# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 46 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 fc ed				ld hl, display_fb1  
801f 22 58 ed				ld (display_fb_active), hl  
8022			  
8022 cd 75 8a				call clear_display  
8025			  
8025 21 5a ed				ld hl, display_fb2  
8028 22 58 ed				ld (display_fb_active), hl  
802b			  
802b cd 75 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 4d ee				ld hl, display_fb0  
8031 22 58 ed				ld (display_fb_active), hl  
8034			  
8034 cd 75 8a				call clear_display  
8037			  
8037			  
8037 cd 1b e1				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd bd e1			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 45 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 98 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 7a 8a			call fill_display  
804e cd 98 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 7a 8a			call fill_display  
8059 cd 98 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 7a 8a			call fill_display  
8064 cd 98 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a 3e 00		        ld a, display_row_1    
806c			else  
806c			        ld a, display_row_1 +10   
806c			endif  
806c 11 79 96			ld de, prom_bootmsg  
806f cd 88 8a			call str_at_display  
8072 cd 98 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b 3e 2a		            LD   A, display_row_3+2  
807d			else  
807d			            LD   A, display_row_3+12  
807d			endif  
807d 11 8e 96			ld de, prom_bootmsg1  
8080 cd 88 8a			call str_at_display  
8083 cd 98 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 b7 ee		ld (debug_mark),a  
8091 32 b8 ee		ld (debug_mark+1),a  
8094 32 b9 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 ba ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 03 ec			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 b7 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 b8 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 b9 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd a3 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 0a ec			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 b7 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 b8 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 b9 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd a3 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 0a ec				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 b7 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 b8 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 b9 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd a3 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd cb 8c				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 03 ec				ld hl, (store_tmp1) 
8110 11 0d ec				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 b7 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 b8 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 b9 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd a3 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 38 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 b7 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 b8 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 b9 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd a3 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 b7 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 b8 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 b9 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd a3 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 b7 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 b8 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 b9 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd a3 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 b7 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 b8 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 b9 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd a3 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd cb 8c			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 0a ec			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 0c ec			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 b7 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 b8 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 b9 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd a3 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 b7 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 b8 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 b9 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd a3 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 0a ec			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 b7 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 b8 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 b9 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 0a ec				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd a3 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 0b ec			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 b7 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 b8 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 b9 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd a3 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 b7 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 b8 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 b9 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd a3 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 0a ec			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 0b ec		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 0d ec		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 16 ec			ld hl, store_page+3+9 
82b5 3a ef eb			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 0a ec			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 b7 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 b8 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 b9 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd a3 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 b7 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 b8 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 b9 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd a3 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd a2 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd a2 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 b7 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 b8 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 b9 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd a3 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 0d ec		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 b7 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 b8 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 b9 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd a3 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 0a ec			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 b7 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 b8 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 b9 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd a3 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 b7 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 b8 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 b9 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd a3 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd cb 8c			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 0a ec			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd cb 8c			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 b7 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 b8 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 b9 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd a3 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 0a ec			ld a, (store_page)	; get file id 
8410 32 fe eb			ld (store_tmpid), a 
8413			 
8413 3a 0c ec			ld a, (store_page+2)    ; get count of extends 
8416 32 fd eb			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 0a ec			ld (store_page), a 
841f 32 0b ec			ld (store_page+1),a 
8422 11 0a ec			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 b7 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 b8 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 b9 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd a3 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a fd eb			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a fe eb			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 b7 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 b8 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 b9 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd a3 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd cb 8c			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 0a ec			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 0a ec			ld (store_page), a 
8482 32 0b ec			ld (store_page+1),a 
8485 11 0a ec			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 b7 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 b8 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 b9 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd a3 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 b7 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 b8 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 b9 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd a3 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd c0 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd a2 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd c0 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd a2 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 b7 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 b8 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 b9 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd a3 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 b7 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 b8 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 b9 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd a3 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd a2 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd a2 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 b7 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 b8 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 b9 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd a3 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 0a ec			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 0a ec			ld (store_page),a 
85a3				 
85a3 32 fe eb			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 0a ec			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 b7 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 b8 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 b9 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd a3 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 0a ec				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 b7 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 b8 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 b9 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd a3 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 f5 eb			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 b7 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 b8 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 b9 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd a3 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 f5 eb			ld (store_tmppageid), hl 
8615				 
8615 3a fe eb			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 0a ec			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 0b ec			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 0c ec			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 0d ec			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 b7 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 b8 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 b9 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd a3 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 0b 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 b7 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 b8 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 b9 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd a3 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 b7 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 b8 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 b9 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd a3 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a f5 eb			ld hl,(store_tmppageid) 
868b 11 0a ec			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 b7 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 b8 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 b9 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd a3 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a fe eb			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 b7 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 b8 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 b9 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd a3 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 08 ec			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 06 ec		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 b7 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 b8 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 b9 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd a3 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 b7 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 b8 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 b9 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd a3 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd cb 8c			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 fb eb			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 06 ec		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 b7 ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 b8 ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 b9 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd a3 94			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 06 ec			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd a2 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 fd eb			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 b7 ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 b8 ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 b9 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd a3 94			call break_point_state  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 05 ec			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 06 ec			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd a2 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 b7 ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 b8 ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 b9 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd a3 94			call break_point_state  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 06 ec			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 08 ec		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 08 ec			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 b7 ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 b8 ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 b9 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd a3 94			call break_point_state  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 b7 ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 b8 ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 b9 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd a3 94			call break_point_state  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd cb 8c			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 fb eb			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 06 ec		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 06 ec			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 b7 ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 b8 ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 b9 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd a3 94			call break_point_state  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 b7 ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 b8 ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 b9 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd a3 94			call break_point_state  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 b7 ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 b8 ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 b9 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd a3 94			call break_point_state  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 b7 ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 b8 ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 b9 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd a3 94			call break_point_state  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 fe eb			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a fe eb			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd cb 8c			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 f5 eb			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 b7 ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 b8 ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 b9 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd a3 94			call break_point_state  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 0a ec			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 b7 ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 b8 ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 b9 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd a3 94			call break_point_state  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 0c ec			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 0c ec			ld (store_page+2), a 
88e3 32 fd eb			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 b7 ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 b8 ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 b9 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd a3 94			call break_point_state  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a f5 eb			ld hl, (store_tmppageid) 
8905 11 0a ec			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd cb 8c			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 f5 eb				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 b7 ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 b8 ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 b9 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd a3 94			call break_point_state  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 0a ec				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a fe eb				ld a, (store_tmpid) 
894b 32 0a ec				ld (store_page), a   ; file id 
894e 3a fd eb				ld a, (store_tmpext)   ; extent for this block 
8951 32 0b ec				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 0c ec				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 b7 ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 b8 ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 b9 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd a3 94			call break_point_state  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a f5 eb			ld hl, (store_tmppageid) 
8985 11 0a ec			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 b7 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 b8 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 b9 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd a3 94			call break_point_state  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a fe eb				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 0a ec			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 0b ec			ld de, store_page+1 
89c1 01 18 01			ld bc, STORE_BLOCK_LOG 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; information window 
8a06			 
8a06			; pass hl with 1st string to display 
8a06			; pass de with 2nd string to display 
8a06			 
8a06			info_panel: 
8a06 e5				push hl 
8a07			 
8a07 2a 58 ed			ld hl, (display_fb_active) 
8a0a e5				push hl    ; future de destination 
8a0b 21 4d ee				ld hl, display_fb0 
8a0e 22 58 ed				ld (display_fb_active), hl 
8a11			 
8a11			;	call clear_display 
8a11			 
8a11				if BASE_CPM 
8a11				ld a, '.' 
8a11				else 
8a11 3e a5			ld a, 165 
8a13				endif 
8a13 cd 7a 8a			call fill_display 
8a16			 
8a16			 
8a16 3e 2d			ld a, display_row_3 + 5 
8a18 cd 88 8a			call str_at_display 
8a1b			 
8a1b e1				pop hl 
8a1c d1				pop de 
8a1d			 
8a1d e5				push hl 
8a1e			 
8a1e			 
8a1e 3e 19			ld a, display_row_2 + 5 
8a20 cd 88 8a			call str_at_display 
8a23			 
8a23			 
8a23 cd 98 8a			call update_display 
8a26 cd 8c 9a			call next_page_prompt 
8a29 cd 75 8a			call clear_display 
8a2c			 
8a2c				 
8a2c 21 fc ed				ld hl, display_fb1 
8a2f 22 58 ed				ld (display_fb_active), hl 
8a32 cd 98 8a			call update_display 
8a35			 
8a35 e1				pop hl 
8a36			 
8a36 c9				ret 
8a37			 
8a37			 
8a37			 
8a37			 
8a37			; TODO windowing? 
8a37			 
8a37			; TODO scroll line up 
8a37			 
8a37			scroll_up: 
8a37			 
8a37 e5				push hl 
8a38 d5				push de 
8a39 c5				push bc 
8a3a			 
8a3a				; get frame buffer  
8a3a			 
8a3a 2a 58 ed			ld hl, (display_fb_active) 
8a3d e5				push hl    ; future de destination 
8a3e			 
8a3e 11 14 00			ld  de, display_cols 
8a41 19				add hl, de 
8a42			 
8a42 d1				pop de 
8a43			 
8a43				;ex de, hl 
8a43 01 4f 00			ld bc, display_fb_len -1  
8a46			;if DEBUG_FORTH_WORDS 
8a46			;	DMARK "SCL" 
8a46			;	CALLMONITOR 
8a46			;endif	 
8a46 ed b0			ldir 
8a48			 
8a48				; wipe bottom row 
8a48			 
8a48			 
8a48 2a 58 ed			ld hl, (display_fb_active) 
8a4b 11 50 00			ld de, display_cols*display_rows 
8a4e 19				add hl, de 
8a4f 06 14			ld b, display_cols 
8a51 3e 20			ld a, ' ' 
8a53			.scwipe: 
8a53 77				ld (hl), a 
8a54 2b				dec hl 
8a55 10 fc			djnz .scwipe 
8a57			 
8a57				;pop hl 
8a57			 
8a57 c1				pop bc 
8a58 d1				pop de 
8a59 e1				pop hl 
8a5a			 
8a5a c9				ret 
8a5b			 
8a5b			 
8a5b			;scroll_upo: 
8a5b			;	ld de, display_row_1 
8a5b			 ;	ld hl, display_row_2 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_2 
8a5b			 ;	ld hl, display_row_3 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_3 
8a5b			 ;	ld hl, display_row_4 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			 
8a5b			; TODO clear row 4 
8a5b			 
8a5b			;	ret 
8a5b			 
8a5b				 
8a5b			scroll_down: 
8a5b			 
8a5b e5				push hl 
8a5c d5				push de 
8a5d c5				push bc 
8a5e			 
8a5e				; get frame buffer  
8a5e			 
8a5e 2a 58 ed			ld hl, (display_fb_active) 
8a61			 
8a61 11 4f 00			ld de, display_fb_len - 1 
8a64 19				add hl, de 
8a65			 
8a65 e5			push hl    ; future de destination 
8a66			 
8a66 11 14 00			ld  de, display_cols 
8a69 ed 52			sbc hl, de 
8a6b			 
8a6b			 
8a6b d1				pop de 
8a6c			 
8a6c			;	ex de, hl 
8a6c 01 4f 00			ld bc, display_fb_len -1  
8a6f			 
8a6f			 
8a6f				 
8a6f			 
8a6f ed b0			ldir 
8a71			 
8a71				; wipe bottom row 
8a71			 
8a71			 
8a71			;	ld hl, (display_fb_active) 
8a71			;;	ld de, display_cols*display_rows 
8a71			;;	add hl, de 
8a71			;	ld b, display_cols 
8a71			;	ld a, ' ' 
8a71			;.scwiped: 
8a71			;	ld (hl), a 
8a71			;	dec hl 
8a71			;	djnz .scwiped 
8a71			 
8a71				;pop hl 
8a71			 
8a71 c1				pop bc 
8a72 d1				pop de 
8a73 e1				pop hl 
8a74			 
8a74 c9				ret 
8a75			;scroll_down: 
8a75			;	ld de, display_row_4 
8a75			;	ld hl, display_row_3 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_3 
8a75			; 	ld hl, display_row_2 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_2 
8a75			;	ld hl, display_row_1 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;;; TODO clear row 1 
8a75			;	ret 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			; clear active frame buffer 
8a75			 
8a75			clear_display: 
8a75 3e 20			ld a, ' ' 
8a77 c3 7a 8a			jp fill_display 
8a7a			 
8a7a			; fill active frame buffer with a char in A 
8a7a			 
8a7a			fill_display: 
8a7a 06 50			ld b,display_fb_len 
8a7c 2a 58 ed			ld hl, (display_fb_active) 
8a7f 77			.fd1:	ld (hl),a 
8a80 23				inc hl 
8a81 10 fc			djnz .fd1 
8a83 23				inc hl 
8a84 3e 00			ld a,0 
8a86 77				ld (hl),a 
8a87			 
8a87			 
8a87 c9				ret 
8a88			; Write string (DE) at pos (A) to active frame buffer 
8a88			 
8a88 2a 58 ed		str_at_display:    ld hl,(display_fb_active) 
8a8b 06 00					ld b,0 
8a8d 4f					ld c,a 
8a8e 09					add hl,bc 
8a8f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8a90 b7			            OR   A              ;Null terminator? 
8a91 c8			            RET  Z              ;Yes, so finished 
8a92 77					ld (hl),a 
8a93 23				inc hl 
8a94 13			            INC  DE             ;Point to next character 
8a95 18 f8		            JR   .sad1     ;Repeat 
8a97 c9					ret 
8a98			 
8a98			; using current frame buffer write to physical display 
8a98			 
8a98			update_display: 
8a98 e5				push hl 
8a99 2a 58 ed			ld hl, (display_fb_active) 
8a9c cd 32 e1			call write_display 
8a9f e1				pop hl 
8aa0 c9				ret 
8aa1			 
8aa1			; TODO scrolling 
8aa1			 
8aa1			 
8aa1			; move cursor right one char 
8aa1			cursor_right: 
8aa1			 
8aa1				; TODO shift right 
8aa1				; TODO if beyond max col 
8aa1				; TODO       cursor_next_line 
8aa1			 
8aa1 c9				ret 
8aa2			 
8aa2			 
8aa2			cursor_next_line: 
8aa2				; TODO first char 
8aa2				; TODO line down 
8aa2				; TODO if past last row 
8aa2				; TODO    scroll up 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			cursor_left: 
8aa3				; TODO shift left 
8aa3				; TODO if beyond left  
8aa3				; TODO     cursor prev line 
8aa3				 
8aa3 c9				ret 
8aa4			 
8aa4			cursor_prev_line: 
8aa4				; TODO last char 
8aa4				; TODO line up 
8aa4				; TODO if past first row 
8aa4				; TODO   scroll down 
8aa4			 
8aa4 c9				ret 
8aa5			 
8aa5			 
8aa5			cout: 
8aa5				; A - char 
8aa5 c9				ret 
8aa6			 
8aa6			 
8aa6			; Display a menu and allow item selection (optional toggle items) 
8aa6			; 
8aa6			; format: 
8aa6			; hl pointer to word array with zero term for items 
8aa6			; e.g.    db item1 
8aa6			;         db .... 
8aa6			;         db 0 
8aa6			; 
8aa6			; a = starting menu item  
8aa6			; 
8aa6			; de = pointer item toggle array   (todo) 
8aa6			; 
8aa6			; returns item selected in a 1-... 
8aa6			; returns 0 if back button pressed 
8aa6			; 
8aa6			; NOTE: Uses system frame buffer to display 
8aa6			; 
8aa6			; LEFT, Q = go back 
8aa6			; RIGHT, SPACE, CR = select 
8aa6			; UP, A - Up 
8aa6			; DOWN, Z - Down 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			menu: 
8aa6			 
8aa6					; keep array pointer 
8aa6			 
8aa6 22 03 ec				ld (store_tmp1), hl 
8aa9 32 01 ec				ld (store_tmp2), a 
8aac			 
8aac					; check for key bounce 
8aac			 
8aac			if BASE_KEV 
8aac			 
8aac			.mbounce:	call cin 
8aac					cp 0 
8aac					jr nz, .mbounce 
8aac			endif 
8aac					; for ease use ex 
8aac			 
8aac					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8aac 21 4d ee				ld hl, display_fb0 
8aaf 22 58 ed				ld (display_fb_active), hl 
8ab2			 
8ab2 cd 75 8a		.mloop:		call clear_display 
8ab5 cd 98 8a				call update_display 
8ab8			 
8ab8					; draw selection id '>' at 1 
8ab8			 
8ab8					; init start of list display 
8ab8			 
8ab8 3e 05				ld a, 5 
8aba 32 ff eb				ld (store_tmp3), a   ; display row count 
8abd 3a 01 ec				ld a,( store_tmp2) 
8ac0 32 02 ec				ld (store_tmp2+1), a   ; display item count 
8ac3			 
8ac3					 
8ac3			.mitem:	 
8ac3			 
8ac3			 
8ac3 3a 02 ec				ld a,(store_tmp2+1) 
8ac6 6f					ld l, a 
8ac7 26 00				ld h, 0 
8ac9 29					add hl, hl 
8aca ed 5b 03 ec			ld de, (store_tmp1) 
8ace 19					add hl, de 
8acf 7e					ld a, (hl) 
8ad0 23					inc hl 
8ad1 66					ld h,(hl) 
8ad2 6f					ld l, a 
8ad3			 
8ad3 cd cb 8c				call ishlzero 
8ad6 28 1a				jr z, .mdone 
8ad8			 
8ad8 eb					ex de, hl 
8ad9 3a ff eb				ld a, (store_tmp3) 
8adc cd 88 8a				call str_at_display 
8adf					 
8adf			 
8adf					; next item 
8adf 3a 02 ec				ld a, (store_tmp2+1) 
8ae2 3c					inc a 
8ae3 32 02 ec				ld (store_tmp2+1), a   ; display item count 
8ae6			 
8ae6			 		; next row 
8ae6			 
8ae6 3a ff eb				ld a, (store_tmp3) 
8ae9 c6 14				add display_cols 
8aeb 32 ff eb				ld (store_tmp3), a 
8aee			 
8aee					; at end of screen? 
8aee			 
8aee fe 10				cp display_rows*4 
8af0 20 d1				jr nz, .mitem 
8af2			 
8af2			 
8af2			.mdone: 
8af2 cd cb 8c				call ishlzero 
8af5 28 08				jr z, .nodn 
8af7			 
8af7 3e 3c				ld a, display_row_4 
8af9 11 78 8b				ld de, .mdown 
8afc cd 88 8a				call str_at_display 
8aff			 
8aff					; draw options to fill the screens with active item on line 1 
8aff					; if current option is 2 or more then display ^ in top 
8aff			 
8aff 3a 01 ec		.nodn:		ld a, (store_tmp2) 
8b02 fe 00				cp 0 
8b04 28 08				jr z, .noup 
8b06			 
8b06 3e 00				ld a, 0 
8b08 11 76 8b				ld de, .mup 
8b0b cd 88 8a				call str_at_display 
8b0e			 
8b0e 3e 02		.noup:		ld a, 2 
8b10 11 74 8b				ld de, .msel 
8b13 cd 88 8a				call str_at_display 
8b16			 
8b16					; if current option + 1 is not null then display V in bottom 
8b16					; get key 
8b16 cd 98 8a				call update_display 
8b19			 
8b19			 
8b19					; handle key 
8b19			 
8b19 cd be e1				call cin_wait 
8b1c			 
8b1c fe 05				cp KEY_UP 
8b1e 28 2b				jr z, .mgoup 
8b20 fe 61				cp 'a' 
8b22 28 27				jr z, .mgoup 
8b24 fe 0a				cp KEY_DOWN 
8b26 28 32				jr z, .mgod 
8b28 fe 7a				cp 'z' 
8b2a 28 2e				jr z, .mgod 
8b2c fe 20				cp ' ' 
8b2e 28 34				jr z, .goend 
8b30 fe 0c				cp KEY_RIGHT 
8b32 28 30				jr z, .goend 
8b34 fe 0d				cp KEY_CR 
8b36 28 2c				jr z, .goend 
8b38 fe 71				cp 'q' 
8b3a 28 0b				jr z, .goback 
8b3c			 
8b3c fe 0b				cp KEY_LEFT 
8b3e 28 07				jr z, .goback 
8b40 fe 08				cp KEY_BS 
8b42 28 03				jr z, .goback 
8b44 c3 b2 8a				jp .mloop 
8b47			 
8b47			.goback: 
8b47 3e 00			ld a, 0 
8b49 18 1d			jr .goend2 
8b4b			 
8b4b				; move up one 
8b4b			.mgoup: 
8b4b 3a 01 ec				ld a, (store_tmp2) 
8b4e fe 00				cp 0 
8b50 ca b2 8a				jp z, .mloop 
8b53 3d					dec a 
8b54 32 01 ec				ld (store_tmp2), a 
8b57 c3 b2 8a				jp .mloop 
8b5a			 
8b5a				; move down one 
8b5a			.mgod: 
8b5a 3a 01 ec				ld a, (store_tmp2) 
8b5d 3c					inc a 
8b5e 32 01 ec				ld (store_tmp2), a 
8b61 c3 b2 8a				jp .mloop 
8b64			 
8b64			 
8b64			.goend: 
8b64					; get selected item number 
8b64			 
8b64 3a 01 ec				ld a, (store_tmp2) 
8b67 3c					inc a 
8b68			 
8b68			.goend2: 
8b68 f5					push af 
8b69			 
8b69					; restore active fb 
8b69					; TODO BUG assumes fb1 
8b69			 
8b69 21 fc ed				ld hl, display_fb1 
8b6c 22 58 ed				ld (display_fb_active), hl 
8b6f			 
8b6f					; restore main regs 
8b6f			 
8b6f			 
8b6f cd 98 8a				call update_display 
8b72			 
8b72 f1					pop af 
8b73			 
8b73 c9				ret 
8b74			 
8b74 .. 00		.msel:   db ">",0 
8b76 .. 00		.mup:   db "^",0 
8b78 .. 00		.mdown:   db "v",0 
8b7a			 
8b7a			 
8b7a			; eof 
8b7a			 
# End of file firmware_display.asm
8b7a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8b7a			; random number generators 
8b7a			 
8b7a			 
8b7a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8b7a			 
8b7a			 
8b7a			;-----> Generate a random number 
8b7a			; output a=answer 0<=a<=255 
8b7a			; all registers are preserved except: af 
8b7a			random: 
8b7a e5			        push    hl 
8b7b d5			        push    de 
8b7c 2a 3a ed		        ld      hl,(randData) 
8b7f ed 5f		        ld      a,r 
8b81 57			        ld      d,a 
8b82 5e			        ld      e,(hl) 
8b83 19			        add     hl,de 
8b84 85			        add     a,l 
8b85 ac			        xor     h 
8b86 22 3a ed		        ld      (randData),hl 
8b89 d1			        pop     de 
8b8a e1			        pop     hl 
8b8b c9			        ret 
8b8c			 
8b8c			 
8b8c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8b8c			 
8b8c			 
8b8c			 
8b8c			;------LFSR------ 
8b8c			;James Montelongo 
8b8c			;optimized by Spencer Putt 
8b8c			;out: 
8b8c			; a = 8 bit random number 
8b8c			RandLFSR: 
8b8c 21 40 ed		        ld hl,LFSRSeed+4 
8b8f 5e			        ld e,(hl) 
8b90 23			        inc hl 
8b91 56			        ld d,(hl) 
8b92 23			        inc hl 
8b93 4e			        ld c,(hl) 
8b94 23			        inc hl 
8b95 7e			        ld a,(hl) 
8b96 47			        ld b,a 
8b97 cb 13		        rl e  
8b99 cb 12			rl d 
8b9b cb 11		        rl c  
8b9d 17				rla 
8b9e cb 13		        rl e  
8ba0 cb 12			rl d 
8ba2 cb 11		        rl c  
8ba4 17				rla 
8ba5 cb 13		        rl e  
8ba7 cb 12			rl d 
8ba9 cb 11		        rl c  
8bab 17				rla 
8bac 67			        ld h,a 
8bad cb 13		        rl e  
8baf cb 12			rl d 
8bb1 cb 11		        rl c  
8bb3 17				rla 
8bb4 a8			        xor b 
8bb5 cb 13		        rl e  
8bb7 cb 12			rl d 
8bb9 ac			        xor h 
8bba a9			        xor c 
8bbb aa			        xor d 
8bbc 21 42 ed		        ld hl,LFSRSeed+6 
8bbf 11 43 ed		        ld de,LFSRSeed+7 
8bc2 01 07 00		        ld bc,7 
8bc5 ed b8		        lddr 
8bc7 12			        ld (de),a 
8bc8 c9			        ret 
8bc9			 
8bc9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bc9			 
8bc9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bc9			 
8bc9			 
8bc9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bc9			 
8bc9			prng16: 
8bc9			;Inputs: 
8bc9			;   (seed1) contains a 16-bit seed value 
8bc9			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bc9			;Outputs: 
8bc9			;   HL is the result 
8bc9			;   BC is the result of the LCG, so not that great of quality 
8bc9			;   DE is preserved 
8bc9			;Destroys: 
8bc9			;   AF 
8bc9			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bc9			;160cc 
8bc9			;26 bytes 
8bc9 2a 34 ed		    ld hl,(seed1) 
8bcc 44			    ld b,h 
8bcd 4d			    ld c,l 
8bce 29			    add hl,hl 
8bcf 29			    add hl,hl 
8bd0 2c			    inc l 
8bd1 09			    add hl,bc 
8bd2 22 34 ed		    ld (seed1),hl 
8bd5 2a 32 ed		    ld hl,(seed2) 
8bd8 29			    add hl,hl 
8bd9 9f			    sbc a,a 
8bda e6 2d		    and %00101101 
8bdc ad			    xor l 
8bdd 6f			    ld l,a 
8bde 22 32 ed		    ld (seed2),hl 
8be1 09			    add hl,bc 
8be2 c9			    ret 
8be3			 
8be3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8be3			 
8be3			rand32: 
8be3			;Inputs: 
8be3			;   (seed1_0) holds the lower 16 bits of the first seed 
8be3			;   (seed1_1) holds the upper 16 bits of the first seed 
8be3			;   (seed2_0) holds the lower 16 bits of the second seed 
8be3			;   (seed2_1) holds the upper 16 bits of the second seed 
8be3			;   **NOTE: seed2 must be non-zero 
8be3			;Outputs: 
8be3			;   HL is the result 
8be3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8be3			;Destroys: 
8be3			;   AF 
8be3			;Tested and passes all CAcert tests 
8be3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8be3			;it has a period of 18,446,744,069,414,584,320 
8be3			;roughly 18.4 quintillion. 
8be3			;LFSR taps: 0,2,6,7  = 11000101 
8be3			;291cc 
8be3			;seed1_0=$+1 
8be3			;    ld hl,12345 
8be3			;seed1_1=$+1 
8be3			;    ld de,6789 
8be3			;    ld b,h 
8be3			;    ld c,l 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    inc l 
8be3			;    add hl,bc 
8be3			;    ld (seed1_0),hl 
8be3			;    ld hl,(seed1_1) 
8be3			;    adc hl,de 
8be3			;    ld (seed1_1),hl 
8be3			;    ex de,hl 
8be3			;seed2_0=$+1 
8be3			;    ld hl,9876 
8be3			;seed2_1=$+1 
8be3			;    ld bc,54321 
8be3			;    add hl,hl \ rl c \ rl b 
8be3			;    ld (seed2_1),bc 
8be3			;    sbc a,a 
8be3			;    and %11000101 
8be3			;    xor l 
8be3			;    ld l,a 
8be3			;    ld (seed2_0),hl 
8be3			;    ex de,hl 
8be3			;    add hl,bc 
8be3			;    ret 
8be3			; 
8be3			 
8be3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8be3			; 20 bytes, 86 cycles (excluding ret) 
8be3			 
8be3			; returns   hl = pseudorandom number 
8be3			; corrupts   a 
8be3			 
8be3			; generates 16-bit pseudorandom numbers with a period of 65535 
8be3			; using the xorshift method: 
8be3			 
8be3			; hl ^= hl << 7 
8be3			; hl ^= hl >> 9 
8be3			; hl ^= hl << 8 
8be3			 
8be3			; some alternative shift triplets which also perform well are: 
8be3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8be3			 
8be3			;  org 32768 
8be3			 
8be3			xrnd: 
8be3 2a 38 ed		  ld hl,(xrandc)       ; seed must not be 0 
8be6 3e 00		  ld a,0 
8be8 bd			  cp l 
8be9 20 02		  jr nz, .xrnd1 
8beb 2e 01		  ld l, 1 
8bed			.xrnd1: 
8bed			 
8bed 7c			  ld a,h 
8bee 1f			  rra 
8bef 7d			  ld a,l 
8bf0 1f			  rra 
8bf1 ac			  xor h 
8bf2 67			  ld h,a 
8bf3 7d			  ld a,l 
8bf4 1f			  rra 
8bf5 7c			  ld a,h 
8bf6 1f			  rra 
8bf7 ad			  xor l 
8bf8 6f			  ld l,a 
8bf9 ac			  xor h 
8bfa 67			  ld h,a 
8bfb			 
8bfb 22 38 ed		  ld (xrandc),hl 
8bfe			 
8bfe c9			  ret 
8bff			;  
8bff			 
8bff			 
8bff			;;;; int maths 
8bff			 
8bff			; https://map.grauw.nl/articles/mult_div_shifts.php 
8bff			; Divide 16-bit values (with 16-bit result) 
8bff			; In: Divide BC by divider DE 
8bff			; Out: BC = result, HL = rest 
8bff			; 
8bff			Div16: 
8bff 21 00 00		    ld hl,0 
8c02 78			    ld a,b 
8c03 06 08		    ld b,8 
8c05			Div16_Loop1: 
8c05 17			    rla 
8c06 ed 6a		    adc hl,hl 
8c08 ed 52		    sbc hl,de 
8c0a 30 01		    jr nc,Div16_NoAdd1 
8c0c 19			    add hl,de 
8c0d			Div16_NoAdd1: 
8c0d 10 f6		    djnz Div16_Loop1 
8c0f 17			    rla 
8c10 2f			    cpl 
8c11 47			    ld b,a 
8c12 79			    ld a,c 
8c13 48			    ld c,b 
8c14 06 08		    ld b,8 
8c16			Div16_Loop2: 
8c16 17			    rla 
8c17 ed 6a		    adc hl,hl 
8c19 ed 52		    sbc hl,de 
8c1b 30 01		    jr nc,Div16_NoAdd2 
8c1d 19			    add hl,de 
8c1e			Div16_NoAdd2: 
8c1e 10 f6		    djnz Div16_Loop2 
8c20 17			    rla 
8c21 2f			    cpl 
8c22 41			    ld b,c 
8c23 4f			    ld c,a 
8c24 c9			ret 
8c25			 
8c25			 
8c25			;http://z80-heaven.wikidot.com/math 
8c25			; 
8c25			;Inputs: 
8c25			;     DE and A are factors 
8c25			;Outputs: 
8c25			;     A is not changed 
8c25			;     B is 0 
8c25			;     C is not changed 
8c25			;     DE is not changed 
8c25			;     HL is the product 
8c25			;Time: 
8c25			;     342+6x 
8c25			; 
8c25			Mult16: 
8c25			 
8c25 06 08		     ld b,8          ;7           7 
8c27 21 00 00		     ld hl,0         ;10         10 
8c2a 29			       add hl,hl     ;11*8       88 
8c2b 07			       rlca          ;4*8        32 
8c2c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c2e 19			         add hl,de   ;--         -- 
8c2f 10 f9		       djnz $-5      ;13*7+8     99 
8c31 c9			ret 
8c32			 
8c32			; 
8c32			; Square root of 16-bit value 
8c32			; In:  HL = value 
8c32			; Out:  D = result (rounded down) 
8c32			; 
8c32			;Sqr16: 
8c32			;    ld de,#0040 
8c32			;    ld a,l 
8c32			;    ld l,h 
8c32			;    ld h,d 
8c32			;    or a 
8c32			;    ld b,8 
8c32			;Sqr16_Loop: 
8c32			;    sbc hl,de 
8c32			;    jr nc,Sqr16_Skip 
8c32			;    add hl,de 
8c32			;Sqr16_Skip: 
8c32			;    ccf 
8c32			;    rl d 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    djnz Sqr16_Loop 
8c32			;    ret 
8c32			; 
8c32			; 
8c32			; Divide 8-bit values 
8c32			; In: Divide E by divider C 
8c32			; Out: A = result, B = rest 
8c32			; 
8c32			Div8: 
8c32 af			    xor a 
8c33 06 08		    ld b,8 
8c35			Div8_Loop: 
8c35 cb 13		    rl e 
8c37 17			    rla 
8c38 91			    sub c 
8c39 30 01		    jr nc,Div8_NoAdd 
8c3b 81			    add a,c 
8c3c			Div8_NoAdd: 
8c3c 10 f7		    djnz Div8_Loop 
8c3e 47			    ld b,a 
8c3f 7b			    ld a,e 
8c40 17			    rla 
8c41 2f			    cpl 
8c42 c9			    ret 
8c43			 
8c43			; 
8c43			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c43			; In: Multiply A with DE 
8c43			; Out: HL = result 
8c43			; 
8c43			Mult12U: 
8c43 2e 00		    ld l,0 
8c45 87			    add a,a 
8c46 30 01		    jr nc,Mult12U_NoAdd0 
8c48 19			    add hl,de 
8c49			Mult12U_NoAdd0: 
8c49 29			    add hl,hl 
8c4a 87			    add a,a 
8c4b 30 01		    jr nc,Mult12U_NoAdd1 
8c4d 19			    add hl,de 
8c4e			Mult12U_NoAdd1: 
8c4e 29			    add hl,hl 
8c4f 87			    add a,a 
8c50 30 01		    jr nc,Mult12U_NoAdd2 
8c52 19			    add hl,de 
8c53			Mult12U_NoAdd2: 
8c53 29			    add hl,hl 
8c54 87			    add a,a 
8c55 30 01		    jr nc,Mult12U_NoAdd3 
8c57 19			    add hl,de 
8c58			Mult12U_NoAdd3: 
8c58 29			    add hl,hl 
8c59 87			    add a,a 
8c5a 30 01		    jr nc,Mult12U_NoAdd4 
8c5c 19			    add hl,de 
8c5d			Mult12U_NoAdd4: 
8c5d 29			    add hl,hl 
8c5e 87			    add a,a 
8c5f 30 01		    jr nc,Mult12U_NoAdd5 
8c61 19			    add hl,de 
8c62			Mult12U_NoAdd5: 
8c62 29			    add hl,hl 
8c63 87			    add a,a 
8c64 30 01		    jr nc,Mult12U_NoAdd6 
8c66 19			    add hl,de 
8c67			Mult12U_NoAdd6: 
8c67 29			    add hl,hl 
8c68 87			    add a,a 
8c69 d0			    ret nc 
8c6a 19			    add hl,de 
8c6b c9			    ret 
8c6c			 
8c6c			; 
8c6c			; Multiply 8-bit value with a 16-bit value (right rotating) 
8c6c			; In: Multiply A with DE 
8c6c			;      Put lowest value in A for most efficient calculation 
8c6c			; Out: HL = result 
8c6c			; 
8c6c			Mult12R: 
8c6c 21 00 00		    ld hl,0 
8c6f			Mult12R_Loop: 
8c6f cb 3f		    srl a 
8c71 30 01		    jr nc,Mult12R_NoAdd 
8c73 19			    add hl,de 
8c74			Mult12R_NoAdd: 
8c74 cb 23		    sla e 
8c76 cb 12		    rl d 
8c78 b7			    or a 
8c79 c2 6f 8c		    jp nz,Mult12R_Loop 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 16-bit values (with 32-bit result) 
8c7d			; In: Multiply BC with DE 
8c7d			; Out: BCHL = result 
8c7d			; 
8c7d			Mult32: 
8c7d 79			    ld a,c 
8c7e 48			    ld c,b 
8c7f 21 00 00		    ld hl,0 
8c82 06 10		    ld b,16 
8c84			Mult32_Loop: 
8c84 29			    add hl,hl 
8c85 17			    rla 
8c86 cb 11		    rl c 
8c88 30 07		    jr nc,Mult32_NoAdd 
8c8a 19			    add hl,de 
8c8b ce 00		    adc a,0 
8c8d d2 91 8c		    jp nc,Mult32_NoAdd 
8c90 0c			    inc c 
8c91			Mult32_NoAdd: 
8c91 10 f1		    djnz Mult32_Loop 
8c93 41			    ld b,c 
8c94 4f			    ld c,a 
8c95 c9			    ret 
8c96			 
8c96			 
8c96			 
8c96			; 
8c96			; Multiply 8-bit values 
8c96			; In:  Multiply H with E 
8c96			; Out: HL = result 
8c96			; 
8c96			Mult8: 
8c96 16 00		    ld d,0 
8c98 6a			    ld l,d 
8c99 06 08		    ld b,8 
8c9b			Mult8_Loop: 
8c9b 29			    add hl,hl 
8c9c 30 01		    jr nc,Mult8_NoAdd 
8c9e 19			    add hl,de 
8c9f			Mult8_NoAdd: 
8c9f 10 fa		    djnz Mult8_Loop 
8ca1 c9			    ret 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			;;http://z80-heaven.wikidot.com/math 
8ca2			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ca2			; 
8ca2			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ca2			;     ld a,16        ;7 
8ca2			;     ld hl,0        ;10 
8ca2			;     jp $+5         ;10 
8ca2			;.DivLoop: 
8ca2			;       add hl,bc    ;-- 
8ca2			;       dec a        ;64 
8ca2			;       jr z,.DivLoopEnd        ;86 
8ca2			; 
8ca2			;       sla e        ;128 
8ca2			;       rl d         ;128 
8ca2			;       adc hl,hl    ;240 
8ca2			;       sbc hl,bc    ;240 
8ca2			;       jr nc,.DivLoop ;23|21 
8ca2			;       inc e        ;-- 
8ca2			;       jp .DivLoop+1 
8ca2			; 
8ca2			;.DivLoopEnd: 
8ca2			 
8ca2			;HL_Div_C: 
8ca2			;Inputs: 
8ca2			;     HL is the numerator 
8ca2			;     C is the denominator 
8ca2			;Outputs: 
8ca2			;     A is the remainder 
8ca2			;     B is 0 
8ca2			;     C is not changed 
8ca2			;     DE is not changed 
8ca2			;     HL is the quotient 
8ca2			; 
8ca2			;       ld b,16 
8ca2			;       xor a 
8ca2			;         add hl,hl 
8ca2			;         rla 
8ca2			;         cp c 
8ca2			;         jr c,$+4 
8ca2			;           inc l 
8ca2			;           sub c 
8ca2			;         djnz $-7 
8ca2			 
8ca2			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ca2			 
8ca2			addatohl: 
8ca2 85			    add   a, l    ; A = A+L 
8ca3 6f			    ld    l, a    ; L = A+L 
8ca4 8c			    adc   a, h    ; A = A+L+H+carry 
8ca5 95			    sub   l       ; A = H+carry 
8ca6 67			    ld    h, a    ; H = H+carry 
8ca7 c9			ret 
8ca8			 
8ca8			addatode: 
8ca8 83			    add   a, e    ; A = A+L 
8ca9 5f			    ld    e, a    ; L = A+L 
8caa 8a			    adc   a, d    ; A = A+L+H+carry 
8cab 93			    sub   e       ; A = H+carry 
8cac 57			    ld    d, a    ; H = H+carry 
8cad c9			ret 
8cae			 
8cae			 
8cae			addatobc: 
8cae 81			    add   a, c    ; A = A+L 
8caf 4f			    ld    c, a    ; L = A+L 
8cb0 88			    adc   a, b    ; A = A+L+H+carry 
8cb1 91			    sub   c       ; A = H+carry 
8cb2 47			    ld    b, a    ; H = H+carry 
8cb3 c9			ret 
8cb4			 
8cb4			subafromhl: 
8cb4			   ; If A=0 do nothing 
8cb4			    ; Otherwise flip A's sign. Since 
8cb4			    ; the upper byte becomes -1, also 
8cb4			    ; substract 1 from H. 
8cb4 ed 44		    neg 
8cb6 ca bf 8c		    jp    z, Skip 
8cb9 25			    dec   h 
8cba			     
8cba			    ; Now add the low byte as usual 
8cba			    ; Two's complement takes care of 
8cba			    ; ensuring the result is correct 
8cba 85			    add   a, l 
8cbb 6f			    ld    l, a 
8cbc 8c			    adc   a, h 
8cbd 95			    sub   l 
8cbe 67			    ld    h, a 
8cbf			Skip: 
8cbf c9				ret 
8cc0			 
8cc0			 
8cc0			; compare hl and de 
8cc0			; returns:  
8cc0			; if hl = de, z=1, s=0, c0=0 
8cc0			; if hl > de, z=0, s=0, c=0 
8cc0			; if hl < de, z=0, s=1, c=1 
8cc0			cmp16:	 
8cc0 b7				or a 
8cc1 ed 52			sbc hl,de 
8cc3 e0				ret po 
8cc4 7c				ld a,h 
8cc5 1f				rra 
8cc6 ee 40			xor 01000000B 
8cc8 37				scf 
8cc9 8f				adc a,a 
8cca c9				ret 
8ccb			 
8ccb			 
8ccb			; test if hl contains zero   - A is destroyed 
8ccb			 
8ccb			ishlzero:    
8ccb b7				or a     ; reset flags 
8ccc 7c				ld a, h 
8ccd b5				or l        	 
8cce			 
8cce c9				ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			 
8ccf			if FORTH_ENABLE_FLOATMATH 
8ccf			;include "float/bbcmath.z80" 
8ccf			include "float/lpfpcalc.asm" 
8ccf			endif 
8ccf			 
8ccf			 
8ccf			; eof 
8ccf			 
# End of file firmware_maths.asm
8ccf			include "firmware_strings.asm"   ; string handling  
8ccf			 
8ccf			 
8ccf			; TODO string len 
8ccf			; input text string, end on cr with zero term 
8ccf			; a offset into frame buffer to start prompt 
8ccf			; d is max length 
8ccf			; e is display size TODO 
8ccf			; c is current cursor position 
8ccf			; hl is ptr to where string will be stored 
8ccf			 
8ccf			 
8ccf			; TODO check limit of buffer for new inserts 
8ccf			; TODO check insert does not push beyond buffer 
8ccf			; TODO scroll in a limited display area 
8ccf			; TODO scroll whole screen on page wrap 
8ccf			 
8ccf			 
8ccf			; TODO handle KEY_PREVWORD 
8ccf			; TODO handle KEY_NEXTWORD 
8ccf			; TODO handle KEY_HOME 
8ccf			; TODO handle KEY_END 
8ccf			; TODO use LCD cursor? 
8ccf			 
8ccf 32 b0 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8cd2 81					add c 
8cd3 32 ae ee				ld (input_at_cursor),a	; save draw pos of cursor 
8cd6 22 b3 ee				ld (input_start), hl     ; save ptr to buffer 
8cd9 79					ld a, c 
8cda cd a2 8c				call addatohl 
8cdd 22 b5 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ce0 7a					ld a,d 
8ce1 32 b2 ee			        ld (input_size), a       ; save length of input area 
8ce4 79					ld a, c 
8ce5 32 a1 ee				ld (input_cursor),a      ; init cursor start position  
8ce8 7b					ld a,e 
8ce9 32 b1 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8cec					 
8cec					 
8cec			 
8cec			;		ld a,(input_ptr) 
8cec			;		ld (input_under_cursor),a 	; save what is under the cursor 
8cec			 
8cec			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8cec					; init cursor shape if not set by the cin routines 
8cec 21 50 ed				ld hl, cursor_shape 
8cef 3e ff				ld a, 255 
8cf1 77					ld (hl), a 
8cf2 23					inc hl 
8cf3 3e 00				ld a, 0 
8cf5 77					ld (hl), a 
8cf6			 
8cf6 3e 0f				ld a, CUR_BLINK_RATE 
8cf8 32 ac ee				ld (input_cur_flash), a 
8cfb 3e 01				ld a, 1 
8cfd 32 ab ee				ld (input_cur_onoff),a 
8d00			 
8d00			;	if DEBUG_INPUT 
8d00			;		push af 
8d00			;		ld a, 'I' 
8d00			;		ld (debug_mark),a 
8d00			;		pop af 
8d00			;		CALLMONITOR 
8d00			;	endif 
8d00			.is1:		; main entry loop 
8d00			 
8d00			 
8d00			 
8d00					; pause 1ms 
8d00			 
8d00 3e 01				ld a, 1 
8d02 cd d7 89				call aDelayInMS 
8d05			 
8d05					; dec flash counter 
8d05 3a ac ee				ld a, (input_cur_flash) 
8d08 3d					dec a 
8d09 32 ac ee				ld (input_cur_flash), a 
8d0c fe 00				cp 0 
8d0e 20 0d				jr nz, .nochgstate 
8d10			 
8d10			 
8d10					; change state 
8d10 3a ab ee				ld a,(input_cur_onoff) 
8d13 ed 44				neg 
8d15 32 ab ee				ld (input_cur_onoff),a 
8d18			 
8d18			 
8d18					; reset on change of state 
8d18 3e 0f				ld a, CUR_BLINK_RATE 
8d1a 32 ac ee				ld (input_cur_flash), a 
8d1d			 
8d1d			.nochgstate: 
8d1d					 
8d1d					 
8d1d			 
8d1d					; display cursor  
8d1d			 
8d1d			;		ld hl, (input_start) 
8d1d			;		ld a, (input_cursor) 
8d1d			;		call addatohl 
8d1d			 
8d1d					; get char under cursor and replace with cursor 
8d1d 2a b5 ee		ld hl, (input_ptr) 
8d20			;		ld a, (hl) 
8d20			;		ld (input_under_cursor),a 
8d20			;		ld a, '_' 
8d20			;		ld (hl), a 
8d20			 
8d20					; display string 
8d20			 
8d20 ed 5b b3 ee			ld de, (input_start) 
8d24 3a b0 ee				ld a, (input_at_pos) 
8d27 cd 88 8a				call str_at_display 
8d2a			;	        call update_display 
8d2a			 
8d2a					; find place to put the cursor 
8d2a			;		add h 
8d2a			;		ld l, display_row_1 
8d2a			;		sub l 
8d2a			; (input_at_pos) 
8d2a					;ld c, a 
8d2a			;		ld a, (input_cursor) 
8d2a			;		ld l, (input_at_pos) 
8d2a			;		;ld b, h 
8d2a			;		add l 
8d2a			;		ld (input_at_cursor),a 
8d2a					;ld l,h 
8d2a			 
8d2a			;		ld h, 0 
8d2a			;		ld l,(input_at_pos) 
8d2a			;		ld a, (input_cursor) 
8d2a			;		call addatohl 
8d2a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d2a			;		call subafromhl 
8d2a			;		ld a,l 
8d2a			;		ld (input_at_cursor), a 
8d2a			 
8d2a				if DEBUG_INPUT 
8d2a					ld a, (hardware_diag) 
8d2a					cp 0 
8d2a					jr z, .skip_input_diag 
8d2a			 
8d2a					ld a,(input_at_pos) 
8d2a					ld hl, LFSRSeed 
8d2a					call hexout 
8d2a					ld a, (input_cursor) 
8d2a					ld hl, LFSRSeed+2 
8d2a					call hexout 
8d2a					ld a,(input_at_cursor) 
8d2a					ld hl, LFSRSeed+4 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_onoff) 
8d2a					ld hl, LFSRSeed+6 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_flash) 
8d2a					ld hl, LFSRSeed+8 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_len) 
8d2a					ld hl, LFSRSeed+10 
8d2a					call hexout 
8d2a					ld hl, LFSRSeed+12 
8d2a					ld a, 0 
8d2a					ld (hl),a 
8d2a					ld a, display_row_4 
8d2a					ld de, LFSRSeed 
8d2a					call str_at_display 
8d2a					.skip_input_diag: 
8d2a				endif 
8d2a			 
8d2a					; decide on if we are showing the cursor this time round 
8d2a			 
8d2a 3a ab ee				ld a, (input_cur_onoff) 
8d2d fe ff				cp 255 
8d2f 28 13				jr z, .skipcur 
8d31			 
8d31			 
8d31 3a ae ee				ld a,(input_at_cursor) 
8d34 11 50 ed				ld de, cursor_shape 
8d37 cd 88 8a				call str_at_display 
8d3a			 
8d3a					; save length of current input string 
8d3a 2a b3 ee				ld hl, (input_start) 
8d3d cd 00 91				call strlenz 
8d40 7d					ld a,l 
8d41 32 a6 ee				ld (input_len),a 
8d44			 
8d44			.skipcur: 
8d44			 
8d44 cd 98 8a			        call update_display 
8d47					 
8d47			 
8d47			 
8d47					; wait 
8d47				 
8d47					; TODO loop without wait to flash the cursor and char under cursor	 
8d47 cd c4 e1				call cin    ; _wait 
8d4a			 
8d4a fe 00				cp 0 
8d4c ca 00 8d				jp z, .is1 
8d4f			 
8d4f					; get ptr to char to input into 
8d4f			 
8d4f 4f					ld c,a 
8d50 2a b3 ee				ld hl, (input_start) 
8d53 3a a1 ee				ld a, (input_cursor) 
8d56 cd a2 8c				call addatohl 
8d59 22 b5 ee				ld (input_ptr), hl 
8d5c 79					ld a,c 
8d5d			 
8d5d					; replace char under cursor 
8d5d			 
8d5d			;		ld hl, (input_ptr) 
8d5d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d5d			;		ld (hl), a 
8d5d			 
8d5d			;	if DEBUG_INPUT 
8d5d			;		push af 
8d5d			;		ld a, 'i' 
8d5d			;		ld (debug_mark),a 
8d5d			;		pop af 
8d5d			;		CALLMONITOR 
8d5d			;	endif 
8d5d fe 0e				cp KEY_HOME 
8d5f 20 0e				jr nz, .iske 
8d61			 
8d61 3a b0 ee				ld a, (input_at_pos) 
8d64 32 ae ee				ld (input_at_cursor),a 
8d67 3e 00				ld a, 0 
8d69 32 a1 ee				ld (input_cursor), a 
8d6c c3 00 8d				jp .is1 
8d6f					 
8d6f fe 0f		.iske:		cp KEY_END 
8d71 20 03				jr nz, .isknw 
8d73 c3 00 8d				jp .is1 
8d76			 
8d76 fe 06		.isknw:		cp KEY_NEXTWORD 
8d78 20 1b				jr nz, .iskpw 
8d7a			 
8d7a 2a b5 ee		.isknwm:	ld hl, (input_ptr) 
8d7d 7e					ld a,(hl)	 
8d7e fe 00				cp 0 
8d80 ca 00 8d				jp z, .is1    ; end of string 
8d83 fe 20				cp ' ' 
8d85 ca 00 8d				jp z, .is1    ; end of word 
8d88 23					inc hl 
8d89 22 b5 ee				ld (input_ptr), hl 
8d8c 3a ae ee				ld a, (input_at_cursor) 
8d8f 3c					inc a 
8d90 32 ae ee				ld (input_at_cursor), a 
8d93 18 e5				jr .isknwm 
8d95			 
8d95 fe 07		.iskpw:		cp KEY_PREVWORD 
8d97 20 1b				jr nz, .iskl 
8d99			.iskpwm:	 
8d99 2a b5 ee				ld hl, (input_ptr) 
8d9c 7e					ld a,(hl)	 
8d9d fe 00				cp 0  
8d9f ca 00 8d				jp z, .is1    ; end of string 
8da2 fe 20				cp ' ' 
8da4 ca 00 8d				jp z, .is1    ; end of word 
8da7 2b					dec hl 
8da8 22 b5 ee				ld (input_ptr), hl 
8dab 3a ae ee				ld a, (input_at_cursor) 
8dae 3d					dec a 
8daf 32 ae ee				ld (input_at_cursor), a 
8db2 18 e5				jr .iskpwm 
8db4			 
8db4			 
8db4 fe 0b		.iskl:		cp KEY_LEFT 
8db6 20 27				jr nz, .isk1 
8db8			 
8db8 3a a1 ee				ld a, (input_cursor) 
8dbb			 
8dbb fe 00				cp 0 
8dbd ca 00 8d				jp z, .is1 		; at start of line to ignore  
8dc0			 
8dc0 3d					dec  a 		; TODO check underflow 
8dc1 32 a1 ee				ld (input_cursor), a 
8dc4			 
8dc4 2a b5 ee				ld hl, (input_ptr) 
8dc7 2b					dec hl 
8dc8 22 b5 ee				ld (input_ptr), hl 
8dcb					 
8dcb 3a ae ee				ld a, (input_at_cursor) 
8dce 3d					dec a 
8dcf 32 ae ee				ld (input_at_cursor), a 
8dd2			 
8dd2 3e 01				ld a, 1		; show cursor moving 
8dd4 32 ab ee				ld (input_cur_onoff),a 
8dd7 3e 0f				ld a, CUR_BLINK_RATE 
8dd9 32 ac ee				ld (input_cur_flash), a 
8ddc			 
8ddc c3 00 8d				jp .is1 
8ddf			 
8ddf fe 0c		.isk1:		cp KEY_RIGHT 
8de1 20 2a				jr nz, .isk2 
8de3			 
8de3 3a a6 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8de6 5f					ld e,a 
8de7 3a a1 ee				ld a, (input_cursor) 
8dea bb					cp e 
8deb ca 00 8d				jp z, .is1		; at the end of string so dont go right 
8dee			 
8dee 3c					inc  a 		; TODO check overflow 
8def 32 a1 ee				ld (input_cursor), a 
8df2			 
8df2 3a ae ee				ld a, (input_at_cursor) 
8df5 3c					inc a 
8df6 32 ae ee				ld (input_at_cursor), a 
8df9			 
8df9 2a b5 ee				ld hl, (input_ptr) 
8dfc 23					inc hl 
8dfd 22 b5 ee				ld (input_ptr), hl 
8e00			 
8e00 3e 01				ld a, 1		; show cursor moving 
8e02 32 ab ee				ld (input_cur_onoff),a 
8e05 3e 0f				ld a, CUR_BLINK_RATE 
8e07 32 ac ee				ld (input_cur_flash), a 
8e0a			 
8e0a c3 00 8d				jp .is1 
8e0d			 
8e0d fe 05		.isk2:		cp KEY_UP 
8e0f			 
8e0f 20 26				jr nz, .isk3 
8e11			 
8e11					; swap last command with the current on 
8e11			 
8e11					; move cursor to start of string 
8e11 2a b3 ee				ld hl, (input_start) 
8e14 22 b5 ee				ld (input_ptr), hl 
8e17			 
8e17 3a b0 ee				ld a, (input_at_pos) 
8e1a 32 ae ee				ld (input_at_cursor), a 
8e1d			 
8e1d 3e 00				ld a, 0 
8e1f 32 a1 ee				ld (input_cursor), a 
8e22					 
8e22					; swap input and last command buffers 
8e22			 
8e22 21 78 e7				ld hl, os_cli_cmd 
8e25 11 77 e8				ld de, os_last_cmd 
8e28 06 ff				ld b, 255 
8e2a 7e			.swap1:		ld a, (hl) 
8e2b 4f					ld c,a 
8e2c 1a					ld a, (de) 
8e2d 77					ld (hl), a 
8e2e 79					ld a,c 
8e2f 12					ld (de),a 
8e30 23					inc hl 
8e31 13					inc de 
8e32 10 f6				djnz .swap1 
8e34			 
8e34			 
8e34			 
8e34			 
8e34			 
8e34 c3 00 8d				jp .is1 
8e37			 
8e37 fe 08		.isk3:		cp KEY_BS 
8e39 20 3c				jr nz, .isk4 
8e3b			 
8e3b 3a a1 ee				ld a, (input_cursor) 
8e3e			 
8e3e fe 00				cp 0 
8e40 ca 00 8d				jp z, .is1 		; at start of line to ignore  
8e43			 
8e43 3d					dec  a 		; TODO check underflow 
8e44 32 a1 ee				ld (input_cursor), a 
8e47			 
8e47					; hl is source 
8e47					; de needs to be source - 1 
8e47			 
8e47			;		ld a, 0 
8e47			;		dec hl 
8e47			;		ld (hl), a 
8e47			 
8e47 2a b5 ee				ld hl, (input_ptr) 
8e4a 2b					dec hl 
8e4b 22 b5 ee				ld (input_ptr), hl 
8e4e			 
8e4e					; shift all data 
8e4e			 
8e4e e5					push hl 
8e4f 23					inc hl 
8e50 d1					pop de 
8e51 3a a6 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e54 4f					ld c,a 
8e55 06 00				ld b,0 
8e57 ed b0				ldir  
8e59			 
8e59			 
8e59			 
8e59			 
8e59 3a ae ee				ld a, (input_at_cursor) 
8e5c 3d					dec a 
8e5d 32 ae ee				ld (input_at_cursor), a 
8e60			 
8e60			 
8e60 3e 01				ld a, 1		; show cursor moving 
8e62 32 ab ee				ld (input_cur_onoff),a 
8e65 3e 0f				ld a, CUR_BLINK_RATE 
8e67 32 ac ee				ld (input_cur_flash), a 
8e6a			 
8e6a					; remove char 
8e6a 3a ae ee				ld a, (input_at_cursor) 
8e6d 3c					inc a 
8e6e 11 f8 8e				ld de,.iblank 
8e71 cd 88 8a				call str_at_display 
8e74			 
8e74 c3 00 8d				jp .is1 
8e77			 
8e77 fe 0d		.isk4:		cp KEY_CR 
8e79 28 6c				jr z, .endinput 
8e7b			 
8e7b					; else add the key press to the end 
8e7b			 
8e7b 4f					ld c, a			; save key pressed 
8e7c			 
8e7c 7e					ld a,(hl)		; get what is currently under char 
8e7d			 
8e7d fe 00				cp 0			; we are at the end of the string 
8e7f 20 2f				jr nz, .onchar 
8e81					 
8e81					; add a char to the end of the string 
8e81				 
8e81 71					ld (hl),c 
8e82 23					inc hl 
8e83			;		ld a,' ' 
8e83			;		ld (hl),a 
8e83			;		inc hl 
8e83 3e 00				ld a,0 
8e85 77					ld (hl),a 
8e86 2b					dec hl 
8e87			 
8e87 3a a1 ee				ld a, (input_cursor) 
8e8a 3c					inc a				; TODO check max string length and scroll  
8e8b 32 a1 ee				ld (input_cursor), a		; inc cursor pos 
8e8e							 
8e8e 3a ae ee				ld a, (input_at_cursor) 
8e91 3c					inc a 
8e92 32 ae ee				ld (input_at_cursor), a 
8e95			 
8e95 2a b5 ee				ld hl, (input_ptr) 
8e98 23					inc hl 
8e99 22 b5 ee				ld (input_ptr), hl 
8e9c			 
8e9c 2a b5 ee				ld hl, (input_ptr) 
8e9f 23					inc hl 
8ea0 22 b5 ee				ld (input_ptr), hl 
8ea3			;	if DEBUG_INPUT 
8ea3			;		push af 
8ea3			;		ld a, '+' 
8ea3			;		ld (debug_mark),a 
8ea3			;		pop af 
8ea3			;		CALLMONITOR 
8ea3			;	endif 
8ea3 3e 01				ld a, 1		; show cursor moving 
8ea5 32 ab ee				ld (input_cur_onoff),a 
8ea8 3e 0f				ld a, CUR_BLINK_RATE 
8eaa 32 ac ee				ld (input_cur_flash), a 
8ead c3 00 8d				jp .is1 
8eb0					 
8eb0			 
8eb0			 
8eb0					; if on a char then insert 
8eb0			.onchar: 
8eb0			 
8eb0					; TODO over flow check: make sure insert does not blow out buffer 
8eb0			 
8eb0					; need to do some maths to use lddr 
8eb0			 
8eb0 e5					push hl   ; save char pos 
8eb1 c5					push bc 
8eb2			 
8eb2 2a b3 ee				ld hl, (input_start) 
8eb5 3a a6 ee				ld a, (input_len) 
8eb8 cd a2 8c				call addatohl  		; end of string 
8ebb 23					inc hl 
8ebc 23					inc hl		; past zero term 
8ebd e5					push hl 
8ebe 23					inc hl 
8ebf e5					push hl  
8ec0			 
8ec0								; start and end of lddr set, now how much to move? 
8ec0			 
8ec0							 
8ec0 3a a1 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ec3 47					ld b,a 
8ec4 3a a6 ee				ld a,(input_len) 
8ec7 5f					ld e,a 
8ec8 90					sub b 
8ec9 3c					inc a		;?? 
8eca 3c					inc a		;?? 
8ecb 3c					inc a		;?? 
8ecc			 
8ecc 06 00				ld b,0 
8ece 4f					ld c,a 
8ecf			 
8ecf				if DEBUG_INPUT 
8ecf					push af 
8ecf					ld a, 'i' 
8ecf					ld (debug_mark),a 
8ecf					pop af 
8ecf			;		CALLMONITOR 
8ecf				endif 
8ecf d1					pop de 
8ed0 e1					pop hl 
8ed1				if DEBUG_INPUT 
8ed1					push af 
8ed1					ld a, 'I' 
8ed1					ld (debug_mark),a 
8ed1					pop af 
8ed1			;		CALLMONITOR 
8ed1				endif 
8ed1 ed b8				lddr 
8ed3				 
8ed3			 
8ed3			 
8ed3					; TODO have a key for insert/overwrite mode???? 
8ed3 c1					pop bc 
8ed4 e1					pop hl 
8ed5 71					ld (hl), c		; otherwise overwrite current char 
8ed6					 
8ed6			 
8ed6			 
8ed6			 
8ed6 3a a1 ee				ld a, (input_cursor) 
8ed9 3c					inc  a 		; TODO check overflow 
8eda 32 a1 ee				ld (input_cursor), a 
8edd			 
8edd 3a ae ee				ld a, (input_at_cursor) 
8ee0 3c					inc a 
8ee1 32 ae ee				ld (input_at_cursor), a 
8ee4			 
8ee4 c3 00 8d				jp .is1 
8ee7			 
8ee7			.endinput:	; TODO look for end of string 
8ee7			 
8ee7					; add trailing space for end of token 
8ee7			 
8ee7 2a b3 ee				ld hl, (input_start) 
8eea 3a a6 ee				ld a,(input_len) 
8eed cd a2 8c				call addatohl 
8ef0 3e 20				ld a, ' ' 
8ef2 77					ld (hl),a 
8ef3					; TODO eof of parse marker 
8ef3			 
8ef3 23					inc hl 
8ef4 3e 00				ld a, 0 
8ef6 77					ld (hl),a 
8ef7			 
8ef7			 
8ef7 c9					ret 
8ef8			 
8ef8 .. 00		.iblank: db " ",0 
8efa			 
8efa			 
8efa 32 b0 ee		input_str_prev:	ld (input_at_pos), a 
8efd 22 b3 ee				ld (input_start), hl 
8f00 3e 01				ld a,1			; add cursor 
8f02 77					ld (hl),a 
8f03 23					inc hl 
8f04 3e 00				ld a,0 
8f06 77					ld (hl),a 
8f07 22 b5 ee				ld (input_ptr), hl 
8f0a 7a					ld a,d 
8f0b 32 b2 ee				ld (input_size), a 
8f0e 3e 00				ld a,0 
8f10 32 a1 ee				ld (input_cursor),a 
8f13			.instr1:	 
8f13			 
8f13					; TODO do block cursor 
8f13					; TODO switch cursor depending on the modifer key 
8f13			 
8f13					; update cursor shape change on key hold 
8f13			 
8f13 2a b5 ee				ld hl, (input_ptr) 
8f16 2b					dec hl 
8f17 3a 50 ed				ld a,(cursor_shape) 
8f1a 77					ld (hl), a 
8f1b			 
8f1b					; display entered text 
8f1b 3a b0 ee				ld a,(input_at_pos) 
8f1e cd 22 e1		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f21 ed 5b b3 ee	            	LD   de, (input_start) 
8f25 cd 1c e1		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f28			 
8f28 cd c4 e1				call cin 
8f2b fe 00				cp 0 
8f2d 28 e4				jr z, .instr1 
8f2f			 
8f2f					; proecess keyboard controls first 
8f2f			 
8f2f 2a b5 ee				ld hl,(input_ptr) 
8f32			 
8f32 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f34 28 5a				jr z, .instrcr 
8f36			 
8f36 fe 08				cp KEY_BS 	; back space 
8f38 20 0f				jr nz, .instr2 
8f3a					; process back space 
8f3a			 
8f3a					; TODO stop back space if at start of string 
8f3a 2b					dec hl 
8f3b 2b					dec hl ; to over write cursor 
8f3c 3a 50 ed				ld a,(cursor_shape) 
8f3f					;ld a,0 
8f3f 77					ld (hl),a 
8f40 23					inc hl 
8f41 3e 20				ld a," " 
8f43 77					ld (hl),a 
8f44 22 b5 ee				ld (input_ptr),hl 
8f47					 
8f47			 
8f47 18 ca				jr .instr1 
8f49			 
8f49 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f4b 20 06				jr nz, .instr3 
8f4d 2b					dec hl 
8f4e 22 b5 ee				ld (input_ptr),hl 
8f51 18 c0				jr .instr1 
8f53				 
8f53 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f55 20 06				jr nz, .instr4 
8f57 23					inc hl 
8f58 22 b5 ee				ld (input_ptr),hl 
8f5b 18 b6				jr .instr1 
8f5d			 
8f5d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f5f 20 06				jr nz, .instr5 
8f61 2b					dec hl 
8f62 22 b5 ee				ld (input_ptr),hl 
8f65 18 ac				jr .instr1 
8f67			 
8f67 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8f69 20 06				jr nz, .instr6 
8f6b 2b					dec hl 
8f6c 22 b5 ee				ld (input_ptr),hl 
8f6f 18 a2				jr .instr1 
8f71 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8f73 20 0b				jr nz, .instrnew 
8f75			 
8f75 21 51 e4			ld hl, scratch 
8f78 11 77 e8			ld de, os_last_cmd 
8f7b cd 99 8f			call strcpy 
8f7e 18 93				jr .instr1 
8f80			 
8f80			 
8f80			.instrnew:	; no special key pressed to see if we have room to store it 
8f80			 
8f80					; TODO do string size test 
8f80			 
8f80 2b					dec hl ; to over write cursor 
8f81 77					ld (hl),a 
8f82 23					inc hl 
8f83 3a 50 ed				ld a,(cursor_shape) 
8f86 77					ld (hl),a 
8f87 23					inc hl 
8f88 3e 00				ld a,0 
8f8a 77					ld (hl),a 
8f8b			 
8f8b 22 b5 ee				ld (input_ptr),hl 
8f8e					 
8f8e 18 83				jr .instr1 
8f90 2b			.instrcr:	dec hl		; remove cursor 
8f91 3e 20				ld a,' '	; TODO add a trailing space for safety 
8f93 77					ld (hl),a 
8f94 23					inc hl 
8f95 3e 00				ld a,0 
8f97 77					ld (hl),a 
8f98			 
8f98			 
8f98					; if at end of line scroll up    
8f98					; TODO detecting only end of line 4 for scroll up  
8f98			 
8f98					;ld   
8f98			 
8f98 c9					ret 
8f99			 
8f99			 
8f99			; strcpy hl = dest, de source 
8f99			 
8f99 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8f9a b7			            OR   A              ;Null terminator? 
8f9b c8			            RET  Z              ;Yes, so finished 
8f9c 1a					ld a,(de) 
8f9d 77					ld (hl),a 
8f9e 13			            INC  DE             ;Point to next character 
8f9f 23					inc hl 
8fa0 18 f7		            JR   strcpy       ;Repeat 
8fa2 c9					ret 
8fa3			 
8fa3			 
8fa3			; TODO string_at  
8fa3			; pass string which starts with lcd offset address and then null term string 
8fa3			 
8fa3			; TODO string to dec 
8fa3			; TODO string to hex 
8fa3			; TODO byte to string hex 
8fa3			; TODO byte to string dec 
8fa3			 
8fa3			 
8fa3			 
8fa3			; from z80uartmonitor 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fa3			; pass hl for where to put the text 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3 c5			hexout:	PUSH BC 
8fa4 f5					PUSH AF 
8fa5 47					LD B, A 
8fa6					; Upper nybble 
8fa6 cb 3f				SRL A 
8fa8 cb 3f				SRL A 
8faa cb 3f				SRL A 
8fac cb 3f				SRL A 
8fae cd be 8f				CALL tohex 
8fb1 77					ld (hl),a 
8fb2 23					inc hl	 
8fb3					 
8fb3					; Lower nybble 
8fb3 78					LD A, B 
8fb4 e6 0f				AND 0FH 
8fb6 cd be 8f				CALL tohex 
8fb9 77					ld (hl),a 
8fba 23					inc hl	 
8fbb					 
8fbb f1					POP AF 
8fbc c1					POP BC 
8fbd c9					RET 
8fbe					 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			tohex: 
8fbe e5					PUSH HL 
8fbf d5					PUSH DE 
8fc0 16 00				LD D, 0 
8fc2 5f					LD E, A 
8fc3 21 cb 8f				LD HL, .DATA 
8fc6 19					ADD HL, DE 
8fc7 7e					LD A, (HL) 
8fc8 d1					POP DE 
8fc9 e1					POP HL 
8fca c9					RET 
8fcb			 
8fcb			.DATA: 
8fcb 30					DEFB	30h	; 0 
8fcc 31					DEFB	31h	; 1 
8fcd 32					DEFB	32h	; 2 
8fce 33					DEFB	33h	; 3 
8fcf 34					DEFB	34h	; 4 
8fd0 35					DEFB	35h	; 5 
8fd1 36					DEFB	36h	; 6 
8fd2 37					DEFB	37h	; 7 
8fd3 38					DEFB	38h	; 8 
8fd4 39					DEFB	39h	; 9 
8fd5 41					DEFB	41h	; A 
8fd6 42					DEFB	42h	; B 
8fd7 43					DEFB	43h	; C 
8fd8 44					DEFB	44h	; D 
8fd9 45					DEFB	45h	; E 
8fda 46					DEFB	46h	; F 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8fdb			;;    subtract $30, if result > 9 then subtract $7 more 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			atohex: 
8fdb d6 30				SUB $30 
8fdd fe 0a				CP 10 
8fdf f8					RET M		; If result negative it was 0-9 so we're done 
8fe0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8fe2 c9					RET		 
8fe3			 
8fe3			 
8fe3			 
8fe3			 
8fe3			; Get 2 ASCII characters as hex byte from pointer in hl 
8fe3			 
8fe3			BYTERD: 
8fe3 16 00			LD	D,00h		;Set up 
8fe5 cd ed 8f			CALL	HEXCON		;Get byte and convert to hex 
8fe8 87				ADD	A,A		;First nibble so 
8fe9 87				ADD	A,A		;multiply by 16 
8fea 87				ADD	A,A		; 
8feb 87				ADD	A,A		; 
8fec 57				LD	D,A		;Save hi nibble in D 
8fed			HEXCON: 
8fed 7e				ld a, (hl)		;Get next chr 
8fee 23				inc hl 
8fef d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8ff1 fe 0a			CP	00Ah		;Is it 0-9 ? 
8ff3 38 02			JR	C,NALPHA	;If so miss next bit 
8ff5 d6 07			SUB	007h		;Else convert alpha 
8ff7			NALPHA: 
8ff7 b2				OR	D		;Add hi nibble back 
8ff8 c9				RET			; 
8ff9			 
8ff9			 
8ff9			; 
8ff9			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8ff9			; Since the routines get_byte and therefore get_nibble are called, only valid 
8ff9			; characters (0-9a-f) are accepted. 
8ff9			; 
8ff9			;get_word        push    af 
8ff9			;                call    get_byte        ; Get the upper byte 
8ff9			;                ld      h, a 
8ff9			;                call    get_byte        ; Get the lower byte 
8ff9			;                ld      l, a 
8ff9			;                pop     af 
8ff9			;                ret 
8ff9			; 
8ff9			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8ff9			; the routine get_nibble is used only valid characters are accepted - the  
8ff9			; input routine only accepts characters 0-9a-f. 
8ff9			; 
8ff9 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8ffa 7e					ld a,(hl) 
8ffb 23					inc hl 
8ffc cd 21 90		                call    nibble2val      ; Get upper nibble 
8fff cb 07		                rlc     a 
9001 cb 07		                rlc     a 
9003 cb 07		                rlc     a 
9005 cb 07		                rlc     a 
9007 47			                ld      b, a            ; Save upper four bits 
9008 7e					ld a,(hl) 
9009 cd 21 90		                call    nibble2val      ; Get lower nibble 
900c b0			                or      b               ; Combine both nibbles 
900d c1			                pop     bc              ; Restore B (and C) 
900e c9			                ret 
900f			; 
900f			; Get a hexadecimal digit from the serial line. This routine blocks until 
900f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
900f			; to the serial line interface. The lower 4 bits of A contain the value of  
900f			; that particular digit. 
900f			; 
900f			;get_nibble      ld a,(hl)           ; Read a character 
900f			;                call    to_upper        ; Convert to upper case 
900f			;                call    is_hex          ; Was it a hex digit? 
900f			;                jr      nc, get_nibble  ; No, get another character 
900f			 ;               call    nibble2val      ; Convert nibble to value 
900f			 ;               call    print_nibble 
900f			 ;               ret 
900f			; 
900f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
900f			; A valid hexadecimal digit is denoted by a set C flag. 
900f			; 
900f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
900f			;                ret     nc              ; Yes 
900f			;                cp      '0'             ; Less than '0'? 
900f			;                jr      nc, is_hex_1    ; No, continue 
900f			;                ccf                     ; Complement carry (i.e. clear it) 
900f			;                ret 
900f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
900f			;                ret     c               ; Yes 
900f			;                cp      'A'             ; Less than 'A'? 
900f			;                jr      nc, is_hex_2    ; No, continue 
900f			;                ccf                     ; Yes - clear carry and return 
900f			;                ret 
900f			;is_hex_2        scf                     ; Set carry 
900f			;                ret 
900f			; 
900f			; Convert a single character contained in A to upper case: 
900f			; 
900f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
9011 d8			                ret     c 
9012 fe 7b		                cp      'z' + 1         ; > 'z'? 
9014 d0			                ret     nc              ; Nothing to do, either 
9015 e6 5f		                and     $5f             ; Convert to upper case 
9017 c9			                ret 
9018			 
9018			 
9018			to_lower: 
9018			 
9018			   ; if char is in [A-Z] make it lower case 
9018			 
9018			   ; enter : a = char 
9018			   ; exit  : a = lower case char 
9018			   ; uses  : af 
9018			 
9018 fe 41		   cp 'A' 
901a d8			   ret c 
901b			    
901b fe 5b		   cp 'Z'+1 
901d d0			   ret nc 
901e			    
901e f6 20		   or $20 
9020 c9			   ret 
9021			 
9021			; 
9021			; Expects a hexadecimal digit (upper case!) in A and returns the 
9021			; corresponding value in A. 
9021			; 
9021 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
9023 38 02		                jr      c, nibble2val_1 ; Yes 
9025 d6 07		                sub     7               ; Adjust for A-F 
9027 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9029 e6 0f		                and     $f              ; Only return lower 4 bits 
902b c9			                ret 
902c			; 
902c			; Print_nibble prints a single hex nibble which is contained in the lower  
902c			; four bits of A: 
902c			; 
902c			;print_nibble    push    af              ; We won't destroy the contents of A 
902c			;                and     $f              ; Just in case... 
902c			;                add     a, '0'             ; If we have a digit we are done here. 
902c			;                cp      '9' + 1         ; Is the result > 9? 
902c			;                jr      c, print_nibble_1 
902c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
902c			;print_nibble_1  call    putc            ; Print the nibble and 
902c			;                pop     af              ; restore the original value of A 
902c			;                ret 
902c			;; 
902c			;; Send a CR/LF pair: 
902c			; 
902c			;crlf            push    af 
902c			;                ld      a, cr 
902c			;                call    putc 
902c			;                ld      a, lf 
902c			;                call    putc 
902c			;                pop     af 
902c			;                ret 
902c			; 
902c			; Print_word prints the four hex digits of a word to the serial line. The  
902c			; word is expected to be in HL. 
902c			; 
902c			;print_word      push    hl 
902c			;                push    af 
902c			;                ld      a, h 
902c			;                call    print_byte 
902c			;                ld      a, l 
902c			;                call    print_byte 
902c			;                pop     af 
902c			;                pop     hl 
902c			;                ret 
902c			; 
902c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
902c			; The byte to be printed is expected to be in A. 
902c			; 
902c			;print_byte      push    af              ; Save the contents of the registers 
902c			;                push    bc 
902c			;                ld      b, a 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                call    print_nibble    ; Print high nibble 
902c			;                ld      a, b 
902c			;                call    print_nibble    ; Print low nibble 
902c			;                pop     bc              ; Restore original register contents 
902c			;                pop     af 
902c			;                ret 
902c			 
902c			 
902c			 
902c			 
902c			 
902c			fourehexhl:  
902c 7e				ld a,(hl) 
902d cd db 8f			call atohex 
9030 cb 3f				SRL A 
9032 cb 3f				SRL A 
9034 cb 3f				SRL A 
9036 cb 3f				SRL A 
9038 47				ld b, a 
9039 23				inc hl 
903a 7e				ld a,(hl) 
903b 23				inc hl 
903c cd db 8f			call atohex 
903f 80				add b 
9040 57				ld d,a 
9041 7e				ld a,(hl) 
9042 cd db 8f			call atohex 
9045 cb 3f				SRL A 
9047 cb 3f				SRL A 
9049 cb 3f				SRL A 
904b cb 3f				SRL A 
904d 47				ld b, a 
904e 23				inc hl 
904f 7e				ld a,(hl) 
9050 23				inc hl 
9051 cd db 8f			call atohex 
9054 80				add b 
9055 5f				ld e, a 
9056 d5				push de 
9057 e1				pop hl 
9058 c9				ret 
9059			 
9059			; pass hl. returns z set if the byte at hl is a digit 
9059			;isdigithl:  
9059			;	push bc 
9059			;	ld a,(hl) 
9059			;	cp ':' 
9059			;	jr nc, .isdf 		; > 
9059			;	cp '0' 
9059			;	jr c, .isdf		; < 
9059			; 
9059			;	; TODO find a better way to set z 
9059			; 
9059			;	ld b,a 
9059			;	cp b 
9059			;	pop bc 
9059			;	ret 
9059			; 
9059			;.isdf:	; not digit so clear z 
9059			; 
9059			;	; TODO find a better way to unset z 
9059			; 
9059			;	ld b,a 
9059			;	inc b 
9059			;	cp b 
9059			; 
9059			;	pop bc 
9059			;	ret 
9059				 
9059				 
9059			 
9059			 
9059			; pass hl as the four byte address to load 
9059			 
9059			get_word_hl:  
9059 e5				push hl 
905a cd f9 8f			call get_byte 
905d				 
905d 47				ld b, a 
905e			 
905e e1				pop hl 
905f 23				inc hl 
9060 23				inc hl 
9061			 
9061			; TODO not able to handle a-f  
9061 7e				ld a,(hl) 
9062			;	;cp ':' 
9062			;	cp 'g' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp 'G' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp '0' 
9062			;	jr c, .single_byte_hl		; < 
9062			 
9062				;call isdigithl 
9062 fe 00			cp 0 
9064 28 06			jr z, .single_byte_hl 
9066			 
9066			.getwhln:   ; hex word so get next byte 
9066			 
9066 cd f9 8f			call get_byte 
9069 6f				ld l, a 
906a 60				ld h,b 
906b c9				ret 
906c 68			.single_byte_hl:   ld l,b 
906d 26 00				ld h,0 
906f c9					ret 
9070			 
9070			 
9070			 
9070			 
9070 21 2b 98			ld hl,asc+1 
9073			;	ld a, (hl) 
9073			;	call nibble2val 
9073 cd f9 8f			call get_byte 
9076			 
9076			;	call fourehexhl 
9076 32 85 e4			ld (scratch+52),a 
9079				 
9079 21 83 e4			ld hl,scratch+50 
907c 22 74 e7			ld (os_cur_ptr),hl 
907f			 
907f c9				ret 
9080			 
9080			 
9080			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
9080			 
9080			; Decimal Unsigned Version 
9080			 
9080			;Number in a to decimal ASCII 
9080			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
9080			;Example: display a=56 as "056" 
9080			;input: a = number 
9080			;Output: a=0,value of a in the screen 
9080			;destroys af,bc (don't know about hl and de) 
9080			DispAToASCII: 
9080 0e 9c			ld	c,-100 
9082 cd 8c 90			call	.Na1 
9085 0e f6			ld	c,-10 
9087 cd 8c 90			call	.Na1 
908a 0e ff			ld	c,-1 
908c 06 2f		.Na1:	ld	b,'0'-1 
908e 04			.Na2:	inc	b 
908f 81				add	a,c 
9090 38 fc			jr	c,.Na2 
9092 91				sub	c		;works as add 100/10/1 
9093 f5				push af		;safer than ld c,a 
9094 78				ld	a,b		;char is in b 
9095			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
9095 f1				pop af		;safer than ld a,c 
9096 c9				ret 
9097			 
9097			; Decimal Signed Version 
9097			 
9097			; DispA 
9097			; -------------------------------------------------------------- 
9097			; Converts a signed integer value to a zero-terminated ASCII 
9097			; string representative of that value (using radix 10). 
9097			; -------------------------------------------------------------- 
9097			; INPUTS: 
9097			;     HL     Value to convert (two's complement integer). 
9097			;     DE     Base address of string destination. (pointer). 
9097			; -------------------------------------------------------------- 
9097			; OUTPUTS: 
9097			;     None 
9097			; -------------------------------------------------------------- 
9097			; REGISTERS/MEMORY DESTROYED 
9097			; AF HL 
9097			; -------------------------------------------------------------- 
9097			 
9097			;DispHLToASCII: 
9097			;   push    de 
9097			;   push    bc 
9097			; 
9097			;; Detect sign of HL. 
9097			;    bit    7, h 
9097			;    jr     z, ._DoConvert 
9097			; 
9097			;; HL is negative. Output '-' to string and negate HL. 
9097			;    ld     a, '-' 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			; 
9097			;; Negate HL (using two's complement) 
9097			;    xor    a 
9097			;    sub    l 
9097			;    ld     l, a 
9097			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
9097			;    sbc    a, h 
9097			;    ld     h, a 
9097			; 
9097			;; Convert HL to digit characters 
9097			;._DoConvert: 
9097			;    ld     b, 0     ; B will count character length of number 
9097			;-   ld     a, 10 
9097			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
9097			;    push   af 
9097			;    inc    b 
9097			;    ld     a, h 
9097			;    or     l 
9097			;    jr     nz, - 
9097			; 
9097			;; Retrieve digits from stack 
9097			;-   pop    af 
9097			;    or     $30 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			;    djnz   - 
9097			; 
9097			;; Terminate string with NULL 
9097			;    xor    a 
9097			;    ld     (de), a 
9097			; 
9097			;    pop    bc 
9097			;    pop    de 
9097			;    ret 
9097			 
9097			;Comments 
9097			; 
9097			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
9097			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
9097			;    Note that the output string will not be fixed-width. 
9097			; 
9097			;Example Usage 
9097			; 
9097			;    ld    hl, -1004 
9097			;    ld    de, OP1 
9097			;    call  DispA 
9097			;    ld    hl, OP1 
9097			;    syscall  PutS 
9097			 
9097			 
9097			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9097			 
9097			 
9097			;Converts an ASCII string to an unsigned 16-bit integer 
9097			;Quits when it reaches a non-decimal digit 
9097			 
9097			string_to_uint16: 
9097			atoui_16: 
9097			;Input: 
9097			;     DE points to the string 
9097			;Outputs: 
9097			;     HL is the result 
9097			;     A is the 8-bit value of the number 
9097			;     DE points to the byte after the number 
9097			;Destroys: 
9097			;     BC 
9097			;       if the string is non-empty, BC is HL/10 
9097			;Size:  24 bytes 
9097			;Speed: 42+d(104+{0,9}) 
9097			;       d is the number of digits in the number 
9097			;       max is 640 cycles for a 5 digit number 
9097			;Assuming no leading zeros: 
9097			;1 digit:  146cc 
9097			;2 digit:  250cc 
9097			;3 digit:  354cc or 363cc (avg: 354.126cc) 
9097			;4 digit:  458cc or 467cc (avg: 458.27cc) 
9097			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
9097			;avg: 544.81158447265625cc (544+13297/16384) 
9097			;=============================================================== 
9097 21 00 00		  ld hl,0 
909a			.u16a: 
909a 1a			  ld a,(de) 
909b d6 30		  sub 30h 
909d fe 0a		  cp 10 
909f d0			  ret nc 
90a0 13			  inc de 
90a1 44			  ld b,h 
90a2 4d			  ld c,l 
90a3 29			  add hl,hl 
90a4 29			  add hl,hl 
90a5 09			  add hl,bc 
90a6 29			  add hl,hl 
90a7 85			  add a,l 
90a8 6f			  ld l,a 
90a9 30 ef		  jr nc,.u16a 
90ab 24			  inc h 
90ac c3 9a 90		  jp .u16a 
90af			 
90af			 
90af			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90af			 
90af			;written by Zeda 
90af			;Converts a 16-bit unsigned integer to an ASCII string. 
90af			 
90af			uitoa_16: 
90af			;Input: 
90af			;   DE is the number to convert 
90af			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90af			;Output: 
90af			;   HL points to the null-terminated ASCII string 
90af			;      NOTE: This isn't necessarily the same as the input HL. 
90af d5			  push de 
90b0 c5			  push bc 
90b1 f5			  push af 
90b2 eb			  ex de,hl 
90b3			 
90b3 01 f0 d8		  ld bc,-10000 
90b6 3e 2f		  ld a,'0'-1 
90b8 3c			  inc a 
90b9 09			  add hl,bc  
90ba 38 fc		   jr c,$-2 
90bc 12			  ld (de),a 
90bd 13			  inc de 
90be			 
90be 01 e8 03		  ld bc,1000 
90c1 3e 3a		  ld a,'9'+1 
90c3 3d			  dec a  
90c4 09			  add hl,bc  
90c5 30 fc		   jr nc,$-2 
90c7 12			  ld (de),a 
90c8 13			  inc de 
90c9			 
90c9 01 9c ff		  ld bc,-100 
90cc 3e 2f		  ld a,'0'-1 
90ce 3c			  inc a  
90cf 09			  add hl,bc  
90d0 38 fc		   jr c,$-2 
90d2 12			  ld (de),a 
90d3 13			  inc de 
90d4			 
90d4 7d			  ld a,l 
90d5 26 3a		  ld h,'9'+1 
90d7 25			  dec h  
90d8 c6 0a		  add a,10  
90da 30 fb		   jr nc,$-3 
90dc c6 30		  add a,'0' 
90de eb			  ex de,hl 
90df 72			  ld (hl),d 
90e0 23			  inc hl 
90e1 77			  ld (hl),a 
90e2 23			  inc hl 
90e3 36 00		  ld (hl),0 
90e5			 
90e5			;Now strip the leading zeros 
90e5 0e fa		  ld c,-6 
90e7 09			  add hl,bc 
90e8 3e 30		  ld a,'0' 
90ea 23			  inc hl  
90eb be			  cp (hl)  
90ec 28 fc		  jr z,$-2 
90ee			 
90ee			;Make sure that the string is non-empty! 
90ee 7e			  ld a,(hl) 
90ef b7			  or a 
90f0 20 01		  jr nz,.atoub 
90f2 2b			  dec hl 
90f3			.atoub: 
90f3			 
90f3 f1			  pop af 
90f4 c1			  pop bc 
90f5 d1			  pop de 
90f6 c9			  ret 
90f7			 
90f7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
90f7			 
90f7			toUpper: 
90f7			;A is the char. 
90f7			;If A is a lowercase letter, this sets it to the matching uppercase 
90f7			;18cc or 30cc or 41cc 
90f7			;avg: 26.75cc 
90f7 fe 61		  cp 'a' 
90f9 d8			  ret c 
90fa fe 7b		  cp 'z'+1 
90fc d0			  ret nc 
90fd d6 20		  sub 'a'-'A' 
90ff c9			  ret 
9100			 
9100			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9100			 
9100			; String Length 
9100			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9100			 
9100			; Get the length of the null-terminated string starting at $8000 hl 
9100			;    LD     HL, $8000 
9100			 
9100			strlenz: 
9100			 
9100 af			    XOR    A               ; Zero is the value we are looking for. 
9101 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9102 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9103			                           ; 65, 536 bytes (the entire addressable memory space). 
9103 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9105			 
9105			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9105 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9106 6f			    LD     L, A             ; number of bytes 
9107 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9109 2b			    DEC    HL              ; Compensate for null. 
910a c9				ret 
910b			 
910b			; Get the length of the A terminated string starting at $8000 hl 
910b			;    LD     HL, $8000 
910b			 
910b			strlent: 
910b			 
910b			                  ; A is the value we are looking for. 
910b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
910d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
910f			                           ; 65, 536 bytes (the entire addressable memory space). 
910f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9111			 
9111			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9111 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9113 2e 00		    LD     L, 0             ; number of bytes 
9115 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9117 2b			    DEC    HL              ; Compensate for null. 
9118 c9				ret 
9119			 
9119			 
9119			;Comparing Strings 
9119			 
9119			;IN    HL     Address of string1. 
9119			;      DE     Address of string2. 
9119			 
9119			; doc given but wrong??? 
9119			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9119			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9119			; tested 
9119			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9119			 
9119			strcmp_old: 
9119 e5			    PUSH   HL 
911a d5			    PUSH   DE 
911b			 
911b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
911c be			    CP     (HL)            ; (want to minimize work). 
911d 38 01		    JR     C, Str1IsBigger 
911f 7e			    LD     A, (HL) 
9120			 
9120			Str1IsBigger: 
9120 4f			    LD     C, A             ; Put length in BC 
9121 06 00		    LD     B, 0 
9123 13			    INC    DE              ; Increment pointers to meat of string. 
9124 23			    INC    HL 
9125			 
9125			CmpLoop: 
9125 1a			    LD     A, (DE)          ; Compare bytes. 
9126 ed a1		    CPI 
9128 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
912a 13			    INC    DE              ; Update pointer. 
912b ea 25 91		    JP     PE, CmpLoop 
912e			 
912e d1			    POP    DE 
912f e1			    POP    HL 
9130 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9131 be			    CP     (HL) 
9132 c9			    RET 
9133			 
9133			NoMatch: 
9133 2b			    DEC    HL 
9134 be			    CP     (HL)            ; Compare again to affect carry. 
9135 d1			    POP    DE 
9136 e1			    POP    HL 
9137 c9			    RET 
9138			 
9138			;; test strmp 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr z, .z1 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z1: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr z, .z2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr c, .c1 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c1: 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr c, .c2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;	NEXTW 
9138			;.str1:   db "string1",0 
9138			;.str2:   db "string2",0 
9138			 
9138			; only care about direct match or not 
9138			; hl and de strings 
9138			; zero set if the same 
9138			 
9138			strcmp: 
9138 1a				ld a, (de) 
9139 be				cp (hl) 
913a 28 02			jr z, .ssame 
913c b7				or a 
913d c9				ret 
913e			 
913e			.ssame:  
913e fe 00			cp 0 
9140 c8				ret z 
9141			 
9141 23				inc hl 
9142 13				inc de 
9143 18 f3			jr strcmp 
9145				 
9145				 
9145			 
9145			 
9145			 
9145			 
9145			; eof 
9145			 
9145			 
9145			 
9145			 
9145			 
9145			 
# End of file firmware_strings.asm
9145			include "firmware_memory.asm"   ; malloc and free  
9145			 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			.mallocsize: db "Wants malloc >256",0 
9145			.mallocasize: db "MALLOC gives >256",0 
9145			.malloczero: db "MALLOC gives zero",0 
9145			 
9145			malloc_guard_zerolen: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145				ld de, 0 
9145			        call cmp16 
9145				jr nz, .lowalloz 
9145			 
9145				push hl 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .malloczero 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145			.lowalloz: 
9145			 
9145			 
9145				pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_entry: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowalloc 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocsize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145				jr .lowdone 
9145			.lowalloc: 
9145			 
9145			 
9145				pop hl 
9145			.lowdone:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_exit: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowallocx 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocasize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145				pop de 
9145				pop hl 
9145			 
9145				CALLMONITOR 
9145				jr .lowdonex 
9145			.lowallocx: 
9145			 
9145				pop hl 
9145			.lowdonex:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			endif 
9145			 
9145			if MALLOC_2 
9145			; Z80 Malloc and Free Functions 
9145			 
9145			; Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc: 
9145				 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_entry 
9145			endif 
9145			 
9145			 
9145			 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "mal" 
9145						CALLMONITOR 
9145					endif 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of size into A 
9145			    or h               ; Check if size is zero 
9145			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
9145			 
9145			    ; Allocate memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma1" 
9145						CALLMONITOR 
9145					endif 
9145			    call malloc_internal ; Call internal malloc function 
9145			    pop af             ; Restore AF register 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret                ; Return 
9145			 
9145			; Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free: 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of pointer into A 
9145			    or h               ; Check if pointer is NULL 
9145			    jp z, free_exit    ; If pointer is NULL, exit 
9145			 
9145			    ; Free memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145			    call free_internal  ; Call internal free function 
9145			    pop af             ; Restore AF register 
9145			    ret                ; Return 
9145			 
9145			; Internal Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc_internal: 
9145			    ld bc, 2           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to requested size 
9145			    ex de, hl          ; Save total size in DE, and keep it in HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			 
9145			    ; Search for free memory block 
9145			    ld de, (heap_end)  ; Load end of heap into DE 
9145			    ld bc, 0           ; Initialize counter 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			malloc_search_loop: 
9145			    ; Check if current block is free 
9145			    ld a, (hl)         ; Load current block's status (free or used) 
9145			    cp 0               ; Compare with zero (free) 
9145			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
9145			 
9145			    ; Check if current block is large enough 
9145			    ld a, (hl+1)       ; Load high byte of block size 
9145			    cp l               ; Compare with low byte of requested size 
9145			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
9145			 
9145			    ld a, (hl+2)       ; Load low byte of block size 
9145			    cp h               ; Compare with high byte of requested size 
9145			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
9145			 
9145			    ; Mark block as used 
9145			    ld (hl), 0xFF      ; Set status byte to indicate used block 
9145			 
9145			    ; Calculate remaining space in block 
9145			    ld bc, 0           ; Clear BC 
9145			    add hl, bc         ; Increment HL to point to start of data block 
9145			    add hl, de         ; HL = HL + DE (total size) 
9145			    ld bc, 1           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to start of data block 
9145			 
9145			    ; Save pointer to allocated block in HL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma5" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			malloc_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3           ; Size of management overhead 
9145			    add hl, bc         ; Move to the next block 
9145			    inc de             ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e            ; Load low byte of heap end address 
9145			    cp (hl)            ; Compare with low byte of current address 
9145			    jr nz, malloc_search_loop  ; If not equal, continue searching 
9145			    ld a, d            ; Load high byte of heap end address 
9145			    cp 0               ; Check if it's zero (end of memory) 
9145			    jr nz, malloc_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, allocation failed 
9145			    xor a              ; Set result to NULL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma6" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			malloc_exit: 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma7" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			; Internal Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free_internal: 
9145			    ld de, (heap_start) ; Load start of heap into DE 
9145			    ld bc, 0            ; Initialize counter 
9145			 
9145			free_search_loop: 
9145			    ; Check if current block contains the pointer 
9145			    ld a, l             ; Load low byte of pointer 
9145			    cp (hl+1)           ; Compare with high byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			    ld a, h             ; Load high byte of pointer 
9145			    cp (hl+2)           ; Compare with low byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			 
9145			    ; Mark block as free 
9145			    ld (hl), 0          ; Set status byte to indicate free block 
9145			    ret                 ; Return 
9145			 
9145			free_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3            ; Size of management overhead 
9145			    add hl, bc          ; Move to the next block 
9145			    inc de              ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e             ; Load low byte of heap end address 
9145			    cp (hl)             ; Compare with low byte of current address 
9145			    jr nz, free_search_loop  ; If not equal, continue searching 
9145			    ld a, d             ; Load high byte of heap end address 
9145			    cp 0                ; Check if it's zero (end of memory) 
9145			    jr nz, free_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, pointer is not found in heap 
9145			    ret 
9145			 
9145			free_exit: 
9145			    ret                 ; Return 
9145			 
9145			; Define heap start and end addresses 
9145			;heap_start:    .dw 0xC000   ; Start of heap 
9145			;heap_end:      .dw 0xE000   ; End of heap 
9145			 
9145			endif 
9145			 
9145			 
9145			if MALLOC_1 
9145			 
9145			 
9145			 
9145			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
9145			 
9145			;moved to firmware.asm 
9145			;heap_start        .equ  0x9000      ; Starting address of heap 
9145			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9145			 
9145			;      .org 0 
9145			;      jp    main 
9145			 
9145			 
9145			;      .org  0x100 
9145			;main: 
9145			;      ld    HL, 0x8100 
9145			;      ld    SP, HL 
9145			; 
9145			;      call  heap_init 
9145			; 
9145			;      ; Make some allocations 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9004 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9014 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9024 
9145			; 
9145			;      ; Free some allocations 
9145			;      ld    HL, 0x9014 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9004 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9024 
9145			;      call  free 
9145			; 
9145			; 
9145			;      halt 
9145			 
9145			 
9145			;------------------------------------------------------------------------------ 
9145			;     heap_init                                                               : 
9145			;                                                                             : 
9145			; Description                                                                 : 
9145			;     Initialise the heap and make it ready for malloc and free operations.   : 
9145			;                                                                             : 
9145			;     The heap is maintained as a linked list, starting with an initial       : 
9145			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9145			;     the first free block in the heap. Each block then points to the next    : 
9145			;     free block within the heap, and the free list ends at the first block   : 
9145			;     with a null pointer to the next free block.                             : 
9145			;                                                                             : 
9145			; Parameters                                                                  : 
9145			;     Inputs are compile-time only. Two defines which specify the starting    : 
9145			;     address of the heap and its size are required, along with a memory      : 
9145			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9145			;     principally stores a pointer to the first free block in the heap.       : 
9145			;                                                                             : 
9145			; Returns                                                                     : 
9145			;     Nothing                                                                 : 
9145			;------------------------------------------------------------------------------ 
9145			heap_init: 
9145 e5			      push  HL 
9146			 
9146			      ; Initialise free list struct 
9146 21 e2 e1		      ld    HL, heap_start 
9149 22 dd e1		      ld    (free_list), HL 
914c 21 00 00		      ld    HL, 0 
914f 22 df e1		      ld    (free_list+2), HL 
9152			 
9152			      ; Insert first free block at bottom of heap, consumes entire heap 
9152 21 33 e4		      ld    HL, heap_start+heap_size-4 
9155 22 e2 e1		      ld    (heap_start), HL        ; Next block (end of free list) 
9158 21 51 02		      ld    HL, heap_size-4 
915b 22 e4 e1		      ld    (heap_start+2), HL      ; Block size 
915e			 
915e			      ; Insert end of free list block at top of heap - two null words will 
915e			      ; terminate the free list 
915e 21 00 00		      ld    HL, 0 
9161 22 35 e4		      ld    (heap_start+heap_size-2), HL 
9164 22 33 e4		      ld    (heap_start+heap_size-4), HL 
9167			 
9167 e1			      pop   HL 
9168			 
9168 c9			      ret 
9169			 
9169			 
9169			;------------------------------------------------------------------------------ 
9169			;     malloc                                                                  : 
9169			;                                                                             : 
9169			; Description                                                                 : 
9169			;     Allocates the wanted space from the heap and returns the address of the : 
9169			;     first useable byte of the allocation.                                   : 
9169			;                                                                             : 
9169			;     Allocations can happen in one of two ways:                              : 
9169			;                                                                             : 
9169			;     1. A free block may be found which is the exact size wanted. In this    : 
9169			;        case the block is removed from the free list and retuedn to the      : 
9169			;        caller.                                                              : 
9169			;     2. A free block may be found which is larger than the size wanted. In   : 
9169			;        this case, the larger block is split into two. The first portion of  : 
9169			;        this block will become the requested space by the malloc call and    : 
9169			;        is returned to the caller. The second portion becomes a new free     : 
9169			;        block, and the free list is adjusted to maintain continuity via this : 
9169			;        newly created block.                                                 : 
9169			;                                                                             : 
9169			;     malloc does not set any initial value in the allocated space, the       : 
9169			;     caller is required to do this as required.                              : 
9169			;                                                                             : 
9169			;     This implementation of malloc uses the stack exclusively, and is        : 
9169			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9169			;     advisable to disable interrupts before calling malloc, and recommended  : 
9169			;     to avoid the use of malloc inside ISRs in general.                      : 
9169			;                                                                             : 
9169			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9169			;                                                                             : 
9169			; Parameters                                                                  : 
9169			;     HL  Number of bytes wanted                                              : 
9169			;                                                                             : 
9169			; Returns                                                                     : 
9169			;     HL  Address of the first useable byte of the allocation                 : 
9169			;                                                                             : 
9169			; Flags                                                                       : 
9169			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9169			;                                                                             : 
9169			; Stack frame                                                                 : 
9169			;       |             |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     BC      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     DE      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     IX      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |  prev_free  |                                                       : 
9169			;   +4  +-------------+                                                       : 
9169			;       |  this_free  |                                                       : 
9169			;   +2  +-------------+                                                       : 
9169			;       |  next_free  |                                                       : 
9169			;   +0  +-------------+                                                       : 
9169			;       |             |                                                       : 
9169			;                                                                             : 
9169			;------------------------------------------------------------------------------ 
9169			 
9169			 
9169			;malloc: 
9169			; 
9169			;	SAVESP ON 1 
9169			; 
9169			;	call malloc_code 
9169			; 
9169			;	CHECKSP ON 1 
9169			;	ret 
9169			 
9169			 
9169			malloc: 
9169 c5			      push  BC 
916a d5			      push  DE 
916b dd e5		      push  IX 
916d			if DEBUG_FORTH_MALLOC_HIGH 
916d			call malloc_guard_entry 
916d			endif 
916d			 
916d					if DEBUG_FORTH_MALLOC 
916d						DMARK "mal" 
916d						CALLMONITOR 
916d					endif 
916d 7c			      ld    A, H                    ; Exit if no space requested 
916e b5			      or    L 
916f ca 2e 92		      jp    Z, malloc_early_exit 
9172			 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			; 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			 
9172			 
9172			 
9172			 
9172					if DEBUG_FORTH_MALLOC 
9172						DMARK "maA" 
9172						CALLMONITOR 
9172					endif 
9172			      ; Set up stack frame 
9172 eb			      ex    DE, HL 
9173 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9176 39			      add   HL, SP 
9177 f9			      ld    SP, HL 
9178 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
917c dd 39		      add   IX, SP 
917e			 
917e			      ; Setup initial state 
917e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
9181 19			      add   HL, DE 
9182			 
9182 44			      ld    B, H                    ; Move want to BC 
9183 4d			      ld    C, L 
9184			 
9184 21 dd e1		      ld    HL, free_list           ; Store prev_free ptr to stack 
9187 dd 75 04		      ld    (IX+4), L 
918a dd 74 05		      ld    (IX+5), H 
918d			 
918d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
918e 23			      inc   HL 
918f 56			      ld    D, (HL) 
9190 dd 73 02		      ld    (IX+2), E 
9193 dd 72 03		      ld    (IX+3), D 
9196 eb			      ex    DE, HL                  ; this_free ptr into HL 
9197			 
9197					if DEBUG_FORTH_MALLOC 
9197						DMARK "maB" 
9197						CALLMONITOR 
9197					endif 
9197			      ; Loop through free block list to find some space 
9197			malloc_find_space: 
9197 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9198 23			      inc   HL 
9199 56			      ld    D, (HL) 
919a			 
919a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
919b b3			      or    E 
919c ca 28 92		      jp    Z, malloc_no_space 
919f			 
919f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91a2 dd 72 01		      ld    (IX+1), D 
91a5			 
91a5			      ; Does this block have enough space to make the allocation? 
91a5 23			      inc   HL                      ; Load free block size into DE 
91a6 5e			      ld    E, (HL) 
91a7 23			      inc   HL 
91a8 56			      ld    D, (HL) 
91a9			 
91a9 eb			      ex    DE, HL                  ; Check size of block against want 
91aa b7			      or    A                       ; Ensure carry flag clear 
91ab ed 42		      sbc   HL, BC 
91ad e5			      push  HL                      ; Store the result for later (new block size) 
91ae			 
91ae ca fd 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91b1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91b3			 
91b3			      ; this_free block is not big enough, setup ptrs to test next free block 
91b3 e1			      pop   HL                      ; Discard previous result 
91b4			 
91b4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91b7 dd 66 03		      ld    H, (IX+3) 
91ba dd 75 04		      ld    (IX+4), L 
91bd dd 74 05		      ld    (IX+5), H 
91c0			 
91c0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91c3 dd 66 01		      ld    H, (IX+1) 
91c6 dd 75 02		      ld    (IX+2), L 
91c9 dd 74 03		      ld    (IX+3), H 
91cc			 
91cc					if DEBUG_FORTH_MALLOC 
91cc						DMARK "MA>" 
91cc						CALLMONITOR 
91cc					endif 
91cc 18 c9		      jr    malloc_find_space 
91ce			 
91ce			      ; split a bigger block into two - requested size and remaining size 
91ce			malloc_alloc_split: 
91ce					if DEBUG_FORTH_MALLOC 
91ce						DMARK "MAs" 
91ce						CALLMONITOR 
91ce					endif 
91ce eb			      ex    DE, HL                  ; Calculate address of new free block 
91cf 2b			      dec   HL 
91d0 2b			      dec   HL 
91d1 2b			      dec   HL 
91d2 09			      add   HL, BC 
91d3			 
91d3			      ; Create a new block and point it at next_free 
91d3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
91d6 dd 56 01		      ld    D, (IX+1) 
91d9			 
91d9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
91da 23			      inc   HL 
91db 72			      ld    (HL), D 
91dc			 
91dc d1			      pop   DE                      ; Store size of new block into new block 
91dd 23			      inc   HL 
91de 73			      ld    (HL), E 
91df 23			      inc   HL 
91e0 72			      ld    (HL), D 
91e1			 
91e1			      ; Update this_free ptr to point to new block 
91e1 2b			      dec   HL 
91e2 2b			      dec   HL 
91e3 2b			      dec   HL 
91e4			 
91e4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91e7 dd 56 03		      ld    D, (IX+3) 
91ea			 
91ea dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91ed dd 74 03		      ld    (IX+3), H 
91f0			 
91f0			      ; Modify this_free block to be allocation 
91f0 eb			      ex    DE, HL 
91f1 af			      xor   A                       ; Null the next block ptr of allocated block 
91f2 77			      ld    (HL), A 
91f3 23			      inc   HL 
91f4 77			      ld    (HL), A 
91f5			 
91f5 23			      inc   HL                      ; Store want size into allocated block 
91f6 71			      ld    (HL), C 
91f7 23			      inc   HL 
91f8 70			      ld    (HL), B 
91f9 23			      inc   HL 
91fa e5			      push  HL                      ; Address of allocation to return 
91fb			 
91fb 18 19		      jr    malloc_update_links 
91fd			 
91fd			malloc_alloc_fit: 
91fd e1			      pop   HL                      ; Dont need new block size, want is exact fit 
91fe			 
91fe					if DEBUG_FORTH_MALLOC 
91fe						DMARK "MAf" 
91fe						CALLMONITOR 
91fe					endif 
91fe			      ; Modify this_free block to be allocation 
91fe eb			      ex    DE, HL 
91ff 2b			      dec   HL 
9200 2b			      dec   HL 
9201 2b			      dec   HL 
9202			 
9202 af			      xor   A                       ; Null the next block ptr of allocated block 
9203 77			      ld    (HL), A 
9204 23			      inc   HL 
9205 77			      ld    (HL), A 
9206			 
9206 23			      inc   HL                      ; Store address of allocation to return 
9207 23			      inc   HL 
9208 23			      inc   HL 
9209 e5			      push  HL 
920a			 
920a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
920a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
920d dd 66 01		      ld    H, (IX+1) 
9210			 
9210 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9213 dd 74 03		      ld    (IX+3), H 
9216			 
9216			 
9216			malloc_update_links: 
9216			      ; Update prev_free ptr to point to this_free 
9216 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9219 dd 66 05		      ld    H, (IX+5) 
921c			 
921c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
921f dd 56 03		      ld    D, (IX+3) 
9222			 
9222 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9223 23			      inc   HL 
9224 72			      ld    (HL), D 
9225			 
9225					if DEBUG_FORTH_MALLOC 
9225						DMARK "Mul" 
9225						CALLMONITOR 
9225					endif 
9225			      ; Clear the Z flag to indicate successful allocation 
9225 7a			      ld    A, D 
9226 b3			      or    E 
9227			 
9227 d1			      pop   DE                      ; Address of allocation 
9228					if DEBUG_FORTH_MALLOC 
9228						DMARK "MAu" 
9228						CALLMONITOR 
9228					endif 
9228			 
9228			malloc_no_space: 
9228 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
922b 39			      add   HL, SP 
922c f9			      ld    SP, HL 
922d			 
922d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAN" 
922e						CALLMONITOR 
922e					endif 
922e			 
922e			malloc_early_exit: 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAx" 
922e						CALLMONITOR 
922e					endif 
922e dd e1		      pop   IX 
9230 d1			      pop   DE 
9231 c1			      pop   BC 
9232			 
9232			if DEBUG_FORTH_MALLOC_HIGH 
9232			call malloc_guard_exit 
9232			call malloc_guard_zerolen 
9232			endif 
9232 c9			      ret 
9233			 
9233			 
9233			;------------------------------------------------------------------------------ 
9233			;     free                                                                    : 
9233			;                                                                             : 
9233			; Description                                                                 : 
9233			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9233			;     returned by malloc, otherwise the behaviour is undefined.               : 
9233			;                                                                             : 
9233			;     Where possible, directly adjacent free blocks will be merged together   : 
9233			;     into larger blocks to help ensure that the heap does not become         : 
9233			;     excessively fragmented.                                                 : 
9233			;                                                                             : 
9233			;     free does not clear or set any other value into the freed space, and    : 
9233			;     therefore its contents may be visible through subsequent malloc's. The  : 
9233			;     caller should clear the freed space as required.                        : 
9233			;                                                                             : 
9233			;     This implementation of free uses the stack exclusively, and is          : 
9233			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9233			;     advisable to disable interrupts before calling free, and recommended    : 
9233			;     to avoid the use of free inside ISRs in general.                        : 
9233			;                                                                             : 
9233			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9233			;                                                                             : 
9233			; Parameters                                                                  : 
9233			;     HL  Pointer to address of first byte of allocation to be freed          : 
9233			;                                                                             : 
9233			; Returns                                                                     : 
9233			;     Nothing                                                                 : 
9233			;                                                                             : 
9233			; Stack frame                                                                 : 
9233			;       |             |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     BC      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     DE      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     IX      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |  prev_free  |                                                       : 
9233			;   +2  +-------------+                                                       : 
9233			;       |  next_free  |                                                       : 
9233			;   +0  +-------------+                                                       : 
9233			;       |             |                                                       : 
9233			;                                                                             : 
9233			;------------------------------------------------------------------------------ 
9233			free: 
9233 c5			      push  BC 
9234 d5			      push  DE 
9235 dd e5		      push  IX 
9237			 
9237 7c			      ld    A, H                    ; Exit if ptr is null 
9238 b5			      or    L 
9239 ca fd 92		      jp    Z, free_early_exit 
923c			 
923c			      ; Set up stack frame 
923c eb			      ex    DE, HL 
923d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9240 39			      add   HL, SP 
9241 f9			      ld    SP, HL 
9242 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9246 dd 39		      add   IX, SP 
9248			 
9248			      ; The address in HL points to the start of the useable allocated space, 
9248			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9248			      ; address of the block itself. 
9248 eb			      ex    DE, HL 
9249 11 fc ff		      ld    DE, -4 
924c 19			      add   HL, DE 
924d			 
924d			      ; An allocated block must have a null next block pointer in it 
924d 7e			      ld    A, (HL) 
924e 23			      inc   HL 
924f b6			      or    (HL) 
9250 c2 f8 92		      jp    NZ, free_done 
9253			 
9253 2b			      dec   HL 
9254			 
9254 44			      ld    B, H                    ; Copy HL to BC 
9255 4d			      ld    C, L 
9256			 
9256			      ; Loop through the free list to find the first block with an address 
9256			      ; higher than the block being freed 
9256 21 dd e1		      ld    HL, free_list 
9259			 
9259			free_find_higher_block: 
9259 5e			      ld    E, (HL)                 ; Load next ptr from free block 
925a 23			      inc   HL 
925b 56			      ld    D, (HL) 
925c 2b			      dec   HL 
925d			 
925d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9260 dd 72 01		      ld    (IX+1), D 
9263 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9266 dd 74 03		      ld    (IX+3), H 
9269			 
9269 78			      ld    A, B                    ; Check if DE is greater than BC 
926a ba			      cp    D                       ; Compare MSB first 
926b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
926d 30 04		      jr    NC, free_find_higher_block_skip 
926f 79			      ld    A, C 
9270 bb			      cp    E                       ; Then compare LSB 
9271 38 08		      jr    C, free_found_higher_block 
9273			 
9273			free_find_higher_block_skip: 
9273 7a			      ld    A, D                    ; Reached the end of the free list? 
9274 b3			      or    E 
9275 ca f8 92		      jp    Z, free_done 
9278			 
9278 eb			      ex    DE, HL 
9279			 
9279 18 de		      jr    free_find_higher_block 
927b			 
927b			free_found_higher_block: 
927b			      ; Insert freed block between prev and next free blocks 
927b 71			      ld    (HL), C                 ; Point prev free block to freed block 
927c 23			      inc   HL 
927d 70			      ld    (HL), B 
927e			 
927e 60			      ld    H, B                    ; Point freed block at next free block 
927f 69			      ld    L, C 
9280 73			      ld    (HL), E 
9281 23			      inc   HL 
9282 72			      ld    (HL), D 
9283			 
9283			      ; Check if the freed block is adjacent to the next free block 
9283 23			      inc   HL                      ; Load size of freed block into HL 
9284 5e			      ld    E, (HL) 
9285 23			      inc   HL 
9286 56			      ld    D, (HL) 
9287 eb			      ex    DE, HL 
9288			 
9288 09			      add   HL, BC                  ; Add addr of freed block and its size 
9289			 
9289 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
928c dd 56 01		      ld    D, (IX+1) 
928f			 
928f b7			      or    A                       ; Clear the carry flag 
9290 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9292 20 22		      jr    NZ, free_check_adjacent_to_prev 
9294			 
9294			      ; Freed block is adjacent to next, merge into one bigger block 
9294 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9295 5e			      ld    E, (HL) 
9296 23			      inc   HL 
9297 56			      ld    D, (HL) 
9298 e5			      push  HL                      ; Save ptr to next block for later 
9299			 
9299 60			      ld    H, B                    ; Store ptr from next block into freed block 
929a 69			      ld    L, C 
929b 73			      ld    (HL), E 
929c 23			      inc   HL 
929d 72			      ld    (HL), D 
929e			 
929e e1			      pop   HL                      ; Restore ptr to next block 
929f 23			      inc   HL                      ; Load size of next block into DE 
92a0 5e			      ld    E, (HL) 
92a1 23			      inc   HL 
92a2 56			      ld    D, (HL) 
92a3 d5			      push  DE                      ; Save next block size for later 
92a4			 
92a4 60			      ld    H, B                    ; Load size of freed block into HL 
92a5 69			      ld    L, C 
92a6 23			      inc   HL 
92a7 23			      inc   HL 
92a8 5e			      ld    E, (HL) 
92a9 23			      inc   HL 
92aa 56			      ld    D, (HL) 
92ab eb			      ex    DE, HL 
92ac			 
92ac d1			      pop   DE                      ; Restore size of next block 
92ad 19			      add   HL, DE                  ; Add sizes of both blocks 
92ae eb			      ex    DE, HL 
92af			 
92af 60			      ld    H, B                    ; Store new bigger size into freed block 
92b0 69			      ld    L, C 
92b1 23			      inc   HL 
92b2 23			      inc   HL 
92b3 73			      ld    (HL), E 
92b4 23			      inc   HL 
92b5 72			      ld    (HL), D 
92b6			 
92b6			free_check_adjacent_to_prev: 
92b6			      ; Check if the freed block is adjacent to the prev free block 
92b6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92b9 dd 66 03		      ld    H, (IX+3) 
92bc			 
92bc 23			      inc   HL                      ; Size of prev free block into DE 
92bd 23			      inc   HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 2b			      dec   HL 
92c2 2b			      dec   HL 
92c3 2b			      dec   HL 
92c4			 
92c4 19			      add   HL, DE                  ; Add prev block addr and size 
92c5			 
92c5 b7			      or    A                       ; Clear the carry flag 
92c6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92c8 20 2e		      jr    NZ, free_done 
92ca			 
92ca			      ; Freed block is adjacent to prev, merge into one bigger block 
92ca 60			      ld    H, B                    ; Load next ptr from freed block into DE 
92cb 69			      ld    L, C 
92cc 5e			      ld    E, (HL) 
92cd 23			      inc   HL 
92ce 56			      ld    D, (HL) 
92cf e5			      push  HL                      ; Save freed block ptr for later 
92d0			 
92d0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92d3 dd 66 03		      ld    H, (IX+3) 
92d6 73			      ld    (HL), E 
92d7 23			      inc   HL 
92d8 72			      ld    (HL), D 
92d9			 
92d9 e1			      pop   HL                      ; Restore freed block ptr 
92da 23			      inc   HL                      ; Load size of freed block into DE 
92db 5e			      ld    E, (HL) 
92dc 23			      inc   HL 
92dd 56			      ld    D, (HL) 
92de d5			      push  DE                      ; Save freed block size for later 
92df			 
92df dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
92e2 dd 66 03		      ld    H, (IX+3) 
92e5 23			      inc   HL 
92e6 23			      inc   HL 
92e7 5e			      ld    E, (HL) 
92e8 23			      inc   HL 
92e9 56			      ld    D, (HL) 
92ea			 
92ea e1			      pop   HL                      ; Add sizes of both blocks 
92eb 19			      add   HL, DE 
92ec eb			      ex    DE, HL 
92ed			 
92ed dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
92f0 dd 66 03		      ld    H, (IX+3) 
92f3 23			      inc   HL 
92f4 23			      inc   HL 
92f5 73			      ld    (HL), E 
92f6 23			      inc   HL 
92f7 72			      ld    (HL), D 
92f8			 
92f8			free_done: 
92f8 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
92fb 39			      add   HL, SP 
92fc f9			      ld    SP, HL 
92fd			 
92fd			free_early_exit: 
92fd dd e1		      pop   IX 
92ff d1			      pop   DE 
9300 c1			      pop   BC 
9301			 
9301 c9			      ret 
9302			 
9302			; moved to firmware.asm 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			;                  .dw   0 
9302			 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_3 
9302			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9302			;heap_start        .equ  0x9000      ; Starting address of heap 
9302			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9302			; 
9302			 ;     .org 0 
9302			  ;    jp    main 
9302			; 
9302			; 
9302			 ;     .org  0x100 
9302			;main: 
9302			 ;     ld    HL, 0x8100 
9302			  ;    ld    SP, HL 
9302			; 
9302			;      call  heap_init 
9302			 
9302			      ; Make some allocations 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9004 
9302			; 
9302			 ;     ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9014 
9302			 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9024 
9302			 
9302			      ; Free some allocations 
9302			;      ld    HL, 0x9014 
9302			;      call  free 
9302			 
9302			;      ld    HL, 0x9004 
9302			;      call  free 
9302			; 
9302			;      ld    HL, 0x9024 
9302			;      call  free 
9302			 
9302			 
9302			 ;     halt 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     heap_init                                                               : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Initialise the heap and make it ready for malloc and free operations.   : 
9302			;                                                                             : 
9302			;     The heap is maintained as a linked list, starting with an initial       : 
9302			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9302			;     the first free block in the heap. Each block then points to the next    : 
9302			;     free block within the heap, and the free list ends at the first block   : 
9302			;     with a null pointer to the next free block.                             : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     Inputs are compile-time only. Two defines which specify the starting    : 
9302			;     address of the heap and its size are required, along with a memory      : 
9302			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9302			;     principally stores a pointer to the first free block in the heap.       : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;------------------------------------------------------------------------------ 
9302			heap_init: 
9302			      push  HL 
9302			 
9302			      ; Initialise free list struct 
9302			      ld    HL, heap_start 
9302			      ld    (free_list), HL 
9302			      ld    HL, 0 
9302			      ld    (free_list+2), HL 
9302			 
9302			      ; Insert first free block at bottom of heap, consumes entire heap 
9302			      ld    HL, heap_start+heap_size-4 
9302			      ld    (heap_start), HL        ; Next block (end of free list) 
9302			      ld    HL, heap_size-4 
9302			      ld    (heap_start+2), HL      ; Block size 
9302			 
9302			      ; Insert end of free list block at top of heap - two null words will 
9302			      ; terminate the free list 
9302			      ld    HL, 0 
9302			      ld    (heap_start+heap_size-2), HL 
9302			      ld    (heap_start+heap_size-4), HL 
9302			 
9302			      pop   HL 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     malloc                                                                  : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Allocates the wanted space from the heap and returns the address of the : 
9302			;     first useable byte of the allocation.                                   : 
9302			;                                                                             : 
9302			;     Allocations can happen in one of two ways:                              : 
9302			;                                                                             : 
9302			;     1. A free block may be found which is the exact size wanted. In this    : 
9302			;        case the block is removed from the free list and retuedn to the      : 
9302			;        caller.                                                              : 
9302			;     2. A free block may be found which is larger than the size wanted. In   : 
9302			;        this case, the larger block is split into two. The first portion of  : 
9302			;        this block will become the requested space by the malloc call and    : 
9302			;        is returned to the caller. The second portion becomes a new free     : 
9302			;        block, and the free list is adjusted to maintain continuity via this : 
9302			;        newly created block.                                                 : 
9302			;                                                                             : 
9302			;     malloc does not set any initial value in the allocated space, the       : 
9302			;     caller is required to do this as required.                              : 
9302			;                                                                             : 
9302			;     This implementation of malloc uses the stack exclusively, and is        : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling malloc, and recommended  : 
9302			;     to avoid the use of malloc inside ISRs in general.                      : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Number of bytes wanted                                              : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     HL  Address of the first useable byte of the allocation                 : 
9302			;                                                                             : 
9302			; Flags                                                                       : 
9302			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +4  +-------------+                                                       : 
9302			;       |  this_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			malloc: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if no space requested 
9302			      or    L 
9302			      jp    Z, malloc_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; Setup initial state 
9302			      ld    HL, 4                   ; want must also include space used by block struct 
9302			      add   HL, DE 
9302			 
9302			      ld    B, H                    ; Move want to BC 
9302			      ld    C, L 
9302			 
9302			      ld    HL, free_list           ; Store prev_free ptr to stack 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    E, (HL)                 ; Store this_free ptr to stack 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ld    (IX+2), E 
9302			      ld    (IX+3), D 
9302			      ex    DE, HL                  ; this_free ptr into HL 
9302			 
9302			      ; Loop through free block list to find some space 
9302			malloc_find_space: 
9302			      ld    E, (HL)                 ; Load next_free ptr into DE 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9302			      or    E 
9302			      jp    Z, malloc_no_space 
9302			 
9302			      ld    (IX+0), E               ; Store next_free ptr to stack 
9302			      ld    (IX+1), D 
9302			 
9302			      ; Does this block have enough space to make the allocation? 
9302			      inc   HL                      ; Load free block size into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ex    DE, HL                  ; Check size of block against want 
9302			      or    A                       ; Ensure carry flag clear 
9302			      sbc   HL, BC 
9302			      push  HL                      ; Store the result for later (new block size) 
9302			 
9302			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9302			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9302			 
9302			      ; this_free block is not big enough, setup ptrs to test next free block 
9302			      pop   HL                      ; Discard previous result 
9302			 
9302			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9302			      ld    H, (IX+3) 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9302			      ld    H, (IX+1) 
9302			      ld    (IX+2), L 
9302			      ld    (IX+3), H 
9302			 
9302			      jr    malloc_find_space 
9302			 
9302			      ; split a bigger block into two - requested size and remaining size 
9302			malloc_alloc_split: 
9302			      ex    DE, HL                  ; Calculate address of new free block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      add   HL, BC 
9302			 
9302			      ; Create a new block and point it at next_free 
9302			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      ld    (HL), E                 ; Store next_free ptr into new block 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   DE                      ; Store size of new block into new block 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Update this_free ptr to point to new block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9302			      ld    (IX+3), H 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store want size into allocated block 
9302			      ld    (HL), C 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			      inc   HL 
9302			      push  HL                      ; Address of allocation to return 
9302			 
9302			      jr    malloc_update_links 
9302			 
9302			malloc_alloc_fit: 
9302			      pop   HL                      ; Dont need new block size, want is exact fit 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store address of allocation to return 
9302			      inc   HL 
9302			      inc   HL 
9302			      push  HL 
9302			 
9302			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9302			      ld    L, (IX+0)               ; next_free to HL 
9302			      ld    H, (IX+1) 
9302			 
9302			      ld    (IX+2), L               ; HL to this_free 
9302			      ld    (IX+3), H 
9302			 
9302			 
9302			malloc_update_links: 
9302			      ; Update prev_free ptr to point to this_free 
9302			      ld    L, (IX+4)               ; prev_free ptr to HL 
9302			      ld    H, (IX+5) 
9302			 
9302			      ld    E, (IX+2)               ; this_free ptr to DE 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (HL), E                 ; this_free ptr into prev_free 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Clear the Z flag to indicate successful allocation 
9302			      ld    A, D 
9302			      or    E 
9302			 
9302			      pop   DE                      ; Address of allocation 
9302			 
9302			malloc_no_space: 
9302			      ld    HL, 6                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			      ex    DE, HL                  ; Alloc addr into HL for return 
9302			 
9302			malloc_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     free                                                                    : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9302			;     returned by malloc, otherwise the behaviour is undefined.               : 
9302			;                                                                             : 
9302			;     Where possible, directly adjacent free blocks will be merged together   : 
9302			;     into larger blocks to help ensure that the heap does not become         : 
9302			;     excessively fragmented.                                                 : 
9302			;                                                                             : 
9302			;     free does not clear or set any other value into the freed space, and    : 
9302			;     therefore its contents may be visible through subsequent malloc's. The  : 
9302			;     caller should clear the freed space as required.                        : 
9302			;                                                                             : 
9302			;     This implementation of free uses the stack exclusively, and is          : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling free, and recommended    : 
9302			;     to avoid the use of free inside ISRs in general.                        : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Pointer to address of first byte of allocation to be freed          : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			free: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if ptr is null 
9302			      or    L 
9302			      jp    Z, free_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; The address in HL points to the start of the useable allocated space, 
9302			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9302			      ; address of the block itself. 
9302			      ex    DE, HL 
9302			      ld    DE, -4 
9302			      add   HL, DE 
9302			 
9302			      ; An allocated block must have a null next block pointer in it 
9302			      ld    A, (HL) 
9302			      inc   HL 
9302			      or    (HL) 
9302			      jp    NZ, free_done 
9302			 
9302			      dec   HL 
9302			 
9302			      ld    B, H                    ; Copy HL to BC 
9302			      ld    C, L 
9302			 
9302			      ; Loop through the free list to find the first block with an address 
9302			      ; higher than the block being freed 
9302			      ld    HL, free_list 
9302			 
9302			free_find_higher_block: 
9302			      ld    E, (HL)                 ; Load next ptr from free block 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			 
9302			      ld    (IX+0), E               ; Save ptr to next free block 
9302			      ld    (IX+1), D 
9302			      ld    (IX+2), L               ; Save ptr to prev free block 
9302			      ld    (IX+3), H 
9302			 
9302			      ld    A, B                    ; Check if DE is greater than BC 
9302			      cp    D                       ; Compare MSB first 
9302			      jr    Z, $+4                  ; MSB the same, compare LSB 
9302			      jr    NC, free_find_higher_block_skip 
9302			      ld    A, C 
9302			      cp    E                       ; Then compare LSB 
9302			      jr    C, free_found_higher_block 
9302			 
9302			free_find_higher_block_skip: 
9302			      ld    A, D                    ; Reached the end of the free list? 
9302			      or    E 
9302			      jp    Z, free_done 
9302			 
9302			      ex    DE, HL 
9302			 
9302			      jr    free_find_higher_block 
9302			 
9302			free_found_higher_block: 
9302			      ; Insert freed block between prev and next free blocks 
9302			      ld    (HL), C                 ; Point prev free block to freed block 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			 
9302			      ld    H, B                    ; Point freed block at next free block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Check if the freed block is adjacent to the next free block 
9302			      inc   HL                      ; Load size of freed block into HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      add   HL, BC                  ; Add addr of freed block and its size 
9302			 
9302			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_check_adjacent_to_prev 
9302			 
9302			      ; Freed block is adjacent to next, merge into one bigger block 
9302			      ex    DE, HL                  ; Load next ptr from next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save ptr to next block for later 
9302			 
9302			      ld    H, B                    ; Store ptr from next block into freed block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore ptr to next block 
9302			      inc   HL                      ; Load size of next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save next block size for later 
9302			 
9302			      ld    H, B                    ; Load size of freed block into HL 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      pop   DE                      ; Restore size of next block 
9302			      add   HL, DE                  ; Add sizes of both blocks 
9302			      ex    DE, HL 
9302			 
9302			      ld    H, B                    ; Store new bigger size into freed block 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_check_adjacent_to_prev: 
9302			      ; Check if the freed block is adjacent to the prev free block 
9302			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9302			      ld    H, (IX+3) 
9302			 
9302			      inc   HL                      ; Size of prev free block into DE 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      add   HL, DE                  ; Add prev block addr and size 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_done 
9302			 
9302			      ; Freed block is adjacent to prev, merge into one bigger block 
9302			      ld    H, B                    ; Load next ptr from freed block into DE 
9302			      ld    L, C 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save freed block ptr for later 
9302			 
9302			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9302			      ld    H, (IX+3) 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore freed block ptr 
9302			      inc   HL                      ; Load size of freed block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save freed block size for later 
9302			 
9302			      ld    L, (IX+2)               ; Load size of prev block into DE 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      pop   HL                      ; Add sizes of both blocks 
9302			      add   HL, DE 
9302			      ex    DE, HL 
9302			 
9302			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_done: 
9302			      ld    HL, 4                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			free_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;      .org 0x8000 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			 ;                 .dw   0 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_4 
9302			 
9302			; My memory allocation code. Very very simple.... 
9302			; allocate space under 250 chars 
9302			 
9302			heap_init: 
9302				; init start of heap as zero 
9302				;  
9302			 
9302				ld hl, heap_start 
9302				ld a, 0 
9302				ld (hl), a      ; empty block 
9302				inc hl 
9302				ld a, 0 
9302				ld (hl), a      ; length of block 
9302				; write end of list 
9302				inc hl 
9302				ld a,(hl) 
9302				inc hl 
9302				ld a,(hl) 
9302				 
9302			 
9302				; init some malloc vars 
9302			 
9302				ld hl, 0 
9302				ld (free_list), hl       ; store last malloc location 
9302			 
9302				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9302				ld a, 0 
9302				ld (hl), a 
9302			 
9302			 
9302				ld hl, heap_start 
9302				;  
9302				  
9302				ret 
9302			 
9302			 
9302			;    free block marker 
9302			;    requested size  
9302			;    pointer to next block 
9302			;    .... 
9302			;    next block marker 
9302			 
9302			 
9302			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9302			; 
9302			 
9302			 
9302			malloc:  
9302				push de 
9302				push bc 
9302				push af 
9302			 
9302				; hl space required 
9302				 
9302				ld c, l    ; hold space   (TODO only a max of 255) 
9302			 
9302			;	inc c     ; TODO BUG need to fix memory leak on push str 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			 
9302			 
9302			 
9302				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9302			 
9302				ld a, (free_list+3) 
9302				cp 0 
9302				jr z, .contheap 
9302			 
9302				ld hl, (free_list)     ; get last alloc 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mrs" 
9302						CALLMONITOR 
9302					endif 
9302				jr .startalloc 
9302			 
9302			.contheap: 
9302				ld hl, heap_start 
9302			 
9302			.startalloc: 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mym" 
9302						CALLMONITOR 
9302					endif 
9302			.findblock: 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmf" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302				ld a,(hl)  
9302				; if byte is zero then clear to use 
9302			 
9302				cp 0 
9302				jr z, .foundemptyblock 
9302			 
9302				; if byte is not clear 
9302				;     then byte is offset to next block 
9302			 
9302				inc hl 
9302				ld a, (hl) ; get size 
9302			.nextblock:	inc hl 
9302					ld e, (hl) 
9302					inc hl 
9302					ld d, (hl) 
9302					ex de, hl 
9302			;	inc hl  ; move past the store space 
9302			;	inc hl  ; move past zero index  
9302			 
9302				; TODO detect no more space 
9302			 
9302				push hl 
9302				ld de, heap_end 
9302				call cmp16 
9302				pop hl 
9302				jr nc, .nospace 
9302			 
9302				jr .findblock 
9302			 
9302			.nospace: ld hl, 0 
9302				jp .exit 
9302			 
9302			 
9302			.foundemptyblock:	 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mme" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; TODO has block enough space if reusing??? 
9302			 
9302				;  
9302			 
9302			; see if this block has been previously used 
9302				inc hl 
9302				ld a, (hl) 
9302				dec hl 
9302				cp 0 
9302				jr z, .newblock 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meR" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; no reusing previously allocated block 
9302			 
9302			; is it smaller than previously used? 
9302				 
9302				inc hl    ; move to size 
9302				ld a, c 
9302				sub (hl)        ; we want c < (hl) 
9302				dec hl    ; move back to marker 
9302			        jr z, .findblock 
9302			 
9302				; update with the new size which should be lower 
9302			 
9302			        ;inc  hl   ; negate next move. move back to size  
9302			 
9302			.newblock: 
9302				; need to be at marker here 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meN" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			 
9302				ld a, c 
9302			 
9302				ld (free_list+3), a	 ; flag resume from last malloc  
9302				ld (free_list), hl    ; save out last location 
9302			 
9302			 
9302				;inc a     ; space for length byte 
9302				ld (hl), a     ; save block in use marker 
9302			 
9302				inc hl   ; move to space marker 
9302				ld (hl), a    ; save new space 
9302			 
9302				inc hl   ; move to start of allocated area 
9302				 
9302			;	push hl     ; save where we are - 1  
9302			 
9302			;	inc hl  ; move past zero index  
9302				; skip space to set down new marker 
9302			 
9302				; provide some extra space for now 
9302			 
9302				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9302				inc a 
9302				inc a 
9302			 
9302				push hl   ; save where we are in the node block 
9302			 
9302				call addatohl 
9302			 
9302				; write linked list point 
9302			 
9302				pop de     ; get our node position 
9302				ex de, hl 
9302			 
9302				ld (hl), e 
9302				inc hl 
9302				ld (hl), d 
9302			 
9302				inc hl 
9302			 
9302				; now at start of allocated data so save pointer 
9302			 
9302				push hl 
9302			 
9302				; jump to position of next node and setup empty header in DE 
9302			 
9302				ex de, hl 
9302			 
9302			;	inc hl ; move past end of block 
9302			 
9302				ld a, 0 
9302				ld (hl), a   ; empty marker 
9302				inc hl 
9302				ld (hl), a   ; size 
9302				inc hl  
9302				ld (hl), a   ; ptr 
9302				inc hl 
9302				ld (hl), a   ; ptr 
9302			 
9302			 
9302				pop hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmr" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			.exit: 
9302				pop af 
9302				pop bc 
9302				pop de  
9302				ret 
9302			 
9302			 
9302			 
9302			 
9302			free:  
9302				push hl 
9302				push af 
9302				; get address in hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "fre" 
9302						CALLMONITOR 
9302					endif 
9302				; data is at hl - move to block count 
9302				dec hl 
9302				dec hl    ; get past pointer 
9302				dec hl 
9302			 
9302				ld a, (hl)    ; need this for a validation check 
9302			 
9302				dec hl    ; move to block marker 
9302			 
9302				; now check that the block count and block marker are the same  
9302			        ; this checks that we are on a malloc node and not random memory 
9302			        ; OK a faint chance this could be a problem but rare - famous last words! 
9302			 
9302				ld c, a 
9302				ld a, (hl)    
9302			 
9302				cp c 
9302				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9302			 
9302				; yes good chance we are on a malloc node 
9302			 
9302				ld a, 0      
9302				ld (hl), a   ; mark as free 
9302			 
9302				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9302			 
9302			.freeignore:  
9302			 
9302				pop af 
9302				pop hl 
9302			 
9302				ret 
9302			 
9302			 
9302			 
9302			endif 
9302			 
9302			; eof 
# End of file firmware_memory.asm
9302			  
9302			; device C  
9302			if SOUND_ENABLE  
9302				include "firmware_sound.asm"  
9302			endif  
9302			  
9302			include "firmware_diags.asm"  
9302			; Hardware diags menu 
9302			 
9302			 
9302			config: 
9302			 
9302 3e 00			ld a, 0 
9304 21 32 93			ld hl, .configmn 
9307 cd a6 8a			call menu 
930a			 
930a fe 00			cp 0 
930c c8				ret z 
930d			 
930d fe 01			cp 1 
930f cc 60 93			call z, .savetostore 
9312			 
9312 fe 02			cp 2 
9314 cc 4c 93			call z, .selautoload 
9317 fe 03			cp 3 
9319 cc 42 93			call z, .disautoload 
931c fe 04			cp 4 
931e cc 56 93			call z, .selbank 
9321 fe 05			cp 5 
9323 cc 6a 93			call z, .debug_tog 
9326 fe 06			cp 6 
9328 cc ad 94			call z, .bpsgo 
932b fe 07			cp 7 
932d cc 90 93			call z, hardware_diags 
9330			 
9330 18 d0			jr config 
9332			 
9332			.configmn: 
9332 9e 96			dw prom_c3 
9334 b5 96			dw prom_c2 
9336 ca 96			dw prom_c2a 
9338 e0 96			dw prom_c2b 
933a			;	dw prom_c4 
933a fd 96			dw prom_m4 
933c 18 97			dw prom_m4b 
933e 20 97			dw prom_c1 
9340 00 00			dw 0 
9342				 
9342			 
9342			 
9342			 
9342			.disautoload: 
9342				if STORAGE_SE 
9342				ld a, $fe      ; bit 0 clear 
9342				ld (spi_device), a 
9342			 
9342				call storage_get_block_0 
9342			 
9342				ld a, 0 
9342				ld (store_page+STORE_0_AUTOFILE), a 
9342			 
9342					ld hl, 0 
9342					ld de, store_page 
9342				call storage_write_block	 ; save update 
9342				else 
9342			 
9342 21 2f 97			ld hl, prom_notav 
9345 11 45 97			ld de, prom_empty 
9348 cd 06 8a			call info_panel 
934b				endif 
934b			 
934b			 
934b c9				ret 
934c			 
934c			 
934c			 
934c			; Select auto start 
934c			 
934c			.selautoload: 
934c			 
934c				 
934c				if STORAGE_SE 
934c			 
934c					call config_dir 
934c				        ld hl, scratch 
934c					ld a, 0 
934c					call menu 
934c			 
934c					cp 0 
934c					ret z 
934c			 
934c					dec a 
934c			 
934c			 
934c					; locate menu option 
934c			 
934c					ld hl, scratch 
934c					call table_lookup 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALl" 
934c						CALLMONITOR 
934c					endif 
934c					; with the pointer to the menu it, the byte following the zero term is the file id 
934c			 
934c					ld a, 0 
934c					ld bc, 50   ; max of bytes to look at 
934c					cpir  
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALb" 
934c						CALLMONITOR 
934c					endif 
934c					;inc hl 
934c			 
934c					ld a, (hl)   ; file id 
934c					 
934c				        ; save bank and file ids 
934c			 
934c					push af 
934c			 
934c			; TODO need to save to block 0 on bank 1	 
934c			 
934c					call storage_get_block_0 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "AL0" 
934c						CALLMONITOR 
934c					endif 
934c					pop af 
934c			 
934c					ld (store_page+STORE_0_FILERUN),a 
934c					 
934c					; save bank id 
934c			 
934c					ld a,(spi_device) 
934c					ld (store_page+STORE_0_BANKRUN),a 
934c			 
934c					; enable auto run of store file 
934c			 
934c					ld a, 1 
934c					ld (store_page+STORE_0_AUTOFILE),a 
934c			 
934c					; save buffer 
934c			 
934c					ld hl, 0 
934c					ld de, store_page 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALw" 
934c						CALLMONITOR 
934c					endif 
934c				call storage_write_block	 ; save update 
934c			  
934c			 
934c			 
934c			 
934c					ld hl, scratch 
934c					call config_fdir 
934c			 
934c				else 
934c			 
934c 21 2f 97			ld hl, prom_notav 
934f 11 45 97			ld de, prom_empty 
9352 cd 06 8a			call info_panel 
9355			 
9355				endif 
9355 c9				ret 
9356			 
9356			 
9356			 
9356			; Select storage bank 
9356			 
9356			.selbank: 
9356			 
9356				if STORAGE_SE 
9356				else 
9356			 
9356 21 2f 97			ld hl, prom_notav 
9359 11 45 97			ld de, prom_empty 
935c cd 06 8a			call info_panel 
935f				endif 
935f				 
935f c9				ret 
9360			 
9360			if STORAGE_SE 
9360			 
9360			.config_ldir:   
9360				; Load storage bank labels into menu array 
9360			 
9360				 
9360			 
9360			 
9360				ret 
9360			 
9360			 
9360			endif 
9360			 
9360			 
9360			; Save user words to storage 
9360			 
9360			.savetostore: 
9360			 
9360				if STORAGE_SE 
9360			 
9360					call config_dir 
9360				        ld hl, scratch 
9360					ld a, 0 
9360					call menu 
9360					 
9360					ld hl, scratch 
9360					call config_fdir 
9360			 
9360				else 
9360			 
9360 21 2f 97			ld hl, prom_notav 
9363 11 45 97			ld de, prom_empty 
9366 cd 06 8a			call info_panel 
9369			 
9369				endif 
9369			 
9369 c9				ret 
936a			 
936a			 
936a			 
936a			if STORAGE_SE 
936a			 
936a			config_fdir: 
936a				; using the scratch dir go through and release the memory allocated for each string 
936a				 
936a				ld hl, scratch 
936a			.cfdir:	ld e,(hl) 
936a				inc hl 
936a				ld d,(hl) 
936a				inc hl 
936a			 
936a				ex de, hl 
936a				call ishlzero 
936a				ret z     ; return on null pointer 
936a				call free 
936a				ex de, hl 
936a				jr .cfdir 
936a			 
936a			 
936a				ret 
936a			 
936a			 
936a			config_dir: 
936a			 
936a				; for the config menus that need to build a directory of storage call this routine 
936a				; it will construct a menu in scratch to pass to menu 
936a			 
936a				; open storage device 
936a			 
936a				; execute DIR to build a list of files and their ids into scratch in menu format 
936a				; once the menu has finished then will need to call config_fdir to release the strings 
936a				 
936a				; c = number items 
936a			 
936a				 
936a				call storage_get_block_0 
936a			 
936a				ld hl, store_page     ; get current id count 
936a				ld b, (hl) 
936a				ld c, 0    ; count of files   
936a			 
936a			 
936a				ld hl, scratch 
936a				ld (store_tmp2), hl    ; location to poke strings 
936a			 
936a				; check for empty drive 
936a			 
936a				ld a, 0 
936a				cp b 
936a				jp z, .dirdone 
936a			 
936a				 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdc" 
936a						CALLMONITOR 
936a					endif 
936a			 
936a			 
936a			.diritem:	 
936a				push bc 
936a				; for each of the current ids do a search for them and if found push to stack 
936a			 
936a					ld hl, STORE_BLOCK_PHY 
936a					ld d, 0		 ; look for extent 0 of block id as this contains file name 
936a					ld e,b 
936a			 
936a					call storage_findnextid 
936a			 
936a			 
936a					; if found hl will be non zero 
936a			 
936a					call ishlzero 
936a					jr z, .dirnotfound 
936a			 
936a					; increase count 
936a			 
936a					pop bc	 
936a					inc c 
936a					push bc 
936a					 
936a			 
936a					; get file header and push the file name 
936a			 
936a					ld de, store_page 
936a					call storage_read_block 
936a			 
936a					; push file id to stack 
936a				 
936a					ld a, (store_page) 
936a					ld h, 0 
936a					ld l, a 
936a			 
936a					;call forth_push_numhl 
936a					; TODO store id 
936a			 
936a					push hl 
936a			 
936a					; push extent count to stack  
936a				 
936a					ld hl, store_page+3 
936a			 
936a					; get file name length 
936a			 
936a					call strlenz   
936a			 
936a					inc hl   ; cover zero term 
936a					inc hl  ; stick the id at the end of the area 
936a			 
936a					push hl 
936a					pop bc    ; move length to bc 
936a			 
936a					call malloc 
936a			 
936a					; TODO save malloc area to scratch 
936a			 
936a					ex de, hl 
936a					ld hl, (store_tmp2) 
936a					ld (hl), e 
936a					inc hl 
936a					ld (hl), d 
936a					inc hl 
936a					ld (store_tmp2), hl 
936a			 
936a					 
936a			 
936a					;pop hl   ; get source 
936a			;		ex de, hl    ; swap aronund	 
936a			 
936a					ld hl, store_page+3 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "CFd" 
936a						CALLMONITOR 
936a					endif 
936a					ldir 
936a			 
936a					; de is past string, move back one and store id 
936a					 
936a					dec de 
936a			 
936a					; store file id 
936a			 
936a					pop hl 
936a					ex de,hl 
936a					ld (hl), e 
936a			 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdi" 
936a						CALLMONITOR 
936a					endif 
936a					 
936a			.dirnotfound: 
936a					pop bc     
936a					djnz .diritem 
936a				 
936a			.dirdone:	 
936a			 
936a					ld a, 0 
936a					ld hl, (store_tmp2) 
936a					ld (hl), a 
936a					inc hl 
936a					ld (hl), a 
936a					inc hl 
936a					; push a count of the dir items found 
936a			 
936a			;		ld h, 0 
936a			;		ld l, c 
936a			 
936a				ret 
936a			 
936a			endif 
936a			 
936a			 
936a			; Settings 
936a			; Run  
936a			 
936a			 
936a			 
936a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
936a			;;hd_menu2:   db "        2: Editor",0   
936a			;hd_menu2:   db "        2: Editor       6: Menu",0   
936a			;hd_menu3:   db "        3: Storage",0 
936a			;hd_menu4:   db "0=quit  4: Debug",0 
936a			;hd_don:     db "ON",0 
936a			;hd_doff:     db "OFF",0 
936a			; 
936a			; 
936a			; 
936a			;hardware_diags_old:       
936a			; 
936a			;.diagmenu: 
936a			;	call clear_display 
936a			;	ld a, display_row_1 
936a			;	ld de, hd_menu1 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_2 
936a			;	ld de, hd_menu2 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_3 
936a			;	ld de, hd_menu3 
936a			;	call str_at_display 
936a			; 
936a			;	ld a,  display_row_4 
936a			;	ld de, hd_menu4 
936a			;	call str_at_display 
936a			; 
936a			;	; display debug state 
936a			; 
936a			;	ld de, hd_don 
936a			;	ld a, (os_view_disable) 
936a			;	cp 0 
936a			;	jr z, .distog 
936a			;	ld de, hd_doff 
936a			;.distog: ld a, display_row_4+17 
936a			;	call str_at_display 
936a			; 
936a			;	call update_display 
936a			; 
936a			;	call cin_wait 
936a			; 
936a			; 
936a			; 
936a			;	cp '4' 
936a			;	jr nz, .diagn1 
936a			; 
936a			;	; debug toggle 
936a			; 
936a			;	ld a, (os_view_disable) 
936a			;	ld b, '*' 
936a			;	cp 0 
936a			;	jr z, .debtog 
936a			;	ld b, 0 
936a			;.debtog:	 
936a			;	ld a,b 
936a			;	ld (os_view_disable),a 
936a			; 
936a			;.diagn1: cp '0' 
936a			;	 ret z 
936a			; 
936a			;;	cp '1' 
936a			;;       jp z, matrix	 
936a			;;   TODO keyboard matrix test 
936a			; 
936a			;	cp '2' 
936a			;	jp z, .diagedit 
936a			; 
936a			;;	cp '6' 
936a			;;	jp z, .menutest 
936a			;;if ENABLE_BASIC 
936a			;;	cp '6' 
936a			;;	jp z, basic 
936a			;;endif 
936a			 ; 
936a			;	jp .diagmenu 
936a			; 
936a			; 
936a			;	ret 
936a			 
936a			 
936a			.debug_tog: 
936a 21 b1 93			ld hl, .menudebug 
936d				 
936d 3a 42 e4			ld a, (os_view_disable) 
9370 fe 2a			cp '*' 
9372 20 04			jr nz,.tdon  
9374 3e 01			ld a, 1 
9376 18 02			jr .tog1 
9378 3e 00		.tdon: ld a, 0 
937a			 
937a			.tog1: 
937a cd a6 8a			call menu 
937d fe 00			cp 0 
937f c8				ret z 
9380 fe 01			cp 1    ; disable debug 
9382 28 04			jr z, .dtog0 
9384 3e 2a			ld a, '*' 
9386 18 02			jr .dtogset 
9388 3e 00		.dtog0: ld a, 0 
938a 32 42 e4		.dtogset:  ld (os_view_disable), a 
938d c3 6a 93			jp .debug_tog 
9390			 
9390			 
9390			hardware_diags:       
9390			 
9390			.diagm: 
9390 21 a3 93			ld hl, .menuitems 
9393 3e 00			ld a, 0 
9395 cd a6 8a			call menu 
9398			 
9398 fe 00		         cp 0 
939a c8				 ret z 
939b			 
939b fe 02			cp 2 
939d ca fc 93			jp z, .diagedit 
93a0			 
93a0			;	cp '6' 
93a0			;	jp z, .menutest 
93a0			;if ENABLE_BASIC 
93a0			;	cp '6' 
93a0			;	jp z, basic 
93a0			;endif 
93a0			  
93a0 c3 90 93			jp .diagm 
93a3			 
93a3				 
93a3 b7 93		.menuitems:   	dw .m1 
93a5 c2 93				dw .m2 
93a7 c9 93				dw .m3 
93a9 d1 93				dw .m5 
93ab d7 93				dw .m5a 
93ad e0 93				dw .m5b 
93af 00 00				dw 0 
93b1			 
93b1			.menudebug: 
93b1 e9 93				dw .m6 
93b3 f2 93				dw .m7 
93b5 00 00				dw 0 
93b7			 
93b7 .. 00		.m1:   db "Key Matrix",0 
93c2 .. 00		.m2:   db "Editor",0 
93c9 .. 00		.m3:   db "Storage",0 
93d1 .. 00		.m5:   db "Sound",0 
93d7 .. 00		.m5a:  db "RAM Test",0 
93e0 .. 00		.m5b:  db "LCD Test",0 
93e9			 
93e9 .. 00		.m6:   db "Debug ON",0 
93f2 .. 00		.m7:   db "Debug OFF",0 
93fc			 
93fc			; debug editor 
93fc			 
93fc			.diagedit: 
93fc			 
93fc 21 51 e4			ld hl, scratch 
93ff			;	ld bc, 250 
93ff			;	ldir 
93ff				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93ff 3e 00			ld a, 0 
9401 77				ld (hl), a 
9402 23				inc hl 
9403 77				ld (hl), a 
9404 23				inc hl 
9405 77				ld (hl), a 
9406			 
9406 cd 75 8a		        call clear_display 
9409 cd 98 8a			call update_display 
940c				;ld a, 1 
940c				;ld (hardware_diag), a 
940c			.diloop: 
940c 3e 00			ld a, display_row_1 
940e 0e 00			ld c, 0 
9410 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9412 1e 28			ld e, 40 
9414			 
9414 21 51 e4			ld hl, scratch	 
9417 cd cf 8c			call input_str 
941a			 
941a 3e 14			ld a, display_row_2 
941c 11 51 e4			ld de, scratch 
941f cd 88 8a			call str_at_display 
9422 cd 98 8a			call update_display 
9425			 
9425 c3 0c 94			jp .diloop 
9428			 
9428			 
9428			; pass word in hl 
9428			; a has display location 
9428			display_word_at: 
9428 f5				push af 
9429 e5				push hl 
942a 7c				ld a,h 
942b 21 56 e7			ld hl, os_word_scratch 
942e cd a3 8f			call hexout 
9431 e1				pop hl 
9432 7d				ld a,l 
9433 21 58 e7			ld hl, os_word_scratch+2 
9436 cd a3 8f			call hexout 
9439 21 5a e7			ld hl, os_word_scratch+4 
943c 3e 00			ld a,0 
943e 77				ld (hl),a 
943f 11 56 e7			ld de,os_word_scratch 
9442 f1				pop af 
9443 cd 88 8a				call str_at_display 
9446 c9				ret 
9447			 
9447			display_ptr_state: 
9447			 
9447				; to restore afterwards 
9447			 
9447 d5				push de 
9448 c5				push bc 
9449 e5				push hl 
944a f5				push af 
944b			 
944b				; for use in here 
944b			 
944b			;	push bc 
944b			;	push de 
944b			;	push hl 
944b			;	push af 
944b			 
944b cd 75 8a			call clear_display 
944e			 
944e 11 21 96			ld de, .ptrstate 
9451 3e 00			ld a, display_row_1 
9453 cd 88 8a			call str_at_display 
9456			 
9456				; display debug step 
9456			 
9456			 
9456 11 b7 ee			ld de, debug_mark 
9459 3e 12			ld a, display_row_1+display_cols-2 
945b cd 88 8a			call str_at_display 
945e			 
945e				; display a 
945e 11 2b 96			ld de, .ptrcliptr 
9461 3e 14			ld a, display_row_2 
9463 cd 88 8a			call str_at_display 
9466			 
9466 f1				pop af 
9467 2a d0 eb			ld hl,(cli_ptr) 
946a 3e 1c			ld a, display_row_2+8 
946c cd 28 94			call display_word_at 
946f			 
946f			 
946f				; display hl 
946f			 
946f			 
946f 11 33 96			ld de, .ptrclioptr 
9472 3e 1e			ld a, display_row_2+10 
9474 cd 88 8a			call str_at_display 
9477			; 
9477			;	pop hl 
9477 3e 21			ld a, display_row_2+13 
9479 2a ce eb			ld hl,(cli_origptr) 
947c cd 28 94			call display_word_at 
947f			; 
947f			;	 
947f			;	; display de 
947f			 
947f			;	ld de, .regstatede 
947f			;	ld a, display_row_3 
947f			;	call str_at_display 
947f			 
947f			;	pop de 
947f			;	ld h,d 
947f			;	ld l, e 
947f			;	ld a, display_row_3+3 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display bc 
947f			 
947f			;	ld de, .regstatebc 
947f			;	ld a, display_row_3+10 
947f			;	call str_at_display 
947f			 
947f			;	pop bc 
947f			;	ld h,b 
947f			;	ld l, c 
947f			;	ld a, display_row_3+13 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display dsp 
947f			 
947f			;	ld de, .regstatedsp 
947f			;	ld a, display_row_4 
947f			;	call str_at_display 
947f			 
947f				 
947f			;	ld hl,(cli_data_sp) 
947f			;	ld a, display_row_4+4 
947f			;	call display_word_at 
947f			 
947f				; display rsp 
947f			 
947f 11 62 96			ld de, .regstatersp 
9482 3e 46			ld a, display_row_4+10 
9484 cd 88 8a			call str_at_display 
9487			 
9487				 
9487 2a 82 eb			ld hl,(cli_ret_sp) 
948a 3e 4a			ld a, display_row_4+14 
948c cd 28 94			call display_word_at 
948f			 
948f cd 98 8a			call update_display 
9492			 
9492 cd f2 89			call delay1s 
9495 cd f2 89			call delay1s 
9498 cd f2 89			call delay1s 
949b			 
949b			 
949b cd 8c 9a			call next_page_prompt 
949e			 
949e				; restore  
949e			 
949e f1				pop af 
949f e1				pop hl 
94a0 c1				pop bc 
94a1 d1				pop de 
94a2 c9				ret 
94a3			 
94a3			break_point_state: 
94a3 f5				push af 
94a4			 
94a4				; see if disabled 
94a4			 
94a4 3a 42 e4			ld a, (os_view_disable) 
94a7 fe 2a			cp '*' 
94a9 20 02			jr nz, .bpsgo 
94ab f1				pop af 
94ac c9				ret 
94ad			 
94ad			.bpsgo: 
94ad f1				pop af 
94ae f5				push af 
94af 22 3e e4			ld (os_view_hl), hl 
94b2 ed 53 3c e4		ld (os_view_de), de 
94b6 ed 43 3a e4		ld (os_view_bc), bc 
94ba e5				push hl 
94bb 6f				ld l, a 
94bc 26 00			ld h, 0 
94be 22 40 e4			ld (os_view_af),hl 
94c1			 
94c1 21 4d ee				ld hl, display_fb0 
94c4 22 58 ed				ld (display_fb_active), hl 
94c7 e1				pop hl	 
94c8			 
94c8 3e 31			ld a, '1' 
94ca fe 2a		.bps1:  cp '*' 
94cc 20 03			jr nz, .bps1b 
94ce 32 42 e4			ld (os_view_disable),a 
94d1 fe 31		.bps1b:  cp '1' 
94d3 20 14			jr nz, .bps2 
94d5			 
94d5				; display reg 
94d5			 
94d5				 
94d5			 
94d5 3a 40 e4			ld a, (os_view_af) 
94d8 2a 3e e4			ld hl, (os_view_hl) 
94db ed 5b 3c e4		ld de, (os_view_de) 
94df ed 4b 3a e4		ld bc, (os_view_bc) 
94e3 cd 7d 95			call display_reg_state 
94e6 c3 69 95			jp .bpschk 
94e9			 
94e9 fe 32		.bps2:  cp '2' 
94eb 20 08			jr nz, .bps3 
94ed				 
94ed				; display hl 
94ed 2a 3e e4			ld hl, (os_view_hl) 
94f0 cd 67 96			call display_dump_at_hl 
94f3			 
94f3 18 74			jr .bpschk 
94f5			 
94f5 fe 33		.bps3:  cp '3' 
94f7 20 08			jr nz, .bps4 
94f9			 
94f9			        ; display de 
94f9 2a 3c e4			ld hl, (os_view_de) 
94fc cd 67 96			call display_dump_at_hl 
94ff			 
94ff 18 68			jr .bpschk 
9501 fe 34		.bps4:  cp '4' 
9503 20 08			jr nz, .bps5 
9505			 
9505			        ; display bc 
9505 2a 3a e4			ld hl, (os_view_bc) 
9508 cd 67 96			call display_dump_at_hl 
950b			 
950b 18 5c			jr .bpschk 
950d fe 35		.bps5:  cp '5' 
950f 20 08		        jr nz, .bps7 
9511			 
9511				; display cur ptr 
9511 2a d0 eb			ld hl, (cli_ptr) 
9514 cd 67 96			call display_dump_at_hl 
9517			 
9517 18 50			jr .bpschk 
9519 fe 36		.bps7:  cp '6' 
951b 20 08			jr nz, .bps8b 
951d				 
951d				; display cur orig ptr 
951d 2a ce eb			ld hl, (cli_origptr) 
9520 cd 67 96			call display_dump_at_hl 
9523 18 44			jr .bpschk 
9525 fe 37		.bps8b:  cp '7' 
9527 20 08			jr nz, .bps9 
9529				 
9529				; display dsp 
9529 2a 7e eb			ld hl, (cli_data_sp) 
952c cd 67 96			call display_dump_at_hl 
952f			 
952f 18 38			jr .bpschk 
9531 fe 39		.bps9:  cp '9' 
9533 20 05			jr nz, .bps8c 
9535				 
9535				; display SP 
9535			;	ld hl, sp 
9535 cd 67 96			call display_dump_at_hl 
9538			 
9538 18 2f			jr .bpschk 
953a fe 38		.bps8c:  cp '8' 
953c 20 08			jr nz, .bps8d 
953e				 
953e				; display rsp 
953e 2a 82 eb			ld hl, (cli_ret_sp) 
9541 cd 67 96			call display_dump_at_hl 
9544			 
9544 18 23			jr .bpschk 
9546 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9548 20 05			jr nz, .bps8 
954a cd 82 98			call monitor 
954d			 
954d 18 1a			jr .bpschk 
954f fe 30		.bps8:  cp '0' 
9551 20 16			jr nz, .bpschk 
9553			 
9553 21 fc ed				ld hl, display_fb1 
9556 22 58 ed				ld (display_fb_active), hl 
9559 cd 98 8a				call update_display 
955c			 
955c				;ld a, (os_view_af) 
955c 2a 3e e4			ld hl, (os_view_hl) 
955f ed 5b 3c e4		ld de, (os_view_de) 
9563 ed 4b 3a e4		ld bc, (os_view_bc) 
9567 f1				pop af 
9568 c9				ret 
9569			 
9569			.bpschk:   
9569 cd f2 89			call delay1s 
956c 3e 4f		ld a,display_row_4 + display_cols - 1 
956e 11 8a 9a		        ld de, endprg 
9571 cd 88 8a			call str_at_display 
9574 cd 98 8a			call update_display 
9577 cd be e1			call cin_wait 
957a			 
957a c3 ca 94			jp .bps1 
957d			 
957d			 
957d			display_reg_state: 
957d			 
957d				; to restore afterwards 
957d			 
957d d5				push de 
957e c5				push bc 
957f e5				push hl 
9580 f5				push af 
9581			 
9581				; for use in here 
9581			 
9581 c5				push bc 
9582 d5				push de 
9583 e5				push hl 
9584 f5				push af 
9585			 
9585 cd 75 8a			call clear_display 
9588			 
9588 11 3d 96			ld de, .regstate 
958b 3e 00			ld a, display_row_1 
958d cd 88 8a			call str_at_display 
9590			 
9590				; display debug step 
9590			 
9590			 
9590 11 b7 ee			ld de, debug_mark 
9593 3e 11			ld a, display_row_1+display_cols-3 
9595 cd 88 8a			call str_at_display 
9598			 
9598				; display a 
9598 11 59 96			ld de, .regstatea 
959b 3e 14			ld a, display_row_2 
959d cd 88 8a			call str_at_display 
95a0			 
95a0 e1				pop hl 
95a1			;	ld h,0 
95a1			;	ld l, a 
95a1 3e 17			ld a, display_row_2+3 
95a3 cd 28 94			call display_word_at 
95a6			 
95a6			 
95a6				; display hl 
95a6			 
95a6			 
95a6 11 4d 96			ld de, .regstatehl 
95a9 3e 1e			ld a, display_row_2+10 
95ab cd 88 8a			call str_at_display 
95ae			 
95ae e1				pop hl 
95af 3e 21			ld a, display_row_2+13 
95b1 cd 28 94			call display_word_at 
95b4			 
95b4				 
95b4				; display de 
95b4			 
95b4 11 51 96			ld de, .regstatede 
95b7 3e 28			ld a, display_row_3 
95b9 cd 88 8a			call str_at_display 
95bc			 
95bc e1				pop hl 
95bd			;	ld h,d 
95bd			;	ld l, e 
95bd 3e 2b			ld a, display_row_3+3 
95bf cd 28 94			call display_word_at 
95c2			 
95c2			 
95c2				; display bc 
95c2			 
95c2 11 55 96			ld de, .regstatebc 
95c5 3e 32			ld a, display_row_3+10 
95c7 cd 88 8a			call str_at_display 
95ca			 
95ca e1				pop hl 
95cb			;	ld h,b 
95cb			;	ld l, c 
95cb 3e 35			ld a, display_row_3+13 
95cd cd 28 94			call display_word_at 
95d0			 
95d0			 
95d0				; display dsp 
95d0			 
95d0 11 5d 96			ld de, .regstatedsp 
95d3 3e 3c			ld a, display_row_4 
95d5 cd 88 8a			call str_at_display 
95d8			 
95d8				 
95d8 2a 7e eb			ld hl,(cli_data_sp) 
95db 3e 40			ld a, display_row_4+4 
95dd cd 28 94			call display_word_at 
95e0			 
95e0				; display rsp 
95e0			 
95e0 11 62 96			ld de, .regstatersp 
95e3 3e 46			ld a, display_row_4+10 
95e5 cd 88 8a			call str_at_display 
95e8			 
95e8				 
95e8 2a 82 eb			ld hl,(cli_ret_sp) 
95eb 3e 4a			ld a, display_row_4+14 
95ed cd 28 94			call display_word_at 
95f0			 
95f0 cd 98 8a			call update_display 
95f3			 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			 
95f3			 
95f3			;	call next_page_prompt 
95f3			 
95f3				; restore  
95f3			 
95f3 f1				pop af 
95f4 e1				pop hl 
95f5 c1				pop bc 
95f6 d1				pop de 
95f7 c9				ret 
95f8			 
95f8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
960c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9621 .. 00		.ptrstate:	db "Ptr State",0 
962b .. 00		.ptrcliptr:     db "cli_ptr",0 
9633 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
963d .. 00		.regstate:	db "Reg State (1/0)",0 
964d .. 00		.regstatehl:	db "HL:",0 
9651 .. 00		.regstatede:	db "DE:",0 
9655 .. 00		.regstatebc:	db "BC:",0 
9659 .. 00		.regstatea:	db "A :",0 
965d .. 00		.regstatedsp:	db "DSP:",0 
9662 .. 00		.regstatersp:	db "RSP:",0 
9667			 
9667			display_dump_at_hl: 
9667 e5				push hl 
9668 d5				push de 
9669 c5				push bc 
966a f5				push af 
966b			 
966b 22 74 e7			ld (os_cur_ptr),hl	 
966e cd 75 8a			call clear_display 
9671 cd 94 99			call dumpcont 
9674			;	call delay1s 
9674			;	call next_page_prompt 
9674			 
9674			 
9674 f1				pop af 
9675 c1				pop bc 
9676 d1				pop de 
9677 e1				pop hl 
9678 c9				ret 
9679			 
9679			;if ENABLE_BASIC 
9679			;	include "nascombasic.asm" 
9679			;	basic: 
9679			;	include "forth/FORTH.ASM" 
9679			;endif 
9679			 
9679			; eof 
9679			 
9679			 
# End of file firmware_diags.asm
9679			  
9679			include "firmware_prompts.asm"  
9679			; Prompts  
9679			 
9679			; boot messages 
9679			 
9679 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
968e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
969e			 
969e			 
969e			; config menus 
969e			 
969e .. 00		prom_c3: db "Add Dictionary To File",0 
96b5 .. 00		prom_c2: db "Select Autoload File",0 
96ca .. 00		prom_c2a: db "Disable Autoload File", 0 
96e0 .. 00		prom_c2b: db "Select Storage Bank",0 
96f4 .. 00		prom_c4: db "Settings",0 
96fd .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9718 .. 00		prom_m4b:   db "Monitor",0 
9720 .. 00		prom_c1: db "Hardware Diags",0 
972f			 
972f			 
972f .. 00		prom_notav:    db "Feature not available",0 
9745 .. 00		prom_empty:    db "",0 
9746			 
9746			; eof 
9746			 
# End of file firmware_prompts.asm
9746			  
9746			  
9746			; eof  
9746			  
# End of file firmware.asm
9746			 
9746			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9746			;if BASE_KEV  
9746			;baseram: equ 08000h 
9746			;endif 
9746			 
9746			;if BASE_SC114 
9746			;baseram:     equ    endofcode 
9746			;endif 
9746			 
9746			 
9746			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9746			 
9746			; start system 
9746			 
9746			coldstart: 
9746				; set sp 
9746				; di/ei 
9746			 
9746 f3				di 
9747 31 00 f0			ld sp, tos 
974a			;	ei 
974a			 
974a			 
974a				; disable breakpoint by default 
974a			 
974a 3e 2a			ld a,'*' 
974c 32 42 e4			ld (os_view_disable),a 
974f			 
974f				; init hardware 
974f			 
974f				; init keyboard and screen hardware 
974f			 
974f cd 1c 80			call hardware_init 
9752			 
9752			 
9752 cd f2 89			call delay1s 
9755 3e 30			ld a, display_row_3+8 
9757 11 03 80			ld de, buildtime 
975a cd 88 8a			call str_at_display 
975d cd 98 8a			call update_display 
9760			 
9760 cd f2 89			call delay1s 
9763 cd f2 89			call delay1s 
9766 cd f2 89			call delay1s 
9769			 
9769				; detect if any keys are held down to enable breakpoints at start up 
9769			 
9769 cd c4 e1			call cin  
976c fe 00			cp 0 
976e 28 03			jr z, .nokeys 
9770			 
9770				;call hardware_diags 
9770 cd 02 93			call config 
9773			 
9773			;	ld de, .bpen 
9773			;	ld a, display_row_4 
9773			;	call str_at_display 
9773			;	call update_display 
9773			; 
9773			;	ld a,0 
9773			;	ld (os_view_disable),a 
9773			; 
9773			;.bpwait: 
9773			;	call cin 
9773			;	cp 0 
9773			;	jr z, .bpwait 
9773			;	jr .nokeys 
9773			; 
9773			; 
9773			;.bpen:  db "Break points enabled!",0 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			.nokeys: 
9773			 
9773			 
9773				 
9773			 
9773			;jp  testkey 
9773			 
9773			;call storage_get_block_0 
9773			; 
9773			;ld hl, 0 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773				 
9773			;ld hl, 10 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			;stop:	nop 
9773			;	jp stop 
9773			 
9773			 
9773			 
9773			main: 
9773 cd 75 8a			call clear_display 
9776 cd 98 8a			call update_display 
9779			 
9779			 
9779			 
9779			;	call testlcd 
9779			 
9779			 
9779			 
9779 cd 91 9e			call forth_init 
977c			 
977c			 
977c			warmstart: 
977c cd 67 9e			call forth_warmstart 
977f			 
977f				; run startup word load 
977f			        ; TODO prevent this running at warmstart after crash  
977f			 
977f				if STARTUP_ENABLE 
977f					if STORAGE_SE 
977f						call forth_autoload 
977f					endif 
977f cd 58 de				call forth_startup 
9782			 
9782			 
9782				endif 
9782			 
9782				; show free memory after boot 
9782 11 1c 98			ld de, freeram 
9785 3e 00			ld a, display_row_1 
9787 cd 88 8a			call str_at_display 
978a			 
978a			; Or use heap_size word???? 
978a 21 37 e4			ld hl, heap_end 
978d 11 e2 e1			ld de, heap_start 
9790 ed 52			sbc hl, de 
9792 e5				push hl 
9793 7c				ld a,h	         	 
9794 21 56 e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9797 cd a3 8f			call hexout 
979a e1			   	pop hl 
979b			 
979b 7d				ld a,l 
979c 21 58 e7			ld hl, os_word_scratch+2 
979f cd a3 8f			call hexout 
97a2 21 5a e7			ld hl, os_word_scratch+4 
97a5 3e 00			ld a, 0 
97a7 77				ld (hl),a 
97a8 11 56 e7			ld de, os_word_scratch 
97ab 3e 0d			ld a, display_row_1 + 13 
97ad cd 88 8a			call str_at_display 
97b0 cd 98 8a			call update_display 
97b3			 
97b3			 
97b3				;call demo 
97b3			 
97b3			 
97b3				; init scratch input area for cli commands 
97b3			 
97b3 21 78 e7			ld hl, os_cli_cmd 
97b6 3e 00			ld a,0 
97b8 77				ld (hl),a 
97b9 23				inc hl 
97ba 77				ld (hl),a 
97bb			 
97bb 3e 00			ld a,0 
97bd 32 77 e8			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97c0			 
97c0 32 74 e7			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97c3 32 75 e7			ld (os_cur_ptr+1),a	 
97c6			 
97c6 32 56 e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97c9 32 57 e7			ld (os_word_scratch+1),a	 
97cc				 
97cc			 
97cc				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97cc 21 78 e7			ld hl, os_cli_cmd 
97cf			 
97cf 3e 00			ld a, 0		 ; init cli input 
97d1 77				ld (hl), a 
97d2 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d4			cli: 
97d4				; show cli prompt 
97d4				;push af 
97d4				;ld a, 0 
97d4				;ld de, prompt 
97d4				;call str_at_display 
97d4			 
97d4				;call update_display 
97d4				;pop af 
97d4				;inc a 
97d4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d4 0e 00			ld c, 0 
97d6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d8 1e 28			ld e, 40 
97da			 
97da 21 78 e7			ld hl, os_cli_cmd 
97dd			 
97dd				STACKFRAME OFF $fefe $9f9f 
97dd				if DEBUG_STACK_IMB 
97dd					if OFF 
97dd						exx 
97dd						ld de, $fefe 
97dd						ld a, d 
97dd						ld hl, curframe 
97dd						call hexout 
97dd						ld a, e 
97dd						ld hl, curframe+2 
97dd						call hexout 
97dd						ld hl, $fefe 
97dd						push hl 
97dd						ld hl, $9f9f 
97dd						push hl 
97dd						exx 
97dd					endif 
97dd				endif 
97dd			endm 
# End of macro STACKFRAME
97dd			 
97dd cd cf 8c			call input_str 
97e0			 
97e0				STACKFRAMECHK OFF $fefe $9f9f 
97e0				if DEBUG_STACK_IMB 
97e0					if OFF 
97e0						exx 
97e0						ld hl, $9f9f 
97e0						pop de   ; $9f9f 
97e0						call cmp16 
97e0						jr nz, .spnosame 
97e0						ld hl, $fefe 
97e0						pop de   ; $fefe 
97e0						call cmp16 
97e0						jr z, .spfrsame 
97e0						.spnosame: call showsperror 
97e0						.spfrsame: nop 
97e0						exx 
97e0					endif 
97e0				endif 
97e0			endm 
# End of macro STACKFRAMECHK
97e0			 
97e0				; copy input to last command 
97e0			 
97e0 21 78 e7			ld hl, os_cli_cmd 
97e3 11 77 e8			ld de, os_last_cmd 
97e6 01 ff 00			ld bc, 255 
97e9 ed b0			ldir 
97eb			 
97eb				; wipe current buffer 
97eb			 
97eb			;	ld a, 0 
97eb			;	ld hl, os_cli_cmd 
97eb			;	ld de, os_cli_cmd+1 
97eb			;	ld bc, 254 
97eb			;	ldir 
97eb				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97eb			;	call strcpy 
97eb			;	ld a, 0 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			 
97eb				; switch frame buffer to program  
97eb			 
97eb 21 fc ed				ld hl, display_fb1 
97ee 22 58 ed				ld (display_fb_active), hl 
97f1			 
97f1			;	nop 
97f1				STACKFRAME ON $fbfe $8f9f 
97f1				if DEBUG_STACK_IMB 
97f1					if ON 
97f1						exx 
97f1						ld de, $fbfe 
97f1						ld a, d 
97f1						ld hl, curframe 
97f1						call hexout 
97f1						ld a, e 
97f1						ld hl, curframe+2 
97f1						call hexout 
97f1						ld hl, $fbfe 
97f1						push hl 
97f1						ld hl, $8f9f 
97f1						push hl 
97f1						exx 
97f1					endif 
97f1				endif 
97f1			endm 
# End of macro STACKFRAME
97f1				; first time into the parser so pass over the current scratch pad 
97f1 21 78 e7			ld hl,os_cli_cmd 
97f4				; tokenise the entered statement(s) in HL 
97f4 cd 0f 9f			call forthparse 
97f7			        ; exec forth statements in top of return stack 
97f7 cd 4f 9f			call forthexec 
97fa				;call forthexec_cleanup 
97fa			;	call parsenext 
97fa			 
97fa				STACKFRAMECHK ON $fbfe $8f9f 
97fa				if DEBUG_STACK_IMB 
97fa					if ON 
97fa						exx 
97fa						ld hl, $8f9f 
97fa						pop de   ; $8f9f 
97fa						call cmp16 
97fa						jr nz, .spnosame 
97fa						ld hl, $fbfe 
97fa						pop de   ; $fbfe 
97fa						call cmp16 
97fa						jr z, .spfrsame 
97fa						.spnosame: call showsperror 
97fa						.spfrsame: nop 
97fa						exx 
97fa					endif 
97fa				endif 
97fa			endm 
# End of macro STACKFRAMECHK
97fa				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97fa			 
97fa 3e 3c			ld a, display_row_4 
97fc 11 2e 98			ld de, endprog 
97ff			 
97ff cd 98 8a			call update_display		 
9802			 
9802 cd 8c 9a			call next_page_prompt 
9805			 
9805				; switch frame buffer to cli 
9805			 
9805 21 4d ee				ld hl, display_fb0 
9808 22 58 ed				ld (display_fb_active), hl 
980b			 
980b			 
980b cd 75 8a		        call clear_display 
980e cd 98 8a			call update_display		 
9811			 
9811 21 78 e7			ld hl, os_cli_cmd 
9814			 
9814 3e 00			ld a, 0		 ; init cli input 
9816 77				ld (hl), a 
9817			 
9817				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9817			 
9817				; now on last line 
9817			 
9817				; TODO scroll screen up 
9817			 
9817				; TODO instead just clear screen and place at top of screen 
9817			 
9817			;	ld a, 0 
9817			;	ld (f_cursor_ptr),a 
9817			 
9817				;call clear_display 
9817				;call update_display 
9817			 
9817				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9817 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9819 c3 d4 97			jp cli 
981c			 
981c .. 00		freeram: db "Free bytes: $",0 
982a ..			asc: db "1A2F" 
982e .. 00		endprog: db "End prog...",0 
983a			 
983a			testenter2:   
983a 21 83 e4			ld hl,scratch+50 
983d 22 74 e7			ld (os_cur_ptr),hl 
9840 c3 d4 97			jp cli 
9843			 
9843			testenter:  
9843			 
9843 21 2a 98			ld hl,asc 
9846			;	ld a,(hl) 
9846			;	call nibble2val 
9846 cd f9 8f			call get_byte 
9849			 
9849			 
9849			;	ld a,(hl) 
9849			;	call atohex 
9849			 
9849			;	call fourehexhl 
9849 32 83 e4			ld (scratch+50),a 
984c			 
984c			 
984c			 
984c 21 2c 98			ld hl,asc+2 
984f			;	ld a, (hl) 
984f			;	call nibble2val 
984f cd f9 8f			call get_byte 
9852			 
9852			;	call fourehexhl 
9852 32 85 e4			ld (scratch+52),a 
9855				 
9855 21 83 e4			ld hl,scratch+50 
9858 22 74 e7			ld (os_cur_ptr),hl 
985b c3 d4 97			jp cli 
985e			 
985e			enter:	 
985e 3a 55 e4			ld a,(scratch+4) 
9861 fe 00			cp 0 
9863 28 0c			jr z, .entercont 
9865				; no, not a null term line so has an address to work out.... 
9865			 
9865 21 53 e4			ld hl,scratch+2 
9868 cd 59 90			call get_word_hl 
986b			 
986b 22 74 e7			ld (os_cur_ptr),hl	 
986e c3 d4 97			jp cli 
9871			 
9871			 
9871			.entercont:  
9871			 
9871 21 53 e4			ld hl, scratch+2 
9874 cd f9 8f			call get_byte 
9877			 
9877 2a 74 e7		   	ld hl,(os_cur_ptr) 
987a 77					ld (hl),a 
987b 23					inc hl 
987c 22 74 e7				ld (os_cur_ptr),hl 
987f				 
987f			; get byte  
987f			 
987f			 
987f c3 d4 97			jp cli 
9882			 
9882			 
9882			; basic monitor support 
9882			 
9882			monitor: 
9882				;  
9882 cd 75 8a			call clear_display 
9885 3e 00			ld a, 0 
9887 11 cf 98			ld de, .monprompt 
988a cd 88 8a			call str_at_display 
988d cd 98 8a			call update_display 
9890			 
9890				; get a monitor command 
9890			 
9890 0e 00			ld c, 0     ; entry at top left 
9892 16 64			ld d, 100   ; max buffer size 
9894 1e 0f			ld e, 15    ; input scroll area 
9896 3e 00			ld a, 0     ; init string 
9898 21 4f e6			ld hl, os_input 
989b 77				ld (hl), a 
989c 23				inc hl 
989d 77				ld (hl), a 
989e 21 4f e6			ld hl, os_input 
98a1 3e 01			ld a, 1     ; init string 
98a3 cd cf 8c			call input_str 
98a6			 
98a6 cd 75 8a		        call clear_display 
98a9 cd 98 8a			call update_display		 
98ac			 
98ac 3a 4f e6			ld a, (os_input) 
98af cd f7 90			call toUpper 
98b2 fe 48		        cp 'H' 
98b4 28 6f		        jr z, .monhelp 
98b6 fe 44			cp 'D'		; dump 
98b8 ca 46 99			jp z, .mondump	 
98bb fe 43			cp 'C'		; dump 
98bd ca 60 99			jp z, .moncdump	 
98c0 fe 4d			cp 'M'		; dump 
98c2 ca d1 98			jp z, .moneditstart 
98c5 fe 55			cp 'U'		; dump 
98c7 28 14			jr z, .monedit	 
98c9 fe 51			cp 'Q'		; dump 
98cb c8				ret z	 
98cc			 
98cc			 
98cc				; TODO "S" to access symbol by name and not need the address 
98cc				; TODO "F" to find a string in memory 
98cc			 
98cc c3 82 98			jp monitor 
98cf			 
98cf .. 00		.monprompt: db ">", 0 
98d1			 
98d1			.moneditstart: 
98d1				; get starting address 
98d1			 
98d1 21 51 e6			ld hl,os_input+2 
98d4 cd 59 90			call get_word_hl 
98d7			 
98d7 22 74 e7			ld (os_cur_ptr),hl	 
98da			 
98da c3 82 98			jp monitor 
98dd			 
98dd			.monedit: 
98dd				; get byte to load 
98dd			 
98dd 21 51 e6			ld hl,os_input+2 
98e0 cd f9 8f			call get_byte 
98e3			 
98e3				; get address to update 
98e3 2a 74 e7			ld hl, (os_cur_ptr) 
98e6			 
98e6				; update byte 
98e6			 
98e6 77				ld (hl), a 
98e7			 
98e7				; move to next address and save it 
98e7			 
98e7 23				inc hl 
98e8 22 74 e7			ld (os_cur_ptr),hl	 
98eb			 
98eb c3 82 98			jp monitor 
98ee			 
98ee			 
98ee .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9902 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
991e .. 00		.monhelptext3:  db "Q-Quit",0 
9925			        
9925			.monhelp: 
9925 3e 00			ld a, display_row_1 
9927 11 ee 98		        ld de, .monhelptext1 
992a			 
992a cd 88 8a			call str_at_display 
992d 3e 14			ld a, display_row_2 
992f 11 02 99		        ld de, .monhelptext2 
9932					 
9932 cd 88 8a			call str_at_display 
9935 3e 28			ld a, display_row_3 
9937 11 1e 99		        ld de, .monhelptext3 
993a					 
993a cd 88 8a			call str_at_display 
993d cd 98 8a			call update_display		 
9940			 
9940 cd 8c 9a			call next_page_prompt 
9943 c3 82 98			jp monitor 
9946			 
9946			.mondump:    
9946 21 51 e6			ld hl,os_input+2 
9949 cd 59 90			call get_word_hl 
994c			 
994c 22 74 e7			ld (os_cur_ptr),hl	 
994f cd 94 99			call dumpcont 
9952 3e 3c			ld a, display_row_4 
9954 11 2e 98			ld de, endprog 
9957			 
9957 cd 98 8a			call update_display		 
995a			 
995a cd 8c 9a			call next_page_prompt 
995d c3 82 98			jp monitor 
9960			.moncdump: 
9960 cd 94 99			call dumpcont 
9963 3e 3c			ld a, display_row_4 
9965 11 2e 98			ld de, endprog 
9968			 
9968 cd 98 8a			call update_display		 
996b			 
996b cd 8c 9a			call next_page_prompt 
996e c3 82 98			jp monitor 
9971			 
9971			 
9971			; TODO symbol access  
9971			 
9971			.symbols:     ;; A list of symbols that can be called up  
9971 4d ee			dw display_fb0 
9973 .. 00			db "fb0",0  
9977 0a ec		     	dw store_page 
9979 .. 00			db "store_page",0 
9984			 
9984			 
9984			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9984			 
9984 3a 52 e4			ld a,(scratch+1) 
9987 fe 00			cp 0 
9989 28 09			jr z, dumpcont 
998b			 
998b				; no, not a null term line so has an address to work out.... 
998b			 
998b 21 53 e4			ld hl,scratch+2 
998e cd 59 90			call get_word_hl 
9991			 
9991 22 74 e7			ld (os_cur_ptr),hl	 
9994			 
9994			 
9994			 
9994			dumpcont: 
9994			 
9994				; dump bytes at ptr 
9994			 
9994			 
9994 3e 00			ld a, display_row_1 
9996 2a 58 ed			ld hl, (display_fb_active) 
9999 cd a2 8c			call addatohl 
999c cd c4 99			call .dumpbyterow 
999f			 
999f 3e 14			ld a, display_row_2 
99a1 2a 58 ed			ld hl, (display_fb_active) 
99a4 cd a2 8c			call addatohl 
99a7 cd c4 99			call .dumpbyterow 
99aa			 
99aa			 
99aa 3e 28			ld a, display_row_3 
99ac 2a 58 ed			ld hl, (display_fb_active) 
99af cd a2 8c			call addatohl 
99b2 cd c4 99			call .dumpbyterow 
99b5			 
99b5 3e 3c			ld a, display_row_4 
99b7 2a 58 ed			ld hl, (display_fb_active) 
99ba cd a2 8c			call addatohl 
99bd cd c4 99			call .dumpbyterow 
99c0			 
99c0 cd 98 8a			call update_display 
99c3			;		jp cli 
99c3 c9				ret 
99c4			 
99c4			.dumpbyterow: 
99c4			 
99c4				;push af 
99c4			 
99c4 e5				push hl 
99c5			 
99c5				; calc where to poke the ascii 
99c5			if display_cols == 20 
99c5 3e 10			ld a, 16 
99c7			else 
99c7				ld a, 31 
99c7			endif 
99c7			 
99c7 cd a2 8c			call addatohl 
99ca 22 56 e7			ld (os_word_scratch),hl  		; save pos for later 
99cd			 
99cd			 
99cd			; display decoding address 
99cd 2a 74 e7		   	ld hl,(os_cur_ptr) 
99d0			 
99d0 7c				ld a,h 
99d1 e1				pop hl 
99d2 e5				push hl 
99d3			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99d3 cd a3 8f			call hexout 
99d6 2a 74 e7		   	ld hl,(os_cur_ptr) 
99d9			 
99d9 7d				ld a,l 
99da e1				pop hl 
99db 23				inc hl 
99dc 23				inc hl 
99dd e5				push hl 
99de			;	ld hl, os_word_scratch+2 
99de cd a3 8f			call hexout 
99e1 e1				pop hl 
99e2 23				inc hl 
99e3 23				inc hl 
99e4				;ld hl, os_word_scratch+4 
99e4 3e 3a			ld a, ':' 
99e6 77				ld (hl),a 
99e7 23				inc hl 
99e8				;ld a, 0 
99e8				;ld (hl),a 
99e8				;ld de, os_word_scratch 
99e8				;pop af 
99e8				;push af 
99e8			;		ld a, display_row_2 
99e8			;		call str_at_display 
99e8			;		call update_display 
99e8			 
99e8			 
99e8			;pop af 
99e8			;	add 5 
99e8			 
99e8			if display_cols == 20 
99e8 06 04			ld b, 4 
99ea			else 
99ea				ld b, 8 
99ea			endif	 
99ea			 
99ea			.dumpbyte: 
99ea c5				push bc 
99eb e5				push hl 
99ec			 
99ec			 
99ec 2a 74 e7		   	ld hl,(os_cur_ptr) 
99ef 7e					ld a,(hl) 
99f0			 
99f0					; poke the ascii to display 
99f0 2a 56 e7				ld hl,(os_word_scratch) 
99f3 77					ld (hl),a 
99f4 23					inc hl 
99f5 22 56 e7				ld (os_word_scratch),hl 
99f8			 
99f8					 
99f8			 
99f8			 
99f8 e1					pop hl 
99f9 e5					push hl 
99fa			 
99fa cd a3 8f				call hexout 
99fd			 
99fd					 
99fd 2a 74 e7		   	ld hl,(os_cur_ptr) 
9a00 23				inc hl 
9a01 22 74 e7		   	ld (os_cur_ptr),hl 
9a04			 
9a04 e1					pop hl 
9a05 23					inc hl 
9a06 23					inc hl 
9a07 23					inc hl 
9a08			 
9a08			 
9a08			 
9a08					;ld a,0 
9a08					;ld (os_word_scratch+2),a 
9a08					;pop af 
9a08					;push af 
9a08			 
9a08					;ld de, os_word_scratch 
9a08					;call str_at_display 
9a08			;		call update_display 
9a08			;		pop af 
9a08 c1					pop bc 
9a09 c6 03				add 3 
9a0b 10 dd			djnz .dumpbyte 
9a0d			 
9a0d				 
9a0d			 
9a0d c9				ret 
9a0e			 
9a0e			jump:	 
9a0e			 
9a0e 21 53 e4			ld hl,scratch+2 
9a11 cd 59 90			call get_word_hl 
9a14				;ld hl,(scratch+2) 
9a14				;call fourehexhl 
9a14			 
9a14 22 74 e7			ld (os_cur_ptr),hl	 
9a17			 
9a17 e9				jp (hl) 
9a18			 
9a18			 
9a18			 
9a18			; TODO implement a basic monitor mode to start with 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			; testing and demo code during development 
9a18			 
9a18			 
9a18 .. 00		str1: db "Enter some text...",0 
9a2b .. 00		clear: db "                    ",0 
9a40			 
9a40			demo: 
9a40			 
9a40			 
9a40			 
9a40			;	call update_display 
9a40			 
9a40				; init scratch input area for testing 
9a40 21 51 e4			ld hl, scratch	 
9a43 3e 00			ld a,0 
9a45 77				ld (hl),a 
9a46			 
9a46			 
9a46 3e 14		            LD   A, display_row_2 
9a48			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a48 11 18 9a		            LD   DE, str1 
9a4b cd 88 8a			call str_at_display 
9a4e			 
9a4e			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a4e			cloop:	 
9a4e 3e 28		            LD   A, display_row_3 
9a50			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a50 11 2b 9a		            LD   DE, clear 
9a53			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a53 cd 88 8a				call str_at_display 
9a56 3e 3c			ld a, display_row_4 
9a58 11 88 9a			ld de, prompt 
9a5b			 
9a5b cd 88 8a				call str_at_display 
9a5e cd 98 8a			call update_display 
9a61			 
9a61 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a63 16 0a			ld d, 10 
9a65 21 51 e4			ld hl, scratch	 
9a68 cd cf 8c			call input_str 
9a6b			 
9a6b			;	call clear_display 
9a6b			;'	call update_display 
9a6b			 
9a6b 3e 00		            LD   A, display_row_1 
9a6d			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a6d 11 2b 9a		            LD   DE, clear 
9a70 cd 88 8a				call str_at_display 
9a73			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a73 3e 00		            LD   A, display_row_1 
9a75			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a75 11 51 e4		            LD   DE, scratch 
9a78			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a78 cd 88 8a				call str_at_display 
9a7b cd 98 8a			call update_display 
9a7e			 
9a7e 3e 00				ld a,0 
9a80 21 51 e4			ld hl, scratch 
9a83 77				ld (hl),a 
9a84			 
9a84 00				nop 
9a85 c3 4e 9a			jp cloop 
9a88			 
9a88			 
9a88			 
9a88			; OS Prompt 
9a88			 
9a88 .. 00		prompt: db ">",0 
9a8a .. 00		endprg: db "?",0 
9a8c			 
9a8c			 
9a8c			; handy next page prompt 
9a8c			next_page_prompt: 
9a8c e5				push hl 
9a8d d5				push de 
9a8e f5				push af 
9a8f c5				push bc 
9a90			 
9a90 3e 4f			ld a,display_row_4 + display_cols - 1 
9a92 11 8a 9a		        ld de, endprg 
9a95 cd 88 8a			call str_at_display 
9a98 cd 98 8a			call update_display 
9a9b cd be e1			call cin_wait 
9a9e c1				pop bc 
9a9f f1				pop af 
9aa0 d1				pop de 
9aa1 e1				pop hl 
9aa2			 
9aa2			 
9aa2 c9				ret 
9aa3			 
9aa3			 
9aa3			; forth parser 
9aa3			 
9aa3			; My forth kernel 
9aa3			include "forth_kernel.asm" 
9aa3			; 
9aa3			; kernel to the forth OS 
9aa3			 
9aa3			DS_TYPE_STR: equ 1     ; string type 
9aa3			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9aa3			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9aa3			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9aa3			 
9aa3			FORTH_PARSEV1: equ 0 
9aa3			FORTH_PARSEV2: equ 0 
9aa3			FORTH_PARSEV3: equ 0 
9aa3			FORTH_PARSEV4: equ 0 
9aa3			FORTH_PARSEV5: equ 1 
9aa3			 
9aa3			;if FORTH_PARSEV5 
9aa3			;	FORTH_END_BUFFER: equ 0 
9aa3			;else 
9aa3			FORTH_END_BUFFER: equ 127 
9aa3			;endif 
9aa3			 
9aa3			FORTH_TRUE: equ 1 
9aa3			FORTH_FALSE: equ 0 
9aa3			 
9aa3			if FORTH_PARSEV4 
9aa3			include "forth_stackops.asm" 
9aa3			endif 
9aa3			 
9aa3			if FORTH_PARSEV5 
9aa3			include "forth_stackopsv5.asm" 
9aa3			 
9aa3			; Stack operations for v5 parser on wards 
9aa3			; * DATA stack 
9aa3			; * LOOP stack 
9aa3			; * RETURN stack 
9aa3			 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_DSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_data_sp) 
9aa3				ld de, cli_data_stack 
9aa3				call cmp16 
9aa3				jp c, fault_dsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_RSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_ret_sp) 
9aa3				ld de, cli_ret_stack 
9aa3				call cmp16 
9aa3				jp c, fault_rsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_CHK_LOOP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_loop_sp) 
9aa3				ld de, cli_loop_stack 
9aa3				call cmp16 
9aa3				jp c, fault_loop_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTSTR: macro 
9aa3				; TOSO might need more for checks when used 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_STR 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTNUM: macro 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_INUM 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			; increase data stack pointer and save hl to it 
9aa3				 
9aa3			FORTH_DSP_NEXT: macro 
9aa3				call macro_forth_dsp_next 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			macro_forth_dsp_next: 
9aa3				if DEBUG_FORTH_STACK_GUARD 
9aa3 cd 22 df				call check_stacks 
9aa6				endif 
9aa6 e5				push hl 
9aa7 d5				push de 
9aa8 eb				ex de,hl 
9aa9 2a 7e eb			ld hl,(cli_data_sp) 
9aac 23				inc hl 
9aad 23				inc hl 
9aae			 
9aae			; PARSEV5 
9aae 23				inc hl 
9aaf 22 7e eb			ld (cli_data_sp),hl 
9ab2 73				ld (hl), e 
9ab3 23				inc hl 
9ab4 72				ld (hl), d 
9ab5 d1				pop de 
9ab6 e1				pop hl 
9ab7				if DEBUG_FORTH_STACK_GUARD 
9ab7 cd 22 df				call check_stacks 
9aba				endif 
9aba c9				ret 
9abb			 
9abb			 
9abb			; increase ret stack pointer and save hl to it 
9abb				 
9abb			FORTH_RSP_NEXT: macro 
9abb				call macro_forth_rsp_next 
9abb				endm 
9abb			 
9abb			macro_forth_rsp_next: 
9abb				if DEBUG_FORTH_STACK_GUARD 
9abb cd 22 df				call check_stacks 
9abe				endif 
9abe e5				push hl 
9abf d5				push de 
9ac0 eb				ex de,hl 
9ac1 2a 82 eb			ld hl,(cli_ret_sp) 
9ac4 23				inc hl 
9ac5 23				inc hl 
9ac6 22 82 eb			ld (cli_ret_sp),hl 
9ac9 73				ld (hl), e 
9aca 23				inc hl 
9acb 72				ld (hl), d 
9acc d1				pop de 
9acd e1				pop hl 
9ace				if DEBUG_FORTH_STACK_GUARD 
9ace cd 22 df				call check_stacks 
9ad1				endif 
9ad1 c9				ret 
9ad2			 
9ad2			; get current ret stack pointer and save to hl  
9ad2				 
9ad2			FORTH_RSP_TOS: macro 
9ad2				call macro_forth_rsp_tos 
9ad2				endm 
9ad2			 
9ad2			macro_forth_rsp_tos: 
9ad2				;push de 
9ad2 2a 82 eb			ld hl,(cli_ret_sp) 
9ad5 cd 0d 9b			call loadhlptrtohl 
9ad8				;ld e, (hl) 
9ad8				;inc hl 
9ad8				;ld d, (hl) 
9ad8				;ex de, hl 
9ad8					if DEBUG_FORTH_WORDS 
9ad8			;			DMARK "RST" 
9ad8						CALLMONITOR 
9ad8 cd a3 94			call break_point_state  
9adb				endm  
# End of macro CALLMONITOR
9adb					endif 
9adb				;pop de 
9adb c9				ret 
9adc			 
9adc			; pop ret stack pointer 
9adc				 
9adc			FORTH_RSP_POP: macro 
9adc				call macro_forth_rsp_pop 
9adc				endm 
9adc			 
9adc			 
9adc			macro_forth_rsp_pop: 
9adc				if DEBUG_FORTH_STACK_GUARD 
9adc			;		DMARK "RPP" 
9adc cd 22 df				call check_stacks 
9adf					FORTH_CHK_RSP_UNDER 
9adf e5				push hl 
9ae0 d5				push de 
9ae1 2a 82 eb			ld hl,(cli_ret_sp) 
9ae4 11 3c eb			ld de, cli_ret_stack 
9ae7 cd c0 8c			call cmp16 
9aea da 36 e0			jp c, fault_rsp_under 
9aed d1				pop de 
9aee e1				pop hl 
9aef				endm 
# End of macro FORTH_CHK_RSP_UNDER
9aef				endif 
9aef e5				push hl 
9af0 2a 82 eb			ld hl,(cli_ret_sp) 
9af3			 
9af3			 
9af3				if FORTH_ENABLE_FREE 
9af3			 
9af3					; get pointer 
9af3			 
9af3					push de 
9af3					push hl 
9af3			 
9af3					ld e, (hl) 
9af3					inc hl 
9af3					ld d, (hl) 
9af3			 
9af3					ex de, hl 
9af3					call free 
9af3			 
9af3					pop hl 
9af3					pop de 
9af3			 
9af3			 
9af3				endif 
9af3			 
9af3			 
9af3 2b				dec hl 
9af4 2b				dec hl 
9af5 22 82 eb			ld (cli_ret_sp), hl 
9af8				; do stack underflow checks 
9af8 e1				pop hl 
9af9				if DEBUG_FORTH_STACK_GUARD 
9af9 cd 22 df				call check_stacks 
9afc					FORTH_CHK_RSP_UNDER 
9afc e5				push hl 
9afd d5				push de 
9afe 2a 82 eb			ld hl,(cli_ret_sp) 
9b01 11 3c eb			ld de, cli_ret_stack 
9b04 cd c0 8c			call cmp16 
9b07 da 36 e0			jp c, fault_rsp_under 
9b0a d1				pop de 
9b0b e1				pop hl 
9b0c				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b0c				endif 
9b0c c9				ret 
9b0d			 
9b0d			 
9b0d			 
9b0d			; routine to load word pointed to by hl into hl 
9b0d			 
9b0d			loadhlptrtohl: 
9b0d			 
9b0d d5				push de 
9b0e 5e				ld e, (hl) 
9b0f 23				inc hl 
9b10 56				ld d, (hl) 
9b11 eb				ex de, hl 
9b12 d1				pop de 
9b13			 
9b13 c9				ret 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			; push a number held in HL onto the data stack 
9b14			; entry point for pushing a value when already in hl used in function above 
9b14			 
9b14			forth_push_numhl: 
9b14			 
9b14 e5				push hl    ; save value to push 
9b15			 
9b15			if DEBUG_FORTH_PUSH 
9b15				; see if disabled 
9b15			 
9b15			 
9b15 f5				push af 
9b16 3a 42 e4			ld a, (os_view_disable) 
9b19 fe 2a			cp '*' 
9b1b 28 34			jr z, .pskip2 
9b1d e5				push hl 
9b1e e5			push hl 
9b1f cd 75 8a			call clear_display 
9b22 e1			pop hl 
9b23 7c				ld a,h 
9b24 21 56 e7			ld hl, os_word_scratch 
9b27 cd a3 8f			call hexout 
9b2a e1				pop hl 
9b2b 7d				ld a,l 
9b2c 21 58 e7			ld hl, os_word_scratch+2 
9b2f cd a3 8f			call hexout 
9b32			 
9b32 21 5a e7			ld hl, os_word_scratch+4 
9b35 3e 00			ld a,0 
9b37 77				ld (hl),a 
9b38 11 56 e7			ld de,os_word_scratch 
9b3b 3e 14				ld a, display_row_2 
9b3d cd 88 8a				call str_at_display 
9b40 11 be ca			ld de, .push_num 
9b43 3e 00			ld a, display_row_1 
9b45			 
9b45 cd 88 8a				call str_at_display 
9b48			 
9b48			 
9b48 cd 98 8a			call update_display 
9b4b cd f2 89			call delay1s 
9b4e cd f2 89			call delay1s 
9b51			.pskip2:  
9b51			 
9b51 f1				pop af 
9b52			endif	 
9b52			 
9b52			 
9b52				FORTH_DSP_NEXT 
9b52 cd a3 9a			call macro_forth_dsp_next 
9b55				endm 
# End of macro FORTH_DSP_NEXT
9b55			 
9b55 2a 7e eb			ld hl, (cli_data_sp) 
9b58			 
9b58				; save item type 
9b58 3e 02			ld a,  DS_TYPE_INUM 
9b5a 77				ld (hl), a 
9b5b 23				inc hl 
9b5c			 
9b5c				; get word off stack 
9b5c d1				pop de 
9b5d 7b				ld a,e 
9b5e 77				ld (hl), a 
9b5f 23				inc hl 
9b60 7a				ld a,d 
9b61 77				ld (hl), a 
9b62			 
9b62			if DEBUG_FORTH_PUSH 
9b62 2b				dec hl 
9b63 2b				dec hl 
9b64 2b				dec hl 
9b65						DMARK "PH5" 
9b65 f5				push af  
9b66 3a 7a 9b			ld a, (.dmark)  
9b69 32 b7 ee			ld (debug_mark),a  
9b6c 3a 7b 9b			ld a, (.dmark+1)  
9b6f 32 b8 ee			ld (debug_mark+1),a  
9b72 3a 7c 9b			ld a, (.dmark+2)  
9b75 32 b9 ee			ld (debug_mark+2),a  
9b78 18 03			jr .pastdmark  
9b7a ..			.dmark: db "PH5"  
9b7d f1			.pastdmark: pop af  
9b7e			endm  
# End of macro DMARK
9b7e				CALLMONITOR 
9b7e cd a3 94			call break_point_state  
9b81				endm  
# End of macro CALLMONITOR
9b81			endif	 
9b81			 
9b81 c9				ret 
9b82			 
9b82			 
9b82			; Push a string to stack pointed to by hl 
9b82			 
9b82			forth_push_str: 
9b82			 
9b82			if DEBUG_FORTH_PUSH 
9b82						DMARK "PSQ" 
9b82 f5				push af  
9b83 3a 97 9b			ld a, (.dmark)  
9b86 32 b7 ee			ld (debug_mark),a  
9b89 3a 98 9b			ld a, (.dmark+1)  
9b8c 32 b8 ee			ld (debug_mark+1),a  
9b8f 3a 99 9b			ld a, (.dmark+2)  
9b92 32 b9 ee			ld (debug_mark+2),a  
9b95 18 03			jr .pastdmark  
9b97 ..			.dmark: db "PSQ"  
9b9a f1			.pastdmark: pop af  
9b9b			endm  
# End of macro DMARK
9b9b				CALLMONITOR 
9b9b cd a3 94			call break_point_state  
9b9e				endm  
# End of macro CALLMONITOR
9b9e			endif	 
9b9e			    
9b9e e5				push hl 
9b9f e5				push hl 
9ba0			 
9ba0			;	ld a, 0   ; find end of string 
9ba0 cd 00 91			call strlenz 
9ba3			if DEBUG_FORTH_PUSH 
9ba3						DMARK "PQ2" 
9ba3 f5				push af  
9ba4 3a b8 9b			ld a, (.dmark)  
9ba7 32 b7 ee			ld (debug_mark),a  
9baa 3a b9 9b			ld a, (.dmark+1)  
9bad 32 b8 ee			ld (debug_mark+1),a  
9bb0 3a ba 9b			ld a, (.dmark+2)  
9bb3 32 b9 ee			ld (debug_mark+2),a  
9bb6 18 03			jr .pastdmark  
9bb8 ..			.dmark: db "PQ2"  
9bbb f1			.pastdmark: pop af  
9bbc			endm  
# End of macro DMARK
9bbc				CALLMONITOR 
9bbc cd a3 94			call break_point_state  
9bbf				endm  
# End of macro CALLMONITOR
9bbf			endif	 
9bbf eb				ex de, hl 
9bc0 e1				pop hl   ; get ptr to start of string 
9bc1			if DEBUG_FORTH_PUSH 
9bc1						DMARK "PQ3" 
9bc1 f5				push af  
9bc2 3a d6 9b			ld a, (.dmark)  
9bc5 32 b7 ee			ld (debug_mark),a  
9bc8 3a d7 9b			ld a, (.dmark+1)  
9bcb 32 b8 ee			ld (debug_mark+1),a  
9bce 3a d8 9b			ld a, (.dmark+2)  
9bd1 32 b9 ee			ld (debug_mark+2),a  
9bd4 18 03			jr .pastdmark  
9bd6 ..			.dmark: db "PQ3"  
9bd9 f1			.pastdmark: pop af  
9bda			endm  
# End of macro DMARK
9bda				CALLMONITOR 
9bda cd a3 94			call break_point_state  
9bdd				endm  
# End of macro CALLMONITOR
9bdd			endif	 
9bdd 19				add hl,de 
9bde			if DEBUG_FORTH_PUSH 
9bde						DMARK "PQE" 
9bde f5				push af  
9bdf 3a f3 9b			ld a, (.dmark)  
9be2 32 b7 ee			ld (debug_mark),a  
9be5 3a f4 9b			ld a, (.dmark+1)  
9be8 32 b8 ee			ld (debug_mark+1),a  
9beb 3a f5 9b			ld a, (.dmark+2)  
9bee 32 b9 ee			ld (debug_mark+2),a  
9bf1 18 03			jr .pastdmark  
9bf3 ..			.dmark: db "PQE"  
9bf6 f1			.pastdmark: pop af  
9bf7			endm  
# End of macro DMARK
9bf7				CALLMONITOR 
9bf7 cd a3 94			call break_point_state  
9bfa				endm  
# End of macro CALLMONITOR
9bfa			endif	 
9bfa			 
9bfa 2b				dec hl    ; see if there is an optional trailing double quote 
9bfb 7e				ld a,(hl) 
9bfc fe 22			cp '"' 
9bfe 20 03			jr nz, .strnoq 
9c00 3e 00			ld a, 0      ; get rid of double quote 
9c02 77				ld (hl), a 
9c03 23			.strnoq: inc hl 
9c04			 
9c04 3e 00			ld a, 0 
9c06 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c07			 
9c07 13				inc de ; add one for the type string 
9c08 13				inc de ; add one for null term??? 
9c09			 
9c09				; tos is get string pointer again 
9c09				; de contains space to allocate 
9c09				 
9c09 d5				push de 
9c0a			 
9c0a eb				ex de, hl 
9c0b			 
9c0b				;push af 
9c0b			 
9c0b			if DEBUG_FORTH_PUSH 
9c0b						DMARK "PHm" 
9c0b f5				push af  
9c0c 3a 20 9c			ld a, (.dmark)  
9c0f 32 b7 ee			ld (debug_mark),a  
9c12 3a 21 9c			ld a, (.dmark+1)  
9c15 32 b8 ee			ld (debug_mark+1),a  
9c18 3a 22 9c			ld a, (.dmark+2)  
9c1b 32 b9 ee			ld (debug_mark+2),a  
9c1e 18 03			jr .pastdmark  
9c20 ..			.dmark: db "PHm"  
9c23 f1			.pastdmark: pop af  
9c24			endm  
# End of macro DMARK
9c24				CALLMONITOR 
9c24 cd a3 94			call break_point_state  
9c27				endm  
# End of macro CALLMONITOR
9c27			endif	 
9c27 cd 69 91			call malloc	; on ret hl now contains allocated memory 
9c2a				if DEBUG_FORTH_MALLOC_GUARD 
9c2a cc 16 cb				call z,malloc_error 
9c2d				endif 
9c2d			 
9c2d				 
9c2d c1				pop bc    ; get length 
9c2e d1				pop de   ;  get string start    
9c2f			 
9c2f				; hl has destination from malloc 
9c2f			 
9c2f eb				ex de, hl    ; prep for ldir 
9c30			 
9c30 d5				push de   ; save malloc area for DSP later 
9c31				;push hl   ; save malloc area for DSP later 
9c31			 
9c31			if DEBUG_FORTH_PUSH 
9c31						DMARK "PHc" 
9c31 f5				push af  
9c32 3a 46 9c			ld a, (.dmark)  
9c35 32 b7 ee			ld (debug_mark),a  
9c38 3a 47 9c			ld a, (.dmark+1)  
9c3b 32 b8 ee			ld (debug_mark+1),a  
9c3e 3a 48 9c			ld a, (.dmark+2)  
9c41 32 b9 ee			ld (debug_mark+2),a  
9c44 18 03			jr .pastdmark  
9c46 ..			.dmark: db "PHc"  
9c49 f1			.pastdmark: pop af  
9c4a			endm  
# End of macro DMARK
9c4a				CALLMONITOR 
9c4a cd a3 94			call break_point_state  
9c4d				endm  
# End of macro CALLMONITOR
9c4d			endif	 
9c4d			 
9c4d			 
9c4d ed b0			ldir 
9c4f			 
9c4f			 
9c4f				; push malloc to data stack     macro?????  
9c4f			 
9c4f				FORTH_DSP_NEXT 
9c4f cd a3 9a			call macro_forth_dsp_next 
9c52				endm 
# End of macro FORTH_DSP_NEXT
9c52			 
9c52				; save value and type 
9c52			 
9c52 2a 7e eb			ld hl, (cli_data_sp) 
9c55			 
9c55				; save item type 
9c55 3e 01			ld a,  DS_TYPE_STR 
9c57 77				ld (hl), a 
9c58 23				inc hl 
9c59			 
9c59				; get malloc word off stack 
9c59 d1				pop de 
9c5a 73				ld (hl), e 
9c5b 23				inc hl 
9c5c 72				ld (hl), d 
9c5d			 
9c5d			 
9c5d			 
9c5d			if DEBUG_FORTH_PUSH 
9c5d 2a 7e eb			ld hl, (cli_data_sp) 
9c60						DMARK "PHS" 
9c60 f5				push af  
9c61 3a 75 9c			ld a, (.dmark)  
9c64 32 b7 ee			ld (debug_mark),a  
9c67 3a 76 9c			ld a, (.dmark+1)  
9c6a 32 b8 ee			ld (debug_mark+1),a  
9c6d 3a 77 9c			ld a, (.dmark+2)  
9c70 32 b9 ee			ld (debug_mark+2),a  
9c73 18 03			jr .pastdmark  
9c75 ..			.dmark: db "PHS"  
9c78 f1			.pastdmark: pop af  
9c79			endm  
# End of macro DMARK
9c79				CALLMONITOR 
9c79 cd a3 94			call break_point_state  
9c7c				endm  
# End of macro CALLMONITOR
9c7c			;	ex de,hl 
9c7c			endif	 
9c7c				; in case of spaces, skip the ptr past the copied string 
9c7c				;pop af 
9c7c				;ld (cli_origptr),hl 
9c7c			 
9c7c c9				ret 
9c7d			 
9c7d			 
9c7d			 
9c7d			; TODO ascii push input onto stack given hl to start of input 
9c7d			 
9c7d			; identify type 
9c7d			; if starts with a " then a string 
9c7d			; otherwise it is a number 
9c7d			;  
9c7d			; if a string 
9c7d			;     scan for ending " to get length of string to malloc for + 1 
9c7d			;     malloc 
9c7d			;     put pointer to string on stack first byte flags as string 
9c7d			; 
9c7d			; else a number 
9c7d			;    look for number format identifier 
9c7d			;    $xx hex 
9c7d			;    %xxxxx bin 
9c7d			;    xxxxx decimal 
9c7d			;    convert number to 16bit word.  
9c7d			;    malloc word + 1 with flag to identiy as num 
9c7d			;    put pointer to number on stack 
9c7d			;   
9c7d			;  
9c7d			  
9c7d			forth_apush: 
9c7d				; kernel push 
9c7d			 
9c7d			if DEBUG_FORTH_PUSH 
9c7d						DMARK "PSH" 
9c7d f5				push af  
9c7e 3a 92 9c			ld a, (.dmark)  
9c81 32 b7 ee			ld (debug_mark),a  
9c84 3a 93 9c			ld a, (.dmark+1)  
9c87 32 b8 ee			ld (debug_mark+1),a  
9c8a 3a 94 9c			ld a, (.dmark+2)  
9c8d 32 b9 ee			ld (debug_mark+2),a  
9c90 18 03			jr .pastdmark  
9c92 ..			.dmark: db "PSH"  
9c95 f1			.pastdmark: pop af  
9c96			endm  
# End of macro DMARK
9c96				CALLMONITOR 
9c96 cd a3 94			call break_point_state  
9c99				endm  
# End of macro CALLMONITOR
9c99			endif	 
9c99				; identify input type 
9c99			 
9c99 7e				ld a,(hl) 
9c9a fe 22			cp '"' 
9c9c 28 0a			jr z, .fapstr 
9c9e fe 24			cp '$' 
9ca0 ca c8 9c			jp z, .faphex 
9ca3 fe 25			cp '%' 
9ca5 ca b0 9c			jp z, .fapbin 
9ca8			;	cp 'b' 
9ca8			;	jp z, .fabin 
9ca8				; else decimal 
9ca8			 
9ca8				; TODO do decimal conversion 
9ca8				; decimal is stored as a 16bit word 
9ca8			 
9ca8				; by default everything is a string if type is not detected 
9ca8			.fapstr: ; 
9ca8 fe 22			cp '"' 
9caa 20 01			jr nz, .strnoqu 
9cac 23				inc hl 
9cad			.strnoqu: 
9cad c3 82 9b			jp forth_push_str 
9cb0			 
9cb0			 
9cb0			 
9cb0			.fapbin:    ; push a binary string.  
9cb0 11 00 00			ld de, 0   ; hold a 16bit value 
9cb3			 
9cb3 23			.fapbinshift:	inc hl  
9cb4 7e				ld a,(hl) 
9cb5 fe 00			cp 0     ; done scanning  
9cb7 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cb9			 
9cb9				; left shift de 
9cb9 eb				ex de, hl	 
9cba 29				add hl, hl 
9cbb			 
9cbb				; is 1 
9cbb fe 31			cp '1' 
9cbd 20 02			jr nz, .binzero 
9cbf cb 4d			bit 1, l 
9cc1			.binzero: 
9cc1 eb				ex de, hl	 ; save current de 
9cc2 18 ef			jr .fapbinshift 
9cc4			 
9cc4			.fapbdone: 
9cc4 eb				ex de, hl 
9cc5 c3 14 9b			jp forth_push_numhl 
9cc8			 
9cc8			 
9cc8			.faphex:   ; hex is always stored as a 16bit word 
9cc8				; skip number prefix 
9cc8 23				inc hl 
9cc9				; turn ascii into number 
9cc9 cd 59 90			call get_word_hl	; ret 16bit word in hl 
9ccc			 
9ccc c3 14 9b			jp forth_push_numhl 
9ccf			 
9ccf 00				 nop 
9cd0			 
9cd0			.fabin:   ; TODO bin conversion 
9cd0			 
9cd0			 
9cd0 c9				ret 
9cd1			 
9cd1			 
9cd1			; get either a string ptr or a 16bit word from the data stack 
9cd1			 
9cd1			FORTH_DSP: macro 
9cd1				call macro_forth_dsp 
9cd1				endm 
9cd1			 
9cd1			macro_forth_dsp: 
9cd1				; data stack pointer points to current word on tos 
9cd1			 
9cd1 2a 7e eb			ld hl,(cli_data_sp) 
9cd4			 
9cd4				if DEBUG_FORTH_PUSH 
9cd4						DMARK "DSP" 
9cd4 f5				push af  
9cd5 3a e9 9c			ld a, (.dmark)  
9cd8 32 b7 ee			ld (debug_mark),a  
9cdb 3a ea 9c			ld a, (.dmark+1)  
9cde 32 b8 ee			ld (debug_mark+1),a  
9ce1 3a eb 9c			ld a, (.dmark+2)  
9ce4 32 b9 ee			ld (debug_mark+2),a  
9ce7 18 03			jr .pastdmark  
9ce9 ..			.dmark: db "DSP"  
9cec f1			.pastdmark: pop af  
9ced			endm  
# End of macro DMARK
9ced			 
9ced cd 4b cb				call display_data_sp 
9cf0				;call break_point_state 
9cf0				;rst 030h 
9cf0				CALLMONITOR 
9cf0 cd a3 94			call break_point_state  
9cf3				endm  
# End of macro CALLMONITOR
9cf3				endif 
9cf3			 
9cf3 c9				ret 
9cf4			 
9cf4			; return hl to start of value on stack 
9cf4			 
9cf4			FORTH_DSP_VALUE: macro 
9cf4				call macro_forth_dsp_value 
9cf4				endm 
9cf4			 
9cf4			macro_forth_dsp_value: 
9cf4			 
9cf4				FORTH_DSP 
9cf4 cd d1 9c			call macro_forth_dsp 
9cf7				endm 
# End of macro FORTH_DSP
9cf7			 
9cf7 d5				push de 
9cf8			 
9cf8 23				inc hl ; skip type 
9cf9			 
9cf9 5e				ld e, (hl) 
9cfa 23				inc hl 
9cfb 56				ld d, (hl) 
9cfc eb				ex de,hl  
9cfd			 
9cfd d1				pop de 
9cfe			 
9cfe c9				ret 
9cff			 
9cff			; return hl to start of value to second item on stack 
9cff			 
9cff			FORTH_DSP_VALUEM1: macro 
9cff				call macro_forth_dsp_value_m1 
9cff				endm 
9cff			 
9cff			macro_forth_dsp_value_m1: 
9cff			 
9cff				FORTH_DSP 
9cff cd d1 9c			call macro_forth_dsp 
9d02				endm 
# End of macro FORTH_DSP
9d02			 
9d02 2b				dec hl 
9d03 2b				dec hl 
9d04			;	dec hl 
9d04			 
9d04 d5				push de 
9d05			 
9d05 5e				ld e, (hl) 
9d06 23				inc hl 
9d07 56				ld d, (hl) 
9d08 eb				ex de,hl  
9d09			 
9d09 d1				pop de 
9d0a			 
9d0a c9				ret 
9d0b			 
9d0b				 
9d0b			 
9d0b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d0b			 
9d0b			FORTH_DSP_POP: macro 
9d0b				call macro_forth_dsp_pop 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			; get the tos data type 
9d0b			 
9d0b			FORTH_DSP_TYPE:   macro 
9d0b			 
9d0b				;FORTH_DSP_VALUE 
9d0b				FORTH_DSP 
9d0b				 
9d0b				; hl points to value 
9d0b				; check type 
9d0b			 
9d0b				ld a,(hl) 
9d0b			 
9d0b				endm 
9d0b			 
9d0b			; load the tos value into hl 
9d0b			 
9d0b			 
9d0b			FORTH_DSP_VALUEHL:  macro 
9d0b				call macro_dsp_valuehl 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			 
9d0b			macro_dsp_valuehl: 
9d0b				FORTH_DSP_VALUE 
9d0b cd f4 9c			call macro_forth_dsp_value 
9d0e				endm 
# End of macro FORTH_DSP_VALUE
9d0e			 
9d0e				;FORTH_ERR_TOS_NOTNUM 
9d0e			 
9d0e				;inc hl   ; skip type id 
9d0e			 
9d0e			;	push de 
9d0e			; 
9d0e			;	ld e, (hl) 
9d0e			;	inc hl 
9d0e			;	ld d, (hl) 
9d0e			;	ex de,hl  
9d0e			 
9d0e			;	pop de 
9d0e			 
9d0e				if DEBUG_FORTH_PUSH 
9d0e						DMARK "DVL" 
9d0e f5				push af  
9d0f 3a 23 9d			ld a, (.dmark)  
9d12 32 b7 ee			ld (debug_mark),a  
9d15 3a 24 9d			ld a, (.dmark+1)  
9d18 32 b8 ee			ld (debug_mark+1),a  
9d1b 3a 25 9d			ld a, (.dmark+2)  
9d1e 32 b9 ee			ld (debug_mark+2),a  
9d21 18 03			jr .pastdmark  
9d23 ..			.dmark: db "DVL"  
9d26 f1			.pastdmark: pop af  
9d27			endm  
# End of macro DMARK
9d27				CALLMONITOR 
9d27 cd a3 94			call break_point_state  
9d2a				endm  
# End of macro CALLMONITOR
9d2a				endif 
9d2a c9				ret 
9d2b			 
9d2b			forth_apushstrhl:      
9d2b				; push of string requires use of cli_origptr 
9d2b				; bodge use 
9d2b			 
9d2b				; get current cli_origptr, save, update with temp pointer  
9d2b ed 5b ce eb		ld de, (cli_origptr) 
9d2f 22 ce eb			ld (cli_origptr), hl 
9d32 d5				push de 
9d33 cd 7d 9c			call forth_apush 
9d36 d1				pop de 
9d37 ed 53 ce eb		ld (cli_origptr), de 
9d3b c9			        ret	 
9d3c			 
9d3c			 
9d3c			; increase loop stack pointer and save hl to it 
9d3c				 
9d3c			FORTH_LOOP_NEXT: macro 
9d3c				call macro_forth_loop_next 
9d3c				;nop 
9d3c				endm 
9d3c			 
9d3c			macro_forth_loop_next: 
9d3c				if DEBUG_FORTH_STACK_GUARD 
9d3c cd 22 df				call check_stacks 
9d3f				endif 
9d3f e5				push hl 
9d40 d5				push de 
9d41 eb				ex de,hl 
9d42 2a 80 eb			ld hl,(cli_loop_sp) 
9d45 23				inc hl 
9d46 23				inc hl 
9d47					if DEBUG_FORTH_WORDS 
9d47						DMARK "LNX" 
9d47 f5				push af  
9d48 3a 5c 9d			ld a, (.dmark)  
9d4b 32 b7 ee			ld (debug_mark),a  
9d4e 3a 5d 9d			ld a, (.dmark+1)  
9d51 32 b8 ee			ld (debug_mark+1),a  
9d54 3a 5e 9d			ld a, (.dmark+2)  
9d57 32 b9 ee			ld (debug_mark+2),a  
9d5a 18 03			jr .pastdmark  
9d5c ..			.dmark: db "LNX"  
9d5f f1			.pastdmark: pop af  
9d60			endm  
# End of macro DMARK
9d60						CALLMONITOR 
9d60 cd a3 94			call break_point_state  
9d63				endm  
# End of macro CALLMONITOR
9d63					endif 
9d63 22 80 eb			ld (cli_loop_sp),hl 
9d66 73				ld (hl), e 
9d67 23				inc hl 
9d68 72				ld (hl), d 
9d69 d1				pop de    ; been reversed so save a swap on restore 
9d6a e1				pop hl 
9d6b				if DEBUG_FORTH_STACK_GUARD 
9d6b cd 22 df				call check_stacks 
9d6e				endif 
9d6e c9				ret 
9d6f			 
9d6f			; get current ret stack pointer and save to hl  
9d6f				 
9d6f			FORTH_LOOP_TOS: macro 
9d6f				call macro_forth_loop_tos 
9d6f				endm 
9d6f			 
9d6f			macro_forth_loop_tos: 
9d6f d5				push de 
9d70 2a 80 eb			ld hl,(cli_loop_sp) 
9d73 5e				ld e, (hl) 
9d74 23				inc hl 
9d75 56				ld d, (hl) 
9d76 eb				ex de, hl 
9d77 d1				pop de 
9d78 c9				ret 
9d79			 
9d79			; pop loop stack pointer 
9d79				 
9d79			FORTH_LOOP_POP: macro 
9d79				call macro_forth_loop_pop 
9d79				endm 
9d79			 
9d79			 
9d79			macro_forth_loop_pop: 
9d79				if DEBUG_FORTH_STACK_GUARD 
9d79					DMARK "LPP" 
9d79 f5				push af  
9d7a 3a 8e 9d			ld a, (.dmark)  
9d7d 32 b7 ee			ld (debug_mark),a  
9d80 3a 8f 9d			ld a, (.dmark+1)  
9d83 32 b8 ee			ld (debug_mark+1),a  
9d86 3a 90 9d			ld a, (.dmark+2)  
9d89 32 b9 ee			ld (debug_mark+2),a  
9d8c 18 03			jr .pastdmark  
9d8e ..			.dmark: db "LPP"  
9d91 f1			.pastdmark: pop af  
9d92			endm  
# End of macro DMARK
9d92 cd 22 df				call check_stacks 
9d95					FORTH_CHK_LOOP_UNDER 
9d95 e5				push hl 
9d96 d5				push de 
9d97 2a 80 eb			ld hl,(cli_loop_sp) 
9d9a 11 ba ea			ld de, cli_loop_stack 
9d9d cd c0 8c			call cmp16 
9da0 da 3c e0			jp c, fault_loop_under 
9da3 d1				pop de 
9da4 e1				pop hl 
9da5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9da5				endif 
9da5 e5				push hl 
9da6 2a 80 eb			ld hl,(cli_loop_sp) 
9da9 2b				dec hl 
9daa 2b				dec hl 
9dab 22 80 eb			ld (cli_loop_sp), hl 
9dae				; TODO do stack underflow checks 
9dae e1				pop hl 
9daf				if DEBUG_FORTH_STACK_GUARD 
9daf cd 22 df				call check_stacks 
9db2					FORTH_CHK_LOOP_UNDER 
9db2 e5				push hl 
9db3 d5				push de 
9db4 2a 80 eb			ld hl,(cli_loop_sp) 
9db7 11 ba ea			ld de, cli_loop_stack 
9dba cd c0 8c			call cmp16 
9dbd da 3c e0			jp c, fault_loop_under 
9dc0 d1				pop de 
9dc1 e1				pop hl 
9dc2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dc2				endif 
9dc2 c9				ret 
9dc3			 
9dc3			macro_forth_dsp_pop: 
9dc3			 
9dc3 e5				push hl 
9dc4			 
9dc4				; release malloc data 
9dc4			 
9dc4				if DEBUG_FORTH_STACK_GUARD 
9dc4 cd 22 df				call check_stacks 
9dc7					FORTH_CHK_DSP_UNDER 
9dc7 e5				push hl 
9dc8 d5				push de 
9dc9 2a 7e eb			ld hl,(cli_data_sp) 
9dcc 11 b8 e9			ld de, cli_data_stack 
9dcf cd c0 8c			call cmp16 
9dd2 da 30 e0			jp c, fault_dsp_under 
9dd5 d1				pop de 
9dd6 e1				pop hl 
9dd7				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dd7				endif 
9dd7				;ld hl,(cli_data_sp) 
9dd7			if DEBUG_FORTH_DOT 
9dd7				DMARK "DPP" 
9dd7 f5				push af  
9dd8 3a ec 9d			ld a, (.dmark)  
9ddb 32 b7 ee			ld (debug_mark),a  
9dde 3a ed 9d			ld a, (.dmark+1)  
9de1 32 b8 ee			ld (debug_mark+1),a  
9de4 3a ee 9d			ld a, (.dmark+2)  
9de7 32 b9 ee			ld (debug_mark+2),a  
9dea 18 03			jr .pastdmark  
9dec ..			.dmark: db "DPP"  
9def f1			.pastdmark: pop af  
9df0			endm  
# End of macro DMARK
9df0				CALLMONITOR 
9df0 cd a3 94			call break_point_state  
9df3				endm  
# End of macro CALLMONITOR
9df3			endif	 
9df3			 
9df3			 
9df3			if FORTH_ENABLE_DSPPOPFREE 
9df3			 
9df3				FORTH_DSP 
9df3 cd d1 9c			call macro_forth_dsp 
9df6				endm 
# End of macro FORTH_DSP
9df6			 
9df6 7e				ld a, (hl) 
9df7 fe 01			cp DS_TYPE_STR 
9df9 20 23			jr nz, .skippopfree 
9dfb			 
9dfb				FORTH_DSP_VALUEHL 
9dfb cd 0b 9d			call macro_dsp_valuehl 
9dfe				endm 
# End of macro FORTH_DSP_VALUEHL
9dfe 00				nop 
9dff			if DEBUG_FORTH_DOT 
9dff				DMARK "DPf" 
9dff f5				push af  
9e00 3a 14 9e			ld a, (.dmark)  
9e03 32 b7 ee			ld (debug_mark),a  
9e06 3a 15 9e			ld a, (.dmark+1)  
9e09 32 b8 ee			ld (debug_mark+1),a  
9e0c 3a 16 9e			ld a, (.dmark+2)  
9e0f 32 b9 ee			ld (debug_mark+2),a  
9e12 18 03			jr .pastdmark  
9e14 ..			.dmark: db "DPf"  
9e17 f1			.pastdmark: pop af  
9e18			endm  
# End of macro DMARK
9e18				CALLMONITOR 
9e18 cd a3 94			call break_point_state  
9e1b				endm  
# End of macro CALLMONITOR
9e1b			endif	 
9e1b cd 33 92			call free 
9e1e			.skippopfree: 
9e1e				 
9e1e			 
9e1e			endif 
9e1e			 
9e1e			if DEBUG_FORTH_DOT_KEY 
9e1e				DMARK "DP2" 
9e1e				CALLMONITOR 
9e1e			endif	 
9e1e			 
9e1e				; move pointer down 
9e1e			 
9e1e 2a 7e eb			ld hl,(cli_data_sp) 
9e21 2b				dec hl 
9e22 2b				dec hl 
9e23			; PARSEV5 
9e23 2b				dec hl 
9e24 22 7e eb			ld (cli_data_sp), hl 
9e27			 
9e27				if DEBUG_FORTH_STACK_GUARD 
9e27 cd 22 df				call check_stacks 
9e2a					FORTH_CHK_DSP_UNDER 
9e2a e5				push hl 
9e2b d5				push de 
9e2c 2a 7e eb			ld hl,(cli_data_sp) 
9e2f 11 b8 e9			ld de, cli_data_stack 
9e32 cd c0 8c			call cmp16 
9e35 da 30 e0			jp c, fault_dsp_under 
9e38 d1				pop de 
9e39 e1				pop hl 
9e3a				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e3a				endif 
9e3a			 
9e3a e1				pop hl 
9e3b			 
9e3b c9				ret 
9e3c			 
9e3c			getwordathl: 
9e3c				; hl points to an address 
9e3c				; load hl with the word at that address 
9e3c			 
9e3c d5				push de 
9e3d			 
9e3d 5e				ld e, (hl) 
9e3e 23				inc hl 
9e3f 56				ld d, (hl) 
9e40 eb				ex de, hl 
9e41			 
9e41 d1				pop de 
9e42 c9				ret 
9e43			 
9e43			 
9e43			 
9e43			 
9e43			 
9e43			; eof 
9e43			 
# End of file forth_stackopsv5.asm
9e43			endif 
9e43			 
9e43			loadwordinhl:	 
9e43			 
9e43 d5				push de 
9e44			 
9e44 5e				ld e, (hl) 
9e45 23				inc hl 
9e46 56				ld d, (hl) 
9e47 eb				ex de,hl  
9e48			 
9e48 d1				pop de 
9e49			 
9e49 c9				ret 
9e4a			 
9e4a			user_word_eol:  
9e4a				; hl contains the pointer to where to create a linked list item from the end 
9e4a				; of the user dict to continue on at the system word dict 
9e4a				 
9e4a				; poke the stub of the word list linked list to repoint to rom words 
9e4a			 
9e4a				; stub format 
9e4a				; db   word id 
9e4a				; dw    link to next word 
9e4a			        ; db char length of token 
9e4a				; db string + 0 term 
9e4a				; db exec code....  
9e4a			 
9e4a 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e4c 77				ld (hl), a		; word id 
9e4d 23				inc hl 
9e4e			 
9e4e 11 19 a0			ld de, sysdict 
9e51 73				ld (hl), e		; next word link ie system dict 
9e52 23				inc hl 
9e53 72				ld (hl), d		; next word link ie system dict 
9e54 23				inc hl	 
9e55			 
9e55			;	ld (hl), sysdict		; next word link ie system dict 
9e55			;	inc hl 
9e55			;	inc hl 
9e55			 
9e55			;	inc hl 
9e55			;	inc hl 
9e55			 
9e55 3e 02			ld a, 2			; word length is 0 
9e57 77				ld (hl), a	 
9e58 23				inc hl 
9e59			 
9e59 3e 7e			ld a, '~'			; word length is 0 
9e5b 77				ld (hl), a	 
9e5c 23				inc hl 
9e5d 3e 00			ld a, 0			; save empty word 
9e5f 77				ld (hl), a 
9e60			 
9e60 c9				ret 
9e61			 
9e61				 
9e61			 
9e61			forthexec_cleanup: 
9e61				FORTH_RSP_POP 
9e61 cd dc 9a			call macro_forth_rsp_pop 
9e64				endm 
# End of macro FORTH_RSP_POP
9e64 c9				ret 
9e65			 
9e65			forth_call_hl: 
9e65				; taking hl 
9e65 e5				push hl 
9e66 c9				ret 
9e67			 
9e67			; this is called to reset Forth system but keep existing uwords etc 
9e67			 
9e67			forth_warmstart: 
9e67				; setup stack over/under flow checks 
9e67				if DEBUG_FORTH_STACK_GUARD 
9e67 cd 08 df				call chk_stk_init 
9e6a				endif 
9e6a			 
9e6a				; init stack pointers  - * these stacks go upwards *  
9e6a 21 3c eb			ld hl, cli_ret_stack 
9e6d 22 82 eb			ld (cli_ret_sp), hl	 
9e70				; set bottom of stack 
9e70 3e 00			ld a,0 
9e72 77				ld (hl),a 
9e73 23				inc hl 
9e74 77				ld (hl),a 
9e75			 
9e75 21 b8 e9			ld hl, cli_data_stack 
9e78 22 7e eb			ld (cli_data_sp), hl	 
9e7b				; set bottom of stack 
9e7b 3e 00			ld a,0 
9e7d 77				ld (hl),a 
9e7e 23				inc hl 
9e7f 77				ld (hl),a 
9e80			 
9e80 21 ba ea			ld hl, cli_loop_stack 
9e83 22 80 eb			ld (cli_loop_sp), hl	 
9e86				; set bottom of stack 
9e86 3e 00			ld a,0 
9e88 77				ld (hl),a 
9e89 23				inc hl 
9e8a 77				ld (hl),a 
9e8b			 
9e8b				; init extent of current open file 
9e8b			 
9e8b 3e 00			ld a, 0 
9e8d 32 fa eb			ld (store_openext), a 
9e90			 
9e90 c9				ret 
9e91			 
9e91			 
9e91			; Cold Start - this is called to setup the whole Forth system 
9e91			 
9e91			forth_init: 
9e91			 
9e91				; setup stack over/under flow checks 
9e91			 
9e91			;	if DEBUG_FORTH_STACK_GUARD 
9e91			;		call chk_stk_init 
9e91			;	endif 
9e91			 
9e91				; enable auto display updates (slow.....) 
9e91			 
9e91 3e 01			ld a, 1 
9e93 32 cc eb			ld (cli_autodisplay), a 
9e96			 
9e96				; if storage is in use disable long reads for now 
9e96 3e 00			ld a, 0 
9e98 32 05 ec			ld (store_longread), a 
9e9b			 
9e9b			 
9e9b				; show start up screen 
9e9b			 
9e9b cd 75 8a			call clear_display 
9e9e			 
9e9e 3e 00			ld a,0 
9ea0 32 ee eb			ld (f_cursor_ptr), a 
9ea3			 
9ea3				; set start of word list in start of ram - for use when creating user words 
9ea3			 
9ea3 21 d3 e1			ld hl, baseram 
9ea6 22 4e e7			ld (os_last_new_uword), hl 
9ea9 cd 4a 9e			call user_word_eol 
9eac				 
9eac			;		call display_data_sp 
9eac			;		call next_page_prompt 
9eac			 
9eac			 
9eac			 
9eac			 
9eac c9				ret 
9ead			 
9ead .. 00		.bootforth: db " Forth Kernel Init ",0 
9ec1			 
9ec1			; TODO push to stack 
9ec1			 
9ec1			;  
9ec1			 
9ec1			if FORTH_PARSEV2 
9ec1			 
9ec1			 
9ec1				include "forth_parserv2.asm" 
9ec1			 
9ec1			endif 
9ec1			 
9ec1			 
9ec1			; parse cli version 1 
9ec1			 
9ec1			if FORTH_PARSEV1 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv1.asm" 
9ec1			endif 
9ec1				 
9ec1			if FORTH_PARSEV3 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv3.asm" 
9ec1				include "forth_wordsv3.asm" 
9ec1			endif 
9ec1			 
9ec1			if FORTH_PARSEV4 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv4.asm" 
9ec1				include "forth_wordsv4.asm" 
9ec1			endif 
9ec1			 
9ec1			if FORTH_PARSEV5 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv5.asm" 
9ec1			 
9ec1			 
9ec1			; A better parser without using malloc and string copies all over the place.  
9ec1			; Exec in situ should be faster 
9ec1			 
9ec1			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ec1			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ec1			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ec1			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ec1			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ec1			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ec1			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ec1			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ec1			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ec1			 
9ec1			; Core word preamble macro 
9ec1			 
9ec1			CWHEAD:   macro nxtword opcode lit len opflags 
9ec1				db WORD_SYS_CORE+opcode             
9ec1				; internal op code number 
9ec1				dw nxtword            
9ec1				; link to next dict word block 
9ec1				db len + 1 
9ec1				; literal length of dict word inc zero term 
9ec1				db lit,0              
9ec1				; literal dict word 
9ec1			        ; TODO db opflags        
9ec1				endm 
9ec1			 
9ec1			 
9ec1			NEXTW: macro  
9ec1				jp macro_next 
9ec1				endm 
9ec1			 
9ec1			macro_next: 
9ec1			if DEBUG_FORTH_PARSE_KEY 
9ec1				DMARK "NXT" 
9ec1				CALLMONITOR 
9ec1			endif	 
9ec1			;	inc hl  ; skip token null term  
9ec1 ed 4b d0 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9ec5 ed 5b ce eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ec9 2a 52 e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ecc			if DEBUG_FORTH_PARSE_KEY 
9ecc				DMARK "}AA" 
9ecc				CALLMONITOR 
9ecc			endif	 
9ecc c3 cf 9f			jp execnext 
9ecf				;jp exec1 
9ecf			       
9ecf			 
9ecf			 
9ecf			; Another go at the parser to compile  
9ecf			 
9ecf			 
9ecf			; TODO rework parser to change all of the string words to byte tokens 
9ecf			; TODO do a search for  
9ecf			 
9ecf			; TODO first run normal parser to zero term sections 
9ecf			; TODO for each word do a token look up to get the op code 
9ecf			; TODO need some means to flag to the exec that this is a byte code form    
9ecf			 
9ecf			 
9ecf			forthcompile: 
9ecf			 
9ecf			; 
9ecf			; line parse: 
9ecf			;       parse raw input buffer 
9ecf			;       tokenise the words 
9ecf			;       malloc new copy (for looping etc) 
9ecf			;       copy to malloc + current pc in line to start of string and add line term 
9ecf			;       save on new rsp 
9ecf			; 
9ecf			 
9ecf			; hl to point to the line to tokenise 
9ecf			 
9ecf			;	push hl 
9ecf 22 52 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9ed2			 
9ed2			;	ld a,0		; string term on input 
9ed2			;	call strlent 
9ed2			 
9ed2			;	ld (os_tok_len), hl	 ; save string length 
9ed2			 
9ed2			;if DEBUG_FORTH_TOK 
9ed2			;	ex de,hl		 
9ed2			;endif 
9ed2			 
9ed2			;	pop hl 		; get back string pointer 
9ed2			 
9ed2			if DEBUG_FORTH_TOK 
9ed2						DMARK "TOc" 
9ed2				CALLMONITOR 
9ed2			endif 
9ed2 7e			.cptoken2:    ld a,(hl) 
9ed3 23				inc hl 
9ed4 fe 7f			cp FORTH_END_BUFFER 
9ed6 28 29			jr z, .cptokendone2 
9ed8 fe 00			cp 0 
9eda 28 25			jr z, .cptokendone2 
9edc fe 22			cp '"' 
9ede 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9ee0 fe 20			cp ' ' 
9ee2 20 ee			jr nz,  .cptoken2 
9ee4			 
9ee4			; TODO consume comments held between ( and ) 
9ee4			 
9ee4				; we have a space so change to zero term for dict match later 
9ee4 2b				dec hl 
9ee5 3e 00			ld a,0 
9ee7 77				ld (hl), a 
9ee8 23				inc hl 
9ee9 18 e7			jr .cptoken2 
9eeb				 
9eeb			 
9eeb			.cptokenstr2: 
9eeb				; skip all white space until either eol (because forgot to term) or end double quote 
9eeb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9eeb				;inc hl ; skip current double quote 
9eeb 7e				ld a,(hl) 
9eec 23				inc hl 
9eed fe 22			cp '"' 
9eef 28 e1			jr z, .cptoken2 
9ef1 fe 7f			cp FORTH_END_BUFFER 
9ef3 28 0c			jr z, .cptokendone2 
9ef5 fe 00			cp 0 
9ef7 28 08			jr z, .cptokendone2 
9ef9 fe 20			cp ' ' 
9efb 28 02			jr z, .cptmp2 
9efd 18 ec			jr .cptokenstr2 
9eff			 
9eff			.cptmp2:	; we have a space so change to zero term for dict match later 
9eff				;dec hl 
9eff				;ld a,"-"	; TODO remove this when working 
9eff				;ld (hl), a 
9eff				;inc hl 
9eff 18 ea			jr .cptokenstr2 
9f01			 
9f01			.cptokendone2: 
9f01				;inc hl 
9f01 3e 7f			ld a, FORTH_END_BUFFER 
9f03 77				ld (hl),a 
9f04 23				inc hl 
9f05 3e 21			ld a, '!' 
9f07 77				ld (hl),a 
9f08			 
9f08 2a 52 e7			ld hl,(os_tok_ptr) 
9f0b			         
9f0b			if DEBUG_FORTH_TOK 
9f0b						DMARK "Tc1" 
9f0b				CALLMONITOR 
9f0b			endif 
9f0b			 
9f0b				; push exec string to top of return stack 
9f0b				FORTH_RSP_NEXT 
9f0b cd bb 9a			call macro_forth_rsp_next 
9f0e				endm 
# End of macro FORTH_RSP_NEXT
9f0e c9				ret 
9f0f			 
9f0f			; Another go at the parser need to simplify the process 
9f0f			 
9f0f			forthparse: 
9f0f			 
9f0f			; 
9f0f			; line parse: 
9f0f			;       parse raw input buffer 
9f0f			;       tokenise the words 
9f0f			;       malloc new copy (for looping etc) 
9f0f			;       copy to malloc + current pc in line to start of string and add line term 
9f0f			;       save on new rsp 
9f0f			; 
9f0f			 
9f0f			; hl to point to the line to tokenise 
9f0f			 
9f0f			;	push hl 
9f0f 22 52 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9f12			 
9f12			;	ld a,0		; string term on input 
9f12			;	call strlent 
9f12			 
9f12			;	ld (os_tok_len), hl	 ; save string length 
9f12			 
9f12			;if DEBUG_FORTH_TOK 
9f12			;	ex de,hl		 
9f12			;endif 
9f12			 
9f12			;	pop hl 		; get back string pointer 
9f12			 
9f12			if DEBUG_FORTH_TOK 
9f12						DMARK "TOK" 
9f12				CALLMONITOR 
9f12			endif 
9f12 7e			.ptoken2:    ld a,(hl) 
9f13 23				inc hl 
9f14 fe 7f			cp FORTH_END_BUFFER 
9f16 28 29			jr z, .ptokendone2 
9f18 fe 00			cp 0 
9f1a 28 25			jr z, .ptokendone2 
9f1c fe 22			cp '"' 
9f1e 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f20 fe 20			cp ' ' 
9f22 20 ee			jr nz,  .ptoken2 
9f24			 
9f24			; TODO consume comments held between ( and ) 
9f24			 
9f24				; we have a space so change to zero term for dict match later 
9f24 2b				dec hl 
9f25 3e 00			ld a,0 
9f27 77				ld (hl), a 
9f28 23				inc hl 
9f29 18 e7			jr .ptoken2 
9f2b				 
9f2b			 
9f2b			.ptokenstr2: 
9f2b				; skip all white space until either eol (because forgot to term) or end double quote 
9f2b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f2b				;inc hl ; skip current double quote 
9f2b 7e				ld a,(hl) 
9f2c 23				inc hl 
9f2d fe 22			cp '"' 
9f2f 28 e1			jr z, .ptoken2 
9f31 fe 7f			cp FORTH_END_BUFFER 
9f33 28 0c			jr z, .ptokendone2 
9f35 fe 00			cp 0 
9f37 28 08			jr z, .ptokendone2 
9f39 fe 20			cp ' ' 
9f3b 28 02			jr z, .ptmp2 
9f3d 18 ec			jr .ptokenstr2 
9f3f			 
9f3f			.ptmp2:	; we have a space so change to zero term for dict match later 
9f3f				;dec hl 
9f3f				;ld a,"-"	; TODO remove this when working 
9f3f				;ld (hl), a 
9f3f				;inc hl 
9f3f 18 ea			jr .ptokenstr2 
9f41			 
9f41			.ptokendone2: 
9f41				;inc hl 
9f41 3e 7f			ld a, FORTH_END_BUFFER 
9f43 77				ld (hl),a 
9f44 23				inc hl 
9f45 3e 21			ld a, '!' 
9f47 77				ld (hl),a 
9f48			 
9f48 2a 52 e7			ld hl,(os_tok_ptr) 
9f4b			         
9f4b			if DEBUG_FORTH_TOK 
9f4b						DMARK "TK1" 
9f4b				CALLMONITOR 
9f4b			endif 
9f4b			 
9f4b				; push exec string to top of return stack 
9f4b				FORTH_RSP_NEXT 
9f4b cd bb 9a			call macro_forth_rsp_next 
9f4e				endm 
# End of macro FORTH_RSP_NEXT
9f4e c9				ret 
9f4f			 
9f4f			; 
9f4f			;	; malloc size + buffer pointer + if is loop flag 
9f4f			;	ld hl,(os_tok_len) 		 ; get string length 
9f4f			; 
9f4f			;	ld a,l 
9f4f			; 
9f4f			;	cp 0			; we dont want to use a null string 
9f4f			;	ret z 
9f4f			; 
9f4f			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f4f			; 
9f4f			;	add 5     ; TODO when certain not over writing memory remove 
9f4f			; 
9f4f			;		 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKE" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	ld l,a 
9f4f			;	ld h,0 
9f4f			;;	push hl   ; save required space for the copy later 
9f4f			;	call malloc 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKM" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			;	if DEBUG_FORTH_MALLOC_GUARD 
9f4f			;		push af 
9f4f			;		call ishlzero 
9f4f			;;		ld a, l 
9f4f			;;		add h 
9f4f			;;		cp 0 
9f4f			;		pop af 
9f4f			;		 
9f4f			;		call z,malloc_error 
9f4f			;	endif 
9f4f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f4f			; 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKR" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	FORTH_RSP_NEXT 
9f4f			; 
9f4f			;	;inc hl	 ; go past current buffer pointer 
9f4f			;	;inc hl 
9f4f			;	;inc hl   ; and past if loop flag 
9f4f			;		; TODO Need to set flag  
9f4f			; 
9f4f			;	 
9f4f			;	 
9f4f			;	ex de,hl	; malloc is dest 
9f4f			;	ld hl, (os_tok_len) 
9f4f			;;	pop bc 
9f4f			;	ld c, l                
9f4f			;	ld b,0 
9f4f			;	ld hl, (os_tok_ptr) 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKT" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	; do str cpy 
9f4f			; 
9f4f			;	ldir      ; copy byte in hl to de 
9f4f			; 
9f4f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			; 
9f4f			;			DMARK "TKY" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			;	;ld a,0 
9f4f			;	;ld a,FORTH_END_BUFFER 
9f4f			;	ex de, hl 
9f4f			;	;dec hl			 ; go back over the space delim at the end of word 
9f4f			;	;ld (hl),a 
9f4f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f4f			;	ld a,FORTH_END_BUFFER 
9f4f			;	ld (hl),a 
9f4f			;	inc hl 
9f4f			;	ld a,FORTH_END_BUFFER 
9f4f			;	ld (hl),a 
9f4f			; 
9f4f			;	; init the malloc area data 
9f4f			;	; set pc for in current area 
9f4f			;	;ld hl, (os_tok_malloc) 
9f4f			;	;inc hl 
9f4f			;	;inc hl 
9f4f			;	;inc hl 
9f4f			;	;ex de,hl 
9f4f			;	;ld hl, (os_tok_malloc) 
9f4f			;	;ld (hl),e 
9f4f			;	;inc hl 
9f4f			;	;ld (hl),d 
9f4f			; 
9f4f			; 
9f4f			;	ld hl,(os_tok_malloc) 
9f4f			;if DEBUG_FORTH_PARSE_KEY 
9f4f			;			DMARK "TKU" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	ret 
9f4f			 
9f4f			forthexec: 
9f4f			 
9f4f			; line exec: 
9f4f			; forth parser 
9f4f			 
9f4f			; 
9f4f			;       get current exec line on rsp 
9f4f			 
9f4f				FORTH_RSP_TOS 
9f4f cd d2 9a			call macro_forth_rsp_tos 
9f52				endm 
# End of macro FORTH_RSP_TOS
9f52			 
9f52			;       restore current pc - hl points to malloc of data 
9f52			 
9f52				;ld e, (hl) 
9f52				;inc hl 
9f52				;ld d, (hl) 
9f52				;ex de,hl 
9f52			 
9f52			 
9f52			exec1: 
9f52 22 52 e7			ld (os_tok_ptr), hl 
9f55			 
9f55				; copy our PC to working vars  
9f55 22 d0 eb			ld (cli_ptr), hl 
9f58 22 ce eb			ld (cli_origptr), hl 
9f5b			 
9f5b 7e				ld a,(hl) 
9f5c fe 7f			cp FORTH_END_BUFFER 
9f5e c8				ret z 
9f5f			 
9f5f				; skip any nulls 
9f5f			 
9f5f fe 00			cp 0 
9f61 20 03			jr nz, .execword 
9f63 23				inc hl 
9f64 18 ec			jr exec1 
9f66			 
9f66			 
9f66			.execword: 
9f66			 
9f66			 
9f66			 
9f66			if DEBUG_FORTH_PARSE_KEY 
9f66						DMARK "KYQ" 
9f66				CALLMONITOR 
9f66			endif 
9f66			;       while at start of word: 
9f66			; get start of dict (in user area first) 
9f66			 
9f66 21 d3 e1		ld hl, baseram 
9f69			;ld hl, sysdict 
9f69 22 d2 eb		ld (cli_nextword),hl 
9f6c			;           match word at pc 
9f6c			;           exec word 
9f6c			;           or push to dsp 
9f6c			;           forward to next token 
9f6c			;           if line term pop rsp and exit 
9f6c			;        
9f6c			 
9f6c			if DEBUG_FORTH_PARSE_KEY 
9f6c						DMARK "KYq" 
9f6c				CALLMONITOR 
9f6c			endif 
9f6c			 
9f6c			; 
9f6c			; word comp 
9f6c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f6c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f6c			;    move to start of word  
9f6c			;    compare word to cli_token 
9f6c			 
9f6c			.execpnword:	; HL at start of a word in the dictionary to check 
9f6c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f6c			;	ld (cli_ptr), hl 
9f6c			 
9f6c 2a d2 eb			ld hl,(cli_nextword) 
9f6f			 
9f6f cd 12 a0			call forth_tok_next 
9f72			; tok next start here 
9f72			;	; TODO skip compiled symbol for now 
9f72			;	inc hl 
9f72			; 
9f72			;	; save pointer to next word 
9f72			; 
9f72			;	; hl now points to the address of the next word pointer  
9f72			;	ld e, (hl) 
9f72			;	inc hl 
9f72			;	ld d, (hl) 
9f72			;	inc l 
9f72			; 
9f72			;	ex de,hl 
9f72			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f72			;	push bc 
9f72			;	ld bc, (cli_nextword) 
9f72			;			DMARK "NXW" 
9f72			;	CALLMONITOR 
9f72			;	pop bc 
9f72			;endif 
9f72			; tok next end here 
9f72 22 d2 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f75 eb				ex de, hl 
9f76			 
9f76			 
9f76				; save the pointer of the current token - 1 to check against 
9f76				 
9f76 22 d6 eb			ld (cli_token), hl   
9f79				; TODO maybe remove below save if no debug 
9f79				; save token string ptr for any debug later 
9f79 23				inc hl  
9f7a 22 d8 eb			ld (cli_origtoken), hl 
9f7d 2b				dec hl 
9f7e				; save pointer to the start of the next dictionay word 
9f7e 7e				ld a,(hl)   ; get string length 
9f7f 47				ld b,a 
9f80			.execpnwordinc:  
9f80 23				inc hl 
9f81 10 fd			djnz .execpnwordinc 
9f83 22 d4 eb			ld (cli_execword), hl      ; save start of this words code 
9f86			 
9f86				; now check the word token against the string being parsed 
9f86			 
9f86 2a d6 eb			ld hl,(cli_token) 
9f89 23				inc hl     ; skip string length (use zero term instead to end) 
9f8a 22 d6 eb			ld (cli_token), hl 
9f8d			 
9f8d			if DEBUG_FORTH_PARSE_KEY 
9f8d						DMARK "KY2" 
9f8d			endif 
9f8d			if DEBUG_FORTH_PARSE_EXEC 
9f8d				; see if disabled 
9f8d			 
9f8d				ld a, (os_view_disable) 
9f8d				cp '*' 
9f8d				jr z, .skip 
9f8d			 
9f8d				push hl 
9f8d				push hl 
9f8d				call clear_display 
9f8d				ld de, .compword 
9f8d				ld a, display_row_1 
9f8d				call str_at_display 
9f8d				pop de 
9f8d				ld a, display_row_2 
9f8d				call str_at_display 
9f8d				ld hl,(cli_ptr) 
9f8d				ld a,(hl) 
9f8d			        ld hl, os_word_scratch 
9f8d				ld (hl),a 
9f8d				ld a,0 
9f8d				inc hl 
9f8d				ld (hl),a 	 
9f8d				ld de, os_word_scratch 
9f8d				ld a, display_row_2+10 
9f8d				call str_at_display 
9f8d				call update_display 
9f8d				ld a, 100 
9f8d				call aDelayInMS 
9f8d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f8d				call delay250ms 
9f8d				endif 
9f8d				pop hl 
9f8d			.skip:  
9f8d			endif	 
9f8d			.execpnchar:    ; compare char between token and string to parse 
9f8d			 
9f8d			if DEBUG_FORTH_PARSE_KEY 
9f8d						DMARK "Ky3" 
9f8d			endif 
9f8d			if DEBUG_FORTH_PARSE_EXEC 
9f8d				; see if disabled 
9f8d			 
9f8d				ld a, (os_view_disable) 
9f8d				cp '*' 
9f8d				jr z, .skip2 
9f8d			 
9f8d			;	call clear_display 
9f8d			ld hl,(cli_token) 
9f8d			ld a,(hl) 
9f8d			ld (os_word_scratch),a 
9f8d				ld hl,(cli_ptr) 
9f8d			ld a,(hl) 
9f8d				ld (os_word_scratch+1),a 
9f8d				ld a,0 
9f8d				ld (os_word_scratch+2),a 
9f8d				ld de,os_word_scratch 
9f8d				ld a,display_row_4 
9f8d				call str_at_display 
9f8d				call update_display 
9f8d			.skip2:  
9f8d			endif 
9f8d 2a d6 eb			ld hl,(cli_token) 
9f90 7e				ld a, (hl)	 ; char in word token 
9f91 23				inc hl 		; move to next char 
9f92 22 d6 eb			ld (cli_token), hl ; and save it 
9f95 47				ld b,a 
9f96			 
9f96 2a d0 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f99 7e				ld a,(hl) 
9f9a 23				inc hl 
9f9b 22 d0 eb			ld (cli_ptr), hl		; move to next char 
9f9e cd f7 90			call toUpper 		; make sure the input string matches case 
9fa1			 
9fa1			if DEBUG_FORTH_PARSE 
9fa1			endif 
9fa1			 
9fa1				; input stream end of token is a space so get rid of it 
9fa1			 
9fa1			;	cp ' ' 
9fa1			;	jr nz, .pnskipspace 
9fa1			; 
9fa1			;	ld a, 0		; make same term as word token term 
9fa1			; 
9fa1			;.pnskipspace: 
9fa1			 
9fa1			if DEBUG_FORTH_PARSE_KEY 
9fa1						DMARK "KY7" 
9fa1			endif 
9fa1 b8				cp b 
9fa2 c2 b8 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fa5				 
9fa5			;    if same 
9fa5			;       scan for string terms 0 for token and 32 for input 
9fa5			 
9fa5				 
9fa5			if DEBUG_FORTH_PARSE_KEY 
9fa5						DMARK "KY8" 
9fa5			endif 
9fa5			 
9fa5 80				add b			 
9fa6 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fa8							; TODO need to make sure last word in zero term string is accounted for 
9fa8 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9faa			 
9faa			 
9faa				; at end of both strings so both are exact match 
9faa			 
9faa			;       skip ptr for next word 
9faa			 
9faa 2a d0 eb			ld hl,(cli_ptr) 	; at input string term 
9fad 23				inc hl			 ; at next char 
9fae 22 d0 eb			ld (cli_ptr), hl     ; save for next round of the parser 
9fb1 22 ce eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fb4				 
9fb4				 
9fb4			if DEBUG_FORTH_PARSE_KEY 
9fb4						DMARK "KY3" 
9fb4			endif 
9fb4			 
9fb4			 
9fb4			 
9fb4			;       exec code block 
9fb4			if DEBUG_FORTH_JP 
9fb4				call clear_display 
9fb4				call update_display 
9fb4				call delay1s 
9fb4				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fb4				ld a,h 
9fb4				ld hl, os_word_scratch 
9fb4				call hexout 
9fb4				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fb4				ld a,l 
9fb4				ld hl, os_word_scratch+2 
9fb4				call hexout 
9fb4				ld hl, os_word_scratch+4 
9fb4				ld a,0 
9fb4				ld (hl),a 
9fb4				ld de,os_word_scratch 
9fb4				call str_at_display 
9fb4					ld a, display_row_2 
9fb4					call str_at_display 
9fb4				ld de, (cli_origtoken) 
9fb4				ld a, display_row_1+10 
9fb4					call str_at_display 
9fb4			 
9fb4				ld a,display_row_1 
9fb4				ld de, .foundword 
9fb4				ld a, display_row_3 
9fb4				call str_at_display 
9fb4				call update_display 
9fb4				call delay1s 
9fb4				call delay1s 
9fb4				call delay1s 
9fb4			endif 
9fb4			 
9fb4			if DEBUG_FORTH_PARSE_KEY 
9fb4						DMARK "KYj" 
9fb4			endif 
9fb4				; TODO save the word pointer in this exec 
9fb4			 
9fb4 2a d4 eb			ld hl,(cli_execword) 
9fb7 e9				jp (hl) 
9fb8			 
9fb8			 
9fb8			;    if not same 
9fb8			;	scan for zero term 
9fb8			;	get ptr for next word 
9fb8			;	goto word comp 
9fb8			 
9fb8			.execpnskipword:	; get pointer to next word 
9fb8 2a d2 eb			ld hl,(cli_nextword) 
9fbb			 
9fbb 7e				ld a,(hl) 
9fbc fe 00			cp WORD_SYS_END 
9fbe			;	cp 0 
9fbe 28 09			jr z, .execendofdict			 ; at end of words 
9fc0			 
9fc0			if DEBUG_FORTH_PARSE_KEY 
9fc0						DMARK "KY4" 
9fc0			endif 
9fc0			if DEBUG_FORTH_PARSE_EXEC 
9fc0			 
9fc0				; see if disabled 
9fc0			 
9fc0				ld a, (os_view_disable) 
9fc0				cp '*' 
9fc0				jr z, .noskip 
9fc0			 
9fc0			 
9fc0				ld de, .nowordfound 
9fc0				ld a, display_row_3 
9fc0				call str_at_display 
9fc0				call update_display 
9fc0				ld a, 100 
9fc0				call aDelayInMS 
9fc0				 
9fc0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc0					call delay250ms 
9fc0				endif 
9fc0			.noskip:  
9fc0			 
9fc0			endif	 
9fc0			 
9fc0 2a ce eb			ld hl,(cli_origptr) 
9fc3 22 d0 eb			ld (cli_ptr),hl 
9fc6			 
9fc6			if DEBUG_FORTH_PARSE_KEY 
9fc6						DMARK "KY5" 
9fc6			endif 
9fc6 c3 6c 9f			jp .execpnword			; else go to next word 
9fc9			 
9fc9			.execendofdict:  
9fc9			 
9fc9			if DEBUG_FORTH_PARSE_KEY 
9fc9						DMARK "KYe" 
9fc9			endif 
9fc9			if DEBUG_FORTH_PARSE_EXEC 
9fc9				; see if disabled 
9fc9			 
9fc9				ld a, (os_view_disable) 
9fc9				cp '*' 
9fc9				jr z, .ispskip 
9fc9			 
9fc9				call clear_display 
9fc9				call update_display 
9fc9				call delay1s 
9fc9				ld de, (cli_origptr) 
9fc9				ld a, display_row_1 
9fc9				call str_at_display 
9fc9				 
9fc9				ld de, .enddict 
9fc9				ld a, display_row_3 
9fc9				call str_at_display 
9fc9				call update_display 
9fc9				ld a, 100 
9fc9				call aDelayInMS 
9fc9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc9				call delay1s 
9fc9				call delay1s 
9fc9				call delay1s 
9fc9				endif 
9fc9			.ispskip:  
9fc9				 
9fc9			endif	 
9fc9			 
9fc9			 
9fc9			 
9fc9				; if the word is not a keyword then must be a literal so push it to stack 
9fc9			 
9fc9			; push token to stack to end of word 
9fc9			 
9fc9				STACKFRAME ON $1efe $2f9f 
9fc9				if DEBUG_STACK_IMB 
9fc9					if ON 
9fc9						exx 
9fc9						ld de, $1efe 
9fc9						ld a, d 
9fc9						ld hl, curframe 
9fc9						call hexout 
9fc9						ld a, e 
9fc9						ld hl, curframe+2 
9fc9						call hexout 
9fc9						ld hl, $1efe 
9fc9						push hl 
9fc9						ld hl, $2f9f 
9fc9						push hl 
9fc9						exx 
9fc9					endif 
9fc9				endif 
9fc9			endm 
# End of macro STACKFRAME
9fc9			 
9fc9 2a 52 e7		ld hl,(os_tok_ptr) 
9fcc cd 7d 9c		call forth_apush 
9fcf			 
9fcf				STACKFRAMECHK ON $1efe $2f9f 
9fcf				if DEBUG_STACK_IMB 
9fcf					if ON 
9fcf						exx 
9fcf						ld hl, $2f9f 
9fcf						pop de   ; $2f9f 
9fcf						call cmp16 
9fcf						jr nz, .spnosame 
9fcf						ld hl, $1efe 
9fcf						pop de   ; $1efe 
9fcf						call cmp16 
9fcf						jr z, .spfrsame 
9fcf						.spnosame: call showsperror 
9fcf						.spfrsame: nop 
9fcf						exx 
9fcf					endif 
9fcf				endif 
9fcf			endm 
# End of macro STACKFRAMECHK
9fcf			 
9fcf			execnext: 
9fcf			 
9fcf			if DEBUG_FORTH_PARSE_KEY 
9fcf						DMARK "KY>" 
9fcf			endif 
9fcf			; move past token to next word 
9fcf			 
9fcf 2a 52 e7		ld hl, (os_tok_ptr) 
9fd2 3e 00		ld a, 0 
9fd4 01 ff 00		ld bc, 255     ; input buffer size 
9fd7 ed b1		cpir 
9fd9			 
9fd9			if DEBUG_FORTH_PARSE_KEY 
9fd9						DMARK "KY!" 
9fd9				CALLMONITOR 
9fd9			endif	 
9fd9			; TODO this might place hl on the null, so will need to forward on??? 
9fd9			;inc hl   ; see if this gets onto the next item 
9fd9			 
9fd9			 
9fd9			; TODO pass a pointer to the buffer to push 
9fd9			; TODO call function to push 
9fd9			 
9fd9			; look for end of input 
9fd9			 
9fd9			;inc hl 
9fd9			;ld a,(hl) 
9fd9			;cp FORTH_END_BUFFER 
9fd9			;ret z 
9fd9			 
9fd9			 
9fd9 c3 52 9f		jp exec1 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			findnexttok: 
9fdc			 
9fdc				; hl is pointer to move 
9fdc				; de is the token to locate 
9fdc			 
9fdc					if DEBUG_FORTH 
9fdc						DMARK "NTK" 
9fdc						CALLMONITOR 
9fdc					endif 
9fdc d5				push de 
9fdd			 
9fdd			.fnt1:	 
9fdd				; find first char of token to locate 
9fdd			 
9fdd 1a				ld a, (de) 
9fde 4f				ld c,a 
9fdf 7e				ld a,(hl) 
9fe0 cd f7 90			call toUpper 
9fe3					if DEBUG_FORTH 
9fe3						DMARK "NT1" 
9fe3						CALLMONITOR 
9fe3					endif 
9fe3 b9				cp c 
9fe4			 
9fe4 28 03			jr z, .fnt2cmpmorefirst	 
9fe6			 
9fe6				; first char not found move to next char 
9fe6			 
9fe6 23				inc hl 
9fe7 18 f4			jr .fnt1 
9fe9			 
9fe9			.fnt2cmpmorefirst:	 
9fe9				; first char of token found.  
9fe9			 
9fe9 e5				push hl     ; save start of token just in case it is the right one 
9fea d9				exx 
9feb e1				pop hl        ; save it to hl' 
9fec d9				exx 
9fed			 
9fed			 
9fed			.fnt2cmpmore:	 
9fed				; compare the rest 
9fed				 
9fed 23				inc hl 
9fee 13				inc de 
9fef				 
9fef 1a				ld a, (de) 
9ff0 4f				ld c,a 
9ff1 7e				ld a,(hl) 
9ff2 cd f7 90			call toUpper 
9ff5			 
9ff5					if DEBUG_FORTH 
9ff5						DMARK "NT2" 
9ff5						CALLMONITOR 
9ff5					endif 
9ff5				; c has the token to find char 
9ff5				; a has the mem to scan char 
9ff5			 
9ff5 b9				cp c 
9ff6 28 04			jr z,.fntmatch1 
9ff8			 
9ff8				; they are not the same 
9ff8			 
9ff8					if DEBUG_FORTH 
9ff8						DMARK "NT3" 
9ff8						CALLMONITOR 
9ff8					endif 
9ff8 d1				pop de	; reset de token to look for 
9ff9 d5				push de 
9ffa 18 e1			jr .fnt1 
9ffc				 
9ffc			.fntmatch1: 
9ffc			 
9ffc				; is the same char a null which means we might have a full hit? 
9ffc					if DEBUG_FORTH 
9ffc						DMARK "NT4" 
9ffc						CALLMONITOR 
9ffc					endif 
9ffc			 
9ffc fe 00			cp 0 
9ffe 28 0b			jr z, .fntmatchyes 
a000			 
a000				; are we at the end of the token to find? 
a000			 
a000					if DEBUG_FORTH 
a000						DMARK "NT5" 
a000						CALLMONITOR 
a000					endif 
a000 3e 00			ld a, 0 
a002 b9				cp c 
a003			 
a003 c2 ed 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a006			 
a006					if DEBUG_FORTH 
a006						DMARK "NT6" 
a006						CALLMONITOR 
a006					endif 
a006				; token to find is exhusted but no match to stream 
a006			 
a006				; restore tok pointer and continue on 
a006 d1				pop de 
a007 d5				push de 
a008 c3 dd 9f			jp .fnt1 
a00b			 
a00b			 
a00b			.fntmatchyes: 
a00b			 
a00b				; hl now contains the end of the found token 
a00b			 
a00b				; get rid of saved token pointer to find 
a00b			 
a00b d1				pop de 
a00c			 
a00c					if DEBUG_FORTH 
a00c						DMARK "NT9" 
a00c						CALLMONITOR 
a00c					endif 
a00c			 
a00c				; hl will be on the null term so forward on 
a00c			 
a00c				; get back the saved start of the token 
a00c			 
a00c d9				exx 
a00d e5				push hl     ; save start of token just in case it is the right one 
a00e d9				exx 
a00f e1				pop hl        ; save it to hl 
a010			 
a010 c9				ret 
a011			 
a011			 
a011			; LIST needs to find a specific token   
a011			; FORGET needs to find a spefici token 
a011			 
a011			; SAVE needs to find all tokens by flag 
a011			; WORDS just needs to scan through all  by flag 
a011			; UWORDS needs to scan through all by flag 
a011			 
a011			 
a011			; given hl as pointer to start of dict look up string 
a011			; return hl as pointer to start of word block 
a011			; or 0 if not found 
a011			 
a011			forth_find_tok: 
a011 c9				ret 
a012			 
a012			; given hl as pointer to dict structure 
a012			; move to the next dict block structure 
a012			 
a012			forth_tok_next: 
a012				; hl now points to the address of the next word pointer  
a012				; TODO skip compiled symbol for now 
a012			;	push de 
a012 23				inc hl 
a013 5e				ld e, (hl) 
a014 23				inc hl 
a015 56				ld d, (hl) 
a016 23				inc hl 
a017			 
a017 eb				ex de,hl 
a018			if DEBUG_FORTH_PARSE_NEXTWORD 
a018				push bc 
a018				ld bc, (cli_nextword) 
a018						DMARK "NXW" 
a018				CALLMONITOR 
a018				pop bc 
a018			endif 
a018			;	pop de	 
a018 c9				ret 
a019			 
a019			 
a019			 
a019			; eof 
# End of file forth_parserv5.asm
a019				include "forth_wordsv4.asm" 
a019			 
a019			; the core word dictionary v4 
a019			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a019			 
a019			; this is a linked list for each of the system words used 
a019			; user defined words will follow the same format but will be in ram 
a019			 
a019			 
a019			; 
a019			; 
a019			; define linked list: 
a019			; 
a019			; 1. compiled byte op code 
a019			; 2. len of text word 
a019			; 3. text word 
a019			; 4. ptr to next dictionary word 
a019			; 5. asm, calls etc for the word 
a019			; 
a019			;  if 1 == 0 then last word in dict  
a019			;   
a019			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a019			;  
a019			;  
a019			; create basic standard set of words 
a019			; 
a019			;  
a019			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a019			; 2DUP 2DROP 2SWAP  
a019			; @ C@ - get byte  
a019			; ! C! - store byte 
a019			; 0< true if less than zero 
a019			; 0= true if zero 
a019			; < >  
a019			; = true if same 
a019			; variables 
a019			 
a019			 
a019			; Hardware specific words I may need 
a019			; 
a019			; IN OUT  
a019			; calls to key util functions 
a019			; calls to hardward abstraction stuff 
a019			; easy control of frame buffers and lcd i/o 
a019			; keyboard  
a019			 
a019			 
a019			;DICT: macro 
a019			; op_code, len, word, next 
a019			;    word: 
a019			;    db op_code 
a019			;    ds word zero term 
a019			;    dw next 
a019			;    endm 
a019			 
a019			 
a019			 
a019			 
a019			; op code 1 is a flag for user define words which are to be handled differently 
a019			 
a019			 
a019			; 
a019			; 
a019			;    TODO on entry to a word this should be the expected environment 
a019			;    hl - tos value if number then held, if string this is the ptr 
a019			;    de -  
a019			 
a019			 
a019			; opcode ranges 
a019			; 0 - end of word dict 
a019			; 255 - user define words 
a019			 
a019			sysdict: 
a019			include "forth_opcodes.asm" 
a019			; op codes for forth keywords 
a019			; free to use code 0  
a019				OPCODE_HEAP: equ  1 
a019				OPCODE_EXEC: equ 2 
a019				OPCODE_DUP: equ 3 
a019				OPCODE_SWAP: equ 4 
a019				OPCODE_COLN: equ 5 
a019				OPCODE_SCOLN: equ 6 
a019				OPCODE_DROP: equ 7 
a019				OPCODE_DUP2: equ 8 
a019				OPCODE_DROP2: equ 9 
a019				OPCODE_SWAP2: equ 10 
a019				OPCODE_AT: equ 11 
a019				OPCODE_CAT: equ 12 
a019				OPCODE_BANG: equ 13 
a019				OPCODE_CBANG: equ 14 
a019				OPCODE_SCALL: equ 15 
a019				OPCODE_DEPTH: equ 16 
a019				OPCODE_OVER: equ 17 
a019				OPCODE_PAUSE: equ 18 
a019				OPCODE_PAUSES: equ 19 
a019				OPCODE_ROT: equ 20 
a019			;free to reuse	OPCODE_WORDS: equ 21 
a019			        OPCODE_NOT: equ 21 
a019				OPCODE_UWORDS: equ 22 
a019				OPCODE_BP: equ 23 
a019				OPCODE_MONITOR: equ 24  
a019				OPCODE_MALLOC: equ 25 
a019				OPCODE_FREE: equ 26 
a019				OPCODE_LIST: equ 27 
a019				OPCODE_FORGET: equ 28 
a019				OPCODE_NOP: equ 29 
a019				OPCODE_COMO: equ 30 
a019				OPCODE_COMC: equ 31 
a019			;free to reuse	OPCODE_ENDCORE: equ 32 
a019				OPCODE_AFTERSOUND: equ 33 
a019				OPCODE_GP2: equ 34 
a019				OPCODE_GP3: equ 35 
a019				OPCODE_GP4: equ 36 
a019				OPCODE_SIN: equ 37 
a019				OPCODE_SOUT: equ 38 
a019				OPCODE_SPIO: equ 39 
a019				OPCODE_SPICEH: equ 40 
a019				OPCODE_SPIOb: equ 41 
a019				OPCODE_SPII: equ 42 
a019				OPCODE_SESEL: equ 43 
a019				OPCODE_CARTDEV: equ 44 
a019			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a019				OPCODE_FB: equ 46 
a019				OPCODE_EMIT: equ 47 
a019				OPCODE_DOTH: equ 48 
a019				OPCODE_DOTF: equ 49 
a019				OPCODE_DOT: equ 50 
a019				OPCODE_CLS: equ 51 
a019				OPCODE_DRAW: equ 52 
a019				OPCODE_DUMP: equ 53 
a019				OPCODE_CDUMP: equ 54 
a019				OPCODE_DAT: equ 55 
a019				OPCODE_HOME: equ 56 
a019				OPCODE_SPACE: equ 57 
a019				OPCODE_SPACES: equ 58 
a019				OPCODE_SCROLL: equ 59 
a019				OPCODE_ATQ: equ 60 
a019				OPCODE_AUTODSP: equ 61 
a019				OPCODE_MENU: equ 62 
a019			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a019				OPCODE_THEN: equ 64 
a019				OPCODE_ELSE: equ 65 
a019				OPCODE_DO: equ 66 
a019				OPCODE_LOOP: equ 67 
a019				OPCODE_I: equ 68 
a019				OPCODE_DLOOP: equ 69  
a019				OPCODE_REPEAT: equ 70  
a019				OPCODE_UNTIL: equ 71 
a019				OPCODE_ENDFLOW: equ 72 
a019				OPCODE_WAITK: equ 73 
a019				OPCODE_ACCEPT: equ 74 
a019				OPCODE_EDIT: equ 75 
a019			;free to reuse	OPCODE_ENDKEY: equ 76 
a019				OPCODE_LZERO: equ 77 
a019				OPCODE_TZERO: equ 78 
a019				OPCODE_LESS: equ 79 
a019				OPCODE_GT: equ 80 
a019				OPCODE_EQUAL: equ 81  
a019			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a019				OPCODE_NEG: equ 83 
a019				OPCODE_DIV: equ 84 
a019				OPCODE_MUL: equ 85 
a019				OPCODE_MIN: equ 86 
a019				OPCODE_MAX: equ 87 
a019				OPCODE_RND16: equ 88 
a019				OPCODE_RND8: equ 89 
a019				OPCODE_RND: equ 90 
a019			;free to reuse	OPCODE_ENDMATHS: equ 91  
a019				OPCODE_BYNAME: equ 92 
a019				OPCODE_DIR: equ 93 
a019				OPCODE_SAVE: equ 94 
a019				OPCODE_LOAD: equ 95 
a019				OPCODE_BSAVE: equ 96 
a019				OPCODE_BLOAD: equ 97 
a019				OPCODE_SEO: equ 98  
a019				OPCODE_SEI: equ 99 
a019				OPCODE_SFREE: equ 100 
a019				OPCODE_SIZE: equ 101 
a019				OPCODE_CREATE: equ 102 
a019				OPCODE_APPEND: equ 103 
a019				OPCODE_SDEL: equ 104 
a019				OPCODE_OPEN: equ 105 
a019				OPCODE_READ: equ 106 
a019				OPCODE_EOF: equ 106 
a019				OPCODE_FORMAT: equ 107 
a019				OPCODE_LABEL: equ 108 
a019				OPCODE_LABELS: equ 109 
a019			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a019				OPCODE_UPPER: equ 111 
a019				OPCODE_LOWER: equ 112 
a019				OPCODE_SUBSTR: equ 113 
a019				OPCODE_LEFT: equ 114 
a019				OPCODE_RIGHT: equ 115 
a019				OPCODE_STR2NUM: equ 116 
a019				OPCODE_NUM2STR: equ 117 
a019				OPCODE_CONCAT: equ 118 
a019				OPCODE_FIND: equ 119 
a019				OPCODE_LEN: equ 120 
a019				OPCODE_CHAR: equ 121 
a019			; free to reuse	OPCODE_STRLEN: equ 122 
a019			; free to reuse	OPCODE_ENDSTR: equ 123 
a019				OPCODE_V0S: equ 124 
a019				OPCODE_V0Q: equ 125 
a019				OPCODE_V1S: equ 126 
a019				OPCODE_V1Q: equ 127 
a019				OPCODE_V2S: equ 128 
a019				OPCODE_V2Q: equ 129 
a019				OPCODE_V3S: equ 130 
a019				OPCODE_V3Q: equ 131 
a019			;free to reuse	OPCODE_END: equ 132 
a019				OPCODE_ZDUP: equ 133 
a019			 
a019			; eof 
# End of file forth_opcodes.asm
a019			 
a019			include "forth_words_core.asm" 
a019			 
a019			; | ## Core Words 
a019			 
a019			;if MALLOC_4 
a019			 
a019			.HEAP: 
a019				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a019 15				db WORD_SYS_CORE+OPCODE_HEAP             
a01a 58 a0			dw .EXEC            
a01c 05				db 4 + 1 
a01d .. 00			db "HEAP",0              
a022				endm 
# End of macro CWHEAD
a022			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a022			; | | u1 - Current number of bytes in the heap 
a022			; | | u2 - Remaining bytes left on the heap 
a022			; | |  
a022			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a022			 
a022			 
a022					if DEBUG_FORTH_WORDS_KEY 
a022						DMARK "HEP" 
a022 f5				push af  
a023 3a 37 a0			ld a, (.dmark)  
a026 32 b7 ee			ld (debug_mark),a  
a029 3a 38 a0			ld a, (.dmark+1)  
a02c 32 b8 ee			ld (debug_mark+1),a  
a02f 3a 39 a0			ld a, (.dmark+2)  
a032 32 b9 ee			ld (debug_mark+2),a  
a035 18 03			jr .pastdmark  
a037 ..			.dmark: db "HEP"  
a03a f1			.pastdmark: pop af  
a03b			endm  
# End of macro DMARK
a03b						CALLMONITOR 
a03b cd a3 94			call break_point_state  
a03e				endm  
# End of macro CALLMONITOR
a03e					endif 
a03e 2a dd e1				ld hl, (free_list )      
a041 11 e2 e1				ld de, heap_start 
a044			 
a044 ed 52				sbc hl, de  
a046			 
a046 cd 14 9b				call forth_push_numhl 
a049			 
a049			 
a049 ed 5b dd e1			ld de, (free_list )      
a04d 21 37 e4				ld hl, heap_end 
a050			 
a050 ed 52				sbc hl, de 
a052			 
a052 cd 14 9b				call forth_push_numhl 
a055					 
a055			 
a055					 
a055			 
a055			 
a055			 
a055					NEXTW 
a055 c3 c1 9e			jp macro_next 
a058				endm 
# End of macro NEXTW
a058			;endif 
a058			 
a058			.EXEC: 
a058			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a058			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a058			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a058			;; > > 
a058			;; > >   
a058			;	STACKFRAME OFF $5efe $5f9f 
a058			; 
a058			;		if DEBUG_FORTH_WORDS_KEY 
a058			;			DMARK "EXE" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	FORTH_DSP_VALUEHL 
a058			; 
a058			;	FORTH_DSP_POP 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX1" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;;	ld e,(hl) 
a058			;;	inc hl 
a058			;;	ld d,(hl) 
a058			;;	ex de,hl 
a058			; 
a058			;;		if DEBUG_FORTH_WORDS 
a058			;;			DMARK "EX2" 
a058			;;			CALLMONITOR 
a058			;;		endif 
a058			;	push hl 
a058			; 
a058			;	;ld a, 0 
a058			;	;ld a, FORTH_END_BUFFER 
a058			;	call strlenz 
a058			;	inc hl   ; include zero term to copy 
a058			;	inc hl   ; include term 
a058			;	inc hl   ; include term 
a058			;	ld b,0 
a058			;	ld c,l 
a058			;	pop hl 
a058			;	ld de, execscratch 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX3" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ldir 
a058			; 
a058			; 
a058			;	ld hl, execscratch 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXe" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	call forthparse 
a058			;	call forthexec 
a058			;;	call forthexec_cleanup 
a058			;;	call forthparse 
a058			;;	call forthexec 
a058			; 
a058			;	STACKFRAMECHK OFF $5efe $5f9f 
a058			; 
a058			;	; an immediate word so no need to process any more words 
a058			;	ret 
a058			;	NEXTW 
a058			 
a058			; dead code - old version  
a058			;	FORTH_RSP_NEXT 
a058			 
a058			;  
a058			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a058			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a058			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a058			;	push hl 
a058			;	push de 
a058			;	push bc 
a058			; 
a058			; 
a058			;		if DEBUG_FORTH_WORDS_KEY 
a058			;			DMARK "EXR" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			; 
a058			; 
a058			;	;v5 FORTH_DSP_VALUE 
a058			;	FORTH_DSP_VALUEHL 
a058			; 
a058			;	; TODO do string type checks 
a058			; 
a058			;;v5	inc hl   ; skip type 
a058			; 
a058			;	push hl  ; source code  
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX1" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ld a, 0 
a058			;	call strlent 
a058			; 
a058			;	inc hl 
a058			;	inc hl 
a058			;	inc hl 
a058			;	inc hl 
a058			; 
a058			;	push hl    ; size 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX2" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	call malloc 
a058			; 
a058			;	ex de, hl    ; de now contains malloc area 
a058			;	pop bc   	; get byte count 
a058			;	pop hl      ; get string to copy 
a058			; 
a058			;	push de     ; save malloc for free later 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX3" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ldir       ; duplicate string 
a058			; 
a058			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a058			;	 
a058			;	; TODO fix the parse would be better than this...  
a058			;	ex de, hl 
a058			;	dec hl 
a058			;	ld a, 0 
a058			;	ld (hl), a 
a058			;	dec hl 
a058			;	ld a, ' ' 
a058			;	ld (hl), a 
a058			;	dec hl 
a058			;	ld (hl), a 
a058			; 
a058			;	dec hl 
a058			;	ld (hl), a 
a058			; 
a058			; 
a058			;	FORTH_DSP_POP  
a058			; 
a058			;	pop hl     
a058			;	push hl    ; save malloc area 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX4" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	call forthparse 
a058			;	call forthexec 
a058			;	 
a058			;	pop hl 
a058			;	if DEBUG_FORTH_WORDS 
a058			;		DMARK "EX5" 
a058			;		CALLMONITOR 
a058			;	endif 
a058			; 
a058			;	if FORTH_ENABLE_FREE 
a058			;	call free 
a058			;	endif 
a058			; 
a058			;	if DEBUG_FORTH_WORDS 
a058			;		DMARK "EX6" 
a058			;		CALLMONITOR 
a058			;	endif 
a058			; 
a058			;	pop bc 
a058			;	pop de 
a058			;	pop hl 
a058			;;	FORTH_RSP_POP	  
a058			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a058			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a058			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a058			; 
a058			;	if DEBUG_FORTH_WORDS 
a058			;		DMARK "EX7" 
a058			;		CALLMONITOR 
a058			;	endif 
a058			;	NEXTW 
a058			 
a058			;.STKEXEC: 
a058			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a058			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a058			; 
a058			; 
a058			;		if DEBUG_FORTH_WORDS_KEY 
a058			;			DMARK "STX" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	FORTH_DSP_VALUEHL 
a058			; 
a058			;	ld (store_tmp1), hl    ; count 
a058			; 
a058			;	FORTH_DSP_POP 
a058			;.stkexec1: 
a058			;	ld hl, (store_tmp1)   ; count 
a058			;	ld a, 0 
a058			;	cp l 
a058			;	ret z 
a058			; 
a058			;	dec hl 
a058			;	ld (store_tmp1), hl    ; count 
a058			;	 
a058			;	FORTH_DSP_VALUEHL 
a058			;	push hl 
a058			;	 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXp" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	FORTH_DSP_POP 
a058			; 
a058			;	call strlenz 
a058			;	inc hl   ; include zero term to copy 
a058			;	inc hl   ; include zero term to copy 
a058			;	inc hl   ; include zero term to copy 
a058			;	ld b,0 
a058			;	ld c,l 
a058			;	pop hl 
a058			;	ld de, execscratch 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX3" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ldir 
a058			; 
a058			; 
a058			;	ld hl, execscratch 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXP" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	call forthparse 
a058			;	ld hl, execscratch 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXx" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	call forthexec 
a058			; 
a058			;	jp .stkexec1 
a058			; 
a058			;	ret 
a058			 
a058			 
a058			.DUP: 
a058				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a058 17				db WORD_SYS_CORE+OPCODE_DUP             
a059 ce a0			dw .ZDUP            
a05b 04				db 3 + 1 
a05c .. 00			db "DUP",0              
a060				endm 
# End of macro CWHEAD
a060			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a060			 
a060					if DEBUG_FORTH_WORDS_KEY 
a060						DMARK "DUP" 
a060 f5				push af  
a061 3a 75 a0			ld a, (.dmark)  
a064 32 b7 ee			ld (debug_mark),a  
a067 3a 76 a0			ld a, (.dmark+1)  
a06a 32 b8 ee			ld (debug_mark+1),a  
a06d 3a 77 a0			ld a, (.dmark+2)  
a070 32 b9 ee			ld (debug_mark+2),a  
a073 18 03			jr .pastdmark  
a075 ..			.dmark: db "DUP"  
a078 f1			.pastdmark: pop af  
a079			endm  
# End of macro DMARK
a079						CALLMONITOR 
a079 cd a3 94			call break_point_state  
a07c				endm  
# End of macro CALLMONITOR
a07c					endif 
a07c			 
a07c					FORTH_DSP 
a07c cd d1 9c			call macro_forth_dsp 
a07f				endm 
# End of macro FORTH_DSP
a07f			 
a07f 7e					ld a, (HL) 
a080 fe 01				cp DS_TYPE_STR 
a082 20 25				jr nz, .dupinum 
a084			 
a084					; push another string 
a084			 
a084					FORTH_DSP_VALUEHL     		 
a084 cd 0b 9d			call macro_dsp_valuehl 
a087				endm 
# End of macro FORTH_DSP_VALUEHL
a087			 
a087				if DEBUG_FORTH_WORDS 
a087					DMARK "DUs" 
a087 f5				push af  
a088 3a 9c a0			ld a, (.dmark)  
a08b 32 b7 ee			ld (debug_mark),a  
a08e 3a 9d a0			ld a, (.dmark+1)  
a091 32 b8 ee			ld (debug_mark+1),a  
a094 3a 9e a0			ld a, (.dmark+2)  
a097 32 b9 ee			ld (debug_mark+2),a  
a09a 18 03			jr .pastdmark  
a09c ..			.dmark: db "DUs"  
a09f f1			.pastdmark: pop af  
a0a0			endm  
# End of macro DMARK
a0a0					CALLMONITOR 
a0a0 cd a3 94			call break_point_state  
a0a3				endm  
# End of macro CALLMONITOR
a0a3				endif 
a0a3 cd 82 9b				call forth_push_str 
a0a6			 
a0a6					NEXTW 
a0a6 c3 c1 9e			jp macro_next 
a0a9				endm 
# End of macro NEXTW
a0a9			 
a0a9			 
a0a9			.dupinum: 
a0a9					 
a0a9			 
a0a9			 
a0a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0a9 cd 0b 9d			call macro_dsp_valuehl 
a0ac				endm 
# End of macro FORTH_DSP_VALUEHL
a0ac			 
a0ac				; TODO add floating point number detection 
a0ac			 
a0ac				if DEBUG_FORTH_WORDS 
a0ac					DMARK "DUi" 
a0ac f5				push af  
a0ad 3a c1 a0			ld a, (.dmark)  
a0b0 32 b7 ee			ld (debug_mark),a  
a0b3 3a c2 a0			ld a, (.dmark+1)  
a0b6 32 b8 ee			ld (debug_mark+1),a  
a0b9 3a c3 a0			ld a, (.dmark+2)  
a0bc 32 b9 ee			ld (debug_mark+2),a  
a0bf 18 03			jr .pastdmark  
a0c1 ..			.dmark: db "DUi"  
a0c4 f1			.pastdmark: pop af  
a0c5			endm  
# End of macro DMARK
a0c5					CALLMONITOR 
a0c5 cd a3 94			call break_point_state  
a0c8				endm  
# End of macro CALLMONITOR
a0c8				endif 
a0c8			 
a0c8 cd 14 9b				call forth_push_numhl 
a0cb					NEXTW 
a0cb c3 c1 9e			jp macro_next 
a0ce				endm 
# End of macro NEXTW
a0ce			.ZDUP: 
a0ce				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a0ce 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0cf 06 a1			dw .SWAP            
a0d1 05				db 4 + 1 
a0d2 .. 00			db "?DUP",0              
a0d7				endm 
# End of macro CWHEAD
a0d7			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a0d7			 
a0d7					if DEBUG_FORTH_WORDS_KEY 
a0d7						DMARK "qDU" 
a0d7 f5				push af  
a0d8 3a ec a0			ld a, (.dmark)  
a0db 32 b7 ee			ld (debug_mark),a  
a0de 3a ed a0			ld a, (.dmark+1)  
a0e1 32 b8 ee			ld (debug_mark+1),a  
a0e4 3a ee a0			ld a, (.dmark+2)  
a0e7 32 b9 ee			ld (debug_mark+2),a  
a0ea 18 03			jr .pastdmark  
a0ec ..			.dmark: db "qDU"  
a0ef f1			.pastdmark: pop af  
a0f0			endm  
# End of macro DMARK
a0f0						CALLMONITOR 
a0f0 cd a3 94			call break_point_state  
a0f3				endm  
# End of macro CALLMONITOR
a0f3					endif 
a0f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0f3 cd 0b 9d			call macro_dsp_valuehl 
a0f6				endm 
# End of macro FORTH_DSP_VALUEHL
a0f6			 
a0f6 e5					push hl 
a0f7			 
a0f7					; is it a zero? 
a0f7			 
a0f7 3e 00				ld a, 0 
a0f9 84					add h 
a0fa 85					add l 
a0fb			 
a0fb e1					pop hl 
a0fc			 
a0fc fe 00				cp 0 
a0fe 28 03				jr z, .dup2orig 
a100			 
a100			 
a100 cd 14 9b				call forth_push_numhl 
a103			 
a103			 
a103				; TODO add floating point number detection 
a103			 
a103			.dup2orig: 
a103			 
a103					NEXTW 
a103 c3 c1 9e			jp macro_next 
a106				endm 
# End of macro NEXTW
a106			.SWAP: 
a106				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a106 18				db WORD_SYS_CORE+OPCODE_SWAP             
a107 45 a1			dw .COLN            
a109 05				db 4 + 1 
a10a .. 00			db "SWAP",0              
a10f				endm 
# End of macro CWHEAD
a10f			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a10f					if DEBUG_FORTH_WORDS_KEY 
a10f						DMARK "SWP" 
a10f f5				push af  
a110 3a 24 a1			ld a, (.dmark)  
a113 32 b7 ee			ld (debug_mark),a  
a116 3a 25 a1			ld a, (.dmark+1)  
a119 32 b8 ee			ld (debug_mark+1),a  
a11c 3a 26 a1			ld a, (.dmark+2)  
a11f 32 b9 ee			ld (debug_mark+2),a  
a122 18 03			jr .pastdmark  
a124 ..			.dmark: db "SWP"  
a127 f1			.pastdmark: pop af  
a128			endm  
# End of macro DMARK
a128						CALLMONITOR 
a128 cd a3 94			call break_point_state  
a12b				endm  
# End of macro CALLMONITOR
a12b					endif 
a12b			 
a12b					FORTH_DSP_VALUEHL 
a12b cd 0b 9d			call macro_dsp_valuehl 
a12e				endm 
# End of macro FORTH_DSP_VALUEHL
a12e e5					push hl     ; w2 
a12f			 
a12f					FORTH_DSP_POP 
a12f cd c3 9d			call macro_forth_dsp_pop 
a132				endm 
# End of macro FORTH_DSP_POP
a132			 
a132					FORTH_DSP_VALUEHL 
a132 cd 0b 9d			call macro_dsp_valuehl 
a135				endm 
# End of macro FORTH_DSP_VALUEHL
a135			 
a135					FORTH_DSP_POP 
a135 cd c3 9d			call macro_forth_dsp_pop 
a138				endm 
# End of macro FORTH_DSP_POP
a138			 
a138 d1					pop de     ; w2	, hl = w1 
a139			 
a139 eb					ex de, hl 
a13a d5					push de 
a13b			 
a13b cd 14 9b				call forth_push_numhl 
a13e			 
a13e e1					pop hl 
a13f			 
a13f cd 14 9b				call forth_push_numhl 
a142					 
a142			 
a142					NEXTW 
a142 c3 c1 9e			jp macro_next 
a145				endm 
# End of macro NEXTW
a145			.COLN: 
a145				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a145 19				db WORD_SYS_CORE+OPCODE_COLN             
a146 d1 a2			dw .SCOLN            
a148 02				db 1 + 1 
a149 .. 00			db ":",0              
a14b				endm 
# End of macro CWHEAD
a14b			; | : ( -- )         Create new word | DONE 
a14b			 
a14b					if DEBUG_FORTH_WORDS_KEY 
a14b						DMARK "CLN" 
a14b f5				push af  
a14c 3a 60 a1			ld a, (.dmark)  
a14f 32 b7 ee			ld (debug_mark),a  
a152 3a 61 a1			ld a, (.dmark+1)  
a155 32 b8 ee			ld (debug_mark+1),a  
a158 3a 62 a1			ld a, (.dmark+2)  
a15b 32 b9 ee			ld (debug_mark+2),a  
a15e 18 03			jr .pastdmark  
a160 ..			.dmark: db "CLN"  
a163 f1			.pastdmark: pop af  
a164			endm  
# End of macro DMARK
a164						CALLMONITOR 
a164 cd a3 94			call break_point_state  
a167				endm  
# End of macro CALLMONITOR
a167					endif 
a167				STACKFRAME OFF $8efe $989f 
a167				if DEBUG_STACK_IMB 
a167					if OFF 
a167						exx 
a167						ld de, $8efe 
a167						ld a, d 
a167						ld hl, curframe 
a167						call hexout 
a167						ld a, e 
a167						ld hl, curframe+2 
a167						call hexout 
a167						ld hl, $8efe 
a167						push hl 
a167						ld hl, $989f 
a167						push hl 
a167						exx 
a167					endif 
a167				endif 
a167			endm 
# End of macro STACKFRAME
a167				; get parser buffer length  of new word 
a167			 
a167				 
a167			 
a167					; move tok past this to start of name defintition 
a167					; TODO get word to define 
a167					; TODO Move past word token 
a167					; TODO get length of string up to the ';' 
a167			 
a167 2a 52 e7			ld hl, (os_tok_ptr) 
a16a 23				inc hl 
a16b 23				inc hl 
a16c			 
a16c 3e 3b			ld a, ';' 
a16e cd 0b 91			call strlent 
a171			 
a171 7d				ld a,l 
a172 32 4d e4			ld (os_new_parse_len), a 
a175			 
a175			 
a175			if DEBUG_FORTH_UWORD 
a175 ed 5b 52 e7		ld de, (os_tok_ptr) 
a179						DMARK ":01" 
a179 f5				push af  
a17a 3a 8e a1			ld a, (.dmark)  
a17d 32 b7 ee			ld (debug_mark),a  
a180 3a 8f a1			ld a, (.dmark+1)  
a183 32 b8 ee			ld (debug_mark+1),a  
a186 3a 90 a1			ld a, (.dmark+2)  
a189 32 b9 ee			ld (debug_mark+2),a  
a18c 18 03			jr .pastdmark  
a18e ..			.dmark: db ":01"  
a191 f1			.pastdmark: pop af  
a192			endm  
# End of macro DMARK
a192				CALLMONITOR 
a192 cd a3 94			call break_point_state  
a195				endm  
# End of macro CALLMONITOR
a195			endif 
a195			 
a195			; 
a195			;  new word memory layout: 
a195			;  
a195			;    : adg 6666 ;  
a195			; 
a195			;    db   1     ; user defined word  
a195 23				inc hl    
a196			;    dw   sysdict 
a196 23				inc hl 
a197 23				inc hl 
a198			;    db <word len>+1 (for null) 
a198 23				inc hl 
a199			;    db .... <word> 
a199			; 
a199			 
a199 23				inc hl    ; some extras for the word preamble before the above 
a19a 23				inc hl 
a19b 23				inc hl 
a19c 23				inc hl 
a19d 23				inc hl 
a19e 23				inc hl 
a19f 23				inc hl  
a1a0 23				inc hl 
a1a1 23				inc hl 
a1a2 23				inc hl 
a1a3 23				inc hl 
a1a4 23				inc hl 
a1a5 23				inc hl 
a1a6 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1a7			;       exec word buffer 
a1a7			;	<ptr word>   
a1a7 23				inc hl 
a1a8 23				inc hl 
a1a9			;       <word list><null term> 7F final term 
a1a9			 
a1a9			 
a1a9			if DEBUG_FORTH_UWORD 
a1a9						DMARK ":02" 
a1a9 f5				push af  
a1aa 3a be a1			ld a, (.dmark)  
a1ad 32 b7 ee			ld (debug_mark),a  
a1b0 3a bf a1			ld a, (.dmark+1)  
a1b3 32 b8 ee			ld (debug_mark+1),a  
a1b6 3a c0 a1			ld a, (.dmark+2)  
a1b9 32 b9 ee			ld (debug_mark+2),a  
a1bc 18 03			jr .pastdmark  
a1be ..			.dmark: db ":02"  
a1c1 f1			.pastdmark: pop af  
a1c2			endm  
# End of macro DMARK
a1c2				CALLMONITOR 
a1c2 cd a3 94			call break_point_state  
a1c5				endm  
# End of macro CALLMONITOR
a1c5			endif 
a1c5			 
a1c5				 
a1c5					; malloc the size 
a1c5			 
a1c5 cd 69 91				call malloc 
a1c8 22 4f e4				ld (os_new_malloc), hl     ; save malloc start 
a1cb			 
a1cb			;    db   1     ; user defined word  
a1cb 3e 01				ld a, WORD_SYS_UWORD  
a1cd 77					ld (hl), a 
a1ce				 
a1ce 23				inc hl    
a1cf			;    dw   sysdict 
a1cf 11 19 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a1d2 73				ld (hl), e 
a1d3 23				inc hl 
a1d4 72				ld (hl), d 
a1d5 23				inc hl 
a1d6			 
a1d6			 
a1d6			;    Setup dict word 
a1d6			 
a1d6 23				inc hl 
a1d7 22 49 e4			ld (os_new_work_ptr), hl     ; save start of dict word  
a1da			 
a1da				; 1. get length of dict word 
a1da			 
a1da			 
a1da 2a 52 e7			ld hl, (os_tok_ptr) 
a1dd 23				inc hl 
a1de 23				inc hl    ; position to start of dict word 
a1df 3e 00			ld a, 0 
a1e1 cd 0b 91			call strlent 
a1e4			 
a1e4			 
a1e4 23				inc hl    ; to include null??? 
a1e5			 
a1e5				; write length of dict word 
a1e5			 
a1e5 ed 5b 49 e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1e9 1b				dec de 
a1ea eb				ex de, hl 
a1eb 73				ld (hl), e 
a1ec eb				ex de, hl 
a1ed			 
a1ed				 
a1ed			 
a1ed				; copy  
a1ed 4d				ld c, l 
a1ee 06 00			ld b, 0 
a1f0 ed 5b 49 e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1f4 2a 52 e7			ld hl, (os_tok_ptr) 
a1f7 23				inc hl 
a1f8 23				inc hl    ; position to start of dict word 
a1f9				 
a1f9			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a1f9				 
a1f9				; TODO need to convert word to upper case 
a1f9			 
a1f9			ucasetok:	 
a1f9 7e				ld a,(hl) 
a1fa cd f7 90			call toUpper 
a1fd 77				ld (hl),a 
a1fe ed a0			ldi 
a200 f2 f9 a1		 	jp p, ucasetok 
a203			 
a203			 
a203			 
a203				; de now points to start of where the word body code should be placed 
a203 ed 53 49 e4		ld (os_new_work_ptr), de 
a207				; hl now points to the words to throw at forthexec which needs to be copied 
a207 22 47 e4			ld (os_new_src_ptr), hl 
a20a			 
a20a				; TODO add 'call to forthexec' 
a20a			 
a20a			if DEBUG_FORTH_UWORD 
a20a c5				push bc 
a20b ed 4b 4f e4		ld bc, (os_new_malloc) 
a20f						DMARK ":0x" 
a20f f5				push af  
a210 3a 24 a2			ld a, (.dmark)  
a213 32 b7 ee			ld (debug_mark),a  
a216 3a 25 a2			ld a, (.dmark+1)  
a219 32 b8 ee			ld (debug_mark+1),a  
a21c 3a 26 a2			ld a, (.dmark+2)  
a21f 32 b9 ee			ld (debug_mark+2),a  
a222 18 03			jr .pastdmark  
a224 ..			.dmark: db ":0x"  
a227 f1			.pastdmark: pop af  
a228			endm  
# End of macro DMARK
a228				CALLMONITOR 
a228 cd a3 94			call break_point_state  
a22b				endm  
# End of macro CALLMONITOR
a22b c1				pop bc 
a22c			endif 
a22c			 
a22c			 
a22c				; create word preamble which should be: 
a22c			 
a22c			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a22c			 
a22c				;    ld hl, <word code> 
a22c				;    jp user_exec 
a22c			        ;    <word code bytes> 
a22c			 
a22c			 
a22c			;	inc de     ; TODO ??? or are we already past the word's null 
a22c eb				ex de, hl 
a22d			 
a22d 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a22f			 
a22f 23				inc hl 
a230 22 43 e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a233 23				inc hl 
a234			 
a234 23				inc hl 
a235 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a237			 
a237 01 44 ca			ld bc, user_exec 
a23a 23				inc hl 
a23b 71				ld (hl), c     ; poke address of user_exec 
a23c 23				inc hl 
a23d 70				ld (hl), b     
a23e			 ; 
a23e			;	inc hl 
a23e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a23e			; 
a23e			; 
a23e			;	ld bc, macro_forth_rsp_next 
a23e			;	inc hl 
a23e			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a23e			;	inc hl 
a23e			;	ld (hl), b     
a23e			 ; 
a23e			;	inc hl 
a23e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a23e			; 
a23e			; 
a23e			;	inc hl 
a23e			;	ld bc, forthexec 
a23e			;	ld (hl), c     ; poke address of forthexec 
a23e			;	inc hl 
a23e			;	ld (hl), b      
a23e			; 
a23e			;	inc hl 
a23e			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a23e			; 
a23e			;	ld bc, user_dict_next 
a23e			;	inc hl 
a23e			;	ld (hl), c     ; poke address of forthexec 
a23e			;	inc hl 
a23e			;	ld (hl), b      
a23e			 
a23e				; hl is now where we need to copy the word byte data to save this 
a23e			 
a23e 23				inc hl 
a23f 22 45 e4			ld (os_new_exec), hl 
a242				 
a242				; copy definition 
a242			 
a242 eb				ex de, hl 
a243			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a243			;	inc de    ; skip the PC for this parse 
a243 3a 4d e4			ld a, (os_new_parse_len) 
a246 4f				ld c, a 
a247 06 00			ld b, 0 
a249 ed b0			ldir		 ; copy defintion 
a24b			 
a24b			 
a24b				; poke the address of where the new word bytes live for forthexec 
a24b			 
a24b 2a 43 e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a24e			 
a24e ed 5b 45 e4		ld de, (os_new_exec)      
a252				 
a252 73				ld (hl), e 
a253 23				inc hl 
a254 72				ld (hl), d 
a255			 
a255					; TODO copy last user dict word next link to this word 
a255					; TODO update last user dict word to point to this word 
a255			; 
a255			; hl f923 de 812a ; bc 811a 
a255			 
a255			if DEBUG_FORTH_UWORD 
a255 c5				push bc 
a256 ed 4b 4f e4		ld bc, (os_new_malloc) 
a25a						DMARK ":0A" 
a25a f5				push af  
a25b 3a 6f a2			ld a, (.dmark)  
a25e 32 b7 ee			ld (debug_mark),a  
a261 3a 70 a2			ld a, (.dmark+1)  
a264 32 b8 ee			ld (debug_mark+1),a  
a267 3a 71 a2			ld a, (.dmark+2)  
a26a 32 b9 ee			ld (debug_mark+2),a  
a26d 18 03			jr .pastdmark  
a26f ..			.dmark: db ":0A"  
a272 f1			.pastdmark: pop af  
a273			endm  
# End of macro DMARK
a273				CALLMONITOR 
a273 cd a3 94			call break_point_state  
a276				endm  
# End of macro CALLMONITOR
a276 c1				pop bc 
a277			endif 
a277			if DEBUG_FORTH_UWORD 
a277 c5				push bc 
a278 ed 4b 4f e4		ld bc, (os_new_malloc) 
a27c 03				inc bc 
a27d 03				inc bc 
a27e 03				inc bc 
a27f 03				inc bc 
a280 03				inc bc 
a281 03				inc bc 
a282 03				inc bc 
a283 03				inc bc 
a284			 
a284						DMARK ":0B" 
a284 f5				push af  
a285 3a 99 a2			ld a, (.dmark)  
a288 32 b7 ee			ld (debug_mark),a  
a28b 3a 9a a2			ld a, (.dmark+1)  
a28e 32 b8 ee			ld (debug_mark+1),a  
a291 3a 9b a2			ld a, (.dmark+2)  
a294 32 b9 ee			ld (debug_mark+2),a  
a297 18 03			jr .pastdmark  
a299 ..			.dmark: db ":0B"  
a29c f1			.pastdmark: pop af  
a29d			endm  
# End of macro DMARK
a29d				CALLMONITOR 
a29d cd a3 94			call break_point_state  
a2a0				endm  
# End of macro CALLMONITOR
a2a0 c1				pop bc 
a2a1			endif 
a2a1			 
a2a1			; update word dict linked list for new word 
a2a1			 
a2a1			 
a2a1 2a 4e e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2a4 23			inc hl     ; move to next work linked list ptr 
a2a5			 
a2a5 ed 5b 4f e4	ld de, (os_new_malloc)		 ; new next word 
a2a9 73			ld (hl), e 
a2aa 23			inc hl 
a2ab 72			ld (hl), d 
a2ac			 
a2ac			if DEBUG_FORTH_UWORD 
a2ac ed 4b 4e e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2b0			endif 
a2b0			 
a2b0 ed 53 4e e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a2b4			 
a2b4			 
a2b4			if DEBUG_FORTH_UWORD 
a2b4						DMARK ":0+" 
a2b4 f5				push af  
a2b5 3a c9 a2			ld a, (.dmark)  
a2b8 32 b7 ee			ld (debug_mark),a  
a2bb 3a ca a2			ld a, (.dmark+1)  
a2be 32 b8 ee			ld (debug_mark+1),a  
a2c1 3a cb a2			ld a, (.dmark+2)  
a2c4 32 b9 ee			ld (debug_mark+2),a  
a2c7 18 03			jr .pastdmark  
a2c9 ..			.dmark: db ":0+"  
a2cc f1			.pastdmark: pop af  
a2cd			endm  
# End of macro DMARK
a2cd				CALLMONITOR 
a2cd cd a3 94			call break_point_state  
a2d0				endm  
# End of macro CALLMONITOR
a2d0			endif 
a2d0			 
a2d0				STACKFRAMECHK OFF $8efe $989f 
a2d0				if DEBUG_STACK_IMB 
a2d0					if OFF 
a2d0						exx 
a2d0						ld hl, $989f 
a2d0						pop de   ; $989f 
a2d0						call cmp16 
a2d0						jr nz, .spnosame 
a2d0						ld hl, $8efe 
a2d0						pop de   ; $8efe 
a2d0						call cmp16 
a2d0						jr z, .spfrsame 
a2d0						.spnosame: call showsperror 
a2d0						.spfrsame: nop 
a2d0						exx 
a2d0					endif 
a2d0				endif 
a2d0			endm 
# End of macro STACKFRAMECHK
a2d0			 
a2d0 c9			ret    ; dont process any remaining parser tokens as they form new word 
a2d1			 
a2d1			 
a2d1			 
a2d1			 
a2d1			;		NEXT 
a2d1			.SCOLN: 
a2d1			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a2d1 06				db OPCODE_SCOLN 
a2d2 1d a3			dw .DROP 
a2d4 02				db 2 
a2d5 .. 00			db ";",0           
a2d7			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a2d7					if DEBUG_FORTH_WORDS_KEY 
a2d7						DMARK "SCN" 
a2d7 f5				push af  
a2d8 3a ec a2			ld a, (.dmark)  
a2db 32 b7 ee			ld (debug_mark),a  
a2de 3a ed a2			ld a, (.dmark+1)  
a2e1 32 b8 ee			ld (debug_mark+1),a  
a2e4 3a ee a2			ld a, (.dmark+2)  
a2e7 32 b9 ee			ld (debug_mark+2),a  
a2ea 18 03			jr .pastdmark  
a2ec ..			.dmark: db "SCN"  
a2ef f1			.pastdmark: pop af  
a2f0			endm  
# End of macro DMARK
a2f0						CALLMONITOR 
a2f0 cd a3 94			call break_point_state  
a2f3				endm  
# End of macro CALLMONITOR
a2f3					endif 
a2f3					FORTH_RSP_TOS 
a2f3 cd d2 9a			call macro_forth_rsp_tos 
a2f6				endm 
# End of macro FORTH_RSP_TOS
a2f6 e5					push hl 
a2f7					FORTH_RSP_POP 
a2f7 cd dc 9a			call macro_forth_rsp_pop 
a2fa				endm 
# End of macro FORTH_RSP_POP
a2fa e1					pop hl 
a2fb			;		ex de,hl 
a2fb 22 52 e7				ld (os_tok_ptr),hl 
a2fe			 
a2fe			if DEBUG_FORTH_UWORD 
a2fe						DMARK "SCL" 
a2fe f5				push af  
a2ff 3a 13 a3			ld a, (.dmark)  
a302 32 b7 ee			ld (debug_mark),a  
a305 3a 14 a3			ld a, (.dmark+1)  
a308 32 b8 ee			ld (debug_mark+1),a  
a30b 3a 15 a3			ld a, (.dmark+2)  
a30e 32 b9 ee			ld (debug_mark+2),a  
a311 18 03			jr .pastdmark  
a313 ..			.dmark: db "SCL"  
a316 f1			.pastdmark: pop af  
a317			endm  
# End of macro DMARK
a317				CALLMONITOR 
a317 cd a3 94			call break_point_state  
a31a				endm  
# End of macro CALLMONITOR
a31a			endif 
a31a					NEXTW 
a31a c3 c1 9e			jp macro_next 
a31d				endm 
# End of macro NEXTW
a31d			 
a31d			.DROP: 
a31d				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a31d 1b				db WORD_SYS_CORE+OPCODE_DROP             
a31e 48 a3			dw .DUP2            
a320 05				db 4 + 1 
a321 .. 00			db "DROP",0              
a326				endm 
# End of macro CWHEAD
a326			; | DROP ( w -- )   drop the TOS item   | DONE 
a326					if DEBUG_FORTH_WORDS_KEY 
a326						DMARK "DRP" 
a326 f5				push af  
a327 3a 3b a3			ld a, (.dmark)  
a32a 32 b7 ee			ld (debug_mark),a  
a32d 3a 3c a3			ld a, (.dmark+1)  
a330 32 b8 ee			ld (debug_mark+1),a  
a333 3a 3d a3			ld a, (.dmark+2)  
a336 32 b9 ee			ld (debug_mark+2),a  
a339 18 03			jr .pastdmark  
a33b ..			.dmark: db "DRP"  
a33e f1			.pastdmark: pop af  
a33f			endm  
# End of macro DMARK
a33f						CALLMONITOR 
a33f cd a3 94			call break_point_state  
a342				endm  
# End of macro CALLMONITOR
a342					endif 
a342					FORTH_DSP_POP 
a342 cd c3 9d			call macro_forth_dsp_pop 
a345				endm 
# End of macro FORTH_DSP_POP
a345					NEXTW 
a345 c3 c1 9e			jp macro_next 
a348				endm 
# End of macro NEXTW
a348			.DUP2: 
a348				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a348 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a349 8d a3			dw .DROP2            
a34b 05				db 4 + 1 
a34c .. 00			db "2DUP",0              
a351				endm 
# End of macro CWHEAD
a351			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a351					if DEBUG_FORTH_WORDS_KEY 
a351						DMARK "2DU" 
a351 f5				push af  
a352 3a 66 a3			ld a, (.dmark)  
a355 32 b7 ee			ld (debug_mark),a  
a358 3a 67 a3			ld a, (.dmark+1)  
a35b 32 b8 ee			ld (debug_mark+1),a  
a35e 3a 68 a3			ld a, (.dmark+2)  
a361 32 b9 ee			ld (debug_mark+2),a  
a364 18 03			jr .pastdmark  
a366 ..			.dmark: db "2DU"  
a369 f1			.pastdmark: pop af  
a36a			endm  
# End of macro DMARK
a36a						CALLMONITOR 
a36a cd a3 94			call break_point_state  
a36d				endm  
# End of macro CALLMONITOR
a36d					endif 
a36d					FORTH_DSP_VALUEHL 
a36d cd 0b 9d			call macro_dsp_valuehl 
a370				endm 
# End of macro FORTH_DSP_VALUEHL
a370 e5					push hl      ; 2 
a371			 
a371					FORTH_DSP_POP 
a371 cd c3 9d			call macro_forth_dsp_pop 
a374				endm 
# End of macro FORTH_DSP_POP
a374					 
a374					FORTH_DSP_VALUEHL 
a374 cd 0b 9d			call macro_dsp_valuehl 
a377				endm 
# End of macro FORTH_DSP_VALUEHL
a377			;		push hl      ; 1 
a377			 
a377					FORTH_DSP_POP 
a377 cd c3 9d			call macro_forth_dsp_pop 
a37a				endm 
# End of macro FORTH_DSP_POP
a37a			 
a37a			;		pop hl       ; 1 
a37a d1					pop de       ; 2 
a37b			 
a37b cd 14 9b				call forth_push_numhl 
a37e eb					ex de, hl 
a37f cd 14 9b				call forth_push_numhl 
a382			 
a382					 
a382 eb					ex de, hl 
a383			 
a383 cd 14 9b				call forth_push_numhl 
a386 eb					ex de, hl 
a387 cd 14 9b				call forth_push_numhl 
a38a			 
a38a			 
a38a					NEXTW 
a38a c3 c1 9e			jp macro_next 
a38d				endm 
# End of macro NEXTW
a38d			.DROP2: 
a38d				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a38d 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a38e bc a3			dw .SWAP2            
a390 06				db 5 + 1 
a391 .. 00			db "2DROP",0              
a397				endm 
# End of macro CWHEAD
a397			; | 2DROP ( w w -- )    Double drop | DONE 
a397					if DEBUG_FORTH_WORDS_KEY 
a397						DMARK "2DR" 
a397 f5				push af  
a398 3a ac a3			ld a, (.dmark)  
a39b 32 b7 ee			ld (debug_mark),a  
a39e 3a ad a3			ld a, (.dmark+1)  
a3a1 32 b8 ee			ld (debug_mark+1),a  
a3a4 3a ae a3			ld a, (.dmark+2)  
a3a7 32 b9 ee			ld (debug_mark+2),a  
a3aa 18 03			jr .pastdmark  
a3ac ..			.dmark: db "2DR"  
a3af f1			.pastdmark: pop af  
a3b0			endm  
# End of macro DMARK
a3b0						CALLMONITOR 
a3b0 cd a3 94			call break_point_state  
a3b3				endm  
# End of macro CALLMONITOR
a3b3					endif 
a3b3					FORTH_DSP_POP 
a3b3 cd c3 9d			call macro_forth_dsp_pop 
a3b6				endm 
# End of macro FORTH_DSP_POP
a3b6					FORTH_DSP_POP 
a3b6 cd c3 9d			call macro_forth_dsp_pop 
a3b9				endm 
# End of macro FORTH_DSP_POP
a3b9					NEXTW 
a3b9 c3 c1 9e			jp macro_next 
a3bc				endm 
# End of macro NEXTW
a3bc			.SWAP2: 
a3bc				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3bc 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3bd e5 a3			dw .AT            
a3bf 06				db 5 + 1 
a3c0 .. 00			db "2SWAP",0              
a3c6				endm 
# End of macro CWHEAD
a3c6			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3c6					if DEBUG_FORTH_WORDS_KEY 
a3c6						DMARK "2SW" 
a3c6 f5				push af  
a3c7 3a db a3			ld a, (.dmark)  
a3ca 32 b7 ee			ld (debug_mark),a  
a3cd 3a dc a3			ld a, (.dmark+1)  
a3d0 32 b8 ee			ld (debug_mark+1),a  
a3d3 3a dd a3			ld a, (.dmark+2)  
a3d6 32 b9 ee			ld (debug_mark+2),a  
a3d9 18 03			jr .pastdmark  
a3db ..			.dmark: db "2SW"  
a3de f1			.pastdmark: pop af  
a3df			endm  
# End of macro DMARK
a3df						CALLMONITOR 
a3df cd a3 94			call break_point_state  
a3e2				endm  
# End of macro CALLMONITOR
a3e2					endif 
a3e2					NEXTW 
a3e2 c3 c1 9e			jp macro_next 
a3e5				endm 
# End of macro NEXTW
a3e5			.AT: 
a3e5				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a3e5 1f				db WORD_SYS_CORE+OPCODE_AT             
a3e6 17 a4			dw .CAT            
a3e8 02				db 1 + 1 
a3e9 .. 00			db "@",0              
a3eb				endm 
# End of macro CWHEAD
a3eb			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a3eb			 
a3eb					if DEBUG_FORTH_WORDS_KEY 
a3eb						DMARK "AT." 
a3eb f5				push af  
a3ec 3a 00 a4			ld a, (.dmark)  
a3ef 32 b7 ee			ld (debug_mark),a  
a3f2 3a 01 a4			ld a, (.dmark+1)  
a3f5 32 b8 ee			ld (debug_mark+1),a  
a3f8 3a 02 a4			ld a, (.dmark+2)  
a3fb 32 b9 ee			ld (debug_mark+2),a  
a3fe 18 03			jr .pastdmark  
a400 ..			.dmark: db "AT."  
a403 f1			.pastdmark: pop af  
a404			endm  
# End of macro DMARK
a404						CALLMONITOR 
a404 cd a3 94			call break_point_state  
a407				endm  
# End of macro CALLMONITOR
a407					endif 
a407			.getbyteat:	 
a407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a407 cd 0b 9d			call macro_dsp_valuehl 
a40a				endm 
# End of macro FORTH_DSP_VALUEHL
a40a					 
a40a			;		push hl 
a40a				 
a40a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a40a cd c3 9d			call macro_forth_dsp_pop 
a40d				endm 
# End of macro FORTH_DSP_POP
a40d			 
a40d			;		pop hl 
a40d			 
a40d 7e					ld a, (hl) 
a40e			 
a40e 6f					ld l, a 
a40f 26 00				ld h, 0 
a411 cd 14 9b				call forth_push_numhl 
a414			 
a414					NEXTW 
a414 c3 c1 9e			jp macro_next 
a417				endm 
# End of macro NEXTW
a417			.CAT: 
a417				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a417 20				db WORD_SYS_CORE+OPCODE_CAT             
a418 40 a4			dw .BANG            
a41a 03				db 2 + 1 
a41b .. 00			db "C@",0              
a41e				endm 
# End of macro CWHEAD
a41e			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a41e					if DEBUG_FORTH_WORDS_KEY 
a41e						DMARK "CAA" 
a41e f5				push af  
a41f 3a 33 a4			ld a, (.dmark)  
a422 32 b7 ee			ld (debug_mark),a  
a425 3a 34 a4			ld a, (.dmark+1)  
a428 32 b8 ee			ld (debug_mark+1),a  
a42b 3a 35 a4			ld a, (.dmark+2)  
a42e 32 b9 ee			ld (debug_mark+2),a  
a431 18 03			jr .pastdmark  
a433 ..			.dmark: db "CAA"  
a436 f1			.pastdmark: pop af  
a437			endm  
# End of macro DMARK
a437						CALLMONITOR 
a437 cd a3 94			call break_point_state  
a43a				endm  
# End of macro CALLMONITOR
a43a					endif 
a43a c3 07 a4				jp .getbyteat 
a43d					NEXTW 
a43d c3 c1 9e			jp macro_next 
a440				endm 
# End of macro NEXTW
a440			.BANG: 
a440				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a440 21				db WORD_SYS_CORE+OPCODE_BANG             
a441 76 a4			dw .CBANG            
a443 02				db 1 + 1 
a444 .. 00			db "!",0              
a446				endm 
# End of macro CWHEAD
a446			; | ! ( x w -- ) Store x at address w      | DONE 
a446					if DEBUG_FORTH_WORDS_KEY 
a446						DMARK "BNG" 
a446 f5				push af  
a447 3a 5b a4			ld a, (.dmark)  
a44a 32 b7 ee			ld (debug_mark),a  
a44d 3a 5c a4			ld a, (.dmark+1)  
a450 32 b8 ee			ld (debug_mark+1),a  
a453 3a 5d a4			ld a, (.dmark+2)  
a456 32 b9 ee			ld (debug_mark+2),a  
a459 18 03			jr .pastdmark  
a45b ..			.dmark: db "BNG"  
a45e f1			.pastdmark: pop af  
a45f			endm  
# End of macro DMARK
a45f						CALLMONITOR 
a45f cd a3 94			call break_point_state  
a462				endm  
# End of macro CALLMONITOR
a462					endif 
a462			 
a462			.storebyteat:		 
a462					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a462 cd 0b 9d			call macro_dsp_valuehl 
a465				endm 
# End of macro FORTH_DSP_VALUEHL
a465					 
a465 e5					push hl 
a466				 
a466					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a466 cd c3 9d			call macro_forth_dsp_pop 
a469				endm 
# End of macro FORTH_DSP_POP
a469			 
a469					; get byte to poke 
a469			 
a469					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a469 cd 0b 9d			call macro_dsp_valuehl 
a46c				endm 
# End of macro FORTH_DSP_VALUEHL
a46c e5					push hl 
a46d			 
a46d			 
a46d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a46d cd c3 9d			call macro_forth_dsp_pop 
a470				endm 
# End of macro FORTH_DSP_POP
a470			 
a470			 
a470 d1					pop de 
a471 e1					pop hl 
a472			 
a472 73					ld (hl),e 
a473			 
a473			 
a473					NEXTW 
a473 c3 c1 9e			jp macro_next 
a476				endm 
# End of macro NEXTW
a476			.CBANG: 
a476				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a476 22				db WORD_SYS_CORE+OPCODE_CBANG             
a477 9f a4			dw .SCALL            
a479 03				db 2 + 1 
a47a .. 00			db "C!",0              
a47d				endm 
# End of macro CWHEAD
a47d			; | C!  ( x w -- ) Store x at address w  | DONE 
a47d					if DEBUG_FORTH_WORDS_KEY 
a47d						DMARK "CBA" 
a47d f5				push af  
a47e 3a 92 a4			ld a, (.dmark)  
a481 32 b7 ee			ld (debug_mark),a  
a484 3a 93 a4			ld a, (.dmark+1)  
a487 32 b8 ee			ld (debug_mark+1),a  
a48a 3a 94 a4			ld a, (.dmark+2)  
a48d 32 b9 ee			ld (debug_mark+2),a  
a490 18 03			jr .pastdmark  
a492 ..			.dmark: db "CBA"  
a495 f1			.pastdmark: pop af  
a496			endm  
# End of macro DMARK
a496						CALLMONITOR 
a496 cd a3 94			call break_point_state  
a499				endm  
# End of macro CALLMONITOR
a499					endif 
a499 c3 62 a4				jp .storebyteat 
a49c					NEXTW 
a49c c3 c1 9e			jp macro_next 
a49f				endm 
# End of macro NEXTW
a49f			.SCALL: 
a49f				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a49f 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4a0 d3 a4			dw .DEPTH            
a4a2 05				db 4 + 1 
a4a3 .. 00			db "CALL",0              
a4a8				endm 
# End of macro CWHEAD
a4a8			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4a8					if DEBUG_FORTH_WORDS_KEY 
a4a8						DMARK "CLL" 
a4a8 f5				push af  
a4a9 3a bd a4			ld a, (.dmark)  
a4ac 32 b7 ee			ld (debug_mark),a  
a4af 3a be a4			ld a, (.dmark+1)  
a4b2 32 b8 ee			ld (debug_mark+1),a  
a4b5 3a bf a4			ld a, (.dmark+2)  
a4b8 32 b9 ee			ld (debug_mark+2),a  
a4bb 18 03			jr .pastdmark  
a4bd ..			.dmark: db "CLL"  
a4c0 f1			.pastdmark: pop af  
a4c1			endm  
# End of macro DMARK
a4c1						CALLMONITOR 
a4c1 cd a3 94			call break_point_state  
a4c4				endm  
# End of macro CALLMONITOR
a4c4					endif 
a4c4			 
a4c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c4 cd 0b 9d			call macro_dsp_valuehl 
a4c7				endm 
# End of macro FORTH_DSP_VALUEHL
a4c7			 
a4c7			;		push hl 
a4c7			 
a4c7					; destroy value TOS 
a4c7			 
a4c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4c7 cd c3 9d			call macro_forth_dsp_pop 
a4ca				endm 
# End of macro FORTH_DSP_POP
a4ca			 
a4ca						 
a4ca			;		pop hl 
a4ca			 
a4ca					; how to do a call with hl???? save SP? 
a4ca cd 65 9e				call forth_call_hl 
a4cd			 
a4cd			 
a4cd					; TODO push value back onto stack for another op etc 
a4cd			 
a4cd cd 14 9b				call forth_push_numhl 
a4d0					NEXTW 
a4d0 c3 c1 9e			jp macro_next 
a4d3				endm 
# End of macro NEXTW
a4d3			.DEPTH: 
a4d3				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a4d3 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a4d4 10 a5			dw .OVER            
a4d6 06				db 5 + 1 
a4d7 .. 00			db "DEPTH",0              
a4dd				endm 
# End of macro CWHEAD
a4dd			; | DEPTH ( -- u ) Push count of stack | DONE 
a4dd					; take current TOS and remove from base value div by two to get count 
a4dd					if DEBUG_FORTH_WORDS_KEY 
a4dd						DMARK "DEP" 
a4dd f5				push af  
a4de 3a f2 a4			ld a, (.dmark)  
a4e1 32 b7 ee			ld (debug_mark),a  
a4e4 3a f3 a4			ld a, (.dmark+1)  
a4e7 32 b8 ee			ld (debug_mark+1),a  
a4ea 3a f4 a4			ld a, (.dmark+2)  
a4ed 32 b9 ee			ld (debug_mark+2),a  
a4f0 18 03			jr .pastdmark  
a4f2 ..			.dmark: db "DEP"  
a4f5 f1			.pastdmark: pop af  
a4f6			endm  
# End of macro DMARK
a4f6						CALLMONITOR 
a4f6 cd a3 94			call break_point_state  
a4f9				endm  
# End of macro CALLMONITOR
a4f9					endif 
a4f9			 
a4f9			 
a4f9 2a 7e eb			ld hl, (cli_data_sp) 
a4fc 11 b8 e9			ld de, cli_data_stack 
a4ff ed 52			sbc hl,de 
a501				 
a501				; div by size of stack item 
a501			 
a501 5d				ld e,l 
a502 0e 03			ld c, 3 
a504 cd 32 8c			call Div8 
a507			 
a507 6f				ld l,a 
a508 26 00			ld h,0 
a50a			 
a50a				;srl h 
a50a				;rr l 
a50a			 
a50a cd 14 9b				call forth_push_numhl 
a50d					NEXTW 
a50d c3 c1 9e			jp macro_next 
a510				endm 
# End of macro NEXTW
a510			.OVER: 
a510				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a510 42				db WORD_SYS_CORE+46             
a511 57 a5			dw .PAUSE            
a513 05				db 4 + 1 
a514 .. 00			db "OVER",0              
a519				endm 
# End of macro CWHEAD
a519			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a519					if DEBUG_FORTH_WORDS_KEY 
a519						DMARK "OVR" 
a519 f5				push af  
a51a 3a 2e a5			ld a, (.dmark)  
a51d 32 b7 ee			ld (debug_mark),a  
a520 3a 2f a5			ld a, (.dmark+1)  
a523 32 b8 ee			ld (debug_mark+1),a  
a526 3a 30 a5			ld a, (.dmark+2)  
a529 32 b9 ee			ld (debug_mark+2),a  
a52c 18 03			jr .pastdmark  
a52e ..			.dmark: db "OVR"  
a531 f1			.pastdmark: pop af  
a532			endm  
# End of macro DMARK
a532						CALLMONITOR 
a532 cd a3 94			call break_point_state  
a535				endm  
# End of macro CALLMONITOR
a535					endif 
a535			 
a535					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a535 cd 0b 9d			call macro_dsp_valuehl 
a538				endm 
# End of macro FORTH_DSP_VALUEHL
a538 e5					push hl    ; n2 
a539					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a539 cd c3 9d			call macro_forth_dsp_pop 
a53c				endm 
# End of macro FORTH_DSP_POP
a53c			 
a53c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a53c cd 0b 9d			call macro_dsp_valuehl 
a53f				endm 
# End of macro FORTH_DSP_VALUEHL
a53f e5					push hl    ; n1 
a540					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a540 cd c3 9d			call macro_forth_dsp_pop 
a543				endm 
# End of macro FORTH_DSP_POP
a543			 
a543 d1					pop de     ; n1 
a544 e1					pop hl     ; n2 
a545			 
a545 d5					push de 
a546 e5					push hl 
a547 d5					push de 
a548			 
a548					; push back  
a548			 
a548 e1					pop hl 
a549 cd 14 9b				call forth_push_numhl 
a54c e1					pop hl 
a54d cd 14 9b				call forth_push_numhl 
a550 e1					pop hl 
a551 cd 14 9b				call forth_push_numhl 
a554					NEXTW 
a554 c3 c1 9e			jp macro_next 
a557				endm 
# End of macro NEXTW
a557			 
a557			.PAUSE: 
a557				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a557 43				db WORD_SYS_CORE+47             
a558 8c a5			dw .PAUSES            
a55a 08				db 7 + 1 
a55b .. 00			db "PAUSEMS",0              
a563				endm 
# End of macro CWHEAD
a563			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a563					if DEBUG_FORTH_WORDS_KEY 
a563						DMARK "PMS" 
a563 f5				push af  
a564 3a 78 a5			ld a, (.dmark)  
a567 32 b7 ee			ld (debug_mark),a  
a56a 3a 79 a5			ld a, (.dmark+1)  
a56d 32 b8 ee			ld (debug_mark+1),a  
a570 3a 7a a5			ld a, (.dmark+2)  
a573 32 b9 ee			ld (debug_mark+2),a  
a576 18 03			jr .pastdmark  
a578 ..			.dmark: db "PMS"  
a57b f1			.pastdmark: pop af  
a57c			endm  
# End of macro DMARK
a57c						CALLMONITOR 
a57c cd a3 94			call break_point_state  
a57f				endm  
# End of macro CALLMONITOR
a57f					endif 
a57f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a57f cd 0b 9d			call macro_dsp_valuehl 
a582				endm 
# End of macro FORTH_DSP_VALUEHL
a582			;		push hl    ; n2 
a582					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a582 cd c3 9d			call macro_forth_dsp_pop 
a585				endm 
# End of macro FORTH_DSP_POP
a585			;		pop hl 
a585			 
a585 7d					ld a, l 
a586 cd d7 89				call aDelayInMS 
a589				       NEXTW 
a589 c3 c1 9e			jp macro_next 
a58c				endm 
# End of macro NEXTW
a58c			.PAUSES:  
a58c				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a58c 44				db WORD_SYS_CORE+48             
a58d fb a5			dw .ROT            
a58f 06				db 5 + 1 
a590 .. 00			db "PAUSE",0              
a596				endm 
# End of macro CWHEAD
a596			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a596					if DEBUG_FORTH_WORDS_KEY 
a596						DMARK "PAU" 
a596 f5				push af  
a597 3a ab a5			ld a, (.dmark)  
a59a 32 b7 ee			ld (debug_mark),a  
a59d 3a ac a5			ld a, (.dmark+1)  
a5a0 32 b8 ee			ld (debug_mark+1),a  
a5a3 3a ad a5			ld a, (.dmark+2)  
a5a6 32 b9 ee			ld (debug_mark+2),a  
a5a9 18 03			jr .pastdmark  
a5ab ..			.dmark: db "PAU"  
a5ae f1			.pastdmark: pop af  
a5af			endm  
# End of macro DMARK
a5af						CALLMONITOR 
a5af cd a3 94			call break_point_state  
a5b2				endm  
# End of macro CALLMONITOR
a5b2					endif 
a5b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b2 cd 0b 9d			call macro_dsp_valuehl 
a5b5				endm 
# End of macro FORTH_DSP_VALUEHL
a5b5			;		push hl    ; n2 
a5b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b5 cd c3 9d			call macro_forth_dsp_pop 
a5b8				endm 
# End of macro FORTH_DSP_POP
a5b8			;		pop hl 
a5b8 45					ld b, l 
a5b9					if DEBUG_FORTH_WORDS 
a5b9						DMARK "PAU" 
a5b9 f5				push af  
a5ba 3a ce a5			ld a, (.dmark)  
a5bd 32 b7 ee			ld (debug_mark),a  
a5c0 3a cf a5			ld a, (.dmark+1)  
a5c3 32 b8 ee			ld (debug_mark+1),a  
a5c6 3a d0 a5			ld a, (.dmark+2)  
a5c9 32 b9 ee			ld (debug_mark+2),a  
a5cc 18 03			jr .pastdmark  
a5ce ..			.dmark: db "PAU"  
a5d1 f1			.pastdmark: pop af  
a5d2			endm  
# End of macro DMARK
a5d2						CALLMONITOR 
a5d2 cd a3 94			call break_point_state  
a5d5				endm  
# End of macro CALLMONITOR
a5d5					endif 
a5d5 c5			.pauses1:	push bc 
a5d6 cd f2 89				call delay1s 
a5d9 c1					pop bc 
a5da					if DEBUG_FORTH_WORDS 
a5da						DMARK "PA1" 
a5da f5				push af  
a5db 3a ef a5			ld a, (.dmark)  
a5de 32 b7 ee			ld (debug_mark),a  
a5e1 3a f0 a5			ld a, (.dmark+1)  
a5e4 32 b8 ee			ld (debug_mark+1),a  
a5e7 3a f1 a5			ld a, (.dmark+2)  
a5ea 32 b9 ee			ld (debug_mark+2),a  
a5ed 18 03			jr .pastdmark  
a5ef ..			.dmark: db "PA1"  
a5f2 f1			.pastdmark: pop af  
a5f3			endm  
# End of macro DMARK
a5f3						CALLMONITOR 
a5f3 cd a3 94			call break_point_state  
a5f6				endm  
# End of macro CALLMONITOR
a5f6					endif 
a5f6 10 dd				djnz .pauses1 
a5f8			 
a5f8				       NEXTW 
a5f8 c3 c1 9e			jp macro_next 
a5fb				endm 
# End of macro NEXTW
a5fb			.ROT: 
a5fb				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a5fb 45				db WORD_SYS_CORE+49             
a5fc 49 a6			dw .UWORDS            
a5fe 04				db 3 + 1 
a5ff .. 00			db "ROT",0              
a603				endm 
# End of macro CWHEAD
a603			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a603					if DEBUG_FORTH_WORDS_KEY 
a603						DMARK "ROT" 
a603 f5				push af  
a604 3a 18 a6			ld a, (.dmark)  
a607 32 b7 ee			ld (debug_mark),a  
a60a 3a 19 a6			ld a, (.dmark+1)  
a60d 32 b8 ee			ld (debug_mark+1),a  
a610 3a 1a a6			ld a, (.dmark+2)  
a613 32 b9 ee			ld (debug_mark+2),a  
a616 18 03			jr .pastdmark  
a618 ..			.dmark: db "ROT"  
a61b f1			.pastdmark: pop af  
a61c			endm  
# End of macro DMARK
a61c						CALLMONITOR 
a61c cd a3 94			call break_point_state  
a61f				endm  
# End of macro CALLMONITOR
a61f					endif 
a61f			 
a61f					FORTH_DSP_VALUEHL 
a61f cd 0b 9d			call macro_dsp_valuehl 
a622				endm 
# End of macro FORTH_DSP_VALUEHL
a622 e5					push hl    ; u3  
a623			 
a623					FORTH_DSP_POP 
a623 cd c3 9d			call macro_forth_dsp_pop 
a626				endm 
# End of macro FORTH_DSP_POP
a626			   
a626					FORTH_DSP_VALUEHL 
a626 cd 0b 9d			call macro_dsp_valuehl 
a629				endm 
# End of macro FORTH_DSP_VALUEHL
a629 e5					push hl     ; u2 
a62a			 
a62a					FORTH_DSP_POP 
a62a cd c3 9d			call macro_forth_dsp_pop 
a62d				endm 
# End of macro FORTH_DSP_POP
a62d			 
a62d					FORTH_DSP_VALUEHL 
a62d cd 0b 9d			call macro_dsp_valuehl 
a630				endm 
# End of macro FORTH_DSP_VALUEHL
a630 e5					push hl     ; u1 
a631			 
a631					FORTH_DSP_POP 
a631 cd c3 9d			call macro_forth_dsp_pop 
a634				endm 
# End of macro FORTH_DSP_POP
a634			 
a634 c1					pop bc      ; u1 
a635 e1					pop hl      ; u2 
a636 d1					pop de      ; u3 
a637			 
a637			 
a637 c5					push bc 
a638 d5					push de 
a639 e5					push hl 
a63a			 
a63a			 
a63a e1					pop hl 
a63b cd 14 9b				call forth_push_numhl 
a63e			 
a63e e1					pop hl 
a63f cd 14 9b				call forth_push_numhl 
a642			 
a642 e1					pop hl 
a643 cd 14 9b				call forth_push_numhl 
a646					 
a646			 
a646			 
a646			 
a646			 
a646			 
a646				       NEXTW 
a646 c3 c1 9e			jp macro_next 
a649				endm 
# End of macro NEXTW
a649			 
a649			.UWORDS: 
a649				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a649 50				db WORD_SYS_CORE+60             
a64a 0b a7			dw .BP            
a64c 07				db 6 + 1 
a64d .. 00			db "UWORDS",0              
a654				endm 
# End of macro CWHEAD
a654			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a654			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a654			; | | Following the count are the individual words. 
a654			; | | 
a654			; | | e.g. UWORDS 
a654			; | | BOX DIRLIST 2 
a654			; | |  
a654			; | | Can be used to save the words to storage via: 
a654			; | | UWORDS $01 DO $01 APPEND LOOP 
a654				if DEBUG_FORTH_WORDS_KEY 
a654					DMARK "UWR" 
a654 f5				push af  
a655 3a 69 a6			ld a, (.dmark)  
a658 32 b7 ee			ld (debug_mark),a  
a65b 3a 6a a6			ld a, (.dmark+1)  
a65e 32 b8 ee			ld (debug_mark+1),a  
a661 3a 6b a6			ld a, (.dmark+2)  
a664 32 b9 ee			ld (debug_mark+2),a  
a667 18 03			jr .pastdmark  
a669 ..			.dmark: db "UWR"  
a66c f1			.pastdmark: pop af  
a66d			endm  
# End of macro DMARK
a66d					CALLMONITOR 
a66d cd a3 94			call break_point_state  
a670				endm  
# End of macro CALLMONITOR
a670				endif 
a670 21 d3 e1				ld hl, baseram 
a673					;ld hl, baseusermem 
a673 01 00 00				ld bc, 0    ; start a counter 
a676			 
a676				; skip dict stub 
a676			 
a676 cd 12 a0				call forth_tok_next 
a679			 
a679			 
a679			; while we have words to look for 
a679			 
a679 7e			.douscan:	ld a, (hl)      
a67a				if DEBUG_FORTH_WORDS 
a67a					DMARK "UWs" 
a67a f5				push af  
a67b 3a 8f a6			ld a, (.dmark)  
a67e 32 b7 ee			ld (debug_mark),a  
a681 3a 90 a6			ld a, (.dmark+1)  
a684 32 b8 ee			ld (debug_mark+1),a  
a687 3a 91 a6			ld a, (.dmark+2)  
a68a 32 b9 ee			ld (debug_mark+2),a  
a68d 18 03			jr .pastdmark  
a68f ..			.dmark: db "UWs"  
a692 f1			.pastdmark: pop af  
a693			endm  
# End of macro DMARK
a693					CALLMONITOR 
a693 cd a3 94			call break_point_state  
a696				endm  
# End of macro CALLMONITOR
a696				endif 
a696 fe 00				cp WORD_SYS_END 
a698 28 4d				jr z, .udone 
a69a fe 01				cp WORD_SYS_UWORD 
a69c 20 44				jr nz, .nuword 
a69e			 
a69e				if DEBUG_FORTH_WORDS 
a69e					DMARK "UWu" 
a69e f5				push af  
a69f 3a b3 a6			ld a, (.dmark)  
a6a2 32 b7 ee			ld (debug_mark),a  
a6a5 3a b4 a6			ld a, (.dmark+1)  
a6a8 32 b8 ee			ld (debug_mark+1),a  
a6ab 3a b5 a6			ld a, (.dmark+2)  
a6ae 32 b9 ee			ld (debug_mark+2),a  
a6b1 18 03			jr .pastdmark  
a6b3 ..			.dmark: db "UWu"  
a6b6 f1			.pastdmark: pop af  
a6b7			endm  
# End of macro DMARK
a6b7					CALLMONITOR 
a6b7 cd a3 94			call break_point_state  
a6ba				endm  
# End of macro CALLMONITOR
a6ba				endif 
a6ba					; we have a uword so push its name to the stack 
a6ba			 
a6ba e5				   	push hl  ; save so we can move to next dict block 
a6bb			 
a6bb					; skip opcode 
a6bb 23					inc hl  
a6bc					; skip next ptr 
a6bc 23					inc hl  
a6bd 23					inc hl 
a6be					; skip len 
a6be 23					inc hl 
a6bf				if DEBUG_FORTH_WORDS 
a6bf					DMARK "UWt" 
a6bf f5				push af  
a6c0 3a d4 a6			ld a, (.dmark)  
a6c3 32 b7 ee			ld (debug_mark),a  
a6c6 3a d5 a6			ld a, (.dmark+1)  
a6c9 32 b8 ee			ld (debug_mark+1),a  
a6cc 3a d6 a6			ld a, (.dmark+2)  
a6cf 32 b9 ee			ld (debug_mark+2),a  
a6d2 18 03			jr .pastdmark  
a6d4 ..			.dmark: db "UWt"  
a6d7 f1			.pastdmark: pop af  
a6d8			endm  
# End of macro DMARK
a6d8					CALLMONITOR 
a6d8 cd a3 94			call break_point_state  
a6db				endm  
# End of macro CALLMONITOR
a6db				endif 
a6db 03					inc bc 
a6dc			 
a6dc c5					push bc 
a6dd cd 82 9b				call forth_push_str 
a6e0 c1					pop bc 
a6e1			 
a6e1 e1					pop hl 	 
a6e2			 
a6e2 cd 12 a0		.nuword:	call forth_tok_next 
a6e5 18 92				jr .douscan  
a6e7			 
a6e7			.udone:		 ; push count of uwords found 
a6e7 c5					push bc 
a6e8 e1					pop hl 
a6e9			 
a6e9				if DEBUG_FORTH_WORDS 
a6e9					DMARK "UWc" 
a6e9 f5				push af  
a6ea 3a fe a6			ld a, (.dmark)  
a6ed 32 b7 ee			ld (debug_mark),a  
a6f0 3a ff a6			ld a, (.dmark+1)  
a6f3 32 b8 ee			ld (debug_mark+1),a  
a6f6 3a 00 a7			ld a, (.dmark+2)  
a6f9 32 b9 ee			ld (debug_mark+2),a  
a6fc 18 03			jr .pastdmark  
a6fe ..			.dmark: db "UWc"  
a701 f1			.pastdmark: pop af  
a702			endm  
# End of macro DMARK
a702					CALLMONITOR 
a702 cd a3 94			call break_point_state  
a705				endm  
# End of macro CALLMONITOR
a705				endif 
a705 cd 14 9b				call forth_push_numhl 
a708			 
a708			 
a708				       NEXTW 
a708 c3 c1 9e			jp macro_next 
a70b				endm 
# End of macro NEXTW
a70b			 
a70b			.BP: 
a70b				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a70b 54				db WORD_SYS_CORE+64             
a70c 41 a7			dw .MONITOR            
a70e 03				db 2 + 1 
a70f .. 00			db "BP",0              
a712				endm 
# End of macro CWHEAD
a712			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a712			; | | $00 Will enable the break points within specific code paths 
a712			; | | $01 Will disable break points 
a712			; | |  
a712			; | | By default break points are off. Either the above can be used to enable them 
a712			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a712			; | | and on release of the pressed key a message will be disaplayed to notify 
a712			; | | that break points are enabled. Pressing any key will then continue boot process. 
a712					; get byte count 
a712					if DEBUG_FORTH_WORDS_KEY 
a712						DMARK "BP." 
a712 f5				push af  
a713 3a 27 a7			ld a, (.dmark)  
a716 32 b7 ee			ld (debug_mark),a  
a719 3a 28 a7			ld a, (.dmark+1)  
a71c 32 b8 ee			ld (debug_mark+1),a  
a71f 3a 29 a7			ld a, (.dmark+2)  
a722 32 b9 ee			ld (debug_mark+2),a  
a725 18 03			jr .pastdmark  
a727 ..			.dmark: db "BP."  
a72a f1			.pastdmark: pop af  
a72b			endm  
# End of macro DMARK
a72b						CALLMONITOR 
a72b cd a3 94			call break_point_state  
a72e				endm  
# End of macro CALLMONITOR
a72e					endif 
a72e			 
a72e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a72e cd 0b 9d			call macro_dsp_valuehl 
a731				endm 
# End of macro FORTH_DSP_VALUEHL
a731			 
a731			;		push hl 
a731			 
a731					; destroy value TOS 
a731			 
a731					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a731 cd c3 9d			call macro_forth_dsp_pop 
a734				endm 
# End of macro FORTH_DSP_POP
a734			 
a734			;		pop hl 
a734			 
a734 3e 00				ld a,0 
a736 bd					cp l 
a737 28 02				jr z, .bpset 
a739 3e 2a				ld a, '*' 
a73b			 
a73b 32 42 e4		.bpset:		ld (os_view_disable), a 
a73e			 
a73e			 
a73e					NEXTW 
a73e c3 c1 9e			jp macro_next 
a741				endm 
# End of macro NEXTW
a741			 
a741			 
a741			.MONITOR: 
a741				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a741 55				db WORD_SYS_CORE+65             
a742 74 a7			dw .MALLOC            
a744 08				db 7 + 1 
a745 .. 00			db "MONITOR",0              
a74d				endm 
# End of macro CWHEAD
a74d			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a74d			; | | At start the current various registers will be displayed with contents. 
a74d			; | | Top right corner will show the most recent debug marker seen. 
a74d			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a74d			; | | and the return stack pointer (RSP). 
a74d			; | | Pressing: 
a74d			; | |    1 - Initial screen 
a74d			; | |    2 - Display a data dump of HL 
a74d			; | |    3 - Display a data dump of DE 
a74d			; | |    4 - Display a data dump of BC 
a74d			; | |    5 - Display a data dump of HL 
a74d			; | |    6 - Display a data dump of DSP 
a74d			; | |    7 - Display a data dump of RSP 
a74d			; | |    8 - Display a data dump of what is at DSP 
a74d			; | |    9 - Display a data dump of what is at RSP 
a74d			; | |    0 - Exit monitor and continue running. This will also enable break points 
a74d			; | |    * - Disable break points 
a74d			; | |    # - Enter traditional monitor mode 
a74d			; | | 
a74d			; | | Monitor Mode 
a74d			; | | ------------ 
a74d			; | | A prompt of '>' will be shown for various commands: 
a74d			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a74d			; | |    C - Continue display a data dump from the last set address 
a74d			; | |    M xxxx - Set start of memory edit at address xx 
a74d			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a74d			; | |    Q - Return to previous 
a74d					if DEBUG_FORTH_WORDS_KEY 
a74d						DMARK "MON" 
a74d f5				push af  
a74e 3a 62 a7			ld a, (.dmark)  
a751 32 b7 ee			ld (debug_mark),a  
a754 3a 63 a7			ld a, (.dmark+1)  
a757 32 b8 ee			ld (debug_mark+1),a  
a75a 3a 64 a7			ld a, (.dmark+2)  
a75d 32 b9 ee			ld (debug_mark+2),a  
a760 18 03			jr .pastdmark  
a762 ..			.dmark: db "MON"  
a765 f1			.pastdmark: pop af  
a766			endm  
# End of macro DMARK
a766						CALLMONITOR 
a766 cd a3 94			call break_point_state  
a769				endm  
# End of macro CALLMONITOR
a769					endif 
a769 3e 00				ld a, 0 
a76b 32 42 e4				ld (os_view_disable), a 
a76e			 
a76e					CALLMONITOR 
a76e cd a3 94			call break_point_state  
a771				endm  
# End of macro CALLMONITOR
a771			 
a771			;	call monitor 
a771			 
a771					NEXTW 
a771 c3 c1 9e			jp macro_next 
a774				endm 
# End of macro NEXTW
a774			 
a774			 
a774			.MALLOC: 
a774				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a774 56				db WORD_SYS_CORE+66             
a775 9d a7			dw .MALLOC2            
a777 06				db 5 + 1 
a778 .. 00			db "ALLOT",0              
a77e				endm 
# End of macro CWHEAD
a77e			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a77e					if DEBUG_FORTH_WORDS_KEY 
a77e						DMARK "ALL" 
a77e f5				push af  
a77f 3a 93 a7			ld a, (.dmark)  
a782 32 b7 ee			ld (debug_mark),a  
a785 3a 94 a7			ld a, (.dmark+1)  
a788 32 b8 ee			ld (debug_mark+1),a  
a78b 3a 95 a7			ld a, (.dmark+2)  
a78e 32 b9 ee			ld (debug_mark+2),a  
a791 18 03			jr .pastdmark  
a793 ..			.dmark: db "ALL"  
a796 f1			.pastdmark: pop af  
a797			endm  
# End of macro DMARK
a797						CALLMONITOR 
a797 cd a3 94			call break_point_state  
a79a				endm  
# End of macro CALLMONITOR
a79a					endif 
a79a c3 c4 a7				jp .mallocc 
a79d			.MALLOC2: 
a79d				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a79d 56				db WORD_SYS_CORE+66             
a79e db a7			dw .FREE            
a7a0 07				db 6 + 1 
a7a1 .. 00			db "MALLOC",0              
a7a8				endm 
# End of macro CWHEAD
a7a8			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7a8					; get byte count 
a7a8					if DEBUG_FORTH_WORDS_KEY 
a7a8						DMARK "MAL" 
a7a8 f5				push af  
a7a9 3a bd a7			ld a, (.dmark)  
a7ac 32 b7 ee			ld (debug_mark),a  
a7af 3a be a7			ld a, (.dmark+1)  
a7b2 32 b8 ee			ld (debug_mark+1),a  
a7b5 3a bf a7			ld a, (.dmark+2)  
a7b8 32 b9 ee			ld (debug_mark+2),a  
a7bb 18 03			jr .pastdmark  
a7bd ..			.dmark: db "MAL"  
a7c0 f1			.pastdmark: pop af  
a7c1			endm  
# End of macro DMARK
a7c1						CALLMONITOR 
a7c1 cd a3 94			call break_point_state  
a7c4				endm  
# End of macro CALLMONITOR
a7c4					endif 
a7c4			.mallocc: 
a7c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7c4 cd 0b 9d			call macro_dsp_valuehl 
a7c7				endm 
# End of macro FORTH_DSP_VALUEHL
a7c7			 
a7c7			;		push hl 
a7c7			 
a7c7					; destroy value TOS 
a7c7			 
a7c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7c7 cd c3 9d			call macro_forth_dsp_pop 
a7ca				endm 
# End of macro FORTH_DSP_POP
a7ca			 
a7ca			;		pop hl 
a7ca cd 69 91				call malloc 
a7cd				if DEBUG_FORTH_MALLOC_GUARD 
a7cd f5					push af 
a7ce cd cb 8c				call ishlzero 
a7d1			;		ld a, l 
a7d1			;		add h 
a7d1			;		cp 0 
a7d1 f1					pop af 
a7d2					 
a7d2 cc 16 cb				call z,malloc_error 
a7d5				endif 
a7d5			 
a7d5 cd 14 9b				call forth_push_numhl 
a7d8					NEXTW 
a7d8 c3 c1 9e			jp macro_next 
a7db				endm 
# End of macro NEXTW
a7db			 
a7db			.FREE: 
a7db				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a7db 57				db WORD_SYS_CORE+67             
a7dc 0c a8			dw .LIST            
a7de 05				db 4 + 1 
a7df .. 00			db "FREE",0              
a7e4				endm 
# End of macro CWHEAD
a7e4			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a7e4					if DEBUG_FORTH_WORDS_KEY 
a7e4						DMARK "FRE" 
a7e4 f5				push af  
a7e5 3a f9 a7			ld a, (.dmark)  
a7e8 32 b7 ee			ld (debug_mark),a  
a7eb 3a fa a7			ld a, (.dmark+1)  
a7ee 32 b8 ee			ld (debug_mark+1),a  
a7f1 3a fb a7			ld a, (.dmark+2)  
a7f4 32 b9 ee			ld (debug_mark+2),a  
a7f7 18 03			jr .pastdmark  
a7f9 ..			.dmark: db "FRE"  
a7fc f1			.pastdmark: pop af  
a7fd			endm  
# End of macro DMARK
a7fd						CALLMONITOR 
a7fd cd a3 94			call break_point_state  
a800				endm  
# End of macro CALLMONITOR
a800					endif 
a800					; get address 
a800			 
a800					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a800 cd 0b 9d			call macro_dsp_valuehl 
a803				endm 
# End of macro FORTH_DSP_VALUEHL
a803			 
a803			;		push hl 
a803			 
a803					; destroy value TOS 
a803			 
a803					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a803 cd c3 9d			call macro_forth_dsp_pop 
a806				endm 
# End of macro FORTH_DSP_POP
a806			 
a806			;		pop hl 
a806			if FORTH_ENABLE_MALLOCFREE 
a806 cd 33 92				call free 
a809			endif 
a809					NEXTW 
a809 c3 c1 9e			jp macro_next 
a80c				endm 
# End of macro NEXTW
a80c			.LIST: 
a80c				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a80c 5c				db WORD_SYS_CORE+72             
a80d fa a9			dw .FORGET            
a80f 05				db 4 + 1 
a810 .. 00			db "LIST",0              
a815				endm 
# End of macro CWHEAD
a815			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a815			; | | The quoted word must be in upper case. 
a815				if DEBUG_FORTH_WORDS_KEY 
a815					DMARK "LST" 
a815 f5				push af  
a816 3a 2a a8			ld a, (.dmark)  
a819 32 b7 ee			ld (debug_mark),a  
a81c 3a 2b a8			ld a, (.dmark+1)  
a81f 32 b8 ee			ld (debug_mark+1),a  
a822 3a 2c a8			ld a, (.dmark+2)  
a825 32 b9 ee			ld (debug_mark+2),a  
a828 18 03			jr .pastdmark  
a82a ..			.dmark: db "LST"  
a82d f1			.pastdmark: pop af  
a82e			endm  
# End of macro DMARK
a82e					CALLMONITOR 
a82e cd a3 94			call break_point_state  
a831				endm  
# End of macro CALLMONITOR
a831				endif 
a831			 
a831					FORTH_DSP_VALUEHL 
a831 cd 0b 9d			call macro_dsp_valuehl 
a834				endm 
# End of macro FORTH_DSP_VALUEHL
a834			 
a834 e5					push hl 
a835					FORTH_DSP_POP 
a835 cd c3 9d			call macro_forth_dsp_pop 
a838				endm 
# End of macro FORTH_DSP_POP
a838 c1					pop bc 
a839			 
a839			; Start format of scratch string 
a839			 
a839 21 51 e4				ld hl, scratch 
a83c			 
a83c 3e 3a				ld a, ':' 
a83e 77					ld (hl),a 
a83f 23					inc hl 
a840 3e 20				ld a, ' ' 
a842 77					ld (hl), a 
a843			 
a843					; Get ptr to the word we need to look up 
a843			 
a843			;		FORTH_DSP_VALUEHL 
a843					;v5 FORTH_DSP_VALUE 
a843				; TODO type check 
a843			;		inc hl    ; Skip type check  
a843			;		push hl 
a843			;		ex de, hl    ; put into DE 
a843			 
a843			 
a843 21 d3 e1				ld hl, baseram 
a846					;ld hl, baseusermem 
a846			 
a846 e5			push hl   ; sacreifical push 
a847			 
a847			.ldouscanm: 
a847 e1				pop hl 
a848			.ldouscan: 
a848				if DEBUG_FORTH_WORDS 
a848					DMARK "LSs" 
a848 f5				push af  
a849 3a 5d a8			ld a, (.dmark)  
a84c 32 b7 ee			ld (debug_mark),a  
a84f 3a 5e a8			ld a, (.dmark+1)  
a852 32 b8 ee			ld (debug_mark+1),a  
a855 3a 5f a8			ld a, (.dmark+2)  
a858 32 b9 ee			ld (debug_mark+2),a  
a85b 18 03			jr .pastdmark  
a85d ..			.dmark: db "LSs"  
a860 f1			.pastdmark: pop af  
a861			endm  
# End of macro DMARK
a861					CALLMONITOR 
a861 cd a3 94			call break_point_state  
a864				endm  
# End of macro CALLMONITOR
a864				endif 
a864				; skip dict stub 
a864 cd 12 a0				call forth_tok_next 
a867			 
a867			 
a867			; while we have words to look for 
a867			 
a867 7e				ld a, (hl)      
a868				if DEBUG_FORTH_WORDS 
a868					DMARK "LSk" 
a868 f5				push af  
a869 3a 7d a8			ld a, (.dmark)  
a86c 32 b7 ee			ld (debug_mark),a  
a86f 3a 7e a8			ld a, (.dmark+1)  
a872 32 b8 ee			ld (debug_mark+1),a  
a875 3a 7f a8			ld a, (.dmark+2)  
a878 32 b9 ee			ld (debug_mark+2),a  
a87b 18 03			jr .pastdmark  
a87d ..			.dmark: db "LSk"  
a880 f1			.pastdmark: pop af  
a881			endm  
# End of macro DMARK
a881					CALLMONITOR 
a881 cd a3 94			call break_point_state  
a884				endm  
# End of macro CALLMONITOR
a884				endif 
a884					;cp WORD_SYS_END 
a884					;jp z, .lunotfound 
a884			 
a884					; if we hit non uwords then gone too far 
a884 fe 01				cp WORD_SYS_UWORD 
a886 c2 b6 a9				jp nz, .lunotfound 
a889			 
a889				if DEBUG_FORTH_WORDS 
a889					DMARK "LSu" 
a889 f5				push af  
a88a 3a 9e a8			ld a, (.dmark)  
a88d 32 b7 ee			ld (debug_mark),a  
a890 3a 9f a8			ld a, (.dmark+1)  
a893 32 b8 ee			ld (debug_mark+1),a  
a896 3a a0 a8			ld a, (.dmark+2)  
a899 32 b9 ee			ld (debug_mark+2),a  
a89c 18 03			jr .pastdmark  
a89e ..			.dmark: db "LSu"  
a8a1 f1			.pastdmark: pop af  
a8a2			endm  
# End of macro DMARK
a8a2					CALLMONITOR 
a8a2 cd a3 94			call break_point_state  
a8a5				endm  
# End of macro CALLMONITOR
a8a5				endif 
a8a5			 
a8a5					; found a uword but is it the one we want... 
a8a5			 
a8a5 c5					push bc     ; uword to find is on bc 
a8a6 d1					pop de 
a8a7			 
a8a7 e5					push hl  ; to save the ptr 
a8a8			 
a8a8					; skip opcode 
a8a8 23					inc hl  
a8a9					; skip next ptr 
a8a9 23					inc hl  
a8aa 23					inc hl 
a8ab					; skip len 
a8ab 23					inc hl 
a8ac			 
a8ac				if DEBUG_FORTH_WORDS 
a8ac					DMARK "LSc" 
a8ac f5				push af  
a8ad 3a c1 a8			ld a, (.dmark)  
a8b0 32 b7 ee			ld (debug_mark),a  
a8b3 3a c2 a8			ld a, (.dmark+1)  
a8b6 32 b8 ee			ld (debug_mark+1),a  
a8b9 3a c3 a8			ld a, (.dmark+2)  
a8bc 32 b9 ee			ld (debug_mark+2),a  
a8bf 18 03			jr .pastdmark  
a8c1 ..			.dmark: db "LSc"  
a8c4 f1			.pastdmark: pop af  
a8c5			endm  
# End of macro DMARK
a8c5					CALLMONITOR 
a8c5 cd a3 94			call break_point_state  
a8c8				endm  
# End of macro CALLMONITOR
a8c8				endif 
a8c8 cd 38 91				call strcmp 
a8cb c2 47 a8				jp nz, .ldouscanm 
a8ce				 
a8ce			 
a8ce			 
a8ce					; we have a uword so push its name to the stack 
a8ce			 
a8ce			;	   	push hl  ; save so we can move to next dict block 
a8ce e1			pop hl 
a8cf			 
a8cf				if DEBUG_FORTH_WORDS 
a8cf					DMARK "LSm" 
a8cf f5				push af  
a8d0 3a e4 a8			ld a, (.dmark)  
a8d3 32 b7 ee			ld (debug_mark),a  
a8d6 3a e5 a8			ld a, (.dmark+1)  
a8d9 32 b8 ee			ld (debug_mark+1),a  
a8dc 3a e6 a8			ld a, (.dmark+2)  
a8df 32 b9 ee			ld (debug_mark+2),a  
a8e2 18 03			jr .pastdmark  
a8e4 ..			.dmark: db "LSm"  
a8e7 f1			.pastdmark: pop af  
a8e8			endm  
# End of macro DMARK
a8e8					CALLMONITOR 
a8e8 cd a3 94			call break_point_state  
a8eb				endm  
# End of macro CALLMONITOR
a8eb				endif 
a8eb			 
a8eb					; skip opcode 
a8eb 23					inc hl  
a8ec					; skip next ptr 
a8ec 23					inc hl  
a8ed 23					inc hl 
a8ee					; skip len 
a8ee 7e					ld a, (hl)   ; save length to add 
a8ef				if DEBUG_FORTH_WORDS 
a8ef					DMARK "LS2" 
a8ef f5				push af  
a8f0 3a 04 a9			ld a, (.dmark)  
a8f3 32 b7 ee			ld (debug_mark),a  
a8f6 3a 05 a9			ld a, (.dmark+1)  
a8f9 32 b8 ee			ld (debug_mark+1),a  
a8fc 3a 06 a9			ld a, (.dmark+2)  
a8ff 32 b9 ee			ld (debug_mark+2),a  
a902 18 03			jr .pastdmark  
a904 ..			.dmark: db "LS2"  
a907 f1			.pastdmark: pop af  
a908			endm  
# End of macro DMARK
a908					CALLMONITOR 
a908 cd a3 94			call break_point_state  
a90b				endm  
# End of macro CALLMONITOR
a90b				endif 
a90b			 
a90b					; save this location 
a90b				 
a90b e5					push hl 
a90c			 
a90c 23					inc hl 
a90d 11 53 e4				ld de, scratch+2 
a910 4f					ld c, a 
a911 06 00				ld b, 0 
a913			 
a913				if DEBUG_FORTH_WORDS 
a913					DMARK "LSn" 
a913 f5				push af  
a914 3a 28 a9			ld a, (.dmark)  
a917 32 b7 ee			ld (debug_mark),a  
a91a 3a 29 a9			ld a, (.dmark+1)  
a91d 32 b8 ee			ld (debug_mark+1),a  
a920 3a 2a a9			ld a, (.dmark+2)  
a923 32 b9 ee			ld (debug_mark+2),a  
a926 18 03			jr .pastdmark  
a928 ..			.dmark: db "LSn"  
a92b f1			.pastdmark: pop af  
a92c			endm  
# End of macro DMARK
a92c					CALLMONITOR 
a92c cd a3 94			call break_point_state  
a92f				endm  
# End of macro CALLMONITOR
a92f				endif 
a92f			 
a92f					; copy uword name to scratch 
a92f			 
a92f ed b0				ldir 
a931			 
a931 1b					dec de 
a932 3e 20				ld a, ' '    ; change null to space 
a934 12					ld (de), a 
a935			 
a935 13					inc de 
a936			 
a936 d5					push de 
a937 c1					pop bc     ; move scratch pointer to end of word name and save it 
a938			 
a938 e1					pop hl 
a939 7e					ld a, (hl) 
a93a					;inc hl 
a93a					; skip word string 
a93a cd a2 8c				call addatohl 
a93d			 
a93d 23					inc hl 
a93e			 
a93e				if DEBUG_FORTH_WORDS 
a93e					DMARK "LS3" 
a93e f5				push af  
a93f 3a 53 a9			ld a, (.dmark)  
a942 32 b7 ee			ld (debug_mark),a  
a945 3a 54 a9			ld a, (.dmark+1)  
a948 32 b8 ee			ld (debug_mark+1),a  
a94b 3a 55 a9			ld a, (.dmark+2)  
a94e 32 b9 ee			ld (debug_mark+2),a  
a951 18 03			jr .pastdmark  
a953 ..			.dmark: db "LS3"  
a956 f1			.pastdmark: pop af  
a957			endm  
# End of macro DMARK
a957					CALLMONITOR 
a957 cd a3 94			call break_point_state  
a95a				endm  
# End of macro CALLMONITOR
a95a				endif 
a95a					; should now be at the start of the machine code to setup the eval of the uword 
a95a					; now locate the ptr to the string defintion 
a95a			 
a95a					; skip ld hl, 
a95a					; then load the ptr 
a95a			; TODO use get from hl ptr 
a95a 23					inc hl 
a95b 5e					ld e, (hl) 
a95c 23					inc hl 
a95d 56					ld d, (hl) 
a95e eb					ex de, hl 
a95f			 
a95f			 
a95f				if DEBUG_FORTH_WORDS 
a95f					DMARK "LSt" 
a95f f5				push af  
a960 3a 74 a9			ld a, (.dmark)  
a963 32 b7 ee			ld (debug_mark),a  
a966 3a 75 a9			ld a, (.dmark+1)  
a969 32 b8 ee			ld (debug_mark+1),a  
a96c 3a 76 a9			ld a, (.dmark+2)  
a96f 32 b9 ee			ld (debug_mark+2),a  
a972 18 03			jr .pastdmark  
a974 ..			.dmark: db "LSt"  
a977 f1			.pastdmark: pop af  
a978			endm  
# End of macro DMARK
a978					CALLMONITOR 
a978 cd a3 94			call break_point_state  
a97b				endm  
# End of macro CALLMONITOR
a97b				endif 
a97b			 
a97b			; cant push right now due to tokenised strings  
a97b			 
a97b			; get the destination of where to copy this definition to. 
a97b			 
a97b c5					push bc 
a97c d1					pop de 
a97d			 
a97d 7e			.listl:         ld a,(hl) 
a97e fe 00				cp 0 
a980 28 09				jr z, .lreplsp     ; replace zero with space 
a982					;cp FORTH_END_BUFFER 
a982 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a984 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a986				 
a986					; just copy this char as is then 
a986			 
a986 12					ld (de), a 
a987			 
a987 23			.listnxt:	inc hl 
a988 13					inc de 
a989 18 f2				jr .listl 
a98b			 
a98b 3e 20		.lreplsp:	ld a,' ' 
a98d 12					ld (de), a 
a98e 18 f7				jr .listnxt 
a990			 
a990			; close up uword def 
a990			 
a990			.listdone: 
a990 12					ld (de), a 
a991 13					inc de 
a992 3e 00				ld a, 0 
a994 12					ld (de), a 
a995			 
a995			; now have def so clean up and push to stack 
a995			 
a995 21 51 e4				ld hl, scratch 
a998				if DEBUG_FORTH_WORDS 
a998					DMARK "Ltp" 
a998 f5				push af  
a999 3a ad a9			ld a, (.dmark)  
a99c 32 b7 ee			ld (debug_mark),a  
a99f 3a ae a9			ld a, (.dmark+1)  
a9a2 32 b8 ee			ld (debug_mark+1),a  
a9a5 3a af a9			ld a, (.dmark+2)  
a9a8 32 b9 ee			ld (debug_mark+2),a  
a9ab 18 03			jr .pastdmark  
a9ad ..			.dmark: db "Ltp"  
a9b0 f1			.pastdmark: pop af  
a9b1			endm  
# End of macro DMARK
a9b1					CALLMONITOR 
a9b1 cd a3 94			call break_point_state  
a9b4				endm  
# End of macro CALLMONITOR
a9b4				endif 
a9b4			 
a9b4 18 1f			jr .listpush 
a9b6			 
a9b6			;.lnuword:	pop hl 
a9b6			;		call forth_tok_next 
a9b6			;		jp .ldouscan  
a9b6			 
a9b6			.lunotfound:		  
a9b6			 
a9b6				if DEBUG_FORTH_WORDS 
a9b6					DMARK "LSn" 
a9b6 f5				push af  
a9b7 3a cb a9			ld a, (.dmark)  
a9ba 32 b7 ee			ld (debug_mark),a  
a9bd 3a cc a9			ld a, (.dmark+1)  
a9c0 32 b8 ee			ld (debug_mark+1),a  
a9c3 3a cd a9			ld a, (.dmark+2)  
a9c6 32 b9 ee			ld (debug_mark+2),a  
a9c9 18 03			jr .pastdmark  
a9cb ..			.dmark: db "LSn"  
a9ce f1			.pastdmark: pop af  
a9cf			endm  
# End of macro DMARK
a9cf					CALLMONITOR 
a9cf cd a3 94			call break_point_state  
a9d2				endm  
# End of macro CALLMONITOR
a9d2				endif 
a9d2			 
a9d2					 
a9d2			;		FORTH_DSP_POP 
a9d2			;		ld hl, .luno 
a9d2			 
a9d2					NEXTW			 
a9d2 c3 c1 9e			jp macro_next 
a9d5				endm 
# End of macro NEXTW
a9d5			 
a9d5			.listpush: 
a9d5				if DEBUG_FORTH_WORDS 
a9d5					DMARK "LS>" 
a9d5 f5				push af  
a9d6 3a ea a9			ld a, (.dmark)  
a9d9 32 b7 ee			ld (debug_mark),a  
a9dc 3a eb a9			ld a, (.dmark+1)  
a9df 32 b8 ee			ld (debug_mark+1),a  
a9e2 3a ec a9			ld a, (.dmark+2)  
a9e5 32 b9 ee			ld (debug_mark+2),a  
a9e8 18 03			jr .pastdmark  
a9ea ..			.dmark: db "LS>"  
a9ed f1			.pastdmark: pop af  
a9ee			endm  
# End of macro DMARK
a9ee					CALLMONITOR 
a9ee cd a3 94			call break_point_state  
a9f1				endm  
# End of macro CALLMONITOR
a9f1				endif 
a9f1 cd 82 9b				call forth_push_str 
a9f4			 
a9f4			 
a9f4			 
a9f4					NEXTW 
a9f4 c3 c1 9e			jp macro_next 
a9f7				endm 
# End of macro NEXTW
a9f7			 
a9f7			;.luno:    db "Word not found",0 
a9f7			 
a9f7			 
a9f7			 
a9f7			 
a9f7			 
a9f7			;		push hl   ; save pointer to start of uword def string 
a9f7			; 
a9f7			;; look for FORTH_EOL_LINE 
a9f7			;		ld a, FORTH_END_BUFFER 
a9f7			;		call strlent 
a9f7			; 
a9f7			;		inc hl		 ; space for coln def 
a9f7			;		inc hl 
a9f7			;		inc hl          ; space for terms 
a9f7			;		inc hl 
a9f7			; 
a9f7			;		ld a, 20   ; TODO get actual length 
a9f7			;		call addatohl    ; include a random amount of room for the uword name 
a9f7			; 
a9f7			;		 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt1" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;		 
a9f7			; 
a9f7			;; malloc space for the string because we cant change it 
a9f7			; 
a9f7			;		call malloc 
a9f7			;	if DEBUG_FORTH_MALLOC_GUARD 
a9f7			;		push af 
a9f7			;		call ishlzero 
a9f7			;		pop af 
a9f7			;		 
a9f7			;		call z,malloc_error 
a9f7			;	endif 
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt2" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;		pop de 
a9f7			;		push hl    ; push the malloc to release later 
a9f7			;		push hl   ;  push back a copy for the later stack push 
a9f7			;		 
a9f7			;; copy the string swapping out the zero terms for spaces 
a9f7			; 
a9f7			;		; de has our source 
a9f7			;		; hl has our dest 
a9f7			; 
a9f7			;; add the coln def 
a9f7			; 
a9f7			;		ld a, ':' 
a9f7			;		ld (hl), a 
a9f7			;		inc hl 
a9f7			;		ld a, ' ' 
a9f7			;		ld (hl), a 
a9f7			;		inc hl 
a9f7			; 
a9f7			;; add the uname word 
a9f7			;		push de   ; save our string for now 
a9f7			;		ex de, hl 
a9f7			; 
a9f7			;		FORTH_DSP_VALUE 
a9f7			;		;v5 FORTH_DSP_VALUE 
a9f7			; 
a9f7			;		inc hl   ; skip type but we know by now this is OK 
a9f7			; 
a9f7			;.luword:	ld a,(hl) 
a9f7			;		cp 0 
a9f7			;		jr z, .luword2 
a9f7			;		ld (de), a 
a9f7			;		inc de 
a9f7			;		inc hl 
a9f7			;		jr .luword 
a9f7			; 
a9f7			;.luword2:	ld a, ' ' 
a9f7			;		ld (de), a 
a9f7			;;		inc hl 
a9f7			;;		inc de 
a9f7			;;		ld (de), a 
a9f7			;;		inc hl 
a9f7			;		inc de 
a9f7			; 
a9f7			;		ex de, hl 
a9f7			;		pop de 
a9f7			;		 
a9f7			;		 
a9f7			; 
a9f7			;; detoken that string and copy it 
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt2" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;.ldetok:	ld a, (de) 
a9f7			;		cp FORTH_END_BUFFER 
a9f7			;		jr z, .ldetokend 
a9f7			;		; swap out any zero term for space 
a9f7			;		cp 0 
a9f7			;		jr nz, .ldetoknext 
a9f7			;		ld a, ' ' 
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "LtS" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;.ldetoknext:	ld (hl), a 
a9f7			;		inc de 
a9f7			;		inc hl 
a9f7			;		jr .ldetok 
a9f7			; 
a9f7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a9f7			;		ld (hl), a  
a9f7			; 
a9f7			;; free that temp malloc 
a9f7			; 
a9f7			;		pop hl    
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt4" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;		call forth_apushstrhl 
a9f7			; 
a9f7			;		; get rid of temp malloc area 
a9f7			; 
a9f7			;		pop hl 
a9f7			;		call free 
a9f7			; 
a9f7			;		jr .ludone 
a9f7			; 
a9f7			;.lnuword:	pop hl 
a9f7			;		call forth_tok_next 
a9f7			;		jp .ldouscan  
a9f7			; 
a9f7			;.ludone:		 pop hl 
a9f7			; 
a9f7					NEXTW 
a9f7 c3 c1 9e			jp macro_next 
a9fa				endm 
# End of macro NEXTW
a9fa			 
a9fa			.FORGET: 
a9fa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a9fa 5d				db WORD_SYS_CORE+73             
a9fb 73 aa			dw .NOP            
a9fd 07				db 6 + 1 
a9fe .. 00			db "FORGET",0              
aa05				endm 
# End of macro CWHEAD
aa05			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa05			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa05			; | |  
aa05			; | | e.g. "MORE" forget 
aa05					if DEBUG_FORTH_WORDS_KEY 
aa05						DMARK "FRG" 
aa05 f5				push af  
aa06 3a 1a aa			ld a, (.dmark)  
aa09 32 b7 ee			ld (debug_mark),a  
aa0c 3a 1b aa			ld a, (.dmark+1)  
aa0f 32 b8 ee			ld (debug_mark+1),a  
aa12 3a 1c aa			ld a, (.dmark+2)  
aa15 32 b9 ee			ld (debug_mark+2),a  
aa18 18 03			jr .pastdmark  
aa1a ..			.dmark: db "FRG"  
aa1d f1			.pastdmark: pop af  
aa1e			endm  
# End of macro DMARK
aa1e						CALLMONITOR 
aa1e cd a3 94			call break_point_state  
aa21				endm  
# End of macro CALLMONITOR
aa21					endif 
aa21			 
aa21				; find uword 
aa21			        ; update start of word with "_" 
aa21				; replace uword with deleted flag 
aa21			 
aa21			 
aa21			;	if DEBUG_FORTH_WORDS 
aa21			;		DMARK "FOG" 
aa21			;		CALLMONITOR 
aa21			;	endif 
aa21			 
aa21			 
aa21					; Get ptr to the word we need to look up 
aa21			 
aa21					FORTH_DSP_VALUEHL 
aa21 cd 0b 9d			call macro_dsp_valuehl 
aa24				endm 
# End of macro FORTH_DSP_VALUEHL
aa24					;v5 FORTH_DSP_VALUE 
aa24				; TODO type check 
aa24			;		inc hl    ; Skip type check  
aa24 e5					push hl 
aa25 c1					pop bc 
aa26			;		ex de, hl    ; put into DE 
aa26			 
aa26			 
aa26 21 d3 e1				ld hl, baseram 
aa29					;ld hl, baseusermem 
aa29			 
aa29				; skip dict stub 
aa29			;	call forth_tok_next 
aa29 e5			push hl   ; sacreifical push 
aa2a			 
aa2a			.fldouscanm: 
aa2a e1				pop hl 
aa2b			.fldouscan: 
aa2b			;	if DEBUG_FORTH_WORDS 
aa2b			;		DMARK "LSs" 
aa2b			;		CALLMONITOR 
aa2b			;	endif 
aa2b				; skip dict stub 
aa2b cd 12 a0				call forth_tok_next 
aa2e			 
aa2e			 
aa2e			; while we have words to look for 
aa2e			 
aa2e 7e				ld a, (hl)      
aa2f			;	if DEBUG_FORTH_WORDS 
aa2f			;		DMARK "LSk" 
aa2f			;		CALLMONITOR 
aa2f			;	endif 
aa2f fe 00				cp WORD_SYS_END 
aa31 ca 6d aa				jp z, .flunotfound 
aa34 fe 01				cp WORD_SYS_UWORD 
aa36 c2 2b aa				jp nz, .fldouscan 
aa39			 
aa39			;	if DEBUG_FORTH_WORDS 
aa39			;		DMARK "LSu" 
aa39			;		CALLMONITOR 
aa39			;	endif 
aa39			 
aa39					; found a uword but is it the one we want... 
aa39			 
aa39 c5					push bc     ; uword to find is on bc 
aa3a d1					pop de 
aa3b			 
aa3b e5					push hl  ; to save the ptr 
aa3c			 
aa3c					; skip opcode 
aa3c 23					inc hl  
aa3d					; skip next ptr 
aa3d 23					inc hl  
aa3e 23					inc hl 
aa3f					; skip len 
aa3f 23					inc hl 
aa40			 
aa40			;	if DEBUG_FORTH_WORDS 
aa40			;		DMARK "LSc" 
aa40			;		CALLMONITOR 
aa40			;	endif 
aa40 cd 38 91				call strcmp 
aa43 c2 2a aa				jp nz, .fldouscanm 
aa46			; 
aa46			; 
aa46			;; while we have words to look for 
aa46			; 
aa46			;.fdouscan:	ld a, (hl)      
aa46			;	if DEBUG_FORTH_WORDS 
aa46			;		DMARK "LSs" 
aa46			;		CALLMONITOR 
aa46			;	endif 
aa46			;		cp WORD_SYS_END 
aa46			;		jp z, .fudone 
aa46			;		cp WORD_SYS_UWORD 
aa46			;		jp nz, .fnuword 
aa46			; 
aa46			;	if DEBUG_FORTH_WORDS 
aa46			;		DMARK "FGu" 
aa46			;		CALLMONITOR 
aa46			;	endif 
aa46			; 
aa46			;		; found a uword but is it the one we want... 
aa46			; 
aa46			; 
aa46			;	        pop de   ; get back the dsp name 
aa46			;		push de 
aa46			; 
aa46			;		push hl  ; to save the ptr 
aa46			; 
aa46			;		; skip opcode 
aa46			;		inc hl  
aa46			;		; skip next ptr 
aa46			;		inc hl  
aa46			;		inc hl 
aa46			;		; skip len 
aa46			;		inc hl 
aa46			; 
aa46			;	if DEBUG_FORTH_WORDS 
aa46			;		DMARK "FGc" 
aa46			;		CALLMONITOR 
aa46			;	endif 
aa46			;		call strcmp 
aa46			;		jp nz, .fnuword 
aa46			 
aa46			 
aa46 e1			pop hl 
aa47			 
aa47				 
aa47				if DEBUG_FORTH_WORDS 
aa47					DMARK "FGm" 
aa47 f5				push af  
aa48 3a 5c aa			ld a, (.dmark)  
aa4b 32 b7 ee			ld (debug_mark),a  
aa4e 3a 5d aa			ld a, (.dmark+1)  
aa51 32 b8 ee			ld (debug_mark+1),a  
aa54 3a 5e aa			ld a, (.dmark+2)  
aa57 32 b9 ee			ld (debug_mark+2),a  
aa5a 18 03			jr .pastdmark  
aa5c ..			.dmark: db "FGm"  
aa5f f1			.pastdmark: pop af  
aa60			endm  
# End of macro DMARK
aa60					CALLMONITOR 
aa60 cd a3 94			call break_point_state  
aa63				endm  
# End of macro CALLMONITOR
aa63				endif 
aa63			 
aa63			 
aa63			 
aa63					; we have a uword so push its name to the stack 
aa63			 
aa63			;	   	push hl  ; save so we can move to next dict block 
aa63			;pop hl 
aa63			 
aa63					; update opcode to deleted 
aa63 3e 03				ld a, WORD_SYS_DELETED 
aa65 77					ld (hl), a 
aa66			 
aa66 23					inc hl  
aa67					; skip next ptr 
aa67 23					inc hl  
aa68 23					inc hl 
aa69					; skip len 
aa69 23					inc hl 
aa6a			 
aa6a					; TODO change parser to skip deleted words but for now mark it out 
aa6a 3e 5f				ld a, "_" 
aa6c 77					ld  (hl),a 
aa6d			 
aa6d			;		jr .fudone 
aa6d			; 
aa6d			;.fnuword:	pop hl 
aa6d			;		call forth_tok_next 
aa6d			;		jp .fdouscan  
aa6d			 
aa6d			.flunotfound:		  
aa6d			 
aa6d			 
aa6d					 
aa6d					FORTH_DSP_POP 
aa6d cd c3 9d			call macro_forth_dsp_pop 
aa70				endm 
# End of macro FORTH_DSP_POP
aa70			;		ld hl, .luno 
aa70			;.fudone:		 pop hl 
aa70					NEXTW 
aa70 c3 c1 9e			jp macro_next 
aa73				endm 
# End of macro NEXTW
aa73			.NOP: 
aa73				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa73 61				db WORD_SYS_CORE+77             
aa74 9a aa			dw .COMO            
aa76 04				db 3 + 1 
aa77 .. 00			db "NOP",0              
aa7b				endm 
# End of macro CWHEAD
aa7b			; | NOP (  --  ) Do nothing | DONE 
aa7b					if DEBUG_FORTH_WORDS_KEY 
aa7b						DMARK "NOP" 
aa7b f5				push af  
aa7c 3a 90 aa			ld a, (.dmark)  
aa7f 32 b7 ee			ld (debug_mark),a  
aa82 3a 91 aa			ld a, (.dmark+1)  
aa85 32 b8 ee			ld (debug_mark+1),a  
aa88 3a 92 aa			ld a, (.dmark+2)  
aa8b 32 b9 ee			ld (debug_mark+2),a  
aa8e 18 03			jr .pastdmark  
aa90 ..			.dmark: db "NOP"  
aa93 f1			.pastdmark: pop af  
aa94			endm  
# End of macro DMARK
aa94						CALLMONITOR 
aa94 cd a3 94			call break_point_state  
aa97				endm  
# End of macro CALLMONITOR
aa97					endif 
aa97				       NEXTW 
aa97 c3 c1 9e			jp macro_next 
aa9a				endm 
# End of macro NEXTW
aa9a			.COMO: 
aa9a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa9a 6e				db WORD_SYS_CORE+90             
aa9b ec aa			dw .COMC            
aa9d 02				db 1 + 1 
aa9e .. 00			db "(",0              
aaa0				endm 
# End of macro CWHEAD
aaa0			; | ( ( -- )  Start of comment | DONE 
aaa0			 
aaa0			 
aaa0 2a 52 e7				ld hl, ( os_tok_ptr) 
aaa3 11 e7 aa			ld de, .closepar 
aaa6					 
aaa6					if DEBUG_FORTH_WORDS 
aaa6						DMARK ").." 
aaa6 f5				push af  
aaa7 3a bb aa			ld a, (.dmark)  
aaaa 32 b7 ee			ld (debug_mark),a  
aaad 3a bc aa			ld a, (.dmark+1)  
aab0 32 b8 ee			ld (debug_mark+1),a  
aab3 3a bd aa			ld a, (.dmark+2)  
aab6 32 b9 ee			ld (debug_mark+2),a  
aab9 18 03			jr .pastdmark  
aabb ..			.dmark: db ").."  
aabe f1			.pastdmark: pop af  
aabf			endm  
# End of macro DMARK
aabf						CALLMONITOR 
aabf cd a3 94			call break_point_state  
aac2				endm  
# End of macro CALLMONITOR
aac2					endif 
aac2 cd dc 9f			call findnexttok  
aac5			 
aac5					if DEBUG_FORTH_WORDS 
aac5						DMARK "IF5" 
aac5 f5				push af  
aac6 3a da aa			ld a, (.dmark)  
aac9 32 b7 ee			ld (debug_mark),a  
aacc 3a db aa			ld a, (.dmark+1)  
aacf 32 b8 ee			ld (debug_mark+1),a  
aad2 3a dc aa			ld a, (.dmark+2)  
aad5 32 b9 ee			ld (debug_mark+2),a  
aad8 18 03			jr .pastdmark  
aada ..			.dmark: db "IF5"  
aadd f1			.pastdmark: pop af  
aade			endm  
# End of macro DMARK
aade						CALLMONITOR 
aade cd a3 94			call break_point_state  
aae1				endm  
# End of macro CALLMONITOR
aae1					endif 
aae1				; replace below with ) exec using tok_ptr 
aae1 22 52 e7			ld (os_tok_ptr), hl 
aae4 c3 52 9f			jp exec1 
aae7			 
aae7 .. 00			.closepar:   db ")",0 
aae9			 
aae9				       NEXTW 
aae9 c3 c1 9e			jp macro_next 
aaec				endm 
# End of macro NEXTW
aaec			.COMC: 
aaec				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aaec 6f				db WORD_SYS_CORE+91             
aaed f5 aa			dw .SCRATCH            
aaef 02				db 1 + 1 
aaf0 .. 00			db ")",0              
aaf2				endm 
# End of macro CWHEAD
aaf2			; | ) ( -- )  End of comment |  DONE  
aaf2				       NEXTW 
aaf2 c3 c1 9e			jp macro_next 
aaf5				endm 
# End of macro NEXTW
aaf5			 
aaf5			.SCRATCH: 
aaf5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aaf5 6f				db WORD_SYS_CORE+91             
aaf6 30 ab			dw .INC            
aaf8 08				db 7 + 1 
aaf9 .. 00			db "SCRATCH",0              
ab01				endm 
# End of macro CWHEAD
ab01			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab01			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab01			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab01			; | |  
ab01			; | | e.g.    : score $00 scratch ; 
ab01			; | |  
ab01			; | | $00 score ! 
ab01			; | | $01 score +! 
ab01			; | |  
ab01			; | | e.g.   : varword $0a scratch ;  
ab01			; | | 
ab01			; | | $8000 varword ! 
ab01					if DEBUG_FORTH_WORDS_KEY 
ab01						DMARK "SCR" 
ab01 f5				push af  
ab02 3a 16 ab			ld a, (.dmark)  
ab05 32 b7 ee			ld (debug_mark),a  
ab08 3a 17 ab			ld a, (.dmark+1)  
ab0b 32 b8 ee			ld (debug_mark+1),a  
ab0e 3a 18 ab			ld a, (.dmark+2)  
ab11 32 b9 ee			ld (debug_mark+2),a  
ab14 18 03			jr .pastdmark  
ab16 ..			.dmark: db "SCR"  
ab19 f1			.pastdmark: pop af  
ab1a			endm  
# End of macro DMARK
ab1a						CALLMONITOR 
ab1a cd a3 94			call break_point_state  
ab1d				endm  
# End of macro CALLMONITOR
ab1d					endif 
ab1d			 
ab1d					FORTH_DSP_VALUEHL 
ab1d cd 0b 9d			call macro_dsp_valuehl 
ab20				endm 
# End of macro FORTH_DSP_VALUEHL
ab20				 
ab20					FORTH_DSP_POP 
ab20 cd c3 9d			call macro_forth_dsp_pop 
ab23				endm 
# End of macro FORTH_DSP_POP
ab23			 
ab23 7d					ld a, l 
ab24 21 76 e9				ld hl, os_var_array 
ab27 cd a2 8c				call addatohl 
ab2a			 
ab2a cd 14 9b				call forth_push_numhl 
ab2d			 
ab2d				       NEXTW 
ab2d c3 c1 9e			jp macro_next 
ab30				endm 
# End of macro NEXTW
ab30			 
ab30			.INC: 
ab30				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab30 6f				db WORD_SYS_CORE+91             
ab31 84 ab			dw .DEC            
ab33 03				db 2 + 1 
ab34 .. 00			db "+!",0              
ab37				endm 
# End of macro CWHEAD
ab37			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab37					if DEBUG_FORTH_WORDS_KEY 
ab37						DMARK "+s_" 
ab37 f5				push af  
ab38 3a 4c ab			ld a, (.dmark)  
ab3b 32 b7 ee			ld (debug_mark),a  
ab3e 3a 4d ab			ld a, (.dmark+1)  
ab41 32 b8 ee			ld (debug_mark+1),a  
ab44 3a 4e ab			ld a, (.dmark+2)  
ab47 32 b9 ee			ld (debug_mark+2),a  
ab4a 18 03			jr .pastdmark  
ab4c ..			.dmark: db "+s_"  
ab4f f1			.pastdmark: pop af  
ab50			endm  
# End of macro DMARK
ab50						CALLMONITOR 
ab50 cd a3 94			call break_point_state  
ab53				endm  
# End of macro CALLMONITOR
ab53					endif 
ab53			 
ab53					FORTH_DSP_VALUEHL 
ab53 cd 0b 9d			call macro_dsp_valuehl 
ab56				endm 
# End of macro FORTH_DSP_VALUEHL
ab56			 
ab56 e5					push hl   ; save address 
ab57			 
ab57					FORTH_DSP_POP 
ab57 cd c3 9d			call macro_forth_dsp_pop 
ab5a				endm 
# End of macro FORTH_DSP_POP
ab5a			 
ab5a					FORTH_DSP_VALUEHL 
ab5a cd 0b 9d			call macro_dsp_valuehl 
ab5d				endm 
# End of macro FORTH_DSP_VALUEHL
ab5d			 
ab5d					FORTH_DSP_POP 
ab5d cd c3 9d			call macro_forth_dsp_pop 
ab60				endm 
# End of macro FORTH_DSP_POP
ab60			 
ab60					; hl contains value to add to byte at a 
ab60				 
ab60 eb					ex de, hl 
ab61			 
ab61 e1					pop hl 
ab62			 
ab62					if DEBUG_FORTH_WORDS 
ab62						DMARK "INC" 
ab62 f5				push af  
ab63 3a 77 ab			ld a, (.dmark)  
ab66 32 b7 ee			ld (debug_mark),a  
ab69 3a 78 ab			ld a, (.dmark+1)  
ab6c 32 b8 ee			ld (debug_mark+1),a  
ab6f 3a 79 ab			ld a, (.dmark+2)  
ab72 32 b9 ee			ld (debug_mark+2),a  
ab75 18 03			jr .pastdmark  
ab77 ..			.dmark: db "INC"  
ab7a f1			.pastdmark: pop af  
ab7b			endm  
# End of macro DMARK
ab7b						CALLMONITOR 
ab7b cd a3 94			call break_point_state  
ab7e				endm  
# End of macro CALLMONITOR
ab7e					endif 
ab7e			 
ab7e 7e					ld a,(hl) 
ab7f 83					add e 
ab80 77					ld (hl),a 
ab81			 
ab81			 
ab81			 
ab81				       NEXTW 
ab81 c3 c1 9e			jp macro_next 
ab84				endm 
# End of macro NEXTW
ab84			 
ab84			.DEC: 
ab84				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ab84 6f				db WORD_SYS_CORE+91             
ab85 d5 ab			dw .INC2            
ab87 03				db 2 + 1 
ab88 .. 00			db "-!",0              
ab8b				endm 
# End of macro CWHEAD
ab8b			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab8b					if DEBUG_FORTH_WORDS_KEY 
ab8b						DMARK "-s_" 
ab8b f5				push af  
ab8c 3a a0 ab			ld a, (.dmark)  
ab8f 32 b7 ee			ld (debug_mark),a  
ab92 3a a1 ab			ld a, (.dmark+1)  
ab95 32 b8 ee			ld (debug_mark+1),a  
ab98 3a a2 ab			ld a, (.dmark+2)  
ab9b 32 b9 ee			ld (debug_mark+2),a  
ab9e 18 03			jr .pastdmark  
aba0 ..			.dmark: db "-s_"  
aba3 f1			.pastdmark: pop af  
aba4			endm  
# End of macro DMARK
aba4						CALLMONITOR 
aba4 cd a3 94			call break_point_state  
aba7				endm  
# End of macro CALLMONITOR
aba7					endif 
aba7			 
aba7					FORTH_DSP_VALUEHL 
aba7 cd 0b 9d			call macro_dsp_valuehl 
abaa				endm 
# End of macro FORTH_DSP_VALUEHL
abaa			 
abaa e5					push hl   ; save address 
abab			 
abab					FORTH_DSP_POP 
abab cd c3 9d			call macro_forth_dsp_pop 
abae				endm 
# End of macro FORTH_DSP_POP
abae			 
abae					FORTH_DSP_VALUEHL 
abae cd 0b 9d			call macro_dsp_valuehl 
abb1				endm 
# End of macro FORTH_DSP_VALUEHL
abb1			 
abb1					; hl contains value to add to byte at a 
abb1				 
abb1 eb					ex de, hl 
abb2			 
abb2 e1					pop hl 
abb3			 
abb3					if DEBUG_FORTH_WORDS 
abb3						DMARK "DEC" 
abb3 f5				push af  
abb4 3a c8 ab			ld a, (.dmark)  
abb7 32 b7 ee			ld (debug_mark),a  
abba 3a c9 ab			ld a, (.dmark+1)  
abbd 32 b8 ee			ld (debug_mark+1),a  
abc0 3a ca ab			ld a, (.dmark+2)  
abc3 32 b9 ee			ld (debug_mark+2),a  
abc6 18 03			jr .pastdmark  
abc8 ..			.dmark: db "DEC"  
abcb f1			.pastdmark: pop af  
abcc			endm  
# End of macro DMARK
abcc						CALLMONITOR 
abcc cd a3 94			call break_point_state  
abcf				endm  
# End of macro CALLMONITOR
abcf					endif 
abcf			 
abcf 7e					ld a,(hl) 
abd0 93					sub e 
abd1 77					ld (hl),a 
abd2			 
abd2			 
abd2			 
abd2				       NEXTW 
abd2 c3 c1 9e			jp macro_next 
abd5				endm 
# End of macro NEXTW
abd5			 
abd5			.INC2: 
abd5				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
abd5 6f				db WORD_SYS_CORE+91             
abd6 7f ac			dw .DEC2            
abd8 04				db 3 + 1 
abd9 .. 00			db "+2!",0              
abdd				endm 
# End of macro CWHEAD
abdd			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
abdd			 
abdd					if DEBUG_FORTH_WORDS_KEY 
abdd						DMARK "+2s" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 b7 ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 b8 ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 b9 ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "+2s"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6						CALLMONITOR 
abf6 cd a3 94			call break_point_state  
abf9				endm  
# End of macro CALLMONITOR
abf9					endif 
abf9			 
abf9					; Address 
abf9			 
abf9					FORTH_DSP_VALUEHL 
abf9 cd 0b 9d			call macro_dsp_valuehl 
abfc				endm 
# End of macro FORTH_DSP_VALUEHL
abfc			 
abfc e5					push hl    ; save address 
abfd			 
abfd					; load content into de 
abfd			 
abfd 5e					ld e,(hl) 
abfe 23					inc hl 
abff 56					ld d, (hl) 
ac00			 
ac00					if DEBUG_FORTH_WORDS 
ac00						DMARK "+2a" 
ac00 f5				push af  
ac01 3a 15 ac			ld a, (.dmark)  
ac04 32 b7 ee			ld (debug_mark),a  
ac07 3a 16 ac			ld a, (.dmark+1)  
ac0a 32 b8 ee			ld (debug_mark+1),a  
ac0d 3a 17 ac			ld a, (.dmark+2)  
ac10 32 b9 ee			ld (debug_mark+2),a  
ac13 18 03			jr .pastdmark  
ac15 ..			.dmark: db "+2a"  
ac18 f1			.pastdmark: pop af  
ac19			endm  
# End of macro DMARK
ac19						CALLMONITOR 
ac19 cd a3 94			call break_point_state  
ac1c				endm  
# End of macro CALLMONITOR
ac1c					endif 
ac1c			 
ac1c					FORTH_DSP_POP 
ac1c cd c3 9d			call macro_forth_dsp_pop 
ac1f				endm 
# End of macro FORTH_DSP_POP
ac1f			 
ac1f					; Get value to add 
ac1f			 
ac1f					FORTH_DSP_VALUE 
ac1f cd f4 9c			call macro_forth_dsp_value 
ac22				endm 
# End of macro FORTH_DSP_VALUE
ac22			 
ac22					if DEBUG_FORTH_WORDS 
ac22						DMARK "+2v" 
ac22 f5				push af  
ac23 3a 37 ac			ld a, (.dmark)  
ac26 32 b7 ee			ld (debug_mark),a  
ac29 3a 38 ac			ld a, (.dmark+1)  
ac2c 32 b8 ee			ld (debug_mark+1),a  
ac2f 3a 39 ac			ld a, (.dmark+2)  
ac32 32 b9 ee			ld (debug_mark+2),a  
ac35 18 03			jr .pastdmark  
ac37 ..			.dmark: db "+2v"  
ac3a f1			.pastdmark: pop af  
ac3b			endm  
# End of macro DMARK
ac3b						CALLMONITOR 
ac3b cd a3 94			call break_point_state  
ac3e				endm  
# End of macro CALLMONITOR
ac3e					endif 
ac3e			 
ac3e 19					add hl, de 
ac3f			 
ac3f					if DEBUG_FORTH_WORDS 
ac3f						DMARK "+2+" 
ac3f f5				push af  
ac40 3a 54 ac			ld a, (.dmark)  
ac43 32 b7 ee			ld (debug_mark),a  
ac46 3a 55 ac			ld a, (.dmark+1)  
ac49 32 b8 ee			ld (debug_mark+1),a  
ac4c 3a 56 ac			ld a, (.dmark+2)  
ac4f 32 b9 ee			ld (debug_mark+2),a  
ac52 18 03			jr .pastdmark  
ac54 ..			.dmark: db "+2+"  
ac57 f1			.pastdmark: pop af  
ac58			endm  
# End of macro DMARK
ac58						CALLMONITOR 
ac58 cd a3 94			call break_point_state  
ac5b				endm  
# End of macro CALLMONITOR
ac5b					endif 
ac5b			 
ac5b					; move result to de 
ac5b			 
ac5b eb					ex de, hl 
ac5c			 
ac5c					; Address 
ac5c			 
ac5c e1					pop hl 
ac5d			 
ac5d					; save it back 
ac5d			 
ac5d 73					ld (hl), e 
ac5e 23					inc hl 
ac5f 72					ld (hl), d 
ac60			 
ac60					if DEBUG_FORTH_WORDS 
ac60						DMARK "+2e" 
ac60 f5				push af  
ac61 3a 75 ac			ld a, (.dmark)  
ac64 32 b7 ee			ld (debug_mark),a  
ac67 3a 76 ac			ld a, (.dmark+1)  
ac6a 32 b8 ee			ld (debug_mark+1),a  
ac6d 3a 77 ac			ld a, (.dmark+2)  
ac70 32 b9 ee			ld (debug_mark+2),a  
ac73 18 03			jr .pastdmark  
ac75 ..			.dmark: db "+2e"  
ac78 f1			.pastdmark: pop af  
ac79			endm  
# End of macro DMARK
ac79						CALLMONITOR 
ac79 cd a3 94			call break_point_state  
ac7c				endm  
# End of macro CALLMONITOR
ac7c					endif 
ac7c			 
ac7c			 
ac7c			 
ac7c			 
ac7c			 
ac7c				       NEXTW 
ac7c c3 c1 9e			jp macro_next 
ac7f				endm 
# End of macro NEXTW
ac7f			 
ac7f			.DEC2: 
ac7f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ac7f 6f				db WORD_SYS_CORE+91             
ac80 2b ad			dw .GET2            
ac82 04				db 3 + 1 
ac83 .. 00			db "-2!",0              
ac87				endm 
# End of macro CWHEAD
ac87			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac87			 
ac87			 
ac87					if DEBUG_FORTH_WORDS_KEY 
ac87						DMARK "-2s" 
ac87 f5				push af  
ac88 3a 9c ac			ld a, (.dmark)  
ac8b 32 b7 ee			ld (debug_mark),a  
ac8e 3a 9d ac			ld a, (.dmark+1)  
ac91 32 b8 ee			ld (debug_mark+1),a  
ac94 3a 9e ac			ld a, (.dmark+2)  
ac97 32 b9 ee			ld (debug_mark+2),a  
ac9a 18 03			jr .pastdmark  
ac9c ..			.dmark: db "-2s"  
ac9f f1			.pastdmark: pop af  
aca0			endm  
# End of macro DMARK
aca0						CALLMONITOR 
aca0 cd a3 94			call break_point_state  
aca3				endm  
# End of macro CALLMONITOR
aca3					endif 
aca3			 
aca3					; Address 
aca3			 
aca3					FORTH_DSP_VALUEHL 
aca3 cd 0b 9d			call macro_dsp_valuehl 
aca6				endm 
# End of macro FORTH_DSP_VALUEHL
aca6			 
aca6 e5					push hl    ; save address 
aca7			 
aca7					; load content into de 
aca7			 
aca7 5e					ld e,(hl) 
aca8 23					inc hl 
aca9 56					ld d, (hl) 
acaa			 
acaa					if DEBUG_FORTH_WORDS 
acaa						DMARK "-2a" 
acaa f5				push af  
acab 3a bf ac			ld a, (.dmark)  
acae 32 b7 ee			ld (debug_mark),a  
acb1 3a c0 ac			ld a, (.dmark+1)  
acb4 32 b8 ee			ld (debug_mark+1),a  
acb7 3a c1 ac			ld a, (.dmark+2)  
acba 32 b9 ee			ld (debug_mark+2),a  
acbd 18 03			jr .pastdmark  
acbf ..			.dmark: db "-2a"  
acc2 f1			.pastdmark: pop af  
acc3			endm  
# End of macro DMARK
acc3						CALLMONITOR 
acc3 cd a3 94			call break_point_state  
acc6				endm  
# End of macro CALLMONITOR
acc6					endif 
acc6			 
acc6					FORTH_DSP_POP 
acc6 cd c3 9d			call macro_forth_dsp_pop 
acc9				endm 
# End of macro FORTH_DSP_POP
acc9			 
acc9					; Get value to remove 
acc9			 
acc9					FORTH_DSP_VALUE 
acc9 cd f4 9c			call macro_forth_dsp_value 
accc				endm 
# End of macro FORTH_DSP_VALUE
accc			 
accc					if DEBUG_FORTH_WORDS 
accc						DMARK "-2v" 
accc f5				push af  
accd 3a e1 ac			ld a, (.dmark)  
acd0 32 b7 ee			ld (debug_mark),a  
acd3 3a e2 ac			ld a, (.dmark+1)  
acd6 32 b8 ee			ld (debug_mark+1),a  
acd9 3a e3 ac			ld a, (.dmark+2)  
acdc 32 b9 ee			ld (debug_mark+2),a  
acdf 18 03			jr .pastdmark  
ace1 ..			.dmark: db "-2v"  
ace4 f1			.pastdmark: pop af  
ace5			endm  
# End of macro DMARK
ace5						CALLMONITOR 
ace5 cd a3 94			call break_point_state  
ace8				endm  
# End of macro CALLMONITOR
ace8					endif 
ace8			 
ace8 eb					ex de, hl 
ace9 ed 52				sbc hl, de 
aceb			 
aceb					if DEBUG_FORTH_WORDS 
aceb						DMARK "-2d" 
aceb f5				push af  
acec 3a 00 ad			ld a, (.dmark)  
acef 32 b7 ee			ld (debug_mark),a  
acf2 3a 01 ad			ld a, (.dmark+1)  
acf5 32 b8 ee			ld (debug_mark+1),a  
acf8 3a 02 ad			ld a, (.dmark+2)  
acfb 32 b9 ee			ld (debug_mark+2),a  
acfe 18 03			jr .pastdmark  
ad00 ..			.dmark: db "-2d"  
ad03 f1			.pastdmark: pop af  
ad04			endm  
# End of macro DMARK
ad04						CALLMONITOR 
ad04 cd a3 94			call break_point_state  
ad07				endm  
# End of macro CALLMONITOR
ad07					endif 
ad07			 
ad07					; move result to de 
ad07			 
ad07 eb					ex de, hl 
ad08			 
ad08					; Address 
ad08			 
ad08 e1					pop hl 
ad09			 
ad09					; save it back 
ad09			 
ad09 73					ld (hl), e 
ad0a 23					inc hl 
ad0b 72					ld (hl), d 
ad0c			 
ad0c					if DEBUG_FORTH_WORDS 
ad0c						DMARK "-2e" 
ad0c f5				push af  
ad0d 3a 21 ad			ld a, (.dmark)  
ad10 32 b7 ee			ld (debug_mark),a  
ad13 3a 22 ad			ld a, (.dmark+1)  
ad16 32 b8 ee			ld (debug_mark+1),a  
ad19 3a 23 ad			ld a, (.dmark+2)  
ad1c 32 b9 ee			ld (debug_mark+2),a  
ad1f 18 03			jr .pastdmark  
ad21 ..			.dmark: db "-2e"  
ad24 f1			.pastdmark: pop af  
ad25			endm  
# End of macro DMARK
ad25						CALLMONITOR 
ad25 cd a3 94			call break_point_state  
ad28				endm  
# End of macro CALLMONITOR
ad28					endif 
ad28			 
ad28			 
ad28			 
ad28			 
ad28			 
ad28				       NEXTW 
ad28 c3 c1 9e			jp macro_next 
ad2b				endm 
# End of macro NEXTW
ad2b			.GET2: 
ad2b				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad2b 6f				db WORD_SYS_CORE+91             
ad2c 5b ad			dw .BANG2            
ad2e 03				db 2 + 1 
ad2f .. 00			db "2@",0              
ad32				endm 
# End of macro CWHEAD
ad32			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad32					if DEBUG_FORTH_WORDS_KEY 
ad32						DMARK "2A_" 
ad32 f5				push af  
ad33 3a 47 ad			ld a, (.dmark)  
ad36 32 b7 ee			ld (debug_mark),a  
ad39 3a 48 ad			ld a, (.dmark+1)  
ad3c 32 b8 ee			ld (debug_mark+1),a  
ad3f 3a 49 ad			ld a, (.dmark+2)  
ad42 32 b9 ee			ld (debug_mark+2),a  
ad45 18 03			jr .pastdmark  
ad47 ..			.dmark: db "2A_"  
ad4a f1			.pastdmark: pop af  
ad4b			endm  
# End of macro DMARK
ad4b						CALLMONITOR 
ad4b cd a3 94			call break_point_state  
ad4e				endm  
# End of macro CALLMONITOR
ad4e					endif 
ad4e			 
ad4e					FORTH_DSP_VALUEHL 
ad4e cd 0b 9d			call macro_dsp_valuehl 
ad51				endm 
# End of macro FORTH_DSP_VALUEHL
ad51			 
ad51 5e					ld e, (hl) 
ad52 23					inc hl 
ad53 56					ld d, (hl) 
ad54			 
ad54 eb					ex de, hl 
ad55			 
ad55 cd 14 9b				call forth_push_numhl 
ad58			 
ad58				       NEXTW 
ad58 c3 c1 9e			jp macro_next 
ad5b				endm 
# End of macro NEXTW
ad5b			.BANG2: 
ad5b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad5b 6f				db WORD_SYS_CORE+91             
ad5c 93 ad			dw .CONFIG            
ad5e 03				db 2 + 1 
ad5f .. 00			db "2!",0              
ad62				endm 
# End of macro CWHEAD
ad62			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad62					if DEBUG_FORTH_WORDS_KEY 
ad62						DMARK "2S_" 
ad62 f5				push af  
ad63 3a 77 ad			ld a, (.dmark)  
ad66 32 b7 ee			ld (debug_mark),a  
ad69 3a 78 ad			ld a, (.dmark+1)  
ad6c 32 b8 ee			ld (debug_mark+1),a  
ad6f 3a 79 ad			ld a, (.dmark+2)  
ad72 32 b9 ee			ld (debug_mark+2),a  
ad75 18 03			jr .pastdmark  
ad77 ..			.dmark: db "2S_"  
ad7a f1			.pastdmark: pop af  
ad7b			endm  
# End of macro DMARK
ad7b						CALLMONITOR 
ad7b cd a3 94			call break_point_state  
ad7e				endm  
# End of macro CALLMONITOR
ad7e					endif 
ad7e			 
ad7e					FORTH_DSP_VALUEHL 
ad7e cd 0b 9d			call macro_dsp_valuehl 
ad81				endm 
# End of macro FORTH_DSP_VALUEHL
ad81			 
ad81 e5					push hl   ; save address 
ad82			 
ad82			 
ad82					FORTH_DSP_POP 
ad82 cd c3 9d			call macro_forth_dsp_pop 
ad85				endm 
# End of macro FORTH_DSP_POP
ad85			 
ad85					 
ad85					FORTH_DSP_VALUEHL 
ad85 cd 0b 9d			call macro_dsp_valuehl 
ad88				endm 
# End of macro FORTH_DSP_VALUEHL
ad88			 
ad88					FORTH_DSP_POP 
ad88 cd c3 9d			call macro_forth_dsp_pop 
ad8b				endm 
# End of macro FORTH_DSP_POP
ad8b			 
ad8b eb					ex de, hl    ; value now in de 
ad8c			 
ad8c e1					pop hl 
ad8d			 
ad8d 73					ld (hl), e 
ad8e			 
ad8e 23					inc hl 
ad8f			 
ad8f 72					ld (hl), d 
ad90			 
ad90			 
ad90				       NEXTW 
ad90 c3 c1 9e			jp macro_next 
ad93				endm 
# End of macro NEXTW
ad93			.CONFIG: 
ad93				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ad93 6f				db WORD_SYS_CORE+91             
ad94 a4 ad			dw .ENDCORE            
ad96 07				db 6 + 1 
ad97 .. 00			db "CONFIG",0              
ad9e				endm 
# End of macro CWHEAD
ad9e			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad9e			 
ad9e cd 02 93				call config 
ada1					NEXTW 
ada1 c3 c1 9e			jp macro_next 
ada4				endm 
# End of macro NEXTW
ada4			.ENDCORE: 
ada4			 
ada4			; eof 
ada4			 
ada4			 
# End of file forth_words_core.asm
ada4			include "forth_words_flow.asm" 
ada4			 
ada4			; | ## Program Flow Words 
ada4			 
ada4			.IF: 
ada4				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ada4 1e				db WORD_SYS_CORE+10             
ada5 99 ae			dw .THEN            
ada7 03				db 2 + 1 
ada8 .. 00			db "IF",0              
adab				endm 
# End of macro CWHEAD
adab			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
adab			; 
adab					if DEBUG_FORTH_WORDS_KEY 
adab						DMARK "IF." 
adab f5				push af  
adac 3a c0 ad			ld a, (.dmark)  
adaf 32 b7 ee			ld (debug_mark),a  
adb2 3a c1 ad			ld a, (.dmark+1)  
adb5 32 b8 ee			ld (debug_mark+1),a  
adb8 3a c2 ad			ld a, (.dmark+2)  
adbb 32 b9 ee			ld (debug_mark+2),a  
adbe 18 03			jr .pastdmark  
adc0 ..			.dmark: db "IF."  
adc3 f1			.pastdmark: pop af  
adc4			endm  
# End of macro DMARK
adc4						CALLMONITOR 
adc4 cd a3 94			call break_point_state  
adc7				endm  
# End of macro CALLMONITOR
adc7					endif 
adc7			; eval TOS 
adc7			 
adc7				FORTH_DSP_VALUEHL 
adc7 cd 0b 9d			call macro_dsp_valuehl 
adca				endm 
# End of macro FORTH_DSP_VALUEHL
adca			 
adca			;	push hl 
adca				FORTH_DSP_POP 
adca cd c3 9d			call macro_forth_dsp_pop 
adcd				endm 
# End of macro FORTH_DSP_POP
adcd			;	pop hl 
adcd			 
adcd					if DEBUG_FORTH_WORDS 
adcd						DMARK "IF1" 
adcd f5				push af  
adce 3a e2 ad			ld a, (.dmark)  
add1 32 b7 ee			ld (debug_mark),a  
add4 3a e3 ad			ld a, (.dmark+1)  
add7 32 b8 ee			ld (debug_mark+1),a  
adda 3a e4 ad			ld a, (.dmark+2)  
addd 32 b9 ee			ld (debug_mark+2),a  
ade0 18 03			jr .pastdmark  
ade2 ..			.dmark: db "IF1"  
ade5 f1			.pastdmark: pop af  
ade6			endm  
# End of macro DMARK
ade6						CALLMONITOR 
ade6 cd a3 94			call break_point_state  
ade9				endm  
# End of macro CALLMONITOR
ade9					endif 
ade9 b7				or a        ; clear carry flag 
adea 11 00 00			ld de, 0 
aded eb				ex de,hl 
adee ed 52			sbc hl, de 
adf0 c2 7a ae			jp nz, .iftrue 
adf3			 
adf3					if DEBUG_FORTH_WORDS 
adf3						DMARK "IF2" 
adf3 f5				push af  
adf4 3a 08 ae			ld a, (.dmark)  
adf7 32 b7 ee			ld (debug_mark),a  
adfa 3a 09 ae			ld a, (.dmark+1)  
adfd 32 b8 ee			ld (debug_mark+1),a  
ae00 3a 0a ae			ld a, (.dmark+2)  
ae03 32 b9 ee			ld (debug_mark+2),a  
ae06 18 03			jr .pastdmark  
ae08 ..			.dmark: db "IF2"  
ae0b f1			.pastdmark: pop af  
ae0c			endm  
# End of macro DMARK
ae0c						CALLMONITOR 
ae0c cd a3 94			call break_point_state  
ae0f				endm  
# End of macro CALLMONITOR
ae0f					endif 
ae0f			 
ae0f			; if not true then skip to THEN 
ae0f			 
ae0f				; TODO get tok_ptr 
ae0f				; TODO consume toks until we get to THEN 
ae0f			 
ae0f 2a 52 e7			ld hl, (os_tok_ptr) 
ae12					if DEBUG_FORTH_WORDS 
ae12						DMARK "IF3" 
ae12 f5				push af  
ae13 3a 27 ae			ld a, (.dmark)  
ae16 32 b7 ee			ld (debug_mark),a  
ae19 3a 28 ae			ld a, (.dmark+1)  
ae1c 32 b8 ee			ld (debug_mark+1),a  
ae1f 3a 29 ae			ld a, (.dmark+2)  
ae22 32 b9 ee			ld (debug_mark+2),a  
ae25 18 03			jr .pastdmark  
ae27 ..			.dmark: db "IF3"  
ae2a f1			.pastdmark: pop af  
ae2b			endm  
# End of macro DMARK
ae2b						CALLMONITOR 
ae2b cd a3 94			call break_point_state  
ae2e				endm  
# End of macro CALLMONITOR
ae2e						 
ae2e					endif 
ae2e 11 75 ae			ld de, .ifthen 
ae31					if DEBUG_FORTH_WORDS 
ae31						DMARK "IF4" 
ae31 f5				push af  
ae32 3a 46 ae			ld a, (.dmark)  
ae35 32 b7 ee			ld (debug_mark),a  
ae38 3a 47 ae			ld a, (.dmark+1)  
ae3b 32 b8 ee			ld (debug_mark+1),a  
ae3e 3a 48 ae			ld a, (.dmark+2)  
ae41 32 b9 ee			ld (debug_mark+2),a  
ae44 18 03			jr .pastdmark  
ae46 ..			.dmark: db "IF4"  
ae49 f1			.pastdmark: pop af  
ae4a			endm  
# End of macro DMARK
ae4a						CALLMONITOR 
ae4a cd a3 94			call break_point_state  
ae4d				endm  
# End of macro CALLMONITOR
ae4d					endif 
ae4d cd dc 9f			call findnexttok  
ae50			 
ae50					if DEBUG_FORTH_WORDS 
ae50						DMARK "IF5" 
ae50 f5				push af  
ae51 3a 65 ae			ld a, (.dmark)  
ae54 32 b7 ee			ld (debug_mark),a  
ae57 3a 66 ae			ld a, (.dmark+1)  
ae5a 32 b8 ee			ld (debug_mark+1),a  
ae5d 3a 67 ae			ld a, (.dmark+2)  
ae60 32 b9 ee			ld (debug_mark+2),a  
ae63 18 03			jr .pastdmark  
ae65 ..			.dmark: db "IF5"  
ae68 f1			.pastdmark: pop af  
ae69			endm  
# End of macro DMARK
ae69						CALLMONITOR 
ae69 cd a3 94			call break_point_state  
ae6c				endm  
# End of macro CALLMONITOR
ae6c					endif 
ae6c				; TODO replace below with ; exec using tok_ptr 
ae6c 22 52 e7			ld (os_tok_ptr), hl 
ae6f c3 52 9f			jp exec1 
ae72				NEXTW 
ae72 c3 c1 9e			jp macro_next 
ae75				endm 
# End of macro NEXTW
ae75			 
ae75 .. 00		.ifthen:  db "THEN",0 
ae7a			 
ae7a			.iftrue:		 
ae7a				; Exec next words normally 
ae7a			 
ae7a				; if true then exec following IF as normal 
ae7a					if DEBUG_FORTH_WORDS 
ae7a						DMARK "IFT" 
ae7a f5				push af  
ae7b 3a 8f ae			ld a, (.dmark)  
ae7e 32 b7 ee			ld (debug_mark),a  
ae81 3a 90 ae			ld a, (.dmark+1)  
ae84 32 b8 ee			ld (debug_mark+1),a  
ae87 3a 91 ae			ld a, (.dmark+2)  
ae8a 32 b9 ee			ld (debug_mark+2),a  
ae8d 18 03			jr .pastdmark  
ae8f ..			.dmark: db "IFT"  
ae92 f1			.pastdmark: pop af  
ae93			endm  
# End of macro DMARK
ae93						CALLMONITOR 
ae93 cd a3 94			call break_point_state  
ae96				endm  
# End of macro CALLMONITOR
ae96					endif 
ae96			 
ae96					NEXTW 
ae96 c3 c1 9e			jp macro_next 
ae99				endm 
# End of macro NEXTW
ae99			.THEN: 
ae99				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae99 1f				db WORD_SYS_CORE+11             
ae9a c1 ae			dw .ELSE            
ae9c 05				db 4 + 1 
ae9d .. 00			db "THEN",0              
aea2				endm 
# End of macro CWHEAD
aea2			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aea2					if DEBUG_FORTH_WORDS_KEY 
aea2						DMARK "THN" 
aea2 f5				push af  
aea3 3a b7 ae			ld a, (.dmark)  
aea6 32 b7 ee			ld (debug_mark),a  
aea9 3a b8 ae			ld a, (.dmark+1)  
aeac 32 b8 ee			ld (debug_mark+1),a  
aeaf 3a b9 ae			ld a, (.dmark+2)  
aeb2 32 b9 ee			ld (debug_mark+2),a  
aeb5 18 03			jr .pastdmark  
aeb7 ..			.dmark: db "THN"  
aeba f1			.pastdmark: pop af  
aebb			endm  
# End of macro DMARK
aebb						CALLMONITOR 
aebb cd a3 94			call break_point_state  
aebe				endm  
# End of macro CALLMONITOR
aebe					endif 
aebe					NEXTW 
aebe c3 c1 9e			jp macro_next 
aec1				endm 
# End of macro NEXTW
aec1			.ELSE: 
aec1				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aec1 20				db WORD_SYS_CORE+12             
aec2 e9 ae			dw .DO            
aec4 03				db 2 + 1 
aec5 .. 00			db "ELSE",0              
aeca				endm 
# End of macro CWHEAD
aeca			; | ELSE ( -- ) Not supported - does nothing | TODO 
aeca			 
aeca					if DEBUG_FORTH_WORDS_KEY 
aeca						DMARK "ELS" 
aeca f5				push af  
aecb 3a df ae			ld a, (.dmark)  
aece 32 b7 ee			ld (debug_mark),a  
aed1 3a e0 ae			ld a, (.dmark+1)  
aed4 32 b8 ee			ld (debug_mark+1),a  
aed7 3a e1 ae			ld a, (.dmark+2)  
aeda 32 b9 ee			ld (debug_mark+2),a  
aedd 18 03			jr .pastdmark  
aedf ..			.dmark: db "ELS"  
aee2 f1			.pastdmark: pop af  
aee3			endm  
# End of macro DMARK
aee3						CALLMONITOR 
aee3 cd a3 94			call break_point_state  
aee6				endm  
# End of macro CALLMONITOR
aee6					endif 
aee6			 
aee6			 
aee6					NEXTW 
aee6 c3 c1 9e			jp macro_next 
aee9				endm 
# End of macro NEXTW
aee9			.DO: 
aee9				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aee9 21				db WORD_SYS_CORE+13             
aeea 10 b0			dw .LOOP            
aeec 03				db 2 + 1 
aeed .. 00			db "DO",0              
aef0				endm 
# End of macro CWHEAD
aef0			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aef0			 
aef0					if DEBUG_FORTH_WORDS_KEY 
aef0						DMARK "DO." 
aef0 f5				push af  
aef1 3a 05 af			ld a, (.dmark)  
aef4 32 b7 ee			ld (debug_mark),a  
aef7 3a 06 af			ld a, (.dmark+1)  
aefa 32 b8 ee			ld (debug_mark+1),a  
aefd 3a 07 af			ld a, (.dmark+2)  
af00 32 b9 ee			ld (debug_mark+2),a  
af03 18 03			jr .pastdmark  
af05 ..			.dmark: db "DO."  
af08 f1			.pastdmark: pop af  
af09			endm  
# End of macro DMARK
af09						CALLMONITOR 
af09 cd a3 94			call break_point_state  
af0c				endm  
# End of macro CALLMONITOR
af0c					endif 
af0c			;  push pc to rsp stack past the DO 
af0c			 
af0c 2a 52 e7				ld hl, (os_tok_ptr) 
af0f 23					inc hl   ; D 
af10 23					inc hl  ; O 
af11 23					inc hl   ; null 
af12					if DEBUG_FORTH_WORDS 
af12						DMARK "DO2" 
af12 f5				push af  
af13 3a 27 af			ld a, (.dmark)  
af16 32 b7 ee			ld (debug_mark),a  
af19 3a 28 af			ld a, (.dmark+1)  
af1c 32 b8 ee			ld (debug_mark+1),a  
af1f 3a 29 af			ld a, (.dmark+2)  
af22 32 b9 ee			ld (debug_mark+2),a  
af25 18 03			jr .pastdmark  
af27 ..			.dmark: db "DO2"  
af2a f1			.pastdmark: pop af  
af2b			endm  
# End of macro DMARK
af2b						CALLMONITOR 
af2b cd a3 94			call break_point_state  
af2e				endm  
# End of macro CALLMONITOR
af2e					endif 
af2e					FORTH_RSP_NEXT 
af2e cd bb 9a			call macro_forth_rsp_next 
af31				endm 
# End of macro FORTH_RSP_NEXT
af31					if DEBUG_FORTH_WORDS 
af31						DMARK "DO3" 
af31 f5				push af  
af32 3a 46 af			ld a, (.dmark)  
af35 32 b7 ee			ld (debug_mark),a  
af38 3a 47 af			ld a, (.dmark+1)  
af3b 32 b8 ee			ld (debug_mark+1),a  
af3e 3a 48 af			ld a, (.dmark+2)  
af41 32 b9 ee			ld (debug_mark+2),a  
af44 18 03			jr .pastdmark  
af46 ..			.dmark: db "DO3"  
af49 f1			.pastdmark: pop af  
af4a			endm  
# End of macro DMARK
af4a						CALLMONITOR 
af4a cd a3 94			call break_point_state  
af4d				endm  
# End of macro CALLMONITOR
af4d					endif 
af4d			 
af4d					;if DEBUG_FORTH_WORDS 
af4d				;		push hl 
af4d			;		endif  
af4d			 
af4d			; get counters from data stack 
af4d			 
af4d			 
af4d					FORTH_DSP_VALUEHL 
af4d cd 0b 9d			call macro_dsp_valuehl 
af50				endm 
# End of macro FORTH_DSP_VALUEHL
af50 e5					push hl		 ; hl now has starting counter which needs to be tos 
af51			 
af51					if DEBUG_FORTH_WORDS 
af51						DMARK "DO4" 
af51 f5				push af  
af52 3a 66 af			ld a, (.dmark)  
af55 32 b7 ee			ld (debug_mark),a  
af58 3a 67 af			ld a, (.dmark+1)  
af5b 32 b8 ee			ld (debug_mark+1),a  
af5e 3a 68 af			ld a, (.dmark+2)  
af61 32 b9 ee			ld (debug_mark+2),a  
af64 18 03			jr .pastdmark  
af66 ..			.dmark: db "DO4"  
af69 f1			.pastdmark: pop af  
af6a			endm  
# End of macro DMARK
af6a						CALLMONITOR 
af6a cd a3 94			call break_point_state  
af6d				endm  
# End of macro CALLMONITOR
af6d					endif 
af6d					FORTH_DSP_POP 
af6d cd c3 9d			call macro_forth_dsp_pop 
af70				endm 
# End of macro FORTH_DSP_POP
af70			 
af70					if DEBUG_FORTH_WORDS 
af70						DMARK "DO5" 
af70 f5				push af  
af71 3a 85 af			ld a, (.dmark)  
af74 32 b7 ee			ld (debug_mark),a  
af77 3a 86 af			ld a, (.dmark+1)  
af7a 32 b8 ee			ld (debug_mark+1),a  
af7d 3a 87 af			ld a, (.dmark+2)  
af80 32 b9 ee			ld (debug_mark+2),a  
af83 18 03			jr .pastdmark  
af85 ..			.dmark: db "DO5"  
af88 f1			.pastdmark: pop af  
af89			endm  
# End of macro DMARK
af89						CALLMONITOR 
af89 cd a3 94			call break_point_state  
af8c				endm  
# End of macro CALLMONITOR
af8c					endif 
af8c			 
af8c					FORTH_DSP_VALUEHL 
af8c cd 0b 9d			call macro_dsp_valuehl 
af8f				endm 
# End of macro FORTH_DSP_VALUEHL
af8f			;		push hl		 ; hl now has starting limit counter 
af8f			 
af8f					if DEBUG_FORTH_WORDS 
af8f						DMARK "DO6" 
af8f f5				push af  
af90 3a a4 af			ld a, (.dmark)  
af93 32 b7 ee			ld (debug_mark),a  
af96 3a a5 af			ld a, (.dmark+1)  
af99 32 b8 ee			ld (debug_mark+1),a  
af9c 3a a6 af			ld a, (.dmark+2)  
af9f 32 b9 ee			ld (debug_mark+2),a  
afa2 18 03			jr .pastdmark  
afa4 ..			.dmark: db "DO6"  
afa7 f1			.pastdmark: pop af  
afa8			endm  
# End of macro DMARK
afa8						CALLMONITOR 
afa8 cd a3 94			call break_point_state  
afab				endm  
# End of macro CALLMONITOR
afab					endif 
afab					FORTH_DSP_POP 
afab cd c3 9d			call macro_forth_dsp_pop 
afae				endm 
# End of macro FORTH_DSP_POP
afae			 
afae			; put counters on the loop stack 
afae			 
afae			;		pop hl			 ; limit counter 
afae d1					pop de			; start counter 
afaf			 
afaf					; push limit counter 
afaf			 
afaf					if DEBUG_FORTH_WORDS 
afaf						DMARK "DO7" 
afaf f5				push af  
afb0 3a c4 af			ld a, (.dmark)  
afb3 32 b7 ee			ld (debug_mark),a  
afb6 3a c5 af			ld a, (.dmark+1)  
afb9 32 b8 ee			ld (debug_mark+1),a  
afbc 3a c6 af			ld a, (.dmark+2)  
afbf 32 b9 ee			ld (debug_mark+2),a  
afc2 18 03			jr .pastdmark  
afc4 ..			.dmark: db "DO7"  
afc7 f1			.pastdmark: pop af  
afc8			endm  
# End of macro DMARK
afc8						CALLMONITOR 
afc8 cd a3 94			call break_point_state  
afcb				endm  
# End of macro CALLMONITOR
afcb					endif 
afcb					FORTH_LOOP_NEXT 
afcb cd 3c 9d			call macro_forth_loop_next 
afce				endm 
# End of macro FORTH_LOOP_NEXT
afce			 
afce					; push start counter 
afce			 
afce eb					ex de, hl 
afcf					if DEBUG_FORTH_WORDS 
afcf						DMARK "DO7" 
afcf f5				push af  
afd0 3a e4 af			ld a, (.dmark)  
afd3 32 b7 ee			ld (debug_mark),a  
afd6 3a e5 af			ld a, (.dmark+1)  
afd9 32 b8 ee			ld (debug_mark+1),a  
afdc 3a e6 af			ld a, (.dmark+2)  
afdf 32 b9 ee			ld (debug_mark+2),a  
afe2 18 03			jr .pastdmark  
afe4 ..			.dmark: db "DO7"  
afe7 f1			.pastdmark: pop af  
afe8			endm  
# End of macro DMARK
afe8						CALLMONITOR 
afe8 cd a3 94			call break_point_state  
afeb				endm  
# End of macro CALLMONITOR
afeb					endif 
afeb					FORTH_LOOP_NEXT 
afeb cd 3c 9d			call macro_forth_loop_next 
afee				endm 
# End of macro FORTH_LOOP_NEXT
afee			 
afee			 
afee					; init first round of I counter 
afee			 
afee 22 76 e7				ld (os_current_i), hl 
aff1			 
aff1					if DEBUG_FORTH_WORDS 
aff1						DMARK "DO8" 
aff1 f5				push af  
aff2 3a 06 b0			ld a, (.dmark)  
aff5 32 b7 ee			ld (debug_mark),a  
aff8 3a 07 b0			ld a, (.dmark+1)  
affb 32 b8 ee			ld (debug_mark+1),a  
affe 3a 08 b0			ld a, (.dmark+2)  
b001 32 b9 ee			ld (debug_mark+2),a  
b004 18 03			jr .pastdmark  
b006 ..			.dmark: db "DO8"  
b009 f1			.pastdmark: pop af  
b00a			endm  
# End of macro DMARK
b00a						CALLMONITOR 
b00a cd a3 94			call break_point_state  
b00d				endm  
# End of macro CALLMONITOR
b00d					endif 
b00d			 
b00d					NEXTW 
b00d c3 c1 9e			jp macro_next 
b010				endm 
# End of macro NEXTW
b010			.LOOP: 
b010				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b010 22				db WORD_SYS_CORE+14             
b011 28 b1			dw .I            
b013 05				db 4 + 1 
b014 .. 00			db "LOOP",0              
b019				endm 
# End of macro CWHEAD
b019			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b019			 
b019				; pop tos as current loop count to hl 
b019			 
b019				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b019			 
b019				FORTH_LOOP_TOS 
b019 cd 6f 9d			call macro_forth_loop_tos 
b01c				endm 
# End of macro FORTH_LOOP_TOS
b01c e5				push hl 
b01d			 
b01d					if DEBUG_FORTH_WORDS_KEY 
b01d						DMARK "LOP" 
b01d f5				push af  
b01e 3a 32 b0			ld a, (.dmark)  
b021 32 b7 ee			ld (debug_mark),a  
b024 3a 33 b0			ld a, (.dmark+1)  
b027 32 b8 ee			ld (debug_mark+1),a  
b02a 3a 34 b0			ld a, (.dmark+2)  
b02d 32 b9 ee			ld (debug_mark+2),a  
b030 18 03			jr .pastdmark  
b032 ..			.dmark: db "LOP"  
b035 f1			.pastdmark: pop af  
b036			endm  
# End of macro DMARK
b036						CALLMONITOR 
b036 cd a3 94			call break_point_state  
b039				endm  
# End of macro CALLMONITOR
b039					endif 
b039				; next item on the stack is the limit. get it 
b039			 
b039			 
b039				FORTH_LOOP_POP 
b039 cd 79 9d			call macro_forth_loop_pop 
b03c				endm 
# End of macro FORTH_LOOP_POP
b03c			 
b03c				FORTH_LOOP_TOS 
b03c cd 6f 9d			call macro_forth_loop_tos 
b03f				endm 
# End of macro FORTH_LOOP_TOS
b03f			 
b03f d1				pop de		 ; de = i, hl = limit 
b040			 
b040					if DEBUG_FORTH_WORDS 
b040						DMARK "LP1" 
b040 f5				push af  
b041 3a 55 b0			ld a, (.dmark)  
b044 32 b7 ee			ld (debug_mark),a  
b047 3a 56 b0			ld a, (.dmark+1)  
b04a 32 b8 ee			ld (debug_mark+1),a  
b04d 3a 57 b0			ld a, (.dmark+2)  
b050 32 b9 ee			ld (debug_mark+2),a  
b053 18 03			jr .pastdmark  
b055 ..			.dmark: db "LP1"  
b058 f1			.pastdmark: pop af  
b059			endm  
# End of macro DMARK
b059						CALLMONITOR 
b059 cd a3 94			call break_point_state  
b05c				endm  
# End of macro CALLMONITOR
b05c					endif 
b05c			 
b05c				; go back to previous word 
b05c			 
b05c d5				push de    ; save I for inc later 
b05d			 
b05d			 
b05d				; get limit 
b05d				;  is I at limit? 
b05d			 
b05d			 
b05d					if DEBUG_FORTH_WORDS 
b05d						DMARK "LP1" 
b05d f5				push af  
b05e 3a 72 b0			ld a, (.dmark)  
b061 32 b7 ee			ld (debug_mark),a  
b064 3a 73 b0			ld a, (.dmark+1)  
b067 32 b8 ee			ld (debug_mark+1),a  
b06a 3a 74 b0			ld a, (.dmark+2)  
b06d 32 b9 ee			ld (debug_mark+2),a  
b070 18 03			jr .pastdmark  
b072 ..			.dmark: db "LP1"  
b075 f1			.pastdmark: pop af  
b076			endm  
# End of macro DMARK
b076						CALLMONITOR 
b076 cd a3 94			call break_point_state  
b079				endm  
# End of macro CALLMONITOR
b079					endif 
b079			 
b079 ed 52			sbc hl, de 
b07b			 
b07b			 
b07b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b07b			 
b07b 20 26				jr nz, .loopnotdone 
b07d			 
b07d e1				pop hl   ; get rid of saved I 
b07e				FORTH_LOOP_POP     ; get rid of limit 
b07e cd 79 9d			call macro_forth_loop_pop 
b081				endm 
# End of macro FORTH_LOOP_POP
b081			 
b081				FORTH_RSP_POP     ; get rid of DO ptr 
b081 cd dc 9a			call macro_forth_rsp_pop 
b084				endm 
# End of macro FORTH_RSP_POP
b084			 
b084			if DEBUG_FORTH_WORDS 
b084						DMARK "LP>" 
b084 f5				push af  
b085 3a 99 b0			ld a, (.dmark)  
b088 32 b7 ee			ld (debug_mark),a  
b08b 3a 9a b0			ld a, (.dmark+1)  
b08e 32 b8 ee			ld (debug_mark+1),a  
b091 3a 9b b0			ld a, (.dmark+2)  
b094 32 b9 ee			ld (debug_mark+2),a  
b097 18 03			jr .pastdmark  
b099 ..			.dmark: db "LP>"  
b09c f1			.pastdmark: pop af  
b09d			endm  
# End of macro DMARK
b09d				CALLMONITOR 
b09d cd a3 94			call break_point_state  
b0a0				endm  
# End of macro CALLMONITOR
b0a0			endif 
b0a0			 
b0a0					NEXTW 
b0a0 c3 c1 9e			jp macro_next 
b0a3				endm 
# End of macro NEXTW
b0a3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0a3			 
b0a3			.loopnotdone: 
b0a3			 
b0a3 e1				pop hl    ; get I 
b0a4 23				inc hl 
b0a5			 
b0a5			   	; save new I 
b0a5			 
b0a5			 
b0a5					; set I counter 
b0a5			 
b0a5 22 76 e7				ld (os_current_i), hl 
b0a8			 
b0a8					if DEBUG_FORTH_WORDS 
b0a8						DMARK "LPN" 
b0a8 f5				push af  
b0a9 3a bd b0			ld a, (.dmark)  
b0ac 32 b7 ee			ld (debug_mark),a  
b0af 3a be b0			ld a, (.dmark+1)  
b0b2 32 b8 ee			ld (debug_mark+1),a  
b0b5 3a bf b0			ld a, (.dmark+2)  
b0b8 32 b9 ee			ld (debug_mark+2),a  
b0bb 18 03			jr .pastdmark  
b0bd ..			.dmark: db "LPN"  
b0c0 f1			.pastdmark: pop af  
b0c1			endm  
# End of macro DMARK
b0c1					CALLMONITOR 
b0c1 cd a3 94			call break_point_state  
b0c4				endm  
# End of macro CALLMONITOR
b0c4					endif 
b0c4					 
b0c4				FORTH_LOOP_NEXT 
b0c4 cd 3c 9d			call macro_forth_loop_next 
b0c7				endm 
# End of macro FORTH_LOOP_NEXT
b0c7			 
b0c7			 
b0c7					if DEBUG_FORTH_WORDS 
b0c7 eb						ex de,hl 
b0c8					endif 
b0c8			 
b0c8			;	; get DO ptr 
b0c8			; 
b0c8					if DEBUG_FORTH_WORDS 
b0c8						DMARK "LP7" 
b0c8 f5				push af  
b0c9 3a dd b0			ld a, (.dmark)  
b0cc 32 b7 ee			ld (debug_mark),a  
b0cf 3a de b0			ld a, (.dmark+1)  
b0d2 32 b8 ee			ld (debug_mark+1),a  
b0d5 3a df b0			ld a, (.dmark+2)  
b0d8 32 b9 ee			ld (debug_mark+2),a  
b0db 18 03			jr .pastdmark  
b0dd ..			.dmark: db "LP7"  
b0e0 f1			.pastdmark: pop af  
b0e1			endm  
# End of macro DMARK
b0e1					CALLMONITOR 
b0e1 cd a3 94			call break_point_state  
b0e4				endm  
# End of macro CALLMONITOR
b0e4					endif 
b0e4				FORTH_RSP_TOS 
b0e4 cd d2 9a			call macro_forth_rsp_tos 
b0e7				endm 
# End of macro FORTH_RSP_TOS
b0e7			 
b0e7					if DEBUG_FORTH_WORDS 
b0e7						DMARK "LP8" 
b0e7 f5				push af  
b0e8 3a fc b0			ld a, (.dmark)  
b0eb 32 b7 ee			ld (debug_mark),a  
b0ee 3a fd b0			ld a, (.dmark+1)  
b0f1 32 b8 ee			ld (debug_mark+1),a  
b0f4 3a fe b0			ld a, (.dmark+2)  
b0f7 32 b9 ee			ld (debug_mark+2),a  
b0fa 18 03			jr .pastdmark  
b0fc ..			.dmark: db "LP8"  
b0ff f1			.pastdmark: pop af  
b100			endm  
# End of macro DMARK
b100					CALLMONITOR 
b100 cd a3 94			call break_point_state  
b103				endm  
# End of macro CALLMONITOR
b103					endif 
b103				;push hl 
b103			 
b103				; not going to DO any more 
b103				; get rid of the RSP pointer as DO will add it back in 
b103				;FORTH_RSP_POP 
b103				;pop hl 
b103			 
b103				;ld hl,(cli_ret_sp) 
b103				;ld e, (hl) 
b103				;inc hl 
b103				;ld d, (hl) 
b103				;ex de,hl 
b103 22 52 e7			ld (os_tok_ptr), hl 
b106					if DEBUG_FORTH_WORDS 
b106						DMARK "LP<" 
b106 f5				push af  
b107 3a 1b b1			ld a, (.dmark)  
b10a 32 b7 ee			ld (debug_mark),a  
b10d 3a 1c b1			ld a, (.dmark+1)  
b110 32 b8 ee			ld (debug_mark+1),a  
b113 3a 1d b1			ld a, (.dmark+2)  
b116 32 b9 ee			ld (debug_mark+2),a  
b119 18 03			jr .pastdmark  
b11b ..			.dmark: db "LP<"  
b11e f1			.pastdmark: pop af  
b11f			endm  
# End of macro DMARK
b11f					CALLMONITOR 
b11f cd a3 94			call break_point_state  
b122				endm  
# End of macro CALLMONITOR
b122				endif 
b122 c3 52 9f			jp exec1 
b125			 
b125					 
b125			 
b125			 
b125					NEXTW 
b125 c3 c1 9e			jp macro_next 
b128				endm 
# End of macro NEXTW
b128			.I:  
b128			 
b128				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b128 5e				db WORD_SYS_CORE+74             
b129 53 b1			dw .DLOOP            
b12b 02				db 1 + 1 
b12c .. 00			db "I",0              
b12e				endm 
# End of macro CWHEAD
b12e			; | I ( -- ) Current loop counter | DONE 
b12e					if DEBUG_FORTH_WORDS_KEY 
b12e						DMARK "I.." 
b12e f5				push af  
b12f 3a 43 b1			ld a, (.dmark)  
b132 32 b7 ee			ld (debug_mark),a  
b135 3a 44 b1			ld a, (.dmark+1)  
b138 32 b8 ee			ld (debug_mark+1),a  
b13b 3a 45 b1			ld a, (.dmark+2)  
b13e 32 b9 ee			ld (debug_mark+2),a  
b141 18 03			jr .pastdmark  
b143 ..			.dmark: db "I.."  
b146 f1			.pastdmark: pop af  
b147			endm  
# End of macro DMARK
b147						CALLMONITOR 
b147 cd a3 94			call break_point_state  
b14a				endm  
# End of macro CALLMONITOR
b14a					endif 
b14a			 
b14a 2a 76 e7				ld hl,(os_current_i) 
b14d cd 14 9b				call forth_push_numhl 
b150			 
b150					NEXTW 
b150 c3 c1 9e			jp macro_next 
b153				endm 
# End of macro NEXTW
b153			.DLOOP: 
b153				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b153 5f				db WORD_SYS_CORE+75             
b154 34 b2			dw .REPEAT            
b156 06				db 5 + 1 
b157 .. 00			db "-LOOP",0              
b15d				endm 
# End of macro CWHEAD
b15d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b15d				; pop tos as current loop count to hl 
b15d					if DEBUG_FORTH_WORDS_KEY 
b15d						DMARK "-LP" 
b15d f5				push af  
b15e 3a 72 b1			ld a, (.dmark)  
b161 32 b7 ee			ld (debug_mark),a  
b164 3a 73 b1			ld a, (.dmark+1)  
b167 32 b8 ee			ld (debug_mark+1),a  
b16a 3a 74 b1			ld a, (.dmark+2)  
b16d 32 b9 ee			ld (debug_mark+2),a  
b170 18 03			jr .pastdmark  
b172 ..			.dmark: db "-LP"  
b175 f1			.pastdmark: pop af  
b176			endm  
# End of macro DMARK
b176						CALLMONITOR 
b176 cd a3 94			call break_point_state  
b179				endm  
# End of macro CALLMONITOR
b179					endif 
b179			 
b179				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b179			 
b179				FORTH_LOOP_TOS 
b179 cd 6f 9d			call macro_forth_loop_tos 
b17c				endm 
# End of macro FORTH_LOOP_TOS
b17c e5				push hl 
b17d			 
b17d					if DEBUG_FORTH_WORDS 
b17d						DMARK "-LP" 
b17d f5				push af  
b17e 3a 92 b1			ld a, (.dmark)  
b181 32 b7 ee			ld (debug_mark),a  
b184 3a 93 b1			ld a, (.dmark+1)  
b187 32 b8 ee			ld (debug_mark+1),a  
b18a 3a 94 b1			ld a, (.dmark+2)  
b18d 32 b9 ee			ld (debug_mark+2),a  
b190 18 03			jr .pastdmark  
b192 ..			.dmark: db "-LP"  
b195 f1			.pastdmark: pop af  
b196			endm  
# End of macro DMARK
b196						CALLMONITOR 
b196 cd a3 94			call break_point_state  
b199				endm  
# End of macro CALLMONITOR
b199					endif 
b199				; next item on the stack is the limit. get it 
b199			 
b199			 
b199				FORTH_LOOP_POP 
b199 cd 79 9d			call macro_forth_loop_pop 
b19c				endm 
# End of macro FORTH_LOOP_POP
b19c			 
b19c				FORTH_LOOP_TOS 
b19c cd 6f 9d			call macro_forth_loop_tos 
b19f				endm 
# End of macro FORTH_LOOP_TOS
b19f			 
b19f d1				pop de		 ; de = i, hl = limit 
b1a0			 
b1a0					if DEBUG_FORTH_WORDS 
b1a0						DMARK "-L1" 
b1a0 f5				push af  
b1a1 3a b5 b1			ld a, (.dmark)  
b1a4 32 b7 ee			ld (debug_mark),a  
b1a7 3a b6 b1			ld a, (.dmark+1)  
b1aa 32 b8 ee			ld (debug_mark+1),a  
b1ad 3a b7 b1			ld a, (.dmark+2)  
b1b0 32 b9 ee			ld (debug_mark+2),a  
b1b3 18 03			jr .pastdmark  
b1b5 ..			.dmark: db "-L1"  
b1b8 f1			.pastdmark: pop af  
b1b9			endm  
# End of macro DMARK
b1b9						CALLMONITOR 
b1b9 cd a3 94			call break_point_state  
b1bc				endm  
# End of macro CALLMONITOR
b1bc					endif 
b1bc			 
b1bc				; go back to previous word 
b1bc			 
b1bc d5				push de    ; save I for inc later 
b1bd			 
b1bd			 
b1bd				; get limit 
b1bd				;  is I at limit? 
b1bd			 
b1bd			 
b1bd					if DEBUG_FORTH_WORDS 
b1bd						DMARK "-L1" 
b1bd f5				push af  
b1be 3a d2 b1			ld a, (.dmark)  
b1c1 32 b7 ee			ld (debug_mark),a  
b1c4 3a d3 b1			ld a, (.dmark+1)  
b1c7 32 b8 ee			ld (debug_mark+1),a  
b1ca 3a d4 b1			ld a, (.dmark+2)  
b1cd 32 b9 ee			ld (debug_mark+2),a  
b1d0 18 03			jr .pastdmark  
b1d2 ..			.dmark: db "-L1"  
b1d5 f1			.pastdmark: pop af  
b1d6			endm  
# End of macro DMARK
b1d6						CALLMONITOR 
b1d6 cd a3 94			call break_point_state  
b1d9				endm  
# End of macro CALLMONITOR
b1d9					endif 
b1d9			 
b1d9 ed 52			sbc hl, de 
b1db			 
b1db			 
b1db				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b1db			 
b1db 20 26				jr nz, .mloopnotdone 
b1dd			 
b1dd e1				pop hl   ; get rid of saved I 
b1de				FORTH_LOOP_POP     ; get rid of limit 
b1de cd 79 9d			call macro_forth_loop_pop 
b1e1				endm 
# End of macro FORTH_LOOP_POP
b1e1			 
b1e1				FORTH_RSP_POP     ; get rid of DO ptr 
b1e1 cd dc 9a			call macro_forth_rsp_pop 
b1e4				endm 
# End of macro FORTH_RSP_POP
b1e4			 
b1e4			if DEBUG_FORTH_WORDS 
b1e4						DMARK "-L>" 
b1e4 f5				push af  
b1e5 3a f9 b1			ld a, (.dmark)  
b1e8 32 b7 ee			ld (debug_mark),a  
b1eb 3a fa b1			ld a, (.dmark+1)  
b1ee 32 b8 ee			ld (debug_mark+1),a  
b1f1 3a fb b1			ld a, (.dmark+2)  
b1f4 32 b9 ee			ld (debug_mark+2),a  
b1f7 18 03			jr .pastdmark  
b1f9 ..			.dmark: db "-L>"  
b1fc f1			.pastdmark: pop af  
b1fd			endm  
# End of macro DMARK
b1fd				CALLMONITOR 
b1fd cd a3 94			call break_point_state  
b200				endm  
# End of macro CALLMONITOR
b200			endif 
b200			 
b200					NEXTW 
b200 c3 c1 9e			jp macro_next 
b203				endm 
# End of macro NEXTW
b203				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b203			 
b203			.mloopnotdone: 
b203			 
b203 e1				pop hl    ; get I 
b204 2b				dec hl 
b205			 
b205			   	; save new I 
b205			 
b205			 
b205					; set I counter 
b205			 
b205 22 76 e7				ld (os_current_i), hl 
b208			 
b208					 
b208				FORTH_LOOP_NEXT 
b208 cd 3c 9d			call macro_forth_loop_next 
b20b				endm 
# End of macro FORTH_LOOP_NEXT
b20b			 
b20b			 
b20b					if DEBUG_FORTH_WORDS 
b20b eb						ex de,hl 
b20c					endif 
b20c			 
b20c			;	; get DO ptr 
b20c			; 
b20c				FORTH_RSP_TOS 
b20c cd d2 9a			call macro_forth_rsp_tos 
b20f				endm 
# End of macro FORTH_RSP_TOS
b20f			 
b20f				;push hl 
b20f			 
b20f				; not going to DO any more 
b20f				; get rid of the RSP pointer as DO will add it back in 
b20f				;FORTH_RSP_POP 
b20f				;pop hl 
b20f			 
b20f			 
b20f 22 52 e7			ld (os_tok_ptr), hl 
b212					if DEBUG_FORTH_WORDS 
b212						DMARK "-L<" 
b212 f5				push af  
b213 3a 27 b2			ld a, (.dmark)  
b216 32 b7 ee			ld (debug_mark),a  
b219 3a 28 b2			ld a, (.dmark+1)  
b21c 32 b8 ee			ld (debug_mark+1),a  
b21f 3a 29 b2			ld a, (.dmark+2)  
b222 32 b9 ee			ld (debug_mark+2),a  
b225 18 03			jr .pastdmark  
b227 ..			.dmark: db "-L<"  
b22a f1			.pastdmark: pop af  
b22b			endm  
# End of macro DMARK
b22b					CALLMONITOR 
b22b cd a3 94			call break_point_state  
b22e				endm  
# End of macro CALLMONITOR
b22e				endif 
b22e c3 52 9f			jp exec1 
b231			 
b231					 
b231			 
b231			 
b231			 
b231				NEXTW 
b231 c3 c1 9e			jp macro_next 
b234				endm 
# End of macro NEXTW
b234			 
b234			 
b234			 
b234			 
b234			.REPEAT: 
b234				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b234 71				db WORD_SYS_CORE+93             
b235 87 b2			dw .UNTIL            
b237 06				db 5 + 1 
b238 .. 00			db "REPEAT",0              
b23f				endm 
# End of macro CWHEAD
b23f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b23f			;  push pc to rsp stack past the REPEAT 
b23f					if DEBUG_FORTH_WORDS_KEY 
b23f						DMARK "REP" 
b23f f5				push af  
b240 3a 54 b2			ld a, (.dmark)  
b243 32 b7 ee			ld (debug_mark),a  
b246 3a 55 b2			ld a, (.dmark+1)  
b249 32 b8 ee			ld (debug_mark+1),a  
b24c 3a 56 b2			ld a, (.dmark+2)  
b24f 32 b9 ee			ld (debug_mark+2),a  
b252 18 03			jr .pastdmark  
b254 ..			.dmark: db "REP"  
b257 f1			.pastdmark: pop af  
b258			endm  
# End of macro DMARK
b258						CALLMONITOR 
b258 cd a3 94			call break_point_state  
b25b				endm  
# End of macro CALLMONITOR
b25b					endif 
b25b			 
b25b 2a 52 e7				ld hl, (os_tok_ptr) 
b25e 23					inc hl   ; R 
b25f 23					inc hl  ; E 
b260 23					inc hl   ; P 
b261 23					inc hl   ; E 
b262 23					inc hl   ; A 
b263 23					inc hl   ; T 
b264 23					inc hl   ; zero 
b265					FORTH_RSP_NEXT 
b265 cd bb 9a			call macro_forth_rsp_next 
b268				endm 
# End of macro FORTH_RSP_NEXT
b268			 
b268			 
b268					if DEBUG_FORTH_WORDS 
b268						DMARK "REP" 
b268 f5				push af  
b269 3a 7d b2			ld a, (.dmark)  
b26c 32 b7 ee			ld (debug_mark),a  
b26f 3a 7e b2			ld a, (.dmark+1)  
b272 32 b8 ee			ld (debug_mark+1),a  
b275 3a 7f b2			ld a, (.dmark+2)  
b278 32 b9 ee			ld (debug_mark+2),a  
b27b 18 03			jr .pastdmark  
b27d ..			.dmark: db "REP"  
b280 f1			.pastdmark: pop af  
b281			endm  
# End of macro DMARK
b281						;pop bc    ; TODO BUG ?????? what is this for???? 
b281						CALLMONITOR 
b281 cd a3 94			call break_point_state  
b284				endm  
# End of macro CALLMONITOR
b284					endif 
b284			 
b284					NEXTW 
b284 c3 c1 9e			jp macro_next 
b287				endm 
# End of macro NEXTW
b287			;	       NEXTW 
b287			 
b287			.UNTIL: 
b287				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b287 72				db WORD_SYS_CORE+94             
b288 1e b3			dw .ENDFLOW            
b28a 06				db 5 + 1 
b28b .. 00			db "UNTIL",0              
b291				endm 
# End of macro CWHEAD
b291			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b291			 
b291				; pop tos as check 
b291			 
b291				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b291			 
b291				FORTH_DSP_VALUEHL 
b291 cd 0b 9d			call macro_dsp_valuehl 
b294				endm 
# End of macro FORTH_DSP_VALUEHL
b294			 
b294					if DEBUG_FORTH_WORDS_KEY 
b294						DMARK "UNT" 
b294 f5				push af  
b295 3a a9 b2			ld a, (.dmark)  
b298 32 b7 ee			ld (debug_mark),a  
b29b 3a aa b2			ld a, (.dmark+1)  
b29e 32 b8 ee			ld (debug_mark+1),a  
b2a1 3a ab b2			ld a, (.dmark+2)  
b2a4 32 b9 ee			ld (debug_mark+2),a  
b2a7 18 03			jr .pastdmark  
b2a9 ..			.dmark: db "UNT"  
b2ac f1			.pastdmark: pop af  
b2ad			endm  
# End of macro DMARK
b2ad						CALLMONITOR 
b2ad cd a3 94			call break_point_state  
b2b0				endm  
# End of macro CALLMONITOR
b2b0					endif 
b2b0			 
b2b0			;	push hl 
b2b0				FORTH_DSP_POP 
b2b0 cd c3 9d			call macro_forth_dsp_pop 
b2b3				endm 
# End of macro FORTH_DSP_POP
b2b3			 
b2b3			;	pop hl 
b2b3			 
b2b3				; test if true 
b2b3			 
b2b3 cd cb 8c			call ishlzero 
b2b6			;	ld a,l 
b2b6			;	add h 
b2b6			; 
b2b6			;	cp 0 
b2b6			 
b2b6 20 3e			jr nz, .untilnotdone 
b2b8			 
b2b8					if DEBUG_FORTH_WORDS 
b2b8						DMARK "UNf" 
b2b8 f5				push af  
b2b9 3a cd b2			ld a, (.dmark)  
b2bc 32 b7 ee			ld (debug_mark),a  
b2bf 3a ce b2			ld a, (.dmark+1)  
b2c2 32 b8 ee			ld (debug_mark+1),a  
b2c5 3a cf b2			ld a, (.dmark+2)  
b2c8 32 b9 ee			ld (debug_mark+2),a  
b2cb 18 03			jr .pastdmark  
b2cd ..			.dmark: db "UNf"  
b2d0 f1			.pastdmark: pop af  
b2d1			endm  
# End of macro DMARK
b2d1						CALLMONITOR 
b2d1 cd a3 94			call break_point_state  
b2d4				endm  
# End of macro CALLMONITOR
b2d4					endif 
b2d4			 
b2d4			 
b2d4			 
b2d4				FORTH_RSP_POP     ; get rid of DO ptr 
b2d4 cd dc 9a			call macro_forth_rsp_pop 
b2d7				endm 
# End of macro FORTH_RSP_POP
b2d7			 
b2d7			if DEBUG_FORTH_WORDS 
b2d7						DMARK "UN>" 
b2d7 f5				push af  
b2d8 3a ec b2			ld a, (.dmark)  
b2db 32 b7 ee			ld (debug_mark),a  
b2de 3a ed b2			ld a, (.dmark+1)  
b2e1 32 b8 ee			ld (debug_mark+1),a  
b2e4 3a ee b2			ld a, (.dmark+2)  
b2e7 32 b9 ee			ld (debug_mark+2),a  
b2ea 18 03			jr .pastdmark  
b2ec ..			.dmark: db "UN>"  
b2ef f1			.pastdmark: pop af  
b2f0			endm  
# End of macro DMARK
b2f0				CALLMONITOR 
b2f0 cd a3 94			call break_point_state  
b2f3				endm  
# End of macro CALLMONITOR
b2f3			endif 
b2f3			 
b2f3					NEXTW 
b2f3 c3 c1 9e			jp macro_next 
b2f6				endm 
# End of macro NEXTW
b2f6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2f6			 
b2f6			.untilnotdone: 
b2f6			 
b2f6			 
b2f6			;	; get DO ptr 
b2f6			; 
b2f6				FORTH_RSP_TOS 
b2f6 cd d2 9a			call macro_forth_rsp_tos 
b2f9				endm 
# End of macro FORTH_RSP_TOS
b2f9			 
b2f9				;push hl 
b2f9			 
b2f9				; not going to DO any more 
b2f9				; get rid of the RSP pointer as DO will add it back in 
b2f9				;FORTH_RSP_POP 
b2f9				;pop hl 
b2f9			 
b2f9			 
b2f9 22 52 e7			ld (os_tok_ptr), hl 
b2fc					if DEBUG_FORTH_WORDS 
b2fc						DMARK "UN<" 
b2fc f5				push af  
b2fd 3a 11 b3			ld a, (.dmark)  
b300 32 b7 ee			ld (debug_mark),a  
b303 3a 12 b3			ld a, (.dmark+1)  
b306 32 b8 ee			ld (debug_mark+1),a  
b309 3a 13 b3			ld a, (.dmark+2)  
b30c 32 b9 ee			ld (debug_mark+2),a  
b30f 18 03			jr .pastdmark  
b311 ..			.dmark: db "UN<"  
b314 f1			.pastdmark: pop af  
b315			endm  
# End of macro DMARK
b315					CALLMONITOR 
b315 cd a3 94			call break_point_state  
b318				endm  
# End of macro CALLMONITOR
b318				endif 
b318 c3 52 9f			jp exec1 
b31b			 
b31b					 
b31b			 
b31b			 
b31b					NEXTW 
b31b c3 c1 9e			jp macro_next 
b31e				endm 
# End of macro NEXTW
b31e			 
b31e			 
b31e			.ENDFLOW: 
b31e			 
b31e			; eof 
b31e			 
# End of file forth_words_flow.asm
b31e			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b31e			include "forth_words_logic.asm" 
b31e			 
b31e			; | ## Logic Words 
b31e			 
b31e			.NOT: 
b31e				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b31e 2d				db WORD_SYS_CORE+25             
b31f 66 b3			dw .IS            
b321 04				db 3 + 1 
b322 .. 00			db "NOT",0              
b326				endm 
# End of macro CWHEAD
b326			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b326					if DEBUG_FORTH_WORDS_KEY 
b326						DMARK "NOT" 
b326 f5				push af  
b327 3a 3b b3			ld a, (.dmark)  
b32a 32 b7 ee			ld (debug_mark),a  
b32d 3a 3c b3			ld a, (.dmark+1)  
b330 32 b8 ee			ld (debug_mark+1),a  
b333 3a 3d b3			ld a, (.dmark+2)  
b336 32 b9 ee			ld (debug_mark+2),a  
b339 18 03			jr .pastdmark  
b33b ..			.dmark: db "NOT"  
b33e f1			.pastdmark: pop af  
b33f			endm  
# End of macro DMARK
b33f						CALLMONITOR 
b33f cd a3 94			call break_point_state  
b342				endm  
# End of macro CALLMONITOR
b342					endif 
b342					FORTH_DSP 
b342 cd d1 9c			call macro_forth_dsp 
b345				endm 
# End of macro FORTH_DSP
b345 7e					ld a,(hl)	; get type of value on TOS 
b346 fe 02				cp DS_TYPE_INUM  
b348 28 03				jr z, .noti 
b34a					NEXTW 
b34a c3 c1 9e			jp macro_next 
b34d				endm 
# End of macro NEXTW
b34d			.noti:          FORTH_DSP_VALUEHL 
b34d cd 0b 9d			call macro_dsp_valuehl 
b350				endm 
# End of macro FORTH_DSP_VALUEHL
b350			;		push hl 
b350					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b350 cd c3 9d			call macro_forth_dsp_pop 
b353				endm 
# End of macro FORTH_DSP_POP
b353			;		pop hl 
b353 3e 00				ld a,0 
b355 bd					cp l 
b356 28 04				jr z, .not2t 
b358 2e 00				ld l, 0 
b35a 18 02				jr .notip 
b35c			 
b35c 2e ff		.not2t:		ld l, 255 
b35e			 
b35e 26 00		.notip:		ld h, 0	 
b360			 
b360 cd 14 9b				call forth_push_numhl 
b363					NEXTW 
b363 c3 c1 9e			jp macro_next 
b366				endm 
# End of macro NEXTW
b366			 
b366			.IS: 
b366				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b366 2d				db WORD_SYS_CORE+25             
b367 8c b3			dw .LZERO            
b369 03				db 2 + 1 
b36a .. 00			db "IS",0              
b36d				endm 
# End of macro CWHEAD
b36d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b36d					if DEBUG_FORTH_WORDS_KEY 
b36d						DMARK "IS." 
b36d f5				push af  
b36e 3a 82 b3			ld a, (.dmark)  
b371 32 b7 ee			ld (debug_mark),a  
b374 3a 83 b3			ld a, (.dmark+1)  
b377 32 b8 ee			ld (debug_mark+1),a  
b37a 3a 84 b3			ld a, (.dmark+2)  
b37d 32 b9 ee			ld (debug_mark+2),a  
b380 18 03			jr .pastdmark  
b382 ..			.dmark: db "IS."  
b385 f1			.pastdmark: pop af  
b386			endm  
# End of macro DMARK
b386						CALLMONITOR 
b386 cd a3 94			call break_point_state  
b389				endm  
# End of macro CALLMONITOR
b389					endif 
b389					NEXTW 
b389 c3 c1 9e			jp macro_next 
b38c				endm 
# End of macro NEXTW
b38c			.LZERO: 
b38c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b38c 2d				db WORD_SYS_CORE+25             
b38d 96 b3			dw .TZERO            
b38f 03				db 2 + 1 
b390 .. 00			db "0<",0              
b393				endm 
# End of macro CWHEAD
b393			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b393					NEXTW 
b393 c3 c1 9e			jp macro_next 
b396				endm 
# End of macro NEXTW
b396			.TZERO: 
b396				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b396 2e				db WORD_SYS_CORE+26             
b397 dd b3			dw .LESS            
b399 03				db 2 + 1 
b39a .. 00			db "0=",0              
b39d				endm 
# End of macro CWHEAD
b39d			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b39d				; TODO add floating point number detection 
b39d					;v5 FORTH_DSP_VALUE 
b39d					if DEBUG_FORTH_WORDS_KEY 
b39d						DMARK "0=." 
b39d f5				push af  
b39e 3a b2 b3			ld a, (.dmark)  
b3a1 32 b7 ee			ld (debug_mark),a  
b3a4 3a b3 b3			ld a, (.dmark+1)  
b3a7 32 b8 ee			ld (debug_mark+1),a  
b3aa 3a b4 b3			ld a, (.dmark+2)  
b3ad 32 b9 ee			ld (debug_mark+2),a  
b3b0 18 03			jr .pastdmark  
b3b2 ..			.dmark: db "0=."  
b3b5 f1			.pastdmark: pop af  
b3b6			endm  
# End of macro DMARK
b3b6						CALLMONITOR 
b3b6 cd a3 94			call break_point_state  
b3b9				endm  
# End of macro CALLMONITOR
b3b9					endif 
b3b9					FORTH_DSP 
b3b9 cd d1 9c			call macro_forth_dsp 
b3bc				endm 
# End of macro FORTH_DSP
b3bc 7e					ld a,(hl)	; get type of value on TOS 
b3bd fe 02				cp DS_TYPE_INUM  
b3bf 28 00				jr z, .tz_inum 
b3c1			 
b3c1				if FORTH_ENABLE_FLOATMATH 
b3c1					jr .tz_done 
b3c1			 
b3c1				endif 
b3c1					 
b3c1			 
b3c1			.tz_inum: 
b3c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c1 cd 0b 9d			call macro_dsp_valuehl 
b3c4				endm 
# End of macro FORTH_DSP_VALUEHL
b3c4			 
b3c4			;		push hl 
b3c4			 
b3c4					; destroy value TOS 
b3c4			 
b3c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c4 cd c3 9d			call macro_forth_dsp_pop 
b3c7				endm 
# End of macro FORTH_DSP_POP
b3c7			 
b3c7			;		pop hl 
b3c7			 
b3c7 3e 00				ld a,0 
b3c9			 
b3c9 bd					cp l 
b3ca 20 08				jr nz, .tz_notzero 
b3cc			 
b3cc bc					cp h 
b3cd			 
b3cd 20 05				jr nz, .tz_notzero 
b3cf			 
b3cf			 
b3cf 21 01 00				ld hl, FORTH_TRUE 
b3d2 18 03				jr .tz_done 
b3d4			 
b3d4 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b3d7			 
b3d7					; push value back onto stack for another op etc 
b3d7			 
b3d7			.tz_done: 
b3d7 cd 14 9b				call forth_push_numhl 
b3da			 
b3da					NEXTW 
b3da c3 c1 9e			jp macro_next 
b3dd				endm 
# End of macro NEXTW
b3dd			.LESS: 
b3dd				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b3dd 2f				db WORD_SYS_CORE+27             
b3de 46 b4			dw .GT            
b3e0 02				db 1 + 1 
b3e1 .. 00			db "<",0              
b3e3				endm 
# End of macro CWHEAD
b3e3			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3e3				; TODO add floating point number detection 
b3e3					if DEBUG_FORTH_WORDS_KEY 
b3e3						DMARK "LES" 
b3e3 f5				push af  
b3e4 3a f8 b3			ld a, (.dmark)  
b3e7 32 b7 ee			ld (debug_mark),a  
b3ea 3a f9 b3			ld a, (.dmark+1)  
b3ed 32 b8 ee			ld (debug_mark+1),a  
b3f0 3a fa b3			ld a, (.dmark+2)  
b3f3 32 b9 ee			ld (debug_mark+2),a  
b3f6 18 03			jr .pastdmark  
b3f8 ..			.dmark: db "LES"  
b3fb f1			.pastdmark: pop af  
b3fc			endm  
# End of macro DMARK
b3fc						CALLMONITOR 
b3fc cd a3 94			call break_point_state  
b3ff				endm  
# End of macro CALLMONITOR
b3ff					endif 
b3ff					FORTH_DSP 
b3ff cd d1 9c			call macro_forth_dsp 
b402				endm 
# End of macro FORTH_DSP
b402					;v5 FORTH_DSP_VALUE 
b402 7e					ld a,(hl)	; get type of value on TOS 
b403 fe 02				cp DS_TYPE_INUM  
b405 28 00				jr z, .less_inum 
b407			 
b407				if FORTH_ENABLE_FLOATMATH 
b407					jr .less_done 
b407			 
b407				endif 
b407					 
b407			 
b407			.less_inum: 
b407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b407 cd 0b 9d			call macro_dsp_valuehl 
b40a				endm 
# End of macro FORTH_DSP_VALUEHL
b40a			 
b40a e5					push hl  ; u2 
b40b			 
b40b					; destroy value TOS 
b40b			 
b40b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b40b cd c3 9d			call macro_forth_dsp_pop 
b40e				endm 
# End of macro FORTH_DSP_POP
b40e			 
b40e			 
b40e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b40e cd 0b 9d			call macro_dsp_valuehl 
b411				endm 
# End of macro FORTH_DSP_VALUEHL
b411			 
b411 e5					push hl    ; u1 
b412			 
b412					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b412 cd c3 9d			call macro_forth_dsp_pop 
b415				endm 
# End of macro FORTH_DSP_POP
b415			 
b415			 
b415 b7			 or a      ;clear carry flag 
b416 01 00 00		 ld bc, FORTH_FALSE 
b419 e1			  pop hl    ; u1 
b41a d1			  pop de    ; u2 
b41b ed 52		  sbc hl,de 
b41d 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b41f			 
b41f 01 01 00		 ld bc, FORTH_TRUE 
b422			.lscont:  
b422 c5					push bc 
b423 e1					pop hl 
b424			 
b424					if DEBUG_FORTH_WORDS 
b424						DMARK "LT1" 
b424 f5				push af  
b425 3a 39 b4			ld a, (.dmark)  
b428 32 b7 ee			ld (debug_mark),a  
b42b 3a 3a b4			ld a, (.dmark+1)  
b42e 32 b8 ee			ld (debug_mark+1),a  
b431 3a 3b b4			ld a, (.dmark+2)  
b434 32 b9 ee			ld (debug_mark+2),a  
b437 18 03			jr .pastdmark  
b439 ..			.dmark: db "LT1"  
b43c f1			.pastdmark: pop af  
b43d			endm  
# End of macro DMARK
b43d						CALLMONITOR 
b43d cd a3 94			call break_point_state  
b440				endm  
# End of macro CALLMONITOR
b440					endif 
b440 cd 14 9b				call forth_push_numhl 
b443			 
b443					NEXTW 
b443 c3 c1 9e			jp macro_next 
b446				endm 
# End of macro NEXTW
b446			.GT: 
b446				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b446 30				db WORD_SYS_CORE+28             
b447 af b4			dw .EQUAL            
b449 02				db 1 + 1 
b44a .. 00			db ">",0              
b44c				endm 
# End of macro CWHEAD
b44c			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b44c				; TODO add floating point number detection 
b44c					if DEBUG_FORTH_WORDS_KEY 
b44c						DMARK "GRT" 
b44c f5				push af  
b44d 3a 61 b4			ld a, (.dmark)  
b450 32 b7 ee			ld (debug_mark),a  
b453 3a 62 b4			ld a, (.dmark+1)  
b456 32 b8 ee			ld (debug_mark+1),a  
b459 3a 63 b4			ld a, (.dmark+2)  
b45c 32 b9 ee			ld (debug_mark+2),a  
b45f 18 03			jr .pastdmark  
b461 ..			.dmark: db "GRT"  
b464 f1			.pastdmark: pop af  
b465			endm  
# End of macro DMARK
b465						CALLMONITOR 
b465 cd a3 94			call break_point_state  
b468				endm  
# End of macro CALLMONITOR
b468					endif 
b468					FORTH_DSP 
b468 cd d1 9c			call macro_forth_dsp 
b46b				endm 
# End of macro FORTH_DSP
b46b					;FORTH_DSP_VALUE 
b46b 7e					ld a,(hl)	; get type of value on TOS 
b46c fe 02				cp DS_TYPE_INUM  
b46e 28 00				jr z, .gt_inum 
b470			 
b470				if FORTH_ENABLE_FLOATMATH 
b470					jr .gt_done 
b470			 
b470				endif 
b470					 
b470			 
b470			.gt_inum: 
b470					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b470 cd 0b 9d			call macro_dsp_valuehl 
b473				endm 
# End of macro FORTH_DSP_VALUEHL
b473			 
b473 e5					push hl  ; u2 
b474			 
b474					; destroy value TOS 
b474			 
b474					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b474 cd c3 9d			call macro_forth_dsp_pop 
b477				endm 
# End of macro FORTH_DSP_POP
b477			 
b477			 
b477					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b477 cd 0b 9d			call macro_dsp_valuehl 
b47a				endm 
# End of macro FORTH_DSP_VALUEHL
b47a			 
b47a e5					push hl    ; u1 
b47b			 
b47b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b47b cd c3 9d			call macro_forth_dsp_pop 
b47e				endm 
# End of macro FORTH_DSP_POP
b47e			 
b47e			 
b47e b7			 or a      ;clear carry flag 
b47f 01 00 00		 ld bc, FORTH_FALSE 
b482 e1			  pop hl    ; u1 
b483 d1			  pop de    ; u2 
b484 ed 52		  sbc hl,de 
b486 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b488			 
b488 01 01 00		 ld bc, FORTH_TRUE 
b48b			.gtcont:  
b48b c5					push bc 
b48c e1					pop hl 
b48d			 
b48d					if DEBUG_FORTH_WORDS 
b48d						DMARK "GT1" 
b48d f5				push af  
b48e 3a a2 b4			ld a, (.dmark)  
b491 32 b7 ee			ld (debug_mark),a  
b494 3a a3 b4			ld a, (.dmark+1)  
b497 32 b8 ee			ld (debug_mark+1),a  
b49a 3a a4 b4			ld a, (.dmark+2)  
b49d 32 b9 ee			ld (debug_mark+2),a  
b4a0 18 03			jr .pastdmark  
b4a2 ..			.dmark: db "GT1"  
b4a5 f1			.pastdmark: pop af  
b4a6			endm  
# End of macro DMARK
b4a6						CALLMONITOR 
b4a6 cd a3 94			call break_point_state  
b4a9				endm  
# End of macro CALLMONITOR
b4a9					endif 
b4a9 cd 14 9b				call forth_push_numhl 
b4ac			 
b4ac					NEXTW 
b4ac c3 c1 9e			jp macro_next 
b4af				endm 
# End of macro NEXTW
b4af			.EQUAL: 
b4af				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4af 31				db WORD_SYS_CORE+29             
b4b0 1a b5			dw .ENDLOGIC            
b4b2 02				db 1 + 1 
b4b3 .. 00			db "=",0              
b4b5				endm 
# End of macro CWHEAD
b4b5			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4b5				; TODO add floating point number detection 
b4b5					if DEBUG_FORTH_WORDS_KEY 
b4b5						DMARK "EQ." 
b4b5 f5				push af  
b4b6 3a ca b4			ld a, (.dmark)  
b4b9 32 b7 ee			ld (debug_mark),a  
b4bc 3a cb b4			ld a, (.dmark+1)  
b4bf 32 b8 ee			ld (debug_mark+1),a  
b4c2 3a cc b4			ld a, (.dmark+2)  
b4c5 32 b9 ee			ld (debug_mark+2),a  
b4c8 18 03			jr .pastdmark  
b4ca ..			.dmark: db "EQ."  
b4cd f1			.pastdmark: pop af  
b4ce			endm  
# End of macro DMARK
b4ce						CALLMONITOR 
b4ce cd a3 94			call break_point_state  
b4d1				endm  
# End of macro CALLMONITOR
b4d1					endif 
b4d1					FORTH_DSP 
b4d1 cd d1 9c			call macro_forth_dsp 
b4d4				endm 
# End of macro FORTH_DSP
b4d4					;v5 FORTH_DSP_VALUE 
b4d4 7e					ld a,(hl)	; get type of value on TOS 
b4d5 fe 02				cp DS_TYPE_INUM  
b4d7 28 00				jr z, .eq_inum 
b4d9			 
b4d9				if FORTH_ENABLE_FLOATMATH 
b4d9					jr .eq_done 
b4d9			 
b4d9				endif 
b4d9					 
b4d9			 
b4d9			.eq_inum: 
b4d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d9 cd 0b 9d			call macro_dsp_valuehl 
b4dc				endm 
# End of macro FORTH_DSP_VALUEHL
b4dc			 
b4dc e5					push hl 
b4dd			 
b4dd					; destroy value TOS 
b4dd			 
b4dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4dd cd c3 9d			call macro_forth_dsp_pop 
b4e0				endm 
# End of macro FORTH_DSP_POP
b4e0			 
b4e0			 
b4e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4e0 cd 0b 9d			call macro_dsp_valuehl 
b4e3				endm 
# End of macro FORTH_DSP_VALUEHL
b4e3			 
b4e3					; one value on hl get other one back 
b4e3			 
b4e3 e5					push hl 
b4e4			 
b4e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4e4 cd c3 9d			call macro_forth_dsp_pop 
b4e7				endm 
# End of macro FORTH_DSP_POP
b4e7			 
b4e7 0e 00				ld c, FORTH_FALSE 
b4e9			 
b4e9 e1					pop hl 
b4ea d1					pop de 
b4eb			 
b4eb 7b					ld a, e 
b4ec bd					cp l 
b4ed			 
b4ed 20 06				jr nz, .eq_done 
b4ef			 
b4ef 7a					ld a, d 
b4f0 bc					cp h 
b4f1			 
b4f1 20 02				jr nz, .eq_done 
b4f3			 
b4f3 0e 01				ld c, FORTH_TRUE 
b4f5					 
b4f5			 
b4f5			 
b4f5			.eq_done: 
b4f5			 
b4f5					; TODO push value back onto stack for another op etc 
b4f5			 
b4f5 26 00				ld h, 0 
b4f7 69					ld l, c 
b4f8					if DEBUG_FORTH_WORDS 
b4f8						DMARK "EQ1" 
b4f8 f5				push af  
b4f9 3a 0d b5			ld a, (.dmark)  
b4fc 32 b7 ee			ld (debug_mark),a  
b4ff 3a 0e b5			ld a, (.dmark+1)  
b502 32 b8 ee			ld (debug_mark+1),a  
b505 3a 0f b5			ld a, (.dmark+2)  
b508 32 b9 ee			ld (debug_mark+2),a  
b50b 18 03			jr .pastdmark  
b50d ..			.dmark: db "EQ1"  
b510 f1			.pastdmark: pop af  
b511			endm  
# End of macro DMARK
b511						CALLMONITOR 
b511 cd a3 94			call break_point_state  
b514				endm  
# End of macro CALLMONITOR
b514					endif 
b514 cd 14 9b				call forth_push_numhl 
b517			 
b517					NEXTW 
b517 c3 c1 9e			jp macro_next 
b51a				endm 
# End of macro NEXTW
b51a			 
b51a			 
b51a			.ENDLOGIC: 
b51a			; eof 
b51a			 
b51a			 
# End of file forth_words_logic.asm
b51a			include "forth_words_maths.asm" 
b51a			 
b51a			; | ## Maths Words 
b51a			 
b51a			.PLUS:	 
b51a				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b51a 15				db WORD_SYS_CORE+1             
b51b 78 b5			dw .NEG            
b51d 02				db 1 + 1 
b51e .. 00			db "+",0              
b520				endm 
# End of macro CWHEAD
b520			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b520					if DEBUG_FORTH_WORDS_KEY 
b520						DMARK "PLU" 
b520 f5				push af  
b521 3a 35 b5			ld a, (.dmark)  
b524 32 b7 ee			ld (debug_mark),a  
b527 3a 36 b5			ld a, (.dmark+1)  
b52a 32 b8 ee			ld (debug_mark+1),a  
b52d 3a 37 b5			ld a, (.dmark+2)  
b530 32 b9 ee			ld (debug_mark+2),a  
b533 18 03			jr .pastdmark  
b535 ..			.dmark: db "PLU"  
b538 f1			.pastdmark: pop af  
b539			endm  
# End of macro DMARK
b539						CALLMONITOR 
b539 cd a3 94			call break_point_state  
b53c				endm  
# End of macro CALLMONITOR
b53c					endif 
b53c					; add top two values and push back result 
b53c			 
b53c					;for v5 FORTH_DSP_VALUE 
b53c					FORTH_DSP 
b53c cd d1 9c			call macro_forth_dsp 
b53f				endm 
# End of macro FORTH_DSP
b53f 7e					ld a,(hl)	; get type of value on TOS 
b540 fe 02				cp DS_TYPE_INUM  
b542 28 03				jr z, .dot_inum 
b544			 
b544					NEXTW 
b544 c3 c1 9e			jp macro_next 
b547				endm 
# End of macro NEXTW
b547			 
b547			; float maths 
b547			 
b547				if FORTH_ENABLE_FLOATMATH 
b547						inc hl      ; now at start of numeric as string 
b547			 
b547					if DEBUG_FORTH_MATHS 
b547						DMARK "ADD" 
b547				CALLMONITOR 
b547					endif 
b547			 
b547					;ld ix, hl 
b547					call CON 
b547			 
b547			 
b547					push hl 
b547					 
b547					 
b547			 
b547						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b547			 
b547					; get next number 
b547			 
b547						FORTH_DSP_VALUE 
b547			 
b547						inc hl      ; now at start of numeric as string 
b547			 
b547					;ld ix, hl 
b547					call CON 
b547			 
b547					push hl 
b547			 
b547			 
b547						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b547			 
b547						; TODO do add 
b547			 
b547						call IADD 
b547			 
b547						; TODO get result back as ascii 
b547			 
b547						; TODO push result  
b547			 
b547			 
b547			 
b547						jr .dot_done 
b547				endif 
b547			 
b547			.dot_inum: 
b547			 
b547			 
b547					if DEBUG_FORTH_DOT 
b547						DMARK "+IT" 
b547 f5				push af  
b548 3a 5c b5			ld a, (.dmark)  
b54b 32 b7 ee			ld (debug_mark),a  
b54e 3a 5d b5			ld a, (.dmark+1)  
b551 32 b8 ee			ld (debug_mark+1),a  
b554 3a 5e b5			ld a, (.dmark+2)  
b557 32 b9 ee			ld (debug_mark+2),a  
b55a 18 03			jr .pastdmark  
b55c ..			.dmark: db "+IT"  
b55f f1			.pastdmark: pop af  
b560			endm  
# End of macro DMARK
b560				CALLMONITOR 
b560 cd a3 94			call break_point_state  
b563				endm  
# End of macro CALLMONITOR
b563					endif 
b563			 
b563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b563 cd 0b 9d			call macro_dsp_valuehl 
b566				endm 
# End of macro FORTH_DSP_VALUEHL
b566			 
b566				; TODO add floating point number detection 
b566			 
b566 e5					push hl 
b567			 
b567					; destroy value TOS 
b567			 
b567					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b567 cd c3 9d			call macro_forth_dsp_pop 
b56a				endm 
# End of macro FORTH_DSP_POP
b56a			 
b56a			 
b56a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b56a cd 0b 9d			call macro_dsp_valuehl 
b56d				endm 
# End of macro FORTH_DSP_VALUEHL
b56d			 
b56d					; one value on hl get other one back 
b56d			 
b56d d1					pop de 
b56e			 
b56e					; do the add 
b56e			 
b56e 19					add hl,de 
b56f			 
b56f					; save it 
b56f			 
b56f			;		push hl	 
b56f			 
b56f					; 
b56f			 
b56f					; destroy value TOS 
b56f			 
b56f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b56f cd c3 9d			call macro_forth_dsp_pop 
b572				endm 
# End of macro FORTH_DSP_POP
b572			 
b572					; TODO push value back onto stack for another op etc 
b572			 
b572			;		pop hl 
b572			 
b572			.dot_done: 
b572 cd 14 9b				call forth_push_numhl 
b575			 
b575					NEXTW 
b575 c3 c1 9e			jp macro_next 
b578				endm 
# End of macro NEXTW
b578			.NEG: 
b578			 
b578				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b578 17				db WORD_SYS_CORE+3             
b579 bb b5			dw .DIV            
b57b 02				db 1 + 1 
b57c .. 00			db "-",0              
b57e				endm 
# End of macro CWHEAD
b57e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b57e					if DEBUG_FORTH_WORDS_KEY 
b57e						DMARK "SUB" 
b57e f5				push af  
b57f 3a 93 b5			ld a, (.dmark)  
b582 32 b7 ee			ld (debug_mark),a  
b585 3a 94 b5			ld a, (.dmark+1)  
b588 32 b8 ee			ld (debug_mark+1),a  
b58b 3a 95 b5			ld a, (.dmark+2)  
b58e 32 b9 ee			ld (debug_mark+2),a  
b591 18 03			jr .pastdmark  
b593 ..			.dmark: db "SUB"  
b596 f1			.pastdmark: pop af  
b597			endm  
# End of macro DMARK
b597						CALLMONITOR 
b597 cd a3 94			call break_point_state  
b59a				endm  
# End of macro CALLMONITOR
b59a					endif 
b59a			 
b59a			 
b59a				; TODO add floating point number detection 
b59a					; v5 FORTH_DSP_VALUE 
b59a					FORTH_DSP 
b59a cd d1 9c			call macro_forth_dsp 
b59d				endm 
# End of macro FORTH_DSP
b59d 7e					ld a,(hl)	; get type of value on TOS 
b59e fe 02				cp DS_TYPE_INUM  
b5a0 28 03				jr z, .neg_inum 
b5a2			 
b5a2					NEXTW 
b5a2 c3 c1 9e			jp macro_next 
b5a5				endm 
# End of macro NEXTW
b5a5			 
b5a5			; float maths 
b5a5			 
b5a5				if FORTH_ENABLE_FLOATMATH 
b5a5					jr .neg_done 
b5a5			 
b5a5				endif 
b5a5					 
b5a5			 
b5a5			.neg_inum: 
b5a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a5 cd 0b 9d			call macro_dsp_valuehl 
b5a8				endm 
# End of macro FORTH_DSP_VALUEHL
b5a8			 
b5a8 e5					push hl 
b5a9			 
b5a9					; destroy value TOS 
b5a9			 
b5a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a9 cd c3 9d			call macro_forth_dsp_pop 
b5ac				endm 
# End of macro FORTH_DSP_POP
b5ac			 
b5ac			 
b5ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ac cd 0b 9d			call macro_dsp_valuehl 
b5af				endm 
# End of macro FORTH_DSP_VALUEHL
b5af			 
b5af					; one value on hl get other one back 
b5af			 
b5af d1					pop de 
b5b0			 
b5b0					; do the sub 
b5b0			;		ex de, hl 
b5b0			 
b5b0 ed 52				sbc hl,de 
b5b2			 
b5b2					; save it 
b5b2			 
b5b2			;		push hl	 
b5b2			 
b5b2					; 
b5b2			 
b5b2					; destroy value TOS 
b5b2			 
b5b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5b2 cd c3 9d			call macro_forth_dsp_pop 
b5b5				endm 
# End of macro FORTH_DSP_POP
b5b5			 
b5b5					; TODO push value back onto stack for another op etc 
b5b5			 
b5b5			;		pop hl 
b5b5			 
b5b5 cd 14 9b				call forth_push_numhl 
b5b8			.neg_done: 
b5b8			 
b5b8					NEXTW 
b5b8 c3 c1 9e			jp macro_next 
b5bb				endm 
# End of macro NEXTW
b5bb			.DIV: 
b5bb				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5bb 18				db WORD_SYS_CORE+4             
b5bc 08 b6			dw .MUL            
b5be 02				db 1 + 1 
b5bf .. 00			db "/",0              
b5c1				endm 
# End of macro CWHEAD
b5c1			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5c1					if DEBUG_FORTH_WORDS_KEY 
b5c1						DMARK "DIV" 
b5c1 f5				push af  
b5c2 3a d6 b5			ld a, (.dmark)  
b5c5 32 b7 ee			ld (debug_mark),a  
b5c8 3a d7 b5			ld a, (.dmark+1)  
b5cb 32 b8 ee			ld (debug_mark+1),a  
b5ce 3a d8 b5			ld a, (.dmark+2)  
b5d1 32 b9 ee			ld (debug_mark+2),a  
b5d4 18 03			jr .pastdmark  
b5d6 ..			.dmark: db "DIV"  
b5d9 f1			.pastdmark: pop af  
b5da			endm  
# End of macro DMARK
b5da						CALLMONITOR 
b5da cd a3 94			call break_point_state  
b5dd				endm  
# End of macro CALLMONITOR
b5dd					endif 
b5dd				; TODO add floating point number detection 
b5dd					; v5 FORTH_DSP_VALUE 
b5dd					FORTH_DSP 
b5dd cd d1 9c			call macro_forth_dsp 
b5e0				endm 
# End of macro FORTH_DSP
b5e0 7e					ld a,(hl)	; get type of value on TOS 
b5e1 fe 02				cp DS_TYPE_INUM  
b5e3 28 03				jr z, .div_inum 
b5e5			 
b5e5				if FORTH_ENABLE_FLOATMATH 
b5e5					jr .div_done 
b5e5			 
b5e5				endif 
b5e5					NEXTW 
b5e5 c3 c1 9e			jp macro_next 
b5e8				endm 
# End of macro NEXTW
b5e8			.div_inum: 
b5e8			 
b5e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e8 cd 0b 9d			call macro_dsp_valuehl 
b5eb				endm 
# End of macro FORTH_DSP_VALUEHL
b5eb			 
b5eb e5					push hl    ; to go to bc 
b5ec			 
b5ec					; destroy value TOS 
b5ec			 
b5ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ec cd c3 9d			call macro_forth_dsp_pop 
b5ef				endm 
# End of macro FORTH_DSP_POP
b5ef			 
b5ef			 
b5ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ef cd 0b 9d			call macro_dsp_valuehl 
b5f2				endm 
# End of macro FORTH_DSP_VALUEHL
b5f2			 
b5f2					; hl to go to de 
b5f2			 
b5f2 e5					push hl 
b5f3			 
b5f3 c1					pop bc 
b5f4 d1					pop de		 
b5f5			 
b5f5			 
b5f5					if DEBUG_FORTH_MATHS 
b5f5						DMARK "DIV" 
b5f5				CALLMONITOR 
b5f5					endif 
b5f5					; one value on hl but move to a get other one back 
b5f5			 
b5f5			        
b5f5 cd ff 8b			call Div16 
b5f8			 
b5f8			;	push af	 
b5f8 e5				push hl 
b5f9 c5				push bc 
b5fa			 
b5fa					if DEBUG_FORTH_MATHS 
b5fa						DMARK "DI1" 
b5fa				CALLMONITOR 
b5fa					endif 
b5fa			 
b5fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5fa cd c3 9d			call macro_forth_dsp_pop 
b5fd				endm 
# End of macro FORTH_DSP_POP
b5fd			 
b5fd			 
b5fd			 
b5fd e1					pop hl    ; result 
b5fe			 
b5fe cd 14 9b				call forth_push_numhl 
b601			 
b601 e1					pop hl    ; reminder 
b602			;		ld h,0 
b602			;		ld l,d 
b602			 
b602 cd 14 9b				call forth_push_numhl 
b605			.div_done: 
b605					NEXTW 
b605 c3 c1 9e			jp macro_next 
b608				endm 
# End of macro NEXTW
b608			.MUL: 
b608				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b608 19				db WORD_SYS_CORE+5             
b609 4d b6			dw .MIN            
b60b 02				db 1 + 1 
b60c .. 00			db "*",0              
b60e				endm 
# End of macro CWHEAD
b60e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b60e				; TODO add floating point number detection 
b60e					if DEBUG_FORTH_WORDS_KEY 
b60e						DMARK "MUL" 
b60e f5				push af  
b60f 3a 23 b6			ld a, (.dmark)  
b612 32 b7 ee			ld (debug_mark),a  
b615 3a 24 b6			ld a, (.dmark+1)  
b618 32 b8 ee			ld (debug_mark+1),a  
b61b 3a 25 b6			ld a, (.dmark+2)  
b61e 32 b9 ee			ld (debug_mark+2),a  
b621 18 03			jr .pastdmark  
b623 ..			.dmark: db "MUL"  
b626 f1			.pastdmark: pop af  
b627			endm  
# End of macro DMARK
b627						CALLMONITOR 
b627 cd a3 94			call break_point_state  
b62a				endm  
# End of macro CALLMONITOR
b62a					endif 
b62a					FORTH_DSP 
b62a cd d1 9c			call macro_forth_dsp 
b62d				endm 
# End of macro FORTH_DSP
b62d					; v5 FORTH_DSP_VALUE 
b62d 7e					ld a,(hl)	; get type of value on TOS 
b62e fe 02				cp DS_TYPE_INUM  
b630 28 03				jr z, .mul_inum 
b632			 
b632				if FORTH_ENABLE_FLOATMATH 
b632					jr .mul_done 
b632			 
b632				endif 
b632			 
b632					NEXTW 
b632 c3 c1 9e			jp macro_next 
b635				endm 
# End of macro NEXTW
b635			.mul_inum:	 
b635			 
b635					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b635 cd 0b 9d			call macro_dsp_valuehl 
b638				endm 
# End of macro FORTH_DSP_VALUEHL
b638			 
b638 e5					push hl 
b639			 
b639					; destroy value TOS 
b639			 
b639					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b639 cd c3 9d			call macro_forth_dsp_pop 
b63c				endm 
# End of macro FORTH_DSP_POP
b63c			 
b63c			 
b63c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b63c cd 0b 9d			call macro_dsp_valuehl 
b63f				endm 
# End of macro FORTH_DSP_VALUEHL
b63f			 
b63f					; one value on hl but move to a get other one back 
b63f			 
b63f 7d					ld a, l 
b640			 
b640 d1					pop de 
b641			 
b641					; do the mull 
b641			;		ex de, hl 
b641			 
b641 cd 25 8c				call Mult16 
b644					; save it 
b644			 
b644			;		push hl	 
b644			 
b644					; 
b644			 
b644					; destroy value TOS 
b644			 
b644					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b644 cd c3 9d			call macro_forth_dsp_pop 
b647				endm 
# End of macro FORTH_DSP_POP
b647			 
b647					; TODO push value back onto stack for another op etc 
b647			 
b647			;		pop hl 
b647			 
b647 cd 14 9b				call forth_push_numhl 
b64a			 
b64a			.mul_done: 
b64a					NEXTW 
b64a c3 c1 9e			jp macro_next 
b64d				endm 
# End of macro NEXTW
b64d			 
b64d			 
b64d			 
b64d			 
b64d			.MIN: 
b64d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b64d 49				db WORD_SYS_CORE+53             
b64e ce b6			dw .MAX            
b650 04				db 3 + 1 
b651 .. 00			db "MIN",0              
b655				endm 
# End of macro CWHEAD
b655			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b655					if DEBUG_FORTH_WORDS_KEY 
b655						DMARK "MIN" 
b655 f5				push af  
b656 3a 6a b6			ld a, (.dmark)  
b659 32 b7 ee			ld (debug_mark),a  
b65c 3a 6b b6			ld a, (.dmark+1)  
b65f 32 b8 ee			ld (debug_mark+1),a  
b662 3a 6c b6			ld a, (.dmark+2)  
b665 32 b9 ee			ld (debug_mark+2),a  
b668 18 03			jr .pastdmark  
b66a ..			.dmark: db "MIN"  
b66d f1			.pastdmark: pop af  
b66e			endm  
# End of macro DMARK
b66e						CALLMONITOR 
b66e cd a3 94			call break_point_state  
b671				endm  
# End of macro CALLMONITOR
b671					endif 
b671					; get u2 
b671			 
b671					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b671 cd 0b 9d			call macro_dsp_valuehl 
b674				endm 
# End of macro FORTH_DSP_VALUEHL
b674			 
b674 e5					push hl   ; u2 
b675			 
b675					; destroy value TOS 
b675			 
b675					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b675 cd c3 9d			call macro_forth_dsp_pop 
b678				endm 
# End of macro FORTH_DSP_POP
b678			 
b678					; get u1 
b678			 
b678					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b678 cd 0b 9d			call macro_dsp_valuehl 
b67b				endm 
# End of macro FORTH_DSP_VALUEHL
b67b			 
b67b e5					push hl  ; u1 
b67c			 
b67c					; destroy value TOS 
b67c			 
b67c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b67c cd c3 9d			call macro_forth_dsp_pop 
b67f				endm 
# End of macro FORTH_DSP_POP
b67f			 
b67f b7			 or a      ;clear carry flag 
b680 e1			  pop hl    ; u1 
b681 d1			  pop de    ; u2 
b682 e5				push hl   ; saved in case hl is lowest 
b683 ed 52		  sbc hl,de 
b685 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b687			 
b687 e1				pop hl 
b688					if DEBUG_FORTH_WORDS 
b688						DMARK "MIN" 
b688 f5				push af  
b689 3a 9d b6			ld a, (.dmark)  
b68c 32 b7 ee			ld (debug_mark),a  
b68f 3a 9e b6			ld a, (.dmark+1)  
b692 32 b8 ee			ld (debug_mark+1),a  
b695 3a 9f b6			ld a, (.dmark+2)  
b698 32 b9 ee			ld (debug_mark+2),a  
b69b 18 03			jr .pastdmark  
b69d ..			.dmark: db "MIN"  
b6a0 f1			.pastdmark: pop af  
b6a1			endm  
# End of macro DMARK
b6a1						CALLMONITOR 
b6a1 cd a3 94			call break_point_state  
b6a4				endm  
# End of macro CALLMONITOR
b6a4					endif 
b6a4 cd 14 9b				call forth_push_numhl 
b6a7			 
b6a7				       NEXTW 
b6a7 c3 c1 9e			jp macro_next 
b6aa				endm 
# End of macro NEXTW
b6aa			 
b6aa			.mincont:  
b6aa c1				pop bc   ; tidy up 
b6ab eb				ex de , hl  
b6ac					if DEBUG_FORTH_WORDS 
b6ac						DMARK "MI1" 
b6ac f5				push af  
b6ad 3a c1 b6			ld a, (.dmark)  
b6b0 32 b7 ee			ld (debug_mark),a  
b6b3 3a c2 b6			ld a, (.dmark+1)  
b6b6 32 b8 ee			ld (debug_mark+1),a  
b6b9 3a c3 b6			ld a, (.dmark+2)  
b6bc 32 b9 ee			ld (debug_mark+2),a  
b6bf 18 03			jr .pastdmark  
b6c1 ..			.dmark: db "MI1"  
b6c4 f1			.pastdmark: pop af  
b6c5			endm  
# End of macro DMARK
b6c5						CALLMONITOR 
b6c5 cd a3 94			call break_point_state  
b6c8				endm  
# End of macro CALLMONITOR
b6c8					endif 
b6c8 cd 14 9b				call forth_push_numhl 
b6cb			 
b6cb				       NEXTW 
b6cb c3 c1 9e			jp macro_next 
b6ce				endm 
# End of macro NEXTW
b6ce			.MAX: 
b6ce				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b6ce 4a				db WORD_SYS_CORE+54             
b6cf 4f b7			dw .RND16            
b6d1 04				db 3 + 1 
b6d2 .. 00			db "MAX",0              
b6d6				endm 
# End of macro CWHEAD
b6d6			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b6d6					if DEBUG_FORTH_WORDS_KEY 
b6d6						DMARK "MAX" 
b6d6 f5				push af  
b6d7 3a eb b6			ld a, (.dmark)  
b6da 32 b7 ee			ld (debug_mark),a  
b6dd 3a ec b6			ld a, (.dmark+1)  
b6e0 32 b8 ee			ld (debug_mark+1),a  
b6e3 3a ed b6			ld a, (.dmark+2)  
b6e6 32 b9 ee			ld (debug_mark+2),a  
b6e9 18 03			jr .pastdmark  
b6eb ..			.dmark: db "MAX"  
b6ee f1			.pastdmark: pop af  
b6ef			endm  
# End of macro DMARK
b6ef						CALLMONITOR 
b6ef cd a3 94			call break_point_state  
b6f2				endm  
# End of macro CALLMONITOR
b6f2					endif 
b6f2					; get u2 
b6f2			 
b6f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f2 cd 0b 9d			call macro_dsp_valuehl 
b6f5				endm 
# End of macro FORTH_DSP_VALUEHL
b6f5			 
b6f5 e5					push hl   ; u2 
b6f6			 
b6f6					; destroy value TOS 
b6f6			 
b6f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6f6 cd c3 9d			call macro_forth_dsp_pop 
b6f9				endm 
# End of macro FORTH_DSP_POP
b6f9			 
b6f9					; get u1 
b6f9			 
b6f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f9 cd 0b 9d			call macro_dsp_valuehl 
b6fc				endm 
# End of macro FORTH_DSP_VALUEHL
b6fc			 
b6fc e5					push hl  ; u1 
b6fd			 
b6fd					; destroy value TOS 
b6fd			 
b6fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fd cd c3 9d			call macro_forth_dsp_pop 
b700				endm 
# End of macro FORTH_DSP_POP
b700			 
b700 b7			 or a      ;clear carry flag 
b701 e1			  pop hl    ; u1 
b702 d1			  pop de    ; u2 
b703 e5				push hl   ; saved in case hl is lowest 
b704 ed 52		  sbc hl,de 
b706 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b708			 
b708 e1				pop hl 
b709					if DEBUG_FORTH_WORDS 
b709						DMARK "MAX" 
b709 f5				push af  
b70a 3a 1e b7			ld a, (.dmark)  
b70d 32 b7 ee			ld (debug_mark),a  
b710 3a 1f b7			ld a, (.dmark+1)  
b713 32 b8 ee			ld (debug_mark+1),a  
b716 3a 20 b7			ld a, (.dmark+2)  
b719 32 b9 ee			ld (debug_mark+2),a  
b71c 18 03			jr .pastdmark  
b71e ..			.dmark: db "MAX"  
b721 f1			.pastdmark: pop af  
b722			endm  
# End of macro DMARK
b722						CALLMONITOR 
b722 cd a3 94			call break_point_state  
b725				endm  
# End of macro CALLMONITOR
b725					endif 
b725 cd 14 9b				call forth_push_numhl 
b728			 
b728				       NEXTW 
b728 c3 c1 9e			jp macro_next 
b72b				endm 
# End of macro NEXTW
b72b			 
b72b			.maxcont:  
b72b c1				pop bc   ; tidy up 
b72c eb				ex de , hl  
b72d					if DEBUG_FORTH_WORDS 
b72d						DMARK "MA1" 
b72d f5				push af  
b72e 3a 42 b7			ld a, (.dmark)  
b731 32 b7 ee			ld (debug_mark),a  
b734 3a 43 b7			ld a, (.dmark+1)  
b737 32 b8 ee			ld (debug_mark+1),a  
b73a 3a 44 b7			ld a, (.dmark+2)  
b73d 32 b9 ee			ld (debug_mark+2),a  
b740 18 03			jr .pastdmark  
b742 ..			.dmark: db "MA1"  
b745 f1			.pastdmark: pop af  
b746			endm  
# End of macro DMARK
b746						CALLMONITOR 
b746 cd a3 94			call break_point_state  
b749				endm  
# End of macro CALLMONITOR
b749					endif 
b749 cd 14 9b				call forth_push_numhl 
b74c				       NEXTW 
b74c c3 c1 9e			jp macro_next 
b74f				endm 
# End of macro NEXTW
b74f			 
b74f			.RND16: 
b74f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b74f 4e				db WORD_SYS_CORE+58             
b750 7e b7			dw .RND8            
b752 06				db 5 + 1 
b753 .. 00			db "RND16",0              
b759				endm 
# End of macro CWHEAD
b759			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b759					if DEBUG_FORTH_WORDS_KEY 
b759						DMARK "R16" 
b759 f5				push af  
b75a 3a 6e b7			ld a, (.dmark)  
b75d 32 b7 ee			ld (debug_mark),a  
b760 3a 6f b7			ld a, (.dmark+1)  
b763 32 b8 ee			ld (debug_mark+1),a  
b766 3a 70 b7			ld a, (.dmark+2)  
b769 32 b9 ee			ld (debug_mark+2),a  
b76c 18 03			jr .pastdmark  
b76e ..			.dmark: db "R16"  
b771 f1			.pastdmark: pop af  
b772			endm  
# End of macro DMARK
b772						CALLMONITOR 
b772 cd a3 94			call break_point_state  
b775				endm  
# End of macro CALLMONITOR
b775					endif 
b775 cd c9 8b				call prng16  
b778 cd 14 9b				call forth_push_numhl 
b77b				       NEXTW 
b77b c3 c1 9e			jp macro_next 
b77e				endm 
# End of macro NEXTW
b77e			.RND8: 
b77e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b77e 60				db WORD_SYS_CORE+76             
b77f b3 b7			dw .RND            
b781 05				db 4 + 1 
b782 .. 00			db "RND8",0              
b787				endm 
# End of macro CWHEAD
b787			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b787					if DEBUG_FORTH_WORDS_KEY 
b787						DMARK "RN8" 
b787 f5				push af  
b788 3a 9c b7			ld a, (.dmark)  
b78b 32 b7 ee			ld (debug_mark),a  
b78e 3a 9d b7			ld a, (.dmark+1)  
b791 32 b8 ee			ld (debug_mark+1),a  
b794 3a 9e b7			ld a, (.dmark+2)  
b797 32 b9 ee			ld (debug_mark+2),a  
b79a 18 03			jr .pastdmark  
b79c ..			.dmark: db "RN8"  
b79f f1			.pastdmark: pop af  
b7a0			endm  
# End of macro DMARK
b7a0						CALLMONITOR 
b7a0 cd a3 94			call break_point_state  
b7a3				endm  
# End of macro CALLMONITOR
b7a3					endif 
b7a3 2a 38 ed				ld hl,(xrandc) 
b7a6 23					inc hl 
b7a7 cd e3 8b				call xrnd 
b7aa 6f					ld l,a	 
b7ab 26 00				ld h,0 
b7ad cd 14 9b				call forth_push_numhl 
b7b0				       NEXTW 
b7b0 c3 c1 9e			jp macro_next 
b7b3				endm 
# End of macro NEXTW
b7b3			.RND: 
b7b3				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7b3 60				db WORD_SYS_CORE+76             
b7b4 b9 b8			dw .ENDMATHS            
b7b6 04				db 3 + 1 
b7b7 .. 00			db "RND",0              
b7bb				endm 
# End of macro CWHEAD
b7bb			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7bb			 
b7bb					if DEBUG_FORTH_WORDS_KEY 
b7bb						DMARK "RND" 
b7bb f5				push af  
b7bc 3a d0 b7			ld a, (.dmark)  
b7bf 32 b7 ee			ld (debug_mark),a  
b7c2 3a d1 b7			ld a, (.dmark+1)  
b7c5 32 b8 ee			ld (debug_mark+1),a  
b7c8 3a d2 b7			ld a, (.dmark+2)  
b7cb 32 b9 ee			ld (debug_mark+2),a  
b7ce 18 03			jr .pastdmark  
b7d0 ..			.dmark: db "RND"  
b7d3 f1			.pastdmark: pop af  
b7d4			endm  
# End of macro DMARK
b7d4						CALLMONITOR 
b7d4 cd a3 94			call break_point_state  
b7d7				endm  
# End of macro CALLMONITOR
b7d7					endif 
b7d7					 
b7d7					FORTH_DSP_VALUEHL    ; upper range 
b7d7 cd 0b 9d			call macro_dsp_valuehl 
b7da				endm 
# End of macro FORTH_DSP_VALUEHL
b7da			 
b7da 22 3c ed				ld (LFSRSeed), hl	 
b7dd			 
b7dd					if DEBUG_FORTH_WORDS 
b7dd						DMARK "RN1" 
b7dd f5				push af  
b7de 3a f2 b7			ld a, (.dmark)  
b7e1 32 b7 ee			ld (debug_mark),a  
b7e4 3a f3 b7			ld a, (.dmark+1)  
b7e7 32 b8 ee			ld (debug_mark+1),a  
b7ea 3a f4 b7			ld a, (.dmark+2)  
b7ed 32 b9 ee			ld (debug_mark+2),a  
b7f0 18 03			jr .pastdmark  
b7f2 ..			.dmark: db "RN1"  
b7f5 f1			.pastdmark: pop af  
b7f6			endm  
# End of macro DMARK
b7f6						CALLMONITOR 
b7f6 cd a3 94			call break_point_state  
b7f9				endm  
# End of macro CALLMONITOR
b7f9					endif 
b7f9					FORTH_DSP_POP 
b7f9 cd c3 9d			call macro_forth_dsp_pop 
b7fc				endm 
# End of macro FORTH_DSP_POP
b7fc			 
b7fc					FORTH_DSP_VALUEHL    ; low range 
b7fc cd 0b 9d			call macro_dsp_valuehl 
b7ff				endm 
# End of macro FORTH_DSP_VALUEHL
b7ff			 
b7ff					if DEBUG_FORTH_WORDS 
b7ff						DMARK "RN2" 
b7ff f5				push af  
b800 3a 14 b8			ld a, (.dmark)  
b803 32 b7 ee			ld (debug_mark),a  
b806 3a 15 b8			ld a, (.dmark+1)  
b809 32 b8 ee			ld (debug_mark+1),a  
b80c 3a 16 b8			ld a, (.dmark+2)  
b80f 32 b9 ee			ld (debug_mark+2),a  
b812 18 03			jr .pastdmark  
b814 ..			.dmark: db "RN2"  
b817 f1			.pastdmark: pop af  
b818			endm  
# End of macro DMARK
b818						CALLMONITOR 
b818 cd a3 94			call break_point_state  
b81b				endm  
# End of macro CALLMONITOR
b81b					endif 
b81b 22 3e ed				ld (LFSRSeed+2), hl 
b81e			 
b81e					FORTH_DSP_POP 
b81e cd c3 9d			call macro_forth_dsp_pop 
b821				endm 
# End of macro FORTH_DSP_POP
b821			 
b821 e5					push hl 
b822			 
b822 e1			.inrange:	pop hl 
b823 cd c9 8b				call prng16  
b826					if DEBUG_FORTH_WORDS 
b826						DMARK "RN3" 
b826 f5				push af  
b827 3a 3b b8			ld a, (.dmark)  
b82a 32 b7 ee			ld (debug_mark),a  
b82d 3a 3c b8			ld a, (.dmark+1)  
b830 32 b8 ee			ld (debug_mark+1),a  
b833 3a 3d b8			ld a, (.dmark+2)  
b836 32 b9 ee			ld (debug_mark+2),a  
b839 18 03			jr .pastdmark  
b83b ..			.dmark: db "RN3"  
b83e f1			.pastdmark: pop af  
b83f			endm  
# End of macro DMARK
b83f						CALLMONITOR 
b83f cd a3 94			call break_point_state  
b842				endm  
# End of macro CALLMONITOR
b842					endif 
b842					 
b842					; if the range is 8bit knock out the high byte 
b842			 
b842 ed 5b 3c ed			ld de, (LFSRSeed)     ; check high level 
b846			 
b846 3e 00				ld a, 0 
b848 ba					cp d  
b849 20 1e				jr nz, .hirange 
b84b 26 00				ld h, 0   ; knock it down to 8bit 
b84d			 
b84d					if DEBUG_FORTH_WORDS 
b84d						DMARK "RNk" 
b84d f5				push af  
b84e 3a 62 b8			ld a, (.dmark)  
b851 32 b7 ee			ld (debug_mark),a  
b854 3a 63 b8			ld a, (.dmark+1)  
b857 32 b8 ee			ld (debug_mark+1),a  
b85a 3a 64 b8			ld a, (.dmark+2)  
b85d 32 b9 ee			ld (debug_mark+2),a  
b860 18 03			jr .pastdmark  
b862 ..			.dmark: db "RNk"  
b865 f1			.pastdmark: pop af  
b866			endm  
# End of macro DMARK
b866						CALLMONITOR 
b866 cd a3 94			call break_point_state  
b869				endm  
# End of macro CALLMONITOR
b869					endif 
b869			.hirange:   
b869 e5					push hl  
b86a b7					or a  
b86b ed 52		                sbc hl, de 
b86d			 
b86d					;call cmp16 
b86d			 
b86d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b86f e1					pop hl 
b870 e5					push hl 
b871			 
b871					if DEBUG_FORTH_WORDS 
b871						DMARK "RN4" 
b871 f5				push af  
b872 3a 86 b8			ld a, (.dmark)  
b875 32 b7 ee			ld (debug_mark),a  
b878 3a 87 b8			ld a, (.dmark+1)  
b87b 32 b8 ee			ld (debug_mark+1),a  
b87e 3a 88 b8			ld a, (.dmark+2)  
b881 32 b9 ee			ld (debug_mark+2),a  
b884 18 03			jr .pastdmark  
b886 ..			.dmark: db "RN4"  
b889 f1			.pastdmark: pop af  
b88a			endm  
# End of macro DMARK
b88a						CALLMONITOR 
b88a cd a3 94			call break_point_state  
b88d				endm  
# End of macro CALLMONITOR
b88d					endif 
b88d ed 5b 3e ed			ld de, (LFSRSeed+2)   ; check low range 
b891					;call cmp16 
b891				 
b891 b7					or a  
b892 ed 52		                sbc hl, de 
b894 38 8c				jr c, .inrange 
b896			 
b896 e1					pop hl 
b897					 
b897					if DEBUG_FORTH_WORDS 
b897						DMARK "RNd" 
b897 f5				push af  
b898 3a ac b8			ld a, (.dmark)  
b89b 32 b7 ee			ld (debug_mark),a  
b89e 3a ad b8			ld a, (.dmark+1)  
b8a1 32 b8 ee			ld (debug_mark+1),a  
b8a4 3a ae b8			ld a, (.dmark+2)  
b8a7 32 b9 ee			ld (debug_mark+2),a  
b8aa 18 03			jr .pastdmark  
b8ac ..			.dmark: db "RNd"  
b8af f1			.pastdmark: pop af  
b8b0			endm  
# End of macro DMARK
b8b0						CALLMONITOR 
b8b0 cd a3 94			call break_point_state  
b8b3				endm  
# End of macro CALLMONITOR
b8b3					endif 
b8b3			 
b8b3			 
b8b3 cd 14 9b				call forth_push_numhl 
b8b6				       NEXTW 
b8b6 c3 c1 9e			jp macro_next 
b8b9				endm 
# End of macro NEXTW
b8b9			 
b8b9			.ENDMATHS: 
b8b9			 
b8b9			; eof 
b8b9			 
# End of file forth_words_maths.asm
b8b9			include "forth_words_display.asm" 
b8b9			 
b8b9			; | ## Display Words 
b8b9			 
b8b9			.INFO: 
b8b9			 
b8b9				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b8b9 62				db WORD_SYS_CORE+78             
b8ba d6 b8			dw .ATP            
b8bc 05				db 4 + 1 
b8bd .. 00			db "INFO",0              
b8c2				endm 
# End of macro CWHEAD
b8c2			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b8c2					FORTH_DSP_VALUEHL 
b8c2 cd 0b 9d			call macro_dsp_valuehl 
b8c5				endm 
# End of macro FORTH_DSP_VALUEHL
b8c5			 
b8c5					FORTH_DSP_POP 
b8c5 cd c3 9d			call macro_forth_dsp_pop 
b8c8				endm 
# End of macro FORTH_DSP_POP
b8c8			 
b8c8 e5					push hl 
b8c9			 
b8c9					FORTH_DSP_VALUEHL 
b8c9 cd 0b 9d			call macro_dsp_valuehl 
b8cc				endm 
# End of macro FORTH_DSP_VALUEHL
b8cc			 
b8cc					FORTH_DSP_POP 
b8cc cd c3 9d			call macro_forth_dsp_pop 
b8cf				endm 
# End of macro FORTH_DSP_POP
b8cf			 
b8cf d1					pop de 
b8d0			 
b8d0 cd 06 8a				call info_panel 
b8d3			 
b8d3			 
b8d3					NEXTW 
b8d3 c3 c1 9e			jp macro_next 
b8d6				endm 
# End of macro NEXTW
b8d6			.ATP: 
b8d6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b8d6 62				db WORD_SYS_CORE+78             
b8d7 4d b9			dw .FB            
b8d9 04				db 3 + 1 
b8da .. 00			db "AT?",0              
b8de				endm 
# End of macro CWHEAD
b8de			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b8de					if DEBUG_FORTH_WORDS_KEY 
b8de						DMARK "AT?" 
b8de f5				push af  
b8df 3a f3 b8			ld a, (.dmark)  
b8e2 32 b7 ee			ld (debug_mark),a  
b8e5 3a f4 b8			ld a, (.dmark+1)  
b8e8 32 b8 ee			ld (debug_mark+1),a  
b8eb 3a f5 b8			ld a, (.dmark+2)  
b8ee 32 b9 ee			ld (debug_mark+2),a  
b8f1 18 03			jr .pastdmark  
b8f3 ..			.dmark: db "AT?"  
b8f6 f1			.pastdmark: pop af  
b8f7			endm  
# End of macro DMARK
b8f7						CALLMONITOR 
b8f7 cd a3 94			call break_point_state  
b8fa				endm  
# End of macro CALLMONITOR
b8fa					endif 
b8fa 3a ee eb				ld a, (f_cursor_ptr) 
b8fd			 
b8fd			if DEBUG_FORTH_WORDS 
b8fd				DMARK "AT?" 
b8fd f5				push af  
b8fe 3a 12 b9			ld a, (.dmark)  
b901 32 b7 ee			ld (debug_mark),a  
b904 3a 13 b9			ld a, (.dmark+1)  
b907 32 b8 ee			ld (debug_mark+1),a  
b90a 3a 14 b9			ld a, (.dmark+2)  
b90d 32 b9 ee			ld (debug_mark+2),a  
b910 18 03			jr .pastdmark  
b912 ..			.dmark: db "AT?"  
b915 f1			.pastdmark: pop af  
b916			endm  
# End of macro DMARK
b916				CALLMONITOR 
b916 cd a3 94			call break_point_state  
b919				endm  
# End of macro CALLMONITOR
b919			endif	 
b919					; count the number of rows 
b919			 
b919 06 00				ld b, 0 
b91b 4f			.atpr:		ld c, a    ; save in case we go below zero 
b91c d6 14				sub display_cols 
b91e f2 24 b9				jp p, .atprunder 
b921 04					inc b 
b922 18 f7				jr .atpr 
b924			.atprunder:	 
b924			if DEBUG_FORTH_WORDS 
b924				DMARK "A?2" 
b924 f5				push af  
b925 3a 39 b9			ld a, (.dmark)  
b928 32 b7 ee			ld (debug_mark),a  
b92b 3a 3a b9			ld a, (.dmark+1)  
b92e 32 b8 ee			ld (debug_mark+1),a  
b931 3a 3b b9			ld a, (.dmark+2)  
b934 32 b9 ee			ld (debug_mark+2),a  
b937 18 03			jr .pastdmark  
b939 ..			.dmark: db "A?2"  
b93c f1			.pastdmark: pop af  
b93d			endm  
# End of macro DMARK
b93d				CALLMONITOR 
b93d cd a3 94			call break_point_state  
b940				endm  
# End of macro CALLMONITOR
b940			endif	 
b940 26 00				ld h, 0 
b942 69					ld l, c 
b943 cd 14 9b				call forth_push_numhl 
b946 68					ld l, b  
b947 cd 14 9b				call forth_push_numhl 
b94a			 
b94a			 
b94a				NEXTW 
b94a c3 c1 9e			jp macro_next 
b94d				endm 
# End of macro NEXTW
b94d			 
b94d			.FB: 
b94d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b94d 1b				db WORD_SYS_CORE+7             
b94e 9b b9			dw .EMIT            
b950 03				db 2 + 1 
b951 .. 00			db "FB",0              
b954				endm 
# End of macro CWHEAD
b954			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b954			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b954			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b954			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b954					if DEBUG_FORTH_WORDS_KEY 
b954						DMARK "FB." 
b954 f5				push af  
b955 3a 69 b9			ld a, (.dmark)  
b958 32 b7 ee			ld (debug_mark),a  
b95b 3a 6a b9			ld a, (.dmark+1)  
b95e 32 b8 ee			ld (debug_mark+1),a  
b961 3a 6b b9			ld a, (.dmark+2)  
b964 32 b9 ee			ld (debug_mark+2),a  
b967 18 03			jr .pastdmark  
b969 ..			.dmark: db "FB."  
b96c f1			.pastdmark: pop af  
b96d			endm  
# End of macro DMARK
b96d						CALLMONITOR 
b96d cd a3 94			call break_point_state  
b970				endm  
# End of macro CALLMONITOR
b970					endif 
b970			 
b970					FORTH_DSP_VALUEHL 
b970 cd 0b 9d			call macro_dsp_valuehl 
b973				endm 
# End of macro FORTH_DSP_VALUEHL
b973			 
b973 7d					ld a, l 
b974 fe 01				cp 1 
b976 20 05				jr nz, .fbn1 
b978 21 fc ed				ld hl, display_fb1 
b97b 18 15				jr .fbset 
b97d fe 02		.fbn1:		cp 2 
b97f 20 05				jr nz, .fbn2 
b981 21 5a ed				ld hl, display_fb2 
b984 18 0c				jr .fbset 
b986 fe 03		.fbn2:		cp 3 
b988 20 05				jr nz, .fbn3 
b98a 21 ab ed				ld hl, display_fb3 
b98d 18 03				jr .fbset 
b98f			.fbn3:		 ; if invalid number select first 
b98f 21 fc ed				ld hl, display_fb1 
b992 22 58 ed		.fbset:		ld (display_fb_active), hl 
b995			 
b995					FORTH_DSP_POP 
b995 cd c3 9d			call macro_forth_dsp_pop 
b998				endm 
# End of macro FORTH_DSP_POP
b998			 
b998					NEXTW 
b998 c3 c1 9e			jp macro_next 
b99b				endm 
# End of macro NEXTW
b99b			 
b99b			 
b99b			.EMIT: 
b99b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b99b 1b				db WORD_SYS_CORE+7             
b99c ec b9			dw .DOTH            
b99e 05				db 4 + 1 
b99f .. 00			db "EMIT",0              
b9a4				endm 
# End of macro CWHEAD
b9a4			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b9a4					; get value off TOS and display it 
b9a4			 
b9a4					if DEBUG_FORTH_WORDS_KEY 
b9a4						DMARK "EMT" 
b9a4 f5				push af  
b9a5 3a b9 b9			ld a, (.dmark)  
b9a8 32 b7 ee			ld (debug_mark),a  
b9ab 3a ba b9			ld a, (.dmark+1)  
b9ae 32 b8 ee			ld (debug_mark+1),a  
b9b1 3a bb b9			ld a, (.dmark+2)  
b9b4 32 b9 ee			ld (debug_mark+2),a  
b9b7 18 03			jr .pastdmark  
b9b9 ..			.dmark: db "EMT"  
b9bc f1			.pastdmark: pop af  
b9bd			endm  
# End of macro DMARK
b9bd						CALLMONITOR 
b9bd cd a3 94			call break_point_state  
b9c0				endm  
# End of macro CALLMONITOR
b9c0					endif 
b9c0			 
b9c0					FORTH_DSP_VALUEHL 
b9c0 cd 0b 9d			call macro_dsp_valuehl 
b9c3				endm 
# End of macro FORTH_DSP_VALUEHL
b9c3			 
b9c3 7d					ld a,l 
b9c4			 
b9c4					; TODO write to display 
b9c4			 
b9c4 32 4f e6				ld (os_input), a 
b9c7 3e 00				ld a, 0 
b9c9 32 50 e6				ld (os_input+1), a 
b9cc					 
b9cc 3a ee eb				ld a, (f_cursor_ptr) 
b9cf 11 4f e6				ld de, os_input 
b9d2 cd 88 8a				call str_at_display 
b9d5			 
b9d5			 
b9d5 3a cc eb				ld a,(cli_autodisplay) 
b9d8 fe 00				cp 0 
b9da 28 03				jr z, .enoupdate 
b9dc cd 98 8a						call update_display 
b9df					.enoupdate: 
b9df			 
b9df 3a ee eb				ld a, (f_cursor_ptr) 
b9e2 3c					inc a 
b9e3 32 ee eb				ld (f_cursor_ptr), a   ; save new pos 
b9e6			 
b9e6			 
b9e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9e6 cd c3 9d			call macro_forth_dsp_pop 
b9e9				endm 
# End of macro FORTH_DSP_POP
b9e9			  
b9e9			 
b9e9					NEXTW 
b9e9 c3 c1 9e			jp macro_next 
b9ec				endm 
# End of macro NEXTW
b9ec			.DOTH: 
b9ec				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b9ec 1c				db WORD_SYS_CORE+8             
b9ed 1c ba			dw .DOTF            
b9ef 03				db 2 + 1 
b9f0 .. 00			db ".-",0              
b9f3				endm 
# End of macro CWHEAD
b9f3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b9f3					; get value off TOS and display it 
b9f3					if DEBUG_FORTH_WORDS_KEY 
b9f3						DMARK "DTD" 
b9f3 f5				push af  
b9f4 3a 08 ba			ld a, (.dmark)  
b9f7 32 b7 ee			ld (debug_mark),a  
b9fa 3a 09 ba			ld a, (.dmark+1)  
b9fd 32 b8 ee			ld (debug_mark+1),a  
ba00 3a 0a ba			ld a, (.dmark+2)  
ba03 32 b9 ee			ld (debug_mark+2),a  
ba06 18 03			jr .pastdmark  
ba08 ..			.dmark: db "DTD"  
ba0b f1			.pastdmark: pop af  
ba0c			endm  
# End of macro DMARK
ba0c						CALLMONITOR 
ba0c cd a3 94			call break_point_state  
ba0f				endm  
# End of macro CALLMONITOR
ba0f					endif 
ba0f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba11 3e 00			ld a, 0 
ba13 32 cd eb			ld (cli_mvdot), a 
ba16 c3 73 ba			jp .dotgo 
ba19				NEXTW 
ba19 c3 c1 9e			jp macro_next 
ba1c				endm 
# End of macro NEXTW
ba1c			.DOTF: 
ba1c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba1c 1c				db WORD_SYS_CORE+8             
ba1d 4a ba			dw .DOT            
ba1f 03				db 2 + 1 
ba20 .. 00			db ".>",0              
ba23				endm 
# End of macro CWHEAD
ba23			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
ba23					; get value off TOS and display it 
ba23			        ; TODO BUG adds extra spaces 
ba23			        ; TODO BUG handle numerics? 
ba23					if DEBUG_FORTH_WORDS_KEY 
ba23						DMARK "DTC" 
ba23 f5				push af  
ba24 3a 38 ba			ld a, (.dmark)  
ba27 32 b7 ee			ld (debug_mark),a  
ba2a 3a 39 ba			ld a, (.dmark+1)  
ba2d 32 b8 ee			ld (debug_mark+1),a  
ba30 3a 3a ba			ld a, (.dmark+2)  
ba33 32 b9 ee			ld (debug_mark+2),a  
ba36 18 03			jr .pastdmark  
ba38 ..			.dmark: db "DTC"  
ba3b f1			.pastdmark: pop af  
ba3c			endm  
# End of macro DMARK
ba3c						CALLMONITOR 
ba3c cd a3 94			call break_point_state  
ba3f				endm  
# End of macro CALLMONITOR
ba3f					endif 
ba3f 3e 01			ld a, 1 
ba41 32 cd eb			ld (cli_mvdot), a 
ba44 c3 73 ba			jp .dotgo 
ba47				NEXTW 
ba47 c3 c1 9e			jp macro_next 
ba4a				endm 
# End of macro NEXTW
ba4a			 
ba4a			.DOT: 
ba4a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
ba4a 1c				db WORD_SYS_CORE+8             
ba4b 26 bc			dw .CLS            
ba4d 02				db 1 + 1 
ba4e .. 00			db ".",0              
ba50				endm 
# End of macro CWHEAD
ba50			        ; | . ( u -- ) Display TOS | DONE 
ba50					; get value off TOS and display it 
ba50			 
ba50					if DEBUG_FORTH_WORDS_KEY 
ba50						DMARK "DOT" 
ba50 f5				push af  
ba51 3a 65 ba			ld a, (.dmark)  
ba54 32 b7 ee			ld (debug_mark),a  
ba57 3a 66 ba			ld a, (.dmark+1)  
ba5a 32 b8 ee			ld (debug_mark+1),a  
ba5d 3a 67 ba			ld a, (.dmark+2)  
ba60 32 b9 ee			ld (debug_mark+2),a  
ba63 18 03			jr .pastdmark  
ba65 ..			.dmark: db "DOT"  
ba68 f1			.pastdmark: pop af  
ba69			endm  
# End of macro DMARK
ba69						CALLMONITOR 
ba69 cd a3 94			call break_point_state  
ba6c				endm  
# End of macro CALLMONITOR
ba6c					endif 
ba6c 3e 00			ld a, 0 
ba6e 32 cd eb			ld (cli_mvdot), a 
ba71 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
ba73				 
ba73			 
ba73			.dotgo: 
ba73			 
ba73			; move up type to on stack for parserv5 
ba73					FORTH_DSP 
ba73 cd d1 9c			call macro_forth_dsp 
ba76				endm 
# End of macro FORTH_DSP
ba76				;FORTH_DSP_VALUE  
ba76			 
ba76			if DEBUG_FORTH_DOT 
ba76				DMARK "DOT" 
ba76 f5				push af  
ba77 3a 8b ba			ld a, (.dmark)  
ba7a 32 b7 ee			ld (debug_mark),a  
ba7d 3a 8c ba			ld a, (.dmark+1)  
ba80 32 b8 ee			ld (debug_mark+1),a  
ba83 3a 8d ba			ld a, (.dmark+2)  
ba86 32 b9 ee			ld (debug_mark+2),a  
ba89 18 03			jr .pastdmark  
ba8b ..			.dmark: db "DOT"  
ba8e f1			.pastdmark: pop af  
ba8f			endm  
# End of macro DMARK
ba8f				CALLMONITOR 
ba8f cd a3 94			call break_point_state  
ba92				endm  
# End of macro CALLMONITOR
ba92			endif	 
ba92			;		.print: 
ba92			 
ba92 7e				ld a,(hl)  ; work out what type of value is on the TOS 
ba93 23				inc hl   ; position to the actual value 
ba94 fe 01			cp DS_TYPE_STR 
ba96 20 06			jr nz, .dotnum1  
ba98			 
ba98			; display string 
ba98				FORTH_DSP_VALUE  
ba98 cd f4 9c			call macro_forth_dsp_value 
ba9b				endm 
# End of macro FORTH_DSP_VALUE
ba9b eb				ex de,hl 
ba9c 18 49			jr .dotwrite 
ba9e			 
ba9e			.dotnum1: 
ba9e fe 02			cp DS_TYPE_INUM 
baa0 20 44			jr nz, .dotflot 
baa2			 
baa2			 
baa2			; display number 
baa2			 
baa2			;	push hl 
baa2			;	call clear_display 
baa2			;	pop hl 
baa2			 
baa2 5e				ld e, (hl) 
baa3 23				inc hl 
baa4 56				ld d, (hl) 
baa5 21 51 e4			ld hl, scratch 
baa8			if DEBUG_FORTH_DOT 
baa8				DMARK "DT1" 
baa8 f5				push af  
baa9 3a bd ba			ld a, (.dmark)  
baac 32 b7 ee			ld (debug_mark),a  
baaf 3a be ba			ld a, (.dmark+1)  
bab2 32 b8 ee			ld (debug_mark+1),a  
bab5 3a bf ba			ld a, (.dmark+2)  
bab8 32 b9 ee			ld (debug_mark+2),a  
babb 18 03			jr .pastdmark  
babd ..			.dmark: db "DT1"  
bac0 f1			.pastdmark: pop af  
bac1			endm  
# End of macro DMARK
bac1				CALLMONITOR 
bac1 cd a3 94			call break_point_state  
bac4				endm  
# End of macro CALLMONITOR
bac4			endif	 
bac4			 
bac4 cd af 90			call uitoa_16 
bac7 eb				ex de,hl 
bac8			 
bac8			if DEBUG_FORTH_DOT 
bac8				DMARK "DT2" 
bac8 f5				push af  
bac9 3a dd ba			ld a, (.dmark)  
bacc 32 b7 ee			ld (debug_mark),a  
bacf 3a de ba			ld a, (.dmark+1)  
bad2 32 b8 ee			ld (debug_mark+1),a  
bad5 3a df ba			ld a, (.dmark+2)  
bad8 32 b9 ee			ld (debug_mark+2),a  
badb 18 03			jr .pastdmark  
badd ..			.dmark: db "DT2"  
bae0 f1			.pastdmark: pop af  
bae1			endm  
# End of macro DMARK
bae1				CALLMONITOR 
bae1 cd a3 94			call break_point_state  
bae4				endm  
# End of macro CALLMONITOR
bae4			endif	 
bae4			 
bae4			;	ld de, os_word_scratch 
bae4 18 01			jr .dotwrite 
bae6			 
bae6 00			.dotflot:   nop 
bae7			; TODO print floating point number 
bae7			 
bae7			.dotwrite:		 
bae7			 
bae7					; if c is set then set all '-' to spaces 
bae7					; need to also take into account .>  
bae7			 
bae7 3e 01				ld a, 1 
bae9 b9					cp c 
baea 20 67				jr nz, .nodashswap 
baec			 
baec					; DE has the string to write, working with HL 
baec			 
baec 06 ff				ld b, 255 
baee d5					push de 
baef e1					pop hl 
baf0			 
baf0			if DEBUG_FORTH_DOT 
baf0				DMARK "DT-" 
baf0 f5				push af  
baf1 3a 05 bb			ld a, (.dmark)  
baf4 32 b7 ee			ld (debug_mark),a  
baf7 3a 06 bb			ld a, (.dmark+1)  
bafa 32 b8 ee			ld (debug_mark+1),a  
bafd 3a 07 bb			ld a, (.dmark+2)  
bb00 32 b9 ee			ld (debug_mark+2),a  
bb03 18 03			jr .pastdmark  
bb05 ..			.dmark: db "DT-"  
bb08 f1			.pastdmark: pop af  
bb09			endm  
# End of macro DMARK
bb09				CALLMONITOR 
bb09 cd a3 94			call break_point_state  
bb0c				endm  
# End of macro CALLMONITOR
bb0c			endif	 
bb0c 7e			.dashscan:	ld a, (hl) 
bb0d fe 00				cp 0 
bb0f 28 42				jr z, .nodashswap 
bb11 fe 2d				cp '-' 
bb13 20 03				jr nz, .dashskip 
bb15 3e 20				ld a, ' ' 
bb17 77					ld (hl), a 
bb18 23			.dashskip:	inc hl 
bb19			if DEBUG_FORTH_DOT 
bb19				DMARK "D-2" 
bb19 f5				push af  
bb1a 3a 2e bb			ld a, (.dmark)  
bb1d 32 b7 ee			ld (debug_mark),a  
bb20 3a 2f bb			ld a, (.dmark+1)  
bb23 32 b8 ee			ld (debug_mark+1),a  
bb26 3a 30 bb			ld a, (.dmark+2)  
bb29 32 b9 ee			ld (debug_mark+2),a  
bb2c 18 03			jr .pastdmark  
bb2e ..			.dmark: db "D-2"  
bb31 f1			.pastdmark: pop af  
bb32			endm  
# End of macro DMARK
bb32				CALLMONITOR 
bb32 cd a3 94			call break_point_state  
bb35				endm  
# End of macro CALLMONITOR
bb35			endif	 
bb35 10 d5				djnz .dashscan 
bb37			 
bb37			if DEBUG_FORTH_DOT 
bb37				DMARK "D-1" 
bb37 f5				push af  
bb38 3a 4c bb			ld a, (.dmark)  
bb3b 32 b7 ee			ld (debug_mark),a  
bb3e 3a 4d bb			ld a, (.dmark+1)  
bb41 32 b8 ee			ld (debug_mark+1),a  
bb44 3a 4e bb			ld a, (.dmark+2)  
bb47 32 b9 ee			ld (debug_mark+2),a  
bb4a 18 03			jr .pastdmark  
bb4c ..			.dmark: db "D-1"  
bb4f f1			.pastdmark: pop af  
bb50			endm  
# End of macro DMARK
bb50				CALLMONITOR 
bb50 cd a3 94			call break_point_state  
bb53				endm  
# End of macro CALLMONITOR
bb53			endif	 
bb53			 
bb53			.nodashswap: 
bb53			 
bb53			if DEBUG_FORTH_DOT 
bb53				DMARK "D-o" 
bb53 f5				push af  
bb54 3a 68 bb			ld a, (.dmark)  
bb57 32 b7 ee			ld (debug_mark),a  
bb5a 3a 69 bb			ld a, (.dmark+1)  
bb5d 32 b8 ee			ld (debug_mark+1),a  
bb60 3a 6a bb			ld a, (.dmark+2)  
bb63 32 b9 ee			ld (debug_mark+2),a  
bb66 18 03			jr .pastdmark  
bb68 ..			.dmark: db "D-o"  
bb6b f1			.pastdmark: pop af  
bb6c			endm  
# End of macro DMARK
bb6c				CALLMONITOR 
bb6c cd a3 94			call break_point_state  
bb6f				endm  
# End of macro CALLMONITOR
bb6f			endif	 
bb6f			 
bb6f d5					push de   ; save string start in case we need to advance print 
bb70			 
bb70 3a ee eb				ld a, (f_cursor_ptr) 
bb73 cd 88 8a				call str_at_display 
bb76 3a cc eb				ld a,(cli_autodisplay) 
bb79 fe 00				cp 0 
bb7b 28 03				jr z, .noupdate 
bb7d cd 98 8a						call update_display 
bb80					.noupdate: 
bb80			 
bb80			 
bb80					; see if we need to advance the print position 
bb80			 
bb80 e1					pop hl   ; get back string 
bb81			;		ex de,hl 
bb81			 
bb81 3a cd eb				ld a, (cli_mvdot) 
bb84			if DEBUG_FORTH_DOT 
bb84			;		ld e,a 
bb84				DMARK "D>1" 
bb84 f5				push af  
bb85 3a 99 bb			ld a, (.dmark)  
bb88 32 b7 ee			ld (debug_mark),a  
bb8b 3a 9a bb			ld a, (.dmark+1)  
bb8e 32 b8 ee			ld (debug_mark+1),a  
bb91 3a 9b bb			ld a, (.dmark+2)  
bb94 32 b9 ee			ld (debug_mark+2),a  
bb97 18 03			jr .pastdmark  
bb99 ..			.dmark: db "D>1"  
bb9c f1			.pastdmark: pop af  
bb9d			endm  
# End of macro DMARK
bb9d				CALLMONITOR 
bb9d cd a3 94			call break_point_state  
bba0				endm  
# End of macro CALLMONITOR
bba0			endif	 
bba0 fe 00				cp 0 
bba2 28 44				jr z, .noadv 
bba4					; yes, lets advance the print position 
bba4 3e 00				ld a, 0 
bba6 cd 0b 91				call strlent 
bba9			if DEBUG_FORTH_DOT 
bba9				DMARK "D-?" 
bba9 f5				push af  
bbaa 3a be bb			ld a, (.dmark)  
bbad 32 b7 ee			ld (debug_mark),a  
bbb0 3a bf bb			ld a, (.dmark+1)  
bbb3 32 b8 ee			ld (debug_mark+1),a  
bbb6 3a c0 bb			ld a, (.dmark+2)  
bbb9 32 b9 ee			ld (debug_mark+2),a  
bbbc 18 03			jr .pastdmark  
bbbe ..			.dmark: db "D-?"  
bbc1 f1			.pastdmark: pop af  
bbc2			endm  
# End of macro DMARK
bbc2				CALLMONITOR 
bbc2 cd a3 94			call break_point_state  
bbc5				endm  
# End of macro CALLMONITOR
bbc5			endif	 
bbc5 3a ee eb				ld a, (f_cursor_ptr) 
bbc8 85					add a,l 
bbc9					;call addatohl 
bbc9					;ld a, l 
bbc9 32 ee eb				ld (f_cursor_ptr), a   ; save new pos 
bbcc			 
bbcc			if DEBUG_FORTH_DOT 
bbcc				DMARK "D->" 
bbcc f5				push af  
bbcd 3a e1 bb			ld a, (.dmark)  
bbd0 32 b7 ee			ld (debug_mark),a  
bbd3 3a e2 bb			ld a, (.dmark+1)  
bbd6 32 b8 ee			ld (debug_mark+1),a  
bbd9 3a e3 bb			ld a, (.dmark+2)  
bbdc 32 b9 ee			ld (debug_mark+2),a  
bbdf 18 03			jr .pastdmark  
bbe1 ..			.dmark: db "D->"  
bbe4 f1			.pastdmark: pop af  
bbe5			endm  
# End of macro DMARK
bbe5				CALLMONITOR 
bbe5 cd a3 94			call break_point_state  
bbe8				endm  
# End of macro CALLMONITOR
bbe8			endif	 
bbe8			 
bbe8			.noadv:	 
bbe8			 
bbe8					if DEBUG_FORTH_DOT_WAIT 
bbe8							call next_page_prompt 
bbe8					endif	 
bbe8			; TODO this pop off the stack causes a crash. i dont know why 
bbe8			 
bbe8			 
bbe8			if DEBUG_FORTH_DOT 
bbe8				DMARK "DTh" 
bbe8 f5				push af  
bbe9 3a fd bb			ld a, (.dmark)  
bbec 32 b7 ee			ld (debug_mark),a  
bbef 3a fe bb			ld a, (.dmark+1)  
bbf2 32 b8 ee			ld (debug_mark+1),a  
bbf5 3a ff bb			ld a, (.dmark+2)  
bbf8 32 b9 ee			ld (debug_mark+2),a  
bbfb 18 03			jr .pastdmark  
bbfd ..			.dmark: db "DTh"  
bc00 f1			.pastdmark: pop af  
bc01			endm  
# End of macro DMARK
bc01				CALLMONITOR 
bc01 cd a3 94			call break_point_state  
bc04				endm  
# End of macro CALLMONITOR
bc04			endif	 
bc04			 
bc04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc04 cd c3 9d			call macro_forth_dsp_pop 
bc07				endm 
# End of macro FORTH_DSP_POP
bc07			 
bc07			if DEBUG_FORTH_DOT 
bc07				DMARK "DTi" 
bc07 f5				push af  
bc08 3a 1c bc			ld a, (.dmark)  
bc0b 32 b7 ee			ld (debug_mark),a  
bc0e 3a 1d bc			ld a, (.dmark+1)  
bc11 32 b8 ee			ld (debug_mark+1),a  
bc14 3a 1e bc			ld a, (.dmark+2)  
bc17 32 b9 ee			ld (debug_mark+2),a  
bc1a 18 03			jr .pastdmark  
bc1c ..			.dmark: db "DTi"  
bc1f f1			.pastdmark: pop af  
bc20			endm  
# End of macro DMARK
bc20				CALLMONITOR 
bc20 cd a3 94			call break_point_state  
bc23				endm  
# End of macro CALLMONITOR
bc23			endif	 
bc23			 
bc23			 
bc23					NEXTW 
bc23 c3 c1 9e			jp macro_next 
bc26				endm 
# End of macro NEXTW
bc26			 
bc26			.CLS: 
bc26				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bc26 35				db WORD_SYS_CORE+33             
bc27 53 bc			dw .DRAW            
bc29 04				db 3 + 1 
bc2a .. 00			db "CLS",0              
bc2e				endm 
# End of macro CWHEAD
bc2e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bc2e					if DEBUG_FORTH_WORDS_KEY 
bc2e						DMARK "CLS" 
bc2e f5				push af  
bc2f 3a 43 bc			ld a, (.dmark)  
bc32 32 b7 ee			ld (debug_mark),a  
bc35 3a 44 bc			ld a, (.dmark+1)  
bc38 32 b8 ee			ld (debug_mark+1),a  
bc3b 3a 45 bc			ld a, (.dmark+2)  
bc3e 32 b9 ee			ld (debug_mark+2),a  
bc41 18 03			jr .pastdmark  
bc43 ..			.dmark: db "CLS"  
bc46 f1			.pastdmark: pop af  
bc47			endm  
# End of macro DMARK
bc47						CALLMONITOR 
bc47 cd a3 94			call break_point_state  
bc4a				endm  
# End of macro CALLMONITOR
bc4a					endif 
bc4a cd 75 8a				call clear_display 
bc4d c3 61 bd				jp .home		; and home cursor 
bc50					NEXTW 
bc50 c3 c1 9e			jp macro_next 
bc53				endm 
# End of macro NEXTW
bc53			 
bc53			.DRAW: 
bc53				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bc53 36				db WORD_SYS_CORE+34             
bc54 7e bc			dw .DUMP            
bc56 05				db 4 + 1 
bc57 .. 00			db "DRAW",0              
bc5c				endm 
# End of macro CWHEAD
bc5c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bc5c					if DEBUG_FORTH_WORDS_KEY 
bc5c						DMARK "DRW" 
bc5c f5				push af  
bc5d 3a 71 bc			ld a, (.dmark)  
bc60 32 b7 ee			ld (debug_mark),a  
bc63 3a 72 bc			ld a, (.dmark+1)  
bc66 32 b8 ee			ld (debug_mark+1),a  
bc69 3a 73 bc			ld a, (.dmark+2)  
bc6c 32 b9 ee			ld (debug_mark+2),a  
bc6f 18 03			jr .pastdmark  
bc71 ..			.dmark: db "DRW"  
bc74 f1			.pastdmark: pop af  
bc75			endm  
# End of macro DMARK
bc75						CALLMONITOR 
bc75 cd a3 94			call break_point_state  
bc78				endm  
# End of macro CALLMONITOR
bc78					endif 
bc78 cd 98 8a				call update_display 
bc7b					NEXTW 
bc7b c3 c1 9e			jp macro_next 
bc7e				endm 
# End of macro NEXTW
bc7e			 
bc7e			.DUMP: 
bc7e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bc7e 37				db WORD_SYS_CORE+35             
bc7f b6 bc			dw .CDUMP            
bc81 05				db 4 + 1 
bc82 .. 00			db "DUMP",0              
bc87				endm 
# End of macro CWHEAD
bc87			; | DUMP ( x -- ) With address x display dump   | DONE 
bc87			; TODO pop address to use off of the stack 
bc87					if DEBUG_FORTH_WORDS_KEY 
bc87						DMARK "DUM" 
bc87 f5				push af  
bc88 3a 9c bc			ld a, (.dmark)  
bc8b 32 b7 ee			ld (debug_mark),a  
bc8e 3a 9d bc			ld a, (.dmark+1)  
bc91 32 b8 ee			ld (debug_mark+1),a  
bc94 3a 9e bc			ld a, (.dmark+2)  
bc97 32 b9 ee			ld (debug_mark+2),a  
bc9a 18 03			jr .pastdmark  
bc9c ..			.dmark: db "DUM"  
bc9f f1			.pastdmark: pop af  
bca0			endm  
# End of macro DMARK
bca0						CALLMONITOR 
bca0 cd a3 94			call break_point_state  
bca3				endm  
# End of macro CALLMONITOR
bca3					endif 
bca3 cd 75 8a				call clear_display 
bca6			 
bca6					; get address 
bca6			 
bca6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bca6 cd 0b 9d			call macro_dsp_valuehl 
bca9				endm 
# End of macro FORTH_DSP_VALUEHL
bca9				 
bca9					; save it for cdump 
bca9			 
bca9 22 74 e7				ld (os_cur_ptr),hl 
bcac			 
bcac					; destroy value TOS 
bcac			 
bcac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcac cd c3 9d			call macro_forth_dsp_pop 
bcaf				endm 
# End of macro FORTH_DSP_POP
bcaf			 
bcaf cd 94 99				call dumpcont	; skip old style of param parsing	 
bcb2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bcb3					NEXTW 
bcb3 c3 c1 9e			jp macro_next 
bcb6				endm 
# End of macro NEXTW
bcb6			.CDUMP: 
bcb6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bcb6 38				db WORD_SYS_CORE+36             
bcb7 e6 bc			dw .DAT            
bcb9 06				db 5 + 1 
bcba .. 00			db "CDUMP",0              
bcc0				endm 
# End of macro CWHEAD
bcc0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bcc0					if DEBUG_FORTH_WORDS_KEY 
bcc0						DMARK "CDP" 
bcc0 f5				push af  
bcc1 3a d5 bc			ld a, (.dmark)  
bcc4 32 b7 ee			ld (debug_mark),a  
bcc7 3a d6 bc			ld a, (.dmark+1)  
bcca 32 b8 ee			ld (debug_mark+1),a  
bccd 3a d7 bc			ld a, (.dmark+2)  
bcd0 32 b9 ee			ld (debug_mark+2),a  
bcd3 18 03			jr .pastdmark  
bcd5 ..			.dmark: db "CDP"  
bcd8 f1			.pastdmark: pop af  
bcd9			endm  
# End of macro DMARK
bcd9						CALLMONITOR 
bcd9 cd a3 94			call break_point_state  
bcdc				endm  
# End of macro CALLMONITOR
bcdc					endif 
bcdc cd 75 8a				call clear_display 
bcdf cd 94 99				call dumpcont	 
bce2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bce3					NEXTW 
bce3 c3 c1 9e			jp macro_next 
bce6				endm 
# End of macro NEXTW
bce6			 
bce6			 
bce6			 
bce6			 
bce6			.DAT: 
bce6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bce6 3d				db WORD_SYS_CORE+41             
bce7 3c bd			dw .HOME            
bce9 03				db 2 + 1 
bcea .. 00			db "AT",0              
bced				endm 
# End of macro CWHEAD
bced			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bced					if DEBUG_FORTH_WORDS_KEY 
bced						DMARK "AT." 
bced f5				push af  
bcee 3a 02 bd			ld a, (.dmark)  
bcf1 32 b7 ee			ld (debug_mark),a  
bcf4 3a 03 bd			ld a, (.dmark+1)  
bcf7 32 b8 ee			ld (debug_mark+1),a  
bcfa 3a 04 bd			ld a, (.dmark+2)  
bcfd 32 b9 ee			ld (debug_mark+2),a  
bd00 18 03			jr .pastdmark  
bd02 ..			.dmark: db "AT."  
bd05 f1			.pastdmark: pop af  
bd06			endm  
# End of macro DMARK
bd06						CALLMONITOR 
bd06 cd a3 94			call break_point_state  
bd09				endm  
# End of macro CALLMONITOR
bd09					endif 
bd09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd09 cd 0b 9d			call macro_dsp_valuehl 
bd0c				endm 
# End of macro FORTH_DSP_VALUEHL
bd0c			 
bd0c			 
bd0c					; TODO save cursor row 
bd0c 7d					ld a,l 
bd0d fe 02				cp 2 
bd0f 20 04				jr nz, .crow3 
bd11 3e 14				ld a, display_row_2 
bd13 18 12				jr .ccol1 
bd15 fe 03		.crow3:		cp 3 
bd17 20 04				jr nz, .crow4 
bd19 3e 28				ld a, display_row_3 
bd1b 18 0a				jr .ccol1 
bd1d fe 04		.crow4:		cp 4 
bd1f 20 04				jr nz, .crow1 
bd21 3e 3c				ld a, display_row_4 
bd23 18 02				jr .ccol1 
bd25 3e 00		.crow1:		ld a,display_row_1 
bd27 f5			.ccol1:		push af			; got row offset 
bd28 6f					ld l,a 
bd29 26 00				ld h,0 
bd2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd2b cd c3 9d			call macro_forth_dsp_pop 
bd2e				endm 
# End of macro FORTH_DSP_POP
bd2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd2e cd 0b 9d			call macro_dsp_valuehl 
bd31				endm 
# End of macro FORTH_DSP_VALUEHL
bd31					; TODO save cursor col 
bd31 f1					pop af 
bd32 85					add l		; add col offset 
bd33 32 ee eb				ld (f_cursor_ptr), a 
bd36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd36 cd c3 9d			call macro_forth_dsp_pop 
bd39				endm 
# End of macro FORTH_DSP_POP
bd39			 
bd39					; calculate  
bd39			 
bd39					NEXTW 
bd39 c3 c1 9e			jp macro_next 
bd3c				endm 
# End of macro NEXTW
bd3c			 
bd3c			 
bd3c			.HOME: 
bd3c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bd3c 41				db WORD_SYS_CORE+45             
bd3d 69 bd			dw .SPACE            
bd3f 05				db 4 + 1 
bd40 .. 00			db "HOME",0              
bd45				endm 
# End of macro CWHEAD
bd45			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bd45					if DEBUG_FORTH_WORDS_KEY 
bd45						DMARK "HOM" 
bd45 f5				push af  
bd46 3a 5a bd			ld a, (.dmark)  
bd49 32 b7 ee			ld (debug_mark),a  
bd4c 3a 5b bd			ld a, (.dmark+1)  
bd4f 32 b8 ee			ld (debug_mark+1),a  
bd52 3a 5c bd			ld a, (.dmark+2)  
bd55 32 b9 ee			ld (debug_mark+2),a  
bd58 18 03			jr .pastdmark  
bd5a ..			.dmark: db "HOM"  
bd5d f1			.pastdmark: pop af  
bd5e			endm  
# End of macro DMARK
bd5e						CALLMONITOR 
bd5e cd a3 94			call break_point_state  
bd61				endm  
# End of macro CALLMONITOR
bd61					endif 
bd61 3e 00		.home:		ld a, 0		; and home cursor 
bd63 32 ee eb				ld (f_cursor_ptr), a 
bd66					NEXTW 
bd66 c3 c1 9e			jp macro_next 
bd69				endm 
# End of macro NEXTW
bd69			 
bd69			 
bd69			.SPACE: 
bd69				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bd69 46				db WORD_SYS_CORE+50             
bd6a 97 bd			dw .SPACES            
bd6c 03				db 2 + 1 
bd6d .. 00			db "BL",0              
bd70				endm 
# End of macro CWHEAD
bd70			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bd70					if DEBUG_FORTH_WORDS_KEY 
bd70						DMARK "BL." 
bd70 f5				push af  
bd71 3a 85 bd			ld a, (.dmark)  
bd74 32 b7 ee			ld (debug_mark),a  
bd77 3a 86 bd			ld a, (.dmark+1)  
bd7a 32 b8 ee			ld (debug_mark+1),a  
bd7d 3a 87 bd			ld a, (.dmark+2)  
bd80 32 b9 ee			ld (debug_mark+2),a  
bd83 18 03			jr .pastdmark  
bd85 ..			.dmark: db "BL."  
bd88 f1			.pastdmark: pop af  
bd89			endm  
# End of macro DMARK
bd89						CALLMONITOR 
bd89 cd a3 94			call break_point_state  
bd8c				endm  
# End of macro CALLMONITOR
bd8c					endif 
bd8c 21 95 bd				ld hl, .blstr 
bd8f cd 82 9b				call forth_push_str 
bd92					 
bd92				       NEXTW 
bd92 c3 c1 9e			jp macro_next 
bd95				endm 
# End of macro NEXTW
bd95			 
bd95 .. 00		.blstr: db " ", 0 
bd97			 
bd97			.SPACES: 
bd97				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bd97 47				db WORD_SYS_CORE+51             
bd98 32 be			dw .SCROLL            
bd9a 07				db 6 + 1 
bd9b .. 00			db "SPACES",0              
bda2				endm 
# End of macro CWHEAD
bda2			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
bda2					if DEBUG_FORTH_WORDS_KEY 
bda2						DMARK "SPS" 
bda2 f5				push af  
bda3 3a b7 bd			ld a, (.dmark)  
bda6 32 b7 ee			ld (debug_mark),a  
bda9 3a b8 bd			ld a, (.dmark+1)  
bdac 32 b8 ee			ld (debug_mark+1),a  
bdaf 3a b9 bd			ld a, (.dmark+2)  
bdb2 32 b9 ee			ld (debug_mark+2),a  
bdb5 18 03			jr .pastdmark  
bdb7 ..			.dmark: db "SPS"  
bdba f1			.pastdmark: pop af  
bdbb			endm  
# End of macro DMARK
bdbb						CALLMONITOR 
bdbb cd a3 94			call break_point_state  
bdbe				endm  
# End of macro CALLMONITOR
bdbe					endif 
bdbe			 
bdbe			 
bdbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdbe cd 0b 9d			call macro_dsp_valuehl 
bdc1				endm 
# End of macro FORTH_DSP_VALUEHL
bdc1			 
bdc1			;		push hl    ; u 
bdc1					if DEBUG_FORTH_WORDS 
bdc1						DMARK "SPA" 
bdc1 f5				push af  
bdc2 3a d6 bd			ld a, (.dmark)  
bdc5 32 b7 ee			ld (debug_mark),a  
bdc8 3a d7 bd			ld a, (.dmark+1)  
bdcb 32 b8 ee			ld (debug_mark+1),a  
bdce 3a d8 bd			ld a, (.dmark+2)  
bdd1 32 b9 ee			ld (debug_mark+2),a  
bdd4 18 03			jr .pastdmark  
bdd6 ..			.dmark: db "SPA"  
bdd9 f1			.pastdmark: pop af  
bdda			endm  
# End of macro DMARK
bdda						CALLMONITOR 
bdda cd a3 94			call break_point_state  
bddd				endm  
# End of macro CALLMONITOR
bddd					endif 
bddd			 
bddd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bddd cd c3 9d			call macro_forth_dsp_pop 
bde0				endm 
# End of macro FORTH_DSP_POP
bde0			;		pop hl 
bde0 4d					ld c, l 
bde1 06 00				ld b, 0 
bde3 21 51 e4				ld hl, scratch  
bde6			 
bde6					if DEBUG_FORTH_WORDS 
bde6						DMARK "SP2" 
bde6 f5				push af  
bde7 3a fb bd			ld a, (.dmark)  
bdea 32 b7 ee			ld (debug_mark),a  
bded 3a fc bd			ld a, (.dmark+1)  
bdf0 32 b8 ee			ld (debug_mark+1),a  
bdf3 3a fd bd			ld a, (.dmark+2)  
bdf6 32 b9 ee			ld (debug_mark+2),a  
bdf9 18 03			jr .pastdmark  
bdfb ..			.dmark: db "SP2"  
bdfe f1			.pastdmark: pop af  
bdff			endm  
# End of macro DMARK
bdff						CALLMONITOR 
bdff cd a3 94			call break_point_state  
be02				endm  
# End of macro CALLMONITOR
be02					endif 
be02 3e 20				ld a, ' ' 
be04 c5			.spaces1:	push bc 
be05 77					ld (hl),a 
be06 23					inc hl 
be07 c1					pop bc 
be08 10 fa				djnz .spaces1 
be0a 3e 00				ld a,0 
be0c 77					ld (hl),a 
be0d 21 51 e4				ld hl, scratch 
be10					if DEBUG_FORTH_WORDS 
be10						DMARK "SP3" 
be10 f5				push af  
be11 3a 25 be			ld a, (.dmark)  
be14 32 b7 ee			ld (debug_mark),a  
be17 3a 26 be			ld a, (.dmark+1)  
be1a 32 b8 ee			ld (debug_mark+1),a  
be1d 3a 27 be			ld a, (.dmark+2)  
be20 32 b9 ee			ld (debug_mark+2),a  
be23 18 03			jr .pastdmark  
be25 ..			.dmark: db "SP3"  
be28 f1			.pastdmark: pop af  
be29			endm  
# End of macro DMARK
be29						CALLMONITOR 
be29 cd a3 94			call break_point_state  
be2c				endm  
# End of macro CALLMONITOR
be2c					endif 
be2c cd 7d 9c				call forth_apush 
be2f			 
be2f				       NEXTW 
be2f c3 c1 9e			jp macro_next 
be32				endm 
# End of macro NEXTW
be32			 
be32			 
be32			 
be32			.SCROLL: 
be32				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
be32 53				db WORD_SYS_CORE+63             
be33 5f be			dw .SCROLLD            
be35 07				db 6 + 1 
be36 .. 00			db "SCROLL",0              
be3d				endm 
# End of macro CWHEAD
be3d			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
be3d					if DEBUG_FORTH_WORDS_KEY 
be3d						DMARK "SCR" 
be3d f5				push af  
be3e 3a 52 be			ld a, (.dmark)  
be41 32 b7 ee			ld (debug_mark),a  
be44 3a 53 be			ld a, (.dmark+1)  
be47 32 b8 ee			ld (debug_mark+1),a  
be4a 3a 54 be			ld a, (.dmark+2)  
be4d 32 b9 ee			ld (debug_mark+2),a  
be50 18 03			jr .pastdmark  
be52 ..			.dmark: db "SCR"  
be55 f1			.pastdmark: pop af  
be56			endm  
# End of macro DMARK
be56						CALLMONITOR 
be56 cd a3 94			call break_point_state  
be59				endm  
# End of macro CALLMONITOR
be59					endif 
be59			 
be59 cd 37 8a			call scroll_up 
be5c			;	call update_display 
be5c			 
be5c					NEXTW 
be5c c3 c1 9e			jp macro_next 
be5f				endm 
# End of macro NEXTW
be5f			 
be5f			 
be5f			 
be5f			;		; get dir 
be5f			; 
be5f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be5f			; 
be5f			;		push hl 
be5f			; 
be5f			;		; destroy value TOS 
be5f			; 
be5f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be5f			; 
be5f			;		; get count 
be5f			; 
be5f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be5f			; 
be5f			;		push hl 
be5f			; 
be5f			;		; destroy value TOS 
be5f			; 
be5f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be5f			; 
be5f			;		; one value on hl get other one back 
be5f			; 
be5f			;		pop bc    ; count 
be5f			; 
be5f			;		pop de   ; dir 
be5f			; 
be5f			; 
be5f			;		ld b, c 
be5f			; 
be5f			;.scrolldir:     push bc 
be5f			;		push de 
be5f			; 
be5f			;		ld a, 0 
be5f			;		cp e 
be5f			;		jr z, .scrollup  
be5f			;		call scroll_down 
be5f			;		jr .scrollnext 
be5f			;.scrollup:	call scroll_up 
be5f			; 
be5f			;		 
be5f			;.scrollnext: 
be5f			;		pop de 
be5f			;		pop bc 
be5f			;		djnz .scrolldir 
be5f			; 
be5f			; 
be5f			; 
be5f			; 
be5f			; 
be5f			;		NEXTW 
be5f			 
be5f			.SCROLLD: 
be5f				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
be5f 53				db WORD_SYS_CORE+63             
be60 8d be			dw .ATQ            
be62 08				db 7 + 1 
be63 .. 00			db "SCROLLD",0              
be6b				endm 
# End of macro CWHEAD
be6b			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
be6b					if DEBUG_FORTH_WORDS_KEY 
be6b						DMARK "SCD" 
be6b f5				push af  
be6c 3a 80 be			ld a, (.dmark)  
be6f 32 b7 ee			ld (debug_mark),a  
be72 3a 81 be			ld a, (.dmark+1)  
be75 32 b8 ee			ld (debug_mark+1),a  
be78 3a 82 be			ld a, (.dmark+2)  
be7b 32 b9 ee			ld (debug_mark+2),a  
be7e 18 03			jr .pastdmark  
be80 ..			.dmark: db "SCD"  
be83 f1			.pastdmark: pop af  
be84			endm  
# End of macro DMARK
be84						CALLMONITOR 
be84 cd a3 94			call break_point_state  
be87				endm  
# End of macro CALLMONITOR
be87					endif 
be87			 
be87 cd 5b 8a			call scroll_down 
be8a			;	call update_display 
be8a			 
be8a					NEXTW 
be8a c3 c1 9e			jp macro_next 
be8d				endm 
# End of macro NEXTW
be8d			 
be8d			 
be8d			.ATQ: 
be8d				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
be8d 62				db WORD_SYS_CORE+78             
be8e eb be			dw .AUTODSP            
be90 04				db 3 + 1 
be91 .. 00			db "AT@",0              
be95				endm 
# End of macro CWHEAD
be95			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
be95					if DEBUG_FORTH_WORDS_KEY 
be95						DMARK "ATA" 
be95 f5				push af  
be96 3a aa be			ld a, (.dmark)  
be99 32 b7 ee			ld (debug_mark),a  
be9c 3a ab be			ld a, (.dmark+1)  
be9f 32 b8 ee			ld (debug_mark+1),a  
bea2 3a ac be			ld a, (.dmark+2)  
bea5 32 b9 ee			ld (debug_mark+2),a  
bea8 18 03			jr .pastdmark  
beaa ..			.dmark: db "ATA"  
bead f1			.pastdmark: pop af  
beae			endm  
# End of macro DMARK
beae						CALLMONITOR 
beae cd a3 94			call break_point_state  
beb1				endm  
# End of macro CALLMONITOR
beb1					endif 
beb1			 
beb1			 
beb1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beb1 cd 0b 9d			call macro_dsp_valuehl 
beb4				endm 
# End of macro FORTH_DSP_VALUEHL
beb4			 
beb4					; TODO save cursor row 
beb4 7d					ld a,l 
beb5 fe 02				cp 2 
beb7 20 04				jr nz, .crow3aq 
beb9 3e 14				ld a, display_row_2 
bebb 18 12				jr .ccol1aq 
bebd fe 03		.crow3aq:		cp 3 
bebf 20 04				jr nz, .crow4aq 
bec1 3e 28				ld a, display_row_3 
bec3 18 0a				jr .ccol1aq 
bec5 fe 04		.crow4aq:		cp 4 
bec7 20 04				jr nz, .crow1aq 
bec9 3e 3c				ld a, display_row_4 
becb 18 02				jr .ccol1aq 
becd 3e 00		.crow1aq:		ld a,display_row_1 
becf f5			.ccol1aq:		push af			; got row offset 
bed0 6f					ld l,a 
bed1 26 00				ld h,0 
bed3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bed3 cd c3 9d			call macro_forth_dsp_pop 
bed6				endm 
# End of macro FORTH_DSP_POP
bed6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bed6 cd 0b 9d			call macro_dsp_valuehl 
bed9				endm 
# End of macro FORTH_DSP_VALUEHL
bed9					; TODO save cursor col 
bed9 f1					pop af 
beda 85					add l		; add col offset 
bedb			 
bedb					; add current frame buffer address 
bedb 2a 58 ed				ld hl, (display_fb_active) 
bede cd a2 8c				call addatohl 
bee1			 
bee1			 
bee1			 
bee1			 
bee1					; get char frame buffer location offset in hl 
bee1			 
bee1 7e					ld a,(hl) 
bee2 26 00				ld h, 0 
bee4 6f					ld l, a 
bee5			 
bee5 cd 14 9b				call forth_push_numhl 
bee8			 
bee8			 
bee8					NEXTW 
bee8 c3 c1 9e			jp macro_next 
beeb				endm 
# End of macro NEXTW
beeb			 
beeb			.AUTODSP: 
beeb				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
beeb 63				db WORD_SYS_CORE+79             
beec 01 bf			dw .MENU            
beee 05				db 4 + 1 
beef .. 00			db "ADSP",0              
bef4				endm 
# End of macro CWHEAD
bef4			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bef4			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bef4			 
bef4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bef4 cd 0b 9d			call macro_dsp_valuehl 
bef7				endm 
# End of macro FORTH_DSP_VALUEHL
bef7			 
bef7			;		push hl 
bef7			 
bef7					; destroy value TOS 
bef7			 
bef7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bef7 cd c3 9d			call macro_forth_dsp_pop 
befa				endm 
# End of macro FORTH_DSP_POP
befa			 
befa			;		pop hl 
befa			 
befa 7d					ld a,l 
befb 32 cc eb				ld (cli_autodisplay), a 
befe				       NEXTW 
befe c3 c1 9e			jp macro_next 
bf01				endm 
# End of macro NEXTW
bf01			 
bf01			.MENU: 
bf01				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bf01 70				db WORD_SYS_CORE+92             
bf02 aa bf			dw .ENDDISPLAY            
bf04 05				db 4 + 1 
bf05 .. 00			db "MENU",0              
bf0a				endm 
# End of macro CWHEAD
bf0a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bf0a			 
bf0a			;		; get number of items on the stack 
bf0a			; 
bf0a				 
bf0a					FORTH_DSP_VALUEHL 
bf0a cd 0b 9d			call macro_dsp_valuehl 
bf0d				endm 
# End of macro FORTH_DSP_VALUEHL
bf0d				 
bf0d					if DEBUG_FORTH_WORDS_KEY 
bf0d						DMARK "MNU" 
bf0d f5				push af  
bf0e 3a 22 bf			ld a, (.dmark)  
bf11 32 b7 ee			ld (debug_mark),a  
bf14 3a 23 bf			ld a, (.dmark+1)  
bf17 32 b8 ee			ld (debug_mark+1),a  
bf1a 3a 24 bf			ld a, (.dmark+2)  
bf1d 32 b9 ee			ld (debug_mark+2),a  
bf20 18 03			jr .pastdmark  
bf22 ..			.dmark: db "MNU"  
bf25 f1			.pastdmark: pop af  
bf26			endm  
# End of macro DMARK
bf26						CALLMONITOR 
bf26 cd a3 94			call break_point_state  
bf29				endm  
# End of macro CALLMONITOR
bf29					endif 
bf29			 
bf29 45					ld b, l	 
bf2a 05					dec b 
bf2b			 
bf2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf2b cd c3 9d			call macro_forth_dsp_pop 
bf2e				endm 
# End of macro FORTH_DSP_POP
bf2e			 
bf2e			 
bf2e					; go directly through the stack to pluck out the string pointers and build an array 
bf2e			 
bf2e			;		FORTH_DSP 
bf2e			 
bf2e					; hl contains top most stack item 
bf2e				 
bf2e 11 51 e4				ld de, scratch 
bf31			 
bf31			.mbuild: 
bf31			 
bf31					FORTH_DSP_VALUEHL 
bf31 cd 0b 9d			call macro_dsp_valuehl 
bf34				endm 
# End of macro FORTH_DSP_VALUEHL
bf34			 
bf34					if DEBUG_FORTH_WORDS 
bf34						DMARK "MN3" 
bf34 f5				push af  
bf35 3a 49 bf			ld a, (.dmark)  
bf38 32 b7 ee			ld (debug_mark),a  
bf3b 3a 4a bf			ld a, (.dmark+1)  
bf3e 32 b8 ee			ld (debug_mark+1),a  
bf41 3a 4b bf			ld a, (.dmark+2)  
bf44 32 b9 ee			ld (debug_mark+2),a  
bf47 18 03			jr .pastdmark  
bf49 ..			.dmark: db "MN3"  
bf4c f1			.pastdmark: pop af  
bf4d			endm  
# End of macro DMARK
bf4d						CALLMONITOR 
bf4d cd a3 94			call break_point_state  
bf50				endm  
# End of macro CALLMONITOR
bf50					endif 
bf50 eb					ex de, hl 
bf51 73					ld (hl), e 
bf52 23					inc hl 
bf53 72					ld (hl), d 
bf54 23					inc hl 
bf55 eb					ex de, hl 
bf56			 
bf56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf56 cd c3 9d			call macro_forth_dsp_pop 
bf59				endm 
# End of macro FORTH_DSP_POP
bf59			 
bf59 10 d6				djnz .mbuild 
bf5b			 
bf5b					; done add term 
bf5b			 
bf5b eb					ex de, hl 
bf5c 36 00				ld (hl), 0 
bf5e 23					inc hl 
bf5f 36 00				ld (hl), 0 
bf61			 
bf61				 
bf61					 
bf61 21 51 e4				ld hl, scratch 
bf64			 
bf64					if DEBUG_FORTH_WORDS 
bf64						DMARK "MNx" 
bf64 f5				push af  
bf65 3a 79 bf			ld a, (.dmark)  
bf68 32 b7 ee			ld (debug_mark),a  
bf6b 3a 7a bf			ld a, (.dmark+1)  
bf6e 32 b8 ee			ld (debug_mark+1),a  
bf71 3a 7b bf			ld a, (.dmark+2)  
bf74 32 b9 ee			ld (debug_mark+2),a  
bf77 18 03			jr .pastdmark  
bf79 ..			.dmark: db "MNx"  
bf7c f1			.pastdmark: pop af  
bf7d			endm  
# End of macro DMARK
bf7d						CALLMONITOR 
bf7d cd a3 94			call break_point_state  
bf80				endm  
# End of macro CALLMONITOR
bf80					endif 
bf80			 
bf80			 
bf80			 
bf80 3e 00				ld a, 0 
bf82 cd a6 8a				call menu 
bf85			 
bf85			 
bf85 6f					ld l, a 
bf86 26 00				ld h, 0 
bf88			 
bf88					if DEBUG_FORTH_WORDS 
bf88						DMARK "MNr" 
bf88 f5				push af  
bf89 3a 9d bf			ld a, (.dmark)  
bf8c 32 b7 ee			ld (debug_mark),a  
bf8f 3a 9e bf			ld a, (.dmark+1)  
bf92 32 b8 ee			ld (debug_mark+1),a  
bf95 3a 9f bf			ld a, (.dmark+2)  
bf98 32 b9 ee			ld (debug_mark+2),a  
bf9b 18 03			jr .pastdmark  
bf9d ..			.dmark: db "MNr"  
bfa0 f1			.pastdmark: pop af  
bfa1			endm  
# End of macro DMARK
bfa1						CALLMONITOR 
bfa1 cd a3 94			call break_point_state  
bfa4				endm  
# End of macro CALLMONITOR
bfa4					endif 
bfa4			 
bfa4 cd 14 9b				call forth_push_numhl 
bfa7			 
bfa7			 
bfa7			 
bfa7			 
bfa7				       NEXTW 
bfa7 c3 c1 9e			jp macro_next 
bfaa				endm 
# End of macro NEXTW
bfaa			 
bfaa			 
bfaa			.ENDDISPLAY: 
bfaa			 
bfaa			; eof 
# End of file forth_words_display.asm
bfaa			include "forth_words_str.asm" 
bfaa			 
bfaa			; | ## String Words 
bfaa			 
bfaa			.PTR:   
bfaa			 
bfaa				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bfaa 48				db WORD_SYS_CORE+52             
bfab d7 bf			dw .STYPE            
bfad 04				db 3 + 1 
bfae .. 00			db "PTR",0              
bfb2				endm 
# End of macro CWHEAD
bfb2			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bfb2			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bfb2			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bfb2			 
bfb2					if DEBUG_FORTH_WORDS_KEY 
bfb2						DMARK "PTR" 
bfb2 f5				push af  
bfb3 3a c7 bf			ld a, (.dmark)  
bfb6 32 b7 ee			ld (debug_mark),a  
bfb9 3a c8 bf			ld a, (.dmark+1)  
bfbc 32 b8 ee			ld (debug_mark+1),a  
bfbf 3a c9 bf			ld a, (.dmark+2)  
bfc2 32 b9 ee			ld (debug_mark+2),a  
bfc5 18 03			jr .pastdmark  
bfc7 ..			.dmark: db "PTR"  
bfca f1			.pastdmark: pop af  
bfcb			endm  
# End of macro DMARK
bfcb						CALLMONITOR 
bfcb cd a3 94			call break_point_state  
bfce				endm  
# End of macro CALLMONITOR
bfce					endif 
bfce					FORTH_DSP_VALUEHL 
bfce cd 0b 9d			call macro_dsp_valuehl 
bfd1				endm 
# End of macro FORTH_DSP_VALUEHL
bfd1 cd 14 9b				call forth_push_numhl 
bfd4			 
bfd4			 
bfd4					NEXTW 
bfd4 c3 c1 9e			jp macro_next 
bfd7				endm 
# End of macro NEXTW
bfd7			.STYPE: 
bfd7				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bfd7 48				db WORD_SYS_CORE+52             
bfd8 26 c0			dw .UPPER            
bfda 06				db 5 + 1 
bfdb .. 00			db "STYPE",0              
bfe1				endm 
# End of macro CWHEAD
bfe1			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bfe1					if DEBUG_FORTH_WORDS_KEY 
bfe1						DMARK "STY" 
bfe1 f5				push af  
bfe2 3a f6 bf			ld a, (.dmark)  
bfe5 32 b7 ee			ld (debug_mark),a  
bfe8 3a f7 bf			ld a, (.dmark+1)  
bfeb 32 b8 ee			ld (debug_mark+1),a  
bfee 3a f8 bf			ld a, (.dmark+2)  
bff1 32 b9 ee			ld (debug_mark+2),a  
bff4 18 03			jr .pastdmark  
bff6 ..			.dmark: db "STY"  
bff9 f1			.pastdmark: pop af  
bffa			endm  
# End of macro DMARK
bffa						CALLMONITOR 
bffa cd a3 94			call break_point_state  
bffd				endm  
# End of macro CALLMONITOR
bffd					endif 
bffd					FORTH_DSP 
bffd cd d1 9c			call macro_forth_dsp 
c000				endm 
# End of macro FORTH_DSP
c000					;v5 FORTH_DSP_VALUE 
c000			 
c000 7e					ld a, (hl) 
c001			 
c001 f5					push af 
c002			 
c002			; Dont destroy TOS		FORTH_DSP_POP 
c002			 
c002 f1					pop af 
c003			 
c003 fe 01				cp DS_TYPE_STR 
c005 28 09				jr z, .typestr 
c007			 
c007 fe 02				cp DS_TYPE_INUM 
c009 28 0a				jr z, .typeinum 
c00b			 
c00b 21 24 c0				ld hl, .tna 
c00e 18 0a				jr .tpush 
c010			 
c010 21 20 c0		.typestr:	ld hl, .tstr 
c013 18 05				jr .tpush 
c015 21 22 c0		.typeinum:	ld hl, .tinum 
c018 18 00				jr .tpush 
c01a			 
c01a			.tpush: 
c01a			 
c01a cd 82 9b				call forth_push_str 
c01d			 
c01d					NEXTW 
c01d c3 c1 9e			jp macro_next 
c020				endm 
# End of macro NEXTW
c020 .. 00		.tstr:	db "s",0 
c022 .. 00		.tinum:  db "i",0 
c024 .. 00		.tna:   db "?", 0 
c026			 
c026			 
c026			.UPPER: 
c026				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c026 48				db WORD_SYS_CORE+52             
c027 61 c0			dw .LOWER            
c029 06				db 5 + 1 
c02a .. 00			db "UPPER",0              
c030				endm 
# End of macro CWHEAD
c030			; | UPPER ( s -- s ) Upper case string s  | DONE 
c030					if DEBUG_FORTH_WORDS_KEY 
c030						DMARK "UPR" 
c030 f5				push af  
c031 3a 45 c0			ld a, (.dmark)  
c034 32 b7 ee			ld (debug_mark),a  
c037 3a 46 c0			ld a, (.dmark+1)  
c03a 32 b8 ee			ld (debug_mark+1),a  
c03d 3a 47 c0			ld a, (.dmark+2)  
c040 32 b9 ee			ld (debug_mark+2),a  
c043 18 03			jr .pastdmark  
c045 ..			.dmark: db "UPR"  
c048 f1			.pastdmark: pop af  
c049			endm  
# End of macro DMARK
c049						CALLMONITOR 
c049 cd a3 94			call break_point_state  
c04c				endm  
# End of macro CALLMONITOR
c04c					endif 
c04c			 
c04c					FORTH_DSP 
c04c cd d1 9c			call macro_forth_dsp 
c04f				endm 
# End of macro FORTH_DSP
c04f					 
c04f			; TODO check is string type 
c04f			 
c04f					FORTH_DSP_VALUEHL 
c04f cd 0b 9d			call macro_dsp_valuehl 
c052				endm 
# End of macro FORTH_DSP_VALUEHL
c052			; get pointer to string in hl 
c052			 
c052 7e			.toup:		ld a, (hl) 
c053 fe 00				cp 0 
c055 28 07				jr z, .toupdone 
c057			 
c057 cd 0f 90				call to_upper 
c05a			 
c05a 77					ld (hl), a 
c05b 23					inc hl 
c05c 18 f4				jr .toup 
c05e			 
c05e					 
c05e			 
c05e			 
c05e			; for each char convert to upper 
c05e					 
c05e			.toupdone: 
c05e			 
c05e			 
c05e					NEXTW 
c05e c3 c1 9e			jp macro_next 
c061				endm 
# End of macro NEXTW
c061			.LOWER: 
c061				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c061 48				db WORD_SYS_CORE+52             
c062 9c c0			dw .TCASE            
c064 06				db 5 + 1 
c065 .. 00			db "LOWER",0              
c06b				endm 
# End of macro CWHEAD
c06b			; | LOWER ( s -- s ) Lower case string s  | DONE 
c06b					if DEBUG_FORTH_WORDS_KEY 
c06b						DMARK "LWR" 
c06b f5				push af  
c06c 3a 80 c0			ld a, (.dmark)  
c06f 32 b7 ee			ld (debug_mark),a  
c072 3a 81 c0			ld a, (.dmark+1)  
c075 32 b8 ee			ld (debug_mark+1),a  
c078 3a 82 c0			ld a, (.dmark+2)  
c07b 32 b9 ee			ld (debug_mark+2),a  
c07e 18 03			jr .pastdmark  
c080 ..			.dmark: db "LWR"  
c083 f1			.pastdmark: pop af  
c084			endm  
# End of macro DMARK
c084						CALLMONITOR 
c084 cd a3 94			call break_point_state  
c087				endm  
# End of macro CALLMONITOR
c087					endif 
c087			 
c087					FORTH_DSP 
c087 cd d1 9c			call macro_forth_dsp 
c08a				endm 
# End of macro FORTH_DSP
c08a					 
c08a			; TODO check is string type 
c08a			 
c08a					FORTH_DSP_VALUEHL 
c08a cd 0b 9d			call macro_dsp_valuehl 
c08d				endm 
# End of macro FORTH_DSP_VALUEHL
c08d			; get pointer to string in hl 
c08d			 
c08d 7e			.tolow:		ld a, (hl) 
c08e fe 00				cp 0 
c090 28 07				jr z, .tolowdone 
c092			 
c092 cd 18 90				call to_lower 
c095			 
c095 77					ld (hl), a 
c096 23					inc hl 
c097 18 f4				jr .tolow 
c099			 
c099					 
c099			 
c099			 
c099			; for each char convert to low 
c099					 
c099			.tolowdone: 
c099					NEXTW 
c099 c3 c1 9e			jp macro_next 
c09c				endm 
# End of macro NEXTW
c09c			.TCASE: 
c09c				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c09c 48				db WORD_SYS_CORE+52             
c09d d2 c1			dw .SUBSTR            
c09f 06				db 5 + 1 
c0a0 .. 00			db "TCASE",0              
c0a6				endm 
# End of macro CWHEAD
c0a6			; | TCASE ( s -- s ) Title case string s  | DONE 
c0a6					if DEBUG_FORTH_WORDS_KEY 
c0a6						DMARK "TCS" 
c0a6 f5				push af  
c0a7 3a bb c0			ld a, (.dmark)  
c0aa 32 b7 ee			ld (debug_mark),a  
c0ad 3a bc c0			ld a, (.dmark+1)  
c0b0 32 b8 ee			ld (debug_mark+1),a  
c0b3 3a bd c0			ld a, (.dmark+2)  
c0b6 32 b9 ee			ld (debug_mark+2),a  
c0b9 18 03			jr .pastdmark  
c0bb ..			.dmark: db "TCS"  
c0be f1			.pastdmark: pop af  
c0bf			endm  
# End of macro DMARK
c0bf						CALLMONITOR 
c0bf cd a3 94			call break_point_state  
c0c2				endm  
# End of macro CALLMONITOR
c0c2					endif 
c0c2			 
c0c2					FORTH_DSP 
c0c2 cd d1 9c			call macro_forth_dsp 
c0c5				endm 
# End of macro FORTH_DSP
c0c5					 
c0c5			; TODO check is string type 
c0c5			 
c0c5					FORTH_DSP_VALUEHL 
c0c5 cd 0b 9d			call macro_dsp_valuehl 
c0c8				endm 
# End of macro FORTH_DSP_VALUEHL
c0c8			; get pointer to string in hl 
c0c8			 
c0c8					if DEBUG_FORTH_WORDS 
c0c8						DMARK "TC1" 
c0c8 f5				push af  
c0c9 3a dd c0			ld a, (.dmark)  
c0cc 32 b7 ee			ld (debug_mark),a  
c0cf 3a de c0			ld a, (.dmark+1)  
c0d2 32 b8 ee			ld (debug_mark+1),a  
c0d5 3a df c0			ld a, (.dmark+2)  
c0d8 32 b9 ee			ld (debug_mark+2),a  
c0db 18 03			jr .pastdmark  
c0dd ..			.dmark: db "TC1"  
c0e0 f1			.pastdmark: pop af  
c0e1			endm  
# End of macro DMARK
c0e1						CALLMONITOR 
c0e1 cd a3 94			call break_point_state  
c0e4				endm  
# End of macro CALLMONITOR
c0e4					endif 
c0e4			 
c0e4					; first time in turn to upper case first char 
c0e4			 
c0e4 7e					ld a, (hl) 
c0e5 c3 6f c1				jp .totsiptou 
c0e8			 
c0e8			 
c0e8 7e			.tot:		ld a, (hl) 
c0e9 fe 00				cp 0 
c0eb ca b3 c1				jp z, .totdone 
c0ee			 
c0ee					if DEBUG_FORTH_WORDS 
c0ee						DMARK "TC2" 
c0ee f5				push af  
c0ef 3a 03 c1			ld a, (.dmark)  
c0f2 32 b7 ee			ld (debug_mark),a  
c0f5 3a 04 c1			ld a, (.dmark+1)  
c0f8 32 b8 ee			ld (debug_mark+1),a  
c0fb 3a 05 c1			ld a, (.dmark+2)  
c0fe 32 b9 ee			ld (debug_mark+2),a  
c101 18 03			jr .pastdmark  
c103 ..			.dmark: db "TC2"  
c106 f1			.pastdmark: pop af  
c107			endm  
# End of macro DMARK
c107						CALLMONITOR 
c107 cd a3 94			call break_point_state  
c10a				endm  
# End of macro CALLMONITOR
c10a					endif 
c10a					; check to see if current char is a space 
c10a			 
c10a fe 20				cp ' ' 
c10c 28 21				jr z, .totsp 
c10e cd 18 90				call to_lower 
c111					if DEBUG_FORTH_WORDS 
c111						DMARK "TC3" 
c111 f5				push af  
c112 3a 26 c1			ld a, (.dmark)  
c115 32 b7 ee			ld (debug_mark),a  
c118 3a 27 c1			ld a, (.dmark+1)  
c11b 32 b8 ee			ld (debug_mark+1),a  
c11e 3a 28 c1			ld a, (.dmark+2)  
c121 32 b9 ee			ld (debug_mark+2),a  
c124 18 03			jr .pastdmark  
c126 ..			.dmark: db "TC3"  
c129 f1			.pastdmark: pop af  
c12a			endm  
# End of macro DMARK
c12a						CALLMONITOR 
c12a cd a3 94			call break_point_state  
c12d				endm  
# End of macro CALLMONITOR
c12d					endif 
c12d 18 63				jr .totnxt 
c12f			 
c12f			.totsp:         ; on a space, find next char which should be upper 
c12f			 
c12f					if DEBUG_FORTH_WORDS 
c12f						DMARK "TC4" 
c12f f5				push af  
c130 3a 44 c1			ld a, (.dmark)  
c133 32 b7 ee			ld (debug_mark),a  
c136 3a 45 c1			ld a, (.dmark+1)  
c139 32 b8 ee			ld (debug_mark+1),a  
c13c 3a 46 c1			ld a, (.dmark+2)  
c13f 32 b9 ee			ld (debug_mark+2),a  
c142 18 03			jr .pastdmark  
c144 ..			.dmark: db "TC4"  
c147 f1			.pastdmark: pop af  
c148			endm  
# End of macro DMARK
c148						CALLMONITOR 
c148 cd a3 94			call break_point_state  
c14b				endm  
# End of macro CALLMONITOR
c14b					endif 
c14b					;; 
c14b			 
c14b fe 20				cp ' ' 
c14d 20 20				jr nz, .totsiptou 
c14f 23					inc hl 
c150 7e					ld a, (hl) 
c151					if DEBUG_FORTH_WORDS 
c151						DMARK "TC5" 
c151 f5				push af  
c152 3a 66 c1			ld a, (.dmark)  
c155 32 b7 ee			ld (debug_mark),a  
c158 3a 67 c1			ld a, (.dmark+1)  
c15b 32 b8 ee			ld (debug_mark+1),a  
c15e 3a 68 c1			ld a, (.dmark+2)  
c161 32 b9 ee			ld (debug_mark+2),a  
c164 18 03			jr .pastdmark  
c166 ..			.dmark: db "TC5"  
c169 f1			.pastdmark: pop af  
c16a			endm  
# End of macro DMARK
c16a						CALLMONITOR 
c16a cd a3 94			call break_point_state  
c16d				endm  
# End of macro CALLMONITOR
c16d					endif 
c16d 18 c0				jr .totsp 
c16f fe 00		.totsiptou:    cp 0 
c171 28 40				jr z, .totdone 
c173					; not space and not zero term so upper case it 
c173 cd 0f 90				call to_upper 
c176			 
c176					if DEBUG_FORTH_WORDS 
c176						DMARK "TC6" 
c176 f5				push af  
c177 3a 8b c1			ld a, (.dmark)  
c17a 32 b7 ee			ld (debug_mark),a  
c17d 3a 8c c1			ld a, (.dmark+1)  
c180 32 b8 ee			ld (debug_mark+1),a  
c183 3a 8d c1			ld a, (.dmark+2)  
c186 32 b9 ee			ld (debug_mark+2),a  
c189 18 03			jr .pastdmark  
c18b ..			.dmark: db "TC6"  
c18e f1			.pastdmark: pop af  
c18f			endm  
# End of macro DMARK
c18f						CALLMONITOR 
c18f cd a3 94			call break_point_state  
c192				endm  
# End of macro CALLMONITOR
c192					endif 
c192			 
c192			 
c192			.totnxt: 
c192			 
c192 77					ld (hl), a 
c193 23					inc hl 
c194					if DEBUG_FORTH_WORDS 
c194						DMARK "TC7" 
c194 f5				push af  
c195 3a a9 c1			ld a, (.dmark)  
c198 32 b7 ee			ld (debug_mark),a  
c19b 3a aa c1			ld a, (.dmark+1)  
c19e 32 b8 ee			ld (debug_mark+1),a  
c1a1 3a ab c1			ld a, (.dmark+2)  
c1a4 32 b9 ee			ld (debug_mark+2),a  
c1a7 18 03			jr .pastdmark  
c1a9 ..			.dmark: db "TC7"  
c1ac f1			.pastdmark: pop af  
c1ad			endm  
# End of macro DMARK
c1ad						CALLMONITOR 
c1ad cd a3 94			call break_point_state  
c1b0				endm  
# End of macro CALLMONITOR
c1b0					endif 
c1b0 c3 e8 c0				jp .tot 
c1b3			 
c1b3					 
c1b3			 
c1b3			 
c1b3			; for each char convert to low 
c1b3					 
c1b3			.totdone: 
c1b3					if DEBUG_FORTH_WORDS 
c1b3						DMARK "TCd" 
c1b3 f5				push af  
c1b4 3a c8 c1			ld a, (.dmark)  
c1b7 32 b7 ee			ld (debug_mark),a  
c1ba 3a c9 c1			ld a, (.dmark+1)  
c1bd 32 b8 ee			ld (debug_mark+1),a  
c1c0 3a ca c1			ld a, (.dmark+2)  
c1c3 32 b9 ee			ld (debug_mark+2),a  
c1c6 18 03			jr .pastdmark  
c1c8 ..			.dmark: db "TCd"  
c1cb f1			.pastdmark: pop af  
c1cc			endm  
# End of macro DMARK
c1cc						CALLMONITOR 
c1cc cd a3 94			call break_point_state  
c1cf				endm  
# End of macro CALLMONITOR
c1cf					endif 
c1cf					NEXTW 
c1cf c3 c1 9e			jp macro_next 
c1d2				endm 
# End of macro NEXTW
c1d2			 
c1d2			.SUBSTR: 
c1d2				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c1d2 48				db WORD_SYS_CORE+52             
c1d3 30 c2			dw .LEFT            
c1d5 07				db 6 + 1 
c1d6 .. 00			db "SUBSTR",0              
c1dd				endm 
# End of macro CWHEAD
c1dd			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c1dd			 
c1dd					if DEBUG_FORTH_WORDS_KEY 
c1dd						DMARK "SST" 
c1dd f5				push af  
c1de 3a f2 c1			ld a, (.dmark)  
c1e1 32 b7 ee			ld (debug_mark),a  
c1e4 3a f3 c1			ld a, (.dmark+1)  
c1e7 32 b8 ee			ld (debug_mark+1),a  
c1ea 3a f4 c1			ld a, (.dmark+2)  
c1ed 32 b9 ee			ld (debug_mark+2),a  
c1f0 18 03			jr .pastdmark  
c1f2 ..			.dmark: db "SST"  
c1f5 f1			.pastdmark: pop af  
c1f6			endm  
# End of macro DMARK
c1f6						CALLMONITOR 
c1f6 cd a3 94			call break_point_state  
c1f9				endm  
# End of macro CALLMONITOR
c1f9					endif 
c1f9			; TODO check string type 
c1f9					FORTH_DSP_VALUEHL 
c1f9 cd 0b 9d			call macro_dsp_valuehl 
c1fc				endm 
# End of macro FORTH_DSP_VALUEHL
c1fc			 
c1fc e5					push hl      ; string length 
c1fd			 
c1fd					FORTH_DSP_POP 
c1fd cd c3 9d			call macro_forth_dsp_pop 
c200				endm 
# End of macro FORTH_DSP_POP
c200			 
c200					FORTH_DSP_VALUEHL 
c200 cd 0b 9d			call macro_dsp_valuehl 
c203				endm 
# End of macro FORTH_DSP_VALUEHL
c203			 
c203 e5					push hl     ; start char 
c204			 
c204					FORTH_DSP_POP 
c204 cd c3 9d			call macro_forth_dsp_pop 
c207				endm 
# End of macro FORTH_DSP_POP
c207			 
c207			 
c207					FORTH_DSP_VALUE 
c207 cd f4 9c			call macro_forth_dsp_value 
c20a				endm 
# End of macro FORTH_DSP_VALUE
c20a			 
c20a d1					pop de    ; get start post offset 
c20b			 
c20b 19					add hl, de    ; starting offset 
c20c			 
c20c c1					pop bc 
c20d c5					push bc      ; grab size of string 
c20e			 
c20e e5					push hl    ; save string start  
c20f			 
c20f 26 00				ld h, 0 
c211 69					ld l, c 
c212 23					inc hl 
c213 23					inc hl 
c214			 
c214 cd 69 91				call malloc 
c217				if DEBUG_FORTH_MALLOC_GUARD 
c217 cc 16 cb				call z,malloc_error 
c21a				endif 
c21a			 
c21a eb					ex de, hl      ; save malloc area for string copy 
c21b e1					pop hl    ; get back source 
c21c c1					pop bc    ; get length of string back 
c21d			 
c21d d5					push de    ; save malloc area for after we push 
c21e ed b0				ldir     ; copy substr 
c220			 
c220			 
c220 eb					ex de, hl 
c221 3e 00				ld a, 0 
c223 77					ld (hl), a   ; term substr 
c224			 
c224					 
c224 e1					pop hl    ; get malloc so we can push it 
c225 e5					push hl   ; save so we can free it afterwards 
c226			 
c226 cd 82 9b				call forth_push_str 
c229			 
c229 e1					pop hl 
c22a cd 33 92				call free 
c22d			 
c22d					 
c22d					 
c22d			 
c22d			 
c22d					NEXTW 
c22d c3 c1 9e			jp macro_next 
c230				endm 
# End of macro NEXTW
c230			 
c230			.LEFT: 
c230				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c230 48				db WORD_SYS_CORE+52             
c231 58 c2			dw .RIGHT            
c233 05				db 4 + 1 
c234 .. 00			db "LEFT",0              
c239				endm 
# End of macro CWHEAD
c239			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c239					if DEBUG_FORTH_WORDS_KEY 
c239						DMARK "LEF" 
c239 f5				push af  
c23a 3a 4e c2			ld a, (.dmark)  
c23d 32 b7 ee			ld (debug_mark),a  
c240 3a 4f c2			ld a, (.dmark+1)  
c243 32 b8 ee			ld (debug_mark+1),a  
c246 3a 50 c2			ld a, (.dmark+2)  
c249 32 b9 ee			ld (debug_mark+2),a  
c24c 18 03			jr .pastdmark  
c24e ..			.dmark: db "LEF"  
c251 f1			.pastdmark: pop af  
c252			endm  
# End of macro DMARK
c252						CALLMONITOR 
c252 cd a3 94			call break_point_state  
c255				endm  
# End of macro CALLMONITOR
c255					endif 
c255			 
c255					NEXTW 
c255 c3 c1 9e			jp macro_next 
c258				endm 
# End of macro NEXTW
c258			.RIGHT: 
c258				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c258 48				db WORD_SYS_CORE+52             
c259 81 c2			dw .STR2NUM            
c25b 06				db 5 + 1 
c25c .. 00			db "RIGHT",0              
c262				endm 
# End of macro CWHEAD
c262			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c262					if DEBUG_FORTH_WORDS_KEY 
c262						DMARK "RIG" 
c262 f5				push af  
c263 3a 77 c2			ld a, (.dmark)  
c266 32 b7 ee			ld (debug_mark),a  
c269 3a 78 c2			ld a, (.dmark+1)  
c26c 32 b8 ee			ld (debug_mark+1),a  
c26f 3a 79 c2			ld a, (.dmark+2)  
c272 32 b9 ee			ld (debug_mark+2),a  
c275 18 03			jr .pastdmark  
c277 ..			.dmark: db "RIG"  
c27a f1			.pastdmark: pop af  
c27b			endm  
# End of macro DMARK
c27b						CALLMONITOR 
c27b cd a3 94			call break_point_state  
c27e				endm  
# End of macro CALLMONITOR
c27e					endif 
c27e			 
c27e					NEXTW 
c27e c3 c1 9e			jp macro_next 
c281				endm 
# End of macro NEXTW
c281			 
c281			 
c281			.STR2NUM: 
c281				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c281 48				db WORD_SYS_CORE+52             
c282 0d c3			dw .NUM2STR            
c284 08				db 7 + 1 
c285 .. 00			db "STR2NUM",0              
c28d				endm 
# End of macro CWHEAD
c28d			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c28d			 
c28d			 
c28d			; TODO STR type check to do 
c28d					if DEBUG_FORTH_WORDS_KEY 
c28d						DMARK "S2N" 
c28d f5				push af  
c28e 3a a2 c2			ld a, (.dmark)  
c291 32 b7 ee			ld (debug_mark),a  
c294 3a a3 c2			ld a, (.dmark+1)  
c297 32 b8 ee			ld (debug_mark+1),a  
c29a 3a a4 c2			ld a, (.dmark+2)  
c29d 32 b9 ee			ld (debug_mark+2),a  
c2a0 18 03			jr .pastdmark  
c2a2 ..			.dmark: db "S2N"  
c2a5 f1			.pastdmark: pop af  
c2a6			endm  
# End of macro DMARK
c2a6						CALLMONITOR 
c2a6 cd a3 94			call break_point_state  
c2a9				endm  
# End of macro CALLMONITOR
c2a9					endif 
c2a9			 
c2a9					;FORTH_DSP 
c2a9					FORTH_DSP_VALUE 
c2a9 cd f4 9c			call macro_forth_dsp_value 
c2ac				endm 
# End of macro FORTH_DSP_VALUE
c2ac					;inc hl 
c2ac			 
c2ac eb					ex de, hl 
c2ad					if DEBUG_FORTH_WORDS 
c2ad						DMARK "S2a" 
c2ad f5				push af  
c2ae 3a c2 c2			ld a, (.dmark)  
c2b1 32 b7 ee			ld (debug_mark),a  
c2b4 3a c3 c2			ld a, (.dmark+1)  
c2b7 32 b8 ee			ld (debug_mark+1),a  
c2ba 3a c4 c2			ld a, (.dmark+2)  
c2bd 32 b9 ee			ld (debug_mark+2),a  
c2c0 18 03			jr .pastdmark  
c2c2 ..			.dmark: db "S2a"  
c2c5 f1			.pastdmark: pop af  
c2c6			endm  
# End of macro DMARK
c2c6						CALLMONITOR 
c2c6 cd a3 94			call break_point_state  
c2c9				endm  
# End of macro CALLMONITOR
c2c9					endif 
c2c9 cd 97 90				call string_to_uint16 
c2cc			 
c2cc					if DEBUG_FORTH_WORDS 
c2cc						DMARK "S2b" 
c2cc f5				push af  
c2cd 3a e1 c2			ld a, (.dmark)  
c2d0 32 b7 ee			ld (debug_mark),a  
c2d3 3a e2 c2			ld a, (.dmark+1)  
c2d6 32 b8 ee			ld (debug_mark+1),a  
c2d9 3a e3 c2			ld a, (.dmark+2)  
c2dc 32 b9 ee			ld (debug_mark+2),a  
c2df 18 03			jr .pastdmark  
c2e1 ..			.dmark: db "S2b"  
c2e4 f1			.pastdmark: pop af  
c2e5			endm  
# End of macro DMARK
c2e5						CALLMONITOR 
c2e5 cd a3 94			call break_point_state  
c2e8				endm  
# End of macro CALLMONITOR
c2e8					endif 
c2e8			;		push hl 
c2e8					FORTH_DSP_POP 
c2e8 cd c3 9d			call macro_forth_dsp_pop 
c2eb				endm 
# End of macro FORTH_DSP_POP
c2eb			;		pop hl 
c2eb					 
c2eb					if DEBUG_FORTH_WORDS 
c2eb						DMARK "S2b" 
c2eb f5				push af  
c2ec 3a 00 c3			ld a, (.dmark)  
c2ef 32 b7 ee			ld (debug_mark),a  
c2f2 3a 01 c3			ld a, (.dmark+1)  
c2f5 32 b8 ee			ld (debug_mark+1),a  
c2f8 3a 02 c3			ld a, (.dmark+2)  
c2fb 32 b9 ee			ld (debug_mark+2),a  
c2fe 18 03			jr .pastdmark  
c300 ..			.dmark: db "S2b"  
c303 f1			.pastdmark: pop af  
c304			endm  
# End of macro DMARK
c304						CALLMONITOR 
c304 cd a3 94			call break_point_state  
c307				endm  
# End of macro CALLMONITOR
c307					endif 
c307 cd 14 9b				call forth_push_numhl	 
c30a			 
c30a				 
c30a				       NEXTW 
c30a c3 c1 9e			jp macro_next 
c30d				endm 
# End of macro NEXTW
c30d			.NUM2STR: 
c30d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c30d 48				db WORD_SYS_CORE+52             
c30e 1c c3			dw .CONCAT            
c310 08				db 7 + 1 
c311 .. 00			db "NUM2STR",0              
c319				endm 
# End of macro CWHEAD
c319			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c319			 
c319			;		; malloc a string to target 
c319			;		ld hl, 10     ; TODO max string size should be fine 
c319			;		call malloc 
c319			;		push hl    ; save malloc location 
c319			; 
c319			; 
c319			;; TODO check int type 
c319			;		FORTH_DSP_VALUEHL 
c319			;		ld a, l 
c319			;		call DispAToASCII   
c319			;;TODO need to chage above call to dump into string 
c319			; 
c319			; 
c319			 
c319				       NEXTW 
c319 c3 c1 9e			jp macro_next 
c31c				endm 
# End of macro NEXTW
c31c			 
c31c			.CONCAT: 
c31c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c31c 48				db WORD_SYS_CORE+52             
c31d cf c3			dw .FIND            
c31f 07				db 6 + 1 
c320 .. 00			db "CONCAT",0              
c327				endm 
# End of macro CWHEAD
c327			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c327			 
c327			; TODO check string type 
c327			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c327			 
c327					if DEBUG_FORTH_WORDS_KEY 
c327						DMARK "CON" 
c327 f5				push af  
c328 3a 3c c3			ld a, (.dmark)  
c32b 32 b7 ee			ld (debug_mark),a  
c32e 3a 3d c3			ld a, (.dmark+1)  
c331 32 b8 ee			ld (debug_mark+1),a  
c334 3a 3e c3			ld a, (.dmark+2)  
c337 32 b9 ee			ld (debug_mark+2),a  
c33a 18 03			jr .pastdmark  
c33c ..			.dmark: db "CON"  
c33f f1			.pastdmark: pop af  
c340			endm  
# End of macro DMARK
c340						CALLMONITOR 
c340 cd a3 94			call break_point_state  
c343				endm  
# End of macro CALLMONITOR
c343					endif 
c343			 
c343			 
c343					FORTH_DSP_VALUE 
c343 cd f4 9c			call macro_forth_dsp_value 
c346				endm 
# End of macro FORTH_DSP_VALUE
c346 e5					push hl   ; s2 
c347			 
c347					FORTH_DSP_POP 
c347 cd c3 9d			call macro_forth_dsp_pop 
c34a				endm 
# End of macro FORTH_DSP_POP
c34a			 
c34a					FORTH_DSP_VALUE 
c34a cd f4 9c			call macro_forth_dsp_value 
c34d				endm 
# End of macro FORTH_DSP_VALUE
c34d			 
c34d e5					push hl   ; s1 
c34e			 
c34e					FORTH_DSP_POP 
c34e cd c3 9d			call macro_forth_dsp_pop 
c351				endm 
# End of macro FORTH_DSP_POP
c351					 
c351			 
c351					; copy s1 
c351			 
c351				 
c351					; save ptr 
c351 e1					pop hl  
c352 e5					push hl 
c353 3e 00				ld a, 0 
c355 cd 0b 91				call strlent 
c358					;inc hl    ; zer0 
c358 06 00				ld b, 0 
c35a 4d					ld c, l 
c35b e1					pop hl		 
c35c 11 51 e4				ld de, scratch	 
c35f					if DEBUG_FORTH_WORDS 
c35f						DMARK "CO1" 
c35f f5				push af  
c360 3a 74 c3			ld a, (.dmark)  
c363 32 b7 ee			ld (debug_mark),a  
c366 3a 75 c3			ld a, (.dmark+1)  
c369 32 b8 ee			ld (debug_mark+1),a  
c36c 3a 76 c3			ld a, (.dmark+2)  
c36f 32 b9 ee			ld (debug_mark+2),a  
c372 18 03			jr .pastdmark  
c374 ..			.dmark: db "CO1"  
c377 f1			.pastdmark: pop af  
c378			endm  
# End of macro DMARK
c378						CALLMONITOR 
c378 cd a3 94			call break_point_state  
c37b				endm  
# End of macro CALLMONITOR
c37b					endif 
c37b ed b0				ldir 
c37d			 
c37d e1					pop hl 
c37e e5					push hl 
c37f d5					push de 
c380			 
c380			 
c380 3e 00				ld a, 0 
c382 cd 0b 91				call strlent 
c385 23					inc hl    ; zer0 
c386 23					inc hl 
c387 06 00				ld b, 0 
c389 4d					ld c, l 
c38a d1					pop de 
c38b e1					pop hl		 
c38c					if DEBUG_FORTH_WORDS 
c38c						DMARK "CO2" 
c38c f5				push af  
c38d 3a a1 c3			ld a, (.dmark)  
c390 32 b7 ee			ld (debug_mark),a  
c393 3a a2 c3			ld a, (.dmark+1)  
c396 32 b8 ee			ld (debug_mark+1),a  
c399 3a a3 c3			ld a, (.dmark+2)  
c39c 32 b9 ee			ld (debug_mark+2),a  
c39f 18 03			jr .pastdmark  
c3a1 ..			.dmark: db "CO2"  
c3a4 f1			.pastdmark: pop af  
c3a5			endm  
# End of macro DMARK
c3a5						CALLMONITOR 
c3a5 cd a3 94			call break_point_state  
c3a8				endm  
# End of macro CALLMONITOR
c3a8					endif 
c3a8 ed b0				ldir 
c3aa			 
c3aa			 
c3aa			 
c3aa 21 51 e4				ld hl, scratch 
c3ad					if DEBUG_FORTH_WORDS 
c3ad						DMARK "CO5" 
c3ad f5				push af  
c3ae 3a c2 c3			ld a, (.dmark)  
c3b1 32 b7 ee			ld (debug_mark),a  
c3b4 3a c3 c3			ld a, (.dmark+1)  
c3b7 32 b8 ee			ld (debug_mark+1),a  
c3ba 3a c4 c3			ld a, (.dmark+2)  
c3bd 32 b9 ee			ld (debug_mark+2),a  
c3c0 18 03			jr .pastdmark  
c3c2 ..			.dmark: db "CO5"  
c3c5 f1			.pastdmark: pop af  
c3c6			endm  
# End of macro DMARK
c3c6						CALLMONITOR 
c3c6 cd a3 94			call break_point_state  
c3c9				endm  
# End of macro CALLMONITOR
c3c9					endif 
c3c9			 
c3c9 cd 82 9b				call forth_push_str 
c3cc			 
c3cc			 
c3cc			 
c3cc			 
c3cc				       NEXTW 
c3cc c3 c1 9e			jp macro_next 
c3cf				endm 
# End of macro NEXTW
c3cf			 
c3cf			 
c3cf			.FIND: 
c3cf				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c3cf 4b				db WORD_SYS_CORE+55             
c3d0 8d c4			dw .LEN            
c3d2 05				db 4 + 1 
c3d3 .. 00			db "FIND",0              
c3d8				endm 
# End of macro CWHEAD
c3d8			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c3d8			 
c3d8					if DEBUG_FORTH_WORDS_KEY 
c3d8						DMARK "FND" 
c3d8 f5				push af  
c3d9 3a ed c3			ld a, (.dmark)  
c3dc 32 b7 ee			ld (debug_mark),a  
c3df 3a ee c3			ld a, (.dmark+1)  
c3e2 32 b8 ee			ld (debug_mark+1),a  
c3e5 3a ef c3			ld a, (.dmark+2)  
c3e8 32 b9 ee			ld (debug_mark+2),a  
c3eb 18 03			jr .pastdmark  
c3ed ..			.dmark: db "FND"  
c3f0 f1			.pastdmark: pop af  
c3f1			endm  
# End of macro DMARK
c3f1						CALLMONITOR 
c3f1 cd a3 94			call break_point_state  
c3f4				endm  
# End of macro CALLMONITOR
c3f4					endif 
c3f4			 
c3f4			; TODO check string type 
c3f4					FORTH_DSP_VALUE 
c3f4 cd f4 9c			call macro_forth_dsp_value 
c3f7				endm 
# End of macro FORTH_DSP_VALUE
c3f7			 
c3f7 e5					push hl    
c3f8 7e					ld a,(hl)    ; char to find   
c3f9			; TODO change char to substr 
c3f9			 
c3f9 f5					push af 
c3fa					 
c3fa			 
c3fa			 
c3fa					if DEBUG_FORTH_WORDS 
c3fa						DMARK "FN1" 
c3fa f5				push af  
c3fb 3a 0f c4			ld a, (.dmark)  
c3fe 32 b7 ee			ld (debug_mark),a  
c401 3a 10 c4			ld a, (.dmark+1)  
c404 32 b8 ee			ld (debug_mark+1),a  
c407 3a 11 c4			ld a, (.dmark+2)  
c40a 32 b9 ee			ld (debug_mark+2),a  
c40d 18 03			jr .pastdmark  
c40f ..			.dmark: db "FN1"  
c412 f1			.pastdmark: pop af  
c413			endm  
# End of macro DMARK
c413						CALLMONITOR 
c413 cd a3 94			call break_point_state  
c416				endm  
# End of macro CALLMONITOR
c416					endif 
c416			 
c416					FORTH_DSP_POP 
c416 cd c3 9d			call macro_forth_dsp_pop 
c419				endm 
# End of macro FORTH_DSP_POP
c419			 
c419					; string to search 
c419			 
c419					FORTH_DSP_VALUE 
c419 cd f4 9c			call macro_forth_dsp_value 
c41c				endm 
# End of macro FORTH_DSP_VALUE
c41c			 
c41c d1					pop de  ; d is char to find  
c41d			 
c41d					if DEBUG_FORTH_WORDS 
c41d						DMARK "FN2" 
c41d f5				push af  
c41e 3a 32 c4			ld a, (.dmark)  
c421 32 b7 ee			ld (debug_mark),a  
c424 3a 33 c4			ld a, (.dmark+1)  
c427 32 b8 ee			ld (debug_mark+1),a  
c42a 3a 34 c4			ld a, (.dmark+2)  
c42d 32 b9 ee			ld (debug_mark+2),a  
c430 18 03			jr .pastdmark  
c432 ..			.dmark: db "FN2"  
c435 f1			.pastdmark: pop af  
c436			endm  
# End of macro DMARK
c436						CALLMONITOR 
c436 cd a3 94			call break_point_state  
c439				endm  
# End of macro CALLMONITOR
c439					endif 
c439					 
c439 01 00 00				ld bc, 0 
c43c 7e			.findchar:      ld a,(hl) 
c43d fe 00				cp 0   		 
c43f 28 27				jr z, .finddone     
c441 ba					cp d 
c442 28 20				jr z, .foundchar 
c444 03					inc bc 
c445 23					inc hl 
c446					if DEBUG_FORTH_WORDS 
c446						DMARK "FN3" 
c446 f5				push af  
c447 3a 5b c4			ld a, (.dmark)  
c44a 32 b7 ee			ld (debug_mark),a  
c44d 3a 5c c4			ld a, (.dmark+1)  
c450 32 b8 ee			ld (debug_mark+1),a  
c453 3a 5d c4			ld a, (.dmark+2)  
c456 32 b9 ee			ld (debug_mark+2),a  
c459 18 03			jr .pastdmark  
c45b ..			.dmark: db "FN3"  
c45e f1			.pastdmark: pop af  
c45f			endm  
# End of macro DMARK
c45f						CALLMONITOR 
c45f cd a3 94			call break_point_state  
c462				endm  
# End of macro CALLMONITOR
c462					endif 
c462 18 d8				jr .findchar 
c464			 
c464			 
c464 c5			.foundchar:	push bc 
c465 e1					pop hl 
c466 18 03				jr .findexit 
c468			 
c468			 
c468							 
c468			 
c468			.finddone:     ; got to end of string with no find 
c468 21 00 00				ld hl, 0 
c46b			.findexit: 
c46b			 
c46b					if DEBUG_FORTH_WORDS 
c46b						DMARK "FNd" 
c46b f5				push af  
c46c 3a 80 c4			ld a, (.dmark)  
c46f 32 b7 ee			ld (debug_mark),a  
c472 3a 81 c4			ld a, (.dmark+1)  
c475 32 b8 ee			ld (debug_mark+1),a  
c478 3a 82 c4			ld a, (.dmark+2)  
c47b 32 b9 ee			ld (debug_mark+2),a  
c47e 18 03			jr .pastdmark  
c480 ..			.dmark: db "FNd"  
c483 f1			.pastdmark: pop af  
c484			endm  
# End of macro DMARK
c484						CALLMONITOR 
c484 cd a3 94			call break_point_state  
c487				endm  
# End of macro CALLMONITOR
c487					endif 
c487 cd 14 9b			call forth_push_numhl 
c48a			 
c48a				       NEXTW 
c48a c3 c1 9e			jp macro_next 
c48d				endm 
# End of macro NEXTW
c48d			 
c48d			.LEN: 
c48d				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c48d 4c				db WORD_SYS_CORE+56             
c48e f7 c4			dw .ASC            
c490 06				db 5 + 1 
c491 .. 00			db "COUNT",0              
c497				endm 
# End of macro CWHEAD
c497			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c497			 
c497					if DEBUG_FORTH_WORDS_KEY 
c497						DMARK "CNT" 
c497 f5				push af  
c498 3a ac c4			ld a, (.dmark)  
c49b 32 b7 ee			ld (debug_mark),a  
c49e 3a ad c4			ld a, (.dmark+1)  
c4a1 32 b8 ee			ld (debug_mark+1),a  
c4a4 3a ae c4			ld a, (.dmark+2)  
c4a7 32 b9 ee			ld (debug_mark+2),a  
c4aa 18 03			jr .pastdmark  
c4ac ..			.dmark: db "CNT"  
c4af f1			.pastdmark: pop af  
c4b0			endm  
# End of macro DMARK
c4b0						CALLMONITOR 
c4b0 cd a3 94			call break_point_state  
c4b3				endm  
# End of macro CALLMONITOR
c4b3					endif 
c4b3			; TODO check string type 
c4b3					FORTH_DSP_VALUE 
c4b3 cd f4 9c			call macro_forth_dsp_value 
c4b6				endm 
# End of macro FORTH_DSP_VALUE
c4b6			 
c4b6			 
c4b6					if DEBUG_FORTH_WORDS 
c4b6						DMARK "CN?" 
c4b6 f5				push af  
c4b7 3a cb c4			ld a, (.dmark)  
c4ba 32 b7 ee			ld (debug_mark),a  
c4bd 3a cc c4			ld a, (.dmark+1)  
c4c0 32 b8 ee			ld (debug_mark+1),a  
c4c3 3a cd c4			ld a, (.dmark+2)  
c4c6 32 b9 ee			ld (debug_mark+2),a  
c4c9 18 03			jr .pastdmark  
c4cb ..			.dmark: db "CN?"  
c4ce f1			.pastdmark: pop af  
c4cf			endm  
# End of macro DMARK
c4cf						CALLMONITOR 
c4cf cd a3 94			call break_point_state  
c4d2				endm  
# End of macro CALLMONITOR
c4d2					endif 
c4d2 cd 00 91				call strlenz 
c4d5					if DEBUG_FORTH_WORDS 
c4d5						DMARK "CNl" 
c4d5 f5				push af  
c4d6 3a ea c4			ld a, (.dmark)  
c4d9 32 b7 ee			ld (debug_mark),a  
c4dc 3a eb c4			ld a, (.dmark+1)  
c4df 32 b8 ee			ld (debug_mark+1),a  
c4e2 3a ec c4			ld a, (.dmark+2)  
c4e5 32 b9 ee			ld (debug_mark+2),a  
c4e8 18 03			jr .pastdmark  
c4ea ..			.dmark: db "CNl"  
c4ed f1			.pastdmark: pop af  
c4ee			endm  
# End of macro DMARK
c4ee						CALLMONITOR 
c4ee cd a3 94			call break_point_state  
c4f1				endm  
# End of macro CALLMONITOR
c4f1					endif 
c4f1			 
c4f1 cd 14 9b				call forth_push_numhl 
c4f4			 
c4f4			 
c4f4			 
c4f4				       NEXTW 
c4f4 c3 c1 9e			jp macro_next 
c4f7				endm 
# End of macro NEXTW
c4f7			.ASC: 
c4f7				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c4f7 4d				db WORD_SYS_CORE+57             
c4f8 65 c5			dw .CHR            
c4fa 04				db 3 + 1 
c4fb .. 00			db "ASC",0              
c4ff				endm 
# End of macro CWHEAD
c4ff			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c4ff					if DEBUG_FORTH_WORDS_KEY 
c4ff						DMARK "ASC" 
c4ff f5				push af  
c500 3a 14 c5			ld a, (.dmark)  
c503 32 b7 ee			ld (debug_mark),a  
c506 3a 15 c5			ld a, (.dmark+1)  
c509 32 b8 ee			ld (debug_mark+1),a  
c50c 3a 16 c5			ld a, (.dmark+2)  
c50f 32 b9 ee			ld (debug_mark+2),a  
c512 18 03			jr .pastdmark  
c514 ..			.dmark: db "ASC"  
c517 f1			.pastdmark: pop af  
c518			endm  
# End of macro DMARK
c518						CALLMONITOR 
c518 cd a3 94			call break_point_state  
c51b				endm  
# End of macro CALLMONITOR
c51b					endif 
c51b					FORTH_DSP_VALUE 
c51b cd f4 9c			call macro_forth_dsp_value 
c51e				endm 
# End of macro FORTH_DSP_VALUE
c51e					;v5 FORTH_DSP_VALUE 
c51e			;		inc hl      ; now at start of numeric as string 
c51e			 
c51e e5					push hl 
c51f			 
c51f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c51f cd c3 9d			call macro_forth_dsp_pop 
c522				endm 
# End of macro FORTH_DSP_POP
c522			 
c522 e1					pop hl 
c523			 
c523					if DEBUG_FORTH_WORDS 
c523						DMARK "AS1" 
c523 f5				push af  
c524 3a 38 c5			ld a, (.dmark)  
c527 32 b7 ee			ld (debug_mark),a  
c52a 3a 39 c5			ld a, (.dmark+1)  
c52d 32 b8 ee			ld (debug_mark+1),a  
c530 3a 3a c5			ld a, (.dmark+2)  
c533 32 b9 ee			ld (debug_mark+2),a  
c536 18 03			jr .pastdmark  
c538 ..			.dmark: db "AS1"  
c53b f1			.pastdmark: pop af  
c53c			endm  
# End of macro DMARK
c53c						CALLMONITOR 
c53c cd a3 94			call break_point_state  
c53f				endm  
# End of macro CALLMONITOR
c53f					endif 
c53f					; push the content of a onto the stack as a value 
c53f			 
c53f 7e					ld a,(hl)   ; get char 
c540 26 00				ld h,0 
c542 6f					ld l,a 
c543					if DEBUG_FORTH_WORDS 
c543						DMARK "AS2" 
c543 f5				push af  
c544 3a 58 c5			ld a, (.dmark)  
c547 32 b7 ee			ld (debug_mark),a  
c54a 3a 59 c5			ld a, (.dmark+1)  
c54d 32 b8 ee			ld (debug_mark+1),a  
c550 3a 5a c5			ld a, (.dmark+2)  
c553 32 b9 ee			ld (debug_mark+2),a  
c556 18 03			jr .pastdmark  
c558 ..			.dmark: db "AS2"  
c55b f1			.pastdmark: pop af  
c55c			endm  
# End of macro DMARK
c55c						CALLMONITOR 
c55c cd a3 94			call break_point_state  
c55f				endm  
# End of macro CALLMONITOR
c55f					endif 
c55f cd 14 9b				call forth_push_numhl 
c562			 
c562				       NEXTW 
c562 c3 c1 9e			jp macro_next 
c565				endm 
# End of macro NEXTW
c565			 
c565			.CHR: 
c565				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c565 4d				db WORD_SYS_CORE+57             
c566 a1 c5			dw .ENDSTR            
c568 04				db 3 + 1 
c569 .. 00			db "CHR",0              
c56d				endm 
# End of macro CWHEAD
c56d			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c56d					if DEBUG_FORTH_WORDS_KEY 
c56d						DMARK "CHR" 
c56d f5				push af  
c56e 3a 82 c5			ld a, (.dmark)  
c571 32 b7 ee			ld (debug_mark),a  
c574 3a 83 c5			ld a, (.dmark+1)  
c577 32 b8 ee			ld (debug_mark+1),a  
c57a 3a 84 c5			ld a, (.dmark+2)  
c57d 32 b9 ee			ld (debug_mark+2),a  
c580 18 03			jr .pastdmark  
c582 ..			.dmark: db "CHR"  
c585 f1			.pastdmark: pop af  
c586			endm  
# End of macro DMARK
c586						CALLMONITOR 
c586 cd a3 94			call break_point_state  
c589				endm  
# End of macro CALLMONITOR
c589					endif 
c589					FORTH_DSP_VALUEHL 
c589 cd 0b 9d			call macro_dsp_valuehl 
c58c				endm 
# End of macro FORTH_DSP_VALUEHL
c58c			 
c58c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c58c cd c3 9d			call macro_forth_dsp_pop 
c58f				endm 
# End of macro FORTH_DSP_POP
c58f			 
c58f					; save asci byte as a zero term string and push string 
c58f			 
c58f 7d					ld a,l 
c590 32 51 e4				ld (scratch), a 
c593			 
c593 3e 00				ld a, 0 
c595 32 52 e4				ld (scratch+1), a 
c598			 
c598 21 51 e4				ld hl, scratch 
c59b cd 82 9b				call forth_push_str 
c59e			 
c59e			 
c59e				       NEXTW 
c59e c3 c1 9e			jp macro_next 
c5a1				endm 
# End of macro NEXTW
c5a1			 
c5a1			 
c5a1			 
c5a1			 
c5a1			.ENDSTR: 
c5a1			; eof 
c5a1			 
# End of file forth_words_str.asm
c5a1			include "forth_words_key.asm" 
c5a1			 
c5a1			; | ## Keyboard Words 
c5a1			 
c5a1			.KEY: 
c5a1				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c5a1 3e				db WORD_SYS_CORE+42             
c5a2 d1 c5			dw .WAITK            
c5a4 04				db 3 + 1 
c5a5 .. 00			db "KEY",0              
c5a9				endm 
# End of macro CWHEAD
c5a9			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c5a9			 
c5a9					if DEBUG_FORTH_WORDS_KEY 
c5a9						DMARK "KEY" 
c5a9 f5				push af  
c5aa 3a be c5			ld a, (.dmark)  
c5ad 32 b7 ee			ld (debug_mark),a  
c5b0 3a bf c5			ld a, (.dmark+1)  
c5b3 32 b8 ee			ld (debug_mark+1),a  
c5b6 3a c0 c5			ld a, (.dmark+2)  
c5b9 32 b9 ee			ld (debug_mark+2),a  
c5bc 18 03			jr .pastdmark  
c5be ..			.dmark: db "KEY"  
c5c1 f1			.pastdmark: pop af  
c5c2			endm  
# End of macro DMARK
c5c2						CALLMONITOR 
c5c2 cd a3 94			call break_point_state  
c5c5				endm  
# End of macro CALLMONITOR
c5c5					endif 
c5c5			; TODO currently waits 
c5c5 cd c4 e1				call cin 
c5c8					;call cin_wait 
c5c8 6f					ld l, a 
c5c9 26 00				ld h, 0 
c5cb cd 14 9b				call forth_push_numhl 
c5ce					NEXTW 
c5ce c3 c1 9e			jp macro_next 
c5d1				endm 
# End of macro NEXTW
c5d1			.WAITK: 
c5d1				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c5d1 3f				db WORD_SYS_CORE+43             
c5d2 03 c6			dw .ACCEPT            
c5d4 06				db 5 + 1 
c5d5 .. 00			db "WAITK",0              
c5db				endm 
# End of macro CWHEAD
c5db			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c5db					if DEBUG_FORTH_WORDS_KEY 
c5db						DMARK "WAI" 
c5db f5				push af  
c5dc 3a f0 c5			ld a, (.dmark)  
c5df 32 b7 ee			ld (debug_mark),a  
c5e2 3a f1 c5			ld a, (.dmark+1)  
c5e5 32 b8 ee			ld (debug_mark+1),a  
c5e8 3a f2 c5			ld a, (.dmark+2)  
c5eb 32 b9 ee			ld (debug_mark+2),a  
c5ee 18 03			jr .pastdmark  
c5f0 ..			.dmark: db "WAI"  
c5f3 f1			.pastdmark: pop af  
c5f4			endm  
# End of macro DMARK
c5f4						CALLMONITOR 
c5f4 cd a3 94			call break_point_state  
c5f7				endm  
# End of macro CALLMONITOR
c5f7					endif 
c5f7 cd be e1				call cin_wait 
c5fa 6f					ld l, a 
c5fb 26 00				ld h, 0 
c5fd cd 14 9b				call forth_push_numhl 
c600					NEXTW 
c600 c3 c1 9e			jp macro_next 
c603				endm 
# End of macro NEXTW
c603			.ACCEPT: 
c603				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c603 40				db WORD_SYS_CORE+44             
c604 61 c6			dw .EDIT            
c606 07				db 6 + 1 
c607 .. 00			db "ACCEPT",0              
c60e				endm 
# End of macro CWHEAD
c60e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c60e					; TODO crashes on push 
c60e					if DEBUG_FORTH_WORDS_KEY 
c60e						DMARK "ACC" 
c60e f5				push af  
c60f 3a 23 c6			ld a, (.dmark)  
c612 32 b7 ee			ld (debug_mark),a  
c615 3a 24 c6			ld a, (.dmark+1)  
c618 32 b8 ee			ld (debug_mark+1),a  
c61b 3a 25 c6			ld a, (.dmark+2)  
c61e 32 b9 ee			ld (debug_mark+2),a  
c621 18 03			jr .pastdmark  
c623 ..			.dmark: db "ACC"  
c626 f1			.pastdmark: pop af  
c627			endm  
# End of macro DMARK
c627						CALLMONITOR 
c627 cd a3 94			call break_point_state  
c62a				endm  
# End of macro CALLMONITOR
c62a					endif 
c62a 21 4f e6				ld hl, os_input 
c62d 3e 00				ld a, 0 
c62f 77					ld (hl),a 
c630 3a ee eb				ld a,(f_cursor_ptr) 
c633 16 64				ld d, 100 
c635 0e 00				ld c, 0 
c637 1e 28				ld e, 40 
c639 cd cf 8c				call input_str 
c63c					; TODO perhaps do a type check and wrap in quotes if not a number 
c63c 21 4f e6				ld hl, os_input 
c63f					if DEBUG_FORTH_WORDS 
c63f						DMARK "AC1" 
c63f f5				push af  
c640 3a 54 c6			ld a, (.dmark)  
c643 32 b7 ee			ld (debug_mark),a  
c646 3a 55 c6			ld a, (.dmark+1)  
c649 32 b8 ee			ld (debug_mark+1),a  
c64c 3a 56 c6			ld a, (.dmark+2)  
c64f 32 b9 ee			ld (debug_mark+2),a  
c652 18 03			jr .pastdmark  
c654 ..			.dmark: db "AC1"  
c657 f1			.pastdmark: pop af  
c658			endm  
# End of macro DMARK
c658						CALLMONITOR 
c658 cd a3 94			call break_point_state  
c65b				endm  
# End of macro CALLMONITOR
c65b					endif 
c65b cd 82 9b				call forth_push_str 
c65e					NEXTW 
c65e c3 c1 9e			jp macro_next 
c661				endm 
# End of macro NEXTW
c661			 
c661			.EDIT: 
c661				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c661 40				db WORD_SYS_CORE+44             
c662 03 c7			dw .ENDKEY            
c664 05				db 4 + 1 
c665 .. 00			db "EDIT",0              
c66a				endm 
# End of macro CWHEAD
c66a			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c66a			 
c66a					; TODO does not copy from stack 
c66a					if DEBUG_FORTH_WORDS_KEY 
c66a						DMARK "EDT" 
c66a f5				push af  
c66b 3a 7f c6			ld a, (.dmark)  
c66e 32 b7 ee			ld (debug_mark),a  
c671 3a 80 c6			ld a, (.dmark+1)  
c674 32 b8 ee			ld (debug_mark+1),a  
c677 3a 81 c6			ld a, (.dmark+2)  
c67a 32 b9 ee			ld (debug_mark+2),a  
c67d 18 03			jr .pastdmark  
c67f ..			.dmark: db "EDT"  
c682 f1			.pastdmark: pop af  
c683			endm  
# End of macro DMARK
c683						CALLMONITOR 
c683 cd a3 94			call break_point_state  
c686				endm  
# End of macro CALLMONITOR
c686					endif 
c686			 
c686					;FORTH_DSP 
c686					FORTH_DSP_VALUEHL 
c686 cd 0b 9d			call macro_dsp_valuehl 
c689				endm 
# End of macro FORTH_DSP_VALUEHL
c689			;		inc hl    ; TODO do type check 
c689			 
c689			;		call get_word_hl 
c689 e5					push hl 
c68a					if DEBUG_FORTH_WORDS 
c68a						DMARK "EDp" 
c68a f5				push af  
c68b 3a 9f c6			ld a, (.dmark)  
c68e 32 b7 ee			ld (debug_mark),a  
c691 3a a0 c6			ld a, (.dmark+1)  
c694 32 b8 ee			ld (debug_mark+1),a  
c697 3a a1 c6			ld a, (.dmark+2)  
c69a 32 b9 ee			ld (debug_mark+2),a  
c69d 18 03			jr .pastdmark  
c69f ..			.dmark: db "EDp"  
c6a2 f1			.pastdmark: pop af  
c6a3			endm  
# End of macro DMARK
c6a3						CALLMONITOR 
c6a3 cd a3 94			call break_point_state  
c6a6				endm  
# End of macro CALLMONITOR
c6a6					endif 
c6a6				;	ld a, 0 
c6a6 cd 00 91				call strlenz 
c6a9 23					inc hl 
c6aa			 
c6aa 06 00				ld b, 0 
c6ac 4d					ld c, l 
c6ad			 
c6ad e1					pop hl 
c6ae 11 4f e6				ld de, os_input 
c6b1					if DEBUG_FORTH_WORDS_KEY 
c6b1						DMARK "EDc" 
c6b1 f5				push af  
c6b2 3a c6 c6			ld a, (.dmark)  
c6b5 32 b7 ee			ld (debug_mark),a  
c6b8 3a c7 c6			ld a, (.dmark+1)  
c6bb 32 b8 ee			ld (debug_mark+1),a  
c6be 3a c8 c6			ld a, (.dmark+2)  
c6c1 32 b9 ee			ld (debug_mark+2),a  
c6c4 18 03			jr .pastdmark  
c6c6 ..			.dmark: db "EDc"  
c6c9 f1			.pastdmark: pop af  
c6ca			endm  
# End of macro DMARK
c6ca						CALLMONITOR 
c6ca cd a3 94			call break_point_state  
c6cd				endm  
# End of macro CALLMONITOR
c6cd					endif 
c6cd ed b0				ldir 
c6cf			 
c6cf			 
c6cf 21 4f e6				ld hl, os_input 
c6d2					;ld a, 0 
c6d2					;ld (hl),a 
c6d2 3a ee eb				ld a,(f_cursor_ptr) 
c6d5 16 64				ld d, 100 
c6d7 0e 00				ld c, 0 
c6d9 1e 28				ld e, 40 
c6db cd cf 8c				call input_str 
c6de					; TODO perhaps do a type check and wrap in quotes if not a number 
c6de 21 4f e6				ld hl, os_input 
c6e1					if DEBUG_FORTH_WORDS 
c6e1						DMARK "ED1" 
c6e1 f5				push af  
c6e2 3a f6 c6			ld a, (.dmark)  
c6e5 32 b7 ee			ld (debug_mark),a  
c6e8 3a f7 c6			ld a, (.dmark+1)  
c6eb 32 b8 ee			ld (debug_mark+1),a  
c6ee 3a f8 c6			ld a, (.dmark+2)  
c6f1 32 b9 ee			ld (debug_mark+2),a  
c6f4 18 03			jr .pastdmark  
c6f6 ..			.dmark: db "ED1"  
c6f9 f1			.pastdmark: pop af  
c6fa			endm  
# End of macro DMARK
c6fa						CALLMONITOR 
c6fa cd a3 94			call break_point_state  
c6fd				endm  
# End of macro CALLMONITOR
c6fd					endif 
c6fd cd 82 9b				call forth_push_str 
c700					NEXTW 
c700 c3 c1 9e			jp macro_next 
c703				endm 
# End of macro NEXTW
c703			 
c703			 
c703			 
c703			.ENDKEY: 
c703			; eof 
c703			 
# End of file forth_words_key.asm
c703			include "forth_words_const.asm" 
c703			 
c703			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c703			 
c703			 
c703			.SPITIME: 
c703				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c703 77				db WORD_SYS_CORE+99             
c704 18 c7			dw .VA            
c706 08				db 7 + 1 
c707 .. 00			db "SPITIME",0              
c70f				endm 
# End of macro CWHEAD
c70f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c70f			; 
c70f			; | If using BANK devices then leave as is. 
c70f			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c70f			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c70f			 
c70f 21 f4 eb				ld hl, spi_clktime  
c712 cd 14 9b				call forth_push_numhl 
c715			 
c715					NEXTW 
c715 c3 c1 9e			jp macro_next 
c718				endm 
# End of macro NEXTW
c718			 
c718			 
c718			.VA: 
c718				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c718 77				db WORD_SYS_CORE+99             
c719 28 c7			dw .SYMBOL            
c71b 03				db 2 + 1 
c71c .. 00			db "VA",0              
c71f				endm 
# End of macro CWHEAD
c71f			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c71f 21 b8 eb				ld hl, cli_var_array 
c722 cd 14 9b				call forth_push_numhl 
c725			 
c725					NEXTW 
c725 c3 c1 9e			jp macro_next 
c728				endm 
# End of macro NEXTW
c728			 
c728			.SYMBOL: 
c728				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c728 77				db WORD_SYS_CORE+99             
c729 60 c8			dw .ENDCONST            
c72b 07				db 6 + 1 
c72c .. 00			db "SYMBOL",0              
c733				endm 
# End of macro CWHEAD
c733			;| SYMBOL ( u1 -- )  Get the address of a system sysmbol from a look up table to TOS  | TO TEST 
c733			;| 
c733			;| The value is the number reference and the final address is pushed to stack 
c733			 
c733					if DEBUG_FORTH_WORDS_KEY 
c733						DMARK "SYM" 
c733 f5				push af  
c734 3a 48 c7			ld a, (.dmark)  
c737 32 b7 ee			ld (debug_mark),a  
c73a 3a 49 c7			ld a, (.dmark+1)  
c73d 32 b8 ee			ld (debug_mark+1),a  
c740 3a 4a c7			ld a, (.dmark+2)  
c743 32 b9 ee			ld (debug_mark+2),a  
c746 18 03			jr .pastdmark  
c748 ..			.dmark: db "SYM"  
c74b f1			.pastdmark: pop af  
c74c			endm  
# End of macro DMARK
c74c						CALLMONITOR 
c74c cd a3 94			call break_point_state  
c74f				endm  
# End of macro CALLMONITOR
c74f					endif 
c74f			 
c74f					FORTH_DSP_VALUEHL 
c74f cd 0b 9d			call macro_dsp_valuehl 
c752				endm 
# End of macro FORTH_DSP_VALUEHL
c752			 
c752 7d					ld a, l     
c753			 
c753			 
c753					if DEBUG_FORTH_WORDS 
c753						DMARK "SY1" 
c753 f5				push af  
c754 3a 68 c7			ld a, (.dmark)  
c757 32 b7 ee			ld (debug_mark),a  
c75a 3a 69 c7			ld a, (.dmark+1)  
c75d 32 b8 ee			ld (debug_mark+1),a  
c760 3a 6a c7			ld a, (.dmark+2)  
c763 32 b9 ee			ld (debug_mark+2),a  
c766 18 03			jr .pastdmark  
c768 ..			.dmark: db "SY1"  
c76b f1			.pastdmark: pop af  
c76c			endm  
# End of macro DMARK
c76c						CALLMONITOR 
c76c cd a3 94			call break_point_state  
c76f				endm  
# End of macro CALLMONITOR
c76f					endif 
c76f					 
c76f f5					push af	 
c770					FORTH_DSP_POP 
c770 cd c3 9d			call macro_forth_dsp_pop 
c773				endm 
# End of macro FORTH_DSP_POP
c773 f1					pop af 
c774			 
c774 cb 27				sla a  
c776				 
c776					 
c776					if DEBUG_FORTH_WORDS 
c776						DMARK "SY" 
c776 f5				push af  
c777 3a 8b c7			ld a, (.dmark)  
c77a 32 b7 ee			ld (debug_mark),a  
c77d 3a 8c c7			ld a, (.dmark+1)  
c780 32 b8 ee			ld (debug_mark+1),a  
c783 3a 8d c7			ld a, (.dmark+2)  
c786 32 b9 ee			ld (debug_mark+2),a  
c789 18 02			jr .pastdmark  
c78b ..			.dmark: db "SY"  
c78d f1			.pastdmark: pop af  
c78e			endm  
# End of macro DMARK
c78e						CALLMONITOR 
c78e cd a3 94			call break_point_state  
c791				endm  
# End of macro CALLMONITOR
c791					endif 
c791			 
c791 21 a0 c7				ld hl, sym_table 
c794 cd a2 8c				call addatohl 
c797 cd 43 9e				call loadwordinhl 
c79a cd 14 9b				call forth_push_numhl 
c79d			 
c79d			 
c79d				       NEXTW 
c79d c3 c1 9e			jp macro_next 
c7a0				endm 
# End of macro NEXTW
c7a0			 
c7a0			sym_table: 
c7a0			 
c7a0			; 0 
c7a0 cc eb		dw cli_autodisplay 
c7a2 da eb		dw cli_buffer 
c7a4 7e eb		dw cli_data_sp 
c7a6 b8 e9		dw cli_data_stack 
c7a8 d4 eb		dw cli_execword 
c7aa 80 eb		dw cli_loop_sp 
c7ac ba ea		dw cli_loop_stack 
c7ae cd eb		dw cli_mvdot 
c7b0 d2 eb		dw cli_nextword 
c7b2 ce eb		dw cli_origptr 
c7b4 d8 eb		dw cli_origtoken 
c7b6			; 11 
c7b6 d0 eb		dw cli_ptr 
c7b8 82 eb		dw cli_ret_sp 
c7ba 3c eb		dw cli_ret_stack 
c7bc d6 eb		dw cli_token 
c7be b8 eb		dw cli_var_array 
c7c0 54 ed		dw cursor_col 
c7c2 52 ed		dw cursor_ptr 
c7c4 53 ed		dw cursor_row 
c7c6 50 ed		dw cursor_shape 
c7c8 b7 ee		dw debug_mark 
c7ca			; 21 
c7ca 4d ee		dw display_fb0 
c7cc fc ed		dw display_fb1 
c7ce 5a ed		dw display_fb2 
c7d0 ab ed		dw display_fb3 
c7d2 58 ed		dw display_fb_active 
c7d4 50 e5		dw execscratch 
c7d6 ee eb		dw f_cursor_ptr 
c7d8 bb ee		dw hardware_word 
c7da ae ee		dw input_at_cursor 
c7dc b0 ee		dw input_at_pos 
c7de			; 31 
c7de ac ee		dw input_cur_flash 
c7e0 ab ee		dw input_cur_onoff 
c7e2 a1 ee		dw input_cursor 
c7e4 b1 ee		dw input_display_size 
c7e6 a6 ee		dw input_len 
c7e8 b5 ee		dw input_ptr 
c7ea b2 ee		dw input_size 
c7ec b3 ee		dw input_start 
c7ee cf 8c		dw input_str 
c7f0 af ee		dw input_under_cursor 
c7f2			; 41 
c7f2 a0 ee		dw key_actual_pressed 
c7f4 cb ee		dw key_fa 
c7f6 c7 ee		dw key_face_held 
c7f8 ca ee		dw key_fb 
c7fa c9 ee		dw key_fc 
c7fc c8 ee		dw key_fd 
c7fe d1 ee		dw key_held 
c800 d0 ee		dw key_held_prev 
c802 bd e1		dw key_init 
c804 cc ee		dw key_repeat_ct 
c806			; 51 
c806 04 00		dw key_rows 
c808 9e ee		dw key_shift 
c80a 9f ee		dw key_symbol 
c80c d2 ee		dw keyscan_scancol 
c80e d6 ee		dw keyscan_table 
c810 fb ee		dw keyscan_table_row1 
c812 f6 ee		dw keyscan_table_row2 
c814 f1 ee		dw keyscan_table_row3 
c816 ec ee		dw keyscan_table_row4 
c818 e7 ee		dw keyscan_table_row5 
c81a			; 61 
c81a 78 e7		dw os_cli_cmd 
c81c 74 e7		dw os_cur_ptr 
c81e 76 e7		dw os_current_i 
c820 4f e6		dw os_input 
c822 77 e8		dw os_last_cmd 
c824 4e e7		dw os_last_new_uword 
c826 42 e4		dw os_view_disable 
c828 3e e4		dw os_view_hl 
c82a 56 e7		dw os_word_scratch 
c82c c3 00		dw portbctl 
c82e			; 71 
c82e c1 00		dw portbdata 
c830 f3 eb		dw spi_cartdev 
c832 f2 eb		dw spi_cartdev2 
c834 f4 eb		dw spi_clktime 
c836 f0 eb		dw spi_device 
c838 ef eb		dw spi_device_id 
c83a f1 eb		dw spi_portbyte 
c83c 36 ed		dw stackstore 
c83e			if STORAGE_SE 
c83e			dw storage_actl 
c83e			dw storage_adata 
c83e			else 
c83e 00 00		dw 0 
c840 00 00		dw 0 
c842			endif 
c842			; 81 
c842 69 88		dw storage_append 
c844			if STORAGE_SE 
c844			dw storage_bctl 
c844			else 
c844 00 00		dw 0 
c846			endif 
c846 22 ed		dw store_bank_active 
c848 f7 eb		dw store_filecache 
c84a 05 ec		dw store_longread 
c84c fb eb		dw store_openaddr 
c84e fa eb		dw store_openext 
c850 f9 eb		dw store_openmaxext 
c852 0a ec		dw store_page 
c854 06 ec		dw store_readbuf 
c856			; 91 
c856 fd eb		dw store_readcont 
c858 08 ec		dw store_readptr 
c85a fd eb		dw store_tmpext 
c85c fe eb		dw store_tmpid 
c85e f5 eb		dw store_tmppageid 
c860			 
c860			 
c860			.ENDCONST: 
c860			 
c860			; eof 
c860			 
c860			 
# End of file forth_words_const.asm
c860			 
c860			if STORAGE_SE 
c860			   	include "forth_words_storage.asm" 
c860			endif 
c860				include "forth_words_device.asm" 
c860			; Device related words 
c860			 
c860			; | ## Device Words 
c860			 
c860			;if SOUND_ENABLE 
c860			;.NOTE: 
c860			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c860			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c860			;		if DEBUG_FORTH_WORDS_KEY 
c860			;			DMARK "NTE" 
c860			;			CALLMONITOR 
c860			;		endif 
c860			; 
c860			;	 
c860			; 
c860			;		NEXTW 
c860			;.AFTERSOUND: 
c860			;endif 
c860			 
c860			 
c860			USE_GPIO: equ 0 
c860			 
c860			if USE_GPIO 
c860			.GP1: 
c860				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c860			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c860					NEXTW 
c860			.GP2: 
c860				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c860			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c860			 
c860					NEXTW 
c860			 
c860			.GP3: 
c860				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c860			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c860			 
c860					NEXTW 
c860			 
c860			.GP4: 
c860				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c860			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c860			 
c860					NEXTW 
c860			.SIN: 
c860			 
c860			 
c860			endif 
c860			 
c860			 
c860				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c860 33				db WORD_SYS_CORE+31             
c861 95 c8			dw .SOUT            
c863 03				db 2 + 1 
c864 .. 00			db "IN",0              
c867				endm 
# End of macro CWHEAD
c867			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c867					if DEBUG_FORTH_WORDS_KEY 
c867						DMARK "IN." 
c867 f5				push af  
c868 3a 7c c8			ld a, (.dmark)  
c86b 32 b7 ee			ld (debug_mark),a  
c86e 3a 7d c8			ld a, (.dmark+1)  
c871 32 b8 ee			ld (debug_mark+1),a  
c874 3a 7e c8			ld a, (.dmark+2)  
c877 32 b9 ee			ld (debug_mark+2),a  
c87a 18 03			jr .pastdmark  
c87c ..			.dmark: db "IN."  
c87f f1			.pastdmark: pop af  
c880			endm  
# End of macro DMARK
c880						CALLMONITOR 
c880 cd a3 94			call break_point_state  
c883				endm  
# End of macro CALLMONITOR
c883					endif 
c883					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c883 cd 0b 9d			call macro_dsp_valuehl 
c886				endm 
# End of macro FORTH_DSP_VALUEHL
c886			 
c886 e5					push hl 
c887			 
c887					; destroy value TOS 
c887			 
c887					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c887 cd c3 9d			call macro_forth_dsp_pop 
c88a				endm 
# End of macro FORTH_DSP_POP
c88a			 
c88a					; one value on hl get other one back 
c88a			 
c88a c1					pop bc 
c88b			 
c88b					; do the sub 
c88b			;		ex de, hl 
c88b			 
c88b ed 68				in l,(c) 
c88d			 
c88d					; save it 
c88d			 
c88d 26 00				ld h,0 
c88f			 
c88f					; TODO push value back onto stack for another op etc 
c88f			 
c88f cd 14 9b				call forth_push_numhl 
c892					NEXTW 
c892 c3 c1 9e			jp macro_next 
c895				endm 
# End of macro NEXTW
c895			.SOUT: 
c895				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c895 34				db WORD_SYS_CORE+32             
c896 e8 c8			dw .SPIO            
c898 04				db 3 + 1 
c899 .. 00			db "OUT",0              
c89d				endm 
# End of macro CWHEAD
c89d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c89d					if DEBUG_FORTH_WORDS_KEY 
c89d						DMARK "OUT" 
c89d f5				push af  
c89e 3a b2 c8			ld a, (.dmark)  
c8a1 32 b7 ee			ld (debug_mark),a  
c8a4 3a b3 c8			ld a, (.dmark+1)  
c8a7 32 b8 ee			ld (debug_mark+1),a  
c8aa 3a b4 c8			ld a, (.dmark+2)  
c8ad 32 b9 ee			ld (debug_mark+2),a  
c8b0 18 03			jr .pastdmark  
c8b2 ..			.dmark: db "OUT"  
c8b5 f1			.pastdmark: pop af  
c8b6			endm  
# End of macro DMARK
c8b6						CALLMONITOR 
c8b6 cd a3 94			call break_point_state  
c8b9				endm  
# End of macro CALLMONITOR
c8b9					endif 
c8b9			 
c8b9					; get port 
c8b9			 
c8b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c8b9 cd 0b 9d			call macro_dsp_valuehl 
c8bc				endm 
# End of macro FORTH_DSP_VALUEHL
c8bc			 
c8bc e5					push hl 
c8bd			 
c8bd					; destroy value TOS 
c8bd			 
c8bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8bd cd c3 9d			call macro_forth_dsp_pop 
c8c0				endm 
# End of macro FORTH_DSP_POP
c8c0			 
c8c0					; get byte to send 
c8c0			 
c8c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c8c0 cd 0b 9d			call macro_dsp_valuehl 
c8c3				endm 
# End of macro FORTH_DSP_VALUEHL
c8c3			 
c8c3			;		push hl 
c8c3			 
c8c3					; destroy value TOS 
c8c3			 
c8c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8c3 cd c3 9d			call macro_forth_dsp_pop 
c8c6				endm 
# End of macro FORTH_DSP_POP
c8c6			 
c8c6					; one value on hl get other one back 
c8c6			 
c8c6			;		pop hl 
c8c6			 
c8c6 c1					pop bc 
c8c7			 
c8c7					if DEBUG_FORTH_WORDS 
c8c7						DMARK "OUT" 
c8c7 f5				push af  
c8c8 3a dc c8			ld a, (.dmark)  
c8cb 32 b7 ee			ld (debug_mark),a  
c8ce 3a dd c8			ld a, (.dmark+1)  
c8d1 32 b8 ee			ld (debug_mark+1),a  
c8d4 3a de c8			ld a, (.dmark+2)  
c8d7 32 b9 ee			ld (debug_mark+2),a  
c8da 18 03			jr .pastdmark  
c8dc ..			.dmark: db "OUT"  
c8df f1			.pastdmark: pop af  
c8e0			endm  
# End of macro DMARK
c8e0						CALLMONITOR 
c8e0 cd a3 94			call break_point_state  
c8e3				endm  
# End of macro CALLMONITOR
c8e3					endif 
c8e3			 
c8e3 ed 69				out (c), l 
c8e5			 
c8e5					NEXTW 
c8e5 c3 c1 9e			jp macro_next 
c8e8				endm 
# End of macro NEXTW
c8e8			 
c8e8			 
c8e8			.SPIO: 
c8e8			 
c8e8			if STORAGE_SE 
c8e8				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c8e8			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c8e8			 
c8e8					call spi_ce_low 
c8e8			    NEXTW 
c8e8			 
c8e8			.SPICEH: 
c8e8				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c8e8			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c8e8			 
c8e8					call spi_ce_high 
c8e8			    NEXTW 
c8e8			 
c8e8			 
c8e8			.SPIOb: 
c8e8			 
c8e8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c8e8			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c8e8			 
c8e8					if DEBUG_FORTH_WORDS_KEY 
c8e8						DMARK "SPo" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8					; get port 
c8e8			 
c8e8			 
c8e8					; get byte to send 
c8e8			 
c8e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c8e8			 
c8e8			;		push hl    ; u1  
c8e8			 
c8e8					; destroy value TOS 
c8e8			 
c8e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8e8			 
c8e8					; one value on hl get other one back 
c8e8			 
c8e8			;		pop hl   ; u2 - addr 
c8e8			 
c8e8					; TODO Send SPI byte 
c8e8			 
c8e8			;		push hl 
c8e8			;		call spi_ce_low 
c8e8			;		pop hl 
c8e8					ld a, l 
c8e8					call spi_send_byte 
c8e8			;		call spi_ce_high 
c8e8			 
c8e8					NEXTW 
c8e8			 
c8e8			.SPII: 
c8e8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c8e8			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c8e8					if DEBUG_FORTH_WORDS_KEY 
c8e8						DMARK "SPi" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8			 
c8e8					; TODO Get SPI byte 
c8e8			 
c8e8					call spi_read_byte 
c8e8			 
c8e8					if DEBUG_FORTH_WORDS 
c8e8						DMARK "Si2" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8					ld h, 0 
c8e8					ld l, a 
c8e8					if DEBUG_FORTH_WORDS 
c8e8						DMARK "Si3" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8					call forth_push_numhl 
c8e8			 
c8e8					NEXTW 
c8e8			 
c8e8			 
c8e8			 
c8e8			.SESEL: 
c8e8				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c8e8			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c8e8					if DEBUG_FORTH_WORDS_KEY 
c8e8						DMARK "BNK" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8			 
c8e8					ld a, 255 
c8e8					ld (spi_cartdev), a 
c8e8			 
c8e8					; get bank 
c8e8			 
c8e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c8e8			 
c8e8			;		push hl 
c8e8			 
c8e8					; destroy value TOS 
c8e8			 
c8e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8e8			 
c8e8					; one value on hl get other one back 
c8e8			 
c8e8			;		pop hl 
c8e8			 
c8e8			 
c8e8					ld c, SPI_CE_HIGH 
c8e8					ld b, '0'    ; human readable bank number 
c8e8			 
c8e8					ld a, l 
c8e8			 
c8e8					if DEBUG_FORTH_WORDS 
c8e8						DMARK "BNK" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8			 
c8e8					; active low 
c8e8			 
c8e8					cp 0 
c8e8					jr z, .bset 
c8e8					cp 1 
c8e8					jr nz, .b2 
c8e8					res 0, c 
c8e8					ld b, '1'    ; human readable bank number 
c8e8			.b2:		cp 2 
c8e8					jr nz, .b3 
c8e8					res 1, c 
c8e8					ld b, '2'    ; human readable bank number 
c8e8			.b3:		cp 3 
c8e8					jr nz, .b4 
c8e8					res 2, c 
c8e8					ld b, '3'    ; human readable bank number 
c8e8			.b4:		cp 4 
c8e8					jr nz, .b5 
c8e8					res 3, c 
c8e8					ld b, '4'    ; human readable bank number 
c8e8			.b5:		cp 5 
c8e8					jr nz, .bset 
c8e8					res 4, c 
c8e8					ld b, '5'    ; human readable bank number 
c8e8			 
c8e8			.bset: 
c8e8					ld a, c 
c8e8					ld (spi_device),a 
c8e8					ld a, b 
c8e8					ld (spi_device_id),a 
c8e8					if DEBUG_FORTH_WORDS 
c8e8						DMARK "BN2" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8			 
c8e8					; set default SPI clk pulse time as disabled for BANK use 
c8e8			 
c8e8					ld a, 0 
c8e8					ld (spi_clktime), a 
c8e8			 
c8e8					NEXTW 
c8e8			 
c8e8			.CARTDEV: 
c8e8				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c8e8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c8e8					if DEBUG_FORTH_WORDS_KEY 
c8e8						DMARK "CDV" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8			 
c8e8					; disable se storage bank selection 
c8e8			 
c8e8					ld a, SPI_CE_HIGH		; ce high 
c8e8					ld (spi_device), a 
c8e8			 
c8e8					; get bank 
c8e8			 
c8e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c8e8			 
c8e8			;		push hl 
c8e8			 
c8e8					; destroy value TOS 
c8e8			 
c8e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8e8			 
c8e8					; one value on hl get other one back 
c8e8			 
c8e8			;		pop hl 
c8e8			 
c8e8					; active low 
c8e8			 
c8e8					ld c, 255 
c8e8			 
c8e8					ld a, l 
c8e8					if DEBUG_FORTH_WORDS 
c8e8						DMARK "CDV" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8					cp 0 
c8e8					jr z, .cset 
c8e8					cp 1 
c8e8					jr nz, .c2 
c8e8					res 0, c 
c8e8			.c2:		cp 2 
c8e8					jr nz, .c3 
c8e8					res 1, c 
c8e8			.c3:		cp 3 
c8e8					jr nz, .c4 
c8e8					res 2, c 
c8e8			.c4:		cp 4 
c8e8					jr nz, .c5 
c8e8					res 3, c 
c8e8			.c5:		cp 5 
c8e8					jr nz, .c6 
c8e8					res 4, c 
c8e8			.c6:		cp 6 
c8e8					jr nz, .c7 
c8e8					res 5, c 
c8e8			.c7:		cp 7 
c8e8					jr nz, .c8 
c8e8					res 6, c 
c8e8			.c8:		cp 8 
c8e8					jr nz, .cset 
c8e8					res 7, c 
c8e8			.cset:		ld a, c 
c8e8					ld (spi_cartdev),a 
c8e8			 
c8e8					if DEBUG_FORTH_WORDS 
c8e8						DMARK "CD2" 
c8e8						CALLMONITOR 
c8e8					endif 
c8e8			 
c8e8					; set default SPI clk pulse time as 10ms for CARTDEV use 
c8e8			 
c8e8					ld a, $0a 
c8e8					ld (spi_clktime), a 
c8e8					NEXTW 
c8e8			endif 
c8e8			 
c8e8			.ENDDEVICE: 
c8e8			; eof 
c8e8			 
# End of file forth_words_device.asm
c8e8			 
c8e8			; var handler 
c8e8			 
c8e8			 
c8e8			.VARS: 
c8e8				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c8e8 77				db WORD_SYS_CORE+99             
c8e9 99 c9			dw .V0            
c8eb 04				db 3 + 1 
c8ec .. 00			db "VAR",0              
c8f0				endm 
# End of macro CWHEAD
c8f0			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c8f0			;| 
c8f0			;| The variable name should consist of a single letter. e.g. "a" 
c8f0			;! If a full string is passed then only the first char is looked at 
c8f0			;| Any other char could exceed bounds checks!  
c8f0			 
c8f0					if DEBUG_FORTH_WORDS_KEY 
c8f0						DMARK "VAR" 
c8f0 f5				push af  
c8f1 3a 05 c9			ld a, (.dmark)  
c8f4 32 b7 ee			ld (debug_mark),a  
c8f7 3a 06 c9			ld a, (.dmark+1)  
c8fa 32 b8 ee			ld (debug_mark+1),a  
c8fd 3a 07 c9			ld a, (.dmark+2)  
c900 32 b9 ee			ld (debug_mark+2),a  
c903 18 03			jr .pastdmark  
c905 ..			.dmark: db "VAR"  
c908 f1			.pastdmark: pop af  
c909			endm  
# End of macro DMARK
c909						CALLMONITOR 
c909 cd a3 94			call break_point_state  
c90c				endm  
# End of macro CALLMONITOR
c90c					endif 
c90c			 
c90c					FORTH_DSP_VALUEHL 
c90c cd 0b 9d			call macro_dsp_valuehl 
c90f				endm 
# End of macro FORTH_DSP_VALUEHL
c90f			 
c90f 7e					ld a, (hl)    ; get first char on of the string 
c910			 
c910			 
c910					if DEBUG_FORTH_WORDS 
c910						DMARK "VR1" 
c910 f5				push af  
c911 3a 25 c9			ld a, (.dmark)  
c914 32 b7 ee			ld (debug_mark),a  
c917 3a 26 c9			ld a, (.dmark+1)  
c91a 32 b8 ee			ld (debug_mark+1),a  
c91d 3a 27 c9			ld a, (.dmark+2)  
c920 32 b9 ee			ld (debug_mark+2),a  
c923 18 03			jr .pastdmark  
c925 ..			.dmark: db "VR1"  
c928 f1			.pastdmark: pop af  
c929			endm  
# End of macro DMARK
c929						CALLMONITOR 
c929 cd a3 94			call break_point_state  
c92c				endm  
# End of macro CALLMONITOR
c92c					endif 
c92c					 
c92c f5					push af	 
c92d					FORTH_DSP_POP 
c92d cd c3 9d			call macro_forth_dsp_pop 
c930				endm 
# End of macro FORTH_DSP_POP
c930 f1					pop af 
c931			 
c931					; convert to upper 
c931			 
c931 cd 0f 90				call to_upper 
c934					if DEBUG_FORTH_WORDS 
c934						DMARK "Vaa" 
c934 f5				push af  
c935 3a 49 c9			ld a, (.dmark)  
c938 32 b7 ee			ld (debug_mark),a  
c93b 3a 4a c9			ld a, (.dmark+1)  
c93e 32 b8 ee			ld (debug_mark+1),a  
c941 3a 4b c9			ld a, (.dmark+2)  
c944 32 b9 ee			ld (debug_mark+2),a  
c947 18 03			jr .pastdmark  
c949 ..			.dmark: db "Vaa"  
c94c f1			.pastdmark: pop af  
c94d			endm  
# End of macro DMARK
c94d						CALLMONITOR 
c94d cd a3 94			call break_point_state  
c950				endm  
# End of macro CALLMONITOR
c950					endif 
c950 06 41				ld b, 'A' 
c952 90					sub b			; set offset 
c953					if DEBUG_FORTH_WORDS 
c953						DMARK "Vbb" 
c953 f5				push af  
c954 3a 68 c9			ld a, (.dmark)  
c957 32 b7 ee			ld (debug_mark),a  
c95a 3a 69 c9			ld a, (.dmark+1)  
c95d 32 b8 ee			ld (debug_mark+1),a  
c960 3a 6a c9			ld a, (.dmark+2)  
c963 32 b9 ee			ld (debug_mark+2),a  
c966 18 03			jr .pastdmark  
c968 ..			.dmark: db "Vbb"  
c96b f1			.pastdmark: pop af  
c96c			endm  
# End of macro DMARK
c96c						CALLMONITOR 
c96c cd a3 94			call break_point_state  
c96f				endm  
# End of macro CALLMONITOR
c96f					endif 
c96f cb 27				sla a  
c971				 
c971					 
c971					if DEBUG_FORTH_WORDS 
c971						DMARK "VR2" 
c971 f5				push af  
c972 3a 86 c9			ld a, (.dmark)  
c975 32 b7 ee			ld (debug_mark),a  
c978 3a 87 c9			ld a, (.dmark+1)  
c97b 32 b8 ee			ld (debug_mark+1),a  
c97e 3a 88 c9			ld a, (.dmark+2)  
c981 32 b9 ee			ld (debug_mark+2),a  
c984 18 03			jr .pastdmark  
c986 ..			.dmark: db "VR2"  
c989 f1			.pastdmark: pop af  
c98a			endm  
# End of macro DMARK
c98a						CALLMONITOR 
c98a cd a3 94			call break_point_state  
c98d				endm  
# End of macro CALLMONITOR
c98d					endif 
c98d			 
c98d 21 84 eb				ld hl, cli_var_array2 
c990 cd a2 8c				call addatohl 
c993 cd 14 9b				call forth_push_numhl 
c996			 
c996			 
c996				       NEXTW 
c996 c3 c1 9e			jp macro_next 
c999				endm 
# End of macro NEXTW
c999			.V0: 
c999				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c999 78				db WORD_SYS_CORE+100             
c99a b1 c9			dw .V0Q            
c99c 04				db 3 + 1 
c99d .. 00			db "V0!",0              
c9a1				endm 
# End of macro CWHEAD
c9a1			;| V0! ( u1 -- )  Store value to v0  | DONE 
c9a1			 
c9a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9a1 cd 0b 9d			call macro_dsp_valuehl 
c9a4				endm 
# End of macro FORTH_DSP_VALUEHL
c9a4			 
c9a4 11 b8 eb				ld de, cli_var_array 
c9a7			 
c9a7 eb					ex de, hl 
c9a8 73					ld (hl), e 
c9a9 23					inc hl 
c9aa 72					ld (hl), d 
c9ab			 
c9ab					; destroy value TOS 
c9ab			 
c9ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9ab cd c3 9d			call macro_forth_dsp_pop 
c9ae				endm 
# End of macro FORTH_DSP_POP
c9ae			 
c9ae				       NEXTW 
c9ae c3 c1 9e			jp macro_next 
c9b1				endm 
# End of macro NEXTW
c9b1			.V0Q: 
c9b1				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c9b1 79				db WORD_SYS_CORE+101             
c9b2 c2 c9			dw .V1S            
c9b4 04				db 3 + 1 
c9b5 .. 00			db "V0@",0              
c9b9				endm 
# End of macro CWHEAD
c9b9			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c9b9 2a b8 eb				ld hl, (cli_var_array) 
c9bc cd 14 9b				call forth_push_numhl 
c9bf			 
c9bf				       NEXTW 
c9bf c3 c1 9e			jp macro_next 
c9c2				endm 
# End of macro NEXTW
c9c2			.V1S: 
c9c2				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c9c2 7a				db WORD_SYS_CORE+102             
c9c3 da c9			dw .V1Q            
c9c5 04				db 3 + 1 
c9c6 .. 00			db "V1!",0              
c9ca				endm 
# End of macro CWHEAD
c9ca			;| V1! ( u1 -- )  Store value to v1 | DONE 
c9ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9ca cd 0b 9d			call macro_dsp_valuehl 
c9cd				endm 
# End of macro FORTH_DSP_VALUEHL
c9cd			 
c9cd 11 ba eb				ld de, cli_var_array+2 
c9d0				 
c9d0 eb					ex de, hl 
c9d1 73					ld (hl), e 
c9d2 23					inc hl 
c9d3 72					ld (hl), d 
c9d4			 
c9d4					; destroy value TOS 
c9d4			 
c9d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9d4 cd c3 9d			call macro_forth_dsp_pop 
c9d7				endm 
# End of macro FORTH_DSP_POP
c9d7				       NEXTW 
c9d7 c3 c1 9e			jp macro_next 
c9da				endm 
# End of macro NEXTW
c9da			.V1Q: 
c9da				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c9da 7b				db WORD_SYS_CORE+103             
c9db eb c9			dw .V2S            
c9dd 04				db 3 + 1 
c9de .. 00			db "V1@",0              
c9e2				endm 
# End of macro CWHEAD
c9e2			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c9e2 2a ba eb				ld hl, (cli_var_array+2) 
c9e5 cd 14 9b				call forth_push_numhl 
c9e8				       NEXTW 
c9e8 c3 c1 9e			jp macro_next 
c9eb				endm 
# End of macro NEXTW
c9eb			.V2S: 
c9eb				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c9eb 7c				db WORD_SYS_CORE+104             
c9ec 03 ca			dw .V2Q            
c9ee 04				db 3 + 1 
c9ef .. 00			db "V2!",0              
c9f3				endm 
# End of macro CWHEAD
c9f3			;| V2! ( u1 -- )  Store value to v2 | DONE 
c9f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9f3 cd 0b 9d			call macro_dsp_valuehl 
c9f6				endm 
# End of macro FORTH_DSP_VALUEHL
c9f6			 
c9f6 11 bc eb				ld de, cli_var_array+4 
c9f9				 
c9f9 eb					ex de, hl 
c9fa 73					ld (hl), e 
c9fb 23					inc hl 
c9fc 72					ld (hl), d 
c9fd			 
c9fd					; destroy value TOS 
c9fd			 
c9fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9fd cd c3 9d			call macro_forth_dsp_pop 
ca00				endm 
# End of macro FORTH_DSP_POP
ca00				       NEXTW 
ca00 c3 c1 9e			jp macro_next 
ca03				endm 
# End of macro NEXTW
ca03			.V2Q: 
ca03				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
ca03 7d				db WORD_SYS_CORE+105             
ca04 14 ca			dw .V3S            
ca06 04				db 3 + 1 
ca07 .. 00			db "V2@",0              
ca0b				endm 
# End of macro CWHEAD
ca0b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
ca0b 2a bc eb				ld hl, (cli_var_array+4) 
ca0e cd 14 9b				call forth_push_numhl 
ca11				       NEXTW 
ca11 c3 c1 9e			jp macro_next 
ca14				endm 
# End of macro NEXTW
ca14			.V3S: 
ca14				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
ca14 7c				db WORD_SYS_CORE+104             
ca15 2c ca			dw .V3Q            
ca17 04				db 3 + 1 
ca18 .. 00			db "V3!",0              
ca1c				endm 
# End of macro CWHEAD
ca1c			;| V3! ( u1 -- )  Store value to v3 | DONE 
ca1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca1c cd 0b 9d			call macro_dsp_valuehl 
ca1f				endm 
# End of macro FORTH_DSP_VALUEHL
ca1f			 
ca1f 11 be eb				ld de, cli_var_array+6 
ca22				 
ca22 eb					ex de, hl 
ca23 73					ld (hl), e 
ca24 23					inc hl 
ca25 72					ld (hl), d 
ca26			 
ca26					; destroy value TOS 
ca26			 
ca26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca26 cd c3 9d			call macro_forth_dsp_pop 
ca29				endm 
# End of macro FORTH_DSP_POP
ca29				       NEXTW 
ca29 c3 c1 9e			jp macro_next 
ca2c				endm 
# End of macro NEXTW
ca2c			.V3Q: 
ca2c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
ca2c 7d				db WORD_SYS_CORE+105             
ca2d 3d ca			dw .END            
ca2f 04				db 3 + 1 
ca30 .. 00			db "V3@",0              
ca34				endm 
# End of macro CWHEAD
ca34			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
ca34 2a be eb				ld hl, (cli_var_array+6) 
ca37 cd 14 9b				call forth_push_numhl 
ca3a				       NEXTW 
ca3a c3 c1 9e			jp macro_next 
ca3d				endm 
# End of macro NEXTW
ca3d			 
ca3d			 
ca3d			 
ca3d			 
ca3d			 
ca3d			; end of dict marker 
ca3d			 
ca3d 00			.END:    db WORD_SYS_END 
ca3e 00 00			dw 0 
ca40 00				db 0 
ca41			 
ca41			; use to jp here for user dict words to save on macro expansion  
ca41			 
ca41			user_dict_next: 
ca41				NEXTW 
ca41 c3 c1 9e			jp macro_next 
ca44				endm 
# End of macro NEXTW
ca44			 
ca44			 
ca44			user_exec: 
ca44				;    ld hl, <word code> 
ca44				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
ca44				;    call forthexec 
ca44				;    jp user_dict_next   (NEXT) 
ca44			        ;    <word code bytes> 
ca44 eb				ex de, hl 
ca45 2a 52 e7			ld hl,(os_tok_ptr) 
ca48				 
ca48				FORTH_RSP_NEXT 
ca48 cd bb 9a			call macro_forth_rsp_next 
ca4b				endm 
# End of macro FORTH_RSP_NEXT
ca4b			 
ca4b			if DEBUG_FORTH_UWORD 
ca4b						DMARK "UEX" 
ca4b f5				push af  
ca4c 3a 60 ca			ld a, (.dmark)  
ca4f 32 b7 ee			ld (debug_mark),a  
ca52 3a 61 ca			ld a, (.dmark+1)  
ca55 32 b8 ee			ld (debug_mark+1),a  
ca58 3a 62 ca			ld a, (.dmark+2)  
ca5b 32 b9 ee			ld (debug_mark+2),a  
ca5e 18 03			jr .pastdmark  
ca60 ..			.dmark: db "UEX"  
ca63 f1			.pastdmark: pop af  
ca64			endm  
# End of macro DMARK
ca64				CALLMONITOR 
ca64 cd a3 94			call break_point_state  
ca67				endm  
# End of macro CALLMONITOR
ca67			endif 
ca67			 
ca67			 
ca67			 
ca67 eb				ex de, hl 
ca68 22 52 e7			ld (os_tok_ptr), hl 
ca6b				 
ca6b				; Don't use next - Skips the first word in uword. 
ca6b			 
ca6b c3 52 9f			jp exec1 
ca6e			;	NEXT 
ca6e			 
ca6e			 
ca6e			; eof 
# End of file forth_wordsv4.asm
ca6e			endif 
ca6e			;;;;;;;;;;;;;; Debug code 
ca6e			 
ca6e			 
ca6e			;if DEBUG_FORTH_PARSE 
ca6e .. 00		.nowordfound: db "No match",0 
ca77 .. 00		.compword:	db "Comparing word ",0 
ca87 .. 00		.nextwordat:	db "Next word at",0 
ca94 .. 00		.charmatch:	db "Char match",0 
ca9f			;endif 
ca9f			if DEBUG_FORTH_JP 
ca9f			.foundword:	db "Word match. Exec..",0 
ca9f			endif 
ca9f			;if DEBUG_FORTH_PUSH 
ca9f .. 00		.enddict:	db "Dict end. Push.",0 
caaf .. 00		.push_str:	db "Pushing string",0 
cabe .. 00		.push_num:	db "Pushing number",0 
cacd .. 00		.data_sp:	db "SP:",0 
cad1 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cae3 .. 00		.wordinde:	db "Word in DE (3/0):",0 
caf5 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cb07			;endif 
cb07			;if DEBUG_FORTH_MALLOC 
cb07 .. 00		.push_malloc:	db "Malloc address",0 
cb16			;endif 
cb16			 
cb16			 
cb16			 
cb16			; display malloc address and current data stack pointer  
cb16			 
cb16			malloc_error: 
cb16 d5				push de 
cb17 f5				push af 
cb18 e5				push hl 
cb19 cd 75 8a			call clear_display 
cb1c 11 3e cb			ld de, .mallocerr 
cb1f 3e 00			ld a,0 
cb21			;	ld de,os_word_scratch 
cb21 cd 88 8a			call str_at_display 
cb24 3e 11			ld a, display_row_1+17 
cb26 11 b7 ee			ld de, debug_mark 
cb29 cd 88 8a			call str_at_display 
cb2c cd 98 8a			call update_display 
cb2f				;call break_point_state 
cb2f cd be e1			call cin_wait 
cb32			 
cb32 3e 20			ld a, ' ' 
cb34 32 42 e4			ld (os_view_disable), a 
cb37 e1				pop hl 
cb38 f1				pop af 
cb39 d1				pop de	 
cb3a				CALLMONITOR 
cb3a cd a3 94			call break_point_state  
cb3d				endm  
# End of macro CALLMONITOR
cb3d c9				ret 
cb3e			 
cb3e .. 00		.mallocerr: 	db "Malloc Error",0 
cb4b			;if DEBUG_FORTH_PUSH 
cb4b			display_data_sp: 
cb4b f5				push af 
cb4c			 
cb4c				; see if disabled 
cb4c			 
cb4c 3a 42 e4			ld a, (os_view_disable) 
cb4f fe 2a			cp '*' 
cb51 28 67			jr z, .skipdsp 
cb53			 
cb53 e5				push hl 
cb54 e5				push hl 
cb55 e5			push hl 
cb56 cd 75 8a			call clear_display 
cb59 e1			pop hl 
cb5a 7c				ld a,h 
cb5b 21 56 e7			ld hl, os_word_scratch 
cb5e cd a3 8f			call hexout 
cb61 e1				pop hl 
cb62 7d				ld a,l 
cb63 21 58 e7			ld hl, os_word_scratch+2 
cb66 cd a3 8f			call hexout 
cb69 21 5a e7			ld hl, os_word_scratch+4 
cb6c 3e 00			ld a,0 
cb6e 77				ld (hl),a 
cb6f 11 56 e7			ld de,os_word_scratch 
cb72 3e 14				ld a, display_row_2 
cb74 cd 88 8a				call str_at_display 
cb77 11 d1 ca			ld de, .wordinhl 
cb7a 3e 00			ld a, display_row_1 
cb7c			 
cb7c cd 88 8a				call str_at_display 
cb7f 11 b7 ee			ld de, debug_mark 
cb82 3e 11			ld a, display_row_1+17 
cb84			 
cb84 cd 88 8a				call str_at_display 
cb87			 
cb87				; display current data stack pointer 
cb87 11 cd ca			ld de,.data_sp 
cb8a 3e 1c				ld a, display_row_2 + 8 
cb8c cd 88 8a				call str_at_display 
cb8f			 
cb8f 2a 7e eb			ld hl,(cli_data_sp) 
cb92 e5				push hl 
cb93 7c				ld a,h 
cb94 21 56 e7			ld hl, os_word_scratch 
cb97 cd a3 8f			call hexout 
cb9a e1				pop hl 
cb9b 7d				ld a,l 
cb9c 21 58 e7			ld hl, os_word_scratch+2 
cb9f cd a3 8f			call hexout 
cba2 21 5a e7			ld hl, os_word_scratch+4 
cba5 3e 00			ld a,0 
cba7 77				ld (hl),a 
cba8 11 56 e7			ld de,os_word_scratch 
cbab 3e 1f				ld a, display_row_2 + 11 
cbad cd 88 8a				call str_at_display 
cbb0			 
cbb0			 
cbb0 cd 98 8a			call update_display 
cbb3 cd f2 89			call delay1s 
cbb6 cd f2 89			call delay1s 
cbb9 e1				pop hl 
cbba			.skipdsp: 
cbba f1				pop af 
cbbb c9				ret 
cbbc			 
cbbc			display_data_malloc: 
cbbc			 
cbbc f5				push af 
cbbd e5				push hl 
cbbe e5				push hl 
cbbf e5			push hl 
cbc0 cd 75 8a			call clear_display 
cbc3 e1			pop hl 
cbc4 7c				ld a,h 
cbc5 21 56 e7			ld hl, os_word_scratch 
cbc8 cd a3 8f			call hexout 
cbcb e1				pop hl 
cbcc 7d				ld a,l 
cbcd 21 58 e7			ld hl, os_word_scratch+2 
cbd0 cd a3 8f			call hexout 
cbd3 21 5a e7			ld hl, os_word_scratch+4 
cbd6 3e 00			ld a,0 
cbd8 77				ld (hl),a 
cbd9 11 56 e7			ld de,os_word_scratch 
cbdc 3e 14				ld a, display_row_2 
cbde cd 88 8a				call str_at_display 
cbe1 11 07 cb			ld de, .push_malloc 
cbe4 3e 00			ld a, display_row_1 
cbe6			 
cbe6 cd 88 8a				call str_at_display 
cbe9			 
cbe9				; display current data stack pointer 
cbe9 11 cd ca			ld de,.data_sp 
cbec 3e 1c				ld a, display_row_2 + 8 
cbee cd 88 8a				call str_at_display 
cbf1			 
cbf1 2a 7e eb			ld hl,(cli_data_sp) 
cbf4 e5				push hl 
cbf5 7c				ld a,h 
cbf6 21 56 e7			ld hl, os_word_scratch 
cbf9 cd a3 8f			call hexout 
cbfc e1				pop hl 
cbfd 7d				ld a,l 
cbfe 21 58 e7			ld hl, os_word_scratch+2 
cc01 cd a3 8f			call hexout 
cc04 21 5a e7			ld hl, os_word_scratch+4 
cc07 3e 00			ld a,0 
cc09 77				ld (hl),a 
cc0a 11 56 e7			ld de,os_word_scratch 
cc0d 3e 1f				ld a, display_row_2 + 11 
cc0f cd 88 8a				call str_at_display 
cc12			 
cc12 cd 98 8a			call update_display 
cc15 cd f2 89			call delay1s 
cc18 cd f2 89			call delay1s 
cc1b e1				pop hl 
cc1c f1				pop af 
cc1d c9				ret 
cc1e			;endif 
cc1e			 
cc1e			include "forth_autostart.asm" 
cc1e			; list of commands to perform at system start up 
cc1e			 
cc1e			startcmds: 
cc1e			;	dw test11 
cc1e			;	dw test12 
cc1e			;	dw test13 
cc1e			;	dw test14 
cc1e			;	dw test15 
cc1e			;	dw test16 
cc1e			;	dw test17 
cc1e			;	dw ifthtest1 
cc1e			;	dw ifthtest2 
cc1e			;	dw ifthtest3 
cc1e			;	dw mmtest1 
cc1e			;	dw mmtest2 
cc1e			;	dw mmtest3 
cc1e			;	dw mmtest4 
cc1e			;	dw mmtest5 
cc1e			;	dw mmtest6 
cc1e			;	dw iftest1 
cc1e			;	dw iftest2 
cc1e			;	dw iftest3 
cc1e			;	dw looptest1 
cc1e			;	dw looptest2 
cc1e			;	dw test1 
cc1e			;	dw test2 
cc1e			;	dw test3 
cc1e			;	dw test4 
cc1e			;	dw game2r 
cc1e			;	dw game2b1 
cc1e			;	dw game2b2 
cc1e			 
cc1e				; start up words that are actually useful 
cc1e			 
cc1e 92 cc		    dw spi1 
cc20 ed cc		    dw spi2 
cc22 7b cd		    dw spi3 
cc24 23 cd		    dw spi4 
cc26 4e cd		    dw spi5 
cc28 e1 cd		    dw spi6 
cc2a 36 ce		    dw spi7 
cc2c			 
cc2c 8e ce		    dw spi8 
cc2e ad ce		    dw spi9 
cc30 05 cf		    dw spi10 
cc32			 
cc32 78 cf			dw longread 
cc34 bf cf			dw clrstack 
cc36 f2 cf			dw type 
cc38 e2 d1			dw stest 
cc3a 16 d0			dw strncpy 
cc3c 78 d1			dw list 
cc3e 77 d0			dw start1 
cc40 89 d0			dw start2 
cc42			;	dw start3 
cc42 9c d0			dw start3b 
cc44 18 d1			dw start3c 
cc46			 
cc46				; (unit) testing words 
cc46			 
cc46 59 d2			dw mtesta 
cc48 0e d3			dw mtestb 
cc4a b1 d3			dw mtestc 
cc4c 66 d4			dw mtestd 
cc4e 0a d5			dw mteste 
cc50			 
cc50				; demo/game words 
cc50			 
cc50 16 dc		        dw game3w 
cc52 44 dc		        dw game3p 
cc54 62 dc		        dw game3sc 
cc56 93 dc		        dw game3vsi 
cc58 bf dc		        dw game3vs 
cc5a				 
cc5a 09 da			dw game2b 
cc5c 77 da			dw game2bf 
cc5e c1 da			dw game2mba 
cc60 57 db			dw game2mbas 
cc62 99 db			dw game2mb 
cc64			 
cc64 ca d6			dw game1 
cc66 db d6			dw game1a 
cc68 3d d7			dw game1b 
cc6a 72 d7			dw game1c 
cc6c a8 d7			dw game1d 
cc6e d9 d7			dw game1s 
cc70 ed d7			dw game1t 
cc72 02 d8			dw game1f 
cc74 36 d8			dw game1z 
cc76 7a d8			dw game1zz 
cc78			 
cc78 c0 d5			dw test5 
cc7a f8 d5			dw test6 
cc7c 30 d6			dw test7 
cc7e 44 d6			dw test8 
cc80 70 d6			dw test9 
cc82 86 d6			dw test10 
cc84				 
cc84 51 d9		        dw ssv5 
cc86 35 d9		        dw ssv4 
cc88 19 d9		        dw ssv3 
cc8a e3 d8		        dw ssv2 
cc8c 6a d9		        dw ssv1 
cc8e b2 d9		        dw ssv1cpm 
cc90			;	dw keyup 
cc90			;	dw keydown 
cc90			;	dw keyleft 
cc90			;	dw keyright 
cc90			;	dw 	keyf1 
cc90			;	dw keyf2 
cc90			;	dw keyf3 
cc90			;	dw keyf4 
cc90			;	dw keyf5 
cc90			;	dw keyf6 
cc90			;	dw keyf7 
cc90			;	dw keyf8 
cc90			;	dw keyf9 
cc90			;	dw keyf10 
cc90			;	dw keyf11 
cc90			;	dw keyf12 
cc90			;	dw keytab 
cc90			;	dw keycr 
cc90			;	dw keyhome 
cc90			;	dw keyend 
cc90			;	dw keybs 
cc90 00 00			db 0, 0	 
cc92			 
cc92			; SPI Net support words 
cc92			 
cc92			; v0! = node to send to 
cc92			; ( str count - ) 
cc92 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cced			 
cced			; spiputchr ( char node - ) 
cced .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
cd23			 
cd23			; spigetchr ( - n ) 
cd23 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
cd4e			 
cd4e			; getnode ( - n ) 
cd4e .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cd7b			 
cd7b			; ( str node - )  
cd7b .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cde1			; store string ( str i - ) 
cde1			 
cde1			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cde1 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
ce36			 
ce36			; get string ( addr i -  )    TO FIX 
ce36			 
ce36 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
ce8e			 
ce8e			 
ce8e			; NETCHAT (TODO) 
ce8e			; Program to allow two nodes to chat with eachother 
ce8e			; 
ce8e			; v0 - target node 
ce8e			;  
ce8e			; accept input at 0,0 
ce8e			; if input is string send spitype to target node 
ce8e			; starting at row 2,0 , while spigetchr is not zero ->  
ce8e			; 
ce8e			; 
ce8e			; TODO add paging of get request 
ce8e			 
ce8e			; ( node - ) 
ce8e .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
cead .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
cf05 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
cf78			 
cf78			 
cf78			; Long read of currently open file 
cf78 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
cfbf			 
cfbf			; clear stack  
cfbf			 
cfbf .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
cff2			 
cff2			; type ( addr count - ) 
cff2 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
d016			 
d016			; some direct memory words 
d016			; strncpy ( len t f -- t ) 
d016			 
d016 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d077			 
d077 .. 00		start1:     	db ": bpon $0000 bp ;",0 
d089 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
d09c .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d118 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d178			 
d178			 
d178			; a handy word to list items on the stack 
d178			 
d178 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d1e2			 
d1e2			 
d1e2			; test stack  
d1e2			; rnd8 stest 
d1e2			 
d1e2 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d259			 
d259			; random malloc and free cycles 
d259			 
d259 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d30e			 
d30e			; fixed malloc and free cycles 
d30e			 
d30e .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d3b1			 
d3b1			; fixed double string push and drop cycle  
d3b1			 
d3b1 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d466			 
d466			; consistent fixed string push and drop cycle  
d466			 
d466 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d50a			 
d50a .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d5c0			 
d5c0			;test1:		db ": aa 1 2 3 ;", 0 
d5c0			;test2:     	db "111 aa 888 999",0 
d5c0			;test3:     	db ": bb 77 ;",0 
d5c0			;test4:     	db "$02 $01 do i . loop bb",0 
d5c0			 
d5c0 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d5f8 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d630 .. 00		test7:     	db ": box hline vline ;",0 
d644 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d670 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d686 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d6ab .. 00		test11:     	db "hello create .",0 
d6ba .. 00		test12:     	db "hello2 create .",0 
d6ca			 
d6ca			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d6ca			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d6ca			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d6ca			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d6ca			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d6ca			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d6ca			 
d6ca			;iftest1:     	db "$0001 IF cls .",0 
d6ca			;iftest2:     	db "$0000 IF cls .",0 
d6ca			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d6ca			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d6ca			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d6ca			 
d6ca			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d6ca			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d6ca			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d6ca			 
d6ca			 
d6ca			 
d6ca			; a small guess the number game 
d6ca			 
d6ca .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d6db .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d73d			 
d73d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d772 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d7a8 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d7d9 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d7ed .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d802 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d836 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d87a			 
d87a			; Using 'ga' save a high score across multiple runs using external storage 
d87a			 
d87a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d8e3			 
d8e3			 
d8e3			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d8e3			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d8e3			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d8e3			 
d8e3			; simple screen saver to test code memory reuse to destruction 
d8e3			 
d8e3 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d919 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d935 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d951 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d96a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d9b2 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
da09			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
da09			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
da09			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
da09			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
da09			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
da09			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
da09			 
da09			 
da09			 
da09			; minesweeper/battleship finding game 
da09			; draws a game board of random ship/mine positions 
da09			; user enters coords to see if it hits on 
da09			; game ends when all are hit 
da09			; when hit or miss says how many may be in the area 
da09			 
da09			; setup the game board and then hide it 
da09 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
da77 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dac1			; prompt for where to target 
dac1 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
db57 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
db7c			; TODO see if the entered coords hits or misses pushes char hit of miss 
db7c .. 00		game2mbht:      db ": mbckht nop ;",0 
db8b .. 00		game2mbms:      db ": mbcms nop ;",0 
db99			; TODO how many might be near by 
db99 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
dc16			 
dc16			; Game 3 
dc16			 
dc16			; Vert scroller ski game - avoid the trees! 
dc16			 
dc16			; v0 score (ie turns) 
dc16			; v1 player pos 
dc16			; v2 left wall 
dc16			; v3 right wall 
dc16			 
dc16			; Draw side walls randomly 
dc16			 
dc16 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
dc44			 
dc44			; Draw player 
dc44 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
dc62			 
dc62			; TODO Get Key 
dc62			 
dc62			; TODO Move left right 
dc62			 
dc62			; scroll and move walls a bit 
dc62			 
dc62 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
dc93			 
dc93			; main game loop 
dc93			 
dc93 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
dcbf .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
dcfe			 
dcfe			; key board defs 
dcfe			 
dcfe .. 00		keyup:       db ": keyup $05 ;",0 
dd0c .. 00		keydown:       db ": keydown $0a ;",0 
dd1c .. 00		keyleft:       db ": keyleft $0b ;",0 
dd2c .. 00		keyright:       db ": keyright $0c ;",0 
dd3d .. 00		keyf1:       db ": keyf1 $10 ;",0 
dd4b .. 00		keyf2:       db ": keyf2 $11 ;",0 
dd59 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dd67 .. 00		keyf4:       db ": keyf4 $13 ;",0 
dd75 .. 00		keyf5:       db ": keyf5 $14 ;",0 
dd83 .. 00		keyf6:       db ": keyf6 $15 ;",0 
dd91 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dd9f .. 00		keyf8:       db ": keyf8 $17 ;",0 
ddad .. 00		keyf9:       db ": keyf9 $18 ;",0 
ddbb .. 00		keyf10:       db ": keyf10 $19 ;",0 
ddca .. 00		keyf11:       db ": keyf11 $1a ;",0 
ddd9 .. 00		keyf12:       db ": keyf12 $1b ;",0 
dde8			 
dde8 .. 00		keytab:       db ": keytab $09 ;",0 
ddf7 .. 00		keycr:       db ": keycr $0d ;",0 
de05 .. 00		keyhome:       db ": keyhome $0e ;",0 
de15 .. 00		keyend:       db ": keyend $0f ;",0 
de24 .. 00		keybs:       db ": keybs $08 ;",0 
de32			 
de32			   
de32			 
de32			 
de32			 
de32			; eof 
# End of file forth_autostart.asm
de32			 
de32 .. 00		sprompt1: db "Startup load...",0 
de42 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
de58			 
de58			 
de58			 
de58			 
de58			forth_startup: 
de58 21 1e cc			ld hl, startcmds 
de5b 3e 00			ld a, 0 
de5d 32 77 e8			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
de60			 
de60 e5			.start1:	push hl 
de61 cd 75 8a			call clear_display 
de64 11 32 de			ld de, sprompt1 
de67 3e 00		        ld a, display_row_1 
de69 cd 88 8a			call str_at_display 
de6c 11 42 de			ld de, sprompt2 
de6f 3e 14		        ld a, display_row_2 
de71 cd 88 8a			call str_at_display 
de74 e1				pop hl 
de75 e5				push hl 
de76 5e				ld e,(hl) 
de77 23				inc hl 
de78 56				ld d,(hl) 
de79 3e 28		        ld a, display_row_3 
de7b cd 88 8a			call str_at_display 
de7e cd 98 8a			call update_display 
de81			 
de81			 
de81 3a 77 e8			ld a, (os_last_cmd) 
de84 fe 00			cp 0 
de86 28 05			jr z, .startprompt 
de88 cd e6 89			call delay250ms 
de8b 18 24			jr .startdo 
de8d				 
de8d				 
de8d			 
de8d			.startprompt: 
de8d			 
de8d 3e 4f			ld a,display_row_4 + display_cols - 1 
de8f 11 8a 9a		        ld de, endprg 
de92 cd 88 8a			call str_at_display 
de95 cd 98 8a			call update_display 
de98 cd f2 89			call delay1s 
de9b cd be e1			call cin_wait 
de9e						 
de9e fe 2a			cp '*' 
dea0 28 5e			jr z, .startupend1 
dea2 fe 23			cp '#' 
dea4 20 07			jr nz, .startno 
dea6 3e 01			ld a, 1 
dea8 32 77 e8			ld (os_last_cmd),a 
deab 18 04			jr .startdo 
dead fe 31		.startno:	cp '1' 
deaf 28 3a			jr z,.startnxt  
deb1			 
deb1				; exec startup line 
deb1			.startdo:	 
deb1 e1				pop hl 
deb2 e5				push hl 
deb3				 
deb3 5e				ld e,(hl) 
deb4 23				inc hl 
deb5 56				ld d,(hl) 
deb6 eb				ex de,hl 
deb7			 
deb7 e5				push hl 
deb8			 
deb8 3e 00			ld a, 0 
deba				;ld a, FORTH_END_BUFFER 
deba cd 0b 91			call strlent 
debd 23				inc hl   ; include zero term to copy 
debe 06 00			ld b,0 
dec0 4d				ld c,l 
dec1 e1				pop hl 
dec2 11 51 e4			ld de, scratch 
dec5 ed b0			ldir 
dec7			 
dec7			 
dec7 21 51 e4			ld hl, scratch 
deca cd 0f 9f			call forthparse 
decd cd 4f 9f			call forthexec 
ded0 cd 61 9e			call forthexec_cleanup 
ded3			 
ded3 3e 3c			ld a, display_row_4 
ded5 11 2e 98			ld de, endprog 
ded8			 
ded8 cd 98 8a			call update_display		 
dedb			 
dedb 3a 77 e8			ld a, (os_last_cmd) 
dede fe 00			cp 0 
dee0 20 09			jr nz, .startnxt 
dee2 cd 8c 9a			call next_page_prompt 
dee5 cd 75 8a		        call clear_display 
dee8 cd 98 8a			call update_display		 
deeb			 
deeb				; move onto next startup line? 
deeb			.startnxt: 
deeb			 
deeb cd e6 89			call delay250ms 
deee e1				pop hl 
deef			 
deef 23				inc hl 
def0 23				inc hl 
def1			 
def1 e5				push hl 
def2 5e				ld e, (hl) 
def3 23				inc hl 
def4 56				ld d, (hl) 
def5 e1				pop hl 
def6				; TODO replace 0 test 
def6			 
def6 eb				ex de, hl 
def7 cd cb 8c			call ishlzero 
defa			;	ld a,e 
defa			;	add d 
defa			;	cp 0    ; any left to do? 
defa eb				ex de, hl 
defb c2 60 de			jp nz, .start1 
defe 18 01			jr .startupend 
df00			 
df00 e1			.startupend1: pop hl 
df01			.startupend: 
df01			 
df01 cd 75 8a			call clear_display 
df04 cd 98 8a			call update_display 
df07 c9				ret 
df08			 
df08			 
df08			; stack over and underflow checks 
df08			 
df08			; init the words to detect the under/overflow 
df08			 
df08			chk_stk_init: 
df08				; a vague random number to check so we dont get any "lucky" hits 
df08 3e 2d			ld a, 45 
df0a 6f				ld l, a 
df0b 00				nop 
df0c 3e 17			ld a, 23 
df0e 67				ld h, a 
df0f			 
df0f 22 38 e4			ld (chk_word), hl     ; the word we need to check against 
df12			 
df12			;	ld (chk_stund), hl	; stack points.... 
df12 22 00 ef			ld (chk_stovr), hl 
df15 22 7c eb			ld (chk_ret_und), hl 
df18 22 3a eb			ld (chk_ret_ovr), hl 
df1b 22 b8 ea			ld (chk_loop_ovr), hl 
df1e 22 b6 e9			ld (chk_data_ovr), hl 
df21 c9				ret 
df22				 
df22			check_stacks: 
df22				; check all stack words 
df22			 
df22 e5				push hl 
df23 d5				push de 
df24			 
df24			;	ld de,(chk_word) 
df24			;	ld hl, (chk_stund)	; stack points.... 
df24			;	if DEBUG_STK_FAULT 
df24			;		DMARK "FAa" 
df24			;		CALLMONITOR 
df24			;	endif 
df24			;	call cmp16 
df24			;	jp z, .chk_faulta 
df24			; 
df24			;	ld de, sfaultsu 
df24			;	jp .chk_fault 
df24			 
df24 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
df27 ed 5b 38 e4		ld de,(chk_word) 
df2b				if DEBUG_STK_FAULT 
df2b					DMARK "FAb" 
df2b					CALLMONITOR 
df2b				endif 
df2b cd c0 8c			call cmp16 
df2e 28 06			jr z, .chk_fault1 
df30 11 d1 df			ld de, sfaultso 
df33 c3 85 df			jp .chk_fault 
df36			.chk_fault1:  
df36 2a 7c eb			ld hl, (chk_ret_und) 
df39 ed 5b 38 e4		ld de,(chk_word) 
df3d				if DEBUG_STK_FAULT 
df3d					DMARK "FAU" 
df3d					CALLMONITOR 
df3d				endif 
df3d cd c0 8c			call cmp16 
df40 ca 49 df			jp z, .chk_fault2 
df43 11 e1 df			ld de, sfaultru 
df46 c3 85 df			jp .chk_fault 
df49			.chk_fault2:  
df49 2a 3a eb			ld hl, (chk_ret_ovr) 
df4c ed 5b 38 e4		ld de,(chk_word) 
df50				if DEBUG_STK_FAULT 
df50					DMARK "FA1" 
df50					CALLMONITOR 
df50				endif 
df50 cd c0 8c			call cmp16 
df53 ca 5c df			jp z, .chk_fault3 
df56 11 ef df			ld de, sfaultro 
df59 c3 85 df			jp .chk_fault 
df5c			.chk_fault3:  
df5c 2a b8 ea			ld hl, (chk_loop_ovr) 
df5f ed 5b 38 e4		ld de,(chk_word) 
df63				if DEBUG_STK_FAULT 
df63					DMARK "FA2" 
df63					CALLMONITOR 
df63				endif 
df63 cd c0 8c			call cmp16 
df66 ca 6f df			jp z, .chk_fault4 
df69 11 09 e0			ld de, sfaultlo 
df6c c3 85 df			jp .chk_fault 
df6f			.chk_fault4:  
df6f 2a b6 e9			ld hl, (chk_data_ovr) 
df72 ed 5b 38 e4		ld de,(chk_word) 
df76				if DEBUG_STK_FAULT 
df76					DMARK "FA3" 
df76					CALLMONITOR 
df76				endif 
df76 cd c0 8c			call cmp16 
df79 ca 82 df			jp z, .chk_fault5 
df7c 11 23 e0			ld de, sfaultdo 
df7f c3 85 df			jp .chk_fault 
df82			 
df82			 
df82			.chk_fault5:  
df82 d1				pop de 
df83 e1				pop hl 
df84			 
df84 c9				ret 
df85			 
df85 cd 75 8a		.chk_fault: 	call clear_display 
df88 3e 14				ld a, display_row_2 
df8a cd 88 8a				call str_at_display 
df8d 11 b3 df				   ld de, .stackfault 
df90 3e 00				ld a, display_row_1 
df92 cd 88 8a				call str_at_display 
df95 11 b7 ee				    ld de, debug_mark 
df98 3e 11				ld a, display_row_1+17 
df9a cd 88 8a				call str_at_display 
df9d cd 98 8a				call update_display 
dfa0			 
dfa0				; prompt before entering montior for investigating issue 
dfa0			 
dfa0 3e 3c			ld a, display_row_4 
dfa2 11 2e 98			ld de, endprog 
dfa5			 
dfa5 cd 98 8a			call update_display		 
dfa8			 
dfa8 cd 8c 9a			call next_page_prompt 
dfab			 
dfab d1				pop de 
dfac e1				pop hl 
dfad cd 82 98				call monitor 
dfb0 c3 7c 97				jp warmstart 
dfb3					;jp 0 
dfb3					;halt 
dfb3			 
dfb3			 
dfb3			 
dfb3 .. 00		.stackfault: 	db "Stack fault:",0 
dfc0			 
dfc0 .. 00		sfaultsu: 	db	"Stack under flow",0 
dfd1 .. 00		sfaultso: 	db	"Stack over flow",0 
dfe1 .. 00		sfaultru:	db "RTS underflow",0 
dfef .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e009 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e023 .. 00		sfaultdo:	db "DTS overflow", 0 
e030			 
e030			 
e030			fault_dsp_under: 
e030 11 42 e0			ld de, .dsp_under 
e033 c3 f2 e0			jp .show_fault 
e036			 
e036			fault_rsp_under: 
e036 11 50 e0			ld de, .rsp_under 
e039 c3 f2 e0			jp .show_fault 
e03c			fault_loop_under: 
e03c 11 5e e0			ld de, .loop_under 
e03f c3 f2 e0			jp .show_fault 
e042			 
e042 .. 00		.dsp_under: db "DSP Underflow",0 
e050 .. 00		.rsp_under: db "RSP Underflow",0 
e05e .. 00		.loop_under: db "LOOP Underflow",0 
e06d			 
e06d			 
e06d d5			type_faultn: 	push de 
e06e e5					push hl 
e06f cd 75 8a				call clear_display 
e072 11 99 e0				   ld de, .typefaultn 
e075 3e 00				ld a, display_row_1 
e077 cd 88 8a				call str_at_display 
e07a 11 b7 ee				    ld de, debug_mark 
e07d 3e 11				ld a, display_row_1+17 
e07f cd 88 8a				call str_at_display 
e082 cd 98 8a				call update_display 
e085			 
e085				; prompt before entering montior for investigating issue 
e085			 
e085 3e 3c			ld a, display_row_4 
e087 11 2e 98			ld de, endprog 
e08a			 
e08a cd 98 8a			call update_display		 
e08d			 
e08d cd 8c 9a			call next_page_prompt 
e090			 
e090 e5					push hl 
e091 d5					push de 
e092 cd 82 98				call monitor 
e095 c3 7c 97				jp warmstart 
e098 76					halt 
e099			 
e099			 
e099 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e0b0			 
e0b0 d5			type_faults: 	push de 
e0b1 e5					push hl 
e0b2 cd 75 8a				call clear_display 
e0b5 11 db e0				   ld de, .typefaults 
e0b8 3e 00				ld a, display_row_1 
e0ba cd 88 8a				call str_at_display 
e0bd 11 b7 ee				    ld de, debug_mark 
e0c0 3e 11				ld a, display_row_1+17 
e0c2 cd 88 8a				call str_at_display 
e0c5 cd 98 8a				call update_display 
e0c8			 
e0c8				; prompt before entering montior for investigating issue 
e0c8			 
e0c8 3e 3c			ld a, display_row_4 
e0ca 11 2e 98			ld de, endprog 
e0cd			 
e0cd cd 98 8a			call update_display		 
e0d0			 
e0d0 cd 8c 9a			call next_page_prompt 
e0d3			 
e0d3 e1					pop hl 
e0d4 d1					pop de 
e0d5 cd 82 98				call monitor 
e0d8 c3 7c 97				jp warmstart 
e0db			 
e0db			 
e0db .. 00		.typefaults: db "STR Type Expected TOS!",0 
e0f2			 
e0f2			.show_fault: 	 
e0f2 d5					push de 
e0f3 cd 75 8a				call clear_display 
e0f6 d1					pop de 
e0f7 3e 00				ld a, display_row_1 
e0f9 cd 88 8a				call str_at_display 
e0fc 11 b7 ee				    ld de, debug_mark 
e0ff 3e 11				ld a, display_row_1+17 
e101 cd 88 8a				call str_at_display 
e104 cd 98 8a				call update_display 
e107			 
e107				; prompt before entering montior for investigating issue 
e107			 
e107 3e 3c			ld a, display_row_4 
e109 11 2e 98			ld de, endprog 
e10c			 
e10c cd 98 8a			call update_display		 
e10f			 
e10f cd 8c 9a			call next_page_prompt 
e112			 
e112 e1					pop hl 
e113 d1					pop de 
e114 cd 82 98				call monitor 
e117			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e117			; TODO Make optional fault restart to cli or warm boot? 
e117					;jp warmstart 
e117 c3 d4 97				jp cli 
e11a 76					halt 
e11b			 
e11b			; handle the auto run of code from files in storage 
e11b			 
e11b			 
e11b			if STORAGE_SE 
e11b			 
e11b			sprompt3: db "Loading from start-up file?:",0 
e11b			sprompt4: db "(Y=Any key/N=No)",0 
e11b			 
e11b			 
e11b			forth_autoload: 
e11b			 
e11b				; load block 0 of store 1 
e11b				 
e11b				ld a, $fe      ; bit 0 clear 
e11b				ld (spi_device), a 
e11b			 
e11b				call storage_get_block_0 
e11b			 
e11b				ld a, (store_page+STORE_0_AUTOFILE) 
e11b			 
e11b				cp 0 
e11b				ret z     ; auto start not enabled 
e11b			 
e11b				call clear_display 
e11b			 
e11b				; set bank 
e11b			 
e11b					ld a, (store_page+STORE_0_BANKRUN) 
e11b					ld (spi_device), a 
e11b			 
e11b				; get file id to load from and get the file name to display 
e11b			 
e11b					ld a, (store_page+STORE_0_FILERUN) 
e11b			 
e11b					ld l, 0 
e11b					ld h, a 
e11b					ld de, store_page 
e11b			 
e11b					if DEBUG_FORTH_WORDS 
e11b						DMARK "ASp" 
e11b						CALLMONITOR 
e11b					endif 
e11b					call storage_read 
e11b			 
e11b					if DEBUG_FORTH_WORDS 
e11b						DMARK "ASr" 
e11b						CALLMONITOR 
e11b					endif 
e11b			 
e11b					call ishlzero 
e11b					ret z             ; file not found 
e11b			 
e11b					ld a, display_row_2 + 10 
e11b					ld de, store_page+3 
e11b					call str_at_display 
e11b				 
e11b			; 
e11b			 
e11b				ld a, display_row_1+5 
e11b				ld de, sprompt3 
e11b				call str_at_display 
e11b				ld a, display_row_3+15 
e11b				ld de, sprompt4 
e11b				call str_at_display 
e11b			 
e11b				call update_display 
e11b			 
e11b				call cin_wait 
e11b				cp 'n' 
e11b				ret z 
e11b				cp 'N' 
e11b				ret z 
e11b			 
e11b				call delay1s 
e11b			 
e11b				ld a, (store_page+2) 
e11b				ld (store_openmaxext), a    ; save count of ext 
e11b				ld a, 1  
e11b				ld (store_openext), a    ; save count of ext 
e11b			 
e11b			.autof:  
e11b				ld l , a 
e11b				 
e11b				ld a, (store_page) 
e11b				ld h, a	 
e11b				ld de, store_page 
e11b					if DEBUG_FORTH_WORDS 
e11b						DMARK "ASl" 
e11b						CALLMONITOR 
e11b					endif 
e11b					call storage_read 
e11b				call ishlzero 
e11b				ret z 
e11b			;	jr z, .autoend 
e11b			 
e11b					if DEBUG_FORTH_WORDS 
e11b						DMARK "ASc" 
e11b						CALLMONITOR 
e11b					endif 
e11b				ld de, store_page+2 
e11b				ld a, display_row_4 
e11b				call str_at_display 
e11b			 
e11b				call update_display 
e11b				call delay250ms 
e11b			 
e11b			 
e11b			 
e11b				ld hl, store_page+2 
e11b				call forthparse 
e11b				call forthexec 
e11b				call forthexec_cleanup 
e11b			 
e11b				 
e11b				ld a, (store_openext) 
e11b				inc a 
e11b				ld (store_openext), a    ; save count of ext 
e11b			 
e11b				jr .autof 
e11b			;.autofdone: 
e11b			; 
e11b			;		if DEBUG_FORTH_WORDS 
e11b			;			DMARK "ASx" 
e11b			;			CALLMONITOR 
e11b			;		endif 
e11b			;;	call clear_display 
e11b			;	ret 
e11b			 
e11b			 
e11b			 
e11b			endif 
e11b			 
e11b			 
e11b			; eof 
# End of file forth_kernel.asm
e11b			;include "nascombasic.asm" 
e11b			 
e11b			 
e11b			; find out where the code ends if loaded into RAM (for SC114) 
e11b			;endofcode:  
e11b			;	nop 
e11b			 
e11b			 
e11b			; eof 
e11b			 
# End of file main.asm
e11b			;include "firmware_lcd_4x20.asm" 
e11b			;include "firmware_key_4x4.asm" 
e11b			include "firmware_serial_display.asm" 
e11b			 
e11b			; Serial display interface for SC114 
e11b			 
e11b			 
e11b			display_row_1: equ 0 
e11b			display_row_2: equ display_row_1+display_cols 
e11b			display_row_3: equ display_row_2 + display_cols 
e11b			display_row_4: equ display_row_3 + display_cols 
e11b			 
e11b			kLCDWidth:  EQU display_cols             ;Width in characters 
e11b			kLCD_Line1: EQU 0x00  
e11b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e11b			; E1 
e11b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e11b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e11b			 
e11b			lcd_init: 
e11b				; no init as handled by the SCM bios 
e11b c9				ret 
e11c			 
e11c			 
e11c			; low level functions for direct screen writes 
e11c			 
e11c			; output char at pos? 
e11c			fLCD_Str: 
e11c			        ;out (SC114_SIO_1_OUT),a 
e11c c5				push bc 
e11d 0e 02			ld c, $02 
e11f f7				rst $30 
e120 c1				pop bc 
e121 c9				ret 
e122			 
e122			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e122			fLCD_Pos: 
e122				; use ASCII escape to position 
e122			        ;out (SC114_SIO_1_OUT),a 
e122 c5				push bc 
e123 0e 02			ld c, $02 
e125 f7				rst $30 
e126 c1				pop bc 
e127			 
e127 c9				ret 
e128			 
e128			; output char at pos 
e128			fLCD_Data: 
e128			      ;  out (SC114_SIO_1_OUT),a 
e128 c5				push bc 
e129 0e 02			ld c, $02 
e12b f7				rst $30 
e12c c1				pop bc 
e12d			 
e12d c9				ret 
e12e			 
e12e			; ascii cls  
e12e			 
e12e 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e132			 
e132			; write the frame buffer given in hl to hardware  
e132			write_display: 
e132			 
e132			API: equ 0 
e132			 
e132			if API 
e132				push bc 
e132				ld b, 4 
e132			 
e132			        ld (display_write_tmp), hl 	  
e132			 
e132				; clear and home cursor 
e132			 
e132				ld c, 6 
e132				ld de, .cls 
e132				rst $30 
e132			 
e132			 
e132			.writeln: 
e132			 
e132				ld de, (display_write_tmp) 
e132				ld c, 6 
e132				rst $30 
e132				ld c, 7 
e132				rst $30 
e132			 
e132				ld hl, (display_write_tmp) 
e132				ld de, display_cols 
e132				add hl,de 
e132				ld (display_write_tmp),hl 
e132			 
e132				djnz  .writeln 
e132			 
e132				pop bc 
e132			 
e132			 
e132				ret 
e132			endif 
e132 e5				push hl 
e133 c5				push bc 
e134 d5				push de 
e135			 
e135			;	ld c, 2 
e135			;	;ld de, .cls 
e135			;	ld a, 27 
e135			;	rst $30 
e135			;	ld c, 2 
e135			;	;ld de, .cls 
e135			;	ld a, '[' 
e135			;	rst $30 
e135			; 
e135			;	ld c, 2 
e135			;	;ld de, .cls 
e135			;	ld a, 'H' 
e135			;	rst $30 
e135			; 
e135			 
e135 0e 02			ld c, 2 
e137				;ld de, .cls 
e137 3e 1b			ld a, 27 
e139 f7				rst $30 
e13a			 
e13a			 
e13a 0e 02			ld c, 2 
e13c				;ld de, .cls 
e13c 3e 5b			ld a, '[' 
e13e f7				rst $30 
e13f 0e 02			ld c, 2 
e141				;ld de, .cls 
e141 3e 32			ld a, '2' 
e143 f7				rst $30 
e144 0e 02			ld c, 2 
e146				;ld de, .cls 
e146 3e 4a			ld a, 'J' 
e148 f7				rst $30 
e149 d1				pop de 
e14a c1				pop bc 
e14b e1				pop hl 
e14c			 
e14c			 
e14c 22 55 ed		        ld (display_write_tmp), hl 	  
e14f 3e 00			ld a, kLCD_Line1 
e151			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e151 06 14			ld b, display_cols 
e153 ed 5b 55 ed		ld de, (display_write_tmp) 
e157 cd b5 e1			call write_len_string 
e15a				 
e15a			 
e15a e5			push hl 
e15b d5			push de 
e15c c5			push bc 
e15d 0e 07			ld c, 7 
e15f f7				rst $30 
e160 c1			pop bc 
e161 d1			pop de 
e162 e1			pop hl 
e163			 
e163				 
e163 2a 55 ed			ld hl, (display_write_tmp) 
e166 11 14 00			ld de, display_cols 
e169 19				add hl,de 
e16a 22 55 ed			ld (display_write_tmp),hl 
e16d			 
e16d				 
e16d 3e 14			ld a, kLCD_Line2 
e16f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e16f 06 14			ld b, display_cols 
e171 ed 5b 55 ed		ld de, (display_write_tmp) 
e175 cd b5 e1			call write_len_string 
e178				 
e178 2a 55 ed			ld hl, (display_write_tmp) 
e17b 11 14 00			ld de, display_cols 
e17e 19				add hl,de 
e17f 22 55 ed			ld (display_write_tmp),hl 
e182			 
e182 e5			push hl 
e183 d5			push de 
e184 c5			push bc 
e185 0e 07			ld c, 7 
e187 f7				rst $30 
e188 c1			pop bc 
e189 d1			pop de 
e18a e1			pop hl 
e18b			 
e18b				 
e18b 3e 28			ld a, kLCD_Line3 
e18d			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e18d 06 14			ld b, display_cols 
e18f ed 5b 55 ed		ld de, (display_write_tmp) 
e193 cd b5 e1			call write_len_string 
e196				 
e196 2a 55 ed			ld hl, (display_write_tmp) 
e199 11 14 00			ld de, display_cols 
e19c 19				add hl,de 
e19d 22 55 ed			ld (display_write_tmp),hl 
e1a0			 
e1a0 e5			push hl 
e1a1 d5			push de 
e1a2 c5			push bc 
e1a3 0e 07			ld c, 7 
e1a5 f7				rst $30 
e1a6 c1			pop bc 
e1a7 d1			pop de 
e1a8 e1			pop hl 
e1a9			 
e1a9				 
e1a9 3e 3c			ld a, kLCD_Line4 
e1ab			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e1ab 06 14			ld b, display_cols 
e1ad ed 5b 55 ed		ld de, (display_write_tmp) 
e1b1 cd b5 e1			call write_len_string 
e1b4 c9					ret 
e1b5			 
e1b5			 
e1b5				; write out a fixed length string given in b from de 
e1b5			 
e1b5 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e1b6 cd 28 e1		            CALL fLCD_Data      ;Write character to display 
e1b9 13				inc de 
e1ba 10 f9			djnz write_len_string 
e1bc c9				ret 
e1bd			 
e1bd			 
e1bd			; eof 
# End of file firmware_serial_display.asm
e1bd			include "firmware_key_serial.asm" 
e1bd			; Serial keyboard interface for SC114 
e1bd			 
e1bd			key_init: 
e1bd				; no init as handled by the SCM bios 
e1bd c9				ret 
e1be			 
e1be			 
e1be			cin_wait: 
e1be			;	ld a, 0 
e1be			;	ret 
e1be			 
e1be				;in a,(SC114_SIO_1_IN) 
e1be			        ; Use SCM API to get from whatever console device we are using 
e1be c5				push bc 
e1bf 0e 01			ld c, $01 
e1c1 f7				rst $30 
e1c2 c1				pop bc 
e1c3 c9				ret 
e1c4			 
e1c4			cin: 
e1c4			 
e1c4			 
e1c4 c5				push bc 
e1c5			 
e1c5				; any key waiting to process? 
e1c5 0e 03			ld c, $03 
e1c7 f7				rst $30 
e1c8 28 05			jr z, .cin_skip 
e1ca			 
e1ca				; yep, get it 
e1ca			 
e1ca 0e 01			ld c, $01 
e1cc f7				rst $30 
e1cd c1				pop bc 
e1ce c9				ret 
e1cf			.cin_skip: 
e1cf 3e 00			ld a, 0 
e1d1 c1				pop bc 
e1d2 c9				ret 
e1d3			 
e1d3			 
e1d3			 
e1d3			 
# End of file firmware_key_serial.asm
e1d3			 
e1d3			baseram:  
e1d3			endofcode: 
e1d3 00				nop 
e1d4			 
e1d4			heap_start: equ baseram+15  ; Starting address of heap 
e1d4			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e1d4			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e1d4			; 
e1d4			 
# End of file os_mini_sc114.asm
e1d4
