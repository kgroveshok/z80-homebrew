# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 19 1d			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			if BASE_KEV = 1  
001c			 
001c				; need to be at $66 for nmi support 
001c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0022 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0028 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0034 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003a 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0040 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0046 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0052 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0058 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0064 00 ff			db 0,255 
0066 c3 60 76			jp nmi 
0069			endif 
0069			 
0069			include "firmware.asm" 
0069			  
0069			; main constants (used here and in firmware)  
0069			  
0069			; TODO have page 0 of storage as bios  
0069			  
0069			Device_A: equ 0h  
0069			Device_B: equ 040h          ; Sound  
0069			  
0069			if BASE_KEV  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_SC114  
0069			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			; TODO fixup for CPM  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			Device_D: equ 0c0h             ; Keyboard and LCD  
0069			  
0069			; Odd specific debug points for testing hardware dev  
0069			  
0069			DEBUG_SOUND: equ 0       
0069			DEBUG_STK_FAULT: equ 0  
0069			DEBUG_INPUT: equ 0     ; Debug input entry code  
0069			DEBUG_KEYCINWAIT: equ 0  
0069			DEBUG_KEYCIN: equ 0  
0069			DEBUG_KEY: equ 0  
0069			DEBUG_KEY_MATRIX: equ 0  
0069			DEBUG_STORECF: equ 0  
0069			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0069			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0069			DEBUG_SPI: equ 0    ; low level spi tests  
0069			  
0069			; Enable many break points  
0069			  
0069			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0069			DEBUG_FORTH_JP: equ 0    ; 4  
0069			DEBUG_FORTH_MALLOC: equ 0  
0069			DEBUG_FORTH_MALLOC_INT: equ 0  
0069			DEBUG_FORTH_DOT: equ 1  
0069			DEBUG_FORTH_DOT_WAIT: equ 0  
0069			DEBUG_FORTH_MATHS: equ 0  
0069			DEBUG_FORTH_TOK: equ 0    ; 4  
0069			DEBUG_FORTH_PARSE: equ 0    ; 3  
0069			DEBUG_FORTH: equ 0  ;2  
0069			DEBUG_FORTH_WORDS: equ 1   ; 1  
0069			DEBUG_FORTH_PUSH: equ 1   ; 1  
0069			DEBUG_FORTH_UWORD: equ 1   ; 1  
0069			  
0069			; Enable key point breakpoints  
0069			  
0069			DEBUG_FORTH_DOT_KEY: equ 0  
0069			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0069			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0069			  
0069			; Debug stack imbalances  
0069			  
0069			ON: equ 1  
0069			OFF: equ 0  
0069			  
0069			DEBUG_STACK_IMB: equ 0  
0069			STACK_IMB_STORE: equ 20  
0069			  
0069			; House keeping and protections  
0069			  
0069			DEBUG_FORTH_STACK_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0069			FORTH_ENABLE_FREE: equ 0  
0069			FORTH_ENABLE_MALLOCFREE: equ 1  
0069			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0069			FORTH_ENABLE_FLOATMATH: equ 0  
0069			  
0069			  
0069			CALLMONITOR: macro  
0069			;	call break_point_state  
0069			; now use the break point debug vector  
0069				call debug_vector  
0069				endm  
0069			  
0069			MALLOC_1: equ 1        ; from dk88   
0069			MALLOC_2: equ 0           ; broke  
0069			MALLOC_3: equ 0           ; really broke  
0069			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0069			  
0069			if BASE_KEV   
0069			stacksize: equ 256  
0069			  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 512  
0069			endif  
0069			if BASE_SC114  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			;if STORAGE_SE == 0  
0069			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0069			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0069			;endif  
0069			  
0069			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0069			  
0069			STORE_0_AUTORUN: equ $20  
0069			  
0069			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0069			  
0069			STORE_0_AUTOFILE: equ $21  
0069			STORE_0_BANKRUN: equ $23  
0069			STORE_0_FILERUN: equ $24  
0069			  
0069			; Block 0 offsets for settings  
0069			  
0069			; if set then skip prompt for start up and accept all  
0069			  
0069			STORE_0_QUICKSTART: equ $25  
0069			  
0069			; Blocks where directory table is held  
0069			  
0069			; Reducing the number of entries increases the max file size  
0069			  
0069			;STORE_DIR_START: equ 1  
0069			;STORE_DIR_END: equ 33  
0069			  
0069			; Blocks from where file data is stored  
0069			  
0069			;STORE_DATA_START: equ STORE_DIR_END + 1  
0069			  
0069			; Block indicators (<32 are data files)  
0069			  
0069			;STORE_BLOCK_CFG: equ $8f       ; config block  
0069			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0069			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0069			;STORE_BLOCK_FREE: equ $85       ; data block free  
0069			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0069			  
0069			  
0069			  
0069			; Directory entry flags  
0069			  
0069			;STORE_DIR_FREE: equ 0  
0069			;STORE_DIR_FILE:  equ 1  
0069			  
0069			; Structure offsets to directory entries  
0069			;STORE_DE_FLAG: equ 0  
0069			;STORE_DE_MAXEXT: equ 1  
0069			;STORE_DE_FILENAME: equ 2  
0069			  
0069			; Structure offsets to block 0  
0069			  
0069			;STORE_BK0_ISFOR: equ 1  
0069			;STORE_BK0_LABEL: equ 3  
0069			  
0069			; memory allocation   
0069			  
0069			chk_stund: equ tos+2           ; underflow check word  
0069			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0069			  
0069			; keyscan table needs rows x cols buffer  
0069			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0069			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0069			  
0069			keyscan_table_row1: equ chk_stovr -key_cols-1  
0069			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0069			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0069			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0069			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0069			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0069			keyscan_scancol: equ keyscan_table-key_cols  
0069			;keyscan_table_len: equ key_rows*key_cols  
0069			;keybufptr: equ keyscan_table - 2  
0069			;keysymbol: equ keybufptr - 1  
0069			key_held: equ keyscan_scancol-1	; currently held  
0069			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0069			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0069			key_fa: equ key_repeat_ct -1 ;  
0069			key_fb: equ key_fa -1 ;  
0069			key_fc: equ key_fb -1 ;  
0069			key_fd: equ key_fc -1 ;  
0069			key_face_held: equ key_fd - 1   
0069			  
0069			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0069			  
0069			hardware_config: equ key_face_held - 10  
0069			  
0069			; hardware config switches  
0069			; TODO add bitmasks on includes for hardware  
0069			; high byte for expansion ids  
0069			;     0000 0000  no card inserted  
0069			;     0000 0001  storage card inserted  
0069			;     0000 0010  spi sd card active  
0069			  
0069			;       
0069			; low byte:  
0069			;     0000 0001   4x4 keypad  
0069			;     0000 0010   full keyboard  
0069			;     0000 0011   spi/ext keyboard  
0069			;     0000 0100   20x4 lcd  
0069			;     0000 1000   40x4 lcd  
0069			;     0000 1100   spi/ext display  
0069			;     0001 0000   ide interface available  
0069			  
0069			hardware_word: equ hardware_config - 2  
0069			  
0069			; debug marker - optional display of debug point on the debug screens  
0069			  
0069			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0069			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0069			  
0069			debug_mark: equ debug_vector - 4  
0069			  
0069			; input_str vars  
0069			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0069			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0069			input_size: equ input_start -1  ; number of chars  
0069			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0069			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0069			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0069			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0069			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0069			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0069			input_len: equ input_cur_onoff - 5 ; length of current input  
0069			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0069			  
0069			CUR_BLINK_RATE: equ 15  
0069			  
0069			key_actual_pressed: equ input_cursor - 1   
0069			key_symbol: equ key_actual_pressed - 1   
0069			key_shift: equ key_symbol - 1   
0069			  
0069			; Display allocation  
0069			  
0069			;display_rows: equ 4     ; move out to mini and mega files  
0069			;display_cols: equ 20  
0069			  
0069			display_fb_len: equ display_rows*display_cols  
0069			  
0069			; primary frame buffer     
0069			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0069			; working frame buffers  
0069			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0069			display_fb3: equ  display_fb1-display_fb_len - 1  
0069			display_fb2: equ  display_fb3-display_fb_len - 1  
0069			;  
0069			; pointer to active frame buffer  
0069			display_fb_active: equ display_fb2 - 2  
0069			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0069			display_write_tmp: equ display_lcde1e2 - 2  
0069			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0069			  
0069			;  
0069			  
0069			;; can load into de directory  
0069			cursor_col: equ display_active-1  
0069			cursor_row: equ cursor_col-1  
0069			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0069			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0069			  
0069			; maths vars  
0069			  
0069			LFSRSeed: equ cursor_shape -20   
0069			randData: equ LFSRSeed - 2  
0069			xrandc: equ randData - 2  
0069			stackstore: equ xrandc - 2  
0069			seed1: equ  stackstore -2   
0069			seed2: equ seed1 - 2  
0069			  
0069			; cf storage vars  
0069			  
0069			iErrorNum:  equ seed2-1         ;Error number  
0069			iErrorReg:  equ iErrorNum -1              ;Error register  
0069			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0069			  
0069			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0069			  
0069			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0069			  
0069			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0069			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0069			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0069			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0069			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0069			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0069			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0069			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0069			store_tmpid: equ store_tmp3 - 1		; page temp id  
0069			store_tmpext: equ store_tmpid - 1		; file extent temp  
0069			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0069			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0069			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0069			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0069			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0069			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0069			;  
0069			; spi vars  
0069			  
0069			  
0069			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0069			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0069			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0069			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0069			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0069			spi_device_id: equ spi_device - 1    ; human readable bank number  
0069			  
0069			;;;;; forth cli params  
0069			  
0069			; TODO use a different frame buffer for forth???  
0069			  
0069			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0069			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0069			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0069			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0069			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0069			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0069			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0069			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0069			  
0069			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0069			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0069			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0069			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0069			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0069			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0069			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0069			  
0069			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0069			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0069			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0069			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0069			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0069			  
0069			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0069			  
0069			; os/forth token vars  
0069			  
0069			os_last_cmd: equ os_var_array-255  
0069			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0069			os_current_i: equ os_cli_cmd-2  
0069			os_cur_ptr: equ os_current_i-2  
0069			os_word_scratch: equ os_cur_ptr-30  
0069			os_tok_len: equ os_word_scratch - 2  
0069			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0069			os_tok_malloc: equ os_tok_ptr - 2  
0069			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0069			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0069			execscratch: equ os_input-255        ; exec cmd eval buffer  
0069			scratch: equ execscratch-255  
0069			  
0069			  
0069			; temp locations for new word processing to save on adding more   
0069			  
0069			os_new_malloc: equ scratch-2  
0069			os_new_parse_len: equ os_new_malloc - 2  
0069			os_new_word_len: equ os_new_parse_len - 2  
0069			os_new_work_ptr: equ os_new_word_len - 2  
0069			os_new_src_ptr: equ os_new_work_ptr - 2  
0069			os_new_exec: equ os_new_src_ptr - 2  
0069			os_new_exec_ptr: equ os_new_exec - 2  
0069			  
0069			; resume memory alloocations....  
0069			  
0069			;os_view_disable: equ os_new_exec_ptr - 1  
0069			os_view_af: equ os_new_exec_ptr - 2  
0069			os_view_hl: equ os_view_af -2  
0069			os_view_de: equ os_view_hl - 2  
0069			os_view_bc: equ os_view_de - 2  
0069			  
0069			; stack checksum word  
0069			if DEBUG_STACK_IMB  
0069				curframe: equ  os_view_de - 5  
0069				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0069				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			else  
0069				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			endif  
0069			  
0069			; with data stack could see memory filled with junk. need some memory management   
0069			; malloc and free entry points added  
0069			  
0069			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0069			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			;heap_end: equ free_list-1  ; Starting address of heap  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			heap_end: equ chk_word-1  ; Starting address of heap  
0069			  
0069			  
0069			;if BASE_KEV   
0069			;heap_start: equ 0800eh  ; Starting address of heap  
0069			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;heap_start: equ baseram+15  ; Starting address of heap  
0069			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;endif  
0069			  
0069			  
0069			;;;;  
0069			  
0069			  
0069			; change below to point to last memory alloc above  
0069			topusermem:  equ   heap_start  
0069			  
0069			;if BASE_KEV   
0069			;baseusermem: equ 08000h  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;;aseusermem:     equ    12  
0069			;baseusermem:     equ    prompt  
0069			;;baseusermem:     equ    endofcode  
0069			;endif  
0069			  
0069			  
0069			; **********************************************************************  
0069			; **  Constants  
0069			; **********************************************************************  
0069			  
0069			; Constants used by this code module  
0069			kDataReg:   EQU Device_D           ;PIO port A data register  
0069			kContReg:   EQU Device_D+2           ;PIO port A control register  
0069			  
0069			  
0069			portbdata:  equ Device_D+1    ; port b data  
0069			portbctl:   equ Device_D+3    ; port b control  
0069			  
0069			  
0069			;KEY_SHIFT:   equ 5  
0069			;KEY_SYMBOLSHIFT:  equ 6  
0069			  
0069			KEY_SHIFTLOCK: equ 4  
0069			  
0069			  
0069			KEY_UP: equ 5  
0069			KEY_NEXTWORD: equ 6  
0069			KEY_PREVWORD: equ 7  
0069			KEY_BS: equ 8  
0069			KEY_TAB:  equ 9  
0069			KEY_DOWN: equ 10  
0069			KEY_LEFT: equ 11  
0069			KEY_RIGHT: equ 12  
0069			KEY_CR:   equ 13  
0069			KEY_HOME: equ 14  
0069			KEY_END: equ 15  
0069			  
0069			KEY_F1: equ 16  
0069			KEY_F2: equ 17  
0069			KEY_F3: equ 18  
0069			KEY_F4: equ 19  
0069			  
0069			KEY_F5: equ 20  
0069			KEY_F6: equ 21  
0069			KEY_F7: equ 22  
0069			KEY_F8: equ 23  
0069			  
0069			KEY_F9: equ 24  
0069			KEY_F10: equ 25  
0069			KEY_F11: equ 26  
0069			KEY_F12: equ 27  
0069			  
0069			;if DEBUG_KEY  
0069			;	KEY_MATRIX_NO_PRESS: equ '.'  
0069			;	KEY_SHIFT:   equ '.'  
0069			;	KEY_SYMBOLSHIFT:  equ '.'  
0069			;else  
0069				KEY_SHIFT:   equ '~'  
0069				KEY_SYMBOLSHIFT:  equ '~'  
0069				KEY_MATRIX_NO_PRESS: equ '~'  
0069			;endi  
0069			  
0069			  
0069			  
0069			  
0069			; Macro to make adding debug marks easier  
0069			  
0069			DMARK: macro str  
0069				push af  
0069				ld a, (.dmark)  
0069				ld (debug_mark),a  
0069				ld a, (.dmark+1)  
0069				ld (debug_mark+1),a  
0069				ld a, (.dmark+2)  
0069				ld (debug_mark+2),a  
0069				jr .pastdmark  
0069			.dmark: db str  
0069			.pastdmark: pop af  
0069			  
0069			endm  
0069			  
0069			  
0069			; macro to detect for stack imbalances  
0069			  
0069			include "stackimbal.asm"  
0069			; Macro and code to detect stock imbalances 
0069			 
0069			SPPUSH: equ 0 
0069			 
0069			; Add a stack frame which can be checked before return 
0069			 
0069			STACKFRAME: macro onoff frame1 frame2 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069						exx 
0069			 
0069						ld de, frame1 
0069						ld a, d 
0069						ld hl, curframe 
0069						call hexout 
0069						ld a, e 
0069						ld hl, curframe+2 
0069						call hexout 
0069			  
0069						ld hl, frame1 
0069						push hl 
0069						ld hl, frame2 
0069						push hl 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			endm 
0069			 
0069			STACKFRAMECHK: macro onoff frame1 frame2 
0069			 
0069					 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						exx 
0069						; check stack frame SP 
0069			 
0069						ld hl, frame2 
0069						pop de   ; frame2 
0069			 
0069						call cmp16 
0069						jr nz, .spnosame 
0069						 
0069			 
0069						ld hl, frame1 
0069						pop de   ; frame1 
0069			 
0069						call cmp16 
0069						jr z, .spfrsame 
0069			 
0069						.spnosame: call showsperror 
0069			 
0069						.spfrsame: nop 
0069			 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			 
0069			 
0069			endm 
0069			 
0069			 
0069			; for a sub routine, wrap SP collection and comparisons 
0069			 
0069			; Usage: 
0069			; 
0069			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0069			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0069			 
0069			SAVESP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069			 
0069						ld (store_sp+(storeword*4)), sp 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			CHECKSP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069			 
0069						; save SP after last save 
0069				 
0069						ld (store_sp+(storeword*4)+2), sp 
0069			 
0069						push hl 
0069						ld hl, store_sp+(storeword*4) 
0069						call check_stack_sp  
0069						pop hl 
0069			 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			if DEBUG_STACK_IMB 
0069			 
0069			check_stack_sp: 
0069					push de 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					push de 
0069			 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					pop hl 
0069			 
0069			 
0069					; check to see if the same 
0069			 
0069					call cmp16 
0069					jr z, .spsame 
0069			 
0069					; not same 
0069			 
0069					call showsperror 
0069			.spsame: 
0069			 
0069					pop de 
0069			 
0069					ret 
0069			 
0069			.sperr:  db "Stack imbalance",0 
0069			 
0069			 
0069			showsperror: 
0069			 
0069			 
0069				push hl 
0069				push af 
0069				push de 
0069				call clear_display 
0069				ld de, .sperr 
0069				ld a,0 
0069			;	ld de,os_word_scratch 
0069				call str_at_display 
0069				ld a, display_row_1+17 
0069				ld de, debug_mark 
0069				call str_at_display 
0069				ld a, 0 
0069				ld (curframe+4),a 
0069				ld hl, curframe 
0069				ld de, os_word_scratch 
0069				ld a, display_row_4 
0069				call str_at_display 
0069				call update_display 
0069				;call break_point_state 
0069				call cin_wait 
0069			 
0069			;	ld a, ' ' 
0069			;	ld (os_view_disable), a 
0069				call bp_on 
0069				pop de	 
0069				pop af 
0069				pop hl 
0069				CALLMONITOR 
0069				ret 
0069			 
0069			endif 
0069			 
0069			 
0069			 
0069			; eof 
# End of file stackimbal.asm
0069			  
0069			;TODO macro to calc col and row offset into screen  
0069			  
0069			  
0069			  
0069			hardware_init:  
0069			  
0069				  
0069			  
0069					;ld a, 0  
0069					;ld (hardware_diag), a  
0069			  
0069					; clear all the buffers  
0069			  
0069 21 0d fd				ld hl, display_fb1  
006c 22 c9 fb				ld (display_fb_active), hl  
006f			  
006f cd 9c 0d				call clear_display  
0072			  
0072 21 cb fb				ld hl, display_fb2  
0075 22 c9 fb				ld (display_fb_active), hl  
0078			  
0078 cd 9c 0d				call clear_display  
007b			  
007b					; init primary frame buffer area  
007b 21 ae fd				ld hl, display_fb0  
007e 22 c9 fb				ld (display_fb_active), hl  
0081			  
0081 cd 9c 0d				call clear_display  
0084			  
0084			  
0084 cd 6d 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0087			  
0087 cd 04 79			call key_init  
008a cd 48 02			call storage_init  
008d			  
008d				; setup malloc functions  
008d			  
008d				if MALLOC_1  
008d cd 73 14				call  heap_init  
0090				endif  
0090				if MALLOC_4  
0090					call  heap_init  
0090				endif  
0090			  
0090				; init sound hardware if present  
0090			  
0090				if SOUND_ENABLE  
0090					call sound_init  
0090				endif  
0090			  
0090				; lcd test sequence  
0090					  
0090 cd bf 0d			call update_display  
0093 cd df 0c			call delay1s  
0096 3e 2b			ld a,'+'  
0098 cd a1 0d			call fill_display  
009b cd bf 0d			call update_display  
009e cd df 0c			call delay1s  
00a1 3e 2a			ld a,'*'  
00a3 cd a1 0d			call fill_display  
00a6 cd bf 0d			call update_display  
00a9 cd df 0c			call delay1s  
00ac 3e 2d			ld a,'-'  
00ae cd a1 0d			call fill_display  
00b1 cd bf 0d			call update_display  
00b4 cd df 0c			call delay1s  
00b7			  
00b7			; boot splash screen  
00b7			if display_cols == 20	  
00b7			        ld a, display_row_1    
00b7			else  
00b7 3e 0a		        ld a, display_row_1 +10   
00b9			endif  
00b9 11 11 1c			ld de, prom_bootmsg  
00bc cd af 0d			call str_at_display  
00bf cd bf 0d			call update_display  
00c2			  
00c2			  
00c2 cd df 0c			call delay1s  
00c5 cd df 0c			call delay1s  
00c8			if display_cols == 20	  
00c8			            LD   A, display_row_3+2  
00c8			else  
00c8 3e 5c		            LD   A, display_row_3+12  
00ca			endif  
00ca 11 26 1c			ld de, prom_bootmsg1  
00cd cd af 0d			call str_at_display  
00d0 cd bf 0d			call update_display  
00d3 cd df 0c			call delay1s  
00d6 cd df 0c			call delay1s  
00d9			  
00d9			;	ld a, display_row_4+3  
00d9			;	ld de, bootmsg2  
00d9			;	call str_at_display  
00d9			;	call update_display  
00d9			;	call delay1s  
00d9			;	call delay1s  
00d9			  
00d9			; debug mark setup  
00d9			  
00d9 3e 5f		ld a, '_'  
00db 32 68 fe		ld (debug_mark),a  
00de 32 69 fe		ld (debug_mark+1),a  
00e1 32 6a fe		ld (debug_mark+2),a  
00e4 3e 00		ld a,0  
00e6 32 6b fe		ld (debug_mark+3),a  
00e9			  
00e9 c9					ret  
00ea			  
00ea			  
00ea			;bootmsg2:	db "Firmware v0.1",0  
00ea			  
00ea			; a 4x20 lcd  
00ea			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ea			  
00ea			;if display_cols == 20  
00ea			;	include "firmware_lcd_4x20.asm"  
00ea			;endif  
00ea			  
00ea			;if display_cols == 40  
00ea			;	include "firmware_lcd_4x40.asm"  
00ea			;endif  
00ea			  
00ea			;  
00ea			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ea			; TODO abstract the bit bang video out interface for dual display  
00ea			; TODO wire video out to tx pin on rc2014 bus  
00ea			  
00ea			; must supply cin, and cin_wait for low level hardware abstraction   
00ea			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ea			; test scancode  
00ea			  
00ea			;;;;;  
00ea			;;;  
00ea			; Moved out to mini and maxi versions  
00ea			;  
00ea			; include "firmware_key_4x4.asm"  
00ea			; using existing 4 wire x 4 resistor array for input  
00ea			;include "firmware_key_4x10.asm"  
00ea			; need to mod the board for 5 rows due to resistor array  
00ea			;include "firmware_key_5x10.asm"  
00ea			  
00ea			; storage hardware interface  
00ea			  
00ea			; use microchip serial eeprom for storage  
00ea			  
00ea			  
00ea			if STORAGE_SE  
00ea				include "firmware_spi.asm"  
00ea			; my spi protocol (used by storage) 
00ea			 
00ea			; SPI pins 
00ea			 
00ea			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ea			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ea			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ea			 
00ea			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ea			; chip pin 4 gnd 
00ea			 
00ea			 
00ea			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ea			SPI_CE1: equ 1      ;    port a1 pin 14  
00ea			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ea			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ea			SPI_CE4: equ 4      ; port a4     pin 10 
00ea			 
00ea			; active low AND masks 
00ea			 
00ea			;SPI_CE0_MASK: equ    255-1 
00ea			;SPI_CE1_MASK: equ   255-2 
00ea			;SPI_CE2_MASK: equ   255-4 
00ea			;SPI_CE3_MASK: equ   255-8 
00ea			;SPI_CE4_MASK: equ   255-16 
00ea			SPI_CE_HIGH:  equ 255 
00ea			 
00ea			 
00ea			 
00ea			;  Perform SCLK wait pulse 
00ea			 
00ea			spi_clk: 
00ea f5				push af 
00eb 3a 61 fa			ld a, (spi_clktime) 
00ee fe 00			cp 0 
00f0 28 03			jr z, .scskip 
00f2 cd c4 0c			call aDelayInMS 
00f5			.scskip: 
00f5 f1				pop af 
00f6 c9				ret 
00f7			 
00f7			 
00f7			 
00f7			; TODO store port id for spi device ie dev c 
00f7			; TODO store pin for SO 
00f7			; TODO store pin for SI 
00f7			; TODO store pin for SCLK 
00f7			 
00f7			; 
00f7			 
00f7			; ensure that spi bus is in a stable state with default pins  
00f7			 
00f7			se_stable_spi:   
00f7			 
00f7				 ; set DI high, CE high , SCLK low 
00f7				;ld a, SPI_DI | SPI_CE0 
00f7 3e 07			ld a, SPI_DI  
00f9 cd 03 02			call spi_ce_high 
00fc d3 80			 out (storage_adata),a 
00fe 32 5e fa			ld (spi_portbyte),a 
0101			 
0101				if DEBUG_SPI 
0101					push hl 
0101					ld l, a 
0101					DMARK "SPI" 
0101					CALLMONITOR 
0101					pop hl 
0101				endif 
0101 c9				ret 
0102			 
0102			; byte to send in a 
0102			 
0102			spi_send_byte: 
0102				; save byte to send for bit mask shift out 
0102 4f			        ld c,a 
0103 3a 5e fa			ld a,(spi_portbyte) 
0106				  
0106				; clock out	each bit of the byte msb first 
0106			 
0106 06 08			ld b, 8 
0108			.ssb1: 
0108				; clear so bit  
0108 cb bf			res SPI_DI, a 
010a cb 11			rl c 
010c				; if bit 7 is set then carry is set 
010c 30 02			jr nc, .ssb2 
010e cb ff			set SPI_DI,a 
0110			.ssb2:  ; output bit to ensure it is stable 
0110 d3 80			out (storage_adata),a 
0112 00				nop 
0113				; clock bit high 
0113 cb ef			set SPI_SCLK,a 
0115 d3 80			out (storage_adata),a 
0117 00				nop 
0118 cd ea 00			call spi_clk 
011b				; then low 
011b cb af			res SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120 cd ea 00			call spi_clk 
0123 10 e3			djnz .ssb1 
0125			 
0125 32 5e fa			ld (spi_portbyte),a 
0128 c9				ret 
0129			 
0129			; TODO low level get byte into A on spi 
0129			 
0129			spi_read_byte:  
0129			 
0129				; save byte to send for bit mask shift out 
0129 0e 00		    ld c,0 
012b 3a 5e fa			ld a,(spi_portbyte) 
012e				  
012e				; clock out	each bit of the byte msb first 
012e			 
012e			 
012e				; clock bit high 
012e cb ef			set SPI_SCLK,a 
0130 d3 80			out (storage_adata),a 
0132 00				nop 
0133 cd ea 00			call spi_clk 
0136			 
0136			    ; read DO  
0136			 
0136 cb f9		    set 7,c 
0138 db 80			in a,(storage_adata) 
013a cb 77		    bit SPI_DO,a 
013c 20 02		    jr nz, .b7 
013e cb b9		    res 7,c 
0140			.b7: 
0140				; then low 
0140 cb af			res SPI_SCLK,a 
0142 d3 80			out (storage_adata),a 
0144 00				nop 
0145 cd ea 00			call spi_clk 
0148			     
0148			 
0148				; clock bit high 
0148 cb ef			set SPI_SCLK,a 
014a d3 80			out (storage_adata),a 
014c 00				nop 
014d cd ea 00			call spi_clk 
0150			 
0150			    ; read DO  
0150			 
0150 cb f1		    set 6,c 
0152 db 80			in a,(storage_adata) 
0154 cb 77		    bit SPI_DO,a 
0156 20 02		    jr nz, .b6 
0158 cb b1		    res 6,c 
015a			.b6: 
015a				; then low 
015a cb af			res SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f cd ea 00			call spi_clk 
0162			 
0162				; clock bit high 
0162 cb ef			set SPI_SCLK,a 
0164 d3 80			out (storage_adata),a 
0166 00				nop 
0167 cd ea 00			call spi_clk 
016a			 
016a			 
016a			    ; read DO  
016a			 
016a cb e9		    set 5,c 
016c db 80			in a,(storage_adata) 
016e cb 77		    bit SPI_DO,a 
0170 20 02		    jr nz, .b5 
0172 cb a9		    res 5,c 
0174			.b5: 
0174				; then low 
0174 cb af			res SPI_SCLK,a 
0176 d3 80			out (storage_adata),a 
0178 00				nop 
0179 cd ea 00			call spi_clk 
017c				; clock bit high 
017c cb ef			set SPI_SCLK,a 
017e d3 80			out (storage_adata),a 
0180 00				nop 
0181 cd ea 00			call spi_clk 
0184			 
0184			    ; read DO  
0184			 
0184 cb e1		    set 4,c 
0186 db 80			in a,(storage_adata) 
0188 cb 77		    bit SPI_DO,a 
018a 20 02		    jr nz, .b4 
018c cb a1		    res 4,c 
018e			.b4: 
018e				; then low 
018e cb af			res SPI_SCLK,a 
0190 d3 80			out (storage_adata),a 
0192 00				nop 
0193 cd ea 00			call spi_clk 
0196				; clock bit high 
0196 cb ef			set SPI_SCLK,a 
0198 d3 80			out (storage_adata),a 
019a 00				nop 
019b cd ea 00			call spi_clk 
019e			 
019e			    ; read DO  
019e			 
019e cb d9		    set 3,c 
01a0 db 80			in a,(storage_adata) 
01a2 cb 77		    bit SPI_DO,a 
01a4 20 02		    jr nz, .b3 
01a6 cb 99		    res 3,c 
01a8			.b3: 
01a8				; then low 
01a8 cb af			res SPI_SCLK,a 
01aa d3 80			out (storage_adata),a 
01ac 00				nop 
01ad cd ea 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4 00				nop 
01b5 cd ea 00			call spi_clk 
01b8			 
01b8			    ; read DO  
01b8			 
01b8 cb d1		    set 2,c 
01ba db 80			in a,(storage_adata) 
01bc cb 77		    bit SPI_DO,a 
01be 20 02		    jr nz, .b2 
01c0 cb 91		    res 2,c 
01c2			.b2: 
01c2				; then low 
01c2 cb af			res SPI_SCLK,a 
01c4 d3 80			out (storage_adata),a 
01c6 00				nop 
01c7 cd ea 00			call spi_clk 
01ca				; clock bit high 
01ca cb ef			set SPI_SCLK,a 
01cc d3 80			out (storage_adata),a 
01ce 00				nop 
01cf cd ea 00			call spi_clk 
01d2			 
01d2			    ; read DO  
01d2			 
01d2 cb c9		    set 1,c 
01d4 db 80			in a,(storage_adata) 
01d6 cb 77		    bit SPI_DO,a 
01d8 20 02		    jr nz, .b1 
01da cb 89		    res 1,c 
01dc			.b1: 
01dc				; then low 
01dc cb af			res SPI_SCLK,a 
01de d3 80			out (storage_adata),a 
01e0 00				nop 
01e1 cd ea 00			call spi_clk 
01e4				; clock bit high 
01e4 cb ef			set SPI_SCLK,a 
01e6 d3 80			out (storage_adata),a 
01e8 00				nop 
01e9 cd ea 00			call spi_clk 
01ec			 
01ec			    ; read DO  
01ec			 
01ec cb c1		    set 0,c 
01ee db 80			in a,(storage_adata) 
01f0 cb 77		    bit SPI_DO,a 
01f2 20 02		    jr nz, .b0 
01f4 cb 81		    res 0,c 
01f6			.b0: 
01f6				; then low 
01f6 cb af			res SPI_SCLK,a 
01f8 d3 80			out (storage_adata),a 
01fa 00				nop 
01fb cd ea 00			call spi_clk 
01fe			 
01fe			 
01fe 32 5e fa			ld (spi_portbyte),a 
0201			 
0201			    ; return byte 
0201 79			    ld a,c 
0202			 
0202			 
0202 c9				ret 
0203			 
0203			 
0203			 
0203			spi_ce_high: 
0203			 
0203				if DEBUG_SPI_HARD_CE0 
0203			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0203					ret 
0203			 
0203				endif 
0203			 
0203			 
0203 f5				push af 
0204			 
0204				; send direct ce to port b 
0204 3e ff			ld a, 255 
0206 d3 81			out (storage_bdata), a 
0208			 
0208 f1				pop af 
0209			 
0209				; for port a that shares with spi lines AND the mask 
0209			  
0209				if DEBUG_SPI 
0209					push hl 
0209					ld h, a 
0209				endif 
0209			;	ld c, SPI_CE_HIGH 
0209			;	and c 
0209 cb c7			set SPI_CE0, a 
020b cb cf			set SPI_CE1, a 
020d cb d7			set SPI_CE2, a 
020f cb df			set SPI_CE3, a 
0211 cb e7			set SPI_CE4, a 
0213			 
0213				if DEBUG_SPI 
0213					ld l, a 
0213					DMARK "CEh" 
0213					CALLMONITOR 
0213					pop hl 
0213				endif 
0213 c9				ret 
0214			 
0214			 
0214			spi_ce_low: 
0214			 
0214				if DEBUG_SPI_HARD_CE0 
0214			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0214					ret 
0214			 
0214				endif 
0214			 
0214 c5				push bc 
0215 f5				push af 
0216			 
0216				; send direct ce to port b 
0216 3a 60 fa			ld a, (spi_cartdev) 
0219 d3 81			out (storage_bdata), a 
021b			 
021b			 
021b			 
021b				; for port a that shares with spi lines AND the mask 
021b			 
021b 3a 5d fa			ld a, (spi_device)  
021e 4f				ld c, a 
021f			 
021f f1				pop af 
0220			 
0220				; detect CEx 
0220			 
0220				if DEBUG_SPI 
0220					push hl 
0220					ld h, a 
0220				endif 
0220			 
0220 cb 41			bit SPI_CE0, c 
0222 20 04			jr nz, .cel1 
0224 cb 87			res SPI_CE0, a 
0226 18 1e			jr .celn 
0228			.cel1: 
0228 cb 49			bit SPI_CE1, c 
022a 20 04			jr nz, .cel2 
022c cb 8f			res SPI_CE1, a 
022e 18 16			jr .celn 
0230			.cel2: 
0230 cb 51			bit SPI_CE2, c 
0232 20 04			jr nz, .cel3 
0234 cb 97			res SPI_CE2, a 
0236 18 0e			jr .celn 
0238			.cel3: 
0238 cb 59			bit SPI_CE3, c 
023a 20 04			jr nz, .cel4 
023c cb 9f			res SPI_CE3, a 
023e 18 06			jr .celn 
0240			.cel4: 
0240 cb 61			bit SPI_CE4, c 
0242 20 02			jr nz, .celn 
0244 cb a7			res SPI_CE4, a 
0246			.celn: 
0246			 
0246			 
0246			 
0246			;	add c 
0246			 
0246				if DEBUG_SPI 
0246					ld l, a 
0246					DMARK "CEl" 
0246					CALLMONITOR 
0246					pop hl 
0246				endif 
0246 c1				pop bc 
0247 c9				ret 
0248			 
0248			 
0248			 
0248			; eof 
0248			 
0248			 
0248			 
0248			 
0248			 
# End of file firmware_spi.asm
0248				include "firmware_seeprom.asm"  
0248			; 
0248			; persisent storage interface via microchip serial eeprom 
0248			 
0248			; port a pio 2 
0248			; pa 7 - si 
0248			; pa 6 - sclk  
0248			; pa 5 - so 
0248			; pa 4 - cs 
0248			; pa 3 - cs 
0248			; pa 2 - cs 
0248			; pa 1 - cs 
0248			; pa 0 - cs 
0248			; 
0248			; TODO get block 
0248			; TODO save block 
0248			; TODO load file 
0248			; TODO save file 
0248			; TODO get dir  
0248			 
0248			;  
0248			storage_adata: equ Device_C    ; device c port a - onboard storage 
0248			storage_actl: equ Device_C+2     ; device c port a 
0248			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0248			storage_bctl: equ Device_C+3     ; device c port b 
0248			 
0248			 
0248			; TODO move these to hardware driver file 
0248			 
0248			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0248			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0248			; storage bank file system format 
0248			; 
0248			; first page of bank: 
0248			; 	addr 0 - status check 
0248			;       addr 1 - write protect flag 
0248			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0248			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0248			;         TODO see if scanning whole of for available next file id is fast enough 
0248			;	addr 4 > zero term string of bank label 
0248			; 
0248			;        
0248			;  
0248			; first page of any file: 
0248			;      byte 0 - file id  
0248			;      byte 1-17 - fixed file name  
0248			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0248			; 
0248			; other pages of any file: 
0248			;      byte 0 - file id 
0248			;      byte 1> - file data 
0248			; 
0248			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0248			;  
0248			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0248			 
0248			 
0248			;storage_so_bit: 5 
0248			;storage_si_bit: 7 
0248			;storage_sclk_bit: 6 
0248			  
0248			 
0248			; init storage pio 
0248			 
0248			storage_init: 
0248			 
0248			 
0248					; set default SPI clk pulse time as disabled 
0248			 
0248 3e 00				ld a, 0 
024a 32 61 fa				ld (spi_clktime), a 
024d			 
024d					; init hardware 
024d			 
024d 3e cf		            LD   A, 11001111b 
024f d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0251 3e 00		            LD   A, 00000000b 
0253 cb f7			set SPI_DO,a 
0255			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0255 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0257			 
0257 3e cf		            LD   A, 11001111b 
0259 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025b 3e 00		            LD   A, 00000000b 
025d d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025f			 
025f				; set all external spi devices off  
025f 3e ff			ld a, 255 
0261 32 5d fa			ld (spi_device), a 
0264 32 60 fa			ld (spi_cartdev), a 
0267			 
0267					; ensure the spi bus is in a default stable state 
0267 cd f7 00				call se_stable_spi 
026a			 
026a			; TODO scan spi bus and gather which storage banks are present 
026a			 
026a			; populate store_bank_active  
026a			; for each ce line activate and attempt to write first byte of bank and read back 
026a			; if zero is returned then bank is empty 
026a			;   
026a			; 
026a			 
026a					; init file extent cache to save on slow reads 
026a			 
026a			;	ld hl, store_filecache 
026a			;	ld de, 0 
026a			;	ld hl,(de)	 
026a			 
026a			 
026a c9			    ret 
026b			 
026b			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026b			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026b			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026b			 
026b			; INSTRUCTION SET 
026b			; READ 0000 0011 Read data from memory array beginning at selected address 
026b			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026b			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026b			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026b			; RDSR 0000 0101 Read STATUS register 
026b			; WRSR 0000 0001 Write STATUS register 
026b			; PE 0100 0010 Page Erase – erase one page in memory array 
026b			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026b			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026b			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026b			 
026b			; TODO send byte steam for page without setting the address for every single byte 
026b			; TODO read byte  
026b			 
026b			; byte in a 
026b			; address in hl  
026b			se_writebyte: 
026b			        
026b			    ;   ld c, a 
026b f5			        push af 
026c e5			        push hl 
026d			 
026d			    ; initi write mode 
026d			    ; 
026d			    ;CS low 
026d			 
026d 3a 5e fa		       ld a,(spi_portbyte) 
0270 cd 14 02			call spi_ce_low 
0273			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0273 d3 80		       out (storage_adata),a 
0275 32 5e fa		       ld (spi_portbyte), a 
0278			 
0278			    ;clock out wren instruction 
0278			 
0278 3e 06		    ld a, store_wren_ins 
027a cd 02 01		    call spi_send_byte  
027d			 
027d			    ;cs high to enable write latch 
027d			 
027d 3a 5e fa		       ld a,(spi_portbyte) 
0280 cd 03 02			call spi_ce_high 
0283			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0283 d3 80		       out (storage_adata),a 
0285 32 5e fa		       ld (spi_portbyte), a 
0288			 
0288 00				nop 
0289			    ; 
0289			    ; intial write data 
0289			    ; 
0289			    ; cs low 
0289			     
0289 3a 5e fa		       ld a,(spi_portbyte) 
028c cd 14 02			call spi_ce_low 
028f			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028f d3 80		       out (storage_adata),a 
0291 32 5e fa		       ld (spi_portbyte), a 
0294			 
0294			    ; clock out write instruction 
0294			     
0294 3e 02		    ld a, store_write_ins  
0296 cd 02 01		    call spi_send_byte  
0299			 
0299			    ; clock out address (depending on address size) 
0299			     
0299 e1			    pop hl 
029a 7c			    ld a,h    ; address out msb first 
029b cd 02 01		    call spi_send_byte  
029e 7d			    ld a,l 
029f cd 02 01		    call spi_send_byte  
02a2			 
02a2			    ; clock out byte(s) for page 
02a2			 
02a2 f1			    pop af 
02a3 cd 02 01		    call spi_send_byte  
02a6			 
02a6			    ; end write with ce high 
02a6 3a 5e fa		       ld a,(spi_portbyte) 
02a9			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a9 cd 03 02			call spi_ce_high 
02ac d3 80		       out (storage_adata),a 
02ae 32 5e fa		       ld (spi_portbyte), a 
02b1			 
02b1				; pause for internal write cycle 
02b1 3e 0a			ld a, 10 
02b3 cd c4 0c			call aDelayInMS 
02b6 c9			    ret 
02b7			 
02b7			; buffer to write in de 
02b7			; address in hl  
02b7			se_writepage: 
02b7			        
02b7			    ;   ld c, a 
02b7 d5				push de 
02b8 e5			        push hl 
02b9			 
02b9			    ; initi write mode 
02b9			    ; 
02b9			    ;CS low 
02b9			 
02b9 3a 5e fa		       ld a,(spi_portbyte) 
02bc cd 14 02			call spi_ce_low 
02bf			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02bf d3 80		       out (storage_adata),a 
02c1 32 5e fa		       ld (spi_portbyte), a 
02c4			 
02c4			    ;clock out wren instruction 
02c4			 
02c4 3e 06		    ld a, store_wren_ins 
02c6 cd 02 01		    call spi_send_byte  
02c9			 
02c9			    ;cs high to enable write latch 
02c9			 
02c9 3a 5e fa		       ld a,(spi_portbyte) 
02cc cd 03 02			call spi_ce_high 
02cf			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cf d3 80		       out (storage_adata),a 
02d1 32 5e fa		       ld (spi_portbyte), a 
02d4			 
02d4 00				nop 
02d5			    ; 
02d5			    ; intial write data 
02d5			    ; 
02d5			    ; cs low 
02d5			     
02d5 3a 5e fa		       ld a,(spi_portbyte) 
02d8			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d8 cd 14 02			call spi_ce_low 
02db d3 80		       out (storage_adata),a 
02dd 32 5e fa		       ld (spi_portbyte), a 
02e0			 
02e0			    ; clock out write instruction 
02e0			     
02e0 3e 02		    ld a, store_write_ins  
02e2 cd 02 01		    call spi_send_byte  
02e5			 
02e5			    ; clock out address (depending on address size) 
02e5			     
02e5 e1			    pop hl 
02e6 7c			    ld a,h    ; address out msb first 
02e7 cd 02 01		    call spi_send_byte  
02ea 7d			    ld a,l 
02eb cd 02 01		    call spi_send_byte  
02ee			 
02ee			    ; clock out byte(s) for page 
02ee			 
02ee e1				pop hl 
02ef 06 40			ld b, STORE_BLOCK_PHY 
02f1			.bytewrite: 
02f1			 
02f1 7e				ld a,(hl) 
02f2 e5			    push hl 
02f3 c5				push bc 
02f4 cd 02 01		    call spi_send_byte  
02f7 c1				pop bc 
02f8 e1				pop hl 
02f9			 
02f9			    ; end write with ce high 
02f9 3a 5e fa		       ld a,(spi_portbyte) 
02fc cd 03 02			call spi_ce_high 
02ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ff d3 80		       out (storage_adata),a 
0301 32 5e fa		       ld (spi_portbyte), a 
0304			 
0304 23				inc hl 
0305 10 ea			djnz .bytewrite 
0307			 
0307				; pause for internal write cycle 
0307 3e 64			ld a, 100 
0309 cd c4 0c			call aDelayInMS 
030c c9			    ret 
030d			; returns byte in a 
030d			; address in hl  
030d			se_readbyte: 
030d d5				push de 
030e c5				push bc 
030f			 
030f			    ;   ld c, a 
030f e5			        push hl 
0310			 
0310			    ; initi write mode 
0310			    ; 
0310			    ;CS low 
0310			 
0310 3a 5e fa		       ld a,(spi_portbyte) 
0313 cd 14 02			call spi_ce_low 
0316			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0316 d3 80		       out (storage_adata),a 
0318 32 5e fa		       ld (spi_portbyte), a 
031b			 
031b			    ;clock out wren instruction 
031b			 
031b 3e 03		    ld a, store_read_ins 
031d cd 02 01		    call spi_send_byte  
0320			 
0320			 
0320			    ; clock out address (depending on address size) 
0320			     
0320 e1			    pop hl 
0321 7c			    ld a,h    ; address out msb first 
0322 cd 02 01		    call spi_send_byte  
0325 7d			    ld a,l 
0326 cd 02 01		    call spi_send_byte  
0329			 
0329			    ; clock in byte(s) for page 
0329			 
0329 cd 29 01		    call spi_read_byte  
032c f5				push af 
032d			 
032d			    ; end write with ce high 
032d 3a 5e fa		       ld a,(spi_portbyte) 
0330			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0330 cd 03 02			call spi_ce_high 
0333 d3 80		       out (storage_adata),a 
0335 32 5e fa		       ld (spi_portbyte), a 
0338			 
0338 f1				pop af 
0339			 
0339 c1				pop bc 
033a d1				pop de 
033b			 
033b c9			    ret 
033c			 
033c			if DEBUG_STORESE 
033c			 
033c			storageput:  
033c			 
033c			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033c			 
033c 21 c0 f1			ld hl,scratch+2 
033f cd 87 13			call get_word_hl 
0342			 
0342				; stuff it here for the moment as it will be overwritten later anyway 
0342			 
0342 22 e1 f4			ld (os_cur_ptr),hl	 
0345			 
0345			 
0345			; get pointer to start of string 
0345			 
0345 21 c5 f1			ld hl, scratch+7 
0348			 
0348			; loop writing char of string to eeprom 
0348			 
0348 7e			.writestr:	ld a,(hl) 
0349 fe 00				cp 0 
034b 28 12				jr z, .wsdone		; done writing 
034d e5					push hl 
034e 2a e1 f4				ld hl,(os_cur_ptr) 
0351 cd 6b 02				call se_writebyte 
0354			 
0354 2a e1 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0357 23					inc hl 
0358 22 e1 f4				ld (os_cur_ptr),hl 
035b			 
035b					; restore string pointer and get next char 
035b			 
035b e1					pop hl 
035c 23					inc hl 
035d 18 e9				jr .writestr 
035f			 
035f			 
035f			 
035f			.wsdone: 
035f			 
035f			 
035f			; when done load first page into a buffer  
035f			 
035f 21 00 80				ld hl,08000h		; start in ram 
0362 22 e1 f4				ld (os_cur_ptr),hl 
0365 21 00 00				ld hl, 0		 ; start of page 
0368 22 e6 f1				ld (scratch+40),hl	; hang on to it 
036b			 
036b 06 80				ld b, 128		; actually get more then one page 
036d c5			.wsload:	push bc 
036e 2a e6 f1				ld hl,(scratch+40) 
0371 e5					push hl 
0372 cd 0d 03				call se_readbyte 
0375			 
0375					; a now as the byte 
0375			 
0375 2a e1 f4				ld hl,(os_cur_ptr) 
0378 77					ld (hl),a 
0379					; inc next buffer area 
0379 23					inc hl 
037a 22 e1 f4				ld (os_cur_ptr),hl 
037d			 
037d					; get eeprom position, inc and save for next round 
037d e1					pop hl		 
037e 23					inc hl 
037f 22 e6 f1				ld (scratch+40),hl 
0382 c1					pop bc 
0383 10 e8				djnz .wsload 
0385			 
0385			; set 'd' pointer to start of buffer 
0385			 
0385 21 00 80				ld hl,08000h 
0388 22 e1 f4				ld (os_cur_ptr),hl 
038b			 
038b			 
038b c9			ret 
038c			 
038c			 
038c c9			storageread: ret 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			endif 
038d			 
038d			 
038d			 
# End of file firmware_seeprom.asm
038d			else  
038d			   ; create some stubs for the labels  
038d			se_readbyte: ret  
038d			se_writebyte: ret  
038d			storage_init: ret  
038d			  
038d			endif  
038d			  
038d			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038d			;include "firmware_cf.asm"  
038d			  
038d			; load up high level storage hardward abstractions  
038d			include "firmware_storage.asm"  
038d			 
038d			; persisent storage hardware abstraction layer  
038d			 
038d			 
038d			 
038d			; Block 0 on storage is a config state 
038d			 
038d			 
038d			 
038d			; TODO add read phy block and write phy block functions 
038d			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038d			 
038d			; Abstraction layer  
038d			 
038d			; Logocial block size is same size as physical size - using tape concept 
038d			 
038d			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038d			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038d			 
038d			 
038d			 
038d			; Filesystem layout (Logical layout) 
038d			; 
038d			; Block 0 - Bank config  
038d			; 
038d			;      Byte - 0 file id counter 
038d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038d			;      Byte - 3-20 zero terminated bank label 
038d			; 
038d			; Block 1 > File storage 
038d			; 
038d			;      Byte 0 file id    - block 0 file details 
038d			;      Byte 1 block id - block 0 is file  
038d			;            Byte 2-15 - File name 
038d			; 
038d			;       - to end of block data 
038d			; 
038d			 
038d			; Get ID for the file named in pointer held HL 
038d			; Returns ID in HL = 255 if no file found 
038d			 
038d			storage_getid: 
038d			 
038d 22 70 fa			ld (store_tmp1), hl 
0390			 
0390				if DEBUG_STORESE 
0390					DMARK "SGI" 
0390 f5				push af  
0391 3a a5 03			ld a, (.dmark)  
0394 32 68 fe			ld (debug_mark),a  
0397 3a a6 03			ld a, (.dmark+1)  
039a 32 69 fe			ld (debug_mark+1),a  
039d 3a a7 03			ld a, (.dmark+2)  
03a0 32 6a fe			ld (debug_mark+2),a  
03a3 18 03			jr .pastdmark  
03a5 ..			.dmark: db "SGI"  
03a8 f1			.pastdmark: pop af  
03a9			endm  
# End of macro DMARK
03a9					CALLMONITOR 
03a9 cd 6c fe			call debug_vector  
03ac				endm  
# End of macro CALLMONITOR
03ac				endif 
03ac				; get block 0 and set counter for number of files to scan 
03ac			 
03ac cd 17 05			call storage_get_block_0 
03af			 
03af 3a 77 fa			ld a, (store_page) 
03b2 47				ld b, a 
03b3			 
03b3				; get extent 0 of each file id 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 68 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 69 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 6a fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd 6c fe			call debug_vector  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf 60			.getloop:	ld h, b 
03d0 2e 00				ld l, 0 
03d2 c5					push bc 
03d3			 
03d3 11 77 fa				ld de, store_page 
03d6				if DEBUG_STORESE 
03d6					DMARK "SGr" 
03d6 f5				push af  
03d7 3a eb 03			ld a, (.dmark)  
03da 32 68 fe			ld (debug_mark),a  
03dd 3a ec 03			ld a, (.dmark+1)  
03e0 32 69 fe			ld (debug_mark+1),a  
03e3 3a ed 03			ld a, (.dmark+2)  
03e6 32 6a fe			ld (debug_mark+2),a  
03e9 18 03			jr .pastdmark  
03eb ..			.dmark: db "SGr"  
03ee f1			.pastdmark: pop af  
03ef			endm  
# End of macro DMARK
03ef					CALLMONITOR 
03ef cd 6c fe			call debug_vector  
03f2				endm  
# End of macro CALLMONITOR
03f2				endif 
03f2 cd bf 09				call storage_read 
03f5 cd f9 0f				call ishlzero 
03f8 28 2d				jr z, .gap 
03fa					 
03fa					; have a file name read. Is it one we want. 
03fa			 
03fa 2a 70 fa				ld hl, (store_tmp1) 
03fd 11 7a fa				ld de, store_page+3   ; file name 
0400			 
0400				if DEBUG_STORESE 
0400					DMARK "SGc" 
0400 f5				push af  
0401 3a 15 04			ld a, (.dmark)  
0404 32 68 fe			ld (debug_mark),a  
0407 3a 16 04			ld a, (.dmark+1)  
040a 32 69 fe			ld (debug_mark+1),a  
040d 3a 17 04			ld a, (.dmark+2)  
0410 32 6a fe			ld (debug_mark+2),a  
0413 18 03			jr .pastdmark  
0415 ..			.dmark: db "SGc"  
0418 f1			.pastdmark: pop af  
0419			endm  
# End of macro DMARK
0419					CALLMONITOR 
0419 cd 6c fe			call debug_vector  
041c				endm  
# End of macro CALLMONITOR
041c				endif 
041c cd 66 14				call strcmp 
041f 20 06				jr nz, .gap   ; not this one 
0421			 
0421 c1				        pop bc 
0422			 
0422 26 00				ld h, 0 
0424 68					ld l, b 
0425 18 22				jr .getdone 
0427						 
0427			 
0427			 
0427			 
0427			.gap: 
0427				if DEBUG_STORESE 
0427					DMARK "SGg" 
0427 f5				push af  
0428 3a 3c 04			ld a, (.dmark)  
042b 32 68 fe			ld (debug_mark),a  
042e 3a 3d 04			ld a, (.dmark+1)  
0431 32 69 fe			ld (debug_mark+1),a  
0434 3a 3e 04			ld a, (.dmark+2)  
0437 32 6a fe			ld (debug_mark+2),a  
043a 18 03			jr .pastdmark  
043c ..			.dmark: db "SGg"  
043f f1			.pastdmark: pop af  
0440			endm  
# End of macro DMARK
0440					CALLMONITOR 
0440 cd 6c fe			call debug_vector  
0443				endm  
# End of macro CALLMONITOR
0443				endif 
0443			 
0443 c1					pop bc 
0444 10 89				djnz .getloop 
0446 21 ff 00				ld hl, 255 
0449			.getdone: 
0449			 
0449				if DEBUG_STORESE 
0449					DMARK "SGe" 
0449 f5				push af  
044a 3a 5e 04			ld a, (.dmark)  
044d 32 68 fe			ld (debug_mark),a  
0450 3a 5f 04			ld a, (.dmark+1)  
0453 32 69 fe			ld (debug_mark+1),a  
0456 3a 60 04			ld a, (.dmark+2)  
0459 32 6a fe			ld (debug_mark+2),a  
045c 18 03			jr .pastdmark  
045e ..			.dmark: db "SGe"  
0461 f1			.pastdmark: pop af  
0462			endm  
# End of macro DMARK
0462					CALLMONITOR 
0462 cd 6c fe			call debug_vector  
0465				endm  
# End of macro CALLMONITOR
0465				endif 
0465			 
0465 c9				ret 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			; Read Block 
0466			; ---------- 
0466			; 
0466			; With current bank 
0466			;  
0466			; Get block number to read 
0466			; Load physical blocks starting at start block into buffer 
0466			 
0466			; de points to buffer to use 
0466			; hl holds logical block number  
0466			 
0466			storage_read_block: 
0466			 
0466				; TODO bank selection 
0466			 
0466				; for each of the physical blocks read it into the buffer 
0466 06 40			ld b, STORE_BLOCK_PHY 
0468			 
0468				if DEBUG_STORESE 
0468 d5					push de 
0469				endif 
0469				 
0469			.rl1:    
0469			 
0469				; read physical block at hl into de 
0469			        ; increment hl and de to next read position on exit 
0469			 
0469 e5				push hl 
046a d5				push de	 
046b c5				push bc 
046c			;	if DEBUG_STORESE 
046c			;		push af 
046c			;		ld a, 'R' 
046c			;		ld (debug_mark),a 
046c			;		pop af 
046c			;		CALLMONITOR 
046c			;	endif 
046c cd 0d 03			call se_readbyte 
046f			;	if DEBUG_STORESE 
046f			;		ld a,(spi_portbyte) 
046f			;		ld l, a 
046f			;		push af 
046f			;		ld a, '1' 
046f			;		ld (debug_mark),a 
046f			;		pop af 
046f			;		CALLMONITOR 
046f			;	endif 
046f c1				pop bc 
0470 d1				pop de 
0471 e1				pop hl 
0472 12				ld (de),a 
0473 23				inc hl 
0474 13				inc de 
0475			 
0475			;	if DEBUG_STORESE 
0475			;		push af 
0475			;		ld a, 'r' 
0475			;		ld (debug_mark),a 
0475			;		pop af 
0475			;		CALLMONITOR 
0475			;	endif 
0475			 
0475 10 f2			djnz .rl1 
0477			 
0477				if DEBUG_STORESE 
0477					DMARK "SRB" 
0477 f5				push af  
0478 3a 8c 04			ld a, (.dmark)  
047b 32 68 fe			ld (debug_mark),a  
047e 3a 8d 04			ld a, (.dmark+1)  
0481 32 69 fe			ld (debug_mark+1),a  
0484 3a 8e 04			ld a, (.dmark+2)  
0487 32 6a fe			ld (debug_mark+2),a  
048a 18 03			jr .pastdmark  
048c ..			.dmark: db "SRB"  
048f f1			.pastdmark: pop af  
0490			endm  
# End of macro DMARK
0490 d1					pop de 
0491			; 
0491			;		push af 
0491			;		ld a, 'R' 
0491			;		ld (debug_mark),a 
0491			;		pop af 
0491					CALLMONITOR 
0491 cd 6c fe			call debug_vector  
0494				endm  
# End of macro CALLMONITOR
0494				endif 
0494 c9				ret	 
0495				 
0495			 
0495			; File Size 
0495			; --------- 
0495			; 
0495			;   hl file id 
0495			; 
0495			;  returns in hl the number of blocks 
0495			 
0495			storage_file_size: 
0495 5d				ld e, l 
0496 16 00			ld d, 0 
0498 21 40 00			ld hl, STORE_BLOCK_PHY 
049b					if DEBUG_FORTH_WORDS 
049b						DMARK "SIZ" 
049b f5				push af  
049c 3a b0 04			ld a, (.dmark)  
049f 32 68 fe			ld (debug_mark),a  
04a2 3a b1 04			ld a, (.dmark+1)  
04a5 32 69 fe			ld (debug_mark+1),a  
04a8 3a b2 04			ld a, (.dmark+2)  
04ab 32 6a fe			ld (debug_mark+2),a  
04ae 18 03			jr .pastdmark  
04b0 ..			.dmark: db "SIZ"  
04b3 f1			.pastdmark: pop af  
04b4			endm  
# End of macro DMARK
04b4						CALLMONITOR 
04b4 cd 6c fe			call debug_vector  
04b7				endm  
# End of macro CALLMONITOR
04b7					endif 
04b7 cd 99 07			call storage_findnextid 
04ba			 
04ba cd f9 0f			call ishlzero 
04bd			;	ld a, l 
04bd			;	add h 
04bd			;	cp 0 
04bd c8				ret z			; block not found so EOF 
04be			 
04be 11 77 fa			ld de, store_page 
04c1 cd 66 04			call storage_read_block 
04c4			 
04c4 3a 79 fa			ld a, (store_page+2)	 ; get extent count 
04c7 6f				ld l, a 
04c8 26 00			ld h, 0 
04ca c9			 	ret 
04cb			 
04cb			 
04cb			; Write Block 
04cb			; ----------- 
04cb			; 
04cb			; With current bank 
04cb			;  
04cb			; Get block number to write 
04cb			; Write physical blocks starting at start block from buffer 
04cb			  
04cb			storage_write_block: 
04cb				; TODO bank selection 
04cb			 
04cb				; for each of the physical blocks read it into the buffer 
04cb 06 40			ld b, STORE_BLOCK_PHY 
04cd			 
04cd				if DEBUG_STORESE 
04cd					DMARK "SWB" 
04cd f5				push af  
04ce 3a e2 04			ld a, (.dmark)  
04d1 32 68 fe			ld (debug_mark),a  
04d4 3a e3 04			ld a, (.dmark+1)  
04d7 32 69 fe			ld (debug_mark+1),a  
04da 3a e4 04			ld a, (.dmark+2)  
04dd 32 6a fe			ld (debug_mark+2),a  
04e0 18 03			jr .pastdmark  
04e2 ..			.dmark: db "SWB"  
04e5 f1			.pastdmark: pop af  
04e6			endm  
# End of macro DMARK
04e6			 
04e6					;push af 
04e6					;ld a, 'W' 
04e6					;ld (debug_mark),a 
04e6					;pop af 
04e6					CALLMONITOR 
04e6 cd 6c fe			call debug_vector  
04e9				endm  
# End of macro CALLMONITOR
04e9				endif 
04e9			 
04e9			; might not be working 
04e9			;	call se_writepage 
04e9			 
04e9			;	ret 
04e9			; 
04e9			 
04e9			 
04e9			 
04e9			.wl1:    
04e9			 
04e9				; read physical block at hl into de 
04e9			        ; increment hl and de to next read position on exit 
04e9			 
04e9 e5				push hl 
04ea d5				push de	 
04eb c5				push bc 
04ec 1a				ld a,(de) 
04ed				;if DEBUG_STORESE 
04ed			;		push af 
04ed			;		ld a, 'W' 
04ed			;		ld (debug_mark),a 
04ed			;		pop af 
04ed			;		CALLMONITOR 
04ed			;	endif 
04ed cd 6b 02			call se_writebyte 
04f0			;	call delay250ms 
04f0 00				nop 
04f1 00				nop 
04f2 00				nop 
04f3			;	if DEBUG_STORESE 
04f3			;		push af 
04f3			;		ld a, 'w' 
04f3			;		ld (debug_mark),a 
04f3			;		pop af 
04f3			;		CALLMONITOR 
04f3			;	endif 
04f3 c1				pop bc 
04f4 d1				pop de 
04f5 e1				pop hl 
04f6 23				inc hl 
04f7 13				inc de 
04f8			 
04f8			 
04f8 10 ef			djnz .wl1 
04fa			 
04fa				if DEBUG_STORESE 
04fa					DMARK "SW2" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 68 fe			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 69 fe			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 6a fe			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "SW2"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513			 
0513					;push af 
0513					;ld a, 'W' 
0513					;ld (debug_mark),a 
0513					;pop af 
0513					CALLMONITOR 
0513 cd 6c fe			call debug_vector  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 c9				ret	 
0517			 
0517			; Init bank 
0517			; --------- 
0517			; 
0517			; With current bank 
0517			; 
0517			; Setup block 0 config 
0517			;     Set 0 file id counter 
0517			;     Set formatted byte pattern 
0517			;     Zero out bank label 
0517			;      
0517			; For every logical block write 0-1 byte as null 
0517			 
0517			storage_get_block_0: 
0517			 
0517				; TODO check presence 
0517			 
0517				; get block 0 config 
0517			 
0517 21 00 00			ld hl, 0 
051a 11 77 fa			ld de, store_page 
051d cd 66 04			call storage_read_block 
0520			 
0520				if DEBUG_STORESE 
0520					DMARK "SB0" 
0520 f5				push af  
0521 3a 35 05			ld a, (.dmark)  
0524 32 68 fe			ld (debug_mark),a  
0527 3a 36 05			ld a, (.dmark+1)  
052a 32 69 fe			ld (debug_mark+1),a  
052d 3a 37 05			ld a, (.dmark+2)  
0530 32 6a fe			ld (debug_mark+2),a  
0533 18 03			jr .pastdmark  
0535 ..			.dmark: db "SB0"  
0538 f1			.pastdmark: pop af  
0539			endm  
# End of macro DMARK
0539 11 77 fa				ld de, store_page 
053c			;		push af 
053c			;		ld a, 'i' 
053c			;		ld (debug_mark),a 
053c			;		pop af 
053c					CALLMONITOR 
053c cd 6c fe			call debug_vector  
053f				endm  
# End of macro CALLMONITOR
053f				endif 
053f			 
053f				; is this area formatted? 
053f			 
053f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053f 2a 78 fa			ld hl, (store_page+1) 
0542 3e 80			ld a,0x80 
0544 bd				cp l 
0545 20 22			jr nz, .ininotformatted 
0547				; do a double check 
0547 3e 27			ld a, 0x27 
0549 bc				cp h 
054a 20 1d			jr nz, .ininotformatted 
054c			 
054c				; formatted then 
054c			 
054c				if DEBUG_STORESE 
054c					DMARK "SB1" 
054c f5				push af  
054d 3a 61 05			ld a, (.dmark)  
0550 32 68 fe			ld (debug_mark),a  
0553 3a 62 05			ld a, (.dmark+1)  
0556 32 69 fe			ld (debug_mark+1),a  
0559 3a 63 05			ld a, (.dmark+2)  
055c 32 6a fe			ld (debug_mark+2),a  
055f 18 03			jr .pastdmark  
0561 ..			.dmark: db "SB1"  
0564 f1			.pastdmark: pop af  
0565			endm  
# End of macro DMARK
0565					;push af 
0565					;ld a, 'I' 
0565					;ld (debug_mark),a 
0565					;pop af 
0565					CALLMONITOR 
0565 cd 6c fe			call debug_vector  
0568				endm  
# End of macro CALLMONITOR
0568				endif 
0568 c9				ret 
0569			 
0569			.ininotformatted: 
0569				; bank not formatted so poke various bits to make sure 
0569			 
0569				if DEBUG_STORESE 
0569					DMARK "SB2" 
0569 f5				push af  
056a 3a 7e 05			ld a, (.dmark)  
056d 32 68 fe			ld (debug_mark),a  
0570 3a 7f 05			ld a, (.dmark+1)  
0573 32 69 fe			ld (debug_mark+1),a  
0576 3a 80 05			ld a, (.dmark+2)  
0579 32 6a fe			ld (debug_mark+2),a  
057c 18 03			jr .pastdmark  
057e ..			.dmark: db "SB2"  
0581 f1			.pastdmark: pop af  
0582			endm  
# End of macro DMARK
0582					;push af 
0582					;ld a, 'f' 
0582					;ld (debug_mark),a 
0582					;pop af 
0582					CALLMONITOR 
0582 cd 6c fe			call debug_vector  
0585				endm  
# End of macro CALLMONITOR
0585				endif 
0585			 
0585 cd a2 0c			call storage_clear_page 
0588			 
0588 21 77 fa			ld hl, store_page 
058b 3e 00			ld a, 0 
058d				 
058d 77				ld (hl),a   ; reset file counter 
058e			 
058e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0591 22 78 fa		 	ld (store_page+1), hl	 
0594			 
0594				; set default label 
0594			 
0594 21 30 06			ld hl, .defaultbanklabl 
0597 11 7a fa		 	ld de, store_page+3 
059a 01 0f 00			ld bc, 15 
059d ed b0			ldir 
059f			 
059f				; Append the current bank id 
059f 21 83 fa			ld hl, store_page+3+9 
05a2 3a 5c fa			ld a, (spi_device_id) 
05a5 77				ld (hl), a 
05a6			 
05a6				; save default page 0 
05a6			 
05a6 21 00 00			ld hl, 0 
05a9 11 77 fa			ld de, store_page 
05ac				if DEBUG_STORESE 
05ac					DMARK "SB3" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 68 fe			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 69 fe			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 6a fe			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "SB3"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5			;		push af 
05c5			;		ld a, 'F' 
05c5			;		ld (debug_mark),a 
05c5			;		pop af 
05c5					CALLMONITOR 
05c5 cd 6c fe			call debug_vector  
05c8				endm  
# End of macro CALLMONITOR
05c8				endif 
05c8 cd cb 04			call storage_write_block 
05cb				if DEBUG_STORESE 
05cb					DMARK "SB4" 
05cb f5				push af  
05cc 3a e0 05			ld a, (.dmark)  
05cf 32 68 fe			ld (debug_mark),a  
05d2 3a e1 05			ld a, (.dmark+1)  
05d5 32 69 fe			ld (debug_mark+1),a  
05d8 3a e2 05			ld a, (.dmark+2)  
05db 32 6a fe			ld (debug_mark+2),a  
05de 18 03			jr .pastdmark  
05e0 ..			.dmark: db "SB4"  
05e3 f1			.pastdmark: pop af  
05e4			endm  
# End of macro DMARK
05e4			;		push af 
05e4			;		ld a, '>' 
05e4			;		ld (debug_mark),a 
05e4			;		pop af 
05e4					CALLMONITOR 
05e4 cd 6c fe			call debug_vector  
05e7				endm  
# End of macro CALLMONITOR
05e7				endif 
05e7			 
05e7 00				nop 
05e8 00				nop 
05e9 00				nop 
05ea			 
05ea				; now set 0 in every page to mark as a free block 
05ea			 
05ea 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ec 21 40 00			ld hl, STORE_BLOCK_PHY 
05ef			 
05ef 3e 00		.setmark1:   	ld a,0 
05f1 e5					push hl 
05f2 c5					push bc 
05f3 cd 6b 02				call se_writebyte 
05f6 3e 0a			ld a, 10 
05f8 cd c4 0c			call aDelayInMS 
05fb 23				inc hl 
05fc cd 6b 02				call se_writebyte 
05ff 3e 0a			ld a, 10 
0601 cd c4 0c			call aDelayInMS 
0604 2b				dec hl 
0605 c1					pop bc 
0606 e1					pop hl 
0607 3e 40				ld a, STORE_BLOCK_PHY 
0609 cd d0 0f				call addatohl 
060c 10 e1				djnz .setmark1 
060e			 
060e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0610 3e 00		.setmark2:   	ld a,0 
0612 e5					push hl 
0613 c5					push bc 
0614 cd 6b 02				call se_writebyte 
0617 3e 0a			ld a, 10 
0619 cd c4 0c			call aDelayInMS 
061c 23				inc hl 
061d cd 6b 02				call se_writebyte 
0620 3e 0a			ld a, 10 
0622 cd c4 0c			call aDelayInMS 
0625 2b				dec hl 
0626 c1					pop bc 
0627 e1					pop hl 
0628 3e 40				ld a, STORE_BLOCK_PHY 
062a cd d0 0f				call addatohl 
062d 10 e1				djnz .setmark2 
062f			 
062f					 
062f			 
062f			 
062f c9				ret 
0630			 
0630			 
0630			 
0630			 
0630 .. 00		.defaultbanklabl:   db "BankLabel_",0 
063b			 
063b			 
063b			 
063b			; Label Bank 
063b			; ---------- 
063b			; 
063b			; With current bank 
063b			; Read block 0 
063b			; Set label 
063b			; Write block 0 
063b			 
063b			; label str pointer in hl 
063b			 
063b			storage_label:     
063b			 
063b				if DEBUG_STORESE 
063b					DMARK "LBL" 
063b f5				push af  
063c 3a 50 06			ld a, (.dmark)  
063f 32 68 fe			ld (debug_mark),a  
0642 3a 51 06			ld a, (.dmark+1)  
0645 32 69 fe			ld (debug_mark+1),a  
0648 3a 52 06			ld a, (.dmark+2)  
064b 32 6a fe			ld (debug_mark+2),a  
064e 18 03			jr .pastdmark  
0650 ..			.dmark: db "LBL"  
0653 f1			.pastdmark: pop af  
0654			endm  
# End of macro DMARK
0654					CALLMONITOR 
0654 cd 6c fe			call debug_vector  
0657				endm  
# End of macro CALLMONITOR
0657				endif 
0657			 
0657 e5				push hl 
0658			 
0658 cd 17 05			call storage_get_block_0 
065b			 
065b				; set default label 
065b			 
065b e1				pop hl 
065c			 
065c 11 7a fa		 	ld de, store_page+3 
065f 01 0f 00			ld bc, 15 
0662				if DEBUG_STORESE 
0662					DMARK "LB3" 
0662 f5				push af  
0663 3a 77 06			ld a, (.dmark)  
0666 32 68 fe			ld (debug_mark),a  
0669 3a 78 06			ld a, (.dmark+1)  
066c 32 69 fe			ld (debug_mark+1),a  
066f 3a 79 06			ld a, (.dmark+2)  
0672 32 6a fe			ld (debug_mark+2),a  
0675 18 03			jr .pastdmark  
0677 ..			.dmark: db "LB3"  
067a f1			.pastdmark: pop af  
067b			endm  
# End of macro DMARK
067b					CALLMONITOR 
067b cd 6c fe			call debug_vector  
067e				endm  
# End of macro CALLMONITOR
067e				endif 
067e ed b0			ldir 
0680				; save default page 0 
0680			 
0680 21 00 00			ld hl, 0 
0683 11 77 fa			ld de, store_page 
0686				if DEBUG_STORESE 
0686					DMARK "LBW" 
0686 f5				push af  
0687 3a 9b 06			ld a, (.dmark)  
068a 32 68 fe			ld (debug_mark),a  
068d 3a 9c 06			ld a, (.dmark+1)  
0690 32 69 fe			ld (debug_mark+1),a  
0693 3a 9d 06			ld a, (.dmark+2)  
0696 32 6a fe			ld (debug_mark+2),a  
0699 18 03			jr .pastdmark  
069b ..			.dmark: db "LBW"  
069e f1			.pastdmark: pop af  
069f			endm  
# End of macro DMARK
069f					CALLMONITOR 
069f cd 6c fe			call debug_vector  
06a2				endm  
# End of macro CALLMONITOR
06a2				endif 
06a2 cd cb 04			call storage_write_block 
06a5			 
06a5 c9				ret 
06a6			 
06a6			 
06a6			 
06a6			; Read Block 0 - Config 
06a6			; --------------------- 
06a6			; 
06a6			; With current bank 
06a6			; Call presence test 
06a6			;    If not present format/init bank  
06a6			; Read block 0  
06a6			;  
06a6			 
06a6			 
06a6			; Dir 
06a6			; --- 
06a6			; 
06a6			; With current bank 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block read byte 2 
06a6			;      if first block of file 
06a6			;         Display file name 
06a6			;         Display type flags for file 
06a6			;        
06a6			 
06a6			; moving to words as this requires stack control 
06a6			 
06a6			 
06a6			; Delete File 
06a6			; ----------- 
06a6			; 
06a6			; With current bank 
06a6			; 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block file id 
06a6			;      If first block of file and dont have file id 
06a6			;         if file to delete 
06a6			;         Save file id 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			;      If file id is one saved 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			 
06a6			 
06a6			.se_done: 
06a6 e1				pop hl 
06a7 c9				ret 
06a8			 
06a8			storage_erase: 
06a8			 
06a8				; hl contains the file id 
06a8			 
06a8 5d				ld e, l 
06a9 16 00			ld d, 0 
06ab 21 40 00			ld hl, STORE_BLOCK_PHY 
06ae					if DEBUG_FORTH_WORDS 
06ae						DMARK "ERA" 
06ae f5				push af  
06af 3a c3 06			ld a, (.dmark)  
06b2 32 68 fe			ld (debug_mark),a  
06b5 3a c4 06			ld a, (.dmark+1)  
06b8 32 69 fe			ld (debug_mark+1),a  
06bb 3a c5 06			ld a, (.dmark+2)  
06be 32 6a fe			ld (debug_mark+2),a  
06c1 18 03			jr .pastdmark  
06c3 ..			.dmark: db "ERA"  
06c6 f1			.pastdmark: pop af  
06c7			endm  
# End of macro DMARK
06c7						CALLMONITOR 
06c7 cd 6c fe			call debug_vector  
06ca				endm  
# End of macro CALLMONITOR
06ca					endif 
06ca cd 99 07			call storage_findnextid 
06cd cd f9 0f			call ishlzero 
06d0 c8				ret z 
06d1			 
06d1 e5				push hl 
06d2			 
06d2				; TODO check file not found 
06d2			 
06d2 11 77 fa			ld de, store_page 
06d5 cd 66 04			call storage_read_block 
06d8			 
06d8 cd f9 0f			call ishlzero 
06db ca a6 06			jp z,.se_done 
06de			 
06de					if DEBUG_FORTH_WORDS 
06de						DMARK "ER1" 
06de f5				push af  
06df 3a f3 06			ld a, (.dmark)  
06e2 32 68 fe			ld (debug_mark),a  
06e5 3a f4 06			ld a, (.dmark+1)  
06e8 32 69 fe			ld (debug_mark+1),a  
06eb 3a f5 06			ld a, (.dmark+2)  
06ee 32 6a fe			ld (debug_mark+2),a  
06f1 18 03			jr .pastdmark  
06f3 ..			.dmark: db "ER1"  
06f6 f1			.pastdmark: pop af  
06f7			endm  
# End of macro DMARK
06f7						CALLMONITOR 
06f7 cd 6c fe			call debug_vector  
06fa				endm  
# End of macro CALLMONITOR
06fa					endif 
06fa 3a 77 fa			ld a, (store_page)	; get file id 
06fd 32 6b fa			ld (store_tmpid), a 
0700			 
0700 3a 79 fa			ld a, (store_page+2)    ; get count of extends 
0703 32 6a fa			ld (store_tmpext), a 
0706			 
0706				; wipe file header 
0706			 
0706 e1				pop hl 
0707 3e 00			ld a, 0 
0709 32 77 fa			ld (store_page), a 
070c 32 78 fa			ld (store_page+1),a 
070f 11 77 fa			ld de, store_page 
0712					if DEBUG_FORTH_WORDS 
0712						DMARK "ER2" 
0712 f5				push af  
0713 3a 27 07			ld a, (.dmark)  
0716 32 68 fe			ld (debug_mark),a  
0719 3a 28 07			ld a, (.dmark+1)  
071c 32 69 fe			ld (debug_mark+1),a  
071f 3a 29 07			ld a, (.dmark+2)  
0722 32 6a fe			ld (debug_mark+2),a  
0725 18 03			jr .pastdmark  
0727 ..			.dmark: db "ER2"  
072a f1			.pastdmark: pop af  
072b			endm  
# End of macro DMARK
072b						CALLMONITOR 
072b cd 6c fe			call debug_vector  
072e				endm  
# End of macro CALLMONITOR
072e					endif 
072e cd cb 04			call storage_write_block 
0731			 
0731			 
0731				; wipe file extents 
0731			 
0731 3a 6a fa			ld a, (store_tmpext) 
0734 47				ld b, a 
0735			 
0735			.eraext:	  
0735 c5				push bc 
0736			 
0736 21 40 00			ld hl, STORE_BLOCK_PHY 
0739 3a 6b fa			ld a,(store_tmpid) 
073c 5f				ld e, a 
073d 50				ld d, b	 
073e					if DEBUG_FORTH_WORDS 
073e						DMARK "ER3" 
073e f5				push af  
073f 3a 53 07			ld a, (.dmark)  
0742 32 68 fe			ld (debug_mark),a  
0745 3a 54 07			ld a, (.dmark+1)  
0748 32 69 fe			ld (debug_mark+1),a  
074b 3a 55 07			ld a, (.dmark+2)  
074e 32 6a fe			ld (debug_mark+2),a  
0751 18 03			jr .pastdmark  
0753 ..			.dmark: db "ER3"  
0756 f1			.pastdmark: pop af  
0757			endm  
# End of macro DMARK
0757						CALLMONITOR 
0757 cd 6c fe			call debug_vector  
075a				endm  
# End of macro CALLMONITOR
075a					endif 
075a cd 99 07			call storage_findnextid 
075d cd f9 0f			call ishlzero 
0760 ca a6 06			jp z,.se_done 
0763			 
0763 e5				push hl 
0764 11 77 fa			ld de, store_page 
0767 cd 66 04			call storage_read_block 
076a			 
076a				; free block	 
076a			 
076a 3e 00			ld a, 0 
076c 32 77 fa			ld (store_page), a 
076f 32 78 fa			ld (store_page+1),a 
0772 11 77 fa			ld de, store_page 
0775 e1				pop hl 
0776					if DEBUG_FORTH_WORDS 
0776						DMARK "ER4" 
0776 f5				push af  
0777 3a 8b 07			ld a, (.dmark)  
077a 32 68 fe			ld (debug_mark),a  
077d 3a 8c 07			ld a, (.dmark+1)  
0780 32 69 fe			ld (debug_mark+1),a  
0783 3a 8d 07			ld a, (.dmark+2)  
0786 32 6a fe			ld (debug_mark+2),a  
0789 18 03			jr .pastdmark  
078b ..			.dmark: db "ER4"  
078e f1			.pastdmark: pop af  
078f			endm  
# End of macro DMARK
078f						CALLMONITOR 
078f cd 6c fe			call debug_vector  
0792				endm  
# End of macro CALLMONITOR
0792					endif 
0792 cd cb 04			call storage_write_block 
0795			 
0795 c1				pop bc 
0796 10 9d			djnz .eraext 
0798			 
0798 c9				ret 
0799			 
0799			 
0799			; Find Free Block 
0799			; --------------- 
0799			; 
0799			; With current bank 
0799			;  
0799			; From given starting logical block 
0799			;    Read block  
0799			;    If no file id 
0799			;         Return block id 
0799			 
0799			 
0799			; hl starting page number 
0799			; hl contains free page number or zero if no pages free 
0799			; e contains the file id to locate 
0799			; d contains the block number 
0799			 
0799			; TODO change to find file id and use zero for free block 
0799			 
0799			storage_findnextid: 
0799			 
0799				; now locate first 0 page to mark as a free block 
0799			 
0799 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079b			;	ld hl, STORE_BLOCK_PHY 
079b			 
079b					if DEBUG_FORTH_WORDS 
079b					DMARK "FNI" 
079b f5				push af  
079c 3a b0 07			ld a, (.dmark)  
079f 32 68 fe			ld (debug_mark),a  
07a2 3a b1 07			ld a, (.dmark+1)  
07a5 32 69 fe			ld (debug_mark+1),a  
07a8 3a b2 07			ld a, (.dmark+2)  
07ab 32 6a fe			ld (debug_mark+2),a  
07ae 18 03			jr .pastdmark  
07b0 ..			.dmark: db "FNI"  
07b3 f1			.pastdmark: pop af  
07b4			endm  
# End of macro DMARK
07b4						CALLMONITOR 
07b4 cd 6c fe			call debug_vector  
07b7				endm  
# End of macro CALLMONITOR
07b7					endif 
07b7			.ff1:   	 
07b7 e5					push hl 
07b8 c5					push bc 
07b9 d5					push de 
07ba cd 0d 03				call se_readbyte 
07bd 5f					ld e,a 
07be 23					inc hl 
07bf cd 0d 03				call se_readbyte 
07c2 57					ld d, a 
07c3 e1					pop hl 
07c4 e5					push hl 
07c5 cd ee 0f				call cmp16 
07c8 28 49				jr z, .fffound 
07ca			 
07ca d1					pop de 
07cb c1					pop bc 
07cc e1					pop hl 
07cd			 
07cd					; is found? 
07cd					;cp e 
07cd					;ret z 
07cd			 
07cd 3e 40				ld a, STORE_BLOCK_PHY 
07cf cd d0 0f				call addatohl 
07d2 10 e3				djnz .ff1 
07d4			 
07d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d6			.ff2:   	 
07d6			 
07d6 e5					push hl 
07d7 c5					push bc 
07d8 d5					push de 
07d9 cd 0d 03				call se_readbyte 
07dc 5f					ld e,a 
07dd 23					inc hl 
07de cd 0d 03				call se_readbyte 
07e1 57					ld d, a 
07e2			 
07e2 e1					pop hl 
07e3 e5					push hl 
07e4 cd ee 0f				call cmp16 
07e7 28 2a				jr z, .fffound 
07e9			 
07e9 d1					pop de 
07ea c1					pop bc 
07eb e1					pop hl 
07ec					; is found? 
07ec					;cp e 
07ec					;ret z 
07ec			 
07ec 3e 40				ld a, STORE_BLOCK_PHY 
07ee cd d0 0f				call addatohl 
07f1 10 e3				djnz .ff2 
07f3			 
07f3			 
07f3					if DEBUG_FORTH_WORDS 
07f3					DMARK "FN-" 
07f3 f5				push af  
07f4 3a 08 08			ld a, (.dmark)  
07f7 32 68 fe			ld (debug_mark),a  
07fa 3a 09 08			ld a, (.dmark+1)  
07fd 32 69 fe			ld (debug_mark+1),a  
0800 3a 0a 08			ld a, (.dmark+2)  
0803 32 6a fe			ld (debug_mark+2),a  
0806 18 03			jr .pastdmark  
0808 ..			.dmark: db "FN-"  
080b f1			.pastdmark: pop af  
080c			endm  
# End of macro DMARK
080c					;	push af 
080c					;	ld a, 'n' 
080c					;	ld (debug_mark),a 
080c					;	pop af 
080c						CALLMONITOR 
080c cd 6c fe			call debug_vector  
080f				endm  
# End of macro CALLMONITOR
080f					endif 
080f				; no free marks! 
080f 21 00 00				ld hl, 0 
0812 c9				ret 
0813			.fffound: 
0813				 
0813			 
0813 d1					pop de 
0814 c1					pop bc 
0815 e1					pop hl 
0816					if DEBUG_FORTH_WORDS 
0816					DMARK "FNF" 
0816 f5				push af  
0817 3a 2b 08			ld a, (.dmark)  
081a 32 68 fe			ld (debug_mark),a  
081d 3a 2c 08			ld a, (.dmark+1)  
0820 32 69 fe			ld (debug_mark+1),a  
0823 3a 2d 08			ld a, (.dmark+2)  
0826 32 6a fe			ld (debug_mark+2),a  
0829 18 03			jr .pastdmark  
082b ..			.dmark: db "FNF"  
082e f1			.pastdmark: pop af  
082f			endm  
# End of macro DMARK
082f					;	push af 
082f					;	ld a, 'n' 
082f					;	ld (debug_mark),a 
082f					;	pop af 
082f						CALLMONITOR 
082f cd 6c fe			call debug_vector  
0832				endm  
# End of macro CALLMONITOR
0832					endif 
0832 c9				ret 
0833			 
0833			 
0833			 
0833			; Free Space 
0833			; ---------- 
0833			; 
0833			; With current bank 
0833			; 
0833			; Set block count to zero 
0833			; Starting with first logical block 
0833			;      Find free block  
0833			;      If block id given, increment block count 
0833			; 
0833			;  
0833			 
0833			 
0833			; hl contains count of free blocks 
0833			 
0833			storage_freeblocks: 
0833			 
0833				; now locate first 0 page to mark as a free block 
0833			 
0833 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0835 21 40 00			ld hl, STORE_BLOCK_PHY 
0838 11 00 00			ld de, 0 
083b			 
083b			.fb1:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd 0d 03				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844 fe 00				cp 0 
0846 20 01				jr nz, .ff1cont 
0848 13					inc de 
0849			 
0849			.ff1cont: 
0849			 
0849			 
0849 3e 40				ld a, STORE_BLOCK_PHY 
084b cd d0 0f				call addatohl 
084e 10 eb				djnz .fb1 
0850			 
0850 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0852			.fb2:   	 
0852 e5					push hl 
0853 c5					push bc 
0854 d5					push de 
0855 cd 0d 03				call se_readbyte 
0858 d1					pop de 
0859 c1					pop bc 
085a e1					pop hl 
085b			 
085b					; is free? 
085b fe 00				cp 0 
085d 20 01				jr nz, .ff2cont 
085f 13					inc de 
0860			 
0860			.ff2cont: 
0860			 
0860 3e 40				ld a, STORE_BLOCK_PHY 
0862 cd d0 0f				call addatohl 
0865 10 eb				djnz .fb2 
0867			 
0867 eb				ex de, hl 
0868 c9				ret 
0869			 
0869			; Get File ID 
0869			; ----------- 
0869			; 
0869			; With current bank 
0869			;  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; For each logical block 
0869			;    Read block file id 
0869			;      If first block of file and dont have file id 
0869			;         if file get id and exit 
0869			 
0869			 
0869			 
0869			 
0869			; Create File 
0869			; ----------- 
0869			; 
0869			; With current bank  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; Increment file id number 
0869			; Save Config 
0869			; Find free block 
0869			; Set buffer with file name and file id 
0869			; Write buffer to free block  
0869			 
0869			 
0869			; hl point to file name 
0869			; hl returns file id 
0869			 
0869			; file format: 
0869			; byte 0 - file id 
0869			; byte 1 - extent number 
0869			; byte 2-> data 
0869			 
0869			; format for extent number 0: 
0869			; 
0869			; byte 0 - file id 
0869			; byte 1 - extent 0 
0869			; byte 2 - extent count 
0869			; byte 3 -> file name and meta data 
0869			 
0869			 
0869			storage_create: 
0869				if DEBUG_STORESE 
0869					DMARK "SCR" 
0869 f5				push af  
086a 3a 7e 08			ld a, (.dmark)  
086d 32 68 fe			ld (debug_mark),a  
0870 3a 7f 08			ld a, (.dmark+1)  
0873 32 69 fe			ld (debug_mark+1),a  
0876 3a 80 08			ld a, (.dmark+2)  
0879 32 6a fe			ld (debug_mark+2),a  
087c 18 03			jr .pastdmark  
087e ..			.dmark: db "SCR"  
0881 f1			.pastdmark: pop af  
0882			endm  
# End of macro DMARK
0882					CALLMONITOR 
0882 cd 6c fe			call debug_vector  
0885				endm  
# End of macro CALLMONITOR
0885				endif 
0885			 
0885 e5				push hl		; save file name pointer 
0886			 
0886 cd 17 05			call storage_get_block_0 
0889			 
0889 3a 77 fa			ld a,(store_page)	; get current file id 
088c 3c				inc a 
088d 32 77 fa			ld (store_page),a 
0890				 
0890 32 6b fa			ld (store_tmpid),a			; save id 
0893			 
0893 21 00 00			ld hl, 0 
0896 11 77 fa			ld de, store_page 
0899				if DEBUG_STORESE 
0899					DMARK "SCw" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 68 fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 69 fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 6a fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCw"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 6c fe			call debug_vector  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5 cd cb 04			call storage_write_block	 ; save update 
08b8			 
08b8				if DEBUG_STORESE 
08b8 11 77 fa				ld de, store_page 
08bb					DMARK "SCC" 
08bb f5				push af  
08bc 3a d0 08			ld a, (.dmark)  
08bf 32 68 fe			ld (debug_mark),a  
08c2 3a d1 08			ld a, (.dmark+1)  
08c5 32 69 fe			ld (debug_mark+1),a  
08c8 3a d2 08			ld a, (.dmark+2)  
08cb 32 6a fe			ld (debug_mark+2),a  
08ce 18 03			jr .pastdmark  
08d0 ..			.dmark: db "SCC"  
08d3 f1			.pastdmark: pop af  
08d4			endm  
# End of macro DMARK
08d4					CALLMONITOR 
08d4 cd 6c fe			call debug_vector  
08d7				endm  
# End of macro CALLMONITOR
08d7				endif 
08d7				;  
08d7				 
08d7 21 40 00			ld hl, STORE_BLOCK_PHY 
08da 11 00 00			ld de, 0 
08dd cd 99 07			call storage_findnextid 
08e0			 
08e0 22 62 fa			ld (store_tmppageid), hl    ; save page to use  
08e3			 
08e3				; TODO detect 0 = no spare blocks 
08e3			 
08e3				; hl now contains the free page to use for the file header page 
08e3			 
08e3				if DEBUG_STORESE 
08e3				DMARK "SCF" 
08e3 f5				push af  
08e4 3a f8 08			ld a, (.dmark)  
08e7 32 68 fe			ld (debug_mark),a  
08ea 3a f9 08			ld a, (.dmark+1)  
08ed 32 69 fe			ld (debug_mark+1),a  
08f0 3a fa 08			ld a, (.dmark+2)  
08f3 32 6a fe			ld (debug_mark+2),a  
08f6 18 03			jr .pastdmark  
08f8 ..			.dmark: db "SCF"  
08fb f1			.pastdmark: pop af  
08fc			endm  
# End of macro DMARK
08fc					CALLMONITOR 
08fc cd 6c fe			call debug_vector  
08ff				endm  
# End of macro CALLMONITOR
08ff				endif 
08ff			 
08ff 22 62 fa			ld (store_tmppageid), hl 
0902				 
0902 3a 6b fa			ld a,(store_tmpid)    ; get file id 
0905			;	ld a, (store_filecache)			; save to cache 
0905			 
0905 32 77 fa			ld (store_page),a    ; set page id 
0908 3e 00			ld a, 0			 ; extent 0 is file header 
090a 32 78 fa			ld (store_page+1), a   ; set file extent 
090d			 
090d 32 79 fa			ld (store_page+2), a   ; extent count for the file 
0910			 
0910			;	inc hl 		; init block 0 of file 
0910			;	inc hl   		; skip file and extent id 
0910			 ;       ld a, 0 
0910			;	ld (hl),a 
0910			;	ld a, (store_filecache+1)  	; save to cache 
0910			 
0910			;	inc hl    ; file name 
0910				 
0910				 
0910 11 7a fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0913				if DEBUG_STORESE 
0913					DMARK "SCc" 
0913 f5				push af  
0914 3a 28 09			ld a, (.dmark)  
0917 32 68 fe			ld (debug_mark),a  
091a 3a 29 09			ld a, (.dmark+1)  
091d 32 69 fe			ld (debug_mark+1),a  
0920 3a 2a 09			ld a, (.dmark+2)  
0923 32 6a fe			ld (debug_mark+2),a  
0926 18 03			jr .pastdmark  
0928 ..			.dmark: db "SCc"  
092b f1			.pastdmark: pop af  
092c			endm  
# End of macro DMARK
092c					CALLMONITOR 
092c cd 6c fe			call debug_vector  
092f				endm  
# End of macro CALLMONITOR
092f				endif 
092f e1				pop hl    ; get zero term string 
0930 e5				push hl 
0931 3e 00			ld a, 0 
0933 cd 39 14			call strlent 
0936 23				inc hl   ; cover zero term 
0937 06 00			ld b,0 
0939 4d				ld c,l 
093a e1				pop hl 
093b				;ex de, hl 
093b				if DEBUG_STORESE 
093b					DMARK "SCa" 
093b f5				push af  
093c 3a 50 09			ld a, (.dmark)  
093f 32 68 fe			ld (debug_mark),a  
0942 3a 51 09			ld a, (.dmark+1)  
0945 32 69 fe			ld (debug_mark+1),a  
0948 3a 52 09			ld a, (.dmark+2)  
094b 32 6a fe			ld (debug_mark+2),a  
094e 18 03			jr .pastdmark  
0950 ..			.dmark: db "SCa"  
0953 f1			.pastdmark: pop af  
0954			endm  
# End of macro DMARK
0954					;push af 
0954					;ld a, 'a' 
0954					;ld (debug_mark),a 
0954					;pop af 
0954					CALLMONITOR 
0954 cd 6c fe			call debug_vector  
0957				endm  
# End of macro CALLMONITOR
0957				endif 
0957 ed b0			ldir    ; copy zero term string 
0959				if DEBUG_STORESE 
0959					DMARK "SCA" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 68 fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 69 fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 6a fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "SCA"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd 6c fe			call debug_vector  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975			 
0975				; write file header page 
0975			 
0975 2a 62 fa			ld hl,(store_tmppageid) 
0978 11 77 fa			ld de, store_page 
097b				if DEBUG_STORESE 
097b					DMARK "SCb" 
097b f5				push af  
097c 3a 90 09			ld a, (.dmark)  
097f 32 68 fe			ld (debug_mark),a  
0982 3a 91 09			ld a, (.dmark+1)  
0985 32 69 fe			ld (debug_mark+1),a  
0988 3a 92 09			ld a, (.dmark+2)  
098b 32 6a fe			ld (debug_mark+2),a  
098e 18 03			jr .pastdmark  
0990 ..			.dmark: db "SCb"  
0993 f1			.pastdmark: pop af  
0994			endm  
# End of macro DMARK
0994					;push af 
0994					;ld a, 'b' 
0994					;ld (debug_mark),a 
0994					;pop af 
0994					CALLMONITOR 
0994 cd 6c fe			call debug_vector  
0997				endm  
# End of macro CALLMONITOR
0997				endif 
0997 cd cb 04			call storage_write_block 
099a			 
099a 3a 6b fa			ld a, (store_tmpid) 
099d 6f				ld l, a 
099e 26 00			ld h,0 
09a0				if DEBUG_STORESE 
09a0					DMARK "SCz" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 68 fe			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 69 fe			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 6a fe			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "SCz"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6c fe			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc c9				ret 
09bd				 
09bd			 
09bd			 
09bd			; 
09bd			; Read File 
09bd			; 
09bd			; h - file id to locate 
09bd			; l - extent to locate 
09bd			; de - pointer to string to read into 
09bd			; 
09bd			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bd			 
09bd			.sr_fail: 
09bd d1				pop de 
09be c9				ret 
09bf			 
09bf			storage_read: 
09bf			 
09bf			 
09bf d5				push de 
09c0			 
09c0			; TODO BUG the above push is it popped before the RET Z? 
09c0			 
09c0			; TODO how to handle multiple part blocks 
09c0			 
09c0				; locate file extent to read 
09c0			 
09c0 5c				ld e, h 
09c1 55				ld d, l 
09c2			 
09c2			.srext: 
09c2 22 75 fa			ld (store_readptr), hl     ; save the current extent to load 
09c5 ed 53 73 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
09c9			 
09c9 21 40 00			ld hl, STORE_BLOCK_PHY 
09cc				if DEBUG_STORESE 
09cc					DMARK "sre" 
09cc f5				push af  
09cd 3a e1 09			ld a, (.dmark)  
09d0 32 68 fe			ld (debug_mark),a  
09d3 3a e2 09			ld a, (.dmark+1)  
09d6 32 69 fe			ld (debug_mark+1),a  
09d9 3a e3 09			ld a, (.dmark+2)  
09dc 32 6a fe			ld (debug_mark+2),a  
09df 18 03			jr .pastdmark  
09e1 ..			.dmark: db "sre"  
09e4 f1			.pastdmark: pop af  
09e5			endm  
# End of macro DMARK
09e5					CALLMONITOR 
09e5 cd 6c fe			call debug_vector  
09e8				endm  
# End of macro CALLMONITOR
09e8				endif 
09e8 cd 99 07			call storage_findnextid 
09eb			 
09eb				if DEBUG_STORESE 
09eb					DMARK "srf" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 68 fe			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 69 fe			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 6a fe			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "srf"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 6c fe			call debug_vector  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd f9 0f			call ishlzero 
0a0a			;	ld a, l 
0a0a			;	add h 
0a0a			;	cp 0 
0a0a 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0c			 
0a0c				; save current address for use by higher level words etc 
0a0c			 
0a0c 22 68 fa			ld (store_openaddr),hl 
0a0f			 
0a0f			 
0a0f				; hl contains page number to load 
0a0f d1				pop de   ; get storage 
0a10 ed 53 73 fa		ld (store_readbuf), de     ; current buffer to load in to 
0a14 d5				push de 
0a15				if DEBUG_STORESE 
0a15					DMARK "srg" 
0a15 f5				push af  
0a16 3a 2a 0a			ld a, (.dmark)  
0a19 32 68 fe			ld (debug_mark),a  
0a1c 3a 2b 0a			ld a, (.dmark+1)  
0a1f 32 69 fe			ld (debug_mark+1),a  
0a22 3a 2c 0a			ld a, (.dmark+2)  
0a25 32 6a fe			ld (debug_mark+2),a  
0a28 18 03			jr .pastdmark  
0a2a ..			.dmark: db "srg"  
0a2d f1			.pastdmark: pop af  
0a2e			endm  
# End of macro DMARK
0a2e					CALLMONITOR 
0a2e cd 6c fe			call debug_vector  
0a31				endm  
# End of macro CALLMONITOR
0a31				endif 
0a31 cd 66 04			call storage_read_block 
0a34			 
0a34				; if this a continuation read??? 
0a34			 
0a34 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a37			 
0a37 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a39 cd d0 0f			call addatohl 
0a3c 7e				ld a,(hl) 
0a3d fe 00			cp 0 
0a3f 28 02			jr z, .markiscont 
0a41 3e ff			ld a, 255 
0a43			 
0a43			.markiscont: 
0a43 32 6a fa			ld (store_readcont), a 
0a46			 
0a46				if DEBUG_STORESE 
0a46					DMARK "srC" 
0a46 f5				push af  
0a47 3a 5b 0a			ld a, (.dmark)  
0a4a 32 68 fe			ld (debug_mark),a  
0a4d 3a 5c 0a			ld a, (.dmark+1)  
0a50 32 69 fe			ld (debug_mark+1),a  
0a53 3a 5d 0a			ld a, (.dmark+2)  
0a56 32 6a fe			ld (debug_mark+2),a  
0a59 18 03			jr .pastdmark  
0a5b ..			.dmark: db "srC"  
0a5e f1			.pastdmark: pop af  
0a5f			endm  
# End of macro DMARK
0a5f					CALLMONITOR 
0a5f cd 6c fe			call debug_vector  
0a62				endm  
# End of macro CALLMONITOR
0a62				endif 
0a62				; only short reads enabled 
0a62			 
0a62 3a 72 fa			ld a, (store_longread) 
0a65 fe 00			cp 0 
0a67 ca 34 0b			jp z, .readdone 
0a6a			 
0a6a			; TODO if block has no zeros then need to read next block  
0a6a			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a6a			; check last byte of physical block. 
0a6a			; if not zero then the next block needs to be loaded 
0a6a			 
0a6a			 
0a6a 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6d			 
0a6d 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6f cd d0 0f			call addatohl 
0a72				;dec hl 
0a72 7e				ld a,(hl) 
0a73				if DEBUG_STORESE 
0a73					DMARK "sr?" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 68 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 69 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 6a fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sr?"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd 6c fe			call debug_vector  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f fe 00			cp 0 
0a91 ca 34 0b			jp z, .readdone 
0a94			 
0a94				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a94			 
0a94 23				inc hl 
0a95			 
0a95 22 73 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a98			 
0a98 ed 5b 75 fa		ld de, (store_readptr)     ; save the current extent to load 
0a9c			 
0a9c eb				ex de, hl 
0a9d			 
0a9d				; next ext 
0a9d			 
0a9d 23				inc hl 
0a9e 22 75 fa			ld  (store_readptr), hl     ; save the current extent to load 
0aa1			 
0aa1				if DEBUG_STORESE 
0aa1					DMARK "sF2" 
0aa1 f5				push af  
0aa2 3a b6 0a			ld a, (.dmark)  
0aa5 32 68 fe			ld (debug_mark),a  
0aa8 3a b7 0a			ld a, (.dmark+1)  
0aab 32 69 fe			ld (debug_mark+1),a  
0aae 3a b8 0a			ld a, (.dmark+2)  
0ab1 32 6a fe			ld (debug_mark+2),a  
0ab4 18 03			jr .pastdmark  
0ab6 ..			.dmark: db "sF2"  
0ab9 f1			.pastdmark: pop af  
0aba			endm  
# End of macro DMARK
0aba					CALLMONITOR 
0aba cd 6c fe			call debug_vector  
0abd				endm  
# End of macro CALLMONITOR
0abd				endif 
0abd			 
0abd				; get and load block 
0abd			 
0abd cd 99 07			call storage_findnextid 
0ac0			 
0ac0				if DEBUG_STORESE 
0ac0					DMARK "sf2" 
0ac0 f5				push af  
0ac1 3a d5 0a			ld a, (.dmark)  
0ac4 32 68 fe			ld (debug_mark),a  
0ac7 3a d6 0a			ld a, (.dmark+1)  
0aca 32 69 fe			ld (debug_mark+1),a  
0acd 3a d7 0a			ld a, (.dmark+2)  
0ad0 32 6a fe			ld (debug_mark+2),a  
0ad3 18 03			jr .pastdmark  
0ad5 ..			.dmark: db "sf2"  
0ad8 f1			.pastdmark: pop af  
0ad9			endm  
# End of macro DMARK
0ad9					CALLMONITOR 
0ad9 cd 6c fe			call debug_vector  
0adc				endm  
# End of macro CALLMONITOR
0adc				endif 
0adc cd f9 0f			call ishlzero 
0adf			;	ld a, l 
0adf			;	add h 
0adf			;	cp 0 
0adf ca bd 09			jp z,.sr_fail			; block not found so EOF 
0ae2				 
0ae2				; save current address for use by higher level words etc 
0ae2			 
0ae2 22 68 fa			ld (store_openaddr),hl 
0ae5			 
0ae5 cd 66 04			call storage_read_block 
0ae8			 
0ae8				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae8				; we need to pull everything back  
0ae8			 
0ae8 ed 5b 73 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aec 2a 73 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aef 23				inc hl 
0af0 23				inc hl     ; skip id and ext 
0af1 01 40 00			ld bc, STORE_BLOCK_PHY 
0af4				if DEBUG_STORESE 
0af4					DMARK "SR<" 
0af4 f5				push af  
0af5 3a 09 0b			ld a, (.dmark)  
0af8 32 68 fe			ld (debug_mark),a  
0afb 3a 0a 0b			ld a, (.dmark+1)  
0afe 32 69 fe			ld (debug_mark+1),a  
0b01 3a 0b 0b			ld a, (.dmark+2)  
0b04 32 6a fe			ld (debug_mark+2),a  
0b07 18 03			jr .pastdmark  
0b09 ..			.dmark: db "SR<"  
0b0c f1			.pastdmark: pop af  
0b0d			endm  
# End of macro DMARK
0b0d					CALLMONITOR 
0b0d cd 6c fe			call debug_vector  
0b10				endm  
# End of macro CALLMONITOR
0b10				endif 
0b10 ed b0			ldir     ; copy data 
0b12			 
0b12				; move the pointer back and pretend we have a full buffer for next recheck 
0b12			 
0b12 1b				dec de 
0b13 1b				dec de 
0b14			 
0b14			; TODO do pop below now short circuit loop????? 
0b14 c1				pop bc     ; get rid of spare de on stack 
0b15				if DEBUG_STORESE 
0b15					DMARK "SR>" 
0b15 f5				push af  
0b16 3a 2a 0b			ld a, (.dmark)  
0b19 32 68 fe			ld (debug_mark),a  
0b1c 3a 2b 0b			ld a, (.dmark+1)  
0b1f 32 69 fe			ld (debug_mark+1),a  
0b22 3a 2c 0b			ld a, (.dmark+2)  
0b25 32 6a fe			ld (debug_mark+2),a  
0b28 18 03			jr .pastdmark  
0b2a ..			.dmark: db "SR>"  
0b2d f1			.pastdmark: pop af  
0b2e			endm  
# End of macro DMARK
0b2e					CALLMONITOR 
0b2e cd 6c fe			call debug_vector  
0b31				endm  
# End of macro CALLMONITOR
0b31				endif 
0b31 c3 c2 09			jp .srext 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			.readdone:		 
0b34 e1				pop hl 		 ; return start of data to show as not EOF 
0b35 23				inc hl   ; past file id 
0b36 23				inc hl   ; past ext 
0b37				if DEBUG_STORESE 
0b37					DMARK "SRe" 
0b37 f5				push af  
0b38 3a 4c 0b			ld a, (.dmark)  
0b3b 32 68 fe			ld (debug_mark),a  
0b3e 3a 4d 0b			ld a, (.dmark+1)  
0b41 32 69 fe			ld (debug_mark+1),a  
0b44 3a 4e 0b			ld a, (.dmark+2)  
0b47 32 6a fe			ld (debug_mark+2),a  
0b4a 18 03			jr .pastdmark  
0b4c ..			.dmark: db "SRe"  
0b4f f1			.pastdmark: pop af  
0b50			endm  
# End of macro DMARK
0b50					CALLMONITOR 
0b50 cd 6c fe			call debug_vector  
0b53				endm  
# End of macro CALLMONITOR
0b53				endif 
0b53 c9					ret 
0b54			 
0b54			 
0b54			 
0b54			; 
0b54			; Append File 
0b54			; 
0b54			; hl - file id to locate 
0b54			; de - pointer to (multi block) string to write 
0b54			 
0b54			.sa_notfound: 
0b54 d1				pop de 
0b55 c9				ret 
0b56			 
0b56			 
0b56			storage_append: 
0b56				; hl -  file id to append to 
0b56				; de - string to append 
0b56			 
0b56 d5				push de 
0b57				 
0b57				if DEBUG_STORESE 
0b57					DMARK "AP1" 
0b57 f5				push af  
0b58 3a 6c 0b			ld a, (.dmark)  
0b5b 32 68 fe			ld (debug_mark),a  
0b5e 3a 6d 0b			ld a, (.dmark+1)  
0b61 32 69 fe			ld (debug_mark+1),a  
0b64 3a 6e 0b			ld a, (.dmark+2)  
0b67 32 6a fe			ld (debug_mark+2),a  
0b6a 18 03			jr .pastdmark  
0b6c ..			.dmark: db "AP1"  
0b6f f1			.pastdmark: pop af  
0b70			endm  
# End of macro DMARK
0b70					CALLMONITOR 
0b70 cd 6c fe			call debug_vector  
0b73				endm  
# End of macro CALLMONITOR
0b73				endif 
0b73			 
0b73 7d				ld a, l 
0b74 32 6b fa			ld (store_tmpid), a 
0b77			 
0b77				; get file header  
0b77			 
0b77 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b79 3a 6b fa			ld a, (store_tmpid) 
0b7c 5f				ld e, a 
0b7d			 
0b7d 21 40 00				ld hl, STORE_BLOCK_PHY 
0b80 cd 99 07				call storage_findnextid 
0b83			 
0b83 cd f9 0f			call ishlzero 
0b86 28 cc			jr z, .sa_notfound 
0b88			 
0b88 22 62 fa			ld (store_tmppageid), hl 
0b8b			 
0b8b				; TODO handle file id not found 
0b8b			 
0b8b				if DEBUG_STORESE 
0b8b					DMARK "AP2" 
0b8b f5				push af  
0b8c 3a a0 0b			ld a, (.dmark)  
0b8f 32 68 fe			ld (debug_mark),a  
0b92 3a a1 0b			ld a, (.dmark+1)  
0b95 32 69 fe			ld (debug_mark+1),a  
0b98 3a a2 0b			ld a, (.dmark+2)  
0b9b 32 6a fe			ld (debug_mark+2),a  
0b9e 18 03			jr .pastdmark  
0ba0 ..			.dmark: db "AP2"  
0ba3 f1			.pastdmark: pop af  
0ba4			endm  
# End of macro DMARK
0ba4					CALLMONITOR 
0ba4 cd 6c fe			call debug_vector  
0ba7				endm  
# End of macro CALLMONITOR
0ba7				endif 
0ba7			 
0ba7				; update file extent count 
0ba7			 
0ba7 11 77 fa			ld de, store_page 
0baa			 
0baa cd 66 04			call storage_read_block 
0bad			 
0bad				if DEBUG_STORESE 
0bad					DMARK "AP3" 
0bad f5				push af  
0bae 3a c2 0b			ld a, (.dmark)  
0bb1 32 68 fe			ld (debug_mark),a  
0bb4 3a c3 0b			ld a, (.dmark+1)  
0bb7 32 69 fe			ld (debug_mark+1),a  
0bba 3a c4 0b			ld a, (.dmark+2)  
0bbd 32 6a fe			ld (debug_mark+2),a  
0bc0 18 03			jr .pastdmark  
0bc2 ..			.dmark: db "AP3"  
0bc5 f1			.pastdmark: pop af  
0bc6			endm  
# End of macro DMARK
0bc6					CALLMONITOR 
0bc6 cd 6c fe			call debug_vector  
0bc9				endm  
# End of macro CALLMONITOR
0bc9				endif 
0bc9			;	ld (store_tmppageid), hl 
0bc9			 
0bc9 3a 79 fa			ld a, (store_page+2) 
0bcc 3c				inc a 
0bcd 32 79 fa			ld (store_page+2), a 
0bd0 32 6a fa			ld (store_tmpext), a 
0bd3				 
0bd3				if DEBUG_STORESE 
0bd3					DMARK "AP3" 
0bd3 f5				push af  
0bd4 3a e8 0b			ld a, (.dmark)  
0bd7 32 68 fe			ld (debug_mark),a  
0bda 3a e9 0b			ld a, (.dmark+1)  
0bdd 32 69 fe			ld (debug_mark+1),a  
0be0 3a ea 0b			ld a, (.dmark+2)  
0be3 32 6a fe			ld (debug_mark+2),a  
0be6 18 03			jr .pastdmark  
0be8 ..			.dmark: db "AP3"  
0beb f1			.pastdmark: pop af  
0bec			endm  
# End of macro DMARK
0bec					CALLMONITOR 
0bec cd 6c fe			call debug_vector  
0bef				endm  
# End of macro CALLMONITOR
0bef				endif 
0bef 2a 62 fa			ld hl, (store_tmppageid) 
0bf2 11 77 fa			ld de, store_page 
0bf5 cd cb 04			call storage_write_block 
0bf8			 
0bf8				; find free block 
0bf8			 
0bf8 11 00 00			ld de, 0			 ; file extent to locate 
0bfb			 
0bfb 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfe cd 99 07				call storage_findnextid 
0c01 cd f9 0f			call ishlzero 
0c04 ca 54 0b			jp z, .sa_notfound 
0c07			 
0c07					; TODO handle no space left 
0c07					 
0c07 22 62 fa				ld (store_tmppageid), hl 
0c0a			 
0c0a				if DEBUG_STORESE 
0c0a					DMARK "AP4" 
0c0a f5				push af  
0c0b 3a 1f 0c			ld a, (.dmark)  
0c0e 32 68 fe			ld (debug_mark),a  
0c11 3a 20 0c			ld a, (.dmark+1)  
0c14 32 69 fe			ld (debug_mark+1),a  
0c17 3a 21 0c			ld a, (.dmark+2)  
0c1a 32 6a fe			ld (debug_mark+2),a  
0c1d 18 03			jr .pastdmark  
0c1f ..			.dmark: db "AP4"  
0c22 f1			.pastdmark: pop af  
0c23			endm  
# End of macro DMARK
0c23					CALLMONITOR 
0c23 cd 6c fe			call debug_vector  
0c26				endm  
# End of macro CALLMONITOR
0c26				endif 
0c26					; init the buffer with zeros so we can id if the buffer is full or not 
0c26			 
0c26 e5					push hl 
0c27 c5					push bc 
0c28			 
0c28 21 77 fa				ld hl, store_page 
0c2b 06 40				ld b, STORE_BLOCK_PHY 
0c2d 3e 00				ld a, 0 
0c2f 77			.zeroblock:	ld (hl), a 
0c30 23					inc hl 
0c31 10 fc				djnz .zeroblock 
0c33			 
0c33 c1					pop bc 
0c34 e1					pop hl 
0c35			 
0c35					; construct block 
0c35			 
0c35 3a 6b fa				ld a, (store_tmpid) 
0c38 32 77 fa				ld (store_page), a   ; file id 
0c3b 3a 6a fa				ld a, (store_tmpext)   ; extent for this block 
0c3e 32 78 fa				ld (store_page+1), a 
0c41			 
0c41 e1					pop hl    ; get string to write 
0c42 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c44 11 79 fa				ld de, store_page+2 
0c47			 
0c47				if DEBUG_STORESE 
0c47					DMARK "AP5" 
0c47 f5				push af  
0c48 3a 5c 0c			ld a, (.dmark)  
0c4b 32 68 fe			ld (debug_mark),a  
0c4e 3a 5d 0c			ld a, (.dmark+1)  
0c51 32 69 fe			ld (debug_mark+1),a  
0c54 3a 5e 0c			ld a, (.dmark+2)  
0c57 32 6a fe			ld (debug_mark+2),a  
0c5a 18 03			jr .pastdmark  
0c5c ..			.dmark: db "AP5"  
0c5f f1			.pastdmark: pop af  
0c60			endm  
# End of macro DMARK
0c60					CALLMONITOR 
0c60 cd 6c fe			call debug_vector  
0c63				endm  
# End of macro CALLMONITOR
0c63				endif 
0c63			 
0c63			 
0c63			 
0c63					; fill buffer with data until end of string or full block 
0c63			 
0c63 7e			.appd:		ld a, (hl) 
0c64 12					ld (de), a 
0c65 fe 00				cp 0 
0c67 28 04				jr z, .appdone 
0c69 23					inc hl 
0c6a 13					inc de 
0c6b 10 f6				djnz .appd 
0c6d			 
0c6d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6e f5					push af   		; save last byte dumped 
0c6f			 
0c6f			 
0c6f 2a 62 fa			ld hl, (store_tmppageid) 
0c72 11 77 fa			ld de, store_page 
0c75				if DEBUG_STORESE 
0c75					DMARK "AP6" 
0c75 f5				push af  
0c76 3a 8a 0c			ld a, (.dmark)  
0c79 32 68 fe			ld (debug_mark),a  
0c7c 3a 8b 0c			ld a, (.dmark+1)  
0c7f 32 69 fe			ld (debug_mark+1),a  
0c82 3a 8c 0c			ld a, (.dmark+2)  
0c85 32 6a fe			ld (debug_mark+2),a  
0c88 18 03			jr .pastdmark  
0c8a ..			.dmark: db "AP6"  
0c8d f1			.pastdmark: pop af  
0c8e			endm  
# End of macro DMARK
0c8e					CALLMONITOR 
0c8e cd 6c fe			call debug_vector  
0c91				endm  
# End of macro CALLMONITOR
0c91				endif 
0c91 cd cb 04				call storage_write_block 
0c94			 
0c94			 
0c94				; was that a full block of data written? 
0c94				; any more to write out? 
0c94			 
0c94				; if yes then set vars and jump to start of function again 
0c94			 
0c94 f1					pop af 
0c95 d1					pop de 
0c96			 
0c96 fe 00				cp 0		 ; no, string was fully written 
0c98 c8					ret z 
0c99			 
0c99					; setup vars for next cycle 
0c99			 
0c99 3a 6b fa				ld a, (store_tmpid) 
0c9c 6f					ld l, a 
0c9d 26 00				ld h, 0 
0c9f			 
0c9f c3 56 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			if DEBUG_STORECF 
0ca2			storageput:	 
0ca2					ret 
0ca2			storageread: 
0ca2					ld hl, store_page 
0ca2					ld b, 200 
0ca2					ld a,0 
0ca2			.src:		ld (hl),a 
0ca2					inc hl 
0ca2					djnz .src 
0ca2					 
0ca2			 
0ca2					ld de, 0 
0ca2					ld bc, 1 
0ca2					ld hl, store_page 
0ca2					call cfRead 
0ca2			 
0ca2				call cfGetError 
0ca2				ld hl,scratch 
0ca2				call hexout 
0ca2				ld hl, scratch+2 
0ca2				ld a, 0 
0ca2				ld (hl),a 
0ca2				ld de, scratch 
0ca2				ld a,display_row_1 
0ca2				call str_at_display 
0ca2				call update_display 
0ca2			 
0ca2					ld hl, store_page 
0ca2					ld (os_cur_ptr),hl 
0ca2			 
0ca2					ret 
0ca2			endif 
0ca2			 
0ca2			 
0ca2			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca2			 
0ca2			storage_clear_page: 
0ca2 e5				push hl 
0ca3 d5				push de 
0ca4 c5				push bc 
0ca5 21 77 fa			ld hl, store_page 
0ca8 3e 00			ld a, 0 
0caa 77				ld (hl), a 
0cab			 
0cab 11 78 fa			ld de, store_page+1 
0cae 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb1			 
0cb1 ed b0			ldir 
0cb3				 
0cb3 c1				pop bc 
0cb4 d1				pop de 
0cb5 e1				pop hl 
0cb6 c9				ret 
0cb7			 
0cb7			; eof 
# End of file firmware_storage.asm
0cb7			  
0cb7			; support routines for above hardware abstraction layer  
0cb7			  
0cb7			include "firmware_general.asm"        ; general support functions  
0cb7			 
0cb7			; word look up 
0cb7			 
0cb7			; in 
0cb7			; a is the index 
0cb7			; hl is pointer start of array 
0cb7			; 
0cb7			; returns 
0cb7			; hl to the word 
0cb7			; 
0cb7			 
0cb7			table_lookup:  
0cb7 d5					push de 
0cb8 eb					ex de, hl 
0cb9			 
0cb9 6f					ld l, a 
0cba 26 00				ld h, 0 
0cbc 29					add hl, hl 
0cbd 19					add hl, de 
0cbe 7e					ld a, (hl) 
0cbf 23					inc hl 
0cc0 66					ld h,(hl) 
0cc1 6f					ld l, a 
0cc2			 
0cc2 d1					pop de 
0cc3 c9					ret 
0cc4			 
0cc4			; Delay loops 
0cc4			 
0cc4			 
0cc4			 
0cc4			aDelayInMS: 
0cc4 c5				push bc 
0cc5 47				ld b,a 
0cc6			msdelay: 
0cc6 c5				push bc 
0cc7				 
0cc7			 
0cc7 01 41 00			ld bc,041h 
0cca cd e2 0c			call delayloop 
0ccd c1				pop bc 
0cce 05				dec b 
0ccf 20 f5			jr nz,msdelay 
0cd1			 
0cd1			;if CPU_CLOCK_8MHZ 
0cd1			;msdelay8: 
0cd1			;	push bc 
0cd1			;	 
0cd1			; 
0cd1			;	ld bc,041h 
0cd1			;	call delayloop 
0cd1			;	pop bc 
0cd1			;	dec b 
0cd1			;	jr nz,msdelay8 
0cd1			;endif 
0cd1			 
0cd1			 
0cd1 c1				pop bc 
0cd2 c9				ret 
0cd3			 
0cd3			 
0cd3			delay250ms: 
0cd3				;push de 
0cd3 01 00 40			ld bc, 04000h 
0cd6 c3 e2 0c			jp delayloop 
0cd9			delay500ms: 
0cd9				;push de 
0cd9 01 00 80			ld bc, 08000h 
0cdc c3 e2 0c			jp delayloop 
0cdf			delay1s: 
0cdf				;push bc 
0cdf			   ; Clobbers A, d and e 
0cdf 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce2			delayloop: 
0ce2 c5			    push bc 
0ce3			 
0ce3			if BASE_CPM 
0ce3				ld bc, CPM_DELAY_TUNE 
0ce3			.cpmloop: 
0ce3				push bc 
0ce3			 
0ce3			endif 
0ce3			 
0ce3			 
0ce3			 
0ce3			delayloopi: 
0ce3			;	push bc 
0ce3			;.dl: 
0ce3 cb 47		    bit     0,a    	; 8 
0ce5 cb 47		    bit     0,a    	; 8 
0ce7 cb 47		    bit     0,a    	; 8 
0ce9 e6 ff		    and     255  	; 7 
0ceb 0b			    dec     bc      	; 6 
0cec 79			    ld      a,c     	; 4 
0ced b0			    or      b     	; 4 
0cee c2 e3 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf1			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf1				;pop de 
0cf1			;pop bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				pop bc 
0cf1				 
0cf1			    dec     bc      	; 6 
0cf1			    ld      a,c     	; 4 
0cf1			    or      b     	; 4 
0cf1			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf1				 
0cf1			 
0cf1			endif 
0cf1			;if CPU_CLOCK_8MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1			 
0cf1			;if CPU_CLOCK_10MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1 c1			    pop bc 
0cf2			 
0cf2 c9				ret 
0cf3			 
0cf3			 
0cf3			 
0cf3			; eof 
# End of file firmware_general.asm
0cf3			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf3			; display routines that use the physical hardware abstraction layer 
0cf3			 
0cf3			 
0cf3			; Display an activity indicator 
0cf3			; Each call returns the new char pointed to in hl 
0cf3			 
0cf3			active: 
0cf3 3a c3 fb			ld a, (display_active) 
0cf6 fe 06			cp 6 
0cf8			 
0cf8 20 02			jr nz, .sne 
0cfa				; gone past the last one reset sequence 
0cfa 3e ff			ld a, 255 
0cfc			 
0cfc			.sne:   
0cfc				; get the next char in seq 
0cfc 3c				inc a 
0cfd 32 c3 fb			ld (display_active), a 
0d00			 
0d00				; look up the string in the table 
0d00 21 17 0d			ld hl, actseq 
0d03 cb 27			sla a 
0d05 cd d0 0f			call addatohl 
0d08 cd 44 24			call loadwordinhl 
0d0b			 
0d0b				; forth will write the to string when pushing so move from rom to ram 
0d0b			 
0d0b 11 c4 fb			ld de, display_active+1 
0d0e 01 02 00			ld bc, 2 
0d11 ed b0			ldir 
0d13			 
0d13 21 c4 fb			ld hl, display_active+1 
0d16 c9				ret 
0d17				 
0d17				 
0d17			 
0d17			 
0d17			;db "|/-\|-\" 
0d17			 
0d17			actseq: 
0d17			 
0d17 25 0d		dw spin0 
0d19 27 0d		dw spin1 
0d1b 29 0d		dw spin2 
0d1d 2b 0d		dw spin3 
0d1f 29 0d		dw spin2 
0d21 27 0d		dw spin1 
0d23 25 0d		dw spin0 
0d25			 
0d25 .. 00		spin0: db " ", 0 
0d27 .. 00		spin1: db "-", 0 
0d29 .. 00		spin2: db "+", 0 
0d2b .. 00		spin3: db "#", 0 
0d2d			 
0d2d			 
0d2d			; information window 
0d2d			 
0d2d			; pass hl with 1st string to display 
0d2d			; pass de with 2nd string to display 
0d2d			 
0d2d			info_panel: 
0d2d e5				push hl 
0d2e			 
0d2e 2a c9 fb			ld hl, (display_fb_active) 
0d31 e5				push hl    ; future de destination 
0d32 21 ae fd				ld hl, display_fb0 
0d35 22 c9 fb				ld (display_fb_active), hl 
0d38			 
0d38			;	call clear_display 
0d38			 
0d38				if BASE_CPM 
0d38				ld a, '.' 
0d38				else 
0d38 3e a5			ld a, 165 
0d3a				endif 
0d3a cd a1 0d			call fill_display 
0d3d			 
0d3d			 
0d3d 3e 55			ld a, display_row_3 + 5 
0d3f cd af 0d			call str_at_display 
0d42			 
0d42 e1				pop hl 
0d43 d1				pop de 
0d44			 
0d44 e5				push hl 
0d45			 
0d45			 
0d45 3e 2d			ld a, display_row_2 + 5 
0d47 cd af 0d			call str_at_display 
0d4a			 
0d4a			 
0d4a cd bf 0d			call update_display 
0d4d cd 8d 20			call next_page_prompt 
0d50 cd 9c 0d			call clear_display 
0d53			 
0d53				 
0d53 21 0d fd				ld hl, display_fb1 
0d56 22 c9 fb				ld (display_fb_active), hl 
0d59 cd bf 0d			call update_display 
0d5c			 
0d5c e1				pop hl 
0d5d			 
0d5d c9				ret 
0d5e			 
0d5e			 
0d5e			 
0d5e			 
0d5e			; TODO windowing? 
0d5e			 
0d5e			; TODO scroll line up 
0d5e			 
0d5e			scroll_up: 
0d5e			 
0d5e e5				push hl 
0d5f d5				push de 
0d60 c5				push bc 
0d61			 
0d61				; get frame buffer  
0d61			 
0d61 2a c9 fb			ld hl, (display_fb_active) 
0d64 e5				push hl    ; future de destination 
0d65			 
0d65 11 28 00			ld  de, display_cols 
0d68 19				add hl, de 
0d69			 
0d69 d1				pop de 
0d6a			 
0d6a				;ex de, hl 
0d6a 01 9f 00			ld bc, display_fb_len -1  
0d6d			;if DEBUG_FORTH_WORDS 
0d6d			;	DMARK "SCL" 
0d6d			;	CALLMONITOR 
0d6d			;endif	 
0d6d ed b0			ldir 
0d6f			 
0d6f				; wipe bottom row 
0d6f			 
0d6f			 
0d6f 2a c9 fb			ld hl, (display_fb_active) 
0d72 11 a0 00			ld de, display_cols*display_rows 
0d75 19				add hl, de 
0d76 06 28			ld b, display_cols 
0d78 3e 20			ld a, ' ' 
0d7a			.scwipe: 
0d7a 77				ld (hl), a 
0d7b 2b				dec hl 
0d7c 10 fc			djnz .scwipe 
0d7e			 
0d7e				;pop hl 
0d7e			 
0d7e c1				pop bc 
0d7f d1				pop de 
0d80 e1				pop hl 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			;scroll_upo: 
0d82			;	ld de, display_row_1 
0d82			 ;	ld hl, display_row_2 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_2 
0d82			 ;	ld hl, display_row_3 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_3 
0d82			 ;	ld hl, display_row_4 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			 
0d82			; TODO clear row 4 
0d82			 
0d82			;	ret 
0d82			 
0d82				 
0d82			scroll_down: 
0d82			 
0d82 e5				push hl 
0d83 d5				push de 
0d84 c5				push bc 
0d85			 
0d85				; get frame buffer  
0d85			 
0d85 2a c9 fb			ld hl, (display_fb_active) 
0d88			 
0d88 11 9f 00			ld de, display_fb_len - 1 
0d8b 19				add hl, de 
0d8c			 
0d8c e5			push hl    ; future de destination 
0d8d			 
0d8d 11 28 00			ld  de, display_cols 
0d90 ed 52			sbc hl, de 
0d92			 
0d92			 
0d92 d1				pop de 
0d93			 
0d93			;	ex de, hl 
0d93 01 9f 00			ld bc, display_fb_len -1  
0d96			 
0d96			 
0d96				 
0d96			 
0d96 ed b0			ldir 
0d98			 
0d98				; wipe bottom row 
0d98			 
0d98			 
0d98			;	ld hl, (display_fb_active) 
0d98			;;	ld de, display_cols*display_rows 
0d98			;;	add hl, de 
0d98			;	ld b, display_cols 
0d98			;	ld a, ' ' 
0d98			;.scwiped: 
0d98			;	ld (hl), a 
0d98			;	dec hl 
0d98			;	djnz .scwiped 
0d98			 
0d98				;pop hl 
0d98			 
0d98 c1				pop bc 
0d99 d1				pop de 
0d9a e1				pop hl 
0d9b			 
0d9b c9				ret 
0d9c			;scroll_down: 
0d9c			;	ld de, display_row_4 
0d9c			;	ld hl, display_row_3 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_3 
0d9c			; 	ld hl, display_row_2 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_2 
0d9c			;	ld hl, display_row_1 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;;; TODO clear row 1 
0d9c			;	ret 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			; clear active frame buffer 
0d9c			 
0d9c			clear_display: 
0d9c 3e 20			ld a, ' ' 
0d9e c3 a1 0d			jp fill_display 
0da1			 
0da1			; fill active frame buffer with a char in A 
0da1			 
0da1			fill_display: 
0da1 06 a0			ld b,display_fb_len 
0da3 2a c9 fb			ld hl, (display_fb_active) 
0da6 77			.fd1:	ld (hl),a 
0da7 23				inc hl 
0da8 10 fc			djnz .fd1 
0daa 23				inc hl 
0dab 3e 00			ld a,0 
0dad 77				ld (hl),a 
0dae			 
0dae			 
0dae c9				ret 
0daf			; Write string (DE) at pos (A) to active frame buffer 
0daf			 
0daf 2a c9 fb		str_at_display:    ld hl,(display_fb_active) 
0db2 06 00					ld b,0 
0db4 4f					ld c,a 
0db5 09					add hl,bc 
0db6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db7 b7			            OR   A              ;Null terminator? 
0db8 c8			            RET  Z              ;Yes, so finished 
0db9 77					ld (hl),a 
0dba 23				inc hl 
0dbb 13			            INC  DE             ;Point to next character 
0dbc 18 f8		            JR   .sad1     ;Repeat 
0dbe c9					ret 
0dbf			 
0dbf			; using current frame buffer write to physical display 
0dbf			 
0dbf			update_display: 
0dbf e5				push hl 
0dc0 2a c9 fb			ld hl, (display_fb_active) 
0dc3 cd 99 76			call write_display 
0dc6 e1				pop hl 
0dc7 c9				ret 
0dc8			 
0dc8			; TODO scrolling 
0dc8			 
0dc8			 
0dc8			; move cursor right one char 
0dc8			cursor_right: 
0dc8			 
0dc8				; TODO shift right 
0dc8				; TODO if beyond max col 
0dc8				; TODO       cursor_next_line 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			 
0dc9			cursor_next_line: 
0dc9				; TODO first char 
0dc9				; TODO line down 
0dc9				; TODO if past last row 
0dc9				; TODO    scroll up 
0dc9			 
0dc9 c9				ret 
0dca			 
0dca			cursor_left: 
0dca				; TODO shift left 
0dca				; TODO if beyond left  
0dca				; TODO     cursor prev line 
0dca				 
0dca c9				ret 
0dcb			 
0dcb			cursor_prev_line: 
0dcb				; TODO last char 
0dcb				; TODO line up 
0dcb				; TODO if past first row 
0dcb				; TODO   scroll down 
0dcb			 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			cout: 
0dcc				; A - char 
0dcc c9				ret 
0dcd			 
0dcd			 
0dcd			; Display a menu and allow item selection (optional toggle items) 
0dcd			; 
0dcd			; format: 
0dcd			; hl pointer to word array with zero term for items 
0dcd			; e.g.    db item1 
0dcd			;         db .... 
0dcd			;         db 0 
0dcd			; 
0dcd			; a = starting menu item  
0dcd			; 
0dcd			; de = pointer item toggle array   (todo) 
0dcd			; 
0dcd			; returns item selected in a 1-... 
0dcd			; returns 0 if back button pressed 
0dcd			; 
0dcd			; NOTE: Uses system frame buffer to display 
0dcd			; 
0dcd			; LEFT, Q = go back 
0dcd			; RIGHT, SPACE, CR = select 
0dcd			; UP, A - Up 
0dcd			; DOWN, Z - Down 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			menu: 
0dcd			 
0dcd					; keep array pointer 
0dcd			 
0dcd 22 70 fa				ld (store_tmp1), hl 
0dd0 32 6e fa				ld (store_tmp2), a 
0dd3			 
0dd3					; check for key bounce 
0dd3			 
0dd3			if BASE_KEV 
0dd3			 
0dd3 cd e4 79		.mbounce:	call cin 
0dd6 fe 00				cp 0 
0dd8 20 f9				jr nz, .mbounce 
0dda			endif 
0dda					; for ease use ex 
0dda			 
0dda					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dda 21 ae fd				ld hl, display_fb0 
0ddd 22 c9 fb				ld (display_fb_active), hl 
0de0			 
0de0 cd 9c 0d		.mloop:		call clear_display 
0de3 cd bf 0d				call update_display 
0de6			 
0de6					; draw selection id '>' at 1 
0de6			 
0de6					; init start of list display 
0de6			 
0de6 3e 05				ld a, 5 
0de8 32 6c fa				ld (store_tmp3), a   ; display row count 
0deb 3a 6e fa				ld a,( store_tmp2) 
0dee 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0df1			 
0df1					 
0df1			.mitem:	 
0df1			 
0df1			 
0df1 3a 6f fa				ld a,(store_tmp2+1) 
0df4 6f					ld l, a 
0df5 26 00				ld h, 0 
0df7 29					add hl, hl 
0df8 ed 5b 70 fa			ld de, (store_tmp1) 
0dfc 19					add hl, de 
0dfd 7e					ld a, (hl) 
0dfe 23					inc hl 
0dff 66					ld h,(hl) 
0e00 6f					ld l, a 
0e01			 
0e01 cd f9 0f				call ishlzero 
0e04 28 1a				jr z, .mdone 
0e06			 
0e06 eb					ex de, hl 
0e07 3a 6c fa				ld a, (store_tmp3) 
0e0a cd af 0d				call str_at_display 
0e0d					 
0e0d			 
0e0d					; next item 
0e0d 3a 6f fa				ld a, (store_tmp2+1) 
0e10 3c					inc a 
0e11 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0e14			 
0e14			 		; next row 
0e14			 
0e14 3a 6c fa				ld a, (store_tmp3) 
0e17 c6 28				add display_cols 
0e19 32 6c fa				ld (store_tmp3), a 
0e1c			 
0e1c					; at end of screen? 
0e1c			 
0e1c fe 10				cp display_rows*4 
0e1e 20 d1				jr nz, .mitem 
0e20			 
0e20			 
0e20			.mdone: 
0e20 cd f9 0f				call ishlzero 
0e23 28 08				jr z, .nodn 
0e25			 
0e25 3e 78				ld a, display_row_4 
0e27 11 a6 0e				ld de, .mdown 
0e2a cd af 0d				call str_at_display 
0e2d			 
0e2d					; draw options to fill the screens with active item on line 1 
0e2d					; if current option is 2 or more then display ^ in top 
0e2d			 
0e2d 3a 6e fa		.nodn:		ld a, (store_tmp2) 
0e30 fe 00				cp 0 
0e32 28 08				jr z, .noup 
0e34			 
0e34 3e 00				ld a, 0 
0e36 11 a4 0e				ld de, .mup 
0e39 cd af 0d				call str_at_display 
0e3c			 
0e3c 3e 02		.noup:		ld a, 2 
0e3e 11 a2 0e				ld de, .msel 
0e41 cd af 0d				call str_at_display 
0e44			 
0e44					; if current option + 1 is not null then display V in bottom 
0e44					; get key 
0e44 cd bf 0d				call update_display 
0e47			 
0e47			 
0e47					; handle key 
0e47			 
0e47 cd d3 79				call cin_wait 
0e4a			 
0e4a fe 05				cp KEY_UP 
0e4c 28 2b				jr z, .mgoup 
0e4e fe 61				cp 'a' 
0e50 28 27				jr z, .mgoup 
0e52 fe 0a				cp KEY_DOWN 
0e54 28 32				jr z, .mgod 
0e56 fe 7a				cp 'z' 
0e58 28 2e				jr z, .mgod 
0e5a fe 20				cp ' ' 
0e5c 28 34				jr z, .goend 
0e5e fe 0c				cp KEY_RIGHT 
0e60 28 30				jr z, .goend 
0e62 fe 0d				cp KEY_CR 
0e64 28 2c				jr z, .goend 
0e66 fe 71				cp 'q' 
0e68 28 0b				jr z, .goback 
0e6a			 
0e6a fe 0b				cp KEY_LEFT 
0e6c 28 07				jr z, .goback 
0e6e fe 08				cp KEY_BS 
0e70 28 03				jr z, .goback 
0e72 c3 e0 0d				jp .mloop 
0e75			 
0e75			.goback: 
0e75 3e 00			ld a, 0 
0e77 18 1d			jr .goend2 
0e79			 
0e79				; move up one 
0e79			.mgoup: 
0e79 3a 6e fa				ld a, (store_tmp2) 
0e7c fe 00				cp 0 
0e7e ca e0 0d				jp z, .mloop 
0e81 3d					dec a 
0e82 32 6e fa				ld (store_tmp2), a 
0e85 c3 e0 0d				jp .mloop 
0e88			 
0e88				; move down one 
0e88			.mgod: 
0e88 3a 6e fa				ld a, (store_tmp2) 
0e8b 3c					inc a 
0e8c 32 6e fa				ld (store_tmp2), a 
0e8f c3 e0 0d				jp .mloop 
0e92			 
0e92			 
0e92			.goend: 
0e92					; get selected item number 
0e92			 
0e92 3a 6e fa				ld a, (store_tmp2) 
0e95 3c					inc a 
0e96			 
0e96			.goend2: 
0e96 f5					push af 
0e97			 
0e97					; restore active fb 
0e97					; TODO BUG assumes fb1 
0e97			 
0e97 21 0d fd				ld hl, display_fb1 
0e9a 22 c9 fb				ld (display_fb_active), hl 
0e9d			 
0e9d					; restore main regs 
0e9d			 
0e9d			 
0e9d cd bf 0d				call update_display 
0ea0			 
0ea0 f1					pop af 
0ea1			 
0ea1 c9				ret 
0ea2			 
0ea2 .. 00		.msel:   db ">",0 
0ea4 .. 00		.mup:   db "^",0 
0ea6 .. 00		.mdown:   db "v",0 
0ea8			 
0ea8			 
0ea8			; eof 
0ea8			 
# End of file firmware_display.asm
0ea8			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea8			; random number generators 
0ea8			 
0ea8			 
0ea8			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea8			 
0ea8			 
0ea8			;-----> Generate a random number 
0ea8			; output a=answer 0<=a<=255 
0ea8			; all registers are preserved except: af 
0ea8			random: 
0ea8 e5			        push    hl 
0ea9 d5			        push    de 
0eaa 2a a8 fb		        ld      hl,(randData) 
0ead ed 5f		        ld      a,r 
0eaf 57			        ld      d,a 
0eb0 5e			        ld      e,(hl) 
0eb1 19			        add     hl,de 
0eb2 85			        add     a,l 
0eb3 ac			        xor     h 
0eb4 22 a8 fb		        ld      (randData),hl 
0eb7 d1			        pop     de 
0eb8 e1			        pop     hl 
0eb9 c9			        ret 
0eba			 
0eba			 
0eba			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eba			 
0eba			 
0eba			 
0eba			;------LFSR------ 
0eba			;James Montelongo 
0eba			;optimized by Spencer Putt 
0eba			;out: 
0eba			; a = 8 bit random number 
0eba			RandLFSR: 
0eba 21 ae fb		        ld hl,LFSRSeed+4 
0ebd 5e			        ld e,(hl) 
0ebe 23			        inc hl 
0ebf 56			        ld d,(hl) 
0ec0 23			        inc hl 
0ec1 4e			        ld c,(hl) 
0ec2 23			        inc hl 
0ec3 7e			        ld a,(hl) 
0ec4 47			        ld b,a 
0ec5 cb 13		        rl e  
0ec7 cb 12			rl d 
0ec9 cb 11		        rl c  
0ecb 17				rla 
0ecc cb 13		        rl e  
0ece cb 12			rl d 
0ed0 cb 11		        rl c  
0ed2 17				rla 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda 67			        ld h,a 
0edb cb 13		        rl e  
0edd cb 12			rl d 
0edf cb 11		        rl c  
0ee1 17				rla 
0ee2 a8			        xor b 
0ee3 cb 13		        rl e  
0ee5 cb 12			rl d 
0ee7 ac			        xor h 
0ee8 a9			        xor c 
0ee9 aa			        xor d 
0eea 21 b0 fb		        ld hl,LFSRSeed+6 
0eed 11 b1 fb		        ld de,LFSRSeed+7 
0ef0 01 07 00		        ld bc,7 
0ef3 ed b8		        lddr 
0ef5 12			        ld (de),a 
0ef6 c9			        ret 
0ef7			 
0ef7			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef7			 
0ef7			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef7			 
0ef7			 
0ef7			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef7			 
0ef7			prng16: 
0ef7			;Inputs: 
0ef7			;   (seed1) contains a 16-bit seed value 
0ef7			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef7			;Outputs: 
0ef7			;   HL is the result 
0ef7			;   BC is the result of the LCG, so not that great of quality 
0ef7			;   DE is preserved 
0ef7			;Destroys: 
0ef7			;   AF 
0ef7			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef7			;160cc 
0ef7			;26 bytes 
0ef7 2a a2 fb		    ld hl,(seed1) 
0efa 44			    ld b,h 
0efb 4d			    ld c,l 
0efc 29			    add hl,hl 
0efd 29			    add hl,hl 
0efe 2c			    inc l 
0eff 09			    add hl,bc 
0f00 22 a2 fb		    ld (seed1),hl 
0f03 2a a0 fb		    ld hl,(seed2) 
0f06 29			    add hl,hl 
0f07 9f			    sbc a,a 
0f08 e6 2d		    and %00101101 
0f0a ad			    xor l 
0f0b 6f			    ld l,a 
0f0c 22 a0 fb		    ld (seed2),hl 
0f0f 09			    add hl,bc 
0f10 c9			    ret 
0f11			 
0f11			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f11			 
0f11			rand32: 
0f11			;Inputs: 
0f11			;   (seed1_0) holds the lower 16 bits of the first seed 
0f11			;   (seed1_1) holds the upper 16 bits of the first seed 
0f11			;   (seed2_0) holds the lower 16 bits of the second seed 
0f11			;   (seed2_1) holds the upper 16 bits of the second seed 
0f11			;   **NOTE: seed2 must be non-zero 
0f11			;Outputs: 
0f11			;   HL is the result 
0f11			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f11			;Destroys: 
0f11			;   AF 
0f11			;Tested and passes all CAcert tests 
0f11			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f11			;it has a period of 18,446,744,069,414,584,320 
0f11			;roughly 18.4 quintillion. 
0f11			;LFSR taps: 0,2,6,7  = 11000101 
0f11			;291cc 
0f11			;seed1_0=$+1 
0f11			;    ld hl,12345 
0f11			;seed1_1=$+1 
0f11			;    ld de,6789 
0f11			;    ld b,h 
0f11			;    ld c,l 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    inc l 
0f11			;    add hl,bc 
0f11			;    ld (seed1_0),hl 
0f11			;    ld hl,(seed1_1) 
0f11			;    adc hl,de 
0f11			;    ld (seed1_1),hl 
0f11			;    ex de,hl 
0f11			;seed2_0=$+1 
0f11			;    ld hl,9876 
0f11			;seed2_1=$+1 
0f11			;    ld bc,54321 
0f11			;    add hl,hl \ rl c \ rl b 
0f11			;    ld (seed2_1),bc 
0f11			;    sbc a,a 
0f11			;    and %11000101 
0f11			;    xor l 
0f11			;    ld l,a 
0f11			;    ld (seed2_0),hl 
0f11			;    ex de,hl 
0f11			;    add hl,bc 
0f11			;    ret 
0f11			; 
0f11			 
0f11			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f11			; 20 bytes, 86 cycles (excluding ret) 
0f11			 
0f11			; returns   hl = pseudorandom number 
0f11			; corrupts   a 
0f11			 
0f11			; generates 16-bit pseudorandom numbers with a period of 65535 
0f11			; using the xorshift method: 
0f11			 
0f11			; hl ^= hl << 7 
0f11			; hl ^= hl >> 9 
0f11			; hl ^= hl << 8 
0f11			 
0f11			; some alternative shift triplets which also perform well are: 
0f11			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f11			 
0f11			;  org 32768 
0f11			 
0f11			xrnd: 
0f11 2a a6 fb		  ld hl,(xrandc)       ; seed must not be 0 
0f14 3e 00		  ld a,0 
0f16 bd			  cp l 
0f17 20 02		  jr nz, .xrnd1 
0f19 2e 01		  ld l, 1 
0f1b			.xrnd1: 
0f1b			 
0f1b 7c			  ld a,h 
0f1c 1f			  rra 
0f1d 7d			  ld a,l 
0f1e 1f			  rra 
0f1f ac			  xor h 
0f20 67			  ld h,a 
0f21 7d			  ld a,l 
0f22 1f			  rra 
0f23 7c			  ld a,h 
0f24 1f			  rra 
0f25 ad			  xor l 
0f26 6f			  ld l,a 
0f27 ac			  xor h 
0f28 67			  ld h,a 
0f29			 
0f29 22 a6 fb		  ld (xrandc),hl 
0f2c			 
0f2c c9			  ret 
0f2d			;  
0f2d			 
0f2d			 
0f2d			;;;; int maths 
0f2d			 
0f2d			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2d			; Divide 16-bit values (with 16-bit result) 
0f2d			; In: Divide BC by divider DE 
0f2d			; Out: BC = result, HL = rest 
0f2d			; 
0f2d			Div16: 
0f2d 21 00 00		    ld hl,0 
0f30 78			    ld a,b 
0f31 06 08		    ld b,8 
0f33			Div16_Loop1: 
0f33 17			    rla 
0f34 ed 6a		    adc hl,hl 
0f36 ed 52		    sbc hl,de 
0f38 30 01		    jr nc,Div16_NoAdd1 
0f3a 19			    add hl,de 
0f3b			Div16_NoAdd1: 
0f3b 10 f6		    djnz Div16_Loop1 
0f3d 17			    rla 
0f3e 2f			    cpl 
0f3f 47			    ld b,a 
0f40 79			    ld a,c 
0f41 48			    ld c,b 
0f42 06 08		    ld b,8 
0f44			Div16_Loop2: 
0f44 17			    rla 
0f45 ed 6a		    adc hl,hl 
0f47 ed 52		    sbc hl,de 
0f49 30 01		    jr nc,Div16_NoAdd2 
0f4b 19			    add hl,de 
0f4c			Div16_NoAdd2: 
0f4c 10 f6		    djnz Div16_Loop2 
0f4e 17			    rla 
0f4f 2f			    cpl 
0f50 41			    ld b,c 
0f51 4f			    ld c,a 
0f52 c9			ret 
0f53			 
0f53			 
0f53			;http://z80-heaven.wikidot.com/math 
0f53			; 
0f53			;Inputs: 
0f53			;     DE and A are factors 
0f53			;Outputs: 
0f53			;     A is not changed 
0f53			;     B is 0 
0f53			;     C is not changed 
0f53			;     DE is not changed 
0f53			;     HL is the product 
0f53			;Time: 
0f53			;     342+6x 
0f53			; 
0f53			Mult16: 
0f53			 
0f53 06 08		     ld b,8          ;7           7 
0f55 21 00 00		     ld hl,0         ;10         10 
0f58 29			       add hl,hl     ;11*8       88 
0f59 07			       rlca          ;4*8        32 
0f5a 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5c 19			         add hl,de   ;--         -- 
0f5d 10 f9		       djnz $-5      ;13*7+8     99 
0f5f c9			ret 
0f60			 
0f60			; 
0f60			; Square root of 16-bit value 
0f60			; In:  HL = value 
0f60			; Out:  D = result (rounded down) 
0f60			; 
0f60			;Sqr16: 
0f60			;    ld de,#0040 
0f60			;    ld a,l 
0f60			;    ld l,h 
0f60			;    ld h,d 
0f60			;    or a 
0f60			;    ld b,8 
0f60			;Sqr16_Loop: 
0f60			;    sbc hl,de 
0f60			;    jr nc,Sqr16_Skip 
0f60			;    add hl,de 
0f60			;Sqr16_Skip: 
0f60			;    ccf 
0f60			;    rl d 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    djnz Sqr16_Loop 
0f60			;    ret 
0f60			; 
0f60			; 
0f60			; Divide 8-bit values 
0f60			; In: Divide E by divider C 
0f60			; Out: A = result, B = rest 
0f60			; 
0f60			Div8: 
0f60 af			    xor a 
0f61 06 08		    ld b,8 
0f63			Div8_Loop: 
0f63 cb 13		    rl e 
0f65 17			    rla 
0f66 91			    sub c 
0f67 30 01		    jr nc,Div8_NoAdd 
0f69 81			    add a,c 
0f6a			Div8_NoAdd: 
0f6a 10 f7		    djnz Div8_Loop 
0f6c 47			    ld b,a 
0f6d 7b			    ld a,e 
0f6e 17			    rla 
0f6f 2f			    cpl 
0f70 c9			    ret 
0f71			 
0f71			; 
0f71			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f71			; In: Multiply A with DE 
0f71			; Out: HL = result 
0f71			; 
0f71			Mult12U: 
0f71 2e 00		    ld l,0 
0f73 87			    add a,a 
0f74 30 01		    jr nc,Mult12U_NoAdd0 
0f76 19			    add hl,de 
0f77			Mult12U_NoAdd0: 
0f77 29			    add hl,hl 
0f78 87			    add a,a 
0f79 30 01		    jr nc,Mult12U_NoAdd1 
0f7b 19			    add hl,de 
0f7c			Mult12U_NoAdd1: 
0f7c 29			    add hl,hl 
0f7d 87			    add a,a 
0f7e 30 01		    jr nc,Mult12U_NoAdd2 
0f80 19			    add hl,de 
0f81			Mult12U_NoAdd2: 
0f81 29			    add hl,hl 
0f82 87			    add a,a 
0f83 30 01		    jr nc,Mult12U_NoAdd3 
0f85 19			    add hl,de 
0f86			Mult12U_NoAdd3: 
0f86 29			    add hl,hl 
0f87 87			    add a,a 
0f88 30 01		    jr nc,Mult12U_NoAdd4 
0f8a 19			    add hl,de 
0f8b			Mult12U_NoAdd4: 
0f8b 29			    add hl,hl 
0f8c 87			    add a,a 
0f8d 30 01		    jr nc,Mult12U_NoAdd5 
0f8f 19			    add hl,de 
0f90			Mult12U_NoAdd5: 
0f90 29			    add hl,hl 
0f91 87			    add a,a 
0f92 30 01		    jr nc,Mult12U_NoAdd6 
0f94 19			    add hl,de 
0f95			Mult12U_NoAdd6: 
0f95 29			    add hl,hl 
0f96 87			    add a,a 
0f97 d0			    ret nc 
0f98 19			    add hl,de 
0f99 c9			    ret 
0f9a			 
0f9a			; 
0f9a			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f9a			; In: Multiply A with DE 
0f9a			;      Put lowest value in A for most efficient calculation 
0f9a			; Out: HL = result 
0f9a			; 
0f9a			Mult12R: 
0f9a 21 00 00		    ld hl,0 
0f9d			Mult12R_Loop: 
0f9d cb 3f		    srl a 
0f9f 30 01		    jr nc,Mult12R_NoAdd 
0fa1 19			    add hl,de 
0fa2			Mult12R_NoAdd: 
0fa2 cb 23		    sla e 
0fa4 cb 12		    rl d 
0fa6 b7			    or a 
0fa7 c2 9d 0f		    jp nz,Mult12R_Loop 
0faa c9			    ret 
0fab			 
0fab			; 
0fab			; Multiply 16-bit values (with 32-bit result) 
0fab			; In: Multiply BC with DE 
0fab			; Out: BCHL = result 
0fab			; 
0fab			Mult32: 
0fab 79			    ld a,c 
0fac 48			    ld c,b 
0fad 21 00 00		    ld hl,0 
0fb0 06 10		    ld b,16 
0fb2			Mult32_Loop: 
0fb2 29			    add hl,hl 
0fb3 17			    rla 
0fb4 cb 11		    rl c 
0fb6 30 07		    jr nc,Mult32_NoAdd 
0fb8 19			    add hl,de 
0fb9 ce 00		    adc a,0 
0fbb d2 bf 0f		    jp nc,Mult32_NoAdd 
0fbe 0c			    inc c 
0fbf			Mult32_NoAdd: 
0fbf 10 f1		    djnz Mult32_Loop 
0fc1 41			    ld b,c 
0fc2 4f			    ld c,a 
0fc3 c9			    ret 
0fc4			 
0fc4			 
0fc4			 
0fc4			; 
0fc4			; Multiply 8-bit values 
0fc4			; In:  Multiply H with E 
0fc4			; Out: HL = result 
0fc4			; 
0fc4			Mult8: 
0fc4 16 00		    ld d,0 
0fc6 6a			    ld l,d 
0fc7 06 08		    ld b,8 
0fc9			Mult8_Loop: 
0fc9 29			    add hl,hl 
0fca 30 01		    jr nc,Mult8_NoAdd 
0fcc 19			    add hl,de 
0fcd			Mult8_NoAdd: 
0fcd 10 fa		    djnz Mult8_Loop 
0fcf c9			    ret 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			;;http://z80-heaven.wikidot.com/math 
0fd0			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fd0			; 
0fd0			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fd0			;     ld a,16        ;7 
0fd0			;     ld hl,0        ;10 
0fd0			;     jp $+5         ;10 
0fd0			;.DivLoop: 
0fd0			;       add hl,bc    ;-- 
0fd0			;       dec a        ;64 
0fd0			;       jr z,.DivLoopEnd        ;86 
0fd0			; 
0fd0			;       sla e        ;128 
0fd0			;       rl d         ;128 
0fd0			;       adc hl,hl    ;240 
0fd0			;       sbc hl,bc    ;240 
0fd0			;       jr nc,.DivLoop ;23|21 
0fd0			;       inc e        ;-- 
0fd0			;       jp .DivLoop+1 
0fd0			; 
0fd0			;.DivLoopEnd: 
0fd0			 
0fd0			;HL_Div_C: 
0fd0			;Inputs: 
0fd0			;     HL is the numerator 
0fd0			;     C is the denominator 
0fd0			;Outputs: 
0fd0			;     A is the remainder 
0fd0			;     B is 0 
0fd0			;     C is not changed 
0fd0			;     DE is not changed 
0fd0			;     HL is the quotient 
0fd0			; 
0fd0			;       ld b,16 
0fd0			;       xor a 
0fd0			;         add hl,hl 
0fd0			;         rla 
0fd0			;         cp c 
0fd0			;         jr c,$+4 
0fd0			;           inc l 
0fd0			;           sub c 
0fd0			;         djnz $-7 
0fd0			 
0fd0			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fd0			 
0fd0			addatohl: 
0fd0 85			    add   a, l    ; A = A+L 
0fd1 6f			    ld    l, a    ; L = A+L 
0fd2 8c			    adc   a, h    ; A = A+L+H+carry 
0fd3 95			    sub   l       ; A = H+carry 
0fd4 67			    ld    h, a    ; H = H+carry 
0fd5 c9			ret 
0fd6			 
0fd6			addatode: 
0fd6 83			    add   a, e    ; A = A+L 
0fd7 5f			    ld    e, a    ; L = A+L 
0fd8 8a			    adc   a, d    ; A = A+L+H+carry 
0fd9 93			    sub   e       ; A = H+carry 
0fda 57			    ld    d, a    ; H = H+carry 
0fdb c9			ret 
0fdc			 
0fdc			 
0fdc			addatobc: 
0fdc 81			    add   a, c    ; A = A+L 
0fdd 4f			    ld    c, a    ; L = A+L 
0fde 88			    adc   a, b    ; A = A+L+H+carry 
0fdf 91			    sub   c       ; A = H+carry 
0fe0 47			    ld    b, a    ; H = H+carry 
0fe1 c9			ret 
0fe2			 
0fe2			subafromhl: 
0fe2			   ; If A=0 do nothing 
0fe2			    ; Otherwise flip A's sign. Since 
0fe2			    ; the upper byte becomes -1, also 
0fe2			    ; substract 1 from H. 
0fe2 ed 44		    neg 
0fe4 ca ed 0f		    jp    z, Skip 
0fe7 25			    dec   h 
0fe8			     
0fe8			    ; Now add the low byte as usual 
0fe8			    ; Two's complement takes care of 
0fe8			    ; ensuring the result is correct 
0fe8 85			    add   a, l 
0fe9 6f			    ld    l, a 
0fea 8c			    adc   a, h 
0feb 95			    sub   l 
0fec 67			    ld    h, a 
0fed			Skip: 
0fed c9				ret 
0fee			 
0fee			 
0fee			; compare hl and de 
0fee			; returns:  
0fee			; if hl = de, z=1, s=0, c0=0 
0fee			; if hl > de, z=0, s=0, c=0 
0fee			; if hl < de, z=0, s=1, c=1 
0fee			cmp16:	 
0fee b7				or a 
0fef ed 52			sbc hl,de 
0ff1 e0				ret po 
0ff2 7c				ld a,h 
0ff3 1f				rra 
0ff4 ee 40			xor 01000000B 
0ff6 37				scf 
0ff7 8f				adc a,a 
0ff8 c9				ret 
0ff9			 
0ff9			 
0ff9			; test if hl contains zero   - A is destroyed 
0ff9			 
0ff9			ishlzero:    
0ff9 b7				or a     ; reset flags 
0ffa 7c				ld a, h 
0ffb b5				or l        	 
0ffc			 
0ffc c9				ret 
0ffd			 
0ffd			 
0ffd			 
0ffd			 
0ffd			if FORTH_ENABLE_FLOATMATH 
0ffd			;include "float/bbcmath.z80" 
0ffd			include "float/lpfpcalc.asm" 
0ffd			endif 
0ffd			 
0ffd			 
0ffd			; eof 
0ffd			 
# End of file firmware_maths.asm
0ffd			include "firmware_strings.asm"   ; string handling  
0ffd			 
0ffd			 
0ffd			; TODO string len 
0ffd			; input text string, end on cr with zero term 
0ffd			; a offset into frame buffer to start prompt 
0ffd			; d is max length 
0ffd			; e is display size TODO 
0ffd			; c is current cursor position 
0ffd			; hl is ptr to where string will be stored 
0ffd			 
0ffd			 
0ffd			; TODO check limit of buffer for new inserts 
0ffd			; TODO check insert does not push beyond buffer 
0ffd			; TODO scroll in a limited display area 
0ffd			; TODO scroll whole screen on page wrap 
0ffd			 
0ffd			 
0ffd			; TODO handle KEY_PREVWORD 
0ffd			; TODO handle KEY_NEXTWORD 
0ffd			; TODO handle KEY_HOME 
0ffd			; TODO handle KEY_END 
0ffd			; TODO use LCD cursor? 
0ffd			 
0ffd 32 61 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
1000 81					add c 
1001 32 5f fe				ld (input_at_cursor),a	; save draw pos of cursor 
1004 22 64 fe				ld (input_start), hl     ; save ptr to buffer 
1007 79					ld a, c 
1008 cd d0 0f				call addatohl 
100b 22 66 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
100e 7a					ld a,d 
100f 32 63 fe			        ld (input_size), a       ; save length of input area 
1012 79					ld a, c 
1013 32 52 fe				ld (input_cursor),a      ; init cursor start position  
1016 7b					ld a,e 
1017 32 62 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101a					 
101a					 
101a			 
101a			;		ld a,(input_ptr) 
101a			;		ld (input_under_cursor),a 	; save what is under the cursor 
101a			 
101a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101a					; init cursor shape if not set by the cin routines 
101a 21 be fb				ld hl, cursor_shape 
101d 3e ff				ld a, 255 
101f 77					ld (hl), a 
1020 23					inc hl 
1021 3e 00				ld a, 0 
1023 77					ld (hl), a 
1024			 
1024 3e 0f				ld a, CUR_BLINK_RATE 
1026 32 5d fe				ld (input_cur_flash), a 
1029 3e 01				ld a, 1 
102b 32 5c fe				ld (input_cur_onoff),a 
102e			 
102e			;	if DEBUG_INPUT 
102e			;		push af 
102e			;		ld a, 'I' 
102e			;		ld (debug_mark),a 
102e			;		pop af 
102e			;		CALLMONITOR 
102e			;	endif 
102e			.is1:		; main entry loop 
102e			 
102e			 
102e			 
102e					; pause 1ms 
102e			 
102e 3e 01				ld a, 1 
1030 cd c4 0c				call aDelayInMS 
1033			 
1033					; dec flash counter 
1033 3a 5d fe				ld a, (input_cur_flash) 
1036 3d					dec a 
1037 32 5d fe				ld (input_cur_flash), a 
103a fe 00				cp 0 
103c 20 0d				jr nz, .nochgstate 
103e			 
103e			 
103e					; change state 
103e 3a 5c fe				ld a,(input_cur_onoff) 
1041 ed 44				neg 
1043 32 5c fe				ld (input_cur_onoff),a 
1046			 
1046			 
1046					; reset on change of state 
1046 3e 0f				ld a, CUR_BLINK_RATE 
1048 32 5d fe				ld (input_cur_flash), a 
104b			 
104b			.nochgstate: 
104b					 
104b					 
104b			 
104b					; display cursor  
104b			 
104b			;		ld hl, (input_start) 
104b			;		ld a, (input_cursor) 
104b			;		call addatohl 
104b			 
104b					; get char under cursor and replace with cursor 
104b 2a 66 fe		ld hl, (input_ptr) 
104e			;		ld a, (hl) 
104e			;		ld (input_under_cursor),a 
104e			;		ld a, '_' 
104e			;		ld (hl), a 
104e			 
104e					; display string 
104e			 
104e ed 5b 64 fe			ld de, (input_start) 
1052 3a 61 fe				ld a, (input_at_pos) 
1055 cd af 0d				call str_at_display 
1058			;	        call update_display 
1058			 
1058					; find place to put the cursor 
1058			;		add h 
1058			;		ld l, display_row_1 
1058			;		sub l 
1058			; (input_at_pos) 
1058					;ld c, a 
1058			;		ld a, (input_cursor) 
1058			;		ld l, (input_at_pos) 
1058			;		;ld b, h 
1058			;		add l 
1058			;		ld (input_at_cursor),a 
1058					;ld l,h 
1058			 
1058			;		ld h, 0 
1058			;		ld l,(input_at_pos) 
1058			;		ld a, (input_cursor) 
1058			;		call addatohl 
1058			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1058			;		call subafromhl 
1058			;		ld a,l 
1058			;		ld (input_at_cursor), a 
1058			 
1058				if DEBUG_INPUT 
1058					ld a, (hardware_diag) 
1058					cp 0 
1058					jr z, .skip_input_diag 
1058			 
1058					ld a,(input_at_pos) 
1058					ld hl, LFSRSeed 
1058					call hexout 
1058					ld a, (input_cursor) 
1058					ld hl, LFSRSeed+2 
1058					call hexout 
1058					ld a,(input_at_cursor) 
1058					ld hl, LFSRSeed+4 
1058					call hexout 
1058			 
1058					ld a,(input_cur_onoff) 
1058					ld hl, LFSRSeed+6 
1058					call hexout 
1058			 
1058					ld a,(input_cur_flash) 
1058					ld hl, LFSRSeed+8 
1058					call hexout 
1058			 
1058					ld a,(input_len) 
1058					ld hl, LFSRSeed+10 
1058					call hexout 
1058					ld hl, LFSRSeed+12 
1058					ld a, 0 
1058					ld (hl),a 
1058					ld a, display_row_4 
1058					ld de, LFSRSeed 
1058					call str_at_display 
1058					.skip_input_diag: 
1058				endif 
1058			 
1058					; decide on if we are showing the cursor this time round 
1058			 
1058 3a 5c fe				ld a, (input_cur_onoff) 
105b fe ff				cp 255 
105d 28 13				jr z, .skipcur 
105f			 
105f			 
105f 3a 5f fe				ld a,(input_at_cursor) 
1062 11 be fb				ld de, cursor_shape 
1065 cd af 0d				call str_at_display 
1068			 
1068					; save length of current input string 
1068 2a 64 fe				ld hl, (input_start) 
106b cd 2e 14				call strlenz 
106e 7d					ld a,l 
106f 32 57 fe				ld (input_len),a 
1072			 
1072			.skipcur: 
1072			 
1072 cd bf 0d			        call update_display 
1075					 
1075			 
1075			 
1075					; wait 
1075				 
1075					; TODO loop without wait to flash the cursor and char under cursor	 
1075 cd e4 79				call cin    ; _wait 
1078			 
1078 fe 00				cp 0 
107a ca 2e 10				jp z, .is1 
107d			 
107d					; get ptr to char to input into 
107d			 
107d 4f					ld c,a 
107e 2a 64 fe				ld hl, (input_start) 
1081 3a 52 fe				ld a, (input_cursor) 
1084 cd d0 0f				call addatohl 
1087 22 66 fe				ld (input_ptr), hl 
108a 79					ld a,c 
108b			 
108b					; replace char under cursor 
108b			 
108b			;		ld hl, (input_ptr) 
108b			;		ld a, (input_under_cursor) 	; get what is under the cursor 
108b			;		ld (hl), a 
108b			 
108b			;	if DEBUG_INPUT 
108b			;		push af 
108b			;		ld a, 'i' 
108b			;		ld (debug_mark),a 
108b			;		pop af 
108b			;		CALLMONITOR 
108b			;	endif 
108b fe 0e				cp KEY_HOME 
108d 20 0e				jr nz, .iske 
108f			 
108f 3a 61 fe				ld a, (input_at_pos) 
1092 32 5f fe				ld (input_at_cursor),a 
1095 3e 00				ld a, 0 
1097 32 52 fe				ld (input_cursor), a 
109a c3 2e 10				jp .is1 
109d					 
109d fe 0f		.iske:		cp KEY_END 
109f 20 03				jr nz, .isknw 
10a1 c3 2e 10				jp .is1 
10a4			 
10a4 fe 06		.isknw:		cp KEY_NEXTWORD 
10a6 20 1b				jr nz, .iskpw 
10a8			 
10a8 2a 66 fe		.isknwm:	ld hl, (input_ptr) 
10ab 7e					ld a,(hl)	 
10ac fe 00				cp 0 
10ae ca 2e 10				jp z, .is1    ; end of string 
10b1 fe 20				cp ' ' 
10b3 ca 2e 10				jp z, .is1    ; end of word 
10b6 23					inc hl 
10b7 22 66 fe				ld (input_ptr), hl 
10ba 3a 5f fe				ld a, (input_at_cursor) 
10bd 3c					inc a 
10be 32 5f fe				ld (input_at_cursor), a 
10c1 18 e5				jr .isknwm 
10c3			 
10c3 fe 07		.iskpw:		cp KEY_PREVWORD 
10c5 20 1b				jr nz, .iskl 
10c7			.iskpwm:	 
10c7 2a 66 fe				ld hl, (input_ptr) 
10ca 7e					ld a,(hl)	 
10cb fe 00				cp 0  
10cd ca 2e 10				jp z, .is1    ; end of string 
10d0 fe 20				cp ' ' 
10d2 ca 2e 10				jp z, .is1    ; end of word 
10d5 2b					dec hl 
10d6 22 66 fe				ld (input_ptr), hl 
10d9 3a 5f fe				ld a, (input_at_cursor) 
10dc 3d					dec a 
10dd 32 5f fe				ld (input_at_cursor), a 
10e0 18 e5				jr .iskpwm 
10e2			 
10e2			 
10e2 fe 0b		.iskl:		cp KEY_LEFT 
10e4 20 27				jr nz, .isk1 
10e6			 
10e6 3a 52 fe				ld a, (input_cursor) 
10e9			 
10e9 fe 00				cp 0 
10eb ca 2e 10				jp z, .is1 		; at start of line to ignore  
10ee			 
10ee 3d					dec  a 		; TODO check underflow 
10ef 32 52 fe				ld (input_cursor), a 
10f2			 
10f2 2a 66 fe				ld hl, (input_ptr) 
10f5 2b					dec hl 
10f6 22 66 fe				ld (input_ptr), hl 
10f9					 
10f9 3a 5f fe				ld a, (input_at_cursor) 
10fc 3d					dec a 
10fd 32 5f fe				ld (input_at_cursor), a 
1100			 
1100 3e 01				ld a, 1		; show cursor moving 
1102 32 5c fe				ld (input_cur_onoff),a 
1105 3e 0f				ld a, CUR_BLINK_RATE 
1107 32 5d fe				ld (input_cur_flash), a 
110a			 
110a c3 2e 10				jp .is1 
110d			 
110d fe 0c		.isk1:		cp KEY_RIGHT 
110f 20 2a				jr nz, .isk2 
1111			 
1111 3a 57 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1114 5f					ld e,a 
1115 3a 52 fe				ld a, (input_cursor) 
1118 bb					cp e 
1119 ca 2e 10				jp z, .is1		; at the end of string so dont go right 
111c			 
111c 3c					inc  a 		; TODO check overflow 
111d 32 52 fe				ld (input_cursor), a 
1120			 
1120 3a 5f fe				ld a, (input_at_cursor) 
1123 3c					inc a 
1124 32 5f fe				ld (input_at_cursor), a 
1127			 
1127 2a 66 fe				ld hl, (input_ptr) 
112a 23					inc hl 
112b 22 66 fe				ld (input_ptr), hl 
112e			 
112e 3e 01				ld a, 1		; show cursor moving 
1130 32 5c fe				ld (input_cur_onoff),a 
1133 3e 0f				ld a, CUR_BLINK_RATE 
1135 32 5d fe				ld (input_cur_flash), a 
1138			 
1138 c3 2e 10				jp .is1 
113b			 
113b fe 05		.isk2:		cp KEY_UP 
113d			 
113d 20 26				jr nz, .isk3 
113f			 
113f					; swap last command with the current on 
113f			 
113f					; move cursor to start of string 
113f 2a 64 fe				ld hl, (input_start) 
1142 22 66 fe				ld (input_ptr), hl 
1145			 
1145 3a 61 fe				ld a, (input_at_pos) 
1148 32 5f fe				ld (input_at_cursor), a 
114b			 
114b 3e 00				ld a, 0 
114d 32 52 fe				ld (input_cursor), a 
1150					 
1150					; swap input and last command buffers 
1150			 
1150 21 e5 f4				ld hl, os_cli_cmd 
1153 11 e4 f5				ld de, os_last_cmd 
1156 06 ff				ld b, 255 
1158 7e			.swap1:		ld a, (hl) 
1159 4f					ld c,a 
115a 1a					ld a, (de) 
115b 77					ld (hl), a 
115c 79					ld a,c 
115d 12					ld (de),a 
115e 23					inc hl 
115f 13					inc de 
1160 10 f6				djnz .swap1 
1162			 
1162			 
1162			 
1162			 
1162			 
1162 c3 2e 10				jp .is1 
1165			 
1165 fe 08		.isk3:		cp KEY_BS 
1167 20 3c				jr nz, .isk4 
1169			 
1169 3a 52 fe				ld a, (input_cursor) 
116c			 
116c fe 00				cp 0 
116e ca 2e 10				jp z, .is1 		; at start of line to ignore  
1171			 
1171 3d					dec  a 		; TODO check underflow 
1172 32 52 fe				ld (input_cursor), a 
1175			 
1175					; hl is source 
1175					; de needs to be source - 1 
1175			 
1175			;		ld a, 0 
1175			;		dec hl 
1175			;		ld (hl), a 
1175			 
1175 2a 66 fe				ld hl, (input_ptr) 
1178 2b					dec hl 
1179 22 66 fe				ld (input_ptr), hl 
117c			 
117c					; shift all data 
117c			 
117c e5					push hl 
117d 23					inc hl 
117e d1					pop de 
117f 3a 57 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1182 4f					ld c,a 
1183 06 00				ld b,0 
1185 ed b0				ldir  
1187			 
1187			 
1187			 
1187			 
1187 3a 5f fe				ld a, (input_at_cursor) 
118a 3d					dec a 
118b 32 5f fe				ld (input_at_cursor), a 
118e			 
118e			 
118e 3e 01				ld a, 1		; show cursor moving 
1190 32 5c fe				ld (input_cur_onoff),a 
1193 3e 0f				ld a, CUR_BLINK_RATE 
1195 32 5d fe				ld (input_cur_flash), a 
1198			 
1198					; remove char 
1198 3a 5f fe				ld a, (input_at_cursor) 
119b 3c					inc a 
119c 11 26 12				ld de,.iblank 
119f cd af 0d				call str_at_display 
11a2			 
11a2 c3 2e 10				jp .is1 
11a5			 
11a5 fe 0d		.isk4:		cp KEY_CR 
11a7 28 6c				jr z, .endinput 
11a9			 
11a9					; else add the key press to the end 
11a9			 
11a9 4f					ld c, a			; save key pressed 
11aa			 
11aa 7e					ld a,(hl)		; get what is currently under char 
11ab			 
11ab fe 00				cp 0			; we are at the end of the string 
11ad 20 2f				jr nz, .onchar 
11af					 
11af					; add a char to the end of the string 
11af				 
11af 71					ld (hl),c 
11b0 23					inc hl 
11b1			;		ld a,' ' 
11b1			;		ld (hl),a 
11b1			;		inc hl 
11b1 3e 00				ld a,0 
11b3 77					ld (hl),a 
11b4 2b					dec hl 
11b5			 
11b5 3a 52 fe				ld a, (input_cursor) 
11b8 3c					inc a				; TODO check max string length and scroll  
11b9 32 52 fe				ld (input_cursor), a		; inc cursor pos 
11bc							 
11bc 3a 5f fe				ld a, (input_at_cursor) 
11bf 3c					inc a 
11c0 32 5f fe				ld (input_at_cursor), a 
11c3			 
11c3 2a 66 fe				ld hl, (input_ptr) 
11c6 23					inc hl 
11c7 22 66 fe				ld (input_ptr), hl 
11ca			 
11ca 2a 66 fe				ld hl, (input_ptr) 
11cd 23					inc hl 
11ce 22 66 fe				ld (input_ptr), hl 
11d1			;	if DEBUG_INPUT 
11d1			;		push af 
11d1			;		ld a, '+' 
11d1			;		ld (debug_mark),a 
11d1			;		pop af 
11d1			;		CALLMONITOR 
11d1			;	endif 
11d1 3e 01				ld a, 1		; show cursor moving 
11d3 32 5c fe				ld (input_cur_onoff),a 
11d6 3e 0f				ld a, CUR_BLINK_RATE 
11d8 32 5d fe				ld (input_cur_flash), a 
11db c3 2e 10				jp .is1 
11de					 
11de			 
11de			 
11de					; if on a char then insert 
11de			.onchar: 
11de			 
11de					; TODO over flow check: make sure insert does not blow out buffer 
11de			 
11de					; need to do some maths to use lddr 
11de			 
11de e5					push hl   ; save char pos 
11df c5					push bc 
11e0			 
11e0 2a 64 fe				ld hl, (input_start) 
11e3 3a 57 fe				ld a, (input_len) 
11e6 cd d0 0f				call addatohl  		; end of string 
11e9 23					inc hl 
11ea 23					inc hl		; past zero term 
11eb e5					push hl 
11ec 23					inc hl 
11ed e5					push hl  
11ee			 
11ee								; start and end of lddr set, now how much to move? 
11ee			 
11ee							 
11ee 3a 52 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11f1 47					ld b,a 
11f2 3a 57 fe				ld a,(input_len) 
11f5 5f					ld e,a 
11f6 90					sub b 
11f7 3c					inc a		;?? 
11f8 3c					inc a		;?? 
11f9 3c					inc a		;?? 
11fa			 
11fa 06 00				ld b,0 
11fc 4f					ld c,a 
11fd			 
11fd				if DEBUG_INPUT 
11fd					push af 
11fd					ld a, 'i' 
11fd					ld (debug_mark),a 
11fd					pop af 
11fd			;		CALLMONITOR 
11fd				endif 
11fd d1					pop de 
11fe e1					pop hl 
11ff				if DEBUG_INPUT 
11ff					push af 
11ff					ld a, 'I' 
11ff					ld (debug_mark),a 
11ff					pop af 
11ff			;		CALLMONITOR 
11ff				endif 
11ff ed b8				lddr 
1201				 
1201			 
1201			 
1201					; TODO have a key for insert/overwrite mode???? 
1201 c1					pop bc 
1202 e1					pop hl 
1203 71					ld (hl), c		; otherwise overwrite current char 
1204					 
1204			 
1204			 
1204			 
1204 3a 52 fe				ld a, (input_cursor) 
1207 3c					inc  a 		; TODO check overflow 
1208 32 52 fe				ld (input_cursor), a 
120b			 
120b 3a 5f fe				ld a, (input_at_cursor) 
120e 3c					inc a 
120f 32 5f fe				ld (input_at_cursor), a 
1212			 
1212 c3 2e 10				jp .is1 
1215			 
1215			.endinput:	; TODO look for end of string 
1215			 
1215					; add trailing space for end of token 
1215			 
1215 2a 64 fe				ld hl, (input_start) 
1218 3a 57 fe				ld a,(input_len) 
121b cd d0 0f				call addatohl 
121e 3e 20				ld a, ' ' 
1220 77					ld (hl),a 
1221					; TODO eof of parse marker 
1221			 
1221 23					inc hl 
1222 3e 00				ld a, 0 
1224 77					ld (hl),a 
1225			 
1225			 
1225 c9					ret 
1226			 
1226 .. 00		.iblank: db " ",0 
1228			 
1228			 
1228 32 61 fe		input_str_prev:	ld (input_at_pos), a 
122b 22 64 fe				ld (input_start), hl 
122e 3e 01				ld a,1			; add cursor 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235 22 66 fe				ld (input_ptr), hl 
1238 7a					ld a,d 
1239 32 63 fe				ld (input_size), a 
123c 3e 00				ld a,0 
123e 32 52 fe				ld (input_cursor),a 
1241			.instr1:	 
1241			 
1241					; TODO do block cursor 
1241					; TODO switch cursor depending on the modifer key 
1241			 
1241					; update cursor shape change on key hold 
1241			 
1241 2a 66 fe				ld hl, (input_ptr) 
1244 2b					dec hl 
1245 3a be fb				ld a,(cursor_shape) 
1248 77					ld (hl), a 
1249			 
1249					; display entered text 
1249 3a 61 fe				ld a,(input_at_pos) 
124c cd a8 77		            	CALL fLCD_Pos       ;Position cursor to location in A 
124f ed 5b 64 fe	            	LD   de, (input_start) 
1253 cd ca 77		            	CALL fLCD_Str       ;Display string pointed to by DE 
1256			 
1256 cd e4 79				call cin 
1259 fe 00				cp 0 
125b 28 e4				jr z, .instr1 
125d			 
125d					; proecess keyboard controls first 
125d			 
125d 2a 66 fe				ld hl,(input_ptr) 
1260			 
1260 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1262 28 5a				jr z, .instrcr 
1264			 
1264 fe 08				cp KEY_BS 	; back space 
1266 20 0f				jr nz, .instr2 
1268					; process back space 
1268			 
1268					; TODO stop back space if at start of string 
1268 2b					dec hl 
1269 2b					dec hl ; to over write cursor 
126a 3a be fb				ld a,(cursor_shape) 
126d					;ld a,0 
126d 77					ld (hl),a 
126e 23					inc hl 
126f 3e 20				ld a," " 
1271 77					ld (hl),a 
1272 22 66 fe				ld (input_ptr),hl 
1275					 
1275			 
1275 18 ca				jr .instr1 
1277			 
1277 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1279 20 06				jr nz, .instr3 
127b 2b					dec hl 
127c 22 66 fe				ld (input_ptr),hl 
127f 18 c0				jr .instr1 
1281				 
1281 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1283 20 06				jr nz, .instr4 
1285 23					inc hl 
1286 22 66 fe				ld (input_ptr),hl 
1289 18 b6				jr .instr1 
128b			 
128b fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
128d 20 06				jr nz, .instr5 
128f 2b					dec hl 
1290 22 66 fe				ld (input_ptr),hl 
1293 18 ac				jr .instr1 
1295			 
1295 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1297 20 06				jr nz, .instr6 
1299 2b					dec hl 
129a 22 66 fe				ld (input_ptr),hl 
129d 18 a2				jr .instr1 
129f fe 05		.instr6:        cp KEY_UP      ; recall last command 
12a1 20 0b				jr nz, .instrnew 
12a3			 
12a3 21 be f1			ld hl, scratch 
12a6 11 e4 f5			ld de, os_last_cmd 
12a9 cd c7 12			call strcpy 
12ac 18 93				jr .instr1 
12ae			 
12ae			 
12ae			.instrnew:	; no special key pressed to see if we have room to store it 
12ae			 
12ae					; TODO do string size test 
12ae			 
12ae 2b					dec hl ; to over write cursor 
12af 77					ld (hl),a 
12b0 23					inc hl 
12b1 3a be fb				ld a,(cursor_shape) 
12b4 77					ld (hl),a 
12b5 23					inc hl 
12b6 3e 00				ld a,0 
12b8 77					ld (hl),a 
12b9			 
12b9 22 66 fe				ld (input_ptr),hl 
12bc					 
12bc 18 83				jr .instr1 
12be 2b			.instrcr:	dec hl		; remove cursor 
12bf 3e 20				ld a,' '	; TODO add a trailing space for safety 
12c1 77					ld (hl),a 
12c2 23					inc hl 
12c3 3e 00				ld a,0 
12c5 77					ld (hl),a 
12c6			 
12c6			 
12c6					; if at end of line scroll up    
12c6					; TODO detecting only end of line 4 for scroll up  
12c6			 
12c6					;ld   
12c6			 
12c6 c9					ret 
12c7			 
12c7			 
12c7			; strcpy hl = dest, de source 
12c7			 
12c7 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12c8 b7			            OR   A              ;Null terminator? 
12c9 c8			            RET  Z              ;Yes, so finished 
12ca 1a					ld a,(de) 
12cb 77					ld (hl),a 
12cc 13			            INC  DE             ;Point to next character 
12cd 23					inc hl 
12ce 18 f7		            JR   strcpy       ;Repeat 
12d0 c9					ret 
12d1			 
12d1			 
12d1			; TODO string_at  
12d1			; pass string which starts with lcd offset address and then null term string 
12d1			 
12d1			; TODO string to dec 
12d1			; TODO string to hex 
12d1			; TODO byte to string hex 
12d1			; TODO byte to string dec 
12d1			 
12d1			 
12d1			 
12d1			; from z80uartmonitor 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12d1			; pass hl for where to put the text 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1 c5			hexout:	PUSH BC 
12d2 f5					PUSH AF 
12d3 47					LD B, A 
12d4					; Upper nybble 
12d4 cb 3f				SRL A 
12d6 cb 3f				SRL A 
12d8 cb 3f				SRL A 
12da cb 3f				SRL A 
12dc cd ec 12				CALL tohex 
12df 77					ld (hl),a 
12e0 23					inc hl	 
12e1					 
12e1					; Lower nybble 
12e1 78					LD A, B 
12e2 e6 0f				AND 0FH 
12e4 cd ec 12				CALL tohex 
12e7 77					ld (hl),a 
12e8 23					inc hl	 
12e9					 
12e9 f1					POP AF 
12ea c1					POP BC 
12eb c9					RET 
12ec					 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			tohex: 
12ec e5					PUSH HL 
12ed d5					PUSH DE 
12ee 16 00				LD D, 0 
12f0 5f					LD E, A 
12f1 21 f9 12				LD HL, .DATA 
12f4 19					ADD HL, DE 
12f5 7e					LD A, (HL) 
12f6 d1					POP DE 
12f7 e1					POP HL 
12f8 c9					RET 
12f9			 
12f9			.DATA: 
12f9 30					DEFB	30h	; 0 
12fa 31					DEFB	31h	; 1 
12fb 32					DEFB	32h	; 2 
12fc 33					DEFB	33h	; 3 
12fd 34					DEFB	34h	; 4 
12fe 35					DEFB	35h	; 5 
12ff 36					DEFB	36h	; 6 
1300 37					DEFB	37h	; 7 
1301 38					DEFB	38h	; 8 
1302 39					DEFB	39h	; 9 
1303 41					DEFB	41h	; A 
1304 42					DEFB	42h	; B 
1305 43					DEFB	43h	; C 
1306 44					DEFB	44h	; D 
1307 45					DEFB	45h	; E 
1308 46					DEFB	46h	; F 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1309			;;    subtract $30, if result > 9 then subtract $7 more 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			atohex: 
1309 d6 30				SUB $30 
130b fe 0a				CP 10 
130d f8					RET M		; If result negative it was 0-9 so we're done 
130e d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1310 c9					RET		 
1311			 
1311			 
1311			 
1311			 
1311			; Get 2 ASCII characters as hex byte from pointer in hl 
1311			 
1311			BYTERD: 
1311 16 00			LD	D,00h		;Set up 
1313 cd 1b 13			CALL	HEXCON		;Get byte and convert to hex 
1316 87				ADD	A,A		;First nibble so 
1317 87				ADD	A,A		;multiply by 16 
1318 87				ADD	A,A		; 
1319 87				ADD	A,A		; 
131a 57				LD	D,A		;Save hi nibble in D 
131b			HEXCON: 
131b 7e				ld a, (hl)		;Get next chr 
131c 23				inc hl 
131d d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
131f fe 0a			CP	00Ah		;Is it 0-9 ? 
1321 38 02			JR	C,NALPHA	;If so miss next bit 
1323 d6 07			SUB	007h		;Else convert alpha 
1325			NALPHA: 
1325 b2				OR	D		;Add hi nibble back 
1326 c9				RET			; 
1327			 
1327			 
1327			; 
1327			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1327			; Since the routines get_byte and therefore get_nibble are called, only valid 
1327			; characters (0-9a-f) are accepted. 
1327			; 
1327			;get_word        push    af 
1327			;                call    get_byte        ; Get the upper byte 
1327			;                ld      h, a 
1327			;                call    get_byte        ; Get the lower byte 
1327			;                ld      l, a 
1327			;                pop     af 
1327			;                ret 
1327			; 
1327			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1327			; the routine get_nibble is used only valid characters are accepted - the  
1327			; input routine only accepts characters 0-9a-f. 
1327			; 
1327 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1328 7e					ld a,(hl) 
1329 23					inc hl 
132a cd 4f 13		                call    nibble2val      ; Get upper nibble 
132d cb 07		                rlc     a 
132f cb 07		                rlc     a 
1331 cb 07		                rlc     a 
1333 cb 07		                rlc     a 
1335 47			                ld      b, a            ; Save upper four bits 
1336 7e					ld a,(hl) 
1337 cd 4f 13		                call    nibble2val      ; Get lower nibble 
133a b0			                or      b               ; Combine both nibbles 
133b c1			                pop     bc              ; Restore B (and C) 
133c c9			                ret 
133d			; 
133d			; Get a hexadecimal digit from the serial line. This routine blocks until 
133d			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
133d			; to the serial line interface. The lower 4 bits of A contain the value of  
133d			; that particular digit. 
133d			; 
133d			;get_nibble      ld a,(hl)           ; Read a character 
133d			;                call    to_upper        ; Convert to upper case 
133d			;                call    is_hex          ; Was it a hex digit? 
133d			;                jr      nc, get_nibble  ; No, get another character 
133d			 ;               call    nibble2val      ; Convert nibble to value 
133d			 ;               call    print_nibble 
133d			 ;               ret 
133d			; 
133d			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
133d			; A valid hexadecimal digit is denoted by a set C flag. 
133d			; 
133d			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
133d			;                ret     nc              ; Yes 
133d			;                cp      '0'             ; Less than '0'? 
133d			;                jr      nc, is_hex_1    ; No, continue 
133d			;                ccf                     ; Complement carry (i.e. clear it) 
133d			;                ret 
133d			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
133d			;                ret     c               ; Yes 
133d			;                cp      'A'             ; Less than 'A'? 
133d			;                jr      nc, is_hex_2    ; No, continue 
133d			;                ccf                     ; Yes - clear carry and return 
133d			;                ret 
133d			;is_hex_2        scf                     ; Set carry 
133d			;                ret 
133d			; 
133d			; Convert a single character contained in A to upper case: 
133d			; 
133d fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
133f d8			                ret     c 
1340 fe 7b		                cp      'z' + 1         ; > 'z'? 
1342 d0			                ret     nc              ; Nothing to do, either 
1343 e6 5f		                and     $5f             ; Convert to upper case 
1345 c9			                ret 
1346			 
1346			 
1346			to_lower: 
1346			 
1346			   ; if char is in [A-Z] make it lower case 
1346			 
1346			   ; enter : a = char 
1346			   ; exit  : a = lower case char 
1346			   ; uses  : af 
1346			 
1346 fe 41		   cp 'A' 
1348 d8			   ret c 
1349			    
1349 fe 5b		   cp 'Z'+1 
134b d0			   ret nc 
134c			    
134c f6 20		   or $20 
134e c9			   ret 
134f			 
134f			; 
134f			; Expects a hexadecimal digit (upper case!) in A and returns the 
134f			; corresponding value in A. 
134f			; 
134f fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1351 38 02		                jr      c, nibble2val_1 ; Yes 
1353 d6 07		                sub     7               ; Adjust for A-F 
1355 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1357 e6 0f		                and     $f              ; Only return lower 4 bits 
1359 c9			                ret 
135a			; 
135a			; Print_nibble prints a single hex nibble which is contained in the lower  
135a			; four bits of A: 
135a			; 
135a			;print_nibble    push    af              ; We won't destroy the contents of A 
135a			;                and     $f              ; Just in case... 
135a			;                add     a, '0'             ; If we have a digit we are done here. 
135a			;                cp      '9' + 1         ; Is the result > 9? 
135a			;                jr      c, print_nibble_1 
135a			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
135a			;print_nibble_1  call    putc            ; Print the nibble and 
135a			;                pop     af              ; restore the original value of A 
135a			;                ret 
135a			;; 
135a			;; Send a CR/LF pair: 
135a			; 
135a			;crlf            push    af 
135a			;                ld      a, cr 
135a			;                call    putc 
135a			;                ld      a, lf 
135a			;                call    putc 
135a			;                pop     af 
135a			;                ret 
135a			; 
135a			; Print_word prints the four hex digits of a word to the serial line. The  
135a			; word is expected to be in HL. 
135a			; 
135a			;print_word      push    hl 
135a			;                push    af 
135a			;                ld      a, h 
135a			;                call    print_byte 
135a			;                ld      a, l 
135a			;                call    print_byte 
135a			;                pop     af 
135a			;                pop     hl 
135a			;                ret 
135a			; 
135a			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
135a			; The byte to be printed is expected to be in A. 
135a			; 
135a			;print_byte      push    af              ; Save the contents of the registers 
135a			;                push    bc 
135a			;                ld      b, a 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                call    print_nibble    ; Print high nibble 
135a			;                ld      a, b 
135a			;                call    print_nibble    ; Print low nibble 
135a			;                pop     bc              ; Restore original register contents 
135a			;                pop     af 
135a			;                ret 
135a			 
135a			 
135a			 
135a			 
135a			 
135a			fourehexhl:  
135a 7e				ld a,(hl) 
135b cd 09 13			call atohex 
135e cb 3f				SRL A 
1360 cb 3f				SRL A 
1362 cb 3f				SRL A 
1364 cb 3f				SRL A 
1366 47				ld b, a 
1367 23				inc hl 
1368 7e				ld a,(hl) 
1369 23				inc hl 
136a cd 09 13			call atohex 
136d 80				add b 
136e 57				ld d,a 
136f 7e				ld a,(hl) 
1370 cd 09 13			call atohex 
1373 cb 3f				SRL A 
1375 cb 3f				SRL A 
1377 cb 3f				SRL A 
1379 cb 3f				SRL A 
137b 47				ld b, a 
137c 23				inc hl 
137d 7e				ld a,(hl) 
137e 23				inc hl 
137f cd 09 13			call atohex 
1382 80				add b 
1383 5f				ld e, a 
1384 d5				push de 
1385 e1				pop hl 
1386 c9				ret 
1387			 
1387			; pass hl. returns z set if the byte at hl is a digit 
1387			;isdigithl:  
1387			;	push bc 
1387			;	ld a,(hl) 
1387			;	cp ':' 
1387			;	jr nc, .isdf 		; > 
1387			;	cp '0' 
1387			;	jr c, .isdf		; < 
1387			; 
1387			;	; TODO find a better way to set z 
1387			; 
1387			;	ld b,a 
1387			;	cp b 
1387			;	pop bc 
1387			;	ret 
1387			; 
1387			;.isdf:	; not digit so clear z 
1387			; 
1387			;	; TODO find a better way to unset z 
1387			; 
1387			;	ld b,a 
1387			;	inc b 
1387			;	cp b 
1387			; 
1387			;	pop bc 
1387			;	ret 
1387				 
1387				 
1387			 
1387			 
1387			; pass hl as the four byte address to load 
1387			 
1387			get_word_hl:  
1387 e5				push hl 
1388 cd 27 13			call get_byte 
138b				 
138b 47				ld b, a 
138c			 
138c e1				pop hl 
138d 23				inc hl 
138e 23				inc hl 
138f			 
138f			; TODO not able to handle a-f  
138f 7e				ld a,(hl) 
1390			;	;cp ':' 
1390			;	cp 'g' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp 'G' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp '0' 
1390			;	jr c, .single_byte_hl		; < 
1390			 
1390				;call isdigithl 
1390 fe 00			cp 0 
1392 28 06			jr z, .single_byte_hl 
1394			 
1394			.getwhln:   ; hex word so get next byte 
1394			 
1394 cd 27 13			call get_byte 
1397 6f				ld l, a 
1398 60				ld h,b 
1399 c9				ret 
139a 68			.single_byte_hl:   ld l,b 
139b 26 00				ld h,0 
139d c9					ret 
139e			 
139e			 
139e			 
139e			 
139e 21 04 1e			ld hl,asc+1 
13a1			;	ld a, (hl) 
13a1			;	call nibble2val 
13a1 cd 27 13			call get_byte 
13a4			 
13a4			;	call fourehexhl 
13a4 32 f2 f1			ld (scratch+52),a 
13a7				 
13a7 21 f0 f1			ld hl,scratch+50 
13aa 22 e1 f4			ld (os_cur_ptr),hl 
13ad			 
13ad c9				ret 
13ae			 
13ae			 
13ae			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13ae			 
13ae			; Decimal Unsigned Version 
13ae			 
13ae			;Number in a to decimal ASCII 
13ae			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13ae			;Example: display a=56 as "056" 
13ae			;input: a = number 
13ae			;Output: a=0,value of a in the screen 
13ae			;destroys af,bc (don't know about hl and de) 
13ae			DispAToASCII: 
13ae 0e 9c			ld	c,-100 
13b0 cd ba 13			call	.Na1 
13b3 0e f6			ld	c,-10 
13b5 cd ba 13			call	.Na1 
13b8 0e ff			ld	c,-1 
13ba 06 2f		.Na1:	ld	b,'0'-1 
13bc 04			.Na2:	inc	b 
13bd 81				add	a,c 
13be 38 fc			jr	c,.Na2 
13c0 91				sub	c		;works as add 100/10/1 
13c1 f5				push af		;safer than ld c,a 
13c2 78				ld	a,b		;char is in b 
13c3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13c3 f1				pop af		;safer than ld a,c 
13c4 c9				ret 
13c5			 
13c5			; Decimal Signed Version 
13c5			 
13c5			; DispA 
13c5			; -------------------------------------------------------------- 
13c5			; Converts a signed integer value to a zero-terminated ASCII 
13c5			; string representative of that value (using radix 10). 
13c5			; -------------------------------------------------------------- 
13c5			; INPUTS: 
13c5			;     HL     Value to convert (two's complement integer). 
13c5			;     DE     Base address of string destination. (pointer). 
13c5			; -------------------------------------------------------------- 
13c5			; OUTPUTS: 
13c5			;     None 
13c5			; -------------------------------------------------------------- 
13c5			; REGISTERS/MEMORY DESTROYED 
13c5			; AF HL 
13c5			; -------------------------------------------------------------- 
13c5			 
13c5			;DispHLToASCII: 
13c5			;   push    de 
13c5			;   push    bc 
13c5			; 
13c5			;; Detect sign of HL. 
13c5			;    bit    7, h 
13c5			;    jr     z, ._DoConvert 
13c5			; 
13c5			;; HL is negative. Output '-' to string and negate HL. 
13c5			;    ld     a, '-' 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			; 
13c5			;; Negate HL (using two's complement) 
13c5			;    xor    a 
13c5			;    sub    l 
13c5			;    ld     l, a 
13c5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13c5			;    sbc    a, h 
13c5			;    ld     h, a 
13c5			; 
13c5			;; Convert HL to digit characters 
13c5			;._DoConvert: 
13c5			;    ld     b, 0     ; B will count character length of number 
13c5			;-   ld     a, 10 
13c5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13c5			;    push   af 
13c5			;    inc    b 
13c5			;    ld     a, h 
13c5			;    or     l 
13c5			;    jr     nz, - 
13c5			; 
13c5			;; Retrieve digits from stack 
13c5			;-   pop    af 
13c5			;    or     $30 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			;    djnz   - 
13c5			; 
13c5			;; Terminate string with NULL 
13c5			;    xor    a 
13c5			;    ld     (de), a 
13c5			; 
13c5			;    pop    bc 
13c5			;    pop    de 
13c5			;    ret 
13c5			 
13c5			;Comments 
13c5			; 
13c5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13c5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13c5			;    Note that the output string will not be fixed-width. 
13c5			; 
13c5			;Example Usage 
13c5			; 
13c5			;    ld    hl, -1004 
13c5			;    ld    de, OP1 
13c5			;    call  DispA 
13c5			;    ld    hl, OP1 
13c5			;    syscall  PutS 
13c5			 
13c5			 
13c5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13c5			 
13c5			 
13c5			;Converts an ASCII string to an unsigned 16-bit integer 
13c5			;Quits when it reaches a non-decimal digit 
13c5			 
13c5			string_to_uint16: 
13c5			atoui_16: 
13c5			;Input: 
13c5			;     DE points to the string 
13c5			;Outputs: 
13c5			;     HL is the result 
13c5			;     A is the 8-bit value of the number 
13c5			;     DE points to the byte after the number 
13c5			;Destroys: 
13c5			;     BC 
13c5			;       if the string is non-empty, BC is HL/10 
13c5			;Size:  24 bytes 
13c5			;Speed: 42+d(104+{0,9}) 
13c5			;       d is the number of digits in the number 
13c5			;       max is 640 cycles for a 5 digit number 
13c5			;Assuming no leading zeros: 
13c5			;1 digit:  146cc 
13c5			;2 digit:  250cc 
13c5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13c5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13c5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13c5			;avg: 544.81158447265625cc (544+13297/16384) 
13c5			;=============================================================== 
13c5 21 00 00		  ld hl,0 
13c8			.u16a: 
13c8 1a			  ld a,(de) 
13c9 d6 30		  sub 30h 
13cb fe 0a		  cp 10 
13cd d0			  ret nc 
13ce 13			  inc de 
13cf 44			  ld b,h 
13d0 4d			  ld c,l 
13d1 29			  add hl,hl 
13d2 29			  add hl,hl 
13d3 09			  add hl,bc 
13d4 29			  add hl,hl 
13d5 85			  add a,l 
13d6 6f			  ld l,a 
13d7 30 ef		  jr nc,.u16a 
13d9 24			  inc h 
13da c3 c8 13		  jp .u16a 
13dd			 
13dd			 
13dd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13dd			 
13dd			;written by Zeda 
13dd			;Converts a 16-bit unsigned integer to an ASCII string. 
13dd			 
13dd			uitoa_16: 
13dd			;Input: 
13dd			;   DE is the number to convert 
13dd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
13dd			;Output: 
13dd			;   HL points to the null-terminated ASCII string 
13dd			;      NOTE: This isn't necessarily the same as the input HL. 
13dd d5			  push de 
13de c5			  push bc 
13df f5			  push af 
13e0 eb			  ex de,hl 
13e1			 
13e1 01 f0 d8		  ld bc,-10000 
13e4 3e 2f		  ld a,'0'-1 
13e6 3c			  inc a 
13e7 09			  add hl,bc  
13e8 38 fc		   jr c,$-2 
13ea 12			  ld (de),a 
13eb 13			  inc de 
13ec			 
13ec 01 e8 03		  ld bc,1000 
13ef 3e 3a		  ld a,'9'+1 
13f1 3d			  dec a  
13f2 09			  add hl,bc  
13f3 30 fc		   jr nc,$-2 
13f5 12			  ld (de),a 
13f6 13			  inc de 
13f7			 
13f7 01 9c ff		  ld bc,-100 
13fa 3e 2f		  ld a,'0'-1 
13fc 3c			  inc a  
13fd 09			  add hl,bc  
13fe 38 fc		   jr c,$-2 
1400 12			  ld (de),a 
1401 13			  inc de 
1402			 
1402 7d			  ld a,l 
1403 26 3a		  ld h,'9'+1 
1405 25			  dec h  
1406 c6 0a		  add a,10  
1408 30 fb		   jr nc,$-3 
140a c6 30		  add a,'0' 
140c eb			  ex de,hl 
140d 72			  ld (hl),d 
140e 23			  inc hl 
140f 77			  ld (hl),a 
1410 23			  inc hl 
1411 36 00		  ld (hl),0 
1413			 
1413			;Now strip the leading zeros 
1413 0e fa		  ld c,-6 
1415 09			  add hl,bc 
1416 3e 30		  ld a,'0' 
1418 23			  inc hl  
1419 be			  cp (hl)  
141a 28 fc		  jr z,$-2 
141c			 
141c			;Make sure that the string is non-empty! 
141c 7e			  ld a,(hl) 
141d b7			  or a 
141e 20 01		  jr nz,.atoub 
1420 2b			  dec hl 
1421			.atoub: 
1421			 
1421 f1			  pop af 
1422 c1			  pop bc 
1423 d1			  pop de 
1424 c9			  ret 
1425			 
1425			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1425			 
1425			toUpper: 
1425			;A is the char. 
1425			;If A is a lowercase letter, this sets it to the matching uppercase 
1425			;18cc or 30cc or 41cc 
1425			;avg: 26.75cc 
1425 fe 61		  cp 'a' 
1427 d8			  ret c 
1428 fe 7b		  cp 'z'+1 
142a d0			  ret nc 
142b d6 20		  sub 'a'-'A' 
142d c9			  ret 
142e			 
142e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
142e			 
142e			; String Length 
142e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
142e			 
142e			; Get the length of the null-terminated string starting at $8000 hl 
142e			;    LD     HL, $8000 
142e			 
142e			strlenz: 
142e			 
142e af			    XOR    A               ; Zero is the value we are looking for. 
142f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1430 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1431			                           ; 65, 536 bytes (the entire addressable memory space). 
1431 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1433			 
1433			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1433 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1434 6f			    LD     L, A             ; number of bytes 
1435 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1437 2b			    DEC    HL              ; Compensate for null. 
1438 c9				ret 
1439			 
1439			; Get the length of the A terminated string starting at $8000 hl 
1439			;    LD     HL, $8000 
1439			 
1439			strlent: 
1439			 
1439			                  ; A is the value we are looking for. 
1439 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
143b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
143d			                           ; 65, 536 bytes (the entire addressable memory space). 
143d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
143f			 
143f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
143f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1441 2e 00		    LD     L, 0             ; number of bytes 
1443 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1445 2b			    DEC    HL              ; Compensate for null. 
1446 c9				ret 
1447			 
1447			 
1447			;Comparing Strings 
1447			 
1447			;IN    HL     Address of string1. 
1447			;      DE     Address of string2. 
1447			 
1447			; doc given but wrong??? 
1447			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1447			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1447			; tested 
1447			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1447			 
1447			strcmp_old: 
1447 e5			    PUSH   HL 
1448 d5			    PUSH   DE 
1449			 
1449 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
144a be			    CP     (HL)            ; (want to minimize work). 
144b 38 01		    JR     C, Str1IsBigger 
144d 7e			    LD     A, (HL) 
144e			 
144e			Str1IsBigger: 
144e 4f			    LD     C, A             ; Put length in BC 
144f 06 00		    LD     B, 0 
1451 13			    INC    DE              ; Increment pointers to meat of string. 
1452 23			    INC    HL 
1453			 
1453			CmpLoop: 
1453 1a			    LD     A, (DE)          ; Compare bytes. 
1454 ed a1		    CPI 
1456 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1458 13			    INC    DE              ; Update pointer. 
1459 ea 53 14		    JP     PE, CmpLoop 
145c			 
145c d1			    POP    DE 
145d e1			    POP    HL 
145e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
145f be			    CP     (HL) 
1460 c9			    RET 
1461			 
1461			NoMatch: 
1461 2b			    DEC    HL 
1462 be			    CP     (HL)            ; Compare again to affect carry. 
1463 d1			    POP    DE 
1464 e1			    POP    HL 
1465 c9			    RET 
1466			 
1466			;; test strmp 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr z, .z1 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z1: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr z, .z2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr c, .c1 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c1: 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr c, .c2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;	NEXTW 
1466			;.str1:   db "string1",0 
1466			;.str2:   db "string2",0 
1466			 
1466			; only care about direct match or not 
1466			; hl and de strings 
1466			; zero set if the same 
1466			 
1466			strcmp: 
1466 1a				ld a, (de) 
1467 be				cp (hl) 
1468 28 02			jr z, .ssame 
146a b7				or a 
146b c9				ret 
146c			 
146c			.ssame:  
146c fe 00			cp 0 
146e c8				ret z 
146f			 
146f 23				inc hl 
1470 13				inc de 
1471 18 f3			jr strcmp 
1473				 
1473				 
1473			 
1473			 
1473			 
1473			 
1473			; eof 
1473			 
1473			 
1473			 
1473			 
1473			 
1473			 
# End of file firmware_strings.asm
1473			include "firmware_memory.asm"   ; malloc and free  
1473			 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			.mallocsize: db "Wants malloc >256",0 
1473			.mallocasize: db "MALLOC gives >256",0 
1473			.malloczero: db "MALLOC gives zero",0 
1473			 
1473			malloc_guard_zerolen: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473				ld de, 0 
1473			        call cmp16 
1473				jr nz, .lowalloz 
1473			 
1473				push hl 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .malloczero 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473				call bp_on 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473			.lowalloz: 
1473			 
1473			 
1473				pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_entry: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowalloc 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocsize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473				jr .lowdone 
1473			.lowalloc: 
1473			 
1473			 
1473				pop hl 
1473			.lowdone:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_exit: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowallocx 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocasize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473				pop de 
1473				pop hl 
1473			 
1473				CALLMONITOR 
1473				jr .lowdonex 
1473			.lowallocx: 
1473			 
1473				pop hl 
1473			.lowdonex:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			endif 
1473			 
1473			if MALLOC_2 
1473			; Z80 Malloc and Free Functions 
1473			 
1473			; Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc: 
1473				 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_entry 
1473			endif 
1473			 
1473			 
1473			 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "mal" 
1473						CALLMONITOR 
1473					endif 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of size into A 
1473			    or h               ; Check if size is zero 
1473			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1473			 
1473			    ; Allocate memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma1" 
1473						CALLMONITOR 
1473					endif 
1473			    call malloc_internal ; Call internal malloc function 
1473			    pop af             ; Restore AF register 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret                ; Return 
1473			 
1473			; Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free: 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of pointer into A 
1473			    or h               ; Check if pointer is NULL 
1473			    jp z, free_exit    ; If pointer is NULL, exit 
1473			 
1473			    ; Free memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473			    call free_internal  ; Call internal free function 
1473			    pop af             ; Restore AF register 
1473			    ret                ; Return 
1473			 
1473			; Internal Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc_internal: 
1473			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to requested size 
1473			    ex de, hl          ; Save total size in DE, and keep it in HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			 
1473			    ; Search for free memory block 
1473			    ld de, (heap_end)  ; Load end of heap into DE 
1473			    ld bc, 0           ; Initialize counter 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			malloc_search_loop: 
1473			    ; Check if current block is free 
1473			    ld a, (hl)         ; Load current block's status (free or used) 
1473			    cp 0               ; Compare with zero (free) 
1473			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1473			 
1473			    ; Check if current block is large enough 
1473			    ld a, (hl+1)       ; Load high byte of block size 
1473			    cp l               ; Compare with low byte of requested size 
1473			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1473			 
1473			    ld a, (hl+2)       ; Load low byte of block size 
1473			    cp h               ; Compare with high byte of requested size 
1473			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1473			 
1473			    ; Mark block as used 
1473			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1473			 
1473			    ; Calculate remaining space in block 
1473			    ld bc, 0           ; Clear BC 
1473			    add hl, bc         ; Increment HL to point to start of data block 
1473			    add hl, de         ; HL = HL + DE (total size) 
1473			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to start of data block 
1473			 
1473			    ; Save pointer to allocated block in HL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma5" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			malloc_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3           ; Size of management overhead 
1473			    add hl, bc         ; Move to the next block 
1473			    inc de             ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e            ; Load low byte of heap end address 
1473			    cp (hl)            ; Compare with low byte of current address 
1473			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1473			    ld a, d            ; Load high byte of heap end address 
1473			    cp 0               ; Check if it's zero (end of memory) 
1473			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, allocation failed 
1473			    xor a              ; Set result to NULL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma6" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			malloc_exit: 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma7" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			; Internal Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free_internal: 
1473			    ld de, (heap_start) ; Load start of heap into DE 
1473			    ld bc, 0            ; Initialize counter 
1473			 
1473			free_search_loop: 
1473			    ; Check if current block contains the pointer 
1473			    ld a, l             ; Load low byte of pointer 
1473			    cp (hl+1)           ; Compare with high byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			    ld a, h             ; Load high byte of pointer 
1473			    cp (hl+2)           ; Compare with low byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			 
1473			    ; Mark block as free 
1473			    ld (hl), 0          ; Set status byte to indicate free block 
1473			    ret                 ; Return 
1473			 
1473			free_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3            ; Size of management overhead 
1473			    add hl, bc          ; Move to the next block 
1473			    inc de              ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e             ; Load low byte of heap end address 
1473			    cp (hl)             ; Compare with low byte of current address 
1473			    jr nz, free_search_loop  ; If not equal, continue searching 
1473			    ld a, d             ; Load high byte of heap end address 
1473			    cp 0                ; Check if it's zero (end of memory) 
1473			    jr nz, free_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, pointer is not found in heap 
1473			    ret 
1473			 
1473			free_exit: 
1473			    ret                 ; Return 
1473			 
1473			; Define heap start and end addresses 
1473			;heap_start:    .dw 0xC000   ; Start of heap 
1473			;heap_end:      .dw 0xE000   ; End of heap 
1473			 
1473			endif 
1473			 
1473			 
1473			if MALLOC_1 
1473			 
1473			 
1473			 
1473			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1473			 
1473			;moved to firmware.asm 
1473			;heap_start        .equ  0x9000      ; Starting address of heap 
1473			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1473			 
1473			;      .org 0 
1473			;      jp    main 
1473			 
1473			 
1473			;      .org  0x100 
1473			;main: 
1473			;      ld    HL, 0x8100 
1473			;      ld    SP, HL 
1473			; 
1473			;      call  heap_init 
1473			; 
1473			;      ; Make some allocations 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9004 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9014 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9024 
1473			; 
1473			;      ; Free some allocations 
1473			;      ld    HL, 0x9014 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9004 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9024 
1473			;      call  free 
1473			; 
1473			; 
1473			;      halt 
1473			 
1473			 
1473			;------------------------------------------------------------------------------ 
1473			;     heap_init                                                               : 
1473			;                                                                             : 
1473			; Description                                                                 : 
1473			;     Initialise the heap and make it ready for malloc and free operations.   : 
1473			;                                                                             : 
1473			;     The heap is maintained as a linked list, starting with an initial       : 
1473			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1473			;     the first free block in the heap. Each block then points to the next    : 
1473			;     free block within the heap, and the free list ends at the first block   : 
1473			;     with a null pointer to the next free block.                             : 
1473			;                                                                             : 
1473			; Parameters                                                                  : 
1473			;     Inputs are compile-time only. Two defines which specify the starting    : 
1473			;     address of the heap and its size are required, along with a memory      : 
1473			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1473			;     principally stores a pointer to the first free block in the heap.       : 
1473			;                                                                             : 
1473			; Returns                                                                     : 
1473			;     Nothing                                                                 : 
1473			;------------------------------------------------------------------------------ 
1473			heap_init: 
1473 e5			      push  HL 
1474			 
1474			      ; Initialise free list struct 
1474 21 0e 80		      ld    HL, heap_start 
1477 22 0a 80		      ld    (free_list), HL 
147a 21 00 00		      ld    HL, 0 
147d 22 0c 80		      ld    (free_list+2), HL 
1480			 
1480			      ; Insert first free block at bottom of heap, consumes entire heap 
1480 21 a1 f1		      ld    HL, heap_start+heap_size-4 
1483 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1486 21 93 71		      ld    HL, heap_size-4 
1489 22 10 80		      ld    (heap_start+2), HL      ; Block size 
148c			 
148c			      ; Insert end of free list block at top of heap - two null words will 
148c			      ; terminate the free list 
148c 21 00 00		      ld    HL, 0 
148f 22 a3 f1		      ld    (heap_start+heap_size-2), HL 
1492 22 a1 f1		      ld    (heap_start+heap_size-4), HL 
1495			 
1495 e1			      pop   HL 
1496			 
1496 c9			      ret 
1497			 
1497			 
1497			;------------------------------------------------------------------------------ 
1497			;     malloc                                                                  : 
1497			;                                                                             : 
1497			; Description                                                                 : 
1497			;     Allocates the wanted space from the heap and returns the address of the : 
1497			;     first useable byte of the allocation.                                   : 
1497			;                                                                             : 
1497			;     Allocations can happen in one of two ways:                              : 
1497			;                                                                             : 
1497			;     1. A free block may be found which is the exact size wanted. In this    : 
1497			;        case the block is removed from the free list and retuedn to the      : 
1497			;        caller.                                                              : 
1497			;     2. A free block may be found which is larger than the size wanted. In   : 
1497			;        this case, the larger block is split into two. The first portion of  : 
1497			;        this block will become the requested space by the malloc call and    : 
1497			;        is returned to the caller. The second portion becomes a new free     : 
1497			;        block, and the free list is adjusted to maintain continuity via this : 
1497			;        newly created block.                                                 : 
1497			;                                                                             : 
1497			;     malloc does not set any initial value in the allocated space, the       : 
1497			;     caller is required to do this as required.                              : 
1497			;                                                                             : 
1497			;     This implementation of malloc uses the stack exclusively, and is        : 
1497			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1497			;     advisable to disable interrupts before calling malloc, and recommended  : 
1497			;     to avoid the use of malloc inside ISRs in general.                      : 
1497			;                                                                             : 
1497			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1497			;                                                                             : 
1497			; Parameters                                                                  : 
1497			;     HL  Number of bytes wanted                                              : 
1497			;                                                                             : 
1497			; Returns                                                                     : 
1497			;     HL  Address of the first useable byte of the allocation                 : 
1497			;                                                                             : 
1497			; Flags                                                                       : 
1497			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1497			;                                                                             : 
1497			; Stack frame                                                                 : 
1497			;       |             |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     BC      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     DE      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     IX      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |  prev_free  |                                                       : 
1497			;   +4  +-------------+                                                       : 
1497			;       |  this_free  |                                                       : 
1497			;   +2  +-------------+                                                       : 
1497			;       |  next_free  |                                                       : 
1497			;   +0  +-------------+                                                       : 
1497			;       |             |                                                       : 
1497			;                                                                             : 
1497			;------------------------------------------------------------------------------ 
1497			 
1497			 
1497			;malloc: 
1497			; 
1497			;	SAVESP ON 1 
1497			; 
1497			;	call malloc_code 
1497			; 
1497			;	CHECKSP ON 1 
1497			;	ret 
1497			 
1497			 
1497			malloc: 
1497 c5			      push  BC 
1498 d5			      push  DE 
1499 dd e5		      push  IX 
149b			if DEBUG_FORTH_MALLOC_HIGH 
149b			call malloc_guard_entry 
149b			endif 
149b			 
149b					if DEBUG_FORTH_MALLOC 
149b						DMARK "mal" 
149b						CALLMONITOR 
149b					endif 
149b 7c			      ld    A, H                    ; Exit if no space requested 
149c b5			      or    L 
149d ca 5c 15		      jp    Z, malloc_early_exit 
14a0			 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			; 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			 
14a0			 
14a0			 
14a0			 
14a0					if DEBUG_FORTH_MALLOC 
14a0						DMARK "maA" 
14a0						CALLMONITOR 
14a0					endif 
14a0			      ; Set up stack frame 
14a0 eb			      ex    DE, HL 
14a1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14a4 39			      add   HL, SP 
14a5 f9			      ld    SP, HL 
14a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14aa dd 39		      add   IX, SP 
14ac			 
14ac			      ; Setup initial state 
14ac 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14af 19			      add   HL, DE 
14b0			 
14b0 44			      ld    B, H                    ; Move want to BC 
14b1 4d			      ld    C, L 
14b2			 
14b2 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
14b5 dd 75 04		      ld    (IX+4), L 
14b8 dd 74 05		      ld    (IX+5), H 
14bb			 
14bb 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14bc 23			      inc   HL 
14bd 56			      ld    D, (HL) 
14be dd 73 02		      ld    (IX+2), E 
14c1 dd 72 03		      ld    (IX+3), D 
14c4 eb			      ex    DE, HL                  ; this_free ptr into HL 
14c5			 
14c5					if DEBUG_FORTH_MALLOC 
14c5						DMARK "maB" 
14c5						CALLMONITOR 
14c5					endif 
14c5			      ; Loop through free block list to find some space 
14c5			malloc_find_space: 
14c5 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
14c6 23			      inc   HL 
14c7 56			      ld    D, (HL) 
14c8			 
14c8 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
14c9 b3			      or    E 
14ca ca 56 15		      jp    Z, malloc_no_space 
14cd			 
14cd dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
14d0 dd 72 01		      ld    (IX+1), D 
14d3			 
14d3			      ; Does this block have enough space to make the allocation? 
14d3 23			      inc   HL                      ; Load free block size into DE 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7			 
14d7 eb			      ex    DE, HL                  ; Check size of block against want 
14d8 b7			      or    A                       ; Ensure carry flag clear 
14d9 ed 42		      sbc   HL, BC 
14db e5			      push  HL                      ; Store the result for later (new block size) 
14dc			 
14dc ca 2b 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
14df 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
14e1			 
14e1			      ; this_free block is not big enough, setup ptrs to test next free block 
14e1 e1			      pop   HL                      ; Discard previous result 
14e2			 
14e2 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
14e5 dd 66 03		      ld    H, (IX+3) 
14e8 dd 75 04		      ld    (IX+4), L 
14eb dd 74 05		      ld    (IX+5), H 
14ee			 
14ee dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4 dd 75 02		      ld    (IX+2), L 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa					if DEBUG_FORTH_MALLOC 
14fa						DMARK "MA>" 
14fa						CALLMONITOR 
14fa					endif 
14fa 18 c9		      jr    malloc_find_space 
14fc			 
14fc			      ; split a bigger block into two - requested size and remaining size 
14fc			malloc_alloc_split: 
14fc					if DEBUG_FORTH_MALLOC 
14fc						DMARK "MAs" 
14fc						CALLMONITOR 
14fc					endif 
14fc eb			      ex    DE, HL                  ; Calculate address of new free block 
14fd 2b			      dec   HL 
14fe 2b			      dec   HL 
14ff 2b			      dec   HL 
1500 09			      add   HL, BC 
1501			 
1501			      ; Create a new block and point it at next_free 
1501 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1504 dd 56 01		      ld    D, (IX+1) 
1507			 
1507 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1508 23			      inc   HL 
1509 72			      ld    (HL), D 
150a			 
150a d1			      pop   DE                      ; Store size of new block into new block 
150b 23			      inc   HL 
150c 73			      ld    (HL), E 
150d 23			      inc   HL 
150e 72			      ld    (HL), D 
150f			 
150f			      ; Update this_free ptr to point to new block 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511 2b			      dec   HL 
1512			 
1512 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1515 dd 56 03		      ld    D, (IX+3) 
1518			 
1518 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
151b dd 74 03		      ld    (IX+3), H 
151e			 
151e			      ; Modify this_free block to be allocation 
151e eb			      ex    DE, HL 
151f af			      xor   A                       ; Null the next block ptr of allocated block 
1520 77			      ld    (HL), A 
1521 23			      inc   HL 
1522 77			      ld    (HL), A 
1523			 
1523 23			      inc   HL                      ; Store want size into allocated block 
1524 71			      ld    (HL), C 
1525 23			      inc   HL 
1526 70			      ld    (HL), B 
1527 23			      inc   HL 
1528 e5			      push  HL                      ; Address of allocation to return 
1529			 
1529 18 19		      jr    malloc_update_links 
152b			 
152b			malloc_alloc_fit: 
152b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
152c			 
152c					if DEBUG_FORTH_MALLOC 
152c						DMARK "MAf" 
152c						CALLMONITOR 
152c					endif 
152c			      ; Modify this_free block to be allocation 
152c eb			      ex    DE, HL 
152d 2b			      dec   HL 
152e 2b			      dec   HL 
152f 2b			      dec   HL 
1530			 
1530 af			      xor   A                       ; Null the next block ptr of allocated block 
1531 77			      ld    (HL), A 
1532 23			      inc   HL 
1533 77			      ld    (HL), A 
1534			 
1534 23			      inc   HL                      ; Store address of allocation to return 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 e5			      push  HL 
1538			 
1538			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1538 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
153b dd 66 01		      ld    H, (IX+1) 
153e			 
153e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1541 dd 74 03		      ld    (IX+3), H 
1544			 
1544			 
1544			malloc_update_links: 
1544			      ; Update prev_free ptr to point to this_free 
1544 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1547 dd 66 05		      ld    H, (IX+5) 
154a			 
154a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
154d dd 56 03		      ld    D, (IX+3) 
1550			 
1550 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1551 23			      inc   HL 
1552 72			      ld    (HL), D 
1553			 
1553					if DEBUG_FORTH_MALLOC 
1553						DMARK "Mul" 
1553						CALLMONITOR 
1553					endif 
1553			      ; Clear the Z flag to indicate successful allocation 
1553 7a			      ld    A, D 
1554 b3			      or    E 
1555			 
1555 d1			      pop   DE                      ; Address of allocation 
1556					if DEBUG_FORTH_MALLOC 
1556						DMARK "MAu" 
1556						CALLMONITOR 
1556					endif 
1556			 
1556			malloc_no_space: 
1556 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1559 39			      add   HL, SP 
155a f9			      ld    SP, HL 
155b			 
155b eb			      ex    DE, HL                  ; Alloc addr into HL for return 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAN" 
155c						CALLMONITOR 
155c					endif 
155c			 
155c			malloc_early_exit: 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAx" 
155c						CALLMONITOR 
155c					endif 
155c dd e1		      pop   IX 
155e d1			      pop   DE 
155f c1			      pop   BC 
1560			 
1560			if DEBUG_FORTH_MALLOC_HIGH 
1560			call malloc_guard_exit 
1560			call malloc_guard_zerolen 
1560			endif 
1560 c9			      ret 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     free                                                                    : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1561			;     returned by malloc, otherwise the behaviour is undefined.               : 
1561			;                                                                             : 
1561			;     Where possible, directly adjacent free blocks will be merged together   : 
1561			;     into larger blocks to help ensure that the heap does not become         : 
1561			;     excessively fragmented.                                                 : 
1561			;                                                                             : 
1561			;     free does not clear or set any other value into the freed space, and    : 
1561			;     therefore its contents may be visible through subsequent malloc's. The  : 
1561			;     caller should clear the freed space as required.                        : 
1561			;                                                                             : 
1561			;     This implementation of free uses the stack exclusively, and is          : 
1561			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1561			;     advisable to disable interrupts before calling free, and recommended    : 
1561			;     to avoid the use of free inside ISRs in general.                        : 
1561			;                                                                             : 
1561			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     HL  Pointer to address of first byte of allocation to be freed          : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     Nothing                                                                 : 
1561			;                                                                             : 
1561			; Stack frame                                                                 : 
1561			;       |             |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     BC      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     DE      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     IX      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |  prev_free  |                                                       : 
1561			;   +2  +-------------+                                                       : 
1561			;       |  next_free  |                                                       : 
1561			;   +0  +-------------+                                                       : 
1561			;       |             |                                                       : 
1561			;                                                                             : 
1561			;------------------------------------------------------------------------------ 
1561			free: 
1561 c5			      push  BC 
1562 d5			      push  DE 
1563 dd e5		      push  IX 
1565			 
1565 7c			      ld    A, H                    ; Exit if ptr is null 
1566 b5			      or    L 
1567 ca 2b 16		      jp    Z, free_early_exit 
156a			 
156a			      ; Set up stack frame 
156a eb			      ex    DE, HL 
156b 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
156e 39			      add   HL, SP 
156f f9			      ld    SP, HL 
1570 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1574 dd 39		      add   IX, SP 
1576			 
1576			      ; The address in HL points to the start of the useable allocated space, 
1576			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1576			      ; address of the block itself. 
1576 eb			      ex    DE, HL 
1577 11 fc ff		      ld    DE, -4 
157a 19			      add   HL, DE 
157b			 
157b			      ; An allocated block must have a null next block pointer in it 
157b 7e			      ld    A, (HL) 
157c 23			      inc   HL 
157d b6			      or    (HL) 
157e c2 26 16		      jp    NZ, free_done 
1581			 
1581 2b			      dec   HL 
1582			 
1582 44			      ld    B, H                    ; Copy HL to BC 
1583 4d			      ld    C, L 
1584			 
1584			      ; Loop through the free list to find the first block with an address 
1584			      ; higher than the block being freed 
1584 21 0a 80		      ld    HL, free_list 
1587			 
1587			free_find_higher_block: 
1587 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1588 23			      inc   HL 
1589 56			      ld    D, (HL) 
158a 2b			      dec   HL 
158b			 
158b dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
158e dd 72 01		      ld    (IX+1), D 
1591 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1594 dd 74 03		      ld    (IX+3), H 
1597			 
1597 78			      ld    A, B                    ; Check if DE is greater than BC 
1598 ba			      cp    D                       ; Compare MSB first 
1599 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
159b 30 04		      jr    NC, free_find_higher_block_skip 
159d 79			      ld    A, C 
159e bb			      cp    E                       ; Then compare LSB 
159f 38 08		      jr    C, free_found_higher_block 
15a1			 
15a1			free_find_higher_block_skip: 
15a1 7a			      ld    A, D                    ; Reached the end of the free list? 
15a2 b3			      or    E 
15a3 ca 26 16		      jp    Z, free_done 
15a6			 
15a6 eb			      ex    DE, HL 
15a7			 
15a7 18 de		      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9 71			      ld    (HL), C                 ; Point prev free block to freed block 
15aa 23			      inc   HL 
15ab 70			      ld    (HL), B 
15ac			 
15ac 60			      ld    H, B                    ; Point freed block at next free block 
15ad 69			      ld    L, C 
15ae 73			      ld    (HL), E 
15af 23			      inc   HL 
15b0 72			      ld    (HL), D 
15b1			 
15b1			      ; Check if the freed block is adjacent to the next free block 
15b1 23			      inc   HL                      ; Load size of freed block into HL 
15b2 5e			      ld    E, (HL) 
15b3 23			      inc   HL 
15b4 56			      ld    D, (HL) 
15b5 eb			      ex    DE, HL 
15b6			 
15b6 09			      add   HL, BC                  ; Add addr of freed block and its size 
15b7			 
15b7 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ba dd 56 01		      ld    D, (IX+1) 
15bd			 
15bd b7			      or    A                       ; Clear the carry flag 
15be ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15c0 20 22		      jr    NZ, free_check_adjacent_to_prev 
15c2			 
15c2			      ; Freed block is adjacent to next, merge into one bigger block 
15c2 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15c3 5e			      ld    E, (HL) 
15c4 23			      inc   HL 
15c5 56			      ld    D, (HL) 
15c6 e5			      push  HL                      ; Save ptr to next block for later 
15c7			 
15c7 60			      ld    H, B                    ; Store ptr from next block into freed block 
15c8 69			      ld    L, C 
15c9 73			      ld    (HL), E 
15ca 23			      inc   HL 
15cb 72			      ld    (HL), D 
15cc			 
15cc e1			      pop   HL                      ; Restore ptr to next block 
15cd 23			      inc   HL                      ; Load size of next block into DE 
15ce 5e			      ld    E, (HL) 
15cf 23			      inc   HL 
15d0 56			      ld    D, (HL) 
15d1 d5			      push  DE                      ; Save next block size for later 
15d2			 
15d2 60			      ld    H, B                    ; Load size of freed block into HL 
15d3 69			      ld    L, C 
15d4 23			      inc   HL 
15d5 23			      inc   HL 
15d6 5e			      ld    E, (HL) 
15d7 23			      inc   HL 
15d8 56			      ld    D, (HL) 
15d9 eb			      ex    DE, HL 
15da			 
15da d1			      pop   DE                      ; Restore size of next block 
15db 19			      add   HL, DE                  ; Add sizes of both blocks 
15dc eb			      ex    DE, HL 
15dd			 
15dd 60			      ld    H, B                    ; Store new bigger size into freed block 
15de 69			      ld    L, C 
15df 23			      inc   HL 
15e0 23			      inc   HL 
15e1 73			      ld    (HL), E 
15e2 23			      inc   HL 
15e3 72			      ld    (HL), D 
15e4			 
15e4			free_check_adjacent_to_prev: 
15e4			      ; Check if the freed block is adjacent to the prev free block 
15e4 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e7 dd 66 03		      ld    H, (IX+3) 
15ea			 
15ea 23			      inc   HL                      ; Size of prev free block into DE 
15eb 23			      inc   HL 
15ec 5e			      ld    E, (HL) 
15ed 23			      inc   HL 
15ee 56			      ld    D, (HL) 
15ef 2b			      dec   HL 
15f0 2b			      dec   HL 
15f1 2b			      dec   HL 
15f2			 
15f2 19			      add   HL, DE                  ; Add prev block addr and size 
15f3			 
15f3 b7			      or    A                       ; Clear the carry flag 
15f4 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15f6 20 2e		      jr    NZ, free_done 
15f8			 
15f8			      ; Freed block is adjacent to prev, merge into one bigger block 
15f8 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15f9 69			      ld    L, C 
15fa 5e			      ld    E, (HL) 
15fb 23			      inc   HL 
15fc 56			      ld    D, (HL) 
15fd e5			      push  HL                      ; Save freed block ptr for later 
15fe			 
15fe dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1601 dd 66 03		      ld    H, (IX+3) 
1604 73			      ld    (HL), E 
1605 23			      inc   HL 
1606 72			      ld    (HL), D 
1607			 
1607 e1			      pop   HL                      ; Restore freed block ptr 
1608 23			      inc   HL                      ; Load size of freed block into DE 
1609 5e			      ld    E, (HL) 
160a 23			      inc   HL 
160b 56			      ld    D, (HL) 
160c d5			      push  DE                      ; Save freed block size for later 
160d			 
160d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1610 dd 66 03		      ld    H, (IX+3) 
1613 23			      inc   HL 
1614 23			      inc   HL 
1615 5e			      ld    E, (HL) 
1616 23			      inc   HL 
1617 56			      ld    D, (HL) 
1618			 
1618 e1			      pop   HL                      ; Add sizes of both blocks 
1619 19			      add   HL, DE 
161a eb			      ex    DE, HL 
161b			 
161b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
161e dd 66 03		      ld    H, (IX+3) 
1621 23			      inc   HL 
1622 23			      inc   HL 
1623 73			      ld    (HL), E 
1624 23			      inc   HL 
1625 72			      ld    (HL), D 
1626			 
1626			free_done: 
1626 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1629 39			      add   HL, SP 
162a f9			      ld    SP, HL 
162b			 
162b			free_early_exit: 
162b dd e1		      pop   IX 
162d d1			      pop   DE 
162e c1			      pop   BC 
162f			 
162f c9			      ret 
1630			 
1630			; moved to firmware.asm 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			;                  .dw   0 
1630			 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_3 
1630			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1630			;heap_start        .equ  0x9000      ; Starting address of heap 
1630			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1630			; 
1630			 ;     .org 0 
1630			  ;    jp    main 
1630			; 
1630			; 
1630			 ;     .org  0x100 
1630			;main: 
1630			 ;     ld    HL, 0x8100 
1630			  ;    ld    SP, HL 
1630			; 
1630			;      call  heap_init 
1630			 
1630			      ; Make some allocations 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9004 
1630			; 
1630			 ;     ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9014 
1630			 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9024 
1630			 
1630			      ; Free some allocations 
1630			;      ld    HL, 0x9014 
1630			;      call  free 
1630			 
1630			;      ld    HL, 0x9004 
1630			;      call  free 
1630			; 
1630			;      ld    HL, 0x9024 
1630			;      call  free 
1630			 
1630			 
1630			 ;     halt 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     heap_init                                                               : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Initialise the heap and make it ready for malloc and free operations.   : 
1630			;                                                                             : 
1630			;     The heap is maintained as a linked list, starting with an initial       : 
1630			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1630			;     the first free block in the heap. Each block then points to the next    : 
1630			;     free block within the heap, and the free list ends at the first block   : 
1630			;     with a null pointer to the next free block.                             : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     Inputs are compile-time only. Two defines which specify the starting    : 
1630			;     address of the heap and its size are required, along with a memory      : 
1630			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1630			;     principally stores a pointer to the first free block in the heap.       : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;------------------------------------------------------------------------------ 
1630			heap_init: 
1630			      push  HL 
1630			 
1630			      ; Initialise free list struct 
1630			      ld    HL, heap_start 
1630			      ld    (free_list), HL 
1630			      ld    HL, 0 
1630			      ld    (free_list+2), HL 
1630			 
1630			      ; Insert first free block at bottom of heap, consumes entire heap 
1630			      ld    HL, heap_start+heap_size-4 
1630			      ld    (heap_start), HL        ; Next block (end of free list) 
1630			      ld    HL, heap_size-4 
1630			      ld    (heap_start+2), HL      ; Block size 
1630			 
1630			      ; Insert end of free list block at top of heap - two null words will 
1630			      ; terminate the free list 
1630			      ld    HL, 0 
1630			      ld    (heap_start+heap_size-2), HL 
1630			      ld    (heap_start+heap_size-4), HL 
1630			 
1630			      pop   HL 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     malloc                                                                  : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Allocates the wanted space from the heap and returns the address of the : 
1630			;     first useable byte of the allocation.                                   : 
1630			;                                                                             : 
1630			;     Allocations can happen in one of two ways:                              : 
1630			;                                                                             : 
1630			;     1. A free block may be found which is the exact size wanted. In this    : 
1630			;        case the block is removed from the free list and retuedn to the      : 
1630			;        caller.                                                              : 
1630			;     2. A free block may be found which is larger than the size wanted. In   : 
1630			;        this case, the larger block is split into two. The first portion of  : 
1630			;        this block will become the requested space by the malloc call and    : 
1630			;        is returned to the caller. The second portion becomes a new free     : 
1630			;        block, and the free list is adjusted to maintain continuity via this : 
1630			;        newly created block.                                                 : 
1630			;                                                                             : 
1630			;     malloc does not set any initial value in the allocated space, the       : 
1630			;     caller is required to do this as required.                              : 
1630			;                                                                             : 
1630			;     This implementation of malloc uses the stack exclusively, and is        : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling malloc, and recommended  : 
1630			;     to avoid the use of malloc inside ISRs in general.                      : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Number of bytes wanted                                              : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     HL  Address of the first useable byte of the allocation                 : 
1630			;                                                                             : 
1630			; Flags                                                                       : 
1630			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +4  +-------------+                                                       : 
1630			;       |  this_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			malloc: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if no space requested 
1630			      or    L 
1630			      jp    Z, malloc_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; Setup initial state 
1630			      ld    HL, 4                   ; want must also include space used by block struct 
1630			      add   HL, DE 
1630			 
1630			      ld    B, H                    ; Move want to BC 
1630			      ld    C, L 
1630			 
1630			      ld    HL, free_list           ; Store prev_free ptr to stack 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    E, (HL)                 ; Store this_free ptr to stack 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ld    (IX+2), E 
1630			      ld    (IX+3), D 
1630			      ex    DE, HL                  ; this_free ptr into HL 
1630			 
1630			      ; Loop through free block list to find some space 
1630			malloc_find_space: 
1630			      ld    E, (HL)                 ; Load next_free ptr into DE 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1630			      or    E 
1630			      jp    Z, malloc_no_space 
1630			 
1630			      ld    (IX+0), E               ; Store next_free ptr to stack 
1630			      ld    (IX+1), D 
1630			 
1630			      ; Does this block have enough space to make the allocation? 
1630			      inc   HL                      ; Load free block size into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ex    DE, HL                  ; Check size of block against want 
1630			      or    A                       ; Ensure carry flag clear 
1630			      sbc   HL, BC 
1630			      push  HL                      ; Store the result for later (new block size) 
1630			 
1630			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1630			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1630			 
1630			      ; this_free block is not big enough, setup ptrs to test next free block 
1630			      pop   HL                      ; Discard previous result 
1630			 
1630			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1630			      ld    H, (IX+3) 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1630			      ld    H, (IX+1) 
1630			      ld    (IX+2), L 
1630			      ld    (IX+3), H 
1630			 
1630			      jr    malloc_find_space 
1630			 
1630			      ; split a bigger block into two - requested size and remaining size 
1630			malloc_alloc_split: 
1630			      ex    DE, HL                  ; Calculate address of new free block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      add   HL, BC 
1630			 
1630			      ; Create a new block and point it at next_free 
1630			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      ld    (HL), E                 ; Store next_free ptr into new block 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   DE                      ; Store size of new block into new block 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Update this_free ptr to point to new block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1630			      ld    (IX+3), H 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store want size into allocated block 
1630			      ld    (HL), C 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			      inc   HL 
1630			      push  HL                      ; Address of allocation to return 
1630			 
1630			      jr    malloc_update_links 
1630			 
1630			malloc_alloc_fit: 
1630			      pop   HL                      ; Dont need new block size, want is exact fit 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store address of allocation to return 
1630			      inc   HL 
1630			      inc   HL 
1630			      push  HL 
1630			 
1630			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1630			      ld    L, (IX+0)               ; next_free to HL 
1630			      ld    H, (IX+1) 
1630			 
1630			      ld    (IX+2), L               ; HL to this_free 
1630			      ld    (IX+3), H 
1630			 
1630			 
1630			malloc_update_links: 
1630			      ; Update prev_free ptr to point to this_free 
1630			      ld    L, (IX+4)               ; prev_free ptr to HL 
1630			      ld    H, (IX+5) 
1630			 
1630			      ld    E, (IX+2)               ; this_free ptr to DE 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (HL), E                 ; this_free ptr into prev_free 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Clear the Z flag to indicate successful allocation 
1630			      ld    A, D 
1630			      or    E 
1630			 
1630			      pop   DE                      ; Address of allocation 
1630			 
1630			malloc_no_space: 
1630			      ld    HL, 6                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			      ex    DE, HL                  ; Alloc addr into HL for return 
1630			 
1630			malloc_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     free                                                                    : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1630			;     returned by malloc, otherwise the behaviour is undefined.               : 
1630			;                                                                             : 
1630			;     Where possible, directly adjacent free blocks will be merged together   : 
1630			;     into larger blocks to help ensure that the heap does not become         : 
1630			;     excessively fragmented.                                                 : 
1630			;                                                                             : 
1630			;     free does not clear or set any other value into the freed space, and    : 
1630			;     therefore its contents may be visible through subsequent malloc's. The  : 
1630			;     caller should clear the freed space as required.                        : 
1630			;                                                                             : 
1630			;     This implementation of free uses the stack exclusively, and is          : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling free, and recommended    : 
1630			;     to avoid the use of free inside ISRs in general.                        : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Pointer to address of first byte of allocation to be freed          : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			free: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if ptr is null 
1630			      or    L 
1630			      jp    Z, free_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; The address in HL points to the start of the useable allocated space, 
1630			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1630			      ; address of the block itself. 
1630			      ex    DE, HL 
1630			      ld    DE, -4 
1630			      add   HL, DE 
1630			 
1630			      ; An allocated block must have a null next block pointer in it 
1630			      ld    A, (HL) 
1630			      inc   HL 
1630			      or    (HL) 
1630			      jp    NZ, free_done 
1630			 
1630			      dec   HL 
1630			 
1630			      ld    B, H                    ; Copy HL to BC 
1630			      ld    C, L 
1630			 
1630			      ; Loop through the free list to find the first block with an address 
1630			      ; higher than the block being freed 
1630			      ld    HL, free_list 
1630			 
1630			free_find_higher_block: 
1630			      ld    E, (HL)                 ; Load next ptr from free block 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			 
1630			      ld    (IX+0), E               ; Save ptr to next free block 
1630			      ld    (IX+1), D 
1630			      ld    (IX+2), L               ; Save ptr to prev free block 
1630			      ld    (IX+3), H 
1630			 
1630			      ld    A, B                    ; Check if DE is greater than BC 
1630			      cp    D                       ; Compare MSB first 
1630			      jr    Z, $+4                  ; MSB the same, compare LSB 
1630			      jr    NC, free_find_higher_block_skip 
1630			      ld    A, C 
1630			      cp    E                       ; Then compare LSB 
1630			      jr    C, free_found_higher_block 
1630			 
1630			free_find_higher_block_skip: 
1630			      ld    A, D                    ; Reached the end of the free list? 
1630			      or    E 
1630			      jp    Z, free_done 
1630			 
1630			      ex    DE, HL 
1630			 
1630			      jr    free_find_higher_block 
1630			 
1630			free_found_higher_block: 
1630			      ; Insert freed block between prev and next free blocks 
1630			      ld    (HL), C                 ; Point prev free block to freed block 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			 
1630			      ld    H, B                    ; Point freed block at next free block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Check if the freed block is adjacent to the next free block 
1630			      inc   HL                      ; Load size of freed block into HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      add   HL, BC                  ; Add addr of freed block and its size 
1630			 
1630			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_check_adjacent_to_prev 
1630			 
1630			      ; Freed block is adjacent to next, merge into one bigger block 
1630			      ex    DE, HL                  ; Load next ptr from next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save ptr to next block for later 
1630			 
1630			      ld    H, B                    ; Store ptr from next block into freed block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore ptr to next block 
1630			      inc   HL                      ; Load size of next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save next block size for later 
1630			 
1630			      ld    H, B                    ; Load size of freed block into HL 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      pop   DE                      ; Restore size of next block 
1630			      add   HL, DE                  ; Add sizes of both blocks 
1630			      ex    DE, HL 
1630			 
1630			      ld    H, B                    ; Store new bigger size into freed block 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_check_adjacent_to_prev: 
1630			      ; Check if the freed block is adjacent to the prev free block 
1630			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1630			      ld    H, (IX+3) 
1630			 
1630			      inc   HL                      ; Size of prev free block into DE 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      add   HL, DE                  ; Add prev block addr and size 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_done 
1630			 
1630			      ; Freed block is adjacent to prev, merge into one bigger block 
1630			      ld    H, B                    ; Load next ptr from freed block into DE 
1630			      ld    L, C 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save freed block ptr for later 
1630			 
1630			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1630			      ld    H, (IX+3) 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore freed block ptr 
1630			      inc   HL                      ; Load size of freed block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save freed block size for later 
1630			 
1630			      ld    L, (IX+2)               ; Load size of prev block into DE 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      pop   HL                      ; Add sizes of both blocks 
1630			      add   HL, DE 
1630			      ex    DE, HL 
1630			 
1630			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_done: 
1630			      ld    HL, 4                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			free_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;      .org 0x8000 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			 ;                 .dw   0 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_4 
1630			 
1630			; My memory allocation code. Very very simple.... 
1630			; allocate space under 250 chars 
1630			 
1630			heap_init: 
1630				; init start of heap as zero 
1630				;  
1630			 
1630				ld hl, heap_start 
1630				ld a, 0 
1630				ld (hl), a      ; empty block 
1630				inc hl 
1630				ld a, 0 
1630				ld (hl), a      ; length of block 
1630				; write end of list 
1630				inc hl 
1630				ld a,(hl) 
1630				inc hl 
1630				ld a,(hl) 
1630				 
1630			 
1630				; init some malloc vars 
1630			 
1630				ld hl, 0 
1630				ld (free_list), hl       ; store last malloc location 
1630			 
1630				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1630				ld a, 0 
1630				ld (hl), a 
1630			 
1630			 
1630				ld hl, heap_start 
1630				;  
1630				  
1630				ret 
1630			 
1630			 
1630			;    free block marker 
1630			;    requested size  
1630			;    pointer to next block 
1630			;    .... 
1630			;    next block marker 
1630			 
1630			 
1630			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1630			; 
1630			 
1630			 
1630			malloc:  
1630				push de 
1630				push bc 
1630				push af 
1630			 
1630				; hl space required 
1630				 
1630				ld c, l    ; hold space   (TODO only a max of 255) 
1630			 
1630			;	inc c     ; TODO BUG need to fix memory leak on push str 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			 
1630			 
1630			 
1630				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1630			 
1630				ld a, (free_list+3) 
1630				cp 0 
1630				jr z, .contheap 
1630			 
1630				ld hl, (free_list)     ; get last alloc 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mrs" 
1630						CALLMONITOR 
1630					endif 
1630				jr .startalloc 
1630			 
1630			.contheap: 
1630				ld hl, heap_start 
1630			 
1630			.startalloc: 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mym" 
1630						CALLMONITOR 
1630					endif 
1630			.findblock: 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmf" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630				ld a,(hl)  
1630				; if byte is zero then clear to use 
1630			 
1630				cp 0 
1630				jr z, .foundemptyblock 
1630			 
1630				; if byte is not clear 
1630				;     then byte is offset to next block 
1630			 
1630				inc hl 
1630				ld a, (hl) ; get size 
1630			.nextblock:	inc hl 
1630					ld e, (hl) 
1630					inc hl 
1630					ld d, (hl) 
1630					ex de, hl 
1630			;	inc hl  ; move past the store space 
1630			;	inc hl  ; move past zero index  
1630			 
1630				; TODO detect no more space 
1630			 
1630				push hl 
1630				ld de, heap_end 
1630				call cmp16 
1630				pop hl 
1630				jr nc, .nospace 
1630			 
1630				jr .findblock 
1630			 
1630			.nospace: ld hl, 0 
1630				jp .exit 
1630			 
1630			 
1630			.foundemptyblock:	 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mme" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; TODO has block enough space if reusing??? 
1630			 
1630				;  
1630			 
1630			; see if this block has been previously used 
1630				inc hl 
1630				ld a, (hl) 
1630				dec hl 
1630				cp 0 
1630				jr z, .newblock 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meR" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; no reusing previously allocated block 
1630			 
1630			; is it smaller than previously used? 
1630				 
1630				inc hl    ; move to size 
1630				ld a, c 
1630				sub (hl)        ; we want c < (hl) 
1630				dec hl    ; move back to marker 
1630			        jr z, .findblock 
1630			 
1630				; update with the new size which should be lower 
1630			 
1630			        ;inc  hl   ; negate next move. move back to size  
1630			 
1630			.newblock: 
1630				; need to be at marker here 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meN" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			 
1630				ld a, c 
1630			 
1630				ld (free_list+3), a	 ; flag resume from last malloc  
1630				ld (free_list), hl    ; save out last location 
1630			 
1630			 
1630				;inc a     ; space for length byte 
1630				ld (hl), a     ; save block in use marker 
1630			 
1630				inc hl   ; move to space marker 
1630				ld (hl), a    ; save new space 
1630			 
1630				inc hl   ; move to start of allocated area 
1630				 
1630			;	push hl     ; save where we are - 1  
1630			 
1630			;	inc hl  ; move past zero index  
1630				; skip space to set down new marker 
1630			 
1630				; provide some extra space for now 
1630			 
1630				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1630				inc a 
1630				inc a 
1630			 
1630				push hl   ; save where we are in the node block 
1630			 
1630				call addatohl 
1630			 
1630				; write linked list point 
1630			 
1630				pop de     ; get our node position 
1630				ex de, hl 
1630			 
1630				ld (hl), e 
1630				inc hl 
1630				ld (hl), d 
1630			 
1630				inc hl 
1630			 
1630				; now at start of allocated data so save pointer 
1630			 
1630				push hl 
1630			 
1630				; jump to position of next node and setup empty header in DE 
1630			 
1630				ex de, hl 
1630			 
1630			;	inc hl ; move past end of block 
1630			 
1630				ld a, 0 
1630				ld (hl), a   ; empty marker 
1630				inc hl 
1630				ld (hl), a   ; size 
1630				inc hl  
1630				ld (hl), a   ; ptr 
1630				inc hl 
1630				ld (hl), a   ; ptr 
1630			 
1630			 
1630				pop hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmr" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			.exit: 
1630				pop af 
1630				pop bc 
1630				pop de  
1630				ret 
1630			 
1630			 
1630			 
1630			 
1630			free:  
1630				push hl 
1630				push af 
1630				; get address in hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "fre" 
1630						CALLMONITOR 
1630					endif 
1630				; data is at hl - move to block count 
1630				dec hl 
1630				dec hl    ; get past pointer 
1630				dec hl 
1630			 
1630				ld a, (hl)    ; need this for a validation check 
1630			 
1630				dec hl    ; move to block marker 
1630			 
1630				; now check that the block count and block marker are the same  
1630			        ; this checks that we are on a malloc node and not random memory 
1630			        ; OK a faint chance this could be a problem but rare - famous last words! 
1630			 
1630				ld c, a 
1630				ld a, (hl)    
1630			 
1630				cp c 
1630				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1630			 
1630				; yes good chance we are on a malloc node 
1630			 
1630				ld a, 0      
1630				ld (hl), a   ; mark as free 
1630			 
1630				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1630			 
1630			.freeignore:  
1630			 
1630				pop af 
1630				pop hl 
1630			 
1630				ret 
1630			 
1630			 
1630			 
1630			endif 
1630			 
1630			; eof 
# End of file firmware_memory.asm
1630			  
1630			; device C  
1630			; Now handled by SPI  
1630			;if SOUND_ENABLE  
1630			;	include "firmware_sound.asm"  
1630			;endif  
1630			  
1630			include "firmware_diags.asm"  
1630			; Hardware diags menu 
1630			 
1630			 
1630			config: 
1630			 
1630 3e 00			ld a, 0 
1632 21 5b 16			ld hl, .configmn 
1635 cd cd 0d			call menu 
1638			 
1638 fe 00			cp 0 
163a c8				ret z 
163b			 
163b			;	cp 1 
163b			;	call z, .savetostore 
163b			 
163b fe 01			cp 1 
163d			if STARTUP_V1 
163d				call z, .selautoload 
163d			endif 
163d			 
163d			if STARTUP_V2 
163d cc 69 16			call z, .enautoload 
1640			endif 
1640 fe 02			cp 2 
1642 cc 80 16			call z, .disautoload 
1645			;	cp 3 
1645			;	call z, .selbank 
1645 fe 03			cp 3 
1647 cc fa 18			call z, .debug_tog 
164a fe 04			cp 4 
164c cc 48 1a			call z, .bpsgo 
164f fe 05			cp 5 
1651 cc 23 19			call z, hardware_diags 
1654			if STARTUP_V2 
1654 fe 06			cp 6 
1656 cc ac 16			call z, create_startup 
1659			endif 
1659 18 d5			jr config 
165b			 
165b			.configmn: 
165b			;	dw prom_c3 
165b 36 1c			dw prom_c2 
165d 4c 1c			dw prom_c2a 
165f			;	dw prom_c2b 
165f			;	dw prom_c4 
165f bb 1c			dw prom_m4 
1661 d6 1c			dw prom_m4b 
1663 de 1c			dw prom_c1 
1665			if STARTUP_V2 
1665 ed 1c			dw prom_c9 
1667			endif 
1667 00 00			dw 0 
1669				 
1669			 
1669			if STARTUP_V2 
1669			.enautoload: 
1669				if STORAGE_SE 
1669 3e fe			ld a, $fe      ; bit 0 clear 
166b 32 5d fa			ld (spi_device), a 
166e			 
166e cd 17 05			call storage_get_block_0 
1671			 
1671 3e 01			ld a, 1 
1673 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
1676			 
1676 21 00 00				ld hl, 0 
1679 11 77 fa				ld de, store_page 
167c cd cb 04			call storage_write_block	 ; save update 
167f				else 
167f			 
167f				ld hl, prom_notav 
167f				ld de, prom_empty 
167f				call info_panel 
167f				endif 
167f			 
167f			 
167f c9				ret 
1680			endif 
1680			 
1680			.disautoload: 
1680				if STORAGE_SE 
1680 3e fe			ld a, $fe      ; bit 0 clear 
1682 32 5d fa			ld (spi_device), a 
1685			 
1685 cd 17 05			call storage_get_block_0 
1688			 
1688 3e 00			ld a, 0 
168a 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
168d			 
168d 21 00 00				ld hl, 0 
1690 11 77 fa				ld de, store_page 
1693 cd cb 04			call storage_write_block	 ; save update 
1696				else 
1696			 
1696				ld hl, prom_notav 
1696				ld de, prom_empty 
1696				call info_panel 
1696				endif 
1696			 
1696			 
1696 c9				ret 
1697			 
1697			if STARTUP_V1 
1697			 
1697			; Select auto start 
1697			 
1697			.selautoload: 
1697			 
1697				 
1697				if STORAGE_SE 
1697			 
1697					call config_dir 
1697				        ld hl, scratch 
1697					ld a, 0 
1697					call menu 
1697			 
1697					cp 0 
1697					ret z 
1697			 
1697					dec a 
1697			 
1697			 
1697					; locate menu option 
1697			 
1697					ld hl, scratch 
1697					call table_lookup 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALl" 
1697						CALLMONITOR 
1697					endif 
1697					; with the pointer to the menu it, the byte following the zero term is the file id 
1697			 
1697					ld a, 0 
1697					ld bc, 50   ; max of bytes to look at 
1697					cpir  
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALb" 
1697						CALLMONITOR 
1697					endif 
1697					;inc hl 
1697			 
1697					ld a, (hl)   ; file id 
1697					 
1697				        ; save bank and file ids 
1697			 
1697					push af 
1697			 
1697			; TODO need to save to block 0 on bank 1	 
1697			 
1697					call storage_get_block_0 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "AL0" 
1697						CALLMONITOR 
1697					endif 
1697					pop af 
1697			 
1697					ld (store_page+STORE_0_FILERUN),a 
1697					 
1697					; save bank id 
1697			 
1697					ld a,(spi_device) 
1697					ld (store_page+STORE_0_BANKRUN),a 
1697			 
1697					; enable auto run of store file 
1697			 
1697					ld a, 1 
1697					ld (store_page+STORE_0_AUTOFILE),a 
1697			 
1697					; save buffer 
1697			 
1697					ld hl, 0 
1697					ld de, store_page 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALw" 
1697						CALLMONITOR 
1697					endif 
1697				call storage_write_block	 ; save update 
1697			  
1697			 
1697			 
1697			 
1697					ld hl, scratch 
1697					call config_fdir 
1697			 
1697				else 
1697			 
1697				ld hl, prom_notav 
1697				ld de, prom_empty 
1697				call info_panel 
1697			 
1697				endif 
1697				ret 
1697			endif 
1697			 
1697			 
1697			; Select storage bank 
1697			 
1697			.selbank: 
1697			 
1697			;	if STORAGE_SE 
1697			;	else 
1697			 
1697 21 02 1d			ld hl, prom_notav 
169a 11 18 1d			ld de, prom_empty 
169d cd 2d 0d			call info_panel 
16a0			;	endif 
16a0				 
16a0 c9				ret 
16a1			 
16a1			if STORAGE_SE 
16a1			 
16a1			.config_ldir:   
16a1				; Load storage bank labels into menu array 
16a1			 
16a1				 
16a1			 
16a1			 
16a1 c9				ret 
16a2			 
16a2			 
16a2			endif 
16a2			 
16a2			 
16a2			; Save user words to storage 
16a2			 
16a2			.savetostore: 
16a2			 
16a2			;	if STORAGE_SE 
16a2			; 
16a2			;		call config_dir 
16a2			;	        ld hl, scratch 
16a2			;		ld a, 0 
16a2			;		call menu 
16a2			;		 
16a2			;		ld hl, scratch 
16a2			;		call config_fdir 
16a2			; 
16a2			;	else 
16a2			 
16a2 21 02 1d			ld hl, prom_notav 
16a5 11 18 1d			ld de, prom_empty 
16a8 cd 2d 0d			call info_panel 
16ab			 
16ab			;	endif 
16ab			 
16ab c9				ret 
16ac			 
16ac			if STARTUP_V2 
16ac			 
16ac			create_startup: 
16ac			 
16ac 3e 00			ld a, 0 
16ae 21 21 18			ld hl, .crstart 
16b1 cd cd 0d			call menu 
16b4			 
16b4 fe 00			cp 0 
16b6 c8				ret z 
16b7			 
16b7 fe 01			cp 1 
16b9 cc e6 16			call z, .genlsword 
16bc fe 02			cp 2 
16be cc f0 16			call z, .genedword 
16c1			 
16c1 fe 03			cp 3 
16c3 cc fa 16			call z, .gendemword 
16c6			 
16c6 fe 04			cp 4 
16c8 cc 04 17			call z, .genutlword 
16cb fe 05			cp 5 
16cd cc 0e 17			call z, .genspiword 
16d0 fe 06			cp 6 
16d2 cc 18 17			call z, .genkeyword 
16d5 fe 07			cp 7 
16d7 cc dc 16			call z, .gensoundword 
16da 18 d0			jr create_startup 
16dc			 
16dc			.gensoundword: 
16dc 21 a6 1c			ld hl, crs_sound 
16df 11 65 17			ld de, .soundworddef 
16e2 cd 22 17			call .genfile 
16e5 c9				ret 
16e6			.genlsword: 
16e6 21 63 1c			ld hl, crs_s1 
16e9 11 8d 17			ld de, .lsworddef 
16ec cd 22 17			call .genfile 
16ef c9				ret 
16f0			 
16f0			.genedword: 
16f0 11 91 17			ld de, .edworddef 
16f3 21 6c 1c			ld hl, crs_s2 
16f6 cd 22 17			call .genfile 
16f9 c9				ret 
16fa			 
16fa			.gendemword: 
16fa 11 99 17			ld de, .demoworddef 
16fd 21 75 1c			ld hl, crs_s3 
1700 cd 22 17			call .genfile 
1703 c9				ret 
1704			 
1704			.genutlword: 
1704 21 84 1c			ld hl, crs_s4 
1707 11 79 17			ld de, .utilwordef 
170a cd 22 17			call .genfile 
170d c9				ret 
170e			.genspiword: 
170e 21 8b 1c			ld hl, crs_s5 
1711 11 df 17			ld de, .spiworddef 
1714 cd 22 17			call .genfile 
1717 c9				ret 
1718			.genkeyword: 
1718 21 97 1c			ld hl, crs_s6 
171b 11 f5 17			ld de, .keyworddef 
171e cd 22 17			call .genfile 
1721 c9				ret 
1722			 
1722			; hl - points to file name 
1722			; de - points to strings to add to file 
1722			 
1722			.genfile: 
1722 e5				push hl 
1723 d5				push de 
1724			 
1724 cd 9c 0d			call clear_display 
1727 3e 00			ld a, display_row_1 
1729 11 54 17			ld de, .genfiletxt 
172c cd af 0d			call str_at_display 
172f cd bf 0d			call update_display 
1732			 
1732 d1				pop de 
1733 e1				pop hl 
1734			 
1734			 
1734 d5				push de 
1735 cd 69 08			call storage_create 
1738				; id in hl 
1738 d1				pop de   ; table of strings to add 
1739			 
1739			.genloop: 
1739			 
1739 e5				push hl ; save id for next time around 
173a d5				push de ; save de for next time around 
173b			 
173b eb				ex de, hl 
173c cd 44 24			call loadwordinhl 
173f eb				ex de, hl 
1740			 
1740				; need hl to be the id 
1740				; need de to be the string ptr 
1740				 
1740 cd 56 0b			call storage_append 
1743			 
1743 d1				pop de 
1744 e1				pop hl 
1745			 
1745 13				inc de 
1746 13				inc de 
1747			 
1747 1a				ld a,(de) 
1748 fe 00			cp 0 
174a 20 ed			jr nz, .genloop 
174c 13				inc de 
174d 1a				ld a, (de) 
174e 1b				dec de 
174f fe 00			cp 0 
1751 20 e6			jr nz, .genloop	 
1753			 
1753 c9				ret 
1754			 
1754 .. 00		.genfiletxt:  db "Creating file...",0 
1765			 
1765			.soundworddef: 
1765 22 6a			dw sound1 
1767 46 6a			dw sound2 
1769 76 6a			dw sound3 
176b 9b 6a			dw sound4 
176d a8 6a			dw sound5 
176f b5 6a			dw sound6 
1771 c2 6a			dw sound7 
1773 cf 6a			dw sound8 
1775 e7 6a			dw sound9 
1777 00 00			dw 0 
1779			 
1779			.utilwordef: 
1779 73 63			dw strncpy 
177b 4e 63			dw type 
177d 1a 63			dw clrstack 
177f d3 62			dw longread 
1781 d4 63			dw start1 
1783 e4 63			dw start2 
1785 f5 63			dw start3b 
1787 70 64			dw start3c 
1789 d0 64			dw list 
178b 00 00			dw 0 
178d			 
178d			.lsworddef: 
178d f5 63			dw start3b 
178f 00 00			dw 0 
1791			 
1791			.edworddef: 
1791 5c 5f			dw edit1 
1793 7d 5f			dw edit2 
1795 b2 5f			dw edit3 
1797 00 00			dw 0 
1799			 
1799			.demoworddef: 
1799 18 69			dw test5 
179b 50 69			dw test6 
179d 88 69			dw test7 
179f 9c 69			dw test8 
17a1 c8 69			dw test9 
17a3 de 69			dw test10 
17a5 fe 6a			dw game1 
17a7 0f 6b			dw game1a 
17a9 71 6b			dw game1b 
17ab a6 6b			dw game1c 
17ad dc 6b			dw game1d 
17af 0d 6c			dw game1s 
17b1 21 6c			dw game1t 
17b3 36 6c			dw game1f 
17b5 6a 6c			dw game1z 
17b7 ae 6c			dw game1zz 
17b9 17 6d			dw ssv2 
17bb 4d 6d			dw ssv3 
17bd 69 6d			dw ssv4 
17bf 85 6d			dw ssv5 
17c1 9e 6d			dw ssv1 
17c3 e6 6d			dw ssv1cpm	 
17c5 3d 6e			dw game2b 
17c7 ab 6e			dw game2bf 
17c9 f5 6e			dw game2mba 
17cb 8b 6f			dw game2mbas	 
17cd b0 6f			dw game2mbht 
17cf bf 6f			dw game2mbms 
17d1 cd 6f			dw game2mb 
17d3 4a 70			dw game3w 
17d5 78 70			dw game3p 
17d7 96 70			dw game3sc 
17d9 c7 70			dw game3vsi 
17db f3 70			dw game3vs 
17dd 00 00			dw 0 
17df			 
17df			 
17df			.spiworddef: 
17df			 
17df ea 5f		    dw spi1 
17e1 43 60		    dw spi2 
17e3 d1 60		    dw spi3 
17e5 79 60		    dw spi4 
17e7 a4 60		    dw spi5 
17e9 37 61		    dw spi6 
17eb 8c 61		    dw spi7 
17ed			 
17ed e4 61		    dw spi8 
17ef 03 62		    dw spi9 
17f1 5b 62		    dw spi10 
17f3 00 00		    dw 0 
17f5			 
17f5			.keyworddef: 
17f5			 
17f5 32 71			dw keyup 
17f7 40 71			dw keydown 
17f9 50 71			dw keyleft 
17fb 60 71			dw keyright 
17fd 71 71			dw 	keyf1 
17ff 7f 71			dw keyf2 
1801 8d 71			dw keyf3 
1803 9b 71			dw keyf4 
1805 a9 71			dw keyf5 
1807 b7 71			dw keyf6 
1809 c5 71			dw keyf7 
180b d3 71			dw keyf8 
180d e1 71			dw keyf9 
180f ef 71			dw keyf10 
1811 fe 71			dw keyf11 
1813 0d 72			dw keyf12 
1815 1c 72			dw keytab 
1817 2b 72			dw keycr 
1819 39 72			dw keyhome 
181b 49 72			dw keyend 
181d 58 72			dw keybs 
181f 00 00			dw 0 
1821			 
1821			.crstart: 
1821 63 1c			dw crs_s1 
1823 6c 1c			dw crs_s2 
1825 75 1c			dw crs_s3 
1827 84 1c			dw crs_s4 
1829 8b 1c			dw crs_s5 
182b 97 1c			dw crs_s6 
182d a6 1c			dw crs_sound 
182f 00 00			dw 0 
1831			 
1831			endif 
1831			 
1831			 
1831			if STORAGE_SE 
1831			 
1831			config_fdir: 
1831				; using the scratch dir go through and release the memory allocated for each string 
1831				 
1831 21 be f1			ld hl, scratch 
1834 5e			.cfdir:	ld e,(hl) 
1835 23				inc hl 
1836 56				ld d,(hl) 
1837 23				inc hl 
1838			 
1838 eb				ex de, hl 
1839 cd f9 0f			call ishlzero 
183c c8				ret z     ; return on null pointer 
183d cd 61 15			call free 
1840 eb				ex de, hl 
1841 18 f1			jr .cfdir 
1843			 
1843			 
1843 c9				ret 
1844			 
1844			 
1844			config_dir: 
1844			 
1844				; for the config menus that need to build a directory of storage call this routine 
1844				; it will construct a menu in scratch to pass to menu 
1844			 
1844				; open storage device 
1844			 
1844				; execute DIR to build a list of files and their ids into scratch in menu format 
1844				; once the menu has finished then will need to call config_fdir to release the strings 
1844				 
1844				; c = number items 
1844			 
1844				 
1844 cd 17 05			call storage_get_block_0 
1847			 
1847 21 77 fa			ld hl, store_page     ; get current id count 
184a 46				ld b, (hl) 
184b 0e 00			ld c, 0    ; count of files   
184d			 
184d			 
184d 21 be f1			ld hl, scratch 
1850 22 6e fa			ld (store_tmp2), hl    ; location to poke strings 
1853			 
1853				; check for empty drive 
1853			 
1853 3e 00			ld a, 0 
1855 b8				cp b 
1856 ca f0 18			jp z, .dirdone 
1859			 
1859				 
1859					if DEBUG_FORTH_WORDS 
1859						DMARK "Cdc" 
1859 f5				push af  
185a 3a 6e 18			ld a, (.dmark)  
185d 32 68 fe			ld (debug_mark),a  
1860 3a 6f 18			ld a, (.dmark+1)  
1863 32 69 fe			ld (debug_mark+1),a  
1866 3a 70 18			ld a, (.dmark+2)  
1869 32 6a fe			ld (debug_mark+2),a  
186c 18 03			jr .pastdmark  
186e ..			.dmark: db "Cdc"  
1871 f1			.pastdmark: pop af  
1872			endm  
# End of macro DMARK
1872						CALLMONITOR 
1872 cd 6c fe			call debug_vector  
1875				endm  
# End of macro CALLMONITOR
1875					endif 
1875			 
1875			 
1875			.diritem:	 
1875 c5				push bc 
1876				; for each of the current ids do a search for them and if found push to stack 
1876			 
1876 21 40 00				ld hl, STORE_BLOCK_PHY 
1879 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
187b 58					ld e,b 
187c			 
187c cd 99 07				call storage_findnextid 
187f			 
187f			 
187f					; if found hl will be non zero 
187f			 
187f cd f9 0f				call ishlzero 
1882 28 69				jr z, .dirnotfound 
1884			 
1884					; increase count 
1884			 
1884 c1					pop bc	 
1885 0c					inc c 
1886 c5					push bc 
1887					 
1887			 
1887					; get file header and push the file name 
1887			 
1887 11 77 fa				ld de, store_page 
188a cd 66 04				call storage_read_block 
188d			 
188d					; push file id to stack 
188d				 
188d 3a 77 fa				ld a, (store_page) 
1890 26 00				ld h, 0 
1892 6f					ld l, a 
1893			 
1893					;call forth_push_numhl 
1893					; TODO store id 
1893			 
1893 e5					push hl 
1894			 
1894					; push extent count to stack  
1894				 
1894 21 7a fa				ld hl, store_page+3 
1897			 
1897					; get file name length 
1897			 
1897 cd 2e 14				call strlenz   
189a			 
189a 23					inc hl   ; cover zero term 
189b 23					inc hl  ; stick the id at the end of the area 
189c			 
189c e5					push hl 
189d c1					pop bc    ; move length to bc 
189e			 
189e cd 97 14				call malloc 
18a1			 
18a1					; TODO save malloc area to scratch 
18a1			 
18a1 eb					ex de, hl 
18a2 2a 6e fa				ld hl, (store_tmp2) 
18a5 73					ld (hl), e 
18a6 23					inc hl 
18a7 72					ld (hl), d 
18a8 23					inc hl 
18a9 22 6e fa				ld (store_tmp2), hl 
18ac			 
18ac					 
18ac			 
18ac					;pop hl   ; get source 
18ac			;		ex de, hl    ; swap aronund	 
18ac			 
18ac 21 7a fa				ld hl, store_page+3 
18af					if DEBUG_FORTH_WORDS 
18af						DMARK "CFd" 
18af f5				push af  
18b0 3a c4 18			ld a, (.dmark)  
18b3 32 68 fe			ld (debug_mark),a  
18b6 3a c5 18			ld a, (.dmark+1)  
18b9 32 69 fe			ld (debug_mark+1),a  
18bc 3a c6 18			ld a, (.dmark+2)  
18bf 32 6a fe			ld (debug_mark+2),a  
18c2 18 03			jr .pastdmark  
18c4 ..			.dmark: db "CFd"  
18c7 f1			.pastdmark: pop af  
18c8			endm  
# End of macro DMARK
18c8						CALLMONITOR 
18c8 cd 6c fe			call debug_vector  
18cb				endm  
# End of macro CALLMONITOR
18cb					endif 
18cb ed b0				ldir 
18cd			 
18cd					; de is past string, move back one and store id 
18cd					 
18cd 1b					dec de 
18ce			 
18ce					; store file id 
18ce			 
18ce e1					pop hl 
18cf eb					ex de,hl 
18d0 73					ld (hl), e 
18d1			 
18d1					if DEBUG_FORTH_WORDS 
18d1						DMARK "Cdi" 
18d1 f5				push af  
18d2 3a e6 18			ld a, (.dmark)  
18d5 32 68 fe			ld (debug_mark),a  
18d8 3a e7 18			ld a, (.dmark+1)  
18db 32 69 fe			ld (debug_mark+1),a  
18de 3a e8 18			ld a, (.dmark+2)  
18e1 32 6a fe			ld (debug_mark+2),a  
18e4 18 03			jr .pastdmark  
18e6 ..			.dmark: db "Cdi"  
18e9 f1			.pastdmark: pop af  
18ea			endm  
# End of macro DMARK
18ea						CALLMONITOR 
18ea cd 6c fe			call debug_vector  
18ed				endm  
# End of macro CALLMONITOR
18ed					endif 
18ed					 
18ed			.dirnotfound: 
18ed c1					pop bc     
18ee 10 85				djnz .diritem 
18f0				 
18f0			.dirdone:	 
18f0			 
18f0 3e 00				ld a, 0 
18f2 2a 6e fa				ld hl, (store_tmp2) 
18f5 77					ld (hl), a 
18f6 23					inc hl 
18f7 77					ld (hl), a 
18f8 23					inc hl 
18f9					; push a count of the dir items found 
18f9			 
18f9			;		ld h, 0 
18f9			;		ld l, c 
18f9			 
18f9 c9				ret 
18fa			 
18fa			endif 
18fa			 
18fa			 
18fa			; Settings 
18fa			; Run  
18fa			 
18fa			 
18fa			 
18fa			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18fa			;;hd_menu2:   db "        2: Editor",0   
18fa			;hd_menu2:   db "        2: Editor       6: Menu",0   
18fa			;hd_menu3:   db "        3: Storage",0 
18fa			;hd_menu4:   db "0=quit  4: Debug",0 
18fa			;hd_don:     db "ON",0 
18fa			;hd_doff:     db "OFF",0 
18fa			; 
18fa			; 
18fa			; 
18fa			;hardware_diags_old:       
18fa			; 
18fa			;.diagmenu: 
18fa			;	call clear_display 
18fa			;	ld a, display_row_1 
18fa			;	ld de, hd_menu1 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_2 
18fa			;	ld de, hd_menu2 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_3 
18fa			;	ld de, hd_menu3 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a,  display_row_4 
18fa			;	ld de, hd_menu4 
18fa			;	call str_at_display 
18fa			; 
18fa			;	; display debug state 
18fa			; 
18fa			;	ld de, hd_don 
18fa			;	ld a, (os_view_disable) 
18fa			;	cp 0 
18fa			;	jr z, .distog 
18fa			;	ld de, hd_doff 
18fa			;.distog: ld a, display_row_4+17 
18fa			;	call str_at_display 
18fa			; 
18fa			;	call update_display 
18fa			; 
18fa			;	call cin_wait 
18fa			; 
18fa			; 
18fa			; 
18fa			;	cp '4' 
18fa			;	jr nz, .diagn1 
18fa			; 
18fa			;	; debug toggle 
18fa			; 
18fa			;	ld a, (os_view_disable) 
18fa			;	ld b, '*' 
18fa			;	cp 0 
18fa			;	jr z, .debtog 
18fa			;	ld b, 0 
18fa			;.debtog:	 
18fa			;	ld a,b 
18fa			;	ld (os_view_disable),a 
18fa			; 
18fa			;.diagn1: cp '0' 
18fa			;	 ret z 
18fa			; 
18fa			;;	cp '1' 
18fa			;;       jp z, matrix	 
18fa			;;   TODO keyboard matrix test 
18fa			; 
18fa			;	cp '2' 
18fa			;	jp z, .diagedit 
18fa			; 
18fa			;;	cp '6' 
18fa			;;	jp z, .menutest 
18fa			;;if ENABLE_BASIC 
18fa			;;	cp '6' 
18fa			;;	jp z, basic 
18fa			;;endif 
18fa			 ; 
18fa			;	jp .diagmenu 
18fa			; 
18fa			; 
18fa			;	ret 
18fa			 
18fa			 
18fa			.debug_tog: 
18fa 21 44 19			ld hl, .menudebug 
18fd				 
18fd			;	ld a, (os_view_disable) 
18fd			;	cp '*' 
18fd 3a 6c fe			ld a,(debug_vector) 
1900 fe c9			cp $C9   ; RET 
1902 20 04			jr nz,.tdon  
1904 3e 01			ld a, 1 
1906 18 02			jr .tog1 
1908 3e 00		.tdon: ld a, 0 
190a			 
190a			.tog1: 
190a cd cd 0d			call menu 
190d fe 00			cp 0 
190f c8				ret z 
1910 fe 01			cp 1    ; disable debug 
1912 28 04			jr z, .dtog0 
1914 3e 2a			ld a, '*' 
1916 18 05			jr .dtogset 
1918			.dtog0:  
1918				;ld a, 0 
1918 cd 36 1a			call bp_on 
191b 18 dd			jr .debug_tog 
191d			.dtogset:  
191d				; ld (os_view_disable), a 
191d cd 42 1a			call bp_off 
1920 c3 fa 18			jp .debug_tog 
1923			 
1923			 
1923			hardware_diags:       
1923			 
1923			.diagm: 
1923 21 36 19			ld hl, .menuitems 
1926 3e 00			ld a, 0 
1928 cd cd 0d			call menu 
192b			 
192b fe 00		         cp 0 
192d c8				 ret z 
192e			 
192e fe 02			cp 2 
1930 ca 8f 19			jp z, .diagedit 
1933			 
1933			;	cp '6' 
1933			;	jp z, .menutest 
1933			;if ENABLE_BASIC 
1933			;	cp '6' 
1933			;	jp z, basic 
1933			;endif 
1933			  
1933 c3 23 19			jp .diagm 
1936			 
1936				 
1936 4a 19		.menuitems:   	dw .m1 
1938 55 19				dw .m2 
193a 5c 19				dw .m3 
193c 64 19				dw .m5 
193e 6a 19				dw .m5a 
1940 73 19				dw .m5b 
1942 00 00				dw 0 
1944			 
1944			.menudebug: 
1944 7c 19				dw .m6 
1946 85 19				dw .m7 
1948 00 00				dw 0 
194a			 
194a .. 00		.m1:   db "Key Matrix",0 
1955 .. 00		.m2:   db "Editor",0 
195c .. 00		.m3:   db "Storage",0 
1964 .. 00		.m5:   db "Sound",0 
196a .. 00		.m5a:  db "RAM Test",0 
1973 .. 00		.m5b:  db "LCD Test",0 
197c			 
197c .. 00		.m6:   db "Debug ON",0 
1985 .. 00		.m7:   db "Debug OFF",0 
198f			 
198f			; debug editor 
198f			 
198f			.diagedit: 
198f			 
198f 21 be f1			ld hl, scratch 
1992			;	ld bc, 250 
1992			;	ldir 
1992				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1992 3e 00			ld a, 0 
1994 77				ld (hl), a 
1995 23				inc hl 
1996 77				ld (hl), a 
1997 23				inc hl 
1998 77				ld (hl), a 
1999			 
1999 cd 9c 0d		        call clear_display 
199c cd bf 0d			call update_display 
199f				;ld a, 1 
199f				;ld (hardware_diag), a 
199f			.diloop: 
199f 3e 00			ld a, display_row_1 
19a1 0e 00			ld c, 0 
19a3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19a5 1e 28			ld e, 40 
19a7			 
19a7 21 be f1			ld hl, scratch	 
19aa cd fd 0f			call input_str 
19ad			 
19ad 3e 28			ld a, display_row_2 
19af 11 be f1			ld de, scratch 
19b2 cd af 0d			call str_at_display 
19b5 cd bf 0d			call update_display 
19b8			 
19b8 c3 9f 19			jp .diloop 
19bb			 
19bb			 
19bb			; pass word in hl 
19bb			; a has display location 
19bb			display_word_at: 
19bb f5				push af 
19bc e5				push hl 
19bd 7c				ld a,h 
19be 21 c3 f4			ld hl, os_word_scratch 
19c1 cd d1 12			call hexout 
19c4 e1				pop hl 
19c5 7d				ld a,l 
19c6 21 c5 f4			ld hl, os_word_scratch+2 
19c9 cd d1 12			call hexout 
19cc 21 c7 f4			ld hl, os_word_scratch+4 
19cf 3e 00			ld a,0 
19d1 77				ld (hl),a 
19d2 11 c3 f4			ld de,os_word_scratch 
19d5 f1				pop af 
19d6 cd af 0d				call str_at_display 
19d9 c9				ret 
19da			 
19da			display_ptr_state: 
19da			 
19da				; to restore afterwards 
19da			 
19da d5				push de 
19db c5				push bc 
19dc e5				push hl 
19dd f5				push af 
19de			 
19de				; for use in here 
19de			 
19de			;	push bc 
19de			;	push de 
19de			;	push hl 
19de			;	push af 
19de			 
19de cd 9c 0d			call clear_display 
19e1			 
19e1 11 b9 1b			ld de, .ptrstate 
19e4 3e 00			ld a, display_row_1 
19e6 cd af 0d			call str_at_display 
19e9			 
19e9				; display debug step 
19e9			 
19e9			 
19e9 11 68 fe			ld de, debug_mark 
19ec 3e 26			ld a, display_row_1+display_cols-2 
19ee cd af 0d			call str_at_display 
19f1			 
19f1				; display a 
19f1 11 c3 1b			ld de, .ptrcliptr 
19f4 3e 28			ld a, display_row_2 
19f6 cd af 0d			call str_at_display 
19f9			 
19f9 f1				pop af 
19fa 2a 3d fa			ld hl,(cli_ptr) 
19fd 3e 30			ld a, display_row_2+8 
19ff cd bb 19			call display_word_at 
1a02			 
1a02			 
1a02				; display hl 
1a02			 
1a02			 
1a02 11 cb 1b			ld de, .ptrclioptr 
1a05 3e 32			ld a, display_row_2+10 
1a07 cd af 0d			call str_at_display 
1a0a			; 
1a0a			;	pop hl 
1a0a 3e 35			ld a, display_row_2+13 
1a0c 2a 3b fa			ld hl,(cli_origptr) 
1a0f cd bb 19			call display_word_at 
1a12			; 
1a12			;	 
1a12			;	; display de 
1a12			 
1a12			;	ld de, .regstatede 
1a12			;	ld a, display_row_3 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop de 
1a12			;	ld h,d 
1a12			;	ld l, e 
1a12			;	ld a, display_row_3+3 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12			;	ld de, .regstatebc 
1a12			;	ld a, display_row_3+10 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop bc 
1a12			;	ld h,b 
1a12			;	ld l, c 
1a12			;	ld a, display_row_3+13 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display dsp 
1a12			 
1a12			;	ld de, .regstatedsp 
1a12			;	ld a, display_row_4 
1a12			;	call str_at_display 
1a12			 
1a12				 
1a12			;	ld hl,(cli_data_sp) 
1a12			;	ld a, display_row_4+4 
1a12			;	call display_word_at 
1a12			 
1a12				; display rsp 
1a12			 
1a12 11 fa 1b			ld de, .regstatersp 
1a15 3e 82			ld a, display_row_4+10 
1a17 cd af 0d			call str_at_display 
1a1a			 
1a1a				 
1a1a 2a ef f9			ld hl,(cli_ret_sp) 
1a1d 3e 86			ld a, display_row_4+14 
1a1f cd bb 19			call display_word_at 
1a22			 
1a22 cd bf 0d			call update_display 
1a25			 
1a25 cd df 0c			call delay1s 
1a28 cd df 0c			call delay1s 
1a2b cd df 0c			call delay1s 
1a2e			 
1a2e			 
1a2e cd 8d 20			call next_page_prompt 
1a31			 
1a31				; restore  
1a31			 
1a31 f1				pop af 
1a32 e1				pop hl 
1a33 c1				pop bc 
1a34 d1				pop de 
1a35 c9				ret 
1a36			 
1a36			; Update the break point vector so that the user can hook a new routine 
1a36			 
1a36			bp_on: 
1a36 3e c3			ld a, $c3    ; JP 
1a38 32 6c fe			ld (debug_vector), a 
1a3b 21 48 1a			ld hl, break_point_state 
1a3e 22 6d fe			ld (debug_vector+1), hl 
1a41 c9				ret 
1a42			 
1a42			bp_off: 
1a42 3e c9			ld a, $c9    ; RET 
1a44 32 6c fe			ld (debug_vector), a 
1a47 c9				ret 
1a48			 
1a48			 
1a48			break_point_state: 
1a48			;	push af 
1a48			; 
1a48			;	; see if disabled 
1a48			; 
1a48			;	ld a, (os_view_disable) 
1a48			;	cp '*' 
1a48			;	jr nz, .bpsgo 
1a48			;	pop af 
1a48			;	ret 
1a48			 
1a48			.bpsgo: 
1a48			;	pop af 
1a48 f5				push af 
1a49 22 ac f1			ld (os_view_hl), hl 
1a4c ed 53 aa f1		ld (os_view_de), de 
1a50 ed 43 a8 f1		ld (os_view_bc), bc 
1a54 e5				push hl 
1a55 6f				ld l, a 
1a56 26 00			ld h, 0 
1a58 22 ae f1			ld (os_view_af),hl 
1a5b			 
1a5b 21 ae fd				ld hl, display_fb0 
1a5e 22 c9 fb				ld (display_fb_active), hl 
1a61 e1				pop hl	 
1a62			 
1a62 3e 31			ld a, '1' 
1a64 fe 2a		.bps1:  cp '*' 
1a66 cc 42 1a			call z, bp_off 
1a69			;	jr nz, .bps1b 
1a69			;	ld (os_view_disable),a 
1a69 fe 31		.bps1b:  cp '1' 
1a6b 20 14			jr nz, .bps2 
1a6d			 
1a6d				; display reg 
1a6d			 
1a6d				 
1a6d			 
1a6d 3a ae f1			ld a, (os_view_af) 
1a70 2a ac f1			ld hl, (os_view_hl) 
1a73 ed 5b aa f1		ld de, (os_view_de) 
1a77 ed 4b a8 f1		ld bc, (os_view_bc) 
1a7b cd 15 1b			call display_reg_state 
1a7e c3 01 1b			jp .bpschk 
1a81			 
1a81 fe 32		.bps2:  cp '2' 
1a83 20 08			jr nz, .bps3 
1a85				 
1a85				; display hl 
1a85 2a ac f1			ld hl, (os_view_hl) 
1a88 cd ff 1b			call display_dump_at_hl 
1a8b			 
1a8b 18 74			jr .bpschk 
1a8d			 
1a8d fe 33		.bps3:  cp '3' 
1a8f 20 08			jr nz, .bps4 
1a91			 
1a91			        ; display de 
1a91 2a aa f1			ld hl, (os_view_de) 
1a94 cd ff 1b			call display_dump_at_hl 
1a97			 
1a97 18 68			jr .bpschk 
1a99 fe 34		.bps4:  cp '4' 
1a9b 20 08			jr nz, .bps5 
1a9d			 
1a9d			        ; display bc 
1a9d 2a a8 f1			ld hl, (os_view_bc) 
1aa0 cd ff 1b			call display_dump_at_hl 
1aa3			 
1aa3 18 5c			jr .bpschk 
1aa5 fe 35		.bps5:  cp '5' 
1aa7 20 08		        jr nz, .bps7 
1aa9			 
1aa9				; display cur ptr 
1aa9 2a 3d fa			ld hl, (cli_ptr) 
1aac cd ff 1b			call display_dump_at_hl 
1aaf			 
1aaf 18 50			jr .bpschk 
1ab1 fe 36		.bps7:  cp '6' 
1ab3 20 08			jr nz, .bps8b 
1ab5				 
1ab5				; display cur orig ptr 
1ab5 2a 3b fa			ld hl, (cli_origptr) 
1ab8 cd ff 1b			call display_dump_at_hl 
1abb 18 44			jr .bpschk 
1abd fe 37		.bps8b:  cp '7' 
1abf 20 08			jr nz, .bps9 
1ac1				 
1ac1				; display dsp 
1ac1 2a eb f9			ld hl, (cli_data_sp) 
1ac4 cd ff 1b			call display_dump_at_hl 
1ac7			 
1ac7 18 38			jr .bpschk 
1ac9 fe 39		.bps9:  cp '9' 
1acb 20 05			jr nz, .bps8c 
1acd				 
1acd				; display SP 
1acd			;	ld hl, sp 
1acd cd ff 1b			call display_dump_at_hl 
1ad0			 
1ad0 18 2f			jr .bpschk 
1ad2 fe 38		.bps8c:  cp '8' 
1ad4 20 08			jr nz, .bps8d 
1ad6				 
1ad6				; display rsp 
1ad6 2a ef f9			ld hl, (cli_ret_sp) 
1ad9 cd ff 1b			call display_dump_at_hl 
1adc			 
1adc 18 23			jr .bpschk 
1ade fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1ae0 20 05			jr nz, .bps8 
1ae2 cd 5b 1e			call monitor 
1ae5			 
1ae5 18 1a			jr .bpschk 
1ae7 fe 30		.bps8:  cp '0' 
1ae9 20 16			jr nz, .bpschk 
1aeb			 
1aeb 21 0d fd				ld hl, display_fb1 
1aee 22 c9 fb				ld (display_fb_active), hl 
1af1 cd bf 0d				call update_display 
1af4			 
1af4				;ld a, (os_view_af) 
1af4 2a ac f1			ld hl, (os_view_hl) 
1af7 ed 5b aa f1		ld de, (os_view_de) 
1afb ed 4b a8 f1		ld bc, (os_view_bc) 
1aff f1				pop af 
1b00 c9				ret 
1b01			 
1b01			.bpschk:   
1b01 cd df 0c			call delay1s 
1b04 3e 9f		ld a,display_row_4 + display_cols - 1 
1b06 11 8b 20		        ld de, endprg 
1b09 cd af 0d			call str_at_display 
1b0c cd bf 0d			call update_display 
1b0f cd d3 79			call cin_wait 
1b12			 
1b12 c3 64 1a			jp .bps1 
1b15			 
1b15			 
1b15			display_reg_state: 
1b15			 
1b15				; to restore afterwards 
1b15			 
1b15 d5				push de 
1b16 c5				push bc 
1b17 e5				push hl 
1b18 f5				push af 
1b19			 
1b19				; for use in here 
1b19			 
1b19 c5				push bc 
1b1a d5				push de 
1b1b e5				push hl 
1b1c f5				push af 
1b1d			 
1b1d cd 9c 0d			call clear_display 
1b20			 
1b20 11 d5 1b			ld de, .regstate 
1b23 3e 00			ld a, display_row_1 
1b25 cd af 0d			call str_at_display 
1b28			 
1b28				; display debug step 
1b28			 
1b28			 
1b28 11 68 fe			ld de, debug_mark 
1b2b 3e 25			ld a, display_row_1+display_cols-3 
1b2d cd af 0d			call str_at_display 
1b30			 
1b30				; display a 
1b30 11 f1 1b			ld de, .regstatea 
1b33 3e 28			ld a, display_row_2 
1b35 cd af 0d			call str_at_display 
1b38			 
1b38 e1				pop hl 
1b39			;	ld h,0 
1b39			;	ld l, a 
1b39 3e 2b			ld a, display_row_2+3 
1b3b cd bb 19			call display_word_at 
1b3e			 
1b3e			 
1b3e				; display hl 
1b3e			 
1b3e			 
1b3e 11 e5 1b			ld de, .regstatehl 
1b41 3e 32			ld a, display_row_2+10 
1b43 cd af 0d			call str_at_display 
1b46			 
1b46 e1				pop hl 
1b47 3e 35			ld a, display_row_2+13 
1b49 cd bb 19			call display_word_at 
1b4c			 
1b4c				 
1b4c				; display de 
1b4c			 
1b4c 11 e9 1b			ld de, .regstatede 
1b4f 3e 50			ld a, display_row_3 
1b51 cd af 0d			call str_at_display 
1b54			 
1b54 e1				pop hl 
1b55			;	ld h,d 
1b55			;	ld l, e 
1b55 3e 53			ld a, display_row_3+3 
1b57 cd bb 19			call display_word_at 
1b5a			 
1b5a			 
1b5a				; display bc 
1b5a			 
1b5a 11 ed 1b			ld de, .regstatebc 
1b5d 3e 5a			ld a, display_row_3+10 
1b5f cd af 0d			call str_at_display 
1b62			 
1b62 e1				pop hl 
1b63			;	ld h,b 
1b63			;	ld l, c 
1b63 3e 5d			ld a, display_row_3+13 
1b65 cd bb 19			call display_word_at 
1b68			 
1b68			 
1b68				; display dsp 
1b68			 
1b68 11 f5 1b			ld de, .regstatedsp 
1b6b 3e 78			ld a, display_row_4 
1b6d cd af 0d			call str_at_display 
1b70			 
1b70				 
1b70 2a eb f9			ld hl,(cli_data_sp) 
1b73 3e 7c			ld a, display_row_4+4 
1b75 cd bb 19			call display_word_at 
1b78			 
1b78				; display rsp 
1b78			 
1b78 11 fa 1b			ld de, .regstatersp 
1b7b 3e 82			ld a, display_row_4+10 
1b7d cd af 0d			call str_at_display 
1b80			 
1b80				 
1b80 2a ef f9			ld hl,(cli_ret_sp) 
1b83 3e 86			ld a, display_row_4+14 
1b85 cd bb 19			call display_word_at 
1b88			 
1b88 cd bf 0d			call update_display 
1b8b			 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			 
1b8b			 
1b8b			;	call next_page_prompt 
1b8b			 
1b8b				; restore  
1b8b			 
1b8b f1				pop af 
1b8c e1				pop hl 
1b8d c1				pop bc 
1b8e d1				pop de 
1b8f c9				ret 
1b90			 
1b90 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ba4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1bb9 .. 00		.ptrstate:	db "Ptr State",0 
1bc3 .. 00		.ptrcliptr:     db "cli_ptr",0 
1bcb .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1bd5 .. 00		.regstate:	db "Reg State (1/0)",0 
1be5 .. 00		.regstatehl:	db "HL:",0 
1be9 .. 00		.regstatede:	db "DE:",0 
1bed .. 00		.regstatebc:	db "BC:",0 
1bf1 .. 00		.regstatea:	db "A :",0 
1bf5 .. 00		.regstatedsp:	db "DSP:",0 
1bfa .. 00		.regstatersp:	db "RSP:",0 
1bff			 
1bff			display_dump_at_hl: 
1bff e5				push hl 
1c00 d5				push de 
1c01 c5				push bc 
1c02 f5				push af 
1c03			 
1c03 22 e1 f4			ld (os_cur_ptr),hl	 
1c06 cd 9c 0d			call clear_display 
1c09 cd 95 1f			call dumpcont 
1c0c			;	call delay1s 
1c0c			;	call next_page_prompt 
1c0c			 
1c0c			 
1c0c f1				pop af 
1c0d c1				pop bc 
1c0e d1				pop de 
1c0f e1				pop hl 
1c10 c9				ret 
1c11			 
1c11			;if ENABLE_BASIC 
1c11			;	include "nascombasic.asm" 
1c11			;	basic: 
1c11			;	include "forth/FORTH.ASM" 
1c11			;endif 
1c11			 
1c11			; eof 
1c11			 
1c11			 
# End of file firmware_diags.asm
1c11			  
1c11			include "firmware_prompts.asm"  
1c11			; Prompts  
1c11			 
1c11			; boot messages 
1c11			 
1c11 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1c26 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1c36			 
1c36			 
1c36			; config menus 
1c36			 
1c36			;prom_c3: db "Add Dictionary To File",0 
1c36			 
1c36			if STARTUP_V1 
1c36			prom_c2: db "Select Autoload File",0 
1c36			prom_c2a: db "Disable Autoload File", 0 
1c36			endif 
1c36			 
1c36			if STARTUP_V2 
1c36 .. 00		prom_c2: db "Enable Autoload Files",0 
1c4c .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c63			 
1c63 .. 00		crs_s1: db "*ls-word", 0 
1c6c .. 00		crs_s2: db "*ed-word", 0 
1c75 .. 00		crs_s3: db "*Demo-Programs", 0 
1c84 .. 00		crs_s4: db "*Utils", 0 
1c8b .. 00		crs_s5: db "*SPI-Addons", 0 
1c97 .. 00		crs_s6: db "*Key-constants", 0 
1ca6 .. 00		crs_sound: db "*Sound-Util", 0 
1cb2			 
1cb2			 
1cb2			 
1cb2			endif 
1cb2			;prom_c2b: db "Select Storage Bank",0 
1cb2 .. 00		prom_c4: db "Settings",0 
1cbb .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cd6 .. 00		prom_m4b:   db "Monitor",0 
1cde .. 00		prom_c1: db "Hardware Diags",0 
1ced			 
1ced			 
1ced			if STARTUP_V2 
1ced .. 00		prom_c9: db "Create Startup Files",0 
1d02			endif 
1d02			 
1d02 .. 00		prom_notav:    db "Feature not available",0 
1d18 .. 00		prom_empty:    db "",0 
1d19			 
1d19			; eof 
1d19			 
# End of file firmware_prompts.asm
1d19			  
1d19			  
1d19			; eof  
1d19			  
# End of file firmware.asm
1d19			 
1d19			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1d19			;if BASE_KEV  
1d19			;baseram: equ 08000h 
1d19			;endif 
1d19			 
1d19			;if BASE_SC114 
1d19			;baseram:     equ    endofcode 
1d19			;endif 
1d19			 
1d19			 
1d19			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1d19			 
1d19			; start system 
1d19			 
1d19			coldstart: 
1d19				; set sp 
1d19				; di/ei 
1d19			 
1d19 f3				di 
1d1a 31 fd ff			ld sp, tos 
1d1d cd 5a 76			call init_nmi 
1d20			;	ei 
1d20			 
1d20				; init spinner 
1d20 3e 00			ld a,0 
1d22 32 c3 fb			ld (display_active), a 
1d25			 
1d25				; disable breakpoint by default 
1d25			 
1d25				;ld a,'*' 
1d25			;	ld a,' ' 
1d25			;	ld (os_view_disable),a 
1d25			 
1d25				; set break point vector as new break point on or off 
1d25 cd 42 1a			call bp_off 
1d28			 
1d28				; init hardware 
1d28			 
1d28				; init keyboard and screen hardware 
1d28			 
1d28 cd 69 00			call hardware_init 
1d2b			 
1d2b			 
1d2b cd df 0c			call delay1s 
1d2e 3e 58			ld a, display_row_3+8 
1d30 11 03 00			ld de, buildtime 
1d33 cd af 0d			call str_at_display 
1d36 cd bf 0d			call update_display 
1d39			 
1d39 cd df 0c			call delay1s 
1d3c cd df 0c			call delay1s 
1d3f cd df 0c			call delay1s 
1d42			 
1d42				; detect if any keys are held down to enable breakpoints at start up 
1d42			 
1d42 cd e4 79			call cin  
1d45 fe 00			cp 0 
1d47 28 03			jr z, .nokeys 
1d49			 
1d49				;call hardware_diags 
1d49 cd 30 16			call config 
1d4c			 
1d4c			;	ld de, .bpen 
1d4c			;	ld a, display_row_4 
1d4c			;	call str_at_display 
1d4c			;	call update_display 
1d4c			; 
1d4c			;	ld a,0 
1d4c			;	ld (os_view_disable),a 
1d4c			; 
1d4c			;.bpwait: 
1d4c			;	call cin 
1d4c			;	cp 0 
1d4c			;	jr z, .bpwait 
1d4c			;	jr .nokeys 
1d4c			; 
1d4c			; 
1d4c			;.bpen:  db "Break points enabled!",0 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			.nokeys: 
1d4c			 
1d4c			 
1d4c				 
1d4c			 
1d4c			;jp  testkey 
1d4c			 
1d4c			;call storage_get_block_0 
1d4c			; 
1d4c			;ld hl, 0 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c				 
1d4c			;ld hl, 10 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			;stop:	nop 
1d4c			;	jp stop 
1d4c			 
1d4c			 
1d4c			 
1d4c			main: 
1d4c cd 9c 0d			call clear_display 
1d4f cd bf 0d			call update_display 
1d52			 
1d52			 
1d52			 
1d52			;	call testlcd 
1d52			 
1d52			 
1d52			 
1d52 cd 92 24			call forth_init 
1d55			 
1d55			 
1d55			warmstart: 
1d55 cd 68 24			call forth_warmstart 
1d58			 
1d58				; run startup word load 
1d58			        ; TODO prevent this running at warmstart after crash  
1d58			 
1d58				if STARTUP_ENABLE 
1d58			 
1d58					if STARTUP_V1 
1d58			 
1d58						if STORAGE_SE 
1d58							call forth_autoload 
1d58						endif 
1d58						call forth_startup 
1d58					endif 
1d58			 
1d58					if STARTUP_V2 
1d58			 
1d58						if STORAGE_SE 
1d58 cd 88 74						call forth_autoload 
1d5b						else 
1d5b							call forth_startup 
1d5b						endif 
1d5b			 
1d5b			 
1d5b					endif 
1d5b			 
1d5b				endif 
1d5b			 
1d5b				; show free memory after boot 
1d5b 11 f5 1d			ld de, freeram 
1d5e 3e 00			ld a, display_row_1 
1d60 cd af 0d			call str_at_display 
1d63			 
1d63			; Or use heap_size word???? 
1d63 21 a5 f1			ld hl, heap_end 
1d66 11 0e 80			ld de, heap_start 
1d69 ed 52			sbc hl, de 
1d6b e5				push hl 
1d6c 7c				ld a,h	         	 
1d6d 21 c3 f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d70 cd d1 12			call hexout 
1d73 e1			   	pop hl 
1d74			 
1d74 7d				ld a,l 
1d75 21 c5 f4			ld hl, os_word_scratch+2 
1d78 cd d1 12			call hexout 
1d7b 21 c7 f4			ld hl, os_word_scratch+4 
1d7e 3e 00			ld a, 0 
1d80 77				ld (hl),a 
1d81 11 c3 f4			ld de, os_word_scratch 
1d84 3e 0d			ld a, display_row_1 + 13 
1d86 cd af 0d			call str_at_display 
1d89 cd bf 0d			call update_display 
1d8c			 
1d8c			 
1d8c				;call demo 
1d8c			 
1d8c			 
1d8c				; init scratch input area for cli commands 
1d8c			 
1d8c 21 e5 f4			ld hl, os_cli_cmd 
1d8f 3e 00			ld a,0 
1d91 77				ld (hl),a 
1d92 23				inc hl 
1d93 77				ld (hl),a 
1d94			 
1d94 3e 00			ld a,0 
1d96 32 e4 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d99			 
1d99 32 e1 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d9c 32 e2 f4			ld (os_cur_ptr+1),a	 
1d9f			 
1d9f 32 c3 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1da2 32 c4 f4			ld (os_word_scratch+1),a	 
1da5				 
1da5			 
1da5				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1da5 21 e5 f4			ld hl, os_cli_cmd 
1da8			 
1da8 3e 00			ld a, 0		 ; init cli input 
1daa 77				ld (hl), a 
1dab 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dad			cli: 
1dad				; show cli prompt 
1dad				;push af 
1dad				;ld a, 0 
1dad				;ld de, prompt 
1dad				;call str_at_display 
1dad			 
1dad				;call update_display 
1dad				;pop af 
1dad				;inc a 
1dad				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1dad 0e 00			ld c, 0 
1daf 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1db1 1e 28			ld e, 40 
1db3			 
1db3 21 e5 f4			ld hl, os_cli_cmd 
1db6			 
1db6				STACKFRAME OFF $fefe $9f9f 
1db6				if DEBUG_STACK_IMB 
1db6					if OFF 
1db6						exx 
1db6						ld de, $fefe 
1db6						ld a, d 
1db6						ld hl, curframe 
1db6						call hexout 
1db6						ld a, e 
1db6						ld hl, curframe+2 
1db6						call hexout 
1db6						ld hl, $fefe 
1db6						push hl 
1db6						ld hl, $9f9f 
1db6						push hl 
1db6						exx 
1db6					endif 
1db6				endif 
1db6			endm 
# End of macro STACKFRAME
1db6			 
1db6 cd fd 0f			call input_str 
1db9			 
1db9				STACKFRAMECHK OFF $fefe $9f9f 
1db9				if DEBUG_STACK_IMB 
1db9					if OFF 
1db9						exx 
1db9						ld hl, $9f9f 
1db9						pop de   ; $9f9f 
1db9						call cmp16 
1db9						jr nz, .spnosame 
1db9						ld hl, $fefe 
1db9						pop de   ; $fefe 
1db9						call cmp16 
1db9						jr z, .spfrsame 
1db9						.spnosame: call showsperror 
1db9						.spfrsame: nop 
1db9						exx 
1db9					endif 
1db9				endif 
1db9			endm 
# End of macro STACKFRAMECHK
1db9			 
1db9				; copy input to last command 
1db9			 
1db9 21 e5 f4			ld hl, os_cli_cmd 
1dbc 11 e4 f5			ld de, os_last_cmd 
1dbf 01 ff 00			ld bc, 255 
1dc2 ed b0			ldir 
1dc4			 
1dc4				; wipe current buffer 
1dc4			 
1dc4			;	ld a, 0 
1dc4			;	ld hl, os_cli_cmd 
1dc4			;	ld de, os_cli_cmd+1 
1dc4			;	ld bc, 254 
1dc4			;	ldir 
1dc4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1dc4			;	call strcpy 
1dc4			;	ld a, 0 
1dc4			;	ld (hl), a 
1dc4			;	inc hl 
1dc4			;	ld (hl), a 
1dc4			;	inc hl 
1dc4			;	ld (hl), a 
1dc4			 
1dc4				; switch frame buffer to program  
1dc4			 
1dc4 21 0d fd				ld hl, display_fb1 
1dc7 22 c9 fb				ld (display_fb_active), hl 
1dca			 
1dca			;	nop 
1dca				STACKFRAME ON $fbfe $8f9f 
1dca				if DEBUG_STACK_IMB 
1dca					if ON 
1dca						exx 
1dca						ld de, $fbfe 
1dca						ld a, d 
1dca						ld hl, curframe 
1dca						call hexout 
1dca						ld a, e 
1dca						ld hl, curframe+2 
1dca						call hexout 
1dca						ld hl, $fbfe 
1dca						push hl 
1dca						ld hl, $8f9f 
1dca						push hl 
1dca						exx 
1dca					endif 
1dca				endif 
1dca			endm 
# End of macro STACKFRAME
1dca				; first time into the parser so pass over the current scratch pad 
1dca 21 e5 f4			ld hl,os_cli_cmd 
1dcd				; tokenise the entered statement(s) in HL 
1dcd cd 10 25			call forthparse 
1dd0			        ; exec forth statements in top of return stack 
1dd0 cd 50 25			call forthexec 
1dd3				;call forthexec_cleanup 
1dd3			;	call parsenext 
1dd3			 
1dd3				STACKFRAMECHK ON $fbfe $8f9f 
1dd3				if DEBUG_STACK_IMB 
1dd3					if ON 
1dd3						exx 
1dd3						ld hl, $8f9f 
1dd3						pop de   ; $8f9f 
1dd3						call cmp16 
1dd3						jr nz, .spnosame 
1dd3						ld hl, $fbfe 
1dd3						pop de   ; $fbfe 
1dd3						call cmp16 
1dd3						jr z, .spfrsame 
1dd3						.spnosame: call showsperror 
1dd3						.spfrsame: nop 
1dd3						exx 
1dd3					endif 
1dd3				endif 
1dd3			endm 
# End of macro STACKFRAMECHK
1dd3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1dd3			 
1dd3 3e 78			ld a, display_row_4 
1dd5 11 07 1e			ld de, endprog 
1dd8			 
1dd8 cd bf 0d			call update_display		 
1ddb			 
1ddb cd 8d 20			call next_page_prompt 
1dde			 
1dde				; switch frame buffer to cli 
1dde			 
1dde 21 ae fd				ld hl, display_fb0 
1de1 22 c9 fb				ld (display_fb_active), hl 
1de4			 
1de4			 
1de4 cd 9c 0d		        call clear_display 
1de7 cd bf 0d			call update_display		 
1dea			 
1dea 21 e5 f4			ld hl, os_cli_cmd 
1ded			 
1ded 3e 00			ld a, 0		 ; init cli input 
1def 77				ld (hl), a 
1df0			 
1df0				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1df0			 
1df0				; now on last line 
1df0			 
1df0				; TODO scroll screen up 
1df0			 
1df0				; TODO instead just clear screen and place at top of screen 
1df0			 
1df0			;	ld a, 0 
1df0			;	ld (f_cursor_ptr),a 
1df0			 
1df0				;call clear_display 
1df0				;call update_display 
1df0			 
1df0				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1df0 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1df2 c3 ad 1d			jp cli 
1df5			 
1df5 .. 00		freeram: db "Free bytes: $",0 
1e03 ..			asc: db "1A2F" 
1e07 .. 00		endprog: db "End prog...",0 
1e13			 
1e13			testenter2:   
1e13 21 f0 f1			ld hl,scratch+50 
1e16 22 e1 f4			ld (os_cur_ptr),hl 
1e19 c3 ad 1d			jp cli 
1e1c			 
1e1c			testenter:  
1e1c			 
1e1c 21 03 1e			ld hl,asc 
1e1f			;	ld a,(hl) 
1e1f			;	call nibble2val 
1e1f cd 27 13			call get_byte 
1e22			 
1e22			 
1e22			;	ld a,(hl) 
1e22			;	call atohex 
1e22			 
1e22			;	call fourehexhl 
1e22 32 f0 f1			ld (scratch+50),a 
1e25			 
1e25			 
1e25			 
1e25 21 05 1e			ld hl,asc+2 
1e28			;	ld a, (hl) 
1e28			;	call nibble2val 
1e28 cd 27 13			call get_byte 
1e2b			 
1e2b			;	call fourehexhl 
1e2b 32 f2 f1			ld (scratch+52),a 
1e2e				 
1e2e 21 f0 f1			ld hl,scratch+50 
1e31 22 e1 f4			ld (os_cur_ptr),hl 
1e34 c3 ad 1d			jp cli 
1e37			 
1e37			enter:	 
1e37 3a c2 f1			ld a,(scratch+4) 
1e3a fe 00			cp 0 
1e3c 28 0c			jr z, .entercont 
1e3e				; no, not a null term line so has an address to work out.... 
1e3e			 
1e3e 21 c0 f1			ld hl,scratch+2 
1e41 cd 87 13			call get_word_hl 
1e44			 
1e44 22 e1 f4			ld (os_cur_ptr),hl	 
1e47 c3 ad 1d			jp cli 
1e4a			 
1e4a			 
1e4a			.entercont:  
1e4a			 
1e4a 21 c0 f1			ld hl, scratch+2 
1e4d cd 27 13			call get_byte 
1e50			 
1e50 2a e1 f4		   	ld hl,(os_cur_ptr) 
1e53 77					ld (hl),a 
1e54 23					inc hl 
1e55 22 e1 f4				ld (os_cur_ptr),hl 
1e58				 
1e58			; get byte  
1e58			 
1e58			 
1e58 c3 ad 1d			jp cli 
1e5b			 
1e5b			 
1e5b			; basic monitor support 
1e5b			 
1e5b			monitor: 
1e5b				;  
1e5b cd 9c 0d			call clear_display 
1e5e 3e 00			ld a, 0 
1e60 11 af 1e			ld de, .monprompt 
1e63 cd af 0d			call str_at_display 
1e66 cd bf 0d			call update_display 
1e69			 
1e69				; get a monitor command 
1e69			 
1e69 0e 00			ld c, 0     ; entry at top left 
1e6b 16 64			ld d, 100   ; max buffer size 
1e6d 1e 0f			ld e, 15    ; input scroll area 
1e6f 3e 00			ld a, 0     ; init string 
1e71 21 bc f3			ld hl, os_input 
1e74 77				ld (hl), a 
1e75 23				inc hl 
1e76 77				ld (hl), a 
1e77 21 bc f3			ld hl, os_input 
1e7a 3e 01			ld a, 1     ; init string 
1e7c cd fd 0f			call input_str 
1e7f			 
1e7f cd 9c 0d		        call clear_display 
1e82 cd bf 0d			call update_display		 
1e85			 
1e85 3a bc f3			ld a, (os_input) 
1e88 cd 25 14			call toUpper 
1e8b fe 48		        cp 'H' 
1e8d ca 14 1f		        jp z, .monhelp 
1e90 fe 44			cp 'D'		; dump 
1e92 ca 47 1f			jp z, .mondump	 
1e95 fe 43			cp 'C'		; dump 
1e97 ca 61 1f			jp z, .moncdump	 
1e9a fe 4d			cp 'M'		; dump 
1e9c ca b1 1e			jp z, .moneditstart 
1e9f fe 55			cp 'U'		; dump 
1ea1 ca bd 1e			jp z, .monedit	 
1ea4 fe 47			cp 'G'		; dump 
1ea6 ca 3d 1f			jp z, .monjump 
1ea9 fe 51			cp 'Q'		; dump 
1eab c8				ret z	 
1eac			 
1eac			 
1eac				; TODO "S" to access symbol by name and not need the address 
1eac				; TODO "F" to find a string in memory 
1eac			 
1eac c3 5b 1e			jp monitor 
1eaf			 
1eaf .. 00		.monprompt: db ">", 0 
1eb1			 
1eb1			.moneditstart: 
1eb1				; get starting address 
1eb1			 
1eb1 21 be f3			ld hl,os_input+2 
1eb4 cd 87 13			call get_word_hl 
1eb7			 
1eb7 22 e1 f4			ld (os_cur_ptr),hl	 
1eba			 
1eba c3 5b 1e			jp monitor 
1ebd			 
1ebd			.monedit: 
1ebd				; get byte to load 
1ebd			 
1ebd 21 be f3			ld hl,os_input+2 
1ec0 cd 27 13			call get_byte 
1ec3			 
1ec3				; get address to update 
1ec3 2a e1 f4			ld hl, (os_cur_ptr) 
1ec6			 
1ec6				; update byte 
1ec6			 
1ec6 77				ld (hl), a 
1ec7			 
1ec7				; move to next address and save it 
1ec7			 
1ec7 23				inc hl 
1ec8 22 e1 f4			ld (os_cur_ptr),hl	 
1ecb			 
1ecb c3 5b 1e			jp monitor 
1ece			 
1ece			 
1ece .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ee2 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1efe .. 00		.monhelptext3:  db "G-Call address",0 
1f0d .. 00		.monhelptext4:  db "Q-Quit",0 
1f14			        
1f14			.monhelp: 
1f14 3e 00			ld a, display_row_1 
1f16 11 ce 1e		        ld de, .monhelptext1 
1f19			 
1f19 cd af 0d			call str_at_display 
1f1c 3e 28			ld a, display_row_2 
1f1e 11 e2 1e		        ld de, .monhelptext2 
1f21					 
1f21 cd af 0d			call str_at_display 
1f24 3e 50			ld a, display_row_3 
1f26 11 fe 1e		        ld de, .monhelptext3 
1f29					 
1f29 cd af 0d			call str_at_display 
1f2c 3e 78			ld a, display_row_4 
1f2e 11 0d 1f		        ld de, .monhelptext4 
1f31 cd af 0d			call str_at_display 
1f34			 
1f34 cd bf 0d			call update_display		 
1f37			 
1f37 cd 8d 20			call next_page_prompt 
1f3a c3 5b 1e			jp monitor 
1f3d			 
1f3d			.monjump:    
1f3d 21 be f3			ld hl,os_input+2 
1f40 cd 87 13			call get_word_hl 
1f43			 
1f43 e9				jp (hl) 
1f44 c3 5b 1e			jp monitor 
1f47			 
1f47			.mondump:    
1f47 21 be f3			ld hl,os_input+2 
1f4a cd 87 13			call get_word_hl 
1f4d			 
1f4d 22 e1 f4			ld (os_cur_ptr),hl	 
1f50 cd 95 1f			call dumpcont 
1f53 3e 78			ld a, display_row_4 
1f55 11 07 1e			ld de, endprog 
1f58			 
1f58 cd bf 0d			call update_display		 
1f5b			 
1f5b cd 8d 20			call next_page_prompt 
1f5e c3 5b 1e			jp monitor 
1f61			.moncdump: 
1f61 cd 95 1f			call dumpcont 
1f64 3e 78			ld a, display_row_4 
1f66 11 07 1e			ld de, endprog 
1f69			 
1f69 cd bf 0d			call update_display		 
1f6c			 
1f6c cd 8d 20			call next_page_prompt 
1f6f c3 5b 1e			jp monitor 
1f72			 
1f72			 
1f72			; TODO symbol access  
1f72			 
1f72			.symbols:     ;; A list of symbols that can be called up  
1f72 ae fd			dw display_fb0 
1f74 .. 00			db "fb0",0  
1f78 77 fa		     	dw store_page 
1f7a .. 00			db "store_page",0 
1f85			 
1f85			 
1f85			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f85			 
1f85 3a bf f1			ld a,(scratch+1) 
1f88 fe 00			cp 0 
1f8a 28 09			jr z, dumpcont 
1f8c			 
1f8c				; no, not a null term line so has an address to work out.... 
1f8c			 
1f8c 21 c0 f1			ld hl,scratch+2 
1f8f cd 87 13			call get_word_hl 
1f92			 
1f92 22 e1 f4			ld (os_cur_ptr),hl	 
1f95			 
1f95			 
1f95			 
1f95			dumpcont: 
1f95			 
1f95				; dump bytes at ptr 
1f95			 
1f95			 
1f95 3e 00			ld a, display_row_1 
1f97 2a c9 fb			ld hl, (display_fb_active) 
1f9a cd d0 0f			call addatohl 
1f9d cd c5 1f			call .dumpbyterow 
1fa0			 
1fa0 3e 28			ld a, display_row_2 
1fa2 2a c9 fb			ld hl, (display_fb_active) 
1fa5 cd d0 0f			call addatohl 
1fa8 cd c5 1f			call .dumpbyterow 
1fab			 
1fab			 
1fab 3e 50			ld a, display_row_3 
1fad 2a c9 fb			ld hl, (display_fb_active) 
1fb0 cd d0 0f			call addatohl 
1fb3 cd c5 1f			call .dumpbyterow 
1fb6			 
1fb6 3e 78			ld a, display_row_4 
1fb8 2a c9 fb			ld hl, (display_fb_active) 
1fbb cd d0 0f			call addatohl 
1fbe cd c5 1f			call .dumpbyterow 
1fc1			 
1fc1 cd bf 0d			call update_display 
1fc4			;		jp cli 
1fc4 c9				ret 
1fc5			 
1fc5			.dumpbyterow: 
1fc5			 
1fc5				;push af 
1fc5			 
1fc5 e5				push hl 
1fc6			 
1fc6				; calc where to poke the ascii 
1fc6			if display_cols == 20 
1fc6				ld a, 16 
1fc6			else 
1fc6 3e 1f			ld a, 31 
1fc8			endif 
1fc8			 
1fc8 cd d0 0f			call addatohl 
1fcb 22 c3 f4			ld (os_word_scratch),hl  		; save pos for later 
1fce			 
1fce			 
1fce			; display decoding address 
1fce 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fd1			 
1fd1 7c				ld a,h 
1fd2 e1				pop hl 
1fd3 e5				push hl 
1fd4			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fd4 cd d1 12			call hexout 
1fd7 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fda			 
1fda 7d				ld a,l 
1fdb e1				pop hl 
1fdc 23				inc hl 
1fdd 23				inc hl 
1fde e5				push hl 
1fdf			;	ld hl, os_word_scratch+2 
1fdf cd d1 12			call hexout 
1fe2 e1				pop hl 
1fe3 23				inc hl 
1fe4 23				inc hl 
1fe5				;ld hl, os_word_scratch+4 
1fe5 3e 3a			ld a, ':' 
1fe7 77				ld (hl),a 
1fe8 23				inc hl 
1fe9				;ld a, 0 
1fe9				;ld (hl),a 
1fe9				;ld de, os_word_scratch 
1fe9				;pop af 
1fe9				;push af 
1fe9			;		ld a, display_row_2 
1fe9			;		call str_at_display 
1fe9			;		call update_display 
1fe9			 
1fe9			 
1fe9			;pop af 
1fe9			;	add 5 
1fe9			 
1fe9			if display_cols == 20 
1fe9				ld b, 4 
1fe9			else 
1fe9 06 08			ld b, 8 
1feb			endif	 
1feb			 
1feb			.dumpbyte: 
1feb c5				push bc 
1fec e5				push hl 
1fed			 
1fed			 
1fed 2a e1 f4		   	ld hl,(os_cur_ptr) 
1ff0 7e					ld a,(hl) 
1ff1			 
1ff1					; poke the ascii to display 
1ff1 2a c3 f4				ld hl,(os_word_scratch) 
1ff4 77					ld (hl),a 
1ff5 23					inc hl 
1ff6 22 c3 f4				ld (os_word_scratch),hl 
1ff9			 
1ff9					 
1ff9			 
1ff9			 
1ff9 e1					pop hl 
1ffa e5					push hl 
1ffb			 
1ffb cd d1 12				call hexout 
1ffe			 
1ffe					 
1ffe 2a e1 f4		   	ld hl,(os_cur_ptr) 
2001 23				inc hl 
2002 22 e1 f4		   	ld (os_cur_ptr),hl 
2005			 
2005 e1					pop hl 
2006 23					inc hl 
2007 23					inc hl 
2008 23					inc hl 
2009			 
2009			 
2009			 
2009					;ld a,0 
2009					;ld (os_word_scratch+2),a 
2009					;pop af 
2009					;push af 
2009			 
2009					;ld de, os_word_scratch 
2009					;call str_at_display 
2009			;		call update_display 
2009			;		pop af 
2009 c1					pop bc 
200a c6 03				add 3 
200c 10 dd			djnz .dumpbyte 
200e			 
200e				 
200e			 
200e c9				ret 
200f			 
200f			jump:	 
200f			 
200f 21 c0 f1			ld hl,scratch+2 
2012 cd 87 13			call get_word_hl 
2015				;ld hl,(scratch+2) 
2015				;call fourehexhl 
2015			 
2015 22 e1 f4			ld (os_cur_ptr),hl	 
2018			 
2018 e9				jp (hl) 
2019			 
2019			 
2019			 
2019			; TODO implement a basic monitor mode to start with 
2019			 
2019			 
2019			 
2019			 
2019			 
2019			 
2019			 
2019			 
2019			 
2019			; testing and demo code during development 
2019			 
2019			 
2019 .. 00		str1: db "Enter some text...",0 
202c .. 00		clear: db "                    ",0 
2041			 
2041			demo: 
2041			 
2041			 
2041			 
2041			;	call update_display 
2041			 
2041				; init scratch input area for testing 
2041 21 be f1			ld hl, scratch	 
2044 3e 00			ld a,0 
2046 77				ld (hl),a 
2047			 
2047			 
2047 3e 28		            LD   A, display_row_2 
2049			;            CALL fLCD_Pos       ;Position cursor to location in A 
2049 11 19 20		            LD   DE, str1 
204c cd af 0d			call str_at_display 
204f			 
204f			;            CALL fLCD_Str       ;Display string pointed to by DE 
204f			cloop:	 
204f 3e 50		            LD   A, display_row_3 
2051			;            CALL fLCD_Pos       ;Position cursor to location in A 
2051 11 2c 20		            LD   DE, clear 
2054			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2054 cd af 0d				call str_at_display 
2057 3e 78			ld a, display_row_4 
2059 11 89 20			ld de, prompt 
205c			 
205c cd af 0d				call str_at_display 
205f cd bf 0d			call update_display 
2062			 
2062 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2064 16 0a			ld d, 10 
2066 21 be f1			ld hl, scratch	 
2069 cd fd 0f			call input_str 
206c			 
206c			;	call clear_display 
206c			;'	call update_display 
206c			 
206c 3e 00		            LD   A, display_row_1 
206e			;            CALL fLCD_Pos       ;Position cursor to location in A 
206e 11 2c 20		            LD   DE, clear 
2071 cd af 0d				call str_at_display 
2074			;            CALL fLCD_Str       ;Display string pointed to by DE 
2074 3e 00		            LD   A, display_row_1 
2076			;            CALL fLCD_Pos       ;Position cursor to location in A 
2076 11 be f1		            LD   DE, scratch 
2079			;            CALL fLCD_Str       ;Display string pointed to by DE 
2079 cd af 0d				call str_at_display 
207c cd bf 0d			call update_display 
207f			 
207f 3e 00				ld a,0 
2081 21 be f1			ld hl, scratch 
2084 77				ld (hl),a 
2085			 
2085 00				nop 
2086 c3 4f 20			jp cloop 
2089			 
2089			 
2089			 
2089			; OS Prompt 
2089			 
2089 .. 00		prompt: db ">",0 
208b .. 00		endprg: db "?",0 
208d			 
208d			 
208d			; handy next page prompt 
208d			next_page_prompt: 
208d e5				push hl 
208e d5				push de 
208f f5				push af 
2090 c5				push bc 
2091			 
2091 3e 9f			ld a,display_row_4 + display_cols - 1 
2093 11 8b 20		        ld de, endprg 
2096 cd af 0d			call str_at_display 
2099 cd bf 0d			call update_display 
209c cd d3 79			call cin_wait 
209f c1				pop bc 
20a0 f1				pop af 
20a1 d1				pop de 
20a2 e1				pop hl 
20a3			 
20a3			 
20a3 c9				ret 
20a4			 
20a4			 
20a4			; forth parser 
20a4			 
20a4			; My forth kernel 
20a4			include "forth_kernel.asm" 
20a4			; 
20a4			; kernel to the forth OS 
20a4			 
20a4			DS_TYPE_STR: equ 1     ; string type 
20a4			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
20a4			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
20a4			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
20a4			 
20a4			FORTH_PARSEV1: equ 0 
20a4			FORTH_PARSEV2: equ 0 
20a4			FORTH_PARSEV3: equ 0 
20a4			FORTH_PARSEV4: equ 0 
20a4			FORTH_PARSEV5: equ 1 
20a4			 
20a4			;if FORTH_PARSEV5 
20a4			;	FORTH_END_BUFFER: equ 0 
20a4			;else 
20a4			FORTH_END_BUFFER: equ 127 
20a4			;endif 
20a4			 
20a4			FORTH_TRUE: equ 1 
20a4			FORTH_FALSE: equ 0 
20a4			 
20a4			if FORTH_PARSEV4 
20a4			include "forth_stackops.asm" 
20a4			endif 
20a4			 
20a4			if FORTH_PARSEV5 
20a4			include "forth_stackopsv5.asm" 
20a4			 
20a4			; Stack operations for v5 parser on wards 
20a4			; * DATA stack 
20a4			; * LOOP stack 
20a4			; * RETURN stack 
20a4			 
20a4			 
20a4			 
20a4			FORTH_CHK_DSP_UNDER: macro 
20a4				push hl 
20a4				push de 
20a4				ld hl,(cli_data_sp) 
20a4				ld de, cli_data_stack 
20a4				call cmp16 
20a4				jp c, fault_dsp_under 
20a4				pop de 
20a4				pop hl 
20a4				endm 
20a4			 
20a4			 
20a4			FORTH_CHK_RSP_UNDER: macro 
20a4				push hl 
20a4				push de 
20a4				ld hl,(cli_ret_sp) 
20a4				ld de, cli_ret_stack 
20a4				call cmp16 
20a4				jp c, fault_rsp_under 
20a4				pop de 
20a4				pop hl 
20a4				endm 
20a4			 
20a4			FORTH_CHK_LOOP_UNDER: macro 
20a4				push hl 
20a4				push de 
20a4				ld hl,(cli_loop_sp) 
20a4				ld de, cli_loop_stack 
20a4				call cmp16 
20a4				jp c, fault_loop_under 
20a4				pop de 
20a4				pop hl 
20a4				endm 
20a4			 
20a4			FORTH_ERR_TOS_NOTSTR: macro 
20a4				; TOSO might need more for checks when used 
20a4				push af 
20a4				ld a,(hl) 
20a4				cp DS_TYPE_STR 
20a4				jp nz, type_faultn   
20a4				pop af 
20a4				endm 
20a4			 
20a4			FORTH_ERR_TOS_NOTNUM: macro 
20a4				push af 
20a4				ld a,(hl) 
20a4				cp DS_TYPE_INUM 
20a4				jp nz, type_faultn   
20a4				pop af 
20a4				endm 
20a4			 
20a4			 
20a4			; increase data stack pointer and save hl to it 
20a4				 
20a4			FORTH_DSP_NEXT: macro 
20a4				call macro_forth_dsp_next 
20a4				endm 
20a4			 
20a4			 
20a4			macro_forth_dsp_next: 
20a4				if DEBUG_FORTH_STACK_GUARD 
20a4 cd 80 72				call check_stacks 
20a7				endif 
20a7 e5				push hl 
20a8 d5				push de 
20a9 eb				ex de,hl 
20aa 2a eb f9			ld hl,(cli_data_sp) 
20ad 23				inc hl 
20ae 23				inc hl 
20af			 
20af			; PARSEV5 
20af 23				inc hl 
20b0 22 eb f9			ld (cli_data_sp),hl 
20b3 73				ld (hl), e 
20b4 23				inc hl 
20b5 72				ld (hl), d 
20b6 d1				pop de 
20b7 e1				pop hl 
20b8				if DEBUG_FORTH_STACK_GUARD 
20b8 cd 80 72				call check_stacks 
20bb				endif 
20bb c9				ret 
20bc			 
20bc			 
20bc			; increase ret stack pointer and save hl to it 
20bc				 
20bc			FORTH_RSP_NEXT: macro 
20bc				call macro_forth_rsp_next 
20bc				endm 
20bc			 
20bc			macro_forth_rsp_next: 
20bc				if DEBUG_FORTH_STACK_GUARD 
20bc cd 80 72				call check_stacks 
20bf				endif 
20bf e5				push hl 
20c0 d5				push de 
20c1 eb				ex de,hl 
20c2 2a ef f9			ld hl,(cli_ret_sp) 
20c5 23				inc hl 
20c6 23				inc hl 
20c7 22 ef f9			ld (cli_ret_sp),hl 
20ca 73				ld (hl), e 
20cb 23				inc hl 
20cc 72				ld (hl), d 
20cd d1				pop de 
20ce e1				pop hl 
20cf				if DEBUG_FORTH_STACK_GUARD 
20cf cd 80 72				call check_stacks 
20d2				endif 
20d2 c9				ret 
20d3			 
20d3			; get current ret stack pointer and save to hl  
20d3				 
20d3			FORTH_RSP_TOS: macro 
20d3				call macro_forth_rsp_tos 
20d3				endm 
20d3			 
20d3			macro_forth_rsp_tos: 
20d3				;push de 
20d3 2a ef f9			ld hl,(cli_ret_sp) 
20d6 cd 0e 21			call loadhlptrtohl 
20d9				;ld e, (hl) 
20d9				;inc hl 
20d9				;ld d, (hl) 
20d9				;ex de, hl 
20d9					if DEBUG_FORTH_WORDS 
20d9			;			DMARK "RST" 
20d9						CALLMONITOR 
20d9 cd 6c fe			call debug_vector  
20dc				endm  
# End of macro CALLMONITOR
20dc					endif 
20dc				;pop de 
20dc c9				ret 
20dd			 
20dd			; pop ret stack pointer 
20dd				 
20dd			FORTH_RSP_POP: macro 
20dd				call macro_forth_rsp_pop 
20dd				endm 
20dd			 
20dd			 
20dd			macro_forth_rsp_pop: 
20dd				if DEBUG_FORTH_STACK_GUARD 
20dd			;		DMARK "RPP" 
20dd cd 80 72				call check_stacks 
20e0					FORTH_CHK_RSP_UNDER 
20e0 e5				push hl 
20e1 d5				push de 
20e2 2a ef f9			ld hl,(cli_ret_sp) 
20e5 11 a9 f9			ld de, cli_ret_stack 
20e8 cd ee 0f			call cmp16 
20eb da 94 73			jp c, fault_rsp_under 
20ee d1				pop de 
20ef e1				pop hl 
20f0				endm 
# End of macro FORTH_CHK_RSP_UNDER
20f0				endif 
20f0 e5				push hl 
20f1 2a ef f9			ld hl,(cli_ret_sp) 
20f4			 
20f4			 
20f4				if FORTH_ENABLE_FREE 
20f4			 
20f4					; get pointer 
20f4			 
20f4					push de 
20f4					push hl 
20f4			 
20f4					ld e, (hl) 
20f4					inc hl 
20f4					ld d, (hl) 
20f4			 
20f4					ex de, hl 
20f4					call free 
20f4			 
20f4					pop hl 
20f4					pop de 
20f4			 
20f4			 
20f4				endif 
20f4			 
20f4			 
20f4 2b				dec hl 
20f5 2b				dec hl 
20f6 22 ef f9			ld (cli_ret_sp), hl 
20f9				; do stack underflow checks 
20f9 e1				pop hl 
20fa				if DEBUG_FORTH_STACK_GUARD 
20fa cd 80 72				call check_stacks 
20fd					FORTH_CHK_RSP_UNDER 
20fd e5				push hl 
20fe d5				push de 
20ff 2a ef f9			ld hl,(cli_ret_sp) 
2102 11 a9 f9			ld de, cli_ret_stack 
2105 cd ee 0f			call cmp16 
2108 da 94 73			jp c, fault_rsp_under 
210b d1				pop de 
210c e1				pop hl 
210d				endm 
# End of macro FORTH_CHK_RSP_UNDER
210d				endif 
210d c9				ret 
210e			 
210e			 
210e			 
210e			; routine to load word pointed to by hl into hl 
210e			 
210e			loadhlptrtohl: 
210e			 
210e d5				push de 
210f 5e				ld e, (hl) 
2110 23				inc hl 
2111 56				ld d, (hl) 
2112 eb				ex de, hl 
2113 d1				pop de 
2114			 
2114 c9				ret 
2115			 
2115			 
2115			 
2115			 
2115			 
2115			; push a number held in HL onto the data stack 
2115			; entry point for pushing a value when already in hl used in function above 
2115			 
2115			forth_push_numhl: 
2115			 
2115 e5				push hl    ; save value to push 
2116			 
2116			if DEBUG_FORTH_PUSH 
2116				; see if disabled 
2116			 
2116			 
2116 f5				push af 
2117 3a 6c fe			ld a,(debug_vector) 
211a fe c9			cp $c9   ; ret 
211c			;	ld a, (os_view_disable) 
211c			;	cp '*' 
211c 28 34			jr z, .pskip2 
211e e5				push hl 
211f e5			push hl 
2120 cd 9c 0d			call clear_display 
2123 e1			pop hl 
2124 7c				ld a,h 
2125 21 c3 f4			ld hl, os_word_scratch 
2128 cd d1 12			call hexout 
212b e1				pop hl 
212c 7d				ld a,l 
212d 21 c5 f4			ld hl, os_word_scratch+2 
2130 cd d1 12			call hexout 
2133			 
2133 21 c7 f4			ld hl, os_word_scratch+4 
2136 3e 00			ld a,0 
2138 77				ld (hl),a 
2139 11 c3 f4			ld de,os_word_scratch 
213c 3e 28				ld a, display_row_2 
213e cd af 0d				call str_at_display 
2141 11 bc 5d			ld de, .push_num 
2144 3e 00			ld a, display_row_1 
2146			 
2146 cd af 0d				call str_at_display 
2149			 
2149			 
2149 cd bf 0d			call update_display 
214c cd df 0c			call delay1s 
214f cd df 0c			call delay1s 
2152			.pskip2:  
2152			 
2152 f1				pop af 
2153			endif	 
2153			 
2153			 
2153				FORTH_DSP_NEXT 
2153 cd a4 20			call macro_forth_dsp_next 
2156				endm 
# End of macro FORTH_DSP_NEXT
2156			 
2156 2a eb f9			ld hl, (cli_data_sp) 
2159			 
2159				; save item type 
2159 3e 02			ld a,  DS_TYPE_INUM 
215b 77				ld (hl), a 
215c 23				inc hl 
215d			 
215d				; get word off stack 
215d d1				pop de 
215e 7b				ld a,e 
215f 77				ld (hl), a 
2160 23				inc hl 
2161 7a				ld a,d 
2162 77				ld (hl), a 
2163			 
2163			if DEBUG_FORTH_PUSH 
2163 2b				dec hl 
2164 2b				dec hl 
2165 2b				dec hl 
2166						DMARK "PH5" 
2166 f5				push af  
2167 3a 7b 21			ld a, (.dmark)  
216a 32 68 fe			ld (debug_mark),a  
216d 3a 7c 21			ld a, (.dmark+1)  
2170 32 69 fe			ld (debug_mark+1),a  
2173 3a 7d 21			ld a, (.dmark+2)  
2176 32 6a fe			ld (debug_mark+2),a  
2179 18 03			jr .pastdmark  
217b ..			.dmark: db "PH5"  
217e f1			.pastdmark: pop af  
217f			endm  
# End of macro DMARK
217f				CALLMONITOR 
217f cd 6c fe			call debug_vector  
2182				endm  
# End of macro CALLMONITOR
2182			endif	 
2182			 
2182 c9				ret 
2183			 
2183			 
2183			; Push a string to stack pointed to by hl 
2183			 
2183			forth_push_str: 
2183			 
2183			if DEBUG_FORTH_PUSH 
2183						DMARK "PSQ" 
2183 f5				push af  
2184 3a 98 21			ld a, (.dmark)  
2187 32 68 fe			ld (debug_mark),a  
218a 3a 99 21			ld a, (.dmark+1)  
218d 32 69 fe			ld (debug_mark+1),a  
2190 3a 9a 21			ld a, (.dmark+2)  
2193 32 6a fe			ld (debug_mark+2),a  
2196 18 03			jr .pastdmark  
2198 ..			.dmark: db "PSQ"  
219b f1			.pastdmark: pop af  
219c			endm  
# End of macro DMARK
219c				CALLMONITOR 
219c cd 6c fe			call debug_vector  
219f				endm  
# End of macro CALLMONITOR
219f			endif	 
219f			    
219f e5				push hl 
21a0 e5				push hl 
21a1			 
21a1			;	ld a, 0   ; find end of string 
21a1 cd 2e 14			call strlenz 
21a4			if DEBUG_FORTH_PUSH 
21a4						DMARK "PQ2" 
21a4 f5				push af  
21a5 3a b9 21			ld a, (.dmark)  
21a8 32 68 fe			ld (debug_mark),a  
21ab 3a ba 21			ld a, (.dmark+1)  
21ae 32 69 fe			ld (debug_mark+1),a  
21b1 3a bb 21			ld a, (.dmark+2)  
21b4 32 6a fe			ld (debug_mark+2),a  
21b7 18 03			jr .pastdmark  
21b9 ..			.dmark: db "PQ2"  
21bc f1			.pastdmark: pop af  
21bd			endm  
# End of macro DMARK
21bd				CALLMONITOR 
21bd cd 6c fe			call debug_vector  
21c0				endm  
# End of macro CALLMONITOR
21c0			endif	 
21c0 eb				ex de, hl 
21c1 e1				pop hl   ; get ptr to start of string 
21c2			if DEBUG_FORTH_PUSH 
21c2						DMARK "PQ3" 
21c2 f5				push af  
21c3 3a d7 21			ld a, (.dmark)  
21c6 32 68 fe			ld (debug_mark),a  
21c9 3a d8 21			ld a, (.dmark+1)  
21cc 32 69 fe			ld (debug_mark+1),a  
21cf 3a d9 21			ld a, (.dmark+2)  
21d2 32 6a fe			ld (debug_mark+2),a  
21d5 18 03			jr .pastdmark  
21d7 ..			.dmark: db "PQ3"  
21da f1			.pastdmark: pop af  
21db			endm  
# End of macro DMARK
21db				CALLMONITOR 
21db cd 6c fe			call debug_vector  
21de				endm  
# End of macro CALLMONITOR
21de			endif	 
21de 19				add hl,de 
21df			if DEBUG_FORTH_PUSH 
21df						DMARK "PQE" 
21df f5				push af  
21e0 3a f4 21			ld a, (.dmark)  
21e3 32 68 fe			ld (debug_mark),a  
21e6 3a f5 21			ld a, (.dmark+1)  
21e9 32 69 fe			ld (debug_mark+1),a  
21ec 3a f6 21			ld a, (.dmark+2)  
21ef 32 6a fe			ld (debug_mark+2),a  
21f2 18 03			jr .pastdmark  
21f4 ..			.dmark: db "PQE"  
21f7 f1			.pastdmark: pop af  
21f8			endm  
# End of macro DMARK
21f8				CALLMONITOR 
21f8 cd 6c fe			call debug_vector  
21fb				endm  
# End of macro CALLMONITOR
21fb			endif	 
21fb			 
21fb 2b				dec hl    ; see if there is an optional trailing double quote 
21fc 7e				ld a,(hl) 
21fd fe 22			cp '"' 
21ff 20 03			jr nz, .strnoq 
2201 3e 00			ld a, 0      ; get rid of double quote 
2203 77				ld (hl), a 
2204 23			.strnoq: inc hl 
2205			 
2205 3e 00			ld a, 0 
2207 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2208			 
2208 13				inc de ; add one for the type string 
2209 13				inc de ; add one for null term??? 
220a			 
220a				; tos is get string pointer again 
220a				; de contains space to allocate 
220a				 
220a d5				push de 
220b			 
220b eb				ex de, hl 
220c			 
220c				;push af 
220c			 
220c			if DEBUG_FORTH_PUSH 
220c						DMARK "PHm" 
220c f5				push af  
220d 3a 21 22			ld a, (.dmark)  
2210 32 68 fe			ld (debug_mark),a  
2213 3a 22 22			ld a, (.dmark+1)  
2216 32 69 fe			ld (debug_mark+1),a  
2219 3a 23 22			ld a, (.dmark+2)  
221c 32 6a fe			ld (debug_mark+2),a  
221f 18 03			jr .pastdmark  
2221 ..			.dmark: db "PHm"  
2224 f1			.pastdmark: pop af  
2225			endm  
# End of macro DMARK
2225				CALLMONITOR 
2225 cd 6c fe			call debug_vector  
2228				endm  
# End of macro CALLMONITOR
2228			endif	 
2228 cd 97 14			call malloc	; on ret hl now contains allocated memory 
222b				if DEBUG_FORTH_MALLOC_GUARD 
222b cc 14 5e				call z,malloc_error 
222e				endif 
222e			 
222e				 
222e c1				pop bc    ; get length 
222f d1				pop de   ;  get string start    
2230			 
2230				; hl has destination from malloc 
2230			 
2230 eb				ex de, hl    ; prep for ldir 
2231			 
2231 d5				push de   ; save malloc area for DSP later 
2232				;push hl   ; save malloc area for DSP later 
2232			 
2232			if DEBUG_FORTH_PUSH 
2232						DMARK "PHc" 
2232 f5				push af  
2233 3a 47 22			ld a, (.dmark)  
2236 32 68 fe			ld (debug_mark),a  
2239 3a 48 22			ld a, (.dmark+1)  
223c 32 69 fe			ld (debug_mark+1),a  
223f 3a 49 22			ld a, (.dmark+2)  
2242 32 6a fe			ld (debug_mark+2),a  
2245 18 03			jr .pastdmark  
2247 ..			.dmark: db "PHc"  
224a f1			.pastdmark: pop af  
224b			endm  
# End of macro DMARK
224b				CALLMONITOR 
224b cd 6c fe			call debug_vector  
224e				endm  
# End of macro CALLMONITOR
224e			endif	 
224e			 
224e			 
224e ed b0			ldir 
2250			 
2250			 
2250				; push malloc to data stack     macro?????  
2250			 
2250				FORTH_DSP_NEXT 
2250 cd a4 20			call macro_forth_dsp_next 
2253				endm 
# End of macro FORTH_DSP_NEXT
2253			 
2253				; save value and type 
2253			 
2253 2a eb f9			ld hl, (cli_data_sp) 
2256			 
2256				; save item type 
2256 3e 01			ld a,  DS_TYPE_STR 
2258 77				ld (hl), a 
2259 23				inc hl 
225a			 
225a				; get malloc word off stack 
225a d1				pop de 
225b 73				ld (hl), e 
225c 23				inc hl 
225d 72				ld (hl), d 
225e			 
225e			 
225e			 
225e			if DEBUG_FORTH_PUSH 
225e 2a eb f9			ld hl, (cli_data_sp) 
2261						DMARK "PHS" 
2261 f5				push af  
2262 3a 76 22			ld a, (.dmark)  
2265 32 68 fe			ld (debug_mark),a  
2268 3a 77 22			ld a, (.dmark+1)  
226b 32 69 fe			ld (debug_mark+1),a  
226e 3a 78 22			ld a, (.dmark+2)  
2271 32 6a fe			ld (debug_mark+2),a  
2274 18 03			jr .pastdmark  
2276 ..			.dmark: db "PHS"  
2279 f1			.pastdmark: pop af  
227a			endm  
# End of macro DMARK
227a				CALLMONITOR 
227a cd 6c fe			call debug_vector  
227d				endm  
# End of macro CALLMONITOR
227d			;	ex de,hl 
227d			endif	 
227d				; in case of spaces, skip the ptr past the copied string 
227d				;pop af 
227d				;ld (cli_origptr),hl 
227d			 
227d c9				ret 
227e			 
227e			 
227e			 
227e			; TODO ascii push input onto stack given hl to start of input 
227e			 
227e			; identify type 
227e			; if starts with a " then a string 
227e			; otherwise it is a number 
227e			;  
227e			; if a string 
227e			;     scan for ending " to get length of string to malloc for + 1 
227e			;     malloc 
227e			;     put pointer to string on stack first byte flags as string 
227e			; 
227e			; else a number 
227e			;    look for number format identifier 
227e			;    $xx hex 
227e			;    %xxxxx bin 
227e			;    xxxxx decimal 
227e			;    convert number to 16bit word.  
227e			;    malloc word + 1 with flag to identiy as num 
227e			;    put pointer to number on stack 
227e			;   
227e			;  
227e			  
227e			forth_apush: 
227e				; kernel push 
227e			 
227e			if DEBUG_FORTH_PUSH 
227e						DMARK "PSH" 
227e f5				push af  
227f 3a 93 22			ld a, (.dmark)  
2282 32 68 fe			ld (debug_mark),a  
2285 3a 94 22			ld a, (.dmark+1)  
2288 32 69 fe			ld (debug_mark+1),a  
228b 3a 95 22			ld a, (.dmark+2)  
228e 32 6a fe			ld (debug_mark+2),a  
2291 18 03			jr .pastdmark  
2293 ..			.dmark: db "PSH"  
2296 f1			.pastdmark: pop af  
2297			endm  
# End of macro DMARK
2297				CALLMONITOR 
2297 cd 6c fe			call debug_vector  
229a				endm  
# End of macro CALLMONITOR
229a			endif	 
229a				; identify input type 
229a			 
229a 7e				ld a,(hl) 
229b fe 22			cp '"' 
229d 28 0a			jr z, .fapstr 
229f fe 24			cp '$' 
22a1 ca c9 22			jp z, .faphex 
22a4 fe 25			cp '%' 
22a6 ca b1 22			jp z, .fapbin 
22a9			;	cp 'b' 
22a9			;	jp z, .fabin 
22a9				; else decimal 
22a9			 
22a9				; TODO do decimal conversion 
22a9				; decimal is stored as a 16bit word 
22a9			 
22a9				; by default everything is a string if type is not detected 
22a9			.fapstr: ; 
22a9 fe 22			cp '"' 
22ab 20 01			jr nz, .strnoqu 
22ad 23				inc hl 
22ae			.strnoqu: 
22ae c3 83 21			jp forth_push_str 
22b1			 
22b1			 
22b1			 
22b1			.fapbin:    ; push a binary string.  
22b1 11 00 00			ld de, 0   ; hold a 16bit value 
22b4			 
22b4 23			.fapbinshift:	inc hl  
22b5 7e				ld a,(hl) 
22b6 fe 00			cp 0     ; done scanning  
22b8 28 0b			jr z, .fapbdone  	; got it in HL so push  
22ba			 
22ba				; left shift de 
22ba eb				ex de, hl	 
22bb 29				add hl, hl 
22bc			 
22bc				; is 1 
22bc fe 31			cp '1' 
22be 20 02			jr nz, .binzero 
22c0 cb 4d			bit 1, l 
22c2			.binzero: 
22c2 eb				ex de, hl	 ; save current de 
22c3 18 ef			jr .fapbinshift 
22c5			 
22c5			.fapbdone: 
22c5 eb				ex de, hl 
22c6 c3 15 21			jp forth_push_numhl 
22c9			 
22c9			 
22c9			.faphex:   ; hex is always stored as a 16bit word 
22c9				; skip number prefix 
22c9 23				inc hl 
22ca				; turn ascii into number 
22ca cd 87 13			call get_word_hl	; ret 16bit word in hl 
22cd			 
22cd c3 15 21			jp forth_push_numhl 
22d0			 
22d0 00				 nop 
22d1			 
22d1			.fabin:   ; TODO bin conversion 
22d1			 
22d1			 
22d1 c9				ret 
22d2			 
22d2			 
22d2			; get either a string ptr or a 16bit word from the data stack 
22d2			 
22d2			FORTH_DSP: macro 
22d2				call macro_forth_dsp 
22d2				endm 
22d2			 
22d2			macro_forth_dsp: 
22d2				; data stack pointer points to current word on tos 
22d2			 
22d2 2a eb f9			ld hl,(cli_data_sp) 
22d5			 
22d5				if DEBUG_FORTH_PUSH 
22d5						DMARK "DSP" 
22d5 f5				push af  
22d6 3a ea 22			ld a, (.dmark)  
22d9 32 68 fe			ld (debug_mark),a  
22dc 3a eb 22			ld a, (.dmark+1)  
22df 32 69 fe			ld (debug_mark+1),a  
22e2 3a ec 22			ld a, (.dmark+2)  
22e5 32 6a fe			ld (debug_mark+2),a  
22e8 18 03			jr .pastdmark  
22ea ..			.dmark: db "DSP"  
22ed f1			.pastdmark: pop af  
22ee			endm  
# End of macro DMARK
22ee			 
22ee cd 47 5e				call display_data_sp 
22f1				;call break_point_state 
22f1				;rst 030h 
22f1				CALLMONITOR 
22f1 cd 6c fe			call debug_vector  
22f4				endm  
# End of macro CALLMONITOR
22f4				endif 
22f4			 
22f4 c9				ret 
22f5			 
22f5			; return hl to start of value on stack 
22f5			 
22f5			FORTH_DSP_VALUE: macro 
22f5				call macro_forth_dsp_value 
22f5				endm 
22f5			 
22f5			macro_forth_dsp_value: 
22f5			 
22f5				FORTH_DSP 
22f5 cd d2 22			call macro_forth_dsp 
22f8				endm 
# End of macro FORTH_DSP
22f8			 
22f8 d5				push de 
22f9			 
22f9 23				inc hl ; skip type 
22fa			 
22fa 5e				ld e, (hl) 
22fb 23				inc hl 
22fc 56				ld d, (hl) 
22fd eb				ex de,hl  
22fe			 
22fe d1				pop de 
22ff			 
22ff c9				ret 
2300			 
2300			; return hl to start of value to second item on stack 
2300			 
2300			FORTH_DSP_VALUEM1: macro 
2300				call macro_forth_dsp_value_m1 
2300				endm 
2300			 
2300			macro_forth_dsp_value_m1: 
2300			 
2300				FORTH_DSP 
2300 cd d2 22			call macro_forth_dsp 
2303				endm 
# End of macro FORTH_DSP
2303			 
2303 2b				dec hl 
2304 2b				dec hl 
2305			;	dec hl 
2305			 
2305 d5				push de 
2306			 
2306 5e				ld e, (hl) 
2307 23				inc hl 
2308 56				ld d, (hl) 
2309 eb				ex de,hl  
230a			 
230a d1				pop de 
230b			 
230b c9				ret 
230c			 
230c				 
230c			 
230c			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
230c			 
230c			FORTH_DSP_POP: macro 
230c				call macro_forth_dsp_pop 
230c				endm 
230c			 
230c			 
230c			; get the tos data type 
230c			 
230c			FORTH_DSP_TYPE:   macro 
230c			 
230c				;FORTH_DSP_VALUE 
230c				FORTH_DSP 
230c				 
230c				; hl points to value 
230c				; check type 
230c			 
230c				ld a,(hl) 
230c			 
230c				endm 
230c			 
230c			; load the tos value into hl 
230c			 
230c			 
230c			FORTH_DSP_VALUEHL:  macro 
230c				call macro_dsp_valuehl 
230c				endm 
230c			 
230c			 
230c			 
230c			macro_dsp_valuehl: 
230c				FORTH_DSP_VALUE 
230c cd f5 22			call macro_forth_dsp_value 
230f				endm 
# End of macro FORTH_DSP_VALUE
230f			 
230f				;FORTH_ERR_TOS_NOTNUM 
230f			 
230f				;inc hl   ; skip type id 
230f			 
230f			;	push de 
230f			; 
230f			;	ld e, (hl) 
230f			;	inc hl 
230f			;	ld d, (hl) 
230f			;	ex de,hl  
230f			 
230f			;	pop de 
230f			 
230f				if DEBUG_FORTH_PUSH 
230f						DMARK "DVL" 
230f f5				push af  
2310 3a 24 23			ld a, (.dmark)  
2313 32 68 fe			ld (debug_mark),a  
2316 3a 25 23			ld a, (.dmark+1)  
2319 32 69 fe			ld (debug_mark+1),a  
231c 3a 26 23			ld a, (.dmark+2)  
231f 32 6a fe			ld (debug_mark+2),a  
2322 18 03			jr .pastdmark  
2324 ..			.dmark: db "DVL"  
2327 f1			.pastdmark: pop af  
2328			endm  
# End of macro DMARK
2328				CALLMONITOR 
2328 cd 6c fe			call debug_vector  
232b				endm  
# End of macro CALLMONITOR
232b				endif 
232b c9				ret 
232c			 
232c			forth_apushstrhl:      
232c				; push of string requires use of cli_origptr 
232c				; bodge use 
232c			 
232c				; get current cli_origptr, save, update with temp pointer  
232c ed 5b 3b fa		ld de, (cli_origptr) 
2330 22 3b fa			ld (cli_origptr), hl 
2333 d5				push de 
2334 cd 7e 22			call forth_apush 
2337 d1				pop de 
2338 ed 53 3b fa		ld (cli_origptr), de 
233c c9			        ret	 
233d			 
233d			 
233d			; increase loop stack pointer and save hl to it 
233d				 
233d			FORTH_LOOP_NEXT: macro 
233d				call macro_forth_loop_next 
233d				;nop 
233d				endm 
233d			 
233d			macro_forth_loop_next: 
233d				if DEBUG_FORTH_STACK_GUARD 
233d cd 80 72				call check_stacks 
2340				endif 
2340 e5				push hl 
2341 d5				push de 
2342 eb				ex de,hl 
2343 2a ed f9			ld hl,(cli_loop_sp) 
2346 23				inc hl 
2347 23				inc hl 
2348					if DEBUG_FORTH_WORDS 
2348						DMARK "LNX" 
2348 f5				push af  
2349 3a 5d 23			ld a, (.dmark)  
234c 32 68 fe			ld (debug_mark),a  
234f 3a 5e 23			ld a, (.dmark+1)  
2352 32 69 fe			ld (debug_mark+1),a  
2355 3a 5f 23			ld a, (.dmark+2)  
2358 32 6a fe			ld (debug_mark+2),a  
235b 18 03			jr .pastdmark  
235d ..			.dmark: db "LNX"  
2360 f1			.pastdmark: pop af  
2361			endm  
# End of macro DMARK
2361						CALLMONITOR 
2361 cd 6c fe			call debug_vector  
2364				endm  
# End of macro CALLMONITOR
2364					endif 
2364 22 ed f9			ld (cli_loop_sp),hl 
2367 73				ld (hl), e 
2368 23				inc hl 
2369 72				ld (hl), d 
236a d1				pop de    ; been reversed so save a swap on restore 
236b e1				pop hl 
236c				if DEBUG_FORTH_STACK_GUARD 
236c cd 80 72				call check_stacks 
236f				endif 
236f c9				ret 
2370			 
2370			; get current ret stack pointer and save to hl  
2370				 
2370			FORTH_LOOP_TOS: macro 
2370				call macro_forth_loop_tos 
2370				endm 
2370			 
2370			macro_forth_loop_tos: 
2370 d5				push de 
2371 2a ed f9			ld hl,(cli_loop_sp) 
2374 5e				ld e, (hl) 
2375 23				inc hl 
2376 56				ld d, (hl) 
2377 eb				ex de, hl 
2378 d1				pop de 
2379 c9				ret 
237a			 
237a			; pop loop stack pointer 
237a				 
237a			FORTH_LOOP_POP: macro 
237a				call macro_forth_loop_pop 
237a				endm 
237a			 
237a			 
237a			macro_forth_loop_pop: 
237a				if DEBUG_FORTH_STACK_GUARD 
237a					DMARK "LPP" 
237a f5				push af  
237b 3a 8f 23			ld a, (.dmark)  
237e 32 68 fe			ld (debug_mark),a  
2381 3a 90 23			ld a, (.dmark+1)  
2384 32 69 fe			ld (debug_mark+1),a  
2387 3a 91 23			ld a, (.dmark+2)  
238a 32 6a fe			ld (debug_mark+2),a  
238d 18 03			jr .pastdmark  
238f ..			.dmark: db "LPP"  
2392 f1			.pastdmark: pop af  
2393			endm  
# End of macro DMARK
2393 cd 80 72				call check_stacks 
2396					FORTH_CHK_LOOP_UNDER 
2396 e5				push hl 
2397 d5				push de 
2398 2a ed f9			ld hl,(cli_loop_sp) 
239b 11 27 f9			ld de, cli_loop_stack 
239e cd ee 0f			call cmp16 
23a1 da 9a 73			jp c, fault_loop_under 
23a4 d1				pop de 
23a5 e1				pop hl 
23a6				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23a6				endif 
23a6 e5				push hl 
23a7 2a ed f9			ld hl,(cli_loop_sp) 
23aa 2b				dec hl 
23ab 2b				dec hl 
23ac 22 ed f9			ld (cli_loop_sp), hl 
23af				; TODO do stack underflow checks 
23af e1				pop hl 
23b0				if DEBUG_FORTH_STACK_GUARD 
23b0 cd 80 72				call check_stacks 
23b3					FORTH_CHK_LOOP_UNDER 
23b3 e5				push hl 
23b4 d5				push de 
23b5 2a ed f9			ld hl,(cli_loop_sp) 
23b8 11 27 f9			ld de, cli_loop_stack 
23bb cd ee 0f			call cmp16 
23be da 9a 73			jp c, fault_loop_under 
23c1 d1				pop de 
23c2 e1				pop hl 
23c3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23c3				endif 
23c3 c9				ret 
23c4			 
23c4			macro_forth_dsp_pop: 
23c4			 
23c4 e5				push hl 
23c5			 
23c5				; release malloc data 
23c5			 
23c5				if DEBUG_FORTH_STACK_GUARD 
23c5 cd 80 72				call check_stacks 
23c8					FORTH_CHK_DSP_UNDER 
23c8 e5				push hl 
23c9 d5				push de 
23ca 2a eb f9			ld hl,(cli_data_sp) 
23cd 11 25 f7			ld de, cli_data_stack 
23d0 cd ee 0f			call cmp16 
23d3 da 8e 73			jp c, fault_dsp_under 
23d6 d1				pop de 
23d7 e1				pop hl 
23d8				endm 
# End of macro FORTH_CHK_DSP_UNDER
23d8				endif 
23d8				;ld hl,(cli_data_sp) 
23d8			if DEBUG_FORTH_DOT 
23d8				DMARK "DPP" 
23d8 f5				push af  
23d9 3a ed 23			ld a, (.dmark)  
23dc 32 68 fe			ld (debug_mark),a  
23df 3a ee 23			ld a, (.dmark+1)  
23e2 32 69 fe			ld (debug_mark+1),a  
23e5 3a ef 23			ld a, (.dmark+2)  
23e8 32 6a fe			ld (debug_mark+2),a  
23eb 18 03			jr .pastdmark  
23ed ..			.dmark: db "DPP"  
23f0 f1			.pastdmark: pop af  
23f1			endm  
# End of macro DMARK
23f1				CALLMONITOR 
23f1 cd 6c fe			call debug_vector  
23f4				endm  
# End of macro CALLMONITOR
23f4			endif	 
23f4			 
23f4			 
23f4			if FORTH_ENABLE_DSPPOPFREE 
23f4			 
23f4				FORTH_DSP 
23f4 cd d2 22			call macro_forth_dsp 
23f7				endm 
# End of macro FORTH_DSP
23f7			 
23f7 7e				ld a, (hl) 
23f8 fe 01			cp DS_TYPE_STR 
23fa 20 23			jr nz, .skippopfree 
23fc			 
23fc				FORTH_DSP_VALUEHL 
23fc cd 0c 23			call macro_dsp_valuehl 
23ff				endm 
# End of macro FORTH_DSP_VALUEHL
23ff 00				nop 
2400			if DEBUG_FORTH_DOT 
2400				DMARK "DPf" 
2400 f5				push af  
2401 3a 15 24			ld a, (.dmark)  
2404 32 68 fe			ld (debug_mark),a  
2407 3a 16 24			ld a, (.dmark+1)  
240a 32 69 fe			ld (debug_mark+1),a  
240d 3a 17 24			ld a, (.dmark+2)  
2410 32 6a fe			ld (debug_mark+2),a  
2413 18 03			jr .pastdmark  
2415 ..			.dmark: db "DPf"  
2418 f1			.pastdmark: pop af  
2419			endm  
# End of macro DMARK
2419				CALLMONITOR 
2419 cd 6c fe			call debug_vector  
241c				endm  
# End of macro CALLMONITOR
241c			endif	 
241c cd 61 15			call free 
241f			.skippopfree: 
241f				 
241f			 
241f			endif 
241f			 
241f			if DEBUG_FORTH_DOT_KEY 
241f				DMARK "DP2" 
241f				CALLMONITOR 
241f			endif	 
241f			 
241f				; move pointer down 
241f			 
241f 2a eb f9			ld hl,(cli_data_sp) 
2422 2b				dec hl 
2423 2b				dec hl 
2424			; PARSEV5 
2424 2b				dec hl 
2425 22 eb f9			ld (cli_data_sp), hl 
2428			 
2428				if DEBUG_FORTH_STACK_GUARD 
2428 cd 80 72				call check_stacks 
242b					FORTH_CHK_DSP_UNDER 
242b e5				push hl 
242c d5				push de 
242d 2a eb f9			ld hl,(cli_data_sp) 
2430 11 25 f7			ld de, cli_data_stack 
2433 cd ee 0f			call cmp16 
2436 da 8e 73			jp c, fault_dsp_under 
2439 d1				pop de 
243a e1				pop hl 
243b				endm 
# End of macro FORTH_CHK_DSP_UNDER
243b				endif 
243b			 
243b e1				pop hl 
243c			 
243c c9				ret 
243d			 
243d			getwordathl: 
243d				; hl points to an address 
243d				; load hl with the word at that address 
243d			 
243d d5				push de 
243e			 
243e 5e				ld e, (hl) 
243f 23				inc hl 
2440 56				ld d, (hl) 
2441 eb				ex de, hl 
2442			 
2442 d1				pop de 
2443 c9				ret 
2444			 
2444			 
2444			 
2444			 
2444			 
2444			; eof 
2444			 
# End of file forth_stackopsv5.asm
2444			endif 
2444			 
2444			loadwordinhl:	 
2444			 
2444 d5				push de 
2445			 
2445 5e				ld e, (hl) 
2446 23				inc hl 
2447 56				ld d, (hl) 
2448 eb				ex de,hl  
2449			 
2449 d1				pop de 
244a			 
244a c9				ret 
244b			 
244b			user_word_eol:  
244b				; hl contains the pointer to where to create a linked list item from the end 
244b				; of the user dict to continue on at the system word dict 
244b				 
244b				; poke the stub of the word list linked list to repoint to rom words 
244b			 
244b				; stub format 
244b				; db   word id 
244b				; dw    link to next word 
244b			        ; db char length of token 
244b				; db string + 0 term 
244b				; db exec code....  
244b			 
244b 3e 00			ld a, WORD_SYS_ROOT     ; root word 
244d 77				ld (hl), a		; word id 
244e 23				inc hl 
244f			 
244f 11 1a 26			ld de, sysdict 
2452 73				ld (hl), e		; next word link ie system dict 
2453 23				inc hl 
2454 72				ld (hl), d		; next word link ie system dict 
2455 23				inc hl	 
2456			 
2456			;	ld (hl), sysdict		; next word link ie system dict 
2456			;	inc hl 
2456			;	inc hl 
2456			 
2456			;	inc hl 
2456			;	inc hl 
2456			 
2456 3e 02			ld a, 2			; word length is 0 
2458 77				ld (hl), a	 
2459 23				inc hl 
245a			 
245a 3e 7e			ld a, '~'			; word length is 0 
245c 77				ld (hl), a	 
245d 23				inc hl 
245e 3e 00			ld a, 0			; save empty word 
2460 77				ld (hl), a 
2461			 
2461 c9				ret 
2462			 
2462				 
2462			 
2462			forthexec_cleanup: 
2462				FORTH_RSP_POP 
2462 cd dd 20			call macro_forth_rsp_pop 
2465				endm 
# End of macro FORTH_RSP_POP
2465 c9				ret 
2466			 
2466			forth_call_hl: 
2466				; taking hl 
2466 e5				push hl 
2467 c9				ret 
2468			 
2468			; this is called to reset Forth system but keep existing uwords etc 
2468			 
2468			forth_warmstart: 
2468				; setup stack over/under flow checks 
2468				if DEBUG_FORTH_STACK_GUARD 
2468 cd 66 72				call chk_stk_init 
246b				endif 
246b			 
246b				; init stack pointers  - * these stacks go upwards *  
246b 21 a9 f9			ld hl, cli_ret_stack 
246e 22 ef f9			ld (cli_ret_sp), hl	 
2471				; set bottom of stack 
2471 3e 00			ld a,0 
2473 77				ld (hl),a 
2474 23				inc hl 
2475 77				ld (hl),a 
2476			 
2476 21 25 f7			ld hl, cli_data_stack 
2479 22 eb f9			ld (cli_data_sp), hl	 
247c				; set bottom of stack 
247c 3e 00			ld a,0 
247e 77				ld (hl),a 
247f 23				inc hl 
2480 77				ld (hl),a 
2481			 
2481 21 27 f9			ld hl, cli_loop_stack 
2484 22 ed f9			ld (cli_loop_sp), hl	 
2487				; set bottom of stack 
2487 3e 00			ld a,0 
2489 77				ld (hl),a 
248a 23				inc hl 
248b 77				ld (hl),a 
248c			 
248c				; init extent of current open file 
248c			 
248c 3e 00			ld a, 0 
248e 32 67 fa			ld (store_openext), a 
2491			 
2491 c9				ret 
2492			 
2492			 
2492			 
2492			; Cold Start - this is called to setup the whole Forth system 
2492			 
2492			forth_init: 
2492			 
2492				; setup stack over/under flow checks 
2492			 
2492			;	if DEBUG_FORTH_STACK_GUARD 
2492			;		call chk_stk_init 
2492			;	endif 
2492			 
2492				; enable auto display updates (slow.....) 
2492			 
2492 3e 01			ld a, 1 
2494 32 39 fa			ld (cli_autodisplay), a 
2497			 
2497				; if storage is in use disable long reads for now 
2497 3e 00			ld a, 0 
2499 32 72 fa			ld (store_longread), a 
249c			 
249c			 
249c				; show start up screen 
249c			 
249c cd 9c 0d			call clear_display 
249f			 
249f 3e 00			ld a,0 
24a1 32 5b fa			ld (f_cursor_ptr), a 
24a4			 
24a4				; set start of word list in start of ram - for use when creating user words 
24a4			 
24a4 21 00 80			ld hl, baseram 
24a7 22 bb f4			ld (os_last_new_uword), hl 
24aa cd 4b 24			call user_word_eol 
24ad				 
24ad			;		call display_data_sp 
24ad			;		call next_page_prompt 
24ad			 
24ad			 
24ad			 
24ad			 
24ad c9				ret 
24ae			 
24ae .. 00		.bootforth: db " Forth Kernel Init ",0 
24c2			 
24c2			; TODO push to stack 
24c2			 
24c2			;  
24c2			 
24c2			if FORTH_PARSEV2 
24c2			 
24c2			 
24c2				include "forth_parserv2.asm" 
24c2			 
24c2			endif 
24c2			 
24c2			 
24c2			; parse cli version 1 
24c2			 
24c2			if FORTH_PARSEV1 
24c2			 
24c2			 
24c2			 
24c2			      include "forth_parserv1.asm" 
24c2			endif 
24c2				 
24c2			if FORTH_PARSEV3 
24c2			 
24c2			 
24c2			 
24c2			      include "forth_parserv3.asm" 
24c2				include "forth_wordsv3.asm" 
24c2			endif 
24c2			 
24c2			if FORTH_PARSEV4 
24c2			 
24c2			 
24c2			 
24c2			      include "forth_parserv4.asm" 
24c2				include "forth_wordsv4.asm" 
24c2			endif 
24c2			 
24c2			if FORTH_PARSEV5 
24c2			 
24c2			 
24c2			 
24c2			      include "forth_parserv5.asm" 
24c2			 
24c2			 
24c2			; A better parser without using malloc and string copies all over the place.  
24c2			; Exec in situ should be faster 
24c2			 
24c2			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24c2			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24c2			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24c2			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24c2			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24c2			WORD_SYS_END: equ 0   ; Opcode for all user words 
24c2			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24c2			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24c2			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24c2			 
24c2			; Core word preamble macro 
24c2			 
24c2			CWHEAD:   macro nxtword opcode lit len opflags 
24c2				db WORD_SYS_CORE+opcode             
24c2				; internal op code number 
24c2				dw nxtword            
24c2				; link to next dict word block 
24c2				db len + 1 
24c2				; literal length of dict word inc zero term 
24c2				db lit,0              
24c2				; literal dict word 
24c2			        ; TODO db opflags        
24c2				endm 
24c2			 
24c2			 
24c2			NEXTW: macro  
24c2				jp macro_next 
24c2				endm 
24c2			 
24c2			macro_next: 
24c2			if DEBUG_FORTH_PARSE_KEY 
24c2				DMARK "NXT" 
24c2				CALLMONITOR 
24c2			endif	 
24c2			;	inc hl  ; skip token null term  
24c2 ed 4b 3d fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24c6 ed 5b 3b fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24ca 2a bf f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24cd			if DEBUG_FORTH_PARSE_KEY 
24cd				DMARK "}AA" 
24cd				CALLMONITOR 
24cd			endif	 
24cd c3 d0 25			jp execnext 
24d0				;jp exec1 
24d0			       
24d0			 
24d0			 
24d0			; Another go at the parser to compile  
24d0			 
24d0			 
24d0			; TODO rework parser to change all of the string words to byte tokens 
24d0			; TODO do a search for  
24d0			 
24d0			; TODO first run normal parser to zero term sections 
24d0			; TODO for each word do a token look up to get the op code 
24d0			; TODO need some means to flag to the exec that this is a byte code form    
24d0			 
24d0			 
24d0			forthcompile: 
24d0			 
24d0			; 
24d0			; line parse: 
24d0			;       parse raw input buffer 
24d0			;       tokenise the words 
24d0			;       malloc new copy (for looping etc) 
24d0			;       copy to malloc + current pc in line to start of string and add line term 
24d0			;       save on new rsp 
24d0			; 
24d0			 
24d0			; hl to point to the line to tokenise 
24d0			 
24d0			;	push hl 
24d0 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
24d3			 
24d3			;	ld a,0		; string term on input 
24d3			;	call strlent 
24d3			 
24d3			;	ld (os_tok_len), hl	 ; save string length 
24d3			 
24d3			;if DEBUG_FORTH_TOK 
24d3			;	ex de,hl		 
24d3			;endif 
24d3			 
24d3			;	pop hl 		; get back string pointer 
24d3			 
24d3			if DEBUG_FORTH_TOK 
24d3						DMARK "TOc" 
24d3				CALLMONITOR 
24d3			endif 
24d3 7e			.cptoken2:    ld a,(hl) 
24d4 23				inc hl 
24d5 fe 7f			cp FORTH_END_BUFFER 
24d7 28 29			jr z, .cptokendone2 
24d9 fe 00			cp 0 
24db 28 25			jr z, .cptokendone2 
24dd fe 22			cp '"' 
24df 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24e1 fe 20			cp ' ' 
24e3 20 ee			jr nz,  .cptoken2 
24e5			 
24e5			; TODO consume comments held between ( and ) 
24e5			 
24e5				; we have a space so change to zero term for dict match later 
24e5 2b				dec hl 
24e6 3e 00			ld a,0 
24e8 77				ld (hl), a 
24e9 23				inc hl 
24ea 18 e7			jr .cptoken2 
24ec				 
24ec			 
24ec			.cptokenstr2: 
24ec				; skip all white space until either eol (because forgot to term) or end double quote 
24ec			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24ec				;inc hl ; skip current double quote 
24ec 7e				ld a,(hl) 
24ed 23				inc hl 
24ee fe 22			cp '"' 
24f0 28 e1			jr z, .cptoken2 
24f2 fe 7f			cp FORTH_END_BUFFER 
24f4 28 0c			jr z, .cptokendone2 
24f6 fe 00			cp 0 
24f8 28 08			jr z, .cptokendone2 
24fa fe 20			cp ' ' 
24fc 28 02			jr z, .cptmp2 
24fe 18 ec			jr .cptokenstr2 
2500			 
2500			.cptmp2:	; we have a space so change to zero term for dict match later 
2500				;dec hl 
2500				;ld a,"-"	; TODO remove this when working 
2500				;ld (hl), a 
2500				;inc hl 
2500 18 ea			jr .cptokenstr2 
2502			 
2502			.cptokendone2: 
2502				;inc hl 
2502 3e 7f			ld a, FORTH_END_BUFFER 
2504 77				ld (hl),a 
2505 23				inc hl 
2506 3e 21			ld a, '!' 
2508 77				ld (hl),a 
2509			 
2509 2a bf f4			ld hl,(os_tok_ptr) 
250c			         
250c			if DEBUG_FORTH_TOK 
250c						DMARK "Tc1" 
250c				CALLMONITOR 
250c			endif 
250c			 
250c				; push exec string to top of return stack 
250c				FORTH_RSP_NEXT 
250c cd bc 20			call macro_forth_rsp_next 
250f				endm 
# End of macro FORTH_RSP_NEXT
250f c9				ret 
2510			 
2510			; Another go at the parser need to simplify the process 
2510			 
2510			forthparse: 
2510			 
2510			; 
2510			; line parse: 
2510			;       parse raw input buffer 
2510			;       tokenise the words 
2510			;       malloc new copy (for looping etc) 
2510			;       copy to malloc + current pc in line to start of string and add line term 
2510			;       save on new rsp 
2510			; 
2510			 
2510			; hl to point to the line to tokenise 
2510			 
2510			;	push hl 
2510 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
2513			 
2513			;	ld a,0		; string term on input 
2513			;	call strlent 
2513			 
2513			;	ld (os_tok_len), hl	 ; save string length 
2513			 
2513			;if DEBUG_FORTH_TOK 
2513			;	ex de,hl		 
2513			;endif 
2513			 
2513			;	pop hl 		; get back string pointer 
2513			 
2513			if DEBUG_FORTH_TOK 
2513						DMARK "TOK" 
2513				CALLMONITOR 
2513			endif 
2513 7e			.ptoken2:    ld a,(hl) 
2514 23				inc hl 
2515 fe 7f			cp FORTH_END_BUFFER 
2517 28 29			jr z, .ptokendone2 
2519 fe 00			cp 0 
251b 28 25			jr z, .ptokendone2 
251d fe 22			cp '"' 
251f 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2521 fe 20			cp ' ' 
2523 20 ee			jr nz,  .ptoken2 
2525			 
2525			; TODO consume comments held between ( and ) 
2525			 
2525				; we have a space so change to zero term for dict match later 
2525 2b				dec hl 
2526 3e 00			ld a,0 
2528 77				ld (hl), a 
2529 23				inc hl 
252a 18 e7			jr .ptoken2 
252c				 
252c			 
252c			.ptokenstr2: 
252c				; skip all white space until either eol (because forgot to term) or end double quote 
252c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
252c				;inc hl ; skip current double quote 
252c 7e				ld a,(hl) 
252d 23				inc hl 
252e fe 22			cp '"' 
2530 28 e1			jr z, .ptoken2 
2532 fe 7f			cp FORTH_END_BUFFER 
2534 28 0c			jr z, .ptokendone2 
2536 fe 00			cp 0 
2538 28 08			jr z, .ptokendone2 
253a fe 20			cp ' ' 
253c 28 02			jr z, .ptmp2 
253e 18 ec			jr .ptokenstr2 
2540			 
2540			.ptmp2:	; we have a space so change to zero term for dict match later 
2540				;dec hl 
2540				;ld a,"-"	; TODO remove this when working 
2540				;ld (hl), a 
2540				;inc hl 
2540 18 ea			jr .ptokenstr2 
2542			 
2542			.ptokendone2: 
2542				;inc hl 
2542 3e 7f			ld a, FORTH_END_BUFFER 
2544 77				ld (hl),a 
2545 23				inc hl 
2546 3e 21			ld a, '!' 
2548 77				ld (hl),a 
2549			 
2549 2a bf f4			ld hl,(os_tok_ptr) 
254c			         
254c			if DEBUG_FORTH_TOK 
254c						DMARK "TK1" 
254c				CALLMONITOR 
254c			endif 
254c			 
254c				; push exec string to top of return stack 
254c				FORTH_RSP_NEXT 
254c cd bc 20			call macro_forth_rsp_next 
254f				endm 
# End of macro FORTH_RSP_NEXT
254f c9				ret 
2550			 
2550			; 
2550			;	; malloc size + buffer pointer + if is loop flag 
2550			;	ld hl,(os_tok_len) 		 ; get string length 
2550			; 
2550			;	ld a,l 
2550			; 
2550			;	cp 0			; we dont want to use a null string 
2550			;	ret z 
2550			; 
2550			;;	add 3    ; prefix malloc with buffer for current word ptr 
2550			; 
2550			;	add 5     ; TODO when certain not over writing memory remove 
2550			; 
2550			;		 
2550			; 
2550			;if DEBUG_FORTH_TOK 
2550			;			DMARK "TKE" 
2550			;	CALLMONITOR 
2550			;endif 
2550			; 
2550			;	ld l,a 
2550			;	ld h,0 
2550			;;	push hl   ; save required space for the copy later 
2550			;	call malloc 
2550			;if DEBUG_FORTH_TOK 
2550			;			DMARK "TKM" 
2550			;	CALLMONITOR 
2550			;endif 
2550			;	if DEBUG_FORTH_MALLOC_GUARD 
2550			;		push af 
2550			;		call ishlzero 
2550			;;		ld a, l 
2550			;;		add h 
2550			;;		cp 0 
2550			;		pop af 
2550			;		 
2550			;		call z,malloc_error 
2550			;	endif 
2550			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2550			; 
2550			; 
2550			;if DEBUG_FORTH_TOK 
2550			;			DMARK "TKR" 
2550			;	CALLMONITOR 
2550			;endif 
2550			; 
2550			;	FORTH_RSP_NEXT 
2550			; 
2550			;	;inc hl	 ; go past current buffer pointer 
2550			;	;inc hl 
2550			;	;inc hl   ; and past if loop flag 
2550			;		; TODO Need to set flag  
2550			; 
2550			;	 
2550			;	 
2550			;	ex de,hl	; malloc is dest 
2550			;	ld hl, (os_tok_len) 
2550			;;	pop bc 
2550			;	ld c, l                
2550			;	ld b,0 
2550			;	ld hl, (os_tok_ptr) 
2550			; 
2550			;if DEBUG_FORTH_TOK 
2550			;			DMARK "TKT" 
2550			;	CALLMONITOR 
2550			;endif 
2550			; 
2550			;	; do str cpy 
2550			; 
2550			;	ldir      ; copy byte in hl to de 
2550			; 
2550			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2550			; 
2550			;if DEBUG_FORTH_TOK 
2550			; 
2550			;			DMARK "TKY" 
2550			;	CALLMONITOR 
2550			;endif 
2550			;	;ld a,0 
2550			;	;ld a,FORTH_END_BUFFER 
2550			;	ex de, hl 
2550			;	;dec hl			 ; go back over the space delim at the end of word 
2550			;	;ld (hl),a 
2550			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2550			;	ld a,FORTH_END_BUFFER 
2550			;	ld (hl),a 
2550			;	inc hl 
2550			;	ld a,FORTH_END_BUFFER 
2550			;	ld (hl),a 
2550			; 
2550			;	; init the malloc area data 
2550			;	; set pc for in current area 
2550			;	;ld hl, (os_tok_malloc) 
2550			;	;inc hl 
2550			;	;inc hl 
2550			;	;inc hl 
2550			;	;ex de,hl 
2550			;	;ld hl, (os_tok_malloc) 
2550			;	;ld (hl),e 
2550			;	;inc hl 
2550			;	;ld (hl),d 
2550			; 
2550			; 
2550			;	ld hl,(os_tok_malloc) 
2550			;if DEBUG_FORTH_PARSE_KEY 
2550			;			DMARK "TKU" 
2550			;	CALLMONITOR 
2550			;endif 
2550			; 
2550			;	ret 
2550			 
2550			forthexec: 
2550			 
2550			; line exec: 
2550			; forth parser 
2550			 
2550			; 
2550			;       get current exec line on rsp 
2550			 
2550				FORTH_RSP_TOS 
2550 cd d3 20			call macro_forth_rsp_tos 
2553				endm 
# End of macro FORTH_RSP_TOS
2553			 
2553			;       restore current pc - hl points to malloc of data 
2553			 
2553				;ld e, (hl) 
2553				;inc hl 
2553				;ld d, (hl) 
2553				;ex de,hl 
2553			 
2553			 
2553			exec1: 
2553 22 bf f4			ld (os_tok_ptr), hl 
2556			 
2556				; copy our PC to working vars  
2556 22 3d fa			ld (cli_ptr), hl 
2559 22 3b fa			ld (cli_origptr), hl 
255c			 
255c 7e				ld a,(hl) 
255d fe 7f			cp FORTH_END_BUFFER 
255f c8				ret z 
2560			 
2560				; skip any nulls 
2560			 
2560 fe 00			cp 0 
2562 20 03			jr nz, .execword 
2564 23				inc hl 
2565 18 ec			jr exec1 
2567			 
2567			 
2567			.execword: 
2567			 
2567			 
2567			 
2567			if DEBUG_FORTH_PARSE_KEY 
2567						DMARK "KYQ" 
2567				CALLMONITOR 
2567			endif 
2567			;       while at start of word: 
2567			; get start of dict (in user area first) 
2567			 
2567 21 00 80		ld hl, baseram 
256a			;ld hl, sysdict 
256a 22 3f fa		ld (cli_nextword),hl 
256d			;           match word at pc 
256d			;           exec word 
256d			;           or push to dsp 
256d			;           forward to next token 
256d			;           if line term pop rsp and exit 
256d			;        
256d			 
256d			if DEBUG_FORTH_PARSE_KEY 
256d						DMARK "KYq" 
256d				CALLMONITOR 
256d			endif 
256d			 
256d			; 
256d			; word comp 
256d			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
256d			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
256d			;    move to start of word  
256d			;    compare word to cli_token 
256d			 
256d			.execpnword:	; HL at start of a word in the dictionary to check 
256d			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
256d			;	ld (cli_ptr), hl 
256d			 
256d 2a 3f fa			ld hl,(cli_nextword) 
2570			 
2570 cd 13 26			call forth_tok_next 
2573			; tok next start here 
2573			;	; TODO skip compiled symbol for now 
2573			;	inc hl 
2573			; 
2573			;	; save pointer to next word 
2573			; 
2573			;	; hl now points to the address of the next word pointer  
2573			;	ld e, (hl) 
2573			;	inc hl 
2573			;	ld d, (hl) 
2573			;	inc l 
2573			; 
2573			;	ex de,hl 
2573			;if DEBUG_FORTH_PARSE_NEXTWORD 
2573			;	push bc 
2573			;	ld bc, (cli_nextword) 
2573			;			DMARK "NXW" 
2573			;	CALLMONITOR 
2573			;	pop bc 
2573			;endif 
2573			; tok next end here 
2573 22 3f fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2576 eb				ex de, hl 
2577			 
2577			 
2577				; save the pointer of the current token - 1 to check against 
2577				 
2577 22 43 fa			ld (cli_token), hl   
257a				; TODO maybe remove below save if no debug 
257a				; save token string ptr for any debug later 
257a 23				inc hl  
257b 22 45 fa			ld (cli_origtoken), hl 
257e 2b				dec hl 
257f				; save pointer to the start of the next dictionay word 
257f 7e				ld a,(hl)   ; get string length 
2580 47				ld b,a 
2581			.execpnwordinc:  
2581 23				inc hl 
2582 10 fd			djnz .execpnwordinc 
2584 22 41 fa			ld (cli_execword), hl      ; save start of this words code 
2587			 
2587				; now check the word token against the string being parsed 
2587			 
2587 2a 43 fa			ld hl,(cli_token) 
258a 23				inc hl     ; skip string length (use zero term instead to end) 
258b 22 43 fa			ld (cli_token), hl 
258e			 
258e			if DEBUG_FORTH_PARSE_KEY 
258e						DMARK "KY2" 
258e			endif 
258e			if DEBUG_FORTH_PARSE_EXEC 
258e				; see if disabled 
258e			 
258e			;	ld a, (os_view_disable) 
258e			;	cp '*' 
258e				ld a, (debug_vector) 
258e				cp $c9   ; RET  
258e				jr z, .skip 
258e			 
258e				push hl 
258e				push hl 
258e				call clear_display 
258e				ld de, .compword 
258e				ld a, display_row_1 
258e				call str_at_display 
258e				pop de 
258e				ld a, display_row_2 
258e				call str_at_display 
258e				ld hl,(cli_ptr) 
258e				ld a,(hl) 
258e			        ld hl, os_word_scratch 
258e				ld (hl),a 
258e				ld a,0 
258e				inc hl 
258e				ld (hl),a 	 
258e				ld de, os_word_scratch 
258e				ld a, display_row_2+10 
258e				call str_at_display 
258e				call update_display 
258e				ld a, 100 
258e				call aDelayInMS 
258e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
258e				call delay250ms 
258e				endif 
258e				pop hl 
258e			.skip:  
258e			endif	 
258e			.execpnchar:    ; compare char between token and string to parse 
258e			 
258e			if DEBUG_FORTH_PARSE_KEY 
258e						DMARK "Ky3" 
258e			endif 
258e			if DEBUG_FORTH_PARSE_EXEC 
258e				; see if disabled 
258e			 
258e			;	ld a, (os_view_disable) 
258e			;	cp '*' 
258e				ld a, (debug_vector) 
258e				cp $C9  ; RET 
258e				jr z, .skip2 
258e			 
258e			;	call clear_display 
258e			ld hl,(cli_token) 
258e			ld a,(hl) 
258e			ld (os_word_scratch),a 
258e				ld hl,(cli_ptr) 
258e			ld a,(hl) 
258e				ld (os_word_scratch+1),a 
258e				ld a,0 
258e				ld (os_word_scratch+2),a 
258e				ld de,os_word_scratch 
258e				ld a,display_row_4 
258e				call str_at_display 
258e				call update_display 
258e			.skip2:  
258e			endif 
258e 2a 43 fa			ld hl,(cli_token) 
2591 7e				ld a, (hl)	 ; char in word token 
2592 23				inc hl 		; move to next char 
2593 22 43 fa			ld (cli_token), hl ; and save it 
2596 47				ld b,a 
2597			 
2597 2a 3d fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
259a 7e				ld a,(hl) 
259b 23				inc hl 
259c 22 3d fa			ld (cli_ptr), hl		; move to next char 
259f cd 25 14			call toUpper 		; make sure the input string matches case 
25a2			 
25a2			if DEBUG_FORTH_PARSE 
25a2			endif 
25a2			 
25a2				; input stream end of token is a space so get rid of it 
25a2			 
25a2			;	cp ' ' 
25a2			;	jr nz, .pnskipspace 
25a2			; 
25a2			;	ld a, 0		; make same term as word token term 
25a2			; 
25a2			;.pnskipspace: 
25a2			 
25a2			if DEBUG_FORTH_PARSE_KEY 
25a2						DMARK "KY7" 
25a2			endif 
25a2 b8				cp b 
25a3 c2 b9 25			jp nz, .execpnskipword	 ; no match so move to next word 
25a6				 
25a6			;    if same 
25a6			;       scan for string terms 0 for token and 32 for input 
25a6			 
25a6				 
25a6			if DEBUG_FORTH_PARSE_KEY 
25a6						DMARK "KY8" 
25a6			endif 
25a6			 
25a6 80				add b			 
25a7 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
25a9							; TODO need to make sure last word in zero term string is accounted for 
25a9 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
25ab			 
25ab			 
25ab				; at end of both strings so both are exact match 
25ab			 
25ab			;       skip ptr for next word 
25ab			 
25ab 2a 3d fa			ld hl,(cli_ptr) 	; at input string term 
25ae 23				inc hl			 ; at next char 
25af 22 3d fa			ld (cli_ptr), hl     ; save for next round of the parser 
25b2 22 3b fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
25b5				 
25b5				 
25b5			if DEBUG_FORTH_PARSE_KEY 
25b5						DMARK "KY3" 
25b5			endif 
25b5			 
25b5			 
25b5			 
25b5			;       exec code block 
25b5			if DEBUG_FORTH_JP 
25b5				call clear_display 
25b5				call update_display 
25b5				call delay1s 
25b5				ld hl, (cli_execword)     ; save for next check if no match on this word 
25b5				ld a,h 
25b5				ld hl, os_word_scratch 
25b5				call hexout 
25b5				ld hl, (cli_execword)     ; save for next check if no match on this word 
25b5				ld a,l 
25b5				ld hl, os_word_scratch+2 
25b5				call hexout 
25b5				ld hl, os_word_scratch+4 
25b5				ld a,0 
25b5				ld (hl),a 
25b5				ld de,os_word_scratch 
25b5				call str_at_display 
25b5					ld a, display_row_2 
25b5					call str_at_display 
25b5				ld de, (cli_origtoken) 
25b5				ld a, display_row_1+10 
25b5					call str_at_display 
25b5			 
25b5				ld a,display_row_1 
25b5				ld de, .foundword 
25b5				ld a, display_row_3 
25b5				call str_at_display 
25b5				call update_display 
25b5				call delay1s 
25b5				call delay1s 
25b5				call delay1s 
25b5			endif 
25b5			 
25b5			if DEBUG_FORTH_PARSE_KEY 
25b5						DMARK "KYj" 
25b5			endif 
25b5				; TODO save the word pointer in this exec 
25b5			 
25b5 2a 41 fa			ld hl,(cli_execword) 
25b8 e9				jp (hl) 
25b9			 
25b9			 
25b9			;    if not same 
25b9			;	scan for zero term 
25b9			;	get ptr for next word 
25b9			;	goto word comp 
25b9			 
25b9			.execpnskipword:	; get pointer to next word 
25b9 2a 3f fa			ld hl,(cli_nextword) 
25bc			 
25bc 7e				ld a,(hl) 
25bd fe 00			cp WORD_SYS_END 
25bf			;	cp 0 
25bf 28 09			jr z, .execendofdict			 ; at end of words 
25c1			 
25c1			if DEBUG_FORTH_PARSE_KEY 
25c1						DMARK "KY4" 
25c1			endif 
25c1			if DEBUG_FORTH_PARSE_EXEC 
25c1			 
25c1				; see if disabled 
25c1			 
25c1			;	ld a, (os_view_disable) 
25c1			;	cp '*' 
25c1				ld a,(debug_vector) 
25c1				cp $c9   ; RET 
25c1				jr z, .noskip 
25c1			 
25c1			 
25c1				ld de, .nowordfound 
25c1				ld a, display_row_3 
25c1				call str_at_display 
25c1				call update_display 
25c1				ld a, 100 
25c1				call aDelayInMS 
25c1				 
25c1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25c1					call delay250ms 
25c1				endif 
25c1			.noskip:  
25c1			 
25c1			endif	 
25c1			 
25c1 2a 3b fa			ld hl,(cli_origptr) 
25c4 22 3d fa			ld (cli_ptr),hl 
25c7			 
25c7			if DEBUG_FORTH_PARSE_KEY 
25c7						DMARK "KY5" 
25c7			endif 
25c7 c3 6d 25			jp .execpnword			; else go to next word 
25ca			 
25ca			.execendofdict:  
25ca			 
25ca			if DEBUG_FORTH_PARSE_KEY 
25ca						DMARK "KYe" 
25ca			endif 
25ca			if DEBUG_FORTH_PARSE_EXEC 
25ca				; see if disabled 
25ca			 
25ca			;	ld a, (os_view_disable) 
25ca			;	cp '*' 
25ca				ld a,(debug_vector) 
25ca				cp $c9   ; ret 
25ca				jr z, .ispskip 
25ca			 
25ca				call clear_display 
25ca				call update_display 
25ca				call delay1s 
25ca				ld de, (cli_origptr) 
25ca				ld a, display_row_1 
25ca				call str_at_display 
25ca				 
25ca				ld de, .enddict 
25ca				ld a, display_row_3 
25ca				call str_at_display 
25ca				call update_display 
25ca				ld a, 100 
25ca				call aDelayInMS 
25ca				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25ca				call delay1s 
25ca				call delay1s 
25ca				call delay1s 
25ca				endif 
25ca			.ispskip:  
25ca				 
25ca			endif	 
25ca			 
25ca			 
25ca			 
25ca				; if the word is not a keyword then must be a literal so push it to stack 
25ca			 
25ca			; push token to stack to end of word 
25ca			 
25ca				STACKFRAME ON $1efe $2f9f 
25ca				if DEBUG_STACK_IMB 
25ca					if ON 
25ca						exx 
25ca						ld de, $1efe 
25ca						ld a, d 
25ca						ld hl, curframe 
25ca						call hexout 
25ca						ld a, e 
25ca						ld hl, curframe+2 
25ca						call hexout 
25ca						ld hl, $1efe 
25ca						push hl 
25ca						ld hl, $2f9f 
25ca						push hl 
25ca						exx 
25ca					endif 
25ca				endif 
25ca			endm 
# End of macro STACKFRAME
25ca			 
25ca 2a bf f4		ld hl,(os_tok_ptr) 
25cd cd 7e 22		call forth_apush 
25d0			 
25d0				STACKFRAMECHK ON $1efe $2f9f 
25d0				if DEBUG_STACK_IMB 
25d0					if ON 
25d0						exx 
25d0						ld hl, $2f9f 
25d0						pop de   ; $2f9f 
25d0						call cmp16 
25d0						jr nz, .spnosame 
25d0						ld hl, $1efe 
25d0						pop de   ; $1efe 
25d0						call cmp16 
25d0						jr z, .spfrsame 
25d0						.spnosame: call showsperror 
25d0						.spfrsame: nop 
25d0						exx 
25d0					endif 
25d0				endif 
25d0			endm 
# End of macro STACKFRAMECHK
25d0			 
25d0			execnext: 
25d0			 
25d0			if DEBUG_FORTH_PARSE_KEY 
25d0						DMARK "KY>" 
25d0			endif 
25d0			; move past token to next word 
25d0			 
25d0 2a bf f4		ld hl, (os_tok_ptr) 
25d3 3e 00		ld a, 0 
25d5 01 ff 00		ld bc, 255     ; input buffer size 
25d8 ed b1		cpir 
25da			 
25da			if DEBUG_FORTH_PARSE_KEY 
25da						DMARK "KY!" 
25da				CALLMONITOR 
25da			endif	 
25da			; TODO this might place hl on the null, so will need to forward on??? 
25da			;inc hl   ; see if this gets onto the next item 
25da			 
25da			 
25da			; TODO pass a pointer to the buffer to push 
25da			; TODO call function to push 
25da			 
25da			; look for end of input 
25da			 
25da			;inc hl 
25da			;ld a,(hl) 
25da			;cp FORTH_END_BUFFER 
25da			;ret z 
25da			 
25da			 
25da c3 53 25		jp exec1 
25dd			 
25dd			 
25dd			 
25dd			 
25dd			 
25dd			 
25dd			 
25dd			 
25dd			 
25dd			findnexttok: 
25dd			 
25dd				; hl is pointer to move 
25dd				; de is the token to locate 
25dd			 
25dd					if DEBUG_FORTH 
25dd						DMARK "NTK" 
25dd						CALLMONITOR 
25dd					endif 
25dd d5				push de 
25de			 
25de			.fnt1:	 
25de				; find first char of token to locate 
25de			 
25de 1a				ld a, (de) 
25df 4f				ld c,a 
25e0 7e				ld a,(hl) 
25e1 cd 25 14			call toUpper 
25e4					if DEBUG_FORTH 
25e4						DMARK "NT1" 
25e4						CALLMONITOR 
25e4					endif 
25e4 b9				cp c 
25e5			 
25e5 28 03			jr z, .fnt2cmpmorefirst	 
25e7			 
25e7				; first char not found move to next char 
25e7			 
25e7 23				inc hl 
25e8 18 f4			jr .fnt1 
25ea			 
25ea			.fnt2cmpmorefirst:	 
25ea				; first char of token found.  
25ea			 
25ea e5				push hl     ; save start of token just in case it is the right one 
25eb d9				exx 
25ec e1				pop hl        ; save it to hl' 
25ed d9				exx 
25ee			 
25ee			 
25ee			.fnt2cmpmore:	 
25ee				; compare the rest 
25ee				 
25ee 23				inc hl 
25ef 13				inc de 
25f0				 
25f0 1a				ld a, (de) 
25f1 4f				ld c,a 
25f2 7e				ld a,(hl) 
25f3 cd 25 14			call toUpper 
25f6			 
25f6					if DEBUG_FORTH 
25f6						DMARK "NT2" 
25f6						CALLMONITOR 
25f6					endif 
25f6				; c has the token to find char 
25f6				; a has the mem to scan char 
25f6			 
25f6 b9				cp c 
25f7 28 04			jr z,.fntmatch1 
25f9			 
25f9				; they are not the same 
25f9			 
25f9					if DEBUG_FORTH 
25f9						DMARK "NT3" 
25f9						CALLMONITOR 
25f9					endif 
25f9 d1				pop de	; reset de token to look for 
25fa d5				push de 
25fb 18 e1			jr .fnt1 
25fd				 
25fd			.fntmatch1: 
25fd			 
25fd				; is the same char a null which means we might have a full hit? 
25fd					if DEBUG_FORTH 
25fd						DMARK "NT4" 
25fd						CALLMONITOR 
25fd					endif 
25fd			 
25fd fe 00			cp 0 
25ff 28 0b			jr z, .fntmatchyes 
2601			 
2601				; are we at the end of the token to find? 
2601			 
2601					if DEBUG_FORTH 
2601						DMARK "NT5" 
2601						CALLMONITOR 
2601					endif 
2601 3e 00			ld a, 0 
2603 b9				cp c 
2604			 
2604 c2 ee 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2607			 
2607					if DEBUG_FORTH 
2607						DMARK "NT6" 
2607						CALLMONITOR 
2607					endif 
2607				; token to find is exhusted but no match to stream 
2607			 
2607				; restore tok pointer and continue on 
2607 d1				pop de 
2608 d5				push de 
2609 c3 de 25			jp .fnt1 
260c			 
260c			 
260c			.fntmatchyes: 
260c			 
260c				; hl now contains the end of the found token 
260c			 
260c				; get rid of saved token pointer to find 
260c			 
260c d1				pop de 
260d			 
260d					if DEBUG_FORTH 
260d						DMARK "NT9" 
260d						CALLMONITOR 
260d					endif 
260d			 
260d				; hl will be on the null term so forward on 
260d			 
260d				; get back the saved start of the token 
260d			 
260d d9				exx 
260e e5				push hl     ; save start of token just in case it is the right one 
260f d9				exx 
2610 e1				pop hl        ; save it to hl 
2611			 
2611 c9				ret 
2612			 
2612			 
2612			; LIST needs to find a specific token   
2612			; FORGET needs to find a spefici token 
2612			 
2612			; SAVE needs to find all tokens by flag 
2612			; WORDS just needs to scan through all  by flag 
2612			; UWORDS needs to scan through all by flag 
2612			 
2612			 
2612			; given hl as pointer to start of dict look up string 
2612			; return hl as pointer to start of word block 
2612			; or 0 if not found 
2612			 
2612			forth_find_tok: 
2612 c9				ret 
2613			 
2613			; given hl as pointer to dict structure 
2613			; move to the next dict block structure 
2613			 
2613			forth_tok_next: 
2613				; hl now points to the address of the next word pointer  
2613				; TODO skip compiled symbol for now 
2613			;	push de 
2613 23				inc hl 
2614 5e				ld e, (hl) 
2615 23				inc hl 
2616 56				ld d, (hl) 
2617 23				inc hl 
2618			 
2618 eb				ex de,hl 
2619			if DEBUG_FORTH_PARSE_NEXTWORD 
2619				push bc 
2619				ld bc, (cli_nextword) 
2619						DMARK "NXW" 
2619				CALLMONITOR 
2619				pop bc 
2619			endif 
2619			;	pop de	 
2619 c9				ret 
261a			 
261a			 
261a			 
261a			; eof 
# End of file forth_parserv5.asm
261a				include "forth_wordsv4.asm" 
261a			 
261a			; the core word dictionary v4 
261a			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
261a			 
261a			; this is a linked list for each of the system words used 
261a			; user defined words will follow the same format but will be in ram 
261a			 
261a			 
261a			; 
261a			; 
261a			; define linked list: 
261a			; 
261a			; 1. compiled byte op code 
261a			; 2. len of text word 
261a			; 3. text word 
261a			; 4. ptr to next dictionary word 
261a			; 5. asm, calls etc for the word 
261a			; 
261a			;  if 1 == 0 then last word in dict  
261a			;   
261a			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
261a			;  
261a			;  
261a			; create basic standard set of words 
261a			; 
261a			;  
261a			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
261a			; 2DUP 2DROP 2SWAP  
261a			; @ C@ - get byte  
261a			; ! C! - store byte 
261a			; 0< true if less than zero 
261a			; 0= true if zero 
261a			; < >  
261a			; = true if same 
261a			; variables 
261a			 
261a			 
261a			; Hardware specific words I may need 
261a			; 
261a			; IN OUT  
261a			; calls to key util functions 
261a			; calls to hardward abstraction stuff 
261a			; easy control of frame buffers and lcd i/o 
261a			; keyboard  
261a			 
261a			 
261a			;DICT: macro 
261a			; op_code, len, word, next 
261a			;    word: 
261a			;    db op_code 
261a			;    ds word zero term 
261a			;    dw next 
261a			;    endm 
261a			 
261a			 
261a			 
261a			 
261a			; op code 1 is a flag for user define words which are to be handled differently 
261a			 
261a			 
261a			; 
261a			; 
261a			;    TODO on entry to a word this should be the expected environment 
261a			;    hl - tos value if number then held, if string this is the ptr 
261a			;    de -  
261a			 
261a			 
261a			; opcode ranges 
261a			; 0 - end of word dict 
261a			; 255 - user define words 
261a			 
261a			sysdict: 
261a			include "forth_opcodes.asm" 
261a			; op codes for forth keywords 
261a			; free to use code 0  
261a				OPCODE_HEAP: equ  1 
261a				OPCODE_EXEC: equ 2 
261a				OPCODE_DUP: equ 3 
261a				OPCODE_SWAP: equ 4 
261a				OPCODE_COLN: equ 5 
261a				OPCODE_SCOLN: equ 6 
261a				OPCODE_DROP: equ 7 
261a				OPCODE_DUP2: equ 8 
261a				OPCODE_DROP2: equ 9 
261a				OPCODE_SWAP2: equ 10 
261a				OPCODE_AT: equ 11 
261a				OPCODE_CAT: equ 12 
261a				OPCODE_BANG: equ 13 
261a				OPCODE_CBANG: equ 14 
261a				OPCODE_SCALL: equ 15 
261a				OPCODE_DEPTH: equ 16 
261a				OPCODE_OVER: equ 17 
261a				OPCODE_PAUSE: equ 18 
261a				OPCODE_PAUSES: equ 19 
261a				OPCODE_ROT: equ 20 
261a			;free to reuse	OPCODE_WORDS: equ 21 
261a			        OPCODE_NOT: equ 21 
261a				OPCODE_UWORDS: equ 22 
261a				OPCODE_BP: equ 23 
261a				OPCODE_MONITOR: equ 24  
261a				OPCODE_MALLOC: equ 25 
261a				OPCODE_FREE: equ 26 
261a				OPCODE_LIST: equ 27 
261a				OPCODE_FORGET: equ 28 
261a				OPCODE_NOP: equ 29 
261a				OPCODE_COMO: equ 30 
261a				OPCODE_COMC: equ 31 
261a			;free to reuse	OPCODE_ENDCORE: equ 32 
261a				OPCODE_AFTERSOUND: equ 33 
261a				OPCODE_GP2: equ 34 
261a				OPCODE_GP3: equ 35 
261a				OPCODE_GP4: equ 36 
261a				OPCODE_SIN: equ 37 
261a				OPCODE_SOUT: equ 38 
261a				OPCODE_SPIO: equ 39 
261a				OPCODE_SPICEH: equ 40 
261a				OPCODE_SPIOb: equ 41 
261a				OPCODE_SPII: equ 42 
261a				OPCODE_SESEL: equ 43 
261a				OPCODE_CARTDEV: equ 44 
261a			; free to reuse	OPCODE_ENDDEVICE: equ 45 
261a				OPCODE_FB: equ 46 
261a				OPCODE_EMIT: equ 47 
261a				OPCODE_DOTH: equ 48 
261a				OPCODE_DOTF: equ 49 
261a				OPCODE_DOT: equ 50 
261a				OPCODE_CLS: equ 51 
261a				OPCODE_DRAW: equ 52 
261a				OPCODE_DUMP: equ 53 
261a				OPCODE_CDUMP: equ 54 
261a				OPCODE_DAT: equ 55 
261a				OPCODE_HOME: equ 56 
261a				OPCODE_SPACE: equ 57 
261a				OPCODE_SPACES: equ 58 
261a				OPCODE_SCROLL: equ 59 
261a				OPCODE_ATQ: equ 60 
261a				OPCODE_AUTODSP: equ 61 
261a				OPCODE_MENU: equ 62 
261a			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
261a				OPCODE_THEN: equ 64 
261a				OPCODE_ELSE: equ 65 
261a				OPCODE_DO: equ 66 
261a				OPCODE_LOOP: equ 67 
261a				OPCODE_I: equ 68 
261a				OPCODE_DLOOP: equ 69  
261a				OPCODE_REPEAT: equ 70  
261a				OPCODE_UNTIL: equ 71 
261a				OPCODE_ENDFLOW: equ 72 
261a				OPCODE_WAITK: equ 73 
261a				OPCODE_ACCEPT: equ 74 
261a				OPCODE_EDIT: equ 75 
261a			;free to reuse	OPCODE_ENDKEY: equ 76 
261a				OPCODE_LZERO: equ 77 
261a				OPCODE_TZERO: equ 78 
261a				OPCODE_LESS: equ 79 
261a				OPCODE_GT: equ 80 
261a				OPCODE_EQUAL: equ 81  
261a			;free to reuse	OPCODE_ENDLOGIC: equ 82 
261a				OPCODE_NEG: equ 83 
261a				OPCODE_DIV: equ 84 
261a				OPCODE_MUL: equ 85 
261a				OPCODE_MIN: equ 86 
261a				OPCODE_MAX: equ 87 
261a				OPCODE_RND16: equ 88 
261a				OPCODE_RND8: equ 89 
261a				OPCODE_RND: equ 90 
261a			;free to reuse	OPCODE_ENDMATHS: equ 91  
261a				OPCODE_BYNAME: equ 92 
261a				OPCODE_DIR: equ 93 
261a				OPCODE_SAVE: equ 94 
261a				OPCODE_LOAD: equ 95 
261a				OPCODE_BSAVE: equ 96 
261a				OPCODE_BLOAD: equ 97 
261a				OPCODE_SEO: equ 98  
261a				OPCODE_SEI: equ 99 
261a				OPCODE_SFREE: equ 100 
261a				OPCODE_SIZE: equ 101 
261a				OPCODE_CREATE: equ 102 
261a				OPCODE_APPEND: equ 103 
261a				OPCODE_SDEL: equ 104 
261a				OPCODE_OPEN: equ 105 
261a				OPCODE_READ: equ 106 
261a				OPCODE_EOF: equ 106 
261a				OPCODE_FORMAT: equ 107 
261a				OPCODE_LABEL: equ 108 
261a				OPCODE_LABELS: equ 109 
261a			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
261a				OPCODE_UPPER: equ 111 
261a				OPCODE_LOWER: equ 112 
261a				OPCODE_SUBSTR: equ 113 
261a				OPCODE_LEFT: equ 114 
261a				OPCODE_RIGHT: equ 115 
261a				OPCODE_STR2NUM: equ 116 
261a				OPCODE_NUM2STR: equ 117 
261a				OPCODE_CONCAT: equ 118 
261a				OPCODE_FIND: equ 119 
261a				OPCODE_LEN: equ 120 
261a				OPCODE_CHAR: equ 121 
261a			; free to reuse	OPCODE_STRLEN: equ 122 
261a			; free to reuse	OPCODE_ENDSTR: equ 123 
261a				OPCODE_V0S: equ 124 
261a				OPCODE_V0Q: equ 125 
261a				OPCODE_V1S: equ 126 
261a				OPCODE_V1Q: equ 127 
261a				OPCODE_V2S: equ 128 
261a				OPCODE_V2Q: equ 129 
261a				OPCODE_V3S: equ 130 
261a				OPCODE_V3Q: equ 131 
261a			;free to reuse	OPCODE_END: equ 132 
261a				OPCODE_ZDUP: equ 133 
261a			 
261a			; eof 
# End of file forth_opcodes.asm
261a			 
261a			include "forth_words_core.asm" 
261a			 
261a			; | ## Core Words 
261a			 
261a			;if MALLOC_4 
261a			 
261a			.HEAP: 
261a				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
261a 15				db WORD_SYS_CORE+OPCODE_HEAP             
261b 59 26			dw .EXEC            
261d 05				db 4 + 1 
261e .. 00			db "HEAP",0              
2623				endm 
# End of macro CWHEAD
2623			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2623			; | | u1 - Current number of bytes in the heap 
2623			; | | u2 - Remaining bytes left on the heap 
2623			; | |  
2623			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2623			 
2623			 
2623					if DEBUG_FORTH_WORDS_KEY 
2623						DMARK "HEP" 
2623 f5				push af  
2624 3a 38 26			ld a, (.dmark)  
2627 32 68 fe			ld (debug_mark),a  
262a 3a 39 26			ld a, (.dmark+1)  
262d 32 69 fe			ld (debug_mark+1),a  
2630 3a 3a 26			ld a, (.dmark+2)  
2633 32 6a fe			ld (debug_mark+2),a  
2636 18 03			jr .pastdmark  
2638 ..			.dmark: db "HEP"  
263b f1			.pastdmark: pop af  
263c			endm  
# End of macro DMARK
263c						CALLMONITOR 
263c cd 6c fe			call debug_vector  
263f				endm  
# End of macro CALLMONITOR
263f					endif 
263f 2a 0a 80				ld hl, (free_list )      
2642 11 0e 80				ld de, heap_start 
2645			 
2645 ed 52				sbc hl, de  
2647			 
2647 cd 15 21				call forth_push_numhl 
264a			 
264a			 
264a ed 5b 0a 80			ld de, (free_list )      
264e 21 a5 f1				ld hl, heap_end 
2651			 
2651 ed 52				sbc hl, de 
2653			 
2653 cd 15 21				call forth_push_numhl 
2656					 
2656			 
2656					 
2656			 
2656			 
2656			 
2656					NEXTW 
2656 c3 c2 24			jp macro_next 
2659				endm 
# End of macro NEXTW
2659			;endif 
2659			 
2659			.EXEC: 
2659			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2659			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2659			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2659			;; > > 
2659			;; > >   
2659			;	STACKFRAME OFF $5efe $5f9f 
2659			; 
2659			;		if DEBUG_FORTH_WORDS_KEY 
2659			;			DMARK "EXE" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			; 
2659			;	FORTH_DSP_VALUEHL 
2659			; 
2659			;	FORTH_DSP_POP 
2659			; 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EX1" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;;	ld e,(hl) 
2659			;;	inc hl 
2659			;;	ld d,(hl) 
2659			;;	ex de,hl 
2659			; 
2659			;;		if DEBUG_FORTH_WORDS 
2659			;;			DMARK "EX2" 
2659			;;			CALLMONITOR 
2659			;;		endif 
2659			;	push hl 
2659			; 
2659			;	;ld a, 0 
2659			;	;ld a, FORTH_END_BUFFER 
2659			;	call strlenz 
2659			;	inc hl   ; include zero term to copy 
2659			;	inc hl   ; include term 
2659			;	inc hl   ; include term 
2659			;	ld b,0 
2659			;	ld c,l 
2659			;	pop hl 
2659			;	ld de, execscratch 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EX3" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;	ldir 
2659			; 
2659			; 
2659			;	ld hl, execscratch 
2659			; 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EXe" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			; 
2659			;	call forthparse 
2659			;	call forthexec 
2659			;;	call forthexec_cleanup 
2659			;;	call forthparse 
2659			;;	call forthexec 
2659			; 
2659			;	STACKFRAMECHK OFF $5efe $5f9f 
2659			; 
2659			;	; an immediate word so no need to process any more words 
2659			;	ret 
2659			;	NEXTW 
2659			 
2659			; dead code - old version  
2659			;	FORTH_RSP_NEXT 
2659			 
2659			;  
2659			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2659			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2659			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2659			;	push hl 
2659			;	push de 
2659			;	push bc 
2659			; 
2659			; 
2659			;		if DEBUG_FORTH_WORDS_KEY 
2659			;			DMARK "EXR" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			; 
2659			; 
2659			; 
2659			;	;v5 FORTH_DSP_VALUE 
2659			;	FORTH_DSP_VALUEHL 
2659			; 
2659			;	; TODO do string type checks 
2659			; 
2659			;;v5	inc hl   ; skip type 
2659			; 
2659			;	push hl  ; source code  
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EX1" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;	ld a, 0 
2659			;	call strlent 
2659			; 
2659			;	inc hl 
2659			;	inc hl 
2659			;	inc hl 
2659			;	inc hl 
2659			; 
2659			;	push hl    ; size 
2659			; 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EX2" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;	call malloc 
2659			; 
2659			;	ex de, hl    ; de now contains malloc area 
2659			;	pop bc   	; get byte count 
2659			;	pop hl      ; get string to copy 
2659			; 
2659			;	push de     ; save malloc for free later 
2659			; 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EX3" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;	ldir       ; duplicate string 
2659			; 
2659			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2659			;	 
2659			;	; TODO fix the parse would be better than this...  
2659			;	ex de, hl 
2659			;	dec hl 
2659			;	ld a, 0 
2659			;	ld (hl), a 
2659			;	dec hl 
2659			;	ld a, ' ' 
2659			;	ld (hl), a 
2659			;	dec hl 
2659			;	ld (hl), a 
2659			; 
2659			;	dec hl 
2659			;	ld (hl), a 
2659			; 
2659			; 
2659			;	FORTH_DSP_POP  
2659			; 
2659			;	pop hl     
2659			;	push hl    ; save malloc area 
2659			; 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EX4" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			; 
2659			;	call forthparse 
2659			;	call forthexec 
2659			;	 
2659			;	pop hl 
2659			;	if DEBUG_FORTH_WORDS 
2659			;		DMARK "EX5" 
2659			;		CALLMONITOR 
2659			;	endif 
2659			; 
2659			;	if FORTH_ENABLE_FREE 
2659			;	call free 
2659			;	endif 
2659			; 
2659			;	if DEBUG_FORTH_WORDS 
2659			;		DMARK "EX6" 
2659			;		CALLMONITOR 
2659			;	endif 
2659			; 
2659			;	pop bc 
2659			;	pop de 
2659			;	pop hl 
2659			;;	FORTH_RSP_POP	  
2659			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2659			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2659			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2659			; 
2659			;	if DEBUG_FORTH_WORDS 
2659			;		DMARK "EX7" 
2659			;		CALLMONITOR 
2659			;	endif 
2659			;	NEXTW 
2659			 
2659			;.STKEXEC: 
2659			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2659			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2659			; 
2659			; 
2659			;		if DEBUG_FORTH_WORDS_KEY 
2659			;			DMARK "STX" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			; 
2659			;	FORTH_DSP_VALUEHL 
2659			; 
2659			;	ld (store_tmp1), hl    ; count 
2659			; 
2659			;	FORTH_DSP_POP 
2659			;.stkexec1: 
2659			;	ld hl, (store_tmp1)   ; count 
2659			;	ld a, 0 
2659			;	cp l 
2659			;	ret z 
2659			; 
2659			;	dec hl 
2659			;	ld (store_tmp1), hl    ; count 
2659			;	 
2659			;	FORTH_DSP_VALUEHL 
2659			;	push hl 
2659			;	 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EXp" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;	FORTH_DSP_POP 
2659			; 
2659			;	call strlenz 
2659			;	inc hl   ; include zero term to copy 
2659			;	inc hl   ; include zero term to copy 
2659			;	inc hl   ; include zero term to copy 
2659			;	ld b,0 
2659			;	ld c,l 
2659			;	pop hl 
2659			;	ld de, execscratch 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EX3" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;	ldir 
2659			; 
2659			; 
2659			;	ld hl, execscratch 
2659			; 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EXP" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			; 
2659			;	call forthparse 
2659			;	ld hl, execscratch 
2659			;		if DEBUG_FORTH_WORDS 
2659			;			DMARK "EXx" 
2659			;			CALLMONITOR 
2659			;		endif 
2659			;	call forthexec 
2659			; 
2659			;	jp .stkexec1 
2659			; 
2659			;	ret 
2659			 
2659			 
2659			.DUP: 
2659				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2659 17				db WORD_SYS_CORE+OPCODE_DUP             
265a cf 26			dw .ZDUP            
265c 04				db 3 + 1 
265d .. 00			db "DUP",0              
2661				endm 
# End of macro CWHEAD
2661			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2661			 
2661					if DEBUG_FORTH_WORDS_KEY 
2661						DMARK "DUP" 
2661 f5				push af  
2662 3a 76 26			ld a, (.dmark)  
2665 32 68 fe			ld (debug_mark),a  
2668 3a 77 26			ld a, (.dmark+1)  
266b 32 69 fe			ld (debug_mark+1),a  
266e 3a 78 26			ld a, (.dmark+2)  
2671 32 6a fe			ld (debug_mark+2),a  
2674 18 03			jr .pastdmark  
2676 ..			.dmark: db "DUP"  
2679 f1			.pastdmark: pop af  
267a			endm  
# End of macro DMARK
267a						CALLMONITOR 
267a cd 6c fe			call debug_vector  
267d				endm  
# End of macro CALLMONITOR
267d					endif 
267d			 
267d					FORTH_DSP 
267d cd d2 22			call macro_forth_dsp 
2680				endm 
# End of macro FORTH_DSP
2680			 
2680 7e					ld a, (HL) 
2681 fe 01				cp DS_TYPE_STR 
2683 20 25				jr nz, .dupinum 
2685			 
2685					; push another string 
2685			 
2685					FORTH_DSP_VALUEHL     		 
2685 cd 0c 23			call macro_dsp_valuehl 
2688				endm 
# End of macro FORTH_DSP_VALUEHL
2688			 
2688				if DEBUG_FORTH_WORDS 
2688					DMARK "DUs" 
2688 f5				push af  
2689 3a 9d 26			ld a, (.dmark)  
268c 32 68 fe			ld (debug_mark),a  
268f 3a 9e 26			ld a, (.dmark+1)  
2692 32 69 fe			ld (debug_mark+1),a  
2695 3a 9f 26			ld a, (.dmark+2)  
2698 32 6a fe			ld (debug_mark+2),a  
269b 18 03			jr .pastdmark  
269d ..			.dmark: db "DUs"  
26a0 f1			.pastdmark: pop af  
26a1			endm  
# End of macro DMARK
26a1					CALLMONITOR 
26a1 cd 6c fe			call debug_vector  
26a4				endm  
# End of macro CALLMONITOR
26a4				endif 
26a4 cd 83 21				call forth_push_str 
26a7			 
26a7					NEXTW 
26a7 c3 c2 24			jp macro_next 
26aa				endm 
# End of macro NEXTW
26aa			 
26aa			 
26aa			.dupinum: 
26aa					 
26aa			 
26aa			 
26aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26aa cd 0c 23			call macro_dsp_valuehl 
26ad				endm 
# End of macro FORTH_DSP_VALUEHL
26ad			 
26ad				; TODO add floating point number detection 
26ad			 
26ad				if DEBUG_FORTH_WORDS 
26ad					DMARK "DUi" 
26ad f5				push af  
26ae 3a c2 26			ld a, (.dmark)  
26b1 32 68 fe			ld (debug_mark),a  
26b4 3a c3 26			ld a, (.dmark+1)  
26b7 32 69 fe			ld (debug_mark+1),a  
26ba 3a c4 26			ld a, (.dmark+2)  
26bd 32 6a fe			ld (debug_mark+2),a  
26c0 18 03			jr .pastdmark  
26c2 ..			.dmark: db "DUi"  
26c5 f1			.pastdmark: pop af  
26c6			endm  
# End of macro DMARK
26c6					CALLMONITOR 
26c6 cd 6c fe			call debug_vector  
26c9				endm  
# End of macro CALLMONITOR
26c9				endif 
26c9			 
26c9 cd 15 21				call forth_push_numhl 
26cc					NEXTW 
26cc c3 c2 24			jp macro_next 
26cf				endm 
# End of macro NEXTW
26cf			.ZDUP: 
26cf				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26cf 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26d0 07 27			dw .SWAP            
26d2 05				db 4 + 1 
26d3 .. 00			db "?DUP",0              
26d8				endm 
# End of macro CWHEAD
26d8			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26d8			 
26d8					if DEBUG_FORTH_WORDS_KEY 
26d8						DMARK "qDU" 
26d8 f5				push af  
26d9 3a ed 26			ld a, (.dmark)  
26dc 32 68 fe			ld (debug_mark),a  
26df 3a ee 26			ld a, (.dmark+1)  
26e2 32 69 fe			ld (debug_mark+1),a  
26e5 3a ef 26			ld a, (.dmark+2)  
26e8 32 6a fe			ld (debug_mark+2),a  
26eb 18 03			jr .pastdmark  
26ed ..			.dmark: db "qDU"  
26f0 f1			.pastdmark: pop af  
26f1			endm  
# End of macro DMARK
26f1						CALLMONITOR 
26f1 cd 6c fe			call debug_vector  
26f4				endm  
# End of macro CALLMONITOR
26f4					endif 
26f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f4 cd 0c 23			call macro_dsp_valuehl 
26f7				endm 
# End of macro FORTH_DSP_VALUEHL
26f7			 
26f7 e5					push hl 
26f8			 
26f8					; is it a zero? 
26f8			 
26f8 3e 00				ld a, 0 
26fa 84					add h 
26fb 85					add l 
26fc			 
26fc e1					pop hl 
26fd			 
26fd fe 00				cp 0 
26ff 28 03				jr z, .dup2orig 
2701			 
2701			 
2701 cd 15 21				call forth_push_numhl 
2704			 
2704			 
2704				; TODO add floating point number detection 
2704			 
2704			.dup2orig: 
2704			 
2704					NEXTW 
2704 c3 c2 24			jp macro_next 
2707				endm 
# End of macro NEXTW
2707			.SWAP: 
2707				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2707 18				db WORD_SYS_CORE+OPCODE_SWAP             
2708 46 27			dw .COLN            
270a 05				db 4 + 1 
270b .. 00			db "SWAP",0              
2710				endm 
# End of macro CWHEAD
2710			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2710					if DEBUG_FORTH_WORDS_KEY 
2710						DMARK "SWP" 
2710 f5				push af  
2711 3a 25 27			ld a, (.dmark)  
2714 32 68 fe			ld (debug_mark),a  
2717 3a 26 27			ld a, (.dmark+1)  
271a 32 69 fe			ld (debug_mark+1),a  
271d 3a 27 27			ld a, (.dmark+2)  
2720 32 6a fe			ld (debug_mark+2),a  
2723 18 03			jr .pastdmark  
2725 ..			.dmark: db "SWP"  
2728 f1			.pastdmark: pop af  
2729			endm  
# End of macro DMARK
2729						CALLMONITOR 
2729 cd 6c fe			call debug_vector  
272c				endm  
# End of macro CALLMONITOR
272c					endif 
272c			 
272c					FORTH_DSP_VALUEHL 
272c cd 0c 23			call macro_dsp_valuehl 
272f				endm 
# End of macro FORTH_DSP_VALUEHL
272f e5					push hl     ; w2 
2730			 
2730					FORTH_DSP_POP 
2730 cd c4 23			call macro_forth_dsp_pop 
2733				endm 
# End of macro FORTH_DSP_POP
2733			 
2733					FORTH_DSP_VALUEHL 
2733 cd 0c 23			call macro_dsp_valuehl 
2736				endm 
# End of macro FORTH_DSP_VALUEHL
2736			 
2736					FORTH_DSP_POP 
2736 cd c4 23			call macro_forth_dsp_pop 
2739				endm 
# End of macro FORTH_DSP_POP
2739			 
2739 d1					pop de     ; w2	, hl = w1 
273a			 
273a eb					ex de, hl 
273b d5					push de 
273c			 
273c cd 15 21				call forth_push_numhl 
273f			 
273f e1					pop hl 
2740			 
2740 cd 15 21				call forth_push_numhl 
2743					 
2743			 
2743					NEXTW 
2743 c3 c2 24			jp macro_next 
2746				endm 
# End of macro NEXTW
2746			.COLN: 
2746				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2746 19				db WORD_SYS_CORE+OPCODE_COLN             
2747 d2 28			dw .SCOLN            
2749 02				db 1 + 1 
274a .. 00			db ":",0              
274c				endm 
# End of macro CWHEAD
274c			; | : ( -- )         Create new word | DONE 
274c			 
274c					if DEBUG_FORTH_WORDS_KEY 
274c						DMARK "CLN" 
274c f5				push af  
274d 3a 61 27			ld a, (.dmark)  
2750 32 68 fe			ld (debug_mark),a  
2753 3a 62 27			ld a, (.dmark+1)  
2756 32 69 fe			ld (debug_mark+1),a  
2759 3a 63 27			ld a, (.dmark+2)  
275c 32 6a fe			ld (debug_mark+2),a  
275f 18 03			jr .pastdmark  
2761 ..			.dmark: db "CLN"  
2764 f1			.pastdmark: pop af  
2765			endm  
# End of macro DMARK
2765						CALLMONITOR 
2765 cd 6c fe			call debug_vector  
2768				endm  
# End of macro CALLMONITOR
2768					endif 
2768				STACKFRAME OFF $8efe $989f 
2768				if DEBUG_STACK_IMB 
2768					if OFF 
2768						exx 
2768						ld de, $8efe 
2768						ld a, d 
2768						ld hl, curframe 
2768						call hexout 
2768						ld a, e 
2768						ld hl, curframe+2 
2768						call hexout 
2768						ld hl, $8efe 
2768						push hl 
2768						ld hl, $989f 
2768						push hl 
2768						exx 
2768					endif 
2768				endif 
2768			endm 
# End of macro STACKFRAME
2768				; get parser buffer length  of new word 
2768			 
2768				 
2768			 
2768					; move tok past this to start of name defintition 
2768					; TODO get word to define 
2768					; TODO Move past word token 
2768					; TODO get length of string up to the ';' 
2768			 
2768 2a bf f4			ld hl, (os_tok_ptr) 
276b 23				inc hl 
276c 23				inc hl 
276d			 
276d 3e 3b			ld a, ';' 
276f cd 39 14			call strlent 
2772			 
2772 7d				ld a,l 
2773 32 ba f1			ld (os_new_parse_len), a 
2776			 
2776			 
2776			if DEBUG_FORTH_UWORD 
2776 ed 5b bf f4		ld de, (os_tok_ptr) 
277a						DMARK ":01" 
277a f5				push af  
277b 3a 8f 27			ld a, (.dmark)  
277e 32 68 fe			ld (debug_mark),a  
2781 3a 90 27			ld a, (.dmark+1)  
2784 32 69 fe			ld (debug_mark+1),a  
2787 3a 91 27			ld a, (.dmark+2)  
278a 32 6a fe			ld (debug_mark+2),a  
278d 18 03			jr .pastdmark  
278f ..			.dmark: db ":01"  
2792 f1			.pastdmark: pop af  
2793			endm  
# End of macro DMARK
2793				CALLMONITOR 
2793 cd 6c fe			call debug_vector  
2796				endm  
# End of macro CALLMONITOR
2796			endif 
2796			 
2796			; 
2796			;  new word memory layout: 
2796			;  
2796			;    : adg 6666 ;  
2796			; 
2796			;    db   1     ; user defined word  
2796 23				inc hl    
2797			;    dw   sysdict 
2797 23				inc hl 
2798 23				inc hl 
2799			;    db <word len>+1 (for null) 
2799 23				inc hl 
279a			;    db .... <word> 
279a			; 
279a			 
279a 23				inc hl    ; some extras for the word preamble before the above 
279b 23				inc hl 
279c 23				inc hl 
279d 23				inc hl 
279e 23				inc hl 
279f 23				inc hl 
27a0 23				inc hl  
27a1 23				inc hl 
27a2 23				inc hl 
27a3 23				inc hl 
27a4 23				inc hl 
27a5 23				inc hl 
27a6 23				inc hl 
27a7 23				inc hl     ; TODO how many do we really need?     maybe only 6 
27a8			;       exec word buffer 
27a8			;	<ptr word>   
27a8 23				inc hl 
27a9 23				inc hl 
27aa			;       <word list><null term> 7F final term 
27aa			 
27aa			 
27aa			if DEBUG_FORTH_UWORD 
27aa						DMARK ":02" 
27aa f5				push af  
27ab 3a bf 27			ld a, (.dmark)  
27ae 32 68 fe			ld (debug_mark),a  
27b1 3a c0 27			ld a, (.dmark+1)  
27b4 32 69 fe			ld (debug_mark+1),a  
27b7 3a c1 27			ld a, (.dmark+2)  
27ba 32 6a fe			ld (debug_mark+2),a  
27bd 18 03			jr .pastdmark  
27bf ..			.dmark: db ":02"  
27c2 f1			.pastdmark: pop af  
27c3			endm  
# End of macro DMARK
27c3				CALLMONITOR 
27c3 cd 6c fe			call debug_vector  
27c6				endm  
# End of macro CALLMONITOR
27c6			endif 
27c6			 
27c6				 
27c6					; malloc the size 
27c6			 
27c6 cd 97 14				call malloc 
27c9 22 bc f1				ld (os_new_malloc), hl     ; save malloc start 
27cc			 
27cc			;    db   1     ; user defined word  
27cc 3e 01				ld a, WORD_SYS_UWORD  
27ce 77					ld (hl), a 
27cf				 
27cf 23				inc hl    
27d0			;    dw   sysdict 
27d0 11 1a 26			ld de, sysdict       ; continue on with the scan to the system dict 
27d3 73				ld (hl), e 
27d4 23				inc hl 
27d5 72				ld (hl), d 
27d6 23				inc hl 
27d7			 
27d7			 
27d7			;    Setup dict word 
27d7			 
27d7 23				inc hl 
27d8 22 b6 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
27db			 
27db				; 1. get length of dict word 
27db			 
27db			 
27db 2a bf f4			ld hl, (os_tok_ptr) 
27de 23				inc hl 
27df 23				inc hl    ; position to start of dict word 
27e0 3e 00			ld a, 0 
27e2 cd 39 14			call strlent 
27e5			 
27e5			 
27e5 23				inc hl    ; to include null??? 
27e6			 
27e6				; write length of dict word 
27e6			 
27e6 ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27ea 1b				dec de 
27eb eb				ex de, hl 
27ec 73				ld (hl), e 
27ed eb				ex de, hl 
27ee			 
27ee				 
27ee			 
27ee				; copy  
27ee 4d				ld c, l 
27ef 06 00			ld b, 0 
27f1 ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27f5 2a bf f4			ld hl, (os_tok_ptr) 
27f8 23				inc hl 
27f9 23				inc hl    ; position to start of dict word 
27fa				 
27fa			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27fa				 
27fa				; TODO need to convert word to upper case 
27fa			 
27fa			ucasetok:	 
27fa 7e				ld a,(hl) 
27fb cd 25 14			call toUpper 
27fe 77				ld (hl),a 
27ff ed a0			ldi 
2801 f2 fa 27		 	jp p, ucasetok 
2804			 
2804			 
2804			 
2804				; de now points to start of where the word body code should be placed 
2804 ed 53 b6 f1		ld (os_new_work_ptr), de 
2808				; hl now points to the words to throw at forthexec which needs to be copied 
2808 22 b4 f1			ld (os_new_src_ptr), hl 
280b			 
280b				; TODO add 'call to forthexec' 
280b			 
280b			if DEBUG_FORTH_UWORD 
280b c5				push bc 
280c ed 4b bc f1		ld bc, (os_new_malloc) 
2810						DMARK ":0x" 
2810 f5				push af  
2811 3a 25 28			ld a, (.dmark)  
2814 32 68 fe			ld (debug_mark),a  
2817 3a 26 28			ld a, (.dmark+1)  
281a 32 69 fe			ld (debug_mark+1),a  
281d 3a 27 28			ld a, (.dmark+2)  
2820 32 6a fe			ld (debug_mark+2),a  
2823 18 03			jr .pastdmark  
2825 ..			.dmark: db ":0x"  
2828 f1			.pastdmark: pop af  
2829			endm  
# End of macro DMARK
2829				CALLMONITOR 
2829 cd 6c fe			call debug_vector  
282c				endm  
# End of macro CALLMONITOR
282c c1				pop bc 
282d			endif 
282d			 
282d			 
282d				; create word preamble which should be: 
282d			 
282d			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
282d			 
282d				;    ld hl, <word code> 
282d				;    jp user_exec 
282d			        ;    <word code bytes> 
282d			 
282d			 
282d			;	inc de     ; TODO ??? or are we already past the word's null 
282d eb				ex de, hl 
282e			 
282e 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2830			 
2830 23				inc hl 
2831 22 b0 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2834 23				inc hl 
2835			 
2835 23				inc hl 
2836 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2838			 
2838 01 42 5d			ld bc, user_exec 
283b 23				inc hl 
283c 71				ld (hl), c     ; poke address of user_exec 
283d 23				inc hl 
283e 70				ld (hl), b     
283f			 ; 
283f			;	inc hl 
283f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
283f			; 
283f			; 
283f			;	ld bc, macro_forth_rsp_next 
283f			;	inc hl 
283f			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
283f			;	inc hl 
283f			;	ld (hl), b     
283f			 ; 
283f			;	inc hl 
283f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
283f			; 
283f			; 
283f			;	inc hl 
283f			;	ld bc, forthexec 
283f			;	ld (hl), c     ; poke address of forthexec 
283f			;	inc hl 
283f			;	ld (hl), b      
283f			; 
283f			;	inc hl 
283f			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
283f			; 
283f			;	ld bc, user_dict_next 
283f			;	inc hl 
283f			;	ld (hl), c     ; poke address of forthexec 
283f			;	inc hl 
283f			;	ld (hl), b      
283f			 
283f				; hl is now where we need to copy the word byte data to save this 
283f			 
283f 23				inc hl 
2840 22 b2 f1			ld (os_new_exec), hl 
2843				 
2843				; copy definition 
2843			 
2843 eb				ex de, hl 
2844			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2844			;	inc de    ; skip the PC for this parse 
2844 3a ba f1			ld a, (os_new_parse_len) 
2847 4f				ld c, a 
2848 06 00			ld b, 0 
284a ed b0			ldir		 ; copy defintion 
284c			 
284c			 
284c				; poke the address of where the new word bytes live for forthexec 
284c			 
284c 2a b0 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
284f			 
284f ed 5b b2 f1		ld de, (os_new_exec)      
2853				 
2853 73				ld (hl), e 
2854 23				inc hl 
2855 72				ld (hl), d 
2856			 
2856					; TODO copy last user dict word next link to this word 
2856					; TODO update last user dict word to point to this word 
2856			; 
2856			; hl f923 de 812a ; bc 811a 
2856			 
2856			if DEBUG_FORTH_UWORD 
2856 c5				push bc 
2857 ed 4b bc f1		ld bc, (os_new_malloc) 
285b						DMARK ":0A" 
285b f5				push af  
285c 3a 70 28			ld a, (.dmark)  
285f 32 68 fe			ld (debug_mark),a  
2862 3a 71 28			ld a, (.dmark+1)  
2865 32 69 fe			ld (debug_mark+1),a  
2868 3a 72 28			ld a, (.dmark+2)  
286b 32 6a fe			ld (debug_mark+2),a  
286e 18 03			jr .pastdmark  
2870 ..			.dmark: db ":0A"  
2873 f1			.pastdmark: pop af  
2874			endm  
# End of macro DMARK
2874				CALLMONITOR 
2874 cd 6c fe			call debug_vector  
2877				endm  
# End of macro CALLMONITOR
2877 c1				pop bc 
2878			endif 
2878			if DEBUG_FORTH_UWORD 
2878 c5				push bc 
2879 ed 4b bc f1		ld bc, (os_new_malloc) 
287d 03				inc bc 
287e 03				inc bc 
287f 03				inc bc 
2880 03				inc bc 
2881 03				inc bc 
2882 03				inc bc 
2883 03				inc bc 
2884 03				inc bc 
2885			 
2885						DMARK ":0B" 
2885 f5				push af  
2886 3a 9a 28			ld a, (.dmark)  
2889 32 68 fe			ld (debug_mark),a  
288c 3a 9b 28			ld a, (.dmark+1)  
288f 32 69 fe			ld (debug_mark+1),a  
2892 3a 9c 28			ld a, (.dmark+2)  
2895 32 6a fe			ld (debug_mark+2),a  
2898 18 03			jr .pastdmark  
289a ..			.dmark: db ":0B"  
289d f1			.pastdmark: pop af  
289e			endm  
# End of macro DMARK
289e				CALLMONITOR 
289e cd 6c fe			call debug_vector  
28a1				endm  
# End of macro CALLMONITOR
28a1 c1				pop bc 
28a2			endif 
28a2			 
28a2			; update word dict linked list for new word 
28a2			 
28a2			 
28a2 2a bb f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
28a5 23			inc hl     ; move to next work linked list ptr 
28a6			 
28a6 ed 5b bc f1	ld de, (os_new_malloc)		 ; new next word 
28aa 73			ld (hl), e 
28ab 23			inc hl 
28ac 72			ld (hl), d 
28ad			 
28ad			if DEBUG_FORTH_UWORD 
28ad ed 4b bb f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
28b1			endif 
28b1			 
28b1 ed 53 bb f4	ld (os_last_new_uword), de      ; update last new uword ptr 
28b5			 
28b5			 
28b5			if DEBUG_FORTH_UWORD 
28b5						DMARK ":0+" 
28b5 f5				push af  
28b6 3a ca 28			ld a, (.dmark)  
28b9 32 68 fe			ld (debug_mark),a  
28bc 3a cb 28			ld a, (.dmark+1)  
28bf 32 69 fe			ld (debug_mark+1),a  
28c2 3a cc 28			ld a, (.dmark+2)  
28c5 32 6a fe			ld (debug_mark+2),a  
28c8 18 03			jr .pastdmark  
28ca ..			.dmark: db ":0+"  
28cd f1			.pastdmark: pop af  
28ce			endm  
# End of macro DMARK
28ce				CALLMONITOR 
28ce cd 6c fe			call debug_vector  
28d1				endm  
# End of macro CALLMONITOR
28d1			endif 
28d1			 
28d1				STACKFRAMECHK OFF $8efe $989f 
28d1				if DEBUG_STACK_IMB 
28d1					if OFF 
28d1						exx 
28d1						ld hl, $989f 
28d1						pop de   ; $989f 
28d1						call cmp16 
28d1						jr nz, .spnosame 
28d1						ld hl, $8efe 
28d1						pop de   ; $8efe 
28d1						call cmp16 
28d1						jr z, .spfrsame 
28d1						.spnosame: call showsperror 
28d1						.spfrsame: nop 
28d1						exx 
28d1					endif 
28d1				endif 
28d1			endm 
# End of macro STACKFRAMECHK
28d1			 
28d1 c9			ret    ; dont process any remaining parser tokens as they form new word 
28d2			 
28d2			 
28d2			 
28d2			 
28d2			;		NEXT 
28d2			.SCOLN: 
28d2			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28d2 06				db OPCODE_SCOLN 
28d3 1e 29			dw .DROP 
28d5 02				db 2 
28d6 .. 00			db ";",0           
28d8			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28d8					if DEBUG_FORTH_WORDS_KEY 
28d8						DMARK "SCN" 
28d8 f5				push af  
28d9 3a ed 28			ld a, (.dmark)  
28dc 32 68 fe			ld (debug_mark),a  
28df 3a ee 28			ld a, (.dmark+1)  
28e2 32 69 fe			ld (debug_mark+1),a  
28e5 3a ef 28			ld a, (.dmark+2)  
28e8 32 6a fe			ld (debug_mark+2),a  
28eb 18 03			jr .pastdmark  
28ed ..			.dmark: db "SCN"  
28f0 f1			.pastdmark: pop af  
28f1			endm  
# End of macro DMARK
28f1						CALLMONITOR 
28f1 cd 6c fe			call debug_vector  
28f4				endm  
# End of macro CALLMONITOR
28f4					endif 
28f4					FORTH_RSP_TOS 
28f4 cd d3 20			call macro_forth_rsp_tos 
28f7				endm 
# End of macro FORTH_RSP_TOS
28f7 e5					push hl 
28f8					FORTH_RSP_POP 
28f8 cd dd 20			call macro_forth_rsp_pop 
28fb				endm 
# End of macro FORTH_RSP_POP
28fb e1					pop hl 
28fc			;		ex de,hl 
28fc 22 bf f4				ld (os_tok_ptr),hl 
28ff			 
28ff			if DEBUG_FORTH_UWORD 
28ff						DMARK "SCL" 
28ff f5				push af  
2900 3a 14 29			ld a, (.dmark)  
2903 32 68 fe			ld (debug_mark),a  
2906 3a 15 29			ld a, (.dmark+1)  
2909 32 69 fe			ld (debug_mark+1),a  
290c 3a 16 29			ld a, (.dmark+2)  
290f 32 6a fe			ld (debug_mark+2),a  
2912 18 03			jr .pastdmark  
2914 ..			.dmark: db "SCL"  
2917 f1			.pastdmark: pop af  
2918			endm  
# End of macro DMARK
2918				CALLMONITOR 
2918 cd 6c fe			call debug_vector  
291b				endm  
# End of macro CALLMONITOR
291b			endif 
291b					NEXTW 
291b c3 c2 24			jp macro_next 
291e				endm 
# End of macro NEXTW
291e			 
291e			.DROP: 
291e				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
291e 1b				db WORD_SYS_CORE+OPCODE_DROP             
291f 49 29			dw .DUP2            
2921 05				db 4 + 1 
2922 .. 00			db "DROP",0              
2927				endm 
# End of macro CWHEAD
2927			; | DROP ( w -- )   drop the TOS item   | DONE 
2927					if DEBUG_FORTH_WORDS_KEY 
2927						DMARK "DRP" 
2927 f5				push af  
2928 3a 3c 29			ld a, (.dmark)  
292b 32 68 fe			ld (debug_mark),a  
292e 3a 3d 29			ld a, (.dmark+1)  
2931 32 69 fe			ld (debug_mark+1),a  
2934 3a 3e 29			ld a, (.dmark+2)  
2937 32 6a fe			ld (debug_mark+2),a  
293a 18 03			jr .pastdmark  
293c ..			.dmark: db "DRP"  
293f f1			.pastdmark: pop af  
2940			endm  
# End of macro DMARK
2940						CALLMONITOR 
2940 cd 6c fe			call debug_vector  
2943				endm  
# End of macro CALLMONITOR
2943					endif 
2943					FORTH_DSP_POP 
2943 cd c4 23			call macro_forth_dsp_pop 
2946				endm 
# End of macro FORTH_DSP_POP
2946					NEXTW 
2946 c3 c2 24			jp macro_next 
2949				endm 
# End of macro NEXTW
2949			.DUP2: 
2949				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2949 1c				db WORD_SYS_CORE+OPCODE_DUP2             
294a 8e 29			dw .DROP2            
294c 05				db 4 + 1 
294d .. 00			db "2DUP",0              
2952				endm 
# End of macro CWHEAD
2952			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2952					if DEBUG_FORTH_WORDS_KEY 
2952						DMARK "2DU" 
2952 f5				push af  
2953 3a 67 29			ld a, (.dmark)  
2956 32 68 fe			ld (debug_mark),a  
2959 3a 68 29			ld a, (.dmark+1)  
295c 32 69 fe			ld (debug_mark+1),a  
295f 3a 69 29			ld a, (.dmark+2)  
2962 32 6a fe			ld (debug_mark+2),a  
2965 18 03			jr .pastdmark  
2967 ..			.dmark: db "2DU"  
296a f1			.pastdmark: pop af  
296b			endm  
# End of macro DMARK
296b						CALLMONITOR 
296b cd 6c fe			call debug_vector  
296e				endm  
# End of macro CALLMONITOR
296e					endif 
296e					FORTH_DSP_VALUEHL 
296e cd 0c 23			call macro_dsp_valuehl 
2971				endm 
# End of macro FORTH_DSP_VALUEHL
2971 e5					push hl      ; 2 
2972			 
2972					FORTH_DSP_POP 
2972 cd c4 23			call macro_forth_dsp_pop 
2975				endm 
# End of macro FORTH_DSP_POP
2975					 
2975					FORTH_DSP_VALUEHL 
2975 cd 0c 23			call macro_dsp_valuehl 
2978				endm 
# End of macro FORTH_DSP_VALUEHL
2978			;		push hl      ; 1 
2978			 
2978					FORTH_DSP_POP 
2978 cd c4 23			call macro_forth_dsp_pop 
297b				endm 
# End of macro FORTH_DSP_POP
297b			 
297b			;		pop hl       ; 1 
297b d1					pop de       ; 2 
297c			 
297c cd 15 21				call forth_push_numhl 
297f eb					ex de, hl 
2980 cd 15 21				call forth_push_numhl 
2983			 
2983					 
2983 eb					ex de, hl 
2984			 
2984 cd 15 21				call forth_push_numhl 
2987 eb					ex de, hl 
2988 cd 15 21				call forth_push_numhl 
298b			 
298b			 
298b					NEXTW 
298b c3 c2 24			jp macro_next 
298e				endm 
# End of macro NEXTW
298e			.DROP2: 
298e				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
298e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
298f bd 29			dw .SWAP2            
2991 06				db 5 + 1 
2992 .. 00			db "2DROP",0              
2998				endm 
# End of macro CWHEAD
2998			; | 2DROP ( w w -- )    Double drop | DONE 
2998					if DEBUG_FORTH_WORDS_KEY 
2998						DMARK "2DR" 
2998 f5				push af  
2999 3a ad 29			ld a, (.dmark)  
299c 32 68 fe			ld (debug_mark),a  
299f 3a ae 29			ld a, (.dmark+1)  
29a2 32 69 fe			ld (debug_mark+1),a  
29a5 3a af 29			ld a, (.dmark+2)  
29a8 32 6a fe			ld (debug_mark+2),a  
29ab 18 03			jr .pastdmark  
29ad ..			.dmark: db "2DR"  
29b0 f1			.pastdmark: pop af  
29b1			endm  
# End of macro DMARK
29b1						CALLMONITOR 
29b1 cd 6c fe			call debug_vector  
29b4				endm  
# End of macro CALLMONITOR
29b4					endif 
29b4					FORTH_DSP_POP 
29b4 cd c4 23			call macro_forth_dsp_pop 
29b7				endm 
# End of macro FORTH_DSP_POP
29b7					FORTH_DSP_POP 
29b7 cd c4 23			call macro_forth_dsp_pop 
29ba				endm 
# End of macro FORTH_DSP_POP
29ba					NEXTW 
29ba c3 c2 24			jp macro_next 
29bd				endm 
# End of macro NEXTW
29bd			.SWAP2: 
29bd				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29bd 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29be e6 29			dw .AT            
29c0 06				db 5 + 1 
29c1 .. 00			db "2SWAP",0              
29c7				endm 
# End of macro CWHEAD
29c7			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29c7					if DEBUG_FORTH_WORDS_KEY 
29c7						DMARK "2SW" 
29c7 f5				push af  
29c8 3a dc 29			ld a, (.dmark)  
29cb 32 68 fe			ld (debug_mark),a  
29ce 3a dd 29			ld a, (.dmark+1)  
29d1 32 69 fe			ld (debug_mark+1),a  
29d4 3a de 29			ld a, (.dmark+2)  
29d7 32 6a fe			ld (debug_mark+2),a  
29da 18 03			jr .pastdmark  
29dc ..			.dmark: db "2SW"  
29df f1			.pastdmark: pop af  
29e0			endm  
# End of macro DMARK
29e0						CALLMONITOR 
29e0 cd 6c fe			call debug_vector  
29e3				endm  
# End of macro CALLMONITOR
29e3					endif 
29e3					NEXTW 
29e3 c3 c2 24			jp macro_next 
29e6				endm 
# End of macro NEXTW
29e6			.AT: 
29e6				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29e6 1f				db WORD_SYS_CORE+OPCODE_AT             
29e7 18 2a			dw .CAT            
29e9 02				db 1 + 1 
29ea .. 00			db "@",0              
29ec				endm 
# End of macro CWHEAD
29ec			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29ec			 
29ec					if DEBUG_FORTH_WORDS_KEY 
29ec						DMARK "AT." 
29ec f5				push af  
29ed 3a 01 2a			ld a, (.dmark)  
29f0 32 68 fe			ld (debug_mark),a  
29f3 3a 02 2a			ld a, (.dmark+1)  
29f6 32 69 fe			ld (debug_mark+1),a  
29f9 3a 03 2a			ld a, (.dmark+2)  
29fc 32 6a fe			ld (debug_mark+2),a  
29ff 18 03			jr .pastdmark  
2a01 ..			.dmark: db "AT."  
2a04 f1			.pastdmark: pop af  
2a05			endm  
# End of macro DMARK
2a05						CALLMONITOR 
2a05 cd 6c fe			call debug_vector  
2a08				endm  
# End of macro CALLMONITOR
2a08					endif 
2a08			.getbyteat:	 
2a08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a08 cd 0c 23			call macro_dsp_valuehl 
2a0b				endm 
# End of macro FORTH_DSP_VALUEHL
2a0b					 
2a0b			;		push hl 
2a0b				 
2a0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a0b cd c4 23			call macro_forth_dsp_pop 
2a0e				endm 
# End of macro FORTH_DSP_POP
2a0e			 
2a0e			;		pop hl 
2a0e			 
2a0e 7e					ld a, (hl) 
2a0f			 
2a0f 6f					ld l, a 
2a10 26 00				ld h, 0 
2a12 cd 15 21				call forth_push_numhl 
2a15			 
2a15					NEXTW 
2a15 c3 c2 24			jp macro_next 
2a18				endm 
# End of macro NEXTW
2a18			.CAT: 
2a18				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a18 20				db WORD_SYS_CORE+OPCODE_CAT             
2a19 41 2a			dw .BANG            
2a1b 03				db 2 + 1 
2a1c .. 00			db "C@",0              
2a1f				endm 
# End of macro CWHEAD
2a1f			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a1f					if DEBUG_FORTH_WORDS_KEY 
2a1f						DMARK "CAA" 
2a1f f5				push af  
2a20 3a 34 2a			ld a, (.dmark)  
2a23 32 68 fe			ld (debug_mark),a  
2a26 3a 35 2a			ld a, (.dmark+1)  
2a29 32 69 fe			ld (debug_mark+1),a  
2a2c 3a 36 2a			ld a, (.dmark+2)  
2a2f 32 6a fe			ld (debug_mark+2),a  
2a32 18 03			jr .pastdmark  
2a34 ..			.dmark: db "CAA"  
2a37 f1			.pastdmark: pop af  
2a38			endm  
# End of macro DMARK
2a38						CALLMONITOR 
2a38 cd 6c fe			call debug_vector  
2a3b				endm  
# End of macro CALLMONITOR
2a3b					endif 
2a3b c3 08 2a				jp .getbyteat 
2a3e					NEXTW 
2a3e c3 c2 24			jp macro_next 
2a41				endm 
# End of macro NEXTW
2a41			.BANG: 
2a41				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a41 21				db WORD_SYS_CORE+OPCODE_BANG             
2a42 77 2a			dw .CBANG            
2a44 02				db 1 + 1 
2a45 .. 00			db "!",0              
2a47				endm 
# End of macro CWHEAD
2a47			; | ! ( x w -- ) Store x at address w      | DONE 
2a47					if DEBUG_FORTH_WORDS_KEY 
2a47						DMARK "BNG" 
2a47 f5				push af  
2a48 3a 5c 2a			ld a, (.dmark)  
2a4b 32 68 fe			ld (debug_mark),a  
2a4e 3a 5d 2a			ld a, (.dmark+1)  
2a51 32 69 fe			ld (debug_mark+1),a  
2a54 3a 5e 2a			ld a, (.dmark+2)  
2a57 32 6a fe			ld (debug_mark+2),a  
2a5a 18 03			jr .pastdmark  
2a5c ..			.dmark: db "BNG"  
2a5f f1			.pastdmark: pop af  
2a60			endm  
# End of macro DMARK
2a60						CALLMONITOR 
2a60 cd 6c fe			call debug_vector  
2a63				endm  
# End of macro CALLMONITOR
2a63					endif 
2a63			 
2a63			.storebyteat:		 
2a63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a63 cd 0c 23			call macro_dsp_valuehl 
2a66				endm 
# End of macro FORTH_DSP_VALUEHL
2a66					 
2a66 e5					push hl 
2a67				 
2a67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a67 cd c4 23			call macro_forth_dsp_pop 
2a6a				endm 
# End of macro FORTH_DSP_POP
2a6a			 
2a6a					; get byte to poke 
2a6a			 
2a6a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a6a cd 0c 23			call macro_dsp_valuehl 
2a6d				endm 
# End of macro FORTH_DSP_VALUEHL
2a6d e5					push hl 
2a6e			 
2a6e			 
2a6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a6e cd c4 23			call macro_forth_dsp_pop 
2a71				endm 
# End of macro FORTH_DSP_POP
2a71			 
2a71			 
2a71 d1					pop de 
2a72 e1					pop hl 
2a73			 
2a73 73					ld (hl),e 
2a74			 
2a74			 
2a74					NEXTW 
2a74 c3 c2 24			jp macro_next 
2a77				endm 
# End of macro NEXTW
2a77			.CBANG: 
2a77				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a77 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a78 a0 2a			dw .SCALL            
2a7a 03				db 2 + 1 
2a7b .. 00			db "C!",0              
2a7e				endm 
# End of macro CWHEAD
2a7e			; | C!  ( x w -- ) Store x at address w  | DONE 
2a7e					if DEBUG_FORTH_WORDS_KEY 
2a7e						DMARK "CBA" 
2a7e f5				push af  
2a7f 3a 93 2a			ld a, (.dmark)  
2a82 32 68 fe			ld (debug_mark),a  
2a85 3a 94 2a			ld a, (.dmark+1)  
2a88 32 69 fe			ld (debug_mark+1),a  
2a8b 3a 95 2a			ld a, (.dmark+2)  
2a8e 32 6a fe			ld (debug_mark+2),a  
2a91 18 03			jr .pastdmark  
2a93 ..			.dmark: db "CBA"  
2a96 f1			.pastdmark: pop af  
2a97			endm  
# End of macro DMARK
2a97						CALLMONITOR 
2a97 cd 6c fe			call debug_vector  
2a9a				endm  
# End of macro CALLMONITOR
2a9a					endif 
2a9a c3 63 2a				jp .storebyteat 
2a9d					NEXTW 
2a9d c3 c2 24			jp macro_next 
2aa0				endm 
# End of macro NEXTW
2aa0			.SCALL: 
2aa0				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2aa0 23				db WORD_SYS_CORE+OPCODE_SCALL             
2aa1 d4 2a			dw .DEPTH            
2aa3 05				db 4 + 1 
2aa4 .. 00			db "CALL",0              
2aa9				endm 
# End of macro CWHEAD
2aa9			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2aa9					if DEBUG_FORTH_WORDS_KEY 
2aa9						DMARK "CLL" 
2aa9 f5				push af  
2aaa 3a be 2a			ld a, (.dmark)  
2aad 32 68 fe			ld (debug_mark),a  
2ab0 3a bf 2a			ld a, (.dmark+1)  
2ab3 32 69 fe			ld (debug_mark+1),a  
2ab6 3a c0 2a			ld a, (.dmark+2)  
2ab9 32 6a fe			ld (debug_mark+2),a  
2abc 18 03			jr .pastdmark  
2abe ..			.dmark: db "CLL"  
2ac1 f1			.pastdmark: pop af  
2ac2			endm  
# End of macro DMARK
2ac2						CALLMONITOR 
2ac2 cd 6c fe			call debug_vector  
2ac5				endm  
# End of macro CALLMONITOR
2ac5					endif 
2ac5			 
2ac5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ac5 cd 0c 23			call macro_dsp_valuehl 
2ac8				endm 
# End of macro FORTH_DSP_VALUEHL
2ac8			 
2ac8			;		push hl 
2ac8			 
2ac8					; destroy value TOS 
2ac8			 
2ac8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ac8 cd c4 23			call macro_forth_dsp_pop 
2acb				endm 
# End of macro FORTH_DSP_POP
2acb			 
2acb						 
2acb			;		pop hl 
2acb			 
2acb					; how to do a call with hl???? save SP? 
2acb cd 66 24				call forth_call_hl 
2ace			 
2ace			 
2ace					; TODO push value back onto stack for another op etc 
2ace			 
2ace cd 15 21				call forth_push_numhl 
2ad1					NEXTW 
2ad1 c3 c2 24			jp macro_next 
2ad4				endm 
# End of macro NEXTW
2ad4			.DEPTH: 
2ad4				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ad4 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ad5 11 2b			dw .OVER            
2ad7 06				db 5 + 1 
2ad8 .. 00			db "DEPTH",0              
2ade				endm 
# End of macro CWHEAD
2ade			; | DEPTH ( -- u ) Push count of stack | DONE 
2ade					; take current TOS and remove from base value div by two to get count 
2ade					if DEBUG_FORTH_WORDS_KEY 
2ade						DMARK "DEP" 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 68 fe			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 69 fe			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 6a fe			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "DEP"  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7						CALLMONITOR 
2af7 cd 6c fe			call debug_vector  
2afa				endm  
# End of macro CALLMONITOR
2afa					endif 
2afa			 
2afa			 
2afa 2a eb f9			ld hl, (cli_data_sp) 
2afd 11 25 f7			ld de, cli_data_stack 
2b00 ed 52			sbc hl,de 
2b02				 
2b02				; div by size of stack item 
2b02			 
2b02 5d				ld e,l 
2b03 0e 03			ld c, 3 
2b05 cd 60 0f			call Div8 
2b08			 
2b08 6f				ld l,a 
2b09 26 00			ld h,0 
2b0b			 
2b0b				;srl h 
2b0b				;rr l 
2b0b			 
2b0b cd 15 21				call forth_push_numhl 
2b0e					NEXTW 
2b0e c3 c2 24			jp macro_next 
2b11				endm 
# End of macro NEXTW
2b11			.OVER: 
2b11				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2b11 42				db WORD_SYS_CORE+46             
2b12 58 2b			dw .PAUSE            
2b14 05				db 4 + 1 
2b15 .. 00			db "OVER",0              
2b1a				endm 
# End of macro CWHEAD
2b1a			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b1a					if DEBUG_FORTH_WORDS_KEY 
2b1a						DMARK "OVR" 
2b1a f5				push af  
2b1b 3a 2f 2b			ld a, (.dmark)  
2b1e 32 68 fe			ld (debug_mark),a  
2b21 3a 30 2b			ld a, (.dmark+1)  
2b24 32 69 fe			ld (debug_mark+1),a  
2b27 3a 31 2b			ld a, (.dmark+2)  
2b2a 32 6a fe			ld (debug_mark+2),a  
2b2d 18 03			jr .pastdmark  
2b2f ..			.dmark: db "OVR"  
2b32 f1			.pastdmark: pop af  
2b33			endm  
# End of macro DMARK
2b33						CALLMONITOR 
2b33 cd 6c fe			call debug_vector  
2b36				endm  
# End of macro CALLMONITOR
2b36					endif 
2b36			 
2b36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b36 cd 0c 23			call macro_dsp_valuehl 
2b39				endm 
# End of macro FORTH_DSP_VALUEHL
2b39 e5					push hl    ; n2 
2b3a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b3a cd c4 23			call macro_forth_dsp_pop 
2b3d				endm 
# End of macro FORTH_DSP_POP
2b3d			 
2b3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b3d cd 0c 23			call macro_dsp_valuehl 
2b40				endm 
# End of macro FORTH_DSP_VALUEHL
2b40 e5					push hl    ; n1 
2b41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b41 cd c4 23			call macro_forth_dsp_pop 
2b44				endm 
# End of macro FORTH_DSP_POP
2b44			 
2b44 d1					pop de     ; n1 
2b45 e1					pop hl     ; n2 
2b46			 
2b46 d5					push de 
2b47 e5					push hl 
2b48 d5					push de 
2b49			 
2b49					; push back  
2b49			 
2b49 e1					pop hl 
2b4a cd 15 21				call forth_push_numhl 
2b4d e1					pop hl 
2b4e cd 15 21				call forth_push_numhl 
2b51 e1					pop hl 
2b52 cd 15 21				call forth_push_numhl 
2b55					NEXTW 
2b55 c3 c2 24			jp macro_next 
2b58				endm 
# End of macro NEXTW
2b58			 
2b58			.PAUSE: 
2b58				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b58 43				db WORD_SYS_CORE+47             
2b59 8d 2b			dw .PAUSES            
2b5b 08				db 7 + 1 
2b5c .. 00			db "PAUSEMS",0              
2b64				endm 
# End of macro CWHEAD
2b64			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b64					if DEBUG_FORTH_WORDS_KEY 
2b64						DMARK "PMS" 
2b64 f5				push af  
2b65 3a 79 2b			ld a, (.dmark)  
2b68 32 68 fe			ld (debug_mark),a  
2b6b 3a 7a 2b			ld a, (.dmark+1)  
2b6e 32 69 fe			ld (debug_mark+1),a  
2b71 3a 7b 2b			ld a, (.dmark+2)  
2b74 32 6a fe			ld (debug_mark+2),a  
2b77 18 03			jr .pastdmark  
2b79 ..			.dmark: db "PMS"  
2b7c f1			.pastdmark: pop af  
2b7d			endm  
# End of macro DMARK
2b7d						CALLMONITOR 
2b7d cd 6c fe			call debug_vector  
2b80				endm  
# End of macro CALLMONITOR
2b80					endif 
2b80					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b80 cd 0c 23			call macro_dsp_valuehl 
2b83				endm 
# End of macro FORTH_DSP_VALUEHL
2b83			;		push hl    ; n2 
2b83					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b83 cd c4 23			call macro_forth_dsp_pop 
2b86				endm 
# End of macro FORTH_DSP_POP
2b86			;		pop hl 
2b86			 
2b86 7d					ld a, l 
2b87 cd c4 0c				call aDelayInMS 
2b8a				       NEXTW 
2b8a c3 c2 24			jp macro_next 
2b8d				endm 
# End of macro NEXTW
2b8d			.PAUSES:  
2b8d				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b8d 44				db WORD_SYS_CORE+48             
2b8e fc 2b			dw .ROT            
2b90 06				db 5 + 1 
2b91 .. 00			db "PAUSE",0              
2b97				endm 
# End of macro CWHEAD
2b97			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b97					if DEBUG_FORTH_WORDS_KEY 
2b97						DMARK "PAU" 
2b97 f5				push af  
2b98 3a ac 2b			ld a, (.dmark)  
2b9b 32 68 fe			ld (debug_mark),a  
2b9e 3a ad 2b			ld a, (.dmark+1)  
2ba1 32 69 fe			ld (debug_mark+1),a  
2ba4 3a ae 2b			ld a, (.dmark+2)  
2ba7 32 6a fe			ld (debug_mark+2),a  
2baa 18 03			jr .pastdmark  
2bac ..			.dmark: db "PAU"  
2baf f1			.pastdmark: pop af  
2bb0			endm  
# End of macro DMARK
2bb0						CALLMONITOR 
2bb0 cd 6c fe			call debug_vector  
2bb3				endm  
# End of macro CALLMONITOR
2bb3					endif 
2bb3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bb3 cd 0c 23			call macro_dsp_valuehl 
2bb6				endm 
# End of macro FORTH_DSP_VALUEHL
2bb6			;		push hl    ; n2 
2bb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bb6 cd c4 23			call macro_forth_dsp_pop 
2bb9				endm 
# End of macro FORTH_DSP_POP
2bb9			;		pop hl 
2bb9 45					ld b, l 
2bba					if DEBUG_FORTH_WORDS 
2bba						DMARK "PAU" 
2bba f5				push af  
2bbb 3a cf 2b			ld a, (.dmark)  
2bbe 32 68 fe			ld (debug_mark),a  
2bc1 3a d0 2b			ld a, (.dmark+1)  
2bc4 32 69 fe			ld (debug_mark+1),a  
2bc7 3a d1 2b			ld a, (.dmark+2)  
2bca 32 6a fe			ld (debug_mark+2),a  
2bcd 18 03			jr .pastdmark  
2bcf ..			.dmark: db "PAU"  
2bd2 f1			.pastdmark: pop af  
2bd3			endm  
# End of macro DMARK
2bd3						CALLMONITOR 
2bd3 cd 6c fe			call debug_vector  
2bd6				endm  
# End of macro CALLMONITOR
2bd6					endif 
2bd6 c5			.pauses1:	push bc 
2bd7 cd df 0c				call delay1s 
2bda c1					pop bc 
2bdb					if DEBUG_FORTH_WORDS 
2bdb						DMARK "PA1" 
2bdb f5				push af  
2bdc 3a f0 2b			ld a, (.dmark)  
2bdf 32 68 fe			ld (debug_mark),a  
2be2 3a f1 2b			ld a, (.dmark+1)  
2be5 32 69 fe			ld (debug_mark+1),a  
2be8 3a f2 2b			ld a, (.dmark+2)  
2beb 32 6a fe			ld (debug_mark+2),a  
2bee 18 03			jr .pastdmark  
2bf0 ..			.dmark: db "PA1"  
2bf3 f1			.pastdmark: pop af  
2bf4			endm  
# End of macro DMARK
2bf4						CALLMONITOR 
2bf4 cd 6c fe			call debug_vector  
2bf7				endm  
# End of macro CALLMONITOR
2bf7					endif 
2bf7 10 dd				djnz .pauses1 
2bf9			 
2bf9				       NEXTW 
2bf9 c3 c2 24			jp macro_next 
2bfc				endm 
# End of macro NEXTW
2bfc			.ROT: 
2bfc				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bfc 45				db WORD_SYS_CORE+49             
2bfd 4a 2c			dw .UWORDS            
2bff 04				db 3 + 1 
2c00 .. 00			db "ROT",0              
2c04				endm 
# End of macro CWHEAD
2c04			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2c04					if DEBUG_FORTH_WORDS_KEY 
2c04						DMARK "ROT" 
2c04 f5				push af  
2c05 3a 19 2c			ld a, (.dmark)  
2c08 32 68 fe			ld (debug_mark),a  
2c0b 3a 1a 2c			ld a, (.dmark+1)  
2c0e 32 69 fe			ld (debug_mark+1),a  
2c11 3a 1b 2c			ld a, (.dmark+2)  
2c14 32 6a fe			ld (debug_mark+2),a  
2c17 18 03			jr .pastdmark  
2c19 ..			.dmark: db "ROT"  
2c1c f1			.pastdmark: pop af  
2c1d			endm  
# End of macro DMARK
2c1d						CALLMONITOR 
2c1d cd 6c fe			call debug_vector  
2c20				endm  
# End of macro CALLMONITOR
2c20					endif 
2c20			 
2c20					FORTH_DSP_VALUEHL 
2c20 cd 0c 23			call macro_dsp_valuehl 
2c23				endm 
# End of macro FORTH_DSP_VALUEHL
2c23 e5					push hl    ; u3  
2c24			 
2c24					FORTH_DSP_POP 
2c24 cd c4 23			call macro_forth_dsp_pop 
2c27				endm 
# End of macro FORTH_DSP_POP
2c27			   
2c27					FORTH_DSP_VALUEHL 
2c27 cd 0c 23			call macro_dsp_valuehl 
2c2a				endm 
# End of macro FORTH_DSP_VALUEHL
2c2a e5					push hl     ; u2 
2c2b			 
2c2b					FORTH_DSP_POP 
2c2b cd c4 23			call macro_forth_dsp_pop 
2c2e				endm 
# End of macro FORTH_DSP_POP
2c2e			 
2c2e					FORTH_DSP_VALUEHL 
2c2e cd 0c 23			call macro_dsp_valuehl 
2c31				endm 
# End of macro FORTH_DSP_VALUEHL
2c31 e5					push hl     ; u1 
2c32			 
2c32					FORTH_DSP_POP 
2c32 cd c4 23			call macro_forth_dsp_pop 
2c35				endm 
# End of macro FORTH_DSP_POP
2c35			 
2c35 c1					pop bc      ; u1 
2c36 e1					pop hl      ; u2 
2c37 d1					pop de      ; u3 
2c38			 
2c38			 
2c38 c5					push bc 
2c39 d5					push de 
2c3a e5					push hl 
2c3b			 
2c3b			 
2c3b e1					pop hl 
2c3c cd 15 21				call forth_push_numhl 
2c3f			 
2c3f e1					pop hl 
2c40 cd 15 21				call forth_push_numhl 
2c43			 
2c43 e1					pop hl 
2c44 cd 15 21				call forth_push_numhl 
2c47					 
2c47			 
2c47			 
2c47			 
2c47			 
2c47			 
2c47				       NEXTW 
2c47 c3 c2 24			jp macro_next 
2c4a				endm 
# End of macro NEXTW
2c4a			 
2c4a			.UWORDS: 
2c4a				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c4a 50				db WORD_SYS_CORE+60             
2c4b 0c 2d			dw .BP            
2c4d 07				db 6 + 1 
2c4e .. 00			db "UWORDS",0              
2c55				endm 
# End of macro CWHEAD
2c55			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c55			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c55			; | | Following the count are the individual words. 
2c55			; | | 
2c55			; | | e.g. UWORDS 
2c55			; | | BOX DIRLIST 2 
2c55			; | |  
2c55			; | | Can be used to save the words to storage via: 
2c55			; | | UWORDS $01 DO $01 APPEND LOOP 
2c55				if DEBUG_FORTH_WORDS_KEY 
2c55					DMARK "UWR" 
2c55 f5				push af  
2c56 3a 6a 2c			ld a, (.dmark)  
2c59 32 68 fe			ld (debug_mark),a  
2c5c 3a 6b 2c			ld a, (.dmark+1)  
2c5f 32 69 fe			ld (debug_mark+1),a  
2c62 3a 6c 2c			ld a, (.dmark+2)  
2c65 32 6a fe			ld (debug_mark+2),a  
2c68 18 03			jr .pastdmark  
2c6a ..			.dmark: db "UWR"  
2c6d f1			.pastdmark: pop af  
2c6e			endm  
# End of macro DMARK
2c6e					CALLMONITOR 
2c6e cd 6c fe			call debug_vector  
2c71				endm  
# End of macro CALLMONITOR
2c71				endif 
2c71 21 00 80				ld hl, baseram 
2c74					;ld hl, baseusermem 
2c74 01 00 00				ld bc, 0    ; start a counter 
2c77			 
2c77				; skip dict stub 
2c77			 
2c77 cd 13 26				call forth_tok_next 
2c7a			 
2c7a			 
2c7a			; while we have words to look for 
2c7a			 
2c7a 7e			.douscan:	ld a, (hl)      
2c7b				if DEBUG_FORTH_WORDS 
2c7b					DMARK "UWs" 
2c7b f5				push af  
2c7c 3a 90 2c			ld a, (.dmark)  
2c7f 32 68 fe			ld (debug_mark),a  
2c82 3a 91 2c			ld a, (.dmark+1)  
2c85 32 69 fe			ld (debug_mark+1),a  
2c88 3a 92 2c			ld a, (.dmark+2)  
2c8b 32 6a fe			ld (debug_mark+2),a  
2c8e 18 03			jr .pastdmark  
2c90 ..			.dmark: db "UWs"  
2c93 f1			.pastdmark: pop af  
2c94			endm  
# End of macro DMARK
2c94					CALLMONITOR 
2c94 cd 6c fe			call debug_vector  
2c97				endm  
# End of macro CALLMONITOR
2c97				endif 
2c97 fe 00				cp WORD_SYS_END 
2c99 28 4d				jr z, .udone 
2c9b fe 01				cp WORD_SYS_UWORD 
2c9d 20 44				jr nz, .nuword 
2c9f			 
2c9f				if DEBUG_FORTH_WORDS 
2c9f					DMARK "UWu" 
2c9f f5				push af  
2ca0 3a b4 2c			ld a, (.dmark)  
2ca3 32 68 fe			ld (debug_mark),a  
2ca6 3a b5 2c			ld a, (.dmark+1)  
2ca9 32 69 fe			ld (debug_mark+1),a  
2cac 3a b6 2c			ld a, (.dmark+2)  
2caf 32 6a fe			ld (debug_mark+2),a  
2cb2 18 03			jr .pastdmark  
2cb4 ..			.dmark: db "UWu"  
2cb7 f1			.pastdmark: pop af  
2cb8			endm  
# End of macro DMARK
2cb8					CALLMONITOR 
2cb8 cd 6c fe			call debug_vector  
2cbb				endm  
# End of macro CALLMONITOR
2cbb				endif 
2cbb					; we have a uword so push its name to the stack 
2cbb			 
2cbb e5				   	push hl  ; save so we can move to next dict block 
2cbc			 
2cbc					; skip opcode 
2cbc 23					inc hl  
2cbd					; skip next ptr 
2cbd 23					inc hl  
2cbe 23					inc hl 
2cbf					; skip len 
2cbf 23					inc hl 
2cc0				if DEBUG_FORTH_WORDS 
2cc0					DMARK "UWt" 
2cc0 f5				push af  
2cc1 3a d5 2c			ld a, (.dmark)  
2cc4 32 68 fe			ld (debug_mark),a  
2cc7 3a d6 2c			ld a, (.dmark+1)  
2cca 32 69 fe			ld (debug_mark+1),a  
2ccd 3a d7 2c			ld a, (.dmark+2)  
2cd0 32 6a fe			ld (debug_mark+2),a  
2cd3 18 03			jr .pastdmark  
2cd5 ..			.dmark: db "UWt"  
2cd8 f1			.pastdmark: pop af  
2cd9			endm  
# End of macro DMARK
2cd9					CALLMONITOR 
2cd9 cd 6c fe			call debug_vector  
2cdc				endm  
# End of macro CALLMONITOR
2cdc				endif 
2cdc 03					inc bc 
2cdd			 
2cdd c5					push bc 
2cde cd 83 21				call forth_push_str 
2ce1 c1					pop bc 
2ce2			 
2ce2 e1					pop hl 	 
2ce3			 
2ce3 cd 13 26		.nuword:	call forth_tok_next 
2ce6 18 92				jr .douscan  
2ce8			 
2ce8			.udone:		 ; push count of uwords found 
2ce8 c5					push bc 
2ce9 e1					pop hl 
2cea			 
2cea				if DEBUG_FORTH_WORDS 
2cea					DMARK "UWc" 
2cea f5				push af  
2ceb 3a ff 2c			ld a, (.dmark)  
2cee 32 68 fe			ld (debug_mark),a  
2cf1 3a 00 2d			ld a, (.dmark+1)  
2cf4 32 69 fe			ld (debug_mark+1),a  
2cf7 3a 01 2d			ld a, (.dmark+2)  
2cfa 32 6a fe			ld (debug_mark+2),a  
2cfd 18 03			jr .pastdmark  
2cff ..			.dmark: db "UWc"  
2d02 f1			.pastdmark: pop af  
2d03			endm  
# End of macro DMARK
2d03					CALLMONITOR 
2d03 cd 6c fe			call debug_vector  
2d06				endm  
# End of macro CALLMONITOR
2d06				endif 
2d06 cd 15 21				call forth_push_numhl 
2d09			 
2d09			 
2d09				       NEXTW 
2d09 c3 c2 24			jp macro_next 
2d0c				endm 
# End of macro NEXTW
2d0c			 
2d0c			.BP: 
2d0c				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2d0c 54				db WORD_SYS_CORE+64             
2d0d 46 2d			dw .MONITOR            
2d0f 03				db 2 + 1 
2d10 .. 00			db "BP",0              
2d13				endm 
# End of macro CWHEAD
2d13			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2d13			; | | $00 Will enable the break points within specific code paths 
2d13			; | | $01 Will disable break points 
2d13			; | |  
2d13			; | | By default break points are off. Either the above can be used to enable them 
2d13			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2d13			; | | and on release of the pressed key a message will be disaplayed to notify 
2d13			; | | that break points are enabled. Pressing any key will then continue boot process. 
2d13					; get byte count 
2d13					if DEBUG_FORTH_WORDS_KEY 
2d13						DMARK "BP." 
2d13 f5				push af  
2d14 3a 28 2d			ld a, (.dmark)  
2d17 32 68 fe			ld (debug_mark),a  
2d1a 3a 29 2d			ld a, (.dmark+1)  
2d1d 32 69 fe			ld (debug_mark+1),a  
2d20 3a 2a 2d			ld a, (.dmark+2)  
2d23 32 6a fe			ld (debug_mark+2),a  
2d26 18 03			jr .pastdmark  
2d28 ..			.dmark: db "BP."  
2d2b f1			.pastdmark: pop af  
2d2c			endm  
# End of macro DMARK
2d2c						CALLMONITOR 
2d2c cd 6c fe			call debug_vector  
2d2f				endm  
# End of macro CALLMONITOR
2d2f					endif 
2d2f			 
2d2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d2f cd 0c 23			call macro_dsp_valuehl 
2d32				endm 
# End of macro FORTH_DSP_VALUEHL
2d32			 
2d32			;		push hl 
2d32			 
2d32					; destroy value TOS 
2d32			 
2d32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d32 cd c4 23			call macro_forth_dsp_pop 
2d35				endm 
# End of macro FORTH_DSP_POP
2d35			 
2d35			;		pop hl 
2d35			 
2d35 3e 00				ld a,0 
2d37 bd					cp l 
2d38 28 06				jr z, .bpset 
2d3a			;		ld a, '*' 
2d3a cd 42 1a				call bp_off 
2d3d					NEXTW 
2d3d c3 c2 24			jp macro_next 
2d40				endm 
# End of macro NEXTW
2d40			 
2d40			.bpset:	 
2d40					;	ld (os_view_disable), a 
2d40 cd 36 1a				call bp_on 
2d43			 
2d43			 
2d43					NEXTW 
2d43 c3 c2 24			jp macro_next 
2d46				endm 
# End of macro NEXTW
2d46			 
2d46			 
2d46			.MONITOR: 
2d46				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d46 55				db WORD_SYS_CORE+65             
2d47 77 2d			dw .MALLOC            
2d49 08				db 7 + 1 
2d4a .. 00			db "MONITOR",0              
2d52				endm 
# End of macro CWHEAD
2d52			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d52			; | | At start the current various registers will be displayed with contents. 
2d52			; | | Top right corner will show the most recent debug marker seen. 
2d52			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d52			; | | and the return stack pointer (RSP). 
2d52			; | | Pressing: 
2d52			; | |    1 - Initial screen 
2d52			; | |    2 - Display a data dump of HL 
2d52			; | |    3 - Display a data dump of DE 
2d52			; | |    4 - Display a data dump of BC 
2d52			; | |    5 - Display a data dump of HL 
2d52			; | |    6 - Display a data dump of DSP 
2d52			; | |    7 - Display a data dump of RSP 
2d52			; | |    8 - Display a data dump of what is at DSP 
2d52			; | |    9 - Display a data dump of what is at RSP 
2d52			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d52			; | |    * - Disable break points 
2d52			; | |    # - Enter traditional monitor mode 
2d52			; | | 
2d52			; | | Monitor Mode 
2d52			; | | ------------ 
2d52			; | | A prompt of '>' will be shown for various commands: 
2d52			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d52			; | |    C - Continue display a data dump from the last set address 
2d52			; | |    M xxxx - Set start of memory edit at address xx 
2d52			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d52			; | |    Q - Return to previous 
2d52					if DEBUG_FORTH_WORDS_KEY 
2d52						DMARK "MON" 
2d52 f5				push af  
2d53 3a 67 2d			ld a, (.dmark)  
2d56 32 68 fe			ld (debug_mark),a  
2d59 3a 68 2d			ld a, (.dmark+1)  
2d5c 32 69 fe			ld (debug_mark+1),a  
2d5f 3a 69 2d			ld a, (.dmark+2)  
2d62 32 6a fe			ld (debug_mark+2),a  
2d65 18 03			jr .pastdmark  
2d67 ..			.dmark: db "MON"  
2d6a f1			.pastdmark: pop af  
2d6b			endm  
# End of macro DMARK
2d6b						CALLMONITOR 
2d6b cd 6c fe			call debug_vector  
2d6e				endm  
# End of macro CALLMONITOR
2d6e					endif 
2d6e			;		ld a, 0 
2d6e			;		ld (os_view_disable), a 
2d6e cd 36 1a				call bp_on 
2d71			 
2d71					CALLMONITOR 
2d71 cd 6c fe			call debug_vector  
2d74				endm  
# End of macro CALLMONITOR
2d74			 
2d74			;	call monitor 
2d74			 
2d74					NEXTW 
2d74 c3 c2 24			jp macro_next 
2d77				endm 
# End of macro NEXTW
2d77			 
2d77			 
2d77			.MALLOC: 
2d77				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d77 56				db WORD_SYS_CORE+66             
2d78 a0 2d			dw .MALLOC2            
2d7a 06				db 5 + 1 
2d7b .. 00			db "ALLOT",0              
2d81				endm 
# End of macro CWHEAD
2d81			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d81					if DEBUG_FORTH_WORDS_KEY 
2d81						DMARK "ALL" 
2d81 f5				push af  
2d82 3a 96 2d			ld a, (.dmark)  
2d85 32 68 fe			ld (debug_mark),a  
2d88 3a 97 2d			ld a, (.dmark+1)  
2d8b 32 69 fe			ld (debug_mark+1),a  
2d8e 3a 98 2d			ld a, (.dmark+2)  
2d91 32 6a fe			ld (debug_mark+2),a  
2d94 18 03			jr .pastdmark  
2d96 ..			.dmark: db "ALL"  
2d99 f1			.pastdmark: pop af  
2d9a			endm  
# End of macro DMARK
2d9a						CALLMONITOR 
2d9a cd 6c fe			call debug_vector  
2d9d				endm  
# End of macro CALLMONITOR
2d9d					endif 
2d9d c3 c7 2d				jp .mallocc 
2da0			.MALLOC2: 
2da0				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2da0 56				db WORD_SYS_CORE+66             
2da1 de 2d			dw .FREE            
2da3 07				db 6 + 1 
2da4 .. 00			db "MALLOC",0              
2dab				endm 
# End of macro CWHEAD
2dab			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2dab					; get byte count 
2dab					if DEBUG_FORTH_WORDS_KEY 
2dab						DMARK "MAL" 
2dab f5				push af  
2dac 3a c0 2d			ld a, (.dmark)  
2daf 32 68 fe			ld (debug_mark),a  
2db2 3a c1 2d			ld a, (.dmark+1)  
2db5 32 69 fe			ld (debug_mark+1),a  
2db8 3a c2 2d			ld a, (.dmark+2)  
2dbb 32 6a fe			ld (debug_mark+2),a  
2dbe 18 03			jr .pastdmark  
2dc0 ..			.dmark: db "MAL"  
2dc3 f1			.pastdmark: pop af  
2dc4			endm  
# End of macro DMARK
2dc4						CALLMONITOR 
2dc4 cd 6c fe			call debug_vector  
2dc7				endm  
# End of macro CALLMONITOR
2dc7					endif 
2dc7			.mallocc: 
2dc7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dc7 cd 0c 23			call macro_dsp_valuehl 
2dca				endm 
# End of macro FORTH_DSP_VALUEHL
2dca			 
2dca			;		push hl 
2dca			 
2dca					; destroy value TOS 
2dca			 
2dca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dca cd c4 23			call macro_forth_dsp_pop 
2dcd				endm 
# End of macro FORTH_DSP_POP
2dcd			 
2dcd			;		pop hl 
2dcd cd 97 14				call malloc 
2dd0				if DEBUG_FORTH_MALLOC_GUARD 
2dd0 f5					push af 
2dd1 cd f9 0f				call ishlzero 
2dd4			;		ld a, l 
2dd4			;		add h 
2dd4			;		cp 0 
2dd4 f1					pop af 
2dd5					 
2dd5 cc 14 5e				call z,malloc_error 
2dd8				endif 
2dd8			 
2dd8 cd 15 21				call forth_push_numhl 
2ddb					NEXTW 
2ddb c3 c2 24			jp macro_next 
2dde				endm 
# End of macro NEXTW
2dde			 
2dde			.FREE: 
2dde				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dde 57				db WORD_SYS_CORE+67             
2ddf 0f 2e			dw .LIST            
2de1 05				db 4 + 1 
2de2 .. 00			db "FREE",0              
2de7				endm 
# End of macro CWHEAD
2de7			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2de7					if DEBUG_FORTH_WORDS_KEY 
2de7						DMARK "FRE" 
2de7 f5				push af  
2de8 3a fc 2d			ld a, (.dmark)  
2deb 32 68 fe			ld (debug_mark),a  
2dee 3a fd 2d			ld a, (.dmark+1)  
2df1 32 69 fe			ld (debug_mark+1),a  
2df4 3a fe 2d			ld a, (.dmark+2)  
2df7 32 6a fe			ld (debug_mark+2),a  
2dfa 18 03			jr .pastdmark  
2dfc ..			.dmark: db "FRE"  
2dff f1			.pastdmark: pop af  
2e00			endm  
# End of macro DMARK
2e00						CALLMONITOR 
2e00 cd 6c fe			call debug_vector  
2e03				endm  
# End of macro CALLMONITOR
2e03					endif 
2e03					; get address 
2e03			 
2e03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e03 cd 0c 23			call macro_dsp_valuehl 
2e06				endm 
# End of macro FORTH_DSP_VALUEHL
2e06			 
2e06			;		push hl 
2e06			 
2e06					; destroy value TOS 
2e06			 
2e06					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e06 cd c4 23			call macro_forth_dsp_pop 
2e09				endm 
# End of macro FORTH_DSP_POP
2e09			 
2e09			;		pop hl 
2e09			if FORTH_ENABLE_MALLOCFREE 
2e09 cd 61 15				call free 
2e0c			endif 
2e0c					NEXTW 
2e0c c3 c2 24			jp macro_next 
2e0f				endm 
# End of macro NEXTW
2e0f			.LIST: 
2e0f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2e0f 5c				db WORD_SYS_CORE+72             
2e10 fd 2f			dw .FORGET            
2e12 05				db 4 + 1 
2e13 .. 00			db "LIST",0              
2e18				endm 
# End of macro CWHEAD
2e18			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2e18			; | | The quoted word must be in upper case. 
2e18				if DEBUG_FORTH_WORDS_KEY 
2e18					DMARK "LST" 
2e18 f5				push af  
2e19 3a 2d 2e			ld a, (.dmark)  
2e1c 32 68 fe			ld (debug_mark),a  
2e1f 3a 2e 2e			ld a, (.dmark+1)  
2e22 32 69 fe			ld (debug_mark+1),a  
2e25 3a 2f 2e			ld a, (.dmark+2)  
2e28 32 6a fe			ld (debug_mark+2),a  
2e2b 18 03			jr .pastdmark  
2e2d ..			.dmark: db "LST"  
2e30 f1			.pastdmark: pop af  
2e31			endm  
# End of macro DMARK
2e31					CALLMONITOR 
2e31 cd 6c fe			call debug_vector  
2e34				endm  
# End of macro CALLMONITOR
2e34				endif 
2e34			 
2e34					FORTH_DSP_VALUEHL 
2e34 cd 0c 23			call macro_dsp_valuehl 
2e37				endm 
# End of macro FORTH_DSP_VALUEHL
2e37			 
2e37 e5					push hl 
2e38					FORTH_DSP_POP 
2e38 cd c4 23			call macro_forth_dsp_pop 
2e3b				endm 
# End of macro FORTH_DSP_POP
2e3b c1					pop bc 
2e3c			 
2e3c			; Start format of scratch string 
2e3c			 
2e3c 21 be f1				ld hl, scratch 
2e3f			 
2e3f 3e 3a				ld a, ':' 
2e41 77					ld (hl),a 
2e42 23					inc hl 
2e43 3e 20				ld a, ' ' 
2e45 77					ld (hl), a 
2e46			 
2e46					; Get ptr to the word we need to look up 
2e46			 
2e46			;		FORTH_DSP_VALUEHL 
2e46					;v5 FORTH_DSP_VALUE 
2e46				; TODO type check 
2e46			;		inc hl    ; Skip type check  
2e46			;		push hl 
2e46			;		ex de, hl    ; put into DE 
2e46			 
2e46			 
2e46 21 00 80				ld hl, baseram 
2e49					;ld hl, baseusermem 
2e49			 
2e49 e5			push hl   ; sacreifical push 
2e4a			 
2e4a			.ldouscanm: 
2e4a e1				pop hl 
2e4b			.ldouscan: 
2e4b				if DEBUG_FORTH_WORDS 
2e4b					DMARK "LSs" 
2e4b f5				push af  
2e4c 3a 60 2e			ld a, (.dmark)  
2e4f 32 68 fe			ld (debug_mark),a  
2e52 3a 61 2e			ld a, (.dmark+1)  
2e55 32 69 fe			ld (debug_mark+1),a  
2e58 3a 62 2e			ld a, (.dmark+2)  
2e5b 32 6a fe			ld (debug_mark+2),a  
2e5e 18 03			jr .pastdmark  
2e60 ..			.dmark: db "LSs"  
2e63 f1			.pastdmark: pop af  
2e64			endm  
# End of macro DMARK
2e64					CALLMONITOR 
2e64 cd 6c fe			call debug_vector  
2e67				endm  
# End of macro CALLMONITOR
2e67				endif 
2e67				; skip dict stub 
2e67 cd 13 26				call forth_tok_next 
2e6a			 
2e6a			 
2e6a			; while we have words to look for 
2e6a			 
2e6a 7e				ld a, (hl)      
2e6b				if DEBUG_FORTH_WORDS 
2e6b					DMARK "LSk" 
2e6b f5				push af  
2e6c 3a 80 2e			ld a, (.dmark)  
2e6f 32 68 fe			ld (debug_mark),a  
2e72 3a 81 2e			ld a, (.dmark+1)  
2e75 32 69 fe			ld (debug_mark+1),a  
2e78 3a 82 2e			ld a, (.dmark+2)  
2e7b 32 6a fe			ld (debug_mark+2),a  
2e7e 18 03			jr .pastdmark  
2e80 ..			.dmark: db "LSk"  
2e83 f1			.pastdmark: pop af  
2e84			endm  
# End of macro DMARK
2e84					CALLMONITOR 
2e84 cd 6c fe			call debug_vector  
2e87				endm  
# End of macro CALLMONITOR
2e87				endif 
2e87					;cp WORD_SYS_END 
2e87					;jp z, .lunotfound 
2e87			 
2e87					; if we hit non uwords then gone too far 
2e87 fe 01				cp WORD_SYS_UWORD 
2e89 c2 b9 2f				jp nz, .lunotfound 
2e8c			 
2e8c				if DEBUG_FORTH_WORDS 
2e8c					DMARK "LSu" 
2e8c f5				push af  
2e8d 3a a1 2e			ld a, (.dmark)  
2e90 32 68 fe			ld (debug_mark),a  
2e93 3a a2 2e			ld a, (.dmark+1)  
2e96 32 69 fe			ld (debug_mark+1),a  
2e99 3a a3 2e			ld a, (.dmark+2)  
2e9c 32 6a fe			ld (debug_mark+2),a  
2e9f 18 03			jr .pastdmark  
2ea1 ..			.dmark: db "LSu"  
2ea4 f1			.pastdmark: pop af  
2ea5			endm  
# End of macro DMARK
2ea5					CALLMONITOR 
2ea5 cd 6c fe			call debug_vector  
2ea8				endm  
# End of macro CALLMONITOR
2ea8				endif 
2ea8			 
2ea8					; found a uword but is it the one we want... 
2ea8			 
2ea8 c5					push bc     ; uword to find is on bc 
2ea9 d1					pop de 
2eaa			 
2eaa e5					push hl  ; to save the ptr 
2eab			 
2eab					; skip opcode 
2eab 23					inc hl  
2eac					; skip next ptr 
2eac 23					inc hl  
2ead 23					inc hl 
2eae					; skip len 
2eae 23					inc hl 
2eaf			 
2eaf				if DEBUG_FORTH_WORDS 
2eaf					DMARK "LSc" 
2eaf f5				push af  
2eb0 3a c4 2e			ld a, (.dmark)  
2eb3 32 68 fe			ld (debug_mark),a  
2eb6 3a c5 2e			ld a, (.dmark+1)  
2eb9 32 69 fe			ld (debug_mark+1),a  
2ebc 3a c6 2e			ld a, (.dmark+2)  
2ebf 32 6a fe			ld (debug_mark+2),a  
2ec2 18 03			jr .pastdmark  
2ec4 ..			.dmark: db "LSc"  
2ec7 f1			.pastdmark: pop af  
2ec8			endm  
# End of macro DMARK
2ec8					CALLMONITOR 
2ec8 cd 6c fe			call debug_vector  
2ecb				endm  
# End of macro CALLMONITOR
2ecb				endif 
2ecb cd 66 14				call strcmp 
2ece c2 4a 2e				jp nz, .ldouscanm 
2ed1				 
2ed1			 
2ed1			 
2ed1					; we have a uword so push its name to the stack 
2ed1			 
2ed1			;	   	push hl  ; save so we can move to next dict block 
2ed1 e1			pop hl 
2ed2			 
2ed2				if DEBUG_FORTH_WORDS 
2ed2					DMARK "LSm" 
2ed2 f5				push af  
2ed3 3a e7 2e			ld a, (.dmark)  
2ed6 32 68 fe			ld (debug_mark),a  
2ed9 3a e8 2e			ld a, (.dmark+1)  
2edc 32 69 fe			ld (debug_mark+1),a  
2edf 3a e9 2e			ld a, (.dmark+2)  
2ee2 32 6a fe			ld (debug_mark+2),a  
2ee5 18 03			jr .pastdmark  
2ee7 ..			.dmark: db "LSm"  
2eea f1			.pastdmark: pop af  
2eeb			endm  
# End of macro DMARK
2eeb					CALLMONITOR 
2eeb cd 6c fe			call debug_vector  
2eee				endm  
# End of macro CALLMONITOR
2eee				endif 
2eee			 
2eee					; skip opcode 
2eee 23					inc hl  
2eef					; skip next ptr 
2eef 23					inc hl  
2ef0 23					inc hl 
2ef1					; skip len 
2ef1 7e					ld a, (hl)   ; save length to add 
2ef2				if DEBUG_FORTH_WORDS 
2ef2					DMARK "LS2" 
2ef2 f5				push af  
2ef3 3a 07 2f			ld a, (.dmark)  
2ef6 32 68 fe			ld (debug_mark),a  
2ef9 3a 08 2f			ld a, (.dmark+1)  
2efc 32 69 fe			ld (debug_mark+1),a  
2eff 3a 09 2f			ld a, (.dmark+2)  
2f02 32 6a fe			ld (debug_mark+2),a  
2f05 18 03			jr .pastdmark  
2f07 ..			.dmark: db "LS2"  
2f0a f1			.pastdmark: pop af  
2f0b			endm  
# End of macro DMARK
2f0b					CALLMONITOR 
2f0b cd 6c fe			call debug_vector  
2f0e				endm  
# End of macro CALLMONITOR
2f0e				endif 
2f0e			 
2f0e					; save this location 
2f0e				 
2f0e e5					push hl 
2f0f			 
2f0f 23					inc hl 
2f10 11 c0 f1				ld de, scratch+2 
2f13 4f					ld c, a 
2f14 06 00				ld b, 0 
2f16			 
2f16				if DEBUG_FORTH_WORDS 
2f16					DMARK "LSn" 
2f16 f5				push af  
2f17 3a 2b 2f			ld a, (.dmark)  
2f1a 32 68 fe			ld (debug_mark),a  
2f1d 3a 2c 2f			ld a, (.dmark+1)  
2f20 32 69 fe			ld (debug_mark+1),a  
2f23 3a 2d 2f			ld a, (.dmark+2)  
2f26 32 6a fe			ld (debug_mark+2),a  
2f29 18 03			jr .pastdmark  
2f2b ..			.dmark: db "LSn"  
2f2e f1			.pastdmark: pop af  
2f2f			endm  
# End of macro DMARK
2f2f					CALLMONITOR 
2f2f cd 6c fe			call debug_vector  
2f32				endm  
# End of macro CALLMONITOR
2f32				endif 
2f32			 
2f32					; copy uword name to scratch 
2f32			 
2f32 ed b0				ldir 
2f34			 
2f34 1b					dec de 
2f35 3e 20				ld a, ' '    ; change null to space 
2f37 12					ld (de), a 
2f38			 
2f38 13					inc de 
2f39			 
2f39 d5					push de 
2f3a c1					pop bc     ; move scratch pointer to end of word name and save it 
2f3b			 
2f3b e1					pop hl 
2f3c 7e					ld a, (hl) 
2f3d					;inc hl 
2f3d					; skip word string 
2f3d cd d0 0f				call addatohl 
2f40			 
2f40 23					inc hl 
2f41			 
2f41				if DEBUG_FORTH_WORDS 
2f41					DMARK "LS3" 
2f41 f5				push af  
2f42 3a 56 2f			ld a, (.dmark)  
2f45 32 68 fe			ld (debug_mark),a  
2f48 3a 57 2f			ld a, (.dmark+1)  
2f4b 32 69 fe			ld (debug_mark+1),a  
2f4e 3a 58 2f			ld a, (.dmark+2)  
2f51 32 6a fe			ld (debug_mark+2),a  
2f54 18 03			jr .pastdmark  
2f56 ..			.dmark: db "LS3"  
2f59 f1			.pastdmark: pop af  
2f5a			endm  
# End of macro DMARK
2f5a					CALLMONITOR 
2f5a cd 6c fe			call debug_vector  
2f5d				endm  
# End of macro CALLMONITOR
2f5d				endif 
2f5d					; should now be at the start of the machine code to setup the eval of the uword 
2f5d					; now locate the ptr to the string defintion 
2f5d			 
2f5d					; skip ld hl, 
2f5d					; then load the ptr 
2f5d			; TODO use get from hl ptr 
2f5d 23					inc hl 
2f5e 5e					ld e, (hl) 
2f5f 23					inc hl 
2f60 56					ld d, (hl) 
2f61 eb					ex de, hl 
2f62			 
2f62			 
2f62				if DEBUG_FORTH_WORDS 
2f62					DMARK "LSt" 
2f62 f5				push af  
2f63 3a 77 2f			ld a, (.dmark)  
2f66 32 68 fe			ld (debug_mark),a  
2f69 3a 78 2f			ld a, (.dmark+1)  
2f6c 32 69 fe			ld (debug_mark+1),a  
2f6f 3a 79 2f			ld a, (.dmark+2)  
2f72 32 6a fe			ld (debug_mark+2),a  
2f75 18 03			jr .pastdmark  
2f77 ..			.dmark: db "LSt"  
2f7a f1			.pastdmark: pop af  
2f7b			endm  
# End of macro DMARK
2f7b					CALLMONITOR 
2f7b cd 6c fe			call debug_vector  
2f7e				endm  
# End of macro CALLMONITOR
2f7e				endif 
2f7e			 
2f7e			; cant push right now due to tokenised strings  
2f7e			 
2f7e			; get the destination of where to copy this definition to. 
2f7e			 
2f7e c5					push bc 
2f7f d1					pop de 
2f80			 
2f80 7e			.listl:         ld a,(hl) 
2f81 fe 00				cp 0 
2f83 28 09				jr z, .lreplsp     ; replace zero with space 
2f85					;cp FORTH_END_BUFFER 
2f85 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f87 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f89				 
2f89					; just copy this char as is then 
2f89			 
2f89 12					ld (de), a 
2f8a			 
2f8a 23			.listnxt:	inc hl 
2f8b 13					inc de 
2f8c 18 f2				jr .listl 
2f8e			 
2f8e 3e 20		.lreplsp:	ld a,' ' 
2f90 12					ld (de), a 
2f91 18 f7				jr .listnxt 
2f93			 
2f93			; close up uword def 
2f93			 
2f93			.listdone: 
2f93 12					ld (de), a 
2f94 13					inc de 
2f95 3e 00				ld a, 0 
2f97 12					ld (de), a 
2f98			 
2f98			; now have def so clean up and push to stack 
2f98			 
2f98 21 be f1				ld hl, scratch 
2f9b				if DEBUG_FORTH_WORDS 
2f9b					DMARK "Ltp" 
2f9b f5				push af  
2f9c 3a b0 2f			ld a, (.dmark)  
2f9f 32 68 fe			ld (debug_mark),a  
2fa2 3a b1 2f			ld a, (.dmark+1)  
2fa5 32 69 fe			ld (debug_mark+1),a  
2fa8 3a b2 2f			ld a, (.dmark+2)  
2fab 32 6a fe			ld (debug_mark+2),a  
2fae 18 03			jr .pastdmark  
2fb0 ..			.dmark: db "Ltp"  
2fb3 f1			.pastdmark: pop af  
2fb4			endm  
# End of macro DMARK
2fb4					CALLMONITOR 
2fb4 cd 6c fe			call debug_vector  
2fb7				endm  
# End of macro CALLMONITOR
2fb7				endif 
2fb7			 
2fb7 18 1f			jr .listpush 
2fb9			 
2fb9			;.lnuword:	pop hl 
2fb9			;		call forth_tok_next 
2fb9			;		jp .ldouscan  
2fb9			 
2fb9			.lunotfound:		  
2fb9			 
2fb9				if DEBUG_FORTH_WORDS 
2fb9					DMARK "LSn" 
2fb9 f5				push af  
2fba 3a ce 2f			ld a, (.dmark)  
2fbd 32 68 fe			ld (debug_mark),a  
2fc0 3a cf 2f			ld a, (.dmark+1)  
2fc3 32 69 fe			ld (debug_mark+1),a  
2fc6 3a d0 2f			ld a, (.dmark+2)  
2fc9 32 6a fe			ld (debug_mark+2),a  
2fcc 18 03			jr .pastdmark  
2fce ..			.dmark: db "LSn"  
2fd1 f1			.pastdmark: pop af  
2fd2			endm  
# End of macro DMARK
2fd2					CALLMONITOR 
2fd2 cd 6c fe			call debug_vector  
2fd5				endm  
# End of macro CALLMONITOR
2fd5				endif 
2fd5			 
2fd5					 
2fd5			;		FORTH_DSP_POP 
2fd5			;		ld hl, .luno 
2fd5			 
2fd5					NEXTW			 
2fd5 c3 c2 24			jp macro_next 
2fd8				endm 
# End of macro NEXTW
2fd8			 
2fd8			.listpush: 
2fd8				if DEBUG_FORTH_WORDS 
2fd8					DMARK "LS>" 
2fd8 f5				push af  
2fd9 3a ed 2f			ld a, (.dmark)  
2fdc 32 68 fe			ld (debug_mark),a  
2fdf 3a ee 2f			ld a, (.dmark+1)  
2fe2 32 69 fe			ld (debug_mark+1),a  
2fe5 3a ef 2f			ld a, (.dmark+2)  
2fe8 32 6a fe			ld (debug_mark+2),a  
2feb 18 03			jr .pastdmark  
2fed ..			.dmark: db "LS>"  
2ff0 f1			.pastdmark: pop af  
2ff1			endm  
# End of macro DMARK
2ff1					CALLMONITOR 
2ff1 cd 6c fe			call debug_vector  
2ff4				endm  
# End of macro CALLMONITOR
2ff4				endif 
2ff4 cd 83 21				call forth_push_str 
2ff7			 
2ff7			 
2ff7			 
2ff7					NEXTW 
2ff7 c3 c2 24			jp macro_next 
2ffa				endm 
# End of macro NEXTW
2ffa			 
2ffa			;.luno:    db "Word not found",0 
2ffa			 
2ffa			 
2ffa			 
2ffa			 
2ffa			 
2ffa			;		push hl   ; save pointer to start of uword def string 
2ffa			; 
2ffa			;; look for FORTH_EOL_LINE 
2ffa			;		ld a, FORTH_END_BUFFER 
2ffa			;		call strlent 
2ffa			; 
2ffa			;		inc hl		 ; space for coln def 
2ffa			;		inc hl 
2ffa			;		inc hl          ; space for terms 
2ffa			;		inc hl 
2ffa			; 
2ffa			;		ld a, 20   ; TODO get actual length 
2ffa			;		call addatohl    ; include a random amount of room for the uword name 
2ffa			; 
2ffa			;		 
2ffa			;	if DEBUG_FORTH_WORDS 
2ffa			;		DMARK "Lt1" 
2ffa			;		CALLMONITOR 
2ffa			;	endif 
2ffa			;		 
2ffa			; 
2ffa			;; malloc space for the string because we cant change it 
2ffa			; 
2ffa			;		call malloc 
2ffa			;	if DEBUG_FORTH_MALLOC_GUARD 
2ffa			;		push af 
2ffa			;		call ishlzero 
2ffa			;		pop af 
2ffa			;		 
2ffa			;		call z,malloc_error 
2ffa			;	endif 
2ffa			; 
2ffa			;	if DEBUG_FORTH_WORDS 
2ffa			;		DMARK "Lt2" 
2ffa			;		CALLMONITOR 
2ffa			;	endif 
2ffa			;		pop de 
2ffa			;		push hl    ; push the malloc to release later 
2ffa			;		push hl   ;  push back a copy for the later stack push 
2ffa			;		 
2ffa			;; copy the string swapping out the zero terms for spaces 
2ffa			; 
2ffa			;		; de has our source 
2ffa			;		; hl has our dest 
2ffa			; 
2ffa			;; add the coln def 
2ffa			; 
2ffa			;		ld a, ':' 
2ffa			;		ld (hl), a 
2ffa			;		inc hl 
2ffa			;		ld a, ' ' 
2ffa			;		ld (hl), a 
2ffa			;		inc hl 
2ffa			; 
2ffa			;; add the uname word 
2ffa			;		push de   ; save our string for now 
2ffa			;		ex de, hl 
2ffa			; 
2ffa			;		FORTH_DSP_VALUE 
2ffa			;		;v5 FORTH_DSP_VALUE 
2ffa			; 
2ffa			;		inc hl   ; skip type but we know by now this is OK 
2ffa			; 
2ffa			;.luword:	ld a,(hl) 
2ffa			;		cp 0 
2ffa			;		jr z, .luword2 
2ffa			;		ld (de), a 
2ffa			;		inc de 
2ffa			;		inc hl 
2ffa			;		jr .luword 
2ffa			; 
2ffa			;.luword2:	ld a, ' ' 
2ffa			;		ld (de), a 
2ffa			;;		inc hl 
2ffa			;;		inc de 
2ffa			;;		ld (de), a 
2ffa			;;		inc hl 
2ffa			;		inc de 
2ffa			; 
2ffa			;		ex de, hl 
2ffa			;		pop de 
2ffa			;		 
2ffa			;		 
2ffa			; 
2ffa			;; detoken that string and copy it 
2ffa			; 
2ffa			;	if DEBUG_FORTH_WORDS 
2ffa			;		DMARK "Lt2" 
2ffa			;		CALLMONITOR 
2ffa			;	endif 
2ffa			;.ldetok:	ld a, (de) 
2ffa			;		cp FORTH_END_BUFFER 
2ffa			;		jr z, .ldetokend 
2ffa			;		; swap out any zero term for space 
2ffa			;		cp 0 
2ffa			;		jr nz, .ldetoknext 
2ffa			;		ld a, ' ' 
2ffa			; 
2ffa			;	if DEBUG_FORTH_WORDS 
2ffa			;		DMARK "LtS" 
2ffa			;		CALLMONITOR 
2ffa			;	endif 
2ffa			;.ldetoknext:	ld (hl), a 
2ffa			;		inc de 
2ffa			;		inc hl 
2ffa			;		jr .ldetok 
2ffa			; 
2ffa			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2ffa			;		ld (hl), a  
2ffa			; 
2ffa			;; free that temp malloc 
2ffa			; 
2ffa			;		pop hl    
2ffa			; 
2ffa			;	if DEBUG_FORTH_WORDS 
2ffa			;		DMARK "Lt4" 
2ffa			;		CALLMONITOR 
2ffa			;	endif 
2ffa			;		call forth_apushstrhl 
2ffa			; 
2ffa			;		; get rid of temp malloc area 
2ffa			; 
2ffa			;		pop hl 
2ffa			;		call free 
2ffa			; 
2ffa			;		jr .ludone 
2ffa			; 
2ffa			;.lnuword:	pop hl 
2ffa			;		call forth_tok_next 
2ffa			;		jp .ldouscan  
2ffa			; 
2ffa			;.ludone:		 pop hl 
2ffa			; 
2ffa					NEXTW 
2ffa c3 c2 24			jp macro_next 
2ffd				endm 
# End of macro NEXTW
2ffd			 
2ffd			.FORGET: 
2ffd				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2ffd 5d				db WORD_SYS_CORE+73             
2ffe 76 30			dw .NOP            
3000 07				db 6 + 1 
3001 .. 00			db "FORGET",0              
3008				endm 
# End of macro CWHEAD
3008			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
3008			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
3008			; | |  
3008			; | | e.g. "MORE" forget 
3008					if DEBUG_FORTH_WORDS_KEY 
3008						DMARK "FRG" 
3008 f5				push af  
3009 3a 1d 30			ld a, (.dmark)  
300c 32 68 fe			ld (debug_mark),a  
300f 3a 1e 30			ld a, (.dmark+1)  
3012 32 69 fe			ld (debug_mark+1),a  
3015 3a 1f 30			ld a, (.dmark+2)  
3018 32 6a fe			ld (debug_mark+2),a  
301b 18 03			jr .pastdmark  
301d ..			.dmark: db "FRG"  
3020 f1			.pastdmark: pop af  
3021			endm  
# End of macro DMARK
3021						CALLMONITOR 
3021 cd 6c fe			call debug_vector  
3024				endm  
# End of macro CALLMONITOR
3024					endif 
3024			 
3024				; find uword 
3024			        ; update start of word with "_" 
3024				; replace uword with deleted flag 
3024			 
3024			 
3024			;	if DEBUG_FORTH_WORDS 
3024			;		DMARK "FOG" 
3024			;		CALLMONITOR 
3024			;	endif 
3024			 
3024			 
3024					; Get ptr to the word we need to look up 
3024			 
3024					FORTH_DSP_VALUEHL 
3024 cd 0c 23			call macro_dsp_valuehl 
3027				endm 
# End of macro FORTH_DSP_VALUEHL
3027					;v5 FORTH_DSP_VALUE 
3027				; TODO type check 
3027			;		inc hl    ; Skip type check  
3027 e5					push hl 
3028 c1					pop bc 
3029			;		ex de, hl    ; put into DE 
3029			 
3029			 
3029 21 00 80				ld hl, baseram 
302c					;ld hl, baseusermem 
302c			 
302c				; skip dict stub 
302c			;	call forth_tok_next 
302c e5			push hl   ; sacreifical push 
302d			 
302d			.fldouscanm: 
302d e1				pop hl 
302e			.fldouscan: 
302e			;	if DEBUG_FORTH_WORDS 
302e			;		DMARK "LSs" 
302e			;		CALLMONITOR 
302e			;	endif 
302e				; skip dict stub 
302e cd 13 26				call forth_tok_next 
3031			 
3031			 
3031			; while we have words to look for 
3031			 
3031 7e				ld a, (hl)      
3032			;	if DEBUG_FORTH_WORDS 
3032			;		DMARK "LSk" 
3032			;		CALLMONITOR 
3032			;	endif 
3032 fe 00				cp WORD_SYS_END 
3034 ca 70 30				jp z, .flunotfound 
3037 fe 01				cp WORD_SYS_UWORD 
3039 c2 2e 30				jp nz, .fldouscan 
303c			 
303c			;	if DEBUG_FORTH_WORDS 
303c			;		DMARK "LSu" 
303c			;		CALLMONITOR 
303c			;	endif 
303c			 
303c					; found a uword but is it the one we want... 
303c			 
303c c5					push bc     ; uword to find is on bc 
303d d1					pop de 
303e			 
303e e5					push hl  ; to save the ptr 
303f			 
303f					; skip opcode 
303f 23					inc hl  
3040					; skip next ptr 
3040 23					inc hl  
3041 23					inc hl 
3042					; skip len 
3042 23					inc hl 
3043			 
3043			;	if DEBUG_FORTH_WORDS 
3043			;		DMARK "LSc" 
3043			;		CALLMONITOR 
3043			;	endif 
3043 cd 66 14				call strcmp 
3046 c2 2d 30				jp nz, .fldouscanm 
3049			; 
3049			; 
3049			;; while we have words to look for 
3049			; 
3049			;.fdouscan:	ld a, (hl)      
3049			;	if DEBUG_FORTH_WORDS 
3049			;		DMARK "LSs" 
3049			;		CALLMONITOR 
3049			;	endif 
3049			;		cp WORD_SYS_END 
3049			;		jp z, .fudone 
3049			;		cp WORD_SYS_UWORD 
3049			;		jp nz, .fnuword 
3049			; 
3049			;	if DEBUG_FORTH_WORDS 
3049			;		DMARK "FGu" 
3049			;		CALLMONITOR 
3049			;	endif 
3049			; 
3049			;		; found a uword but is it the one we want... 
3049			; 
3049			; 
3049			;	        pop de   ; get back the dsp name 
3049			;		push de 
3049			; 
3049			;		push hl  ; to save the ptr 
3049			; 
3049			;		; skip opcode 
3049			;		inc hl  
3049			;		; skip next ptr 
3049			;		inc hl  
3049			;		inc hl 
3049			;		; skip len 
3049			;		inc hl 
3049			; 
3049			;	if DEBUG_FORTH_WORDS 
3049			;		DMARK "FGc" 
3049			;		CALLMONITOR 
3049			;	endif 
3049			;		call strcmp 
3049			;		jp nz, .fnuword 
3049			 
3049			 
3049 e1			pop hl 
304a			 
304a				 
304a				if DEBUG_FORTH_WORDS 
304a					DMARK "FGm" 
304a f5				push af  
304b 3a 5f 30			ld a, (.dmark)  
304e 32 68 fe			ld (debug_mark),a  
3051 3a 60 30			ld a, (.dmark+1)  
3054 32 69 fe			ld (debug_mark+1),a  
3057 3a 61 30			ld a, (.dmark+2)  
305a 32 6a fe			ld (debug_mark+2),a  
305d 18 03			jr .pastdmark  
305f ..			.dmark: db "FGm"  
3062 f1			.pastdmark: pop af  
3063			endm  
# End of macro DMARK
3063					CALLMONITOR 
3063 cd 6c fe			call debug_vector  
3066				endm  
# End of macro CALLMONITOR
3066				endif 
3066			 
3066			 
3066			 
3066					; we have a uword so push its name to the stack 
3066			 
3066			;	   	push hl  ; save so we can move to next dict block 
3066			;pop hl 
3066			 
3066					; update opcode to deleted 
3066 3e 03				ld a, WORD_SYS_DELETED 
3068 77					ld (hl), a 
3069			 
3069 23					inc hl  
306a					; skip next ptr 
306a 23					inc hl  
306b 23					inc hl 
306c					; skip len 
306c 23					inc hl 
306d			 
306d					; TODO change parser to skip deleted words but for now mark it out 
306d 3e 5f				ld a, "_" 
306f 77					ld  (hl),a 
3070			 
3070			;		jr .fudone 
3070			; 
3070			;.fnuword:	pop hl 
3070			;		call forth_tok_next 
3070			;		jp .fdouscan  
3070			 
3070			.flunotfound:		  
3070			 
3070			 
3070					 
3070					FORTH_DSP_POP 
3070 cd c4 23			call macro_forth_dsp_pop 
3073				endm 
# End of macro FORTH_DSP_POP
3073			;		ld hl, .luno 
3073			;.fudone:		 pop hl 
3073					NEXTW 
3073 c3 c2 24			jp macro_next 
3076				endm 
# End of macro NEXTW
3076			.NOP: 
3076				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3076 61				db WORD_SYS_CORE+77             
3077 9d 30			dw .COMO            
3079 04				db 3 + 1 
307a .. 00			db "NOP",0              
307e				endm 
# End of macro CWHEAD
307e			; | NOP (  --  ) Do nothing | DONE 
307e					if DEBUG_FORTH_WORDS_KEY 
307e						DMARK "NOP" 
307e f5				push af  
307f 3a 93 30			ld a, (.dmark)  
3082 32 68 fe			ld (debug_mark),a  
3085 3a 94 30			ld a, (.dmark+1)  
3088 32 69 fe			ld (debug_mark+1),a  
308b 3a 95 30			ld a, (.dmark+2)  
308e 32 6a fe			ld (debug_mark+2),a  
3091 18 03			jr .pastdmark  
3093 ..			.dmark: db "NOP"  
3096 f1			.pastdmark: pop af  
3097			endm  
# End of macro DMARK
3097						CALLMONITOR 
3097 cd 6c fe			call debug_vector  
309a				endm  
# End of macro CALLMONITOR
309a					endif 
309a				       NEXTW 
309a c3 c2 24			jp macro_next 
309d				endm 
# End of macro NEXTW
309d			.COMO: 
309d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
309d 6e				db WORD_SYS_CORE+90             
309e ef 30			dw .COMC            
30a0 02				db 1 + 1 
30a1 .. 00			db "(",0              
30a3				endm 
# End of macro CWHEAD
30a3			; | ( ( -- )  Start of comment | DONE 
30a3			 
30a3			 
30a3 2a bf f4				ld hl, ( os_tok_ptr) 
30a6 11 ea 30			ld de, .closepar 
30a9					 
30a9					if DEBUG_FORTH_WORDS 
30a9						DMARK ").." 
30a9 f5				push af  
30aa 3a be 30			ld a, (.dmark)  
30ad 32 68 fe			ld (debug_mark),a  
30b0 3a bf 30			ld a, (.dmark+1)  
30b3 32 69 fe			ld (debug_mark+1),a  
30b6 3a c0 30			ld a, (.dmark+2)  
30b9 32 6a fe			ld (debug_mark+2),a  
30bc 18 03			jr .pastdmark  
30be ..			.dmark: db ").."  
30c1 f1			.pastdmark: pop af  
30c2			endm  
# End of macro DMARK
30c2						CALLMONITOR 
30c2 cd 6c fe			call debug_vector  
30c5				endm  
# End of macro CALLMONITOR
30c5					endif 
30c5 cd dd 25			call findnexttok  
30c8			 
30c8					if DEBUG_FORTH_WORDS 
30c8						DMARK "IF5" 
30c8 f5				push af  
30c9 3a dd 30			ld a, (.dmark)  
30cc 32 68 fe			ld (debug_mark),a  
30cf 3a de 30			ld a, (.dmark+1)  
30d2 32 69 fe			ld (debug_mark+1),a  
30d5 3a df 30			ld a, (.dmark+2)  
30d8 32 6a fe			ld (debug_mark+2),a  
30db 18 03			jr .pastdmark  
30dd ..			.dmark: db "IF5"  
30e0 f1			.pastdmark: pop af  
30e1			endm  
# End of macro DMARK
30e1						CALLMONITOR 
30e1 cd 6c fe			call debug_vector  
30e4				endm  
# End of macro CALLMONITOR
30e4					endif 
30e4				; replace below with ) exec using tok_ptr 
30e4 22 bf f4			ld (os_tok_ptr), hl 
30e7 c3 53 25			jp exec1 
30ea			 
30ea .. 00			.closepar:   db ")",0 
30ec			 
30ec				       NEXTW 
30ec c3 c2 24			jp macro_next 
30ef				endm 
# End of macro NEXTW
30ef			.COMC: 
30ef				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30ef 6f				db WORD_SYS_CORE+91             
30f0 f8 30			dw .SCRATCH            
30f2 02				db 1 + 1 
30f3 .. 00			db ")",0              
30f5				endm 
# End of macro CWHEAD
30f5			; | ) ( -- )  End of comment |  DONE  
30f5				       NEXTW 
30f5 c3 c2 24			jp macro_next 
30f8				endm 
# End of macro NEXTW
30f8			 
30f8			.SCRATCH: 
30f8				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30f8 6f				db WORD_SYS_CORE+91             
30f9 33 31			dw .INC            
30fb 08				db 7 + 1 
30fc .. 00			db "SCRATCH",0              
3104				endm 
# End of macro CWHEAD
3104			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3104			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3104			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3104			; | |  
3104			; | | e.g.    : score $00 scratch ; 
3104			; | |  
3104			; | | $00 score ! 
3104			; | | $01 score +! 
3104			; | |  
3104			; | | e.g.   : varword $0a scratch ;  
3104			; | | 
3104			; | | $8000 varword ! 
3104					if DEBUG_FORTH_WORDS_KEY 
3104						DMARK "SCR" 
3104 f5				push af  
3105 3a 19 31			ld a, (.dmark)  
3108 32 68 fe			ld (debug_mark),a  
310b 3a 1a 31			ld a, (.dmark+1)  
310e 32 69 fe			ld (debug_mark+1),a  
3111 3a 1b 31			ld a, (.dmark+2)  
3114 32 6a fe			ld (debug_mark+2),a  
3117 18 03			jr .pastdmark  
3119 ..			.dmark: db "SCR"  
311c f1			.pastdmark: pop af  
311d			endm  
# End of macro DMARK
311d						CALLMONITOR 
311d cd 6c fe			call debug_vector  
3120				endm  
# End of macro CALLMONITOR
3120					endif 
3120			 
3120					FORTH_DSP_VALUEHL 
3120 cd 0c 23			call macro_dsp_valuehl 
3123				endm 
# End of macro FORTH_DSP_VALUEHL
3123				 
3123					FORTH_DSP_POP 
3123 cd c4 23			call macro_forth_dsp_pop 
3126				endm 
# End of macro FORTH_DSP_POP
3126			 
3126 7d					ld a, l 
3127 21 e3 f6				ld hl, os_var_array 
312a cd d0 0f				call addatohl 
312d			 
312d cd 15 21				call forth_push_numhl 
3130			 
3130				       NEXTW 
3130 c3 c2 24			jp macro_next 
3133				endm 
# End of macro NEXTW
3133			 
3133			.INC: 
3133				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3133 6f				db WORD_SYS_CORE+91             
3134 87 31			dw .DEC            
3136 03				db 2 + 1 
3137 .. 00			db "+!",0              
313a				endm 
# End of macro CWHEAD
313a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
313a					if DEBUG_FORTH_WORDS_KEY 
313a						DMARK "+s_" 
313a f5				push af  
313b 3a 4f 31			ld a, (.dmark)  
313e 32 68 fe			ld (debug_mark),a  
3141 3a 50 31			ld a, (.dmark+1)  
3144 32 69 fe			ld (debug_mark+1),a  
3147 3a 51 31			ld a, (.dmark+2)  
314a 32 6a fe			ld (debug_mark+2),a  
314d 18 03			jr .pastdmark  
314f ..			.dmark: db "+s_"  
3152 f1			.pastdmark: pop af  
3153			endm  
# End of macro DMARK
3153						CALLMONITOR 
3153 cd 6c fe			call debug_vector  
3156				endm  
# End of macro CALLMONITOR
3156					endif 
3156			 
3156					FORTH_DSP_VALUEHL 
3156 cd 0c 23			call macro_dsp_valuehl 
3159				endm 
# End of macro FORTH_DSP_VALUEHL
3159			 
3159 e5					push hl   ; save address 
315a			 
315a					FORTH_DSP_POP 
315a cd c4 23			call macro_forth_dsp_pop 
315d				endm 
# End of macro FORTH_DSP_POP
315d			 
315d					FORTH_DSP_VALUEHL 
315d cd 0c 23			call macro_dsp_valuehl 
3160				endm 
# End of macro FORTH_DSP_VALUEHL
3160			 
3160					FORTH_DSP_POP 
3160 cd c4 23			call macro_forth_dsp_pop 
3163				endm 
# End of macro FORTH_DSP_POP
3163			 
3163					; hl contains value to add to byte at a 
3163				 
3163 eb					ex de, hl 
3164			 
3164 e1					pop hl 
3165			 
3165					if DEBUG_FORTH_WORDS 
3165						DMARK "INC" 
3165 f5				push af  
3166 3a 7a 31			ld a, (.dmark)  
3169 32 68 fe			ld (debug_mark),a  
316c 3a 7b 31			ld a, (.dmark+1)  
316f 32 69 fe			ld (debug_mark+1),a  
3172 3a 7c 31			ld a, (.dmark+2)  
3175 32 6a fe			ld (debug_mark+2),a  
3178 18 03			jr .pastdmark  
317a ..			.dmark: db "INC"  
317d f1			.pastdmark: pop af  
317e			endm  
# End of macro DMARK
317e						CALLMONITOR 
317e cd 6c fe			call debug_vector  
3181				endm  
# End of macro CALLMONITOR
3181					endif 
3181			 
3181 7e					ld a,(hl) 
3182 83					add e 
3183 77					ld (hl),a 
3184			 
3184			 
3184			 
3184				       NEXTW 
3184 c3 c2 24			jp macro_next 
3187				endm 
# End of macro NEXTW
3187			 
3187			.DEC: 
3187				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3187 6f				db WORD_SYS_CORE+91             
3188 d8 31			dw .INC2            
318a 03				db 2 + 1 
318b .. 00			db "-!",0              
318e				endm 
# End of macro CWHEAD
318e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
318e					if DEBUG_FORTH_WORDS_KEY 
318e						DMARK "-s_" 
318e f5				push af  
318f 3a a3 31			ld a, (.dmark)  
3192 32 68 fe			ld (debug_mark),a  
3195 3a a4 31			ld a, (.dmark+1)  
3198 32 69 fe			ld (debug_mark+1),a  
319b 3a a5 31			ld a, (.dmark+2)  
319e 32 6a fe			ld (debug_mark+2),a  
31a1 18 03			jr .pastdmark  
31a3 ..			.dmark: db "-s_"  
31a6 f1			.pastdmark: pop af  
31a7			endm  
# End of macro DMARK
31a7						CALLMONITOR 
31a7 cd 6c fe			call debug_vector  
31aa				endm  
# End of macro CALLMONITOR
31aa					endif 
31aa			 
31aa					FORTH_DSP_VALUEHL 
31aa cd 0c 23			call macro_dsp_valuehl 
31ad				endm 
# End of macro FORTH_DSP_VALUEHL
31ad			 
31ad e5					push hl   ; save address 
31ae			 
31ae					FORTH_DSP_POP 
31ae cd c4 23			call macro_forth_dsp_pop 
31b1				endm 
# End of macro FORTH_DSP_POP
31b1			 
31b1					FORTH_DSP_VALUEHL 
31b1 cd 0c 23			call macro_dsp_valuehl 
31b4				endm 
# End of macro FORTH_DSP_VALUEHL
31b4			 
31b4					; hl contains value to add to byte at a 
31b4				 
31b4 eb					ex de, hl 
31b5			 
31b5 e1					pop hl 
31b6			 
31b6					if DEBUG_FORTH_WORDS 
31b6						DMARK "DEC" 
31b6 f5				push af  
31b7 3a cb 31			ld a, (.dmark)  
31ba 32 68 fe			ld (debug_mark),a  
31bd 3a cc 31			ld a, (.dmark+1)  
31c0 32 69 fe			ld (debug_mark+1),a  
31c3 3a cd 31			ld a, (.dmark+2)  
31c6 32 6a fe			ld (debug_mark+2),a  
31c9 18 03			jr .pastdmark  
31cb ..			.dmark: db "DEC"  
31ce f1			.pastdmark: pop af  
31cf			endm  
# End of macro DMARK
31cf						CALLMONITOR 
31cf cd 6c fe			call debug_vector  
31d2				endm  
# End of macro CALLMONITOR
31d2					endif 
31d2			 
31d2 7e					ld a,(hl) 
31d3 93					sub e 
31d4 77					ld (hl),a 
31d5			 
31d5			 
31d5			 
31d5				       NEXTW 
31d5 c3 c2 24			jp macro_next 
31d8				endm 
# End of macro NEXTW
31d8			 
31d8			.INC2: 
31d8				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31d8 6f				db WORD_SYS_CORE+91             
31d9 82 32			dw .DEC2            
31db 04				db 3 + 1 
31dc .. 00			db "+2!",0              
31e0				endm 
# End of macro CWHEAD
31e0			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31e0			 
31e0					if DEBUG_FORTH_WORDS_KEY 
31e0						DMARK "+2s" 
31e0 f5				push af  
31e1 3a f5 31			ld a, (.dmark)  
31e4 32 68 fe			ld (debug_mark),a  
31e7 3a f6 31			ld a, (.dmark+1)  
31ea 32 69 fe			ld (debug_mark+1),a  
31ed 3a f7 31			ld a, (.dmark+2)  
31f0 32 6a fe			ld (debug_mark+2),a  
31f3 18 03			jr .pastdmark  
31f5 ..			.dmark: db "+2s"  
31f8 f1			.pastdmark: pop af  
31f9			endm  
# End of macro DMARK
31f9						CALLMONITOR 
31f9 cd 6c fe			call debug_vector  
31fc				endm  
# End of macro CALLMONITOR
31fc					endif 
31fc			 
31fc					; Address 
31fc			 
31fc					FORTH_DSP_VALUEHL 
31fc cd 0c 23			call macro_dsp_valuehl 
31ff				endm 
# End of macro FORTH_DSP_VALUEHL
31ff			 
31ff e5					push hl    ; save address 
3200			 
3200					; load content into de 
3200			 
3200 5e					ld e,(hl) 
3201 23					inc hl 
3202 56					ld d, (hl) 
3203			 
3203					if DEBUG_FORTH_WORDS 
3203						DMARK "+2a" 
3203 f5				push af  
3204 3a 18 32			ld a, (.dmark)  
3207 32 68 fe			ld (debug_mark),a  
320a 3a 19 32			ld a, (.dmark+1)  
320d 32 69 fe			ld (debug_mark+1),a  
3210 3a 1a 32			ld a, (.dmark+2)  
3213 32 6a fe			ld (debug_mark+2),a  
3216 18 03			jr .pastdmark  
3218 ..			.dmark: db "+2a"  
321b f1			.pastdmark: pop af  
321c			endm  
# End of macro DMARK
321c						CALLMONITOR 
321c cd 6c fe			call debug_vector  
321f				endm  
# End of macro CALLMONITOR
321f					endif 
321f			 
321f					FORTH_DSP_POP 
321f cd c4 23			call macro_forth_dsp_pop 
3222				endm 
# End of macro FORTH_DSP_POP
3222			 
3222					; Get value to add 
3222			 
3222					FORTH_DSP_VALUE 
3222 cd f5 22			call macro_forth_dsp_value 
3225				endm 
# End of macro FORTH_DSP_VALUE
3225			 
3225					if DEBUG_FORTH_WORDS 
3225						DMARK "+2v" 
3225 f5				push af  
3226 3a 3a 32			ld a, (.dmark)  
3229 32 68 fe			ld (debug_mark),a  
322c 3a 3b 32			ld a, (.dmark+1)  
322f 32 69 fe			ld (debug_mark+1),a  
3232 3a 3c 32			ld a, (.dmark+2)  
3235 32 6a fe			ld (debug_mark+2),a  
3238 18 03			jr .pastdmark  
323a ..			.dmark: db "+2v"  
323d f1			.pastdmark: pop af  
323e			endm  
# End of macro DMARK
323e						CALLMONITOR 
323e cd 6c fe			call debug_vector  
3241				endm  
# End of macro CALLMONITOR
3241					endif 
3241			 
3241 19					add hl, de 
3242			 
3242					if DEBUG_FORTH_WORDS 
3242						DMARK "+2+" 
3242 f5				push af  
3243 3a 57 32			ld a, (.dmark)  
3246 32 68 fe			ld (debug_mark),a  
3249 3a 58 32			ld a, (.dmark+1)  
324c 32 69 fe			ld (debug_mark+1),a  
324f 3a 59 32			ld a, (.dmark+2)  
3252 32 6a fe			ld (debug_mark+2),a  
3255 18 03			jr .pastdmark  
3257 ..			.dmark: db "+2+"  
325a f1			.pastdmark: pop af  
325b			endm  
# End of macro DMARK
325b						CALLMONITOR 
325b cd 6c fe			call debug_vector  
325e				endm  
# End of macro CALLMONITOR
325e					endif 
325e			 
325e					; move result to de 
325e			 
325e eb					ex de, hl 
325f			 
325f					; Address 
325f			 
325f e1					pop hl 
3260			 
3260					; save it back 
3260			 
3260 73					ld (hl), e 
3261 23					inc hl 
3262 72					ld (hl), d 
3263			 
3263					if DEBUG_FORTH_WORDS 
3263						DMARK "+2e" 
3263 f5				push af  
3264 3a 78 32			ld a, (.dmark)  
3267 32 68 fe			ld (debug_mark),a  
326a 3a 79 32			ld a, (.dmark+1)  
326d 32 69 fe			ld (debug_mark+1),a  
3270 3a 7a 32			ld a, (.dmark+2)  
3273 32 6a fe			ld (debug_mark+2),a  
3276 18 03			jr .pastdmark  
3278 ..			.dmark: db "+2e"  
327b f1			.pastdmark: pop af  
327c			endm  
# End of macro DMARK
327c						CALLMONITOR 
327c cd 6c fe			call debug_vector  
327f				endm  
# End of macro CALLMONITOR
327f					endif 
327f			 
327f			 
327f			 
327f			 
327f			 
327f				       NEXTW 
327f c3 c2 24			jp macro_next 
3282				endm 
# End of macro NEXTW
3282			 
3282			.DEC2: 
3282				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3282 6f				db WORD_SYS_CORE+91             
3283 2e 33			dw .GET2            
3285 04				db 3 + 1 
3286 .. 00			db "-2!",0              
328a				endm 
# End of macro CWHEAD
328a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
328a			 
328a			 
328a					if DEBUG_FORTH_WORDS_KEY 
328a						DMARK "-2s" 
328a f5				push af  
328b 3a 9f 32			ld a, (.dmark)  
328e 32 68 fe			ld (debug_mark),a  
3291 3a a0 32			ld a, (.dmark+1)  
3294 32 69 fe			ld (debug_mark+1),a  
3297 3a a1 32			ld a, (.dmark+2)  
329a 32 6a fe			ld (debug_mark+2),a  
329d 18 03			jr .pastdmark  
329f ..			.dmark: db "-2s"  
32a2 f1			.pastdmark: pop af  
32a3			endm  
# End of macro DMARK
32a3						CALLMONITOR 
32a3 cd 6c fe			call debug_vector  
32a6				endm  
# End of macro CALLMONITOR
32a6					endif 
32a6			 
32a6					; Address 
32a6			 
32a6					FORTH_DSP_VALUEHL 
32a6 cd 0c 23			call macro_dsp_valuehl 
32a9				endm 
# End of macro FORTH_DSP_VALUEHL
32a9			 
32a9 e5					push hl    ; save address 
32aa			 
32aa					; load content into de 
32aa			 
32aa 5e					ld e,(hl) 
32ab 23					inc hl 
32ac 56					ld d, (hl) 
32ad			 
32ad					if DEBUG_FORTH_WORDS 
32ad						DMARK "-2a" 
32ad f5				push af  
32ae 3a c2 32			ld a, (.dmark)  
32b1 32 68 fe			ld (debug_mark),a  
32b4 3a c3 32			ld a, (.dmark+1)  
32b7 32 69 fe			ld (debug_mark+1),a  
32ba 3a c4 32			ld a, (.dmark+2)  
32bd 32 6a fe			ld (debug_mark+2),a  
32c0 18 03			jr .pastdmark  
32c2 ..			.dmark: db "-2a"  
32c5 f1			.pastdmark: pop af  
32c6			endm  
# End of macro DMARK
32c6						CALLMONITOR 
32c6 cd 6c fe			call debug_vector  
32c9				endm  
# End of macro CALLMONITOR
32c9					endif 
32c9			 
32c9					FORTH_DSP_POP 
32c9 cd c4 23			call macro_forth_dsp_pop 
32cc				endm 
# End of macro FORTH_DSP_POP
32cc			 
32cc					; Get value to remove 
32cc			 
32cc					FORTH_DSP_VALUE 
32cc cd f5 22			call macro_forth_dsp_value 
32cf				endm 
# End of macro FORTH_DSP_VALUE
32cf			 
32cf					if DEBUG_FORTH_WORDS 
32cf						DMARK "-2v" 
32cf f5				push af  
32d0 3a e4 32			ld a, (.dmark)  
32d3 32 68 fe			ld (debug_mark),a  
32d6 3a e5 32			ld a, (.dmark+1)  
32d9 32 69 fe			ld (debug_mark+1),a  
32dc 3a e6 32			ld a, (.dmark+2)  
32df 32 6a fe			ld (debug_mark+2),a  
32e2 18 03			jr .pastdmark  
32e4 ..			.dmark: db "-2v"  
32e7 f1			.pastdmark: pop af  
32e8			endm  
# End of macro DMARK
32e8						CALLMONITOR 
32e8 cd 6c fe			call debug_vector  
32eb				endm  
# End of macro CALLMONITOR
32eb					endif 
32eb			 
32eb eb					ex de, hl 
32ec ed 52				sbc hl, de 
32ee			 
32ee					if DEBUG_FORTH_WORDS 
32ee						DMARK "-2d" 
32ee f5				push af  
32ef 3a 03 33			ld a, (.dmark)  
32f2 32 68 fe			ld (debug_mark),a  
32f5 3a 04 33			ld a, (.dmark+1)  
32f8 32 69 fe			ld (debug_mark+1),a  
32fb 3a 05 33			ld a, (.dmark+2)  
32fe 32 6a fe			ld (debug_mark+2),a  
3301 18 03			jr .pastdmark  
3303 ..			.dmark: db "-2d"  
3306 f1			.pastdmark: pop af  
3307			endm  
# End of macro DMARK
3307						CALLMONITOR 
3307 cd 6c fe			call debug_vector  
330a				endm  
# End of macro CALLMONITOR
330a					endif 
330a			 
330a					; move result to de 
330a			 
330a eb					ex de, hl 
330b			 
330b					; Address 
330b			 
330b e1					pop hl 
330c			 
330c					; save it back 
330c			 
330c 73					ld (hl), e 
330d 23					inc hl 
330e 72					ld (hl), d 
330f			 
330f					if DEBUG_FORTH_WORDS 
330f						DMARK "-2e" 
330f f5				push af  
3310 3a 24 33			ld a, (.dmark)  
3313 32 68 fe			ld (debug_mark),a  
3316 3a 25 33			ld a, (.dmark+1)  
3319 32 69 fe			ld (debug_mark+1),a  
331c 3a 26 33			ld a, (.dmark+2)  
331f 32 6a fe			ld (debug_mark+2),a  
3322 18 03			jr .pastdmark  
3324 ..			.dmark: db "-2e"  
3327 f1			.pastdmark: pop af  
3328			endm  
# End of macro DMARK
3328						CALLMONITOR 
3328 cd 6c fe			call debug_vector  
332b				endm  
# End of macro CALLMONITOR
332b					endif 
332b			 
332b			 
332b			 
332b			 
332b			 
332b				       NEXTW 
332b c3 c2 24			jp macro_next 
332e				endm 
# End of macro NEXTW
332e			.GET2: 
332e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
332e 6f				db WORD_SYS_CORE+91             
332f 5e 33			dw .BANG2            
3331 03				db 2 + 1 
3332 .. 00			db "2@",0              
3335				endm 
# End of macro CWHEAD
3335			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3335					if DEBUG_FORTH_WORDS_KEY 
3335						DMARK "2A_" 
3335 f5				push af  
3336 3a 4a 33			ld a, (.dmark)  
3339 32 68 fe			ld (debug_mark),a  
333c 3a 4b 33			ld a, (.dmark+1)  
333f 32 69 fe			ld (debug_mark+1),a  
3342 3a 4c 33			ld a, (.dmark+2)  
3345 32 6a fe			ld (debug_mark+2),a  
3348 18 03			jr .pastdmark  
334a ..			.dmark: db "2A_"  
334d f1			.pastdmark: pop af  
334e			endm  
# End of macro DMARK
334e						CALLMONITOR 
334e cd 6c fe			call debug_vector  
3351				endm  
# End of macro CALLMONITOR
3351					endif 
3351			 
3351					FORTH_DSP_VALUEHL 
3351 cd 0c 23			call macro_dsp_valuehl 
3354				endm 
# End of macro FORTH_DSP_VALUEHL
3354			 
3354 5e					ld e, (hl) 
3355 23					inc hl 
3356 56					ld d, (hl) 
3357			 
3357 eb					ex de, hl 
3358			 
3358 cd 15 21				call forth_push_numhl 
335b			 
335b				       NEXTW 
335b c3 c2 24			jp macro_next 
335e				endm 
# End of macro NEXTW
335e			.BANG2: 
335e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
335e 6f				db WORD_SYS_CORE+91             
335f 96 33			dw .CONFIG            
3361 03				db 2 + 1 
3362 .. 00			db "2!",0              
3365				endm 
# End of macro CWHEAD
3365			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3365					if DEBUG_FORTH_WORDS_KEY 
3365						DMARK "2S_" 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 68 fe			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 69 fe			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 6a fe			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "2S_"  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd 6c fe			call debug_vector  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381			 
3381					FORTH_DSP_VALUEHL 
3381 cd 0c 23			call macro_dsp_valuehl 
3384				endm 
# End of macro FORTH_DSP_VALUEHL
3384			 
3384 e5					push hl   ; save address 
3385			 
3385			 
3385					FORTH_DSP_POP 
3385 cd c4 23			call macro_forth_dsp_pop 
3388				endm 
# End of macro FORTH_DSP_POP
3388			 
3388					 
3388					FORTH_DSP_VALUEHL 
3388 cd 0c 23			call macro_dsp_valuehl 
338b				endm 
# End of macro FORTH_DSP_VALUEHL
338b			 
338b					FORTH_DSP_POP 
338b cd c4 23			call macro_forth_dsp_pop 
338e				endm 
# End of macro FORTH_DSP_POP
338e			 
338e eb					ex de, hl    ; value now in de 
338f			 
338f e1					pop hl 
3390			 
3390 73					ld (hl), e 
3391			 
3391 23					inc hl 
3392			 
3392 72					ld (hl), d 
3393			 
3393			 
3393				       NEXTW 
3393 c3 c2 24			jp macro_next 
3396				endm 
# End of macro NEXTW
3396			.CONFIG: 
3396				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3396 6f				db WORD_SYS_CORE+91             
3397 a7 33			dw .ADTOS            
3399 07				db 6 + 1 
339a .. 00			db "CONFIG",0              
33a1				endm 
# End of macro CWHEAD
33a1			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
33a1			 
33a1 cd 30 16				call config 
33a4					NEXTW 
33a4 c3 c2 24			jp macro_next 
33a7				endm 
# End of macro NEXTW
33a7			 
33a7			.ADTOS: 
33a7				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
33a7 6f				db WORD_SYS_CORE+91             
33a8 bd 33			dw .SBTOS            
33aa 03				db 2 + 1 
33ab .. 00			db "1+",0              
33ae				endm 
# End of macro CWHEAD
33ae			; | 1+ ( u -- u )  Increment value on TOS | DONE 
33ae			 
33ae					FORTH_DSP_VALUEHL 
33ae cd 0c 23			call macro_dsp_valuehl 
33b1				endm 
# End of macro FORTH_DSP_VALUEHL
33b1 e5					push hl 
33b2			 
33b2					FORTH_DSP_POP 
33b2 cd c4 23			call macro_forth_dsp_pop 
33b5				endm 
# End of macro FORTH_DSP_POP
33b5 e1					pop hl 
33b6			 
33b6 23					inc hl 
33b7 cd 15 21				call forth_push_numhl 
33ba					 
33ba					NEXTW 
33ba c3 c2 24			jp macro_next 
33bd				endm 
# End of macro NEXTW
33bd			.SBTOS: 
33bd				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33bd 6f				db WORD_SYS_CORE+91             
33be d3 33			dw .ADSTORE            
33c0 03				db 2 + 1 
33c1 .. 00			db "1-",0              
33c4				endm 
# End of macro CWHEAD
33c4			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33c4			 
33c4					FORTH_DSP_VALUEHL 
33c4 cd 0c 23			call macro_dsp_valuehl 
33c7				endm 
# End of macro FORTH_DSP_VALUEHL
33c7 e5					push hl 
33c8			 
33c8					FORTH_DSP_POP 
33c8 cd c4 23			call macro_forth_dsp_pop 
33cb				endm 
# End of macro FORTH_DSP_POP
33cb e1					pop hl 
33cc			 
33cc 2b					dec hl 
33cd cd 15 21				call forth_push_numhl 
33d0					 
33d0					NEXTW 
33d0 c3 c2 24			jp macro_next 
33d3				endm 
# End of macro NEXTW
33d3			.ADSTORE: 
33d3				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33d3 6f				db WORD_SYS_CORE+91             
33d4 e9 33			dw .ADWSTORE            
33d6 04				db 3 + 1 
33d7 .. 00			db "1+!",0              
33db				endm 
# End of macro CWHEAD
33db			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33db			 
33db					FORTH_DSP_VALUEHL 
33db cd 0c 23			call macro_dsp_valuehl 
33de				endm 
# End of macro FORTH_DSP_VALUEHL
33de e5					push hl 
33df			 
33df					FORTH_DSP_POP 
33df cd c4 23			call macro_forth_dsp_pop 
33e2				endm 
# End of macro FORTH_DSP_POP
33e2 e1					pop hl 
33e3			 
33e3 7e					ld a, (hl) 
33e4 3c					inc a 
33e5 77					ld (hl), a 
33e6					 
33e6					NEXTW 
33e6 c3 c2 24			jp macro_next 
33e9				endm 
# End of macro NEXTW
33e9			.ADWSTORE: 
33e9				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
33e9 6f				db WORD_SYS_CORE+91             
33ea 07 34			dw .ENDCORE            
33ec 05				db 4 + 1 
33ed .. 00			db "1+2!",0              
33f2				endm 
# End of macro CWHEAD
33f2			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33f2			 
33f2					FORTH_DSP_VALUEHL 
33f2 cd 0c 23			call macro_dsp_valuehl 
33f5				endm 
# End of macro FORTH_DSP_VALUEHL
33f5 e5					push hl 
33f6			 
33f6					FORTH_DSP_POP 
33f6 cd c4 23			call macro_forth_dsp_pop 
33f9				endm 
# End of macro FORTH_DSP_POP
33f9 e1					pop hl 
33fa			 
33fa e5					push hl 
33fb			 
33fb cd 44 24				call loadwordinhl 
33fe 23					inc hl 
33ff			 
33ff d1					pop de 
3400 eb					ex de, hl 
3401 73					ld (hl), e 
3402 23					inc hl 
3403 72					ld (hl), d 
3404					 
3404					NEXTW 
3404 c3 c2 24			jp macro_next 
3407				endm 
# End of macro NEXTW
3407			.ENDCORE: 
3407			 
3407			; eof 
3407			 
3407			 
# End of file forth_words_core.asm
3407			include "forth_words_flow.asm" 
3407			 
3407			; | ## Program Flow Words 
3407			 
3407			.IF: 
3407				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3407 1e				db WORD_SYS_CORE+10             
3408 fc 34			dw .THEN            
340a 03				db 2 + 1 
340b .. 00			db "IF",0              
340e				endm 
# End of macro CWHEAD
340e			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
340e			; 
340e					if DEBUG_FORTH_WORDS_KEY 
340e						DMARK "IF." 
340e f5				push af  
340f 3a 23 34			ld a, (.dmark)  
3412 32 68 fe			ld (debug_mark),a  
3415 3a 24 34			ld a, (.dmark+1)  
3418 32 69 fe			ld (debug_mark+1),a  
341b 3a 25 34			ld a, (.dmark+2)  
341e 32 6a fe			ld (debug_mark+2),a  
3421 18 03			jr .pastdmark  
3423 ..			.dmark: db "IF."  
3426 f1			.pastdmark: pop af  
3427			endm  
# End of macro DMARK
3427						CALLMONITOR 
3427 cd 6c fe			call debug_vector  
342a				endm  
# End of macro CALLMONITOR
342a					endif 
342a			; eval TOS 
342a			 
342a				FORTH_DSP_VALUEHL 
342a cd 0c 23			call macro_dsp_valuehl 
342d				endm 
# End of macro FORTH_DSP_VALUEHL
342d			 
342d			;	push hl 
342d				FORTH_DSP_POP 
342d cd c4 23			call macro_forth_dsp_pop 
3430				endm 
# End of macro FORTH_DSP_POP
3430			;	pop hl 
3430			 
3430					if DEBUG_FORTH_WORDS 
3430						DMARK "IF1" 
3430 f5				push af  
3431 3a 45 34			ld a, (.dmark)  
3434 32 68 fe			ld (debug_mark),a  
3437 3a 46 34			ld a, (.dmark+1)  
343a 32 69 fe			ld (debug_mark+1),a  
343d 3a 47 34			ld a, (.dmark+2)  
3440 32 6a fe			ld (debug_mark+2),a  
3443 18 03			jr .pastdmark  
3445 ..			.dmark: db "IF1"  
3448 f1			.pastdmark: pop af  
3449			endm  
# End of macro DMARK
3449						CALLMONITOR 
3449 cd 6c fe			call debug_vector  
344c				endm  
# End of macro CALLMONITOR
344c					endif 
344c b7				or a        ; clear carry flag 
344d 11 00 00			ld de, 0 
3450 eb				ex de,hl 
3451 ed 52			sbc hl, de 
3453 c2 dd 34			jp nz, .iftrue 
3456			 
3456					if DEBUG_FORTH_WORDS 
3456						DMARK "IF2" 
3456 f5				push af  
3457 3a 6b 34			ld a, (.dmark)  
345a 32 68 fe			ld (debug_mark),a  
345d 3a 6c 34			ld a, (.dmark+1)  
3460 32 69 fe			ld (debug_mark+1),a  
3463 3a 6d 34			ld a, (.dmark+2)  
3466 32 6a fe			ld (debug_mark+2),a  
3469 18 03			jr .pastdmark  
346b ..			.dmark: db "IF2"  
346e f1			.pastdmark: pop af  
346f			endm  
# End of macro DMARK
346f						CALLMONITOR 
346f cd 6c fe			call debug_vector  
3472				endm  
# End of macro CALLMONITOR
3472					endif 
3472			 
3472			; if not true then skip to THEN 
3472			 
3472				; TODO get tok_ptr 
3472				; TODO consume toks until we get to THEN 
3472			 
3472 2a bf f4			ld hl, (os_tok_ptr) 
3475					if DEBUG_FORTH_WORDS 
3475						DMARK "IF3" 
3475 f5				push af  
3476 3a 8a 34			ld a, (.dmark)  
3479 32 68 fe			ld (debug_mark),a  
347c 3a 8b 34			ld a, (.dmark+1)  
347f 32 69 fe			ld (debug_mark+1),a  
3482 3a 8c 34			ld a, (.dmark+2)  
3485 32 6a fe			ld (debug_mark+2),a  
3488 18 03			jr .pastdmark  
348a ..			.dmark: db "IF3"  
348d f1			.pastdmark: pop af  
348e			endm  
# End of macro DMARK
348e						CALLMONITOR 
348e cd 6c fe			call debug_vector  
3491				endm  
# End of macro CALLMONITOR
3491						 
3491					endif 
3491 11 d8 34			ld de, .ifthen 
3494					if DEBUG_FORTH_WORDS 
3494						DMARK "IF4" 
3494 f5				push af  
3495 3a a9 34			ld a, (.dmark)  
3498 32 68 fe			ld (debug_mark),a  
349b 3a aa 34			ld a, (.dmark+1)  
349e 32 69 fe			ld (debug_mark+1),a  
34a1 3a ab 34			ld a, (.dmark+2)  
34a4 32 6a fe			ld (debug_mark+2),a  
34a7 18 03			jr .pastdmark  
34a9 ..			.dmark: db "IF4"  
34ac f1			.pastdmark: pop af  
34ad			endm  
# End of macro DMARK
34ad						CALLMONITOR 
34ad cd 6c fe			call debug_vector  
34b0				endm  
# End of macro CALLMONITOR
34b0					endif 
34b0 cd dd 25			call findnexttok  
34b3			 
34b3					if DEBUG_FORTH_WORDS 
34b3						DMARK "IF5" 
34b3 f5				push af  
34b4 3a c8 34			ld a, (.dmark)  
34b7 32 68 fe			ld (debug_mark),a  
34ba 3a c9 34			ld a, (.dmark+1)  
34bd 32 69 fe			ld (debug_mark+1),a  
34c0 3a ca 34			ld a, (.dmark+2)  
34c3 32 6a fe			ld (debug_mark+2),a  
34c6 18 03			jr .pastdmark  
34c8 ..			.dmark: db "IF5"  
34cb f1			.pastdmark: pop af  
34cc			endm  
# End of macro DMARK
34cc						CALLMONITOR 
34cc cd 6c fe			call debug_vector  
34cf				endm  
# End of macro CALLMONITOR
34cf					endif 
34cf				; TODO replace below with ; exec using tok_ptr 
34cf 22 bf f4			ld (os_tok_ptr), hl 
34d2 c3 53 25			jp exec1 
34d5				NEXTW 
34d5 c3 c2 24			jp macro_next 
34d8				endm 
# End of macro NEXTW
34d8			 
34d8 .. 00		.ifthen:  db "THEN",0 
34dd			 
34dd			.iftrue:		 
34dd				; Exec next words normally 
34dd			 
34dd				; if true then exec following IF as normal 
34dd					if DEBUG_FORTH_WORDS 
34dd						DMARK "IFT" 
34dd f5				push af  
34de 3a f2 34			ld a, (.dmark)  
34e1 32 68 fe			ld (debug_mark),a  
34e4 3a f3 34			ld a, (.dmark+1)  
34e7 32 69 fe			ld (debug_mark+1),a  
34ea 3a f4 34			ld a, (.dmark+2)  
34ed 32 6a fe			ld (debug_mark+2),a  
34f0 18 03			jr .pastdmark  
34f2 ..			.dmark: db "IFT"  
34f5 f1			.pastdmark: pop af  
34f6			endm  
# End of macro DMARK
34f6						CALLMONITOR 
34f6 cd 6c fe			call debug_vector  
34f9				endm  
# End of macro CALLMONITOR
34f9					endif 
34f9			 
34f9					NEXTW 
34f9 c3 c2 24			jp macro_next 
34fc				endm 
# End of macro NEXTW
34fc			.THEN: 
34fc				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
34fc 1f				db WORD_SYS_CORE+11             
34fd 24 35			dw .ELSE            
34ff 05				db 4 + 1 
3500 .. 00			db "THEN",0              
3505				endm 
# End of macro CWHEAD
3505			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3505					if DEBUG_FORTH_WORDS_KEY 
3505						DMARK "THN" 
3505 f5				push af  
3506 3a 1a 35			ld a, (.dmark)  
3509 32 68 fe			ld (debug_mark),a  
350c 3a 1b 35			ld a, (.dmark+1)  
350f 32 69 fe			ld (debug_mark+1),a  
3512 3a 1c 35			ld a, (.dmark+2)  
3515 32 6a fe			ld (debug_mark+2),a  
3518 18 03			jr .pastdmark  
351a ..			.dmark: db "THN"  
351d f1			.pastdmark: pop af  
351e			endm  
# End of macro DMARK
351e						CALLMONITOR 
351e cd 6c fe			call debug_vector  
3521				endm  
# End of macro CALLMONITOR
3521					endif 
3521					NEXTW 
3521 c3 c2 24			jp macro_next 
3524				endm 
# End of macro NEXTW
3524			.ELSE: 
3524				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3524 20				db WORD_SYS_CORE+12             
3525 4c 35			dw .DO            
3527 03				db 2 + 1 
3528 .. 00			db "ELSE",0              
352d				endm 
# End of macro CWHEAD
352d			; | ELSE ( -- ) Not supported - does nothing | TODO 
352d			 
352d					if DEBUG_FORTH_WORDS_KEY 
352d						DMARK "ELS" 
352d f5				push af  
352e 3a 42 35			ld a, (.dmark)  
3531 32 68 fe			ld (debug_mark),a  
3534 3a 43 35			ld a, (.dmark+1)  
3537 32 69 fe			ld (debug_mark+1),a  
353a 3a 44 35			ld a, (.dmark+2)  
353d 32 6a fe			ld (debug_mark+2),a  
3540 18 03			jr .pastdmark  
3542 ..			.dmark: db "ELS"  
3545 f1			.pastdmark: pop af  
3546			endm  
# End of macro DMARK
3546						CALLMONITOR 
3546 cd 6c fe			call debug_vector  
3549				endm  
# End of macro CALLMONITOR
3549					endif 
3549			 
3549			 
3549					NEXTW 
3549 c3 c2 24			jp macro_next 
354c				endm 
# End of macro NEXTW
354c			.DO: 
354c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
354c 21				db WORD_SYS_CORE+13             
354d 73 36			dw .LOOP            
354f 03				db 2 + 1 
3550 .. 00			db "DO",0              
3553				endm 
# End of macro CWHEAD
3553			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3553			 
3553					if DEBUG_FORTH_WORDS_KEY 
3553						DMARK "DO." 
3553 f5				push af  
3554 3a 68 35			ld a, (.dmark)  
3557 32 68 fe			ld (debug_mark),a  
355a 3a 69 35			ld a, (.dmark+1)  
355d 32 69 fe			ld (debug_mark+1),a  
3560 3a 6a 35			ld a, (.dmark+2)  
3563 32 6a fe			ld (debug_mark+2),a  
3566 18 03			jr .pastdmark  
3568 ..			.dmark: db "DO."  
356b f1			.pastdmark: pop af  
356c			endm  
# End of macro DMARK
356c						CALLMONITOR 
356c cd 6c fe			call debug_vector  
356f				endm  
# End of macro CALLMONITOR
356f					endif 
356f			;  push pc to rsp stack past the DO 
356f			 
356f 2a bf f4				ld hl, (os_tok_ptr) 
3572 23					inc hl   ; D 
3573 23					inc hl  ; O 
3574 23					inc hl   ; null 
3575					if DEBUG_FORTH_WORDS 
3575						DMARK "DO2" 
3575 f5				push af  
3576 3a 8a 35			ld a, (.dmark)  
3579 32 68 fe			ld (debug_mark),a  
357c 3a 8b 35			ld a, (.dmark+1)  
357f 32 69 fe			ld (debug_mark+1),a  
3582 3a 8c 35			ld a, (.dmark+2)  
3585 32 6a fe			ld (debug_mark+2),a  
3588 18 03			jr .pastdmark  
358a ..			.dmark: db "DO2"  
358d f1			.pastdmark: pop af  
358e			endm  
# End of macro DMARK
358e						CALLMONITOR 
358e cd 6c fe			call debug_vector  
3591				endm  
# End of macro CALLMONITOR
3591					endif 
3591					FORTH_RSP_NEXT 
3591 cd bc 20			call macro_forth_rsp_next 
3594				endm 
# End of macro FORTH_RSP_NEXT
3594					if DEBUG_FORTH_WORDS 
3594						DMARK "DO3" 
3594 f5				push af  
3595 3a a9 35			ld a, (.dmark)  
3598 32 68 fe			ld (debug_mark),a  
359b 3a aa 35			ld a, (.dmark+1)  
359e 32 69 fe			ld (debug_mark+1),a  
35a1 3a ab 35			ld a, (.dmark+2)  
35a4 32 6a fe			ld (debug_mark+2),a  
35a7 18 03			jr .pastdmark  
35a9 ..			.dmark: db "DO3"  
35ac f1			.pastdmark: pop af  
35ad			endm  
# End of macro DMARK
35ad						CALLMONITOR 
35ad cd 6c fe			call debug_vector  
35b0				endm  
# End of macro CALLMONITOR
35b0					endif 
35b0			 
35b0					;if DEBUG_FORTH_WORDS 
35b0				;		push hl 
35b0			;		endif  
35b0			 
35b0			; get counters from data stack 
35b0			 
35b0			 
35b0					FORTH_DSP_VALUEHL 
35b0 cd 0c 23			call macro_dsp_valuehl 
35b3				endm 
# End of macro FORTH_DSP_VALUEHL
35b3 e5					push hl		 ; hl now has starting counter which needs to be tos 
35b4			 
35b4					if DEBUG_FORTH_WORDS 
35b4						DMARK "DO4" 
35b4 f5				push af  
35b5 3a c9 35			ld a, (.dmark)  
35b8 32 68 fe			ld (debug_mark),a  
35bb 3a ca 35			ld a, (.dmark+1)  
35be 32 69 fe			ld (debug_mark+1),a  
35c1 3a cb 35			ld a, (.dmark+2)  
35c4 32 6a fe			ld (debug_mark+2),a  
35c7 18 03			jr .pastdmark  
35c9 ..			.dmark: db "DO4"  
35cc f1			.pastdmark: pop af  
35cd			endm  
# End of macro DMARK
35cd						CALLMONITOR 
35cd cd 6c fe			call debug_vector  
35d0				endm  
# End of macro CALLMONITOR
35d0					endif 
35d0					FORTH_DSP_POP 
35d0 cd c4 23			call macro_forth_dsp_pop 
35d3				endm 
# End of macro FORTH_DSP_POP
35d3			 
35d3					if DEBUG_FORTH_WORDS 
35d3						DMARK "DO5" 
35d3 f5				push af  
35d4 3a e8 35			ld a, (.dmark)  
35d7 32 68 fe			ld (debug_mark),a  
35da 3a e9 35			ld a, (.dmark+1)  
35dd 32 69 fe			ld (debug_mark+1),a  
35e0 3a ea 35			ld a, (.dmark+2)  
35e3 32 6a fe			ld (debug_mark+2),a  
35e6 18 03			jr .pastdmark  
35e8 ..			.dmark: db "DO5"  
35eb f1			.pastdmark: pop af  
35ec			endm  
# End of macro DMARK
35ec						CALLMONITOR 
35ec cd 6c fe			call debug_vector  
35ef				endm  
# End of macro CALLMONITOR
35ef					endif 
35ef			 
35ef					FORTH_DSP_VALUEHL 
35ef cd 0c 23			call macro_dsp_valuehl 
35f2				endm 
# End of macro FORTH_DSP_VALUEHL
35f2			;		push hl		 ; hl now has starting limit counter 
35f2			 
35f2					if DEBUG_FORTH_WORDS 
35f2						DMARK "DO6" 
35f2 f5				push af  
35f3 3a 07 36			ld a, (.dmark)  
35f6 32 68 fe			ld (debug_mark),a  
35f9 3a 08 36			ld a, (.dmark+1)  
35fc 32 69 fe			ld (debug_mark+1),a  
35ff 3a 09 36			ld a, (.dmark+2)  
3602 32 6a fe			ld (debug_mark+2),a  
3605 18 03			jr .pastdmark  
3607 ..			.dmark: db "DO6"  
360a f1			.pastdmark: pop af  
360b			endm  
# End of macro DMARK
360b						CALLMONITOR 
360b cd 6c fe			call debug_vector  
360e				endm  
# End of macro CALLMONITOR
360e					endif 
360e					FORTH_DSP_POP 
360e cd c4 23			call macro_forth_dsp_pop 
3611				endm 
# End of macro FORTH_DSP_POP
3611			 
3611			; put counters on the loop stack 
3611			 
3611			;		pop hl			 ; limit counter 
3611 d1					pop de			; start counter 
3612			 
3612					; push limit counter 
3612			 
3612					if DEBUG_FORTH_WORDS 
3612						DMARK "DO7" 
3612 f5				push af  
3613 3a 27 36			ld a, (.dmark)  
3616 32 68 fe			ld (debug_mark),a  
3619 3a 28 36			ld a, (.dmark+1)  
361c 32 69 fe			ld (debug_mark+1),a  
361f 3a 29 36			ld a, (.dmark+2)  
3622 32 6a fe			ld (debug_mark+2),a  
3625 18 03			jr .pastdmark  
3627 ..			.dmark: db "DO7"  
362a f1			.pastdmark: pop af  
362b			endm  
# End of macro DMARK
362b						CALLMONITOR 
362b cd 6c fe			call debug_vector  
362e				endm  
# End of macro CALLMONITOR
362e					endif 
362e					FORTH_LOOP_NEXT 
362e cd 3d 23			call macro_forth_loop_next 
3631				endm 
# End of macro FORTH_LOOP_NEXT
3631			 
3631					; push start counter 
3631			 
3631 eb					ex de, hl 
3632					if DEBUG_FORTH_WORDS 
3632						DMARK "DO7" 
3632 f5				push af  
3633 3a 47 36			ld a, (.dmark)  
3636 32 68 fe			ld (debug_mark),a  
3639 3a 48 36			ld a, (.dmark+1)  
363c 32 69 fe			ld (debug_mark+1),a  
363f 3a 49 36			ld a, (.dmark+2)  
3642 32 6a fe			ld (debug_mark+2),a  
3645 18 03			jr .pastdmark  
3647 ..			.dmark: db "DO7"  
364a f1			.pastdmark: pop af  
364b			endm  
# End of macro DMARK
364b						CALLMONITOR 
364b cd 6c fe			call debug_vector  
364e				endm  
# End of macro CALLMONITOR
364e					endif 
364e					FORTH_LOOP_NEXT 
364e cd 3d 23			call macro_forth_loop_next 
3651				endm 
# End of macro FORTH_LOOP_NEXT
3651			 
3651			 
3651					; init first round of I counter 
3651			 
3651 22 e3 f4				ld (os_current_i), hl 
3654			 
3654					if DEBUG_FORTH_WORDS 
3654						DMARK "DO8" 
3654 f5				push af  
3655 3a 69 36			ld a, (.dmark)  
3658 32 68 fe			ld (debug_mark),a  
365b 3a 6a 36			ld a, (.dmark+1)  
365e 32 69 fe			ld (debug_mark+1),a  
3661 3a 6b 36			ld a, (.dmark+2)  
3664 32 6a fe			ld (debug_mark+2),a  
3667 18 03			jr .pastdmark  
3669 ..			.dmark: db "DO8"  
366c f1			.pastdmark: pop af  
366d			endm  
# End of macro DMARK
366d						CALLMONITOR 
366d cd 6c fe			call debug_vector  
3670				endm  
# End of macro CALLMONITOR
3670					endif 
3670			 
3670					NEXTW 
3670 c3 c2 24			jp macro_next 
3673				endm 
# End of macro NEXTW
3673			.LOOP: 
3673				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3673 22				db WORD_SYS_CORE+14             
3674 8b 37			dw .I            
3676 05				db 4 + 1 
3677 .. 00			db "LOOP",0              
367c				endm 
# End of macro CWHEAD
367c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
367c			 
367c				; pop tos as current loop count to hl 
367c			 
367c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
367c			 
367c				FORTH_LOOP_TOS 
367c cd 70 23			call macro_forth_loop_tos 
367f				endm 
# End of macro FORTH_LOOP_TOS
367f e5				push hl 
3680			 
3680					if DEBUG_FORTH_WORDS_KEY 
3680						DMARK "LOP" 
3680 f5				push af  
3681 3a 95 36			ld a, (.dmark)  
3684 32 68 fe			ld (debug_mark),a  
3687 3a 96 36			ld a, (.dmark+1)  
368a 32 69 fe			ld (debug_mark+1),a  
368d 3a 97 36			ld a, (.dmark+2)  
3690 32 6a fe			ld (debug_mark+2),a  
3693 18 03			jr .pastdmark  
3695 ..			.dmark: db "LOP"  
3698 f1			.pastdmark: pop af  
3699			endm  
# End of macro DMARK
3699						CALLMONITOR 
3699 cd 6c fe			call debug_vector  
369c				endm  
# End of macro CALLMONITOR
369c					endif 
369c				; next item on the stack is the limit. get it 
369c			 
369c			 
369c				FORTH_LOOP_POP 
369c cd 7a 23			call macro_forth_loop_pop 
369f				endm 
# End of macro FORTH_LOOP_POP
369f			 
369f				FORTH_LOOP_TOS 
369f cd 70 23			call macro_forth_loop_tos 
36a2				endm 
# End of macro FORTH_LOOP_TOS
36a2			 
36a2 d1				pop de		 ; de = i, hl = limit 
36a3			 
36a3					if DEBUG_FORTH_WORDS 
36a3						DMARK "LP1" 
36a3 f5				push af  
36a4 3a b8 36			ld a, (.dmark)  
36a7 32 68 fe			ld (debug_mark),a  
36aa 3a b9 36			ld a, (.dmark+1)  
36ad 32 69 fe			ld (debug_mark+1),a  
36b0 3a ba 36			ld a, (.dmark+2)  
36b3 32 6a fe			ld (debug_mark+2),a  
36b6 18 03			jr .pastdmark  
36b8 ..			.dmark: db "LP1"  
36bb f1			.pastdmark: pop af  
36bc			endm  
# End of macro DMARK
36bc						CALLMONITOR 
36bc cd 6c fe			call debug_vector  
36bf				endm  
# End of macro CALLMONITOR
36bf					endif 
36bf			 
36bf				; go back to previous word 
36bf			 
36bf d5				push de    ; save I for inc later 
36c0			 
36c0			 
36c0				; get limit 
36c0				;  is I at limit? 
36c0			 
36c0			 
36c0					if DEBUG_FORTH_WORDS 
36c0						DMARK "LP1" 
36c0 f5				push af  
36c1 3a d5 36			ld a, (.dmark)  
36c4 32 68 fe			ld (debug_mark),a  
36c7 3a d6 36			ld a, (.dmark+1)  
36ca 32 69 fe			ld (debug_mark+1),a  
36cd 3a d7 36			ld a, (.dmark+2)  
36d0 32 6a fe			ld (debug_mark+2),a  
36d3 18 03			jr .pastdmark  
36d5 ..			.dmark: db "LP1"  
36d8 f1			.pastdmark: pop af  
36d9			endm  
# End of macro DMARK
36d9						CALLMONITOR 
36d9 cd 6c fe			call debug_vector  
36dc				endm  
# End of macro CALLMONITOR
36dc					endif 
36dc			 
36dc ed 52			sbc hl, de 
36de			 
36de			 
36de				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
36de			 
36de 20 26				jr nz, .loopnotdone 
36e0			 
36e0 e1				pop hl   ; get rid of saved I 
36e1				FORTH_LOOP_POP     ; get rid of limit 
36e1 cd 7a 23			call macro_forth_loop_pop 
36e4				endm 
# End of macro FORTH_LOOP_POP
36e4			 
36e4				FORTH_RSP_POP     ; get rid of DO ptr 
36e4 cd dd 20			call macro_forth_rsp_pop 
36e7				endm 
# End of macro FORTH_RSP_POP
36e7			 
36e7			if DEBUG_FORTH_WORDS 
36e7						DMARK "LP>" 
36e7 f5				push af  
36e8 3a fc 36			ld a, (.dmark)  
36eb 32 68 fe			ld (debug_mark),a  
36ee 3a fd 36			ld a, (.dmark+1)  
36f1 32 69 fe			ld (debug_mark+1),a  
36f4 3a fe 36			ld a, (.dmark+2)  
36f7 32 6a fe			ld (debug_mark+2),a  
36fa 18 03			jr .pastdmark  
36fc ..			.dmark: db "LP>"  
36ff f1			.pastdmark: pop af  
3700			endm  
# End of macro DMARK
3700				CALLMONITOR 
3700 cd 6c fe			call debug_vector  
3703				endm  
# End of macro CALLMONITOR
3703			endif 
3703			 
3703					NEXTW 
3703 c3 c2 24			jp macro_next 
3706				endm 
# End of macro NEXTW
3706				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3706			 
3706			.loopnotdone: 
3706			 
3706 e1				pop hl    ; get I 
3707 23				inc hl 
3708			 
3708			   	; save new I 
3708			 
3708			 
3708					; set I counter 
3708			 
3708 22 e3 f4				ld (os_current_i), hl 
370b			 
370b					if DEBUG_FORTH_WORDS 
370b						DMARK "LPN" 
370b f5				push af  
370c 3a 20 37			ld a, (.dmark)  
370f 32 68 fe			ld (debug_mark),a  
3712 3a 21 37			ld a, (.dmark+1)  
3715 32 69 fe			ld (debug_mark+1),a  
3718 3a 22 37			ld a, (.dmark+2)  
371b 32 6a fe			ld (debug_mark+2),a  
371e 18 03			jr .pastdmark  
3720 ..			.dmark: db "LPN"  
3723 f1			.pastdmark: pop af  
3724			endm  
# End of macro DMARK
3724					CALLMONITOR 
3724 cd 6c fe			call debug_vector  
3727				endm  
# End of macro CALLMONITOR
3727					endif 
3727					 
3727				FORTH_LOOP_NEXT 
3727 cd 3d 23			call macro_forth_loop_next 
372a				endm 
# End of macro FORTH_LOOP_NEXT
372a			 
372a			 
372a					if DEBUG_FORTH_WORDS 
372a eb						ex de,hl 
372b					endif 
372b			 
372b			;	; get DO ptr 
372b			; 
372b					if DEBUG_FORTH_WORDS 
372b						DMARK "LP7" 
372b f5				push af  
372c 3a 40 37			ld a, (.dmark)  
372f 32 68 fe			ld (debug_mark),a  
3732 3a 41 37			ld a, (.dmark+1)  
3735 32 69 fe			ld (debug_mark+1),a  
3738 3a 42 37			ld a, (.dmark+2)  
373b 32 6a fe			ld (debug_mark+2),a  
373e 18 03			jr .pastdmark  
3740 ..			.dmark: db "LP7"  
3743 f1			.pastdmark: pop af  
3744			endm  
# End of macro DMARK
3744					CALLMONITOR 
3744 cd 6c fe			call debug_vector  
3747				endm  
# End of macro CALLMONITOR
3747					endif 
3747				FORTH_RSP_TOS 
3747 cd d3 20			call macro_forth_rsp_tos 
374a				endm 
# End of macro FORTH_RSP_TOS
374a			 
374a					if DEBUG_FORTH_WORDS 
374a						DMARK "LP8" 
374a f5				push af  
374b 3a 5f 37			ld a, (.dmark)  
374e 32 68 fe			ld (debug_mark),a  
3751 3a 60 37			ld a, (.dmark+1)  
3754 32 69 fe			ld (debug_mark+1),a  
3757 3a 61 37			ld a, (.dmark+2)  
375a 32 6a fe			ld (debug_mark+2),a  
375d 18 03			jr .pastdmark  
375f ..			.dmark: db "LP8"  
3762 f1			.pastdmark: pop af  
3763			endm  
# End of macro DMARK
3763					CALLMONITOR 
3763 cd 6c fe			call debug_vector  
3766				endm  
# End of macro CALLMONITOR
3766					endif 
3766				;push hl 
3766			 
3766				; not going to DO any more 
3766				; get rid of the RSP pointer as DO will add it back in 
3766				;FORTH_RSP_POP 
3766				;pop hl 
3766			 
3766				;ld hl,(cli_ret_sp) 
3766				;ld e, (hl) 
3766				;inc hl 
3766				;ld d, (hl) 
3766				;ex de,hl 
3766 22 bf f4			ld (os_tok_ptr), hl 
3769					if DEBUG_FORTH_WORDS 
3769						DMARK "LP<" 
3769 f5				push af  
376a 3a 7e 37			ld a, (.dmark)  
376d 32 68 fe			ld (debug_mark),a  
3770 3a 7f 37			ld a, (.dmark+1)  
3773 32 69 fe			ld (debug_mark+1),a  
3776 3a 80 37			ld a, (.dmark+2)  
3779 32 6a fe			ld (debug_mark+2),a  
377c 18 03			jr .pastdmark  
377e ..			.dmark: db "LP<"  
3781 f1			.pastdmark: pop af  
3782			endm  
# End of macro DMARK
3782					CALLMONITOR 
3782 cd 6c fe			call debug_vector  
3785				endm  
# End of macro CALLMONITOR
3785				endif 
3785 c3 53 25			jp exec1 
3788			 
3788					 
3788			 
3788			 
3788					NEXTW 
3788 c3 c2 24			jp macro_next 
378b				endm 
# End of macro NEXTW
378b			.I:  
378b			 
378b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
378b 5e				db WORD_SYS_CORE+74             
378c b6 37			dw .DLOOP            
378e 02				db 1 + 1 
378f .. 00			db "I",0              
3791				endm 
# End of macro CWHEAD
3791			; | I ( -- ) Current loop counter | DONE 
3791					if DEBUG_FORTH_WORDS_KEY 
3791						DMARK "I.." 
3791 f5				push af  
3792 3a a6 37			ld a, (.dmark)  
3795 32 68 fe			ld (debug_mark),a  
3798 3a a7 37			ld a, (.dmark+1)  
379b 32 69 fe			ld (debug_mark+1),a  
379e 3a a8 37			ld a, (.dmark+2)  
37a1 32 6a fe			ld (debug_mark+2),a  
37a4 18 03			jr .pastdmark  
37a6 ..			.dmark: db "I.."  
37a9 f1			.pastdmark: pop af  
37aa			endm  
# End of macro DMARK
37aa						CALLMONITOR 
37aa cd 6c fe			call debug_vector  
37ad				endm  
# End of macro CALLMONITOR
37ad					endif 
37ad			 
37ad 2a e3 f4				ld hl,(os_current_i) 
37b0 cd 15 21				call forth_push_numhl 
37b3			 
37b3					NEXTW 
37b3 c3 c2 24			jp macro_next 
37b6				endm 
# End of macro NEXTW
37b6			.DLOOP: 
37b6				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37b6 5f				db WORD_SYS_CORE+75             
37b7 97 38			dw .REPEAT            
37b9 06				db 5 + 1 
37ba .. 00			db "-LOOP",0              
37c0				endm 
# End of macro CWHEAD
37c0			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37c0				; pop tos as current loop count to hl 
37c0					if DEBUG_FORTH_WORDS_KEY 
37c0						DMARK "-LP" 
37c0 f5				push af  
37c1 3a d5 37			ld a, (.dmark)  
37c4 32 68 fe			ld (debug_mark),a  
37c7 3a d6 37			ld a, (.dmark+1)  
37ca 32 69 fe			ld (debug_mark+1),a  
37cd 3a d7 37			ld a, (.dmark+2)  
37d0 32 6a fe			ld (debug_mark+2),a  
37d3 18 03			jr .pastdmark  
37d5 ..			.dmark: db "-LP"  
37d8 f1			.pastdmark: pop af  
37d9			endm  
# End of macro DMARK
37d9						CALLMONITOR 
37d9 cd 6c fe			call debug_vector  
37dc				endm  
# End of macro CALLMONITOR
37dc					endif 
37dc			 
37dc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
37dc			 
37dc				FORTH_LOOP_TOS 
37dc cd 70 23			call macro_forth_loop_tos 
37df				endm 
# End of macro FORTH_LOOP_TOS
37df e5				push hl 
37e0			 
37e0					if DEBUG_FORTH_WORDS 
37e0						DMARK "-LP" 
37e0 f5				push af  
37e1 3a f5 37			ld a, (.dmark)  
37e4 32 68 fe			ld (debug_mark),a  
37e7 3a f6 37			ld a, (.dmark+1)  
37ea 32 69 fe			ld (debug_mark+1),a  
37ed 3a f7 37			ld a, (.dmark+2)  
37f0 32 6a fe			ld (debug_mark+2),a  
37f3 18 03			jr .pastdmark  
37f5 ..			.dmark: db "-LP"  
37f8 f1			.pastdmark: pop af  
37f9			endm  
# End of macro DMARK
37f9						CALLMONITOR 
37f9 cd 6c fe			call debug_vector  
37fc				endm  
# End of macro CALLMONITOR
37fc					endif 
37fc				; next item on the stack is the limit. get it 
37fc			 
37fc			 
37fc				FORTH_LOOP_POP 
37fc cd 7a 23			call macro_forth_loop_pop 
37ff				endm 
# End of macro FORTH_LOOP_POP
37ff			 
37ff				FORTH_LOOP_TOS 
37ff cd 70 23			call macro_forth_loop_tos 
3802				endm 
# End of macro FORTH_LOOP_TOS
3802			 
3802 d1				pop de		 ; de = i, hl = limit 
3803			 
3803					if DEBUG_FORTH_WORDS 
3803						DMARK "-L1" 
3803 f5				push af  
3804 3a 18 38			ld a, (.dmark)  
3807 32 68 fe			ld (debug_mark),a  
380a 3a 19 38			ld a, (.dmark+1)  
380d 32 69 fe			ld (debug_mark+1),a  
3810 3a 1a 38			ld a, (.dmark+2)  
3813 32 6a fe			ld (debug_mark+2),a  
3816 18 03			jr .pastdmark  
3818 ..			.dmark: db "-L1"  
381b f1			.pastdmark: pop af  
381c			endm  
# End of macro DMARK
381c						CALLMONITOR 
381c cd 6c fe			call debug_vector  
381f				endm  
# End of macro CALLMONITOR
381f					endif 
381f			 
381f				; go back to previous word 
381f			 
381f d5				push de    ; save I for inc later 
3820			 
3820			 
3820				; get limit 
3820				;  is I at limit? 
3820			 
3820			 
3820					if DEBUG_FORTH_WORDS 
3820						DMARK "-L1" 
3820 f5				push af  
3821 3a 35 38			ld a, (.dmark)  
3824 32 68 fe			ld (debug_mark),a  
3827 3a 36 38			ld a, (.dmark+1)  
382a 32 69 fe			ld (debug_mark+1),a  
382d 3a 37 38			ld a, (.dmark+2)  
3830 32 6a fe			ld (debug_mark+2),a  
3833 18 03			jr .pastdmark  
3835 ..			.dmark: db "-L1"  
3838 f1			.pastdmark: pop af  
3839			endm  
# End of macro DMARK
3839						CALLMONITOR 
3839 cd 6c fe			call debug_vector  
383c				endm  
# End of macro CALLMONITOR
383c					endif 
383c			 
383c ed 52			sbc hl, de 
383e			 
383e			 
383e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
383e			 
383e 20 26				jr nz, .mloopnotdone 
3840			 
3840 e1				pop hl   ; get rid of saved I 
3841				FORTH_LOOP_POP     ; get rid of limit 
3841 cd 7a 23			call macro_forth_loop_pop 
3844				endm 
# End of macro FORTH_LOOP_POP
3844			 
3844				FORTH_RSP_POP     ; get rid of DO ptr 
3844 cd dd 20			call macro_forth_rsp_pop 
3847				endm 
# End of macro FORTH_RSP_POP
3847			 
3847			if DEBUG_FORTH_WORDS 
3847						DMARK "-L>" 
3847 f5				push af  
3848 3a 5c 38			ld a, (.dmark)  
384b 32 68 fe			ld (debug_mark),a  
384e 3a 5d 38			ld a, (.dmark+1)  
3851 32 69 fe			ld (debug_mark+1),a  
3854 3a 5e 38			ld a, (.dmark+2)  
3857 32 6a fe			ld (debug_mark+2),a  
385a 18 03			jr .pastdmark  
385c ..			.dmark: db "-L>"  
385f f1			.pastdmark: pop af  
3860			endm  
# End of macro DMARK
3860				CALLMONITOR 
3860 cd 6c fe			call debug_vector  
3863				endm  
# End of macro CALLMONITOR
3863			endif 
3863			 
3863					NEXTW 
3863 c3 c2 24			jp macro_next 
3866				endm 
# End of macro NEXTW
3866				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3866			 
3866			.mloopnotdone: 
3866			 
3866 e1				pop hl    ; get I 
3867 2b				dec hl 
3868			 
3868			   	; save new I 
3868			 
3868			 
3868					; set I counter 
3868			 
3868 22 e3 f4				ld (os_current_i), hl 
386b			 
386b					 
386b				FORTH_LOOP_NEXT 
386b cd 3d 23			call macro_forth_loop_next 
386e				endm 
# End of macro FORTH_LOOP_NEXT
386e			 
386e			 
386e					if DEBUG_FORTH_WORDS 
386e eb						ex de,hl 
386f					endif 
386f			 
386f			;	; get DO ptr 
386f			; 
386f				FORTH_RSP_TOS 
386f cd d3 20			call macro_forth_rsp_tos 
3872				endm 
# End of macro FORTH_RSP_TOS
3872			 
3872				;push hl 
3872			 
3872				; not going to DO any more 
3872				; get rid of the RSP pointer as DO will add it back in 
3872				;FORTH_RSP_POP 
3872				;pop hl 
3872			 
3872			 
3872 22 bf f4			ld (os_tok_ptr), hl 
3875					if DEBUG_FORTH_WORDS 
3875						DMARK "-L<" 
3875 f5				push af  
3876 3a 8a 38			ld a, (.dmark)  
3879 32 68 fe			ld (debug_mark),a  
387c 3a 8b 38			ld a, (.dmark+1)  
387f 32 69 fe			ld (debug_mark+1),a  
3882 3a 8c 38			ld a, (.dmark+2)  
3885 32 6a fe			ld (debug_mark+2),a  
3888 18 03			jr .pastdmark  
388a ..			.dmark: db "-L<"  
388d f1			.pastdmark: pop af  
388e			endm  
# End of macro DMARK
388e					CALLMONITOR 
388e cd 6c fe			call debug_vector  
3891				endm  
# End of macro CALLMONITOR
3891				endif 
3891 c3 53 25			jp exec1 
3894			 
3894					 
3894			 
3894			 
3894			 
3894				NEXTW 
3894 c3 c2 24			jp macro_next 
3897				endm 
# End of macro NEXTW
3897			 
3897			 
3897			 
3897			 
3897			.REPEAT: 
3897				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3897 71				db WORD_SYS_CORE+93             
3898 ea 38			dw .UNTIL            
389a 06				db 5 + 1 
389b .. 00			db "REPEAT",0              
38a2				endm 
# End of macro CWHEAD
38a2			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
38a2			;  push pc to rsp stack past the REPEAT 
38a2					if DEBUG_FORTH_WORDS_KEY 
38a2						DMARK "REP" 
38a2 f5				push af  
38a3 3a b7 38			ld a, (.dmark)  
38a6 32 68 fe			ld (debug_mark),a  
38a9 3a b8 38			ld a, (.dmark+1)  
38ac 32 69 fe			ld (debug_mark+1),a  
38af 3a b9 38			ld a, (.dmark+2)  
38b2 32 6a fe			ld (debug_mark+2),a  
38b5 18 03			jr .pastdmark  
38b7 ..			.dmark: db "REP"  
38ba f1			.pastdmark: pop af  
38bb			endm  
# End of macro DMARK
38bb						CALLMONITOR 
38bb cd 6c fe			call debug_vector  
38be				endm  
# End of macro CALLMONITOR
38be					endif 
38be			 
38be 2a bf f4				ld hl, (os_tok_ptr) 
38c1 23					inc hl   ; R 
38c2 23					inc hl  ; E 
38c3 23					inc hl   ; P 
38c4 23					inc hl   ; E 
38c5 23					inc hl   ; A 
38c6 23					inc hl   ; T 
38c7 23					inc hl   ; zero 
38c8					FORTH_RSP_NEXT 
38c8 cd bc 20			call macro_forth_rsp_next 
38cb				endm 
# End of macro FORTH_RSP_NEXT
38cb			 
38cb			 
38cb					if DEBUG_FORTH_WORDS 
38cb						DMARK "REP" 
38cb f5				push af  
38cc 3a e0 38			ld a, (.dmark)  
38cf 32 68 fe			ld (debug_mark),a  
38d2 3a e1 38			ld a, (.dmark+1)  
38d5 32 69 fe			ld (debug_mark+1),a  
38d8 3a e2 38			ld a, (.dmark+2)  
38db 32 6a fe			ld (debug_mark+2),a  
38de 18 03			jr .pastdmark  
38e0 ..			.dmark: db "REP"  
38e3 f1			.pastdmark: pop af  
38e4			endm  
# End of macro DMARK
38e4						;pop bc    ; TODO BUG ?????? what is this for???? 
38e4						CALLMONITOR 
38e4 cd 6c fe			call debug_vector  
38e7				endm  
# End of macro CALLMONITOR
38e7					endif 
38e7			 
38e7					NEXTW 
38e7 c3 c2 24			jp macro_next 
38ea				endm 
# End of macro NEXTW
38ea			;	       NEXTW 
38ea			 
38ea			.UNTIL: 
38ea				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
38ea 72				db WORD_SYS_CORE+94             
38eb 81 39			dw .ENDFLOW            
38ed 06				db 5 + 1 
38ee .. 00			db "UNTIL",0              
38f4				endm 
# End of macro CWHEAD
38f4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
38f4			 
38f4				; pop tos as check 
38f4			 
38f4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38f4			 
38f4				FORTH_DSP_VALUEHL 
38f4 cd 0c 23			call macro_dsp_valuehl 
38f7				endm 
# End of macro FORTH_DSP_VALUEHL
38f7			 
38f7					if DEBUG_FORTH_WORDS_KEY 
38f7						DMARK "UNT" 
38f7 f5				push af  
38f8 3a 0c 39			ld a, (.dmark)  
38fb 32 68 fe			ld (debug_mark),a  
38fe 3a 0d 39			ld a, (.dmark+1)  
3901 32 69 fe			ld (debug_mark+1),a  
3904 3a 0e 39			ld a, (.dmark+2)  
3907 32 6a fe			ld (debug_mark+2),a  
390a 18 03			jr .pastdmark  
390c ..			.dmark: db "UNT"  
390f f1			.pastdmark: pop af  
3910			endm  
# End of macro DMARK
3910						CALLMONITOR 
3910 cd 6c fe			call debug_vector  
3913				endm  
# End of macro CALLMONITOR
3913					endif 
3913			 
3913			;	push hl 
3913				FORTH_DSP_POP 
3913 cd c4 23			call macro_forth_dsp_pop 
3916				endm 
# End of macro FORTH_DSP_POP
3916			 
3916			;	pop hl 
3916			 
3916				; test if true 
3916			 
3916 cd f9 0f			call ishlzero 
3919			;	ld a,l 
3919			;	add h 
3919			; 
3919			;	cp 0 
3919			 
3919 20 3e			jr nz, .untilnotdone 
391b			 
391b					if DEBUG_FORTH_WORDS 
391b						DMARK "UNf" 
391b f5				push af  
391c 3a 30 39			ld a, (.dmark)  
391f 32 68 fe			ld (debug_mark),a  
3922 3a 31 39			ld a, (.dmark+1)  
3925 32 69 fe			ld (debug_mark+1),a  
3928 3a 32 39			ld a, (.dmark+2)  
392b 32 6a fe			ld (debug_mark+2),a  
392e 18 03			jr .pastdmark  
3930 ..			.dmark: db "UNf"  
3933 f1			.pastdmark: pop af  
3934			endm  
# End of macro DMARK
3934						CALLMONITOR 
3934 cd 6c fe			call debug_vector  
3937				endm  
# End of macro CALLMONITOR
3937					endif 
3937			 
3937			 
3937			 
3937				FORTH_RSP_POP     ; get rid of DO ptr 
3937 cd dd 20			call macro_forth_rsp_pop 
393a				endm 
# End of macro FORTH_RSP_POP
393a			 
393a			if DEBUG_FORTH_WORDS 
393a						DMARK "UN>" 
393a f5				push af  
393b 3a 4f 39			ld a, (.dmark)  
393e 32 68 fe			ld (debug_mark),a  
3941 3a 50 39			ld a, (.dmark+1)  
3944 32 69 fe			ld (debug_mark+1),a  
3947 3a 51 39			ld a, (.dmark+2)  
394a 32 6a fe			ld (debug_mark+2),a  
394d 18 03			jr .pastdmark  
394f ..			.dmark: db "UN>"  
3952 f1			.pastdmark: pop af  
3953			endm  
# End of macro DMARK
3953				CALLMONITOR 
3953 cd 6c fe			call debug_vector  
3956				endm  
# End of macro CALLMONITOR
3956			endif 
3956			 
3956					NEXTW 
3956 c3 c2 24			jp macro_next 
3959				endm 
# End of macro NEXTW
3959				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3959			 
3959			.untilnotdone: 
3959			 
3959			 
3959			;	; get DO ptr 
3959			; 
3959				FORTH_RSP_TOS 
3959 cd d3 20			call macro_forth_rsp_tos 
395c				endm 
# End of macro FORTH_RSP_TOS
395c			 
395c				;push hl 
395c			 
395c				; not going to DO any more 
395c				; get rid of the RSP pointer as DO will add it back in 
395c				;FORTH_RSP_POP 
395c				;pop hl 
395c			 
395c			 
395c 22 bf f4			ld (os_tok_ptr), hl 
395f					if DEBUG_FORTH_WORDS 
395f						DMARK "UN<" 
395f f5				push af  
3960 3a 74 39			ld a, (.dmark)  
3963 32 68 fe			ld (debug_mark),a  
3966 3a 75 39			ld a, (.dmark+1)  
3969 32 69 fe			ld (debug_mark+1),a  
396c 3a 76 39			ld a, (.dmark+2)  
396f 32 6a fe			ld (debug_mark+2),a  
3972 18 03			jr .pastdmark  
3974 ..			.dmark: db "UN<"  
3977 f1			.pastdmark: pop af  
3978			endm  
# End of macro DMARK
3978					CALLMONITOR 
3978 cd 6c fe			call debug_vector  
397b				endm  
# End of macro CALLMONITOR
397b				endif 
397b c3 53 25			jp exec1 
397e			 
397e					 
397e			 
397e			 
397e					NEXTW 
397e c3 c2 24			jp macro_next 
3981				endm 
# End of macro NEXTW
3981			 
3981			 
3981			.ENDFLOW: 
3981			 
3981			; eof 
3981			 
# End of file forth_words_flow.asm
3981			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3981			include "forth_words_logic.asm" 
3981			 
3981			; | ## Logic Words 
3981			 
3981			.NOT: 
3981				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3981 2d				db WORD_SYS_CORE+25             
3982 c9 39			dw .IS            
3984 04				db 3 + 1 
3985 .. 00			db "NOT",0              
3989				endm 
# End of macro CWHEAD
3989			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3989					if DEBUG_FORTH_WORDS_KEY 
3989						DMARK "NOT" 
3989 f5				push af  
398a 3a 9e 39			ld a, (.dmark)  
398d 32 68 fe			ld (debug_mark),a  
3990 3a 9f 39			ld a, (.dmark+1)  
3993 32 69 fe			ld (debug_mark+1),a  
3996 3a a0 39			ld a, (.dmark+2)  
3999 32 6a fe			ld (debug_mark+2),a  
399c 18 03			jr .pastdmark  
399e ..			.dmark: db "NOT"  
39a1 f1			.pastdmark: pop af  
39a2			endm  
# End of macro DMARK
39a2						CALLMONITOR 
39a2 cd 6c fe			call debug_vector  
39a5				endm  
# End of macro CALLMONITOR
39a5					endif 
39a5					FORTH_DSP 
39a5 cd d2 22			call macro_forth_dsp 
39a8				endm 
# End of macro FORTH_DSP
39a8 7e					ld a,(hl)	; get type of value on TOS 
39a9 fe 02				cp DS_TYPE_INUM  
39ab 28 03				jr z, .noti 
39ad					NEXTW 
39ad c3 c2 24			jp macro_next 
39b0				endm 
# End of macro NEXTW
39b0			.noti:          FORTH_DSP_VALUEHL 
39b0 cd 0c 23			call macro_dsp_valuehl 
39b3				endm 
# End of macro FORTH_DSP_VALUEHL
39b3			;		push hl 
39b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b3 cd c4 23			call macro_forth_dsp_pop 
39b6				endm 
# End of macro FORTH_DSP_POP
39b6			;		pop hl 
39b6 3e 00				ld a,0 
39b8 bd					cp l 
39b9 28 04				jr z, .not2t 
39bb 2e 00				ld l, 0 
39bd 18 02				jr .notip 
39bf			 
39bf 2e ff		.not2t:		ld l, 255 
39c1			 
39c1 26 00		.notip:		ld h, 0	 
39c3			 
39c3 cd 15 21				call forth_push_numhl 
39c6					NEXTW 
39c6 c3 c2 24			jp macro_next 
39c9				endm 
# End of macro NEXTW
39c9			 
39c9			.IS: 
39c9				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
39c9 2d				db WORD_SYS_CORE+25             
39ca ef 39			dw .LZERO            
39cc 03				db 2 + 1 
39cd .. 00			db "IS",0              
39d0				endm 
# End of macro CWHEAD
39d0			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
39d0					if DEBUG_FORTH_WORDS_KEY 
39d0						DMARK "IS." 
39d0 f5				push af  
39d1 3a e5 39			ld a, (.dmark)  
39d4 32 68 fe			ld (debug_mark),a  
39d7 3a e6 39			ld a, (.dmark+1)  
39da 32 69 fe			ld (debug_mark+1),a  
39dd 3a e7 39			ld a, (.dmark+2)  
39e0 32 6a fe			ld (debug_mark+2),a  
39e3 18 03			jr .pastdmark  
39e5 ..			.dmark: db "IS."  
39e8 f1			.pastdmark: pop af  
39e9			endm  
# End of macro DMARK
39e9						CALLMONITOR 
39e9 cd 6c fe			call debug_vector  
39ec				endm  
# End of macro CALLMONITOR
39ec					endif 
39ec					NEXTW 
39ec c3 c2 24			jp macro_next 
39ef				endm 
# End of macro NEXTW
39ef			.LZERO: 
39ef				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
39ef 2d				db WORD_SYS_CORE+25             
39f0 f9 39			dw .TZERO            
39f2 03				db 2 + 1 
39f3 .. 00			db "0<",0              
39f6				endm 
# End of macro CWHEAD
39f6			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
39f6					NEXTW 
39f6 c3 c2 24			jp macro_next 
39f9				endm 
# End of macro NEXTW
39f9			.TZERO: 
39f9				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
39f9 2e				db WORD_SYS_CORE+26             
39fa 40 3a			dw .LESS            
39fc 03				db 2 + 1 
39fd .. 00			db "0=",0              
3a00				endm 
# End of macro CWHEAD
3a00			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3a00				; TODO add floating point number detection 
3a00					;v5 FORTH_DSP_VALUE 
3a00					if DEBUG_FORTH_WORDS_KEY 
3a00						DMARK "0=." 
3a00 f5				push af  
3a01 3a 15 3a			ld a, (.dmark)  
3a04 32 68 fe			ld (debug_mark),a  
3a07 3a 16 3a			ld a, (.dmark+1)  
3a0a 32 69 fe			ld (debug_mark+1),a  
3a0d 3a 17 3a			ld a, (.dmark+2)  
3a10 32 6a fe			ld (debug_mark+2),a  
3a13 18 03			jr .pastdmark  
3a15 ..			.dmark: db "0=."  
3a18 f1			.pastdmark: pop af  
3a19			endm  
# End of macro DMARK
3a19						CALLMONITOR 
3a19 cd 6c fe			call debug_vector  
3a1c				endm  
# End of macro CALLMONITOR
3a1c					endif 
3a1c					FORTH_DSP 
3a1c cd d2 22			call macro_forth_dsp 
3a1f				endm 
# End of macro FORTH_DSP
3a1f 7e					ld a,(hl)	; get type of value on TOS 
3a20 fe 02				cp DS_TYPE_INUM  
3a22 28 00				jr z, .tz_inum 
3a24			 
3a24				if FORTH_ENABLE_FLOATMATH 
3a24					jr .tz_done 
3a24			 
3a24				endif 
3a24					 
3a24			 
3a24			.tz_inum: 
3a24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a24 cd 0c 23			call macro_dsp_valuehl 
3a27				endm 
# End of macro FORTH_DSP_VALUEHL
3a27			 
3a27			;		push hl 
3a27			 
3a27					; destroy value TOS 
3a27			 
3a27					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a27 cd c4 23			call macro_forth_dsp_pop 
3a2a				endm 
# End of macro FORTH_DSP_POP
3a2a			 
3a2a			;		pop hl 
3a2a			 
3a2a 3e 00				ld a,0 
3a2c			 
3a2c bd					cp l 
3a2d 20 08				jr nz, .tz_notzero 
3a2f			 
3a2f bc					cp h 
3a30			 
3a30 20 05				jr nz, .tz_notzero 
3a32			 
3a32			 
3a32 21 01 00				ld hl, FORTH_TRUE 
3a35 18 03				jr .tz_done 
3a37			 
3a37 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a3a			 
3a3a					; push value back onto stack for another op etc 
3a3a			 
3a3a			.tz_done: 
3a3a cd 15 21				call forth_push_numhl 
3a3d			 
3a3d					NEXTW 
3a3d c3 c2 24			jp macro_next 
3a40				endm 
# End of macro NEXTW
3a40			.LESS: 
3a40				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a40 2f				db WORD_SYS_CORE+27             
3a41 a9 3a			dw .GT            
3a43 02				db 1 + 1 
3a44 .. 00			db "<",0              
3a46				endm 
# End of macro CWHEAD
3a46			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a46				; TODO add floating point number detection 
3a46					if DEBUG_FORTH_WORDS_KEY 
3a46						DMARK "LES" 
3a46 f5				push af  
3a47 3a 5b 3a			ld a, (.dmark)  
3a4a 32 68 fe			ld (debug_mark),a  
3a4d 3a 5c 3a			ld a, (.dmark+1)  
3a50 32 69 fe			ld (debug_mark+1),a  
3a53 3a 5d 3a			ld a, (.dmark+2)  
3a56 32 6a fe			ld (debug_mark+2),a  
3a59 18 03			jr .pastdmark  
3a5b ..			.dmark: db "LES"  
3a5e f1			.pastdmark: pop af  
3a5f			endm  
# End of macro DMARK
3a5f						CALLMONITOR 
3a5f cd 6c fe			call debug_vector  
3a62				endm  
# End of macro CALLMONITOR
3a62					endif 
3a62					FORTH_DSP 
3a62 cd d2 22			call macro_forth_dsp 
3a65				endm 
# End of macro FORTH_DSP
3a65					;v5 FORTH_DSP_VALUE 
3a65 7e					ld a,(hl)	; get type of value on TOS 
3a66 fe 02				cp DS_TYPE_INUM  
3a68 28 00				jr z, .less_inum 
3a6a			 
3a6a				if FORTH_ENABLE_FLOATMATH 
3a6a					jr .less_done 
3a6a			 
3a6a				endif 
3a6a					 
3a6a			 
3a6a			.less_inum: 
3a6a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a6a cd 0c 23			call macro_dsp_valuehl 
3a6d				endm 
# End of macro FORTH_DSP_VALUEHL
3a6d			 
3a6d e5					push hl  ; u2 
3a6e			 
3a6e					; destroy value TOS 
3a6e			 
3a6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6e cd c4 23			call macro_forth_dsp_pop 
3a71				endm 
# End of macro FORTH_DSP_POP
3a71			 
3a71			 
3a71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a71 cd 0c 23			call macro_dsp_valuehl 
3a74				endm 
# End of macro FORTH_DSP_VALUEHL
3a74			 
3a74 e5					push hl    ; u1 
3a75			 
3a75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a75 cd c4 23			call macro_forth_dsp_pop 
3a78				endm 
# End of macro FORTH_DSP_POP
3a78			 
3a78			 
3a78 b7			 or a      ;clear carry flag 
3a79 01 00 00		 ld bc, FORTH_FALSE 
3a7c e1			  pop hl    ; u1 
3a7d d1			  pop de    ; u2 
3a7e ed 52		  sbc hl,de 
3a80 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3a82			 
3a82 01 01 00		 ld bc, FORTH_TRUE 
3a85			.lscont:  
3a85 c5					push bc 
3a86 e1					pop hl 
3a87			 
3a87					if DEBUG_FORTH_WORDS 
3a87						DMARK "LT1" 
3a87 f5				push af  
3a88 3a 9c 3a			ld a, (.dmark)  
3a8b 32 68 fe			ld (debug_mark),a  
3a8e 3a 9d 3a			ld a, (.dmark+1)  
3a91 32 69 fe			ld (debug_mark+1),a  
3a94 3a 9e 3a			ld a, (.dmark+2)  
3a97 32 6a fe			ld (debug_mark+2),a  
3a9a 18 03			jr .pastdmark  
3a9c ..			.dmark: db "LT1"  
3a9f f1			.pastdmark: pop af  
3aa0			endm  
# End of macro DMARK
3aa0						CALLMONITOR 
3aa0 cd 6c fe			call debug_vector  
3aa3				endm  
# End of macro CALLMONITOR
3aa3					endif 
3aa3 cd 15 21				call forth_push_numhl 
3aa6			 
3aa6					NEXTW 
3aa6 c3 c2 24			jp macro_next 
3aa9				endm 
# End of macro NEXTW
3aa9			.GT: 
3aa9				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3aa9 30				db WORD_SYS_CORE+28             
3aaa 12 3b			dw .EQUAL            
3aac 02				db 1 + 1 
3aad .. 00			db ">",0              
3aaf				endm 
# End of macro CWHEAD
3aaf			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3aaf				; TODO add floating point number detection 
3aaf					if DEBUG_FORTH_WORDS_KEY 
3aaf						DMARK "GRT" 
3aaf f5				push af  
3ab0 3a c4 3a			ld a, (.dmark)  
3ab3 32 68 fe			ld (debug_mark),a  
3ab6 3a c5 3a			ld a, (.dmark+1)  
3ab9 32 69 fe			ld (debug_mark+1),a  
3abc 3a c6 3a			ld a, (.dmark+2)  
3abf 32 6a fe			ld (debug_mark+2),a  
3ac2 18 03			jr .pastdmark  
3ac4 ..			.dmark: db "GRT"  
3ac7 f1			.pastdmark: pop af  
3ac8			endm  
# End of macro DMARK
3ac8						CALLMONITOR 
3ac8 cd 6c fe			call debug_vector  
3acb				endm  
# End of macro CALLMONITOR
3acb					endif 
3acb					FORTH_DSP 
3acb cd d2 22			call macro_forth_dsp 
3ace				endm 
# End of macro FORTH_DSP
3ace					;FORTH_DSP_VALUE 
3ace 7e					ld a,(hl)	; get type of value on TOS 
3acf fe 02				cp DS_TYPE_INUM  
3ad1 28 00				jr z, .gt_inum 
3ad3			 
3ad3				if FORTH_ENABLE_FLOATMATH 
3ad3					jr .gt_done 
3ad3			 
3ad3				endif 
3ad3					 
3ad3			 
3ad3			.gt_inum: 
3ad3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad3 cd 0c 23			call macro_dsp_valuehl 
3ad6				endm 
# End of macro FORTH_DSP_VALUEHL
3ad6			 
3ad6 e5					push hl  ; u2 
3ad7			 
3ad7					; destroy value TOS 
3ad7			 
3ad7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad7 cd c4 23			call macro_forth_dsp_pop 
3ada				endm 
# End of macro FORTH_DSP_POP
3ada			 
3ada			 
3ada					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ada cd 0c 23			call macro_dsp_valuehl 
3add				endm 
# End of macro FORTH_DSP_VALUEHL
3add			 
3add e5					push hl    ; u1 
3ade			 
3ade					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ade cd c4 23			call macro_forth_dsp_pop 
3ae1				endm 
# End of macro FORTH_DSP_POP
3ae1			 
3ae1			 
3ae1 b7			 or a      ;clear carry flag 
3ae2 01 00 00		 ld bc, FORTH_FALSE 
3ae5 e1			  pop hl    ; u1 
3ae6 d1			  pop de    ; u2 
3ae7 ed 52		  sbc hl,de 
3ae9 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3aeb			 
3aeb 01 01 00		 ld bc, FORTH_TRUE 
3aee			.gtcont:  
3aee c5					push bc 
3aef e1					pop hl 
3af0			 
3af0					if DEBUG_FORTH_WORDS 
3af0						DMARK "GT1" 
3af0 f5				push af  
3af1 3a 05 3b			ld a, (.dmark)  
3af4 32 68 fe			ld (debug_mark),a  
3af7 3a 06 3b			ld a, (.dmark+1)  
3afa 32 69 fe			ld (debug_mark+1),a  
3afd 3a 07 3b			ld a, (.dmark+2)  
3b00 32 6a fe			ld (debug_mark+2),a  
3b03 18 03			jr .pastdmark  
3b05 ..			.dmark: db "GT1"  
3b08 f1			.pastdmark: pop af  
3b09			endm  
# End of macro DMARK
3b09						CALLMONITOR 
3b09 cd 6c fe			call debug_vector  
3b0c				endm  
# End of macro CALLMONITOR
3b0c					endif 
3b0c cd 15 21				call forth_push_numhl 
3b0f			 
3b0f					NEXTW 
3b0f c3 c2 24			jp macro_next 
3b12				endm 
# End of macro NEXTW
3b12			.EQUAL: 
3b12				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b12 31				db WORD_SYS_CORE+29             
3b13 7d 3b			dw .ENDLOGIC            
3b15 02				db 1 + 1 
3b16 .. 00			db "=",0              
3b18				endm 
# End of macro CWHEAD
3b18			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b18				; TODO add floating point number detection 
3b18					if DEBUG_FORTH_WORDS_KEY 
3b18						DMARK "EQ." 
3b18 f5				push af  
3b19 3a 2d 3b			ld a, (.dmark)  
3b1c 32 68 fe			ld (debug_mark),a  
3b1f 3a 2e 3b			ld a, (.dmark+1)  
3b22 32 69 fe			ld (debug_mark+1),a  
3b25 3a 2f 3b			ld a, (.dmark+2)  
3b28 32 6a fe			ld (debug_mark+2),a  
3b2b 18 03			jr .pastdmark  
3b2d ..			.dmark: db "EQ."  
3b30 f1			.pastdmark: pop af  
3b31			endm  
# End of macro DMARK
3b31						CALLMONITOR 
3b31 cd 6c fe			call debug_vector  
3b34				endm  
# End of macro CALLMONITOR
3b34					endif 
3b34					FORTH_DSP 
3b34 cd d2 22			call macro_forth_dsp 
3b37				endm 
# End of macro FORTH_DSP
3b37					;v5 FORTH_DSP_VALUE 
3b37 7e					ld a,(hl)	; get type of value on TOS 
3b38 fe 02				cp DS_TYPE_INUM  
3b3a 28 00				jr z, .eq_inum 
3b3c			 
3b3c				if FORTH_ENABLE_FLOATMATH 
3b3c					jr .eq_done 
3b3c			 
3b3c				endif 
3b3c					 
3b3c			 
3b3c			.eq_inum: 
3b3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b3c cd 0c 23			call macro_dsp_valuehl 
3b3f				endm 
# End of macro FORTH_DSP_VALUEHL
3b3f			 
3b3f e5					push hl 
3b40			 
3b40					; destroy value TOS 
3b40			 
3b40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b40 cd c4 23			call macro_forth_dsp_pop 
3b43				endm 
# End of macro FORTH_DSP_POP
3b43			 
3b43			 
3b43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b43 cd 0c 23			call macro_dsp_valuehl 
3b46				endm 
# End of macro FORTH_DSP_VALUEHL
3b46			 
3b46					; one value on hl get other one back 
3b46			 
3b46 e5					push hl 
3b47			 
3b47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b47 cd c4 23			call macro_forth_dsp_pop 
3b4a				endm 
# End of macro FORTH_DSP_POP
3b4a			 
3b4a 0e 00				ld c, FORTH_FALSE 
3b4c			 
3b4c e1					pop hl 
3b4d d1					pop de 
3b4e			 
3b4e 7b					ld a, e 
3b4f bd					cp l 
3b50			 
3b50 20 06				jr nz, .eq_done 
3b52			 
3b52 7a					ld a, d 
3b53 bc					cp h 
3b54			 
3b54 20 02				jr nz, .eq_done 
3b56			 
3b56 0e 01				ld c, FORTH_TRUE 
3b58					 
3b58			 
3b58			 
3b58			.eq_done: 
3b58			 
3b58					; TODO push value back onto stack for another op etc 
3b58			 
3b58 26 00				ld h, 0 
3b5a 69					ld l, c 
3b5b					if DEBUG_FORTH_WORDS 
3b5b						DMARK "EQ1" 
3b5b f5				push af  
3b5c 3a 70 3b			ld a, (.dmark)  
3b5f 32 68 fe			ld (debug_mark),a  
3b62 3a 71 3b			ld a, (.dmark+1)  
3b65 32 69 fe			ld (debug_mark+1),a  
3b68 3a 72 3b			ld a, (.dmark+2)  
3b6b 32 6a fe			ld (debug_mark+2),a  
3b6e 18 03			jr .pastdmark  
3b70 ..			.dmark: db "EQ1"  
3b73 f1			.pastdmark: pop af  
3b74			endm  
# End of macro DMARK
3b74						CALLMONITOR 
3b74 cd 6c fe			call debug_vector  
3b77				endm  
# End of macro CALLMONITOR
3b77					endif 
3b77 cd 15 21				call forth_push_numhl 
3b7a			 
3b7a					NEXTW 
3b7a c3 c2 24			jp macro_next 
3b7d				endm 
# End of macro NEXTW
3b7d			 
3b7d			 
3b7d			.ENDLOGIC: 
3b7d			; eof 
3b7d			 
3b7d			 
# End of file forth_words_logic.asm
3b7d			include "forth_words_maths.asm" 
3b7d			 
3b7d			; | ## Maths Words 
3b7d			 
3b7d			.PLUS:	 
3b7d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3b7d 15				db WORD_SYS_CORE+1             
3b7e db 3b			dw .NEG            
3b80 02				db 1 + 1 
3b81 .. 00			db "+",0              
3b83				endm 
# End of macro CWHEAD
3b83			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3b83					if DEBUG_FORTH_WORDS_KEY 
3b83						DMARK "PLU" 
3b83 f5				push af  
3b84 3a 98 3b			ld a, (.dmark)  
3b87 32 68 fe			ld (debug_mark),a  
3b8a 3a 99 3b			ld a, (.dmark+1)  
3b8d 32 69 fe			ld (debug_mark+1),a  
3b90 3a 9a 3b			ld a, (.dmark+2)  
3b93 32 6a fe			ld (debug_mark+2),a  
3b96 18 03			jr .pastdmark  
3b98 ..			.dmark: db "PLU"  
3b9b f1			.pastdmark: pop af  
3b9c			endm  
# End of macro DMARK
3b9c						CALLMONITOR 
3b9c cd 6c fe			call debug_vector  
3b9f				endm  
# End of macro CALLMONITOR
3b9f					endif 
3b9f					; add top two values and push back result 
3b9f			 
3b9f					;for v5 FORTH_DSP_VALUE 
3b9f					FORTH_DSP 
3b9f cd d2 22			call macro_forth_dsp 
3ba2				endm 
# End of macro FORTH_DSP
3ba2 7e					ld a,(hl)	; get type of value on TOS 
3ba3 fe 02				cp DS_TYPE_INUM  
3ba5 28 03				jr z, .dot_inum 
3ba7			 
3ba7					NEXTW 
3ba7 c3 c2 24			jp macro_next 
3baa				endm 
# End of macro NEXTW
3baa			 
3baa			; float maths 
3baa			 
3baa				if FORTH_ENABLE_FLOATMATH 
3baa						inc hl      ; now at start of numeric as string 
3baa			 
3baa					if DEBUG_FORTH_MATHS 
3baa						DMARK "ADD" 
3baa				CALLMONITOR 
3baa					endif 
3baa			 
3baa					;ld ix, hl 
3baa					call CON 
3baa			 
3baa			 
3baa					push hl 
3baa					 
3baa					 
3baa			 
3baa						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3baa			 
3baa					; get next number 
3baa			 
3baa						FORTH_DSP_VALUE 
3baa			 
3baa						inc hl      ; now at start of numeric as string 
3baa			 
3baa					;ld ix, hl 
3baa					call CON 
3baa			 
3baa					push hl 
3baa			 
3baa			 
3baa						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3baa			 
3baa						; TODO do add 
3baa			 
3baa						call IADD 
3baa			 
3baa						; TODO get result back as ascii 
3baa			 
3baa						; TODO push result  
3baa			 
3baa			 
3baa			 
3baa						jr .dot_done 
3baa				endif 
3baa			 
3baa			.dot_inum: 
3baa			 
3baa			 
3baa					if DEBUG_FORTH_DOT 
3baa						DMARK "+IT" 
3baa f5				push af  
3bab 3a bf 3b			ld a, (.dmark)  
3bae 32 68 fe			ld (debug_mark),a  
3bb1 3a c0 3b			ld a, (.dmark+1)  
3bb4 32 69 fe			ld (debug_mark+1),a  
3bb7 3a c1 3b			ld a, (.dmark+2)  
3bba 32 6a fe			ld (debug_mark+2),a  
3bbd 18 03			jr .pastdmark  
3bbf ..			.dmark: db "+IT"  
3bc2 f1			.pastdmark: pop af  
3bc3			endm  
# End of macro DMARK
3bc3				CALLMONITOR 
3bc3 cd 6c fe			call debug_vector  
3bc6				endm  
# End of macro CALLMONITOR
3bc6					endif 
3bc6			 
3bc6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bc6 cd 0c 23			call macro_dsp_valuehl 
3bc9				endm 
# End of macro FORTH_DSP_VALUEHL
3bc9			 
3bc9				; TODO add floating point number detection 
3bc9			 
3bc9 e5					push hl 
3bca			 
3bca					; destroy value TOS 
3bca			 
3bca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bca cd c4 23			call macro_forth_dsp_pop 
3bcd				endm 
# End of macro FORTH_DSP_POP
3bcd			 
3bcd			 
3bcd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bcd cd 0c 23			call macro_dsp_valuehl 
3bd0				endm 
# End of macro FORTH_DSP_VALUEHL
3bd0			 
3bd0					; one value on hl get other one back 
3bd0			 
3bd0 d1					pop de 
3bd1			 
3bd1					; do the add 
3bd1			 
3bd1 19					add hl,de 
3bd2			 
3bd2					; save it 
3bd2			 
3bd2			;		push hl	 
3bd2			 
3bd2					; 
3bd2			 
3bd2					; destroy value TOS 
3bd2			 
3bd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd2 cd c4 23			call macro_forth_dsp_pop 
3bd5				endm 
# End of macro FORTH_DSP_POP
3bd5			 
3bd5					; TODO push value back onto stack for another op etc 
3bd5			 
3bd5			;		pop hl 
3bd5			 
3bd5			.dot_done: 
3bd5 cd 15 21				call forth_push_numhl 
3bd8			 
3bd8					NEXTW 
3bd8 c3 c2 24			jp macro_next 
3bdb				endm 
# End of macro NEXTW
3bdb			.NEG: 
3bdb			 
3bdb				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3bdb 17				db WORD_SYS_CORE+3             
3bdc 1e 3c			dw .DIV            
3bde 02				db 1 + 1 
3bdf .. 00			db "-",0              
3be1				endm 
# End of macro CWHEAD
3be1			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3be1					if DEBUG_FORTH_WORDS_KEY 
3be1						DMARK "SUB" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 68 fe			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 69 fe			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 6a fe			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "SUB"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa						CALLMONITOR 
3bfa cd 6c fe			call debug_vector  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd			 
3bfd			 
3bfd				; TODO add floating point number detection 
3bfd					; v5 FORTH_DSP_VALUE 
3bfd					FORTH_DSP 
3bfd cd d2 22			call macro_forth_dsp 
3c00				endm 
# End of macro FORTH_DSP
3c00 7e					ld a,(hl)	; get type of value on TOS 
3c01 fe 02				cp DS_TYPE_INUM  
3c03 28 03				jr z, .neg_inum 
3c05			 
3c05					NEXTW 
3c05 c3 c2 24			jp macro_next 
3c08				endm 
# End of macro NEXTW
3c08			 
3c08			; float maths 
3c08			 
3c08				if FORTH_ENABLE_FLOATMATH 
3c08					jr .neg_done 
3c08			 
3c08				endif 
3c08					 
3c08			 
3c08			.neg_inum: 
3c08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c08 cd 0c 23			call macro_dsp_valuehl 
3c0b				endm 
# End of macro FORTH_DSP_VALUEHL
3c0b			 
3c0b e5					push hl 
3c0c			 
3c0c					; destroy value TOS 
3c0c			 
3c0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c0c cd c4 23			call macro_forth_dsp_pop 
3c0f				endm 
# End of macro FORTH_DSP_POP
3c0f			 
3c0f			 
3c0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c0f cd 0c 23			call macro_dsp_valuehl 
3c12				endm 
# End of macro FORTH_DSP_VALUEHL
3c12			 
3c12					; one value on hl get other one back 
3c12			 
3c12 d1					pop de 
3c13			 
3c13					; do the sub 
3c13			;		ex de, hl 
3c13			 
3c13 ed 52				sbc hl,de 
3c15			 
3c15					; save it 
3c15			 
3c15			;		push hl	 
3c15			 
3c15					; 
3c15			 
3c15					; destroy value TOS 
3c15			 
3c15					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c15 cd c4 23			call macro_forth_dsp_pop 
3c18				endm 
# End of macro FORTH_DSP_POP
3c18			 
3c18					; TODO push value back onto stack for another op etc 
3c18			 
3c18			;		pop hl 
3c18			 
3c18 cd 15 21				call forth_push_numhl 
3c1b			.neg_done: 
3c1b			 
3c1b					NEXTW 
3c1b c3 c2 24			jp macro_next 
3c1e				endm 
# End of macro NEXTW
3c1e			.DIV: 
3c1e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c1e 18				db WORD_SYS_CORE+4             
3c1f 6b 3c			dw .MUL            
3c21 02				db 1 + 1 
3c22 .. 00			db "/",0              
3c24				endm 
# End of macro CWHEAD
3c24			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c24					if DEBUG_FORTH_WORDS_KEY 
3c24						DMARK "DIV" 
3c24 f5				push af  
3c25 3a 39 3c			ld a, (.dmark)  
3c28 32 68 fe			ld (debug_mark),a  
3c2b 3a 3a 3c			ld a, (.dmark+1)  
3c2e 32 69 fe			ld (debug_mark+1),a  
3c31 3a 3b 3c			ld a, (.dmark+2)  
3c34 32 6a fe			ld (debug_mark+2),a  
3c37 18 03			jr .pastdmark  
3c39 ..			.dmark: db "DIV"  
3c3c f1			.pastdmark: pop af  
3c3d			endm  
# End of macro DMARK
3c3d						CALLMONITOR 
3c3d cd 6c fe			call debug_vector  
3c40				endm  
# End of macro CALLMONITOR
3c40					endif 
3c40				; TODO add floating point number detection 
3c40					; v5 FORTH_DSP_VALUE 
3c40					FORTH_DSP 
3c40 cd d2 22			call macro_forth_dsp 
3c43				endm 
# End of macro FORTH_DSP
3c43 7e					ld a,(hl)	; get type of value on TOS 
3c44 fe 02				cp DS_TYPE_INUM  
3c46 28 03				jr z, .div_inum 
3c48			 
3c48				if FORTH_ENABLE_FLOATMATH 
3c48					jr .div_done 
3c48			 
3c48				endif 
3c48					NEXTW 
3c48 c3 c2 24			jp macro_next 
3c4b				endm 
# End of macro NEXTW
3c4b			.div_inum: 
3c4b			 
3c4b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c4b cd 0c 23			call macro_dsp_valuehl 
3c4e				endm 
# End of macro FORTH_DSP_VALUEHL
3c4e			 
3c4e e5					push hl    ; to go to bc 
3c4f			 
3c4f					; destroy value TOS 
3c4f			 
3c4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4f cd c4 23			call macro_forth_dsp_pop 
3c52				endm 
# End of macro FORTH_DSP_POP
3c52			 
3c52			 
3c52					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c52 cd 0c 23			call macro_dsp_valuehl 
3c55				endm 
# End of macro FORTH_DSP_VALUEHL
3c55			 
3c55					; hl to go to de 
3c55			 
3c55 e5					push hl 
3c56			 
3c56 c1					pop bc 
3c57 d1					pop de		 
3c58			 
3c58			 
3c58					if DEBUG_FORTH_MATHS 
3c58						DMARK "DIV" 
3c58				CALLMONITOR 
3c58					endif 
3c58					; one value on hl but move to a get other one back 
3c58			 
3c58			        
3c58 cd 2d 0f			call Div16 
3c5b			 
3c5b			;	push af	 
3c5b e5				push hl 
3c5c c5				push bc 
3c5d			 
3c5d					if DEBUG_FORTH_MATHS 
3c5d						DMARK "DI1" 
3c5d				CALLMONITOR 
3c5d					endif 
3c5d			 
3c5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c5d cd c4 23			call macro_forth_dsp_pop 
3c60				endm 
# End of macro FORTH_DSP_POP
3c60			 
3c60			 
3c60			 
3c60 e1					pop hl    ; result 
3c61			 
3c61 cd 15 21				call forth_push_numhl 
3c64			 
3c64 e1					pop hl    ; reminder 
3c65			;		ld h,0 
3c65			;		ld l,d 
3c65			 
3c65 cd 15 21				call forth_push_numhl 
3c68			.div_done: 
3c68					NEXTW 
3c68 c3 c2 24			jp macro_next 
3c6b				endm 
# End of macro NEXTW
3c6b			.MUL: 
3c6b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c6b 19				db WORD_SYS_CORE+5             
3c6c b0 3c			dw .MIN            
3c6e 02				db 1 + 1 
3c6f .. 00			db "*",0              
3c71				endm 
# End of macro CWHEAD
3c71			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3c71				; TODO add floating point number detection 
3c71					if DEBUG_FORTH_WORDS_KEY 
3c71						DMARK "MUL" 
3c71 f5				push af  
3c72 3a 86 3c			ld a, (.dmark)  
3c75 32 68 fe			ld (debug_mark),a  
3c78 3a 87 3c			ld a, (.dmark+1)  
3c7b 32 69 fe			ld (debug_mark+1),a  
3c7e 3a 88 3c			ld a, (.dmark+2)  
3c81 32 6a fe			ld (debug_mark+2),a  
3c84 18 03			jr .pastdmark  
3c86 ..			.dmark: db "MUL"  
3c89 f1			.pastdmark: pop af  
3c8a			endm  
# End of macro DMARK
3c8a						CALLMONITOR 
3c8a cd 6c fe			call debug_vector  
3c8d				endm  
# End of macro CALLMONITOR
3c8d					endif 
3c8d					FORTH_DSP 
3c8d cd d2 22			call macro_forth_dsp 
3c90				endm 
# End of macro FORTH_DSP
3c90					; v5 FORTH_DSP_VALUE 
3c90 7e					ld a,(hl)	; get type of value on TOS 
3c91 fe 02				cp DS_TYPE_INUM  
3c93 28 03				jr z, .mul_inum 
3c95			 
3c95				if FORTH_ENABLE_FLOATMATH 
3c95					jr .mul_done 
3c95			 
3c95				endif 
3c95			 
3c95					NEXTW 
3c95 c3 c2 24			jp macro_next 
3c98				endm 
# End of macro NEXTW
3c98			.mul_inum:	 
3c98			 
3c98					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c98 cd 0c 23			call macro_dsp_valuehl 
3c9b				endm 
# End of macro FORTH_DSP_VALUEHL
3c9b			 
3c9b e5					push hl 
3c9c			 
3c9c					; destroy value TOS 
3c9c			 
3c9c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c9c cd c4 23			call macro_forth_dsp_pop 
3c9f				endm 
# End of macro FORTH_DSP_POP
3c9f			 
3c9f			 
3c9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c9f cd 0c 23			call macro_dsp_valuehl 
3ca2				endm 
# End of macro FORTH_DSP_VALUEHL
3ca2			 
3ca2					; one value on hl but move to a get other one back 
3ca2			 
3ca2 7d					ld a, l 
3ca3			 
3ca3 d1					pop de 
3ca4			 
3ca4					; do the mull 
3ca4			;		ex de, hl 
3ca4			 
3ca4 cd 53 0f				call Mult16 
3ca7					; save it 
3ca7			 
3ca7			;		push hl	 
3ca7			 
3ca7					; 
3ca7			 
3ca7					; destroy value TOS 
3ca7			 
3ca7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca7 cd c4 23			call macro_forth_dsp_pop 
3caa				endm 
# End of macro FORTH_DSP_POP
3caa			 
3caa					; TODO push value back onto stack for another op etc 
3caa			 
3caa			;		pop hl 
3caa			 
3caa cd 15 21				call forth_push_numhl 
3cad			 
3cad			.mul_done: 
3cad					NEXTW 
3cad c3 c2 24			jp macro_next 
3cb0				endm 
# End of macro NEXTW
3cb0			 
3cb0			 
3cb0			 
3cb0			 
3cb0			.MIN: 
3cb0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3cb0 49				db WORD_SYS_CORE+53             
3cb1 31 3d			dw .MAX            
3cb3 04				db 3 + 1 
3cb4 .. 00			db "MIN",0              
3cb8				endm 
# End of macro CWHEAD
3cb8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3cb8					if DEBUG_FORTH_WORDS_KEY 
3cb8						DMARK "MIN" 
3cb8 f5				push af  
3cb9 3a cd 3c			ld a, (.dmark)  
3cbc 32 68 fe			ld (debug_mark),a  
3cbf 3a ce 3c			ld a, (.dmark+1)  
3cc2 32 69 fe			ld (debug_mark+1),a  
3cc5 3a cf 3c			ld a, (.dmark+2)  
3cc8 32 6a fe			ld (debug_mark+2),a  
3ccb 18 03			jr .pastdmark  
3ccd ..			.dmark: db "MIN"  
3cd0 f1			.pastdmark: pop af  
3cd1			endm  
# End of macro DMARK
3cd1						CALLMONITOR 
3cd1 cd 6c fe			call debug_vector  
3cd4				endm  
# End of macro CALLMONITOR
3cd4					endif 
3cd4					; get u2 
3cd4			 
3cd4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd4 cd 0c 23			call macro_dsp_valuehl 
3cd7				endm 
# End of macro FORTH_DSP_VALUEHL
3cd7			 
3cd7 e5					push hl   ; u2 
3cd8			 
3cd8					; destroy value TOS 
3cd8			 
3cd8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd8 cd c4 23			call macro_forth_dsp_pop 
3cdb				endm 
# End of macro FORTH_DSP_POP
3cdb			 
3cdb					; get u1 
3cdb			 
3cdb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cdb cd 0c 23			call macro_dsp_valuehl 
3cde				endm 
# End of macro FORTH_DSP_VALUEHL
3cde			 
3cde e5					push hl  ; u1 
3cdf			 
3cdf					; destroy value TOS 
3cdf			 
3cdf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cdf cd c4 23			call macro_forth_dsp_pop 
3ce2				endm 
# End of macro FORTH_DSP_POP
3ce2			 
3ce2 b7			 or a      ;clear carry flag 
3ce3 e1			  pop hl    ; u1 
3ce4 d1			  pop de    ; u2 
3ce5 e5				push hl   ; saved in case hl is lowest 
3ce6 ed 52		  sbc hl,de 
3ce8 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3cea			 
3cea e1				pop hl 
3ceb					if DEBUG_FORTH_WORDS 
3ceb						DMARK "MIN" 
3ceb f5				push af  
3cec 3a 00 3d			ld a, (.dmark)  
3cef 32 68 fe			ld (debug_mark),a  
3cf2 3a 01 3d			ld a, (.dmark+1)  
3cf5 32 69 fe			ld (debug_mark+1),a  
3cf8 3a 02 3d			ld a, (.dmark+2)  
3cfb 32 6a fe			ld (debug_mark+2),a  
3cfe 18 03			jr .pastdmark  
3d00 ..			.dmark: db "MIN"  
3d03 f1			.pastdmark: pop af  
3d04			endm  
# End of macro DMARK
3d04						CALLMONITOR 
3d04 cd 6c fe			call debug_vector  
3d07				endm  
# End of macro CALLMONITOR
3d07					endif 
3d07 cd 15 21				call forth_push_numhl 
3d0a			 
3d0a				       NEXTW 
3d0a c3 c2 24			jp macro_next 
3d0d				endm 
# End of macro NEXTW
3d0d			 
3d0d			.mincont:  
3d0d c1				pop bc   ; tidy up 
3d0e eb				ex de , hl  
3d0f					if DEBUG_FORTH_WORDS 
3d0f						DMARK "MI1" 
3d0f f5				push af  
3d10 3a 24 3d			ld a, (.dmark)  
3d13 32 68 fe			ld (debug_mark),a  
3d16 3a 25 3d			ld a, (.dmark+1)  
3d19 32 69 fe			ld (debug_mark+1),a  
3d1c 3a 26 3d			ld a, (.dmark+2)  
3d1f 32 6a fe			ld (debug_mark+2),a  
3d22 18 03			jr .pastdmark  
3d24 ..			.dmark: db "MI1"  
3d27 f1			.pastdmark: pop af  
3d28			endm  
# End of macro DMARK
3d28						CALLMONITOR 
3d28 cd 6c fe			call debug_vector  
3d2b				endm  
# End of macro CALLMONITOR
3d2b					endif 
3d2b cd 15 21				call forth_push_numhl 
3d2e			 
3d2e				       NEXTW 
3d2e c3 c2 24			jp macro_next 
3d31				endm 
# End of macro NEXTW
3d31			.MAX: 
3d31				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d31 4a				db WORD_SYS_CORE+54             
3d32 b2 3d			dw .RND16            
3d34 04				db 3 + 1 
3d35 .. 00			db "MAX",0              
3d39				endm 
# End of macro CWHEAD
3d39			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d39					if DEBUG_FORTH_WORDS_KEY 
3d39						DMARK "MAX" 
3d39 f5				push af  
3d3a 3a 4e 3d			ld a, (.dmark)  
3d3d 32 68 fe			ld (debug_mark),a  
3d40 3a 4f 3d			ld a, (.dmark+1)  
3d43 32 69 fe			ld (debug_mark+1),a  
3d46 3a 50 3d			ld a, (.dmark+2)  
3d49 32 6a fe			ld (debug_mark+2),a  
3d4c 18 03			jr .pastdmark  
3d4e ..			.dmark: db "MAX"  
3d51 f1			.pastdmark: pop af  
3d52			endm  
# End of macro DMARK
3d52						CALLMONITOR 
3d52 cd 6c fe			call debug_vector  
3d55				endm  
# End of macro CALLMONITOR
3d55					endif 
3d55					; get u2 
3d55			 
3d55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d55 cd 0c 23			call macro_dsp_valuehl 
3d58				endm 
# End of macro FORTH_DSP_VALUEHL
3d58			 
3d58 e5					push hl   ; u2 
3d59			 
3d59					; destroy value TOS 
3d59			 
3d59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d59 cd c4 23			call macro_forth_dsp_pop 
3d5c				endm 
# End of macro FORTH_DSP_POP
3d5c			 
3d5c					; get u1 
3d5c			 
3d5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d5c cd 0c 23			call macro_dsp_valuehl 
3d5f				endm 
# End of macro FORTH_DSP_VALUEHL
3d5f			 
3d5f e5					push hl  ; u1 
3d60			 
3d60					; destroy value TOS 
3d60			 
3d60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d60 cd c4 23			call macro_forth_dsp_pop 
3d63				endm 
# End of macro FORTH_DSP_POP
3d63			 
3d63 b7			 or a      ;clear carry flag 
3d64 e1			  pop hl    ; u1 
3d65 d1			  pop de    ; u2 
3d66 e5				push hl   ; saved in case hl is lowest 
3d67 ed 52		  sbc hl,de 
3d69 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d6b			 
3d6b e1				pop hl 
3d6c					if DEBUG_FORTH_WORDS 
3d6c						DMARK "MAX" 
3d6c f5				push af  
3d6d 3a 81 3d			ld a, (.dmark)  
3d70 32 68 fe			ld (debug_mark),a  
3d73 3a 82 3d			ld a, (.dmark+1)  
3d76 32 69 fe			ld (debug_mark+1),a  
3d79 3a 83 3d			ld a, (.dmark+2)  
3d7c 32 6a fe			ld (debug_mark+2),a  
3d7f 18 03			jr .pastdmark  
3d81 ..			.dmark: db "MAX"  
3d84 f1			.pastdmark: pop af  
3d85			endm  
# End of macro DMARK
3d85						CALLMONITOR 
3d85 cd 6c fe			call debug_vector  
3d88				endm  
# End of macro CALLMONITOR
3d88					endif 
3d88 cd 15 21				call forth_push_numhl 
3d8b			 
3d8b				       NEXTW 
3d8b c3 c2 24			jp macro_next 
3d8e				endm 
# End of macro NEXTW
3d8e			 
3d8e			.maxcont:  
3d8e c1				pop bc   ; tidy up 
3d8f eb				ex de , hl  
3d90					if DEBUG_FORTH_WORDS 
3d90						DMARK "MA1" 
3d90 f5				push af  
3d91 3a a5 3d			ld a, (.dmark)  
3d94 32 68 fe			ld (debug_mark),a  
3d97 3a a6 3d			ld a, (.dmark+1)  
3d9a 32 69 fe			ld (debug_mark+1),a  
3d9d 3a a7 3d			ld a, (.dmark+2)  
3da0 32 6a fe			ld (debug_mark+2),a  
3da3 18 03			jr .pastdmark  
3da5 ..			.dmark: db "MA1"  
3da8 f1			.pastdmark: pop af  
3da9			endm  
# End of macro DMARK
3da9						CALLMONITOR 
3da9 cd 6c fe			call debug_vector  
3dac				endm  
# End of macro CALLMONITOR
3dac					endif 
3dac cd 15 21				call forth_push_numhl 
3daf				       NEXTW 
3daf c3 c2 24			jp macro_next 
3db2				endm 
# End of macro NEXTW
3db2			 
3db2			.RND16: 
3db2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3db2 4e				db WORD_SYS_CORE+58             
3db3 e1 3d			dw .RND8            
3db5 06				db 5 + 1 
3db6 .. 00			db "RND16",0              
3dbc				endm 
# End of macro CWHEAD
3dbc			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3dbc					if DEBUG_FORTH_WORDS_KEY 
3dbc						DMARK "R16" 
3dbc f5				push af  
3dbd 3a d1 3d			ld a, (.dmark)  
3dc0 32 68 fe			ld (debug_mark),a  
3dc3 3a d2 3d			ld a, (.dmark+1)  
3dc6 32 69 fe			ld (debug_mark+1),a  
3dc9 3a d3 3d			ld a, (.dmark+2)  
3dcc 32 6a fe			ld (debug_mark+2),a  
3dcf 18 03			jr .pastdmark  
3dd1 ..			.dmark: db "R16"  
3dd4 f1			.pastdmark: pop af  
3dd5			endm  
# End of macro DMARK
3dd5						CALLMONITOR 
3dd5 cd 6c fe			call debug_vector  
3dd8				endm  
# End of macro CALLMONITOR
3dd8					endif 
3dd8 cd f7 0e				call prng16  
3ddb cd 15 21				call forth_push_numhl 
3dde				       NEXTW 
3dde c3 c2 24			jp macro_next 
3de1				endm 
# End of macro NEXTW
3de1			.RND8: 
3de1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3de1 60				db WORD_SYS_CORE+76             
3de2 16 3e			dw .RND            
3de4 05				db 4 + 1 
3de5 .. 00			db "RND8",0              
3dea				endm 
# End of macro CWHEAD
3dea			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3dea					if DEBUG_FORTH_WORDS_KEY 
3dea						DMARK "RN8" 
3dea f5				push af  
3deb 3a ff 3d			ld a, (.dmark)  
3dee 32 68 fe			ld (debug_mark),a  
3df1 3a 00 3e			ld a, (.dmark+1)  
3df4 32 69 fe			ld (debug_mark+1),a  
3df7 3a 01 3e			ld a, (.dmark+2)  
3dfa 32 6a fe			ld (debug_mark+2),a  
3dfd 18 03			jr .pastdmark  
3dff ..			.dmark: db "RN8"  
3e02 f1			.pastdmark: pop af  
3e03			endm  
# End of macro DMARK
3e03						CALLMONITOR 
3e03 cd 6c fe			call debug_vector  
3e06				endm  
# End of macro CALLMONITOR
3e06					endif 
3e06 2a a6 fb				ld hl,(xrandc) 
3e09 23					inc hl 
3e0a cd 11 0f				call xrnd 
3e0d 6f					ld l,a	 
3e0e 26 00				ld h,0 
3e10 cd 15 21				call forth_push_numhl 
3e13				       NEXTW 
3e13 c3 c2 24			jp macro_next 
3e16				endm 
# End of macro NEXTW
3e16			.RND: 
3e16				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e16 60				db WORD_SYS_CORE+76             
3e17 1c 3f			dw .ENDMATHS            
3e19 04				db 3 + 1 
3e1a .. 00			db "RND",0              
3e1e				endm 
# End of macro CWHEAD
3e1e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e1e			 
3e1e					if DEBUG_FORTH_WORDS_KEY 
3e1e						DMARK "RND" 
3e1e f5				push af  
3e1f 3a 33 3e			ld a, (.dmark)  
3e22 32 68 fe			ld (debug_mark),a  
3e25 3a 34 3e			ld a, (.dmark+1)  
3e28 32 69 fe			ld (debug_mark+1),a  
3e2b 3a 35 3e			ld a, (.dmark+2)  
3e2e 32 6a fe			ld (debug_mark+2),a  
3e31 18 03			jr .pastdmark  
3e33 ..			.dmark: db "RND"  
3e36 f1			.pastdmark: pop af  
3e37			endm  
# End of macro DMARK
3e37						CALLMONITOR 
3e37 cd 6c fe			call debug_vector  
3e3a				endm  
# End of macro CALLMONITOR
3e3a					endif 
3e3a					 
3e3a					FORTH_DSP_VALUEHL    ; upper range 
3e3a cd 0c 23			call macro_dsp_valuehl 
3e3d				endm 
# End of macro FORTH_DSP_VALUEHL
3e3d			 
3e3d 22 aa fb				ld (LFSRSeed), hl	 
3e40			 
3e40					if DEBUG_FORTH_WORDS 
3e40						DMARK "RN1" 
3e40 f5				push af  
3e41 3a 55 3e			ld a, (.dmark)  
3e44 32 68 fe			ld (debug_mark),a  
3e47 3a 56 3e			ld a, (.dmark+1)  
3e4a 32 69 fe			ld (debug_mark+1),a  
3e4d 3a 57 3e			ld a, (.dmark+2)  
3e50 32 6a fe			ld (debug_mark+2),a  
3e53 18 03			jr .pastdmark  
3e55 ..			.dmark: db "RN1"  
3e58 f1			.pastdmark: pop af  
3e59			endm  
# End of macro DMARK
3e59						CALLMONITOR 
3e59 cd 6c fe			call debug_vector  
3e5c				endm  
# End of macro CALLMONITOR
3e5c					endif 
3e5c					FORTH_DSP_POP 
3e5c cd c4 23			call macro_forth_dsp_pop 
3e5f				endm 
# End of macro FORTH_DSP_POP
3e5f			 
3e5f					FORTH_DSP_VALUEHL    ; low range 
3e5f cd 0c 23			call macro_dsp_valuehl 
3e62				endm 
# End of macro FORTH_DSP_VALUEHL
3e62			 
3e62					if DEBUG_FORTH_WORDS 
3e62						DMARK "RN2" 
3e62 f5				push af  
3e63 3a 77 3e			ld a, (.dmark)  
3e66 32 68 fe			ld (debug_mark),a  
3e69 3a 78 3e			ld a, (.dmark+1)  
3e6c 32 69 fe			ld (debug_mark+1),a  
3e6f 3a 79 3e			ld a, (.dmark+2)  
3e72 32 6a fe			ld (debug_mark+2),a  
3e75 18 03			jr .pastdmark  
3e77 ..			.dmark: db "RN2"  
3e7a f1			.pastdmark: pop af  
3e7b			endm  
# End of macro DMARK
3e7b						CALLMONITOR 
3e7b cd 6c fe			call debug_vector  
3e7e				endm  
# End of macro CALLMONITOR
3e7e					endif 
3e7e 22 ac fb				ld (LFSRSeed+2), hl 
3e81			 
3e81					FORTH_DSP_POP 
3e81 cd c4 23			call macro_forth_dsp_pop 
3e84				endm 
# End of macro FORTH_DSP_POP
3e84			 
3e84 e5					push hl 
3e85			 
3e85 e1			.inrange:	pop hl 
3e86 cd f7 0e				call prng16  
3e89					if DEBUG_FORTH_WORDS 
3e89						DMARK "RN3" 
3e89 f5				push af  
3e8a 3a 9e 3e			ld a, (.dmark)  
3e8d 32 68 fe			ld (debug_mark),a  
3e90 3a 9f 3e			ld a, (.dmark+1)  
3e93 32 69 fe			ld (debug_mark+1),a  
3e96 3a a0 3e			ld a, (.dmark+2)  
3e99 32 6a fe			ld (debug_mark+2),a  
3e9c 18 03			jr .pastdmark  
3e9e ..			.dmark: db "RN3"  
3ea1 f1			.pastdmark: pop af  
3ea2			endm  
# End of macro DMARK
3ea2						CALLMONITOR 
3ea2 cd 6c fe			call debug_vector  
3ea5				endm  
# End of macro CALLMONITOR
3ea5					endif 
3ea5					 
3ea5					; if the range is 8bit knock out the high byte 
3ea5			 
3ea5 ed 5b aa fb			ld de, (LFSRSeed)     ; check high level 
3ea9			 
3ea9 3e 00				ld a, 0 
3eab ba					cp d  
3eac 20 1e				jr nz, .hirange 
3eae 26 00				ld h, 0   ; knock it down to 8bit 
3eb0			 
3eb0					if DEBUG_FORTH_WORDS 
3eb0						DMARK "RNk" 
3eb0 f5				push af  
3eb1 3a c5 3e			ld a, (.dmark)  
3eb4 32 68 fe			ld (debug_mark),a  
3eb7 3a c6 3e			ld a, (.dmark+1)  
3eba 32 69 fe			ld (debug_mark+1),a  
3ebd 3a c7 3e			ld a, (.dmark+2)  
3ec0 32 6a fe			ld (debug_mark+2),a  
3ec3 18 03			jr .pastdmark  
3ec5 ..			.dmark: db "RNk"  
3ec8 f1			.pastdmark: pop af  
3ec9			endm  
# End of macro DMARK
3ec9						CALLMONITOR 
3ec9 cd 6c fe			call debug_vector  
3ecc				endm  
# End of macro CALLMONITOR
3ecc					endif 
3ecc			.hirange:   
3ecc e5					push hl  
3ecd b7					or a  
3ece ed 52		                sbc hl, de 
3ed0			 
3ed0					;call cmp16 
3ed0			 
3ed0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ed2 e1					pop hl 
3ed3 e5					push hl 
3ed4			 
3ed4					if DEBUG_FORTH_WORDS 
3ed4						DMARK "RN4" 
3ed4 f5				push af  
3ed5 3a e9 3e			ld a, (.dmark)  
3ed8 32 68 fe			ld (debug_mark),a  
3edb 3a ea 3e			ld a, (.dmark+1)  
3ede 32 69 fe			ld (debug_mark+1),a  
3ee1 3a eb 3e			ld a, (.dmark+2)  
3ee4 32 6a fe			ld (debug_mark+2),a  
3ee7 18 03			jr .pastdmark  
3ee9 ..			.dmark: db "RN4"  
3eec f1			.pastdmark: pop af  
3eed			endm  
# End of macro DMARK
3eed						CALLMONITOR 
3eed cd 6c fe			call debug_vector  
3ef0				endm  
# End of macro CALLMONITOR
3ef0					endif 
3ef0 ed 5b ac fb			ld de, (LFSRSeed+2)   ; check low range 
3ef4					;call cmp16 
3ef4				 
3ef4 b7					or a  
3ef5 ed 52		                sbc hl, de 
3ef7 38 8c				jr c, .inrange 
3ef9			 
3ef9 e1					pop hl 
3efa					 
3efa					if DEBUG_FORTH_WORDS 
3efa						DMARK "RNd" 
3efa f5				push af  
3efb 3a 0f 3f			ld a, (.dmark)  
3efe 32 68 fe			ld (debug_mark),a  
3f01 3a 10 3f			ld a, (.dmark+1)  
3f04 32 69 fe			ld (debug_mark+1),a  
3f07 3a 11 3f			ld a, (.dmark+2)  
3f0a 32 6a fe			ld (debug_mark+2),a  
3f0d 18 03			jr .pastdmark  
3f0f ..			.dmark: db "RNd"  
3f12 f1			.pastdmark: pop af  
3f13			endm  
# End of macro DMARK
3f13						CALLMONITOR 
3f13 cd 6c fe			call debug_vector  
3f16				endm  
# End of macro CALLMONITOR
3f16					endif 
3f16			 
3f16			 
3f16 cd 15 21				call forth_push_numhl 
3f19				       NEXTW 
3f19 c3 c2 24			jp macro_next 
3f1c				endm 
# End of macro NEXTW
3f1c			 
3f1c			.ENDMATHS: 
3f1c			 
3f1c			; eof 
3f1c			 
# End of file forth_words_maths.asm
3f1c			include "forth_words_display.asm" 
3f1c			 
3f1c			; | ## Display Words 
3f1c			 
3f1c			.ACT: 
3f1c			 
3f1c				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f1c 62				db WORD_SYS_CORE+78             
3f1d 68 3f			dw .INFO            
3f1f 07				db 6 + 1 
3f20 .. 00			db "ACTIVE",0              
3f27				endm 
# End of macro CWHEAD
3f27			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f27			;  
3f27			; | | e.g. $ff $00 do active . $01 pause loop 
3f27			 
3f27					if DEBUG_FORTH_WORDS_KEY 
3f27						DMARK "ACT" 
3f27 f5				push af  
3f28 3a 3c 3f			ld a, (.dmark)  
3f2b 32 68 fe			ld (debug_mark),a  
3f2e 3a 3d 3f			ld a, (.dmark+1)  
3f31 32 69 fe			ld (debug_mark+1),a  
3f34 3a 3e 3f			ld a, (.dmark+2)  
3f37 32 6a fe			ld (debug_mark+2),a  
3f3a 18 03			jr .pastdmark  
3f3c ..			.dmark: db "ACT"  
3f3f f1			.pastdmark: pop af  
3f40			endm  
# End of macro DMARK
3f40						CALLMONITOR 
3f40 cd 6c fe			call debug_vector  
3f43				endm  
# End of macro CALLMONITOR
3f43					endif 
3f43 cd f3 0c				call active 
3f46					if DEBUG_FORTH_WORDS 
3f46						DMARK "ACp" 
3f46 f5				push af  
3f47 3a 5b 3f			ld a, (.dmark)  
3f4a 32 68 fe			ld (debug_mark),a  
3f4d 3a 5c 3f			ld a, (.dmark+1)  
3f50 32 69 fe			ld (debug_mark+1),a  
3f53 3a 5d 3f			ld a, (.dmark+2)  
3f56 32 6a fe			ld (debug_mark+2),a  
3f59 18 03			jr .pastdmark  
3f5b ..			.dmark: db "ACp"  
3f5e f1			.pastdmark: pop af  
3f5f			endm  
# End of macro DMARK
3f5f						CALLMONITOR 
3f5f cd 6c fe			call debug_vector  
3f62				endm  
# End of macro CALLMONITOR
3f62					endif 
3f62 cd 83 21				call forth_push_str 
3f65			 
3f65					NEXTW 
3f65 c3 c2 24			jp macro_next 
3f68				endm 
# End of macro NEXTW
3f68			.INFO: 
3f68			 
3f68				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f68 62				db WORD_SYS_CORE+78             
3f69 85 3f			dw .ATP            
3f6b 05				db 4 + 1 
3f6c .. 00			db "INFO",0              
3f71				endm 
# End of macro CWHEAD
3f71			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3f71					FORTH_DSP_VALUEHL 
3f71 cd 0c 23			call macro_dsp_valuehl 
3f74				endm 
# End of macro FORTH_DSP_VALUEHL
3f74			 
3f74					FORTH_DSP_POP 
3f74 cd c4 23			call macro_forth_dsp_pop 
3f77				endm 
# End of macro FORTH_DSP_POP
3f77			 
3f77 e5					push hl 
3f78			 
3f78					FORTH_DSP_VALUEHL 
3f78 cd 0c 23			call macro_dsp_valuehl 
3f7b				endm 
# End of macro FORTH_DSP_VALUEHL
3f7b			 
3f7b					FORTH_DSP_POP 
3f7b cd c4 23			call macro_forth_dsp_pop 
3f7e				endm 
# End of macro FORTH_DSP_POP
3f7e			 
3f7e d1					pop de 
3f7f			 
3f7f cd 2d 0d				call info_panel 
3f82			 
3f82			 
3f82					NEXTW 
3f82 c3 c2 24			jp macro_next 
3f85				endm 
# End of macro NEXTW
3f85			.ATP: 
3f85				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f85 62				db WORD_SYS_CORE+78             
3f86 fc 3f			dw .FB            
3f88 04				db 3 + 1 
3f89 .. 00			db "AT?",0              
3f8d				endm 
# End of macro CWHEAD
3f8d			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f8d					if DEBUG_FORTH_WORDS_KEY 
3f8d						DMARK "AT?" 
3f8d f5				push af  
3f8e 3a a2 3f			ld a, (.dmark)  
3f91 32 68 fe			ld (debug_mark),a  
3f94 3a a3 3f			ld a, (.dmark+1)  
3f97 32 69 fe			ld (debug_mark+1),a  
3f9a 3a a4 3f			ld a, (.dmark+2)  
3f9d 32 6a fe			ld (debug_mark+2),a  
3fa0 18 03			jr .pastdmark  
3fa2 ..			.dmark: db "AT?"  
3fa5 f1			.pastdmark: pop af  
3fa6			endm  
# End of macro DMARK
3fa6						CALLMONITOR 
3fa6 cd 6c fe			call debug_vector  
3fa9				endm  
# End of macro CALLMONITOR
3fa9					endif 
3fa9 3a 5b fa				ld a, (f_cursor_ptr) 
3fac			 
3fac			if DEBUG_FORTH_WORDS 
3fac				DMARK "AT?" 
3fac f5				push af  
3fad 3a c1 3f			ld a, (.dmark)  
3fb0 32 68 fe			ld (debug_mark),a  
3fb3 3a c2 3f			ld a, (.dmark+1)  
3fb6 32 69 fe			ld (debug_mark+1),a  
3fb9 3a c3 3f			ld a, (.dmark+2)  
3fbc 32 6a fe			ld (debug_mark+2),a  
3fbf 18 03			jr .pastdmark  
3fc1 ..			.dmark: db "AT?"  
3fc4 f1			.pastdmark: pop af  
3fc5			endm  
# End of macro DMARK
3fc5				CALLMONITOR 
3fc5 cd 6c fe			call debug_vector  
3fc8				endm  
# End of macro CALLMONITOR
3fc8			endif	 
3fc8					; count the number of rows 
3fc8			 
3fc8 06 00				ld b, 0 
3fca 4f			.atpr:		ld c, a    ; save in case we go below zero 
3fcb d6 28				sub display_cols 
3fcd f2 d3 3f				jp p, .atprunder 
3fd0 04					inc b 
3fd1 18 f7				jr .atpr 
3fd3			.atprunder:	 
3fd3			if DEBUG_FORTH_WORDS 
3fd3				DMARK "A?2" 
3fd3 f5				push af  
3fd4 3a e8 3f			ld a, (.dmark)  
3fd7 32 68 fe			ld (debug_mark),a  
3fda 3a e9 3f			ld a, (.dmark+1)  
3fdd 32 69 fe			ld (debug_mark+1),a  
3fe0 3a ea 3f			ld a, (.dmark+2)  
3fe3 32 6a fe			ld (debug_mark+2),a  
3fe6 18 03			jr .pastdmark  
3fe8 ..			.dmark: db "A?2"  
3feb f1			.pastdmark: pop af  
3fec			endm  
# End of macro DMARK
3fec				CALLMONITOR 
3fec cd 6c fe			call debug_vector  
3fef				endm  
# End of macro CALLMONITOR
3fef			endif	 
3fef 26 00				ld h, 0 
3ff1 69					ld l, c 
3ff2 cd 15 21				call forth_push_numhl 
3ff5 68					ld l, b  
3ff6 cd 15 21				call forth_push_numhl 
3ff9			 
3ff9			 
3ff9				NEXTW 
3ff9 c3 c2 24			jp macro_next 
3ffc				endm 
# End of macro NEXTW
3ffc			 
3ffc			.FB: 
3ffc				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ffc 1b				db WORD_SYS_CORE+7             
3ffd 4a 40			dw .EMIT            
3fff 03				db 2 + 1 
4000 .. 00			db "FB",0              
4003				endm 
# End of macro CWHEAD
4003			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
4003			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
4003			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
4003			; | | If automatic display is off then updates will not be shown until DRAW is used. 
4003					if DEBUG_FORTH_WORDS_KEY 
4003						DMARK "FB." 
4003 f5				push af  
4004 3a 18 40			ld a, (.dmark)  
4007 32 68 fe			ld (debug_mark),a  
400a 3a 19 40			ld a, (.dmark+1)  
400d 32 69 fe			ld (debug_mark+1),a  
4010 3a 1a 40			ld a, (.dmark+2)  
4013 32 6a fe			ld (debug_mark+2),a  
4016 18 03			jr .pastdmark  
4018 ..			.dmark: db "FB."  
401b f1			.pastdmark: pop af  
401c			endm  
# End of macro DMARK
401c						CALLMONITOR 
401c cd 6c fe			call debug_vector  
401f				endm  
# End of macro CALLMONITOR
401f					endif 
401f			 
401f					FORTH_DSP_VALUEHL 
401f cd 0c 23			call macro_dsp_valuehl 
4022				endm 
# End of macro FORTH_DSP_VALUEHL
4022			 
4022 7d					ld a, l 
4023 fe 01				cp 1 
4025 20 05				jr nz, .fbn1 
4027 21 0d fd				ld hl, display_fb1 
402a 18 15				jr .fbset 
402c fe 02		.fbn1:		cp 2 
402e 20 05				jr nz, .fbn2 
4030 21 cb fb				ld hl, display_fb2 
4033 18 0c				jr .fbset 
4035 fe 03		.fbn2:		cp 3 
4037 20 05				jr nz, .fbn3 
4039 21 6c fc				ld hl, display_fb3 
403c 18 03				jr .fbset 
403e			.fbn3:		 ; if invalid number select first 
403e 21 0d fd				ld hl, display_fb1 
4041 22 c9 fb		.fbset:		ld (display_fb_active), hl 
4044			 
4044					FORTH_DSP_POP 
4044 cd c4 23			call macro_forth_dsp_pop 
4047				endm 
# End of macro FORTH_DSP_POP
4047			 
4047					NEXTW 
4047 c3 c2 24			jp macro_next 
404a				endm 
# End of macro NEXTW
404a			 
404a			 
404a			.EMIT: 
404a				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
404a 1b				db WORD_SYS_CORE+7             
404b 9b 40			dw .DOTH            
404d 05				db 4 + 1 
404e .. 00			db "EMIT",0              
4053				endm 
# End of macro CWHEAD
4053			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4053					; get value off TOS and display it 
4053			 
4053					if DEBUG_FORTH_WORDS_KEY 
4053						DMARK "EMT" 
4053 f5				push af  
4054 3a 68 40			ld a, (.dmark)  
4057 32 68 fe			ld (debug_mark),a  
405a 3a 69 40			ld a, (.dmark+1)  
405d 32 69 fe			ld (debug_mark+1),a  
4060 3a 6a 40			ld a, (.dmark+2)  
4063 32 6a fe			ld (debug_mark+2),a  
4066 18 03			jr .pastdmark  
4068 ..			.dmark: db "EMT"  
406b f1			.pastdmark: pop af  
406c			endm  
# End of macro DMARK
406c						CALLMONITOR 
406c cd 6c fe			call debug_vector  
406f				endm  
# End of macro CALLMONITOR
406f					endif 
406f			 
406f					FORTH_DSP_VALUEHL 
406f cd 0c 23			call macro_dsp_valuehl 
4072				endm 
# End of macro FORTH_DSP_VALUEHL
4072			 
4072 7d					ld a,l 
4073			 
4073					; TODO write to display 
4073			 
4073 32 bc f3				ld (os_input), a 
4076 3e 00				ld a, 0 
4078 32 bd f3				ld (os_input+1), a 
407b					 
407b 3a 5b fa				ld a, (f_cursor_ptr) 
407e 11 bc f3				ld de, os_input 
4081 cd af 0d				call str_at_display 
4084			 
4084			 
4084 3a 39 fa				ld a,(cli_autodisplay) 
4087 fe 00				cp 0 
4089 28 03				jr z, .enoupdate 
408b cd bf 0d						call update_display 
408e					.enoupdate: 
408e			 
408e 3a 5b fa				ld a, (f_cursor_ptr) 
4091 3c					inc a 
4092 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
4095			 
4095			 
4095					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4095 cd c4 23			call macro_forth_dsp_pop 
4098				endm 
# End of macro FORTH_DSP_POP
4098			  
4098			 
4098					NEXTW 
4098 c3 c2 24			jp macro_next 
409b				endm 
# End of macro NEXTW
409b			.DOTH: 
409b				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
409b 1c				db WORD_SYS_CORE+8             
409c cb 40			dw .DOTF            
409e 03				db 2 + 1 
409f .. 00			db ".-",0              
40a2				endm 
# End of macro CWHEAD
40a2			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
40a2					; get value off TOS and display it 
40a2					if DEBUG_FORTH_WORDS_KEY 
40a2						DMARK "DTD" 
40a2 f5				push af  
40a3 3a b7 40			ld a, (.dmark)  
40a6 32 68 fe			ld (debug_mark),a  
40a9 3a b8 40			ld a, (.dmark+1)  
40ac 32 69 fe			ld (debug_mark+1),a  
40af 3a b9 40			ld a, (.dmark+2)  
40b2 32 6a fe			ld (debug_mark+2),a  
40b5 18 03			jr .pastdmark  
40b7 ..			.dmark: db "DTD"  
40ba f1			.pastdmark: pop af  
40bb			endm  
# End of macro DMARK
40bb						CALLMONITOR 
40bb cd 6c fe			call debug_vector  
40be				endm  
# End of macro CALLMONITOR
40be					endif 
40be 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40c0 3e 00			ld a, 0 
40c2 32 3a fa			ld (cli_mvdot), a 
40c5 c3 22 41			jp .dotgo 
40c8				NEXTW 
40c8 c3 c2 24			jp macro_next 
40cb				endm 
# End of macro NEXTW
40cb			.DOTF: 
40cb				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
40cb 1c				db WORD_SYS_CORE+8             
40cc f9 40			dw .DOT            
40ce 03				db 2 + 1 
40cf .. 00			db ".>",0              
40d2				endm 
# End of macro CWHEAD
40d2			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
40d2					; get value off TOS and display it 
40d2			        ; TODO BUG adds extra spaces 
40d2			        ; TODO BUG handle numerics? 
40d2					if DEBUG_FORTH_WORDS_KEY 
40d2						DMARK "DTC" 
40d2 f5				push af  
40d3 3a e7 40			ld a, (.dmark)  
40d6 32 68 fe			ld (debug_mark),a  
40d9 3a e8 40			ld a, (.dmark+1)  
40dc 32 69 fe			ld (debug_mark+1),a  
40df 3a e9 40			ld a, (.dmark+2)  
40e2 32 6a fe			ld (debug_mark+2),a  
40e5 18 03			jr .pastdmark  
40e7 ..			.dmark: db "DTC"  
40ea f1			.pastdmark: pop af  
40eb			endm  
# End of macro DMARK
40eb						CALLMONITOR 
40eb cd 6c fe			call debug_vector  
40ee				endm  
# End of macro CALLMONITOR
40ee					endif 
40ee 3e 01			ld a, 1 
40f0 32 3a fa			ld (cli_mvdot), a 
40f3 c3 22 41			jp .dotgo 
40f6				NEXTW 
40f6 c3 c2 24			jp macro_next 
40f9				endm 
# End of macro NEXTW
40f9			 
40f9			.DOT: 
40f9				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
40f9 1c				db WORD_SYS_CORE+8             
40fa d5 42			dw .CLS            
40fc 02				db 1 + 1 
40fd .. 00			db ".",0              
40ff				endm 
# End of macro CWHEAD
40ff			        ; | . ( u -- ) Display TOS | DONE 
40ff					; get value off TOS and display it 
40ff			 
40ff					if DEBUG_FORTH_WORDS_KEY 
40ff						DMARK "DOT" 
40ff f5				push af  
4100 3a 14 41			ld a, (.dmark)  
4103 32 68 fe			ld (debug_mark),a  
4106 3a 15 41			ld a, (.dmark+1)  
4109 32 69 fe			ld (debug_mark+1),a  
410c 3a 16 41			ld a, (.dmark+2)  
410f 32 6a fe			ld (debug_mark+2),a  
4112 18 03			jr .pastdmark  
4114 ..			.dmark: db "DOT"  
4117 f1			.pastdmark: pop af  
4118			endm  
# End of macro DMARK
4118						CALLMONITOR 
4118 cd 6c fe			call debug_vector  
411b				endm  
# End of macro CALLMONITOR
411b					endif 
411b 3e 00			ld a, 0 
411d 32 3a fa			ld (cli_mvdot), a 
4120 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4122				 
4122			 
4122			.dotgo: 
4122			 
4122			; move up type to on stack for parserv5 
4122					FORTH_DSP 
4122 cd d2 22			call macro_forth_dsp 
4125				endm 
# End of macro FORTH_DSP
4125				;FORTH_DSP_VALUE  
4125			 
4125			if DEBUG_FORTH_DOT 
4125				DMARK "DOT" 
4125 f5				push af  
4126 3a 3a 41			ld a, (.dmark)  
4129 32 68 fe			ld (debug_mark),a  
412c 3a 3b 41			ld a, (.dmark+1)  
412f 32 69 fe			ld (debug_mark+1),a  
4132 3a 3c 41			ld a, (.dmark+2)  
4135 32 6a fe			ld (debug_mark+2),a  
4138 18 03			jr .pastdmark  
413a ..			.dmark: db "DOT"  
413d f1			.pastdmark: pop af  
413e			endm  
# End of macro DMARK
413e				CALLMONITOR 
413e cd 6c fe			call debug_vector  
4141				endm  
# End of macro CALLMONITOR
4141			endif	 
4141			;		.print: 
4141			 
4141 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4142 23				inc hl   ; position to the actual value 
4143 fe 01			cp DS_TYPE_STR 
4145 20 06			jr nz, .dotnum1  
4147			 
4147			; display string 
4147				FORTH_DSP_VALUE  
4147 cd f5 22			call macro_forth_dsp_value 
414a				endm 
# End of macro FORTH_DSP_VALUE
414a eb				ex de,hl 
414b 18 49			jr .dotwrite 
414d			 
414d			.dotnum1: 
414d fe 02			cp DS_TYPE_INUM 
414f 20 44			jr nz, .dotflot 
4151			 
4151			 
4151			; display number 
4151			 
4151			;	push hl 
4151			;	call clear_display 
4151			;	pop hl 
4151			 
4151 5e				ld e, (hl) 
4152 23				inc hl 
4153 56				ld d, (hl) 
4154 21 be f1			ld hl, scratch 
4157			if DEBUG_FORTH_DOT 
4157				DMARK "DT1" 
4157 f5				push af  
4158 3a 6c 41			ld a, (.dmark)  
415b 32 68 fe			ld (debug_mark),a  
415e 3a 6d 41			ld a, (.dmark+1)  
4161 32 69 fe			ld (debug_mark+1),a  
4164 3a 6e 41			ld a, (.dmark+2)  
4167 32 6a fe			ld (debug_mark+2),a  
416a 18 03			jr .pastdmark  
416c ..			.dmark: db "DT1"  
416f f1			.pastdmark: pop af  
4170			endm  
# End of macro DMARK
4170				CALLMONITOR 
4170 cd 6c fe			call debug_vector  
4173				endm  
# End of macro CALLMONITOR
4173			endif	 
4173			 
4173 cd dd 13			call uitoa_16 
4176 eb				ex de,hl 
4177			 
4177			if DEBUG_FORTH_DOT 
4177				DMARK "DT2" 
4177 f5				push af  
4178 3a 8c 41			ld a, (.dmark)  
417b 32 68 fe			ld (debug_mark),a  
417e 3a 8d 41			ld a, (.dmark+1)  
4181 32 69 fe			ld (debug_mark+1),a  
4184 3a 8e 41			ld a, (.dmark+2)  
4187 32 6a fe			ld (debug_mark+2),a  
418a 18 03			jr .pastdmark  
418c ..			.dmark: db "DT2"  
418f f1			.pastdmark: pop af  
4190			endm  
# End of macro DMARK
4190				CALLMONITOR 
4190 cd 6c fe			call debug_vector  
4193				endm  
# End of macro CALLMONITOR
4193			endif	 
4193			 
4193			;	ld de, os_word_scratch 
4193 18 01			jr .dotwrite 
4195			 
4195 00			.dotflot:   nop 
4196			; TODO print floating point number 
4196			 
4196			.dotwrite:		 
4196			 
4196					; if c is set then set all '-' to spaces 
4196					; need to also take into account .>  
4196			 
4196 3e 01				ld a, 1 
4198 b9					cp c 
4199 20 67				jr nz, .nodashswap 
419b			 
419b					; DE has the string to write, working with HL 
419b			 
419b 06 ff				ld b, 255 
419d d5					push de 
419e e1					pop hl 
419f			 
419f			if DEBUG_FORTH_DOT 
419f				DMARK "DT-" 
419f f5				push af  
41a0 3a b4 41			ld a, (.dmark)  
41a3 32 68 fe			ld (debug_mark),a  
41a6 3a b5 41			ld a, (.dmark+1)  
41a9 32 69 fe			ld (debug_mark+1),a  
41ac 3a b6 41			ld a, (.dmark+2)  
41af 32 6a fe			ld (debug_mark+2),a  
41b2 18 03			jr .pastdmark  
41b4 ..			.dmark: db "DT-"  
41b7 f1			.pastdmark: pop af  
41b8			endm  
# End of macro DMARK
41b8				CALLMONITOR 
41b8 cd 6c fe			call debug_vector  
41bb				endm  
# End of macro CALLMONITOR
41bb			endif	 
41bb 7e			.dashscan:	ld a, (hl) 
41bc fe 00				cp 0 
41be 28 42				jr z, .nodashswap 
41c0 fe 2d				cp '-' 
41c2 20 03				jr nz, .dashskip 
41c4 3e 20				ld a, ' ' 
41c6 77					ld (hl), a 
41c7 23			.dashskip:	inc hl 
41c8			if DEBUG_FORTH_DOT 
41c8				DMARK "D-2" 
41c8 f5				push af  
41c9 3a dd 41			ld a, (.dmark)  
41cc 32 68 fe			ld (debug_mark),a  
41cf 3a de 41			ld a, (.dmark+1)  
41d2 32 69 fe			ld (debug_mark+1),a  
41d5 3a df 41			ld a, (.dmark+2)  
41d8 32 6a fe			ld (debug_mark+2),a  
41db 18 03			jr .pastdmark  
41dd ..			.dmark: db "D-2"  
41e0 f1			.pastdmark: pop af  
41e1			endm  
# End of macro DMARK
41e1				CALLMONITOR 
41e1 cd 6c fe			call debug_vector  
41e4				endm  
# End of macro CALLMONITOR
41e4			endif	 
41e4 10 d5				djnz .dashscan 
41e6			 
41e6			if DEBUG_FORTH_DOT 
41e6				DMARK "D-1" 
41e6 f5				push af  
41e7 3a fb 41			ld a, (.dmark)  
41ea 32 68 fe			ld (debug_mark),a  
41ed 3a fc 41			ld a, (.dmark+1)  
41f0 32 69 fe			ld (debug_mark+1),a  
41f3 3a fd 41			ld a, (.dmark+2)  
41f6 32 6a fe			ld (debug_mark+2),a  
41f9 18 03			jr .pastdmark  
41fb ..			.dmark: db "D-1"  
41fe f1			.pastdmark: pop af  
41ff			endm  
# End of macro DMARK
41ff				CALLMONITOR 
41ff cd 6c fe			call debug_vector  
4202				endm  
# End of macro CALLMONITOR
4202			endif	 
4202			 
4202			.nodashswap: 
4202			 
4202			if DEBUG_FORTH_DOT 
4202				DMARK "D-o" 
4202 f5				push af  
4203 3a 17 42			ld a, (.dmark)  
4206 32 68 fe			ld (debug_mark),a  
4209 3a 18 42			ld a, (.dmark+1)  
420c 32 69 fe			ld (debug_mark+1),a  
420f 3a 19 42			ld a, (.dmark+2)  
4212 32 6a fe			ld (debug_mark+2),a  
4215 18 03			jr .pastdmark  
4217 ..			.dmark: db "D-o"  
421a f1			.pastdmark: pop af  
421b			endm  
# End of macro DMARK
421b				CALLMONITOR 
421b cd 6c fe			call debug_vector  
421e				endm  
# End of macro CALLMONITOR
421e			endif	 
421e			 
421e d5					push de   ; save string start in case we need to advance print 
421f			 
421f 3a 5b fa				ld a, (f_cursor_ptr) 
4222 cd af 0d				call str_at_display 
4225 3a 39 fa				ld a,(cli_autodisplay) 
4228 fe 00				cp 0 
422a 28 03				jr z, .noupdate 
422c cd bf 0d						call update_display 
422f					.noupdate: 
422f			 
422f			 
422f					; see if we need to advance the print position 
422f			 
422f e1					pop hl   ; get back string 
4230			;		ex de,hl 
4230			 
4230 3a 3a fa				ld a, (cli_mvdot) 
4233			if DEBUG_FORTH_DOT 
4233			;		ld e,a 
4233				DMARK "D>1" 
4233 f5				push af  
4234 3a 48 42			ld a, (.dmark)  
4237 32 68 fe			ld (debug_mark),a  
423a 3a 49 42			ld a, (.dmark+1)  
423d 32 69 fe			ld (debug_mark+1),a  
4240 3a 4a 42			ld a, (.dmark+2)  
4243 32 6a fe			ld (debug_mark+2),a  
4246 18 03			jr .pastdmark  
4248 ..			.dmark: db "D>1"  
424b f1			.pastdmark: pop af  
424c			endm  
# End of macro DMARK
424c				CALLMONITOR 
424c cd 6c fe			call debug_vector  
424f				endm  
# End of macro CALLMONITOR
424f			endif	 
424f fe 00				cp 0 
4251 28 44				jr z, .noadv 
4253					; yes, lets advance the print position 
4253 3e 00				ld a, 0 
4255 cd 39 14				call strlent 
4258			if DEBUG_FORTH_DOT 
4258				DMARK "D-?" 
4258 f5				push af  
4259 3a 6d 42			ld a, (.dmark)  
425c 32 68 fe			ld (debug_mark),a  
425f 3a 6e 42			ld a, (.dmark+1)  
4262 32 69 fe			ld (debug_mark+1),a  
4265 3a 6f 42			ld a, (.dmark+2)  
4268 32 6a fe			ld (debug_mark+2),a  
426b 18 03			jr .pastdmark  
426d ..			.dmark: db "D-?"  
4270 f1			.pastdmark: pop af  
4271			endm  
# End of macro DMARK
4271				CALLMONITOR 
4271 cd 6c fe			call debug_vector  
4274				endm  
# End of macro CALLMONITOR
4274			endif	 
4274 3a 5b fa				ld a, (f_cursor_ptr) 
4277 85					add a,l 
4278					;call addatohl 
4278					;ld a, l 
4278 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
427b			 
427b			if DEBUG_FORTH_DOT 
427b				DMARK "D->" 
427b f5				push af  
427c 3a 90 42			ld a, (.dmark)  
427f 32 68 fe			ld (debug_mark),a  
4282 3a 91 42			ld a, (.dmark+1)  
4285 32 69 fe			ld (debug_mark+1),a  
4288 3a 92 42			ld a, (.dmark+2)  
428b 32 6a fe			ld (debug_mark+2),a  
428e 18 03			jr .pastdmark  
4290 ..			.dmark: db "D->"  
4293 f1			.pastdmark: pop af  
4294			endm  
# End of macro DMARK
4294				CALLMONITOR 
4294 cd 6c fe			call debug_vector  
4297				endm  
# End of macro CALLMONITOR
4297			endif	 
4297			 
4297			.noadv:	 
4297			 
4297					if DEBUG_FORTH_DOT_WAIT 
4297							call next_page_prompt 
4297					endif	 
4297			; TODO this pop off the stack causes a crash. i dont know why 
4297			 
4297			 
4297			if DEBUG_FORTH_DOT 
4297				DMARK "DTh" 
4297 f5				push af  
4298 3a ac 42			ld a, (.dmark)  
429b 32 68 fe			ld (debug_mark),a  
429e 3a ad 42			ld a, (.dmark+1)  
42a1 32 69 fe			ld (debug_mark+1),a  
42a4 3a ae 42			ld a, (.dmark+2)  
42a7 32 6a fe			ld (debug_mark+2),a  
42aa 18 03			jr .pastdmark  
42ac ..			.dmark: db "DTh"  
42af f1			.pastdmark: pop af  
42b0			endm  
# End of macro DMARK
42b0				CALLMONITOR 
42b0 cd 6c fe			call debug_vector  
42b3				endm  
# End of macro CALLMONITOR
42b3			endif	 
42b3			 
42b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42b3 cd c4 23			call macro_forth_dsp_pop 
42b6				endm 
# End of macro FORTH_DSP_POP
42b6			 
42b6			if DEBUG_FORTH_DOT 
42b6				DMARK "DTi" 
42b6 f5				push af  
42b7 3a cb 42			ld a, (.dmark)  
42ba 32 68 fe			ld (debug_mark),a  
42bd 3a cc 42			ld a, (.dmark+1)  
42c0 32 69 fe			ld (debug_mark+1),a  
42c3 3a cd 42			ld a, (.dmark+2)  
42c6 32 6a fe			ld (debug_mark+2),a  
42c9 18 03			jr .pastdmark  
42cb ..			.dmark: db "DTi"  
42ce f1			.pastdmark: pop af  
42cf			endm  
# End of macro DMARK
42cf				CALLMONITOR 
42cf cd 6c fe			call debug_vector  
42d2				endm  
# End of macro CALLMONITOR
42d2			endif	 
42d2			 
42d2			 
42d2					NEXTW 
42d2 c3 c2 24			jp macro_next 
42d5				endm 
# End of macro NEXTW
42d5			 
42d5			.CLS: 
42d5				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
42d5 35				db WORD_SYS_CORE+33             
42d6 02 43			dw .DRAW            
42d8 04				db 3 + 1 
42d9 .. 00			db "CLS",0              
42dd				endm 
# End of macro CWHEAD
42dd			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
42dd					if DEBUG_FORTH_WORDS_KEY 
42dd						DMARK "CLS" 
42dd f5				push af  
42de 3a f2 42			ld a, (.dmark)  
42e1 32 68 fe			ld (debug_mark),a  
42e4 3a f3 42			ld a, (.dmark+1)  
42e7 32 69 fe			ld (debug_mark+1),a  
42ea 3a f4 42			ld a, (.dmark+2)  
42ed 32 6a fe			ld (debug_mark+2),a  
42f0 18 03			jr .pastdmark  
42f2 ..			.dmark: db "CLS"  
42f5 f1			.pastdmark: pop af  
42f6			endm  
# End of macro DMARK
42f6						CALLMONITOR 
42f6 cd 6c fe			call debug_vector  
42f9				endm  
# End of macro CALLMONITOR
42f9					endif 
42f9 cd 9c 0d				call clear_display 
42fc c3 10 44				jp .home		; and home cursor 
42ff					NEXTW 
42ff c3 c2 24			jp macro_next 
4302				endm 
# End of macro NEXTW
4302			 
4302			.DRAW: 
4302				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4302 36				db WORD_SYS_CORE+34             
4303 2d 43			dw .DUMP            
4305 05				db 4 + 1 
4306 .. 00			db "DRAW",0              
430b				endm 
# End of macro CWHEAD
430b			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
430b					if DEBUG_FORTH_WORDS_KEY 
430b						DMARK "DRW" 
430b f5				push af  
430c 3a 20 43			ld a, (.dmark)  
430f 32 68 fe			ld (debug_mark),a  
4312 3a 21 43			ld a, (.dmark+1)  
4315 32 69 fe			ld (debug_mark+1),a  
4318 3a 22 43			ld a, (.dmark+2)  
431b 32 6a fe			ld (debug_mark+2),a  
431e 18 03			jr .pastdmark  
4320 ..			.dmark: db "DRW"  
4323 f1			.pastdmark: pop af  
4324			endm  
# End of macro DMARK
4324						CALLMONITOR 
4324 cd 6c fe			call debug_vector  
4327				endm  
# End of macro CALLMONITOR
4327					endif 
4327 cd bf 0d				call update_display 
432a					NEXTW 
432a c3 c2 24			jp macro_next 
432d				endm 
# End of macro NEXTW
432d			 
432d			.DUMP: 
432d				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
432d 37				db WORD_SYS_CORE+35             
432e 65 43			dw .CDUMP            
4330 05				db 4 + 1 
4331 .. 00			db "DUMP",0              
4336				endm 
# End of macro CWHEAD
4336			; | DUMP ( x -- ) With address x display dump   | DONE 
4336			; TODO pop address to use off of the stack 
4336					if DEBUG_FORTH_WORDS_KEY 
4336						DMARK "DUM" 
4336 f5				push af  
4337 3a 4b 43			ld a, (.dmark)  
433a 32 68 fe			ld (debug_mark),a  
433d 3a 4c 43			ld a, (.dmark+1)  
4340 32 69 fe			ld (debug_mark+1),a  
4343 3a 4d 43			ld a, (.dmark+2)  
4346 32 6a fe			ld (debug_mark+2),a  
4349 18 03			jr .pastdmark  
434b ..			.dmark: db "DUM"  
434e f1			.pastdmark: pop af  
434f			endm  
# End of macro DMARK
434f						CALLMONITOR 
434f cd 6c fe			call debug_vector  
4352				endm  
# End of macro CALLMONITOR
4352					endif 
4352 cd 9c 0d				call clear_display 
4355			 
4355					; get address 
4355			 
4355					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4355 cd 0c 23			call macro_dsp_valuehl 
4358				endm 
# End of macro FORTH_DSP_VALUEHL
4358				 
4358					; save it for cdump 
4358			 
4358 22 e1 f4				ld (os_cur_ptr),hl 
435b			 
435b					; destroy value TOS 
435b			 
435b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
435b cd c4 23			call macro_forth_dsp_pop 
435e				endm 
# End of macro FORTH_DSP_POP
435e			 
435e cd 95 1f				call dumpcont	; skip old style of param parsing	 
4361 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4362					NEXTW 
4362 c3 c2 24			jp macro_next 
4365				endm 
# End of macro NEXTW
4365			.CDUMP: 
4365				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4365 38				db WORD_SYS_CORE+36             
4366 95 43			dw .DAT            
4368 06				db 5 + 1 
4369 .. 00			db "CDUMP",0              
436f				endm 
# End of macro CWHEAD
436f			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
436f					if DEBUG_FORTH_WORDS_KEY 
436f						DMARK "CDP" 
436f f5				push af  
4370 3a 84 43			ld a, (.dmark)  
4373 32 68 fe			ld (debug_mark),a  
4376 3a 85 43			ld a, (.dmark+1)  
4379 32 69 fe			ld (debug_mark+1),a  
437c 3a 86 43			ld a, (.dmark+2)  
437f 32 6a fe			ld (debug_mark+2),a  
4382 18 03			jr .pastdmark  
4384 ..			.dmark: db "CDP"  
4387 f1			.pastdmark: pop af  
4388			endm  
# End of macro DMARK
4388						CALLMONITOR 
4388 cd 6c fe			call debug_vector  
438b				endm  
# End of macro CALLMONITOR
438b					endif 
438b cd 9c 0d				call clear_display 
438e cd 95 1f				call dumpcont	 
4391 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4392					NEXTW 
4392 c3 c2 24			jp macro_next 
4395				endm 
# End of macro NEXTW
4395			 
4395			 
4395			 
4395			 
4395			.DAT: 
4395				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4395 3d				db WORD_SYS_CORE+41             
4396 eb 43			dw .HOME            
4398 03				db 2 + 1 
4399 .. 00			db "AT",0              
439c				endm 
# End of macro CWHEAD
439c			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
439c					if DEBUG_FORTH_WORDS_KEY 
439c						DMARK "AT." 
439c f5				push af  
439d 3a b1 43			ld a, (.dmark)  
43a0 32 68 fe			ld (debug_mark),a  
43a3 3a b2 43			ld a, (.dmark+1)  
43a6 32 69 fe			ld (debug_mark+1),a  
43a9 3a b3 43			ld a, (.dmark+2)  
43ac 32 6a fe			ld (debug_mark+2),a  
43af 18 03			jr .pastdmark  
43b1 ..			.dmark: db "AT."  
43b4 f1			.pastdmark: pop af  
43b5			endm  
# End of macro DMARK
43b5						CALLMONITOR 
43b5 cd 6c fe			call debug_vector  
43b8				endm  
# End of macro CALLMONITOR
43b8					endif 
43b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43b8 cd 0c 23			call macro_dsp_valuehl 
43bb				endm 
# End of macro FORTH_DSP_VALUEHL
43bb			 
43bb			 
43bb					; TODO save cursor row 
43bb 7d					ld a,l 
43bc fe 02				cp 2 
43be 20 04				jr nz, .crow3 
43c0 3e 28				ld a, display_row_2 
43c2 18 12				jr .ccol1 
43c4 fe 03		.crow3:		cp 3 
43c6 20 04				jr nz, .crow4 
43c8 3e 50				ld a, display_row_3 
43ca 18 0a				jr .ccol1 
43cc fe 04		.crow4:		cp 4 
43ce 20 04				jr nz, .crow1 
43d0 3e 78				ld a, display_row_4 
43d2 18 02				jr .ccol1 
43d4 3e 00		.crow1:		ld a,display_row_1 
43d6 f5			.ccol1:		push af			; got row offset 
43d7 6f					ld l,a 
43d8 26 00				ld h,0 
43da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43da cd c4 23			call macro_forth_dsp_pop 
43dd				endm 
# End of macro FORTH_DSP_POP
43dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43dd cd 0c 23			call macro_dsp_valuehl 
43e0				endm 
# End of macro FORTH_DSP_VALUEHL
43e0					; TODO save cursor col 
43e0 f1					pop af 
43e1 85					add l		; add col offset 
43e2 32 5b fa				ld (f_cursor_ptr), a 
43e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43e5 cd c4 23			call macro_forth_dsp_pop 
43e8				endm 
# End of macro FORTH_DSP_POP
43e8			 
43e8					; calculate  
43e8			 
43e8					NEXTW 
43e8 c3 c2 24			jp macro_next 
43eb				endm 
# End of macro NEXTW
43eb			 
43eb			 
43eb			.HOME: 
43eb				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
43eb 41				db WORD_SYS_CORE+45             
43ec 18 44			dw .SPACE            
43ee 05				db 4 + 1 
43ef .. 00			db "HOME",0              
43f4				endm 
# End of macro CWHEAD
43f4			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
43f4					if DEBUG_FORTH_WORDS_KEY 
43f4						DMARK "HOM" 
43f4 f5				push af  
43f5 3a 09 44			ld a, (.dmark)  
43f8 32 68 fe			ld (debug_mark),a  
43fb 3a 0a 44			ld a, (.dmark+1)  
43fe 32 69 fe			ld (debug_mark+1),a  
4401 3a 0b 44			ld a, (.dmark+2)  
4404 32 6a fe			ld (debug_mark+2),a  
4407 18 03			jr .pastdmark  
4409 ..			.dmark: db "HOM"  
440c f1			.pastdmark: pop af  
440d			endm  
# End of macro DMARK
440d						CALLMONITOR 
440d cd 6c fe			call debug_vector  
4410				endm  
# End of macro CALLMONITOR
4410					endif 
4410 3e 00		.home:		ld a, 0		; and home cursor 
4412 32 5b fa				ld (f_cursor_ptr), a 
4415					NEXTW 
4415 c3 c2 24			jp macro_next 
4418				endm 
# End of macro NEXTW
4418			 
4418			 
4418			.SPACE: 
4418				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4418 46				db WORD_SYS_CORE+50             
4419 4e 44			dw .SPACES            
441b 03				db 2 + 1 
441c .. 00			db "BL",0              
441f				endm 
# End of macro CWHEAD
441f			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
441f					if DEBUG_FORTH_WORDS_KEY 
441f						DMARK "BL." 
441f f5				push af  
4420 3a 34 44			ld a, (.dmark)  
4423 32 68 fe			ld (debug_mark),a  
4426 3a 35 44			ld a, (.dmark+1)  
4429 32 69 fe			ld (debug_mark+1),a  
442c 3a 36 44			ld a, (.dmark+2)  
442f 32 6a fe			ld (debug_mark+2),a  
4432 18 03			jr .pastdmark  
4434 ..			.dmark: db "BL."  
4437 f1			.pastdmark: pop af  
4438			endm  
# End of macro DMARK
4438						CALLMONITOR 
4438 cd 6c fe			call debug_vector  
443b				endm  
# End of macro CALLMONITOR
443b					endif 
443b 3e 20				ld a, " " 
443d 32 be f1				ld (scratch),a 
4440 3e 00				ld a, 0 
4442 32 bf f1				ld (scratch+1),a 
4445 21 be f1				ld hl, scratch 
4448 cd 83 21				call forth_push_str 
444b					 
444b				       NEXTW 
444b c3 c2 24			jp macro_next 
444e				endm 
# End of macro NEXTW
444e			 
444e			;.blstr: db " ", 0 
444e			 
444e			.SPACES: 
444e				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
444e 47				db WORD_SYS_CORE+51             
444f e9 44			dw .SCROLL            
4451 07				db 6 + 1 
4452 .. 00			db "SPACES",0              
4459				endm 
# End of macro CWHEAD
4459			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4459					if DEBUG_FORTH_WORDS_KEY 
4459						DMARK "SPS" 
4459 f5				push af  
445a 3a 6e 44			ld a, (.dmark)  
445d 32 68 fe			ld (debug_mark),a  
4460 3a 6f 44			ld a, (.dmark+1)  
4463 32 69 fe			ld (debug_mark+1),a  
4466 3a 70 44			ld a, (.dmark+2)  
4469 32 6a fe			ld (debug_mark+2),a  
446c 18 03			jr .pastdmark  
446e ..			.dmark: db "SPS"  
4471 f1			.pastdmark: pop af  
4472			endm  
# End of macro DMARK
4472						CALLMONITOR 
4472 cd 6c fe			call debug_vector  
4475				endm  
# End of macro CALLMONITOR
4475					endif 
4475			 
4475			 
4475					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4475 cd 0c 23			call macro_dsp_valuehl 
4478				endm 
# End of macro FORTH_DSP_VALUEHL
4478			 
4478 e5					push hl    ; u 
4479					if DEBUG_FORTH_WORDS 
4479						DMARK "SPA" 
4479 f5				push af  
447a 3a 8e 44			ld a, (.dmark)  
447d 32 68 fe			ld (debug_mark),a  
4480 3a 8f 44			ld a, (.dmark+1)  
4483 32 69 fe			ld (debug_mark+1),a  
4486 3a 90 44			ld a, (.dmark+2)  
4489 32 6a fe			ld (debug_mark+2),a  
448c 18 03			jr .pastdmark  
448e ..			.dmark: db "SPA"  
4491 f1			.pastdmark: pop af  
4492			endm  
# End of macro DMARK
4492						CALLMONITOR 
4492 cd 6c fe			call debug_vector  
4495				endm  
# End of macro CALLMONITOR
4495					endif 
4495			 
4495					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4495 cd c4 23			call macro_forth_dsp_pop 
4498				endm 
# End of macro FORTH_DSP_POP
4498 e1					pop hl 
4499 0e 00				ld c, 0 
449b 45					ld b, l 
449c 21 be f1				ld hl, scratch  
449f			 
449f					if DEBUG_FORTH_WORDS 
449f						DMARK "SP2" 
449f f5				push af  
44a0 3a b4 44			ld a, (.dmark)  
44a3 32 68 fe			ld (debug_mark),a  
44a6 3a b5 44			ld a, (.dmark+1)  
44a9 32 69 fe			ld (debug_mark+1),a  
44ac 3a b6 44			ld a, (.dmark+2)  
44af 32 6a fe			ld (debug_mark+2),a  
44b2 18 03			jr .pastdmark  
44b4 ..			.dmark: db "SP2"  
44b7 f1			.pastdmark: pop af  
44b8			endm  
# End of macro DMARK
44b8						CALLMONITOR 
44b8 cd 6c fe			call debug_vector  
44bb				endm  
# End of macro CALLMONITOR
44bb					endif 
44bb 3e 20				ld a, ' ' 
44bd			.spaces1:	 
44bd 77					ld (hl),a 
44be 23					inc hl 
44bf					 
44bf 10 fc				djnz .spaces1 
44c1 3e 00				ld a,0 
44c3 77					ld (hl),a 
44c4 21 be f1				ld hl, scratch 
44c7					if DEBUG_FORTH_WORDS 
44c7						DMARK "SP3" 
44c7 f5				push af  
44c8 3a dc 44			ld a, (.dmark)  
44cb 32 68 fe			ld (debug_mark),a  
44ce 3a dd 44			ld a, (.dmark+1)  
44d1 32 69 fe			ld (debug_mark+1),a  
44d4 3a de 44			ld a, (.dmark+2)  
44d7 32 6a fe			ld (debug_mark+2),a  
44da 18 03			jr .pastdmark  
44dc ..			.dmark: db "SP3"  
44df f1			.pastdmark: pop af  
44e0			endm  
# End of macro DMARK
44e0						CALLMONITOR 
44e0 cd 6c fe			call debug_vector  
44e3				endm  
# End of macro CALLMONITOR
44e3					endif 
44e3 cd 83 21				call forth_push_str 
44e6			 
44e6				       NEXTW 
44e6 c3 c2 24			jp macro_next 
44e9				endm 
# End of macro NEXTW
44e9			 
44e9			 
44e9			 
44e9			.SCROLL: 
44e9				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
44e9 53				db WORD_SYS_CORE+63             
44ea 16 45			dw .SCROLLD            
44ec 07				db 6 + 1 
44ed .. 00			db "SCROLL",0              
44f4				endm 
# End of macro CWHEAD
44f4			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
44f4					if DEBUG_FORTH_WORDS_KEY 
44f4						DMARK "SCR" 
44f4 f5				push af  
44f5 3a 09 45			ld a, (.dmark)  
44f8 32 68 fe			ld (debug_mark),a  
44fb 3a 0a 45			ld a, (.dmark+1)  
44fe 32 69 fe			ld (debug_mark+1),a  
4501 3a 0b 45			ld a, (.dmark+2)  
4504 32 6a fe			ld (debug_mark+2),a  
4507 18 03			jr .pastdmark  
4509 ..			.dmark: db "SCR"  
450c f1			.pastdmark: pop af  
450d			endm  
# End of macro DMARK
450d						CALLMONITOR 
450d cd 6c fe			call debug_vector  
4510				endm  
# End of macro CALLMONITOR
4510					endif 
4510			 
4510 cd 5e 0d			call scroll_up 
4513			;	call update_display 
4513			 
4513					NEXTW 
4513 c3 c2 24			jp macro_next 
4516				endm 
# End of macro NEXTW
4516			 
4516			 
4516			 
4516			;		; get dir 
4516			; 
4516			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4516			; 
4516			;		push hl 
4516			; 
4516			;		; destroy value TOS 
4516			; 
4516			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4516			; 
4516			;		; get count 
4516			; 
4516			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4516			; 
4516			;		push hl 
4516			; 
4516			;		; destroy value TOS 
4516			; 
4516			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4516			; 
4516			;		; one value on hl get other one back 
4516			; 
4516			;		pop bc    ; count 
4516			; 
4516			;		pop de   ; dir 
4516			; 
4516			; 
4516			;		ld b, c 
4516			; 
4516			;.scrolldir:     push bc 
4516			;		push de 
4516			; 
4516			;		ld a, 0 
4516			;		cp e 
4516			;		jr z, .scrollup  
4516			;		call scroll_down 
4516			;		jr .scrollnext 
4516			;.scrollup:	call scroll_up 
4516			; 
4516			;		 
4516			;.scrollnext: 
4516			;		pop de 
4516			;		pop bc 
4516			;		djnz .scrolldir 
4516			; 
4516			; 
4516			; 
4516			; 
4516			; 
4516			;		NEXTW 
4516			 
4516			.SCROLLD: 
4516				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4516 53				db WORD_SYS_CORE+63             
4517 44 45			dw .ATQ            
4519 08				db 7 + 1 
451a .. 00			db "SCROLLD",0              
4522				endm 
# End of macro CWHEAD
4522			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4522					if DEBUG_FORTH_WORDS_KEY 
4522						DMARK "SCD" 
4522 f5				push af  
4523 3a 37 45			ld a, (.dmark)  
4526 32 68 fe			ld (debug_mark),a  
4529 3a 38 45			ld a, (.dmark+1)  
452c 32 69 fe			ld (debug_mark+1),a  
452f 3a 39 45			ld a, (.dmark+2)  
4532 32 6a fe			ld (debug_mark+2),a  
4535 18 03			jr .pastdmark  
4537 ..			.dmark: db "SCD"  
453a f1			.pastdmark: pop af  
453b			endm  
# End of macro DMARK
453b						CALLMONITOR 
453b cd 6c fe			call debug_vector  
453e				endm  
# End of macro CALLMONITOR
453e					endif 
453e			 
453e cd 82 0d			call scroll_down 
4541			;	call update_display 
4541			 
4541					NEXTW 
4541 c3 c2 24			jp macro_next 
4544				endm 
# End of macro NEXTW
4544			 
4544			 
4544			.ATQ: 
4544				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4544 62				db WORD_SYS_CORE+78             
4545 a2 45			dw .AUTODSP            
4547 04				db 3 + 1 
4548 .. 00			db "AT@",0              
454c				endm 
# End of macro CWHEAD
454c			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
454c					if DEBUG_FORTH_WORDS_KEY 
454c						DMARK "ATA" 
454c f5				push af  
454d 3a 61 45			ld a, (.dmark)  
4550 32 68 fe			ld (debug_mark),a  
4553 3a 62 45			ld a, (.dmark+1)  
4556 32 69 fe			ld (debug_mark+1),a  
4559 3a 63 45			ld a, (.dmark+2)  
455c 32 6a fe			ld (debug_mark+2),a  
455f 18 03			jr .pastdmark  
4561 ..			.dmark: db "ATA"  
4564 f1			.pastdmark: pop af  
4565			endm  
# End of macro DMARK
4565						CALLMONITOR 
4565 cd 6c fe			call debug_vector  
4568				endm  
# End of macro CALLMONITOR
4568					endif 
4568			 
4568			 
4568					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4568 cd 0c 23			call macro_dsp_valuehl 
456b				endm 
# End of macro FORTH_DSP_VALUEHL
456b			 
456b					; TODO save cursor row 
456b 7d					ld a,l 
456c fe 02				cp 2 
456e 20 04				jr nz, .crow3aq 
4570 3e 28				ld a, display_row_2 
4572 18 12				jr .ccol1aq 
4574 fe 03		.crow3aq:		cp 3 
4576 20 04				jr nz, .crow4aq 
4578 3e 50				ld a, display_row_3 
457a 18 0a				jr .ccol1aq 
457c fe 04		.crow4aq:		cp 4 
457e 20 04				jr nz, .crow1aq 
4580 3e 78				ld a, display_row_4 
4582 18 02				jr .ccol1aq 
4584 3e 00		.crow1aq:		ld a,display_row_1 
4586 f5			.ccol1aq:		push af			; got row offset 
4587 6f					ld l,a 
4588 26 00				ld h,0 
458a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
458a cd c4 23			call macro_forth_dsp_pop 
458d				endm 
# End of macro FORTH_DSP_POP
458d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
458d cd 0c 23			call macro_dsp_valuehl 
4590				endm 
# End of macro FORTH_DSP_VALUEHL
4590					; TODO save cursor col 
4590 f1					pop af 
4591 85					add l		; add col offset 
4592			 
4592					; add current frame buffer address 
4592 2a c9 fb				ld hl, (display_fb_active) 
4595 cd d0 0f				call addatohl 
4598			 
4598			 
4598			 
4598			 
4598					; get char frame buffer location offset in hl 
4598			 
4598 7e					ld a,(hl) 
4599 26 00				ld h, 0 
459b 6f					ld l, a 
459c			 
459c cd 15 21				call forth_push_numhl 
459f			 
459f			 
459f					NEXTW 
459f c3 c2 24			jp macro_next 
45a2				endm 
# End of macro NEXTW
45a2			 
45a2			.AUTODSP: 
45a2				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
45a2 63				db WORD_SYS_CORE+79             
45a3 b8 45			dw .MENU            
45a5 05				db 4 + 1 
45a6 .. 00			db "ADSP",0              
45ab				endm 
# End of macro CWHEAD
45ab			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
45ab			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
45ab			 
45ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45ab cd 0c 23			call macro_dsp_valuehl 
45ae				endm 
# End of macro FORTH_DSP_VALUEHL
45ae			 
45ae			;		push hl 
45ae			 
45ae					; destroy value TOS 
45ae			 
45ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45ae cd c4 23			call macro_forth_dsp_pop 
45b1				endm 
# End of macro FORTH_DSP_POP
45b1			 
45b1			;		pop hl 
45b1			 
45b1 7d					ld a,l 
45b2 32 39 fa				ld (cli_autodisplay), a 
45b5				       NEXTW 
45b5 c3 c2 24			jp macro_next 
45b8				endm 
# End of macro NEXTW
45b8			 
45b8			.MENU: 
45b8				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
45b8 70				db WORD_SYS_CORE+92             
45b9 61 46			dw .ENDDISPLAY            
45bb 05				db 4 + 1 
45bc .. 00			db "MENU",0              
45c1				endm 
# End of macro CWHEAD
45c1			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
45c1			 
45c1			;		; get number of items on the stack 
45c1			; 
45c1				 
45c1					FORTH_DSP_VALUEHL 
45c1 cd 0c 23			call macro_dsp_valuehl 
45c4				endm 
# End of macro FORTH_DSP_VALUEHL
45c4				 
45c4					if DEBUG_FORTH_WORDS_KEY 
45c4						DMARK "MNU" 
45c4 f5				push af  
45c5 3a d9 45			ld a, (.dmark)  
45c8 32 68 fe			ld (debug_mark),a  
45cb 3a da 45			ld a, (.dmark+1)  
45ce 32 69 fe			ld (debug_mark+1),a  
45d1 3a db 45			ld a, (.dmark+2)  
45d4 32 6a fe			ld (debug_mark+2),a  
45d7 18 03			jr .pastdmark  
45d9 ..			.dmark: db "MNU"  
45dc f1			.pastdmark: pop af  
45dd			endm  
# End of macro DMARK
45dd						CALLMONITOR 
45dd cd 6c fe			call debug_vector  
45e0				endm  
# End of macro CALLMONITOR
45e0					endif 
45e0			 
45e0 45					ld b, l	 
45e1 05					dec b 
45e2			 
45e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45e2 cd c4 23			call macro_forth_dsp_pop 
45e5				endm 
# End of macro FORTH_DSP_POP
45e5			 
45e5			 
45e5					; go directly through the stack to pluck out the string pointers and build an array 
45e5			 
45e5			;		FORTH_DSP 
45e5			 
45e5					; hl contains top most stack item 
45e5				 
45e5 11 be f1				ld de, scratch 
45e8			 
45e8			.mbuild: 
45e8			 
45e8					FORTH_DSP_VALUEHL 
45e8 cd 0c 23			call macro_dsp_valuehl 
45eb				endm 
# End of macro FORTH_DSP_VALUEHL
45eb			 
45eb					if DEBUG_FORTH_WORDS 
45eb						DMARK "MN3" 
45eb f5				push af  
45ec 3a 00 46			ld a, (.dmark)  
45ef 32 68 fe			ld (debug_mark),a  
45f2 3a 01 46			ld a, (.dmark+1)  
45f5 32 69 fe			ld (debug_mark+1),a  
45f8 3a 02 46			ld a, (.dmark+2)  
45fb 32 6a fe			ld (debug_mark+2),a  
45fe 18 03			jr .pastdmark  
4600 ..			.dmark: db "MN3"  
4603 f1			.pastdmark: pop af  
4604			endm  
# End of macro DMARK
4604						CALLMONITOR 
4604 cd 6c fe			call debug_vector  
4607				endm  
# End of macro CALLMONITOR
4607					endif 
4607 eb					ex de, hl 
4608 73					ld (hl), e 
4609 23					inc hl 
460a 72					ld (hl), d 
460b 23					inc hl 
460c eb					ex de, hl 
460d			 
460d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
460d cd c4 23			call macro_forth_dsp_pop 
4610				endm 
# End of macro FORTH_DSP_POP
4610			 
4610 10 d6				djnz .mbuild 
4612			 
4612					; done add term 
4612			 
4612 eb					ex de, hl 
4613 36 00				ld (hl), 0 
4615 23					inc hl 
4616 36 00				ld (hl), 0 
4618			 
4618				 
4618					 
4618 21 be f1				ld hl, scratch 
461b			 
461b					if DEBUG_FORTH_WORDS 
461b						DMARK "MNx" 
461b f5				push af  
461c 3a 30 46			ld a, (.dmark)  
461f 32 68 fe			ld (debug_mark),a  
4622 3a 31 46			ld a, (.dmark+1)  
4625 32 69 fe			ld (debug_mark+1),a  
4628 3a 32 46			ld a, (.dmark+2)  
462b 32 6a fe			ld (debug_mark+2),a  
462e 18 03			jr .pastdmark  
4630 ..			.dmark: db "MNx"  
4633 f1			.pastdmark: pop af  
4634			endm  
# End of macro DMARK
4634						CALLMONITOR 
4634 cd 6c fe			call debug_vector  
4637				endm  
# End of macro CALLMONITOR
4637					endif 
4637			 
4637			 
4637			 
4637 3e 00				ld a, 0 
4639 cd cd 0d				call menu 
463c			 
463c			 
463c 6f					ld l, a 
463d 26 00				ld h, 0 
463f			 
463f					if DEBUG_FORTH_WORDS 
463f						DMARK "MNr" 
463f f5				push af  
4640 3a 54 46			ld a, (.dmark)  
4643 32 68 fe			ld (debug_mark),a  
4646 3a 55 46			ld a, (.dmark+1)  
4649 32 69 fe			ld (debug_mark+1),a  
464c 3a 56 46			ld a, (.dmark+2)  
464f 32 6a fe			ld (debug_mark+2),a  
4652 18 03			jr .pastdmark  
4654 ..			.dmark: db "MNr"  
4657 f1			.pastdmark: pop af  
4658			endm  
# End of macro DMARK
4658						CALLMONITOR 
4658 cd 6c fe			call debug_vector  
465b				endm  
# End of macro CALLMONITOR
465b					endif 
465b			 
465b cd 15 21				call forth_push_numhl 
465e			 
465e			 
465e			 
465e			 
465e				       NEXTW 
465e c3 c2 24			jp macro_next 
4661				endm 
# End of macro NEXTW
4661			 
4661			 
4661			.ENDDISPLAY: 
4661			 
4661			; eof 
# End of file forth_words_display.asm
4661			include "forth_words_str.asm" 
4661			 
4661			; | ## String Words 
4661			 
4661			.PTR:   
4661			 
4661				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4661 48				db WORD_SYS_CORE+52             
4662 8e 46			dw .STYPE            
4664 04				db 3 + 1 
4665 .. 00			db "PTR",0              
4669				endm 
# End of macro CWHEAD
4669			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4669			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4669			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4669			 
4669					if DEBUG_FORTH_WORDS_KEY 
4669						DMARK "PTR" 
4669 f5				push af  
466a 3a 7e 46			ld a, (.dmark)  
466d 32 68 fe			ld (debug_mark),a  
4670 3a 7f 46			ld a, (.dmark+1)  
4673 32 69 fe			ld (debug_mark+1),a  
4676 3a 80 46			ld a, (.dmark+2)  
4679 32 6a fe			ld (debug_mark+2),a  
467c 18 03			jr .pastdmark  
467e ..			.dmark: db "PTR"  
4681 f1			.pastdmark: pop af  
4682			endm  
# End of macro DMARK
4682						CALLMONITOR 
4682 cd 6c fe			call debug_vector  
4685				endm  
# End of macro CALLMONITOR
4685					endif 
4685					FORTH_DSP_VALUEHL 
4685 cd 0c 23			call macro_dsp_valuehl 
4688				endm 
# End of macro FORTH_DSP_VALUEHL
4688 cd 15 21				call forth_push_numhl 
468b			 
468b			 
468b					NEXTW 
468b c3 c2 24			jp macro_next 
468e				endm 
# End of macro NEXTW
468e			.STYPE: 
468e				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
468e 48				db WORD_SYS_CORE+52             
468f dd 46			dw .UPPER            
4691 06				db 5 + 1 
4692 .. 00			db "STYPE",0              
4698				endm 
# End of macro CWHEAD
4698			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4698					if DEBUG_FORTH_WORDS_KEY 
4698						DMARK "STY" 
4698 f5				push af  
4699 3a ad 46			ld a, (.dmark)  
469c 32 68 fe			ld (debug_mark),a  
469f 3a ae 46			ld a, (.dmark+1)  
46a2 32 69 fe			ld (debug_mark+1),a  
46a5 3a af 46			ld a, (.dmark+2)  
46a8 32 6a fe			ld (debug_mark+2),a  
46ab 18 03			jr .pastdmark  
46ad ..			.dmark: db "STY"  
46b0 f1			.pastdmark: pop af  
46b1			endm  
# End of macro DMARK
46b1						CALLMONITOR 
46b1 cd 6c fe			call debug_vector  
46b4				endm  
# End of macro CALLMONITOR
46b4					endif 
46b4					FORTH_DSP 
46b4 cd d2 22			call macro_forth_dsp 
46b7				endm 
# End of macro FORTH_DSP
46b7					;v5 FORTH_DSP_VALUE 
46b7			 
46b7 7e					ld a, (hl) 
46b8			 
46b8 f5					push af 
46b9			 
46b9			; Dont destroy TOS		FORTH_DSP_POP 
46b9			 
46b9 f1					pop af 
46ba			 
46ba fe 01				cp DS_TYPE_STR 
46bc 28 09				jr z, .typestr 
46be			 
46be fe 02				cp DS_TYPE_INUM 
46c0 28 0a				jr z, .typeinum 
46c2			 
46c2 21 db 46				ld hl, .tna 
46c5 18 0a				jr .tpush 
46c7			 
46c7 21 d7 46		.typestr:	ld hl, .tstr 
46ca 18 05				jr .tpush 
46cc 21 d9 46		.typeinum:	ld hl, .tinum 
46cf 18 00				jr .tpush 
46d1			 
46d1			.tpush: 
46d1			 
46d1 cd 83 21				call forth_push_str 
46d4			 
46d4					NEXTW 
46d4 c3 c2 24			jp macro_next 
46d7				endm 
# End of macro NEXTW
46d7 .. 00		.tstr:	db "s",0 
46d9 .. 00		.tinum:  db "i",0 
46db .. 00		.tna:   db "?", 0 
46dd			 
46dd			 
46dd			.UPPER: 
46dd				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
46dd 48				db WORD_SYS_CORE+52             
46de 18 47			dw .LOWER            
46e0 06				db 5 + 1 
46e1 .. 00			db "UPPER",0              
46e7				endm 
# End of macro CWHEAD
46e7			; | UPPER ( s -- s ) Upper case string s  | DONE 
46e7					if DEBUG_FORTH_WORDS_KEY 
46e7						DMARK "UPR" 
46e7 f5				push af  
46e8 3a fc 46			ld a, (.dmark)  
46eb 32 68 fe			ld (debug_mark),a  
46ee 3a fd 46			ld a, (.dmark+1)  
46f1 32 69 fe			ld (debug_mark+1),a  
46f4 3a fe 46			ld a, (.dmark+2)  
46f7 32 6a fe			ld (debug_mark+2),a  
46fa 18 03			jr .pastdmark  
46fc ..			.dmark: db "UPR"  
46ff f1			.pastdmark: pop af  
4700			endm  
# End of macro DMARK
4700						CALLMONITOR 
4700 cd 6c fe			call debug_vector  
4703				endm  
# End of macro CALLMONITOR
4703					endif 
4703			 
4703					FORTH_DSP 
4703 cd d2 22			call macro_forth_dsp 
4706				endm 
# End of macro FORTH_DSP
4706					 
4706			; TODO check is string type 
4706			 
4706					FORTH_DSP_VALUEHL 
4706 cd 0c 23			call macro_dsp_valuehl 
4709				endm 
# End of macro FORTH_DSP_VALUEHL
4709			; get pointer to string in hl 
4709			 
4709 7e			.toup:		ld a, (hl) 
470a fe 00				cp 0 
470c 28 07				jr z, .toupdone 
470e			 
470e cd 3d 13				call to_upper 
4711			 
4711 77					ld (hl), a 
4712 23					inc hl 
4713 18 f4				jr .toup 
4715			 
4715					 
4715			 
4715			 
4715			; for each char convert to upper 
4715					 
4715			.toupdone: 
4715			 
4715			 
4715					NEXTW 
4715 c3 c2 24			jp macro_next 
4718				endm 
# End of macro NEXTW
4718			.LOWER: 
4718				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4718 48				db WORD_SYS_CORE+52             
4719 53 47			dw .TCASE            
471b 06				db 5 + 1 
471c .. 00			db "LOWER",0              
4722				endm 
# End of macro CWHEAD
4722			; | LOWER ( s -- s ) Lower case string s  | DONE 
4722					if DEBUG_FORTH_WORDS_KEY 
4722						DMARK "LWR" 
4722 f5				push af  
4723 3a 37 47			ld a, (.dmark)  
4726 32 68 fe			ld (debug_mark),a  
4729 3a 38 47			ld a, (.dmark+1)  
472c 32 69 fe			ld (debug_mark+1),a  
472f 3a 39 47			ld a, (.dmark+2)  
4732 32 6a fe			ld (debug_mark+2),a  
4735 18 03			jr .pastdmark  
4737 ..			.dmark: db "LWR"  
473a f1			.pastdmark: pop af  
473b			endm  
# End of macro DMARK
473b						CALLMONITOR 
473b cd 6c fe			call debug_vector  
473e				endm  
# End of macro CALLMONITOR
473e					endif 
473e			 
473e					FORTH_DSP 
473e cd d2 22			call macro_forth_dsp 
4741				endm 
# End of macro FORTH_DSP
4741					 
4741			; TODO check is string type 
4741			 
4741					FORTH_DSP_VALUEHL 
4741 cd 0c 23			call macro_dsp_valuehl 
4744				endm 
# End of macro FORTH_DSP_VALUEHL
4744			; get pointer to string in hl 
4744			 
4744 7e			.tolow:		ld a, (hl) 
4745 fe 00				cp 0 
4747 28 07				jr z, .tolowdone 
4749			 
4749 cd 46 13				call to_lower 
474c			 
474c 77					ld (hl), a 
474d 23					inc hl 
474e 18 f4				jr .tolow 
4750			 
4750					 
4750			 
4750			 
4750			; for each char convert to low 
4750					 
4750			.tolowdone: 
4750					NEXTW 
4750 c3 c2 24			jp macro_next 
4753				endm 
# End of macro NEXTW
4753			.TCASE: 
4753				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4753 48				db WORD_SYS_CORE+52             
4754 89 48			dw .SUBSTR            
4756 06				db 5 + 1 
4757 .. 00			db "TCASE",0              
475d				endm 
# End of macro CWHEAD
475d			; | TCASE ( s -- s ) Title case string s  | DONE 
475d					if DEBUG_FORTH_WORDS_KEY 
475d						DMARK "TCS" 
475d f5				push af  
475e 3a 72 47			ld a, (.dmark)  
4761 32 68 fe			ld (debug_mark),a  
4764 3a 73 47			ld a, (.dmark+1)  
4767 32 69 fe			ld (debug_mark+1),a  
476a 3a 74 47			ld a, (.dmark+2)  
476d 32 6a fe			ld (debug_mark+2),a  
4770 18 03			jr .pastdmark  
4772 ..			.dmark: db "TCS"  
4775 f1			.pastdmark: pop af  
4776			endm  
# End of macro DMARK
4776						CALLMONITOR 
4776 cd 6c fe			call debug_vector  
4779				endm  
# End of macro CALLMONITOR
4779					endif 
4779			 
4779					FORTH_DSP 
4779 cd d2 22			call macro_forth_dsp 
477c				endm 
# End of macro FORTH_DSP
477c					 
477c			; TODO check is string type 
477c			 
477c					FORTH_DSP_VALUEHL 
477c cd 0c 23			call macro_dsp_valuehl 
477f				endm 
# End of macro FORTH_DSP_VALUEHL
477f			; get pointer to string in hl 
477f			 
477f					if DEBUG_FORTH_WORDS 
477f						DMARK "TC1" 
477f f5				push af  
4780 3a 94 47			ld a, (.dmark)  
4783 32 68 fe			ld (debug_mark),a  
4786 3a 95 47			ld a, (.dmark+1)  
4789 32 69 fe			ld (debug_mark+1),a  
478c 3a 96 47			ld a, (.dmark+2)  
478f 32 6a fe			ld (debug_mark+2),a  
4792 18 03			jr .pastdmark  
4794 ..			.dmark: db "TC1"  
4797 f1			.pastdmark: pop af  
4798			endm  
# End of macro DMARK
4798						CALLMONITOR 
4798 cd 6c fe			call debug_vector  
479b				endm  
# End of macro CALLMONITOR
479b					endif 
479b			 
479b					; first time in turn to upper case first char 
479b			 
479b 7e					ld a, (hl) 
479c c3 26 48				jp .totsiptou 
479f			 
479f			 
479f 7e			.tot:		ld a, (hl) 
47a0 fe 00				cp 0 
47a2 ca 6a 48				jp z, .totdone 
47a5			 
47a5					if DEBUG_FORTH_WORDS 
47a5						DMARK "TC2" 
47a5 f5				push af  
47a6 3a ba 47			ld a, (.dmark)  
47a9 32 68 fe			ld (debug_mark),a  
47ac 3a bb 47			ld a, (.dmark+1)  
47af 32 69 fe			ld (debug_mark+1),a  
47b2 3a bc 47			ld a, (.dmark+2)  
47b5 32 6a fe			ld (debug_mark+2),a  
47b8 18 03			jr .pastdmark  
47ba ..			.dmark: db "TC2"  
47bd f1			.pastdmark: pop af  
47be			endm  
# End of macro DMARK
47be						CALLMONITOR 
47be cd 6c fe			call debug_vector  
47c1				endm  
# End of macro CALLMONITOR
47c1					endif 
47c1					; check to see if current char is a space 
47c1			 
47c1 fe 20				cp ' ' 
47c3 28 21				jr z, .totsp 
47c5 cd 46 13				call to_lower 
47c8					if DEBUG_FORTH_WORDS 
47c8						DMARK "TC3" 
47c8 f5				push af  
47c9 3a dd 47			ld a, (.dmark)  
47cc 32 68 fe			ld (debug_mark),a  
47cf 3a de 47			ld a, (.dmark+1)  
47d2 32 69 fe			ld (debug_mark+1),a  
47d5 3a df 47			ld a, (.dmark+2)  
47d8 32 6a fe			ld (debug_mark+2),a  
47db 18 03			jr .pastdmark  
47dd ..			.dmark: db "TC3"  
47e0 f1			.pastdmark: pop af  
47e1			endm  
# End of macro DMARK
47e1						CALLMONITOR 
47e1 cd 6c fe			call debug_vector  
47e4				endm  
# End of macro CALLMONITOR
47e4					endif 
47e4 18 63				jr .totnxt 
47e6			 
47e6			.totsp:         ; on a space, find next char which should be upper 
47e6			 
47e6					if DEBUG_FORTH_WORDS 
47e6						DMARK "TC4" 
47e6 f5				push af  
47e7 3a fb 47			ld a, (.dmark)  
47ea 32 68 fe			ld (debug_mark),a  
47ed 3a fc 47			ld a, (.dmark+1)  
47f0 32 69 fe			ld (debug_mark+1),a  
47f3 3a fd 47			ld a, (.dmark+2)  
47f6 32 6a fe			ld (debug_mark+2),a  
47f9 18 03			jr .pastdmark  
47fb ..			.dmark: db "TC4"  
47fe f1			.pastdmark: pop af  
47ff			endm  
# End of macro DMARK
47ff						CALLMONITOR 
47ff cd 6c fe			call debug_vector  
4802				endm  
# End of macro CALLMONITOR
4802					endif 
4802					;; 
4802			 
4802 fe 20				cp ' ' 
4804 20 20				jr nz, .totsiptou 
4806 23					inc hl 
4807 7e					ld a, (hl) 
4808					if DEBUG_FORTH_WORDS 
4808						DMARK "TC5" 
4808 f5				push af  
4809 3a 1d 48			ld a, (.dmark)  
480c 32 68 fe			ld (debug_mark),a  
480f 3a 1e 48			ld a, (.dmark+1)  
4812 32 69 fe			ld (debug_mark+1),a  
4815 3a 1f 48			ld a, (.dmark+2)  
4818 32 6a fe			ld (debug_mark+2),a  
481b 18 03			jr .pastdmark  
481d ..			.dmark: db "TC5"  
4820 f1			.pastdmark: pop af  
4821			endm  
# End of macro DMARK
4821						CALLMONITOR 
4821 cd 6c fe			call debug_vector  
4824				endm  
# End of macro CALLMONITOR
4824					endif 
4824 18 c0				jr .totsp 
4826 fe 00		.totsiptou:    cp 0 
4828 28 40				jr z, .totdone 
482a					; not space and not zero term so upper case it 
482a cd 3d 13				call to_upper 
482d			 
482d					if DEBUG_FORTH_WORDS 
482d						DMARK "TC6" 
482d f5				push af  
482e 3a 42 48			ld a, (.dmark)  
4831 32 68 fe			ld (debug_mark),a  
4834 3a 43 48			ld a, (.dmark+1)  
4837 32 69 fe			ld (debug_mark+1),a  
483a 3a 44 48			ld a, (.dmark+2)  
483d 32 6a fe			ld (debug_mark+2),a  
4840 18 03			jr .pastdmark  
4842 ..			.dmark: db "TC6"  
4845 f1			.pastdmark: pop af  
4846			endm  
# End of macro DMARK
4846						CALLMONITOR 
4846 cd 6c fe			call debug_vector  
4849				endm  
# End of macro CALLMONITOR
4849					endif 
4849			 
4849			 
4849			.totnxt: 
4849			 
4849 77					ld (hl), a 
484a 23					inc hl 
484b					if DEBUG_FORTH_WORDS 
484b						DMARK "TC7" 
484b f5				push af  
484c 3a 60 48			ld a, (.dmark)  
484f 32 68 fe			ld (debug_mark),a  
4852 3a 61 48			ld a, (.dmark+1)  
4855 32 69 fe			ld (debug_mark+1),a  
4858 3a 62 48			ld a, (.dmark+2)  
485b 32 6a fe			ld (debug_mark+2),a  
485e 18 03			jr .pastdmark  
4860 ..			.dmark: db "TC7"  
4863 f1			.pastdmark: pop af  
4864			endm  
# End of macro DMARK
4864						CALLMONITOR 
4864 cd 6c fe			call debug_vector  
4867				endm  
# End of macro CALLMONITOR
4867					endif 
4867 c3 9f 47				jp .tot 
486a			 
486a					 
486a			 
486a			 
486a			; for each char convert to low 
486a					 
486a			.totdone: 
486a					if DEBUG_FORTH_WORDS 
486a						DMARK "TCd" 
486a f5				push af  
486b 3a 7f 48			ld a, (.dmark)  
486e 32 68 fe			ld (debug_mark),a  
4871 3a 80 48			ld a, (.dmark+1)  
4874 32 69 fe			ld (debug_mark+1),a  
4877 3a 81 48			ld a, (.dmark+2)  
487a 32 6a fe			ld (debug_mark+2),a  
487d 18 03			jr .pastdmark  
487f ..			.dmark: db "TCd"  
4882 f1			.pastdmark: pop af  
4883			endm  
# End of macro DMARK
4883						CALLMONITOR 
4883 cd 6c fe			call debug_vector  
4886				endm  
# End of macro CALLMONITOR
4886					endif 
4886					NEXTW 
4886 c3 c2 24			jp macro_next 
4889				endm 
# End of macro NEXTW
4889			 
4889			.SUBSTR: 
4889				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4889 48				db WORD_SYS_CORE+52             
488a e7 48			dw .LEFT            
488c 07				db 6 + 1 
488d .. 00			db "SUBSTR",0              
4894				endm 
# End of macro CWHEAD
4894			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4894			 
4894					if DEBUG_FORTH_WORDS_KEY 
4894						DMARK "SST" 
4894 f5				push af  
4895 3a a9 48			ld a, (.dmark)  
4898 32 68 fe			ld (debug_mark),a  
489b 3a aa 48			ld a, (.dmark+1)  
489e 32 69 fe			ld (debug_mark+1),a  
48a1 3a ab 48			ld a, (.dmark+2)  
48a4 32 6a fe			ld (debug_mark+2),a  
48a7 18 03			jr .pastdmark  
48a9 ..			.dmark: db "SST"  
48ac f1			.pastdmark: pop af  
48ad			endm  
# End of macro DMARK
48ad						CALLMONITOR 
48ad cd 6c fe			call debug_vector  
48b0				endm  
# End of macro CALLMONITOR
48b0					endif 
48b0			; TODO check string type 
48b0					FORTH_DSP_VALUEHL 
48b0 cd 0c 23			call macro_dsp_valuehl 
48b3				endm 
# End of macro FORTH_DSP_VALUEHL
48b3			 
48b3 e5					push hl      ; string length 
48b4			 
48b4					FORTH_DSP_POP 
48b4 cd c4 23			call macro_forth_dsp_pop 
48b7				endm 
# End of macro FORTH_DSP_POP
48b7			 
48b7					FORTH_DSP_VALUEHL 
48b7 cd 0c 23			call macro_dsp_valuehl 
48ba				endm 
# End of macro FORTH_DSP_VALUEHL
48ba			 
48ba e5					push hl     ; start char 
48bb			 
48bb					FORTH_DSP_POP 
48bb cd c4 23			call macro_forth_dsp_pop 
48be				endm 
# End of macro FORTH_DSP_POP
48be			 
48be			 
48be					FORTH_DSP_VALUE 
48be cd f5 22			call macro_forth_dsp_value 
48c1				endm 
# End of macro FORTH_DSP_VALUE
48c1			 
48c1 d1					pop de    ; get start post offset 
48c2			 
48c2 19					add hl, de    ; starting offset 
48c3			 
48c3 c1					pop bc 
48c4 c5					push bc      ; grab size of string 
48c5			 
48c5 e5					push hl    ; save string start  
48c6			 
48c6 26 00				ld h, 0 
48c8 69					ld l, c 
48c9 23					inc hl 
48ca 23					inc hl 
48cb			 
48cb cd 97 14				call malloc 
48ce				if DEBUG_FORTH_MALLOC_GUARD 
48ce cc 14 5e				call z,malloc_error 
48d1				endif 
48d1			 
48d1 eb					ex de, hl      ; save malloc area for string copy 
48d2 e1					pop hl    ; get back source 
48d3 c1					pop bc    ; get length of string back 
48d4			 
48d4 d5					push de    ; save malloc area for after we push 
48d5 ed b0				ldir     ; copy substr 
48d7			 
48d7			 
48d7 eb					ex de, hl 
48d8 3e 00				ld a, 0 
48da 77					ld (hl), a   ; term substr 
48db			 
48db					 
48db e1					pop hl    ; get malloc so we can push it 
48dc e5					push hl   ; save so we can free it afterwards 
48dd			 
48dd cd 83 21				call forth_push_str 
48e0			 
48e0 e1					pop hl 
48e1 cd 61 15				call free 
48e4			 
48e4					 
48e4					 
48e4			 
48e4			 
48e4					NEXTW 
48e4 c3 c2 24			jp macro_next 
48e7				endm 
# End of macro NEXTW
48e7			 
48e7			.LEFT: 
48e7				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
48e7 48				db WORD_SYS_CORE+52             
48e8 0f 49			dw .RIGHT            
48ea 05				db 4 + 1 
48eb .. 00			db "LEFT",0              
48f0				endm 
# End of macro CWHEAD
48f0			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
48f0					if DEBUG_FORTH_WORDS_KEY 
48f0						DMARK "LEF" 
48f0 f5				push af  
48f1 3a 05 49			ld a, (.dmark)  
48f4 32 68 fe			ld (debug_mark),a  
48f7 3a 06 49			ld a, (.dmark+1)  
48fa 32 69 fe			ld (debug_mark+1),a  
48fd 3a 07 49			ld a, (.dmark+2)  
4900 32 6a fe			ld (debug_mark+2),a  
4903 18 03			jr .pastdmark  
4905 ..			.dmark: db "LEF"  
4908 f1			.pastdmark: pop af  
4909			endm  
# End of macro DMARK
4909						CALLMONITOR 
4909 cd 6c fe			call debug_vector  
490c				endm  
# End of macro CALLMONITOR
490c					endif 
490c			 
490c					NEXTW 
490c c3 c2 24			jp macro_next 
490f				endm 
# End of macro NEXTW
490f			.RIGHT: 
490f				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
490f 48				db WORD_SYS_CORE+52             
4910 38 49			dw .STR2NUM            
4912 06				db 5 + 1 
4913 .. 00			db "RIGHT",0              
4919				endm 
# End of macro CWHEAD
4919			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4919					if DEBUG_FORTH_WORDS_KEY 
4919						DMARK "RIG" 
4919 f5				push af  
491a 3a 2e 49			ld a, (.dmark)  
491d 32 68 fe			ld (debug_mark),a  
4920 3a 2f 49			ld a, (.dmark+1)  
4923 32 69 fe			ld (debug_mark+1),a  
4926 3a 30 49			ld a, (.dmark+2)  
4929 32 6a fe			ld (debug_mark+2),a  
492c 18 03			jr .pastdmark  
492e ..			.dmark: db "RIG"  
4931 f1			.pastdmark: pop af  
4932			endm  
# End of macro DMARK
4932						CALLMONITOR 
4932 cd 6c fe			call debug_vector  
4935				endm  
# End of macro CALLMONITOR
4935					endif 
4935			 
4935					NEXTW 
4935 c3 c2 24			jp macro_next 
4938				endm 
# End of macro NEXTW
4938			 
4938			 
4938			.STR2NUM: 
4938				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4938 48				db WORD_SYS_CORE+52             
4939 c4 49			dw .NUM2STR            
493b 08				db 7 + 1 
493c .. 00			db "STR2NUM",0              
4944				endm 
# End of macro CWHEAD
4944			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4944			 
4944			 
4944			; TODO STR type check to do 
4944					if DEBUG_FORTH_WORDS_KEY 
4944						DMARK "S2N" 
4944 f5				push af  
4945 3a 59 49			ld a, (.dmark)  
4948 32 68 fe			ld (debug_mark),a  
494b 3a 5a 49			ld a, (.dmark+1)  
494e 32 69 fe			ld (debug_mark+1),a  
4951 3a 5b 49			ld a, (.dmark+2)  
4954 32 6a fe			ld (debug_mark+2),a  
4957 18 03			jr .pastdmark  
4959 ..			.dmark: db "S2N"  
495c f1			.pastdmark: pop af  
495d			endm  
# End of macro DMARK
495d						CALLMONITOR 
495d cd 6c fe			call debug_vector  
4960				endm  
# End of macro CALLMONITOR
4960					endif 
4960			 
4960					;FORTH_DSP 
4960					FORTH_DSP_VALUE 
4960 cd f5 22			call macro_forth_dsp_value 
4963				endm 
# End of macro FORTH_DSP_VALUE
4963					;inc hl 
4963			 
4963 eb					ex de, hl 
4964					if DEBUG_FORTH_WORDS 
4964						DMARK "S2a" 
4964 f5				push af  
4965 3a 79 49			ld a, (.dmark)  
4968 32 68 fe			ld (debug_mark),a  
496b 3a 7a 49			ld a, (.dmark+1)  
496e 32 69 fe			ld (debug_mark+1),a  
4971 3a 7b 49			ld a, (.dmark+2)  
4974 32 6a fe			ld (debug_mark+2),a  
4977 18 03			jr .pastdmark  
4979 ..			.dmark: db "S2a"  
497c f1			.pastdmark: pop af  
497d			endm  
# End of macro DMARK
497d						CALLMONITOR 
497d cd 6c fe			call debug_vector  
4980				endm  
# End of macro CALLMONITOR
4980					endif 
4980 cd c5 13				call string_to_uint16 
4983			 
4983					if DEBUG_FORTH_WORDS 
4983						DMARK "S2b" 
4983 f5				push af  
4984 3a 98 49			ld a, (.dmark)  
4987 32 68 fe			ld (debug_mark),a  
498a 3a 99 49			ld a, (.dmark+1)  
498d 32 69 fe			ld (debug_mark+1),a  
4990 3a 9a 49			ld a, (.dmark+2)  
4993 32 6a fe			ld (debug_mark+2),a  
4996 18 03			jr .pastdmark  
4998 ..			.dmark: db "S2b"  
499b f1			.pastdmark: pop af  
499c			endm  
# End of macro DMARK
499c						CALLMONITOR 
499c cd 6c fe			call debug_vector  
499f				endm  
# End of macro CALLMONITOR
499f					endif 
499f			;		push hl 
499f					FORTH_DSP_POP 
499f cd c4 23			call macro_forth_dsp_pop 
49a2				endm 
# End of macro FORTH_DSP_POP
49a2			;		pop hl 
49a2					 
49a2					if DEBUG_FORTH_WORDS 
49a2						DMARK "S2b" 
49a2 f5				push af  
49a3 3a b7 49			ld a, (.dmark)  
49a6 32 68 fe			ld (debug_mark),a  
49a9 3a b8 49			ld a, (.dmark+1)  
49ac 32 69 fe			ld (debug_mark+1),a  
49af 3a b9 49			ld a, (.dmark+2)  
49b2 32 6a fe			ld (debug_mark+2),a  
49b5 18 03			jr .pastdmark  
49b7 ..			.dmark: db "S2b"  
49ba f1			.pastdmark: pop af  
49bb			endm  
# End of macro DMARK
49bb						CALLMONITOR 
49bb cd 6c fe			call debug_vector  
49be				endm  
# End of macro CALLMONITOR
49be					endif 
49be cd 15 21				call forth_push_numhl	 
49c1			 
49c1				 
49c1				       NEXTW 
49c1 c3 c2 24			jp macro_next 
49c4				endm 
# End of macro NEXTW
49c4			.NUM2STR: 
49c4				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
49c4 48				db WORD_SYS_CORE+52             
49c5 d3 49			dw .CONCAT            
49c7 08				db 7 + 1 
49c8 .. 00			db "NUM2STR",0              
49d0				endm 
# End of macro CWHEAD
49d0			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
49d0			 
49d0			;		; malloc a string to target 
49d0			;		ld hl, 10     ; TODO max string size should be fine 
49d0			;		call malloc 
49d0			;		push hl    ; save malloc location 
49d0			; 
49d0			; 
49d0			;; TODO check int type 
49d0			;		FORTH_DSP_VALUEHL 
49d0			;		ld a, l 
49d0			;		call DispAToASCII   
49d0			;;TODO need to chage above call to dump into string 
49d0			; 
49d0			; 
49d0			 
49d0				       NEXTW 
49d0 c3 c2 24			jp macro_next 
49d3				endm 
# End of macro NEXTW
49d3			 
49d3			.CONCAT: 
49d3				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
49d3 48				db WORD_SYS_CORE+52             
49d4 86 4a			dw .FIND            
49d6 07				db 6 + 1 
49d7 .. 00			db "CONCAT",0              
49de				endm 
# End of macro CWHEAD
49de			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
49de			 
49de			; TODO check string type 
49de			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
49de			 
49de					if DEBUG_FORTH_WORDS_KEY 
49de						DMARK "CON" 
49de f5				push af  
49df 3a f3 49			ld a, (.dmark)  
49e2 32 68 fe			ld (debug_mark),a  
49e5 3a f4 49			ld a, (.dmark+1)  
49e8 32 69 fe			ld (debug_mark+1),a  
49eb 3a f5 49			ld a, (.dmark+2)  
49ee 32 6a fe			ld (debug_mark+2),a  
49f1 18 03			jr .pastdmark  
49f3 ..			.dmark: db "CON"  
49f6 f1			.pastdmark: pop af  
49f7			endm  
# End of macro DMARK
49f7						CALLMONITOR 
49f7 cd 6c fe			call debug_vector  
49fa				endm  
# End of macro CALLMONITOR
49fa					endif 
49fa			 
49fa			 
49fa					FORTH_DSP_VALUE 
49fa cd f5 22			call macro_forth_dsp_value 
49fd				endm 
# End of macro FORTH_DSP_VALUE
49fd e5					push hl   ; s2 
49fe			 
49fe					FORTH_DSP_POP 
49fe cd c4 23			call macro_forth_dsp_pop 
4a01				endm 
# End of macro FORTH_DSP_POP
4a01			 
4a01					FORTH_DSP_VALUE 
4a01 cd f5 22			call macro_forth_dsp_value 
4a04				endm 
# End of macro FORTH_DSP_VALUE
4a04			 
4a04 e5					push hl   ; s1 
4a05			 
4a05					FORTH_DSP_POP 
4a05 cd c4 23			call macro_forth_dsp_pop 
4a08				endm 
# End of macro FORTH_DSP_POP
4a08					 
4a08			 
4a08					; copy s1 
4a08			 
4a08				 
4a08					; save ptr 
4a08 e1					pop hl  
4a09 e5					push hl 
4a0a 3e 00				ld a, 0 
4a0c cd 39 14				call strlent 
4a0f					;inc hl    ; zer0 
4a0f 06 00				ld b, 0 
4a11 4d					ld c, l 
4a12 e1					pop hl		 
4a13 11 be f1				ld de, scratch	 
4a16					if DEBUG_FORTH_WORDS 
4a16						DMARK "CO1" 
4a16 f5				push af  
4a17 3a 2b 4a			ld a, (.dmark)  
4a1a 32 68 fe			ld (debug_mark),a  
4a1d 3a 2c 4a			ld a, (.dmark+1)  
4a20 32 69 fe			ld (debug_mark+1),a  
4a23 3a 2d 4a			ld a, (.dmark+2)  
4a26 32 6a fe			ld (debug_mark+2),a  
4a29 18 03			jr .pastdmark  
4a2b ..			.dmark: db "CO1"  
4a2e f1			.pastdmark: pop af  
4a2f			endm  
# End of macro DMARK
4a2f						CALLMONITOR 
4a2f cd 6c fe			call debug_vector  
4a32				endm  
# End of macro CALLMONITOR
4a32					endif 
4a32 ed b0				ldir 
4a34			 
4a34 e1					pop hl 
4a35 e5					push hl 
4a36 d5					push de 
4a37			 
4a37			 
4a37 3e 00				ld a, 0 
4a39 cd 39 14				call strlent 
4a3c 23					inc hl    ; zer0 
4a3d 23					inc hl 
4a3e 06 00				ld b, 0 
4a40 4d					ld c, l 
4a41 d1					pop de 
4a42 e1					pop hl		 
4a43					if DEBUG_FORTH_WORDS 
4a43						DMARK "CO2" 
4a43 f5				push af  
4a44 3a 58 4a			ld a, (.dmark)  
4a47 32 68 fe			ld (debug_mark),a  
4a4a 3a 59 4a			ld a, (.dmark+1)  
4a4d 32 69 fe			ld (debug_mark+1),a  
4a50 3a 5a 4a			ld a, (.dmark+2)  
4a53 32 6a fe			ld (debug_mark+2),a  
4a56 18 03			jr .pastdmark  
4a58 ..			.dmark: db "CO2"  
4a5b f1			.pastdmark: pop af  
4a5c			endm  
# End of macro DMARK
4a5c						CALLMONITOR 
4a5c cd 6c fe			call debug_vector  
4a5f				endm  
# End of macro CALLMONITOR
4a5f					endif 
4a5f ed b0				ldir 
4a61			 
4a61			 
4a61			 
4a61 21 be f1				ld hl, scratch 
4a64					if DEBUG_FORTH_WORDS 
4a64						DMARK "CO5" 
4a64 f5				push af  
4a65 3a 79 4a			ld a, (.dmark)  
4a68 32 68 fe			ld (debug_mark),a  
4a6b 3a 7a 4a			ld a, (.dmark+1)  
4a6e 32 69 fe			ld (debug_mark+1),a  
4a71 3a 7b 4a			ld a, (.dmark+2)  
4a74 32 6a fe			ld (debug_mark+2),a  
4a77 18 03			jr .pastdmark  
4a79 ..			.dmark: db "CO5"  
4a7c f1			.pastdmark: pop af  
4a7d			endm  
# End of macro DMARK
4a7d						CALLMONITOR 
4a7d cd 6c fe			call debug_vector  
4a80				endm  
# End of macro CALLMONITOR
4a80					endif 
4a80			 
4a80 cd 83 21				call forth_push_str 
4a83			 
4a83			 
4a83			 
4a83			 
4a83				       NEXTW 
4a83 c3 c2 24			jp macro_next 
4a86				endm 
# End of macro NEXTW
4a86			 
4a86			 
4a86			.FIND: 
4a86				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a86 4b				db WORD_SYS_CORE+55             
4a87 44 4b			dw .LEN            
4a89 05				db 4 + 1 
4a8a .. 00			db "FIND",0              
4a8f				endm 
# End of macro CWHEAD
4a8f			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a8f			 
4a8f					if DEBUG_FORTH_WORDS_KEY 
4a8f						DMARK "FND" 
4a8f f5				push af  
4a90 3a a4 4a			ld a, (.dmark)  
4a93 32 68 fe			ld (debug_mark),a  
4a96 3a a5 4a			ld a, (.dmark+1)  
4a99 32 69 fe			ld (debug_mark+1),a  
4a9c 3a a6 4a			ld a, (.dmark+2)  
4a9f 32 6a fe			ld (debug_mark+2),a  
4aa2 18 03			jr .pastdmark  
4aa4 ..			.dmark: db "FND"  
4aa7 f1			.pastdmark: pop af  
4aa8			endm  
# End of macro DMARK
4aa8						CALLMONITOR 
4aa8 cd 6c fe			call debug_vector  
4aab				endm  
# End of macro CALLMONITOR
4aab					endif 
4aab			 
4aab			; TODO check string type 
4aab					FORTH_DSP_VALUE 
4aab cd f5 22			call macro_forth_dsp_value 
4aae				endm 
# End of macro FORTH_DSP_VALUE
4aae			 
4aae e5					push hl    
4aaf 7e					ld a,(hl)    ; char to find   
4ab0			; TODO change char to substr 
4ab0			 
4ab0 f5					push af 
4ab1					 
4ab1			 
4ab1			 
4ab1					if DEBUG_FORTH_WORDS 
4ab1						DMARK "FN1" 
4ab1 f5				push af  
4ab2 3a c6 4a			ld a, (.dmark)  
4ab5 32 68 fe			ld (debug_mark),a  
4ab8 3a c7 4a			ld a, (.dmark+1)  
4abb 32 69 fe			ld (debug_mark+1),a  
4abe 3a c8 4a			ld a, (.dmark+2)  
4ac1 32 6a fe			ld (debug_mark+2),a  
4ac4 18 03			jr .pastdmark  
4ac6 ..			.dmark: db "FN1"  
4ac9 f1			.pastdmark: pop af  
4aca			endm  
# End of macro DMARK
4aca						CALLMONITOR 
4aca cd 6c fe			call debug_vector  
4acd				endm  
# End of macro CALLMONITOR
4acd					endif 
4acd			 
4acd					FORTH_DSP_POP 
4acd cd c4 23			call macro_forth_dsp_pop 
4ad0				endm 
# End of macro FORTH_DSP_POP
4ad0			 
4ad0					; string to search 
4ad0			 
4ad0					FORTH_DSP_VALUE 
4ad0 cd f5 22			call macro_forth_dsp_value 
4ad3				endm 
# End of macro FORTH_DSP_VALUE
4ad3			 
4ad3 d1					pop de  ; d is char to find  
4ad4			 
4ad4					if DEBUG_FORTH_WORDS 
4ad4						DMARK "FN2" 
4ad4 f5				push af  
4ad5 3a e9 4a			ld a, (.dmark)  
4ad8 32 68 fe			ld (debug_mark),a  
4adb 3a ea 4a			ld a, (.dmark+1)  
4ade 32 69 fe			ld (debug_mark+1),a  
4ae1 3a eb 4a			ld a, (.dmark+2)  
4ae4 32 6a fe			ld (debug_mark+2),a  
4ae7 18 03			jr .pastdmark  
4ae9 ..			.dmark: db "FN2"  
4aec f1			.pastdmark: pop af  
4aed			endm  
# End of macro DMARK
4aed						CALLMONITOR 
4aed cd 6c fe			call debug_vector  
4af0				endm  
# End of macro CALLMONITOR
4af0					endif 
4af0					 
4af0 01 00 00				ld bc, 0 
4af3 7e			.findchar:      ld a,(hl) 
4af4 fe 00				cp 0   		 
4af6 28 27				jr z, .finddone     
4af8 ba					cp d 
4af9 28 20				jr z, .foundchar 
4afb 03					inc bc 
4afc 23					inc hl 
4afd					if DEBUG_FORTH_WORDS 
4afd						DMARK "FN3" 
4afd f5				push af  
4afe 3a 12 4b			ld a, (.dmark)  
4b01 32 68 fe			ld (debug_mark),a  
4b04 3a 13 4b			ld a, (.dmark+1)  
4b07 32 69 fe			ld (debug_mark+1),a  
4b0a 3a 14 4b			ld a, (.dmark+2)  
4b0d 32 6a fe			ld (debug_mark+2),a  
4b10 18 03			jr .pastdmark  
4b12 ..			.dmark: db "FN3"  
4b15 f1			.pastdmark: pop af  
4b16			endm  
# End of macro DMARK
4b16						CALLMONITOR 
4b16 cd 6c fe			call debug_vector  
4b19				endm  
# End of macro CALLMONITOR
4b19					endif 
4b19 18 d8				jr .findchar 
4b1b			 
4b1b			 
4b1b c5			.foundchar:	push bc 
4b1c e1					pop hl 
4b1d 18 03				jr .findexit 
4b1f			 
4b1f			 
4b1f							 
4b1f			 
4b1f			.finddone:     ; got to end of string with no find 
4b1f 21 00 00				ld hl, 0 
4b22			.findexit: 
4b22			 
4b22					if DEBUG_FORTH_WORDS 
4b22						DMARK "FNd" 
4b22 f5				push af  
4b23 3a 37 4b			ld a, (.dmark)  
4b26 32 68 fe			ld (debug_mark),a  
4b29 3a 38 4b			ld a, (.dmark+1)  
4b2c 32 69 fe			ld (debug_mark+1),a  
4b2f 3a 39 4b			ld a, (.dmark+2)  
4b32 32 6a fe			ld (debug_mark+2),a  
4b35 18 03			jr .pastdmark  
4b37 ..			.dmark: db "FNd"  
4b3a f1			.pastdmark: pop af  
4b3b			endm  
# End of macro DMARK
4b3b						CALLMONITOR 
4b3b cd 6c fe			call debug_vector  
4b3e				endm  
# End of macro CALLMONITOR
4b3e					endif 
4b3e cd 15 21			call forth_push_numhl 
4b41			 
4b41				       NEXTW 
4b41 c3 c2 24			jp macro_next 
4b44				endm 
# End of macro NEXTW
4b44			 
4b44			.LEN: 
4b44				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b44 4c				db WORD_SYS_CORE+56             
4b45 ae 4b			dw .ASC            
4b47 06				db 5 + 1 
4b48 .. 00			db "COUNT",0              
4b4e				endm 
# End of macro CWHEAD
4b4e			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b4e			 
4b4e					if DEBUG_FORTH_WORDS_KEY 
4b4e						DMARK "CNT" 
4b4e f5				push af  
4b4f 3a 63 4b			ld a, (.dmark)  
4b52 32 68 fe			ld (debug_mark),a  
4b55 3a 64 4b			ld a, (.dmark+1)  
4b58 32 69 fe			ld (debug_mark+1),a  
4b5b 3a 65 4b			ld a, (.dmark+2)  
4b5e 32 6a fe			ld (debug_mark+2),a  
4b61 18 03			jr .pastdmark  
4b63 ..			.dmark: db "CNT"  
4b66 f1			.pastdmark: pop af  
4b67			endm  
# End of macro DMARK
4b67						CALLMONITOR 
4b67 cd 6c fe			call debug_vector  
4b6a				endm  
# End of macro CALLMONITOR
4b6a					endif 
4b6a			; TODO check string type 
4b6a					FORTH_DSP_VALUE 
4b6a cd f5 22			call macro_forth_dsp_value 
4b6d				endm 
# End of macro FORTH_DSP_VALUE
4b6d			 
4b6d			 
4b6d					if DEBUG_FORTH_WORDS 
4b6d						DMARK "CN?" 
4b6d f5				push af  
4b6e 3a 82 4b			ld a, (.dmark)  
4b71 32 68 fe			ld (debug_mark),a  
4b74 3a 83 4b			ld a, (.dmark+1)  
4b77 32 69 fe			ld (debug_mark+1),a  
4b7a 3a 84 4b			ld a, (.dmark+2)  
4b7d 32 6a fe			ld (debug_mark+2),a  
4b80 18 03			jr .pastdmark  
4b82 ..			.dmark: db "CN?"  
4b85 f1			.pastdmark: pop af  
4b86			endm  
# End of macro DMARK
4b86						CALLMONITOR 
4b86 cd 6c fe			call debug_vector  
4b89				endm  
# End of macro CALLMONITOR
4b89					endif 
4b89 cd 2e 14				call strlenz 
4b8c					if DEBUG_FORTH_WORDS 
4b8c						DMARK "CNl" 
4b8c f5				push af  
4b8d 3a a1 4b			ld a, (.dmark)  
4b90 32 68 fe			ld (debug_mark),a  
4b93 3a a2 4b			ld a, (.dmark+1)  
4b96 32 69 fe			ld (debug_mark+1),a  
4b99 3a a3 4b			ld a, (.dmark+2)  
4b9c 32 6a fe			ld (debug_mark+2),a  
4b9f 18 03			jr .pastdmark  
4ba1 ..			.dmark: db "CNl"  
4ba4 f1			.pastdmark: pop af  
4ba5			endm  
# End of macro DMARK
4ba5						CALLMONITOR 
4ba5 cd 6c fe			call debug_vector  
4ba8				endm  
# End of macro CALLMONITOR
4ba8					endif 
4ba8			 
4ba8 cd 15 21				call forth_push_numhl 
4bab			 
4bab			 
4bab			 
4bab				       NEXTW 
4bab c3 c2 24			jp macro_next 
4bae				endm 
# End of macro NEXTW
4bae			.ASC: 
4bae				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4bae 4d				db WORD_SYS_CORE+57             
4baf 1c 4c			dw .CHR            
4bb1 04				db 3 + 1 
4bb2 .. 00			db "ASC",0              
4bb6				endm 
# End of macro CWHEAD
4bb6			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4bb6					if DEBUG_FORTH_WORDS_KEY 
4bb6						DMARK "ASC" 
4bb6 f5				push af  
4bb7 3a cb 4b			ld a, (.dmark)  
4bba 32 68 fe			ld (debug_mark),a  
4bbd 3a cc 4b			ld a, (.dmark+1)  
4bc0 32 69 fe			ld (debug_mark+1),a  
4bc3 3a cd 4b			ld a, (.dmark+2)  
4bc6 32 6a fe			ld (debug_mark+2),a  
4bc9 18 03			jr .pastdmark  
4bcb ..			.dmark: db "ASC"  
4bce f1			.pastdmark: pop af  
4bcf			endm  
# End of macro DMARK
4bcf						CALLMONITOR 
4bcf cd 6c fe			call debug_vector  
4bd2				endm  
# End of macro CALLMONITOR
4bd2					endif 
4bd2					FORTH_DSP_VALUE 
4bd2 cd f5 22			call macro_forth_dsp_value 
4bd5				endm 
# End of macro FORTH_DSP_VALUE
4bd5					;v5 FORTH_DSP_VALUE 
4bd5			;		inc hl      ; now at start of numeric as string 
4bd5			 
4bd5 e5					push hl 
4bd6			 
4bd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd6 cd c4 23			call macro_forth_dsp_pop 
4bd9				endm 
# End of macro FORTH_DSP_POP
4bd9			 
4bd9 e1					pop hl 
4bda			 
4bda					if DEBUG_FORTH_WORDS 
4bda						DMARK "AS1" 
4bda f5				push af  
4bdb 3a ef 4b			ld a, (.dmark)  
4bde 32 68 fe			ld (debug_mark),a  
4be1 3a f0 4b			ld a, (.dmark+1)  
4be4 32 69 fe			ld (debug_mark+1),a  
4be7 3a f1 4b			ld a, (.dmark+2)  
4bea 32 6a fe			ld (debug_mark+2),a  
4bed 18 03			jr .pastdmark  
4bef ..			.dmark: db "AS1"  
4bf2 f1			.pastdmark: pop af  
4bf3			endm  
# End of macro DMARK
4bf3						CALLMONITOR 
4bf3 cd 6c fe			call debug_vector  
4bf6				endm  
# End of macro CALLMONITOR
4bf6					endif 
4bf6					; push the content of a onto the stack as a value 
4bf6			 
4bf6 7e					ld a,(hl)   ; get char 
4bf7 26 00				ld h,0 
4bf9 6f					ld l,a 
4bfa					if DEBUG_FORTH_WORDS 
4bfa						DMARK "AS2" 
4bfa f5				push af  
4bfb 3a 0f 4c			ld a, (.dmark)  
4bfe 32 68 fe			ld (debug_mark),a  
4c01 3a 10 4c			ld a, (.dmark+1)  
4c04 32 69 fe			ld (debug_mark+1),a  
4c07 3a 11 4c			ld a, (.dmark+2)  
4c0a 32 6a fe			ld (debug_mark+2),a  
4c0d 18 03			jr .pastdmark  
4c0f ..			.dmark: db "AS2"  
4c12 f1			.pastdmark: pop af  
4c13			endm  
# End of macro DMARK
4c13						CALLMONITOR 
4c13 cd 6c fe			call debug_vector  
4c16				endm  
# End of macro CALLMONITOR
4c16					endif 
4c16 cd 15 21				call forth_push_numhl 
4c19			 
4c19				       NEXTW 
4c19 c3 c2 24			jp macro_next 
4c1c				endm 
# End of macro NEXTW
4c1c			 
4c1c			.CHR: 
4c1c				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c1c 4d				db WORD_SYS_CORE+57             
4c1d 58 4c			dw .ENDSTR            
4c1f 04				db 3 + 1 
4c20 .. 00			db "CHR",0              
4c24				endm 
# End of macro CWHEAD
4c24			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c24					if DEBUG_FORTH_WORDS_KEY 
4c24						DMARK "CHR" 
4c24 f5				push af  
4c25 3a 39 4c			ld a, (.dmark)  
4c28 32 68 fe			ld (debug_mark),a  
4c2b 3a 3a 4c			ld a, (.dmark+1)  
4c2e 32 69 fe			ld (debug_mark+1),a  
4c31 3a 3b 4c			ld a, (.dmark+2)  
4c34 32 6a fe			ld (debug_mark+2),a  
4c37 18 03			jr .pastdmark  
4c39 ..			.dmark: db "CHR"  
4c3c f1			.pastdmark: pop af  
4c3d			endm  
# End of macro DMARK
4c3d						CALLMONITOR 
4c3d cd 6c fe			call debug_vector  
4c40				endm  
# End of macro CALLMONITOR
4c40					endif 
4c40					FORTH_DSP_VALUEHL 
4c40 cd 0c 23			call macro_dsp_valuehl 
4c43				endm 
# End of macro FORTH_DSP_VALUEHL
4c43			 
4c43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c43 cd c4 23			call macro_forth_dsp_pop 
4c46				endm 
# End of macro FORTH_DSP_POP
4c46			 
4c46					; save asci byte as a zero term string and push string 
4c46			 
4c46 7d					ld a,l 
4c47 32 be f1				ld (scratch), a 
4c4a			 
4c4a 3e 00				ld a, 0 
4c4c 32 bf f1				ld (scratch+1), a 
4c4f			 
4c4f 21 be f1				ld hl, scratch 
4c52 cd 83 21				call forth_push_str 
4c55			 
4c55			 
4c55				       NEXTW 
4c55 c3 c2 24			jp macro_next 
4c58				endm 
# End of macro NEXTW
4c58			 
4c58			 
4c58			 
4c58			 
4c58			.ENDSTR: 
4c58			; eof 
4c58			 
# End of file forth_words_str.asm
4c58			include "forth_words_key.asm" 
4c58			 
4c58			; | ## Keyboard Words 
4c58			 
4c58			.KEY: 
4c58				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c58 3e				db WORD_SYS_CORE+42             
4c59 88 4c			dw .WAITK            
4c5b 04				db 3 + 1 
4c5c .. 00			db "KEY",0              
4c60				endm 
# End of macro CWHEAD
4c60			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4c60			 
4c60					if DEBUG_FORTH_WORDS_KEY 
4c60						DMARK "KEY" 
4c60 f5				push af  
4c61 3a 75 4c			ld a, (.dmark)  
4c64 32 68 fe			ld (debug_mark),a  
4c67 3a 76 4c			ld a, (.dmark+1)  
4c6a 32 69 fe			ld (debug_mark+1),a  
4c6d 3a 77 4c			ld a, (.dmark+2)  
4c70 32 6a fe			ld (debug_mark+2),a  
4c73 18 03			jr .pastdmark  
4c75 ..			.dmark: db "KEY"  
4c78 f1			.pastdmark: pop af  
4c79			endm  
# End of macro DMARK
4c79						CALLMONITOR 
4c79 cd 6c fe			call debug_vector  
4c7c				endm  
# End of macro CALLMONITOR
4c7c					endif 
4c7c			; TODO currently waits 
4c7c cd e4 79				call cin 
4c7f					;call cin_wait 
4c7f 6f					ld l, a 
4c80 26 00				ld h, 0 
4c82 cd 15 21				call forth_push_numhl 
4c85					NEXTW 
4c85 c3 c2 24			jp macro_next 
4c88				endm 
# End of macro NEXTW
4c88			.WAITK: 
4c88				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c88 3f				db WORD_SYS_CORE+43             
4c89 ba 4c			dw .ACCEPT            
4c8b 06				db 5 + 1 
4c8c .. 00			db "WAITK",0              
4c92				endm 
# End of macro CWHEAD
4c92			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c92					if DEBUG_FORTH_WORDS_KEY 
4c92						DMARK "WAI" 
4c92 f5				push af  
4c93 3a a7 4c			ld a, (.dmark)  
4c96 32 68 fe			ld (debug_mark),a  
4c99 3a a8 4c			ld a, (.dmark+1)  
4c9c 32 69 fe			ld (debug_mark+1),a  
4c9f 3a a9 4c			ld a, (.dmark+2)  
4ca2 32 6a fe			ld (debug_mark+2),a  
4ca5 18 03			jr .pastdmark  
4ca7 ..			.dmark: db "WAI"  
4caa f1			.pastdmark: pop af  
4cab			endm  
# End of macro DMARK
4cab						CALLMONITOR 
4cab cd 6c fe			call debug_vector  
4cae				endm  
# End of macro CALLMONITOR
4cae					endif 
4cae cd d3 79				call cin_wait 
4cb1 6f					ld l, a 
4cb2 26 00				ld h, 0 
4cb4 cd 15 21				call forth_push_numhl 
4cb7					NEXTW 
4cb7 c3 c2 24			jp macro_next 
4cba				endm 
# End of macro NEXTW
4cba			.ACCEPT: 
4cba				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4cba 40				db WORD_SYS_CORE+44             
4cbb 18 4d			dw .EDIT            
4cbd 07				db 6 + 1 
4cbe .. 00			db "ACCEPT",0              
4cc5				endm 
# End of macro CWHEAD
4cc5			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4cc5					; TODO crashes on push 
4cc5					if DEBUG_FORTH_WORDS_KEY 
4cc5						DMARK "ACC" 
4cc5 f5				push af  
4cc6 3a da 4c			ld a, (.dmark)  
4cc9 32 68 fe			ld (debug_mark),a  
4ccc 3a db 4c			ld a, (.dmark+1)  
4ccf 32 69 fe			ld (debug_mark+1),a  
4cd2 3a dc 4c			ld a, (.dmark+2)  
4cd5 32 6a fe			ld (debug_mark+2),a  
4cd8 18 03			jr .pastdmark  
4cda ..			.dmark: db "ACC"  
4cdd f1			.pastdmark: pop af  
4cde			endm  
# End of macro DMARK
4cde						CALLMONITOR 
4cde cd 6c fe			call debug_vector  
4ce1				endm  
# End of macro CALLMONITOR
4ce1					endif 
4ce1 21 bc f3				ld hl, os_input 
4ce4 3e 00				ld a, 0 
4ce6 77					ld (hl),a 
4ce7 3a 5b fa				ld a,(f_cursor_ptr) 
4cea 16 64				ld d, 100 
4cec 0e 00				ld c, 0 
4cee 1e 28				ld e, 40 
4cf0 cd fd 0f				call input_str 
4cf3					; TODO perhaps do a type check and wrap in quotes if not a number 
4cf3 21 bc f3				ld hl, os_input 
4cf6					if DEBUG_FORTH_WORDS 
4cf6						DMARK "AC1" 
4cf6 f5				push af  
4cf7 3a 0b 4d			ld a, (.dmark)  
4cfa 32 68 fe			ld (debug_mark),a  
4cfd 3a 0c 4d			ld a, (.dmark+1)  
4d00 32 69 fe			ld (debug_mark+1),a  
4d03 3a 0d 4d			ld a, (.dmark+2)  
4d06 32 6a fe			ld (debug_mark+2),a  
4d09 18 03			jr .pastdmark  
4d0b ..			.dmark: db "AC1"  
4d0e f1			.pastdmark: pop af  
4d0f			endm  
# End of macro DMARK
4d0f						CALLMONITOR 
4d0f cd 6c fe			call debug_vector  
4d12				endm  
# End of macro CALLMONITOR
4d12					endif 
4d12 cd 83 21				call forth_push_str 
4d15					NEXTW 
4d15 c3 c2 24			jp macro_next 
4d18				endm 
# End of macro NEXTW
4d18			 
4d18			.EDIT: 
4d18				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d18 40				db WORD_SYS_CORE+44             
4d19 ba 4d			dw .DEDIT            
4d1b 05				db 4 + 1 
4d1c .. 00			db "EDIT",0              
4d21				endm 
# End of macro CWHEAD
4d21			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d21			 
4d21					; TODO does not copy from stack 
4d21					if DEBUG_FORTH_WORDS_KEY 
4d21						DMARK "EDT" 
4d21 f5				push af  
4d22 3a 36 4d			ld a, (.dmark)  
4d25 32 68 fe			ld (debug_mark),a  
4d28 3a 37 4d			ld a, (.dmark+1)  
4d2b 32 69 fe			ld (debug_mark+1),a  
4d2e 3a 38 4d			ld a, (.dmark+2)  
4d31 32 6a fe			ld (debug_mark+2),a  
4d34 18 03			jr .pastdmark  
4d36 ..			.dmark: db "EDT"  
4d39 f1			.pastdmark: pop af  
4d3a			endm  
# End of macro DMARK
4d3a						CALLMONITOR 
4d3a cd 6c fe			call debug_vector  
4d3d				endm  
# End of macro CALLMONITOR
4d3d					endif 
4d3d			 
4d3d					;FORTH_DSP 
4d3d					FORTH_DSP_VALUEHL 
4d3d cd 0c 23			call macro_dsp_valuehl 
4d40				endm 
# End of macro FORTH_DSP_VALUEHL
4d40			;		inc hl    ; TODO do type check 
4d40			 
4d40			;		call get_word_hl 
4d40 e5					push hl 
4d41					if DEBUG_FORTH_WORDS 
4d41						DMARK "EDp" 
4d41 f5				push af  
4d42 3a 56 4d			ld a, (.dmark)  
4d45 32 68 fe			ld (debug_mark),a  
4d48 3a 57 4d			ld a, (.dmark+1)  
4d4b 32 69 fe			ld (debug_mark+1),a  
4d4e 3a 58 4d			ld a, (.dmark+2)  
4d51 32 6a fe			ld (debug_mark+2),a  
4d54 18 03			jr .pastdmark  
4d56 ..			.dmark: db "EDp"  
4d59 f1			.pastdmark: pop af  
4d5a			endm  
# End of macro DMARK
4d5a						CALLMONITOR 
4d5a cd 6c fe			call debug_vector  
4d5d				endm  
# End of macro CALLMONITOR
4d5d					endif 
4d5d				;	ld a, 0 
4d5d cd 2e 14				call strlenz 
4d60 23					inc hl 
4d61			 
4d61 06 00				ld b, 0 
4d63 4d					ld c, l 
4d64			 
4d64 e1					pop hl 
4d65 11 bc f3				ld de, os_input 
4d68					if DEBUG_FORTH_WORDS_KEY 
4d68						DMARK "EDc" 
4d68 f5				push af  
4d69 3a 7d 4d			ld a, (.dmark)  
4d6c 32 68 fe			ld (debug_mark),a  
4d6f 3a 7e 4d			ld a, (.dmark+1)  
4d72 32 69 fe			ld (debug_mark+1),a  
4d75 3a 7f 4d			ld a, (.dmark+2)  
4d78 32 6a fe			ld (debug_mark+2),a  
4d7b 18 03			jr .pastdmark  
4d7d ..			.dmark: db "EDc"  
4d80 f1			.pastdmark: pop af  
4d81			endm  
# End of macro DMARK
4d81						CALLMONITOR 
4d81 cd 6c fe			call debug_vector  
4d84				endm  
# End of macro CALLMONITOR
4d84					endif 
4d84 ed b0				ldir 
4d86			 
4d86			 
4d86 21 bc f3				ld hl, os_input 
4d89					;ld a, 0 
4d89					;ld (hl),a 
4d89 3a 5b fa				ld a,(f_cursor_ptr) 
4d8c 16 64				ld d, 100 
4d8e 0e 00				ld c, 0 
4d90 1e 28				ld e, 40 
4d92 cd fd 0f				call input_str 
4d95					; TODO perhaps do a type check and wrap in quotes if not a number 
4d95 21 bc f3				ld hl, os_input 
4d98					if DEBUG_FORTH_WORDS 
4d98						DMARK "ED1" 
4d98 f5				push af  
4d99 3a ad 4d			ld a, (.dmark)  
4d9c 32 68 fe			ld (debug_mark),a  
4d9f 3a ae 4d			ld a, (.dmark+1)  
4da2 32 69 fe			ld (debug_mark+1),a  
4da5 3a af 4d			ld a, (.dmark+2)  
4da8 32 6a fe			ld (debug_mark+2),a  
4dab 18 03			jr .pastdmark  
4dad ..			.dmark: db "ED1"  
4db0 f1			.pastdmark: pop af  
4db1			endm  
# End of macro DMARK
4db1						CALLMONITOR 
4db1 cd 6c fe			call debug_vector  
4db4				endm  
# End of macro CALLMONITOR
4db4					endif 
4db4 cd 83 21				call forth_push_str 
4db7					NEXTW 
4db7 c3 c2 24			jp macro_next 
4dba				endm 
# End of macro NEXTW
4dba			 
4dba			.DEDIT: 
4dba				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4dba 40				db WORD_SYS_CORE+44             
4dbb 1c 4e			dw .ENDKEY            
4dbd 06				db 5 + 1 
4dbe .. 00			db "DEDIT",0              
4dc4				endm 
# End of macro CWHEAD
4dc4			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4dc4			 
4dc4					; TODO does not copy from stack 
4dc4					if DEBUG_FORTH_WORDS_KEY 
4dc4						DMARK "DED" 
4dc4 f5				push af  
4dc5 3a d9 4d			ld a, (.dmark)  
4dc8 32 68 fe			ld (debug_mark),a  
4dcb 3a da 4d			ld a, (.dmark+1)  
4dce 32 69 fe			ld (debug_mark+1),a  
4dd1 3a db 4d			ld a, (.dmark+2)  
4dd4 32 6a fe			ld (debug_mark+2),a  
4dd7 18 03			jr .pastdmark  
4dd9 ..			.dmark: db "DED"  
4ddc f1			.pastdmark: pop af  
4ddd			endm  
# End of macro DMARK
4ddd						CALLMONITOR 
4ddd cd 6c fe			call debug_vector  
4de0				endm  
# End of macro CALLMONITOR
4de0					endif 
4de0			 
4de0					;FORTH_DSP 
4de0					FORTH_DSP_VALUEHL 
4de0 cd 0c 23			call macro_dsp_valuehl 
4de3				endm 
# End of macro FORTH_DSP_VALUEHL
4de3			;		inc hl    ; TODO do type check 
4de3			 
4de3			;		call get_word_hl 
4de3 e5					push hl 
4de4 e5					push hl 
4de5					FORTH_DSP_POP 
4de5 cd c4 23			call macro_forth_dsp_pop 
4de8				endm 
# End of macro FORTH_DSP_POP
4de8 e1					pop hl 
4de9					if DEBUG_FORTH_WORDS 
4de9						DMARK "EDp" 
4de9 f5				push af  
4dea 3a fe 4d			ld a, (.dmark)  
4ded 32 68 fe			ld (debug_mark),a  
4df0 3a ff 4d			ld a, (.dmark+1)  
4df3 32 69 fe			ld (debug_mark+1),a  
4df6 3a 00 4e			ld a, (.dmark+2)  
4df9 32 6a fe			ld (debug_mark+2),a  
4dfc 18 03			jr .pastdmark  
4dfe ..			.dmark: db "EDp"  
4e01 f1			.pastdmark: pop af  
4e02			endm  
# End of macro DMARK
4e02						CALLMONITOR 
4e02 cd 6c fe			call debug_vector  
4e05				endm  
# End of macro CALLMONITOR
4e05					endif 
4e05				;	ld a, 0 
4e05 cd 2e 14				call strlenz 
4e08 23					inc hl 
4e09			 
4e09 06 00				ld b, 0 
4e0b 4d					ld c, l 
4e0c			 
4e0c e1					pop hl 
4e0d			 
4e0d					;ld a, 0 
4e0d					;ld (hl),a 
4e0d 3a 5b fa				ld a,(f_cursor_ptr) 
4e10 16 64				ld d, 100 
4e12 0e 00				ld c, 0 
4e14 1e 28				ld e, 40 
4e16 cd fd 0f				call input_str 
4e19					; TODO perhaps do a type check and wrap in quotes if not a number 
4e19					NEXTW 
4e19 c3 c2 24			jp macro_next 
4e1c				endm 
# End of macro NEXTW
4e1c			 
4e1c			 
4e1c			.ENDKEY: 
4e1c			; eof 
4e1c			 
# End of file forth_words_key.asm
4e1c			include "forth_words_const.asm" 
4e1c			 
4e1c			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e1c			 
4e1c			 
4e1c			.SPITIME: 
4e1c				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e1c 77				db WORD_SYS_CORE+99             
4e1d 31 4e			dw .VA            
4e1f 08				db 7 + 1 
4e20 .. 00			db "SPITIME",0              
4e28				endm 
# End of macro CWHEAD
4e28			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4e28			; 
4e28			; | If using BANK devices then leave as is. 
4e28			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4e28			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4e28			 
4e28 21 61 fa				ld hl, spi_clktime  
4e2b cd 15 21				call forth_push_numhl 
4e2e			 
4e2e					NEXTW 
4e2e c3 c2 24			jp macro_next 
4e31				endm 
# End of macro NEXTW
4e31			 
4e31			 
4e31			.VA: 
4e31				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4e31 77				db WORD_SYS_CORE+99             
4e32 41 4e			dw .SYMBOL            
4e34 03				db 2 + 1 
4e35 .. 00			db "VA",0              
4e38				endm 
# End of macro CWHEAD
4e38			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4e38 21 25 fa				ld hl, cli_var_array 
4e3b cd 15 21				call forth_push_numhl 
4e3e			 
4e3e					NEXTW 
4e3e c3 c2 24			jp macro_next 
4e41				endm 
# End of macro NEXTW
4e41			 
4e41			.SYMBOL: 
4e41				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4e41 77				db WORD_SYS_CORE+99             
4e42 4b 4f			dw .ENDCONST            
4e44 07				db 6 + 1 
4e45 .. 00			db "SYMBOL",0              
4e4c				endm 
# End of macro CWHEAD
4e4c			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e4c			; | 
4e4c			; | The value is the number reference and the final address is pushed to stack 
4e4c			 
4e4c			; | dw sym_table 
4e4c			; | dw nmi_vector 
4e4c			; | dw cli_autodisplay 
4e4c			; | dw cli_data_sp 
4e4c			; | dw cli_data_stack 
4e4c			; | dw cli_loop_sp 
4e4c			; | dw cli_loop_stack 
4e4c			; | dw cli_var_array 
4e4c			; | dw cursor_col 
4e4c			; | dw cursor_ptr 
4e4c			; | ; 10 
4e4c			; | dw cursor_row 
4e4c			; | dw debug_mark 
4e4c			; | dw display_fb0 
4e4c			; | dw display_fb1 
4e4c			; | dw display_fb2 
4e4c			; | dw display_fb3 
4e4c			; | dw display_fb_active 
4e4c			; | dw execscratch 
4e4c			; | dw f_cursor_ptr 
4e4c			; | dw hardware_word 
4e4c			; | ;20 
4e4c			; | dw input_at_cursor 
4e4c			; | dw input_at_pos 
4e4c			; | dw input_cur_flash 
4e4c			; | dw input_cur_onoff 
4e4c			; | dw input_cursor 
4e4c			; | dw input_display_size 
4e4c			; | dw input_len 
4e4c			; | dw input_ptr 
4e4c			; | dw input_size 
4e4c			; | dw input_start 
4e4c			; | ; 30 
4e4c			; | dw input_str 
4e4c			; | dw input_under_cursor 
4e4c			; | dw os_cli_cmd 
4e4c			; | dw os_cur_ptr 
4e4c			; | dw os_current_i 
4e4c			; | dw os_input 
4e4c			; | dw os_last_cmd 
4e4c			; | dw os_last_new_uword 
4e4c			; | dw debug_vector 
4e4c			; | dw os_view_hl 
4e4c			; | ;40 
4e4c			; | dw os_word_scratch 
4e4c			; | dw portbctl 
4e4c			; | dw portbdata 
4e4c			; | dw spi_cartdev 
4e4c			; | dw spi_cartdev2 
4e4c			; | dw spi_clktime 
4e4c			; | dw spi_device 
4e4c			; | dw spi_device_id 
4e4c			; | dw spi_portbyte 
4e4c			; | dw stackstore 
4e4c			; | ; 50 
4e4c			; | if STORAGE_SE 
4e4c			; | dw storage_actl 
4e4c			; | dw storage_adata 
4e4c			; | else 
4e4c			; | dw 0 
4e4c			; | dw 0 
4e4c			; | endif 
4e4c			; | dw storage_append 
4e4c			; | if STORAGE_SE 
4e4c			; | dw storage_bctl 
4e4c			; | else 
4e4c			; | dw 0 
4e4c			; | endif 
4e4c			; | dw store_bank_active 
4e4c			; | dw store_filecache 
4e4c			; | dw store_longread 
4e4c			; | dw store_openaddr 
4e4c			; | dw store_openext 
4e4c			; | dw store_openmaxext 
4e4c			; | ; 60 
4e4c			; | dw store_page 
4e4c			; | dw store_readbuf 
4e4c			; | dw store_readcont 
4e4c			; | dw store_readptr 
4e4c			; | dw store_tmpext 
4e4c			; | dw store_tmpid 
4e4c			; | dw store_tmppageid 
4e4c			; | dw malloc 
4e4c			; | dw free 
4e4c			; | dw cin 
4e4c			; | ; 70 
4e4c			; | dw cin_wait 
4e4c			; | dw forth_push_numhl 
4e4c			; | dw forth_push_str 
4e4c			 
4e4c					if DEBUG_FORTH_WORDS_KEY 
4e4c						DMARK "SYM" 
4e4c f5				push af  
4e4d 3a 61 4e			ld a, (.dmark)  
4e50 32 68 fe			ld (debug_mark),a  
4e53 3a 62 4e			ld a, (.dmark+1)  
4e56 32 69 fe			ld (debug_mark+1),a  
4e59 3a 63 4e			ld a, (.dmark+2)  
4e5c 32 6a fe			ld (debug_mark+2),a  
4e5f 18 03			jr .pastdmark  
4e61 ..			.dmark: db "SYM"  
4e64 f1			.pastdmark: pop af  
4e65			endm  
# End of macro DMARK
4e65						CALLMONITOR 
4e65 cd 6c fe			call debug_vector  
4e68				endm  
# End of macro CALLMONITOR
4e68					endif 
4e68			 
4e68					FORTH_DSP_VALUEHL 
4e68 cd 0c 23			call macro_dsp_valuehl 
4e6b				endm 
# End of macro FORTH_DSP_VALUEHL
4e6b			 
4e6b 7d					ld a, l     
4e6c			 
4e6c			 
4e6c					if DEBUG_FORTH_WORDS 
4e6c						DMARK "SY1" 
4e6c f5				push af  
4e6d 3a 81 4e			ld a, (.dmark)  
4e70 32 68 fe			ld (debug_mark),a  
4e73 3a 82 4e			ld a, (.dmark+1)  
4e76 32 69 fe			ld (debug_mark+1),a  
4e79 3a 83 4e			ld a, (.dmark+2)  
4e7c 32 6a fe			ld (debug_mark+2),a  
4e7f 18 03			jr .pastdmark  
4e81 ..			.dmark: db "SY1"  
4e84 f1			.pastdmark: pop af  
4e85			endm  
# End of macro DMARK
4e85						CALLMONITOR 
4e85 cd 6c fe			call debug_vector  
4e88				endm  
# End of macro CALLMONITOR
4e88					endif 
4e88					 
4e88 f5					push af	 
4e89					FORTH_DSP_POP 
4e89 cd c4 23			call macro_forth_dsp_pop 
4e8c				endm 
# End of macro FORTH_DSP_POP
4e8c f1					pop af 
4e8d			 
4e8d cb 27				sla a  
4e8f				 
4e8f					 
4e8f					if DEBUG_FORTH_WORDS 
4e8f						DMARK "SY" 
4e8f f5				push af  
4e90 3a a4 4e			ld a, (.dmark)  
4e93 32 68 fe			ld (debug_mark),a  
4e96 3a a5 4e			ld a, (.dmark+1)  
4e99 32 69 fe			ld (debug_mark+1),a  
4e9c 3a a6 4e			ld a, (.dmark+2)  
4e9f 32 6a fe			ld (debug_mark+2),a  
4ea2 18 02			jr .pastdmark  
4ea4 ..			.dmark: db "SY"  
4ea6 f1			.pastdmark: pop af  
4ea7			endm  
# End of macro DMARK
4ea7						CALLMONITOR 
4ea7 cd 6c fe			call debug_vector  
4eaa				endm  
# End of macro CALLMONITOR
4eaa					endif 
4eaa			 
4eaa 21 b9 4e				ld hl, sym_table 
4ead cd d0 0f				call addatohl 
4eb0 cd 44 24				call loadwordinhl 
4eb3 cd 15 21				call forth_push_numhl 
4eb6			 
4eb6			 
4eb6				       NEXTW 
4eb6 c3 c2 24			jp macro_next 
4eb9				endm 
# End of macro NEXTW
4eb9			 
4eb9			sym_table: 
4eb9			 
4eb9			; 0 
4eb9 b9 4e		dw sym_table 
4ebb 6f fe		dw nmi_vector 
4ebd 39 fa		dw cli_autodisplay 
4ebf eb f9		dw cli_data_sp 
4ec1 25 f7		dw cli_data_stack 
4ec3 ed f9		dw cli_loop_sp 
4ec5 27 f9		dw cli_loop_stack 
4ec7 25 fa		dw cli_var_array 
4ec9 c2 fb		dw cursor_col 
4ecb c0 fb		dw cursor_ptr 
4ecd			; 10 
4ecd c1 fb		dw cursor_row 
4ecf 68 fe		dw debug_mark 
4ed1 ae fd		dw display_fb0 
4ed3 0d fd		dw display_fb1 
4ed5 cb fb		dw display_fb2 
4ed7 6c fc		dw display_fb3 
4ed9 c9 fb		dw display_fb_active 
4edb bd f2		dw execscratch 
4edd 5b fa		dw f_cursor_ptr 
4edf 72 fe		dw hardware_word 
4ee1			;20 
4ee1 5f fe		dw input_at_cursor 
4ee3 61 fe		dw input_at_pos 
4ee5 5d fe		dw input_cur_flash 
4ee7 5c fe		dw input_cur_onoff 
4ee9 52 fe		dw input_cursor 
4eeb 62 fe		dw input_display_size 
4eed 57 fe		dw input_len 
4eef 66 fe		dw input_ptr 
4ef1 63 fe		dw input_size 
4ef3 64 fe		dw input_start 
4ef5			; 30 
4ef5 fd 0f		dw input_str 
4ef7 60 fe		dw input_under_cursor 
4ef9 e5 f4		dw os_cli_cmd 
4efb e1 f4		dw os_cur_ptr 
4efd e3 f4		dw os_current_i 
4eff bc f3		dw os_input 
4f01 e4 f5		dw os_last_cmd 
4f03 bb f4		dw os_last_new_uword 
4f05 6c fe		dw debug_vector 
4f07 ac f1		dw os_view_hl 
4f09			;40 
4f09 c3 f4		dw os_word_scratch 
4f0b c3 00		dw portbctl 
4f0d c1 00		dw portbdata 
4f0f 60 fa		dw spi_cartdev 
4f11 5f fa		dw spi_cartdev2 
4f13 61 fa		dw spi_clktime 
4f15 5d fa		dw spi_device 
4f17 5c fa		dw spi_device_id 
4f19 5e fa		dw spi_portbyte 
4f1b a4 fb		dw stackstore 
4f1d			; 50 
4f1d			if STORAGE_SE 
4f1d 82 00		dw storage_actl 
4f1f 80 00		dw storage_adata 
4f21			else 
4f21			dw 0 
4f21			dw 0 
4f21			endif 
4f21 56 0b		dw storage_append 
4f23			if STORAGE_SE 
4f23 83 00		dw storage_bctl 
4f25			else 
4f25			dw 0 
4f25			endif 
4f25 90 fb		dw store_bank_active 
4f27 64 fa		dw store_filecache 
4f29 72 fa		dw store_longread 
4f2b 68 fa		dw store_openaddr 
4f2d 67 fa		dw store_openext 
4f2f 66 fa		dw store_openmaxext 
4f31			; 60 
4f31 77 fa		dw store_page 
4f33 73 fa		dw store_readbuf 
4f35 6a fa		dw store_readcont 
4f37 75 fa		dw store_readptr 
4f39 6a fa		dw store_tmpext 
4f3b 6b fa		dw store_tmpid 
4f3d 62 fa		dw store_tmppageid 
4f3f 97 14		dw malloc 
4f41 61 15		dw free 
4f43 e4 79		dw cin 
4f45			; 70 
4f45 d3 79		dw cin_wait 
4f47 15 21		dw forth_push_numhl 
4f49 83 21		dw forth_push_str 
4f4b			 
4f4b			 
4f4b			.ENDCONST: 
4f4b			 
4f4b			; eof 
4f4b			 
4f4b			 
# End of file forth_words_const.asm
4f4b			 
4f4b			if STORAGE_SE 
4f4b			   	include "forth_words_storage.asm" 
4f4b			 
4f4b			; | ## Fixed Storage Words 
4f4b			 
4f4b			.RENAME: 
4f4b			  
4f4b				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f4b 3a				db WORD_SYS_CORE+38             
4f4c 41 50			dw .RECORD            
4f4e 07				db 6 + 1 
4f4f .. 00			db "RENAME",0              
4f56				endm 
# End of macro CWHEAD
4f56			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f56			; | | Compatible with PicoSPINet  
4f56					if DEBUG_FORTH_WORDS_KEY 
4f56						DMARK "REN" 
4f56 f5				push af  
4f57 3a 6b 4f			ld a, (.dmark)  
4f5a 32 68 fe			ld (debug_mark),a  
4f5d 3a 6c 4f			ld a, (.dmark+1)  
4f60 32 69 fe			ld (debug_mark+1),a  
4f63 3a 6d 4f			ld a, (.dmark+2)  
4f66 32 6a fe			ld (debug_mark+2),a  
4f69 18 03			jr .pastdmark  
4f6b ..			.dmark: db "REN"  
4f6e f1			.pastdmark: pop af  
4f6f			endm  
# End of macro DMARK
4f6f						CALLMONITOR 
4f6f cd 6c fe			call debug_vector  
4f72				endm  
# End of macro CALLMONITOR
4f72					endif 
4f72			 
4f72			 
4f72					; preserve some internal vars used by other file handing routines 
4f72			 
4f72 2a 68 fa				ld hl, (store_openaddr) 
4f75 e5					push hl 
4f76 3a 6a fa				ld a, (store_readcont) 
4f79 f5					push af 
4f7a			 
4f7a					FORTH_DSP_VALUEHL 
4f7a cd 0c 23			call macro_dsp_valuehl 
4f7d				endm 
# End of macro FORTH_DSP_VALUEHL
4f7d			 
4f7d					; move ext and id around for the file header 
4f7d			 
4f7d 65					ld h, l 
4f7e 2e 00				ld l, 0 
4f80			 
4f80 e5					push hl    ; id 
4f81			 
4f81					FORTH_DSP_POP 
4f81 cd c4 23			call macro_forth_dsp_pop 
4f84				endm 
# End of macro FORTH_DSP_POP
4f84			 
4f84					; Locate the file header 
4f84			 
4f84 e1					pop hl 
4f85 e5					push hl 
4f86 11 77 fa				ld de, store_page      ; get block zero of file 
4f89					if DEBUG_FORTH_WORDS 
4f89						DMARK "REr" 
4f89 f5				push af  
4f8a 3a 9e 4f			ld a, (.dmark)  
4f8d 32 68 fe			ld (debug_mark),a  
4f90 3a 9f 4f			ld a, (.dmark+1)  
4f93 32 69 fe			ld (debug_mark+1),a  
4f96 3a a0 4f			ld a, (.dmark+2)  
4f99 32 6a fe			ld (debug_mark+2),a  
4f9c 18 03			jr .pastdmark  
4f9e ..			.dmark: db "REr"  
4fa1 f1			.pastdmark: pop af  
4fa2			endm  
# End of macro DMARK
4fa2						CALLMONITOR 
4fa2 cd 6c fe			call debug_vector  
4fa5				endm  
# End of macro CALLMONITOR
4fa5					endif 
4fa5 cd bf 09				call storage_read 
4fa8			 
4fa8 cd f9 0f			call ishlzero 
4fab 20 05			jr nz, .rnfound 
4fad			 
4fad				; file does not exist so indicate with 255 extents in use 
4fad			 
4fad 3e ff			ld a, 255 
4faf e1				pop hl ; clear dup hl 
4fb0 18 7b			jr .skiprneof 
4fb2			 
4fb2			 
4fb2			.rnfound: 
4fb2					; file found so rename 
4fb2			 
4fb2					FORTH_DSP_VALUEHL 
4fb2 cd 0c 23			call macro_dsp_valuehl 
4fb5				endm 
# End of macro FORTH_DSP_VALUEHL
4fb5			 
4fb5 e5				push hl 
4fb6 3e 00			ld a, 0 
4fb8 cd 39 14			call strlent 
4fbb 23				inc hl   ; cover zero term 
4fbc 06 00			ld b,0 
4fbe 4d				ld c,l 
4fbf e1				pop hl 
4fc0 11 7a fa				ld de, store_page + 3 
4fc3 ed b0				ldir 
4fc5			 
4fc5 11 77 fa				ld de, store_page 
4fc8					if DEBUG_FORTH_WORDS 
4fc8						DMARK "RER" 
4fc8 f5				push af  
4fc9 3a dd 4f			ld a, (.dmark)  
4fcc 32 68 fe			ld (debug_mark),a  
4fcf 3a de 4f			ld a, (.dmark+1)  
4fd2 32 69 fe			ld (debug_mark+1),a  
4fd5 3a df 4f			ld a, (.dmark+2)  
4fd8 32 6a fe			ld (debug_mark+2),a  
4fdb 18 03			jr .pastdmark  
4fdd ..			.dmark: db "RER"  
4fe0 f1			.pastdmark: pop af  
4fe1			endm  
# End of macro DMARK
4fe1						CALLMONITOR 
4fe1 cd 6c fe			call debug_vector  
4fe4				endm  
# End of macro CALLMONITOR
4fe4					endif 
4fe4			 
4fe4 e1					pop hl    ; get orig file id and mangle it for find id 
4fe5 55					ld d, l 
4fe6 5c					ld e, h 
4fe7			 
4fe7 21 00 00				ld hl, 0 
4fea					if DEBUG_FORTH_WORDS 
4fea						DMARK "REf" 
4fea f5				push af  
4feb 3a ff 4f			ld a, (.dmark)  
4fee 32 68 fe			ld (debug_mark),a  
4ff1 3a 00 50			ld a, (.dmark+1)  
4ff4 32 69 fe			ld (debug_mark+1),a  
4ff7 3a 01 50			ld a, (.dmark+2)  
4ffa 32 6a fe			ld (debug_mark+2),a  
4ffd 18 03			jr .pastdmark  
4fff ..			.dmark: db "REf"  
5002 f1			.pastdmark: pop af  
5003			endm  
# End of macro DMARK
5003						CALLMONITOR 
5003 cd 6c fe			call debug_vector  
5006				endm  
# End of macro CALLMONITOR
5006					endif 
5006 cd 99 07				call storage_findnextid 
5009 11 77 fa				ld de, store_page 
500c					if DEBUG_FORTH_WORDS 
500c						DMARK "REw" 
500c f5				push af  
500d 3a 21 50			ld a, (.dmark)  
5010 32 68 fe			ld (debug_mark),a  
5013 3a 22 50			ld a, (.dmark+1)  
5016 32 69 fe			ld (debug_mark+1),a  
5019 3a 23 50			ld a, (.dmark+2)  
501c 32 6a fe			ld (debug_mark+2),a  
501f 18 03			jr .pastdmark  
5021 ..			.dmark: db "REw"  
5024 f1			.pastdmark: pop af  
5025			endm  
# End of macro DMARK
5025						CALLMONITOR 
5025 cd 6c fe			call debug_vector  
5028				endm  
# End of macro CALLMONITOR
5028					endif 
5028 cd cb 04				call storage_write_block 
502b			 
502b 3e 00				ld a, 0 
502d			.skiprneof: 
502d					; drop file name 
502d					FORTH_DSP_POP 
502d cd c4 23			call macro_forth_dsp_pop 
5030				endm 
# End of macro FORTH_DSP_POP
5030			 
5030 6f					ld l, a 
5031 26 00				ld h, 0 
5033 cd 15 21				call forth_push_numhl 
5036			 
5036			 
5036 f1					pop af 
5037 32 6a fa				ld (store_readcont),a 
503a e1					pop hl 
503b 22 68 fa				ld (store_openaddr), hl 
503e						 
503e				NEXTW 
503e c3 c2 24			jp macro_next 
5041				endm 
# End of macro NEXTW
5041			.RECORD: 
5041			  
5041				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5041 3a				db WORD_SYS_CORE+38             
5042 e5 50			dw .BREAD            
5044 07				db 6 + 1 
5045 .. 00			db "RECORD",0              
504c				endm 
# End of macro CWHEAD
504c			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
504c			; | | Compatible with PicoSPINet  
504c			 
504c					if DEBUG_FORTH_WORDS_KEY 
504c						DMARK "REC" 
504c f5				push af  
504d 3a 61 50			ld a, (.dmark)  
5050 32 68 fe			ld (debug_mark),a  
5053 3a 62 50			ld a, (.dmark+1)  
5056 32 69 fe			ld (debug_mark+1),a  
5059 3a 63 50			ld a, (.dmark+2)  
505c 32 6a fe			ld (debug_mark+2),a  
505f 18 03			jr .pastdmark  
5061 ..			.dmark: db "REC"  
5064 f1			.pastdmark: pop af  
5065			endm  
# End of macro DMARK
5065						CALLMONITOR 
5065 cd 6c fe			call debug_vector  
5068				endm  
# End of macro CALLMONITOR
5068					endif 
5068			 
5068					FORTH_DSP_VALUEHL 
5068 cd 0c 23			call macro_dsp_valuehl 
506b				endm 
# End of macro FORTH_DSP_VALUEHL
506b			 
506b e5					push hl    ; id 
506c			 
506c					FORTH_DSP_POP 
506c cd c4 23			call macro_forth_dsp_pop 
506f				endm 
# End of macro FORTH_DSP_POP
506f			 
506f					FORTH_DSP_VALUEHL 
506f cd 0c 23			call macro_dsp_valuehl 
5072				endm 
# End of macro FORTH_DSP_VALUEHL
5072			 
5072					FORTH_DSP_POP 
5072 cd c4 23			call macro_forth_dsp_pop 
5075				endm 
# End of macro FORTH_DSP_POP
5075			 
5075 d1					pop de     ; get file id 
5076			 
5076					; e = file id 
5076					; l = file extent 
5076			 
5076			 
5076					; construct request to access file extent 
5076			 
5076			;		ld a, e 
5076 63					ld h, e 
5077					 
5077					 
5077					 
5077			 
5077					; e has id 
5077			 
5077 11 77 fa			ld de, store_page 
507a					if DEBUG_FORTH_WORDS 
507a						DMARK "REr" 
507a f5				push af  
507b 3a 8f 50			ld a, (.dmark)  
507e 32 68 fe			ld (debug_mark),a  
5081 3a 90 50			ld a, (.dmark+1)  
5084 32 69 fe			ld (debug_mark+1),a  
5087 3a 91 50			ld a, (.dmark+2)  
508a 32 6a fe			ld (debug_mark+2),a  
508d 18 03			jr .pastdmark  
508f ..			.dmark: db "REr"  
5092 f1			.pastdmark: pop af  
5093			endm  
# End of macro DMARK
5093						CALLMONITOR 
5093 cd 6c fe			call debug_vector  
5096				endm  
# End of macro CALLMONITOR
5096					endif 
5096 cd bf 09				call storage_read 
5099 cd f9 0f			call ishlzero 
509c 28 22			jr z, .recnotfound 
509e			 
509e			 
509e					if DEBUG_FORTH_WORDS 
509e						DMARK "REe" 
509e f5				push af  
509f 3a b3 50			ld a, (.dmark)  
50a2 32 68 fe			ld (debug_mark),a  
50a5 3a b4 50			ld a, (.dmark+1)  
50a8 32 69 fe			ld (debug_mark+1),a  
50ab 3a b5 50			ld a, (.dmark+2)  
50ae 32 6a fe			ld (debug_mark+2),a  
50b1 18 03			jr .pastdmark  
50b3 ..			.dmark: db "REe"  
50b6 f1			.pastdmark: pop af  
50b7			endm  
# End of macro DMARK
50b7						CALLMONITOR 
50b7 cd 6c fe			call debug_vector  
50ba				endm  
# End of macro CALLMONITOR
50ba					endif 
50ba cd 83 21			call forth_push_str 
50bd			 
50bd					NEXTW 
50bd c3 c2 24			jp macro_next 
50c0				endm 
# End of macro NEXTW
50c0			 
50c0			.recnotfound: 
50c0					if DEBUG_FORTH_WORDS 
50c0						DMARK "REf" 
50c0 f5				push af  
50c1 3a d5 50			ld a, (.dmark)  
50c4 32 68 fe			ld (debug_mark),a  
50c7 3a d6 50			ld a, (.dmark+1)  
50ca 32 69 fe			ld (debug_mark+1),a  
50cd 3a d7 50			ld a, (.dmark+2)  
50d0 32 6a fe			ld (debug_mark+2),a  
50d3 18 03			jr .pastdmark  
50d5 ..			.dmark: db "REf"  
50d8 f1			.pastdmark: pop af  
50d9			endm  
# End of macro DMARK
50d9						CALLMONITOR 
50d9 cd 6c fe			call debug_vector  
50dc				endm  
# End of macro CALLMONITOR
50dc					endif 
50dc 21 ff 00			ld hl, 255 
50df cd 15 21			call forth_push_numhl 
50e2				NEXTW 
50e2 c3 c2 24			jp macro_next 
50e5				endm 
# End of macro NEXTW
50e5			 
50e5			 
50e5			.BREAD: 
50e5			  
50e5				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
50e5 3a				db WORD_SYS_CORE+38             
50e6 68 51			dw .BWRITE            
50e8 06				db 5 + 1 
50e9 .. 00			db "BREAD",0              
50ef				endm 
# End of macro CWHEAD
50ef			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
50ef			; | | Compatible with PicoSPINet  
50ef				 
50ef					if DEBUG_FORTH_WORDS_KEY 
50ef						DMARK "BRD" 
50ef f5				push af  
50f0 3a 04 51			ld a, (.dmark)  
50f3 32 68 fe			ld (debug_mark),a  
50f6 3a 05 51			ld a, (.dmark+1)  
50f9 32 69 fe			ld (debug_mark+1),a  
50fc 3a 06 51			ld a, (.dmark+2)  
50ff 32 6a fe			ld (debug_mark+2),a  
5102 18 03			jr .pastdmark  
5104 ..			.dmark: db "BRD"  
5107 f1			.pastdmark: pop af  
5108			endm  
# End of macro DMARK
5108						CALLMONITOR 
5108 cd 6c fe			call debug_vector  
510b				endm  
# End of macro CALLMONITOR
510b					endif 
510b			 
510b				FORTH_DSP_VALUEHL 
510b cd 0c 23			call macro_dsp_valuehl 
510e				endm 
# End of macro FORTH_DSP_VALUEHL
510e			 
510e				FORTH_DSP_POP 
510e cd c4 23			call macro_forth_dsp_pop 
5111				endm 
# End of macro FORTH_DSP_POP
5111			 
5111				; calc block address 
5111			 
5111 eb				ex de, hl 
5112 3e 40			ld a, STORE_BLOCK_PHY 
5114 cd 53 0f			call Mult16 
5117			 
5117			 
5117 11 77 fa			ld de, store_page 
511a			 
511a					if DEBUG_FORTH_WORDS 
511a						DMARK "BR1" 
511a f5				push af  
511b 3a 2f 51			ld a, (.dmark)  
511e 32 68 fe			ld (debug_mark),a  
5121 3a 30 51			ld a, (.dmark+1)  
5124 32 69 fe			ld (debug_mark+1),a  
5127 3a 31 51			ld a, (.dmark+2)  
512a 32 6a fe			ld (debug_mark+2),a  
512d 18 03			jr .pastdmark  
512f ..			.dmark: db "BR1"  
5132 f1			.pastdmark: pop af  
5133			endm  
# End of macro DMARK
5133						CALLMONITOR 
5133 cd 6c fe			call debug_vector  
5136				endm  
# End of macro CALLMONITOR
5136					endif 
5136			 
5136 cd 66 04			call storage_read_block 
5139			 
5139 cd f9 0f			call ishlzero 
513c 20 05			jr nz, .brfound 
513e			 
513e cd 15 21			call forth_push_numhl 
5141 18 22			jr .brdone 
5143			 
5143			 
5143			.brfound: 
5143 21 79 fa		        ld hl, store_page+2 
5146			 
5146					if DEBUG_FORTH_WORDS 
5146						DMARK "BR2" 
5146 f5				push af  
5147 3a 5b 51			ld a, (.dmark)  
514a 32 68 fe			ld (debug_mark),a  
514d 3a 5c 51			ld a, (.dmark+1)  
5150 32 69 fe			ld (debug_mark+1),a  
5153 3a 5d 51			ld a, (.dmark+2)  
5156 32 6a fe			ld (debug_mark+2),a  
5159 18 03			jr .pastdmark  
515b ..			.dmark: db "BR2"  
515e f1			.pastdmark: pop af  
515f			endm  
# End of macro DMARK
515f						CALLMONITOR 
515f cd 6c fe			call debug_vector  
5162				endm  
# End of macro CALLMONITOR
5162					endif 
5162			 
5162 cd 83 21			call forth_push_str 
5165			 
5165			 
5165			.brdone: 
5165			 
5165					NEXTW 
5165 c3 c2 24			jp macro_next 
5168				endm 
# End of macro NEXTW
5168			.BWRITE: 
5168				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5168 3a				db WORD_SYS_CORE+38             
5169 fd 51			dw .BUPD            
516b 07				db 6 + 1 
516c .. 00			db "BWRITE",0              
5173				endm 
# End of macro CWHEAD
5173			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5173			; | | Compatible with PicoSPINet  
5173			 
5173					if DEBUG_FORTH_WORDS_KEY 
5173						DMARK "BWR" 
5173 f5				push af  
5174 3a 88 51			ld a, (.dmark)  
5177 32 68 fe			ld (debug_mark),a  
517a 3a 89 51			ld a, (.dmark+1)  
517d 32 69 fe			ld (debug_mark+1),a  
5180 3a 8a 51			ld a, (.dmark+2)  
5183 32 6a fe			ld (debug_mark+2),a  
5186 18 03			jr .pastdmark  
5188 ..			.dmark: db "BWR"  
518b f1			.pastdmark: pop af  
518c			endm  
# End of macro DMARK
518c						CALLMONITOR 
518c cd 6c fe			call debug_vector  
518f				endm  
# End of macro CALLMONITOR
518f					endif 
518f			 
518f				FORTH_DSP_VALUEHL 
518f cd 0c 23			call macro_dsp_valuehl 
5192				endm 
# End of macro FORTH_DSP_VALUEHL
5192			 
5192				; calc block address 
5192			 
5192 eb				ex de, hl 
5193 3e 40			ld a, STORE_BLOCK_PHY 
5195 cd 53 0f			call Mult16 
5198			 
5198 e5				push hl         ; address 
5199			 
5199				FORTH_DSP_POP 
5199 cd c4 23			call macro_forth_dsp_pop 
519c				endm 
# End of macro FORTH_DSP_POP
519c			 
519c				FORTH_DSP_VALUEHL 
519c cd 0c 23			call macro_dsp_valuehl 
519f				endm 
# End of macro FORTH_DSP_VALUEHL
519f			 
519f				FORTH_DSP_POP 
519f cd c4 23			call macro_forth_dsp_pop 
51a2				endm 
# End of macro FORTH_DSP_POP
51a2			 
51a2 cd a2 0c			call storage_clear_page 
51a5			 
51a5				; copy string to store page 
51a5			 
51a5 e5				push hl     ; save string address 
51a6			 
51a6 3e 00			ld a, 0 
51a8 cd 39 14			call strlent 
51ab			 
51ab 23				inc hl 
51ac			 
51ac 4d				ld c, l 
51ad 06 00			ld b, 0 
51af			 
51af e1				pop hl 
51b0 11 79 fa			ld de, store_page + 2 
51b3					if DEBUG_FORTH_WORDS 
51b3						DMARK "BW1" 
51b3 f5				push af  
51b4 3a c8 51			ld a, (.dmark)  
51b7 32 68 fe			ld (debug_mark),a  
51ba 3a c9 51			ld a, (.dmark+1)  
51bd 32 69 fe			ld (debug_mark+1),a  
51c0 3a ca 51			ld a, (.dmark+2)  
51c3 32 6a fe			ld (debug_mark+2),a  
51c6 18 03			jr .pastdmark  
51c8 ..			.dmark: db "BW1"  
51cb f1			.pastdmark: pop af  
51cc			endm  
# End of macro DMARK
51cc						CALLMONITOR 
51cc cd 6c fe			call debug_vector  
51cf				endm  
# End of macro CALLMONITOR
51cf					endif 
51cf ed b0			ldir 
51d1			 
51d1			 
51d1				; poke the start of the block with flags to prevent high level file ops hitting the block 
51d1			 
51d1 21 ff ff			ld hl, $ffff 
51d4			 
51d4 22 77 fa			ld (store_page), hl	 
51d7				 
51d7 e1				pop hl    ; get address 
51d8 11 77 fa			ld de, store_page 
51db			 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "BW2" 
51db f5				push af  
51dc 3a f0 51			ld a, (.dmark)  
51df 32 68 fe			ld (debug_mark),a  
51e2 3a f1 51			ld a, (.dmark+1)  
51e5 32 69 fe			ld (debug_mark+1),a  
51e8 3a f2 51			ld a, (.dmark+2)  
51eb 32 6a fe			ld (debug_mark+2),a  
51ee 18 03			jr .pastdmark  
51f0 ..			.dmark: db "BW2"  
51f3 f1			.pastdmark: pop af  
51f4			endm  
# End of macro DMARK
51f4						CALLMONITOR 
51f4 cd 6c fe			call debug_vector  
51f7				endm  
# End of macro CALLMONITOR
51f7					endif 
51f7			 
51f7 cd cb 04			call storage_write_block 
51fa			 
51fa					NEXTW 
51fa c3 c2 24			jp macro_next 
51fd				endm 
# End of macro NEXTW
51fd			 
51fd			.BUPD: 
51fd				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51fd 3a				db WORD_SYS_CORE+38             
51fe 53 52			dw .BYID            
5200 05				db 4 + 1 
5201 .. 00			db "BUPD",0              
5206				endm 
# End of macro CWHEAD
5206			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5206			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5206			; | | or completely different file system structure. 
5206			; | | Compatible with PicoSPINet  
5206			 
5206					if DEBUG_FORTH_WORDS_KEY 
5206						DMARK "BUD" 
5206 f5				push af  
5207 3a 1b 52			ld a, (.dmark)  
520a 32 68 fe			ld (debug_mark),a  
520d 3a 1c 52			ld a, (.dmark+1)  
5210 32 69 fe			ld (debug_mark+1),a  
5213 3a 1d 52			ld a, (.dmark+2)  
5216 32 6a fe			ld (debug_mark+2),a  
5219 18 03			jr .pastdmark  
521b ..			.dmark: db "BUD"  
521e f1			.pastdmark: pop af  
521f			endm  
# End of macro DMARK
521f						CALLMONITOR 
521f cd 6c fe			call debug_vector  
5222				endm  
# End of macro CALLMONITOR
5222					endif 
5222			 
5222				FORTH_DSP_VALUEHL 
5222 cd 0c 23			call macro_dsp_valuehl 
5225				endm 
# End of macro FORTH_DSP_VALUEHL
5225			 
5225				; calc block address 
5225			 
5225 eb				ex de, hl 
5226 3e 40			ld a, STORE_BLOCK_PHY 
5228 cd 53 0f			call Mult16 
522b			 
522b				FORTH_DSP_POP 
522b cd c4 23			call macro_forth_dsp_pop 
522e				endm 
# End of macro FORTH_DSP_POP
522e			 
522e			 
522e 11 77 fa			ld de, store_page 
5231			 
5231					if DEBUG_FORTH_WORDS 
5231						DMARK "BUe" 
5231 f5				push af  
5232 3a 46 52			ld a, (.dmark)  
5235 32 68 fe			ld (debug_mark),a  
5238 3a 47 52			ld a, (.dmark+1)  
523b 32 69 fe			ld (debug_mark+1),a  
523e 3a 48 52			ld a, (.dmark+2)  
5241 32 6a fe			ld (debug_mark+2),a  
5244 18 03			jr .pastdmark  
5246 ..			.dmark: db "BUe"  
5249 f1			.pastdmark: pop af  
524a			endm  
# End of macro DMARK
524a						CALLMONITOR 
524a cd 6c fe			call debug_vector  
524d				endm  
# End of macro CALLMONITOR
524d					endif 
524d			 
524d cd cb 04			call storage_write_block 
5250			 
5250					NEXTW 
5250 c3 c2 24			jp macro_next 
5253				endm 
# End of macro NEXTW
5253			 
5253			.BYID: 
5253			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5253			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5253			; 
5253			;		 
5253			;		if DEBUG_FORTH_WORDS_KEY 
5253			;			DMARK "BYID" 
5253			;			CALLMONITOR 
5253			;		endif 
5253			; 
5253			;		; get direct address 
5253			; 
5253			;		FORTH_DSP_VALUEHL 
5253			; 
5253			;		FORTH_DSP_POP 
5253			; 
5253			;	; calc block address 
5253			; 
5253			;	ex de, hl 
5253			;	ld a, STORE_BLOCK_PHY 
5253			;	call Mult16 
5253			;	;	do BREAD with number as param 
5253			;	; push the file name	 
5253			;	ld de, store_page 
5253			;	call storage_read_block 
5253			 ;       ld hl, store_page+2 
5253			; 
5253			; 
5253			;		NEXTW 
5253			;.BYNAME: 
5253				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5253 3a				db WORD_SYS_CORE+38             
5254 6c 52			dw .DIR            
5256 06				db 5 + 1 
5257 .. 00			db "GETID",0              
525d				endm 
# End of macro CWHEAD
525d			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
525d			; | | Compatible with PicoSPINet  
525d			 
525d					; get pointer to file name to seek 
525d			 
525d					FORTH_DSP_VALUEHL 
525d cd 0c 23			call macro_dsp_valuehl 
5260				endm 
# End of macro FORTH_DSP_VALUEHL
5260			 
5260			 
5260 cd 8d 03				call storage_getid  
5263			 
5263					FORTH_DSP_POP 
5263 cd c4 23			call macro_forth_dsp_pop 
5266				endm 
# End of macro FORTH_DSP_POP
5266			 
5266 cd 15 21				call forth_push_numhl 
5269			 
5269					NEXTW 
5269 c3 c2 24			jp macro_next 
526c				endm 
# End of macro NEXTW
526c			; 
526c			.DIR: 
526c				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
526c 3a				db WORD_SYS_CORE+38             
526d 70 53			dw .SAVE            
526f 04				db 3 + 1 
5270 .. 00			db "DIR",0              
5274				endm 
# End of macro CWHEAD
5274			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5274			; | | Compatible with PicoSPINet  
5274			 
5274					if DEBUG_FORTH_WORDS_KEY 
5274						DMARK "DIR" 
5274 f5				push af  
5275 3a 89 52			ld a, (.dmark)  
5278 32 68 fe			ld (debug_mark),a  
527b 3a 8a 52			ld a, (.dmark+1)  
527e 32 69 fe			ld (debug_mark+1),a  
5281 3a 8b 52			ld a, (.dmark+2)  
5284 32 6a fe			ld (debug_mark+2),a  
5287 18 03			jr .pastdmark  
5289 ..			.dmark: db "DIR"  
528c f1			.pastdmark: pop af  
528d			endm  
# End of macro DMARK
528d						CALLMONITOR 
528d cd 6c fe			call debug_vector  
5290				endm  
# End of macro CALLMONITOR
5290					endif 
5290 cd 17 05			call storage_get_block_0 
5293			 
5293 21 77 fa			ld hl, store_page     ; get current id count 
5296 46				ld b, (hl) 
5297 0e 00			ld c, 0    ; count of files   
5299					if DEBUG_FORTH_WORDS 
5299						DMARK "DI1" 
5299 f5				push af  
529a 3a ae 52			ld a, (.dmark)  
529d 32 68 fe			ld (debug_mark),a  
52a0 3a af 52			ld a, (.dmark+1)  
52a3 32 69 fe			ld (debug_mark+1),a  
52a6 3a b0 52			ld a, (.dmark+2)  
52a9 32 6a fe			ld (debug_mark+2),a  
52ac 18 03			jr .pastdmark  
52ae ..			.dmark: db "DI1"  
52b1 f1			.pastdmark: pop af  
52b2			endm  
# End of macro DMARK
52b2						CALLMONITOR 
52b2 cd 6c fe			call debug_vector  
52b5				endm  
# End of macro CALLMONITOR
52b5					endif 
52b5			 
52b5				; check for empty drive 
52b5			 
52b5 3e 00			ld a, 0 
52b7 b8				cp b 
52b8 ca 26 53			jp z, .dirdone 
52bb			 
52bb				; for each of the current ids do a search for them and if found push to stack 
52bb			 
52bb c5			.diritem:	push bc 
52bc 21 40 00				ld hl, STORE_BLOCK_PHY 
52bf 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
52c1 58					ld e,b 
52c2			 
52c2			;		if DEBUG_FORTH_WORDS 
52c2			;			DMARK "DI2" 
52c2			;			CALLMONITOR 
52c2			;		endif 
52c2			 
52c2 cd 99 07				call storage_findnextid 
52c5			 
52c5			;		if DEBUG_FORTH_WORDS 
52c5			;			DMARK "DI3" 
52c5			;			CALLMONITOR 
52c5			;		endif 
52c5			 
52c5					; if found hl will be non zero 
52c5			 
52c5 cd f9 0f				call ishlzero 
52c8			;		ld a, l 
52c8			;		add h 
52c8			; 
52c8			;		cp 0 
52c8 28 59				jr z, .dirnotfound 
52ca			 
52ca					; increase count 
52ca			 
52ca c1					pop bc	 
52cb 0c					inc c 
52cc c5					push bc 
52cd					 
52cd			 
52cd					; get file header and push the file name 
52cd			 
52cd 11 77 fa				ld de, store_page 
52d0 cd 66 04				call storage_read_block 
52d3			 
52d3					; push file id to stack 
52d3				 
52d3 3a 77 fa				ld a, (store_page) 
52d6 26 00				ld h, 0 
52d8 6f					ld l, a 
52d9 cd 15 21				call forth_push_numhl 
52dc			 
52dc					; push extent count to stack  
52dc				 
52dc 3a 79 fa				ld a, (store_page+2) 
52df 26 00				ld h, 0 
52e1 6f					ld l, a 
52e2 cd 15 21				call forth_push_numhl 
52e5			 
52e5					; push file name 
52e5			 
52e5 21 7a fa				ld hl, store_page+3 
52e8					if DEBUG_FORTH_WORDS 
52e8						DMARK "DI5" 
52e8 f5				push af  
52e9 3a fd 52			ld a, (.dmark)  
52ec 32 68 fe			ld (debug_mark),a  
52ef 3a fe 52			ld a, (.dmark+1)  
52f2 32 69 fe			ld (debug_mark+1),a  
52f5 3a ff 52			ld a, (.dmark+2)  
52f8 32 6a fe			ld (debug_mark+2),a  
52fb 18 03			jr .pastdmark  
52fd ..			.dmark: db "DI5"  
5300 f1			.pastdmark: pop af  
5301			endm  
# End of macro DMARK
5301						CALLMONITOR 
5301 cd 6c fe			call debug_vector  
5304				endm  
# End of macro CALLMONITOR
5304					endif 
5304 cd 83 21				call forth_push_str 
5307					if DEBUG_FORTH_WORDS 
5307						DMARK "DI6" 
5307 f5				push af  
5308 3a 1c 53			ld a, (.dmark)  
530b 32 68 fe			ld (debug_mark),a  
530e 3a 1d 53			ld a, (.dmark+1)  
5311 32 69 fe			ld (debug_mark+1),a  
5314 3a 1e 53			ld a, (.dmark+2)  
5317 32 6a fe			ld (debug_mark+2),a  
531a 18 03			jr .pastdmark  
531c ..			.dmark: db "DI6"  
531f f1			.pastdmark: pop af  
5320			endm  
# End of macro DMARK
5320						CALLMONITOR 
5320 cd 6c fe			call debug_vector  
5323				endm  
# End of macro CALLMONITOR
5323					endif 
5323			.dirnotfound: 
5323 c1					pop bc     
5324 10 95				djnz .diritem 
5326				 
5326			.dirdone:	 
5326					if DEBUG_FORTH_WORDS 
5326						DMARK "DI7" 
5326 f5				push af  
5327 3a 3b 53			ld a, (.dmark)  
532a 32 68 fe			ld (debug_mark),a  
532d 3a 3c 53			ld a, (.dmark+1)  
5330 32 69 fe			ld (debug_mark+1),a  
5333 3a 3d 53			ld a, (.dmark+2)  
5336 32 6a fe			ld (debug_mark+2),a  
5339 18 03			jr .pastdmark  
533b ..			.dmark: db "DI7"  
533e f1			.pastdmark: pop af  
533f			endm  
# End of macro DMARK
533f						CALLMONITOR 
533f cd 6c fe			call debug_vector  
5342				endm  
# End of macro CALLMONITOR
5342					endif 
5342			 
5342					; push a count of the dir items found 
5342			 
5342 26 00				ld h, 0 
5344 69					ld l, c 
5345 cd 15 21				call forth_push_numhl 
5348			 
5348					; push the bank label 
5348			 
5348 cd 17 05				call storage_get_block_0 
534b			 
534b				 
534b 21 7a fa		 		ld hl, store_page+3 
534e			 
534e					if DEBUG_FORTH_WORDS 
534e						DMARK "DI8" 
534e f5				push af  
534f 3a 63 53			ld a, (.dmark)  
5352 32 68 fe			ld (debug_mark),a  
5355 3a 64 53			ld a, (.dmark+1)  
5358 32 69 fe			ld (debug_mark+1),a  
535b 3a 65 53			ld a, (.dmark+2)  
535e 32 6a fe			ld (debug_mark+2),a  
5361 18 03			jr .pastdmark  
5363 ..			.dmark: db "DI8"  
5366 f1			.pastdmark: pop af  
5367			endm  
# End of macro DMARK
5367						CALLMONITOR 
5367 cd 6c fe			call debug_vector  
536a				endm  
# End of macro CALLMONITOR
536a					endif 
536a cd 83 21				call forth_push_str 
536d			 
536d			 
536d				 
536d					NEXTW 
536d c3 c2 24			jp macro_next 
5370				endm 
# End of macro NEXTW
5370			.SAVE: 
5370			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5370			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5370			;		NEXTW 
5370			;.LOAD: 
5370			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5370			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5370			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5370			;; > > The LOAD command can not be used in any user words or compound lines. 
5370			; 
5370			;		; store_openext use it. If zero it is EOF 
5370			; 
5370			;		; read block from current stream id 
5370			;		; if the block does not contain zero term keep reading blocks until zero found 
5370			;		; push the block to stack 
5370			;		; save the block id to stream 
5370			; 
5370			; 
5370			;		FORTH_DSP_VALUEHL 
5370			; 
5370			;;		push hl 
5370			; 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LOA" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			;		FORTH_DSP_POP 
5370			; 
5370			;;		pop hl 
5370			; 
5370			;		ld h, l 
5370			;		ld l, 0 
5370			; 
5370			;		push hl     ; stack holds current file id and extent to work with 
5370			; 
5370			; 
5370			;		ld de, store_page      ; get block zero of file 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LO0" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			;		call storage_read 
5370			; 
5370			;		ld a, (store_page+2)    ; max extents for this file 
5370			;		ld  (store_openmaxext),a   ; get our limit 
5370			; 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LOE" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			; 
5370			;; TODO dont know why max extents are not present 
5370			;;		cp 0 
5370			;;		jp z, .loadeof     ; dont read past eof 
5370			; 
5370			;;		ld a, 1   ; start from the head of the file 
5370			; 
5370			;.loadline:	pop hl 
5370			;		inc hl 
5370			;		ld  a, (store_openmaxext)   ; get our limit 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LOx" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			;		inc a 
5370			;		cp l 
5370			;		jp z, .loadeof 
5370			;		push hl    ; save current extent 
5370			; 
5370			;		ld de, store_page 
5370			; 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LO1" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			;		call storage_read 
5370			; 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LO2" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			;	call ishlzero 
5370			;	ld a, l 
5370			;	add h 
5370			;	cp 0 
5370			;	jr z, .loadeof 
5370			; 
5370			;	; not eof so hl should point to data to exec 
5370			; 
5370			;	; will need to add the FORTH_END_BUFFER flag 
5370			 ; 
5370			;	ld hl, store_page+2 
5370			;	ld bc, 255 
5370			;	ld a, 0 
5370			;	cpir 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LOt" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			;	dec hl 
5370			;	ld a, ' ' 
5370			;	ld (hl), a 
5370			;	inc hl 
5370			;	ld (hl), a 
5370			;	inc hl 
5370			;	ld (hl), a 
5370			;	inc hl 
5370			;	ld a, FORTH_END_BUFFER 
5370			;	ld (hl), a 
5370			; 
5370			;	; TODO handle more than a single block read 
5370			; 
5370			; 
5370			;	ld hl, store_page+2 
5370			; 
5370			;	ld (os_tok_ptr), hl 
5370			; 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LO3" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			; 
5370			;	call forthparse 
5370			;	call forthexec 
5370			;	call forthexec_cleanup 
5370			; 
5370			;	; go to next extent 
5370			; 
5370			;	; get next block  or mark as eof 
5370			;	jp .loadline 
5370			; 
5370			; 
5370			; 
5370			;	       NEXTW 
5370			;.loadeof:	ld a, 0 
5370			;		ld (store_openext), a 
5370			; 
5370			;	if DEBUG_STORESE 
5370			;		DMARK "LOF" 
5370			;		CALLMONITOR 
5370			;	endif 
5370			;		ret 
5370			;		;NEXTW 
5370			;.BSAVE:   
5370			; 
5370			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5370			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5370			;		NEXTW 
5370			;.BLOAD: 
5370			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5370			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5370			;		NEXTW 
5370			;;;; counter gap 
5370			 
5370			 
5370			.SEO: 
5370				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5370 64				db WORD_SYS_CORE+80             
5371 8f 53			dw .SEI            
5373 04				db 3 + 1 
5374 .. 00			db "SEO",0              
5378				endm 
# End of macro CWHEAD
5378			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5378			 
5378					; get port 
5378			 
5378					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5378 cd 0c 23			call macro_dsp_valuehl 
537b				endm 
# End of macro FORTH_DSP_VALUEHL
537b			 
537b e5					push hl    ; u2 - byte 
537c			 
537c					; destroy value TOS 
537c			 
537c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
537c cd c4 23			call macro_forth_dsp_pop 
537f				endm 
# End of macro FORTH_DSP_POP
537f			 
537f					; get byte to send 
537f			 
537f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
537f cd 0c 23			call macro_dsp_valuehl 
5382				endm 
# End of macro FORTH_DSP_VALUEHL
5382			 
5382 e5					push hl    ; u1 - addr 
5383			 
5383					; destroy value TOS 
5383			 
5383					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5383 cd c4 23			call macro_forth_dsp_pop 
5386				endm 
# End of macro FORTH_DSP_POP
5386			 
5386					; one value on hl get other one back 
5386			 
5386 d1					pop de   ; u1 - byte 
5387			 
5387 e1					pop hl   ; u2 - addr 
5388			 
5388					; TODO Send SPI byte 
5388			 
5388			 
5388 7b					ld a, e 
5389 cd 6b 02				call se_writebyte 
538c			 
538c					 
538c			 
538c					NEXTW 
538c c3 c2 24			jp macro_next 
538f				endm 
# End of macro NEXTW
538f			 
538f			.SEI: 
538f				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
538f 65				db WORD_SYS_CORE+81             
5390 a9 53			dw .SFREE            
5392 04				db 3 + 1 
5393 .. 00			db "SEI",0              
5397				endm 
# End of macro CWHEAD
5397			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5397			 
5397					; get port 
5397			 
5397					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5397 cd 0c 23			call macro_dsp_valuehl 
539a				endm 
# End of macro FORTH_DSP_VALUEHL
539a			 
539a			;		push hl 
539a			 
539a					; destroy value TOS 
539a			 
539a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
539a cd c4 23			call macro_forth_dsp_pop 
539d				endm 
# End of macro FORTH_DSP_POP
539d			 
539d					; one value on hl get other one back 
539d			 
539d			;		pop hl 
539d			 
539d			 
539d					; TODO Get SPI byte 
539d			 
539d cd 0d 03				call se_readbyte 
53a0			 
53a0 26 00				ld h, 0 
53a2 6f					ld l, a 
53a3 cd 15 21				call forth_push_numhl 
53a6			 
53a6					NEXTW 
53a6 c3 c2 24			jp macro_next 
53a9				endm 
# End of macro NEXTW
53a9			 
53a9			.SFREE: 
53a9				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
53a9 67				db WORD_SYS_CORE+83             
53aa d8 53			dw .SIZE            
53ac 06				db 5 + 1 
53ad .. 00			db "FFREE",0              
53b3				endm 
# End of macro CWHEAD
53b3			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
53b3			; | | Compatible with PicoSPINet  
53b3					if DEBUG_FORTH_WORDS_KEY 
53b3						DMARK "FFR" 
53b3 f5				push af  
53b4 3a c8 53			ld a, (.dmark)  
53b7 32 68 fe			ld (debug_mark),a  
53ba 3a c9 53			ld a, (.dmark+1)  
53bd 32 69 fe			ld (debug_mark+1),a  
53c0 3a ca 53			ld a, (.dmark+2)  
53c3 32 6a fe			ld (debug_mark+2),a  
53c6 18 03			jr .pastdmark  
53c8 ..			.dmark: db "FFR"  
53cb f1			.pastdmark: pop af  
53cc			endm  
# End of macro DMARK
53cc						CALLMONITOR 
53cc cd 6c fe			call debug_vector  
53cf				endm  
# End of macro CALLMONITOR
53cf					endif 
53cf			 
53cf cd 33 08				call storage_freeblocks 
53d2			 
53d2 cd 15 21				call forth_push_numhl 
53d5			 
53d5				       NEXTW 
53d5 c3 c2 24			jp macro_next 
53d8				endm 
# End of macro NEXTW
53d8			.SIZE: 
53d8				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
53d8 67				db WORD_SYS_CORE+83             
53d9 0c 54			dw .CREATE            
53db 05				db 4 + 1 
53dc .. 00			db "SIZE",0              
53e1				endm 
# End of macro CWHEAD
53e1			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
53e1			; | | Compatible with PicoSPINet  
53e1					if DEBUG_FORTH_WORDS_KEY 
53e1						DMARK "SIZ" 
53e1 f5				push af  
53e2 3a f6 53			ld a, (.dmark)  
53e5 32 68 fe			ld (debug_mark),a  
53e8 3a f7 53			ld a, (.dmark+1)  
53eb 32 69 fe			ld (debug_mark+1),a  
53ee 3a f8 53			ld a, (.dmark+2)  
53f1 32 6a fe			ld (debug_mark+2),a  
53f4 18 03			jr .pastdmark  
53f6 ..			.dmark: db "SIZ"  
53f9 f1			.pastdmark: pop af  
53fa			endm  
# End of macro DMARK
53fa						CALLMONITOR 
53fa cd 6c fe			call debug_vector  
53fd				endm  
# End of macro CALLMONITOR
53fd					endif 
53fd			 
53fd					FORTH_DSP_VALUEHL 
53fd cd 0c 23			call macro_dsp_valuehl 
5400				endm 
# End of macro FORTH_DSP_VALUEHL
5400			;		push hl 
5400					FORTH_DSP_POP 
5400 cd c4 23			call macro_forth_dsp_pop 
5403				endm 
# End of macro FORTH_DSP_POP
5403			;		pop hl 
5403 cd 95 04				call storage_file_size 
5406			 
5406 cd 15 21				call forth_push_numhl 
5409			  
5409			 
5409				       NEXTW 
5409 c3 c2 24			jp macro_next 
540c				endm 
# End of macro NEXTW
540c			 
540c			.CREATE: 
540c				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
540c 68				db WORD_SYS_CORE+84             
540d 7a 54			dw .APPEND            
540f 07				db 6 + 1 
5410 .. 00			db "CREATE",0              
5417				endm 
# End of macro CWHEAD
5417			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5417			; | | e.g.  
5417			; | | TestProgram CREATE 
5417			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5417			; | |  
5417			; | | Max file IDs are 255. 
5417			; | |  
5417			; | | Compatible with PicoSPINet  
5417					 
5417					if DEBUG_FORTH_WORDS_KEY 
5417						DMARK "CRT" 
5417 f5				push af  
5418 3a 2c 54			ld a, (.dmark)  
541b 32 68 fe			ld (debug_mark),a  
541e 3a 2d 54			ld a, (.dmark+1)  
5421 32 69 fe			ld (debug_mark+1),a  
5424 3a 2e 54			ld a, (.dmark+2)  
5427 32 6a fe			ld (debug_mark+2),a  
542a 18 03			jr .pastdmark  
542c ..			.dmark: db "CRT"  
542f f1			.pastdmark: pop af  
5430			endm  
# End of macro DMARK
5430						CALLMONITOR 
5430 cd 6c fe			call debug_vector  
5433				endm  
# End of macro CALLMONITOR
5433					endif 
5433			;		call storage_get_block_0 
5433			 
5433					; TODO pop hl 
5433			 
5433					;v5 FORTH_DSP_VALUE 
5433					FORTH_DSP_VALUE 
5433 cd f5 22			call macro_forth_dsp_value 
5436				endm 
# End of macro FORTH_DSP_VALUE
5436			 
5436				if DEBUG_STORESE 
5436					DMARK "CR1" 
5436 f5				push af  
5437 3a 4b 54			ld a, (.dmark)  
543a 32 68 fe			ld (debug_mark),a  
543d 3a 4c 54			ld a, (.dmark+1)  
5440 32 69 fe			ld (debug_mark+1),a  
5443 3a 4d 54			ld a, (.dmark+2)  
5446 32 6a fe			ld (debug_mark+2),a  
5449 18 03			jr .pastdmark  
544b ..			.dmark: db "CR1"  
544e f1			.pastdmark: pop af  
544f			endm  
# End of macro DMARK
544f					CALLMONITOR 
544f cd 6c fe			call debug_vector  
5452				endm  
# End of macro CALLMONITOR
5452				endif 
5452			;		push hl 
5452			;		FORTH_DSP_POP 
5452			;		pop hl 
5452			 
5452			;		inc hl   ; move past the type marker 
5452			 
5452 cd 69 08				call storage_create 
5455			 
5455				if DEBUG_STORESE 
5455					DMARK "CT1" 
5455 f5				push af  
5456 3a 6a 54			ld a, (.dmark)  
5459 32 68 fe			ld (debug_mark),a  
545c 3a 6b 54			ld a, (.dmark+1)  
545f 32 69 fe			ld (debug_mark+1),a  
5462 3a 6c 54			ld a, (.dmark+2)  
5465 32 6a fe			ld (debug_mark+2),a  
5468 18 03			jr .pastdmark  
546a ..			.dmark: db "CT1"  
546d f1			.pastdmark: pop af  
546e			endm  
# End of macro DMARK
546e					CALLMONITOR 
546e cd 6c fe			call debug_vector  
5471				endm  
# End of macro CALLMONITOR
5471				endif 
5471			;		push hl 
5471					FORTH_DSP_POP 
5471 cd c4 23			call macro_forth_dsp_pop 
5474				endm 
# End of macro FORTH_DSP_POP
5474			;		pop hl 
5474					; push file id to stack 
5474 cd 15 21				call forth_push_numhl 
5477			 
5477			 
5477			 
5477				       NEXTW 
5477 c3 c2 24			jp macro_next 
547a				endm 
# End of macro NEXTW
547a			 
547a			.APPEND: 
547a				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
547a 69				db WORD_SYS_CORE+85             
547b 0b 55			dw .SDEL            
547d 07				db 6 + 1 
547e .. 00			db "APPEND",0              
5485				endm 
# End of macro CWHEAD
5485			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5485			; | | e.g. 
5485			; | | Test CREATE      -> $01 
5485			; | | "A string to add to file" $01 APPEND 
5485			; | |  
5485			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5485			; | | Compatible with PicoSPINet  
5485					if DEBUG_FORTH_WORDS_KEY 
5485						DMARK "APP" 
5485 f5				push af  
5486 3a 9a 54			ld a, (.dmark)  
5489 32 68 fe			ld (debug_mark),a  
548c 3a 9b 54			ld a, (.dmark+1)  
548f 32 69 fe			ld (debug_mark+1),a  
5492 3a 9c 54			ld a, (.dmark+2)  
5495 32 6a fe			ld (debug_mark+2),a  
5498 18 03			jr .pastdmark  
549a ..			.dmark: db "APP"  
549d f1			.pastdmark: pop af  
549e			endm  
# End of macro DMARK
549e						CALLMONITOR 
549e cd 6c fe			call debug_vector  
54a1				endm  
# End of macro CALLMONITOR
54a1					endif 
54a1			 
54a1					FORTH_DSP_VALUEHL 
54a1 cd 0c 23			call macro_dsp_valuehl 
54a4				endm 
# End of macro FORTH_DSP_VALUEHL
54a4 e5					push hl 	; save file id 
54a5			 
54a5				if DEBUG_STORESE 
54a5					DMARK "AP1" 
54a5 f5				push af  
54a6 3a ba 54			ld a, (.dmark)  
54a9 32 68 fe			ld (debug_mark),a  
54ac 3a bb 54			ld a, (.dmark+1)  
54af 32 69 fe			ld (debug_mark+1),a  
54b2 3a bc 54			ld a, (.dmark+2)  
54b5 32 6a fe			ld (debug_mark+2),a  
54b8 18 03			jr .pastdmark  
54ba ..			.dmark: db "AP1"  
54bd f1			.pastdmark: pop af  
54be			endm  
# End of macro DMARK
54be					CALLMONITOR 
54be cd 6c fe			call debug_vector  
54c1				endm  
# End of macro CALLMONITOR
54c1				endif 
54c1					FORTH_DSP_POP 
54c1 cd c4 23			call macro_forth_dsp_pop 
54c4				endm 
# End of macro FORTH_DSP_POP
54c4			 
54c4					FORTH_DSP_VALUEHL 
54c4 cd 0c 23			call macro_dsp_valuehl 
54c7				endm 
# End of macro FORTH_DSP_VALUEHL
54c7					;v5 FORTH_DSP_VALUE 
54c7 e5					push hl 	; save ptr to string to save 
54c8			 
54c8				if DEBUG_STORESE 
54c8					DMARK "AP1" 
54c8 f5				push af  
54c9 3a dd 54			ld a, (.dmark)  
54cc 32 68 fe			ld (debug_mark),a  
54cf 3a de 54			ld a, (.dmark+1)  
54d2 32 69 fe			ld (debug_mark+1),a  
54d5 3a df 54			ld a, (.dmark+2)  
54d8 32 6a fe			ld (debug_mark+2),a  
54db 18 03			jr .pastdmark  
54dd ..			.dmark: db "AP1"  
54e0 f1			.pastdmark: pop af  
54e1			endm  
# End of macro DMARK
54e1					CALLMONITOR 
54e1 cd 6c fe			call debug_vector  
54e4				endm  
# End of macro CALLMONITOR
54e4				endif 
54e4					FORTH_DSP_POP 
54e4 cd c4 23			call macro_forth_dsp_pop 
54e7				endm 
# End of macro FORTH_DSP_POP
54e7			 
54e7 d1					pop de 
54e8 e1					pop hl 
54e9				if DEBUG_STORESE 
54e9					DMARK "AP2" 
54e9 f5				push af  
54ea 3a fe 54			ld a, (.dmark)  
54ed 32 68 fe			ld (debug_mark),a  
54f0 3a ff 54			ld a, (.dmark+1)  
54f3 32 69 fe			ld (debug_mark+1),a  
54f6 3a 00 55			ld a, (.dmark+2)  
54f9 32 6a fe			ld (debug_mark+2),a  
54fc 18 03			jr .pastdmark  
54fe ..			.dmark: db "AP2"  
5501 f1			.pastdmark: pop af  
5502			endm  
# End of macro DMARK
5502					CALLMONITOR 
5502 cd 6c fe			call debug_vector  
5505				endm  
# End of macro CALLMONITOR
5505				endif 
5505					;inc de ; skip var type indicator 
5505			 
5505					; TODO how to append numerics???? 
5505			 
5505 cd 56 0b				call storage_append		 
5508			 
5508				       NEXTW 
5508 c3 c2 24			jp macro_next 
550b				endm 
# End of macro NEXTW
550b			.SDEL: 
550b				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
550b 6a				db WORD_SYS_CORE+86             
550c 57 55			dw .OPEN            
550e 05				db 4 + 1 
550f .. 00			db "ERA",0              
5513				endm 
# End of macro CWHEAD
5513			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5513			; | | Compatible with PicoSPINet  
5513					FORTH_DSP_VALUEHL 
5513 cd 0c 23			call macro_dsp_valuehl 
5516				endm 
# End of macro FORTH_DSP_VALUEHL
5516			;		push hl 	; save file id 
5516			 
5516					if DEBUG_FORTH_WORDS_KEY 
5516						DMARK "ERA" 
5516 f5				push af  
5517 3a 2b 55			ld a, (.dmark)  
551a 32 68 fe			ld (debug_mark),a  
551d 3a 2c 55			ld a, (.dmark+1)  
5520 32 69 fe			ld (debug_mark+1),a  
5523 3a 2d 55			ld a, (.dmark+2)  
5526 32 6a fe			ld (debug_mark+2),a  
5529 18 03			jr .pastdmark  
552b ..			.dmark: db "ERA"  
552e f1			.pastdmark: pop af  
552f			endm  
# End of macro DMARK
552f						CALLMONITOR 
552f cd 6c fe			call debug_vector  
5532				endm  
# End of macro CALLMONITOR
5532					endif 
5532				if DEBUG_STORESE 
5532					DMARK "ER1" 
5532 f5				push af  
5533 3a 47 55			ld a, (.dmark)  
5536 32 68 fe			ld (debug_mark),a  
5539 3a 48 55			ld a, (.dmark+1)  
553c 32 69 fe			ld (debug_mark+1),a  
553f 3a 49 55			ld a, (.dmark+2)  
5542 32 6a fe			ld (debug_mark+2),a  
5545 18 03			jr .pastdmark  
5547 ..			.dmark: db "ER1"  
554a f1			.pastdmark: pop af  
554b			endm  
# End of macro DMARK
554b					CALLMONITOR 
554b cd 6c fe			call debug_vector  
554e				endm  
# End of macro CALLMONITOR
554e				endif 
554e					FORTH_DSP_POP 
554e cd c4 23			call macro_forth_dsp_pop 
5551				endm 
# End of macro FORTH_DSP_POP
5551			 
5551			;		pop hl 
5551			 
5551 cd a8 06				call storage_erase 
5554				       NEXTW 
5554 c3 c2 24			jp macro_next 
5557				endm 
# End of macro NEXTW
5557			 
5557			.OPEN: 
5557				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5557 6b				db WORD_SYS_CORE+87             
5558 eb 55			dw .READ            
555a 05				db 4 + 1 
555b .. 00			db "OPEN",0              
5560				endm 
# End of macro CWHEAD
5560			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5560			; | | e.g. 
5560			; | | $01 OPEN $01 DO $01 READ . LOOP 
5560			; | | 
5560			; | | Will return with 255 blocks if the file does not exist 
5560			; | | Compatible with PicoSPINet  
5560			 
5560					if DEBUG_FORTH_WORDS_KEY 
5560						DMARK "OPN" 
5560 f5				push af  
5561 3a 75 55			ld a, (.dmark)  
5564 32 68 fe			ld (debug_mark),a  
5567 3a 76 55			ld a, (.dmark+1)  
556a 32 69 fe			ld (debug_mark+1),a  
556d 3a 77 55			ld a, (.dmark+2)  
5570 32 6a fe			ld (debug_mark+2),a  
5573 18 03			jr .pastdmark  
5575 ..			.dmark: db "OPN"  
5578 f1			.pastdmark: pop af  
5579			endm  
# End of macro DMARK
5579						CALLMONITOR 
5579 cd 6c fe			call debug_vector  
557c				endm  
# End of macro CALLMONITOR
557c					endif 
557c					; TODO handle multiple file opens 
557c			 
557c 3e 01			       	ld a, 1 
557e 32 67 fa				ld (store_openext), a 
5581			 
5581					; get max extents for this file 
5581				 
5581								 
5581					FORTH_DSP_VALUEHL 
5581 cd 0c 23			call macro_dsp_valuehl 
5584				endm 
# End of macro FORTH_DSP_VALUEHL
5584			 
5584 65					ld h, l 
5585 2e 00				ld l, 0 
5587			 
5587					; store file id 
5587			 
5587 7c					ld a, h 
5588 32 64 fa				ld (store_filecache), a 
558b			 
558b				if DEBUG_STORESE 
558b					DMARK "OPN" 
558b f5				push af  
558c 3a a0 55			ld a, (.dmark)  
558f 32 68 fe			ld (debug_mark),a  
5592 3a a1 55			ld a, (.dmark+1)  
5595 32 69 fe			ld (debug_mark+1),a  
5598 3a a2 55			ld a, (.dmark+2)  
559b 32 6a fe			ld (debug_mark+2),a  
559e 18 03			jr .pastdmark  
55a0 ..			.dmark: db "OPN"  
55a3 f1			.pastdmark: pop af  
55a4			endm  
# End of macro DMARK
55a4					CALLMONITOR 
55a4 cd 6c fe			call debug_vector  
55a7				endm  
# End of macro CALLMONITOR
55a7				endif 
55a7			;		push hl 
55a7					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
55a7 cd c4 23			call macro_forth_dsp_pop 
55aa				endm 
# End of macro FORTH_DSP_POP
55aa			;		pop hl 
55aa						 
55aa 11 77 fa				ld de, store_page      ; get block zero of file 
55ad cd bf 09				call storage_read 
55b0 cd f9 0f			call ishlzero 
55b3 20 04			jr nz, .opfound 
55b5			 
55b5				; file does not exist so indicate with 255 extents in use 
55b5			 
55b5 3e ff			ld a, 255 
55b7 18 29			jr .skipopeneof 
55b9			 
55b9			 
55b9			.opfound: 
55b9			 
55b9			 
55b9 3a 79 fa				ld a, (store_page+2)    ; max extents for this file 
55bc 32 66 fa				ld  (store_openmaxext), a   ; get our limit and push 
55bf					 
55bf				if DEBUG_STORESE 
55bf					DMARK "OPx" 
55bf f5				push af  
55c0 3a d4 55			ld a, (.dmark)  
55c3 32 68 fe			ld (debug_mark),a  
55c6 3a d5 55			ld a, (.dmark+1)  
55c9 32 69 fe			ld (debug_mark+1),a  
55cc 3a d6 55			ld a, (.dmark+2)  
55cf 32 6a fe			ld (debug_mark+2),a  
55d2 18 03			jr .pastdmark  
55d4 ..			.dmark: db "OPx"  
55d7 f1			.pastdmark: pop af  
55d8			endm  
# End of macro DMARK
55d8					CALLMONITOR 
55d8 cd 6c fe			call debug_vector  
55db				endm  
# End of macro CALLMONITOR
55db				endif 
55db fe 00				cp 0 
55dd 20 03				jr nz, .skipopeneof 
55df					; have opened an empty file 
55df					 
55df 32 67 fa				ld (store_openext), a 
55e2			 
55e2			.skipopeneof: 
55e2			 
55e2 6f					ld l, a 
55e3 26 00				ld h, 0 
55e5 cd 15 21				call forth_push_numhl 
55e8			 
55e8			 
55e8				       NEXTW 
55e8 c3 c2 24			jp macro_next 
55eb				endm 
# End of macro NEXTW
55eb			.READ: 
55eb				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
55eb 6c				db WORD_SYS_CORE+88             
55ec 15 57			dw .EOF            
55ee 05				db 4 + 1 
55ef .. 00			db "READ",0              
55f4				endm 
# End of macro CWHEAD
55f4			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
55f4			; | | e.g. 
55f4			; | | $01 OPEN $01 DO READ . LOOP 
55f4			; | | 
55f4			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
55f4			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
55f4			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
55f4			; | | two bytes contain the file id and extent. 
55f4			; | |  
55f4			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
55f4			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
55f4			; | | Compatible with PicoSPINet  
55f4			 
55f4					if DEBUG_FORTH_WORDS_KEY 
55f4						DMARK "REA" 
55f4 f5				push af  
55f5 3a 09 56			ld a, (.dmark)  
55f8 32 68 fe			ld (debug_mark),a  
55fb 3a 0a 56			ld a, (.dmark+1)  
55fe 32 69 fe			ld (debug_mark+1),a  
5601 3a 0b 56			ld a, (.dmark+2)  
5604 32 6a fe			ld (debug_mark+2),a  
5607 18 03			jr .pastdmark  
5609 ..			.dmark: db "REA"  
560c f1			.pastdmark: pop af  
560d			endm  
# End of macro DMARK
560d						CALLMONITOR 
560d cd 6c fe			call debug_vector  
5610				endm  
# End of macro CALLMONITOR
5610					endif 
5610					; store_openext use it. If zero it is EOF 
5610			 
5610					; read block from current stream id 
5610					; if the block does not contain zero term keep reading blocks until zero found 
5610					; push the block to stack 
5610					; save the block id to stream 
5610			 
5610			 
5610 cd 42 57				call .testeof 
5613 3e 01				ld a, 1 
5615 bd					cp l 
5616 ca f1 56				jp z, .ateof 
5619			 
5619			 
5619			;		FORTH_DSP_VALUEHL 
5619			 
5619			;		push hl 
5619			 
5619			;	if DEBUG_STORESE 
5619			;		DMARK "REA" 
5619			;		CALLMONITOR 
5619			;	endif 
5619			;		FORTH_DSP_POP 
5619			 
5619			;		pop hl 
5619				 
5619 3a 64 fa				ld a, (store_filecache) 
561c 67					ld h,a 
561d			 
561d 3a 67 fa				ld a, (store_openext) 
5620 6f					ld l, a 
5621					 
5621 fe 00				cp 0 
5623 ca f1 56				jp z, .ateof     ; dont read past eof 
5626			 
5626 cd a2 0c				call storage_clear_page 
5629			 
5629 11 77 fa				ld de, store_page 
562c				if DEBUG_STORESE 
562c					DMARK "RE1" 
562c f5				push af  
562d 3a 41 56			ld a, (.dmark)  
5630 32 68 fe			ld (debug_mark),a  
5633 3a 42 56			ld a, (.dmark+1)  
5636 32 69 fe			ld (debug_mark+1),a  
5639 3a 43 56			ld a, (.dmark+2)  
563c 32 6a fe			ld (debug_mark+2),a  
563f 18 03			jr .pastdmark  
5641 ..			.dmark: db "RE1"  
5644 f1			.pastdmark: pop af  
5645			endm  
# End of macro DMARK
5645					CALLMONITOR 
5645 cd 6c fe			call debug_vector  
5648				endm  
# End of macro CALLMONITOR
5648				endif 
5648 cd bf 09				call storage_read 
564b			 
564b				if DEBUG_STORESE 
564b					DMARK "RE2" 
564b f5				push af  
564c 3a 60 56			ld a, (.dmark)  
564f 32 68 fe			ld (debug_mark),a  
5652 3a 61 56			ld a, (.dmark+1)  
5655 32 69 fe			ld (debug_mark+1),a  
5658 3a 62 56			ld a, (.dmark+2)  
565b 32 6a fe			ld (debug_mark+2),a  
565e 18 03			jr .pastdmark  
5660 ..			.dmark: db "RE2"  
5663 f1			.pastdmark: pop af  
5664			endm  
# End of macro DMARK
5664					CALLMONITOR 
5664 cd 6c fe			call debug_vector  
5667				endm  
# End of macro CALLMONITOR
5667				endif 
5667 cd f9 0f			call ishlzero 
566a			;	ld a, l 
566a			;	add h 
566a			;	cp 0 
566a ca f1 56			jp z, .readeof 
566d			 
566d				; not eof so hl should point to data to push to stack 
566d			 
566d				if DEBUG_STORESE 
566d					DMARK "RE3" 
566d f5				push af  
566e 3a 82 56			ld a, (.dmark)  
5671 32 68 fe			ld (debug_mark),a  
5674 3a 83 56			ld a, (.dmark+1)  
5677 32 69 fe			ld (debug_mark+1),a  
567a 3a 84 56			ld a, (.dmark+2)  
567d 32 6a fe			ld (debug_mark+2),a  
5680 18 03			jr .pastdmark  
5682 ..			.dmark: db "RE3"  
5685 f1			.pastdmark: pop af  
5686			endm  
# End of macro DMARK
5686					CALLMONITOR 
5686 cd 6c fe			call debug_vector  
5689				endm  
# End of macro CALLMONITOR
5689				endif 
5689 cd 83 21			call forth_push_str 
568c			 
568c				if DEBUG_STORESE 
568c					DMARK "RE4" 
568c f5				push af  
568d 3a a1 56			ld a, (.dmark)  
5690 32 68 fe			ld (debug_mark),a  
5693 3a a2 56			ld a, (.dmark+1)  
5696 32 69 fe			ld (debug_mark+1),a  
5699 3a a3 56			ld a, (.dmark+2)  
569c 32 6a fe			ld (debug_mark+2),a  
569f 18 03			jr .pastdmark  
56a1 ..			.dmark: db "RE4"  
56a4 f1			.pastdmark: pop af  
56a5			endm  
# End of macro DMARK
56a5					CALLMONITOR 
56a5 cd 6c fe			call debug_vector  
56a8				endm  
# End of macro CALLMONITOR
56a8				endif 
56a8				; get next block  or mark as eof 
56a8			 
56a8 3a 66 fa			ld a, (store_openmaxext)   ; get our limit 
56ab 4f				ld c, a	 
56ac 3a 67 fa			ld a, (store_openext) 
56af			 
56af				if DEBUG_STORESE 
56af					DMARK "RE5" 
56af f5				push af  
56b0 3a c4 56			ld a, (.dmark)  
56b3 32 68 fe			ld (debug_mark),a  
56b6 3a c5 56			ld a, (.dmark+1)  
56b9 32 69 fe			ld (debug_mark+1),a  
56bc 3a c6 56			ld a, (.dmark+2)  
56bf 32 6a fe			ld (debug_mark+2),a  
56c2 18 03			jr .pastdmark  
56c4 ..			.dmark: db "RE5"  
56c7 f1			.pastdmark: pop af  
56c8			endm  
# End of macro DMARK
56c8					CALLMONITOR 
56c8 cd 6c fe			call debug_vector  
56cb				endm  
# End of macro CALLMONITOR
56cb				endif 
56cb b9				cp c 
56cc 28 23			jr z, .readeof     ; at last extent 
56ce			 
56ce 3c					inc a 
56cf 32 67 fa				ld (store_openext), a 
56d2			 
56d2				if DEBUG_STORESE 
56d2					DMARK "RE6" 
56d2 f5				push af  
56d3 3a e7 56			ld a, (.dmark)  
56d6 32 68 fe			ld (debug_mark),a  
56d9 3a e8 56			ld a, (.dmark+1)  
56dc 32 69 fe			ld (debug_mark+1),a  
56df 3a e9 56			ld a, (.dmark+2)  
56e2 32 6a fe			ld (debug_mark+2),a  
56e5 18 03			jr .pastdmark  
56e7 ..			.dmark: db "RE6"  
56ea f1			.pastdmark: pop af  
56eb			endm  
# End of macro DMARK
56eb					CALLMONITOR 
56eb cd 6c fe			call debug_vector  
56ee				endm  
# End of macro CALLMONITOR
56ee				endif 
56ee			 
56ee			 
56ee				       NEXTW 
56ee c3 c2 24			jp macro_next 
56f1				endm 
# End of macro NEXTW
56f1			.ateof: 
56f1				;	ld hl, .showeof 
56f1				;	call forth_push_str 
56f1 3e 00		.readeof:	ld a, 0 
56f3 32 67 fa				ld (store_openext), a 
56f6			 
56f6					 
56f6				if DEBUG_STORESE 
56f6					DMARK "REF" 
56f6 f5				push af  
56f7 3a 0b 57			ld a, (.dmark)  
56fa 32 68 fe			ld (debug_mark),a  
56fd 3a 0c 57			ld a, (.dmark+1)  
5700 32 69 fe			ld (debug_mark+1),a  
5703 3a 0d 57			ld a, (.dmark+2)  
5706 32 6a fe			ld (debug_mark+2),a  
5709 18 03			jr .pastdmark  
570b ..			.dmark: db "REF"  
570e f1			.pastdmark: pop af  
570f			endm  
# End of macro DMARK
570f					CALLMONITOR 
570f cd 6c fe			call debug_vector  
5712				endm  
# End of macro CALLMONITOR
5712				endif 
5712				       NEXTW 
5712 c3 c2 24			jp macro_next 
5715				endm 
# End of macro NEXTW
5715			 
5715			;.showeof:   db "eof", 0 
5715			 
5715			 
5715			.EOF: 
5715				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5715 6d				db WORD_SYS_CORE+89             
5716 57 57			dw .FORMAT            
5718 04				db 3 + 1 
5719 .. 00			db "EOF",0              
571d				endm 
# End of macro CWHEAD
571d			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
571d			; | | e.g. 
571d			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
571d			; | | Compatible with PicoSPINet  
571d					; TODO if current block id for stream is zero then push true else false 
571d			 
571d					if DEBUG_FORTH_WORDS_KEY 
571d						DMARK "EOF" 
571d f5				push af  
571e 3a 32 57			ld a, (.dmark)  
5721 32 68 fe			ld (debug_mark),a  
5724 3a 33 57			ld a, (.dmark+1)  
5727 32 69 fe			ld (debug_mark+1),a  
572a 3a 34 57			ld a, (.dmark+2)  
572d 32 6a fe			ld (debug_mark+2),a  
5730 18 03			jr .pastdmark  
5732 ..			.dmark: db "EOF"  
5735 f1			.pastdmark: pop af  
5736			endm  
# End of macro DMARK
5736						CALLMONITOR 
5736 cd 6c fe			call debug_vector  
5739				endm  
# End of macro CALLMONITOR
5739					endif 
5739			 
5739					; TODO handlue multiple file streams 
5739			 
5739			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5739 cd 42 57				call .testeof 
573c cd 15 21				call forth_push_numhl 
573f			 
573f			 
573f				       NEXTW 
573f c3 c2 24			jp macro_next 
5742				endm 
# End of macro NEXTW
5742			 
5742			.testeof: 
5742 2e 01				ld l, 1 
5744 3a 66 fa				ld a, (store_openmaxext) 
5747 fe 00				cp 0 
5749 28 09				jr  z, .eofdone   ; empty file 
574b 3a 67 fa				ld a, (store_openext) 
574e fe 00				cp 0 
5750 28 02				jr  z, .eofdone 
5752 2e 00				ld l, 0 
5754 26 00		.eofdone:	ld h, 0 
5756 c9					ret 
5757			 
5757			 
5757			 
5757			 
5757			.FORMAT: 
5757				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5757 6d				db WORD_SYS_CORE+89             
5758 a8 57			dw .LABEL            
575a 07				db 6 + 1 
575b .. 00			db "FORMAT",0              
5762				endm 
# End of macro CWHEAD
5762			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5762			; | | Compatible with PicoSPINet  
5762					; TODO if current block id for stream is zero then push true else false 
5762				 
5762				if DEBUG_STORESE 
5762					DMARK "FOR" 
5762 f5				push af  
5763 3a 77 57			ld a, (.dmark)  
5766 32 68 fe			ld (debug_mark),a  
5769 3a 78 57			ld a, (.dmark+1)  
576c 32 69 fe			ld (debug_mark+1),a  
576f 3a 79 57			ld a, (.dmark+2)  
5772 32 6a fe			ld (debug_mark+2),a  
5775 18 03			jr .pastdmark  
5777 ..			.dmark: db "FOR"  
577a f1			.pastdmark: pop af  
577b			endm  
# End of macro DMARK
577b					CALLMONITOR 
577b cd 6c fe			call debug_vector  
577e				endm  
# End of macro CALLMONITOR
577e				endif 
577e					; Wipes the bank check flags to cause a reformat on next block 0 read 
577e			 
577e 21 01 00				ld hl, 1 
5781 3e 00				ld a, 0 
5783 cd 6b 02				call se_writebyte 
5786			 
5786				if DEBUG_STORESE 
5786					DMARK "FO0" 
5786 f5				push af  
5787 3a 9b 57			ld a, (.dmark)  
578a 32 68 fe			ld (debug_mark),a  
578d 3a 9c 57			ld a, (.dmark+1)  
5790 32 69 fe			ld (debug_mark+1),a  
5793 3a 9d 57			ld a, (.dmark+2)  
5796 32 6a fe			ld (debug_mark+2),a  
5799 18 03			jr .pastdmark  
579b ..			.dmark: db "FO0"  
579e f1			.pastdmark: pop af  
579f			endm  
# End of macro DMARK
579f					CALLMONITOR 
579f cd 6c fe			call debug_vector  
57a2				endm  
# End of macro CALLMONITOR
57a2				endif 
57a2					; force bank init 
57a2			 
57a2 cd 17 05				call storage_get_block_0 
57a5					 
57a5				       NEXTW 
57a5 c3 c2 24			jp macro_next 
57a8				endm 
# End of macro NEXTW
57a8			.LABEL: 
57a8				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
57a8 6d				db WORD_SYS_CORE+89             
57a9 f6 57			dw .STOREPAGE            
57ab 06				db 5 + 1 
57ac .. 00			db "LABEL",0              
57b2				endm 
# End of macro CWHEAD
57b2			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
57b2			; | | Compatible with PicoSPINet  
57b2					; TODO test to see if bank is selected 
57b2				 
57b2					if DEBUG_FORTH_WORDS_KEY 
57b2						DMARK "LBL" 
57b2 f5				push af  
57b3 3a c7 57			ld a, (.dmark)  
57b6 32 68 fe			ld (debug_mark),a  
57b9 3a c8 57			ld a, (.dmark+1)  
57bc 32 69 fe			ld (debug_mark+1),a  
57bf 3a c9 57			ld a, (.dmark+2)  
57c2 32 6a fe			ld (debug_mark+2),a  
57c5 18 03			jr .pastdmark  
57c7 ..			.dmark: db "LBL"  
57ca f1			.pastdmark: pop af  
57cb			endm  
# End of macro DMARK
57cb						CALLMONITOR 
57cb cd 6c fe			call debug_vector  
57ce				endm  
# End of macro CALLMONITOR
57ce					endif 
57ce			;	if DEBUG_STORESE 
57ce			;		DMARK "LBL" 
57ce			;		CALLMONITOR 
57ce			;	endif 
57ce					FORTH_DSP_VALUEHL 
57ce cd 0c 23			call macro_dsp_valuehl 
57d1				endm 
# End of macro FORTH_DSP_VALUEHL
57d1					;v5FORTH_DSP_VALUE 
57d1					 
57d1			;		push hl 
57d1					FORTH_DSP_POP 
57d1 cd c4 23			call macro_forth_dsp_pop 
57d4				endm 
# End of macro FORTH_DSP_POP
57d4			;		pop hl 
57d4			 
57d4			;v5		inc hl   ; move past the type marker 
57d4			 
57d4				if DEBUG_STORESE 
57d4					DMARK "LBl" 
57d4 f5				push af  
57d5 3a e9 57			ld a, (.dmark)  
57d8 32 68 fe			ld (debug_mark),a  
57db 3a ea 57			ld a, (.dmark+1)  
57de 32 69 fe			ld (debug_mark+1),a  
57e1 3a eb 57			ld a, (.dmark+2)  
57e4 32 6a fe			ld (debug_mark+2),a  
57e7 18 03			jr .pastdmark  
57e9 ..			.dmark: db "LBl"  
57ec f1			.pastdmark: pop af  
57ed			endm  
# End of macro DMARK
57ed					CALLMONITOR 
57ed cd 6c fe			call debug_vector  
57f0				endm  
# End of macro CALLMONITOR
57f0				endif 
57f0 cd 3b 06				call storage_label 
57f3			 
57f3				       NEXTW 
57f3 c3 c2 24			jp macro_next 
57f6				endm 
# End of macro NEXTW
57f6			.STOREPAGE: 
57f6				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57f6 6d				db WORD_SYS_CORE+89             
57f7 29 58			dw .LABELS            
57f9 0a				db 9 + 1 
57fa .. 00			db "STOREPAGE",0              
5804				endm 
# End of macro CWHEAD
5804			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5804			; | | Compatible with PicoSPINet  
5804					; TODO test to see if bank is selected 
5804				 
5804					if DEBUG_FORTH_WORDS_KEY 
5804						DMARK "STP" 
5804 f5				push af  
5805 3a 19 58			ld a, (.dmark)  
5808 32 68 fe			ld (debug_mark),a  
580b 3a 1a 58			ld a, (.dmark+1)  
580e 32 69 fe			ld (debug_mark+1),a  
5811 3a 1b 58			ld a, (.dmark+2)  
5814 32 6a fe			ld (debug_mark+2),a  
5817 18 03			jr .pastdmark  
5819 ..			.dmark: db "STP"  
581c f1			.pastdmark: pop af  
581d			endm  
# End of macro DMARK
581d						CALLMONITOR 
581d cd 6c fe			call debug_vector  
5820				endm  
# End of macro CALLMONITOR
5820					endif 
5820			;	if DEBUG_STORESE 
5820			;		DMARK "STP" 
5820			;		CALLMONITOR 
5820			;	endif 
5820			 
5820 21 77 fa			ld hl, store_page 
5823 cd 15 21			call forth_push_numhl 
5826			 
5826			 
5826				       NEXTW 
5826 c3 c2 24			jp macro_next 
5829				endm 
# End of macro NEXTW
5829			.LABELS: 
5829				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5829 6d				db WORD_SYS_CORE+89             
582a b3 58			dw .SCONST1            
582c 07				db 6 + 1 
582d .. 00			db "LABELS",0              
5834				endm 
# End of macro CWHEAD
5834			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5834			; | | *NOT* Compatible with PicoSPINet  
5834					;  
5834			 
5834					; save the current device selected to restore afterwards 
5834				 
5834 3a 5d fa				ld a, (spi_device) 
5837 f5					push af 
5838			 
5838			 
5838					; run through each of the banks 
5838			 
5838 21 01 00				ld hl, 1 
583b cd 15 21				call forth_push_numhl 
583e 3e ff				ld a, SPI_CE_HIGH 
5840 cb 87				res SPI_CE0, a 
5842 32 5d fa				ld (spi_device), a 
5845 cd 17 05				call storage_get_block_0 
5848 21 7a fa				ld hl, store_page+3 
584b cd 83 21				call forth_push_str 
584e			 
584e					 
584e 21 02 00				ld hl, 2 
5851 cd 15 21				call forth_push_numhl 
5854 3e ff				ld a, SPI_CE_HIGH 
5856 cb 8f				res SPI_CE1, a 
5858 32 5d fa				ld (spi_device), a 
585b cd 17 05				call storage_get_block_0 
585e 21 7a fa				ld hl, store_page+3 
5861 cd 83 21				call forth_push_str 
5864			 
5864					 
5864 21 03 00				ld hl, 3 
5867 cd 15 21				call forth_push_numhl 
586a 3e ff				ld a, SPI_CE_HIGH 
586c cb 97				res SPI_CE2, a 
586e 32 5d fa				ld (spi_device), a 
5871 cd 17 05				call storage_get_block_0 
5874 21 7a fa				ld hl, store_page+3 
5877 cd 83 21				call forth_push_str 
587a			 
587a			 
587a 21 04 00				ld hl, 4 
587d cd 15 21				call forth_push_numhl 
5880 3e ff				ld a, SPI_CE_HIGH 
5882 cb 9f				res SPI_CE3, a 
5884 32 5d fa				ld (spi_device), a 
5887 cd 17 05				call storage_get_block_0 
588a 21 7a fa				ld hl, store_page+3 
588d cd 83 21				call forth_push_str 
5890			 
5890					 
5890			 
5890 21 05 00				ld hl, 5 
5893 cd 15 21				call forth_push_numhl 
5896 3e ff				ld a, SPI_CE_HIGH 
5898 cb a7				res SPI_CE4, a 
589a 32 5d fa				ld (spi_device), a 
589d cd 17 05				call storage_get_block_0 
58a0 21 7a fa				ld hl, store_page+3 
58a3 cd 83 21				call forth_push_str 
58a6			 
58a6					 
58a6					; push fixed count of storage devices (on board) for now 
58a6			 
58a6 21 05 00				ld hl, 5 
58a9 cd 15 21				call forth_push_numhl 
58ac			 
58ac					; restore selected device  
58ac				 
58ac f1					pop af 
58ad 32 5d fa				ld (spi_device), a 
58b0			 
58b0				       NEXTW 
58b0 c3 c2 24			jp macro_next 
58b3				endm 
# End of macro NEXTW
58b3			 
58b3			.SCONST1: 
58b3				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
58b3 6d				db WORD_SYS_CORE+89             
58b4 ca 58			dw .SCONST2            
58b6 07				db 6 + 1 
58b7 .. 00			db "FILEID",0              
58be				endm 
# End of macro CWHEAD
58be			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
58be			; | | Compatible with PicoSPINet  
58be 3a 64 fa				ld a, (store_filecache) 
58c1 26 00				ld h, 0 
58c3 6f					ld l, a 
58c4 cd 15 21				call forth_push_numhl 
58c7					NEXTW 
58c7 c3 c2 24			jp macro_next 
58ca				endm 
# End of macro NEXTW
58ca			.SCONST2: 
58ca				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
58ca 6d				db WORD_SYS_CORE+89             
58cb e2 58			dw .SCONST3            
58cd 08				db 7 + 1 
58ce .. 00			db "FILEEXT",0              
58d6				endm 
# End of macro CWHEAD
58d6			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
58d6			; | | Compatible with PicoSPINet  
58d6 3a 67 fa				ld a, (store_openext) 
58d9 26 00				ld h, 0 
58db 6f					ld l, a 
58dc cd 15 21				call forth_push_numhl 
58df					NEXTW 
58df c3 c2 24			jp macro_next 
58e2				endm 
# End of macro NEXTW
58e2			.SCONST3: 
58e2				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
58e2 6d				db WORD_SYS_CORE+89             
58e3 fa 58			dw .SCONST4            
58e5 08				db 7 + 1 
58e6 .. 00			db "FILEMAX",0              
58ee				endm 
# End of macro CWHEAD
58ee			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
58ee			; | | Compatible with PicoSPINet  
58ee 3a 66 fa				ld a, (store_openmaxext) 
58f1 26 00				ld h, 0 
58f3 6f					ld l, a 
58f4 cd 15 21				call forth_push_numhl 
58f7					NEXTW 
58f7 c3 c2 24			jp macro_next 
58fa				endm 
# End of macro NEXTW
58fa			.SCONST4: 
58fa				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58fa 6d				db WORD_SYS_CORE+89             
58fb 10 59			dw .SCONST5            
58fd 09				db 8 + 1 
58fe .. 00			db "FILEADDR",0              
5907				endm 
# End of macro CWHEAD
5907			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5907			; | | Compatible with PicoSPINet  
5907 2a 68 fa				ld hl, (store_openaddr) 
590a cd 15 21				call forth_push_numhl 
590d					NEXTW 
590d c3 c2 24			jp macro_next 
5910				endm 
# End of macro NEXTW
5910			.SCONST5: 
5910				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5910 6d				db WORD_SYS_CORE+89             
5911 31 59			dw .SCONST6            
5913 09				db 8 + 1 
5914 .. 00			db "FILEPAGE",0              
591d				endm 
# End of macro CWHEAD
591d			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
591d			; | | Compatible with PicoSPINet  
591d 2a 68 fa				ld hl, (store_openaddr) 
5920 e5					push hl 
5921 c1					pop bc 
5922 16 00				ld d, 0 
5924 1e 40				ld e, STORE_BLOCK_PHY 
5926 cd 2d 0f				call Div16 
5929 c5					push bc 
592a e1					pop hl 
592b cd 15 21				call forth_push_numhl 
592e					NEXTW 
592e c3 c2 24			jp macro_next 
5931				endm 
# End of macro NEXTW
5931			.SCONST6: 
5931				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5931 6d				db WORD_SYS_CORE+89             
5932 4a 59			dw .ENDSTORAGE            
5934 09				db 8 + 1 
5935 .. 00			db "READCONT",0              
593e				endm 
# End of macro CWHEAD
593e			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
593e			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
593e			; | | a further read should, if applicable, be CONCAT to the previous read. 
593e			; | | Compatible with PicoSPINet  
593e 3a 6a fa				ld a, (store_readcont) 
5941 26 00				ld h, 0 
5943 6f					ld l, a 
5944 cd 15 21				call forth_push_numhl 
5947					NEXTW 
5947 c3 c2 24			jp macro_next 
594a				endm 
# End of macro NEXTW
594a			.ENDSTORAGE: 
594a			; eof 
# End of file forth_words_storage.asm
594a			endif 
594a				include "forth_words_device.asm" 
594a			; Device related words 
594a			 
594a			; | ## Device Words 
594a			 
594a			;if SOUND_ENABLE 
594a			;.NOTE: 
594a			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
594a			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
594a			;		if DEBUG_FORTH_WORDS_KEY 
594a			;			DMARK "NTE" 
594a			;			CALLMONITOR 
594a			;		endif 
594a			; 
594a			;	 
594a			; 
594a			;		NEXTW 
594a			;.AFTERSOUND: 
594a			;endif 
594a			 
594a			 
594a			USE_GPIO: equ 0 
594a			 
594a			if USE_GPIO 
594a			.GP1: 
594a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
594a			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
594a					NEXTW 
594a			.GP2: 
594a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
594a			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
594a			 
594a					NEXTW 
594a			 
594a			.GP3: 
594a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
594a			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
594a			 
594a					NEXTW 
594a			 
594a			.GP4: 
594a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
594a			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
594a			 
594a					NEXTW 
594a			.SIN: 
594a			 
594a			 
594a			endif 
594a			 
594a			 
594a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
594a 33				db WORD_SYS_CORE+31             
594b 7f 59			dw .SOUT            
594d 03				db 2 + 1 
594e .. 00			db "IN",0              
5951				endm 
# End of macro CWHEAD
5951			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5951					if DEBUG_FORTH_WORDS_KEY 
5951						DMARK "IN." 
5951 f5				push af  
5952 3a 66 59			ld a, (.dmark)  
5955 32 68 fe			ld (debug_mark),a  
5958 3a 67 59			ld a, (.dmark+1)  
595b 32 69 fe			ld (debug_mark+1),a  
595e 3a 68 59			ld a, (.dmark+2)  
5961 32 6a fe			ld (debug_mark+2),a  
5964 18 03			jr .pastdmark  
5966 ..			.dmark: db "IN."  
5969 f1			.pastdmark: pop af  
596a			endm  
# End of macro DMARK
596a						CALLMONITOR 
596a cd 6c fe			call debug_vector  
596d				endm  
# End of macro CALLMONITOR
596d					endif 
596d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
596d cd 0c 23			call macro_dsp_valuehl 
5970				endm 
# End of macro FORTH_DSP_VALUEHL
5970			 
5970 e5					push hl 
5971			 
5971					; destroy value TOS 
5971			 
5971					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5971 cd c4 23			call macro_forth_dsp_pop 
5974				endm 
# End of macro FORTH_DSP_POP
5974			 
5974					; one value on hl get other one back 
5974			 
5974 c1					pop bc 
5975			 
5975					; do the sub 
5975			;		ex de, hl 
5975			 
5975 ed 68				in l,(c) 
5977			 
5977					; save it 
5977			 
5977 26 00				ld h,0 
5979			 
5979					; TODO push value back onto stack for another op etc 
5979			 
5979 cd 15 21				call forth_push_numhl 
597c					NEXTW 
597c c3 c2 24			jp macro_next 
597f				endm 
# End of macro NEXTW
597f			.SOUT: 
597f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
597f 34				db WORD_SYS_CORE+32             
5980 d2 59			dw .SPIO            
5982 04				db 3 + 1 
5983 .. 00			db "OUT",0              
5987				endm 
# End of macro CWHEAD
5987			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5987					if DEBUG_FORTH_WORDS_KEY 
5987						DMARK "OUT" 
5987 f5				push af  
5988 3a 9c 59			ld a, (.dmark)  
598b 32 68 fe			ld (debug_mark),a  
598e 3a 9d 59			ld a, (.dmark+1)  
5991 32 69 fe			ld (debug_mark+1),a  
5994 3a 9e 59			ld a, (.dmark+2)  
5997 32 6a fe			ld (debug_mark+2),a  
599a 18 03			jr .pastdmark  
599c ..			.dmark: db "OUT"  
599f f1			.pastdmark: pop af  
59a0			endm  
# End of macro DMARK
59a0						CALLMONITOR 
59a0 cd 6c fe			call debug_vector  
59a3				endm  
# End of macro CALLMONITOR
59a3					endif 
59a3			 
59a3					; get port 
59a3			 
59a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59a3 cd 0c 23			call macro_dsp_valuehl 
59a6				endm 
# End of macro FORTH_DSP_VALUEHL
59a6			 
59a6 e5					push hl 
59a7			 
59a7					; destroy value TOS 
59a7			 
59a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59a7 cd c4 23			call macro_forth_dsp_pop 
59aa				endm 
# End of macro FORTH_DSP_POP
59aa			 
59aa					; get byte to send 
59aa			 
59aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59aa cd 0c 23			call macro_dsp_valuehl 
59ad				endm 
# End of macro FORTH_DSP_VALUEHL
59ad			 
59ad			;		push hl 
59ad			 
59ad					; destroy value TOS 
59ad			 
59ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59ad cd c4 23			call macro_forth_dsp_pop 
59b0				endm 
# End of macro FORTH_DSP_POP
59b0			 
59b0					; one value on hl get other one back 
59b0			 
59b0			;		pop hl 
59b0			 
59b0 c1					pop bc 
59b1			 
59b1					if DEBUG_FORTH_WORDS 
59b1						DMARK "OUT" 
59b1 f5				push af  
59b2 3a c6 59			ld a, (.dmark)  
59b5 32 68 fe			ld (debug_mark),a  
59b8 3a c7 59			ld a, (.dmark+1)  
59bb 32 69 fe			ld (debug_mark+1),a  
59be 3a c8 59			ld a, (.dmark+2)  
59c1 32 6a fe			ld (debug_mark+2),a  
59c4 18 03			jr .pastdmark  
59c6 ..			.dmark: db "OUT"  
59c9 f1			.pastdmark: pop af  
59ca			endm  
# End of macro DMARK
59ca						CALLMONITOR 
59ca cd 6c fe			call debug_vector  
59cd				endm  
# End of macro CALLMONITOR
59cd					endif 
59cd			 
59cd ed 69				out (c), l 
59cf			 
59cf					NEXTW 
59cf c3 c2 24			jp macro_next 
59d2				endm 
# End of macro NEXTW
59d2			 
59d2			 
59d2			.SPIO: 
59d2			 
59d2			if STORAGE_SE 
59d2				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
59d2 51				db WORD_SYS_CORE+61             
59d3 e3 59			dw .SPICEH            
59d5 07				db 6 + 1 
59d6 .. 00			db "SPICEL",0              
59dd				endm 
# End of macro CWHEAD
59dd			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
59dd			 
59dd cd 14 02				call spi_ce_low 
59e0			    NEXTW 
59e0 c3 c2 24			jp macro_next 
59e3				endm 
# End of macro NEXTW
59e3			 
59e3			.SPICEH: 
59e3				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
59e3 51				db WORD_SYS_CORE+61             
59e4 f4 59			dw .SPIOb            
59e6 07				db 6 + 1 
59e7 .. 00			db "SPICEH",0              
59ee				endm 
# End of macro CWHEAD
59ee			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
59ee			 
59ee cd 03 02				call spi_ce_high 
59f1			    NEXTW 
59f1 c3 c2 24			jp macro_next 
59f4				endm 
# End of macro NEXTW
59f4			 
59f4			 
59f4			.SPIOb: 
59f4			 
59f4				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
59f4 51				db WORD_SYS_CORE+61             
59f5 26 5a			dw .SPII            
59f7 05				db 4 + 1 
59f8 .. 00			db "SPIO",0              
59fd				endm 
# End of macro CWHEAD
59fd			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59fd			 
59fd					if DEBUG_FORTH_WORDS_KEY 
59fd						DMARK "SPo" 
59fd f5				push af  
59fe 3a 12 5a			ld a, (.dmark)  
5a01 32 68 fe			ld (debug_mark),a  
5a04 3a 13 5a			ld a, (.dmark+1)  
5a07 32 69 fe			ld (debug_mark+1),a  
5a0a 3a 14 5a			ld a, (.dmark+2)  
5a0d 32 6a fe			ld (debug_mark+2),a  
5a10 18 03			jr .pastdmark  
5a12 ..			.dmark: db "SPo"  
5a15 f1			.pastdmark: pop af  
5a16			endm  
# End of macro DMARK
5a16						CALLMONITOR 
5a16 cd 6c fe			call debug_vector  
5a19				endm  
# End of macro CALLMONITOR
5a19					endif 
5a19					; get port 
5a19			 
5a19			 
5a19					; get byte to send 
5a19			 
5a19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a19 cd 0c 23			call macro_dsp_valuehl 
5a1c				endm 
# End of macro FORTH_DSP_VALUEHL
5a1c			 
5a1c			;		push hl    ; u1  
5a1c			 
5a1c					; destroy value TOS 
5a1c			 
5a1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a1c cd c4 23			call macro_forth_dsp_pop 
5a1f				endm 
# End of macro FORTH_DSP_POP
5a1f			 
5a1f					; one value on hl get other one back 
5a1f			 
5a1f			;		pop hl   ; u2 - addr 
5a1f			 
5a1f					; TODO Send SPI byte 
5a1f			 
5a1f			;		push hl 
5a1f			;		call spi_ce_low 
5a1f			;		pop hl 
5a1f 7d					ld a, l 
5a20 cd 02 01				call spi_send_byte 
5a23			;		call spi_ce_high 
5a23			 
5a23					NEXTW 
5a23 c3 c2 24			jp macro_next 
5a26				endm 
# End of macro NEXTW
5a26			 
5a26			.SPII: 
5a26				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a26 52				db WORD_SYS_CORE+62             
5a27 8f 5a			dw .SESEL            
5a29 06				db 5 + 1 
5a2a .. 00			db "SPII",0              
5a2f				endm 
# End of macro CWHEAD
5a2f			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a2f					if DEBUG_FORTH_WORDS_KEY 
5a2f						DMARK "SPi" 
5a2f f5				push af  
5a30 3a 44 5a			ld a, (.dmark)  
5a33 32 68 fe			ld (debug_mark),a  
5a36 3a 45 5a			ld a, (.dmark+1)  
5a39 32 69 fe			ld (debug_mark+1),a  
5a3c 3a 46 5a			ld a, (.dmark+2)  
5a3f 32 6a fe			ld (debug_mark+2),a  
5a42 18 03			jr .pastdmark  
5a44 ..			.dmark: db "SPi"  
5a47 f1			.pastdmark: pop af  
5a48			endm  
# End of macro DMARK
5a48						CALLMONITOR 
5a48 cd 6c fe			call debug_vector  
5a4b				endm  
# End of macro CALLMONITOR
5a4b					endif 
5a4b			 
5a4b					; TODO Get SPI byte 
5a4b			 
5a4b cd 29 01				call spi_read_byte 
5a4e			 
5a4e					if DEBUG_FORTH_WORDS 
5a4e						DMARK "Si2" 
5a4e f5				push af  
5a4f 3a 63 5a			ld a, (.dmark)  
5a52 32 68 fe			ld (debug_mark),a  
5a55 3a 64 5a			ld a, (.dmark+1)  
5a58 32 69 fe			ld (debug_mark+1),a  
5a5b 3a 65 5a			ld a, (.dmark+2)  
5a5e 32 6a fe			ld (debug_mark+2),a  
5a61 18 03			jr .pastdmark  
5a63 ..			.dmark: db "Si2"  
5a66 f1			.pastdmark: pop af  
5a67			endm  
# End of macro DMARK
5a67						CALLMONITOR 
5a67 cd 6c fe			call debug_vector  
5a6a				endm  
# End of macro CALLMONITOR
5a6a					endif 
5a6a 26 00				ld h, 0 
5a6c 6f					ld l, a 
5a6d					if DEBUG_FORTH_WORDS 
5a6d						DMARK "Si3" 
5a6d f5				push af  
5a6e 3a 82 5a			ld a, (.dmark)  
5a71 32 68 fe			ld (debug_mark),a  
5a74 3a 83 5a			ld a, (.dmark+1)  
5a77 32 69 fe			ld (debug_mark+1),a  
5a7a 3a 84 5a			ld a, (.dmark+2)  
5a7d 32 6a fe			ld (debug_mark+2),a  
5a80 18 03			jr .pastdmark  
5a82 ..			.dmark: db "Si3"  
5a85 f1			.pastdmark: pop af  
5a86			endm  
# End of macro DMARK
5a86						CALLMONITOR 
5a86 cd 6c fe			call debug_vector  
5a89				endm  
# End of macro CALLMONITOR
5a89					endif 
5a89 cd 15 21				call forth_push_numhl 
5a8c			 
5a8c					NEXTW 
5a8c c3 c2 24			jp macro_next 
5a8f				endm 
# End of macro NEXTW
5a8f			 
5a8f			 
5a8f			 
5a8f			.SESEL: 
5a8f				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a8f 66				db WORD_SYS_CORE+82             
5a90 38 5b			dw .CARTDEV            
5a92 05				db 4 + 1 
5a93 .. 00			db "BANK",0              
5a98				endm 
# End of macro CWHEAD
5a98			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a98					if DEBUG_FORTH_WORDS_KEY 
5a98						DMARK "BNK" 
5a98 f5				push af  
5a99 3a ad 5a			ld a, (.dmark)  
5a9c 32 68 fe			ld (debug_mark),a  
5a9f 3a ae 5a			ld a, (.dmark+1)  
5aa2 32 69 fe			ld (debug_mark+1),a  
5aa5 3a af 5a			ld a, (.dmark+2)  
5aa8 32 6a fe			ld (debug_mark+2),a  
5aab 18 03			jr .pastdmark  
5aad ..			.dmark: db "BNK"  
5ab0 f1			.pastdmark: pop af  
5ab1			endm  
# End of macro DMARK
5ab1						CALLMONITOR 
5ab1 cd 6c fe			call debug_vector  
5ab4				endm  
# End of macro CALLMONITOR
5ab4					endif 
5ab4			 
5ab4 3e ff				ld a, 255 
5ab6 32 60 fa				ld (spi_cartdev), a 
5ab9			 
5ab9					; get bank 
5ab9			 
5ab9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ab9 cd 0c 23			call macro_dsp_valuehl 
5abc				endm 
# End of macro FORTH_DSP_VALUEHL
5abc			 
5abc			;		push hl 
5abc			 
5abc					; destroy value TOS 
5abc			 
5abc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5abc cd c4 23			call macro_forth_dsp_pop 
5abf				endm 
# End of macro FORTH_DSP_POP
5abf			 
5abf					; one value on hl get other one back 
5abf			 
5abf			;		pop hl 
5abf			 
5abf			 
5abf 0e ff				ld c, SPI_CE_HIGH 
5ac1 06 30				ld b, '0'    ; human readable bank number 
5ac3			 
5ac3 7d					ld a, l 
5ac4			 
5ac4					if DEBUG_FORTH_WORDS 
5ac4						DMARK "BNK" 
5ac4 f5				push af  
5ac5 3a d9 5a			ld a, (.dmark)  
5ac8 32 68 fe			ld (debug_mark),a  
5acb 3a da 5a			ld a, (.dmark+1)  
5ace 32 69 fe			ld (debug_mark+1),a  
5ad1 3a db 5a			ld a, (.dmark+2)  
5ad4 32 6a fe			ld (debug_mark+2),a  
5ad7 18 03			jr .pastdmark  
5ad9 ..			.dmark: db "BNK"  
5adc f1			.pastdmark: pop af  
5add			endm  
# End of macro DMARK
5add						CALLMONITOR 
5add cd 6c fe			call debug_vector  
5ae0				endm  
# End of macro CALLMONITOR
5ae0					endif 
5ae0			 
5ae0					; active low 
5ae0			 
5ae0 fe 00				cp 0 
5ae2 28 28				jr z, .bset 
5ae4 fe 01				cp 1 
5ae6 20 04				jr nz, .b2 
5ae8 cb 81				res 0, c 
5aea 06 31				ld b, '1'    ; human readable bank number 
5aec fe 02		.b2:		cp 2 
5aee 20 04				jr nz, .b3 
5af0 cb 89				res 1, c 
5af2 06 32				ld b, '2'    ; human readable bank number 
5af4 fe 03		.b3:		cp 3 
5af6 20 04				jr nz, .b4 
5af8 cb 91				res 2, c 
5afa 06 33				ld b, '3'    ; human readable bank number 
5afc fe 04		.b4:		cp 4 
5afe 20 04				jr nz, .b5 
5b00 cb 99				res 3, c 
5b02 06 34				ld b, '4'    ; human readable bank number 
5b04 fe 05		.b5:		cp 5 
5b06 20 04				jr nz, .bset 
5b08 cb a1				res 4, c 
5b0a 06 35				ld b, '5'    ; human readable bank number 
5b0c			 
5b0c			.bset: 
5b0c 79					ld a, c 
5b0d 32 5d fa				ld (spi_device),a 
5b10 78					ld a, b 
5b11 32 5c fa				ld (spi_device_id),a 
5b14					if DEBUG_FORTH_WORDS 
5b14						DMARK "BN2" 
5b14 f5				push af  
5b15 3a 29 5b			ld a, (.dmark)  
5b18 32 68 fe			ld (debug_mark),a  
5b1b 3a 2a 5b			ld a, (.dmark+1)  
5b1e 32 69 fe			ld (debug_mark+1),a  
5b21 3a 2b 5b			ld a, (.dmark+2)  
5b24 32 6a fe			ld (debug_mark+2),a  
5b27 18 03			jr .pastdmark  
5b29 ..			.dmark: db "BN2"  
5b2c f1			.pastdmark: pop af  
5b2d			endm  
# End of macro DMARK
5b2d						CALLMONITOR 
5b2d cd 6c fe			call debug_vector  
5b30				endm  
# End of macro CALLMONITOR
5b30					endif 
5b30			 
5b30					; set default SPI clk pulse time as disabled for BANK use 
5b30			 
5b30 3e 00				ld a, 0 
5b32 32 61 fa				ld (spi_clktime), a 
5b35			 
5b35					NEXTW 
5b35 c3 c2 24			jp macro_next 
5b38				endm 
# End of macro NEXTW
5b38			 
5b38			.CARTDEV: 
5b38				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5b38 66				db WORD_SYS_CORE+82             
5b39 e6 5b			dw .ENDDEVICE            
5b3b 08				db 7 + 1 
5b3c .. 00			db "CARTDEV",0              
5b44				endm 
# End of macro CWHEAD
5b44			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5b44					if DEBUG_FORTH_WORDS_KEY 
5b44						DMARK "CDV" 
5b44 f5				push af  
5b45 3a 59 5b			ld a, (.dmark)  
5b48 32 68 fe			ld (debug_mark),a  
5b4b 3a 5a 5b			ld a, (.dmark+1)  
5b4e 32 69 fe			ld (debug_mark+1),a  
5b51 3a 5b 5b			ld a, (.dmark+2)  
5b54 32 6a fe			ld (debug_mark+2),a  
5b57 18 03			jr .pastdmark  
5b59 ..			.dmark: db "CDV"  
5b5c f1			.pastdmark: pop af  
5b5d			endm  
# End of macro DMARK
5b5d						CALLMONITOR 
5b5d cd 6c fe			call debug_vector  
5b60				endm  
# End of macro CALLMONITOR
5b60					endif 
5b60			 
5b60					; disable se storage bank selection 
5b60			 
5b60 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b62 32 5d fa				ld (spi_device), a 
5b65			 
5b65					; get bank 
5b65			 
5b65					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b65 cd 0c 23			call macro_dsp_valuehl 
5b68				endm 
# End of macro FORTH_DSP_VALUEHL
5b68			 
5b68			;		push hl 
5b68			 
5b68					; destroy value TOS 
5b68			 
5b68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b68 cd c4 23			call macro_forth_dsp_pop 
5b6b				endm 
# End of macro FORTH_DSP_POP
5b6b			 
5b6b					; one value on hl get other one back 
5b6b			 
5b6b			;		pop hl 
5b6b			 
5b6b					; active low 
5b6b			 
5b6b 0e ff				ld c, 255 
5b6d			 
5b6d 7d					ld a, l 
5b6e					if DEBUG_FORTH_WORDS 
5b6e						DMARK "CDV" 
5b6e f5				push af  
5b6f 3a 83 5b			ld a, (.dmark)  
5b72 32 68 fe			ld (debug_mark),a  
5b75 3a 84 5b			ld a, (.dmark+1)  
5b78 32 69 fe			ld (debug_mark+1),a  
5b7b 3a 85 5b			ld a, (.dmark+2)  
5b7e 32 6a fe			ld (debug_mark+2),a  
5b81 18 03			jr .pastdmark  
5b83 ..			.dmark: db "CDV"  
5b86 f1			.pastdmark: pop af  
5b87			endm  
# End of macro DMARK
5b87						CALLMONITOR 
5b87 cd 6c fe			call debug_vector  
5b8a				endm  
# End of macro CALLMONITOR
5b8a					endif 
5b8a fe 00				cp 0 
5b8c 28 30				jr z, .cset 
5b8e fe 01				cp 1 
5b90 20 02				jr nz, .c2 
5b92 cb 81				res 0, c 
5b94 fe 02		.c2:		cp 2 
5b96 20 02				jr nz, .c3 
5b98 cb 89				res 1, c 
5b9a fe 03		.c3:		cp 3 
5b9c 20 02				jr nz, .c4 
5b9e cb 91				res 2, c 
5ba0 fe 04		.c4:		cp 4 
5ba2 20 02				jr nz, .c5 
5ba4 cb 99				res 3, c 
5ba6 fe 05		.c5:		cp 5 
5ba8 20 02				jr nz, .c6 
5baa cb a1				res 4, c 
5bac fe 06		.c6:		cp 6 
5bae 20 02				jr nz, .c7 
5bb0 cb a9				res 5, c 
5bb2 fe 07		.c7:		cp 7 
5bb4 20 02				jr nz, .c8 
5bb6 cb b1				res 6, c 
5bb8 fe 08		.c8:		cp 8 
5bba 20 02				jr nz, .cset 
5bbc cb b9				res 7, c 
5bbe 79			.cset:		ld a, c 
5bbf 32 60 fa				ld (spi_cartdev),a 
5bc2			 
5bc2					if DEBUG_FORTH_WORDS 
5bc2						DMARK "CD2" 
5bc2 f5				push af  
5bc3 3a d7 5b			ld a, (.dmark)  
5bc6 32 68 fe			ld (debug_mark),a  
5bc9 3a d8 5b			ld a, (.dmark+1)  
5bcc 32 69 fe			ld (debug_mark+1),a  
5bcf 3a d9 5b			ld a, (.dmark+2)  
5bd2 32 6a fe			ld (debug_mark+2),a  
5bd5 18 03			jr .pastdmark  
5bd7 ..			.dmark: db "CD2"  
5bda f1			.pastdmark: pop af  
5bdb			endm  
# End of macro DMARK
5bdb						CALLMONITOR 
5bdb cd 6c fe			call debug_vector  
5bde				endm  
# End of macro CALLMONITOR
5bde					endif 
5bde			 
5bde					; set default SPI clk pulse time as 10ms for CARTDEV use 
5bde			 
5bde 3e 0a				ld a, $0a 
5be0 32 61 fa				ld (spi_clktime), a 
5be3					NEXTW 
5be3 c3 c2 24			jp macro_next 
5be6				endm 
# End of macro NEXTW
5be6			endif 
5be6			 
5be6			.ENDDEVICE: 
5be6			; eof 
5be6			 
# End of file forth_words_device.asm
5be6			 
5be6			; var handler 
5be6			 
5be6			 
5be6			.VARS: 
5be6				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5be6 77				db WORD_SYS_CORE+99             
5be7 97 5c			dw .V0            
5be9 04				db 3 + 1 
5bea .. 00			db "VAR",0              
5bee				endm 
# End of macro CWHEAD
5bee			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5bee			;| 
5bee			;| The variable name should consist of a single letter. e.g. "a" 
5bee			;! If a full string is passed then only the first char is looked at 
5bee			;| Any other char could exceed bounds checks!  
5bee			 
5bee					if DEBUG_FORTH_WORDS_KEY 
5bee						DMARK "VAR" 
5bee f5				push af  
5bef 3a 03 5c			ld a, (.dmark)  
5bf2 32 68 fe			ld (debug_mark),a  
5bf5 3a 04 5c			ld a, (.dmark+1)  
5bf8 32 69 fe			ld (debug_mark+1),a  
5bfb 3a 05 5c			ld a, (.dmark+2)  
5bfe 32 6a fe			ld (debug_mark+2),a  
5c01 18 03			jr .pastdmark  
5c03 ..			.dmark: db "VAR"  
5c06 f1			.pastdmark: pop af  
5c07			endm  
# End of macro DMARK
5c07						CALLMONITOR 
5c07 cd 6c fe			call debug_vector  
5c0a				endm  
# End of macro CALLMONITOR
5c0a					endif 
5c0a			 
5c0a					FORTH_DSP_VALUEHL 
5c0a cd 0c 23			call macro_dsp_valuehl 
5c0d				endm 
# End of macro FORTH_DSP_VALUEHL
5c0d			 
5c0d 7e					ld a, (hl)    ; get first char on of the string 
5c0e			 
5c0e			 
5c0e					if DEBUG_FORTH_WORDS 
5c0e						DMARK "VR1" 
5c0e f5				push af  
5c0f 3a 23 5c			ld a, (.dmark)  
5c12 32 68 fe			ld (debug_mark),a  
5c15 3a 24 5c			ld a, (.dmark+1)  
5c18 32 69 fe			ld (debug_mark+1),a  
5c1b 3a 25 5c			ld a, (.dmark+2)  
5c1e 32 6a fe			ld (debug_mark+2),a  
5c21 18 03			jr .pastdmark  
5c23 ..			.dmark: db "VR1"  
5c26 f1			.pastdmark: pop af  
5c27			endm  
# End of macro DMARK
5c27						CALLMONITOR 
5c27 cd 6c fe			call debug_vector  
5c2a				endm  
# End of macro CALLMONITOR
5c2a					endif 
5c2a					 
5c2a f5					push af	 
5c2b					FORTH_DSP_POP 
5c2b cd c4 23			call macro_forth_dsp_pop 
5c2e				endm 
# End of macro FORTH_DSP_POP
5c2e f1					pop af 
5c2f			 
5c2f					; convert to upper 
5c2f			 
5c2f cd 3d 13				call to_upper 
5c32					if DEBUG_FORTH_WORDS 
5c32						DMARK "Vaa" 
5c32 f5				push af  
5c33 3a 47 5c			ld a, (.dmark)  
5c36 32 68 fe			ld (debug_mark),a  
5c39 3a 48 5c			ld a, (.dmark+1)  
5c3c 32 69 fe			ld (debug_mark+1),a  
5c3f 3a 49 5c			ld a, (.dmark+2)  
5c42 32 6a fe			ld (debug_mark+2),a  
5c45 18 03			jr .pastdmark  
5c47 ..			.dmark: db "Vaa"  
5c4a f1			.pastdmark: pop af  
5c4b			endm  
# End of macro DMARK
5c4b						CALLMONITOR 
5c4b cd 6c fe			call debug_vector  
5c4e				endm  
# End of macro CALLMONITOR
5c4e					endif 
5c4e 06 41				ld b, 'A' 
5c50 90					sub b			; set offset 
5c51					if DEBUG_FORTH_WORDS 
5c51						DMARK "Vbb" 
5c51 f5				push af  
5c52 3a 66 5c			ld a, (.dmark)  
5c55 32 68 fe			ld (debug_mark),a  
5c58 3a 67 5c			ld a, (.dmark+1)  
5c5b 32 69 fe			ld (debug_mark+1),a  
5c5e 3a 68 5c			ld a, (.dmark+2)  
5c61 32 6a fe			ld (debug_mark+2),a  
5c64 18 03			jr .pastdmark  
5c66 ..			.dmark: db "Vbb"  
5c69 f1			.pastdmark: pop af  
5c6a			endm  
# End of macro DMARK
5c6a						CALLMONITOR 
5c6a cd 6c fe			call debug_vector  
5c6d				endm  
# End of macro CALLMONITOR
5c6d					endif 
5c6d cb 27				sla a  
5c6f				 
5c6f					 
5c6f					if DEBUG_FORTH_WORDS 
5c6f						DMARK "VR2" 
5c6f f5				push af  
5c70 3a 84 5c			ld a, (.dmark)  
5c73 32 68 fe			ld (debug_mark),a  
5c76 3a 85 5c			ld a, (.dmark+1)  
5c79 32 69 fe			ld (debug_mark+1),a  
5c7c 3a 86 5c			ld a, (.dmark+2)  
5c7f 32 6a fe			ld (debug_mark+2),a  
5c82 18 03			jr .pastdmark  
5c84 ..			.dmark: db "VR2"  
5c87 f1			.pastdmark: pop af  
5c88			endm  
# End of macro DMARK
5c88						CALLMONITOR 
5c88 cd 6c fe			call debug_vector  
5c8b				endm  
# End of macro CALLMONITOR
5c8b					endif 
5c8b			 
5c8b 21 f1 f9				ld hl, cli_var_array2 
5c8e cd d0 0f				call addatohl 
5c91 cd 15 21				call forth_push_numhl 
5c94			 
5c94			 
5c94				       NEXTW 
5c94 c3 c2 24			jp macro_next 
5c97				endm 
# End of macro NEXTW
5c97			.V0: 
5c97				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c97 78				db WORD_SYS_CORE+100             
5c98 af 5c			dw .V0Q            
5c9a 04				db 3 + 1 
5c9b .. 00			db "V0!",0              
5c9f				endm 
# End of macro CWHEAD
5c9f			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c9f			 
5c9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c9f cd 0c 23			call macro_dsp_valuehl 
5ca2				endm 
# End of macro FORTH_DSP_VALUEHL
5ca2			 
5ca2 11 25 fa				ld de, cli_var_array 
5ca5			 
5ca5 eb					ex de, hl 
5ca6 73					ld (hl), e 
5ca7 23					inc hl 
5ca8 72					ld (hl), d 
5ca9			 
5ca9					; destroy value TOS 
5ca9			 
5ca9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ca9 cd c4 23			call macro_forth_dsp_pop 
5cac				endm 
# End of macro FORTH_DSP_POP
5cac			 
5cac				       NEXTW 
5cac c3 c2 24			jp macro_next 
5caf				endm 
# End of macro NEXTW
5caf			.V0Q: 
5caf				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5caf 79				db WORD_SYS_CORE+101             
5cb0 c0 5c			dw .V1S            
5cb2 04				db 3 + 1 
5cb3 .. 00			db "V0@",0              
5cb7				endm 
# End of macro CWHEAD
5cb7			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5cb7 2a 25 fa				ld hl, (cli_var_array) 
5cba cd 15 21				call forth_push_numhl 
5cbd			 
5cbd				       NEXTW 
5cbd c3 c2 24			jp macro_next 
5cc0				endm 
# End of macro NEXTW
5cc0			.V1S: 
5cc0				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5cc0 7a				db WORD_SYS_CORE+102             
5cc1 d8 5c			dw .V1Q            
5cc3 04				db 3 + 1 
5cc4 .. 00			db "V1!",0              
5cc8				endm 
# End of macro CWHEAD
5cc8			;| V1! ( u1 -- )  Store value to v1 | DONE 
5cc8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cc8 cd 0c 23			call macro_dsp_valuehl 
5ccb				endm 
# End of macro FORTH_DSP_VALUEHL
5ccb			 
5ccb 11 27 fa				ld de, cli_var_array+2 
5cce				 
5cce eb					ex de, hl 
5ccf 73					ld (hl), e 
5cd0 23					inc hl 
5cd1 72					ld (hl), d 
5cd2			 
5cd2					; destroy value TOS 
5cd2			 
5cd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cd2 cd c4 23			call macro_forth_dsp_pop 
5cd5				endm 
# End of macro FORTH_DSP_POP
5cd5				       NEXTW 
5cd5 c3 c2 24			jp macro_next 
5cd8				endm 
# End of macro NEXTW
5cd8			.V1Q: 
5cd8				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5cd8 7b				db WORD_SYS_CORE+103             
5cd9 e9 5c			dw .V2S            
5cdb 04				db 3 + 1 
5cdc .. 00			db "V1@",0              
5ce0				endm 
# End of macro CWHEAD
5ce0			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5ce0 2a 27 fa				ld hl, (cli_var_array+2) 
5ce3 cd 15 21				call forth_push_numhl 
5ce6				       NEXTW 
5ce6 c3 c2 24			jp macro_next 
5ce9				endm 
# End of macro NEXTW
5ce9			.V2S: 
5ce9				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5ce9 7c				db WORD_SYS_CORE+104             
5cea 01 5d			dw .V2Q            
5cec 04				db 3 + 1 
5ced .. 00			db "V2!",0              
5cf1				endm 
# End of macro CWHEAD
5cf1			;| V2! ( u1 -- )  Store value to v2 | DONE 
5cf1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cf1 cd 0c 23			call macro_dsp_valuehl 
5cf4				endm 
# End of macro FORTH_DSP_VALUEHL
5cf4			 
5cf4 11 29 fa				ld de, cli_var_array+4 
5cf7				 
5cf7 eb					ex de, hl 
5cf8 73					ld (hl), e 
5cf9 23					inc hl 
5cfa 72					ld (hl), d 
5cfb			 
5cfb					; destroy value TOS 
5cfb			 
5cfb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cfb cd c4 23			call macro_forth_dsp_pop 
5cfe				endm 
# End of macro FORTH_DSP_POP
5cfe				       NEXTW 
5cfe c3 c2 24			jp macro_next 
5d01				endm 
# End of macro NEXTW
5d01			.V2Q: 
5d01				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5d01 7d				db WORD_SYS_CORE+105             
5d02 12 5d			dw .V3S            
5d04 04				db 3 + 1 
5d05 .. 00			db "V2@",0              
5d09				endm 
# End of macro CWHEAD
5d09			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5d09 2a 29 fa				ld hl, (cli_var_array+4) 
5d0c cd 15 21				call forth_push_numhl 
5d0f				       NEXTW 
5d0f c3 c2 24			jp macro_next 
5d12				endm 
# End of macro NEXTW
5d12			.V3S: 
5d12				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d12 7c				db WORD_SYS_CORE+104             
5d13 2a 5d			dw .V3Q            
5d15 04				db 3 + 1 
5d16 .. 00			db "V3!",0              
5d1a				endm 
# End of macro CWHEAD
5d1a			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d1a cd 0c 23			call macro_dsp_valuehl 
5d1d				endm 
# End of macro FORTH_DSP_VALUEHL
5d1d			 
5d1d 11 2b fa				ld de, cli_var_array+6 
5d20				 
5d20 eb					ex de, hl 
5d21 73					ld (hl), e 
5d22 23					inc hl 
5d23 72					ld (hl), d 
5d24			 
5d24					; destroy value TOS 
5d24			 
5d24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d24 cd c4 23			call macro_forth_dsp_pop 
5d27				endm 
# End of macro FORTH_DSP_POP
5d27				       NEXTW 
5d27 c3 c2 24			jp macro_next 
5d2a				endm 
# End of macro NEXTW
5d2a			.V3Q: 
5d2a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d2a 7d				db WORD_SYS_CORE+105             
5d2b 3b 5d			dw .END            
5d2d 04				db 3 + 1 
5d2e .. 00			db "V3@",0              
5d32				endm 
# End of macro CWHEAD
5d32			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5d32 2a 2b fa				ld hl, (cli_var_array+6) 
5d35 cd 15 21				call forth_push_numhl 
5d38				       NEXTW 
5d38 c3 c2 24			jp macro_next 
5d3b				endm 
# End of macro NEXTW
5d3b			 
5d3b			 
5d3b			 
5d3b			 
5d3b			 
5d3b			; end of dict marker 
5d3b			 
5d3b 00			.END:    db WORD_SYS_END 
5d3c 00 00			dw 0 
5d3e 00				db 0 
5d3f			 
5d3f			; use to jp here for user dict words to save on macro expansion  
5d3f			 
5d3f			user_dict_next: 
5d3f				NEXTW 
5d3f c3 c2 24			jp macro_next 
5d42				endm 
# End of macro NEXTW
5d42			 
5d42			 
5d42			user_exec: 
5d42				;    ld hl, <word code> 
5d42				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5d42				;    call forthexec 
5d42				;    jp user_dict_next   (NEXT) 
5d42			        ;    <word code bytes> 
5d42 eb				ex de, hl 
5d43 2a bf f4			ld hl,(os_tok_ptr) 
5d46				 
5d46				FORTH_RSP_NEXT 
5d46 cd bc 20			call macro_forth_rsp_next 
5d49				endm 
# End of macro FORTH_RSP_NEXT
5d49			 
5d49			if DEBUG_FORTH_UWORD 
5d49						DMARK "UEX" 
5d49 f5				push af  
5d4a 3a 5e 5d			ld a, (.dmark)  
5d4d 32 68 fe			ld (debug_mark),a  
5d50 3a 5f 5d			ld a, (.dmark+1)  
5d53 32 69 fe			ld (debug_mark+1),a  
5d56 3a 60 5d			ld a, (.dmark+2)  
5d59 32 6a fe			ld (debug_mark+2),a  
5d5c 18 03			jr .pastdmark  
5d5e ..			.dmark: db "UEX"  
5d61 f1			.pastdmark: pop af  
5d62			endm  
# End of macro DMARK
5d62				CALLMONITOR 
5d62 cd 6c fe			call debug_vector  
5d65				endm  
# End of macro CALLMONITOR
5d65			endif 
5d65			 
5d65			 
5d65			 
5d65 eb				ex de, hl 
5d66 22 bf f4			ld (os_tok_ptr), hl 
5d69				 
5d69				; Don't use next - Skips the first word in uword. 
5d69			 
5d69 c3 53 25			jp exec1 
5d6c			;	NEXT 
5d6c			 
5d6c			 
5d6c			; eof 
# End of file forth_wordsv4.asm
5d6c			endif 
5d6c			;;;;;;;;;;;;;; Debug code 
5d6c			 
5d6c			 
5d6c			;if DEBUG_FORTH_PARSE 
5d6c .. 00		.nowordfound: db "No match",0 
5d75 .. 00		.compword:	db "Comparing word ",0 
5d85 .. 00		.nextwordat:	db "Next word at",0 
5d92 .. 00		.charmatch:	db "Char match",0 
5d9d			;endif 
5d9d			if DEBUG_FORTH_JP 
5d9d			.foundword:	db "Word match. Exec..",0 
5d9d			endif 
5d9d			;if DEBUG_FORTH_PUSH 
5d9d .. 00		.enddict:	db "Dict end. Push.",0 
5dad .. 00		.push_str:	db "Pushing string",0 
5dbc .. 00		.push_num:	db "Pushing number",0 
5dcb .. 00		.data_sp:	db "SP:",0 
5dcf .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5de1 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5df3 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5e05			;endif 
5e05			;if DEBUG_FORTH_MALLOC 
5e05 .. 00		.push_malloc:	db "Malloc address",0 
5e14			;endif 
5e14			 
5e14			 
5e14			 
5e14			; display malloc address and current data stack pointer  
5e14			 
5e14			malloc_error: 
5e14 d5				push de 
5e15 f5				push af 
5e16 e5				push hl 
5e17 cd 9c 0d			call clear_display 
5e1a 11 3a 5e			ld de, .mallocerr 
5e1d 3e 00			ld a,0 
5e1f			;	ld de,os_word_scratch 
5e1f cd af 0d			call str_at_display 
5e22 3e 11			ld a, display_row_1+17 
5e24 11 68 fe			ld de, debug_mark 
5e27 cd af 0d			call str_at_display 
5e2a cd bf 0d			call update_display 
5e2d				;call break_point_state 
5e2d cd d3 79			call cin_wait 
5e30			 
5e30			;	ld a, ' ' 
5e30			;	ld (os_view_disable), a 
5e30 cd 36 1a			call bp_on 
5e33 e1				pop hl 
5e34 f1				pop af 
5e35 d1				pop de	 
5e36				CALLMONITOR 
5e36 cd 6c fe			call debug_vector  
5e39				endm  
# End of macro CALLMONITOR
5e39 c9				ret 
5e3a			 
5e3a .. 00		.mallocerr: 	db "Malloc Error",0 
5e47			;if DEBUG_FORTH_PUSH 
5e47			display_data_sp: 
5e47 f5				push af 
5e48			 
5e48				; see if disabled 
5e48			 
5e48			 
5e48 3a 6c fe			ld a, (debug_vector) 
5e4b fe c9			cp $C9  ; RET 
5e4d				;ld a, (os_view_disable) 
5e4d				;cp '*' 
5e4d 28 67			jr z, .skipdsp 
5e4f			 
5e4f e5				push hl 
5e50 e5				push hl 
5e51 e5			push hl 
5e52 cd 9c 0d			call clear_display 
5e55 e1			pop hl 
5e56 7c				ld a,h 
5e57 21 c3 f4			ld hl, os_word_scratch 
5e5a cd d1 12			call hexout 
5e5d e1				pop hl 
5e5e 7d				ld a,l 
5e5f 21 c5 f4			ld hl, os_word_scratch+2 
5e62 cd d1 12			call hexout 
5e65 21 c7 f4			ld hl, os_word_scratch+4 
5e68 3e 00			ld a,0 
5e6a 77				ld (hl),a 
5e6b 11 c3 f4			ld de,os_word_scratch 
5e6e 3e 28				ld a, display_row_2 
5e70 cd af 0d				call str_at_display 
5e73 11 cf 5d			ld de, .wordinhl 
5e76 3e 00			ld a, display_row_1 
5e78			 
5e78 cd af 0d				call str_at_display 
5e7b 11 68 fe			ld de, debug_mark 
5e7e 3e 11			ld a, display_row_1+17 
5e80			 
5e80 cd af 0d				call str_at_display 
5e83			 
5e83				; display current data stack pointer 
5e83 11 cb 5d			ld de,.data_sp 
5e86 3e 30				ld a, display_row_2 + 8 
5e88 cd af 0d				call str_at_display 
5e8b			 
5e8b 2a eb f9			ld hl,(cli_data_sp) 
5e8e e5				push hl 
5e8f 7c				ld a,h 
5e90 21 c3 f4			ld hl, os_word_scratch 
5e93 cd d1 12			call hexout 
5e96 e1				pop hl 
5e97 7d				ld a,l 
5e98 21 c5 f4			ld hl, os_word_scratch+2 
5e9b cd d1 12			call hexout 
5e9e 21 c7 f4			ld hl, os_word_scratch+4 
5ea1 3e 00			ld a,0 
5ea3 77				ld (hl),a 
5ea4 11 c3 f4			ld de,os_word_scratch 
5ea7 3e 33				ld a, display_row_2 + 11 
5ea9 cd af 0d				call str_at_display 
5eac			 
5eac			 
5eac cd bf 0d			call update_display 
5eaf cd df 0c			call delay1s 
5eb2 cd df 0c			call delay1s 
5eb5 e1				pop hl 
5eb6			.skipdsp: 
5eb6 f1				pop af 
5eb7 c9				ret 
5eb8			 
5eb8			display_data_malloc: 
5eb8			 
5eb8 f5				push af 
5eb9 e5				push hl 
5eba e5				push hl 
5ebb e5			push hl 
5ebc cd 9c 0d			call clear_display 
5ebf e1			pop hl 
5ec0 7c				ld a,h 
5ec1 21 c3 f4			ld hl, os_word_scratch 
5ec4 cd d1 12			call hexout 
5ec7 e1				pop hl 
5ec8 7d				ld a,l 
5ec9 21 c5 f4			ld hl, os_word_scratch+2 
5ecc cd d1 12			call hexout 
5ecf 21 c7 f4			ld hl, os_word_scratch+4 
5ed2 3e 00			ld a,0 
5ed4 77				ld (hl),a 
5ed5 11 c3 f4			ld de,os_word_scratch 
5ed8 3e 28				ld a, display_row_2 
5eda cd af 0d				call str_at_display 
5edd 11 05 5e			ld de, .push_malloc 
5ee0 3e 00			ld a, display_row_1 
5ee2			 
5ee2 cd af 0d				call str_at_display 
5ee5			 
5ee5				; display current data stack pointer 
5ee5 11 cb 5d			ld de,.data_sp 
5ee8 3e 30				ld a, display_row_2 + 8 
5eea cd af 0d				call str_at_display 
5eed			 
5eed 2a eb f9			ld hl,(cli_data_sp) 
5ef0 e5				push hl 
5ef1 7c				ld a,h 
5ef2 21 c3 f4			ld hl, os_word_scratch 
5ef5 cd d1 12			call hexout 
5ef8 e1				pop hl 
5ef9 7d				ld a,l 
5efa 21 c5 f4			ld hl, os_word_scratch+2 
5efd cd d1 12			call hexout 
5f00 21 c7 f4			ld hl, os_word_scratch+4 
5f03 3e 00			ld a,0 
5f05 77				ld (hl),a 
5f06 11 c3 f4			ld de,os_word_scratch 
5f09 3e 33				ld a, display_row_2 + 11 
5f0b cd af 0d				call str_at_display 
5f0e			 
5f0e cd bf 0d			call update_display 
5f11 cd df 0c			call delay1s 
5f14 cd df 0c			call delay1s 
5f17 e1				pop hl 
5f18 f1				pop af 
5f19 c9				ret 
5f1a			;endif 
5f1a			 
5f1a			include "forth_autostart.asm" 
5f1a			; list of commands to perform at system start up 
5f1a			 
5f1a			startcmds: 
5f1a			;	dw test11 
5f1a			;	dw test12 
5f1a			;	dw test13 
5f1a			;	dw test14 
5f1a			;	dw test15 
5f1a			;	dw test16 
5f1a			;	dw test17 
5f1a			;	dw ifthtest1 
5f1a			;	dw ifthtest2 
5f1a			;	dw ifthtest3 
5f1a			;	dw mmtest1 
5f1a			;	dw mmtest2 
5f1a			;	dw mmtest3 
5f1a			;	dw mmtest4 
5f1a			;	dw mmtest5 
5f1a			;	dw mmtest6 
5f1a			;	dw iftest1 
5f1a			;	dw iftest2 
5f1a			;	dw iftest3 
5f1a			;	dw looptest1 
5f1a			;	dw looptest2 
5f1a			;	dw test1 
5f1a			;	dw test2 
5f1a			;	dw test3 
5f1a			;	dw test4 
5f1a			;	dw game2r 
5f1a			;	dw game2b1 
5f1a			;	dw game2b2 
5f1a			 
5f1a				; start up words that are actually useful 
5f1a			 
5f1a			;    dw spi1 
5f1a			;    dw spi2 
5f1a			;    dw spi3 
5f1a			;    dw spi4 
5f1a			;    dw spi5 
5f1a			;    dw spi6 
5f1a			;    dw spi7 
5f1a			; 
5f1a			;    dw spi8 
5f1a			;    dw spi9 
5f1a			;    dw spi10 
5f1a			 
5f1a			; file editor 
5f1a			;	dw edit1 
5f1a			;	dw edit2 
5f1a			;	dw edit3 
5f1a			 
5f1a			;	dw longread 
5f1a 1a 63			dw clrstack 
5f1c 4e 63			dw type 
5f1e			;	dw stest 
5f1e 73 63			dw strncpy 
5f20			;	dw list 
5f20 d4 63			dw start1 
5f22 e4 63			dw start2 
5f24			;	dw start3 
5f24			;	dw start3b 
5f24			;	dw start3c 
5f24			 
5f24				; (unit) testing words 
5f24			 
5f24			;	dw mtesta 
5f24			;	dw mtestb 
5f24			;	dw mtestc 
5f24			;	dw mtestd 
5f24			;	dw mteste 
5f24			 
5f24				; demo/game words 
5f24			 
5f24			;        dw game3w 
5f24			;        dw game3p 
5f24			;        dw game3sc 
5f24			;        dw game3vsi 
5f24			;        dw game3vs 
5f24				 
5f24 3d 6e			dw game2b 
5f26 ab 6e			dw game2bf 
5f28 f5 6e			dw game2mba 
5f2a 8b 6f			dw game2mbas 
5f2c cd 6f			dw game2mb 
5f2e			 
5f2e fe 6a			dw game1 
5f30 0f 6b			dw game1a 
5f32 71 6b			dw game1b 
5f34 a6 6b			dw game1c 
5f36 dc 6b			dw game1d 
5f38 0d 6c			dw game1s 
5f3a 21 6c			dw game1t 
5f3c 36 6c			dw game1f 
5f3e 6a 6c			dw game1z 
5f40 ae 6c			dw game1zz 
5f42			 
5f42 18 69			dw test5 
5f44 50 69			dw test6 
5f46 88 69			dw test7 
5f48 9c 69			dw test8 
5f4a c8 69			dw test9 
5f4c de 69			dw test10 
5f4e				 
5f4e 85 6d		        dw ssv5 
5f50 69 6d		        dw ssv4 
5f52 4d 6d		        dw ssv3 
5f54 17 6d		        dw ssv2 
5f56 9e 6d		        dw ssv1 
5f58 e6 6d		        dw ssv1cpm 
5f5a			;	dw keyup 
5f5a			;	dw keydown 
5f5a			;	dw keyleft 
5f5a			;	dw keyright 
5f5a			;	dw 	keyf1 
5f5a			;	dw keyf2 
5f5a			;	dw keyf3 
5f5a			;	dw keyf4 
5f5a			;	dw keyf5 
5f5a			;	dw keyf6 
5f5a			;	dw keyf7 
5f5a			;	dw keyf8 
5f5a			;	dw keyf9 
5f5a			;	dw keyf10 
5f5a			;	dw keyf11 
5f5a			;	dw keyf12 
5f5a			;	dw keytab 
5f5a			;	dw keycr 
5f5a			;	dw keyhome 
5f5a			;	dw keyend 
5f5a			;	dw keybs 
5f5a 00 00			db 0, 0	 
5f5c			 
5f5c			 
5f5c			; File Editor 
5f5c			 
5f5c			; ( id - ) use 'e' to edit the displayed line 
5f5c .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f7d .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fb2			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fb2 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fea			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fea			 
5fea			; SPI Net support words 
5fea			 
5fea			; v0! = node to send to 
5fea			; ( str count - ) 
5fea .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6043			 
6043			; spiputchr ( char node - ) 
6043 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
6079			 
6079			; spigetchr ( - n ) 
6079 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
60a4			 
60a4			; getnode ( - n ) 
60a4 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60d1			 
60d1			; ( str node - )  
60d1 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6137			; store string ( str i - ) 
6137			 
6137			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6137 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
618c			 
618c			; get string ( addr i -  )    TO FIX 
618c			 
618c .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61e4			 
61e4			 
61e4			; NETCHAT (TODO) 
61e4			; Program to allow two nodes to chat with eachother 
61e4			; 
61e4			; v0 - target node 
61e4			;  
61e4			; accept input at 0,0 
61e4			; if input is string send spitype to target node 
61e4			; starting at row 2,0 , while spigetchr is not zero ->  
61e4			; 
61e4			; 
61e4			; TODO add paging of get request 
61e4			 
61e4			; ( node - ) 
61e4 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6203 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
625b .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
62d3			 
62d3			 
62d3			; Long read of currently open file 
62d3 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
631a			 
631a			; clear stack  
631a			 
631a .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
634e			 
634e			; type ( addr count - ) 
634e .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6373			 
6373			; some direct memory words 
6373			; strncpy ( len t f -- t ) 
6373			 
6373 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63d4			 
63d4 .. 00		start1:     	db ": bpon $00 bp ;",0 
63e4 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63f5 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6470 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64d0			 
64d0			 
64d0			; a handy word to list items on the stack 
64d0			 
64d0 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
653a			 
653a			 
653a			; test stack  
653a			; rnd8 stest 
653a			 
653a .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
65b1			 
65b1			; random malloc and free cycles 
65b1			 
65b1 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6666			 
6666			; fixed malloc and free cycles 
6666			 
6666 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6709			 
6709			; fixed double string push and drop cycle  
6709			 
6709 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
67be			 
67be			; consistent fixed string push and drop cycle  
67be			 
67be .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6862			 
6862 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6918			 
6918			;test1:		db ": aa 1 2 3 ;", 0 
6918			;test2:     	db "111 aa 888 999",0 
6918			;test3:     	db ": bb 77 ;",0 
6918			;test4:     	db "$02 $01 do i . loop bb",0 
6918			 
6918 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6950 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6988 .. 00		test7:     	db ": box hline vline ;",0 
699c .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
69c8 .. 00		test9:     	db ": sw $01 adsp world ;",0 
69de .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6a03 .. 00		test11:     	db "hello create .",0 
6a12 .. 00		test12:     	db "hello2 create .",0 
6a22			 
6a22			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6a22			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6a22			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6a22			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6a22			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6a22			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6a22			 
6a22			;iftest1:     	db "$0001 IF cls .",0 
6a22			;iftest2:     	db "$0000 IF cls .",0 
6a22			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6a22			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6a22			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6a22			 
6a22			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a22			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a22			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a22			 
6a22			 
6a22 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6a46 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6a76 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6a9b .. 00		sound4: db ": cha $00 ; ",0 
6aa8 .. 00		sound5: db ": chb $20 ; ",0 
6ab5 .. 00		sound6: db ": chc $40 ; ",0 
6ac2 .. 00		sound7: db ": chd $60 ; ",0 
6acf .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6ae7 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6afe			 
6afe			 
6afe			 
6afe			 
6afe			; a small guess the number game 
6afe			 
6afe .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6b0f .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6b71			 
6b71 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6ba6 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6bdc .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6c0d .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6c21 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6c36 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6c6a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6cae			 
6cae			; Using 'ga' save a high score across multiple runs using external storage 
6cae			 
6cae .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6d17			 
6d17			 
6d17			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6d17			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d17			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d17			 
6d17			; simple screen saver to test code memory reuse to destruction 
6d17			 
6d17 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6d4d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6d69 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6d85 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6d9e .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6de6 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6e3d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e3d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6e3d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6e3d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6e3d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6e3d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6e3d			 
6e3d			 
6e3d			 
6e3d			; minesweeper/battleship finding game 
6e3d			; draws a game board of random ship/mine positions 
6e3d			; user enters coords to see if it hits on 
6e3d			; game ends when all are hit 
6e3d			; when hit or miss says how many may be in the area 
6e3d			 
6e3d			; setup the game board and then hide it 
6e3d .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6eab .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6ef5			; prompt for where to target 
6ef5 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6f8b .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6fb0			; TODO see if the entered coords hits or misses pushes char hit of miss 
6fb0 .. 00		game2mbht:      db ": mbckht nop ;",0 
6fbf .. 00		game2mbms:      db ": mbcms nop ;",0 
6fcd			; TODO how many might be near by 
6fcd .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
704a			 
704a			; Game 3 
704a			 
704a			; Vert scroller ski game - avoid the trees! 
704a			 
704a			; v0 score (ie turns) 
704a			; v1 player pos 
704a			; v2 left wall 
704a			; v3 right wall 
704a			 
704a			; Draw side walls randomly 
704a			 
704a .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7078			 
7078			; Draw player 
7078 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7096			 
7096			; TODO Get Key 
7096			 
7096			; TODO Move left right 
7096			 
7096			; scroll and move walls a bit 
7096			 
7096 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
70c7			 
70c7			; main game loop 
70c7			 
70c7 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
70f3 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7132			 
7132			; key board defs 
7132			 
7132 .. 00		keyup:       db ": keyup $05 ;",0 
7140 .. 00		keydown:       db ": keydown $0a ;",0 
7150 .. 00		keyleft:       db ": keyleft $0b ;",0 
7160 .. 00		keyright:       db ": keyright $0c ;",0 
7171 .. 00		keyf1:       db ": keyf1 $10 ;",0 
717f .. 00		keyf2:       db ": keyf2 $11 ;",0 
718d .. 00		keyf3:       db ": keyf3 $12 ;",0 
719b .. 00		keyf4:       db ": keyf4 $13 ;",0 
71a9 .. 00		keyf5:       db ": keyf5 $14 ;",0 
71b7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
71c5 .. 00		keyf7:       db ": keyf7 $16 ;",0 
71d3 .. 00		keyf8:       db ": keyf8 $17 ;",0 
71e1 .. 00		keyf9:       db ": keyf9 $18 ;",0 
71ef .. 00		keyf10:       db ": keyf10 $19 ;",0 
71fe .. 00		keyf11:       db ": keyf11 $1a ;",0 
720d .. 00		keyf12:       db ": keyf12 $1b ;",0 
721c			 
721c .. 00		keytab:       db ": keytab $09 ;",0 
722b .. 00		keycr:       db ": keycr $0d ;",0 
7239 .. 00		keyhome:       db ": keyhome $0e ;",0 
7249 .. 00		keyend:       db ": keyend $0f ;",0 
7258 .. 00		keybs:       db ": keybs $08 ;",0 
7266			 
7266			   
7266			 
7266			 
7266			 
7266			; eof 
# End of file forth_autostart.asm
7266			 
7266			 
7266			 
7266			; stack over and underflow checks 
7266			 
7266			; init the words to detect the under/overflow 
7266			 
7266			chk_stk_init: 
7266				; a vague random number to check so we dont get any "lucky" hits 
7266 3e 2d			ld a, 45 
7268 6f				ld l, a 
7269 00				nop 
726a 3e 17			ld a, 23 
726c 67				ld h, a 
726d			 
726d 22 a6 f1			ld (chk_word), hl     ; the word we need to check against 
7270			 
7270			;	ld (chk_stund), hl	; stack points.... 
7270 22 fd fe			ld (chk_stovr), hl 
7273 22 e9 f9			ld (chk_ret_und), hl 
7276 22 a7 f9			ld (chk_ret_ovr), hl 
7279 22 25 f9			ld (chk_loop_ovr), hl 
727c 22 23 f7			ld (chk_data_ovr), hl 
727f c9				ret 
7280				 
7280			check_stacks: 
7280				; check all stack words 
7280			 
7280 e5				push hl 
7281 d5				push de 
7282			 
7282			;	ld de,(chk_word) 
7282			;	ld hl, (chk_stund)	; stack points.... 
7282			;	if DEBUG_STK_FAULT 
7282			;		DMARK "FAa" 
7282			;		CALLMONITOR 
7282			;	endif 
7282			;	call cmp16 
7282			;	jp z, .chk_faulta 
7282			; 
7282			;	ld de, sfaultsu 
7282			;	jp .chk_fault 
7282			 
7282 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7285 ed 5b a6 f1		ld de,(chk_word) 
7289				if DEBUG_STK_FAULT 
7289					DMARK "FAb" 
7289					CALLMONITOR 
7289				endif 
7289 cd ee 0f			call cmp16 
728c 28 06			jr z, .chk_fault1 
728e 11 2f 73			ld de, sfaultso 
7291 c3 e3 72			jp .chk_fault 
7294			.chk_fault1:  
7294 2a e9 f9			ld hl, (chk_ret_und) 
7297 ed 5b a6 f1		ld de,(chk_word) 
729b				if DEBUG_STK_FAULT 
729b					DMARK "FAU" 
729b					CALLMONITOR 
729b				endif 
729b cd ee 0f			call cmp16 
729e ca a7 72			jp z, .chk_fault2 
72a1 11 3f 73			ld de, sfaultru 
72a4 c3 e3 72			jp .chk_fault 
72a7			.chk_fault2:  
72a7 2a a7 f9			ld hl, (chk_ret_ovr) 
72aa ed 5b a6 f1		ld de,(chk_word) 
72ae				if DEBUG_STK_FAULT 
72ae					DMARK "FA1" 
72ae					CALLMONITOR 
72ae				endif 
72ae cd ee 0f			call cmp16 
72b1 ca ba 72			jp z, .chk_fault3 
72b4 11 4d 73			ld de, sfaultro 
72b7 c3 e3 72			jp .chk_fault 
72ba			.chk_fault3:  
72ba 2a 25 f9			ld hl, (chk_loop_ovr) 
72bd ed 5b a6 f1		ld de,(chk_word) 
72c1				if DEBUG_STK_FAULT 
72c1					DMARK "FA2" 
72c1					CALLMONITOR 
72c1				endif 
72c1 cd ee 0f			call cmp16 
72c4 ca cd 72			jp z, .chk_fault4 
72c7 11 67 73			ld de, sfaultlo 
72ca c3 e3 72			jp .chk_fault 
72cd			.chk_fault4:  
72cd 2a 23 f7			ld hl, (chk_data_ovr) 
72d0 ed 5b a6 f1		ld de,(chk_word) 
72d4				if DEBUG_STK_FAULT 
72d4					DMARK "FA3" 
72d4					CALLMONITOR 
72d4				endif 
72d4 cd ee 0f			call cmp16 
72d7 ca e0 72			jp z, .chk_fault5 
72da 11 81 73			ld de, sfaultdo 
72dd c3 e3 72			jp .chk_fault 
72e0			 
72e0			 
72e0			.chk_fault5:  
72e0 d1				pop de 
72e1 e1				pop hl 
72e2			 
72e2 c9				ret 
72e3			 
72e3 cd 9c 0d		.chk_fault: 	call clear_display 
72e6 3e 28				ld a, display_row_2 
72e8 cd af 0d				call str_at_display 
72eb 11 11 73				   ld de, .stackfault 
72ee 3e 00				ld a, display_row_1 
72f0 cd af 0d				call str_at_display 
72f3 11 68 fe				    ld de, debug_mark 
72f6 3e 11				ld a, display_row_1+17 
72f8 cd af 0d				call str_at_display 
72fb cd bf 0d				call update_display 
72fe			 
72fe				; prompt before entering montior for investigating issue 
72fe			 
72fe 3e 78			ld a, display_row_4 
7300 11 07 1e			ld de, endprog 
7303			 
7303 cd bf 0d			call update_display		 
7306			 
7306 cd 8d 20			call next_page_prompt 
7309			 
7309 d1				pop de 
730a e1				pop hl 
730b cd 5b 1e				call monitor 
730e c3 55 1d				jp warmstart 
7311					;jp 0 
7311					;halt 
7311			 
7311			 
7311			 
7311 .. 00		.stackfault: 	db "Stack fault:",0 
731e			 
731e .. 00		sfaultsu: 	db	"Stack under flow",0 
732f .. 00		sfaultso: 	db	"Stack over flow",0 
733f .. 00		sfaultru:	db "RTS underflow",0 
734d .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7367 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7381 .. 00		sfaultdo:	db "DTS overflow", 0 
738e			 
738e			 
738e			fault_dsp_under: 
738e 11 a0 73			ld de, .dsp_under 
7391 c3 50 74			jp .show_fault 
7394			 
7394			fault_rsp_under: 
7394 11 ae 73			ld de, .rsp_under 
7397 c3 50 74			jp .show_fault 
739a			fault_loop_under: 
739a 11 bc 73			ld de, .loop_under 
739d c3 50 74			jp .show_fault 
73a0			 
73a0 .. 00		.dsp_under: db "DSP Underflow",0 
73ae .. 00		.rsp_under: db "RSP Underflow",0 
73bc .. 00		.loop_under: db "LOOP Underflow",0 
73cb			 
73cb			 
73cb d5			type_faultn: 	push de 
73cc e5					push hl 
73cd cd 9c 0d				call clear_display 
73d0 11 f7 73				   ld de, .typefaultn 
73d3 3e 00				ld a, display_row_1 
73d5 cd af 0d				call str_at_display 
73d8 11 68 fe				    ld de, debug_mark 
73db 3e 11				ld a, display_row_1+17 
73dd cd af 0d				call str_at_display 
73e0 cd bf 0d				call update_display 
73e3			 
73e3				; prompt before entering montior for investigating issue 
73e3			 
73e3 3e 78			ld a, display_row_4 
73e5 11 07 1e			ld de, endprog 
73e8			 
73e8 cd bf 0d			call update_display		 
73eb			 
73eb cd 8d 20			call next_page_prompt 
73ee			 
73ee e5					push hl 
73ef d5					push de 
73f0 cd 5b 1e				call monitor 
73f3 c3 55 1d				jp warmstart 
73f6 76					halt 
73f7			 
73f7			 
73f7 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
740e			 
740e d5			type_faults: 	push de 
740f e5					push hl 
7410 cd 9c 0d				call clear_display 
7413 11 39 74				   ld de, .typefaults 
7416 3e 00				ld a, display_row_1 
7418 cd af 0d				call str_at_display 
741b 11 68 fe				    ld de, debug_mark 
741e 3e 11				ld a, display_row_1+17 
7420 cd af 0d				call str_at_display 
7423 cd bf 0d				call update_display 
7426			 
7426				; prompt before entering montior for investigating issue 
7426			 
7426 3e 78			ld a, display_row_4 
7428 11 07 1e			ld de, endprog 
742b			 
742b cd bf 0d			call update_display		 
742e			 
742e cd 8d 20			call next_page_prompt 
7431			 
7431 e1					pop hl 
7432 d1					pop de 
7433 cd 5b 1e				call monitor 
7436 c3 55 1d				jp warmstart 
7439			 
7439			 
7439 .. 00		.typefaults: db "STR Type Expected TOS!",0 
7450			 
7450			.show_fault: 	 
7450 d5					push de 
7451 cd 9c 0d				call clear_display 
7454 d1					pop de 
7455 3e 00				ld a, display_row_1 
7457 cd af 0d				call str_at_display 
745a 11 68 fe				    ld de, debug_mark 
745d 3e 11				ld a, display_row_1+17 
745f cd af 0d				call str_at_display 
7462 cd bf 0d				call update_display 
7465			 
7465				; prompt before entering montior for investigating issue 
7465			 
7465 3e 78			ld a, display_row_4 
7467 11 07 1e			ld de, endprog 
746a			 
746a cd bf 0d			call update_display		 
746d			 
746d cd 8d 20			call next_page_prompt 
7470			 
7470 e1					pop hl 
7471 d1					pop de 
7472 cd 5b 1e				call monitor 
7475			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7475			; TODO Make optional fault restart to cli or warm boot? 
7475					;jp warmstart 
7475 c3 ad 1d				jp cli 
7478 76					halt 
7479			 
7479			; handle the auto run of code from files in storage 
7479			 
7479			 
7479			include "forth_startup.asm" 
7479			; Which startup method to use? 
7479			; 
7479			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7479			; followed by loading of a list of scripts in eeprom 
7479			 
7479			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7479			; from eeprom 
7479			 
7479			; Select with define in main stubs 
7479			 
7479			if STARTUP_V1 
7479				include "forth_startupv1.asm" 
7479			endif 
7479			if STARTUP_V2 
7479				include "forth_startupv2.asm" 
7479			; Version 2 of the startup  
7479			;  
7479			; Auto load any files in bank 1 that start with a '*' 
7479			; If no se storage then revert to using eprom 
7479			 
7479			 
7479			if STORAGE_SE = 0 
7479			 
7479			sprompt1: db "Startup load...",0 
7479			sprompt2: db "Run? 1=No *=End #=All",0 
7479			 
7479			 
7479			 
7479			 
7479			forth_startup: 
7479				ld hl, startcmds 
7479				ld a, 0 
7479				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7479			 
7479			.start1:	push hl 
7479				call clear_display 
7479				ld de, sprompt1 
7479			        ld a, display_row_1 
7479				call str_at_display 
7479				ld de, sprompt2 
7479			        ld a, display_row_2 
7479				call str_at_display 
7479				pop hl 
7479				push hl 
7479				ld e,(hl) 
7479				inc hl 
7479				ld d,(hl) 
7479			        ld a, display_row_3 
7479				call str_at_display 
7479				call update_display 
7479			 
7479			 
7479				ld a, (os_last_cmd) 
7479				cp 0 
7479				jr z, .startprompt 
7479				call delay250ms 
7479				jr .startdo 
7479				 
7479				 
7479			 
7479			.startprompt: 
7479			 
7479				ld a,display_row_4 + display_cols - 1 
7479			        ld de, endprg 
7479				call str_at_display 
7479				call update_display 
7479				call delay1s 
7479				call cin_wait 
7479						 
7479				cp '*' 
7479				jr z, .startupend1 
7479				cp '#' 
7479				jr nz, .startno 
7479				ld a, 1 
7479				ld (os_last_cmd),a 
7479				jr .startdo 
7479			.startno:	cp '1' 
7479				jr z,.startnxt  
7479			 
7479				; exec startup line 
7479			.startdo:	 
7479				pop hl 
7479				push hl 
7479				 
7479				ld e,(hl) 
7479				inc hl 
7479				ld d,(hl) 
7479				ex de,hl 
7479			 
7479				push hl 
7479			 
7479				ld a, 0 
7479				;ld a, FORTH_END_BUFFER 
7479				call strlent 
7479				inc hl   ; include zero term to copy 
7479				ld b,0 
7479				ld c,l 
7479				pop hl 
7479				ld de, scratch 
7479				ldir 
7479			 
7479			 
7479				ld hl, scratch 
7479				call forthparse 
7479				call forthexec 
7479				call forthexec_cleanup 
7479			 
7479				ld a, display_row_4 
7479				ld de, endprog 
7479			 
7479				call update_display		 
7479			 
7479				ld a, (os_last_cmd) 
7479				cp 0 
7479				jr nz, .startnxt 
7479				call next_page_prompt 
7479			        call clear_display 
7479				call update_display		 
7479			 
7479				; move onto next startup line? 
7479			.startnxt: 
7479			 
7479				call delay250ms 
7479				pop hl 
7479			 
7479				inc hl 
7479				inc hl 
7479			 
7479				push hl 
7479				ld e, (hl) 
7479				inc hl 
7479				ld d, (hl) 
7479				pop hl 
7479				; TODO replace 0 test 
7479			 
7479				ex de, hl 
7479				call ishlzero 
7479			;	ld a,e 
7479			;	add d 
7479			;	cp 0    ; any left to do? 
7479				ex de, hl 
7479				jp nz, .start1 
7479				jr .startupend 
7479			 
7479			.startupend1: pop hl 
7479			.startupend: 
7479			 
7479				call clear_display 
7479				call update_display 
7479				ret 
7479			endif 
7479			 
7479			 
7479			if STORAGE_SE 
7479			 
7479			;sprompt3: db "Loading from start-up file:",0 
7479 .. 00		sprompt3: db "  Searching...",0 
7488			;sprompt4: db "(Any key to stop)",0 
7488			 
7488			 
7488			forth_autoload: 
7488			 
7488				; load block 0 of store 1 
7488				 
7488 3e fe			ld a, $fe      ; bit 0 clear 
748a 32 5d fa			ld (spi_device), a 
748d			 
748d cd 17 05			call storage_get_block_0 
7490			 
7490 3a 98 fa			ld a, (store_page+STORE_0_AUTOFILE) 
7493			 
7493 fe 00			cp 0 
7495 c8				ret z     ; auto start not enabled 
7496			 
7496 cd 9c 0d			call clear_display 
7499			 
7499				; set bank 
7499			 
7499 3a 9a fa				ld a, (store_page+STORE_0_BANKRUN) 
749c 32 5d fa				ld (spi_device), a 
749f			 
749f			 
749f				; generate a directory of bank 1 and search for flagged files 
749f			 
749f					if DEBUG_FORTH_WORDS_KEY 
749f						DMARK "DIR" 
749f f5				push af  
74a0 3a b4 74			ld a, (.dmark)  
74a3 32 68 fe			ld (debug_mark),a  
74a6 3a b5 74			ld a, (.dmark+1)  
74a9 32 69 fe			ld (debug_mark+1),a  
74ac 3a b6 74			ld a, (.dmark+2)  
74af 32 6a fe			ld (debug_mark+2),a  
74b2 18 03			jr .pastdmark  
74b4 ..			.dmark: db "DIR"  
74b7 f1			.pastdmark: pop af  
74b8			endm  
# End of macro DMARK
74b8						CALLMONITOR 
74b8 cd 6c fe			call debug_vector  
74bb				endm  
# End of macro CALLMONITOR
74bb					endif 
74bb			 
74bb cd 17 05			call storage_get_block_0 
74be			 
74be 21 77 fa			ld hl, store_page     ; get current id count 
74c1 46				ld b, (hl) 
74c2 0e 00			ld c, 0    ; count of files   
74c4					if DEBUG_FORTH_WORDS 
74c4						DMARK "DI1" 
74c4 f5				push af  
74c5 3a d9 74			ld a, (.dmark)  
74c8 32 68 fe			ld (debug_mark),a  
74cb 3a da 74			ld a, (.dmark+1)  
74ce 32 69 fe			ld (debug_mark+1),a  
74d1 3a db 74			ld a, (.dmark+2)  
74d4 32 6a fe			ld (debug_mark+2),a  
74d7 18 03			jr .pastdmark  
74d9 ..			.dmark: db "DI1"  
74dc f1			.pastdmark: pop af  
74dd			endm  
# End of macro DMARK
74dd						CALLMONITOR 
74dd cd 6c fe			call debug_vector  
74e0				endm  
# End of macro CALLMONITOR
74e0					endif 
74e0			 
74e0				; check for empty drive 
74e0			 
74e0 3e 00			ld a, 0 
74e2 b8				cp b 
74e3 ca 30 75			jp z, .dirdone 
74e6			 
74e6				; for each of the current ids do a search for them and if found push to stack 
74e6			 
74e6 c5			.diritem:	push bc 
74e7 21 40 00				ld hl, STORE_BLOCK_PHY 
74ea 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
74ec 58					ld e,b 
74ed			 
74ed d5					push de 
74ee e5					push hl 
74ef cd 9c 0d			call clear_display 
74f2 3e 32			ld a, display_row_2 + 10 
74f4 11 79 74			ld de, sprompt3 
74f7 cd af 0d			call str_at_display 
74fa cd f3 0c			call active 
74fd eb				ex de, hl 
74fe 3e 2f			ld a, display_row_2 + 7 
7500 cd af 0d			call str_at_display 
7503 cd bf 0d			call update_display 
7506 e1				pop hl 
7507 d1				pop de 
7508			 
7508			;		if DEBUG_FORTH_WORDS 
7508			;			DMARK "DI2" 
7508			;			CALLMONITOR 
7508			;		endif 
7508			 
7508 cd 99 07				call storage_findnextid 
750b			 
750b			;		if DEBUG_FORTH_WORDS 
750b			;			DMARK "DI3" 
750b			;			CALLMONITOR 
750b			;		endif 
750b			 
750b					; if found hl will be non zero 
750b			 
750b cd f9 0f				call ishlzero 
750e			;		ld a, l 
750e			;		add h 
750e			; 
750e			;		cp 0 
750e 28 1d				jr z, .dirnotfound 
7510			 
7510					; increase count 
7510			 
7510 c1					pop bc	 
7511 0c					inc c 
7512 c5					push bc 
7513					 
7513			 
7513					; get file header and push the file name 
7513			 
7513 11 77 fa				ld de, store_page 
7516 cd 66 04				call storage_read_block 
7519			 
7519					; push file id to stack 
7519				 
7519			 
7519					; is this a file we want to run? 
7519			 
7519 21 7a fa				ld hl, store_page+3 
751c 7e					ld a,(hl) 
751d fe 2a				cp '*' 
751f 20 0c				jr nz,  .dirnotfound 
7521					 
7521			 
7521			 
7521 3a 77 fa				ld a, (store_page) 
7524 d5					push de 
7525 e5					push hl 
7526 c5					push bc 
7527 cd 53 75				call .autorunf 
752a c1					pop bc 
752b e1					pop hl 
752c d1					pop de 
752d			 
752d			 
752d			 
752d				; save this extent 
752d			 
752d					; push file name 
752d			;display file name to run 
752d			 
752d			;		ld hl, store_page+3 
752d			;		if DEBUG_FORTH_WORDS 
752d			;			DMARK "DI5" 
752d			;			CALLMONITOR 
752d			;		endif 
752d			; 
752d			;		 
752d			; 
752d			;		call forth_push_str 
752d			;		if DEBUG_FORTH_WORDS 
752d			;			DMARK "DI6" 
752d			;			CALLMONITOR 
752d			;		endif 
752d			.dirnotfound: 
752d c1					pop bc     
752e 10 b6				djnz .diritem 
7530				 
7530			.dirdone:	 
7530					if DEBUG_FORTH_WORDS 
7530						DMARK "DI7" 
7530 f5				push af  
7531 3a 45 75			ld a, (.dmark)  
7534 32 68 fe			ld (debug_mark),a  
7537 3a 46 75			ld a, (.dmark+1)  
753a 32 69 fe			ld (debug_mark+1),a  
753d 3a 47 75			ld a, (.dmark+2)  
7540 32 6a fe			ld (debug_mark+2),a  
7543 18 03			jr .pastdmark  
7545 ..			.dmark: db "DI7"  
7548 f1			.pastdmark: pop af  
7549			endm  
# End of macro DMARK
7549						CALLMONITOR 
7549 cd 6c fe			call debug_vector  
754c				endm  
# End of macro CALLMONITOR
754c					endif 
754c			 
754c cd 9c 0d				call clear_display 
754f cd bf 0d				call update_display 
7552			 
7552 c9					ret 
7553			 
7553			 
7553			 
7553			 
7553			 
7553			.autorunf: 
7553			 
7553			 
7553				; get file id to load from and get the file name to display 
7553			 
7553			;		ld a, (store_page+STORE_0_FILERUN) 
7553			 
7553 2e 00				ld l, 0 
7555 67					ld h, a 
7556 11 77 fa				ld de, store_page 
7559			 
7559					if DEBUG_FORTH_WORDS 
7559						DMARK "ASp" 
7559 f5				push af  
755a 3a 6e 75			ld a, (.dmark)  
755d 32 68 fe			ld (debug_mark),a  
7560 3a 6f 75			ld a, (.dmark+1)  
7563 32 69 fe			ld (debug_mark+1),a  
7566 3a 70 75			ld a, (.dmark+2)  
7569 32 6a fe			ld (debug_mark+2),a  
756c 18 03			jr .pastdmark  
756e ..			.dmark: db "ASp"  
7571 f1			.pastdmark: pop af  
7572			endm  
# End of macro DMARK
7572						CALLMONITOR 
7572 cd 6c fe			call debug_vector  
7575				endm  
# End of macro CALLMONITOR
7575					endif 
7575 cd bf 09				call storage_read 
7578			 
7578					if DEBUG_FORTH_WORDS 
7578						DMARK "ASr" 
7578 f5				push af  
7579 3a 8d 75			ld a, (.dmark)  
757c 32 68 fe			ld (debug_mark),a  
757f 3a 8e 75			ld a, (.dmark+1)  
7582 32 69 fe			ld (debug_mark+1),a  
7585 3a 8f 75			ld a, (.dmark+2)  
7588 32 6a fe			ld (debug_mark+2),a  
758b 18 03			jr .pastdmark  
758d ..			.dmark: db "ASr"  
7590 f1			.pastdmark: pop af  
7591			endm  
# End of macro DMARK
7591						CALLMONITOR 
7591 cd 6c fe			call debug_vector  
7594				endm  
# End of macro CALLMONITOR
7594					endif 
7594			 
7594 cd f9 0f				call ishlzero 
7597 c8					ret z             ; file not found 
7598			 
7598					; display file name we are loading 
7598			 
7598 cd 9c 0d				call clear_display 
759b			 
759b 3e 32				ld a, display_row_2 + 10 
759d 11 7a fa				ld de, store_page+3 
75a0 cd af 0d				call str_at_display 
75a3				 
75a3			; 
75a3			 
75a3			;	ld a, display_row_1+5 
75a3			;	ld de, sprompt3 
75a3			;	call str_at_display 
75a3			;	ld a, display_row_2+7 
75a3			;	call active 
75a3			;	ex de, hl 
75a3			;;	ld de, sprompt4 
75a3			;	call str_at_display 
75a3			; 
75a3 cd bf 0d			call update_display 
75a6			 
75a6			;	call cin_wait 
75a6			;	cp 'n' 
75a6			;	ret z 
75a6			;	cp 'N' 
75a6			;	ret z 
75a6			 
75a6			;	call delay1s 
75a6			 
75a6 3a 79 fa			ld a, (store_page+2) 
75a9 32 66 fa			ld (store_openmaxext), a    ; save count of ext 
75ac 3e 01			ld a, 1  
75ae 32 67 fa			ld (store_openext), a    ; save count of ext 
75b1			 
75b1			.autof: 
75b1				; begin to read a line from file 
75b1			 
75b1 21 e5 f4			ld hl, os_cli_cmd 
75b4 22 e3 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
75b7			  
75b7			.readext: 
75b7 3a 67 fa			ld a, (store_openext) 
75ba 6f				ld l , a 
75bb				 
75bb 3a 77 fa			ld a, (store_page) 
75be 67				ld h, a	 
75bf 11 77 fa			ld de, store_page 
75c2					if DEBUG_FORTH_WORDS 
75c2						DMARK "ASl" 
75c2 f5				push af  
75c3 3a d7 75			ld a, (.dmark)  
75c6 32 68 fe			ld (debug_mark),a  
75c9 3a d8 75			ld a, (.dmark+1)  
75cc 32 69 fe			ld (debug_mark+1),a  
75cf 3a d9 75			ld a, (.dmark+2)  
75d2 32 6a fe			ld (debug_mark+2),a  
75d5 18 03			jr .pastdmark  
75d7 ..			.dmark: db "ASl"  
75da f1			.pastdmark: pop af  
75db			endm  
# End of macro DMARK
75db						CALLMONITOR 
75db cd 6c fe			call debug_vector  
75de				endm  
# End of macro CALLMONITOR
75de					endif 
75de cd bf 09				call storage_read 
75e1 cd f9 0f			call ishlzero 
75e4 c8				ret z 
75e5			 
75e5			; TODO copy to exec buffer 
75e5			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75e5			 
75e5				; copy the record buffer to the cli buffer 
75e5			 
75e5 ed 5b e3 f6		ld de, (os_var_array) 
75e9 21 79 fa			ld hl, store_page+2 
75ec			;	ex de, hl 
75ec 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
75ef ed b0			ldir 
75f1 ed 53 e3 f6		ld (os_var_array), de 
75f5				 
75f5 3a 67 fa			ld a, (store_openext) 
75f8 3c				inc a 
75f9 32 67 fa			ld (store_openext), a    ; save count of ext 
75fc			 
75fc			 
75fc			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75fc				 
75fc 3a 6a fa			ld a, (store_readcont) 
75ff fe 00			cp 0 
7601 20 b4			jr nz, .readext 
7603			 
7603			;	jr z, .autoend 
7603			 
7603					if DEBUG_FORTH_WORDS 
7603						DMARK "ASc" 
7603 f5				push af  
7604 3a 18 76			ld a, (.dmark)  
7607 32 68 fe			ld (debug_mark),a  
760a 3a 19 76			ld a, (.dmark+1)  
760d 32 69 fe			ld (debug_mark+1),a  
7610 3a 1a 76			ld a, (.dmark+2)  
7613 32 6a fe			ld (debug_mark+2),a  
7616 18 03			jr .pastdmark  
7618 ..			.dmark: db "ASc"  
761b f1			.pastdmark: pop af  
761c			endm  
# End of macro DMARK
761c						CALLMONITOR 
761c cd 6c fe			call debug_vector  
761f				endm  
# End of macro CALLMONITOR
761f					endif 
761f e5				push hl	 
7620 d5				push de 
7621 cd f3 0c			call active 
7624 eb				ex de, hl 
7625 3e 2f			ld a, display_row_2 + 7 
7627 cd af 0d			call str_at_display 
762a			 
762a cd bf 0d			call update_display 
762d d1				pop de  
762e e1				pop hl 
762f			;	call delay250ms 
762f			 
762f			 
762f			 
762f			 
762f			.autoexec: 
762f			 
762f			 
762f 21 e5 f4			ld hl, os_cli_cmd 
7632					if DEBUG_FORTH_WORDS 
7632						DMARK "ASx" 
7632 f5				push af  
7633 3a 47 76			ld a, (.dmark)  
7636 32 68 fe			ld (debug_mark),a  
7639 3a 48 76			ld a, (.dmark+1)  
763c 32 69 fe			ld (debug_mark+1),a  
763f 3a 49 76			ld a, (.dmark+2)  
7642 32 6a fe			ld (debug_mark+2),a  
7645 18 03			jr .pastdmark  
7647 ..			.dmark: db "ASx"  
764a f1			.pastdmark: pop af  
764b			endm  
# End of macro DMARK
764b						CALLMONITOR 
764b cd 6c fe			call debug_vector  
764e				endm  
# End of macro CALLMONITOR
764e					endif 
764e cd 10 25			call forthparse 
7651 cd 50 25			call forthexec 
7654 cd 62 24			call forthexec_cleanup 
7657			 
7657			 
7657			 
7657 c3 b1 75			jp .autof 
765a			;.autofdone: 
765a			; 
765a			;		if DEBUG_FORTH_WORDS 
765a			;			DMARK "ASx" 
765a			;			CALLMONITOR 
765a			;		endif 
765a			;;	call clear_display 
765a			;	ret 
765a			 
765a			 
765a			 
765a			endif 
# End of file forth_startupv2.asm
765a			endif 
765a			 
# End of file forth_startup.asm
765a			 
765a			; eof 
# End of file forth_kernel.asm
765a			;include "nascombasic.asm" 
765a			 
765a			 
765a			; find out where the code ends if loaded into RAM (for SC114) 
765a			;endofcode:  
765a			;	nop 
765a			 
765a			 
765a			; jump to nmi vector 
765a			 
765a			init_nmi: 
765a 3e c9			ld a, $c9   ; RET 
765c 32 6f fe			ld (nmi_vector), a 
765f c9				ret 
7660			nmi: 
7660 e5				push hl 
7661 d5				push de 
7662 c5				push bc 
7663 f5				push af 
7664 cd 6f fe			call nmi_vector 
7667 f5				push af 
7668 c5				push bc 
7669 d5				push de 
766a e5				push hl 
766b ed 4d			reti 
766d			 
766d			 
766d			; eof 
766d			 
# End of file main.asm
766d			include "firmware_lcd_4x40.asm" 
766d			; **********************************************************************  
766d			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
766d			; **********************************************************************  
766d			;  
766d			; **  Written as a Small Computer Monitor App  
766d			; **  www.scc.me.uk  
766d			;  
766d			; History  
766d			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
766d			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
766d			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
766d			;  
766d			; **********************************************************************  
766d			;  
766d			; This program is an example of one of the methods of interfacing an   
766d			; alphanumeric LCD module.   
766d			;  
766d			; In this example the display is connected to either a Z80 PIO or a   
766d			; simple 8-bit output port.   
766d			;  
766d			; This interfacing method uses 4-bit data mode and uses time delays  
766d			; rather than polling the display's ready status. As a result the   
766d			; interface only requires 6 simple output lines:  
766d			;   Output bit 0 = not used  
766d			;   Output bit 1 = not used  
766d			;   Output bit 2 = RS         High = data, Low = instruction  
766d			;   Output bit 3 = E          Active high  
766d			;   Output bit 4 = DB4  
766d			;   Output bit 5 = DB5  
766d			;   Output bit 6 = DB6  
766d			;   Output bit 7 = DB7  
766d			; Display's R/W is connected to 0v so it is always in write mode  
766d			;  
766d			; This set up should work with any system supporting the RC2014 bus  
766d			  
766d			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
766d			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
766d			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
766d			;  
766d			; **********************************************************************  
766d			  
766d			; Additonal for 4x40. E1 and E2 instead of just E   
766d			; TODO swipe vidout signal on port a to activate E2  
766d			  
766d			; **********************************************************************  
766d			; **  Constants  
766d			; **********************************************************************  
766d			; LCD constants required by LCD support module  
766d			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
766d			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
766d			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
766d			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
766d			; TODO Decide which E is being set  
766d			kLCDWidth:  EQU display_cols             ;Width in characters  
766d			  
766d			; **********************************************************************  
766d			; **  Code library usage  
766d			; **********************************************************************  
766d			  
766d			; send character to current cursor position  
766d			; wraps and/or scrolls screen automatically  
766d			  
766d			  
766d			  
766d			lcd_init:  
766d			  
766d			; SCMonAPI functions used  
766d			  
766d			; Alphanumeric LCD functions used  
766d			; no need to specify specific functions for this module  
766d			  
766d 3e cf		            LD   A, 11001111b  
766f d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7671 3e 00		            LD   A, 00000000b  
7673 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7675			  
7675			; Initialise alphanumeric LCD module  
7675 3e 00				ld a, 0  
7677 32 c8 fb				ld (display_lcde1e2), a  
767a cd fb 76		            CALL fLCD_Init      ;Initialise LCD module  
767d 3e 01				ld a, 1  
767f 32 c8 fb				ld (display_lcde1e2), a  
7682 cd fb 76		            CALL fLCD_Init      ;Initialise LCD module  
7685			  
7685 c9				ret  
7686			  
7686			;  
7686			;;  
7686			; lcd functions  
7686			;  
7686			;  
7686			  
7686			; what is at cursor position   
7686			  
7686			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7686			;		call curptr  
7686			;		ret  
7686			  
7686			  
7686			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7686			  
7686			curptr:  
7686 c5				push bc  
7687 21 ae fd			ld hl, display_fb0  
768a			cpr:	  
768a				; loop for cursor whole row  
768a 0e 28			ld c, display_cols  
768c 23			cpr1:	inc hl  
768d 0d				dec c  
768e 20 fc			jr nz, cpr1  
7690 05				dec b  
7691 20 f7			jr nz, cpr  
7693			  
7693				; add col	  
7693			  
7693 23			cpr2:	inc hl  
7694 1d				dec e  
7695 20 fc			jr nz, cpr2  
7697			  
7697 c1				pop bc  
7698 c9				ret  
7699				  
7699			  
7699			  
7699			  
7699			  
7699			; write the frame buffer given in hl to hardware   
7699 22 c6 fb		write_display: ld (display_write_tmp), hl 	   
769c 3e 00			ld a, kLCD_Line1  
769e cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76a1 06 28			ld b, display_cols  
76a3 ed 5b c6 fb		ld de, (display_write_tmp)  
76a7 cd f3 76			call write_len_string  
76aa				  
76aa				  
76aa 2a c6 fb			ld hl, (display_write_tmp)  
76ad 11 28 00			ld de, display_cols  
76b0 19				add hl,de  
76b1 22 c6 fb			ld (display_write_tmp),hl  
76b4			  
76b4				  
76b4 3e 28			ld a, kLCD_Line2  
76b6 cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76b9 06 28			ld b, display_cols  
76bb ed 5b c6 fb		ld de, (display_write_tmp)  
76bf cd f3 76			call write_len_string  
76c2				  
76c2 2a c6 fb			ld hl, (display_write_tmp)  
76c5 11 28 00			ld de, display_cols  
76c8 19				add hl,de  
76c9 22 c6 fb			ld (display_write_tmp),hl  
76cc			  
76cc				  
76cc 3e 50			ld a, kLCD_Line3  
76ce cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76d1 06 28			ld b, display_cols  
76d3 ed 5b c6 fb		ld de, (display_write_tmp)  
76d7 cd f3 76			call write_len_string  
76da				  
76da 2a c6 fb			ld hl, (display_write_tmp)  
76dd 11 28 00			ld de, display_cols  
76e0 19				add hl,de  
76e1 22 c6 fb			ld (display_write_tmp),hl  
76e4			  
76e4				  
76e4 3e 78			ld a, kLCD_Line4  
76e6 cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76e9 06 28			ld b, display_cols  
76eb ed 5b c6 fb		ld de, (display_write_tmp)  
76ef cd f3 76			call write_len_string  
76f2 c9					ret  
76f3				  
76f3				; write out a fixed length string given in b from de  
76f3			  
76f3 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
76f4 cd 60 77		            CALL fLCD_Data      ;Write character to display  
76f7 13				inc de  
76f8 10 f9			djnz write_len_string  
76fa c9				ret  
76fb			  
76fb			; Some other things to do  
76fb			;            LD   A, kLCD_Clear ;Display clear  
76fb			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
76fb			;            LD   A, kLCD_Under ;Display on with underscore cursor  
76fb			;            LD   A, kLCD_On     ;Display on with no cursor  
76fb			;            ;LD   A, kLCD_Off   ;Display off  
76fb			;            CALL fLCD_Inst      ;Send instruction to display  
76fb			;  
76fb			;  
76fb			;            halt  
76fb			;  
76fb			;  
76fb			;MsgHello:   DB  "Hello World!",0  
76fb			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
76fb			  
76fb			; Custom characters 5 pixels wide by 8 pixels high  
76fb			; Up to 8 custom characters can be defined  
76fb			;BitMaps:      
76fb			;; Character 0x00 = Battery icon  
76fb			;            DB  01110b  
76fb			;            DB  11011b  
76fb			;            DB  10001b  
76fb			;            DB  10001b  
76fb			;            DB  11111b  
76fb			;            DB  11111b  
76fb			;            DB  11111b  
76fb			;            DB  11111b  
76fb			;; Character 0x01 = Bluetooth icon  
76fb			;            DB  01100b  
76fb			;            DB  01010b  
76fb			;            DB  11100b  
76fb			;            DB  01000b  
76fb			;            DB  11100b  
76fb			;            DB  01010b  
76fb			;            DB  01100b  
76fb			;            DB  00000b  
76fb			;  
76fb			  
76fb			  
76fb			; **********************************************************************  
76fb			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
76fb			; **********************************************************************  
76fb			;  
76fb			; **  Written as a Small Computer Monitor App   
76fb			; **  Version 0.1 SCC 2018-05-16  
76fb			; **  www.scc.me.uk  
76fb			;  
76fb			; **********************************************************************  
76fb			;  
76fb			; This module provides support for alphanumeric LCD modules using with  
76fb			; *  HD44780 (or compatible) controller  
76fb			; *  5 x 7 pixel fonts  
76fb			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
76fb			; *  Interface via six digital outputs to the display (see below)  
76fb			;  
76fb			; LCD module pinout:  
76fb			;   1  Vss   0v supply  
76fb			;   2  Vdd   5v supply  
76fb			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
76fb			;   4  RS    High = data, Low = instruction  
76fb			;   5  R/W   High = Read, Low = Write  
76fb			;   6  E     Enable signal (active high)  
76fb			;   7  DB0   Data bit 0  
76fb			;   8  DB1   Data bit 1  
76fb			;   9  DB2   Data bit 2  
76fb			;  10  DB3   Data bit 3  
76fb			;  11  DB4   Data bit 4  
76fb			;  12  DB5   Data bit 5  
76fb			;  13  DB6   Data bit 6  
76fb			;  14  DB7   Data bit 7  
76fb			;  15  A     Backlight anode (+)  
76fb			;  16  K     Backlight cathode (-)  
76fb			;  
76fb			; This interfacing method uses 4-bit data mode and uses time delays  
76fb			; rather than polling the display's ready status. As a result the   
76fb			; interface only requires 6 simple output lines:  
76fb			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
76fb			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
76fb			;   LCD DB4 = Microcomputer output port bit 4  
76fb			;   LCD DB5 = Microcomputer output port bit 5  
76fb			;   LCD DB6 = Microcomputer output port bit 6  
76fb			;   LCD DB7 = Microcomputer output port bit 7  
76fb			; Display's R/W is connected to 0v so it is always in write mode  
76fb			; All 6 connections must be on the same port address <kLCDPrt>  
76fb			; This method also allows a decent length of cable from micro to LCD  
76fb			;  
76fb			; **********************************************************************  
76fb			;  
76fb			; To include the code for any given function provided by this module,   
76fb			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
76fb			; the parent source file.  
76fb			; For example:  #REQUIRES   uHexPrefix  
76fb			;  
76fb			; Also #INCLUDE this file at some point after the #REQUIRES statements  
76fb			; in the parent source file.  
76fb			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
76fb			;  
76fb			; These are the function names provided by this module:  
76fb			; fLCD_Init                     ;Initialise LCD  
76fb			; fLCD_Inst                     ;Send instruction to LCD  
76fb			; fLCD_Data                     ;Send data byte to LCD  
76fb			; fLCD_Pos                      ;Position cursor  
76fb			; fLCD_Str                      ;Display string  
76fb			; fLCD_Def                      ;Define custom character  
76fb			;  
76fb			; **********************************************************************  
76fb			;  
76fb			; Requires SCMonAPI.asm to also be included in the project  
76fb			;  
76fb			  
76fb			  
76fb			; **********************************************************************  
76fb			; **  Constants  
76fb			; **********************************************************************  
76fb			  
76fb			; Constants that must be defined externally  
76fb			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
76fb			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
76fb			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
76fb			;kLCDWidth: EQU 20             ;Width in characters  
76fb			  
76fb			; general line offsets in any frame buffer  
76fb			  
76fb			  
76fb			display_row_1: equ 0  
76fb			display_row_2: equ display_row_1+display_cols  
76fb			display_row_3: equ display_row_2 + display_cols  
76fb			display_row_4: equ display_row_3 + display_cols  
76fb			;display_row_4_eol:   
76fb			  
76fb			  
76fb			; Cursor position values for the start of each line  
76fb			  
76fb			; E  
76fb			kLCD_Line1: EQU 0x00   
76fb			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
76fb			; E1  
76fb			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
76fb			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
76fb			  
76fb			; Instructions to send as A register to fLCD_Inst  
76fb			kLCD_Clear: EQU 00000001b     ;LCD clear  
76fb			kLCD_Off:   EQU 00001000b     ;LCD off  
76fb			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
76fb			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
76fb			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
76fb			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
76fb			  
76fb			; Constants used by this code module  
76fb			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
76fb			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
76fb			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
76fb			  
76fb			  
76fb			  
76fb			; **********************************************************************  
76fb			; **  LCD support functions  
76fb			; **********************************************************************  
76fb			  
76fb			; Initialise alphanumeric LCD module  
76fb			; LCD control register codes:  
76fb			;   DL   0 = 4-bit mode        1 = 8-bit mode  
76fb			;   N    0 = 1-line mode       1 = 2-line mode  
76fb			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
76fb			;   D    0 = Display off       1 = Display on  
76fb			;   C    0 = Cursor off        1 = Cursor on  
76fb			;   B    0 = Blinking off      1 = Blinking on  
76fb			;   ID   0 = Decrement mode    1 = Increment mode  
76fb			;   SH   0 = Entire shift off  1 = Entire shift on  
76fb 3e 28		fLCD_Init:  LD   A, 40  
76fd cd 22 78		            CALL LCDDelay       ;Delay 40ms after power up  
7700			; For reliable reset set 8-bit mode - 3 times  
7700 cd f2 77		            CALL WrFn8bit       ;Function = 8-bit mode  
7703 cd f2 77		            CALL WrFn8bit       ;Function = 8-bit mode  
7706 cd f2 77		            CALL WrFn8bit       ;Function = 8-bit mode  
7709			; Set 4-bit mode  
7709 cd ee 77		            CALL WrFn4bit       ;Function = 4-bit mode  
770c cd 20 78		            CALL LCDDelay1      ;Delay 37 us or more  
770f			; Function set  
770f 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7711 cd 24 77		            CALL fLCD_Inst      ;2 line, display on  
7714			; Display On/Off control  
7714 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7716 cd 24 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7719			; Display Clear  
7719 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
771b cd 24 77		            CALL fLCD_Inst      ;Clear display  
771e			; Entry mode  
771e 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7720 cd 24 77		            CALL fLCD_Inst      ;Increment mode, shift off  
7723			; Display module now initialised  
7723 c9			            RET  
7724			; ok to here  
7724			  
7724			; Write instruction to LCD  
7724			;   On entry: A = Instruction byte to be written  
7724			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7724 f5			fLCD_Inst:  PUSH AF  
7725 f5			            PUSH AF  
7726 cd 38 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7729 f1			            POP  AF  
772a 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
772b 17			            RLA  
772c 17			            RLA  
772d 17			            RLA  
772e cd 38 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7731 3e 02		            LD   A, 2  
7733 cd 22 78		            CALL LCDDelay       ;Delay 2 ms to complete   
7736 f1			            POP  AF  
7737 c9			            RET  
7738			Wr4bits:   
7738 f5					push af  
7739 3a c8 fb				ld a, (display_lcde1e2)  
773c fe 00				cp 0     ; e  
773e 20 10				jr nz, .wea2	  
7740 f1					pop af  
7741 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7743 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7745 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7747 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7749 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
774b cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
774d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
774f c9			            RET  
7750 f1			.wea2:		pop af  
7751 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7753 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7755 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7757 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7759 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
775b cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
775d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
775f c9			            RET  
7760			  
7760			  
7760			; Write data to LCD  
7760			;   On entry: A = Data byte to be written  
7760			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7760 f5			fLCD_Data:  PUSH AF  
7761 f5			            PUSH AF  
7762 cd 74 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7765 f1			            POP  AF  
7766 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7767 17			            RLA  
7768 17			            RLA  
7769 17			            RLA  
776a cd 74 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
776d 3e 96		            LD   A, 150  
776f 3d			Wait:      DEC  A              ;Wait a while to allow data   
7770 20 fd		            JR   NZ, Wait      ;  write to complete  
7772 f1			            POP  AF  
7773 c9			            RET  
7774			Wr4bitsa:     
7774 f5					push af  
7775 3a c8 fb				ld a, (display_lcde1e2)  
7778 fe 00				cp 0     ; e1  
777a 20 16				jr nz, .we2	  
777c f1					pop af  
777d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
777f cb d7		            SET  kLCDBitRS, A  
7781 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7783 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7785 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7787 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7789 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
778b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
778d cb 97		            RES  kLCDBitRS, A  
778f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7791 c9			            RET  
7792 f1			.we2:		pop af  
7793 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7795 cb d7		            SET  kLCDBitRS, A  
7797 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7799 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
779b cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
779d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
779f cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
77a1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77a3 cb 97		            RES  kLCDBitRS, A  
77a5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77a7 c9			            RET  
77a8			  
77a8			  
77a8			; Position cursor to specified location  
77a8			;   On entry: A = Cursor position  
77a8			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77a8 f5			fLCD_Pos:   PUSH AF  
77a9					; at this point set the E1 or E2 flag depending on position  
77a9			  
77a9 c5					push bc  
77aa			;		push af  
77aa 06 00				ld b, 0  
77ac 4f					ld c, a  
77ad 3e 4f				ld a, kLCD_Line3-1  
77af b7			 		or a      ;clear carry flag  
77b0 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
77b1 38 04				jr c, .pe1  
77b3			  
77b3					; E selection  
77b3 cb 80				res 0, b         ; bit 0 unset e  
77b5			;		pop af    ; before line 3 so recover orig pos  
77b5			;		ld c, a    ; save for poking back  
77b5 18 06				jr .peset	          
77b7			.pe1:          	; E2 selection  
77b7 cb c0				set 0, b         ; bit 0 set e1  
77b9 79					ld a, c  
77ba de 4f				sbc a, kLCD_Line3-1  
77bc 4f					ld c, a	         ; save caculated offset  
77bd			;		pop af     ; bin this original value now we have calculated form  
77bd			  
77bd			.peset:		; set bit  
77bd 78					ld a, b  
77be 32 c8 fb				ld (display_lcde1e2), a 	  
77c1 79					ld a, c  
77c2 c1					pop bc  
77c3			  
77c3 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
77c5 cd 24 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77c8 f1			            POP  AF  
77c9 c9			            RET  
77ca			  
77ca			  
77ca			; Output text string to LCD  
77ca			;   On entry: DE = Pointer to null terminated text string  
77ca			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
77ca 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
77cb b7			            OR   A              ;Null terminator?  
77cc c8			            RET  Z              ;Yes, so finished  
77cd cd 60 77		            CALL fLCD_Data      ;Write character to display  
77d0 13			            INC  DE             ;Point to next character  
77d1 18 f7		            JR   fLCD_Str       ;Repeat  
77d3 c9					ret  
77d4			  
77d4			; Define custom character  
77d4			;   On entry: A = Character number (0 to 7)  
77d4			;             DE = Pointer to character bitmap data  
77d4			;   On exit:  A = Next character number  
77d4			;             DE = Next location following bitmap  
77d4			;             BC HL IX IY I AF' BC' DE' HL' preserved  
77d4			; Character is   
77d4 c5			fLCD_Def:   PUSH BC  
77d5 f5			            PUSH AF  
77d6 07			            RLCA                ;Calculate location  
77d7 07			            RLCA                ;  for bitmap data  
77d8 07			            RLCA                ;  = 8 x CharacterNumber  
77d9 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
77db cd 24 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77de 06 00		            LD   B, 0  
77e0 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
77e1 cd 60 77		            CALL fLCD_Data      ;Write byte to display  
77e4 13			            INC  DE             ;Point to next byte  
77e5 04			            INC  B              ;Count bytes  
77e6 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
77e8 28 f6		            JR   Z, Loop       ;No, so repeat  
77ea f1			            POP  AF  
77eb 3c			            INC  A              ;Increment character number  
77ec c1			            POP  BC  
77ed c9			            RET  
77ee			  
77ee			  
77ee			; **********************************************************************  
77ee			; **  Private functions  
77ee			; **********************************************************************  
77ee			  
77ee			; Write function to LCD  
77ee			;   On entry: A = Function byte to be written  
77ee			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77ee 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
77f0 18 02		            JR   WrFunc  
77f2 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
77f4 f5			WrFunc:     PUSH AF  
77f5 f5					push af  
77f6 3a c8 fb				ld a, (display_lcde1e2)  
77f9 fe 00				cp 0     ; e1  
77fb 20 0f				jr nz, .wfea2	  
77fd f1					pop af  
77fe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7800 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7802 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7804 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7806 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7808 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
780a 18 0d			jr .wfskip  
780c f1			.wfea2:		pop af  
780d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
780f cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7811 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7813 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7815 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7817 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7819 3e 05		.wfskip:            LD  A, 5  
781b cd 22 78		            CALL LCDDelay       ;Delay 5 ms to complete  
781e f1			            POP  AF  
781f c9			            RET  
7820			  
7820			  
7820			; Delay in milliseconds  
7820			;   On entry: A = Number of milliseconds delay  
7820			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7820 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7822 d5			LCDDelay:   PUSH DE  
7823 5f			            LD   E, A           ;Delay by 'A' ms  
7824 16 00		            LD   D, 0  
7826 cd c4 0c		            CALL aDelayInMS  
7829 d1			            POP  DE  
782a c9			            RET  
782b			  
782b			  
782b			testlcd:  
782b 3e 00			ld a, kLCD_Line1  
782d cd a8 77			call fLCD_Pos  
7830 06 28			ld b, 40  
7832 11 60 78			ld de, .ttext1  
7835 cd f3 76			call write_len_string  
7838			  
7838 3e 28			ld a, kLCD_Line2  
783a cd a8 77			call fLCD_Pos  
783d 06 28			ld b, 40  
783f 11 89 78			ld de, .ttext2  
7842 cd f3 76			call write_len_string  
7845 3e 50			ld a, kLCD_Line3  
7847 cd a8 77			call fLCD_Pos  
784a 06 28			ld b, 40  
784c 11 b2 78			ld de, .ttext3  
784f cd f3 76			call write_len_string  
7852 3e 78			ld a, kLCD_Line4  
7854 cd a8 77			call fLCD_Pos  
7857 06 28			ld b, 40  
7859 11 db 78			ld de, .ttext4  
785c cd f3 76			call write_len_string  
785f			  
785f 76				halt  
7860			  
7860			  
7860 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7889 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
78b2 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
78db .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7904			   
7904			  
7904			  
7904			; eof  
7904			  
# End of file firmware_lcd_4x40.asm
7904			;include "firmware_lcd_4x20.asm" 
7904			include "firmware_key_5x10.asm" 
7904			; 5 x 10 decade counter scanner  
7904			  
7904			  
7904			; TODO do cursor shape change for shift keys  
7904			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7904			  
7904			  
7904			; bit mask for each scan column and row for teing the matrix  
7904			  
7904			  
7904			key_init:  
7904			  
7904			; SCMonAPI functions used  
7904			  
7904			; Alphanumeric LCD functions used  
7904			; no need to specify specific functions for this module  
7904			  
7904			  
7904 3e cf		            LD   A, 11001111b  
7906 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7908			;            LD   A, 00000000b  
7908 3e 1f		            LD   A, 00011111b  
790a d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
790c			  
790c			  
790c				; TODO Configure cursor shapes  
790c			  
790c				; Load cursor shapes   
790c 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
790e 11 1e 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7911 06 02		            LD   B, 2           ;Number of characters to define  
7913 cd d4 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7916 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7918			  
7918 3e 01				ld a, 1  
791a 32 be fb			ld (cursor_shape),a  
791d c9				ret  
791e			  
791e			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
791e			; Up to 8 custom characters can be defined  
791e			.cursor_shapes:      
791e			;; Character 0x00 = Normal  
791e 1f			            DB  11111b  
791f 1f			            DB  11111b  
7920 1f			            DB  11111b  
7921 1f			            DB  11111b  
7922 1f			            DB  11111b  
7923 1f			            DB  11111b  
7924 1f			            DB  11111b  
7925 1f			            DB  11111b  
7926			;; Character 0x01 = Modifier  
7926 1f			            DB  11111b  
7927 1b			            DB  11011b  
7928 1b			            DB  11011b  
7929 1b			            DB  11011b  
792a 1b			            DB  11011b  
792b 1f			            DB  11111b  
792c 1b			            DB  11011b  
792d 1f			            DB  11111b  
792e			  
792e			  
792e			  
792e			  
792e			; Display custom character 0  
792e			;            LD   A, kLCD_Line1+14  
792e			;            CALL fLCD_Pos       ;Position cursor to location in A  
792e			;            LD   A, 0  
792e			;            CALL fLCD_Data      ;Write character in A at cursor  
792e			  
792e			; Display custom character 1  
792e			;            LD   A, kLCD_Line2+14  
792e			;            CALL fLCD_Pos      ;Position cursor to location in A  
792e			;            LD   A, 1  
792e			;            CALL fLCD_Data     ;Write character in A at cursor  
792e			  
792e			; keyboard scanning   
792e			  
792e			; character in from keyboard  
792e			  
792e			; mapping for the pcb layout  
792e			  
792e			.matrix_to_char:  
792e .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7939 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7944 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
794f 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
795a .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7965			.matrix_to_shift:  
7965			  
7965 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7970 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
797b 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7986 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7991 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
799c			  
799c			.matrix_to_symbolshift:  
799c			  
799c fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
79a7 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
79b2 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
79bd			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
79bd 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
79c8 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
79d3			  
79d3			  
79d3			  
79d3			; mapping for a simple straight through breadboard layout  
79d3			  
79d3			;.matrix_to_char:  
79d3			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79d3			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
79d3			;		db "asdfghjkl",KEY_CR,0  
79d3			;		db "qwertyuiop",0  
79d3			;		 db "1234567890",0  
79d3			;.matrix_to_shift:  
79d3			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
79d3			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
79d3			;		db "ASDFGHJKL",KEY_CR,0  
79d3			;		db "QWERTYUIOP",0  
79d3			;		 db "!",'"',"#$%^&*()",0  
79d3			;.matrix_to_symbolshift:  
79d3			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79d3			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
79d3			;		db "_?*fghjk=",KEY_CR,0  
79d3			;		db "-/+*[]{}@#",0  
79d3			;		 db "1234567890",0  
79d3			  
79d3			;.matrix_to_char: db "D#0*C987B654A321"  
79d3			  
79d3			  
79d3				  
79d3			  
79d3			; add cin and cin_wait  
79d3			  
79d3 cd e4 79		cin_wait: 	call cin  
79d6						if DEBUG_KEYCINWAIT  
79d6							push af  
79d6							  
79d6							ld hl,key_repeat_ct  
79d6							ld (hl),a  
79d6							inc hl  
79d6							call hexout  
79d6							ld hl,key_repeat_ct+3  
79d6							ld a,0  
79d6							ld (hl),a  
79d6			  
79d6							    LD   A, kLCD_Line1+11  
79d6							    CALL fLCD_Pos       ;Position cursor to location in A  
79d6							    LD   DE, key_repeat_ct  
79d6							    ;LD   DE, MsgHello  
79d6							    CALL fLCD_Str       ;Display string pointed to by DE  
79d6			  
79d6			  
79d6			  
79d6							pop af  
79d6						endif  
79d6 fe 00			cp 0  
79d8 28 f9			jr z, cin_wait   ; block until key press  
79da			  
79da							if DEBUG_KEYCINWAIT  
79da								push af  
79da			  
79da								ld a, 'A'	  
79da								ld hl,key_repeat_ct  
79da								ld (hl),a  
79da								inc hl  
79da								ld a,0  
79da								ld (hl),a  
79da			  
79da								    LD   A, kLCD_Line2+11  
79da								    CALL fLCD_Pos       ;Position cursor to location in A  
79da								    LD   DE, key_repeat_ct  
79da								    ;LD   DE, MsgHello  
79da								    CALL fLCD_Str       ;Display string pointed to by DE  
79da			  
79da							call delay500ms  
79da			  
79da								pop af  
79da							endif  
79da f5				push af   ; save key pressed  
79db			  
79db			.cin_wait1:	  
79db							if DEBUG_KEYCINWAIT  
79db								push af  
79db			  
79db								ld a, 'b'	  
79db								ld hl,key_repeat_ct  
79db								ld (hl),a  
79db								inc hl  
79db								ld a,0  
79db								ld (hl),a  
79db			  
79db								    LD   A, kLCD_Line2+11  
79db								    CALL fLCD_Pos       ;Position cursor to location in A  
79db								    LD   DE, key_repeat_ct  
79db								    ;LD   DE, MsgHello  
79db								    CALL fLCD_Str       ;Display string pointed to by DE  
79db			  
79db			  
79db							call delay500ms  
79db			  
79db								pop af  
79db							endif  
79db			  
79db cd e4 79		call cin  
79de fe 00			cp 0  
79e0 20 f9			jr nz, .cin_wait1  	; wait for key release  
79e2			if DEBUG_KEYCINWAIT  
79e2				push af  
79e2			  
79e2				ld a, '3'	  
79e2				ld hl,key_repeat_ct  
79e2				ld (hl),a  
79e2				inc hl  
79e2				ld a,0  
79e2				ld (hl),a  
79e2			  
79e2			            LD   A, kLCD_Line2+11  
79e2			            CALL fLCD_Pos       ;Position cursor to location in A  
79e2			            LD   DE, key_repeat_ct  
79e2			            ;LD   DE, MsgHello  
79e2			            CALL fLCD_Str       ;Display string pointed to by DE  
79e2			  
79e2			  
79e2			call delay500ms  
79e2			  
79e2				pop af  
79e2			endif  
79e2			  
79e2 f1				pop af   ; get key  
79e3 c9				ret  
79e4			  
79e4			  
79e4 cd f8 79		cin: 	call .mtoc  
79e7			  
79e7			if DEBUG_KEYCIN  
79e7				push af  
79e7				  
79e7				ld hl,key_repeat_ct  
79e7				ld (hl),a  
79e7				inc hl  
79e7				call hexout  
79e7				ld hl,key_repeat_ct+3  
79e7				ld a,0  
79e7				ld (hl),a  
79e7			  
79e7			            LD   A, kLCD_Line3+15  
79e7			            CALL fLCD_Pos       ;Position cursor to location in A  
79e7			            LD   DE, key_repeat_ct  
79e7			            ;LD   DE, MsgHello  
79e7			            CALL fLCD_Str       ;Display string pointed to by DE  
79e7			  
79e7			  
79e7			call delay500ms  
79e7			  
79e7				pop af  
79e7			endif  
79e7			  
79e7			  
79e7				; no key held  
79e7 fe 00			cp 0  
79e9 c8				ret z  
79ea			  
79ea			if DEBUG_KEYCIN  
79ea				push af  
79ea			  
79ea				ld a, '1'	  
79ea				ld hl,key_repeat_ct  
79ea				ld (hl),a  
79ea				inc hl  
79ea				ld a,0  
79ea				ld (hl),a  
79ea			  
79ea			            LD   A, kLCD_Line4+15  
79ea			            CALL fLCD_Pos       ;Position cursor to location in A  
79ea			            LD   DE, key_repeat_ct  
79ea			            ;LD   DE, MsgHello  
79ea			            CALL fLCD_Str       ;Display string pointed to by DE  
79ea			  
79ea			  
79ea			call delay500ms  
79ea			  
79ea				pop af  
79ea			endif  
79ea			  
79ea				; stop key bounce  
79ea			  
79ea 32 88 fe			ld (key_held),a		 ; save it  
79ed 47				ld b, a  
79ee			  
79ee c5			.cina1:	push bc  
79ef			if DEBUG_KEYCIN  
79ef				push af  
79ef			  
79ef				ld hl,key_repeat_ct  
79ef				inc hl  
79ef				call hexout  
79ef				ld hl,key_repeat_ct+3  
79ef				ld a,0  
79ef				ld (hl),a  
79ef				ld hl,key_repeat_ct  
79ef				ld a, '2'	  
79ef				ld (hl),a  
79ef			  
79ef			            LD   A, kLCD_Line4+15  
79ef			            CALL fLCD_Pos       ;Position cursor to location in A  
79ef			            LD   DE, key_repeat_ct  
79ef			            ;LD   DE, MsgHello  
79ef			            CALL fLCD_Str       ;Display string pointed to by DE  
79ef			  
79ef				pop af  
79ef			endif  
79ef cd f8 79			call .mtoc  
79f2 c1				pop bc  
79f3 b8				cp b  
79f4 28 f8			jr z, .cina1  
79f6 78				ld a,b		  
79f7			if DEBUG_KEYCIN  
79f7				push af  
79f7			  
79f7				ld hl,key_repeat_ct  
79f7				inc hl  
79f7				call hexout  
79f7				ld hl,key_repeat_ct+3  
79f7				ld a,0  
79f7				ld (hl),a  
79f7				ld hl,key_repeat_ct  
79f7				ld a, '3'	  
79f7				ld (hl),a  
79f7			  
79f7			            LD   A, kLCD_Line4+15  
79f7			            CALL fLCD_Pos       ;Position cursor to location in A  
79f7			            LD   DE, key_repeat_ct  
79f7			            ;LD   DE, MsgHello  
79f7			            CALL fLCD_Str       ;Display string pointed to by DE  
79f7			  
79f7				pop af  
79f7			endif  
79f7 c9				ret  
79f8			  
79f8			; detect keyboard modifier key press and apply new overlay to the face key held  
79f8			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
79f8			  
79f8			;.cin_map_modifier:   
79f8			;	ld a, (hl)  
79f8			;	and 255  
79f8			;	ret NZ		; modifier key not flagged  
79f8			;  
79f8			;	; get key face  
79f8			;  
79f8			;	ld b,(key_face_held)  
79f8			;  
79f8			;	ld b, key_cols * key_rows  
79f8			;  
79f8			;	push de  
79f8			;	pop hl  
79f8			;  
79f8			;.mmod1: ld a,(hl)   ; get map test  
79f8			;	cp b  
79f8			;	jr z, .mmod2  
79f8			;  
79f8			;  
79f8			;  
79f8			;.mmod2: inc hl    ;   
79f8			;  
79f8			;	  
79f8			;  
79f8			;	  
79f8			;  
79f8			;	ld hl,key_actual_pressed  
79f8			;	ld (hl),a,  
79f8			;	ret  
79f8			  
79f8			; map matrix key held to char on face of key  
79f8			  
79f8			.mtoc:  
79f8			  
79f8			; test decade counter strobes  
79f8			  
79f8			;.decadetest1:  
79f8			  
79f8			; reset counter  
79f8			;ld a, 128  
79f8			;out (portbdata),a  
79f8			  
79f8			  
79f8			;ld b, 5  
79f8			;.dec1:  
79f8			;ld a, 0  
79f8			;out (portbdata),a  
79f8			;call delay1s  
79f8			  
79f8			;ld a, 32  
79f8			;out (portbdata),a  
79f8			;call delay1s  
79f8			;call delay1s  
79f8			;call delay1s  
79f8			;  
79f8			;ld a, 64+32  
79f8			;out (portbdata),a  
79f8			;call delay1s  
79f8			;;djnz .dec1  
79f8			;  
79f8			;jp .decadetest1  
79f8			  
79f8			  
79f8			  
79f8			  
79f8			  
79f8			  
79f8			  
79f8			  
79f8			  
79f8			  
79f8				; scan keyboard matrix and generate raw scan map  
79f8 cd 8b 7a			call matrix  
79fb			  
79fb				; reuse c bit 0 left modifer button - ie shift  
79fb			        ; reuse c bit 1 for right modifer button - ie symbol shift  
79fb				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
79fb			  
79fb 0e 00			ld c, 0  
79fd			  
79fd				; TODO set flags for modifer key presses   
79fd				; TODO do a search for modifer key...  
79fd			  
79fd				;ld hl,keyscan_table_row4  
79fd 21 e7 fe			ld hl,keyscan_table_row2  
7a00			  
7a00 7e				ld a, (hl)  
7a01 fe 23			cp '#'  
7a03 20 07			jr nz, .nextmodcheck  
7a05 cb c1			set 0, c  
7a07 21 65 79			ld hl, .matrix_to_shift  
7a0a 18 21			jr .dokeymap  
7a0c				; TODO for now igonre  
7a0c			.nextmodcheck:  
7a0c 21 dc fe			ld hl,keyscan_table_row3  
7a0f			  
7a0f 7e				ld a, (hl)  
7a10 fe 23			cp '#'  
7a12 20 07			jr nz, .nextmodcheck2  
7a14 cb c9			set 1, c   
7a16 21 9c 79			ld hl, .matrix_to_symbolshift  
7a19 18 12			jr .dokeymap  
7a1b			.nextmodcheck2:  
7a1b 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7a1e			  
7a1e 7e				ld a, (hl)  
7a1f fe 23			cp '#'  
7a21 20 07			jr nz, .donemodcheck  
7a23 cb c9			set 1, c   
7a25 21 65 79			ld hl, .matrix_to_shift  
7a28 18 03			jr .dokeymap  
7a2a			  
7a2a				; no modifer found so just map to normal keys  
7a2a				; get mtoc map matrix to respective keys  
7a2a			;	ld hl, .matrix_to_char  
7a2a			;	ld hl, .matrix_to_char  
7a2a			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a2a			;	ld a, KEY_SHIFT  
7a2a			;	call findchar  
7a2a			;  
7a2a			;	; got offset to key modifer in b  
7a2a			;  
7a2a			;	ld hl,keyscan_table_row5  
7a2a			;  
7a2a			;	ld a,b  
7a2a			;	call addatohl  
7a2a			;	ld a,(hl)  
7a2a			;  
7a2a			;	cp '#'  
7a2a			;	jr nz, .nextmodcheck  
7a2a			;	set 0, c  
7a2a			;	ld hl, .matrix_to_char  
7a2a			;	jr .dokeymap  
7a2a			;	; TODO for now igonre  
7a2a			;.nextmodcheck:  
7a2a			;	ld hl, .matrix_to_symbolshift  
7a2a			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a2a			;	ld a, KEY_SYMBOLSHIFT  
7a2a			;	call findchar  
7a2a			;  
7a2a			;  
7a2a			;	; got offset to key modifer in b  
7a2a			;  
7a2a			;	ld hl,keyscan_table_row5  
7a2a			;  
7a2a			;	ld a,b  
7a2a			;	call addatohl  
7a2a			;	ld a,(hl)  
7a2a			;  
7a2a			;	cp '#'  
7a2a			;	jr nz, .donemodcheck  
7a2a			;	set 1, c   
7a2a			;	ld hl, .matrix_to_symbolshift  
7a2a			;	jr .dokeymap  
7a2a			  
7a2a			  
7a2a			  
7a2a			.donemodcheck:  
7a2a				; no modifer found so just map to normal keys  
7a2a				; get mtoc map matrix to respective keys  
7a2a 21 2e 79			ld hl, .matrix_to_char  
7a2d			  
7a2d			.dokeymap:  
7a2d				;ld (key_fa), c   
7a2d cd 46 7a			call .mapkeys  
7a30			  
7a30			  
7a30			if DEBUG_KEY  
7a30			  
7a30			; Display text on first line  
7a30			            LD   A, kLCD_Line1  
7a30			            CALL fLCD_Pos       ;Position cursor to location in A  
7a30			            LD   DE, keyscan_table_row1  
7a30			            ;LD   DE, MsgHello  
7a30			            CALL fLCD_Str       ;Display string pointed to by DE  
7a30			  
7a30			; Display text on second line  
7a30			            LD   A, kLCD_Line2  
7a30			            CALL fLCD_Pos       ;Position cursor to location in A  
7a30			            LD   DE, keyscan_table_row2  
7a30			            CALL fLCD_Str       ;Display string pointed to by DE  
7a30			            LD   A, kLCD_Line3  
7a30			            CALL fLCD_Pos       ;Position cursor to location in A  
7a30			            LD   DE, keyscan_table_row3  
7a30			            CALL fLCD_Str       ;Display string pointed to by DE  
7a30			            LD   A, kLCD_Line4  
7a30			            CALL fLCD_Pos       ;Position cursor to location in A  
7a30			            LD   DE, keyscan_table_row4  
7a30			            CALL fLCD_Str       ;Display string pointed to by DE  
7a30			            LD   A, kLCD_Line1+10  
7a30			            CALL fLCD_Pos       ;Position cursor to location in A  
7a30			            LD   DE, keyscan_table_row5  
7a30			            CALL fLCD_Str       ;Display string pointed to by DE  
7a30			  
7a30				;call delay250ms  
7a30			endif  
7a30			;	jp testkey  
7a30			  
7a30			; get first char reported  
7a30			  
7a30 21 c6 fe			ld hl,keyscan_table_row5  
7a33			  
7a33				;ld b, 46   ; 30 keys to remap + 8 nulls   
7a33 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a35			.findkey:  
7a35 7e				ld a,(hl)  
7a36 fe 00			cp 0  
7a38 28 04			jr z, .nextkey  
7a3a fe 7e			cp KEY_MATRIX_NO_PRESS  
7a3c 20 06			jr nz, .foundkey  
7a3e			.nextkey:  
7a3e 23				inc hl  
7a3f 10 f4			djnz .findkey  
7a41 3e 00			ld a,0  
7a43 c9				ret  
7a44			.foundkey:  
7a44 7e				ld a,(hl)  
7a45 c9				ret  
7a46				  
7a46			  
7a46			; convert the raw key map given hl for destination key  
7a46			.mapkeys:  
7a46 11 c6 fe			ld de,keyscan_table_row5  
7a49			  
7a49 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a4b			.remap:  
7a4b 1a				ld a,(de)  
7a4c fe 23			cp '#'  
7a4e 20 02			jr nz, .remapnext  
7a50				;CALLMONITOR  
7a50 7e				ld a,(hl)  
7a51 12				ld (de),a  
7a52			  
7a52			  
7a52			  
7a52			.remapnext:  
7a52 23				inc hl  
7a53 13				inc de  
7a54 10 f5			djnz .remap  
7a56				  
7a56 c9				ret  
7a57			  
7a57			  
7a57			  
7a57			.mtocold2:  
7a57			  
7a57			;	; flag if key D is held down and remove from reporting  
7a57			;	ld bc, .key_map_fd    
7a57			;	ld hl, keyscan_table  
7a57			;	ld de, key_fd  
7a57			;	call .key_shift_hold  
7a57			;	cp 255  
7a57			;	jr z, .cinmap  
7a57			;	; flag if key C is held down and remove from reporting  
7a57			;	ld bc, .key_map_fc    
7a57			;	ld hl, keyscan_table+key_cols  
7a57			;	ld de, key_fc  
7a57			;	call .key_shift_hold  
7a57			;	cp 255  
7a57			;	jr z, .cinmap  
7a57			;	; flag if key B is held down and remove from reporting  
7a57			;	ld bc, .key_map_fb    
7a57			;	ld hl, keyscan_table+(key_cols*2)  
7a57			;	ld de, key_fb  
7a57			;	call .key_shift_hold  
7a57			;	cp 255  
7a57			;	jr z, .cinmap  
7a57			;	; flag if key A is held down and remove from reporting  
7a57			;	ld bc, .key_map_fa    
7a57			;	ld hl, keyscan_table+(key_cols*3)  
7a57			;	ld de, key_fa  
7a57			;	call .key_shift_hold  
7a57			;	cp 255  
7a57			;	jr z, .cinmap  
7a57			  
7a57 11 2e 79			ld de, .matrix_to_char  
7a5a			  
7a5a			  
7a5a			.cinmap1:   
7a5a				if DEBUG_KEY  
7a5a			            LD   A, kLCD_Line4  
7a5a			            CALL fLCD_Pos       ;Position cursor to location in A  
7a5a					push de  
7a5a			            LD   DE, keyscan_table  
7a5a			            CALL fLCD_Str       ;Display string pointed to by DE  
7a5a					pop de  
7a5a				endif  
7a5a			  
7a5a				; scan key matrix table for any held key  
7a5a			  
7a5a				; de holds either the default matrix or one selected above  
7a5a			  
7a5a 21 93 fe			ld hl, keyscan_table  
7a5d 06 32			ld b,key_cols*key_rows  
7a5f			  
7a5f 7e			.cin11:	ld a,(hl)  
7a60 fe 23			cp '#'  
7a62 28 08			jr z, .cinhit1  
7a64 23				inc hl  
7a65 13				inc de  
7a66 05				dec b  
7a67 20 f6			jr nz, .cin11  
7a69				; no key found held  
7a69 3e 00			ld a,0  
7a6b c9				ret  
7a6c d5			.cinhit1: push de  
7a6d e1				pop hl  
7a6e 7e				ld a,(hl)  
7a6f c9				ret  
7a70			  
7a70			; flag a control key is held   
7a70			; hl is key pin, de is flag indicator  
7a70			  
7a70			.key_shift_hold1:  
7a70 c5				push bc  
7a71 3e 01			ld a, 1  
7a73 32 be fb			ld (cursor_shape),a  
7a76 06 00			ld b, 0  
7a78 7e				ld a, (hl)  
7a79 fe 2e			cp '.'  
7a7b 28 0a			jr z, .key_shift11  
7a7d 06 ff			ld b, 255  
7a7f 3e 2b			ld a, '+'    ; hide key from later scans  
7a81 77				ld (hl),a  
7a82 3e 02			ld a, 2  
7a84 32 be fb			ld (cursor_shape),a  
7a87			.key_shift11:  
7a87				; write flag indicator  
7a87 78				ld a,b  
7a88 12				ld (de),a  
7a89			  
7a89 d1				pop de    ; de now holds the key map ptr  
7a8a c9				ret  
7a8b			  
7a8b				  
7a8b			  
7a8b			; scans keyboard matrix and flags key press in memory array	  
7a8b				  
7a8b			matrix:  
7a8b				;call matrix  
7a8b				; TODO optimise the code....  
7a8b			  
7a8b			  
7a8b			;ld hl, keyscan_table_row1  
7a8b			;ld de, keyscan_table_row1+1  
7a8b			;ld bc,46  
7a8b			;ld a,KEY_MATRIX_NO_PRESS  
7a8b			;ldir  
7a8b			  
7a8b			  
7a8b			  
7a8b			; reset counter  
7a8b 3e 80		ld a, 128  
7a8d d3 c1		out (portbdata),a  
7a8f			  
7a8f 06 0a		ld b, 10  
7a91 0e 00		ld c, 0       ; current clock toggle  
7a93			  
7a93			.colscan:  
7a93			  
7a93			; set current column  
7a93			; disable clock enable and set clock low  
7a93			  
7a93			;ld a, 0  
7a93			;out (portbdata),a  
7a93			  
7a93			; For each column scan for switches  
7a93			  
7a93 c5			push bc  
7a94 21 89 fe		ld hl, keyscan_scancol  
7a97 cd a0 7b		call .rowscan  
7a9a c1			pop bc  
7a9b			  
7a9b			  
7a9b			; get back current column  
7a9b			  
7a9b			; translate the row scan  
7a9b			  
7a9b			;   
7a9b			; row 1  
7a9b			  
7a9b 78			ld a,b  
7a9c			  
7a9c 21 fc fe		LD   hl, keyscan_table_row1+10  
7a9f			  
7a9f cd e2 0f		call subafromhl  
7aa2			;call addatohl  
7aa2			  
7aa2 11 89 fe		ld de, keyscan_scancol  
7aa5			  
7aa5 1a			ld a,(de)  
7aa6 77			ld (hl),a  
7aa7			  
7aa7			  
7aa7			  
7aa7			  
7aa7			; row 2  
7aa7			  
7aa7 78			ld a,b  
7aa8			  
7aa8 21 f1 fe		LD   hl, keyscan_table_row2+10  
7aab			  
7aab			;call addatohl  
7aab cd e2 0f		call subafromhl  
7aae			  
7aae			  
7aae 11 8a fe		ld de, keyscan_scancol+1  
7ab1			  
7ab1 1a			ld a,(de)  
7ab2 77			ld (hl),a  
7ab3			  
7ab3			  
7ab3			; row 3  
7ab3			  
7ab3 78			ld a,b  
7ab4			  
7ab4 21 e6 fe		LD   hl, keyscan_table_row3+10  
7ab7			  
7ab7			;call addatohl  
7ab7 cd e2 0f		call subafromhl  
7aba			  
7aba 11 8b fe		ld de, keyscan_scancol+2  
7abd			  
7abd 1a			ld a,(de)  
7abe 77			ld (hl),a  
7abf			  
7abf			  
7abf			  
7abf			; row 4  
7abf			  
7abf 78			ld a,b  
7ac0			  
7ac0 21 db fe		LD   hl, keyscan_table_row4+10  
7ac3			  
7ac3			;call addatohl  
7ac3 cd e2 0f		call subafromhl  
7ac6			  
7ac6 11 8c fe		ld de, keyscan_scancol+3  
7ac9			  
7ac9 1a			ld a,(de)  
7aca 77			ld (hl),a  
7acb			  
7acb			; row 5  
7acb			  
7acb 78			ld a,b  
7acc			  
7acc 21 d0 fe		LD   hl, keyscan_table_row5+10  
7acf			  
7acf			;call addatohl  
7acf cd e2 0f		call subafromhl  
7ad2			  
7ad2 11 8d fe		ld de, keyscan_scancol+4  
7ad5			  
7ad5 1a			ld a,(de)  
7ad6 77			ld (hl),a  
7ad7			  
7ad7			; handshake next column  
7ad7			  
7ad7			  
7ad7 3e 40		ld a, 64  
7ad9 d3 c1		out (portbdata),a  
7adb			  
7adb 3e 00		ld a, 0  
7add d3 c1		out (portbdata),a  
7adf			  
7adf			; toggle clk and move to next column  
7adf			;ld a, 64  
7adf			;cp c  
7adf			;  
7adf			;jr z, .coltoglow  
7adf			;ld c, a  
7adf			;jr .coltog  
7adf			;.coltoglow:  
7adf			;ld c, 0  
7adf			;.coltog:  
7adf			;ld a, c  
7adf			;out (portbdata),a  
7adf			  
7adf 10 b2		djnz .colscan  
7ae1			  
7ae1 3e 0a		ld a,10  
7ae3 21 f2 fe		LD   hl, keyscan_table_row1  
7ae6 cd d0 0f		call addatohl  
7ae9 3e 00		ld a, 0  
7aeb 77			ld (hl), a  
7aec			  
7aec			  
7aec 3e 0a		ld a,10  
7aee 21 e7 fe		LD   hl, keyscan_table_row2  
7af1 cd d0 0f		call addatohl  
7af4 3e 00		ld a, 0  
7af6 77			ld (hl), a  
7af7			  
7af7 3e 0a		ld a,10  
7af9 21 dc fe		LD   hl, keyscan_table_row3  
7afc cd d0 0f		call addatohl  
7aff 3e 00		ld a, 0  
7b01 77			ld (hl), a  
7b02			  
7b02 3e 0a		ld a,10  
7b04 21 d1 fe		LD   hl, keyscan_table_row4  
7b07 cd d0 0f		call addatohl  
7b0a 3e 00		ld a, 0  
7b0c 77			ld (hl), a  
7b0d			  
7b0d 3e 0a		ld a,10  
7b0f 21 c6 fe		LD   hl, keyscan_table_row5  
7b12 cd d0 0f		call addatohl  
7b15 3e 00		ld a, 0  
7b17 77			ld (hl), a  
7b18			  
7b18			if DEBUG_KEY_MATRIX  
7b18			  
7b18			; Display text on first line  
7b18			            LD   A, kLCD_Line1  
7b18			            CALL fLCD_Pos       ;Position cursor to location in A  
7b18			            LD   DE, keyscan_table_row1  
7b18			            ;LD   DE, MsgHello  
7b18			            CALL fLCD_Str       ;Display string pointed to by DE  
7b18			  
7b18			; Display text on second line  
7b18			            LD   A, kLCD_Line2  
7b18			            CALL fLCD_Pos       ;Position cursor to location in A  
7b18			            LD   DE, keyscan_table_row2  
7b18			            CALL fLCD_Str       ;Display string pointed to by DE  
7b18			            LD   A, kLCD_Line3  
7b18			            CALL fLCD_Pos       ;Position cursor to location in A  
7b18			            LD   DE, keyscan_table_row3  
7b18			            CALL fLCD_Str       ;Display string pointed to by DE  
7b18			            LD   A, kLCD_Line4  
7b18			            CALL fLCD_Pos       ;Position cursor to location in A  
7b18			            LD   DE, keyscan_table_row4  
7b18			            CALL fLCD_Str       ;Display string pointed to by DE  
7b18			            LD   A, kLCD_Line4+10  
7b18			            CALL fLCD_Pos       ;Position cursor to location in A  
7b18			            LD   DE, keyscan_table_row5  
7b18			            CALL fLCD_Str       ;Display string pointed to by DE  
7b18			  
7b18			;call delay250ms  
7b18				jp matrix  
7b18			endif  
7b18 c9			ret  
7b19			  
7b19			; using decade counter....  
7b19			  
7b19			  
7b19			; TODO reset decade counter to start of scan  
7b19			  
7b19			; reset 15  
7b19			; clock 14  
7b19			; ce 13  
7b19			  
7b19			; 1 - q5  
7b19			; 2 - q1  
7b19			; 3 - q0  
7b19			; 4 - q2  
7b19			; 5 - q6  
7b19			; 6 - q7  
7b19			; 7 - q3  
7b19			; 8 - vss  
7b19			; 9 - q8  
7b19			; 10 - q4  
7b19			; 11 - q9  
7b19			; 12 - cout  
7b19			; 16 - vdd  
7b19			  
7b19			; clock      ce       reset     output  
7b19			; 0          x        0         n  
7b19			; x          1        0         n  
7b19			; x          x        1         q0  
7b19			; rising     0        0         n+1  
7b19			; falling    x        0         n  
7b19			; x          rising   0         n  
7b19			; 1          falling  0         x+1  
7b19			;  
7b19			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b19			  
7b19			;   
7b19			; reset   
7b19			; 13=0, 14=0, 15=1 .. 15=0  
7b19			;  
7b19			; handshake line  
7b19			; 14=1.... read line 14=0  
7b19			  
7b19			  
7b19			  
7b19			  
7b19			  
7b19			; TODO hand shake clock for next column scan  
7b19			; TODO detect each row  
7b19			  
7b19			  
7b19			  
7b19			  
7b19			; reset 128  
7b19			; clock 64  
7b19			; ce 32  
7b19			  
7b19			  
7b19			.cyclestart:  
7b19			  
7b19			; reset counter  
7b19 3e 80		ld a, 128  
7b1b d3 c1		out (portbdata),a  
7b1d			  
7b1d			; loop leds  
7b1d 06 0a		ld b,10  
7b1f			  
7b1f			.cycle1:  
7b1f c5			push bc  
7b20 3e 00		ld a, 0  
7b22 d3 c1		out (portbdata),a  
7b24 cd d3 0c		call delay250ms  
7b27			  
7b27 3e 40		ld a, 64  
7b29 d3 c1		out (portbdata),a  
7b2b cd d3 0c		call delay250ms  
7b2e			  
7b2e 3e 00		ld a, 0  
7b30 d3 c1		out (portbdata),a  
7b32 cd d3 0c		call delay250ms  
7b35			  
7b35 c1			pop bc  
7b36 10 e7		djnz .cycle1  
7b38			  
7b38			  
7b38 18 df		jr .cyclestart  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			; map matrix key held to char on face of key  
7b3a			  
7b3a			;.mtocold:  
7b3a			;  
7b3a			;  
7b3a			;; reset counter  
7b3a			;ld a, 128  
7b3a			;out (portbdata),a  
7b3a			;  
7b3a			;  
7b3a			;; scan keyboard row 1  
7b3a			;ld a, 0  
7b3a			;out (portbdata),a  
7b3a			;;ld a, 64  
7b3a			;;out (portbdata),a  
7b3a			;  
7b3a			;  
7b3a			;	ld a, 128  
7b3a			;	ld hl, keyscan_table  
7b3a			;	call .rowscan  
7b3a			;  
7b3a			;;ld a, 0  
7b3a			;;out (portbdata),a  
7b3a			;ld a, 64  
7b3a			;out (portbdata),a  
7b3a			;  
7b3a			;	ld a, 64  
7b3a			;	ld hl, keyscan_table+key_cols  
7b3a			;	call .rowscan  
7b3a			;  
7b3a			;ld a, 0  
7b3a			;out (portbdata),a  
7b3a			;;ld a, 64  
7b3a			;;out (portbdata),a  
7b3a			;	ld a, 32  
7b3a			;	ld hl, keyscan_table+(key_cols*2)  
7b3a			;	call .rowscan  
7b3a			;  
7b3a			;  
7b3a			;;ld a, 0  
7b3a			;;out (portbdata),a  
7b3a			;ld a, 64  
7b3a			;out (portbdata),a  
7b3a			;  
7b3a			;	ld a, 16  
7b3a			;	ld hl, keyscan_table+(key_cols*3)  
7b3a			;	call .rowscan  
7b3a			;  
7b3a			;  
7b3a			;	; flag if key D is held down and remove from reporting  
7b3a			;	ld bc, .key_map_fd    
7b3a			;	ld hl, keyscan_table  
7b3a			;	ld de, key_fd  
7b3a			;	call .key_shift_hold  
7b3a			;	cp 255  
7b3a			;	jr z, .cinmap  
7b3a			;	; flag if key C is held down and remove from reporting  
7b3a			;	ld bc, .key_map_fc    
7b3a			;	ld hl, keyscan_table+key_cols  
7b3a			;	ld de, key_fc  
7b3a			;	call .key_shift_hold  
7b3a			;	cp 255  
7b3a			;	jr z, .cinmap  
7b3a			;	; flag if key B is held down and remove from reporting  
7b3a			;	ld bc, .key_map_fb    
7b3a			;	ld hl, keyscan_table+(key_cols*2)  
7b3a			;	ld de, key_fb  
7b3a			;	call .key_shift_hold  
7b3a			;	cp 255  
7b3a			;	jr z, .cinmap  
7b3a			;	; flag if key A is held down and remove from reporting  
7b3a			;	ld bc, .key_map_fa    
7b3a			;	ld hl, keyscan_table+(key_cols*3)  
7b3a			;	ld de, key_fa  
7b3a			;	call .key_shift_hold  
7b3a			;	cp 255  
7b3a			;	jr z, .cinmap  
7b3a			;  
7b3a			;	ld de, .matrix_to_char  
7b3a			;  
7b3a			;  
7b3a			;.cinmap:   
7b3a			;	if DEBUG_KEY  
7b3a			;            LD   A, kLCD_Line4  
7b3a			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b3a			;		push de  
7b3a			;            LD   DE, keyscan_table  
7b3a			;            CALL fLCD_Str       ;Display string pointed to by DE  
7b3a			;		pop de  
7b3a			;	endif  
7b3a			  
7b3a				; scan key matrix table for any held key  
7b3a			  
7b3a				; de holds either the default matrix or one selected above  
7b3a			  
7b3a			;	ld hl, keyscan_table  
7b3a			;	ld b,key_cols*key_rows  
7b3a			;  
7b3a			;.cin1:	ld a,(hl)  
7b3a			;	cp '#'  
7b3a			;	jr z, .cinhit  
7b3a			;	inc hl  
7b3a			;	inc de  
7b3a			;	dec b  
7b3a			;	jr nz, .cin1  
7b3a			;	; no key found held  
7b3a			;	ld a,0  
7b3a			;	ret  
7b3a			;.cinhit: push de  
7b3a			;	pop hl  
7b3a			;	ld a,(hl)  
7b3a			;	ret  
7b3a			  
7b3a			; flag a control key is held   
7b3a			; hl is key pin, de is flag indicator  
7b3a			  
7b3a			;.key_shift_hold:  
7b3a			;	push bc  
7b3a			;	ld a, 1  
7b3a			;	ld (cursor_shape),a  
7b3a			;	ld b, 0  
7b3a			;	ld a, (hl)  
7b3a			;	cp '.'  
7b3a			;	jr z, .key_shift1  
7b3a			;	ld b, 255  
7b3a			;	ld a, '+'    ; hide key from later scans  
7b3a			;	ld (hl),a  
7b3a			;	ld a, 2  
7b3a			;	ld (cursor_shape),a  
7b3a			;.key_shift1:  
7b3a			;	; write flag indicator  
7b3a			;	ld a,b  
7b3a			;	ld (de),a  
7b3a			;  
7b3a			;	pop de    ; de now holds the key map ptr  
7b3a			;	ret  
7b3a			  
7b3a				  
7b3a				  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			;	push hl  
7b3a			;	push de  
7b3a			;	push bc  
7b3a			;	call keyscan  
7b3a			;	; map key matrix to ascii value of key face  
7b3a			;  
7b3a			;	ld hl, key_face_map  
7b3a			;	ld de, keyscan_table  
7b3a			;  
7b3a			;	; get how many keys to look at  
7b3a			;	ld b, keyscan_table_len  
7b3a			;	  
7b3a			;  
7b3a			;	; at this stage fall out on first key hit  
7b3a			;	; TODO handle multiple key press  
7b3a			;  
7b3a			;map1:	ld a,(hl)  
7b3a			;	cp '#'  
7b3a			;	jr z, keyhit  
7b3a			;	inc hl  
7b3a			;	inc de  
7b3a			;	dec b  
7b3a			;	jr nz, map1  
7b3a			;nohit:	ld a, 0  
7b3a			;	jr keydone  
7b3a			;keyhit: push de  
7b3a			;	pop hl  
7b3a			;	ld a,(hl)  
7b3a			;keydone:  
7b3a			;	push bc  
7b3a			;	push de  
7b3a			; 	push hl  
7b3a			;	ret   
7b3a			;  
7b3a			  
7b3a			  
7b3a			  
7b3a			  
7b3a			; scan physical key matrix  
7b3a			  
7b3a			  
7b3a			;keyscan:  
7b3a			;  
7b3a			;; for each key_row use keyscanr bit mask for out  
7b3a			;; then read in for keyscanc bitmask  
7b3a			;; save result of row scan to keyscantable  
7b3a			;  
7b3a			;; scan keyboard row 1  
7b3a			;  
7b3a			;	ld b, key_rows  
7b3a			;	ld hl, key_scanr  
7b3a			;	ld de, keyscan_table  
7b3a			;  
7b3a			;rowloop:  
7b3a			;  
7b3a			;	ld a,(hl)		; out bit mask to energise keyboard row  
7b3a			;	call rowscan  
7b3a			;	inc hl  
7b3a			;	dec b  
7b3a			;	jr nz, rowloop  
7b3a			;  
7b3a			;	ret  
7b3a			;  
7b3a			;  
7b3a			;; pass a out bitmask, b row number  
7b3a			;arowscan:   
7b3a			;	push bc  
7b3a			;  
7b3a			;	ld d, b  
7b3a			;  
7b3a			;	; calculate buffer location for this row  
7b3a			;  
7b3a			;	ld hl, keyscan_table	  
7b3a			;kbufr:  ld e, key_cols  
7b3a			;kbufc:	inc hl  
7b3a			;	dec e  
7b3a			;	jr nz, kbufc  
7b3a			;	dec d  
7b3a			;	jr nz, kbufr  
7b3a			;  
7b3a			;	; energise row and read columns  
7b3a			;  
7b3a			;	out (portbdata),a  
7b3a			;	in a,(portbdata)  
7b3a			;	ld c,a  
7b3a			;  
7b3a			;  
7b3a			;	; save buffer loc  
7b3a			;  
7b3a			;	ld (keybufptr), hl  
7b3a			;  
7b3a			;	ld hl, key_scanc  
7b3a			;	ld d, key_cols  
7b3a			;  
7b3a			;	; for each column check each bit mask  
7b3a			;  
7b3a			;colloop:  
7b3a			;	  
7b3a			;  
7b3a			;	; reset flags for the row   
7b3a			;  
7b3a			;	ld b,'.'  
7b3a			;	and (hl)  
7b3a			;	jr z, maskskip  
7b3a			;	ld b,'#'  
7b3a			;maskskip:  
7b3a			;	; save  key state  
7b3a			;	push hl  
7b3a			;	ld hl, (keybufptr)  
7b3a			;	ld (hl), b  
7b3a			;	inc hl  
7b3a			;	ld (keybufptr), hl  
7b3a			;  
7b3a			;	; move to next bit mask  
7b3a			;	pop hl  
7b3a			;	inc hl  
7b3a			;  
7b3a			;	dec d  
7b3a			;	jr nz, colloop  
7b3a			;  
7b3a			;	ret  
7b3a			;  
7b3a			;  
7b3a			;;  
7b3a			; lcd functions  
7b3a			;  
7b3a			;  
7b3a			  
7b3a			;if DEBUG_KEY_MATRIX  
7b3a			  
7b3a			; test function to display hardware view of matrix state  
7b3a			  
7b3a			matrixold:  
7b3a			  
7b3a			  
7b3a			  
7b3a			; reset counter  
7b3a 3e 80		ld a, 128  
7b3c d3 c1		out (portbdata),a  
7b3e			; scan keyboard row 1  
7b3e 3e 00		ld a, 0  
7b40 d3 c1		out (portbdata),a  
7b42			;ld a, 64  
7b42			;out (portbdata),a  
7b42 3e 80			ld a, 128  
7b44 21 f2 fe			ld hl, keyscan_table_row1  
7b47 cd a0 7b			call .rowscan  
7b4a			  
7b4a			;ld a, 0  
7b4a			;out (portbdata),a  
7b4a 3e 40		ld a, 64  
7b4c d3 c1		out (portbdata),a  
7b4e 3e 40			ld a, 64  
7b50 21 e7 fe			ld hl, keyscan_table_row2  
7b53 cd a0 7b			call .rowscan  
7b56			  
7b56 3e 00		ld a, 0  
7b58 d3 c1		out (portbdata),a  
7b5a			;ld a, 64  
7b5a			;out (portbdata),a  
7b5a 3e 20			ld a, 32  
7b5c 21 dc fe			ld hl, keyscan_table_row3  
7b5f cd a0 7b			call .rowscan  
7b62			  
7b62			;ld a, 0  
7b62			;out (portbdata),a  
7b62 3e 40		ld a, 64  
7b64 d3 c1		out (portbdata),a  
7b66 3e 10			ld a, 16  
7b68 21 d1 fe			ld hl, keyscan_table_row4  
7b6b cd a0 7b			call .rowscan  
7b6e			  
7b6e			; Display text on first line  
7b6e 3e 00		            LD   A, kLCD_Line1  
7b70 cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b73 11 f2 fe		            LD   DE, keyscan_table_row1  
7b76			            ;LD   DE, MsgHello  
7b76 cd ca 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b79			  
7b79			; Display text on second line  
7b79 3e 28		            LD   A, kLCD_Line2  
7b7b cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b7e 11 e7 fe		            LD   DE, keyscan_table_row2  
7b81 cd ca 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b84 3e 50		            LD   A, kLCD_Line3  
7b86 cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b89 11 dc fe		            LD   DE, keyscan_table_row3  
7b8c cd ca 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b8f 3e 78		            LD   A, kLCD_Line4  
7b91 cd a8 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b94 11 d1 fe		            LD   DE, keyscan_table_row4  
7b97 cd ca 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b9a			  
7b9a cd d3 0c			call delay250ms  
7b9d c3 8b 7a			jp matrix  
7ba0			  
7ba0			; pass de as row display flags  
7ba0			.rowscan:   
7ba0			;	out (portbdata),a  
7ba0 db c1			in a,(portbdata)  
7ba2 4f				ld c,a  
7ba3				; reset flags for the row   
7ba3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ba5 e6 01			and 1  
7ba7 28 02			jr z, .p1on  
7ba9 06 23			ld b,'#'  
7bab			.p1on:  
7bab 70				ld (hl), b  
7bac 23				inc hl  
7bad			  
7bad 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7baf 79				ld a,c  
7bb0 e6 02			and 2  
7bb2			;	bit 0,a  
7bb2 28 02			jr z, .p2on  
7bb4 06 23			ld b,'#'  
7bb6			.p2on:  
7bb6 70				ld (hl), b  
7bb7 23				inc hl  
7bb8			;  
7bb8 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bba 79				ld a,c  
7bbb e6 04			and 4  
7bbd			;;	bit 0,a  
7bbd 28 02			jr z, .p3on  
7bbf 06 23			ld b,'#'  
7bc1			.p3on:  
7bc1 70				ld (hl), b  
7bc2 23				inc hl  
7bc3			;;  
7bc3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bc5			;;	bit 0,a  
7bc5 79				ld a,c  
7bc6 e6 08			and 8  
7bc8 28 02			jr z, .p4on  
7bca 06 23			ld b,'#'  
7bcc			.p4on:  
7bcc 70				ld (hl), b  
7bcd 23				inc hl  
7bce			  
7bce 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bd0			;;	bit 0,a  
7bd0 79				ld a,c  
7bd1 e6 10			and 16  
7bd3 28 02			jr z, .p5on  
7bd5 06 23			ld b,'#'  
7bd7			.p5on:  
7bd7 70				ld (hl), b  
7bd8 23				inc hl  
7bd9			; zero term  
7bd9 06 00			ld b,0  
7bdb 70				ld (hl), b  
7bdc			  
7bdc c9			.rscandone: ret  
7bdd			  
7bdd			;addatohl:  
7bdd			;  
7bdd			 ;add   a, l    ; A = A+L  
7bdd			  ;  ld    l, a    ; L = A+L  
7bdd			   ; adc   a, h    ; A = A+L+H+carry  
7bdd			   ; sub   l       ; A = H+carry  
7bdd			   ; ld    h, a    ; H = H+carry  
7bdd			  
7bdd			;ret  
7bdd			; eof  
# End of file firmware_key_5x10.asm
7bdd			;include "firmware_key_4x10.asm" 
7bdd			 
7bdd			heap_size:    equ heap_end - heap_start 
7bdd			;eof 
# End of file os_mega.asm
7bdd
