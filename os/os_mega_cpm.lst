# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 c3 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-09-10 20:01' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
011f			  
011f			debug_umark: equ parse_vector - 6  ; current user mark  
011f			debug_mark: equ debug_umark - 4    ; internal word debug points  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 07 ed				ld hl, display_fb1  
0122 22 c3 eb				ld (display_fb_active), hl  
0125			  
0125 cd b7 0b				call clear_display  
0128			  
0128 21 c5 eb				ld hl, display_fb2  
012b 22 c3 eb				ld (display_fb_active), hl  
012e			  
012e cd b7 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 a8 ed				ld hl, display_fb0  
0134 22 c3 eb				ld (display_fb_active), hl  
0137			  
0137 cd b7 0b				call clear_display  
013a			  
013a			  
013a cd bd 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd ab 65			call key_init  
0140 cd ad 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd 89 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd d9 0b			call update_display  
0149 cd f0 0a			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd bc 0b			call fill_display  
0151 cd d9 0b			call update_display  
0154 cd f0 0a			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd bc 0b			call fill_display  
015c cd d9 0b			call update_display  
015f cd f0 0a			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd bc 0b			call fill_display  
0167 cd d9 0b			call update_display  
016a cd f0 0a			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 30 16			ld de, prom_bootmsg  
0172 cd c9 0b			call str_at_display  
0175 cd d9 0b			call update_display  
0178			  
0178			  
0178 cd f0 0a			call delay1s  
017b cd f0 0a			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 45 16			ld de, prom_bootmsg1  
0183 cd c9 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd c9 0b			call str_at_display  
018e			  
018e cd d9 0b			call update_display  
0191 cd f0 0a			call delay1s  
0194 cd f0 0a			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 62 ee		ld (debug_mark),a  
019c 32 63 ee		ld (debug_mark+1),a  
019f 32 64 ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 65 ee		ld (debug_mark+3),a  
01a7 32 66 ee		ld (debug_umark),a  
01aa			  
01aa c9					ret  
01ab			  
01ab			  
01ab			;bootmsg2:	db "Firmware v0.1",0  
01ab			  
01ab			; a 4x20 lcd  
01ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ab			  
01ab			;if display_cols == 20  
01ab			;	include "firmware_lcd_4x20.asm"  
01ab			;endif  
01ab			  
01ab			;if display_cols == 40  
01ab			;	include "firmware_lcd_4x40.asm"  
01ab			;endif  
01ab			  
01ab			;  
01ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ab			; TODO abstract the bit bang video out interface for dual display  
01ab			; TODO wire video out to tx pin on rc2014 bus  
01ab			  
01ab			; must supply cin, and cin_wait for low level hardware abstraction   
01ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ab			; test scancode  
01ab			  
01ab			;;;;;  
01ab			;;;  
01ab			; Moved out to mini and maxi versions  
01ab			;  
01ab			; include "firmware_key_4x4.asm"  
01ab			; using existing 4 wire x 4 resistor array for input  
01ab			;include "firmware_key_4x10.asm"  
01ab			; need to mod the board for 5 rows due to resistor array  
01ab			;include "firmware_key_5x10.asm"  
01ab			  
01ab			; storage hardware interface  
01ab			  
01ab			; use microchip serial eeprom for storage  
01ab			  
01ab			  
01ab			if STORAGE_SE  
01ab				include "firmware_spi.asm"  
01ab				include "firmware_seeprom.asm"  
01ab			else  
01ab			   ; create some stubs for the labels  
01ab c9			se_readbyte: ret  
01ac c9			se_writebyte: ret  
01ad c9			storage_init: ret  
01ae			  
01ae			endif  
01ae			  
01ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ae			;include "firmware_cf.asm"  
01ae			  
01ae			; load up high level storage hardward abstractions  
01ae			include "firmware_storage.asm"  
01ae			 
01ae			; persisent storage hardware abstraction layer  
01ae			 
01ae			 
01ae			 
01ae			; Block 0 on storage is a config state 
01ae			 
01ae			 
01ae			 
01ae			; TODO add read phy block and write phy block functions 
01ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ae			 
01ae			; Abstraction layer  
01ae			 
01ae			; Logocial block size is same size as physical size - using tape concept 
01ae			 
01ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ae			 
01ae			 
01ae			 
01ae			; Filesystem layout (Logical layout) 
01ae			; 
01ae			; Block 0 - Bank config  
01ae			; 
01ae			;      Byte - 0 file id counter 
01ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ae			;      Byte - 3-20 zero terminated bank label 
01ae			; 
01ae			; Block 1 > File storage 
01ae			; 
01ae			;      Byte 0 file id    - block 0 file details 
01ae			;      Byte 1 block id - block 0 is file  
01ae			;            Byte 2-15 - File name 
01ae			; 
01ae			;       - to end of block data 
01ae			; 
01ae			 
01ae			; Get ID for the file named in pointer held HL 
01ae			; Returns ID in HL = 255 if no file found 
01ae			 
01ae			storage_getid: 
01ae			 
01ae 22 6a ea			ld (store_tmp1), hl 
01b1			 
01b1				if DEBUG_STORESE 
01b1					DMARK "SGI" 
01b1 f5				push af  
01b2 3a c6 01			ld a, (.dmark)  
01b5 32 62 ee			ld (debug_mark),a  
01b8 3a c7 01			ld a, (.dmark+1)  
01bb 32 63 ee			ld (debug_mark+1),a  
01be 3a c8 01			ld a, (.dmark+2)  
01c1 32 64 ee			ld (debug_mark+2),a  
01c4 18 03			jr .pastdmark  
01c6 ..			.dmark: db "SGI"  
01c9 f1			.pastdmark: pop af  
01ca			endm  
# End of macro DMARK
01ca					CALLMONITOR 
01ca cd 6f ee			call debug_vector  
01cd				endm  
# End of macro CALLMONITOR
01cd				endif 
01cd				; get block 0 and set counter for number of files to scan 
01cd			 
01cd cd 35 03			call storage_get_block_0 
01d0			 
01d0 3a 71 ea			ld a, (store_page) 
01d3 47				ld b, a 
01d4			 
01d4				; get extent 0 of each file id 
01d4			 
01d4				if DEBUG_STORESE 
01d4					DMARK "SGc" 
01d4 f5				push af  
01d5 3a e9 01			ld a, (.dmark)  
01d8 32 62 ee			ld (debug_mark),a  
01db 3a ea 01			ld a, (.dmark+1)  
01de 32 63 ee			ld (debug_mark+1),a  
01e1 3a eb 01			ld a, (.dmark+2)  
01e4 32 64 ee			ld (debug_mark+2),a  
01e7 18 03			jr .pastdmark  
01e9 ..			.dmark: db "SGc"  
01ec f1			.pastdmark: pop af  
01ed			endm  
# End of macro DMARK
01ed					CALLMONITOR 
01ed cd 6f ee			call debug_vector  
01f0				endm  
# End of macro CALLMONITOR
01f0				endif 
01f0 60			.getloop:	ld h, b 
01f1 2e 00				ld l, 0 
01f3 c5					push bc 
01f4			 
01f4 11 71 ea				ld de, store_page 
01f7				if DEBUG_STORESE 
01f7					DMARK "SGr" 
01f7 f5				push af  
01f8 3a 0c 02			ld a, (.dmark)  
01fb 32 62 ee			ld (debug_mark),a  
01fe 3a 0d 02			ld a, (.dmark+1)  
0201 32 63 ee			ld (debug_mark+1),a  
0204 3a 0e 02			ld a, (.dmark+2)  
0207 32 64 ee			ld (debug_mark+2),a  
020a 18 03			jr .pastdmark  
020c ..			.dmark: db "SGr"  
020f f1			.pastdmark: pop af  
0210			endm  
# End of macro DMARK
0210					CALLMONITOR 
0210 cd 6f ee			call debug_vector  
0213				endm  
# End of macro CALLMONITOR
0213				endif 
0213 cd d7 07				call storage_read 
0216 cd 0a 0e				call ishlzero 
0219 28 2d				jr z, .gap 
021b					 
021b					; have a file name read. Is it one we want. 
021b			 
021b 2a 6a ea				ld hl, (store_tmp1) 
021e 11 74 ea				ld de, store_page+3   ; file name 
0221			 
0221				if DEBUG_STORESE 
0221					DMARK "SGc" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 62 ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 63 ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 64 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGc"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 6f ee			call debug_vector  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d cd 71 11				call strcmp 
0240 20 06				jr nz, .gap   ; not this one 
0242			 
0242 c1				        pop bc 
0243			 
0243 26 00				ld h, 0 
0245 68					ld l, b 
0246 18 22				jr .getdone 
0248						 
0248			 
0248			 
0248			 
0248			.gap: 
0248				if DEBUG_STORESE 
0248					DMARK "SGg" 
0248 f5				push af  
0249 3a 5d 02			ld a, (.dmark)  
024c 32 62 ee			ld (debug_mark),a  
024f 3a 5e 02			ld a, (.dmark+1)  
0252 32 63 ee			ld (debug_mark+1),a  
0255 3a 5f 02			ld a, (.dmark+2)  
0258 32 64 ee			ld (debug_mark+2),a  
025b 18 03			jr .pastdmark  
025d ..			.dmark: db "SGg"  
0260 f1			.pastdmark: pop af  
0261			endm  
# End of macro DMARK
0261					CALLMONITOR 
0261 cd 6f ee			call debug_vector  
0264				endm  
# End of macro CALLMONITOR
0264				endif 
0264			 
0264 c1					pop bc 
0265 10 89				djnz .getloop 
0267 21 ff 00				ld hl, 255 
026a			.getdone: 
026a			 
026a				if DEBUG_STORESE 
026a					DMARK "SGe" 
026a f5				push af  
026b 3a 7f 02			ld a, (.dmark)  
026e 32 62 ee			ld (debug_mark),a  
0271 3a 80 02			ld a, (.dmark+1)  
0274 32 63 ee			ld (debug_mark+1),a  
0277 3a 81 02			ld a, (.dmark+2)  
027a 32 64 ee			ld (debug_mark+2),a  
027d 18 03			jr .pastdmark  
027f ..			.dmark: db "SGe"  
0282 f1			.pastdmark: pop af  
0283			endm  
# End of macro DMARK
0283					CALLMONITOR 
0283 cd 6f ee			call debug_vector  
0286				endm  
# End of macro CALLMONITOR
0286				endif 
0286			 
0286 c9				ret 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			; Read Block 
0287			; ---------- 
0287			; 
0287			; With current bank 
0287			;  
0287			; Get block number to read 
0287			; Load physical blocks starting at start block into buffer 
0287			 
0287			; de points to buffer to use 
0287			; hl holds logical block number  
0287			 
0287			storage_read_block: 
0287			 
0287				; TODO bank selection 
0287			 
0287				; for each of the physical blocks read it into the buffer 
0287 06 40			ld b, STORE_BLOCK_PHY 
0289			 
0289				if DEBUG_STORESE 
0289 d5					push de 
028a				endif 
028a				 
028a			.rl1:    
028a			 
028a				; read physical block at hl into de 
028a			        ; increment hl and de to next read position on exit 
028a			 
028a e5				push hl 
028b d5				push de	 
028c c5				push bc 
028d			;	if DEBUG_STORESE 
028d			;		push af 
028d			;		ld a, 'R' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d cd ab 01			call se_readbyte 
0290			;	if DEBUG_STORESE 
0290			;		ld a,(spi_portbyte) 
0290			;		ld l, a 
0290			;		push af 
0290			;		ld a, '1' 
0290			;		ld (debug_mark),a 
0290			;		pop af 
0290			;		CALLMONITOR 
0290			;	endif 
0290 c1				pop bc 
0291 d1				pop de 
0292 e1				pop hl 
0293 12				ld (de),a 
0294 23				inc hl 
0295 13				inc de 
0296			 
0296			;	if DEBUG_STORESE 
0296			;		push af 
0296			;		ld a, 'r' 
0296			;		ld (debug_mark),a 
0296			;		pop af 
0296			;		CALLMONITOR 
0296			;	endif 
0296			 
0296 10 f2			djnz .rl1 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SRB" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 62 ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 63 ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 64 ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SRB"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1 d1					pop de 
02b2			; 
02b2			;		push af 
02b2			;		ld a, 'R' 
02b2			;		ld (debug_mark),a 
02b2			;		pop af 
02b2					CALLMONITOR 
02b2 cd 6f ee			call debug_vector  
02b5				endm  
# End of macro CALLMONITOR
02b5				endif 
02b5 c9				ret	 
02b6				 
02b6			 
02b6			; File Size 
02b6			; --------- 
02b6			; 
02b6			;   hl file id 
02b6			; 
02b6			;  returns in hl the number of blocks 
02b6			 
02b6			storage_file_size: 
02b6 5d				ld e, l 
02b7 16 00			ld d, 0 
02b9 21 40 00			ld hl, STORE_BLOCK_PHY 
02bc					if DEBUG_FORTH_WORDS 
02bc						DMARK "SIZ" 
02bc f5				push af  
02bd 3a d1 02			ld a, (.dmark)  
02c0 32 62 ee			ld (debug_mark),a  
02c3 3a d2 02			ld a, (.dmark+1)  
02c6 32 63 ee			ld (debug_mark+1),a  
02c9 3a d3 02			ld a, (.dmark+2)  
02cc 32 64 ee			ld (debug_mark+2),a  
02cf 18 03			jr .pastdmark  
02d1 ..			.dmark: db "SIZ"  
02d4 f1			.pastdmark: pop af  
02d5			endm  
# End of macro DMARK
02d5						CALLMONITOR 
02d5 cd 6f ee			call debug_vector  
02d8				endm  
# End of macro CALLMONITOR
02d8					endif 
02d8 cd b3 05			call storage_findnextid 
02db			 
02db cd 0a 0e			call ishlzero 
02de			;	ld a, l 
02de			;	add h 
02de			;	cp 0 
02de c8				ret z			; block not found so EOF 
02df			 
02df 11 71 ea			ld de, store_page 
02e2 cd 87 02			call storage_read_block 
02e5			 
02e5 3a 73 ea			ld a, (store_page+2)	 ; get extent count 
02e8 6f				ld l, a 
02e9 26 00			ld h, 0 
02eb c9			 	ret 
02ec			 
02ec			 
02ec			; Write Block 
02ec			; ----------- 
02ec			; 
02ec			; With current bank 
02ec			;  
02ec			; Get block number to write 
02ec			; Write physical blocks starting at start block from buffer 
02ec			  
02ec			storage_write_block: 
02ec				; TODO bank selection 
02ec			 
02ec				; for each of the physical blocks read it into the buffer 
02ec 06 40			ld b, STORE_BLOCK_PHY 
02ee			 
02ee				if DEBUG_STORESE 
02ee					DMARK "SWB" 
02ee f5				push af  
02ef 3a 03 03			ld a, (.dmark)  
02f2 32 62 ee			ld (debug_mark),a  
02f5 3a 04 03			ld a, (.dmark+1)  
02f8 32 63 ee			ld (debug_mark+1),a  
02fb 3a 05 03			ld a, (.dmark+2)  
02fe 32 64 ee			ld (debug_mark+2),a  
0301 18 03			jr .pastdmark  
0303 ..			.dmark: db "SWB"  
0306 f1			.pastdmark: pop af  
0307			endm  
# End of macro DMARK
0307			 
0307					;push af 
0307					;ld a, 'W' 
0307					;ld (debug_mark),a 
0307					;pop af 
0307					CALLMONITOR 
0307 cd 6f ee			call debug_vector  
030a				endm  
# End of macro CALLMONITOR
030a				endif 
030a			 
030a			; might not be working 
030a			;	call se_writepage 
030a			 
030a			;	ret 
030a			; 
030a			 
030a			 
030a			 
030a			.wl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d 1a				ld a,(de) 
030e				;if DEBUG_STORESE 
030e			;		push af 
030e			;		ld a, 'W' 
030e			;		ld (debug_mark),a 
030e			;		pop af 
030e			;		CALLMONITOR 
030e			;	endif 
030e cd ac 01			call se_writebyte 
0311			;	call delay250ms 
0311			;	nop 
0311			;	nop 
0311			;	nop 
0311			;	if DEBUG_STORESE 
0311			;		push af 
0311			;		ld a, 'w' 
0311			;		ld (debug_mark),a 
0311			;		pop af 
0311			;		CALLMONITOR 
0311			;	endif 
0311 c1				pop bc 
0312 d1				pop de 
0313 e1				pop hl 
0314 23				inc hl 
0315 13				inc de 
0316			 
0316			 
0316 10 f2			djnz .wl1 
0318			 
0318				if DEBUG_STORESE 
0318					DMARK "SW2" 
0318 f5				push af  
0319 3a 2d 03			ld a, (.dmark)  
031c 32 62 ee			ld (debug_mark),a  
031f 3a 2e 03			ld a, (.dmark+1)  
0322 32 63 ee			ld (debug_mark+1),a  
0325 3a 2f 03			ld a, (.dmark+2)  
0328 32 64 ee			ld (debug_mark+2),a  
032b 18 03			jr .pastdmark  
032d ..			.dmark: db "SW2"  
0330 f1			.pastdmark: pop af  
0331			endm  
# End of macro DMARK
0331			 
0331					;push af 
0331					;ld a, 'W' 
0331					;ld (debug_mark),a 
0331					;pop af 
0331					CALLMONITOR 
0331 cd 6f ee			call debug_vector  
0334				endm  
# End of macro CALLMONITOR
0334				endif 
0334 c9				ret	 
0335			 
0335			; Init bank 
0335			; --------- 
0335			; 
0335			; With current bank 
0335			; 
0335			; Setup block 0 config 
0335			;     Set 0 file id counter 
0335			;     Set formatted byte pattern 
0335			;     Zero out bank label 
0335			;      
0335			; For every logical block write 0-1 byte as null 
0335			 
0335			storage_get_block_0: 
0335			 
0335				; TODO check presence 
0335			 
0335				; get block 0 config 
0335			 
0335 21 00 00			ld hl, 0 
0338 11 71 ea			ld de, store_page 
033b cd 87 02			call storage_read_block 
033e			 
033e				if DEBUG_STORESE 
033e					DMARK "SB0" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 62 ee			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 63 ee			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 64 ee			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SB0"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357 11 71 ea				ld de, store_page 
035a			;		push af 
035a			;		ld a, 'i' 
035a			;		ld (debug_mark),a 
035a			;		pop af 
035a					CALLMONITOR 
035a cd 6f ee			call debug_vector  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d			 
035d				; is this area formatted? 
035d			 
035d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
035d 2a 72 ea			ld hl, (store_page+1) 
0360 3e 80			ld a,0x80 
0362 bd				cp l 
0363 20 22			jr nz, .ininotformatted 
0365				; do a double check 
0365 3e 27			ld a, 0x27 
0367 bc				cp h 
0368 20 1d			jr nz, .ininotformatted 
036a			 
036a				; formatted then 
036a			 
036a				if DEBUG_STORESE 
036a					DMARK "SB1" 
036a f5				push af  
036b 3a 7f 03			ld a, (.dmark)  
036e 32 62 ee			ld (debug_mark),a  
0371 3a 80 03			ld a, (.dmark+1)  
0374 32 63 ee			ld (debug_mark+1),a  
0377 3a 81 03			ld a, (.dmark+2)  
037a 32 64 ee			ld (debug_mark+2),a  
037d 18 03			jr .pastdmark  
037f ..			.dmark: db "SB1"  
0382 f1			.pastdmark: pop af  
0383			endm  
# End of macro DMARK
0383					;push af 
0383					;ld a, 'I' 
0383					;ld (debug_mark),a 
0383					;pop af 
0383					CALLMONITOR 
0383 cd 6f ee			call debug_vector  
0386				endm  
# End of macro CALLMONITOR
0386				endif 
0386 c9				ret 
0387			 
0387			.ininotformatted: 
0387				; bank not formatted so poke various bits to make sure 
0387			 
0387				if DEBUG_STORESE 
0387					DMARK "SB2" 
0387 f5				push af  
0388 3a 9c 03			ld a, (.dmark)  
038b 32 62 ee			ld (debug_mark),a  
038e 3a 9d 03			ld a, (.dmark+1)  
0391 32 63 ee			ld (debug_mark+1),a  
0394 3a 9e 03			ld a, (.dmark+2)  
0397 32 64 ee			ld (debug_mark+2),a  
039a 18 03			jr .pastdmark  
039c ..			.dmark: db "SB2"  
039f f1			.pastdmark: pop af  
03a0			endm  
# End of macro DMARK
03a0					;push af 
03a0					;ld a, 'f' 
03a0					;ld (debug_mark),a 
03a0					;pop af 
03a0					CALLMONITOR 
03a0 cd 6f ee			call debug_vector  
03a3				endm  
# End of macro CALLMONITOR
03a3				endif 
03a3			 
03a3 cd b4 0a			call storage_clear_page 
03a6			 
03a6 21 71 ea			ld hl, store_page 
03a9			;	ld a, 0 
03a9				 
03a9 36 00			ld (hl),0   ; reset file counter 
03ab			 
03ab 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03ae 22 72 ea		 	ld (store_page+1), hl	 
03b1			 
03b1				; set default label 
03b1			 
03b1 21 4a 04			ld hl, .defaultbanklabl 
03b4 11 74 ea		 	ld de, store_page+3 
03b7 01 0f 00			ld bc, 15 
03ba ed b0			ldir 
03bc			 
03bc				; Append the current bank id 
03bc 21 7d ea			ld hl, store_page+3+9 
03bf 3a 56 ea			ld a, (spi_device_id) 
03c2 77				ld (hl), a 
03c3			 
03c3				; save default page 0 
03c3			 
03c3 21 00 00			ld hl, 0 
03c6 11 71 ea			ld de, store_page 
03c9				if DEBUG_STORESE 
03c9					DMARK "SB3" 
03c9 f5				push af  
03ca 3a de 03			ld a, (.dmark)  
03cd 32 62 ee			ld (debug_mark),a  
03d0 3a df 03			ld a, (.dmark+1)  
03d3 32 63 ee			ld (debug_mark+1),a  
03d6 3a e0 03			ld a, (.dmark+2)  
03d9 32 64 ee			ld (debug_mark+2),a  
03dc 18 03			jr .pastdmark  
03de ..			.dmark: db "SB3"  
03e1 f1			.pastdmark: pop af  
03e2			endm  
# End of macro DMARK
03e2			;		push af 
03e2			;		ld a, 'F' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 6f ee			call debug_vector  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5 cd ec 02			call storage_write_block 
03e8				if DEBUG_STORESE 
03e8					DMARK "SB4" 
03e8 f5				push af  
03e9 3a fd 03			ld a, (.dmark)  
03ec 32 62 ee			ld (debug_mark),a  
03ef 3a fe 03			ld a, (.dmark+1)  
03f2 32 63 ee			ld (debug_mark+1),a  
03f5 3a ff 03			ld a, (.dmark+2)  
03f8 32 64 ee			ld (debug_mark+2),a  
03fb 18 03			jr .pastdmark  
03fd ..			.dmark: db "SB4"  
0400 f1			.pastdmark: pop af  
0401			endm  
# End of macro DMARK
0401			;		push af 
0401			;		ld a, '>' 
0401			;		ld (debug_mark),a 
0401			;		pop af 
0401					CALLMONITOR 
0401 cd 6f ee			call debug_vector  
0404				endm  
# End of macro CALLMONITOR
0404				endif 
0404			 
0404			;	nop 
0404			;	nop 
0404			;	nop 
0404			 
0404				; now set 0 in every page to mark as a free block 
0404			 
0404 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0406 21 40 00			ld hl, STORE_BLOCK_PHY 
0409			 
0409 3e 00		.setmark1:   	ld a,0 
040b e5					push hl 
040c c5					push bc 
040d cd ac 01				call se_writebyte 
0410 3e 0a			ld a, 10 
0412 cd d5 0a			call aDelayInMS 
0415 23				inc hl 
0416 cd ac 01				call se_writebyte 
0419 3e 0a			ld a, 10 
041b cd d5 0a			call aDelayInMS 
041e 2b				dec hl 
041f c1					pop bc 
0420 e1					pop hl 
0421 3e 40				ld a, STORE_BLOCK_PHY 
0423 cd e1 0d				call addatohl 
0426 10 e1				djnz .setmark1 
0428			 
0428 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
042a 3e 00		.setmark2:   	ld a,0 
042c e5					push hl 
042d c5					push bc 
042e cd ac 01				call se_writebyte 
0431 3e 0a			ld a, 10 
0433 cd d5 0a			call aDelayInMS 
0436 23				inc hl 
0437 cd ac 01				call se_writebyte 
043a 3e 0a			ld a, 10 
043c cd d5 0a			call aDelayInMS 
043f 2b				dec hl 
0440 c1					pop bc 
0441 e1					pop hl 
0442 3e 40				ld a, STORE_BLOCK_PHY 
0444 cd e1 0d				call addatohl 
0447 10 e1				djnz .setmark2 
0449			 
0449					 
0449			 
0449			 
0449 c9				ret 
044a			 
044a			 
044a			 
044a			 
044a .. 00		.defaultbanklabl:   db "BankLabel_",0 
0455			 
0455			 
0455			 
0455			; Label Bank 
0455			; ---------- 
0455			; 
0455			; With current bank 
0455			; Read block 0 
0455			; Set label 
0455			; Write block 0 
0455			 
0455			; label str pointer in hl 
0455			 
0455			storage_label:     
0455			 
0455				if DEBUG_STORESE 
0455					DMARK "LBL" 
0455 f5				push af  
0456 3a 6a 04			ld a, (.dmark)  
0459 32 62 ee			ld (debug_mark),a  
045c 3a 6b 04			ld a, (.dmark+1)  
045f 32 63 ee			ld (debug_mark+1),a  
0462 3a 6c 04			ld a, (.dmark+2)  
0465 32 64 ee			ld (debug_mark+2),a  
0468 18 03			jr .pastdmark  
046a ..			.dmark: db "LBL"  
046d f1			.pastdmark: pop af  
046e			endm  
# End of macro DMARK
046e					CALLMONITOR 
046e cd 6f ee			call debug_vector  
0471				endm  
# End of macro CALLMONITOR
0471				endif 
0471			 
0471 e5				push hl 
0472			 
0472 cd 35 03			call storage_get_block_0 
0475			 
0475				; set default label 
0475			 
0475 e1				pop hl 
0476			 
0476 11 74 ea		 	ld de, store_page+3 
0479 01 0f 00			ld bc, 15 
047c				if DEBUG_STORESE 
047c					DMARK "LB3" 
047c f5				push af  
047d 3a 91 04			ld a, (.dmark)  
0480 32 62 ee			ld (debug_mark),a  
0483 3a 92 04			ld a, (.dmark+1)  
0486 32 63 ee			ld (debug_mark+1),a  
0489 3a 93 04			ld a, (.dmark+2)  
048c 32 64 ee			ld (debug_mark+2),a  
048f 18 03			jr .pastdmark  
0491 ..			.dmark: db "LB3"  
0494 f1			.pastdmark: pop af  
0495			endm  
# End of macro DMARK
0495					CALLMONITOR 
0495 cd 6f ee			call debug_vector  
0498				endm  
# End of macro CALLMONITOR
0498				endif 
0498 ed b0			ldir 
049a				; save default page 0 
049a			 
049a 21 00 00			ld hl, 0 
049d 11 71 ea			ld de, store_page 
04a0				if DEBUG_STORESE 
04a0					DMARK "LBW" 
04a0 f5				push af  
04a1 3a b5 04			ld a, (.dmark)  
04a4 32 62 ee			ld (debug_mark),a  
04a7 3a b6 04			ld a, (.dmark+1)  
04aa 32 63 ee			ld (debug_mark+1),a  
04ad 3a b7 04			ld a, (.dmark+2)  
04b0 32 64 ee			ld (debug_mark+2),a  
04b3 18 03			jr .pastdmark  
04b5 ..			.dmark: db "LBW"  
04b8 f1			.pastdmark: pop af  
04b9			endm  
# End of macro DMARK
04b9					CALLMONITOR 
04b9 cd 6f ee			call debug_vector  
04bc				endm  
# End of macro CALLMONITOR
04bc				endif 
04bc cd ec 02			call storage_write_block 
04bf			 
04bf c9				ret 
04c0			 
04c0			 
04c0			 
04c0			; Read Block 0 - Config 
04c0			; --------------------- 
04c0			; 
04c0			; With current bank 
04c0			; Call presence test 
04c0			;    If not present format/init bank  
04c0			; Read block 0  
04c0			;  
04c0			 
04c0			 
04c0			; Dir 
04c0			; --- 
04c0			; 
04c0			; With current bank 
04c0			; Load Block 0 Config 
04c0			; Get max file id number 
04c0			; For each logical block 
04c0			;    Read block read byte 2 
04c0			;      if first block of file 
04c0			;         Display file name 
04c0			;         Display type flags for file 
04c0			;        
04c0			 
04c0			; moving to words as this requires stack control 
04c0			 
04c0			 
04c0			; Delete File 
04c0			; ----------- 
04c0			; 
04c0			; With current bank 
04c0			; 
04c0			; Load Block 0 Config 
04c0			; Get max file id number 
04c0			; For each logical block 
04c0			;    Read block file id 
04c0			;      If first block of file and dont have file id 
04c0			;         if file to delete 
04c0			;         Save file id 
04c0			;         Null file id 
04c0			;         Write this block back 
04c0			;      If file id is one saved 
04c0			;         Null file id 
04c0			;         Write this block back 
04c0			 
04c0			 
04c0			.se_done: 
04c0 e1				pop hl 
04c1 c9				ret 
04c2			 
04c2			storage_erase: 
04c2			 
04c2				; hl contains the file id 
04c2			 
04c2 5d				ld e, l 
04c3 16 00			ld d, 0 
04c5 21 40 00			ld hl, STORE_BLOCK_PHY 
04c8					if DEBUG_FORTH_WORDS 
04c8						DMARK "ERA" 
04c8 f5				push af  
04c9 3a dd 04			ld a, (.dmark)  
04cc 32 62 ee			ld (debug_mark),a  
04cf 3a de 04			ld a, (.dmark+1)  
04d2 32 63 ee			ld (debug_mark+1),a  
04d5 3a df 04			ld a, (.dmark+2)  
04d8 32 64 ee			ld (debug_mark+2),a  
04db 18 03			jr .pastdmark  
04dd ..			.dmark: db "ERA"  
04e0 f1			.pastdmark: pop af  
04e1			endm  
# End of macro DMARK
04e1						CALLMONITOR 
04e1 cd 6f ee			call debug_vector  
04e4				endm  
# End of macro CALLMONITOR
04e4					endif 
04e4 cd b3 05			call storage_findnextid 
04e7 cd 0a 0e			call ishlzero 
04ea c8				ret z 
04eb			 
04eb e5				push hl 
04ec			 
04ec				; TODO check file not found 
04ec			 
04ec 11 71 ea			ld de, store_page 
04ef cd 87 02			call storage_read_block 
04f2			 
04f2 cd 0a 0e			call ishlzero 
04f5 ca c0 04			jp z,.se_done 
04f8			 
04f8					if DEBUG_FORTH_WORDS 
04f8						DMARK "ER1" 
04f8 f5				push af  
04f9 3a 0d 05			ld a, (.dmark)  
04fc 32 62 ee			ld (debug_mark),a  
04ff 3a 0e 05			ld a, (.dmark+1)  
0502 32 63 ee			ld (debug_mark+1),a  
0505 3a 0f 05			ld a, (.dmark+2)  
0508 32 64 ee			ld (debug_mark+2),a  
050b 18 03			jr .pastdmark  
050d ..			.dmark: db "ER1"  
0510 f1			.pastdmark: pop af  
0511			endm  
# End of macro DMARK
0511						CALLMONITOR 
0511 cd 6f ee			call debug_vector  
0514				endm  
# End of macro CALLMONITOR
0514					endif 
0514 3a 71 ea			ld a, (store_page)	; get file id 
0517 32 65 ea			ld (store_tmpid), a 
051a			 
051a 3a 73 ea			ld a, (store_page+2)    ; get count of extends 
051d 32 64 ea			ld (store_tmpext), a 
0520			 
0520				; wipe file header 
0520			 
0520 e1				pop hl 
0521 3e 00			ld a, 0 
0523 32 71 ea			ld (store_page), a 
0526 32 72 ea			ld (store_page+1),a 
0529 11 71 ea			ld de, store_page 
052c					if DEBUG_FORTH_WORDS 
052c						DMARK "ER2" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 62 ee			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 63 ee			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 64 ee			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "ER2"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545						CALLMONITOR 
0545 cd 6f ee			call debug_vector  
0548				endm  
# End of macro CALLMONITOR
0548					endif 
0548 cd ec 02			call storage_write_block 
054b			 
054b			 
054b				; wipe file extents 
054b			 
054b 3a 64 ea			ld a, (store_tmpext) 
054e 47				ld b, a 
054f			 
054f			.eraext:	  
054f c5				push bc 
0550			 
0550 21 40 00			ld hl, STORE_BLOCK_PHY 
0553 3a 65 ea			ld a,(store_tmpid) 
0556 5f				ld e, a 
0557 50				ld d, b	 
0558					if DEBUG_FORTH_WORDS 
0558						DMARK "ER3" 
0558 f5				push af  
0559 3a 6d 05			ld a, (.dmark)  
055c 32 62 ee			ld (debug_mark),a  
055f 3a 6e 05			ld a, (.dmark+1)  
0562 32 63 ee			ld (debug_mark+1),a  
0565 3a 6f 05			ld a, (.dmark+2)  
0568 32 64 ee			ld (debug_mark+2),a  
056b 18 03			jr .pastdmark  
056d ..			.dmark: db "ER3"  
0570 f1			.pastdmark: pop af  
0571			endm  
# End of macro DMARK
0571						CALLMONITOR 
0571 cd 6f ee			call debug_vector  
0574				endm  
# End of macro CALLMONITOR
0574					endif 
0574 cd b3 05			call storage_findnextid 
0577 cd 0a 0e			call ishlzero 
057a ca c0 04			jp z,.se_done 
057d			 
057d e5				push hl 
057e 11 71 ea			ld de, store_page 
0581 cd 87 02			call storage_read_block 
0584			 
0584				; free block	 
0584			 
0584 3e 00			ld a, 0 
0586 32 71 ea			ld (store_page), a 
0589 32 72 ea			ld (store_page+1),a 
058c 11 71 ea			ld de, store_page 
058f e1				pop hl 
0590					if DEBUG_FORTH_WORDS 
0590						DMARK "ER4" 
0590 f5				push af  
0591 3a a5 05			ld a, (.dmark)  
0594 32 62 ee			ld (debug_mark),a  
0597 3a a6 05			ld a, (.dmark+1)  
059a 32 63 ee			ld (debug_mark+1),a  
059d 3a a7 05			ld a, (.dmark+2)  
05a0 32 64 ee			ld (debug_mark+2),a  
05a3 18 03			jr .pastdmark  
05a5 ..			.dmark: db "ER4"  
05a8 f1			.pastdmark: pop af  
05a9			endm  
# End of macro DMARK
05a9						CALLMONITOR 
05a9 cd 6f ee			call debug_vector  
05ac				endm  
# End of macro CALLMONITOR
05ac					endif 
05ac cd ec 02			call storage_write_block 
05af			 
05af c1				pop bc 
05b0 10 9d			djnz .eraext 
05b2			 
05b2 c9				ret 
05b3			 
05b3			 
05b3			; Find Free Block 
05b3			; --------------- 
05b3			; 
05b3			; With current bank 
05b3			;  
05b3			; From given starting logical block 
05b3			;    Read block  
05b3			;    If no file id 
05b3			;         Return block id 
05b3			 
05b3			 
05b3			; hl starting page number 
05b3			; hl contains free page number or zero if no pages free 
05b3			; e contains the file id to locate 
05b3			; d contains the block number 
05b3			 
05b3			; TODO change to find file id and use zero for free block 
05b3			 
05b3			storage_findnextid: 
05b3			 
05b3				; now locate first 0 page to mark as a free block 
05b3			 
05b3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05b5			;	ld hl, STORE_BLOCK_PHY 
05b5			 
05b5					if DEBUG_FORTH_WORDS 
05b5					DMARK "FNI" 
05b5 f5				push af  
05b6 3a ca 05			ld a, (.dmark)  
05b9 32 62 ee			ld (debug_mark),a  
05bc 3a cb 05			ld a, (.dmark+1)  
05bf 32 63 ee			ld (debug_mark+1),a  
05c2 3a cc 05			ld a, (.dmark+2)  
05c5 32 64 ee			ld (debug_mark+2),a  
05c8 18 03			jr .pastdmark  
05ca ..			.dmark: db "FNI"  
05cd f1			.pastdmark: pop af  
05ce			endm  
# End of macro DMARK
05ce						CALLMONITOR 
05ce cd 6f ee			call debug_vector  
05d1				endm  
# End of macro CALLMONITOR
05d1					endif 
05d1			.ff1:   	 
05d1 e5					push hl 
05d2 c5					push bc 
05d3 d5					push de 
05d4 cd ab 01				call se_readbyte 
05d7 5f					ld e,a 
05d8 23					inc hl 
05d9 cd ab 01				call se_readbyte 
05dc 57					ld d, a 
05dd e1					pop hl 
05de e5					push hl 
05df cd ff 0d				call cmp16 
05e2 28 49				jr z, .fffound 
05e4			 
05e4 d1					pop de 
05e5 c1					pop bc 
05e6 e1					pop hl 
05e7			 
05e7					; is found? 
05e7					;cp e 
05e7					;ret z 
05e7			 
05e7 3e 40				ld a, STORE_BLOCK_PHY 
05e9 cd e1 0d				call addatohl 
05ec 10 e3				djnz .ff1 
05ee			 
05ee 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f0			.ff2:   	 
05f0			 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 d5					push de 
05f3 cd ab 01				call se_readbyte 
05f6 5f					ld e,a 
05f7 23					inc hl 
05f8 cd ab 01				call se_readbyte 
05fb 57					ld d, a 
05fc			 
05fc e1					pop hl 
05fd e5					push hl 
05fe cd ff 0d				call cmp16 
0601 28 2a				jr z, .fffound 
0603			 
0603 d1					pop de 
0604 c1					pop bc 
0605 e1					pop hl 
0606					; is found? 
0606					;cp e 
0606					;ret z 
0606			 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd e1 0d				call addatohl 
060b 10 e3				djnz .ff2 
060d			 
060d			 
060d					if DEBUG_FORTH_WORDS 
060d					DMARK "FN-" 
060d f5				push af  
060e 3a 22 06			ld a, (.dmark)  
0611 32 62 ee			ld (debug_mark),a  
0614 3a 23 06			ld a, (.dmark+1)  
0617 32 63 ee			ld (debug_mark+1),a  
061a 3a 24 06			ld a, (.dmark+2)  
061d 32 64 ee			ld (debug_mark+2),a  
0620 18 03			jr .pastdmark  
0622 ..			.dmark: db "FN-"  
0625 f1			.pastdmark: pop af  
0626			endm  
# End of macro DMARK
0626					;	push af 
0626					;	ld a, 'n' 
0626					;	ld (debug_mark),a 
0626					;	pop af 
0626						CALLMONITOR 
0626 cd 6f ee			call debug_vector  
0629				endm  
# End of macro CALLMONITOR
0629					endif 
0629				; no free marks! 
0629 21 00 00				ld hl, 0 
062c c9				ret 
062d			.fffound: 
062d				 
062d			 
062d d1					pop de 
062e c1					pop bc 
062f e1					pop hl 
0630					if DEBUG_FORTH_WORDS 
0630					DMARK "FNF" 
0630 f5				push af  
0631 3a 45 06			ld a, (.dmark)  
0634 32 62 ee			ld (debug_mark),a  
0637 3a 46 06			ld a, (.dmark+1)  
063a 32 63 ee			ld (debug_mark+1),a  
063d 3a 47 06			ld a, (.dmark+2)  
0640 32 64 ee			ld (debug_mark+2),a  
0643 18 03			jr .pastdmark  
0645 ..			.dmark: db "FNF"  
0648 f1			.pastdmark: pop af  
0649			endm  
# End of macro DMARK
0649					;	push af 
0649					;	ld a, 'n' 
0649					;	ld (debug_mark),a 
0649					;	pop af 
0649						CALLMONITOR 
0649 cd 6f ee			call debug_vector  
064c				endm  
# End of macro CALLMONITOR
064c					endif 
064c c9				ret 
064d			 
064d			 
064d			 
064d			; Free Space 
064d			; ---------- 
064d			; 
064d			; With current bank 
064d			; 
064d			; Set block count to zero 
064d			; Starting with first logical block 
064d			;      Find free block  
064d			;      If block id given, increment block count 
064d			; 
064d			;  
064d			 
064d			 
064d			; hl contains count of free blocks 
064d			 
064d			storage_freeblocks: 
064d			 
064d				; now locate first 0 page to mark as a free block 
064d			 
064d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
064f 21 40 00			ld hl, STORE_BLOCK_PHY 
0652 11 00 00			ld de, 0 
0655			 
0655			.fb1:   	 
0655 e5					push hl 
0656 c5					push bc 
0657 d5					push de 
0658 cd ab 01				call se_readbyte 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is free? 
065e			;		cp 0 
065e b7					or a 
065f 20 01				jr nz, .ff1cont 
0661 13					inc de 
0662			 
0662			.ff1cont: 
0662			 
0662			 
0662 3e 40				ld a, STORE_BLOCK_PHY 
0664 cd e1 0d				call addatohl 
0667 10 ec				djnz .fb1 
0669			 
0669 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066b			.fb2:   	 
066b e5					push hl 
066c c5					push bc 
066d d5					push de 
066e cd ab 01				call se_readbyte 
0671 d1					pop de 
0672 c1					pop bc 
0673 e1					pop hl 
0674			 
0674					; is free? 
0674			;		cp 0 
0674 b7					or a 
0675 20 01				jr nz, .ff2cont 
0677 13					inc de 
0678			 
0678			.ff2cont: 
0678			 
0678 3e 40				ld a, STORE_BLOCK_PHY 
067a cd e1 0d				call addatohl 
067d 10 ec				djnz .fb2 
067f			 
067f eb				ex de, hl 
0680 c9				ret 
0681			 
0681			; Get File ID 
0681			; ----------- 
0681			; 
0681			; With current bank 
0681			;  
0681			; Load Block 0 Config 
0681			; Get max file id number 
0681			; For each logical block 
0681			;    Read block file id 
0681			;      If first block of file and dont have file id 
0681			;         if file get id and exit 
0681			 
0681			 
0681			 
0681			 
0681			; Create File 
0681			; ----------- 
0681			; 
0681			; With current bank  
0681			; Load Block 0 Config 
0681			; Get max file id number 
0681			; Increment file id number 
0681			; Save Config 
0681			; Find free block 
0681			; Set buffer with file name and file id 
0681			; Write buffer to free block  
0681			 
0681			 
0681			; hl point to file name 
0681			; hl returns file id 
0681			 
0681			; file format: 
0681			; byte 0 - file id 
0681			; byte 1 - extent number 
0681			; byte 2-> data 
0681			 
0681			; format for extent number 0: 
0681			; 
0681			; byte 0 - file id 
0681			; byte 1 - extent 0 
0681			; byte 2 - extent count 
0681			; byte 3 -> file name and meta data 
0681			 
0681			 
0681			storage_create: 
0681				if DEBUG_STORESE 
0681					DMARK "SCR" 
0681 f5				push af  
0682 3a 96 06			ld a, (.dmark)  
0685 32 62 ee			ld (debug_mark),a  
0688 3a 97 06			ld a, (.dmark+1)  
068b 32 63 ee			ld (debug_mark+1),a  
068e 3a 98 06			ld a, (.dmark+2)  
0691 32 64 ee			ld (debug_mark+2),a  
0694 18 03			jr .pastdmark  
0696 ..			.dmark: db "SCR"  
0699 f1			.pastdmark: pop af  
069a			endm  
# End of macro DMARK
069a					CALLMONITOR 
069a cd 6f ee			call debug_vector  
069d				endm  
# End of macro CALLMONITOR
069d				endif 
069d			 
069d e5				push hl		; save file name pointer 
069e			 
069e cd 35 03			call storage_get_block_0 
06a1			 
06a1 3a 71 ea			ld a,(store_page)	; get current file id 
06a4 3c				inc a 
06a5 32 71 ea			ld (store_page),a 
06a8				 
06a8 32 65 ea			ld (store_tmpid),a			; save id 
06ab			 
06ab 21 00 00			ld hl, 0 
06ae 11 71 ea			ld de, store_page 
06b1				if DEBUG_STORESE 
06b1					DMARK "SCw" 
06b1 f5				push af  
06b2 3a c6 06			ld a, (.dmark)  
06b5 32 62 ee			ld (debug_mark),a  
06b8 3a c7 06			ld a, (.dmark+1)  
06bb 32 63 ee			ld (debug_mark+1),a  
06be 3a c8 06			ld a, (.dmark+2)  
06c1 32 64 ee			ld (debug_mark+2),a  
06c4 18 03			jr .pastdmark  
06c6 ..			.dmark: db "SCw"  
06c9 f1			.pastdmark: pop af  
06ca			endm  
# End of macro DMARK
06ca					CALLMONITOR 
06ca cd 6f ee			call debug_vector  
06cd				endm  
# End of macro CALLMONITOR
06cd				endif 
06cd cd ec 02			call storage_write_block	 ; save update 
06d0			 
06d0				if DEBUG_STORESE 
06d0 11 71 ea				ld de, store_page 
06d3					DMARK "SCC" 
06d3 f5				push af  
06d4 3a e8 06			ld a, (.dmark)  
06d7 32 62 ee			ld (debug_mark),a  
06da 3a e9 06			ld a, (.dmark+1)  
06dd 32 63 ee			ld (debug_mark+1),a  
06e0 3a ea 06			ld a, (.dmark+2)  
06e3 32 64 ee			ld (debug_mark+2),a  
06e6 18 03			jr .pastdmark  
06e8 ..			.dmark: db "SCC"  
06eb f1			.pastdmark: pop af  
06ec			endm  
# End of macro DMARK
06ec					CALLMONITOR 
06ec cd 6f ee			call debug_vector  
06ef				endm  
# End of macro CALLMONITOR
06ef				endif 
06ef				;  
06ef				 
06ef 21 40 00			ld hl, STORE_BLOCK_PHY 
06f2 11 00 00			ld de, 0 
06f5 cd b3 05			call storage_findnextid 
06f8			 
06f8 22 5c ea			ld (store_tmppageid), hl    ; save page to use  
06fb			 
06fb				; TODO detect 0 = no spare blocks 
06fb			 
06fb				; hl now contains the free page to use for the file header page 
06fb			 
06fb				if DEBUG_STORESE 
06fb				DMARK "SCF" 
06fb f5				push af  
06fc 3a 10 07			ld a, (.dmark)  
06ff 32 62 ee			ld (debug_mark),a  
0702 3a 11 07			ld a, (.dmark+1)  
0705 32 63 ee			ld (debug_mark+1),a  
0708 3a 12 07			ld a, (.dmark+2)  
070b 32 64 ee			ld (debug_mark+2),a  
070e 18 03			jr .pastdmark  
0710 ..			.dmark: db "SCF"  
0713 f1			.pastdmark: pop af  
0714			endm  
# End of macro DMARK
0714					CALLMONITOR 
0714 cd 6f ee			call debug_vector  
0717				endm  
# End of macro CALLMONITOR
0717				endif 
0717			 
0717 22 5c ea			ld (store_tmppageid), hl 
071a				 
071a 3a 65 ea			ld a,(store_tmpid)    ; get file id 
071d			;	ld a, (store_filecache)			; save to cache 
071d			 
071d 32 71 ea			ld (store_page),a    ; set page id 
0720 3e 00			ld a, 0			 ; extent 0 is file header 
0722 32 72 ea			ld (store_page+1), a   ; set file extent 
0725			 
0725 32 73 ea			ld (store_page+2), a   ; extent count for the file 
0728			 
0728			;	inc hl 		; init block 0 of file 
0728			;	inc hl   		; skip file and extent id 
0728			 ;       ld a, 0 
0728			;	ld (hl),a 
0728			;	ld a, (store_filecache+1)  	; save to cache 
0728			 
0728			;	inc hl    ; file name 
0728				 
0728				 
0728 11 74 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
072b				if DEBUG_STORESE 
072b					DMARK "SCc" 
072b f5				push af  
072c 3a 40 07			ld a, (.dmark)  
072f 32 62 ee			ld (debug_mark),a  
0732 3a 41 07			ld a, (.dmark+1)  
0735 32 63 ee			ld (debug_mark+1),a  
0738 3a 42 07			ld a, (.dmark+2)  
073b 32 64 ee			ld (debug_mark+2),a  
073e 18 03			jr .pastdmark  
0740 ..			.dmark: db "SCc"  
0743 f1			.pastdmark: pop af  
0744			endm  
# End of macro DMARK
0744					CALLMONITOR 
0744 cd 6f ee			call debug_vector  
0747				endm  
# End of macro CALLMONITOR
0747				endif 
0747 e1				pop hl    ; get zero term string 
0748 e5				push hl 
0749 3e 00			ld a, 0 
074b cd 44 11			call strlent 
074e 23				inc hl   ; cover zero term 
074f 06 00			ld b,0 
0751 4d				ld c,l 
0752 e1				pop hl 
0753				;ex de, hl 
0753				if DEBUG_STORESE 
0753					DMARK "SCa" 
0753 f5				push af  
0754 3a 68 07			ld a, (.dmark)  
0757 32 62 ee			ld (debug_mark),a  
075a 3a 69 07			ld a, (.dmark+1)  
075d 32 63 ee			ld (debug_mark+1),a  
0760 3a 6a 07			ld a, (.dmark+2)  
0763 32 64 ee			ld (debug_mark+2),a  
0766 18 03			jr .pastdmark  
0768 ..			.dmark: db "SCa"  
076b f1			.pastdmark: pop af  
076c			endm  
# End of macro DMARK
076c					;push af 
076c					;ld a, 'a' 
076c					;ld (debug_mark),a 
076c					;pop af 
076c					CALLMONITOR 
076c cd 6f ee			call debug_vector  
076f				endm  
# End of macro CALLMONITOR
076f				endif 
076f ed b0			ldir    ; copy zero term string 
0771				if DEBUG_STORESE 
0771					DMARK "SCA" 
0771 f5				push af  
0772 3a 86 07			ld a, (.dmark)  
0775 32 62 ee			ld (debug_mark),a  
0778 3a 87 07			ld a, (.dmark+1)  
077b 32 63 ee			ld (debug_mark+1),a  
077e 3a 88 07			ld a, (.dmark+2)  
0781 32 64 ee			ld (debug_mark+2),a  
0784 18 03			jr .pastdmark  
0786 ..			.dmark: db "SCA"  
0789 f1			.pastdmark: pop af  
078a			endm  
# End of macro DMARK
078a					CALLMONITOR 
078a cd 6f ee			call debug_vector  
078d				endm  
# End of macro CALLMONITOR
078d				endif 
078d			 
078d				; write file header page 
078d			 
078d 2a 5c ea			ld hl,(store_tmppageid) 
0790 11 71 ea			ld de, store_page 
0793				if DEBUG_STORESE 
0793					DMARK "SCb" 
0793 f5				push af  
0794 3a a8 07			ld a, (.dmark)  
0797 32 62 ee			ld (debug_mark),a  
079a 3a a9 07			ld a, (.dmark+1)  
079d 32 63 ee			ld (debug_mark+1),a  
07a0 3a aa 07			ld a, (.dmark+2)  
07a3 32 64 ee			ld (debug_mark+2),a  
07a6 18 03			jr .pastdmark  
07a8 ..			.dmark: db "SCb"  
07ab f1			.pastdmark: pop af  
07ac			endm  
# End of macro DMARK
07ac					;push af 
07ac					;ld a, 'b' 
07ac					;ld (debug_mark),a 
07ac					;pop af 
07ac					CALLMONITOR 
07ac cd 6f ee			call debug_vector  
07af				endm  
# End of macro CALLMONITOR
07af				endif 
07af cd ec 02			call storage_write_block 
07b2			 
07b2 3a 65 ea			ld a, (store_tmpid) 
07b5 6f				ld l, a 
07b6 26 00			ld h,0 
07b8				if DEBUG_STORESE 
07b8					DMARK "SCz" 
07b8 f5				push af  
07b9 3a cd 07			ld a, (.dmark)  
07bc 32 62 ee			ld (debug_mark),a  
07bf 3a ce 07			ld a, (.dmark+1)  
07c2 32 63 ee			ld (debug_mark+1),a  
07c5 3a cf 07			ld a, (.dmark+2)  
07c8 32 64 ee			ld (debug_mark+2),a  
07cb 18 03			jr .pastdmark  
07cd ..			.dmark: db "SCz"  
07d0 f1			.pastdmark: pop af  
07d1			endm  
# End of macro DMARK
07d1					CALLMONITOR 
07d1 cd 6f ee			call debug_vector  
07d4				endm  
# End of macro CALLMONITOR
07d4				endif 
07d4 c9				ret 
07d5				 
07d5			 
07d5			 
07d5			; 
07d5			; Read File 
07d5			; 
07d5			; h - file id to locate 
07d5			; l - extent to locate 
07d5			; de - pointer to string to read into 
07d5			; 
07d5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d5			 
07d5			.sr_fail: 
07d5 d1				pop de 
07d6 c9				ret 
07d7			 
07d7			storage_read: 
07d7			 
07d7			 
07d7 d5				push de 
07d8			 
07d8			; TODO BUG the above push is it popped before the RET Z? 
07d8			 
07d8			; TODO how to handle multiple part blocks 
07d8			 
07d8				; locate file extent to read 
07d8			 
07d8 5c				ld e, h 
07d9 55				ld d, l 
07da			 
07da			.srext: 
07da 22 6f ea			ld (store_readptr), hl     ; save the current extent to load 
07dd ed 53 6d ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07e1			 
07e1 21 40 00			ld hl, STORE_BLOCK_PHY 
07e4				if DEBUG_STORESE 
07e4					DMARK "sre" 
07e4 f5				push af  
07e5 3a f9 07			ld a, (.dmark)  
07e8 32 62 ee			ld (debug_mark),a  
07eb 3a fa 07			ld a, (.dmark+1)  
07ee 32 63 ee			ld (debug_mark+1),a  
07f1 3a fb 07			ld a, (.dmark+2)  
07f4 32 64 ee			ld (debug_mark+2),a  
07f7 18 03			jr .pastdmark  
07f9 ..			.dmark: db "sre"  
07fc f1			.pastdmark: pop af  
07fd			endm  
# End of macro DMARK
07fd					CALLMONITOR 
07fd cd 6f ee			call debug_vector  
0800				endm  
# End of macro CALLMONITOR
0800				endif 
0800 cd b3 05			call storage_findnextid 
0803			 
0803				if DEBUG_STORESE 
0803					DMARK "srf" 
0803 f5				push af  
0804 3a 18 08			ld a, (.dmark)  
0807 32 62 ee			ld (debug_mark),a  
080a 3a 19 08			ld a, (.dmark+1)  
080d 32 63 ee			ld (debug_mark+1),a  
0810 3a 1a 08			ld a, (.dmark+2)  
0813 32 64 ee			ld (debug_mark+2),a  
0816 18 03			jr .pastdmark  
0818 ..			.dmark: db "srf"  
081b f1			.pastdmark: pop af  
081c			endm  
# End of macro DMARK
081c					CALLMONITOR 
081c cd 6f ee			call debug_vector  
081f				endm  
# End of macro CALLMONITOR
081f				endif 
081f cd 0a 0e			call ishlzero 
0822			;	ld a, l 
0822			;	add h 
0822			;	cp 0 
0822 28 b1			jr z,.sr_fail			; block not found so EOF 
0824			 
0824				; save current address for use by higher level words etc 
0824			 
0824 22 62 ea			ld (store_openaddr),hl 
0827			 
0827			 
0827				; hl contains page number to load 
0827 d1				pop de   ; get storage 
0828 ed 53 6d ea		ld (store_readbuf), de     ; current buffer to load in to 
082c d5				push de 
082d				if DEBUG_STORESE 
082d					DMARK "srg" 
082d f5				push af  
082e 3a 42 08			ld a, (.dmark)  
0831 32 62 ee			ld (debug_mark),a  
0834 3a 43 08			ld a, (.dmark+1)  
0837 32 63 ee			ld (debug_mark+1),a  
083a 3a 44 08			ld a, (.dmark+2)  
083d 32 64 ee			ld (debug_mark+2),a  
0840 18 03			jr .pastdmark  
0842 ..			.dmark: db "srg"  
0845 f1			.pastdmark: pop af  
0846			endm  
# End of macro DMARK
0846					CALLMONITOR 
0846 cd 6f ee			call debug_vector  
0849				endm  
# End of macro CALLMONITOR
0849				endif 
0849 cd 87 02			call storage_read_block 
084c			 
084c				; if this a continuation read??? 
084c			 
084c 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084f			 
084f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0851 cd e1 0d			call addatohl 
0854 7e				ld a,(hl) 
0855			;	cp 0 
0855 b7				or a 
0856 28 02			jr z, .markiscont 
0858 3e ff			ld a, 255 
085a			 
085a			.markiscont: 
085a 32 64 ea			ld (store_readcont), a 
085d			 
085d				if DEBUG_STORESE 
085d					DMARK "srC" 
085d f5				push af  
085e 3a 72 08			ld a, (.dmark)  
0861 32 62 ee			ld (debug_mark),a  
0864 3a 73 08			ld a, (.dmark+1)  
0867 32 63 ee			ld (debug_mark+1),a  
086a 3a 74 08			ld a, (.dmark+2)  
086d 32 64 ee			ld (debug_mark+2),a  
0870 18 03			jr .pastdmark  
0872 ..			.dmark: db "srC"  
0875 f1			.pastdmark: pop af  
0876			endm  
# End of macro DMARK
0876					CALLMONITOR 
0876 cd 6f ee			call debug_vector  
0879				endm  
# End of macro CALLMONITOR
0879				endif 
0879				; only short reads enabled 
0879			 
0879 3a 6c ea			ld a, (store_longread) 
087c			;	cp 0 
087c b7				or a 
087d ca 49 09			jp z, .readdone 
0880			 
0880			; TODO if block has no zeros then need to read next block  
0880			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0880			; check last byte of physical block. 
0880			; if not zero then the next block needs to be loaded 
0880			 
0880			 
0880 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0883			 
0883 3e 3f			ld a, STORE_BLOCK_PHY-1 
0885 cd e1 0d			call addatohl 
0888				;dec hl 
0888 7e				ld a,(hl) 
0889				if DEBUG_STORESE 
0889					DMARK "sr?" 
0889 f5				push af  
088a 3a 9e 08			ld a, (.dmark)  
088d 32 62 ee			ld (debug_mark),a  
0890 3a 9f 08			ld a, (.dmark+1)  
0893 32 63 ee			ld (debug_mark+1),a  
0896 3a a0 08			ld a, (.dmark+2)  
0899 32 64 ee			ld (debug_mark+2),a  
089c 18 03			jr .pastdmark  
089e ..			.dmark: db "sr?"  
08a1 f1			.pastdmark: pop af  
08a2			endm  
# End of macro DMARK
08a2					CALLMONITOR 
08a2 cd 6f ee			call debug_vector  
08a5				endm  
# End of macro CALLMONITOR
08a5				endif 
08a5			;	cp 0 
08a5 b7				or a 
08a6 ca 49 09			jp z, .readdone 
08a9			 
08a9				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a9			 
08a9 23				inc hl 
08aa			 
08aa 22 6d ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ad			 
08ad ed 5b 6f ea		ld de, (store_readptr)     ; save the current extent to load 
08b1			 
08b1 eb				ex de, hl 
08b2			 
08b2				; next ext 
08b2			 
08b2 23				inc hl 
08b3 22 6f ea			ld  (store_readptr), hl     ; save the current extent to load 
08b6			 
08b6				if DEBUG_STORESE 
08b6					DMARK "sF2" 
08b6 f5				push af  
08b7 3a cb 08			ld a, (.dmark)  
08ba 32 62 ee			ld (debug_mark),a  
08bd 3a cc 08			ld a, (.dmark+1)  
08c0 32 63 ee			ld (debug_mark+1),a  
08c3 3a cd 08			ld a, (.dmark+2)  
08c6 32 64 ee			ld (debug_mark+2),a  
08c9 18 03			jr .pastdmark  
08cb ..			.dmark: db "sF2"  
08ce f1			.pastdmark: pop af  
08cf			endm  
# End of macro DMARK
08cf					CALLMONITOR 
08cf cd 6f ee			call debug_vector  
08d2				endm  
# End of macro CALLMONITOR
08d2				endif 
08d2			 
08d2				; get and load block 
08d2			 
08d2 cd b3 05			call storage_findnextid 
08d5			 
08d5				if DEBUG_STORESE 
08d5					DMARK "sf2" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 62 ee			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 63 ee			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 64 ee			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "sf2"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 6f ee			call debug_vector  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1 cd 0a 0e			call ishlzero 
08f4			;	ld a, l 
08f4			;	add h 
08f4			;	cp 0 
08f4 ca d5 07			jp z,.sr_fail			; block not found so EOF 
08f7				 
08f7				; save current address for use by higher level words etc 
08f7			 
08f7 22 62 ea			ld (store_openaddr),hl 
08fa			 
08fa cd 87 02			call storage_read_block 
08fd			 
08fd				; on a continuation block, we now have the file id and ext in the middle of the block 
08fd				; we need to pull everything back  
08fd			 
08fd ed 5b 6d ea		ld de, (store_readbuf)     ; current buffer to nudge into 
0901 2a 6d ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0904 23				inc hl 
0905 23				inc hl     ; skip id and ext 
0906 01 40 00			ld bc, STORE_BLOCK_PHY 
0909				if DEBUG_STORESE 
0909					DMARK "SR<" 
0909 f5				push af  
090a 3a 1e 09			ld a, (.dmark)  
090d 32 62 ee			ld (debug_mark),a  
0910 3a 1f 09			ld a, (.dmark+1)  
0913 32 63 ee			ld (debug_mark+1),a  
0916 3a 20 09			ld a, (.dmark+2)  
0919 32 64 ee			ld (debug_mark+2),a  
091c 18 03			jr .pastdmark  
091e ..			.dmark: db "SR<"  
0921 f1			.pastdmark: pop af  
0922			endm  
# End of macro DMARK
0922					CALLMONITOR 
0922 cd 6f ee			call debug_vector  
0925				endm  
# End of macro CALLMONITOR
0925				endif 
0925 ed b0			ldir     ; copy data 
0927			 
0927				; move the pointer back and pretend we have a full buffer for next recheck 
0927			 
0927 1b				dec de 
0928 1b				dec de 
0929			 
0929			; TODO do pop below now short circuit loop????? 
0929 c1				pop bc     ; get rid of spare de on stack 
092a				if DEBUG_STORESE 
092a					DMARK "SR>" 
092a f5				push af  
092b 3a 3f 09			ld a, (.dmark)  
092e 32 62 ee			ld (debug_mark),a  
0931 3a 40 09			ld a, (.dmark+1)  
0934 32 63 ee			ld (debug_mark+1),a  
0937 3a 41 09			ld a, (.dmark+2)  
093a 32 64 ee			ld (debug_mark+2),a  
093d 18 03			jr .pastdmark  
093f ..			.dmark: db "SR>"  
0942 f1			.pastdmark: pop af  
0943			endm  
# End of macro DMARK
0943					CALLMONITOR 
0943 cd 6f ee			call debug_vector  
0946				endm  
# End of macro CALLMONITOR
0946				endif 
0946 c3 da 07			jp .srext 
0949			 
0949			 
0949			 
0949			 
0949			 
0949			.readdone:		 
0949 e1				pop hl 		 ; return start of data to show as not EOF 
094a 23				inc hl   ; past file id 
094b 23				inc hl   ; past ext 
094c				if DEBUG_STORESE 
094c					DMARK "SRe" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 62 ee			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 63 ee			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 64 ee			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "SRe"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 6f ee			call debug_vector  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 c9					ret 
0969			 
0969			 
0969			 
0969			; 
0969			; Append File 
0969			; 
0969			; hl - file id to locate 
0969			; de - pointer to (multi block) string to write 
0969			 
0969			.sa_notfound: 
0969 d1				pop de 
096a c9				ret 
096b			 
096b			 
096b			storage_append: 
096b				; hl -  file id to append to 
096b				; de - string to append 
096b			 
096b d5				push de 
096c				 
096c				if DEBUG_STORESE 
096c					DMARK "AP1" 
096c f5				push af  
096d 3a 81 09			ld a, (.dmark)  
0970 32 62 ee			ld (debug_mark),a  
0973 3a 82 09			ld a, (.dmark+1)  
0976 32 63 ee			ld (debug_mark+1),a  
0979 3a 83 09			ld a, (.dmark+2)  
097c 32 64 ee			ld (debug_mark+2),a  
097f 18 03			jr .pastdmark  
0981 ..			.dmark: db "AP1"  
0984 f1			.pastdmark: pop af  
0985			endm  
# End of macro DMARK
0985					CALLMONITOR 
0985 cd 6f ee			call debug_vector  
0988				endm  
# End of macro CALLMONITOR
0988				endif 
0988			 
0988 7d				ld a, l 
0989 32 65 ea			ld (store_tmpid), a 
098c			 
098c				; get file header  
098c			 
098c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098e 3a 65 ea			ld a, (store_tmpid) 
0991 5f				ld e, a 
0992			 
0992 21 40 00				ld hl, STORE_BLOCK_PHY 
0995 cd b3 05				call storage_findnextid 
0998			 
0998 cd 0a 0e			call ishlzero 
099b 28 cc			jr z, .sa_notfound 
099d			 
099d 22 5c ea			ld (store_tmppageid), hl 
09a0			 
09a0				; TODO handle file id not found 
09a0			 
09a0				if DEBUG_STORESE 
09a0					DMARK "AP2" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 62 ee			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 63 ee			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 64 ee			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "AP2"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6f ee			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc			 
09bc				; update file extent count 
09bc			 
09bc 11 71 ea			ld de, store_page 
09bf			 
09bf cd 87 02			call storage_read_block 
09c2			 
09c2				if DEBUG_STORESE 
09c2					DMARK "AP3" 
09c2 f5				push af  
09c3 3a d7 09			ld a, (.dmark)  
09c6 32 62 ee			ld (debug_mark),a  
09c9 3a d8 09			ld a, (.dmark+1)  
09cc 32 63 ee			ld (debug_mark+1),a  
09cf 3a d9 09			ld a, (.dmark+2)  
09d2 32 64 ee			ld (debug_mark+2),a  
09d5 18 03			jr .pastdmark  
09d7 ..			.dmark: db "AP3"  
09da f1			.pastdmark: pop af  
09db			endm  
# End of macro DMARK
09db					CALLMONITOR 
09db cd 6f ee			call debug_vector  
09de				endm  
# End of macro CALLMONITOR
09de				endif 
09de			;	ld (store_tmppageid), hl 
09de			 
09de 3a 73 ea			ld a, (store_page+2) 
09e1 3c				inc a 
09e2 32 73 ea			ld (store_page+2), a 
09e5 32 64 ea			ld (store_tmpext), a 
09e8				 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP3" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 62 ee			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 63 ee			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 64 ee			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP3"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 6f ee			call debug_vector  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 2a 5c ea			ld hl, (store_tmppageid) 
0a07 11 71 ea			ld de, store_page 
0a0a cd ec 02			call storage_write_block 
0a0d			 
0a0d				; find free block 
0a0d			 
0a0d 11 00 00			ld de, 0			 ; file extent to locate 
0a10			 
0a10 21 40 00				ld hl, STORE_BLOCK_PHY 
0a13 cd b3 05				call storage_findnextid 
0a16 cd 0a 0e			call ishlzero 
0a19 ca 69 09			jp z, .sa_notfound 
0a1c			 
0a1c					; TODO handle no space left 
0a1c					 
0a1c 22 5c ea				ld (store_tmppageid), hl 
0a1f			 
0a1f				if DEBUG_STORESE 
0a1f					DMARK "AP4" 
0a1f f5				push af  
0a20 3a 34 0a			ld a, (.dmark)  
0a23 32 62 ee			ld (debug_mark),a  
0a26 3a 35 0a			ld a, (.dmark+1)  
0a29 32 63 ee			ld (debug_mark+1),a  
0a2c 3a 36 0a			ld a, (.dmark+2)  
0a2f 32 64 ee			ld (debug_mark+2),a  
0a32 18 03			jr .pastdmark  
0a34 ..			.dmark: db "AP4"  
0a37 f1			.pastdmark: pop af  
0a38			endm  
# End of macro DMARK
0a38					CALLMONITOR 
0a38 cd 6f ee			call debug_vector  
0a3b				endm  
# End of macro CALLMONITOR
0a3b				endif 
0a3b					; init the buffer with zeros so we can id if the buffer is full or not 
0a3b			 
0a3b e5					push hl 
0a3c c5					push bc 
0a3d			 
0a3d 21 71 ea				ld hl, store_page 
0a40 06 40				ld b, STORE_BLOCK_PHY 
0a42			;		ld a, 0 
0a42 36 00		.zeroblock:	ld (hl), 0 
0a44 23					inc hl 
0a45 10 fb				djnz .zeroblock 
0a47			 
0a47 c1					pop bc 
0a48 e1					pop hl 
0a49			 
0a49					; construct block 
0a49			 
0a49 3a 65 ea				ld a, (store_tmpid) 
0a4c 32 71 ea				ld (store_page), a   ; file id 
0a4f 3a 64 ea				ld a, (store_tmpext)   ; extent for this block 
0a52 32 72 ea				ld (store_page+1), a 
0a55			 
0a55 e1					pop hl    ; get string to write 
0a56 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a58 11 73 ea				ld de, store_page+2 
0a5b			 
0a5b				if DEBUG_STORESE 
0a5b					DMARK "AP5" 
0a5b f5				push af  
0a5c 3a 70 0a			ld a, (.dmark)  
0a5f 32 62 ee			ld (debug_mark),a  
0a62 3a 71 0a			ld a, (.dmark+1)  
0a65 32 63 ee			ld (debug_mark+1),a  
0a68 3a 72 0a			ld a, (.dmark+2)  
0a6b 32 64 ee			ld (debug_mark+2),a  
0a6e 18 03			jr .pastdmark  
0a70 ..			.dmark: db "AP5"  
0a73 f1			.pastdmark: pop af  
0a74			endm  
# End of macro DMARK
0a74					CALLMONITOR 
0a74 cd 6f ee			call debug_vector  
0a77				endm  
# End of macro CALLMONITOR
0a77				endif 
0a77			 
0a77			 
0a77			 
0a77					; fill buffer with data until end of string or full block 
0a77			 
0a77 7e			.appd:		ld a, (hl) 
0a78 12					ld (de), a 
0a79			;		cp 0 
0a79 b7					or a 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f7				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 5c ea			ld hl, (store_tmppageid) 
0a85 11 71 ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 62 ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 63 ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 64 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6f ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd ec 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9					;cp 0		 ; no, string was fully written 
0aa9 b7					or a 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 65 ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 6b 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4			;		ld a,0 
0ab4			.src:		ld (hl),0 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4			;	ld a, 0 
0ab4				ld (hl),0 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 71 ea			ld hl, store_page 
0aba			;	ld a, 0 
0aba 36 00			ld (hl), 0 
0abc			 
0abc 11 72 ea			ld de, store_page+1 
0abf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac2			 
0ac2 ed b0			ldir 
0ac4				 
0ac4 c1				pop bc 
0ac5 d1				pop de 
0ac6 e1				pop hl 
0ac7 c9				ret 
0ac8			 
0ac8			; eof 
# End of file firmware_storage.asm
0ac8			  
0ac8			; support routines for above hardware abstraction layer  
0ac8			  
0ac8			include "firmware_general.asm"        ; general support functions  
0ac8			 
0ac8			; word look up 
0ac8			 
0ac8			; in 
0ac8			; a is the index 
0ac8			; hl is pointer start of array 
0ac8			; 
0ac8			; returns 
0ac8			; hl to the word 
0ac8			; 
0ac8			 
0ac8			table_lookup:  
0ac8 d5					push de 
0ac9 eb					ex de, hl 
0aca			 
0aca 6f					ld l, a 
0acb 26 00				ld h, 0 
0acd 29					add hl, hl 
0ace 19					add hl, de 
0acf 7e					ld a, (hl) 
0ad0 23					inc hl 
0ad1 66					ld h,(hl) 
0ad2 6f					ld l, a 
0ad3			 
0ad3 d1					pop de 
0ad4 c9					ret 
0ad5			 
0ad5			; Delay loops 
0ad5			 
0ad5			 
0ad5			 
0ad5			aDelayInMS: 
0ad5 c5				push bc 
0ad6 47				ld b,a 
0ad7			msdelay: 
0ad7 c5				push bc 
0ad8				 
0ad8			 
0ad8 01 41 00			ld bc,041h 
0adb cd f3 0a			call delayloop 
0ade c1				pop bc 
0adf 05				dec b 
0ae0 20 f5			jr nz,msdelay 
0ae2			 
0ae2			;if CPU_CLOCK_8MHZ 
0ae2			;msdelay8: 
0ae2			;	push bc 
0ae2			;	 
0ae2			; 
0ae2			;	ld bc,041h 
0ae2			;	call delayloop 
0ae2			;	pop bc 
0ae2			;	dec b 
0ae2			;	jr nz,msdelay8 
0ae2			;endif 
0ae2			 
0ae2			 
0ae2 c1				pop bc 
0ae3 c9				ret 
0ae4			 
0ae4			 
0ae4			delay250ms: 
0ae4				;push de 
0ae4 01 00 40			ld bc, 04000h 
0ae7 c3 f3 0a			jp delayloop 
0aea			delay500ms: 
0aea				;push de 
0aea 01 00 80			ld bc, 08000h 
0aed c3 f3 0a			jp delayloop 
0af0			delay1s: 
0af0				;push bc 
0af0			   ; Clobbers A, d and e 
0af0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af3			delayloop: 
0af3 c5			    push bc 
0af4			 
0af4			if BASE_CPM 
0af4 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af7			.cpmloop: 
0af7 c5				push bc 
0af8			 
0af8			endif 
0af8			 
0af8			 
0af8			 
0af8			delayloopi: 
0af8			;	push bc 
0af8			;.dl: 
0af8 cb 47		    bit     0,a    	; 8 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe e6 ff		    and     255  	; 7 
0b00 0b			    dec     bc      	; 6 
0b01 79			    ld      a,c     	; 4 
0b02 b0			    or      b     	; 4 
0b03 c2 f8 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b06			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b06				;pop de 
0b06			;pop bc 
0b06			 
0b06			if BASE_CPM 
0b06 c1				pop bc 
0b07				 
0b07 0b			    dec     bc      	; 6 
0b08 79			    ld      a,c     	; 4 
0b09 b0			    or      b     	; 4 
0b0a c2 f7 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0d				 
0b0d			 
0b0d			endif 
0b0d			;if CPU_CLOCK_8MHZ 
0b0d			;    pop bc 
0b0d			;    push bc 
0b0d			;.dl8: 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    and     255  	; 7 
0b0d			;    dec     bc      	; 6 
0b0d			;    ld      a,c     	; 4 
0b0d			;    or      b     	; 4 
0b0d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0d			;endif 
0b0d			 
0b0d			;if CPU_CLOCK_10MHZ 
0b0d			;    pop bc 
0b0d			;    push bc 
0b0d			;.dl8: 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    and     255  	; 7 
0b0d			;    dec     bc      	; 6 
0b0d			;    ld      a,c     	; 4 
0b0d			;    or      b     	; 4 
0b0d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0d			;endif 
0b0d c1			    pop bc 
0b0e			 
0b0e c9				ret 
0b0f			 
0b0f			 
0b0f			 
0b0f			; eof 
# End of file firmware_general.asm
0b0f			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b0f			; display routines that use the physical hardware abstraction layer 
0b0f			 
0b0f			 
0b0f			; Display an activity indicator 
0b0f			; Each call returns the new char pointed to in hl 
0b0f			 
0b0f			active: 
0b0f 3a bd eb			ld a, (display_active) 
0b12 fe 06			cp 6 
0b14			 
0b14 20 02			jr nz, .sne 
0b16				; gone past the last one reset sequence 
0b16 3e ff			ld a, 255 
0b18			 
0b18			.sne:   
0b18				; get the next char in seq 
0b18 3c				inc a 
0b19 32 bd eb			ld (display_active), a 
0b1c			 
0b1c				; look up the string in the table 
0b1c 21 33 0b			ld hl, actseq 
0b1f cb 27			sla a 
0b21 cd e1 0d			call addatohl 
0b24 cd 3f 1e			call loadwordinhl 
0b27			 
0b27				; forth will write the to string when pushing so move from rom to ram 
0b27			 
0b27 11 be eb			ld de, display_active+1 
0b2a 01 02 00			ld bc, 2 
0b2d ed b0			ldir 
0b2f			 
0b2f 21 be eb			ld hl, display_active+1 
0b32 c9				ret 
0b33				 
0b33				 
0b33			 
0b33			 
0b33			;db "|/-\|-\" 
0b33			 
0b33			actseq: 
0b33			 
0b33 41 0b		dw spin0 
0b35 43 0b		dw spin1 
0b37 45 0b		dw spin2 
0b39 47 0b		dw spin3 
0b3b 45 0b		dw spin2 
0b3d 43 0b		dw spin1 
0b3f 41 0b		dw spin0 
0b41			 
0b41 .. 00		spin0: db " ", 0 
0b43 .. 00		spin1: db "-", 0 
0b45 .. 00		spin2: db "+", 0 
0b47 .. 00		spin3: db "#", 0 
0b49			 
0b49			 
0b49			; information window 
0b49			 
0b49			; pass hl with 1st string to display 
0b49			; pass de with 2nd string to display 
0b49			 
0b49			info_panel: 
0b49 e5				push hl 
0b4a			 
0b4a 2a c3 eb			ld hl, (display_fb_active) 
0b4d e5				push hl    ; future de destination 
0b4e 21 a8 ed				ld hl, display_fb0 
0b51 22 c3 eb				ld (display_fb_active), hl 
0b54			 
0b54			;	call clear_display 
0b54			 
0b54				if BASE_CPM 
0b54 3e 2e			ld a, '.' 
0b56				else 
0b56				ld a, 165 
0b56				endif 
0b56 cd bc 0b			call fill_display 
0b59			 
0b59			 
0b59 3e 55			ld a, display_row_3 + 5 
0b5b cd c9 0b			call str_at_display 
0b5e			 
0b5e e1				pop hl 
0b5f d1				pop de 
0b60			 
0b60 e5				push hl 
0b61			 
0b61			 
0b61 3e 2d			ld a, display_row_2 + 5 
0b63 cd c9 0b			call str_at_display 
0b66			 
0b66			 
0b66 cd d9 0b			call update_display 
0b69 cd 4e 1a			call next_page_prompt 
0b6c cd b7 0b			call clear_display 
0b6f			 
0b6f				 
0b6f 21 07 ed				ld hl, display_fb1 
0b72 22 c3 eb				ld (display_fb_active), hl 
0b75 cd d9 0b			call update_display 
0b78			 
0b78 e1				pop hl 
0b79			 
0b79 c9				ret 
0b7a			 
0b7a			 
0b7a			 
0b7a			 
0b7a			; TODO windowing? 
0b7a			 
0b7a			; TODO scroll line up 
0b7a			 
0b7a			scroll_up: 
0b7a			 
0b7a e5				push hl 
0b7b d5				push de 
0b7c c5				push bc 
0b7d			 
0b7d				; get frame buffer  
0b7d			 
0b7d 2a c3 eb			ld hl, (display_fb_active) 
0b80 e5				push hl    ; future de destination 
0b81			 
0b81 11 28 00			ld  de, display_cols 
0b84 19				add hl, de 
0b85			 
0b85 d1				pop de 
0b86			 
0b86				;ex de, hl 
0b86 01 9f 00			ld bc, display_fb_len -1  
0b89			;if DEBUG_FORTH_WORDS 
0b89			;	DMARK "SCL" 
0b89			;	CALLMONITOR 
0b89			;endif	 
0b89 ed b0			ldir 
0b8b			 
0b8b				; wipe bottom row 
0b8b			 
0b8b			 
0b8b 2a c3 eb			ld hl, (display_fb_active) 
0b8e 11 a0 00			ld de, display_cols*display_rows 
0b91 19				add hl, de 
0b92 06 28			ld b, display_cols 
0b94			;	ld a, ' ' 
0b94			.scwipe: 
0b94 36 20			ld (hl), ' ' 
0b96 2b				dec hl 
0b97 10 fb			djnz .scwipe 
0b99			 
0b99				;pop hl 
0b99			 
0b99 c1				pop bc 
0b9a d1				pop de 
0b9b e1				pop hl 
0b9c			 
0b9c c9				ret 
0b9d			 
0b9d			 
0b9d			;scroll_upo: 
0b9d			;	ld de, display_row_1 
0b9d			 ;	ld hl, display_row_2 
0b9d			;	ld bc, display_cols 
0b9d			;	ldir 
0b9d			;	ld de, display_row_2 
0b9d			 ;	ld hl, display_row_3 
0b9d			;	ld bc, display_cols 
0b9d			;	ldir 
0b9d			;	ld de, display_row_3 
0b9d			 ;	ld hl, display_row_4 
0b9d			;	ld bc, display_cols 
0b9d			;	ldir 
0b9d			 
0b9d			; TODO clear row 4 
0b9d			 
0b9d			;	ret 
0b9d			 
0b9d				 
0b9d			scroll_down: 
0b9d			 
0b9d e5				push hl 
0b9e d5				push de 
0b9f c5				push bc 
0ba0			 
0ba0				; get frame buffer  
0ba0			 
0ba0 2a c3 eb			ld hl, (display_fb_active) 
0ba3			 
0ba3 11 9f 00			ld de, display_fb_len - 1 
0ba6 19				add hl, de 
0ba7			 
0ba7 e5			push hl    ; future de destination 
0ba8			 
0ba8 11 28 00			ld  de, display_cols 
0bab ed 52			sbc hl, de 
0bad			 
0bad			 
0bad d1				pop de 
0bae			 
0bae			;	ex de, hl 
0bae 01 9f 00			ld bc, display_fb_len -1  
0bb1			 
0bb1			 
0bb1				 
0bb1			 
0bb1 ed b0			ldir 
0bb3			 
0bb3				; wipe bottom row 
0bb3			 
0bb3			 
0bb3			;	ld hl, (display_fb_active) 
0bb3			;;	ld de, display_cols*display_rows 
0bb3			;;	add hl, de 
0bb3			;	ld b, display_cols 
0bb3			;	ld a, ' ' 
0bb3			;.scwiped: 
0bb3			;	ld (hl), a 
0bb3			;	dec hl 
0bb3			;	djnz .scwiped 
0bb3			 
0bb3				;pop hl 
0bb3			 
0bb3 c1				pop bc 
0bb4 d1				pop de 
0bb5 e1				pop hl 
0bb6			 
0bb6 c9				ret 
0bb7			;scroll_down: 
0bb7			;	ld de, display_row_4 
0bb7			;	ld hl, display_row_3 
0bb7			;	ld bc, display_cols 
0bb7			;	ldir 
0bb7			;	ld de, display_row_3 
0bb7			; 	ld hl, display_row_2 
0bb7			;	ld bc, display_cols 
0bb7			;	ldir 
0bb7			;	ld de, display_row_2 
0bb7			;	ld hl, display_row_1 
0bb7			;	ld bc, display_cols 
0bb7			;	ldir 
0bb7			;;; TODO clear row 1 
0bb7			;	ret 
0bb7			 
0bb7			 
0bb7			 
0bb7			 
0bb7			 
0bb7			; clear active frame buffer 
0bb7			 
0bb7			clear_display: 
0bb7 3e 20			ld a, ' ' 
0bb9 c3 bc 0b			jp fill_display 
0bbc			 
0bbc			; fill active frame buffer with a char in A 
0bbc			 
0bbc			fill_display: 
0bbc 06 a0			ld b,display_fb_len 
0bbe 2a c3 eb			ld hl, (display_fb_active) 
0bc1 77			.fd1:	ld (hl),a 
0bc2 23				inc hl 
0bc3 10 fc			djnz .fd1 
0bc5 23				inc hl 
0bc6			;	ld a,0 
0bc6 36 00			ld (hl),0 
0bc8			 
0bc8			 
0bc8 c9				ret 
0bc9			; Write string (DE) at pos (A) to active frame buffer 
0bc9			 
0bc9 2a c3 eb		str_at_display:    ld hl,(display_fb_active) 
0bcc 06 00					ld b,0 
0bce 4f					ld c,a 
0bcf 09					add hl,bc 
0bd0 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd1 b7			            OR   A              ;Null terminator? 
0bd2 c8			            RET  Z              ;Yes, so finished 
0bd3 77					ld (hl),a 
0bd4 23				inc hl 
0bd5 13			            INC  DE             ;Point to next character 
0bd6 18 f8		            JR   .sad1     ;Repeat 
0bd8 c9					ret 
0bd9			 
0bd9			; using current frame buffer write to physical display 
0bd9			 
0bd9			update_display: 
0bd9 e5				push hl 
0bda 2a c3 eb			ld hl, (display_fb_active) 
0bdd cd fa 64			call write_display 
0be0 e1				pop hl 
0be1 c9				ret 
0be2			 
0be2			; TODO scrolling 
0be2			 
0be2			 
0be2			; move cursor right one char 
0be2			cursor_right: 
0be2			 
0be2				; TODO shift right 
0be2				; TODO if beyond max col 
0be2				; TODO       cursor_next_line 
0be2			 
0be2 c9				ret 
0be3			 
0be3			 
0be3			cursor_next_line: 
0be3				; TODO first char 
0be3				; TODO line down 
0be3				; TODO if past last row 
0be3				; TODO    scroll up 
0be3			 
0be3 c9				ret 
0be4			 
0be4			cursor_left: 
0be4				; TODO shift left 
0be4				; TODO if beyond left  
0be4				; TODO     cursor prev line 
0be4				 
0be4 c9				ret 
0be5			 
0be5			cursor_prev_line: 
0be5				; TODO last char 
0be5				; TODO line up 
0be5				; TODO if past first row 
0be5				; TODO   scroll down 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cout: 
0be6				; A - char 
0be6 c9				ret 
0be7			 
0be7			 
0be7			; Display a menu and allow item selection (optional toggle items) 
0be7			; 
0be7			; format: 
0be7			; hl pointer to word array with zero term for items 
0be7			; e.g.    db item1 
0be7			;         db .... 
0be7			;         db 0 
0be7			; 
0be7			; a = starting menu item  
0be7			; 
0be7			; de = pointer item toggle array   (todo) 
0be7			; 
0be7			; returns item selected in a 1-... 
0be7			; returns 0 if back button pressed 
0be7			; 
0be7			; NOTE: Uses system frame buffer to display 
0be7			; 
0be7			; LEFT, Q = go back 
0be7			; RIGHT, SPACE, CR = select 
0be7			; UP, A - Up 
0be7			; DOWN, Z - Down 
0be7			 
0be7			 
0be7			 
0be7			 
0be7			 
0be7			menu: 
0be7			 
0be7					; keep array pointer 
0be7			 
0be7 22 6a ea				ld (store_tmp1), hl 
0bea 32 68 ea				ld (store_tmp2), a 
0bed			 
0bed					; check for key bounce 
0bed			 
0bed			if BASE_KEV 
0bed			 
0bed			.mbounce:	call cin 
0bed			;		cp 0 
0bed					or a 
0bed					jr nz, .mbounce 
0bed			endif 
0bed					; for ease use ex 
0bed			 
0bed					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bed 21 a8 ed				ld hl, display_fb0 
0bf0 22 c3 eb				ld (display_fb_active), hl 
0bf3			 
0bf3 cd b7 0b		.mloop:		call clear_display 
0bf6 cd d9 0b				call update_display 
0bf9			 
0bf9					; draw selection id '>' at 1 
0bf9			 
0bf9					; init start of list display 
0bf9			 
0bf9 3e 05				ld a, 5 
0bfb 32 66 ea				ld (store_tmp3), a   ; display row count 
0bfe 3a 68 ea				ld a,( store_tmp2) 
0c01 32 69 ea				ld (store_tmp2+1), a   ; display item count 
0c04			 
0c04					 
0c04			.mitem:	 
0c04			 
0c04			 
0c04 3a 69 ea				ld a,(store_tmp2+1) 
0c07 6f					ld l, a 
0c08 26 00				ld h, 0 
0c0a 29					add hl, hl 
0c0b ed 5b 6a ea			ld de, (store_tmp1) 
0c0f 19					add hl, de 
0c10 7e					ld a, (hl) 
0c11 23					inc hl 
0c12 66					ld h,(hl) 
0c13 6f					ld l, a 
0c14			 
0c14 cd 0a 0e				call ishlzero 
0c17 28 1a				jr z, .mdone 
0c19			 
0c19 eb					ex de, hl 
0c1a 3a 66 ea				ld a, (store_tmp3) 
0c1d cd c9 0b				call str_at_display 
0c20					 
0c20			 
0c20					; next item 
0c20 3a 69 ea				ld a, (store_tmp2+1) 
0c23 3c					inc a 
0c24 32 69 ea				ld (store_tmp2+1), a   ; display item count 
0c27			 
0c27			 		; next row 
0c27			 
0c27 3a 66 ea				ld a, (store_tmp3) 
0c2a c6 28				add display_cols 
0c2c 32 66 ea				ld (store_tmp3), a 
0c2f			 
0c2f					; at end of screen? 
0c2f			 
0c2f fe 10				cp display_rows*4 
0c31 20 d1				jr nz, .mitem 
0c33			 
0c33			 
0c33			.mdone: 
0c33 cd 0a 0e				call ishlzero 
0c36 28 08				jr z, .nodn 
0c38			 
0c38 3e 78				ld a, display_row_4 
0c3a 11 b7 0c				ld de, .mdown 
0c3d cd c9 0b				call str_at_display 
0c40			 
0c40					; draw options to fill the screens with active item on line 1 
0c40					; if current option is 2 or more then display ^ in top 
0c40			 
0c40 3a 68 ea		.nodn:		ld a, (store_tmp2) 
0c43			;		cp 0 
0c43 b7					or a 
0c44 28 08				jr z, .noup 
0c46			 
0c46 3e 00				ld a, 0 
0c48 11 b5 0c				ld de, .mup 
0c4b cd c9 0b				call str_at_display 
0c4e			 
0c4e 3e 02		.noup:		ld a, 2 
0c50 11 b3 0c				ld de, .msel 
0c53 cd c9 0b				call str_at_display 
0c56			 
0c56					; if current option + 1 is not null then display V in bottom 
0c56					; get key 
0c56 cd d9 0b				call update_display 
0c59			 
0c59			 
0c59					; handle key 
0c59			 
0c59 cd ac 65				call cin_wait 
0c5c			 
0c5c fe 05				cp KEY_UP 
0c5e 28 2b				jr z, .mgoup 
0c60 fe 61				cp 'a' 
0c62 28 27				jr z, .mgoup 
0c64 fe 0a				cp KEY_DOWN 
0c66 28 31				jr z, .mgod 
0c68 fe 7a				cp 'z' 
0c6a 28 2d				jr z, .mgod 
0c6c fe 20				cp ' ' 
0c6e 28 33				jr z, .goend 
0c70 fe 0c				cp KEY_RIGHT 
0c72 28 2f				jr z, .goend 
0c74 fe 0d				cp KEY_CR 
0c76 28 2b				jr z, .goend 
0c78 fe 71				cp 'q' 
0c7a 28 0b				jr z, .goback 
0c7c			 
0c7c fe 0b				cp KEY_LEFT 
0c7e 28 07				jr z, .goback 
0c80 fe 08				cp KEY_BS 
0c82 28 03				jr z, .goback 
0c84 c3 f3 0b				jp .mloop 
0c87			 
0c87			.goback: 
0c87 3e 00			ld a, 0 
0c89 18 1c			jr .goend2 
0c8b			 
0c8b				; move up one 
0c8b			.mgoup: 
0c8b 3a 68 ea				ld a, (store_tmp2) 
0c8e			;		cp 0 
0c8e b7					or a 
0c8f ca f3 0b				jp z, .mloop 
0c92 3d					dec a 
0c93 32 68 ea				ld (store_tmp2), a 
0c96 c3 f3 0b				jp .mloop 
0c99			 
0c99				; move down one 
0c99			.mgod: 
0c99 3a 68 ea				ld a, (store_tmp2) 
0c9c 3c					inc a 
0c9d 32 68 ea				ld (store_tmp2), a 
0ca0 c3 f3 0b				jp .mloop 
0ca3			 
0ca3			 
0ca3			.goend: 
0ca3					; get selected item number 
0ca3			 
0ca3 3a 68 ea				ld a, (store_tmp2) 
0ca6 3c					inc a 
0ca7			 
0ca7			.goend2: 
0ca7 f5					push af 
0ca8			 
0ca8					; restore active fb 
0ca8					; TODO BUG assumes fb1 
0ca8			 
0ca8 21 07 ed				ld hl, display_fb1 
0cab 22 c3 eb				ld (display_fb_active), hl 
0cae			 
0cae					; restore main regs 
0cae			 
0cae			 
0cae cd d9 0b				call update_display 
0cb1			 
0cb1 f1					pop af 
0cb2			 
0cb2 c9				ret 
0cb3			 
0cb3 .. 00		.msel:   db ">",0 
0cb5 .. 00		.mup:   db "^",0 
0cb7 .. 00		.mdown:   db "v",0 
0cb9			 
0cb9			 
0cb9			; eof 
0cb9			 
# End of file firmware_display.asm
0cb9			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cb9			; random number generators 
0cb9			 
0cb9			 
0cb9			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cb9			 
0cb9			 
0cb9			;-----> Generate a random number 
0cb9			; output a=answer 0<=a<=255 
0cb9			; all registers are preserved except: af 
0cb9			random: 
0cb9 e5			        push    hl 
0cba d5			        push    de 
0cbb 2a a2 eb		        ld      hl,(randData) 
0cbe ed 5f		        ld      a,r 
0cc0 57			        ld      d,a 
0cc1 5e			        ld      e,(hl) 
0cc2 19			        add     hl,de 
0cc3 85			        add     a,l 
0cc4 ac			        xor     h 
0cc5 22 a2 eb		        ld      (randData),hl 
0cc8 d1			        pop     de 
0cc9 e1			        pop     hl 
0cca c9			        ret 
0ccb			 
0ccb			 
0ccb			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ccb			 
0ccb			 
0ccb			 
0ccb			;------LFSR------ 
0ccb			;James Montelongo 
0ccb			;optimized by Spencer Putt 
0ccb			;out: 
0ccb			; a = 8 bit random number 
0ccb			RandLFSR: 
0ccb 21 a8 eb		        ld hl,LFSRSeed+4 
0cce 5e			        ld e,(hl) 
0ccf 23			        inc hl 
0cd0 56			        ld d,(hl) 
0cd1 23			        inc hl 
0cd2 4e			        ld c,(hl) 
0cd3 23			        inc hl 
0cd4 7e			        ld a,(hl) 
0cd5 47			        ld b,a 
0cd6 cb 13		        rl e  
0cd8 cb 12			rl d 
0cda cb 11		        rl c  
0cdc 17				rla 
0cdd cb 13		        rl e  
0cdf cb 12			rl d 
0ce1 cb 11		        rl c  
0ce3 17				rla 
0ce4 cb 13		        rl e  
0ce6 cb 12			rl d 
0ce8 cb 11		        rl c  
0cea 17				rla 
0ceb 67			        ld h,a 
0cec cb 13		        rl e  
0cee cb 12			rl d 
0cf0 cb 11		        rl c  
0cf2 17				rla 
0cf3 a8			        xor b 
0cf4 cb 13		        rl e  
0cf6 cb 12			rl d 
0cf8 ac			        xor h 
0cf9 a9			        xor c 
0cfa aa			        xor d 
0cfb 21 aa eb		        ld hl,LFSRSeed+6 
0cfe 11 ab eb		        ld de,LFSRSeed+7 
0d01 01 07 00		        ld bc,7 
0d04 ed b8		        lddr 
0d06 12			        ld (de),a 
0d07 c9			        ret 
0d08			 
0d08			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d08			 
0d08			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d08			 
0d08			 
0d08			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d08			 
0d08			prng16: 
0d08			;Inputs: 
0d08			;   (seed1) contains a 16-bit seed value 
0d08			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d08			;Outputs: 
0d08			;   HL is the result 
0d08			;   BC is the result of the LCG, so not that great of quality 
0d08			;   DE is preserved 
0d08			;Destroys: 
0d08			;   AF 
0d08			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d08			;160cc 
0d08			;26 bytes 
0d08 2a 9c eb		    ld hl,(seed1) 
0d0b 44			    ld b,h 
0d0c 4d			    ld c,l 
0d0d 29			    add hl,hl 
0d0e 29			    add hl,hl 
0d0f 2c			    inc l 
0d10 09			    add hl,bc 
0d11 22 9c eb		    ld (seed1),hl 
0d14 2a 9a eb		    ld hl,(seed2) 
0d17 29			    add hl,hl 
0d18 9f			    sbc a,a 
0d19 e6 2d		    and %00101101 
0d1b ad			    xor l 
0d1c 6f			    ld l,a 
0d1d 22 9a eb		    ld (seed2),hl 
0d20 09			    add hl,bc 
0d21 c9			    ret 
0d22			 
0d22			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d22			 
0d22			rand32: 
0d22			;Inputs: 
0d22			;   (seed1_0) holds the lower 16 bits of the first seed 
0d22			;   (seed1_1) holds the upper 16 bits of the first seed 
0d22			;   (seed2_0) holds the lower 16 bits of the second seed 
0d22			;   (seed2_1) holds the upper 16 bits of the second seed 
0d22			;   **NOTE: seed2 must be non-zero 
0d22			;Outputs: 
0d22			;   HL is the result 
0d22			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d22			;Destroys: 
0d22			;   AF 
0d22			;Tested and passes all CAcert tests 
0d22			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d22			;it has a period of 18,446,744,069,414,584,320 
0d22			;roughly 18.4 quintillion. 
0d22			;LFSR taps: 0,2,6,7  = 11000101 
0d22			;291cc 
0d22			;seed1_0=$+1 
0d22			;    ld hl,12345 
0d22			;seed1_1=$+1 
0d22			;    ld de,6789 
0d22			;    ld b,h 
0d22			;    ld c,l 
0d22			;    add hl,hl \ rl e \ rl d 
0d22			;    add hl,hl \ rl e \ rl d 
0d22			;    inc l 
0d22			;    add hl,bc 
0d22			;    ld (seed1_0),hl 
0d22			;    ld hl,(seed1_1) 
0d22			;    adc hl,de 
0d22			;    ld (seed1_1),hl 
0d22			;    ex de,hl 
0d22			;seed2_0=$+1 
0d22			;    ld hl,9876 
0d22			;seed2_1=$+1 
0d22			;    ld bc,54321 
0d22			;    add hl,hl \ rl c \ rl b 
0d22			;    ld (seed2_1),bc 
0d22			;    sbc a,a 
0d22			;    and %11000101 
0d22			;    xor l 
0d22			;    ld l,a 
0d22			;    ld (seed2_0),hl 
0d22			;    ex de,hl 
0d22			;    add hl,bc 
0d22			;    ret 
0d22			; 
0d22			 
0d22			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d22			; 20 bytes, 86 cycles (excluding ret) 
0d22			 
0d22			; returns   hl = pseudorandom number 
0d22			; corrupts   a 
0d22			 
0d22			; generates 16-bit pseudorandom numbers with a period of 65535 
0d22			; using the xorshift method: 
0d22			 
0d22			; hl ^= hl << 7 
0d22			; hl ^= hl >> 9 
0d22			; hl ^= hl << 8 
0d22			 
0d22			; some alternative shift triplets which also perform well are: 
0d22			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d22			 
0d22			;  org 32768 
0d22			 
0d22			xrnd: 
0d22 2a a0 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d25 3e 00		  ld a,0 
0d27 bd			  cp l 
0d28 20 02		  jr nz, .xrnd1 
0d2a 2e 01		  ld l, 1 
0d2c			.xrnd1: 
0d2c			 
0d2c 7c			  ld a,h 
0d2d 1f			  rra 
0d2e 7d			  ld a,l 
0d2f 1f			  rra 
0d30 ac			  xor h 
0d31 67			  ld h,a 
0d32 7d			  ld a,l 
0d33 1f			  rra 
0d34 7c			  ld a,h 
0d35 1f			  rra 
0d36 ad			  xor l 
0d37 6f			  ld l,a 
0d38 ac			  xor h 
0d39 67			  ld h,a 
0d3a			 
0d3a 22 a0 eb		  ld (xrandc),hl 
0d3d			 
0d3d c9			  ret 
0d3e			;  
0d3e			 
0d3e			 
0d3e			;;;; int maths 
0d3e			 
0d3e			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d3e			; Divide 16-bit values (with 16-bit result) 
0d3e			; In: Divide BC by divider DE 
0d3e			; Out: BC = result, HL = rest 
0d3e			; 
0d3e			Div16: 
0d3e 21 00 00		    ld hl,0 
0d41 78			    ld a,b 
0d42 06 08		    ld b,8 
0d44			Div16_Loop1: 
0d44 17			    rla 
0d45 ed 6a		    adc hl,hl 
0d47 ed 52		    sbc hl,de 
0d49 30 01		    jr nc,Div16_NoAdd1 
0d4b 19			    add hl,de 
0d4c			Div16_NoAdd1: 
0d4c 10 f6		    djnz Div16_Loop1 
0d4e 17			    rla 
0d4f 2f			    cpl 
0d50 47			    ld b,a 
0d51 79			    ld a,c 
0d52 48			    ld c,b 
0d53 06 08		    ld b,8 
0d55			Div16_Loop2: 
0d55 17			    rla 
0d56 ed 6a		    adc hl,hl 
0d58 ed 52		    sbc hl,de 
0d5a 30 01		    jr nc,Div16_NoAdd2 
0d5c 19			    add hl,de 
0d5d			Div16_NoAdd2: 
0d5d 10 f6		    djnz Div16_Loop2 
0d5f 17			    rla 
0d60 2f			    cpl 
0d61 41			    ld b,c 
0d62 4f			    ld c,a 
0d63 c9			ret 
0d64			 
0d64			 
0d64			;http://z80-heaven.wikidot.com/math 
0d64			; 
0d64			;Inputs: 
0d64			;     DE and A are factors 
0d64			;Outputs: 
0d64			;     A is not changed 
0d64			;     B is 0 
0d64			;     C is not changed 
0d64			;     DE is not changed 
0d64			;     HL is the product 
0d64			;Time: 
0d64			;     342+6x 
0d64			; 
0d64			Mult16: 
0d64			 
0d64 06 08		     ld b,8          ;7           7 
0d66 21 00 00		     ld hl,0         ;10         10 
0d69 29			       add hl,hl     ;11*8       88 
0d6a 07			       rlca          ;4*8        32 
0d6b 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d6d 19			         add hl,de   ;--         -- 
0d6e 10 f9		       djnz $-5      ;13*7+8     99 
0d70 c9			ret 
0d71			 
0d71			; 
0d71			; Square root of 16-bit value 
0d71			; In:  HL = value 
0d71			; Out:  D = result (rounded down) 
0d71			; 
0d71			;Sqr16: 
0d71			;    ld de,#0040 
0d71			;    ld a,l 
0d71			;    ld l,h 
0d71			;    ld h,d 
0d71			;    or a 
0d71			;    ld b,8 
0d71			;Sqr16_Loop: 
0d71			;    sbc hl,de 
0d71			;    jr nc,Sqr16_Skip 
0d71			;    add hl,de 
0d71			;Sqr16_Skip: 
0d71			;    ccf 
0d71			;    rl d 
0d71			;    add a,a 
0d71			;    adc hl,hl 
0d71			;    add a,a 
0d71			;    adc hl,hl 
0d71			;    djnz Sqr16_Loop 
0d71			;    ret 
0d71			; 
0d71			; 
0d71			; Divide 8-bit values 
0d71			; In: Divide E by divider C 
0d71			; Out: A = result, B = rest 
0d71			; 
0d71			Div8: 
0d71 af			    xor a 
0d72 06 08		    ld b,8 
0d74			Div8_Loop: 
0d74 cb 13		    rl e 
0d76 17			    rla 
0d77 91			    sub c 
0d78 30 01		    jr nc,Div8_NoAdd 
0d7a 81			    add a,c 
0d7b			Div8_NoAdd: 
0d7b 10 f7		    djnz Div8_Loop 
0d7d 47			    ld b,a 
0d7e 7b			    ld a,e 
0d7f 17			    rla 
0d80 2f			    cpl 
0d81 c9			    ret 
0d82			 
0d82			; 
0d82			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d82			; In: Multiply A with DE 
0d82			; Out: HL = result 
0d82			; 
0d82			Mult12U: 
0d82 2e 00		    ld l,0 
0d84 87			    add a,a 
0d85 30 01		    jr nc,Mult12U_NoAdd0 
0d87 19			    add hl,de 
0d88			Mult12U_NoAdd0: 
0d88 29			    add hl,hl 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd1 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd1: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd2 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd2: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd3 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd3: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd4 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd4: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd5 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd5: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd6 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd6: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 d0			    ret nc 
0da9 19			    add hl,de 
0daa c9			    ret 
0dab			 
0dab			; 
0dab			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dab			; In: Multiply A with DE 
0dab			;      Put lowest value in A for most efficient calculation 
0dab			; Out: HL = result 
0dab			; 
0dab			Mult12R: 
0dab 21 00 00		    ld hl,0 
0dae			Mult12R_Loop: 
0dae cb 3f		    srl a 
0db0 30 01		    jr nc,Mult12R_NoAdd 
0db2 19			    add hl,de 
0db3			Mult12R_NoAdd: 
0db3 cb 23		    sla e 
0db5 cb 12		    rl d 
0db7 b7			    or a 
0db8 c2 ae 0d		    jp nz,Mult12R_Loop 
0dbb c9			    ret 
0dbc			 
0dbc			; 
0dbc			; Multiply 16-bit values (with 32-bit result) 
0dbc			; In: Multiply BC with DE 
0dbc			; Out: BCHL = result 
0dbc			; 
0dbc			Mult32: 
0dbc 79			    ld a,c 
0dbd 48			    ld c,b 
0dbe 21 00 00		    ld hl,0 
0dc1 06 10		    ld b,16 
0dc3			Mult32_Loop: 
0dc3 29			    add hl,hl 
0dc4 17			    rla 
0dc5 cb 11		    rl c 
0dc7 30 07		    jr nc,Mult32_NoAdd 
0dc9 19			    add hl,de 
0dca ce 00		    adc a,0 
0dcc d2 d0 0d		    jp nc,Mult32_NoAdd 
0dcf 0c			    inc c 
0dd0			Mult32_NoAdd: 
0dd0 10 f1		    djnz Mult32_Loop 
0dd2 41			    ld b,c 
0dd3 4f			    ld c,a 
0dd4 c9			    ret 
0dd5			 
0dd5			 
0dd5			 
0dd5			; 
0dd5			; Multiply 8-bit values 
0dd5			; In:  Multiply H with E 
0dd5			; Out: HL = result 
0dd5			; 
0dd5			Mult8: 
0dd5 16 00		    ld d,0 
0dd7 6a			    ld l,d 
0dd8 06 08		    ld b,8 
0dda			Mult8_Loop: 
0dda 29			    add hl,hl 
0ddb 30 01		    jr nc,Mult8_NoAdd 
0ddd 19			    add hl,de 
0dde			Mult8_NoAdd: 
0dde 10 fa		    djnz Mult8_Loop 
0de0 c9			    ret 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			 
0de1			;;http://z80-heaven.wikidot.com/math 
0de1			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de1			; 
0de1			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de1			;     ld a,16        ;7 
0de1			;     ld hl,0        ;10 
0de1			;     jp $+5         ;10 
0de1			;.DivLoop: 
0de1			;       add hl,bc    ;-- 
0de1			;       dec a        ;64 
0de1			;       jr z,.DivLoopEnd        ;86 
0de1			; 
0de1			;       sla e        ;128 
0de1			;       rl d         ;128 
0de1			;       adc hl,hl    ;240 
0de1			;       sbc hl,bc    ;240 
0de1			;       jr nc,.DivLoop ;23|21 
0de1			;       inc e        ;-- 
0de1			;       jp .DivLoop+1 
0de1			; 
0de1			;.DivLoopEnd: 
0de1			 
0de1			;HL_Div_C: 
0de1			;Inputs: 
0de1			;     HL is the numerator 
0de1			;     C is the denominator 
0de1			;Outputs: 
0de1			;     A is the remainder 
0de1			;     B is 0 
0de1			;     C is not changed 
0de1			;     DE is not changed 
0de1			;     HL is the quotient 
0de1			; 
0de1			;       ld b,16 
0de1			;       xor a 
0de1			;         add hl,hl 
0de1			;         rla 
0de1			;         cp c 
0de1			;         jr c,$+4 
0de1			;           inc l 
0de1			;           sub c 
0de1			;         djnz $-7 
0de1			 
0de1			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de1			 
0de1			addatohl: 
0de1 85			    add   a, l    ; A = A+L 
0de2 6f			    ld    l, a    ; L = A+L 
0de3 8c			    adc   a, h    ; A = A+L+H+carry 
0de4 95			    sub   l       ; A = H+carry 
0de5 67			    ld    h, a    ; H = H+carry 
0de6 c9			ret 
0de7			 
0de7			addatode: 
0de7 83			    add   a, e    ; A = A+L 
0de8 5f			    ld    e, a    ; L = A+L 
0de9 8a			    adc   a, d    ; A = A+L+H+carry 
0dea 93			    sub   e       ; A = H+carry 
0deb 57			    ld    d, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			 
0ded			addatobc: 
0ded 81			    add   a, c    ; A = A+L 
0dee 4f			    ld    c, a    ; L = A+L 
0def 88			    adc   a, b    ; A = A+L+H+carry 
0df0 91			    sub   c       ; A = H+carry 
0df1 47			    ld    b, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			subafromhl: 
0df3			   ; If A=0 do nothing 
0df3			    ; Otherwise flip A's sign. Since 
0df3			    ; the upper byte becomes -1, also 
0df3			    ; substract 1 from H. 
0df3 ed 44		    neg 
0df5 ca fe 0d		    jp    z, Skip 
0df8 25			    dec   h 
0df9			     
0df9			    ; Now add the low byte as usual 
0df9			    ; Two's complement takes care of 
0df9			    ; ensuring the result is correct 
0df9 85			    add   a, l 
0dfa 6f			    ld    l, a 
0dfb 8c			    adc   a, h 
0dfc 95			    sub   l 
0dfd 67			    ld    h, a 
0dfe			Skip: 
0dfe c9				ret 
0dff			 
0dff			 
0dff			; compare hl and de 
0dff			; returns:  
0dff			; if hl = de, z=1, s=0, c0=0 
0dff			; if hl > de, z=0, s=0, c=0 
0dff			; if hl < de, z=0, s=1, c=1 
0dff			cmp16:	 
0dff b7				or a 
0e00 ed 52			sbc hl,de 
0e02 e0				ret po 
0e03 7c				ld a,h 
0e04 1f				rra 
0e05 ee 40			xor 01000000B 
0e07 37				scf 
0e08 8f				adc a,a 
0e09 c9				ret 
0e0a			 
0e0a			 
0e0a			; test if hl contains zero   - A is destroyed 
0e0a			 
0e0a			ishlzero:    
0e0a b7				or a     ; reset flags 
0e0b 7c				ld a, h 
0e0c b5				or l        	 
0e0d			 
0e0d c9				ret 
0e0e			 
0e0e			 
0e0e			 
0e0e			 
0e0e			if FORTH_ENABLE_FLOATMATH 
0e0e			;include "float/bbcmath.z80" 
0e0e			include "float/lpfpcalc.asm" 
0e0e			endif 
0e0e			 
0e0e			 
0e0e			; eof 
0e0e			 
# End of file firmware_maths.asm
0e0e			include "firmware_strings.asm"   ; string handling  
0e0e			 
0e0e			 
0e0e			; TODO string len 
0e0e			; input text string, end on cr with zero term 
0e0e			; a offset into frame buffer to start prompt 
0e0e			; d is max length 
0e0e			; e is display size TODO 
0e0e			; c is current cursor position 
0e0e			; hl is ptr to where string will be stored and edited directly 
0e0e			 
0e0e			 
0e0e			; TODO check limit of buffer for new inserts 
0e0e			; TODO check insert does not push beyond buffer 
0e0e			; TODO scroll in a limited display area 
0e0e			; TODO scroll whole screen on page wrap 
0e0e			 
0e0e			 
0e0e			; TODO use LCD cursor? 
0e0e			 
0e0e			EDIT_V1: equ 0 
0e0e			EDIT_V2: equ 1 
0e0e			 
0e0e			 
0e0e			 
0e0e			if EDIT_V2 
0e0e			input_str: 
0e0e			 
0e0e 32 5b ee			    	ld (input_at_pos),a      ; save display position to start 
0e11			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e11 22 5e ee				ld (input_start), hl     ; save ptr to buffer 
0e14			;		ld a, c 
0e14			;		call addatohl 
0e14			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e14 7a					ld a,d 
0e15 32 5d ee			        ld (input_size), a       ; save length of input area 
0e18 79					ld a, c 
0e19 32 4c ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e1c 7b					ld a,e 
0e1d 32 5c ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e20			 
0e20			 
0e20					; add a trailing space to make screen refresh nicer 
0e20			 
0e20					;ld hl, (input_start) 
0e20					;push hl 
0e20					;ld a, 0 
0e20					;call strlent 
0e20					;ld a, l 
0e20					;pop hl 
0e20					;call addatohl 
0e20					;dec hl 
0e20					;ld a, ' ' 
0e20					;ld (hl), a 
0e20					;inc hl 
0e20					;ld (hl), a 
0e20					;inc hl 
0e20					;ld a, 0 
0e20					;ld (hl), a 
0e20			 
0e20			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e20					; init cursor shape if not set by the cin routines 
0e20 21 b8 eb				ld hl, cursor_shape 
0e23			if BASE_KEV 
0e23			;		ld a, 255 
0e23					ld (hl), 255 
0e23			else 
0e23					;ld a, '#' 
0e23 36 23				ld (hl), '#' 
0e25			endif 
0e25 23					inc hl 
0e26			;		ld a, 0 
0e26 36 00				ld (hl), 0 
0e28			 
0e28 3e 09				ld a, CUR_BLINK_RATE 
0e2a 32 57 ee				ld (input_cur_flash), a 
0e2d 3e 01				ld a, 1 
0e2f 32 56 ee				ld (input_cur_onoff),a 
0e32			.inmain:	 
0e32			 
0e32 cd 53 0f				call input_disp_ref 
0e35			 
0e35					; save current length of string 
0e35			 
0e35 2a 5e ee				ld hl, (input_start) 
0e38 3e 00				ld a, 0 
0e3a cd 44 11				call strlent 
0e3d 7d					ld a,l 
0e3e 32 51 ee				ld (input_len), a 
0e41			 
0e41					;call input_disp_oncur 
0e41			 
0e41					; display current state of input buffer 
0e41			 
0e41					; clean any backspace chars 
0e41			 
0e41 3e 20				ld a, " " 
0e43 32 b8 e2				ld (scratch),a 
0e46 3e 00				ld a, 0 
0e48 32 b9 e2				ld (scratch+1),a 
0e4b 3a 5b ee				ld a,(input_at_pos) 
0e4e 85					add l 
0e4f 11 b8 e2				ld de, scratch 
0e52 cd c9 0b				call str_at_display 
0e55			 
0e55					; pause 1ms 
0e55			 
0e55 3e 01				ld a, 1 
0e57 cd d5 0a				call aDelayInMS 
0e5a			 
0e5a			; display cursor if visible on this cycle 
0e5a			 
0e5a					; dec flash counter 
0e5a 3a 57 ee				ld a, (input_cur_flash) 
0e5d 3d					dec a 
0e5e 32 57 ee				ld (input_cur_flash), a 
0e61			;		cp 0 
0e61 b7					or a 
0e62 20 0d				jr nz, .inochgstate 
0e64			 
0e64			 
0e64					; reset on change of state 
0e64 3e 09				ld a, CUR_BLINK_RATE 
0e66 32 57 ee				ld (input_cur_flash), a 
0e69			 
0e69					; change state 
0e69 3a 56 ee				ld a,(input_cur_onoff) 
0e6c ed 44				neg 
0e6e 32 56 ee				ld (input_cur_onoff),a 
0e71			 
0e71			 
0e71			 
0e71			 
0e71					; TODO is cursor visible? 
0e71					; TODO if so then over write the char at curspos pos with the cursor shape 
0e71			 
0e71								 
0e71			 
0e71			.inochgstate: 
0e71 3a 56 ee				ld a,(input_cur_onoff) 
0e74 fe ff				cp 255 
0e76 28 0e				jr z, .skipcursor 
0e78 3a 5b ee				ld a, (input_at_pos) 
0e7b 47					ld b, a 
0e7c 3a 4c ee				ld a, (input_cursor) 
0e7f 80					add b 
0e80 11 b8 eb				ld de, cursor_shape 
0e83					 
0e83 cd c9 0b				call str_at_display 
0e86			 
0e86			.skipcursor: 
0e86				if DEBUG_INPUTV2 
0e86			 
0e86					ld a,(input_at_pos) 
0e86					ld hl, LFSRSeed 
0e86					call hexout 
0e86					ld a, (input_cursor) 
0e86					ld hl, LFSRSeed+2 
0e86					call hexout 
0e86					ld a,(input_size) 
0e86					ld hl, LFSRSeed+4 
0e86					call hexout 
0e86			 
0e86					ld a,(input_cur_onoff) 
0e86					ld hl, LFSRSeed+6 
0e86					call hexout 
0e86			 
0e86					ld a,(input_cur_flash) 
0e86					ld hl, LFSRSeed+8 
0e86					call hexout 
0e86			 
0e86					ld a,(input_len) 
0e86					ld hl, LFSRSeed+10 
0e86					call hexout 
0e86					ld hl, LFSRSeed+12 
0e86			;		ld a, 0 
0e86					ld (hl),0 
0e86					ld a, display_row_4 
0e86					ld de, LFSRSeed 
0e86					call str_at_display 
0e86				endif 
0e86 cd d9 0b				call update_display 
0e89			 
0e89					; TODO keyboard processing 
0e89			 
0e89			if BASE_CPM 
0e89 cd ac 65				call cin_wait 
0e8c			else 
0e8c					call cin    ; _wait 
0e8c			endif 
0e8c			;		cp 0 
0e8c b7					or a 
0e8d ca 32 0e				jp z, .inmain 
0e90			 
0e90 fe 0b				cp KEY_LEFT    ; cursor left 
0e92 ca 45 0f				jp z, input_left 
0e95				 
0e95 fe 0c				cp KEY_RIGHT      ; cursor right 
0e97 ca 4c 0f				jp z, input_right 
0e9a			 
0e9a fe 0d				cp KEY_CR 
0e9c c8					ret z 
0e9d			 
0e9d fe 08				cp KEY_BS 
0e9f ca b7 0f				jp z, input_delchar 
0ea2			 
0ea2 fe 06				cp KEY_NEXTWORD 
0ea4 ca cb 0e				jp z, input_nxtword 
0ea7			 
0ea7 fe 07				cp KEY_PREVWORD 
0ea9 ca f0 0e				jp z, input_prvword 
0eac			 
0eac fe 0e				cp KEY_HOME    ; jump to start of line 
0eae 20 08				jr nz, .ikh 
0eb0 3e 00				ld a, 0 
0eb2 32 4c ee				ld (input_cursor), a 
0eb5 ca 32 0e				jp z, .inmain 
0eb8			.ikh: 
0eb8			 
0eb8 fe 0f				cp KEY_END     ; jump to end of line 
0eba 20 09				jr nz, .ike 
0ebc 3a 51 ee				ld a, (input_len) 
0ebf 32 4c ee				ld (input_cursor),a 
0ec2 ca 32 0e				jp z, .inmain 
0ec5			.ike: 
0ec5 fe 05			        cp KEY_UP      ; recall last command 
0ec7 c8					ret z 
0ec8			;jr nz, .irec 
0ec8			; TODO next word 
0ec8			; TODO prev word 
0ec8			;  
0ec8			; 
0ec8			;	ld hl, scratch 
0ec8			;	ld de, os_last_cmd 
0ec8			;	call strcpy 
0ec8			;		jp  .inmain 
0ec8			.irec: 
0ec8			;		jr .instr1 
0ec8			 
0ec8			 
0ec8			 
0ec8					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ec8			 
0ec8			; TODO return if any special keys are given 
0ec8			;		ld l, a 
0ec8			;		ld a, 28 ; KEY_F12   ; 27 
0ec8			;		sub l 
0ec8			;		ret m 
0ec8			;		ld a, l 
0ec8					; if no special key then insert as a char 
0ec8			 
0ec8 c3 8c 0f				jp input_inschr 
0ecb			 
0ecb				 
0ecb			input_nxtword: 
0ecb				; jump to start next word after the cursor 
0ecb			 
0ecb			.insknwn:	 
0ecb cd 82 0f				call input_curptr	 
0ece 7e					ld a,(hl)	 
0ecf			;		cp 0 
0ecf b7					or a 
0ed0 ca 32 0e				jp z, .inmain    ; end of string 
0ed3			 
0ed3			; if we are on a word, then move off of it 
0ed3			 
0ed3 fe 20				cp ' ' 
0ed5 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ed7 21 4c ee				ld hl, input_cursor 
0eda 34					inc (hl) 
0edb 18 ee				jr .insknwn 
0edd			 
0edd			.inspace: 
0edd			 
0edd cd 82 0f				call input_curptr	 
0ee0 7e					ld a,(hl)	 
0ee1			;		cp 0 
0ee1 b7					or a 
0ee2 ca 32 0e				jp z, .inmain    ; end of string 
0ee5			 
0ee5			; if we are on a word, then move off of it 
0ee5			 
0ee5 fe 20				cp ' ' 
0ee7 c2 32 0e				jp nz, .inmain     ; we are on non space so at next word 
0eea 21 4c ee				ld hl, input_cursor 
0eed 34					inc (hl) 
0eee 18 ed				jr .inspace 
0ef0			 
0ef0			 
0ef0			 
0ef0			 
0ef0			input_prvword: 
0ef0				; jump to the start of previous word before the cursor 
0ef0			 
0ef0			; where are we to start with currently? 
0ef0			 
0ef0 cd 82 0f				call input_curptr	 
0ef3 7e					ld a, (hl) 
0ef4 fe 20				cp ' ' 
0ef6 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0ef8			 
0ef8			 
0ef8			 
0ef8			.inskpwn:	 
0ef8 3a 4c ee				ld a,(input_cursor) 
0efb			;		cp 0 
0efb b7					or a 
0efc ca 32 0e				jp z, .inmain    ; start of string 
0eff			 
0eff			;if we are on a word, then move off of it 
0eff			 
0eff cd 82 0f				call input_curptr	 
0f02 7e					ld a, (hl) 
0f03 fe 20				cp ' ' 
0f05 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f07					;jp z, .inmain    ; start of string 
0f07 21 4c ee				ld hl, input_cursor 
0f0a 35					dec (hl) 
0f0b 18 eb				jr .inskpwn 
0f0d			.iwstart: 
0f0d 21 4c ee				ld hl, input_cursor 
0f10 34					inc (hl) 
0f11 c3 32 0e				jp .inmain 
0f14					 
0f14			 
0f14			.inspacep: 
0f14			 
0f14					;jp .inmain    ; start of string 
0f14			 
0f14			 
0f14			 
0f14 3a 4c ee				ld a,(input_cursor) 
0f17			;		cp 0 
0f17 b7					or a 
0f18 ca 32 0e				jp z, .inmain    ; start of string 
0f1b			 
0f1b			; if we are on a word, then move off of it 
0f1b			 
0f1b cd 82 0f				call input_curptr	 
0f1e 7e					ld a, (hl) 
0f1f fe 20				cp ' ' 
0f21 c2 2a 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f24 21 4c ee				ld hl, input_cursor 
0f27 35					dec (hl) 
0f28 18 ea				jr .inspacep 
0f2a			 
0f2a			 
0f2a			.incharp:	 
0f2a					; eat the word to get to the start 
0f2a 3a 4c ee				ld a,(input_cursor) 
0f2d			;		cp 0 
0f2d b7					or a 
0f2e ca 32 0e				jp z, .inmain    ; start of string 
0f31			 
0f31			; if we are on a word, then move off of it 
0f31			 
0f31 cd 82 0f				call input_curptr	 
0f34 7e					ld a, (hl) 
0f35 fe 20				cp ' ' 
0f37 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f39 21 4c ee				ld hl, input_cursor 
0f3c 35					dec (hl) 
0f3d 18 eb				jr .incharp 
0f3f			.ipwordst: 
0f3f					; at space before the prev word so reposition over it 
0f3f 21 4c ee				ld hl, input_cursor 
0f42 34					inc (hl) 
0f43 18 b3				jr .inskpwn 
0f45					 
0f45			 
0f45			 
0f45			input_left: 
0f45				; move cursor left 
0f45 21 4c ee			ld hl, input_cursor 
0f48 35				dec (hl) 
0f49			;	cp 0 
0f49			;	jp z, .inmain    ; ignore left as at the start of the string 
0f49 c3 32 0e			jp .inmain 
0f4c			 
0f4c			input_right: 
0f4c				; move cursor right 
0f4c				 
0f4c				;ld a, (input_size) 
0f4c				;ld b, a 
0f4c 21 4c ee			ld hl, input_cursor 
0f4f 34				inc (hl) 
0f50				;dec b 
0f50				;cp 0 
0f50				;jp z, .inmain   ; ignore as at end of the string buffer 
0f50				;ld a, b 
0f50				;inc a 
0f50				;ld (input_cursor), a 
0f50 c3 32 0e			jp .inmain 
0f53			 
0f53			 
0f53			 
0f53			input_disp_ref: 
0f53				; display the text from start of buffer (ie full refresh) 
0f53 3a 5b ee			ld a, (input_at_pos) 
0f56 2a 5e ee			ld hl,(input_start) 
0f59 eb				ex de, hl 
0f5a cd c9 0b			call str_at_display  
0f5d c9				ret 
0f5e			input_disp_oncur: 
0f5e				; display the text from cursor position to end of buffer 
0f5e				; TODO position start of string at cursor position on screen 
0f5e				; TODO draw from that point on 
0f5e 3a 4c ee			ld a, (input_cursor) 
0f61 47				ld b, a 
0f62 3a 5b ee			ld a, (input_at_pos) 
0f65 80				add b 
0f66 48				ld c, b     ; save a 
0f67 78				ld a, b     ; inc string start for cursor 
0f68 2a 5e ee			ld hl,(input_start) 
0f6b cd e1 0d			call addatohl 
0f6e eb				ex de, hl 
0f6f 79				ld a, c 
0f70 cd c9 0b			call str_at_display  
0f73 c9				ret 
0f74			 
0f74			input_nxtw: 
0f74				; Find next word 
0f74 c9				ret 
0f75			 
0f75			input_prvw: 
0f75				; Find previous word 
0f75 c9				ret 
0f76			 
0f76			input_lenrem:   
0f76				; Calculate the length of string remaining from current cursor 
0f76				; position to end of buffer (exc null term) 
0f76				 
0f76 3a 4c ee			ld a, (input_cursor) 
0f79 4f				ld c, a 
0f7a 3a 5d ee			ld a, (input_size) 
0f7d 91				sub c 
0f7e 06 00			ld b, 0 
0f80 0d				dec c 
0f81 c9				ret	 
0f82			 
0f82			input_curptr: 
0f82				; calc address of the character under the cursor 
0f82				 
0f82 2a 5e ee			ld hl, (input_start) 
0f85 3a 4c ee			ld a, (input_cursor) 
0f88 cd e1 0d			call addatohl 
0f8b c9				ret 
0f8c			 
0f8c			input_inschr: 
0f8c				; Insert char at cursor position 
0f8c f5				push af   ; save char 
0f8d				;call input_lenrem    ; get bc length of remaining string 
0f8d			 
0f8d				 
0f8d cd 82 0f			call input_curptr 
0f90			;	ld hl, (input_start) 
0f90			;	ld a, (input_cursor) 
0f90			;	call addatohl 
0f90				;push hl   ; save to come back to 
0f90			 
0f90				; shift everything up one to end of buffer 
0f90			 
0f90				;push hl 
0f90				;dec de 
0f90				;inc de 
0f90			;	ldir 
0f90				 
0f90				;pop hl 
0f90			 
0f90				; are we adding to the end of line? 
0f90			 
0f90 3a 4c ee			ld a, (input_cursor) 
0f93 47				ld b, a 
0f94 3a 51 ee			ld a, (input_len) 
0f97 b8				cp b 
0f98 20 08			jr nz, .insmid   ; no, insert in middle of text 
0f9a			 
0f9a				; tack on the end of the line 
0f9a f1				pop af 
0f9b 77				ld (hl), a   ; save new char 
0f9c 23				inc hl 
0f9d			;	ld a, 0 
0f9d 36 00			ld (hl), 0 
0f9f c3 4c 0f			jp input_right 
0fa2				 
0fa2			.insmid: 
0fa2				; hl has insertion point so move everything up one to allow for insertion 
0fa2				;call input_shiftright 
0fa2 f1				pop af 
0fa3			 
0fa3			.shufinsmid: 
0fa3 47				ld b, a     ; b contains new char, c prev char at this position  
0fa4 7e				ld a, (hl) 
0fa5			 
0fa5			;	cp 0    ; at end of string need to then dump new char and add term 
0fa5 b7				or a 
0fa6 28 07			jr z, .endinsmid 
0fa8 4f				ld c, a 
0fa9 78				ld a, b 
0faa 77				ld (hl), a 
0fab 23				inc hl 
0fac 79				ld a, c 
0fad 18 f4			jr .shufinsmid 
0faf				 
0faf			 
0faf			 
0faf			 
0faf			.endinsmid: 
0faf 78				ld a, b 
0fb0 77				ld (hl), a 
0fb1 23				inc hl 
0fb2			;	ld a, 0 
0fb2 36 00			ld (hl), 0 
0fb4			 
0fb4			 
0fb4			;	ld (hl), a   ; save new char 
0fb4			 
0fb4 c3 4c 0f			jp input_right 
0fb7			 
0fb7			;input_shiftright: 
0fb7			;	; shift text right at cursor, hl has shift start 
0fb7			;	push hl 
0fb7			;	push de 
0fb7			;	push bc 
0fb7			; 
0fb7			; 
0fb7			;	; move to end of string past zero term 
0fb7			;	ld hl,(input_start) 
0fb7			;	ld a, (input_len) 
0fb7			;	call addatohl 
0fb7			;	inc hl 
0fb7			;;	inc hl 
0fb7			;;	inc hl 
0fb7			;	ld a, 0 
0fb7			;	ld (hl), a 
0fb7			;;	dec hl 
0fb7			;	 
0fb7			;;	ld (hl), a 
0fb7			;;	dec hl 
0fb7			; 
0fb7			;	push hl 
0fb7			;	pop de 
0fb7			;	inc de 
0fb7			;	 
0fb7			; 
0fb7			;;	ld hl,(input_start) 
0fb7			;;	ld a, (input_cursor) 
0fb7			;;	call addatohl 
0fb7			; 
0fb7			; 
0fb7			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fb7			;	call input_lenrem    ; get bc length of remaining string 
0fb7			;	;ld a, (input_cursor) 
0fb7			;	;ld c, a 
0fb7			;	ld a, (input_len) 
0fb7			;	cp 2 
0fb7			;	jr z, .iskipzero	 
0fb7			;	;sub c 
0fb7			;	;inc a 
0fb7			;	;ld c, a 
0fb7			;	;ld b, 0 
0fb7			;	inc c 
0fb7			;	inc c 
0fb7			;	; move data 
0fb7			;	lddr 
0fb7			;.iskipzero: 
0fb7			; 
0fb7			;	pop bc 
0fb7			;	pop de 
0fb7			;	pop hl 
0fb7			;	ret	 
0fb7			 
0fb7			input_delchar: 
0fb7				; Delete char at cursor position 
0fb7 cd 76 0f			call input_lenrem    ; get bc length of remaining string 
0fba 2a 5e ee			ld hl, (input_start) 
0fbd 3a 4c ee			ld a, (input_cursor) 
0fc0 cd e1 0d			call addatohl 
0fc3			 
0fc3 e5				push hl 
0fc4 d1				pop de 
0fc5 1b				dec de 
0fc6			 
0fc6			.dl:	 
0fc6 ed a0			ldi  
0fc8 7e				ld a, (hl) 
0fc9			;	cp 0 
0fc9 b7				or a 
0fca 28 02			jr z, .dldone 
0fcc 18 f8			jr .dl 
0fce			.dldone: 
0fce ed a0			ldi 
0fd0			 
0fd0 c3 45 0f			jp input_left 
0fd3			 
0fd3			 
0fd3			endif 
0fd3			 
0fd3			 
0fd3			 
0fd3			if EDIT_V1 
0fd3			input_str: 
0fd3			 
0fd3				    	ld (input_at_pos),a      ; save display position to start 
0fd3					add c 
0fd3					ld (input_at_cursor),a	; save draw pos of cursor 
0fd3					ld (input_start), hl     ; save ptr to buffer 
0fd3					ld a, c 
0fd3					call addatohl 
0fd3					ld (input_ptr), hl     ; save ptr to point under the cursor 
0fd3					ld a,d 
0fd3				        ld (input_size), a       ; save length of input area 
0fd3					ld a, c 
0fd3					ld (input_cursor),a      ; init cursor start position  
0fd3					ld a,e 
0fd3				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fd3					 
0fd3					 
0fd3			 
0fd3			;		ld a,(input_ptr) 
0fd3			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fd3			 
0fd3			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fd3					; init cursor shape if not set by the cin routines 
0fd3					ld hl, cursor_shape 
0fd3			if BASE_KEV 
0fd3					ld a, 255 
0fd3			else 
0fd3					ld a, '#' 
0fd3			endif 
0fd3					ld (hl), a 
0fd3					inc hl 
0fd3					ld a, 0 
0fd3					ld (hl), a 
0fd3			 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3					ld a, 1 
0fd3					ld (input_cur_onoff),a 
0fd3			 
0fd3			;	if DEBUG_INPUT 
0fd3			;		push af 
0fd3			;		ld a, 'I' 
0fd3			;		ld (debug_mark),a 
0fd3			;		pop af 
0fd3			;		CALLMONITOR 
0fd3			;	endif 
0fd3			.is1:		; main entry loop 
0fd3			 
0fd3			 
0fd3			 
0fd3					; pause 1ms 
0fd3			 
0fd3					ld a, 1 
0fd3					call aDelayInMS 
0fd3			 
0fd3					; dec flash counter 
0fd3					ld a, (input_cur_flash) 
0fd3					dec a 
0fd3					ld (input_cur_flash), a 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jr nz, .nochgstate 
0fd3			 
0fd3			 
0fd3					; change state 
0fd3					ld a,(input_cur_onoff) 
0fd3					neg 
0fd3					ld (input_cur_onoff),a 
0fd3			 
0fd3			 
0fd3					; reset on change of state 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3			.nochgstate: 
0fd3					 
0fd3					 
0fd3			 
0fd3					; display cursor  
0fd3			 
0fd3			;		ld hl, (input_start) 
0fd3			;		ld a, (input_cursor) 
0fd3			;		call addatohl 
0fd3			 
0fd3					; get char under cursor and replace with cursor 
0fd3			ld hl, (input_ptr) 
0fd3			;		ld a, (hl) 
0fd3			;		ld (input_under_cursor),a 
0fd3			;		ld a, '_' 
0fd3			;		ld (hl), a 
0fd3			 
0fd3					; display string 
0fd3			 
0fd3					ld de, (input_start) 
0fd3					ld a, (input_at_pos) 
0fd3					call str_at_display 
0fd3			;	        call update_display 
0fd3			 
0fd3					; find place to put the cursor 
0fd3			;		add h 
0fd3			;		ld l, display_row_1 
0fd3			;		sub l 
0fd3			; (input_at_pos) 
0fd3					;ld c, a 
0fd3			;		ld a, (input_cursor) 
0fd3			;		ld l, (input_at_pos) 
0fd3			;		;ld b, h 
0fd3			;		add l 
0fd3			;		ld (input_at_cursor),a 
0fd3					;ld l,h 
0fd3			 
0fd3			;		ld h, 0 
0fd3			;		ld l,(input_at_pos) 
0fd3			;		ld a, (input_cursor) 
0fd3			;		call addatohl 
0fd3			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd3			;		call subafromhl 
0fd3			;		ld a,l 
0fd3			;		ld (input_at_cursor), a 
0fd3			 
0fd3				if DEBUG_INPUT 
0fd3					ld a, (hardware_diag) 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jr z, .skip_input_diag 
0fd3			 
0fd3					ld a,(input_at_pos) 
0fd3					ld hl, LFSRSeed 
0fd3					call hexout 
0fd3					ld a, (input_cursor) 
0fd3					ld hl, LFSRSeed+2 
0fd3					call hexout 
0fd3					ld a,(input_at_cursor) 
0fd3					ld hl, LFSRSeed+4 
0fd3					call hexout 
0fd3			 
0fd3					ld a,(input_cur_onoff) 
0fd3					ld hl, LFSRSeed+6 
0fd3					call hexout 
0fd3			 
0fd3					ld a,(input_cur_flash) 
0fd3					ld hl, LFSRSeed+8 
0fd3					call hexout 
0fd3			 
0fd3					ld a,(input_len) 
0fd3					ld hl, LFSRSeed+10 
0fd3					call hexout 
0fd3					ld hl, LFSRSeed+12 
0fd3					ld a, 0 
0fd3					ld (hl),a 
0fd3					ld a, display_row_4 
0fd3					ld de, LFSRSeed 
0fd3					call str_at_display 
0fd3					.skip_input_diag: 
0fd3				endif 
0fd3			 
0fd3					; decide on if we are showing the cursor this time round 
0fd3			 
0fd3					ld a, (input_cur_onoff) 
0fd3					cp 255 
0fd3					jr z, .skipcur 
0fd3			 
0fd3			 
0fd3					ld a,(input_at_cursor) 
0fd3					ld de, cursor_shape 
0fd3					call str_at_display 
0fd3			 
0fd3					; save length of current input string 
0fd3					ld hl, (input_start) 
0fd3					ld a, 0 
0fd3					call strlent 
0fd3					ld a,l 
0fd3					ld (input_len),a 
0fd3			 
0fd3			.skipcur: 
0fd3			 
0fd3				        call update_display 
0fd3					 
0fd3			 
0fd3			 
0fd3					; wait 
0fd3				 
0fd3					; TODO loop without wait to flash the cursor and char under cursor	 
0fd3					call cin    ; _wait 
0fd3			 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1 
0fd3			 
0fd3					; get ptr to char to input into 
0fd3			 
0fd3					ld c,a 
0fd3					ld hl, (input_start) 
0fd3					ld a, (input_cursor) 
0fd3					call addatohl 
0fd3					ld (input_ptr), hl 
0fd3					ld a,c 
0fd3			 
0fd3					; replace char under cursor 
0fd3			 
0fd3			;		ld hl, (input_ptr) 
0fd3			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fd3			;		ld (hl), a 
0fd3			 
0fd3			;	if DEBUG_INPUT 
0fd3			;		push af 
0fd3			;		ld a, 'i' 
0fd3			;		ld (debug_mark),a 
0fd3			;		pop af 
0fd3			;		CALLMONITOR 
0fd3			;	endif 
0fd3					cp KEY_HOME 
0fd3					jr nz, .iske 
0fd3			 
0fd3					ld a, (input_at_pos) 
0fd3					ld (input_at_cursor),a 
0fd3					ld a, 0 
0fd3					ld (input_cursor), a 
0fd3					jp .is1 
0fd3					 
0fd3			.iske:		cp KEY_END 
0fd3					jr nz, .isknw 
0fd3					jp .is1 
0fd3			 
0fd3			.isknw:		cp KEY_NEXTWORD 
0fd3					jr nz, .iskpw 
0fd3			 
0fd3			.isknwm:	ld hl, (input_ptr) 
0fd3					ld a,(hl)	 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1    ; end of string 
0fd3					cp ' ' 
0fd3					jp z, .is1    ; end of word 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3					jr .isknwm 
0fd3			 
0fd3			.iskpw:		cp KEY_PREVWORD 
0fd3					jr nz, .iskl 
0fd3			.iskpwm:	 
0fd3					ld hl, (input_ptr) 
0fd3					ld a,(hl)	 
0fd3			;		cp 0  
0fd3					or a 
0fd3					jp z, .is1    ; end of string 
0fd3					cp ' ' 
0fd3					jp z, .is1    ; end of word 
0fd3					dec hl 
0fd3					ld (input_ptr), hl 
0fd3					ld a, (input_at_cursor) 
0fd3					dec a 
0fd3					ld (input_at_cursor), a 
0fd3					jr .iskpwm 
0fd3			 
0fd3			 
0fd3			.iskl:		cp KEY_LEFT 
0fd3					jr nz, .isk1 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3			 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1 		; at start of line to ignore  
0fd3			 
0fd3					dec  a 		; TODO check underflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					dec hl 
0fd3					ld (input_ptr), hl 
0fd3					 
0fd3					ld a, (input_at_cursor) 
0fd3					dec a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk1:		cp KEY_RIGHT 
0fd3					jr nz, .isk2 
0fd3			 
0fd3					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0fd3					ld e,a 
0fd3					ld a, (input_cursor) 
0fd3					cp e 
0fd3					jp z, .is1		; at the end of string so dont go right 
0fd3			 
0fd3					inc  a 		; TODO check overflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk2:		cp KEY_UP 
0fd3			 
0fd3					jr nz, .isk3 
0fd3			 
0fd3					; swap last command with the current on 
0fd3			 
0fd3					; move cursor to start of string 
0fd3					ld hl, (input_start) 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					ld a, (input_at_pos) 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld a, 0 
0fd3					ld (input_cursor), a 
0fd3					 
0fd3					; swap input and last command buffers 
0fd3			 
0fd3					ld hl, os_cli_cmd 
0fd3					ld de, os_last_cmd 
0fd3					ld b, 255 
0fd3			.swap1:		ld a, (hl) 
0fd3					ld c,a 
0fd3					ld a, (de) 
0fd3					ld (hl), a 
0fd3					ld a,c 
0fd3					ld (de),a 
0fd3					inc hl 
0fd3					inc de 
0fd3					djnz .swap1 
0fd3			 
0fd3			 
0fd3			 
0fd3			 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk3:		cp KEY_BS 
0fd3					jr nz, .isk4 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3			 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jp z, .is1 		; at start of line to ignore  
0fd3			 
0fd3					dec  a 		; TODO check underflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					; hl is source 
0fd3					; de needs to be source - 1 
0fd3			 
0fd3			;		ld a, 0 
0fd3			;		dec hl 
0fd3			;		ld (hl), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					dec hl 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					; shift all data 
0fd3			 
0fd3					push hl 
0fd3					inc hl 
0fd3					pop de 
0fd3					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0fd3					ld c,a 
0fd3					ld b,0 
0fd3					ldir  
0fd3			 
0fd3			 
0fd3			 
0fd3			 
0fd3					ld a, (input_at_cursor) 
0fd3					dec a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3			 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3			 
0fd3					; remove char 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld de,.iblank 
0fd3					call str_at_display 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.isk4:		cp KEY_CR 
0fd3					jr z, .endinput 
0fd3			 
0fd3					; else add the key press to the end 
0fd3			 
0fd3					ld c, a			; save key pressed 
0fd3			 
0fd3					ld a,(hl)		; get what is currently under char 
0fd3			 
0fd3			;		cp 0			; we are at the end of the string 
0fd3					or a 
0fd3					jr nz, .onchar 
0fd3					 
0fd3					; add a char to the end of the string 
0fd3				 
0fd3					ld (hl),c 
0fd3					inc hl 
0fd3			;		ld a,' ' 
0fd3			;		ld (hl),a 
0fd3			;		inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3					dec hl 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3					inc a				; TODO check max string length and scroll  
0fd3					ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					inc hl 
0fd3					ld (input_ptr), hl 
0fd3			;	if DEBUG_INPUT 
0fd3			;		push af 
0fd3			;		ld a, '+' 
0fd3			;		ld (debug_mark),a 
0fd3			;		pop af 
0fd3			;		CALLMONITOR 
0fd3			;	endif 
0fd3					ld a, 1		; show cursor moving 
0fd3					ld (input_cur_onoff),a 
0fd3					ld a, CUR_BLINK_RATE 
0fd3					ld (input_cur_flash), a 
0fd3					jp .is1 
0fd3					 
0fd3			 
0fd3			 
0fd3					; if on a char then insert 
0fd3			.onchar: 
0fd3			 
0fd3					; TODO over flow check: make sure insert does not blow out buffer 
0fd3			 
0fd3					; need to do some maths to use lddr 
0fd3			 
0fd3					push hl   ; save char pos 
0fd3					push bc 
0fd3			 
0fd3					ld hl, (input_start) 
0fd3					ld a, (input_len) 
0fd3					call addatohl  		; end of string 
0fd3					inc hl 
0fd3					inc hl		; past zero term 
0fd3					push hl 
0fd3					inc hl 
0fd3					push hl  
0fd3			 
0fd3								; start and end of lddr set, now how much to move? 
0fd3			 
0fd3							 
0fd3					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fd3					ld b,a 
0fd3					ld a,(input_len) 
0fd3					ld e,a 
0fd3					sub b 
0fd3					inc a		;?? 
0fd3					inc a		;?? 
0fd3					inc a		;?? 
0fd3			 
0fd3					ld b,0 
0fd3					ld c,a 
0fd3			 
0fd3				if DEBUG_INPUT 
0fd3					push af 
0fd3					ld a, 'i' 
0fd3					ld (debug_mark),a 
0fd3					pop af 
0fd3			;		CALLMONITOR 
0fd3				endif 
0fd3					pop de 
0fd3					pop hl 
0fd3				if DEBUG_INPUT 
0fd3					push af 
0fd3					ld a, 'I' 
0fd3					ld (debug_mark),a 
0fd3					pop af 
0fd3			;		CALLMONITOR 
0fd3				endif 
0fd3					lddr 
0fd3				 
0fd3			 
0fd3			 
0fd3					; TODO have a key for insert/overwrite mode???? 
0fd3					pop bc 
0fd3					pop hl 
0fd3					ld (hl), c		; otherwise overwrite current char 
0fd3					 
0fd3			 
0fd3			 
0fd3			 
0fd3					ld a, (input_cursor) 
0fd3					inc  a 		; TODO check overflow 
0fd3					ld (input_cursor), a 
0fd3			 
0fd3					ld a, (input_at_cursor) 
0fd3					inc a 
0fd3					ld (input_at_cursor), a 
0fd3			 
0fd3					jp .is1 
0fd3			 
0fd3			.endinput:	; TODO look for end of string 
0fd3			 
0fd3					; add trailing space for end of token 
0fd3			 
0fd3					ld hl, (input_start) 
0fd3					ld a,(input_len) 
0fd3					call addatohl 
0fd3					ld a, ' ' 
0fd3					ld (hl),a 
0fd3					; TODO eof of parse marker 
0fd3			 
0fd3					inc hl 
0fd3					ld a, 0 
0fd3					ld (hl),a 
0fd3			 
0fd3			 
0fd3					ret 
0fd3			 
0fd3			.iblank: db " ",0 
0fd3			 
0fd3			 
0fd3			input_str_prev:	ld (input_at_pos), a 
0fd3					ld (input_start), hl 
0fd3					ld a,1			; add cursor 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3					ld (input_ptr), hl 
0fd3					ld a,d 
0fd3					ld (input_size), a 
0fd3					ld a,0 
0fd3					ld (input_cursor),a 
0fd3			.instr1:	 
0fd3			 
0fd3					; TODO do block cursor 
0fd3					; TODO switch cursor depending on the modifer key 
0fd3			 
0fd3					; update cursor shape change on key hold 
0fd3			 
0fd3					ld hl, (input_ptr) 
0fd3					dec hl 
0fd3					ld a,(cursor_shape) 
0fd3					ld (hl), a 
0fd3			 
0fd3					; display entered text 
0fd3					ld a,(input_at_pos) 
0fd3			            	CALL fLCD_Pos       ;Position cursor to location in A 
0fd3			            	LD   de, (input_start) 
0fd3			            	CALL fLCD_Str       ;Display string pointed to by DE 
0fd3			 
0fd3					call cin 
0fd3			;		cp 0 
0fd3					or a 
0fd3					jr z, .instr1 
0fd3			 
0fd3					; proecess keyboard controls first 
0fd3			 
0fd3					ld hl,(input_ptr) 
0fd3			 
0fd3					cp KEY_CR	 ; pressing enter ends input 
0fd3					jr z, .instrcr 
0fd3			 
0fd3					cp KEY_BS 	; back space 
0fd3					jr nz, .instr2 
0fd3					; process back space 
0fd3			 
0fd3					; TODO stop back space if at start of string 
0fd3					dec hl 
0fd3					dec hl ; to over write cursor 
0fd3					ld a,(cursor_shape) 
0fd3					;ld a,0 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a," " 
0fd3					ld (hl),a 
0fd3					ld (input_ptr),hl 
0fd3					 
0fd3			 
0fd3					jr .instr1 
0fd3			 
0fd3			.instr2:	cp KEY_LEFT    ; cursor left 
0fd3					jr nz, .instr3 
0fd3					dec hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3				 
0fd3			.instr3:	cp KEY_RIGHT      ; cursor right 
0fd3					jr nz, .instr4 
0fd3					inc hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3			 
0fd3			.instr4:	cp KEY_HOME    ; jump to start of line 
0fd3					jr nz, .instr5 
0fd3					dec hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3			 
0fd3			.instr5:	cp KEY_END     ; jump to end of line 
0fd3					jr nz, .instr6 
0fd3					dec hl 
0fd3					ld (input_ptr),hl 
0fd3					jr .instr1 
0fd3			.instr6:        cp KEY_UP      ; recall last command 
0fd3					jr nz, .instrnew 
0fd3			 
0fd3				ld hl, scratch 
0fd3				ld de, os_last_cmd 
0fd3				call strcpy 
0fd3					jr .instr1 
0fd3			 
0fd3			 
0fd3			.instrnew:	; no special key pressed to see if we have room to store it 
0fd3			 
0fd3					; TODO do string size test 
0fd3			 
0fd3					dec hl ; to over write cursor 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,(cursor_shape) 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3			 
0fd3					ld (input_ptr),hl 
0fd3					 
0fd3					jr .instr1 
0fd3			.instrcr:	dec hl		; remove cursor 
0fd3					ld a,' '	; TODO add a trailing space for safety 
0fd3					ld (hl),a 
0fd3					inc hl 
0fd3					ld a,0 
0fd3					ld (hl),a 
0fd3			 
0fd3			 
0fd3					; if at end of line scroll up    
0fd3					; TODO detecting only end of line 4 for scroll up  
0fd3			 
0fd3					;ld   
0fd3			 
0fd3					ret 
0fd3			 
0fd3			 
0fd3			endif 
0fd3			; strcpy hl = dest, de source 
0fd3			 
0fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fd4 b7			            OR   A              ;Null terminator? 
0fd5 c8			            RET  Z              ;Yes, so finished 
0fd6 1a					ld a,(de) 
0fd7 77					ld (hl),a 
0fd8 13			            INC  DE             ;Point to next character 
0fd9 23					inc hl 
0fda 18 f7		            JR   strcpy       ;Repeat 
0fdc c9					ret 
0fdd			 
0fdd			 
0fdd			; TODO string_at  
0fdd			; pass string which starts with lcd offset address and then null term string 
0fdd			 
0fdd			; TODO string to dec 
0fdd			; TODO string to hex 
0fdd			; TODO byte to string hex 
0fdd			; TODO byte to string dec 
0fdd			 
0fdd			 
0fdd			 
0fdd			; from z80uartmonitor 
0fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fdd			; pass hl for where to put the text 
0fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fdd c5			hexout:	PUSH BC 
0fde f5					PUSH AF 
0fdf 47					LD B, A 
0fe0					; Upper nybble 
0fe0 cb 3f				SRL A 
0fe2 cb 3f				SRL A 
0fe4 cb 3f				SRL A 
0fe6 cb 3f				SRL A 
0fe8 cd f8 0f				CALL tohex 
0feb 77					ld (hl),a 
0fec 23					inc hl	 
0fed					 
0fed					; Lower nybble 
0fed 78					LD A, B 
0fee e6 0f				AND 0FH 
0ff0 cd f8 0f				CALL tohex 
0ff3 77					ld (hl),a 
0ff4 23					inc hl	 
0ff5					 
0ff5 f1					POP AF 
0ff6 c1					POP BC 
0ff7 c9					RET 
0ff8					 
0ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ff8			tohex: 
0ff8 e5					PUSH HL 
0ff9 d5					PUSH DE 
0ffa 16 00				LD D, 0 
0ffc 5f					LD E, A 
0ffd 21 05 10				LD HL, .DATA 
1000 19					ADD HL, DE 
1001 7e					LD A, (HL) 
1002 d1					POP DE 
1003 e1					POP HL 
1004 c9					RET 
1005			 
1005			.DATA: 
1005 30					DEFB	30h	; 0 
1006 31					DEFB	31h	; 1 
1007 32					DEFB	32h	; 2 
1008 33					DEFB	33h	; 3 
1009 34					DEFB	34h	; 4 
100a 35					DEFB	35h	; 5 
100b 36					DEFB	36h	; 6 
100c 37					DEFB	37h	; 7 
100d 38					DEFB	38h	; 8 
100e 39					DEFB	39h	; 9 
100f 41					DEFB	41h	; A 
1010 42					DEFB	42h	; B 
1011 43					DEFB	43h	; C 
1012 44					DEFB	44h	; D 
1013 45					DEFB	45h	; E 
1014 46					DEFB	46h	; F 
1015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1015			;;    subtract $30, if result > 9 then subtract $7 more 
1015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1015			atohex: 
1015 d6 30				SUB $30 
1017 fe 0a				CP 10 
1019 f8					RET M		; If result negative it was 0-9 so we're done 
101a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
101c c9					RET		 
101d			 
101d			 
101d			 
101d			 
101d			; Get 2 ASCII characters as hex byte from pointer in hl 
101d			 
101d			BYTERD: 
101d 16 00			LD	D,00h		;Set up 
101f cd 27 10			CALL	HEXCON		;Get byte and convert to hex 
1022 87				ADD	A,A		;First nibble so 
1023 87				ADD	A,A		;multiply by 16 
1024 87				ADD	A,A		; 
1025 87				ADD	A,A		; 
1026 57				LD	D,A		;Save hi nibble in D 
1027			HEXCON: 
1027 7e				ld a, (hl)		;Get next chr 
1028 23				inc hl 
1029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
102b fe 0a			CP	00Ah		;Is it 0-9 ? 
102d 38 02			JR	C,NALPHA	;If so miss next bit 
102f d6 07			SUB	007h		;Else convert alpha 
1031			NALPHA: 
1031 b2				OR	D		;Add hi nibble back 
1032 c9				RET			; 
1033			 
1033			 
1033			; 
1033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1033			; Since the routines get_byte and therefore get_nibble are called, only valid 
1033			; characters (0-9a-f) are accepted. 
1033			; 
1033			;get_word        push    af 
1033			;                call    get_byte        ; Get the upper byte 
1033			;                ld      h, a 
1033			;                call    get_byte        ; Get the lower byte 
1033			;                ld      l, a 
1033			;                pop     af 
1033			;                ret 
1033			; 
1033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1033			; the routine get_nibble is used only valid characters are accepted - the  
1033			; input routine only accepts characters 0-9a-f. 
1033			; 
1033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1034 7e					ld a,(hl) 
1035 23					inc hl 
1036 cd 5b 10		                call    nibble2val      ; Get upper nibble 
1039 cb 07		                rlc     a 
103b cb 07		                rlc     a 
103d cb 07		                rlc     a 
103f cb 07		                rlc     a 
1041 47			                ld      b, a            ; Save upper four bits 
1042 7e					ld a,(hl) 
1043 cd 5b 10		                call    nibble2val      ; Get lower nibble 
1046 b0			                or      b               ; Combine both nibbles 
1047 c1			                pop     bc              ; Restore B (and C) 
1048 c9			                ret 
1049			; 
1049			; Get a hexadecimal digit from the serial line. This routine blocks until 
1049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1049			; to the serial line interface. The lower 4 bits of A contain the value of  
1049			; that particular digit. 
1049			; 
1049			;get_nibble      ld a,(hl)           ; Read a character 
1049			;                call    to_upper        ; Convert to upper case 
1049			;                call    is_hex          ; Was it a hex digit? 
1049			;                jr      nc, get_nibble  ; No, get another character 
1049			 ;               call    nibble2val      ; Convert nibble to value 
1049			 ;               call    print_nibble 
1049			 ;               ret 
1049			; 
1049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1049			; A valid hexadecimal digit is denoted by a set C flag. 
1049			; 
1049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1049			;                ret     nc              ; Yes 
1049			;                cp      '0'             ; Less than '0'? 
1049			;                jr      nc, is_hex_1    ; No, continue 
1049			;                ccf                     ; Complement carry (i.e. clear it) 
1049			;                ret 
1049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1049			;                ret     c               ; Yes 
1049			;                cp      'A'             ; Less than 'A'? 
1049			;                jr      nc, is_hex_2    ; No, continue 
1049			;                ccf                     ; Yes - clear carry and return 
1049			;                ret 
1049			;is_hex_2        scf                     ; Set carry 
1049			;                ret 
1049			; 
1049			; Convert a single character contained in A to upper case: 
1049			; 
1049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
104b d8			                ret     c 
104c fe 7b		                cp      'z' + 1         ; > 'z'? 
104e d0			                ret     nc              ; Nothing to do, either 
104f e6 5f		                and     $5f             ; Convert to upper case 
1051 c9			                ret 
1052			 
1052			 
1052			to_lower: 
1052			 
1052			   ; if char is in [A-Z] make it lower case 
1052			 
1052			   ; enter : a = char 
1052			   ; exit  : a = lower case char 
1052			   ; uses  : af 
1052			 
1052 fe 41		   cp 'A' 
1054 d8			   ret c 
1055			    
1055 fe 5b		   cp 'Z'+1 
1057 d0			   ret nc 
1058			    
1058 f6 20		   or $20 
105a c9			   ret 
105b			 
105b			; 
105b			; Expects a hexadecimal digit (upper case!) in A and returns the 
105b			; corresponding value in A. 
105b			; 
105b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
105d 38 02		                jr      c, nibble2val_1 ; Yes 
105f d6 07		                sub     7               ; Adjust for A-F 
1061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1063 e6 0f		                and     $f              ; Only return lower 4 bits 
1065 c9			                ret 
1066			; 
1066			; Print_nibble prints a single hex nibble which is contained in the lower  
1066			; four bits of A: 
1066			; 
1066			;print_nibble    push    af              ; We won't destroy the contents of A 
1066			;                and     $f              ; Just in case... 
1066			;                add     a, '0'             ; If we have a digit we are done here. 
1066			;                cp      '9' + 1         ; Is the result > 9? 
1066			;                jr      c, print_nibble_1 
1066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1066			;print_nibble_1  call    putc            ; Print the nibble and 
1066			;                pop     af              ; restore the original value of A 
1066			;                ret 
1066			;; 
1066			;; Send a CR/LF pair: 
1066			; 
1066			;crlf            push    af 
1066			;                ld      a, cr 
1066			;                call    putc 
1066			;                ld      a, lf 
1066			;                call    putc 
1066			;                pop     af 
1066			;                ret 
1066			; 
1066			; Print_word prints the four hex digits of a word to the serial line. The  
1066			; word is expected to be in HL. 
1066			; 
1066			;print_word      push    hl 
1066			;                push    af 
1066			;                ld      a, h 
1066			;                call    print_byte 
1066			;                ld      a, l 
1066			;                call    print_byte 
1066			;                pop     af 
1066			;                pop     hl 
1066			;                ret 
1066			; 
1066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1066			; The byte to be printed is expected to be in A. 
1066			; 
1066			;print_byte      push    af              ; Save the contents of the registers 
1066			;                push    bc 
1066			;                ld      b, a 
1066			;                rrca 
1066			;                rrca 
1066			;                rrca 
1066			;                rrca 
1066			;                call    print_nibble    ; Print high nibble 
1066			;                ld      a, b 
1066			;                call    print_nibble    ; Print low nibble 
1066			;                pop     bc              ; Restore original register contents 
1066			;                pop     af 
1066			;                ret 
1066			 
1066			 
1066			 
1066			 
1066			 
1066			fourehexhl:  
1066 7e				ld a,(hl) 
1067 cd 15 10			call atohex 
106a cb 3f				SRL A 
106c cb 3f				SRL A 
106e cb 3f				SRL A 
1070 cb 3f				SRL A 
1072 47				ld b, a 
1073 23				inc hl 
1074 7e				ld a,(hl) 
1075 23				inc hl 
1076 cd 15 10			call atohex 
1079 80				add b 
107a 57				ld d,a 
107b 7e				ld a,(hl) 
107c cd 15 10			call atohex 
107f cb 3f				SRL A 
1081 cb 3f				SRL A 
1083 cb 3f				SRL A 
1085 cb 3f				SRL A 
1087 47				ld b, a 
1088 23				inc hl 
1089 7e				ld a,(hl) 
108a 23				inc hl 
108b cd 15 10			call atohex 
108e 80				add b 
108f 5f				ld e, a 
1090 d5				push de 
1091 e1				pop hl 
1092 c9				ret 
1093			 
1093			; pass hl. returns z set if the byte at hl is a digit 
1093			;isdigithl:  
1093			;	push bc 
1093			;	ld a,(hl) 
1093			;	cp ':' 
1093			;	jr nc, .isdf 		; > 
1093			;	cp '0' 
1093			;	jr c, .isdf		; < 
1093			; 
1093			;	; TODO find a better way to set z 
1093			; 
1093			;	ld b,a 
1093			;	cp b 
1093			;	pop bc 
1093			;	ret 
1093			; 
1093			;.isdf:	; not digit so clear z 
1093			; 
1093			;	; TODO find a better way to unset z 
1093			; 
1093			;	ld b,a 
1093			;	inc b 
1093			;	cp b 
1093			; 
1093			;	pop bc 
1093			;	ret 
1093				 
1093				 
1093			 
1093			 
1093			; pass hl as the four byte address to load 
1093			 
1093			get_word_hl:  
1093 e5				push hl 
1094 cd 33 10			call get_byte 
1097				 
1097 47				ld b, a 
1098			 
1098 e1				pop hl 
1099 23				inc hl 
109a 23				inc hl 
109b			 
109b			; TODO not able to handle a-f  
109b 7e				ld a,(hl) 
109c			;	;cp ':' 
109c			;	cp 'g' 
109c			;	jr nc, .single_byte_hl 		; > 
109c			;	cp 'G' 
109c			;	jr nc, .single_byte_hl 		; > 
109c			;	cp '0' 
109c			;	jr c, .single_byte_hl		; < 
109c			 
109c				;call isdigithl 
109c			;	cp 0 
109c b7				or a 
109d 28 06			jr z, .single_byte_hl 
109f			 
109f			.getwhln:   ; hex word so get next byte 
109f			 
109f cd 33 10			call get_byte 
10a2 6f				ld l, a 
10a3 60				ld h,b 
10a4 c9				ret 
10a5 68			.single_byte_hl:   ld l,b 
10a6 26 00				ld h,0 
10a8 c9					ret 
10a9			 
10a9			 
10a9			 
10a9			 
10a9 21 b5 17			ld hl,asc+1 
10ac			;	ld a, (hl) 
10ac			;	call nibble2val 
10ac cd 33 10			call get_byte 
10af			 
10af			;	call fourehexhl 
10af 32 ec e2			ld (scratch+52),a 
10b2				 
10b2 21 ea e2			ld hl,scratch+50 
10b5 22 db e5			ld (os_cur_ptr),hl 
10b8			 
10b8 c9				ret 
10b9			 
10b9			 
10b9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10b9			 
10b9			; Decimal Unsigned Version 
10b9			 
10b9			;Number in a to decimal ASCII 
10b9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10b9			;Example: display a=56 as "056" 
10b9			;input: a = number 
10b9			;Output: a=0,value of a in the screen 
10b9			;destroys af,bc (don't know about hl and de) 
10b9			DispAToASCII: 
10b9 0e 9c			ld	c,-100 
10bb cd c5 10			call	.Na1 
10be 0e f6			ld	c,-10 
10c0 cd c5 10			call	.Na1 
10c3 0e ff			ld	c,-1 
10c5 06 2f		.Na1:	ld	b,'0'-1 
10c7 04			.Na2:	inc	b 
10c8 81				add	a,c 
10c9 38 fc			jr	c,.Na2 
10cb 91				sub	c		;works as add 100/10/1 
10cc f5				push af		;safer than ld c,a 
10cd 78				ld	a,b		;char is in b 
10ce			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10ce f1				pop af		;safer than ld a,c 
10cf c9				ret 
10d0			 
10d0			; Decimal Signed Version 
10d0			 
10d0			; DispA 
10d0			; -------------------------------------------------------------- 
10d0			; Converts a signed integer value to a zero-terminated ASCII 
10d0			; string representative of that value (using radix 10). 
10d0			; -------------------------------------------------------------- 
10d0			; INPUTS: 
10d0			;     HL     Value to convert (two's complement integer). 
10d0			;     DE     Base address of string destination. (pointer). 
10d0			; -------------------------------------------------------------- 
10d0			; OUTPUTS: 
10d0			;     None 
10d0			; -------------------------------------------------------------- 
10d0			; REGISTERS/MEMORY DESTROYED 
10d0			; AF HL 
10d0			; -------------------------------------------------------------- 
10d0			 
10d0			;DispHLToASCII: 
10d0			;   push    de 
10d0			;   push    bc 
10d0			; 
10d0			;; Detect sign of HL. 
10d0			;    bit    7, h 
10d0			;    jr     z, ._DoConvert 
10d0			; 
10d0			;; HL is negative. Output '-' to string and negate HL. 
10d0			;    ld     a, '-' 
10d0			;    ld     (de), a 
10d0			;    inc    de 
10d0			; 
10d0			;; Negate HL (using two's complement) 
10d0			;    xor    a 
10d0			;    sub    l 
10d0			;    ld     l, a 
10d0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10d0			;    sbc    a, h 
10d0			;    ld     h, a 
10d0			; 
10d0			;; Convert HL to digit characters 
10d0			;._DoConvert: 
10d0			;    ld     b, 0     ; B will count character length of number 
10d0			;-   ld     a, 10 
10d0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10d0			;    push   af 
10d0			;    inc    b 
10d0			;    ld     a, h 
10d0			;    or     l 
10d0			;    jr     nz, - 
10d0			; 
10d0			;; Retrieve digits from stack 
10d0			;-   pop    af 
10d0			;    or     $30 
10d0			;    ld     (de), a 
10d0			;    inc    de 
10d0			;    djnz   - 
10d0			; 
10d0			;; Terminate string with NULL 
10d0			;    xor    a 
10d0			;    ld     (de), a 
10d0			; 
10d0			;    pop    bc 
10d0			;    pop    de 
10d0			;    ret 
10d0			 
10d0			;Comments 
10d0			; 
10d0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10d0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10d0			;    Note that the output string will not be fixed-width. 
10d0			; 
10d0			;Example Usage 
10d0			; 
10d0			;    ld    hl, -1004 
10d0			;    ld    de, OP1 
10d0			;    call  DispA 
10d0			;    ld    hl, OP1 
10d0			;    syscall  PutS 
10d0			 
10d0			 
10d0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10d0			 
10d0			 
10d0			;Converts an ASCII string to an unsigned 16-bit integer 
10d0			;Quits when it reaches a non-decimal digit 
10d0			 
10d0			string_to_uint16: 
10d0			atoui_16: 
10d0			;Input: 
10d0			;     DE points to the string 
10d0			;Outputs: 
10d0			;     HL is the result 
10d0			;     A is the 8-bit value of the number 
10d0			;     DE points to the byte after the number 
10d0			;Destroys: 
10d0			;     BC 
10d0			;       if the string is non-empty, BC is HL/10 
10d0			;Size:  24 bytes 
10d0			;Speed: 42+d(104+{0,9}) 
10d0			;       d is the number of digits in the number 
10d0			;       max is 640 cycles for a 5 digit number 
10d0			;Assuming no leading zeros: 
10d0			;1 digit:  146cc 
10d0			;2 digit:  250cc 
10d0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10d0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10d0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10d0			;avg: 544.81158447265625cc (544+13297/16384) 
10d0			;=============================================================== 
10d0 21 00 00		  ld hl,0 
10d3			.u16a: 
10d3 1a			  ld a,(de) 
10d4 d6 30		  sub 30h 
10d6 fe 0a		  cp 10 
10d8 d0			  ret nc 
10d9 13			  inc de 
10da 44			  ld b,h 
10db 4d			  ld c,l 
10dc 29			  add hl,hl 
10dd 29			  add hl,hl 
10de 09			  add hl,bc 
10df 29			  add hl,hl 
10e0 85			  add a,l 
10e1 6f			  ld l,a 
10e2 30 ef		  jr nc,.u16a 
10e4 24			  inc h 
10e5 c3 d3 10		  jp .u16a 
10e8			 
10e8			 
10e8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10e8			 
10e8			;written by Zeda 
10e8			;Converts a 16-bit unsigned integer to an ASCII string. 
10e8			 
10e8			uitoa_16: 
10e8			;Input: 
10e8			;   DE is the number to convert 
10e8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10e8			;Output: 
10e8			;   HL points to the null-terminated ASCII string 
10e8			;      NOTE: This isn't necessarily the same as the input HL. 
10e8 d5			  push de 
10e9 c5			  push bc 
10ea f5			  push af 
10eb eb			  ex de,hl 
10ec			 
10ec 01 f0 d8		  ld bc,-10000 
10ef 3e 2f		  ld a,'0'-1 
10f1 3c			  inc a 
10f2 09			  add hl,bc  
10f3 38 fc		   jr c,$-2 
10f5 12			  ld (de),a 
10f6 13			  inc de 
10f7			 
10f7 01 e8 03		  ld bc,1000 
10fa 3e 3a		  ld a,'9'+1 
10fc 3d			  dec a  
10fd 09			  add hl,bc  
10fe 30 fc		   jr nc,$-2 
1100 12			  ld (de),a 
1101 13			  inc de 
1102			 
1102 01 9c ff		  ld bc,-100 
1105 3e 2f		  ld a,'0'-1 
1107 3c			  inc a  
1108 09			  add hl,bc  
1109 38 fc		   jr c,$-2 
110b 12			  ld (de),a 
110c 13			  inc de 
110d			 
110d 7d			  ld a,l 
110e 26 3a		  ld h,'9'+1 
1110 25			  dec h  
1111 c6 0a		  add a,10  
1113 30 fb		   jr nc,$-3 
1115 c6 30		  add a,'0' 
1117 eb			  ex de,hl 
1118 72			  ld (hl),d 
1119 23			  inc hl 
111a 77			  ld (hl),a 
111b 23			  inc hl 
111c 36 00		  ld (hl),0 
111e			 
111e			;Now strip the leading zeros 
111e 0e fa		  ld c,-6 
1120 09			  add hl,bc 
1121 3e 30		  ld a,'0' 
1123 23			  inc hl  
1124 be			  cp (hl)  
1125 28 fc		  jr z,$-2 
1127			 
1127			;Make sure that the string is non-empty! 
1127 7e			  ld a,(hl) 
1128 b7			  or a 
1129 20 01		  jr nz,.atoub 
112b 2b			  dec hl 
112c			.atoub: 
112c			 
112c f1			  pop af 
112d c1			  pop bc 
112e d1			  pop de 
112f c9			  ret 
1130			 
1130			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1130			 
1130			toUpper: 
1130			;A is the char. 
1130			;If A is a lowercase letter, this sets it to the matching uppercase 
1130			;18cc or 30cc or 41cc 
1130			;avg: 26.75cc 
1130 fe 61		  cp 'a' 
1132 d8			  ret c 
1133 fe 7b		  cp 'z'+1 
1135 d0			  ret nc 
1136 d6 20		  sub 'a'-'A' 
1138 c9			  ret 
1139			 
1139			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1139			 
1139			; String Length 
1139			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1139			 
1139			; Get the length of the null-terminated string starting at $8000 hl 
1139			;    LD     HL, $8000 
1139			 
1139			strlenz: 
1139			 
1139 af			    XOR    A               ; Zero is the value we are looking for. 
113a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
113b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
113c			                           ; 65, 536 bytes (the entire addressable memory space). 
113c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
113e			 
113e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
113e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
113f 6f			    LD     L, A             ; number of bytes 
1140 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1142 2b			    DEC    HL              ; Compensate for null. 
1143 c9				ret 
1144			 
1144			; Get the length of the A terminated string starting at $8000 hl 
1144			;    LD     HL, $8000 
1144			 
1144			strlent: 
1144			 
1144			                  ; A is the value we are looking for. 
1144 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1146 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1148			                           ; 65, 536 bytes (the entire addressable memory space). 
1148 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
114a			 
114a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
114a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
114c 2e 00		    LD     L, 0             ; number of bytes 
114e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1150 2b			    DEC    HL              ; Compensate for null. 
1151 c9				ret 
1152			 
1152			 
1152			;Comparing Strings 
1152			 
1152			;IN    HL     Address of string1. 
1152			;      DE     Address of string2. 
1152			 
1152			; doc given but wrong??? 
1152			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1152			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1152			; tested 
1152			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1152			 
1152			strcmp_old: 
1152 e5			    PUSH   HL 
1153 d5			    PUSH   DE 
1154			 
1154 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1155 be			    CP     (HL)            ; (want to minimize work). 
1156 38 01		    JR     C, Str1IsBigger 
1158 7e			    LD     A, (HL) 
1159			 
1159			Str1IsBigger: 
1159 4f			    LD     C, A             ; Put length in BC 
115a 06 00		    LD     B, 0 
115c 13			    INC    DE              ; Increment pointers to meat of string. 
115d 23			    INC    HL 
115e			 
115e			CmpLoop: 
115e 1a			    LD     A, (DE)          ; Compare bytes. 
115f ed a1		    CPI 
1161 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1163 13			    INC    DE              ; Update pointer. 
1164 ea 5e 11		    JP     PE, CmpLoop 
1167			 
1167 d1			    POP    DE 
1168 e1			    POP    HL 
1169 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
116a be			    CP     (HL) 
116b c9			    RET 
116c			 
116c			NoMatch: 
116c 2b			    DEC    HL 
116d be			    CP     (HL)            ; Compare again to affect carry. 
116e d1			    POP    DE 
116f e1			    POP    HL 
1170 c9			    RET 
1171			 
1171			;; test strmp 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str2 
1171			;call strcmp 
1171			;jr z, .z1 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "NZ1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.z1: 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "ZZ1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str1 
1171			;call strcmp 
1171			;jr z, .z2 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "NZ2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.z2: 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "ZZ2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str2 
1171			;call strcmp 
1171			;jr c, .c1 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "Nc1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.c1: 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "cc1" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			; 
1171			;ld de, .str1 
1171			;ld hl, .str1 
1171			;call strcmp 
1171			;jr c, .c2 
1171			;;this 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "Nc2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;.c2: 
1171			; 
1171			;	if DEBUG_FORTH_WORDS 
1171			;		DMARK "cc2" 
1171			;		CALLMONITOR 
1171			;	endif 
1171			;	NEXTW 
1171			;.str1:   db "string1",0 
1171			;.str2:   db "string2",0 
1171			 
1171			; only care about direct match or not 
1171			; hl and de strings 
1171			; zero set if the same 
1171			 
1171			strcmp: 
1171 1a				ld a, (de) 
1172 be				cp (hl) 
1173 28 02			jr z, .ssame 
1175 b7				or a 
1176 c9				ret 
1177			 
1177			.ssame:  
1177			;	cp 0 
1177 b7				or a 
1178 c8				ret z 
1179			 
1179 23				inc hl 
117a 13				inc de 
117b 18 f4			jr strcmp 
117d				 
117d				 
117d			 
117d			;Copyright (c) 2014, Luke Maurits 
117d			;All rights reserved. 
117d			; 
117d			;Redistribution and use in source and binary forms, with or without 
117d			;modification, are permitted provided that the following conditions are met: 
117d			; 
117d			;* Redistributions of source code must retain the above copyright notice, this 
117d			;  list of conditions and the following disclaimer. 
117d			; 
117d			;* Redistributions in binary form must reproduce the above copyright notice, 
117d			;  this list of conditions and the following disclaimer in the documentation 
117d			;  and/or other materials provided with the distribution. 
117d			; 
117d			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
117d			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
117d			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
117d			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
117d			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
117d			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
117d			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
117d			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
117d			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
117d			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
117d			 
117d			; https://github.com/lmaurits/lm512/blob/master/string.z80 
117d			 
117d			StrictStrCmp: 
117d				; Load next chars of each string 
117d 1a				ld a, (de) 
117e 47				ld b, a 
117f 7e				ld a, (hl) 
1180				; Compare 
1180 b8				cp b 
1181				; Return non-zero if chars don't match 
1181 c0				ret nz 
1182				; Check for end of both strings 
1182 fe 00			cp "\0" 
1184				; Return if strings have ended 
1184 c8				ret z 
1185				; Otherwise, advance to next chars 
1185 23				inc hl 
1186 13				inc de 
1187 18 f4			jr StrictStrCmp 
1189			 
1189			;end 
1189			; eof 
1189			 
1189			 
1189			 
1189			 
1189			 
1189			 
# End of file firmware_strings.asm
1189			include "firmware_memory.asm"   ; malloc and free  
1189			 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189			.mallocsize: db "Wants malloc >256",0 
1189			.mallocasize: db "MALLOC gives >256",0 
1189			.malloczero: db "MALLOC gives zero",0 
1189			 
1189			malloc_guard_zerolen: 
1189				push hl 
1189				push de 
1189				push af 
1189			 
1189				ld de, 0 
1189			        call cmp16 
1189				jr nz, .lowalloz 
1189			 
1189				push hl 
1189				push de 
1189					ld hl, display_fb0 
1189					ld (display_fb_active), hl 
1189				call clear_display 
1189				ld a, 0 
1189				ld de, .malloczero 
1189				call str_at_display 
1189				call update_display 
1189				call delay1s 
1189				call delay1s 
1189				call bp_on 
1189			;	ld a, 0 
1189			;	ld (os_view_disable), a 
1189			 
1189				pop de 
1189				pop hl 
1189			 
1189				 
1189			 
1189				CALLMONITOR 
1189			.lowalloz: 
1189			 
1189			 
1189				pop af 
1189				pop de 
1189				pop hl 
1189			ret 
1189			 
1189			malloc_guard_entry: 
1189				push hl 
1189				push de 
1189				push af 
1189			 
1189			 	or a      ;clear carry flag 
1189				push hl 
1189				ld de, 255 
1189				sbc hl, de 
1189				jr c, .lowalloc 
1189			 
1189				push de 
1189					ld hl, display_fb0 
1189					ld (display_fb_active), hl 
1189				call clear_display 
1189				ld a, 0 
1189				ld de, .mallocsize 
1189				call str_at_display 
1189				call update_display 
1189				call delay1s 
1189				call delay1s 
1189			;	ld a, 0 
1189			;	ld (os_view_disable), a 
1189				call bp_on 
1189			 
1189				pop de 
1189				pop hl 
1189			 
1189				 
1189			 
1189				CALLMONITOR 
1189				jr .lowdone 
1189			.lowalloc: 
1189			 
1189			 
1189				pop hl 
1189			.lowdone:	pop af 
1189				pop de 
1189				pop hl 
1189			ret 
1189			 
1189			malloc_guard_exit: 
1189				push hl 
1189				push de 
1189				push af 
1189			 
1189			 	or a      ;clear carry flag 
1189				push hl 
1189				ld de, 255 
1189				sbc hl, de 
1189				jr c, .lowallocx 
1189			 
1189				push de 
1189					ld hl, display_fb0 
1189					ld (display_fb_active), hl 
1189				call clear_display 
1189				ld a, 0 
1189				ld de, .mallocasize 
1189				call str_at_display 
1189				call update_display 
1189				call delay1s 
1189				call delay1s 
1189			;	ld a, 0 
1189			;	ld (os_view_disable), a 
1189				call bp_on 
1189				pop de 
1189				pop hl 
1189			 
1189				CALLMONITOR 
1189				jr .lowdonex 
1189			.lowallocx: 
1189			 
1189				pop hl 
1189			.lowdonex:	pop af 
1189				pop de 
1189				pop hl 
1189			ret 
1189			endif 
1189			 
1189			if MALLOC_2 
1189			; Z80 Malloc and Free Functions 
1189			 
1189			; Malloc Function: 
1189			; Input: 
1189			;   HL: Size of block to allocate 
1189			; Output: 
1189			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1189			 
1189			malloc: 
1189				 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189			call malloc_guard_entry 
1189			endif 
1189			 
1189			 
1189			 
1189			 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "mal" 
1189						CALLMONITOR 
1189					endif 
1189			    push af            ; Save AF register 
1189			    ld a, l            ; Load low byte of size into A 
1189			    or h               ; Check if size is zero 
1189			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1189			 
1189			    ; Allocate memory 
1189			    ld hl, (heap_start) ; Load start of heap into HL 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "ma1" 
1189						CALLMONITOR 
1189					endif 
1189			    call malloc_internal ; Call internal malloc function 
1189			    pop af             ; Restore AF register 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret                ; Return 
1189			 
1189			; Free Function: 
1189			; Input: 
1189			;   HL: Pointer to memory block to free 
1189			; Output: 
1189			;   None 
1189			 
1189			free: 
1189			    push af            ; Save AF register 
1189			    ld a, l            ; Load low byte of pointer into A 
1189			    or h               ; Check if pointer is NULL 
1189			    jp z, free_exit    ; If pointer is NULL, exit 
1189			 
1189			    ; Free memory 
1189			    ld hl, (heap_start) ; Load start of heap into HL 
1189			    call free_internal  ; Call internal free function 
1189			    pop af             ; Restore AF register 
1189			    ret                ; Return 
1189			 
1189			; Internal Malloc Function: 
1189			; Input: 
1189			;   HL: Size of block to allocate 
1189			; Output: 
1189			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1189			 
1189			malloc_internal: 
1189			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1189			    add hl, bc         ; Add management overhead to requested size 
1189			    ex de, hl          ; Save total size in DE, and keep it in HL 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "ma2" 
1189						CALLMONITOR 
1189					endif 
1189			 
1189			    ; Search for free memory block 
1189			    ld de, (heap_end)  ; Load end of heap into DE 
1189			    ld bc, 0           ; Initialize counter 
1189			 
1189					if DEBUG_FORTH_MALLOC 
1189						DMARK "ma2" 
1189						CALLMONITOR 
1189					endif 
1189			malloc_search_loop: 
1189			    ; Check if current block is free 
1189			    ld a, (hl)         ; Load current block's status (free or used) 
1189			;    cp 0               ; Compare with zero (free) 
1189				or a 
1189			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1189			 
1189			    ; Check if current block is large enough 
1189			    ld a, (hl+1)       ; Load high byte of block size 
1189			    cp l               ; Compare with low byte of requested size 
1189			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1189			 
1189			    ld a, (hl+2)       ; Load low byte of block size 
1189			    cp h               ; Compare with high byte of requested size 
1189			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1189			 
1189			    ; Mark block as used 
1189			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1189			 
1189			    ; Calculate remaining space in block 
1189			    ld bc, 0           ; Clear BC 
1189			    add hl, bc         ; Increment HL to point to start of data block 
1189			    add hl, de         ; HL = HL + DE (total size) 
1189			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1189			    add hl, bc         ; Add management overhead to start of data block 
1189			 
1189			    ; Save pointer to allocated block in HL 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189						DMARK "ma5" 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret 
1189			 
1189			malloc_skip_block_check: 
1189			    ; Move to the next block 
1189			    ld bc, 3           ; Size of management overhead 
1189			    add hl, bc         ; Move to the next block 
1189			    inc de             ; Increment counter 
1189			 
1189			    ; Check if we have reached the end of heap 
1189			    ld a, e            ; Load low byte of heap end address 
1189			    cp (hl)            ; Compare with low byte of current address 
1189			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1189			    ld a, d            ; Load high byte of heap end address 
1189			;    cp 0               ; Check if it's zero (end of memory) 
1189				or a 
1189			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1189			 
1189			    ; If we reached here, allocation failed 
1189			    xor a              ; Set result to NULL 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189						DMARK "ma6" 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret 
1189			malloc_exit: 
1189			if DEBUG_FORTH_MALLOC_HIGH 
1189						DMARK "ma7" 
1189			call malloc_guard_exit 
1189			call malloc_guard_zerolen 
1189			endif 
1189			    ret 
1189			 
1189			; Internal Free Function: 
1189			; Input: 
1189			;   HL: Pointer to memory block to free 
1189			; Output: 
1189			;   None 
1189			 
1189			free_internal: 
1189			    ld de, (heap_start) ; Load start of heap into DE 
1189			    ld bc, 0            ; Initialize counter 
1189			 
1189			free_search_loop: 
1189			    ; Check if current block contains the pointer 
1189			    ld a, l             ; Load low byte of pointer 
1189			    cp (hl+1)           ; Compare with high byte of current block's address 
1189			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1189			    ld a, h             ; Load high byte of pointer 
1189			    cp (hl+2)           ; Compare with low byte of current block's address 
1189			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1189			 
1189			    ; Mark block as free 
1189			    ld (hl), 0          ; Set status byte to indicate free block 
1189			    ret                 ; Return 
1189			 
1189			free_skip_block_check: 
1189			    ; Move to the next block 
1189			    ld bc, 3            ; Size of management overhead 
1189			    add hl, bc          ; Move to the next block 
1189			    inc de              ; Increment counter 
1189			 
1189			    ; Check if we have reached the end of heap 
1189			    ld a, e             ; Load low byte of heap end address 
1189			    cp (hl)             ; Compare with low byte of current address 
1189			    jr nz, free_search_loop  ; If not equal, continue searching 
1189			    ld a, d             ; Load high byte of heap end address 
1189			;    cp 0                ; Check if it's zero (end of memory) 
1189				or a 
1189			    jr nz, free_search_loop  ; If not zero, continue searching 
1189			 
1189			    ; If we reached here, pointer is not found in heap 
1189			    ret 
1189			 
1189			free_exit: 
1189			    ret                 ; Return 
1189			 
1189			; Define heap start and end addresses 
1189			;heap_start:    .dw 0xC000   ; Start of heap 
1189			;heap_end:      .dw 0xE000   ; End of heap 
1189			 
1189			endif 
1189			 
1189			 
1189			if MALLOC_1 
1189			 
1189			 
1189			 
1189			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1189			 
1189			;moved to firmware.asm 
1189			;heap_start        .equ  0x9000      ; Starting address of heap 
1189			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1189			 
1189			;      .org 0 
1189			;      jp    main 
1189			 
1189			 
1189			;      .org  0x100 
1189			;main: 
1189			;      ld    HL, 0x8100 
1189			;      ld    SP, HL 
1189			; 
1189			;      call  heap_init 
1189			; 
1189			;      ; Make some allocations 
1189			;      ld    HL, 12 
1189			;      call  malloc            ; Allocates 0x9004 
1189			; 
1189			;      ld    HL, 12 
1189			;      call  malloc            ; Allocates 0x9014 
1189			; 
1189			;      ld    HL, 12 
1189			;      call  malloc            ; Allocates 0x9024 
1189			; 
1189			;      ; Free some allocations 
1189			;      ld    HL, 0x9014 
1189			;      call  free 
1189			; 
1189			;      ld    HL, 0x9004 
1189			;      call  free 
1189			; 
1189			;      ld    HL, 0x9024 
1189			;      call  free 
1189			; 
1189			; 
1189			;      halt 
1189			 
1189			 
1189			;------------------------------------------------------------------------------ 
1189			;     heap_init                                                               : 
1189			;                                                                             : 
1189			; Description                                                                 : 
1189			;     Initialise the heap and make it ready for malloc and free operations.   : 
1189			;                                                                             : 
1189			;     The heap is maintained as a linked list, starting with an initial       : 
1189			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1189			;     the first free block in the heap. Each block then points to the next    : 
1189			;     free block within the heap, and the free list ends at the first block   : 
1189			;     with a null pointer to the next free block.                             : 
1189			;                                                                             : 
1189			; Parameters                                                                  : 
1189			;     Inputs are compile-time only. Two defines which specify the starting    : 
1189			;     address of the heap and its size are required, along with a memory      : 
1189			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1189			;     principally stores a pointer to the first free block in the heap.       : 
1189			;                                                                             : 
1189			; Returns                                                                     : 
1189			;     Nothing                                                                 : 
1189			;------------------------------------------------------------------------------ 
1189			heap_init: 
1189 e5			      push  HL 
118a			 
118a			      ; Initialise free list struct 
118a 21 dc 65		      ld    HL, heap_start 
118d 22 d7 65		      ld    (free_list), HL 
1190 21 00 00		      ld    HL, 0 
1193 22 d9 65		      ld    (free_list+2), HL 
1196			 
1196			      ; Insert first free block at bottom of heap, consumes entire heap 
1196 21 8f e2		      ld    HL, heap_start+heap_size-4 
1199 22 dc 65		      ld    (heap_start), HL        ; Next block (end of free list) 
119c 21 b3 7c		      ld    HL, heap_size-4 
119f 22 de 65		      ld    (heap_start+2), HL      ; Block size 
11a2			 
11a2			      ; Insert end of free list block at top of heap - two null words will 
11a2			      ; terminate the free list 
11a2 21 00 00		      ld    HL, 0 
11a5 22 91 e2		      ld    (heap_start+heap_size-2), HL 
11a8 22 8f e2		      ld    (heap_start+heap_size-4), HL 
11ab			 
11ab e1			      pop   HL 
11ac			 
11ac c9			      ret 
11ad			 
11ad			 
11ad			;------------------------------------------------------------------------------ 
11ad			;     malloc                                                                  : 
11ad			;                                                                             : 
11ad			; Description                                                                 : 
11ad			;     Allocates the wanted space from the heap and returns the address of the : 
11ad			;     first useable byte of the allocation.                                   : 
11ad			;                                                                             : 
11ad			;     Allocations can happen in one of two ways:                              : 
11ad			;                                                                             : 
11ad			;     1. A free block may be found which is the exact size wanted. In this    : 
11ad			;        case the block is removed from the free list and retuedn to the      : 
11ad			;        caller.                                                              : 
11ad			;     2. A free block may be found which is larger than the size wanted. In   : 
11ad			;        this case, the larger block is split into two. The first portion of  : 
11ad			;        this block will become the requested space by the malloc call and    : 
11ad			;        is returned to the caller. The second portion becomes a new free     : 
11ad			;        block, and the free list is adjusted to maintain continuity via this : 
11ad			;        newly created block.                                                 : 
11ad			;                                                                             : 
11ad			;     malloc does not set any initial value in the allocated space, the       : 
11ad			;     caller is required to do this as required.                              : 
11ad			;                                                                             : 
11ad			;     This implementation of malloc uses the stack exclusively, and is        : 
11ad			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11ad			;     advisable to disable interrupts before calling malloc, and recommended  : 
11ad			;     to avoid the use of malloc inside ISRs in general.                      : 
11ad			;                                                                             : 
11ad			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11ad			;                                                                             : 
11ad			; Parameters                                                                  : 
11ad			;     HL  Number of bytes wanted                                              : 
11ad			;                                                                             : 
11ad			; Returns                                                                     : 
11ad			;     HL  Address of the first useable byte of the allocation                 : 
11ad			;                                                                             : 
11ad			; Flags                                                                       : 
11ad			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11ad			;                                                                             : 
11ad			; Stack frame                                                                 : 
11ad			;       |             |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |     BC      |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |     DE      |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |     IX      |                                                       : 
11ad			;       +-------------+                                                       : 
11ad			;       |  prev_free  |                                                       : 
11ad			;   +4  +-------------+                                                       : 
11ad			;       |  this_free  |                                                       : 
11ad			;   +2  +-------------+                                                       : 
11ad			;       |  next_free  |                                                       : 
11ad			;   +0  +-------------+                                                       : 
11ad			;       |             |                                                       : 
11ad			;                                                                             : 
11ad			;------------------------------------------------------------------------------ 
11ad			 
11ad			 
11ad			;malloc: 
11ad			; 
11ad			;	SAVESP ON 1 
11ad			; 
11ad			;	call malloc_code 
11ad			; 
11ad			;	CHECKSP ON 1 
11ad			;	ret 
11ad			 
11ad			 
11ad			malloc: 
11ad c5			      push  BC 
11ae d5			      push  DE 
11af dd e5		      push  IX 
11b1			if DEBUG_FORTH_MALLOC_HIGH 
11b1			call malloc_guard_entry 
11b1			endif 
11b1			 
11b1					if DEBUG_FORTH_MALLOC 
11b1						DMARK "mal" 
11b1						CALLMONITOR 
11b1					endif 
11b1 7c			      ld    A, H                    ; Exit if no space requested 
11b2 b5			      or    L 
11b3 ca 72 12		      jp    Z, malloc_early_exit 
11b6			 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			; 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			;inc hl 
11b6			 
11b6			 
11b6			 
11b6			 
11b6					if DEBUG_FORTH_MALLOC 
11b6						DMARK "maA" 
11b6						CALLMONITOR 
11b6					endif 
11b6			      ; Set up stack frame 
11b6 eb			      ex    DE, HL 
11b7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11ba 39			      add   HL, SP 
11bb f9			      ld    SP, HL 
11bc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11c0 dd 39		      add   IX, SP 
11c2			 
11c2			      ; Setup initial state 
11c2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11c5 19			      add   HL, DE 
11c6			 
11c6 44			      ld    B, H                    ; Move want to BC 
11c7 4d			      ld    C, L 
11c8			 
11c8 21 d7 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
11cb dd 75 04		      ld    (IX+4), L 
11ce dd 74 05		      ld    (IX+5), H 
11d1			 
11d1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11d2 23			      inc   HL 
11d3 56			      ld    D, (HL) 
11d4 dd 73 02		      ld    (IX+2), E 
11d7 dd 72 03		      ld    (IX+3), D 
11da eb			      ex    DE, HL                  ; this_free ptr into HL 
11db			 
11db					if DEBUG_FORTH_MALLOC 
11db						DMARK "maB" 
11db						CALLMONITOR 
11db					endif 
11db			      ; Loop through free block list to find some space 
11db			malloc_find_space: 
11db 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11dc 23			      inc   HL 
11dd 56			      ld    D, (HL) 
11de			 
11de 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11df b3			      or    E 
11e0 ca 6c 12		      jp    Z, malloc_no_space 
11e3			 
11e3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11e6 dd 72 01		      ld    (IX+1), D 
11e9			 
11e9			      ; Does this block have enough space to make the allocation? 
11e9 23			      inc   HL                      ; Load free block size into DE 
11ea 5e			      ld    E, (HL) 
11eb 23			      inc   HL 
11ec 56			      ld    D, (HL) 
11ed			 
11ed eb			      ex    DE, HL                  ; Check size of block against want 
11ee b7			      or    A                       ; Ensure carry flag clear 
11ef ed 42		      sbc   HL, BC 
11f1 e5			      push  HL                      ; Store the result for later (new block size) 
11f2			 
11f2 ca 41 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11f5 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11f7			 
11f7			      ; this_free block is not big enough, setup ptrs to test next free block 
11f7 e1			      pop   HL                      ; Discard previous result 
11f8			 
11f8 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11fb dd 66 03		      ld    H, (IX+3) 
11fe dd 75 04		      ld    (IX+4), L 
1201 dd 74 05		      ld    (IX+5), H 
1204			 
1204 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1207 dd 66 01		      ld    H, (IX+1) 
120a dd 75 02		      ld    (IX+2), L 
120d dd 74 03		      ld    (IX+3), H 
1210			 
1210					if DEBUG_FORTH_MALLOC 
1210						DMARK "MA>" 
1210						CALLMONITOR 
1210					endif 
1210 18 c9		      jr    malloc_find_space 
1212			 
1212			      ; split a bigger block into two - requested size and remaining size 
1212			malloc_alloc_split: 
1212					if DEBUG_FORTH_MALLOC 
1212						DMARK "MAs" 
1212						CALLMONITOR 
1212					endif 
1212 eb			      ex    DE, HL                  ; Calculate address of new free block 
1213 2b			      dec   HL 
1214 2b			      dec   HL 
1215 2b			      dec   HL 
1216 09			      add   HL, BC 
1217			 
1217			      ; Create a new block and point it at next_free 
1217 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
121a dd 56 01		      ld    D, (IX+1) 
121d			 
121d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
121e 23			      inc   HL 
121f 72			      ld    (HL), D 
1220			 
1220 d1			      pop   DE                      ; Store size of new block into new block 
1221 23			      inc   HL 
1222 73			      ld    (HL), E 
1223 23			      inc   HL 
1224 72			      ld    (HL), D 
1225			 
1225			      ; Update this_free ptr to point to new block 
1225 2b			      dec   HL 
1226 2b			      dec   HL 
1227 2b			      dec   HL 
1228			 
1228 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
122b dd 56 03		      ld    D, (IX+3) 
122e			 
122e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1231 dd 74 03		      ld    (IX+3), H 
1234			 
1234			      ; Modify this_free block to be allocation 
1234 eb			      ex    DE, HL 
1235 af			      xor   A                       ; Null the next block ptr of allocated block 
1236 77			      ld    (HL), A 
1237 23			      inc   HL 
1238 77			      ld    (HL), A 
1239			 
1239 23			      inc   HL                      ; Store want size into allocated block 
123a 71			      ld    (HL), C 
123b 23			      inc   HL 
123c 70			      ld    (HL), B 
123d 23			      inc   HL 
123e e5			      push  HL                      ; Address of allocation to return 
123f			 
123f 18 19		      jr    malloc_update_links 
1241			 
1241			malloc_alloc_fit: 
1241 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1242			 
1242					if DEBUG_FORTH_MALLOC 
1242						DMARK "MAf" 
1242						CALLMONITOR 
1242					endif 
1242			      ; Modify this_free block to be allocation 
1242 eb			      ex    DE, HL 
1243 2b			      dec   HL 
1244 2b			      dec   HL 
1245 2b			      dec   HL 
1246			 
1246 af			      xor   A                       ; Null the next block ptr of allocated block 
1247 77			      ld    (HL), A 
1248 23			      inc   HL 
1249 77			      ld    (HL), A 
124a			 
124a 23			      inc   HL                      ; Store address of allocation to return 
124b 23			      inc   HL 
124c 23			      inc   HL 
124d e5			      push  HL 
124e			 
124e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
124e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1251 dd 66 01		      ld    H, (IX+1) 
1254			 
1254 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1257 dd 74 03		      ld    (IX+3), H 
125a			 
125a			 
125a			malloc_update_links: 
125a			      ; Update prev_free ptr to point to this_free 
125a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
125d dd 66 05		      ld    H, (IX+5) 
1260			 
1260 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1263 dd 56 03		      ld    D, (IX+3) 
1266			 
1266 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1267 23			      inc   HL 
1268 72			      ld    (HL), D 
1269			 
1269					if DEBUG_FORTH_MALLOC 
1269						DMARK "Mul" 
1269						CALLMONITOR 
1269					endif 
1269			      ; Clear the Z flag to indicate successful allocation 
1269 7a			      ld    A, D 
126a b3			      or    E 
126b			 
126b d1			      pop   DE                      ; Address of allocation 
126c					if DEBUG_FORTH_MALLOC 
126c						DMARK "MAu" 
126c						CALLMONITOR 
126c					endif 
126c			 
126c			malloc_no_space: 
126c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
126f 39			      add   HL, SP 
1270 f9			      ld    SP, HL 
1271			 
1271 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1272					if DEBUG_FORTH_MALLOC 
1272						DMARK "MAN" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			malloc_early_exit: 
1272					if DEBUG_FORTH_MALLOC 
1272						DMARK "MAx" 
1272						CALLMONITOR 
1272					endif 
1272 dd e1		      pop   IX 
1274 d1			      pop   DE 
1275 c1			      pop   BC 
1276			 
1276			if DEBUG_FORTH_MALLOC_HIGH 
1276			call malloc_guard_exit 
1276			call malloc_guard_zerolen 
1276			endif 
1276 c9			      ret 
1277			 
1277			 
1277			;------------------------------------------------------------------------------ 
1277			;     free                                                                    : 
1277			;                                                                             : 
1277			; Description                                                                 : 
1277			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1277			;     returned by malloc, otherwise the behaviour is undefined.               : 
1277			;                                                                             : 
1277			;     Where possible, directly adjacent free blocks will be merged together   : 
1277			;     into larger blocks to help ensure that the heap does not become         : 
1277			;     excessively fragmented.                                                 : 
1277			;                                                                             : 
1277			;     free does not clear or set any other value into the freed space, and    : 
1277			;     therefore its contents may be visible through subsequent malloc's. The  : 
1277			;     caller should clear the freed space as required.                        : 
1277			;                                                                             : 
1277			;     This implementation of free uses the stack exclusively, and is          : 
1277			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1277			;     advisable to disable interrupts before calling free, and recommended    : 
1277			;     to avoid the use of free inside ISRs in general.                        : 
1277			;                                                                             : 
1277			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1277			;                                                                             : 
1277			; Parameters                                                                  : 
1277			;     HL  Pointer to address of first byte of allocation to be freed          : 
1277			;                                                                             : 
1277			; Returns                                                                     : 
1277			;     Nothing                                                                 : 
1277			;                                                                             : 
1277			; Stack frame                                                                 : 
1277			;       |             |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |     BC      |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |     DE      |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |     IX      |                                                       : 
1277			;       +-------------+                                                       : 
1277			;       |  prev_free  |                                                       : 
1277			;   +2  +-------------+                                                       : 
1277			;       |  next_free  |                                                       : 
1277			;   +0  +-------------+                                                       : 
1277			;       |             |                                                       : 
1277			;                                                                             : 
1277			;------------------------------------------------------------------------------ 
1277			free: 
1277 c5			      push  BC 
1278 d5			      push  DE 
1279 dd e5		      push  IX 
127b			 
127b 7c			      ld    A, H                    ; Exit if ptr is null 
127c b5			      or    L 
127d ca 41 13		      jp    Z, free_early_exit 
1280			 
1280			      ; Set up stack frame 
1280 eb			      ex    DE, HL 
1281 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1284 39			      add   HL, SP 
1285 f9			      ld    SP, HL 
1286 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
128a dd 39		      add   IX, SP 
128c			 
128c			      ; The address in HL points to the start of the useable allocated space, 
128c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
128c			      ; address of the block itself. 
128c eb			      ex    DE, HL 
128d 11 fc ff		      ld    DE, -4 
1290 19			      add   HL, DE 
1291			 
1291			      ; An allocated block must have a null next block pointer in it 
1291 7e			      ld    A, (HL) 
1292 23			      inc   HL 
1293 b6			      or    (HL) 
1294 c2 3c 13		      jp    NZ, free_done 
1297			 
1297 2b			      dec   HL 
1298			 
1298 44			      ld    B, H                    ; Copy HL to BC 
1299 4d			      ld    C, L 
129a			 
129a			      ; Loop through the free list to find the first block with an address 
129a			      ; higher than the block being freed 
129a 21 d7 65		      ld    HL, free_list 
129d			 
129d			free_find_higher_block: 
129d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
129e 23			      inc   HL 
129f 56			      ld    D, (HL) 
12a0 2b			      dec   HL 
12a1			 
12a1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12a4 dd 72 01		      ld    (IX+1), D 
12a7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12aa dd 74 03		      ld    (IX+3), H 
12ad			 
12ad 78			      ld    A, B                    ; Check if DE is greater than BC 
12ae ba			      cp    D                       ; Compare MSB first 
12af 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12b1 30 04		      jr    NC, free_find_higher_block_skip 
12b3 79			      ld    A, C 
12b4 bb			      cp    E                       ; Then compare LSB 
12b5 38 08		      jr    C, free_found_higher_block 
12b7			 
12b7			free_find_higher_block_skip: 
12b7 7a			      ld    A, D                    ; Reached the end of the free list? 
12b8 b3			      or    E 
12b9 ca 3c 13		      jp    Z, free_done 
12bc			 
12bc eb			      ex    DE, HL 
12bd			 
12bd 18 de		      jr    free_find_higher_block 
12bf			 
12bf			free_found_higher_block: 
12bf			      ; Insert freed block between prev and next free blocks 
12bf 71			      ld    (HL), C                 ; Point prev free block to freed block 
12c0 23			      inc   HL 
12c1 70			      ld    (HL), B 
12c2			 
12c2 60			      ld    H, B                    ; Point freed block at next free block 
12c3 69			      ld    L, C 
12c4 73			      ld    (HL), E 
12c5 23			      inc   HL 
12c6 72			      ld    (HL), D 
12c7			 
12c7			      ; Check if the freed block is adjacent to the next free block 
12c7 23			      inc   HL                      ; Load size of freed block into HL 
12c8 5e			      ld    E, (HL) 
12c9 23			      inc   HL 
12ca 56			      ld    D, (HL) 
12cb eb			      ex    DE, HL 
12cc			 
12cc 09			      add   HL, BC                  ; Add addr of freed block and its size 
12cd			 
12cd dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12d0 dd 56 01		      ld    D, (IX+1) 
12d3			 
12d3 b7			      or    A                       ; Clear the carry flag 
12d4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12d6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12d8			 
12d8			      ; Freed block is adjacent to next, merge into one bigger block 
12d8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12d9 5e			      ld    E, (HL) 
12da 23			      inc   HL 
12db 56			      ld    D, (HL) 
12dc e5			      push  HL                      ; Save ptr to next block for later 
12dd			 
12dd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12de 69			      ld    L, C 
12df 73			      ld    (HL), E 
12e0 23			      inc   HL 
12e1 72			      ld    (HL), D 
12e2			 
12e2 e1			      pop   HL                      ; Restore ptr to next block 
12e3 23			      inc   HL                      ; Load size of next block into DE 
12e4 5e			      ld    E, (HL) 
12e5 23			      inc   HL 
12e6 56			      ld    D, (HL) 
12e7 d5			      push  DE                      ; Save next block size for later 
12e8			 
12e8 60			      ld    H, B                    ; Load size of freed block into HL 
12e9 69			      ld    L, C 
12ea 23			      inc   HL 
12eb 23			      inc   HL 
12ec 5e			      ld    E, (HL) 
12ed 23			      inc   HL 
12ee 56			      ld    D, (HL) 
12ef eb			      ex    DE, HL 
12f0			 
12f0 d1			      pop   DE                      ; Restore size of next block 
12f1 19			      add   HL, DE                  ; Add sizes of both blocks 
12f2 eb			      ex    DE, HL 
12f3			 
12f3 60			      ld    H, B                    ; Store new bigger size into freed block 
12f4 69			      ld    L, C 
12f5 23			      inc   HL 
12f6 23			      inc   HL 
12f7 73			      ld    (HL), E 
12f8 23			      inc   HL 
12f9 72			      ld    (HL), D 
12fa			 
12fa			free_check_adjacent_to_prev: 
12fa			      ; Check if the freed block is adjacent to the prev free block 
12fa dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
12fd dd 66 03		      ld    H, (IX+3) 
1300			 
1300 23			      inc   HL                      ; Size of prev free block into DE 
1301 23			      inc   HL 
1302 5e			      ld    E, (HL) 
1303 23			      inc   HL 
1304 56			      ld    D, (HL) 
1305 2b			      dec   HL 
1306 2b			      dec   HL 
1307 2b			      dec   HL 
1308			 
1308 19			      add   HL, DE                  ; Add prev block addr and size 
1309			 
1309 b7			      or    A                       ; Clear the carry flag 
130a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
130c 20 2e		      jr    NZ, free_done 
130e			 
130e			      ; Freed block is adjacent to prev, merge into one bigger block 
130e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
130f 69			      ld    L, C 
1310 5e			      ld    E, (HL) 
1311 23			      inc   HL 
1312 56			      ld    D, (HL) 
1313 e5			      push  HL                      ; Save freed block ptr for later 
1314			 
1314 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1317 dd 66 03		      ld    H, (IX+3) 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d e1			      pop   HL                      ; Restore freed block ptr 
131e 23			      inc   HL                      ; Load size of freed block into DE 
131f 5e			      ld    E, (HL) 
1320 23			      inc   HL 
1321 56			      ld    D, (HL) 
1322 d5			      push  DE                      ; Save freed block size for later 
1323			 
1323 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1326 dd 66 03		      ld    H, (IX+3) 
1329 23			      inc   HL 
132a 23			      inc   HL 
132b 5e			      ld    E, (HL) 
132c 23			      inc   HL 
132d 56			      ld    D, (HL) 
132e			 
132e e1			      pop   HL                      ; Add sizes of both blocks 
132f 19			      add   HL, DE 
1330 eb			      ex    DE, HL 
1331			 
1331 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1334 dd 66 03		      ld    H, (IX+3) 
1337 23			      inc   HL 
1338 23			      inc   HL 
1339 73			      ld    (HL), E 
133a 23			      inc   HL 
133b 72			      ld    (HL), D 
133c			 
133c			free_done: 
133c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
133f 39			      add   HL, SP 
1340 f9			      ld    SP, HL 
1341			 
1341			free_early_exit: 
1341 dd e1		      pop   IX 
1343 d1			      pop   DE 
1344 c1			      pop   BC 
1345			 
1345 c9			      ret 
1346			 
1346			; moved to firmware.asm 
1346			; 
1346			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1346			;                  .dw   0 
1346			 
1346			 
1346			endif 
1346			 
1346			 
1346			if MALLOC_3 
1346			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1346			;heap_start        .equ  0x9000      ; Starting address of heap 
1346			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1346			; 
1346			 ;     .org 0 
1346			  ;    jp    main 
1346			; 
1346			; 
1346			 ;     .org  0x100 
1346			;main: 
1346			 ;     ld    HL, 0x8100 
1346			  ;    ld    SP, HL 
1346			; 
1346			;      call  heap_init 
1346			 
1346			      ; Make some allocations 
1346			;      ld    HL, 12 
1346			;      call  malloc            ; Allocates 0x9004 
1346			; 
1346			 ;     ld    HL, 12 
1346			;      call  malloc            ; Allocates 0x9014 
1346			 
1346			;      ld    HL, 12 
1346			;      call  malloc            ; Allocates 0x9024 
1346			 
1346			      ; Free some allocations 
1346			;      ld    HL, 0x9014 
1346			;      call  free 
1346			 
1346			;      ld    HL, 0x9004 
1346			;      call  free 
1346			; 
1346			;      ld    HL, 0x9024 
1346			;      call  free 
1346			 
1346			 
1346			 ;     halt 
1346			 
1346			 
1346			;------------------------------------------------------------------------------ 
1346			;     heap_init                                                               : 
1346			;                                                                             : 
1346			; Description                                                                 : 
1346			;     Initialise the heap and make it ready for malloc and free operations.   : 
1346			;                                                                             : 
1346			;     The heap is maintained as a linked list, starting with an initial       : 
1346			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1346			;     the first free block in the heap. Each block then points to the next    : 
1346			;     free block within the heap, and the free list ends at the first block   : 
1346			;     with a null pointer to the next free block.                             : 
1346			;                                                                             : 
1346			; Parameters                                                                  : 
1346			;     Inputs are compile-time only. Two defines which specify the starting    : 
1346			;     address of the heap and its size are required, along with a memory      : 
1346			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1346			;     principally stores a pointer to the first free block in the heap.       : 
1346			;                                                                             : 
1346			; Returns                                                                     : 
1346			;     Nothing                                                                 : 
1346			;------------------------------------------------------------------------------ 
1346			heap_init: 
1346			      push  HL 
1346			 
1346			      ; Initialise free list struct 
1346			      ld    HL, heap_start 
1346			      ld    (free_list), HL 
1346			      ld    HL, 0 
1346			      ld    (free_list+2), HL 
1346			 
1346			      ; Insert first free block at bottom of heap, consumes entire heap 
1346			      ld    HL, heap_start+heap_size-4 
1346			      ld    (heap_start), HL        ; Next block (end of free list) 
1346			      ld    HL, heap_size-4 
1346			      ld    (heap_start+2), HL      ; Block size 
1346			 
1346			      ; Insert end of free list block at top of heap - two null words will 
1346			      ; terminate the free list 
1346			      ld    HL, 0 
1346			      ld    (heap_start+heap_size-2), HL 
1346			      ld    (heap_start+heap_size-4), HL 
1346			 
1346			      pop   HL 
1346			 
1346			      ret 
1346			 
1346			 
1346			;------------------------------------------------------------------------------ 
1346			;     malloc                                                                  : 
1346			;                                                                             : 
1346			; Description                                                                 : 
1346			;     Allocates the wanted space from the heap and returns the address of the : 
1346			;     first useable byte of the allocation.                                   : 
1346			;                                                                             : 
1346			;     Allocations can happen in one of two ways:                              : 
1346			;                                                                             : 
1346			;     1. A free block may be found which is the exact size wanted. In this    : 
1346			;        case the block is removed from the free list and retuedn to the      : 
1346			;        caller.                                                              : 
1346			;     2. A free block may be found which is larger than the size wanted. In   : 
1346			;        this case, the larger block is split into two. The first portion of  : 
1346			;        this block will become the requested space by the malloc call and    : 
1346			;        is returned to the caller. The second portion becomes a new free     : 
1346			;        block, and the free list is adjusted to maintain continuity via this : 
1346			;        newly created block.                                                 : 
1346			;                                                                             : 
1346			;     malloc does not set any initial value in the allocated space, the       : 
1346			;     caller is required to do this as required.                              : 
1346			;                                                                             : 
1346			;     This implementation of malloc uses the stack exclusively, and is        : 
1346			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1346			;     advisable to disable interrupts before calling malloc, and recommended  : 
1346			;     to avoid the use of malloc inside ISRs in general.                      : 
1346			;                                                                             : 
1346			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1346			;                                                                             : 
1346			; Parameters                                                                  : 
1346			;     HL  Number of bytes wanted                                              : 
1346			;                                                                             : 
1346			; Returns                                                                     : 
1346			;     HL  Address of the first useable byte of the allocation                 : 
1346			;                                                                             : 
1346			; Flags                                                                       : 
1346			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1346			;                                                                             : 
1346			; Stack frame                                                                 : 
1346			;       |             |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     BC      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     DE      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     IX      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |  prev_free  |                                                       : 
1346			;   +4  +-------------+                                                       : 
1346			;       |  this_free  |                                                       : 
1346			;   +2  +-------------+                                                       : 
1346			;       |  next_free  |                                                       : 
1346			;   +0  +-------------+                                                       : 
1346			;       |             |                                                       : 
1346			;                                                                             : 
1346			;------------------------------------------------------------------------------ 
1346			malloc: 
1346			      push  BC 
1346			      push  DE 
1346			      push  IX 
1346			 
1346			      ld    A, H                    ; Exit if no space requested 
1346			      or    L 
1346			      jp    Z, malloc_early_exit 
1346			 
1346			      ; Set up stack frame 
1346			      ex    DE, HL 
1346			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			      ld    IX, 0                   ; Use IX as a frame pointer 
1346			      add   IX, SP 
1346			 
1346			      ; Setup initial state 
1346			      ld    HL, 4                   ; want must also include space used by block struct 
1346			      add   HL, DE 
1346			 
1346			      ld    B, H                    ; Move want to BC 
1346			      ld    C, L 
1346			 
1346			      ld    HL, free_list           ; Store prev_free ptr to stack 
1346			      ld    (IX+4), L 
1346			      ld    (IX+5), H 
1346			 
1346			      ld    E, (HL)                 ; Store this_free ptr to stack 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      ld    (IX+2), E 
1346			      ld    (IX+3), D 
1346			      ex    DE, HL                  ; this_free ptr into HL 
1346			 
1346			      ; Loop through free block list to find some space 
1346			malloc_find_space: 
1346			      ld    E, (HL)                 ; Load next_free ptr into DE 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			 
1346			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1346			      or    E 
1346			      jp    Z, malloc_no_space 
1346			 
1346			      ld    (IX+0), E               ; Store next_free ptr to stack 
1346			      ld    (IX+1), D 
1346			 
1346			      ; Does this block have enough space to make the allocation? 
1346			      inc   HL                      ; Load free block size into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			 
1346			      ex    DE, HL                  ; Check size of block against want 
1346			      or    A                       ; Ensure carry flag clear 
1346			      sbc   HL, BC 
1346			      push  HL                      ; Store the result for later (new block size) 
1346			 
1346			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1346			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1346			 
1346			      ; this_free block is not big enough, setup ptrs to test next free block 
1346			      pop   HL                      ; Discard previous result 
1346			 
1346			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1346			      ld    H, (IX+3) 
1346			      ld    (IX+4), L 
1346			      ld    (IX+5), H 
1346			 
1346			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1346			      ld    H, (IX+1) 
1346			      ld    (IX+2), L 
1346			      ld    (IX+3), H 
1346			 
1346			      jr    malloc_find_space 
1346			 
1346			      ; split a bigger block into two - requested size and remaining size 
1346			malloc_alloc_split: 
1346			      ex    DE, HL                  ; Calculate address of new free block 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			      add   HL, BC 
1346			 
1346			      ; Create a new block and point it at next_free 
1346			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1346			      ld    D, (IX+1) 
1346			 
1346			      ld    (HL), E                 ; Store next_free ptr into new block 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      pop   DE                      ; Store size of new block into new block 
1346			      inc   HL 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      ; Update this_free ptr to point to new block 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			 
1346			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1346			      ld    D, (IX+3) 
1346			 
1346			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1346			      ld    (IX+3), H 
1346			 
1346			      ; Modify this_free block to be allocation 
1346			      ex    DE, HL 
1346			      xor   A                       ; Null the next block ptr of allocated block 
1346			      ld    (HL), A 
1346			      inc   HL 
1346			      ld    (HL), A 
1346			 
1346			      inc   HL                      ; Store want size into allocated block 
1346			      ld    (HL), C 
1346			      inc   HL 
1346			      ld    (HL), B 
1346			      inc   HL 
1346			      push  HL                      ; Address of allocation to return 
1346			 
1346			      jr    malloc_update_links 
1346			 
1346			malloc_alloc_fit: 
1346			      pop   HL                      ; Dont need new block size, want is exact fit 
1346			 
1346			      ; Modify this_free block to be allocation 
1346			      ex    DE, HL 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			 
1346			      xor   A                       ; Null the next block ptr of allocated block 
1346			      ld    (HL), A 
1346			      inc   HL 
1346			      ld    (HL), A 
1346			 
1346			      inc   HL                      ; Store address of allocation to return 
1346			      inc   HL 
1346			      inc   HL 
1346			      push  HL 
1346			 
1346			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1346			      ld    L, (IX+0)               ; next_free to HL 
1346			      ld    H, (IX+1) 
1346			 
1346			      ld    (IX+2), L               ; HL to this_free 
1346			      ld    (IX+3), H 
1346			 
1346			 
1346			malloc_update_links: 
1346			      ; Update prev_free ptr to point to this_free 
1346			      ld    L, (IX+4)               ; prev_free ptr to HL 
1346			      ld    H, (IX+5) 
1346			 
1346			      ld    E, (IX+2)               ; this_free ptr to DE 
1346			      ld    D, (IX+3) 
1346			 
1346			      ld    (HL), E                 ; this_free ptr into prev_free 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      ; Clear the Z flag to indicate successful allocation 
1346			      ld    A, D 
1346			      or    E 
1346			 
1346			      pop   DE                      ; Address of allocation 
1346			 
1346			malloc_no_space: 
1346			      ld    HL, 6                   ; Clean up stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			 
1346			      ex    DE, HL                  ; Alloc addr into HL for return 
1346			 
1346			malloc_early_exit: 
1346			      pop   IX 
1346			      pop   DE 
1346			      pop   BC 
1346			 
1346			      ret 
1346			 
1346			 
1346			;------------------------------------------------------------------------------ 
1346			;     free                                                                    : 
1346			;                                                                             : 
1346			; Description                                                                 : 
1346			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1346			;     returned by malloc, otherwise the behaviour is undefined.               : 
1346			;                                                                             : 
1346			;     Where possible, directly adjacent free blocks will be merged together   : 
1346			;     into larger blocks to help ensure that the heap does not become         : 
1346			;     excessively fragmented.                                                 : 
1346			;                                                                             : 
1346			;     free does not clear or set any other value into the freed space, and    : 
1346			;     therefore its contents may be visible through subsequent malloc's. The  : 
1346			;     caller should clear the freed space as required.                        : 
1346			;                                                                             : 
1346			;     This implementation of free uses the stack exclusively, and is          : 
1346			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1346			;     advisable to disable interrupts before calling free, and recommended    : 
1346			;     to avoid the use of free inside ISRs in general.                        : 
1346			;                                                                             : 
1346			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1346			;                                                                             : 
1346			; Parameters                                                                  : 
1346			;     HL  Pointer to address of first byte of allocation to be freed          : 
1346			;                                                                             : 
1346			; Returns                                                                     : 
1346			;     Nothing                                                                 : 
1346			;                                                                             : 
1346			; Stack frame                                                                 : 
1346			;       |             |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     BC      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     DE      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |     IX      |                                                       : 
1346			;       +-------------+                                                       : 
1346			;       |  prev_free  |                                                       : 
1346			;   +2  +-------------+                                                       : 
1346			;       |  next_free  |                                                       : 
1346			;   +0  +-------------+                                                       : 
1346			;       |             |                                                       : 
1346			;                                                                             : 
1346			;------------------------------------------------------------------------------ 
1346			free: 
1346			      push  BC 
1346			      push  DE 
1346			      push  IX 
1346			 
1346			      ld    A, H                    ; Exit if ptr is null 
1346			      or    L 
1346			      jp    Z, free_early_exit 
1346			 
1346			      ; Set up stack frame 
1346			      ex    DE, HL 
1346			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			      ld    IX, 0                   ; Use IX as a frame pointer 
1346			      add   IX, SP 
1346			 
1346			      ; The address in HL points to the start of the useable allocated space, 
1346			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1346			      ; address of the block itself. 
1346			      ex    DE, HL 
1346			      ld    DE, -4 
1346			      add   HL, DE 
1346			 
1346			      ; An allocated block must have a null next block pointer in it 
1346			      ld    A, (HL) 
1346			      inc   HL 
1346			      or    (HL) 
1346			      jp    NZ, free_done 
1346			 
1346			      dec   HL 
1346			 
1346			      ld    B, H                    ; Copy HL to BC 
1346			      ld    C, L 
1346			 
1346			      ; Loop through the free list to find the first block with an address 
1346			      ; higher than the block being freed 
1346			      ld    HL, free_list 
1346			 
1346			free_find_higher_block: 
1346			      ld    E, (HL)                 ; Load next ptr from free block 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      dec   HL 
1346			 
1346			      ld    (IX+0), E               ; Save ptr to next free block 
1346			      ld    (IX+1), D 
1346			      ld    (IX+2), L               ; Save ptr to prev free block 
1346			      ld    (IX+3), H 
1346			 
1346			      ld    A, B                    ; Check if DE is greater than BC 
1346			      cp    D                       ; Compare MSB first 
1346			      jr    Z, $+4                  ; MSB the same, compare LSB 
1346			      jr    NC, free_find_higher_block_skip 
1346			      ld    A, C 
1346			      cp    E                       ; Then compare LSB 
1346			      jr    C, free_found_higher_block 
1346			 
1346			free_find_higher_block_skip: 
1346			      ld    A, D                    ; Reached the end of the free list? 
1346			      or    E 
1346			      jp    Z, free_done 
1346			 
1346			      ex    DE, HL 
1346			 
1346			      jr    free_find_higher_block 
1346			 
1346			free_found_higher_block: 
1346			      ; Insert freed block between prev and next free blocks 
1346			      ld    (HL), C                 ; Point prev free block to freed block 
1346			      inc   HL 
1346			      ld    (HL), B 
1346			 
1346			      ld    H, B                    ; Point freed block at next free block 
1346			      ld    L, C 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      ; Check if the freed block is adjacent to the next free block 
1346			      inc   HL                      ; Load size of freed block into HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      ex    DE, HL 
1346			 
1346			      add   HL, BC                  ; Add addr of freed block and its size 
1346			 
1346			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1346			      ld    D, (IX+1) 
1346			 
1346			      or    A                       ; Clear the carry flag 
1346			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1346			      jr    NZ, free_check_adjacent_to_prev 
1346			 
1346			      ; Freed block is adjacent to next, merge into one bigger block 
1346			      ex    DE, HL                  ; Load next ptr from next block into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  HL                      ; Save ptr to next block for later 
1346			 
1346			      ld    H, B                    ; Store ptr from next block into freed block 
1346			      ld    L, C 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      pop   HL                      ; Restore ptr to next block 
1346			      inc   HL                      ; Load size of next block into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  DE                      ; Save next block size for later 
1346			 
1346			      ld    H, B                    ; Load size of freed block into HL 
1346			      ld    L, C 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      ex    DE, HL 
1346			 
1346			      pop   DE                      ; Restore size of next block 
1346			      add   HL, DE                  ; Add sizes of both blocks 
1346			      ex    DE, HL 
1346			 
1346			      ld    H, B                    ; Store new bigger size into freed block 
1346			      ld    L, C 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			free_check_adjacent_to_prev: 
1346			      ; Check if the freed block is adjacent to the prev free block 
1346			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1346			      ld    H, (IX+3) 
1346			 
1346			      inc   HL                      ; Size of prev free block into DE 
1346			      inc   HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      dec   HL 
1346			      dec   HL 
1346			      dec   HL 
1346			 
1346			      add   HL, DE                  ; Add prev block addr and size 
1346			 
1346			      or    A                       ; Clear the carry flag 
1346			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1346			      jr    NZ, free_done 
1346			 
1346			      ; Freed block is adjacent to prev, merge into one bigger block 
1346			      ld    H, B                    ; Load next ptr from freed block into DE 
1346			      ld    L, C 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  HL                      ; Save freed block ptr for later 
1346			 
1346			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1346			      ld    H, (IX+3) 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			      pop   HL                      ; Restore freed block ptr 
1346			      inc   HL                      ; Load size of freed block into DE 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			      push  DE                      ; Save freed block size for later 
1346			 
1346			      ld    L, (IX+2)               ; Load size of prev block into DE 
1346			      ld    H, (IX+3) 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    E, (HL) 
1346			      inc   HL 
1346			      ld    D, (HL) 
1346			 
1346			      pop   HL                      ; Add sizes of both blocks 
1346			      add   HL, DE 
1346			      ex    DE, HL 
1346			 
1346			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1346			      ld    H, (IX+3) 
1346			      inc   HL 
1346			      inc   HL 
1346			      ld    (HL), E 
1346			      inc   HL 
1346			      ld    (HL), D 
1346			 
1346			free_done: 
1346			      ld    HL, 4                   ; Clean up stack frame 
1346			      add   HL, SP 
1346			      ld    SP, HL 
1346			 
1346			free_early_exit: 
1346			      pop   IX 
1346			      pop   DE 
1346			      pop   BC 
1346			 
1346			      ret 
1346			 
1346			 
1346			;      .org 0x8000 
1346			; 
1346			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1346			 ;                 .dw   0 
1346			 
1346			endif 
1346			 
1346			 
1346			if MALLOC_4 
1346			 
1346			; My memory allocation code. Very very simple.... 
1346			; allocate space under 250 chars 
1346			 
1346			heap_init: 
1346				; init start of heap as zero 
1346				;  
1346			 
1346				ld hl, heap_start 
1346			;	ld a, 0 
1346				ld (hl), 0      ; empty block 
1346				inc hl 
1346			;	ld a, 0 
1346				ld (hl), 0      ; length of block 
1346				; write end of list 
1346				inc hl 
1346				ld a,(hl) 
1346				inc hl 
1346				ld a,(hl) 
1346				 
1346			 
1346				; init some malloc vars 
1346			 
1346				ld hl, 0 
1346				ld (free_list), hl       ; store last malloc location 
1346			 
1346				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1346			;	ld a, 0 
1346				ld (hl), 0 
1346			 
1346			 
1346				ld hl, heap_start 
1346				;  
1346				  
1346				ret 
1346			 
1346			 
1346			;    free block marker 
1346			;    requested size  
1346			;    pointer to next block 
1346			;    .... 
1346			;    next block marker 
1346			 
1346			 
1346			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1346			; 
1346			 
1346			 
1346			malloc:  
1346				push de 
1346				push bc 
1346				push af 
1346			 
1346				; hl space required 
1346				 
1346				ld c, l    ; hold space   (TODO only a max of 255) 
1346			 
1346			;	inc c     ; TODO BUG need to fix memory leak on push str 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			;	inc c 
1346			 
1346			 
1346			 
1346				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1346			 
1346				ld a, (free_list+3) 
1346			;	cp 0 
1346				or a 
1346				jr z, .contheap 
1346			 
1346				ld hl, (free_list)     ; get last alloc 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mrs" 
1346						CALLMONITOR 
1346					endif 
1346				jr .startalloc 
1346			 
1346			.contheap: 
1346				ld hl, heap_start 
1346			 
1346			.startalloc: 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mym" 
1346						CALLMONITOR 
1346					endif 
1346			.findblock: 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mmf" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346				ld a,(hl)  
1346				; if byte is zero then clear to use 
1346			 
1346			;	cp 0 
1346				or a 
1346				jr z, .foundemptyblock 
1346			 
1346				; if byte is not clear 
1346				;     then byte is offset to next block 
1346			 
1346				inc hl 
1346				ld a, (hl) ; get size 
1346			.nextblock:	inc hl 
1346					ld e, (hl) 
1346					inc hl 
1346					ld d, (hl) 
1346					ex de, hl 
1346			;	inc hl  ; move past the store space 
1346			;	inc hl  ; move past zero index  
1346			 
1346				; TODO detect no more space 
1346			 
1346				push hl 
1346				ld de, heap_end 
1346				call cmp16 
1346				pop hl 
1346				jr nc, .nospace 
1346			 
1346				jr .findblock 
1346			 
1346			.nospace: ld hl, 0 
1346				jp .exit 
1346			 
1346			 
1346			.foundemptyblock:	 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mme" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			; TODO has block enough space if reusing??? 
1346			 
1346				;  
1346			 
1346			; see if this block has been previously used 
1346				inc hl 
1346				ld a, (hl) 
1346				dec hl 
1346			;	cp 0 
1346				or a 
1346				jr z, .newblock 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "meR" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			; no reusing previously allocated block 
1346			 
1346			; is it smaller than previously used? 
1346				 
1346				inc hl    ; move to size 
1346				ld a, c 
1346				sub (hl)        ; we want c < (hl) 
1346				dec hl    ; move back to marker 
1346			        jr z, .findblock 
1346			 
1346				; update with the new size which should be lower 
1346			 
1346			        ;inc  hl   ; negate next move. move back to size  
1346			 
1346			.newblock: 
1346				; need to be at marker here 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "meN" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			 
1346				ld a, c 
1346			 
1346				ld (free_list+3), a	 ; flag resume from last malloc  
1346				ld (free_list), hl    ; save out last location 
1346			 
1346			 
1346				;inc a     ; space for length byte 
1346				ld (hl), a     ; save block in use marker 
1346			 
1346				inc hl   ; move to space marker 
1346				ld (hl), a    ; save new space 
1346			 
1346				inc hl   ; move to start of allocated area 
1346				 
1346			;	push hl     ; save where we are - 1  
1346			 
1346			;	inc hl  ; move past zero index  
1346				; skip space to set down new marker 
1346			 
1346				; provide some extra space for now 
1346			 
1346				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1346				inc a 
1346				inc a 
1346			 
1346				push hl   ; save where we are in the node block 
1346			 
1346				call addatohl 
1346			 
1346				; write linked list point 
1346			 
1346				pop de     ; get our node position 
1346				ex de, hl 
1346			 
1346				ld (hl), e 
1346				inc hl 
1346				ld (hl), d 
1346			 
1346				inc hl 
1346			 
1346				; now at start of allocated data so save pointer 
1346			 
1346				push hl 
1346			 
1346				; jump to position of next node and setup empty header in DE 
1346			 
1346				ex de, hl 
1346			 
1346			;	inc hl ; move past end of block 
1346			 
1346			;	ld a, 0 
1346				ld (hl), 0   ; empty marker 
1346				inc hl 
1346				ld (hl), 0   ; size 
1346				inc hl  
1346				ld (hl), 0   ; ptr 
1346				inc hl 
1346				ld (hl), 0   ; ptr 
1346			 
1346			 
1346				pop hl 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "mmr" 
1346						CALLMONITOR 
1346					endif 
1346			 
1346			.exit: 
1346				pop af 
1346				pop bc 
1346				pop de  
1346				ret 
1346			 
1346			 
1346			 
1346			 
1346			free:  
1346				push hl 
1346				push af 
1346				; get address in hl 
1346			 
1346					if DEBUG_FORTH_MALLOC_INT 
1346						DMARK "fre" 
1346						CALLMONITOR 
1346					endif 
1346				; data is at hl - move to block count 
1346				dec hl 
1346				dec hl    ; get past pointer 
1346				dec hl 
1346			 
1346				ld a, (hl)    ; need this for a validation check 
1346			 
1346				dec hl    ; move to block marker 
1346			 
1346				; now check that the block count and block marker are the same  
1346			        ; this checks that we are on a malloc node and not random memory 
1346			        ; OK a faint chance this could be a problem but rare - famous last words! 
1346			 
1346				ld c, a 
1346				ld a, (hl)    
1346			 
1346				cp c 
1346				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1346			 
1346				; yes good chance we are on a malloc node 
1346			 
1346			;	ld a, 0      
1346				ld (hl), 0   ; mark as free 
1346			 
1346				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1346			 
1346			.freeignore:  
1346			 
1346				pop af 
1346				pop hl 
1346			 
1346				ret 
1346			 
1346			 
1346			 
1346			endif 
1346			 
1346			; eof 
# End of file firmware_memory.asm
1346			  
1346			; device C  
1346			; Now handled by SPI  
1346			;if SOUND_ENABLE  
1346			;	include "firmware_sound.asm"  
1346			;endif  
1346			  
1346			include "firmware_diags.asm"  
1346			; Hardware diags menu 
1346			 
1346			 
1346			config: 
1346			 
1346 3e 00			ld a, 0 
1348 21 67 13			ld hl, .configmn 
134b cd e7 0b			call menu 
134e			 
134e fe 00			cp 0 
1350 c8				ret z 
1351			 
1351			;	cp 1 
1351			;	call z, .savetostore 
1351			 
1351 fe 01			cp 1 
1353			if STARTUP_V1 
1353 cc 7b 13			call z, .selautoload 
1356			endif 
1356			 
1356			if STARTUP_V2 
1356				call z, .enautoload 
1356			endif 
1356 fe 02			cp 2 
1358 cc 71 13			call z, .disautoload 
135b			;	cp 3 
135b			;	call z, .selbank 
135b fe 03			cp 3 
135d cc 99 13			call z, .debug_tog 
1360 fe 04			cp 4 
1362 cc 67 14			call z, .bpsgo 
1365			;	cp 5 
1365			;	call z, hardware_diags 
1365			if STARTUP_V2 
1365				cp 5 
1365				call z, create_startup 
1365			endif 
1365 18 df			jr config 
1367			 
1367			.configmn: 
1367			;	dw prom_c3 
1367 55 16			dw prom_c2 
1369 6a 16			dw prom_c2a 
136b			;	dw prom_c2b 
136b			;	dw prom_c4 
136b 89 16			dw prom_m4 
136d a4 16			dw prom_m4b 
136f			;	dw prom_c1 
136f			if STARTUP_V2 
136f				dw prom_c9 
136f			endif 
136f 00 00			dw 0 
1371				 
1371			 
1371			if STARTUP_V2 
1371			.enautoload: 
1371				if STORAGE_SE 
1371				ld a, $fe      ; bit 0 clear 
1371				ld (spi_device), a 
1371			 
1371				call storage_get_block_0 
1371			 
1371				ld a, 1 
1371				ld (store_page+STORE_0_AUTOFILE), a 
1371			 
1371					ld hl, 0 
1371					ld de, store_page 
1371				call storage_write_block	 ; save update 
1371				else 
1371			 
1371				ld hl, prom_notav 
1371				ld de, prom_empty 
1371				call info_panel 
1371				endif 
1371			 
1371			 
1371				ret 
1371			endif 
1371			 
1371			.disautoload: 
1371				if STORAGE_SE 
1371				ld a, $fe      ; bit 0 clear 
1371				ld (spi_device), a 
1371			 
1371				call storage_get_block_0 
1371			 
1371				ld a, 0 
1371				ld (store_page+STORE_0_AUTOFILE), a 
1371			 
1371					ld hl, 0 
1371					ld de, store_page 
1371				call storage_write_block	 ; save update 
1371				else 
1371			 
1371 21 ac 16			ld hl, prom_notav 
1374 11 c2 16			ld de, prom_empty 
1377 cd 49 0b			call info_panel 
137a				endif 
137a			 
137a			 
137a c9				ret 
137b			 
137b			if STARTUP_V1 
137b			 
137b			; Select auto start 
137b			 
137b			.selautoload: 
137b			 
137b				 
137b				if STORAGE_SE 
137b			 
137b					call config_dir 
137b				        ld hl, scratch 
137b					ld a, 0 
137b					call menu 
137b			 
137b					cp 0 
137b					ret z 
137b			 
137b					dec a 
137b			 
137b			 
137b					; locate menu option 
137b			 
137b					ld hl, scratch 
137b					call table_lookup 
137b			 
137b					if DEBUG_FORTH_WORDS 
137b						DMARK "ALl" 
137b						CALLMONITOR 
137b					endif 
137b					; with the pointer to the menu it, the byte following the zero term is the file id 
137b			 
137b					ld a, 0 
137b					ld bc, 50   ; max of bytes to look at 
137b					cpir  
137b			 
137b					if DEBUG_FORTH_WORDS 
137b						DMARK "ALb" 
137b						CALLMONITOR 
137b					endif 
137b					;inc hl 
137b			 
137b					ld a, (hl)   ; file id 
137b					 
137b				        ; save bank and file ids 
137b			 
137b					push af 
137b			 
137b			; TODO need to save to block 0 on bank 1	 
137b			 
137b					call storage_get_block_0 
137b			 
137b					if DEBUG_FORTH_WORDS 
137b						DMARK "AL0" 
137b						CALLMONITOR 
137b					endif 
137b					pop af 
137b			 
137b					ld (store_page+STORE_0_FILERUN),a 
137b					 
137b					; save bank id 
137b			 
137b					ld a,(spi_device) 
137b					ld (store_page+STORE_0_BANKRUN),a 
137b			 
137b					; enable auto run of store file 
137b			 
137b					ld a, 1 
137b					ld (store_page+STORE_0_AUTOFILE),a 
137b			 
137b					; save buffer 
137b			 
137b					ld hl, 0 
137b					ld de, store_page 
137b					if DEBUG_FORTH_WORDS 
137b						DMARK "ALw" 
137b						CALLMONITOR 
137b					endif 
137b				call storage_write_block	 ; save update 
137b			  
137b			 
137b			 
137b			 
137b					ld hl, scratch 
137b					call config_fdir 
137b			 
137b				else 
137b			 
137b 21 ac 16			ld hl, prom_notav 
137e 11 c2 16			ld de, prom_empty 
1381 cd 49 0b			call info_panel 
1384			 
1384				endif 
1384 c9				ret 
1385			endif 
1385			 
1385			 
1385			; Select storage bank 
1385			 
1385			.selbank: 
1385			 
1385			;	if STORAGE_SE 
1385			;	else 
1385			 
1385 21 ac 16			ld hl, prom_notav 
1388 11 c2 16			ld de, prom_empty 
138b cd 49 0b			call info_panel 
138e			;	endif 
138e				 
138e c9				ret 
138f			 
138f			if STORAGE_SE 
138f			 
138f			.config_ldir:   
138f				; Load storage bank labels into menu array 
138f			 
138f				 
138f			 
138f			 
138f				ret 
138f			 
138f			 
138f			endif 
138f			 
138f			 
138f			; Save user words to storage 
138f			 
138f			.savetostore: 
138f			 
138f			;	if STORAGE_SE 
138f			; 
138f			;		call config_dir 
138f			;	        ld hl, scratch 
138f			;		ld a, 0 
138f			;		call menu 
138f			;		 
138f			;		ld hl, scratch 
138f			;		call config_fdir 
138f			; 
138f			;	else 
138f			 
138f 21 ac 16			ld hl, prom_notav 
1392 11 c2 16			ld de, prom_empty 
1395 cd 49 0b			call info_panel 
1398			 
1398			;	endif 
1398			 
1398 c9				ret 
1399			 
1399			if STARTUP_V2 
1399			 
1399			create_startup: 
1399			 
1399				ld a, 0 
1399				ld hl, .crstart 
1399				call menu 
1399			 
1399				cp 0 
1399				ret z 
1399			 
1399				cp 1 
1399				call z, .genlsword 
1399				cp 2 
1399				call z, .genedword 
1399			 
1399				cp 3 
1399				call z, .gendemword 
1399			 
1399				cp 4 
1399				call z, .genutlword 
1399				cp 5 
1399				call z, .genspiword 
1399				cp 6 
1399				call z, .genkeyword 
1399				cp 7 
1399				call z, .gensoundword 
1399				cp 8 
1399				call z, .genhwword 
1399				jr create_startup 
1399			 
1399			.genhwword: 
1399				ld hl, crs_hw 
1399				ld de, .hwworddef 
1399				call .genfile 
1399				ret 
1399			.gensoundword: 
1399				ld hl, crs_sound 
1399				ld de, .soundworddef 
1399				call .genfile 
1399				ret 
1399			.genlsword: 
1399				ld hl, crs_s1 
1399				ld de, .lsworddef 
1399				call .genfile 
1399				ret 
1399			 
1399			.genedword: 
1399				ld de, .edworddef 
1399				ld hl, crs_s2 
1399				call .genfile 
1399				ret 
1399			 
1399			.gendemword: 
1399				ld de, .demoworddef 
1399				ld hl, crs_s3 
1399				call .genfile 
1399				ret 
1399			 
1399			.genutlword: 
1399				ld hl, crs_s4 
1399				ld de, .utilwordef 
1399				call .genfile 
1399				ret 
1399			.genspiword: 
1399				ld hl, crs_s5 
1399				ld de, .spiworddef 
1399				call .genfile 
1399				ret 
1399			.genkeyword: 
1399				ld hl, crs_s6 
1399				ld de, .keyworddef 
1399				call .genfile 
1399				ret 
1399			 
1399			; hl - points to file name 
1399			; de - points to strings to add to file 
1399			 
1399			.genfile: 
1399				push hl 
1399				push de 
1399			 
1399				call clear_display 
1399				ld a, display_row_1 
1399				ld de, .genfiletxt 
1399				call str_at_display 
1399				call update_display 
1399			 
1399				pop de 
1399				pop hl 
1399			 
1399			 
1399				push de 
1399				call storage_create 
1399				; id in hl 
1399				pop de   ; table of strings to add 
1399			 
1399			.genloop: 
1399			 
1399				push hl ; save id for next time around 
1399				push de ; save de for next time around 
1399			 
1399				ex de, hl 
1399				call loadwordinhl 
1399				ex de, hl 
1399			 
1399				; need hl to be the id 
1399				; need de to be the string ptr 
1399				 
1399				call storage_append 
1399			 
1399				pop de 
1399				pop hl 
1399			 
1399				inc de 
1399				inc de 
1399			 
1399				ld a,(de) 
1399				cp 0 
1399				jr nz, .genloop 
1399				inc de 
1399				ld a, (de) 
1399				dec de 
1399				cp 0 
1399				jr nz, .genloop	 
1399			 
1399				ret 
1399			 
1399			.genfiletxt:  db "Creating file...",0 
1399			 
1399			.hwworddef: 
1399				dw test5 
1399				dw test6 
1399				dw test7 
1399				dw test8 
1399				dw test9 
1399				dw test10 
1399				dw 0 
1399			 
1399			.soundworddef: 
1399				dw sound1 
1399				dw sound2 
1399				dw sound3 
1399				dw sound4 
1399				dw sound5 
1399				dw sound6 
1399				dw sound7 
1399				dw sound8 
1399				dw sound9 
1399				dw 0 
1399			 
1399			.utilwordef: 
1399				dw strncpy 
1399				dw type 
1399				dw tuck 
1399				dw clrstack 
1399				dw longread 
1399				dw start1 
1399				dw start2 
1399			; duplicated 
1399			;	dw start3b 
1399			;	dw start3c 
1399				dw list 
1399				dw 0 
1399			 
1399			.lsworddef: 
1399				dw start3b 
1399				dw 0 
1399			 
1399			.edworddef: 
1399				dw edit1 
1399				dw edit2 
1399				dw edit3 
1399				dw 0 
1399			 
1399			.demoworddef: 
1399				dw game1 
1399				dw game1a 
1399				dw game1b 
1399				dw game1c 
1399				dw game1d 
1399				dw game1s 
1399				dw game1t 
1399				dw game1f 
1399				dw game1z 
1399				dw game1zz 
1399				dw ssv2 
1399				dw ssv3 
1399				dw ssv4 
1399				dw ssv5 
1399				dw ssv1 
1399				dw ssv1cpm	 
1399			;	dw game2b 
1399			;	dw game2bf 
1399			;	dw game2mba 
1399			;	dw game2mbas	 
1399			;	dw game2mbht 
1399			;	dw game2mbms 
1399			;	dw game2mb 
1399			;	dw game3w 
1399			;	dw game3p 
1399			;	dw game3sc 
1399			;	dw game3vsi 
1399			;	dw game3vs 
1399				dw 0 
1399			 
1399			 
1399			.spiworddef: 
1399			 
1399			    dw spi1 
1399			    dw spi2 
1399			    dw spi2b 
1399			    dw spi3 
1399			    dw spi4 
1399			    dw spi5 
1399			;    dw spi6 
1399			;    dw spi7 
1399			 
1399			;    dw spi8 
1399			;    dw spi9 
1399			;    dw spi10 
1399			    dw 0 
1399			 
1399			.keyworddef: 
1399			 
1399				dw keyup 
1399				dw keydown 
1399				dw keyleft 
1399				dw keyright 
1399				dw 	keyf1 
1399				dw keyf2 
1399				dw keyf3 
1399				dw keyf4 
1399				dw keyf5 
1399				dw keyf6 
1399				dw keyf7 
1399				dw keyf8 
1399				dw keyf9 
1399				dw keyf10 
1399				dw keyf11 
1399				dw keyf12 
1399				dw keytab 
1399				dw keycr 
1399				dw keyhome 
1399				dw keyend 
1399				dw keybs 
1399				dw 0 
1399			 
1399			.crstart: 
1399				dw crs_s1 
1399				dw crs_s2 
1399				dw crs_s3 
1399				dw crs_s4 
1399				dw crs_s5 
1399				dw crs_s6 
1399				dw crs_sound 
1399				dw crs_hw 
1399				dw 0 
1399			 
1399			endif 
1399			 
1399			 
1399			if STORAGE_SE 
1399			 
1399			config_fdir: 
1399				; using the scratch dir go through and release the memory allocated for each string 
1399				 
1399				ld hl, scratch 
1399			.cfdir:	ld e,(hl) 
1399				inc hl 
1399				ld d,(hl) 
1399				inc hl 
1399			 
1399				ex de, hl 
1399				call ishlzero 
1399				ret z     ; return on null pointer 
1399				call free 
1399				ex de, hl 
1399				jr .cfdir 
1399			 
1399			 
1399				ret 
1399			 
1399			 
1399			config_dir: 
1399			 
1399				; for the config menus that need to build a directory of storage call this routine 
1399				; it will construct a menu in scratch to pass to menu 
1399			 
1399				; open storage device 
1399			 
1399				; execute DIR to build a list of files and their ids into scratch in menu format 
1399				; once the menu has finished then will need to call config_fdir to release the strings 
1399				 
1399				; c = number items 
1399			 
1399				 
1399				call storage_get_block_0 
1399			 
1399				ld hl, store_page     ; get current id count 
1399				ld b, (hl) 
1399				ld c, 0    ; count of files   
1399			 
1399			 
1399				ld hl, scratch 
1399				ld (store_tmp2), hl    ; location to poke strings 
1399			 
1399				; check for empty drive 
1399			 
1399				ld a, 0 
1399				cp b 
1399				jp z, .dirdone 
1399			 
1399				 
1399					if DEBUG_FORTH_WORDS 
1399						DMARK "Cdc" 
1399						CALLMONITOR 
1399					endif 
1399			 
1399			 
1399			.diritem:	 
1399				push bc 
1399				; for each of the current ids do a search for them and if found push to stack 
1399			 
1399					ld hl, STORE_BLOCK_PHY 
1399					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1399					ld e,b 
1399			 
1399					call storage_findnextid 
1399			 
1399			 
1399					; if found hl will be non zero 
1399			 
1399					call ishlzero 
1399					jr z, .dirnotfound 
1399			 
1399					; increase count 
1399			 
1399					pop bc	 
1399					inc c 
1399					push bc 
1399					 
1399			 
1399					; get file header and push the file name 
1399			 
1399					ld de, store_page 
1399					call storage_read_block 
1399			 
1399					; push file id to stack 
1399				 
1399					ld a, (store_page) 
1399					ld h, 0 
1399					ld l, a 
1399			 
1399					;call forth_push_numhl 
1399					; TODO store id 
1399			 
1399					push hl 
1399			 
1399					; push extent count to stack  
1399				 
1399					ld hl, store_page+3 
1399			 
1399					; get file name length 
1399			 
1399					call strlenz   
1399			 
1399					inc hl   ; cover zero term 
1399					inc hl  ; stick the id at the end of the area 
1399			 
1399					push hl 
1399					pop bc    ; move length to bc 
1399			 
1399					call malloc 
1399			 
1399					; TODO save malloc area to scratch 
1399			 
1399					ex de, hl 
1399					ld hl, (store_tmp2) 
1399					ld (hl), e 
1399					inc hl 
1399					ld (hl), d 
1399					inc hl 
1399					ld (store_tmp2), hl 
1399			 
1399					 
1399			 
1399					;pop hl   ; get source 
1399			;		ex de, hl    ; swap aronund	 
1399			 
1399					ld hl, store_page+3 
1399					if DEBUG_FORTH_WORDS 
1399						DMARK "CFd" 
1399						CALLMONITOR 
1399					endif 
1399					ldir 
1399			 
1399					; de is past string, move back one and store id 
1399					 
1399					dec de 
1399			 
1399					; store file id 
1399			 
1399					pop hl 
1399					ex de,hl 
1399					ld (hl), e 
1399			 
1399					if DEBUG_FORTH_WORDS 
1399						DMARK "Cdi" 
1399						CALLMONITOR 
1399					endif 
1399					 
1399			.dirnotfound: 
1399					pop bc     
1399					djnz .diritem 
1399				 
1399			.dirdone:	 
1399			 
1399			;		ld a, 0 
1399					ld hl, (store_tmp2) 
1399					ld (hl), 0 
1399					inc hl 
1399					ld (hl), 0 
1399					inc hl 
1399					; push a count of the dir items found 
1399			 
1399			;		ld h, 0 
1399			;		ld l, c 
1399			 
1399				ret 
1399			 
1399			endif 
1399			 
1399			 
1399			; Settings 
1399			; Run  
1399			 
1399			 
1399			 
1399			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1399			;;hd_menu2:   db "        2: Editor",0   
1399			;hd_menu2:   db "        2: Editor       6: Menu",0   
1399			;hd_menu3:   db "        3: Storage",0 
1399			;hd_menu4:   db "0=quit  4: Debug",0 
1399			;hd_don:     db "ON",0 
1399			;hd_doff:     db "OFF",0 
1399			; 
1399			; 
1399			; 
1399			;hardware_diags_old:       
1399			; 
1399			;.diagmenu: 
1399			;	call clear_display 
1399			;	ld a, display_row_1 
1399			;	ld de, hd_menu1 
1399			;	call str_at_display 
1399			; 
1399			;	ld a, display_row_2 
1399			;	ld de, hd_menu2 
1399			;	call str_at_display 
1399			; 
1399			;	ld a, display_row_3 
1399			;	ld de, hd_menu3 
1399			;	call str_at_display 
1399			; 
1399			;	ld a,  display_row_4 
1399			;	ld de, hd_menu4 
1399			;	call str_at_display 
1399			; 
1399			;	; display debug state 
1399			; 
1399			;	ld de, hd_don 
1399			;	ld a, (os_view_disable) 
1399			;	cp 0 
1399			;	jr z, .distog 
1399			;	ld de, hd_doff 
1399			;.distog: ld a, display_row_4+17 
1399			;	call str_at_display 
1399			; 
1399			;	call update_display 
1399			; 
1399			;	call cin_wait 
1399			; 
1399			; 
1399			; 
1399			;	cp '4' 
1399			;	jr nz, .diagn1 
1399			; 
1399			;	; debug toggle 
1399			; 
1399			;	ld a, (os_view_disable) 
1399			;	ld b, '*' 
1399			;	cp 0 
1399			;	jr z, .debtog 
1399			;	ld b, 0 
1399			;.debtog:	 
1399			;	ld a,b 
1399			;	ld (os_view_disable),a 
1399			; 
1399			;.diagn1: cp '0' 
1399			;	 ret z 
1399			; 
1399			;;	cp '1' 
1399			;;       jp z, matrix	 
1399			;;   TODO keyboard matrix test 
1399			; 
1399			;	cp '2' 
1399			;	jp z, .diagedit 
1399			; 
1399			;;	cp '6' 
1399			;;	jp z, .menutest 
1399			;;if ENABLE_BASIC 
1399			;;	cp '6' 
1399			;;	jp z, basic 
1399			;;endif 
1399			 ; 
1399			;	jp .diagmenu 
1399			; 
1399			; 
1399			;	ret 
1399			 
1399			 
1399			.debug_tog: 
1399 21 c2 13			ld hl, .menudebug 
139c				 
139c			;	ld a, (os_view_disable) 
139c			;	cp '*' 
139c 3a 6f ee			ld a,(debug_vector) 
139f fe c9			cp $C9   ; RET 
13a1 20 04			jr nz,.tdon  
13a3 3e 01			ld a, 1 
13a5 18 02			jr .tog1 
13a7 3e 00		.tdon: ld a, 0 
13a9			 
13a9			.tog1: 
13a9 cd e7 0b			call menu 
13ac fe 00			cp 0 
13ae c8				ret z 
13af fe 01			cp 1    ; disable debug 
13b1 28 04			jr z, .dtog0 
13b3 3e 2a			ld a, '*' 
13b5 18 05			jr .dtogset 
13b7			.dtog0:  
13b7				;ld a, 0 
13b7 cd 55 14			call bp_on 
13ba 18 dd			jr .debug_tog 
13bc			.dtogset:  
13bc				; ld (os_view_disable), a 
13bc cd 61 14			call bp_off 
13bf c3 99 13			jp .debug_tog 
13c2			 
13c2			 
13c2			.menudebug: 
13c2 c8 13				dw .m6 
13c4 d1 13				dw .m7 
13c6 00 00				dw 0 
13c8 .. 00		.m6:   db "Debug ON",0 
13d1 .. 00		.m7:   db "Debug OFF",0 
13db			;hardware_diags:       
13db			 
13db			ENABLE_HDIAGS: equ 0 
13db			 
13db			if ENABLE_HDIAGS 
13db			.diagm: 
13db				ld hl, .menuitems 
13db				ld a, 0 
13db				call menu 
13db			 
13db			         cp 0 
13db				 ret z 
13db			 
13db				cp 2 
13db				jp z, .diagedit 
13db			 
13db			;	cp '6' 
13db			;	jp z, .menutest 
13db			;if ENABLE_BASIC 
13db			;	cp '6' 
13db			;	jp z, basic 
13db			;endif 
13db			  
13db				jp .diagm 
13db			 
13db				 
13db			.menuitems:   	dw .m1 
13db					dw .m2 
13db					dw .m3 
13db					dw .m5 
13db					dw .m5a 
13db					dw .m5b 
13db					dw 0 
13db			 
13db			 
13db			.m1:   db "Key Matrix",0 
13db			.m2:   db "Editor",0 
13db			.m3:   db "Storage",0 
13db			.m5:   db "Sound",0 
13db			.m5a:  db "RAM Test",0 
13db			.m5b:  db "LCD Test",0 
13db			 
13db			 
13db			; debug editor 
13db			 
13db			.diagedit: 
13db			 
13db				ld hl, scratch 
13db			;	ld bc, 250 
13db			;	ldir 
13db				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13db			;	ld a, 0 
13db				ld (hl), 0 
13db				inc hl 
13db				ld (hl), 0 
13db				inc hl 
13db				ld (hl), 0 
13db			 
13db			        call clear_display 
13db				call update_display 
13db				;ld a, 1 
13db				;ld (hardware_diag), a 
13db			.diloop: 
13db				ld a, display_row_1 
13db				ld c, 0 
13db				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13db				ld e, 40 
13db			 
13db				ld hl, scratch	 
13db				call input_str 
13db			 
13db				ld a, display_row_2 
13db				ld de, scratch 
13db				call str_at_display 
13db				call update_display 
13db			 
13db				jp .diloop 
13db			endif 
13db			 
13db			; pass word in hl 
13db			; a has display location 
13db			display_word_at: 
13db f5				push af 
13dc e5				push hl 
13dd 7c				ld a,h 
13de 21 bd e5			ld hl, os_word_scratch 
13e1 cd dd 0f			call hexout 
13e4 e1				pop hl 
13e5 7d				ld a,l 
13e6 21 bf e5			ld hl, os_word_scratch+2 
13e9 cd dd 0f			call hexout 
13ec 21 c1 e5			ld hl, os_word_scratch+4 
13ef			;	ld a,0 
13ef 36 00			ld (hl),0 
13f1 11 bd e5			ld de,os_word_scratch 
13f4 f1				pop af 
13f5 cd c9 0b				call str_at_display 
13f8 c9				ret 
13f9			 
13f9			display_ptr_state: 
13f9			 
13f9				; to restore afterwards 
13f9			 
13f9 d5				push de 
13fa c5				push bc 
13fb e5				push hl 
13fc f5				push af 
13fd			 
13fd				; for use in here 
13fd			 
13fd			;	push bc 
13fd			;	push de 
13fd			;	push hl 
13fd			;	push af 
13fd			 
13fd cd b7 0b			call clear_display 
1400			 
1400 11 d8 15			ld de, .ptrstate 
1403 3e 00			ld a, display_row_1 
1405 cd c9 0b			call str_at_display 
1408			 
1408				; display debug step 
1408			 
1408			 
1408 11 62 ee			ld de, debug_mark 
140b 3e 26			ld a, display_row_1+display_cols-2 
140d cd c9 0b			call str_at_display 
1410			 
1410				; display a 
1410 11 e2 15			ld de, .ptrcliptr 
1413 3e 28			ld a, display_row_2 
1415 cd c9 0b			call str_at_display 
1418			 
1418 f1				pop af 
1419 2a 37 ea			ld hl,(cli_ptr) 
141c 3e 30			ld a, display_row_2+8 
141e cd db 13			call display_word_at 
1421			 
1421			 
1421				; display hl 
1421			 
1421			 
1421 11 ea 15			ld de, .ptrclioptr 
1424 3e 32			ld a, display_row_2+10 
1426 cd c9 0b			call str_at_display 
1429			; 
1429			;	pop hl 
1429 3e 35			ld a, display_row_2+13 
142b 2a 35 ea			ld hl,(cli_origptr) 
142e cd db 13			call display_word_at 
1431			; 
1431			;	 
1431			;	; display de 
1431			 
1431			;	ld de, .regstatede 
1431			;	ld a, display_row_3 
1431			;	call str_at_display 
1431			 
1431			;	pop de 
1431			;	ld h,d 
1431			;	ld l, e 
1431			;	ld a, display_row_3+3 
1431			;	call display_word_at 
1431			 
1431			 
1431				; display bc 
1431			 
1431			;	ld de, .regstatebc 
1431			;	ld a, display_row_3+10 
1431			;	call str_at_display 
1431			 
1431			;	pop bc 
1431			;	ld h,b 
1431			;	ld l, c 
1431			;	ld a, display_row_3+13 
1431			;	call display_word_at 
1431			 
1431			 
1431				; display dsp 
1431			 
1431			;	ld de, .regstatedsp 
1431			;	ld a, display_row_4 
1431			;	call str_at_display 
1431			 
1431				 
1431			;	ld hl,(cli_data_sp) 
1431			;	ld a, display_row_4+4 
1431			;	call display_word_at 
1431			 
1431				; display rsp 
1431			 
1431 11 19 16			ld de, .regstatersp 
1434 3e 82			ld a, display_row_4+10 
1436 cd c9 0b			call str_at_display 
1439			 
1439				 
1439 2a e9 e9			ld hl,(cli_ret_sp) 
143c 3e 86			ld a, display_row_4+14 
143e cd db 13			call display_word_at 
1441			 
1441 cd d9 0b			call update_display 
1444			 
1444 cd f0 0a			call delay1s 
1447 cd f0 0a			call delay1s 
144a cd f0 0a			call delay1s 
144d			 
144d			 
144d cd 4e 1a			call next_page_prompt 
1450			 
1450				; restore  
1450			 
1450 f1				pop af 
1451 e1				pop hl 
1452 c1				pop bc 
1453 d1				pop de 
1454 c9				ret 
1455			 
1455			; Update the break point vector so that the user can hook a new routine 
1455			 
1455			bp_on: 
1455 3e c3			ld a, $c3    ; JP 
1457 32 6f ee			ld (debug_vector), a 
145a 21 67 14			ld hl, break_point_state 
145d 22 70 ee			ld (debug_vector+1), hl 
1460 c9				ret 
1461			 
1461			bp_off: 
1461 3e c9			ld a, $c9    ; RET 
1463 32 6f ee			ld (debug_vector), a 
1466 c9				ret 
1467			 
1467			 
1467			break_point_state: 
1467			;	push af 
1467			; 
1467			;	; see if disabled 
1467			; 
1467			;	ld a, (os_view_disable) 
1467			;	cp '*' 
1467			;	jr nz, .bpsgo 
1467			;	pop af 
1467			;	ret 
1467			 
1467			.bpsgo: 
1467			;	pop af 
1467 f5				push af 
1468 22 9a e2			ld (os_view_hl), hl 
146b ed 53 98 e2		ld (os_view_de), de 
146f ed 43 96 e2		ld (os_view_bc), bc 
1473 e5				push hl 
1474 6f				ld l, a 
1475 26 00			ld h, 0 
1477 22 9c e2			ld (os_view_af),hl 
147a			 
147a 21 a8 ed				ld hl, display_fb0 
147d 22 c3 eb				ld (display_fb_active), hl 
1480 e1				pop hl	 
1481			 
1481 3e 31			ld a, '1' 
1483 fe 2a		.bps1:  cp '*' 
1485 cc 61 14			call z, bp_off 
1488			;	jr nz, .bps1b 
1488			;	ld (os_view_disable),a 
1488 fe 31		.bps1b:  cp '1' 
148a 20 14			jr nz, .bps2 
148c			 
148c				; display reg 
148c			 
148c				 
148c			 
148c 3a 9c e2			ld a, (os_view_af) 
148f 2a 9a e2			ld hl, (os_view_hl) 
1492 ed 5b 98 e2		ld de, (os_view_de) 
1496 ed 4b 96 e2		ld bc, (os_view_bc) 
149a cd 34 15			call display_reg_state 
149d c3 20 15			jp .bpschk 
14a0			 
14a0 fe 32		.bps2:  cp '2' 
14a2 20 08			jr nz, .bps3 
14a4				 
14a4				; display hl 
14a4 2a 9a e2			ld hl, (os_view_hl) 
14a7 cd 1e 16			call display_dump_at_hl 
14aa			 
14aa 18 74			jr .bpschk 
14ac			 
14ac fe 33		.bps3:  cp '3' 
14ae 20 08			jr nz, .bps4 
14b0			 
14b0			        ; display de 
14b0 2a 98 e2			ld hl, (os_view_de) 
14b3 cd 1e 16			call display_dump_at_hl 
14b6			 
14b6 18 68			jr .bpschk 
14b8 fe 34		.bps4:  cp '4' 
14ba 20 08			jr nz, .bps5 
14bc			 
14bc			        ; display bc 
14bc 2a 96 e2			ld hl, (os_view_bc) 
14bf cd 1e 16			call display_dump_at_hl 
14c2			 
14c2 18 5c			jr .bpschk 
14c4 fe 35		.bps5:  cp '5' 
14c6 20 08		        jr nz, .bps7 
14c8			 
14c8				; display cur ptr 
14c8 2a 37 ea			ld hl, (cli_ptr) 
14cb cd 1e 16			call display_dump_at_hl 
14ce			 
14ce 18 50			jr .bpschk 
14d0 fe 36		.bps7:  cp '6' 
14d2 20 08			jr nz, .bps8b 
14d4				 
14d4				; display cur orig ptr 
14d4 2a 35 ea			ld hl, (cli_origptr) 
14d7 cd 1e 16			call display_dump_at_hl 
14da 18 44			jr .bpschk 
14dc fe 37		.bps8b:  cp '7' 
14de 20 08			jr nz, .bps9 
14e0				 
14e0				; display dsp 
14e0 2a e5 e9			ld hl, (cli_data_sp) 
14e3 cd 1e 16			call display_dump_at_hl 
14e6			 
14e6 18 38			jr .bpschk 
14e8 fe 39		.bps9:  cp '9' 
14ea 20 05			jr nz, .bps8c 
14ec				 
14ec				; display SP 
14ec			;	ld hl, sp 
14ec cd 1e 16			call display_dump_at_hl 
14ef			 
14ef 18 2f			jr .bpschk 
14f1 fe 38		.bps8c:  cp '8' 
14f3 20 08			jr nz, .bps8d 
14f5				 
14f5				; display rsp 
14f5 2a e9 e9			ld hl, (cli_ret_sp) 
14f8 cd 1e 16			call display_dump_at_hl 
14fb			 
14fb 18 23			jr .bpschk 
14fd fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14ff 20 05			jr nz, .bps8 
1501 cd 0c 18			call monitor 
1504			 
1504 18 1a			jr .bpschk 
1506 fe 30		.bps8:  cp '0' 
1508 20 16			jr nz, .bpschk 
150a			 
150a 21 07 ed				ld hl, display_fb1 
150d 22 c3 eb				ld (display_fb_active), hl 
1510 cd d9 0b				call update_display 
1513			 
1513				;ld a, (os_view_af) 
1513 2a 9a e2			ld hl, (os_view_hl) 
1516 ed 5b 98 e2		ld de, (os_view_de) 
151a ed 4b 96 e2		ld bc, (os_view_bc) 
151e f1				pop af 
151f c9				ret 
1520			 
1520			.bpschk:   
1520 cd f0 0a			call delay1s 
1523 3e 9f		ld a,display_row_4 + display_cols - 1 
1525 11 4c 1a		        ld de, endprg 
1528 cd c9 0b			call str_at_display 
152b cd d9 0b			call update_display 
152e cd ac 65			call cin_wait 
1531			 
1531 c3 83 14			jp .bps1 
1534			 
1534			 
1534			display_reg_state: 
1534			 
1534				; to restore afterwards 
1534			 
1534 d5				push de 
1535 c5				push bc 
1536 e5				push hl 
1537 f5				push af 
1538			 
1538				; for use in here 
1538			 
1538 c5				push bc 
1539 d5				push de 
153a e5				push hl 
153b f5				push af 
153c			 
153c cd b7 0b			call clear_display 
153f			 
153f 11 f4 15			ld de, .regstate 
1542 3e 00			ld a, display_row_1 
1544 cd c9 0b			call str_at_display 
1547			 
1547				; display debug step 
1547			 
1547			 
1547 11 62 ee			ld de, debug_mark 
154a 3e 25			ld a, display_row_1+display_cols-3 
154c cd c9 0b			call str_at_display 
154f			 
154f				; display a 
154f 11 10 16			ld de, .regstatea 
1552 3e 28			ld a, display_row_2 
1554 cd c9 0b			call str_at_display 
1557			 
1557 e1				pop hl 
1558			;	ld h,0 
1558			;	ld l, a 
1558 3e 2b			ld a, display_row_2+3 
155a cd db 13			call display_word_at 
155d			 
155d			 
155d				; display hl 
155d			 
155d			 
155d 11 04 16			ld de, .regstatehl 
1560 3e 32			ld a, display_row_2+10 
1562 cd c9 0b			call str_at_display 
1565			 
1565 e1				pop hl 
1566 3e 35			ld a, display_row_2+13 
1568 cd db 13			call display_word_at 
156b			 
156b				 
156b				; display de 
156b			 
156b 11 08 16			ld de, .regstatede 
156e 3e 50			ld a, display_row_3 
1570 cd c9 0b			call str_at_display 
1573			 
1573 e1				pop hl 
1574			;	ld h,d 
1574			;	ld l, e 
1574 3e 53			ld a, display_row_3+3 
1576 cd db 13			call display_word_at 
1579			 
1579			 
1579				; display bc 
1579			 
1579 11 0c 16			ld de, .regstatebc 
157c 3e 5a			ld a, display_row_3+10 
157e cd c9 0b			call str_at_display 
1581			 
1581 e1				pop hl 
1582			;	ld h,b 
1582			;	ld l, c 
1582 3e 5d			ld a, display_row_3+13 
1584 cd db 13			call display_word_at 
1587			 
1587			 
1587				; display dsp 
1587			 
1587 11 14 16			ld de, .regstatedsp 
158a 3e 78			ld a, display_row_4 
158c cd c9 0b			call str_at_display 
158f			 
158f				 
158f 2a e5 e9			ld hl,(cli_data_sp) 
1592 3e 7c			ld a, display_row_4+4 
1594 cd db 13			call display_word_at 
1597			 
1597				; display rsp 
1597			 
1597 11 19 16			ld de, .regstatersp 
159a 3e 82			ld a, display_row_4+10 
159c cd c9 0b			call str_at_display 
159f			 
159f				 
159f 2a e9 e9			ld hl,(cli_ret_sp) 
15a2 3e 86			ld a, display_row_4+14 
15a4 cd db 13			call display_word_at 
15a7			 
15a7 cd d9 0b			call update_display 
15aa			 
15aa			;	call delay1s 
15aa			;	call delay1s 
15aa			;	call delay1s 
15aa			 
15aa			 
15aa			;	call next_page_prompt 
15aa			 
15aa				; restore  
15aa			 
15aa f1				pop af 
15ab e1				pop hl 
15ac c1				pop bc 
15ad d1				pop de 
15ae c9				ret 
15af			 
15af .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15c3 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15d8 .. 00		.ptrstate:	db "Ptr State",0 
15e2 .. 00		.ptrcliptr:     db "cli_ptr",0 
15ea .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15f4 .. 00		.regstate:	db "Reg State (1/0)",0 
1604 .. 00		.regstatehl:	db "HL:",0 
1608 .. 00		.regstatede:	db "DE:",0 
160c .. 00		.regstatebc:	db "BC:",0 
1610 .. 00		.regstatea:	db "A :",0 
1614 .. 00		.regstatedsp:	db "DSP:",0 
1619 .. 00		.regstatersp:	db "RSP:",0 
161e			 
161e			display_dump_at_hl: 
161e e5				push hl 
161f d5				push de 
1620 c5				push bc 
1621 f5				push af 
1622			 
1622 22 db e5			ld (os_cur_ptr),hl	 
1625 cd b7 0b			call clear_display 
1628 cd 5a 19			call dumpcont 
162b			;	call delay1s 
162b			;	call next_page_prompt 
162b			 
162b			 
162b f1				pop af 
162c c1				pop bc 
162d d1				pop de 
162e e1				pop hl 
162f c9				ret 
1630			 
1630			;if ENABLE_BASIC 
1630			;	include "nascombasic.asm" 
1630			;	basic: 
1630			;	include "forth/FORTH.ASM" 
1630			;endif 
1630			 
1630			; eof 
1630			 
1630			 
# End of file firmware_diags.asm
1630			  
1630			include "firmware_prompts.asm"  
1630			; Prompts  
1630			 
1630			; boot messages 
1630			 
1630 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1645 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1655			 
1655			 
1655			; config menus 
1655			 
1655			;prom_c3: db "Add Dictionary To File",0 
1655			 
1655			if STARTUP_V1 
1655 .. 00		prom_c2: db "Select Autoload File",0 
166a .. 00		prom_c2a: db "Disable Autoload File", 0 
1680			endif 
1680			 
1680			if STARTUP_V2 
1680			prom_c2: db "Enable Autoload Files",0 
1680			prom_c2a: db "Disable Autoload Files", 0 
1680			 
1680			crs_s1: db "*ls-word", 0 
1680			crs_s2: db "*ed-word", 0 
1680			crs_s3: db "*Demo-Games", 0 
1680			crs_s4: db "*Utils", 0 
1680			crs_s5: db "*SPI-Util", 0 
1680			crs_s6: db "*Key-Constants", 0 
1680			crs_sound: db "*Sound-Util", 0 
1680			crs_hw: db "*Hello-World",0 
1680			 
1680			 
1680			 
1680			endif 
1680			;prom_c2b: db "Select Storage Bank",0 
1680 .. 00		prom_c4: db "Settings",0 
1689 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
16a4 .. 00		prom_m4b:   db "Monitor",0 
16ac			;prom_c1: db "Hardware Diags",0 
16ac			 
16ac			 
16ac			if STARTUP_V2 
16ac			prom_c9: db "Create Startup Files",0 
16ac			endif 
16ac			 
16ac .. 00		prom_notav:    db "Feature not available",0 
16c2 .. 00		prom_empty:    db "",0 
16c3			 
16c3			; eof 
16c3			 
# End of file firmware_prompts.asm
16c3			  
16c3			; eof  
16c3			  
# End of file firmware.asm
16c3			 
16c3			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
16c3			;if BASE_KEV  
16c3			;baseram: equ 08000h 
16c3			;endif 
16c3			 
16c3			;if BASE_SC114 
16c3			;baseram:     equ    endofcode 
16c3			;endif 
16c3			 
16c3			 
16c3			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
16c3			 
16c3			; start system 
16c3			 
16c3			coldstart: 
16c3				; set sp 
16c3				; di/ei 
16c3			 
16c3 f3				di 
16c4 31 00 f0			ld sp, tos 
16c7 cd aa 64			call init_nmi 
16ca			;	ei 
16ca			 
16ca				; init spinner 
16ca 3e 00			ld a,0 
16cc 32 bd eb			ld (display_active), a 
16cf			 
16cf				; disable breakpoint by default 
16cf			 
16cf				;ld a,'*' 
16cf			;	ld a,' ' 
16cf			;	ld (os_view_disable),a 
16cf			 
16cf				; set break point vector as new break point on or off 
16cf cd 61 14			call bp_off 
16d2			 
16d2			 
16d2				; default the parse vector to just a RET 
16d2 3e c9			ld a, $c9 
16d4 32 6c ee			ld (parse_vector), a 
16d7			 
16d7				; init hardware 
16d7			 
16d7				; init keyboard and screen hardware 
16d7			 
16d7 cd 1f 01			call hardware_init 
16da			 
16da			 
16da cd f0 0a			call delay1s 
16dd 3e 58			ld a, display_row_3+8 
16df 11 03 01			ld de, buildtime 
16e2 cd c9 0b			call str_at_display 
16e5 cd d9 0b			call update_display 
16e8			 
16e8 cd f0 0a			call delay1s 
16eb cd f0 0a			call delay1s 
16ee cd f0 0a			call delay1s 
16f1			 
16f1				; detect if any keys are held down to enable breakpoints at start up 
16f1			 
16f1 cd b4 65			call cin  
16f4 fe 00			cp 0 
16f6 28 03			jr z, .nokeys 
16f8			 
16f8				;call hardware_diags 
16f8 cd 46 13			call config 
16fb			 
16fb			;	ld de, .bpen 
16fb			;	ld a, display_row_4 
16fb			;	call str_at_display 
16fb			;	call update_display 
16fb			; 
16fb			;	ld a,0 
16fb			;	ld (os_view_disable),a 
16fb			; 
16fb			;.bpwait: 
16fb			;	call cin 
16fb			;	cp 0 
16fb			;	jr z, .bpwait 
16fb			;	jr .nokeys 
16fb			; 
16fb			; 
16fb			;.bpen:  db "Break points enabled!",0 
16fb			 
16fb			 
16fb			 
16fb			 
16fb			 
16fb			 
16fb			.nokeys: 
16fb			 
16fb			 
16fb				 
16fb			 
16fb			;jp  testkey 
16fb			 
16fb			;call storage_get_block_0 
16fb			; 
16fb			;ld hl, 0 
16fb			;ld de, store_page 
16fb			;call storage_read_block 
16fb			 
16fb				 
16fb			;ld hl, 10 
16fb			;ld de, store_page 
16fb			;call storage_read_block 
16fb			 
16fb			 
16fb			 
16fb			 
16fb			 
16fb			;stop:	nop 
16fb			;	jp stop 
16fb			 
16fb			 
16fb			 
16fb			main: 
16fb cd b7 0b			call clear_display 
16fe cd d9 0b			call update_display 
1701			 
1701			 
1701			 
1701			;	call testlcd 
1701			 
1701			 
1701			 
1701 cd 89 1e			call forth_init 
1704			 
1704			 
1704			warmstart: 
1704 cd 5f 1e			call forth_warmstart 
1707			 
1707				; run startup word load 
1707			        ; TODO prevent this running at warmstart after crash  
1707			 
1707				if STARTUP_ENABLE 
1707			 
1707					if STARTUP_V1 
1707			 
1707						if STORAGE_SE 
1707							call forth_autoload 
1707						endif 
1707 cd fa 63					call forth_startup 
170a					endif 
170a			 
170a					if STARTUP_V2 
170a			 
170a						if STORAGE_SE 
170a							call forth_autoload 
170a						else 
170a							call forth_startup 
170a						endif 
170a			 
170a			 
170a					endif 
170a			 
170a				endif 
170a			 
170a			warmstart_afterauto: 
170a			 
170a				; show free memory after boot 
170a 11 a7 17			ld de, freeram 
170d 3e 00			ld a, display_row_1 
170f cd c9 0b			call str_at_display 
1712			 
1712				; get current heap start after loading any uwords 
1712			 
1712				;ld de, (os_last_new_uword) 
1712				;ex de, hl 
1712			 
1712			; Or use heap_size word???? 
1712				;ld hl, heap_end 
1712				;ld hl, heap_size 
1712				;ld de, topusermem 
1712				;ld de, heap_start 
1712 ed 5b d7 65			ld de, (free_list )      
1716 21 93 e2				ld hl, heap_end 
1719 ed 52			sbc hl, de 
171b				;push hl 
171b				;ld a,h	         	 
171b				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
171b				;call hexout 
171b			   	;pop hl 
171b			; 
171b			;	ld a,l 
171b			;	ld hl, os_word_scratch+2 
171b			;	call hexout 
171b			;	ld hl, os_word_scratch+4 
171b			;	ld a, 0 
171b			;	ld (hl),a 
171b eb				ex de, hl 
171c 21 bd e5			ld hl, os_word_scratch 
171f cd e8 10			call uitoa_16 
1722			 
1722			 
1722 11 bd e5			ld de, os_word_scratch 
1725 3e 0d			ld a, display_row_1 + 13 
1727 cd c9 0b			call str_at_display 
172a cd d9 0b			call update_display 
172d			 
172d			 
172d				;call demo 
172d			 
172d			 
172d				; init scratch input area for cli commands 
172d			 
172d 21 df e5			ld hl, os_cli_cmd 
1730			;	ld a,0 
1730 36 00			ld (hl),0 
1732 23				inc hl 
1733 36 00			ld (hl),0 
1735			 
1735 3e 00			ld a,0 
1737 32 de e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
173a			 
173a 32 db e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
173d 32 dc e5			ld (os_cur_ptr+1),a	 
1740			 
1740 32 bd e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1743 32 be e5			ld (os_word_scratch+1),a	 
1746				 
1746			 
1746				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1746 21 df e5			ld hl, os_cli_cmd 
1749			 
1749			;	ld a, 0		 ; init cli input 
1749 36 00			ld (hl), 0 
174b 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
174d			cli: 
174d				; show cli prompt 
174d				;push af 
174d				;ld a, 0 
174d				;ld de, prompt 
174d				;call str_at_display 
174d			 
174d				;call update_display 
174d				;pop af 
174d				;inc a 
174d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
174d			 
174d			.lastrecall: 
174d			 
174d 0e 00			ld c, 0 
174f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1751 1e 28			ld e, 40 
1753			 
1753 21 df e5			ld hl, os_cli_cmd 
1756			 
1756				STACKFRAME OFF $fefe $9f9f 
1756				if DEBUG_STACK_IMB 
1756					if OFF 
1756						exx 
1756						ld de, $fefe 
1756						ld a, d 
1756						ld hl, curframe 
1756						call hexout 
1756						ld a, e 
1756						ld hl, curframe+2 
1756						call hexout 
1756						ld hl, $fefe 
1756						push hl 
1756						ld hl, $9f9f 
1756						push hl 
1756						exx 
1756					endif 
1756				endif 
1756			endm 
# End of macro STACKFRAME
1756			 
1756 cd 0e 0e			call input_str 
1759			 
1759				STACKFRAMECHK OFF $fefe $9f9f 
1759				if DEBUG_STACK_IMB 
1759					if OFF 
1759						exx 
1759						ld hl, $9f9f 
1759						pop de   ; $9f9f 
1759						call cmp16 
1759						jr nz, .spnosame 
1759						ld hl, $fefe 
1759						pop de   ; $fefe 
1759						call cmp16 
1759						jr z, .spfrsame 
1759						.spnosame: call showsperror 
1759						.spfrsame: nop 
1759						exx 
1759					endif 
1759				endif 
1759			endm 
# End of macro STACKFRAMECHK
1759			 
1759			 
1759				; check to see if last line recall has been requested 
1759			 
1759			if EDIT_V2 
1759 fe 05			cp KEY_UP 
175b 20 0f			jr nz, .noexecline 
175d			 
175d 11 df e5			ld de, os_cli_cmd 
1760 21 de e6			ld hl, os_last_cmd 
1763 01 ff 00			ld bc, 255 
1766 ed b0			ldir 
1768 3e 00			ld a, 0 
176a 18 e1			jr .lastrecall 
176c			endif 
176c			 
176c			.noexecline: 
176c				; no so exec the line		 
176c			 
176c				; copy input to last command 
176c			 
176c 21 df e5			ld hl, os_cli_cmd 
176f 11 de e6			ld de, os_last_cmd 
1772 01 ff 00			ld bc, 255 
1775 ed b0			ldir 
1777			 
1777				; wipe current buffer 
1777			 
1777			;	ld a, 0 
1777			;	ld hl, os_cli_cmd 
1777			;	ld de, os_cli_cmd+1 
1777			;	ld bc, 254 
1777			;	ldir 
1777				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1777			;	call strcpy 
1777			;	ld a, 0 
1777			;	ld (hl), a 
1777			;	inc hl 
1777			;	ld (hl), a 
1777			;	inc hl 
1777			;	ld (hl), a 
1777			 
1777				; switch frame buffer to program  
1777			 
1777 21 07 ed				ld hl, display_fb1 
177a 22 c3 eb				ld (display_fb_active), hl 
177d			 
177d			;	nop 
177d				STACKFRAME ON $fbfe $8f9f 
177d				if DEBUG_STACK_IMB 
177d					if ON 
177d						exx 
177d						ld de, $fbfe 
177d						ld a, d 
177d						ld hl, curframe 
177d						call hexout 
177d						ld a, e 
177d						ld hl, curframe+2 
177d						call hexout 
177d						ld hl, $fbfe 
177d						push hl 
177d						ld hl, $8f9f 
177d						push hl 
177d						exx 
177d					endif 
177d				endif 
177d			endm 
# End of macro STACKFRAME
177d				; first time into the parser so pass over the current scratch pad 
177d 21 df e5			ld hl,os_cli_cmd 
1780				; tokenise the entered statement(s) in HL 
1780 cd ff 1e			call forthparse 
1783			        ; exec forth statements in top of return stack 
1783 cd 37 1f			call forthexec 
1786				;call forthexec_cleanup 
1786			;	call parsenext 
1786			 
1786				STACKFRAMECHK ON $fbfe $8f9f 
1786				if DEBUG_STACK_IMB 
1786					if ON 
1786						exx 
1786						ld hl, $8f9f 
1786						pop de   ; $8f9f 
1786						call cmp16 
1786						jr nz, .spnosame 
1786						ld hl, $fbfe 
1786						pop de   ; $fbfe 
1786						call cmp16 
1786						jr z, .spfrsame 
1786						.spnosame: call showsperror 
1786						.spfrsame: nop 
1786						exx 
1786					endif 
1786				endif 
1786			endm 
# End of macro STACKFRAMECHK
1786				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1786			 
1786 3e 78			ld a, display_row_4 
1788 11 b8 17			ld de, endprog 
178b			 
178b cd d9 0b			call update_display		 
178e			 
178e cd 4e 1a			call next_page_prompt 
1791			 
1791				; switch frame buffer to cli 
1791			 
1791 21 a8 ed				ld hl, display_fb0 
1794 22 c3 eb				ld (display_fb_active), hl 
1797			 
1797			 
1797 cd b7 0b		        call clear_display 
179a cd d9 0b			call update_display		 
179d			 
179d 21 df e5			ld hl, os_cli_cmd 
17a0			 
17a0			;	ld a, 0		 ; init cli input 
17a0 36 00			ld (hl), 0 
17a2			 
17a2				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
17a2			 
17a2				; now on last line 
17a2			 
17a2				; TODO scroll screen up 
17a2			 
17a2				; TODO instead just clear screen and place at top of screen 
17a2			 
17a2			;	ld a, 0 
17a2			;	ld (f_cursor_ptr),a 
17a2			 
17a2				;call clear_display 
17a2				;call update_display 
17a2			 
17a2				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17a2 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17a4 c3 4d 17			jp cli 
17a7			 
17a7 .. 00		freeram: db "Free bytes: ",0 
17b4 ..			asc: db "1A2F" 
17b8 .. 00		endprog: db "End prog...",0 
17c4			 
17c4			testenter2:   
17c4 21 ea e2			ld hl,scratch+50 
17c7 22 db e5			ld (os_cur_ptr),hl 
17ca c3 4d 17			jp cli 
17cd			 
17cd			testenter:  
17cd			 
17cd 21 b4 17			ld hl,asc 
17d0			;	ld a,(hl) 
17d0			;	call nibble2val 
17d0 cd 33 10			call get_byte 
17d3			 
17d3			 
17d3			;	ld a,(hl) 
17d3			;	call atohex 
17d3			 
17d3			;	call fourehexhl 
17d3 32 ea e2			ld (scratch+50),a 
17d6			 
17d6			 
17d6			 
17d6 21 b6 17			ld hl,asc+2 
17d9			;	ld a, (hl) 
17d9			;	call nibble2val 
17d9 cd 33 10			call get_byte 
17dc			 
17dc			;	call fourehexhl 
17dc 32 ec e2			ld (scratch+52),a 
17df				 
17df 21 ea e2			ld hl,scratch+50 
17e2 22 db e5			ld (os_cur_ptr),hl 
17e5 c3 4d 17			jp cli 
17e8			 
17e8			enter:	 
17e8 3a bc e2			ld a,(scratch+4) 
17eb fe 00			cp 0 
17ed 28 0c			jr z, .entercont 
17ef				; no, not a null term line so has an address to work out.... 
17ef			 
17ef 21 ba e2			ld hl,scratch+2 
17f2 cd 93 10			call get_word_hl 
17f5			 
17f5 22 db e5			ld (os_cur_ptr),hl	 
17f8 c3 4d 17			jp cli 
17fb			 
17fb			 
17fb			.entercont:  
17fb			 
17fb 21 ba e2			ld hl, scratch+2 
17fe cd 33 10			call get_byte 
1801			 
1801 2a db e5		   	ld hl,(os_cur_ptr) 
1804 77					ld (hl),a 
1805 23					inc hl 
1806 22 db e5				ld (os_cur_ptr),hl 
1809				 
1809			; get byte  
1809			 
1809			 
1809 c3 4d 17			jp cli 
180c			 
180c			 
180c			; basic monitor support 
180c			 
180c			monitor: 
180c				;  
180c cd b7 0b			call clear_display 
180f 3e 00			ld a, 0 
1811 11 65 18			ld de, .monprompt 
1814 cd c9 0b			call str_at_display 
1817 cd d9 0b			call update_display 
181a			 
181a				; get a monitor command 
181a			 
181a 0e 00			ld c, 0     ; entry at top left 
181c 16 64			ld d, 100   ; max buffer size 
181e 1e 0f			ld e, 15    ; input scroll area 
1820			;	ld a, 0     ; init string 
1820 21 b6 e4			ld hl, os_input 
1823 36 00			ld (hl), 0 
1825 23				inc hl 
1826 36 00			ld (hl), 0 
1828 21 b6 e4			ld hl, os_input 
182b 3e 01			ld a, 1     ; init string 
182d cd 0e 0e			call input_str 
1830			 
1830 cd b7 0b		        call clear_display 
1833 cd d9 0b			call update_display		 
1836			 
1836 3a b6 e4			ld a, (os_input) 
1839 cd 30 11			call toUpper 
183c fe 48		        cp 'H' 
183e ca d9 18		        jp z, .monhelp 
1841 fe 44			cp 'D'		; dump 
1843 ca 0c 19			jp z, .mondump	 
1846 fe 43			cp 'C'		; dump 
1848 ca 26 19			jp z, .moncdump	 
184b fe 4d			cp 'M'		; dump 
184d ca 67 18			jp z, .moneditstart 
1850 fe 55			cp 'U'		; dump 
1852 ca 73 18			jp z, .monedit	 
1855 fe 47			cp 'G'		; dump 
1857 ca 02 19			jp z, .monjump 
185a fe 42			cp 'B'		; forth breakpoint 
185c cc 67 14			call z, break_point_state 
185f fe 51			cp 'Q'		; dump 
1861 c8				ret z	 
1862			 
1862			 
1862				; TODO "S" to access symbol by name and not need the address 
1862				; TODO "F" to find a string in memory 
1862			 
1862 c3 0c 18			jp monitor 
1865			 
1865 .. 00		.monprompt: db ">", 0 
1867			 
1867			.moneditstart: 
1867				; get starting address 
1867			 
1867 21 b8 e4			ld hl,os_input+2 
186a cd 93 10			call get_word_hl 
186d			 
186d 22 db e5			ld (os_cur_ptr),hl	 
1870			 
1870 c3 0c 18			jp monitor 
1873			 
1873			.monedit: 
1873				; get byte to load 
1873			 
1873 21 b8 e4			ld hl,os_input+2 
1876 cd 33 10			call get_byte 
1879			 
1879				; get address to update 
1879 2a db e5			ld hl, (os_cur_ptr) 
187c			 
187c				; update byte 
187c			 
187c 77				ld (hl), a 
187d			 
187d				; move to next address and save it 
187d			 
187d 23				inc hl 
187e 22 db e5			ld (os_cur_ptr),hl	 
1881			 
1881 c3 0c 18			jp monitor 
1884			 
1884			 
1884 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1898 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
18b4 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
18d2 .. 00		.monhelptext4:  db "Q-Quit",0 
18d9			        
18d9			.monhelp: 
18d9 3e 00			ld a, display_row_1 
18db 11 84 18		        ld de, .monhelptext1 
18de			 
18de cd c9 0b			call str_at_display 
18e1 3e 28			ld a, display_row_2 
18e3 11 98 18		        ld de, .monhelptext2 
18e6					 
18e6 cd c9 0b			call str_at_display 
18e9 3e 50			ld a, display_row_3 
18eb 11 b4 18		        ld de, .monhelptext3 
18ee					 
18ee cd c9 0b			call str_at_display 
18f1 3e 78			ld a, display_row_4 
18f3 11 d2 18		        ld de, .monhelptext4 
18f6 cd c9 0b			call str_at_display 
18f9			 
18f9 cd d9 0b			call update_display		 
18fc			 
18fc cd 4e 1a			call next_page_prompt 
18ff c3 0c 18			jp monitor 
1902			 
1902			.monjump:    
1902 21 b8 e4			ld hl,os_input+2 
1905 cd 93 10			call get_word_hl 
1908			 
1908 e9				jp (hl) 
1909 c3 0c 18			jp monitor 
190c			 
190c			.mondump:    
190c 21 b8 e4			ld hl,os_input+2 
190f cd 93 10			call get_word_hl 
1912			 
1912 22 db e5			ld (os_cur_ptr),hl	 
1915 cd 5a 19			call dumpcont 
1918 3e 78			ld a, display_row_4 
191a 11 b8 17			ld de, endprog 
191d			 
191d cd d9 0b			call update_display		 
1920			 
1920 cd 4e 1a			call next_page_prompt 
1923 c3 0c 18			jp monitor 
1926			.moncdump: 
1926 cd 5a 19			call dumpcont 
1929 3e 78			ld a, display_row_4 
192b 11 b8 17			ld de, endprog 
192e			 
192e cd d9 0b			call update_display		 
1931			 
1931 cd 4e 1a			call next_page_prompt 
1934 c3 0c 18			jp monitor 
1937			 
1937			 
1937			; TODO symbol access  
1937			 
1937			.symbols:     ;; A list of symbols that can be called up  
1937 a8 ed			dw display_fb0 
1939 .. 00			db "fb0",0  
193d 71 ea		     	dw store_page 
193f .. 00			db "store_page",0 
194a			 
194a			 
194a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
194a			 
194a 3a b9 e2			ld a,(scratch+1) 
194d fe 00			cp 0 
194f 28 09			jr z, dumpcont 
1951			 
1951				; no, not a null term line so has an address to work out.... 
1951			 
1951 21 ba e2			ld hl,scratch+2 
1954 cd 93 10			call get_word_hl 
1957			 
1957 22 db e5			ld (os_cur_ptr),hl	 
195a			 
195a			 
195a			 
195a			dumpcont: 
195a			 
195a				; dump bytes at ptr 
195a			 
195a			 
195a 3e 00			ld a, display_row_1 
195c 2a c3 eb			ld hl, (display_fb_active) 
195f cd e1 0d			call addatohl 
1962 cd 8a 19			call .dumpbyterow 
1965			 
1965 3e 28			ld a, display_row_2 
1967 2a c3 eb			ld hl, (display_fb_active) 
196a cd e1 0d			call addatohl 
196d cd 8a 19			call .dumpbyterow 
1970			 
1970			 
1970 3e 50			ld a, display_row_3 
1972 2a c3 eb			ld hl, (display_fb_active) 
1975 cd e1 0d			call addatohl 
1978 cd 8a 19			call .dumpbyterow 
197b			 
197b 3e 78			ld a, display_row_4 
197d 2a c3 eb			ld hl, (display_fb_active) 
1980 cd e1 0d			call addatohl 
1983 cd 8a 19			call .dumpbyterow 
1986			 
1986 cd d9 0b			call update_display 
1989			;		jp cli 
1989 c9				ret 
198a			 
198a			.dumpbyterow: 
198a			 
198a				;push af 
198a			 
198a e5				push hl 
198b			 
198b				; calc where to poke the ascii 
198b			if display_cols == 20 
198b				ld a, 16 
198b			else 
198b 3e 1f			ld a, 31 
198d			endif 
198d			 
198d cd e1 0d			call addatohl 
1990 22 bd e5			ld (os_word_scratch),hl  		; save pos for later 
1993			 
1993			 
1993			; display decoding address 
1993 2a db e5		   	ld hl,(os_cur_ptr) 
1996			 
1996 7c				ld a,h 
1997 e1				pop hl 
1998 e5				push hl 
1999			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1999 cd dd 0f			call hexout 
199c 2a db e5		   	ld hl,(os_cur_ptr) 
199f			 
199f 7d				ld a,l 
19a0 e1				pop hl 
19a1 23				inc hl 
19a2 23				inc hl 
19a3 e5				push hl 
19a4			;	ld hl, os_word_scratch+2 
19a4 cd dd 0f			call hexout 
19a7 e1				pop hl 
19a8 23				inc hl 
19a9 23				inc hl 
19aa				;ld hl, os_word_scratch+4 
19aa			;	ld a, ':' 
19aa 36 3a			ld (hl),':' 
19ac 23				inc hl 
19ad				;ld a, 0 
19ad				;ld (hl),a 
19ad				;ld de, os_word_scratch 
19ad				;pop af 
19ad				;push af 
19ad			;		ld a, display_row_2 
19ad			;		call str_at_display 
19ad			;		call update_display 
19ad			 
19ad			 
19ad			;pop af 
19ad			;	add 5 
19ad			 
19ad			if display_cols == 20 
19ad				ld b, 4 
19ad			else 
19ad 06 08			ld b, 8 
19af			endif	 
19af			 
19af			.dumpbyte: 
19af c5				push bc 
19b0 e5				push hl 
19b1			 
19b1			 
19b1 2a db e5		   	ld hl,(os_cur_ptr) 
19b4 7e					ld a,(hl) 
19b5			 
19b5					; poke the ascii to display 
19b5 2a bd e5				ld hl,(os_word_scratch) 
19b8 77					ld (hl),a 
19b9 23					inc hl 
19ba 22 bd e5				ld (os_word_scratch),hl 
19bd			 
19bd					 
19bd			 
19bd			 
19bd e1					pop hl 
19be e5					push hl 
19bf			 
19bf cd dd 0f				call hexout 
19c2			 
19c2					 
19c2 2a db e5		   	ld hl,(os_cur_ptr) 
19c5 23				inc hl 
19c6 22 db e5		   	ld (os_cur_ptr),hl 
19c9			 
19c9 e1					pop hl 
19ca 23					inc hl 
19cb 23					inc hl 
19cc 23					inc hl 
19cd			 
19cd			 
19cd			 
19cd					;ld a,0 
19cd					;ld (os_word_scratch+2),a 
19cd					;pop af 
19cd					;push af 
19cd			 
19cd					;ld de, os_word_scratch 
19cd					;call str_at_display 
19cd			;		call update_display 
19cd			;		pop af 
19cd c1					pop bc 
19ce c6 03				add 3 
19d0 10 dd			djnz .dumpbyte 
19d2			 
19d2				 
19d2			 
19d2 c9				ret 
19d3			 
19d3			jump:	 
19d3			 
19d3 21 ba e2			ld hl,scratch+2 
19d6 cd 93 10			call get_word_hl 
19d9				;ld hl,(scratch+2) 
19d9				;call fourehexhl 
19d9			 
19d9 22 db e5			ld (os_cur_ptr),hl	 
19dc			 
19dc e9				jp (hl) 
19dd			 
19dd			 
19dd			 
19dd			; TODO implement a basic monitor mode to start with 
19dd			 
19dd			 
19dd			 
19dd			 
19dd			 
19dd			 
19dd			 
19dd			 
19dd			 
19dd			; testing and demo code during development 
19dd			 
19dd			 
19dd .. 00		str1: db "Enter some text...",0 
19f0 .. 00		clear: db "                    ",0 
1a05			 
1a05			demo: 
1a05			 
1a05			 
1a05			 
1a05			;	call update_display 
1a05			 
1a05				; init scratch input area for testing 
1a05 21 b8 e2			ld hl, scratch	 
1a08			;	ld a,0 
1a08 36 00			ld (hl),0 
1a0a			 
1a0a			 
1a0a 3e 28		            LD   A, display_row_2 
1a0c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a0c 11 dd 19		            LD   DE, str1 
1a0f cd c9 0b			call str_at_display 
1a12			 
1a12			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a12			cloop:	 
1a12 3e 50		            LD   A, display_row_3 
1a14			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a14 11 f0 19		            LD   DE, clear 
1a17			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1a17 cd c9 0b				call str_at_display 
1a1a 3e 78			ld a, display_row_4 
1a1c 11 4a 1a			ld de, prompt 
1a1f			 
1a1f cd c9 0b				call str_at_display 
1a22 cd d9 0b			call update_display 
1a25			 
1a25 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a27 16 0a			ld d, 10 
1a29 21 b8 e2			ld hl, scratch	 
1a2c cd 0e 0e			call input_str 
1a2f			 
1a2f			;	call clear_display 
1a2f			;'	call update_display 
1a2f			 
1a2f 3e 00		            LD   A, display_row_1 
1a31			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a31 11 f0 19		            LD   DE, clear 
1a34 cd c9 0b				call str_at_display 
1a37			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a37 3e 00		            LD   A, display_row_1 
1a39			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a39 11 b8 e2		            LD   DE, scratch 
1a3c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a3c cd c9 0b				call str_at_display 
1a3f cd d9 0b			call update_display 
1a42			 
1a42			;		ld a,0 
1a42 21 b8 e2			ld hl, scratch 
1a45 36 00			ld (hl),0 
1a47			 
1a47			;	nop 
1a47 c3 12 1a			jp cloop 
1a4a			 
1a4a			 
1a4a			 
1a4a			; OS Prompt 
1a4a			 
1a4a .. 00		prompt: db ">",0 
1a4c .. 00		endprg: db "?",0 
1a4e			 
1a4e			 
1a4e			; handy next page prompt 
1a4e			next_page_prompt: 
1a4e e5				push hl 
1a4f d5				push de 
1a50 f5				push af 
1a51 c5				push bc 
1a52			 
1a52 3e 9f			ld a,display_row_4 + display_cols - 1 
1a54 11 4c 1a		        ld de, endprg 
1a57 cd c9 0b			call str_at_display 
1a5a cd d9 0b			call update_display 
1a5d cd ac 65			call cin_wait 
1a60 c1				pop bc 
1a61 f1				pop af 
1a62 d1				pop de 
1a63 e1				pop hl 
1a64			 
1a64			 
1a64 c9				ret 
1a65			 
1a65			 
1a65			; forth parser 
1a65			 
1a65			; My forth kernel 
1a65			include "forth_kernel.asm" 
1a65			; 
1a65			; kernel to the forth OS 
1a65			 
1a65			DS_TYPE_STR: equ 1     ; string type 
1a65			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1a65			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1a65			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
1a65			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1a65			 
1a65			FORTH_PARSEV1: equ 0 
1a65			FORTH_PARSEV2: equ 0 
1a65			FORTH_PARSEV3: equ 0 
1a65			FORTH_PARSEV4: equ 0 
1a65			FORTH_PARSEV5: equ 0 
1a65			FORTH_PARSEV6: equ 1 
1a65			 
1a65			;if FORTH_PARSEV5 
1a65			;	FORTH_END_BUFFER: equ 0 
1a65			;else 
1a65			FORTH_END_BUFFER: equ 127 
1a65			;endif 
1a65			 
1a65			FORTH_TRUE: equ 1 
1a65			FORTH_FALSE: equ 0 
1a65			 
1a65			if FORTH_PARSEV4 
1a65			include "forth_stackops.asm" 
1a65			endif 
1a65			 
1a65			if FORTH_PARSEV5 
1a65			include "forth_stackopsv5.asm" 
1a65			endif 
1a65			 
1a65			if FORTH_PARSEV6 
1a65			include "forth_stackopsv5.asm" 
1a65			 
1a65			; Stack operations for v5 parser on wards 
1a65			; * DATA stack 
1a65			; * LOOP stack 
1a65			; * RETURN stack 
1a65			 
1a65			 
1a65			 
1a65			FORTH_CHK_DSP_UNDER: macro 
1a65				push hl 
1a65				push de 
1a65				ld hl,(cli_data_sp) 
1a65				ld de, cli_data_stack 
1a65				call cmp16 
1a65				jp c, fault_dsp_under 
1a65				pop de 
1a65				pop hl 
1a65				endm 
1a65			 
1a65			 
1a65			FORTH_CHK_RSP_UNDER: macro 
1a65				push hl 
1a65				push de 
1a65				ld hl,(cli_ret_sp) 
1a65				ld de, cli_ret_stack 
1a65				call cmp16 
1a65				jp c, fault_rsp_under 
1a65				pop de 
1a65				pop hl 
1a65				endm 
1a65			 
1a65			FORTH_CHK_LOOP_UNDER: macro 
1a65				push hl 
1a65				push de 
1a65				ld hl,(cli_loop_sp) 
1a65				ld de, cli_loop_stack 
1a65				call cmp16 
1a65				jp c, fault_loop_under 
1a65				pop de 
1a65				pop hl 
1a65				endm 
1a65			 
1a65			FORTH_ERR_TOS_NOTSTR: macro 
1a65				; TOSO might need more for checks when used 
1a65				push af 
1a65				ld a,(hl) 
1a65				cp DS_TYPE_STR 
1a65				jp nz, type_faultn   
1a65				pop af 
1a65				endm 
1a65			 
1a65			FORTH_ERR_TOS_NOTNUM: macro 
1a65				push af 
1a65				ld a,(hl) 
1a65				cp DS_TYPE_INUM 
1a65				jp nz, type_faultn   
1a65				pop af 
1a65				endm 
1a65			 
1a65			 
1a65			; increase data stack pointer and save hl to it 
1a65				 
1a65			FORTH_DSP_NEXT: macro 
1a65				call macro_forth_dsp_next 
1a65				endm 
1a65			 
1a65			 
1a65			macro_forth_dsp_next: 
1a65				if DEBUG_FORTH_STACK_GUARD 
1a65 cd d2 61				call check_stacks 
1a68				endif 
1a68 e5				push hl 
1a69 d5				push de 
1a6a eb				ex de,hl 
1a6b 2a e5 e9			ld hl,(cli_data_sp) 
1a6e 23				inc hl 
1a6f 23				inc hl 
1a70			 
1a70			; PARSEV5 
1a70 23				inc hl 
1a71 22 e5 e9			ld (cli_data_sp),hl 
1a74 73				ld (hl), e 
1a75 23				inc hl 
1a76 72				ld (hl), d 
1a77 d1				pop de 
1a78 e1				pop hl 
1a79				if DEBUG_FORTH_STACK_GUARD 
1a79 cd d2 61				call check_stacks 
1a7c				endif 
1a7c c9				ret 
1a7d			 
1a7d			 
1a7d			; increase ret stack pointer and save hl to it 
1a7d				 
1a7d			FORTH_RSP_NEXT: macro 
1a7d				call macro_forth_rsp_next 
1a7d				endm 
1a7d			 
1a7d			macro_forth_rsp_next: 
1a7d				if DEBUG_FORTH_STACK_GUARD 
1a7d cd d2 61				call check_stacks 
1a80				endif 
1a80 e5				push hl 
1a81 d5				push de 
1a82 eb				ex de,hl 
1a83 2a e9 e9			ld hl,(cli_ret_sp) 
1a86 23				inc hl 
1a87 23				inc hl 
1a88 22 e9 e9			ld (cli_ret_sp),hl 
1a8b 73				ld (hl), e 
1a8c 23				inc hl 
1a8d 72				ld (hl), d 
1a8e d1				pop de 
1a8f e1				pop hl 
1a90				if DEBUG_FORTH_STACK_GUARD 
1a90 cd d2 61				call check_stacks 
1a93				endif 
1a93 c9				ret 
1a94			 
1a94			; get current ret stack pointer and save to hl  
1a94				 
1a94			FORTH_RSP_TOS: macro 
1a94				call macro_forth_rsp_tos 
1a94				endm 
1a94			 
1a94			macro_forth_rsp_tos: 
1a94				;push de 
1a94 2a e9 e9			ld hl,(cli_ret_sp) 
1a97 cd cf 1a			call loadhlptrtohl 
1a9a				;ld e, (hl) 
1a9a				;inc hl 
1a9a				;ld d, (hl) 
1a9a				;ex de, hl 
1a9a					if DEBUG_FORTH_WORDS 
1a9a			;			DMARK "RST" 
1a9a						CALLMONITOR 
1a9a cd 6f ee			call debug_vector  
1a9d				endm  
# End of macro CALLMONITOR
1a9d					endif 
1a9d				;pop de 
1a9d c9				ret 
1a9e			 
1a9e			; pop ret stack pointer 
1a9e				 
1a9e			FORTH_RSP_POP: macro 
1a9e				call macro_forth_rsp_pop 
1a9e				endm 
1a9e			 
1a9e			 
1a9e			macro_forth_rsp_pop: 
1a9e				if DEBUG_FORTH_STACK_GUARD 
1a9e			;		DMARK "RPP" 
1a9e cd d2 61				call check_stacks 
1aa1					FORTH_CHK_RSP_UNDER 
1aa1 e5				push hl 
1aa2 d5				push de 
1aa3 2a e9 e9			ld hl,(cli_ret_sp) 
1aa6 11 a3 e9			ld de, cli_ret_stack 
1aa9 cd ff 0d			call cmp16 
1aac da e9 62			jp c, fault_rsp_under 
1aaf d1				pop de 
1ab0 e1				pop hl 
1ab1				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ab1				endif 
1ab1 e5				push hl 
1ab2 2a e9 e9			ld hl,(cli_ret_sp) 
1ab5			 
1ab5			 
1ab5				if FORTH_ENABLE_FREE 
1ab5			 
1ab5					; get pointer 
1ab5			 
1ab5					push de 
1ab5					push hl 
1ab5			 
1ab5					ld e, (hl) 
1ab5					inc hl 
1ab5					ld d, (hl) 
1ab5			 
1ab5					ex de, hl 
1ab5					call free 
1ab5			 
1ab5					pop hl 
1ab5					pop de 
1ab5			 
1ab5			 
1ab5				endif 
1ab5			 
1ab5			 
1ab5 2b				dec hl 
1ab6 2b				dec hl 
1ab7 22 e9 e9			ld (cli_ret_sp), hl 
1aba				; do stack underflow checks 
1aba e1				pop hl 
1abb				if DEBUG_FORTH_STACK_GUARD 
1abb cd d2 61				call check_stacks 
1abe					FORTH_CHK_RSP_UNDER 
1abe e5				push hl 
1abf d5				push de 
1ac0 2a e9 e9			ld hl,(cli_ret_sp) 
1ac3 11 a3 e9			ld de, cli_ret_stack 
1ac6 cd ff 0d			call cmp16 
1ac9 da e9 62			jp c, fault_rsp_under 
1acc d1				pop de 
1acd e1				pop hl 
1ace				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ace				endif 
1ace c9				ret 
1acf			 
1acf			 
1acf			 
1acf			; routine to load word pointed to by hl into hl 
1acf			 
1acf			loadhlptrtohl: 
1acf			 
1acf d5				push de 
1ad0 5e				ld e, (hl) 
1ad1 23				inc hl 
1ad2 56				ld d, (hl) 
1ad3 eb				ex de, hl 
1ad4 d1				pop de 
1ad5			 
1ad5 c9				ret 
1ad6			 
1ad6			 
1ad6			 
1ad6			 
1ad6			 
1ad6			; push a number held in HL onto the data stack 
1ad6			; entry point for pushing a value when already in hl used in function above 
1ad6			 
1ad6			forth_push_numhl: 
1ad6			 
1ad6 e5				push hl    ; save value to push 
1ad7			 
1ad7			if DEBUG_FORTH_PUSH 
1ad7				; see if disabled 
1ad7			 
1ad7			 
1ad7 f5				push af 
1ad8 3a 6f ee			ld a,(debug_vector) 
1adb fe c9			cp $c9   ; ret 
1add			;	ld a, (os_view_disable) 
1add			;	cp '*' 
1add 28 33			jr z, .pskip2 
1adf e5				push hl 
1ae0 e5			push hl 
1ae1 cd b7 0b			call clear_display 
1ae4 e1			pop hl 
1ae5 7c				ld a,h 
1ae6 21 bd e5			ld hl, os_word_scratch 
1ae9 cd dd 0f			call hexout 
1aec e1				pop hl 
1aed 7d				ld a,l 
1aee 21 bf e5			ld hl, os_word_scratch+2 
1af1 cd dd 0f			call hexout 
1af4			 
1af4 21 c1 e5			ld hl, os_word_scratch+4 
1af7			;	ld a,0 
1af7 36 00			ld (hl),0 
1af9 11 bd e5			ld de,os_word_scratch 
1afc 3e 28				ld a, display_row_2 
1afe cd c9 0b				call str_at_display 
1b01 11 cf 53			ld de, .push_num 
1b04 3e 00			ld a, display_row_1 
1b06			 
1b06 cd c9 0b				call str_at_display 
1b09			 
1b09			 
1b09 cd d9 0b			call update_display 
1b0c cd f0 0a			call delay1s 
1b0f cd f0 0a			call delay1s 
1b12			.pskip2:  
1b12			 
1b12 f1				pop af 
1b13			endif	 
1b13			 
1b13			 
1b13				FORTH_DSP_NEXT 
1b13 cd 65 1a			call macro_forth_dsp_next 
1b16				endm 
# End of macro FORTH_DSP_NEXT
1b16			 
1b16 2a e5 e9			ld hl, (cli_data_sp) 
1b19			 
1b19				; save item type 
1b19			;	ld a,  DS_TYPE_INUM 
1b19 36 02			ld (hl), DS_TYPE_INUM 
1b1b 23				inc hl 
1b1c			 
1b1c				; get word off stack 
1b1c d1				pop de 
1b1d				;ld a,e 
1b1d 73				ld (hl), e 
1b1e 23				inc hl 
1b1f			;	ld a,d 
1b1f 72				ld (hl), d 
1b20			 
1b20			if DEBUG_FORTH_PUSH 
1b20 2b				dec hl 
1b21 2b				dec hl 
1b22 2b				dec hl 
1b23						DMARK "PH5" 
1b23 f5				push af  
1b24 3a 38 1b			ld a, (.dmark)  
1b27 32 62 ee			ld (debug_mark),a  
1b2a 3a 39 1b			ld a, (.dmark+1)  
1b2d 32 63 ee			ld (debug_mark+1),a  
1b30 3a 3a 1b			ld a, (.dmark+2)  
1b33 32 64 ee			ld (debug_mark+2),a  
1b36 18 03			jr .pastdmark  
1b38 ..			.dmark: db "PH5"  
1b3b f1			.pastdmark: pop af  
1b3c			endm  
# End of macro DMARK
1b3c				CALLMONITOR 
1b3c cd 6f ee			call debug_vector  
1b3f				endm  
# End of macro CALLMONITOR
1b3f			endif	 
1b3f			 
1b3f c9				ret 
1b40			 
1b40			 
1b40			; Push a string to stack pointed to by hl 
1b40			 
1b40			forth_push_str: 
1b40			 
1b40			if DEBUG_FORTH_PUSH 
1b40						DMARK "PSQ" 
1b40 f5				push af  
1b41 3a 55 1b			ld a, (.dmark)  
1b44 32 62 ee			ld (debug_mark),a  
1b47 3a 56 1b			ld a, (.dmark+1)  
1b4a 32 63 ee			ld (debug_mark+1),a  
1b4d 3a 57 1b			ld a, (.dmark+2)  
1b50 32 64 ee			ld (debug_mark+2),a  
1b53 18 03			jr .pastdmark  
1b55 ..			.dmark: db "PSQ"  
1b58 f1			.pastdmark: pop af  
1b59			endm  
# End of macro DMARK
1b59				CALLMONITOR 
1b59 cd 6f ee			call debug_vector  
1b5c				endm  
# End of macro CALLMONITOR
1b5c			endif	 
1b5c			 
1b5c			 
1b5c			    
1b5c e5				push hl 
1b5d e5				push hl 
1b5e			 
1b5e			;	ld a, 0   ; find end of string 
1b5e cd 39 11			call strlenz 
1b61			if DEBUG_FORTH_PUSH 
1b61						DMARK "PQ2" 
1b61 f5				push af  
1b62 3a 76 1b			ld a, (.dmark)  
1b65 32 62 ee			ld (debug_mark),a  
1b68 3a 77 1b			ld a, (.dmark+1)  
1b6b 32 63 ee			ld (debug_mark+1),a  
1b6e 3a 78 1b			ld a, (.dmark+2)  
1b71 32 64 ee			ld (debug_mark+2),a  
1b74 18 03			jr .pastdmark  
1b76 ..			.dmark: db "PQ2"  
1b79 f1			.pastdmark: pop af  
1b7a			endm  
# End of macro DMARK
1b7a				CALLMONITOR 
1b7a cd 6f ee			call debug_vector  
1b7d				endm  
# End of macro CALLMONITOR
1b7d			endif	 
1b7d eb				ex de, hl 
1b7e e1				pop hl   ; get ptr to start of string 
1b7f			if DEBUG_FORTH_PUSH 
1b7f						DMARK "PQ3" 
1b7f f5				push af  
1b80 3a 94 1b			ld a, (.dmark)  
1b83 32 62 ee			ld (debug_mark),a  
1b86 3a 95 1b			ld a, (.dmark+1)  
1b89 32 63 ee			ld (debug_mark+1),a  
1b8c 3a 96 1b			ld a, (.dmark+2)  
1b8f 32 64 ee			ld (debug_mark+2),a  
1b92 18 03			jr .pastdmark  
1b94 ..			.dmark: db "PQ3"  
1b97 f1			.pastdmark: pop af  
1b98			endm  
# End of macro DMARK
1b98				CALLMONITOR 
1b98 cd 6f ee			call debug_vector  
1b9b				endm  
# End of macro CALLMONITOR
1b9b			endif	 
1b9b 19				add hl,de 
1b9c			if DEBUG_FORTH_PUSH 
1b9c						DMARK "PQE" 
1b9c f5				push af  
1b9d 3a b1 1b			ld a, (.dmark)  
1ba0 32 62 ee			ld (debug_mark),a  
1ba3 3a b2 1b			ld a, (.dmark+1)  
1ba6 32 63 ee			ld (debug_mark+1),a  
1ba9 3a b3 1b			ld a, (.dmark+2)  
1bac 32 64 ee			ld (debug_mark+2),a  
1baf 18 03			jr .pastdmark  
1bb1 ..			.dmark: db "PQE"  
1bb4 f1			.pastdmark: pop af  
1bb5			endm  
# End of macro DMARK
1bb5				CALLMONITOR 
1bb5 cd 6f ee			call debug_vector  
1bb8				endm  
# End of macro CALLMONITOR
1bb8			endif	 
1bb8			 
1bb8 2b				dec hl    ; see if there is an optional trailing double quote 
1bb9 7e				ld a,(hl) 
1bba fe 22			cp '"' 
1bbc 20 02			jr nz, .strnoq 
1bbe			;	ld a, 0      ; get rid of double quote 
1bbe 36 00			ld (hl), 0 
1bc0 23			.strnoq: inc hl 
1bc1			 
1bc1			;	ld a, 0 
1bc1 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
1bc3			 
1bc3 13				inc de ; add one for the type string 
1bc4 13				inc de ; add one for null term??? 
1bc5			 
1bc5				; tos is get string pointer again 
1bc5				; de contains space to allocate 
1bc5				 
1bc5 d5				push de 
1bc6			 
1bc6 eb				ex de, hl 
1bc7			 
1bc7				;push af 
1bc7			 
1bc7			if DEBUG_FORTH_PUSH 
1bc7						DMARK "PHm" 
1bc7 f5				push af  
1bc8 3a dc 1b			ld a, (.dmark)  
1bcb 32 62 ee			ld (debug_mark),a  
1bce 3a dd 1b			ld a, (.dmark+1)  
1bd1 32 63 ee			ld (debug_mark+1),a  
1bd4 3a de 1b			ld a, (.dmark+2)  
1bd7 32 64 ee			ld (debug_mark+2),a  
1bda 18 03			jr .pastdmark  
1bdc ..			.dmark: db "PHm"  
1bdf f1			.pastdmark: pop af  
1be0			endm  
# End of macro DMARK
1be0				CALLMONITOR 
1be0 cd 6f ee			call debug_vector  
1be3				endm  
# End of macro CALLMONITOR
1be3			endif	 
1be3 cd ad 11			call malloc	; on ret hl now contains allocated memory 
1be6				if DEBUG_FORTH_MALLOC_GUARD 
1be6 cc 27 54				call z,malloc_error 
1be9				endif 
1be9			 
1be9				 
1be9 c1				pop bc    ; get length 
1bea d1				pop de   ;  get string start    
1beb			 
1beb				; hl has destination from malloc 
1beb			 
1beb eb				ex de, hl    ; prep for ldir 
1bec			 
1bec d5				push de   ; save malloc area for DSP later 
1bed				;push hl   ; save malloc area for DSP later 
1bed			 
1bed			if DEBUG_FORTH_PUSH 
1bed						DMARK "PHc" 
1bed f5				push af  
1bee 3a 02 1c			ld a, (.dmark)  
1bf1 32 62 ee			ld (debug_mark),a  
1bf4 3a 03 1c			ld a, (.dmark+1)  
1bf7 32 63 ee			ld (debug_mark+1),a  
1bfa 3a 04 1c			ld a, (.dmark+2)  
1bfd 32 64 ee			ld (debug_mark+2),a  
1c00 18 03			jr .pastdmark  
1c02 ..			.dmark: db "PHc"  
1c05 f1			.pastdmark: pop af  
1c06			endm  
# End of macro DMARK
1c06				CALLMONITOR 
1c06 cd 6f ee			call debug_vector  
1c09				endm  
# End of macro CALLMONITOR
1c09			endif	 
1c09			 
1c09			 
1c09 ed b0			ldir 
1c0b			 
1c0b			 
1c0b				; push malloc to data stack     macro?????  
1c0b			 
1c0b				FORTH_DSP_NEXT 
1c0b cd 65 1a			call macro_forth_dsp_next 
1c0e				endm 
# End of macro FORTH_DSP_NEXT
1c0e			 
1c0e				; save value and type 
1c0e			 
1c0e 2a e5 e9			ld hl, (cli_data_sp) 
1c11			 
1c11				; save item type 
1c11			;	ld a,  DS_TYPE_STR 
1c11 36 01			ld (hl), DS_TYPE_STR 
1c13 23				inc hl 
1c14			 
1c14				; get malloc word off stack 
1c14 d1				pop de 
1c15 73				ld (hl), e 
1c16 23				inc hl 
1c17 72				ld (hl), d 
1c18			 
1c18			 
1c18			 
1c18			if DEBUG_FORTH_PUSH 
1c18 2a e5 e9			ld hl, (cli_data_sp) 
1c1b						DMARK "PHS" 
1c1b f5				push af  
1c1c 3a 30 1c			ld a, (.dmark)  
1c1f 32 62 ee			ld (debug_mark),a  
1c22 3a 31 1c			ld a, (.dmark+1)  
1c25 32 63 ee			ld (debug_mark+1),a  
1c28 3a 32 1c			ld a, (.dmark+2)  
1c2b 32 64 ee			ld (debug_mark+2),a  
1c2e 18 03			jr .pastdmark  
1c30 ..			.dmark: db "PHS"  
1c33 f1			.pastdmark: pop af  
1c34			endm  
# End of macro DMARK
1c34				CALLMONITOR 
1c34 cd 6f ee			call debug_vector  
1c37				endm  
# End of macro CALLMONITOR
1c37			;	ex de,hl 
1c37			endif	 
1c37				; in case of spaces, skip the ptr past the copied string 
1c37				;pop af 
1c37				;ld (cli_origptr),hl 
1c37			 
1c37 c9				ret 
1c38			 
1c38			 
1c38			 
1c38			; TODO ascii push input onto stack given hl to start of input 
1c38			 
1c38			; identify type 
1c38			; if starts with a " then a string 
1c38			; otherwise it is a number 
1c38			;  
1c38			; if a string 
1c38			;     scan for ending " to get length of string to malloc for + 1 
1c38			;     malloc 
1c38			;     put pointer to string on stack first byte flags as string 
1c38			; 
1c38			; else a number 
1c38			;    look for number format identifier 
1c38			;    $xx hex 
1c38			;    %xxxxx bin 
1c38			;    xxxxx decimal 
1c38			;    convert number to 16bit word.  
1c38			;    malloc word + 1 with flag to identiy as num 
1c38			;    put pointer to number on stack 
1c38			;   
1c38			;  
1c38			  
1c38			forth_apush: 
1c38				; kernel push 
1c38			 
1c38			if DEBUG_FORTH_PUSH 
1c38						DMARK "PSH" 
1c38 f5				push af  
1c39 3a 4d 1c			ld a, (.dmark)  
1c3c 32 62 ee			ld (debug_mark),a  
1c3f 3a 4e 1c			ld a, (.dmark+1)  
1c42 32 63 ee			ld (debug_mark+1),a  
1c45 3a 4f 1c			ld a, (.dmark+2)  
1c48 32 64 ee			ld (debug_mark+2),a  
1c4b 18 03			jr .pastdmark  
1c4d ..			.dmark: db "PSH"  
1c50 f1			.pastdmark: pop af  
1c51			endm  
# End of macro DMARK
1c51				CALLMONITOR 
1c51 cd 6f ee			call debug_vector  
1c54				endm  
# End of macro CALLMONITOR
1c54			endif	 
1c54				; identify input type 
1c54			 
1c54 7e				ld a,(hl) 
1c55			 
1c55 fe 23			cp '#' 
1c57 ca 8f 1c			jp z, .fapdec 
1c5a			 
1c5a			 
1c5a fe 22			cp '"' 
1c5c 28 0a			jr z, .fapstr 
1c5e fe 24			cp '$' 
1c60 ca 87 1c			jp z, .faphex 
1c63 fe 25			cp '%' 
1c65 ca 70 1c			jp z, .fapbin 
1c68			;	cp 'b' 
1c68			;	jp z, .fabin 
1c68				; else decimal 
1c68			 
1c68				; TODO do decimal conversion 
1c68				; decimal is stored as a 16bit word 
1c68			 
1c68				; by default everything is a string if type is not detected 
1c68			.fapstr: ; 
1c68 fe 22			cp '"' 
1c6a 20 01			jr nz, .strnoqu 
1c6c 23				inc hl 
1c6d			.strnoqu: 
1c6d c3 40 1b			jp forth_push_str 
1c70			 
1c70			 
1c70			 
1c70			.fapbin:    ; push a binary string.  
1c70 11 00 00			ld de, 0   ; hold a 16bit value 
1c73			 
1c73 23			.fapbinshift:	inc hl  
1c74 7e				ld a,(hl) 
1c75			;	cp 0     ; done scanning  
1c75 b7				or a 
1c76 28 0b			jr z, .fapbdone  	; got it in HL so push  
1c78			 
1c78				; left shift de 
1c78 eb				ex de, hl	 
1c79 29				add hl, hl 
1c7a			 
1c7a				; is 1 
1c7a fe 31			cp '1' 
1c7c 20 02			jr nz, .binzero 
1c7e cb 4d			bit 1, l 
1c80			.binzero: 
1c80 eb				ex de, hl	 ; save current de 
1c81 18 f0			jr .fapbinshift 
1c83			 
1c83			.fapbdone: 
1c83 eb				ex de, hl 
1c84 c3 d6 1a			jp forth_push_numhl 
1c87			 
1c87			 
1c87			.faphex:   ; hex is always stored as a 16bit word 
1c87				; skip number prefix 
1c87 23				inc hl 
1c88				; turn ascii into number 
1c88 cd 93 10			call get_word_hl	; ret 16bit word in hl 
1c8b			 
1c8b c3 d6 1a			jp forth_push_numhl 
1c8e			 
1c8e			;	 nop 
1c8e			 
1c8e			.fabin:   ; TODO bin conversion 
1c8e			 
1c8e			 
1c8e c9				ret 
1c8f			.fapdec:	 
1c8f				; string to dec conversion 
1c8f 23				inc hl 
1c90 eb				ex de, hl 
1c91 cd d0 10			call string_to_uint16 
1c94 c3 d6 1a			jp forth_push_numhl 
1c97 c9				ret 
1c98				 
1c98			;atoui_16: 
1c98			 
1c98			; get either a string ptr or a 16bit word from the data stack 
1c98			 
1c98			FORTH_DSP: macro 
1c98				call macro_forth_dsp 
1c98				endm 
1c98			 
1c98			macro_forth_dsp: 
1c98				; data stack pointer points to current word on tos 
1c98			 
1c98 2a e5 e9			ld hl,(cli_data_sp) 
1c9b			 
1c9b				if DEBUG_FORTH_PUSH 
1c9b						DMARK "DSP" 
1c9b f5				push af  
1c9c 3a b0 1c			ld a, (.dmark)  
1c9f 32 62 ee			ld (debug_mark),a  
1ca2 3a b1 1c			ld a, (.dmark+1)  
1ca5 32 63 ee			ld (debug_mark+1),a  
1ca8 3a b2 1c			ld a, (.dmark+2)  
1cab 32 64 ee			ld (debug_mark+2),a  
1cae 18 03			jr .pastdmark  
1cb0 ..			.dmark: db "DSP"  
1cb3 f1			.pastdmark: pop af  
1cb4			endm  
# End of macro DMARK
1cb4			 
1cb4 cd 5a 54				call display_data_sp 
1cb7				;call break_point_state 
1cb7				;rst 030h 
1cb7				CALLMONITOR 
1cb7 cd 6f ee			call debug_vector  
1cba				endm  
# End of macro CALLMONITOR
1cba				endif 
1cba			 
1cba c9				ret 
1cbb			 
1cbb			; return hl to start of value on stack 
1cbb			 
1cbb			FORTH_DSP_VALUE: macro 
1cbb				call macro_forth_dsp_value 
1cbb				endm 
1cbb			 
1cbb			macro_forth_dsp_value: 
1cbb			 
1cbb				FORTH_DSP 
1cbb cd 98 1c			call macro_forth_dsp 
1cbe				endm 
# End of macro FORTH_DSP
1cbe			 
1cbe d5				push de 
1cbf			 
1cbf 23				inc hl ; skip type 
1cc0			 
1cc0 5e				ld e, (hl) 
1cc1 23				inc hl 
1cc2 56				ld d, (hl) 
1cc3 eb				ex de,hl  
1cc4			 
1cc4 d1				pop de 
1cc5			 
1cc5 c9				ret 
1cc6			 
1cc6			; return hl to start of value to second item on stack 
1cc6			 
1cc6			FORTH_DSP_VALUEM1: macro 
1cc6				call macro_forth_dsp_value_m1 
1cc6				endm 
1cc6			 
1cc6			macro_forth_dsp_value_m1: 
1cc6			 
1cc6				FORTH_DSP 
1cc6 cd 98 1c			call macro_forth_dsp 
1cc9				endm 
# End of macro FORTH_DSP
1cc9			 
1cc9 2b				dec hl 
1cca 2b				dec hl 
1ccb			;	dec hl 
1ccb			 
1ccb d5				push de 
1ccc			 
1ccc 5e				ld e, (hl) 
1ccd 23				inc hl 
1cce 56				ld d, (hl) 
1ccf eb				ex de,hl  
1cd0			 
1cd0 d1				pop de 
1cd1			 
1cd1 c9				ret 
1cd2			 
1cd2				 
1cd2			 
1cd2			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1cd2			 
1cd2			FORTH_DSP_POP: macro 
1cd2				call macro_forth_dsp_pop 
1cd2				endm 
1cd2			 
1cd2			 
1cd2			; get the tos data type 
1cd2			 
1cd2			FORTH_DSP_TYPE:   macro 
1cd2			 
1cd2				;FORTH_DSP_VALUE 
1cd2				FORTH_DSP 
1cd2				 
1cd2				; hl points to value 
1cd2				; check type 
1cd2			 
1cd2				ld a,(hl) 
1cd2			 
1cd2				endm 
1cd2			 
1cd2			; load the tos value into hl 
1cd2			 
1cd2			 
1cd2			FORTH_DSP_VALUEHL:  macro 
1cd2				call macro_dsp_valuehl 
1cd2				endm 
1cd2			 
1cd2			 
1cd2			 
1cd2			macro_dsp_valuehl: 
1cd2				FORTH_DSP_VALUE 
1cd2 cd bb 1c			call macro_forth_dsp_value 
1cd5				endm 
# End of macro FORTH_DSP_VALUE
1cd5			 
1cd5				;FORTH_ERR_TOS_NOTNUM 
1cd5			 
1cd5				;inc hl   ; skip type id 
1cd5			 
1cd5			;	push de 
1cd5			; 
1cd5			;	ld e, (hl) 
1cd5			;	inc hl 
1cd5			;	ld d, (hl) 
1cd5			;	ex de,hl  
1cd5			 
1cd5			;	pop de 
1cd5			 
1cd5				if DEBUG_FORTH_PUSH 
1cd5						DMARK "DVL" 
1cd5 f5				push af  
1cd6 3a ea 1c			ld a, (.dmark)  
1cd9 32 62 ee			ld (debug_mark),a  
1cdc 3a eb 1c			ld a, (.dmark+1)  
1cdf 32 63 ee			ld (debug_mark+1),a  
1ce2 3a ec 1c			ld a, (.dmark+2)  
1ce5 32 64 ee			ld (debug_mark+2),a  
1ce8 18 03			jr .pastdmark  
1cea ..			.dmark: db "DVL"  
1ced f1			.pastdmark: pop af  
1cee			endm  
# End of macro DMARK
1cee				CALLMONITOR 
1cee cd 6f ee			call debug_vector  
1cf1				endm  
# End of macro CALLMONITOR
1cf1				endif 
1cf1 c9				ret 
1cf2			 
1cf2			forth_apushstrhl:      
1cf2				; push of string requires use of cli_origptr 
1cf2				; bodge use 
1cf2			 
1cf2				; get current cli_origptr, save, update with temp pointer  
1cf2 ed 5b 35 ea		ld de, (cli_origptr) 
1cf6 22 35 ea			ld (cli_origptr), hl 
1cf9 d5				push de 
1cfa cd 38 1c			call forth_apush 
1cfd d1				pop de 
1cfe ed 53 35 ea		ld (cli_origptr), de 
1d02 c9			        ret	 
1d03			 
1d03			 
1d03			; increase loop stack pointer and save hl to it 
1d03				 
1d03			FORTH_LOOP_NEXT: macro 
1d03				call macro_forth_loop_next 
1d03				;nop 
1d03				endm 
1d03			 
1d03			macro_forth_loop_next: 
1d03				if DEBUG_FORTH_STACK_GUARD 
1d03 cd d2 61				call check_stacks 
1d06				endif 
1d06 e5				push hl 
1d07 d5				push de 
1d08 eb				ex de,hl 
1d09 2a e7 e9			ld hl,(cli_loop_sp) 
1d0c 23				inc hl 
1d0d 23				inc hl 
1d0e					if DEBUG_FORTH_WORDS 
1d0e						DMARK "LNX" 
1d0e f5				push af  
1d0f 3a 23 1d			ld a, (.dmark)  
1d12 32 62 ee			ld (debug_mark),a  
1d15 3a 24 1d			ld a, (.dmark+1)  
1d18 32 63 ee			ld (debug_mark+1),a  
1d1b 3a 25 1d			ld a, (.dmark+2)  
1d1e 32 64 ee			ld (debug_mark+2),a  
1d21 18 03			jr .pastdmark  
1d23 ..			.dmark: db "LNX"  
1d26 f1			.pastdmark: pop af  
1d27			endm  
# End of macro DMARK
1d27						CALLMONITOR 
1d27 cd 6f ee			call debug_vector  
1d2a				endm  
# End of macro CALLMONITOR
1d2a					endif 
1d2a 22 e7 e9			ld (cli_loop_sp),hl 
1d2d 73				ld (hl), e 
1d2e 23				inc hl 
1d2f 72				ld (hl), d 
1d30 d1				pop de    ; been reversed so save a swap on restore 
1d31 e1				pop hl 
1d32				if DEBUG_FORTH_STACK_GUARD 
1d32 cd d2 61				call check_stacks 
1d35				endif 
1d35 c9				ret 
1d36			 
1d36			; get current ret stack pointer and save to hl  
1d36				 
1d36			FORTH_LOOP_TOS: macro 
1d36				call macro_forth_loop_tos 
1d36				endm 
1d36			 
1d36			macro_forth_loop_tos: 
1d36 d5				push de 
1d37 2a e7 e9			ld hl,(cli_loop_sp) 
1d3a 5e				ld e, (hl) 
1d3b 23				inc hl 
1d3c 56				ld d, (hl) 
1d3d eb				ex de, hl 
1d3e d1				pop de 
1d3f c9				ret 
1d40			 
1d40			; pop loop stack pointer 
1d40				 
1d40			FORTH_LOOP_POP: macro 
1d40				call macro_forth_loop_pop 
1d40				endm 
1d40			 
1d40			 
1d40			macro_forth_loop_pop: 
1d40				if DEBUG_FORTH_STACK_GUARD 
1d40					DMARK "LPP" 
1d40 f5				push af  
1d41 3a 55 1d			ld a, (.dmark)  
1d44 32 62 ee			ld (debug_mark),a  
1d47 3a 56 1d			ld a, (.dmark+1)  
1d4a 32 63 ee			ld (debug_mark+1),a  
1d4d 3a 57 1d			ld a, (.dmark+2)  
1d50 32 64 ee			ld (debug_mark+2),a  
1d53 18 03			jr .pastdmark  
1d55 ..			.dmark: db "LPP"  
1d58 f1			.pastdmark: pop af  
1d59			endm  
# End of macro DMARK
1d59 cd d2 61				call check_stacks 
1d5c					FORTH_CHK_LOOP_UNDER 
1d5c e5				push hl 
1d5d d5				push de 
1d5e 2a e7 e9			ld hl,(cli_loop_sp) 
1d61 11 21 e9			ld de, cli_loop_stack 
1d64 cd ff 0d			call cmp16 
1d67 da ef 62			jp c, fault_loop_under 
1d6a d1				pop de 
1d6b e1				pop hl 
1d6c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d6c				endif 
1d6c e5				push hl 
1d6d 2a e7 e9			ld hl,(cli_loop_sp) 
1d70 2b				dec hl 
1d71 2b				dec hl 
1d72 22 e7 e9			ld (cli_loop_sp), hl 
1d75				; TODO do stack underflow checks 
1d75 e1				pop hl 
1d76				if DEBUG_FORTH_STACK_GUARD 
1d76 cd d2 61				call check_stacks 
1d79					FORTH_CHK_LOOP_UNDER 
1d79 e5				push hl 
1d7a d5				push de 
1d7b 2a e7 e9			ld hl,(cli_loop_sp) 
1d7e 11 21 e9			ld de, cli_loop_stack 
1d81 cd ff 0d			call cmp16 
1d84 da ef 62			jp c, fault_loop_under 
1d87 d1				pop de 
1d88 e1				pop hl 
1d89				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d89				endif 
1d89 c9				ret 
1d8a			 
1d8a			macro_forth_dsp_pop: 
1d8a			 
1d8a e5				push hl 
1d8b			 
1d8b				; release malloc data 
1d8b			 
1d8b				if DEBUG_FORTH_STACK_GUARD 
1d8b cd d2 61				call check_stacks 
1d8e					FORTH_CHK_DSP_UNDER 
1d8e e5				push hl 
1d8f d5				push de 
1d90 2a e5 e9			ld hl,(cli_data_sp) 
1d93 11 1f e8			ld de, cli_data_stack 
1d96 cd ff 0d			call cmp16 
1d99 da e3 62			jp c, fault_dsp_under 
1d9c d1				pop de 
1d9d e1				pop hl 
1d9e				endm 
# End of macro FORTH_CHK_DSP_UNDER
1d9e				endif 
1d9e				;ld hl,(cli_data_sp) 
1d9e			if DEBUG_FORTH_DOT 
1d9e				DMARK "DPP" 
1d9e f5				push af  
1d9f 3a b3 1d			ld a, (.dmark)  
1da2 32 62 ee			ld (debug_mark),a  
1da5 3a b4 1d			ld a, (.dmark+1)  
1da8 32 63 ee			ld (debug_mark+1),a  
1dab 3a b5 1d			ld a, (.dmark+2)  
1dae 32 64 ee			ld (debug_mark+2),a  
1db1 18 03			jr .pastdmark  
1db3 ..			.dmark: db "DPP"  
1db6 f1			.pastdmark: pop af  
1db7			endm  
# End of macro DMARK
1db7				CALLMONITOR 
1db7 cd 6f ee			call debug_vector  
1dba				endm  
# End of macro CALLMONITOR
1dba			endif	 
1dba			 
1dba			 
1dba			if FORTH_ENABLE_DSPPOPFREE 
1dba			 
1dba				FORTH_DSP 
1dba cd 98 1c			call macro_forth_dsp 
1dbd				endm 
# End of macro FORTH_DSP
1dbd			 
1dbd 7e				ld a, (hl) 
1dbe fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
1dc0 20 22			jr nz, .skippopfree 
1dc2			 
1dc2				FORTH_DSP_VALUEHL 
1dc2 cd d2 1c			call macro_dsp_valuehl 
1dc5				endm 
# End of macro FORTH_DSP_VALUEHL
1dc5			;	nop 
1dc5			if DEBUG_FORTH_DOT 
1dc5				DMARK "DPf" 
1dc5 f5				push af  
1dc6 3a da 1d			ld a, (.dmark)  
1dc9 32 62 ee			ld (debug_mark),a  
1dcc 3a db 1d			ld a, (.dmark+1)  
1dcf 32 63 ee			ld (debug_mark+1),a  
1dd2 3a dc 1d			ld a, (.dmark+2)  
1dd5 32 64 ee			ld (debug_mark+2),a  
1dd8 18 03			jr .pastdmark  
1dda ..			.dmark: db "DPf"  
1ddd f1			.pastdmark: pop af  
1dde			endm  
# End of macro DMARK
1dde				CALLMONITOR 
1dde cd 6f ee			call debug_vector  
1de1				endm  
# End of macro CALLMONITOR
1de1			endif	 
1de1 cd 77 12			call free 
1de4			.skippopfree: 
1de4				 
1de4			 
1de4			endif 
1de4			 
1de4			if DEBUG_FORTH_DOT_KEY 
1de4				DMARK "DP2" 
1de4				CALLMONITOR 
1de4			endif	 
1de4			 
1de4				; move pointer down 
1de4			 
1de4 2a e5 e9			ld hl,(cli_data_sp) 
1de7 2b				dec hl 
1de8 2b				dec hl 
1de9			; PARSEV5 
1de9 2b				dec hl 
1dea 22 e5 e9			ld (cli_data_sp), hl 
1ded			 
1ded				if DEBUG_FORTH_STACK_GUARD 
1ded cd d2 61				call check_stacks 
1df0					FORTH_CHK_DSP_UNDER 
1df0 e5				push hl 
1df1 d5				push de 
1df2 2a e5 e9			ld hl,(cli_data_sp) 
1df5 11 1f e8			ld de, cli_data_stack 
1df8 cd ff 0d			call cmp16 
1dfb da e3 62			jp c, fault_dsp_under 
1dfe d1				pop de 
1dff e1				pop hl 
1e00				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e00				endif 
1e00			 
1e00 e1				pop hl 
1e01			 
1e01 c9				ret 
1e02			 
1e02			getwordathl: 
1e02				; hl points to an address 
1e02				; load hl with the word at that address 
1e02			 
1e02 d5				push de 
1e03			 
1e03 5e				ld e, (hl) 
1e04 23				inc hl 
1e05 56				ld d, (hl) 
1e06 eb				ex de, hl 
1e07			 
1e07 d1				pop de 
1e08 c9				ret 
1e09			 
1e09			 
1e09			; functions to manuplite stack pointers 
1e09			 
1e09			; generate fragment to set hl to be pointer to a stack item 
1e09			 
1e09			FORTH_DSP_PTR: macro  x 
1e09				ld hl,(cli_data_sp) 
1e09				ld de, x * 3 
1e09				sbc hl, de 
1e09				endm 
1e09			 
1e09			 
1e09			 
1e09			; copy point in hl to stack tmp storage slots 1-4 
1e09			hltostack1: 
1e09 11 b5 e2			ld de, os_stack_1  
1e0c c3 37 1e			jp hltostackmv 
1e0f			 
1e0f			hltostack2:  
1e0f 11 b2 e2			ld de, os_stack_2 
1e12 c3 37 1e			jp hltostackmv 
1e15			 
1e15			hltostack3:  
1e15 11 af e2			ld de, os_stack_3 
1e18 c3 37 1e			jp hltostackmv 
1e1b			 
1e1b			hltostack4:  
1e1b 11 ac e2			ld de, os_stack_4  
1e1e c3 37 1e			jp hltostackmv 
1e21			 
1e21			; copy to point in hl from stack tmp storage slots 1-4 
1e21			hlfromstack1: 
1e21 11 b5 e2			ld de, os_stack_1 
1e24 c3 36 1e			jp hlfromsttackmv 
1e27			 
1e27			hlfromstack2:  
1e27 11 b2 e2			ld de, os_stack_2 
1e2a c3 36 1e			jp hlfromsttackmv 
1e2d			 
1e2d			hlfromstack3:  
1e2d 11 af e2			ld de, os_stack_3 
1e30 c3 36 1e			jp hlfromsttackmv 
1e33			 
1e33			hlfromstack4:  
1e33 11 ac e2			ld de, os_stack_4 
1e36			 
1e36			hlfromsttackmv: 
1e36 eb				ex de, hl 
1e37			 
1e37			hltostackmv: 
1e37			 
1e37				; do stack move 
1e37 c5				push bc 
1e38 01 03 00			ld bc, 3 
1e3b ed b0			ldir  
1e3d c1				pop bc	 
1e3e c9				ret 
1e3f			 
1e3f			; eof 
1e3f			 
# End of file forth_stackopsv5.asm
1e3f			endif 
1e3f			loadwordinhl:	 
1e3f			 
1e3f d5				push de 
1e40			 
1e40 5e				ld e, (hl) 
1e41 23				inc hl 
1e42 56				ld d, (hl) 
1e43 eb				ex de,hl  
1e44			 
1e44 d1				pop de 
1e45			 
1e45 c9				ret 
1e46			 
1e46			user_word_eol:  
1e46				; hl contains the pointer to where to create a linked list item from the end 
1e46				; of the user dict to continue on at the system word dict 
1e46				 
1e46				; poke the stub of the word list linked list to repoint to rom words 
1e46			 
1e46				; stub format 
1e46				; db   word id 
1e46				; dw    link to next word 
1e46			        ; db char length of token 
1e46				; db string + 0 term 
1e46				; db exec code....  
1e46			 
1e46			;	ld a, WORD_SYS_ROOT     ; root word 
1e46 36 00			ld (hl), WORD_SYS_ROOT		; word id 
1e48 23				inc hl 
1e49			 
1e49 11 f2 1f			ld de, sysdict 
1e4c 73				ld (hl), e		; next word link ie system dict 
1e4d 23				inc hl 
1e4e 72				ld (hl), d		; next word link ie system dict 
1e4f 23				inc hl	 
1e50			 
1e50			;	ld (hl), sysdict		; next word link ie system dict 
1e50			;	inc hl 
1e50			;	inc hl 
1e50			 
1e50			;	inc hl 
1e50			;	inc hl 
1e50			 
1e50			;	ld a, 2			; word length is 0 
1e50 36 02			ld (hl), 2 
1e52 23				inc hl 
1e53			 
1e53			;	ld a, '~'			; word length is 0 
1e53 36 7e			ld (hl), '~' 
1e55 23				inc hl 
1e56			;	ld a, 0			; save empty word 
1e56 36 00			ld (hl), 0 
1e58			 
1e58 c9				ret 
1e59			 
1e59				 
1e59			 
1e59			forthexec_cleanup: 
1e59				FORTH_RSP_POP 
1e59 cd 9e 1a			call macro_forth_rsp_pop 
1e5c				endm 
# End of macro FORTH_RSP_POP
1e5c c9				ret 
1e5d			 
1e5d			forth_call_hl: 
1e5d				; taking hl 
1e5d e5				push hl 
1e5e c9				ret 
1e5f			 
1e5f			; this is called to reset Forth system but keep existing uwords etc 
1e5f			 
1e5f			forth_warmstart: 
1e5f				; setup stack over/under flow checks 
1e5f				if DEBUG_FORTH_STACK_GUARD 
1e5f cd b8 61				call chk_stk_init 
1e62				endif 
1e62			 
1e62				; init stack pointers  - * these stacks go upwards *  
1e62 21 a3 e9			ld hl, cli_ret_stack 
1e65 22 e9 e9			ld (cli_ret_sp), hl	 
1e68				; set bottom of stack 
1e68			;	ld a,0 
1e68 36 00			ld (hl),0 
1e6a 23				inc hl 
1e6b 36 00			ld (hl),0 
1e6d			 
1e6d 21 1f e8			ld hl, cli_data_stack 
1e70 22 e5 e9			ld (cli_data_sp), hl	 
1e73				; set bottom of stack 
1e73			;	ld a,0 
1e73 36 00			ld (hl),0 
1e75 23				inc hl 
1e76 36 00			ld (hl),0 
1e78			 
1e78 21 21 e9			ld hl, cli_loop_stack 
1e7b 22 e7 e9			ld (cli_loop_sp), hl	 
1e7e				; set bottom of stack 
1e7e			;	ld a,0 
1e7e 36 00			ld (hl),0 
1e80 23				inc hl 
1e81 36 00			ld (hl),0 
1e83			 
1e83				; init extent of current open file 
1e83			 
1e83 3e 00			ld a, 0 
1e85 32 61 ea			ld (store_openext), a 
1e88			 
1e88 c9				ret 
1e89			 
1e89			 
1e89			 
1e89			; Cold Start - this is called to setup the whole Forth system 
1e89			 
1e89			forth_init: 
1e89			 
1e89				; setup stack over/under flow checks 
1e89			 
1e89			;	if DEBUG_FORTH_STACK_GUARD 
1e89			;		call chk_stk_init 
1e89			;	endif 
1e89			 
1e89				; enable auto display updates (slow.....) 
1e89			 
1e89 3e 01			ld a, 1 
1e8b 32 33 ea			ld (cli_autodisplay), a 
1e8e			 
1e8e				; if storage is in use disable long reads for now 
1e8e 3e 00			ld a, 0 
1e90 32 6c ea			ld (store_longread), a 
1e93			 
1e93			 
1e93				; show start up screen 
1e93			 
1e93 cd b7 0b			call clear_display 
1e96			 
1e96 3e 00			ld a,0 
1e98 32 55 ea			ld (f_cursor_ptr), a 
1e9b			 
1e9b				; set start of word list in start of ram - for use when creating user words 
1e9b			 
1e9b 21 cd 65			ld hl, baseram 
1e9e 22 b5 e5			ld (os_last_new_uword), hl 
1ea1 cd 46 1e			call user_word_eol 
1ea4				 
1ea4			;		call display_data_sp 
1ea4			;		call next_page_prompt 
1ea4			 
1ea4			 
1ea4			 
1ea4			 
1ea4 c9				ret 
1ea5			 
1ea5 .. 00		.bootforth: db " Forth Kernel Init ",0 
1eb9			 
1eb9			; TODO push to stack 
1eb9			 
1eb9			;  
1eb9			 
1eb9			if FORTH_PARSEV2 
1eb9			 
1eb9			 
1eb9				include "forth_parserv2.asm" 
1eb9			 
1eb9			endif 
1eb9			 
1eb9			 
1eb9			; parse cli version 1 
1eb9			 
1eb9			if FORTH_PARSEV1 
1eb9			 
1eb9			 
1eb9			 
1eb9			      include "forth_parserv1.asm" 
1eb9			endif 
1eb9				 
1eb9			if FORTH_PARSEV3 
1eb9			      include "forth_parserv3.asm" 
1eb9				include "forth_wordsv3.asm" 
1eb9			endif 
1eb9			 
1eb9			if FORTH_PARSEV4 
1eb9			      include "forth_parserv4.asm" 
1eb9				include "forth_wordsv4.asm" 
1eb9			endif 
1eb9			 
1eb9			if FORTH_PARSEV5 
1eb9			      include "forth_parserv5.asm" 
1eb9				include "forth_wordsv4.asm" 
1eb9			endif 
1eb9			 
1eb9			if FORTH_PARSEV6 
1eb9			      include "forth_parserv6.asm" 
1eb9			 
1eb9			 
1eb9			; A better parser without using malloc and string copies all over the place.  
1eb9			; Exec in situ should be faster 
1eb9			 
1eb9			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1eb9			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1eb9			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1eb9			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1eb9			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1eb9			WORD_SYS_END: equ 0   ; Opcode for all user words 
1eb9			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1eb9			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1eb9			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1eb9			 
1eb9			; Core word preamble macro 
1eb9			 
1eb9			CWHEAD:   macro nxtword opcode lit len opflags 
1eb9				db WORD_SYS_CORE+opcode             
1eb9				; internal op code number 
1eb9				dw nxtword            
1eb9				; link to next dict word block 
1eb9				db len + 1 
1eb9				; literal length of dict word inc zero term 
1eb9				db lit,0              
1eb9				; literal dict word 
1eb9			        ; TODO db opflags        
1eb9				endm 
1eb9			 
1eb9			 
1eb9			NEXTW: macro  
1eb9				call parse_vector 
1eb9				jp macro_next 
1eb9				endm 
1eb9			 
1eb9			macro_next: 
1eb9			if DEBUG_FORTH_PARSE_EXEC 
1eb9				DMARK "NXT" 
1eb9				CALLMONITOR 
1eb9			endif	 
1eb9			;	inc hl  ; skip token null term  
1eb9 ed 4b 37 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ebd ed 5b 35 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ec1 2a b9 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ec4			if DEBUG_FORTH_PARSE_EXEC 
1ec4				DMARK "}AA" 
1ec4				CALLMONITOR 
1ec4			endif	 
1ec4 c3 a9 1f			jp execnext 
1ec7				;jp exec1 
1ec7			       
1ec7			 
1ec7			 
1ec7			; Another go at the parser to compile  
1ec7			 
1ec7			 
1ec7			; TODO rework parser to change all of the string words to byte tokens 
1ec7			; TODO do a search for  
1ec7			 
1ec7			; TODO first run normal parser to zero term sections 
1ec7			; TODO for each word do a token look up to get the op code 
1ec7			; TODO need some means to flag to the exec that this is a byte code form    
1ec7			 
1ec7			 
1ec7			forthcompile: 
1ec7			 
1ec7			; 
1ec7			; line parse: 
1ec7			;       parse raw input buffer 
1ec7			;       tokenise the words 
1ec7			;       malloc new copy (for looping etc) 
1ec7			;       copy to malloc + current pc in line to start of string and add line term 
1ec7			;       save on new rsp 
1ec7			; 
1ec7			 
1ec7			; hl to point to the line to tokenise 
1ec7			 
1ec7			;	push hl 
1ec7 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1eca			 
1eca			;	ld a,0		; string term on input 
1eca			;	call strlent 
1eca			 
1eca			;	ld (os_tok_len), hl	 ; save string length 
1eca			 
1eca			;if DEBUG_FORTH_TOK 
1eca			;	ex de,hl		 
1eca			;endif 
1eca			 
1eca			;	pop hl 		; get back string pointer 
1eca			 
1eca			if DEBUG_FORTH_TOK 
1eca						DMARK "TOc" 
1eca				CALLMONITOR 
1eca			endif 
1eca 7e			.cptoken2:    ld a,(hl) 
1ecb 23				inc hl 
1ecc fe 7f			cp FORTH_END_BUFFER 
1ece 28 26			jr z, .cptokendone2 
1ed0			;	cp 0 
1ed0 b7				or a 
1ed1 28 23			jr z, .cptokendone2 
1ed3 fe 22			cp '"' 
1ed5 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1ed7 fe 20			cp ' ' 
1ed9 20 ef			jr nz,  .cptoken2 
1edb			 
1edb			; TODO consume comments held between ( and ) 
1edb			 
1edb				; we have a space so change to zero term for dict match later 
1edb 2b				dec hl 
1edc			;	ld a,0 
1edc 36 00			ld (hl), 0 
1ede 23				inc hl 
1edf 18 e9			jr .cptoken2 
1ee1				 
1ee1			 
1ee1			.cptokenstr2: 
1ee1				; skip all white space until either eol (because forgot to term) or end double quote 
1ee1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ee1				;inc hl ; skip current double quote 
1ee1 7e				ld a,(hl) 
1ee2 23				inc hl 
1ee3 fe 22			cp '"' 
1ee5 28 e3			jr z, .cptoken2 
1ee7 fe 7f			cp FORTH_END_BUFFER 
1ee9 28 0b			jr z, .cptokendone2 
1eeb			;	cp 0 
1eeb b7				or a 
1eec 28 08			jr z, .cptokendone2 
1eee fe 20			cp ' ' 
1ef0 28 02			jr z, .cptmp2 
1ef2 18 ed			jr .cptokenstr2 
1ef4			 
1ef4			.cptmp2:	; we have a space so change to zero term for dict match later 
1ef4				;dec hl 
1ef4				;ld a,"-"	; TODO remove this when working 
1ef4				;ld (hl), a 
1ef4				;inc hl 
1ef4 18 eb			jr .cptokenstr2 
1ef6			 
1ef6			.cptokendone2: 
1ef6				;inc hl 
1ef6			;	ld a, FORTH_END_BUFFER 
1ef6 36 7f			ld (hl),FORTH_END_BUFFER 
1ef8			;	inc hl 
1ef8			;	ld a, '!' 
1ef8			;	ld (hl),a 
1ef8			 
1ef8 2a b9 e5			ld hl,(os_tok_ptr) 
1efb			         
1efb			if DEBUG_FORTH_TOK 
1efb						DMARK "Tc1" 
1efb				CALLMONITOR 
1efb			endif 
1efb			 
1efb				; push exec string to top of return stack 
1efb				FORTH_RSP_NEXT 
1efb cd 7d 1a			call macro_forth_rsp_next 
1efe				endm 
# End of macro FORTH_RSP_NEXT
1efe c9				ret 
1eff			 
1eff			; Another go at the parser need to simplify the process 
1eff			 
1eff			forthparse: 
1eff			 
1eff			; 
1eff			; line parse: 
1eff			;       parse raw input buffer 
1eff			;       tokenise the words 
1eff			;       malloc new copy (for looping etc) 
1eff			;       copy to malloc + current pc in line to start of string and add line term 
1eff			;       save on new rsp 
1eff			; 
1eff			 
1eff			; hl to point to the line to tokenise 
1eff			 
1eff			;	push hl 
1eff 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f02			 
1f02			;	ld a,0		; string term on input 
1f02			;	call strlent 
1f02			 
1f02			;	ld (os_tok_len), hl	 ; save string length 
1f02			 
1f02			;if DEBUG_FORTH_TOK 
1f02			;	ex de,hl		 
1f02			;endif 
1f02			 
1f02			;	pop hl 		; get back string pointer 
1f02			 
1f02			if DEBUG_FORTH_TOK 
1f02						DMARK "TOK" 
1f02				CALLMONITOR 
1f02			endif 
1f02 7e			.ptoken2:    ld a,(hl) 
1f03 23				inc hl 
1f04 fe 7f			cp FORTH_END_BUFFER 
1f06 28 26			jr z, .ptokendone2 
1f08			;	cp 0 
1f08 b7				or a 
1f09 28 23			jr z, .ptokendone2 
1f0b fe 22			cp '"' 
1f0d 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f0f fe 20			cp ' ' 
1f11 20 ef			jr nz,  .ptoken2 
1f13			 
1f13			; TODO consume comments held between ( and ) 
1f13			 
1f13				; we have a space so change to zero term for dict match later 
1f13 2b				dec hl 
1f14			;	ld a,0 
1f14 36 00			ld (hl), 0 
1f16 23				inc hl 
1f17 18 e9			jr .ptoken2 
1f19				 
1f19			 
1f19			.ptokenstr2: 
1f19				; skip all white space until either eol (because forgot to term) or end double quote 
1f19			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f19				;inc hl ; skip current double quote 
1f19 7e				ld a,(hl) 
1f1a 23				inc hl 
1f1b fe 22			cp '"' 
1f1d 28 e3			jr z, .ptoken2 
1f1f fe 7f			cp FORTH_END_BUFFER 
1f21 28 0b			jr z, .ptokendone2 
1f23			;	cp 0 
1f23 b7				or a 
1f24 28 08			jr z, .ptokendone2 
1f26 fe 20			cp ' ' 
1f28 28 02			jr z, .ptmp2 
1f2a 18 ed			jr .ptokenstr2 
1f2c			 
1f2c			.ptmp2:	; we have a space so change to zero term for dict match later 
1f2c				;dec hl 
1f2c				;ld a,"-"	; TODO remove this when working 
1f2c				;ld (hl), a 
1f2c				;inc hl 
1f2c 18 eb			jr .ptokenstr2 
1f2e			 
1f2e			.ptokendone2: 
1f2e				;inc hl 
1f2e			;	ld a, FORTH_END_BUFFER 
1f2e 36 7f			ld (hl),FORTH_END_BUFFER 
1f30			;	inc hl 
1f30			;	ld a, '!' 
1f30			;	ld (hl),a 
1f30			 
1f30 2a b9 e5			ld hl,(os_tok_ptr) 
1f33			         
1f33			if DEBUG_FORTH_TOK 
1f33						DMARK "TK1" 
1f33				CALLMONITOR 
1f33			endif 
1f33			 
1f33				; push exec string to top of return stack 
1f33				FORTH_RSP_NEXT 
1f33 cd 7d 1a			call macro_forth_rsp_next 
1f36				endm 
# End of macro FORTH_RSP_NEXT
1f36 c9				ret 
1f37			 
1f37			; 
1f37			;	; malloc size + buffer pointer + if is loop flag 
1f37			;	ld hl,(os_tok_len) 		 ; get string length 
1f37			; 
1f37			;	ld a,l 
1f37			; 
1f37			;	cp 0			; we dont want to use a null string 
1f37			;	ret z 
1f37			; 
1f37			;;	add 3    ; prefix malloc with buffer for current word ptr 
1f37			; 
1f37			;	add 5     ; TODO when certain not over writing memory remove 
1f37			; 
1f37			;		 
1f37			; 
1f37			;if DEBUG_FORTH_TOK 
1f37			;			DMARK "TKE" 
1f37			;	CALLMONITOR 
1f37			;endif 
1f37			; 
1f37			;	ld l,a 
1f37			;	ld h,0 
1f37			;;	push hl   ; save required space for the copy later 
1f37			;	call malloc 
1f37			;if DEBUG_FORTH_TOK 
1f37			;			DMARK "TKM" 
1f37			;	CALLMONITOR 
1f37			;endif 
1f37			;	if DEBUG_FORTH_MALLOC_GUARD 
1f37			;		push af 
1f37			;		call ishlzero 
1f37			;;		ld a, l 
1f37			;;		add h 
1f37			;;		cp 0 
1f37			;		pop af 
1f37			;		 
1f37			;		call z,malloc_error 
1f37			;	endif 
1f37			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1f37			; 
1f37			; 
1f37			;if DEBUG_FORTH_TOK 
1f37			;			DMARK "TKR" 
1f37			;	CALLMONITOR 
1f37			;endif 
1f37			; 
1f37			;	FORTH_RSP_NEXT 
1f37			; 
1f37			;	;inc hl	 ; go past current buffer pointer 
1f37			;	;inc hl 
1f37			;	;inc hl   ; and past if loop flag 
1f37			;		; TODO Need to set flag  
1f37			; 
1f37			;	 
1f37			;	 
1f37			;	ex de,hl	; malloc is dest 
1f37			;	ld hl, (os_tok_len) 
1f37			;;	pop bc 
1f37			;	ld c, l                
1f37			;	ld b,0 
1f37			;	ld hl, (os_tok_ptr) 
1f37			; 
1f37			;if DEBUG_FORTH_TOK 
1f37			;			DMARK "TKT" 
1f37			;	CALLMONITOR 
1f37			;endif 
1f37			; 
1f37			;	; do str cpy 
1f37			; 
1f37			;	ldir      ; copy byte in hl to de 
1f37			; 
1f37			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1f37			; 
1f37			;if DEBUG_FORTH_TOK 
1f37			; 
1f37			;			DMARK "TKY" 
1f37			;	CALLMONITOR 
1f37			;endif 
1f37			;	;ld a,0 
1f37			;	;ld a,FORTH_END_BUFFER 
1f37			;	ex de, hl 
1f37			;	;dec hl			 ; go back over the space delim at the end of word 
1f37			;	;ld (hl),a 
1f37			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1f37			;	ld a,FORTH_END_BUFFER 
1f37			;	ld (hl),a 
1f37			;	inc hl 
1f37			;	ld a,FORTH_END_BUFFER 
1f37			;	ld (hl),a 
1f37			; 
1f37			;	; init the malloc area data 
1f37			;	; set pc for in current area 
1f37			;	;ld hl, (os_tok_malloc) 
1f37			;	;inc hl 
1f37			;	;inc hl 
1f37			;	;inc hl 
1f37			;	;ex de,hl 
1f37			;	;ld hl, (os_tok_malloc) 
1f37			;	;ld (hl),e 
1f37			;	;inc hl 
1f37			;	;ld (hl),d 
1f37			; 
1f37			; 
1f37			;	ld hl,(os_tok_malloc) 
1f37			;if DEBUG_FORTH_PARSE_KEY 
1f37			;			DMARK "TKU" 
1f37			;	CALLMONITOR 
1f37			;endif 
1f37			; 
1f37			;	ret 
1f37			 
1f37			forthexec: 
1f37			 
1f37			; line exec: 
1f37			; forth parser 
1f37			 
1f37			; 
1f37			;       get current exec line on rsp 
1f37			 
1f37				FORTH_RSP_TOS 
1f37 cd 94 1a			call macro_forth_rsp_tos 
1f3a				endm 
# End of macro FORTH_RSP_TOS
1f3a			 
1f3a			;       restore current pc - hl points to malloc of data 
1f3a			 
1f3a				;ld e, (hl) 
1f3a				;inc hl 
1f3a				;ld d, (hl) 
1f3a				;ex de,hl 
1f3a			 
1f3a			 
1f3a			exec1: 
1f3a 22 b9 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
1f3d			 
1f3d				; copy our PC to working vars  
1f3d 22 37 ea			ld (cli_ptr), hl                    ; here 
1f40 22 35 ea			ld (cli_origptr), hl                ; here 
1f43			 
1f43 7e				ld a,(hl)                           ; here make hl be the ram ptr 
1f44 fe 7f			cp FORTH_END_BUFFER 
1f46 c8				ret z 
1f47			 
1f47				; skip any nulls 
1f47			 
1f47			;	cp 0 
1f47 b7				or a 
1f48 20 03			jr nz, .execword 
1f4a 23				inc hl 
1f4b 18 ed			jr exec1 
1f4d			 
1f4d			 
1f4d			.execword: 
1f4d			 
1f4d			 
1f4d			 
1f4d			if DEBUG_FORTH_PARSE_EXEC 
1f4d						DMARK "KYQ" 
1f4d				CALLMONITOR 
1f4d			endif 
1f4d			;       while at start of word: 
1f4d			; get start of dict (in user area first) 
1f4d			 
1f4d 21 cd 65		ld hl, baseram 
1f50			;ld hl, sysdict 
1f50 22 39 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
1f53			;           match word at pc 
1f53			;           exec word 
1f53			;           or push to dsp 
1f53			;           forward to next token 
1f53			;           if line term pop rsp and exit 
1f53			;        
1f53			 
1f53			if DEBUG_FORTH_PARSE_EXEC 
1f53						DMARK "KYq" 
1f53				CALLMONITOR 
1f53			endif 
1f53			 
1f53			; 
1f53			; word comp 
1f53			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1f53			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1f53			;    move to start of word  
1f53			;    compare word to cli_token 
1f53			 
1f53			.execpnword:	; HL at start of a word in the dictionary to check 
1f53			 
1f53 2a 39 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
1f56			 
1f56 cd eb 1f			call forth_tok_next 
1f59			; tok next end here 
1f59 22 39 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1f5c eb				ex de, hl 
1f5d			 
1f5d			 
1f5d				; save the pointer of the current token - 1 to check against 
1f5d				 
1f5d 22 3d ea			ld (cli_token), hl   
1f60				; TODO maybe remove below save if no debug 
1f60				; save token string ptr for any debug later 
1f60 23				inc hl  
1f61 22 3f ea			ld (cli_origtoken), hl 
1f64 2b				dec hl 
1f65				; save pointer to the start of the next dictionay word 
1f65 7e				ld a,(hl)   ; get string length 
1f66 47				ld b,a 
1f67			.execpnwordinc:  
1f67 23				inc hl 
1f68 10 fd			djnz .execpnwordinc 
1f6a 22 3b ea			ld (cli_execword), hl      ; save start of this words code 
1f6d			 
1f6d				; now check the word token against the string being parsed 
1f6d			 
1f6d 2a 3d ea			ld hl,(cli_token) 
1f70 23				inc hl     ; skip string length (use zero term instead to end) 
1f71				;ld (cli_token), hl 
1f71			 
1f71			.execpnchar:    ; compare char between token and string to parse 
1f71			 
1f71			 
1f71				;ld hl, (cli_token)     ; the dict word  
1f71 ed 5b 37 ea		ld de, (cli_ptr)     ; cli to parse 
1f75			 
1f75			 
1f75			.execpncharl:    ; compare char between token and string to parse (loop) 
1f75			 
1f75 1a				ld a,(de) 
1f76 cd 30 11			call toUpper 		; make sure the input string matches case 
1f79 be				cp (hl) 
1f7a			 
1f7a c2 92 1f			jp nz, .execpnskipword	 ; no match so move to next word 
1f7d				 
1f7d			;    if same 
1f7d			;       scan for string terms 0 for token and 32 for input 
1f7d 46				ld b,(hl) 
1f7e 80				add b			 
1f7f 23				inc hl 
1f80 13				inc de 
1f81 b7				or a 
1f82			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1f82							; TODO need to make sure last word in zero term string is accounted for 
1f82 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
1f84			 
1f84			 
1f84				; at end of both strings so both are exact match 
1f84			 
1f84			;       skip ptr for next word 
1f84			 
1f84 2a 37 ea			ld hl,(cli_ptr) 	; at input string term 
1f87 23				inc hl			 ; at next char 
1f88 22 37 ea			ld (cli_ptr), hl     ; save for next round of the parser 
1f8b 22 35 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1f8e				 
1f8e				 
1f8e			 
1f8e			 
1f8e			 
1f8e			;       exec code block 
1f8e			if DEBUG_FORTH_JP 
1f8e				call clear_display 
1f8e				call update_display 
1f8e				call delay1s 
1f8e				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f8e				ld a,h 
1f8e				ld hl, os_word_scratch 
1f8e				call hexout 
1f8e				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f8e				ld a,l 
1f8e				ld hl, os_word_scratch+2 
1f8e				call hexout 
1f8e				ld hl, os_word_scratch+4 
1f8e			;	ld a,0 
1f8e				ld (hl),0 
1f8e				ld de,os_word_scratch 
1f8e				call str_at_display 
1f8e					ld a, display_row_2 
1f8e					call str_at_display 
1f8e				ld de, (cli_origtoken) 
1f8e				ld a, display_row_1+10 
1f8e					call str_at_display 
1f8e			 
1f8e				ld a,display_row_1 
1f8e				ld de, .foundword 
1f8e				ld a, display_row_3 
1f8e				call str_at_display 
1f8e				call update_display 
1f8e				call delay1s 
1f8e				call delay1s 
1f8e				call delay1s 
1f8e			endif 
1f8e			 
1f8e			if DEBUG_FORTH_PARSE_EXEC 
1f8e						DMARK "KYj" 
1f8e			endif 
1f8e				; TODO save the word pointer in this exec 
1f8e			 
1f8e 2a 3b ea			ld hl,(cli_execword) 
1f91 e9				jp (hl) 
1f92			 
1f92			 
1f92			;    if not same 
1f92			;	scan for zero term 
1f92			;	get ptr for next word 
1f92			;	goto word comp 
1f92			 
1f92			.execpnskipword:	; get pointer to next word 
1f92 2a 39 ea			ld hl,(cli_nextword) 
1f95			 
1f95 7e				ld a,(hl) 
1f96 fe 00			cp WORD_SYS_END 
1f98			;	cp 0 
1f98 28 09			jr z, .execendofdict			 ; at end of words 
1f9a			 
1f9a			if DEBUG_FORTH_PARSE_EXEC 
1f9a						DMARK "KY4" 
1f9a			endif 
1f9a			if DEBUG_FORTH_PARSE_EXEC 
1f9a			 
1f9a				; see if disabled 
1f9a			 
1f9a			;	ld a, (os_view_disable) 
1f9a			;	cp '*' 
1f9a				ld a,(debug_vector) 
1f9a				cp $c9   ; RET 
1f9a				jr z, .noskip 
1f9a			 
1f9a			 
1f9a				ld de, .nowordfound 
1f9a				ld a, display_row_3 
1f9a				call str_at_display 
1f9a				call update_display 
1f9a				ld a, 100 
1f9a				call aDelayInMS 
1f9a				 
1f9a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f9a					call delay250ms 
1f9a				endif 
1f9a			.noskip:  
1f9a			 
1f9a			endif	 
1f9a			 
1f9a 2a 35 ea			ld hl,(cli_origptr) 
1f9d 22 37 ea			ld (cli_ptr),hl 
1fa0			 
1fa0			if DEBUG_FORTH_PARSE_EXEC 
1fa0						DMARK "KY5" 
1fa0			endif 
1fa0 c3 53 1f			jp .execpnword			; else go to next word 
1fa3			 
1fa3			.execendofdict:  
1fa3			 
1fa3			if DEBUG_FORTH_PARSE_EXEC 
1fa3						DMARK "KYe" 
1fa3			endif 
1fa3			if DEBUG_FORTH_PARSE_EXEC 
1fa3				; see if disabled 
1fa3			 
1fa3			;	ld a, (os_view_disable) 
1fa3			;	cp '*' 
1fa3				ld a,(debug_vector) 
1fa3				cp $c9   ; ret 
1fa3				jr z, .ispskip 
1fa3			 
1fa3				call clear_display 
1fa3				call update_display 
1fa3				call delay1s 
1fa3				ld de, (cli_origptr) 
1fa3				ld a, display_row_1 
1fa3				call str_at_display 
1fa3				 
1fa3				ld de, .enddict 
1fa3				ld a, display_row_3 
1fa3				call str_at_display 
1fa3				call update_display 
1fa3				ld a, 100 
1fa3				call aDelayInMS 
1fa3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fa3				call delay1s 
1fa3				call delay1s 
1fa3				call delay1s 
1fa3				endif 
1fa3			.ispskip:  
1fa3				 
1fa3			endif	 
1fa3			 
1fa3			 
1fa3			 
1fa3				; if the word is not a keyword then must be a literal so push it to stack 
1fa3			 
1fa3			; push token to stack to end of word 
1fa3			 
1fa3				STACKFRAME ON $1efe $2f9f 
1fa3				if DEBUG_STACK_IMB 
1fa3					if ON 
1fa3						exx 
1fa3						ld de, $1efe 
1fa3						ld a, d 
1fa3						ld hl, curframe 
1fa3						call hexout 
1fa3						ld a, e 
1fa3						ld hl, curframe+2 
1fa3						call hexout 
1fa3						ld hl, $1efe 
1fa3						push hl 
1fa3						ld hl, $2f9f 
1fa3						push hl 
1fa3						exx 
1fa3					endif 
1fa3				endif 
1fa3			endm 
# End of macro STACKFRAME
1fa3			 
1fa3 2a b9 e5		ld hl,(os_tok_ptr) 
1fa6 cd 38 1c		call forth_apush 
1fa9			 
1fa9				STACKFRAMECHK ON $1efe $2f9f 
1fa9				if DEBUG_STACK_IMB 
1fa9					if ON 
1fa9						exx 
1fa9						ld hl, $2f9f 
1fa9						pop de   ; $2f9f 
1fa9						call cmp16 
1fa9						jr nz, .spnosame 
1fa9						ld hl, $1efe 
1fa9						pop de   ; $1efe 
1fa9						call cmp16 
1fa9						jr z, .spfrsame 
1fa9						.spnosame: call showsperror 
1fa9						.spfrsame: nop 
1fa9						exx 
1fa9					endif 
1fa9				endif 
1fa9			endm 
# End of macro STACKFRAMECHK
1fa9			 
1fa9			execnext: 
1fa9			 
1fa9			if DEBUG_FORTH_PARSE_EXEC 
1fa9						DMARK "KY>" 
1fa9			endif 
1fa9			; move past token to next word 
1fa9			 
1fa9 2a b9 e5		ld hl, (os_tok_ptr) 
1fac 3e 00		ld a, 0 
1fae 01 ff 00		ld bc, 255     ; input buffer size 
1fb1 ed b1		cpir 
1fb3			 
1fb3			if DEBUG_FORTH_PARSE_EXEC 
1fb3						DMARK "KY!" 
1fb3				CALLMONITOR 
1fb3			endif	 
1fb3			; TODO this might place hl on the null, so will need to forward on??? 
1fb3			;inc hl   ; see if this gets onto the next item 
1fb3			 
1fb3			 
1fb3			; TODO pass a pointer to the buffer to push 
1fb3			; TODO call function to push 
1fb3			 
1fb3			; look for end of input 
1fb3			 
1fb3			;inc hl 
1fb3			;ld a,(hl) 
1fb3			;cp FORTH_END_BUFFER 
1fb3			;ret z 
1fb3			 
1fb3			 
1fb3 c3 3a 1f		jp exec1 
1fb6			 
1fb6			 
1fb6			 
1fb6			 
1fb6			 
1fb6			 
1fb6			 
1fb6			 
1fb6			 
1fb6			findnexttok: 
1fb6			 
1fb6				; hl is pointer to move 
1fb6				; de is the token to locate 
1fb6			 
1fb6					if DEBUG_FORTH 
1fb6						DMARK "NTK" 
1fb6						CALLMONITOR 
1fb6					endif 
1fb6 d5				push de 
1fb7			 
1fb7			.fnt1:	 
1fb7				; find first char of token to locate 
1fb7			 
1fb7 1a				ld a, (de) 
1fb8 4f				ld c,a 
1fb9 7e				ld a,(hl) 
1fba cd 30 11			call toUpper 
1fbd					if DEBUG_FORTH 
1fbd						DMARK "NT1" 
1fbd						CALLMONITOR 
1fbd					endif 
1fbd b9				cp c 
1fbe			 
1fbe 28 03			jr z, .fnt2cmpmorefirst	 
1fc0			 
1fc0				; first char not found move to next char 
1fc0			 
1fc0 23				inc hl 
1fc1 18 f4			jr .fnt1 
1fc3			 
1fc3			.fnt2cmpmorefirst:	 
1fc3				; first char of token found.  
1fc3			 
1fc3 e5				push hl     ; save start of token just in case it is the right one 
1fc4 d9				exx 
1fc5 e1				pop hl        ; save it to hl' 
1fc6 d9				exx 
1fc7			 
1fc7			 
1fc7			.fnt2cmpmore:	 
1fc7				; compare the rest 
1fc7				 
1fc7 23				inc hl 
1fc8 13				inc de 
1fc9				 
1fc9 1a				ld a, (de) 
1fca 4f				ld c,a 
1fcb 7e				ld a,(hl) 
1fcc cd 30 11			call toUpper 
1fcf			 
1fcf					if DEBUG_FORTH 
1fcf						DMARK "NT2" 
1fcf						CALLMONITOR 
1fcf					endif 
1fcf				; c has the token to find char 
1fcf				; a has the mem to scan char 
1fcf			 
1fcf b9				cp c 
1fd0 28 04			jr z,.fntmatch1 
1fd2			 
1fd2				; they are not the same 
1fd2			 
1fd2					if DEBUG_FORTH 
1fd2						DMARK "NT3" 
1fd2						CALLMONITOR 
1fd2					endif 
1fd2 d1				pop de	; reset de token to look for 
1fd3 d5				push de 
1fd4 18 e1			jr .fnt1 
1fd6				 
1fd6			.fntmatch1: 
1fd6			 
1fd6				; is the same char a null which means we might have a full hit? 
1fd6					if DEBUG_FORTH 
1fd6						DMARK "NT4" 
1fd6						CALLMONITOR 
1fd6					endif 
1fd6			 
1fd6			;	cp 0 
1fd6 b7				or a 
1fd7 28 0b			jr z, .fntmatchyes 
1fd9			 
1fd9				; are we at the end of the token to find? 
1fd9			 
1fd9					if DEBUG_FORTH 
1fd9						DMARK "NT5" 
1fd9						CALLMONITOR 
1fd9					endif 
1fd9 3e 00			ld a, 0 
1fdb b9				cp c 
1fdc			 
1fdc c2 c7 1f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1fdf			 
1fdf					if DEBUG_FORTH 
1fdf						DMARK "NT6" 
1fdf						CALLMONITOR 
1fdf					endif 
1fdf				; token to find is exhusted but no match to stream 
1fdf			 
1fdf				; restore tok pointer and continue on 
1fdf d1				pop de 
1fe0 d5				push de 
1fe1 c3 b7 1f			jp .fnt1 
1fe4			 
1fe4			 
1fe4			.fntmatchyes: 
1fe4			 
1fe4				; hl now contains the end of the found token 
1fe4			 
1fe4				; get rid of saved token pointer to find 
1fe4			 
1fe4 d1				pop de 
1fe5			 
1fe5					if DEBUG_FORTH 
1fe5						DMARK "NT9" 
1fe5						CALLMONITOR 
1fe5					endif 
1fe5			 
1fe5				; hl will be on the null term so forward on 
1fe5			 
1fe5				; get back the saved start of the token 
1fe5			 
1fe5 d9				exx 
1fe6 e5				push hl     ; save start of token just in case it is the right one 
1fe7 d9				exx 
1fe8 e1				pop hl        ; save it to hl 
1fe9			 
1fe9 c9				ret 
1fea			 
1fea			 
1fea			; LIST needs to find a specific token   
1fea			; FORGET needs to find a spefici token 
1fea			 
1fea			; SAVE needs to find all tokens by flag 
1fea			; WORDS just needs to scan through all  by flag 
1fea			; UWORDS needs to scan through all by flag 
1fea			 
1fea			 
1fea			; given hl as pointer to start of dict look up string 
1fea			; return hl as pointer to start of word block 
1fea			; or 0 if not found 
1fea			 
1fea			forth_find_tok: 
1fea c9				ret 
1feb			 
1feb			; given hl as pointer to dict structure 
1feb			; move to the next dict block structure 
1feb			 
1feb			forth_tok_next: 
1feb				; hl now points to the address of the next word pointer  
1feb				; TODO skip compiled symbol for now 
1feb			;	push de 
1feb 23				inc hl 
1fec 5e				ld e, (hl) 
1fed 23				inc hl 
1fee 56				ld d, (hl) 
1fef 23				inc hl 
1ff0			 
1ff0 eb				ex de,hl 
1ff1			if DEBUG_FORTH_PARSE_NEXTWORD 
1ff1				push bc 
1ff1				ld bc, (cli_nextword) 
1ff1						DMARK "NXW" 
1ff1				CALLMONITOR 
1ff1				pop bc 
1ff1			endif 
1ff1			;	pop de	 
1ff1 c9				ret 
1ff2			 
1ff2			 
1ff2			 
1ff2			; eof 
# End of file forth_parserv6.asm
1ff2				include "forth_wordsv4.asm" 
1ff2			 
1ff2			; the core word dictionary v4 
1ff2			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ff2			 
1ff2			; this is a linked list for each of the system words used 
1ff2			; user defined words will follow the same format but will be in ram 
1ff2			 
1ff2			 
1ff2			; 
1ff2			; 
1ff2			; define linked list: 
1ff2			; 
1ff2			; 1. compiled byte op code 
1ff2			; 2. len of text word 
1ff2			; 3. text word 
1ff2			; 4. ptr to next dictionary word 
1ff2			; 5. asm, calls etc for the word 
1ff2			; 
1ff2			;  if 1 == 0 then last word in dict  
1ff2			;   
1ff2			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ff2			;  
1ff2			;  
1ff2			; create basic standard set of words 
1ff2			; 
1ff2			;  
1ff2			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ff2			; 2DUP 2DROP 2SWAP  
1ff2			; @ C@ - get byte  
1ff2			; ! C! - store byte 
1ff2			; 0< true if less than zero 
1ff2			; 0= true if zero 
1ff2			; < >  
1ff2			; = true if same 
1ff2			; variables 
1ff2			 
1ff2			 
1ff2			; Hardware specific words I may need 
1ff2			; 
1ff2			; IN OUT  
1ff2			; calls to key util functions 
1ff2			; calls to hardward abstraction stuff 
1ff2			; easy control of frame buffers and lcd i/o 
1ff2			; keyboard  
1ff2			 
1ff2			 
1ff2			;DICT: macro 
1ff2			; op_code, len, word, next 
1ff2			;    word: 
1ff2			;    db op_code 
1ff2			;    ds word zero term 
1ff2			;    dw next 
1ff2			;    endm 
1ff2			 
1ff2			 
1ff2			 
1ff2			 
1ff2			; op code 1 is a flag for user define words which are to be handled differently 
1ff2			 
1ff2			 
1ff2			; 
1ff2			; 
1ff2			;    TODO on entry to a word this should be the expected environment 
1ff2			;    hl - tos value if number then held, if string this is the ptr 
1ff2			;    de -  
1ff2			 
1ff2			 
1ff2			; opcode ranges 
1ff2			; 0 - end of word dict 
1ff2			; 255 - user define words 
1ff2			 
1ff2			sysdict: 
1ff2			include "forth_opcodes.asm" 
1ff2			; op codes for forth keywords 
1ff2			 
1ff2			; Changing use of opcodes to flag is the word exists in compiled form or not.  
1ff2			; This provides a means to compile uwords if required for higher performance 
1ff2			; by avoiding the use of the keyword parser and just jumping directly to the code 
1ff2			; Actually there is already a flag for if the code exists as binary thinking about it... 
1ff2			 
1ff2			 
1ff2			 
1ff2			 
1ff2			 
1ff2			; free to use code 0  
1ff2				OPCODE_HEAP: equ  1 
1ff2				OPCODE_EXEC: equ 2 
1ff2				OPCODE_DUP: equ 3 
1ff2				OPCODE_SWAP: equ 4 
1ff2				OPCODE_COLN: equ 5 
1ff2				OPCODE_SCOLN: equ 6 
1ff2				OPCODE_DROP: equ 7 
1ff2				OPCODE_DUP2: equ 8 
1ff2				OPCODE_DROP2: equ 9 
1ff2				OPCODE_SWAP2: equ 10 
1ff2				OPCODE_AT: equ 11 
1ff2				OPCODE_CAT: equ 12 
1ff2				OPCODE_BANG: equ 13 
1ff2				OPCODE_CBANG: equ 14 
1ff2				OPCODE_SCALL: equ 15 
1ff2				OPCODE_DEPTH: equ 16 
1ff2				OPCODE_OVER: equ 17 
1ff2				OPCODE_PAUSE: equ 18 
1ff2				OPCODE_PAUSES: equ 19 
1ff2				OPCODE_ROT: equ 20 
1ff2			;free to reuse	OPCODE_WORDS: equ 21 
1ff2			        OPCODE_NOT: equ 21 
1ff2				OPCODE_UWORDS: equ 22 
1ff2				OPCODE_BP: equ 23 
1ff2				OPCODE_MONITOR: equ 24  
1ff2				OPCODE_MALLOC: equ 25 
1ff2				OPCODE_FREE: equ 26 
1ff2				OPCODE_LIST: equ 27 
1ff2				OPCODE_FORGET: equ 28 
1ff2				OPCODE_NOP: equ 29 
1ff2				OPCODE_COMO: equ 30 
1ff2				OPCODE_COMC: equ 31 
1ff2			;free to reuse	OPCODE_ENDCORE: equ 32 
1ff2				OPCODE_AFTERSOUND: equ 33 
1ff2				OPCODE_GP2: equ 34 
1ff2				OPCODE_GP3: equ 35 
1ff2				OPCODE_GP4: equ 36 
1ff2				OPCODE_SIN: equ 37 
1ff2				OPCODE_SOUT: equ 38 
1ff2				OPCODE_SPIO: equ 39 
1ff2				OPCODE_SPICEH: equ 40 
1ff2				OPCODE_SPIOb: equ 41 
1ff2				OPCODE_SPII: equ 42 
1ff2				OPCODE_SESEL: equ 43 
1ff2				OPCODE_CARTDEV: equ 44 
1ff2			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ff2				OPCODE_FB: equ 46 
1ff2				OPCODE_EMIT: equ 47 
1ff2				OPCODE_DOTH: equ 48 
1ff2				OPCODE_DOTF: equ 49 
1ff2				OPCODE_DOT: equ 50 
1ff2				OPCODE_CLS: equ 51 
1ff2				OPCODE_DRAW: equ 52 
1ff2				OPCODE_DUMP: equ 53 
1ff2				OPCODE_CDUMP: equ 54 
1ff2				OPCODE_DAT: equ 55 
1ff2				OPCODE_HOME: equ 56 
1ff2				OPCODE_SPACE: equ 57 
1ff2				OPCODE_SPACES: equ 58 
1ff2				OPCODE_SCROLL: equ 59 
1ff2				OPCODE_ATQ: equ 60 
1ff2				OPCODE_AUTODSP: equ 61 
1ff2				OPCODE_MENU: equ 62 
1ff2			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ff2				OPCODE_THEN: equ 64 
1ff2				OPCODE_ELSE: equ 65 
1ff2				OPCODE_DO: equ 66 
1ff2				OPCODE_LOOP: equ 67 
1ff2				OPCODE_I: equ 68 
1ff2				OPCODE_DLOOP: equ 69  
1ff2				OPCODE_REPEAT: equ 70  
1ff2				OPCODE_UNTIL: equ 71 
1ff2				OPCODE_ENDFLOW: equ 72 
1ff2				OPCODE_WAITK: equ 73 
1ff2				OPCODE_ACCEPT: equ 74 
1ff2				OPCODE_EDIT: equ 75 
1ff2			;free to reuse	OPCODE_ENDKEY: equ 76 
1ff2				OPCODE_LZERO: equ 77 
1ff2				OPCODE_TZERO: equ 78 
1ff2				OPCODE_LESS: equ 79 
1ff2				OPCODE_GT: equ 80 
1ff2				OPCODE_EQUAL: equ 81  
1ff2			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ff2				OPCODE_NEG: equ 83 
1ff2				OPCODE_DIV: equ 84 
1ff2				OPCODE_MUL: equ 85 
1ff2				OPCODE_MIN: equ 86 
1ff2				OPCODE_MAX: equ 87 
1ff2				OPCODE_RND16: equ 88 
1ff2				OPCODE_RND8: equ 89 
1ff2				OPCODE_RND: equ 90 
1ff2			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ff2				OPCODE_BYNAME: equ 92 
1ff2				OPCODE_DIR: equ 93 
1ff2				OPCODE_SAVE: equ 94 
1ff2				OPCODE_LOAD: equ 95 
1ff2				OPCODE_BSAVE: equ 96 
1ff2				OPCODE_BLOAD: equ 97 
1ff2				OPCODE_SEO: equ 98  
1ff2				OPCODE_SEI: equ 99 
1ff2				OPCODE_SFREE: equ 100 
1ff2				OPCODE_SIZE: equ 101 
1ff2				OPCODE_CREATE: equ 102 
1ff2				OPCODE_APPEND: equ 103 
1ff2				OPCODE_SDEL: equ 104 
1ff2				OPCODE_OPEN: equ 105 
1ff2				OPCODE_READ: equ 106 
1ff2				OPCODE_EOF: equ 106 
1ff2				OPCODE_FORMAT: equ 107 
1ff2				OPCODE_LABEL: equ 108 
1ff2				OPCODE_LABELS: equ 109 
1ff2			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ff2				OPCODE_UPPER: equ 111 
1ff2				OPCODE_LOWER: equ 112 
1ff2				OPCODE_SUBSTR: equ 113 
1ff2				OPCODE_LEFT: equ 114 
1ff2				OPCODE_RIGHT: equ 115 
1ff2				OPCODE_STR2NUM: equ 116 
1ff2				OPCODE_NUM2STR: equ 117 
1ff2				OPCODE_CONCAT: equ 118 
1ff2				OPCODE_FIND: equ 119 
1ff2				OPCODE_LEN: equ 120 
1ff2				OPCODE_CHAR: equ 121 
1ff2			; free to reuse	OPCODE_STRLEN: equ 122 
1ff2			; free to reuse	OPCODE_ENDSTR: equ 123 
1ff2				OPCODE_V0S: equ 124 
1ff2				OPCODE_V0Q: equ 125 
1ff2				OPCODE_V1S: equ 126 
1ff2				OPCODE_V1Q: equ 127 
1ff2				OPCODE_V2S: equ 128 
1ff2				OPCODE_V2Q: equ 129 
1ff2				OPCODE_V3S: equ 130 
1ff2				OPCODE_V3Q: equ 131 
1ff2			;free to reuse	OPCODE_END: equ 132 
1ff2				OPCODE_ZDUP: equ 133 
1ff2			 
1ff2			; eof 
# End of file forth_opcodes.asm
1ff2			 
1ff2			include "forth_words_core.asm" 
1ff2			 
1ff2			; | ## Core Words 
1ff2			 
1ff2			;if MALLOC_4 
1ff2			 
1ff2			.HEAP: 
1ff2			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ff2 15				db WORD_SYS_CORE+OPCODE_HEAP             
1ff3 34 20			dw .EXEC            
1ff5 05				db 4 + 1 
1ff6 .. 00			db "HEAP",0              
1ffb				endm 
# End of macro CWHEAD
1ffb			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1ffb			; | | u1 - Current number of bytes in the heap 
1ffb			; | | u2 - Remaining bytes left on the heap 
1ffb			; | |  
1ffb			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1ffb			 
1ffb			 
1ffb				if DEBUG_FORTH_WORDS_KEY 
1ffb					DMARK "HEP" 
1ffb f5				push af  
1ffc 3a 10 20			ld a, (.dmark)  
1fff 32 62 ee			ld (debug_mark),a  
2002 3a 11 20			ld a, (.dmark+1)  
2005 32 63 ee			ld (debug_mark+1),a  
2008 3a 12 20			ld a, (.dmark+2)  
200b 32 64 ee			ld (debug_mark+2),a  
200e 18 03			jr .pastdmark  
2010 ..			.dmark: db "HEP"  
2013 f1			.pastdmark: pop af  
2014			endm  
# End of macro DMARK
2014					CALLMONITOR 
2014 cd 6f ee			call debug_vector  
2017				endm  
# End of macro CALLMONITOR
2017				endif 
2017 2a d7 65			ld hl, (free_list )      
201a 11 dc 65			ld de, heap_start 
201d			 
201d ed 52			sbc hl, de  
201f			 
201f cd d6 1a			call forth_push_numhl 
2022			 
2022			 
2022 ed 5b d7 65		ld de, (free_list )      
2026 21 93 e2			ld hl, heap_end 
2029			 
2029 ed 52			sbc hl, de 
202b			 
202b cd d6 1a			call forth_push_numhl 
202e				 
202e			 
202e				 
202e			 
202e			 
202e			 
202e				NEXTW 
202e cd 6c ee			call parse_vector 
2031 c3 b9 1e			jp macro_next 
2034				endm 
# End of macro NEXTW
2034			;endif 
2034			 
2034			.EXEC: 
2034			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2034			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2034			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2034			;; > > 
2034			;; > >   
2034			;	STACKFRAME OFF $5efe $5f9f 
2034			; 
2034			;		if DEBUG_FORTH_WORDS_KEY 
2034			;			DMARK "EXE" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			; 
2034			;	FORTH_DSP_VALUEHL 
2034			; 
2034			;	FORTH_DSP_POP 
2034			; 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EX1" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;;	ld e,(hl) 
2034			;;	inc hl 
2034			;;	ld d,(hl) 
2034			;;	ex de,hl 
2034			; 
2034			;;		if DEBUG_FORTH_WORDS 
2034			;;			DMARK "EX2" 
2034			;;			CALLMONITOR 
2034			;;		endif 
2034			;	push hl 
2034			; 
2034			;	;ld a, 0 
2034			;	;ld a, FORTH_END_BUFFER 
2034			;	call strlenz 
2034			;	inc hl   ; include zero term to copy 
2034			;	inc hl   ; include term 
2034			;	inc hl   ; include term 
2034			;	ld b,0 
2034			;	ld c,l 
2034			;	pop hl 
2034			;	ld de, execscratch 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EX3" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;	ldir 
2034			; 
2034			; 
2034			;	ld hl, execscratch 
2034			; 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EXe" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			; 
2034			;	call forthparse 
2034			;	call forthexec 
2034			;;	call forthexec_cleanup 
2034			;;	call forthparse 
2034			;;	call forthexec 
2034			; 
2034			;	STACKFRAMECHK OFF $5efe $5f9f 
2034			; 
2034			;	; an immediate word so no need to process any more words 
2034			;	ret 
2034			;	NEXTW 
2034			 
2034			; dead code - old version  
2034			;	FORTH_RSP_NEXT 
2034			 
2034			;  
2034			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2034			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2034			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2034			;	push hl 
2034			;	push de 
2034			;	push bc 
2034			; 
2034			; 
2034			;		if DEBUG_FORTH_WORDS_KEY 
2034			;			DMARK "EXR" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			; 
2034			; 
2034			; 
2034			;	;v5 FORTH_DSP_VALUE 
2034			;	FORTH_DSP_VALUEHL 
2034			; 
2034			;	; TODO do string type checks 
2034			; 
2034			;;v5	inc hl   ; skip type 
2034			; 
2034			;	push hl  ; source code  
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EX1" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;	ld a, 0 
2034			;	call strlent 
2034			; 
2034			;	inc hl 
2034			;	inc hl 
2034			;	inc hl 
2034			;	inc hl 
2034			; 
2034			;	push hl    ; size 
2034			; 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EX2" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;	call malloc 
2034			; 
2034			;	ex de, hl    ; de now contains malloc area 
2034			;	pop bc   	; get byte count 
2034			;	pop hl      ; get string to copy 
2034			; 
2034			;	push de     ; save malloc for free later 
2034			; 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EX3" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;	ldir       ; duplicate string 
2034			; 
2034			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2034			;	 
2034			;	; TODO fix the parse would be better than this...  
2034			;	ex de, hl 
2034			;	dec hl 
2034			;	ld a, 0 
2034			;	ld (hl), a 
2034			;	dec hl 
2034			;	ld a, ' ' 
2034			;	ld (hl), a 
2034			;	dec hl 
2034			;	ld (hl), a 
2034			; 
2034			;	dec hl 
2034			;	ld (hl), a 
2034			; 
2034			; 
2034			;	FORTH_DSP_POP  
2034			; 
2034			;	pop hl     
2034			;	push hl    ; save malloc area 
2034			; 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EX4" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			; 
2034			;	call forthparse 
2034			;	call forthexec 
2034			;	 
2034			;	pop hl 
2034			;	if DEBUG_FORTH_WORDS 
2034			;		DMARK "EX5" 
2034			;		CALLMONITOR 
2034			;	endif 
2034			; 
2034			;	if FORTH_ENABLE_FREE 
2034			;	call free 
2034			;	endif 
2034			; 
2034			;	if DEBUG_FORTH_WORDS 
2034			;		DMARK "EX6" 
2034			;		CALLMONITOR 
2034			;	endif 
2034			; 
2034			;	pop bc 
2034			;	pop de 
2034			;	pop hl 
2034			;;	FORTH_RSP_POP	  
2034			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2034			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2034			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2034			; 
2034			;	if DEBUG_FORTH_WORDS 
2034			;		DMARK "EX7" 
2034			;		CALLMONITOR 
2034			;	endif 
2034			;	NEXTW 
2034			 
2034			;.STKEXEC: 
2034			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2034			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2034			; 
2034			; 
2034			;		if DEBUG_FORTH_WORDS_KEY 
2034			;			DMARK "STX" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			; 
2034			;	FORTH_DSP_VALUEHL 
2034			; 
2034			;	ld (store_tmp1), hl    ; count 
2034			; 
2034			;	FORTH_DSP_POP 
2034			;.stkexec1: 
2034			;	ld hl, (store_tmp1)   ; count 
2034			;	ld a, 0 
2034			;	cp l 
2034			;	ret z 
2034			; 
2034			;	dec hl 
2034			;	ld (store_tmp1), hl    ; count 
2034			;	 
2034			;	FORTH_DSP_VALUEHL 
2034			;	push hl 
2034			;	 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EXp" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;	FORTH_DSP_POP 
2034			; 
2034			;	call strlenz 
2034			;	inc hl   ; include zero term to copy 
2034			;	inc hl   ; include zero term to copy 
2034			;	inc hl   ; include zero term to copy 
2034			;	ld b,0 
2034			;	ld c,l 
2034			;	pop hl 
2034			;	ld de, execscratch 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EX3" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;	ldir 
2034			; 
2034			; 
2034			;	ld hl, execscratch 
2034			; 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EXP" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			; 
2034			;	call forthparse 
2034			;	ld hl, execscratch 
2034			;		if DEBUG_FORTH_WORDS 
2034			;			DMARK "EXx" 
2034			;			CALLMONITOR 
2034			;		endif 
2034			;	call forthexec 
2034			; 
2034			;	jp .stkexec1 
2034			; 
2034			;	ret 
2034			 
2034			 
2034			.DUP: 
2034			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2034 17				db WORD_SYS_CORE+OPCODE_DUP             
2035 b0 20			dw .ZDUP            
2037 04				db 3 + 1 
2038 .. 00			db "DUP",0              
203c				endm 
# End of macro CWHEAD
203c			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
203c			; | | >[!NOTE] 
203c			; | | > If the duplicated item is a string it is safely duplicated 
203c			 
203c				if DEBUG_FORTH_WORDS_KEY 
203c					DMARK "DUP" 
203c f5				push af  
203d 3a 51 20			ld a, (.dmark)  
2040 32 62 ee			ld (debug_mark),a  
2043 3a 52 20			ld a, (.dmark+1)  
2046 32 63 ee			ld (debug_mark+1),a  
2049 3a 53 20			ld a, (.dmark+2)  
204c 32 64 ee			ld (debug_mark+2),a  
204f 18 03			jr .pastdmark  
2051 ..			.dmark: db "DUP"  
2054 f1			.pastdmark: pop af  
2055			endm  
# End of macro DMARK
2055					CALLMONITOR 
2055 cd 6f ee			call debug_vector  
2058				endm  
# End of macro CALLMONITOR
2058				endif 
2058			 
2058				FORTH_DSP 
2058 cd 98 1c			call macro_forth_dsp 
205b				endm 
# End of macro FORTH_DSP
205b			 
205b 7e				ld a, (HL) 
205c fe 01			cp DS_TYPE_STR 
205e 20 28			jr nz, .dupinum 
2060			 
2060				; push another string 
2060			 
2060				FORTH_DSP_VALUEHL     		 
2060 cd d2 1c			call macro_dsp_valuehl 
2063				endm 
# End of macro FORTH_DSP_VALUEHL
2063			 
2063			if DEBUG_FORTH_WORDS 
2063				DMARK "DUs" 
2063 f5				push af  
2064 3a 78 20			ld a, (.dmark)  
2067 32 62 ee			ld (debug_mark),a  
206a 3a 79 20			ld a, (.dmark+1)  
206d 32 63 ee			ld (debug_mark+1),a  
2070 3a 7a 20			ld a, (.dmark+2)  
2073 32 64 ee			ld (debug_mark+2),a  
2076 18 03			jr .pastdmark  
2078 ..			.dmark: db "DUs"  
207b f1			.pastdmark: pop af  
207c			endm  
# End of macro DMARK
207c				CALLMONITOR 
207c cd 6f ee			call debug_vector  
207f				endm  
# End of macro CALLMONITOR
207f			endif 
207f cd 40 1b			call forth_push_str 
2082			 
2082				NEXTW 
2082 cd 6c ee			call parse_vector 
2085 c3 b9 1e			jp macro_next 
2088				endm 
# End of macro NEXTW
2088			 
2088			 
2088			.dupinum: 
2088				 
2088			 
2088			 
2088				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2088 cd d2 1c			call macro_dsp_valuehl 
208b				endm 
# End of macro FORTH_DSP_VALUEHL
208b			 
208b			; TODO add floating point number detection 
208b			 
208b			if DEBUG_FORTH_WORDS 
208b				DMARK "DUi" 
208b f5				push af  
208c 3a a0 20			ld a, (.dmark)  
208f 32 62 ee			ld (debug_mark),a  
2092 3a a1 20			ld a, (.dmark+1)  
2095 32 63 ee			ld (debug_mark+1),a  
2098 3a a2 20			ld a, (.dmark+2)  
209b 32 64 ee			ld (debug_mark+2),a  
209e 18 03			jr .pastdmark  
20a0 ..			.dmark: db "DUi"  
20a3 f1			.pastdmark: pop af  
20a4			endm  
# End of macro DMARK
20a4				CALLMONITOR 
20a4 cd 6f ee			call debug_vector  
20a7				endm  
# End of macro CALLMONITOR
20a7			endif 
20a7			 
20a7 cd d6 1a			call forth_push_numhl 
20aa				NEXTW 
20aa cd 6c ee			call parse_vector 
20ad c3 b9 1e			jp macro_next 
20b0				endm 
# End of macro NEXTW
20b0			.ZDUP: 
20b0			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
20b0 99				db WORD_SYS_CORE+OPCODE_ZDUP             
20b1 ea 20			dw .DMRK            
20b3 05				db 4 + 1 
20b4 .. 00			db "?DUP",0              
20b9				endm 
# End of macro CWHEAD
20b9			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
20b9			; | | >[!NOTE] 
20b9			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
20b9			 
20b9				if DEBUG_FORTH_WORDS_KEY 
20b9					DMARK "qDU" 
20b9 f5				push af  
20ba 3a ce 20			ld a, (.dmark)  
20bd 32 62 ee			ld (debug_mark),a  
20c0 3a cf 20			ld a, (.dmark+1)  
20c3 32 63 ee			ld (debug_mark+1),a  
20c6 3a d0 20			ld a, (.dmark+2)  
20c9 32 64 ee			ld (debug_mark+2),a  
20cc 18 03			jr .pastdmark  
20ce ..			.dmark: db "qDU"  
20d1 f1			.pastdmark: pop af  
20d2			endm  
# End of macro DMARK
20d2					CALLMONITOR 
20d2 cd 6f ee			call debug_vector  
20d5				endm  
# End of macro CALLMONITOR
20d5				endif 
20d5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20d5 cd d2 1c			call macro_dsp_valuehl 
20d8				endm 
# End of macro FORTH_DSP_VALUEHL
20d8			 
20d8 e5				push hl 
20d9			 
20d9				; is it a zero? 
20d9			 
20d9 3e 00			ld a, 0 
20db 84				add h 
20dc 85				add l 
20dd			 
20dd e1				pop hl 
20de			 
20de			;	cp 0 
20de b7				or a 
20df 28 03			jr z, .dup2orig 
20e1			 
20e1			 
20e1 cd d6 1a			call forth_push_numhl 
20e4			 
20e4			 
20e4			; TODO add floating point number detection 
20e4			 
20e4			.dup2orig: 
20e4			 
20e4				NEXTW 
20e4 cd 6c ee			call parse_vector 
20e7 c3 b9 1e			jp macro_next 
20ea				endm 
# End of macro NEXTW
20ea			.DMRK: 
20ea			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
20ea 99				db WORD_SYS_CORE+OPCODE_ZDUP             
20eb 2a 21			dw .LSHIFT            
20ed 06				db 5 + 1 
20ee .. 00			db "DMARK",0              
20f4				endm 
# End of macro CWHEAD
20f4			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
20f4			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
20f4				if DEBUG_FORTH_WORDS_KEY 
20f4					DMARK "DMK" 
20f4 f5				push af  
20f5 3a 09 21			ld a, (.dmark)  
20f8 32 62 ee			ld (debug_mark),a  
20fb 3a 0a 21			ld a, (.dmark+1)  
20fe 32 63 ee			ld (debug_mark+1),a  
2101 3a 0b 21			ld a, (.dmark+2)  
2104 32 64 ee			ld (debug_mark+2),a  
2107 18 03			jr .pastdmark  
2109 ..			.dmark: db "DMK"  
210c f1			.pastdmark: pop af  
210d			endm  
# End of macro DMARK
210d					CALLMONITOR 
210d cd 6f ee			call debug_vector  
2110				endm  
# End of macro CALLMONITOR
2110				endif 
2110				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2110 cd d2 1c			call macro_dsp_valuehl 
2113				endm 
# End of macro FORTH_DSP_VALUEHL
2113			 
2113 7e				ld a, (hl) 
2114 32 62 ee			ld (debug_mark),a 
2117 23				inc hl 
2118 7e				ld a, (hl) 
2119 32 63 ee			ld (debug_mark+1),a 
211c 23				inc hl 
211d 7e				ld a, (hl) 
211e 32 64 ee			ld (debug_mark+2),a 
2121			 
2121			 
2121				FORTH_DSP_POP 
2121 cd 8a 1d			call macro_forth_dsp_pop 
2124				endm 
# End of macro FORTH_DSP_POP
2124				NEXTW 
2124 cd 6c ee			call parse_vector 
2127 c3 b9 1e			jp macro_next 
212a				endm 
# End of macro NEXTW
212a			.LSHIFT: 
212a			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
212a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
212b 61 21			dw .RSHIFT            
212d 07				db 6 + 1 
212e .. 00			db "LSHIFT",0              
2135				endm 
# End of macro CWHEAD
2135			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2135				if DEBUG_FORTH_WORDS_KEY 
2135					DMARK "LSH" 
2135 f5				push af  
2136 3a 4a 21			ld a, (.dmark)  
2139 32 62 ee			ld (debug_mark),a  
213c 3a 4b 21			ld a, (.dmark+1)  
213f 32 63 ee			ld (debug_mark+1),a  
2142 3a 4c 21			ld a, (.dmark+2)  
2145 32 64 ee			ld (debug_mark+2),a  
2148 18 03			jr .pastdmark  
214a ..			.dmark: db "LSH"  
214d f1			.pastdmark: pop af  
214e			endm  
# End of macro DMARK
214e					CALLMONITOR 
214e cd 6f ee			call debug_vector  
2151				endm  
# End of macro CALLMONITOR
2151				endif 
2151				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2151 cd d2 1c			call macro_dsp_valuehl 
2154				endm 
# End of macro FORTH_DSP_VALUEHL
2154				FORTH_DSP_POP 
2154 cd 8a 1d			call macro_forth_dsp_pop 
2157				endm 
# End of macro FORTH_DSP_POP
2157			 
2157 29				add hl, hl 
2158 cd d6 1a			call forth_push_numhl 
215b				NEXTW 
215b cd 6c ee			call parse_vector 
215e c3 b9 1e			jp macro_next 
2161				endm 
# End of macro NEXTW
2161			.RSHIFT: 
2161			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
2161 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2162 9b 21			dw .SWAP            
2164 07				db 6 + 1 
2165 .. 00			db "RSHIFT",0              
216c				endm 
# End of macro CWHEAD
216c			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
216c				if DEBUG_FORTH_WORDS_KEY 
216c					DMARK "RSH" 
216c f5				push af  
216d 3a 81 21			ld a, (.dmark)  
2170 32 62 ee			ld (debug_mark),a  
2173 3a 82 21			ld a, (.dmark+1)  
2176 32 63 ee			ld (debug_mark+1),a  
2179 3a 83 21			ld a, (.dmark+2)  
217c 32 64 ee			ld (debug_mark+2),a  
217f 18 03			jr .pastdmark  
2181 ..			.dmark: db "RSH"  
2184 f1			.pastdmark: pop af  
2185			endm  
# End of macro DMARK
2185					CALLMONITOR 
2185 cd 6f ee			call debug_vector  
2188				endm  
# End of macro CALLMONITOR
2188				endif 
2188				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2188 cd d2 1c			call macro_dsp_valuehl 
218b				endm 
# End of macro FORTH_DSP_VALUEHL
218b				FORTH_DSP_POP 
218b cd 8a 1d			call macro_forth_dsp_pop 
218e				endm 
# End of macro FORTH_DSP_POP
218e cb 3c			srl h 
2190 cb 1d			rr l 
2192 cd d6 1a			call forth_push_numhl 
2195				NEXTW 
2195 cd 6c ee			call parse_vector 
2198 c3 b9 1e			jp macro_next 
219b				endm 
# End of macro NEXTW
219b			.SWAP: 
219b			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
219b 18				db WORD_SYS_CORE+OPCODE_SWAP             
219c f2 21			dw .COLN            
219e 05				db 4 + 1 
219f .. 00			db "SWAP",0              
21a4				endm 
# End of macro CWHEAD
21a4			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21a4				if DEBUG_FORTH_WORDS_KEY 
21a4					DMARK "SWP" 
21a4 f5				push af  
21a5 3a b9 21			ld a, (.dmark)  
21a8 32 62 ee			ld (debug_mark),a  
21ab 3a ba 21			ld a, (.dmark+1)  
21ae 32 63 ee			ld (debug_mark+1),a  
21b1 3a bb 21			ld a, (.dmark+2)  
21b4 32 64 ee			ld (debug_mark+2),a  
21b7 18 03			jr .pastdmark  
21b9 ..			.dmark: db "SWP"  
21bc f1			.pastdmark: pop af  
21bd			endm  
# End of macro DMARK
21bd					CALLMONITOR 
21bd cd 6f ee			call debug_vector  
21c0				endm  
# End of macro CALLMONITOR
21c0				endif 
21c0			 
21c0			; DONE Use os stack swap memory 
21c0			 
21c0				FORTH_DSP_PTR 0     ; TOS 
21c0 2a e5 e9			ld hl,(cli_data_sp) 
21c3 11 00 00			ld de, 0 * 3 
21c6 ed 52			sbc hl, de 
21c8				endm 
# End of macro FORTH_DSP_PTR
21c8 cd 09 1e			call hltostack1 
21cb			  
21cb				FORTH_DSP_PTR 1     ; TOS 
21cb 2a e5 e9			ld hl,(cli_data_sp) 
21ce 11 03 00			ld de, 1 * 3 
21d1 ed 52			sbc hl, de 
21d3				endm 
# End of macro FORTH_DSP_PTR
21d3 cd 0f 1e			call hltostack2 
21d6			 
21d6				FORTH_DSP_PTR 0     ; TOS 
21d6 2a e5 e9			ld hl,(cli_data_sp) 
21d9 11 00 00			ld de, 0 * 3 
21dc ed 52			sbc hl, de 
21de				endm 
# End of macro FORTH_DSP_PTR
21de cd 27 1e			call hlfromstack2 
21e1			 
21e1				FORTH_DSP_PTR 1     ; TOS 
21e1 2a e5 e9			ld hl,(cli_data_sp) 
21e4 11 03 00			ld de, 1 * 3 
21e7 ed 52			sbc hl, de 
21e9				endm 
# End of macro FORTH_DSP_PTR
21e9 cd 21 1e			call hlfromstack1 
21ec			;	FORTH_DSP_VALUEHL 
21ec			;	push hl     ; w2 
21ec			; 
21ec			;	FORTH_DSP_POP 
21ec			; 
21ec			;	FORTH_DSP_VALUEHL 
21ec			; 
21ec			;	FORTH_DSP_POP 
21ec			; 
21ec			;	pop de     ; w2	, hl = w1 
21ec			; 
21ec			;	ex de, hl 
21ec			;	push de 
21ec			; 
21ec			;	call forth_push_numhl 
21ec			; 
21ec			;	pop hl 
21ec			; 
21ec			;	call forth_push_numhl 
21ec				 
21ec			 
21ec				NEXTW 
21ec cd 6c ee			call parse_vector 
21ef c3 b9 1e			jp macro_next 
21f2				endm 
# End of macro NEXTW
21f2			.COLN: 
21f2			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21f2 19				db WORD_SYS_CORE+OPCODE_COLN             
21f3 7d 23			dw .SCOLN            
21f5 02				db 1 + 1 
21f6 .. 00			db ":",0              
21f8				endm 
# End of macro CWHEAD
21f8			; | : ( -- )         Create new word | DONE 
21f8			 
21f8				if DEBUG_FORTH_WORDS_KEY 
21f8					DMARK "CLN" 
21f8 f5				push af  
21f9 3a 0d 22			ld a, (.dmark)  
21fc 32 62 ee			ld (debug_mark),a  
21ff 3a 0e 22			ld a, (.dmark+1)  
2202 32 63 ee			ld (debug_mark+1),a  
2205 3a 0f 22			ld a, (.dmark+2)  
2208 32 64 ee			ld (debug_mark+2),a  
220b 18 03			jr .pastdmark  
220d ..			.dmark: db "CLN"  
2210 f1			.pastdmark: pop af  
2211			endm  
# End of macro DMARK
2211					CALLMONITOR 
2211 cd 6f ee			call debug_vector  
2214				endm  
# End of macro CALLMONITOR
2214				endif 
2214			STACKFRAME OFF $8efe $989f 
2214				if DEBUG_STACK_IMB 
2214					if OFF 
2214						exx 
2214						ld de, $8efe 
2214						ld a, d 
2214						ld hl, curframe 
2214						call hexout 
2214						ld a, e 
2214						ld hl, curframe+2 
2214						call hexout 
2214						ld hl, $8efe 
2214						push hl 
2214						ld hl, $989f 
2214						push hl 
2214						exx 
2214					endif 
2214				endif 
2214			endm 
# End of macro STACKFRAME
2214			; get parser buffer length  of new word 
2214			 
2214			 
2214			 
2214				; move tok past this to start of name defintition 
2214				; TODO get word to define 
2214				; TODO Move past word token 
2214				; TODO get length of string up to the ';' 
2214			 
2214 2a b9 e5		ld hl, (os_tok_ptr) 
2217 23			inc hl 
2218 23			inc hl 
2219			 
2219 3e 3b		ld a, ';' 
221b cd 44 11		call strlent 
221e			 
221e 7d			ld a,l 
221f 32 a8 e2		ld (os_new_parse_len), a 
2222			 
2222			 
2222			if DEBUG_FORTH_UWORD 
2222 ed 5b b9 e5	ld de, (os_tok_ptr) 
2226					DMARK ":01" 
2226 f5				push af  
2227 3a 3b 22			ld a, (.dmark)  
222a 32 62 ee			ld (debug_mark),a  
222d 3a 3c 22			ld a, (.dmark+1)  
2230 32 63 ee			ld (debug_mark+1),a  
2233 3a 3d 22			ld a, (.dmark+2)  
2236 32 64 ee			ld (debug_mark+2),a  
2239 18 03			jr .pastdmark  
223b ..			.dmark: db ":01"  
223e f1			.pastdmark: pop af  
223f			endm  
# End of macro DMARK
223f			CALLMONITOR 
223f cd 6f ee			call debug_vector  
2242				endm  
# End of macro CALLMONITOR
2242			endif 
2242			 
2242			; 
2242			;  new word memory layout: 
2242			;  
2242			;    : adg 6666 ;  
2242			; 
2242			;    db   1     ; user defined word  
2242 23			inc hl    
2243			;    dw   sysdict 
2243 23			inc hl 
2244 23			inc hl 
2245			;    db <word len>+1 (for null) 
2245 23			inc hl 
2246			;    db .... <word> 
2246			; 
2246			 
2246 23			inc hl    ; some extras for the word preamble before the above 
2247 23			inc hl 
2248 23			inc hl 
2249 23			inc hl 
224a 23			inc hl 
224b 23			inc hl 
224c 23			inc hl  
224d 23			inc hl 
224e 23			inc hl 
224f 23			inc hl 
2250 23			inc hl 
2251 23			inc hl 
2252 23			inc hl 
2253 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2254			;       exec word buffer 
2254			;	<ptr word>   
2254 23			inc hl 
2255 23			inc hl 
2256			;       <word list><null term> 7F final term 
2256			 
2256			 
2256			if DEBUG_FORTH_UWORD 
2256					DMARK ":02" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 62 ee			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 63 ee			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 64 ee			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db ":02"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f			CALLMONITOR 
226f cd 6f ee			call debug_vector  
2272				endm  
# End of macro CALLMONITOR
2272			endif 
2272			 
2272			 
2272				; malloc the size 
2272			 
2272 cd ad 11			call malloc 
2275 22 aa e2			ld (os_new_malloc), hl     ; save malloc start 
2278			 
2278			;    db   1     ; user defined word  
2278			;	ld a, WORD_SYS_UWORD  
2278 36 01			ld (hl), WORD_SYS_UWORD 
227a			 
227a 23			inc hl    
227b			;    dw   sysdict 
227b 11 f2 1f		ld de, sysdict       ; continue on with the scan to the system dict 
227e 73			ld (hl), e 
227f 23			inc hl 
2280 72			ld (hl), d 
2281 23			inc hl 
2282			 
2282			 
2282			;    Setup dict word 
2282			 
2282 23			inc hl 
2283 22 a4 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2286			 
2286			; 1. get length of dict word 
2286			 
2286			 
2286 2a b9 e5		ld hl, (os_tok_ptr) 
2289 23			inc hl 
228a 23			inc hl    ; position to start of dict word 
228b 3e 00		ld a, 0 
228d cd 44 11		call strlent 
2290			 
2290			 
2290 23			inc hl    ; to include null??? 
2291			 
2291			; write length of dict word 
2291			 
2291 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2295 1b			dec de 
2296 eb			ex de, hl 
2297 73			ld (hl), e 
2298 eb			ex de, hl 
2299			 
2299			 
2299			 
2299			; copy  
2299 4d			ld c, l 
229a 06 00		ld b, 0 
229c ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22a0 2a b9 e5		ld hl, (os_tok_ptr) 
22a3 23			inc hl 
22a4 23			inc hl    ; position to start of dict word 
22a5			 
22a5			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22a5			 
22a5			; TODO need to convert word to upper case 
22a5			 
22a5			ucasetok:	 
22a5 7e			ld a,(hl) 
22a6 cd 30 11		call toUpper 
22a9 77			ld (hl),a 
22aa ed a0		ldi 
22ac f2 a5 22		jp p, ucasetok 
22af			 
22af			 
22af			 
22af			; de now points to start of where the word body code should be placed 
22af ed 53 a4 e2	ld (os_new_work_ptr), de 
22b3			; hl now points to the words to throw at forthexec which needs to be copied 
22b3 22 a2 e2		ld (os_new_src_ptr), hl 
22b6			 
22b6			; TODO add 'call to forthexec' 
22b6			 
22b6			if DEBUG_FORTH_UWORD 
22b6 c5			push bc 
22b7 ed 4b aa e2	ld bc, (os_new_malloc) 
22bb					DMARK ":0x" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 62 ee			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 63 ee			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 64 ee			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db ":0x"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4			CALLMONITOR 
22d4 cd 6f ee			call debug_vector  
22d7				endm  
# End of macro CALLMONITOR
22d7 c1			pop bc 
22d8			endif 
22d8			 
22d8			 
22d8			; create word preamble which should be: 
22d8			 
22d8			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
22d8			 
22d8			;    ld hl, <word code> 
22d8			;    jp user_exec 
22d8			;    <word code bytes> 
22d8			 
22d8			 
22d8			;	inc de     ; TODO ??? or are we already past the word's null 
22d8 eb			ex de, hl 
22d9			 
22d9 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22db			 
22db 23			inc hl 
22dc 22 9e e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22df 23			inc hl 
22e0			 
22e0 23			inc hl 
22e1 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22e3			 
22e3 01 55 53		ld bc, user_exec 
22e6 23			inc hl 
22e7 71			ld (hl), c     ; poke address of user_exec 
22e8 23			inc hl 
22e9 70			ld (hl), b     
22ea			; 
22ea			;	inc hl 
22ea			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22ea			; 
22ea			; 
22ea			;	ld bc, macro_forth_rsp_next 
22ea			;	inc hl 
22ea			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22ea			;	inc hl 
22ea			;	ld (hl), b     
22ea			; 
22ea			;	inc hl 
22ea			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22ea			; 
22ea			; 
22ea			;	inc hl 
22ea			;	ld bc, forthexec 
22ea			;	ld (hl), c     ; poke address of forthexec 
22ea			;	inc hl 
22ea			;	ld (hl), b      
22ea			; 
22ea			;	inc hl 
22ea			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22ea			; 
22ea			;	ld bc, user_dict_next 
22ea			;	inc hl 
22ea			;	ld (hl), c     ; poke address of forthexec 
22ea			;	inc hl 
22ea			;	ld (hl), b      
22ea			 
22ea			; hl is now where we need to copy the word byte data to save this 
22ea			 
22ea 23			inc hl 
22eb 22 a0 e2		ld (os_new_exec), hl 
22ee			 
22ee			; copy definition 
22ee			 
22ee eb			ex de, hl 
22ef			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22ef			;	inc de    ; skip the PC for this parse 
22ef 3a a8 e2		ld a, (os_new_parse_len) 
22f2 4f			ld c, a 
22f3 06 00		ld b, 0 
22f5 ed b0		ldir		 ; copy defintion 
22f7			 
22f7			 
22f7			; poke the address of where the new word bytes live for forthexec 
22f7			 
22f7 2a 9e e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22fa			 
22fa ed 5b a0 e2	ld de, (os_new_exec)      
22fe			 
22fe 73			ld (hl), e 
22ff 23			inc hl 
2300 72			ld (hl), d 
2301			 
2301				; TODO copy last user dict word next link to this word 
2301				; TODO update last user dict word to point to this word 
2301			; 
2301			; hl f923 de 812a ; bc 811a 
2301			 
2301			if DEBUG_FORTH_UWORD 
2301 c5			push bc 
2302 ed 4b aa e2	ld bc, (os_new_malloc) 
2306					DMARK ":0A" 
2306 f5				push af  
2307 3a 1b 23			ld a, (.dmark)  
230a 32 62 ee			ld (debug_mark),a  
230d 3a 1c 23			ld a, (.dmark+1)  
2310 32 63 ee			ld (debug_mark+1),a  
2313 3a 1d 23			ld a, (.dmark+2)  
2316 32 64 ee			ld (debug_mark+2),a  
2319 18 03			jr .pastdmark  
231b ..			.dmark: db ":0A"  
231e f1			.pastdmark: pop af  
231f			endm  
# End of macro DMARK
231f			CALLMONITOR 
231f cd 6f ee			call debug_vector  
2322				endm  
# End of macro CALLMONITOR
2322 c1			pop bc 
2323			endif 
2323			if DEBUG_FORTH_UWORD 
2323 c5			push bc 
2324 ed 4b aa e2	ld bc, (os_new_malloc) 
2328 03			inc bc 
2329 03			inc bc 
232a 03			inc bc 
232b 03			inc bc 
232c 03			inc bc 
232d 03			inc bc 
232e 03			inc bc 
232f 03			inc bc 
2330			 
2330					DMARK ":0B" 
2330 f5				push af  
2331 3a 45 23			ld a, (.dmark)  
2334 32 62 ee			ld (debug_mark),a  
2337 3a 46 23			ld a, (.dmark+1)  
233a 32 63 ee			ld (debug_mark+1),a  
233d 3a 47 23			ld a, (.dmark+2)  
2340 32 64 ee			ld (debug_mark+2),a  
2343 18 03			jr .pastdmark  
2345 ..			.dmark: db ":0B"  
2348 f1			.pastdmark: pop af  
2349			endm  
# End of macro DMARK
2349			CALLMONITOR 
2349 cd 6f ee			call debug_vector  
234c				endm  
# End of macro CALLMONITOR
234c c1			pop bc 
234d			endif 
234d			 
234d			; update word dict linked list for new word 
234d			 
234d			 
234d 2a b5 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2350 23			inc hl     ; move to next work linked list ptr 
2351			 
2351 ed 5b aa e2	ld de, (os_new_malloc)		 ; new next word 
2355 73			ld (hl), e 
2356 23			inc hl 
2357 72			ld (hl), d 
2358			 
2358			if DEBUG_FORTH_UWORD 
2358 ed 4b b5 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
235c			endif 
235c			 
235c ed 53 b5 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2360			 
2360			 
2360			if DEBUG_FORTH_UWORD 
2360					DMARK ":0+" 
2360 f5				push af  
2361 3a 75 23			ld a, (.dmark)  
2364 32 62 ee			ld (debug_mark),a  
2367 3a 76 23			ld a, (.dmark+1)  
236a 32 63 ee			ld (debug_mark+1),a  
236d 3a 77 23			ld a, (.dmark+2)  
2370 32 64 ee			ld (debug_mark+2),a  
2373 18 03			jr .pastdmark  
2375 ..			.dmark: db ":0+"  
2378 f1			.pastdmark: pop af  
2379			endm  
# End of macro DMARK
2379			CALLMONITOR 
2379 cd 6f ee			call debug_vector  
237c				endm  
# End of macro CALLMONITOR
237c			endif 
237c			 
237c			STACKFRAMECHK OFF $8efe $989f 
237c				if DEBUG_STACK_IMB 
237c					if OFF 
237c						exx 
237c						ld hl, $989f 
237c						pop de   ; $989f 
237c						call cmp16 
237c						jr nz, .spnosame 
237c						ld hl, $8efe 
237c						pop de   ; $8efe 
237c						call cmp16 
237c						jr z, .spfrsame 
237c						.spnosame: call showsperror 
237c						.spfrsame: nop 
237c						exx 
237c					endif 
237c				endif 
237c			endm 
# End of macro STACKFRAMECHK
237c			 
237c c9			ret    ; dont process any remaining parser tokens as they form new word 
237d			 
237d			 
237d			 
237d			 
237d			;		NEXT 
237d			.SCOLN: 
237d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
237d 06			db OPCODE_SCOLN 
237e cc 23		dw .DROP 
2380 02			db 2 
2381 .. 00		db ";",0           
2383			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2383				if DEBUG_FORTH_WORDS_KEY 
2383					DMARK "SCN" 
2383 f5				push af  
2384 3a 98 23			ld a, (.dmark)  
2387 32 62 ee			ld (debug_mark),a  
238a 3a 99 23			ld a, (.dmark+1)  
238d 32 63 ee			ld (debug_mark+1),a  
2390 3a 9a 23			ld a, (.dmark+2)  
2393 32 64 ee			ld (debug_mark+2),a  
2396 18 03			jr .pastdmark  
2398 ..			.dmark: db "SCN"  
239b f1			.pastdmark: pop af  
239c			endm  
# End of macro DMARK
239c					CALLMONITOR 
239c cd 6f ee			call debug_vector  
239f				endm  
# End of macro CALLMONITOR
239f				endif 
239f				FORTH_RSP_TOS 
239f cd 94 1a			call macro_forth_rsp_tos 
23a2				endm 
# End of macro FORTH_RSP_TOS
23a2 e5				push hl 
23a3				FORTH_RSP_POP 
23a3 cd 9e 1a			call macro_forth_rsp_pop 
23a6				endm 
# End of macro FORTH_RSP_POP
23a6 e1				pop hl 
23a7			;		ex de,hl 
23a7 22 b9 e5			ld (os_tok_ptr),hl 
23aa			 
23aa			if DEBUG_FORTH_UWORD 
23aa					DMARK "SCL" 
23aa f5				push af  
23ab 3a bf 23			ld a, (.dmark)  
23ae 32 62 ee			ld (debug_mark),a  
23b1 3a c0 23			ld a, (.dmark+1)  
23b4 32 63 ee			ld (debug_mark+1),a  
23b7 3a c1 23			ld a, (.dmark+2)  
23ba 32 64 ee			ld (debug_mark+2),a  
23bd 18 03			jr .pastdmark  
23bf ..			.dmark: db "SCL"  
23c2 f1			.pastdmark: pop af  
23c3			endm  
# End of macro DMARK
23c3			CALLMONITOR 
23c3 cd 6f ee			call debug_vector  
23c6				endm  
# End of macro CALLMONITOR
23c6			endif 
23c6				NEXTW 
23c6 cd 6c ee			call parse_vector 
23c9 c3 b9 1e			jp macro_next 
23cc				endm 
# End of macro NEXTW
23cc			 
23cc			.DROP: 
23cc			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23cc 1b				db WORD_SYS_CORE+OPCODE_DROP             
23cd fa 23			dw .DUP2            
23cf 05				db 4 + 1 
23d0 .. 00			db "DROP",0              
23d5				endm 
# End of macro CWHEAD
23d5			; | DROP ( w -- )   drop the TOS item   | DONE 
23d5				if DEBUG_FORTH_WORDS_KEY 
23d5					DMARK "DRP" 
23d5 f5				push af  
23d6 3a ea 23			ld a, (.dmark)  
23d9 32 62 ee			ld (debug_mark),a  
23dc 3a eb 23			ld a, (.dmark+1)  
23df 32 63 ee			ld (debug_mark+1),a  
23e2 3a ec 23			ld a, (.dmark+2)  
23e5 32 64 ee			ld (debug_mark+2),a  
23e8 18 03			jr .pastdmark  
23ea ..			.dmark: db "DRP"  
23ed f1			.pastdmark: pop af  
23ee			endm  
# End of macro DMARK
23ee					CALLMONITOR 
23ee cd 6f ee			call debug_vector  
23f1				endm  
# End of macro CALLMONITOR
23f1				endif 
23f1				FORTH_DSP_POP 
23f1 cd 8a 1d			call macro_forth_dsp_pop 
23f4				endm 
# End of macro FORTH_DSP_POP
23f4				NEXTW 
23f4 cd 6c ee			call parse_vector 
23f7 c3 b9 1e			jp macro_next 
23fa				endm 
# End of macro NEXTW
23fa			.DUP2: 
23fa			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23fa 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23fb 42 24			dw .DROP2            
23fd 05				db 4 + 1 
23fe .. 00			db "2DUP",0              
2403				endm 
# End of macro CWHEAD
2403			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2403			; | | >[!NOTE] 
2403			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
2403				if DEBUG_FORTH_WORDS_KEY 
2403					DMARK "2DU" 
2403 f5				push af  
2404 3a 18 24			ld a, (.dmark)  
2407 32 62 ee			ld (debug_mark),a  
240a 3a 19 24			ld a, (.dmark+1)  
240d 32 63 ee			ld (debug_mark+1),a  
2410 3a 1a 24			ld a, (.dmark+2)  
2413 32 64 ee			ld (debug_mark+2),a  
2416 18 03			jr .pastdmark  
2418 ..			.dmark: db "2DU"  
241b f1			.pastdmark: pop af  
241c			endm  
# End of macro DMARK
241c					CALLMONITOR 
241c cd 6f ee			call debug_vector  
241f				endm  
# End of macro CALLMONITOR
241f				endif 
241f				FORTH_DSP_VALUEHL 
241f cd d2 1c			call macro_dsp_valuehl 
2422				endm 
# End of macro FORTH_DSP_VALUEHL
2422 e5				push hl      ; 2 
2423			 
2423				FORTH_DSP_POP 
2423 cd 8a 1d			call macro_forth_dsp_pop 
2426				endm 
# End of macro FORTH_DSP_POP
2426				 
2426				FORTH_DSP_VALUEHL 
2426 cd d2 1c			call macro_dsp_valuehl 
2429				endm 
# End of macro FORTH_DSP_VALUEHL
2429			;		push hl      ; 1 
2429			 
2429				FORTH_DSP_POP 
2429 cd 8a 1d			call macro_forth_dsp_pop 
242c				endm 
# End of macro FORTH_DSP_POP
242c			 
242c			;		pop hl       ; 1 
242c d1				pop de       ; 2 
242d			 
242d cd d6 1a			call forth_push_numhl 
2430 eb				ex de, hl 
2431 cd d6 1a			call forth_push_numhl 
2434			 
2434				 
2434 eb				ex de, hl 
2435			 
2435 cd d6 1a			call forth_push_numhl 
2438 eb				ex de, hl 
2439 cd d6 1a			call forth_push_numhl 
243c			 
243c			 
243c				NEXTW 
243c cd 6c ee			call parse_vector 
243f c3 b9 1e			jp macro_next 
2442				endm 
# End of macro NEXTW
2442			.DROP2: 
2442			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2442 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2443 74 24			dw .PICK            
2445 06				db 5 + 1 
2446 .. 00			db "2DROP",0              
244c				endm 
# End of macro CWHEAD
244c			; | 2DROP ( w w -- )    Double drop | DONE 
244c				if DEBUG_FORTH_WORDS_KEY 
244c					DMARK "2DR" 
244c f5				push af  
244d 3a 61 24			ld a, (.dmark)  
2450 32 62 ee			ld (debug_mark),a  
2453 3a 62 24			ld a, (.dmark+1)  
2456 32 63 ee			ld (debug_mark+1),a  
2459 3a 63 24			ld a, (.dmark+2)  
245c 32 64 ee			ld (debug_mark+2),a  
245f 18 03			jr .pastdmark  
2461 ..			.dmark: db "2DR"  
2464 f1			.pastdmark: pop af  
2465			endm  
# End of macro DMARK
2465					CALLMONITOR 
2465 cd 6f ee			call debug_vector  
2468				endm  
# End of macro CALLMONITOR
2468				endif 
2468				FORTH_DSP_POP 
2468 cd 8a 1d			call macro_forth_dsp_pop 
246b				endm 
# End of macro FORTH_DSP_POP
246b				FORTH_DSP_POP 
246b cd 8a 1d			call macro_forth_dsp_pop 
246e				endm 
# End of macro FORTH_DSP_POP
246e				NEXTW 
246e cd 6c ee			call parse_vector 
2471 c3 b9 1e			jp macro_next 
2474				endm 
# End of macro NEXTW
2474			.PICK: 
2474			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2474 77				db WORD_SYS_CORE+99             
2475 11 25			dw .SWAP2            
2477 05				db 4 + 1 
2478 .. 00			db "PICK",0              
247d				endm 
# End of macro CWHEAD
247d			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
247d			; | | >[!NOTE] 
247d			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
247d				if DEBUG_FORTH_WORDS_KEY 
247d					DMARK "PIK" 
247d f5				push af  
247e 3a 92 24			ld a, (.dmark)  
2481 32 62 ee			ld (debug_mark),a  
2484 3a 93 24			ld a, (.dmark+1)  
2487 32 63 ee			ld (debug_mark+1),a  
248a 3a 94 24			ld a, (.dmark+2)  
248d 32 64 ee			ld (debug_mark+2),a  
2490 18 03			jr .pastdmark  
2492 ..			.dmark: db "PIK"  
2495 f1			.pastdmark: pop af  
2496			endm  
# End of macro DMARK
2496					CALLMONITOR 
2496 cd 6f ee			call debug_vector  
2499				endm  
# End of macro CALLMONITOR
2499				endif 
2499			 
2499				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2499 cd d2 1c			call macro_dsp_valuehl 
249c				endm 
# End of macro FORTH_DSP_VALUEHL
249c				 
249c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
249c cd 8a 1d			call macro_forth_dsp_pop 
249f				endm 
# End of macro FORTH_DSP_POP
249f			 
249f				; init from TOS 
249f e5				push hl 
24a0				FORTH_DSP 
24a0 cd 98 1c			call macro_forth_dsp 
24a3				endm 
# End of macro FORTH_DSP
24a3			;	ld hl, cli_data_sp 
24a3				if DEBUG_FORTH_WORDS 
24a3					DMARK "PK1" 
24a3 f5				push af  
24a4 3a b8 24			ld a, (.dmark)  
24a7 32 62 ee			ld (debug_mark),a  
24aa 3a b9 24			ld a, (.dmark+1)  
24ad 32 63 ee			ld (debug_mark+1),a  
24b0 3a ba 24			ld a, (.dmark+2)  
24b3 32 64 ee			ld (debug_mark+2),a  
24b6 18 03			jr .pastdmark  
24b8 ..			.dmark: db "PK1"  
24bb f1			.pastdmark: pop af  
24bc			endm  
# End of macro DMARK
24bc					CALLMONITOR 
24bc cd 6f ee			call debug_vector  
24bf				endm  
# End of macro CALLMONITOR
24bf				endif 
24bf c1				pop bc 
24c0 41				ld b,c 
24c1 3e 00			ld a, 0 
24c3 b8				cp b 
24c4 28 21			jr z, .pdone	 
24c6			.pkl: 
24c6 2b				dec hl 
24c7 2b				dec hl 
24c8 2b				dec hl 
24c9			 
24c9				if DEBUG_FORTH_WORDS 
24c9					DMARK "PKl" 
24c9 f5				push af  
24ca 3a de 24			ld a, (.dmark)  
24cd 32 62 ee			ld (debug_mark),a  
24d0 3a df 24			ld a, (.dmark+1)  
24d3 32 63 ee			ld (debug_mark+1),a  
24d6 3a e0 24			ld a, (.dmark+2)  
24d9 32 64 ee			ld (debug_mark+2),a  
24dc 18 03			jr .pastdmark  
24de ..			.dmark: db "PKl"  
24e1 f1			.pastdmark: pop af  
24e2			endm  
# End of macro DMARK
24e2					CALLMONITOR 
24e2 cd 6f ee			call debug_vector  
24e5				endm  
# End of macro CALLMONITOR
24e5				endif 
24e5 10 df			djnz .pkl 
24e7			.pdone: 
24e7				 
24e7				; TODO do type check with correct push 
24e7			 
24e7 23				inc hl 
24e8				;call loadwordinhl 
24e8 5e				ld e, (hl) 
24e9 23				inc hl 
24ea 56				ld d, (hl) 
24eb eb				ex de,hl 
24ec				if DEBUG_FORTH_WORDS 
24ec					DMARK "PKp" 
24ec f5				push af  
24ed 3a 01 25			ld a, (.dmark)  
24f0 32 62 ee			ld (debug_mark),a  
24f3 3a 02 25			ld a, (.dmark+1)  
24f6 32 63 ee			ld (debug_mark+1),a  
24f9 3a 03 25			ld a, (.dmark+2)  
24fc 32 64 ee			ld (debug_mark+2),a  
24ff 18 03			jr .pastdmark  
2501 ..			.dmark: db "PKp"  
2504 f1			.pastdmark: pop af  
2505			endm  
# End of macro DMARK
2505					CALLMONITOR 
2505 cd 6f ee			call debug_vector  
2508				endm  
# End of macro CALLMONITOR
2508				endif 
2508 cd d6 1a			call forth_push_numhl 
250b			 
250b				NEXTW 
250b cd 6c ee			call parse_vector 
250e c3 b9 1e			jp macro_next 
2511				endm 
# End of macro NEXTW
2511			.SWAP2: 
2511			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2511 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2512 95 25			dw .AT            
2514 06				db 5 + 1 
2515 .. 00			db "2SWAP",0              
251b				endm 
# End of macro CWHEAD
251b			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
251b				if DEBUG_FORTH_WORDS_KEY 
251b					DMARK "2SW" 
251b f5				push af  
251c 3a 30 25			ld a, (.dmark)  
251f 32 62 ee			ld (debug_mark),a  
2522 3a 31 25			ld a, (.dmark+1)  
2525 32 63 ee			ld (debug_mark+1),a  
2528 3a 32 25			ld a, (.dmark+2)  
252b 32 64 ee			ld (debug_mark+2),a  
252e 18 03			jr .pastdmark  
2530 ..			.dmark: db "2SW"  
2533 f1			.pastdmark: pop af  
2534			endm  
# End of macro DMARK
2534					CALLMONITOR 
2534 cd 6f ee			call debug_vector  
2537				endm  
# End of macro CALLMONITOR
2537				endif 
2537			; TODO Use os stack swap memory 
2537			 
2537				FORTH_DSP_PTR 0     ; TOS    w4 
2537 2a e5 e9			ld hl,(cli_data_sp) 
253a 11 00 00			ld de, 0 * 3 
253d ed 52			sbc hl, de 
253f				endm 
# End of macro FORTH_DSP_PTR
253f cd 09 1e			call hltostack1 
2542			  
2542				FORTH_DSP_PTR 1     ; TOS    w3 
2542 2a e5 e9			ld hl,(cli_data_sp) 
2545 11 03 00			ld de, 1 * 3 
2548 ed 52			sbc hl, de 
254a				endm 
# End of macro FORTH_DSP_PTR
254a cd 0f 1e			call hltostack2 
254d			 
254d			 
254d			 
254d				FORTH_DSP_PTR 2     ; TOS    w2 
254d 2a e5 e9			ld hl,(cli_data_sp) 
2550 11 06 00			ld de, 2 * 3 
2553 ed 52			sbc hl, de 
2555				endm 
# End of macro FORTH_DSP_PTR
2555 cd 15 1e			call hltostack3 
2558			 
2558				FORTH_DSP_PTR 3     ; TOS   w1 
2558 2a e5 e9			ld hl,(cli_data_sp) 
255b 11 09 00			ld de, 3 * 3 
255e ed 52			sbc hl, de 
2560				endm 
# End of macro FORTH_DSP_PTR
2560 cd 1b 1e			call hltostack4 
2563			 
2563			 
2563			 
2563			 
2563				FORTH_DSP_PTR 0     ; TOS 
2563 2a e5 e9			ld hl,(cli_data_sp) 
2566 11 00 00			ld de, 0 * 3 
2569 ed 52			sbc hl, de 
256b				endm 
# End of macro FORTH_DSP_PTR
256b cd 2d 1e			call hlfromstack3 
256e			 
256e				FORTH_DSP_PTR 1     ; TOS 
256e 2a e5 e9			ld hl,(cli_data_sp) 
2571 11 03 00			ld de, 1 * 3 
2574 ed 52			sbc hl, de 
2576				endm 
# End of macro FORTH_DSP_PTR
2576 cd 33 1e			call hlfromstack4 
2579			 
2579			 
2579			 
2579				FORTH_DSP_PTR 2     ; TOS 
2579 2a e5 e9			ld hl,(cli_data_sp) 
257c 11 06 00			ld de, 2 * 3 
257f ed 52			sbc hl, de 
2581				endm 
# End of macro FORTH_DSP_PTR
2581 cd 21 1e			call hlfromstack1 
2584			 
2584				FORTH_DSP_PTR 3     ; TOS 
2584 2a e5 e9			ld hl,(cli_data_sp) 
2587 11 09 00			ld de, 3 * 3 
258a ed 52			sbc hl, de 
258c				endm 
# End of macro FORTH_DSP_PTR
258c cd 27 1e			call hlfromstack2 
258f			 
258f				NEXTW 
258f cd 6c ee			call parse_vector 
2592 c3 b9 1e			jp macro_next 
2595				endm 
# End of macro NEXTW
2595			.AT: 
2595			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2595 1f				db WORD_SYS_CORE+OPCODE_AT             
2596 ca 25			dw .CAT            
2598 02				db 1 + 1 
2599 .. 00			db "@",0              
259b				endm 
# End of macro CWHEAD
259b			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
259b			 
259b				if DEBUG_FORTH_WORDS_KEY 
259b					DMARK "AT." 
259b f5				push af  
259c 3a b0 25			ld a, (.dmark)  
259f 32 62 ee			ld (debug_mark),a  
25a2 3a b1 25			ld a, (.dmark+1)  
25a5 32 63 ee			ld (debug_mark+1),a  
25a8 3a b2 25			ld a, (.dmark+2)  
25ab 32 64 ee			ld (debug_mark+2),a  
25ae 18 03			jr .pastdmark  
25b0 ..			.dmark: db "AT."  
25b3 f1			.pastdmark: pop af  
25b4			endm  
# End of macro DMARK
25b4					CALLMONITOR 
25b4 cd 6f ee			call debug_vector  
25b7				endm  
# End of macro CALLMONITOR
25b7				endif 
25b7			.getbyteat:	 
25b7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b7 cd d2 1c			call macro_dsp_valuehl 
25ba				endm 
# End of macro FORTH_DSP_VALUEHL
25ba				 
25ba			;		push hl 
25ba			 
25ba				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ba cd 8a 1d			call macro_forth_dsp_pop 
25bd				endm 
# End of macro FORTH_DSP_POP
25bd			 
25bd			;		pop hl 
25bd			 
25bd 7e				ld a, (hl) 
25be			 
25be 6f				ld l, a 
25bf 26 00			ld h, 0 
25c1 cd d6 1a			call forth_push_numhl 
25c4			 
25c4				NEXTW 
25c4 cd 6c ee			call parse_vector 
25c7 c3 b9 1e			jp macro_next 
25ca				endm 
# End of macro NEXTW
25ca			.CAT: 
25ca			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25ca 20				db WORD_SYS_CORE+OPCODE_CAT             
25cb f6 25			dw .BANG            
25cd 03				db 2 + 1 
25ce .. 00			db "C@",0              
25d1				endm 
# End of macro CWHEAD
25d1			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25d1				if DEBUG_FORTH_WORDS_KEY 
25d1					DMARK "CAA" 
25d1 f5				push af  
25d2 3a e6 25			ld a, (.dmark)  
25d5 32 62 ee			ld (debug_mark),a  
25d8 3a e7 25			ld a, (.dmark+1)  
25db 32 63 ee			ld (debug_mark+1),a  
25de 3a e8 25			ld a, (.dmark+2)  
25e1 32 64 ee			ld (debug_mark+2),a  
25e4 18 03			jr .pastdmark  
25e6 ..			.dmark: db "CAA"  
25e9 f1			.pastdmark: pop af  
25ea			endm  
# End of macro DMARK
25ea					CALLMONITOR 
25ea cd 6f ee			call debug_vector  
25ed				endm  
# End of macro CALLMONITOR
25ed				endif 
25ed c3 b7 25			jp .getbyteat 
25f0				NEXTW 
25f0 cd 6c ee			call parse_vector 
25f3 c3 b9 1e			jp macro_next 
25f6				endm 
# End of macro NEXTW
25f6			.BANG: 
25f6			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25f6 21				db WORD_SYS_CORE+OPCODE_BANG             
25f7 2f 26			dw .CBANG            
25f9 02				db 1 + 1 
25fa .. 00			db "!",0              
25fc				endm 
# End of macro CWHEAD
25fc			; | ! ( x w -- ) Store x at address w      | DONE 
25fc				if DEBUG_FORTH_WORDS_KEY 
25fc					DMARK "BNG" 
25fc f5				push af  
25fd 3a 11 26			ld a, (.dmark)  
2600 32 62 ee			ld (debug_mark),a  
2603 3a 12 26			ld a, (.dmark+1)  
2606 32 63 ee			ld (debug_mark+1),a  
2609 3a 13 26			ld a, (.dmark+2)  
260c 32 64 ee			ld (debug_mark+2),a  
260f 18 03			jr .pastdmark  
2611 ..			.dmark: db "BNG"  
2614 f1			.pastdmark: pop af  
2615			endm  
# End of macro DMARK
2615					CALLMONITOR 
2615 cd 6f ee			call debug_vector  
2618				endm  
# End of macro CALLMONITOR
2618				endif 
2618			 
2618			.storebyteat:		 
2618				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2618 cd d2 1c			call macro_dsp_valuehl 
261b				endm 
# End of macro FORTH_DSP_VALUEHL
261b				 
261b e5				push hl 
261c			 
261c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261c cd 8a 1d			call macro_forth_dsp_pop 
261f				endm 
# End of macro FORTH_DSP_POP
261f			 
261f				; get byte to poke 
261f			 
261f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
261f cd d2 1c			call macro_dsp_valuehl 
2622				endm 
# End of macro FORTH_DSP_VALUEHL
2622 e5				push hl 
2623			 
2623			 
2623				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2623 cd 8a 1d			call macro_forth_dsp_pop 
2626				endm 
# End of macro FORTH_DSP_POP
2626			 
2626			 
2626 d1				pop de 
2627 e1				pop hl 
2628			 
2628 73				ld (hl),e 
2629			 
2629			 
2629				NEXTW 
2629 cd 6c ee			call parse_vector 
262c c3 b9 1e			jp macro_next 
262f				endm 
# End of macro NEXTW
262f			.CBANG: 
262f			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
262f 22				db WORD_SYS_CORE+OPCODE_CBANG             
2630 5b 26			dw .SCALL            
2632 03				db 2 + 1 
2633 .. 00			db "C!",0              
2636				endm 
# End of macro CWHEAD
2636			; | C!  ( x w -- ) Store x at address w  | DONE 
2636				if DEBUG_FORTH_WORDS_KEY 
2636					DMARK "CBA" 
2636 f5				push af  
2637 3a 4b 26			ld a, (.dmark)  
263a 32 62 ee			ld (debug_mark),a  
263d 3a 4c 26			ld a, (.dmark+1)  
2640 32 63 ee			ld (debug_mark+1),a  
2643 3a 4d 26			ld a, (.dmark+2)  
2646 32 64 ee			ld (debug_mark+2),a  
2649 18 03			jr .pastdmark  
264b ..			.dmark: db "CBA"  
264e f1			.pastdmark: pop af  
264f			endm  
# End of macro DMARK
264f					CALLMONITOR 
264f cd 6f ee			call debug_vector  
2652				endm  
# End of macro CALLMONITOR
2652				endif 
2652 c3 18 26			jp .storebyteat 
2655				NEXTW 
2655 cd 6c ee			call parse_vector 
2658 c3 b9 1e			jp macro_next 
265b				endm 
# End of macro NEXTW
265b			.SCALL: 
265b			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
265b 23				db WORD_SYS_CORE+OPCODE_SCALL             
265c 92 26			dw .DEPTH            
265e 05				db 4 + 1 
265f .. 00			db "CALL",0              
2664				endm 
# End of macro CWHEAD
2664			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2664				if DEBUG_FORTH_WORDS_KEY 
2664					DMARK "CLL" 
2664 f5				push af  
2665 3a 79 26			ld a, (.dmark)  
2668 32 62 ee			ld (debug_mark),a  
266b 3a 7a 26			ld a, (.dmark+1)  
266e 32 63 ee			ld (debug_mark+1),a  
2671 3a 7b 26			ld a, (.dmark+2)  
2674 32 64 ee			ld (debug_mark+2),a  
2677 18 03			jr .pastdmark  
2679 ..			.dmark: db "CLL"  
267c f1			.pastdmark: pop af  
267d			endm  
# End of macro DMARK
267d					CALLMONITOR 
267d cd 6f ee			call debug_vector  
2680				endm  
# End of macro CALLMONITOR
2680				endif 
2680			 
2680				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2680 cd d2 1c			call macro_dsp_valuehl 
2683				endm 
# End of macro FORTH_DSP_VALUEHL
2683			 
2683			;		push hl 
2683			 
2683				; destroy value TOS 
2683			 
2683				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2683 cd 8a 1d			call macro_forth_dsp_pop 
2686				endm 
# End of macro FORTH_DSP_POP
2686			 
2686					 
2686			;		pop hl 
2686			 
2686				; how to do a call with hl???? save SP? 
2686 cd 5d 1e			call forth_call_hl 
2689			 
2689			 
2689				; TODO push value back onto stack for another op etc 
2689			 
2689 cd d6 1a			call forth_push_numhl 
268c				NEXTW 
268c cd 6c ee			call parse_vector 
268f c3 b9 1e			jp macro_next 
2692				endm 
# End of macro NEXTW
2692			.DEPTH: 
2692			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2692 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2693 d2 26			dw .OVER            
2695 06				db 5 + 1 
2696 .. 00			db "DEPTH",0              
269c				endm 
# End of macro CWHEAD
269c			; | DEPTH ( -- u ) Push count of stack | DONE 
269c				; take current TOS and remove from base value div by two to get count 
269c				if DEBUG_FORTH_WORDS_KEY 
269c					DMARK "DEP" 
269c f5				push af  
269d 3a b1 26			ld a, (.dmark)  
26a0 32 62 ee			ld (debug_mark),a  
26a3 3a b2 26			ld a, (.dmark+1)  
26a6 32 63 ee			ld (debug_mark+1),a  
26a9 3a b3 26			ld a, (.dmark+2)  
26ac 32 64 ee			ld (debug_mark+2),a  
26af 18 03			jr .pastdmark  
26b1 ..			.dmark: db "DEP"  
26b4 f1			.pastdmark: pop af  
26b5			endm  
# End of macro DMARK
26b5					CALLMONITOR 
26b5 cd 6f ee			call debug_vector  
26b8				endm  
# End of macro CALLMONITOR
26b8				endif 
26b8			 
26b8			 
26b8 2a e5 e9		ld hl, (cli_data_sp) 
26bb 11 1f e8		ld de, cli_data_stack 
26be ed 52		sbc hl,de 
26c0			 
26c0			; div by size of stack item 
26c0			 
26c0 5d			ld e,l 
26c1 0e 03		ld c, 3 
26c3 cd 71 0d		call Div8 
26c6			 
26c6 6f			ld l,a 
26c7 26 00		ld h,0 
26c9			 
26c9			;srl h 
26c9			;rr l 
26c9			 
26c9 cd d6 1a			call forth_push_numhl 
26cc				NEXTW 
26cc cd 6c ee			call parse_vector 
26cf c3 b9 1e			jp macro_next 
26d2				endm 
# End of macro NEXTW
26d2			.OVER: 
26d2			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26d2 42				db WORD_SYS_CORE+46             
26d3 22 27			dw .PAUSE            
26d5 05				db 4 + 1 
26d6 .. 00			db "OVER",0              
26db				endm 
# End of macro CWHEAD
26db			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26db			; | | >[!NOTE] 
26db			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
26db				if DEBUG_FORTH_WORDS_KEY 
26db					DMARK "OVR" 
26db f5				push af  
26dc 3a f0 26			ld a, (.dmark)  
26df 32 62 ee			ld (debug_mark),a  
26e2 3a f1 26			ld a, (.dmark+1)  
26e5 32 63 ee			ld (debug_mark+1),a  
26e8 3a f2 26			ld a, (.dmark+2)  
26eb 32 64 ee			ld (debug_mark+2),a  
26ee 18 03			jr .pastdmark  
26f0 ..			.dmark: db "OVR"  
26f3 f1			.pastdmark: pop af  
26f4			endm  
# End of macro DMARK
26f4					CALLMONITOR 
26f4 cd 6f ee			call debug_vector  
26f7				endm  
# End of macro CALLMONITOR
26f7				endif 
26f7			 
26f7			; TODO Use os stack swap memory 
26f7			 
26f7				; work out what type we are looking at 
26f7			 
26f7				FORTH_DSP_PTR 1 
26f7 2a e5 e9			ld hl,(cli_data_sp) 
26fa 11 03 00			ld de, 1 * 3 
26fd ed 52			sbc hl, de 
26ff				endm 
# End of macro FORTH_DSP_PTR
26ff			 
26ff 7e				ld a, (hl) 
2700				 
2700 f5				push af 
2701				; whatever the type lets get the pointer or word 
2701 23				inc hl 
2702			;; 
2702			 
2702				; type check now to decide on how to push  
2702			 
2702 cd 3f 1e			call loadwordinhl 
2705 f1				pop af 
2706 fe 01			cp DS_TYPE_STR 
2708 28 09			jr z, .ovstr 
270a			 
270a				; we have a numeric so load the word and push 
270a			;	ld e, (hl) 
270a			;	inc hl 
270a			;	ld d, (hl) 
270a			;	ex de, hl 
270a cd d6 1a			call forth_push_numhl 
270d				NEXTW 
270d cd 6c ee			call parse_vector 
2710 c3 b9 1e			jp macro_next 
2713				endm 
# End of macro NEXTW
2713			 
2713			.ovstr: 
2713				; ok, a string so get the pointer and push as a string 
2713			 
2713			;	call loadwordinhl 
2713 cd 40 1b			call forth_push_str 
2716				NEXTW 
2716 cd 6c ee			call parse_vector 
2719 c3 b9 1e			jp macro_next 
271c				endm 
# End of macro NEXTW
271c			 
271c			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
271c			;	push hl    ; n2 
271c			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
271c			; 
271c			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
271c			;	push hl    ; n1 
271c			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
271c			; 
271c			;	pop de     ; n1 
271c			;	pop hl     ; n2 
271c			; 
271c			;	push de 
271c			;	push hl 
271c			;	push de 
271c			 
271c				; push back  
271c			 
271c			;	pop hl 
271c			;	call forth_push_numhl 
271c			;	pop hl 
271c			;	call forth_push_numhl 
271c			;	pop hl 
271c			;	call forth_push_numhl 
271c				NEXTW 
271c cd 6c ee			call parse_vector 
271f c3 b9 1e			jp macro_next 
2722				endm 
# End of macro NEXTW
2722			 
2722			.PAUSE: 
2722			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2722 43				db WORD_SYS_CORE+47             
2723 5a 27			dw .PAUSES            
2725 08				db 7 + 1 
2726 .. 00			db "PAUSEMS",0              
272e				endm 
# End of macro CWHEAD
272e			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
272e				if DEBUG_FORTH_WORDS_KEY 
272e					DMARK "PMS" 
272e f5				push af  
272f 3a 43 27			ld a, (.dmark)  
2732 32 62 ee			ld (debug_mark),a  
2735 3a 44 27			ld a, (.dmark+1)  
2738 32 63 ee			ld (debug_mark+1),a  
273b 3a 45 27			ld a, (.dmark+2)  
273e 32 64 ee			ld (debug_mark+2),a  
2741 18 03			jr .pastdmark  
2743 ..			.dmark: db "PMS"  
2746 f1			.pastdmark: pop af  
2747			endm  
# End of macro DMARK
2747					CALLMONITOR 
2747 cd 6f ee			call debug_vector  
274a				endm  
# End of macro CALLMONITOR
274a				endif 
274a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
274a cd d2 1c			call macro_dsp_valuehl 
274d				endm 
# End of macro FORTH_DSP_VALUEHL
274d			;		push hl    ; n2 
274d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
274d cd 8a 1d			call macro_forth_dsp_pop 
2750				endm 
# End of macro FORTH_DSP_POP
2750			;		pop hl 
2750			 
2750 7d				ld a, l 
2751 cd d5 0a			call aDelayInMS 
2754			       NEXTW 
2754 cd 6c ee			call parse_vector 
2757 c3 b9 1e			jp macro_next 
275a				endm 
# End of macro NEXTW
275a			.PAUSES:  
275a			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
275a 44				db WORD_SYS_CORE+48             
275b cc 27			dw .ROT            
275d 06				db 5 + 1 
275e .. 00			db "PAUSE",0              
2764				endm 
# End of macro CWHEAD
2764			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2764				if DEBUG_FORTH_WORDS_KEY 
2764					DMARK "PAU" 
2764 f5				push af  
2765 3a 79 27			ld a, (.dmark)  
2768 32 62 ee			ld (debug_mark),a  
276b 3a 7a 27			ld a, (.dmark+1)  
276e 32 63 ee			ld (debug_mark+1),a  
2771 3a 7b 27			ld a, (.dmark+2)  
2774 32 64 ee			ld (debug_mark+2),a  
2777 18 03			jr .pastdmark  
2779 ..			.dmark: db "PAU"  
277c f1			.pastdmark: pop af  
277d			endm  
# End of macro DMARK
277d					CALLMONITOR 
277d cd 6f ee			call debug_vector  
2780				endm  
# End of macro CALLMONITOR
2780				endif 
2780				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2780 cd d2 1c			call macro_dsp_valuehl 
2783				endm 
# End of macro FORTH_DSP_VALUEHL
2783			;		push hl    ; n2 
2783				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2783 cd 8a 1d			call macro_forth_dsp_pop 
2786				endm 
# End of macro FORTH_DSP_POP
2786			;		pop hl 
2786 45				ld b, l 
2787				if DEBUG_FORTH_WORDS 
2787					DMARK "PAU" 
2787 f5				push af  
2788 3a 9c 27			ld a, (.dmark)  
278b 32 62 ee			ld (debug_mark),a  
278e 3a 9d 27			ld a, (.dmark+1)  
2791 32 63 ee			ld (debug_mark+1),a  
2794 3a 9e 27			ld a, (.dmark+2)  
2797 32 64 ee			ld (debug_mark+2),a  
279a 18 03			jr .pastdmark  
279c ..			.dmark: db "PAU"  
279f f1			.pastdmark: pop af  
27a0			endm  
# End of macro DMARK
27a0					CALLMONITOR 
27a0 cd 6f ee			call debug_vector  
27a3				endm  
# End of macro CALLMONITOR
27a3				endif 
27a3 c5			.pauses1:	push bc 
27a4 cd f0 0a			call delay1s 
27a7 c1				pop bc 
27a8				if DEBUG_FORTH_WORDS 
27a8					DMARK "PA1" 
27a8 f5				push af  
27a9 3a bd 27			ld a, (.dmark)  
27ac 32 62 ee			ld (debug_mark),a  
27af 3a be 27			ld a, (.dmark+1)  
27b2 32 63 ee			ld (debug_mark+1),a  
27b5 3a bf 27			ld a, (.dmark+2)  
27b8 32 64 ee			ld (debug_mark+2),a  
27bb 18 03			jr .pastdmark  
27bd ..			.dmark: db "PA1"  
27c0 f1			.pastdmark: pop af  
27c1			endm  
# End of macro DMARK
27c1					CALLMONITOR 
27c1 cd 6f ee			call debug_vector  
27c4				endm  
# End of macro CALLMONITOR
27c4				endif 
27c4 10 dd			djnz .pauses1 
27c6			 
27c6			       NEXTW 
27c6 cd 6c ee			call parse_vector 
27c9 c3 b9 1e			jp macro_next 
27cc				endm 
# End of macro NEXTW
27cc			.ROT: 
27cc			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
27cc 45				db WORD_SYS_CORE+49             
27cd 38 28			dw .UWORDS            
27cf 04				db 3 + 1 
27d0 .. 00			db "ROT",0              
27d4				endm 
# End of macro CWHEAD
27d4			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
27d4				if DEBUG_FORTH_WORDS_KEY 
27d4					DMARK "ROT" 
27d4 f5				push af  
27d5 3a e9 27			ld a, (.dmark)  
27d8 32 62 ee			ld (debug_mark),a  
27db 3a ea 27			ld a, (.dmark+1)  
27de 32 63 ee			ld (debug_mark+1),a  
27e1 3a eb 27			ld a, (.dmark+2)  
27e4 32 64 ee			ld (debug_mark+2),a  
27e7 18 03			jr .pastdmark  
27e9 ..			.dmark: db "ROT"  
27ec f1			.pastdmark: pop af  
27ed			endm  
# End of macro DMARK
27ed					CALLMONITOR 
27ed cd 6f ee			call debug_vector  
27f0				endm  
# End of macro CALLMONITOR
27f0				endif 
27f0			 
27f0			; DONE Use os stack swap memory 
27f0			 
27f0				FORTH_DSP_PTR 0     ; u3 
27f0 2a e5 e9			ld hl,(cli_data_sp) 
27f3 11 00 00			ld de, 0 * 3 
27f6 ed 52			sbc hl, de 
27f8				endm 
# End of macro FORTH_DSP_PTR
27f8 cd 09 1e			call hltostack1     
27fb			  
27fb				FORTH_DSP_PTR 1     ; u2 
27fb 2a e5 e9			ld hl,(cli_data_sp) 
27fe 11 03 00			ld de, 1 * 3 
2801 ed 52			sbc hl, de 
2803				endm 
# End of macro FORTH_DSP_PTR
2803 cd 0f 1e			call hltostack2      
2806			 
2806				FORTH_DSP_PTR 2     ; u1 
2806 2a e5 e9			ld hl,(cli_data_sp) 
2809 11 06 00			ld de, 2 * 3 
280c ed 52			sbc hl, de 
280e				endm 
# End of macro FORTH_DSP_PTR
280e cd 15 1e			call hltostack3 
2811			 
2811			 
2811				FORTH_DSP_PTR 0     ;  
2811 2a e5 e9			ld hl,(cli_data_sp) 
2814 11 00 00			ld de, 0 * 3 
2817 ed 52			sbc hl, de 
2819				endm 
# End of macro FORTH_DSP_PTR
2819 cd 2d 1e			call hlfromstack3 
281c			 
281c				FORTH_DSP_PTR 1     ; TOS 
281c 2a e5 e9			ld hl,(cli_data_sp) 
281f 11 03 00			ld de, 1 * 3 
2822 ed 52			sbc hl, de 
2824				endm 
# End of macro FORTH_DSP_PTR
2824 cd 21 1e			call hlfromstack1 
2827			 
2827				FORTH_DSP_PTR 2     ; TOS 
2827 2a e5 e9			ld hl,(cli_data_sp) 
282a 11 06 00			ld de, 2 * 3 
282d ed 52			sbc hl, de 
282f				endm 
# End of macro FORTH_DSP_PTR
282f cd 27 1e			call hlfromstack2 
2832			 
2832			 
2832			;	FORTH_DSP_VALUEHL 
2832			;	push hl    ; u3  
2832			; 
2832			;	FORTH_DSP_POP 
2832			; 
2832			;	FORTH_DSP_VALUEHL 
2832			;	push hl     ; u2 
2832			; 
2832			;	FORTH_DSP_POP 
2832			; 
2832			;	FORTH_DSP_VALUEHL 
2832			;	push hl     ; u1 
2832			; 
2832			;	FORTH_DSP_POP 
2832			; 
2832			;	pop bc      ; u1 
2832			;	pop hl      ; u2 
2832			;	pop de      ; u3 
2832			; 
2832			; 
2832			;	push bc 
2832			;	push de 
2832			;	push hl 
2832			; 
2832			; 
2832			;	pop hl 
2832			;	call forth_push_numhl 
2832			; 
2832			;	pop hl 
2832			;	call forth_push_numhl 
2832			; 
2832			;	pop hl 
2832			;	call forth_push_numhl 
2832				 
2832			 
2832			 
2832			 
2832			 
2832			 
2832			       NEXTW 
2832 cd 6c ee			call parse_vector 
2835 c3 b9 1e			jp macro_next 
2838				endm 
# End of macro NEXTW
2838			 
2838			.UWORDS: 
2838			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2838 50				db WORD_SYS_CORE+60             
2839 fd 28			dw .BP            
283b 07				db 6 + 1 
283c .. 00			db "UWORDS",0              
2843				endm 
# End of macro CWHEAD
2843			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2843			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2843			; | | Following the count are the individual words. 
2843			; | | 
2843			; | | e.g. UWORDS 
2843			; | | BOX DIRLIST 2 
2843			; | |  
2843			; | | Can be used to save the words to storage via: 
2843			; | | UWORDS $01 DO $01 APPEND LOOP 
2843			if DEBUG_FORTH_WORDS_KEY 
2843				DMARK "UWR" 
2843 f5				push af  
2844 3a 58 28			ld a, (.dmark)  
2847 32 62 ee			ld (debug_mark),a  
284a 3a 59 28			ld a, (.dmark+1)  
284d 32 63 ee			ld (debug_mark+1),a  
2850 3a 5a 28			ld a, (.dmark+2)  
2853 32 64 ee			ld (debug_mark+2),a  
2856 18 03			jr .pastdmark  
2858 ..			.dmark: db "UWR"  
285b f1			.pastdmark: pop af  
285c			endm  
# End of macro DMARK
285c				CALLMONITOR 
285c cd 6f ee			call debug_vector  
285f				endm  
# End of macro CALLMONITOR
285f			endif 
285f 21 cd 65			ld hl, baseram 
2862				;ld hl, baseusermem 
2862 01 00 00			ld bc, 0    ; start a counter 
2865			 
2865			; skip dict stub 
2865			 
2865 cd eb 1f			call forth_tok_next 
2868			 
2868			 
2868			; while we have words to look for 
2868			 
2868 7e			.douscan:	ld a, (hl)      
2869			if DEBUG_FORTH_WORDS 
2869				DMARK "UWs" 
2869 f5				push af  
286a 3a 7e 28			ld a, (.dmark)  
286d 32 62 ee			ld (debug_mark),a  
2870 3a 7f 28			ld a, (.dmark+1)  
2873 32 63 ee			ld (debug_mark+1),a  
2876 3a 80 28			ld a, (.dmark+2)  
2879 32 64 ee			ld (debug_mark+2),a  
287c 18 03			jr .pastdmark  
287e ..			.dmark: db "UWs"  
2881 f1			.pastdmark: pop af  
2882			endm  
# End of macro DMARK
2882				CALLMONITOR 
2882 cd 6f ee			call debug_vector  
2885				endm  
# End of macro CALLMONITOR
2885			endif 
2885 fe 00			cp WORD_SYS_END 
2887 28 4d			jr z, .udone 
2889 fe 01			cp WORD_SYS_UWORD 
288b 20 44			jr nz, .nuword 
288d			 
288d			if DEBUG_FORTH_WORDS 
288d				DMARK "UWu" 
288d f5				push af  
288e 3a a2 28			ld a, (.dmark)  
2891 32 62 ee			ld (debug_mark),a  
2894 3a a3 28			ld a, (.dmark+1)  
2897 32 63 ee			ld (debug_mark+1),a  
289a 3a a4 28			ld a, (.dmark+2)  
289d 32 64 ee			ld (debug_mark+2),a  
28a0 18 03			jr .pastdmark  
28a2 ..			.dmark: db "UWu"  
28a5 f1			.pastdmark: pop af  
28a6			endm  
# End of macro DMARK
28a6				CALLMONITOR 
28a6 cd 6f ee			call debug_vector  
28a9				endm  
# End of macro CALLMONITOR
28a9			endif 
28a9				; we have a uword so push its name to the stack 
28a9			 
28a9 e5				push hl  ; save so we can move to next dict block 
28aa			 
28aa				; skip opcode 
28aa 23				inc hl  
28ab				; skip next ptr 
28ab 23				inc hl  
28ac 23				inc hl 
28ad				; skip len 
28ad 23				inc hl 
28ae			if DEBUG_FORTH_WORDS 
28ae				DMARK "UWt" 
28ae f5				push af  
28af 3a c3 28			ld a, (.dmark)  
28b2 32 62 ee			ld (debug_mark),a  
28b5 3a c4 28			ld a, (.dmark+1)  
28b8 32 63 ee			ld (debug_mark+1),a  
28bb 3a c5 28			ld a, (.dmark+2)  
28be 32 64 ee			ld (debug_mark+2),a  
28c1 18 03			jr .pastdmark  
28c3 ..			.dmark: db "UWt"  
28c6 f1			.pastdmark: pop af  
28c7			endm  
# End of macro DMARK
28c7				CALLMONITOR 
28c7 cd 6f ee			call debug_vector  
28ca				endm  
# End of macro CALLMONITOR
28ca			endif 
28ca 03				inc bc 
28cb			 
28cb c5				push bc 
28cc cd 40 1b			call forth_push_str 
28cf c1				pop bc 
28d0			 
28d0 e1				pop hl 	 
28d1			 
28d1 cd eb 1f		.nuword:	call forth_tok_next 
28d4 18 92			jr .douscan  
28d6			 
28d6			.udone:		 ; push count of uwords found 
28d6 c5				push bc 
28d7 e1				pop hl 
28d8			 
28d8			if DEBUG_FORTH_WORDS 
28d8				DMARK "UWc" 
28d8 f5				push af  
28d9 3a ed 28			ld a, (.dmark)  
28dc 32 62 ee			ld (debug_mark),a  
28df 3a ee 28			ld a, (.dmark+1)  
28e2 32 63 ee			ld (debug_mark+1),a  
28e5 3a ef 28			ld a, (.dmark+2)  
28e8 32 64 ee			ld (debug_mark+2),a  
28eb 18 03			jr .pastdmark  
28ed ..			.dmark: db "UWc"  
28f0 f1			.pastdmark: pop af  
28f1			endm  
# End of macro DMARK
28f1				CALLMONITOR 
28f1 cd 6f ee			call debug_vector  
28f4				endm  
# End of macro CALLMONITOR
28f4			endif 
28f4 cd d6 1a			call forth_push_numhl 
28f7			 
28f7			 
28f7			       NEXTW 
28f7 cd 6c ee			call parse_vector 
28fa c3 b9 1e			jp macro_next 
28fd				endm 
# End of macro NEXTW
28fd			 
28fd			.BP: 
28fd			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
28fd 54				db WORD_SYS_CORE+64             
28fe 3d 29			dw .MONITOR            
2900 03				db 2 + 1 
2901 .. 00			db "BP",0              
2904				endm 
# End of macro CWHEAD
2904			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2904			; | | $00 Will enable the break points within specific code paths 
2904			; | | $01 Will disable break points 
2904			; | |  
2904			; | | By default break points are off. Either the above can be used to enable them 
2904			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2904			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2904			; | | can disable break points. Exiting will then continue boot process. 
2904				; get byte count 
2904				if DEBUG_FORTH_WORDS_KEY 
2904					DMARK "BP." 
2904 f5				push af  
2905 3a 19 29			ld a, (.dmark)  
2908 32 62 ee			ld (debug_mark),a  
290b 3a 1a 29			ld a, (.dmark+1)  
290e 32 63 ee			ld (debug_mark+1),a  
2911 3a 1b 29			ld a, (.dmark+2)  
2914 32 64 ee			ld (debug_mark+2),a  
2917 18 03			jr .pastdmark  
2919 ..			.dmark: db "BP."  
291c f1			.pastdmark: pop af  
291d			endm  
# End of macro DMARK
291d					CALLMONITOR 
291d cd 6f ee			call debug_vector  
2920				endm  
# End of macro CALLMONITOR
2920				endif 
2920			 
2920				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2920 cd d2 1c			call macro_dsp_valuehl 
2923				endm 
# End of macro FORTH_DSP_VALUEHL
2923			 
2923			;		push hl 
2923			 
2923				; destroy value TOS 
2923			 
2923				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2923 cd 8a 1d			call macro_forth_dsp_pop 
2926				endm 
# End of macro FORTH_DSP_POP
2926			 
2926			;		pop hl 
2926			 
2926 3e 00			ld a,0 
2928 bd				cp l 
2929 28 09			jr z, .bpset 
292b			;		ld a, '*' 
292b cd 61 14			call bp_off 
292e				NEXTW 
292e cd 6c ee			call parse_vector 
2931 c3 b9 1e			jp macro_next 
2934				endm 
# End of macro NEXTW
2934			 
2934			.bpset:	 
2934				;	ld (os_view_disable), a 
2934 cd 55 14			call bp_on 
2937			 
2937			 
2937				NEXTW 
2937 cd 6c ee			call parse_vector 
293a c3 b9 1e			jp macro_next 
293d				endm 
# End of macro NEXTW
293d			 
293d			 
293d			.MONITOR: 
293d			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
293d 55				db WORD_SYS_CORE+65             
293e 71 29			dw .MALLOC            
2940 08				db 7 + 1 
2941 .. 00			db "MONITOR",0              
2949				endm 
# End of macro CWHEAD
2949			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2949			; | | At start the current various registers will be displayed with contents. 
2949			; | | Top right corner will show the most recent debug marker seen. 
2949			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2949			; | | and the return stack pointer (RSP). 
2949			; | | Pressing: 
2949			; | |  
2949			; | |    1 - Initial screen 
2949			; | |  
2949			; | |    2 - Display a data dump of HL 
2949			; | |  
2949			; | |    3 - Display a data dump of DE 
2949			; | |  
2949			; | |    4 - Display a data dump of BC 
2949			; | |  
2949			; | |    5 - Display a data dump of HL 
2949			; | |  
2949			; | |    6 - Display a data dump of DSP 
2949			; | |  
2949			; | |    7 - Display a data dump of RSP 
2949			; | |  
2949			; | |    8 - Display a data dump of what is at DSP 
2949			; | |  
2949			; | |    9 - Display a data dump of what is at RSP 
2949			; | |  
2949			; | |    0 - Exit monitor and continue running. This will also enable break points 
2949			; | |  
2949			; | |    * - Disable break points 
2949			; | |  
2949			; | |    # - Enter traditional monitor mode 
2949			; | |  
2949			; | | 
2949			; | | Monitor Mode 
2949			; | | ------------ 
2949			; | | A prompt of '>' will be shown for various commands: 
2949			; | |  
2949			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2949			; | |  
2949			; | |    C - Continue display a data dump from the last set address 
2949			; | |  
2949			; | |    M xxxx - Set start of memory edit at address xx 
2949			; | |  
2949			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2949			; | |  
2949			; | |    G xxxx - Exec code at specific address 
2949			; | |  
2949			; | |    Q - Return to previous 
2949				if DEBUG_FORTH_WORDS_KEY 
2949					DMARK "MON" 
2949 f5				push af  
294a 3a 5e 29			ld a, (.dmark)  
294d 32 62 ee			ld (debug_mark),a  
2950 3a 5f 29			ld a, (.dmark+1)  
2953 32 63 ee			ld (debug_mark+1),a  
2956 3a 60 29			ld a, (.dmark+2)  
2959 32 64 ee			ld (debug_mark+2),a  
295c 18 03			jr .pastdmark  
295e ..			.dmark: db "MON"  
2961 f1			.pastdmark: pop af  
2962			endm  
# End of macro DMARK
2962					CALLMONITOR 
2962 cd 6f ee			call debug_vector  
2965				endm  
# End of macro CALLMONITOR
2965				endif 
2965			;		ld a, 0 
2965			;		ld (os_view_disable), a 
2965 cd 55 14			call bp_on 
2968			 
2968				CALLMONITOR 
2968 cd 6f ee			call debug_vector  
296b				endm  
# End of macro CALLMONITOR
296b			 
296b			;	call monitor 
296b			 
296b				NEXTW 
296b cd 6c ee			call parse_vector 
296e c3 b9 1e			jp macro_next 
2971				endm 
# End of macro NEXTW
2971			 
2971			 
2971			.MALLOC: 
2971			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2971 56				db WORD_SYS_CORE+66             
2972 9a 29			dw .MALLOC2            
2974 06				db 5 + 1 
2975 .. 00			db "ALLOT",0              
297b				endm 
# End of macro CWHEAD
297b			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
297b				if DEBUG_FORTH_WORDS_KEY 
297b					DMARK "ALL" 
297b f5				push af  
297c 3a 90 29			ld a, (.dmark)  
297f 32 62 ee			ld (debug_mark),a  
2982 3a 91 29			ld a, (.dmark+1)  
2985 32 63 ee			ld (debug_mark+1),a  
2988 3a 92 29			ld a, (.dmark+2)  
298b 32 64 ee			ld (debug_mark+2),a  
298e 18 03			jr .pastdmark  
2990 ..			.dmark: db "ALL"  
2993 f1			.pastdmark: pop af  
2994			endm  
# End of macro DMARK
2994					CALLMONITOR 
2994 cd 6f ee			call debug_vector  
2997				endm  
# End of macro CALLMONITOR
2997				endif 
2997 c3 c1 29			jp .mallocc 
299a			.MALLOC2: 
299a			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
299a 56				db WORD_SYS_CORE+66             
299b db 29			dw .FREE            
299d 07				db 6 + 1 
299e .. 00			db "MALLOC",0              
29a5				endm 
# End of macro CWHEAD
29a5			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29a5				; get byte count 
29a5				if DEBUG_FORTH_WORDS_KEY 
29a5					DMARK "MAL" 
29a5 f5				push af  
29a6 3a ba 29			ld a, (.dmark)  
29a9 32 62 ee			ld (debug_mark),a  
29ac 3a bb 29			ld a, (.dmark+1)  
29af 32 63 ee			ld (debug_mark+1),a  
29b2 3a bc 29			ld a, (.dmark+2)  
29b5 32 64 ee			ld (debug_mark+2),a  
29b8 18 03			jr .pastdmark  
29ba ..			.dmark: db "MAL"  
29bd f1			.pastdmark: pop af  
29be			endm  
# End of macro DMARK
29be					CALLMONITOR 
29be cd 6f ee			call debug_vector  
29c1				endm  
# End of macro CALLMONITOR
29c1				endif 
29c1			.mallocc: 
29c1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c1 cd d2 1c			call macro_dsp_valuehl 
29c4				endm 
# End of macro FORTH_DSP_VALUEHL
29c4			 
29c4			;		push hl 
29c4			 
29c4				; destroy value TOS 
29c4			 
29c4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c4 cd 8a 1d			call macro_forth_dsp_pop 
29c7				endm 
# End of macro FORTH_DSP_POP
29c7			 
29c7			;		pop hl 
29c7 cd ad 11			call malloc 
29ca			if DEBUG_FORTH_MALLOC_GUARD 
29ca f5				push af 
29cb cd 0a 0e			call ishlzero 
29ce			;		ld a, l 
29ce			;		add h 
29ce			;		cp 0 
29ce f1				pop af 
29cf				 
29cf cc 27 54			call z,malloc_error 
29d2			endif 
29d2			 
29d2 cd d6 1a			call forth_push_numhl 
29d5				NEXTW 
29d5 cd 6c ee			call parse_vector 
29d8 c3 b9 1e			jp macro_next 
29db				endm 
# End of macro NEXTW
29db			 
29db			.FREE: 
29db			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
29db 57				db WORD_SYS_CORE+67             
29dc 0f 2a			dw .UPTR            
29de 05				db 4 + 1 
29df .. 00			db "FREE",0              
29e4				endm 
# End of macro CWHEAD
29e4			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
29e4				if DEBUG_FORTH_WORDS_KEY 
29e4					DMARK "FRE" 
29e4 f5				push af  
29e5 3a f9 29			ld a, (.dmark)  
29e8 32 62 ee			ld (debug_mark),a  
29eb 3a fa 29			ld a, (.dmark+1)  
29ee 32 63 ee			ld (debug_mark+1),a  
29f1 3a fb 29			ld a, (.dmark+2)  
29f4 32 64 ee			ld (debug_mark+2),a  
29f7 18 03			jr .pastdmark  
29f9 ..			.dmark: db "FRE"  
29fc f1			.pastdmark: pop af  
29fd			endm  
# End of macro DMARK
29fd					CALLMONITOR 
29fd cd 6f ee			call debug_vector  
2a00				endm  
# End of macro CALLMONITOR
2a00				endif 
2a00				; get address 
2a00			 
2a00				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a00 cd d2 1c			call macro_dsp_valuehl 
2a03				endm 
# End of macro FORTH_DSP_VALUEHL
2a03			 
2a03			;		push hl 
2a03			 
2a03				; destroy value TOS 
2a03			 
2a03				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a03 cd 8a 1d			call macro_forth_dsp_pop 
2a06				endm 
# End of macro FORTH_DSP_POP
2a06			 
2a06			;		pop hl 
2a06			if FORTH_ENABLE_MALLOCFREE 
2a06 cd 77 12			call free 
2a09			endif 
2a09				NEXTW 
2a09 cd 6c ee			call parse_vector 
2a0c c3 b9 1e			jp macro_next 
2a0f				endm 
# End of macro NEXTW
2a0f			.UPTR: 
2a0f			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2a0f 57				db WORD_SYS_CORE+67             
2a10 15 2b			dw .LIST            
2a12 05				db 4 + 1 
2a13 .. 00			db "UPTR",0              
2a18				endm 
# End of macro CWHEAD
2a18			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2a18				if DEBUG_FORTH_WORDS_KEY 
2a18					DMARK "UPT" 
2a18 f5				push af  
2a19 3a 2d 2a			ld a, (.dmark)  
2a1c 32 62 ee			ld (debug_mark),a  
2a1f 3a 2e 2a			ld a, (.dmark+1)  
2a22 32 63 ee			ld (debug_mark+1),a  
2a25 3a 2f 2a			ld a, (.dmark+2)  
2a28 32 64 ee			ld (debug_mark+2),a  
2a2b 18 03			jr .pastdmark  
2a2d ..			.dmark: db "UPT"  
2a30 f1			.pastdmark: pop af  
2a31			endm  
# End of macro DMARK
2a31					CALLMONITOR 
2a31 cd 6f ee			call debug_vector  
2a34				endm  
# End of macro CALLMONITOR
2a34				endif 
2a34				FORTH_DSP_VALUEHL 
2a34 cd d2 1c			call macro_dsp_valuehl 
2a37				endm 
# End of macro FORTH_DSP_VALUEHL
2a37			 
2a37 e5				push hl 
2a38				FORTH_DSP_POP 
2a38 cd 8a 1d			call macro_forth_dsp_pop 
2a3b				endm 
# End of macro FORTH_DSP_POP
2a3b c1				pop bc 
2a3c			 
2a3c			 
2a3c				; Get ptr to the word we need to look up 
2a3c			 
2a3c			;		FORTH_DSP_VALUEHL 
2a3c				;v5 FORTH_DSP_VALUE 
2a3c			; TODO type check 
2a3c			;		inc hl    ; Skip type check  
2a3c			;		push hl 
2a3c			;		ex de, hl    ; put into DE 
2a3c			 
2a3c			 
2a3c 21 cd 65			ld hl, baseram 
2a3f				;ld hl, baseusermem 
2a3f			 
2a3f e5			push hl   ; sacreifical push 
2a40			 
2a40			.uldouscanm: 
2a40 e1			pop hl 
2a41			.uldouscan: 
2a41			if DEBUG_FORTH_WORDS 
2a41				DMARK "LSs" 
2a41 f5				push af  
2a42 3a 56 2a			ld a, (.dmark)  
2a45 32 62 ee			ld (debug_mark),a  
2a48 3a 57 2a			ld a, (.dmark+1)  
2a4b 32 63 ee			ld (debug_mark+1),a  
2a4e 3a 58 2a			ld a, (.dmark+2)  
2a51 32 64 ee			ld (debug_mark+2),a  
2a54 18 03			jr .pastdmark  
2a56 ..			.dmark: db "LSs"  
2a59 f1			.pastdmark: pop af  
2a5a			endm  
# End of macro DMARK
2a5a				CALLMONITOR 
2a5a cd 6f ee			call debug_vector  
2a5d				endm  
# End of macro CALLMONITOR
2a5d			endif 
2a5d			; skip dict stub 
2a5d cd eb 1f			call forth_tok_next 
2a60			 
2a60			 
2a60			; while we have words to look for 
2a60			 
2a60 7e			ld a, (hl)      
2a61			if DEBUG_FORTH_WORDS 
2a61				DMARK "LSk" 
2a61 f5				push af  
2a62 3a 76 2a			ld a, (.dmark)  
2a65 32 62 ee			ld (debug_mark),a  
2a68 3a 77 2a			ld a, (.dmark+1)  
2a6b 32 63 ee			ld (debug_mark+1),a  
2a6e 3a 78 2a			ld a, (.dmark+2)  
2a71 32 64 ee			ld (debug_mark+2),a  
2a74 18 03			jr .pastdmark  
2a76 ..			.dmark: db "LSk"  
2a79 f1			.pastdmark: pop af  
2a7a			endm  
# End of macro DMARK
2a7a				CALLMONITOR 
2a7a cd 6f ee			call debug_vector  
2a7d				endm  
# End of macro CALLMONITOR
2a7d			endif 
2a7d				;cp WORD_SYS_END 
2a7d				;jp z, .lunotfound 
2a7d			 
2a7d					; if we hit non uwords then gone too far 
2a7d fe 01				cp WORD_SYS_UWORD 
2a7f c2 0c 2b				jp nz, .ulunotfound 
2a82			 
2a82				if DEBUG_FORTH_WORDS 
2a82					DMARK "LSu" 
2a82 f5				push af  
2a83 3a 97 2a			ld a, (.dmark)  
2a86 32 62 ee			ld (debug_mark),a  
2a89 3a 98 2a			ld a, (.dmark+1)  
2a8c 32 63 ee			ld (debug_mark+1),a  
2a8f 3a 99 2a			ld a, (.dmark+2)  
2a92 32 64 ee			ld (debug_mark+2),a  
2a95 18 03			jr .pastdmark  
2a97 ..			.dmark: db "LSu"  
2a9a f1			.pastdmark: pop af  
2a9b			endm  
# End of macro DMARK
2a9b					CALLMONITOR 
2a9b cd 6f ee			call debug_vector  
2a9e				endm  
# End of macro CALLMONITOR
2a9e				endif 
2a9e			 
2a9e					; found a uword but is it the one we want... 
2a9e			 
2a9e c5					push bc     ; uword to find is on bc 
2a9f d1					pop de 
2aa0			 
2aa0 e5					push hl  ; to save the ptr 
2aa1			 
2aa1					; skip opcode 
2aa1 23					inc hl  
2aa2					; skip next ptr 
2aa2 23					inc hl  
2aa3 23					inc hl 
2aa4					; skip len 
2aa4 23					inc hl 
2aa5			 
2aa5				if DEBUG_FORTH_WORDS 
2aa5					DMARK "LSc" 
2aa5 f5				push af  
2aa6 3a ba 2a			ld a, (.dmark)  
2aa9 32 62 ee			ld (debug_mark),a  
2aac 3a bb 2a			ld a, (.dmark+1)  
2aaf 32 63 ee			ld (debug_mark+1),a  
2ab2 3a bc 2a			ld a, (.dmark+2)  
2ab5 32 64 ee			ld (debug_mark+2),a  
2ab8 18 03			jr .pastdmark  
2aba ..			.dmark: db "LSc"  
2abd f1			.pastdmark: pop af  
2abe			endm  
# End of macro DMARK
2abe					CALLMONITOR 
2abe cd 6f ee			call debug_vector  
2ac1				endm  
# End of macro CALLMONITOR
2ac1				endif 
2ac1			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2ac1			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2ac1			; Nope that has gone the other way. It needs to be exact not on first zero 
2ac1			;		call strcmp 
2ac1 c5					push bc 
2ac2 cd 7d 11				call StrictStrCmp 
2ac5 c1					pop bc 
2ac6 c2 40 2a				jp nz, .uldouscanm 
2ac9				 
2ac9			 
2ac9			 
2ac9					; we have a uword so push its name to the stack 
2ac9			 
2ac9			;	   	push hl  ; save so we can move to next dict block 
2ac9 e1			pop hl 
2aca			 
2aca				if DEBUG_FORTH_WORDS 
2aca					DMARK "LSm" 
2aca f5				push af  
2acb 3a df 2a			ld a, (.dmark)  
2ace 32 62 ee			ld (debug_mark),a  
2ad1 3a e0 2a			ld a, (.dmark+1)  
2ad4 32 63 ee			ld (debug_mark+1),a  
2ad7 3a e1 2a			ld a, (.dmark+2)  
2ada 32 64 ee			ld (debug_mark+2),a  
2add 18 03			jr .pastdmark  
2adf ..			.dmark: db "LSm"  
2ae2 f1			.pastdmark: pop af  
2ae3			endm  
# End of macro DMARK
2ae3					CALLMONITOR 
2ae3 cd 6f ee			call debug_vector  
2ae6				endm  
# End of macro CALLMONITOR
2ae6				endif 
2ae6			 
2ae6					; skip opcode 
2ae6 23					inc hl  
2ae7					; skip next ptr 
2ae7 23					inc hl  
2ae8 23					inc hl 
2ae9					; skip len 
2ae9 7e					ld a, (hl)   ; save length to add 
2aea				if DEBUG_FORTH_WORDS 
2aea					DMARK "LS2" 
2aea f5				push af  
2aeb 3a ff 2a			ld a, (.dmark)  
2aee 32 62 ee			ld (debug_mark),a  
2af1 3a 00 2b			ld a, (.dmark+1)  
2af4 32 63 ee			ld (debug_mark+1),a  
2af7 3a 01 2b			ld a, (.dmark+2)  
2afa 32 64 ee			ld (debug_mark+2),a  
2afd 18 03			jr .pastdmark  
2aff ..			.dmark: db "LS2"  
2b02 f1			.pastdmark: pop af  
2b03			endm  
# End of macro DMARK
2b03					CALLMONITOR 
2b03 cd 6f ee			call debug_vector  
2b06				endm  
# End of macro CALLMONITOR
2b06				endif 
2b06			 
2b06				; skip zero term and other uword defs to position right at the exec code 
2b06 06 04			ld b, 4 
2b08 80				add a,b 
2b09			 
2b09 cd e1 0d			call addatohl 
2b0c					; save this location 
2b0c				 
2b0c			.ulunotfound: 
2b0c cd d6 1a			call forth_push_numhl 
2b0f						 
2b0f				NEXTW 
2b0f cd 6c ee			call parse_vector 
2b12 c3 b9 1e			jp macro_next 
2b15				endm 
# End of macro NEXTW
2b15			.LIST: 
2b15			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2b15 5c				db WORD_SYS_CORE+72             
2b16 17 2d			dw .FORGET            
2b18 05				db 4 + 1 
2b19 .. 00			db "LIST",0              
2b1e				endm 
# End of macro CWHEAD
2b1e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2b1e			; | | The quoted word must be in upper case. 
2b1e			if DEBUG_FORTH_WORDS_KEY 
2b1e				DMARK "LST" 
2b1e f5				push af  
2b1f 3a 33 2b			ld a, (.dmark)  
2b22 32 62 ee			ld (debug_mark),a  
2b25 3a 34 2b			ld a, (.dmark+1)  
2b28 32 63 ee			ld (debug_mark+1),a  
2b2b 3a 35 2b			ld a, (.dmark+2)  
2b2e 32 64 ee			ld (debug_mark+2),a  
2b31 18 03			jr .pastdmark  
2b33 ..			.dmark: db "LST"  
2b36 f1			.pastdmark: pop af  
2b37			endm  
# End of macro DMARK
2b37				CALLMONITOR 
2b37 cd 6f ee			call debug_vector  
2b3a				endm  
# End of macro CALLMONITOR
2b3a			endif 
2b3a			 
2b3a				FORTH_DSP_VALUEHL 
2b3a cd d2 1c			call macro_dsp_valuehl 
2b3d				endm 
# End of macro FORTH_DSP_VALUEHL
2b3d			 
2b3d e5				push hl 
2b3e				FORTH_DSP_POP 
2b3e cd 8a 1d			call macro_forth_dsp_pop 
2b41				endm 
# End of macro FORTH_DSP_POP
2b41 c1				pop bc 
2b42			 
2b42			; Start format of scratch string 
2b42			 
2b42 21 b8 e2			ld hl, scratch 
2b45			 
2b45			;	ld a, ':' 
2b45 36 3a			ld (hl),':' 
2b47 23				inc hl 
2b48			;	ld a, ' ' 
2b48 36 20			ld (hl), ' ' 
2b4a			 
2b4a				; Get ptr to the word we need to look up 
2b4a			 
2b4a			;		FORTH_DSP_VALUEHL 
2b4a				;v5 FORTH_DSP_VALUE 
2b4a			; TODO type check 
2b4a			;		inc hl    ; Skip type check  
2b4a			;		push hl 
2b4a			;		ex de, hl    ; put into DE 
2b4a			 
2b4a			 
2b4a 21 cd 65			ld hl, baseram 
2b4d				;ld hl, baseusermem 
2b4d			 
2b4d e5			push hl   ; sacreifical push 
2b4e			 
2b4e			.ldouscanm: 
2b4e e1			pop hl 
2b4f			.ldouscan: 
2b4f			if DEBUG_FORTH_WORDS 
2b4f				DMARK "LSs" 
2b4f f5				push af  
2b50 3a 64 2b			ld a, (.dmark)  
2b53 32 62 ee			ld (debug_mark),a  
2b56 3a 65 2b			ld a, (.dmark+1)  
2b59 32 63 ee			ld (debug_mark+1),a  
2b5c 3a 66 2b			ld a, (.dmark+2)  
2b5f 32 64 ee			ld (debug_mark+2),a  
2b62 18 03			jr .pastdmark  
2b64 ..			.dmark: db "LSs"  
2b67 f1			.pastdmark: pop af  
2b68			endm  
# End of macro DMARK
2b68				CALLMONITOR 
2b68 cd 6f ee			call debug_vector  
2b6b				endm  
# End of macro CALLMONITOR
2b6b			endif 
2b6b			; skip dict stub 
2b6b cd eb 1f			call forth_tok_next 
2b6e			 
2b6e			 
2b6e			; while we have words to look for 
2b6e			 
2b6e 7e			ld a, (hl)      
2b6f			if DEBUG_FORTH_WORDS 
2b6f				DMARK "LSk" 
2b6f f5				push af  
2b70 3a 84 2b			ld a, (.dmark)  
2b73 32 62 ee			ld (debug_mark),a  
2b76 3a 85 2b			ld a, (.dmark+1)  
2b79 32 63 ee			ld (debug_mark+1),a  
2b7c 3a 86 2b			ld a, (.dmark+2)  
2b7f 32 64 ee			ld (debug_mark+2),a  
2b82 18 03			jr .pastdmark  
2b84 ..			.dmark: db "LSk"  
2b87 f1			.pastdmark: pop af  
2b88			endm  
# End of macro DMARK
2b88				CALLMONITOR 
2b88 cd 6f ee			call debug_vector  
2b8b				endm  
# End of macro CALLMONITOR
2b8b			endif 
2b8b				;cp WORD_SYS_END 
2b8b				;jp z, .lunotfound 
2b8b			 
2b8b					; if we hit non uwords then gone too far 
2b8b fe 01				cp WORD_SYS_UWORD 
2b8d c2 ca 2c				jp nz, .lunotfound 
2b90			 
2b90				if DEBUG_FORTH_WORDS 
2b90					DMARK "LSu" 
2b90 f5				push af  
2b91 3a a5 2b			ld a, (.dmark)  
2b94 32 62 ee			ld (debug_mark),a  
2b97 3a a6 2b			ld a, (.dmark+1)  
2b9a 32 63 ee			ld (debug_mark+1),a  
2b9d 3a a7 2b			ld a, (.dmark+2)  
2ba0 32 64 ee			ld (debug_mark+2),a  
2ba3 18 03			jr .pastdmark  
2ba5 ..			.dmark: db "LSu"  
2ba8 f1			.pastdmark: pop af  
2ba9			endm  
# End of macro DMARK
2ba9					CALLMONITOR 
2ba9 cd 6f ee			call debug_vector  
2bac				endm  
# End of macro CALLMONITOR
2bac				endif 
2bac			 
2bac					; found a uword but is it the one we want... 
2bac			 
2bac c5					push bc     ; uword to find is on bc 
2bad d1					pop de 
2bae			 
2bae e5					push hl  ; to save the ptr 
2baf			 
2baf					; skip opcode 
2baf 23					inc hl  
2bb0					; skip next ptr 
2bb0 23					inc hl  
2bb1 23					inc hl 
2bb2					; skip len 
2bb2 23					inc hl 
2bb3			 
2bb3				if DEBUG_FORTH_WORDS 
2bb3					DMARK "LSc" 
2bb3 f5				push af  
2bb4 3a c8 2b			ld a, (.dmark)  
2bb7 32 62 ee			ld (debug_mark),a  
2bba 3a c9 2b			ld a, (.dmark+1)  
2bbd 32 63 ee			ld (debug_mark+1),a  
2bc0 3a ca 2b			ld a, (.dmark+2)  
2bc3 32 64 ee			ld (debug_mark+2),a  
2bc6 18 03			jr .pastdmark  
2bc8 ..			.dmark: db "LSc"  
2bcb f1			.pastdmark: pop af  
2bcc			endm  
# End of macro DMARK
2bcc					CALLMONITOR 
2bcc cd 6f ee			call debug_vector  
2bcf				endm  
# End of macro CALLMONITOR
2bcf				endif 
2bcf			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2bcf			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2bcf			; Nope that has gone the other way. It needs to be exact not on first zero 
2bcf			;		call strcmp 
2bcf c5					push bc 
2bd0 cd 7d 11				call StrictStrCmp 
2bd3 c1					pop bc 
2bd4 c2 4e 2b				jp nz, .ldouscanm 
2bd7				 
2bd7			 
2bd7			 
2bd7					; we have a uword so push its name to the stack 
2bd7			 
2bd7			;	   	push hl  ; save so we can move to next dict block 
2bd7 e1			pop hl 
2bd8			 
2bd8				if DEBUG_FORTH_WORDS 
2bd8					DMARK "LSm" 
2bd8 f5				push af  
2bd9 3a ed 2b			ld a, (.dmark)  
2bdc 32 62 ee			ld (debug_mark),a  
2bdf 3a ee 2b			ld a, (.dmark+1)  
2be2 32 63 ee			ld (debug_mark+1),a  
2be5 3a ef 2b			ld a, (.dmark+2)  
2be8 32 64 ee			ld (debug_mark+2),a  
2beb 18 03			jr .pastdmark  
2bed ..			.dmark: db "LSm"  
2bf0 f1			.pastdmark: pop af  
2bf1			endm  
# End of macro DMARK
2bf1					CALLMONITOR 
2bf1 cd 6f ee			call debug_vector  
2bf4				endm  
# End of macro CALLMONITOR
2bf4				endif 
2bf4			 
2bf4					; skip opcode 
2bf4 23					inc hl  
2bf5					; skip next ptr 
2bf5 23					inc hl  
2bf6 23					inc hl 
2bf7					; skip len 
2bf7 7e					ld a, (hl)   ; save length to add 
2bf8				if DEBUG_FORTH_WORDS 
2bf8					DMARK "LS2" 
2bf8 f5				push af  
2bf9 3a 0d 2c			ld a, (.dmark)  
2bfc 32 62 ee			ld (debug_mark),a  
2bff 3a 0e 2c			ld a, (.dmark+1)  
2c02 32 63 ee			ld (debug_mark+1),a  
2c05 3a 0f 2c			ld a, (.dmark+2)  
2c08 32 64 ee			ld (debug_mark+2),a  
2c0b 18 03			jr .pastdmark  
2c0d ..			.dmark: db "LS2"  
2c10 f1			.pastdmark: pop af  
2c11			endm  
# End of macro DMARK
2c11					CALLMONITOR 
2c11 cd 6f ee			call debug_vector  
2c14				endm  
# End of macro CALLMONITOR
2c14				endif 
2c14			 
2c14					; save this location 
2c14				 
2c14 e5					push hl 
2c15			 
2c15 23					inc hl 
2c16 11 ba e2				ld de, scratch+2 
2c19 4f					ld c, a 
2c1a 06 00				ld b, 0 
2c1c			 
2c1c				if DEBUG_FORTH_WORDS 
2c1c					DMARK "LSn" 
2c1c f5				push af  
2c1d 3a 31 2c			ld a, (.dmark)  
2c20 32 62 ee			ld (debug_mark),a  
2c23 3a 32 2c			ld a, (.dmark+1)  
2c26 32 63 ee			ld (debug_mark+1),a  
2c29 3a 33 2c			ld a, (.dmark+2)  
2c2c 32 64 ee			ld (debug_mark+2),a  
2c2f 18 03			jr .pastdmark  
2c31 ..			.dmark: db "LSn"  
2c34 f1			.pastdmark: pop af  
2c35			endm  
# End of macro DMARK
2c35					CALLMONITOR 
2c35 cd 6f ee			call debug_vector  
2c38				endm  
# End of macro CALLMONITOR
2c38				endif 
2c38			 
2c38					; copy uword name to scratch 
2c38			 
2c38			;		ldir 
2c38			.licplw:	; copy uword name to scratch converting to lower case as we go 
2c38 ed a0				ldi 
2c3a 1b					dec de 
2c3b 1a					ld a, (de) 
2c3c cd 52 10				call to_lower 
2c3f 12					ld (de),a 
2c40 13					inc de 
2c41 3e 00				ld a, 0 
2c43 b9					cp c 
2c44 20 f2				jr nz, .licplw 
2c46			 
2c46			 
2c46			 
2c46 1b					dec de 
2c47 3e 20				ld a, ' '    ; change null to space 
2c49 12					ld (de), a 
2c4a			 
2c4a 13					inc de 
2c4b			 
2c4b d5					push de 
2c4c c1					pop bc     ; move scratch pointer to end of word name and save it 
2c4d			 
2c4d e1					pop hl 
2c4e 7e					ld a, (hl) 
2c4f					;inc hl 
2c4f					; skip word string 
2c4f cd e1 0d				call addatohl 
2c52			 
2c52 23					inc hl 
2c53			 
2c53				if DEBUG_FORTH_WORDS 
2c53					DMARK "LS3" 
2c53 f5				push af  
2c54 3a 68 2c			ld a, (.dmark)  
2c57 32 62 ee			ld (debug_mark),a  
2c5a 3a 69 2c			ld a, (.dmark+1)  
2c5d 32 63 ee			ld (debug_mark+1),a  
2c60 3a 6a 2c			ld a, (.dmark+2)  
2c63 32 64 ee			ld (debug_mark+2),a  
2c66 18 03			jr .pastdmark  
2c68 ..			.dmark: db "LS3"  
2c6b f1			.pastdmark: pop af  
2c6c			endm  
# End of macro DMARK
2c6c					CALLMONITOR 
2c6c cd 6f ee			call debug_vector  
2c6f				endm  
# End of macro CALLMONITOR
2c6f				endif 
2c6f					; should now be at the start of the machine code to setup the eval of the uword 
2c6f					; now locate the ptr to the string defintion 
2c6f			 
2c6f					; skip ld hl, 
2c6f					; then load the ptr 
2c6f			; TODO use get from hl ptr 
2c6f 23					inc hl 
2c70 5e					ld e, (hl) 
2c71 23					inc hl 
2c72 56					ld d, (hl) 
2c73 eb					ex de, hl 
2c74			 
2c74			 
2c74				if DEBUG_FORTH_WORDS 
2c74					DMARK "LSt" 
2c74 f5				push af  
2c75 3a 89 2c			ld a, (.dmark)  
2c78 32 62 ee			ld (debug_mark),a  
2c7b 3a 8a 2c			ld a, (.dmark+1)  
2c7e 32 63 ee			ld (debug_mark+1),a  
2c81 3a 8b 2c			ld a, (.dmark+2)  
2c84 32 64 ee			ld (debug_mark+2),a  
2c87 18 03			jr .pastdmark  
2c89 ..			.dmark: db "LSt"  
2c8c f1			.pastdmark: pop af  
2c8d			endm  
# End of macro DMARK
2c8d					CALLMONITOR 
2c8d cd 6f ee			call debug_vector  
2c90				endm  
# End of macro CALLMONITOR
2c90				endif 
2c90			 
2c90			; cant push right now due to tokenised strings  
2c90			 
2c90			; get the destination of where to copy this definition to. 
2c90			 
2c90 c5					push bc 
2c91 d1					pop de 
2c92			 
2c92 7e			.listl:         ld a,(hl) 
2c93			;		cp 0 
2c93 b7					or a 
2c94 28 09				jr z, .lreplsp     ; replace zero with space 
2c96					;cp FORTH_END_BUFFER 
2c96 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2c98 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c9a				 
2c9a					; just copy this char as is then 
2c9a			 
2c9a 12					ld (de), a 
2c9b			 
2c9b 23			.listnxt:	inc hl 
2c9c 13					inc de 
2c9d 18 f3				jr .listl 
2c9f			 
2c9f 3e 20		.lreplsp:	ld a,' ' 
2ca1 12					ld (de), a 
2ca2 18 f7				jr .listnxt 
2ca4			 
2ca4			; close up uword def 
2ca4			 
2ca4			.listdone: 
2ca4 12					ld (de), a 
2ca5 13					inc de 
2ca6 3e 00				ld a, 0 
2ca8 12					ld (de), a 
2ca9			 
2ca9			; now have def so clean up and push to stack 
2ca9			 
2ca9 21 b8 e2				ld hl, scratch 
2cac				if DEBUG_FORTH_WORDS 
2cac					DMARK "Ltp" 
2cac f5				push af  
2cad 3a c1 2c			ld a, (.dmark)  
2cb0 32 62 ee			ld (debug_mark),a  
2cb3 3a c2 2c			ld a, (.dmark+1)  
2cb6 32 63 ee			ld (debug_mark+1),a  
2cb9 3a c3 2c			ld a, (.dmark+2)  
2cbc 32 64 ee			ld (debug_mark+2),a  
2cbf 18 03			jr .pastdmark  
2cc1 ..			.dmark: db "Ltp"  
2cc4 f1			.pastdmark: pop af  
2cc5			endm  
# End of macro DMARK
2cc5					CALLMONITOR 
2cc5 cd 6f ee			call debug_vector  
2cc8				endm  
# End of macro CALLMONITOR
2cc8				endif 
2cc8			 
2cc8 18 22			jr .listpush 
2cca			 
2cca			;.lnuword:	pop hl 
2cca			;		call forth_tok_next 
2cca			;		jp .ldouscan  
2cca			 
2cca			.lunotfound:		  
2cca			 
2cca				if DEBUG_FORTH_WORDS 
2cca					DMARK "LSn" 
2cca f5				push af  
2ccb 3a df 2c			ld a, (.dmark)  
2cce 32 62 ee			ld (debug_mark),a  
2cd1 3a e0 2c			ld a, (.dmark+1)  
2cd4 32 63 ee			ld (debug_mark+1),a  
2cd7 3a e1 2c			ld a, (.dmark+2)  
2cda 32 64 ee			ld (debug_mark+2),a  
2cdd 18 03			jr .pastdmark  
2cdf ..			.dmark: db "LSn"  
2ce2 f1			.pastdmark: pop af  
2ce3			endm  
# End of macro DMARK
2ce3					CALLMONITOR 
2ce3 cd 6f ee			call debug_vector  
2ce6				endm  
# End of macro CALLMONITOR
2ce6				endif 
2ce6			 
2ce6					 
2ce6			;		FORTH_DSP_POP 
2ce6			;		ld hl, .luno 
2ce6			 
2ce6					NEXTW			 
2ce6 cd 6c ee			call parse_vector 
2ce9 c3 b9 1e			jp macro_next 
2cec				endm 
# End of macro NEXTW
2cec			 
2cec			.listpush: 
2cec				if DEBUG_FORTH_WORDS 
2cec					DMARK "LS>" 
2cec f5				push af  
2ced 3a 01 2d			ld a, (.dmark)  
2cf0 32 62 ee			ld (debug_mark),a  
2cf3 3a 02 2d			ld a, (.dmark+1)  
2cf6 32 63 ee			ld (debug_mark+1),a  
2cf9 3a 03 2d			ld a, (.dmark+2)  
2cfc 32 64 ee			ld (debug_mark+2),a  
2cff 18 03			jr .pastdmark  
2d01 ..			.dmark: db "LS>"  
2d04 f1			.pastdmark: pop af  
2d05			endm  
# End of macro DMARK
2d05					CALLMONITOR 
2d05 cd 6f ee			call debug_vector  
2d08				endm  
# End of macro CALLMONITOR
2d08				endif 
2d08 cd 40 1b				call forth_push_str 
2d0b			 
2d0b			 
2d0b			 
2d0b					NEXTW 
2d0b cd 6c ee			call parse_vector 
2d0e c3 b9 1e			jp macro_next 
2d11				endm 
# End of macro NEXTW
2d11			 
2d11			;.luno:    db "Word not found",0 
2d11			 
2d11			 
2d11			 
2d11			 
2d11			 
2d11			;		push hl   ; save pointer to start of uword def string 
2d11			; 
2d11			;; look for FORTH_EOL_LINE 
2d11			;		ld a, FORTH_END_BUFFER 
2d11			;		call strlent 
2d11			; 
2d11			;		inc hl		 ; space for coln def 
2d11			;		inc hl 
2d11			;		inc hl          ; space for terms 
2d11			;		inc hl 
2d11			; 
2d11			;		ld a, 20   ; TODO get actual length 
2d11			;		call addatohl    ; include a random amount of room for the uword name 
2d11			; 
2d11			;		 
2d11			;	if DEBUG_FORTH_WORDS 
2d11			;		DMARK "Lt1" 
2d11			;		CALLMONITOR 
2d11			;	endif 
2d11			;		 
2d11			; 
2d11			;; malloc space for the string because we cant change it 
2d11			; 
2d11			;		call malloc 
2d11			;	if DEBUG_FORTH_MALLOC_GUARD 
2d11			;		push af 
2d11			;		call ishlzero 
2d11			;		pop af 
2d11			;		 
2d11			;		call z,malloc_error 
2d11			;	endif 
2d11			; 
2d11			;	if DEBUG_FORTH_WORDS 
2d11			;		DMARK "Lt2" 
2d11			;		CALLMONITOR 
2d11			;	endif 
2d11			;		pop de 
2d11			;		push hl    ; push the malloc to release later 
2d11			;		push hl   ;  push back a copy for the later stack push 
2d11			;		 
2d11			;; copy the string swapping out the zero terms for spaces 
2d11			; 
2d11			;		; de has our source 
2d11			;		; hl has our dest 
2d11			; 
2d11			;; add the coln def 
2d11			; 
2d11			;		ld a, ':' 
2d11			;		ld (hl), a 
2d11			;		inc hl 
2d11			;		ld a, ' ' 
2d11			;		ld (hl), a 
2d11			;		inc hl 
2d11			; 
2d11			;; add the uname word 
2d11			;		push de   ; save our string for now 
2d11			;		ex de, hl 
2d11			; 
2d11			;		FORTH_DSP_VALUE 
2d11			;		;v5 FORTH_DSP_VALUE 
2d11			; 
2d11			;		inc hl   ; skip type but we know by now this is OK 
2d11			; 
2d11			;.luword:	ld a,(hl) 
2d11			;		cp 0 
2d11			;		jr z, .luword2 
2d11			;		ld (de), a 
2d11			;		inc de 
2d11			;		inc hl 
2d11			;		jr .luword 
2d11			; 
2d11			;.luword2:	ld a, ' ' 
2d11			;		ld (de), a 
2d11			;;		inc hl 
2d11			;;		inc de 
2d11			;;		ld (de), a 
2d11			;;		inc hl 
2d11			;		inc de 
2d11			; 
2d11			;		ex de, hl 
2d11			;		pop de 
2d11			;		 
2d11			;		 
2d11			; 
2d11			;; detoken that string and copy it 
2d11			; 
2d11			;	if DEBUG_FORTH_WORDS 
2d11			;		DMARK "Lt2" 
2d11			;		CALLMONITOR 
2d11			;	endif 
2d11			;.ldetok:	ld a, (de) 
2d11			;		cp FORTH_END_BUFFER 
2d11			;		jr z, .ldetokend 
2d11			;		; swap out any zero term for space 
2d11			;		cp 0 
2d11			;		jr nz, .ldetoknext 
2d11			;		ld a, ' ' 
2d11			; 
2d11			;	if DEBUG_FORTH_WORDS 
2d11			;		DMARK "LtS" 
2d11			;		CALLMONITOR 
2d11			;	endif 
2d11			;.ldetoknext:	ld (hl), a 
2d11			;		inc de 
2d11			;		inc hl 
2d11			;		jr .ldetok 
2d11			; 
2d11			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d11			;		ld (hl), a  
2d11			; 
2d11			;; free that temp malloc 
2d11			; 
2d11			;		pop hl    
2d11			; 
2d11			;	if DEBUG_FORTH_WORDS 
2d11			;		DMARK "Lt4" 
2d11			;		CALLMONITOR 
2d11			;	endif 
2d11			;		call forth_apushstrhl 
2d11			; 
2d11			;		; get rid of temp malloc area 
2d11			; 
2d11			;		pop hl 
2d11			;		call free 
2d11			; 
2d11			;		jr .ludone 
2d11			; 
2d11			;.lnuword:	pop hl 
2d11			;		call forth_tok_next 
2d11			;		jp .ldouscan  
2d11			; 
2d11			;.ludone:		 pop hl 
2d11			; 
2d11					NEXTW 
2d11 cd 6c ee			call parse_vector 
2d14 c3 b9 1e			jp macro_next 
2d17				endm 
# End of macro NEXTW
2d17			 
2d17			.FORGET: 
2d17				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d17 5d				db WORD_SYS_CORE+73             
2d18 92 2d			dw .NOP            
2d1a 07				db 6 + 1 
2d1b .. 00			db "FORGET",0              
2d22				endm 
# End of macro CWHEAD
2d22			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d22			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2d22			; | |  
2d22			; | | e.g. "MORE" forget 
2d22					if DEBUG_FORTH_WORDS_KEY 
2d22						DMARK "FRG" 
2d22 f5				push af  
2d23 3a 37 2d			ld a, (.dmark)  
2d26 32 62 ee			ld (debug_mark),a  
2d29 3a 38 2d			ld a, (.dmark+1)  
2d2c 32 63 ee			ld (debug_mark+1),a  
2d2f 3a 39 2d			ld a, (.dmark+2)  
2d32 32 64 ee			ld (debug_mark+2),a  
2d35 18 03			jr .pastdmark  
2d37 ..			.dmark: db "FRG"  
2d3a f1			.pastdmark: pop af  
2d3b			endm  
# End of macro DMARK
2d3b						CALLMONITOR 
2d3b cd 6f ee			call debug_vector  
2d3e				endm  
# End of macro CALLMONITOR
2d3e					endif 
2d3e			 
2d3e				; find uword 
2d3e			        ; update start of word with "_" 
2d3e				; replace uword with deleted flag 
2d3e			 
2d3e			 
2d3e			;	if DEBUG_FORTH_WORDS 
2d3e			;		DMARK "FOG" 
2d3e			;		CALLMONITOR 
2d3e			;	endif 
2d3e			 
2d3e			 
2d3e					; Get ptr to the word we need to look up 
2d3e			 
2d3e					FORTH_DSP_VALUEHL 
2d3e cd d2 1c			call macro_dsp_valuehl 
2d41				endm 
# End of macro FORTH_DSP_VALUEHL
2d41					;v5 FORTH_DSP_VALUE 
2d41				; TODO type check 
2d41			;		inc hl    ; Skip type check  
2d41 e5					push hl 
2d42 c1					pop bc 
2d43			;		ex de, hl    ; put into DE 
2d43			 
2d43			 
2d43 21 cd 65				ld hl, baseram 
2d46					;ld hl, baseusermem 
2d46			 
2d46				; skip dict stub 
2d46			;	call forth_tok_next 
2d46 e5			push hl   ; sacreifical push 
2d47			 
2d47			.fldouscanm: 
2d47 e1				pop hl 
2d48			.fldouscan: 
2d48			;	if DEBUG_FORTH_WORDS 
2d48			;		DMARK "LSs" 
2d48			;		CALLMONITOR 
2d48			;	endif 
2d48				; skip dict stub 
2d48 cd eb 1f				call forth_tok_next 
2d4b			 
2d4b			 
2d4b			; while we have words to look for 
2d4b			 
2d4b 7e				ld a, (hl)      
2d4c			;	if DEBUG_FORTH_WORDS 
2d4c			;		DMARK "LSk" 
2d4c			;		CALLMONITOR 
2d4c			;	endif 
2d4c fe 00				cp WORD_SYS_END 
2d4e ca 89 2d				jp z, .flunotfound 
2d51 fe 01				cp WORD_SYS_UWORD 
2d53 c2 48 2d				jp nz, .fldouscan 
2d56			 
2d56			;	if DEBUG_FORTH_WORDS 
2d56			;		DMARK "LSu" 
2d56			;		CALLMONITOR 
2d56			;	endif 
2d56			 
2d56					; found a uword but is it the one we want... 
2d56			 
2d56 c5					push bc     ; uword to find is on bc 
2d57 d1					pop de 
2d58			 
2d58 e5					push hl  ; to save the ptr 
2d59			 
2d59					; skip opcode 
2d59 23					inc hl  
2d5a					; skip next ptr 
2d5a 23					inc hl  
2d5b 23					inc hl 
2d5c					; skip len 
2d5c 23					inc hl 
2d5d			 
2d5d			;	if DEBUG_FORTH_WORDS 
2d5d			;		DMARK "LSc" 
2d5d			;		CALLMONITOR 
2d5d			;	endif 
2d5d cd 71 11				call strcmp 
2d60 c2 47 2d				jp nz, .fldouscanm 
2d63			; 
2d63			; 
2d63			;; while we have words to look for 
2d63			; 
2d63			;.fdouscan:	ld a, (hl)      
2d63			;	if DEBUG_FORTH_WORDS 
2d63			;		DMARK "LSs" 
2d63			;		CALLMONITOR 
2d63			;	endif 
2d63			;		cp WORD_SYS_END 
2d63			;		jp z, .fudone 
2d63			;		cp WORD_SYS_UWORD 
2d63			;		jp nz, .fnuword 
2d63			; 
2d63			;	if DEBUG_FORTH_WORDS 
2d63			;		DMARK "FGu" 
2d63			;		CALLMONITOR 
2d63			;	endif 
2d63			; 
2d63			;		; found a uword but is it the one we want... 
2d63			; 
2d63			; 
2d63			;	        pop de   ; get back the dsp name 
2d63			;		push de 
2d63			; 
2d63			;		push hl  ; to save the ptr 
2d63			; 
2d63			;		; skip opcode 
2d63			;		inc hl  
2d63			;		; skip next ptr 
2d63			;		inc hl  
2d63			;		inc hl 
2d63			;		; skip len 
2d63			;		inc hl 
2d63			; 
2d63			;	if DEBUG_FORTH_WORDS 
2d63			;		DMARK "FGc" 
2d63			;		CALLMONITOR 
2d63			;	endif 
2d63			;		call strcmp 
2d63			;		jp nz, .fnuword 
2d63			 
2d63			 
2d63 e1			pop hl 
2d64			 
2d64				 
2d64				if DEBUG_FORTH_WORDS 
2d64					DMARK "FGm" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 62 ee			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 63 ee			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 64 ee			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "FGm"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d					CALLMONITOR 
2d7d cd 6f ee			call debug_vector  
2d80				endm  
# End of macro CALLMONITOR
2d80				endif 
2d80			 
2d80			 
2d80			 
2d80					; we have a uword so push its name to the stack 
2d80			 
2d80			;	   	push hl  ; save so we can move to next dict block 
2d80			;pop hl 
2d80			 
2d80					; update opcode to deleted 
2d80			;		ld a, WORD_SYS_DELETED 
2d80 36 03				ld (hl), WORD_SYS_DELETED 
2d82			 
2d82 23					inc hl  
2d83					; skip next ptr 
2d83 23					inc hl  
2d84 23					inc hl 
2d85					; skip len 
2d85 23					inc hl 
2d86			 
2d86					; TODO change parser to skip deleted words but for now mark it out 
2d86 3e 5f				ld a, "_" 
2d88 77					ld  (hl),a 
2d89			 
2d89			;		jr .fudone 
2d89			; 
2d89			;.fnuword:	pop hl 
2d89			;		call forth_tok_next 
2d89			;		jp .fdouscan  
2d89			 
2d89			.flunotfound:		  
2d89			 
2d89			 
2d89					 
2d89					FORTH_DSP_POP 
2d89 cd 8a 1d			call macro_forth_dsp_pop 
2d8c				endm 
# End of macro FORTH_DSP_POP
2d8c			;		ld hl, .luno 
2d8c			;.fudone:		 pop hl 
2d8c					NEXTW 
2d8c cd 6c ee			call parse_vector 
2d8f c3 b9 1e			jp macro_next 
2d92				endm 
# End of macro NEXTW
2d92			.NOP: 
2d92				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2d92 61				db WORD_SYS_CORE+77             
2d93 bc 2d			dw .COMO            
2d95 04				db 3 + 1 
2d96 .. 00			db "NOP",0              
2d9a				endm 
# End of macro CWHEAD
2d9a			; | NOP (  --  ) Do nothing | DONE 
2d9a					if DEBUG_FORTH_WORDS_KEY 
2d9a						DMARK "NOP" 
2d9a f5				push af  
2d9b 3a af 2d			ld a, (.dmark)  
2d9e 32 62 ee			ld (debug_mark),a  
2da1 3a b0 2d			ld a, (.dmark+1)  
2da4 32 63 ee			ld (debug_mark+1),a  
2da7 3a b1 2d			ld a, (.dmark+2)  
2daa 32 64 ee			ld (debug_mark+2),a  
2dad 18 03			jr .pastdmark  
2daf ..			.dmark: db "NOP"  
2db2 f1			.pastdmark: pop af  
2db3			endm  
# End of macro DMARK
2db3						CALLMONITOR 
2db3 cd 6f ee			call debug_vector  
2db6				endm  
# End of macro CALLMONITOR
2db6					endif 
2db6				       NEXTW 
2db6 cd 6c ee			call parse_vector 
2db9 c3 b9 1e			jp macro_next 
2dbc				endm 
# End of macro NEXTW
2dbc			.COMO: 
2dbc				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2dbc 6e				db WORD_SYS_CORE+90             
2dbd 11 2e			dw .COMC            
2dbf 02				db 1 + 1 
2dc0 .. 00			db "(",0              
2dc2				endm 
# End of macro CWHEAD
2dc2			; | ( ( -- )  Start of comment | DONE 
2dc2			 
2dc2			 
2dc2 2a b9 e5				ld hl, ( os_tok_ptr) 
2dc5 11 09 2e			ld de, .closepar 
2dc8					 
2dc8					if DEBUG_FORTH_WORDS 
2dc8						DMARK ").." 
2dc8 f5				push af  
2dc9 3a dd 2d			ld a, (.dmark)  
2dcc 32 62 ee			ld (debug_mark),a  
2dcf 3a de 2d			ld a, (.dmark+1)  
2dd2 32 63 ee			ld (debug_mark+1),a  
2dd5 3a df 2d			ld a, (.dmark+2)  
2dd8 32 64 ee			ld (debug_mark+2),a  
2ddb 18 03			jr .pastdmark  
2ddd ..			.dmark: db ").."  
2de0 f1			.pastdmark: pop af  
2de1			endm  
# End of macro DMARK
2de1						CALLMONITOR 
2de1 cd 6f ee			call debug_vector  
2de4				endm  
# End of macro CALLMONITOR
2de4					endif 
2de4 cd b6 1f			call findnexttok  
2de7			 
2de7					if DEBUG_FORTH_WORDS 
2de7						DMARK "IF5" 
2de7 f5				push af  
2de8 3a fc 2d			ld a, (.dmark)  
2deb 32 62 ee			ld (debug_mark),a  
2dee 3a fd 2d			ld a, (.dmark+1)  
2df1 32 63 ee			ld (debug_mark+1),a  
2df4 3a fe 2d			ld a, (.dmark+2)  
2df7 32 64 ee			ld (debug_mark+2),a  
2dfa 18 03			jr .pastdmark  
2dfc ..			.dmark: db "IF5"  
2dff f1			.pastdmark: pop af  
2e00			endm  
# End of macro DMARK
2e00						CALLMONITOR 
2e00 cd 6f ee			call debug_vector  
2e03				endm  
# End of macro CALLMONITOR
2e03					endif 
2e03				; replace below with ) exec using tok_ptr 
2e03 22 b9 e5			ld (os_tok_ptr), hl 
2e06 c3 3a 1f			jp exec1 
2e09			 
2e09 .. 00			.closepar:   db ")",0 
2e0b			 
2e0b				       NEXTW 
2e0b cd 6c ee			call parse_vector 
2e0e c3 b9 1e			jp macro_next 
2e11				endm 
# End of macro NEXTW
2e11			.COMC: 
2e11				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e11 6f				db WORD_SYS_CORE+91             
2e12 1d 2e			dw .SCRATCH            
2e14 02				db 1 + 1 
2e15 .. 00			db ")",0              
2e17				endm 
# End of macro CWHEAD
2e17			; | ) ( -- )  End of comment |  DONE  
2e17				       NEXTW 
2e17 cd 6c ee			call parse_vector 
2e1a c3 b9 1e			jp macro_next 
2e1d				endm 
# End of macro NEXTW
2e1d			 
2e1d			.SCRATCH: 
2e1d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e1d 6f				db WORD_SYS_CORE+91             
2e1e 5b 2e			dw .INC            
2e20 08				db 7 + 1 
2e21 .. 00			db "SCRATCH",0              
2e29				endm 
# End of macro CWHEAD
2e29			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e29			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e29			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e29			; | |  
2e29			; | | e.g.    : score $00 scratch ; 
2e29			; | |  
2e29			; | | $00 score ! 
2e29			; | | $01 score +! 
2e29			; | |  
2e29			; | | e.g.   : varword $0a scratch ;  
2e29			; | | 
2e29			; | | $8000 varword ! 
2e29					if DEBUG_FORTH_WORDS_KEY 
2e29						DMARK "SCR" 
2e29 f5				push af  
2e2a 3a 3e 2e			ld a, (.dmark)  
2e2d 32 62 ee			ld (debug_mark),a  
2e30 3a 3f 2e			ld a, (.dmark+1)  
2e33 32 63 ee			ld (debug_mark+1),a  
2e36 3a 40 2e			ld a, (.dmark+2)  
2e39 32 64 ee			ld (debug_mark+2),a  
2e3c 18 03			jr .pastdmark  
2e3e ..			.dmark: db "SCR"  
2e41 f1			.pastdmark: pop af  
2e42			endm  
# End of macro DMARK
2e42						CALLMONITOR 
2e42 cd 6f ee			call debug_vector  
2e45				endm  
# End of macro CALLMONITOR
2e45					endif 
2e45			 
2e45					FORTH_DSP_VALUEHL 
2e45 cd d2 1c			call macro_dsp_valuehl 
2e48				endm 
# End of macro FORTH_DSP_VALUEHL
2e48				 
2e48					FORTH_DSP_POP 
2e48 cd 8a 1d			call macro_forth_dsp_pop 
2e4b				endm 
# End of macro FORTH_DSP_POP
2e4b			 
2e4b 7d					ld a, l 
2e4c 21 dd e7				ld hl, os_var_array 
2e4f cd e1 0d				call addatohl 
2e52			 
2e52 cd d6 1a				call forth_push_numhl 
2e55			 
2e55				       NEXTW 
2e55 cd 6c ee			call parse_vector 
2e58 c3 b9 1e			jp macro_next 
2e5b				endm 
# End of macro NEXTW
2e5b			 
2e5b			.INC: 
2e5b				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2e5b 6f				db WORD_SYS_CORE+91             
2e5c b4 2e			dw .DEC            
2e5e 03				db 2 + 1 
2e5f .. 00			db "+!",0              
2e62				endm 
# End of macro CWHEAD
2e62			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2e62					if DEBUG_FORTH_WORDS_KEY 
2e62						DMARK "+s_" 
2e62 f5				push af  
2e63 3a 77 2e			ld a, (.dmark)  
2e66 32 62 ee			ld (debug_mark),a  
2e69 3a 78 2e			ld a, (.dmark+1)  
2e6c 32 63 ee			ld (debug_mark+1),a  
2e6f 3a 79 2e			ld a, (.dmark+2)  
2e72 32 64 ee			ld (debug_mark+2),a  
2e75 18 03			jr .pastdmark  
2e77 ..			.dmark: db "+s_"  
2e7a f1			.pastdmark: pop af  
2e7b			endm  
# End of macro DMARK
2e7b						CALLMONITOR 
2e7b cd 6f ee			call debug_vector  
2e7e				endm  
# End of macro CALLMONITOR
2e7e					endif 
2e7e			 
2e7e					FORTH_DSP_VALUEHL 
2e7e cd d2 1c			call macro_dsp_valuehl 
2e81				endm 
# End of macro FORTH_DSP_VALUEHL
2e81			 
2e81 e5					push hl   ; save address 
2e82			 
2e82					FORTH_DSP_POP 
2e82 cd 8a 1d			call macro_forth_dsp_pop 
2e85				endm 
# End of macro FORTH_DSP_POP
2e85			 
2e85					FORTH_DSP_VALUEHL 
2e85 cd d2 1c			call macro_dsp_valuehl 
2e88				endm 
# End of macro FORTH_DSP_VALUEHL
2e88			 
2e88 e5					push hl 
2e89					FORTH_DSP_POP 
2e89 cd 8a 1d			call macro_forth_dsp_pop 
2e8c				endm 
# End of macro FORTH_DSP_POP
2e8c e1					pop hl 
2e8d			 
2e8d					; hl contains value to add to byte at a 
2e8d				 
2e8d eb					ex de, hl 
2e8e			 
2e8e e1					pop hl 
2e8f			 
2e8f					if DEBUG_FORTH_WORDS 
2e8f						DMARK "INC" 
2e8f f5				push af  
2e90 3a a4 2e			ld a, (.dmark)  
2e93 32 62 ee			ld (debug_mark),a  
2e96 3a a5 2e			ld a, (.dmark+1)  
2e99 32 63 ee			ld (debug_mark+1),a  
2e9c 3a a6 2e			ld a, (.dmark+2)  
2e9f 32 64 ee			ld (debug_mark+2),a  
2ea2 18 03			jr .pastdmark  
2ea4 ..			.dmark: db "INC"  
2ea7 f1			.pastdmark: pop af  
2ea8			endm  
# End of macro DMARK
2ea8						CALLMONITOR 
2ea8 cd 6f ee			call debug_vector  
2eab				endm  
# End of macro CALLMONITOR
2eab					endif 
2eab			 
2eab 7e					ld a,(hl) 
2eac 83					add e 
2ead 77					ld (hl),a 
2eae			 
2eae			 
2eae			 
2eae				       NEXTW 
2eae cd 6c ee			call parse_vector 
2eb1 c3 b9 1e			jp macro_next 
2eb4				endm 
# End of macro NEXTW
2eb4			 
2eb4			.DEC: 
2eb4				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2eb4 6f				db WORD_SYS_CORE+91             
2eb5 0b 2f			dw .INC2            
2eb7 03				db 2 + 1 
2eb8 .. 00			db "-!",0              
2ebb				endm 
# End of macro CWHEAD
2ebb			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ebb					if DEBUG_FORTH_WORDS_KEY 
2ebb						DMARK "-s_" 
2ebb f5				push af  
2ebc 3a d0 2e			ld a, (.dmark)  
2ebf 32 62 ee			ld (debug_mark),a  
2ec2 3a d1 2e			ld a, (.dmark+1)  
2ec5 32 63 ee			ld (debug_mark+1),a  
2ec8 3a d2 2e			ld a, (.dmark+2)  
2ecb 32 64 ee			ld (debug_mark+2),a  
2ece 18 03			jr .pastdmark  
2ed0 ..			.dmark: db "-s_"  
2ed3 f1			.pastdmark: pop af  
2ed4			endm  
# End of macro DMARK
2ed4						CALLMONITOR 
2ed4 cd 6f ee			call debug_vector  
2ed7				endm  
# End of macro CALLMONITOR
2ed7					endif 
2ed7			 
2ed7					FORTH_DSP_VALUEHL 
2ed7 cd d2 1c			call macro_dsp_valuehl 
2eda				endm 
# End of macro FORTH_DSP_VALUEHL
2eda			 
2eda e5					push hl   ; save address 
2edb			 
2edb					FORTH_DSP_POP 
2edb cd 8a 1d			call macro_forth_dsp_pop 
2ede				endm 
# End of macro FORTH_DSP_POP
2ede			 
2ede					FORTH_DSP_VALUEHL 
2ede cd d2 1c			call macro_dsp_valuehl 
2ee1				endm 
# End of macro FORTH_DSP_VALUEHL
2ee1			 
2ee1					; hl contains value to add to byte at a 
2ee1				 
2ee1 eb					ex de, hl 
2ee2			 
2ee2 e1					pop hl 
2ee3			 
2ee3					if DEBUG_FORTH_WORDS 
2ee3						DMARK "DEC" 
2ee3 f5				push af  
2ee4 3a f8 2e			ld a, (.dmark)  
2ee7 32 62 ee			ld (debug_mark),a  
2eea 3a f9 2e			ld a, (.dmark+1)  
2eed 32 63 ee			ld (debug_mark+1),a  
2ef0 3a fa 2e			ld a, (.dmark+2)  
2ef3 32 64 ee			ld (debug_mark+2),a  
2ef6 18 03			jr .pastdmark  
2ef8 ..			.dmark: db "DEC"  
2efb f1			.pastdmark: pop af  
2efc			endm  
# End of macro DMARK
2efc						CALLMONITOR 
2efc cd 6f ee			call debug_vector  
2eff				endm  
# End of macro CALLMONITOR
2eff					endif 
2eff			 
2eff 7e					ld a,(hl) 
2f00 93					sub e 
2f01 77					ld (hl),a 
2f02			 
2f02			 
2f02					FORTH_DSP_POP 
2f02 cd 8a 1d			call macro_forth_dsp_pop 
2f05				endm 
# End of macro FORTH_DSP_POP
2f05			 
2f05				       NEXTW 
2f05 cd 6c ee			call parse_vector 
2f08 c3 b9 1e			jp macro_next 
2f0b				endm 
# End of macro NEXTW
2f0b			 
2f0b			.INC2: 
2f0b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f0b 6f				db WORD_SYS_CORE+91             
2f0c bb 2f			dw .DEC2            
2f0e 04				db 3 + 1 
2f0f .. 00			db "+2!",0              
2f13				endm 
# End of macro CWHEAD
2f13			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f13			 
2f13					if DEBUG_FORTH_WORDS_KEY 
2f13						DMARK "+2s" 
2f13 f5				push af  
2f14 3a 28 2f			ld a, (.dmark)  
2f17 32 62 ee			ld (debug_mark),a  
2f1a 3a 29 2f			ld a, (.dmark+1)  
2f1d 32 63 ee			ld (debug_mark+1),a  
2f20 3a 2a 2f			ld a, (.dmark+2)  
2f23 32 64 ee			ld (debug_mark+2),a  
2f26 18 03			jr .pastdmark  
2f28 ..			.dmark: db "+2s"  
2f2b f1			.pastdmark: pop af  
2f2c			endm  
# End of macro DMARK
2f2c						CALLMONITOR 
2f2c cd 6f ee			call debug_vector  
2f2f				endm  
# End of macro CALLMONITOR
2f2f					endif 
2f2f			 
2f2f					; Address 
2f2f			 
2f2f					FORTH_DSP_VALUEHL 
2f2f cd d2 1c			call macro_dsp_valuehl 
2f32				endm 
# End of macro FORTH_DSP_VALUEHL
2f32			 
2f32 e5					push hl    ; save address 
2f33			 
2f33					; load content into de 
2f33			 
2f33 5e					ld e,(hl) 
2f34 23					inc hl 
2f35 56					ld d, (hl) 
2f36			 
2f36					if DEBUG_FORTH_WORDS 
2f36						DMARK "+2a" 
2f36 f5				push af  
2f37 3a 4b 2f			ld a, (.dmark)  
2f3a 32 62 ee			ld (debug_mark),a  
2f3d 3a 4c 2f			ld a, (.dmark+1)  
2f40 32 63 ee			ld (debug_mark+1),a  
2f43 3a 4d 2f			ld a, (.dmark+2)  
2f46 32 64 ee			ld (debug_mark+2),a  
2f49 18 03			jr .pastdmark  
2f4b ..			.dmark: db "+2a"  
2f4e f1			.pastdmark: pop af  
2f4f			endm  
# End of macro DMARK
2f4f						CALLMONITOR 
2f4f cd 6f ee			call debug_vector  
2f52				endm  
# End of macro CALLMONITOR
2f52					endif 
2f52			 
2f52					FORTH_DSP_POP 
2f52 cd 8a 1d			call macro_forth_dsp_pop 
2f55				endm 
# End of macro FORTH_DSP_POP
2f55			 
2f55					; Get value to add 
2f55			 
2f55					FORTH_DSP_VALUE 
2f55 cd bb 1c			call macro_forth_dsp_value 
2f58				endm 
# End of macro FORTH_DSP_VALUE
2f58			 
2f58					if DEBUG_FORTH_WORDS 
2f58						DMARK "+2v" 
2f58 f5				push af  
2f59 3a 6d 2f			ld a, (.dmark)  
2f5c 32 62 ee			ld (debug_mark),a  
2f5f 3a 6e 2f			ld a, (.dmark+1)  
2f62 32 63 ee			ld (debug_mark+1),a  
2f65 3a 6f 2f			ld a, (.dmark+2)  
2f68 32 64 ee			ld (debug_mark+2),a  
2f6b 18 03			jr .pastdmark  
2f6d ..			.dmark: db "+2v"  
2f70 f1			.pastdmark: pop af  
2f71			endm  
# End of macro DMARK
2f71						CALLMONITOR 
2f71 cd 6f ee			call debug_vector  
2f74				endm  
# End of macro CALLMONITOR
2f74					endif 
2f74			 
2f74 19					add hl, de 
2f75			 
2f75					if DEBUG_FORTH_WORDS 
2f75						DMARK "+2+" 
2f75 f5				push af  
2f76 3a 8a 2f			ld a, (.dmark)  
2f79 32 62 ee			ld (debug_mark),a  
2f7c 3a 8b 2f			ld a, (.dmark+1)  
2f7f 32 63 ee			ld (debug_mark+1),a  
2f82 3a 8c 2f			ld a, (.dmark+2)  
2f85 32 64 ee			ld (debug_mark+2),a  
2f88 18 03			jr .pastdmark  
2f8a ..			.dmark: db "+2+"  
2f8d f1			.pastdmark: pop af  
2f8e			endm  
# End of macro DMARK
2f8e						CALLMONITOR 
2f8e cd 6f ee			call debug_vector  
2f91				endm  
# End of macro CALLMONITOR
2f91					endif 
2f91			 
2f91					; move result to de 
2f91			 
2f91 eb					ex de, hl 
2f92			 
2f92					; Address 
2f92			 
2f92 e1					pop hl 
2f93			 
2f93					; save it back 
2f93			 
2f93 73					ld (hl), e 
2f94 23					inc hl 
2f95 72					ld (hl), d 
2f96			 
2f96					if DEBUG_FORTH_WORDS 
2f96						DMARK "+2e" 
2f96 f5				push af  
2f97 3a ab 2f			ld a, (.dmark)  
2f9a 32 62 ee			ld (debug_mark),a  
2f9d 3a ac 2f			ld a, (.dmark+1)  
2fa0 32 63 ee			ld (debug_mark+1),a  
2fa3 3a ad 2f			ld a, (.dmark+2)  
2fa6 32 64 ee			ld (debug_mark+2),a  
2fa9 18 03			jr .pastdmark  
2fab ..			.dmark: db "+2e"  
2fae f1			.pastdmark: pop af  
2faf			endm  
# End of macro DMARK
2faf						CALLMONITOR 
2faf cd 6f ee			call debug_vector  
2fb2				endm  
# End of macro CALLMONITOR
2fb2					endif 
2fb2			 
2fb2			 
2fb2			 
2fb2					FORTH_DSP_POP 
2fb2 cd 8a 1d			call macro_forth_dsp_pop 
2fb5				endm 
# End of macro FORTH_DSP_POP
2fb5			 
2fb5			 
2fb5				       NEXTW 
2fb5 cd 6c ee			call parse_vector 
2fb8 c3 b9 1e			jp macro_next 
2fbb				endm 
# End of macro NEXTW
2fbb			 
2fbb			.DEC2: 
2fbb				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2fbb 6f				db WORD_SYS_CORE+91             
2fbc 6d 30			dw .GET2            
2fbe 04				db 3 + 1 
2fbf .. 00			db "-2!",0              
2fc3				endm 
# End of macro CWHEAD
2fc3			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2fc3			 
2fc3			 
2fc3					if DEBUG_FORTH_WORDS_KEY 
2fc3						DMARK "-2s" 
2fc3 f5				push af  
2fc4 3a d8 2f			ld a, (.dmark)  
2fc7 32 62 ee			ld (debug_mark),a  
2fca 3a d9 2f			ld a, (.dmark+1)  
2fcd 32 63 ee			ld (debug_mark+1),a  
2fd0 3a da 2f			ld a, (.dmark+2)  
2fd3 32 64 ee			ld (debug_mark+2),a  
2fd6 18 03			jr .pastdmark  
2fd8 ..			.dmark: db "-2s"  
2fdb f1			.pastdmark: pop af  
2fdc			endm  
# End of macro DMARK
2fdc						CALLMONITOR 
2fdc cd 6f ee			call debug_vector  
2fdf				endm  
# End of macro CALLMONITOR
2fdf					endif 
2fdf			 
2fdf					; Address 
2fdf			 
2fdf					FORTH_DSP_VALUEHL 
2fdf cd d2 1c			call macro_dsp_valuehl 
2fe2				endm 
# End of macro FORTH_DSP_VALUEHL
2fe2			 
2fe2 e5					push hl    ; save address 
2fe3			 
2fe3					; load content into de 
2fe3			 
2fe3 5e					ld e,(hl) 
2fe4 23					inc hl 
2fe5 56					ld d, (hl) 
2fe6			 
2fe6					if DEBUG_FORTH_WORDS 
2fe6						DMARK "-2a" 
2fe6 f5				push af  
2fe7 3a fb 2f			ld a, (.dmark)  
2fea 32 62 ee			ld (debug_mark),a  
2fed 3a fc 2f			ld a, (.dmark+1)  
2ff0 32 63 ee			ld (debug_mark+1),a  
2ff3 3a fd 2f			ld a, (.dmark+2)  
2ff6 32 64 ee			ld (debug_mark+2),a  
2ff9 18 03			jr .pastdmark  
2ffb ..			.dmark: db "-2a"  
2ffe f1			.pastdmark: pop af  
2fff			endm  
# End of macro DMARK
2fff						CALLMONITOR 
2fff cd 6f ee			call debug_vector  
3002				endm  
# End of macro CALLMONITOR
3002					endif 
3002			 
3002					FORTH_DSP_POP 
3002 cd 8a 1d			call macro_forth_dsp_pop 
3005				endm 
# End of macro FORTH_DSP_POP
3005			 
3005					; Get value to remove 
3005			 
3005					FORTH_DSP_VALUE 
3005 cd bb 1c			call macro_forth_dsp_value 
3008				endm 
# End of macro FORTH_DSP_VALUE
3008			 
3008					if DEBUG_FORTH_WORDS 
3008						DMARK "-2v" 
3008 f5				push af  
3009 3a 1d 30			ld a, (.dmark)  
300c 32 62 ee			ld (debug_mark),a  
300f 3a 1e 30			ld a, (.dmark+1)  
3012 32 63 ee			ld (debug_mark+1),a  
3015 3a 1f 30			ld a, (.dmark+2)  
3018 32 64 ee			ld (debug_mark+2),a  
301b 18 03			jr .pastdmark  
301d ..			.dmark: db "-2v"  
3020 f1			.pastdmark: pop af  
3021			endm  
# End of macro DMARK
3021						CALLMONITOR 
3021 cd 6f ee			call debug_vector  
3024				endm  
# End of macro CALLMONITOR
3024					endif 
3024			 
3024 eb					ex de, hl 
3025 ed 52				sbc hl, de 
3027			 
3027					if DEBUG_FORTH_WORDS 
3027						DMARK "-2d" 
3027 f5				push af  
3028 3a 3c 30			ld a, (.dmark)  
302b 32 62 ee			ld (debug_mark),a  
302e 3a 3d 30			ld a, (.dmark+1)  
3031 32 63 ee			ld (debug_mark+1),a  
3034 3a 3e 30			ld a, (.dmark+2)  
3037 32 64 ee			ld (debug_mark+2),a  
303a 18 03			jr .pastdmark  
303c ..			.dmark: db "-2d"  
303f f1			.pastdmark: pop af  
3040			endm  
# End of macro DMARK
3040						CALLMONITOR 
3040 cd 6f ee			call debug_vector  
3043				endm  
# End of macro CALLMONITOR
3043					endif 
3043			 
3043					; move result to de 
3043			 
3043 eb					ex de, hl 
3044			 
3044					; Address 
3044			 
3044 e1					pop hl 
3045			 
3045					; save it back 
3045			 
3045 73					ld (hl), e 
3046 23					inc hl 
3047 72					ld (hl), d 
3048			 
3048					if DEBUG_FORTH_WORDS 
3048						DMARK "-2e" 
3048 f5				push af  
3049 3a 5d 30			ld a, (.dmark)  
304c 32 62 ee			ld (debug_mark),a  
304f 3a 5e 30			ld a, (.dmark+1)  
3052 32 63 ee			ld (debug_mark+1),a  
3055 3a 5f 30			ld a, (.dmark+2)  
3058 32 64 ee			ld (debug_mark+2),a  
305b 18 03			jr .pastdmark  
305d ..			.dmark: db "-2e"  
3060 f1			.pastdmark: pop af  
3061			endm  
# End of macro DMARK
3061						CALLMONITOR 
3061 cd 6f ee			call debug_vector  
3064				endm  
# End of macro CALLMONITOR
3064					endif 
3064			 
3064			 
3064					FORTH_DSP_POP 
3064 cd 8a 1d			call macro_forth_dsp_pop 
3067				endm 
# End of macro FORTH_DSP_POP
3067			 
3067			 
3067			 
3067				       NEXTW 
3067 cd 6c ee			call parse_vector 
306a c3 b9 1e			jp macro_next 
306d				endm 
# End of macro NEXTW
306d			.GET2: 
306d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
306d 6f				db WORD_SYS_CORE+91             
306e a5 30			dw .BANG2            
3070 03				db 2 + 1 
3071 .. 00			db "2@",0              
3074				endm 
# End of macro CWHEAD
3074			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3074					if DEBUG_FORTH_WORDS_KEY 
3074						DMARK "2A_" 
3074 f5				push af  
3075 3a 89 30			ld a, (.dmark)  
3078 32 62 ee			ld (debug_mark),a  
307b 3a 8a 30			ld a, (.dmark+1)  
307e 32 63 ee			ld (debug_mark+1),a  
3081 3a 8b 30			ld a, (.dmark+2)  
3084 32 64 ee			ld (debug_mark+2),a  
3087 18 03			jr .pastdmark  
3089 ..			.dmark: db "2A_"  
308c f1			.pastdmark: pop af  
308d			endm  
# End of macro DMARK
308d						CALLMONITOR 
308d cd 6f ee			call debug_vector  
3090				endm  
# End of macro CALLMONITOR
3090					endif 
3090			 
3090					FORTH_DSP_VALUEHL 
3090 cd d2 1c			call macro_dsp_valuehl 
3093				endm 
# End of macro FORTH_DSP_VALUEHL
3093			 
3093 e5					push hl   ; save address 
3094			 
3094					FORTH_DSP_POP 
3094 cd 8a 1d			call macro_forth_dsp_pop 
3097				endm 
# End of macro FORTH_DSP_POP
3097			 
3097 e1					pop hl 
3098			 
3098 5e					ld e, (hl) 
3099 23					inc hl 
309a 56					ld d, (hl) 
309b			 
309b eb					ex de, hl 
309c			 
309c cd d6 1a				call forth_push_numhl 
309f			 
309f				       NEXTW 
309f cd 6c ee			call parse_vector 
30a2 c3 b9 1e			jp macro_next 
30a5				endm 
# End of macro NEXTW
30a5			.BANG2: 
30a5				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30a5 6f				db WORD_SYS_CORE+91             
30a6 e0 30			dw .CONFIG            
30a8 03				db 2 + 1 
30a9 .. 00			db "2!",0              
30ac				endm 
# End of macro CWHEAD
30ac			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30ac					if DEBUG_FORTH_WORDS_KEY 
30ac						DMARK "2S_" 
30ac f5				push af  
30ad 3a c1 30			ld a, (.dmark)  
30b0 32 62 ee			ld (debug_mark),a  
30b3 3a c2 30			ld a, (.dmark+1)  
30b6 32 63 ee			ld (debug_mark+1),a  
30b9 3a c3 30			ld a, (.dmark+2)  
30bc 32 64 ee			ld (debug_mark+2),a  
30bf 18 03			jr .pastdmark  
30c1 ..			.dmark: db "2S_"  
30c4 f1			.pastdmark: pop af  
30c5			endm  
# End of macro DMARK
30c5						CALLMONITOR 
30c5 cd 6f ee			call debug_vector  
30c8				endm  
# End of macro CALLMONITOR
30c8					endif 
30c8			 
30c8					FORTH_DSP_VALUEHL 
30c8 cd d2 1c			call macro_dsp_valuehl 
30cb				endm 
# End of macro FORTH_DSP_VALUEHL
30cb			 
30cb e5					push hl   ; save address 
30cc			 
30cc			 
30cc					FORTH_DSP_POP 
30cc cd 8a 1d			call macro_forth_dsp_pop 
30cf				endm 
# End of macro FORTH_DSP_POP
30cf			 
30cf					 
30cf					FORTH_DSP_VALUEHL 
30cf cd d2 1c			call macro_dsp_valuehl 
30d2				endm 
# End of macro FORTH_DSP_VALUEHL
30d2			 
30d2					FORTH_DSP_POP 
30d2 cd 8a 1d			call macro_forth_dsp_pop 
30d5				endm 
# End of macro FORTH_DSP_POP
30d5			 
30d5 eb					ex de, hl    ; value now in de 
30d6			 
30d6 e1					pop hl 
30d7			 
30d7 73					ld (hl), e 
30d8			 
30d8 23					inc hl 
30d9			 
30d9 72					ld (hl), d 
30da			 
30da			 
30da				       NEXTW 
30da cd 6c ee			call parse_vector 
30dd c3 b9 1e			jp macro_next 
30e0				endm 
# End of macro NEXTW
30e0			.CONFIG: 
30e0				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
30e0 6f				db WORD_SYS_CORE+91             
30e1 f4 30			dw .ADTOS            
30e3 07				db 6 + 1 
30e4 .. 00			db "CONFIG",0              
30eb				endm 
# End of macro CWHEAD
30eb			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
30eb			 
30eb cd 46 13				call config 
30ee					NEXTW 
30ee cd 6c ee			call parse_vector 
30f1 c3 b9 1e			jp macro_next 
30f4				endm 
# End of macro NEXTW
30f4			 
30f4			.ADTOS: 
30f4				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
30f4 6f				db WORD_SYS_CORE+91             
30f5 0d 31			dw .SBTOS            
30f7 03				db 2 + 1 
30f8 .. 00			db "1+",0              
30fb				endm 
# End of macro CWHEAD
30fb			; | 1+ ( u -- u )  Increment value on TOS | DONE 
30fb			 
30fb					FORTH_DSP_VALUEHL 
30fb cd d2 1c			call macro_dsp_valuehl 
30fe				endm 
# End of macro FORTH_DSP_VALUEHL
30fe e5					push hl 
30ff			 
30ff					FORTH_DSP_POP 
30ff cd 8a 1d			call macro_forth_dsp_pop 
3102				endm 
# End of macro FORTH_DSP_POP
3102 e1					pop hl 
3103			 
3103 23					inc hl 
3104 cd d6 1a				call forth_push_numhl 
3107					 
3107					NEXTW 
3107 cd 6c ee			call parse_vector 
310a c3 b9 1e			jp macro_next 
310d				endm 
# End of macro NEXTW
310d			.SBTOS: 
310d				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
310d 6f				db WORD_SYS_CORE+91             
310e 26 31			dw .ADSTORE            
3110 03				db 2 + 1 
3111 .. 00			db "1-",0              
3114				endm 
# End of macro CWHEAD
3114			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3114			 
3114					FORTH_DSP_VALUEHL 
3114 cd d2 1c			call macro_dsp_valuehl 
3117				endm 
# End of macro FORTH_DSP_VALUEHL
3117 e5					push hl 
3118			 
3118					FORTH_DSP_POP 
3118 cd 8a 1d			call macro_forth_dsp_pop 
311b				endm 
# End of macro FORTH_DSP_POP
311b e1					pop hl 
311c			 
311c 2b					dec hl 
311d cd d6 1a				call forth_push_numhl 
3120					 
3120					NEXTW 
3120 cd 6c ee			call parse_vector 
3123 c3 b9 1e			jp macro_next 
3126				endm 
# End of macro NEXTW
3126			.ADSTORE: 
3126				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3126 6f				db WORD_SYS_CORE+91             
3127 3f 31			dw .ADWSTORE            
3129 04				db 3 + 1 
312a .. 00			db "1+!",0              
312e				endm 
# End of macro CWHEAD
312e			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
312e			 
312e					FORTH_DSP_VALUEHL 
312e cd d2 1c			call macro_dsp_valuehl 
3131				endm 
# End of macro FORTH_DSP_VALUEHL
3131 e5					push hl 
3132			 
3132					FORTH_DSP_POP 
3132 cd 8a 1d			call macro_forth_dsp_pop 
3135				endm 
# End of macro FORTH_DSP_POP
3135 e1					pop hl 
3136			 
3136 7e					ld a, (hl) 
3137 3c					inc a 
3138 77					ld (hl), a 
3139					 
3139					NEXTW 
3139 cd 6c ee			call parse_vector 
313c c3 b9 1e			jp macro_next 
313f				endm 
# End of macro NEXTW
313f			.ADWSTORE: 
313f				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
313f 6f				db WORD_SYS_CORE+91             
3140 60 31			dw .SBSTORE            
3142 05				db 4 + 1 
3143 .. 00			db "1+2!",0              
3148				endm 
# End of macro CWHEAD
3148			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3148			 
3148					FORTH_DSP_VALUEHL 
3148 cd d2 1c			call macro_dsp_valuehl 
314b				endm 
# End of macro FORTH_DSP_VALUEHL
314b e5					push hl 
314c			 
314c					FORTH_DSP_POP 
314c cd 8a 1d			call macro_forth_dsp_pop 
314f				endm 
# End of macro FORTH_DSP_POP
314f e1					pop hl 
3150			 
3150 e5					push hl 
3151			 
3151 cd 3f 1e				call loadwordinhl 
3154 23					inc hl 
3155			 
3155 d1					pop de 
3156 eb					ex de, hl 
3157 73					ld (hl), e 
3158 23					inc hl 
3159 72					ld (hl), d 
315a					 
315a					NEXTW 
315a cd 6c ee			call parse_vector 
315d c3 b9 1e			jp macro_next 
3160				endm 
# End of macro NEXTW
3160			.SBSTORE: 
3160				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3160 6f				db WORD_SYS_CORE+91             
3161 79 31			dw .SBWSTORE            
3163 04				db 3 + 1 
3164 .. 00			db "1-!",0              
3168				endm 
# End of macro CWHEAD
3168			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3168			 
3168					FORTH_DSP_VALUEHL 
3168 cd d2 1c			call macro_dsp_valuehl 
316b				endm 
# End of macro FORTH_DSP_VALUEHL
316b e5					push hl 
316c			 
316c					FORTH_DSP_POP 
316c cd 8a 1d			call macro_forth_dsp_pop 
316f				endm 
# End of macro FORTH_DSP_POP
316f e1					pop hl 
3170			 
3170 7e					ld a, (hl) 
3171 3d					dec a 
3172 77					ld (hl), a 
3173					 
3173					NEXTW 
3173 cd 6c ee			call parse_vector 
3176 c3 b9 1e			jp macro_next 
3179				endm 
# End of macro NEXTW
3179			.SBWSTORE: 
3179				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3179 6f				db WORD_SYS_CORE+91             
317a 9a 31			dw .ENDCORE            
317c 05				db 4 + 1 
317d .. 00			db "1-2!",0              
3182				endm 
# End of macro CWHEAD
3182			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3182			 
3182					FORTH_DSP_VALUEHL 
3182 cd d2 1c			call macro_dsp_valuehl 
3185				endm 
# End of macro FORTH_DSP_VALUEHL
3185 e5					push hl 
3186			 
3186					FORTH_DSP_POP 
3186 cd 8a 1d			call macro_forth_dsp_pop 
3189				endm 
# End of macro FORTH_DSP_POP
3189 e1					pop hl 
318a			 
318a e5					push hl 
318b			 
318b cd 3f 1e				call loadwordinhl 
318e 2b					dec hl 
318f			 
318f d1					pop de 
3190 eb					ex de, hl 
3191 73					ld (hl), e 
3192 23					inc hl 
3193 72					ld (hl), d 
3194					 
3194					NEXTW 
3194 cd 6c ee			call parse_vector 
3197 c3 b9 1e			jp macro_next 
319a				endm 
# End of macro NEXTW
319a			.ENDCORE: 
319a			 
319a			; eof 
319a			 
319a			 
# End of file forth_words_core.asm
319a			include "forth_words_flow.asm" 
319a			 
319a			; | ## Program Flow Words 
319a			 
319a			.IF: 
319a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
319a 1e				db WORD_SYS_CORE+10             
319b 95 32			dw .THEN            
319d 03				db 2 + 1 
319e .. 00			db "IF",0              
31a1				endm 
# End of macro CWHEAD
31a1			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
31a1			; | | Note: currently not supporting ELSE or nested IF 
31a1			; 
31a1					if DEBUG_FORTH_WORDS_KEY 
31a1						DMARK "IF." 
31a1 f5				push af  
31a2 3a b6 31			ld a, (.dmark)  
31a5 32 62 ee			ld (debug_mark),a  
31a8 3a b7 31			ld a, (.dmark+1)  
31ab 32 63 ee			ld (debug_mark+1),a  
31ae 3a b8 31			ld a, (.dmark+2)  
31b1 32 64 ee			ld (debug_mark+2),a  
31b4 18 03			jr .pastdmark  
31b6 ..			.dmark: db "IF."  
31b9 f1			.pastdmark: pop af  
31ba			endm  
# End of macro DMARK
31ba						CALLMONITOR 
31ba cd 6f ee			call debug_vector  
31bd				endm  
# End of macro CALLMONITOR
31bd					endif 
31bd			; eval TOS 
31bd			 
31bd				FORTH_DSP_VALUEHL 
31bd cd d2 1c			call macro_dsp_valuehl 
31c0				endm 
# End of macro FORTH_DSP_VALUEHL
31c0			 
31c0			;	push hl 
31c0				FORTH_DSP_POP 
31c0 cd 8a 1d			call macro_forth_dsp_pop 
31c3				endm 
# End of macro FORTH_DSP_POP
31c3			;	pop hl 
31c3			 
31c3					if DEBUG_FORTH_WORDS 
31c3						DMARK "IF1" 
31c3 f5				push af  
31c4 3a d8 31			ld a, (.dmark)  
31c7 32 62 ee			ld (debug_mark),a  
31ca 3a d9 31			ld a, (.dmark+1)  
31cd 32 63 ee			ld (debug_mark+1),a  
31d0 3a da 31			ld a, (.dmark+2)  
31d3 32 64 ee			ld (debug_mark+2),a  
31d6 18 03			jr .pastdmark  
31d8 ..			.dmark: db "IF1"  
31db f1			.pastdmark: pop af  
31dc			endm  
# End of macro DMARK
31dc						CALLMONITOR 
31dc cd 6f ee			call debug_vector  
31df				endm  
# End of macro CALLMONITOR
31df					endif 
31df b7				or a        ; clear carry flag 
31e0 11 00 00			ld de, 0 
31e3 eb				ex de,hl 
31e4 ed 52			sbc hl, de 
31e6 c2 73 32			jp nz, .iftrue 
31e9			 
31e9					if DEBUG_FORTH_WORDS 
31e9						DMARK "IF2" 
31e9 f5				push af  
31ea 3a fe 31			ld a, (.dmark)  
31ed 32 62 ee			ld (debug_mark),a  
31f0 3a ff 31			ld a, (.dmark+1)  
31f3 32 63 ee			ld (debug_mark+1),a  
31f6 3a 00 32			ld a, (.dmark+2)  
31f9 32 64 ee			ld (debug_mark+2),a  
31fc 18 03			jr .pastdmark  
31fe ..			.dmark: db "IF2"  
3201 f1			.pastdmark: pop af  
3202			endm  
# End of macro DMARK
3202						CALLMONITOR 
3202 cd 6f ee			call debug_vector  
3205				endm  
# End of macro CALLMONITOR
3205					endif 
3205			 
3205			; if not true then skip to THEN 
3205			 
3205				; TODO get tok_ptr 
3205				; TODO consume toks until we get to THEN 
3205			 
3205 2a b9 e5			ld hl, (os_tok_ptr) 
3208					if DEBUG_FORTH_WORDS 
3208						DMARK "IF3" 
3208 f5				push af  
3209 3a 1d 32			ld a, (.dmark)  
320c 32 62 ee			ld (debug_mark),a  
320f 3a 1e 32			ld a, (.dmark+1)  
3212 32 63 ee			ld (debug_mark+1),a  
3215 3a 1f 32			ld a, (.dmark+2)  
3218 32 64 ee			ld (debug_mark+2),a  
321b 18 03			jr .pastdmark  
321d ..			.dmark: db "IF3"  
3220 f1			.pastdmark: pop af  
3221			endm  
# End of macro DMARK
3221						CALLMONITOR 
3221 cd 6f ee			call debug_vector  
3224				endm  
# End of macro CALLMONITOR
3224						 
3224					endif 
3224 11 6e 32			ld de, .ifthen 
3227					if DEBUG_FORTH_WORDS 
3227						DMARK "IF4" 
3227 f5				push af  
3228 3a 3c 32			ld a, (.dmark)  
322b 32 62 ee			ld (debug_mark),a  
322e 3a 3d 32			ld a, (.dmark+1)  
3231 32 63 ee			ld (debug_mark+1),a  
3234 3a 3e 32			ld a, (.dmark+2)  
3237 32 64 ee			ld (debug_mark+2),a  
323a 18 03			jr .pastdmark  
323c ..			.dmark: db "IF4"  
323f f1			.pastdmark: pop af  
3240			endm  
# End of macro DMARK
3240						CALLMONITOR 
3240 cd 6f ee			call debug_vector  
3243				endm  
# End of macro CALLMONITOR
3243					endif 
3243 cd b6 1f			call findnexttok  
3246			 
3246					if DEBUG_FORTH_WORDS 
3246						DMARK "IF5" 
3246 f5				push af  
3247 3a 5b 32			ld a, (.dmark)  
324a 32 62 ee			ld (debug_mark),a  
324d 3a 5c 32			ld a, (.dmark+1)  
3250 32 63 ee			ld (debug_mark+1),a  
3253 3a 5d 32			ld a, (.dmark+2)  
3256 32 64 ee			ld (debug_mark+2),a  
3259 18 03			jr .pastdmark  
325b ..			.dmark: db "IF5"  
325e f1			.pastdmark: pop af  
325f			endm  
# End of macro DMARK
325f						CALLMONITOR 
325f cd 6f ee			call debug_vector  
3262				endm  
# End of macro CALLMONITOR
3262					endif 
3262				; TODO replace below with ; exec using tok_ptr 
3262 22 b9 e5			ld (os_tok_ptr), hl 
3265 c3 3a 1f			jp exec1 
3268				NEXTW 
3268 cd 6c ee			call parse_vector 
326b c3 b9 1e			jp macro_next 
326e				endm 
# End of macro NEXTW
326e			 
326e .. 00		.ifthen:  db "THEN",0 
3273			 
3273			.iftrue:		 
3273				; Exec next words normally 
3273			 
3273				; if true then exec following IF as normal 
3273					if DEBUG_FORTH_WORDS 
3273						DMARK "IFT" 
3273 f5				push af  
3274 3a 88 32			ld a, (.dmark)  
3277 32 62 ee			ld (debug_mark),a  
327a 3a 89 32			ld a, (.dmark+1)  
327d 32 63 ee			ld (debug_mark+1),a  
3280 3a 8a 32			ld a, (.dmark+2)  
3283 32 64 ee			ld (debug_mark+2),a  
3286 18 03			jr .pastdmark  
3288 ..			.dmark: db "IFT"  
328b f1			.pastdmark: pop af  
328c			endm  
# End of macro DMARK
328c						CALLMONITOR 
328c cd 6f ee			call debug_vector  
328f				endm  
# End of macro CALLMONITOR
328f					endif 
328f			 
328f					NEXTW 
328f cd 6c ee			call parse_vector 
3292 c3 b9 1e			jp macro_next 
3295				endm 
# End of macro NEXTW
3295			.THEN: 
3295				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3295 1f				db WORD_SYS_CORE+11             
3296 c0 32			dw .ELSE            
3298 05				db 4 + 1 
3299 .. 00			db "THEN",0              
329e				endm 
# End of macro CWHEAD
329e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
329e					if DEBUG_FORTH_WORDS_KEY 
329e						DMARK "THN" 
329e f5				push af  
329f 3a b3 32			ld a, (.dmark)  
32a2 32 62 ee			ld (debug_mark),a  
32a5 3a b4 32			ld a, (.dmark+1)  
32a8 32 63 ee			ld (debug_mark+1),a  
32ab 3a b5 32			ld a, (.dmark+2)  
32ae 32 64 ee			ld (debug_mark+2),a  
32b1 18 03			jr .pastdmark  
32b3 ..			.dmark: db "THN"  
32b6 f1			.pastdmark: pop af  
32b7			endm  
# End of macro DMARK
32b7						CALLMONITOR 
32b7 cd 6f ee			call debug_vector  
32ba				endm  
# End of macro CALLMONITOR
32ba					endif 
32ba					NEXTW 
32ba cd 6c ee			call parse_vector 
32bd c3 b9 1e			jp macro_next 
32c0				endm 
# End of macro NEXTW
32c0			.ELSE: 
32c0				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32c0 20				db WORD_SYS_CORE+12             
32c1 eb 32			dw .DO            
32c3 03				db 2 + 1 
32c4 .. 00			db "ELSE",0              
32c9				endm 
# End of macro CWHEAD
32c9			; | ELSE ( -- ) Not supported - does nothing | TODO 
32c9			 
32c9					if DEBUG_FORTH_WORDS_KEY 
32c9						DMARK "ELS" 
32c9 f5				push af  
32ca 3a de 32			ld a, (.dmark)  
32cd 32 62 ee			ld (debug_mark),a  
32d0 3a df 32			ld a, (.dmark+1)  
32d3 32 63 ee			ld (debug_mark+1),a  
32d6 3a e0 32			ld a, (.dmark+2)  
32d9 32 64 ee			ld (debug_mark+2),a  
32dc 18 03			jr .pastdmark  
32de ..			.dmark: db "ELS"  
32e1 f1			.pastdmark: pop af  
32e2			endm  
# End of macro DMARK
32e2						CALLMONITOR 
32e2 cd 6f ee			call debug_vector  
32e5				endm  
# End of macro CALLMONITOR
32e5					endif 
32e5			 
32e5			 
32e5					NEXTW 
32e5 cd 6c ee			call parse_vector 
32e8 c3 b9 1e			jp macro_next 
32eb				endm 
# End of macro NEXTW
32eb			.DO: 
32eb				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32eb 21				db WORD_SYS_CORE+13             
32ec 15 34			dw .LOOP            
32ee 03				db 2 + 1 
32ef .. 00			db "DO",0              
32f2				endm 
# End of macro CWHEAD
32f2			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
32f2			 
32f2					if DEBUG_FORTH_WORDS_KEY 
32f2						DMARK "DO." 
32f2 f5				push af  
32f3 3a 07 33			ld a, (.dmark)  
32f6 32 62 ee			ld (debug_mark),a  
32f9 3a 08 33			ld a, (.dmark+1)  
32fc 32 63 ee			ld (debug_mark+1),a  
32ff 3a 09 33			ld a, (.dmark+2)  
3302 32 64 ee			ld (debug_mark+2),a  
3305 18 03			jr .pastdmark  
3307 ..			.dmark: db "DO."  
330a f1			.pastdmark: pop af  
330b			endm  
# End of macro DMARK
330b						CALLMONITOR 
330b cd 6f ee			call debug_vector  
330e				endm  
# End of macro CALLMONITOR
330e					endif 
330e			;  push pc to rsp stack past the DO 
330e			 
330e 2a b9 e5				ld hl, (os_tok_ptr) 
3311 23					inc hl   ; D 
3312 23					inc hl  ; O 
3313 23					inc hl   ; null 
3314					if DEBUG_FORTH_WORDS 
3314						DMARK "DO2" 
3314 f5				push af  
3315 3a 29 33			ld a, (.dmark)  
3318 32 62 ee			ld (debug_mark),a  
331b 3a 2a 33			ld a, (.dmark+1)  
331e 32 63 ee			ld (debug_mark+1),a  
3321 3a 2b 33			ld a, (.dmark+2)  
3324 32 64 ee			ld (debug_mark+2),a  
3327 18 03			jr .pastdmark  
3329 ..			.dmark: db "DO2"  
332c f1			.pastdmark: pop af  
332d			endm  
# End of macro DMARK
332d						CALLMONITOR 
332d cd 6f ee			call debug_vector  
3330				endm  
# End of macro CALLMONITOR
3330					endif 
3330					FORTH_RSP_NEXT 
3330 cd 7d 1a			call macro_forth_rsp_next 
3333				endm 
# End of macro FORTH_RSP_NEXT
3333					if DEBUG_FORTH_WORDS 
3333						DMARK "DO3" 
3333 f5				push af  
3334 3a 48 33			ld a, (.dmark)  
3337 32 62 ee			ld (debug_mark),a  
333a 3a 49 33			ld a, (.dmark+1)  
333d 32 63 ee			ld (debug_mark+1),a  
3340 3a 4a 33			ld a, (.dmark+2)  
3343 32 64 ee			ld (debug_mark+2),a  
3346 18 03			jr .pastdmark  
3348 ..			.dmark: db "DO3"  
334b f1			.pastdmark: pop af  
334c			endm  
# End of macro DMARK
334c						CALLMONITOR 
334c cd 6f ee			call debug_vector  
334f				endm  
# End of macro CALLMONITOR
334f					endif 
334f			 
334f					;if DEBUG_FORTH_WORDS 
334f				;		push hl 
334f			;		endif  
334f			 
334f			; get counters from data stack 
334f			 
334f			 
334f					FORTH_DSP_VALUEHL 
334f cd d2 1c			call macro_dsp_valuehl 
3352				endm 
# End of macro FORTH_DSP_VALUEHL
3352 e5					push hl		 ; hl now has starting counter which needs to be tos 
3353			 
3353					if DEBUG_FORTH_WORDS 
3353						DMARK "DO4" 
3353 f5				push af  
3354 3a 68 33			ld a, (.dmark)  
3357 32 62 ee			ld (debug_mark),a  
335a 3a 69 33			ld a, (.dmark+1)  
335d 32 63 ee			ld (debug_mark+1),a  
3360 3a 6a 33			ld a, (.dmark+2)  
3363 32 64 ee			ld (debug_mark+2),a  
3366 18 03			jr .pastdmark  
3368 ..			.dmark: db "DO4"  
336b f1			.pastdmark: pop af  
336c			endm  
# End of macro DMARK
336c						CALLMONITOR 
336c cd 6f ee			call debug_vector  
336f				endm  
# End of macro CALLMONITOR
336f					endif 
336f					FORTH_DSP_POP 
336f cd 8a 1d			call macro_forth_dsp_pop 
3372				endm 
# End of macro FORTH_DSP_POP
3372			 
3372					if DEBUG_FORTH_WORDS 
3372						DMARK "DO5" 
3372 f5				push af  
3373 3a 87 33			ld a, (.dmark)  
3376 32 62 ee			ld (debug_mark),a  
3379 3a 88 33			ld a, (.dmark+1)  
337c 32 63 ee			ld (debug_mark+1),a  
337f 3a 89 33			ld a, (.dmark+2)  
3382 32 64 ee			ld (debug_mark+2),a  
3385 18 03			jr .pastdmark  
3387 ..			.dmark: db "DO5"  
338a f1			.pastdmark: pop af  
338b			endm  
# End of macro DMARK
338b						CALLMONITOR 
338b cd 6f ee			call debug_vector  
338e				endm  
# End of macro CALLMONITOR
338e					endif 
338e			 
338e					FORTH_DSP_VALUEHL 
338e cd d2 1c			call macro_dsp_valuehl 
3391				endm 
# End of macro FORTH_DSP_VALUEHL
3391			;		push hl		 ; hl now has starting limit counter 
3391			 
3391					if DEBUG_FORTH_WORDS 
3391						DMARK "DO6" 
3391 f5				push af  
3392 3a a6 33			ld a, (.dmark)  
3395 32 62 ee			ld (debug_mark),a  
3398 3a a7 33			ld a, (.dmark+1)  
339b 32 63 ee			ld (debug_mark+1),a  
339e 3a a8 33			ld a, (.dmark+2)  
33a1 32 64 ee			ld (debug_mark+2),a  
33a4 18 03			jr .pastdmark  
33a6 ..			.dmark: db "DO6"  
33a9 f1			.pastdmark: pop af  
33aa			endm  
# End of macro DMARK
33aa						CALLMONITOR 
33aa cd 6f ee			call debug_vector  
33ad				endm  
# End of macro CALLMONITOR
33ad					endif 
33ad					FORTH_DSP_POP 
33ad cd 8a 1d			call macro_forth_dsp_pop 
33b0				endm 
# End of macro FORTH_DSP_POP
33b0			 
33b0			; put counters on the loop stack 
33b0			 
33b0			;		pop hl			 ; limit counter 
33b0 d1					pop de			; start counter 
33b1			 
33b1					; push limit counter 
33b1			 
33b1					if DEBUG_FORTH_WORDS 
33b1						DMARK "DO7" 
33b1 f5				push af  
33b2 3a c6 33			ld a, (.dmark)  
33b5 32 62 ee			ld (debug_mark),a  
33b8 3a c7 33			ld a, (.dmark+1)  
33bb 32 63 ee			ld (debug_mark+1),a  
33be 3a c8 33			ld a, (.dmark+2)  
33c1 32 64 ee			ld (debug_mark+2),a  
33c4 18 03			jr .pastdmark  
33c6 ..			.dmark: db "DO7"  
33c9 f1			.pastdmark: pop af  
33ca			endm  
# End of macro DMARK
33ca						CALLMONITOR 
33ca cd 6f ee			call debug_vector  
33cd				endm  
# End of macro CALLMONITOR
33cd					endif 
33cd					FORTH_LOOP_NEXT 
33cd cd 03 1d			call macro_forth_loop_next 
33d0				endm 
# End of macro FORTH_LOOP_NEXT
33d0			 
33d0					; push start counter 
33d0			 
33d0 eb					ex de, hl 
33d1					if DEBUG_FORTH_WORDS 
33d1						DMARK "DO7" 
33d1 f5				push af  
33d2 3a e6 33			ld a, (.dmark)  
33d5 32 62 ee			ld (debug_mark),a  
33d8 3a e7 33			ld a, (.dmark+1)  
33db 32 63 ee			ld (debug_mark+1),a  
33de 3a e8 33			ld a, (.dmark+2)  
33e1 32 64 ee			ld (debug_mark+2),a  
33e4 18 03			jr .pastdmark  
33e6 ..			.dmark: db "DO7"  
33e9 f1			.pastdmark: pop af  
33ea			endm  
# End of macro DMARK
33ea						CALLMONITOR 
33ea cd 6f ee			call debug_vector  
33ed				endm  
# End of macro CALLMONITOR
33ed					endif 
33ed					FORTH_LOOP_NEXT 
33ed cd 03 1d			call macro_forth_loop_next 
33f0				endm 
# End of macro FORTH_LOOP_NEXT
33f0			 
33f0			 
33f0					; init first round of I counter 
33f0			 
33f0 22 dd e5				ld (os_current_i), hl 
33f3			 
33f3					if DEBUG_FORTH_WORDS 
33f3						DMARK "DO8" 
33f3 f5				push af  
33f4 3a 08 34			ld a, (.dmark)  
33f7 32 62 ee			ld (debug_mark),a  
33fa 3a 09 34			ld a, (.dmark+1)  
33fd 32 63 ee			ld (debug_mark+1),a  
3400 3a 0a 34			ld a, (.dmark+2)  
3403 32 64 ee			ld (debug_mark+2),a  
3406 18 03			jr .pastdmark  
3408 ..			.dmark: db "DO8"  
340b f1			.pastdmark: pop af  
340c			endm  
# End of macro DMARK
340c						CALLMONITOR 
340c cd 6f ee			call debug_vector  
340f				endm  
# End of macro CALLMONITOR
340f					endif 
340f			 
340f					NEXTW 
340f cd 6c ee			call parse_vector 
3412 c3 b9 1e			jp macro_next 
3415				endm 
# End of macro NEXTW
3415			.LOOP: 
3415				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3415 22				db WORD_SYS_CORE+14             
3416 33 35			dw .I            
3418 05				db 4 + 1 
3419 .. 00			db "LOOP",0              
341e				endm 
# End of macro CWHEAD
341e			; | LOOP ( -- ) Increment and test loop counter  | DONE 
341e			 
341e				; pop tos as current loop count to hl 
341e			 
341e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
341e			 
341e				FORTH_LOOP_TOS 
341e cd 36 1d			call macro_forth_loop_tos 
3421				endm 
# End of macro FORTH_LOOP_TOS
3421 e5				push hl 
3422			 
3422					if DEBUG_FORTH_WORDS_KEY 
3422						DMARK "LOP" 
3422 f5				push af  
3423 3a 37 34			ld a, (.dmark)  
3426 32 62 ee			ld (debug_mark),a  
3429 3a 38 34			ld a, (.dmark+1)  
342c 32 63 ee			ld (debug_mark+1),a  
342f 3a 39 34			ld a, (.dmark+2)  
3432 32 64 ee			ld (debug_mark+2),a  
3435 18 03			jr .pastdmark  
3437 ..			.dmark: db "LOP"  
343a f1			.pastdmark: pop af  
343b			endm  
# End of macro DMARK
343b						CALLMONITOR 
343b cd 6f ee			call debug_vector  
343e				endm  
# End of macro CALLMONITOR
343e					endif 
343e				; next item on the stack is the limit. get it 
343e			 
343e			 
343e				FORTH_LOOP_POP 
343e cd 40 1d			call macro_forth_loop_pop 
3441				endm 
# End of macro FORTH_LOOP_POP
3441			 
3441				FORTH_LOOP_TOS 
3441 cd 36 1d			call macro_forth_loop_tos 
3444				endm 
# End of macro FORTH_LOOP_TOS
3444			 
3444 d1				pop de		 ; de = i, hl = limit 
3445			 
3445					if DEBUG_FORTH_WORDS 
3445						DMARK "LP1" 
3445 f5				push af  
3446 3a 5a 34			ld a, (.dmark)  
3449 32 62 ee			ld (debug_mark),a  
344c 3a 5b 34			ld a, (.dmark+1)  
344f 32 63 ee			ld (debug_mark+1),a  
3452 3a 5c 34			ld a, (.dmark+2)  
3455 32 64 ee			ld (debug_mark+2),a  
3458 18 03			jr .pastdmark  
345a ..			.dmark: db "LP1"  
345d f1			.pastdmark: pop af  
345e			endm  
# End of macro DMARK
345e						CALLMONITOR 
345e cd 6f ee			call debug_vector  
3461				endm  
# End of macro CALLMONITOR
3461					endif 
3461			 
3461				; go back to previous word 
3461			 
3461 d5				push de    ; save I for inc later 
3462			 
3462			 
3462				; get limit 
3462				;  is I at limit? 
3462			 
3462			 
3462					if DEBUG_FORTH_WORDS 
3462						DMARK "LP1" 
3462 f5				push af  
3463 3a 77 34			ld a, (.dmark)  
3466 32 62 ee			ld (debug_mark),a  
3469 3a 78 34			ld a, (.dmark+1)  
346c 32 63 ee			ld (debug_mark+1),a  
346f 3a 79 34			ld a, (.dmark+2)  
3472 32 64 ee			ld (debug_mark+2),a  
3475 18 03			jr .pastdmark  
3477 ..			.dmark: db "LP1"  
347a f1			.pastdmark: pop af  
347b			endm  
# End of macro DMARK
347b						CALLMONITOR 
347b cd 6f ee			call debug_vector  
347e				endm  
# End of macro CALLMONITOR
347e					endif 
347e			 
347e ed 52			sbc hl, de 
3480			 
3480			 
3480				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3480			 
3480 20 29				jr nz, .loopnotdone 
3482			 
3482 e1				pop hl   ; get rid of saved I 
3483				FORTH_LOOP_POP     ; get rid of limit 
3483 cd 40 1d			call macro_forth_loop_pop 
3486				endm 
# End of macro FORTH_LOOP_POP
3486			 
3486				FORTH_RSP_POP     ; get rid of DO ptr 
3486 cd 9e 1a			call macro_forth_rsp_pop 
3489				endm 
# End of macro FORTH_RSP_POP
3489			 
3489			if DEBUG_FORTH_WORDS 
3489						DMARK "LP>" 
3489 f5				push af  
348a 3a 9e 34			ld a, (.dmark)  
348d 32 62 ee			ld (debug_mark),a  
3490 3a 9f 34			ld a, (.dmark+1)  
3493 32 63 ee			ld (debug_mark+1),a  
3496 3a a0 34			ld a, (.dmark+2)  
3499 32 64 ee			ld (debug_mark+2),a  
349c 18 03			jr .pastdmark  
349e ..			.dmark: db "LP>"  
34a1 f1			.pastdmark: pop af  
34a2			endm  
# End of macro DMARK
34a2				CALLMONITOR 
34a2 cd 6f ee			call debug_vector  
34a5				endm  
# End of macro CALLMONITOR
34a5			endif 
34a5			 
34a5					NEXTW 
34a5 cd 6c ee			call parse_vector 
34a8 c3 b9 1e			jp macro_next 
34ab				endm 
# End of macro NEXTW
34ab				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34ab			 
34ab			.loopnotdone: 
34ab			 
34ab e1				pop hl    ; get I 
34ac 23				inc hl 
34ad			 
34ad			   	; save new I 
34ad			 
34ad			 
34ad					; set I counter 
34ad			 
34ad 22 dd e5				ld (os_current_i), hl 
34b0			 
34b0					if DEBUG_FORTH_WORDS 
34b0						DMARK "LPN" 
34b0 f5				push af  
34b1 3a c5 34			ld a, (.dmark)  
34b4 32 62 ee			ld (debug_mark),a  
34b7 3a c6 34			ld a, (.dmark+1)  
34ba 32 63 ee			ld (debug_mark+1),a  
34bd 3a c7 34			ld a, (.dmark+2)  
34c0 32 64 ee			ld (debug_mark+2),a  
34c3 18 03			jr .pastdmark  
34c5 ..			.dmark: db "LPN"  
34c8 f1			.pastdmark: pop af  
34c9			endm  
# End of macro DMARK
34c9					CALLMONITOR 
34c9 cd 6f ee			call debug_vector  
34cc				endm  
# End of macro CALLMONITOR
34cc					endif 
34cc					 
34cc				FORTH_LOOP_NEXT 
34cc cd 03 1d			call macro_forth_loop_next 
34cf				endm 
# End of macro FORTH_LOOP_NEXT
34cf			 
34cf			 
34cf					if DEBUG_FORTH_WORDS 
34cf eb						ex de,hl 
34d0					endif 
34d0			 
34d0			;	; get DO ptr 
34d0			; 
34d0					if DEBUG_FORTH_WORDS 
34d0						DMARK "LP7" 
34d0 f5				push af  
34d1 3a e5 34			ld a, (.dmark)  
34d4 32 62 ee			ld (debug_mark),a  
34d7 3a e6 34			ld a, (.dmark+1)  
34da 32 63 ee			ld (debug_mark+1),a  
34dd 3a e7 34			ld a, (.dmark+2)  
34e0 32 64 ee			ld (debug_mark+2),a  
34e3 18 03			jr .pastdmark  
34e5 ..			.dmark: db "LP7"  
34e8 f1			.pastdmark: pop af  
34e9			endm  
# End of macro DMARK
34e9					CALLMONITOR 
34e9 cd 6f ee			call debug_vector  
34ec				endm  
# End of macro CALLMONITOR
34ec					endif 
34ec				FORTH_RSP_TOS 
34ec cd 94 1a			call macro_forth_rsp_tos 
34ef				endm 
# End of macro FORTH_RSP_TOS
34ef			 
34ef					if DEBUG_FORTH_WORDS 
34ef						DMARK "LP8" 
34ef f5				push af  
34f0 3a 04 35			ld a, (.dmark)  
34f3 32 62 ee			ld (debug_mark),a  
34f6 3a 05 35			ld a, (.dmark+1)  
34f9 32 63 ee			ld (debug_mark+1),a  
34fc 3a 06 35			ld a, (.dmark+2)  
34ff 32 64 ee			ld (debug_mark+2),a  
3502 18 03			jr .pastdmark  
3504 ..			.dmark: db "LP8"  
3507 f1			.pastdmark: pop af  
3508			endm  
# End of macro DMARK
3508					CALLMONITOR 
3508 cd 6f ee			call debug_vector  
350b				endm  
# End of macro CALLMONITOR
350b					endif 
350b				;push hl 
350b			 
350b				; not going to DO any more 
350b				; get rid of the RSP pointer as DO will add it back in 
350b				;FORTH_RSP_POP 
350b				;pop hl 
350b			 
350b				;ld hl,(cli_ret_sp) 
350b				;ld e, (hl) 
350b				;inc hl 
350b				;ld d, (hl) 
350b				;ex de,hl 
350b 22 b9 e5			ld (os_tok_ptr), hl 
350e					if DEBUG_FORTH_WORDS 
350e						DMARK "LP<" 
350e f5				push af  
350f 3a 23 35			ld a, (.dmark)  
3512 32 62 ee			ld (debug_mark),a  
3515 3a 24 35			ld a, (.dmark+1)  
3518 32 63 ee			ld (debug_mark+1),a  
351b 3a 25 35			ld a, (.dmark+2)  
351e 32 64 ee			ld (debug_mark+2),a  
3521 18 03			jr .pastdmark  
3523 ..			.dmark: db "LP<"  
3526 f1			.pastdmark: pop af  
3527			endm  
# End of macro DMARK
3527					CALLMONITOR 
3527 cd 6f ee			call debug_vector  
352a				endm  
# End of macro CALLMONITOR
352a				endif 
352a c3 3a 1f			jp exec1 
352d			 
352d					 
352d			 
352d			 
352d					NEXTW 
352d cd 6c ee			call parse_vector 
3530 c3 b9 1e			jp macro_next 
3533				endm 
# End of macro NEXTW
3533			.I:  
3533			 
3533				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3533 5e				db WORD_SYS_CORE+74             
3534 61 35			dw .DLOOP            
3536 02				db 1 + 1 
3537 .. 00			db "I",0              
3539				endm 
# End of macro CWHEAD
3539			; | I ( -- ) Current loop counter | DONE 
3539					if DEBUG_FORTH_WORDS_KEY 
3539						DMARK "I.." 
3539 f5				push af  
353a 3a 4e 35			ld a, (.dmark)  
353d 32 62 ee			ld (debug_mark),a  
3540 3a 4f 35			ld a, (.dmark+1)  
3543 32 63 ee			ld (debug_mark+1),a  
3546 3a 50 35			ld a, (.dmark+2)  
3549 32 64 ee			ld (debug_mark+2),a  
354c 18 03			jr .pastdmark  
354e ..			.dmark: db "I.."  
3551 f1			.pastdmark: pop af  
3552			endm  
# End of macro DMARK
3552						CALLMONITOR 
3552 cd 6f ee			call debug_vector  
3555				endm  
# End of macro CALLMONITOR
3555					endif 
3555			 
3555 2a dd e5				ld hl,(os_current_i) 
3558 cd d6 1a				call forth_push_numhl 
355b			 
355b					NEXTW 
355b cd 6c ee			call parse_vector 
355e c3 b9 1e			jp macro_next 
3561				endm 
# End of macro NEXTW
3561			.DLOOP: 
3561				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3561 5f				db WORD_SYS_CORE+75             
3562 48 36			dw .REPEAT            
3564 06				db 5 + 1 
3565 .. 00			db "-LOOP",0              
356b				endm 
# End of macro CWHEAD
356b			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
356b				; pop tos as current loop count to hl 
356b					if DEBUG_FORTH_WORDS_KEY 
356b						DMARK "-LP" 
356b f5				push af  
356c 3a 80 35			ld a, (.dmark)  
356f 32 62 ee			ld (debug_mark),a  
3572 3a 81 35			ld a, (.dmark+1)  
3575 32 63 ee			ld (debug_mark+1),a  
3578 3a 82 35			ld a, (.dmark+2)  
357b 32 64 ee			ld (debug_mark+2),a  
357e 18 03			jr .pastdmark  
3580 ..			.dmark: db "-LP"  
3583 f1			.pastdmark: pop af  
3584			endm  
# End of macro DMARK
3584						CALLMONITOR 
3584 cd 6f ee			call debug_vector  
3587				endm  
# End of macro CALLMONITOR
3587					endif 
3587			 
3587				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3587			 
3587				FORTH_LOOP_TOS 
3587 cd 36 1d			call macro_forth_loop_tos 
358a				endm 
# End of macro FORTH_LOOP_TOS
358a e5				push hl 
358b			 
358b					if DEBUG_FORTH_WORDS 
358b						DMARK "-LP" 
358b f5				push af  
358c 3a a0 35			ld a, (.dmark)  
358f 32 62 ee			ld (debug_mark),a  
3592 3a a1 35			ld a, (.dmark+1)  
3595 32 63 ee			ld (debug_mark+1),a  
3598 3a a2 35			ld a, (.dmark+2)  
359b 32 64 ee			ld (debug_mark+2),a  
359e 18 03			jr .pastdmark  
35a0 ..			.dmark: db "-LP"  
35a3 f1			.pastdmark: pop af  
35a4			endm  
# End of macro DMARK
35a4						CALLMONITOR 
35a4 cd 6f ee			call debug_vector  
35a7				endm  
# End of macro CALLMONITOR
35a7					endif 
35a7				; next item on the stack is the limit. get it 
35a7			 
35a7			 
35a7				FORTH_LOOP_POP 
35a7 cd 40 1d			call macro_forth_loop_pop 
35aa				endm 
# End of macro FORTH_LOOP_POP
35aa			 
35aa				FORTH_LOOP_TOS 
35aa cd 36 1d			call macro_forth_loop_tos 
35ad				endm 
# End of macro FORTH_LOOP_TOS
35ad			 
35ad d1				pop de		 ; de = i, hl = limit 
35ae			 
35ae					if DEBUG_FORTH_WORDS 
35ae						DMARK "-L1" 
35ae f5				push af  
35af 3a c3 35			ld a, (.dmark)  
35b2 32 62 ee			ld (debug_mark),a  
35b5 3a c4 35			ld a, (.dmark+1)  
35b8 32 63 ee			ld (debug_mark+1),a  
35bb 3a c5 35			ld a, (.dmark+2)  
35be 32 64 ee			ld (debug_mark+2),a  
35c1 18 03			jr .pastdmark  
35c3 ..			.dmark: db "-L1"  
35c6 f1			.pastdmark: pop af  
35c7			endm  
# End of macro DMARK
35c7						CALLMONITOR 
35c7 cd 6f ee			call debug_vector  
35ca				endm  
# End of macro CALLMONITOR
35ca					endif 
35ca			 
35ca				; go back to previous word 
35ca			 
35ca d5				push de    ; save I for inc later 
35cb			 
35cb			 
35cb				; get limit 
35cb				;  is I at limit? 
35cb			 
35cb			 
35cb					if DEBUG_FORTH_WORDS 
35cb						DMARK "-L1" 
35cb f5				push af  
35cc 3a e0 35			ld a, (.dmark)  
35cf 32 62 ee			ld (debug_mark),a  
35d2 3a e1 35			ld a, (.dmark+1)  
35d5 32 63 ee			ld (debug_mark+1),a  
35d8 3a e2 35			ld a, (.dmark+2)  
35db 32 64 ee			ld (debug_mark+2),a  
35de 18 03			jr .pastdmark  
35e0 ..			.dmark: db "-L1"  
35e3 f1			.pastdmark: pop af  
35e4			endm  
# End of macro DMARK
35e4						CALLMONITOR 
35e4 cd 6f ee			call debug_vector  
35e7				endm  
# End of macro CALLMONITOR
35e7					endif 
35e7			 
35e7 ed 52			sbc hl, de 
35e9			 
35e9			 
35e9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35e9			 
35e9 20 29				jr nz, .mloopnotdone 
35eb			 
35eb e1				pop hl   ; get rid of saved I 
35ec				FORTH_LOOP_POP     ; get rid of limit 
35ec cd 40 1d			call macro_forth_loop_pop 
35ef				endm 
# End of macro FORTH_LOOP_POP
35ef			 
35ef				FORTH_RSP_POP     ; get rid of DO ptr 
35ef cd 9e 1a			call macro_forth_rsp_pop 
35f2				endm 
# End of macro FORTH_RSP_POP
35f2			 
35f2			if DEBUG_FORTH_WORDS 
35f2						DMARK "-L>" 
35f2 f5				push af  
35f3 3a 07 36			ld a, (.dmark)  
35f6 32 62 ee			ld (debug_mark),a  
35f9 3a 08 36			ld a, (.dmark+1)  
35fc 32 63 ee			ld (debug_mark+1),a  
35ff 3a 09 36			ld a, (.dmark+2)  
3602 32 64 ee			ld (debug_mark+2),a  
3605 18 03			jr .pastdmark  
3607 ..			.dmark: db "-L>"  
360a f1			.pastdmark: pop af  
360b			endm  
# End of macro DMARK
360b				CALLMONITOR 
360b cd 6f ee			call debug_vector  
360e				endm  
# End of macro CALLMONITOR
360e			endif 
360e			 
360e					NEXTW 
360e cd 6c ee			call parse_vector 
3611 c3 b9 1e			jp macro_next 
3614				endm 
# End of macro NEXTW
3614				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3614			 
3614			.mloopnotdone: 
3614			 
3614 e1				pop hl    ; get I 
3615 2b				dec hl 
3616			 
3616			   	; save new I 
3616			 
3616			 
3616					; set I counter 
3616			 
3616 22 dd e5				ld (os_current_i), hl 
3619			 
3619					 
3619				FORTH_LOOP_NEXT 
3619 cd 03 1d			call macro_forth_loop_next 
361c				endm 
# End of macro FORTH_LOOP_NEXT
361c			 
361c			 
361c					if DEBUG_FORTH_WORDS 
361c eb						ex de,hl 
361d					endif 
361d			 
361d			;	; get DO ptr 
361d			; 
361d				FORTH_RSP_TOS 
361d cd 94 1a			call macro_forth_rsp_tos 
3620				endm 
# End of macro FORTH_RSP_TOS
3620			 
3620				;push hl 
3620			 
3620				; not going to DO any more 
3620				; get rid of the RSP pointer as DO will add it back in 
3620				;FORTH_RSP_POP 
3620				;pop hl 
3620			 
3620			 
3620 22 b9 e5			ld (os_tok_ptr), hl 
3623					if DEBUG_FORTH_WORDS 
3623						DMARK "-L<" 
3623 f5				push af  
3624 3a 38 36			ld a, (.dmark)  
3627 32 62 ee			ld (debug_mark),a  
362a 3a 39 36			ld a, (.dmark+1)  
362d 32 63 ee			ld (debug_mark+1),a  
3630 3a 3a 36			ld a, (.dmark+2)  
3633 32 64 ee			ld (debug_mark+2),a  
3636 18 03			jr .pastdmark  
3638 ..			.dmark: db "-L<"  
363b f1			.pastdmark: pop af  
363c			endm  
# End of macro DMARK
363c					CALLMONITOR 
363c cd 6f ee			call debug_vector  
363f				endm  
# End of macro CALLMONITOR
363f				endif 
363f c3 3a 1f			jp exec1 
3642			 
3642					 
3642			 
3642			 
3642			 
3642				NEXTW 
3642 cd 6c ee			call parse_vector 
3645 c3 b9 1e			jp macro_next 
3648				endm 
# End of macro NEXTW
3648			 
3648			 
3648			 
3648			 
3648			.REPEAT: 
3648				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3648 71				db WORD_SYS_CORE+93             
3649 9e 36			dw .UNTIL            
364b 06				db 5 + 1 
364c .. 00			db "REPEAT",0              
3653				endm 
# End of macro CWHEAD
3653			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3653			;  push pc to rsp stack past the REPEAT 
3653					if DEBUG_FORTH_WORDS_KEY 
3653						DMARK "REP" 
3653 f5				push af  
3654 3a 68 36			ld a, (.dmark)  
3657 32 62 ee			ld (debug_mark),a  
365a 3a 69 36			ld a, (.dmark+1)  
365d 32 63 ee			ld (debug_mark+1),a  
3660 3a 6a 36			ld a, (.dmark+2)  
3663 32 64 ee			ld (debug_mark+2),a  
3666 18 03			jr .pastdmark  
3668 ..			.dmark: db "REP"  
366b f1			.pastdmark: pop af  
366c			endm  
# End of macro DMARK
366c						CALLMONITOR 
366c cd 6f ee			call debug_vector  
366f				endm  
# End of macro CALLMONITOR
366f					endif 
366f			 
366f 2a b9 e5				ld hl, (os_tok_ptr) 
3672 23					inc hl   ; R 
3673 23					inc hl  ; E 
3674 23					inc hl   ; P 
3675 23					inc hl   ; E 
3676 23					inc hl   ; A 
3677 23					inc hl   ; T 
3678 23					inc hl   ; zero 
3679					FORTH_RSP_NEXT 
3679 cd 7d 1a			call macro_forth_rsp_next 
367c				endm 
# End of macro FORTH_RSP_NEXT
367c			 
367c			 
367c					if DEBUG_FORTH_WORDS 
367c						DMARK "REP" 
367c f5				push af  
367d 3a 91 36			ld a, (.dmark)  
3680 32 62 ee			ld (debug_mark),a  
3683 3a 92 36			ld a, (.dmark+1)  
3686 32 63 ee			ld (debug_mark+1),a  
3689 3a 93 36			ld a, (.dmark+2)  
368c 32 64 ee			ld (debug_mark+2),a  
368f 18 03			jr .pastdmark  
3691 ..			.dmark: db "REP"  
3694 f1			.pastdmark: pop af  
3695			endm  
# End of macro DMARK
3695						;pop bc    ; TODO BUG ?????? what is this for???? 
3695						CALLMONITOR 
3695 cd 6f ee			call debug_vector  
3698				endm  
# End of macro CALLMONITOR
3698					endif 
3698			 
3698					NEXTW 
3698 cd 6c ee			call parse_vector 
369b c3 b9 1e			jp macro_next 
369e				endm 
# End of macro NEXTW
369e			;	       NEXTW 
369e			 
369e			.UNTIL: 
369e				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
369e 72				db WORD_SYS_CORE+94             
369f 3b 37			dw .ENDFLOW            
36a1 06				db 5 + 1 
36a2 .. 00			db "UNTIL",0              
36a8				endm 
# End of macro CWHEAD
36a8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36a8			 
36a8				; pop tos as check 
36a8			 
36a8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36a8			 
36a8				FORTH_DSP_VALUEHL 
36a8 cd d2 1c			call macro_dsp_valuehl 
36ab				endm 
# End of macro FORTH_DSP_VALUEHL
36ab			 
36ab					if DEBUG_FORTH_WORDS_KEY 
36ab						DMARK "UNT" 
36ab f5				push af  
36ac 3a c0 36			ld a, (.dmark)  
36af 32 62 ee			ld (debug_mark),a  
36b2 3a c1 36			ld a, (.dmark+1)  
36b5 32 63 ee			ld (debug_mark+1),a  
36b8 3a c2 36			ld a, (.dmark+2)  
36bb 32 64 ee			ld (debug_mark+2),a  
36be 18 03			jr .pastdmark  
36c0 ..			.dmark: db "UNT"  
36c3 f1			.pastdmark: pop af  
36c4			endm  
# End of macro DMARK
36c4						CALLMONITOR 
36c4 cd 6f ee			call debug_vector  
36c7				endm  
# End of macro CALLMONITOR
36c7					endif 
36c7			 
36c7			;	push hl 
36c7				FORTH_DSP_POP 
36c7 cd 8a 1d			call macro_forth_dsp_pop 
36ca				endm 
# End of macro FORTH_DSP_POP
36ca			 
36ca			;	pop hl 
36ca			 
36ca				; test if true 
36ca			 
36ca cd 0a 0e			call ishlzero 
36cd			;	ld a,l 
36cd			;	add h 
36cd			; 
36cd			;	cp 0 
36cd			 
36cd 20 41			jr nz, .untilnotdone 
36cf			 
36cf					if DEBUG_FORTH_WORDS 
36cf						DMARK "UNf" 
36cf f5				push af  
36d0 3a e4 36			ld a, (.dmark)  
36d3 32 62 ee			ld (debug_mark),a  
36d6 3a e5 36			ld a, (.dmark+1)  
36d9 32 63 ee			ld (debug_mark+1),a  
36dc 3a e6 36			ld a, (.dmark+2)  
36df 32 64 ee			ld (debug_mark+2),a  
36e2 18 03			jr .pastdmark  
36e4 ..			.dmark: db "UNf"  
36e7 f1			.pastdmark: pop af  
36e8			endm  
# End of macro DMARK
36e8						CALLMONITOR 
36e8 cd 6f ee			call debug_vector  
36eb				endm  
# End of macro CALLMONITOR
36eb					endif 
36eb			 
36eb			 
36eb			 
36eb				FORTH_RSP_POP     ; get rid of DO ptr 
36eb cd 9e 1a			call macro_forth_rsp_pop 
36ee				endm 
# End of macro FORTH_RSP_POP
36ee			 
36ee			if DEBUG_FORTH_WORDS 
36ee						DMARK "UN>" 
36ee f5				push af  
36ef 3a 03 37			ld a, (.dmark)  
36f2 32 62 ee			ld (debug_mark),a  
36f5 3a 04 37			ld a, (.dmark+1)  
36f8 32 63 ee			ld (debug_mark+1),a  
36fb 3a 05 37			ld a, (.dmark+2)  
36fe 32 64 ee			ld (debug_mark+2),a  
3701 18 03			jr .pastdmark  
3703 ..			.dmark: db "UN>"  
3706 f1			.pastdmark: pop af  
3707			endm  
# End of macro DMARK
3707				CALLMONITOR 
3707 cd 6f ee			call debug_vector  
370a				endm  
# End of macro CALLMONITOR
370a			endif 
370a			 
370a					NEXTW 
370a cd 6c ee			call parse_vector 
370d c3 b9 1e			jp macro_next 
3710				endm 
# End of macro NEXTW
3710				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3710			 
3710			.untilnotdone: 
3710			 
3710			 
3710			;	; get DO ptr 
3710			; 
3710				FORTH_RSP_TOS 
3710 cd 94 1a			call macro_forth_rsp_tos 
3713				endm 
# End of macro FORTH_RSP_TOS
3713			 
3713				;push hl 
3713			 
3713				; not going to DO any more 
3713				; get rid of the RSP pointer as DO will add it back in 
3713				;FORTH_RSP_POP 
3713				;pop hl 
3713			 
3713			 
3713 22 b9 e5			ld (os_tok_ptr), hl 
3716					if DEBUG_FORTH_WORDS 
3716						DMARK "UN<" 
3716 f5				push af  
3717 3a 2b 37			ld a, (.dmark)  
371a 32 62 ee			ld (debug_mark),a  
371d 3a 2c 37			ld a, (.dmark+1)  
3720 32 63 ee			ld (debug_mark+1),a  
3723 3a 2d 37			ld a, (.dmark+2)  
3726 32 64 ee			ld (debug_mark+2),a  
3729 18 03			jr .pastdmark  
372b ..			.dmark: db "UN<"  
372e f1			.pastdmark: pop af  
372f			endm  
# End of macro DMARK
372f					CALLMONITOR 
372f cd 6f ee			call debug_vector  
3732				endm  
# End of macro CALLMONITOR
3732				endif 
3732 c3 3a 1f			jp exec1 
3735			 
3735					 
3735			 
3735			 
3735					NEXTW 
3735 cd 6c ee			call parse_vector 
3738 c3 b9 1e			jp macro_next 
373b				endm 
# End of macro NEXTW
373b			 
373b			 
373b			.ENDFLOW: 
373b			 
373b			; eof 
373b			 
# End of file forth_words_flow.asm
373b			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
373b			include "forth_words_logic.asm" 
373b			 
373b			; | ## Logic Words 
373b			 
373b			.NOT: 
373b				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
373b 2d				db WORD_SYS_CORE+25             
373c 89 37			dw .IS            
373e 04				db 3 + 1 
373f .. 00			db "NOT",0              
3743				endm 
# End of macro CWHEAD
3743			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3743					if DEBUG_FORTH_WORDS_KEY 
3743						DMARK "NOT" 
3743 f5				push af  
3744 3a 58 37			ld a, (.dmark)  
3747 32 62 ee			ld (debug_mark),a  
374a 3a 59 37			ld a, (.dmark+1)  
374d 32 63 ee			ld (debug_mark+1),a  
3750 3a 5a 37			ld a, (.dmark+2)  
3753 32 64 ee			ld (debug_mark+2),a  
3756 18 03			jr .pastdmark  
3758 ..			.dmark: db "NOT"  
375b f1			.pastdmark: pop af  
375c			endm  
# End of macro DMARK
375c						CALLMONITOR 
375c cd 6f ee			call debug_vector  
375f				endm  
# End of macro CALLMONITOR
375f					endif 
375f					FORTH_DSP 
375f cd 98 1c			call macro_forth_dsp 
3762				endm 
# End of macro FORTH_DSP
3762 7e					ld a,(hl)	; get type of value on TOS 
3763 fe 02				cp DS_TYPE_INUM  
3765 28 06				jr z, .noti 
3767					NEXTW 
3767 cd 6c ee			call parse_vector 
376a c3 b9 1e			jp macro_next 
376d				endm 
# End of macro NEXTW
376d			.noti:          FORTH_DSP_VALUEHL 
376d cd d2 1c			call macro_dsp_valuehl 
3770				endm 
# End of macro FORTH_DSP_VALUEHL
3770			;		push hl 
3770					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3770 cd 8a 1d			call macro_forth_dsp_pop 
3773				endm 
# End of macro FORTH_DSP_POP
3773			;		pop hl 
3773 3e 00				ld a,0 
3775 bd					cp l 
3776 28 04				jr z, .not2t 
3778 2e 00				ld l, 0 
377a 18 02				jr .notip 
377c			 
377c 2e ff		.not2t:		ld l, 255 
377e			 
377e 26 00		.notip:		ld h, 0	 
3780			 
3780 cd d6 1a				call forth_push_numhl 
3783					NEXTW 
3783 cd 6c ee			call parse_vector 
3786 c3 b9 1e			jp macro_next 
3789				endm 
# End of macro NEXTW
3789			 
3789			.IS: 
3789				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3789 2d				db WORD_SYS_CORE+25             
378a cd 37			dw .LZERO            
378c 08				db 7 + 1 
378d .. 00			db "COMPARE",0              
3795				endm 
# End of macro CWHEAD
3795			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3795					if DEBUG_FORTH_WORDS_KEY 
3795						DMARK "CMP" 
3795 f5				push af  
3796 3a aa 37			ld a, (.dmark)  
3799 32 62 ee			ld (debug_mark),a  
379c 3a ab 37			ld a, (.dmark+1)  
379f 32 63 ee			ld (debug_mark+1),a  
37a2 3a ac 37			ld a, (.dmark+2)  
37a5 32 64 ee			ld (debug_mark+2),a  
37a8 18 03			jr .pastdmark  
37aa ..			.dmark: db "CMP"  
37ad f1			.pastdmark: pop af  
37ae			endm  
# End of macro DMARK
37ae						CALLMONITOR 
37ae cd 6f ee			call debug_vector  
37b1				endm  
# End of macro CALLMONITOR
37b1					endif 
37b1			 
37b1					FORTH_DSP_VALUEHL 
37b1 cd d2 1c			call macro_dsp_valuehl 
37b4				endm 
# End of macro FORTH_DSP_VALUEHL
37b4			 
37b4 e5					push hl 
37b5			 
37b5					FORTH_DSP_VALUEM1 
37b5 cd c6 1c			call macro_forth_dsp_value_m1 
37b8				endm 
# End of macro FORTH_DSP_VALUEM1
37b8			 
37b8 d1					pop de 
37b9			 
37b9					; got pointers to both. Now check. 
37b9			 
37b9 cd 71 11				call strcmp 
37bc				 
37bc 26 00				ld h, 0 
37be 2e 00				ld l, 0 
37c0 20 02				jr nz, .compnsame 
37c2 2e 01				ld l, 1	 
37c4			.compnsame: 
37c4 cd d6 1a				call forth_push_numhl 
37c7			 
37c7					NEXTW 
37c7 cd 6c ee			call parse_vector 
37ca c3 b9 1e			jp macro_next 
37cd				endm 
# End of macro NEXTW
37cd			.LZERO: 
37cd				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37cd 2d				db WORD_SYS_CORE+25             
37ce da 37			dw .TZERO            
37d0 03				db 2 + 1 
37d1 .. 00			db "0<",0              
37d4				endm 
# End of macro CWHEAD
37d4			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37d4					NEXTW 
37d4 cd 6c ee			call parse_vector 
37d7 c3 b9 1e			jp macro_next 
37da				endm 
# End of macro NEXTW
37da			.TZERO: 
37da				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37da 2e				db WORD_SYS_CORE+26             
37db 24 38			dw .LESS            
37dd 03				db 2 + 1 
37de .. 00			db "0=",0              
37e1				endm 
# End of macro CWHEAD
37e1			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
37e1				; TODO add floating point number detection 
37e1					;v5 FORTH_DSP_VALUE 
37e1					if DEBUG_FORTH_WORDS_KEY 
37e1						DMARK "0=." 
37e1 f5				push af  
37e2 3a f6 37			ld a, (.dmark)  
37e5 32 62 ee			ld (debug_mark),a  
37e8 3a f7 37			ld a, (.dmark+1)  
37eb 32 63 ee			ld (debug_mark+1),a  
37ee 3a f8 37			ld a, (.dmark+2)  
37f1 32 64 ee			ld (debug_mark+2),a  
37f4 18 03			jr .pastdmark  
37f6 ..			.dmark: db "0=."  
37f9 f1			.pastdmark: pop af  
37fa			endm  
# End of macro DMARK
37fa						CALLMONITOR 
37fa cd 6f ee			call debug_vector  
37fd				endm  
# End of macro CALLMONITOR
37fd					endif 
37fd					FORTH_DSP 
37fd cd 98 1c			call macro_forth_dsp 
3800				endm 
# End of macro FORTH_DSP
3800 7e					ld a,(hl)	; get type of value on TOS 
3801 fe 02				cp DS_TYPE_INUM  
3803 28 00				jr z, .tz_inum 
3805			 
3805				if FORTH_ENABLE_FLOATMATH 
3805					jr .tz_done 
3805			 
3805				endif 
3805					 
3805			 
3805			.tz_inum: 
3805					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3805 cd d2 1c			call macro_dsp_valuehl 
3808				endm 
# End of macro FORTH_DSP_VALUEHL
3808			 
3808			;		push hl 
3808			 
3808					; destroy value TOS 
3808			 
3808					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3808 cd 8a 1d			call macro_forth_dsp_pop 
380b				endm 
# End of macro FORTH_DSP_POP
380b			 
380b			;		pop hl 
380b			 
380b 3e 00				ld a,0 
380d			 
380d bd					cp l 
380e 20 08				jr nz, .tz_notzero 
3810			 
3810 bc					cp h 
3811			 
3811 20 05				jr nz, .tz_notzero 
3813			 
3813			 
3813 21 01 00				ld hl, FORTH_TRUE 
3816 18 03				jr .tz_done 
3818			 
3818 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
381b			 
381b					; push value back onto stack for another op etc 
381b			 
381b			.tz_done: 
381b cd d6 1a				call forth_push_numhl 
381e			 
381e					NEXTW 
381e cd 6c ee			call parse_vector 
3821 c3 b9 1e			jp macro_next 
3824				endm 
# End of macro NEXTW
3824			.LESS: 
3824				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3824 2f				db WORD_SYS_CORE+27             
3825 90 38			dw .GT            
3827 02				db 1 + 1 
3828 .. 00			db "<",0              
382a				endm 
# End of macro CWHEAD
382a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
382a				; TODO add floating point number detection 
382a					if DEBUG_FORTH_WORDS_KEY 
382a						DMARK "LES" 
382a f5				push af  
382b 3a 3f 38			ld a, (.dmark)  
382e 32 62 ee			ld (debug_mark),a  
3831 3a 40 38			ld a, (.dmark+1)  
3834 32 63 ee			ld (debug_mark+1),a  
3837 3a 41 38			ld a, (.dmark+2)  
383a 32 64 ee			ld (debug_mark+2),a  
383d 18 03			jr .pastdmark  
383f ..			.dmark: db "LES"  
3842 f1			.pastdmark: pop af  
3843			endm  
# End of macro DMARK
3843						CALLMONITOR 
3843 cd 6f ee			call debug_vector  
3846				endm  
# End of macro CALLMONITOR
3846					endif 
3846					FORTH_DSP 
3846 cd 98 1c			call macro_forth_dsp 
3849				endm 
# End of macro FORTH_DSP
3849					;v5 FORTH_DSP_VALUE 
3849 7e					ld a,(hl)	; get type of value on TOS 
384a fe 02				cp DS_TYPE_INUM  
384c 28 00				jr z, .less_inum 
384e			 
384e				if FORTH_ENABLE_FLOATMATH 
384e					jr .less_done 
384e			 
384e				endif 
384e					 
384e			 
384e			.less_inum: 
384e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
384e cd d2 1c			call macro_dsp_valuehl 
3851				endm 
# End of macro FORTH_DSP_VALUEHL
3851			 
3851 e5					push hl  ; u2 
3852			 
3852					; destroy value TOS 
3852			 
3852					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3852 cd 8a 1d			call macro_forth_dsp_pop 
3855				endm 
# End of macro FORTH_DSP_POP
3855			 
3855			 
3855					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3855 cd d2 1c			call macro_dsp_valuehl 
3858				endm 
# End of macro FORTH_DSP_VALUEHL
3858			 
3858 e5					push hl    ; u1 
3859			 
3859					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3859 cd 8a 1d			call macro_forth_dsp_pop 
385c				endm 
# End of macro FORTH_DSP_POP
385c			 
385c			 
385c b7			 or a      ;clear carry flag 
385d 01 00 00		 ld bc, FORTH_FALSE 
3860 e1			  pop hl    ; u1 
3861 d1			  pop de    ; u2 
3862 ed 52		  sbc hl,de 
3864 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3866			 
3866 01 01 00		 ld bc, FORTH_TRUE 
3869			.lscont:  
3869 c5					push bc 
386a e1					pop hl 
386b			 
386b					if DEBUG_FORTH_WORDS 
386b						DMARK "LT1" 
386b f5				push af  
386c 3a 80 38			ld a, (.dmark)  
386f 32 62 ee			ld (debug_mark),a  
3872 3a 81 38			ld a, (.dmark+1)  
3875 32 63 ee			ld (debug_mark+1),a  
3878 3a 82 38			ld a, (.dmark+2)  
387b 32 64 ee			ld (debug_mark+2),a  
387e 18 03			jr .pastdmark  
3880 ..			.dmark: db "LT1"  
3883 f1			.pastdmark: pop af  
3884			endm  
# End of macro DMARK
3884						CALLMONITOR 
3884 cd 6f ee			call debug_vector  
3887				endm  
# End of macro CALLMONITOR
3887					endif 
3887 cd d6 1a				call forth_push_numhl 
388a			 
388a					NEXTW 
388a cd 6c ee			call parse_vector 
388d c3 b9 1e			jp macro_next 
3890				endm 
# End of macro NEXTW
3890			.GT: 
3890				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3890 30				db WORD_SYS_CORE+28             
3891 fc 38			dw .EQUAL            
3893 02				db 1 + 1 
3894 .. 00			db ">",0              
3896				endm 
# End of macro CWHEAD
3896			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3896				; TODO add floating point number detection 
3896					if DEBUG_FORTH_WORDS_KEY 
3896						DMARK "GRT" 
3896 f5				push af  
3897 3a ab 38			ld a, (.dmark)  
389a 32 62 ee			ld (debug_mark),a  
389d 3a ac 38			ld a, (.dmark+1)  
38a0 32 63 ee			ld (debug_mark+1),a  
38a3 3a ad 38			ld a, (.dmark+2)  
38a6 32 64 ee			ld (debug_mark+2),a  
38a9 18 03			jr .pastdmark  
38ab ..			.dmark: db "GRT"  
38ae f1			.pastdmark: pop af  
38af			endm  
# End of macro DMARK
38af						CALLMONITOR 
38af cd 6f ee			call debug_vector  
38b2				endm  
# End of macro CALLMONITOR
38b2					endif 
38b2					FORTH_DSP 
38b2 cd 98 1c			call macro_forth_dsp 
38b5				endm 
# End of macro FORTH_DSP
38b5					;FORTH_DSP_VALUE 
38b5 7e					ld a,(hl)	; get type of value on TOS 
38b6 fe 02				cp DS_TYPE_INUM  
38b8 28 00				jr z, .gt_inum 
38ba			 
38ba				if FORTH_ENABLE_FLOATMATH 
38ba					jr .gt_done 
38ba			 
38ba				endif 
38ba					 
38ba			 
38ba			.gt_inum: 
38ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ba cd d2 1c			call macro_dsp_valuehl 
38bd				endm 
# End of macro FORTH_DSP_VALUEHL
38bd			 
38bd e5					push hl  ; u2 
38be			 
38be					; destroy value TOS 
38be			 
38be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38be cd 8a 1d			call macro_forth_dsp_pop 
38c1				endm 
# End of macro FORTH_DSP_POP
38c1			 
38c1			 
38c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c1 cd d2 1c			call macro_dsp_valuehl 
38c4				endm 
# End of macro FORTH_DSP_VALUEHL
38c4			 
38c4 e5					push hl    ; u1 
38c5			 
38c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c5 cd 8a 1d			call macro_forth_dsp_pop 
38c8				endm 
# End of macro FORTH_DSP_POP
38c8			 
38c8			 
38c8 b7			 or a      ;clear carry flag 
38c9 01 00 00		 ld bc, FORTH_FALSE 
38cc e1			  pop hl    ; u1 
38cd d1			  pop de    ; u2 
38ce ed 52		  sbc hl,de 
38d0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38d2			 
38d2 01 01 00		 ld bc, FORTH_TRUE 
38d5			.gtcont:  
38d5 c5					push bc 
38d6 e1					pop hl 
38d7			 
38d7					if DEBUG_FORTH_WORDS 
38d7						DMARK "GT1" 
38d7 f5				push af  
38d8 3a ec 38			ld a, (.dmark)  
38db 32 62 ee			ld (debug_mark),a  
38de 3a ed 38			ld a, (.dmark+1)  
38e1 32 63 ee			ld (debug_mark+1),a  
38e4 3a ee 38			ld a, (.dmark+2)  
38e7 32 64 ee			ld (debug_mark+2),a  
38ea 18 03			jr .pastdmark  
38ec ..			.dmark: db "GT1"  
38ef f1			.pastdmark: pop af  
38f0			endm  
# End of macro DMARK
38f0						CALLMONITOR 
38f0 cd 6f ee			call debug_vector  
38f3				endm  
# End of macro CALLMONITOR
38f3					endif 
38f3 cd d6 1a				call forth_push_numhl 
38f6			 
38f6					NEXTW 
38f6 cd 6c ee			call parse_vector 
38f9 c3 b9 1e			jp macro_next 
38fc				endm 
# End of macro NEXTW
38fc			.EQUAL: 
38fc				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38fc 31				db WORD_SYS_CORE+29             
38fd 6a 39			dw .ENDLOGIC            
38ff 02				db 1 + 1 
3900 .. 00			db "=",0              
3902				endm 
# End of macro CWHEAD
3902			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3902				; TODO add floating point number detection 
3902					if DEBUG_FORTH_WORDS_KEY 
3902						DMARK "EQ." 
3902 f5				push af  
3903 3a 17 39			ld a, (.dmark)  
3906 32 62 ee			ld (debug_mark),a  
3909 3a 18 39			ld a, (.dmark+1)  
390c 32 63 ee			ld (debug_mark+1),a  
390f 3a 19 39			ld a, (.dmark+2)  
3912 32 64 ee			ld (debug_mark+2),a  
3915 18 03			jr .pastdmark  
3917 ..			.dmark: db "EQ."  
391a f1			.pastdmark: pop af  
391b			endm  
# End of macro DMARK
391b						CALLMONITOR 
391b cd 6f ee			call debug_vector  
391e				endm  
# End of macro CALLMONITOR
391e					endif 
391e					FORTH_DSP 
391e cd 98 1c			call macro_forth_dsp 
3921				endm 
# End of macro FORTH_DSP
3921					;v5 FORTH_DSP_VALUE 
3921 7e					ld a,(hl)	; get type of value on TOS 
3922 fe 02				cp DS_TYPE_INUM  
3924 28 00				jr z, .eq_inum 
3926			 
3926				if FORTH_ENABLE_FLOATMATH 
3926					jr .eq_done 
3926			 
3926				endif 
3926					 
3926			 
3926			.eq_inum: 
3926					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3926 cd d2 1c			call macro_dsp_valuehl 
3929				endm 
# End of macro FORTH_DSP_VALUEHL
3929			 
3929 e5					push hl 
392a			 
392a					; destroy value TOS 
392a			 
392a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392a cd 8a 1d			call macro_forth_dsp_pop 
392d				endm 
# End of macro FORTH_DSP_POP
392d			 
392d			 
392d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392d cd d2 1c			call macro_dsp_valuehl 
3930				endm 
# End of macro FORTH_DSP_VALUEHL
3930			 
3930					; one value on hl get other one back 
3930			 
3930 e5					push hl 
3931			 
3931					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3931 cd 8a 1d			call macro_forth_dsp_pop 
3934				endm 
# End of macro FORTH_DSP_POP
3934			 
3934 0e 00				ld c, FORTH_FALSE 
3936			 
3936 e1					pop hl 
3937 d1					pop de 
3938			 
3938 7b					ld a, e 
3939 bd					cp l 
393a			 
393a 20 06				jr nz, .eq_done 
393c			 
393c 7a					ld a, d 
393d bc					cp h 
393e			 
393e 20 02				jr nz, .eq_done 
3940			 
3940 0e 01				ld c, FORTH_TRUE 
3942					 
3942			 
3942			 
3942			.eq_done: 
3942			 
3942					; TODO push value back onto stack for another op etc 
3942			 
3942 26 00				ld h, 0 
3944 69					ld l, c 
3945					if DEBUG_FORTH_WORDS 
3945						DMARK "EQ1" 
3945 f5				push af  
3946 3a 5a 39			ld a, (.dmark)  
3949 32 62 ee			ld (debug_mark),a  
394c 3a 5b 39			ld a, (.dmark+1)  
394f 32 63 ee			ld (debug_mark+1),a  
3952 3a 5c 39			ld a, (.dmark+2)  
3955 32 64 ee			ld (debug_mark+2),a  
3958 18 03			jr .pastdmark  
395a ..			.dmark: db "EQ1"  
395d f1			.pastdmark: pop af  
395e			endm  
# End of macro DMARK
395e						CALLMONITOR 
395e cd 6f ee			call debug_vector  
3961				endm  
# End of macro CALLMONITOR
3961					endif 
3961 cd d6 1a				call forth_push_numhl 
3964			 
3964					NEXTW 
3964 cd 6c ee			call parse_vector 
3967 c3 b9 1e			jp macro_next 
396a				endm 
# End of macro NEXTW
396a			 
396a			 
396a			.ENDLOGIC: 
396a			; eof 
396a			 
396a			 
# End of file forth_words_logic.asm
396a			include "forth_words_maths.asm" 
396a			 
396a			; | ## Maths Words 
396a			 
396a			.PLUS:	 
396a				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
396a 15				db WORD_SYS_CORE+1             
396b ce 39			dw .NEG            
396d 02				db 1 + 1 
396e .. 00			db "+",0              
3970				endm 
# End of macro CWHEAD
3970			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3970					if DEBUG_FORTH_WORDS_KEY 
3970						DMARK "PLU" 
3970 f5				push af  
3971 3a 85 39			ld a, (.dmark)  
3974 32 62 ee			ld (debug_mark),a  
3977 3a 86 39			ld a, (.dmark+1)  
397a 32 63 ee			ld (debug_mark+1),a  
397d 3a 87 39			ld a, (.dmark+2)  
3980 32 64 ee			ld (debug_mark+2),a  
3983 18 03			jr .pastdmark  
3985 ..			.dmark: db "PLU"  
3988 f1			.pastdmark: pop af  
3989			endm  
# End of macro DMARK
3989						CALLMONITOR 
3989 cd 6f ee			call debug_vector  
398c				endm  
# End of macro CALLMONITOR
398c					endif 
398c					; add top two values and push back result 
398c			 
398c					;for v5 FORTH_DSP_VALUE 
398c					FORTH_DSP 
398c cd 98 1c			call macro_forth_dsp 
398f				endm 
# End of macro FORTH_DSP
398f 7e					ld a,(hl)	; get type of value on TOS 
3990 fe 02				cp DS_TYPE_INUM  
3992 28 06				jr z, .dot_inum 
3994			 
3994					NEXTW 
3994 cd 6c ee			call parse_vector 
3997 c3 b9 1e			jp macro_next 
399a				endm 
# End of macro NEXTW
399a			 
399a			; float maths 
399a			 
399a				if FORTH_ENABLE_FLOATMATH 
399a						inc hl      ; now at start of numeric as string 
399a			 
399a					if DEBUG_FORTH_MATHS 
399a						DMARK "ADD" 
399a				CALLMONITOR 
399a					endif 
399a			 
399a					;ld ix, hl 
399a					call CON 
399a			 
399a			 
399a					push hl 
399a					 
399a					 
399a			 
399a						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
399a			 
399a					; get next number 
399a			 
399a						FORTH_DSP_VALUE 
399a			 
399a						inc hl      ; now at start of numeric as string 
399a			 
399a					;ld ix, hl 
399a					call CON 
399a			 
399a					push hl 
399a			 
399a			 
399a						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399a			 
399a						; TODO do add 
399a			 
399a						call IADD 
399a			 
399a						; TODO get result back as ascii 
399a			 
399a						; TODO push result  
399a			 
399a			 
399a			 
399a						jr .dot_done 
399a				endif 
399a			 
399a			.dot_inum: 
399a			 
399a			 
399a					if DEBUG_FORTH_DOT 
399a						DMARK "+IT" 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 62 ee			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 63 ee			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 64 ee			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "+IT"  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3				CALLMONITOR 
39b3 cd 6f ee			call debug_vector  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6			 
39b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b6 cd d2 1c			call macro_dsp_valuehl 
39b9				endm 
# End of macro FORTH_DSP_VALUEHL
39b9			 
39b9				; TODO add floating point number detection 
39b9			 
39b9 e5					push hl 
39ba			 
39ba					; destroy value TOS 
39ba			 
39ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ba cd 8a 1d			call macro_forth_dsp_pop 
39bd				endm 
# End of macro FORTH_DSP_POP
39bd			 
39bd			 
39bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39bd cd d2 1c			call macro_dsp_valuehl 
39c0				endm 
# End of macro FORTH_DSP_VALUEHL
39c0			 
39c0					; one value on hl get other one back 
39c0			 
39c0 d1					pop de 
39c1			 
39c1					; do the add 
39c1			 
39c1 19					add hl,de 
39c2			 
39c2					; save it 
39c2			 
39c2			;		push hl	 
39c2			 
39c2					; 
39c2			 
39c2					; destroy value TOS 
39c2			 
39c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c2 cd 8a 1d			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5					; TODO push value back onto stack for another op etc 
39c5			 
39c5			;		pop hl 
39c5			 
39c5			.dot_done: 
39c5 cd d6 1a				call forth_push_numhl 
39c8			 
39c8					NEXTW 
39c8 cd 6c ee			call parse_vector 
39cb c3 b9 1e			jp macro_next 
39ce				endm 
# End of macro NEXTW
39ce			.NEG: 
39ce			 
39ce				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
39ce 17				db WORD_SYS_CORE+3             
39cf 17 3a			dw .DIV            
39d1 02				db 1 + 1 
39d2 .. 00			db "-",0              
39d4				endm 
# End of macro CWHEAD
39d4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39d4					if DEBUG_FORTH_WORDS_KEY 
39d4						DMARK "SUB" 
39d4 f5				push af  
39d5 3a e9 39			ld a, (.dmark)  
39d8 32 62 ee			ld (debug_mark),a  
39db 3a ea 39			ld a, (.dmark+1)  
39de 32 63 ee			ld (debug_mark+1),a  
39e1 3a eb 39			ld a, (.dmark+2)  
39e4 32 64 ee			ld (debug_mark+2),a  
39e7 18 03			jr .pastdmark  
39e9 ..			.dmark: db "SUB"  
39ec f1			.pastdmark: pop af  
39ed			endm  
# End of macro DMARK
39ed						CALLMONITOR 
39ed cd 6f ee			call debug_vector  
39f0				endm  
# End of macro CALLMONITOR
39f0					endif 
39f0			 
39f0			 
39f0				; TODO add floating point number detection 
39f0					; v5 FORTH_DSP_VALUE 
39f0					FORTH_DSP 
39f0 cd 98 1c			call macro_forth_dsp 
39f3				endm 
# End of macro FORTH_DSP
39f3 7e					ld a,(hl)	; get type of value on TOS 
39f4 fe 02				cp DS_TYPE_INUM  
39f6 28 06				jr z, .neg_inum 
39f8			 
39f8					NEXTW 
39f8 cd 6c ee			call parse_vector 
39fb c3 b9 1e			jp macro_next 
39fe				endm 
# End of macro NEXTW
39fe			 
39fe			; float maths 
39fe			 
39fe				if FORTH_ENABLE_FLOATMATH 
39fe					jr .neg_done 
39fe			 
39fe				endif 
39fe					 
39fe			 
39fe			.neg_inum: 
39fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39fe cd d2 1c			call macro_dsp_valuehl 
3a01				endm 
# End of macro FORTH_DSP_VALUEHL
3a01			 
3a01 e5					push hl 
3a02			 
3a02					; destroy value TOS 
3a02			 
3a02					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a02 cd 8a 1d			call macro_forth_dsp_pop 
3a05				endm 
# End of macro FORTH_DSP_POP
3a05			 
3a05			 
3a05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a05 cd d2 1c			call macro_dsp_valuehl 
3a08				endm 
# End of macro FORTH_DSP_VALUEHL
3a08			 
3a08					; one value on hl get other one back 
3a08			 
3a08 d1					pop de 
3a09			 
3a09					; do the sub 
3a09			;		ex de, hl 
3a09			 
3a09 ed 52				sbc hl,de 
3a0b			 
3a0b					; save it 
3a0b			 
3a0b			;		push hl	 
3a0b			 
3a0b					; 
3a0b			 
3a0b					; destroy value TOS 
3a0b			 
3a0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0b cd 8a 1d			call macro_forth_dsp_pop 
3a0e				endm 
# End of macro FORTH_DSP_POP
3a0e			 
3a0e					; TODO push value back onto stack for another op etc 
3a0e			 
3a0e			;		pop hl 
3a0e			 
3a0e cd d6 1a				call forth_push_numhl 
3a11			.neg_done: 
3a11			 
3a11					NEXTW 
3a11 cd 6c ee			call parse_vector 
3a14 c3 b9 1e			jp macro_next 
3a17				endm 
# End of macro NEXTW
3a17			.DIV: 
3a17				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a17 18				db WORD_SYS_CORE+4             
3a18 6a 3a			dw .MUL            
3a1a 02				db 1 + 1 
3a1b .. 00			db "/",0              
3a1d				endm 
# End of macro CWHEAD
3a1d			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a1d					if DEBUG_FORTH_WORDS_KEY 
3a1d						DMARK "DIV" 
3a1d f5				push af  
3a1e 3a 32 3a			ld a, (.dmark)  
3a21 32 62 ee			ld (debug_mark),a  
3a24 3a 33 3a			ld a, (.dmark+1)  
3a27 32 63 ee			ld (debug_mark+1),a  
3a2a 3a 34 3a			ld a, (.dmark+2)  
3a2d 32 64 ee			ld (debug_mark+2),a  
3a30 18 03			jr .pastdmark  
3a32 ..			.dmark: db "DIV"  
3a35 f1			.pastdmark: pop af  
3a36			endm  
# End of macro DMARK
3a36						CALLMONITOR 
3a36 cd 6f ee			call debug_vector  
3a39				endm  
# End of macro CALLMONITOR
3a39					endif 
3a39				; TODO add floating point number detection 
3a39					; v5 FORTH_DSP_VALUE 
3a39					FORTH_DSP 
3a39 cd 98 1c			call macro_forth_dsp 
3a3c				endm 
# End of macro FORTH_DSP
3a3c 7e					ld a,(hl)	; get type of value on TOS 
3a3d fe 02				cp DS_TYPE_INUM  
3a3f 28 06				jr z, .div_inum 
3a41			 
3a41				if FORTH_ENABLE_FLOATMATH 
3a41					jr .div_done 
3a41			 
3a41				endif 
3a41					NEXTW 
3a41 cd 6c ee			call parse_vector 
3a44 c3 b9 1e			jp macro_next 
3a47				endm 
# End of macro NEXTW
3a47			.div_inum: 
3a47			 
3a47					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a47 cd d2 1c			call macro_dsp_valuehl 
3a4a				endm 
# End of macro FORTH_DSP_VALUEHL
3a4a			 
3a4a e5					push hl    ; to go to bc 
3a4b			 
3a4b					; destroy value TOS 
3a4b			 
3a4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a4b cd 8a 1d			call macro_forth_dsp_pop 
3a4e				endm 
# End of macro FORTH_DSP_POP
3a4e			 
3a4e			 
3a4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4e cd d2 1c			call macro_dsp_valuehl 
3a51				endm 
# End of macro FORTH_DSP_VALUEHL
3a51			 
3a51					; hl to go to de 
3a51			 
3a51 e5					push hl 
3a52			 
3a52 c1					pop bc 
3a53 d1					pop de		 
3a54			 
3a54			 
3a54					if DEBUG_FORTH_MATHS 
3a54						DMARK "DIV" 
3a54				CALLMONITOR 
3a54					endif 
3a54					; one value on hl but move to a get other one back 
3a54			 
3a54			        
3a54 cd 3e 0d			call Div16 
3a57			 
3a57			;	push af	 
3a57 e5				push hl 
3a58 c5				push bc 
3a59			 
3a59					if DEBUG_FORTH_MATHS 
3a59						DMARK "DI1" 
3a59				CALLMONITOR 
3a59					endif 
3a59			 
3a59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a59 cd 8a 1d			call macro_forth_dsp_pop 
3a5c				endm 
# End of macro FORTH_DSP_POP
3a5c			 
3a5c			 
3a5c			 
3a5c e1					pop hl    ; result 
3a5d			 
3a5d cd d6 1a				call forth_push_numhl 
3a60			 
3a60 e1					pop hl    ; reminder 
3a61			;		ld h,0 
3a61			;		ld l,d 
3a61			 
3a61 cd d6 1a				call forth_push_numhl 
3a64			.div_done: 
3a64					NEXTW 
3a64 cd 6c ee			call parse_vector 
3a67 c3 b9 1e			jp macro_next 
3a6a				endm 
# End of macro NEXTW
3a6a			.MUL: 
3a6a				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a6a 19				db WORD_SYS_CORE+5             
3a6b b5 3a			dw .MIN            
3a6d 02				db 1 + 1 
3a6e .. 00			db "*",0              
3a70				endm 
# End of macro CWHEAD
3a70			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a70				; TODO add floating point number detection 
3a70					if DEBUG_FORTH_WORDS_KEY 
3a70						DMARK "MUL" 
3a70 f5				push af  
3a71 3a 85 3a			ld a, (.dmark)  
3a74 32 62 ee			ld (debug_mark),a  
3a77 3a 86 3a			ld a, (.dmark+1)  
3a7a 32 63 ee			ld (debug_mark+1),a  
3a7d 3a 87 3a			ld a, (.dmark+2)  
3a80 32 64 ee			ld (debug_mark+2),a  
3a83 18 03			jr .pastdmark  
3a85 ..			.dmark: db "MUL"  
3a88 f1			.pastdmark: pop af  
3a89			endm  
# End of macro DMARK
3a89						CALLMONITOR 
3a89 cd 6f ee			call debug_vector  
3a8c				endm  
# End of macro CALLMONITOR
3a8c					endif 
3a8c					FORTH_DSP 
3a8c cd 98 1c			call macro_forth_dsp 
3a8f				endm 
# End of macro FORTH_DSP
3a8f					; v5 FORTH_DSP_VALUE 
3a8f 7e					ld a,(hl)	; get type of value on TOS 
3a90 fe 02				cp DS_TYPE_INUM  
3a92 28 06				jr z, .mul_inum 
3a94			 
3a94				if FORTH_ENABLE_FLOATMATH 
3a94					jr .mul_done 
3a94			 
3a94				endif 
3a94			 
3a94					NEXTW 
3a94 cd 6c ee			call parse_vector 
3a97 c3 b9 1e			jp macro_next 
3a9a				endm 
# End of macro NEXTW
3a9a			.mul_inum:	 
3a9a			 
3a9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9a cd d2 1c			call macro_dsp_valuehl 
3a9d				endm 
# End of macro FORTH_DSP_VALUEHL
3a9d			 
3a9d e5					push hl 
3a9e			 
3a9e					; destroy value TOS 
3a9e			 
3a9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9e cd 8a 1d			call macro_forth_dsp_pop 
3aa1				endm 
# End of macro FORTH_DSP_POP
3aa1			 
3aa1			 
3aa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa1 cd d2 1c			call macro_dsp_valuehl 
3aa4				endm 
# End of macro FORTH_DSP_VALUEHL
3aa4			 
3aa4					; one value on hl but move to a get other one back 
3aa4			 
3aa4 7d					ld a, l 
3aa5			 
3aa5 d1					pop de 
3aa6			 
3aa6					; do the mull 
3aa6			;		ex de, hl 
3aa6			 
3aa6 cd 64 0d				call Mult16 
3aa9					; save it 
3aa9			 
3aa9			;		push hl	 
3aa9			 
3aa9					; 
3aa9			 
3aa9					; destroy value TOS 
3aa9			 
3aa9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa9 cd 8a 1d			call macro_forth_dsp_pop 
3aac				endm 
# End of macro FORTH_DSP_POP
3aac			 
3aac					; TODO push value back onto stack for another op etc 
3aac			 
3aac			;		pop hl 
3aac			 
3aac cd d6 1a				call forth_push_numhl 
3aaf			 
3aaf			.mul_done: 
3aaf					NEXTW 
3aaf cd 6c ee			call parse_vector 
3ab2 c3 b9 1e			jp macro_next 
3ab5				endm 
# End of macro NEXTW
3ab5			 
3ab5			 
3ab5			 
3ab5			 
3ab5			.MIN: 
3ab5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ab5 49				db WORD_SYS_CORE+53             
3ab6 3c 3b			dw .MAX            
3ab8 04				db 3 + 1 
3ab9 .. 00			db "MIN",0              
3abd				endm 
# End of macro CWHEAD
3abd			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3abd					if DEBUG_FORTH_WORDS_KEY 
3abd						DMARK "MIN" 
3abd f5				push af  
3abe 3a d2 3a			ld a, (.dmark)  
3ac1 32 62 ee			ld (debug_mark),a  
3ac4 3a d3 3a			ld a, (.dmark+1)  
3ac7 32 63 ee			ld (debug_mark+1),a  
3aca 3a d4 3a			ld a, (.dmark+2)  
3acd 32 64 ee			ld (debug_mark+2),a  
3ad0 18 03			jr .pastdmark  
3ad2 ..			.dmark: db "MIN"  
3ad5 f1			.pastdmark: pop af  
3ad6			endm  
# End of macro DMARK
3ad6						CALLMONITOR 
3ad6 cd 6f ee			call debug_vector  
3ad9				endm  
# End of macro CALLMONITOR
3ad9					endif 
3ad9					; get u2 
3ad9			 
3ad9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad9 cd d2 1c			call macro_dsp_valuehl 
3adc				endm 
# End of macro FORTH_DSP_VALUEHL
3adc			 
3adc e5					push hl   ; u2 
3add			 
3add					; destroy value TOS 
3add			 
3add					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3add cd 8a 1d			call macro_forth_dsp_pop 
3ae0				endm 
# End of macro FORTH_DSP_POP
3ae0			 
3ae0					; get u1 
3ae0			 
3ae0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae0 cd d2 1c			call macro_dsp_valuehl 
3ae3				endm 
# End of macro FORTH_DSP_VALUEHL
3ae3			 
3ae3 e5					push hl  ; u1 
3ae4			 
3ae4					; destroy value TOS 
3ae4			 
3ae4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ae4 cd 8a 1d			call macro_forth_dsp_pop 
3ae7				endm 
# End of macro FORTH_DSP_POP
3ae7			 
3ae7 b7			 or a      ;clear carry flag 
3ae8 e1			  pop hl    ; u1 
3ae9 d1			  pop de    ; u2 
3aea e5				push hl   ; saved in case hl is lowest 
3aeb ed 52		  sbc hl,de 
3aed 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3aef			 
3aef e1				pop hl 
3af0					if DEBUG_FORTH_WORDS 
3af0						DMARK "MIN" 
3af0 f5				push af  
3af1 3a 05 3b			ld a, (.dmark)  
3af4 32 62 ee			ld (debug_mark),a  
3af7 3a 06 3b			ld a, (.dmark+1)  
3afa 32 63 ee			ld (debug_mark+1),a  
3afd 3a 07 3b			ld a, (.dmark+2)  
3b00 32 64 ee			ld (debug_mark+2),a  
3b03 18 03			jr .pastdmark  
3b05 ..			.dmark: db "MIN"  
3b08 f1			.pastdmark: pop af  
3b09			endm  
# End of macro DMARK
3b09						CALLMONITOR 
3b09 cd 6f ee			call debug_vector  
3b0c				endm  
# End of macro CALLMONITOR
3b0c					endif 
3b0c cd d6 1a				call forth_push_numhl 
3b0f			 
3b0f				       NEXTW 
3b0f cd 6c ee			call parse_vector 
3b12 c3 b9 1e			jp macro_next 
3b15				endm 
# End of macro NEXTW
3b15			 
3b15			.mincont:  
3b15 c1				pop bc   ; tidy up 
3b16 eb				ex de , hl  
3b17					if DEBUG_FORTH_WORDS 
3b17						DMARK "MI1" 
3b17 f5				push af  
3b18 3a 2c 3b			ld a, (.dmark)  
3b1b 32 62 ee			ld (debug_mark),a  
3b1e 3a 2d 3b			ld a, (.dmark+1)  
3b21 32 63 ee			ld (debug_mark+1),a  
3b24 3a 2e 3b			ld a, (.dmark+2)  
3b27 32 64 ee			ld (debug_mark+2),a  
3b2a 18 03			jr .pastdmark  
3b2c ..			.dmark: db "MI1"  
3b2f f1			.pastdmark: pop af  
3b30			endm  
# End of macro DMARK
3b30						CALLMONITOR 
3b30 cd 6f ee			call debug_vector  
3b33				endm  
# End of macro CALLMONITOR
3b33					endif 
3b33 cd d6 1a				call forth_push_numhl 
3b36			 
3b36				       NEXTW 
3b36 cd 6c ee			call parse_vector 
3b39 c3 b9 1e			jp macro_next 
3b3c				endm 
# End of macro NEXTW
3b3c			.MAX: 
3b3c				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b3c 4a				db WORD_SYS_CORE+54             
3b3d c3 3b			dw .RND16            
3b3f 04				db 3 + 1 
3b40 .. 00			db "MAX",0              
3b44				endm 
# End of macro CWHEAD
3b44			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b44					if DEBUG_FORTH_WORDS_KEY 
3b44						DMARK "MAX" 
3b44 f5				push af  
3b45 3a 59 3b			ld a, (.dmark)  
3b48 32 62 ee			ld (debug_mark),a  
3b4b 3a 5a 3b			ld a, (.dmark+1)  
3b4e 32 63 ee			ld (debug_mark+1),a  
3b51 3a 5b 3b			ld a, (.dmark+2)  
3b54 32 64 ee			ld (debug_mark+2),a  
3b57 18 03			jr .pastdmark  
3b59 ..			.dmark: db "MAX"  
3b5c f1			.pastdmark: pop af  
3b5d			endm  
# End of macro DMARK
3b5d						CALLMONITOR 
3b5d cd 6f ee			call debug_vector  
3b60				endm  
# End of macro CALLMONITOR
3b60					endif 
3b60					; get u2 
3b60			 
3b60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b60 cd d2 1c			call macro_dsp_valuehl 
3b63				endm 
# End of macro FORTH_DSP_VALUEHL
3b63			 
3b63 e5					push hl   ; u2 
3b64			 
3b64					; destroy value TOS 
3b64			 
3b64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b64 cd 8a 1d			call macro_forth_dsp_pop 
3b67				endm 
# End of macro FORTH_DSP_POP
3b67			 
3b67					; get u1 
3b67			 
3b67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b67 cd d2 1c			call macro_dsp_valuehl 
3b6a				endm 
# End of macro FORTH_DSP_VALUEHL
3b6a			 
3b6a e5					push hl  ; u1 
3b6b			 
3b6b					; destroy value TOS 
3b6b			 
3b6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b6b cd 8a 1d			call macro_forth_dsp_pop 
3b6e				endm 
# End of macro FORTH_DSP_POP
3b6e			 
3b6e b7			 or a      ;clear carry flag 
3b6f e1			  pop hl    ; u1 
3b70 d1			  pop de    ; u2 
3b71 e5				push hl   ; saved in case hl is lowest 
3b72 ed 52		  sbc hl,de 
3b74 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b76			 
3b76 e1				pop hl 
3b77					if DEBUG_FORTH_WORDS 
3b77						DMARK "MAX" 
3b77 f5				push af  
3b78 3a 8c 3b			ld a, (.dmark)  
3b7b 32 62 ee			ld (debug_mark),a  
3b7e 3a 8d 3b			ld a, (.dmark+1)  
3b81 32 63 ee			ld (debug_mark+1),a  
3b84 3a 8e 3b			ld a, (.dmark+2)  
3b87 32 64 ee			ld (debug_mark+2),a  
3b8a 18 03			jr .pastdmark  
3b8c ..			.dmark: db "MAX"  
3b8f f1			.pastdmark: pop af  
3b90			endm  
# End of macro DMARK
3b90						CALLMONITOR 
3b90 cd 6f ee			call debug_vector  
3b93				endm  
# End of macro CALLMONITOR
3b93					endif 
3b93 cd d6 1a				call forth_push_numhl 
3b96			 
3b96				       NEXTW 
3b96 cd 6c ee			call parse_vector 
3b99 c3 b9 1e			jp macro_next 
3b9c				endm 
# End of macro NEXTW
3b9c			 
3b9c			.maxcont:  
3b9c c1				pop bc   ; tidy up 
3b9d eb				ex de , hl  
3b9e					if DEBUG_FORTH_WORDS 
3b9e						DMARK "MA1" 
3b9e f5				push af  
3b9f 3a b3 3b			ld a, (.dmark)  
3ba2 32 62 ee			ld (debug_mark),a  
3ba5 3a b4 3b			ld a, (.dmark+1)  
3ba8 32 63 ee			ld (debug_mark+1),a  
3bab 3a b5 3b			ld a, (.dmark+2)  
3bae 32 64 ee			ld (debug_mark+2),a  
3bb1 18 03			jr .pastdmark  
3bb3 ..			.dmark: db "MA1"  
3bb6 f1			.pastdmark: pop af  
3bb7			endm  
# End of macro DMARK
3bb7						CALLMONITOR 
3bb7 cd 6f ee			call debug_vector  
3bba				endm  
# End of macro CALLMONITOR
3bba					endif 
3bba cd d6 1a				call forth_push_numhl 
3bbd				       NEXTW 
3bbd cd 6c ee			call parse_vector 
3bc0 c3 b9 1e			jp macro_next 
3bc3				endm 
# End of macro NEXTW
3bc3			 
3bc3			.RND16: 
3bc3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3bc3 4e				db WORD_SYS_CORE+58             
3bc4 f5 3b			dw .RND8            
3bc6 06				db 5 + 1 
3bc7 .. 00			db "RND16",0              
3bcd				endm 
# End of macro CWHEAD
3bcd			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3bcd					if DEBUG_FORTH_WORDS_KEY 
3bcd						DMARK "R16" 
3bcd f5				push af  
3bce 3a e2 3b			ld a, (.dmark)  
3bd1 32 62 ee			ld (debug_mark),a  
3bd4 3a e3 3b			ld a, (.dmark+1)  
3bd7 32 63 ee			ld (debug_mark+1),a  
3bda 3a e4 3b			ld a, (.dmark+2)  
3bdd 32 64 ee			ld (debug_mark+2),a  
3be0 18 03			jr .pastdmark  
3be2 ..			.dmark: db "R16"  
3be5 f1			.pastdmark: pop af  
3be6			endm  
# End of macro DMARK
3be6						CALLMONITOR 
3be6 cd 6f ee			call debug_vector  
3be9				endm  
# End of macro CALLMONITOR
3be9					endif 
3be9 cd 08 0d				call prng16  
3bec cd d6 1a				call forth_push_numhl 
3bef				       NEXTW 
3bef cd 6c ee			call parse_vector 
3bf2 c3 b9 1e			jp macro_next 
3bf5				endm 
# End of macro NEXTW
3bf5			.RND8: 
3bf5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3bf5 60				db WORD_SYS_CORE+76             
3bf6 2d 3c			dw .RND            
3bf8 05				db 4 + 1 
3bf9 .. 00			db "RND8",0              
3bfe				endm 
# End of macro CWHEAD
3bfe			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bfe					if DEBUG_FORTH_WORDS_KEY 
3bfe						DMARK "RN8" 
3bfe f5				push af  
3bff 3a 13 3c			ld a, (.dmark)  
3c02 32 62 ee			ld (debug_mark),a  
3c05 3a 14 3c			ld a, (.dmark+1)  
3c08 32 63 ee			ld (debug_mark+1),a  
3c0b 3a 15 3c			ld a, (.dmark+2)  
3c0e 32 64 ee			ld (debug_mark+2),a  
3c11 18 03			jr .pastdmark  
3c13 ..			.dmark: db "RN8"  
3c16 f1			.pastdmark: pop af  
3c17			endm  
# End of macro DMARK
3c17						CALLMONITOR 
3c17 cd 6f ee			call debug_vector  
3c1a				endm  
# End of macro CALLMONITOR
3c1a					endif 
3c1a 2a a0 eb				ld hl,(xrandc) 
3c1d 23					inc hl 
3c1e cd 22 0d				call xrnd 
3c21 6f					ld l,a	 
3c22 26 00				ld h,0 
3c24 cd d6 1a				call forth_push_numhl 
3c27				       NEXTW 
3c27 cd 6c ee			call parse_vector 
3c2a c3 b9 1e			jp macro_next 
3c2d				endm 
# End of macro NEXTW
3c2d			.RND: 
3c2d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3c2d 60				db WORD_SYS_CORE+76             
3c2e 36 3d			dw .ENDMATHS            
3c30 04				db 3 + 1 
3c31 .. 00			db "RND",0              
3c35				endm 
# End of macro CWHEAD
3c35			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c35			 
3c35					if DEBUG_FORTH_WORDS_KEY 
3c35						DMARK "RND" 
3c35 f5				push af  
3c36 3a 4a 3c			ld a, (.dmark)  
3c39 32 62 ee			ld (debug_mark),a  
3c3c 3a 4b 3c			ld a, (.dmark+1)  
3c3f 32 63 ee			ld (debug_mark+1),a  
3c42 3a 4c 3c			ld a, (.dmark+2)  
3c45 32 64 ee			ld (debug_mark+2),a  
3c48 18 03			jr .pastdmark  
3c4a ..			.dmark: db "RND"  
3c4d f1			.pastdmark: pop af  
3c4e			endm  
# End of macro DMARK
3c4e						CALLMONITOR 
3c4e cd 6f ee			call debug_vector  
3c51				endm  
# End of macro CALLMONITOR
3c51					endif 
3c51					 
3c51					FORTH_DSP_VALUEHL    ; upper range 
3c51 cd d2 1c			call macro_dsp_valuehl 
3c54				endm 
# End of macro FORTH_DSP_VALUEHL
3c54			 
3c54 22 a4 eb				ld (LFSRSeed), hl	 
3c57			 
3c57					if DEBUG_FORTH_WORDS 
3c57						DMARK "RN1" 
3c57 f5				push af  
3c58 3a 6c 3c			ld a, (.dmark)  
3c5b 32 62 ee			ld (debug_mark),a  
3c5e 3a 6d 3c			ld a, (.dmark+1)  
3c61 32 63 ee			ld (debug_mark+1),a  
3c64 3a 6e 3c			ld a, (.dmark+2)  
3c67 32 64 ee			ld (debug_mark+2),a  
3c6a 18 03			jr .pastdmark  
3c6c ..			.dmark: db "RN1"  
3c6f f1			.pastdmark: pop af  
3c70			endm  
# End of macro DMARK
3c70						CALLMONITOR 
3c70 cd 6f ee			call debug_vector  
3c73				endm  
# End of macro CALLMONITOR
3c73					endif 
3c73					FORTH_DSP_POP 
3c73 cd 8a 1d			call macro_forth_dsp_pop 
3c76				endm 
# End of macro FORTH_DSP_POP
3c76			 
3c76					FORTH_DSP_VALUEHL    ; low range 
3c76 cd d2 1c			call macro_dsp_valuehl 
3c79				endm 
# End of macro FORTH_DSP_VALUEHL
3c79			 
3c79					if DEBUG_FORTH_WORDS 
3c79						DMARK "RN2" 
3c79 f5				push af  
3c7a 3a 8e 3c			ld a, (.dmark)  
3c7d 32 62 ee			ld (debug_mark),a  
3c80 3a 8f 3c			ld a, (.dmark+1)  
3c83 32 63 ee			ld (debug_mark+1),a  
3c86 3a 90 3c			ld a, (.dmark+2)  
3c89 32 64 ee			ld (debug_mark+2),a  
3c8c 18 03			jr .pastdmark  
3c8e ..			.dmark: db "RN2"  
3c91 f1			.pastdmark: pop af  
3c92			endm  
# End of macro DMARK
3c92						CALLMONITOR 
3c92 cd 6f ee			call debug_vector  
3c95				endm  
# End of macro CALLMONITOR
3c95					endif 
3c95 22 a6 eb				ld (LFSRSeed+2), hl 
3c98			 
3c98					FORTH_DSP_POP 
3c98 cd 8a 1d			call macro_forth_dsp_pop 
3c9b				endm 
# End of macro FORTH_DSP_POP
3c9b			 
3c9b e5					push hl 
3c9c			 
3c9c e1			.inrange:	pop hl 
3c9d cd 08 0d				call prng16  
3ca0					if DEBUG_FORTH_WORDS 
3ca0						DMARK "RN3" 
3ca0 f5				push af  
3ca1 3a b5 3c			ld a, (.dmark)  
3ca4 32 62 ee			ld (debug_mark),a  
3ca7 3a b6 3c			ld a, (.dmark+1)  
3caa 32 63 ee			ld (debug_mark+1),a  
3cad 3a b7 3c			ld a, (.dmark+2)  
3cb0 32 64 ee			ld (debug_mark+2),a  
3cb3 18 03			jr .pastdmark  
3cb5 ..			.dmark: db "RN3"  
3cb8 f1			.pastdmark: pop af  
3cb9			endm  
# End of macro DMARK
3cb9						CALLMONITOR 
3cb9 cd 6f ee			call debug_vector  
3cbc				endm  
# End of macro CALLMONITOR
3cbc					endif 
3cbc					 
3cbc					; if the range is 8bit knock out the high byte 
3cbc			 
3cbc ed 5b a4 eb			ld de, (LFSRSeed)     ; check high level 
3cc0			 
3cc0 3e 00				ld a, 0 
3cc2 ba					cp d  
3cc3 20 1e				jr nz, .hirange 
3cc5 26 00				ld h, 0   ; knock it down to 8bit 
3cc7			 
3cc7					if DEBUG_FORTH_WORDS 
3cc7						DMARK "RNk" 
3cc7 f5				push af  
3cc8 3a dc 3c			ld a, (.dmark)  
3ccb 32 62 ee			ld (debug_mark),a  
3cce 3a dd 3c			ld a, (.dmark+1)  
3cd1 32 63 ee			ld (debug_mark+1),a  
3cd4 3a de 3c			ld a, (.dmark+2)  
3cd7 32 64 ee			ld (debug_mark+2),a  
3cda 18 03			jr .pastdmark  
3cdc ..			.dmark: db "RNk"  
3cdf f1			.pastdmark: pop af  
3ce0			endm  
# End of macro DMARK
3ce0						CALLMONITOR 
3ce0 cd 6f ee			call debug_vector  
3ce3				endm  
# End of macro CALLMONITOR
3ce3					endif 
3ce3			.hirange:   
3ce3 e5					push hl  
3ce4 b7					or a  
3ce5 ed 52		                sbc hl, de 
3ce7			 
3ce7					;call cmp16 
3ce7			 
3ce7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ce9 e1					pop hl 
3cea e5					push hl 
3ceb			 
3ceb					if DEBUG_FORTH_WORDS 
3ceb						DMARK "RN4" 
3ceb f5				push af  
3cec 3a 00 3d			ld a, (.dmark)  
3cef 32 62 ee			ld (debug_mark),a  
3cf2 3a 01 3d			ld a, (.dmark+1)  
3cf5 32 63 ee			ld (debug_mark+1),a  
3cf8 3a 02 3d			ld a, (.dmark+2)  
3cfb 32 64 ee			ld (debug_mark+2),a  
3cfe 18 03			jr .pastdmark  
3d00 ..			.dmark: db "RN4"  
3d03 f1			.pastdmark: pop af  
3d04			endm  
# End of macro DMARK
3d04						CALLMONITOR 
3d04 cd 6f ee			call debug_vector  
3d07				endm  
# End of macro CALLMONITOR
3d07					endif 
3d07 ed 5b a6 eb			ld de, (LFSRSeed+2)   ; check low range 
3d0b					;call cmp16 
3d0b				 
3d0b b7					or a  
3d0c ed 52		                sbc hl, de 
3d0e 38 8c				jr c, .inrange 
3d10			 
3d10 e1					pop hl 
3d11					 
3d11					if DEBUG_FORTH_WORDS 
3d11						DMARK "RNd" 
3d11 f5				push af  
3d12 3a 26 3d			ld a, (.dmark)  
3d15 32 62 ee			ld (debug_mark),a  
3d18 3a 27 3d			ld a, (.dmark+1)  
3d1b 32 63 ee			ld (debug_mark+1),a  
3d1e 3a 28 3d			ld a, (.dmark+2)  
3d21 32 64 ee			ld (debug_mark+2),a  
3d24 18 03			jr .pastdmark  
3d26 ..			.dmark: db "RNd"  
3d29 f1			.pastdmark: pop af  
3d2a			endm  
# End of macro DMARK
3d2a						CALLMONITOR 
3d2a cd 6f ee			call debug_vector  
3d2d				endm  
# End of macro CALLMONITOR
3d2d					endif 
3d2d			 
3d2d			 
3d2d cd d6 1a				call forth_push_numhl 
3d30				       NEXTW 
3d30 cd 6c ee			call parse_vector 
3d33 c3 b9 1e			jp macro_next 
3d36				endm 
# End of macro NEXTW
3d36			 
3d36			.ENDMATHS: 
3d36			 
3d36			; eof 
3d36			 
# End of file forth_words_maths.asm
3d36			include "forth_words_display.asm" 
3d36			 
3d36			; | ## Display Words 
3d36			 
3d36			.ACT: 
3d36			 
3d36				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3d36 62				db WORD_SYS_CORE+78             
3d37 85 3d			dw .INFO            
3d39 07				db 6 + 1 
3d3a .. 00			db "ACTIVE",0              
3d41				endm 
# End of macro CWHEAD
3d41			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3d41			;  
3d41			; | | To display a pulsing activity indicator in a processing loop do this... 
3d41			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3d41			 
3d41					if DEBUG_FORTH_WORDS_KEY 
3d41						DMARK "ACT" 
3d41 f5				push af  
3d42 3a 56 3d			ld a, (.dmark)  
3d45 32 62 ee			ld (debug_mark),a  
3d48 3a 57 3d			ld a, (.dmark+1)  
3d4b 32 63 ee			ld (debug_mark+1),a  
3d4e 3a 58 3d			ld a, (.dmark+2)  
3d51 32 64 ee			ld (debug_mark+2),a  
3d54 18 03			jr .pastdmark  
3d56 ..			.dmark: db "ACT"  
3d59 f1			.pastdmark: pop af  
3d5a			endm  
# End of macro DMARK
3d5a						CALLMONITOR 
3d5a cd 6f ee			call debug_vector  
3d5d				endm  
# End of macro CALLMONITOR
3d5d					endif 
3d5d cd 0f 0b				call active 
3d60					if DEBUG_FORTH_WORDS 
3d60						DMARK "ACp" 
3d60 f5				push af  
3d61 3a 75 3d			ld a, (.dmark)  
3d64 32 62 ee			ld (debug_mark),a  
3d67 3a 76 3d			ld a, (.dmark+1)  
3d6a 32 63 ee			ld (debug_mark+1),a  
3d6d 3a 77 3d			ld a, (.dmark+2)  
3d70 32 64 ee			ld (debug_mark+2),a  
3d73 18 03			jr .pastdmark  
3d75 ..			.dmark: db "ACp"  
3d78 f1			.pastdmark: pop af  
3d79			endm  
# End of macro DMARK
3d79						CALLMONITOR 
3d79 cd 6f ee			call debug_vector  
3d7c				endm  
# End of macro CALLMONITOR
3d7c					endif 
3d7c cd 40 1b				call forth_push_str 
3d7f			 
3d7f					NEXTW 
3d7f cd 6c ee			call parse_vector 
3d82 c3 b9 1e			jp macro_next 
3d85				endm 
# End of macro NEXTW
3d85			.INFO: 
3d85			 
3d85				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d85 62				db WORD_SYS_CORE+78             
3d86 a5 3d			dw .ATP            
3d88 05				db 4 + 1 
3d89 .. 00			db "INFO",0              
3d8e				endm 
# End of macro CWHEAD
3d8e			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d8e					FORTH_DSP_VALUEHL 
3d8e cd d2 1c			call macro_dsp_valuehl 
3d91				endm 
# End of macro FORTH_DSP_VALUEHL
3d91			 
3d91					FORTH_DSP_POP 
3d91 cd 8a 1d			call macro_forth_dsp_pop 
3d94				endm 
# End of macro FORTH_DSP_POP
3d94			 
3d94 e5					push hl 
3d95			 
3d95					FORTH_DSP_VALUEHL 
3d95 cd d2 1c			call macro_dsp_valuehl 
3d98				endm 
# End of macro FORTH_DSP_VALUEHL
3d98			 
3d98					FORTH_DSP_POP 
3d98 cd 8a 1d			call macro_forth_dsp_pop 
3d9b				endm 
# End of macro FORTH_DSP_POP
3d9b			 
3d9b d1					pop de 
3d9c			 
3d9c cd 49 0b				call info_panel 
3d9f			 
3d9f			 
3d9f					NEXTW 
3d9f cd 6c ee			call parse_vector 
3da2 c3 b9 1e			jp macro_next 
3da5				endm 
# End of macro NEXTW
3da5			.ATP: 
3da5				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3da5 62				db WORD_SYS_CORE+78             
3da6 1f 3e			dw .FB            
3da8 04				db 3 + 1 
3da9 .. 00			db "AT?",0              
3dad				endm 
# End of macro CWHEAD
3dad			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3dad					if DEBUG_FORTH_WORDS_KEY 
3dad						DMARK "AT?" 
3dad f5				push af  
3dae 3a c2 3d			ld a, (.dmark)  
3db1 32 62 ee			ld (debug_mark),a  
3db4 3a c3 3d			ld a, (.dmark+1)  
3db7 32 63 ee			ld (debug_mark+1),a  
3dba 3a c4 3d			ld a, (.dmark+2)  
3dbd 32 64 ee			ld (debug_mark+2),a  
3dc0 18 03			jr .pastdmark  
3dc2 ..			.dmark: db "AT?"  
3dc5 f1			.pastdmark: pop af  
3dc6			endm  
# End of macro DMARK
3dc6						CALLMONITOR 
3dc6 cd 6f ee			call debug_vector  
3dc9				endm  
# End of macro CALLMONITOR
3dc9					endif 
3dc9 3a 55 ea				ld a, (f_cursor_ptr) 
3dcc			 
3dcc			if DEBUG_FORTH_WORDS 
3dcc				DMARK "AT?" 
3dcc f5				push af  
3dcd 3a e1 3d			ld a, (.dmark)  
3dd0 32 62 ee			ld (debug_mark),a  
3dd3 3a e2 3d			ld a, (.dmark+1)  
3dd6 32 63 ee			ld (debug_mark+1),a  
3dd9 3a e3 3d			ld a, (.dmark+2)  
3ddc 32 64 ee			ld (debug_mark+2),a  
3ddf 18 03			jr .pastdmark  
3de1 ..			.dmark: db "AT?"  
3de4 f1			.pastdmark: pop af  
3de5			endm  
# End of macro DMARK
3de5				CALLMONITOR 
3de5 cd 6f ee			call debug_vector  
3de8				endm  
# End of macro CALLMONITOR
3de8			endif	 
3de8					; count the number of rows 
3de8			 
3de8 06 00				ld b, 0 
3dea 4f			.atpr:		ld c, a    ; save in case we go below zero 
3deb d6 28				sub display_cols 
3ded f2 f3 3d				jp p, .atprunder 
3df0 04					inc b 
3df1 18 f7				jr .atpr 
3df3			.atprunder:	 
3df3			if DEBUG_FORTH_WORDS 
3df3				DMARK "A?2" 
3df3 f5				push af  
3df4 3a 08 3e			ld a, (.dmark)  
3df7 32 62 ee			ld (debug_mark),a  
3dfa 3a 09 3e			ld a, (.dmark+1)  
3dfd 32 63 ee			ld (debug_mark+1),a  
3e00 3a 0a 3e			ld a, (.dmark+2)  
3e03 32 64 ee			ld (debug_mark+2),a  
3e06 18 03			jr .pastdmark  
3e08 ..			.dmark: db "A?2"  
3e0b f1			.pastdmark: pop af  
3e0c			endm  
# End of macro DMARK
3e0c				CALLMONITOR 
3e0c cd 6f ee			call debug_vector  
3e0f				endm  
# End of macro CALLMONITOR
3e0f			endif	 
3e0f 26 00				ld h, 0 
3e11 69					ld l, c 
3e12 cd d6 1a				call forth_push_numhl 
3e15 68					ld l, b  
3e16 cd d6 1a				call forth_push_numhl 
3e19			 
3e19			 
3e19				NEXTW 
3e19 cd 6c ee			call parse_vector 
3e1c c3 b9 1e			jp macro_next 
3e1f				endm 
# End of macro NEXTW
3e1f			 
3e1f			.FB: 
3e1f				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3e1f 1b				db WORD_SYS_CORE+7             
3e20 70 3e			dw .EMIT            
3e22 03				db 2 + 1 
3e23 .. 00			db "FB",0              
3e26				endm 
# End of macro CWHEAD
3e26			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3e26			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3e26			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3e26			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3e26					if DEBUG_FORTH_WORDS_KEY 
3e26						DMARK "FB." 
3e26 f5				push af  
3e27 3a 3b 3e			ld a, (.dmark)  
3e2a 32 62 ee			ld (debug_mark),a  
3e2d 3a 3c 3e			ld a, (.dmark+1)  
3e30 32 63 ee			ld (debug_mark+1),a  
3e33 3a 3d 3e			ld a, (.dmark+2)  
3e36 32 64 ee			ld (debug_mark+2),a  
3e39 18 03			jr .pastdmark  
3e3b ..			.dmark: db "FB."  
3e3e f1			.pastdmark: pop af  
3e3f			endm  
# End of macro DMARK
3e3f						CALLMONITOR 
3e3f cd 6f ee			call debug_vector  
3e42				endm  
# End of macro CALLMONITOR
3e42					endif 
3e42			 
3e42					FORTH_DSP_VALUEHL 
3e42 cd d2 1c			call macro_dsp_valuehl 
3e45				endm 
# End of macro FORTH_DSP_VALUEHL
3e45			 
3e45 7d					ld a, l 
3e46 fe 01				cp 1 
3e48 20 05				jr nz, .fbn1 
3e4a 21 07 ed				ld hl, display_fb1 
3e4d 18 15				jr .fbset 
3e4f fe 02		.fbn1:		cp 2 
3e51 20 05				jr nz, .fbn2 
3e53 21 c5 eb				ld hl, display_fb2 
3e56 18 0c				jr .fbset 
3e58 fe 03		.fbn2:		cp 3 
3e5a 20 05				jr nz, .fbn3 
3e5c 21 66 ec				ld hl, display_fb3 
3e5f 18 03				jr .fbset 
3e61			.fbn3:		 ; if invalid number select first 
3e61 21 07 ed				ld hl, display_fb1 
3e64 22 c3 eb		.fbset:		ld (display_fb_active), hl 
3e67			 
3e67					FORTH_DSP_POP 
3e67 cd 8a 1d			call macro_forth_dsp_pop 
3e6a				endm 
# End of macro FORTH_DSP_POP
3e6a			 
3e6a					NEXTW 
3e6a cd 6c ee			call parse_vector 
3e6d c3 b9 1e			jp macro_next 
3e70				endm 
# End of macro NEXTW
3e70			 
3e70			 
3e70			.EMIT: 
3e70				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3e70 1b				db WORD_SYS_CORE+7             
3e71 c3 3e			dw .DOTH            
3e73 05				db 4 + 1 
3e74 .. 00			db "EMIT",0              
3e79				endm 
# End of macro CWHEAD
3e79			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3e79					; get value off TOS and display it 
3e79			 
3e79					if DEBUG_FORTH_WORDS_KEY 
3e79						DMARK "EMT" 
3e79 f5				push af  
3e7a 3a 8e 3e			ld a, (.dmark)  
3e7d 32 62 ee			ld (debug_mark),a  
3e80 3a 8f 3e			ld a, (.dmark+1)  
3e83 32 63 ee			ld (debug_mark+1),a  
3e86 3a 90 3e			ld a, (.dmark+2)  
3e89 32 64 ee			ld (debug_mark+2),a  
3e8c 18 03			jr .pastdmark  
3e8e ..			.dmark: db "EMT"  
3e91 f1			.pastdmark: pop af  
3e92			endm  
# End of macro DMARK
3e92						CALLMONITOR 
3e92 cd 6f ee			call debug_vector  
3e95				endm  
# End of macro CALLMONITOR
3e95					endif 
3e95			 
3e95					FORTH_DSP_VALUEHL 
3e95 cd d2 1c			call macro_dsp_valuehl 
3e98				endm 
# End of macro FORTH_DSP_VALUEHL
3e98			 
3e98 7d					ld a,l 
3e99			 
3e99					; TODO write to display 
3e99			 
3e99 32 b6 e4				ld (os_input), a 
3e9c 3e 00				ld a, 0 
3e9e 32 b7 e4				ld (os_input+1), a 
3ea1					 
3ea1 3a 55 ea				ld a, (f_cursor_ptr) 
3ea4 11 b6 e4				ld de, os_input 
3ea7 cd c9 0b				call str_at_display 
3eaa			 
3eaa			 
3eaa 3a 33 ea				ld a,(cli_autodisplay) 
3ead			;		cp 0 
3ead b7					or a 
3eae 28 03				jr z, .enoupdate 
3eb0 cd d9 0b						call update_display 
3eb3					.enoupdate: 
3eb3			 
3eb3 3a 55 ea				ld a, (f_cursor_ptr) 
3eb6 3c					inc a 
3eb7 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
3eba			 
3eba			 
3eba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eba cd 8a 1d			call macro_forth_dsp_pop 
3ebd				endm 
# End of macro FORTH_DSP_POP
3ebd			  
3ebd			 
3ebd					NEXTW 
3ebd cd 6c ee			call parse_vector 
3ec0 c3 b9 1e			jp macro_next 
3ec3				endm 
# End of macro NEXTW
3ec3			.DOTH: 
3ec3				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3ec3 1c				db WORD_SYS_CORE+8             
3ec4 f6 3e			dw .DOTF            
3ec6 03				db 2 + 1 
3ec7 .. 00			db ".-",0              
3eca				endm 
# End of macro CWHEAD
3eca			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3eca					; get value off TOS and display it 
3eca					if DEBUG_FORTH_WORDS_KEY 
3eca						DMARK "DTD" 
3eca f5				push af  
3ecb 3a df 3e			ld a, (.dmark)  
3ece 32 62 ee			ld (debug_mark),a  
3ed1 3a e0 3e			ld a, (.dmark+1)  
3ed4 32 63 ee			ld (debug_mark+1),a  
3ed7 3a e1 3e			ld a, (.dmark+2)  
3eda 32 64 ee			ld (debug_mark+2),a  
3edd 18 03			jr .pastdmark  
3edf ..			.dmark: db "DTD"  
3ee2 f1			.pastdmark: pop af  
3ee3			endm  
# End of macro DMARK
3ee3						CALLMONITOR 
3ee3 cd 6f ee			call debug_vector  
3ee6				endm  
# End of macro CALLMONITOR
3ee6					endif 
3ee6 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ee8 3e 00			ld a, 0 
3eea 32 34 ea			ld (cli_mvdot), a 
3eed c3 50 3f			jp .dotgo 
3ef0				NEXTW 
3ef0 cd 6c ee			call parse_vector 
3ef3 c3 b9 1e			jp macro_next 
3ef6				endm 
# End of macro NEXTW
3ef6			.DOTF: 
3ef6				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3ef6 1c				db WORD_SYS_CORE+8             
3ef7 27 3f			dw .DOT            
3ef9 03				db 2 + 1 
3efa .. 00			db ".>",0              
3efd				endm 
# End of macro CWHEAD
3efd			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3efd					; get value off TOS and display it 
3efd			        ; TODO BUG adds extra spaces 
3efd			        ; TODO BUG handle numerics? 
3efd					if DEBUG_FORTH_WORDS_KEY 
3efd						DMARK "DTC" 
3efd f5				push af  
3efe 3a 12 3f			ld a, (.dmark)  
3f01 32 62 ee			ld (debug_mark),a  
3f04 3a 13 3f			ld a, (.dmark+1)  
3f07 32 63 ee			ld (debug_mark+1),a  
3f0a 3a 14 3f			ld a, (.dmark+2)  
3f0d 32 64 ee			ld (debug_mark+2),a  
3f10 18 03			jr .pastdmark  
3f12 ..			.dmark: db "DTC"  
3f15 f1			.pastdmark: pop af  
3f16			endm  
# End of macro DMARK
3f16						CALLMONITOR 
3f16 cd 6f ee			call debug_vector  
3f19				endm  
# End of macro CALLMONITOR
3f19					endif 
3f19 3e 01			ld a, 1 
3f1b 32 34 ea			ld (cli_mvdot), a 
3f1e c3 50 3f			jp .dotgo 
3f21				NEXTW 
3f21 cd 6c ee			call parse_vector 
3f24 c3 b9 1e			jp macro_next 
3f27				endm 
# End of macro NEXTW
3f27			 
3f27			.DOT: 
3f27				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3f27 1c				db WORD_SYS_CORE+8             
3f28 02 41			dw .CLS            
3f2a 02				db 1 + 1 
3f2b .. 00			db ".",0              
3f2d				endm 
# End of macro CWHEAD
3f2d			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3f2d					; get value off TOS and display it 
3f2d			 
3f2d					if DEBUG_FORTH_WORDS_KEY 
3f2d						DMARK "DOT" 
3f2d f5				push af  
3f2e 3a 42 3f			ld a, (.dmark)  
3f31 32 62 ee			ld (debug_mark),a  
3f34 3a 43 3f			ld a, (.dmark+1)  
3f37 32 63 ee			ld (debug_mark+1),a  
3f3a 3a 44 3f			ld a, (.dmark+2)  
3f3d 32 64 ee			ld (debug_mark+2),a  
3f40 18 03			jr .pastdmark  
3f42 ..			.dmark: db "DOT"  
3f45 f1			.pastdmark: pop af  
3f46			endm  
# End of macro DMARK
3f46						CALLMONITOR 
3f46 cd 6f ee			call debug_vector  
3f49				endm  
# End of macro CALLMONITOR
3f49					endif 
3f49 3e 00			ld a, 0 
3f4b 32 34 ea			ld (cli_mvdot), a 
3f4e 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3f50				 
3f50			 
3f50			.dotgo: 
3f50			 
3f50			; move up type to on stack for parserv5 
3f50					FORTH_DSP 
3f50 cd 98 1c			call macro_forth_dsp 
3f53				endm 
# End of macro FORTH_DSP
3f53				;FORTH_DSP_VALUE  
3f53			 
3f53			if DEBUG_FORTH_DOT 
3f53				DMARK "DOT" 
3f53 f5				push af  
3f54 3a 68 3f			ld a, (.dmark)  
3f57 32 62 ee			ld (debug_mark),a  
3f5a 3a 69 3f			ld a, (.dmark+1)  
3f5d 32 63 ee			ld (debug_mark+1),a  
3f60 3a 6a 3f			ld a, (.dmark+2)  
3f63 32 64 ee			ld (debug_mark+2),a  
3f66 18 03			jr .pastdmark  
3f68 ..			.dmark: db "DOT"  
3f6b f1			.pastdmark: pop af  
3f6c			endm  
# End of macro DMARK
3f6c				CALLMONITOR 
3f6c cd 6f ee			call debug_vector  
3f6f				endm  
# End of macro CALLMONITOR
3f6f			endif	 
3f6f			;		.print: 
3f6f			 
3f6f 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3f70 23				inc hl   ; position to the actual value 
3f71 fe 01			cp DS_TYPE_STR 
3f73 20 06			jr nz, .dotnum1  
3f75			 
3f75			; display string 
3f75				FORTH_DSP_VALUE  
3f75 cd bb 1c			call macro_forth_dsp_value 
3f78				endm 
# End of macro FORTH_DSP_VALUE
3f78 eb				ex de,hl 
3f79 18 49			jr .dotwrite 
3f7b			 
3f7b			.dotnum1: 
3f7b fe 02			cp DS_TYPE_INUM 
3f7d 20 44			jr nz, .dotflot 
3f7f			 
3f7f			 
3f7f			; display number 
3f7f			 
3f7f			;	push hl 
3f7f			;	call clear_display 
3f7f			;	pop hl 
3f7f			 
3f7f 5e				ld e, (hl) 
3f80 23				inc hl 
3f81 56				ld d, (hl) 
3f82 21 b8 e2			ld hl, scratch 
3f85			if DEBUG_FORTH_DOT 
3f85				DMARK "DT1" 
3f85 f5				push af  
3f86 3a 9a 3f			ld a, (.dmark)  
3f89 32 62 ee			ld (debug_mark),a  
3f8c 3a 9b 3f			ld a, (.dmark+1)  
3f8f 32 63 ee			ld (debug_mark+1),a  
3f92 3a 9c 3f			ld a, (.dmark+2)  
3f95 32 64 ee			ld (debug_mark+2),a  
3f98 18 03			jr .pastdmark  
3f9a ..			.dmark: db "DT1"  
3f9d f1			.pastdmark: pop af  
3f9e			endm  
# End of macro DMARK
3f9e				CALLMONITOR 
3f9e cd 6f ee			call debug_vector  
3fa1				endm  
# End of macro CALLMONITOR
3fa1			endif	 
3fa1			 
3fa1 cd e8 10			call uitoa_16 
3fa4 eb				ex de,hl 
3fa5			 
3fa5			if DEBUG_FORTH_DOT 
3fa5				DMARK "DT2" 
3fa5 f5				push af  
3fa6 3a ba 3f			ld a, (.dmark)  
3fa9 32 62 ee			ld (debug_mark),a  
3fac 3a bb 3f			ld a, (.dmark+1)  
3faf 32 63 ee			ld (debug_mark+1),a  
3fb2 3a bc 3f			ld a, (.dmark+2)  
3fb5 32 64 ee			ld (debug_mark+2),a  
3fb8 18 03			jr .pastdmark  
3fba ..			.dmark: db "DT2"  
3fbd f1			.pastdmark: pop af  
3fbe			endm  
# End of macro DMARK
3fbe				CALLMONITOR 
3fbe cd 6f ee			call debug_vector  
3fc1				endm  
# End of macro CALLMONITOR
3fc1			endif	 
3fc1			 
3fc1			;	ld de, os_word_scratch 
3fc1 18 01			jr .dotwrite 
3fc3			 
3fc3 00			.dotflot:   nop 
3fc4			; TODO print floating point number 
3fc4			 
3fc4			.dotwrite:		 
3fc4			 
3fc4					; if c is set then set all '-' to spaces 
3fc4					; need to also take into account .>  
3fc4			 
3fc4 3e 01				ld a, 1 
3fc6 b9					cp c 
3fc7 20 65				jr nz, .nodashswap 
3fc9			 
3fc9					; DE has the string to write, working with HL 
3fc9			 
3fc9 06 ff				ld b, 255 
3fcb d5					push de 
3fcc e1					pop hl 
3fcd			 
3fcd			if DEBUG_FORTH_DOT 
3fcd				DMARK "DT-" 
3fcd f5				push af  
3fce 3a e2 3f			ld a, (.dmark)  
3fd1 32 62 ee			ld (debug_mark),a  
3fd4 3a e3 3f			ld a, (.dmark+1)  
3fd7 32 63 ee			ld (debug_mark+1),a  
3fda 3a e4 3f			ld a, (.dmark+2)  
3fdd 32 64 ee			ld (debug_mark+2),a  
3fe0 18 03			jr .pastdmark  
3fe2 ..			.dmark: db "DT-"  
3fe5 f1			.pastdmark: pop af  
3fe6			endm  
# End of macro DMARK
3fe6				CALLMONITOR 
3fe6 cd 6f ee			call debug_vector  
3fe9				endm  
# End of macro CALLMONITOR
3fe9			endif	 
3fe9 7e			.dashscan:	ld a, (hl) 
3fea			;		cp 0 
3fea b7					or a 
3feb 28 41				jr z, .nodashswap 
3fed fe 2d				cp '-' 
3fef 20 02				jr nz, .dashskip 
3ff1			;		ld a, ' ' 
3ff1 36 20				ld (hl), ' ' 
3ff3 23			.dashskip:	inc hl 
3ff4			if DEBUG_FORTH_DOT 
3ff4				DMARK "D-2" 
3ff4 f5				push af  
3ff5 3a 09 40			ld a, (.dmark)  
3ff8 32 62 ee			ld (debug_mark),a  
3ffb 3a 0a 40			ld a, (.dmark+1)  
3ffe 32 63 ee			ld (debug_mark+1),a  
4001 3a 0b 40			ld a, (.dmark+2)  
4004 32 64 ee			ld (debug_mark+2),a  
4007 18 03			jr .pastdmark  
4009 ..			.dmark: db "D-2"  
400c f1			.pastdmark: pop af  
400d			endm  
# End of macro DMARK
400d				CALLMONITOR 
400d cd 6f ee			call debug_vector  
4010				endm  
# End of macro CALLMONITOR
4010			endif	 
4010 10 d7				djnz .dashscan 
4012			 
4012			if DEBUG_FORTH_DOT 
4012				DMARK "D-1" 
4012 f5				push af  
4013 3a 27 40			ld a, (.dmark)  
4016 32 62 ee			ld (debug_mark),a  
4019 3a 28 40			ld a, (.dmark+1)  
401c 32 63 ee			ld (debug_mark+1),a  
401f 3a 29 40			ld a, (.dmark+2)  
4022 32 64 ee			ld (debug_mark+2),a  
4025 18 03			jr .pastdmark  
4027 ..			.dmark: db "D-1"  
402a f1			.pastdmark: pop af  
402b			endm  
# End of macro DMARK
402b				CALLMONITOR 
402b cd 6f ee			call debug_vector  
402e				endm  
# End of macro CALLMONITOR
402e			endif	 
402e			 
402e			.nodashswap: 
402e			 
402e			if DEBUG_FORTH_DOT 
402e				DMARK "D-o" 
402e f5				push af  
402f 3a 43 40			ld a, (.dmark)  
4032 32 62 ee			ld (debug_mark),a  
4035 3a 44 40			ld a, (.dmark+1)  
4038 32 63 ee			ld (debug_mark+1),a  
403b 3a 45 40			ld a, (.dmark+2)  
403e 32 64 ee			ld (debug_mark+2),a  
4041 18 03			jr .pastdmark  
4043 ..			.dmark: db "D-o"  
4046 f1			.pastdmark: pop af  
4047			endm  
# End of macro DMARK
4047				CALLMONITOR 
4047 cd 6f ee			call debug_vector  
404a				endm  
# End of macro CALLMONITOR
404a			endif	 
404a			 
404a d5					push de   ; save string start in case we need to advance print 
404b			 
404b 3a 55 ea				ld a, (f_cursor_ptr) 
404e cd c9 0b				call str_at_display 
4051 3a 33 ea				ld a,(cli_autodisplay) 
4054			;		cp 0 
4054 b7					or a 
4055 28 03				jr z, .noupdate 
4057 cd d9 0b						call update_display 
405a					.noupdate: 
405a			 
405a			 
405a					; see if we need to advance the print position 
405a			 
405a e1					pop hl   ; get back string 
405b			;		ex de,hl 
405b			 
405b 3a 34 ea				ld a, (cli_mvdot) 
405e			if DEBUG_FORTH_DOT 
405e			;		ld e,a 
405e				DMARK "D>1" 
405e f5				push af  
405f 3a 73 40			ld a, (.dmark)  
4062 32 62 ee			ld (debug_mark),a  
4065 3a 74 40			ld a, (.dmark+1)  
4068 32 63 ee			ld (debug_mark+1),a  
406b 3a 75 40			ld a, (.dmark+2)  
406e 32 64 ee			ld (debug_mark+2),a  
4071 18 03			jr .pastdmark  
4073 ..			.dmark: db "D>1"  
4076 f1			.pastdmark: pop af  
4077			endm  
# End of macro DMARK
4077				CALLMONITOR 
4077 cd 6f ee			call debug_vector  
407a				endm  
# End of macro CALLMONITOR
407a			endif	 
407a			;		cp 0 
407a b7					or a 
407b 28 44				jr z, .noadv 
407d					; yes, lets advance the print position 
407d 3e 00				ld a, 0 
407f cd 44 11				call strlent 
4082			if DEBUG_FORTH_DOT 
4082				DMARK "D-?" 
4082 f5				push af  
4083 3a 97 40			ld a, (.dmark)  
4086 32 62 ee			ld (debug_mark),a  
4089 3a 98 40			ld a, (.dmark+1)  
408c 32 63 ee			ld (debug_mark+1),a  
408f 3a 99 40			ld a, (.dmark+2)  
4092 32 64 ee			ld (debug_mark+2),a  
4095 18 03			jr .pastdmark  
4097 ..			.dmark: db "D-?"  
409a f1			.pastdmark: pop af  
409b			endm  
# End of macro DMARK
409b				CALLMONITOR 
409b cd 6f ee			call debug_vector  
409e				endm  
# End of macro CALLMONITOR
409e			endif	 
409e 3a 55 ea				ld a, (f_cursor_ptr) 
40a1 85					add a,l 
40a2					;call addatohl 
40a2					;ld a, l 
40a2 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
40a5			 
40a5			if DEBUG_FORTH_DOT 
40a5				DMARK "D->" 
40a5 f5				push af  
40a6 3a ba 40			ld a, (.dmark)  
40a9 32 62 ee			ld (debug_mark),a  
40ac 3a bb 40			ld a, (.dmark+1)  
40af 32 63 ee			ld (debug_mark+1),a  
40b2 3a bc 40			ld a, (.dmark+2)  
40b5 32 64 ee			ld (debug_mark+2),a  
40b8 18 03			jr .pastdmark  
40ba ..			.dmark: db "D->"  
40bd f1			.pastdmark: pop af  
40be			endm  
# End of macro DMARK
40be				CALLMONITOR 
40be cd 6f ee			call debug_vector  
40c1				endm  
# End of macro CALLMONITOR
40c1			endif	 
40c1			 
40c1			.noadv:	 
40c1			 
40c1					if DEBUG_FORTH_DOT_WAIT 
40c1							call next_page_prompt 
40c1					endif	 
40c1			; TODO this pop off the stack causes a crash. i dont know why 
40c1			 
40c1			 
40c1			if DEBUG_FORTH_DOT 
40c1				DMARK "DTh" 
40c1 f5				push af  
40c2 3a d6 40			ld a, (.dmark)  
40c5 32 62 ee			ld (debug_mark),a  
40c8 3a d7 40			ld a, (.dmark+1)  
40cb 32 63 ee			ld (debug_mark+1),a  
40ce 3a d8 40			ld a, (.dmark+2)  
40d1 32 64 ee			ld (debug_mark+2),a  
40d4 18 03			jr .pastdmark  
40d6 ..			.dmark: db "DTh"  
40d9 f1			.pastdmark: pop af  
40da			endm  
# End of macro DMARK
40da				CALLMONITOR 
40da cd 6f ee			call debug_vector  
40dd				endm  
# End of macro CALLMONITOR
40dd			endif	 
40dd			 
40dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40dd cd 8a 1d			call macro_forth_dsp_pop 
40e0				endm 
# End of macro FORTH_DSP_POP
40e0			 
40e0			if DEBUG_FORTH_DOT 
40e0				DMARK "DTi" 
40e0 f5				push af  
40e1 3a f5 40			ld a, (.dmark)  
40e4 32 62 ee			ld (debug_mark),a  
40e7 3a f6 40			ld a, (.dmark+1)  
40ea 32 63 ee			ld (debug_mark+1),a  
40ed 3a f7 40			ld a, (.dmark+2)  
40f0 32 64 ee			ld (debug_mark+2),a  
40f3 18 03			jr .pastdmark  
40f5 ..			.dmark: db "DTi"  
40f8 f1			.pastdmark: pop af  
40f9			endm  
# End of macro DMARK
40f9				CALLMONITOR 
40f9 cd 6f ee			call debug_vector  
40fc				endm  
# End of macro CALLMONITOR
40fc			endif	 
40fc			 
40fc			 
40fc					NEXTW 
40fc cd 6c ee			call parse_vector 
40ff c3 b9 1e			jp macro_next 
4102				endm 
# End of macro NEXTW
4102			 
4102			.CLS: 
4102				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4102 35				db WORD_SYS_CORE+33             
4103 32 41			dw .DRAW            
4105 04				db 3 + 1 
4106 .. 00			db "CLS",0              
410a				endm 
# End of macro CWHEAD
410a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
410a					if DEBUG_FORTH_WORDS_KEY 
410a						DMARK "CLS" 
410a f5				push af  
410b 3a 1f 41			ld a, (.dmark)  
410e 32 62 ee			ld (debug_mark),a  
4111 3a 20 41			ld a, (.dmark+1)  
4114 32 63 ee			ld (debug_mark+1),a  
4117 3a 21 41			ld a, (.dmark+2)  
411a 32 64 ee			ld (debug_mark+2),a  
411d 18 03			jr .pastdmark  
411f ..			.dmark: db "CLS"  
4122 f1			.pastdmark: pop af  
4123			endm  
# End of macro DMARK
4123						CALLMONITOR 
4123 cd 6f ee			call debug_vector  
4126				endm  
# End of macro CALLMONITOR
4126					endif 
4126 cd b7 0b				call clear_display 
4129 c3 4c 42				jp .home		; and home cursor 
412c					NEXTW 
412c cd 6c ee			call parse_vector 
412f c3 b9 1e			jp macro_next 
4132				endm 
# End of macro NEXTW
4132			 
4132			.DRAW: 
4132				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4132 36				db WORD_SYS_CORE+34             
4133 60 41			dw .DUMP            
4135 05				db 4 + 1 
4136 .. 00			db "DRAW",0              
413b				endm 
# End of macro CWHEAD
413b			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
413b					if DEBUG_FORTH_WORDS_KEY 
413b						DMARK "DRW" 
413b f5				push af  
413c 3a 50 41			ld a, (.dmark)  
413f 32 62 ee			ld (debug_mark),a  
4142 3a 51 41			ld a, (.dmark+1)  
4145 32 63 ee			ld (debug_mark+1),a  
4148 3a 52 41			ld a, (.dmark+2)  
414b 32 64 ee			ld (debug_mark+2),a  
414e 18 03			jr .pastdmark  
4150 ..			.dmark: db "DRW"  
4153 f1			.pastdmark: pop af  
4154			endm  
# End of macro DMARK
4154						CALLMONITOR 
4154 cd 6f ee			call debug_vector  
4157				endm  
# End of macro CALLMONITOR
4157					endif 
4157 cd d9 0b				call update_display 
415a					NEXTW 
415a cd 6c ee			call parse_vector 
415d c3 b9 1e			jp macro_next 
4160				endm 
# End of macro NEXTW
4160			 
4160			.DUMP: 
4160				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4160 37				db WORD_SYS_CORE+35             
4161 9b 41			dw .CDUMP            
4163 05				db 4 + 1 
4164 .. 00			db "DUMP",0              
4169				endm 
# End of macro CWHEAD
4169			; | DUMP ( x -- ) With address x display dump   | DONE 
4169			; TODO pop address to use off of the stack 
4169					if DEBUG_FORTH_WORDS_KEY 
4169						DMARK "DUM" 
4169 f5				push af  
416a 3a 7e 41			ld a, (.dmark)  
416d 32 62 ee			ld (debug_mark),a  
4170 3a 7f 41			ld a, (.dmark+1)  
4173 32 63 ee			ld (debug_mark+1),a  
4176 3a 80 41			ld a, (.dmark+2)  
4179 32 64 ee			ld (debug_mark+2),a  
417c 18 03			jr .pastdmark  
417e ..			.dmark: db "DUM"  
4181 f1			.pastdmark: pop af  
4182			endm  
# End of macro DMARK
4182						CALLMONITOR 
4182 cd 6f ee			call debug_vector  
4185				endm  
# End of macro CALLMONITOR
4185					endif 
4185 cd b7 0b				call clear_display 
4188			 
4188					; get address 
4188			 
4188					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4188 cd d2 1c			call macro_dsp_valuehl 
418b				endm 
# End of macro FORTH_DSP_VALUEHL
418b				 
418b					; save it for cdump 
418b			 
418b 22 db e5				ld (os_cur_ptr),hl 
418e			 
418e					; destroy value TOS 
418e			 
418e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
418e cd 8a 1d			call macro_forth_dsp_pop 
4191				endm 
# End of macro FORTH_DSP_POP
4191			 
4191 cd 5a 19				call dumpcont	; skip old style of param parsing	 
4194 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4195					NEXTW 
4195 cd 6c ee			call parse_vector 
4198 c3 b9 1e			jp macro_next 
419b				endm 
# End of macro NEXTW
419b			.CDUMP: 
419b				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
419b 38				db WORD_SYS_CORE+36             
419c ce 41			dw .DAT            
419e 06				db 5 + 1 
419f .. 00			db "CDUMP",0              
41a5				endm 
# End of macro CWHEAD
41a5			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
41a5					if DEBUG_FORTH_WORDS_KEY 
41a5						DMARK "CDP" 
41a5 f5				push af  
41a6 3a ba 41			ld a, (.dmark)  
41a9 32 62 ee			ld (debug_mark),a  
41ac 3a bb 41			ld a, (.dmark+1)  
41af 32 63 ee			ld (debug_mark+1),a  
41b2 3a bc 41			ld a, (.dmark+2)  
41b5 32 64 ee			ld (debug_mark+2),a  
41b8 18 03			jr .pastdmark  
41ba ..			.dmark: db "CDP"  
41bd f1			.pastdmark: pop af  
41be			endm  
# End of macro DMARK
41be						CALLMONITOR 
41be cd 6f ee			call debug_vector  
41c1				endm  
# End of macro CALLMONITOR
41c1					endif 
41c1 cd b7 0b				call clear_display 
41c4 cd 5a 19				call dumpcont	 
41c7 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
41c8					NEXTW 
41c8 cd 6c ee			call parse_vector 
41cb c3 b9 1e			jp macro_next 
41ce				endm 
# End of macro NEXTW
41ce			 
41ce			 
41ce			 
41ce			 
41ce			.DAT: 
41ce				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
41ce 3d				db WORD_SYS_CORE+41             
41cf 27 42			dw .HOME            
41d1 03				db 2 + 1 
41d2 .. 00			db "AT",0              
41d5				endm 
# End of macro CWHEAD
41d5			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
41d5					if DEBUG_FORTH_WORDS_KEY 
41d5						DMARK "AT." 
41d5 f5				push af  
41d6 3a ea 41			ld a, (.dmark)  
41d9 32 62 ee			ld (debug_mark),a  
41dc 3a eb 41			ld a, (.dmark+1)  
41df 32 63 ee			ld (debug_mark+1),a  
41e2 3a ec 41			ld a, (.dmark+2)  
41e5 32 64 ee			ld (debug_mark+2),a  
41e8 18 03			jr .pastdmark  
41ea ..			.dmark: db "AT."  
41ed f1			.pastdmark: pop af  
41ee			endm  
# End of macro DMARK
41ee						CALLMONITOR 
41ee cd 6f ee			call debug_vector  
41f1				endm  
# End of macro CALLMONITOR
41f1					endif 
41f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41f1 cd d2 1c			call macro_dsp_valuehl 
41f4				endm 
# End of macro FORTH_DSP_VALUEHL
41f4			 
41f4			 
41f4					; TODO save cursor row 
41f4 7d					ld a,l 
41f5 fe 02				cp 2 
41f7 20 04				jr nz, .crow3 
41f9 3e 28				ld a, display_row_2 
41fb 18 12				jr .ccol1 
41fd fe 03		.crow3:		cp 3 
41ff 20 04				jr nz, .crow4 
4201 3e 50				ld a, display_row_3 
4203 18 0a				jr .ccol1 
4205 fe 04		.crow4:		cp 4 
4207 20 04				jr nz, .crow1 
4209 3e 78				ld a, display_row_4 
420b 18 02				jr .ccol1 
420d 3e 00		.crow1:		ld a,display_row_1 
420f f5			.ccol1:		push af			; got row offset 
4210 6f					ld l,a 
4211 26 00				ld h,0 
4213					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4213 cd 8a 1d			call macro_forth_dsp_pop 
4216				endm 
# End of macro FORTH_DSP_POP
4216					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4216 cd d2 1c			call macro_dsp_valuehl 
4219				endm 
# End of macro FORTH_DSP_VALUEHL
4219					; TODO save cursor col 
4219 f1					pop af 
421a 85					add l		; add col offset 
421b 32 55 ea				ld (f_cursor_ptr), a 
421e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
421e cd 8a 1d			call macro_forth_dsp_pop 
4221				endm 
# End of macro FORTH_DSP_POP
4221			 
4221					; calculate  
4221			 
4221					NEXTW 
4221 cd 6c ee			call parse_vector 
4224 c3 b9 1e			jp macro_next 
4227				endm 
# End of macro NEXTW
4227			 
4227			 
4227			.HOME: 
4227				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4227 41				db WORD_SYS_CORE+45             
4228 57 42			dw .CR            
422a 05				db 4 + 1 
422b .. 00			db "HOME",0              
4230				endm 
# End of macro CWHEAD
4230			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4230					if DEBUG_FORTH_WORDS_KEY 
4230						DMARK "HOM" 
4230 f5				push af  
4231 3a 45 42			ld a, (.dmark)  
4234 32 62 ee			ld (debug_mark),a  
4237 3a 46 42			ld a, (.dmark+1)  
423a 32 63 ee			ld (debug_mark+1),a  
423d 3a 47 42			ld a, (.dmark+2)  
4240 32 64 ee			ld (debug_mark+2),a  
4243 18 03			jr .pastdmark  
4245 ..			.dmark: db "HOM"  
4248 f1			.pastdmark: pop af  
4249			endm  
# End of macro DMARK
4249						CALLMONITOR 
4249 cd 6f ee			call debug_vector  
424c				endm  
# End of macro CALLMONITOR
424c					endif 
424c 3e 00		.home:		ld a, 0		; and home cursor 
424e 32 55 ea				ld (f_cursor_ptr), a 
4251					NEXTW 
4251 cd 6c ee			call parse_vector 
4254 c3 b9 1e			jp macro_next 
4257				endm 
# End of macro NEXTW
4257			 
4257			 
4257			.CR: 
4257				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4257 46				db WORD_SYS_CORE+50             
4258 95 42			dw .SPACE            
425a 03				db 2 + 1 
425b .. 00			db "CR",0              
425e				endm 
# End of macro CWHEAD
425e			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
425e					if DEBUG_FORTH_WORDS_KEY 
425e						DMARK "CR." 
425e f5				push af  
425f 3a 73 42			ld a, (.dmark)  
4262 32 62 ee			ld (debug_mark),a  
4265 3a 74 42			ld a, (.dmark+1)  
4268 32 63 ee			ld (debug_mark+1),a  
426b 3a 75 42			ld a, (.dmark+2)  
426e 32 64 ee			ld (debug_mark+2),a  
4271 18 03			jr .pastdmark  
4273 ..			.dmark: db "CR."  
4276 f1			.pastdmark: pop af  
4277			endm  
# End of macro DMARK
4277						CALLMONITOR 
4277 cd 6f ee			call debug_vector  
427a				endm  
# End of macro CALLMONITOR
427a					endif 
427a 3e 0d				ld a, 13 
427c 32 b8 e2				ld (scratch),a 
427f 3e 0a				ld a, 10 
4281 32 b9 e2				ld (scratch+1),a 
4284 3e 00				ld a, 0 
4286 32 ba e2				ld (scratch+2),a 
4289 21 b8 e2				ld hl, scratch 
428c cd 40 1b				call forth_push_str 
428f					 
428f				       NEXTW 
428f cd 6c ee			call parse_vector 
4292 c3 b9 1e			jp macro_next 
4295				endm 
# End of macro NEXTW
4295			.SPACE: 
4295				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4295 46				db WORD_SYS_CORE+50             
4296 ce 42			dw .SPACES            
4298 03				db 2 + 1 
4299 .. 00			db "BL",0              
429c				endm 
# End of macro CWHEAD
429c			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
429c					if DEBUG_FORTH_WORDS_KEY 
429c						DMARK "BL." 
429c f5				push af  
429d 3a b1 42			ld a, (.dmark)  
42a0 32 62 ee			ld (debug_mark),a  
42a3 3a b2 42			ld a, (.dmark+1)  
42a6 32 63 ee			ld (debug_mark+1),a  
42a9 3a b3 42			ld a, (.dmark+2)  
42ac 32 64 ee			ld (debug_mark+2),a  
42af 18 03			jr .pastdmark  
42b1 ..			.dmark: db "BL."  
42b4 f1			.pastdmark: pop af  
42b5			endm  
# End of macro DMARK
42b5						CALLMONITOR 
42b5 cd 6f ee			call debug_vector  
42b8				endm  
# End of macro CALLMONITOR
42b8					endif 
42b8 3e 20				ld a, " " 
42ba 32 b8 e2				ld (scratch),a 
42bd 3e 00				ld a, 0 
42bf 32 b9 e2				ld (scratch+1),a 
42c2 21 b8 e2				ld hl, scratch 
42c5 cd 40 1b				call forth_push_str 
42c8					 
42c8				       NEXTW 
42c8 cd 6c ee			call parse_vector 
42cb c3 b9 1e			jp macro_next 
42ce				endm 
# End of macro NEXTW
42ce			 
42ce			;.blstr: db " ", 0 
42ce			 
42ce			.SPACES: 
42ce				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
42ce 47				db WORD_SYS_CORE+51             
42cf 6a 43			dw .SCROLL            
42d1 07				db 6 + 1 
42d2 .. 00			db "SPACES",0              
42d9				endm 
# End of macro CWHEAD
42d9			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
42d9					if DEBUG_FORTH_WORDS_KEY 
42d9						DMARK "SPS" 
42d9 f5				push af  
42da 3a ee 42			ld a, (.dmark)  
42dd 32 62 ee			ld (debug_mark),a  
42e0 3a ef 42			ld a, (.dmark+1)  
42e3 32 63 ee			ld (debug_mark+1),a  
42e6 3a f0 42			ld a, (.dmark+2)  
42e9 32 64 ee			ld (debug_mark+2),a  
42ec 18 03			jr .pastdmark  
42ee ..			.dmark: db "SPS"  
42f1 f1			.pastdmark: pop af  
42f2			endm  
# End of macro DMARK
42f2						CALLMONITOR 
42f2 cd 6f ee			call debug_vector  
42f5				endm  
# End of macro CALLMONITOR
42f5					endif 
42f5			 
42f5			 
42f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42f5 cd d2 1c			call macro_dsp_valuehl 
42f8				endm 
# End of macro FORTH_DSP_VALUEHL
42f8			 
42f8 e5					push hl    ; u 
42f9					if DEBUG_FORTH_WORDS 
42f9						DMARK "SPA" 
42f9 f5				push af  
42fa 3a 0e 43			ld a, (.dmark)  
42fd 32 62 ee			ld (debug_mark),a  
4300 3a 0f 43			ld a, (.dmark+1)  
4303 32 63 ee			ld (debug_mark+1),a  
4306 3a 10 43			ld a, (.dmark+2)  
4309 32 64 ee			ld (debug_mark+2),a  
430c 18 03			jr .pastdmark  
430e ..			.dmark: db "SPA"  
4311 f1			.pastdmark: pop af  
4312			endm  
# End of macro DMARK
4312						CALLMONITOR 
4312 cd 6f ee			call debug_vector  
4315				endm  
# End of macro CALLMONITOR
4315					endif 
4315			 
4315					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4315 cd 8a 1d			call macro_forth_dsp_pop 
4318				endm 
# End of macro FORTH_DSP_POP
4318 e1					pop hl 
4319 0e 00				ld c, 0 
431b 45					ld b, l 
431c 21 b8 e2				ld hl, scratch  
431f			 
431f					if DEBUG_FORTH_WORDS 
431f						DMARK "SP2" 
431f f5				push af  
4320 3a 34 43			ld a, (.dmark)  
4323 32 62 ee			ld (debug_mark),a  
4326 3a 35 43			ld a, (.dmark+1)  
4329 32 63 ee			ld (debug_mark+1),a  
432c 3a 36 43			ld a, (.dmark+2)  
432f 32 64 ee			ld (debug_mark+2),a  
4332 18 03			jr .pastdmark  
4334 ..			.dmark: db "SP2"  
4337 f1			.pastdmark: pop af  
4338			endm  
# End of macro DMARK
4338						CALLMONITOR 
4338 cd 6f ee			call debug_vector  
433b				endm  
# End of macro CALLMONITOR
433b					endif 
433b			;		ld a, ' ' 
433b			.spaces1:	 
433b 36 20				ld (hl),' ' 
433d 23					inc hl 
433e					 
433e 10 fb				djnz .spaces1 
4340			;		ld a,0 
4340 36 00				ld (hl),0 
4342 21 b8 e2				ld hl, scratch 
4345					if DEBUG_FORTH_WORDS 
4345						DMARK "SP3" 
4345 f5				push af  
4346 3a 5a 43			ld a, (.dmark)  
4349 32 62 ee			ld (debug_mark),a  
434c 3a 5b 43			ld a, (.dmark+1)  
434f 32 63 ee			ld (debug_mark+1),a  
4352 3a 5c 43			ld a, (.dmark+2)  
4355 32 64 ee			ld (debug_mark+2),a  
4358 18 03			jr .pastdmark  
435a ..			.dmark: db "SP3"  
435d f1			.pastdmark: pop af  
435e			endm  
# End of macro DMARK
435e						CALLMONITOR 
435e cd 6f ee			call debug_vector  
4361				endm  
# End of macro CALLMONITOR
4361					endif 
4361 cd 40 1b				call forth_push_str 
4364			 
4364				       NEXTW 
4364 cd 6c ee			call parse_vector 
4367 c3 b9 1e			jp macro_next 
436a				endm 
# End of macro NEXTW
436a			 
436a			 
436a			 
436a			.SCROLL: 
436a				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
436a 53				db WORD_SYS_CORE+63             
436b 9a 43			dw .SCROLLD            
436d 07				db 6 + 1 
436e .. 00			db "SCROLL",0              
4375				endm 
# End of macro CWHEAD
4375			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4375					if DEBUG_FORTH_WORDS_KEY 
4375						DMARK "SCR" 
4375 f5				push af  
4376 3a 8a 43			ld a, (.dmark)  
4379 32 62 ee			ld (debug_mark),a  
437c 3a 8b 43			ld a, (.dmark+1)  
437f 32 63 ee			ld (debug_mark+1),a  
4382 3a 8c 43			ld a, (.dmark+2)  
4385 32 64 ee			ld (debug_mark+2),a  
4388 18 03			jr .pastdmark  
438a ..			.dmark: db "SCR"  
438d f1			.pastdmark: pop af  
438e			endm  
# End of macro DMARK
438e						CALLMONITOR 
438e cd 6f ee			call debug_vector  
4391				endm  
# End of macro CALLMONITOR
4391					endif 
4391			 
4391 cd 7a 0b			call scroll_up 
4394			;	call update_display 
4394			 
4394					NEXTW 
4394 cd 6c ee			call parse_vector 
4397 c3 b9 1e			jp macro_next 
439a				endm 
# End of macro NEXTW
439a			 
439a			 
439a			 
439a			;		; get dir 
439a			; 
439a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
439a			; 
439a			;		push hl 
439a			; 
439a			;		; destroy value TOS 
439a			; 
439a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
439a			; 
439a			;		; get count 
439a			; 
439a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
439a			; 
439a			;		push hl 
439a			; 
439a			;		; destroy value TOS 
439a			; 
439a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
439a			; 
439a			;		; one value on hl get other one back 
439a			; 
439a			;		pop bc    ; count 
439a			; 
439a			;		pop de   ; dir 
439a			; 
439a			; 
439a			;		ld b, c 
439a			; 
439a			;.scrolldir:     push bc 
439a			;		push de 
439a			; 
439a			;		ld a, 0 
439a			;		cp e 
439a			;		jr z, .scrollup  
439a			;		call scroll_down 
439a			;		jr .scrollnext 
439a			;.scrollup:	call scroll_up 
439a			; 
439a			;		 
439a			;.scrollnext: 
439a			;		pop de 
439a			;		pop bc 
439a			;		djnz .scrolldir 
439a			; 
439a			; 
439a			; 
439a			; 
439a			; 
439a			;		NEXTW 
439a			 
439a			.SCROLLD: 
439a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
439a 53				db WORD_SYS_CORE+63             
439b cb 43			dw .ATQ            
439d 08				db 7 + 1 
439e .. 00			db "SCROLLD",0              
43a6				endm 
# End of macro CWHEAD
43a6			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
43a6					if DEBUG_FORTH_WORDS_KEY 
43a6						DMARK "SCD" 
43a6 f5				push af  
43a7 3a bb 43			ld a, (.dmark)  
43aa 32 62 ee			ld (debug_mark),a  
43ad 3a bc 43			ld a, (.dmark+1)  
43b0 32 63 ee			ld (debug_mark+1),a  
43b3 3a bd 43			ld a, (.dmark+2)  
43b6 32 64 ee			ld (debug_mark+2),a  
43b9 18 03			jr .pastdmark  
43bb ..			.dmark: db "SCD"  
43be f1			.pastdmark: pop af  
43bf			endm  
# End of macro DMARK
43bf						CALLMONITOR 
43bf cd 6f ee			call debug_vector  
43c2				endm  
# End of macro CALLMONITOR
43c2					endif 
43c2			 
43c2 cd 9d 0b			call scroll_down 
43c5			;	call update_display 
43c5			 
43c5					NEXTW 
43c5 cd 6c ee			call parse_vector 
43c8 c3 b9 1e			jp macro_next 
43cb				endm 
# End of macro NEXTW
43cb			 
43cb			 
43cb			.ATQ: 
43cb				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
43cb 62				db WORD_SYS_CORE+78             
43cc 2c 44			dw .AUTODSP            
43ce 04				db 3 + 1 
43cf .. 00			db "AT@",0              
43d3				endm 
# End of macro CWHEAD
43d3			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
43d3					if DEBUG_FORTH_WORDS_KEY 
43d3						DMARK "ATA" 
43d3 f5				push af  
43d4 3a e8 43			ld a, (.dmark)  
43d7 32 62 ee			ld (debug_mark),a  
43da 3a e9 43			ld a, (.dmark+1)  
43dd 32 63 ee			ld (debug_mark+1),a  
43e0 3a ea 43			ld a, (.dmark+2)  
43e3 32 64 ee			ld (debug_mark+2),a  
43e6 18 03			jr .pastdmark  
43e8 ..			.dmark: db "ATA"  
43eb f1			.pastdmark: pop af  
43ec			endm  
# End of macro DMARK
43ec						CALLMONITOR 
43ec cd 6f ee			call debug_vector  
43ef				endm  
# End of macro CALLMONITOR
43ef					endif 
43ef			 
43ef			 
43ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43ef cd d2 1c			call macro_dsp_valuehl 
43f2				endm 
# End of macro FORTH_DSP_VALUEHL
43f2			 
43f2					; TODO save cursor row 
43f2 7d					ld a,l 
43f3 fe 02				cp 2 
43f5 20 04				jr nz, .crow3aq 
43f7 3e 28				ld a, display_row_2 
43f9 18 12				jr .ccol1aq 
43fb fe 03		.crow3aq:		cp 3 
43fd 20 04				jr nz, .crow4aq 
43ff 3e 50				ld a, display_row_3 
4401 18 0a				jr .ccol1aq 
4403 fe 04		.crow4aq:		cp 4 
4405 20 04				jr nz, .crow1aq 
4407 3e 78				ld a, display_row_4 
4409 18 02				jr .ccol1aq 
440b 3e 00		.crow1aq:		ld a,display_row_1 
440d f5			.ccol1aq:		push af			; got row offset 
440e 6f					ld l,a 
440f 26 00				ld h,0 
4411					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4411 cd 8a 1d			call macro_forth_dsp_pop 
4414				endm 
# End of macro FORTH_DSP_POP
4414					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4414 cd d2 1c			call macro_dsp_valuehl 
4417				endm 
# End of macro FORTH_DSP_VALUEHL
4417					; TODO save cursor col 
4417 f1					pop af 
4418 85					add l		; add col offset 
4419			 
4419					; add current frame buffer address 
4419 2a c3 eb				ld hl, (display_fb_active) 
441c cd e1 0d				call addatohl 
441f			 
441f			 
441f			 
441f			 
441f					; get char frame buffer location offset in hl 
441f			 
441f 7e					ld a,(hl) 
4420 26 00				ld h, 0 
4422 6f					ld l, a 
4423			 
4423 cd d6 1a				call forth_push_numhl 
4426			 
4426			 
4426					NEXTW 
4426 cd 6c ee			call parse_vector 
4429 c3 b9 1e			jp macro_next 
442c				endm 
# End of macro NEXTW
442c			 
442c			.AUTODSP: 
442c				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
442c 63				db WORD_SYS_CORE+79             
442d 45 44			dw .MENU            
442f 05				db 4 + 1 
4430 .. 00			db "ADSP",0              
4435				endm 
# End of macro CWHEAD
4435			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4435			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4435			 
4435					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4435 cd d2 1c			call macro_dsp_valuehl 
4438				endm 
# End of macro FORTH_DSP_VALUEHL
4438			 
4438			;		push hl 
4438			 
4438					; destroy value TOS 
4438			 
4438					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4438 cd 8a 1d			call macro_forth_dsp_pop 
443b				endm 
# End of macro FORTH_DSP_POP
443b			 
443b			;		pop hl 
443b			 
443b 7d					ld a,l 
443c 32 33 ea				ld (cli_autodisplay), a 
443f				       NEXTW 
443f cd 6c ee			call parse_vector 
4442 c3 b9 1e			jp macro_next 
4445				endm 
# End of macro NEXTW
4445			 
4445			.MENU: 
4445				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4445 70				db WORD_SYS_CORE+92             
4446 f1 44			dw .ENDDISPLAY            
4448 05				db 4 + 1 
4449 .. 00			db "MENU",0              
444e				endm 
# End of macro CWHEAD
444e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
444e			 
444e			;		; get number of items on the stack 
444e			; 
444e				 
444e					FORTH_DSP_VALUEHL 
444e cd d2 1c			call macro_dsp_valuehl 
4451				endm 
# End of macro FORTH_DSP_VALUEHL
4451				 
4451					if DEBUG_FORTH_WORDS_KEY 
4451						DMARK "MNU" 
4451 f5				push af  
4452 3a 66 44			ld a, (.dmark)  
4455 32 62 ee			ld (debug_mark),a  
4458 3a 67 44			ld a, (.dmark+1)  
445b 32 63 ee			ld (debug_mark+1),a  
445e 3a 68 44			ld a, (.dmark+2)  
4461 32 64 ee			ld (debug_mark+2),a  
4464 18 03			jr .pastdmark  
4466 ..			.dmark: db "MNU"  
4469 f1			.pastdmark: pop af  
446a			endm  
# End of macro DMARK
446a						CALLMONITOR 
446a cd 6f ee			call debug_vector  
446d				endm  
# End of macro CALLMONITOR
446d					endif 
446d			 
446d 45					ld b, l	 
446e 05					dec b 
446f			 
446f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
446f cd 8a 1d			call macro_forth_dsp_pop 
4472				endm 
# End of macro FORTH_DSP_POP
4472			 
4472			 
4472					; go directly through the stack to pluck out the string pointers and build an array 
4472			 
4472			;		FORTH_DSP 
4472			 
4472					; hl contains top most stack item 
4472				 
4472 11 b8 e2				ld de, scratch 
4475			 
4475			.mbuild: 
4475			 
4475					FORTH_DSP_VALUEHL 
4475 cd d2 1c			call macro_dsp_valuehl 
4478				endm 
# End of macro FORTH_DSP_VALUEHL
4478			 
4478					if DEBUG_FORTH_WORDS 
4478						DMARK "MN3" 
4478 f5				push af  
4479 3a 8d 44			ld a, (.dmark)  
447c 32 62 ee			ld (debug_mark),a  
447f 3a 8e 44			ld a, (.dmark+1)  
4482 32 63 ee			ld (debug_mark+1),a  
4485 3a 8f 44			ld a, (.dmark+2)  
4488 32 64 ee			ld (debug_mark+2),a  
448b 18 03			jr .pastdmark  
448d ..			.dmark: db "MN3"  
4490 f1			.pastdmark: pop af  
4491			endm  
# End of macro DMARK
4491						CALLMONITOR 
4491 cd 6f ee			call debug_vector  
4494				endm  
# End of macro CALLMONITOR
4494					endif 
4494 eb					ex de, hl 
4495 73					ld (hl), e 
4496 23					inc hl 
4497 72					ld (hl), d 
4498 23					inc hl 
4499 eb					ex de, hl 
449a			 
449a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
449a cd 8a 1d			call macro_forth_dsp_pop 
449d				endm 
# End of macro FORTH_DSP_POP
449d			 
449d 10 d6				djnz .mbuild 
449f			 
449f					; done add term 
449f			 
449f eb					ex de, hl 
44a0 36 00				ld (hl), 0 
44a2 23					inc hl 
44a3 36 00				ld (hl), 0 
44a5			 
44a5				 
44a5					 
44a5 21 b8 e2				ld hl, scratch 
44a8			 
44a8					if DEBUG_FORTH_WORDS 
44a8						DMARK "MNx" 
44a8 f5				push af  
44a9 3a bd 44			ld a, (.dmark)  
44ac 32 62 ee			ld (debug_mark),a  
44af 3a be 44			ld a, (.dmark+1)  
44b2 32 63 ee			ld (debug_mark+1),a  
44b5 3a bf 44			ld a, (.dmark+2)  
44b8 32 64 ee			ld (debug_mark+2),a  
44bb 18 03			jr .pastdmark  
44bd ..			.dmark: db "MNx"  
44c0 f1			.pastdmark: pop af  
44c1			endm  
# End of macro DMARK
44c1						CALLMONITOR 
44c1 cd 6f ee			call debug_vector  
44c4				endm  
# End of macro CALLMONITOR
44c4					endif 
44c4			 
44c4			 
44c4			 
44c4 3e 00				ld a, 0 
44c6 cd e7 0b				call menu 
44c9			 
44c9			 
44c9 6f					ld l, a 
44ca 26 00				ld h, 0 
44cc			 
44cc					if DEBUG_FORTH_WORDS 
44cc						DMARK "MNr" 
44cc f5				push af  
44cd 3a e1 44			ld a, (.dmark)  
44d0 32 62 ee			ld (debug_mark),a  
44d3 3a e2 44			ld a, (.dmark+1)  
44d6 32 63 ee			ld (debug_mark+1),a  
44d9 3a e3 44			ld a, (.dmark+2)  
44dc 32 64 ee			ld (debug_mark+2),a  
44df 18 03			jr .pastdmark  
44e1 ..			.dmark: db "MNr"  
44e4 f1			.pastdmark: pop af  
44e5			endm  
# End of macro DMARK
44e5						CALLMONITOR 
44e5 cd 6f ee			call debug_vector  
44e8				endm  
# End of macro CALLMONITOR
44e8					endif 
44e8			 
44e8 cd d6 1a				call forth_push_numhl 
44eb			 
44eb			 
44eb			 
44eb			 
44eb				       NEXTW 
44eb cd 6c ee			call parse_vector 
44ee c3 b9 1e			jp macro_next 
44f1				endm 
# End of macro NEXTW
44f1			 
44f1			 
44f1			.ENDDISPLAY: 
44f1			 
44f1			; eof 
# End of file forth_words_display.asm
44f1			include "forth_words_str.asm" 
44f1			 
44f1			; | ## String Words 
44f1			 
44f1			.CONST: 
44f1				 
44f1				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
44f1 48				db WORD_SYS_CORE+52             
44f2 06 45			dw .MOVE            
44f4 06				db 5 + 1 
44f5 .. 00			db "CONST",0              
44fb				endm 
# End of macro CWHEAD
44fb			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
44fb					FORTH_DSP 
44fb cd 98 1c			call macro_forth_dsp 
44fe				endm 
# End of macro FORTH_DSP
44fe 36 04				ld (hl), DS_TYPE_CONST 
4500					NEXTW 
4500 cd 6c ee			call parse_vector 
4503 c3 b9 1e			jp macro_next 
4506				endm 
# End of macro NEXTW
4506			 
4506			.MOVE:   
4506			 
4506				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
4506 48				db WORD_SYS_CORE+52             
4507 2d 45			dw .ZMOVE            
4509 05				db 4 + 1 
450a .. 00			db "MOVE",0              
450f				endm 
# End of macro CWHEAD
450f			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
450f			 
450f					FORTH_DSP_VALUEHL 
450f cd d2 1c			call macro_dsp_valuehl 
4512				endm 
# End of macro FORTH_DSP_VALUEHL
4512 e5					push hl    ; push count 
4513			 
4513					FORTH_DSP_POP 
4513 cd 8a 1d			call macro_forth_dsp_pop 
4516				endm 
# End of macro FORTH_DSP_POP
4516			 
4516					FORTH_DSP_VALUEHL 
4516 cd d2 1c			call macro_dsp_valuehl 
4519				endm 
# End of macro FORTH_DSP_VALUEHL
4519 e5					push hl    ; dest 
451a			 
451a					FORTH_DSP_POP 
451a cd 8a 1d			call macro_forth_dsp_pop 
451d				endm 
# End of macro FORTH_DSP_POP
451d			 
451d					FORTH_DSP_VALUEHL 
451d cd d2 1c			call macro_dsp_valuehl 
4520				endm 
# End of macro FORTH_DSP_VALUEHL
4520			 
4520					FORTH_DSP_POP 
4520 cd 8a 1d			call macro_forth_dsp_pop 
4523				endm 
# End of macro FORTH_DSP_POP
4523			 
4523 d1					pop de 
4524 c1					pop bc 
4525				 
4525 ed b0				ldir 
4527				NEXTW 
4527 cd 6c ee			call parse_vector 
452a c3 b9 1e			jp macro_next 
452d				endm 
# End of macro NEXTW
452d			.ZMOVE:   
452d			 
452d				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
452d 48				db WORD_SYS_CORE+52             
452e 56 45			dw .TABLE            
4530 06				db 5 + 1 
4531 .. 00			db "ZMOVE",0              
4537				endm 
# End of macro CWHEAD
4537					 
4537			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
4537			; | | Ensure you have enough space! 
4537			 
4537			 
4537					FORTH_DSP_VALUEHL 
4537 cd d2 1c			call macro_dsp_valuehl 
453a				endm 
# End of macro FORTH_DSP_VALUEHL
453a e5					push hl    ; dest 
453b			 
453b					FORTH_DSP_POP 
453b cd 8a 1d			call macro_forth_dsp_pop 
453e				endm 
# End of macro FORTH_DSP_POP
453e			 
453e					FORTH_DSP_VALUEHL 
453e cd d2 1c			call macro_dsp_valuehl 
4541				endm 
# End of macro FORTH_DSP_VALUEHL
4541			 
4541					FORTH_DSP_POP 
4541 cd 8a 1d			call macro_forth_dsp_pop 
4544				endm 
# End of macro FORTH_DSP_POP
4544			 
4544 d1					pop de 
4545			 
4545 01 ff 00				ld bc, 255 
4548 ed a0		.zmovel:	ldi 
454a 2b					dec hl 
454b 7e					ld a,(hl) 
454c 23					inc hl 
454d b7					or a  
454e 20 f8				jr nz, .zmovel    
4550					 
4550			 
4550				NEXTW 
4550 cd 6c ee			call parse_vector 
4553 c3 b9 1e			jp macro_next 
4556				endm 
# End of macro NEXTW
4556			 
4556			.TABLE:   
4556			 
4556				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
4556 48				db WORD_SYS_CORE+52             
4557 bb 45			dw .SPLIT            
4559 06				db 5 + 1 
455a .. 00			db "TABLE",0              
4560				endm 
# End of macro CWHEAD
4560					 
4560			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
4560			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
4560			; | | in any kind of lookup or iteration.  
4560			; | | Last item in the array will be a zero pointer for ease of iteration 
4560			 
4560			 
4560				; get the count of strings 
4560			 
4560					FORTH_DSP_VALUEHL 
4560 cd d2 1c			call macro_dsp_valuehl 
4563				endm 
# End of macro FORTH_DSP_VALUEHL
4563			 
4563					FORTH_DSP_POP 
4563 cd 8a 1d			call macro_forth_dsp_pop 
4566				endm 
# End of macro FORTH_DSP_POP
4566			 
4566				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
4566			 
4566					; l contains count 
4566			 
4566 7d					ld a,l 
4567 32 b8 e2				ld (scratch), a     ; save it for the loading loop 
456a			 
456a 2c					inc l  ; for zero pointer 
456b eb					ex de, hl 
456c 3e 02				ld a, 2 
456e cd 64 0d				call Mult16 
4571			 
4571					; hl is the size of block to allocate 
4571			 
4571 cd ad 11				call malloc 
4574				if DEBUG_FORTH_MALLOC_GUARD 
4574 cc 27 54				call z,malloc_error 
4577				endif 
4577					; hl is the pointer to the array block 
4577						 
4577 22 b9 e2				ld (scratch+1), hl    ; save the base for later push to stack 
457a 22 bb e2				ld (scratch+3), hl    ; save the base for current string to push 
457d			 
457d 3a b8 e2				ld a, (scratch) 
4580 47					ld b, a 
4581			 
4581				; for each string 
4581			 
4581			.tablelop: 
4581			 
4581 c5					push bc 
4582			 
4582				;     get string pointer 
4582			 
4582					FORTH_DSP_VALUEHL 
4582 cd d2 1c			call macro_dsp_valuehl 
4585				endm 
# End of macro FORTH_DSP_VALUEHL
4585			 
4585 e5					push hl 
4586			 
4586				;     get string length 
4586			 
4586 3e 00				ld a,0 
4588 cd 44 11				call strlent 
458b			 
458b 23					inc hl 
458c e5					push hl 
458d			 
458d				;     allocate string length 
458d			 
458d cd ad 11				call malloc 
4590			 
4590			        ;     copy string to block 
4590			 
4590 c1					pop bc 
4591 eb					ex de, hl 
4592 e1					pop hl 
4593 d5					push de 
4594			 
4594 ed b0				ldir 
4596			 
4596			 
4596			        ;     add pointer to string to array block 
4596			 
4596 2a bb e2				ld hl, (scratch+3)    ; save the base for current string to push 
4599			 
4599 d1					pop de     ; the pointer to the newly copied string to add to the array 
459a 73					ld (hl), e 
459b 23					inc hl 
459c 72					ld (hl), d	 
459d 23					inc hl 
459e				 
459e 22 bb e2				ld (scratch+3), hl    ; save the base for current string to push 
45a1			 
45a1					FORTH_DSP_POP 
45a1 cd 8a 1d			call macro_forth_dsp_pop 
45a4				endm 
# End of macro FORTH_DSP_POP
45a4			 
45a4 c1					pop bc 
45a5 10 da				djnz .tablelop 
45a7			 
45a7			        ;  push array block pointer 
45a7			 
45a7 2a bb e2				ld hl, (scratch+3)    ; save the base for current string to push 
45aa 36 00				ld (hl), 0 
45ac 23					inc hl 
45ad 36 00				ld (hl), 0 
45af			 
45af			 
45af				 
45af 2a b9 e2				ld hl, (scratch+1)    ; save the base for current string to push 
45b2 cd d6 1a				call forth_push_numhl 
45b5			 
45b5				NEXTW 
45b5 cd 6c ee			call parse_vector 
45b8 c3 b9 1e			jp macro_next 
45bb				endm 
# End of macro NEXTW
45bb			 
45bb			.SPLIT:   
45bb			 
45bb				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
45bb 48				db WORD_SYS_CORE+52             
45bc b2 46			dw .PTR            
45be 06				db 5 + 1 
45bf .. 00			db "SPLIT",0              
45c5				endm 
# End of macro CWHEAD
45c5			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
45c5					if DEBUG_FORTH_WORDS_KEY 
45c5						DMARK "SPT" 
45c5 f5				push af  
45c6 3a da 45			ld a, (.dmark)  
45c9 32 62 ee			ld (debug_mark),a  
45cc 3a db 45			ld a, (.dmark+1)  
45cf 32 63 ee			ld (debug_mark+1),a  
45d2 3a dc 45			ld a, (.dmark+2)  
45d5 32 64 ee			ld (debug_mark+2),a  
45d8 18 03			jr .pastdmark  
45da ..			.dmark: db "SPT"  
45dd f1			.pastdmark: pop af  
45de			endm  
# End of macro DMARK
45de						CALLMONITOR 
45de cd 6f ee			call debug_vector  
45e1				endm  
# End of macro CALLMONITOR
45e1					endif 
45e1			 
45e1					; get delim 
45e1					FORTH_DSP_VALUEHL 
45e1 cd d2 1c			call macro_dsp_valuehl 
45e4				endm 
# End of macro FORTH_DSP_VALUEHL
45e4			 
45e4					FORTH_DSP_POP 
45e4 cd 8a 1d			call macro_forth_dsp_pop 
45e7				endm 
# End of macro FORTH_DSP_POP
45e7					 
45e7			 
45e7 45					ld b, l    ; move delim to b 
45e8 0e 01				ld c, 1   ; count of poritions 
45ea			 
45ea c5					push bc 
45eb			 
45eb					if DEBUG_FORTH_WORDS 
45eb						DMARK "SPa" 
45eb f5				push af  
45ec 3a 00 46			ld a, (.dmark)  
45ef 32 62 ee			ld (debug_mark),a  
45f2 3a 01 46			ld a, (.dmark+1)  
45f5 32 63 ee			ld (debug_mark+1),a  
45f8 3a 02 46			ld a, (.dmark+2)  
45fb 32 64 ee			ld (debug_mark+2),a  
45fe 18 03			jr .pastdmark  
4600 ..			.dmark: db "SPa"  
4603 f1			.pastdmark: pop af  
4604			endm  
# End of macro DMARK
4604						CALLMONITOR 
4604 cd 6f ee			call debug_vector  
4607				endm  
# End of macro CALLMONITOR
4607					endif 
4607					; get pointer to string to chop up 
4607					FORTH_DSP_VALUEHL 
4607 cd d2 1c			call macro_dsp_valuehl 
460a				endm 
# End of macro FORTH_DSP_VALUEHL
460a			 
460a			;		push hl 
460a 11 b8 e2				ld de, scratch 
460d			.spllop: 
460d c1					pop bc 
460e c5					push bc 
460f			;		pop hl 
460f					if DEBUG_FORTH_WORDS 
460f						DMARK "SPl" 
460f f5				push af  
4610 3a 24 46			ld a, (.dmark)  
4613 32 62 ee			ld (debug_mark),a  
4616 3a 25 46			ld a, (.dmark+1)  
4619 32 63 ee			ld (debug_mark+1),a  
461c 3a 26 46			ld a, (.dmark+2)  
461f 32 64 ee			ld (debug_mark+2),a  
4622 18 03			jr .pastdmark  
4624 ..			.dmark: db "SPl"  
4627 f1			.pastdmark: pop af  
4628			endm  
# End of macro DMARK
4628						CALLMONITOR 
4628 cd 6f ee			call debug_vector  
462b				endm  
# End of macro CALLMONITOR
462b					endif 
462b 7e					ld a, (hl) 
462c b8					cp b 
462d 28 07				jr z, .splnxt 
462f			;		cp 0 
462f b7					or a 
4630 28 34				jr z, .splend 
4632 ed a0				ldi 
4634 18 d7				jr .spllop 
4636			 
4636					; hit dlim 
4636			 
4636			.splnxt: 
4636					if DEBUG_FORTH_WORDS 
4636						DMARK "SPx" 
4636 f5				push af  
4637 3a 4b 46			ld a, (.dmark)  
463a 32 62 ee			ld (debug_mark),a  
463d 3a 4c 46			ld a, (.dmark+1)  
4640 32 63 ee			ld (debug_mark+1),a  
4643 3a 4d 46			ld a, (.dmark+2)  
4646 32 64 ee			ld (debug_mark+2),a  
4649 18 03			jr .pastdmark  
464b ..			.dmark: db "SPx"  
464e f1			.pastdmark: pop af  
464f			endm  
# End of macro DMARK
464f						CALLMONITOR 
464f cd 6f ee			call debug_vector  
4652				endm  
# End of macro CALLMONITOR
4652					endif 
4652 3e 00				ld a, 0 
4654 12					ld (de), a 
4655					;ex de, hl 
4655 e5					push hl 
4656 21 b8 e2				ld hl, scratch 
4659 cd 40 1b				call forth_push_str 
465c e1					pop hl 
465d					;ex de, hl 
465d 23					inc hl 
465e c1					pop bc 
465f 0c					inc c 
4660 c5					push bc 
4661 11 b8 e2				ld de, scratch 
4664 18 a7				jr .spllop 
4666			 
4666			.splend:		 
4666					if DEBUG_FORTH_WORDS 
4666						DMARK "SPe" 
4666 f5				push af  
4667 3a 7b 46			ld a, (.dmark)  
466a 32 62 ee			ld (debug_mark),a  
466d 3a 7c 46			ld a, (.dmark+1)  
4670 32 63 ee			ld (debug_mark+1),a  
4673 3a 7d 46			ld a, (.dmark+2)  
4676 32 64 ee			ld (debug_mark+2),a  
4679 18 03			jr .pastdmark  
467b ..			.dmark: db "SPe"  
467e f1			.pastdmark: pop af  
467f			endm  
# End of macro DMARK
467f						CALLMONITOR 
467f cd 6f ee			call debug_vector  
4682				endm  
# End of macro CALLMONITOR
4682					endif 
4682 12					ld (de), a 
4683 eb					ex de, hl 
4684			;		push hl 
4684 21 b8 e2				ld hl, scratch 
4687 cd 40 1b				call forth_push_str 
468a					 
468a					if DEBUG_FORTH_WORDS 
468a						DMARK "SPc" 
468a f5				push af  
468b 3a 9f 46			ld a, (.dmark)  
468e 32 62 ee			ld (debug_mark),a  
4691 3a a0 46			ld a, (.dmark+1)  
4694 32 63 ee			ld (debug_mark+1),a  
4697 3a a1 46			ld a, (.dmark+2)  
469a 32 64 ee			ld (debug_mark+2),a  
469d 18 03			jr .pastdmark  
469f ..			.dmark: db "SPc"  
46a2 f1			.pastdmark: pop af  
46a3			endm  
# End of macro DMARK
46a3						CALLMONITOR 
46a3 cd 6f ee			call debug_vector  
46a6				endm  
# End of macro CALLMONITOR
46a6					endif 
46a6			 
46a6 e1					pop hl    ; get counter from bc which has been push 
46a7 26 00				ld h, 0 
46a9			;		ld l, c 
46a9 cd d6 1a				call forth_push_numhl 
46ac			 
46ac			 
46ac				NEXTW 
46ac cd 6c ee			call parse_vector 
46af c3 b9 1e			jp macro_next 
46b2				endm 
# End of macro NEXTW
46b2			.PTR:   
46b2			 
46b2				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
46b2 48				db WORD_SYS_CORE+52             
46b3 e2 46			dw .STYPE            
46b5 04				db 3 + 1 
46b6 .. 00			db "PTR",0              
46ba				endm 
# End of macro CWHEAD
46ba			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
46ba			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
46ba			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
46ba			 
46ba					if DEBUG_FORTH_WORDS_KEY 
46ba						DMARK "PTR" 
46ba f5				push af  
46bb 3a cf 46			ld a, (.dmark)  
46be 32 62 ee			ld (debug_mark),a  
46c1 3a d0 46			ld a, (.dmark+1)  
46c4 32 63 ee			ld (debug_mark+1),a  
46c7 3a d1 46			ld a, (.dmark+2)  
46ca 32 64 ee			ld (debug_mark+2),a  
46cd 18 03			jr .pastdmark  
46cf ..			.dmark: db "PTR"  
46d2 f1			.pastdmark: pop af  
46d3			endm  
# End of macro DMARK
46d3						CALLMONITOR 
46d3 cd 6f ee			call debug_vector  
46d6				endm  
# End of macro CALLMONITOR
46d6					endif 
46d6					FORTH_DSP_VALUEHL 
46d6 cd d2 1c			call macro_dsp_valuehl 
46d9				endm 
# End of macro FORTH_DSP_VALUEHL
46d9 cd d6 1a				call forth_push_numhl 
46dc			 
46dc			 
46dc					NEXTW 
46dc cd 6c ee			call parse_vector 
46df c3 b9 1e			jp macro_next 
46e2				endm 
# End of macro NEXTW
46e2			.STYPE: 
46e2				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
46e2 48				db WORD_SYS_CORE+52             
46e3 3f 47			dw .UPPER            
46e5 06				db 5 + 1 
46e6 .. 00			db "STYPE",0              
46ec				endm 
# End of macro CWHEAD
46ec			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
46ec			; | | 's' string or 'i' integer or 'c' const 
46ec					if DEBUG_FORTH_WORDS_KEY 
46ec						DMARK "STY" 
46ec f5				push af  
46ed 3a 01 47			ld a, (.dmark)  
46f0 32 62 ee			ld (debug_mark),a  
46f3 3a 02 47			ld a, (.dmark+1)  
46f6 32 63 ee			ld (debug_mark+1),a  
46f9 3a 03 47			ld a, (.dmark+2)  
46fc 32 64 ee			ld (debug_mark+2),a  
46ff 18 03			jr .pastdmark  
4701 ..			.dmark: db "STY"  
4704 f1			.pastdmark: pop af  
4705			endm  
# End of macro DMARK
4705						CALLMONITOR 
4705 cd 6f ee			call debug_vector  
4708				endm  
# End of macro CALLMONITOR
4708					endif 
4708					FORTH_DSP 
4708 cd 98 1c			call macro_forth_dsp 
470b				endm 
# End of macro FORTH_DSP
470b					;v5 FORTH_DSP_VALUE 
470b			 
470b 7e					ld a, (hl) 
470c			 
470c f5					push af 
470d			 
470d			; Dont destroy TOS		FORTH_DSP_POP 
470d			 
470d f1					pop af 
470e			 
470e fe 01				cp DS_TYPE_STR 
4710 28 12				jr z, .typestr 
4712 fe 04				cp DS_TYPE_CONST 
4714 28 09				jr z, .typeconst 
4716			 
4716 fe 02				cp DS_TYPE_INUM 
4718 28 0f				jr z, .typeinum 
471a			 
471a 21 3d 47				ld hl, .tna 
471d 18 0f				jr .tpush 
471f			 
471f 21 39 47		.typeconst:	ld hl, .tconst 
4722 18 0a				jr .tpush 
4724 21 37 47		.typestr:	ld hl, .tstr 
4727 18 05				jr .tpush 
4729 21 3b 47		.typeinum:	ld hl, .tinum 
472c 18 00				jr .tpush 
472e			 
472e			.tpush: 
472e			 
472e cd 40 1b				call forth_push_str 
4731			 
4731					NEXTW 
4731 cd 6c ee			call parse_vector 
4734 c3 b9 1e			jp macro_next 
4737				endm 
# End of macro NEXTW
4737 .. 00		.tstr:	db "s",0 
4739 .. 00		.tconst:	db "c",0 
473b .. 00		.tinum:  db "i",0 
473d .. 00		.tna:   db "?", 0 
473f			 
473f			 
473f			.UPPER: 
473f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
473f 48				db WORD_SYS_CORE+52             
4740 7c 47			dw .LOWER            
4742 06				db 5 + 1 
4743 .. 00			db "UPPER",0              
4749				endm 
# End of macro CWHEAD
4749			; | UPPER ( s -- s ) Upper case string s  | DONE 
4749					if DEBUG_FORTH_WORDS_KEY 
4749						DMARK "UPR" 
4749 f5				push af  
474a 3a 5e 47			ld a, (.dmark)  
474d 32 62 ee			ld (debug_mark),a  
4750 3a 5f 47			ld a, (.dmark+1)  
4753 32 63 ee			ld (debug_mark+1),a  
4756 3a 60 47			ld a, (.dmark+2)  
4759 32 64 ee			ld (debug_mark+2),a  
475c 18 03			jr .pastdmark  
475e ..			.dmark: db "UPR"  
4761 f1			.pastdmark: pop af  
4762			endm  
# End of macro DMARK
4762						CALLMONITOR 
4762 cd 6f ee			call debug_vector  
4765				endm  
# End of macro CALLMONITOR
4765					endif 
4765			 
4765					FORTH_DSP 
4765 cd 98 1c			call macro_forth_dsp 
4768				endm 
# End of macro FORTH_DSP
4768					 
4768			; TODO check is string type 
4768			 
4768					FORTH_DSP_VALUEHL 
4768 cd d2 1c			call macro_dsp_valuehl 
476b				endm 
# End of macro FORTH_DSP_VALUEHL
476b			; get pointer to string in hl 
476b			 
476b 7e			.toup:		ld a, (hl) 
476c			;		cp 0 
476c b7					or a 
476d 28 07				jr z, .toupdone 
476f			 
476f cd 49 10				call to_upper 
4772			 
4772 77					ld (hl), a 
4773 23					inc hl 
4774 18 f5				jr .toup 
4776			 
4776					 
4776			 
4776			 
4776			; for each char convert to upper 
4776					 
4776			.toupdone: 
4776			 
4776			 
4776					NEXTW 
4776 cd 6c ee			call parse_vector 
4779 c3 b9 1e			jp macro_next 
477c				endm 
# End of macro NEXTW
477c			.LOWER: 
477c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
477c 48				db WORD_SYS_CORE+52             
477d b9 47			dw .TCASE            
477f 06				db 5 + 1 
4780 .. 00			db "LOWER",0              
4786				endm 
# End of macro CWHEAD
4786			; | LOWER ( s -- s ) Lower case string s  | DONE 
4786					if DEBUG_FORTH_WORDS_KEY 
4786						DMARK "LWR" 
4786 f5				push af  
4787 3a 9b 47			ld a, (.dmark)  
478a 32 62 ee			ld (debug_mark),a  
478d 3a 9c 47			ld a, (.dmark+1)  
4790 32 63 ee			ld (debug_mark+1),a  
4793 3a 9d 47			ld a, (.dmark+2)  
4796 32 64 ee			ld (debug_mark+2),a  
4799 18 03			jr .pastdmark  
479b ..			.dmark: db "LWR"  
479e f1			.pastdmark: pop af  
479f			endm  
# End of macro DMARK
479f						CALLMONITOR 
479f cd 6f ee			call debug_vector  
47a2				endm  
# End of macro CALLMONITOR
47a2					endif 
47a2			 
47a2					FORTH_DSP 
47a2 cd 98 1c			call macro_forth_dsp 
47a5				endm 
# End of macro FORTH_DSP
47a5					 
47a5			; TODO check is string type 
47a5			 
47a5					FORTH_DSP_VALUEHL 
47a5 cd d2 1c			call macro_dsp_valuehl 
47a8				endm 
# End of macro FORTH_DSP_VALUEHL
47a8			; get pointer to string in hl 
47a8			 
47a8 7e			.tolow:		ld a, (hl) 
47a9			;		cp 0 
47a9 b7					or a 
47aa 28 07				jr z, .tolowdone 
47ac			 
47ac cd 52 10				call to_lower 
47af			 
47af 77					ld (hl), a 
47b0 23					inc hl 
47b1 18 f5				jr .tolow 
47b3			 
47b3					 
47b3			 
47b3			 
47b3			; for each char convert to low 
47b3					 
47b3			.tolowdone: 
47b3					NEXTW 
47b3 cd 6c ee			call parse_vector 
47b6 c3 b9 1e			jp macro_next 
47b9				endm 
# End of macro NEXTW
47b9			.TCASE: 
47b9				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
47b9 48				db WORD_SYS_CORE+52             
47ba f0 48			dw .SUBSTR            
47bc 06				db 5 + 1 
47bd .. 00			db "TCASE",0              
47c3				endm 
# End of macro CWHEAD
47c3			; | TCASE ( s -- s ) Title case string s  | DONE 
47c3					if DEBUG_FORTH_WORDS_KEY 
47c3						DMARK "TCS" 
47c3 f5				push af  
47c4 3a d8 47			ld a, (.dmark)  
47c7 32 62 ee			ld (debug_mark),a  
47ca 3a d9 47			ld a, (.dmark+1)  
47cd 32 63 ee			ld (debug_mark+1),a  
47d0 3a da 47			ld a, (.dmark+2)  
47d3 32 64 ee			ld (debug_mark+2),a  
47d6 18 03			jr .pastdmark  
47d8 ..			.dmark: db "TCS"  
47db f1			.pastdmark: pop af  
47dc			endm  
# End of macro DMARK
47dc						CALLMONITOR 
47dc cd 6f ee			call debug_vector  
47df				endm  
# End of macro CALLMONITOR
47df					endif 
47df			 
47df					FORTH_DSP 
47df cd 98 1c			call macro_forth_dsp 
47e2				endm 
# End of macro FORTH_DSP
47e2					 
47e2			; TODO check is string type 
47e2			 
47e2					FORTH_DSP_VALUEHL 
47e2 cd d2 1c			call macro_dsp_valuehl 
47e5				endm 
# End of macro FORTH_DSP_VALUEHL
47e5			; get pointer to string in hl 
47e5			 
47e5					if DEBUG_FORTH_WORDS 
47e5						DMARK "TC1" 
47e5 f5				push af  
47e6 3a fa 47			ld a, (.dmark)  
47e9 32 62 ee			ld (debug_mark),a  
47ec 3a fb 47			ld a, (.dmark+1)  
47ef 32 63 ee			ld (debug_mark+1),a  
47f2 3a fc 47			ld a, (.dmark+2)  
47f5 32 64 ee			ld (debug_mark+2),a  
47f8 18 03			jr .pastdmark  
47fa ..			.dmark: db "TC1"  
47fd f1			.pastdmark: pop af  
47fe			endm  
# End of macro DMARK
47fe						CALLMONITOR 
47fe cd 6f ee			call debug_vector  
4801				endm  
# End of macro CALLMONITOR
4801					endif 
4801			 
4801					; first time in turn to upper case first char 
4801			 
4801 7e					ld a, (hl) 
4802 c3 8b 48				jp .totsiptou 
4805			 
4805			 
4805 7e			.tot:		ld a, (hl) 
4806			;		cp 0 
4806 b7					or a 
4807 ca ce 48				jp z, .totdone 
480a			 
480a					if DEBUG_FORTH_WORDS 
480a						DMARK "TC2" 
480a f5				push af  
480b 3a 1f 48			ld a, (.dmark)  
480e 32 62 ee			ld (debug_mark),a  
4811 3a 20 48			ld a, (.dmark+1)  
4814 32 63 ee			ld (debug_mark+1),a  
4817 3a 21 48			ld a, (.dmark+2)  
481a 32 64 ee			ld (debug_mark+2),a  
481d 18 03			jr .pastdmark  
481f ..			.dmark: db "TC2"  
4822 f1			.pastdmark: pop af  
4823			endm  
# End of macro DMARK
4823						CALLMONITOR 
4823 cd 6f ee			call debug_vector  
4826				endm  
# End of macro CALLMONITOR
4826					endif 
4826					; check to see if current char is a space 
4826			 
4826 fe 20				cp ' ' 
4828 28 21				jr z, .totsp 
482a cd 52 10				call to_lower 
482d					if DEBUG_FORTH_WORDS 
482d						DMARK "TC3" 
482d f5				push af  
482e 3a 42 48			ld a, (.dmark)  
4831 32 62 ee			ld (debug_mark),a  
4834 3a 43 48			ld a, (.dmark+1)  
4837 32 63 ee			ld (debug_mark+1),a  
483a 3a 44 48			ld a, (.dmark+2)  
483d 32 64 ee			ld (debug_mark+2),a  
4840 18 03			jr .pastdmark  
4842 ..			.dmark: db "TC3"  
4845 f1			.pastdmark: pop af  
4846			endm  
# End of macro DMARK
4846						CALLMONITOR 
4846 cd 6f ee			call debug_vector  
4849				endm  
# End of macro CALLMONITOR
4849					endif 
4849 18 62				jr .totnxt 
484b			 
484b			.totsp:         ; on a space, find next char which should be upper 
484b			 
484b					if DEBUG_FORTH_WORDS 
484b						DMARK "TC4" 
484b f5				push af  
484c 3a 60 48			ld a, (.dmark)  
484f 32 62 ee			ld (debug_mark),a  
4852 3a 61 48			ld a, (.dmark+1)  
4855 32 63 ee			ld (debug_mark+1),a  
4858 3a 62 48			ld a, (.dmark+2)  
485b 32 64 ee			ld (debug_mark+2),a  
485e 18 03			jr .pastdmark  
4860 ..			.dmark: db "TC4"  
4863 f1			.pastdmark: pop af  
4864			endm  
# End of macro DMARK
4864						CALLMONITOR 
4864 cd 6f ee			call debug_vector  
4867				endm  
# End of macro CALLMONITOR
4867					endif 
4867					;; 
4867			 
4867 fe 20				cp ' ' 
4869 20 20				jr nz, .totsiptou 
486b 23					inc hl 
486c 7e					ld a, (hl) 
486d					if DEBUG_FORTH_WORDS 
486d						DMARK "TC5" 
486d f5				push af  
486e 3a 82 48			ld a, (.dmark)  
4871 32 62 ee			ld (debug_mark),a  
4874 3a 83 48			ld a, (.dmark+1)  
4877 32 63 ee			ld (debug_mark+1),a  
487a 3a 84 48			ld a, (.dmark+2)  
487d 32 64 ee			ld (debug_mark+2),a  
4880 18 03			jr .pastdmark  
4882 ..			.dmark: db "TC5"  
4885 f1			.pastdmark: pop af  
4886			endm  
# End of macro DMARK
4886						CALLMONITOR 
4886 cd 6f ee			call debug_vector  
4889				endm  
# End of macro CALLMONITOR
4889					endif 
4889 18 c0				jr .totsp 
488b			.totsiptou:     
488b					;cp 0 
488b b7					or a 
488c 28 40				jr z, .totdone 
488e					; not space and not zero term so upper case it 
488e cd 49 10				call to_upper 
4891			 
4891					if DEBUG_FORTH_WORDS 
4891						DMARK "TC6" 
4891 f5				push af  
4892 3a a6 48			ld a, (.dmark)  
4895 32 62 ee			ld (debug_mark),a  
4898 3a a7 48			ld a, (.dmark+1)  
489b 32 63 ee			ld (debug_mark+1),a  
489e 3a a8 48			ld a, (.dmark+2)  
48a1 32 64 ee			ld (debug_mark+2),a  
48a4 18 03			jr .pastdmark  
48a6 ..			.dmark: db "TC6"  
48a9 f1			.pastdmark: pop af  
48aa			endm  
# End of macro DMARK
48aa						CALLMONITOR 
48aa cd 6f ee			call debug_vector  
48ad				endm  
# End of macro CALLMONITOR
48ad					endif 
48ad			 
48ad			 
48ad			.totnxt: 
48ad			 
48ad 77					ld (hl), a 
48ae 23					inc hl 
48af					if DEBUG_FORTH_WORDS 
48af						DMARK "TC7" 
48af f5				push af  
48b0 3a c4 48			ld a, (.dmark)  
48b3 32 62 ee			ld (debug_mark),a  
48b6 3a c5 48			ld a, (.dmark+1)  
48b9 32 63 ee			ld (debug_mark+1),a  
48bc 3a c6 48			ld a, (.dmark+2)  
48bf 32 64 ee			ld (debug_mark+2),a  
48c2 18 03			jr .pastdmark  
48c4 ..			.dmark: db "TC7"  
48c7 f1			.pastdmark: pop af  
48c8			endm  
# End of macro DMARK
48c8						CALLMONITOR 
48c8 cd 6f ee			call debug_vector  
48cb				endm  
# End of macro CALLMONITOR
48cb					endif 
48cb c3 05 48				jp .tot 
48ce			 
48ce					 
48ce			 
48ce			 
48ce			; for each char convert to low 
48ce					 
48ce			.totdone: 
48ce					if DEBUG_FORTH_WORDS 
48ce						DMARK "TCd" 
48ce f5				push af  
48cf 3a e3 48			ld a, (.dmark)  
48d2 32 62 ee			ld (debug_mark),a  
48d5 3a e4 48			ld a, (.dmark+1)  
48d8 32 63 ee			ld (debug_mark+1),a  
48db 3a e5 48			ld a, (.dmark+2)  
48de 32 64 ee			ld (debug_mark+2),a  
48e1 18 03			jr .pastdmark  
48e3 ..			.dmark: db "TCd"  
48e6 f1			.pastdmark: pop af  
48e7			endm  
# End of macro DMARK
48e7						CALLMONITOR 
48e7 cd 6f ee			call debug_vector  
48ea				endm  
# End of macro CALLMONITOR
48ea					endif 
48ea					NEXTW 
48ea cd 6c ee			call parse_vector 
48ed c3 b9 1e			jp macro_next 
48f0				endm 
# End of macro NEXTW
48f0			 
48f0			.SUBSTR: 
48f0				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
48f0 48				db WORD_SYS_CORE+52             
48f1 50 49			dw .LEFT            
48f3 07				db 6 + 1 
48f4 .. 00			db "SUBSTR",0              
48fb				endm 
# End of macro CWHEAD
48fb			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
48fb			 
48fb					if DEBUG_FORTH_WORDS_KEY 
48fb						DMARK "SST" 
48fb f5				push af  
48fc 3a 10 49			ld a, (.dmark)  
48ff 32 62 ee			ld (debug_mark),a  
4902 3a 11 49			ld a, (.dmark+1)  
4905 32 63 ee			ld (debug_mark+1),a  
4908 3a 12 49			ld a, (.dmark+2)  
490b 32 64 ee			ld (debug_mark+2),a  
490e 18 03			jr .pastdmark  
4910 ..			.dmark: db "SST"  
4913 f1			.pastdmark: pop af  
4914			endm  
# End of macro DMARK
4914						CALLMONITOR 
4914 cd 6f ee			call debug_vector  
4917				endm  
# End of macro CALLMONITOR
4917					endif 
4917			; TODO check string type 
4917					FORTH_DSP_VALUEHL 
4917 cd d2 1c			call macro_dsp_valuehl 
491a				endm 
# End of macro FORTH_DSP_VALUEHL
491a			 
491a e5					push hl      ; string length 
491b			 
491b					FORTH_DSP_POP 
491b cd 8a 1d			call macro_forth_dsp_pop 
491e				endm 
# End of macro FORTH_DSP_POP
491e			 
491e					FORTH_DSP_VALUEHL 
491e cd d2 1c			call macro_dsp_valuehl 
4921				endm 
# End of macro FORTH_DSP_VALUEHL
4921			 
4921 e5					push hl     ; start char 
4922			 
4922					FORTH_DSP_POP 
4922 cd 8a 1d			call macro_forth_dsp_pop 
4925				endm 
# End of macro FORTH_DSP_POP
4925			 
4925			 
4925					FORTH_DSP_VALUE 
4925 cd bb 1c			call macro_forth_dsp_value 
4928				endm 
# End of macro FORTH_DSP_VALUE
4928			 
4928 d1					pop de    ; get start post offset 
4929			 
4929 19					add hl, de    ; starting offset 
492a			 
492a c1					pop bc 
492b c5					push bc      ; grab size of string 
492c			 
492c e5					push hl    ; save string start  
492d			 
492d 26 00				ld h, 0 
492f 69					ld l, c 
4930 23					inc hl 
4931 23					inc hl 
4932			 
4932 cd ad 11				call malloc 
4935				if DEBUG_FORTH_MALLOC_GUARD 
4935 cc 27 54				call z,malloc_error 
4938				endif 
4938			 
4938 eb					ex de, hl      ; save malloc area for string copy 
4939 e1					pop hl    ; get back source 
493a c1					pop bc    ; get length of string back 
493b			 
493b d5					push de    ; save malloc area for after we push 
493c ed b0				ldir     ; copy substr 
493e			 
493e			 
493e eb					ex de, hl 
493f			;		ld a, 0 
493f 36 00				ld (hl), 0   ; term substr 
4941			 
4941					 
4941 e1					pop hl    ; get malloc so we can push it 
4942 e5					push hl   ; save so we can free it afterwards 
4943			 
4943 cd 40 1b				call forth_push_str 
4946			 
4946 e1					pop hl 
4947 cd 77 12				call free 
494a			 
494a					 
494a					 
494a			 
494a			 
494a					NEXTW 
494a cd 6c ee			call parse_vector 
494d c3 b9 1e			jp macro_next 
4950				endm 
# End of macro NEXTW
4950			 
4950			.LEFT: 
4950				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4950 48				db WORD_SYS_CORE+52             
4951 94 49			dw .RIGHT            
4953 05				db 4 + 1 
4954 .. 00			db "LEFT",0              
4959				endm 
# End of macro CWHEAD
4959			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4959					if DEBUG_FORTH_WORDS_KEY 
4959						DMARK "LEF" 
4959 f5				push af  
495a 3a 6e 49			ld a, (.dmark)  
495d 32 62 ee			ld (debug_mark),a  
4960 3a 6f 49			ld a, (.dmark+1)  
4963 32 63 ee			ld (debug_mark+1),a  
4966 3a 70 49			ld a, (.dmark+2)  
4969 32 64 ee			ld (debug_mark+2),a  
496c 18 03			jr .pastdmark  
496e ..			.dmark: db "LEF"  
4971 f1			.pastdmark: pop af  
4972			endm  
# End of macro DMARK
4972						CALLMONITOR 
4972 cd 6f ee			call debug_vector  
4975				endm  
# End of macro CALLMONITOR
4975					endif 
4975			 
4975					 
4975			; TODO check string type 
4975					FORTH_DSP_VALUEHL 
4975 cd d2 1c			call macro_dsp_valuehl 
4978				endm 
# End of macro FORTH_DSP_VALUEHL
4978			 
4978 e5					push hl      ; string length 
4979			 
4979					FORTH_DSP_POP 
4979 cd 8a 1d			call macro_forth_dsp_pop 
497c				endm 
# End of macro FORTH_DSP_POP
497c			 
497c					FORTH_DSP_VALUEHL 
497c cd d2 1c			call macro_dsp_valuehl 
497f				endm 
# End of macro FORTH_DSP_VALUEHL
497f			 
497f c1					pop bc 
4980			 
4980 11 b8 e2				ld de, scratch 
4983 ed b0				ldir 
4985 3e 00				ld a, 0 
4987 12					ld (de), a 
4988					 
4988 21 b8 e2				ld hl, scratch 
498b cd 40 1b				call forth_push_str 
498e			 
498e					NEXTW 
498e cd 6c ee			call parse_vector 
4991 c3 b9 1e			jp macro_next 
4994				endm 
# End of macro NEXTW
4994			.RIGHT: 
4994				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4994 48				db WORD_SYS_CORE+52             
4995 55 4a			dw .STR2NUM            
4997 06				db 5 + 1 
4998 .. 00			db "RIGHT",0              
499e				endm 
# End of macro CWHEAD
499e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
499e					if DEBUG_FORTH_WORDS_KEY 
499e						DMARK "RIG" 
499e f5				push af  
499f 3a b3 49			ld a, (.dmark)  
49a2 32 62 ee			ld (debug_mark),a  
49a5 3a b4 49			ld a, (.dmark+1)  
49a8 32 63 ee			ld (debug_mark+1),a  
49ab 3a b5 49			ld a, (.dmark+2)  
49ae 32 64 ee			ld (debug_mark+2),a  
49b1 18 03			jr .pastdmark  
49b3 ..			.dmark: db "RIG"  
49b6 f1			.pastdmark: pop af  
49b7			endm  
# End of macro DMARK
49b7						CALLMONITOR 
49b7 cd 6f ee			call debug_vector  
49ba				endm  
# End of macro CALLMONITOR
49ba					endif 
49ba			 
49ba			; TODO check string type 
49ba					FORTH_DSP_VALUEHL 
49ba cd d2 1c			call macro_dsp_valuehl 
49bd				endm 
# End of macro FORTH_DSP_VALUEHL
49bd			 
49bd e5					push hl      ; string length 
49be			 
49be					FORTH_DSP_POP 
49be cd 8a 1d			call macro_forth_dsp_pop 
49c1				endm 
# End of macro FORTH_DSP_POP
49c1			 
49c1					FORTH_DSP_VALUEHL 
49c1 cd d2 1c			call macro_dsp_valuehl 
49c4				endm 
# End of macro FORTH_DSP_VALUEHL
49c4			 
49c4					if DEBUG_FORTH_WORDS 
49c4						DMARK "RI1" 
49c4 f5				push af  
49c5 3a d9 49			ld a, (.dmark)  
49c8 32 62 ee			ld (debug_mark),a  
49cb 3a da 49			ld a, (.dmark+1)  
49ce 32 63 ee			ld (debug_mark+1),a  
49d1 3a db 49			ld a, (.dmark+2)  
49d4 32 64 ee			ld (debug_mark+2),a  
49d7 18 03			jr .pastdmark  
49d9 ..			.dmark: db "RI1"  
49dc f1			.pastdmark: pop af  
49dd			endm  
# End of macro DMARK
49dd						CALLMONITOR 
49dd cd 6f ee			call debug_vector  
49e0				endm  
# End of macro CALLMONITOR
49e0					endif 
49e0					; from the pointer to string get to the end of string 
49e0			 
49e0 01 ff 00				ld bc, 255 
49e3 3e 00				ld a, 0 
49e5 ed b1				cpir 
49e7 2b					dec hl 
49e8			 
49e8					;  
49e8			 
49e8					if DEBUG_FORTH_WORDS 
49e8						DMARK "RI2" 
49e8 f5				push af  
49e9 3a fd 49			ld a, (.dmark)  
49ec 32 62 ee			ld (debug_mark),a  
49ef 3a fe 49			ld a, (.dmark+1)  
49f2 32 63 ee			ld (debug_mark+1),a  
49f5 3a ff 49			ld a, (.dmark+2)  
49f8 32 64 ee			ld (debug_mark+2),a  
49fb 18 03			jr .pastdmark  
49fd ..			.dmark: db "RI2"  
4a00 f1			.pastdmark: pop af  
4a01			endm  
# End of macro DMARK
4a01						CALLMONITOR 
4a01 cd 6f ee			call debug_vector  
4a04				endm  
# End of macro CALLMONITOR
4a04					endif 
4a04			 
4a04 c1					pop bc    ;  length of string to copy 
4a05			 
4a05 79					ld a, c 
4a06 eb					ex de, hl 
4a07 21 b8 e2				ld hl, scratch  
4a0a cd e1 0d				call addatohl 
4a0d			 
4a0d eb					ex de, hl 
4a0e			 
4a0e					if DEBUG_FORTH_WORDS 
4a0e						DMARK "RI3" 
4a0e f5				push af  
4a0f 3a 23 4a			ld a, (.dmark)  
4a12 32 62 ee			ld (debug_mark),a  
4a15 3a 24 4a			ld a, (.dmark+1)  
4a18 32 63 ee			ld (debug_mark+1),a  
4a1b 3a 25 4a			ld a, (.dmark+2)  
4a1e 32 64 ee			ld (debug_mark+2),a  
4a21 18 03			jr .pastdmark  
4a23 ..			.dmark: db "RI3"  
4a26 f1			.pastdmark: pop af  
4a27			endm  
# End of macro DMARK
4a27						CALLMONITOR 
4a27 cd 6f ee			call debug_vector  
4a2a				endm  
# End of macro CALLMONITOR
4a2a					endif 
4a2a			 
4a2a 03					inc bc 
4a2b ed b8				lddr 
4a2d					 
4a2d 21 b8 e2				ld hl, scratch 
4a30					if DEBUG_FORTH_WORDS 
4a30						DMARK "RI4" 
4a30 f5				push af  
4a31 3a 45 4a			ld a, (.dmark)  
4a34 32 62 ee			ld (debug_mark),a  
4a37 3a 46 4a			ld a, (.dmark+1)  
4a3a 32 63 ee			ld (debug_mark+1),a  
4a3d 3a 47 4a			ld a, (.dmark+2)  
4a40 32 64 ee			ld (debug_mark+2),a  
4a43 18 03			jr .pastdmark  
4a45 ..			.dmark: db "RI4"  
4a48 f1			.pastdmark: pop af  
4a49			endm  
# End of macro DMARK
4a49						CALLMONITOR 
4a49 cd 6f ee			call debug_vector  
4a4c				endm  
# End of macro CALLMONITOR
4a4c					endif 
4a4c cd 40 1b				call forth_push_str 
4a4f			 
4a4f			 
4a4f					NEXTW 
4a4f cd 6c ee			call parse_vector 
4a52 c3 b9 1e			jp macro_next 
4a55				endm 
# End of macro NEXTW
4a55			 
4a55			 
4a55			.STR2NUM: 
4a55				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4a55 48				db WORD_SYS_CORE+52             
4a56 e4 4a			dw .NUM2STR            
4a58 08				db 7 + 1 
4a59 .. 00			db "STR2NUM",0              
4a61				endm 
# End of macro CWHEAD
4a61			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4a61			 
4a61			 
4a61			; TODO STR type check to do 
4a61					if DEBUG_FORTH_WORDS_KEY 
4a61						DMARK "S2N" 
4a61 f5				push af  
4a62 3a 76 4a			ld a, (.dmark)  
4a65 32 62 ee			ld (debug_mark),a  
4a68 3a 77 4a			ld a, (.dmark+1)  
4a6b 32 63 ee			ld (debug_mark+1),a  
4a6e 3a 78 4a			ld a, (.dmark+2)  
4a71 32 64 ee			ld (debug_mark+2),a  
4a74 18 03			jr .pastdmark  
4a76 ..			.dmark: db "S2N"  
4a79 f1			.pastdmark: pop af  
4a7a			endm  
# End of macro DMARK
4a7a						CALLMONITOR 
4a7a cd 6f ee			call debug_vector  
4a7d				endm  
# End of macro CALLMONITOR
4a7d					endif 
4a7d			 
4a7d					;FORTH_DSP 
4a7d					FORTH_DSP_VALUE 
4a7d cd bb 1c			call macro_forth_dsp_value 
4a80				endm 
# End of macro FORTH_DSP_VALUE
4a80					;inc hl 
4a80			 
4a80 eb					ex de, hl 
4a81					if DEBUG_FORTH_WORDS 
4a81						DMARK "S2a" 
4a81 f5				push af  
4a82 3a 96 4a			ld a, (.dmark)  
4a85 32 62 ee			ld (debug_mark),a  
4a88 3a 97 4a			ld a, (.dmark+1)  
4a8b 32 63 ee			ld (debug_mark+1),a  
4a8e 3a 98 4a			ld a, (.dmark+2)  
4a91 32 64 ee			ld (debug_mark+2),a  
4a94 18 03			jr .pastdmark  
4a96 ..			.dmark: db "S2a"  
4a99 f1			.pastdmark: pop af  
4a9a			endm  
# End of macro DMARK
4a9a						CALLMONITOR 
4a9a cd 6f ee			call debug_vector  
4a9d				endm  
# End of macro CALLMONITOR
4a9d					endif 
4a9d cd d0 10				call string_to_uint16 
4aa0			 
4aa0					if DEBUG_FORTH_WORDS 
4aa0						DMARK "S2b" 
4aa0 f5				push af  
4aa1 3a b5 4a			ld a, (.dmark)  
4aa4 32 62 ee			ld (debug_mark),a  
4aa7 3a b6 4a			ld a, (.dmark+1)  
4aaa 32 63 ee			ld (debug_mark+1),a  
4aad 3a b7 4a			ld a, (.dmark+2)  
4ab0 32 64 ee			ld (debug_mark+2),a  
4ab3 18 03			jr .pastdmark  
4ab5 ..			.dmark: db "S2b"  
4ab8 f1			.pastdmark: pop af  
4ab9			endm  
# End of macro DMARK
4ab9						CALLMONITOR 
4ab9 cd 6f ee			call debug_vector  
4abc				endm  
# End of macro CALLMONITOR
4abc					endif 
4abc			;		push hl 
4abc					FORTH_DSP_POP 
4abc cd 8a 1d			call macro_forth_dsp_pop 
4abf				endm 
# End of macro FORTH_DSP_POP
4abf			;		pop hl 
4abf					 
4abf					if DEBUG_FORTH_WORDS 
4abf						DMARK "S2b" 
4abf f5				push af  
4ac0 3a d4 4a			ld a, (.dmark)  
4ac3 32 62 ee			ld (debug_mark),a  
4ac6 3a d5 4a			ld a, (.dmark+1)  
4ac9 32 63 ee			ld (debug_mark+1),a  
4acc 3a d6 4a			ld a, (.dmark+2)  
4acf 32 64 ee			ld (debug_mark+2),a  
4ad2 18 03			jr .pastdmark  
4ad4 ..			.dmark: db "S2b"  
4ad7 f1			.pastdmark: pop af  
4ad8			endm  
# End of macro DMARK
4ad8						CALLMONITOR 
4ad8 cd 6f ee			call debug_vector  
4adb				endm  
# End of macro CALLMONITOR
4adb					endif 
4adb cd d6 1a				call forth_push_numhl	 
4ade			 
4ade				 
4ade				       NEXTW 
4ade cd 6c ee			call parse_vector 
4ae1 c3 b9 1e			jp macro_next 
4ae4				endm 
# End of macro NEXTW
4ae4			.NUM2STR: 
4ae4				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4ae4 48				db WORD_SYS_CORE+52             
4ae5 79 4b			dw .CONCAT            
4ae7 08				db 7 + 1 
4ae8 .. 00			db "NUM2STR",0              
4af0				endm 
# End of macro CWHEAD
4af0			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4af0			 
4af0			;		; malloc a string to target 
4af0			;		ld hl, 10     ; TODO max string size should be fine 
4af0			;		call malloc 
4af0			;		push hl    ; save malloc location 
4af0			; 
4af0			; 
4af0			;; TODO check int type 
4af0					if DEBUG_FORTH_WORDS_KEY 
4af0						DMARK "N2S" 
4af0 f5				push af  
4af1 3a 05 4b			ld a, (.dmark)  
4af4 32 62 ee			ld (debug_mark),a  
4af7 3a 06 4b			ld a, (.dmark+1)  
4afa 32 63 ee			ld (debug_mark+1),a  
4afd 3a 07 4b			ld a, (.dmark+2)  
4b00 32 64 ee			ld (debug_mark+2),a  
4b03 18 03			jr .pastdmark  
4b05 ..			.dmark: db "N2S"  
4b08 f1			.pastdmark: pop af  
4b09			endm  
# End of macro DMARK
4b09						CALLMONITOR 
4b09 cd 6f ee			call debug_vector  
4b0c				endm  
# End of macro CALLMONITOR
4b0c					endif 
4b0c			 
4b0c					FORTH_DSP_VALUEHL 
4b0c cd d2 1c			call macro_dsp_valuehl 
4b0f				endm 
# End of macro FORTH_DSP_VALUEHL
4b0f			 
4b0f					if DEBUG_FORTH_WORDS 
4b0f						DMARK "NS1" 
4b0f f5				push af  
4b10 3a 24 4b			ld a, (.dmark)  
4b13 32 62 ee			ld (debug_mark),a  
4b16 3a 25 4b			ld a, (.dmark+1)  
4b19 32 63 ee			ld (debug_mark+1),a  
4b1c 3a 26 4b			ld a, (.dmark+2)  
4b1f 32 64 ee			ld (debug_mark+2),a  
4b22 18 03			jr .pastdmark  
4b24 ..			.dmark: db "NS1"  
4b27 f1			.pastdmark: pop af  
4b28			endm  
# End of macro DMARK
4b28						CALLMONITOR 
4b28 cd 6f ee			call debug_vector  
4b2b				endm  
# End of macro CALLMONITOR
4b2b					endif 
4b2b					FORTH_DSP_POP 
4b2b cd 8a 1d			call macro_forth_dsp_pop 
4b2e				endm 
# End of macro FORTH_DSP_POP
4b2e			 
4b2e eb					ex de, hl 
4b2f 21 b8 e2				ld hl, scratch 
4b32					if DEBUG_FORTH_WORDS 
4b32						DMARK "NS2" 
4b32 f5				push af  
4b33 3a 47 4b			ld a, (.dmark)  
4b36 32 62 ee			ld (debug_mark),a  
4b39 3a 48 4b			ld a, (.dmark+1)  
4b3c 32 63 ee			ld (debug_mark+1),a  
4b3f 3a 49 4b			ld a, (.dmark+2)  
4b42 32 64 ee			ld (debug_mark+2),a  
4b45 18 03			jr .pastdmark  
4b47 ..			.dmark: db "NS2"  
4b4a f1			.pastdmark: pop af  
4b4b			endm  
# End of macro DMARK
4b4b						CALLMONITOR 
4b4b cd 6f ee			call debug_vector  
4b4e				endm  
# End of macro CALLMONITOR
4b4e					endif 
4b4e cd e8 10				call uitoa_16 
4b51 21 b8 e2				ld hl, scratch 
4b54					if DEBUG_FORTH_WORDS 
4b54						DMARK "NS3" 
4b54 f5				push af  
4b55 3a 69 4b			ld a, (.dmark)  
4b58 32 62 ee			ld (debug_mark),a  
4b5b 3a 6a 4b			ld a, (.dmark+1)  
4b5e 32 63 ee			ld (debug_mark+1),a  
4b61 3a 6b 4b			ld a, (.dmark+2)  
4b64 32 64 ee			ld (debug_mark+2),a  
4b67 18 03			jr .pastdmark  
4b69 ..			.dmark: db "NS3"  
4b6c f1			.pastdmark: pop af  
4b6d			endm  
# End of macro DMARK
4b6d						CALLMONITOR 
4b6d cd 6f ee			call debug_vector  
4b70				endm  
# End of macro CALLMONITOR
4b70					endif 
4b70 cd 40 1b				call forth_push_str 
4b73			;		ld a, l 
4b73			;		call DispAToASCII   
4b73			;;TODO need to chage above call to dump into string 
4b73			; 
4b73			; 
4b73			 
4b73				       NEXTW 
4b73 cd 6c ee			call parse_vector 
4b76 c3 b9 1e			jp macro_next 
4b79				endm 
# End of macro NEXTW
4b79			 
4b79			.CONCAT: 
4b79				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4b79 48				db WORD_SYS_CORE+52             
4b7a 2f 4c			dw .FIND            
4b7c 07				db 6 + 1 
4b7d .. 00			db "CONCAT",0              
4b84				endm 
# End of macro CWHEAD
4b84			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4b84			 
4b84			; TODO check string type 
4b84			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4b84			 
4b84					if DEBUG_FORTH_WORDS_KEY 
4b84						DMARK "CON" 
4b84 f5				push af  
4b85 3a 99 4b			ld a, (.dmark)  
4b88 32 62 ee			ld (debug_mark),a  
4b8b 3a 9a 4b			ld a, (.dmark+1)  
4b8e 32 63 ee			ld (debug_mark+1),a  
4b91 3a 9b 4b			ld a, (.dmark+2)  
4b94 32 64 ee			ld (debug_mark+2),a  
4b97 18 03			jr .pastdmark  
4b99 ..			.dmark: db "CON"  
4b9c f1			.pastdmark: pop af  
4b9d			endm  
# End of macro DMARK
4b9d						CALLMONITOR 
4b9d cd 6f ee			call debug_vector  
4ba0				endm  
# End of macro CALLMONITOR
4ba0					endif 
4ba0			 
4ba0			 
4ba0					FORTH_DSP_VALUE 
4ba0 cd bb 1c			call macro_forth_dsp_value 
4ba3				endm 
# End of macro FORTH_DSP_VALUE
4ba3 e5					push hl   ; s2 
4ba4			 
4ba4					FORTH_DSP_POP 
4ba4 cd 8a 1d			call macro_forth_dsp_pop 
4ba7				endm 
# End of macro FORTH_DSP_POP
4ba7			 
4ba7					FORTH_DSP_VALUE 
4ba7 cd bb 1c			call macro_forth_dsp_value 
4baa				endm 
# End of macro FORTH_DSP_VALUE
4baa			 
4baa e5					push hl   ; s1 
4bab			 
4bab					FORTH_DSP_POP 
4bab cd 8a 1d			call macro_forth_dsp_pop 
4bae				endm 
# End of macro FORTH_DSP_POP
4bae					 
4bae			 
4bae					; copy s1 
4bae			 
4bae				 
4bae					; save ptr 
4bae e1					pop hl  
4baf e5					push hl 
4bb0 3e 00				ld a, 0 
4bb2 cd 44 11				call strlent 
4bb5					;inc hl    ; zer0 
4bb5 06 00				ld b, 0 
4bb7 4d					ld c, l 
4bb8 e1					pop hl		 
4bb9 11 b8 e2				ld de, scratch	 
4bbc					if DEBUG_FORTH_WORDS 
4bbc						DMARK "CO1" 
4bbc f5				push af  
4bbd 3a d1 4b			ld a, (.dmark)  
4bc0 32 62 ee			ld (debug_mark),a  
4bc3 3a d2 4b			ld a, (.dmark+1)  
4bc6 32 63 ee			ld (debug_mark+1),a  
4bc9 3a d3 4b			ld a, (.dmark+2)  
4bcc 32 64 ee			ld (debug_mark+2),a  
4bcf 18 03			jr .pastdmark  
4bd1 ..			.dmark: db "CO1"  
4bd4 f1			.pastdmark: pop af  
4bd5			endm  
# End of macro DMARK
4bd5						CALLMONITOR 
4bd5 cd 6f ee			call debug_vector  
4bd8				endm  
# End of macro CALLMONITOR
4bd8					endif 
4bd8 ed b0				ldir 
4bda			 
4bda e1					pop hl 
4bdb e5					push hl 
4bdc d5					push de 
4bdd			 
4bdd			 
4bdd 3e 00				ld a, 0 
4bdf cd 44 11				call strlent 
4be2 23					inc hl    ; zer0 
4be3 23					inc hl 
4be4 06 00				ld b, 0 
4be6 4d					ld c, l 
4be7 d1					pop de 
4be8 e1					pop hl		 
4be9					if DEBUG_FORTH_WORDS 
4be9						DMARK "CO2" 
4be9 f5				push af  
4bea 3a fe 4b			ld a, (.dmark)  
4bed 32 62 ee			ld (debug_mark),a  
4bf0 3a ff 4b			ld a, (.dmark+1)  
4bf3 32 63 ee			ld (debug_mark+1),a  
4bf6 3a 00 4c			ld a, (.dmark+2)  
4bf9 32 64 ee			ld (debug_mark+2),a  
4bfc 18 03			jr .pastdmark  
4bfe ..			.dmark: db "CO2"  
4c01 f1			.pastdmark: pop af  
4c02			endm  
# End of macro DMARK
4c02						CALLMONITOR 
4c02 cd 6f ee			call debug_vector  
4c05				endm  
# End of macro CALLMONITOR
4c05					endif 
4c05 ed b0				ldir 
4c07			 
4c07			 
4c07			 
4c07 21 b8 e2				ld hl, scratch 
4c0a					if DEBUG_FORTH_WORDS 
4c0a						DMARK "CO5" 
4c0a f5				push af  
4c0b 3a 1f 4c			ld a, (.dmark)  
4c0e 32 62 ee			ld (debug_mark),a  
4c11 3a 20 4c			ld a, (.dmark+1)  
4c14 32 63 ee			ld (debug_mark+1),a  
4c17 3a 21 4c			ld a, (.dmark+2)  
4c1a 32 64 ee			ld (debug_mark+2),a  
4c1d 18 03			jr .pastdmark  
4c1f ..			.dmark: db "CO5"  
4c22 f1			.pastdmark: pop af  
4c23			endm  
# End of macro DMARK
4c23						CALLMONITOR 
4c23 cd 6f ee			call debug_vector  
4c26				endm  
# End of macro CALLMONITOR
4c26					endif 
4c26			 
4c26 cd 40 1b				call forth_push_str 
4c29			 
4c29			 
4c29			 
4c29			 
4c29				       NEXTW 
4c29 cd 6c ee			call parse_vector 
4c2c c3 b9 1e			jp macro_next 
4c2f				endm 
# End of macro NEXTW
4c2f			 
4c2f			 
4c2f			.FIND: 
4c2f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4c2f 4b				db WORD_SYS_CORE+55             
4c30 ef 4c			dw .LEN            
4c32 05				db 4 + 1 
4c33 .. 00			db "FIND",0              
4c38				endm 
# End of macro CWHEAD
4c38			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4c38			 
4c38					if DEBUG_FORTH_WORDS_KEY 
4c38						DMARK "FND" 
4c38 f5				push af  
4c39 3a 4d 4c			ld a, (.dmark)  
4c3c 32 62 ee			ld (debug_mark),a  
4c3f 3a 4e 4c			ld a, (.dmark+1)  
4c42 32 63 ee			ld (debug_mark+1),a  
4c45 3a 4f 4c			ld a, (.dmark+2)  
4c48 32 64 ee			ld (debug_mark+2),a  
4c4b 18 03			jr .pastdmark  
4c4d ..			.dmark: db "FND"  
4c50 f1			.pastdmark: pop af  
4c51			endm  
# End of macro DMARK
4c51						CALLMONITOR 
4c51 cd 6f ee			call debug_vector  
4c54				endm  
# End of macro CALLMONITOR
4c54					endif 
4c54			 
4c54			; TODO check string type 
4c54					FORTH_DSP_VALUE 
4c54 cd bb 1c			call macro_forth_dsp_value 
4c57				endm 
# End of macro FORTH_DSP_VALUE
4c57			 
4c57 e5					push hl    
4c58 7e					ld a,(hl)    ; char to find   
4c59			; TODO change char to substr 
4c59			 
4c59 f5					push af 
4c5a					 
4c5a			 
4c5a			 
4c5a					if DEBUG_FORTH_WORDS 
4c5a						DMARK "FN1" 
4c5a f5				push af  
4c5b 3a 6f 4c			ld a, (.dmark)  
4c5e 32 62 ee			ld (debug_mark),a  
4c61 3a 70 4c			ld a, (.dmark+1)  
4c64 32 63 ee			ld (debug_mark+1),a  
4c67 3a 71 4c			ld a, (.dmark+2)  
4c6a 32 64 ee			ld (debug_mark+2),a  
4c6d 18 03			jr .pastdmark  
4c6f ..			.dmark: db "FN1"  
4c72 f1			.pastdmark: pop af  
4c73			endm  
# End of macro DMARK
4c73						CALLMONITOR 
4c73 cd 6f ee			call debug_vector  
4c76				endm  
# End of macro CALLMONITOR
4c76					endif 
4c76			 
4c76					FORTH_DSP_POP 
4c76 cd 8a 1d			call macro_forth_dsp_pop 
4c79				endm 
# End of macro FORTH_DSP_POP
4c79			 
4c79					; string to search 
4c79			 
4c79					FORTH_DSP_VALUE 
4c79 cd bb 1c			call macro_forth_dsp_value 
4c7c				endm 
# End of macro FORTH_DSP_VALUE
4c7c			 
4c7c d1					pop de  ; d is char to find  
4c7d			 
4c7d					if DEBUG_FORTH_WORDS 
4c7d						DMARK "FN2" 
4c7d f5				push af  
4c7e 3a 92 4c			ld a, (.dmark)  
4c81 32 62 ee			ld (debug_mark),a  
4c84 3a 93 4c			ld a, (.dmark+1)  
4c87 32 63 ee			ld (debug_mark+1),a  
4c8a 3a 94 4c			ld a, (.dmark+2)  
4c8d 32 64 ee			ld (debug_mark+2),a  
4c90 18 03			jr .pastdmark  
4c92 ..			.dmark: db "FN2"  
4c95 f1			.pastdmark: pop af  
4c96			endm  
# End of macro DMARK
4c96						CALLMONITOR 
4c96 cd 6f ee			call debug_vector  
4c99				endm  
# End of macro CALLMONITOR
4c99					endif 
4c99					 
4c99 01 00 00				ld bc, 0 
4c9c 7e			.findchar:      ld a,(hl) 
4c9d			;		cp 0   		 
4c9d b7					or a 
4c9e 28 27				jr z, .finddone     
4ca0 ba					cp d 
4ca1 28 20				jr z, .foundchar 
4ca3 03					inc bc 
4ca4 23					inc hl 
4ca5					if DEBUG_FORTH_WORDS 
4ca5						DMARK "FN3" 
4ca5 f5				push af  
4ca6 3a ba 4c			ld a, (.dmark)  
4ca9 32 62 ee			ld (debug_mark),a  
4cac 3a bb 4c			ld a, (.dmark+1)  
4caf 32 63 ee			ld (debug_mark+1),a  
4cb2 3a bc 4c			ld a, (.dmark+2)  
4cb5 32 64 ee			ld (debug_mark+2),a  
4cb8 18 03			jr .pastdmark  
4cba ..			.dmark: db "FN3"  
4cbd f1			.pastdmark: pop af  
4cbe			endm  
# End of macro DMARK
4cbe						CALLMONITOR 
4cbe cd 6f ee			call debug_vector  
4cc1				endm  
# End of macro CALLMONITOR
4cc1					endif 
4cc1 18 d9				jr .findchar 
4cc3			 
4cc3			 
4cc3 c5			.foundchar:	push bc 
4cc4 e1					pop hl 
4cc5 18 03				jr .findexit 
4cc7			 
4cc7			 
4cc7							 
4cc7			 
4cc7			.finddone:     ; got to end of string with no find 
4cc7 21 00 00				ld hl, 0 
4cca			.findexit: 
4cca			 
4cca					if DEBUG_FORTH_WORDS 
4cca						DMARK "FNd" 
4cca f5				push af  
4ccb 3a df 4c			ld a, (.dmark)  
4cce 32 62 ee			ld (debug_mark),a  
4cd1 3a e0 4c			ld a, (.dmark+1)  
4cd4 32 63 ee			ld (debug_mark+1),a  
4cd7 3a e1 4c			ld a, (.dmark+2)  
4cda 32 64 ee			ld (debug_mark+2),a  
4cdd 18 03			jr .pastdmark  
4cdf ..			.dmark: db "FNd"  
4ce2 f1			.pastdmark: pop af  
4ce3			endm  
# End of macro DMARK
4ce3						CALLMONITOR 
4ce3 cd 6f ee			call debug_vector  
4ce6				endm  
# End of macro CALLMONITOR
4ce6					endif 
4ce6 cd d6 1a			call forth_push_numhl 
4ce9			 
4ce9				       NEXTW 
4ce9 cd 6c ee			call parse_vector 
4cec c3 b9 1e			jp macro_next 
4cef				endm 
# End of macro NEXTW
4cef			 
4cef			.LEN: 
4cef				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4cef 4c				db WORD_SYS_CORE+56             
4cf0 5c 4d			dw .ASC            
4cf2 06				db 5 + 1 
4cf3 .. 00			db "COUNT",0              
4cf9				endm 
# End of macro CWHEAD
4cf9			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4cf9			 
4cf9					if DEBUG_FORTH_WORDS_KEY 
4cf9						DMARK "CNT" 
4cf9 f5				push af  
4cfa 3a 0e 4d			ld a, (.dmark)  
4cfd 32 62 ee			ld (debug_mark),a  
4d00 3a 0f 4d			ld a, (.dmark+1)  
4d03 32 63 ee			ld (debug_mark+1),a  
4d06 3a 10 4d			ld a, (.dmark+2)  
4d09 32 64 ee			ld (debug_mark+2),a  
4d0c 18 03			jr .pastdmark  
4d0e ..			.dmark: db "CNT"  
4d11 f1			.pastdmark: pop af  
4d12			endm  
# End of macro DMARK
4d12						CALLMONITOR 
4d12 cd 6f ee			call debug_vector  
4d15				endm  
# End of macro CALLMONITOR
4d15					endif 
4d15			; TODO check string type 
4d15					FORTH_DSP_VALUE 
4d15 cd bb 1c			call macro_forth_dsp_value 
4d18				endm 
# End of macro FORTH_DSP_VALUE
4d18			 
4d18			 
4d18					if DEBUG_FORTH_WORDS 
4d18						DMARK "CN?" 
4d18 f5				push af  
4d19 3a 2d 4d			ld a, (.dmark)  
4d1c 32 62 ee			ld (debug_mark),a  
4d1f 3a 2e 4d			ld a, (.dmark+1)  
4d22 32 63 ee			ld (debug_mark+1),a  
4d25 3a 2f 4d			ld a, (.dmark+2)  
4d28 32 64 ee			ld (debug_mark+2),a  
4d2b 18 03			jr .pastdmark  
4d2d ..			.dmark: db "CN?"  
4d30 f1			.pastdmark: pop af  
4d31			endm  
# End of macro DMARK
4d31						CALLMONITOR 
4d31 cd 6f ee			call debug_vector  
4d34				endm  
# End of macro CALLMONITOR
4d34					endif 
4d34 cd 39 11				call strlenz 
4d37					if DEBUG_FORTH_WORDS 
4d37						DMARK "CNl" 
4d37 f5				push af  
4d38 3a 4c 4d			ld a, (.dmark)  
4d3b 32 62 ee			ld (debug_mark),a  
4d3e 3a 4d 4d			ld a, (.dmark+1)  
4d41 32 63 ee			ld (debug_mark+1),a  
4d44 3a 4e 4d			ld a, (.dmark+2)  
4d47 32 64 ee			ld (debug_mark+2),a  
4d4a 18 03			jr .pastdmark  
4d4c ..			.dmark: db "CNl"  
4d4f f1			.pastdmark: pop af  
4d50			endm  
# End of macro DMARK
4d50						CALLMONITOR 
4d50 cd 6f ee			call debug_vector  
4d53				endm  
# End of macro CALLMONITOR
4d53					endif 
4d53			 
4d53 cd d6 1a				call forth_push_numhl 
4d56			 
4d56			 
4d56			 
4d56				       NEXTW 
4d56 cd 6c ee			call parse_vector 
4d59 c3 b9 1e			jp macro_next 
4d5c				endm 
# End of macro NEXTW
4d5c			.ASC: 
4d5c				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4d5c 4d				db WORD_SYS_CORE+57             
4d5d cd 4d			dw .CHR            
4d5f 04				db 3 + 1 
4d60 .. 00			db "ASC",0              
4d64				endm 
# End of macro CWHEAD
4d64			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4d64					if DEBUG_FORTH_WORDS_KEY 
4d64						DMARK "ASC" 
4d64 f5				push af  
4d65 3a 79 4d			ld a, (.dmark)  
4d68 32 62 ee			ld (debug_mark),a  
4d6b 3a 7a 4d			ld a, (.dmark+1)  
4d6e 32 63 ee			ld (debug_mark+1),a  
4d71 3a 7b 4d			ld a, (.dmark+2)  
4d74 32 64 ee			ld (debug_mark+2),a  
4d77 18 03			jr .pastdmark  
4d79 ..			.dmark: db "ASC"  
4d7c f1			.pastdmark: pop af  
4d7d			endm  
# End of macro DMARK
4d7d						CALLMONITOR 
4d7d cd 6f ee			call debug_vector  
4d80				endm  
# End of macro CALLMONITOR
4d80					endif 
4d80					FORTH_DSP_VALUE 
4d80 cd bb 1c			call macro_forth_dsp_value 
4d83				endm 
# End of macro FORTH_DSP_VALUE
4d83					;v5 FORTH_DSP_VALUE 
4d83			;		inc hl      ; now at start of numeric as string 
4d83			 
4d83 e5					push hl 
4d84			 
4d84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d84 cd 8a 1d			call macro_forth_dsp_pop 
4d87				endm 
# End of macro FORTH_DSP_POP
4d87			 
4d87 e1					pop hl 
4d88			 
4d88					if DEBUG_FORTH_WORDS 
4d88						DMARK "AS1" 
4d88 f5				push af  
4d89 3a 9d 4d			ld a, (.dmark)  
4d8c 32 62 ee			ld (debug_mark),a  
4d8f 3a 9e 4d			ld a, (.dmark+1)  
4d92 32 63 ee			ld (debug_mark+1),a  
4d95 3a 9f 4d			ld a, (.dmark+2)  
4d98 32 64 ee			ld (debug_mark+2),a  
4d9b 18 03			jr .pastdmark  
4d9d ..			.dmark: db "AS1"  
4da0 f1			.pastdmark: pop af  
4da1			endm  
# End of macro DMARK
4da1						CALLMONITOR 
4da1 cd 6f ee			call debug_vector  
4da4				endm  
# End of macro CALLMONITOR
4da4					endif 
4da4					; push the content of a onto the stack as a value 
4da4			 
4da4 7e					ld a,(hl)   ; get char 
4da5 26 00				ld h,0 
4da7 6f					ld l,a 
4da8					if DEBUG_FORTH_WORDS 
4da8						DMARK "AS2" 
4da8 f5				push af  
4da9 3a bd 4d			ld a, (.dmark)  
4dac 32 62 ee			ld (debug_mark),a  
4daf 3a be 4d			ld a, (.dmark+1)  
4db2 32 63 ee			ld (debug_mark+1),a  
4db5 3a bf 4d			ld a, (.dmark+2)  
4db8 32 64 ee			ld (debug_mark+2),a  
4dbb 18 03			jr .pastdmark  
4dbd ..			.dmark: db "AS2"  
4dc0 f1			.pastdmark: pop af  
4dc1			endm  
# End of macro DMARK
4dc1						CALLMONITOR 
4dc1 cd 6f ee			call debug_vector  
4dc4				endm  
# End of macro CALLMONITOR
4dc4					endif 
4dc4 cd d6 1a				call forth_push_numhl 
4dc7			 
4dc7				       NEXTW 
4dc7 cd 6c ee			call parse_vector 
4dca c3 b9 1e			jp macro_next 
4dcd				endm 
# End of macro NEXTW
4dcd			 
4dcd			.CHR: 
4dcd				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4dcd 4d				db WORD_SYS_CORE+57             
4dce 0c 4e			dw .ENDSTR            
4dd0 04				db 3 + 1 
4dd1 .. 00			db "CHR",0              
4dd5				endm 
# End of macro CWHEAD
4dd5			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4dd5					if DEBUG_FORTH_WORDS_KEY 
4dd5						DMARK "CHR" 
4dd5 f5				push af  
4dd6 3a ea 4d			ld a, (.dmark)  
4dd9 32 62 ee			ld (debug_mark),a  
4ddc 3a eb 4d			ld a, (.dmark+1)  
4ddf 32 63 ee			ld (debug_mark+1),a  
4de2 3a ec 4d			ld a, (.dmark+2)  
4de5 32 64 ee			ld (debug_mark+2),a  
4de8 18 03			jr .pastdmark  
4dea ..			.dmark: db "CHR"  
4ded f1			.pastdmark: pop af  
4dee			endm  
# End of macro DMARK
4dee						CALLMONITOR 
4dee cd 6f ee			call debug_vector  
4df1				endm  
# End of macro CALLMONITOR
4df1					endif 
4df1					FORTH_DSP_VALUEHL 
4df1 cd d2 1c			call macro_dsp_valuehl 
4df4				endm 
# End of macro FORTH_DSP_VALUEHL
4df4			 
4df4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4df4 cd 8a 1d			call macro_forth_dsp_pop 
4df7				endm 
# End of macro FORTH_DSP_POP
4df7			 
4df7					; save asci byte as a zero term string and push string 
4df7			 
4df7 7d					ld a,l 
4df8 32 b8 e2				ld (scratch), a 
4dfb			 
4dfb 3e 00				ld a, 0 
4dfd 32 b9 e2				ld (scratch+1), a 
4e00			 
4e00 21 b8 e2				ld hl, scratch 
4e03 cd 40 1b				call forth_push_str 
4e06			 
4e06			 
4e06				       NEXTW 
4e06 cd 6c ee			call parse_vector 
4e09 c3 b9 1e			jp macro_next 
4e0c				endm 
# End of macro NEXTW
4e0c			 
4e0c			 
4e0c			 
4e0c			 
4e0c			.ENDSTR: 
4e0c			; eof 
4e0c			 
# End of file forth_words_str.asm
4e0c			include "forth_words_key.asm" 
4e0c			 
4e0c			; | ## Keyboard Words 
4e0c			 
4e0c			.KEY: 
4e0c				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
4e0c 3e				db WORD_SYS_CORE+42             
4e0d 3f 4e			dw .KEYDB            
4e0f 04				db 3 + 1 
4e10 .. 00			db "KEY",0              
4e14				endm 
# End of macro CWHEAD
4e14			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4e14			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4e14			; | | Can use something like this to process: 
4e14			; | | > repeat active . key ?dup if emit then #1 until  
4e14			 
4e14					if DEBUG_FORTH_WORDS_KEY 
4e14						DMARK "KEY" 
4e14 f5				push af  
4e15 3a 29 4e			ld a, (.dmark)  
4e18 32 62 ee			ld (debug_mark),a  
4e1b 3a 2a 4e			ld a, (.dmark+1)  
4e1e 32 63 ee			ld (debug_mark+1),a  
4e21 3a 2b 4e			ld a, (.dmark+2)  
4e24 32 64 ee			ld (debug_mark+2),a  
4e27 18 03			jr .pastdmark  
4e29 ..			.dmark: db "KEY"  
4e2c f1			.pastdmark: pop af  
4e2d			endm  
# End of macro DMARK
4e2d						CALLMONITOR 
4e2d cd 6f ee			call debug_vector  
4e30				endm  
# End of macro CALLMONITOR
4e30					endif 
4e30			; TODO currently waits 
4e30 cd b4 65				call cinndb 
4e33					;call cin_wait 
4e33 6f					ld l, a 
4e34 26 00				ld h, 0 
4e36 cd d6 1a				call forth_push_numhl 
4e39					NEXTW 
4e39 cd 6c ee			call parse_vector 
4e3c c3 b9 1e			jp macro_next 
4e3f				endm 
# End of macro NEXTW
4e3f			.KEYDB: 
4e3f				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
4e3f 3e				db WORD_SYS_CORE+42             
4e40 74 4e			dw .WAITK            
4e42 06				db 5 + 1 
4e43 .. 00			db "KEYDB",0              
4e49				endm 
# End of macro CWHEAD
4e49			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
4e49			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4e49			; | | Can use something like this to process: 
4e49			; | | > repeat active . key ?dup if emit then #1 until  
4e49			 
4e49					if DEBUG_FORTH_WORDS_KEY 
4e49						DMARK "KEB" 
4e49 f5				push af  
4e4a 3a 5e 4e			ld a, (.dmark)  
4e4d 32 62 ee			ld (debug_mark),a  
4e50 3a 5f 4e			ld a, (.dmark+1)  
4e53 32 63 ee			ld (debug_mark+1),a  
4e56 3a 60 4e			ld a, (.dmark+2)  
4e59 32 64 ee			ld (debug_mark+2),a  
4e5c 18 03			jr .pastdmark  
4e5e ..			.dmark: db "KEB"  
4e61 f1			.pastdmark: pop af  
4e62			endm  
# End of macro DMARK
4e62						CALLMONITOR 
4e62 cd 6f ee			call debug_vector  
4e65				endm  
# End of macro CALLMONITOR
4e65					endif 
4e65			; TODO currently waits 
4e65 cd b4 65				call cin 
4e68					;call cin_wait 
4e68 6f					ld l, a 
4e69 26 00				ld h, 0 
4e6b cd d6 1a				call forth_push_numhl 
4e6e					NEXTW 
4e6e cd 6c ee			call parse_vector 
4e71 c3 b9 1e			jp macro_next 
4e74				endm 
# End of macro NEXTW
4e74			.WAITK: 
4e74				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4e74 3f				db WORD_SYS_CORE+43             
4e75 a9 4e			dw .ACCEPT            
4e77 06				db 5 + 1 
4e78 .. 00			db "WAITK",0              
4e7e				endm 
# End of macro CWHEAD
4e7e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4e7e					if DEBUG_FORTH_WORDS_KEY 
4e7e						DMARK "WAI" 
4e7e f5				push af  
4e7f 3a 93 4e			ld a, (.dmark)  
4e82 32 62 ee			ld (debug_mark),a  
4e85 3a 94 4e			ld a, (.dmark+1)  
4e88 32 63 ee			ld (debug_mark+1),a  
4e8b 3a 95 4e			ld a, (.dmark+2)  
4e8e 32 64 ee			ld (debug_mark+2),a  
4e91 18 03			jr .pastdmark  
4e93 ..			.dmark: db "WAI"  
4e96 f1			.pastdmark: pop af  
4e97			endm  
# End of macro DMARK
4e97						CALLMONITOR 
4e97 cd 6f ee			call debug_vector  
4e9a				endm  
# End of macro CALLMONITOR
4e9a					endif 
4e9a cd ac 65				call cin_wait 
4e9d 6f					ld l, a 
4e9e 26 00				ld h, 0 
4ea0 cd d6 1a				call forth_push_numhl 
4ea3					NEXTW 
4ea3 cd 6c ee			call parse_vector 
4ea6 c3 b9 1e			jp macro_next 
4ea9				endm 
# End of macro NEXTW
4ea9			.ACCEPT: 
4ea9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4ea9 40				db WORD_SYS_CORE+44             
4eaa 09 4f			dw .EDIT            
4eac 07				db 6 + 1 
4ead .. 00			db "ACCEPT",0              
4eb4				endm 
# End of macro CWHEAD
4eb4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4eb4					; TODO crashes on push 
4eb4					if DEBUG_FORTH_WORDS_KEY 
4eb4						DMARK "ACC" 
4eb4 f5				push af  
4eb5 3a c9 4e			ld a, (.dmark)  
4eb8 32 62 ee			ld (debug_mark),a  
4ebb 3a ca 4e			ld a, (.dmark+1)  
4ebe 32 63 ee			ld (debug_mark+1),a  
4ec1 3a cb 4e			ld a, (.dmark+2)  
4ec4 32 64 ee			ld (debug_mark+2),a  
4ec7 18 03			jr .pastdmark  
4ec9 ..			.dmark: db "ACC"  
4ecc f1			.pastdmark: pop af  
4ecd			endm  
# End of macro DMARK
4ecd						CALLMONITOR 
4ecd cd 6f ee			call debug_vector  
4ed0				endm  
# End of macro CALLMONITOR
4ed0					endif 
4ed0 21 b6 e4				ld hl, os_input 
4ed3			;		ld a, 0 
4ed3 36 00				ld (hl),0 
4ed5 3a 55 ea				ld a,(f_cursor_ptr) 
4ed8 16 64				ld d, 100 
4eda 0e 00				ld c, 0 
4edc 1e 28				ld e, 40 
4ede cd 0e 0e				call input_str 
4ee1					; TODO perhaps do a type check and wrap in quotes if not a number 
4ee1 21 b6 e4				ld hl, os_input 
4ee4					if DEBUG_FORTH_WORDS 
4ee4						DMARK "AC1" 
4ee4 f5				push af  
4ee5 3a f9 4e			ld a, (.dmark)  
4ee8 32 62 ee			ld (debug_mark),a  
4eeb 3a fa 4e			ld a, (.dmark+1)  
4eee 32 63 ee			ld (debug_mark+1),a  
4ef1 3a fb 4e			ld a, (.dmark+2)  
4ef4 32 64 ee			ld (debug_mark+2),a  
4ef7 18 03			jr .pastdmark  
4ef9 ..			.dmark: db "AC1"  
4efc f1			.pastdmark: pop af  
4efd			endm  
# End of macro DMARK
4efd						CALLMONITOR 
4efd cd 6f ee			call debug_vector  
4f00				endm  
# End of macro CALLMONITOR
4f00					endif 
4f00 cd 40 1b				call forth_push_str 
4f03					NEXTW 
4f03 cd 6c ee			call parse_vector 
4f06 c3 b9 1e			jp macro_next 
4f09				endm 
# End of macro NEXTW
4f09			 
4f09			.EDIT: 
4f09				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4f09 40				db WORD_SYS_CORE+44             
4f0a ae 4f			dw .DEDIT            
4f0c 05				db 4 + 1 
4f0d .. 00			db "EDIT",0              
4f12				endm 
# End of macro CWHEAD
4f12			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4f12			 
4f12					; TODO does not copy from stack 
4f12					if DEBUG_FORTH_WORDS_KEY 
4f12						DMARK "EDT" 
4f12 f5				push af  
4f13 3a 27 4f			ld a, (.dmark)  
4f16 32 62 ee			ld (debug_mark),a  
4f19 3a 28 4f			ld a, (.dmark+1)  
4f1c 32 63 ee			ld (debug_mark+1),a  
4f1f 3a 29 4f			ld a, (.dmark+2)  
4f22 32 64 ee			ld (debug_mark+2),a  
4f25 18 03			jr .pastdmark  
4f27 ..			.dmark: db "EDT"  
4f2a f1			.pastdmark: pop af  
4f2b			endm  
# End of macro DMARK
4f2b						CALLMONITOR 
4f2b cd 6f ee			call debug_vector  
4f2e				endm  
# End of macro CALLMONITOR
4f2e					endif 
4f2e			 
4f2e					;FORTH_DSP 
4f2e					FORTH_DSP_VALUEHL 
4f2e cd d2 1c			call macro_dsp_valuehl 
4f31				endm 
# End of macro FORTH_DSP_VALUEHL
4f31			;		inc hl    ; TODO do type check 
4f31			 
4f31			;		call get_word_hl 
4f31 e5					push hl 
4f32					if DEBUG_FORTH_WORDS 
4f32						DMARK "EDp" 
4f32 f5				push af  
4f33 3a 47 4f			ld a, (.dmark)  
4f36 32 62 ee			ld (debug_mark),a  
4f39 3a 48 4f			ld a, (.dmark+1)  
4f3c 32 63 ee			ld (debug_mark+1),a  
4f3f 3a 49 4f			ld a, (.dmark+2)  
4f42 32 64 ee			ld (debug_mark+2),a  
4f45 18 03			jr .pastdmark  
4f47 ..			.dmark: db "EDp"  
4f4a f1			.pastdmark: pop af  
4f4b			endm  
# End of macro DMARK
4f4b						CALLMONITOR 
4f4b cd 6f ee			call debug_vector  
4f4e				endm  
# End of macro CALLMONITOR
4f4e					endif 
4f4e				;	ld a, 0 
4f4e cd 39 11				call strlenz 
4f51 23					inc hl 
4f52			 
4f52 06 00				ld b, 0 
4f54 4d					ld c, l 
4f55			 
4f55 e1					pop hl 
4f56 11 b6 e4				ld de, os_input 
4f59					if DEBUG_FORTH_WORDS_KEY 
4f59						DMARK "EDc" 
4f59 f5				push af  
4f5a 3a 6e 4f			ld a, (.dmark)  
4f5d 32 62 ee			ld (debug_mark),a  
4f60 3a 6f 4f			ld a, (.dmark+1)  
4f63 32 63 ee			ld (debug_mark+1),a  
4f66 3a 70 4f			ld a, (.dmark+2)  
4f69 32 64 ee			ld (debug_mark+2),a  
4f6c 18 03			jr .pastdmark  
4f6e ..			.dmark: db "EDc"  
4f71 f1			.pastdmark: pop af  
4f72			endm  
# End of macro DMARK
4f72						CALLMONITOR 
4f72 cd 6f ee			call debug_vector  
4f75				endm  
# End of macro CALLMONITOR
4f75					endif 
4f75 ed b0				ldir 
4f77			 
4f77			 
4f77 21 b6 e4				ld hl, os_input 
4f7a					;ld a, 0 
4f7a					;ld (hl),a 
4f7a 3a 55 ea				ld a,(f_cursor_ptr) 
4f7d 16 64				ld d, 100 
4f7f 0e 00				ld c, 0 
4f81 1e 28				ld e, 40 
4f83 cd 0e 0e				call input_str 
4f86					; TODO perhaps do a type check and wrap in quotes if not a number 
4f86 21 b6 e4				ld hl, os_input 
4f89					if DEBUG_FORTH_WORDS 
4f89						DMARK "ED1" 
4f89 f5				push af  
4f8a 3a 9e 4f			ld a, (.dmark)  
4f8d 32 62 ee			ld (debug_mark),a  
4f90 3a 9f 4f			ld a, (.dmark+1)  
4f93 32 63 ee			ld (debug_mark+1),a  
4f96 3a a0 4f			ld a, (.dmark+2)  
4f99 32 64 ee			ld (debug_mark+2),a  
4f9c 18 03			jr .pastdmark  
4f9e ..			.dmark: db "ED1"  
4fa1 f1			.pastdmark: pop af  
4fa2			endm  
# End of macro DMARK
4fa2						CALLMONITOR 
4fa2 cd 6f ee			call debug_vector  
4fa5				endm  
# End of macro CALLMONITOR
4fa5					endif 
4fa5 cd 40 1b				call forth_push_str 
4fa8					NEXTW 
4fa8 cd 6c ee			call parse_vector 
4fab c3 b9 1e			jp macro_next 
4fae				endm 
# End of macro NEXTW
4fae			 
4fae			.DEDIT: 
4fae				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4fae 40				db WORD_SYS_CORE+44             
4faf 13 50			dw .ENDKEY            
4fb1 06				db 5 + 1 
4fb2 .. 00			db "DEDIT",0              
4fb8				endm 
# End of macro CWHEAD
4fb8			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
4fb8			 
4fb8					; TODO does not copy from stack 
4fb8					if DEBUG_FORTH_WORDS_KEY 
4fb8						DMARK "DED" 
4fb8 f5				push af  
4fb9 3a cd 4f			ld a, (.dmark)  
4fbc 32 62 ee			ld (debug_mark),a  
4fbf 3a ce 4f			ld a, (.dmark+1)  
4fc2 32 63 ee			ld (debug_mark+1),a  
4fc5 3a cf 4f			ld a, (.dmark+2)  
4fc8 32 64 ee			ld (debug_mark+2),a  
4fcb 18 03			jr .pastdmark  
4fcd ..			.dmark: db "DED"  
4fd0 f1			.pastdmark: pop af  
4fd1			endm  
# End of macro DMARK
4fd1						CALLMONITOR 
4fd1 cd 6f ee			call debug_vector  
4fd4				endm  
# End of macro CALLMONITOR
4fd4					endif 
4fd4			 
4fd4					;FORTH_DSP 
4fd4					FORTH_DSP_VALUEHL 
4fd4 cd d2 1c			call macro_dsp_valuehl 
4fd7				endm 
# End of macro FORTH_DSP_VALUEHL
4fd7			;		inc hl    ; TODO do type check 
4fd7			 
4fd7			;		call get_word_hl 
4fd7 e5					push hl 
4fd8 e5					push hl 
4fd9					FORTH_DSP_POP 
4fd9 cd 8a 1d			call macro_forth_dsp_pop 
4fdc				endm 
# End of macro FORTH_DSP_POP
4fdc e1					pop hl 
4fdd					if DEBUG_FORTH_WORDS 
4fdd						DMARK "EDp" 
4fdd f5				push af  
4fde 3a f2 4f			ld a, (.dmark)  
4fe1 32 62 ee			ld (debug_mark),a  
4fe4 3a f3 4f			ld a, (.dmark+1)  
4fe7 32 63 ee			ld (debug_mark+1),a  
4fea 3a f4 4f			ld a, (.dmark+2)  
4fed 32 64 ee			ld (debug_mark+2),a  
4ff0 18 03			jr .pastdmark  
4ff2 ..			.dmark: db "EDp"  
4ff5 f1			.pastdmark: pop af  
4ff6			endm  
# End of macro DMARK
4ff6						CALLMONITOR 
4ff6 cd 6f ee			call debug_vector  
4ff9				endm  
# End of macro CALLMONITOR
4ff9					endif 
4ff9				;	ld a, 0 
4ff9 cd 39 11				call strlenz 
4ffc 23					inc hl 
4ffd			 
4ffd 06 00				ld b, 0 
4fff 4d					ld c, l 
5000			 
5000 e1					pop hl 
5001			 
5001					;ld a, 0 
5001					;ld (hl),a 
5001 3a 55 ea				ld a,(f_cursor_ptr) 
5004 16 64				ld d, 100 
5006 0e 00				ld c, 0 
5008 1e 28				ld e, 40 
500a cd 0e 0e				call input_str 
500d					; TODO perhaps do a type check and wrap in quotes if not a number 
500d					NEXTW 
500d cd 6c ee			call parse_vector 
5010 c3 b9 1e			jp macro_next 
5013				endm 
# End of macro NEXTW
5013			 
5013			 
5013			.ENDKEY: 
5013			; eof 
5013			 
# End of file forth_words_key.asm
5013			include "forth_words_const.asm" 
5013			 
5013			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
5013			 
5013			 
5013			.SPITIME: 
5013				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
5013 77				db WORD_SYS_CORE+99             
5014 2b 50			dw .VA            
5016 08				db 7 + 1 
5017 .. 00			db "SPITIME",0              
501f				endm 
# End of macro CWHEAD
501f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
501f			; 
501f			; | | If using BANK devices then leave as is. 
501f			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
501f			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
501f			 
501f 21 5b ea				ld hl, spi_clktime  
5022 cd d6 1a				call forth_push_numhl 
5025			 
5025					NEXTW 
5025 cd 6c ee			call parse_vector 
5028 c3 b9 1e			jp macro_next 
502b				endm 
# End of macro NEXTW
502b			 
502b			 
502b			.VA: 
502b				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
502b 77				db WORD_SYS_CORE+99             
502c 3e 50			dw .SYMBOL            
502e 03				db 2 + 1 
502f .. 00			db "VA",0              
5032				endm 
# End of macro CWHEAD
5032			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
5032 21 1f ea				ld hl, cli_var_array 
5035 cd d6 1a				call forth_push_numhl 
5038			 
5038					NEXTW 
5038 cd 6c ee			call parse_vector 
503b c3 b9 1e			jp macro_next 
503e				endm 
# End of macro NEXTW
503e			 
503e			.SYMBOL: 
503e				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
503e 77				db WORD_SYS_CORE+99             
503f 4d 51			dw .ENDCONST            
5041 07				db 6 + 1 
5042 .. 00			db "SYMBOL",0              
5049				endm 
# End of macro CWHEAD
5049			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
5049			; | 
5049			; | | The value is the number reference and the final address is pushed to stack 
5049			 
5049			; | | ``` 
5049			; | | dw sym_table 
5049			; | | dw nmi_vector 
5049			; | | dw cli_autodisplay 
5049			; | | dw cli_data_sp 
5049			; | | dw cli_data_stack 
5049			; | | dw cli_loop_sp 
5049			; | | dw cli_loop_stack 
5049			; | | dw cli_var_array 
5049			; | | dw cursor_col 
5049			; | | dw cursor_ptr 
5049			; | | ; 10 
5049			; | | dw cursor_row 
5049			; | | dw debug_mark 
5049			; | | dw display_fb0 
5049			; | | dw display_fb1 
5049			; | | dw display_fb2 
5049			; | | dw display_fb3 
5049			; | | dw display_fb_active 
5049			; | | dw execscratch 
5049			; | | dw f_cursor_ptr 
5049			; | | dw hardware_word 
5049			; | | ;20 
5049			; | | dw input_at_cursor 
5049			; | | dw input_at_pos 
5049			; | | dw input_cur_flash 
5049			; | | dw input_cur_onoff 
5049			; | | dw input_cursor 
5049			; | | dw input_display_size 
5049			; | | dw input_len 
5049			; | | dw input_ptr 
5049			; | | dw input_size 
5049			; | | dw input_start 
5049			; | | ; 30 
5049			; | | dw input_str 
5049			; | | dw input_under_cursor 
5049			; | | dw os_cli_cmd 
5049			; | | dw os_cur_ptr 
5049			; | | dw os_current_i 
5049			; | | dw os_input 
5049			; | | dw os_last_cmd 
5049			; | | dw os_last_new_uword 
5049			; | | dw debug_vector 
5049			; | | dw os_view_hl 
5049			; | | ;40 
5049			; | | dw os_word_scratch 
5049			; | | dw portbctl 
5049			; | | dw portbdata 
5049			; | | dw spi_cartdev 
5049			; | | dw spi_cartdev2 
5049			; | | dw spi_clktime 
5049			; | | dw spi_device 
5049			; | | dw spi_device_id 
5049			; | | dw spi_portbyte 
5049			; | | dw stackstore 
5049			; | | ; 50 
5049			; | | if STORAGE_SE 
5049			; | | dw storage_actl 
5049			; | | dw storage_adata 
5049			; | | else 
5049			; | | dw 0 
5049			; | | dw 0 
5049			; | | endif 
5049			; | | dw storage_append 
5049			; | | if STORAGE_SE 
5049			; | | dw storage_bctl 
5049			; | | else 
5049			; | | dw 0 
5049			; | | endif 
5049			; | | dw store_bank_active 
5049			; | | dw store_filecache 
5049			; | | dw store_longread 
5049			; | | dw store_openaddr 
5049			; | | dw store_openext 
5049			; | | dw store_openmaxext 
5049			; | | ; 60 
5049			; | | dw store_page 
5049			; | | dw store_readbuf 
5049			; | | dw store_readcont 
5049			; | | dw store_readptr 
5049			; | | dw store_tmpext 
5049			; | | dw store_tmpid 
5049			; | | dw store_tmppageid 
5049			; | | dw malloc 
5049			; | | dw free 
5049			; | | dw cin 
5049			; | | ; 70 
5049			; | | dw cin_wait 
5049			; | | dw forth_push_numhl 
5049			; | | dw forth_push_str 
5049			; | | dw parse_vector 
5049			; | | ``` 
5049			 
5049					if DEBUG_FORTH_WORDS_KEY 
5049						DMARK "SYM" 
5049 f5				push af  
504a 3a 5e 50			ld a, (.dmark)  
504d 32 62 ee			ld (debug_mark),a  
5050 3a 5f 50			ld a, (.dmark+1)  
5053 32 63 ee			ld (debug_mark+1),a  
5056 3a 60 50			ld a, (.dmark+2)  
5059 32 64 ee			ld (debug_mark+2),a  
505c 18 03			jr .pastdmark  
505e ..			.dmark: db "SYM"  
5061 f1			.pastdmark: pop af  
5062			endm  
# End of macro DMARK
5062						CALLMONITOR 
5062 cd 6f ee			call debug_vector  
5065				endm  
# End of macro CALLMONITOR
5065					endif 
5065			 
5065					FORTH_DSP_VALUEHL 
5065 cd d2 1c			call macro_dsp_valuehl 
5068				endm 
# End of macro FORTH_DSP_VALUEHL
5068			 
5068 7d					ld a, l     
5069			 
5069			 
5069					if DEBUG_FORTH_WORDS 
5069						DMARK "SY1" 
5069 f5				push af  
506a 3a 7e 50			ld a, (.dmark)  
506d 32 62 ee			ld (debug_mark),a  
5070 3a 7f 50			ld a, (.dmark+1)  
5073 32 63 ee			ld (debug_mark+1),a  
5076 3a 80 50			ld a, (.dmark+2)  
5079 32 64 ee			ld (debug_mark+2),a  
507c 18 03			jr .pastdmark  
507e ..			.dmark: db "SY1"  
5081 f1			.pastdmark: pop af  
5082			endm  
# End of macro DMARK
5082						CALLMONITOR 
5082 cd 6f ee			call debug_vector  
5085				endm  
# End of macro CALLMONITOR
5085					endif 
5085					 
5085 f5					push af	 
5086					FORTH_DSP_POP 
5086 cd 8a 1d			call macro_forth_dsp_pop 
5089				endm 
# End of macro FORTH_DSP_POP
5089 f1					pop af 
508a			 
508a cb 27				sla a  
508c				 
508c					 
508c					if DEBUG_FORTH_WORDS 
508c						DMARK "SY" 
508c f5				push af  
508d 3a a1 50			ld a, (.dmark)  
5090 32 62 ee			ld (debug_mark),a  
5093 3a a2 50			ld a, (.dmark+1)  
5096 32 63 ee			ld (debug_mark+1),a  
5099 3a a3 50			ld a, (.dmark+2)  
509c 32 64 ee			ld (debug_mark+2),a  
509f 18 02			jr .pastdmark  
50a1 ..			.dmark: db "SY"  
50a3 f1			.pastdmark: pop af  
50a4			endm  
# End of macro DMARK
50a4						CALLMONITOR 
50a4 cd 6f ee			call debug_vector  
50a7				endm  
# End of macro CALLMONITOR
50a7					endif 
50a7			 
50a7 21 b9 50				ld hl, sym_table 
50aa cd e1 0d				call addatohl 
50ad cd 3f 1e				call loadwordinhl 
50b0 cd d6 1a				call forth_push_numhl 
50b3			 
50b3			 
50b3				       NEXTW 
50b3 cd 6c ee			call parse_vector 
50b6 c3 b9 1e			jp macro_next 
50b9				endm 
# End of macro NEXTW
50b9			 
50b9			sym_table: 
50b9			 
50b9			; 0 
50b9 b9 50		dw sym_table 
50bb 72 ee		dw nmi_vector 
50bd 33 ea		dw cli_autodisplay 
50bf e5 e9		dw cli_data_sp 
50c1 1f e8		dw cli_data_stack 
50c3 e7 e9		dw cli_loop_sp 
50c5 21 e9		dw cli_loop_stack 
50c7 1f ea		dw cli_var_array 
50c9 bc eb		dw cursor_col 
50cb ba eb		dw cursor_ptr 
50cd			; 10 
50cd bb eb		dw cursor_row 
50cf 62 ee		dw debug_mark 
50d1 a8 ed		dw display_fb0 
50d3 07 ed		dw display_fb1 
50d5 c5 eb		dw display_fb2 
50d7 66 ec		dw display_fb3 
50d9 c3 eb		dw display_fb_active 
50db b7 e3		dw execscratch 
50dd 55 ea		dw f_cursor_ptr 
50df 75 ee		dw hardware_word 
50e1			;20 
50e1 59 ee		dw input_at_cursor 
50e3 5b ee		dw input_at_pos 
50e5 57 ee		dw input_cur_flash 
50e7 56 ee		dw input_cur_onoff 
50e9 4c ee		dw input_cursor 
50eb 5c ee		dw input_display_size 
50ed 51 ee		dw input_len 
50ef 60 ee		dw input_ptr 
50f1 5d ee		dw input_size 
50f3 5e ee		dw input_start 
50f5			; 30 
50f5 0e 0e		dw input_str 
50f7 5a ee		dw input_under_cursor 
50f9 df e5		dw os_cli_cmd 
50fb db e5		dw os_cur_ptr 
50fd dd e5		dw os_current_i 
50ff b6 e4		dw os_input 
5101 de e6		dw os_last_cmd 
5103 b5 e5		dw os_last_new_uword 
5105 6f ee		dw debug_vector 
5107 9a e2		dw os_view_hl 
5109			;40 
5109 bd e5		dw os_word_scratch 
510b c3 00		dw portbctl 
510d c1 00		dw portbdata 
510f 5a ea		dw spi_cartdev 
5111 59 ea		dw spi_cartdev2 
5113 5b ea		dw spi_clktime 
5115 57 ea		dw spi_device 
5117 56 ea		dw spi_device_id 
5119 58 ea		dw spi_portbyte 
511b 9e eb		dw stackstore 
511d			; 50 
511d			if STORAGE_SE 
511d			dw storage_actl 
511d			dw storage_adata 
511d			else 
511d 00 00		dw 0 
511f 00 00		dw 0 
5121			endif 
5121 6b 09		dw storage_append 
5123			if STORAGE_SE 
5123			dw storage_bctl 
5123			else 
5123 00 00		dw 0 
5125			endif 
5125 8a eb		dw store_bank_active 
5127 5e ea		dw store_filecache 
5129 6c ea		dw store_longread 
512b 62 ea		dw store_openaddr 
512d 61 ea		dw store_openext 
512f 60 ea		dw store_openmaxext 
5131			; 60 
5131 71 ea		dw store_page 
5133 6d ea		dw store_readbuf 
5135 64 ea		dw store_readcont 
5137 6f ea		dw store_readptr 
5139 64 ea		dw store_tmpext 
513b 65 ea		dw store_tmpid 
513d 5c ea		dw store_tmppageid 
513f ad 11		dw malloc 
5141 77 12		dw free 
5143 b4 65		dw cin 
5145			; 70 
5145 ac 65		dw cin_wait 
5147 d6 1a		dw forth_push_numhl 
5149 40 1b		dw forth_push_str 
514b 6c ee		dw parse_vector 
514d			 
514d			.ENDCONST: 
514d			 
514d			; eof 
514d			 
514d			 
# End of file forth_words_const.asm
514d			 
514d			if STORAGE_SE 
514d			   	include "forth_words_storage.asm" 
514d			endif 
514d				include "forth_words_device.asm" 
514d			; Device related words 
514d			 
514d			; | ## Device Words 
514d			 
514d			;if SOUND_ENABLE 
514d			;.NOTE: 
514d			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
514d			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
514d			;		if DEBUG_FORTH_WORDS_KEY 
514d			;			DMARK "NTE" 
514d			;			CALLMONITOR 
514d			;		endif 
514d			; 
514d			;	 
514d			; 
514d			;		NEXTW 
514d			;.AFTERSOUND: 
514d			;endif 
514d			 
514d			 
514d			USE_GPIO: equ 0 
514d			 
514d			if USE_GPIO 
514d			.GP1: 
514d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
514d			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
514d					NEXTW 
514d			.GP2: 
514d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
514d			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
514d			 
514d					NEXTW 
514d			 
514d			.GP3: 
514d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
514d			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
514d			 
514d					NEXTW 
514d			 
514d			.GP4: 
514d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
514d			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
514d			 
514d					NEXTW 
514d			.SIN: 
514d			 
514d			 
514d			endif 
514d			 
514d			 
514d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
514d 33				db WORD_SYS_CORE+31             
514e 85 51			dw .SOUT            
5150 03				db 2 + 1 
5151 .. 00			db "IN",0              
5154				endm 
# End of macro CWHEAD
5154			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5154					if DEBUG_FORTH_WORDS_KEY 
5154						DMARK "IN." 
5154 f5				push af  
5155 3a 69 51			ld a, (.dmark)  
5158 32 62 ee			ld (debug_mark),a  
515b 3a 6a 51			ld a, (.dmark+1)  
515e 32 63 ee			ld (debug_mark+1),a  
5161 3a 6b 51			ld a, (.dmark+2)  
5164 32 64 ee			ld (debug_mark+2),a  
5167 18 03			jr .pastdmark  
5169 ..			.dmark: db "IN."  
516c f1			.pastdmark: pop af  
516d			endm  
# End of macro DMARK
516d						CALLMONITOR 
516d cd 6f ee			call debug_vector  
5170				endm  
# End of macro CALLMONITOR
5170					endif 
5170					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5170 cd d2 1c			call macro_dsp_valuehl 
5173				endm 
# End of macro FORTH_DSP_VALUEHL
5173			 
5173 e5					push hl 
5174			 
5174					; destroy value TOS 
5174			 
5174					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5174 cd 8a 1d			call macro_forth_dsp_pop 
5177				endm 
# End of macro FORTH_DSP_POP
5177			 
5177					; one value on hl get other one back 
5177			 
5177 c1					pop bc 
5178			 
5178					; do the sub 
5178			;		ex de, hl 
5178			 
5178 ed 68				in l,(c) 
517a			 
517a					; save it 
517a			 
517a 26 00				ld h,0 
517c			 
517c					; TODO push value back onto stack for another op etc 
517c			 
517c cd d6 1a				call forth_push_numhl 
517f					NEXTW 
517f cd 6c ee			call parse_vector 
5182 c3 b9 1e			jp macro_next 
5185				endm 
# End of macro NEXTW
5185			.SOUT: 
5185				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5185 34				db WORD_SYS_CORE+32             
5186 db 51			dw .SPIO            
5188 04				db 3 + 1 
5189 .. 00			db "OUT",0              
518d				endm 
# End of macro CWHEAD
518d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
518d					if DEBUG_FORTH_WORDS_KEY 
518d						DMARK "OUT" 
518d f5				push af  
518e 3a a2 51			ld a, (.dmark)  
5191 32 62 ee			ld (debug_mark),a  
5194 3a a3 51			ld a, (.dmark+1)  
5197 32 63 ee			ld (debug_mark+1),a  
519a 3a a4 51			ld a, (.dmark+2)  
519d 32 64 ee			ld (debug_mark+2),a  
51a0 18 03			jr .pastdmark  
51a2 ..			.dmark: db "OUT"  
51a5 f1			.pastdmark: pop af  
51a6			endm  
# End of macro DMARK
51a6						CALLMONITOR 
51a6 cd 6f ee			call debug_vector  
51a9				endm  
# End of macro CALLMONITOR
51a9					endif 
51a9			 
51a9					; get port 
51a9			 
51a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51a9 cd d2 1c			call macro_dsp_valuehl 
51ac				endm 
# End of macro FORTH_DSP_VALUEHL
51ac			 
51ac e5					push hl 
51ad			 
51ad					; destroy value TOS 
51ad			 
51ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51ad cd 8a 1d			call macro_forth_dsp_pop 
51b0				endm 
# End of macro FORTH_DSP_POP
51b0			 
51b0					; get byte to send 
51b0			 
51b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51b0 cd d2 1c			call macro_dsp_valuehl 
51b3				endm 
# End of macro FORTH_DSP_VALUEHL
51b3			 
51b3			;		push hl 
51b3			 
51b3					; destroy value TOS 
51b3			 
51b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51b3 cd 8a 1d			call macro_forth_dsp_pop 
51b6				endm 
# End of macro FORTH_DSP_POP
51b6			 
51b6					; one value on hl get other one back 
51b6			 
51b6			;		pop hl 
51b6			 
51b6 c1					pop bc 
51b7			 
51b7					if DEBUG_FORTH_WORDS 
51b7						DMARK "OUT" 
51b7 f5				push af  
51b8 3a cc 51			ld a, (.dmark)  
51bb 32 62 ee			ld (debug_mark),a  
51be 3a cd 51			ld a, (.dmark+1)  
51c1 32 63 ee			ld (debug_mark+1),a  
51c4 3a ce 51			ld a, (.dmark+2)  
51c7 32 64 ee			ld (debug_mark+2),a  
51ca 18 03			jr .pastdmark  
51cc ..			.dmark: db "OUT"  
51cf f1			.pastdmark: pop af  
51d0			endm  
# End of macro DMARK
51d0						CALLMONITOR 
51d0 cd 6f ee			call debug_vector  
51d3				endm  
# End of macro CALLMONITOR
51d3					endif 
51d3			 
51d3 ed 69				out (c), l 
51d5			 
51d5					NEXTW 
51d5 cd 6c ee			call parse_vector 
51d8 c3 b9 1e			jp macro_next 
51db				endm 
# End of macro NEXTW
51db			 
51db			 
51db			.SPIO: 
51db			 
51db			if STORAGE_SE 
51db				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
51db			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
51db			 
51db					call spi_ce_low 
51db			    NEXTW 
51db			 
51db			.SPICEH: 
51db				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
51db			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
51db			 
51db					call spi_ce_high 
51db			    NEXTW 
51db			 
51db			 
51db			.SPIOb: 
51db			 
51db				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
51db			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
51db			 
51db					if DEBUG_FORTH_WORDS_KEY 
51db						DMARK "SPo" 
51db						CALLMONITOR 
51db					endif 
51db					; get port 
51db			 
51db			 
51db					; get byte to send 
51db			 
51db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51db			 
51db			;		push hl    ; u1  
51db			 
51db					; destroy value TOS 
51db			 
51db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51db			 
51db					; one value on hl get other one back 
51db			 
51db			;		pop hl   ; u2 - addr 
51db			 
51db					; TODO Send SPI byte 
51db			 
51db			;		push hl 
51db			;		call spi_ce_low 
51db			;		pop hl 
51db					ld a, l 
51db					call spi_send_byte 
51db			;		call spi_ce_high 
51db			 
51db					NEXTW 
51db			 
51db			.SPII: 
51db				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
51db			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
51db					if DEBUG_FORTH_WORDS_KEY 
51db						DMARK "SPi" 
51db						CALLMONITOR 
51db					endif 
51db			 
51db					; TODO Get SPI byte 
51db			 
51db					call spi_read_byte 
51db			 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "Si2" 
51db						CALLMONITOR 
51db					endif 
51db					ld h, 0 
51db					ld l, a 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "Si3" 
51db						CALLMONITOR 
51db					endif 
51db					call forth_push_numhl 
51db			 
51db					NEXTW 
51db			 
51db			 
51db			 
51db			.SESEL: 
51db				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
51db			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
51db			; | | Set to zero to disable storage. 
51db					if DEBUG_FORTH_WORDS_KEY 
51db						DMARK "BNK" 
51db						CALLMONITOR 
51db					endif 
51db			 
51db					ld a, 255 
51db					ld (spi_cartdev), a 
51db			 
51db					; get bank 
51db			 
51db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51db			 
51db			;		push hl 
51db			 
51db					; destroy value TOS 
51db			 
51db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51db			 
51db					; one value on hl get other one back 
51db			 
51db			;		pop hl 
51db			 
51db			 
51db					ld c, SPI_CE_HIGH 
51db					ld b, '0'    ; human readable bank number 
51db			 
51db					ld a, l 
51db			 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "BNK" 
51db						CALLMONITOR 
51db					endif 
51db			 
51db					; active low 
51db			 
51db			;		cp 0 
51db					or a 
51db					jr z, .bset 
51db					cp 1 
51db					jr nz, .b2 
51db					res 0, c 
51db					ld b, '1'    ; human readable bank number 
51db			.b2:		cp 2 
51db					jr nz, .b3 
51db					res 1, c 
51db					ld b, '2'    ; human readable bank number 
51db			.b3:		cp 3 
51db					jr nz, .b4 
51db					res 2, c 
51db					ld b, '3'    ; human readable bank number 
51db			.b4:		cp 4 
51db					jr nz, .b5 
51db					res 3, c 
51db					ld b, '4'    ; human readable bank number 
51db			.b5:		cp 5 
51db					jr nz, .bset 
51db					res 4, c 
51db					ld b, '5'    ; human readable bank number 
51db			 
51db			.bset: 
51db					ld a, c 
51db					ld (spi_device),a 
51db					ld a, b 
51db					ld (spi_device_id),a 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "BN2" 
51db						CALLMONITOR 
51db					endif 
51db			 
51db					; set default SPI clk pulse time as disabled for BANK use 
51db			 
51db					ld a, 0 
51db					ld (spi_clktime), a 
51db			 
51db					NEXTW 
51db			 
51db			.CARTDEV: 
51db				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
51db			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
51db			; | | Set to zero to disable devices. 
51db					if DEBUG_FORTH_WORDS_KEY 
51db						DMARK "CDV" 
51db						CALLMONITOR 
51db					endif 
51db			 
51db					; disable se storage bank selection 
51db			 
51db					ld a, SPI_CE_HIGH		; ce high 
51db					ld (spi_device), a 
51db			 
51db					; get bank 
51db			 
51db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51db			 
51db			;		push hl 
51db			 
51db					; destroy value TOS 
51db			 
51db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51db			 
51db					; one value on hl get other one back 
51db			 
51db			;		pop hl 
51db			 
51db					; active low 
51db			 
51db					ld c, 255 
51db			 
51db					ld a, l 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "CDV" 
51db						CALLMONITOR 
51db					endif 
51db			;		cp 0 
51db					or a 
51db					jr z, .cset 
51db					cp 1 
51db					jr nz, .c2 
51db					res 0, c 
51db			.c2:		cp 2 
51db					jr nz, .c3 
51db					res 1, c 
51db			.c3:		cp 3 
51db					jr nz, .c4 
51db					res 2, c 
51db			.c4:		cp 4 
51db					jr nz, .c5 
51db					res 3, c 
51db			.c5:		cp 5 
51db					jr nz, .c6 
51db					res 4, c 
51db			.c6:		cp 6 
51db					jr nz, .c7 
51db					res 5, c 
51db			.c7:		cp 7 
51db					jr nz, .c8 
51db					res 6, c 
51db			.c8:		cp 8 
51db					jr nz, .cset 
51db					res 7, c 
51db			.cset:		ld a, c 
51db					ld (spi_cartdev),a 
51db			 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "CD2" 
51db						CALLMONITOR 
51db					endif 
51db			 
51db					; set default SPI clk pulse time as 10ms for CARTDEV use 
51db			 
51db					ld a, $0a 
51db					ld (spi_clktime), a 
51db					NEXTW 
51db			endif 
51db			 
51db			.ENDDEVICE: 
51db			; eof 
51db			 
# End of file forth_words_device.asm
51db			 
51db			; var handler 
51db			 
51db			 
51db			.VARS: 
51db				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
51db 77				db WORD_SYS_CORE+99             
51dc 8f 52			dw .V0            
51de 04				db 3 + 1 
51df .. 00			db "VAR",0              
51e3				endm 
# End of macro CWHEAD
51e3			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
51e3			;| 
51e3			;| The variable name should consist of a single letter. e.g. "a" 
51e3			;! If a full string is passed then only the first char is looked at 
51e3			;| Any other char could exceed bounds checks!  
51e3			 
51e3					if DEBUG_FORTH_WORDS_KEY 
51e3						DMARK "VAR" 
51e3 f5				push af  
51e4 3a f8 51			ld a, (.dmark)  
51e7 32 62 ee			ld (debug_mark),a  
51ea 3a f9 51			ld a, (.dmark+1)  
51ed 32 63 ee			ld (debug_mark+1),a  
51f0 3a fa 51			ld a, (.dmark+2)  
51f3 32 64 ee			ld (debug_mark+2),a  
51f6 18 03			jr .pastdmark  
51f8 ..			.dmark: db "VAR"  
51fb f1			.pastdmark: pop af  
51fc			endm  
# End of macro DMARK
51fc						CALLMONITOR 
51fc cd 6f ee			call debug_vector  
51ff				endm  
# End of macro CALLMONITOR
51ff					endif 
51ff			 
51ff					FORTH_DSP_VALUEHL 
51ff cd d2 1c			call macro_dsp_valuehl 
5202				endm 
# End of macro FORTH_DSP_VALUEHL
5202			 
5202 7e					ld a, (hl)    ; get first char on of the string 
5203			 
5203			 
5203					if DEBUG_FORTH_WORDS 
5203						DMARK "VR1" 
5203 f5				push af  
5204 3a 18 52			ld a, (.dmark)  
5207 32 62 ee			ld (debug_mark),a  
520a 3a 19 52			ld a, (.dmark+1)  
520d 32 63 ee			ld (debug_mark+1),a  
5210 3a 1a 52			ld a, (.dmark+2)  
5213 32 64 ee			ld (debug_mark+2),a  
5216 18 03			jr .pastdmark  
5218 ..			.dmark: db "VR1"  
521b f1			.pastdmark: pop af  
521c			endm  
# End of macro DMARK
521c						CALLMONITOR 
521c cd 6f ee			call debug_vector  
521f				endm  
# End of macro CALLMONITOR
521f					endif 
521f					 
521f f5					push af	 
5220					FORTH_DSP_POP 
5220 cd 8a 1d			call macro_forth_dsp_pop 
5223				endm 
# End of macro FORTH_DSP_POP
5223 f1					pop af 
5224			 
5224					; convert to upper 
5224			 
5224 cd 49 10				call to_upper 
5227					if DEBUG_FORTH_WORDS 
5227						DMARK "Vaa" 
5227 f5				push af  
5228 3a 3c 52			ld a, (.dmark)  
522b 32 62 ee			ld (debug_mark),a  
522e 3a 3d 52			ld a, (.dmark+1)  
5231 32 63 ee			ld (debug_mark+1),a  
5234 3a 3e 52			ld a, (.dmark+2)  
5237 32 64 ee			ld (debug_mark+2),a  
523a 18 03			jr .pastdmark  
523c ..			.dmark: db "Vaa"  
523f f1			.pastdmark: pop af  
5240			endm  
# End of macro DMARK
5240						CALLMONITOR 
5240 cd 6f ee			call debug_vector  
5243				endm  
# End of macro CALLMONITOR
5243					endif 
5243 06 41				ld b, 'A' 
5245 90					sub b			; set offset 
5246					if DEBUG_FORTH_WORDS 
5246						DMARK "Vbb" 
5246 f5				push af  
5247 3a 5b 52			ld a, (.dmark)  
524a 32 62 ee			ld (debug_mark),a  
524d 3a 5c 52			ld a, (.dmark+1)  
5250 32 63 ee			ld (debug_mark+1),a  
5253 3a 5d 52			ld a, (.dmark+2)  
5256 32 64 ee			ld (debug_mark+2),a  
5259 18 03			jr .pastdmark  
525b ..			.dmark: db "Vbb"  
525e f1			.pastdmark: pop af  
525f			endm  
# End of macro DMARK
525f						CALLMONITOR 
525f cd 6f ee			call debug_vector  
5262				endm  
# End of macro CALLMONITOR
5262					endif 
5262 cb 27				sla a  
5264				 
5264					 
5264					if DEBUG_FORTH_WORDS 
5264						DMARK "VR2" 
5264 f5				push af  
5265 3a 79 52			ld a, (.dmark)  
5268 32 62 ee			ld (debug_mark),a  
526b 3a 7a 52			ld a, (.dmark+1)  
526e 32 63 ee			ld (debug_mark+1),a  
5271 3a 7b 52			ld a, (.dmark+2)  
5274 32 64 ee			ld (debug_mark+2),a  
5277 18 03			jr .pastdmark  
5279 ..			.dmark: db "VR2"  
527c f1			.pastdmark: pop af  
527d			endm  
# End of macro DMARK
527d						CALLMONITOR 
527d cd 6f ee			call debug_vector  
5280				endm  
# End of macro CALLMONITOR
5280					endif 
5280			 
5280 21 eb e9				ld hl, cli_var_array2 
5283 cd e1 0d				call addatohl 
5286 cd d6 1a				call forth_push_numhl 
5289			 
5289			 
5289				       NEXTW 
5289 cd 6c ee			call parse_vector 
528c c3 b9 1e			jp macro_next 
528f				endm 
# End of macro NEXTW
528f			.V0: 
528f				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
528f 78				db WORD_SYS_CORE+100             
5290 aa 52			dw .V0Q            
5292 04				db 3 + 1 
5293 .. 00			db "V0!",0              
5297				endm 
# End of macro CWHEAD
5297			;| V0! ( u1 -- )  Store value to v0  | DONE 
5297			 
5297					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5297 cd d2 1c			call macro_dsp_valuehl 
529a				endm 
# End of macro FORTH_DSP_VALUEHL
529a			 
529a 11 1f ea				ld de, cli_var_array 
529d			 
529d eb					ex de, hl 
529e 73					ld (hl), e 
529f 23					inc hl 
52a0 72					ld (hl), d 
52a1			 
52a1					; destroy value TOS 
52a1			 
52a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52a1 cd 8a 1d			call macro_forth_dsp_pop 
52a4				endm 
# End of macro FORTH_DSP_POP
52a4			 
52a4				       NEXTW 
52a4 cd 6c ee			call parse_vector 
52a7 c3 b9 1e			jp macro_next 
52aa				endm 
# End of macro NEXTW
52aa			.V0Q: 
52aa				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
52aa 79				db WORD_SYS_CORE+101             
52ab be 52			dw .V1S            
52ad 04				db 3 + 1 
52ae .. 00			db "V0@",0              
52b2				endm 
# End of macro CWHEAD
52b2			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
52b2 2a 1f ea				ld hl, (cli_var_array) 
52b5 cd d6 1a				call forth_push_numhl 
52b8			 
52b8				       NEXTW 
52b8 cd 6c ee			call parse_vector 
52bb c3 b9 1e			jp macro_next 
52be				endm 
# End of macro NEXTW
52be			.V1S: 
52be				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
52be 7a				db WORD_SYS_CORE+102             
52bf d9 52			dw .V1Q            
52c1 04				db 3 + 1 
52c2 .. 00			db "V1!",0              
52c6				endm 
# End of macro CWHEAD
52c6			;| V1! ( u1 -- )  Store value to v1 | DONE 
52c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52c6 cd d2 1c			call macro_dsp_valuehl 
52c9				endm 
# End of macro FORTH_DSP_VALUEHL
52c9			 
52c9 11 21 ea				ld de, cli_var_array+2 
52cc				 
52cc eb					ex de, hl 
52cd 73					ld (hl), e 
52ce 23					inc hl 
52cf 72					ld (hl), d 
52d0			 
52d0					; destroy value TOS 
52d0			 
52d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52d0 cd 8a 1d			call macro_forth_dsp_pop 
52d3				endm 
# End of macro FORTH_DSP_POP
52d3				       NEXTW 
52d3 cd 6c ee			call parse_vector 
52d6 c3 b9 1e			jp macro_next 
52d9				endm 
# End of macro NEXTW
52d9			.V1Q: 
52d9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
52d9 7b				db WORD_SYS_CORE+103             
52da ed 52			dw .V2S            
52dc 04				db 3 + 1 
52dd .. 00			db "V1@",0              
52e1				endm 
# End of macro CWHEAD
52e1			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
52e1 2a 21 ea				ld hl, (cli_var_array+2) 
52e4 cd d6 1a				call forth_push_numhl 
52e7				       NEXTW 
52e7 cd 6c ee			call parse_vector 
52ea c3 b9 1e			jp macro_next 
52ed				endm 
# End of macro NEXTW
52ed			.V2S: 
52ed				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
52ed 7c				db WORD_SYS_CORE+104             
52ee 08 53			dw .V2Q            
52f0 04				db 3 + 1 
52f1 .. 00			db "V2!",0              
52f5				endm 
# End of macro CWHEAD
52f5			;| V2! ( u1 -- )  Store value to v2 | DONE 
52f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52f5 cd d2 1c			call macro_dsp_valuehl 
52f8				endm 
# End of macro FORTH_DSP_VALUEHL
52f8			 
52f8 11 23 ea				ld de, cli_var_array+4 
52fb				 
52fb eb					ex de, hl 
52fc 73					ld (hl), e 
52fd 23					inc hl 
52fe 72					ld (hl), d 
52ff			 
52ff					; destroy value TOS 
52ff			 
52ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52ff cd 8a 1d			call macro_forth_dsp_pop 
5302				endm 
# End of macro FORTH_DSP_POP
5302				       NEXTW 
5302 cd 6c ee			call parse_vector 
5305 c3 b9 1e			jp macro_next 
5308				endm 
# End of macro NEXTW
5308			.V2Q: 
5308				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5308 7d				db WORD_SYS_CORE+105             
5309 1c 53			dw .V3S            
530b 04				db 3 + 1 
530c .. 00			db "V2@",0              
5310				endm 
# End of macro CWHEAD
5310			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5310 2a 23 ea				ld hl, (cli_var_array+4) 
5313 cd d6 1a				call forth_push_numhl 
5316				       NEXTW 
5316 cd 6c ee			call parse_vector 
5319 c3 b9 1e			jp macro_next 
531c				endm 
# End of macro NEXTW
531c			.V3S: 
531c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
531c 7c				db WORD_SYS_CORE+104             
531d 37 53			dw .V3Q            
531f 04				db 3 + 1 
5320 .. 00			db "V3!",0              
5324				endm 
# End of macro CWHEAD
5324			;| V3! ( u1 -- )  Store value to v3 | DONE 
5324					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5324 cd d2 1c			call macro_dsp_valuehl 
5327				endm 
# End of macro FORTH_DSP_VALUEHL
5327			 
5327 11 25 ea				ld de, cli_var_array+6 
532a				 
532a eb					ex de, hl 
532b 73					ld (hl), e 
532c 23					inc hl 
532d 72					ld (hl), d 
532e			 
532e					; destroy value TOS 
532e			 
532e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
532e cd 8a 1d			call macro_forth_dsp_pop 
5331				endm 
# End of macro FORTH_DSP_POP
5331				       NEXTW 
5331 cd 6c ee			call parse_vector 
5334 c3 b9 1e			jp macro_next 
5337				endm 
# End of macro NEXTW
5337			.V3Q: 
5337				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5337 7d				db WORD_SYS_CORE+105             
5338 4b 53			dw .END            
533a 04				db 3 + 1 
533b .. 00			db "V3@",0              
533f				endm 
# End of macro CWHEAD
533f			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
533f 2a 25 ea				ld hl, (cli_var_array+6) 
5342 cd d6 1a				call forth_push_numhl 
5345				       NEXTW 
5345 cd 6c ee			call parse_vector 
5348 c3 b9 1e			jp macro_next 
534b				endm 
# End of macro NEXTW
534b			 
534b			 
534b			 
534b			 
534b			 
534b			; end of dict marker 
534b			 
534b 00			.END:    db WORD_SYS_END 
534c 00 00			dw 0 
534e 00				db 0 
534f			 
534f			; use to jp here for user dict words to save on macro expansion  
534f			 
534f			user_dict_next: 
534f				NEXTW 
534f cd 6c ee			call parse_vector 
5352 c3 b9 1e			jp macro_next 
5355				endm 
# End of macro NEXTW
5355			 
5355			 
5355			user_exec: 
5355				;    ld hl, <word code> 
5355				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5355				;    call forthexec 
5355				;    jp user_dict_next   (NEXT) 
5355			        ;    <word code bytes> 
5355 eb				ex de, hl 
5356 2a b9 e5			ld hl,(os_tok_ptr) 
5359				 
5359				FORTH_RSP_NEXT 
5359 cd 7d 1a			call macro_forth_rsp_next 
535c				endm 
# End of macro FORTH_RSP_NEXT
535c			 
535c			if DEBUG_FORTH_UWORD 
535c						DMARK "UEX" 
535c f5				push af  
535d 3a 71 53			ld a, (.dmark)  
5360 32 62 ee			ld (debug_mark),a  
5363 3a 72 53			ld a, (.dmark+1)  
5366 32 63 ee			ld (debug_mark+1),a  
5369 3a 73 53			ld a, (.dmark+2)  
536c 32 64 ee			ld (debug_mark+2),a  
536f 18 03			jr .pastdmark  
5371 ..			.dmark: db "UEX"  
5374 f1			.pastdmark: pop af  
5375			endm  
# End of macro DMARK
5375				CALLMONITOR 
5375 cd 6f ee			call debug_vector  
5378				endm  
# End of macro CALLMONITOR
5378			endif 
5378			 
5378			 
5378			 
5378 eb				ex de, hl 
5379 22 b9 e5			ld (os_tok_ptr), hl 
537c				 
537c				; Don't use next - Skips the first word in uword. 
537c			 
537c c3 3a 1f			jp exec1 
537f			;	NEXT 
537f			 
537f			 
537f			; eof 
# End of file forth_wordsv4.asm
537f			endif 
537f			;;;;;;;;;;;;;; Debug code 
537f			 
537f			 
537f			;if DEBUG_FORTH_PARSE 
537f .. 00		.nowordfound: db "No match",0 
5388 .. 00		.compword:	db "Comparing word ",0 
5398 .. 00		.nextwordat:	db "Next word at",0 
53a5 .. 00		.charmatch:	db "Char match",0 
53b0			;endif 
53b0			if DEBUG_FORTH_JP 
53b0			.foundword:	db "Word match. Exec..",0 
53b0			endif 
53b0			;if DEBUG_FORTH_PUSH 
53b0 .. 00		.enddict:	db "Dict end. Push.",0 
53c0 .. 00		.push_str:	db "Pushing string",0 
53cf .. 00		.push_num:	db "Pushing number",0 
53de .. 00		.data_sp:	db "SP:",0 
53e2 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
53f4 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5406 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5418			;endif 
5418			;if DEBUG_FORTH_MALLOC 
5418 .. 00		.push_malloc:	db "Malloc address",0 
5427			;endif 
5427			 
5427			 
5427			 
5427			; display malloc address and current data stack pointer  
5427			 
5427			malloc_error: 
5427 d5				push de 
5428 f5				push af 
5429 e5				push hl 
542a cd b7 0b			call clear_display 
542d 11 4d 54			ld de, .mallocerr 
5430 3e 00			ld a,0 
5432			;	ld de,os_word_scratch 
5432 cd c9 0b			call str_at_display 
5435 3e 11			ld a, display_row_1+17 
5437 11 62 ee			ld de, debug_mark 
543a cd c9 0b			call str_at_display 
543d cd d9 0b			call update_display 
5440				;call break_point_state 
5440 cd ac 65			call cin_wait 
5443			 
5443			;	ld a, ' ' 
5443			;	ld (os_view_disable), a 
5443 cd 55 14			call bp_on 
5446 e1				pop hl 
5447 f1				pop af 
5448 d1				pop de	 
5449				CALLMONITOR 
5449 cd 6f ee			call debug_vector  
544c				endm  
# End of macro CALLMONITOR
544c c9				ret 
544d			 
544d .. 00		.mallocerr: 	db "Malloc Error",0 
545a			;if DEBUG_FORTH_PUSH 
545a			display_data_sp: 
545a f5				push af 
545b			 
545b				; see if disabled 
545b			 
545b			 
545b 3a 6f ee			ld a, (debug_vector) 
545e fe c9			cp $C9  ; RET 
5460				;ld a, (os_view_disable) 
5460				;cp '*' 
5460 28 65			jr z, .skipdsp 
5462			 
5462 e5				push hl 
5463 e5				push hl 
5464 e5			push hl 
5465 cd b7 0b			call clear_display 
5468 e1			pop hl 
5469 7c				ld a,h 
546a 21 bd e5			ld hl, os_word_scratch 
546d cd dd 0f			call hexout 
5470 e1				pop hl 
5471 7d				ld a,l 
5472 21 bf e5			ld hl, os_word_scratch+2 
5475 cd dd 0f			call hexout 
5478 21 c1 e5			ld hl, os_word_scratch+4 
547b			;	ld a,0 
547b 36 00			ld (hl),0 
547d 11 bd e5			ld de,os_word_scratch 
5480 3e 28				ld a, display_row_2 
5482 cd c9 0b				call str_at_display 
5485 11 e2 53			ld de, .wordinhl 
5488 3e 00			ld a, display_row_1 
548a			 
548a cd c9 0b				call str_at_display 
548d 11 62 ee			ld de, debug_mark 
5490 3e 11			ld a, display_row_1+17 
5492			 
5492 cd c9 0b				call str_at_display 
5495			 
5495				; display current data stack pointer 
5495 11 de 53			ld de,.data_sp 
5498 3e 30				ld a, display_row_2 + 8 
549a cd c9 0b				call str_at_display 
549d			 
549d 2a e5 e9			ld hl,(cli_data_sp) 
54a0 e5				push hl 
54a1 7c				ld a,h 
54a2 21 bd e5			ld hl, os_word_scratch 
54a5 cd dd 0f			call hexout 
54a8 e1				pop hl 
54a9 7d				ld a,l 
54aa 21 bf e5			ld hl, os_word_scratch+2 
54ad cd dd 0f			call hexout 
54b0 21 c1 e5			ld hl, os_word_scratch+4 
54b3			;	ld a,0 
54b3 36 00			ld (hl),0 
54b5 11 bd e5			ld de,os_word_scratch 
54b8 3e 33				ld a, display_row_2 + 11 
54ba cd c9 0b				call str_at_display 
54bd			 
54bd			 
54bd cd d9 0b			call update_display 
54c0 cd f0 0a			call delay1s 
54c3 cd f0 0a			call delay1s 
54c6 e1				pop hl 
54c7			.skipdsp: 
54c7 f1				pop af 
54c8 c9				ret 
54c9			 
54c9			display_data_malloc: 
54c9			 
54c9 f5				push af 
54ca e5				push hl 
54cb e5				push hl 
54cc e5			push hl 
54cd cd b7 0b			call clear_display 
54d0 e1			pop hl 
54d1 7c				ld a,h 
54d2 21 bd e5			ld hl, os_word_scratch 
54d5 cd dd 0f			call hexout 
54d8 e1				pop hl 
54d9 7d				ld a,l 
54da 21 bf e5			ld hl, os_word_scratch+2 
54dd cd dd 0f			call hexout 
54e0 21 c1 e5			ld hl, os_word_scratch+4 
54e3			;	ld a,0 
54e3 36 00			ld (hl),0 
54e5 11 bd e5			ld de,os_word_scratch 
54e8 3e 28				ld a, display_row_2 
54ea cd c9 0b				call str_at_display 
54ed 11 18 54			ld de, .push_malloc 
54f0 3e 00			ld a, display_row_1 
54f2			 
54f2 cd c9 0b				call str_at_display 
54f5			 
54f5				; display current data stack pointer 
54f5 11 de 53			ld de,.data_sp 
54f8 3e 30				ld a, display_row_2 + 8 
54fa cd c9 0b				call str_at_display 
54fd			 
54fd 2a e5 e9			ld hl,(cli_data_sp) 
5500 e5				push hl 
5501 7c				ld a,h 
5502 21 bd e5			ld hl, os_word_scratch 
5505 cd dd 0f			call hexout 
5508 e1				pop hl 
5509 7d				ld a,l 
550a 21 bf e5			ld hl, os_word_scratch+2 
550d cd dd 0f			call hexout 
5510 21 c1 e5			ld hl, os_word_scratch+4 
5513			;	ld a,0 
5513 36 00			ld (hl),0 
5515 11 bd e5			ld de,os_word_scratch 
5518 3e 33				ld a, display_row_2 + 11 
551a cd c9 0b				call str_at_display 
551d			 
551d cd d9 0b			call update_display 
5520 cd f0 0a			call delay1s 
5523 cd f0 0a			call delay1s 
5526 e1				pop hl 
5527 f1				pop af 
5528 c9				ret 
5529			;endif 
5529			 
5529			include "forth_autostart.asm" 
5529			; list of commands to perform at system start up 
5529			 
5529			startcmds: 
5529			;	dw test11 
5529			;	dw test12 
5529			;	dw test13 
5529			;	dw test14 
5529			;	dw test15 
5529			;	dw test16 
5529			;	dw test17 
5529			;	dw ifthtest1 
5529			;	dw ifthtest2 
5529			;	dw ifthtest3 
5529			;	dw mmtest1 
5529			;	dw mmtest2 
5529			;	dw mmtest3 
5529			;	dw mmtest4 
5529			;	dw mmtest5 
5529			;	dw mmtest6 
5529			;	dw iftest1 
5529			;	dw iftest2 
5529			;	dw iftest3 
5529			;	dw looptest1 
5529			;	dw looptest2 
5529			;	dw test1 
5529			;	dw test2 
5529			;	dw test3 
5529			;	dw test4 
5529			;	dw game2r 
5529			;	dw game2b1 
5529			;	dw game2b2 
5529			 
5529				; start up words that are actually useful 
5529			 
5529			;    dw spi1 
5529			;    dw spi2 
5529			;    dw spi3 
5529			;    dw spi4 
5529			;    dw spi5 
5529			;    dw spi6 
5529			;    dw spi7 
5529			; 
5529			;    dw spi8 
5529			;    dw spi9 
5529			;    dw spi10 
5529			 
5529			; file editor 
5529			;	dw edit1 
5529			;	dw edit2 
5529			;	dw edit3 
5529			 
5529			;	dw longread 
5529 4b 59			dw clrstack 
552b 7f 59			dw type 
552d			;	dw stest 
552d a4 59			dw strncpy 
552f 14 5b			dw list 
5531 05 5a			dw start1 
5533 15 5a			dw start2 
5535			;	dw start3 
5535			;	dw start3b 
5535			;	dw start3c 
5535			 
5535				; (unit) testing words 
5535			 
5535			;	dw mtesta 
5535			;	dw mtestb 
5535			;	dw mtestc 
5535			;	dw mtestd 
5535			;	dw mteste 
5535			 
5535				; demo/game words 
5535			 
5535			;        dw game3w 
5535			;        dw game3p 
5535			;        dw game3sc 
5535			;        dw game3vsi 
5535			;        dw game3vs 
5535				 
5535			;	dw game2b 
5535			;	dw game2bf 
5535			;	dw game2mba 
5535			;	dw game2mbas 
5535			;	dw game2mb 
5535			 
5535 45 5d			dw game1 
5537 56 5d			dw game1a 
5539 b8 5d			dw game1b 
553b ed 5d			dw game1c 
553d 23 5e			dw game1d 
553f 54 5e			dw game1s 
5541 68 5e			dw game1t 
5543 7d 5e			dw game1f 
5545 b1 5e			dw game1z 
5547 f5 5e			dw game1zz 
5549			 
5549 7e 5b			dw test5 
554b b6 5b			dw test6 
554d ee 5b			dw test7 
554f 02 5c			dw test8 
5551 2e 5c			dw test9 
5553 44 5c			dw test10 
5555				 
5555 cc 5f		        dw ssv5 
5557 b0 5f		        dw ssv4 
5559 94 5f		        dw ssv3 
555b 5e 5f		        dw ssv2 
555d e5 5f		        dw ssv1 
555f 2d 60		        dw ssv1cpm 
5561			;	dw keyup 
5561			;	dw keydown 
5561			;	dw keyleft 
5561			;	dw keyright 
5561			;	dw 	keyf1 
5561			;	dw keyf2 
5561			;	dw keyf3 
5561			;	dw keyf4 
5561			;	dw keyf5 
5561			;	dw keyf6 
5561			;	dw keyf7 
5561			;	dw keyf8 
5561			;	dw keyf9 
5561			;	dw keyf10 
5561			;	dw keyf11 
5561			;	dw keyf12 
5561			;	dw keytab 
5561			;	dw keycr 
5561			;	dw keyhome 
5561			;	dw keyend 
5561			;	dw keybs 
5561 00 00			db 0, 0	 
5563			 
5563			 
5563			; File Editor 
5563			 
5563			; ( id - ) use 'e' to edit the displayed line 
5563 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5584 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
55b9			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
55b9 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
55f1			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
55f1			 
55f1			; SPI Net support words 
55f1			 
55f1			; v0! = node to send to 
55f1			; ( str count - ) 
55f1 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
564a			 
564a			; spiputc ( char node - ) 
564a .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
567e			; spiputc ( u node - ) 
567e .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
56ac			 
56ac			; spigetc ( - n ) 
56ac .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
56d5			 
56d5			; getnode ( - n ) 
56d5 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5702			 
5702			; ( str node - )  
5702 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5768			; store string ( str i - ) 
5768			 
5768			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5768 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
57bd			 
57bd			; get string ( addr i -  )    TO FIX 
57bd			 
57bd .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5815			 
5815			 
5815			; NETCHAT (TODO) 
5815			; Program to allow two nodes to chat with eachother 
5815			; 
5815			; v0 - target node 
5815			;  
5815			; accept input at 0,0 
5815			; if input is string send spitype to target node 
5815			; starting at row 2,0 , while spigetchr is not zero ->  
5815			; 
5815			; 
5815			; TODO add paging of get request 
5815			 
5815			; ( node - ) 
5815 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5834 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
588c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5904			 
5904			 
5904			; Long read of currently open file 
5904 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
594b			 
594b			; clear stack  
594b			 
594b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
597f			 
597f			; type ( addr count - ) 
597f .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
59a4			 
59a4			; some direct memory words 
59a4			; strncpy ( len t f -- t ) 
59a4			 
59a4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5a05			 
5a05 .. 00		start1:     	db ": bpon $00 bp ;",0 
5a15 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5a26 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5aa1 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5b01			 
5b01 .. 00		tuck:         db ": tuck swap over ;", 0 
5b14			 
5b14			; a handy word to list items on the stack 
5b14			 
5b14 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5b7e			 
5b7e			 
5b7e			; test stack  
5b7e			; rnd8 stest 
5b7e			 
5b7e			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5b7e			 
5b7e			; random malloc and free cycles 
5b7e			 
5b7e			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b7e			 
5b7e			; fixed malloc and free cycles 
5b7e			 
5b7e			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b7e			 
5b7e			; fixed double string push and drop cycle  
5b7e			 
5b7e			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5b7e			 
5b7e			; consistent fixed string push and drop cycle  
5b7e			 
5b7e			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b7e			 
5b7e			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b7e			 
5b7e			;test1:		db ": aa 1 2 3 ;", 0 
5b7e			;test2:     	db "111 aa 888 999",0 
5b7e			;test3:     	db ": bb 77 ;",0 
5b7e			;test4:     	db "$02 $01 do i . loop bb",0 
5b7e			 
5b7e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5bb6 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5bee .. 00		test7:     	db ": box hline vline ;",0 
5c02 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5c2e .. 00		test9:     	db ": sw $01 adsp world ;",0 
5c44 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5c69			;test11:     	db "hello create .",0 
5c69			;test12:     	db "hello2 create .",0 
5c69			 
5c69			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5c69			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5c69			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5c69			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5c69			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5c69			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5c69			 
5c69			;iftest1:     	db "$0001 IF cls .",0 
5c69			;iftest2:     	db "$0000 IF cls .",0 
5c69			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5c69			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5c69			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5c69			 
5c69			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c69			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c69			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c69			 
5c69			 
5c69 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5c8d .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5cbd .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5ce2 .. 00		sound4: db ": cha $00 ; ",0 
5cef .. 00		sound5: db ": chb $20 ; ",0 
5cfc .. 00		sound6: db ": chc $40 ; ",0 
5d09 .. 00		sound7: db ": chd $60 ; ",0 
5d16 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5d2e .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5d45			 
5d45			 
5d45			 
5d45			 
5d45			; a small guess the number game 
5d45			 
5d45 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5d56 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5db8			 
5db8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ded .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5e23 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5e54 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5e68 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5e7d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5eb1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5ef5			 
5ef5			; Using 'ga' save a high score across multiple runs using external storage 
5ef5			 
5ef5 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5f5e			 
5f5e			 
5f5e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5f5e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f5e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f5e			 
5f5e			; simple screen saver to test code memory reuse to destruction 
5f5e			 
5f5e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5f94 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5fb0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5fcc .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5fe5 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
602d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6084			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6084			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6084			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6084			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6084			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6084			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6084			 
6084			 
6084			 
6084			; minesweeper/battleship finding game 
6084			; draws a game board of random ship/mine positions 
6084			; user enters coords to see if it hits on 
6084			; game ends when all are hit 
6084			; when hit or miss says how many may be in the area 
6084			 
6084			; setup the game board and then hide it 
6084			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6084			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6084			;; prompt for where to target 
6084			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6084			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6084			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6084			;game2mbht:      db ": mbckht nop ;",0 
6084			;game2mbms:      db ": mbcms nop ;",0 
6084			; TODO how many might be near by 
6084			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6084			 
6084			; Game 3 
6084			 
6084			; Vert scroller ski game - avoid the trees! 
6084			 
6084			; v0 score (ie turns) 
6084			; v1 player pos 
6084			; v2 left wall 
6084			; v3 right wall 
6084			 
6084			; Draw side walls randomly 
6084			 
6084			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6084			 
6084			; Draw player 
6084			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6084			 
6084			; TODO Get Key 
6084			 
6084			; TODO Move left right 
6084			 
6084			; scroll and move walls a bit 
6084			 
6084			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6084			 
6084			; main game loop 
6084			 
6084			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6084			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6084			 
6084			; key board defs 
6084			 
6084 .. 00		keyup:       db ": keyup $05 ;",0 
6092 .. 00		keydown:       db ": keydown $0a ;",0 
60a2 .. 00		keyleft:       db ": keyleft $0b ;",0 
60b2 .. 00		keyright:       db ": keyright $0c ;",0 
60c3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60d1 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60df .. 00		keyf3:       db ": keyf3 $12 ;",0 
60ed .. 00		keyf4:       db ": keyf4 $13 ;",0 
60fb .. 00		keyf5:       db ": keyf5 $14 ;",0 
6109 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6117 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6125 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6133 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6141 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6150 .. 00		keyf11:       db ": keyf11 $1a ;",0 
615f .. 00		keyf12:       db ": keyf12 $1b ;",0 
616e			 
616e .. 00		keytab:       db ": keytab $09 ;",0 
617d .. 00		keycr:       db ": keycr $0d ;",0 
618b .. 00		keyhome:       db ": keyhome $0e ;",0 
619b .. 00		keyend:       db ": keyend $0f ;",0 
61aa .. 00		keybs:       db ": keybs $08 ;",0 
61b8			 
61b8			   
61b8			 
61b8			 
61b8			 
61b8			; eof 
# End of file forth_autostart.asm
61b8			 
61b8			 
61b8			 
61b8			; stack over and underflow checks 
61b8			 
61b8			; init the words to detect the under/overflow 
61b8			 
61b8			chk_stk_init: 
61b8				; a vague random number to check so we dont get any "lucky" hits 
61b8 3e 2d			ld a, 45 
61ba 6f				ld l, a 
61bb 00				nop 
61bc 3e 17			ld a, 23 
61be 67				ld h, a 
61bf			 
61bf 22 94 e2			ld (chk_word), hl     ; the word we need to check against 
61c2			 
61c2			;	ld (chk_stund), hl	; stack points.... 
61c2 22 00 ef			ld (chk_stovr), hl 
61c5 22 e3 e9			ld (chk_ret_und), hl 
61c8 22 a1 e9			ld (chk_ret_ovr), hl 
61cb 22 1f e9			ld (chk_loop_ovr), hl 
61ce 22 1d e8			ld (chk_data_ovr), hl 
61d1 c9				ret 
61d2				 
61d2			check_stacks: 
61d2				; check all stack words 
61d2			 
61d2 e5				push hl 
61d3 d5				push de 
61d4			 
61d4			;	ld de,(chk_word) 
61d4			;	ld hl, (chk_stund)	; stack points.... 
61d4			;	if DEBUG_STK_FAULT 
61d4			;		DMARK "FAa" 
61d4			;		CALLMONITOR 
61d4			;	endif 
61d4			;	call cmp16 
61d4			;	jp z, .chk_faulta 
61d4			; 
61d4			;	ld de, sfaultsu 
61d4			;	jp .chk_fault 
61d4			 
61d4 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61d7 ed 5b 94 e2		ld de,(chk_word) 
61db				if DEBUG_STK_FAULT 
61db					DMARK "FAb" 
61db					CALLMONITOR 
61db				endif 
61db cd ff 0d			call cmp16 
61de 28 06			jr z, .chk_fault1 
61e0 11 84 62			ld de, sfaultso 
61e3 c3 35 62			jp .chk_fault 
61e6			.chk_fault1:  
61e6 2a e3 e9			ld hl, (chk_ret_und) 
61e9 ed 5b 94 e2		ld de,(chk_word) 
61ed				if DEBUG_STK_FAULT 
61ed					DMARK "FAU" 
61ed					CALLMONITOR 
61ed				endif 
61ed cd ff 0d			call cmp16 
61f0 ca f9 61			jp z, .chk_fault2 
61f3 11 94 62			ld de, sfaultru 
61f6 c3 35 62			jp .chk_fault 
61f9			.chk_fault2:  
61f9 2a a1 e9			ld hl, (chk_ret_ovr) 
61fc ed 5b 94 e2		ld de,(chk_word) 
6200				if DEBUG_STK_FAULT 
6200					DMARK "FA1" 
6200					CALLMONITOR 
6200				endif 
6200 cd ff 0d			call cmp16 
6203 ca 0c 62			jp z, .chk_fault3 
6206 11 a2 62			ld de, sfaultro 
6209 c3 35 62			jp .chk_fault 
620c			.chk_fault3:  
620c 2a 1f e9			ld hl, (chk_loop_ovr) 
620f ed 5b 94 e2		ld de,(chk_word) 
6213				if DEBUG_STK_FAULT 
6213					DMARK "FA2" 
6213					CALLMONITOR 
6213				endif 
6213 cd ff 0d			call cmp16 
6216 ca 1f 62			jp z, .chk_fault4 
6219 11 bc 62			ld de, sfaultlo 
621c c3 35 62			jp .chk_fault 
621f			.chk_fault4:  
621f 2a 1d e8			ld hl, (chk_data_ovr) 
6222 ed 5b 94 e2		ld de,(chk_word) 
6226				if DEBUG_STK_FAULT 
6226					DMARK "FA3" 
6226					CALLMONITOR 
6226				endif 
6226 cd ff 0d			call cmp16 
6229 ca 32 62			jp z, .chk_fault5 
622c 11 d6 62			ld de, sfaultdo 
622f c3 35 62			jp .chk_fault 
6232			 
6232			 
6232			.chk_fault5:  
6232 d1				pop de 
6233 e1				pop hl 
6234			 
6234 c9				ret 
6235			 
6235 cd b7 0b		.chk_fault: 	call clear_display 
6238 3e 28				ld a, display_row_2 
623a cd c9 0b				call str_at_display 
623d 11 66 62				   ld de, .stackfault 
6240 3e 00				ld a, display_row_1 
6242 cd c9 0b				call str_at_display 
6245 11 62 ee				    ld de, debug_mark 
6248 3e 11				ld a, display_row_1+17 
624a cd c9 0b				call str_at_display 
624d cd d9 0b				call update_display 
6250			 
6250				; prompt before entering montior for investigating issue 
6250			 
6250 3e 78			ld a, display_row_4 
6252 11 b8 17			ld de, endprog 
6255			 
6255 cd d9 0b			call update_display		 
6258			 
6258 cd 4e 1a			call next_page_prompt 
625b			 
625b d1				pop de 
625c e1				pop hl 
625d cd 0c 18				call monitor 
6260 cd 5f 1e				call forth_warmstart 
6263 c3 0a 17				jp warmstart_afterauto 
6266					;jp 0 
6266					;halt 
6266			 
6266			 
6266			 
6266 .. 00		.stackfault: 	db "Stack fault:",0 
6273			 
6273 .. 00		sfaultsu: 	db	"Stack under flow",0 
6284 .. 00		sfaultso: 	db	"Stack over flow",0 
6294 .. 00		sfaultru:	db "RTS underflow",0 
62a2 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
62bc .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62d6 .. 00		sfaultdo:	db "DTS overflow", 0 
62e3			 
62e3			 
62e3			fault_dsp_under: 
62e3 11 f5 62			ld de, .dsp_under 
62e6 c3 ab 63			jp .show_fault 
62e9			 
62e9			fault_rsp_under: 
62e9 11 03 63			ld de, .rsp_under 
62ec c3 ab 63			jp .show_fault 
62ef			fault_loop_under: 
62ef 11 11 63			ld de, .loop_under 
62f2 c3 ab 63			jp .show_fault 
62f5			 
62f5 .. 00		.dsp_under: db "DSP Underflow",0 
6303 .. 00		.rsp_under: db "RSP Underflow",0 
6311 .. 00		.loop_under: db "LOOP Underflow",0 
6320			 
6320			 
6320 d5			type_faultn: 	push de 
6321 e5					push hl 
6322 cd b7 0b				call clear_display 
6325 11 4f 63				   ld de, .typefaultn 
6328 3e 00				ld a, display_row_1 
632a cd c9 0b				call str_at_display 
632d 11 62 ee				    ld de, debug_mark 
6330 3e 11				ld a, display_row_1+17 
6332 cd c9 0b				call str_at_display 
6335 cd d9 0b				call update_display 
6338			 
6338				; prompt before entering montior for investigating issue 
6338			 
6338 3e 78			ld a, display_row_4 
633a 11 b8 17			ld de, endprog 
633d			 
633d cd d9 0b			call update_display		 
6340			 
6340 cd 4e 1a			call next_page_prompt 
6343			 
6343 e5					push hl 
6344 d5					push de 
6345 cd 0c 18				call monitor 
6348 cd 5f 1e				call forth_warmstart 
634b c3 0a 17				jp warmstart_afterauto 
634e 76					halt 
634f			 
634f			 
634f .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6366			 
6366 d5			type_faults: 	push de 
6367 e5					push hl 
6368 cd b7 0b				call clear_display 
636b 11 94 63				   ld de, .typefaults 
636e 3e 00				ld a, display_row_1 
6370 cd c9 0b				call str_at_display 
6373 11 62 ee				    ld de, debug_mark 
6376 3e 11				ld a, display_row_1+17 
6378 cd c9 0b				call str_at_display 
637b cd d9 0b				call update_display 
637e			 
637e				; prompt before entering montior for investigating issue 
637e			 
637e 3e 78			ld a, display_row_4 
6380 11 b8 17			ld de, endprog 
6383			 
6383 cd d9 0b			call update_display		 
6386			 
6386 cd 4e 1a			call next_page_prompt 
6389			 
6389 e1					pop hl 
638a d1					pop de 
638b cd 0c 18				call monitor 
638e cd 5f 1e				call forth_warmstart 
6391 c3 0a 17				jp warmstart_afterauto 
6394			 
6394			 
6394 .. 00		.typefaults: db "STR Type Expected TOS!",0 
63ab			 
63ab			.show_fault: 	 
63ab d5					push de 
63ac cd b7 0b				call clear_display 
63af d1					pop de 
63b0 3e 00				ld a, display_row_1 
63b2 cd c9 0b				call str_at_display 
63b5 11 62 ee				    ld de, debug_mark 
63b8 3e 11				ld a, display_row_1+17 
63ba cd c9 0b				call str_at_display 
63bd cd d9 0b				call update_display 
63c0			 
63c0				; prompt before entering montior for investigating issue 
63c0			 
63c0 3e 78			ld a, display_row_4 
63c2 11 b8 17			ld de, endprog 
63c5			 
63c5 cd d9 0b			call update_display		 
63c8			 
63c8 cd 4e 1a			call next_page_prompt 
63cb			 
63cb e1					pop hl 
63cc d1					pop de 
63cd cd 0c 18				call monitor 
63d0			; do a dump to cli and not warmstart so we preserve all of the uwords.  
63d0			; TODO Make optional fault restart to cli or warm boot? 
63d0					;jp warmstart 
63d0 c3 4d 17				jp cli 
63d3 76					halt 
63d4			 
63d4			 
63d4			; handle the auto run of code from files in storage 
63d4			 
63d4			 
63d4			include "forth_startup.asm" 
63d4			; Which startup method to use? 
63d4			; 
63d4			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
63d4			; followed by loading of a list of scripts in eeprom 
63d4			 
63d4			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
63d4			; from eeprom 
63d4			 
63d4			; Select with define in main stubs 
63d4			 
63d4			if STARTUP_V1 
63d4				include "forth_startupv1.asm" 
63d4			; Startup script loading version 1 
63d4			 
63d4			; If SE storage is available first stage is to use the selected file 
63d4			; then go through the eeprom list 
63d4			 
63d4 .. 00		sprompt1: db "Startup load...",0 
63e4 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63fa			 
63fa			 
63fa			 
63fa			 
63fa			forth_startup: 
63fa 21 29 55			ld hl, startcmds 
63fd 3e 00			ld a, 0 
63ff 32 de e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6402			 
6402 e5			.start1:	push hl 
6403 cd b7 0b			call clear_display 
6406 11 d4 63			ld de, sprompt1 
6409 3e 00		        ld a, display_row_1 
640b cd c9 0b			call str_at_display 
640e 11 e4 63			ld de, sprompt2 
6411 3e 28		        ld a, display_row_2 
6413 cd c9 0b			call str_at_display 
6416 e1				pop hl 
6417 e5				push hl 
6418 5e				ld e,(hl) 
6419 23				inc hl 
641a 56				ld d,(hl) 
641b 3e 50		        ld a, display_row_3 
641d cd c9 0b			call str_at_display 
6420 cd d9 0b			call update_display 
6423			 
6423			 
6423 3a de e6			ld a, (os_last_cmd) 
6426 fe 00			cp 0 
6428 28 05			jr z, .startprompt 
642a cd e4 0a			call delay250ms 
642d 18 24			jr .startdo 
642f				 
642f				 
642f			 
642f			.startprompt: 
642f			 
642f 3e 9f			ld a,display_row_4 + display_cols - 1 
6431 11 4c 1a		        ld de, endprg 
6434 cd c9 0b			call str_at_display 
6437 cd d9 0b			call update_display 
643a cd f0 0a			call delay1s 
643d cd ac 65			call cin_wait 
6440						 
6440 fe 2a			cp '*' 
6442 28 5e			jr z, .startupend1 
6444 fe 23			cp '#' 
6446 20 07			jr nz, .startno 
6448 3e 01			ld a, 1 
644a 32 de e6			ld (os_last_cmd),a 
644d 18 04			jr .startdo 
644f fe 31		.startno:	cp '1' 
6451 28 3a			jr z,.startnxt  
6453			 
6453				; exec startup line 
6453			.startdo:	 
6453 e1				pop hl 
6454 e5				push hl 
6455				 
6455 5e				ld e,(hl) 
6456 23				inc hl 
6457 56				ld d,(hl) 
6458 eb				ex de,hl 
6459			 
6459 e5				push hl 
645a			 
645a 3e 00			ld a, 0 
645c				;ld a, FORTH_END_BUFFER 
645c cd 44 11			call strlent 
645f 23				inc hl   ; include zero term to copy 
6460 06 00			ld b,0 
6462 4d				ld c,l 
6463 e1				pop hl 
6464 11 b8 e2			ld de, scratch 
6467 ed b0			ldir 
6469			 
6469			 
6469 21 b8 e2			ld hl, scratch 
646c cd ff 1e			call forthparse 
646f cd 37 1f			call forthexec 
6472 cd 59 1e			call forthexec_cleanup 
6475			 
6475 3e 78			ld a, display_row_4 
6477 11 b8 17			ld de, endprog 
647a			 
647a cd d9 0b			call update_display		 
647d			 
647d 3a de e6			ld a, (os_last_cmd) 
6480 fe 00			cp 0 
6482 20 09			jr nz, .startnxt 
6484 cd 4e 1a			call next_page_prompt 
6487 cd b7 0b		        call clear_display 
648a cd d9 0b			call update_display		 
648d			 
648d				; move onto next startup line? 
648d			.startnxt: 
648d			 
648d cd e4 0a			call delay250ms 
6490 e1				pop hl 
6491			 
6491 23				inc hl 
6492 23				inc hl 
6493			 
6493 e5				push hl 
6494 5e				ld e, (hl) 
6495 23				inc hl 
6496 56				ld d, (hl) 
6497 e1				pop hl 
6498				; TODO replace 0 test 
6498			 
6498 eb				ex de, hl 
6499 cd 0a 0e			call ishlzero 
649c			;	ld a,e 
649c			;	add d 
649c			;	cp 0    ; any left to do? 
649c eb				ex de, hl 
649d c2 02 64			jp nz, .start1 
64a0 18 01			jr .startupend 
64a2			 
64a2 e1			.startupend1: pop hl 
64a3			.startupend: 
64a3			 
64a3 cd b7 0b			call clear_display 
64a6 cd d9 0b			call update_display 
64a9 c9				ret 
64aa			if STORAGE_SE 
64aa			 
64aa			sprompt3: db "Loading from start-up file?:",0 
64aa			sprompt4: db "(Y=Any key/N=No)",0 
64aa			 
64aa			 
64aa			forth_autoload: 
64aa			 
64aa				; load block 0 of store 1 
64aa				 
64aa				ld a, $fe      ; bit 0 clear 
64aa				ld (spi_device), a 
64aa			 
64aa				call storage_get_block_0 
64aa			 
64aa				ld a, (store_page+STORE_0_AUTOFILE) 
64aa			 
64aa				cp 0 
64aa				ret z     ; auto start not enabled 
64aa			 
64aa				call clear_display 
64aa			 
64aa				; set bank 
64aa			 
64aa					ld a, (store_page+STORE_0_BANKRUN) 
64aa					ld (spi_device), a 
64aa			 
64aa				; get file id to load from and get the file name to display 
64aa			 
64aa					ld a, (store_page+STORE_0_FILERUN) 
64aa			 
64aa					ld l, 0 
64aa					ld h, a 
64aa					ld de, store_page 
64aa			 
64aa					if DEBUG_FORTH_WORDS 
64aa						DMARK "ASp" 
64aa						CALLMONITOR 
64aa					endif 
64aa					call storage_read 
64aa			 
64aa					if DEBUG_FORTH_WORDS 
64aa						DMARK "ASr" 
64aa						CALLMONITOR 
64aa					endif 
64aa			 
64aa					call ishlzero 
64aa					ret z             ; file not found 
64aa			 
64aa					ld a, display_row_2 + 10 
64aa					ld de, store_page+3 
64aa					call str_at_display 
64aa				 
64aa			; 
64aa			 
64aa				ld a, display_row_1+5 
64aa				ld de, sprompt3 
64aa				call str_at_display 
64aa				ld a, display_row_3+15 
64aa				ld de, sprompt4 
64aa				call str_at_display 
64aa			 
64aa				call update_display 
64aa			 
64aa				call cin_wait 
64aa				cp 'n' 
64aa				ret z 
64aa				cp 'N' 
64aa				ret z 
64aa			 
64aa				call delay1s 
64aa			 
64aa				ld a, (store_page+2) 
64aa				ld (store_openmaxext), a    ; save count of ext 
64aa				ld a, 1  
64aa				ld (store_openext), a    ; save count of ext 
64aa			 
64aa			.autof:  
64aa				ld l , a 
64aa				 
64aa				ld a, (store_page) 
64aa				ld h, a	 
64aa				ld de, store_page 
64aa					if DEBUG_FORTH_WORDS 
64aa						DMARK "ASl" 
64aa						CALLMONITOR 
64aa					endif 
64aa					call storage_read 
64aa				call ishlzero 
64aa				ret z 
64aa			;	jr z, .autoend 
64aa			 
64aa					if DEBUG_FORTH_WORDS 
64aa						DMARK "ASc" 
64aa						CALLMONITOR 
64aa					endif 
64aa				ld de, store_page+2 
64aa				ld a, display_row_4 
64aa				call str_at_display 
64aa			 
64aa				call update_display 
64aa				call delay250ms 
64aa			 
64aa			 
64aa			 
64aa				ld hl, store_page+2 
64aa				call forthparse 
64aa				call forthexec 
64aa				call forthexec_cleanup 
64aa			 
64aa				 
64aa				ld a, (store_openext) 
64aa				inc a 
64aa				ld (store_openext), a    ; save count of ext 
64aa			 
64aa				jr .autof 
64aa			;.autofdone: 
64aa			; 
64aa			;		if DEBUG_FORTH_WORDS 
64aa			;			DMARK "ASx" 
64aa			;			CALLMONITOR 
64aa			;		endif 
64aa			;;	call clear_display 
64aa			;	ret 
64aa			 
64aa			 
64aa			 
64aa			endif 
# End of file forth_startupv1.asm
64aa			endif 
64aa			if STARTUP_V2 
64aa				include "forth_startupv2.asm" 
64aa			endif 
64aa			 
# End of file forth_startup.asm
64aa			 
64aa			; eof 
# End of file forth_kernel.asm
64aa			;include "nascombasic.asm" 
64aa			 
64aa			 
64aa			; find out where the code ends if loaded into RAM (for SC114) 
64aa			;endofcode:  
64aa			;	nop 
64aa			 
64aa			 
64aa			; jump to nmi vector 
64aa			 
64aa			init_nmi: 
64aa 3e c9			ld a, $c9   ; RET 
64ac 32 72 ee			ld (nmi_vector), a 
64af c9				ret 
64b0			nmi: 
64b0 e5				push hl 
64b1 d5				push de 
64b2 c5				push bc 
64b3 f5				push af 
64b4 cd 72 ee			call nmi_vector 
64b7 f5				push af 
64b8 c5				push bc 
64b9 d5				push de 
64ba e5				push hl 
64bb ed 4d			reti 
64bd			 
64bd			 
64bd			; eof 
64bd			 
# End of file main.asm
64bd			;include "firmware_lcd_4x40.asm" 
64bd			;;include "firmware_lcd_4x20.asm" 
64bd			include "firmware_cpm_display.asm" 
64bd			 
64bd			; Serial display interface for SC114 
64bd			 
64bd			 
64bd			display_row_1: equ 0 
64bd			display_row_2: equ display_row_1+display_cols 
64bd			display_row_3: equ display_row_2 + display_cols 
64bd			display_row_4: equ display_row_3 + display_cols 
64bd			 
64bd			kLCDWidth:  EQU display_cols             ;Width in characters 
64bd			kLCD_Line1: EQU 0x00  
64bd			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
64bd			; E1 
64bd			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
64bd			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
64bd			 
64bd			lcd_init: 
64bd				; no init as handled by the SCM bios 
64bd c9				ret 
64be			 
64be			 
64be			; low level functions for direct screen writes 
64be			 
64be			; output char at pos? 
64be			fLCD_Str: 
64be			        ;out (SC114_SIO_1_OUT),a 
64be c5				push bc 
64bf d5				push de 
64c0 5f				ld e, a 
64c1			; TODO Replace with CP/M BIOS call 
64c1 0e 02			ld c, $02 
64c3 cd 05 00			call 5 
64c6 d1				pop de 
64c7 c1				pop bc 
64c8 c9				ret 
64c9			 
64c9			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
64c9			fLCD_Pos: 
64c9				; use ASCII escape to position 
64c9			        ;out (SC114_SIO_1_OUT),a 
64c9 c5				push bc 
64ca d5				push de 
64cb 5f				ld e, a 
64cc 0e 02			ld c, $02 
64ce			; TODO Replace with CP/M BIOS call 
64ce cd 05 00			call 5 
64d1 d1				pop de 
64d2 c1				pop bc 
64d3			 
64d3 c9				ret 
64d4			 
64d4			; output char at pos 
64d4			fLCD_Data: 
64d4			      ;  out (SC114_SIO_1_OUT),a 
64d4 c5				push bc 
64d5 d5				push de 
64d6 0e 02			ld c, $02 
64d8 5f				ld e, a 
64d9			; TODO Replace with CP/M BIOS call 
64d9 cd 05 00			call 5 
64dc d1				pop de 
64dd c1				pop bc 
64de			 
64de c9				ret 
64df			 
64df			; ascii cls  
64df			 
64df 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64e3			 
64e3 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
64fa			;.clscpm: db 3, $3c,"$" 
64fa			 
64fa			; write the frame buffer given in hl to hardware  
64fa			write_display: 
64fa			 
64fa			API: equ 0 
64fa			 
64fa			if API 
64fa				push bc 
64fa				ld b, 4 
64fa			 
64fa			        ld (display_write_tmp), hl 	  
64fa			 
64fa				; clear and home cursor 
64fa			 
64fa				ld c, 9 
64fa				ld de, .cls 
64fa			; TODO Replace with CP/M BIOS call 
64fa				call 5 
64fa			 
64fa			 
64fa			.writeln: 
64fa			 
64fa				ld de, (display_write_tmp) 
64fa				ld c, 6 
64fa			; TODO Replace with CP/M BIOS call 
64fa				rst $30 
64fa				ld c, 7 
64fa				rst $30 
64fa			 
64fa				ld hl, (display_write_tmp) 
64fa				ld de, display_cols 
64fa				add hl,de 
64fa				ld (display_write_tmp),hl 
64fa			 
64fa				djnz  .writeln 
64fa			 
64fa				pop bc 
64fa			 
64fa			 
64fa				ret 
64fa			endif 
64fa e5				push hl 
64fb c5				push bc 
64fc d5				push de 
64fd			 
64fd			;	ld c, 2 
64fd			;	;ld de, .cls 
64fd			;	ld a, 27 
64fd			;	rst $30 
64fd			;	ld c, 2 
64fd			;	;ld de, .cls 
64fd			;	ld a, '[' 
64fd			;	rst $30 
64fd			; 
64fd			;	ld c, 2 
64fd			;	;ld de, .cls 
64fd			;	ld a, 'H' 
64fd			;	rst $30 
64fd			; 
64fd			 
64fd			 
64fd			; lots of CR/LF 
64fd			;	ld c, 9 
64fd			;	ld de, .clscpm 
64fd			;	call 5 
64fd			 
64fd			; xterm cls 
64fd 0e 02			ld c, 2 
64ff 1e 1b			ld e, 27 
6501 cd 05 00			call 5 
6504			; cls causes too much flicker 
6504			;	ld c, 2 
6504			;	ld e, 'c' 
6504			;	call 5 
6504			 
6504			; use xterm home instead 
6504 0e 02			ld c, 2 
6506 1e 5b			ld e, '[' 
6508 cd 05 00			call 5 
650b 0e 02			ld c, 2 
650d 1e 48			ld e, 'H' 
650f cd 05 00			call 5 
6512			LLL: equ 0 
6512			 
6512			if LLL 
6512			 
6512				ld c, 2 
6512				;ld de, .cls 
6512				ld e, 27 
6512			; TODO Replace with CP/M BIOS call 
6512				call 5 
6512			 
6512			 
6512				ld c, 2 
6512				;ld de, .cls 
6512				ld e, '[' 
6512			; TODO Replace with CP/M BIOS call 
6512				call 5 
6512				ld c, 2 
6512				;ld de, .cls 
6512				ld e, '2' 
6512			; TODO Replace with CP/M BIOS call 
6512				call 5 
6512				ld c, 2 
6512				;ld de, .cls 
6512				ld e, 'J' 
6512			; TODO Replace with CP/M BIOS call 
6512				call 5 
6512			 
6512			endif 
6512			 
6512 d1				pop de 
6513 c1				pop bc 
6514 e1				pop hl 
6515			 
6515			 
6515 22 c0 eb		        ld (display_write_tmp), hl 	  
6518 3e 00			ld a, kLCD_Line1 
651a			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
651a 06 28			ld b, display_cols 
651c ed 5b c0 eb		ld de, (display_write_tmp) 
6520 cd a3 65			call write_len_string 
6523				 
6523			 
6523 e5			push hl 
6524 d5			push de 
6525 c5			push bc 
6526 0e 02			ld c, 2 
6528 1e 0a			ld e, 10 
652a cd 05 00			call 5 
652d 0e 02			ld c, 2 
652f 1e 0d			ld e, 13 
6531 cd 05 00			call 5 
6534			; TODO Replace with CP/M BIOS call 
6534				;rst $30 
6534 c1			pop bc 
6535 d1			pop de 
6536 e1			pop hl 
6537			 
6537				 
6537 2a c0 eb			ld hl, (display_write_tmp) 
653a 11 28 00			ld de, display_cols 
653d 19				add hl,de 
653e 22 c0 eb			ld (display_write_tmp),hl 
6541			 
6541				 
6541 3e 28			ld a, kLCD_Line2 
6543			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6543 06 28			ld b, display_cols 
6545 ed 5b c0 eb		ld de, (display_write_tmp) 
6549 cd a3 65			call write_len_string 
654c				 
654c 2a c0 eb			ld hl, (display_write_tmp) 
654f 11 28 00			ld de, display_cols 
6552 19				add hl,de 
6553 22 c0 eb			ld (display_write_tmp),hl 
6556			 
6556 e5			push hl 
6557 d5			push de 
6558 c5			push bc 
6559 0e 07			ld c, 7 
655b			; TODO Replace with CP/M BIOS call 
655b				;rst $30 
655b 0e 02			ld c, 2 
655d 1e 0a			ld e, 10 
655f cd 05 00			call 5 
6562 0e 02			ld c, 2 
6564 1e 0d			ld e, 13 
6566 cd 05 00			call 5 
6569 c1			pop bc 
656a d1			pop de 
656b e1			pop hl 
656c			 
656c				 
656c 3e 50			ld a, kLCD_Line3 
656e			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
656e 06 28			ld b, display_cols 
6570 ed 5b c0 eb		ld de, (display_write_tmp) 
6574 cd a3 65			call write_len_string 
6577				 
6577 2a c0 eb			ld hl, (display_write_tmp) 
657a 11 28 00			ld de, display_cols 
657d 19				add hl,de 
657e 22 c0 eb			ld (display_write_tmp),hl 
6581			 
6581 e5			push hl 
6582 d5			push de 
6583 c5			push bc 
6584 0e 07			ld c, 7 
6586			; TODO Replace with CP/M BIOS call 
6586				;rst $30 
6586 0e 02			ld c, 2 
6588 1e 0a			ld e, 10 
658a cd 05 00			call 5 
658d 0e 02			ld c, 2 
658f 1e 0d			ld e, 13 
6591 cd 05 00			call 5 
6594 c1			pop bc 
6595 d1			pop de 
6596 e1			pop hl 
6597			 
6597				 
6597 3e 78			ld a, kLCD_Line4 
6599			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
6599 06 28			ld b, display_cols 
659b ed 5b c0 eb		ld de, (display_write_tmp) 
659f cd a3 65			call write_len_string 
65a2 c9					ret 
65a3			 
65a3			 
65a3				; write out a fixed length string given in b from de 
65a3			 
65a3 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
65a4 cd d4 64		            CALL fLCD_Data      ;Write character to display 
65a7 13				inc de 
65a8 10 f9			djnz write_len_string 
65aa c9				ret 
65ab			 
65ab			 
65ab			; eof 
# End of file firmware_cpm_display.asm
65ab			;include "firmware_key_5x10.asm" 
65ab			;;include "firmware_key_4x10.asm" 
65ab			include "firmware_key_cpm.asm" 
65ab			; Serial keyboard interface for SC114 
65ab			 
65ab			 
65ab			key_init: 
65ab				; no init as handled by the SCM bios 
65ab c9				ret 
65ac			 
65ac			 
65ac			cin_wait: 
65ac			;	ld a, 0 
65ac			;	ret 
65ac			 
65ac				;in a,(SC114_SIO_1_IN) 
65ac			        ; Use SCM API to get from whatever console device we are using 
65ac			 
65ac			; TODO Replace with CP/M BIOS call 
65ac c5				push bc 
65ad 0e 01			ld c, $01 
65af cd 05 00			call 5 
65b2 c1				pop bc 
65b3 c9				ret 
65b4			 
65b4			cinndb:  
65b4			cin: 
65b4			 
65b4			 
65b4 c5				push bc 
65b5			 
65b5				; any key waiting to process? 
65b5			; TODO Replace with CP/M BIOS call 
65b5 0e 06			ld c, $06 
65b7 cd 05 00			call 5 
65ba 28 0d			jr z, .cin_skip 
65bc			 
65bc				; yep, get it 
65bc			 
65bc 0e 01			ld c, $01 
65be			; TODO Replace with CP/M BIOS call 
65be cd 05 00			call 5 
65c1			 
65c1 fe 7f			cp $7f     ; back space 
65c3 20 02			jr nz, .skipbs 
65c5 3e 08			ld a, KEY_BS 
65c7			.skipbs: 
65c7			 
65c7 c1				pop bc 
65c8 c9				ret 
65c9			.cin_skip: 
65c9 3e 00			ld a, 0 
65cb c1				pop bc 
65cc c9				ret 
65cd			 
65cd			 
65cd			 
65cd			 
# End of file firmware_key_cpm.asm
65cd			endofcode:  
65cd			baseram:  
65cd 00				nop 
65ce			 
65ce			heap_start: equ baseram+15  ; Starting address of heap 
65ce			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
65ce			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
65ce			;VDU:  EQU     endofcode           ; BASIC Work space 
65ce			; eof 
65ce			 
# End of file os_mega_cpm.asm
65ce
