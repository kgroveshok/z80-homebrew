# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 40 1a			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		.buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd c2 0b				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd c2 0b				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd c2 0b				call clear_display  
0037			  
0037			  
0037 cd dd 67				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 74 6a			call key_init  
003d cd bb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 99 12				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd 56 14				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd e5 0b			call update_display  
0049 cd 3f 0b			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd c7 0b			call fill_display  
0051 cd e5 0b			call update_display  
0054 cd 3f 0b			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd c7 0b			call fill_display  
005c cd e5 0b			call update_display  
005f cd 3f 0b			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd c7 0b			call fill_display  
0067 cd e5 0b			call update_display  
006a cd 3f 0b			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 73 19			ld de, prom_bootmsg  
0072 cd d5 0b			call str_at_display  
0075 cd e5 0b			call update_display  
0078			  
0078			  
0078 cd 3f 0b			call delay1s  
007b cd 3f 0b			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 88 19			ld de, prom_bootmsg1  
0083 cd d5 0b			call str_at_display  
0086 cd e5 0b			call update_display  
0089 cd 3f 0b			call delay1s  
008c cd 3f 0b			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			 
00a0			; TODO store port id for spi device ie dev c 
00a0			; TODO store pin for SO 
00a0			; TODO store pin for SI 
00a0			; TODO store pin for SCLK 
00a0			 
00a0			; 
00a0			 
00a0			; ensure that spi bus is in a stable state with default pins  
00a0			 
00a0			se_stable_spi:   
00a0			 
00a0				 ; set DI high, CE high , SCLK low 
00a0				;ld a, SPI_DI | SPI_CE0 
00a0 3e 07			ld a, SPI_DI  
00a2 cd 76 01			call spi_ce_high 
00a5 d3 80			 out (storage_adata),a 
00a7 32 40 fb			ld (spi_portbyte),a 
00aa			 
00aa				if DEBUG_SPI 
00aa					push hl 
00aa					ld l, a 
00aa					DMARK "SPI" 
00aa					CALLMONITOR 
00aa					pop hl 
00aa				endif 
00aa c9				ret 
00ab			 
00ab			; byte to send in a 
00ab			 
00ab			spi_send_byte: 
00ab				; save byte to send for bit mask shift out 
00ab 4f			        ld c,a 
00ac 3a 40 fb			ld a,(spi_portbyte) 
00af				  
00af				; clock out	each bit of the byte msb first 
00af			 
00af 06 08			ld b, 8 
00b1			.ssb1: 
00b1				; clear so bit  
00b1 cb bf			res SPI_DI, a 
00b3 cb 11			rl c 
00b5				; if bit 7 is set then carry is set 
00b5 30 02			jr nc, .ssb2 
00b7 cb ff			set SPI_DI,a 
00b9			.ssb2:  ; output bit to ensure it is stable 
00b9 d3 80			out (storage_adata),a 
00bb 00				nop 
00bc				; clock bit high 
00bc cb ef			set SPI_SCLK,a 
00be d3 80			out (storage_adata),a 
00c0 00				nop 
00c1				; then low 
00c1 cb af			res SPI_SCLK,a 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6 10 e9			djnz .ssb1 
00c8			 
00c8 32 40 fb			ld (spi_portbyte),a 
00cb c9				ret 
00cc			 
00cc			; TODO low level get byte into A on spi 
00cc			 
00cc			spi_read_byte:  
00cc			 
00cc				; save byte to send for bit mask shift out 
00cc 0e 00		    ld c,0 
00ce 3a 40 fb			ld a,(spi_portbyte) 
00d1				  
00d1				; clock out	each bit of the byte msb first 
00d1			 
00d1			 
00d1				; clock bit high 
00d1 cb ef			set SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6			 
00d6			    ; read DO  
00d6			 
00d6 cb f9		    set 7,c 
00d8 db 80			in a,(storage_adata) 
00da cb 77		    bit SPI_DO,a 
00dc 20 02		    jr nz, .b7 
00de cb b9		    res 7,c 
00e0			.b7: 
00e0				; then low 
00e0 cb af			res SPI_SCLK,a 
00e2 d3 80			out (storage_adata),a 
00e4 00				nop 
00e5			     
00e5			 
00e5				; clock bit high 
00e5 cb ef			set SPI_SCLK,a 
00e7 d3 80			out (storage_adata),a 
00e9 00				nop 
00ea			 
00ea			    ; read DO  
00ea			 
00ea cb f1		    set 6,c 
00ec db 80			in a,(storage_adata) 
00ee cb 77		    bit SPI_DO,a 
00f0 20 02		    jr nz, .b6 
00f2 cb b1		    res 6,c 
00f4			.b6: 
00f4				; then low 
00f4 cb af			res SPI_SCLK,a 
00f6 d3 80			out (storage_adata),a 
00f8 00				nop 
00f9			 
00f9				; clock bit high 
00f9 cb ef			set SPI_SCLK,a 
00fb d3 80			out (storage_adata),a 
00fd 00				nop 
00fe			 
00fe			 
00fe			    ; read DO  
00fe			 
00fe cb e9		    set 5,c 
0100 db 80			in a,(storage_adata) 
0102 cb 77		    bit SPI_DO,a 
0104 20 02		    jr nz, .b5 
0106 cb a9		    res 5,c 
0108			.b5: 
0108				; then low 
0108 cb af			res SPI_SCLK,a 
010a d3 80			out (storage_adata),a 
010c 00				nop 
010d				; clock bit high 
010d cb ef			set SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112			 
0112			    ; read DO  
0112			 
0112 cb e1		    set 4,c 
0114 db 80			in a,(storage_adata) 
0116 cb 77		    bit SPI_DO,a 
0118 20 02		    jr nz, .b4 
011a cb a1		    res 4,c 
011c			.b4: 
011c				; then low 
011c cb af			res SPI_SCLK,a 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126			 
0126			    ; read DO  
0126			 
0126 cb d9		    set 3,c 
0128 db 80			in a,(storage_adata) 
012a cb 77		    bit SPI_DO,a 
012c 20 02		    jr nz, .b3 
012e cb 99		    res 3,c 
0130			.b3: 
0130				; then low 
0130 cb af			res SPI_SCLK,a 
0132 d3 80			out (storage_adata),a 
0134 00				nop 
0135				; clock bit high 
0135 cb ef			set SPI_SCLK,a 
0137 d3 80			out (storage_adata),a 
0139 00				nop 
013a			 
013a			    ; read DO  
013a			 
013a cb d1		    set 2,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b2 
0142 cb 91		    res 2,c 
0144			.b2: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e			 
014e			    ; read DO  
014e			 
014e cb c9		    set 1,c 
0150 db 80			in a,(storage_adata) 
0152 cb 77		    bit SPI_DO,a 
0154 20 02		    jr nz, .b1 
0156 cb 89		    res 1,c 
0158			.b1: 
0158				; then low 
0158 cb af			res SPI_SCLK,a 
015a d3 80			out (storage_adata),a 
015c 00				nop 
015d				; clock bit high 
015d cb ef			set SPI_SCLK,a 
015f d3 80			out (storage_adata),a 
0161 00				nop 
0162			 
0162			    ; read DO  
0162			 
0162 cb c1		    set 0,c 
0164 db 80			in a,(storage_adata) 
0166 cb 77		    bit SPI_DO,a 
0168 20 02		    jr nz, .b0 
016a cb 81		    res 0,c 
016c			.b0: 
016c				; then low 
016c cb af			res SPI_SCLK,a 
016e d3 80			out (storage_adata),a 
0170 00				nop 
0171			 
0171			 
0171 32 40 fb			ld (spi_portbyte),a 
0174			 
0174			    ; return byte 
0174 79			    ld a,c 
0175			 
0175			 
0175 c9				ret 
0176			 
0176			 
0176			 
0176			spi_ce_high: 
0176			 
0176				if DEBUG_SPI_HARD_CE0 
0176			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0176					ret 
0176			 
0176				endif 
0176			 
0176			 
0176 f5				push af 
0177			 
0177				; send direct ce to port b 
0177 3e ff			ld a, 255 
0179 d3 81			out (storage_bdata), a 
017b			 
017b f1				pop af 
017c			 
017c				; for port a that shares with spi lines AND the mask 
017c			  
017c				if DEBUG_SPI 
017c					push hl 
017c					ld h, a 
017c				endif 
017c			;	ld c, SPI_CE_HIGH 
017c			;	and c 
017c cb c7			set SPI_CE0, a 
017e cb cf			set SPI_CE1, a 
0180 cb d7			set SPI_CE2, a 
0182 cb df			set SPI_CE3, a 
0184 cb e7			set SPI_CE4, a 
0186			 
0186				if DEBUG_SPI 
0186					ld l, a 
0186					DMARK "CEh" 
0186					CALLMONITOR 
0186					pop hl 
0186				endif 
0186 c9				ret 
0187			 
0187			 
0187			spi_ce_low: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187 c5				push bc 
0188 f5				push af 
0189			 
0189				; send direct ce to port b 
0189 3a 42 fb			ld a, (spi_cartdev) 
018c d3 81			out (storage_bdata), a 
018e			 
018e			 
018e			 
018e				; for port a that shares with spi lines AND the mask 
018e			 
018e 3a 3f fb			ld a, (spi_device)  
0191 4f				ld c, a 
0192			 
0192 f1				pop af 
0193			 
0193				; detect CEx 
0193			 
0193				if DEBUG_SPI 
0193					push hl 
0193					ld h, a 
0193				endif 
0193			 
0193 cb 41			bit SPI_CE0, c 
0195 20 04			jr nz, .cel1 
0197 cb 87			res SPI_CE0, a 
0199 18 1e			jr .celn 
019b			.cel1: 
019b cb 49			bit SPI_CE1, c 
019d 20 04			jr nz, .cel2 
019f cb 8f			res SPI_CE1, a 
01a1 18 16			jr .celn 
01a3			.cel2: 
01a3 cb 51			bit SPI_CE2, c 
01a5 20 04			jr nz, .cel3 
01a7 cb 97			res SPI_CE2, a 
01a9 18 0e			jr .celn 
01ab			.cel3: 
01ab cb 59			bit SPI_CE3, c 
01ad 20 04			jr nz, .cel4 
01af cb 9f			res SPI_CE3, a 
01b1 18 06			jr .celn 
01b3			.cel4: 
01b3 cb 61			bit SPI_CE4, c 
01b5 20 02			jr nz, .celn 
01b7 cb a7			res SPI_CE4, a 
01b9			.celn: 
01b9			 
01b9			 
01b9			 
01b9			;	add c 
01b9			 
01b9				if DEBUG_SPI 
01b9					ld l, a 
01b9					DMARK "CEl" 
01b9					CALLMONITOR 
01b9					pop hl 
01b9				endif 
01b9 c1				pop bc 
01ba c9				ret 
01bb			 
01bb			 
01bb			 
01bb			; eof 
01bb			 
01bb			 
01bb			 
01bb			 
01bb			 
# End of file firmware_spi.asm
01bb				include "firmware_seeprom.asm"  
01bb			; 
01bb			; persisent storage interface via microchip serial eeprom 
01bb			 
01bb			; port a pio 2 
01bb			; pa 7 - si 
01bb			; pa 6 - sclk  
01bb			; pa 5 - so 
01bb			; pa 4 - cs 
01bb			; pa 3 - cs 
01bb			; pa 2 - cs 
01bb			; pa 1 - cs 
01bb			; pa 0 - cs 
01bb			; 
01bb			; TODO get block 
01bb			; TODO save block 
01bb			; TODO load file 
01bb			; TODO save file 
01bb			; TODO get dir  
01bb			 
01bb			;  
01bb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01bb			storage_actl: equ Device_C+2     ; device c port a 
01bb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01bb			storage_bctl: equ Device_C+3     ; device c port b 
01bb			 
01bb			 
01bb			; TODO move these to hardware driver file 
01bb			 
01bb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01bb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01bb			; storage bank file system format 
01bb			; 
01bb			; first page of bank: 
01bb			; 	addr 0 - status check 
01bb			;       addr 1 - write protect flag 
01bb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01bb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01bb			;         TODO see if scanning whole of for available next file id is fast enough 
01bb			;	addr 4 > zero term string of bank label 
01bb			; 
01bb			;        
01bb			;  
01bb			; first page of any file: 
01bb			;      byte 0 - file id  
01bb			;      byte 1-17 - fixed file name  
01bb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01bb			; 
01bb			; other pages of any file: 
01bb			;      byte 0 - file id 
01bb			;      byte 1> - file data 
01bb			; 
01bb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01bb			;  
01bb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01bb			 
01bb			 
01bb			;storage_so_bit: 5 
01bb			;storage_si_bit: 7 
01bb			;storage_sclk_bit: 6 
01bb			  
01bb			 
01bb			; init storage pio 
01bb			 
01bb			storage_init: 
01bb			 
01bb 3e cf		            LD   A, 11001111b 
01bd d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bf 3e 00		            LD   A, 00000000b 
01c1 cb f7			set SPI_DO,a 
01c3			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c3 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c5			 
01c5 3e cf		            LD   A, 11001111b 
01c7 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c9 3e 00		            LD   A, 00000000b 
01cb d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01cd			 
01cd				; set all external spi devices off 
01cd 3e 00			ld a, 0 
01cf 32 3f fb			ld (spi_device), a 
01d2 32 42 fb			ld (spi_cartdev), a 
01d5			 
01d5					; ensure the spi bus is in a default stable state 
01d5 cd a0 00				call se_stable_spi 
01d8			 
01d8			; TODO scan spi bus and gather which storage banks are present 
01d8			 
01d8			; populate store_bank_active  
01d8			; for each ce line activate and attempt to write first byte of bank and read back 
01d8			; if zero is returned then bank is empty 
01d8			;   
01d8			; 
01d8			 
01d8					; init file extent cache to save on slow reads 
01d8			 
01d8			;	ld hl, store_filecache 
01d8			;	ld de, 0 
01d8			;	ld hl,(de)	 
01d8			 
01d8			 
01d8 c9			    ret 
01d9			 
01d9			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d9			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d9			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d9			 
01d9			; INSTRUCTION SET 
01d9			; READ 0000 0011 Read data from memory array beginning at selected address 
01d9			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d9			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d9			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d9			; RDSR 0000 0101 Read STATUS register 
01d9			; WRSR 0000 0001 Write STATUS register 
01d9			; PE 0100 0010 Page Erase – erase one page in memory array 
01d9			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d9			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d9			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d9			 
01d9			; TODO send byte steam for page without setting the address for every single byte 
01d9			; TODO read byte  
01d9			 
01d9			; byte in a 
01d9			; address in hl  
01d9			se_writebyte: 
01d9			        
01d9			    ;   ld c, a 
01d9 f5			        push af 
01da e5			        push hl 
01db			 
01db			    ; initi write mode 
01db			    ; 
01db			    ;CS low 
01db			 
01db 3a 40 fb		       ld a,(spi_portbyte) 
01de cd 87 01			call spi_ce_low 
01e1			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e1 d3 80		       out (storage_adata),a 
01e3 32 40 fb		       ld (spi_portbyte), a 
01e6			 
01e6			    ;clock out wren instruction 
01e6			 
01e6 3e 06		    ld a, store_wren_ins 
01e8 cd ab 00		    call spi_send_byte  
01eb			 
01eb			    ;cs high to enable write latch 
01eb			 
01eb 3a 40 fb		       ld a,(spi_portbyte) 
01ee cd 76 01			call spi_ce_high 
01f1			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f1 d3 80		       out (storage_adata),a 
01f3 32 40 fb		       ld (spi_portbyte), a 
01f6			 
01f6 00				nop 
01f7			    ; 
01f7			    ; intial write data 
01f7			    ; 
01f7			    ; cs low 
01f7			     
01f7 3a 40 fb		       ld a,(spi_portbyte) 
01fa cd 87 01			call spi_ce_low 
01fd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd d3 80		       out (storage_adata),a 
01ff 32 40 fb		       ld (spi_portbyte), a 
0202			 
0202			    ; clock out write instruction 
0202			     
0202 3e 02		    ld a, store_write_ins  
0204 cd ab 00		    call spi_send_byte  
0207			 
0207			    ; clock out address (depending on address size) 
0207			     
0207 e1			    pop hl 
0208 7c			    ld a,h    ; address out msb first 
0209 cd ab 00		    call spi_send_byte  
020c 7d			    ld a,l 
020d cd ab 00		    call spi_send_byte  
0210			 
0210			    ; clock out byte(s) for page 
0210			 
0210 f1			    pop af 
0211 cd ab 00		    call spi_send_byte  
0214			 
0214			    ; end write with ce high 
0214 3a 40 fb		       ld a,(spi_portbyte) 
0217			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0217 cd 76 01			call spi_ce_high 
021a d3 80		       out (storage_adata),a 
021c 32 40 fb		       ld (spi_portbyte), a 
021f			 
021f				; pause for internal write cycle 
021f 3e 0a			ld a, 10 
0221 cd 24 0b			call aDelayInMS 
0224 c9			    ret 
0225			 
0225			; buffer to write in de 
0225			; address in hl  
0225			se_writepage: 
0225			        
0225			    ;   ld c, a 
0225 d5				push de 
0226 e5			        push hl 
0227			 
0227			    ; initi write mode 
0227			    ; 
0227			    ;CS low 
0227			 
0227 3a 40 fb		       ld a,(spi_portbyte) 
022a cd 87 01			call spi_ce_low 
022d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022d d3 80		       out (storage_adata),a 
022f 32 40 fb		       ld (spi_portbyte), a 
0232			 
0232			    ;clock out wren instruction 
0232			 
0232 3e 06		    ld a, store_wren_ins 
0234 cd ab 00		    call spi_send_byte  
0237			 
0237			    ;cs high to enable write latch 
0237			 
0237 3a 40 fb		       ld a,(spi_portbyte) 
023a cd 76 01			call spi_ce_high 
023d			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023d d3 80		       out (storage_adata),a 
023f 32 40 fb		       ld (spi_portbyte), a 
0242			 
0242 00				nop 
0243			    ; 
0243			    ; intial write data 
0243			    ; 
0243			    ; cs low 
0243			     
0243 3a 40 fb		       ld a,(spi_portbyte) 
0246			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0246 cd 87 01			call spi_ce_low 
0249 d3 80		       out (storage_adata),a 
024b 32 40 fb		       ld (spi_portbyte), a 
024e			 
024e			    ; clock out write instruction 
024e			     
024e 3e 02		    ld a, store_write_ins  
0250 cd ab 00		    call spi_send_byte  
0253			 
0253			    ; clock out address (depending on address size) 
0253			     
0253 e1			    pop hl 
0254 7c			    ld a,h    ; address out msb first 
0255 cd ab 00		    call spi_send_byte  
0258 7d			    ld a,l 
0259 cd ab 00		    call spi_send_byte  
025c			 
025c			    ; clock out byte(s) for page 
025c			 
025c e1				pop hl 
025d 06 40			ld b, STORE_BLOCK_PHY 
025f			.bytewrite: 
025f			 
025f 7e				ld a,(hl) 
0260 e5			    push hl 
0261 c5				push bc 
0262 cd ab 00		    call spi_send_byte  
0265 c1				pop bc 
0266 e1				pop hl 
0267			 
0267			    ; end write with ce high 
0267 3a 40 fb		       ld a,(spi_portbyte) 
026a cd 76 01			call spi_ce_high 
026d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026d d3 80		       out (storage_adata),a 
026f 32 40 fb		       ld (spi_portbyte), a 
0272			 
0272 23				inc hl 
0273 10 ea			djnz .bytewrite 
0275			 
0275				; pause for internal write cycle 
0275 3e 64			ld a, 100 
0277 cd 24 0b			call aDelayInMS 
027a c9			    ret 
027b			; returns byte in a 
027b			; address in hl  
027b			se_readbyte: 
027b d5				push de 
027c c5				push bc 
027d			 
027d			    ;   ld c, a 
027d e5			        push hl 
027e			 
027e			    ; initi write mode 
027e			    ; 
027e			    ;CS low 
027e			 
027e 3a 40 fb		       ld a,(spi_portbyte) 
0281 cd 87 01			call spi_ce_low 
0284			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0284 d3 80		       out (storage_adata),a 
0286 32 40 fb		       ld (spi_portbyte), a 
0289			 
0289			    ;clock out wren instruction 
0289			 
0289 3e 03		    ld a, store_read_ins 
028b cd ab 00		    call spi_send_byte  
028e			 
028e			 
028e			    ; clock out address (depending on address size) 
028e			     
028e e1			    pop hl 
028f 7c			    ld a,h    ; address out msb first 
0290 cd ab 00		    call spi_send_byte  
0293 7d			    ld a,l 
0294 cd ab 00		    call spi_send_byte  
0297			 
0297			    ; clock in byte(s) for page 
0297			 
0297 cd cc 00		    call spi_read_byte  
029a f5				push af 
029b			 
029b			    ; end write with ce high 
029b 3a 40 fb		       ld a,(spi_portbyte) 
029e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029e cd 76 01			call spi_ce_high 
02a1 d3 80		       out (storage_adata),a 
02a3 32 40 fb		       ld (spi_portbyte), a 
02a6			 
02a6 f1				pop af 
02a7			 
02a7 c1				pop bc 
02a8 d1				pop de 
02a9			 
02a9 c9			    ret 
02aa			 
02aa			if DEBUG_STORESE 
02aa			 
02aa			storageput:  
02aa			 
02aa			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02aa			 
02aa 21 d6 f2			ld hl,scratch+2 
02ad cd ad 11			call get_word_hl 
02b0			 
02b0				; stuff it here for the moment as it will be overwritten later anyway 
02b0			 
02b0 22 f7 f5			ld (os_cur_ptr),hl	 
02b3			 
02b3			 
02b3			; get pointer to start of string 
02b3			 
02b3 21 db f2			ld hl, scratch+7 
02b6			 
02b6			; loop writing char of string to eeprom 
02b6			 
02b6 7e			.writestr:	ld a,(hl) 
02b7 fe 00				cp 0 
02b9 28 12				jr z, .wsdone		; done writing 
02bb e5					push hl 
02bc 2a f7 f5				ld hl,(os_cur_ptr) 
02bf cd d9 01				call se_writebyte 
02c2			 
02c2 2a f7 f5				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c5 23					inc hl 
02c6 22 f7 f5				ld (os_cur_ptr),hl 
02c9			 
02c9					; restore string pointer and get next char 
02c9			 
02c9 e1					pop hl 
02ca 23					inc hl 
02cb 18 e9				jr .writestr 
02cd			 
02cd			 
02cd			 
02cd			.wsdone: 
02cd			 
02cd			 
02cd			; when done load first page into a buffer  
02cd			 
02cd 21 00 80				ld hl,08000h		; start in ram 
02d0 22 f7 f5				ld (os_cur_ptr),hl 
02d3 21 00 00				ld hl, 0		 ; start of page 
02d6 22 fc f2				ld (scratch+40),hl	; hang on to it 
02d9			 
02d9 06 80				ld b, 128		; actually get more then one page 
02db c5			.wsload:	push bc 
02dc 2a fc f2				ld hl,(scratch+40) 
02df e5					push hl 
02e0 cd 7b 02				call se_readbyte 
02e3			 
02e3					; a now as the byte 
02e3			 
02e3 2a f7 f5				ld hl,(os_cur_ptr) 
02e6 77					ld (hl),a 
02e7					; inc next buffer area 
02e7 23					inc hl 
02e8 22 f7 f5				ld (os_cur_ptr),hl 
02eb			 
02eb					; get eeprom position, inc and save for next round 
02eb e1					pop hl		 
02ec 23					inc hl 
02ed 22 fc f2				ld (scratch+40),hl 
02f0 c1					pop bc 
02f1 10 e8				djnz .wsload 
02f3			 
02f3			; set 'd' pointer to start of buffer 
02f3			 
02f3 21 00 80				ld hl,08000h 
02f6 22 f7 f5				ld (os_cur_ptr),hl 
02f9			 
02f9			 
02f9 c9			ret 
02fa			 
02fa			 
02fa c9			storageread: ret 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			endif 
02fb			 
02fb			 
02fb			 
# End of file firmware_seeprom.asm
02fb			else  
02fb			   ; create some stubs for the labels  
02fb			se_readbyte: ret  
02fb			se_writebyte: ret  
02fb			storage_init: ret  
02fb			  
02fb			endif  
02fb			  
02fb			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02fb			;include "firmware_cf.asm"  
02fb			  
02fb			; load up high level storage hardward abstractions  
02fb			include "firmware_storage.asm"  
02fb			 
02fb			; persisent storage hardware abstraction layer  
02fb			 
02fb			 
02fb			 
02fb			; Block 0 on storage is a config state 
02fb			 
02fb			 
02fb			 
02fb			; TODO add read phy block and write phy block functions 
02fb			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02fb			 
02fb			; Abstraction layer  
02fb			 
02fb			; Logocial block size is same size as physical size - using tape concept 
02fb			 
02fb			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02fb			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02fb			 
02fb			 
02fb			 
02fb			; Filesystem layout (Logical layout) 
02fb			; 
02fb			; Block 0 - Bank config  
02fb			; 
02fb			;      Byte - 0 file id counter 
02fb			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02fb			;      Byte - 3-20 zero terminated bank label 
02fb			; 
02fb			; Block 1 > File storage 
02fb			; 
02fb			;      Byte 0 file id    - block 0 file details 
02fb			;      Byte 1 block id - block 0 is file  
02fb			;            Byte 2-15 - File name 
02fb			; 
02fb			;       - to end of block data 
02fb			; 
02fb			 
02fb			; Get ID for the file named in pointer held HL 
02fb			; Returns ID in HL = 255 if no file found 
02fb			 
02fb			storage_getid: 
02fb			 
02fb 22 57 fb			ld (store_tmp1), hl 
02fe			 
02fe				if DEBUG_STORESE 
02fe					DMARK "SGI" 
02fe f5				push af  
02ff 3a 13 03			ld a, (.dmark)  
0302 32 6e fe			ld (debug_mark),a  
0305 3a 14 03			ld a, (.dmark+1)  
0308 32 6f fe			ld (debug_mark+1),a  
030b 3a 15 03			ld a, (.dmark+2)  
030e 32 70 fe			ld (debug_mark+2),a  
0311 18 03			jr .pastdmark  
0313 ..			.dmark: db "SGI"  
0316 f1			.pastdmark: pop af  
0317			endm  
# End of macro DMARK
0317					CALLMONITOR 
0317 cd 9d 17			call break_point_state  
031a				endm  
# End of macro CALLMONITOR
031a				endif 
031a				; get block 0 and set counter for number of files to scan 
031a			 
031a cd 85 04			call storage_get_block_0 
031d			 
031d 3a 59 fb			ld a, (store_page) 
0320 47				ld b, a 
0321			 
0321				; get extent 0 of each file id 
0321			 
0321				if DEBUG_STORESE 
0321					DMARK "SGc" 
0321 f5				push af  
0322 3a 36 03			ld a, (.dmark)  
0325 32 6e fe			ld (debug_mark),a  
0328 3a 37 03			ld a, (.dmark+1)  
032b 32 6f fe			ld (debug_mark+1),a  
032e 3a 38 03			ld a, (.dmark+2)  
0331 32 70 fe			ld (debug_mark+2),a  
0334 18 03			jr .pastdmark  
0336 ..			.dmark: db "SGc"  
0339 f1			.pastdmark: pop af  
033a			endm  
# End of macro DMARK
033a					CALLMONITOR 
033a cd 9d 17			call break_point_state  
033d				endm  
# End of macro CALLMONITOR
033d				endif 
033d 60			.getloop:	ld h, b 
033e 2e 00				ld l, 0 
0340 c5					push bc 
0341			 
0341 11 59 fb				ld de, store_page 
0344				if DEBUG_STORESE 
0344					DMARK "SGr" 
0344 f5				push af  
0345 3a 59 03			ld a, (.dmark)  
0348 32 6e fe			ld (debug_mark),a  
034b 3a 5a 03			ld a, (.dmark+1)  
034e 32 6f fe			ld (debug_mark+1),a  
0351 3a 5b 03			ld a, (.dmark+2)  
0354 32 70 fe			ld (debug_mark+2),a  
0357 18 03			jr .pastdmark  
0359 ..			.dmark: db "SGr"  
035c f1			.pastdmark: pop af  
035d			endm  
# End of macro DMARK
035d					CALLMONITOR 
035d cd 9d 17			call break_point_state  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360 cd 2d 09				call storage_read 
0363 cd 1f 0e				call ishlzero 
0366 28 2d				jr z, .gap 
0368					 
0368					; have a file name read. Is it one we want. 
0368			 
0368 2a 57 fb				ld hl, (store_tmp1) 
036b 11 5c fb				ld de, store_page+3   ; file name 
036e			 
036e				if DEBUG_STORESE 
036e					DMARK "SGc" 
036e f5				push af  
036f 3a 83 03			ld a, (.dmark)  
0372 32 6e fe			ld (debug_mark),a  
0375 3a 84 03			ld a, (.dmark+1)  
0378 32 6f fe			ld (debug_mark+1),a  
037b 3a 85 03			ld a, (.dmark+2)  
037e 32 70 fe			ld (debug_mark+2),a  
0381 18 03			jr .pastdmark  
0383 ..			.dmark: db "SGc"  
0386 f1			.pastdmark: pop af  
0387			endm  
# End of macro DMARK
0387					CALLMONITOR 
0387 cd 9d 17			call break_point_state  
038a				endm  
# End of macro CALLMONITOR
038a				endif 
038a cd 8c 12				call strcmp 
038d 20 06				jr nz, .gap   ; not this one 
038f			 
038f c1				        pop bc 
0390			 
0390 26 00				ld h, 0 
0392 68					ld l, b 
0393 18 22				jr .getdone 
0395						 
0395			 
0395			 
0395			 
0395			.gap: 
0395				if DEBUG_STORESE 
0395					DMARK "SGg" 
0395 f5				push af  
0396 3a aa 03			ld a, (.dmark)  
0399 32 6e fe			ld (debug_mark),a  
039c 3a ab 03			ld a, (.dmark+1)  
039f 32 6f fe			ld (debug_mark+1),a  
03a2 3a ac 03			ld a, (.dmark+2)  
03a5 32 70 fe			ld (debug_mark+2),a  
03a8 18 03			jr .pastdmark  
03aa ..			.dmark: db "SGg"  
03ad f1			.pastdmark: pop af  
03ae			endm  
# End of macro DMARK
03ae					CALLMONITOR 
03ae cd 9d 17			call break_point_state  
03b1				endm  
# End of macro CALLMONITOR
03b1				endif 
03b1			 
03b1 c1					pop bc 
03b2 10 89				djnz .getloop 
03b4 21 ff 00				ld hl, 255 
03b7			.getdone: 
03b7			 
03b7				if DEBUG_STORESE 
03b7					DMARK "SGe" 
03b7 f5				push af  
03b8 3a cc 03			ld a, (.dmark)  
03bb 32 6e fe			ld (debug_mark),a  
03be 3a cd 03			ld a, (.dmark+1)  
03c1 32 6f fe			ld (debug_mark+1),a  
03c4 3a ce 03			ld a, (.dmark+2)  
03c7 32 70 fe			ld (debug_mark+2),a  
03ca 18 03			jr .pastdmark  
03cc ..			.dmark: db "SGe"  
03cf f1			.pastdmark: pop af  
03d0			endm  
# End of macro DMARK
03d0					CALLMONITOR 
03d0 cd 9d 17			call break_point_state  
03d3				endm  
# End of macro CALLMONITOR
03d3				endif 
03d3			 
03d3 c9				ret 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			; Read Block 
03d4			; ---------- 
03d4			; 
03d4			; With current bank 
03d4			;  
03d4			; Get block number to read 
03d4			; Load physical blocks starting at start block into buffer 
03d4			 
03d4			; de points to buffer to use 
03d4			; hl holds logical block number  
03d4			 
03d4			storage_read_block: 
03d4			 
03d4				; TODO bank selection 
03d4			 
03d4				; for each of the physical blocks read it into the buffer 
03d4 06 40			ld b, STORE_BLOCK_PHY 
03d6			 
03d6				if DEBUG_STORESE 
03d6 d5					push de 
03d7				endif 
03d7				 
03d7			.rl1:    
03d7			 
03d7				; read physical block at hl into de 
03d7			        ; increment hl and de to next read position on exit 
03d7			 
03d7 e5				push hl 
03d8 d5				push de	 
03d9 c5				push bc 
03da			;	if DEBUG_STORESE 
03da			;		push af 
03da			;		ld a, 'R' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da cd 7b 02			call se_readbyte 
03dd			;	if DEBUG_STORESE 
03dd			;		ld a,(spi_portbyte) 
03dd			;		ld l, a 
03dd			;		push af 
03dd			;		ld a, '1' 
03dd			;		ld (debug_mark),a 
03dd			;		pop af 
03dd			;		CALLMONITOR 
03dd			;	endif 
03dd c1				pop bc 
03de d1				pop de 
03df e1				pop hl 
03e0 12				ld (de),a 
03e1 23				inc hl 
03e2 13				inc de 
03e3			 
03e3			;	if DEBUG_STORESE 
03e3			;		push af 
03e3			;		ld a, 'r' 
03e3			;		ld (debug_mark),a 
03e3			;		pop af 
03e3			;		CALLMONITOR 
03e3			;	endif 
03e3			 
03e3 10 f2			djnz .rl1 
03e5			 
03e5				if DEBUG_STORESE 
03e5					DMARK "SRB" 
03e5 f5				push af  
03e6 3a fa 03			ld a, (.dmark)  
03e9 32 6e fe			ld (debug_mark),a  
03ec 3a fb 03			ld a, (.dmark+1)  
03ef 32 6f fe			ld (debug_mark+1),a  
03f2 3a fc 03			ld a, (.dmark+2)  
03f5 32 70 fe			ld (debug_mark+2),a  
03f8 18 03			jr .pastdmark  
03fa ..			.dmark: db "SRB"  
03fd f1			.pastdmark: pop af  
03fe			endm  
# End of macro DMARK
03fe d1					pop de 
03ff			; 
03ff			;		push af 
03ff			;		ld a, 'R' 
03ff			;		ld (debug_mark),a 
03ff			;		pop af 
03ff					CALLMONITOR 
03ff cd 9d 17			call break_point_state  
0402				endm  
# End of macro CALLMONITOR
0402				endif 
0402 c9				ret	 
0403				 
0403			 
0403			; File Size 
0403			; --------- 
0403			; 
0403			;   hl file id 
0403			; 
0403			;  returns in hl the number of blocks 
0403			 
0403			storage_file_size: 
0403 5d				ld e, l 
0404 16 00			ld d, 0 
0406 21 40 00			ld hl, STORE_BLOCK_PHY 
0409					if DEBUG_FORTH_WORDS 
0409						DMARK "SIZ" 
0409 f5				push af  
040a 3a 1e 04			ld a, (.dmark)  
040d 32 6e fe			ld (debug_mark),a  
0410 3a 1f 04			ld a, (.dmark+1)  
0413 32 6f fe			ld (debug_mark+1),a  
0416 3a 20 04			ld a, (.dmark+2)  
0419 32 70 fe			ld (debug_mark+2),a  
041c 18 03			jr .pastdmark  
041e ..			.dmark: db "SIZ"  
0421 f1			.pastdmark: pop af  
0422			endm  
# End of macro DMARK
0422						CALLMONITOR 
0422 cd 9d 17			call break_point_state  
0425				endm  
# End of macro CALLMONITOR
0425					endif 
0425 cd 07 07			call storage_findnextid 
0428			 
0428 cd 1f 0e			call ishlzero 
042b			;	ld a, l 
042b			;	add h 
042b			;	cp 0 
042b c8				ret z			; block not found so EOF 
042c			 
042c 11 59 fb			ld de, store_page 
042f cd d4 03			call storage_read_block 
0432			 
0432 3a 5b fb			ld a, (store_page+2)	 ; get extent count 
0435 6f				ld l, a 
0436 26 00			ld h, 0 
0438 c9			 	ret 
0439			 
0439			 
0439			; Write Block 
0439			; ----------- 
0439			; 
0439			; With current bank 
0439			;  
0439			; Get block number to write 
0439			; Write physical blocks starting at start block from buffer 
0439			  
0439			storage_write_block: 
0439				; TODO bank selection 
0439			 
0439				; for each of the physical blocks read it into the buffer 
0439 06 40			ld b, STORE_BLOCK_PHY 
043b			 
043b				if DEBUG_STORESE 
043b					DMARK "SWB" 
043b f5				push af  
043c 3a 50 04			ld a, (.dmark)  
043f 32 6e fe			ld (debug_mark),a  
0442 3a 51 04			ld a, (.dmark+1)  
0445 32 6f fe			ld (debug_mark+1),a  
0448 3a 52 04			ld a, (.dmark+2)  
044b 32 70 fe			ld (debug_mark+2),a  
044e 18 03			jr .pastdmark  
0450 ..			.dmark: db "SWB"  
0453 f1			.pastdmark: pop af  
0454			endm  
# End of macro DMARK
0454			 
0454					;push af 
0454					;ld a, 'W' 
0454					;ld (debug_mark),a 
0454					;pop af 
0454					CALLMONITOR 
0454 cd 9d 17			call break_point_state  
0457				endm  
# End of macro CALLMONITOR
0457				endif 
0457			 
0457			; might not be working 
0457			;	call se_writepage 
0457			 
0457			;	ret 
0457			; 
0457			 
0457			 
0457			 
0457			.wl1:    
0457			 
0457				; read physical block at hl into de 
0457			        ; increment hl and de to next read position on exit 
0457			 
0457 e5				push hl 
0458 d5				push de	 
0459 c5				push bc 
045a 1a				ld a,(de) 
045b				;if DEBUG_STORESE 
045b			;		push af 
045b			;		ld a, 'W' 
045b			;		ld (debug_mark),a 
045b			;		pop af 
045b			;		CALLMONITOR 
045b			;	endif 
045b cd d9 01			call se_writebyte 
045e			;	call delay250ms 
045e 00				nop 
045f 00				nop 
0460 00				nop 
0461			;	if DEBUG_STORESE 
0461			;		push af 
0461			;		ld a, 'w' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461			;		CALLMONITOR 
0461			;	endif 
0461 c1				pop bc 
0462 d1				pop de 
0463 e1				pop hl 
0464 23				inc hl 
0465 13				inc de 
0466			 
0466			 
0466 10 ef			djnz .wl1 
0468			 
0468				if DEBUG_STORESE 
0468					DMARK "SW2" 
0468 f5				push af  
0469 3a 7d 04			ld a, (.dmark)  
046c 32 6e fe			ld (debug_mark),a  
046f 3a 7e 04			ld a, (.dmark+1)  
0472 32 6f fe			ld (debug_mark+1),a  
0475 3a 7f 04			ld a, (.dmark+2)  
0478 32 70 fe			ld (debug_mark+2),a  
047b 18 03			jr .pastdmark  
047d ..			.dmark: db "SW2"  
0480 f1			.pastdmark: pop af  
0481			endm  
# End of macro DMARK
0481			 
0481					;push af 
0481					;ld a, 'W' 
0481					;ld (debug_mark),a 
0481					;pop af 
0481					CALLMONITOR 
0481 cd 9d 17			call break_point_state  
0484				endm  
# End of macro CALLMONITOR
0484				endif 
0484 c9				ret	 
0485			 
0485			; Init bank 
0485			; --------- 
0485			; 
0485			; With current bank 
0485			; 
0485			; Setup block 0 config 
0485			;     Set 0 file id counter 
0485			;     Set formatted byte pattern 
0485			;     Zero out bank label 
0485			;      
0485			; For every logical block write 0-1 byte as null 
0485			 
0485			storage_get_block_0: 
0485			 
0485				; TODO check presence 
0485			 
0485				; get block 0 config 
0485			 
0485 21 00 00			ld hl, 0 
0488 11 59 fb			ld de, store_page 
048b cd d4 03			call storage_read_block 
048e			 
048e				if DEBUG_STORESE 
048e					DMARK "SB0" 
048e f5				push af  
048f 3a a3 04			ld a, (.dmark)  
0492 32 6e fe			ld (debug_mark),a  
0495 3a a4 04			ld a, (.dmark+1)  
0498 32 6f fe			ld (debug_mark+1),a  
049b 3a a5 04			ld a, (.dmark+2)  
049e 32 70 fe			ld (debug_mark+2),a  
04a1 18 03			jr .pastdmark  
04a3 ..			.dmark: db "SB0"  
04a6 f1			.pastdmark: pop af  
04a7			endm  
# End of macro DMARK
04a7 11 59 fb				ld de, store_page 
04aa			;		push af 
04aa			;		ld a, 'i' 
04aa			;		ld (debug_mark),a 
04aa			;		pop af 
04aa					CALLMONITOR 
04aa cd 9d 17			call break_point_state  
04ad				endm  
# End of macro CALLMONITOR
04ad				endif 
04ad			 
04ad				; is this area formatted? 
04ad			 
04ad			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ad 2a 5a fb			ld hl, (store_page+1) 
04b0 3e 80			ld a,0x80 
04b2 bd				cp l 
04b3 20 22			jr nz, .ininotformatted 
04b5				; do a double check 
04b5 3e 27			ld a, 0x27 
04b7 bc				cp h 
04b8 20 1d			jr nz, .ininotformatted 
04ba			 
04ba				; formatted then 
04ba			 
04ba				if DEBUG_STORESE 
04ba					DMARK "SB1" 
04ba f5				push af  
04bb 3a cf 04			ld a, (.dmark)  
04be 32 6e fe			ld (debug_mark),a  
04c1 3a d0 04			ld a, (.dmark+1)  
04c4 32 6f fe			ld (debug_mark+1),a  
04c7 3a d1 04			ld a, (.dmark+2)  
04ca 32 70 fe			ld (debug_mark+2),a  
04cd 18 03			jr .pastdmark  
04cf ..			.dmark: db "SB1"  
04d2 f1			.pastdmark: pop af  
04d3			endm  
# End of macro DMARK
04d3					;push af 
04d3					;ld a, 'I' 
04d3					;ld (debug_mark),a 
04d3					;pop af 
04d3					CALLMONITOR 
04d3 cd 9d 17			call break_point_state  
04d6				endm  
# End of macro CALLMONITOR
04d6				endif 
04d6 c9				ret 
04d7			 
04d7			.ininotformatted: 
04d7				; bank not formatted so poke various bits to make sure 
04d7			 
04d7				if DEBUG_STORESE 
04d7					DMARK "SB2" 
04d7 f5				push af  
04d8 3a ec 04			ld a, (.dmark)  
04db 32 6e fe			ld (debug_mark),a  
04de 3a ed 04			ld a, (.dmark+1)  
04e1 32 6f fe			ld (debug_mark+1),a  
04e4 3a ee 04			ld a, (.dmark+2)  
04e7 32 70 fe			ld (debug_mark+2),a  
04ea 18 03			jr .pastdmark  
04ec ..			.dmark: db "SB2"  
04ef f1			.pastdmark: pop af  
04f0			endm  
# End of macro DMARK
04f0					;push af 
04f0					;ld a, 'f' 
04f0					;ld (debug_mark),a 
04f0					;pop af 
04f0					CALLMONITOR 
04f0 cd 9d 17			call break_point_state  
04f3				endm  
# End of macro CALLMONITOR
04f3				endif 
04f3			 
04f3 cd 02 0b			call storage_clear_page 
04f6			 
04f6 21 59 fb			ld hl, store_page 
04f9 3e 00			ld a, 0 
04fb				 
04fb 77				ld (hl),a   ; reset file counter 
04fc			 
04fc 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ff 22 5a fb		 	ld (store_page+1), hl	 
0502			 
0502				; set default label 
0502			 
0502 21 9e 05			ld hl, .defaultbanklabl 
0505 11 5c fb		 	ld de, store_page+3 
0508 01 0f 00			ld bc, 15 
050b ed b0			ldir 
050d			 
050d				; Append the current bank id 
050d 21 65 fb			ld hl, store_page+3+9 
0510 3a 3e fb			ld a, (spi_device_id) 
0513 77				ld (hl), a 
0514			 
0514				; save default page 0 
0514			 
0514 21 00 00			ld hl, 0 
0517 11 59 fb			ld de, store_page 
051a				if DEBUG_STORESE 
051a					DMARK "SB3" 
051a f5				push af  
051b 3a 2f 05			ld a, (.dmark)  
051e 32 6e fe			ld (debug_mark),a  
0521 3a 30 05			ld a, (.dmark+1)  
0524 32 6f fe			ld (debug_mark+1),a  
0527 3a 31 05			ld a, (.dmark+2)  
052a 32 70 fe			ld (debug_mark+2),a  
052d 18 03			jr .pastdmark  
052f ..			.dmark: db "SB3"  
0532 f1			.pastdmark: pop af  
0533			endm  
# End of macro DMARK
0533			;		push af 
0533			;		ld a, 'F' 
0533			;		ld (debug_mark),a 
0533			;		pop af 
0533					CALLMONITOR 
0533 cd 9d 17			call break_point_state  
0536				endm  
# End of macro CALLMONITOR
0536				endif 
0536 cd 39 04			call storage_write_block 
0539				if DEBUG_STORESE 
0539					DMARK "SB4" 
0539 f5				push af  
053a 3a 4e 05			ld a, (.dmark)  
053d 32 6e fe			ld (debug_mark),a  
0540 3a 4f 05			ld a, (.dmark+1)  
0543 32 6f fe			ld (debug_mark+1),a  
0546 3a 50 05			ld a, (.dmark+2)  
0549 32 70 fe			ld (debug_mark+2),a  
054c 18 03			jr .pastdmark  
054e ..			.dmark: db "SB4"  
0551 f1			.pastdmark: pop af  
0552			endm  
# End of macro DMARK
0552			;		push af 
0552			;		ld a, '>' 
0552			;		ld (debug_mark),a 
0552			;		pop af 
0552					CALLMONITOR 
0552 cd 9d 17			call break_point_state  
0555				endm  
# End of macro CALLMONITOR
0555				endif 
0555			 
0555 00				nop 
0556 00				nop 
0557 00				nop 
0558			 
0558				; now set 0 in every page to mark as a free block 
0558			 
0558 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
055a 21 40 00			ld hl, STORE_BLOCK_PHY 
055d			 
055d 3e 00		.setmark1:   	ld a,0 
055f e5					push hl 
0560 c5					push bc 
0561 cd d9 01				call se_writebyte 
0564 3e 0a			ld a, 10 
0566 cd 24 0b			call aDelayInMS 
0569 23				inc hl 
056a cd d9 01				call se_writebyte 
056d 3e 0a			ld a, 10 
056f cd 24 0b			call aDelayInMS 
0572 2b				dec hl 
0573 c1					pop bc 
0574 e1					pop hl 
0575 3e 40				ld a, STORE_BLOCK_PHY 
0577 cd f6 0d				call addatohl 
057a 10 e1				djnz .setmark1 
057c			 
057c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057e 3e 00		.setmark2:   	ld a,0 
0580 e5					push hl 
0581 c5					push bc 
0582 cd d9 01				call se_writebyte 
0585 3e 0a			ld a, 10 
0587 cd 24 0b			call aDelayInMS 
058a 23				inc hl 
058b cd d9 01				call se_writebyte 
058e 3e 0a			ld a, 10 
0590 cd 24 0b			call aDelayInMS 
0593 2b				dec hl 
0594 c1					pop bc 
0595 e1					pop hl 
0596 3e 40				ld a, STORE_BLOCK_PHY 
0598 cd f6 0d				call addatohl 
059b 10 e1				djnz .setmark2 
059d			 
059d					 
059d			 
059d			 
059d c9				ret 
059e			 
059e			 
059e			 
059e			 
059e .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a9			 
05a9			 
05a9			 
05a9			; Label Bank 
05a9			; ---------- 
05a9			; 
05a9			; With current bank 
05a9			; Read block 0 
05a9			; Set label 
05a9			; Write block 0 
05a9			 
05a9			; label str pointer in hl 
05a9			 
05a9			storage_label:     
05a9			 
05a9				if DEBUG_STORESE 
05a9					DMARK "LBL" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 6e fe			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 6f fe			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 70 fe			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "LBL"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2					CALLMONITOR 
05c2 cd 9d 17			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5				endif 
05c5			 
05c5 e5				push hl 
05c6			 
05c6 cd 85 04			call storage_get_block_0 
05c9			 
05c9				; set default label 
05c9			 
05c9 e1				pop hl 
05ca			 
05ca 11 5c fb		 	ld de, store_page+3 
05cd 01 0f 00			ld bc, 15 
05d0				if DEBUG_STORESE 
05d0					DMARK "LB3" 
05d0 f5				push af  
05d1 3a e5 05			ld a, (.dmark)  
05d4 32 6e fe			ld (debug_mark),a  
05d7 3a e6 05			ld a, (.dmark+1)  
05da 32 6f fe			ld (debug_mark+1),a  
05dd 3a e7 05			ld a, (.dmark+2)  
05e0 32 70 fe			ld (debug_mark+2),a  
05e3 18 03			jr .pastdmark  
05e5 ..			.dmark: db "LB3"  
05e8 f1			.pastdmark: pop af  
05e9			endm  
# End of macro DMARK
05e9					CALLMONITOR 
05e9 cd 9d 17			call break_point_state  
05ec				endm  
# End of macro CALLMONITOR
05ec				endif 
05ec ed b0			ldir 
05ee				; save default page 0 
05ee			 
05ee 21 00 00			ld hl, 0 
05f1 11 59 fb			ld de, store_page 
05f4				if DEBUG_STORESE 
05f4					DMARK "LBW" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 6e fe			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 6f fe			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 70 fe			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "LBW"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd 9d 17			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610 cd 39 04			call storage_write_block 
0613			 
0613 c9				ret 
0614			 
0614			 
0614			 
0614			; Read Block 0 - Config 
0614			; --------------------- 
0614			; 
0614			; With current bank 
0614			; Call presence test 
0614			;    If not present format/init bank  
0614			; Read block 0  
0614			;  
0614			 
0614			 
0614			; Dir 
0614			; --- 
0614			; 
0614			; With current bank 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block read byte 2 
0614			;      if first block of file 
0614			;         Display file name 
0614			;         Display type flags for file 
0614			;        
0614			 
0614			; moving to words as this requires stack control 
0614			 
0614			 
0614			; Delete File 
0614			; ----------- 
0614			; 
0614			; With current bank 
0614			; 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block file id 
0614			;      If first block of file and dont have file id 
0614			;         if file to delete 
0614			;         Save file id 
0614			;         Null file id 
0614			;         Write this block back 
0614			;      If file id is one saved 
0614			;         Null file id 
0614			;         Write this block back 
0614			 
0614			 
0614			.se_done: 
0614 e1				pop hl 
0615 c9				ret 
0616			 
0616			storage_erase: 
0616			 
0616				; hl contains the file id 
0616			 
0616 5d				ld e, l 
0617 16 00			ld d, 0 
0619 21 40 00			ld hl, STORE_BLOCK_PHY 
061c					if DEBUG_FORTH_WORDS 
061c						DMARK "ERA" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 6e fe			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 6f fe			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 70 fe			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "ERA"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635						CALLMONITOR 
0635 cd 9d 17			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638					endif 
0638 cd 07 07			call storage_findnextid 
063b cd 1f 0e			call ishlzero 
063e c8				ret z 
063f			 
063f e5				push hl 
0640			 
0640				; TODO check file not found 
0640			 
0640 11 59 fb			ld de, store_page 
0643 cd d4 03			call storage_read_block 
0646			 
0646 cd 1f 0e			call ishlzero 
0649 ca 14 06			jp z,.se_done 
064c			 
064c					if DEBUG_FORTH_WORDS 
064c						DMARK "ER1" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 6e fe			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 6f fe			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 70 fe			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "ER1"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665						CALLMONITOR 
0665 cd 9d 17			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668					endif 
0668 3a 59 fb			ld a, (store_page)	; get file id 
066b 32 52 fb			ld (store_tmpid), a 
066e			 
066e 3a 5b fb			ld a, (store_page+2)    ; get count of extends 
0671 32 51 fb			ld (store_tmpext), a 
0674			 
0674				; wipe file header 
0674			 
0674 e1				pop hl 
0675 3e 00			ld a, 0 
0677 32 59 fb			ld (store_page), a 
067a 32 5a fb			ld (store_page+1),a 
067d 11 59 fb			ld de, store_page 
0680					if DEBUG_FORTH_WORDS 
0680						DMARK "ER2" 
0680 f5				push af  
0681 3a 95 06			ld a, (.dmark)  
0684 32 6e fe			ld (debug_mark),a  
0687 3a 96 06			ld a, (.dmark+1)  
068a 32 6f fe			ld (debug_mark+1),a  
068d 3a 97 06			ld a, (.dmark+2)  
0690 32 70 fe			ld (debug_mark+2),a  
0693 18 03			jr .pastdmark  
0695 ..			.dmark: db "ER2"  
0698 f1			.pastdmark: pop af  
0699			endm  
# End of macro DMARK
0699						CALLMONITOR 
0699 cd 9d 17			call break_point_state  
069c				endm  
# End of macro CALLMONITOR
069c					endif 
069c cd 39 04			call storage_write_block 
069f			 
069f			 
069f				; wipe file extents 
069f			 
069f 3a 51 fb			ld a, (store_tmpext) 
06a2 47				ld b, a 
06a3			 
06a3			.eraext:	  
06a3 c5				push bc 
06a4			 
06a4 21 40 00			ld hl, STORE_BLOCK_PHY 
06a7 3a 52 fb			ld a,(store_tmpid) 
06aa 5f				ld e, a 
06ab 50				ld d, b	 
06ac					if DEBUG_FORTH_WORDS 
06ac						DMARK "ER3" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6e fe			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6f fe			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 70 fe			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "ER3"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5						CALLMONITOR 
06c5 cd 9d 17			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8					endif 
06c8 cd 07 07			call storage_findnextid 
06cb cd 1f 0e			call ishlzero 
06ce ca 14 06			jp z,.se_done 
06d1			 
06d1 e5				push hl 
06d2 11 59 fb			ld de, store_page 
06d5 cd d4 03			call storage_read_block 
06d8			 
06d8				; free block	 
06d8			 
06d8 3e 00			ld a, 0 
06da 32 59 fb			ld (store_page), a 
06dd 32 5a fb			ld (store_page+1),a 
06e0 11 59 fb			ld de, store_page 
06e3 e1				pop hl 
06e4					if DEBUG_FORTH_WORDS 
06e4						DMARK "ER4" 
06e4 f5				push af  
06e5 3a f9 06			ld a, (.dmark)  
06e8 32 6e fe			ld (debug_mark),a  
06eb 3a fa 06			ld a, (.dmark+1)  
06ee 32 6f fe			ld (debug_mark+1),a  
06f1 3a fb 06			ld a, (.dmark+2)  
06f4 32 70 fe			ld (debug_mark+2),a  
06f7 18 03			jr .pastdmark  
06f9 ..			.dmark: db "ER4"  
06fc f1			.pastdmark: pop af  
06fd			endm  
# End of macro DMARK
06fd						CALLMONITOR 
06fd cd 9d 17			call break_point_state  
0700				endm  
# End of macro CALLMONITOR
0700					endif 
0700 cd 39 04			call storage_write_block 
0703			 
0703 c1				pop bc 
0704 10 9d			djnz .eraext 
0706			 
0706 c9				ret 
0707			 
0707			 
0707			; Find Free Block 
0707			; --------------- 
0707			; 
0707			; With current bank 
0707			;  
0707			; From given starting logical block 
0707			;    Read block  
0707			;    If no file id 
0707			;         Return block id 
0707			 
0707			 
0707			; hl starting page number 
0707			; hl contains free page number or zero if no pages free 
0707			; e contains the file id to locate 
0707			; d contains the block number 
0707			 
0707			; TODO change to find file id and use zero for free block 
0707			 
0707			storage_findnextid: 
0707			 
0707				; now locate first 0 page to mark as a free block 
0707			 
0707 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0709			;	ld hl, STORE_BLOCK_PHY 
0709			 
0709					if DEBUG_FORTH_WORDS 
0709					DMARK "FNI" 
0709 f5				push af  
070a 3a 1e 07			ld a, (.dmark)  
070d 32 6e fe			ld (debug_mark),a  
0710 3a 1f 07			ld a, (.dmark+1)  
0713 32 6f fe			ld (debug_mark+1),a  
0716 3a 20 07			ld a, (.dmark+2)  
0719 32 70 fe			ld (debug_mark+2),a  
071c 18 03			jr .pastdmark  
071e ..			.dmark: db "FNI"  
0721 f1			.pastdmark: pop af  
0722			endm  
# End of macro DMARK
0722						CALLMONITOR 
0722 cd 9d 17			call break_point_state  
0725				endm  
# End of macro CALLMONITOR
0725					endif 
0725			.ff1:   	 
0725 e5					push hl 
0726 c5					push bc 
0727 d5					push de 
0728 cd 7b 02				call se_readbyte 
072b 5f					ld e,a 
072c 23					inc hl 
072d cd 7b 02				call se_readbyte 
0730 57					ld d, a 
0731 e1					pop hl 
0732 e5					push hl 
0733 cd 14 0e				call cmp16 
0736 28 49				jr z, .fffound 
0738			 
0738 d1					pop de 
0739 c1					pop bc 
073a e1					pop hl 
073b			 
073b					; is found? 
073b					;cp e 
073b					;ret z 
073b			 
073b 3e 40				ld a, STORE_BLOCK_PHY 
073d cd f6 0d				call addatohl 
0740 10 e3				djnz .ff1 
0742			 
0742 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0744			.ff2:   	 
0744			 
0744 e5					push hl 
0745 c5					push bc 
0746 d5					push de 
0747 cd 7b 02				call se_readbyte 
074a 5f					ld e,a 
074b 23					inc hl 
074c cd 7b 02				call se_readbyte 
074f 57					ld d, a 
0750			 
0750 e1					pop hl 
0751 e5					push hl 
0752 cd 14 0e				call cmp16 
0755 28 2a				jr z, .fffound 
0757			 
0757 d1					pop de 
0758 c1					pop bc 
0759 e1					pop hl 
075a					; is found? 
075a					;cp e 
075a					;ret z 
075a			 
075a 3e 40				ld a, STORE_BLOCK_PHY 
075c cd f6 0d				call addatohl 
075f 10 e3				djnz .ff2 
0761			 
0761			 
0761					if DEBUG_FORTH_WORDS 
0761					DMARK "FN-" 
0761 f5				push af  
0762 3a 76 07			ld a, (.dmark)  
0765 32 6e fe			ld (debug_mark),a  
0768 3a 77 07			ld a, (.dmark+1)  
076b 32 6f fe			ld (debug_mark+1),a  
076e 3a 78 07			ld a, (.dmark+2)  
0771 32 70 fe			ld (debug_mark+2),a  
0774 18 03			jr .pastdmark  
0776 ..			.dmark: db "FN-"  
0779 f1			.pastdmark: pop af  
077a			endm  
# End of macro DMARK
077a					;	push af 
077a					;	ld a, 'n' 
077a					;	ld (debug_mark),a 
077a					;	pop af 
077a						CALLMONITOR 
077a cd 9d 17			call break_point_state  
077d				endm  
# End of macro CALLMONITOR
077d					endif 
077d				; no free marks! 
077d 21 00 00				ld hl, 0 
0780 c9				ret 
0781			.fffound: 
0781				 
0781			 
0781 d1					pop de 
0782 c1					pop bc 
0783 e1					pop hl 
0784					if DEBUG_FORTH_WORDS 
0784					DMARK "FNF" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 6e fe			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 6f fe			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 70 fe			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "FNF"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d					;	push af 
079d					;	ld a, 'n' 
079d					;	ld (debug_mark),a 
079d					;	pop af 
079d						CALLMONITOR 
079d cd 9d 17			call break_point_state  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 c9				ret 
07a1			 
07a1			 
07a1			 
07a1			; Free Space 
07a1			; ---------- 
07a1			; 
07a1			; With current bank 
07a1			; 
07a1			; Set block count to zero 
07a1			; Starting with first logical block 
07a1			;      Find free block  
07a1			;      If block id given, increment block count 
07a1			; 
07a1			;  
07a1			 
07a1			 
07a1			; hl contains count of free blocks 
07a1			 
07a1			storage_freeblocks: 
07a1			 
07a1				; now locate first 0 page to mark as a free block 
07a1			 
07a1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a3 21 40 00			ld hl, STORE_BLOCK_PHY 
07a6 11 00 00			ld de, 0 
07a9			 
07a9			.fb1:   	 
07a9 e5					push hl 
07aa c5					push bc 
07ab d5					push de 
07ac cd 7b 02				call se_readbyte 
07af d1					pop de 
07b0 c1					pop bc 
07b1 e1					pop hl 
07b2			 
07b2					; is free? 
07b2 fe 00				cp 0 
07b4 20 01				jr nz, .ff1cont 
07b6 13					inc de 
07b7			 
07b7			.ff1cont: 
07b7			 
07b7			 
07b7 3e 40				ld a, STORE_BLOCK_PHY 
07b9 cd f6 0d				call addatohl 
07bc 10 eb				djnz .fb1 
07be			 
07be 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07c0			.fb2:   	 
07c0 e5					push hl 
07c1 c5					push bc 
07c2 d5					push de 
07c3 cd 7b 02				call se_readbyte 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9			 
07c9					; is free? 
07c9 fe 00				cp 0 
07cb 20 01				jr nz, .ff2cont 
07cd 13					inc de 
07ce			 
07ce			.ff2cont: 
07ce			 
07ce 3e 40				ld a, STORE_BLOCK_PHY 
07d0 cd f6 0d				call addatohl 
07d3 10 eb				djnz .fb2 
07d5			 
07d5 eb				ex de, hl 
07d6 c9				ret 
07d7			 
07d7			; Get File ID 
07d7			; ----------- 
07d7			; 
07d7			; With current bank 
07d7			;  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; For each logical block 
07d7			;    Read block file id 
07d7			;      If first block of file and dont have file id 
07d7			;         if file get id and exit 
07d7			 
07d7			 
07d7			 
07d7			 
07d7			; Create File 
07d7			; ----------- 
07d7			; 
07d7			; With current bank  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; Increment file id number 
07d7			; Save Config 
07d7			; Find free block 
07d7			; Set buffer with file name and file id 
07d7			; Write buffer to free block  
07d7			 
07d7			 
07d7			; hl point to file name 
07d7			; hl returns file id 
07d7			 
07d7			; file format: 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent number 
07d7			; byte 2-> data 
07d7			 
07d7			; format for extent number 0: 
07d7			; 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent 0 
07d7			; byte 2 - extent count 
07d7			; byte 3 -> file name and meta data 
07d7			 
07d7			 
07d7			storage_create: 
07d7				if DEBUG_STORESE 
07d7					DMARK "SCR" 
07d7 f5				push af  
07d8 3a ec 07			ld a, (.dmark)  
07db 32 6e fe			ld (debug_mark),a  
07de 3a ed 07			ld a, (.dmark+1)  
07e1 32 6f fe			ld (debug_mark+1),a  
07e4 3a ee 07			ld a, (.dmark+2)  
07e7 32 70 fe			ld (debug_mark+2),a  
07ea 18 03			jr .pastdmark  
07ec ..			.dmark: db "SCR"  
07ef f1			.pastdmark: pop af  
07f0			endm  
# End of macro DMARK
07f0					CALLMONITOR 
07f0 cd 9d 17			call break_point_state  
07f3				endm  
# End of macro CALLMONITOR
07f3				endif 
07f3			 
07f3 e5				push hl		; save file name pointer 
07f4			 
07f4 cd 85 04			call storage_get_block_0 
07f7			 
07f7 3a 59 fb			ld a,(store_page)	; get current file id 
07fa 3c				inc a 
07fb 32 59 fb			ld (store_page),a 
07fe				 
07fe 32 52 fb			ld (store_tmpid),a			; save id 
0801			 
0801 21 00 00			ld hl, 0 
0804 11 59 fb			ld de, store_page 
0807				if DEBUG_STORESE 
0807					DMARK "SCw" 
0807 f5				push af  
0808 3a 1c 08			ld a, (.dmark)  
080b 32 6e fe			ld (debug_mark),a  
080e 3a 1d 08			ld a, (.dmark+1)  
0811 32 6f fe			ld (debug_mark+1),a  
0814 3a 1e 08			ld a, (.dmark+2)  
0817 32 70 fe			ld (debug_mark+2),a  
081a 18 03			jr .pastdmark  
081c ..			.dmark: db "SCw"  
081f f1			.pastdmark: pop af  
0820			endm  
# End of macro DMARK
0820					CALLMONITOR 
0820 cd 9d 17			call break_point_state  
0823				endm  
# End of macro CALLMONITOR
0823				endif 
0823 cd 39 04			call storage_write_block	 ; save update 
0826			 
0826				if DEBUG_STORESE 
0826 11 59 fb				ld de, store_page 
0829					DMARK "SCC" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 6e fe			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 6f fe			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 70 fe			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCC"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd 9d 17			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845				;  
0845				 
0845 21 40 00			ld hl, STORE_BLOCK_PHY 
0848 11 00 00			ld de, 0 
084b cd 07 07			call storage_findnextid 
084e			 
084e 22 43 fb			ld (store_tmppageid), hl    ; save page to use  
0851			 
0851				; TODO detect 0 = no spare blocks 
0851			 
0851				; hl now contains the free page to use for the file header page 
0851			 
0851				if DEBUG_STORESE 
0851				DMARK "SCF" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 6e fe			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 6f fe			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 70 fe			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SCF"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd 9d 17			call break_point_state  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d			 
086d 22 43 fb			ld (store_tmppageid), hl 
0870				 
0870 3a 52 fb			ld a,(store_tmpid)    ; get file id 
0873			;	ld a, (store_filecache)			; save to cache 
0873			 
0873 32 59 fb			ld (store_page),a    ; set page id 
0876 3e 00			ld a, 0			 ; extent 0 is file header 
0878 32 5a fb			ld (store_page+1), a   ; set file extent 
087b			 
087b 32 5b fb			ld (store_page+2), a   ; extent count for the file 
087e			 
087e			;	inc hl 		; init block 0 of file 
087e			;	inc hl   		; skip file and extent id 
087e			 ;       ld a, 0 
087e			;	ld (hl),a 
087e			;	ld a, (store_filecache+1)  	; save to cache 
087e			 
087e			;	inc hl    ; file name 
087e				 
087e				 
087e 11 5c fb			ld de, store_page+3    ; get buffer for term string to use as file name 
0881				if DEBUG_STORESE 
0881					DMARK "SCc" 
0881 f5				push af  
0882 3a 96 08			ld a, (.dmark)  
0885 32 6e fe			ld (debug_mark),a  
0888 3a 97 08			ld a, (.dmark+1)  
088b 32 6f fe			ld (debug_mark+1),a  
088e 3a 98 08			ld a, (.dmark+2)  
0891 32 70 fe			ld (debug_mark+2),a  
0894 18 03			jr .pastdmark  
0896 ..			.dmark: db "SCc"  
0899 f1			.pastdmark: pop af  
089a			endm  
# End of macro DMARK
089a					CALLMONITOR 
089a cd 9d 17			call break_point_state  
089d				endm  
# End of macro CALLMONITOR
089d				endif 
089d e1				pop hl    ; get zero term string 
089e e5				push hl 
089f 3e 00			ld a, 0 
08a1 cd 5f 12			call strlent 
08a4 23				inc hl   ; cover zero term 
08a5 06 00			ld b,0 
08a7 4d				ld c,l 
08a8 e1				pop hl 
08a9				;ex de, hl 
08a9				if DEBUG_STORESE 
08a9					DMARK "SCa" 
08a9 f5				push af  
08aa 3a be 08			ld a, (.dmark)  
08ad 32 6e fe			ld (debug_mark),a  
08b0 3a bf 08			ld a, (.dmark+1)  
08b3 32 6f fe			ld (debug_mark+1),a  
08b6 3a c0 08			ld a, (.dmark+2)  
08b9 32 70 fe			ld (debug_mark+2),a  
08bc 18 03			jr .pastdmark  
08be ..			.dmark: db "SCa"  
08c1 f1			.pastdmark: pop af  
08c2			endm  
# End of macro DMARK
08c2					;push af 
08c2					;ld a, 'a' 
08c2					;ld (debug_mark),a 
08c2					;pop af 
08c2					CALLMONITOR 
08c2 cd 9d 17			call break_point_state  
08c5				endm  
# End of macro CALLMONITOR
08c5				endif 
08c5 ed b0			ldir    ; copy zero term string 
08c7				if DEBUG_STORESE 
08c7					DMARK "SCA" 
08c7 f5				push af  
08c8 3a dc 08			ld a, (.dmark)  
08cb 32 6e fe			ld (debug_mark),a  
08ce 3a dd 08			ld a, (.dmark+1)  
08d1 32 6f fe			ld (debug_mark+1),a  
08d4 3a de 08			ld a, (.dmark+2)  
08d7 32 70 fe			ld (debug_mark+2),a  
08da 18 03			jr .pastdmark  
08dc ..			.dmark: db "SCA"  
08df f1			.pastdmark: pop af  
08e0			endm  
# End of macro DMARK
08e0					CALLMONITOR 
08e0 cd 9d 17			call break_point_state  
08e3				endm  
# End of macro CALLMONITOR
08e3				endif 
08e3			 
08e3				; write file header page 
08e3			 
08e3 2a 43 fb			ld hl,(store_tmppageid) 
08e6 11 59 fb			ld de, store_page 
08e9				if DEBUG_STORESE 
08e9					DMARK "SCb" 
08e9 f5				push af  
08ea 3a fe 08			ld a, (.dmark)  
08ed 32 6e fe			ld (debug_mark),a  
08f0 3a ff 08			ld a, (.dmark+1)  
08f3 32 6f fe			ld (debug_mark+1),a  
08f6 3a 00 09			ld a, (.dmark+2)  
08f9 32 70 fe			ld (debug_mark+2),a  
08fc 18 03			jr .pastdmark  
08fe ..			.dmark: db "SCb"  
0901 f1			.pastdmark: pop af  
0902			endm  
# End of macro DMARK
0902					;push af 
0902					;ld a, 'b' 
0902					;ld (debug_mark),a 
0902					;pop af 
0902					CALLMONITOR 
0902 cd 9d 17			call break_point_state  
0905				endm  
# End of macro CALLMONITOR
0905				endif 
0905 cd 39 04			call storage_write_block 
0908			 
0908 3a 52 fb			ld a, (store_tmpid) 
090b 6f				ld l, a 
090c 26 00			ld h,0 
090e				if DEBUG_STORESE 
090e					DMARK "SCz" 
090e f5				push af  
090f 3a 23 09			ld a, (.dmark)  
0912 32 6e fe			ld (debug_mark),a  
0915 3a 24 09			ld a, (.dmark+1)  
0918 32 6f fe			ld (debug_mark+1),a  
091b 3a 25 09			ld a, (.dmark+2)  
091e 32 70 fe			ld (debug_mark+2),a  
0921 18 03			jr .pastdmark  
0923 ..			.dmark: db "SCz"  
0926 f1			.pastdmark: pop af  
0927			endm  
# End of macro DMARK
0927					CALLMONITOR 
0927 cd 9d 17			call break_point_state  
092a				endm  
# End of macro CALLMONITOR
092a				endif 
092a c9				ret 
092b				 
092b			 
092b			 
092b			; 
092b			; Read File 
092b			; 
092b			; h - file id to locate 
092b			; l - extent to locate 
092b			; de - pointer to string to read into 
092b			; 
092b			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
092b			 
092b			.sr_fail: 
092b d1				pop de 
092c c9				ret 
092d			 
092d			storage_read: 
092d d5				push de 
092e			 
092e			; TODO BUG the above push is it popped before the RET Z? 
092e			 
092e			; TODO how to handle multiple part blocks 
092e			 
092e				; locate file extent to read 
092e			 
092e 5c				ld e, h 
092f 55				ld d, l 
0930 21 40 00			ld hl, STORE_BLOCK_PHY 
0933				if DEBUG_STORESE 
0933					DMARK "SRE" 
0933 f5				push af  
0934 3a 48 09			ld a, (.dmark)  
0937 32 6e fe			ld (debug_mark),a  
093a 3a 49 09			ld a, (.dmark+1)  
093d 32 6f fe			ld (debug_mark+1),a  
0940 3a 4a 09			ld a, (.dmark+2)  
0943 32 70 fe			ld (debug_mark+2),a  
0946 18 03			jr .pastdmark  
0948 ..			.dmark: db "SRE"  
094b f1			.pastdmark: pop af  
094c			endm  
# End of macro DMARK
094c					CALLMONITOR 
094c cd 9d 17			call break_point_state  
094f				endm  
# End of macro CALLMONITOR
094f				endif 
094f cd 07 07			call storage_findnextid 
0952			 
0952				if DEBUG_STORESE 
0952					DMARK "SRf" 
0952 f5				push af  
0953 3a 67 09			ld a, (.dmark)  
0956 32 6e fe			ld (debug_mark),a  
0959 3a 68 09			ld a, (.dmark+1)  
095c 32 6f fe			ld (debug_mark+1),a  
095f 3a 69 09			ld a, (.dmark+2)  
0962 32 70 fe			ld (debug_mark+2),a  
0965 18 03			jr .pastdmark  
0967 ..			.dmark: db "SRf"  
096a f1			.pastdmark: pop af  
096b			endm  
# End of macro DMARK
096b					CALLMONITOR 
096b cd 9d 17			call break_point_state  
096e				endm  
# End of macro CALLMONITOR
096e				endif 
096e cd 1f 0e			call ishlzero 
0971			;	ld a, l 
0971			;	add h 
0971			;	cp 0 
0971 28 b8			jr z,.sr_fail			; block not found so EOF 
0973			 
0973				; hl contains page number to load 
0973 d1				pop de   ; get storage 
0974 d5				push de 
0975				if DEBUG_STORESE 
0975					DMARK "SRg" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 6e fe			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 6f fe			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 70 fe			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "SRg"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 9d 17			call break_point_state  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991 cd d4 03			call storage_read_block 
0994			 
0994			 
0994			; TODO if block has no zeros then need to read next block  
0994			 
0994			 
0994					 
0994 e1				pop hl 		 ; return start of data to show as not EOF 
0995 23				inc hl   ; past file id 
0996 23				inc hl   ; past ext 
0997				if DEBUG_STORESE 
0997					DMARK "SRe" 
0997 f5				push af  
0998 3a ac 09			ld a, (.dmark)  
099b 32 6e fe			ld (debug_mark),a  
099e 3a ad 09			ld a, (.dmark+1)  
09a1 32 6f fe			ld (debug_mark+1),a  
09a4 3a ae 09			ld a, (.dmark+2)  
09a7 32 70 fe			ld (debug_mark+2),a  
09aa 18 03			jr .pastdmark  
09ac ..			.dmark: db "SRe"  
09af f1			.pastdmark: pop af  
09b0			endm  
# End of macro DMARK
09b0					CALLMONITOR 
09b0 cd 9d 17			call break_point_state  
09b3				endm  
# End of macro CALLMONITOR
09b3				endif 
09b3 c9					ret 
09b4			 
09b4			 
09b4			 
09b4			; 
09b4			; Append File 
09b4			; 
09b4			; hl - file id to locate 
09b4			; de - pointer to (multi block) string to write 
09b4			 
09b4			.sa_notfound: 
09b4 d1				pop de 
09b5 c9				ret 
09b6			 
09b6			 
09b6			storage_append: 
09b6				; hl -  file id to append to 
09b6				; de - string to append 
09b6			 
09b6 d5				push de 
09b7				 
09b7				if DEBUG_STORESE 
09b7					DMARK "AP1" 
09b7 f5				push af  
09b8 3a cc 09			ld a, (.dmark)  
09bb 32 6e fe			ld (debug_mark),a  
09be 3a cd 09			ld a, (.dmark+1)  
09c1 32 6f fe			ld (debug_mark+1),a  
09c4 3a ce 09			ld a, (.dmark+2)  
09c7 32 70 fe			ld (debug_mark+2),a  
09ca 18 03			jr .pastdmark  
09cc ..			.dmark: db "AP1"  
09cf f1			.pastdmark: pop af  
09d0			endm  
# End of macro DMARK
09d0					CALLMONITOR 
09d0 cd 9d 17			call break_point_state  
09d3				endm  
# End of macro CALLMONITOR
09d3				endif 
09d3			 
09d3 7d				ld a, l 
09d4 32 52 fb			ld (store_tmpid), a 
09d7			 
09d7				; get file header  
09d7			 
09d7 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
09d9 3a 52 fb			ld a, (store_tmpid) 
09dc 5f				ld e, a 
09dd			 
09dd 21 40 00				ld hl, STORE_BLOCK_PHY 
09e0 cd 07 07				call storage_findnextid 
09e3			 
09e3 cd 1f 0e			call ishlzero 
09e6 28 cc			jr z, .sa_notfound 
09e8			 
09e8 22 43 fb			ld (store_tmppageid), hl 
09eb			 
09eb				; TODO handle file id not found 
09eb			 
09eb				if DEBUG_STORESE 
09eb					DMARK "AP2" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 6e fe			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 6f fe			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 70 fe			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "AP2"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 9d 17			call break_point_state  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07			 
0a07				; update file extent count 
0a07			 
0a07 11 59 fb			ld de, store_page 
0a0a			 
0a0a cd d4 03			call storage_read_block 
0a0d			 
0a0d				if DEBUG_STORESE 
0a0d					DMARK "AP3" 
0a0d f5				push af  
0a0e 3a 22 0a			ld a, (.dmark)  
0a11 32 6e fe			ld (debug_mark),a  
0a14 3a 23 0a			ld a, (.dmark+1)  
0a17 32 6f fe			ld (debug_mark+1),a  
0a1a 3a 24 0a			ld a, (.dmark+2)  
0a1d 32 70 fe			ld (debug_mark+2),a  
0a20 18 03			jr .pastdmark  
0a22 ..			.dmark: db "AP3"  
0a25 f1			.pastdmark: pop af  
0a26			endm  
# End of macro DMARK
0a26					CALLMONITOR 
0a26 cd 9d 17			call break_point_state  
0a29				endm  
# End of macro CALLMONITOR
0a29				endif 
0a29			;	ld (store_tmppageid), hl 
0a29			 
0a29 3a 5b fb			ld a, (store_page+2) 
0a2c 3c				inc a 
0a2d 32 5b fb			ld (store_page+2), a 
0a30 32 51 fb			ld (store_tmpext), a 
0a33				 
0a33				if DEBUG_STORESE 
0a33					DMARK "AP3" 
0a33 f5				push af  
0a34 3a 48 0a			ld a, (.dmark)  
0a37 32 6e fe			ld (debug_mark),a  
0a3a 3a 49 0a			ld a, (.dmark+1)  
0a3d 32 6f fe			ld (debug_mark+1),a  
0a40 3a 4a 0a			ld a, (.dmark+2)  
0a43 32 70 fe			ld (debug_mark+2),a  
0a46 18 03			jr .pastdmark  
0a48 ..			.dmark: db "AP3"  
0a4b f1			.pastdmark: pop af  
0a4c			endm  
# End of macro DMARK
0a4c					CALLMONITOR 
0a4c cd 9d 17			call break_point_state  
0a4f				endm  
# End of macro CALLMONITOR
0a4f				endif 
0a4f 2a 43 fb			ld hl, (store_tmppageid) 
0a52 11 59 fb			ld de, store_page 
0a55 cd 39 04			call storage_write_block 
0a58			 
0a58				; find free block 
0a58			 
0a58 11 00 00			ld de, 0			 ; file extent to locate 
0a5b			 
0a5b 21 40 00				ld hl, STORE_BLOCK_PHY 
0a5e cd 07 07				call storage_findnextid 
0a61 cd 1f 0e			call ishlzero 
0a64 ca b4 09			jp z, .sa_notfound 
0a67			 
0a67					; TODO handle no space left 
0a67					 
0a67 22 43 fb				ld (store_tmppageid), hl 
0a6a			 
0a6a				if DEBUG_STORESE 
0a6a					DMARK "AP4" 
0a6a f5				push af  
0a6b 3a 7f 0a			ld a, (.dmark)  
0a6e 32 6e fe			ld (debug_mark),a  
0a71 3a 80 0a			ld a, (.dmark+1)  
0a74 32 6f fe			ld (debug_mark+1),a  
0a77 3a 81 0a			ld a, (.dmark+2)  
0a7a 32 70 fe			ld (debug_mark+2),a  
0a7d 18 03			jr .pastdmark  
0a7f ..			.dmark: db "AP4"  
0a82 f1			.pastdmark: pop af  
0a83			endm  
# End of macro DMARK
0a83					CALLMONITOR 
0a83 cd 9d 17			call break_point_state  
0a86				endm  
# End of macro CALLMONITOR
0a86				endif 
0a86					; init the buffer with zeros so we can id if the buffer is full or not 
0a86			 
0a86 e5					push hl 
0a87 c5					push bc 
0a88			 
0a88 21 59 fb				ld hl, store_page 
0a8b 06 40				ld b, STORE_BLOCK_PHY 
0a8d 3e 00				ld a, 0 
0a8f 77			.zeroblock:	ld (hl), a 
0a90 23					inc hl 
0a91 10 fc				djnz .zeroblock 
0a93			 
0a93 c1					pop bc 
0a94 e1					pop hl 
0a95			 
0a95					; construct block 
0a95			 
0a95 3a 52 fb				ld a, (store_tmpid) 
0a98 32 59 fb				ld (store_page), a   ; file id 
0a9b 3a 51 fb				ld a, (store_tmpext)   ; extent for this block 
0a9e 32 5a fb				ld (store_page+1), a 
0aa1			 
0aa1 e1					pop hl    ; get string to write 
0aa2 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0aa4 11 5b fb				ld de, store_page+2 
0aa7			 
0aa7				if DEBUG_STORESE 
0aa7					DMARK "AP5" 
0aa7 f5				push af  
0aa8 3a bc 0a			ld a, (.dmark)  
0aab 32 6e fe			ld (debug_mark),a  
0aae 3a bd 0a			ld a, (.dmark+1)  
0ab1 32 6f fe			ld (debug_mark+1),a  
0ab4 3a be 0a			ld a, (.dmark+2)  
0ab7 32 70 fe			ld (debug_mark+2),a  
0aba 18 03			jr .pastdmark  
0abc ..			.dmark: db "AP5"  
0abf f1			.pastdmark: pop af  
0ac0			endm  
# End of macro DMARK
0ac0					CALLMONITOR 
0ac0 cd 9d 17			call break_point_state  
0ac3				endm  
# End of macro CALLMONITOR
0ac3				endif 
0ac3			 
0ac3			 
0ac3			 
0ac3					; fill buffer with data until end of string or full block 
0ac3			 
0ac3 7e			.appd:		ld a, (hl) 
0ac4 12					ld (de), a 
0ac5 fe 00				cp 0 
0ac7 28 04				jr z, .appdone 
0ac9 23					inc hl 
0aca 13					inc de 
0acb 10 f6				djnz .appd 
0acd			 
0acd e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0ace f5					push af   		; save last byte dumped 
0acf			 
0acf			 
0acf 2a 43 fb			ld hl, (store_tmppageid) 
0ad2 11 59 fb			ld de, store_page 
0ad5				if DEBUG_STORESE 
0ad5					DMARK "AP6" 
0ad5 f5				push af  
0ad6 3a ea 0a			ld a, (.dmark)  
0ad9 32 6e fe			ld (debug_mark),a  
0adc 3a eb 0a			ld a, (.dmark+1)  
0adf 32 6f fe			ld (debug_mark+1),a  
0ae2 3a ec 0a			ld a, (.dmark+2)  
0ae5 32 70 fe			ld (debug_mark+2),a  
0ae8 18 03			jr .pastdmark  
0aea ..			.dmark: db "AP6"  
0aed f1			.pastdmark: pop af  
0aee			endm  
# End of macro DMARK
0aee					CALLMONITOR 
0aee cd 9d 17			call break_point_state  
0af1				endm  
# End of macro CALLMONITOR
0af1				endif 
0af1 cd 39 04				call storage_write_block 
0af4			 
0af4			 
0af4				; was that a full block of data written? 
0af4				; any more to write out? 
0af4			 
0af4				; if yes then set vars and jump to start of function again 
0af4			 
0af4 f1					pop af 
0af5 d1					pop de 
0af6			 
0af6 fe 00				cp 0		 ; no, string was fully written 
0af8 c8					ret z 
0af9			 
0af9					; setup vars for next cycle 
0af9			 
0af9 3a 52 fb				ld a, (store_tmpid) 
0afc 6f					ld l, a 
0afd 26 00				ld h, 0 
0aff			 
0aff c3 b6 09			 	jp storage_append	 ; yes, need to write out some more 
0b02			 
0b02			 
0b02			 
0b02			 
0b02			 
0b02			 
0b02			 
0b02			if DEBUG_STORECF 
0b02			storageput:	 
0b02					ret 
0b02			storageread: 
0b02					ld hl, store_page 
0b02					ld b, 200 
0b02					ld a,0 
0b02			.src:		ld (hl),a 
0b02					inc hl 
0b02					djnz .src 
0b02					 
0b02			 
0b02					ld de, 0 
0b02					ld bc, 1 
0b02					ld hl, store_page 
0b02					call cfRead 
0b02			 
0b02				call cfGetError 
0b02				ld hl,scratch 
0b02				call hexout 
0b02				ld hl, scratch+2 
0b02				ld a, 0 
0b02				ld (hl),a 
0b02				ld de, scratch 
0b02				ld a,display_row_1 
0b02				call str_at_display 
0b02				call update_display 
0b02			 
0b02					ld hl, store_page 
0b02					ld (os_cur_ptr),hl 
0b02			 
0b02					ret 
0b02			endif 
0b02			 
0b02			 
0b02			; Clear out the main buffer store (used to remove junk before writing a new block) 
0b02			 
0b02			storage_clear_page: 
0b02 e5				push hl 
0b03 d5				push de 
0b04 c5				push bc 
0b05 21 59 fb			ld hl, store_page 
0b08 3e 00			ld a, 0 
0b0a 77				ld (hl), a 
0b0b			 
0b0b 11 5a fb			ld de, store_page+1 
0b0e 01 40 00			ld bc, STORE_BLOCK_PHY 
0b11			 
0b11 ed b0			ldir 
0b13				 
0b13 c1				pop bc 
0b14 d1				pop de 
0b15 e1				pop hl 
0b16 c9				ret 
0b17			 
0b17			; eof 
# End of file firmware_storage.asm
0b17			  
0b17			; support routines for above hardware abstraction layer  
0b17			  
0b17			include "firmware_general.asm"        ; general support functions  
0b17			 
0b17			; word look up 
0b17			 
0b17			; in 
0b17			; a is the index 
0b17			; hl is pointer start of array 
0b17			; 
0b17			; returns 
0b17			; hl to the word 
0b17			; 
0b17			 
0b17			table_lookup:  
0b17 d5					push de 
0b18 eb					ex de, hl 
0b19			 
0b19 6f					ld l, a 
0b1a 26 00				ld h, 0 
0b1c 29					add hl, hl 
0b1d 19					add hl, de 
0b1e 7e					ld a, (hl) 
0b1f 23					inc hl 
0b20 66					ld h,(hl) 
0b21 6f					ld l, a 
0b22			 
0b22 d1					pop de 
0b23 c9					ret 
0b24			 
0b24			; Delay loops 
0b24			 
0b24			 
0b24			 
0b24			aDelayInMS: 
0b24 c5				push bc 
0b25 47				ld b,a 
0b26			msdelay: 
0b26 c5				push bc 
0b27				 
0b27			 
0b27 01 41 00			ld bc,041h 
0b2a cd 42 0b			call delayloop 
0b2d c1				pop bc 
0b2e 05				dec b 
0b2f 20 f5			jr nz,msdelay 
0b31			 
0b31			;if CPU_CLOCK_8MHZ 
0b31			;msdelay8: 
0b31			;	push bc 
0b31			;	 
0b31			; 
0b31			;	ld bc,041h 
0b31			;	call delayloop 
0b31			;	pop bc 
0b31			;	dec b 
0b31			;	jr nz,msdelay8 
0b31			;endif 
0b31			 
0b31			 
0b31 c1				pop bc 
0b32 c9				ret 
0b33			 
0b33			 
0b33			delay250ms: 
0b33				;push de 
0b33 01 00 40			ld bc, 04000h 
0b36 c3 42 0b			jp delayloop 
0b39			delay500ms: 
0b39				;push de 
0b39 01 00 80			ld bc, 08000h 
0b3c c3 42 0b			jp delayloop 
0b3f			delay1s: 
0b3f				;push bc 
0b3f			   ; Clobbers A, d and e 
0b3f 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b42			delayloop: 
0b42 c5			    push bc 
0b43			 
0b43			if BASE_CPM 
0b43				ld bc, CPM_DELAY_TUNE 
0b43			.cpmloop: 
0b43				push bc 
0b43			 
0b43			endif 
0b43			 
0b43			 
0b43			 
0b43			delayloopi: 
0b43			;	push bc 
0b43			;.dl: 
0b43 cb 47		    bit     0,a    	; 8 
0b45 cb 47		    bit     0,a    	; 8 
0b47 cb 47		    bit     0,a    	; 8 
0b49 e6 ff		    and     255  	; 7 
0b4b 0b			    dec     bc      	; 6 
0b4c 79			    ld      a,c     	; 4 
0b4d b0			    or      b     	; 4 
0b4e c2 43 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b51			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b51				;pop de 
0b51			;pop bc 
0b51			 
0b51			if BASE_CPM 
0b51				pop bc 
0b51				 
0b51			    dec     bc      	; 6 
0b51			    ld      a,c     	; 4 
0b51			    or      b     	; 4 
0b51			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b51				 
0b51			 
0b51			endif 
0b51			;if CPU_CLOCK_8MHZ 
0b51			;    pop bc 
0b51			;    push bc 
0b51			;.dl8: 
0b51			;    bit     0,a    	; 8 
0b51			;    bit     0,a    	; 8 
0b51			;    bit     0,a    	; 8 
0b51			;    and     255  	; 7 
0b51			;    dec     bc      	; 6 
0b51			;    ld      a,c     	; 4 
0b51			;    or      b     	; 4 
0b51			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b51			;endif 
0b51			 
0b51			;if CPU_CLOCK_10MHZ 
0b51			;    pop bc 
0b51			;    push bc 
0b51			;.dl8: 
0b51			;    bit     0,a    	; 8 
0b51			;    bit     0,a    	; 8 
0b51			;    bit     0,a    	; 8 
0b51			;    and     255  	; 7 
0b51			;    dec     bc      	; 6 
0b51			;    ld      a,c     	; 4 
0b51			;    or      b     	; 4 
0b51			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b51			;endif 
0b51 c1			    pop bc 
0b52			 
0b52 c9				ret 
0b53			 
0b53			 
0b53			 
0b53			; eof 
# End of file firmware_general.asm
0b53			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b53			; display routines that use the physical hardware abstraction layer 
0b53			 
0b53			 
0b53			; information window 
0b53			 
0b53			; pass hl with 1st string to display 
0b53			; pass de with 2nd string to display 
0b53			 
0b53			info_panel: 
0b53 e5				push hl 
0b54			 
0b54 2a cf fb			ld hl, (display_fb_active) 
0b57 e5				push hl    ; future de destination 
0b58 21 b4 fd				ld hl, display_fb0 
0b5b 22 cf fb				ld (display_fb_active), hl 
0b5e			 
0b5e			;	call clear_display 
0b5e			 
0b5e				if BASE_CPM 
0b5e				ld a, '.' 
0b5e				else 
0b5e 3e a5			ld a, 165 
0b60				endif 
0b60 cd c7 0b			call fill_display 
0b63			 
0b63			 
0b63 3e 55			ld a, display_row_3 + 5 
0b65 cd d5 0b			call str_at_display 
0b68			 
0b68 e1				pop hl 
0b69 d1				pop de 
0b6a			 
0b6a e5				push hl 
0b6b			 
0b6b			 
0b6b 3e 2d			ld a, display_row_2 + 5 
0b6d cd d5 0b			call str_at_display 
0b70			 
0b70			 
0b70 cd e5 0b			call update_display 
0b73 cd 83 1d			call next_page_prompt 
0b76 cd c2 0b			call clear_display 
0b79			 
0b79				 
0b79 21 13 fd				ld hl, display_fb1 
0b7c 22 cf fb				ld (display_fb_active), hl 
0b7f cd e5 0b			call update_display 
0b82			 
0b82 e1				pop hl 
0b83			 
0b83 c9				ret 
0b84			 
0b84			 
0b84			 
0b84			 
0b84			; TODO windowing? 
0b84			 
0b84			; TODO scroll line up 
0b84			 
0b84			scroll_up: 
0b84			 
0b84 e5				push hl 
0b85 d5				push de 
0b86 c5				push bc 
0b87			 
0b87				; get frame buffer  
0b87			 
0b87 2a cf fb			ld hl, (display_fb_active) 
0b8a e5				push hl    ; future de destination 
0b8b			 
0b8b 11 28 00			ld  de, display_cols 
0b8e 19				add hl, de 
0b8f			 
0b8f d1				pop de 
0b90			 
0b90				;ex de, hl 
0b90 01 9f 00			ld bc, display_fb_len -1  
0b93			;if DEBUG_FORTH_WORDS 
0b93			;	DMARK "SCL" 
0b93			;	CALLMONITOR 
0b93			;endif	 
0b93 ed b0			ldir 
0b95			 
0b95				; wipe bottom row 
0b95			 
0b95			 
0b95 2a cf fb			ld hl, (display_fb_active) 
0b98 11 a0 00			ld de, display_cols*display_rows 
0b9b 19				add hl, de 
0b9c 06 28			ld b, display_cols 
0b9e 3e 20			ld a, ' ' 
0ba0			.scwipe: 
0ba0 77				ld (hl), a 
0ba1 2b				dec hl 
0ba2 10 fc			djnz .scwipe 
0ba4			 
0ba4				;pop hl 
0ba4			 
0ba4 c1				pop bc 
0ba5 d1				pop de 
0ba6 e1				pop hl 
0ba7			 
0ba7 c9				ret 
0ba8			 
0ba8			 
0ba8			;scroll_upo: 
0ba8			;	ld de, display_row_1 
0ba8			 ;	ld hl, display_row_2 
0ba8			;	ld bc, display_cols 
0ba8			;	ldir 
0ba8			;	ld de, display_row_2 
0ba8			 ;	ld hl, display_row_3 
0ba8			;	ld bc, display_cols 
0ba8			;	ldir 
0ba8			;	ld de, display_row_3 
0ba8			 ;	ld hl, display_row_4 
0ba8			;	ld bc, display_cols 
0ba8			;	ldir 
0ba8			 
0ba8			; TODO clear row 4 
0ba8			 
0ba8			;	ret 
0ba8			 
0ba8				 
0ba8			scroll_down: 
0ba8			 
0ba8 e5				push hl 
0ba9 d5				push de 
0baa c5				push bc 
0bab			 
0bab				; get frame buffer  
0bab			 
0bab 2a cf fb			ld hl, (display_fb_active) 
0bae			 
0bae 11 9f 00			ld de, display_fb_len - 1 
0bb1 19				add hl, de 
0bb2			 
0bb2 e5			push hl    ; future de destination 
0bb3			 
0bb3 11 28 00			ld  de, display_cols 
0bb6 ed 52			sbc hl, de 
0bb8			 
0bb8			 
0bb8 d1				pop de 
0bb9			 
0bb9			;	ex de, hl 
0bb9 01 9f 00			ld bc, display_fb_len -1  
0bbc			 
0bbc			 
0bbc				 
0bbc			 
0bbc ed b0			ldir 
0bbe			 
0bbe				; wipe bottom row 
0bbe			 
0bbe			 
0bbe			;	ld hl, (display_fb_active) 
0bbe			;;	ld de, display_cols*display_rows 
0bbe			;;	add hl, de 
0bbe			;	ld b, display_cols 
0bbe			;	ld a, ' ' 
0bbe			;.scwiped: 
0bbe			;	ld (hl), a 
0bbe			;	dec hl 
0bbe			;	djnz .scwiped 
0bbe			 
0bbe				;pop hl 
0bbe			 
0bbe c1				pop bc 
0bbf d1				pop de 
0bc0 e1				pop hl 
0bc1			 
0bc1 c9				ret 
0bc2			;scroll_down: 
0bc2			;	ld de, display_row_4 
0bc2			;	ld hl, display_row_3 
0bc2			;	ld bc, display_cols 
0bc2			;	ldir 
0bc2			;	ld de, display_row_3 
0bc2			; 	ld hl, display_row_2 
0bc2			;	ld bc, display_cols 
0bc2			;	ldir 
0bc2			;	ld de, display_row_2 
0bc2			;	ld hl, display_row_1 
0bc2			;	ld bc, display_cols 
0bc2			;	ldir 
0bc2			;;; TODO clear row 1 
0bc2			;	ret 
0bc2			 
0bc2			 
0bc2			 
0bc2			 
0bc2			 
0bc2			; clear active frame buffer 
0bc2			 
0bc2			clear_display: 
0bc2 3e 20			ld a, ' ' 
0bc4 c3 c7 0b			jp fill_display 
0bc7			 
0bc7			; fill active frame buffer with a char in A 
0bc7			 
0bc7			fill_display: 
0bc7 06 a0			ld b,display_fb_len 
0bc9 2a cf fb			ld hl, (display_fb_active) 
0bcc 77			.fd1:	ld (hl),a 
0bcd 23				inc hl 
0bce 10 fc			djnz .fd1 
0bd0 23				inc hl 
0bd1 3e 00			ld a,0 
0bd3 77				ld (hl),a 
0bd4			 
0bd4			 
0bd4 c9				ret 
0bd5			; Write string (DE) at pos (A) to active frame buffer 
0bd5			 
0bd5 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0bd8 06 00					ld b,0 
0bda 4f					ld c,a 
0bdb 09					add hl,bc 
0bdc 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bdd b7			            OR   A              ;Null terminator? 
0bde c8			            RET  Z              ;Yes, so finished 
0bdf 77					ld (hl),a 
0be0 23				inc hl 
0be1 13			            INC  DE             ;Point to next character 
0be2 18 f8		            JR   .sad1     ;Repeat 
0be4 c9					ret 
0be5			 
0be5			; using current frame buffer write to physical display 
0be5			 
0be5			update_display: 
0be5 e5				push hl 
0be6 2a cf fb			ld hl, (display_fb_active) 
0be9 cd 09 68			call write_display 
0bec e1				pop hl 
0bed c9				ret 
0bee			 
0bee			; TODO scrolling 
0bee			 
0bee			 
0bee			; move cursor right one char 
0bee			cursor_right: 
0bee			 
0bee				; TODO shift right 
0bee				; TODO if beyond max col 
0bee				; TODO       cursor_next_line 
0bee			 
0bee c9				ret 
0bef			 
0bef			 
0bef			cursor_next_line: 
0bef				; TODO first char 
0bef				; TODO line down 
0bef				; TODO if past last row 
0bef				; TODO    scroll up 
0bef			 
0bef c9				ret 
0bf0			 
0bf0			cursor_left: 
0bf0				; TODO shift left 
0bf0				; TODO if beyond left  
0bf0				; TODO     cursor prev line 
0bf0				 
0bf0 c9				ret 
0bf1			 
0bf1			cursor_prev_line: 
0bf1				; TODO last char 
0bf1				; TODO line up 
0bf1				; TODO if past first row 
0bf1				; TODO   scroll down 
0bf1			 
0bf1 c9				ret 
0bf2			 
0bf2			 
0bf2			cout: 
0bf2				; A - char 
0bf2 c9				ret 
0bf3			 
0bf3			 
0bf3			; Display a menu and allow item selection (optional toggle items) 
0bf3			; 
0bf3			; format: 
0bf3			; hl pointer to word array with zero term for items 
0bf3			; e.g.    db item1 
0bf3			;         db .... 
0bf3			;         db 0 
0bf3			; 
0bf3			; a = starting menu item  
0bf3			; 
0bf3			; de = pointer item toggle array   (todo) 
0bf3			; 
0bf3			; returns item selected in a 1-... 
0bf3			; returns 0 if back button pressed 
0bf3			; 
0bf3			; NOTE: Uses system frame buffer to display 
0bf3			; 
0bf3			; LEFT, Q = go back 
0bf3			; RIGHT, SPACE, CR = select 
0bf3			; UP, A - Up 
0bf3			; DOWN, Z - Down 
0bf3			 
0bf3			 
0bf3			 
0bf3			 
0bf3			 
0bf3			menu: 
0bf3			 
0bf3					; keep array pointer 
0bf3			 
0bf3 22 57 fb				ld (store_tmp1), hl 
0bf6 32 55 fb				ld (store_tmp2), a 
0bf9			 
0bf9					; check for key bounce 
0bf9			 
0bf9			if BASE_KEV 
0bf9			 
0bf9 cd 54 6b		.mbounce:	call cin 
0bfc fe 00				cp 0 
0bfe 20 f9				jr nz, .mbounce 
0c00			endif 
0c00					; for ease use ex 
0c00			 
0c00					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0c00 21 b4 fd				ld hl, display_fb0 
0c03 22 cf fb				ld (display_fb_active), hl 
0c06			 
0c06 cd c2 0b		.mloop:		call clear_display 
0c09 cd e5 0b				call update_display 
0c0c			 
0c0c					; draw selection id '>' at 1 
0c0c			 
0c0c					; init start of list display 
0c0c			 
0c0c 3e 05				ld a, 5 
0c0e 32 53 fb				ld (store_tmp3), a   ; display row count 
0c11 3a 55 fb				ld a,( store_tmp2) 
0c14 32 56 fb				ld (store_tmp2+1), a   ; display item count 
0c17			 
0c17					 
0c17			.mitem:	 
0c17			 
0c17			 
0c17 3a 56 fb				ld a,(store_tmp2+1) 
0c1a 6f					ld l, a 
0c1b 26 00				ld h, 0 
0c1d 29					add hl, hl 
0c1e ed 5b 57 fb			ld de, (store_tmp1) 
0c22 19					add hl, de 
0c23 7e					ld a, (hl) 
0c24 23					inc hl 
0c25 66					ld h,(hl) 
0c26 6f					ld l, a 
0c27			 
0c27 cd 1f 0e				call ishlzero 
0c2a 28 1a				jr z, .mdone 
0c2c			 
0c2c eb					ex de, hl 
0c2d 3a 53 fb				ld a, (store_tmp3) 
0c30 cd d5 0b				call str_at_display 
0c33					 
0c33			 
0c33					; next item 
0c33 3a 56 fb				ld a, (store_tmp2+1) 
0c36 3c					inc a 
0c37 32 56 fb				ld (store_tmp2+1), a   ; display item count 
0c3a			 
0c3a			 		; next row 
0c3a			 
0c3a 3a 53 fb				ld a, (store_tmp3) 
0c3d c6 28				add display_cols 
0c3f 32 53 fb				ld (store_tmp3), a 
0c42			 
0c42					; at end of screen? 
0c42			 
0c42 fe 10				cp display_rows*4 
0c44 20 d1				jr nz, .mitem 
0c46			 
0c46			 
0c46			.mdone: 
0c46 cd 1f 0e				call ishlzero 
0c49 28 08				jr z, .nodn 
0c4b			 
0c4b 3e 78				ld a, display_row_4 
0c4d 11 cc 0c				ld de, .mdown 
0c50 cd d5 0b				call str_at_display 
0c53			 
0c53					; draw options to fill the screens with active item on line 1 
0c53					; if current option is 2 or more then display ^ in top 
0c53			 
0c53 3a 55 fb		.nodn:		ld a, (store_tmp2) 
0c56 fe 00				cp 0 
0c58 28 08				jr z, .noup 
0c5a			 
0c5a 3e 00				ld a, 0 
0c5c 11 ca 0c				ld de, .mup 
0c5f cd d5 0b				call str_at_display 
0c62			 
0c62 3e 02		.noup:		ld a, 2 
0c64 11 c8 0c				ld de, .msel 
0c67 cd d5 0b				call str_at_display 
0c6a			 
0c6a					; if current option + 1 is not null then display V in bottom 
0c6a					; get key 
0c6a cd e5 0b				call update_display 
0c6d			 
0c6d			 
0c6d					; handle key 
0c6d			 
0c6d cd 43 6b				call cin_wait 
0c70			 
0c70 fe 05				cp KEY_UP 
0c72 28 2b				jr z, .mgoup 
0c74 fe 61				cp 'a' 
0c76 28 27				jr z, .mgoup 
0c78 fe 0a				cp KEY_DOWN 
0c7a 28 32				jr z, .mgod 
0c7c fe 7a				cp 'z' 
0c7e 28 2e				jr z, .mgod 
0c80 fe 20				cp ' ' 
0c82 28 34				jr z, .goend 
0c84 fe 0c				cp KEY_RIGHT 
0c86 28 30				jr z, .goend 
0c88 fe 0d				cp KEY_CR 
0c8a 28 2c				jr z, .goend 
0c8c fe 71				cp 'q' 
0c8e 28 0b				jr z, .goback 
0c90			 
0c90 fe 0b				cp KEY_LEFT 
0c92 28 07				jr z, .goback 
0c94 fe 08				cp KEY_BS 
0c96 28 03				jr z, .goback 
0c98 c3 06 0c				jp .mloop 
0c9b			 
0c9b			.goback: 
0c9b 3e 00			ld a, 0 
0c9d 18 1d			jr .goend2 
0c9f			 
0c9f				; move up one 
0c9f			.mgoup: 
0c9f 3a 55 fb				ld a, (store_tmp2) 
0ca2 fe 00				cp 0 
0ca4 ca 06 0c				jp z, .mloop 
0ca7 3d					dec a 
0ca8 32 55 fb				ld (store_tmp2), a 
0cab c3 06 0c				jp .mloop 
0cae			 
0cae				; move down one 
0cae			.mgod: 
0cae 3a 55 fb				ld a, (store_tmp2) 
0cb1 3c					inc a 
0cb2 32 55 fb				ld (store_tmp2), a 
0cb5 c3 06 0c				jp .mloop 
0cb8			 
0cb8			 
0cb8			.goend: 
0cb8					; get selected item number 
0cb8			 
0cb8 3a 55 fb				ld a, (store_tmp2) 
0cbb 3c					inc a 
0cbc			 
0cbc			.goend2: 
0cbc f5					push af 
0cbd			 
0cbd					; restore active fb 
0cbd					; TODO BUG assumes fb1 
0cbd			 
0cbd 21 13 fd				ld hl, display_fb1 
0cc0 22 cf fb				ld (display_fb_active), hl 
0cc3			 
0cc3					; restore main regs 
0cc3			 
0cc3			 
0cc3 cd e5 0b				call update_display 
0cc6			 
0cc6 f1					pop af 
0cc7			 
0cc7 c9				ret 
0cc8			 
0cc8 .. 00		.msel:   db ">",0 
0cca .. 00		.mup:   db "^",0 
0ccc .. 00		.mdown:   db "v",0 
0cce			 
0cce			 
0cce			; eof 
0cce			 
# End of file firmware_display.asm
0cce			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cce			; random number generators 
0cce			 
0cce			 
0cce			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cce			 
0cce			 
0cce			;-----> Generate a random number 
0cce			; output a=answer 0<=a<=255 
0cce			; all registers are preserved except: af 
0cce			random: 
0cce e5			        push    hl 
0ccf d5			        push    de 
0cd0 2a b1 fb		        ld      hl,(randData) 
0cd3 ed 5f		        ld      a,r 
0cd5 57			        ld      d,a 
0cd6 5e			        ld      e,(hl) 
0cd7 19			        add     hl,de 
0cd8 85			        add     a,l 
0cd9 ac			        xor     h 
0cda 22 b1 fb		        ld      (randData),hl 
0cdd d1			        pop     de 
0cde e1			        pop     hl 
0cdf c9			        ret 
0ce0			 
0ce0			 
0ce0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ce0			 
0ce0			 
0ce0			 
0ce0			;------LFSR------ 
0ce0			;James Montelongo 
0ce0			;optimized by Spencer Putt 
0ce0			;out: 
0ce0			; a = 8 bit random number 
0ce0			RandLFSR: 
0ce0 21 b7 fb		        ld hl,LFSRSeed+4 
0ce3 5e			        ld e,(hl) 
0ce4 23			        inc hl 
0ce5 56			        ld d,(hl) 
0ce6 23			        inc hl 
0ce7 4e			        ld c,(hl) 
0ce8 23			        inc hl 
0ce9 7e			        ld a,(hl) 
0cea 47			        ld b,a 
0ceb cb 13		        rl e  
0ced cb 12			rl d 
0cef cb 11		        rl c  
0cf1 17				rla 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd cb 11		        rl c  
0cff 17				rla 
0d00 67			        ld h,a 
0d01 cb 13		        rl e  
0d03 cb 12			rl d 
0d05 cb 11		        rl c  
0d07 17				rla 
0d08 a8			        xor b 
0d09 cb 13		        rl e  
0d0b cb 12			rl d 
0d0d ac			        xor h 
0d0e a9			        xor c 
0d0f aa			        xor d 
0d10 21 b9 fb		        ld hl,LFSRSeed+6 
0d13 11 ba fb		        ld de,LFSRSeed+7 
0d16 01 07 00		        ld bc,7 
0d19 ed b8		        lddr 
0d1b 12			        ld (de),a 
0d1c c9			        ret 
0d1d			 
0d1d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d1d			 
0d1d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d1d			 
0d1d			 
0d1d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d1d			 
0d1d			prng16: 
0d1d			;Inputs: 
0d1d			;   (seed1) contains a 16-bit seed value 
0d1d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d1d			;Outputs: 
0d1d			;   HL is the result 
0d1d			;   BC is the result of the LCG, so not that great of quality 
0d1d			;   DE is preserved 
0d1d			;Destroys: 
0d1d			;   AF 
0d1d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d1d			;160cc 
0d1d			;26 bytes 
0d1d 2a ab fb		    ld hl,(seed1) 
0d20 44			    ld b,h 
0d21 4d			    ld c,l 
0d22 29			    add hl,hl 
0d23 29			    add hl,hl 
0d24 2c			    inc l 
0d25 09			    add hl,bc 
0d26 22 ab fb		    ld (seed1),hl 
0d29 2a a9 fb		    ld hl,(seed2) 
0d2c 29			    add hl,hl 
0d2d 9f			    sbc a,a 
0d2e e6 2d		    and %00101101 
0d30 ad			    xor l 
0d31 6f			    ld l,a 
0d32 22 a9 fb		    ld (seed2),hl 
0d35 09			    add hl,bc 
0d36 c9			    ret 
0d37			 
0d37			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d37			 
0d37			rand32: 
0d37			;Inputs: 
0d37			;   (seed1_0) holds the lower 16 bits of the first seed 
0d37			;   (seed1_1) holds the upper 16 bits of the first seed 
0d37			;   (seed2_0) holds the lower 16 bits of the second seed 
0d37			;   (seed2_1) holds the upper 16 bits of the second seed 
0d37			;   **NOTE: seed2 must be non-zero 
0d37			;Outputs: 
0d37			;   HL is the result 
0d37			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d37			;Destroys: 
0d37			;   AF 
0d37			;Tested and passes all CAcert tests 
0d37			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d37			;it has a period of 18,446,744,069,414,584,320 
0d37			;roughly 18.4 quintillion. 
0d37			;LFSR taps: 0,2,6,7  = 11000101 
0d37			;291cc 
0d37			;seed1_0=$+1 
0d37			;    ld hl,12345 
0d37			;seed1_1=$+1 
0d37			;    ld de,6789 
0d37			;    ld b,h 
0d37			;    ld c,l 
0d37			;    add hl,hl \ rl e \ rl d 
0d37			;    add hl,hl \ rl e \ rl d 
0d37			;    inc l 
0d37			;    add hl,bc 
0d37			;    ld (seed1_0),hl 
0d37			;    ld hl,(seed1_1) 
0d37			;    adc hl,de 
0d37			;    ld (seed1_1),hl 
0d37			;    ex de,hl 
0d37			;seed2_0=$+1 
0d37			;    ld hl,9876 
0d37			;seed2_1=$+1 
0d37			;    ld bc,54321 
0d37			;    add hl,hl \ rl c \ rl b 
0d37			;    ld (seed2_1),bc 
0d37			;    sbc a,a 
0d37			;    and %11000101 
0d37			;    xor l 
0d37			;    ld l,a 
0d37			;    ld (seed2_0),hl 
0d37			;    ex de,hl 
0d37			;    add hl,bc 
0d37			;    ret 
0d37			; 
0d37			 
0d37			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d37			; 20 bytes, 86 cycles (excluding ret) 
0d37			 
0d37			; returns   hl = pseudorandom number 
0d37			; corrupts   a 
0d37			 
0d37			; generates 16-bit pseudorandom numbers with a period of 65535 
0d37			; using the xorshift method: 
0d37			 
0d37			; hl ^= hl << 7 
0d37			; hl ^= hl >> 9 
0d37			; hl ^= hl << 8 
0d37			 
0d37			; some alternative shift triplets which also perform well are: 
0d37			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d37			 
0d37			;  org 32768 
0d37			 
0d37			xrnd: 
0d37 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0d3a 3e 00		  ld a,0 
0d3c bd			  cp l 
0d3d 20 02		  jr nz, .xrnd1 
0d3f 2e 01		  ld l, 1 
0d41			.xrnd1: 
0d41			 
0d41 7c			  ld a,h 
0d42 1f			  rra 
0d43 7d			  ld a,l 
0d44 1f			  rra 
0d45 ac			  xor h 
0d46 67			  ld h,a 
0d47 7d			  ld a,l 
0d48 1f			  rra 
0d49 7c			  ld a,h 
0d4a 1f			  rra 
0d4b ad			  xor l 
0d4c 6f			  ld l,a 
0d4d ac			  xor h 
0d4e 67			  ld h,a 
0d4f			 
0d4f 22 af fb		  ld (xrandc),hl 
0d52			 
0d52 c9			  ret 
0d53			;  
0d53			 
0d53			 
0d53			;;;; int maths 
0d53			 
0d53			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d53			; Divide 16-bit values (with 16-bit result) 
0d53			; In: Divide BC by divider DE 
0d53			; Out: BC = result, HL = rest 
0d53			; 
0d53			Div16: 
0d53 21 00 00		    ld hl,0 
0d56 78			    ld a,b 
0d57 06 08		    ld b,8 
0d59			Div16_Loop1: 
0d59 17			    rla 
0d5a ed 6a		    adc hl,hl 
0d5c ed 52		    sbc hl,de 
0d5e 30 01		    jr nc,Div16_NoAdd1 
0d60 19			    add hl,de 
0d61			Div16_NoAdd1: 
0d61 10 f6		    djnz Div16_Loop1 
0d63 17			    rla 
0d64 2f			    cpl 
0d65 47			    ld b,a 
0d66 79			    ld a,c 
0d67 48			    ld c,b 
0d68 06 08		    ld b,8 
0d6a			Div16_Loop2: 
0d6a 17			    rla 
0d6b ed 6a		    adc hl,hl 
0d6d ed 52		    sbc hl,de 
0d6f 30 01		    jr nc,Div16_NoAdd2 
0d71 19			    add hl,de 
0d72			Div16_NoAdd2: 
0d72 10 f6		    djnz Div16_Loop2 
0d74 17			    rla 
0d75 2f			    cpl 
0d76 41			    ld b,c 
0d77 4f			    ld c,a 
0d78 c9			ret 
0d79			 
0d79			 
0d79			;http://z80-heaven.wikidot.com/math 
0d79			; 
0d79			;Inputs: 
0d79			;     DE and A are factors 
0d79			;Outputs: 
0d79			;     A is not changed 
0d79			;     B is 0 
0d79			;     C is not changed 
0d79			;     DE is not changed 
0d79			;     HL is the product 
0d79			;Time: 
0d79			;     342+6x 
0d79			; 
0d79			Mult16: 
0d79			 
0d79 06 08		     ld b,8          ;7           7 
0d7b 21 00 00		     ld hl,0         ;10         10 
0d7e 29			       add hl,hl     ;11*8       88 
0d7f 07			       rlca          ;4*8        32 
0d80 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d82 19			         add hl,de   ;--         -- 
0d83 10 f9		       djnz $-5      ;13*7+8     99 
0d85 c9			ret 
0d86			 
0d86			; 
0d86			; Square root of 16-bit value 
0d86			; In:  HL = value 
0d86			; Out:  D = result (rounded down) 
0d86			; 
0d86			;Sqr16: 
0d86			;    ld de,#0040 
0d86			;    ld a,l 
0d86			;    ld l,h 
0d86			;    ld h,d 
0d86			;    or a 
0d86			;    ld b,8 
0d86			;Sqr16_Loop: 
0d86			;    sbc hl,de 
0d86			;    jr nc,Sqr16_Skip 
0d86			;    add hl,de 
0d86			;Sqr16_Skip: 
0d86			;    ccf 
0d86			;    rl d 
0d86			;    add a,a 
0d86			;    adc hl,hl 
0d86			;    add a,a 
0d86			;    adc hl,hl 
0d86			;    djnz Sqr16_Loop 
0d86			;    ret 
0d86			; 
0d86			; 
0d86			; Divide 8-bit values 
0d86			; In: Divide E by divider C 
0d86			; Out: A = result, B = rest 
0d86			; 
0d86			Div8: 
0d86 af			    xor a 
0d87 06 08		    ld b,8 
0d89			Div8_Loop: 
0d89 cb 13		    rl e 
0d8b 17			    rla 
0d8c 91			    sub c 
0d8d 30 01		    jr nc,Div8_NoAdd 
0d8f 81			    add a,c 
0d90			Div8_NoAdd: 
0d90 10 f7		    djnz Div8_Loop 
0d92 47			    ld b,a 
0d93 7b			    ld a,e 
0d94 17			    rla 
0d95 2f			    cpl 
0d96 c9			    ret 
0d97			 
0d97			; 
0d97			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d97			; In: Multiply A with DE 
0d97			; Out: HL = result 
0d97			; 
0d97			Mult12U: 
0d97 2e 00		    ld l,0 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd0 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd0: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd1 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd1: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd2 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd2: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd3 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd3: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae 30 01		    jr nc,Mult12U_NoAdd4 
0db0 19			    add hl,de 
0db1			Mult12U_NoAdd4: 
0db1 29			    add hl,hl 
0db2 87			    add a,a 
0db3 30 01		    jr nc,Mult12U_NoAdd5 
0db5 19			    add hl,de 
0db6			Mult12U_NoAdd5: 
0db6 29			    add hl,hl 
0db7 87			    add a,a 
0db8 30 01		    jr nc,Mult12U_NoAdd6 
0dba 19			    add hl,de 
0dbb			Mult12U_NoAdd6: 
0dbb 29			    add hl,hl 
0dbc 87			    add a,a 
0dbd d0			    ret nc 
0dbe 19			    add hl,de 
0dbf c9			    ret 
0dc0			 
0dc0			; 
0dc0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dc0			; In: Multiply A with DE 
0dc0			;      Put lowest value in A for most efficient calculation 
0dc0			; Out: HL = result 
0dc0			; 
0dc0			Mult12R: 
0dc0 21 00 00		    ld hl,0 
0dc3			Mult12R_Loop: 
0dc3 cb 3f		    srl a 
0dc5 30 01		    jr nc,Mult12R_NoAdd 
0dc7 19			    add hl,de 
0dc8			Mult12R_NoAdd: 
0dc8 cb 23		    sla e 
0dca cb 12		    rl d 
0dcc b7			    or a 
0dcd c2 c3 0d		    jp nz,Mult12R_Loop 
0dd0 c9			    ret 
0dd1			 
0dd1			; 
0dd1			; Multiply 16-bit values (with 32-bit result) 
0dd1			; In: Multiply BC with DE 
0dd1			; Out: BCHL = result 
0dd1			; 
0dd1			Mult32: 
0dd1 79			    ld a,c 
0dd2 48			    ld c,b 
0dd3 21 00 00		    ld hl,0 
0dd6 06 10		    ld b,16 
0dd8			Mult32_Loop: 
0dd8 29			    add hl,hl 
0dd9 17			    rla 
0dda cb 11		    rl c 
0ddc 30 07		    jr nc,Mult32_NoAdd 
0dde 19			    add hl,de 
0ddf ce 00		    adc a,0 
0de1 d2 e5 0d		    jp nc,Mult32_NoAdd 
0de4 0c			    inc c 
0de5			Mult32_NoAdd: 
0de5 10 f1		    djnz Mult32_Loop 
0de7 41			    ld b,c 
0de8 4f			    ld c,a 
0de9 c9			    ret 
0dea			 
0dea			 
0dea			 
0dea			; 
0dea			; Multiply 8-bit values 
0dea			; In:  Multiply H with E 
0dea			; Out: HL = result 
0dea			; 
0dea			Mult8: 
0dea 16 00		    ld d,0 
0dec 6a			    ld l,d 
0ded 06 08		    ld b,8 
0def			Mult8_Loop: 
0def 29			    add hl,hl 
0df0 30 01		    jr nc,Mult8_NoAdd 
0df2 19			    add hl,de 
0df3			Mult8_NoAdd: 
0df3 10 fa		    djnz Mult8_Loop 
0df5 c9			    ret 
0df6			 
0df6			 
0df6			 
0df6			 
0df6			 
0df6			 
0df6			 
0df6			 
0df6			;;http://z80-heaven.wikidot.com/math 
0df6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df6			; 
0df6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df6			;     ld a,16        ;7 
0df6			;     ld hl,0        ;10 
0df6			;     jp $+5         ;10 
0df6			;.DivLoop: 
0df6			;       add hl,bc    ;-- 
0df6			;       dec a        ;64 
0df6			;       jr z,.DivLoopEnd        ;86 
0df6			; 
0df6			;       sla e        ;128 
0df6			;       rl d         ;128 
0df6			;       adc hl,hl    ;240 
0df6			;       sbc hl,bc    ;240 
0df6			;       jr nc,.DivLoop ;23|21 
0df6			;       inc e        ;-- 
0df6			;       jp .DivLoop+1 
0df6			; 
0df6			;.DivLoopEnd: 
0df6			 
0df6			;HL_Div_C: 
0df6			;Inputs: 
0df6			;     HL is the numerator 
0df6			;     C is the denominator 
0df6			;Outputs: 
0df6			;     A is the remainder 
0df6			;     B is 0 
0df6			;     C is not changed 
0df6			;     DE is not changed 
0df6			;     HL is the quotient 
0df6			; 
0df6			;       ld b,16 
0df6			;       xor a 
0df6			;         add hl,hl 
0df6			;         rla 
0df6			;         cp c 
0df6			;         jr c,$+4 
0df6			;           inc l 
0df6			;           sub c 
0df6			;         djnz $-7 
0df6			 
0df6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df6			 
0df6			addatohl: 
0df6 85			    add   a, l    ; A = A+L 
0df7 6f			    ld    l, a    ; L = A+L 
0df8 8c			    adc   a, h    ; A = A+L+H+carry 
0df9 95			    sub   l       ; A = H+carry 
0dfa 67			    ld    h, a    ; H = H+carry 
0dfb c9			ret 
0dfc			 
0dfc			addatode: 
0dfc 83			    add   a, e    ; A = A+L 
0dfd 5f			    ld    e, a    ; L = A+L 
0dfe 8a			    adc   a, d    ; A = A+L+H+carry 
0dff 93			    sub   e       ; A = H+carry 
0e00 57			    ld    d, a    ; H = H+carry 
0e01 c9			ret 
0e02			 
0e02			 
0e02			addatobc: 
0e02 81			    add   a, c    ; A = A+L 
0e03 4f			    ld    c, a    ; L = A+L 
0e04 88			    adc   a, b    ; A = A+L+H+carry 
0e05 91			    sub   c       ; A = H+carry 
0e06 47			    ld    b, a    ; H = H+carry 
0e07 c9			ret 
0e08			 
0e08			subafromhl: 
0e08			   ; If A=0 do nothing 
0e08			    ; Otherwise flip A's sign. Since 
0e08			    ; the upper byte becomes -1, also 
0e08			    ; substract 1 from H. 
0e08 ed 44		    neg 
0e0a ca 13 0e		    jp    z, Skip 
0e0d 25			    dec   h 
0e0e			     
0e0e			    ; Now add the low byte as usual 
0e0e			    ; Two's complement takes care of 
0e0e			    ; ensuring the result is correct 
0e0e 85			    add   a, l 
0e0f 6f			    ld    l, a 
0e10 8c			    adc   a, h 
0e11 95			    sub   l 
0e12 67			    ld    h, a 
0e13			Skip: 
0e13 c9				ret 
0e14			 
0e14			 
0e14			; compare hl and de 
0e14			; returns:  
0e14			; if hl = de, z=1, s=0, c0=0 
0e14			; if hl > de, z=0, s=0, c=0 
0e14			; if hl < de, z=0, s=1, c=1 
0e14			cmp16:	 
0e14 b7				or a 
0e15 ed 52			sbc hl,de 
0e17 e0				ret po 
0e18 7c				ld a,h 
0e19 1f				rra 
0e1a ee 40			xor 01000000B 
0e1c 37				scf 
0e1d 8f				adc a,a 
0e1e c9				ret 
0e1f			 
0e1f			 
0e1f			; test if hl contains zero   - A is destroyed 
0e1f			 
0e1f			ishlzero:    
0e1f b7				or a     ; reset flags 
0e20 7c				ld a, h 
0e21 b5				or l        	 
0e22			 
0e22 c9				ret 
0e23			 
0e23			 
0e23			 
0e23			 
0e23			if FORTH_ENABLE_FLOATMATH 
0e23			;include "float/bbcmath.z80" 
0e23			include "float/lpfpcalc.asm" 
0e23			endif 
0e23			 
0e23			 
0e23			; eof 
0e23			 
# End of file firmware_maths.asm
0e23			include "firmware_strings.asm"   ; string handling  
0e23			 
0e23			 
0e23			; TODO string len 
0e23			; input text string, end on cr with zero term 
0e23			; a offset into frame buffer to start prompt 
0e23			; d is max length 
0e23			; e is display size TODO 
0e23			; c is current cursor position 
0e23			; hl is ptr to where string will be stored 
0e23			 
0e23			 
0e23			; TODO check limit of buffer for new inserts 
0e23			; TODO check insert does not push beyond buffer 
0e23			; TODO scroll in a limited display area 
0e23			; TODO scroll whole screen on page wrap 
0e23			 
0e23			 
0e23			; TODO handle KEY_PREVWORD 
0e23			; TODO handle KEY_NEXTWORD 
0e23			; TODO handle KEY_HOME 
0e23			; TODO handle KEY_END 
0e23			; TODO use LCD cursor? 
0e23			 
0e23 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e26 81					add c 
0e27 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0e2a 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0e2d 79					ld a, c 
0e2e cd f6 0d				call addatohl 
0e31 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e34 7a					ld a,d 
0e35 32 69 fe			        ld (input_size), a       ; save length of input area 
0e38 79					ld a, c 
0e39 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0e3c 7b					ld a,e 
0e3d 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e40					 
0e40					 
0e40			 
0e40			;		ld a,(input_ptr) 
0e40			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e40			 
0e40			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e40					; init cursor shape if not set by the cin routines 
0e40 21 c7 fb				ld hl, cursor_shape 
0e43 3e ff				ld a, 255 
0e45 77					ld (hl), a 
0e46 23					inc hl 
0e47 3e 00				ld a, 0 
0e49 77					ld (hl), a 
0e4a			 
0e4a 3e 0f				ld a, CUR_BLINK_RATE 
0e4c 32 63 fe				ld (input_cur_flash), a 
0e4f 3e 01				ld a, 1 
0e51 32 62 fe				ld (input_cur_onoff),a 
0e54			 
0e54			;	if DEBUG_INPUT 
0e54			;		push af 
0e54			;		ld a, 'I' 
0e54			;		ld (debug_mark),a 
0e54			;		pop af 
0e54			;		CALLMONITOR 
0e54			;	endif 
0e54			.is1:		; main entry loop 
0e54			 
0e54			 
0e54			 
0e54					; pause 1ms 
0e54			 
0e54 3e 01				ld a, 1 
0e56 cd 24 0b				call aDelayInMS 
0e59			 
0e59					; dec flash counter 
0e59 3a 63 fe				ld a, (input_cur_flash) 
0e5c 3d					dec a 
0e5d 32 63 fe				ld (input_cur_flash), a 
0e60 fe 00				cp 0 
0e62 20 0d				jr nz, .nochgstate 
0e64			 
0e64			 
0e64					; change state 
0e64 3a 62 fe				ld a,(input_cur_onoff) 
0e67 ed 44				neg 
0e69 32 62 fe				ld (input_cur_onoff),a 
0e6c			 
0e6c			 
0e6c					; reset on change of state 
0e6c 3e 0f				ld a, CUR_BLINK_RATE 
0e6e 32 63 fe				ld (input_cur_flash), a 
0e71			 
0e71			.nochgstate: 
0e71					 
0e71					 
0e71			 
0e71					; display cursor  
0e71			 
0e71			;		ld hl, (input_start) 
0e71			;		ld a, (input_cursor) 
0e71			;		call addatohl 
0e71			 
0e71					; get char under cursor and replace with cursor 
0e71 2a 6c fe		ld hl, (input_ptr) 
0e74			;		ld a, (hl) 
0e74			;		ld (input_under_cursor),a 
0e74			;		ld a, '_' 
0e74			;		ld (hl), a 
0e74			 
0e74					; display string 
0e74			 
0e74 ed 5b 6a fe			ld de, (input_start) 
0e78 3a 67 fe				ld a, (input_at_pos) 
0e7b cd d5 0b				call str_at_display 
0e7e			;	        call update_display 
0e7e			 
0e7e					; find place to put the cursor 
0e7e			;		add h 
0e7e			;		ld l, display_row_1 
0e7e			;		sub l 
0e7e			; (input_at_pos) 
0e7e					;ld c, a 
0e7e			;		ld a, (input_cursor) 
0e7e			;		ld l, (input_at_pos) 
0e7e			;		;ld b, h 
0e7e			;		add l 
0e7e			;		ld (input_at_cursor),a 
0e7e					;ld l,h 
0e7e			 
0e7e			;		ld h, 0 
0e7e			;		ld l,(input_at_pos) 
0e7e			;		ld a, (input_cursor) 
0e7e			;		call addatohl 
0e7e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e7e			;		call subafromhl 
0e7e			;		ld a,l 
0e7e			;		ld (input_at_cursor), a 
0e7e			 
0e7e				if DEBUG_INPUT 
0e7e					ld a, (hardware_diag) 
0e7e					cp 0 
0e7e					jr z, .skip_input_diag 
0e7e			 
0e7e					ld a,(input_at_pos) 
0e7e					ld hl, LFSRSeed 
0e7e					call hexout 
0e7e					ld a, (input_cursor) 
0e7e					ld hl, LFSRSeed+2 
0e7e					call hexout 
0e7e					ld a,(input_at_cursor) 
0e7e					ld hl, LFSRSeed+4 
0e7e					call hexout 
0e7e			 
0e7e					ld a,(input_cur_onoff) 
0e7e					ld hl, LFSRSeed+6 
0e7e					call hexout 
0e7e			 
0e7e					ld a,(input_cur_flash) 
0e7e					ld hl, LFSRSeed+8 
0e7e					call hexout 
0e7e			 
0e7e					ld a,(input_len) 
0e7e					ld hl, LFSRSeed+10 
0e7e					call hexout 
0e7e					ld hl, LFSRSeed+12 
0e7e					ld a, 0 
0e7e					ld (hl),a 
0e7e					ld a, display_row_4 
0e7e					ld de, LFSRSeed 
0e7e					call str_at_display 
0e7e					.skip_input_diag: 
0e7e				endif 
0e7e			 
0e7e					; decide on if we are showing the cursor this time round 
0e7e			 
0e7e 3a 62 fe				ld a, (input_cur_onoff) 
0e81 fe ff				cp 255 
0e83 28 13				jr z, .skipcur 
0e85			 
0e85			 
0e85 3a 65 fe				ld a,(input_at_cursor) 
0e88 11 c7 fb				ld de, cursor_shape 
0e8b cd d5 0b				call str_at_display 
0e8e			 
0e8e					; save length of current input string 
0e8e 2a 6a fe				ld hl, (input_start) 
0e91 cd 54 12				call strlenz 
0e94 7d					ld a,l 
0e95 32 5d fe				ld (input_len),a 
0e98			 
0e98			.skipcur: 
0e98			 
0e98 cd e5 0b			        call update_display 
0e9b					 
0e9b			 
0e9b			 
0e9b					; wait 
0e9b				 
0e9b					; TODO loop without wait to flash the cursor and char under cursor	 
0e9b cd 54 6b				call cin    ; _wait 
0e9e			 
0e9e fe 00				cp 0 
0ea0 ca 54 0e				jp z, .is1 
0ea3			 
0ea3					; get ptr to char to input into 
0ea3			 
0ea3 4f					ld c,a 
0ea4 2a 6a fe				ld hl, (input_start) 
0ea7 3a 58 fe				ld a, (input_cursor) 
0eaa cd f6 0d				call addatohl 
0ead 22 6c fe				ld (input_ptr), hl 
0eb0 79					ld a,c 
0eb1			 
0eb1					; replace char under cursor 
0eb1			 
0eb1			;		ld hl, (input_ptr) 
0eb1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0eb1			;		ld (hl), a 
0eb1			 
0eb1			;	if DEBUG_INPUT 
0eb1			;		push af 
0eb1			;		ld a, 'i' 
0eb1			;		ld (debug_mark),a 
0eb1			;		pop af 
0eb1			;		CALLMONITOR 
0eb1			;	endif 
0eb1 fe 0e				cp KEY_HOME 
0eb3 20 0e				jr nz, .iske 
0eb5			 
0eb5 3a 67 fe				ld a, (input_at_pos) 
0eb8 32 65 fe				ld (input_at_cursor),a 
0ebb 3e 00				ld a, 0 
0ebd 32 58 fe				ld (input_cursor), a 
0ec0 c3 54 0e				jp .is1 
0ec3					 
0ec3 fe 0f		.iske:		cp KEY_END 
0ec5 20 03				jr nz, .isknw 
0ec7 c3 54 0e				jp .is1 
0eca			 
0eca fe 06		.isknw:		cp KEY_NEXTWORD 
0ecc 20 1b				jr nz, .iskpw 
0ece			 
0ece 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
0ed1 7e					ld a,(hl)	 
0ed2 fe 00				cp 0 
0ed4 ca 54 0e				jp z, .is1    ; end of string 
0ed7 fe 20				cp ' ' 
0ed9 ca 54 0e				jp z, .is1    ; end of word 
0edc 23					inc hl 
0edd 22 6c fe				ld (input_ptr), hl 
0ee0 3a 65 fe				ld a, (input_at_cursor) 
0ee3 3c					inc a 
0ee4 32 65 fe				ld (input_at_cursor), a 
0ee7 18 e5				jr .isknwm 
0ee9			 
0ee9 fe 07		.iskpw:		cp KEY_PREVWORD 
0eeb 20 1b				jr nz, .iskl 
0eed			.iskpwm:	 
0eed 2a 6c fe				ld hl, (input_ptr) 
0ef0 7e					ld a,(hl)	 
0ef1 fe 00				cp 0  
0ef3 ca 54 0e				jp z, .is1    ; end of string 
0ef6 fe 20				cp ' ' 
0ef8 ca 54 0e				jp z, .is1    ; end of word 
0efb 2b					dec hl 
0efc 22 6c fe				ld (input_ptr), hl 
0eff 3a 65 fe				ld a, (input_at_cursor) 
0f02 3d					dec a 
0f03 32 65 fe				ld (input_at_cursor), a 
0f06 18 e5				jr .iskpwm 
0f08			 
0f08			 
0f08 fe 0b		.iskl:		cp KEY_LEFT 
0f0a 20 27				jr nz, .isk1 
0f0c			 
0f0c 3a 58 fe				ld a, (input_cursor) 
0f0f			 
0f0f fe 00				cp 0 
0f11 ca 54 0e				jp z, .is1 		; at start of line to ignore  
0f14			 
0f14 3d					dec  a 		; TODO check underflow 
0f15 32 58 fe				ld (input_cursor), a 
0f18			 
0f18 2a 6c fe				ld hl, (input_ptr) 
0f1b 2b					dec hl 
0f1c 22 6c fe				ld (input_ptr), hl 
0f1f					 
0f1f 3a 65 fe				ld a, (input_at_cursor) 
0f22 3d					dec a 
0f23 32 65 fe				ld (input_at_cursor), a 
0f26			 
0f26 3e 01				ld a, 1		; show cursor moving 
0f28 32 62 fe				ld (input_cur_onoff),a 
0f2b 3e 0f				ld a, CUR_BLINK_RATE 
0f2d 32 63 fe				ld (input_cur_flash), a 
0f30			 
0f30 c3 54 0e				jp .is1 
0f33			 
0f33 fe 0c		.isk1:		cp KEY_RIGHT 
0f35 20 2a				jr nz, .isk2 
0f37			 
0f37 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f3a 5f					ld e,a 
0f3b 3a 58 fe				ld a, (input_cursor) 
0f3e bb					cp e 
0f3f ca 54 0e				jp z, .is1		; at the end of string so dont go right 
0f42			 
0f42 3c					inc  a 		; TODO check overflow 
0f43 32 58 fe				ld (input_cursor), a 
0f46			 
0f46 3a 65 fe				ld a, (input_at_cursor) 
0f49 3c					inc a 
0f4a 32 65 fe				ld (input_at_cursor), a 
0f4d			 
0f4d 2a 6c fe				ld hl, (input_ptr) 
0f50 23					inc hl 
0f51 22 6c fe				ld (input_ptr), hl 
0f54			 
0f54 3e 01				ld a, 1		; show cursor moving 
0f56 32 62 fe				ld (input_cur_onoff),a 
0f59 3e 0f				ld a, CUR_BLINK_RATE 
0f5b 32 63 fe				ld (input_cur_flash), a 
0f5e			 
0f5e c3 54 0e				jp .is1 
0f61			 
0f61 fe 05		.isk2:		cp KEY_UP 
0f63			 
0f63 20 26				jr nz, .isk3 
0f65			 
0f65					; swap last command with the current on 
0f65			 
0f65					; move cursor to start of string 
0f65 2a 6a fe				ld hl, (input_start) 
0f68 22 6c fe				ld (input_ptr), hl 
0f6b			 
0f6b 3a 67 fe				ld a, (input_at_pos) 
0f6e 32 65 fe				ld (input_at_cursor), a 
0f71			 
0f71 3e 00				ld a, 0 
0f73 32 58 fe				ld (input_cursor), a 
0f76					 
0f76					; swap input and last command buffers 
0f76			 
0f76 21 fb f5				ld hl, os_cli_cmd 
0f79 11 fa f6				ld de, os_last_cmd 
0f7c 06 ff				ld b, 255 
0f7e 7e			.swap1:		ld a, (hl) 
0f7f 4f					ld c,a 
0f80 1a					ld a, (de) 
0f81 77					ld (hl), a 
0f82 79					ld a,c 
0f83 12					ld (de),a 
0f84 23					inc hl 
0f85 13					inc de 
0f86 10 f6				djnz .swap1 
0f88			 
0f88			 
0f88			 
0f88			 
0f88			 
0f88 c3 54 0e				jp .is1 
0f8b			 
0f8b fe 08		.isk3:		cp KEY_BS 
0f8d 20 3c				jr nz, .isk4 
0f8f			 
0f8f 3a 58 fe				ld a, (input_cursor) 
0f92			 
0f92 fe 00				cp 0 
0f94 ca 54 0e				jp z, .is1 		; at start of line to ignore  
0f97			 
0f97 3d					dec  a 		; TODO check underflow 
0f98 32 58 fe				ld (input_cursor), a 
0f9b			 
0f9b					; hl is source 
0f9b					; de needs to be source - 1 
0f9b			 
0f9b			;		ld a, 0 
0f9b			;		dec hl 
0f9b			;		ld (hl), a 
0f9b			 
0f9b 2a 6c fe				ld hl, (input_ptr) 
0f9e 2b					dec hl 
0f9f 22 6c fe				ld (input_ptr), hl 
0fa2			 
0fa2					; shift all data 
0fa2			 
0fa2 e5					push hl 
0fa3 23					inc hl 
0fa4 d1					pop de 
0fa5 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0fa8 4f					ld c,a 
0fa9 06 00				ld b,0 
0fab ed b0				ldir  
0fad			 
0fad			 
0fad			 
0fad			 
0fad 3a 65 fe				ld a, (input_at_cursor) 
0fb0 3d					dec a 
0fb1 32 65 fe				ld (input_at_cursor), a 
0fb4			 
0fb4			 
0fb4 3e 01				ld a, 1		; show cursor moving 
0fb6 32 62 fe				ld (input_cur_onoff),a 
0fb9 3e 0f				ld a, CUR_BLINK_RATE 
0fbb 32 63 fe				ld (input_cur_flash), a 
0fbe			 
0fbe					; remove char 
0fbe 3a 65 fe				ld a, (input_at_cursor) 
0fc1 3c					inc a 
0fc2 11 4c 10				ld de,.iblank 
0fc5 cd d5 0b				call str_at_display 
0fc8			 
0fc8 c3 54 0e				jp .is1 
0fcb			 
0fcb fe 0d		.isk4:		cp KEY_CR 
0fcd 28 6c				jr z, .endinput 
0fcf			 
0fcf					; else add the key press to the end 
0fcf			 
0fcf 4f					ld c, a			; save key pressed 
0fd0			 
0fd0 7e					ld a,(hl)		; get what is currently under char 
0fd1			 
0fd1 fe 00				cp 0			; we are at the end of the string 
0fd3 20 2f				jr nz, .onchar 
0fd5					 
0fd5					; add a char to the end of the string 
0fd5				 
0fd5 71					ld (hl),c 
0fd6 23					inc hl 
0fd7			;		ld a,' ' 
0fd7			;		ld (hl),a 
0fd7			;		inc hl 
0fd7 3e 00				ld a,0 
0fd9 77					ld (hl),a 
0fda 2b					dec hl 
0fdb			 
0fdb 3a 58 fe				ld a, (input_cursor) 
0fde 3c					inc a				; TODO check max string length and scroll  
0fdf 32 58 fe				ld (input_cursor), a		; inc cursor pos 
0fe2							 
0fe2 3a 65 fe				ld a, (input_at_cursor) 
0fe5 3c					inc a 
0fe6 32 65 fe				ld (input_at_cursor), a 
0fe9			 
0fe9 2a 6c fe				ld hl, (input_ptr) 
0fec 23					inc hl 
0fed 22 6c fe				ld (input_ptr), hl 
0ff0			 
0ff0 2a 6c fe				ld hl, (input_ptr) 
0ff3 23					inc hl 
0ff4 22 6c fe				ld (input_ptr), hl 
0ff7			;	if DEBUG_INPUT 
0ff7			;		push af 
0ff7			;		ld a, '+' 
0ff7			;		ld (debug_mark),a 
0ff7			;		pop af 
0ff7			;		CALLMONITOR 
0ff7			;	endif 
0ff7 3e 01				ld a, 1		; show cursor moving 
0ff9 32 62 fe				ld (input_cur_onoff),a 
0ffc 3e 0f				ld a, CUR_BLINK_RATE 
0ffe 32 63 fe				ld (input_cur_flash), a 
1001 c3 54 0e				jp .is1 
1004					 
1004			 
1004			 
1004					; if on a char then insert 
1004			.onchar: 
1004			 
1004					; TODO over flow check: make sure insert does not blow out buffer 
1004			 
1004					; need to do some maths to use lddr 
1004			 
1004 e5					push hl   ; save char pos 
1005 c5					push bc 
1006			 
1006 2a 6a fe				ld hl, (input_start) 
1009 3a 5d fe				ld a, (input_len) 
100c cd f6 0d				call addatohl  		; end of string 
100f 23					inc hl 
1010 23					inc hl		; past zero term 
1011 e5					push hl 
1012 23					inc hl 
1013 e5					push hl  
1014			 
1014								; start and end of lddr set, now how much to move? 
1014			 
1014							 
1014 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1017 47					ld b,a 
1018 3a 5d fe				ld a,(input_len) 
101b 5f					ld e,a 
101c 90					sub b 
101d 3c					inc a		;?? 
101e 3c					inc a		;?? 
101f 3c					inc a		;?? 
1020			 
1020 06 00				ld b,0 
1022 4f					ld c,a 
1023			 
1023				if DEBUG_INPUT 
1023					push af 
1023					ld a, 'i' 
1023					ld (debug_mark),a 
1023					pop af 
1023			;		CALLMONITOR 
1023				endif 
1023 d1					pop de 
1024 e1					pop hl 
1025				if DEBUG_INPUT 
1025					push af 
1025					ld a, 'I' 
1025					ld (debug_mark),a 
1025					pop af 
1025			;		CALLMONITOR 
1025				endif 
1025 ed b8				lddr 
1027				 
1027			 
1027			 
1027					; TODO have a key for insert/overwrite mode???? 
1027 c1					pop bc 
1028 e1					pop hl 
1029 71					ld (hl), c		; otherwise overwrite current char 
102a					 
102a			 
102a			 
102a			 
102a 3a 58 fe				ld a, (input_cursor) 
102d 3c					inc  a 		; TODO check overflow 
102e 32 58 fe				ld (input_cursor), a 
1031			 
1031 3a 65 fe				ld a, (input_at_cursor) 
1034 3c					inc a 
1035 32 65 fe				ld (input_at_cursor), a 
1038			 
1038 c3 54 0e				jp .is1 
103b			 
103b			.endinput:	; TODO look for end of string 
103b			 
103b					; add trailing space for end of token 
103b			 
103b 2a 6a fe				ld hl, (input_start) 
103e 3a 5d fe				ld a,(input_len) 
1041 cd f6 0d				call addatohl 
1044 3e 20				ld a, ' ' 
1046 77					ld (hl),a 
1047					; TODO eof of parse marker 
1047			 
1047 23					inc hl 
1048 3e 00				ld a, 0 
104a 77					ld (hl),a 
104b			 
104b			 
104b c9					ret 
104c			 
104c .. 00		.iblank: db " ",0 
104e			 
104e			 
104e 32 67 fe		input_str_prev:	ld (input_at_pos), a 
1051 22 6a fe				ld (input_start), hl 
1054 3e 01				ld a,1			; add cursor 
1056 77					ld (hl),a 
1057 23					inc hl 
1058 3e 00				ld a,0 
105a 77					ld (hl),a 
105b 22 6c fe				ld (input_ptr), hl 
105e 7a					ld a,d 
105f 32 69 fe				ld (input_size), a 
1062 3e 00				ld a,0 
1064 32 58 fe				ld (input_cursor),a 
1067			.instr1:	 
1067			 
1067					; TODO do block cursor 
1067					; TODO switch cursor depending on the modifer key 
1067			 
1067					; update cursor shape change on key hold 
1067			 
1067 2a 6c fe				ld hl, (input_ptr) 
106a 2b					dec hl 
106b 3a c7 fb				ld a,(cursor_shape) 
106e 77					ld (hl), a 
106f			 
106f					; display entered text 
106f 3a 67 fe				ld a,(input_at_pos) 
1072 cd 18 69		            	CALL fLCD_Pos       ;Position cursor to location in A 
1075 ed 5b 6a fe	            	LD   de, (input_start) 
1079 cd 3a 69		            	CALL fLCD_Str       ;Display string pointed to by DE 
107c			 
107c cd 54 6b				call cin 
107f fe 00				cp 0 
1081 28 e4				jr z, .instr1 
1083			 
1083					; proecess keyboard controls first 
1083			 
1083 2a 6c fe				ld hl,(input_ptr) 
1086			 
1086 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1088 28 5a				jr z, .instrcr 
108a			 
108a fe 08				cp KEY_BS 	; back space 
108c 20 0f				jr nz, .instr2 
108e					; process back space 
108e			 
108e					; TODO stop back space if at start of string 
108e 2b					dec hl 
108f 2b					dec hl ; to over write cursor 
1090 3a c7 fb				ld a,(cursor_shape) 
1093					;ld a,0 
1093 77					ld (hl),a 
1094 23					inc hl 
1095 3e 20				ld a," " 
1097 77					ld (hl),a 
1098 22 6c fe				ld (input_ptr),hl 
109b					 
109b			 
109b 18 ca				jr .instr1 
109d			 
109d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
109f 20 06				jr nz, .instr3 
10a1 2b					dec hl 
10a2 22 6c fe				ld (input_ptr),hl 
10a5 18 c0				jr .instr1 
10a7				 
10a7 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
10a9 20 06				jr nz, .instr4 
10ab 23					inc hl 
10ac 22 6c fe				ld (input_ptr),hl 
10af 18 b6				jr .instr1 
10b1			 
10b1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10b3 20 06				jr nz, .instr5 
10b5 2b					dec hl 
10b6 22 6c fe				ld (input_ptr),hl 
10b9 18 ac				jr .instr1 
10bb			 
10bb fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10bd 20 06				jr nz, .instr6 
10bf 2b					dec hl 
10c0 22 6c fe				ld (input_ptr),hl 
10c3 18 a2				jr .instr1 
10c5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10c7 20 0b				jr nz, .instrnew 
10c9			 
10c9 21 d4 f2			ld hl, scratch 
10cc 11 fa f6			ld de, os_last_cmd 
10cf cd ed 10			call strcpy 
10d2 18 93				jr .instr1 
10d4			 
10d4			 
10d4			.instrnew:	; no special key pressed to see if we have room to store it 
10d4			 
10d4					; TODO do string size test 
10d4			 
10d4 2b					dec hl ; to over write cursor 
10d5 77					ld (hl),a 
10d6 23					inc hl 
10d7 3a c7 fb				ld a,(cursor_shape) 
10da 77					ld (hl),a 
10db 23					inc hl 
10dc 3e 00				ld a,0 
10de 77					ld (hl),a 
10df			 
10df 22 6c fe				ld (input_ptr),hl 
10e2					 
10e2 18 83				jr .instr1 
10e4 2b			.instrcr:	dec hl		; remove cursor 
10e5 3e 20				ld a,' '	; TODO add a trailing space for safety 
10e7 77					ld (hl),a 
10e8 23					inc hl 
10e9 3e 00				ld a,0 
10eb 77					ld (hl),a 
10ec			 
10ec			 
10ec					; if at end of line scroll up    
10ec					; TODO detecting only end of line 4 for scroll up  
10ec			 
10ec					;ld   
10ec			 
10ec c9					ret 
10ed			 
10ed			 
10ed			; strcpy hl = dest, de source 
10ed			 
10ed 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10ee b7			            OR   A              ;Null terminator? 
10ef c8			            RET  Z              ;Yes, so finished 
10f0 1a					ld a,(de) 
10f1 77					ld (hl),a 
10f2 13			            INC  DE             ;Point to next character 
10f3 23					inc hl 
10f4 18 f7		            JR   strcpy       ;Repeat 
10f6 c9					ret 
10f7			 
10f7			 
10f7			; TODO string_at  
10f7			; pass string which starts with lcd offset address and then null term string 
10f7			 
10f7			; TODO string to dec 
10f7			; TODO string to hex 
10f7			; TODO byte to string hex 
10f7			; TODO byte to string dec 
10f7			 
10f7			 
10f7			 
10f7			; from z80uartmonitor 
10f7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10f7			; pass hl for where to put the text 
10f7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f7 c5			hexout:	PUSH BC 
10f8 f5					PUSH AF 
10f9 47					LD B, A 
10fa					; Upper nybble 
10fa cb 3f				SRL A 
10fc cb 3f				SRL A 
10fe cb 3f				SRL A 
1100 cb 3f				SRL A 
1102 cd 12 11				CALL tohex 
1105 77					ld (hl),a 
1106 23					inc hl	 
1107					 
1107					; Lower nybble 
1107 78					LD A, B 
1108 e6 0f				AND 0FH 
110a cd 12 11				CALL tohex 
110d 77					ld (hl),a 
110e 23					inc hl	 
110f					 
110f f1					POP AF 
1110 c1					POP BC 
1111 c9					RET 
1112					 
1112			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1112			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1112			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1112			tohex: 
1112 e5					PUSH HL 
1113 d5					PUSH DE 
1114 16 00				LD D, 0 
1116 5f					LD E, A 
1117 21 1f 11				LD HL, .DATA 
111a 19					ADD HL, DE 
111b 7e					LD A, (HL) 
111c d1					POP DE 
111d e1					POP HL 
111e c9					RET 
111f			 
111f			.DATA: 
111f 30					DEFB	30h	; 0 
1120 31					DEFB	31h	; 1 
1121 32					DEFB	32h	; 2 
1122 33					DEFB	33h	; 3 
1123 34					DEFB	34h	; 4 
1124 35					DEFB	35h	; 5 
1125 36					DEFB	36h	; 6 
1126 37					DEFB	37h	; 7 
1127 38					DEFB	38h	; 8 
1128 39					DEFB	39h	; 9 
1129 41					DEFB	41h	; A 
112a 42					DEFB	42h	; B 
112b 43					DEFB	43h	; C 
112c 44					DEFB	44h	; D 
112d 45					DEFB	45h	; E 
112e 46					DEFB	46h	; F 
112f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
112f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
112f			;;    subtract $30, if result > 9 then subtract $7 more 
112f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
112f			atohex: 
112f d6 30				SUB $30 
1131 fe 0a				CP 10 
1133 f8					RET M		; If result negative it was 0-9 so we're done 
1134 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1136 c9					RET		 
1137			 
1137			 
1137			 
1137			 
1137			; Get 2 ASCII characters as hex byte from pointer in hl 
1137			 
1137			BYTERD: 
1137 16 00			LD	D,00h		;Set up 
1139 cd 41 11			CALL	HEXCON		;Get byte and convert to hex 
113c 87				ADD	A,A		;First nibble so 
113d 87				ADD	A,A		;multiply by 16 
113e 87				ADD	A,A		; 
113f 87				ADD	A,A		; 
1140 57				LD	D,A		;Save hi nibble in D 
1141			HEXCON: 
1141 7e				ld a, (hl)		;Get next chr 
1142 23				inc hl 
1143 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1145 fe 0a			CP	00Ah		;Is it 0-9 ? 
1147 38 02			JR	C,NALPHA	;If so miss next bit 
1149 d6 07			SUB	007h		;Else convert alpha 
114b			NALPHA: 
114b b2				OR	D		;Add hi nibble back 
114c c9				RET			; 
114d			 
114d			 
114d			; 
114d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
114d			; Since the routines get_byte and therefore get_nibble are called, only valid 
114d			; characters (0-9a-f) are accepted. 
114d			; 
114d			;get_word        push    af 
114d			;                call    get_byte        ; Get the upper byte 
114d			;                ld      h, a 
114d			;                call    get_byte        ; Get the lower byte 
114d			;                ld      l, a 
114d			;                pop     af 
114d			;                ret 
114d			; 
114d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
114d			; the routine get_nibble is used only valid characters are accepted - the  
114d			; input routine only accepts characters 0-9a-f. 
114d			; 
114d c5			get_byte:        push    bc              ; Save contents of B (and C) 
114e 7e					ld a,(hl) 
114f 23					inc hl 
1150 cd 75 11		                call    nibble2val      ; Get upper nibble 
1153 cb 07		                rlc     a 
1155 cb 07		                rlc     a 
1157 cb 07		                rlc     a 
1159 cb 07		                rlc     a 
115b 47			                ld      b, a            ; Save upper four bits 
115c 7e					ld a,(hl) 
115d cd 75 11		                call    nibble2val      ; Get lower nibble 
1160 b0			                or      b               ; Combine both nibbles 
1161 c1			                pop     bc              ; Restore B (and C) 
1162 c9			                ret 
1163			; 
1163			; Get a hexadecimal digit from the serial line. This routine blocks until 
1163			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1163			; to the serial line interface. The lower 4 bits of A contain the value of  
1163			; that particular digit. 
1163			; 
1163			;get_nibble      ld a,(hl)           ; Read a character 
1163			;                call    to_upper        ; Convert to upper case 
1163			;                call    is_hex          ; Was it a hex digit? 
1163			;                jr      nc, get_nibble  ; No, get another character 
1163			 ;               call    nibble2val      ; Convert nibble to value 
1163			 ;               call    print_nibble 
1163			 ;               ret 
1163			; 
1163			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1163			; A valid hexadecimal digit is denoted by a set C flag. 
1163			; 
1163			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1163			;                ret     nc              ; Yes 
1163			;                cp      '0'             ; Less than '0'? 
1163			;                jr      nc, is_hex_1    ; No, continue 
1163			;                ccf                     ; Complement carry (i.e. clear it) 
1163			;                ret 
1163			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1163			;                ret     c               ; Yes 
1163			;                cp      'A'             ; Less than 'A'? 
1163			;                jr      nc, is_hex_2    ; No, continue 
1163			;                ccf                     ; Yes - clear carry and return 
1163			;                ret 
1163			;is_hex_2        scf                     ; Set carry 
1163			;                ret 
1163			; 
1163			; Convert a single character contained in A to upper case: 
1163			; 
1163 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1165 d8			                ret     c 
1166 fe 7b		                cp      'z' + 1         ; > 'z'? 
1168 d0			                ret     nc              ; Nothing to do, either 
1169 e6 5f		                and     $5f             ; Convert to upper case 
116b c9			                ret 
116c			 
116c			 
116c			to_lower: 
116c			 
116c			   ; if char is in [A-Z] make it lower case 
116c			 
116c			   ; enter : a = char 
116c			   ; exit  : a = lower case char 
116c			   ; uses  : af 
116c			 
116c fe 41		   cp 'A' 
116e d8			   ret c 
116f			    
116f fe 5b		   cp 'Z'+1 
1171 d0			   ret nc 
1172			    
1172 f6 20		   or $20 
1174 c9			   ret 
1175			 
1175			; 
1175			; Expects a hexadecimal digit (upper case!) in A and returns the 
1175			; corresponding value in A. 
1175			; 
1175 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1177 38 02		                jr      c, nibble2val_1 ; Yes 
1179 d6 07		                sub     7               ; Adjust for A-F 
117b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
117d e6 0f		                and     $f              ; Only return lower 4 bits 
117f c9			                ret 
1180			; 
1180			; Print_nibble prints a single hex nibble which is contained in the lower  
1180			; four bits of A: 
1180			; 
1180			;print_nibble    push    af              ; We won't destroy the contents of A 
1180			;                and     $f              ; Just in case... 
1180			;                add     a, '0'             ; If we have a digit we are done here. 
1180			;                cp      '9' + 1         ; Is the result > 9? 
1180			;                jr      c, print_nibble_1 
1180			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1180			;print_nibble_1  call    putc            ; Print the nibble and 
1180			;                pop     af              ; restore the original value of A 
1180			;                ret 
1180			;; 
1180			;; Send a CR/LF pair: 
1180			; 
1180			;crlf            push    af 
1180			;                ld      a, cr 
1180			;                call    putc 
1180			;                ld      a, lf 
1180			;                call    putc 
1180			;                pop     af 
1180			;                ret 
1180			; 
1180			; Print_word prints the four hex digits of a word to the serial line. The  
1180			; word is expected to be in HL. 
1180			; 
1180			;print_word      push    hl 
1180			;                push    af 
1180			;                ld      a, h 
1180			;                call    print_byte 
1180			;                ld      a, l 
1180			;                call    print_byte 
1180			;                pop     af 
1180			;                pop     hl 
1180			;                ret 
1180			; 
1180			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1180			; The byte to be printed is expected to be in A. 
1180			; 
1180			;print_byte      push    af              ; Save the contents of the registers 
1180			;                push    bc 
1180			;                ld      b, a 
1180			;                rrca 
1180			;                rrca 
1180			;                rrca 
1180			;                rrca 
1180			;                call    print_nibble    ; Print high nibble 
1180			;                ld      a, b 
1180			;                call    print_nibble    ; Print low nibble 
1180			;                pop     bc              ; Restore original register contents 
1180			;                pop     af 
1180			;                ret 
1180			 
1180			 
1180			 
1180			 
1180			 
1180			fourehexhl:  
1180 7e				ld a,(hl) 
1181 cd 2f 11			call atohex 
1184 cb 3f				SRL A 
1186 cb 3f				SRL A 
1188 cb 3f				SRL A 
118a cb 3f				SRL A 
118c 47				ld b, a 
118d 23				inc hl 
118e 7e				ld a,(hl) 
118f 23				inc hl 
1190 cd 2f 11			call atohex 
1193 80				add b 
1194 57				ld d,a 
1195 7e				ld a,(hl) 
1196 cd 2f 11			call atohex 
1199 cb 3f				SRL A 
119b cb 3f				SRL A 
119d cb 3f				SRL A 
119f cb 3f				SRL A 
11a1 47				ld b, a 
11a2 23				inc hl 
11a3 7e				ld a,(hl) 
11a4 23				inc hl 
11a5 cd 2f 11			call atohex 
11a8 80				add b 
11a9 5f				ld e, a 
11aa d5				push de 
11ab e1				pop hl 
11ac c9				ret 
11ad			 
11ad			; pass hl. returns z set if the byte at hl is a digit 
11ad			;isdigithl:  
11ad			;	push bc 
11ad			;	ld a,(hl) 
11ad			;	cp ':' 
11ad			;	jr nc, .isdf 		; > 
11ad			;	cp '0' 
11ad			;	jr c, .isdf		; < 
11ad			; 
11ad			;	; TODO find a better way to set z 
11ad			; 
11ad			;	ld b,a 
11ad			;	cp b 
11ad			;	pop bc 
11ad			;	ret 
11ad			; 
11ad			;.isdf:	; not digit so clear z 
11ad			; 
11ad			;	; TODO find a better way to unset z 
11ad			; 
11ad			;	ld b,a 
11ad			;	inc b 
11ad			;	cp b 
11ad			; 
11ad			;	pop bc 
11ad			;	ret 
11ad				 
11ad				 
11ad			 
11ad			 
11ad			; pass hl as the four byte address to load 
11ad			 
11ad			get_word_hl:  
11ad e5				push hl 
11ae cd 4d 11			call get_byte 
11b1				 
11b1 47				ld b, a 
11b2			 
11b2 e1				pop hl 
11b3 23				inc hl 
11b4 23				inc hl 
11b5			 
11b5			; TODO not able to handle a-f  
11b5 7e				ld a,(hl) 
11b6			;	;cp ':' 
11b6			;	cp 'g' 
11b6			;	jr nc, .single_byte_hl 		; > 
11b6			;	cp 'G' 
11b6			;	jr nc, .single_byte_hl 		; > 
11b6			;	cp '0' 
11b6			;	jr c, .single_byte_hl		; < 
11b6			 
11b6				;call isdigithl 
11b6 fe 00			cp 0 
11b8 28 06			jr z, .single_byte_hl 
11ba			 
11ba			.getwhln:   ; hex word so get next byte 
11ba			 
11ba cd 4d 11			call get_byte 
11bd 6f				ld l, a 
11be 60				ld h,b 
11bf c9				ret 
11c0 68			.single_byte_hl:   ld l,b 
11c1 26 00				ld h,0 
11c3 c9					ret 
11c4			 
11c4			 
11c4			 
11c4			 
11c4 21 22 1b			ld hl,asc+1 
11c7			;	ld a, (hl) 
11c7			;	call nibble2val 
11c7 cd 4d 11			call get_byte 
11ca			 
11ca			;	call fourehexhl 
11ca 32 08 f3			ld (scratch+52),a 
11cd				 
11cd 21 06 f3			ld hl,scratch+50 
11d0 22 f7 f5			ld (os_cur_ptr),hl 
11d3			 
11d3 c9				ret 
11d4			 
11d4			 
11d4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11d4			 
11d4			; Decimal Unsigned Version 
11d4			 
11d4			;Number in a to decimal ASCII 
11d4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11d4			;Example: display a=56 as "056" 
11d4			;input: a = number 
11d4			;Output: a=0,value of a in the screen 
11d4			;destroys af,bc (don't know about hl and de) 
11d4			DispAToASCII: 
11d4 0e 9c			ld	c,-100 
11d6 cd e0 11			call	.Na1 
11d9 0e f6			ld	c,-10 
11db cd e0 11			call	.Na1 
11de 0e ff			ld	c,-1 
11e0 06 2f		.Na1:	ld	b,'0'-1 
11e2 04			.Na2:	inc	b 
11e3 81				add	a,c 
11e4 38 fc			jr	c,.Na2 
11e6 91				sub	c		;works as add 100/10/1 
11e7 f5				push af		;safer than ld c,a 
11e8 78				ld	a,b		;char is in b 
11e9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11e9 f1				pop af		;safer than ld a,c 
11ea c9				ret 
11eb			 
11eb			; Decimal Signed Version 
11eb			 
11eb			; DispA 
11eb			; -------------------------------------------------------------- 
11eb			; Converts a signed integer value to a zero-terminated ASCII 
11eb			; string representative of that value (using radix 10). 
11eb			; -------------------------------------------------------------- 
11eb			; INPUTS: 
11eb			;     HL     Value to convert (two's complement integer). 
11eb			;     DE     Base address of string destination. (pointer). 
11eb			; -------------------------------------------------------------- 
11eb			; OUTPUTS: 
11eb			;     None 
11eb			; -------------------------------------------------------------- 
11eb			; REGISTERS/MEMORY DESTROYED 
11eb			; AF HL 
11eb			; -------------------------------------------------------------- 
11eb			 
11eb			;DispHLToASCII: 
11eb			;   push    de 
11eb			;   push    bc 
11eb			; 
11eb			;; Detect sign of HL. 
11eb			;    bit    7, h 
11eb			;    jr     z, ._DoConvert 
11eb			; 
11eb			;; HL is negative. Output '-' to string and negate HL. 
11eb			;    ld     a, '-' 
11eb			;    ld     (de), a 
11eb			;    inc    de 
11eb			; 
11eb			;; Negate HL (using two's complement) 
11eb			;    xor    a 
11eb			;    sub    l 
11eb			;    ld     l, a 
11eb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11eb			;    sbc    a, h 
11eb			;    ld     h, a 
11eb			; 
11eb			;; Convert HL to digit characters 
11eb			;._DoConvert: 
11eb			;    ld     b, 0     ; B will count character length of number 
11eb			;-   ld     a, 10 
11eb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11eb			;    push   af 
11eb			;    inc    b 
11eb			;    ld     a, h 
11eb			;    or     l 
11eb			;    jr     nz, - 
11eb			; 
11eb			;; Retrieve digits from stack 
11eb			;-   pop    af 
11eb			;    or     $30 
11eb			;    ld     (de), a 
11eb			;    inc    de 
11eb			;    djnz   - 
11eb			; 
11eb			;; Terminate string with NULL 
11eb			;    xor    a 
11eb			;    ld     (de), a 
11eb			; 
11eb			;    pop    bc 
11eb			;    pop    de 
11eb			;    ret 
11eb			 
11eb			;Comments 
11eb			; 
11eb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11eb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11eb			;    Note that the output string will not be fixed-width. 
11eb			; 
11eb			;Example Usage 
11eb			; 
11eb			;    ld    hl, -1004 
11eb			;    ld    de, OP1 
11eb			;    call  DispA 
11eb			;    ld    hl, OP1 
11eb			;    syscall  PutS 
11eb			 
11eb			 
11eb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11eb			 
11eb			 
11eb			;Converts an ASCII string to an unsigned 16-bit integer 
11eb			;Quits when it reaches a non-decimal digit 
11eb			 
11eb			string_to_uint16: 
11eb			atoui_16: 
11eb			;Input: 
11eb			;     DE points to the string 
11eb			;Outputs: 
11eb			;     HL is the result 
11eb			;     A is the 8-bit value of the number 
11eb			;     DE points to the byte after the number 
11eb			;Destroys: 
11eb			;     BC 
11eb			;       if the string is non-empty, BC is HL/10 
11eb			;Size:  24 bytes 
11eb			;Speed: 42+d(104+{0,9}) 
11eb			;       d is the number of digits in the number 
11eb			;       max is 640 cycles for a 5 digit number 
11eb			;Assuming no leading zeros: 
11eb			;1 digit:  146cc 
11eb			;2 digit:  250cc 
11eb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11eb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11eb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11eb			;avg: 544.81158447265625cc (544+13297/16384) 
11eb			;=============================================================== 
11eb 21 00 00		  ld hl,0 
11ee			.u16a: 
11ee 1a			  ld a,(de) 
11ef d6 30		  sub 30h 
11f1 fe 0a		  cp 10 
11f3 d0			  ret nc 
11f4 13			  inc de 
11f5 44			  ld b,h 
11f6 4d			  ld c,l 
11f7 29			  add hl,hl 
11f8 29			  add hl,hl 
11f9 09			  add hl,bc 
11fa 29			  add hl,hl 
11fb 85			  add a,l 
11fc 6f			  ld l,a 
11fd 30 ef		  jr nc,.u16a 
11ff 24			  inc h 
1200 c3 ee 11		  jp .u16a 
1203			 
1203			 
1203			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1203			 
1203			;written by Zeda 
1203			;Converts a 16-bit unsigned integer to an ASCII string. 
1203			 
1203			uitoa_16: 
1203			;Input: 
1203			;   DE is the number to convert 
1203			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1203			;Output: 
1203			;   HL points to the null-terminated ASCII string 
1203			;      NOTE: This isn't necessarily the same as the input HL. 
1203 d5			  push de 
1204 c5			  push bc 
1205 f5			  push af 
1206 eb			  ex de,hl 
1207			 
1207 01 f0 d8		  ld bc,-10000 
120a 3e 2f		  ld a,'0'-1 
120c 3c			  inc a 
120d 09			  add hl,bc  
120e 38 fc		   jr c,$-2 
1210 12			  ld (de),a 
1211 13			  inc de 
1212			 
1212 01 e8 03		  ld bc,1000 
1215 3e 3a		  ld a,'9'+1 
1217 3d			  dec a  
1218 09			  add hl,bc  
1219 30 fc		   jr nc,$-2 
121b 12			  ld (de),a 
121c 13			  inc de 
121d			 
121d 01 9c ff		  ld bc,-100 
1220 3e 2f		  ld a,'0'-1 
1222 3c			  inc a  
1223 09			  add hl,bc  
1224 38 fc		   jr c,$-2 
1226 12			  ld (de),a 
1227 13			  inc de 
1228			 
1228 7d			  ld a,l 
1229 26 3a		  ld h,'9'+1 
122b 25			  dec h  
122c c6 0a		  add a,10  
122e 30 fb		   jr nc,$-3 
1230 c6 30		  add a,'0' 
1232 eb			  ex de,hl 
1233 72			  ld (hl),d 
1234 23			  inc hl 
1235 77			  ld (hl),a 
1236 23			  inc hl 
1237 36 00		  ld (hl),0 
1239			 
1239			;Now strip the leading zeros 
1239 0e fa		  ld c,-6 
123b 09			  add hl,bc 
123c 3e 30		  ld a,'0' 
123e 23			  inc hl  
123f be			  cp (hl)  
1240 28 fc		  jr z,$-2 
1242			 
1242			;Make sure that the string is non-empty! 
1242 7e			  ld a,(hl) 
1243 b7			  or a 
1244 20 01		  jr nz,.atoub 
1246 2b			  dec hl 
1247			.atoub: 
1247			 
1247 f1			  pop af 
1248 c1			  pop bc 
1249 d1			  pop de 
124a c9			  ret 
124b			 
124b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
124b			 
124b			toUpper: 
124b			;A is the char. 
124b			;If A is a lowercase letter, this sets it to the matching uppercase 
124b			;18cc or 30cc or 41cc 
124b			;avg: 26.75cc 
124b fe 61		  cp 'a' 
124d d8			  ret c 
124e fe 7b		  cp 'z'+1 
1250 d0			  ret nc 
1251 d6 20		  sub 'a'-'A' 
1253 c9			  ret 
1254			 
1254			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1254			 
1254			; String Length 
1254			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1254			 
1254			; Get the length of the null-terminated string starting at $8000 hl 
1254			;    LD     HL, $8000 
1254			 
1254			strlenz: 
1254			 
1254 af			    XOR    A               ; Zero is the value we are looking for. 
1255 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1256 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1257			                           ; 65, 536 bytes (the entire addressable memory space). 
1257 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1259			 
1259			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1259 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
125a 6f			    LD     L, A             ; number of bytes 
125b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125d 2b			    DEC    HL              ; Compensate for null. 
125e c9				ret 
125f			 
125f			; Get the length of the A terminated string starting at $8000 hl 
125f			;    LD     HL, $8000 
125f			 
125f			strlent: 
125f			 
125f			                  ; A is the value we are looking for. 
125f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1261 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1263			                           ; 65, 536 bytes (the entire addressable memory space). 
1263 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1265			 
1265			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1265 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1267 2e 00		    LD     L, 0             ; number of bytes 
1269 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
126b 2b			    DEC    HL              ; Compensate for null. 
126c c9				ret 
126d			 
126d			 
126d			;Comparing Strings 
126d			 
126d			;IN    HL     Address of string1. 
126d			;      DE     Address of string2. 
126d			 
126d			; doc given but wrong??? 
126d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
126d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
126d			; tested 
126d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
126d			 
126d			strcmp_old: 
126d e5			    PUSH   HL 
126e d5			    PUSH   DE 
126f			 
126f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1270 be			    CP     (HL)            ; (want to minimize work). 
1271 38 01		    JR     C, Str1IsBigger 
1273 7e			    LD     A, (HL) 
1274			 
1274			Str1IsBigger: 
1274 4f			    LD     C, A             ; Put length in BC 
1275 06 00		    LD     B, 0 
1277 13			    INC    DE              ; Increment pointers to meat of string. 
1278 23			    INC    HL 
1279			 
1279			CmpLoop: 
1279 1a			    LD     A, (DE)          ; Compare bytes. 
127a ed a1		    CPI 
127c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
127e 13			    INC    DE              ; Update pointer. 
127f ea 79 12		    JP     PE, CmpLoop 
1282			 
1282 d1			    POP    DE 
1283 e1			    POP    HL 
1284 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1285 be			    CP     (HL) 
1286 c9			    RET 
1287			 
1287			NoMatch: 
1287 2b			    DEC    HL 
1288 be			    CP     (HL)            ; Compare again to affect carry. 
1289 d1			    POP    DE 
128a e1			    POP    HL 
128b c9			    RET 
128c			 
128c			;; test strmp 
128c			; 
128c			;ld de, .str1 
128c			;ld hl, .str2 
128c			;call strcmp 
128c			;jr z, .z1 
128c			;;this 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "NZ1" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			;.z1: 
128c			; 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "ZZ1" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			; 
128c			;ld de, .str1 
128c			;ld hl, .str1 
128c			;call strcmp 
128c			;jr z, .z2 
128c			;;this 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "NZ2" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			;.z2: 
128c			; 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "ZZ2" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			; 
128c			;ld de, .str1 
128c			;ld hl, .str2 
128c			;call strcmp 
128c			;jr c, .c1 
128c			; 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "Nc1" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			;.c1: 
128c			;;this 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "cc1" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			; 
128c			;ld de, .str1 
128c			;ld hl, .str1 
128c			;call strcmp 
128c			;jr c, .c2 
128c			;;this 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "Nc2" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			;.c2: 
128c			; 
128c			;	if DEBUG_FORTH_WORDS 
128c			;		DMARK "cc2" 
128c			;		CALLMONITOR 
128c			;	endif 
128c			;	NEXTW 
128c			;.str1:   db "string1",0 
128c			;.str2:   db "string2",0 
128c			 
128c			; only care about direct match or not 
128c			; hl and de strings 
128c			; zero set if the same 
128c			 
128c			strcmp: 
128c 1a				ld a, (de) 
128d be				cp (hl) 
128e 28 02			jr z, .ssame 
1290 b7				or a 
1291 c9				ret 
1292			 
1292			.ssame:  
1292 fe 00			cp 0 
1294 c8				ret z 
1295			 
1295 23				inc hl 
1296 13				inc de 
1297 18 f3			jr strcmp 
1299				 
1299				 
1299			 
1299			 
1299			 
1299			 
1299			; eof 
1299			 
1299			 
1299			 
1299			 
1299			 
1299			 
# End of file firmware_strings.asm
1299			include "firmware_memory.asm"   ; malloc and free  
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			.mallocsize: db "Wants malloc >256",0 
1299			.mallocasize: db "MALLOC gives >256",0 
1299			.malloczero: db "MALLOC gives zero",0 
1299			 
1299			malloc_guard_zerolen: 
1299				push hl 
1299				push de 
1299				push af 
1299			 
1299				ld de, 0 
1299			        call cmp16 
1299				jr nz, .lowalloz 
1299			 
1299				push hl 
1299				push de 
1299					ld hl, display_fb0 
1299					ld (display_fb_active), hl 
1299				call clear_display 
1299				ld a, 0 
1299				ld de, .malloczero 
1299				call str_at_display 
1299				call update_display 
1299				call delay1s 
1299				call delay1s 
1299				ld a, 0 
1299				ld (os_view_disable), a 
1299			 
1299				pop de 
1299				pop hl 
1299			 
1299				 
1299			 
1299				CALLMONITOR 
1299			.lowalloz: 
1299			 
1299			 
1299				pop af 
1299				pop de 
1299				pop hl 
1299			ret 
1299			 
1299			malloc_guard_entry: 
1299				push hl 
1299				push de 
1299				push af 
1299			 
1299			 	or a      ;clear carry flag 
1299				push hl 
1299				ld de, 255 
1299				sbc hl, de 
1299				jr c, .lowalloc 
1299			 
1299				push de 
1299					ld hl, display_fb0 
1299					ld (display_fb_active), hl 
1299				call clear_display 
1299				ld a, 0 
1299				ld de, .mallocsize 
1299				call str_at_display 
1299				call update_display 
1299				call delay1s 
1299				call delay1s 
1299				ld a, 0 
1299				ld (os_view_disable), a 
1299			 
1299				pop de 
1299				pop hl 
1299			 
1299				 
1299			 
1299				CALLMONITOR 
1299				jr .lowdone 
1299			.lowalloc: 
1299			 
1299			 
1299				pop hl 
1299			.lowdone:	pop af 
1299				pop de 
1299				pop hl 
1299			ret 
1299			 
1299			malloc_guard_exit: 
1299				push hl 
1299				push de 
1299				push af 
1299			 
1299			 	or a      ;clear carry flag 
1299				push hl 
1299				ld de, 255 
1299				sbc hl, de 
1299				jr c, .lowallocx 
1299			 
1299				push de 
1299					ld hl, display_fb0 
1299					ld (display_fb_active), hl 
1299				call clear_display 
1299				ld a, 0 
1299				ld de, .mallocasize 
1299				call str_at_display 
1299				call update_display 
1299				call delay1s 
1299				call delay1s 
1299				ld a, 0 
1299				ld (os_view_disable), a 
1299				pop de 
1299				pop hl 
1299			 
1299				CALLMONITOR 
1299				jr .lowdonex 
1299			.lowallocx: 
1299			 
1299				pop hl 
1299			.lowdonex:	pop af 
1299				pop de 
1299				pop hl 
1299			ret 
1299			endif 
1299			 
1299			if MALLOC_2 
1299			; Z80 Malloc and Free Functions 
1299			 
1299			; Malloc Function: 
1299			; Input: 
1299			;   HL: Size of block to allocate 
1299			; Output: 
1299			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1299			 
1299			malloc: 
1299				 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_entry 
1299			endif 
1299			 
1299			 
1299			 
1299			 
1299					if DEBUG_FORTH_MALLOC 
1299						DMARK "mal" 
1299						CALLMONITOR 
1299					endif 
1299			    push af            ; Save AF register 
1299			    ld a, l            ; Load low byte of size into A 
1299			    or h               ; Check if size is zero 
1299			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1299			 
1299			    ; Allocate memory 
1299			    ld hl, (heap_start) ; Load start of heap into HL 
1299					if DEBUG_FORTH_MALLOC 
1299						DMARK "ma1" 
1299						CALLMONITOR 
1299					endif 
1299			    call malloc_internal ; Call internal malloc function 
1299			    pop af             ; Restore AF register 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299			    ret                ; Return 
1299			 
1299			; Free Function: 
1299			; Input: 
1299			;   HL: Pointer to memory block to free 
1299			; Output: 
1299			;   None 
1299			 
1299			free: 
1299			    push af            ; Save AF register 
1299			    ld a, l            ; Load low byte of pointer into A 
1299			    or h               ; Check if pointer is NULL 
1299			    jp z, free_exit    ; If pointer is NULL, exit 
1299			 
1299			    ; Free memory 
1299			    ld hl, (heap_start) ; Load start of heap into HL 
1299			    call free_internal  ; Call internal free function 
1299			    pop af             ; Restore AF register 
1299			    ret                ; Return 
1299			 
1299			; Internal Malloc Function: 
1299			; Input: 
1299			;   HL: Size of block to allocate 
1299			; Output: 
1299			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1299			 
1299			malloc_internal: 
1299			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1299			    add hl, bc         ; Add management overhead to requested size 
1299			    ex de, hl          ; Save total size in DE, and keep it in HL 
1299					if DEBUG_FORTH_MALLOC 
1299						DMARK "ma2" 
1299						CALLMONITOR 
1299					endif 
1299			 
1299			    ; Search for free memory block 
1299			    ld de, (heap_end)  ; Load end of heap into DE 
1299			    ld bc, 0           ; Initialize counter 
1299			 
1299					if DEBUG_FORTH_MALLOC 
1299						DMARK "ma2" 
1299						CALLMONITOR 
1299					endif 
1299			malloc_search_loop: 
1299			    ; Check if current block is free 
1299			    ld a, (hl)         ; Load current block's status (free or used) 
1299			    cp 0               ; Compare with zero (free) 
1299			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1299			 
1299			    ; Check if current block is large enough 
1299			    ld a, (hl+1)       ; Load high byte of block size 
1299			    cp l               ; Compare with low byte of requested size 
1299			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1299			 
1299			    ld a, (hl+2)       ; Load low byte of block size 
1299			    cp h               ; Compare with high byte of requested size 
1299			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1299			 
1299			    ; Mark block as used 
1299			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1299			 
1299			    ; Calculate remaining space in block 
1299			    ld bc, 0           ; Clear BC 
1299			    add hl, bc         ; Increment HL to point to start of data block 
1299			    add hl, de         ; HL = HL + DE (total size) 
1299			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1299			    add hl, bc         ; Add management overhead to start of data block 
1299			 
1299			    ; Save pointer to allocated block in HL 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299						DMARK "ma5" 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299			    ret 
1299			 
1299			malloc_skip_block_check: 
1299			    ; Move to the next block 
1299			    ld bc, 3           ; Size of management overhead 
1299			    add hl, bc         ; Move to the next block 
1299			    inc de             ; Increment counter 
1299			 
1299			    ; Check if we have reached the end of heap 
1299			    ld a, e            ; Load low byte of heap end address 
1299			    cp (hl)            ; Compare with low byte of current address 
1299			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1299			    ld a, d            ; Load high byte of heap end address 
1299			    cp 0               ; Check if it's zero (end of memory) 
1299			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1299			 
1299			    ; If we reached here, allocation failed 
1299			    xor a              ; Set result to NULL 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299						DMARK "ma6" 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299			    ret 
1299			malloc_exit: 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299						DMARK "ma7" 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299			    ret 
1299			 
1299			; Internal Free Function: 
1299			; Input: 
1299			;   HL: Pointer to memory block to free 
1299			; Output: 
1299			;   None 
1299			 
1299			free_internal: 
1299			    ld de, (heap_start) ; Load start of heap into DE 
1299			    ld bc, 0            ; Initialize counter 
1299			 
1299			free_search_loop: 
1299			    ; Check if current block contains the pointer 
1299			    ld a, l             ; Load low byte of pointer 
1299			    cp (hl+1)           ; Compare with high byte of current block's address 
1299			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1299			    ld a, h             ; Load high byte of pointer 
1299			    cp (hl+2)           ; Compare with low byte of current block's address 
1299			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1299			 
1299			    ; Mark block as free 
1299			    ld (hl), 0          ; Set status byte to indicate free block 
1299			    ret                 ; Return 
1299			 
1299			free_skip_block_check: 
1299			    ; Move to the next block 
1299			    ld bc, 3            ; Size of management overhead 
1299			    add hl, bc          ; Move to the next block 
1299			    inc de              ; Increment counter 
1299			 
1299			    ; Check if we have reached the end of heap 
1299			    ld a, e             ; Load low byte of heap end address 
1299			    cp (hl)             ; Compare with low byte of current address 
1299			    jr nz, free_search_loop  ; If not equal, continue searching 
1299			    ld a, d             ; Load high byte of heap end address 
1299			    cp 0                ; Check if it's zero (end of memory) 
1299			    jr nz, free_search_loop  ; If not zero, continue searching 
1299			 
1299			    ; If we reached here, pointer is not found in heap 
1299			    ret 
1299			 
1299			free_exit: 
1299			    ret                 ; Return 
1299			 
1299			; Define heap start and end addresses 
1299			;heap_start:    .dw 0xC000   ; Start of heap 
1299			;heap_end:      .dw 0xE000   ; End of heap 
1299			 
1299			endif 
1299			 
1299			 
1299			if MALLOC_1 
1299			 
1299			 
1299			 
1299			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1299			 
1299			;moved to firmware.asm 
1299			;heap_start        .equ  0x9000      ; Starting address of heap 
1299			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1299			 
1299			;      .org 0 
1299			;      jp    main 
1299			 
1299			 
1299			;      .org  0x100 
1299			;main: 
1299			;      ld    HL, 0x8100 
1299			;      ld    SP, HL 
1299			; 
1299			;      call  heap_init 
1299			; 
1299			;      ; Make some allocations 
1299			;      ld    HL, 12 
1299			;      call  malloc            ; Allocates 0x9004 
1299			; 
1299			;      ld    HL, 12 
1299			;      call  malloc            ; Allocates 0x9014 
1299			; 
1299			;      ld    HL, 12 
1299			;      call  malloc            ; Allocates 0x9024 
1299			; 
1299			;      ; Free some allocations 
1299			;      ld    HL, 0x9014 
1299			;      call  free 
1299			; 
1299			;      ld    HL, 0x9004 
1299			;      call  free 
1299			; 
1299			;      ld    HL, 0x9024 
1299			;      call  free 
1299			; 
1299			; 
1299			;      halt 
1299			 
1299			 
1299			;------------------------------------------------------------------------------ 
1299			;     heap_init                                                               : 
1299			;                                                                             : 
1299			; Description                                                                 : 
1299			;     Initialise the heap and make it ready for malloc and free operations.   : 
1299			;                                                                             : 
1299			;     The heap is maintained as a linked list, starting with an initial       : 
1299			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1299			;     the first free block in the heap. Each block then points to the next    : 
1299			;     free block within the heap, and the free list ends at the first block   : 
1299			;     with a null pointer to the next free block.                             : 
1299			;                                                                             : 
1299			; Parameters                                                                  : 
1299			;     Inputs are compile-time only. Two defines which specify the starting    : 
1299			;     address of the heap and its size are required, along with a memory      : 
1299			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1299			;     principally stores a pointer to the first free block in the heap.       : 
1299			;                                                                             : 
1299			; Returns                                                                     : 
1299			;     Nothing                                                                 : 
1299			;------------------------------------------------------------------------------ 
1299			heap_init: 
1299 e5			      push  HL 
129a			 
129a			      ; Initialise free list struct 
129a 21 0e 80		      ld    HL, heap_start 
129d 22 0a 80		      ld    (free_list), HL 
12a0 21 00 00		      ld    HL, 0 
12a3 22 0c 80		      ld    (free_list+2), HL 
12a6			 
12a6			      ; Insert first free block at bottom of heap, consumes entire heap 
12a6 21 b6 f2		      ld    HL, heap_start+heap_size-4 
12a9 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
12ac 21 a8 72		      ld    HL, heap_size-4 
12af 22 10 80		      ld    (heap_start+2), HL      ; Block size 
12b2			 
12b2			      ; Insert end of free list block at top of heap - two null words will 
12b2			      ; terminate the free list 
12b2 21 00 00		      ld    HL, 0 
12b5 22 b8 f2		      ld    (heap_start+heap_size-2), HL 
12b8 22 b6 f2		      ld    (heap_start+heap_size-4), HL 
12bb			 
12bb e1			      pop   HL 
12bc			 
12bc c9			      ret 
12bd			 
12bd			 
12bd			;------------------------------------------------------------------------------ 
12bd			;     malloc                                                                  : 
12bd			;                                                                             : 
12bd			; Description                                                                 : 
12bd			;     Allocates the wanted space from the heap and returns the address of the : 
12bd			;     first useable byte of the allocation.                                   : 
12bd			;                                                                             : 
12bd			;     Allocations can happen in one of two ways:                              : 
12bd			;                                                                             : 
12bd			;     1. A free block may be found which is the exact size wanted. In this    : 
12bd			;        case the block is removed from the free list and retuedn to the      : 
12bd			;        caller.                                                              : 
12bd			;     2. A free block may be found which is larger than the size wanted. In   : 
12bd			;        this case, the larger block is split into two. The first portion of  : 
12bd			;        this block will become the requested space by the malloc call and    : 
12bd			;        is returned to the caller. The second portion becomes a new free     : 
12bd			;        block, and the free list is adjusted to maintain continuity via this : 
12bd			;        newly created block.                                                 : 
12bd			;                                                                             : 
12bd			;     malloc does not set any initial value in the allocated space, the       : 
12bd			;     caller is required to do this as required.                              : 
12bd			;                                                                             : 
12bd			;     This implementation of malloc uses the stack exclusively, and is        : 
12bd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12bd			;     advisable to disable interrupts before calling malloc, and recommended  : 
12bd			;     to avoid the use of malloc inside ISRs in general.                      : 
12bd			;                                                                             : 
12bd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12bd			;                                                                             : 
12bd			; Parameters                                                                  : 
12bd			;     HL  Number of bytes wanted                                              : 
12bd			;                                                                             : 
12bd			; Returns                                                                     : 
12bd			;     HL  Address of the first useable byte of the allocation                 : 
12bd			;                                                                             : 
12bd			; Flags                                                                       : 
12bd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12bd			;                                                                             : 
12bd			; Stack frame                                                                 : 
12bd			;       |             |                                                       : 
12bd			;       +-------------+                                                       : 
12bd			;       |     BC      |                                                       : 
12bd			;       +-------------+                                                       : 
12bd			;       |     DE      |                                                       : 
12bd			;       +-------------+                                                       : 
12bd			;       |     IX      |                                                       : 
12bd			;       +-------------+                                                       : 
12bd			;       |  prev_free  |                                                       : 
12bd			;   +4  +-------------+                                                       : 
12bd			;       |  this_free  |                                                       : 
12bd			;   +2  +-------------+                                                       : 
12bd			;       |  next_free  |                                                       : 
12bd			;   +0  +-------------+                                                       : 
12bd			;       |             |                                                       : 
12bd			;                                                                             : 
12bd			;------------------------------------------------------------------------------ 
12bd			 
12bd			 
12bd			;malloc: 
12bd			; 
12bd			;	SAVESP ON 1 
12bd			; 
12bd			;	call malloc_code 
12bd			; 
12bd			;	CHECKSP ON 1 
12bd			;	ret 
12bd			 
12bd			 
12bd			malloc: 
12bd c5			      push  BC 
12be d5			      push  DE 
12bf dd e5		      push  IX 
12c1			if DEBUG_FORTH_MALLOC_HIGH 
12c1			call malloc_guard_entry 
12c1			endif 
12c1			 
12c1					if DEBUG_FORTH_MALLOC 
12c1						DMARK "mal" 
12c1						CALLMONITOR 
12c1					endif 
12c1 7c			      ld    A, H                    ; Exit if no space requested 
12c2 b5			      or    L 
12c3 ca 82 13		      jp    Z, malloc_early_exit 
12c6			 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			; 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			;inc hl 
12c6			 
12c6			 
12c6			 
12c6			 
12c6					if DEBUG_FORTH_MALLOC 
12c6						DMARK "maA" 
12c6						CALLMONITOR 
12c6					endif 
12c6			      ; Set up stack frame 
12c6 eb			      ex    DE, HL 
12c7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12ca 39			      add   HL, SP 
12cb f9			      ld    SP, HL 
12cc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12d0 dd 39		      add   IX, SP 
12d2			 
12d2			      ; Setup initial state 
12d2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12d5 19			      add   HL, DE 
12d6			 
12d6 44			      ld    B, H                    ; Move want to BC 
12d7 4d			      ld    C, L 
12d8			 
12d8 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
12db dd 75 04		      ld    (IX+4), L 
12de dd 74 05		      ld    (IX+5), H 
12e1			 
12e1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12e2 23			      inc   HL 
12e3 56			      ld    D, (HL) 
12e4 dd 73 02		      ld    (IX+2), E 
12e7 dd 72 03		      ld    (IX+3), D 
12ea eb			      ex    DE, HL                  ; this_free ptr into HL 
12eb			 
12eb					if DEBUG_FORTH_MALLOC 
12eb						DMARK "maB" 
12eb						CALLMONITOR 
12eb					endif 
12eb			      ; Loop through free block list to find some space 
12eb			malloc_find_space: 
12eb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12ef b3			      or    E 
12f0 ca 7c 13		      jp    Z, malloc_no_space 
12f3			 
12f3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12f6 dd 72 01		      ld    (IX+1), D 
12f9			 
12f9			      ; Does this block have enough space to make the allocation? 
12f9 23			      inc   HL                      ; Load free block size into DE 
12fa 5e			      ld    E, (HL) 
12fb 23			      inc   HL 
12fc 56			      ld    D, (HL) 
12fd			 
12fd eb			      ex    DE, HL                  ; Check size of block against want 
12fe b7			      or    A                       ; Ensure carry flag clear 
12ff ed 42		      sbc   HL, BC 
1301 e5			      push  HL                      ; Store the result for later (new block size) 
1302			 
1302 ca 51 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1305 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1307			 
1307			      ; this_free block is not big enough, setup ptrs to test next free block 
1307 e1			      pop   HL                      ; Discard previous result 
1308			 
1308 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
130b dd 66 03		      ld    H, (IX+3) 
130e dd 75 04		      ld    (IX+4), L 
1311 dd 74 05		      ld    (IX+5), H 
1314			 
1314 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1317 dd 66 01		      ld    H, (IX+1) 
131a dd 75 02		      ld    (IX+2), L 
131d dd 74 03		      ld    (IX+3), H 
1320			 
1320					if DEBUG_FORTH_MALLOC 
1320						DMARK "MA>" 
1320						CALLMONITOR 
1320					endif 
1320 18 c9		      jr    malloc_find_space 
1322			 
1322			      ; split a bigger block into two - requested size and remaining size 
1322			malloc_alloc_split: 
1322					if DEBUG_FORTH_MALLOC 
1322						DMARK "MAs" 
1322						CALLMONITOR 
1322					endif 
1322 eb			      ex    DE, HL                  ; Calculate address of new free block 
1323 2b			      dec   HL 
1324 2b			      dec   HL 
1325 2b			      dec   HL 
1326 09			      add   HL, BC 
1327			 
1327			      ; Create a new block and point it at next_free 
1327 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
132a dd 56 01		      ld    D, (IX+1) 
132d			 
132d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
132e 23			      inc   HL 
132f 72			      ld    (HL), D 
1330			 
1330 d1			      pop   DE                      ; Store size of new block into new block 
1331 23			      inc   HL 
1332 73			      ld    (HL), E 
1333 23			      inc   HL 
1334 72			      ld    (HL), D 
1335			 
1335			      ; Update this_free ptr to point to new block 
1335 2b			      dec   HL 
1336 2b			      dec   HL 
1337 2b			      dec   HL 
1338			 
1338 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
133b dd 56 03		      ld    D, (IX+3) 
133e			 
133e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1341 dd 74 03		      ld    (IX+3), H 
1344			 
1344			      ; Modify this_free block to be allocation 
1344 eb			      ex    DE, HL 
1345 af			      xor   A                       ; Null the next block ptr of allocated block 
1346 77			      ld    (HL), A 
1347 23			      inc   HL 
1348 77			      ld    (HL), A 
1349			 
1349 23			      inc   HL                      ; Store want size into allocated block 
134a 71			      ld    (HL), C 
134b 23			      inc   HL 
134c 70			      ld    (HL), B 
134d 23			      inc   HL 
134e e5			      push  HL                      ; Address of allocation to return 
134f			 
134f 18 19		      jr    malloc_update_links 
1351			 
1351			malloc_alloc_fit: 
1351 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1352			 
1352					if DEBUG_FORTH_MALLOC 
1352						DMARK "MAf" 
1352						CALLMONITOR 
1352					endif 
1352			      ; Modify this_free block to be allocation 
1352 eb			      ex    DE, HL 
1353 2b			      dec   HL 
1354 2b			      dec   HL 
1355 2b			      dec   HL 
1356			 
1356 af			      xor   A                       ; Null the next block ptr of allocated block 
1357 77			      ld    (HL), A 
1358 23			      inc   HL 
1359 77			      ld    (HL), A 
135a			 
135a 23			      inc   HL                      ; Store address of allocation to return 
135b 23			      inc   HL 
135c 23			      inc   HL 
135d e5			      push  HL 
135e			 
135e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
135e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1361 dd 66 01		      ld    H, (IX+1) 
1364			 
1364 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1367 dd 74 03		      ld    (IX+3), H 
136a			 
136a			 
136a			malloc_update_links: 
136a			      ; Update prev_free ptr to point to this_free 
136a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
136d dd 66 05		      ld    H, (IX+5) 
1370			 
1370 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1373 dd 56 03		      ld    D, (IX+3) 
1376			 
1376 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1377 23			      inc   HL 
1378 72			      ld    (HL), D 
1379			 
1379					if DEBUG_FORTH_MALLOC 
1379						DMARK "Mul" 
1379						CALLMONITOR 
1379					endif 
1379			      ; Clear the Z flag to indicate successful allocation 
1379 7a			      ld    A, D 
137a b3			      or    E 
137b			 
137b d1			      pop   DE                      ; Address of allocation 
137c					if DEBUG_FORTH_MALLOC 
137c						DMARK "MAu" 
137c						CALLMONITOR 
137c					endif 
137c			 
137c			malloc_no_space: 
137c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
137f 39			      add   HL, SP 
1380 f9			      ld    SP, HL 
1381			 
1381 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1382					if DEBUG_FORTH_MALLOC 
1382						DMARK "MAN" 
1382						CALLMONITOR 
1382					endif 
1382			 
1382			malloc_early_exit: 
1382					if DEBUG_FORTH_MALLOC 
1382						DMARK "MAx" 
1382						CALLMONITOR 
1382					endif 
1382 dd e1		      pop   IX 
1384 d1			      pop   DE 
1385 c1			      pop   BC 
1386			 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386 c9			      ret 
1387			 
1387			 
1387			;------------------------------------------------------------------------------ 
1387			;     free                                                                    : 
1387			;                                                                             : 
1387			; Description                                                                 : 
1387			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1387			;     returned by malloc, otherwise the behaviour is undefined.               : 
1387			;                                                                             : 
1387			;     Where possible, directly adjacent free blocks will be merged together   : 
1387			;     into larger blocks to help ensure that the heap does not become         : 
1387			;     excessively fragmented.                                                 : 
1387			;                                                                             : 
1387			;     free does not clear or set any other value into the freed space, and    : 
1387			;     therefore its contents may be visible through subsequent malloc's. The  : 
1387			;     caller should clear the freed space as required.                        : 
1387			;                                                                             : 
1387			;     This implementation of free uses the stack exclusively, and is          : 
1387			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1387			;     advisable to disable interrupts before calling free, and recommended    : 
1387			;     to avoid the use of free inside ISRs in general.                        : 
1387			;                                                                             : 
1387			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1387			;                                                                             : 
1387			; Parameters                                                                  : 
1387			;     HL  Pointer to address of first byte of allocation to be freed          : 
1387			;                                                                             : 
1387			; Returns                                                                     : 
1387			;     Nothing                                                                 : 
1387			;                                                                             : 
1387			; Stack frame                                                                 : 
1387			;       |             |                                                       : 
1387			;       +-------------+                                                       : 
1387			;       |     BC      |                                                       : 
1387			;       +-------------+                                                       : 
1387			;       |     DE      |                                                       : 
1387			;       +-------------+                                                       : 
1387			;       |     IX      |                                                       : 
1387			;       +-------------+                                                       : 
1387			;       |  prev_free  |                                                       : 
1387			;   +2  +-------------+                                                       : 
1387			;       |  next_free  |                                                       : 
1387			;   +0  +-------------+                                                       : 
1387			;       |             |                                                       : 
1387			;                                                                             : 
1387			;------------------------------------------------------------------------------ 
1387			free: 
1387 c5			      push  BC 
1388 d5			      push  DE 
1389 dd e5		      push  IX 
138b			 
138b 7c			      ld    A, H                    ; Exit if ptr is null 
138c b5			      or    L 
138d ca 51 14		      jp    Z, free_early_exit 
1390			 
1390			      ; Set up stack frame 
1390 eb			      ex    DE, HL 
1391 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1394 39			      add   HL, SP 
1395 f9			      ld    SP, HL 
1396 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
139a dd 39		      add   IX, SP 
139c			 
139c			      ; The address in HL points to the start of the useable allocated space, 
139c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
139c			      ; address of the block itself. 
139c eb			      ex    DE, HL 
139d 11 fc ff		      ld    DE, -4 
13a0 19			      add   HL, DE 
13a1			 
13a1			      ; An allocated block must have a null next block pointer in it 
13a1 7e			      ld    A, (HL) 
13a2 23			      inc   HL 
13a3 b6			      or    (HL) 
13a4 c2 4c 14		      jp    NZ, free_done 
13a7			 
13a7 2b			      dec   HL 
13a8			 
13a8 44			      ld    B, H                    ; Copy HL to BC 
13a9 4d			      ld    C, L 
13aa			 
13aa			      ; Loop through the free list to find the first block with an address 
13aa			      ; higher than the block being freed 
13aa 21 0a 80		      ld    HL, free_list 
13ad			 
13ad			free_find_higher_block: 
13ad 5e			      ld    E, (HL)                 ; Load next ptr from free block 
13ae 23			      inc   HL 
13af 56			      ld    D, (HL) 
13b0 2b			      dec   HL 
13b1			 
13b1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13b4 dd 72 01		      ld    (IX+1), D 
13b7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ba dd 74 03		      ld    (IX+3), H 
13bd			 
13bd 78			      ld    A, B                    ; Check if DE is greater than BC 
13be ba			      cp    D                       ; Compare MSB first 
13bf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13c1 30 04		      jr    NC, free_find_higher_block_skip 
13c3 79			      ld    A, C 
13c4 bb			      cp    E                       ; Then compare LSB 
13c5 38 08		      jr    C, free_found_higher_block 
13c7			 
13c7			free_find_higher_block_skip: 
13c7 7a			      ld    A, D                    ; Reached the end of the free list? 
13c8 b3			      or    E 
13c9 ca 4c 14		      jp    Z, free_done 
13cc			 
13cc eb			      ex    DE, HL 
13cd			 
13cd 18 de		      jr    free_find_higher_block 
13cf			 
13cf			free_found_higher_block: 
13cf			      ; Insert freed block between prev and next free blocks 
13cf 71			      ld    (HL), C                 ; Point prev free block to freed block 
13d0 23			      inc   HL 
13d1 70			      ld    (HL), B 
13d2			 
13d2 60			      ld    H, B                    ; Point freed block at next free block 
13d3 69			      ld    L, C 
13d4 73			      ld    (HL), E 
13d5 23			      inc   HL 
13d6 72			      ld    (HL), D 
13d7			 
13d7			      ; Check if the freed block is adjacent to the next free block 
13d7 23			      inc   HL                      ; Load size of freed block into HL 
13d8 5e			      ld    E, (HL) 
13d9 23			      inc   HL 
13da 56			      ld    D, (HL) 
13db eb			      ex    DE, HL 
13dc			 
13dc 09			      add   HL, BC                  ; Add addr of freed block and its size 
13dd			 
13dd dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13e0 dd 56 01		      ld    D, (IX+1) 
13e3			 
13e3 b7			      or    A                       ; Clear the carry flag 
13e4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13e6 20 22		      jr    NZ, free_check_adjacent_to_prev 
13e8			 
13e8			      ; Freed block is adjacent to next, merge into one bigger block 
13e8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13e9 5e			      ld    E, (HL) 
13ea 23			      inc   HL 
13eb 56			      ld    D, (HL) 
13ec e5			      push  HL                      ; Save ptr to next block for later 
13ed			 
13ed 60			      ld    H, B                    ; Store ptr from next block into freed block 
13ee 69			      ld    L, C 
13ef 73			      ld    (HL), E 
13f0 23			      inc   HL 
13f1 72			      ld    (HL), D 
13f2			 
13f2 e1			      pop   HL                      ; Restore ptr to next block 
13f3 23			      inc   HL                      ; Load size of next block into DE 
13f4 5e			      ld    E, (HL) 
13f5 23			      inc   HL 
13f6 56			      ld    D, (HL) 
13f7 d5			      push  DE                      ; Save next block size for later 
13f8			 
13f8 60			      ld    H, B                    ; Load size of freed block into HL 
13f9 69			      ld    L, C 
13fa 23			      inc   HL 
13fb 23			      inc   HL 
13fc 5e			      ld    E, (HL) 
13fd 23			      inc   HL 
13fe 56			      ld    D, (HL) 
13ff eb			      ex    DE, HL 
1400			 
1400 d1			      pop   DE                      ; Restore size of next block 
1401 19			      add   HL, DE                  ; Add sizes of both blocks 
1402 eb			      ex    DE, HL 
1403			 
1403 60			      ld    H, B                    ; Store new bigger size into freed block 
1404 69			      ld    L, C 
1405 23			      inc   HL 
1406 23			      inc   HL 
1407 73			      ld    (HL), E 
1408 23			      inc   HL 
1409 72			      ld    (HL), D 
140a			 
140a			free_check_adjacent_to_prev: 
140a			      ; Check if the freed block is adjacent to the prev free block 
140a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
140d dd 66 03		      ld    H, (IX+3) 
1410			 
1410 23			      inc   HL                      ; Size of prev free block into DE 
1411 23			      inc   HL 
1412 5e			      ld    E, (HL) 
1413 23			      inc   HL 
1414 56			      ld    D, (HL) 
1415 2b			      dec   HL 
1416 2b			      dec   HL 
1417 2b			      dec   HL 
1418			 
1418 19			      add   HL, DE                  ; Add prev block addr and size 
1419			 
1419 b7			      or    A                       ; Clear the carry flag 
141a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
141c 20 2e		      jr    NZ, free_done 
141e			 
141e			      ; Freed block is adjacent to prev, merge into one bigger block 
141e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
141f 69			      ld    L, C 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 e5			      push  HL                      ; Save freed block ptr for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1427 dd 66 03		      ld    H, (IX+3) 
142a 73			      ld    (HL), E 
142b 23			      inc   HL 
142c 72			      ld    (HL), D 
142d			 
142d e1			      pop   HL                      ; Restore freed block ptr 
142e 23			      inc   HL                      ; Load size of freed block into DE 
142f 5e			      ld    E, (HL) 
1430 23			      inc   HL 
1431 56			      ld    D, (HL) 
1432 d5			      push  DE                      ; Save freed block size for later 
1433			 
1433 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1436 dd 66 03		      ld    H, (IX+3) 
1439 23			      inc   HL 
143a 23			      inc   HL 
143b 5e			      ld    E, (HL) 
143c 23			      inc   HL 
143d 56			      ld    D, (HL) 
143e			 
143e e1			      pop   HL                      ; Add sizes of both blocks 
143f 19			      add   HL, DE 
1440 eb			      ex    DE, HL 
1441			 
1441 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1444 dd 66 03		      ld    H, (IX+3) 
1447 23			      inc   HL 
1448 23			      inc   HL 
1449 73			      ld    (HL), E 
144a 23			      inc   HL 
144b 72			      ld    (HL), D 
144c			 
144c			free_done: 
144c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
144f 39			      add   HL, SP 
1450 f9			      ld    SP, HL 
1451			 
1451			free_early_exit: 
1451 dd e1		      pop   IX 
1453 d1			      pop   DE 
1454 c1			      pop   BC 
1455			 
1455 c9			      ret 
1456			 
1456			; moved to firmware.asm 
1456			; 
1456			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1456			;                  .dw   0 
1456			 
1456			 
1456			endif 
1456			 
1456			 
1456			if MALLOC_3 
1456			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1456			;heap_start        .equ  0x9000      ; Starting address of heap 
1456			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1456			; 
1456			 ;     .org 0 
1456			  ;    jp    main 
1456			; 
1456			; 
1456			 ;     .org  0x100 
1456			;main: 
1456			 ;     ld    HL, 0x8100 
1456			  ;    ld    SP, HL 
1456			; 
1456			;      call  heap_init 
1456			 
1456			      ; Make some allocations 
1456			;      ld    HL, 12 
1456			;      call  malloc            ; Allocates 0x9004 
1456			; 
1456			 ;     ld    HL, 12 
1456			;      call  malloc            ; Allocates 0x9014 
1456			 
1456			;      ld    HL, 12 
1456			;      call  malloc            ; Allocates 0x9024 
1456			 
1456			      ; Free some allocations 
1456			;      ld    HL, 0x9014 
1456			;      call  free 
1456			 
1456			;      ld    HL, 0x9004 
1456			;      call  free 
1456			; 
1456			;      ld    HL, 0x9024 
1456			;      call  free 
1456			 
1456			 
1456			 ;     halt 
1456			 
1456			 
1456			;------------------------------------------------------------------------------ 
1456			;     heap_init                                                               : 
1456			;                                                                             : 
1456			; Description                                                                 : 
1456			;     Initialise the heap and make it ready for malloc and free operations.   : 
1456			;                                                                             : 
1456			;     The heap is maintained as a linked list, starting with an initial       : 
1456			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1456			;     the first free block in the heap. Each block then points to the next    : 
1456			;     free block within the heap, and the free list ends at the first block   : 
1456			;     with a null pointer to the next free block.                             : 
1456			;                                                                             : 
1456			; Parameters                                                                  : 
1456			;     Inputs are compile-time only. Two defines which specify the starting    : 
1456			;     address of the heap and its size are required, along with a memory      : 
1456			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1456			;     principally stores a pointer to the first free block in the heap.       : 
1456			;                                                                             : 
1456			; Returns                                                                     : 
1456			;     Nothing                                                                 : 
1456			;------------------------------------------------------------------------------ 
1456			heap_init: 
1456			      push  HL 
1456			 
1456			      ; Initialise free list struct 
1456			      ld    HL, heap_start 
1456			      ld    (free_list), HL 
1456			      ld    HL, 0 
1456			      ld    (free_list+2), HL 
1456			 
1456			      ; Insert first free block at bottom of heap, consumes entire heap 
1456			      ld    HL, heap_start+heap_size-4 
1456			      ld    (heap_start), HL        ; Next block (end of free list) 
1456			      ld    HL, heap_size-4 
1456			      ld    (heap_start+2), HL      ; Block size 
1456			 
1456			      ; Insert end of free list block at top of heap - two null words will 
1456			      ; terminate the free list 
1456			      ld    HL, 0 
1456			      ld    (heap_start+heap_size-2), HL 
1456			      ld    (heap_start+heap_size-4), HL 
1456			 
1456			      pop   HL 
1456			 
1456			      ret 
1456			 
1456			 
1456			;------------------------------------------------------------------------------ 
1456			;     malloc                                                                  : 
1456			;                                                                             : 
1456			; Description                                                                 : 
1456			;     Allocates the wanted space from the heap and returns the address of the : 
1456			;     first useable byte of the allocation.                                   : 
1456			;                                                                             : 
1456			;     Allocations can happen in one of two ways:                              : 
1456			;                                                                             : 
1456			;     1. A free block may be found which is the exact size wanted. In this    : 
1456			;        case the block is removed from the free list and retuedn to the      : 
1456			;        caller.                                                              : 
1456			;     2. A free block may be found which is larger than the size wanted. In   : 
1456			;        this case, the larger block is split into two. The first portion of  : 
1456			;        this block will become the requested space by the malloc call and    : 
1456			;        is returned to the caller. The second portion becomes a new free     : 
1456			;        block, and the free list is adjusted to maintain continuity via this : 
1456			;        newly created block.                                                 : 
1456			;                                                                             : 
1456			;     malloc does not set any initial value in the allocated space, the       : 
1456			;     caller is required to do this as required.                              : 
1456			;                                                                             : 
1456			;     This implementation of malloc uses the stack exclusively, and is        : 
1456			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1456			;     advisable to disable interrupts before calling malloc, and recommended  : 
1456			;     to avoid the use of malloc inside ISRs in general.                      : 
1456			;                                                                             : 
1456			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1456			;                                                                             : 
1456			; Parameters                                                                  : 
1456			;     HL  Number of bytes wanted                                              : 
1456			;                                                                             : 
1456			; Returns                                                                     : 
1456			;     HL  Address of the first useable byte of the allocation                 : 
1456			;                                                                             : 
1456			; Flags                                                                       : 
1456			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1456			;                                                                             : 
1456			; Stack frame                                                                 : 
1456			;       |             |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |     BC      |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |     DE      |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |     IX      |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |  prev_free  |                                                       : 
1456			;   +4  +-------------+                                                       : 
1456			;       |  this_free  |                                                       : 
1456			;   +2  +-------------+                                                       : 
1456			;       |  next_free  |                                                       : 
1456			;   +0  +-------------+                                                       : 
1456			;       |             |                                                       : 
1456			;                                                                             : 
1456			;------------------------------------------------------------------------------ 
1456			malloc: 
1456			      push  BC 
1456			      push  DE 
1456			      push  IX 
1456			 
1456			      ld    A, H                    ; Exit if no space requested 
1456			      or    L 
1456			      jp    Z, malloc_early_exit 
1456			 
1456			      ; Set up stack frame 
1456			      ex    DE, HL 
1456			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1456			      add   HL, SP 
1456			      ld    SP, HL 
1456			      ld    IX, 0                   ; Use IX as a frame pointer 
1456			      add   IX, SP 
1456			 
1456			      ; Setup initial state 
1456			      ld    HL, 4                   ; want must also include space used by block struct 
1456			      add   HL, DE 
1456			 
1456			      ld    B, H                    ; Move want to BC 
1456			      ld    C, L 
1456			 
1456			      ld    HL, free_list           ; Store prev_free ptr to stack 
1456			      ld    (IX+4), L 
1456			      ld    (IX+5), H 
1456			 
1456			      ld    E, (HL)                 ; Store this_free ptr to stack 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      ld    (IX+2), E 
1456			      ld    (IX+3), D 
1456			      ex    DE, HL                  ; this_free ptr into HL 
1456			 
1456			      ; Loop through free block list to find some space 
1456			malloc_find_space: 
1456			      ld    E, (HL)                 ; Load next_free ptr into DE 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			 
1456			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1456			      or    E 
1456			      jp    Z, malloc_no_space 
1456			 
1456			      ld    (IX+0), E               ; Store next_free ptr to stack 
1456			      ld    (IX+1), D 
1456			 
1456			      ; Does this block have enough space to make the allocation? 
1456			      inc   HL                      ; Load free block size into DE 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			 
1456			      ex    DE, HL                  ; Check size of block against want 
1456			      or    A                       ; Ensure carry flag clear 
1456			      sbc   HL, BC 
1456			      push  HL                      ; Store the result for later (new block size) 
1456			 
1456			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1456			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1456			 
1456			      ; this_free block is not big enough, setup ptrs to test next free block 
1456			      pop   HL                      ; Discard previous result 
1456			 
1456			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1456			      ld    H, (IX+3) 
1456			      ld    (IX+4), L 
1456			      ld    (IX+5), H 
1456			 
1456			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1456			      ld    H, (IX+1) 
1456			      ld    (IX+2), L 
1456			      ld    (IX+3), H 
1456			 
1456			      jr    malloc_find_space 
1456			 
1456			      ; split a bigger block into two - requested size and remaining size 
1456			malloc_alloc_split: 
1456			      ex    DE, HL                  ; Calculate address of new free block 
1456			      dec   HL 
1456			      dec   HL 
1456			      dec   HL 
1456			      add   HL, BC 
1456			 
1456			      ; Create a new block and point it at next_free 
1456			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1456			      ld    D, (IX+1) 
1456			 
1456			      ld    (HL), E                 ; Store next_free ptr into new block 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			      pop   DE                      ; Store size of new block into new block 
1456			      inc   HL 
1456			      ld    (HL), E 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			      ; Update this_free ptr to point to new block 
1456			      dec   HL 
1456			      dec   HL 
1456			      dec   HL 
1456			 
1456			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1456			      ld    D, (IX+3) 
1456			 
1456			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1456			      ld    (IX+3), H 
1456			 
1456			      ; Modify this_free block to be allocation 
1456			      ex    DE, HL 
1456			      xor   A                       ; Null the next block ptr of allocated block 
1456			      ld    (HL), A 
1456			      inc   HL 
1456			      ld    (HL), A 
1456			 
1456			      inc   HL                      ; Store want size into allocated block 
1456			      ld    (HL), C 
1456			      inc   HL 
1456			      ld    (HL), B 
1456			      inc   HL 
1456			      push  HL                      ; Address of allocation to return 
1456			 
1456			      jr    malloc_update_links 
1456			 
1456			malloc_alloc_fit: 
1456			      pop   HL                      ; Dont need new block size, want is exact fit 
1456			 
1456			      ; Modify this_free block to be allocation 
1456			      ex    DE, HL 
1456			      dec   HL 
1456			      dec   HL 
1456			      dec   HL 
1456			 
1456			      xor   A                       ; Null the next block ptr of allocated block 
1456			      ld    (HL), A 
1456			      inc   HL 
1456			      ld    (HL), A 
1456			 
1456			      inc   HL                      ; Store address of allocation to return 
1456			      inc   HL 
1456			      inc   HL 
1456			      push  HL 
1456			 
1456			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1456			      ld    L, (IX+0)               ; next_free to HL 
1456			      ld    H, (IX+1) 
1456			 
1456			      ld    (IX+2), L               ; HL to this_free 
1456			      ld    (IX+3), H 
1456			 
1456			 
1456			malloc_update_links: 
1456			      ; Update prev_free ptr to point to this_free 
1456			      ld    L, (IX+4)               ; prev_free ptr to HL 
1456			      ld    H, (IX+5) 
1456			 
1456			      ld    E, (IX+2)               ; this_free ptr to DE 
1456			      ld    D, (IX+3) 
1456			 
1456			      ld    (HL), E                 ; this_free ptr into prev_free 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			      ; Clear the Z flag to indicate successful allocation 
1456			      ld    A, D 
1456			      or    E 
1456			 
1456			      pop   DE                      ; Address of allocation 
1456			 
1456			malloc_no_space: 
1456			      ld    HL, 6                   ; Clean up stack frame 
1456			      add   HL, SP 
1456			      ld    SP, HL 
1456			 
1456			      ex    DE, HL                  ; Alloc addr into HL for return 
1456			 
1456			malloc_early_exit: 
1456			      pop   IX 
1456			      pop   DE 
1456			      pop   BC 
1456			 
1456			      ret 
1456			 
1456			 
1456			;------------------------------------------------------------------------------ 
1456			;     free                                                                    : 
1456			;                                                                             : 
1456			; Description                                                                 : 
1456			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1456			;     returned by malloc, otherwise the behaviour is undefined.               : 
1456			;                                                                             : 
1456			;     Where possible, directly adjacent free blocks will be merged together   : 
1456			;     into larger blocks to help ensure that the heap does not become         : 
1456			;     excessively fragmented.                                                 : 
1456			;                                                                             : 
1456			;     free does not clear or set any other value into the freed space, and    : 
1456			;     therefore its contents may be visible through subsequent malloc's. The  : 
1456			;     caller should clear the freed space as required.                        : 
1456			;                                                                             : 
1456			;     This implementation of free uses the stack exclusively, and is          : 
1456			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1456			;     advisable to disable interrupts before calling free, and recommended    : 
1456			;     to avoid the use of free inside ISRs in general.                        : 
1456			;                                                                             : 
1456			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1456			;                                                                             : 
1456			; Parameters                                                                  : 
1456			;     HL  Pointer to address of first byte of allocation to be freed          : 
1456			;                                                                             : 
1456			; Returns                                                                     : 
1456			;     Nothing                                                                 : 
1456			;                                                                             : 
1456			; Stack frame                                                                 : 
1456			;       |             |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |     BC      |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |     DE      |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |     IX      |                                                       : 
1456			;       +-------------+                                                       : 
1456			;       |  prev_free  |                                                       : 
1456			;   +2  +-------------+                                                       : 
1456			;       |  next_free  |                                                       : 
1456			;   +0  +-------------+                                                       : 
1456			;       |             |                                                       : 
1456			;                                                                             : 
1456			;------------------------------------------------------------------------------ 
1456			free: 
1456			      push  BC 
1456			      push  DE 
1456			      push  IX 
1456			 
1456			      ld    A, H                    ; Exit if ptr is null 
1456			      or    L 
1456			      jp    Z, free_early_exit 
1456			 
1456			      ; Set up stack frame 
1456			      ex    DE, HL 
1456			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1456			      add   HL, SP 
1456			      ld    SP, HL 
1456			      ld    IX, 0                   ; Use IX as a frame pointer 
1456			      add   IX, SP 
1456			 
1456			      ; The address in HL points to the start of the useable allocated space, 
1456			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1456			      ; address of the block itself. 
1456			      ex    DE, HL 
1456			      ld    DE, -4 
1456			      add   HL, DE 
1456			 
1456			      ; An allocated block must have a null next block pointer in it 
1456			      ld    A, (HL) 
1456			      inc   HL 
1456			      or    (HL) 
1456			      jp    NZ, free_done 
1456			 
1456			      dec   HL 
1456			 
1456			      ld    B, H                    ; Copy HL to BC 
1456			      ld    C, L 
1456			 
1456			      ; Loop through the free list to find the first block with an address 
1456			      ; higher than the block being freed 
1456			      ld    HL, free_list 
1456			 
1456			free_find_higher_block: 
1456			      ld    E, (HL)                 ; Load next ptr from free block 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      dec   HL 
1456			 
1456			      ld    (IX+0), E               ; Save ptr to next free block 
1456			      ld    (IX+1), D 
1456			      ld    (IX+2), L               ; Save ptr to prev free block 
1456			      ld    (IX+3), H 
1456			 
1456			      ld    A, B                    ; Check if DE is greater than BC 
1456			      cp    D                       ; Compare MSB first 
1456			      jr    Z, $+4                  ; MSB the same, compare LSB 
1456			      jr    NC, free_find_higher_block_skip 
1456			      ld    A, C 
1456			      cp    E                       ; Then compare LSB 
1456			      jr    C, free_found_higher_block 
1456			 
1456			free_find_higher_block_skip: 
1456			      ld    A, D                    ; Reached the end of the free list? 
1456			      or    E 
1456			      jp    Z, free_done 
1456			 
1456			      ex    DE, HL 
1456			 
1456			      jr    free_find_higher_block 
1456			 
1456			free_found_higher_block: 
1456			      ; Insert freed block between prev and next free blocks 
1456			      ld    (HL), C                 ; Point prev free block to freed block 
1456			      inc   HL 
1456			      ld    (HL), B 
1456			 
1456			      ld    H, B                    ; Point freed block at next free block 
1456			      ld    L, C 
1456			      ld    (HL), E 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			      ; Check if the freed block is adjacent to the next free block 
1456			      inc   HL                      ; Load size of freed block into HL 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      ex    DE, HL 
1456			 
1456			      add   HL, BC                  ; Add addr of freed block and its size 
1456			 
1456			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1456			      ld    D, (IX+1) 
1456			 
1456			      or    A                       ; Clear the carry flag 
1456			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1456			      jr    NZ, free_check_adjacent_to_prev 
1456			 
1456			      ; Freed block is adjacent to next, merge into one bigger block 
1456			      ex    DE, HL                  ; Load next ptr from next block into DE 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      push  HL                      ; Save ptr to next block for later 
1456			 
1456			      ld    H, B                    ; Store ptr from next block into freed block 
1456			      ld    L, C 
1456			      ld    (HL), E 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			      pop   HL                      ; Restore ptr to next block 
1456			      inc   HL                      ; Load size of next block into DE 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      push  DE                      ; Save next block size for later 
1456			 
1456			      ld    H, B                    ; Load size of freed block into HL 
1456			      ld    L, C 
1456			      inc   HL 
1456			      inc   HL 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      ex    DE, HL 
1456			 
1456			      pop   DE                      ; Restore size of next block 
1456			      add   HL, DE                  ; Add sizes of both blocks 
1456			      ex    DE, HL 
1456			 
1456			      ld    H, B                    ; Store new bigger size into freed block 
1456			      ld    L, C 
1456			      inc   HL 
1456			      inc   HL 
1456			      ld    (HL), E 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			free_check_adjacent_to_prev: 
1456			      ; Check if the freed block is adjacent to the prev free block 
1456			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1456			      ld    H, (IX+3) 
1456			 
1456			      inc   HL                      ; Size of prev free block into DE 
1456			      inc   HL 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      dec   HL 
1456			      dec   HL 
1456			      dec   HL 
1456			 
1456			      add   HL, DE                  ; Add prev block addr and size 
1456			 
1456			      or    A                       ; Clear the carry flag 
1456			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1456			      jr    NZ, free_done 
1456			 
1456			      ; Freed block is adjacent to prev, merge into one bigger block 
1456			      ld    H, B                    ; Load next ptr from freed block into DE 
1456			      ld    L, C 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      push  HL                      ; Save freed block ptr for later 
1456			 
1456			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1456			      ld    H, (IX+3) 
1456			      ld    (HL), E 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			      pop   HL                      ; Restore freed block ptr 
1456			      inc   HL                      ; Load size of freed block into DE 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			      push  DE                      ; Save freed block size for later 
1456			 
1456			      ld    L, (IX+2)               ; Load size of prev block into DE 
1456			      ld    H, (IX+3) 
1456			      inc   HL 
1456			      inc   HL 
1456			      ld    E, (HL) 
1456			      inc   HL 
1456			      ld    D, (HL) 
1456			 
1456			      pop   HL                      ; Add sizes of both blocks 
1456			      add   HL, DE 
1456			      ex    DE, HL 
1456			 
1456			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1456			      ld    H, (IX+3) 
1456			      inc   HL 
1456			      inc   HL 
1456			      ld    (HL), E 
1456			      inc   HL 
1456			      ld    (HL), D 
1456			 
1456			free_done: 
1456			      ld    HL, 4                   ; Clean up stack frame 
1456			      add   HL, SP 
1456			      ld    SP, HL 
1456			 
1456			free_early_exit: 
1456			      pop   IX 
1456			      pop   DE 
1456			      pop   BC 
1456			 
1456			      ret 
1456			 
1456			 
1456			;      .org 0x8000 
1456			; 
1456			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1456			 ;                 .dw   0 
1456			 
1456			endif 
1456			 
1456			 
1456			if MALLOC_4 
1456			 
1456			; My memory allocation code. Very very simple.... 
1456			; allocate space under 250 chars 
1456			 
1456			heap_init: 
1456				; init start of heap as zero 
1456				;  
1456			 
1456				ld hl, heap_start 
1456				ld a, 0 
1456				ld (hl), a      ; empty block 
1456				inc hl 
1456				ld a, 0 
1456				ld (hl), a      ; length of block 
1456				; write end of list 
1456				inc hl 
1456				ld a,(hl) 
1456				inc hl 
1456				ld a,(hl) 
1456				 
1456			 
1456				; init some malloc vars 
1456			 
1456				ld hl, 0 
1456				ld (free_list), hl       ; store last malloc location 
1456			 
1456				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1456				ld a, 0 
1456				ld (hl), a 
1456			 
1456			 
1456				ld hl, heap_start 
1456				;  
1456				  
1456				ret 
1456			 
1456			 
1456			;    free block marker 
1456			;    requested size  
1456			;    pointer to next block 
1456			;    .... 
1456			;    next block marker 
1456			 
1456			 
1456			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1456			; 
1456			 
1456			 
1456			malloc:  
1456				push de 
1456				push bc 
1456				push af 
1456			 
1456				; hl space required 
1456				 
1456				ld c, l    ; hold space   (TODO only a max of 255) 
1456			 
1456			;	inc c     ; TODO BUG need to fix memory leak on push str 
1456			;	inc c 
1456			;	inc c 
1456			;	inc c 
1456			;	inc c 
1456			;	inc c 
1456			;	inc c 
1456			 
1456			 
1456			 
1456				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1456			 
1456				ld a, (free_list+3) 
1456				cp 0 
1456				jr z, .contheap 
1456			 
1456				ld hl, (free_list)     ; get last alloc 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "mrs" 
1456						CALLMONITOR 
1456					endif 
1456				jr .startalloc 
1456			 
1456			.contheap: 
1456				ld hl, heap_start 
1456			 
1456			.startalloc: 
1456			 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "mym" 
1456						CALLMONITOR 
1456					endif 
1456			.findblock: 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "mmf" 
1456						CALLMONITOR 
1456					endif 
1456			 
1456				ld a,(hl)  
1456				; if byte is zero then clear to use 
1456			 
1456				cp 0 
1456				jr z, .foundemptyblock 
1456			 
1456				; if byte is not clear 
1456				;     then byte is offset to next block 
1456			 
1456				inc hl 
1456				ld a, (hl) ; get size 
1456			.nextblock:	inc hl 
1456					ld e, (hl) 
1456					inc hl 
1456					ld d, (hl) 
1456					ex de, hl 
1456			;	inc hl  ; move past the store space 
1456			;	inc hl  ; move past zero index  
1456			 
1456				; TODO detect no more space 
1456			 
1456				push hl 
1456				ld de, heap_end 
1456				call cmp16 
1456				pop hl 
1456				jr nc, .nospace 
1456			 
1456				jr .findblock 
1456			 
1456			.nospace: ld hl, 0 
1456				jp .exit 
1456			 
1456			 
1456			.foundemptyblock:	 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "mme" 
1456						CALLMONITOR 
1456					endif 
1456			 
1456			; TODO has block enough space if reusing??? 
1456			 
1456				;  
1456			 
1456			; see if this block has been previously used 
1456				inc hl 
1456				ld a, (hl) 
1456				dec hl 
1456				cp 0 
1456				jr z, .newblock 
1456			 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "meR" 
1456						CALLMONITOR 
1456					endif 
1456			 
1456			; no reusing previously allocated block 
1456			 
1456			; is it smaller than previously used? 
1456				 
1456				inc hl    ; move to size 
1456				ld a, c 
1456				sub (hl)        ; we want c < (hl) 
1456				dec hl    ; move back to marker 
1456			        jr z, .findblock 
1456			 
1456				; update with the new size which should be lower 
1456			 
1456			        ;inc  hl   ; negate next move. move back to size  
1456			 
1456			.newblock: 
1456				; need to be at marker here 
1456			 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "meN" 
1456						CALLMONITOR 
1456					endif 
1456			 
1456			 
1456				ld a, c 
1456			 
1456				ld (free_list+3), a	 ; flag resume from last malloc  
1456				ld (free_list), hl    ; save out last location 
1456			 
1456			 
1456				;inc a     ; space for length byte 
1456				ld (hl), a     ; save block in use marker 
1456			 
1456				inc hl   ; move to space marker 
1456				ld (hl), a    ; save new space 
1456			 
1456				inc hl   ; move to start of allocated area 
1456				 
1456			;	push hl     ; save where we are - 1  
1456			 
1456			;	inc hl  ; move past zero index  
1456				; skip space to set down new marker 
1456			 
1456				; provide some extra space for now 
1456			 
1456				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1456				inc a 
1456				inc a 
1456			 
1456				push hl   ; save where we are in the node block 
1456			 
1456				call addatohl 
1456			 
1456				; write linked list point 
1456			 
1456				pop de     ; get our node position 
1456				ex de, hl 
1456			 
1456				ld (hl), e 
1456				inc hl 
1456				ld (hl), d 
1456			 
1456				inc hl 
1456			 
1456				; now at start of allocated data so save pointer 
1456			 
1456				push hl 
1456			 
1456				; jump to position of next node and setup empty header in DE 
1456			 
1456				ex de, hl 
1456			 
1456			;	inc hl ; move past end of block 
1456			 
1456				ld a, 0 
1456				ld (hl), a   ; empty marker 
1456				inc hl 
1456				ld (hl), a   ; size 
1456				inc hl  
1456				ld (hl), a   ; ptr 
1456				inc hl 
1456				ld (hl), a   ; ptr 
1456			 
1456			 
1456				pop hl 
1456			 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "mmr" 
1456						CALLMONITOR 
1456					endif 
1456			 
1456			.exit: 
1456				pop af 
1456				pop bc 
1456				pop de  
1456				ret 
1456			 
1456			 
1456			 
1456			 
1456			free:  
1456				push hl 
1456				push af 
1456				; get address in hl 
1456			 
1456					if DEBUG_FORTH_MALLOC_INT 
1456						DMARK "fre" 
1456						CALLMONITOR 
1456					endif 
1456				; data is at hl - move to block count 
1456				dec hl 
1456				dec hl    ; get past pointer 
1456				dec hl 
1456			 
1456				ld a, (hl)    ; need this for a validation check 
1456			 
1456				dec hl    ; move to block marker 
1456			 
1456				; now check that the block count and block marker are the same  
1456			        ; this checks that we are on a malloc node and not random memory 
1456			        ; OK a faint chance this could be a problem but rare - famous last words! 
1456			 
1456				ld c, a 
1456				ld a, (hl)    
1456			 
1456				cp c 
1456				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1456			 
1456				; yes good chance we are on a malloc node 
1456			 
1456				ld a, 0      
1456				ld (hl), a   ; mark as free 
1456			 
1456				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1456			 
1456			.freeignore:  
1456			 
1456				pop af 
1456				pop hl 
1456			 
1456				ret 
1456			 
1456			 
1456			 
1456			endif 
1456			 
1456			; eof 
# End of file firmware_memory.asm
1456			  
1456			; device C  
1456			if SOUND_ENABLE  
1456				include "firmware_sound.asm"  
1456			; Sound abstraction layer 
1456			 
1456			; support different sound chips through common interface 
1456			 
1456			SOUND_DEVICE_AY: equ 0 
1456			 
1456			SOUND_DEVICE: equ Device_A 
1456			 
1456			 
1456			 
1456			if SOUND_DEVICE_AY 
1456				include "firmware_sound_ay38910.asm" 
1456			else 
1456				include "firmware_sound_sn76489an.asm" 
1456			 
1456			; Device support for SN76489AN sound chip 
1456			 
1456			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1456			; http://danceswithferrets.org/geekblog/?p=93 
1456			; https://www.smspower.org/Development/SN76489 
1456			 
1456			; D0 [ 3] 
1456			; D1 [ 2] 
1456			; D2 [ 1] 
1456			; D3 [15] 
1456			; D4 [13] 
1456			; D5 [12] 
1456			; D6 [11] 
1456			; D7 [10] 
1456			; /WE [ 5] 
1456			; CLK [14] 
1456			; /OE [ 6] 
1456			; AUDIO [ 7] 
1456			; GND 8 
1456			; +5 16 
1456			; 
1456			 
1456			; Write sequence: 
1456			; CE low 
1456			; Data bus 
1456			; WE low then high 
1456			; 32 clock cycles / 8ns write time at 4mhz 
1456			; 
1456			; https://github.com/jblang/SN76489 
1456			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1456			; Tried: 
1456			; 
1456			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1456			; 
1456			; Connected WE to OR too 
1456			;  
1456			; That enabled the clock when required 
1456			; However still random bus corruption. Need further investigation 
1456			 
1456			 
1456			SOUND_LATCH: equ 10000000B 
1456			SOUND_DATA: equ 0B 
1456			SOUND_CH0:  equ 0B    ; Tone 
1456			SOUND_CH1: equ 0100000B        ; Tone 
1456			SOUND_CH2: equ 1000000B   ; Tone 
1456			SOUND_CH3: equ 1100000B    ; Noise 
1456			SOUND_VOL: equ 10000B 
1456			SOUND_TONE: equ 0B 
1456			 
1456			 
1456			sound_init: 
1456 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1458 cd 6d 14			call note_send_byte 
145b 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
145d cd 6d 14			call note_send_byte 
1460 cd 33 0b			call delay250ms 
1463 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1465 cd 6d 14			call note_send_byte 
1468 cd 33 0b			call delay250ms 
146b c9				ret 
146c			 
146c			; Play a note 
146c			; h = note 
146c			; l = duration 
146c			; a = channel 
146c			 
146c			 
146c			;  frequ = clock / ( 2 x reg valu x 32 )  
146c			 
146c			note:  
146c				 
146c			 
146c c9				ret 
146d			 
146d			note_send_byte: 
146d				; byte in a 
146d			 
146d				; we high 
146d d3 40			out (Device_B), a 
146f			;	ld a, 1 
146f			;	call aDelayInMS 
146f 00				nop  
1470 00				nop  
1471 00				nop  
1472 00				nop  
1473				; we low 
1473 d3 40			out (Device_B), a 
1475			;	ld a, 1 
1475			;	call aDelayInMS 
1475 00				nop  
1476 00				nop  
1477 00				nop  
1478 00				nop  
1479				; we high 
1479 d3 40			out (Device_B), a 
147b			;	ld a, 1 
147b			;	call aDelayInMS 
147b 00				nop  
147c 00				nop  
147d 00				nop  
147e 00				nop  
147f			 
147f			 
147f c9				ret 
1480			 
1480			;void SilenceAllChannels() 
1480			;{ 
1480			;  SendByte(0x9f); 
1480			;  SendByte(0xbf); 
1480			;  SendByte(0xdf); 
1480			;  SendByte(0xff); 
1480			;} 
1480			 
1480			 
1480			; eof 
1480			 
# End of file firmware_sound_sn76489an.asm
1480			endif 
1480			 
1480			 
1480			; Abstraction entry points 
1480			 
1480			; init  
1480			 
1480			; sound_init in specific hardware files 
1480			 
1480			; Play a note 
1480			; h = note 
1480			; l = duration 
1480			; a = channel 
1480			 
1480			;note:     
1480			;	ret 
1480			 
1480			 
1480			 
1480			 
1480			; eof 
1480			 
# End of file firmware_sound.asm
1480			endif  
1480			  
1480			include "firmware_diags.asm"  
1480			; Hardware diags menu 
1480			 
1480			 
1480			config: 
1480			 
1480 3e 00			ld a, 0 
1482 21 b0 14			ld hl, .configmn 
1485 cd f3 0b			call menu 
1488			 
1488 fe 00			cp 0 
148a c8				ret z 
148b			 
148b fe 01			cp 1 
148d cc 89 15			call z, .savetostore 
1490			 
1490 fe 02			cp 2 
1492 cc d7 14			call z, .selautoload 
1495 fe 03			cp 3 
1497 cc c0 14			call z, .disautoload 
149a fe 04			cp 4 
149c cc 87 15			call z, .selbank 
149f fe 05			cp 5 
14a1 cc 64 16			call z, .debug_tog 
14a4 fe 06			cp 6 
14a6 cc a7 17			call z, .bpsgo 
14a9 fe 07			cp 7 
14ab cc 8a 16			call z, hardware_diags 
14ae			 
14ae 18 d0			jr config 
14b0			 
14b0			.configmn: 
14b0 98 19			dw prom_c3 
14b2 af 19			dw prom_c2 
14b4 c4 19			dw prom_c2a 
14b6 da 19			dw prom_c2b 
14b8			;	dw prom_c4 
14b8 f7 19			dw prom_m4 
14ba 12 1a			dw prom_m4b 
14bc 1a 1a			dw prom_c1 
14be 00 00			dw 0 
14c0				 
14c0			 
14c0			 
14c0			 
14c0			.disautoload: 
14c0				if STORAGE_SE 
14c0 3e fe			ld a, $fe      ; bit 0 clear 
14c2 32 3f fb			ld (spi_device), a 
14c5			 
14c5 cd 85 04			call storage_get_block_0 
14c8			 
14c8 3e 00			ld a, 0 
14ca 32 7a fb			ld (store_page+STORE_0_AUTOFILE), a 
14cd			 
14cd 21 00 00				ld hl, 0 
14d0 11 59 fb				ld de, store_page 
14d3 cd 39 04			call storage_write_block	 ; save update 
14d6				else 
14d6			 
14d6				ld hl, prom_notav 
14d6				ld de, prom_empty 
14d6				call info_panel 
14d6				endif 
14d6			 
14d6			 
14d6 c9				ret 
14d7			 
14d7			 
14d7			 
14d7			; Select auto start 
14d7			 
14d7			.selautoload: 
14d7			 
14d7				 
14d7				if STORAGE_SE 
14d7			 
14d7 cd ae 15				call config_dir 
14da 21 d4 f2			        ld hl, scratch 
14dd 3e 00				ld a, 0 
14df cd f3 0b				call menu 
14e2			 
14e2 fe 00				cp 0 
14e4 c8					ret z 
14e5			 
14e5 3d					dec a 
14e6			 
14e6			 
14e6					; locate menu option 
14e6			 
14e6 21 d4 f2				ld hl, scratch 
14e9 cd 17 0b				call table_lookup 
14ec			 
14ec					if DEBUG_FORTH_WORDS 
14ec						DMARK "ALl" 
14ec f5				push af  
14ed 3a 01 15			ld a, (.dmark)  
14f0 32 6e fe			ld (debug_mark),a  
14f3 3a 02 15			ld a, (.dmark+1)  
14f6 32 6f fe			ld (debug_mark+1),a  
14f9 3a 03 15			ld a, (.dmark+2)  
14fc 32 70 fe			ld (debug_mark+2),a  
14ff 18 03			jr .pastdmark  
1501 ..			.dmark: db "ALl"  
1504 f1			.pastdmark: pop af  
1505			endm  
# End of macro DMARK
1505						CALLMONITOR 
1505 cd 9d 17			call break_point_state  
1508				endm  
# End of macro CALLMONITOR
1508					endif 
1508					; with the pointer to the menu it, the byte following the zero term is the file id 
1508			 
1508 3e 00				ld a, 0 
150a 01 32 00				ld bc, 50   ; max of bytes to look at 
150d ed b1				cpir  
150f			 
150f					if DEBUG_FORTH_WORDS 
150f						DMARK "ALb" 
150f f5				push af  
1510 3a 24 15			ld a, (.dmark)  
1513 32 6e fe			ld (debug_mark),a  
1516 3a 25 15			ld a, (.dmark+1)  
1519 32 6f fe			ld (debug_mark+1),a  
151c 3a 26 15			ld a, (.dmark+2)  
151f 32 70 fe			ld (debug_mark+2),a  
1522 18 03			jr .pastdmark  
1524 ..			.dmark: db "ALb"  
1527 f1			.pastdmark: pop af  
1528			endm  
# End of macro DMARK
1528						CALLMONITOR 
1528 cd 9d 17			call break_point_state  
152b				endm  
# End of macro CALLMONITOR
152b					endif 
152b					;inc hl 
152b			 
152b 7e					ld a, (hl)   ; file id 
152c					 
152c				        ; save bank and file ids 
152c			 
152c f5					push af 
152d			 
152d			; TODO need to save to block 0 on bank 1	 
152d			 
152d cd 85 04				call storage_get_block_0 
1530			 
1530					if DEBUG_FORTH_WORDS 
1530						DMARK "AL0" 
1530 f5				push af  
1531 3a 45 15			ld a, (.dmark)  
1534 32 6e fe			ld (debug_mark),a  
1537 3a 46 15			ld a, (.dmark+1)  
153a 32 6f fe			ld (debug_mark+1),a  
153d 3a 47 15			ld a, (.dmark+2)  
1540 32 70 fe			ld (debug_mark+2),a  
1543 18 03			jr .pastdmark  
1545 ..			.dmark: db "AL0"  
1548 f1			.pastdmark: pop af  
1549			endm  
# End of macro DMARK
1549						CALLMONITOR 
1549 cd 9d 17			call break_point_state  
154c				endm  
# End of macro CALLMONITOR
154c					endif 
154c f1					pop af 
154d			 
154d 32 7d fb				ld (store_page+STORE_0_FILERUN),a 
1550					 
1550					; save bank id 
1550			 
1550 3a 3f fb				ld a,(spi_device) 
1553 32 7c fb				ld (store_page+STORE_0_BANKRUN),a 
1556			 
1556					; enable auto run of store file 
1556			 
1556 3e 01				ld a, 1 
1558 32 7a fb				ld (store_page+STORE_0_AUTOFILE),a 
155b			 
155b					; save buffer 
155b			 
155b 21 00 00				ld hl, 0 
155e 11 59 fb				ld de, store_page 
1561					if DEBUG_FORTH_WORDS 
1561						DMARK "ALw" 
1561 f5				push af  
1562 3a 76 15			ld a, (.dmark)  
1565 32 6e fe			ld (debug_mark),a  
1568 3a 77 15			ld a, (.dmark+1)  
156b 32 6f fe			ld (debug_mark+1),a  
156e 3a 78 15			ld a, (.dmark+2)  
1571 32 70 fe			ld (debug_mark+2),a  
1574 18 03			jr .pastdmark  
1576 ..			.dmark: db "ALw"  
1579 f1			.pastdmark: pop af  
157a			endm  
# End of macro DMARK
157a						CALLMONITOR 
157a cd 9d 17			call break_point_state  
157d				endm  
# End of macro CALLMONITOR
157d					endif 
157d cd 39 04			call storage_write_block	 ; save update 
1580			  
1580			 
1580			 
1580			 
1580 21 d4 f2				ld hl, scratch 
1583 cd 9b 15				call config_fdir 
1586			 
1586				else 
1586			 
1586				ld hl, prom_notav 
1586				ld de, prom_empty 
1586				call info_panel 
1586			 
1586				endif 
1586 c9				ret 
1587			 
1587			 
1587			 
1587			; Select storage bank 
1587			 
1587			.selbank: 
1587			 
1587				if STORAGE_SE 
1587				else 
1587			 
1587				ld hl, prom_notav 
1587				ld de, prom_empty 
1587				call info_panel 
1587				endif 
1587				 
1587 c9				ret 
1588			 
1588			if STORAGE_SE 
1588			 
1588			.config_ldir:   
1588				; Load storage bank labels into menu array 
1588			 
1588				 
1588			 
1588			 
1588 c9				ret 
1589			 
1589			 
1589			endif 
1589			 
1589			 
1589			; Save user words to storage 
1589			 
1589			.savetostore: 
1589			 
1589				if STORAGE_SE 
1589			 
1589 cd ae 15				call config_dir 
158c 21 d4 f2			        ld hl, scratch 
158f 3e 00				ld a, 0 
1591 cd f3 0b				call menu 
1594					 
1594 21 d4 f2				ld hl, scratch 
1597 cd 9b 15				call config_fdir 
159a			 
159a				else 
159a			 
159a				ld hl, prom_notav 
159a				ld de, prom_empty 
159a				call info_panel 
159a			 
159a				endif 
159a			 
159a c9				ret 
159b			 
159b			 
159b			 
159b			if STORAGE_SE 
159b			 
159b			config_fdir: 
159b				; using the scratch dir go through and release the memory allocated for each string 
159b				 
159b 21 d4 f2			ld hl, scratch 
159e 5e			.cfdir:	ld e,(hl) 
159f 23				inc hl 
15a0 56				ld d,(hl) 
15a1 23				inc hl 
15a2			 
15a2 eb				ex de, hl 
15a3 cd 1f 0e			call ishlzero 
15a6 c8				ret z     ; return on null pointer 
15a7 cd 87 13			call free 
15aa eb				ex de, hl 
15ab 18 f1			jr .cfdir 
15ad			 
15ad			 
15ad c9				ret 
15ae			 
15ae			 
15ae			config_dir: 
15ae			 
15ae				; for the config menus that need to build a directory of storage call this routine 
15ae				; it will construct a menu in scratch to pass to menu 
15ae			 
15ae				; open storage device 
15ae			 
15ae				; execute DIR to build a list of files and their ids into scratch in menu format 
15ae				; once the menu has finished then will need to call config_fdir to release the strings 
15ae				 
15ae				; c = number items 
15ae			 
15ae				 
15ae cd 85 04			call storage_get_block_0 
15b1			 
15b1 21 59 fb			ld hl, store_page     ; get current id count 
15b4 46				ld b, (hl) 
15b5 0e 00			ld c, 0    ; count of files   
15b7			 
15b7			 
15b7 21 d4 f2			ld hl, scratch 
15ba 22 55 fb			ld (store_tmp2), hl    ; location to poke strings 
15bd			 
15bd				; check for empty drive 
15bd			 
15bd 3e 00			ld a, 0 
15bf b8				cp b 
15c0 ca 5a 16			jp z, .dirdone 
15c3			 
15c3				 
15c3					if DEBUG_FORTH_WORDS 
15c3						DMARK "Cdc" 
15c3 f5				push af  
15c4 3a d8 15			ld a, (.dmark)  
15c7 32 6e fe			ld (debug_mark),a  
15ca 3a d9 15			ld a, (.dmark+1)  
15cd 32 6f fe			ld (debug_mark+1),a  
15d0 3a da 15			ld a, (.dmark+2)  
15d3 32 70 fe			ld (debug_mark+2),a  
15d6 18 03			jr .pastdmark  
15d8 ..			.dmark: db "Cdc"  
15db f1			.pastdmark: pop af  
15dc			endm  
# End of macro DMARK
15dc						CALLMONITOR 
15dc cd 9d 17			call break_point_state  
15df				endm  
# End of macro CALLMONITOR
15df					endif 
15df			 
15df			 
15df			.diritem:	 
15df c5				push bc 
15e0				; for each of the current ids do a search for them and if found push to stack 
15e0			 
15e0 21 40 00				ld hl, STORE_BLOCK_PHY 
15e3 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
15e5 58					ld e,b 
15e6			 
15e6 cd 07 07				call storage_findnextid 
15e9			 
15e9			 
15e9					; if found hl will be non zero 
15e9			 
15e9 cd 1f 0e				call ishlzero 
15ec 28 69				jr z, .dirnotfound 
15ee			 
15ee					; increase count 
15ee			 
15ee c1					pop bc	 
15ef 0c					inc c 
15f0 c5					push bc 
15f1					 
15f1			 
15f1					; get file header and push the file name 
15f1			 
15f1 11 59 fb				ld de, store_page 
15f4 cd d4 03				call storage_read_block 
15f7			 
15f7					; push file id to stack 
15f7				 
15f7 3a 59 fb				ld a, (store_page) 
15fa 26 00				ld h, 0 
15fc 6f					ld l, a 
15fd			 
15fd					;call forth_push_numhl 
15fd					; TODO store id 
15fd			 
15fd e5					push hl 
15fe			 
15fe					; push extent count to stack  
15fe				 
15fe 21 5c fb				ld hl, store_page+3 
1601			 
1601					; get file name length 
1601			 
1601 cd 54 12				call strlenz   
1604			 
1604 23					inc hl   ; cover zero term 
1605 23					inc hl  ; stick the id at the end of the area 
1606			 
1606 e5					push hl 
1607 c1					pop bc    ; move length to bc 
1608			 
1608 cd bd 12				call malloc 
160b			 
160b					; TODO save malloc area to scratch 
160b			 
160b eb					ex de, hl 
160c 2a 55 fb				ld hl, (store_tmp2) 
160f 73					ld (hl), e 
1610 23					inc hl 
1611 72					ld (hl), d 
1612 23					inc hl 
1613 22 55 fb				ld (store_tmp2), hl 
1616			 
1616					 
1616			 
1616					;pop hl   ; get source 
1616			;		ex de, hl    ; swap aronund	 
1616			 
1616 21 5c fb				ld hl, store_page+3 
1619					if DEBUG_FORTH_WORDS 
1619						DMARK "CFd" 
1619 f5				push af  
161a 3a 2e 16			ld a, (.dmark)  
161d 32 6e fe			ld (debug_mark),a  
1620 3a 2f 16			ld a, (.dmark+1)  
1623 32 6f fe			ld (debug_mark+1),a  
1626 3a 30 16			ld a, (.dmark+2)  
1629 32 70 fe			ld (debug_mark+2),a  
162c 18 03			jr .pastdmark  
162e ..			.dmark: db "CFd"  
1631 f1			.pastdmark: pop af  
1632			endm  
# End of macro DMARK
1632						CALLMONITOR 
1632 cd 9d 17			call break_point_state  
1635				endm  
# End of macro CALLMONITOR
1635					endif 
1635 ed b0				ldir 
1637			 
1637					; de is past string, move back one and store id 
1637					 
1637 1b					dec de 
1638			 
1638					; store file id 
1638			 
1638 e1					pop hl 
1639 eb					ex de,hl 
163a 73					ld (hl), e 
163b			 
163b					if DEBUG_FORTH_WORDS 
163b						DMARK "Cdi" 
163b f5				push af  
163c 3a 50 16			ld a, (.dmark)  
163f 32 6e fe			ld (debug_mark),a  
1642 3a 51 16			ld a, (.dmark+1)  
1645 32 6f fe			ld (debug_mark+1),a  
1648 3a 52 16			ld a, (.dmark+2)  
164b 32 70 fe			ld (debug_mark+2),a  
164e 18 03			jr .pastdmark  
1650 ..			.dmark: db "Cdi"  
1653 f1			.pastdmark: pop af  
1654			endm  
# End of macro DMARK
1654						CALLMONITOR 
1654 cd 9d 17			call break_point_state  
1657				endm  
# End of macro CALLMONITOR
1657					endif 
1657					 
1657			.dirnotfound: 
1657 c1					pop bc     
1658 10 85				djnz .diritem 
165a				 
165a			.dirdone:	 
165a			 
165a 3e 00				ld a, 0 
165c 2a 55 fb				ld hl, (store_tmp2) 
165f 77					ld (hl), a 
1660 23					inc hl 
1661 77					ld (hl), a 
1662 23					inc hl 
1663					; push a count of the dir items found 
1663			 
1663			;		ld h, 0 
1663			;		ld l, c 
1663			 
1663 c9				ret 
1664			 
1664			endif 
1664			 
1664			 
1664			; Settings 
1664			; Run  
1664			 
1664			 
1664			 
1664			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1664			;;hd_menu2:   db "        2: Editor",0   
1664			;hd_menu2:   db "        2: Editor       6: Menu",0   
1664			;hd_menu3:   db "        3: Storage",0 
1664			;hd_menu4:   db "0=quit  4: Debug",0 
1664			;hd_don:     db "ON",0 
1664			;hd_doff:     db "OFF",0 
1664			; 
1664			; 
1664			; 
1664			;hardware_diags_old:       
1664			; 
1664			;.diagmenu: 
1664			;	call clear_display 
1664			;	ld a, display_row_1 
1664			;	ld de, hd_menu1 
1664			;	call str_at_display 
1664			; 
1664			;	ld a, display_row_2 
1664			;	ld de, hd_menu2 
1664			;	call str_at_display 
1664			; 
1664			;	ld a, display_row_3 
1664			;	ld de, hd_menu3 
1664			;	call str_at_display 
1664			; 
1664			;	ld a,  display_row_4 
1664			;	ld de, hd_menu4 
1664			;	call str_at_display 
1664			; 
1664			;	; display debug state 
1664			; 
1664			;	ld de, hd_don 
1664			;	ld a, (os_view_disable) 
1664			;	cp 0 
1664			;	jr z, .distog 
1664			;	ld de, hd_doff 
1664			;.distog: ld a, display_row_4+17 
1664			;	call str_at_display 
1664			; 
1664			;	call update_display 
1664			; 
1664			;	call cin_wait 
1664			; 
1664			; 
1664			; 
1664			;	cp '4' 
1664			;	jr nz, .diagn1 
1664			; 
1664			;	; debug toggle 
1664			; 
1664			;	ld a, (os_view_disable) 
1664			;	ld b, '*' 
1664			;	cp 0 
1664			;	jr z, .debtog 
1664			;	ld b, 0 
1664			;.debtog:	 
1664			;	ld a,b 
1664			;	ld (os_view_disable),a 
1664			; 
1664			;.diagn1: cp '0' 
1664			;	 ret z 
1664			; 
1664			;;	cp '1' 
1664			;;       jp z, matrix	 
1664			;;   TODO keyboard matrix test 
1664			; 
1664			;	cp '2' 
1664			;	jp z, .diagedit 
1664			; 
1664			;;	cp '6' 
1664			;;	jp z, .menutest 
1664			;;if ENABLE_BASIC 
1664			;;	cp '6' 
1664			;;	jp z, basic 
1664			;;endif 
1664			 ; 
1664			;	jp .diagmenu 
1664			; 
1664			; 
1664			;	ret 
1664			 
1664			 
1664			.debug_tog: 
1664 21 ab 16			ld hl, .menudebug 
1667				 
1667 3a c5 f2			ld a, (os_view_disable) 
166a fe 2a			cp '*' 
166c 20 04			jr nz,.tdon  
166e 3e 01			ld a, 1 
1670 18 02			jr .tog1 
1672 3e 00		.tdon: ld a, 0 
1674			 
1674			.tog1: 
1674 cd f3 0b			call menu 
1677 fe 00			cp 0 
1679 c8				ret z 
167a fe 01			cp 1    ; disable debug 
167c 28 04			jr z, .dtog0 
167e 3e 2a			ld a, '*' 
1680 18 02			jr .dtogset 
1682 3e 00		.dtog0: ld a, 0 
1684 32 c5 f2		.dtogset:  ld (os_view_disable), a 
1687 c3 64 16			jp .debug_tog 
168a			 
168a			 
168a			hardware_diags:       
168a			 
168a			.diagm: 
168a 21 9d 16			ld hl, .menuitems 
168d 3e 00			ld a, 0 
168f cd f3 0b			call menu 
1692			 
1692 fe 00		         cp 0 
1694 c8				 ret z 
1695			 
1695 fe 02			cp 2 
1697 ca f6 16			jp z, .diagedit 
169a			 
169a			;	cp '6' 
169a			;	jp z, .menutest 
169a			;if ENABLE_BASIC 
169a			;	cp '6' 
169a			;	jp z, basic 
169a			;endif 
169a			  
169a c3 8a 16			jp .diagm 
169d			 
169d				 
169d b1 16		.menuitems:   	dw .m1 
169f bc 16				dw .m2 
16a1 c3 16				dw .m3 
16a3 cb 16				dw .m5 
16a5 d1 16				dw .m5a 
16a7 da 16				dw .m5b 
16a9 00 00				dw 0 
16ab			 
16ab			.menudebug: 
16ab e3 16				dw .m6 
16ad ec 16				dw .m7 
16af 00 00				dw 0 
16b1			 
16b1 .. 00		.m1:   db "Key Matrix",0 
16bc .. 00		.m2:   db "Editor",0 
16c3 .. 00		.m3:   db "Storage",0 
16cb .. 00		.m5:   db "Sound",0 
16d1 .. 00		.m5a:  db "RAM Test",0 
16da .. 00		.m5b:  db "LCD Test",0 
16e3			 
16e3 .. 00		.m6:   db "Debug ON",0 
16ec .. 00		.m7:   db "Debug OFF",0 
16f6			 
16f6			; debug editor 
16f6			 
16f6			.diagedit: 
16f6			 
16f6 21 d4 f2			ld hl, scratch 
16f9			;	ld bc, 250 
16f9			;	ldir 
16f9				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16f9 3e 00			ld a, 0 
16fb 77				ld (hl), a 
16fc 23				inc hl 
16fd 77				ld (hl), a 
16fe 23				inc hl 
16ff 77				ld (hl), a 
1700			 
1700 cd c2 0b		        call clear_display 
1703 cd e5 0b			call update_display 
1706				;ld a, 1 
1706				;ld (hardware_diag), a 
1706			.diloop: 
1706 3e 00			ld a, display_row_1 
1708 0e 00			ld c, 0 
170a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
170c 1e 28			ld e, 40 
170e			 
170e 21 d4 f2			ld hl, scratch	 
1711 cd 23 0e			call input_str 
1714			 
1714 3e 28			ld a, display_row_2 
1716 11 d4 f2			ld de, scratch 
1719 cd d5 0b			call str_at_display 
171c cd e5 0b			call update_display 
171f			 
171f c3 06 17			jp .diloop 
1722			 
1722			 
1722			; pass word in hl 
1722			; a has display location 
1722			display_word_at: 
1722 f5				push af 
1723 e5				push hl 
1724 7c				ld a,h 
1725 21 d9 f5			ld hl, os_word_scratch 
1728 cd f7 10			call hexout 
172b e1				pop hl 
172c 7d				ld a,l 
172d 21 db f5			ld hl, os_word_scratch+2 
1730 cd f7 10			call hexout 
1733 21 dd f5			ld hl, os_word_scratch+4 
1736 3e 00			ld a,0 
1738 77				ld (hl),a 
1739 11 d9 f5			ld de,os_word_scratch 
173c f1				pop af 
173d cd d5 0b				call str_at_display 
1740 c9				ret 
1741			 
1741			display_ptr_state: 
1741			 
1741				; to restore afterwards 
1741			 
1741 d5				push de 
1742 c5				push bc 
1743 e5				push hl 
1744 f5				push af 
1745			 
1745				; for use in here 
1745			 
1745			;	push bc 
1745			;	push de 
1745			;	push hl 
1745			;	push af 
1745			 
1745 cd c2 0b			call clear_display 
1748			 
1748 11 1b 19			ld de, .ptrstate 
174b 3e 00			ld a, display_row_1 
174d cd d5 0b			call str_at_display 
1750			 
1750				; display debug step 
1750			 
1750			 
1750 11 6e fe			ld de, debug_mark 
1753 3e 26			ld a, display_row_1+display_cols-2 
1755 cd d5 0b			call str_at_display 
1758			 
1758				; display a 
1758 11 25 19			ld de, .ptrcliptr 
175b 3e 28			ld a, display_row_2 
175d cd d5 0b			call str_at_display 
1760			 
1760 f1				pop af 
1761 2a 1f fb			ld hl,(cli_ptr) 
1764 3e 30			ld a, display_row_2+8 
1766 cd 22 17			call display_word_at 
1769			 
1769			 
1769				; display hl 
1769			 
1769			 
1769 11 2d 19			ld de, .ptrclioptr 
176c 3e 32			ld a, display_row_2+10 
176e cd d5 0b			call str_at_display 
1771			; 
1771			;	pop hl 
1771 3e 35			ld a, display_row_2+13 
1773 2a 1d fb			ld hl,(cli_origptr) 
1776 cd 22 17			call display_word_at 
1779			; 
1779			;	 
1779			;	; display de 
1779			 
1779			;	ld de, .regstatede 
1779			;	ld a, display_row_3 
1779			;	call str_at_display 
1779			 
1779			;	pop de 
1779			;	ld h,d 
1779			;	ld l, e 
1779			;	ld a, display_row_3+3 
1779			;	call display_word_at 
1779			 
1779			 
1779				; display bc 
1779			 
1779			;	ld de, .regstatebc 
1779			;	ld a, display_row_3+10 
1779			;	call str_at_display 
1779			 
1779			;	pop bc 
1779			;	ld h,b 
1779			;	ld l, c 
1779			;	ld a, display_row_3+13 
1779			;	call display_word_at 
1779			 
1779			 
1779				; display dsp 
1779			 
1779			;	ld de, .regstatedsp 
1779			;	ld a, display_row_4 
1779			;	call str_at_display 
1779			 
1779				 
1779			;	ld hl,(cli_data_sp) 
1779			;	ld a, display_row_4+4 
1779			;	call display_word_at 
1779			 
1779				; display rsp 
1779			 
1779 11 5c 19			ld de, .regstatersp 
177c 3e 82			ld a, display_row_4+10 
177e cd d5 0b			call str_at_display 
1781			 
1781				 
1781 2a 05 fb			ld hl,(cli_ret_sp) 
1784 3e 86			ld a, display_row_4+14 
1786 cd 22 17			call display_word_at 
1789			 
1789 cd e5 0b			call update_display 
178c			 
178c cd 3f 0b			call delay1s 
178f cd 3f 0b			call delay1s 
1792 cd 3f 0b			call delay1s 
1795			 
1795			 
1795 cd 83 1d			call next_page_prompt 
1798			 
1798				; restore  
1798			 
1798 f1				pop af 
1799 e1				pop hl 
179a c1				pop bc 
179b d1				pop de 
179c c9				ret 
179d			 
179d			break_point_state: 
179d f5				push af 
179e			 
179e				; see if disabled 
179e			 
179e 3a c5 f2			ld a, (os_view_disable) 
17a1 fe 2a			cp '*' 
17a3 20 02			jr nz, .bpsgo 
17a5 f1				pop af 
17a6 c9				ret 
17a7			 
17a7			.bpsgo: 
17a7 f1				pop af 
17a8 f5				push af 
17a9 22 c1 f2			ld (os_view_hl), hl 
17ac ed 53 bf f2		ld (os_view_de), de 
17b0 ed 43 bd f2		ld (os_view_bc), bc 
17b4 e5				push hl 
17b5 6f				ld l, a 
17b6 26 00			ld h, 0 
17b8 22 c3 f2			ld (os_view_af),hl 
17bb			 
17bb 21 b4 fd				ld hl, display_fb0 
17be 22 cf fb				ld (display_fb_active), hl 
17c1 e1				pop hl	 
17c2			 
17c2 3e 31			ld a, '1' 
17c4 fe 2a		.bps1:  cp '*' 
17c6 20 03			jr nz, .bps1b 
17c8 32 c5 f2			ld (os_view_disable),a 
17cb fe 31		.bps1b:  cp '1' 
17cd 20 14			jr nz, .bps2 
17cf			 
17cf				; display reg 
17cf			 
17cf				 
17cf			 
17cf 3a c3 f2			ld a, (os_view_af) 
17d2 2a c1 f2			ld hl, (os_view_hl) 
17d5 ed 5b bf f2		ld de, (os_view_de) 
17d9 ed 4b bd f2		ld bc, (os_view_bc) 
17dd cd 77 18			call display_reg_state 
17e0 c3 63 18			jp .bpschk 
17e3			 
17e3 fe 32		.bps2:  cp '2' 
17e5 20 08			jr nz, .bps3 
17e7				 
17e7				; display hl 
17e7 2a c1 f2			ld hl, (os_view_hl) 
17ea cd 61 19			call display_dump_at_hl 
17ed			 
17ed 18 74			jr .bpschk 
17ef			 
17ef fe 33		.bps3:  cp '3' 
17f1 20 08			jr nz, .bps4 
17f3			 
17f3			        ; display de 
17f3 2a bf f2			ld hl, (os_view_de) 
17f6 cd 61 19			call display_dump_at_hl 
17f9			 
17f9 18 68			jr .bpschk 
17fb fe 34		.bps4:  cp '4' 
17fd 20 08			jr nz, .bps5 
17ff			 
17ff			        ; display bc 
17ff 2a bd f2			ld hl, (os_view_bc) 
1802 cd 61 19			call display_dump_at_hl 
1805			 
1805 18 5c			jr .bpschk 
1807 fe 35		.bps5:  cp '5' 
1809 20 08		        jr nz, .bps7 
180b			 
180b				; display cur ptr 
180b 2a 1f fb			ld hl, (cli_ptr) 
180e cd 61 19			call display_dump_at_hl 
1811			 
1811 18 50			jr .bpschk 
1813 fe 36		.bps7:  cp '6' 
1815 20 08			jr nz, .bps8b 
1817				 
1817				; display cur orig ptr 
1817 2a 1d fb			ld hl, (cli_origptr) 
181a cd 61 19			call display_dump_at_hl 
181d 18 44			jr .bpschk 
181f fe 37		.bps8b:  cp '7' 
1821 20 08			jr nz, .bps9 
1823				 
1823				; display dsp 
1823 2a 01 fb			ld hl, (cli_data_sp) 
1826 cd 61 19			call display_dump_at_hl 
1829			 
1829 18 38			jr .bpschk 
182b fe 39		.bps9:  cp '9' 
182d 20 05			jr nz, .bps8c 
182f				 
182f				; display SP 
182f			;	ld hl, sp 
182f cd 61 19			call display_dump_at_hl 
1832			 
1832 18 2f			jr .bpschk 
1834 fe 38		.bps8c:  cp '8' 
1836 20 08			jr nz, .bps8d 
1838				 
1838				; display rsp 
1838 2a 05 fb			ld hl, (cli_ret_sp) 
183b cd 61 19			call display_dump_at_hl 
183e			 
183e 18 23			jr .bpschk 
1840 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1842 20 05			jr nz, .bps8 
1844 cd 79 1b			call monitor 
1847			 
1847 18 1a			jr .bpschk 
1849 fe 30		.bps8:  cp '0' 
184b 20 16			jr nz, .bpschk 
184d			 
184d 21 13 fd				ld hl, display_fb1 
1850 22 cf fb				ld (display_fb_active), hl 
1853 cd e5 0b				call update_display 
1856			 
1856				;ld a, (os_view_af) 
1856 2a c1 f2			ld hl, (os_view_hl) 
1859 ed 5b bf f2		ld de, (os_view_de) 
185d ed 4b bd f2		ld bc, (os_view_bc) 
1861 f1				pop af 
1862 c9				ret 
1863			 
1863			.bpschk:   
1863 cd 3f 0b			call delay1s 
1866 3e 9f		ld a,display_row_4 + display_cols - 1 
1868 11 81 1d		        ld de, endprg 
186b cd d5 0b			call str_at_display 
186e cd e5 0b			call update_display 
1871 cd 43 6b			call cin_wait 
1874			 
1874 c3 c4 17			jp .bps1 
1877			 
1877			 
1877			display_reg_state: 
1877			 
1877				; to restore afterwards 
1877			 
1877 d5				push de 
1878 c5				push bc 
1879 e5				push hl 
187a f5				push af 
187b			 
187b				; for use in here 
187b			 
187b c5				push bc 
187c d5				push de 
187d e5				push hl 
187e f5				push af 
187f			 
187f cd c2 0b			call clear_display 
1882			 
1882 11 37 19			ld de, .regstate 
1885 3e 00			ld a, display_row_1 
1887 cd d5 0b			call str_at_display 
188a			 
188a				; display debug step 
188a			 
188a			 
188a 11 6e fe			ld de, debug_mark 
188d 3e 25			ld a, display_row_1+display_cols-3 
188f cd d5 0b			call str_at_display 
1892			 
1892				; display a 
1892 11 53 19			ld de, .regstatea 
1895 3e 28			ld a, display_row_2 
1897 cd d5 0b			call str_at_display 
189a			 
189a e1				pop hl 
189b			;	ld h,0 
189b			;	ld l, a 
189b 3e 2b			ld a, display_row_2+3 
189d cd 22 17			call display_word_at 
18a0			 
18a0			 
18a0				; display hl 
18a0			 
18a0			 
18a0 11 47 19			ld de, .regstatehl 
18a3 3e 32			ld a, display_row_2+10 
18a5 cd d5 0b			call str_at_display 
18a8			 
18a8 e1				pop hl 
18a9 3e 35			ld a, display_row_2+13 
18ab cd 22 17			call display_word_at 
18ae			 
18ae				 
18ae				; display de 
18ae			 
18ae 11 4b 19			ld de, .regstatede 
18b1 3e 50			ld a, display_row_3 
18b3 cd d5 0b			call str_at_display 
18b6			 
18b6 e1				pop hl 
18b7			;	ld h,d 
18b7			;	ld l, e 
18b7 3e 53			ld a, display_row_3+3 
18b9 cd 22 17			call display_word_at 
18bc			 
18bc			 
18bc				; display bc 
18bc			 
18bc 11 4f 19			ld de, .regstatebc 
18bf 3e 5a			ld a, display_row_3+10 
18c1 cd d5 0b			call str_at_display 
18c4			 
18c4 e1				pop hl 
18c5			;	ld h,b 
18c5			;	ld l, c 
18c5 3e 5d			ld a, display_row_3+13 
18c7 cd 22 17			call display_word_at 
18ca			 
18ca			 
18ca				; display dsp 
18ca			 
18ca 11 57 19			ld de, .regstatedsp 
18cd 3e 78			ld a, display_row_4 
18cf cd d5 0b			call str_at_display 
18d2			 
18d2				 
18d2 2a 01 fb			ld hl,(cli_data_sp) 
18d5 3e 7c			ld a, display_row_4+4 
18d7 cd 22 17			call display_word_at 
18da			 
18da				; display rsp 
18da			 
18da 11 5c 19			ld de, .regstatersp 
18dd 3e 82			ld a, display_row_4+10 
18df cd d5 0b			call str_at_display 
18e2			 
18e2				 
18e2 2a 05 fb			ld hl,(cli_ret_sp) 
18e5 3e 86			ld a, display_row_4+14 
18e7 cd 22 17			call display_word_at 
18ea			 
18ea cd e5 0b			call update_display 
18ed			 
18ed			;	call delay1s 
18ed			;	call delay1s 
18ed			;	call delay1s 
18ed			 
18ed			 
18ed			;	call next_page_prompt 
18ed			 
18ed				; restore  
18ed			 
18ed f1				pop af 
18ee e1				pop hl 
18ef c1				pop bc 
18f0 d1				pop de 
18f1 c9				ret 
18f2			 
18f2 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1906 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
191b .. 00		.ptrstate:	db "Ptr State",0 
1925 .. 00		.ptrcliptr:     db "cli_ptr",0 
192d .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1937 .. 00		.regstate:	db "Reg State (1/0)",0 
1947 .. 00		.regstatehl:	db "HL:",0 
194b .. 00		.regstatede:	db "DE:",0 
194f .. 00		.regstatebc:	db "BC:",0 
1953 .. 00		.regstatea:	db "A :",0 
1957 .. 00		.regstatedsp:	db "DSP:",0 
195c .. 00		.regstatersp:	db "RSP:",0 
1961			 
1961			display_dump_at_hl: 
1961 e5				push hl 
1962 d5				push de 
1963 c5				push bc 
1964 f5				push af 
1965			 
1965 22 f7 f5			ld (os_cur_ptr),hl	 
1968 cd c2 0b			call clear_display 
196b cd 8b 1c			call dumpcont 
196e			;	call delay1s 
196e			;	call next_page_prompt 
196e			 
196e			 
196e f1				pop af 
196f c1				pop bc 
1970 d1				pop de 
1971 e1				pop hl 
1972 c9				ret 
1973			 
1973			;if ENABLE_BASIC 
1973			;	include "nascombasic.asm" 
1973			;	basic: 
1973			;	include "forth/FORTH.ASM" 
1973			;endif 
1973			 
1973			; eof 
1973			 
1973			 
# End of file firmware_diags.asm
1973			  
1973			include "firmware_prompts.asm"  
1973			; Prompts  
1973			 
1973			; boot messages 
1973			 
1973 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1988 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1998			 
1998			 
1998			; config menus 
1998			 
1998 .. 00		prom_c3: db "Add Dictionary To File",0 
19af .. 00		prom_c2: db "Select Autoload File",0 
19c4 .. 00		prom_c2a: db "Disable Autoload File", 0 
19da .. 00		prom_c2b: db "Select Storage Bank",0 
19ee .. 00		prom_c4: db "Settings",0 
19f7 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1a12 .. 00		prom_m4b:   db "Monitor",0 
1a1a .. 00		prom_c1: db "Hardware Diags",0 
1a29			 
1a29			 
1a29 .. 00		prom_notav:    db "Feature not available",0 
1a3f .. 00		prom_empty:    db "",0 
1a40			 
1a40			; eof 
1a40			 
# End of file firmware_prompts.asm
1a40			  
1a40			  
1a40			; eof  
1a40			  
# End of file firmware.asm
1a40			 
1a40			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1a40			;if BASE_KEV  
1a40			;baseram: equ 08000h 
1a40			;endif 
1a40			 
1a40			;if BASE_SC114 
1a40			;baseram:     equ    endofcode 
1a40			;endif 
1a40			 
1a40			 
1a40			; start system 
1a40			 
1a40			coldstart: 
1a40				; set sp 
1a40				; di/ei 
1a40			 
1a40 f3				di 
1a41 31 fd ff			ld sp, tos 
1a44			;	ei 
1a44			 
1a44			 
1a44				; disable breakpoint by default 
1a44			 
1a44 3e 2a			ld a,'*' 
1a46 32 c5 f2			ld (os_view_disable),a 
1a49			 
1a49				; init hardware 
1a49			 
1a49				; init keyboard and screen hardware 
1a49			 
1a49 cd 1c 00			call hardware_init 
1a4c			 
1a4c			 
1a4c cd 3f 0b			call delay1s 
1a4f 3e 58			ld a, display_row_3+8 
1a51 11 03 00			ld de, .buildtime 
1a54 cd d5 0b			call str_at_display 
1a57 cd e5 0b			call update_display 
1a5a			 
1a5a cd 3f 0b			call delay1s 
1a5d			 
1a5d				; detect if any keys are held down to enable breakpoints at start up 
1a5d			 
1a5d cd 54 6b			call cin  
1a60 fe 00			cp 0 
1a62 28 03			jr z, .nokeys 
1a64			 
1a64				;call hardware_diags 
1a64 cd 80 14			call config 
1a67			 
1a67			;	ld de, .bpen 
1a67			;	ld a, display_row_4 
1a67			;	call str_at_display 
1a67			;	call update_display 
1a67			; 
1a67			;	ld a,0 
1a67			;	ld (os_view_disable),a 
1a67			; 
1a67			;.bpwait: 
1a67			;	call cin 
1a67			;	cp 0 
1a67			;	jr z, .bpwait 
1a67			;	jr .nokeys 
1a67			; 
1a67			; 
1a67			;.bpen:  db "Break points enabled!",0 
1a67			 
1a67			 
1a67			 
1a67			 
1a67			 
1a67			 
1a67			.nokeys: 
1a67			 
1a67			 
1a67				 
1a67			 
1a67			;jp  testkey 
1a67			 
1a67			;call storage_get_block_0 
1a67			; 
1a67			;ld hl, 0 
1a67			;ld de, store_page 
1a67			;call storage_read_block 
1a67			 
1a67				 
1a67			;ld hl, 10 
1a67			;ld de, store_page 
1a67			;call storage_read_block 
1a67			 
1a67			 
1a67			 
1a67			 
1a67			 
1a67			;stop:	nop 
1a67			;	jp stop 
1a67			 
1a67			 
1a67			 
1a67			main: 
1a67 cd c2 0b			call clear_display 
1a6a cd e5 0b			call update_display 
1a6d			 
1a6d			 
1a6d			 
1a6d			;	call testlcd 
1a6d			 
1a6d			 
1a6d			 
1a6d cd 49 21			call forth_init 
1a70			 
1a70			 
1a70			warmstart: 
1a70 cd 1f 21			call forth_warmstart 
1a73			 
1a73				; run startup word load 
1a73			        ; TODO prevent this running at warmstart after crash  
1a73			 
1a73				if STARTUP_ENABLE 
1a73					if STORAGE_SE 
1a73 cd e2 66					call forth_autoload 
1a76					endif 
1a76 cd f1 63				call forth_startup 
1a79			 
1a79			 
1a79				endif 
1a79			 
1a79				; show free memory after boot 
1a79 11 13 1b			ld de, freeram 
1a7c 3e 00			ld a, display_row_1 
1a7e cd d5 0b			call str_at_display 
1a81			 
1a81			; Or use heap_size word???? 
1a81 21 ba f2			ld hl, heap_end 
1a84 11 0e 80			ld de, heap_start 
1a87 ed 52			sbc hl, de 
1a89 e5				push hl 
1a8a 7c				ld a,h	         	 
1a8b 21 d9 f5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a8e cd f7 10			call hexout 
1a91 e1			   	pop hl 
1a92			 
1a92 7d				ld a,l 
1a93 21 db f5			ld hl, os_word_scratch+2 
1a96 cd f7 10			call hexout 
1a99 21 dd f5			ld hl, os_word_scratch+4 
1a9c 3e 00			ld a, 0 
1a9e 77				ld (hl),a 
1a9f 11 d9 f5			ld de, os_word_scratch 
1aa2 3e 0d			ld a, display_row_1 + 13 
1aa4 cd d5 0b			call str_at_display 
1aa7 cd e5 0b			call update_display 
1aaa			 
1aaa			 
1aaa				;call demo 
1aaa			 
1aaa			 
1aaa				; init scratch input area for cli commands 
1aaa			 
1aaa 21 fb f5			ld hl, os_cli_cmd 
1aad 3e 00			ld a,0 
1aaf 77				ld (hl),a 
1ab0 23				inc hl 
1ab1 77				ld (hl),a 
1ab2			 
1ab2 3e 00			ld a,0 
1ab4 32 fa f6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ab7			 
1ab7 32 f7 f5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1aba 32 f8 f5			ld (os_cur_ptr+1),a	 
1abd			 
1abd 32 d9 f5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1ac0 32 da f5			ld (os_word_scratch+1),a	 
1ac3				 
1ac3			 
1ac3				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ac3 21 fb f5			ld hl, os_cli_cmd 
1ac6			 
1ac6 3e 00			ld a, 0		 ; init cli input 
1ac8 77				ld (hl), a 
1ac9 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1acb			cli: 
1acb				; show cli prompt 
1acb				;push af 
1acb				;ld a, 0 
1acb				;ld de, prompt 
1acb				;call str_at_display 
1acb			 
1acb				;call update_display 
1acb				;pop af 
1acb				;inc a 
1acb				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1acb 0e 00			ld c, 0 
1acd 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1acf 1e 28			ld e, 40 
1ad1			 
1ad1 21 fb f5			ld hl, os_cli_cmd 
1ad4			 
1ad4				STACKFRAME OFF $fefe $9f9f 
1ad4				if DEBUG_STACK_IMB 
1ad4					if OFF 
1ad4						exx 
1ad4						ld de, $fefe 
1ad4						ld a, d 
1ad4						ld hl, curframe 
1ad4						call hexout 
1ad4						ld a, e 
1ad4						ld hl, curframe+2 
1ad4						call hexout 
1ad4						ld hl, $fefe 
1ad4						push hl 
1ad4						ld hl, $9f9f 
1ad4						push hl 
1ad4						exx 
1ad4					endif 
1ad4				endif 
1ad4			endm 
# End of macro STACKFRAME
1ad4			 
1ad4 cd 23 0e			call input_str 
1ad7			 
1ad7				STACKFRAMECHK OFF $fefe $9f9f 
1ad7				if DEBUG_STACK_IMB 
1ad7					if OFF 
1ad7						exx 
1ad7						ld hl, $9f9f 
1ad7						pop de   ; $9f9f 
1ad7						call cmp16 
1ad7						jr nz, .spnosame 
1ad7						ld hl, $fefe 
1ad7						pop de   ; $fefe 
1ad7						call cmp16 
1ad7						jr z, .spfrsame 
1ad7						.spnosame: call showsperror 
1ad7						.spfrsame: nop 
1ad7						exx 
1ad7					endif 
1ad7				endif 
1ad7			endm 
# End of macro STACKFRAMECHK
1ad7			 
1ad7				; copy input to last command 
1ad7			 
1ad7 21 fb f5			ld hl, os_cli_cmd 
1ada 11 fa f6			ld de, os_last_cmd 
1add 01 ff 00			ld bc, 255 
1ae0 ed b0			ldir 
1ae2			 
1ae2				; wipe current buffer 
1ae2			 
1ae2			;	ld a, 0 
1ae2			;	ld hl, os_cli_cmd 
1ae2			;	ld de, os_cli_cmd+1 
1ae2			;	ld bc, 254 
1ae2			;	ldir 
1ae2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ae2			;	call strcpy 
1ae2			;	ld a, 0 
1ae2			;	ld (hl), a 
1ae2			;	inc hl 
1ae2			;	ld (hl), a 
1ae2			;	inc hl 
1ae2			;	ld (hl), a 
1ae2			 
1ae2				; switch frame buffer to program  
1ae2			 
1ae2 21 13 fd				ld hl, display_fb1 
1ae5 22 cf fb				ld (display_fb_active), hl 
1ae8			 
1ae8			;	nop 
1ae8				STACKFRAME ON $fbfe $8f9f 
1ae8				if DEBUG_STACK_IMB 
1ae8					if ON 
1ae8						exx 
1ae8						ld de, $fbfe 
1ae8						ld a, d 
1ae8						ld hl, curframe 
1ae8						call hexout 
1ae8						ld a, e 
1ae8						ld hl, curframe+2 
1ae8						call hexout 
1ae8						ld hl, $fbfe 
1ae8						push hl 
1ae8						ld hl, $8f9f 
1ae8						push hl 
1ae8						exx 
1ae8					endif 
1ae8				endif 
1ae8			endm 
# End of macro STACKFRAME
1ae8				; first time into the parser so pass over the current scratch pad 
1ae8 21 fb f5			ld hl,os_cli_cmd 
1aeb				; tokenise the entered statement(s) in HL 
1aeb cd c2 21			call forthparse 
1aee			        ; exec forth statements in top of return stack 
1aee cd 02 22			call forthexec 
1af1				;call forthexec_cleanup 
1af1			;	call parsenext 
1af1			 
1af1				STACKFRAMECHK ON $fbfe $8f9f 
1af1				if DEBUG_STACK_IMB 
1af1					if ON 
1af1						exx 
1af1						ld hl, $8f9f 
1af1						pop de   ; $8f9f 
1af1						call cmp16 
1af1						jr nz, .spnosame 
1af1						ld hl, $fbfe 
1af1						pop de   ; $fbfe 
1af1						call cmp16 
1af1						jr z, .spfrsame 
1af1						.spnosame: call showsperror 
1af1						.spfrsame: nop 
1af1						exx 
1af1					endif 
1af1				endif 
1af1			endm 
# End of macro STACKFRAMECHK
1af1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1af1			 
1af1 3e 78			ld a, display_row_4 
1af3 11 25 1b			ld de, endprog 
1af6			 
1af6 cd e5 0b			call update_display		 
1af9			 
1af9 cd 83 1d			call next_page_prompt 
1afc			 
1afc				; switch frame buffer to cli 
1afc			 
1afc 21 b4 fd				ld hl, display_fb0 
1aff 22 cf fb				ld (display_fb_active), hl 
1b02			 
1b02			 
1b02 cd c2 0b		        call clear_display 
1b05 cd e5 0b			call update_display		 
1b08			 
1b08 21 fb f5			ld hl, os_cli_cmd 
1b0b			 
1b0b 3e 00			ld a, 0		 ; init cli input 
1b0d 77				ld (hl), a 
1b0e			 
1b0e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1b0e			 
1b0e				; now on last line 
1b0e			 
1b0e				; TODO scroll screen up 
1b0e			 
1b0e				; TODO instead just clear screen and place at top of screen 
1b0e			 
1b0e			;	ld a, 0 
1b0e			;	ld (f_cursor_ptr),a 
1b0e			 
1b0e				;call clear_display 
1b0e				;call update_display 
1b0e			 
1b0e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b0e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b10 c3 cb 1a			jp cli 
1b13			 
1b13 .. 00		freeram: db "Free bytes: $",0 
1b21 ..			asc: db "1A2F" 
1b25 .. 00		endprog: db "End prog...",0 
1b31			 
1b31			testenter2:   
1b31 21 06 f3			ld hl,scratch+50 
1b34 22 f7 f5			ld (os_cur_ptr),hl 
1b37 c3 cb 1a			jp cli 
1b3a			 
1b3a			testenter:  
1b3a			 
1b3a 21 21 1b			ld hl,asc 
1b3d			;	ld a,(hl) 
1b3d			;	call nibble2val 
1b3d cd 4d 11			call get_byte 
1b40			 
1b40			 
1b40			;	ld a,(hl) 
1b40			;	call atohex 
1b40			 
1b40			;	call fourehexhl 
1b40 32 06 f3			ld (scratch+50),a 
1b43			 
1b43			 
1b43			 
1b43 21 23 1b			ld hl,asc+2 
1b46			;	ld a, (hl) 
1b46			;	call nibble2val 
1b46 cd 4d 11			call get_byte 
1b49			 
1b49			;	call fourehexhl 
1b49 32 08 f3			ld (scratch+52),a 
1b4c				 
1b4c 21 06 f3			ld hl,scratch+50 
1b4f 22 f7 f5			ld (os_cur_ptr),hl 
1b52 c3 cb 1a			jp cli 
1b55			 
1b55			enter:	 
1b55 3a d8 f2			ld a,(scratch+4) 
1b58 fe 00			cp 0 
1b5a 28 0c			jr z, .entercont 
1b5c				; no, not a null term line so has an address to work out.... 
1b5c			 
1b5c 21 d6 f2			ld hl,scratch+2 
1b5f cd ad 11			call get_word_hl 
1b62			 
1b62 22 f7 f5			ld (os_cur_ptr),hl	 
1b65 c3 cb 1a			jp cli 
1b68			 
1b68			 
1b68			.entercont:  
1b68			 
1b68 21 d6 f2			ld hl, scratch+2 
1b6b cd 4d 11			call get_byte 
1b6e			 
1b6e 2a f7 f5		   	ld hl,(os_cur_ptr) 
1b71 77					ld (hl),a 
1b72 23					inc hl 
1b73 22 f7 f5				ld (os_cur_ptr),hl 
1b76				 
1b76			; get byte  
1b76			 
1b76			 
1b76 c3 cb 1a			jp cli 
1b79			 
1b79			 
1b79			; basic monitor support 
1b79			 
1b79			monitor: 
1b79				;  
1b79 cd c2 0b			call clear_display 
1b7c 3e 00			ld a, 0 
1b7e 11 c6 1b			ld de, .monprompt 
1b81 cd d5 0b			call str_at_display 
1b84 cd e5 0b			call update_display 
1b87			 
1b87				; get a monitor command 
1b87			 
1b87 0e 00			ld c, 0     ; entry at top left 
1b89 16 64			ld d, 100   ; max buffer size 
1b8b 1e 0f			ld e, 15    ; input scroll area 
1b8d 3e 00			ld a, 0     ; init string 
1b8f 21 d2 f4			ld hl, os_input 
1b92 77				ld (hl), a 
1b93 23				inc hl 
1b94 77				ld (hl), a 
1b95 21 d2 f4			ld hl, os_input 
1b98 3e 01			ld a, 1     ; init string 
1b9a cd 23 0e			call input_str 
1b9d			 
1b9d cd c2 0b		        call clear_display 
1ba0 cd e5 0b			call update_display		 
1ba3			 
1ba3 3a d2 f4			ld a, (os_input) 
1ba6 cd 4b 12			call toUpper 
1ba9 fe 48		        cp 'H' 
1bab 28 6f		        jr z, .monhelp 
1bad fe 44			cp 'D'		; dump 
1baf ca 3d 1c			jp z, .mondump	 
1bb2 fe 43			cp 'C'		; dump 
1bb4 ca 57 1c			jp z, .moncdump	 
1bb7 fe 4d			cp 'M'		; dump 
1bb9 ca c8 1b			jp z, .moneditstart 
1bbc fe 55			cp 'U'		; dump 
1bbe 28 14			jr z, .monedit	 
1bc0 fe 51			cp 'Q'		; dump 
1bc2 c8				ret z	 
1bc3			 
1bc3			 
1bc3				; TODO "S" to access symbol by name and not need the address 
1bc3				; TODO "F" to find a string in memory 
1bc3			 
1bc3 c3 79 1b			jp monitor 
1bc6			 
1bc6 .. 00		.monprompt: db ">", 0 
1bc8			 
1bc8			.moneditstart: 
1bc8				; get starting address 
1bc8			 
1bc8 21 d4 f4			ld hl,os_input+2 
1bcb cd ad 11			call get_word_hl 
1bce			 
1bce 22 f7 f5			ld (os_cur_ptr),hl	 
1bd1			 
1bd1 c3 79 1b			jp monitor 
1bd4			 
1bd4			.monedit: 
1bd4				; get byte to load 
1bd4			 
1bd4 21 d4 f4			ld hl,os_input+2 
1bd7 cd 4d 11			call get_byte 
1bda			 
1bda				; get address to update 
1bda 2a f7 f5			ld hl, (os_cur_ptr) 
1bdd			 
1bdd				; update byte 
1bdd			 
1bdd 77				ld (hl), a 
1bde			 
1bde				; move to next address and save it 
1bde			 
1bde 23				inc hl 
1bdf 22 f7 f5			ld (os_cur_ptr),hl	 
1be2			 
1be2 c3 79 1b			jp monitor 
1be5			 
1be5			 
1be5 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1bf9 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1c15 .. 00		.monhelptext3:  db "Q-Quit",0 
1c1c			        
1c1c			.monhelp: 
1c1c 3e 00			ld a, display_row_1 
1c1e 11 e5 1b		        ld de, .monhelptext1 
1c21			 
1c21 cd d5 0b			call str_at_display 
1c24 3e 28			ld a, display_row_2 
1c26 11 f9 1b		        ld de, .monhelptext2 
1c29					 
1c29 cd d5 0b			call str_at_display 
1c2c 3e 50			ld a, display_row_3 
1c2e 11 15 1c		        ld de, .monhelptext3 
1c31					 
1c31 cd d5 0b			call str_at_display 
1c34 cd e5 0b			call update_display		 
1c37			 
1c37 cd 83 1d			call next_page_prompt 
1c3a c3 79 1b			jp monitor 
1c3d			 
1c3d			.mondump:    
1c3d 21 d4 f4			ld hl,os_input+2 
1c40 cd ad 11			call get_word_hl 
1c43			 
1c43 22 f7 f5			ld (os_cur_ptr),hl	 
1c46 cd 8b 1c			call dumpcont 
1c49 3e 78			ld a, display_row_4 
1c4b 11 25 1b			ld de, endprog 
1c4e			 
1c4e cd e5 0b			call update_display		 
1c51			 
1c51 cd 83 1d			call next_page_prompt 
1c54 c3 79 1b			jp monitor 
1c57			.moncdump: 
1c57 cd 8b 1c			call dumpcont 
1c5a 3e 78			ld a, display_row_4 
1c5c 11 25 1b			ld de, endprog 
1c5f			 
1c5f cd e5 0b			call update_display		 
1c62			 
1c62 cd 83 1d			call next_page_prompt 
1c65 c3 79 1b			jp monitor 
1c68			 
1c68			 
1c68			; TODO symbol access  
1c68			 
1c68			.symbols:     ;; A list of symbols that can be called up  
1c68 b4 fd			dw display_fb0 
1c6a .. 00			db "fb0",0  
1c6e 59 fb		     	dw store_page 
1c70 .. 00			db "store_page",0 
1c7b			 
1c7b			 
1c7b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1c7b			 
1c7b 3a d5 f2			ld a,(scratch+1) 
1c7e fe 00			cp 0 
1c80 28 09			jr z, dumpcont 
1c82			 
1c82				; no, not a null term line so has an address to work out.... 
1c82			 
1c82 21 d6 f2			ld hl,scratch+2 
1c85 cd ad 11			call get_word_hl 
1c88			 
1c88 22 f7 f5			ld (os_cur_ptr),hl	 
1c8b			 
1c8b			 
1c8b			 
1c8b			dumpcont: 
1c8b			 
1c8b				; dump bytes at ptr 
1c8b			 
1c8b			 
1c8b 3e 00			ld a, display_row_1 
1c8d 2a cf fb			ld hl, (display_fb_active) 
1c90 cd f6 0d			call addatohl 
1c93 cd bb 1c			call .dumpbyterow 
1c96			 
1c96 3e 28			ld a, display_row_2 
1c98 2a cf fb			ld hl, (display_fb_active) 
1c9b cd f6 0d			call addatohl 
1c9e cd bb 1c			call .dumpbyterow 
1ca1			 
1ca1			 
1ca1 3e 50			ld a, display_row_3 
1ca3 2a cf fb			ld hl, (display_fb_active) 
1ca6 cd f6 0d			call addatohl 
1ca9 cd bb 1c			call .dumpbyterow 
1cac			 
1cac 3e 78			ld a, display_row_4 
1cae 2a cf fb			ld hl, (display_fb_active) 
1cb1 cd f6 0d			call addatohl 
1cb4 cd bb 1c			call .dumpbyterow 
1cb7			 
1cb7 cd e5 0b			call update_display 
1cba			;		jp cli 
1cba c9				ret 
1cbb			 
1cbb			.dumpbyterow: 
1cbb			 
1cbb				;push af 
1cbb			 
1cbb e5				push hl 
1cbc			 
1cbc				; calc where to poke the ascii 
1cbc			if display_cols == 20 
1cbc				ld a, 16 
1cbc			else 
1cbc 3e 1f			ld a, 31 
1cbe			endif 
1cbe			 
1cbe cd f6 0d			call addatohl 
1cc1 22 d9 f5			ld (os_word_scratch),hl  		; save pos for later 
1cc4			 
1cc4			 
1cc4			; display decoding address 
1cc4 2a f7 f5		   	ld hl,(os_cur_ptr) 
1cc7			 
1cc7 7c				ld a,h 
1cc8 e1				pop hl 
1cc9 e5				push hl 
1cca			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1cca cd f7 10			call hexout 
1ccd 2a f7 f5		   	ld hl,(os_cur_ptr) 
1cd0			 
1cd0 7d				ld a,l 
1cd1 e1				pop hl 
1cd2 23				inc hl 
1cd3 23				inc hl 
1cd4 e5				push hl 
1cd5			;	ld hl, os_word_scratch+2 
1cd5 cd f7 10			call hexout 
1cd8 e1				pop hl 
1cd9 23				inc hl 
1cda 23				inc hl 
1cdb				;ld hl, os_word_scratch+4 
1cdb 3e 3a			ld a, ':' 
1cdd 77				ld (hl),a 
1cde 23				inc hl 
1cdf				;ld a, 0 
1cdf				;ld (hl),a 
1cdf				;ld de, os_word_scratch 
1cdf				;pop af 
1cdf				;push af 
1cdf			;		ld a, display_row_2 
1cdf			;		call str_at_display 
1cdf			;		call update_display 
1cdf			 
1cdf			 
1cdf			;pop af 
1cdf			;	add 5 
1cdf			 
1cdf			if display_cols == 20 
1cdf				ld b, 4 
1cdf			else 
1cdf 06 08			ld b, 8 
1ce1			endif	 
1ce1			 
1ce1			.dumpbyte: 
1ce1 c5				push bc 
1ce2 e5				push hl 
1ce3			 
1ce3			 
1ce3 2a f7 f5		   	ld hl,(os_cur_ptr) 
1ce6 7e					ld a,(hl) 
1ce7			 
1ce7					; poke the ascii to display 
1ce7 2a d9 f5				ld hl,(os_word_scratch) 
1cea 77					ld (hl),a 
1ceb 23					inc hl 
1cec 22 d9 f5				ld (os_word_scratch),hl 
1cef			 
1cef					 
1cef			 
1cef			 
1cef e1					pop hl 
1cf0 e5					push hl 
1cf1			 
1cf1 cd f7 10				call hexout 
1cf4			 
1cf4					 
1cf4 2a f7 f5		   	ld hl,(os_cur_ptr) 
1cf7 23				inc hl 
1cf8 22 f7 f5		   	ld (os_cur_ptr),hl 
1cfb			 
1cfb e1					pop hl 
1cfc 23					inc hl 
1cfd 23					inc hl 
1cfe 23					inc hl 
1cff			 
1cff			 
1cff			 
1cff					;ld a,0 
1cff					;ld (os_word_scratch+2),a 
1cff					;pop af 
1cff					;push af 
1cff			 
1cff					;ld de, os_word_scratch 
1cff					;call str_at_display 
1cff			;		call update_display 
1cff			;		pop af 
1cff c1					pop bc 
1d00 c6 03				add 3 
1d02 10 dd			djnz .dumpbyte 
1d04			 
1d04				 
1d04			 
1d04 c9				ret 
1d05			 
1d05			jump:	 
1d05			 
1d05 21 d6 f2			ld hl,scratch+2 
1d08 cd ad 11			call get_word_hl 
1d0b				;ld hl,(scratch+2) 
1d0b				;call fourehexhl 
1d0b			 
1d0b 22 f7 f5			ld (os_cur_ptr),hl	 
1d0e			 
1d0e e9				jp (hl) 
1d0f			 
1d0f			 
1d0f			 
1d0f			; TODO implement a basic monitor mode to start with 
1d0f			 
1d0f			 
1d0f			 
1d0f			 
1d0f			 
1d0f			 
1d0f			 
1d0f			 
1d0f			 
1d0f			; testing and demo code during development 
1d0f			 
1d0f			 
1d0f .. 00		str1: db "Enter some text...",0 
1d22 .. 00		clear: db "                    ",0 
1d37			 
1d37			demo: 
1d37			 
1d37			 
1d37			 
1d37			;	call update_display 
1d37			 
1d37				; init scratch input area for testing 
1d37 21 d4 f2			ld hl, scratch	 
1d3a 3e 00			ld a,0 
1d3c 77				ld (hl),a 
1d3d			 
1d3d			 
1d3d 3e 28		            LD   A, display_row_2 
1d3f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d3f 11 0f 1d		            LD   DE, str1 
1d42 cd d5 0b			call str_at_display 
1d45			 
1d45			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d45			cloop:	 
1d45 3e 50		            LD   A, display_row_3 
1d47			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d47 11 22 1d		            LD   DE, clear 
1d4a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1d4a cd d5 0b				call str_at_display 
1d4d 3e 78			ld a, display_row_4 
1d4f 11 7f 1d			ld de, prompt 
1d52			 
1d52 cd d5 0b				call str_at_display 
1d55 cd e5 0b			call update_display 
1d58			 
1d58 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d5a 16 0a			ld d, 10 
1d5c 21 d4 f2			ld hl, scratch	 
1d5f cd 23 0e			call input_str 
1d62			 
1d62			;	call clear_display 
1d62			;'	call update_display 
1d62			 
1d62 3e 00		            LD   A, display_row_1 
1d64			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d64 11 22 1d		            LD   DE, clear 
1d67 cd d5 0b				call str_at_display 
1d6a			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d6a 3e 00		            LD   A, display_row_1 
1d6c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d6c 11 d4 f2		            LD   DE, scratch 
1d6f			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d6f cd d5 0b				call str_at_display 
1d72 cd e5 0b			call update_display 
1d75			 
1d75 3e 00				ld a,0 
1d77 21 d4 f2			ld hl, scratch 
1d7a 77				ld (hl),a 
1d7b			 
1d7b 00				nop 
1d7c c3 45 1d			jp cloop 
1d7f			 
1d7f			 
1d7f			 
1d7f			; OS Prompt 
1d7f			 
1d7f .. 00		prompt: db ">",0 
1d81 .. 00		endprg: db "?",0 
1d83			 
1d83			 
1d83			; handy next page prompt 
1d83			next_page_prompt: 
1d83 e5				push hl 
1d84 d5				push de 
1d85 f5				push af 
1d86 c5				push bc 
1d87			 
1d87 3e 9f			ld a,display_row_4 + display_cols - 1 
1d89 11 81 1d		        ld de, endprg 
1d8c cd d5 0b			call str_at_display 
1d8f cd e5 0b			call update_display 
1d92 cd 43 6b			call cin_wait 
1d95 c1				pop bc 
1d96 f1				pop af 
1d97 d1				pop de 
1d98 e1				pop hl 
1d99			 
1d99			 
1d99 c9				ret 
1d9a			 
1d9a			 
1d9a			; forth parser 
1d9a			 
1d9a			; My forth kernel 
1d9a			include "forth_kernel.asm" 
1d9a			; 
1d9a			; kernel to the forth OS 
1d9a			 
1d9a			DS_TYPE_STR: equ 1     ; string type 
1d9a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1d9a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1d9a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1d9a			 
1d9a			FORTH_PARSEV1: equ 0 
1d9a			FORTH_PARSEV2: equ 0 
1d9a			FORTH_PARSEV3: equ 0 
1d9a			FORTH_PARSEV4: equ 0 
1d9a			FORTH_PARSEV5: equ 1 
1d9a			 
1d9a			;if FORTH_PARSEV5 
1d9a			;	FORTH_END_BUFFER: equ 0 
1d9a			;else 
1d9a			FORTH_END_BUFFER: equ 127 
1d9a			;endif 
1d9a			 
1d9a			FORTH_TRUE: equ 1 
1d9a			FORTH_FALSE: equ 0 
1d9a			 
1d9a			if FORTH_PARSEV4 
1d9a			include "forth_stackops.asm" 
1d9a			endif 
1d9a			 
1d9a			if FORTH_PARSEV5 
1d9a			include "forth_stackopsv5.asm" 
1d9a			 
1d9a			; Stack operations for v5 parser on wards 
1d9a			; * DATA stack 
1d9a			; * LOOP stack 
1d9a			; * RETURN stack 
1d9a			 
1d9a			 
1d9a			 
1d9a			FORTH_CHK_DSP_UNDER: macro 
1d9a				push hl 
1d9a				push de 
1d9a				ld hl,(cli_data_sp) 
1d9a				ld de, cli_data_stack 
1d9a				call cmp16 
1d9a				jp c, fault_dsp_under 
1d9a				pop de 
1d9a				pop hl 
1d9a				endm 
1d9a			 
1d9a			 
1d9a			FORTH_CHK_RSP_UNDER: macro 
1d9a				push hl 
1d9a				push de 
1d9a				ld hl,(cli_ret_sp) 
1d9a				ld de, cli_ret_stack 
1d9a				call cmp16 
1d9a				jp c, fault_rsp_under 
1d9a				pop de 
1d9a				pop hl 
1d9a				endm 
1d9a			 
1d9a			FORTH_CHK_LOOP_UNDER: macro 
1d9a				push hl 
1d9a				push de 
1d9a				ld hl,(cli_loop_sp) 
1d9a				ld de, cli_loop_stack 
1d9a				call cmp16 
1d9a				jp c, fault_loop_under 
1d9a				pop de 
1d9a				pop hl 
1d9a				endm 
1d9a			 
1d9a			FORTH_ERR_TOS_NOTSTR: macro 
1d9a				; TOSO might need more for checks when used 
1d9a				push af 
1d9a				ld a,(hl) 
1d9a				cp DS_TYPE_STR 
1d9a				jp nz, type_faultn   
1d9a				pop af 
1d9a				endm 
1d9a			 
1d9a			FORTH_ERR_TOS_NOTNUM: macro 
1d9a				push af 
1d9a				ld a,(hl) 
1d9a				cp DS_TYPE_INUM 
1d9a				jp nz, type_faultn   
1d9a				pop af 
1d9a				endm 
1d9a			 
1d9a			 
1d9a			; increase data stack pointer and save hl to it 
1d9a				 
1d9a			FORTH_DSP_NEXT: macro 
1d9a				call macro_forth_dsp_next 
1d9a				endm 
1d9a			 
1d9a			 
1d9a			macro_forth_dsp_next: 
1d9a				if DEBUG_FORTH_STACK_GUARD 
1d9a cd bb 64				call check_stacks 
1d9d				endif 
1d9d e5				push hl 
1d9e d5				push de 
1d9f eb				ex de,hl 
1da0 2a 01 fb			ld hl,(cli_data_sp) 
1da3 23				inc hl 
1da4 23				inc hl 
1da5			 
1da5			; PARSEV5 
1da5 23				inc hl 
1da6 22 01 fb			ld (cli_data_sp),hl 
1da9 73				ld (hl), e 
1daa 23				inc hl 
1dab 72				ld (hl), d 
1dac d1				pop de 
1dad e1				pop hl 
1dae				if DEBUG_FORTH_STACK_GUARD 
1dae cd bb 64				call check_stacks 
1db1				endif 
1db1 c9				ret 
1db2			 
1db2			 
1db2			; increase ret stack pointer and save hl to it 
1db2				 
1db2			FORTH_RSP_NEXT: macro 
1db2				call macro_forth_rsp_next 
1db2				endm 
1db2			 
1db2			macro_forth_rsp_next: 
1db2				if DEBUG_FORTH_STACK_GUARD 
1db2 cd bb 64				call check_stacks 
1db5				endif 
1db5 e5				push hl 
1db6 d5				push de 
1db7 eb				ex de,hl 
1db8 2a 05 fb			ld hl,(cli_ret_sp) 
1dbb 23				inc hl 
1dbc 23				inc hl 
1dbd 22 05 fb			ld (cli_ret_sp),hl 
1dc0 73				ld (hl), e 
1dc1 23				inc hl 
1dc2 72				ld (hl), d 
1dc3 d1				pop de 
1dc4 e1				pop hl 
1dc5				if DEBUG_FORTH_STACK_GUARD 
1dc5 cd bb 64				call check_stacks 
1dc8				endif 
1dc8 c9				ret 
1dc9			 
1dc9			; get current ret stack pointer and save to hl  
1dc9				 
1dc9			FORTH_RSP_TOS: macro 
1dc9				call macro_forth_rsp_tos 
1dc9				endm 
1dc9			 
1dc9			macro_forth_rsp_tos: 
1dc9				;push de 
1dc9 2a 05 fb			ld hl,(cli_ret_sp) 
1dcc cd 04 1e			call loadhlptrtohl 
1dcf				;ld e, (hl) 
1dcf				;inc hl 
1dcf				;ld d, (hl) 
1dcf				;ex de, hl 
1dcf					if DEBUG_FORTH_WORDS 
1dcf			;			DMARK "RST" 
1dcf						CALLMONITOR 
1dcf cd 9d 17			call break_point_state  
1dd2				endm  
# End of macro CALLMONITOR
1dd2					endif 
1dd2				;pop de 
1dd2 c9				ret 
1dd3			 
1dd3			; pop ret stack pointer 
1dd3				 
1dd3			FORTH_RSP_POP: macro 
1dd3				call macro_forth_rsp_pop 
1dd3				endm 
1dd3			 
1dd3			 
1dd3			macro_forth_rsp_pop: 
1dd3				if DEBUG_FORTH_STACK_GUARD 
1dd3			;		DMARK "RPP" 
1dd3 cd bb 64				call check_stacks 
1dd6					FORTH_CHK_RSP_UNDER 
1dd6 e5				push hl 
1dd7 d5				push de 
1dd8 2a 05 fb			ld hl,(cli_ret_sp) 
1ddb 11 bf fa			ld de, cli_ret_stack 
1dde cd 14 0e			call cmp16 
1de1 da cf 65			jp c, fault_rsp_under 
1de4 d1				pop de 
1de5 e1				pop hl 
1de6				endm 
# End of macro FORTH_CHK_RSP_UNDER
1de6				endif 
1de6 e5				push hl 
1de7 2a 05 fb			ld hl,(cli_ret_sp) 
1dea			 
1dea			 
1dea				if FORTH_ENABLE_FREE 
1dea			 
1dea					; get pointer 
1dea			 
1dea					push de 
1dea					push hl 
1dea			 
1dea					ld e, (hl) 
1dea					inc hl 
1dea					ld d, (hl) 
1dea			 
1dea					ex de, hl 
1dea					call free 
1dea			 
1dea					pop hl 
1dea					pop de 
1dea			 
1dea			 
1dea				endif 
1dea			 
1dea			 
1dea 2b				dec hl 
1deb 2b				dec hl 
1dec 22 05 fb			ld (cli_ret_sp), hl 
1def				; do stack underflow checks 
1def e1				pop hl 
1df0				if DEBUG_FORTH_STACK_GUARD 
1df0 cd bb 64				call check_stacks 
1df3					FORTH_CHK_RSP_UNDER 
1df3 e5				push hl 
1df4 d5				push de 
1df5 2a 05 fb			ld hl,(cli_ret_sp) 
1df8 11 bf fa			ld de, cli_ret_stack 
1dfb cd 14 0e			call cmp16 
1dfe da cf 65			jp c, fault_rsp_under 
1e01 d1				pop de 
1e02 e1				pop hl 
1e03				endm 
# End of macro FORTH_CHK_RSP_UNDER
1e03				endif 
1e03 c9				ret 
1e04			 
1e04			 
1e04			 
1e04			; routine to load word pointed to by hl into hl 
1e04			 
1e04			loadhlptrtohl: 
1e04			 
1e04 d5				push de 
1e05 5e				ld e, (hl) 
1e06 23				inc hl 
1e07 56				ld d, (hl) 
1e08 eb				ex de, hl 
1e09 d1				pop de 
1e0a			 
1e0a c9				ret 
1e0b			 
1e0b			 
1e0b			 
1e0b			 
1e0b			 
1e0b			; push a number held in HL onto the data stack 
1e0b			; entry point for pushing a value when already in hl used in function above 
1e0b			 
1e0b			forth_push_numhl: 
1e0b			 
1e0b e5				push hl    ; save value to push 
1e0c			 
1e0c			if DEBUG_FORTH_PUSH 
1e0c				; see if disabled 
1e0c			 
1e0c			 
1e0c f5				push af 
1e0d 3a c5 f2			ld a, (os_view_disable) 
1e10 fe 2a			cp '*' 
1e12 28 34			jr z, .pskip2 
1e14 e5				push hl 
1e15 e5			push hl 
1e16 cd c2 0b			call clear_display 
1e19 e1			pop hl 
1e1a 7c				ld a,h 
1e1b 21 d9 f5			ld hl, os_word_scratch 
1e1e cd f7 10			call hexout 
1e21 e1				pop hl 
1e22 7d				ld a,l 
1e23 21 db f5			ld hl, os_word_scratch+2 
1e26 cd f7 10			call hexout 
1e29			 
1e29 21 dd f5			ld hl, os_word_scratch+4 
1e2c 3e 00			ld a,0 
1e2e 77				ld (hl),a 
1e2f 11 d9 f5			ld de,os_word_scratch 
1e32 3e 28				ld a, display_row_2 
1e34 cd d5 0b				call str_at_display 
1e37 11 9a 53			ld de, .push_num 
1e3a 3e 00			ld a, display_row_1 
1e3c			 
1e3c cd d5 0b				call str_at_display 
1e3f			 
1e3f			 
1e3f cd e5 0b			call update_display 
1e42 cd 3f 0b			call delay1s 
1e45 cd 3f 0b			call delay1s 
1e48			.pskip2:  
1e48			 
1e48 f1				pop af 
1e49			endif	 
1e49			 
1e49			 
1e49				FORTH_DSP_NEXT 
1e49 cd 9a 1d			call macro_forth_dsp_next 
1e4c				endm 
# End of macro FORTH_DSP_NEXT
1e4c			 
1e4c 2a 01 fb			ld hl, (cli_data_sp) 
1e4f			 
1e4f				; save item type 
1e4f 3e 02			ld a,  DS_TYPE_INUM 
1e51 77				ld (hl), a 
1e52 23				inc hl 
1e53			 
1e53				; get word off stack 
1e53 d1				pop de 
1e54 7b				ld a,e 
1e55 77				ld (hl), a 
1e56 23				inc hl 
1e57 7a				ld a,d 
1e58 77				ld (hl), a 
1e59			 
1e59			if DEBUG_FORTH_PUSH 
1e59 2b				dec hl 
1e5a 2b				dec hl 
1e5b 2b				dec hl 
1e5c						DMARK "PH5" 
1e5c f5				push af  
1e5d 3a 71 1e			ld a, (.dmark)  
1e60 32 6e fe			ld (debug_mark),a  
1e63 3a 72 1e			ld a, (.dmark+1)  
1e66 32 6f fe			ld (debug_mark+1),a  
1e69 3a 73 1e			ld a, (.dmark+2)  
1e6c 32 70 fe			ld (debug_mark+2),a  
1e6f 18 03			jr .pastdmark  
1e71 ..			.dmark: db "PH5"  
1e74 f1			.pastdmark: pop af  
1e75			endm  
# End of macro DMARK
1e75				CALLMONITOR 
1e75 cd 9d 17			call break_point_state  
1e78				endm  
# End of macro CALLMONITOR
1e78			endif	 
1e78			 
1e78 c9				ret 
1e79			 
1e79			 
1e79			; Push a string to stack pointed to by hl 
1e79			 
1e79			forth_push_str: 
1e79			 
1e79			if DEBUG_FORTH_PUSH 
1e79						DMARK "PSQ" 
1e79 f5				push af  
1e7a 3a 8e 1e			ld a, (.dmark)  
1e7d 32 6e fe			ld (debug_mark),a  
1e80 3a 8f 1e			ld a, (.dmark+1)  
1e83 32 6f fe			ld (debug_mark+1),a  
1e86 3a 90 1e			ld a, (.dmark+2)  
1e89 32 70 fe			ld (debug_mark+2),a  
1e8c 18 03			jr .pastdmark  
1e8e ..			.dmark: db "PSQ"  
1e91 f1			.pastdmark: pop af  
1e92			endm  
# End of macro DMARK
1e92				CALLMONITOR 
1e92 cd 9d 17			call break_point_state  
1e95				endm  
# End of macro CALLMONITOR
1e95			endif	 
1e95			    
1e95 e5				push hl 
1e96 e5				push hl 
1e97			 
1e97			;	ld a, 0   ; find end of string 
1e97 cd 54 12			call strlenz 
1e9a			if DEBUG_FORTH_PUSH 
1e9a						DMARK "PQ2" 
1e9a f5				push af  
1e9b 3a af 1e			ld a, (.dmark)  
1e9e 32 6e fe			ld (debug_mark),a  
1ea1 3a b0 1e			ld a, (.dmark+1)  
1ea4 32 6f fe			ld (debug_mark+1),a  
1ea7 3a b1 1e			ld a, (.dmark+2)  
1eaa 32 70 fe			ld (debug_mark+2),a  
1ead 18 03			jr .pastdmark  
1eaf ..			.dmark: db "PQ2"  
1eb2 f1			.pastdmark: pop af  
1eb3			endm  
# End of macro DMARK
1eb3				CALLMONITOR 
1eb3 cd 9d 17			call break_point_state  
1eb6				endm  
# End of macro CALLMONITOR
1eb6			endif	 
1eb6 eb				ex de, hl 
1eb7 e1				pop hl   ; get ptr to start of string 
1eb8			if DEBUG_FORTH_PUSH 
1eb8						DMARK "PQ3" 
1eb8 f5				push af  
1eb9 3a cd 1e			ld a, (.dmark)  
1ebc 32 6e fe			ld (debug_mark),a  
1ebf 3a ce 1e			ld a, (.dmark+1)  
1ec2 32 6f fe			ld (debug_mark+1),a  
1ec5 3a cf 1e			ld a, (.dmark+2)  
1ec8 32 70 fe			ld (debug_mark+2),a  
1ecb 18 03			jr .pastdmark  
1ecd ..			.dmark: db "PQ3"  
1ed0 f1			.pastdmark: pop af  
1ed1			endm  
# End of macro DMARK
1ed1				CALLMONITOR 
1ed1 cd 9d 17			call break_point_state  
1ed4				endm  
# End of macro CALLMONITOR
1ed4			endif	 
1ed4 19				add hl,de 
1ed5			if DEBUG_FORTH_PUSH 
1ed5						DMARK "PQE" 
1ed5 f5				push af  
1ed6 3a ea 1e			ld a, (.dmark)  
1ed9 32 6e fe			ld (debug_mark),a  
1edc 3a eb 1e			ld a, (.dmark+1)  
1edf 32 6f fe			ld (debug_mark+1),a  
1ee2 3a ec 1e			ld a, (.dmark+2)  
1ee5 32 70 fe			ld (debug_mark+2),a  
1ee8 18 03			jr .pastdmark  
1eea ..			.dmark: db "PQE"  
1eed f1			.pastdmark: pop af  
1eee			endm  
# End of macro DMARK
1eee				CALLMONITOR 
1eee cd 9d 17			call break_point_state  
1ef1				endm  
# End of macro CALLMONITOR
1ef1			endif	 
1ef1			 
1ef1 2b				dec hl    ; see if there is an optional trailing double quote 
1ef2 7e				ld a,(hl) 
1ef3 fe 22			cp '"' 
1ef5 20 03			jr nz, .strnoq 
1ef7 3e 00			ld a, 0      ; get rid of double quote 
1ef9 77				ld (hl), a 
1efa 23			.strnoq: inc hl 
1efb			 
1efb 3e 00			ld a, 0 
1efd 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1efe			 
1efe 13				inc de ; add one for the type string 
1eff 13				inc de ; add one for null term??? 
1f00			 
1f00				; tos is get string pointer again 
1f00				; de contains space to allocate 
1f00				 
1f00 d5				push de 
1f01			 
1f01 eb				ex de, hl 
1f02			 
1f02				;push af 
1f02			 
1f02			if DEBUG_FORTH_PUSH 
1f02						DMARK "PHm" 
1f02 f5				push af  
1f03 3a 17 1f			ld a, (.dmark)  
1f06 32 6e fe			ld (debug_mark),a  
1f09 3a 18 1f			ld a, (.dmark+1)  
1f0c 32 6f fe			ld (debug_mark+1),a  
1f0f 3a 19 1f			ld a, (.dmark+2)  
1f12 32 70 fe			ld (debug_mark+2),a  
1f15 18 03			jr .pastdmark  
1f17 ..			.dmark: db "PHm"  
1f1a f1			.pastdmark: pop af  
1f1b			endm  
# End of macro DMARK
1f1b				CALLMONITOR 
1f1b cd 9d 17			call break_point_state  
1f1e				endm  
# End of macro CALLMONITOR
1f1e			endif	 
1f1e cd bd 12			call malloc	; on ret hl now contains allocated memory 
1f21				if DEBUG_FORTH_MALLOC_GUARD 
1f21 cc f2 53				call z,malloc_error 
1f24				endif 
1f24			 
1f24				 
1f24 c1				pop bc    ; get length 
1f25 d1				pop de   ;  get string start    
1f26			 
1f26				; hl has destination from malloc 
1f26			 
1f26 eb				ex de, hl    ; prep for ldir 
1f27			 
1f27 d5				push de   ; save malloc area for DSP later 
1f28				;push hl   ; save malloc area for DSP later 
1f28			 
1f28			if DEBUG_FORTH_PUSH 
1f28						DMARK "PHc" 
1f28 f5				push af  
1f29 3a 3d 1f			ld a, (.dmark)  
1f2c 32 6e fe			ld (debug_mark),a  
1f2f 3a 3e 1f			ld a, (.dmark+1)  
1f32 32 6f fe			ld (debug_mark+1),a  
1f35 3a 3f 1f			ld a, (.dmark+2)  
1f38 32 70 fe			ld (debug_mark+2),a  
1f3b 18 03			jr .pastdmark  
1f3d ..			.dmark: db "PHc"  
1f40 f1			.pastdmark: pop af  
1f41			endm  
# End of macro DMARK
1f41				CALLMONITOR 
1f41 cd 9d 17			call break_point_state  
1f44				endm  
# End of macro CALLMONITOR
1f44			endif	 
1f44			 
1f44			 
1f44 ed b0			ldir 
1f46			 
1f46			 
1f46				; push malloc to data stack     macro?????  
1f46			 
1f46				FORTH_DSP_NEXT 
1f46 cd 9a 1d			call macro_forth_dsp_next 
1f49				endm 
# End of macro FORTH_DSP_NEXT
1f49			 
1f49				; save value and type 
1f49			 
1f49 2a 01 fb			ld hl, (cli_data_sp) 
1f4c			 
1f4c				; save item type 
1f4c 3e 01			ld a,  DS_TYPE_STR 
1f4e 77				ld (hl), a 
1f4f 23				inc hl 
1f50			 
1f50				; get malloc word off stack 
1f50 d1				pop de 
1f51 73				ld (hl), e 
1f52 23				inc hl 
1f53 72				ld (hl), d 
1f54			 
1f54			 
1f54			 
1f54			if DEBUG_FORTH_PUSH 
1f54 2a 01 fb			ld hl, (cli_data_sp) 
1f57						DMARK "PHS" 
1f57 f5				push af  
1f58 3a 6c 1f			ld a, (.dmark)  
1f5b 32 6e fe			ld (debug_mark),a  
1f5e 3a 6d 1f			ld a, (.dmark+1)  
1f61 32 6f fe			ld (debug_mark+1),a  
1f64 3a 6e 1f			ld a, (.dmark+2)  
1f67 32 70 fe			ld (debug_mark+2),a  
1f6a 18 03			jr .pastdmark  
1f6c ..			.dmark: db "PHS"  
1f6f f1			.pastdmark: pop af  
1f70			endm  
# End of macro DMARK
1f70				CALLMONITOR 
1f70 cd 9d 17			call break_point_state  
1f73				endm  
# End of macro CALLMONITOR
1f73			;	ex de,hl 
1f73			endif	 
1f73				; in case of spaces, skip the ptr past the copied string 
1f73				;pop af 
1f73				;ld (cli_origptr),hl 
1f73			 
1f73 c9				ret 
1f74			 
1f74			 
1f74			 
1f74			; TODO ascii push input onto stack given hl to start of input 
1f74			 
1f74			; identify type 
1f74			; if starts with a " then a string 
1f74			; otherwise it is a number 
1f74			;  
1f74			; if a string 
1f74			;     scan for ending " to get length of string to malloc for + 1 
1f74			;     malloc 
1f74			;     put pointer to string on stack first byte flags as string 
1f74			; 
1f74			; else a number 
1f74			;    look for number format identifier 
1f74			;    $xx hex 
1f74			;    %xxxxx bin 
1f74			;    xxxxx decimal 
1f74			;    convert number to 16bit word.  
1f74			;    malloc word + 1 with flag to identiy as num 
1f74			;    put pointer to number on stack 
1f74			;   
1f74			;  
1f74			  
1f74			forth_apush: 
1f74				; kernel push 
1f74			 
1f74			if DEBUG_FORTH_PUSH 
1f74						DMARK "PSH" 
1f74 f5				push af  
1f75 3a 89 1f			ld a, (.dmark)  
1f78 32 6e fe			ld (debug_mark),a  
1f7b 3a 8a 1f			ld a, (.dmark+1)  
1f7e 32 6f fe			ld (debug_mark+1),a  
1f81 3a 8b 1f			ld a, (.dmark+2)  
1f84 32 70 fe			ld (debug_mark+2),a  
1f87 18 03			jr .pastdmark  
1f89 ..			.dmark: db "PSH"  
1f8c f1			.pastdmark: pop af  
1f8d			endm  
# End of macro DMARK
1f8d				CALLMONITOR 
1f8d cd 9d 17			call break_point_state  
1f90				endm  
# End of macro CALLMONITOR
1f90			endif	 
1f90				; identify input type 
1f90			 
1f90 7e				ld a,(hl) 
1f91 fe 22			cp '"' 
1f93 28 0a			jr z, .fapstr 
1f95 fe 24			cp '$' 
1f97 ca bf 1f			jp z, .faphex 
1f9a fe 25			cp '%' 
1f9c ca a7 1f			jp z, .fapbin 
1f9f			;	cp 'b' 
1f9f			;	jp z, .fabin 
1f9f				; else decimal 
1f9f			 
1f9f				; TODO do decimal conversion 
1f9f				; decimal is stored as a 16bit word 
1f9f			 
1f9f				; by default everything is a string if type is not detected 
1f9f			.fapstr: ; 
1f9f fe 22			cp '"' 
1fa1 20 01			jr nz, .strnoqu 
1fa3 23				inc hl 
1fa4			.strnoqu: 
1fa4 c3 79 1e			jp forth_push_str 
1fa7			 
1fa7			 
1fa7			 
1fa7			.fapbin:    ; push a binary string.  
1fa7 11 00 00			ld de, 0   ; hold a 16bit value 
1faa			 
1faa 23			.fapbinshift:	inc hl  
1fab 7e				ld a,(hl) 
1fac fe 00			cp 0     ; done scanning  
1fae 28 0b			jr z, .fapbdone  	; got it in HL so push  
1fb0			 
1fb0				; left shift de 
1fb0 eb				ex de, hl	 
1fb1 29				add hl, hl 
1fb2			 
1fb2				; is 1 
1fb2 fe 31			cp '1' 
1fb4 20 02			jr nz, .binzero 
1fb6 cb 4d			bit 1, l 
1fb8			.binzero: 
1fb8 eb				ex de, hl	 ; save current de 
1fb9 18 ef			jr .fapbinshift 
1fbb			 
1fbb			.fapbdone: 
1fbb eb				ex de, hl 
1fbc c3 0b 1e			jp forth_push_numhl 
1fbf			 
1fbf			 
1fbf			.faphex:   ; hex is always stored as a 16bit word 
1fbf				; skip number prefix 
1fbf 23				inc hl 
1fc0				; turn ascii into number 
1fc0 cd ad 11			call get_word_hl	; ret 16bit word in hl 
1fc3			 
1fc3 c3 0b 1e			jp forth_push_numhl 
1fc6			 
1fc6 00				 nop 
1fc7			 
1fc7			.fabin:   ; TODO bin conversion 
1fc7			 
1fc7			 
1fc7 c9				ret 
1fc8			 
1fc8			 
1fc8			; get either a string ptr or a 16bit word from the data stack 
1fc8			 
1fc8			FORTH_DSP: macro 
1fc8				call macro_forth_dsp 
1fc8				endm 
1fc8			 
1fc8			macro_forth_dsp: 
1fc8				; data stack pointer points to current word on tos 
1fc8			 
1fc8 2a 01 fb			ld hl,(cli_data_sp) 
1fcb			 
1fcb				if DEBUG_FORTH_PUSH 
1fcb						DMARK "DSP" 
1fcb f5				push af  
1fcc 3a e0 1f			ld a, (.dmark)  
1fcf 32 6e fe			ld (debug_mark),a  
1fd2 3a e1 1f			ld a, (.dmark+1)  
1fd5 32 6f fe			ld (debug_mark+1),a  
1fd8 3a e2 1f			ld a, (.dmark+2)  
1fdb 32 70 fe			ld (debug_mark+2),a  
1fde 18 03			jr .pastdmark  
1fe0 ..			.dmark: db "DSP"  
1fe3 f1			.pastdmark: pop af  
1fe4			endm  
# End of macro DMARK
1fe4			 
1fe4 cd 27 54				call display_data_sp 
1fe7				;call break_point_state 
1fe7				;rst 030h 
1fe7				CALLMONITOR 
1fe7 cd 9d 17			call break_point_state  
1fea				endm  
# End of macro CALLMONITOR
1fea				endif 
1fea			 
1fea c9				ret 
1feb			 
1feb			; return hl to start of value on stack 
1feb			 
1feb			FORTH_DSP_VALUE: macro 
1feb				call macro_forth_dsp_value 
1feb				endm 
1feb			 
1feb			macro_forth_dsp_value: 
1feb			 
1feb				FORTH_DSP 
1feb cd c8 1f			call macro_forth_dsp 
1fee				endm 
# End of macro FORTH_DSP
1fee			 
1fee d5				push de 
1fef			 
1fef 23				inc hl ; skip type 
1ff0			 
1ff0 5e				ld e, (hl) 
1ff1 23				inc hl 
1ff2 56				ld d, (hl) 
1ff3 eb				ex de,hl  
1ff4			 
1ff4 d1				pop de 
1ff5			 
1ff5 c9				ret 
1ff6			 
1ff6			; return hl to start of value to second item on stack 
1ff6			 
1ff6			FORTH_DSP_VALUEM1: macro 
1ff6				call macro_forth_dsp_value_m1 
1ff6				endm 
1ff6			 
1ff6			macro_forth_dsp_value_m1: 
1ff6			 
1ff6				FORTH_DSP 
1ff6 cd c8 1f			call macro_forth_dsp 
1ff9				endm 
# End of macro FORTH_DSP
1ff9			 
1ff9 2b				dec hl 
1ffa 2b				dec hl 
1ffb			;	dec hl 
1ffb			 
1ffb d5				push de 
1ffc			 
1ffc 5e				ld e, (hl) 
1ffd 23				inc hl 
1ffe 56				ld d, (hl) 
1fff eb				ex de,hl  
2000			 
2000 d1				pop de 
2001			 
2001 c9				ret 
2002			 
2002				 
2002			 
2002			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2002			 
2002			FORTH_DSP_POP: macro 
2002				call macro_forth_dsp_pop 
2002				endm 
2002			 
2002			 
2002			; get the tos data type 
2002			 
2002			FORTH_DSP_TYPE:   macro 
2002			 
2002				;FORTH_DSP_VALUE 
2002				FORTH_DSP 
2002				 
2002				; hl points to value 
2002				; check type 
2002			 
2002				ld a,(hl) 
2002			 
2002				endm 
2002			 
2002			; load the tos value into hl 
2002			 
2002			 
2002			FORTH_DSP_VALUEHL:  macro 
2002				call macro_dsp_valuehl 
2002				endm 
2002			 
2002			 
2002			 
2002			macro_dsp_valuehl: 
2002				FORTH_DSP_VALUE 
2002 cd eb 1f			call macro_forth_dsp_value 
2005				endm 
# End of macro FORTH_DSP_VALUE
2005			 
2005				;FORTH_ERR_TOS_NOTNUM 
2005			 
2005				;inc hl   ; skip type id 
2005			 
2005			;	push de 
2005			; 
2005			;	ld e, (hl) 
2005			;	inc hl 
2005			;	ld d, (hl) 
2005			;	ex de,hl  
2005			 
2005			;	pop de 
2005			 
2005				if DEBUG_FORTH_PUSH 
2005						DMARK "DVL" 
2005 f5				push af  
2006 3a 1a 20			ld a, (.dmark)  
2009 32 6e fe			ld (debug_mark),a  
200c 3a 1b 20			ld a, (.dmark+1)  
200f 32 6f fe			ld (debug_mark+1),a  
2012 3a 1c 20			ld a, (.dmark+2)  
2015 32 70 fe			ld (debug_mark+2),a  
2018 18 03			jr .pastdmark  
201a ..			.dmark: db "DVL"  
201d f1			.pastdmark: pop af  
201e			endm  
# End of macro DMARK
201e				CALLMONITOR 
201e cd 9d 17			call break_point_state  
2021				endm  
# End of macro CALLMONITOR
2021				endif 
2021 c9				ret 
2022			 
2022			forth_apushstrhl:      
2022				; push of string requires use of cli_origptr 
2022				; bodge use 
2022			 
2022				; get current cli_origptr, save, update with temp pointer  
2022 ed 5b 1d fb		ld de, (cli_origptr) 
2026 22 1d fb			ld (cli_origptr), hl 
2029 d5				push de 
202a cd 74 1f			call forth_apush 
202d d1				pop de 
202e ed 53 1d fb		ld (cli_origptr), de 
2032 c9			        ret	 
2033			 
2033			 
2033			; increase loop stack pointer and save hl to it 
2033				 
2033			FORTH_LOOP_NEXT: macro 
2033				call macro_forth_loop_next 
2033				;nop 
2033				endm 
2033			 
2033			macro_forth_loop_next: 
2033				if DEBUG_FORTH_STACK_GUARD 
2033 cd bb 64				call check_stacks 
2036				endif 
2036 e5				push hl 
2037 d5				push de 
2038 eb				ex de,hl 
2039 2a 03 fb			ld hl,(cli_loop_sp) 
203c 23				inc hl 
203d 23				inc hl 
203e					if DEBUG_FORTH_WORDS 
203e						DMARK "LNX" 
203e f5				push af  
203f 3a 53 20			ld a, (.dmark)  
2042 32 6e fe			ld (debug_mark),a  
2045 3a 54 20			ld a, (.dmark+1)  
2048 32 6f fe			ld (debug_mark+1),a  
204b 3a 55 20			ld a, (.dmark+2)  
204e 32 70 fe			ld (debug_mark+2),a  
2051 18 03			jr .pastdmark  
2053 ..			.dmark: db "LNX"  
2056 f1			.pastdmark: pop af  
2057			endm  
# End of macro DMARK
2057						CALLMONITOR 
2057 cd 9d 17			call break_point_state  
205a				endm  
# End of macro CALLMONITOR
205a					endif 
205a 22 03 fb			ld (cli_loop_sp),hl 
205d 73				ld (hl), e 
205e 23				inc hl 
205f 72				ld (hl), d 
2060 d1				pop de    ; been reversed so save a swap on restore 
2061 e1				pop hl 
2062				if DEBUG_FORTH_STACK_GUARD 
2062 cd bb 64				call check_stacks 
2065				endif 
2065 c9				ret 
2066			 
2066			; get current ret stack pointer and save to hl  
2066				 
2066			FORTH_LOOP_TOS: macro 
2066				call macro_forth_loop_tos 
2066				endm 
2066			 
2066			macro_forth_loop_tos: 
2066 d5				push de 
2067 2a 03 fb			ld hl,(cli_loop_sp) 
206a 5e				ld e, (hl) 
206b 23				inc hl 
206c 56				ld d, (hl) 
206d eb				ex de, hl 
206e d1				pop de 
206f c9				ret 
2070			 
2070			; pop loop stack pointer 
2070				 
2070			FORTH_LOOP_POP: macro 
2070				call macro_forth_loop_pop 
2070				endm 
2070			 
2070			 
2070			macro_forth_loop_pop: 
2070				if DEBUG_FORTH_STACK_GUARD 
2070					DMARK "LPP" 
2070 f5				push af  
2071 3a 85 20			ld a, (.dmark)  
2074 32 6e fe			ld (debug_mark),a  
2077 3a 86 20			ld a, (.dmark+1)  
207a 32 6f fe			ld (debug_mark+1),a  
207d 3a 87 20			ld a, (.dmark+2)  
2080 32 70 fe			ld (debug_mark+2),a  
2083 18 03			jr .pastdmark  
2085 ..			.dmark: db "LPP"  
2088 f1			.pastdmark: pop af  
2089			endm  
# End of macro DMARK
2089 cd bb 64				call check_stacks 
208c					FORTH_CHK_LOOP_UNDER 
208c e5				push hl 
208d d5				push de 
208e 2a 03 fb			ld hl,(cli_loop_sp) 
2091 11 3d fa			ld de, cli_loop_stack 
2094 cd 14 0e			call cmp16 
2097 da d5 65			jp c, fault_loop_under 
209a d1				pop de 
209b e1				pop hl 
209c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
209c				endif 
209c e5				push hl 
209d 2a 03 fb			ld hl,(cli_loop_sp) 
20a0 2b				dec hl 
20a1 2b				dec hl 
20a2 22 03 fb			ld (cli_loop_sp), hl 
20a5				; TODO do stack underflow checks 
20a5 e1				pop hl 
20a6				if DEBUG_FORTH_STACK_GUARD 
20a6 cd bb 64				call check_stacks 
20a9					FORTH_CHK_LOOP_UNDER 
20a9 e5				push hl 
20aa d5				push de 
20ab 2a 03 fb			ld hl,(cli_loop_sp) 
20ae 11 3d fa			ld de, cli_loop_stack 
20b1 cd 14 0e			call cmp16 
20b4 da d5 65			jp c, fault_loop_under 
20b7 d1				pop de 
20b8 e1				pop hl 
20b9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
20b9				endif 
20b9 c9				ret 
20ba			 
20ba			macro_forth_dsp_pop: 
20ba			 
20ba e5				push hl 
20bb			 
20bb				; release malloc data 
20bb			 
20bb				if DEBUG_FORTH_STACK_GUARD 
20bb cd bb 64				call check_stacks 
20be					FORTH_CHK_DSP_UNDER 
20be e5				push hl 
20bf d5				push de 
20c0 2a 01 fb			ld hl,(cli_data_sp) 
20c3 11 3b f8			ld de, cli_data_stack 
20c6 cd 14 0e			call cmp16 
20c9 da c9 65			jp c, fault_dsp_under 
20cc d1				pop de 
20cd e1				pop hl 
20ce				endm 
# End of macro FORTH_CHK_DSP_UNDER
20ce				endif 
20ce				;ld hl,(cli_data_sp) 
20ce			if DEBUG_FORTH_DOT 
20ce				DMARK "DPP" 
20ce				CALLMONITOR 
20ce			endif	 
20ce			 
20ce			 
20ce			if FORTH_ENABLE_DSPPOPFREE 
20ce			 
20ce				FORTH_DSP 
20ce cd c8 1f			call macro_forth_dsp 
20d1				endm 
# End of macro FORTH_DSP
20d1			 
20d1 7e				ld a, (hl) 
20d2 fe 01			cp DS_TYPE_STR 
20d4 20 07			jr nz, .skippopfree 
20d6			 
20d6				FORTH_DSP_VALUEHL 
20d6 cd 02 20			call macro_dsp_valuehl 
20d9				endm 
# End of macro FORTH_DSP_VALUEHL
20d9 00				nop 
20da			if DEBUG_FORTH_DOT 
20da				DMARK "DPf" 
20da				CALLMONITOR 
20da			endif	 
20da cd 87 13			call free 
20dd			.skippopfree: 
20dd				 
20dd			 
20dd			endif 
20dd			 
20dd			if DEBUG_FORTH_DOT_KEY 
20dd				DMARK "DP2" 
20dd				CALLMONITOR 
20dd			endif	 
20dd			 
20dd				; move pointer down 
20dd			 
20dd 2a 01 fb			ld hl,(cli_data_sp) 
20e0 2b				dec hl 
20e1 2b				dec hl 
20e2			; PARSEV5 
20e2 2b				dec hl 
20e3 22 01 fb			ld (cli_data_sp), hl 
20e6			 
20e6				if DEBUG_FORTH_STACK_GUARD 
20e6 cd bb 64				call check_stacks 
20e9					FORTH_CHK_DSP_UNDER 
20e9 e5				push hl 
20ea d5				push de 
20eb 2a 01 fb			ld hl,(cli_data_sp) 
20ee 11 3b f8			ld de, cli_data_stack 
20f1 cd 14 0e			call cmp16 
20f4 da c9 65			jp c, fault_dsp_under 
20f7 d1				pop de 
20f8 e1				pop hl 
20f9				endm 
# End of macro FORTH_CHK_DSP_UNDER
20f9				endif 
20f9			 
20f9 e1				pop hl 
20fa			 
20fa c9				ret 
20fb			 
20fb			getwordathl: 
20fb				; hl points to an address 
20fb				; load hl with the word at that address 
20fb			 
20fb d5				push de 
20fc			 
20fc 5e				ld e, (hl) 
20fd 23				inc hl 
20fe 56				ld d, (hl) 
20ff eb				ex de, hl 
2100			 
2100 d1				pop de 
2101 c9				ret 
2102			 
2102			 
2102			 
2102			 
2102			 
2102			; eof 
2102			 
# End of file forth_stackopsv5.asm
2102			endif 
2102			 
2102			user_word_eol:  
2102				; hl contains the pointer to where to create a linked list item from the end 
2102				; of the user dict to continue on at the system word dict 
2102				 
2102				; poke the stub of the word list linked list to repoint to rom words 
2102			 
2102				; stub format 
2102				; db   word id 
2102				; dw    link to next word 
2102			        ; db char length of token 
2102				; db string + 0 term 
2102				; db exec code....  
2102			 
2102 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2104 77				ld (hl), a		; word id 
2105 23				inc hl 
2106			 
2106 11 cc 22			ld de, sysdict 
2109 73				ld (hl), e		; next word link ie system dict 
210a 23				inc hl 
210b 72				ld (hl), d		; next word link ie system dict 
210c 23				inc hl	 
210d			 
210d			;	ld (hl), sysdict		; next word link ie system dict 
210d			;	inc hl 
210d			;	inc hl 
210d			 
210d			;	inc hl 
210d			;	inc hl 
210d			 
210d 3e 02			ld a, 2			; word length is 0 
210f 77				ld (hl), a	 
2110 23				inc hl 
2111			 
2111 3e 7e			ld a, '~'			; word length is 0 
2113 77				ld (hl), a	 
2114 23				inc hl 
2115 3e 00			ld a, 0			; save empty word 
2117 77				ld (hl), a 
2118			 
2118 c9				ret 
2119			 
2119				 
2119			 
2119			forthexec_cleanup: 
2119				FORTH_RSP_POP 
2119 cd d3 1d			call macro_forth_rsp_pop 
211c				endm 
# End of macro FORTH_RSP_POP
211c c9				ret 
211d			 
211d			forth_call_hl: 
211d				; taking hl 
211d e5				push hl 
211e c9				ret 
211f			 
211f			; this is called to reset Forth system but keep existing uwords etc 
211f			 
211f			forth_warmstart: 
211f				; setup stack over/under flow checks 
211f				if DEBUG_FORTH_STACK_GUARD 
211f cd a1 64				call chk_stk_init 
2122				endif 
2122			 
2122				; init stack pointers  - * these stacks go upwards *  
2122 21 bf fa			ld hl, cli_ret_stack 
2125 22 05 fb			ld (cli_ret_sp), hl	 
2128				; set bottom of stack 
2128 3e 00			ld a,0 
212a 77				ld (hl),a 
212b 23				inc hl 
212c 77				ld (hl),a 
212d			 
212d 21 3b f8			ld hl, cli_data_stack 
2130 22 01 fb			ld (cli_data_sp), hl	 
2133				; set bottom of stack 
2133 3e 00			ld a,0 
2135 77				ld (hl),a 
2136 23				inc hl 
2137 77				ld (hl),a 
2138			 
2138 21 3d fa			ld hl, cli_loop_stack 
213b 22 03 fb			ld (cli_loop_sp), hl	 
213e				; set bottom of stack 
213e 3e 00			ld a,0 
2140 77				ld (hl),a 
2141 23				inc hl 
2142 77				ld (hl),a 
2143			 
2143				; init extent of current open file 
2143			 
2143 3e 00			ld a, 0 
2145 32 50 fb			ld (store_openext), a 
2148			 
2148 c9				ret 
2149			 
2149			 
2149			; Cold Start - this is called to setup the whole Forth system 
2149			 
2149			forth_init: 
2149			 
2149				; setup stack over/under flow checks 
2149			 
2149			;	if DEBUG_FORTH_STACK_GUARD 
2149			;		call chk_stk_init 
2149			;	endif 
2149			 
2149				; enable auto display updates (slow.....) 
2149			 
2149 3e 01			ld a, 1 
214b 32 1b fb			ld (cli_autodisplay), a 
214e			 
214e			 
214e			 
214e				; show start up screen 
214e			 
214e cd c2 0b			call clear_display 
2151			 
2151 3e 00			ld a,0 
2153 32 3d fb			ld (f_cursor_ptr), a 
2156			 
2156				; set start of word list in start of ram - for use when creating user words 
2156			 
2156 21 00 80			ld hl, baseram 
2159 22 d1 f5			ld (os_last_new_uword), hl 
215c cd 02 21			call user_word_eol 
215f				 
215f			;		call display_data_sp 
215f			;		call next_page_prompt 
215f			 
215f			 
215f			 
215f			 
215f c9				ret 
2160			 
2160 .. 00		.bootforth: db " Forth Kernel Init ",0 
2174			 
2174			; TODO push to stack 
2174			 
2174			;  
2174			 
2174			if FORTH_PARSEV2 
2174			 
2174			 
2174				include "forth_parserv2.asm" 
2174			 
2174			endif 
2174			 
2174			 
2174			; parse cli version 1 
2174			 
2174			if FORTH_PARSEV1 
2174			 
2174			 
2174			 
2174			      include "forth_parserv1.asm" 
2174			endif 
2174				 
2174			if FORTH_PARSEV3 
2174			 
2174			 
2174			 
2174			      include "forth_parserv3.asm" 
2174				include "forth_wordsv3.asm" 
2174			endif 
2174			 
2174			if FORTH_PARSEV4 
2174			 
2174			 
2174			 
2174			      include "forth_parserv4.asm" 
2174				include "forth_wordsv4.asm" 
2174			endif 
2174			 
2174			if FORTH_PARSEV5 
2174			 
2174			 
2174			 
2174			      include "forth_parserv5.asm" 
2174			 
2174			 
2174			; A better parser without using malloc and string copies all over the place.  
2174			; Exec in situ should be faster 
2174			 
2174			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2174			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2174			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2174			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2174			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2174			WORD_SYS_END: equ 0   ; Opcode for all user words 
2174			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2174			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2174			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2174			 
2174			; Core word preamble macro 
2174			 
2174			CWHEAD:   macro nxtword opcode lit len opflags 
2174				db WORD_SYS_CORE+opcode             
2174				; internal op code number 
2174				dw nxtword            
2174				; link to next dict word block 
2174				db len + 1 
2174				; literal length of dict word inc zero term 
2174				db lit,0              
2174				; literal dict word 
2174			        ; TODO db opflags        
2174				endm 
2174			 
2174			 
2174			NEXTW: macro  
2174				jp macro_next 
2174				endm 
2174			 
2174			macro_next: 
2174			if DEBUG_FORTH_PARSE_KEY 
2174				DMARK "NXT" 
2174				CALLMONITOR 
2174			endif	 
2174			;	inc hl  ; skip token null term  
2174 ed 4b 1f fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2178 ed 5b 1d fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
217c 2a d5 f5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
217f			if DEBUG_FORTH_PARSE_KEY 
217f				DMARK "}AA" 
217f				CALLMONITOR 
217f			endif	 
217f c3 82 22			jp execnext 
2182				;jp exec1 
2182			       
2182			 
2182			 
2182			; Another go at the parser to compile  
2182			 
2182			 
2182			; TODO rework parser to change all of the string words to byte tokens 
2182			; TODO do a search for  
2182			 
2182			; TODO first run normal parser to zero term sections 
2182			; TODO for each word do a token look up to get the op code 
2182			; TODO need some means to flag to the exec that this is a byte code form    
2182			 
2182			 
2182			forthcompile: 
2182			 
2182			; 
2182			; line parse: 
2182			;       parse raw input buffer 
2182			;       tokenise the words 
2182			;       malloc new copy (for looping etc) 
2182			;       copy to malloc + current pc in line to start of string and add line term 
2182			;       save on new rsp 
2182			; 
2182			 
2182			; hl to point to the line to tokenise 
2182			 
2182			;	push hl 
2182 22 d5 f5			ld (os_tok_ptr), hl  ; save ptr to string 
2185			 
2185			;	ld a,0		; string term on input 
2185			;	call strlent 
2185			 
2185			;	ld (os_tok_len), hl	 ; save string length 
2185			 
2185			;if DEBUG_FORTH_TOK 
2185			;	ex de,hl		 
2185			;endif 
2185			 
2185			;	pop hl 		; get back string pointer 
2185			 
2185			if DEBUG_FORTH_TOK 
2185						DMARK "TOc" 
2185				CALLMONITOR 
2185			endif 
2185 7e			.cptoken2:    ld a,(hl) 
2186 23				inc hl 
2187 fe 7f			cp FORTH_END_BUFFER 
2189 28 29			jr z, .cptokendone2 
218b fe 00			cp 0 
218d 28 25			jr z, .cptokendone2 
218f fe 22			cp '"' 
2191 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2193 fe 20			cp ' ' 
2195 20 ee			jr nz,  .cptoken2 
2197			 
2197			; TODO consume comments held between ( and ) 
2197			 
2197				; we have a space so change to zero term for dict match later 
2197 2b				dec hl 
2198 3e 00			ld a,0 
219a 77				ld (hl), a 
219b 23				inc hl 
219c 18 e7			jr .cptoken2 
219e				 
219e			 
219e			.cptokenstr2: 
219e				; skip all white space until either eol (because forgot to term) or end double quote 
219e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
219e				;inc hl ; skip current double quote 
219e 7e				ld a,(hl) 
219f 23				inc hl 
21a0 fe 22			cp '"' 
21a2 28 e1			jr z, .cptoken2 
21a4 fe 7f			cp FORTH_END_BUFFER 
21a6 28 0c			jr z, .cptokendone2 
21a8 fe 00			cp 0 
21aa 28 08			jr z, .cptokendone2 
21ac fe 20			cp ' ' 
21ae 28 02			jr z, .cptmp2 
21b0 18 ec			jr .cptokenstr2 
21b2			 
21b2			.cptmp2:	; we have a space so change to zero term for dict match later 
21b2				;dec hl 
21b2				;ld a,"-"	; TODO remove this when working 
21b2				;ld (hl), a 
21b2				;inc hl 
21b2 18 ea			jr .cptokenstr2 
21b4			 
21b4			.cptokendone2: 
21b4				;inc hl 
21b4 3e 7f			ld a, FORTH_END_BUFFER 
21b6 77				ld (hl),a 
21b7 23				inc hl 
21b8 3e 21			ld a, '!' 
21ba 77				ld (hl),a 
21bb			 
21bb 2a d5 f5			ld hl,(os_tok_ptr) 
21be			         
21be			if DEBUG_FORTH_TOK 
21be						DMARK "Tc1" 
21be				CALLMONITOR 
21be			endif 
21be			 
21be				; push exec string to top of return stack 
21be				FORTH_RSP_NEXT 
21be cd b2 1d			call macro_forth_rsp_next 
21c1				endm 
# End of macro FORTH_RSP_NEXT
21c1 c9				ret 
21c2			 
21c2			; Another go at the parser need to simplify the process 
21c2			 
21c2			forthparse: 
21c2			 
21c2			; 
21c2			; line parse: 
21c2			;       parse raw input buffer 
21c2			;       tokenise the words 
21c2			;       malloc new copy (for looping etc) 
21c2			;       copy to malloc + current pc in line to start of string and add line term 
21c2			;       save on new rsp 
21c2			; 
21c2			 
21c2			; hl to point to the line to tokenise 
21c2			 
21c2			;	push hl 
21c2 22 d5 f5			ld (os_tok_ptr), hl  ; save ptr to string 
21c5			 
21c5			;	ld a,0		; string term on input 
21c5			;	call strlent 
21c5			 
21c5			;	ld (os_tok_len), hl	 ; save string length 
21c5			 
21c5			;if DEBUG_FORTH_TOK 
21c5			;	ex de,hl		 
21c5			;endif 
21c5			 
21c5			;	pop hl 		; get back string pointer 
21c5			 
21c5			if DEBUG_FORTH_TOK 
21c5						DMARK "TOK" 
21c5				CALLMONITOR 
21c5			endif 
21c5 7e			.ptoken2:    ld a,(hl) 
21c6 23				inc hl 
21c7 fe 7f			cp FORTH_END_BUFFER 
21c9 28 29			jr z, .ptokendone2 
21cb fe 00			cp 0 
21cd 28 25			jr z, .ptokendone2 
21cf fe 22			cp '"' 
21d1 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
21d3 fe 20			cp ' ' 
21d5 20 ee			jr nz,  .ptoken2 
21d7			 
21d7			; TODO consume comments held between ( and ) 
21d7			 
21d7				; we have a space so change to zero term for dict match later 
21d7 2b				dec hl 
21d8 3e 00			ld a,0 
21da 77				ld (hl), a 
21db 23				inc hl 
21dc 18 e7			jr .ptoken2 
21de				 
21de			 
21de			.ptokenstr2: 
21de				; skip all white space until either eol (because forgot to term) or end double quote 
21de			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
21de				;inc hl ; skip current double quote 
21de 7e				ld a,(hl) 
21df 23				inc hl 
21e0 fe 22			cp '"' 
21e2 28 e1			jr z, .ptoken2 
21e4 fe 7f			cp FORTH_END_BUFFER 
21e6 28 0c			jr z, .ptokendone2 
21e8 fe 00			cp 0 
21ea 28 08			jr z, .ptokendone2 
21ec fe 20			cp ' ' 
21ee 28 02			jr z, .ptmp2 
21f0 18 ec			jr .ptokenstr2 
21f2			 
21f2			.ptmp2:	; we have a space so change to zero term for dict match later 
21f2				;dec hl 
21f2				;ld a,"-"	; TODO remove this when working 
21f2				;ld (hl), a 
21f2				;inc hl 
21f2 18 ea			jr .ptokenstr2 
21f4			 
21f4			.ptokendone2: 
21f4				;inc hl 
21f4 3e 7f			ld a, FORTH_END_BUFFER 
21f6 77				ld (hl),a 
21f7 23				inc hl 
21f8 3e 21			ld a, '!' 
21fa 77				ld (hl),a 
21fb			 
21fb 2a d5 f5			ld hl,(os_tok_ptr) 
21fe			         
21fe			if DEBUG_FORTH_TOK 
21fe						DMARK "TK1" 
21fe				CALLMONITOR 
21fe			endif 
21fe			 
21fe				; push exec string to top of return stack 
21fe				FORTH_RSP_NEXT 
21fe cd b2 1d			call macro_forth_rsp_next 
2201				endm 
# End of macro FORTH_RSP_NEXT
2201 c9				ret 
2202			 
2202			; 
2202			;	; malloc size + buffer pointer + if is loop flag 
2202			;	ld hl,(os_tok_len) 		 ; get string length 
2202			; 
2202			;	ld a,l 
2202			; 
2202			;	cp 0			; we dont want to use a null string 
2202			;	ret z 
2202			; 
2202			;;	add 3    ; prefix malloc with buffer for current word ptr 
2202			; 
2202			;	add 5     ; TODO when certain not over writing memory remove 
2202			; 
2202			;		 
2202			; 
2202			;if DEBUG_FORTH_TOK 
2202			;			DMARK "TKE" 
2202			;	CALLMONITOR 
2202			;endif 
2202			; 
2202			;	ld l,a 
2202			;	ld h,0 
2202			;;	push hl   ; save required space for the copy later 
2202			;	call malloc 
2202			;if DEBUG_FORTH_TOK 
2202			;			DMARK "TKM" 
2202			;	CALLMONITOR 
2202			;endif 
2202			;	if DEBUG_FORTH_MALLOC_GUARD 
2202			;		push af 
2202			;		call ishlzero 
2202			;;		ld a, l 
2202			;;		add h 
2202			;;		cp 0 
2202			;		pop af 
2202			;		 
2202			;		call z,malloc_error 
2202			;	endif 
2202			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2202			; 
2202			; 
2202			;if DEBUG_FORTH_TOK 
2202			;			DMARK "TKR" 
2202			;	CALLMONITOR 
2202			;endif 
2202			; 
2202			;	FORTH_RSP_NEXT 
2202			; 
2202			;	;inc hl	 ; go past current buffer pointer 
2202			;	;inc hl 
2202			;	;inc hl   ; and past if loop flag 
2202			;		; TODO Need to set flag  
2202			; 
2202			;	 
2202			;	 
2202			;	ex de,hl	; malloc is dest 
2202			;	ld hl, (os_tok_len) 
2202			;;	pop bc 
2202			;	ld c, l                
2202			;	ld b,0 
2202			;	ld hl, (os_tok_ptr) 
2202			; 
2202			;if DEBUG_FORTH_TOK 
2202			;			DMARK "TKT" 
2202			;	CALLMONITOR 
2202			;endif 
2202			; 
2202			;	; do str cpy 
2202			; 
2202			;	ldir      ; copy byte in hl to de 
2202			; 
2202			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2202			; 
2202			;if DEBUG_FORTH_TOK 
2202			; 
2202			;			DMARK "TKY" 
2202			;	CALLMONITOR 
2202			;endif 
2202			;	;ld a,0 
2202			;	;ld a,FORTH_END_BUFFER 
2202			;	ex de, hl 
2202			;	;dec hl			 ; go back over the space delim at the end of word 
2202			;	;ld (hl),a 
2202			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2202			;	ld a,FORTH_END_BUFFER 
2202			;	ld (hl),a 
2202			;	inc hl 
2202			;	ld a,FORTH_END_BUFFER 
2202			;	ld (hl),a 
2202			; 
2202			;	; init the malloc area data 
2202			;	; set pc for in current area 
2202			;	;ld hl, (os_tok_malloc) 
2202			;	;inc hl 
2202			;	;inc hl 
2202			;	;inc hl 
2202			;	;ex de,hl 
2202			;	;ld hl, (os_tok_malloc) 
2202			;	;ld (hl),e 
2202			;	;inc hl 
2202			;	;ld (hl),d 
2202			; 
2202			; 
2202			;	ld hl,(os_tok_malloc) 
2202			;if DEBUG_FORTH_PARSE_KEY 
2202			;			DMARK "TKU" 
2202			;	CALLMONITOR 
2202			;endif 
2202			; 
2202			;	ret 
2202			 
2202			forthexec: 
2202			 
2202			; line exec: 
2202			; forth parser 
2202			 
2202			; 
2202			;       get current exec line on rsp 
2202			 
2202				FORTH_RSP_TOS 
2202 cd c9 1d			call macro_forth_rsp_tos 
2205				endm 
# End of macro FORTH_RSP_TOS
2205			 
2205			;       restore current pc - hl points to malloc of data 
2205			 
2205				;ld e, (hl) 
2205				;inc hl 
2205				;ld d, (hl) 
2205				;ex de,hl 
2205			 
2205			 
2205			exec1: 
2205 22 d5 f5			ld (os_tok_ptr), hl 
2208			 
2208				; copy our PC to working vars  
2208 22 1f fb			ld (cli_ptr), hl 
220b 22 1d fb			ld (cli_origptr), hl 
220e			 
220e 7e				ld a,(hl) 
220f fe 7f			cp FORTH_END_BUFFER 
2211 c8				ret z 
2212			 
2212				; skip any nulls 
2212			 
2212 fe 00			cp 0 
2214 20 03			jr nz, .execword 
2216 23				inc hl 
2217 18 ec			jr exec1 
2219			 
2219			 
2219			.execword: 
2219			 
2219			 
2219			 
2219			if DEBUG_FORTH_PARSE_KEY 
2219						DMARK "KYQ" 
2219				CALLMONITOR 
2219			endif 
2219			;       while at start of word: 
2219			; get start of dict (in user area first) 
2219			 
2219 21 00 80		ld hl, baseram 
221c			;ld hl, sysdict 
221c 22 21 fb		ld (cli_nextword),hl 
221f			;           match word at pc 
221f			;           exec word 
221f			;           or push to dsp 
221f			;           forward to next token 
221f			;           if line term pop rsp and exit 
221f			;        
221f			 
221f			if DEBUG_FORTH_PARSE_KEY 
221f						DMARK "KYq" 
221f				CALLMONITOR 
221f			endif 
221f			 
221f			; 
221f			; word comp 
221f			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
221f			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
221f			;    move to start of word  
221f			;    compare word to cli_token 
221f			 
221f			.execpnword:	; HL at start of a word in the dictionary to check 
221f			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
221f			;	ld (cli_ptr), hl 
221f			 
221f 2a 21 fb			ld hl,(cli_nextword) 
2222			 
2222 cd c5 22			call forth_tok_next 
2225			; tok next start here 
2225			;	; TODO skip compiled symbol for now 
2225			;	inc hl 
2225			; 
2225			;	; save pointer to next word 
2225			; 
2225			;	; hl now points to the address of the next word pointer  
2225			;	ld e, (hl) 
2225			;	inc hl 
2225			;	ld d, (hl) 
2225			;	inc l 
2225			; 
2225			;	ex de,hl 
2225			;if DEBUG_FORTH_PARSE_NEXTWORD 
2225			;	push bc 
2225			;	ld bc, (cli_nextword) 
2225			;			DMARK "NXW" 
2225			;	CALLMONITOR 
2225			;	pop bc 
2225			;endif 
2225			; tok next end here 
2225 22 21 fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
2228 eb				ex de, hl 
2229			 
2229			 
2229				; save the pointer of the current token - 1 to check against 
2229				 
2229 22 25 fb			ld (cli_token), hl   
222c				; TODO maybe remove below save if no debug 
222c				; save token string ptr for any debug later 
222c 23				inc hl  
222d 22 27 fb			ld (cli_origtoken), hl 
2230 2b				dec hl 
2231				; save pointer to the start of the next dictionay word 
2231 7e				ld a,(hl)   ; get string length 
2232 47				ld b,a 
2233			.execpnwordinc:  
2233 23				inc hl 
2234 10 fd			djnz .execpnwordinc 
2236 22 23 fb			ld (cli_execword), hl      ; save start of this words code 
2239			 
2239				; now check the word token against the string being parsed 
2239			 
2239 2a 25 fb			ld hl,(cli_token) 
223c 23				inc hl     ; skip string length (use zero term instead to end) 
223d 22 25 fb			ld (cli_token), hl 
2240			 
2240			if DEBUG_FORTH_PARSE_KEY 
2240						DMARK "KY2" 
2240			endif 
2240			if DEBUG_FORTH_PARSE_EXEC 
2240				; see if disabled 
2240			 
2240				ld a, (os_view_disable) 
2240				cp '*' 
2240				jr z, .skip 
2240			 
2240				push hl 
2240				push hl 
2240				call clear_display 
2240				ld de, .compword 
2240				ld a, display_row_1 
2240				call str_at_display 
2240				pop de 
2240				ld a, display_row_2 
2240				call str_at_display 
2240				ld hl,(cli_ptr) 
2240				ld a,(hl) 
2240			        ld hl, os_word_scratch 
2240				ld (hl),a 
2240				ld a,0 
2240				inc hl 
2240				ld (hl),a 	 
2240				ld de, os_word_scratch 
2240				ld a, display_row_2+10 
2240				call str_at_display 
2240				call update_display 
2240				ld a, 100 
2240				call aDelayInMS 
2240				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2240				call delay250ms 
2240				endif 
2240				pop hl 
2240			.skip:  
2240			endif	 
2240			.execpnchar:    ; compare char between token and string to parse 
2240			 
2240			if DEBUG_FORTH_PARSE_KEY 
2240						DMARK "Ky3" 
2240			endif 
2240			if DEBUG_FORTH_PARSE_EXEC 
2240				; see if disabled 
2240			 
2240				ld a, (os_view_disable) 
2240				cp '*' 
2240				jr z, .skip2 
2240			 
2240			;	call clear_display 
2240			ld hl,(cli_token) 
2240			ld a,(hl) 
2240			ld (os_word_scratch),a 
2240				ld hl,(cli_ptr) 
2240			ld a,(hl) 
2240				ld (os_word_scratch+1),a 
2240				ld a,0 
2240				ld (os_word_scratch+2),a 
2240				ld de,os_word_scratch 
2240				ld a,display_row_4 
2240				call str_at_display 
2240				call update_display 
2240			.skip2:  
2240			endif 
2240 2a 25 fb			ld hl,(cli_token) 
2243 7e				ld a, (hl)	 ; char in word token 
2244 23				inc hl 		; move to next char 
2245 22 25 fb			ld (cli_token), hl ; and save it 
2248 47				ld b,a 
2249			 
2249 2a 1f fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
224c 7e				ld a,(hl) 
224d 23				inc hl 
224e 22 1f fb			ld (cli_ptr), hl		; move to next char 
2251 cd 4b 12			call toUpper 		; make sure the input string matches case 
2254			 
2254			if DEBUG_FORTH_PARSE 
2254			endif 
2254			 
2254				; input stream end of token is a space so get rid of it 
2254			 
2254			;	cp ' ' 
2254			;	jr nz, .pnskipspace 
2254			; 
2254			;	ld a, 0		; make same term as word token term 
2254			; 
2254			;.pnskipspace: 
2254			 
2254			if DEBUG_FORTH_PARSE_KEY 
2254						DMARK "KY7" 
2254			endif 
2254 b8				cp b 
2255 c2 6b 22			jp nz, .execpnskipword	 ; no match so move to next word 
2258				 
2258			;    if same 
2258			;       scan for string terms 0 for token and 32 for input 
2258			 
2258				 
2258			if DEBUG_FORTH_PARSE_KEY 
2258						DMARK "KY8" 
2258			endif 
2258			 
2258 80				add b			 
2259 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
225b							; TODO need to make sure last word in zero term string is accounted for 
225b 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
225d			 
225d			 
225d				; at end of both strings so both are exact match 
225d			 
225d			;       skip ptr for next word 
225d			 
225d 2a 1f fb			ld hl,(cli_ptr) 	; at input string term 
2260 23				inc hl			 ; at next char 
2261 22 1f fb			ld (cli_ptr), hl     ; save for next round of the parser 
2264 22 1d fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2267				 
2267				 
2267			if DEBUG_FORTH_PARSE_KEY 
2267						DMARK "KY3" 
2267			endif 
2267			 
2267			 
2267			 
2267			;       exec code block 
2267			if DEBUG_FORTH_JP 
2267				call clear_display 
2267				call update_display 
2267				call delay1s 
2267				ld hl, (cli_execword)     ; save for next check if no match on this word 
2267				ld a,h 
2267				ld hl, os_word_scratch 
2267				call hexout 
2267				ld hl, (cli_execword)     ; save for next check if no match on this word 
2267				ld a,l 
2267				ld hl, os_word_scratch+2 
2267				call hexout 
2267				ld hl, os_word_scratch+4 
2267				ld a,0 
2267				ld (hl),a 
2267				ld de,os_word_scratch 
2267				call str_at_display 
2267					ld a, display_row_2 
2267					call str_at_display 
2267				ld de, (cli_origtoken) 
2267				ld a, display_row_1+10 
2267					call str_at_display 
2267			 
2267				ld a,display_row_1 
2267				ld de, .foundword 
2267				ld a, display_row_3 
2267				call str_at_display 
2267				call update_display 
2267				call delay1s 
2267				call delay1s 
2267				call delay1s 
2267			endif 
2267			 
2267			if DEBUG_FORTH_PARSE_KEY 
2267						DMARK "KYj" 
2267			endif 
2267				; TODO save the word pointer in this exec 
2267			 
2267 2a 23 fb			ld hl,(cli_execword) 
226a e9				jp (hl) 
226b			 
226b			 
226b			;    if not same 
226b			;	scan for zero term 
226b			;	get ptr for next word 
226b			;	goto word comp 
226b			 
226b			.execpnskipword:	; get pointer to next word 
226b 2a 21 fb			ld hl,(cli_nextword) 
226e			 
226e 7e				ld a,(hl) 
226f fe 00			cp WORD_SYS_END 
2271			;	cp 0 
2271 28 09			jr z, .execendofdict			 ; at end of words 
2273			 
2273			if DEBUG_FORTH_PARSE_KEY 
2273						DMARK "KY4" 
2273			endif 
2273			if DEBUG_FORTH_PARSE_EXEC 
2273			 
2273				; see if disabled 
2273			 
2273				ld a, (os_view_disable) 
2273				cp '*' 
2273				jr z, .noskip 
2273			 
2273			 
2273				ld de, .nowordfound 
2273				ld a, display_row_3 
2273				call str_at_display 
2273				call update_display 
2273				ld a, 100 
2273				call aDelayInMS 
2273				 
2273				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2273					call delay250ms 
2273				endif 
2273			.noskip:  
2273			 
2273			endif	 
2273			 
2273 2a 1d fb			ld hl,(cli_origptr) 
2276 22 1f fb			ld (cli_ptr),hl 
2279			 
2279			if DEBUG_FORTH_PARSE_KEY 
2279						DMARK "KY5" 
2279			endif 
2279 c3 1f 22			jp .execpnword			; else go to next word 
227c			 
227c			.execendofdict:  
227c			 
227c			if DEBUG_FORTH_PARSE_KEY 
227c						DMARK "KYe" 
227c			endif 
227c			if DEBUG_FORTH_PARSE_EXEC 
227c				; see if disabled 
227c			 
227c				ld a, (os_view_disable) 
227c				cp '*' 
227c				jr z, .ispskip 
227c			 
227c				call clear_display 
227c				call update_display 
227c				call delay1s 
227c				ld de, (cli_origptr) 
227c				ld a, display_row_1 
227c				call str_at_display 
227c				 
227c				ld de, .enddict 
227c				ld a, display_row_3 
227c				call str_at_display 
227c				call update_display 
227c				ld a, 100 
227c				call aDelayInMS 
227c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
227c				call delay1s 
227c				call delay1s 
227c				call delay1s 
227c				endif 
227c			.ispskip:  
227c				 
227c			endif	 
227c			 
227c			 
227c			 
227c				; if the word is not a keyword then must be a literal so push it to stack 
227c			 
227c			; push token to stack to end of word 
227c			 
227c				STACKFRAME ON $1efe $2f9f 
227c				if DEBUG_STACK_IMB 
227c					if ON 
227c						exx 
227c						ld de, $1efe 
227c						ld a, d 
227c						ld hl, curframe 
227c						call hexout 
227c						ld a, e 
227c						ld hl, curframe+2 
227c						call hexout 
227c						ld hl, $1efe 
227c						push hl 
227c						ld hl, $2f9f 
227c						push hl 
227c						exx 
227c					endif 
227c				endif 
227c			endm 
# End of macro STACKFRAME
227c			 
227c 2a d5 f5		ld hl,(os_tok_ptr) 
227f cd 74 1f		call forth_apush 
2282			 
2282				STACKFRAMECHK ON $1efe $2f9f 
2282				if DEBUG_STACK_IMB 
2282					if ON 
2282						exx 
2282						ld hl, $2f9f 
2282						pop de   ; $2f9f 
2282						call cmp16 
2282						jr nz, .spnosame 
2282						ld hl, $1efe 
2282						pop de   ; $1efe 
2282						call cmp16 
2282						jr z, .spfrsame 
2282						.spnosame: call showsperror 
2282						.spfrsame: nop 
2282						exx 
2282					endif 
2282				endif 
2282			endm 
# End of macro STACKFRAMECHK
2282			 
2282			execnext: 
2282			 
2282			if DEBUG_FORTH_PARSE_KEY 
2282						DMARK "KY>" 
2282			endif 
2282			; move past token to next word 
2282			 
2282 2a d5 f5		ld hl, (os_tok_ptr) 
2285 3e 00		ld a, 0 
2287 01 ff 00		ld bc, 255     ; input buffer size 
228a ed b1		cpir 
228c			 
228c			if DEBUG_FORTH_PARSE_KEY 
228c						DMARK "KY!" 
228c				CALLMONITOR 
228c			endif	 
228c			; TODO this might place hl on the null, so will need to forward on??? 
228c			;inc hl   ; see if this gets onto the next item 
228c			 
228c			 
228c			; TODO pass a pointer to the buffer to push 
228c			; TODO call function to push 
228c			 
228c			; look for end of input 
228c			 
228c			;inc hl 
228c			;ld a,(hl) 
228c			;cp FORTH_END_BUFFER 
228c			;ret z 
228c			 
228c			 
228c c3 05 22		jp exec1 
228f			 
228f			 
228f			 
228f			 
228f			 
228f			 
228f			 
228f			 
228f			 
228f			findnexttok: 
228f			 
228f				; hl is pointer to move 
228f				; de is the token to locate 
228f			 
228f					if DEBUG_FORTH 
228f						DMARK "NTK" 
228f						CALLMONITOR 
228f					endif 
228f d5				push de 
2290			 
2290			.fnt1:	 
2290				; find first char of token to locate 
2290			 
2290 1a				ld a, (de) 
2291 4f				ld c,a 
2292 7e				ld a,(hl) 
2293 cd 4b 12			call toUpper 
2296					if DEBUG_FORTH 
2296						DMARK "NT1" 
2296						CALLMONITOR 
2296					endif 
2296 b9				cp c 
2297			 
2297 28 03			jr z, .fnt2cmpmorefirst	 
2299			 
2299				; first char not found move to next char 
2299			 
2299 23				inc hl 
229a 18 f4			jr .fnt1 
229c			 
229c			.fnt2cmpmorefirst:	 
229c				; first char of token found.  
229c			 
229c e5				push hl     ; save start of token just in case it is the right one 
229d d9				exx 
229e e1				pop hl        ; save it to hl' 
229f d9				exx 
22a0			 
22a0			 
22a0			.fnt2cmpmore:	 
22a0				; compare the rest 
22a0				 
22a0 23				inc hl 
22a1 13				inc de 
22a2				 
22a2 1a				ld a, (de) 
22a3 4f				ld c,a 
22a4 7e				ld a,(hl) 
22a5 cd 4b 12			call toUpper 
22a8			 
22a8					if DEBUG_FORTH 
22a8						DMARK "NT2" 
22a8						CALLMONITOR 
22a8					endif 
22a8				; c has the token to find char 
22a8				; a has the mem to scan char 
22a8			 
22a8 b9				cp c 
22a9 28 04			jr z,.fntmatch1 
22ab			 
22ab				; they are not the same 
22ab			 
22ab					if DEBUG_FORTH 
22ab						DMARK "NT3" 
22ab						CALLMONITOR 
22ab					endif 
22ab d1				pop de	; reset de token to look for 
22ac d5				push de 
22ad 18 e1			jr .fnt1 
22af				 
22af			.fntmatch1: 
22af			 
22af				; is the same char a null which means we might have a full hit? 
22af					if DEBUG_FORTH 
22af						DMARK "NT4" 
22af						CALLMONITOR 
22af					endif 
22af			 
22af fe 00			cp 0 
22b1 28 0b			jr z, .fntmatchyes 
22b3			 
22b3				; are we at the end of the token to find? 
22b3			 
22b3					if DEBUG_FORTH 
22b3						DMARK "NT5" 
22b3						CALLMONITOR 
22b3					endif 
22b3 3e 00			ld a, 0 
22b5 b9				cp c 
22b6			 
22b6 c2 a0 22			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
22b9			 
22b9					if DEBUG_FORTH 
22b9						DMARK "NT6" 
22b9						CALLMONITOR 
22b9					endif 
22b9				; token to find is exhusted but no match to stream 
22b9			 
22b9				; restore tok pointer and continue on 
22b9 d1				pop de 
22ba d5				push de 
22bb c3 90 22			jp .fnt1 
22be			 
22be			 
22be			.fntmatchyes: 
22be			 
22be				; hl now contains the end of the found token 
22be			 
22be				; get rid of saved token pointer to find 
22be			 
22be d1				pop de 
22bf			 
22bf					if DEBUG_FORTH 
22bf						DMARK "NT9" 
22bf						CALLMONITOR 
22bf					endif 
22bf			 
22bf				; hl will be on the null term so forward on 
22bf			 
22bf				; get back the saved start of the token 
22bf			 
22bf d9				exx 
22c0 e5				push hl     ; save start of token just in case it is the right one 
22c1 d9				exx 
22c2 e1				pop hl        ; save it to hl 
22c3			 
22c3 c9				ret 
22c4			 
22c4			 
22c4			; LIST needs to find a specific token   
22c4			; FORGET needs to find a spefici token 
22c4			 
22c4			; SAVE needs to find all tokens by flag 
22c4			; WORDS just needs to scan through all  by flag 
22c4			; UWORDS needs to scan through all by flag 
22c4			 
22c4			 
22c4			; given hl as pointer to start of dict look up string 
22c4			; return hl as pointer to start of word block 
22c4			; or 0 if not found 
22c4			 
22c4			forth_find_tok: 
22c4 c9				ret 
22c5			 
22c5			; given hl as pointer to dict structure 
22c5			; move to the next dict block structure 
22c5			 
22c5			forth_tok_next: 
22c5				; hl now points to the address of the next word pointer  
22c5				; TODO skip compiled symbol for now 
22c5			;	push de 
22c5 23				inc hl 
22c6 5e				ld e, (hl) 
22c7 23				inc hl 
22c8 56				ld d, (hl) 
22c9 23				inc hl 
22ca			 
22ca eb				ex de,hl 
22cb			if DEBUG_FORTH_PARSE_NEXTWORD 
22cb				push bc 
22cb				ld bc, (cli_nextword) 
22cb						DMARK "NXW" 
22cb				CALLMONITOR 
22cb				pop bc 
22cb			endif 
22cb			;	pop de	 
22cb c9				ret 
22cc			 
22cc			 
22cc			 
22cc			; eof 
# End of file forth_parserv5.asm
22cc				include "forth_wordsv4.asm" 
22cc			 
22cc			; the core word dictionary v4 
22cc			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
22cc			 
22cc			; this is a linked list for each of the system words used 
22cc			; user defined words will follow the same format but will be in ram 
22cc			 
22cc			 
22cc			; 
22cc			; 
22cc			; define linked list: 
22cc			; 
22cc			; 1. compiled byte op code 
22cc			; 2. len of text word 
22cc			; 3. text word 
22cc			; 4. ptr to next dictionary word 
22cc			; 5. asm, calls etc for the word 
22cc			; 
22cc			;  if 1 == 0 then last word in dict  
22cc			;   
22cc			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
22cc			;  
22cc			;  
22cc			; create basic standard set of words 
22cc			; 
22cc			;  
22cc			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
22cc			; 2DUP 2DROP 2SWAP  
22cc			; @ C@ - get byte  
22cc			; ! C! - store byte 
22cc			; 0< true if less than zero 
22cc			; 0= true if zero 
22cc			; < >  
22cc			; = true if same 
22cc			; variables 
22cc			 
22cc			 
22cc			; Hardware specific words I may need 
22cc			; 
22cc			; IN OUT  
22cc			; calls to key util functions 
22cc			; calls to hardward abstraction stuff 
22cc			; easy control of frame buffers and lcd i/o 
22cc			; keyboard  
22cc			 
22cc			 
22cc			;DICT: macro 
22cc			; op_code, len, word, next 
22cc			;    word: 
22cc			;    db op_code 
22cc			;    ds word zero term 
22cc			;    dw next 
22cc			;    endm 
22cc			 
22cc			 
22cc			 
22cc			 
22cc			; op code 1 is a flag for user define words which are to be handled differently 
22cc			 
22cc			 
22cc			; 
22cc			; 
22cc			;    TODO on entry to a word this should be the expected environment 
22cc			;    hl - tos value if number then held, if string this is the ptr 
22cc			;    de -  
22cc			 
22cc			 
22cc			; opcode ranges 
22cc			; 0 - end of word dict 
22cc			; 255 - user define words 
22cc			 
22cc			sysdict: 
22cc			include "forth_opcodes.asm" 
22cc			; op codes for forth keywords 
22cc			; free to use code 0  
22cc				OPCODE_HEAP: equ  1 
22cc				OPCODE_EXEC: equ 2 
22cc				OPCODE_DUP: equ 3 
22cc				OPCODE_SWAP: equ 4 
22cc				OPCODE_COLN: equ 5 
22cc				OPCODE_SCOLN: equ 6 
22cc				OPCODE_DROP: equ 7 
22cc				OPCODE_DUP2: equ 8 
22cc				OPCODE_DROP2: equ 9 
22cc				OPCODE_SWAP2: equ 10 
22cc				OPCODE_AT: equ 11 
22cc				OPCODE_CAT: equ 12 
22cc				OPCODE_BANG: equ 13 
22cc				OPCODE_CBANG: equ 14 
22cc				OPCODE_SCALL: equ 15 
22cc				OPCODE_DEPTH: equ 16 
22cc				OPCODE_OVER: equ 17 
22cc				OPCODE_PAUSE: equ 18 
22cc				OPCODE_PAUSES: equ 19 
22cc				OPCODE_ROT: equ 20 
22cc			;free to reuse	OPCODE_WORDS: equ 21 
22cc			        OPCODE_NOT: equ 21 
22cc				OPCODE_UWORDS: equ 22 
22cc				OPCODE_BP: equ 23 
22cc				OPCODE_MONITOR: equ 24  
22cc				OPCODE_MALLOC: equ 25 
22cc				OPCODE_FREE: equ 26 
22cc				OPCODE_LIST: equ 27 
22cc				OPCODE_FORGET: equ 28 
22cc				OPCODE_NOP: equ 29 
22cc				OPCODE_COMO: equ 30 
22cc				OPCODE_COMC: equ 31 
22cc			;free to reuse	OPCODE_ENDCORE: equ 32 
22cc				OPCODE_AFTERSOUND: equ 33 
22cc				OPCODE_GP2: equ 34 
22cc				OPCODE_GP3: equ 35 
22cc				OPCODE_GP4: equ 36 
22cc				OPCODE_SIN: equ 37 
22cc				OPCODE_SOUT: equ 38 
22cc				OPCODE_SPIO: equ 39 
22cc				OPCODE_SPICEH: equ 40 
22cc				OPCODE_SPIOb: equ 41 
22cc				OPCODE_SPII: equ 42 
22cc				OPCODE_SESEL: equ 43 
22cc				OPCODE_CARTDEV: equ 44 
22cc			; free to reuse	OPCODE_ENDDEVICE: equ 45 
22cc				OPCODE_FB: equ 46 
22cc				OPCODE_EMIT: equ 47 
22cc				OPCODE_DOTH: equ 48 
22cc				OPCODE_DOTF: equ 49 
22cc				OPCODE_DOT: equ 50 
22cc				OPCODE_CLS: equ 51 
22cc				OPCODE_DRAW: equ 52 
22cc				OPCODE_DUMP: equ 53 
22cc				OPCODE_CDUMP: equ 54 
22cc				OPCODE_DAT: equ 55 
22cc				OPCODE_HOME: equ 56 
22cc				OPCODE_SPACE: equ 57 
22cc				OPCODE_SPACES: equ 58 
22cc				OPCODE_SCROLL: equ 59 
22cc				OPCODE_ATQ: equ 60 
22cc				OPCODE_AUTODSP: equ 61 
22cc				OPCODE_MENU: equ 62 
22cc			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
22cc				OPCODE_THEN: equ 64 
22cc				OPCODE_ELSE: equ 65 
22cc				OPCODE_DO: equ 66 
22cc				OPCODE_LOOP: equ 67 
22cc				OPCODE_I: equ 68 
22cc				OPCODE_DLOOP: equ 69  
22cc				OPCODE_REPEAT: equ 70  
22cc				OPCODE_UNTIL: equ 71 
22cc				OPCODE_ENDFLOW: equ 72 
22cc				OPCODE_WAITK: equ 73 
22cc				OPCODE_ACCEPT: equ 74 
22cc				OPCODE_EDIT: equ 75 
22cc			;free to reuse	OPCODE_ENDKEY: equ 76 
22cc				OPCODE_LZERO: equ 77 
22cc				OPCODE_TZERO: equ 78 
22cc				OPCODE_LESS: equ 79 
22cc				OPCODE_GT: equ 80 
22cc				OPCODE_EQUAL: equ 81  
22cc			;free to reuse	OPCODE_ENDLOGIC: equ 82 
22cc				OPCODE_NEG: equ 83 
22cc				OPCODE_DIV: equ 84 
22cc				OPCODE_MUL: equ 85 
22cc				OPCODE_MIN: equ 86 
22cc				OPCODE_MAX: equ 87 
22cc				OPCODE_RND16: equ 88 
22cc				OPCODE_RND8: equ 89 
22cc				OPCODE_RND: equ 90 
22cc			;free to reuse	OPCODE_ENDMATHS: equ 91  
22cc				OPCODE_BYNAME: equ 92 
22cc				OPCODE_DIR: equ 93 
22cc				OPCODE_SAVE: equ 94 
22cc				OPCODE_LOAD: equ 95 
22cc				OPCODE_BSAVE: equ 96 
22cc				OPCODE_BLOAD: equ 97 
22cc				OPCODE_SEO: equ 98  
22cc				OPCODE_SEI: equ 99 
22cc				OPCODE_SFREE: equ 100 
22cc				OPCODE_SIZE: equ 101 
22cc				OPCODE_CREATE: equ 102 
22cc				OPCODE_APPEND: equ 103 
22cc				OPCODE_SDEL: equ 104 
22cc				OPCODE_OPEN: equ 105 
22cc				OPCODE_READ: equ 106 
22cc				OPCODE_EOF: equ 106 
22cc				OPCODE_FORMAT: equ 107 
22cc				OPCODE_LABEL: equ 108 
22cc				OPCODE_LABELS: equ 109 
22cc			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
22cc				OPCODE_UPPER: equ 111 
22cc				OPCODE_LOWER: equ 112 
22cc				OPCODE_SUBSTR: equ 113 
22cc				OPCODE_LEFT: equ 114 
22cc				OPCODE_RIGHT: equ 115 
22cc				OPCODE_STR2NUM: equ 116 
22cc				OPCODE_NUM2STR: equ 117 
22cc				OPCODE_CONCAT: equ 118 
22cc				OPCODE_FIND: equ 119 
22cc				OPCODE_LEN: equ 120 
22cc				OPCODE_CHAR: equ 121 
22cc			; free to reuse	OPCODE_STRLEN: equ 122 
22cc			; free to reuse	OPCODE_ENDSTR: equ 123 
22cc				OPCODE_V0S: equ 124 
22cc				OPCODE_V0Q: equ 125 
22cc				OPCODE_V1S: equ 126 
22cc				OPCODE_V1Q: equ 127 
22cc				OPCODE_V2S: equ 128 
22cc				OPCODE_V2Q: equ 129 
22cc				OPCODE_V3S: equ 130 
22cc				OPCODE_V3Q: equ 131 
22cc			;free to reuse	OPCODE_END: equ 132 
22cc				OPCODE_ZDUP: equ 133 
22cc			 
22cc			; eof 
# End of file forth_opcodes.asm
22cc			 
22cc			include "forth_words_core.asm" 
22cc			 
22cc			; | ## Core Words 
22cc			 
22cc			;if MALLOC_4 
22cc			 
22cc			.HEAP: 
22cc				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
22cc 15				db WORD_SYS_CORE+OPCODE_HEAP             
22cd 0b 23			dw .EXEC            
22cf 05				db 4 + 1 
22d0 .. 00			db "HEAP",0              
22d5				endm 
# End of macro CWHEAD
22d5			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
22d5			; | | u1 - Current number of bytes in the heap 
22d5			; | | u2 - Remaining bytes left on the heap 
22d5			; | |  
22d5			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
22d5			 
22d5			 
22d5					if DEBUG_FORTH_WORDS_KEY 
22d5						DMARK "HEP" 
22d5 f5				push af  
22d6 3a ea 22			ld a, (.dmark)  
22d9 32 6e fe			ld (debug_mark),a  
22dc 3a eb 22			ld a, (.dmark+1)  
22df 32 6f fe			ld (debug_mark+1),a  
22e2 3a ec 22			ld a, (.dmark+2)  
22e5 32 70 fe			ld (debug_mark+2),a  
22e8 18 03			jr .pastdmark  
22ea ..			.dmark: db "HEP"  
22ed f1			.pastdmark: pop af  
22ee			endm  
# End of macro DMARK
22ee						CALLMONITOR 
22ee cd 9d 17			call break_point_state  
22f1				endm  
# End of macro CALLMONITOR
22f1					endif 
22f1 2a 0a 80				ld hl, (free_list )      
22f4 11 0e 80				ld de, heap_start 
22f7			 
22f7 ed 52				sbc hl, de  
22f9			 
22f9 cd 0b 1e				call forth_push_numhl 
22fc			 
22fc			 
22fc ed 5b 0a 80			ld de, (free_list )      
2300 21 ba f2				ld hl, heap_end 
2303			 
2303 ed 52				sbc hl, de 
2305			 
2305 cd 0b 1e				call forth_push_numhl 
2308					 
2308			 
2308					 
2308			 
2308			 
2308			 
2308					NEXTW 
2308 c3 74 21			jp macro_next 
230b				endm 
# End of macro NEXTW
230b			;endif 
230b			 
230b			.EXEC: 
230b			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
230b			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
230b			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
230b			;; > > 
230b			;; > >   
230b			;	STACKFRAME OFF $5efe $5f9f 
230b			; 
230b			;		if DEBUG_FORTH_WORDS_KEY 
230b			;			DMARK "EXE" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			; 
230b			;	FORTH_DSP_VALUEHL 
230b			; 
230b			;	FORTH_DSP_POP 
230b			; 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EX1" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;;	ld e,(hl) 
230b			;;	inc hl 
230b			;;	ld d,(hl) 
230b			;;	ex de,hl 
230b			; 
230b			;;		if DEBUG_FORTH_WORDS 
230b			;;			DMARK "EX2" 
230b			;;			CALLMONITOR 
230b			;;		endif 
230b			;	push hl 
230b			; 
230b			;	;ld a, 0 
230b			;	;ld a, FORTH_END_BUFFER 
230b			;	call strlenz 
230b			;	inc hl   ; include zero term to copy 
230b			;	inc hl   ; include term 
230b			;	inc hl   ; include term 
230b			;	ld b,0 
230b			;	ld c,l 
230b			;	pop hl 
230b			;	ld de, execscratch 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EX3" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;	ldir 
230b			; 
230b			; 
230b			;	ld hl, execscratch 
230b			; 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EXe" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			; 
230b			;	call forthparse 
230b			;	call forthexec 
230b			;;	call forthexec_cleanup 
230b			;;	call forthparse 
230b			;;	call forthexec 
230b			; 
230b			;	STACKFRAMECHK OFF $5efe $5f9f 
230b			; 
230b			;	; an immediate word so no need to process any more words 
230b			;	ret 
230b			;	NEXTW 
230b			 
230b			; dead code - old version  
230b			;	FORTH_RSP_NEXT 
230b			 
230b			;  
230b			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
230b			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
230b			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
230b			;	push hl 
230b			;	push de 
230b			;	push bc 
230b			; 
230b			; 
230b			;		if DEBUG_FORTH_WORDS_KEY 
230b			;			DMARK "EXR" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			; 
230b			; 
230b			; 
230b			;	;v5 FORTH_DSP_VALUE 
230b			;	FORTH_DSP_VALUEHL 
230b			; 
230b			;	; TODO do string type checks 
230b			; 
230b			;;v5	inc hl   ; skip type 
230b			; 
230b			;	push hl  ; source code  
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EX1" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;	ld a, 0 
230b			;	call strlent 
230b			; 
230b			;	inc hl 
230b			;	inc hl 
230b			;	inc hl 
230b			;	inc hl 
230b			; 
230b			;	push hl    ; size 
230b			; 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EX2" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;	call malloc 
230b			; 
230b			;	ex de, hl    ; de now contains malloc area 
230b			;	pop bc   	; get byte count 
230b			;	pop hl      ; get string to copy 
230b			; 
230b			;	push de     ; save malloc for free later 
230b			; 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EX3" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;	ldir       ; duplicate string 
230b			; 
230b			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
230b			;	 
230b			;	; TODO fix the parse would be better than this...  
230b			;	ex de, hl 
230b			;	dec hl 
230b			;	ld a, 0 
230b			;	ld (hl), a 
230b			;	dec hl 
230b			;	ld a, ' ' 
230b			;	ld (hl), a 
230b			;	dec hl 
230b			;	ld (hl), a 
230b			; 
230b			;	dec hl 
230b			;	ld (hl), a 
230b			; 
230b			; 
230b			;	FORTH_DSP_POP  
230b			; 
230b			;	pop hl     
230b			;	push hl    ; save malloc area 
230b			; 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EX4" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			; 
230b			;	call forthparse 
230b			;	call forthexec 
230b			;	 
230b			;	pop hl 
230b			;	if DEBUG_FORTH_WORDS 
230b			;		DMARK "EX5" 
230b			;		CALLMONITOR 
230b			;	endif 
230b			; 
230b			;	if FORTH_ENABLE_FREE 
230b			;	call free 
230b			;	endif 
230b			; 
230b			;	if DEBUG_FORTH_WORDS 
230b			;		DMARK "EX6" 
230b			;		CALLMONITOR 
230b			;	endif 
230b			; 
230b			;	pop bc 
230b			;	pop de 
230b			;	pop hl 
230b			;;	FORTH_RSP_POP	  
230b			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
230b			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
230b			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
230b			; 
230b			;	if DEBUG_FORTH_WORDS 
230b			;		DMARK "EX7" 
230b			;		CALLMONITOR 
230b			;	endif 
230b			;	NEXTW 
230b			 
230b			;.STKEXEC: 
230b			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
230b			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
230b			; 
230b			; 
230b			;		if DEBUG_FORTH_WORDS_KEY 
230b			;			DMARK "STX" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			; 
230b			;	FORTH_DSP_VALUEHL 
230b			; 
230b			;	ld (store_tmp1), hl    ; count 
230b			; 
230b			;	FORTH_DSP_POP 
230b			;.stkexec1: 
230b			;	ld hl, (store_tmp1)   ; count 
230b			;	ld a, 0 
230b			;	cp l 
230b			;	ret z 
230b			; 
230b			;	dec hl 
230b			;	ld (store_tmp1), hl    ; count 
230b			;	 
230b			;	FORTH_DSP_VALUEHL 
230b			;	push hl 
230b			;	 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EXp" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;	FORTH_DSP_POP 
230b			; 
230b			;	call strlenz 
230b			;	inc hl   ; include zero term to copy 
230b			;	inc hl   ; include zero term to copy 
230b			;	inc hl   ; include zero term to copy 
230b			;	ld b,0 
230b			;	ld c,l 
230b			;	pop hl 
230b			;	ld de, execscratch 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EX3" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;	ldir 
230b			; 
230b			; 
230b			;	ld hl, execscratch 
230b			; 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EXP" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			; 
230b			;	call forthparse 
230b			;	ld hl, execscratch 
230b			;		if DEBUG_FORTH_WORDS 
230b			;			DMARK "EXx" 
230b			;			CALLMONITOR 
230b			;		endif 
230b			;	call forthexec 
230b			; 
230b			;	jp .stkexec1 
230b			; 
230b			;	ret 
230b			 
230b			 
230b			.DUP: 
230b				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
230b 17				db WORD_SYS_CORE+OPCODE_DUP             
230c 81 23			dw .ZDUP            
230e 04				db 3 + 1 
230f .. 00			db "DUP",0              
2313				endm 
# End of macro CWHEAD
2313			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2313			 
2313					if DEBUG_FORTH_WORDS_KEY 
2313						DMARK "DUP" 
2313 f5				push af  
2314 3a 28 23			ld a, (.dmark)  
2317 32 6e fe			ld (debug_mark),a  
231a 3a 29 23			ld a, (.dmark+1)  
231d 32 6f fe			ld (debug_mark+1),a  
2320 3a 2a 23			ld a, (.dmark+2)  
2323 32 70 fe			ld (debug_mark+2),a  
2326 18 03			jr .pastdmark  
2328 ..			.dmark: db "DUP"  
232b f1			.pastdmark: pop af  
232c			endm  
# End of macro DMARK
232c						CALLMONITOR 
232c cd 9d 17			call break_point_state  
232f				endm  
# End of macro CALLMONITOR
232f					endif 
232f			 
232f					FORTH_DSP 
232f cd c8 1f			call macro_forth_dsp 
2332				endm 
# End of macro FORTH_DSP
2332			 
2332 7e					ld a, (HL) 
2333 fe 01				cp DS_TYPE_STR 
2335 20 25				jr nz, .dupinum 
2337			 
2337					; push another string 
2337			 
2337					FORTH_DSP_VALUEHL     		 
2337 cd 02 20			call macro_dsp_valuehl 
233a				endm 
# End of macro FORTH_DSP_VALUEHL
233a			 
233a				if DEBUG_FORTH_WORDS 
233a					DMARK "DUs" 
233a f5				push af  
233b 3a 4f 23			ld a, (.dmark)  
233e 32 6e fe			ld (debug_mark),a  
2341 3a 50 23			ld a, (.dmark+1)  
2344 32 6f fe			ld (debug_mark+1),a  
2347 3a 51 23			ld a, (.dmark+2)  
234a 32 70 fe			ld (debug_mark+2),a  
234d 18 03			jr .pastdmark  
234f ..			.dmark: db "DUs"  
2352 f1			.pastdmark: pop af  
2353			endm  
# End of macro DMARK
2353					CALLMONITOR 
2353 cd 9d 17			call break_point_state  
2356				endm  
# End of macro CALLMONITOR
2356				endif 
2356 cd 79 1e				call forth_push_str 
2359			 
2359					NEXTW 
2359 c3 74 21			jp macro_next 
235c				endm 
# End of macro NEXTW
235c			 
235c			 
235c			.dupinum: 
235c					 
235c			 
235c			 
235c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
235c cd 02 20			call macro_dsp_valuehl 
235f				endm 
# End of macro FORTH_DSP_VALUEHL
235f			 
235f				; TODO add floating point number detection 
235f			 
235f				if DEBUG_FORTH_WORDS 
235f					DMARK "DUi" 
235f f5				push af  
2360 3a 74 23			ld a, (.dmark)  
2363 32 6e fe			ld (debug_mark),a  
2366 3a 75 23			ld a, (.dmark+1)  
2369 32 6f fe			ld (debug_mark+1),a  
236c 3a 76 23			ld a, (.dmark+2)  
236f 32 70 fe			ld (debug_mark+2),a  
2372 18 03			jr .pastdmark  
2374 ..			.dmark: db "DUi"  
2377 f1			.pastdmark: pop af  
2378			endm  
# End of macro DMARK
2378					CALLMONITOR 
2378 cd 9d 17			call break_point_state  
237b				endm  
# End of macro CALLMONITOR
237b				endif 
237b			 
237b cd 0b 1e				call forth_push_numhl 
237e					NEXTW 
237e c3 74 21			jp macro_next 
2381				endm 
# End of macro NEXTW
2381			.ZDUP: 
2381				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2381 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2382 b9 23			dw .SWAP            
2384 05				db 4 + 1 
2385 .. 00			db "?DUP",0              
238a				endm 
# End of macro CWHEAD
238a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
238a			 
238a					if DEBUG_FORTH_WORDS_KEY 
238a						DMARK "qDU" 
238a f5				push af  
238b 3a 9f 23			ld a, (.dmark)  
238e 32 6e fe			ld (debug_mark),a  
2391 3a a0 23			ld a, (.dmark+1)  
2394 32 6f fe			ld (debug_mark+1),a  
2397 3a a1 23			ld a, (.dmark+2)  
239a 32 70 fe			ld (debug_mark+2),a  
239d 18 03			jr .pastdmark  
239f ..			.dmark: db "qDU"  
23a2 f1			.pastdmark: pop af  
23a3			endm  
# End of macro DMARK
23a3						CALLMONITOR 
23a3 cd 9d 17			call break_point_state  
23a6				endm  
# End of macro CALLMONITOR
23a6					endif 
23a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23a6 cd 02 20			call macro_dsp_valuehl 
23a9				endm 
# End of macro FORTH_DSP_VALUEHL
23a9			 
23a9 e5					push hl 
23aa			 
23aa					; is it a zero? 
23aa			 
23aa 3e 00				ld a, 0 
23ac 84					add h 
23ad 85					add l 
23ae			 
23ae e1					pop hl 
23af			 
23af fe 00				cp 0 
23b1 28 03				jr z, .dup2orig 
23b3			 
23b3			 
23b3 cd 0b 1e				call forth_push_numhl 
23b6			 
23b6			 
23b6				; TODO add floating point number detection 
23b6			 
23b6			.dup2orig: 
23b6			 
23b6					NEXTW 
23b6 c3 74 21			jp macro_next 
23b9				endm 
# End of macro NEXTW
23b9			.SWAP: 
23b9				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
23b9 18				db WORD_SYS_CORE+OPCODE_SWAP             
23ba f8 23			dw .COLN            
23bc 05				db 4 + 1 
23bd .. 00			db "SWAP",0              
23c2				endm 
# End of macro CWHEAD
23c2			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
23c2					if DEBUG_FORTH_WORDS_KEY 
23c2						DMARK "SWP" 
23c2 f5				push af  
23c3 3a d7 23			ld a, (.dmark)  
23c6 32 6e fe			ld (debug_mark),a  
23c9 3a d8 23			ld a, (.dmark+1)  
23cc 32 6f fe			ld (debug_mark+1),a  
23cf 3a d9 23			ld a, (.dmark+2)  
23d2 32 70 fe			ld (debug_mark+2),a  
23d5 18 03			jr .pastdmark  
23d7 ..			.dmark: db "SWP"  
23da f1			.pastdmark: pop af  
23db			endm  
# End of macro DMARK
23db						CALLMONITOR 
23db cd 9d 17			call break_point_state  
23de				endm  
# End of macro CALLMONITOR
23de					endif 
23de			 
23de					FORTH_DSP_VALUEHL 
23de cd 02 20			call macro_dsp_valuehl 
23e1				endm 
# End of macro FORTH_DSP_VALUEHL
23e1 e5					push hl     ; w2 
23e2			 
23e2					FORTH_DSP_POP 
23e2 cd ba 20			call macro_forth_dsp_pop 
23e5				endm 
# End of macro FORTH_DSP_POP
23e5			 
23e5					FORTH_DSP_VALUEHL 
23e5 cd 02 20			call macro_dsp_valuehl 
23e8				endm 
# End of macro FORTH_DSP_VALUEHL
23e8			 
23e8					FORTH_DSP_POP 
23e8 cd ba 20			call macro_forth_dsp_pop 
23eb				endm 
# End of macro FORTH_DSP_POP
23eb			 
23eb d1					pop de     ; w2	, hl = w1 
23ec			 
23ec eb					ex de, hl 
23ed d5					push de 
23ee			 
23ee cd 0b 1e				call forth_push_numhl 
23f1			 
23f1 e1					pop hl 
23f2			 
23f2 cd 0b 1e				call forth_push_numhl 
23f5					 
23f5			 
23f5					NEXTW 
23f5 c3 74 21			jp macro_next 
23f8				endm 
# End of macro NEXTW
23f8			.COLN: 
23f8				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
23f8 19				db WORD_SYS_CORE+OPCODE_COLN             
23f9 84 25			dw .SCOLN            
23fb 02				db 1 + 1 
23fc .. 00			db ":",0              
23fe				endm 
# End of macro CWHEAD
23fe			; | : ( -- )         Create new word | DONE 
23fe			 
23fe					if DEBUG_FORTH_WORDS_KEY 
23fe						DMARK "CLN" 
23fe f5				push af  
23ff 3a 13 24			ld a, (.dmark)  
2402 32 6e fe			ld (debug_mark),a  
2405 3a 14 24			ld a, (.dmark+1)  
2408 32 6f fe			ld (debug_mark+1),a  
240b 3a 15 24			ld a, (.dmark+2)  
240e 32 70 fe			ld (debug_mark+2),a  
2411 18 03			jr .pastdmark  
2413 ..			.dmark: db "CLN"  
2416 f1			.pastdmark: pop af  
2417			endm  
# End of macro DMARK
2417						CALLMONITOR 
2417 cd 9d 17			call break_point_state  
241a				endm  
# End of macro CALLMONITOR
241a					endif 
241a				STACKFRAME OFF $8efe $989f 
241a				if DEBUG_STACK_IMB 
241a					if OFF 
241a						exx 
241a						ld de, $8efe 
241a						ld a, d 
241a						ld hl, curframe 
241a						call hexout 
241a						ld a, e 
241a						ld hl, curframe+2 
241a						call hexout 
241a						ld hl, $8efe 
241a						push hl 
241a						ld hl, $989f 
241a						push hl 
241a						exx 
241a					endif 
241a				endif 
241a			endm 
# End of macro STACKFRAME
241a				; get parser buffer length  of new word 
241a			 
241a				 
241a			 
241a					; move tok past this to start of name defintition 
241a					; TODO get word to define 
241a					; TODO Move past word token 
241a					; TODO get length of string up to the ';' 
241a			 
241a 2a d5 f5			ld hl, (os_tok_ptr) 
241d 23				inc hl 
241e 23				inc hl 
241f			 
241f 3e 3b			ld a, ';' 
2421 cd 5f 12			call strlent 
2424			 
2424 7d				ld a,l 
2425 32 d0 f2			ld (os_new_parse_len), a 
2428			 
2428			 
2428			if DEBUG_FORTH_UWORD 
2428 ed 5b d5 f5		ld de, (os_tok_ptr) 
242c						DMARK ":01" 
242c f5				push af  
242d 3a 41 24			ld a, (.dmark)  
2430 32 6e fe			ld (debug_mark),a  
2433 3a 42 24			ld a, (.dmark+1)  
2436 32 6f fe			ld (debug_mark+1),a  
2439 3a 43 24			ld a, (.dmark+2)  
243c 32 70 fe			ld (debug_mark+2),a  
243f 18 03			jr .pastdmark  
2441 ..			.dmark: db ":01"  
2444 f1			.pastdmark: pop af  
2445			endm  
# End of macro DMARK
2445				CALLMONITOR 
2445 cd 9d 17			call break_point_state  
2448				endm  
# End of macro CALLMONITOR
2448			endif 
2448			 
2448			; 
2448			;  new word memory layout: 
2448			;  
2448			;    : adg 6666 ;  
2448			; 
2448			;    db   1     ; user defined word  
2448 23				inc hl    
2449			;    dw   sysdict 
2449 23				inc hl 
244a 23				inc hl 
244b			;    db <word len>+1 (for null) 
244b 23				inc hl 
244c			;    db .... <word> 
244c			; 
244c			 
244c 23				inc hl    ; some extras for the word preamble before the above 
244d 23				inc hl 
244e 23				inc hl 
244f 23				inc hl 
2450 23				inc hl 
2451 23				inc hl 
2452 23				inc hl  
2453 23				inc hl 
2454 23				inc hl 
2455 23				inc hl 
2456 23				inc hl 
2457 23				inc hl 
2458 23				inc hl 
2459 23				inc hl     ; TODO how many do we really need?     maybe only 6 
245a			;       exec word buffer 
245a			;	<ptr word>   
245a 23				inc hl 
245b 23				inc hl 
245c			;       <word list><null term> 7F final term 
245c			 
245c			 
245c			if DEBUG_FORTH_UWORD 
245c						DMARK ":02" 
245c f5				push af  
245d 3a 71 24			ld a, (.dmark)  
2460 32 6e fe			ld (debug_mark),a  
2463 3a 72 24			ld a, (.dmark+1)  
2466 32 6f fe			ld (debug_mark+1),a  
2469 3a 73 24			ld a, (.dmark+2)  
246c 32 70 fe			ld (debug_mark+2),a  
246f 18 03			jr .pastdmark  
2471 ..			.dmark: db ":02"  
2474 f1			.pastdmark: pop af  
2475			endm  
# End of macro DMARK
2475				CALLMONITOR 
2475 cd 9d 17			call break_point_state  
2478				endm  
# End of macro CALLMONITOR
2478			endif 
2478			 
2478				 
2478					; malloc the size 
2478			 
2478 cd bd 12				call malloc 
247b 22 d2 f2				ld (os_new_malloc), hl     ; save malloc start 
247e			 
247e			;    db   1     ; user defined word  
247e 3e 01				ld a, WORD_SYS_UWORD  
2480 77					ld (hl), a 
2481				 
2481 23				inc hl    
2482			;    dw   sysdict 
2482 11 cc 22			ld de, sysdict       ; continue on with the scan to the system dict 
2485 73				ld (hl), e 
2486 23				inc hl 
2487 72				ld (hl), d 
2488 23				inc hl 
2489			 
2489			 
2489			;    Setup dict word 
2489			 
2489 23				inc hl 
248a 22 cc f2			ld (os_new_work_ptr), hl     ; save start of dict word  
248d			 
248d				; 1. get length of dict word 
248d			 
248d			 
248d 2a d5 f5			ld hl, (os_tok_ptr) 
2490 23				inc hl 
2491 23				inc hl    ; position to start of dict word 
2492 3e 00			ld a, 0 
2494 cd 5f 12			call strlent 
2497			 
2497			 
2497 23				inc hl    ; to include null??? 
2498			 
2498				; write length of dict word 
2498			 
2498 ed 5b cc f2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
249c 1b				dec de 
249d eb				ex de, hl 
249e 73				ld (hl), e 
249f eb				ex de, hl 
24a0			 
24a0				 
24a0			 
24a0				; copy  
24a0 4d				ld c, l 
24a1 06 00			ld b, 0 
24a3 ed 5b cc f2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
24a7 2a d5 f5			ld hl, (os_tok_ptr) 
24aa 23				inc hl 
24ab 23				inc hl    ; position to start of dict word 
24ac				 
24ac			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
24ac				 
24ac				; TODO need to convert word to upper case 
24ac			 
24ac			ucasetok:	 
24ac 7e				ld a,(hl) 
24ad cd 4b 12			call toUpper 
24b0 77				ld (hl),a 
24b1 ed a0			ldi 
24b3 f2 ac 24		 	jp p, ucasetok 
24b6			 
24b6			 
24b6			 
24b6				; de now points to start of where the word body code should be placed 
24b6 ed 53 cc f2		ld (os_new_work_ptr), de 
24ba				; hl now points to the words to throw at forthexec which needs to be copied 
24ba 22 ca f2			ld (os_new_src_ptr), hl 
24bd			 
24bd				; TODO add 'call to forthexec' 
24bd			 
24bd			if DEBUG_FORTH_UWORD 
24bd c5				push bc 
24be ed 4b d2 f2		ld bc, (os_new_malloc) 
24c2						DMARK ":0x" 
24c2 f5				push af  
24c3 3a d7 24			ld a, (.dmark)  
24c6 32 6e fe			ld (debug_mark),a  
24c9 3a d8 24			ld a, (.dmark+1)  
24cc 32 6f fe			ld (debug_mark+1),a  
24cf 3a d9 24			ld a, (.dmark+2)  
24d2 32 70 fe			ld (debug_mark+2),a  
24d5 18 03			jr .pastdmark  
24d7 ..			.dmark: db ":0x"  
24da f1			.pastdmark: pop af  
24db			endm  
# End of macro DMARK
24db				CALLMONITOR 
24db cd 9d 17			call break_point_state  
24de				endm  
# End of macro CALLMONITOR
24de c1				pop bc 
24df			endif 
24df			 
24df			 
24df				; create word preamble which should be: 
24df			 
24df			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
24df			 
24df				;    ld hl, <word code> 
24df				;    jp user_exec 
24df			        ;    <word code bytes> 
24df			 
24df			 
24df			;	inc de     ; TODO ??? or are we already past the word's null 
24df eb				ex de, hl 
24e0			 
24e0 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
24e2			 
24e2 23				inc hl 
24e3 22 c6 f2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
24e6 23				inc hl 
24e7			 
24e7 23				inc hl 
24e8 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
24ea			 
24ea 01 20 53			ld bc, user_exec 
24ed 23				inc hl 
24ee 71				ld (hl), c     ; poke address of user_exec 
24ef 23				inc hl 
24f0 70				ld (hl), b     
24f1			 ; 
24f1			;	inc hl 
24f1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24f1			; 
24f1			; 
24f1			;	ld bc, macro_forth_rsp_next 
24f1			;	inc hl 
24f1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
24f1			;	inc hl 
24f1			;	ld (hl), b     
24f1			 ; 
24f1			;	inc hl 
24f1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24f1			; 
24f1			; 
24f1			;	inc hl 
24f1			;	ld bc, forthexec 
24f1			;	ld (hl), c     ; poke address of forthexec 
24f1			;	inc hl 
24f1			;	ld (hl), b      
24f1			; 
24f1			;	inc hl 
24f1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
24f1			; 
24f1			;	ld bc, user_dict_next 
24f1			;	inc hl 
24f1			;	ld (hl), c     ; poke address of forthexec 
24f1			;	inc hl 
24f1			;	ld (hl), b      
24f1			 
24f1				; hl is now where we need to copy the word byte data to save this 
24f1			 
24f1 23				inc hl 
24f2 22 c8 f2			ld (os_new_exec), hl 
24f5				 
24f5				; copy definition 
24f5			 
24f5 eb				ex de, hl 
24f6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
24f6			;	inc de    ; skip the PC for this parse 
24f6 3a d0 f2			ld a, (os_new_parse_len) 
24f9 4f				ld c, a 
24fa 06 00			ld b, 0 
24fc ed b0			ldir		 ; copy defintion 
24fe			 
24fe			 
24fe				; poke the address of where the new word bytes live for forthexec 
24fe			 
24fe 2a c6 f2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2501			 
2501 ed 5b c8 f2		ld de, (os_new_exec)      
2505				 
2505 73				ld (hl), e 
2506 23				inc hl 
2507 72				ld (hl), d 
2508			 
2508					; TODO copy last user dict word next link to this word 
2508					; TODO update last user dict word to point to this word 
2508			; 
2508			; hl f923 de 812a ; bc 811a 
2508			 
2508			if DEBUG_FORTH_UWORD 
2508 c5				push bc 
2509 ed 4b d2 f2		ld bc, (os_new_malloc) 
250d						DMARK ":0A" 
250d f5				push af  
250e 3a 22 25			ld a, (.dmark)  
2511 32 6e fe			ld (debug_mark),a  
2514 3a 23 25			ld a, (.dmark+1)  
2517 32 6f fe			ld (debug_mark+1),a  
251a 3a 24 25			ld a, (.dmark+2)  
251d 32 70 fe			ld (debug_mark+2),a  
2520 18 03			jr .pastdmark  
2522 ..			.dmark: db ":0A"  
2525 f1			.pastdmark: pop af  
2526			endm  
# End of macro DMARK
2526				CALLMONITOR 
2526 cd 9d 17			call break_point_state  
2529				endm  
# End of macro CALLMONITOR
2529 c1				pop bc 
252a			endif 
252a			if DEBUG_FORTH_UWORD 
252a c5				push bc 
252b ed 4b d2 f2		ld bc, (os_new_malloc) 
252f 03				inc bc 
2530 03				inc bc 
2531 03				inc bc 
2532 03				inc bc 
2533 03				inc bc 
2534 03				inc bc 
2535 03				inc bc 
2536 03				inc bc 
2537			 
2537						DMARK ":0B" 
2537 f5				push af  
2538 3a 4c 25			ld a, (.dmark)  
253b 32 6e fe			ld (debug_mark),a  
253e 3a 4d 25			ld a, (.dmark+1)  
2541 32 6f fe			ld (debug_mark+1),a  
2544 3a 4e 25			ld a, (.dmark+2)  
2547 32 70 fe			ld (debug_mark+2),a  
254a 18 03			jr .pastdmark  
254c ..			.dmark: db ":0B"  
254f f1			.pastdmark: pop af  
2550			endm  
# End of macro DMARK
2550				CALLMONITOR 
2550 cd 9d 17			call break_point_state  
2553				endm  
# End of macro CALLMONITOR
2553 c1				pop bc 
2554			endif 
2554			 
2554			; update word dict linked list for new word 
2554			 
2554			 
2554 2a d1 f5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2557 23			inc hl     ; move to next work linked list ptr 
2558			 
2558 ed 5b d2 f2	ld de, (os_new_malloc)		 ; new next word 
255c 73			ld (hl), e 
255d 23			inc hl 
255e 72			ld (hl), d 
255f			 
255f			if DEBUG_FORTH_UWORD 
255f ed 4b d1 f5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2563			endif 
2563			 
2563 ed 53 d1 f5	ld (os_last_new_uword), de      ; update last new uword ptr 
2567			 
2567			 
2567			if DEBUG_FORTH_UWORD 
2567						DMARK ":0+" 
2567 f5				push af  
2568 3a 7c 25			ld a, (.dmark)  
256b 32 6e fe			ld (debug_mark),a  
256e 3a 7d 25			ld a, (.dmark+1)  
2571 32 6f fe			ld (debug_mark+1),a  
2574 3a 7e 25			ld a, (.dmark+2)  
2577 32 70 fe			ld (debug_mark+2),a  
257a 18 03			jr .pastdmark  
257c ..			.dmark: db ":0+"  
257f f1			.pastdmark: pop af  
2580			endm  
# End of macro DMARK
2580				CALLMONITOR 
2580 cd 9d 17			call break_point_state  
2583				endm  
# End of macro CALLMONITOR
2583			endif 
2583			 
2583				STACKFRAMECHK OFF $8efe $989f 
2583				if DEBUG_STACK_IMB 
2583					if OFF 
2583						exx 
2583						ld hl, $989f 
2583						pop de   ; $989f 
2583						call cmp16 
2583						jr nz, .spnosame 
2583						ld hl, $8efe 
2583						pop de   ; $8efe 
2583						call cmp16 
2583						jr z, .spfrsame 
2583						.spnosame: call showsperror 
2583						.spfrsame: nop 
2583						exx 
2583					endif 
2583				endif 
2583			endm 
# End of macro STACKFRAMECHK
2583			 
2583 c9			ret    ; dont process any remaining parser tokens as they form new word 
2584			 
2584			 
2584			 
2584			 
2584			;		NEXT 
2584			.SCOLN: 
2584			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2584 06				db OPCODE_SCOLN 
2585 d0 25			dw .DROP 
2587 02				db 2 
2588 .. 00			db ";",0           
258a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
258a					if DEBUG_FORTH_WORDS_KEY 
258a						DMARK "SCN" 
258a f5				push af  
258b 3a 9f 25			ld a, (.dmark)  
258e 32 6e fe			ld (debug_mark),a  
2591 3a a0 25			ld a, (.dmark+1)  
2594 32 6f fe			ld (debug_mark+1),a  
2597 3a a1 25			ld a, (.dmark+2)  
259a 32 70 fe			ld (debug_mark+2),a  
259d 18 03			jr .pastdmark  
259f ..			.dmark: db "SCN"  
25a2 f1			.pastdmark: pop af  
25a3			endm  
# End of macro DMARK
25a3						CALLMONITOR 
25a3 cd 9d 17			call break_point_state  
25a6				endm  
# End of macro CALLMONITOR
25a6					endif 
25a6					FORTH_RSP_TOS 
25a6 cd c9 1d			call macro_forth_rsp_tos 
25a9				endm 
# End of macro FORTH_RSP_TOS
25a9 e5					push hl 
25aa					FORTH_RSP_POP 
25aa cd d3 1d			call macro_forth_rsp_pop 
25ad				endm 
# End of macro FORTH_RSP_POP
25ad e1					pop hl 
25ae			;		ex de,hl 
25ae 22 d5 f5				ld (os_tok_ptr),hl 
25b1			 
25b1			if DEBUG_FORTH_UWORD 
25b1						DMARK "SCL" 
25b1 f5				push af  
25b2 3a c6 25			ld a, (.dmark)  
25b5 32 6e fe			ld (debug_mark),a  
25b8 3a c7 25			ld a, (.dmark+1)  
25bb 32 6f fe			ld (debug_mark+1),a  
25be 3a c8 25			ld a, (.dmark+2)  
25c1 32 70 fe			ld (debug_mark+2),a  
25c4 18 03			jr .pastdmark  
25c6 ..			.dmark: db "SCL"  
25c9 f1			.pastdmark: pop af  
25ca			endm  
# End of macro DMARK
25ca				CALLMONITOR 
25ca cd 9d 17			call break_point_state  
25cd				endm  
# End of macro CALLMONITOR
25cd			endif 
25cd					NEXTW 
25cd c3 74 21			jp macro_next 
25d0				endm 
# End of macro NEXTW
25d0			 
25d0			.DROP: 
25d0				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
25d0 1b				db WORD_SYS_CORE+OPCODE_DROP             
25d1 fb 25			dw .DUP2            
25d3 05				db 4 + 1 
25d4 .. 00			db "DROP",0              
25d9				endm 
# End of macro CWHEAD
25d9			; | DROP ( w -- )   drop the TOS item   | DONE 
25d9					if DEBUG_FORTH_WORDS_KEY 
25d9						DMARK "DRP" 
25d9 f5				push af  
25da 3a ee 25			ld a, (.dmark)  
25dd 32 6e fe			ld (debug_mark),a  
25e0 3a ef 25			ld a, (.dmark+1)  
25e3 32 6f fe			ld (debug_mark+1),a  
25e6 3a f0 25			ld a, (.dmark+2)  
25e9 32 70 fe			ld (debug_mark+2),a  
25ec 18 03			jr .pastdmark  
25ee ..			.dmark: db "DRP"  
25f1 f1			.pastdmark: pop af  
25f2			endm  
# End of macro DMARK
25f2						CALLMONITOR 
25f2 cd 9d 17			call break_point_state  
25f5				endm  
# End of macro CALLMONITOR
25f5					endif 
25f5					FORTH_DSP_POP 
25f5 cd ba 20			call macro_forth_dsp_pop 
25f8				endm 
# End of macro FORTH_DSP_POP
25f8					NEXTW 
25f8 c3 74 21			jp macro_next 
25fb				endm 
# End of macro NEXTW
25fb			.DUP2: 
25fb				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
25fb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
25fc 40 26			dw .DROP2            
25fe 05				db 4 + 1 
25ff .. 00			db "2DUP",0              
2604				endm 
# End of macro CWHEAD
2604			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2604					if DEBUG_FORTH_WORDS_KEY 
2604						DMARK "2DU" 
2604 f5				push af  
2605 3a 19 26			ld a, (.dmark)  
2608 32 6e fe			ld (debug_mark),a  
260b 3a 1a 26			ld a, (.dmark+1)  
260e 32 6f fe			ld (debug_mark+1),a  
2611 3a 1b 26			ld a, (.dmark+2)  
2614 32 70 fe			ld (debug_mark+2),a  
2617 18 03			jr .pastdmark  
2619 ..			.dmark: db "2DU"  
261c f1			.pastdmark: pop af  
261d			endm  
# End of macro DMARK
261d						CALLMONITOR 
261d cd 9d 17			call break_point_state  
2620				endm  
# End of macro CALLMONITOR
2620					endif 
2620					FORTH_DSP_VALUEHL 
2620 cd 02 20			call macro_dsp_valuehl 
2623				endm 
# End of macro FORTH_DSP_VALUEHL
2623 e5					push hl      ; 2 
2624			 
2624					FORTH_DSP_POP 
2624 cd ba 20			call macro_forth_dsp_pop 
2627				endm 
# End of macro FORTH_DSP_POP
2627					 
2627					FORTH_DSP_VALUEHL 
2627 cd 02 20			call macro_dsp_valuehl 
262a				endm 
# End of macro FORTH_DSP_VALUEHL
262a			;		push hl      ; 1 
262a			 
262a					FORTH_DSP_POP 
262a cd ba 20			call macro_forth_dsp_pop 
262d				endm 
# End of macro FORTH_DSP_POP
262d			 
262d			;		pop hl       ; 1 
262d d1					pop de       ; 2 
262e			 
262e cd 0b 1e				call forth_push_numhl 
2631 eb					ex de, hl 
2632 cd 0b 1e				call forth_push_numhl 
2635			 
2635					 
2635 eb					ex de, hl 
2636			 
2636 cd 0b 1e				call forth_push_numhl 
2639 eb					ex de, hl 
263a cd 0b 1e				call forth_push_numhl 
263d			 
263d			 
263d					NEXTW 
263d c3 74 21			jp macro_next 
2640				endm 
# End of macro NEXTW
2640			.DROP2: 
2640				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2640 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2641 6f 26			dw .SWAP2            
2643 06				db 5 + 1 
2644 .. 00			db "2DROP",0              
264a				endm 
# End of macro CWHEAD
264a			; | 2DROP ( w w -- )    Double drop | DONE 
264a					if DEBUG_FORTH_WORDS_KEY 
264a						DMARK "2DR" 
264a f5				push af  
264b 3a 5f 26			ld a, (.dmark)  
264e 32 6e fe			ld (debug_mark),a  
2651 3a 60 26			ld a, (.dmark+1)  
2654 32 6f fe			ld (debug_mark+1),a  
2657 3a 61 26			ld a, (.dmark+2)  
265a 32 70 fe			ld (debug_mark+2),a  
265d 18 03			jr .pastdmark  
265f ..			.dmark: db "2DR"  
2662 f1			.pastdmark: pop af  
2663			endm  
# End of macro DMARK
2663						CALLMONITOR 
2663 cd 9d 17			call break_point_state  
2666				endm  
# End of macro CALLMONITOR
2666					endif 
2666					FORTH_DSP_POP 
2666 cd ba 20			call macro_forth_dsp_pop 
2669				endm 
# End of macro FORTH_DSP_POP
2669					FORTH_DSP_POP 
2669 cd ba 20			call macro_forth_dsp_pop 
266c				endm 
# End of macro FORTH_DSP_POP
266c					NEXTW 
266c c3 74 21			jp macro_next 
266f				endm 
# End of macro NEXTW
266f			.SWAP2: 
266f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
266f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2670 98 26			dw .AT            
2672 06				db 5 + 1 
2673 .. 00			db "2SWAP",0              
2679				endm 
# End of macro CWHEAD
2679			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2679					if DEBUG_FORTH_WORDS_KEY 
2679						DMARK "2SW" 
2679 f5				push af  
267a 3a 8e 26			ld a, (.dmark)  
267d 32 6e fe			ld (debug_mark),a  
2680 3a 8f 26			ld a, (.dmark+1)  
2683 32 6f fe			ld (debug_mark+1),a  
2686 3a 90 26			ld a, (.dmark+2)  
2689 32 70 fe			ld (debug_mark+2),a  
268c 18 03			jr .pastdmark  
268e ..			.dmark: db "2SW"  
2691 f1			.pastdmark: pop af  
2692			endm  
# End of macro DMARK
2692						CALLMONITOR 
2692 cd 9d 17			call break_point_state  
2695				endm  
# End of macro CALLMONITOR
2695					endif 
2695					NEXTW 
2695 c3 74 21			jp macro_next 
2698				endm 
# End of macro NEXTW
2698			.AT: 
2698				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2698 1f				db WORD_SYS_CORE+OPCODE_AT             
2699 ca 26			dw .CAT            
269b 02				db 1 + 1 
269c .. 00			db "@",0              
269e				endm 
# End of macro CWHEAD
269e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
269e			 
269e					if DEBUG_FORTH_WORDS_KEY 
269e						DMARK "AT." 
269e f5				push af  
269f 3a b3 26			ld a, (.dmark)  
26a2 32 6e fe			ld (debug_mark),a  
26a5 3a b4 26			ld a, (.dmark+1)  
26a8 32 6f fe			ld (debug_mark+1),a  
26ab 3a b5 26			ld a, (.dmark+2)  
26ae 32 70 fe			ld (debug_mark+2),a  
26b1 18 03			jr .pastdmark  
26b3 ..			.dmark: db "AT."  
26b6 f1			.pastdmark: pop af  
26b7			endm  
# End of macro DMARK
26b7						CALLMONITOR 
26b7 cd 9d 17			call break_point_state  
26ba				endm  
# End of macro CALLMONITOR
26ba					endif 
26ba			.getbyteat:	 
26ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ba cd 02 20			call macro_dsp_valuehl 
26bd				endm 
# End of macro FORTH_DSP_VALUEHL
26bd					 
26bd			;		push hl 
26bd				 
26bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26bd cd ba 20			call macro_forth_dsp_pop 
26c0				endm 
# End of macro FORTH_DSP_POP
26c0			 
26c0			;		pop hl 
26c0			 
26c0 7e					ld a, (hl) 
26c1			 
26c1 6f					ld l, a 
26c2 26 00				ld h, 0 
26c4 cd 0b 1e				call forth_push_numhl 
26c7			 
26c7					NEXTW 
26c7 c3 74 21			jp macro_next 
26ca				endm 
# End of macro NEXTW
26ca			.CAT: 
26ca				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
26ca 20				db WORD_SYS_CORE+OPCODE_CAT             
26cb f3 26			dw .BANG            
26cd 03				db 2 + 1 
26ce .. 00			db "C@",0              
26d1				endm 
# End of macro CWHEAD
26d1			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
26d1					if DEBUG_FORTH_WORDS_KEY 
26d1						DMARK "CAA" 
26d1 f5				push af  
26d2 3a e6 26			ld a, (.dmark)  
26d5 32 6e fe			ld (debug_mark),a  
26d8 3a e7 26			ld a, (.dmark+1)  
26db 32 6f fe			ld (debug_mark+1),a  
26de 3a e8 26			ld a, (.dmark+2)  
26e1 32 70 fe			ld (debug_mark+2),a  
26e4 18 03			jr .pastdmark  
26e6 ..			.dmark: db "CAA"  
26e9 f1			.pastdmark: pop af  
26ea			endm  
# End of macro DMARK
26ea						CALLMONITOR 
26ea cd 9d 17			call break_point_state  
26ed				endm  
# End of macro CALLMONITOR
26ed					endif 
26ed c3 ba 26				jp .getbyteat 
26f0					NEXTW 
26f0 c3 74 21			jp macro_next 
26f3				endm 
# End of macro NEXTW
26f3			.BANG: 
26f3				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
26f3 21				db WORD_SYS_CORE+OPCODE_BANG             
26f4 29 27			dw .CBANG            
26f6 02				db 1 + 1 
26f7 .. 00			db "!",0              
26f9				endm 
# End of macro CWHEAD
26f9			; | ! ( x w -- ) Store x at address w      | DONE 
26f9					if DEBUG_FORTH_WORDS_KEY 
26f9						DMARK "BNG" 
26f9 f5				push af  
26fa 3a 0e 27			ld a, (.dmark)  
26fd 32 6e fe			ld (debug_mark),a  
2700 3a 0f 27			ld a, (.dmark+1)  
2703 32 6f fe			ld (debug_mark+1),a  
2706 3a 10 27			ld a, (.dmark+2)  
2709 32 70 fe			ld (debug_mark+2),a  
270c 18 03			jr .pastdmark  
270e ..			.dmark: db "BNG"  
2711 f1			.pastdmark: pop af  
2712			endm  
# End of macro DMARK
2712						CALLMONITOR 
2712 cd 9d 17			call break_point_state  
2715				endm  
# End of macro CALLMONITOR
2715					endif 
2715			 
2715			.storebyteat:		 
2715					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2715 cd 02 20			call macro_dsp_valuehl 
2718				endm 
# End of macro FORTH_DSP_VALUEHL
2718					 
2718 e5					push hl 
2719				 
2719					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2719 cd ba 20			call macro_forth_dsp_pop 
271c				endm 
# End of macro FORTH_DSP_POP
271c			 
271c					; get byte to poke 
271c			 
271c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
271c cd 02 20			call macro_dsp_valuehl 
271f				endm 
# End of macro FORTH_DSP_VALUEHL
271f e5					push hl 
2720			 
2720			 
2720					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2720 cd ba 20			call macro_forth_dsp_pop 
2723				endm 
# End of macro FORTH_DSP_POP
2723			 
2723			 
2723 d1					pop de 
2724 e1					pop hl 
2725			 
2725 73					ld (hl),e 
2726			 
2726			 
2726					NEXTW 
2726 c3 74 21			jp macro_next 
2729				endm 
# End of macro NEXTW
2729			.CBANG: 
2729				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2729 22				db WORD_SYS_CORE+OPCODE_CBANG             
272a 52 27			dw .SCALL            
272c 03				db 2 + 1 
272d .. 00			db "C!",0              
2730				endm 
# End of macro CWHEAD
2730			; | C!  ( x w -- ) Store x at address w  | DONE 
2730					if DEBUG_FORTH_WORDS_KEY 
2730						DMARK "CBA" 
2730 f5				push af  
2731 3a 45 27			ld a, (.dmark)  
2734 32 6e fe			ld (debug_mark),a  
2737 3a 46 27			ld a, (.dmark+1)  
273a 32 6f fe			ld (debug_mark+1),a  
273d 3a 47 27			ld a, (.dmark+2)  
2740 32 70 fe			ld (debug_mark+2),a  
2743 18 03			jr .pastdmark  
2745 ..			.dmark: db "CBA"  
2748 f1			.pastdmark: pop af  
2749			endm  
# End of macro DMARK
2749						CALLMONITOR 
2749 cd 9d 17			call break_point_state  
274c				endm  
# End of macro CALLMONITOR
274c					endif 
274c c3 15 27				jp .storebyteat 
274f					NEXTW 
274f c3 74 21			jp macro_next 
2752				endm 
# End of macro NEXTW
2752			.SCALL: 
2752				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2752 23				db WORD_SYS_CORE+OPCODE_SCALL             
2753 86 27			dw .DEPTH            
2755 05				db 4 + 1 
2756 .. 00			db "CALL",0              
275b				endm 
# End of macro CWHEAD
275b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
275b					if DEBUG_FORTH_WORDS_KEY 
275b						DMARK "CLL" 
275b f5				push af  
275c 3a 70 27			ld a, (.dmark)  
275f 32 6e fe			ld (debug_mark),a  
2762 3a 71 27			ld a, (.dmark+1)  
2765 32 6f fe			ld (debug_mark+1),a  
2768 3a 72 27			ld a, (.dmark+2)  
276b 32 70 fe			ld (debug_mark+2),a  
276e 18 03			jr .pastdmark  
2770 ..			.dmark: db "CLL"  
2773 f1			.pastdmark: pop af  
2774			endm  
# End of macro DMARK
2774						CALLMONITOR 
2774 cd 9d 17			call break_point_state  
2777				endm  
# End of macro CALLMONITOR
2777					endif 
2777			 
2777					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2777 cd 02 20			call macro_dsp_valuehl 
277a				endm 
# End of macro FORTH_DSP_VALUEHL
277a			 
277a			;		push hl 
277a			 
277a					; destroy value TOS 
277a			 
277a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
277a cd ba 20			call macro_forth_dsp_pop 
277d				endm 
# End of macro FORTH_DSP_POP
277d			 
277d						 
277d			;		pop hl 
277d			 
277d					; how to do a call with hl???? save SP? 
277d cd 1d 21				call forth_call_hl 
2780			 
2780			 
2780					; TODO push value back onto stack for another op etc 
2780			 
2780 cd 0b 1e				call forth_push_numhl 
2783					NEXTW 
2783 c3 74 21			jp macro_next 
2786				endm 
# End of macro NEXTW
2786			.DEPTH: 
2786				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2786 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2787 c3 27			dw .OVER            
2789 06				db 5 + 1 
278a .. 00			db "DEPTH",0              
2790				endm 
# End of macro CWHEAD
2790			; | DEPTH ( -- u ) Push count of stack | DONE 
2790					; take current TOS and remove from base value div by two to get count 
2790					if DEBUG_FORTH_WORDS_KEY 
2790						DMARK "DEP" 
2790 f5				push af  
2791 3a a5 27			ld a, (.dmark)  
2794 32 6e fe			ld (debug_mark),a  
2797 3a a6 27			ld a, (.dmark+1)  
279a 32 6f fe			ld (debug_mark+1),a  
279d 3a a7 27			ld a, (.dmark+2)  
27a0 32 70 fe			ld (debug_mark+2),a  
27a3 18 03			jr .pastdmark  
27a5 ..			.dmark: db "DEP"  
27a8 f1			.pastdmark: pop af  
27a9			endm  
# End of macro DMARK
27a9						CALLMONITOR 
27a9 cd 9d 17			call break_point_state  
27ac				endm  
# End of macro CALLMONITOR
27ac					endif 
27ac			 
27ac			 
27ac 2a 01 fb			ld hl, (cli_data_sp) 
27af 11 3b f8			ld de, cli_data_stack 
27b2 ed 52			sbc hl,de 
27b4				 
27b4				; div by size of stack item 
27b4			 
27b4 5d				ld e,l 
27b5 0e 03			ld c, 3 
27b7 cd 86 0d			call Div8 
27ba			 
27ba 6f				ld l,a 
27bb 26 00			ld h,0 
27bd			 
27bd				;srl h 
27bd				;rr l 
27bd			 
27bd cd 0b 1e				call forth_push_numhl 
27c0					NEXTW 
27c0 c3 74 21			jp macro_next 
27c3				endm 
# End of macro NEXTW
27c3			.OVER: 
27c3				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
27c3 42				db WORD_SYS_CORE+46             
27c4 0a 28			dw .PAUSE            
27c6 05				db 4 + 1 
27c7 .. 00			db "OVER",0              
27cc				endm 
# End of macro CWHEAD
27cc			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
27cc					if DEBUG_FORTH_WORDS_KEY 
27cc						DMARK "OVR" 
27cc f5				push af  
27cd 3a e1 27			ld a, (.dmark)  
27d0 32 6e fe			ld (debug_mark),a  
27d3 3a e2 27			ld a, (.dmark+1)  
27d6 32 6f fe			ld (debug_mark+1),a  
27d9 3a e3 27			ld a, (.dmark+2)  
27dc 32 70 fe			ld (debug_mark+2),a  
27df 18 03			jr .pastdmark  
27e1 ..			.dmark: db "OVR"  
27e4 f1			.pastdmark: pop af  
27e5			endm  
# End of macro DMARK
27e5						CALLMONITOR 
27e5 cd 9d 17			call break_point_state  
27e8				endm  
# End of macro CALLMONITOR
27e8					endif 
27e8			 
27e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27e8 cd 02 20			call macro_dsp_valuehl 
27eb				endm 
# End of macro FORTH_DSP_VALUEHL
27eb e5					push hl    ; n2 
27ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27ec cd ba 20			call macro_forth_dsp_pop 
27ef				endm 
# End of macro FORTH_DSP_POP
27ef			 
27ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ef cd 02 20			call macro_dsp_valuehl 
27f2				endm 
# End of macro FORTH_DSP_VALUEHL
27f2 e5					push hl    ; n1 
27f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27f3 cd ba 20			call macro_forth_dsp_pop 
27f6				endm 
# End of macro FORTH_DSP_POP
27f6			 
27f6 d1					pop de     ; n1 
27f7 e1					pop hl     ; n2 
27f8			 
27f8 d5					push de 
27f9 e5					push hl 
27fa d5					push de 
27fb			 
27fb					; push back  
27fb			 
27fb e1					pop hl 
27fc cd 0b 1e				call forth_push_numhl 
27ff e1					pop hl 
2800 cd 0b 1e				call forth_push_numhl 
2803 e1					pop hl 
2804 cd 0b 1e				call forth_push_numhl 
2807					NEXTW 
2807 c3 74 21			jp macro_next 
280a				endm 
# End of macro NEXTW
280a			 
280a			.PAUSE: 
280a				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
280a 43				db WORD_SYS_CORE+47             
280b 3f 28			dw .PAUSES            
280d 08				db 7 + 1 
280e .. 00			db "PAUSEMS",0              
2816				endm 
# End of macro CWHEAD
2816			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2816					if DEBUG_FORTH_WORDS_KEY 
2816						DMARK "PMS" 
2816 f5				push af  
2817 3a 2b 28			ld a, (.dmark)  
281a 32 6e fe			ld (debug_mark),a  
281d 3a 2c 28			ld a, (.dmark+1)  
2820 32 6f fe			ld (debug_mark+1),a  
2823 3a 2d 28			ld a, (.dmark+2)  
2826 32 70 fe			ld (debug_mark+2),a  
2829 18 03			jr .pastdmark  
282b ..			.dmark: db "PMS"  
282e f1			.pastdmark: pop af  
282f			endm  
# End of macro DMARK
282f						CALLMONITOR 
282f cd 9d 17			call break_point_state  
2832				endm  
# End of macro CALLMONITOR
2832					endif 
2832					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2832 cd 02 20			call macro_dsp_valuehl 
2835				endm 
# End of macro FORTH_DSP_VALUEHL
2835			;		push hl    ; n2 
2835					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2835 cd ba 20			call macro_forth_dsp_pop 
2838				endm 
# End of macro FORTH_DSP_POP
2838			;		pop hl 
2838			 
2838 7d					ld a, l 
2839 cd 24 0b				call aDelayInMS 
283c				       NEXTW 
283c c3 74 21			jp macro_next 
283f				endm 
# End of macro NEXTW
283f			.PAUSES:  
283f				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
283f 44				db WORD_SYS_CORE+48             
2840 ae 28			dw .ROT            
2842 06				db 5 + 1 
2843 .. 00			db "PAUSE",0              
2849				endm 
# End of macro CWHEAD
2849			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2849					if DEBUG_FORTH_WORDS_KEY 
2849						DMARK "PAU" 
2849 f5				push af  
284a 3a 5e 28			ld a, (.dmark)  
284d 32 6e fe			ld (debug_mark),a  
2850 3a 5f 28			ld a, (.dmark+1)  
2853 32 6f fe			ld (debug_mark+1),a  
2856 3a 60 28			ld a, (.dmark+2)  
2859 32 70 fe			ld (debug_mark+2),a  
285c 18 03			jr .pastdmark  
285e ..			.dmark: db "PAU"  
2861 f1			.pastdmark: pop af  
2862			endm  
# End of macro DMARK
2862						CALLMONITOR 
2862 cd 9d 17			call break_point_state  
2865				endm  
# End of macro CALLMONITOR
2865					endif 
2865					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2865 cd 02 20			call macro_dsp_valuehl 
2868				endm 
# End of macro FORTH_DSP_VALUEHL
2868			;		push hl    ; n2 
2868					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2868 cd ba 20			call macro_forth_dsp_pop 
286b				endm 
# End of macro FORTH_DSP_POP
286b			;		pop hl 
286b 45					ld b, l 
286c					if DEBUG_FORTH_WORDS 
286c						DMARK "PAU" 
286c f5				push af  
286d 3a 81 28			ld a, (.dmark)  
2870 32 6e fe			ld (debug_mark),a  
2873 3a 82 28			ld a, (.dmark+1)  
2876 32 6f fe			ld (debug_mark+1),a  
2879 3a 83 28			ld a, (.dmark+2)  
287c 32 70 fe			ld (debug_mark+2),a  
287f 18 03			jr .pastdmark  
2881 ..			.dmark: db "PAU"  
2884 f1			.pastdmark: pop af  
2885			endm  
# End of macro DMARK
2885						CALLMONITOR 
2885 cd 9d 17			call break_point_state  
2888				endm  
# End of macro CALLMONITOR
2888					endif 
2888 c5			.pauses1:	push bc 
2889 cd 3f 0b				call delay1s 
288c c1					pop bc 
288d					if DEBUG_FORTH_WORDS 
288d						DMARK "PA1" 
288d f5				push af  
288e 3a a2 28			ld a, (.dmark)  
2891 32 6e fe			ld (debug_mark),a  
2894 3a a3 28			ld a, (.dmark+1)  
2897 32 6f fe			ld (debug_mark+1),a  
289a 3a a4 28			ld a, (.dmark+2)  
289d 32 70 fe			ld (debug_mark+2),a  
28a0 18 03			jr .pastdmark  
28a2 ..			.dmark: db "PA1"  
28a5 f1			.pastdmark: pop af  
28a6			endm  
# End of macro DMARK
28a6						CALLMONITOR 
28a6 cd 9d 17			call break_point_state  
28a9				endm  
# End of macro CALLMONITOR
28a9					endif 
28a9 10 dd				djnz .pauses1 
28ab			 
28ab				       NEXTW 
28ab c3 74 21			jp macro_next 
28ae				endm 
# End of macro NEXTW
28ae			.ROT: 
28ae				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
28ae 45				db WORD_SYS_CORE+49             
28af fc 28			dw .UWORDS            
28b1 04				db 3 + 1 
28b2 .. 00			db "ROT",0              
28b6				endm 
# End of macro CWHEAD
28b6			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
28b6					if DEBUG_FORTH_WORDS_KEY 
28b6						DMARK "ROT" 
28b6 f5				push af  
28b7 3a cb 28			ld a, (.dmark)  
28ba 32 6e fe			ld (debug_mark),a  
28bd 3a cc 28			ld a, (.dmark+1)  
28c0 32 6f fe			ld (debug_mark+1),a  
28c3 3a cd 28			ld a, (.dmark+2)  
28c6 32 70 fe			ld (debug_mark+2),a  
28c9 18 03			jr .pastdmark  
28cb ..			.dmark: db "ROT"  
28ce f1			.pastdmark: pop af  
28cf			endm  
# End of macro DMARK
28cf						CALLMONITOR 
28cf cd 9d 17			call break_point_state  
28d2				endm  
# End of macro CALLMONITOR
28d2					endif 
28d2			 
28d2					FORTH_DSP_VALUEHL 
28d2 cd 02 20			call macro_dsp_valuehl 
28d5				endm 
# End of macro FORTH_DSP_VALUEHL
28d5 e5					push hl    ; u3  
28d6			 
28d6					FORTH_DSP_POP 
28d6 cd ba 20			call macro_forth_dsp_pop 
28d9				endm 
# End of macro FORTH_DSP_POP
28d9			   
28d9					FORTH_DSP_VALUEHL 
28d9 cd 02 20			call macro_dsp_valuehl 
28dc				endm 
# End of macro FORTH_DSP_VALUEHL
28dc e5					push hl     ; u2 
28dd			 
28dd					FORTH_DSP_POP 
28dd cd ba 20			call macro_forth_dsp_pop 
28e0				endm 
# End of macro FORTH_DSP_POP
28e0			 
28e0					FORTH_DSP_VALUEHL 
28e0 cd 02 20			call macro_dsp_valuehl 
28e3				endm 
# End of macro FORTH_DSP_VALUEHL
28e3 e5					push hl     ; u1 
28e4			 
28e4					FORTH_DSP_POP 
28e4 cd ba 20			call macro_forth_dsp_pop 
28e7				endm 
# End of macro FORTH_DSP_POP
28e7			 
28e7 c1					pop bc      ; u1 
28e8 e1					pop hl      ; u2 
28e9 d1					pop de      ; u3 
28ea			 
28ea			 
28ea c5					push bc 
28eb d5					push de 
28ec e5					push hl 
28ed			 
28ed			 
28ed e1					pop hl 
28ee cd 0b 1e				call forth_push_numhl 
28f1			 
28f1 e1					pop hl 
28f2 cd 0b 1e				call forth_push_numhl 
28f5			 
28f5 e1					pop hl 
28f6 cd 0b 1e				call forth_push_numhl 
28f9					 
28f9			 
28f9			 
28f9			 
28f9			 
28f9			 
28f9				       NEXTW 
28f9 c3 74 21			jp macro_next 
28fc				endm 
# End of macro NEXTW
28fc			 
28fc			.UWORDS: 
28fc				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
28fc 50				db WORD_SYS_CORE+60             
28fd be 29			dw .BP            
28ff 07				db 6 + 1 
2900 .. 00			db "UWORDS",0              
2907				endm 
# End of macro CWHEAD
2907			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2907			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2907			; | | Following the count are the individual words. 
2907			; | | 
2907			; | | e.g. UWORDS 
2907			; | | BOX DIRLIST 2 
2907			; | |  
2907			; | | Can be used to save the words to storage via: 
2907			; | | UWORDS $01 DO $01 APPEND LOOP 
2907				if DEBUG_FORTH_WORDS_KEY 
2907					DMARK "UWR" 
2907 f5				push af  
2908 3a 1c 29			ld a, (.dmark)  
290b 32 6e fe			ld (debug_mark),a  
290e 3a 1d 29			ld a, (.dmark+1)  
2911 32 6f fe			ld (debug_mark+1),a  
2914 3a 1e 29			ld a, (.dmark+2)  
2917 32 70 fe			ld (debug_mark+2),a  
291a 18 03			jr .pastdmark  
291c ..			.dmark: db "UWR"  
291f f1			.pastdmark: pop af  
2920			endm  
# End of macro DMARK
2920					CALLMONITOR 
2920 cd 9d 17			call break_point_state  
2923				endm  
# End of macro CALLMONITOR
2923				endif 
2923 21 00 80				ld hl, baseram 
2926					;ld hl, baseusermem 
2926 01 00 00				ld bc, 0    ; start a counter 
2929			 
2929				; skip dict stub 
2929			 
2929 cd c5 22				call forth_tok_next 
292c			 
292c			 
292c			; while we have words to look for 
292c			 
292c 7e			.douscan:	ld a, (hl)      
292d				if DEBUG_FORTH_WORDS 
292d					DMARK "UWs" 
292d f5				push af  
292e 3a 42 29			ld a, (.dmark)  
2931 32 6e fe			ld (debug_mark),a  
2934 3a 43 29			ld a, (.dmark+1)  
2937 32 6f fe			ld (debug_mark+1),a  
293a 3a 44 29			ld a, (.dmark+2)  
293d 32 70 fe			ld (debug_mark+2),a  
2940 18 03			jr .pastdmark  
2942 ..			.dmark: db "UWs"  
2945 f1			.pastdmark: pop af  
2946			endm  
# End of macro DMARK
2946					CALLMONITOR 
2946 cd 9d 17			call break_point_state  
2949				endm  
# End of macro CALLMONITOR
2949				endif 
2949 fe 00				cp WORD_SYS_END 
294b 28 4d				jr z, .udone 
294d fe 01				cp WORD_SYS_UWORD 
294f 20 44				jr nz, .nuword 
2951			 
2951				if DEBUG_FORTH_WORDS 
2951					DMARK "UWu" 
2951 f5				push af  
2952 3a 66 29			ld a, (.dmark)  
2955 32 6e fe			ld (debug_mark),a  
2958 3a 67 29			ld a, (.dmark+1)  
295b 32 6f fe			ld (debug_mark+1),a  
295e 3a 68 29			ld a, (.dmark+2)  
2961 32 70 fe			ld (debug_mark+2),a  
2964 18 03			jr .pastdmark  
2966 ..			.dmark: db "UWu"  
2969 f1			.pastdmark: pop af  
296a			endm  
# End of macro DMARK
296a					CALLMONITOR 
296a cd 9d 17			call break_point_state  
296d				endm  
# End of macro CALLMONITOR
296d				endif 
296d					; we have a uword so push its name to the stack 
296d			 
296d e5				   	push hl  ; save so we can move to next dict block 
296e			 
296e					; skip opcode 
296e 23					inc hl  
296f					; skip next ptr 
296f 23					inc hl  
2970 23					inc hl 
2971					; skip len 
2971 23					inc hl 
2972				if DEBUG_FORTH_WORDS 
2972					DMARK "UWt" 
2972 f5				push af  
2973 3a 87 29			ld a, (.dmark)  
2976 32 6e fe			ld (debug_mark),a  
2979 3a 88 29			ld a, (.dmark+1)  
297c 32 6f fe			ld (debug_mark+1),a  
297f 3a 89 29			ld a, (.dmark+2)  
2982 32 70 fe			ld (debug_mark+2),a  
2985 18 03			jr .pastdmark  
2987 ..			.dmark: db "UWt"  
298a f1			.pastdmark: pop af  
298b			endm  
# End of macro DMARK
298b					CALLMONITOR 
298b cd 9d 17			call break_point_state  
298e				endm  
# End of macro CALLMONITOR
298e				endif 
298e 03					inc bc 
298f			 
298f c5					push bc 
2990 cd 79 1e				call forth_push_str 
2993 c1					pop bc 
2994			 
2994 e1					pop hl 	 
2995			 
2995 cd c5 22		.nuword:	call forth_tok_next 
2998 18 92				jr .douscan  
299a			 
299a			.udone:		 ; push count of uwords found 
299a c5					push bc 
299b e1					pop hl 
299c			 
299c				if DEBUG_FORTH_WORDS 
299c					DMARK "UWc" 
299c f5				push af  
299d 3a b1 29			ld a, (.dmark)  
29a0 32 6e fe			ld (debug_mark),a  
29a3 3a b2 29			ld a, (.dmark+1)  
29a6 32 6f fe			ld (debug_mark+1),a  
29a9 3a b3 29			ld a, (.dmark+2)  
29ac 32 70 fe			ld (debug_mark+2),a  
29af 18 03			jr .pastdmark  
29b1 ..			.dmark: db "UWc"  
29b4 f1			.pastdmark: pop af  
29b5			endm  
# End of macro DMARK
29b5					CALLMONITOR 
29b5 cd 9d 17			call break_point_state  
29b8				endm  
# End of macro CALLMONITOR
29b8				endif 
29b8 cd 0b 1e				call forth_push_numhl 
29bb			 
29bb			 
29bb				       NEXTW 
29bb c3 74 21			jp macro_next 
29be				endm 
# End of macro NEXTW
29be			 
29be			.BP: 
29be				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
29be 54				db WORD_SYS_CORE+64             
29bf f4 29			dw .MONITOR            
29c1 03				db 2 + 1 
29c2 .. 00			db "BP",0              
29c5				endm 
# End of macro CWHEAD
29c5			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
29c5			; | | $00 Will enable the break points within specific code paths 
29c5			; | | $01 Will disable break points 
29c5			; | |  
29c5			; | | By default break points are off. Either the above can be used to enable them 
29c5			; | | or if a key is held down during start up the spashscreen will appear to freeze 
29c5			; | | and on release of the pressed key a message will be disaplayed to notify 
29c5			; | | that break points are enabled. Pressing any key will then continue boot process. 
29c5					; get byte count 
29c5					if DEBUG_FORTH_WORDS_KEY 
29c5						DMARK "BP." 
29c5 f5				push af  
29c6 3a da 29			ld a, (.dmark)  
29c9 32 6e fe			ld (debug_mark),a  
29cc 3a db 29			ld a, (.dmark+1)  
29cf 32 6f fe			ld (debug_mark+1),a  
29d2 3a dc 29			ld a, (.dmark+2)  
29d5 32 70 fe			ld (debug_mark+2),a  
29d8 18 03			jr .pastdmark  
29da ..			.dmark: db "BP."  
29dd f1			.pastdmark: pop af  
29de			endm  
# End of macro DMARK
29de						CALLMONITOR 
29de cd 9d 17			call break_point_state  
29e1				endm  
# End of macro CALLMONITOR
29e1					endif 
29e1			 
29e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29e1 cd 02 20			call macro_dsp_valuehl 
29e4				endm 
# End of macro FORTH_DSP_VALUEHL
29e4			 
29e4			;		push hl 
29e4			 
29e4					; destroy value TOS 
29e4			 
29e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29e4 cd ba 20			call macro_forth_dsp_pop 
29e7				endm 
# End of macro FORTH_DSP_POP
29e7			 
29e7			;		pop hl 
29e7			 
29e7 3e 00				ld a,0 
29e9 bd					cp l 
29ea 28 02				jr z, .bpset 
29ec 3e 2a				ld a, '*' 
29ee			 
29ee 32 c5 f2		.bpset:		ld (os_view_disable), a 
29f1			 
29f1			 
29f1					NEXTW 
29f1 c3 74 21			jp macro_next 
29f4				endm 
# End of macro NEXTW
29f4			 
29f4			 
29f4			.MONITOR: 
29f4				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
29f4 55				db WORD_SYS_CORE+65             
29f5 27 2a			dw .MALLOC            
29f7 08				db 7 + 1 
29f8 .. 00			db "MONITOR",0              
2a00				endm 
# End of macro CWHEAD
2a00			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2a00			; | | At start the current various registers will be displayed with contents. 
2a00			; | | Top right corner will show the most recent debug marker seen. 
2a00			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2a00			; | | and the return stack pointer (RSP). 
2a00			; | | Pressing: 
2a00			; | |    1 - Initial screen 
2a00			; | |    2 - Display a data dump of HL 
2a00			; | |    3 - Display a data dump of DE 
2a00			; | |    4 - Display a data dump of BC 
2a00			; | |    5 - Display a data dump of HL 
2a00			; | |    6 - Display a data dump of DSP 
2a00			; | |    7 - Display a data dump of RSP 
2a00			; | |    8 - Display a data dump of what is at DSP 
2a00			; | |    9 - Display a data dump of what is at RSP 
2a00			; | |    0 - Exit monitor and continue running. This will also enable break points 
2a00			; | |    * - Disable break points 
2a00			; | |    # - Enter traditional monitor mode 
2a00			; | | 
2a00			; | | Monitor Mode 
2a00			; | | ------------ 
2a00			; | | A prompt of '>' will be shown for various commands: 
2a00			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2a00			; | |    C - Continue display a data dump from the last set address 
2a00			; | |    M xxxx - Set start of memory edit at address xx 
2a00			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2a00			; | |    Q - Return to previous 
2a00					if DEBUG_FORTH_WORDS_KEY 
2a00						DMARK "MON" 
2a00 f5				push af  
2a01 3a 15 2a			ld a, (.dmark)  
2a04 32 6e fe			ld (debug_mark),a  
2a07 3a 16 2a			ld a, (.dmark+1)  
2a0a 32 6f fe			ld (debug_mark+1),a  
2a0d 3a 17 2a			ld a, (.dmark+2)  
2a10 32 70 fe			ld (debug_mark+2),a  
2a13 18 03			jr .pastdmark  
2a15 ..			.dmark: db "MON"  
2a18 f1			.pastdmark: pop af  
2a19			endm  
# End of macro DMARK
2a19						CALLMONITOR 
2a19 cd 9d 17			call break_point_state  
2a1c				endm  
# End of macro CALLMONITOR
2a1c					endif 
2a1c 3e 00				ld a, 0 
2a1e 32 c5 f2				ld (os_view_disable), a 
2a21			 
2a21					CALLMONITOR 
2a21 cd 9d 17			call break_point_state  
2a24				endm  
# End of macro CALLMONITOR
2a24			 
2a24			;	call monitor 
2a24			 
2a24					NEXTW 
2a24 c3 74 21			jp macro_next 
2a27				endm 
# End of macro NEXTW
2a27			 
2a27			 
2a27			.MALLOC: 
2a27				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2a27 56				db WORD_SYS_CORE+66             
2a28 50 2a			dw .MALLOC2            
2a2a 06				db 5 + 1 
2a2b .. 00			db "ALLOT",0              
2a31				endm 
# End of macro CWHEAD
2a31			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a31					if DEBUG_FORTH_WORDS_KEY 
2a31						DMARK "ALL" 
2a31 f5				push af  
2a32 3a 46 2a			ld a, (.dmark)  
2a35 32 6e fe			ld (debug_mark),a  
2a38 3a 47 2a			ld a, (.dmark+1)  
2a3b 32 6f fe			ld (debug_mark+1),a  
2a3e 3a 48 2a			ld a, (.dmark+2)  
2a41 32 70 fe			ld (debug_mark+2),a  
2a44 18 03			jr .pastdmark  
2a46 ..			.dmark: db "ALL"  
2a49 f1			.pastdmark: pop af  
2a4a			endm  
# End of macro DMARK
2a4a						CALLMONITOR 
2a4a cd 9d 17			call break_point_state  
2a4d				endm  
# End of macro CALLMONITOR
2a4d					endif 
2a4d c3 77 2a				jp .mallocc 
2a50			.MALLOC2: 
2a50				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2a50 56				db WORD_SYS_CORE+66             
2a51 8e 2a			dw .FREE            
2a53 07				db 6 + 1 
2a54 .. 00			db "MALLOC",0              
2a5b				endm 
# End of macro CWHEAD
2a5b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a5b					; get byte count 
2a5b					if DEBUG_FORTH_WORDS_KEY 
2a5b						DMARK "MAL" 
2a5b f5				push af  
2a5c 3a 70 2a			ld a, (.dmark)  
2a5f 32 6e fe			ld (debug_mark),a  
2a62 3a 71 2a			ld a, (.dmark+1)  
2a65 32 6f fe			ld (debug_mark+1),a  
2a68 3a 72 2a			ld a, (.dmark+2)  
2a6b 32 70 fe			ld (debug_mark+2),a  
2a6e 18 03			jr .pastdmark  
2a70 ..			.dmark: db "MAL"  
2a73 f1			.pastdmark: pop af  
2a74			endm  
# End of macro DMARK
2a74						CALLMONITOR 
2a74 cd 9d 17			call break_point_state  
2a77				endm  
# End of macro CALLMONITOR
2a77					endif 
2a77			.mallocc: 
2a77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a77 cd 02 20			call macro_dsp_valuehl 
2a7a				endm 
# End of macro FORTH_DSP_VALUEHL
2a7a			 
2a7a			;		push hl 
2a7a			 
2a7a					; destroy value TOS 
2a7a			 
2a7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a7a cd ba 20			call macro_forth_dsp_pop 
2a7d				endm 
# End of macro FORTH_DSP_POP
2a7d			 
2a7d			;		pop hl 
2a7d cd bd 12				call malloc 
2a80				if DEBUG_FORTH_MALLOC_GUARD 
2a80 f5					push af 
2a81 cd 1f 0e				call ishlzero 
2a84			;		ld a, l 
2a84			;		add h 
2a84			;		cp 0 
2a84 f1					pop af 
2a85					 
2a85 cc f2 53				call z,malloc_error 
2a88				endif 
2a88			 
2a88 cd 0b 1e				call forth_push_numhl 
2a8b					NEXTW 
2a8b c3 74 21			jp macro_next 
2a8e				endm 
# End of macro NEXTW
2a8e			 
2a8e			.FREE: 
2a8e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a8e 57				db WORD_SYS_CORE+67             
2a8f bf 2a			dw .LIST            
2a91 05				db 4 + 1 
2a92 .. 00			db "FREE",0              
2a97				endm 
# End of macro CWHEAD
2a97			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a97					if DEBUG_FORTH_WORDS_KEY 
2a97						DMARK "FRE" 
2a97 f5				push af  
2a98 3a ac 2a			ld a, (.dmark)  
2a9b 32 6e fe			ld (debug_mark),a  
2a9e 3a ad 2a			ld a, (.dmark+1)  
2aa1 32 6f fe			ld (debug_mark+1),a  
2aa4 3a ae 2a			ld a, (.dmark+2)  
2aa7 32 70 fe			ld (debug_mark+2),a  
2aaa 18 03			jr .pastdmark  
2aac ..			.dmark: db "FRE"  
2aaf f1			.pastdmark: pop af  
2ab0			endm  
# End of macro DMARK
2ab0						CALLMONITOR 
2ab0 cd 9d 17			call break_point_state  
2ab3				endm  
# End of macro CALLMONITOR
2ab3					endif 
2ab3					; get address 
2ab3			 
2ab3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab3 cd 02 20			call macro_dsp_valuehl 
2ab6				endm 
# End of macro FORTH_DSP_VALUEHL
2ab6			 
2ab6			;		push hl 
2ab6			 
2ab6					; destroy value TOS 
2ab6			 
2ab6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab6 cd ba 20			call macro_forth_dsp_pop 
2ab9				endm 
# End of macro FORTH_DSP_POP
2ab9			 
2ab9			;		pop hl 
2ab9			if FORTH_ENABLE_MALLOCFREE 
2ab9 cd 87 13				call free 
2abc			endif 
2abc					NEXTW 
2abc c3 74 21			jp macro_next 
2abf				endm 
# End of macro NEXTW
2abf			.LIST: 
2abf				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2abf 5c				db WORD_SYS_CORE+72             
2ac0 ad 2c			dw .FORGET            
2ac2 05				db 4 + 1 
2ac3 .. 00			db "LIST",0              
2ac8				endm 
# End of macro CWHEAD
2ac8			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2ac8			; | | The quoted word must be in upper case. 
2ac8				if DEBUG_FORTH_WORDS_KEY 
2ac8					DMARK "LST" 
2ac8 f5				push af  
2ac9 3a dd 2a			ld a, (.dmark)  
2acc 32 6e fe			ld (debug_mark),a  
2acf 3a de 2a			ld a, (.dmark+1)  
2ad2 32 6f fe			ld (debug_mark+1),a  
2ad5 3a df 2a			ld a, (.dmark+2)  
2ad8 32 70 fe			ld (debug_mark+2),a  
2adb 18 03			jr .pastdmark  
2add ..			.dmark: db "LST"  
2ae0 f1			.pastdmark: pop af  
2ae1			endm  
# End of macro DMARK
2ae1					CALLMONITOR 
2ae1 cd 9d 17			call break_point_state  
2ae4				endm  
# End of macro CALLMONITOR
2ae4				endif 
2ae4			 
2ae4					FORTH_DSP_VALUEHL 
2ae4 cd 02 20			call macro_dsp_valuehl 
2ae7				endm 
# End of macro FORTH_DSP_VALUEHL
2ae7			 
2ae7 e5					push hl 
2ae8					FORTH_DSP_POP 
2ae8 cd ba 20			call macro_forth_dsp_pop 
2aeb				endm 
# End of macro FORTH_DSP_POP
2aeb c1					pop bc 
2aec			 
2aec			; Start format of scratch string 
2aec			 
2aec 21 d4 f2				ld hl, scratch 
2aef			 
2aef 3e 3a				ld a, ':' 
2af1 77					ld (hl),a 
2af2 23					inc hl 
2af3 3e 20				ld a, ' ' 
2af5 77					ld (hl), a 
2af6			 
2af6					; Get ptr to the word we need to look up 
2af6			 
2af6			;		FORTH_DSP_VALUEHL 
2af6					;v5 FORTH_DSP_VALUE 
2af6				; TODO type check 
2af6			;		inc hl    ; Skip type check  
2af6			;		push hl 
2af6			;		ex de, hl    ; put into DE 
2af6			 
2af6			 
2af6 21 00 80				ld hl, baseram 
2af9					;ld hl, baseusermem 
2af9			 
2af9 e5			push hl   ; sacreifical push 
2afa			 
2afa			.ldouscanm: 
2afa e1				pop hl 
2afb			.ldouscan: 
2afb				if DEBUG_FORTH_WORDS 
2afb					DMARK "LSs" 
2afb f5				push af  
2afc 3a 10 2b			ld a, (.dmark)  
2aff 32 6e fe			ld (debug_mark),a  
2b02 3a 11 2b			ld a, (.dmark+1)  
2b05 32 6f fe			ld (debug_mark+1),a  
2b08 3a 12 2b			ld a, (.dmark+2)  
2b0b 32 70 fe			ld (debug_mark+2),a  
2b0e 18 03			jr .pastdmark  
2b10 ..			.dmark: db "LSs"  
2b13 f1			.pastdmark: pop af  
2b14			endm  
# End of macro DMARK
2b14					CALLMONITOR 
2b14 cd 9d 17			call break_point_state  
2b17				endm  
# End of macro CALLMONITOR
2b17				endif 
2b17				; skip dict stub 
2b17 cd c5 22				call forth_tok_next 
2b1a			 
2b1a			 
2b1a			; while we have words to look for 
2b1a			 
2b1a 7e				ld a, (hl)      
2b1b				if DEBUG_FORTH_WORDS 
2b1b					DMARK "LSk" 
2b1b f5				push af  
2b1c 3a 30 2b			ld a, (.dmark)  
2b1f 32 6e fe			ld (debug_mark),a  
2b22 3a 31 2b			ld a, (.dmark+1)  
2b25 32 6f fe			ld (debug_mark+1),a  
2b28 3a 32 2b			ld a, (.dmark+2)  
2b2b 32 70 fe			ld (debug_mark+2),a  
2b2e 18 03			jr .pastdmark  
2b30 ..			.dmark: db "LSk"  
2b33 f1			.pastdmark: pop af  
2b34			endm  
# End of macro DMARK
2b34					CALLMONITOR 
2b34 cd 9d 17			call break_point_state  
2b37				endm  
# End of macro CALLMONITOR
2b37				endif 
2b37					;cp WORD_SYS_END 
2b37					;jp z, .lunotfound 
2b37			 
2b37					; if we hit non uwords then gone too far 
2b37 fe 01				cp WORD_SYS_UWORD 
2b39 c2 69 2c				jp nz, .lunotfound 
2b3c			 
2b3c				if DEBUG_FORTH_WORDS 
2b3c					DMARK "LSu" 
2b3c f5				push af  
2b3d 3a 51 2b			ld a, (.dmark)  
2b40 32 6e fe			ld (debug_mark),a  
2b43 3a 52 2b			ld a, (.dmark+1)  
2b46 32 6f fe			ld (debug_mark+1),a  
2b49 3a 53 2b			ld a, (.dmark+2)  
2b4c 32 70 fe			ld (debug_mark+2),a  
2b4f 18 03			jr .pastdmark  
2b51 ..			.dmark: db "LSu"  
2b54 f1			.pastdmark: pop af  
2b55			endm  
# End of macro DMARK
2b55					CALLMONITOR 
2b55 cd 9d 17			call break_point_state  
2b58				endm  
# End of macro CALLMONITOR
2b58				endif 
2b58			 
2b58					; found a uword but is it the one we want... 
2b58			 
2b58 c5					push bc     ; uword to find is on bc 
2b59 d1					pop de 
2b5a			 
2b5a e5					push hl  ; to save the ptr 
2b5b			 
2b5b					; skip opcode 
2b5b 23					inc hl  
2b5c					; skip next ptr 
2b5c 23					inc hl  
2b5d 23					inc hl 
2b5e					; skip len 
2b5e 23					inc hl 
2b5f			 
2b5f				if DEBUG_FORTH_WORDS 
2b5f					DMARK "LSc" 
2b5f f5				push af  
2b60 3a 74 2b			ld a, (.dmark)  
2b63 32 6e fe			ld (debug_mark),a  
2b66 3a 75 2b			ld a, (.dmark+1)  
2b69 32 6f fe			ld (debug_mark+1),a  
2b6c 3a 76 2b			ld a, (.dmark+2)  
2b6f 32 70 fe			ld (debug_mark+2),a  
2b72 18 03			jr .pastdmark  
2b74 ..			.dmark: db "LSc"  
2b77 f1			.pastdmark: pop af  
2b78			endm  
# End of macro DMARK
2b78					CALLMONITOR 
2b78 cd 9d 17			call break_point_state  
2b7b				endm  
# End of macro CALLMONITOR
2b7b				endif 
2b7b cd 8c 12				call strcmp 
2b7e c2 fa 2a				jp nz, .ldouscanm 
2b81				 
2b81			 
2b81			 
2b81					; we have a uword so push its name to the stack 
2b81			 
2b81			;	   	push hl  ; save so we can move to next dict block 
2b81 e1			pop hl 
2b82			 
2b82				if DEBUG_FORTH_WORDS 
2b82					DMARK "LSm" 
2b82 f5				push af  
2b83 3a 97 2b			ld a, (.dmark)  
2b86 32 6e fe			ld (debug_mark),a  
2b89 3a 98 2b			ld a, (.dmark+1)  
2b8c 32 6f fe			ld (debug_mark+1),a  
2b8f 3a 99 2b			ld a, (.dmark+2)  
2b92 32 70 fe			ld (debug_mark+2),a  
2b95 18 03			jr .pastdmark  
2b97 ..			.dmark: db "LSm"  
2b9a f1			.pastdmark: pop af  
2b9b			endm  
# End of macro DMARK
2b9b					CALLMONITOR 
2b9b cd 9d 17			call break_point_state  
2b9e				endm  
# End of macro CALLMONITOR
2b9e				endif 
2b9e			 
2b9e					; skip opcode 
2b9e 23					inc hl  
2b9f					; skip next ptr 
2b9f 23					inc hl  
2ba0 23					inc hl 
2ba1					; skip len 
2ba1 7e					ld a, (hl)   ; save length to add 
2ba2				if DEBUG_FORTH_WORDS 
2ba2					DMARK "LS2" 
2ba2 f5				push af  
2ba3 3a b7 2b			ld a, (.dmark)  
2ba6 32 6e fe			ld (debug_mark),a  
2ba9 3a b8 2b			ld a, (.dmark+1)  
2bac 32 6f fe			ld (debug_mark+1),a  
2baf 3a b9 2b			ld a, (.dmark+2)  
2bb2 32 70 fe			ld (debug_mark+2),a  
2bb5 18 03			jr .pastdmark  
2bb7 ..			.dmark: db "LS2"  
2bba f1			.pastdmark: pop af  
2bbb			endm  
# End of macro DMARK
2bbb					CALLMONITOR 
2bbb cd 9d 17			call break_point_state  
2bbe				endm  
# End of macro CALLMONITOR
2bbe				endif 
2bbe			 
2bbe					; save this location 
2bbe				 
2bbe e5					push hl 
2bbf			 
2bbf 23					inc hl 
2bc0 11 d6 f2				ld de, scratch+2 
2bc3 4f					ld c, a 
2bc4 06 00				ld b, 0 
2bc6			 
2bc6				if DEBUG_FORTH_WORDS 
2bc6					DMARK "LSn" 
2bc6 f5				push af  
2bc7 3a db 2b			ld a, (.dmark)  
2bca 32 6e fe			ld (debug_mark),a  
2bcd 3a dc 2b			ld a, (.dmark+1)  
2bd0 32 6f fe			ld (debug_mark+1),a  
2bd3 3a dd 2b			ld a, (.dmark+2)  
2bd6 32 70 fe			ld (debug_mark+2),a  
2bd9 18 03			jr .pastdmark  
2bdb ..			.dmark: db "LSn"  
2bde f1			.pastdmark: pop af  
2bdf			endm  
# End of macro DMARK
2bdf					CALLMONITOR 
2bdf cd 9d 17			call break_point_state  
2be2				endm  
# End of macro CALLMONITOR
2be2				endif 
2be2			 
2be2					; copy uword name to scratch 
2be2			 
2be2 ed b0				ldir 
2be4			 
2be4 1b					dec de 
2be5 3e 20				ld a, ' '    ; change null to space 
2be7 12					ld (de), a 
2be8			 
2be8 13					inc de 
2be9			 
2be9 d5					push de 
2bea c1					pop bc     ; move scratch pointer to end of word name and save it 
2beb			 
2beb e1					pop hl 
2bec 7e					ld a, (hl) 
2bed					;inc hl 
2bed					; skip word string 
2bed cd f6 0d				call addatohl 
2bf0			 
2bf0 23					inc hl 
2bf1			 
2bf1				if DEBUG_FORTH_WORDS 
2bf1					DMARK "LS3" 
2bf1 f5				push af  
2bf2 3a 06 2c			ld a, (.dmark)  
2bf5 32 6e fe			ld (debug_mark),a  
2bf8 3a 07 2c			ld a, (.dmark+1)  
2bfb 32 6f fe			ld (debug_mark+1),a  
2bfe 3a 08 2c			ld a, (.dmark+2)  
2c01 32 70 fe			ld (debug_mark+2),a  
2c04 18 03			jr .pastdmark  
2c06 ..			.dmark: db "LS3"  
2c09 f1			.pastdmark: pop af  
2c0a			endm  
# End of macro DMARK
2c0a					CALLMONITOR 
2c0a cd 9d 17			call break_point_state  
2c0d				endm  
# End of macro CALLMONITOR
2c0d				endif 
2c0d					; should now be at the start of the machine code to setup the eval of the uword 
2c0d					; now locate the ptr to the string defintion 
2c0d			 
2c0d					; skip ld hl, 
2c0d					; then load the ptr 
2c0d			; TODO use get from hl ptr 
2c0d 23					inc hl 
2c0e 5e					ld e, (hl) 
2c0f 23					inc hl 
2c10 56					ld d, (hl) 
2c11 eb					ex de, hl 
2c12			 
2c12			 
2c12				if DEBUG_FORTH_WORDS 
2c12					DMARK "LSt" 
2c12 f5				push af  
2c13 3a 27 2c			ld a, (.dmark)  
2c16 32 6e fe			ld (debug_mark),a  
2c19 3a 28 2c			ld a, (.dmark+1)  
2c1c 32 6f fe			ld (debug_mark+1),a  
2c1f 3a 29 2c			ld a, (.dmark+2)  
2c22 32 70 fe			ld (debug_mark+2),a  
2c25 18 03			jr .pastdmark  
2c27 ..			.dmark: db "LSt"  
2c2a f1			.pastdmark: pop af  
2c2b			endm  
# End of macro DMARK
2c2b					CALLMONITOR 
2c2b cd 9d 17			call break_point_state  
2c2e				endm  
# End of macro CALLMONITOR
2c2e				endif 
2c2e			 
2c2e			; cant push right now due to tokenised strings  
2c2e			 
2c2e			; get the destination of where to copy this definition to. 
2c2e			 
2c2e c5					push bc 
2c2f d1					pop de 
2c30			 
2c30 7e			.listl:         ld a,(hl) 
2c31 fe 00				cp 0 
2c33 28 09				jr z, .lreplsp     ; replace zero with space 
2c35					;cp FORTH_END_BUFFER 
2c35 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2c37 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c39				 
2c39					; just copy this char as is then 
2c39			 
2c39 12					ld (de), a 
2c3a			 
2c3a 23			.listnxt:	inc hl 
2c3b 13					inc de 
2c3c 18 f2				jr .listl 
2c3e			 
2c3e 3e 20		.lreplsp:	ld a,' ' 
2c40 12					ld (de), a 
2c41 18 f7				jr .listnxt 
2c43			 
2c43			; close up uword def 
2c43			 
2c43			.listdone: 
2c43 12					ld (de), a 
2c44 13					inc de 
2c45 3e 00				ld a, 0 
2c47 12					ld (de), a 
2c48			 
2c48			; now have def so clean up and push to stack 
2c48			 
2c48 21 d4 f2				ld hl, scratch 
2c4b				if DEBUG_FORTH_WORDS 
2c4b					DMARK "Ltp" 
2c4b f5				push af  
2c4c 3a 60 2c			ld a, (.dmark)  
2c4f 32 6e fe			ld (debug_mark),a  
2c52 3a 61 2c			ld a, (.dmark+1)  
2c55 32 6f fe			ld (debug_mark+1),a  
2c58 3a 62 2c			ld a, (.dmark+2)  
2c5b 32 70 fe			ld (debug_mark+2),a  
2c5e 18 03			jr .pastdmark  
2c60 ..			.dmark: db "Ltp"  
2c63 f1			.pastdmark: pop af  
2c64			endm  
# End of macro DMARK
2c64					CALLMONITOR 
2c64 cd 9d 17			call break_point_state  
2c67				endm  
# End of macro CALLMONITOR
2c67				endif 
2c67			 
2c67 18 1f			jr .listpush 
2c69			 
2c69			;.lnuword:	pop hl 
2c69			;		call forth_tok_next 
2c69			;		jp .ldouscan  
2c69			 
2c69			.lunotfound:		  
2c69			 
2c69				if DEBUG_FORTH_WORDS 
2c69					DMARK "LSn" 
2c69 f5				push af  
2c6a 3a 7e 2c			ld a, (.dmark)  
2c6d 32 6e fe			ld (debug_mark),a  
2c70 3a 7f 2c			ld a, (.dmark+1)  
2c73 32 6f fe			ld (debug_mark+1),a  
2c76 3a 80 2c			ld a, (.dmark+2)  
2c79 32 70 fe			ld (debug_mark+2),a  
2c7c 18 03			jr .pastdmark  
2c7e ..			.dmark: db "LSn"  
2c81 f1			.pastdmark: pop af  
2c82			endm  
# End of macro DMARK
2c82					CALLMONITOR 
2c82 cd 9d 17			call break_point_state  
2c85				endm  
# End of macro CALLMONITOR
2c85				endif 
2c85			 
2c85					 
2c85			;		FORTH_DSP_POP 
2c85			;		ld hl, .luno 
2c85			 
2c85					NEXTW			 
2c85 c3 74 21			jp macro_next 
2c88				endm 
# End of macro NEXTW
2c88			 
2c88			.listpush: 
2c88				if DEBUG_FORTH_WORDS 
2c88					DMARK "LS>" 
2c88 f5				push af  
2c89 3a 9d 2c			ld a, (.dmark)  
2c8c 32 6e fe			ld (debug_mark),a  
2c8f 3a 9e 2c			ld a, (.dmark+1)  
2c92 32 6f fe			ld (debug_mark+1),a  
2c95 3a 9f 2c			ld a, (.dmark+2)  
2c98 32 70 fe			ld (debug_mark+2),a  
2c9b 18 03			jr .pastdmark  
2c9d ..			.dmark: db "LS>"  
2ca0 f1			.pastdmark: pop af  
2ca1			endm  
# End of macro DMARK
2ca1					CALLMONITOR 
2ca1 cd 9d 17			call break_point_state  
2ca4				endm  
# End of macro CALLMONITOR
2ca4				endif 
2ca4 cd 79 1e				call forth_push_str 
2ca7			 
2ca7			 
2ca7			 
2ca7					NEXTW 
2ca7 c3 74 21			jp macro_next 
2caa				endm 
# End of macro NEXTW
2caa			 
2caa			;.luno:    db "Word not found",0 
2caa			 
2caa			 
2caa			 
2caa			 
2caa			 
2caa			;		push hl   ; save pointer to start of uword def string 
2caa			; 
2caa			;; look for FORTH_EOL_LINE 
2caa			;		ld a, FORTH_END_BUFFER 
2caa			;		call strlent 
2caa			; 
2caa			;		inc hl		 ; space for coln def 
2caa			;		inc hl 
2caa			;		inc hl          ; space for terms 
2caa			;		inc hl 
2caa			; 
2caa			;		ld a, 20   ; TODO get actual length 
2caa			;		call addatohl    ; include a random amount of room for the uword name 
2caa			; 
2caa			;		 
2caa			;	if DEBUG_FORTH_WORDS 
2caa			;		DMARK "Lt1" 
2caa			;		CALLMONITOR 
2caa			;	endif 
2caa			;		 
2caa			; 
2caa			;; malloc space for the string because we cant change it 
2caa			; 
2caa			;		call malloc 
2caa			;	if DEBUG_FORTH_MALLOC_GUARD 
2caa			;		push af 
2caa			;		call ishlzero 
2caa			;		pop af 
2caa			;		 
2caa			;		call z,malloc_error 
2caa			;	endif 
2caa			; 
2caa			;	if DEBUG_FORTH_WORDS 
2caa			;		DMARK "Lt2" 
2caa			;		CALLMONITOR 
2caa			;	endif 
2caa			;		pop de 
2caa			;		push hl    ; push the malloc to release later 
2caa			;		push hl   ;  push back a copy for the later stack push 
2caa			;		 
2caa			;; copy the string swapping out the zero terms for spaces 
2caa			; 
2caa			;		; de has our source 
2caa			;		; hl has our dest 
2caa			; 
2caa			;; add the coln def 
2caa			; 
2caa			;		ld a, ':' 
2caa			;		ld (hl), a 
2caa			;		inc hl 
2caa			;		ld a, ' ' 
2caa			;		ld (hl), a 
2caa			;		inc hl 
2caa			; 
2caa			;; add the uname word 
2caa			;		push de   ; save our string for now 
2caa			;		ex de, hl 
2caa			; 
2caa			;		FORTH_DSP_VALUE 
2caa			;		;v5 FORTH_DSP_VALUE 
2caa			; 
2caa			;		inc hl   ; skip type but we know by now this is OK 
2caa			; 
2caa			;.luword:	ld a,(hl) 
2caa			;		cp 0 
2caa			;		jr z, .luword2 
2caa			;		ld (de), a 
2caa			;		inc de 
2caa			;		inc hl 
2caa			;		jr .luword 
2caa			; 
2caa			;.luword2:	ld a, ' ' 
2caa			;		ld (de), a 
2caa			;;		inc hl 
2caa			;;		inc de 
2caa			;;		ld (de), a 
2caa			;;		inc hl 
2caa			;		inc de 
2caa			; 
2caa			;		ex de, hl 
2caa			;		pop de 
2caa			;		 
2caa			;		 
2caa			; 
2caa			;; detoken that string and copy it 
2caa			; 
2caa			;	if DEBUG_FORTH_WORDS 
2caa			;		DMARK "Lt2" 
2caa			;		CALLMONITOR 
2caa			;	endif 
2caa			;.ldetok:	ld a, (de) 
2caa			;		cp FORTH_END_BUFFER 
2caa			;		jr z, .ldetokend 
2caa			;		; swap out any zero term for space 
2caa			;		cp 0 
2caa			;		jr nz, .ldetoknext 
2caa			;		ld a, ' ' 
2caa			; 
2caa			;	if DEBUG_FORTH_WORDS 
2caa			;		DMARK "LtS" 
2caa			;		CALLMONITOR 
2caa			;	endif 
2caa			;.ldetoknext:	ld (hl), a 
2caa			;		inc de 
2caa			;		inc hl 
2caa			;		jr .ldetok 
2caa			; 
2caa			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2caa			;		ld (hl), a  
2caa			; 
2caa			;; free that temp malloc 
2caa			; 
2caa			;		pop hl    
2caa			; 
2caa			;	if DEBUG_FORTH_WORDS 
2caa			;		DMARK "Lt4" 
2caa			;		CALLMONITOR 
2caa			;	endif 
2caa			;		call forth_apushstrhl 
2caa			; 
2caa			;		; get rid of temp malloc area 
2caa			; 
2caa			;		pop hl 
2caa			;		call free 
2caa			; 
2caa			;		jr .ludone 
2caa			; 
2caa			;.lnuword:	pop hl 
2caa			;		call forth_tok_next 
2caa			;		jp .ldouscan  
2caa			; 
2caa			;.ludone:		 pop hl 
2caa			; 
2caa					NEXTW 
2caa c3 74 21			jp macro_next 
2cad				endm 
# End of macro NEXTW
2cad			 
2cad			.FORGET: 
2cad				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2cad 5d				db WORD_SYS_CORE+73             
2cae 26 2d			dw .NOP            
2cb0 07				db 6 + 1 
2cb1 .. 00			db "FORGET",0              
2cb8				endm 
# End of macro CWHEAD
2cb8			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2cb8			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2cb8			; | |  
2cb8			; | | e.g. "MORE" forget 
2cb8					if DEBUG_FORTH_WORDS_KEY 
2cb8						DMARK "FRG" 
2cb8 f5				push af  
2cb9 3a cd 2c			ld a, (.dmark)  
2cbc 32 6e fe			ld (debug_mark),a  
2cbf 3a ce 2c			ld a, (.dmark+1)  
2cc2 32 6f fe			ld (debug_mark+1),a  
2cc5 3a cf 2c			ld a, (.dmark+2)  
2cc8 32 70 fe			ld (debug_mark+2),a  
2ccb 18 03			jr .pastdmark  
2ccd ..			.dmark: db "FRG"  
2cd0 f1			.pastdmark: pop af  
2cd1			endm  
# End of macro DMARK
2cd1						CALLMONITOR 
2cd1 cd 9d 17			call break_point_state  
2cd4				endm  
# End of macro CALLMONITOR
2cd4					endif 
2cd4			 
2cd4				; find uword 
2cd4			        ; update start of word with "_" 
2cd4				; replace uword with deleted flag 
2cd4			 
2cd4			 
2cd4			;	if DEBUG_FORTH_WORDS 
2cd4			;		DMARK "FOG" 
2cd4			;		CALLMONITOR 
2cd4			;	endif 
2cd4			 
2cd4			 
2cd4					; Get ptr to the word we need to look up 
2cd4			 
2cd4					FORTH_DSP_VALUEHL 
2cd4 cd 02 20			call macro_dsp_valuehl 
2cd7				endm 
# End of macro FORTH_DSP_VALUEHL
2cd7					;v5 FORTH_DSP_VALUE 
2cd7				; TODO type check 
2cd7			;		inc hl    ; Skip type check  
2cd7 e5					push hl 
2cd8 c1					pop bc 
2cd9			;		ex de, hl    ; put into DE 
2cd9			 
2cd9			 
2cd9 21 00 80				ld hl, baseram 
2cdc					;ld hl, baseusermem 
2cdc			 
2cdc				; skip dict stub 
2cdc			;	call forth_tok_next 
2cdc e5			push hl   ; sacreifical push 
2cdd			 
2cdd			.fldouscanm: 
2cdd e1				pop hl 
2cde			.fldouscan: 
2cde			;	if DEBUG_FORTH_WORDS 
2cde			;		DMARK "LSs" 
2cde			;		CALLMONITOR 
2cde			;	endif 
2cde				; skip dict stub 
2cde cd c5 22				call forth_tok_next 
2ce1			 
2ce1			 
2ce1			; while we have words to look for 
2ce1			 
2ce1 7e				ld a, (hl)      
2ce2			;	if DEBUG_FORTH_WORDS 
2ce2			;		DMARK "LSk" 
2ce2			;		CALLMONITOR 
2ce2			;	endif 
2ce2 fe 00				cp WORD_SYS_END 
2ce4 ca 20 2d				jp z, .flunotfound 
2ce7 fe 01				cp WORD_SYS_UWORD 
2ce9 c2 de 2c				jp nz, .fldouscan 
2cec			 
2cec			;	if DEBUG_FORTH_WORDS 
2cec			;		DMARK "LSu" 
2cec			;		CALLMONITOR 
2cec			;	endif 
2cec			 
2cec					; found a uword but is it the one we want... 
2cec			 
2cec c5					push bc     ; uword to find is on bc 
2ced d1					pop de 
2cee			 
2cee e5					push hl  ; to save the ptr 
2cef			 
2cef					; skip opcode 
2cef 23					inc hl  
2cf0					; skip next ptr 
2cf0 23					inc hl  
2cf1 23					inc hl 
2cf2					; skip len 
2cf2 23					inc hl 
2cf3			 
2cf3			;	if DEBUG_FORTH_WORDS 
2cf3			;		DMARK "LSc" 
2cf3			;		CALLMONITOR 
2cf3			;	endif 
2cf3 cd 8c 12				call strcmp 
2cf6 c2 dd 2c				jp nz, .fldouscanm 
2cf9			; 
2cf9			; 
2cf9			;; while we have words to look for 
2cf9			; 
2cf9			;.fdouscan:	ld a, (hl)      
2cf9			;	if DEBUG_FORTH_WORDS 
2cf9			;		DMARK "LSs" 
2cf9			;		CALLMONITOR 
2cf9			;	endif 
2cf9			;		cp WORD_SYS_END 
2cf9			;		jp z, .fudone 
2cf9			;		cp WORD_SYS_UWORD 
2cf9			;		jp nz, .fnuword 
2cf9			; 
2cf9			;	if DEBUG_FORTH_WORDS 
2cf9			;		DMARK "FGu" 
2cf9			;		CALLMONITOR 
2cf9			;	endif 
2cf9			; 
2cf9			;		; found a uword but is it the one we want... 
2cf9			; 
2cf9			; 
2cf9			;	        pop de   ; get back the dsp name 
2cf9			;		push de 
2cf9			; 
2cf9			;		push hl  ; to save the ptr 
2cf9			; 
2cf9			;		; skip opcode 
2cf9			;		inc hl  
2cf9			;		; skip next ptr 
2cf9			;		inc hl  
2cf9			;		inc hl 
2cf9			;		; skip len 
2cf9			;		inc hl 
2cf9			; 
2cf9			;	if DEBUG_FORTH_WORDS 
2cf9			;		DMARK "FGc" 
2cf9			;		CALLMONITOR 
2cf9			;	endif 
2cf9			;		call strcmp 
2cf9			;		jp nz, .fnuword 
2cf9			 
2cf9			 
2cf9 e1			pop hl 
2cfa			 
2cfa				 
2cfa				if DEBUG_FORTH_WORDS 
2cfa					DMARK "FGm" 
2cfa f5				push af  
2cfb 3a 0f 2d			ld a, (.dmark)  
2cfe 32 6e fe			ld (debug_mark),a  
2d01 3a 10 2d			ld a, (.dmark+1)  
2d04 32 6f fe			ld (debug_mark+1),a  
2d07 3a 11 2d			ld a, (.dmark+2)  
2d0a 32 70 fe			ld (debug_mark+2),a  
2d0d 18 03			jr .pastdmark  
2d0f ..			.dmark: db "FGm"  
2d12 f1			.pastdmark: pop af  
2d13			endm  
# End of macro DMARK
2d13					CALLMONITOR 
2d13 cd 9d 17			call break_point_state  
2d16				endm  
# End of macro CALLMONITOR
2d16				endif 
2d16			 
2d16			 
2d16			 
2d16					; we have a uword so push its name to the stack 
2d16			 
2d16			;	   	push hl  ; save so we can move to next dict block 
2d16			;pop hl 
2d16			 
2d16					; update opcode to deleted 
2d16 3e 03				ld a, WORD_SYS_DELETED 
2d18 77					ld (hl), a 
2d19			 
2d19 23					inc hl  
2d1a					; skip next ptr 
2d1a 23					inc hl  
2d1b 23					inc hl 
2d1c					; skip len 
2d1c 23					inc hl 
2d1d			 
2d1d					; TODO change parser to skip deleted words but for now mark it out 
2d1d 3e 5f				ld a, "_" 
2d1f 77					ld  (hl),a 
2d20			 
2d20			;		jr .fudone 
2d20			; 
2d20			;.fnuword:	pop hl 
2d20			;		call forth_tok_next 
2d20			;		jp .fdouscan  
2d20			 
2d20			.flunotfound:		  
2d20			 
2d20			 
2d20					 
2d20					FORTH_DSP_POP 
2d20 cd ba 20			call macro_forth_dsp_pop 
2d23				endm 
# End of macro FORTH_DSP_POP
2d23			;		ld hl, .luno 
2d23			;.fudone:		 pop hl 
2d23					NEXTW 
2d23 c3 74 21			jp macro_next 
2d26				endm 
# End of macro NEXTW
2d26			.NOP: 
2d26				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2d26 61				db WORD_SYS_CORE+77             
2d27 4d 2d			dw .COMO            
2d29 04				db 3 + 1 
2d2a .. 00			db "NOP",0              
2d2e				endm 
# End of macro CWHEAD
2d2e			; | NOP (  --  ) Do nothing | DONE 
2d2e					if DEBUG_FORTH_WORDS_KEY 
2d2e						DMARK "NOP" 
2d2e f5				push af  
2d2f 3a 43 2d			ld a, (.dmark)  
2d32 32 6e fe			ld (debug_mark),a  
2d35 3a 44 2d			ld a, (.dmark+1)  
2d38 32 6f fe			ld (debug_mark+1),a  
2d3b 3a 45 2d			ld a, (.dmark+2)  
2d3e 32 70 fe			ld (debug_mark+2),a  
2d41 18 03			jr .pastdmark  
2d43 ..			.dmark: db "NOP"  
2d46 f1			.pastdmark: pop af  
2d47			endm  
# End of macro DMARK
2d47						CALLMONITOR 
2d47 cd 9d 17			call break_point_state  
2d4a				endm  
# End of macro CALLMONITOR
2d4a					endif 
2d4a				       NEXTW 
2d4a c3 74 21			jp macro_next 
2d4d				endm 
# End of macro NEXTW
2d4d			.COMO: 
2d4d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2d4d 6e				db WORD_SYS_CORE+90             
2d4e 9f 2d			dw .COMC            
2d50 02				db 1 + 1 
2d51 .. 00			db "(",0              
2d53				endm 
# End of macro CWHEAD
2d53			; | ( ( -- )  Start of comment | DONE 
2d53			 
2d53			 
2d53 2a d5 f5				ld hl, ( os_tok_ptr) 
2d56 11 9a 2d			ld de, .closepar 
2d59					 
2d59					if DEBUG_FORTH_WORDS 
2d59						DMARK ").." 
2d59 f5				push af  
2d5a 3a 6e 2d			ld a, (.dmark)  
2d5d 32 6e fe			ld (debug_mark),a  
2d60 3a 6f 2d			ld a, (.dmark+1)  
2d63 32 6f fe			ld (debug_mark+1),a  
2d66 3a 70 2d			ld a, (.dmark+2)  
2d69 32 70 fe			ld (debug_mark+2),a  
2d6c 18 03			jr .pastdmark  
2d6e ..			.dmark: db ").."  
2d71 f1			.pastdmark: pop af  
2d72			endm  
# End of macro DMARK
2d72						CALLMONITOR 
2d72 cd 9d 17			call break_point_state  
2d75				endm  
# End of macro CALLMONITOR
2d75					endif 
2d75 cd 8f 22			call findnexttok  
2d78			 
2d78					if DEBUG_FORTH_WORDS 
2d78						DMARK "IF5" 
2d78 f5				push af  
2d79 3a 8d 2d			ld a, (.dmark)  
2d7c 32 6e fe			ld (debug_mark),a  
2d7f 3a 8e 2d			ld a, (.dmark+1)  
2d82 32 6f fe			ld (debug_mark+1),a  
2d85 3a 8f 2d			ld a, (.dmark+2)  
2d88 32 70 fe			ld (debug_mark+2),a  
2d8b 18 03			jr .pastdmark  
2d8d ..			.dmark: db "IF5"  
2d90 f1			.pastdmark: pop af  
2d91			endm  
# End of macro DMARK
2d91						CALLMONITOR 
2d91 cd 9d 17			call break_point_state  
2d94				endm  
# End of macro CALLMONITOR
2d94					endif 
2d94				; replace below with ) exec using tok_ptr 
2d94 22 d5 f5			ld (os_tok_ptr), hl 
2d97 c3 05 22			jp exec1 
2d9a			 
2d9a .. 00			.closepar:   db ")",0 
2d9c			 
2d9c				       NEXTW 
2d9c c3 74 21			jp macro_next 
2d9f				endm 
# End of macro NEXTW
2d9f			.COMC: 
2d9f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2d9f 6f				db WORD_SYS_CORE+91             
2da0 a8 2d			dw .SCRATCH            
2da2 02				db 1 + 1 
2da3 .. 00			db ")",0              
2da5				endm 
# End of macro CWHEAD
2da5			; | ) ( -- )  End of comment |  DONE  
2da5				       NEXTW 
2da5 c3 74 21			jp macro_next 
2da8				endm 
# End of macro NEXTW
2da8			 
2da8			.SCRATCH: 
2da8				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2da8 6f				db WORD_SYS_CORE+91             
2da9 e3 2d			dw .INC            
2dab 08				db 7 + 1 
2dac .. 00			db "SCRATCH",0              
2db4				endm 
# End of macro CWHEAD
2db4			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2db4			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2db4			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2db4			; | |  
2db4			; | | e.g.    : score $00 scratch ; 
2db4			; | |  
2db4			; | | $00 score ! 
2db4			; | | $01 score +! 
2db4			; | |  
2db4			; | | e.g.   : varword $0a scratch ;  
2db4			; | | 
2db4			; | | $8000 varword ! 
2db4					if DEBUG_FORTH_WORDS_KEY 
2db4						DMARK "SCR" 
2db4 f5				push af  
2db5 3a c9 2d			ld a, (.dmark)  
2db8 32 6e fe			ld (debug_mark),a  
2dbb 3a ca 2d			ld a, (.dmark+1)  
2dbe 32 6f fe			ld (debug_mark+1),a  
2dc1 3a cb 2d			ld a, (.dmark+2)  
2dc4 32 70 fe			ld (debug_mark+2),a  
2dc7 18 03			jr .pastdmark  
2dc9 ..			.dmark: db "SCR"  
2dcc f1			.pastdmark: pop af  
2dcd			endm  
# End of macro DMARK
2dcd						CALLMONITOR 
2dcd cd 9d 17			call break_point_state  
2dd0				endm  
# End of macro CALLMONITOR
2dd0					endif 
2dd0			 
2dd0					FORTH_DSP_VALUEHL 
2dd0 cd 02 20			call macro_dsp_valuehl 
2dd3				endm 
# End of macro FORTH_DSP_VALUEHL
2dd3				 
2dd3					FORTH_DSP_POP 
2dd3 cd ba 20			call macro_forth_dsp_pop 
2dd6				endm 
# End of macro FORTH_DSP_POP
2dd6			 
2dd6 7d					ld a, l 
2dd7 21 f9 f7				ld hl, os_var_array 
2dda cd f6 0d				call addatohl 
2ddd			 
2ddd cd 0b 1e				call forth_push_numhl 
2de0			 
2de0				       NEXTW 
2de0 c3 74 21			jp macro_next 
2de3				endm 
# End of macro NEXTW
2de3			 
2de3			.INC: 
2de3				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2de3 6f				db WORD_SYS_CORE+91             
2de4 37 2e			dw .DEC            
2de6 03				db 2 + 1 
2de7 .. 00			db "+!",0              
2dea				endm 
# End of macro CWHEAD
2dea			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2dea					if DEBUG_FORTH_WORDS_KEY 
2dea						DMARK "+s_" 
2dea f5				push af  
2deb 3a ff 2d			ld a, (.dmark)  
2dee 32 6e fe			ld (debug_mark),a  
2df1 3a 00 2e			ld a, (.dmark+1)  
2df4 32 6f fe			ld (debug_mark+1),a  
2df7 3a 01 2e			ld a, (.dmark+2)  
2dfa 32 70 fe			ld (debug_mark+2),a  
2dfd 18 03			jr .pastdmark  
2dff ..			.dmark: db "+s_"  
2e02 f1			.pastdmark: pop af  
2e03			endm  
# End of macro DMARK
2e03						CALLMONITOR 
2e03 cd 9d 17			call break_point_state  
2e06				endm  
# End of macro CALLMONITOR
2e06					endif 
2e06			 
2e06					FORTH_DSP_VALUEHL 
2e06 cd 02 20			call macro_dsp_valuehl 
2e09				endm 
# End of macro FORTH_DSP_VALUEHL
2e09			 
2e09 e5					push hl   ; save address 
2e0a			 
2e0a					FORTH_DSP_POP 
2e0a cd ba 20			call macro_forth_dsp_pop 
2e0d				endm 
# End of macro FORTH_DSP_POP
2e0d			 
2e0d					FORTH_DSP_VALUEHL 
2e0d cd 02 20			call macro_dsp_valuehl 
2e10				endm 
# End of macro FORTH_DSP_VALUEHL
2e10			 
2e10					FORTH_DSP_POP 
2e10 cd ba 20			call macro_forth_dsp_pop 
2e13				endm 
# End of macro FORTH_DSP_POP
2e13			 
2e13					; hl contains value to add to byte at a 
2e13				 
2e13 eb					ex de, hl 
2e14			 
2e14 e1					pop hl 
2e15			 
2e15					if DEBUG_FORTH_WORDS 
2e15						DMARK "INC" 
2e15 f5				push af  
2e16 3a 2a 2e			ld a, (.dmark)  
2e19 32 6e fe			ld (debug_mark),a  
2e1c 3a 2b 2e			ld a, (.dmark+1)  
2e1f 32 6f fe			ld (debug_mark+1),a  
2e22 3a 2c 2e			ld a, (.dmark+2)  
2e25 32 70 fe			ld (debug_mark+2),a  
2e28 18 03			jr .pastdmark  
2e2a ..			.dmark: db "INC"  
2e2d f1			.pastdmark: pop af  
2e2e			endm  
# End of macro DMARK
2e2e						CALLMONITOR 
2e2e cd 9d 17			call break_point_state  
2e31				endm  
# End of macro CALLMONITOR
2e31					endif 
2e31			 
2e31 7e					ld a,(hl) 
2e32 83					add e 
2e33 77					ld (hl),a 
2e34			 
2e34			 
2e34			 
2e34				       NEXTW 
2e34 c3 74 21			jp macro_next 
2e37				endm 
# End of macro NEXTW
2e37			 
2e37			.DEC: 
2e37				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2e37 6f				db WORD_SYS_CORE+91             
2e38 88 2e			dw .INC2            
2e3a 03				db 2 + 1 
2e3b .. 00			db "-!",0              
2e3e				endm 
# End of macro CWHEAD
2e3e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2e3e					if DEBUG_FORTH_WORDS_KEY 
2e3e						DMARK "-s_" 
2e3e f5				push af  
2e3f 3a 53 2e			ld a, (.dmark)  
2e42 32 6e fe			ld (debug_mark),a  
2e45 3a 54 2e			ld a, (.dmark+1)  
2e48 32 6f fe			ld (debug_mark+1),a  
2e4b 3a 55 2e			ld a, (.dmark+2)  
2e4e 32 70 fe			ld (debug_mark+2),a  
2e51 18 03			jr .pastdmark  
2e53 ..			.dmark: db "-s_"  
2e56 f1			.pastdmark: pop af  
2e57			endm  
# End of macro DMARK
2e57						CALLMONITOR 
2e57 cd 9d 17			call break_point_state  
2e5a				endm  
# End of macro CALLMONITOR
2e5a					endif 
2e5a			 
2e5a					FORTH_DSP_VALUEHL 
2e5a cd 02 20			call macro_dsp_valuehl 
2e5d				endm 
# End of macro FORTH_DSP_VALUEHL
2e5d			 
2e5d e5					push hl   ; save address 
2e5e			 
2e5e					FORTH_DSP_POP 
2e5e cd ba 20			call macro_forth_dsp_pop 
2e61				endm 
# End of macro FORTH_DSP_POP
2e61			 
2e61					FORTH_DSP_VALUEHL 
2e61 cd 02 20			call macro_dsp_valuehl 
2e64				endm 
# End of macro FORTH_DSP_VALUEHL
2e64			 
2e64					; hl contains value to add to byte at a 
2e64				 
2e64 eb					ex de, hl 
2e65			 
2e65 e1					pop hl 
2e66			 
2e66					if DEBUG_FORTH_WORDS 
2e66						DMARK "DEC" 
2e66 f5				push af  
2e67 3a 7b 2e			ld a, (.dmark)  
2e6a 32 6e fe			ld (debug_mark),a  
2e6d 3a 7c 2e			ld a, (.dmark+1)  
2e70 32 6f fe			ld (debug_mark+1),a  
2e73 3a 7d 2e			ld a, (.dmark+2)  
2e76 32 70 fe			ld (debug_mark+2),a  
2e79 18 03			jr .pastdmark  
2e7b ..			.dmark: db "DEC"  
2e7e f1			.pastdmark: pop af  
2e7f			endm  
# End of macro DMARK
2e7f						CALLMONITOR 
2e7f cd 9d 17			call break_point_state  
2e82				endm  
# End of macro CALLMONITOR
2e82					endif 
2e82			 
2e82 7e					ld a,(hl) 
2e83 93					sub e 
2e84 77					ld (hl),a 
2e85			 
2e85			 
2e85			 
2e85				       NEXTW 
2e85 c3 74 21			jp macro_next 
2e88				endm 
# End of macro NEXTW
2e88			 
2e88			.INC2: 
2e88				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2e88 6f				db WORD_SYS_CORE+91             
2e89 32 2f			dw .DEC2            
2e8b 04				db 3 + 1 
2e8c .. 00			db "+2!",0              
2e90				endm 
# End of macro CWHEAD
2e90			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2e90			 
2e90					if DEBUG_FORTH_WORDS_KEY 
2e90						DMARK "+2s" 
2e90 f5				push af  
2e91 3a a5 2e			ld a, (.dmark)  
2e94 32 6e fe			ld (debug_mark),a  
2e97 3a a6 2e			ld a, (.dmark+1)  
2e9a 32 6f fe			ld (debug_mark+1),a  
2e9d 3a a7 2e			ld a, (.dmark+2)  
2ea0 32 70 fe			ld (debug_mark+2),a  
2ea3 18 03			jr .pastdmark  
2ea5 ..			.dmark: db "+2s"  
2ea8 f1			.pastdmark: pop af  
2ea9			endm  
# End of macro DMARK
2ea9						CALLMONITOR 
2ea9 cd 9d 17			call break_point_state  
2eac				endm  
# End of macro CALLMONITOR
2eac					endif 
2eac			 
2eac					; Address 
2eac			 
2eac					FORTH_DSP_VALUEHL 
2eac cd 02 20			call macro_dsp_valuehl 
2eaf				endm 
# End of macro FORTH_DSP_VALUEHL
2eaf			 
2eaf e5					push hl    ; save address 
2eb0			 
2eb0					; load content into de 
2eb0			 
2eb0 5e					ld e,(hl) 
2eb1 23					inc hl 
2eb2 56					ld d, (hl) 
2eb3			 
2eb3					if DEBUG_FORTH_WORDS 
2eb3						DMARK "+2a" 
2eb3 f5				push af  
2eb4 3a c8 2e			ld a, (.dmark)  
2eb7 32 6e fe			ld (debug_mark),a  
2eba 3a c9 2e			ld a, (.dmark+1)  
2ebd 32 6f fe			ld (debug_mark+1),a  
2ec0 3a ca 2e			ld a, (.dmark+2)  
2ec3 32 70 fe			ld (debug_mark+2),a  
2ec6 18 03			jr .pastdmark  
2ec8 ..			.dmark: db "+2a"  
2ecb f1			.pastdmark: pop af  
2ecc			endm  
# End of macro DMARK
2ecc						CALLMONITOR 
2ecc cd 9d 17			call break_point_state  
2ecf				endm  
# End of macro CALLMONITOR
2ecf					endif 
2ecf			 
2ecf					FORTH_DSP_POP 
2ecf cd ba 20			call macro_forth_dsp_pop 
2ed2				endm 
# End of macro FORTH_DSP_POP
2ed2			 
2ed2					; Get value to add 
2ed2			 
2ed2					FORTH_DSP_VALUE 
2ed2 cd eb 1f			call macro_forth_dsp_value 
2ed5				endm 
# End of macro FORTH_DSP_VALUE
2ed5			 
2ed5					if DEBUG_FORTH_WORDS 
2ed5						DMARK "+2v" 
2ed5 f5				push af  
2ed6 3a ea 2e			ld a, (.dmark)  
2ed9 32 6e fe			ld (debug_mark),a  
2edc 3a eb 2e			ld a, (.dmark+1)  
2edf 32 6f fe			ld (debug_mark+1),a  
2ee2 3a ec 2e			ld a, (.dmark+2)  
2ee5 32 70 fe			ld (debug_mark+2),a  
2ee8 18 03			jr .pastdmark  
2eea ..			.dmark: db "+2v"  
2eed f1			.pastdmark: pop af  
2eee			endm  
# End of macro DMARK
2eee						CALLMONITOR 
2eee cd 9d 17			call break_point_state  
2ef1				endm  
# End of macro CALLMONITOR
2ef1					endif 
2ef1			 
2ef1 19					add hl, de 
2ef2			 
2ef2					if DEBUG_FORTH_WORDS 
2ef2						DMARK "+2+" 
2ef2 f5				push af  
2ef3 3a 07 2f			ld a, (.dmark)  
2ef6 32 6e fe			ld (debug_mark),a  
2ef9 3a 08 2f			ld a, (.dmark+1)  
2efc 32 6f fe			ld (debug_mark+1),a  
2eff 3a 09 2f			ld a, (.dmark+2)  
2f02 32 70 fe			ld (debug_mark+2),a  
2f05 18 03			jr .pastdmark  
2f07 ..			.dmark: db "+2+"  
2f0a f1			.pastdmark: pop af  
2f0b			endm  
# End of macro DMARK
2f0b						CALLMONITOR 
2f0b cd 9d 17			call break_point_state  
2f0e				endm  
# End of macro CALLMONITOR
2f0e					endif 
2f0e			 
2f0e					; move result to de 
2f0e			 
2f0e eb					ex de, hl 
2f0f			 
2f0f					; Address 
2f0f			 
2f0f e1					pop hl 
2f10			 
2f10					; save it back 
2f10			 
2f10 73					ld (hl), e 
2f11 23					inc hl 
2f12 72					ld (hl), d 
2f13			 
2f13					if DEBUG_FORTH_WORDS 
2f13						DMARK "+2e" 
2f13 f5				push af  
2f14 3a 28 2f			ld a, (.dmark)  
2f17 32 6e fe			ld (debug_mark),a  
2f1a 3a 29 2f			ld a, (.dmark+1)  
2f1d 32 6f fe			ld (debug_mark+1),a  
2f20 3a 2a 2f			ld a, (.dmark+2)  
2f23 32 70 fe			ld (debug_mark+2),a  
2f26 18 03			jr .pastdmark  
2f28 ..			.dmark: db "+2e"  
2f2b f1			.pastdmark: pop af  
2f2c			endm  
# End of macro DMARK
2f2c						CALLMONITOR 
2f2c cd 9d 17			call break_point_state  
2f2f				endm  
# End of macro CALLMONITOR
2f2f					endif 
2f2f			 
2f2f			 
2f2f			 
2f2f			 
2f2f			 
2f2f				       NEXTW 
2f2f c3 74 21			jp macro_next 
2f32				endm 
# End of macro NEXTW
2f32			 
2f32			.DEC2: 
2f32				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2f32 6f				db WORD_SYS_CORE+91             
2f33 de 2f			dw .GET2            
2f35 04				db 3 + 1 
2f36 .. 00			db "-2!",0              
2f3a				endm 
# End of macro CWHEAD
2f3a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2f3a			 
2f3a			 
2f3a					if DEBUG_FORTH_WORDS_KEY 
2f3a						DMARK "-2s" 
2f3a f5				push af  
2f3b 3a 4f 2f			ld a, (.dmark)  
2f3e 32 6e fe			ld (debug_mark),a  
2f41 3a 50 2f			ld a, (.dmark+1)  
2f44 32 6f fe			ld (debug_mark+1),a  
2f47 3a 51 2f			ld a, (.dmark+2)  
2f4a 32 70 fe			ld (debug_mark+2),a  
2f4d 18 03			jr .pastdmark  
2f4f ..			.dmark: db "-2s"  
2f52 f1			.pastdmark: pop af  
2f53			endm  
# End of macro DMARK
2f53						CALLMONITOR 
2f53 cd 9d 17			call break_point_state  
2f56				endm  
# End of macro CALLMONITOR
2f56					endif 
2f56			 
2f56					; Address 
2f56			 
2f56					FORTH_DSP_VALUEHL 
2f56 cd 02 20			call macro_dsp_valuehl 
2f59				endm 
# End of macro FORTH_DSP_VALUEHL
2f59			 
2f59 e5					push hl    ; save address 
2f5a			 
2f5a					; load content into de 
2f5a			 
2f5a 5e					ld e,(hl) 
2f5b 23					inc hl 
2f5c 56					ld d, (hl) 
2f5d			 
2f5d					if DEBUG_FORTH_WORDS 
2f5d						DMARK "-2a" 
2f5d f5				push af  
2f5e 3a 72 2f			ld a, (.dmark)  
2f61 32 6e fe			ld (debug_mark),a  
2f64 3a 73 2f			ld a, (.dmark+1)  
2f67 32 6f fe			ld (debug_mark+1),a  
2f6a 3a 74 2f			ld a, (.dmark+2)  
2f6d 32 70 fe			ld (debug_mark+2),a  
2f70 18 03			jr .pastdmark  
2f72 ..			.dmark: db "-2a"  
2f75 f1			.pastdmark: pop af  
2f76			endm  
# End of macro DMARK
2f76						CALLMONITOR 
2f76 cd 9d 17			call break_point_state  
2f79				endm  
# End of macro CALLMONITOR
2f79					endif 
2f79			 
2f79					FORTH_DSP_POP 
2f79 cd ba 20			call macro_forth_dsp_pop 
2f7c				endm 
# End of macro FORTH_DSP_POP
2f7c			 
2f7c					; Get value to remove 
2f7c			 
2f7c					FORTH_DSP_VALUE 
2f7c cd eb 1f			call macro_forth_dsp_value 
2f7f				endm 
# End of macro FORTH_DSP_VALUE
2f7f			 
2f7f					if DEBUG_FORTH_WORDS 
2f7f						DMARK "-2v" 
2f7f f5				push af  
2f80 3a 94 2f			ld a, (.dmark)  
2f83 32 6e fe			ld (debug_mark),a  
2f86 3a 95 2f			ld a, (.dmark+1)  
2f89 32 6f fe			ld (debug_mark+1),a  
2f8c 3a 96 2f			ld a, (.dmark+2)  
2f8f 32 70 fe			ld (debug_mark+2),a  
2f92 18 03			jr .pastdmark  
2f94 ..			.dmark: db "-2v"  
2f97 f1			.pastdmark: pop af  
2f98			endm  
# End of macro DMARK
2f98						CALLMONITOR 
2f98 cd 9d 17			call break_point_state  
2f9b				endm  
# End of macro CALLMONITOR
2f9b					endif 
2f9b			 
2f9b eb					ex de, hl 
2f9c ed 52				sbc hl, de 
2f9e			 
2f9e					if DEBUG_FORTH_WORDS 
2f9e						DMARK "-2d" 
2f9e f5				push af  
2f9f 3a b3 2f			ld a, (.dmark)  
2fa2 32 6e fe			ld (debug_mark),a  
2fa5 3a b4 2f			ld a, (.dmark+1)  
2fa8 32 6f fe			ld (debug_mark+1),a  
2fab 3a b5 2f			ld a, (.dmark+2)  
2fae 32 70 fe			ld (debug_mark+2),a  
2fb1 18 03			jr .pastdmark  
2fb3 ..			.dmark: db "-2d"  
2fb6 f1			.pastdmark: pop af  
2fb7			endm  
# End of macro DMARK
2fb7						CALLMONITOR 
2fb7 cd 9d 17			call break_point_state  
2fba				endm  
# End of macro CALLMONITOR
2fba					endif 
2fba			 
2fba					; move result to de 
2fba			 
2fba eb					ex de, hl 
2fbb			 
2fbb					; Address 
2fbb			 
2fbb e1					pop hl 
2fbc			 
2fbc					; save it back 
2fbc			 
2fbc 73					ld (hl), e 
2fbd 23					inc hl 
2fbe 72					ld (hl), d 
2fbf			 
2fbf					if DEBUG_FORTH_WORDS 
2fbf						DMARK "-2e" 
2fbf f5				push af  
2fc0 3a d4 2f			ld a, (.dmark)  
2fc3 32 6e fe			ld (debug_mark),a  
2fc6 3a d5 2f			ld a, (.dmark+1)  
2fc9 32 6f fe			ld (debug_mark+1),a  
2fcc 3a d6 2f			ld a, (.dmark+2)  
2fcf 32 70 fe			ld (debug_mark+2),a  
2fd2 18 03			jr .pastdmark  
2fd4 ..			.dmark: db "-2e"  
2fd7 f1			.pastdmark: pop af  
2fd8			endm  
# End of macro DMARK
2fd8						CALLMONITOR 
2fd8 cd 9d 17			call break_point_state  
2fdb				endm  
# End of macro CALLMONITOR
2fdb					endif 
2fdb			 
2fdb			 
2fdb			 
2fdb			 
2fdb			 
2fdb				       NEXTW 
2fdb c3 74 21			jp macro_next 
2fde				endm 
# End of macro NEXTW
2fde			.GET2: 
2fde				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2fde 6f				db WORD_SYS_CORE+91             
2fdf 0e 30			dw .BANG2            
2fe1 03				db 2 + 1 
2fe2 .. 00			db "2@",0              
2fe5				endm 
# End of macro CWHEAD
2fe5			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2fe5					if DEBUG_FORTH_WORDS_KEY 
2fe5						DMARK "2A_" 
2fe5 f5				push af  
2fe6 3a fa 2f			ld a, (.dmark)  
2fe9 32 6e fe			ld (debug_mark),a  
2fec 3a fb 2f			ld a, (.dmark+1)  
2fef 32 6f fe			ld (debug_mark+1),a  
2ff2 3a fc 2f			ld a, (.dmark+2)  
2ff5 32 70 fe			ld (debug_mark+2),a  
2ff8 18 03			jr .pastdmark  
2ffa ..			.dmark: db "2A_"  
2ffd f1			.pastdmark: pop af  
2ffe			endm  
# End of macro DMARK
2ffe						CALLMONITOR 
2ffe cd 9d 17			call break_point_state  
3001				endm  
# End of macro CALLMONITOR
3001					endif 
3001			 
3001					FORTH_DSP_VALUEHL 
3001 cd 02 20			call macro_dsp_valuehl 
3004				endm 
# End of macro FORTH_DSP_VALUEHL
3004			 
3004 5e					ld e, (hl) 
3005 23					inc hl 
3006 56					ld d, (hl) 
3007			 
3007 eb					ex de, hl 
3008			 
3008 cd 0b 1e				call forth_push_numhl 
300b			 
300b				       NEXTW 
300b c3 74 21			jp macro_next 
300e				endm 
# End of macro NEXTW
300e			.BANG2: 
300e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
300e 6f				db WORD_SYS_CORE+91             
300f 46 30			dw .CONFIG            
3011 03				db 2 + 1 
3012 .. 00			db "2!",0              
3015				endm 
# End of macro CWHEAD
3015			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3015					if DEBUG_FORTH_WORDS_KEY 
3015						DMARK "2S_" 
3015 f5				push af  
3016 3a 2a 30			ld a, (.dmark)  
3019 32 6e fe			ld (debug_mark),a  
301c 3a 2b 30			ld a, (.dmark+1)  
301f 32 6f fe			ld (debug_mark+1),a  
3022 3a 2c 30			ld a, (.dmark+2)  
3025 32 70 fe			ld (debug_mark+2),a  
3028 18 03			jr .pastdmark  
302a ..			.dmark: db "2S_"  
302d f1			.pastdmark: pop af  
302e			endm  
# End of macro DMARK
302e						CALLMONITOR 
302e cd 9d 17			call break_point_state  
3031				endm  
# End of macro CALLMONITOR
3031					endif 
3031			 
3031					FORTH_DSP_VALUEHL 
3031 cd 02 20			call macro_dsp_valuehl 
3034				endm 
# End of macro FORTH_DSP_VALUEHL
3034			 
3034 e5					push hl   ; save address 
3035			 
3035			 
3035					FORTH_DSP_POP 
3035 cd ba 20			call macro_forth_dsp_pop 
3038				endm 
# End of macro FORTH_DSP_POP
3038			 
3038					 
3038					FORTH_DSP_VALUEHL 
3038 cd 02 20			call macro_dsp_valuehl 
303b				endm 
# End of macro FORTH_DSP_VALUEHL
303b			 
303b					FORTH_DSP_POP 
303b cd ba 20			call macro_forth_dsp_pop 
303e				endm 
# End of macro FORTH_DSP_POP
303e			 
303e eb					ex de, hl    ; value now in de 
303f			 
303f e1					pop hl 
3040			 
3040 73					ld (hl), e 
3041			 
3041 23					inc hl 
3042			 
3042 72					ld (hl), d 
3043			 
3043			 
3043				       NEXTW 
3043 c3 74 21			jp macro_next 
3046				endm 
# End of macro NEXTW
3046			.CONFIG: 
3046				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3046 6f				db WORD_SYS_CORE+91             
3047 57 30			dw .ENDCORE            
3049 07				db 6 + 1 
304a .. 00			db "CONFIG",0              
3051				endm 
# End of macro CWHEAD
3051			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3051			 
3051 cd 80 14				call config 
3054					NEXTW 
3054 c3 74 21			jp macro_next 
3057				endm 
# End of macro NEXTW
3057			.ENDCORE: 
3057			 
3057			; eof 
3057			 
3057			 
# End of file forth_words_core.asm
3057			include "forth_words_flow.asm" 
3057			 
3057			; | ## Program Flow Words 
3057			 
3057			.IF: 
3057				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3057 1e				db WORD_SYS_CORE+10             
3058 4c 31			dw .THEN            
305a 03				db 2 + 1 
305b .. 00			db "IF",0              
305e				endm 
# End of macro CWHEAD
305e			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
305e			; 
305e					if DEBUG_FORTH_WORDS_KEY 
305e						DMARK "IF." 
305e f5				push af  
305f 3a 73 30			ld a, (.dmark)  
3062 32 6e fe			ld (debug_mark),a  
3065 3a 74 30			ld a, (.dmark+1)  
3068 32 6f fe			ld (debug_mark+1),a  
306b 3a 75 30			ld a, (.dmark+2)  
306e 32 70 fe			ld (debug_mark+2),a  
3071 18 03			jr .pastdmark  
3073 ..			.dmark: db "IF."  
3076 f1			.pastdmark: pop af  
3077			endm  
# End of macro DMARK
3077						CALLMONITOR 
3077 cd 9d 17			call break_point_state  
307a				endm  
# End of macro CALLMONITOR
307a					endif 
307a			; eval TOS 
307a			 
307a				FORTH_DSP_VALUEHL 
307a cd 02 20			call macro_dsp_valuehl 
307d				endm 
# End of macro FORTH_DSP_VALUEHL
307d			 
307d			;	push hl 
307d				FORTH_DSP_POP 
307d cd ba 20			call macro_forth_dsp_pop 
3080				endm 
# End of macro FORTH_DSP_POP
3080			;	pop hl 
3080			 
3080					if DEBUG_FORTH_WORDS 
3080						DMARK "IF1" 
3080 f5				push af  
3081 3a 95 30			ld a, (.dmark)  
3084 32 6e fe			ld (debug_mark),a  
3087 3a 96 30			ld a, (.dmark+1)  
308a 32 6f fe			ld (debug_mark+1),a  
308d 3a 97 30			ld a, (.dmark+2)  
3090 32 70 fe			ld (debug_mark+2),a  
3093 18 03			jr .pastdmark  
3095 ..			.dmark: db "IF1"  
3098 f1			.pastdmark: pop af  
3099			endm  
# End of macro DMARK
3099						CALLMONITOR 
3099 cd 9d 17			call break_point_state  
309c				endm  
# End of macro CALLMONITOR
309c					endif 
309c b7				or a        ; clear carry flag 
309d 11 00 00			ld de, 0 
30a0 eb				ex de,hl 
30a1 ed 52			sbc hl, de 
30a3 c2 2d 31			jp nz, .iftrue 
30a6			 
30a6					if DEBUG_FORTH_WORDS 
30a6						DMARK "IF2" 
30a6 f5				push af  
30a7 3a bb 30			ld a, (.dmark)  
30aa 32 6e fe			ld (debug_mark),a  
30ad 3a bc 30			ld a, (.dmark+1)  
30b0 32 6f fe			ld (debug_mark+1),a  
30b3 3a bd 30			ld a, (.dmark+2)  
30b6 32 70 fe			ld (debug_mark+2),a  
30b9 18 03			jr .pastdmark  
30bb ..			.dmark: db "IF2"  
30be f1			.pastdmark: pop af  
30bf			endm  
# End of macro DMARK
30bf						CALLMONITOR 
30bf cd 9d 17			call break_point_state  
30c2				endm  
# End of macro CALLMONITOR
30c2					endif 
30c2			 
30c2			; if not true then skip to THEN 
30c2			 
30c2				; TODO get tok_ptr 
30c2				; TODO consume toks until we get to THEN 
30c2			 
30c2 2a d5 f5			ld hl, (os_tok_ptr) 
30c5					if DEBUG_FORTH_WORDS 
30c5						DMARK "IF3" 
30c5 f5				push af  
30c6 3a da 30			ld a, (.dmark)  
30c9 32 6e fe			ld (debug_mark),a  
30cc 3a db 30			ld a, (.dmark+1)  
30cf 32 6f fe			ld (debug_mark+1),a  
30d2 3a dc 30			ld a, (.dmark+2)  
30d5 32 70 fe			ld (debug_mark+2),a  
30d8 18 03			jr .pastdmark  
30da ..			.dmark: db "IF3"  
30dd f1			.pastdmark: pop af  
30de			endm  
# End of macro DMARK
30de						CALLMONITOR 
30de cd 9d 17			call break_point_state  
30e1				endm  
# End of macro CALLMONITOR
30e1						 
30e1					endif 
30e1 11 28 31			ld de, .ifthen 
30e4					if DEBUG_FORTH_WORDS 
30e4						DMARK "IF4" 
30e4 f5				push af  
30e5 3a f9 30			ld a, (.dmark)  
30e8 32 6e fe			ld (debug_mark),a  
30eb 3a fa 30			ld a, (.dmark+1)  
30ee 32 6f fe			ld (debug_mark+1),a  
30f1 3a fb 30			ld a, (.dmark+2)  
30f4 32 70 fe			ld (debug_mark+2),a  
30f7 18 03			jr .pastdmark  
30f9 ..			.dmark: db "IF4"  
30fc f1			.pastdmark: pop af  
30fd			endm  
# End of macro DMARK
30fd						CALLMONITOR 
30fd cd 9d 17			call break_point_state  
3100				endm  
# End of macro CALLMONITOR
3100					endif 
3100 cd 8f 22			call findnexttok  
3103			 
3103					if DEBUG_FORTH_WORDS 
3103						DMARK "IF5" 
3103 f5				push af  
3104 3a 18 31			ld a, (.dmark)  
3107 32 6e fe			ld (debug_mark),a  
310a 3a 19 31			ld a, (.dmark+1)  
310d 32 6f fe			ld (debug_mark+1),a  
3110 3a 1a 31			ld a, (.dmark+2)  
3113 32 70 fe			ld (debug_mark+2),a  
3116 18 03			jr .pastdmark  
3118 ..			.dmark: db "IF5"  
311b f1			.pastdmark: pop af  
311c			endm  
# End of macro DMARK
311c						CALLMONITOR 
311c cd 9d 17			call break_point_state  
311f				endm  
# End of macro CALLMONITOR
311f					endif 
311f				; TODO replace below with ; exec using tok_ptr 
311f 22 d5 f5			ld (os_tok_ptr), hl 
3122 c3 05 22			jp exec1 
3125				NEXTW 
3125 c3 74 21			jp macro_next 
3128				endm 
# End of macro NEXTW
3128			 
3128 .. 00		.ifthen:  db "THEN",0 
312d			 
312d			.iftrue:		 
312d				; Exec next words normally 
312d			 
312d				; if true then exec following IF as normal 
312d					if DEBUG_FORTH_WORDS 
312d						DMARK "IFT" 
312d f5				push af  
312e 3a 42 31			ld a, (.dmark)  
3131 32 6e fe			ld (debug_mark),a  
3134 3a 43 31			ld a, (.dmark+1)  
3137 32 6f fe			ld (debug_mark+1),a  
313a 3a 44 31			ld a, (.dmark+2)  
313d 32 70 fe			ld (debug_mark+2),a  
3140 18 03			jr .pastdmark  
3142 ..			.dmark: db "IFT"  
3145 f1			.pastdmark: pop af  
3146			endm  
# End of macro DMARK
3146						CALLMONITOR 
3146 cd 9d 17			call break_point_state  
3149				endm  
# End of macro CALLMONITOR
3149					endif 
3149			 
3149					NEXTW 
3149 c3 74 21			jp macro_next 
314c				endm 
# End of macro NEXTW
314c			.THEN: 
314c				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
314c 1f				db WORD_SYS_CORE+11             
314d 74 31			dw .ELSE            
314f 05				db 4 + 1 
3150 .. 00			db "THEN",0              
3155				endm 
# End of macro CWHEAD
3155			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3155					if DEBUG_FORTH_WORDS_KEY 
3155						DMARK "THN" 
3155 f5				push af  
3156 3a 6a 31			ld a, (.dmark)  
3159 32 6e fe			ld (debug_mark),a  
315c 3a 6b 31			ld a, (.dmark+1)  
315f 32 6f fe			ld (debug_mark+1),a  
3162 3a 6c 31			ld a, (.dmark+2)  
3165 32 70 fe			ld (debug_mark+2),a  
3168 18 03			jr .pastdmark  
316a ..			.dmark: db "THN"  
316d f1			.pastdmark: pop af  
316e			endm  
# End of macro DMARK
316e						CALLMONITOR 
316e cd 9d 17			call break_point_state  
3171				endm  
# End of macro CALLMONITOR
3171					endif 
3171					NEXTW 
3171 c3 74 21			jp macro_next 
3174				endm 
# End of macro NEXTW
3174			.ELSE: 
3174				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3174 20				db WORD_SYS_CORE+12             
3175 9c 31			dw .DO            
3177 03				db 2 + 1 
3178 .. 00			db "ELSE",0              
317d				endm 
# End of macro CWHEAD
317d			; | ELSE ( -- ) Not supported - does nothing | TODO 
317d			 
317d					if DEBUG_FORTH_WORDS_KEY 
317d						DMARK "ELS" 
317d f5				push af  
317e 3a 92 31			ld a, (.dmark)  
3181 32 6e fe			ld (debug_mark),a  
3184 3a 93 31			ld a, (.dmark+1)  
3187 32 6f fe			ld (debug_mark+1),a  
318a 3a 94 31			ld a, (.dmark+2)  
318d 32 70 fe			ld (debug_mark+2),a  
3190 18 03			jr .pastdmark  
3192 ..			.dmark: db "ELS"  
3195 f1			.pastdmark: pop af  
3196			endm  
# End of macro DMARK
3196						CALLMONITOR 
3196 cd 9d 17			call break_point_state  
3199				endm  
# End of macro CALLMONITOR
3199					endif 
3199			 
3199			 
3199					NEXTW 
3199 c3 74 21			jp macro_next 
319c				endm 
# End of macro NEXTW
319c			.DO: 
319c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
319c 21				db WORD_SYS_CORE+13             
319d c3 32			dw .LOOP            
319f 03				db 2 + 1 
31a0 .. 00			db "DO",0              
31a3				endm 
# End of macro CWHEAD
31a3			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
31a3			 
31a3					if DEBUG_FORTH_WORDS_KEY 
31a3						DMARK "DO." 
31a3 f5				push af  
31a4 3a b8 31			ld a, (.dmark)  
31a7 32 6e fe			ld (debug_mark),a  
31aa 3a b9 31			ld a, (.dmark+1)  
31ad 32 6f fe			ld (debug_mark+1),a  
31b0 3a ba 31			ld a, (.dmark+2)  
31b3 32 70 fe			ld (debug_mark+2),a  
31b6 18 03			jr .pastdmark  
31b8 ..			.dmark: db "DO."  
31bb f1			.pastdmark: pop af  
31bc			endm  
# End of macro DMARK
31bc						CALLMONITOR 
31bc cd 9d 17			call break_point_state  
31bf				endm  
# End of macro CALLMONITOR
31bf					endif 
31bf			;  push pc to rsp stack past the DO 
31bf			 
31bf 2a d5 f5				ld hl, (os_tok_ptr) 
31c2 23					inc hl   ; D 
31c3 23					inc hl  ; O 
31c4 23					inc hl   ; null 
31c5					if DEBUG_FORTH_WORDS 
31c5						DMARK "DO2" 
31c5 f5				push af  
31c6 3a da 31			ld a, (.dmark)  
31c9 32 6e fe			ld (debug_mark),a  
31cc 3a db 31			ld a, (.dmark+1)  
31cf 32 6f fe			ld (debug_mark+1),a  
31d2 3a dc 31			ld a, (.dmark+2)  
31d5 32 70 fe			ld (debug_mark+2),a  
31d8 18 03			jr .pastdmark  
31da ..			.dmark: db "DO2"  
31dd f1			.pastdmark: pop af  
31de			endm  
# End of macro DMARK
31de						CALLMONITOR 
31de cd 9d 17			call break_point_state  
31e1				endm  
# End of macro CALLMONITOR
31e1					endif 
31e1					FORTH_RSP_NEXT 
31e1 cd b2 1d			call macro_forth_rsp_next 
31e4				endm 
# End of macro FORTH_RSP_NEXT
31e4					if DEBUG_FORTH_WORDS 
31e4						DMARK "DO3" 
31e4 f5				push af  
31e5 3a f9 31			ld a, (.dmark)  
31e8 32 6e fe			ld (debug_mark),a  
31eb 3a fa 31			ld a, (.dmark+1)  
31ee 32 6f fe			ld (debug_mark+1),a  
31f1 3a fb 31			ld a, (.dmark+2)  
31f4 32 70 fe			ld (debug_mark+2),a  
31f7 18 03			jr .pastdmark  
31f9 ..			.dmark: db "DO3"  
31fc f1			.pastdmark: pop af  
31fd			endm  
# End of macro DMARK
31fd						CALLMONITOR 
31fd cd 9d 17			call break_point_state  
3200				endm  
# End of macro CALLMONITOR
3200					endif 
3200			 
3200					;if DEBUG_FORTH_WORDS 
3200				;		push hl 
3200			;		endif  
3200			 
3200			; get counters from data stack 
3200			 
3200			 
3200					FORTH_DSP_VALUEHL 
3200 cd 02 20			call macro_dsp_valuehl 
3203				endm 
# End of macro FORTH_DSP_VALUEHL
3203 e5					push hl		 ; hl now has starting counter which needs to be tos 
3204			 
3204					if DEBUG_FORTH_WORDS 
3204						DMARK "DO4" 
3204 f5				push af  
3205 3a 19 32			ld a, (.dmark)  
3208 32 6e fe			ld (debug_mark),a  
320b 3a 1a 32			ld a, (.dmark+1)  
320e 32 6f fe			ld (debug_mark+1),a  
3211 3a 1b 32			ld a, (.dmark+2)  
3214 32 70 fe			ld (debug_mark+2),a  
3217 18 03			jr .pastdmark  
3219 ..			.dmark: db "DO4"  
321c f1			.pastdmark: pop af  
321d			endm  
# End of macro DMARK
321d						CALLMONITOR 
321d cd 9d 17			call break_point_state  
3220				endm  
# End of macro CALLMONITOR
3220					endif 
3220					FORTH_DSP_POP 
3220 cd ba 20			call macro_forth_dsp_pop 
3223				endm 
# End of macro FORTH_DSP_POP
3223			 
3223					if DEBUG_FORTH_WORDS 
3223						DMARK "DO5" 
3223 f5				push af  
3224 3a 38 32			ld a, (.dmark)  
3227 32 6e fe			ld (debug_mark),a  
322a 3a 39 32			ld a, (.dmark+1)  
322d 32 6f fe			ld (debug_mark+1),a  
3230 3a 3a 32			ld a, (.dmark+2)  
3233 32 70 fe			ld (debug_mark+2),a  
3236 18 03			jr .pastdmark  
3238 ..			.dmark: db "DO5"  
323b f1			.pastdmark: pop af  
323c			endm  
# End of macro DMARK
323c						CALLMONITOR 
323c cd 9d 17			call break_point_state  
323f				endm  
# End of macro CALLMONITOR
323f					endif 
323f			 
323f					FORTH_DSP_VALUEHL 
323f cd 02 20			call macro_dsp_valuehl 
3242				endm 
# End of macro FORTH_DSP_VALUEHL
3242			;		push hl		 ; hl now has starting limit counter 
3242			 
3242					if DEBUG_FORTH_WORDS 
3242						DMARK "DO6" 
3242 f5				push af  
3243 3a 57 32			ld a, (.dmark)  
3246 32 6e fe			ld (debug_mark),a  
3249 3a 58 32			ld a, (.dmark+1)  
324c 32 6f fe			ld (debug_mark+1),a  
324f 3a 59 32			ld a, (.dmark+2)  
3252 32 70 fe			ld (debug_mark+2),a  
3255 18 03			jr .pastdmark  
3257 ..			.dmark: db "DO6"  
325a f1			.pastdmark: pop af  
325b			endm  
# End of macro DMARK
325b						CALLMONITOR 
325b cd 9d 17			call break_point_state  
325e				endm  
# End of macro CALLMONITOR
325e					endif 
325e					FORTH_DSP_POP 
325e cd ba 20			call macro_forth_dsp_pop 
3261				endm 
# End of macro FORTH_DSP_POP
3261			 
3261			; put counters on the loop stack 
3261			 
3261			;		pop hl			 ; limit counter 
3261 d1					pop de			; start counter 
3262			 
3262					; push limit counter 
3262			 
3262					if DEBUG_FORTH_WORDS 
3262						DMARK "DO7" 
3262 f5				push af  
3263 3a 77 32			ld a, (.dmark)  
3266 32 6e fe			ld (debug_mark),a  
3269 3a 78 32			ld a, (.dmark+1)  
326c 32 6f fe			ld (debug_mark+1),a  
326f 3a 79 32			ld a, (.dmark+2)  
3272 32 70 fe			ld (debug_mark+2),a  
3275 18 03			jr .pastdmark  
3277 ..			.dmark: db "DO7"  
327a f1			.pastdmark: pop af  
327b			endm  
# End of macro DMARK
327b						CALLMONITOR 
327b cd 9d 17			call break_point_state  
327e				endm  
# End of macro CALLMONITOR
327e					endif 
327e					FORTH_LOOP_NEXT 
327e cd 33 20			call macro_forth_loop_next 
3281				endm 
# End of macro FORTH_LOOP_NEXT
3281			 
3281					; push start counter 
3281			 
3281 eb					ex de, hl 
3282					if DEBUG_FORTH_WORDS 
3282						DMARK "DO7" 
3282 f5				push af  
3283 3a 97 32			ld a, (.dmark)  
3286 32 6e fe			ld (debug_mark),a  
3289 3a 98 32			ld a, (.dmark+1)  
328c 32 6f fe			ld (debug_mark+1),a  
328f 3a 99 32			ld a, (.dmark+2)  
3292 32 70 fe			ld (debug_mark+2),a  
3295 18 03			jr .pastdmark  
3297 ..			.dmark: db "DO7"  
329a f1			.pastdmark: pop af  
329b			endm  
# End of macro DMARK
329b						CALLMONITOR 
329b cd 9d 17			call break_point_state  
329e				endm  
# End of macro CALLMONITOR
329e					endif 
329e					FORTH_LOOP_NEXT 
329e cd 33 20			call macro_forth_loop_next 
32a1				endm 
# End of macro FORTH_LOOP_NEXT
32a1			 
32a1			 
32a1					; init first round of I counter 
32a1			 
32a1 22 f9 f5				ld (os_current_i), hl 
32a4			 
32a4					if DEBUG_FORTH_WORDS 
32a4						DMARK "DO8" 
32a4 f5				push af  
32a5 3a b9 32			ld a, (.dmark)  
32a8 32 6e fe			ld (debug_mark),a  
32ab 3a ba 32			ld a, (.dmark+1)  
32ae 32 6f fe			ld (debug_mark+1),a  
32b1 3a bb 32			ld a, (.dmark+2)  
32b4 32 70 fe			ld (debug_mark+2),a  
32b7 18 03			jr .pastdmark  
32b9 ..			.dmark: db "DO8"  
32bc f1			.pastdmark: pop af  
32bd			endm  
# End of macro DMARK
32bd						CALLMONITOR 
32bd cd 9d 17			call break_point_state  
32c0				endm  
# End of macro CALLMONITOR
32c0					endif 
32c0			 
32c0					NEXTW 
32c0 c3 74 21			jp macro_next 
32c3				endm 
# End of macro NEXTW
32c3			.LOOP: 
32c3				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
32c3 22				db WORD_SYS_CORE+14             
32c4 db 33			dw .I            
32c6 05				db 4 + 1 
32c7 .. 00			db "LOOP",0              
32cc				endm 
# End of macro CWHEAD
32cc			; | LOOP ( -- ) Increment and test loop counter  | DONE 
32cc			 
32cc				; pop tos as current loop count to hl 
32cc			 
32cc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32cc			 
32cc				FORTH_LOOP_TOS 
32cc cd 66 20			call macro_forth_loop_tos 
32cf				endm 
# End of macro FORTH_LOOP_TOS
32cf e5				push hl 
32d0			 
32d0					if DEBUG_FORTH_WORDS_KEY 
32d0						DMARK "LOP" 
32d0 f5				push af  
32d1 3a e5 32			ld a, (.dmark)  
32d4 32 6e fe			ld (debug_mark),a  
32d7 3a e6 32			ld a, (.dmark+1)  
32da 32 6f fe			ld (debug_mark+1),a  
32dd 3a e7 32			ld a, (.dmark+2)  
32e0 32 70 fe			ld (debug_mark+2),a  
32e3 18 03			jr .pastdmark  
32e5 ..			.dmark: db "LOP"  
32e8 f1			.pastdmark: pop af  
32e9			endm  
# End of macro DMARK
32e9						CALLMONITOR 
32e9 cd 9d 17			call break_point_state  
32ec				endm  
# End of macro CALLMONITOR
32ec					endif 
32ec				; next item on the stack is the limit. get it 
32ec			 
32ec			 
32ec				FORTH_LOOP_POP 
32ec cd 70 20			call macro_forth_loop_pop 
32ef				endm 
# End of macro FORTH_LOOP_POP
32ef			 
32ef				FORTH_LOOP_TOS 
32ef cd 66 20			call macro_forth_loop_tos 
32f2				endm 
# End of macro FORTH_LOOP_TOS
32f2			 
32f2 d1				pop de		 ; de = i, hl = limit 
32f3			 
32f3					if DEBUG_FORTH_WORDS 
32f3						DMARK "LP1" 
32f3 f5				push af  
32f4 3a 08 33			ld a, (.dmark)  
32f7 32 6e fe			ld (debug_mark),a  
32fa 3a 09 33			ld a, (.dmark+1)  
32fd 32 6f fe			ld (debug_mark+1),a  
3300 3a 0a 33			ld a, (.dmark+2)  
3303 32 70 fe			ld (debug_mark+2),a  
3306 18 03			jr .pastdmark  
3308 ..			.dmark: db "LP1"  
330b f1			.pastdmark: pop af  
330c			endm  
# End of macro DMARK
330c						CALLMONITOR 
330c cd 9d 17			call break_point_state  
330f				endm  
# End of macro CALLMONITOR
330f					endif 
330f			 
330f				; go back to previous word 
330f			 
330f d5				push de    ; save I for inc later 
3310			 
3310			 
3310				; get limit 
3310				;  is I at limit? 
3310			 
3310			 
3310					if DEBUG_FORTH_WORDS 
3310						DMARK "LP1" 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 6e fe			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 6f fe			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 70 fe			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "LP1"  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329						CALLMONITOR 
3329 cd 9d 17			call break_point_state  
332c				endm  
# End of macro CALLMONITOR
332c					endif 
332c			 
332c ed 52			sbc hl, de 
332e			 
332e			 
332e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
332e			 
332e 20 26				jr nz, .loopnotdone 
3330			 
3330 e1				pop hl   ; get rid of saved I 
3331				FORTH_LOOP_POP     ; get rid of limit 
3331 cd 70 20			call macro_forth_loop_pop 
3334				endm 
# End of macro FORTH_LOOP_POP
3334			 
3334				FORTH_RSP_POP     ; get rid of DO ptr 
3334 cd d3 1d			call macro_forth_rsp_pop 
3337				endm 
# End of macro FORTH_RSP_POP
3337			 
3337			if DEBUG_FORTH_WORDS 
3337						DMARK "LP>" 
3337 f5				push af  
3338 3a 4c 33			ld a, (.dmark)  
333b 32 6e fe			ld (debug_mark),a  
333e 3a 4d 33			ld a, (.dmark+1)  
3341 32 6f fe			ld (debug_mark+1),a  
3344 3a 4e 33			ld a, (.dmark+2)  
3347 32 70 fe			ld (debug_mark+2),a  
334a 18 03			jr .pastdmark  
334c ..			.dmark: db "LP>"  
334f f1			.pastdmark: pop af  
3350			endm  
# End of macro DMARK
3350				CALLMONITOR 
3350 cd 9d 17			call break_point_state  
3353				endm  
# End of macro CALLMONITOR
3353			endif 
3353			 
3353					NEXTW 
3353 c3 74 21			jp macro_next 
3356				endm 
# End of macro NEXTW
3356				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3356			 
3356			.loopnotdone: 
3356			 
3356 e1				pop hl    ; get I 
3357 23				inc hl 
3358			 
3358			   	; save new I 
3358			 
3358			 
3358					; set I counter 
3358			 
3358 22 f9 f5				ld (os_current_i), hl 
335b			 
335b					if DEBUG_FORTH_WORDS 
335b						DMARK "LPN" 
335b f5				push af  
335c 3a 70 33			ld a, (.dmark)  
335f 32 6e fe			ld (debug_mark),a  
3362 3a 71 33			ld a, (.dmark+1)  
3365 32 6f fe			ld (debug_mark+1),a  
3368 3a 72 33			ld a, (.dmark+2)  
336b 32 70 fe			ld (debug_mark+2),a  
336e 18 03			jr .pastdmark  
3370 ..			.dmark: db "LPN"  
3373 f1			.pastdmark: pop af  
3374			endm  
# End of macro DMARK
3374					CALLMONITOR 
3374 cd 9d 17			call break_point_state  
3377				endm  
# End of macro CALLMONITOR
3377					endif 
3377					 
3377				FORTH_LOOP_NEXT 
3377 cd 33 20			call macro_forth_loop_next 
337a				endm 
# End of macro FORTH_LOOP_NEXT
337a			 
337a			 
337a					if DEBUG_FORTH_WORDS 
337a eb						ex de,hl 
337b					endif 
337b			 
337b			;	; get DO ptr 
337b			; 
337b					if DEBUG_FORTH_WORDS 
337b						DMARK "LP7" 
337b f5				push af  
337c 3a 90 33			ld a, (.dmark)  
337f 32 6e fe			ld (debug_mark),a  
3382 3a 91 33			ld a, (.dmark+1)  
3385 32 6f fe			ld (debug_mark+1),a  
3388 3a 92 33			ld a, (.dmark+2)  
338b 32 70 fe			ld (debug_mark+2),a  
338e 18 03			jr .pastdmark  
3390 ..			.dmark: db "LP7"  
3393 f1			.pastdmark: pop af  
3394			endm  
# End of macro DMARK
3394					CALLMONITOR 
3394 cd 9d 17			call break_point_state  
3397				endm  
# End of macro CALLMONITOR
3397					endif 
3397				FORTH_RSP_TOS 
3397 cd c9 1d			call macro_forth_rsp_tos 
339a				endm 
# End of macro FORTH_RSP_TOS
339a			 
339a					if DEBUG_FORTH_WORDS 
339a						DMARK "LP8" 
339a f5				push af  
339b 3a af 33			ld a, (.dmark)  
339e 32 6e fe			ld (debug_mark),a  
33a1 3a b0 33			ld a, (.dmark+1)  
33a4 32 6f fe			ld (debug_mark+1),a  
33a7 3a b1 33			ld a, (.dmark+2)  
33aa 32 70 fe			ld (debug_mark+2),a  
33ad 18 03			jr .pastdmark  
33af ..			.dmark: db "LP8"  
33b2 f1			.pastdmark: pop af  
33b3			endm  
# End of macro DMARK
33b3					CALLMONITOR 
33b3 cd 9d 17			call break_point_state  
33b6				endm  
# End of macro CALLMONITOR
33b6					endif 
33b6				;push hl 
33b6			 
33b6				; not going to DO any more 
33b6				; get rid of the RSP pointer as DO will add it back in 
33b6				;FORTH_RSP_POP 
33b6				;pop hl 
33b6			 
33b6				;ld hl,(cli_ret_sp) 
33b6				;ld e, (hl) 
33b6				;inc hl 
33b6				;ld d, (hl) 
33b6				;ex de,hl 
33b6 22 d5 f5			ld (os_tok_ptr), hl 
33b9					if DEBUG_FORTH_WORDS 
33b9						DMARK "LP<" 
33b9 f5				push af  
33ba 3a ce 33			ld a, (.dmark)  
33bd 32 6e fe			ld (debug_mark),a  
33c0 3a cf 33			ld a, (.dmark+1)  
33c3 32 6f fe			ld (debug_mark+1),a  
33c6 3a d0 33			ld a, (.dmark+2)  
33c9 32 70 fe			ld (debug_mark+2),a  
33cc 18 03			jr .pastdmark  
33ce ..			.dmark: db "LP<"  
33d1 f1			.pastdmark: pop af  
33d2			endm  
# End of macro DMARK
33d2					CALLMONITOR 
33d2 cd 9d 17			call break_point_state  
33d5				endm  
# End of macro CALLMONITOR
33d5				endif 
33d5 c3 05 22			jp exec1 
33d8			 
33d8					 
33d8			 
33d8			 
33d8					NEXTW 
33d8 c3 74 21			jp macro_next 
33db				endm 
# End of macro NEXTW
33db			.I:  
33db			 
33db				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
33db 5e				db WORD_SYS_CORE+74             
33dc 06 34			dw .DLOOP            
33de 02				db 1 + 1 
33df .. 00			db "I",0              
33e1				endm 
# End of macro CWHEAD
33e1			; | I ( -- ) Current loop counter | DONE 
33e1					if DEBUG_FORTH_WORDS_KEY 
33e1						DMARK "I.." 
33e1 f5				push af  
33e2 3a f6 33			ld a, (.dmark)  
33e5 32 6e fe			ld (debug_mark),a  
33e8 3a f7 33			ld a, (.dmark+1)  
33eb 32 6f fe			ld (debug_mark+1),a  
33ee 3a f8 33			ld a, (.dmark+2)  
33f1 32 70 fe			ld (debug_mark+2),a  
33f4 18 03			jr .pastdmark  
33f6 ..			.dmark: db "I.."  
33f9 f1			.pastdmark: pop af  
33fa			endm  
# End of macro DMARK
33fa						CALLMONITOR 
33fa cd 9d 17			call break_point_state  
33fd				endm  
# End of macro CALLMONITOR
33fd					endif 
33fd			 
33fd 2a f9 f5				ld hl,(os_current_i) 
3400 cd 0b 1e				call forth_push_numhl 
3403			 
3403					NEXTW 
3403 c3 74 21			jp macro_next 
3406				endm 
# End of macro NEXTW
3406			.DLOOP: 
3406				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3406 5f				db WORD_SYS_CORE+75             
3407 e7 34			dw .REPEAT            
3409 06				db 5 + 1 
340a .. 00			db "-LOOP",0              
3410				endm 
# End of macro CWHEAD
3410			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3410				; pop tos as current loop count to hl 
3410					if DEBUG_FORTH_WORDS_KEY 
3410						DMARK "-LP" 
3410 f5				push af  
3411 3a 25 34			ld a, (.dmark)  
3414 32 6e fe			ld (debug_mark),a  
3417 3a 26 34			ld a, (.dmark+1)  
341a 32 6f fe			ld (debug_mark+1),a  
341d 3a 27 34			ld a, (.dmark+2)  
3420 32 70 fe			ld (debug_mark+2),a  
3423 18 03			jr .pastdmark  
3425 ..			.dmark: db "-LP"  
3428 f1			.pastdmark: pop af  
3429			endm  
# End of macro DMARK
3429						CALLMONITOR 
3429 cd 9d 17			call break_point_state  
342c				endm  
# End of macro CALLMONITOR
342c					endif 
342c			 
342c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
342c			 
342c				FORTH_LOOP_TOS 
342c cd 66 20			call macro_forth_loop_tos 
342f				endm 
# End of macro FORTH_LOOP_TOS
342f e5				push hl 
3430			 
3430					if DEBUG_FORTH_WORDS 
3430						DMARK "-LP" 
3430 f5				push af  
3431 3a 45 34			ld a, (.dmark)  
3434 32 6e fe			ld (debug_mark),a  
3437 3a 46 34			ld a, (.dmark+1)  
343a 32 6f fe			ld (debug_mark+1),a  
343d 3a 47 34			ld a, (.dmark+2)  
3440 32 70 fe			ld (debug_mark+2),a  
3443 18 03			jr .pastdmark  
3445 ..			.dmark: db "-LP"  
3448 f1			.pastdmark: pop af  
3449			endm  
# End of macro DMARK
3449						CALLMONITOR 
3449 cd 9d 17			call break_point_state  
344c				endm  
# End of macro CALLMONITOR
344c					endif 
344c				; next item on the stack is the limit. get it 
344c			 
344c			 
344c				FORTH_LOOP_POP 
344c cd 70 20			call macro_forth_loop_pop 
344f				endm 
# End of macro FORTH_LOOP_POP
344f			 
344f				FORTH_LOOP_TOS 
344f cd 66 20			call macro_forth_loop_tos 
3452				endm 
# End of macro FORTH_LOOP_TOS
3452			 
3452 d1				pop de		 ; de = i, hl = limit 
3453			 
3453					if DEBUG_FORTH_WORDS 
3453						DMARK "-L1" 
3453 f5				push af  
3454 3a 68 34			ld a, (.dmark)  
3457 32 6e fe			ld (debug_mark),a  
345a 3a 69 34			ld a, (.dmark+1)  
345d 32 6f fe			ld (debug_mark+1),a  
3460 3a 6a 34			ld a, (.dmark+2)  
3463 32 70 fe			ld (debug_mark+2),a  
3466 18 03			jr .pastdmark  
3468 ..			.dmark: db "-L1"  
346b f1			.pastdmark: pop af  
346c			endm  
# End of macro DMARK
346c						CALLMONITOR 
346c cd 9d 17			call break_point_state  
346f				endm  
# End of macro CALLMONITOR
346f					endif 
346f			 
346f				; go back to previous word 
346f			 
346f d5				push de    ; save I for inc later 
3470			 
3470			 
3470				; get limit 
3470				;  is I at limit? 
3470			 
3470			 
3470					if DEBUG_FORTH_WORDS 
3470						DMARK "-L1" 
3470 f5				push af  
3471 3a 85 34			ld a, (.dmark)  
3474 32 6e fe			ld (debug_mark),a  
3477 3a 86 34			ld a, (.dmark+1)  
347a 32 6f fe			ld (debug_mark+1),a  
347d 3a 87 34			ld a, (.dmark+2)  
3480 32 70 fe			ld (debug_mark+2),a  
3483 18 03			jr .pastdmark  
3485 ..			.dmark: db "-L1"  
3488 f1			.pastdmark: pop af  
3489			endm  
# End of macro DMARK
3489						CALLMONITOR 
3489 cd 9d 17			call break_point_state  
348c				endm  
# End of macro CALLMONITOR
348c					endif 
348c			 
348c ed 52			sbc hl, de 
348e			 
348e			 
348e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
348e			 
348e 20 26				jr nz, .mloopnotdone 
3490			 
3490 e1				pop hl   ; get rid of saved I 
3491				FORTH_LOOP_POP     ; get rid of limit 
3491 cd 70 20			call macro_forth_loop_pop 
3494				endm 
# End of macro FORTH_LOOP_POP
3494			 
3494				FORTH_RSP_POP     ; get rid of DO ptr 
3494 cd d3 1d			call macro_forth_rsp_pop 
3497				endm 
# End of macro FORTH_RSP_POP
3497			 
3497			if DEBUG_FORTH_WORDS 
3497						DMARK "-L>" 
3497 f5				push af  
3498 3a ac 34			ld a, (.dmark)  
349b 32 6e fe			ld (debug_mark),a  
349e 3a ad 34			ld a, (.dmark+1)  
34a1 32 6f fe			ld (debug_mark+1),a  
34a4 3a ae 34			ld a, (.dmark+2)  
34a7 32 70 fe			ld (debug_mark+2),a  
34aa 18 03			jr .pastdmark  
34ac ..			.dmark: db "-L>"  
34af f1			.pastdmark: pop af  
34b0			endm  
# End of macro DMARK
34b0				CALLMONITOR 
34b0 cd 9d 17			call break_point_state  
34b3				endm  
# End of macro CALLMONITOR
34b3			endif 
34b3			 
34b3					NEXTW 
34b3 c3 74 21			jp macro_next 
34b6				endm 
# End of macro NEXTW
34b6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34b6			 
34b6			.mloopnotdone: 
34b6			 
34b6 e1				pop hl    ; get I 
34b7 2b				dec hl 
34b8			 
34b8			   	; save new I 
34b8			 
34b8			 
34b8					; set I counter 
34b8			 
34b8 22 f9 f5				ld (os_current_i), hl 
34bb			 
34bb					 
34bb				FORTH_LOOP_NEXT 
34bb cd 33 20			call macro_forth_loop_next 
34be				endm 
# End of macro FORTH_LOOP_NEXT
34be			 
34be			 
34be					if DEBUG_FORTH_WORDS 
34be eb						ex de,hl 
34bf					endif 
34bf			 
34bf			;	; get DO ptr 
34bf			; 
34bf				FORTH_RSP_TOS 
34bf cd c9 1d			call macro_forth_rsp_tos 
34c2				endm 
# End of macro FORTH_RSP_TOS
34c2			 
34c2				;push hl 
34c2			 
34c2				; not going to DO any more 
34c2				; get rid of the RSP pointer as DO will add it back in 
34c2				;FORTH_RSP_POP 
34c2				;pop hl 
34c2			 
34c2			 
34c2 22 d5 f5			ld (os_tok_ptr), hl 
34c5					if DEBUG_FORTH_WORDS 
34c5						DMARK "-L<" 
34c5 f5				push af  
34c6 3a da 34			ld a, (.dmark)  
34c9 32 6e fe			ld (debug_mark),a  
34cc 3a db 34			ld a, (.dmark+1)  
34cf 32 6f fe			ld (debug_mark+1),a  
34d2 3a dc 34			ld a, (.dmark+2)  
34d5 32 70 fe			ld (debug_mark+2),a  
34d8 18 03			jr .pastdmark  
34da ..			.dmark: db "-L<"  
34dd f1			.pastdmark: pop af  
34de			endm  
# End of macro DMARK
34de					CALLMONITOR 
34de cd 9d 17			call break_point_state  
34e1				endm  
# End of macro CALLMONITOR
34e1				endif 
34e1 c3 05 22			jp exec1 
34e4			 
34e4					 
34e4			 
34e4			 
34e4			 
34e4				NEXTW 
34e4 c3 74 21			jp macro_next 
34e7				endm 
# End of macro NEXTW
34e7			 
34e7			 
34e7			 
34e7			 
34e7			.REPEAT: 
34e7				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
34e7 71				db WORD_SYS_CORE+93             
34e8 3a 35			dw .UNTIL            
34ea 06				db 5 + 1 
34eb .. 00			db "REPEAT",0              
34f2				endm 
# End of macro CWHEAD
34f2			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
34f2			;  push pc to rsp stack past the REPEAT 
34f2					if DEBUG_FORTH_WORDS_KEY 
34f2						DMARK "REP" 
34f2 f5				push af  
34f3 3a 07 35			ld a, (.dmark)  
34f6 32 6e fe			ld (debug_mark),a  
34f9 3a 08 35			ld a, (.dmark+1)  
34fc 32 6f fe			ld (debug_mark+1),a  
34ff 3a 09 35			ld a, (.dmark+2)  
3502 32 70 fe			ld (debug_mark+2),a  
3505 18 03			jr .pastdmark  
3507 ..			.dmark: db "REP"  
350a f1			.pastdmark: pop af  
350b			endm  
# End of macro DMARK
350b						CALLMONITOR 
350b cd 9d 17			call break_point_state  
350e				endm  
# End of macro CALLMONITOR
350e					endif 
350e			 
350e 2a d5 f5				ld hl, (os_tok_ptr) 
3511 23					inc hl   ; R 
3512 23					inc hl  ; E 
3513 23					inc hl   ; P 
3514 23					inc hl   ; E 
3515 23					inc hl   ; A 
3516 23					inc hl   ; T 
3517 23					inc hl   ; zero 
3518					FORTH_RSP_NEXT 
3518 cd b2 1d			call macro_forth_rsp_next 
351b				endm 
# End of macro FORTH_RSP_NEXT
351b			 
351b			 
351b					if DEBUG_FORTH_WORDS 
351b						DMARK "REP" 
351b f5				push af  
351c 3a 30 35			ld a, (.dmark)  
351f 32 6e fe			ld (debug_mark),a  
3522 3a 31 35			ld a, (.dmark+1)  
3525 32 6f fe			ld (debug_mark+1),a  
3528 3a 32 35			ld a, (.dmark+2)  
352b 32 70 fe			ld (debug_mark+2),a  
352e 18 03			jr .pastdmark  
3530 ..			.dmark: db "REP"  
3533 f1			.pastdmark: pop af  
3534			endm  
# End of macro DMARK
3534						;pop bc    ; TODO BUG ?????? what is this for???? 
3534						CALLMONITOR 
3534 cd 9d 17			call break_point_state  
3537				endm  
# End of macro CALLMONITOR
3537					endif 
3537			 
3537					NEXTW 
3537 c3 74 21			jp macro_next 
353a				endm 
# End of macro NEXTW
353a			;	       NEXTW 
353a			 
353a			.UNTIL: 
353a				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
353a 72				db WORD_SYS_CORE+94             
353b d1 35			dw .ENDFLOW            
353d 06				db 5 + 1 
353e .. 00			db "UNTIL",0              
3544				endm 
# End of macro CWHEAD
3544			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3544			 
3544				; pop tos as check 
3544			 
3544				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3544			 
3544				FORTH_DSP_VALUEHL 
3544 cd 02 20			call macro_dsp_valuehl 
3547				endm 
# End of macro FORTH_DSP_VALUEHL
3547			 
3547					if DEBUG_FORTH_WORDS_KEY 
3547						DMARK "UNT" 
3547 f5				push af  
3548 3a 5c 35			ld a, (.dmark)  
354b 32 6e fe			ld (debug_mark),a  
354e 3a 5d 35			ld a, (.dmark+1)  
3551 32 6f fe			ld (debug_mark+1),a  
3554 3a 5e 35			ld a, (.dmark+2)  
3557 32 70 fe			ld (debug_mark+2),a  
355a 18 03			jr .pastdmark  
355c ..			.dmark: db "UNT"  
355f f1			.pastdmark: pop af  
3560			endm  
# End of macro DMARK
3560						CALLMONITOR 
3560 cd 9d 17			call break_point_state  
3563				endm  
# End of macro CALLMONITOR
3563					endif 
3563			 
3563			;	push hl 
3563				FORTH_DSP_POP 
3563 cd ba 20			call macro_forth_dsp_pop 
3566				endm 
# End of macro FORTH_DSP_POP
3566			 
3566			;	pop hl 
3566			 
3566				; test if true 
3566			 
3566 cd 1f 0e			call ishlzero 
3569			;	ld a,l 
3569			;	add h 
3569			; 
3569			;	cp 0 
3569			 
3569 20 3e			jr nz, .untilnotdone 
356b			 
356b					if DEBUG_FORTH_WORDS 
356b						DMARK "UNf" 
356b f5				push af  
356c 3a 80 35			ld a, (.dmark)  
356f 32 6e fe			ld (debug_mark),a  
3572 3a 81 35			ld a, (.dmark+1)  
3575 32 6f fe			ld (debug_mark+1),a  
3578 3a 82 35			ld a, (.dmark+2)  
357b 32 70 fe			ld (debug_mark+2),a  
357e 18 03			jr .pastdmark  
3580 ..			.dmark: db "UNf"  
3583 f1			.pastdmark: pop af  
3584			endm  
# End of macro DMARK
3584						CALLMONITOR 
3584 cd 9d 17			call break_point_state  
3587				endm  
# End of macro CALLMONITOR
3587					endif 
3587			 
3587			 
3587			 
3587				FORTH_RSP_POP     ; get rid of DO ptr 
3587 cd d3 1d			call macro_forth_rsp_pop 
358a				endm 
# End of macro FORTH_RSP_POP
358a			 
358a			if DEBUG_FORTH_WORDS 
358a						DMARK "UN>" 
358a f5				push af  
358b 3a 9f 35			ld a, (.dmark)  
358e 32 6e fe			ld (debug_mark),a  
3591 3a a0 35			ld a, (.dmark+1)  
3594 32 6f fe			ld (debug_mark+1),a  
3597 3a a1 35			ld a, (.dmark+2)  
359a 32 70 fe			ld (debug_mark+2),a  
359d 18 03			jr .pastdmark  
359f ..			.dmark: db "UN>"  
35a2 f1			.pastdmark: pop af  
35a3			endm  
# End of macro DMARK
35a3				CALLMONITOR 
35a3 cd 9d 17			call break_point_state  
35a6				endm  
# End of macro CALLMONITOR
35a6			endif 
35a6			 
35a6					NEXTW 
35a6 c3 74 21			jp macro_next 
35a9				endm 
# End of macro NEXTW
35a9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
35a9			 
35a9			.untilnotdone: 
35a9			 
35a9			 
35a9			;	; get DO ptr 
35a9			; 
35a9				FORTH_RSP_TOS 
35a9 cd c9 1d			call macro_forth_rsp_tos 
35ac				endm 
# End of macro FORTH_RSP_TOS
35ac			 
35ac				;push hl 
35ac			 
35ac				; not going to DO any more 
35ac				; get rid of the RSP pointer as DO will add it back in 
35ac				;FORTH_RSP_POP 
35ac				;pop hl 
35ac			 
35ac			 
35ac 22 d5 f5			ld (os_tok_ptr), hl 
35af					if DEBUG_FORTH_WORDS 
35af						DMARK "UN<" 
35af f5				push af  
35b0 3a c4 35			ld a, (.dmark)  
35b3 32 6e fe			ld (debug_mark),a  
35b6 3a c5 35			ld a, (.dmark+1)  
35b9 32 6f fe			ld (debug_mark+1),a  
35bc 3a c6 35			ld a, (.dmark+2)  
35bf 32 70 fe			ld (debug_mark+2),a  
35c2 18 03			jr .pastdmark  
35c4 ..			.dmark: db "UN<"  
35c7 f1			.pastdmark: pop af  
35c8			endm  
# End of macro DMARK
35c8					CALLMONITOR 
35c8 cd 9d 17			call break_point_state  
35cb				endm  
# End of macro CALLMONITOR
35cb				endif 
35cb c3 05 22			jp exec1 
35ce			 
35ce					 
35ce			 
35ce			 
35ce					NEXTW 
35ce c3 74 21			jp macro_next 
35d1				endm 
# End of macro NEXTW
35d1			 
35d1			 
35d1			.ENDFLOW: 
35d1			 
35d1			; eof 
35d1			 
# End of file forth_words_flow.asm
35d1			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
35d1			include "forth_words_logic.asm" 
35d1			 
35d1			; | ## Logic Words 
35d1			 
35d1			.NOT: 
35d1				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
35d1 2d				db WORD_SYS_CORE+25             
35d2 19 36			dw .IS            
35d4 04				db 3 + 1 
35d5 .. 00			db "NOT",0              
35d9				endm 
# End of macro CWHEAD
35d9			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
35d9					if DEBUG_FORTH_WORDS_KEY 
35d9						DMARK "NOT" 
35d9 f5				push af  
35da 3a ee 35			ld a, (.dmark)  
35dd 32 6e fe			ld (debug_mark),a  
35e0 3a ef 35			ld a, (.dmark+1)  
35e3 32 6f fe			ld (debug_mark+1),a  
35e6 3a f0 35			ld a, (.dmark+2)  
35e9 32 70 fe			ld (debug_mark+2),a  
35ec 18 03			jr .pastdmark  
35ee ..			.dmark: db "NOT"  
35f1 f1			.pastdmark: pop af  
35f2			endm  
# End of macro DMARK
35f2						CALLMONITOR 
35f2 cd 9d 17			call break_point_state  
35f5				endm  
# End of macro CALLMONITOR
35f5					endif 
35f5					FORTH_DSP 
35f5 cd c8 1f			call macro_forth_dsp 
35f8				endm 
# End of macro FORTH_DSP
35f8 7e					ld a,(hl)	; get type of value on TOS 
35f9 fe 02				cp DS_TYPE_INUM  
35fb 28 03				jr z, .noti 
35fd					NEXTW 
35fd c3 74 21			jp macro_next 
3600				endm 
# End of macro NEXTW
3600			.noti:          FORTH_DSP_VALUEHL 
3600 cd 02 20			call macro_dsp_valuehl 
3603				endm 
# End of macro FORTH_DSP_VALUEHL
3603			;		push hl 
3603					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3603 cd ba 20			call macro_forth_dsp_pop 
3606				endm 
# End of macro FORTH_DSP_POP
3606			;		pop hl 
3606 3e 00				ld a,0 
3608 bd					cp l 
3609 28 04				jr z, .not2t 
360b 2e 00				ld l, 0 
360d 18 02				jr .notip 
360f			 
360f 2e ff		.not2t:		ld l, 255 
3611			 
3611 26 00		.notip:		ld h, 0	 
3613			 
3613 cd 0b 1e				call forth_push_numhl 
3616					NEXTW 
3616 c3 74 21			jp macro_next 
3619				endm 
# End of macro NEXTW
3619			 
3619			.IS: 
3619				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3619 2d				db WORD_SYS_CORE+25             
361a 3f 36			dw .LZERO            
361c 03				db 2 + 1 
361d .. 00			db "IS",0              
3620				endm 
# End of macro CWHEAD
3620			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3620					if DEBUG_FORTH_WORDS_KEY 
3620						DMARK "IS." 
3620 f5				push af  
3621 3a 35 36			ld a, (.dmark)  
3624 32 6e fe			ld (debug_mark),a  
3627 3a 36 36			ld a, (.dmark+1)  
362a 32 6f fe			ld (debug_mark+1),a  
362d 3a 37 36			ld a, (.dmark+2)  
3630 32 70 fe			ld (debug_mark+2),a  
3633 18 03			jr .pastdmark  
3635 ..			.dmark: db "IS."  
3638 f1			.pastdmark: pop af  
3639			endm  
# End of macro DMARK
3639						CALLMONITOR 
3639 cd 9d 17			call break_point_state  
363c				endm  
# End of macro CALLMONITOR
363c					endif 
363c					NEXTW 
363c c3 74 21			jp macro_next 
363f				endm 
# End of macro NEXTW
363f			.LZERO: 
363f				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
363f 2d				db WORD_SYS_CORE+25             
3640 49 36			dw .TZERO            
3642 03				db 2 + 1 
3643 .. 00			db "0<",0              
3646				endm 
# End of macro CWHEAD
3646			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3646					NEXTW 
3646 c3 74 21			jp macro_next 
3649				endm 
# End of macro NEXTW
3649			.TZERO: 
3649				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3649 2e				db WORD_SYS_CORE+26             
364a 90 36			dw .LESS            
364c 03				db 2 + 1 
364d .. 00			db "0=",0              
3650				endm 
# End of macro CWHEAD
3650			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3650				; TODO add floating point number detection 
3650					;v5 FORTH_DSP_VALUE 
3650					if DEBUG_FORTH_WORDS_KEY 
3650						DMARK "0=." 
3650 f5				push af  
3651 3a 65 36			ld a, (.dmark)  
3654 32 6e fe			ld (debug_mark),a  
3657 3a 66 36			ld a, (.dmark+1)  
365a 32 6f fe			ld (debug_mark+1),a  
365d 3a 67 36			ld a, (.dmark+2)  
3660 32 70 fe			ld (debug_mark+2),a  
3663 18 03			jr .pastdmark  
3665 ..			.dmark: db "0=."  
3668 f1			.pastdmark: pop af  
3669			endm  
# End of macro DMARK
3669						CALLMONITOR 
3669 cd 9d 17			call break_point_state  
366c				endm  
# End of macro CALLMONITOR
366c					endif 
366c					FORTH_DSP 
366c cd c8 1f			call macro_forth_dsp 
366f				endm 
# End of macro FORTH_DSP
366f 7e					ld a,(hl)	; get type of value on TOS 
3670 fe 02				cp DS_TYPE_INUM  
3672 28 00				jr z, .tz_inum 
3674			 
3674				if FORTH_ENABLE_FLOATMATH 
3674					jr .tz_done 
3674			 
3674				endif 
3674					 
3674			 
3674			.tz_inum: 
3674					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3674 cd 02 20			call macro_dsp_valuehl 
3677				endm 
# End of macro FORTH_DSP_VALUEHL
3677			 
3677			;		push hl 
3677			 
3677					; destroy value TOS 
3677			 
3677					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3677 cd ba 20			call macro_forth_dsp_pop 
367a				endm 
# End of macro FORTH_DSP_POP
367a			 
367a			;		pop hl 
367a			 
367a 3e 00				ld a,0 
367c			 
367c bd					cp l 
367d 20 08				jr nz, .tz_notzero 
367f			 
367f bc					cp h 
3680			 
3680 20 05				jr nz, .tz_notzero 
3682			 
3682			 
3682 21 01 00				ld hl, FORTH_TRUE 
3685 18 03				jr .tz_done 
3687			 
3687 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
368a			 
368a					; push value back onto stack for another op etc 
368a			 
368a			.tz_done: 
368a cd 0b 1e				call forth_push_numhl 
368d			 
368d					NEXTW 
368d c3 74 21			jp macro_next 
3690				endm 
# End of macro NEXTW
3690			.LESS: 
3690				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3690 2f				db WORD_SYS_CORE+27             
3691 f9 36			dw .GT            
3693 02				db 1 + 1 
3694 .. 00			db "<",0              
3696				endm 
# End of macro CWHEAD
3696			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3696				; TODO add floating point number detection 
3696					if DEBUG_FORTH_WORDS_KEY 
3696						DMARK "LES" 
3696 f5				push af  
3697 3a ab 36			ld a, (.dmark)  
369a 32 6e fe			ld (debug_mark),a  
369d 3a ac 36			ld a, (.dmark+1)  
36a0 32 6f fe			ld (debug_mark+1),a  
36a3 3a ad 36			ld a, (.dmark+2)  
36a6 32 70 fe			ld (debug_mark+2),a  
36a9 18 03			jr .pastdmark  
36ab ..			.dmark: db "LES"  
36ae f1			.pastdmark: pop af  
36af			endm  
# End of macro DMARK
36af						CALLMONITOR 
36af cd 9d 17			call break_point_state  
36b2				endm  
# End of macro CALLMONITOR
36b2					endif 
36b2					FORTH_DSP 
36b2 cd c8 1f			call macro_forth_dsp 
36b5				endm 
# End of macro FORTH_DSP
36b5					;v5 FORTH_DSP_VALUE 
36b5 7e					ld a,(hl)	; get type of value on TOS 
36b6 fe 02				cp DS_TYPE_INUM  
36b8 28 00				jr z, .less_inum 
36ba			 
36ba				if FORTH_ENABLE_FLOATMATH 
36ba					jr .less_done 
36ba			 
36ba				endif 
36ba					 
36ba			 
36ba			.less_inum: 
36ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ba cd 02 20			call macro_dsp_valuehl 
36bd				endm 
# End of macro FORTH_DSP_VALUEHL
36bd			 
36bd e5					push hl  ; u2 
36be			 
36be					; destroy value TOS 
36be			 
36be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36be cd ba 20			call macro_forth_dsp_pop 
36c1				endm 
# End of macro FORTH_DSP_POP
36c1			 
36c1			 
36c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c1 cd 02 20			call macro_dsp_valuehl 
36c4				endm 
# End of macro FORTH_DSP_VALUEHL
36c4			 
36c4 e5					push hl    ; u1 
36c5			 
36c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c5 cd ba 20			call macro_forth_dsp_pop 
36c8				endm 
# End of macro FORTH_DSP_POP
36c8			 
36c8			 
36c8 b7			 or a      ;clear carry flag 
36c9 01 00 00		 ld bc, FORTH_FALSE 
36cc e1			  pop hl    ; u1 
36cd d1			  pop de    ; u2 
36ce ed 52		  sbc hl,de 
36d0 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
36d2			 
36d2 01 01 00		 ld bc, FORTH_TRUE 
36d5			.lscont:  
36d5 c5					push bc 
36d6 e1					pop hl 
36d7			 
36d7					if DEBUG_FORTH_WORDS 
36d7						DMARK "LT1" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 6e fe			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 6f fe			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 70 fe			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "LT1"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0						CALLMONITOR 
36f0 cd 9d 17			call break_point_state  
36f3				endm  
# End of macro CALLMONITOR
36f3					endif 
36f3 cd 0b 1e				call forth_push_numhl 
36f6			 
36f6					NEXTW 
36f6 c3 74 21			jp macro_next 
36f9				endm 
# End of macro NEXTW
36f9			.GT: 
36f9				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
36f9 30				db WORD_SYS_CORE+28             
36fa 62 37			dw .EQUAL            
36fc 02				db 1 + 1 
36fd .. 00			db ">",0              
36ff				endm 
# End of macro CWHEAD
36ff			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
36ff				; TODO add floating point number detection 
36ff					if DEBUG_FORTH_WORDS_KEY 
36ff						DMARK "GRT" 
36ff f5				push af  
3700 3a 14 37			ld a, (.dmark)  
3703 32 6e fe			ld (debug_mark),a  
3706 3a 15 37			ld a, (.dmark+1)  
3709 32 6f fe			ld (debug_mark+1),a  
370c 3a 16 37			ld a, (.dmark+2)  
370f 32 70 fe			ld (debug_mark+2),a  
3712 18 03			jr .pastdmark  
3714 ..			.dmark: db "GRT"  
3717 f1			.pastdmark: pop af  
3718			endm  
# End of macro DMARK
3718						CALLMONITOR 
3718 cd 9d 17			call break_point_state  
371b				endm  
# End of macro CALLMONITOR
371b					endif 
371b					FORTH_DSP 
371b cd c8 1f			call macro_forth_dsp 
371e				endm 
# End of macro FORTH_DSP
371e					;FORTH_DSP_VALUE 
371e 7e					ld a,(hl)	; get type of value on TOS 
371f fe 02				cp DS_TYPE_INUM  
3721 28 00				jr z, .gt_inum 
3723			 
3723				if FORTH_ENABLE_FLOATMATH 
3723					jr .gt_done 
3723			 
3723				endif 
3723					 
3723			 
3723			.gt_inum: 
3723					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3723 cd 02 20			call macro_dsp_valuehl 
3726				endm 
# End of macro FORTH_DSP_VALUEHL
3726			 
3726 e5					push hl  ; u2 
3727			 
3727					; destroy value TOS 
3727			 
3727					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3727 cd ba 20			call macro_forth_dsp_pop 
372a				endm 
# End of macro FORTH_DSP_POP
372a			 
372a			 
372a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372a cd 02 20			call macro_dsp_valuehl 
372d				endm 
# End of macro FORTH_DSP_VALUEHL
372d			 
372d e5					push hl    ; u1 
372e			 
372e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372e cd ba 20			call macro_forth_dsp_pop 
3731				endm 
# End of macro FORTH_DSP_POP
3731			 
3731			 
3731 b7			 or a      ;clear carry flag 
3732 01 00 00		 ld bc, FORTH_FALSE 
3735 e1			  pop hl    ; u1 
3736 d1			  pop de    ; u2 
3737 ed 52		  sbc hl,de 
3739 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
373b			 
373b 01 01 00		 ld bc, FORTH_TRUE 
373e			.gtcont:  
373e c5					push bc 
373f e1					pop hl 
3740			 
3740					if DEBUG_FORTH_WORDS 
3740						DMARK "GT1" 
3740 f5				push af  
3741 3a 55 37			ld a, (.dmark)  
3744 32 6e fe			ld (debug_mark),a  
3747 3a 56 37			ld a, (.dmark+1)  
374a 32 6f fe			ld (debug_mark+1),a  
374d 3a 57 37			ld a, (.dmark+2)  
3750 32 70 fe			ld (debug_mark+2),a  
3753 18 03			jr .pastdmark  
3755 ..			.dmark: db "GT1"  
3758 f1			.pastdmark: pop af  
3759			endm  
# End of macro DMARK
3759						CALLMONITOR 
3759 cd 9d 17			call break_point_state  
375c				endm  
# End of macro CALLMONITOR
375c					endif 
375c cd 0b 1e				call forth_push_numhl 
375f			 
375f					NEXTW 
375f c3 74 21			jp macro_next 
3762				endm 
# End of macro NEXTW
3762			.EQUAL: 
3762				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3762 31				db WORD_SYS_CORE+29             
3763 cd 37			dw .ENDLOGIC            
3765 02				db 1 + 1 
3766 .. 00			db "=",0              
3768				endm 
# End of macro CWHEAD
3768			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3768				; TODO add floating point number detection 
3768					if DEBUG_FORTH_WORDS_KEY 
3768						DMARK "EQ." 
3768 f5				push af  
3769 3a 7d 37			ld a, (.dmark)  
376c 32 6e fe			ld (debug_mark),a  
376f 3a 7e 37			ld a, (.dmark+1)  
3772 32 6f fe			ld (debug_mark+1),a  
3775 3a 7f 37			ld a, (.dmark+2)  
3778 32 70 fe			ld (debug_mark+2),a  
377b 18 03			jr .pastdmark  
377d ..			.dmark: db "EQ."  
3780 f1			.pastdmark: pop af  
3781			endm  
# End of macro DMARK
3781						CALLMONITOR 
3781 cd 9d 17			call break_point_state  
3784				endm  
# End of macro CALLMONITOR
3784					endif 
3784					FORTH_DSP 
3784 cd c8 1f			call macro_forth_dsp 
3787				endm 
# End of macro FORTH_DSP
3787					;v5 FORTH_DSP_VALUE 
3787 7e					ld a,(hl)	; get type of value on TOS 
3788 fe 02				cp DS_TYPE_INUM  
378a 28 00				jr z, .eq_inum 
378c			 
378c				if FORTH_ENABLE_FLOATMATH 
378c					jr .eq_done 
378c			 
378c				endif 
378c					 
378c			 
378c			.eq_inum: 
378c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378c cd 02 20			call macro_dsp_valuehl 
378f				endm 
# End of macro FORTH_DSP_VALUEHL
378f			 
378f e5					push hl 
3790			 
3790					; destroy value TOS 
3790			 
3790					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3790 cd ba 20			call macro_forth_dsp_pop 
3793				endm 
# End of macro FORTH_DSP_POP
3793			 
3793			 
3793					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3793 cd 02 20			call macro_dsp_valuehl 
3796				endm 
# End of macro FORTH_DSP_VALUEHL
3796			 
3796					; one value on hl get other one back 
3796			 
3796 e5					push hl 
3797			 
3797					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3797 cd ba 20			call macro_forth_dsp_pop 
379a				endm 
# End of macro FORTH_DSP_POP
379a			 
379a 0e 00				ld c, FORTH_FALSE 
379c			 
379c e1					pop hl 
379d d1					pop de 
379e			 
379e 7b					ld a, e 
379f bd					cp l 
37a0			 
37a0 20 06				jr nz, .eq_done 
37a2			 
37a2 7a					ld a, d 
37a3 bc					cp h 
37a4			 
37a4 20 02				jr nz, .eq_done 
37a6			 
37a6 0e 01				ld c, FORTH_TRUE 
37a8					 
37a8			 
37a8			 
37a8			.eq_done: 
37a8			 
37a8					; TODO push value back onto stack for another op etc 
37a8			 
37a8 26 00				ld h, 0 
37aa 69					ld l, c 
37ab					if DEBUG_FORTH_WORDS 
37ab						DMARK "EQ1" 
37ab f5				push af  
37ac 3a c0 37			ld a, (.dmark)  
37af 32 6e fe			ld (debug_mark),a  
37b2 3a c1 37			ld a, (.dmark+1)  
37b5 32 6f fe			ld (debug_mark+1),a  
37b8 3a c2 37			ld a, (.dmark+2)  
37bb 32 70 fe			ld (debug_mark+2),a  
37be 18 03			jr .pastdmark  
37c0 ..			.dmark: db "EQ1"  
37c3 f1			.pastdmark: pop af  
37c4			endm  
# End of macro DMARK
37c4						CALLMONITOR 
37c4 cd 9d 17			call break_point_state  
37c7				endm  
# End of macro CALLMONITOR
37c7					endif 
37c7 cd 0b 1e				call forth_push_numhl 
37ca			 
37ca					NEXTW 
37ca c3 74 21			jp macro_next 
37cd				endm 
# End of macro NEXTW
37cd			 
37cd			 
37cd			.ENDLOGIC: 
37cd			; eof 
37cd			 
37cd			 
# End of file forth_words_logic.asm
37cd			include "forth_words_maths.asm" 
37cd			 
37cd			; | ## Maths Words 
37cd			 
37cd			.PLUS:	 
37cd				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
37cd 15				db WORD_SYS_CORE+1             
37ce 0f 38			dw .NEG            
37d0 02				db 1 + 1 
37d1 .. 00			db "+",0              
37d3				endm 
# End of macro CWHEAD
37d3			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
37d3					if DEBUG_FORTH_WORDS_KEY 
37d3						DMARK "PLU" 
37d3 f5				push af  
37d4 3a e8 37			ld a, (.dmark)  
37d7 32 6e fe			ld (debug_mark),a  
37da 3a e9 37			ld a, (.dmark+1)  
37dd 32 6f fe			ld (debug_mark+1),a  
37e0 3a ea 37			ld a, (.dmark+2)  
37e3 32 70 fe			ld (debug_mark+2),a  
37e6 18 03			jr .pastdmark  
37e8 ..			.dmark: db "PLU"  
37eb f1			.pastdmark: pop af  
37ec			endm  
# End of macro DMARK
37ec						CALLMONITOR 
37ec cd 9d 17			call break_point_state  
37ef				endm  
# End of macro CALLMONITOR
37ef					endif 
37ef					; add top two values and push back result 
37ef			 
37ef					;for v5 FORTH_DSP_VALUE 
37ef					FORTH_DSP 
37ef cd c8 1f			call macro_forth_dsp 
37f2				endm 
# End of macro FORTH_DSP
37f2 7e					ld a,(hl)	; get type of value on TOS 
37f3 fe 02				cp DS_TYPE_INUM  
37f5 28 03				jr z, .dot_inum 
37f7			 
37f7					NEXTW 
37f7 c3 74 21			jp macro_next 
37fa				endm 
# End of macro NEXTW
37fa			 
37fa			; float maths 
37fa			 
37fa				if FORTH_ENABLE_FLOATMATH 
37fa						inc hl      ; now at start of numeric as string 
37fa			 
37fa					if DEBUG_FORTH_MATHS 
37fa						DMARK "ADD" 
37fa				CALLMONITOR 
37fa					endif 
37fa			 
37fa					;ld ix, hl 
37fa					call CON 
37fa			 
37fa			 
37fa					push hl 
37fa					 
37fa					 
37fa			 
37fa						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
37fa			 
37fa					; get next number 
37fa			 
37fa						FORTH_DSP_VALUE 
37fa			 
37fa						inc hl      ; now at start of numeric as string 
37fa			 
37fa					;ld ix, hl 
37fa					call CON 
37fa			 
37fa					push hl 
37fa			 
37fa			 
37fa						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37fa			 
37fa						; TODO do add 
37fa			 
37fa						call IADD 
37fa			 
37fa						; TODO get result back as ascii 
37fa			 
37fa						; TODO push result  
37fa			 
37fa			 
37fa			 
37fa						jr .dot_done 
37fa				endif 
37fa			 
37fa			.dot_inum: 
37fa			 
37fa			 
37fa					if DEBUG_FORTH_DOT 
37fa						DMARK "+IT" 
37fa				CALLMONITOR 
37fa					endif 
37fa			 
37fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fa cd 02 20			call macro_dsp_valuehl 
37fd				endm 
# End of macro FORTH_DSP_VALUEHL
37fd			 
37fd				; TODO add floating point number detection 
37fd			 
37fd e5					push hl 
37fe			 
37fe					; destroy value TOS 
37fe			 
37fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37fe cd ba 20			call macro_forth_dsp_pop 
3801				endm 
# End of macro FORTH_DSP_POP
3801			 
3801			 
3801					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3801 cd 02 20			call macro_dsp_valuehl 
3804				endm 
# End of macro FORTH_DSP_VALUEHL
3804			 
3804					; one value on hl get other one back 
3804			 
3804 d1					pop de 
3805			 
3805					; do the add 
3805			 
3805 19					add hl,de 
3806			 
3806					; save it 
3806			 
3806			;		push hl	 
3806			 
3806					; 
3806			 
3806					; destroy value TOS 
3806			 
3806					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3806 cd ba 20			call macro_forth_dsp_pop 
3809				endm 
# End of macro FORTH_DSP_POP
3809			 
3809					; TODO push value back onto stack for another op etc 
3809			 
3809			;		pop hl 
3809			 
3809			.dot_done: 
3809 cd 0b 1e				call forth_push_numhl 
380c			 
380c					NEXTW 
380c c3 74 21			jp macro_next 
380f				endm 
# End of macro NEXTW
380f			.NEG: 
380f			 
380f				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
380f 17				db WORD_SYS_CORE+3             
3810 52 38			dw .DIV            
3812 02				db 1 + 1 
3813 .. 00			db "-",0              
3815				endm 
# End of macro CWHEAD
3815			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3815					if DEBUG_FORTH_WORDS_KEY 
3815						DMARK "SUB" 
3815 f5				push af  
3816 3a 2a 38			ld a, (.dmark)  
3819 32 6e fe			ld (debug_mark),a  
381c 3a 2b 38			ld a, (.dmark+1)  
381f 32 6f fe			ld (debug_mark+1),a  
3822 3a 2c 38			ld a, (.dmark+2)  
3825 32 70 fe			ld (debug_mark+2),a  
3828 18 03			jr .pastdmark  
382a ..			.dmark: db "SUB"  
382d f1			.pastdmark: pop af  
382e			endm  
# End of macro DMARK
382e						CALLMONITOR 
382e cd 9d 17			call break_point_state  
3831				endm  
# End of macro CALLMONITOR
3831					endif 
3831			 
3831			 
3831				; TODO add floating point number detection 
3831					; v5 FORTH_DSP_VALUE 
3831					FORTH_DSP 
3831 cd c8 1f			call macro_forth_dsp 
3834				endm 
# End of macro FORTH_DSP
3834 7e					ld a,(hl)	; get type of value on TOS 
3835 fe 02				cp DS_TYPE_INUM  
3837 28 03				jr z, .neg_inum 
3839			 
3839					NEXTW 
3839 c3 74 21			jp macro_next 
383c				endm 
# End of macro NEXTW
383c			 
383c			; float maths 
383c			 
383c				if FORTH_ENABLE_FLOATMATH 
383c					jr .neg_done 
383c			 
383c				endif 
383c					 
383c			 
383c			.neg_inum: 
383c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383c cd 02 20			call macro_dsp_valuehl 
383f				endm 
# End of macro FORTH_DSP_VALUEHL
383f			 
383f e5					push hl 
3840			 
3840					; destroy value TOS 
3840			 
3840					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3840 cd ba 20			call macro_forth_dsp_pop 
3843				endm 
# End of macro FORTH_DSP_POP
3843			 
3843			 
3843					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3843 cd 02 20			call macro_dsp_valuehl 
3846				endm 
# End of macro FORTH_DSP_VALUEHL
3846			 
3846					; one value on hl get other one back 
3846			 
3846 d1					pop de 
3847			 
3847					; do the sub 
3847			;		ex de, hl 
3847			 
3847 ed 52				sbc hl,de 
3849			 
3849					; save it 
3849			 
3849			;		push hl	 
3849			 
3849					; 
3849			 
3849					; destroy value TOS 
3849			 
3849					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3849 cd ba 20			call macro_forth_dsp_pop 
384c				endm 
# End of macro FORTH_DSP_POP
384c			 
384c					; TODO push value back onto stack for another op etc 
384c			 
384c			;		pop hl 
384c			 
384c cd 0b 1e				call forth_push_numhl 
384f			.neg_done: 
384f			 
384f					NEXTW 
384f c3 74 21			jp macro_next 
3852				endm 
# End of macro NEXTW
3852			.DIV: 
3852				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3852 18				db WORD_SYS_CORE+4             
3853 9f 38			dw .MUL            
3855 02				db 1 + 1 
3856 .. 00			db "/",0              
3858				endm 
# End of macro CWHEAD
3858			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3858					if DEBUG_FORTH_WORDS_KEY 
3858						DMARK "DIV" 
3858 f5				push af  
3859 3a 6d 38			ld a, (.dmark)  
385c 32 6e fe			ld (debug_mark),a  
385f 3a 6e 38			ld a, (.dmark+1)  
3862 32 6f fe			ld (debug_mark+1),a  
3865 3a 6f 38			ld a, (.dmark+2)  
3868 32 70 fe			ld (debug_mark+2),a  
386b 18 03			jr .pastdmark  
386d ..			.dmark: db "DIV"  
3870 f1			.pastdmark: pop af  
3871			endm  
# End of macro DMARK
3871						CALLMONITOR 
3871 cd 9d 17			call break_point_state  
3874				endm  
# End of macro CALLMONITOR
3874					endif 
3874				; TODO add floating point number detection 
3874					; v5 FORTH_DSP_VALUE 
3874					FORTH_DSP 
3874 cd c8 1f			call macro_forth_dsp 
3877				endm 
# End of macro FORTH_DSP
3877 7e					ld a,(hl)	; get type of value on TOS 
3878 fe 02				cp DS_TYPE_INUM  
387a 28 03				jr z, .div_inum 
387c			 
387c				if FORTH_ENABLE_FLOATMATH 
387c					jr .div_done 
387c			 
387c				endif 
387c					NEXTW 
387c c3 74 21			jp macro_next 
387f				endm 
# End of macro NEXTW
387f			.div_inum: 
387f			 
387f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
387f cd 02 20			call macro_dsp_valuehl 
3882				endm 
# End of macro FORTH_DSP_VALUEHL
3882			 
3882 e5					push hl    ; to go to bc 
3883			 
3883					; destroy value TOS 
3883			 
3883					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3883 cd ba 20			call macro_forth_dsp_pop 
3886				endm 
# End of macro FORTH_DSP_POP
3886			 
3886			 
3886					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3886 cd 02 20			call macro_dsp_valuehl 
3889				endm 
# End of macro FORTH_DSP_VALUEHL
3889			 
3889					; hl to go to de 
3889			 
3889 e5					push hl 
388a			 
388a c1					pop bc 
388b d1					pop de		 
388c			 
388c			 
388c					if DEBUG_FORTH_MATHS 
388c						DMARK "DIV" 
388c				CALLMONITOR 
388c					endif 
388c					; one value on hl but move to a get other one back 
388c			 
388c			        
388c cd 53 0d			call Div16 
388f			 
388f			;	push af	 
388f e5				push hl 
3890 c5				push bc 
3891			 
3891					if DEBUG_FORTH_MATHS 
3891						DMARK "DI1" 
3891				CALLMONITOR 
3891					endif 
3891			 
3891					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3891 cd ba 20			call macro_forth_dsp_pop 
3894				endm 
# End of macro FORTH_DSP_POP
3894			 
3894			 
3894			 
3894 e1					pop hl    ; result 
3895			 
3895 cd 0b 1e				call forth_push_numhl 
3898			 
3898 e1					pop hl    ; reminder 
3899			;		ld h,0 
3899			;		ld l,d 
3899			 
3899 cd 0b 1e				call forth_push_numhl 
389c			.div_done: 
389c					NEXTW 
389c c3 74 21			jp macro_next 
389f				endm 
# End of macro NEXTW
389f			.MUL: 
389f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
389f 19				db WORD_SYS_CORE+5             
38a0 e4 38			dw .MIN            
38a2 02				db 1 + 1 
38a3 .. 00			db "*",0              
38a5				endm 
# End of macro CWHEAD
38a5			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
38a5				; TODO add floating point number detection 
38a5					if DEBUG_FORTH_WORDS_KEY 
38a5						DMARK "MUL" 
38a5 f5				push af  
38a6 3a ba 38			ld a, (.dmark)  
38a9 32 6e fe			ld (debug_mark),a  
38ac 3a bb 38			ld a, (.dmark+1)  
38af 32 6f fe			ld (debug_mark+1),a  
38b2 3a bc 38			ld a, (.dmark+2)  
38b5 32 70 fe			ld (debug_mark+2),a  
38b8 18 03			jr .pastdmark  
38ba ..			.dmark: db "MUL"  
38bd f1			.pastdmark: pop af  
38be			endm  
# End of macro DMARK
38be						CALLMONITOR 
38be cd 9d 17			call break_point_state  
38c1				endm  
# End of macro CALLMONITOR
38c1					endif 
38c1					FORTH_DSP 
38c1 cd c8 1f			call macro_forth_dsp 
38c4				endm 
# End of macro FORTH_DSP
38c4					; v5 FORTH_DSP_VALUE 
38c4 7e					ld a,(hl)	; get type of value on TOS 
38c5 fe 02				cp DS_TYPE_INUM  
38c7 28 03				jr z, .mul_inum 
38c9			 
38c9				if FORTH_ENABLE_FLOATMATH 
38c9					jr .mul_done 
38c9			 
38c9				endif 
38c9			 
38c9					NEXTW 
38c9 c3 74 21			jp macro_next 
38cc				endm 
# End of macro NEXTW
38cc			.mul_inum:	 
38cc			 
38cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38cc cd 02 20			call macro_dsp_valuehl 
38cf				endm 
# End of macro FORTH_DSP_VALUEHL
38cf			 
38cf e5					push hl 
38d0			 
38d0					; destroy value TOS 
38d0			 
38d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38d0 cd ba 20			call macro_forth_dsp_pop 
38d3				endm 
# End of macro FORTH_DSP_POP
38d3			 
38d3			 
38d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38d3 cd 02 20			call macro_dsp_valuehl 
38d6				endm 
# End of macro FORTH_DSP_VALUEHL
38d6			 
38d6					; one value on hl but move to a get other one back 
38d6			 
38d6 7d					ld a, l 
38d7			 
38d7 d1					pop de 
38d8			 
38d8					; do the mull 
38d8			;		ex de, hl 
38d8			 
38d8 cd 79 0d				call Mult16 
38db					; save it 
38db			 
38db			;		push hl	 
38db			 
38db					; 
38db			 
38db					; destroy value TOS 
38db			 
38db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38db cd ba 20			call macro_forth_dsp_pop 
38de				endm 
# End of macro FORTH_DSP_POP
38de			 
38de					; TODO push value back onto stack for another op etc 
38de			 
38de			;		pop hl 
38de			 
38de cd 0b 1e				call forth_push_numhl 
38e1			 
38e1			.mul_done: 
38e1					NEXTW 
38e1 c3 74 21			jp macro_next 
38e4				endm 
# End of macro NEXTW
38e4			 
38e4			 
38e4			 
38e4			 
38e4			.MIN: 
38e4				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
38e4 49				db WORD_SYS_CORE+53             
38e5 65 39			dw .MAX            
38e7 04				db 3 + 1 
38e8 .. 00			db "MIN",0              
38ec				endm 
# End of macro CWHEAD
38ec			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
38ec					if DEBUG_FORTH_WORDS_KEY 
38ec						DMARK "MIN" 
38ec f5				push af  
38ed 3a 01 39			ld a, (.dmark)  
38f0 32 6e fe			ld (debug_mark),a  
38f3 3a 02 39			ld a, (.dmark+1)  
38f6 32 6f fe			ld (debug_mark+1),a  
38f9 3a 03 39			ld a, (.dmark+2)  
38fc 32 70 fe			ld (debug_mark+2),a  
38ff 18 03			jr .pastdmark  
3901 ..			.dmark: db "MIN"  
3904 f1			.pastdmark: pop af  
3905			endm  
# End of macro DMARK
3905						CALLMONITOR 
3905 cd 9d 17			call break_point_state  
3908				endm  
# End of macro CALLMONITOR
3908					endif 
3908					; get u2 
3908			 
3908					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3908 cd 02 20			call macro_dsp_valuehl 
390b				endm 
# End of macro FORTH_DSP_VALUEHL
390b			 
390b e5					push hl   ; u2 
390c			 
390c					; destroy value TOS 
390c			 
390c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
390c cd ba 20			call macro_forth_dsp_pop 
390f				endm 
# End of macro FORTH_DSP_POP
390f			 
390f					; get u1 
390f			 
390f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
390f cd 02 20			call macro_dsp_valuehl 
3912				endm 
# End of macro FORTH_DSP_VALUEHL
3912			 
3912 e5					push hl  ; u1 
3913			 
3913					; destroy value TOS 
3913			 
3913					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3913 cd ba 20			call macro_forth_dsp_pop 
3916				endm 
# End of macro FORTH_DSP_POP
3916			 
3916 b7			 or a      ;clear carry flag 
3917 e1			  pop hl    ; u1 
3918 d1			  pop de    ; u2 
3919 e5				push hl   ; saved in case hl is lowest 
391a ed 52		  sbc hl,de 
391c 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
391e			 
391e e1				pop hl 
391f					if DEBUG_FORTH_WORDS 
391f						DMARK "MIN" 
391f f5				push af  
3920 3a 34 39			ld a, (.dmark)  
3923 32 6e fe			ld (debug_mark),a  
3926 3a 35 39			ld a, (.dmark+1)  
3929 32 6f fe			ld (debug_mark+1),a  
392c 3a 36 39			ld a, (.dmark+2)  
392f 32 70 fe			ld (debug_mark+2),a  
3932 18 03			jr .pastdmark  
3934 ..			.dmark: db "MIN"  
3937 f1			.pastdmark: pop af  
3938			endm  
# End of macro DMARK
3938						CALLMONITOR 
3938 cd 9d 17			call break_point_state  
393b				endm  
# End of macro CALLMONITOR
393b					endif 
393b cd 0b 1e				call forth_push_numhl 
393e			 
393e				       NEXTW 
393e c3 74 21			jp macro_next 
3941				endm 
# End of macro NEXTW
3941			 
3941			.mincont:  
3941 c1				pop bc   ; tidy up 
3942 eb				ex de , hl  
3943					if DEBUG_FORTH_WORDS 
3943						DMARK "MI1" 
3943 f5				push af  
3944 3a 58 39			ld a, (.dmark)  
3947 32 6e fe			ld (debug_mark),a  
394a 3a 59 39			ld a, (.dmark+1)  
394d 32 6f fe			ld (debug_mark+1),a  
3950 3a 5a 39			ld a, (.dmark+2)  
3953 32 70 fe			ld (debug_mark+2),a  
3956 18 03			jr .pastdmark  
3958 ..			.dmark: db "MI1"  
395b f1			.pastdmark: pop af  
395c			endm  
# End of macro DMARK
395c						CALLMONITOR 
395c cd 9d 17			call break_point_state  
395f				endm  
# End of macro CALLMONITOR
395f					endif 
395f cd 0b 1e				call forth_push_numhl 
3962			 
3962				       NEXTW 
3962 c3 74 21			jp macro_next 
3965				endm 
# End of macro NEXTW
3965			.MAX: 
3965				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3965 4a				db WORD_SYS_CORE+54             
3966 e6 39			dw .RND16            
3968 04				db 3 + 1 
3969 .. 00			db "MAX",0              
396d				endm 
# End of macro CWHEAD
396d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
396d					if DEBUG_FORTH_WORDS_KEY 
396d						DMARK "MAX" 
396d f5				push af  
396e 3a 82 39			ld a, (.dmark)  
3971 32 6e fe			ld (debug_mark),a  
3974 3a 83 39			ld a, (.dmark+1)  
3977 32 6f fe			ld (debug_mark+1),a  
397a 3a 84 39			ld a, (.dmark+2)  
397d 32 70 fe			ld (debug_mark+2),a  
3980 18 03			jr .pastdmark  
3982 ..			.dmark: db "MAX"  
3985 f1			.pastdmark: pop af  
3986			endm  
# End of macro DMARK
3986						CALLMONITOR 
3986 cd 9d 17			call break_point_state  
3989				endm  
# End of macro CALLMONITOR
3989					endif 
3989					; get u2 
3989			 
3989					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3989 cd 02 20			call macro_dsp_valuehl 
398c				endm 
# End of macro FORTH_DSP_VALUEHL
398c			 
398c e5					push hl   ; u2 
398d			 
398d					; destroy value TOS 
398d			 
398d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
398d cd ba 20			call macro_forth_dsp_pop 
3990				endm 
# End of macro FORTH_DSP_POP
3990			 
3990					; get u1 
3990			 
3990					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3990 cd 02 20			call macro_dsp_valuehl 
3993				endm 
# End of macro FORTH_DSP_VALUEHL
3993			 
3993 e5					push hl  ; u1 
3994			 
3994					; destroy value TOS 
3994			 
3994					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3994 cd ba 20			call macro_forth_dsp_pop 
3997				endm 
# End of macro FORTH_DSP_POP
3997			 
3997 b7			 or a      ;clear carry flag 
3998 e1			  pop hl    ; u1 
3999 d1			  pop de    ; u2 
399a e5				push hl   ; saved in case hl is lowest 
399b ed 52		  sbc hl,de 
399d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
399f			 
399f e1				pop hl 
39a0					if DEBUG_FORTH_WORDS 
39a0						DMARK "MAX" 
39a0 f5				push af  
39a1 3a b5 39			ld a, (.dmark)  
39a4 32 6e fe			ld (debug_mark),a  
39a7 3a b6 39			ld a, (.dmark+1)  
39aa 32 6f fe			ld (debug_mark+1),a  
39ad 3a b7 39			ld a, (.dmark+2)  
39b0 32 70 fe			ld (debug_mark+2),a  
39b3 18 03			jr .pastdmark  
39b5 ..			.dmark: db "MAX"  
39b8 f1			.pastdmark: pop af  
39b9			endm  
# End of macro DMARK
39b9						CALLMONITOR 
39b9 cd 9d 17			call break_point_state  
39bc				endm  
# End of macro CALLMONITOR
39bc					endif 
39bc cd 0b 1e				call forth_push_numhl 
39bf			 
39bf				       NEXTW 
39bf c3 74 21			jp macro_next 
39c2				endm 
# End of macro NEXTW
39c2			 
39c2			.maxcont:  
39c2 c1				pop bc   ; tidy up 
39c3 eb				ex de , hl  
39c4					if DEBUG_FORTH_WORDS 
39c4						DMARK "MA1" 
39c4 f5				push af  
39c5 3a d9 39			ld a, (.dmark)  
39c8 32 6e fe			ld (debug_mark),a  
39cb 3a da 39			ld a, (.dmark+1)  
39ce 32 6f fe			ld (debug_mark+1),a  
39d1 3a db 39			ld a, (.dmark+2)  
39d4 32 70 fe			ld (debug_mark+2),a  
39d7 18 03			jr .pastdmark  
39d9 ..			.dmark: db "MA1"  
39dc f1			.pastdmark: pop af  
39dd			endm  
# End of macro DMARK
39dd						CALLMONITOR 
39dd cd 9d 17			call break_point_state  
39e0				endm  
# End of macro CALLMONITOR
39e0					endif 
39e0 cd 0b 1e				call forth_push_numhl 
39e3				       NEXTW 
39e3 c3 74 21			jp macro_next 
39e6				endm 
# End of macro NEXTW
39e6			 
39e6			.RND16: 
39e6				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
39e6 4e				db WORD_SYS_CORE+58             
39e7 15 3a			dw .RND8            
39e9 06				db 5 + 1 
39ea .. 00			db "RND16",0              
39f0				endm 
# End of macro CWHEAD
39f0			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
39f0					if DEBUG_FORTH_WORDS_KEY 
39f0						DMARK "R16" 
39f0 f5				push af  
39f1 3a 05 3a			ld a, (.dmark)  
39f4 32 6e fe			ld (debug_mark),a  
39f7 3a 06 3a			ld a, (.dmark+1)  
39fa 32 6f fe			ld (debug_mark+1),a  
39fd 3a 07 3a			ld a, (.dmark+2)  
3a00 32 70 fe			ld (debug_mark+2),a  
3a03 18 03			jr .pastdmark  
3a05 ..			.dmark: db "R16"  
3a08 f1			.pastdmark: pop af  
3a09			endm  
# End of macro DMARK
3a09						CALLMONITOR 
3a09 cd 9d 17			call break_point_state  
3a0c				endm  
# End of macro CALLMONITOR
3a0c					endif 
3a0c cd 1d 0d				call prng16  
3a0f cd 0b 1e				call forth_push_numhl 
3a12				       NEXTW 
3a12 c3 74 21			jp macro_next 
3a15				endm 
# End of macro NEXTW
3a15			.RND8: 
3a15				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3a15 60				db WORD_SYS_CORE+76             
3a16 4a 3a			dw .RND            
3a18 05				db 4 + 1 
3a19 .. 00			db "RND8",0              
3a1e				endm 
# End of macro CWHEAD
3a1e			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3a1e					if DEBUG_FORTH_WORDS_KEY 
3a1e						DMARK "RN8" 
3a1e f5				push af  
3a1f 3a 33 3a			ld a, (.dmark)  
3a22 32 6e fe			ld (debug_mark),a  
3a25 3a 34 3a			ld a, (.dmark+1)  
3a28 32 6f fe			ld (debug_mark+1),a  
3a2b 3a 35 3a			ld a, (.dmark+2)  
3a2e 32 70 fe			ld (debug_mark+2),a  
3a31 18 03			jr .pastdmark  
3a33 ..			.dmark: db "RN8"  
3a36 f1			.pastdmark: pop af  
3a37			endm  
# End of macro DMARK
3a37						CALLMONITOR 
3a37 cd 9d 17			call break_point_state  
3a3a				endm  
# End of macro CALLMONITOR
3a3a					endif 
3a3a 2a af fb				ld hl,(xrandc) 
3a3d 23					inc hl 
3a3e cd 37 0d				call xrnd 
3a41 6f					ld l,a	 
3a42 26 00				ld h,0 
3a44 cd 0b 1e				call forth_push_numhl 
3a47				       NEXTW 
3a47 c3 74 21			jp macro_next 
3a4a				endm 
# End of macro NEXTW
3a4a			.RND: 
3a4a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3a4a 60				db WORD_SYS_CORE+76             
3a4b 50 3b			dw .ENDMATHS            
3a4d 04				db 3 + 1 
3a4e .. 00			db "RND",0              
3a52				endm 
# End of macro CWHEAD
3a52			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3a52			 
3a52					if DEBUG_FORTH_WORDS_KEY 
3a52						DMARK "RND" 
3a52 f5				push af  
3a53 3a 67 3a			ld a, (.dmark)  
3a56 32 6e fe			ld (debug_mark),a  
3a59 3a 68 3a			ld a, (.dmark+1)  
3a5c 32 6f fe			ld (debug_mark+1),a  
3a5f 3a 69 3a			ld a, (.dmark+2)  
3a62 32 70 fe			ld (debug_mark+2),a  
3a65 18 03			jr .pastdmark  
3a67 ..			.dmark: db "RND"  
3a6a f1			.pastdmark: pop af  
3a6b			endm  
# End of macro DMARK
3a6b						CALLMONITOR 
3a6b cd 9d 17			call break_point_state  
3a6e				endm  
# End of macro CALLMONITOR
3a6e					endif 
3a6e					 
3a6e					FORTH_DSP_VALUEHL    ; upper range 
3a6e cd 02 20			call macro_dsp_valuehl 
3a71				endm 
# End of macro FORTH_DSP_VALUEHL
3a71			 
3a71 22 b3 fb				ld (LFSRSeed), hl	 
3a74			 
3a74					if DEBUG_FORTH_WORDS 
3a74						DMARK "RN1" 
3a74 f5				push af  
3a75 3a 89 3a			ld a, (.dmark)  
3a78 32 6e fe			ld (debug_mark),a  
3a7b 3a 8a 3a			ld a, (.dmark+1)  
3a7e 32 6f fe			ld (debug_mark+1),a  
3a81 3a 8b 3a			ld a, (.dmark+2)  
3a84 32 70 fe			ld (debug_mark+2),a  
3a87 18 03			jr .pastdmark  
3a89 ..			.dmark: db "RN1"  
3a8c f1			.pastdmark: pop af  
3a8d			endm  
# End of macro DMARK
3a8d						CALLMONITOR 
3a8d cd 9d 17			call break_point_state  
3a90				endm  
# End of macro CALLMONITOR
3a90					endif 
3a90					FORTH_DSP_POP 
3a90 cd ba 20			call macro_forth_dsp_pop 
3a93				endm 
# End of macro FORTH_DSP_POP
3a93			 
3a93					FORTH_DSP_VALUEHL    ; low range 
3a93 cd 02 20			call macro_dsp_valuehl 
3a96				endm 
# End of macro FORTH_DSP_VALUEHL
3a96			 
3a96					if DEBUG_FORTH_WORDS 
3a96						DMARK "RN2" 
3a96 f5				push af  
3a97 3a ab 3a			ld a, (.dmark)  
3a9a 32 6e fe			ld (debug_mark),a  
3a9d 3a ac 3a			ld a, (.dmark+1)  
3aa0 32 6f fe			ld (debug_mark+1),a  
3aa3 3a ad 3a			ld a, (.dmark+2)  
3aa6 32 70 fe			ld (debug_mark+2),a  
3aa9 18 03			jr .pastdmark  
3aab ..			.dmark: db "RN2"  
3aae f1			.pastdmark: pop af  
3aaf			endm  
# End of macro DMARK
3aaf						CALLMONITOR 
3aaf cd 9d 17			call break_point_state  
3ab2				endm  
# End of macro CALLMONITOR
3ab2					endif 
3ab2 22 b5 fb				ld (LFSRSeed+2), hl 
3ab5			 
3ab5					FORTH_DSP_POP 
3ab5 cd ba 20			call macro_forth_dsp_pop 
3ab8				endm 
# End of macro FORTH_DSP_POP
3ab8			 
3ab8 e5					push hl 
3ab9			 
3ab9 e1			.inrange:	pop hl 
3aba cd 1d 0d				call prng16  
3abd					if DEBUG_FORTH_WORDS 
3abd						DMARK "RN3" 
3abd f5				push af  
3abe 3a d2 3a			ld a, (.dmark)  
3ac1 32 6e fe			ld (debug_mark),a  
3ac4 3a d3 3a			ld a, (.dmark+1)  
3ac7 32 6f fe			ld (debug_mark+1),a  
3aca 3a d4 3a			ld a, (.dmark+2)  
3acd 32 70 fe			ld (debug_mark+2),a  
3ad0 18 03			jr .pastdmark  
3ad2 ..			.dmark: db "RN3"  
3ad5 f1			.pastdmark: pop af  
3ad6			endm  
# End of macro DMARK
3ad6						CALLMONITOR 
3ad6 cd 9d 17			call break_point_state  
3ad9				endm  
# End of macro CALLMONITOR
3ad9					endif 
3ad9					 
3ad9					; if the range is 8bit knock out the high byte 
3ad9			 
3ad9 ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3add			 
3add 3e 00				ld a, 0 
3adf ba					cp d  
3ae0 20 1e				jr nz, .hirange 
3ae2 26 00				ld h, 0   ; knock it down to 8bit 
3ae4			 
3ae4					if DEBUG_FORTH_WORDS 
3ae4						DMARK "RNk" 
3ae4 f5				push af  
3ae5 3a f9 3a			ld a, (.dmark)  
3ae8 32 6e fe			ld (debug_mark),a  
3aeb 3a fa 3a			ld a, (.dmark+1)  
3aee 32 6f fe			ld (debug_mark+1),a  
3af1 3a fb 3a			ld a, (.dmark+2)  
3af4 32 70 fe			ld (debug_mark+2),a  
3af7 18 03			jr .pastdmark  
3af9 ..			.dmark: db "RNk"  
3afc f1			.pastdmark: pop af  
3afd			endm  
# End of macro DMARK
3afd						CALLMONITOR 
3afd cd 9d 17			call break_point_state  
3b00				endm  
# End of macro CALLMONITOR
3b00					endif 
3b00			.hirange:   
3b00 e5					push hl  
3b01 b7					or a  
3b02 ed 52		                sbc hl, de 
3b04			 
3b04					;call cmp16 
3b04			 
3b04 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3b06 e1					pop hl 
3b07 e5					push hl 
3b08			 
3b08					if DEBUG_FORTH_WORDS 
3b08						DMARK "RN4" 
3b08 f5				push af  
3b09 3a 1d 3b			ld a, (.dmark)  
3b0c 32 6e fe			ld (debug_mark),a  
3b0f 3a 1e 3b			ld a, (.dmark+1)  
3b12 32 6f fe			ld (debug_mark+1),a  
3b15 3a 1f 3b			ld a, (.dmark+2)  
3b18 32 70 fe			ld (debug_mark+2),a  
3b1b 18 03			jr .pastdmark  
3b1d ..			.dmark: db "RN4"  
3b20 f1			.pastdmark: pop af  
3b21			endm  
# End of macro DMARK
3b21						CALLMONITOR 
3b21 cd 9d 17			call break_point_state  
3b24				endm  
# End of macro CALLMONITOR
3b24					endif 
3b24 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3b28					;call cmp16 
3b28				 
3b28 b7					or a  
3b29 ed 52		                sbc hl, de 
3b2b 38 8c				jr c, .inrange 
3b2d			 
3b2d e1					pop hl 
3b2e					 
3b2e					if DEBUG_FORTH_WORDS 
3b2e						DMARK "RNd" 
3b2e f5				push af  
3b2f 3a 43 3b			ld a, (.dmark)  
3b32 32 6e fe			ld (debug_mark),a  
3b35 3a 44 3b			ld a, (.dmark+1)  
3b38 32 6f fe			ld (debug_mark+1),a  
3b3b 3a 45 3b			ld a, (.dmark+2)  
3b3e 32 70 fe			ld (debug_mark+2),a  
3b41 18 03			jr .pastdmark  
3b43 ..			.dmark: db "RNd"  
3b46 f1			.pastdmark: pop af  
3b47			endm  
# End of macro DMARK
3b47						CALLMONITOR 
3b47 cd 9d 17			call break_point_state  
3b4a				endm  
# End of macro CALLMONITOR
3b4a					endif 
3b4a			 
3b4a			 
3b4a cd 0b 1e				call forth_push_numhl 
3b4d				       NEXTW 
3b4d c3 74 21			jp macro_next 
3b50				endm 
# End of macro NEXTW
3b50			 
3b50			.ENDMATHS: 
3b50			 
3b50			; eof 
3b50			 
# End of file forth_words_maths.asm
3b50			include "forth_words_display.asm" 
3b50			 
3b50			; | ## Display Words 
3b50			 
3b50			.INFO: 
3b50			 
3b50				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3b50 62				db WORD_SYS_CORE+78             
3b51 6d 3b			dw .ATP            
3b53 05				db 4 + 1 
3b54 .. 00			db "INFO",0              
3b59				endm 
# End of macro CWHEAD
3b59			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3b59					FORTH_DSP_VALUEHL 
3b59 cd 02 20			call macro_dsp_valuehl 
3b5c				endm 
# End of macro FORTH_DSP_VALUEHL
3b5c			 
3b5c					FORTH_DSP_POP 
3b5c cd ba 20			call macro_forth_dsp_pop 
3b5f				endm 
# End of macro FORTH_DSP_POP
3b5f			 
3b5f e5					push hl 
3b60			 
3b60					FORTH_DSP_VALUEHL 
3b60 cd 02 20			call macro_dsp_valuehl 
3b63				endm 
# End of macro FORTH_DSP_VALUEHL
3b63			 
3b63					FORTH_DSP_POP 
3b63 cd ba 20			call macro_forth_dsp_pop 
3b66				endm 
# End of macro FORTH_DSP_POP
3b66			 
3b66 d1					pop de 
3b67			 
3b67 cd 53 0b				call info_panel 
3b6a			 
3b6a			 
3b6a					NEXTW 
3b6a c3 74 21			jp macro_next 
3b6d				endm 
# End of macro NEXTW
3b6d			.ATP: 
3b6d				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b6d 62				db WORD_SYS_CORE+78             
3b6e e4 3b			dw .FB            
3b70 04				db 3 + 1 
3b71 .. 00			db "AT?",0              
3b75				endm 
# End of macro CWHEAD
3b75			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b75					if DEBUG_FORTH_WORDS_KEY 
3b75						DMARK "AT?" 
3b75 f5				push af  
3b76 3a 8a 3b			ld a, (.dmark)  
3b79 32 6e fe			ld (debug_mark),a  
3b7c 3a 8b 3b			ld a, (.dmark+1)  
3b7f 32 6f fe			ld (debug_mark+1),a  
3b82 3a 8c 3b			ld a, (.dmark+2)  
3b85 32 70 fe			ld (debug_mark+2),a  
3b88 18 03			jr .pastdmark  
3b8a ..			.dmark: db "AT?"  
3b8d f1			.pastdmark: pop af  
3b8e			endm  
# End of macro DMARK
3b8e						CALLMONITOR 
3b8e cd 9d 17			call break_point_state  
3b91				endm  
# End of macro CALLMONITOR
3b91					endif 
3b91 3a 3d fb				ld a, (f_cursor_ptr) 
3b94			 
3b94			if DEBUG_FORTH_WORDS 
3b94				DMARK "AT?" 
3b94 f5				push af  
3b95 3a a9 3b			ld a, (.dmark)  
3b98 32 6e fe			ld (debug_mark),a  
3b9b 3a aa 3b			ld a, (.dmark+1)  
3b9e 32 6f fe			ld (debug_mark+1),a  
3ba1 3a ab 3b			ld a, (.dmark+2)  
3ba4 32 70 fe			ld (debug_mark+2),a  
3ba7 18 03			jr .pastdmark  
3ba9 ..			.dmark: db "AT?"  
3bac f1			.pastdmark: pop af  
3bad			endm  
# End of macro DMARK
3bad				CALLMONITOR 
3bad cd 9d 17			call break_point_state  
3bb0				endm  
# End of macro CALLMONITOR
3bb0			endif	 
3bb0					; count the number of rows 
3bb0			 
3bb0 06 00				ld b, 0 
3bb2 4f			.atpr:		ld c, a    ; save in case we go below zero 
3bb3 d6 28				sub display_cols 
3bb5 f2 bb 3b				jp p, .atprunder 
3bb8 04					inc b 
3bb9 18 f7				jr .atpr 
3bbb			.atprunder:	 
3bbb			if DEBUG_FORTH_WORDS 
3bbb				DMARK "A?2" 
3bbb f5				push af  
3bbc 3a d0 3b			ld a, (.dmark)  
3bbf 32 6e fe			ld (debug_mark),a  
3bc2 3a d1 3b			ld a, (.dmark+1)  
3bc5 32 6f fe			ld (debug_mark+1),a  
3bc8 3a d2 3b			ld a, (.dmark+2)  
3bcb 32 70 fe			ld (debug_mark+2),a  
3bce 18 03			jr .pastdmark  
3bd0 ..			.dmark: db "A?2"  
3bd3 f1			.pastdmark: pop af  
3bd4			endm  
# End of macro DMARK
3bd4				CALLMONITOR 
3bd4 cd 9d 17			call break_point_state  
3bd7				endm  
# End of macro CALLMONITOR
3bd7			endif	 
3bd7 26 00				ld h, 0 
3bd9 69					ld l, c 
3bda cd 0b 1e				call forth_push_numhl 
3bdd 68					ld l, b  
3bde cd 0b 1e				call forth_push_numhl 
3be1			 
3be1			 
3be1				NEXTW 
3be1 c3 74 21			jp macro_next 
3be4				endm 
# End of macro NEXTW
3be4			 
3be4			.FB: 
3be4				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3be4 1b				db WORD_SYS_CORE+7             
3be5 32 3c			dw .EMIT            
3be7 03				db 2 + 1 
3be8 .. 00			db "FB",0              
3beb				endm 
# End of macro CWHEAD
3beb			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3beb			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3beb			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3beb			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3beb					if DEBUG_FORTH_WORDS_KEY 
3beb						DMARK "FB." 
3beb f5				push af  
3bec 3a 00 3c			ld a, (.dmark)  
3bef 32 6e fe			ld (debug_mark),a  
3bf2 3a 01 3c			ld a, (.dmark+1)  
3bf5 32 6f fe			ld (debug_mark+1),a  
3bf8 3a 02 3c			ld a, (.dmark+2)  
3bfb 32 70 fe			ld (debug_mark+2),a  
3bfe 18 03			jr .pastdmark  
3c00 ..			.dmark: db "FB."  
3c03 f1			.pastdmark: pop af  
3c04			endm  
# End of macro DMARK
3c04						CALLMONITOR 
3c04 cd 9d 17			call break_point_state  
3c07				endm  
# End of macro CALLMONITOR
3c07					endif 
3c07			 
3c07					FORTH_DSP_VALUEHL 
3c07 cd 02 20			call macro_dsp_valuehl 
3c0a				endm 
# End of macro FORTH_DSP_VALUEHL
3c0a			 
3c0a 7d					ld a, l 
3c0b fe 01				cp 1 
3c0d 20 05				jr nz, .fbn1 
3c0f 21 13 fd				ld hl, display_fb1 
3c12 18 15				jr .fbset 
3c14 fe 02		.fbn1:		cp 2 
3c16 20 05				jr nz, .fbn2 
3c18 21 d1 fb				ld hl, display_fb2 
3c1b 18 0c				jr .fbset 
3c1d fe 03		.fbn2:		cp 3 
3c1f 20 05				jr nz, .fbn3 
3c21 21 72 fc				ld hl, display_fb3 
3c24 18 03				jr .fbset 
3c26			.fbn3:		 ; if invalid number select first 
3c26 21 13 fd				ld hl, display_fb1 
3c29 22 cf fb		.fbset:		ld (display_fb_active), hl 
3c2c			 
3c2c					FORTH_DSP_POP 
3c2c cd ba 20			call macro_forth_dsp_pop 
3c2f				endm 
# End of macro FORTH_DSP_POP
3c2f			 
3c2f					NEXTW 
3c2f c3 74 21			jp macro_next 
3c32				endm 
# End of macro NEXTW
3c32			 
3c32			 
3c32			.EMIT: 
3c32				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3c32 1b				db WORD_SYS_CORE+7             
3c33 83 3c			dw .DOTH            
3c35 05				db 4 + 1 
3c36 .. 00			db "EMIT",0              
3c3b				endm 
# End of macro CWHEAD
3c3b			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3c3b					; get value off TOS and display it 
3c3b			 
3c3b					if DEBUG_FORTH_WORDS_KEY 
3c3b						DMARK "EMT" 
3c3b f5				push af  
3c3c 3a 50 3c			ld a, (.dmark)  
3c3f 32 6e fe			ld (debug_mark),a  
3c42 3a 51 3c			ld a, (.dmark+1)  
3c45 32 6f fe			ld (debug_mark+1),a  
3c48 3a 52 3c			ld a, (.dmark+2)  
3c4b 32 70 fe			ld (debug_mark+2),a  
3c4e 18 03			jr .pastdmark  
3c50 ..			.dmark: db "EMT"  
3c53 f1			.pastdmark: pop af  
3c54			endm  
# End of macro DMARK
3c54						CALLMONITOR 
3c54 cd 9d 17			call break_point_state  
3c57				endm  
# End of macro CALLMONITOR
3c57					endif 
3c57			 
3c57					FORTH_DSP_VALUEHL 
3c57 cd 02 20			call macro_dsp_valuehl 
3c5a				endm 
# End of macro FORTH_DSP_VALUEHL
3c5a			 
3c5a 7d					ld a,l 
3c5b			 
3c5b					; TODO write to display 
3c5b			 
3c5b 32 d2 f4				ld (os_input), a 
3c5e 3e 00				ld a, 0 
3c60 32 d3 f4				ld (os_input+1), a 
3c63					 
3c63 3a 3d fb				ld a, (f_cursor_ptr) 
3c66 11 d2 f4				ld de, os_input 
3c69 cd d5 0b				call str_at_display 
3c6c			 
3c6c			 
3c6c 3a 1b fb				ld a,(cli_autodisplay) 
3c6f fe 00				cp 0 
3c71 28 03				jr z, .enoupdate 
3c73 cd e5 0b						call update_display 
3c76					.enoupdate: 
3c76			 
3c76 3a 3d fb				ld a, (f_cursor_ptr) 
3c79 3c					inc a 
3c7a 32 3d fb				ld (f_cursor_ptr), a   ; save new pos 
3c7d			 
3c7d			 
3c7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7d cd ba 20			call macro_forth_dsp_pop 
3c80				endm 
# End of macro FORTH_DSP_POP
3c80			  
3c80			 
3c80					NEXTW 
3c80 c3 74 21			jp macro_next 
3c83				endm 
# End of macro NEXTW
3c83			.DOTH: 
3c83				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c83 1c				db WORD_SYS_CORE+8             
3c84 b3 3c			dw .DOTF            
3c86 03				db 2 + 1 
3c87 .. 00			db ".-",0              
3c8a				endm 
# End of macro CWHEAD
3c8a			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c8a					; get value off TOS and display it 
3c8a					if DEBUG_FORTH_WORDS_KEY 
3c8a						DMARK "DTD" 
3c8a f5				push af  
3c8b 3a 9f 3c			ld a, (.dmark)  
3c8e 32 6e fe			ld (debug_mark),a  
3c91 3a a0 3c			ld a, (.dmark+1)  
3c94 32 6f fe			ld (debug_mark+1),a  
3c97 3a a1 3c			ld a, (.dmark+2)  
3c9a 32 70 fe			ld (debug_mark+2),a  
3c9d 18 03			jr .pastdmark  
3c9f ..			.dmark: db "DTD"  
3ca2 f1			.pastdmark: pop af  
3ca3			endm  
# End of macro DMARK
3ca3						CALLMONITOR 
3ca3 cd 9d 17			call break_point_state  
3ca6				endm  
# End of macro CALLMONITOR
3ca6					endif 
3ca6 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ca8 3e 00			ld a, 0 
3caa 32 1c fb			ld (cli_mvdot), a 
3cad c3 0a 3d			jp .dotgo 
3cb0				NEXTW 
3cb0 c3 74 21			jp macro_next 
3cb3				endm 
# End of macro NEXTW
3cb3			.DOTF: 
3cb3				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3cb3 1c				db WORD_SYS_CORE+8             
3cb4 e1 3c			dw .DOT            
3cb6 03				db 2 + 1 
3cb7 .. 00			db ".>",0              
3cba				endm 
# End of macro CWHEAD
3cba			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3cba					; get value off TOS and display it 
3cba			        ; TODO BUG adds extra spaces 
3cba			        ; TODO BUG handle numerics? 
3cba					if DEBUG_FORTH_WORDS_KEY 
3cba						DMARK "DTC" 
3cba f5				push af  
3cbb 3a cf 3c			ld a, (.dmark)  
3cbe 32 6e fe			ld (debug_mark),a  
3cc1 3a d0 3c			ld a, (.dmark+1)  
3cc4 32 6f fe			ld (debug_mark+1),a  
3cc7 3a d1 3c			ld a, (.dmark+2)  
3cca 32 70 fe			ld (debug_mark+2),a  
3ccd 18 03			jr .pastdmark  
3ccf ..			.dmark: db "DTC"  
3cd2 f1			.pastdmark: pop af  
3cd3			endm  
# End of macro DMARK
3cd3						CALLMONITOR 
3cd3 cd 9d 17			call break_point_state  
3cd6				endm  
# End of macro CALLMONITOR
3cd6					endif 
3cd6 3e 01			ld a, 1 
3cd8 32 1c fb			ld (cli_mvdot), a 
3cdb c3 0a 3d			jp .dotgo 
3cde				NEXTW 
3cde c3 74 21			jp macro_next 
3ce1				endm 
# End of macro NEXTW
3ce1			 
3ce1			.DOT: 
3ce1				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ce1 1c				db WORD_SYS_CORE+8             
3ce2 6d 3d			dw .CLS            
3ce4 02				db 1 + 1 
3ce5 .. 00			db ".",0              
3ce7				endm 
# End of macro CWHEAD
3ce7			        ; | . ( u -- ) Display TOS | DONE 
3ce7					; get value off TOS and display it 
3ce7			 
3ce7					if DEBUG_FORTH_WORDS_KEY 
3ce7						DMARK "DOT" 
3ce7 f5				push af  
3ce8 3a fc 3c			ld a, (.dmark)  
3ceb 32 6e fe			ld (debug_mark),a  
3cee 3a fd 3c			ld a, (.dmark+1)  
3cf1 32 6f fe			ld (debug_mark+1),a  
3cf4 3a fe 3c			ld a, (.dmark+2)  
3cf7 32 70 fe			ld (debug_mark+2),a  
3cfa 18 03			jr .pastdmark  
3cfc ..			.dmark: db "DOT"  
3cff f1			.pastdmark: pop af  
3d00			endm  
# End of macro DMARK
3d00						CALLMONITOR 
3d00 cd 9d 17			call break_point_state  
3d03				endm  
# End of macro CALLMONITOR
3d03					endif 
3d03 3e 00			ld a, 0 
3d05 32 1c fb			ld (cli_mvdot), a 
3d08 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3d0a				 
3d0a			 
3d0a			.dotgo: 
3d0a			 
3d0a			; move up type to on stack for parserv5 
3d0a					FORTH_DSP 
3d0a cd c8 1f			call macro_forth_dsp 
3d0d				endm 
# End of macro FORTH_DSP
3d0d				;FORTH_DSP_VALUE  
3d0d			 
3d0d			if DEBUG_FORTH_DOT 
3d0d				DMARK "DOT" 
3d0d				CALLMONITOR 
3d0d			endif	 
3d0d			;		.print: 
3d0d			 
3d0d 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3d0e 23				inc hl   ; position to the actual value 
3d0f fe 01			cp DS_TYPE_STR 
3d11 20 06			jr nz, .dotnum1  
3d13			 
3d13			; display string 
3d13				FORTH_DSP_VALUE  
3d13 cd eb 1f			call macro_forth_dsp_value 
3d16				endm 
# End of macro FORTH_DSP_VALUE
3d16 eb				ex de,hl 
3d17 18 11			jr .dotwrite 
3d19			 
3d19			.dotnum1: 
3d19 fe 02			cp DS_TYPE_INUM 
3d1b 20 0c			jr nz, .dotflot 
3d1d			 
3d1d			 
3d1d			; display number 
3d1d			 
3d1d			;	push hl 
3d1d			;	call clear_display 
3d1d			;	pop hl 
3d1d			 
3d1d 5e				ld e, (hl) 
3d1e 23				inc hl 
3d1f 56				ld d, (hl) 
3d20 21 d4 f2			ld hl, scratch 
3d23			if DEBUG_FORTH_DOT 
3d23				DMARK "DT1" 
3d23				CALLMONITOR 
3d23			endif	 
3d23			 
3d23 cd 03 12			call uitoa_16 
3d26 eb				ex de,hl 
3d27			 
3d27			if DEBUG_FORTH_DOT 
3d27				DMARK "DT2" 
3d27				CALLMONITOR 
3d27			endif	 
3d27			 
3d27			;	ld de, os_word_scratch 
3d27 18 01			jr .dotwrite 
3d29			 
3d29 00			.dotflot:   nop 
3d2a			; TODO print floating point number 
3d2a			 
3d2a			.dotwrite:		 
3d2a			 
3d2a					; if c is set then set all '-' to spaces 
3d2a					; need to also take into account .>  
3d2a			 
3d2a 3e 01				ld a, 1 
3d2c b9					cp c 
3d2d 20 13				jr nz, .nodashswap 
3d2f			 
3d2f					; DE has the string to write, working with HL 
3d2f			 
3d2f 06 ff				ld b, 255 
3d31 d5					push de 
3d32 e1					pop hl 
3d33			 
3d33			if DEBUG_FORTH_DOT 
3d33				DMARK "DT-" 
3d33				CALLMONITOR 
3d33			endif	 
3d33 7e			.dashscan:	ld a, (hl) 
3d34 fe 00				cp 0 
3d36 28 0a				jr z, .nodashswap 
3d38 fe 2d				cp '-' 
3d3a 20 03				jr nz, .dashskip 
3d3c 3e 20				ld a, ' ' 
3d3e 77					ld (hl), a 
3d3f 23			.dashskip:	inc hl 
3d40			if DEBUG_FORTH_DOT 
3d40				DMARK "D-2" 
3d40				CALLMONITOR 
3d40			endif	 
3d40 10 f1				djnz .dashscan 
3d42			 
3d42			if DEBUG_FORTH_DOT 
3d42				DMARK "D-1" 
3d42				CALLMONITOR 
3d42			endif	 
3d42			 
3d42			.nodashswap: 
3d42			 
3d42 e5					push hl   ; save string start in case we need to advance print 
3d43			 
3d43 3a 3d fb				ld a, (f_cursor_ptr) 
3d46 cd d5 0b				call str_at_display 
3d49 3a 1b fb				ld a,(cli_autodisplay) 
3d4c fe 00				cp 0 
3d4e 28 03				jr z, .noupdate 
3d50 cd e5 0b						call update_display 
3d53					.noupdate: 
3d53			 
3d53			 
3d53					; see if we need to advance the print position 
3d53			 
3d53 e1					pop hl   ; get back string 
3d54			 
3d54 3a 1c fb				ld a, (cli_mvdot) 
3d57			if DEBUG_FORTH_DOT 
3d57					ld e,a 
3d57				DMARK "D>1" 
3d57				CALLMONITOR 
3d57			endif	 
3d57 fe 00				cp 0 
3d59 28 0c				jr z, .noadv 
3d5b					; yes, lets advance the print position 
3d5b 3e 00				ld a, 0 
3d5d cd 5f 12				call strlent 
3d60 3a 3d fb				ld a, (f_cursor_ptr) 
3d63 85					add a,l 
3d64					;call addatohl 
3d64					;ld a, l 
3d64 32 3d fb				ld (f_cursor_ptr), a   ; save new pos 
3d67			 
3d67			if DEBUG_FORTH_DOT 
3d67				DMARK "D->" 
3d67				CALLMONITOR 
3d67			endif	 
3d67			 
3d67			.noadv:	 
3d67			 
3d67					if DEBUG_FORTH_DOT_WAIT 
3d67							call next_page_prompt 
3d67					endif	 
3d67			; TODO this pop off the stack causes a crash. i dont know why 
3d67			 
3d67			 
3d67			if DEBUG_FORTH_DOT 
3d67				DMARK "DTh" 
3d67				CALLMONITOR 
3d67			endif	 
3d67			 
3d67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d67 cd ba 20			call macro_forth_dsp_pop 
3d6a				endm 
# End of macro FORTH_DSP_POP
3d6a			 
3d6a			if DEBUG_FORTH_DOT 
3d6a				DMARK "DTi" 
3d6a				CALLMONITOR 
3d6a			endif	 
3d6a			 
3d6a			 
3d6a					NEXTW 
3d6a c3 74 21			jp macro_next 
3d6d				endm 
# End of macro NEXTW
3d6d			 
3d6d			.CLS: 
3d6d				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d6d 35				db WORD_SYS_CORE+33             
3d6e 9a 3d			dw .DRAW            
3d70 04				db 3 + 1 
3d71 .. 00			db "CLS",0              
3d75				endm 
# End of macro CWHEAD
3d75			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d75					if DEBUG_FORTH_WORDS_KEY 
3d75						DMARK "CLS" 
3d75 f5				push af  
3d76 3a 8a 3d			ld a, (.dmark)  
3d79 32 6e fe			ld (debug_mark),a  
3d7c 3a 8b 3d			ld a, (.dmark+1)  
3d7f 32 6f fe			ld (debug_mark+1),a  
3d82 3a 8c 3d			ld a, (.dmark+2)  
3d85 32 70 fe			ld (debug_mark+2),a  
3d88 18 03			jr .pastdmark  
3d8a ..			.dmark: db "CLS"  
3d8d f1			.pastdmark: pop af  
3d8e			endm  
# End of macro DMARK
3d8e						CALLMONITOR 
3d8e cd 9d 17			call break_point_state  
3d91				endm  
# End of macro CALLMONITOR
3d91					endif 
3d91 cd c2 0b				call clear_display 
3d94 c3 a8 3e				jp .home		; and home cursor 
3d97					NEXTW 
3d97 c3 74 21			jp macro_next 
3d9a				endm 
# End of macro NEXTW
3d9a			 
3d9a			.DRAW: 
3d9a				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d9a 36				db WORD_SYS_CORE+34             
3d9b c5 3d			dw .DUMP            
3d9d 05				db 4 + 1 
3d9e .. 00			db "DRAW",0              
3da3				endm 
# End of macro CWHEAD
3da3			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3da3					if DEBUG_FORTH_WORDS_KEY 
3da3						DMARK "DRW" 
3da3 f5				push af  
3da4 3a b8 3d			ld a, (.dmark)  
3da7 32 6e fe			ld (debug_mark),a  
3daa 3a b9 3d			ld a, (.dmark+1)  
3dad 32 6f fe			ld (debug_mark+1),a  
3db0 3a ba 3d			ld a, (.dmark+2)  
3db3 32 70 fe			ld (debug_mark+2),a  
3db6 18 03			jr .pastdmark  
3db8 ..			.dmark: db "DRW"  
3dbb f1			.pastdmark: pop af  
3dbc			endm  
# End of macro DMARK
3dbc						CALLMONITOR 
3dbc cd 9d 17			call break_point_state  
3dbf				endm  
# End of macro CALLMONITOR
3dbf					endif 
3dbf cd e5 0b				call update_display 
3dc2					NEXTW 
3dc2 c3 74 21			jp macro_next 
3dc5				endm 
# End of macro NEXTW
3dc5			 
3dc5			.DUMP: 
3dc5				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3dc5 37				db WORD_SYS_CORE+35             
3dc6 fd 3d			dw .CDUMP            
3dc8 05				db 4 + 1 
3dc9 .. 00			db "DUMP",0              
3dce				endm 
# End of macro CWHEAD
3dce			; | DUMP ( x -- ) With address x display dump   | DONE 
3dce			; TODO pop address to use off of the stack 
3dce					if DEBUG_FORTH_WORDS_KEY 
3dce						DMARK "DUM" 
3dce f5				push af  
3dcf 3a e3 3d			ld a, (.dmark)  
3dd2 32 6e fe			ld (debug_mark),a  
3dd5 3a e4 3d			ld a, (.dmark+1)  
3dd8 32 6f fe			ld (debug_mark+1),a  
3ddb 3a e5 3d			ld a, (.dmark+2)  
3dde 32 70 fe			ld (debug_mark+2),a  
3de1 18 03			jr .pastdmark  
3de3 ..			.dmark: db "DUM"  
3de6 f1			.pastdmark: pop af  
3de7			endm  
# End of macro DMARK
3de7						CALLMONITOR 
3de7 cd 9d 17			call break_point_state  
3dea				endm  
# End of macro CALLMONITOR
3dea					endif 
3dea cd c2 0b				call clear_display 
3ded			 
3ded					; get address 
3ded			 
3ded					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ded cd 02 20			call macro_dsp_valuehl 
3df0				endm 
# End of macro FORTH_DSP_VALUEHL
3df0				 
3df0					; save it for cdump 
3df0			 
3df0 22 f7 f5				ld (os_cur_ptr),hl 
3df3			 
3df3					; destroy value TOS 
3df3			 
3df3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df3 cd ba 20			call macro_forth_dsp_pop 
3df6				endm 
# End of macro FORTH_DSP_POP
3df6			 
3df6 cd 8b 1c				call dumpcont	; skip old style of param parsing	 
3df9 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3dfa					NEXTW 
3dfa c3 74 21			jp macro_next 
3dfd				endm 
# End of macro NEXTW
3dfd			.CDUMP: 
3dfd				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3dfd 38				db WORD_SYS_CORE+36             
3dfe 2d 3e			dw .DAT            
3e00 06				db 5 + 1 
3e01 .. 00			db "CDUMP",0              
3e07				endm 
# End of macro CWHEAD
3e07			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e07					if DEBUG_FORTH_WORDS_KEY 
3e07						DMARK "CDP" 
3e07 f5				push af  
3e08 3a 1c 3e			ld a, (.dmark)  
3e0b 32 6e fe			ld (debug_mark),a  
3e0e 3a 1d 3e			ld a, (.dmark+1)  
3e11 32 6f fe			ld (debug_mark+1),a  
3e14 3a 1e 3e			ld a, (.dmark+2)  
3e17 32 70 fe			ld (debug_mark+2),a  
3e1a 18 03			jr .pastdmark  
3e1c ..			.dmark: db "CDP"  
3e1f f1			.pastdmark: pop af  
3e20			endm  
# End of macro DMARK
3e20						CALLMONITOR 
3e20 cd 9d 17			call break_point_state  
3e23				endm  
# End of macro CALLMONITOR
3e23					endif 
3e23 cd c2 0b				call clear_display 
3e26 cd 8b 1c				call dumpcont	 
3e29 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e2a					NEXTW 
3e2a c3 74 21			jp macro_next 
3e2d				endm 
# End of macro NEXTW
3e2d			 
3e2d			 
3e2d			 
3e2d			 
3e2d			.DAT: 
3e2d				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e2d 3d				db WORD_SYS_CORE+41             
3e2e 83 3e			dw .HOME            
3e30 03				db 2 + 1 
3e31 .. 00			db "AT",0              
3e34				endm 
# End of macro CWHEAD
3e34			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e34					if DEBUG_FORTH_WORDS_KEY 
3e34						DMARK "AT." 
3e34 f5				push af  
3e35 3a 49 3e			ld a, (.dmark)  
3e38 32 6e fe			ld (debug_mark),a  
3e3b 3a 4a 3e			ld a, (.dmark+1)  
3e3e 32 6f fe			ld (debug_mark+1),a  
3e41 3a 4b 3e			ld a, (.dmark+2)  
3e44 32 70 fe			ld (debug_mark+2),a  
3e47 18 03			jr .pastdmark  
3e49 ..			.dmark: db "AT."  
3e4c f1			.pastdmark: pop af  
3e4d			endm  
# End of macro DMARK
3e4d						CALLMONITOR 
3e4d cd 9d 17			call break_point_state  
3e50				endm  
# End of macro CALLMONITOR
3e50					endif 
3e50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e50 cd 02 20			call macro_dsp_valuehl 
3e53				endm 
# End of macro FORTH_DSP_VALUEHL
3e53			 
3e53			 
3e53					; TODO save cursor row 
3e53 7d					ld a,l 
3e54 fe 02				cp 2 
3e56 20 04				jr nz, .crow3 
3e58 3e 28				ld a, display_row_2 
3e5a 18 12				jr .ccol1 
3e5c fe 03		.crow3:		cp 3 
3e5e 20 04				jr nz, .crow4 
3e60 3e 50				ld a, display_row_3 
3e62 18 0a				jr .ccol1 
3e64 fe 04		.crow4:		cp 4 
3e66 20 04				jr nz, .crow1 
3e68 3e 78				ld a, display_row_4 
3e6a 18 02				jr .ccol1 
3e6c 3e 00		.crow1:		ld a,display_row_1 
3e6e f5			.ccol1:		push af			; got row offset 
3e6f 6f					ld l,a 
3e70 26 00				ld h,0 
3e72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e72 cd ba 20			call macro_forth_dsp_pop 
3e75				endm 
# End of macro FORTH_DSP_POP
3e75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e75 cd 02 20			call macro_dsp_valuehl 
3e78				endm 
# End of macro FORTH_DSP_VALUEHL
3e78					; TODO save cursor col 
3e78 f1					pop af 
3e79 85					add l		; add col offset 
3e7a 32 3d fb				ld (f_cursor_ptr), a 
3e7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e7d cd ba 20			call macro_forth_dsp_pop 
3e80				endm 
# End of macro FORTH_DSP_POP
3e80			 
3e80					; calculate  
3e80			 
3e80					NEXTW 
3e80 c3 74 21			jp macro_next 
3e83				endm 
# End of macro NEXTW
3e83			 
3e83			 
3e83			.HOME: 
3e83				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e83 41				db WORD_SYS_CORE+45             
3e84 b0 3e			dw .SPACE            
3e86 05				db 4 + 1 
3e87 .. 00			db "HOME",0              
3e8c				endm 
# End of macro CWHEAD
3e8c			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e8c					if DEBUG_FORTH_WORDS_KEY 
3e8c						DMARK "HOM" 
3e8c f5				push af  
3e8d 3a a1 3e			ld a, (.dmark)  
3e90 32 6e fe			ld (debug_mark),a  
3e93 3a a2 3e			ld a, (.dmark+1)  
3e96 32 6f fe			ld (debug_mark+1),a  
3e99 3a a3 3e			ld a, (.dmark+2)  
3e9c 32 70 fe			ld (debug_mark+2),a  
3e9f 18 03			jr .pastdmark  
3ea1 ..			.dmark: db "HOM"  
3ea4 f1			.pastdmark: pop af  
3ea5			endm  
# End of macro DMARK
3ea5						CALLMONITOR 
3ea5 cd 9d 17			call break_point_state  
3ea8				endm  
# End of macro CALLMONITOR
3ea8					endif 
3ea8 3e 00		.home:		ld a, 0		; and home cursor 
3eaa 32 3d fb				ld (f_cursor_ptr), a 
3ead					NEXTW 
3ead c3 74 21			jp macro_next 
3eb0				endm 
# End of macro NEXTW
3eb0			 
3eb0			 
3eb0			.SPACE: 
3eb0				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3eb0 46				db WORD_SYS_CORE+50             
3eb1 de 3e			dw .SPACES            
3eb3 03				db 2 + 1 
3eb4 .. 00			db "BL",0              
3eb7				endm 
# End of macro CWHEAD
3eb7			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3eb7					if DEBUG_FORTH_WORDS_KEY 
3eb7						DMARK "BL." 
3eb7 f5				push af  
3eb8 3a cc 3e			ld a, (.dmark)  
3ebb 32 6e fe			ld (debug_mark),a  
3ebe 3a cd 3e			ld a, (.dmark+1)  
3ec1 32 6f fe			ld (debug_mark+1),a  
3ec4 3a ce 3e			ld a, (.dmark+2)  
3ec7 32 70 fe			ld (debug_mark+2),a  
3eca 18 03			jr .pastdmark  
3ecc ..			.dmark: db "BL."  
3ecf f1			.pastdmark: pop af  
3ed0			endm  
# End of macro DMARK
3ed0						CALLMONITOR 
3ed0 cd 9d 17			call break_point_state  
3ed3				endm  
# End of macro CALLMONITOR
3ed3					endif 
3ed3 21 dc 3e				ld hl, .blstr 
3ed6 cd 79 1e				call forth_push_str 
3ed9					 
3ed9				       NEXTW 
3ed9 c3 74 21			jp macro_next 
3edc				endm 
# End of macro NEXTW
3edc			 
3edc .. 00		.blstr: db " ", 0 
3ede			 
3ede			.SPACES: 
3ede				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3ede 47				db WORD_SYS_CORE+51             
3edf 79 3f			dw .SCROLL            
3ee1 07				db 6 + 1 
3ee2 .. 00			db "SPACES",0              
3ee9				endm 
# End of macro CWHEAD
3ee9			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ee9					if DEBUG_FORTH_WORDS_KEY 
3ee9						DMARK "SPS" 
3ee9 f5				push af  
3eea 3a fe 3e			ld a, (.dmark)  
3eed 32 6e fe			ld (debug_mark),a  
3ef0 3a ff 3e			ld a, (.dmark+1)  
3ef3 32 6f fe			ld (debug_mark+1),a  
3ef6 3a 00 3f			ld a, (.dmark+2)  
3ef9 32 70 fe			ld (debug_mark+2),a  
3efc 18 03			jr .pastdmark  
3efe ..			.dmark: db "SPS"  
3f01 f1			.pastdmark: pop af  
3f02			endm  
# End of macro DMARK
3f02						CALLMONITOR 
3f02 cd 9d 17			call break_point_state  
3f05				endm  
# End of macro CALLMONITOR
3f05					endif 
3f05			 
3f05			 
3f05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f05 cd 02 20			call macro_dsp_valuehl 
3f08				endm 
# End of macro FORTH_DSP_VALUEHL
3f08			 
3f08			;		push hl    ; u 
3f08					if DEBUG_FORTH_WORDS 
3f08						DMARK "SPA" 
3f08 f5				push af  
3f09 3a 1d 3f			ld a, (.dmark)  
3f0c 32 6e fe			ld (debug_mark),a  
3f0f 3a 1e 3f			ld a, (.dmark+1)  
3f12 32 6f fe			ld (debug_mark+1),a  
3f15 3a 1f 3f			ld a, (.dmark+2)  
3f18 32 70 fe			ld (debug_mark+2),a  
3f1b 18 03			jr .pastdmark  
3f1d ..			.dmark: db "SPA"  
3f20 f1			.pastdmark: pop af  
3f21			endm  
# End of macro DMARK
3f21						CALLMONITOR 
3f21 cd 9d 17			call break_point_state  
3f24				endm  
# End of macro CALLMONITOR
3f24					endif 
3f24			 
3f24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f24 cd ba 20			call macro_forth_dsp_pop 
3f27				endm 
# End of macro FORTH_DSP_POP
3f27			;		pop hl 
3f27 4d					ld c, l 
3f28 06 00				ld b, 0 
3f2a 21 d4 f2				ld hl, scratch  
3f2d			 
3f2d					if DEBUG_FORTH_WORDS 
3f2d						DMARK "SP2" 
3f2d f5				push af  
3f2e 3a 42 3f			ld a, (.dmark)  
3f31 32 6e fe			ld (debug_mark),a  
3f34 3a 43 3f			ld a, (.dmark+1)  
3f37 32 6f fe			ld (debug_mark+1),a  
3f3a 3a 44 3f			ld a, (.dmark+2)  
3f3d 32 70 fe			ld (debug_mark+2),a  
3f40 18 03			jr .pastdmark  
3f42 ..			.dmark: db "SP2"  
3f45 f1			.pastdmark: pop af  
3f46			endm  
# End of macro DMARK
3f46						CALLMONITOR 
3f46 cd 9d 17			call break_point_state  
3f49				endm  
# End of macro CALLMONITOR
3f49					endif 
3f49 3e 20				ld a, ' ' 
3f4b c5			.spaces1:	push bc 
3f4c 77					ld (hl),a 
3f4d 23					inc hl 
3f4e c1					pop bc 
3f4f 10 fa				djnz .spaces1 
3f51 3e 00				ld a,0 
3f53 77					ld (hl),a 
3f54 21 d4 f2				ld hl, scratch 
3f57					if DEBUG_FORTH_WORDS 
3f57						DMARK "SP3" 
3f57 f5				push af  
3f58 3a 6c 3f			ld a, (.dmark)  
3f5b 32 6e fe			ld (debug_mark),a  
3f5e 3a 6d 3f			ld a, (.dmark+1)  
3f61 32 6f fe			ld (debug_mark+1),a  
3f64 3a 6e 3f			ld a, (.dmark+2)  
3f67 32 70 fe			ld (debug_mark+2),a  
3f6a 18 03			jr .pastdmark  
3f6c ..			.dmark: db "SP3"  
3f6f f1			.pastdmark: pop af  
3f70			endm  
# End of macro DMARK
3f70						CALLMONITOR 
3f70 cd 9d 17			call break_point_state  
3f73				endm  
# End of macro CALLMONITOR
3f73					endif 
3f73 cd 74 1f				call forth_apush 
3f76			 
3f76				       NEXTW 
3f76 c3 74 21			jp macro_next 
3f79				endm 
# End of macro NEXTW
3f79			 
3f79			 
3f79			 
3f79			.SCROLL: 
3f79				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f79 53				db WORD_SYS_CORE+63             
3f7a a6 3f			dw .SCROLLD            
3f7c 07				db 6 + 1 
3f7d .. 00			db "SCROLL",0              
3f84				endm 
# End of macro CWHEAD
3f84			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f84					if DEBUG_FORTH_WORDS_KEY 
3f84						DMARK "SCR" 
3f84 f5				push af  
3f85 3a 99 3f			ld a, (.dmark)  
3f88 32 6e fe			ld (debug_mark),a  
3f8b 3a 9a 3f			ld a, (.dmark+1)  
3f8e 32 6f fe			ld (debug_mark+1),a  
3f91 3a 9b 3f			ld a, (.dmark+2)  
3f94 32 70 fe			ld (debug_mark+2),a  
3f97 18 03			jr .pastdmark  
3f99 ..			.dmark: db "SCR"  
3f9c f1			.pastdmark: pop af  
3f9d			endm  
# End of macro DMARK
3f9d						CALLMONITOR 
3f9d cd 9d 17			call break_point_state  
3fa0				endm  
# End of macro CALLMONITOR
3fa0					endif 
3fa0			 
3fa0 cd 84 0b			call scroll_up 
3fa3			;	call update_display 
3fa3			 
3fa3					NEXTW 
3fa3 c3 74 21			jp macro_next 
3fa6				endm 
# End of macro NEXTW
3fa6			 
3fa6			 
3fa6			 
3fa6			;		; get dir 
3fa6			; 
3fa6			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa6			; 
3fa6			;		push hl 
3fa6			; 
3fa6			;		; destroy value TOS 
3fa6			; 
3fa6			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fa6			; 
3fa6			;		; get count 
3fa6			; 
3fa6			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa6			; 
3fa6			;		push hl 
3fa6			; 
3fa6			;		; destroy value TOS 
3fa6			; 
3fa6			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fa6			; 
3fa6			;		; one value on hl get other one back 
3fa6			; 
3fa6			;		pop bc    ; count 
3fa6			; 
3fa6			;		pop de   ; dir 
3fa6			; 
3fa6			; 
3fa6			;		ld b, c 
3fa6			; 
3fa6			;.scrolldir:     push bc 
3fa6			;		push de 
3fa6			; 
3fa6			;		ld a, 0 
3fa6			;		cp e 
3fa6			;		jr z, .scrollup  
3fa6			;		call scroll_down 
3fa6			;		jr .scrollnext 
3fa6			;.scrollup:	call scroll_up 
3fa6			; 
3fa6			;		 
3fa6			;.scrollnext: 
3fa6			;		pop de 
3fa6			;		pop bc 
3fa6			;		djnz .scrolldir 
3fa6			; 
3fa6			; 
3fa6			; 
3fa6			; 
3fa6			; 
3fa6			;		NEXTW 
3fa6			 
3fa6			.SCROLLD: 
3fa6				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3fa6 53				db WORD_SYS_CORE+63             
3fa7 d4 3f			dw .ATQ            
3fa9 08				db 7 + 1 
3faa .. 00			db "SCROLLD",0              
3fb2				endm 
# End of macro CWHEAD
3fb2			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3fb2					if DEBUG_FORTH_WORDS_KEY 
3fb2						DMARK "SCD" 
3fb2 f5				push af  
3fb3 3a c7 3f			ld a, (.dmark)  
3fb6 32 6e fe			ld (debug_mark),a  
3fb9 3a c8 3f			ld a, (.dmark+1)  
3fbc 32 6f fe			ld (debug_mark+1),a  
3fbf 3a c9 3f			ld a, (.dmark+2)  
3fc2 32 70 fe			ld (debug_mark+2),a  
3fc5 18 03			jr .pastdmark  
3fc7 ..			.dmark: db "SCD"  
3fca f1			.pastdmark: pop af  
3fcb			endm  
# End of macro DMARK
3fcb						CALLMONITOR 
3fcb cd 9d 17			call break_point_state  
3fce				endm  
# End of macro CALLMONITOR
3fce					endif 
3fce			 
3fce cd a8 0b			call scroll_down 
3fd1			;	call update_display 
3fd1			 
3fd1					NEXTW 
3fd1 c3 74 21			jp macro_next 
3fd4				endm 
# End of macro NEXTW
3fd4			 
3fd4			 
3fd4			.ATQ: 
3fd4				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3fd4 62				db WORD_SYS_CORE+78             
3fd5 32 40			dw .AUTODSP            
3fd7 04				db 3 + 1 
3fd8 .. 00			db "AT@",0              
3fdc				endm 
# End of macro CWHEAD
3fdc			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3fdc					if DEBUG_FORTH_WORDS_KEY 
3fdc						DMARK "ATA" 
3fdc f5				push af  
3fdd 3a f1 3f			ld a, (.dmark)  
3fe0 32 6e fe			ld (debug_mark),a  
3fe3 3a f2 3f			ld a, (.dmark+1)  
3fe6 32 6f fe			ld (debug_mark+1),a  
3fe9 3a f3 3f			ld a, (.dmark+2)  
3fec 32 70 fe			ld (debug_mark+2),a  
3fef 18 03			jr .pastdmark  
3ff1 ..			.dmark: db "ATA"  
3ff4 f1			.pastdmark: pop af  
3ff5			endm  
# End of macro DMARK
3ff5						CALLMONITOR 
3ff5 cd 9d 17			call break_point_state  
3ff8				endm  
# End of macro CALLMONITOR
3ff8					endif 
3ff8			 
3ff8			 
3ff8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff8 cd 02 20			call macro_dsp_valuehl 
3ffb				endm 
# End of macro FORTH_DSP_VALUEHL
3ffb			 
3ffb					; TODO save cursor row 
3ffb 7d					ld a,l 
3ffc fe 02				cp 2 
3ffe 20 04				jr nz, .crow3aq 
4000 3e 28				ld a, display_row_2 
4002 18 12				jr .ccol1aq 
4004 fe 03		.crow3aq:		cp 3 
4006 20 04				jr nz, .crow4aq 
4008 3e 50				ld a, display_row_3 
400a 18 0a				jr .ccol1aq 
400c fe 04		.crow4aq:		cp 4 
400e 20 04				jr nz, .crow1aq 
4010 3e 78				ld a, display_row_4 
4012 18 02				jr .ccol1aq 
4014 3e 00		.crow1aq:		ld a,display_row_1 
4016 f5			.ccol1aq:		push af			; got row offset 
4017 6f					ld l,a 
4018 26 00				ld h,0 
401a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
401a cd ba 20			call macro_forth_dsp_pop 
401d				endm 
# End of macro FORTH_DSP_POP
401d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
401d cd 02 20			call macro_dsp_valuehl 
4020				endm 
# End of macro FORTH_DSP_VALUEHL
4020					; TODO save cursor col 
4020 f1					pop af 
4021 85					add l		; add col offset 
4022			 
4022					; add current frame buffer address 
4022 2a cf fb				ld hl, (display_fb_active) 
4025 cd f6 0d				call addatohl 
4028			 
4028			 
4028			 
4028			 
4028					; get char frame buffer location offset in hl 
4028			 
4028 7e					ld a,(hl) 
4029 26 00				ld h, 0 
402b 6f					ld l, a 
402c			 
402c cd 0b 1e				call forth_push_numhl 
402f			 
402f			 
402f					NEXTW 
402f c3 74 21			jp macro_next 
4032				endm 
# End of macro NEXTW
4032			 
4032			.AUTODSP: 
4032				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4032 63				db WORD_SYS_CORE+79             
4033 48 40			dw .MENU            
4035 05				db 4 + 1 
4036 .. 00			db "ADSP",0              
403b				endm 
# End of macro CWHEAD
403b			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
403b			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
403b			 
403b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
403b cd 02 20			call macro_dsp_valuehl 
403e				endm 
# End of macro FORTH_DSP_VALUEHL
403e			 
403e			;		push hl 
403e			 
403e					; destroy value TOS 
403e			 
403e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
403e cd ba 20			call macro_forth_dsp_pop 
4041				endm 
# End of macro FORTH_DSP_POP
4041			 
4041			;		pop hl 
4041			 
4041 7d					ld a,l 
4042 32 1b fb				ld (cli_autodisplay), a 
4045				       NEXTW 
4045 c3 74 21			jp macro_next 
4048				endm 
# End of macro NEXTW
4048			 
4048			.MENU: 
4048				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4048 70				db WORD_SYS_CORE+92             
4049 f1 40			dw .ENDDISPLAY            
404b 05				db 4 + 1 
404c .. 00			db "MENU",0              
4051				endm 
# End of macro CWHEAD
4051			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4051			 
4051			;		; get number of items on the stack 
4051			; 
4051				 
4051					FORTH_DSP_VALUEHL 
4051 cd 02 20			call macro_dsp_valuehl 
4054				endm 
# End of macro FORTH_DSP_VALUEHL
4054				 
4054					if DEBUG_FORTH_WORDS_KEY 
4054						DMARK "MNU" 
4054 f5				push af  
4055 3a 69 40			ld a, (.dmark)  
4058 32 6e fe			ld (debug_mark),a  
405b 3a 6a 40			ld a, (.dmark+1)  
405e 32 6f fe			ld (debug_mark+1),a  
4061 3a 6b 40			ld a, (.dmark+2)  
4064 32 70 fe			ld (debug_mark+2),a  
4067 18 03			jr .pastdmark  
4069 ..			.dmark: db "MNU"  
406c f1			.pastdmark: pop af  
406d			endm  
# End of macro DMARK
406d						CALLMONITOR 
406d cd 9d 17			call break_point_state  
4070				endm  
# End of macro CALLMONITOR
4070					endif 
4070			 
4070 45					ld b, l	 
4071 05					dec b 
4072			 
4072					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4072 cd ba 20			call macro_forth_dsp_pop 
4075				endm 
# End of macro FORTH_DSP_POP
4075			 
4075			 
4075					; go directly through the stack to pluck out the string pointers and build an array 
4075			 
4075			;		FORTH_DSP 
4075			 
4075					; hl contains top most stack item 
4075				 
4075 11 d4 f2				ld de, scratch 
4078			 
4078			.mbuild: 
4078			 
4078					FORTH_DSP_VALUEHL 
4078 cd 02 20			call macro_dsp_valuehl 
407b				endm 
# End of macro FORTH_DSP_VALUEHL
407b			 
407b					if DEBUG_FORTH_WORDS 
407b						DMARK "MN3" 
407b f5				push af  
407c 3a 90 40			ld a, (.dmark)  
407f 32 6e fe			ld (debug_mark),a  
4082 3a 91 40			ld a, (.dmark+1)  
4085 32 6f fe			ld (debug_mark+1),a  
4088 3a 92 40			ld a, (.dmark+2)  
408b 32 70 fe			ld (debug_mark+2),a  
408e 18 03			jr .pastdmark  
4090 ..			.dmark: db "MN3"  
4093 f1			.pastdmark: pop af  
4094			endm  
# End of macro DMARK
4094						CALLMONITOR 
4094 cd 9d 17			call break_point_state  
4097				endm  
# End of macro CALLMONITOR
4097					endif 
4097 eb					ex de, hl 
4098 73					ld (hl), e 
4099 23					inc hl 
409a 72					ld (hl), d 
409b 23					inc hl 
409c eb					ex de, hl 
409d			 
409d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
409d cd ba 20			call macro_forth_dsp_pop 
40a0				endm 
# End of macro FORTH_DSP_POP
40a0			 
40a0 10 d6				djnz .mbuild 
40a2			 
40a2					; done add term 
40a2			 
40a2 eb					ex de, hl 
40a3 36 00				ld (hl), 0 
40a5 23					inc hl 
40a6 36 00				ld (hl), 0 
40a8			 
40a8				 
40a8					 
40a8 21 d4 f2				ld hl, scratch 
40ab			 
40ab					if DEBUG_FORTH_WORDS 
40ab						DMARK "MNx" 
40ab f5				push af  
40ac 3a c0 40			ld a, (.dmark)  
40af 32 6e fe			ld (debug_mark),a  
40b2 3a c1 40			ld a, (.dmark+1)  
40b5 32 6f fe			ld (debug_mark+1),a  
40b8 3a c2 40			ld a, (.dmark+2)  
40bb 32 70 fe			ld (debug_mark+2),a  
40be 18 03			jr .pastdmark  
40c0 ..			.dmark: db "MNx"  
40c3 f1			.pastdmark: pop af  
40c4			endm  
# End of macro DMARK
40c4						CALLMONITOR 
40c4 cd 9d 17			call break_point_state  
40c7				endm  
# End of macro CALLMONITOR
40c7					endif 
40c7			 
40c7			 
40c7			 
40c7 3e 00				ld a, 0 
40c9 cd f3 0b				call menu 
40cc			 
40cc			 
40cc 6f					ld l, a 
40cd 26 00				ld h, 0 
40cf			 
40cf					if DEBUG_FORTH_WORDS 
40cf						DMARK "MNr" 
40cf f5				push af  
40d0 3a e4 40			ld a, (.dmark)  
40d3 32 6e fe			ld (debug_mark),a  
40d6 3a e5 40			ld a, (.dmark+1)  
40d9 32 6f fe			ld (debug_mark+1),a  
40dc 3a e6 40			ld a, (.dmark+2)  
40df 32 70 fe			ld (debug_mark+2),a  
40e2 18 03			jr .pastdmark  
40e4 ..			.dmark: db "MNr"  
40e7 f1			.pastdmark: pop af  
40e8			endm  
# End of macro DMARK
40e8						CALLMONITOR 
40e8 cd 9d 17			call break_point_state  
40eb				endm  
# End of macro CALLMONITOR
40eb					endif 
40eb			 
40eb cd 0b 1e				call forth_push_numhl 
40ee			 
40ee			 
40ee			 
40ee			 
40ee				       NEXTW 
40ee c3 74 21			jp macro_next 
40f1				endm 
# End of macro NEXTW
40f1			 
40f1			 
40f1			.ENDDISPLAY: 
40f1			 
40f1			; eof 
# End of file forth_words_display.asm
40f1			include "forth_words_str.asm" 
40f1			 
40f1			; | ## String Words 
40f1			 
40f1			.PTR:   
40f1			 
40f1				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
40f1 48				db WORD_SYS_CORE+52             
40f2 1e 41			dw .STYPE            
40f4 04				db 3 + 1 
40f5 .. 00			db "PTR",0              
40f9				endm 
# End of macro CWHEAD
40f9			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
40f9			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
40f9			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
40f9			 
40f9					if DEBUG_FORTH_WORDS_KEY 
40f9						DMARK "PTR" 
40f9 f5				push af  
40fa 3a 0e 41			ld a, (.dmark)  
40fd 32 6e fe			ld (debug_mark),a  
4100 3a 0f 41			ld a, (.dmark+1)  
4103 32 6f fe			ld (debug_mark+1),a  
4106 3a 10 41			ld a, (.dmark+2)  
4109 32 70 fe			ld (debug_mark+2),a  
410c 18 03			jr .pastdmark  
410e ..			.dmark: db "PTR"  
4111 f1			.pastdmark: pop af  
4112			endm  
# End of macro DMARK
4112						CALLMONITOR 
4112 cd 9d 17			call break_point_state  
4115				endm  
# End of macro CALLMONITOR
4115					endif 
4115					FORTH_DSP_VALUEHL 
4115 cd 02 20			call macro_dsp_valuehl 
4118				endm 
# End of macro FORTH_DSP_VALUEHL
4118 cd 0b 1e				call forth_push_numhl 
411b			 
411b			 
411b					NEXTW 
411b c3 74 21			jp macro_next 
411e				endm 
# End of macro NEXTW
411e			.STYPE: 
411e				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
411e 48				db WORD_SYS_CORE+52             
411f 6d 41			dw .UPPER            
4121 06				db 5 + 1 
4122 .. 00			db "STYPE",0              
4128				endm 
# End of macro CWHEAD
4128			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4128					if DEBUG_FORTH_WORDS_KEY 
4128						DMARK "STY" 
4128 f5				push af  
4129 3a 3d 41			ld a, (.dmark)  
412c 32 6e fe			ld (debug_mark),a  
412f 3a 3e 41			ld a, (.dmark+1)  
4132 32 6f fe			ld (debug_mark+1),a  
4135 3a 3f 41			ld a, (.dmark+2)  
4138 32 70 fe			ld (debug_mark+2),a  
413b 18 03			jr .pastdmark  
413d ..			.dmark: db "STY"  
4140 f1			.pastdmark: pop af  
4141			endm  
# End of macro DMARK
4141						CALLMONITOR 
4141 cd 9d 17			call break_point_state  
4144				endm  
# End of macro CALLMONITOR
4144					endif 
4144					FORTH_DSP 
4144 cd c8 1f			call macro_forth_dsp 
4147				endm 
# End of macro FORTH_DSP
4147					;v5 FORTH_DSP_VALUE 
4147			 
4147 7e					ld a, (hl) 
4148			 
4148 f5					push af 
4149			 
4149			; Dont destroy TOS		FORTH_DSP_POP 
4149			 
4149 f1					pop af 
414a			 
414a fe 01				cp DS_TYPE_STR 
414c 28 09				jr z, .typestr 
414e			 
414e fe 02				cp DS_TYPE_INUM 
4150 28 0a				jr z, .typeinum 
4152			 
4152 21 6b 41				ld hl, .tna 
4155 18 0a				jr .tpush 
4157			 
4157 21 67 41		.typestr:	ld hl, .tstr 
415a 18 05				jr .tpush 
415c 21 69 41		.typeinum:	ld hl, .tinum 
415f 18 00				jr .tpush 
4161			 
4161			.tpush: 
4161			 
4161 cd 79 1e				call forth_push_str 
4164			 
4164					NEXTW 
4164 c3 74 21			jp macro_next 
4167				endm 
# End of macro NEXTW
4167 .. 00		.tstr:	db "s",0 
4169 .. 00		.tinum:  db "i",0 
416b .. 00		.tna:   db "?", 0 
416d			 
416d			 
416d			.UPPER: 
416d				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
416d 48				db WORD_SYS_CORE+52             
416e a8 41			dw .LOWER            
4170 06				db 5 + 1 
4171 .. 00			db "UPPER",0              
4177				endm 
# End of macro CWHEAD
4177			; | UPPER ( s -- s ) Upper case string s  | DONE 
4177					if DEBUG_FORTH_WORDS_KEY 
4177						DMARK "UPR" 
4177 f5				push af  
4178 3a 8c 41			ld a, (.dmark)  
417b 32 6e fe			ld (debug_mark),a  
417e 3a 8d 41			ld a, (.dmark+1)  
4181 32 6f fe			ld (debug_mark+1),a  
4184 3a 8e 41			ld a, (.dmark+2)  
4187 32 70 fe			ld (debug_mark+2),a  
418a 18 03			jr .pastdmark  
418c ..			.dmark: db "UPR"  
418f f1			.pastdmark: pop af  
4190			endm  
# End of macro DMARK
4190						CALLMONITOR 
4190 cd 9d 17			call break_point_state  
4193				endm  
# End of macro CALLMONITOR
4193					endif 
4193			 
4193					FORTH_DSP 
4193 cd c8 1f			call macro_forth_dsp 
4196				endm 
# End of macro FORTH_DSP
4196					 
4196			; TODO check is string type 
4196			 
4196					FORTH_DSP_VALUEHL 
4196 cd 02 20			call macro_dsp_valuehl 
4199				endm 
# End of macro FORTH_DSP_VALUEHL
4199			; get pointer to string in hl 
4199			 
4199 7e			.toup:		ld a, (hl) 
419a fe 00				cp 0 
419c 28 07				jr z, .toupdone 
419e			 
419e cd 63 11				call to_upper 
41a1			 
41a1 77					ld (hl), a 
41a2 23					inc hl 
41a3 18 f4				jr .toup 
41a5			 
41a5					 
41a5			 
41a5			 
41a5			; for each char convert to upper 
41a5					 
41a5			.toupdone: 
41a5			 
41a5			 
41a5					NEXTW 
41a5 c3 74 21			jp macro_next 
41a8				endm 
# End of macro NEXTW
41a8			.LOWER: 
41a8				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
41a8 48				db WORD_SYS_CORE+52             
41a9 e3 41			dw .TCASE            
41ab 06				db 5 + 1 
41ac .. 00			db "LOWER",0              
41b2				endm 
# End of macro CWHEAD
41b2			; | LOWER ( s -- s ) Lower case string s  | DONE 
41b2					if DEBUG_FORTH_WORDS_KEY 
41b2						DMARK "LWR" 
41b2 f5				push af  
41b3 3a c7 41			ld a, (.dmark)  
41b6 32 6e fe			ld (debug_mark),a  
41b9 3a c8 41			ld a, (.dmark+1)  
41bc 32 6f fe			ld (debug_mark+1),a  
41bf 3a c9 41			ld a, (.dmark+2)  
41c2 32 70 fe			ld (debug_mark+2),a  
41c5 18 03			jr .pastdmark  
41c7 ..			.dmark: db "LWR"  
41ca f1			.pastdmark: pop af  
41cb			endm  
# End of macro DMARK
41cb						CALLMONITOR 
41cb cd 9d 17			call break_point_state  
41ce				endm  
# End of macro CALLMONITOR
41ce					endif 
41ce			 
41ce					FORTH_DSP 
41ce cd c8 1f			call macro_forth_dsp 
41d1				endm 
# End of macro FORTH_DSP
41d1					 
41d1			; TODO check is string type 
41d1			 
41d1					FORTH_DSP_VALUEHL 
41d1 cd 02 20			call macro_dsp_valuehl 
41d4				endm 
# End of macro FORTH_DSP_VALUEHL
41d4			; get pointer to string in hl 
41d4			 
41d4 7e			.tolow:		ld a, (hl) 
41d5 fe 00				cp 0 
41d7 28 07				jr z, .tolowdone 
41d9			 
41d9 cd 6c 11				call to_lower 
41dc			 
41dc 77					ld (hl), a 
41dd 23					inc hl 
41de 18 f4				jr .tolow 
41e0			 
41e0					 
41e0			 
41e0			 
41e0			; for each char convert to low 
41e0					 
41e0			.tolowdone: 
41e0					NEXTW 
41e0 c3 74 21			jp macro_next 
41e3				endm 
# End of macro NEXTW
41e3			.TCASE: 
41e3				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
41e3 48				db WORD_SYS_CORE+52             
41e4 19 43			dw .SUBSTR            
41e6 06				db 5 + 1 
41e7 .. 00			db "TCASE",0              
41ed				endm 
# End of macro CWHEAD
41ed			; | TCASE ( s -- s ) Title case string s  | DONE 
41ed					if DEBUG_FORTH_WORDS_KEY 
41ed						DMARK "TCS" 
41ed f5				push af  
41ee 3a 02 42			ld a, (.dmark)  
41f1 32 6e fe			ld (debug_mark),a  
41f4 3a 03 42			ld a, (.dmark+1)  
41f7 32 6f fe			ld (debug_mark+1),a  
41fa 3a 04 42			ld a, (.dmark+2)  
41fd 32 70 fe			ld (debug_mark+2),a  
4200 18 03			jr .pastdmark  
4202 ..			.dmark: db "TCS"  
4205 f1			.pastdmark: pop af  
4206			endm  
# End of macro DMARK
4206						CALLMONITOR 
4206 cd 9d 17			call break_point_state  
4209				endm  
# End of macro CALLMONITOR
4209					endif 
4209			 
4209					FORTH_DSP 
4209 cd c8 1f			call macro_forth_dsp 
420c				endm 
# End of macro FORTH_DSP
420c					 
420c			; TODO check is string type 
420c			 
420c					FORTH_DSP_VALUEHL 
420c cd 02 20			call macro_dsp_valuehl 
420f				endm 
# End of macro FORTH_DSP_VALUEHL
420f			; get pointer to string in hl 
420f			 
420f					if DEBUG_FORTH_WORDS 
420f						DMARK "TC1" 
420f f5				push af  
4210 3a 24 42			ld a, (.dmark)  
4213 32 6e fe			ld (debug_mark),a  
4216 3a 25 42			ld a, (.dmark+1)  
4219 32 6f fe			ld (debug_mark+1),a  
421c 3a 26 42			ld a, (.dmark+2)  
421f 32 70 fe			ld (debug_mark+2),a  
4222 18 03			jr .pastdmark  
4224 ..			.dmark: db "TC1"  
4227 f1			.pastdmark: pop af  
4228			endm  
# End of macro DMARK
4228						CALLMONITOR 
4228 cd 9d 17			call break_point_state  
422b				endm  
# End of macro CALLMONITOR
422b					endif 
422b			 
422b					; first time in turn to upper case first char 
422b			 
422b 7e					ld a, (hl) 
422c c3 b6 42				jp .totsiptou 
422f			 
422f			 
422f 7e			.tot:		ld a, (hl) 
4230 fe 00				cp 0 
4232 ca fa 42				jp z, .totdone 
4235			 
4235					if DEBUG_FORTH_WORDS 
4235						DMARK "TC2" 
4235 f5				push af  
4236 3a 4a 42			ld a, (.dmark)  
4239 32 6e fe			ld (debug_mark),a  
423c 3a 4b 42			ld a, (.dmark+1)  
423f 32 6f fe			ld (debug_mark+1),a  
4242 3a 4c 42			ld a, (.dmark+2)  
4245 32 70 fe			ld (debug_mark+2),a  
4248 18 03			jr .pastdmark  
424a ..			.dmark: db "TC2"  
424d f1			.pastdmark: pop af  
424e			endm  
# End of macro DMARK
424e						CALLMONITOR 
424e cd 9d 17			call break_point_state  
4251				endm  
# End of macro CALLMONITOR
4251					endif 
4251					; check to see if current char is a space 
4251			 
4251 fe 20				cp ' ' 
4253 28 21				jr z, .totsp 
4255 cd 6c 11				call to_lower 
4258					if DEBUG_FORTH_WORDS 
4258						DMARK "TC3" 
4258 f5				push af  
4259 3a 6d 42			ld a, (.dmark)  
425c 32 6e fe			ld (debug_mark),a  
425f 3a 6e 42			ld a, (.dmark+1)  
4262 32 6f fe			ld (debug_mark+1),a  
4265 3a 6f 42			ld a, (.dmark+2)  
4268 32 70 fe			ld (debug_mark+2),a  
426b 18 03			jr .pastdmark  
426d ..			.dmark: db "TC3"  
4270 f1			.pastdmark: pop af  
4271			endm  
# End of macro DMARK
4271						CALLMONITOR 
4271 cd 9d 17			call break_point_state  
4274				endm  
# End of macro CALLMONITOR
4274					endif 
4274 18 63				jr .totnxt 
4276			 
4276			.totsp:         ; on a space, find next char which should be upper 
4276			 
4276					if DEBUG_FORTH_WORDS 
4276						DMARK "TC4" 
4276 f5				push af  
4277 3a 8b 42			ld a, (.dmark)  
427a 32 6e fe			ld (debug_mark),a  
427d 3a 8c 42			ld a, (.dmark+1)  
4280 32 6f fe			ld (debug_mark+1),a  
4283 3a 8d 42			ld a, (.dmark+2)  
4286 32 70 fe			ld (debug_mark+2),a  
4289 18 03			jr .pastdmark  
428b ..			.dmark: db "TC4"  
428e f1			.pastdmark: pop af  
428f			endm  
# End of macro DMARK
428f						CALLMONITOR 
428f cd 9d 17			call break_point_state  
4292				endm  
# End of macro CALLMONITOR
4292					endif 
4292					;; 
4292			 
4292 fe 20				cp ' ' 
4294 20 20				jr nz, .totsiptou 
4296 23					inc hl 
4297 7e					ld a, (hl) 
4298					if DEBUG_FORTH_WORDS 
4298						DMARK "TC5" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 6e fe			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 6f fe			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 70 fe			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "TC5"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd 9d 17			call break_point_state  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4 18 c0				jr .totsp 
42b6 fe 00		.totsiptou:    cp 0 
42b8 28 40				jr z, .totdone 
42ba					; not space and not zero term so upper case it 
42ba cd 63 11				call to_upper 
42bd			 
42bd					if DEBUG_FORTH_WORDS 
42bd						DMARK "TC6" 
42bd f5				push af  
42be 3a d2 42			ld a, (.dmark)  
42c1 32 6e fe			ld (debug_mark),a  
42c4 3a d3 42			ld a, (.dmark+1)  
42c7 32 6f fe			ld (debug_mark+1),a  
42ca 3a d4 42			ld a, (.dmark+2)  
42cd 32 70 fe			ld (debug_mark+2),a  
42d0 18 03			jr .pastdmark  
42d2 ..			.dmark: db "TC6"  
42d5 f1			.pastdmark: pop af  
42d6			endm  
# End of macro DMARK
42d6						CALLMONITOR 
42d6 cd 9d 17			call break_point_state  
42d9				endm  
# End of macro CALLMONITOR
42d9					endif 
42d9			 
42d9			 
42d9			.totnxt: 
42d9			 
42d9 77					ld (hl), a 
42da 23					inc hl 
42db					if DEBUG_FORTH_WORDS 
42db						DMARK "TC7" 
42db f5				push af  
42dc 3a f0 42			ld a, (.dmark)  
42df 32 6e fe			ld (debug_mark),a  
42e2 3a f1 42			ld a, (.dmark+1)  
42e5 32 6f fe			ld (debug_mark+1),a  
42e8 3a f2 42			ld a, (.dmark+2)  
42eb 32 70 fe			ld (debug_mark+2),a  
42ee 18 03			jr .pastdmark  
42f0 ..			.dmark: db "TC7"  
42f3 f1			.pastdmark: pop af  
42f4			endm  
# End of macro DMARK
42f4						CALLMONITOR 
42f4 cd 9d 17			call break_point_state  
42f7				endm  
# End of macro CALLMONITOR
42f7					endif 
42f7 c3 2f 42				jp .tot 
42fa			 
42fa					 
42fa			 
42fa			 
42fa			; for each char convert to low 
42fa					 
42fa			.totdone: 
42fa					if DEBUG_FORTH_WORDS 
42fa						DMARK "TCd" 
42fa f5				push af  
42fb 3a 0f 43			ld a, (.dmark)  
42fe 32 6e fe			ld (debug_mark),a  
4301 3a 10 43			ld a, (.dmark+1)  
4304 32 6f fe			ld (debug_mark+1),a  
4307 3a 11 43			ld a, (.dmark+2)  
430a 32 70 fe			ld (debug_mark+2),a  
430d 18 03			jr .pastdmark  
430f ..			.dmark: db "TCd"  
4312 f1			.pastdmark: pop af  
4313			endm  
# End of macro DMARK
4313						CALLMONITOR 
4313 cd 9d 17			call break_point_state  
4316				endm  
# End of macro CALLMONITOR
4316					endif 
4316					NEXTW 
4316 c3 74 21			jp macro_next 
4319				endm 
# End of macro NEXTW
4319			 
4319			.SUBSTR: 
4319				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4319 48				db WORD_SYS_CORE+52             
431a 77 43			dw .LEFT            
431c 07				db 6 + 1 
431d .. 00			db "SUBSTR",0              
4324				endm 
# End of macro CWHEAD
4324			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4324			 
4324					if DEBUG_FORTH_WORDS_KEY 
4324						DMARK "SST" 
4324 f5				push af  
4325 3a 39 43			ld a, (.dmark)  
4328 32 6e fe			ld (debug_mark),a  
432b 3a 3a 43			ld a, (.dmark+1)  
432e 32 6f fe			ld (debug_mark+1),a  
4331 3a 3b 43			ld a, (.dmark+2)  
4334 32 70 fe			ld (debug_mark+2),a  
4337 18 03			jr .pastdmark  
4339 ..			.dmark: db "SST"  
433c f1			.pastdmark: pop af  
433d			endm  
# End of macro DMARK
433d						CALLMONITOR 
433d cd 9d 17			call break_point_state  
4340				endm  
# End of macro CALLMONITOR
4340					endif 
4340			; TODO check string type 
4340					FORTH_DSP_VALUEHL 
4340 cd 02 20			call macro_dsp_valuehl 
4343				endm 
# End of macro FORTH_DSP_VALUEHL
4343			 
4343 e5					push hl      ; string length 
4344			 
4344					FORTH_DSP_POP 
4344 cd ba 20			call macro_forth_dsp_pop 
4347				endm 
# End of macro FORTH_DSP_POP
4347			 
4347					FORTH_DSP_VALUEHL 
4347 cd 02 20			call macro_dsp_valuehl 
434a				endm 
# End of macro FORTH_DSP_VALUEHL
434a			 
434a e5					push hl     ; start char 
434b			 
434b					FORTH_DSP_POP 
434b cd ba 20			call macro_forth_dsp_pop 
434e				endm 
# End of macro FORTH_DSP_POP
434e			 
434e			 
434e					FORTH_DSP_VALUE 
434e cd eb 1f			call macro_forth_dsp_value 
4351				endm 
# End of macro FORTH_DSP_VALUE
4351			 
4351 d1					pop de    ; get start post offset 
4352			 
4352 19					add hl, de    ; starting offset 
4353			 
4353 c1					pop bc 
4354 c5					push bc      ; grab size of string 
4355			 
4355 e5					push hl    ; save string start  
4356			 
4356 26 00				ld h, 0 
4358 69					ld l, c 
4359 23					inc hl 
435a 23					inc hl 
435b			 
435b cd bd 12				call malloc 
435e				if DEBUG_FORTH_MALLOC_GUARD 
435e cc f2 53				call z,malloc_error 
4361				endif 
4361			 
4361 eb					ex de, hl      ; save malloc area for string copy 
4362 e1					pop hl    ; get back source 
4363 c1					pop bc    ; get length of string back 
4364			 
4364 d5					push de    ; save malloc area for after we push 
4365 ed b0				ldir     ; copy substr 
4367			 
4367			 
4367 eb					ex de, hl 
4368 3e 00				ld a, 0 
436a 77					ld (hl), a   ; term substr 
436b			 
436b					 
436b e1					pop hl    ; get malloc so we can push it 
436c e5					push hl   ; save so we can free it afterwards 
436d			 
436d cd 79 1e				call forth_push_str 
4370			 
4370 e1					pop hl 
4371 cd 87 13				call free 
4374			 
4374					 
4374					 
4374			 
4374			 
4374					NEXTW 
4374 c3 74 21			jp macro_next 
4377				endm 
# End of macro NEXTW
4377			 
4377			.LEFT: 
4377				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4377 48				db WORD_SYS_CORE+52             
4378 9f 43			dw .RIGHT            
437a 05				db 4 + 1 
437b .. 00			db "LEFT",0              
4380				endm 
# End of macro CWHEAD
4380			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4380					if DEBUG_FORTH_WORDS_KEY 
4380						DMARK "LEF" 
4380 f5				push af  
4381 3a 95 43			ld a, (.dmark)  
4384 32 6e fe			ld (debug_mark),a  
4387 3a 96 43			ld a, (.dmark+1)  
438a 32 6f fe			ld (debug_mark+1),a  
438d 3a 97 43			ld a, (.dmark+2)  
4390 32 70 fe			ld (debug_mark+2),a  
4393 18 03			jr .pastdmark  
4395 ..			.dmark: db "LEF"  
4398 f1			.pastdmark: pop af  
4399			endm  
# End of macro DMARK
4399						CALLMONITOR 
4399 cd 9d 17			call break_point_state  
439c				endm  
# End of macro CALLMONITOR
439c					endif 
439c			 
439c					NEXTW 
439c c3 74 21			jp macro_next 
439f				endm 
# End of macro NEXTW
439f			.RIGHT: 
439f				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
439f 48				db WORD_SYS_CORE+52             
43a0 c8 43			dw .STR2NUM            
43a2 06				db 5 + 1 
43a3 .. 00			db "RIGHT",0              
43a9				endm 
# End of macro CWHEAD
43a9			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
43a9					if DEBUG_FORTH_WORDS_KEY 
43a9						DMARK "RIG" 
43a9 f5				push af  
43aa 3a be 43			ld a, (.dmark)  
43ad 32 6e fe			ld (debug_mark),a  
43b0 3a bf 43			ld a, (.dmark+1)  
43b3 32 6f fe			ld (debug_mark+1),a  
43b6 3a c0 43			ld a, (.dmark+2)  
43b9 32 70 fe			ld (debug_mark+2),a  
43bc 18 03			jr .pastdmark  
43be ..			.dmark: db "RIG"  
43c1 f1			.pastdmark: pop af  
43c2			endm  
# End of macro DMARK
43c2						CALLMONITOR 
43c2 cd 9d 17			call break_point_state  
43c5				endm  
# End of macro CALLMONITOR
43c5					endif 
43c5			 
43c5					NEXTW 
43c5 c3 74 21			jp macro_next 
43c8				endm 
# End of macro NEXTW
43c8			 
43c8			 
43c8			.STR2NUM: 
43c8				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
43c8 48				db WORD_SYS_CORE+52             
43c9 54 44			dw .NUM2STR            
43cb 08				db 7 + 1 
43cc .. 00			db "STR2NUM",0              
43d4				endm 
# End of macro CWHEAD
43d4			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
43d4			 
43d4			 
43d4			; TODO STR type check to do 
43d4					if DEBUG_FORTH_WORDS_KEY 
43d4						DMARK "S2N" 
43d4 f5				push af  
43d5 3a e9 43			ld a, (.dmark)  
43d8 32 6e fe			ld (debug_mark),a  
43db 3a ea 43			ld a, (.dmark+1)  
43de 32 6f fe			ld (debug_mark+1),a  
43e1 3a eb 43			ld a, (.dmark+2)  
43e4 32 70 fe			ld (debug_mark+2),a  
43e7 18 03			jr .pastdmark  
43e9 ..			.dmark: db "S2N"  
43ec f1			.pastdmark: pop af  
43ed			endm  
# End of macro DMARK
43ed						CALLMONITOR 
43ed cd 9d 17			call break_point_state  
43f0				endm  
# End of macro CALLMONITOR
43f0					endif 
43f0			 
43f0					;FORTH_DSP 
43f0					FORTH_DSP_VALUE 
43f0 cd eb 1f			call macro_forth_dsp_value 
43f3				endm 
# End of macro FORTH_DSP_VALUE
43f3					;inc hl 
43f3			 
43f3 eb					ex de, hl 
43f4					if DEBUG_FORTH_WORDS 
43f4						DMARK "S2a" 
43f4 f5				push af  
43f5 3a 09 44			ld a, (.dmark)  
43f8 32 6e fe			ld (debug_mark),a  
43fb 3a 0a 44			ld a, (.dmark+1)  
43fe 32 6f fe			ld (debug_mark+1),a  
4401 3a 0b 44			ld a, (.dmark+2)  
4404 32 70 fe			ld (debug_mark+2),a  
4407 18 03			jr .pastdmark  
4409 ..			.dmark: db "S2a"  
440c f1			.pastdmark: pop af  
440d			endm  
# End of macro DMARK
440d						CALLMONITOR 
440d cd 9d 17			call break_point_state  
4410				endm  
# End of macro CALLMONITOR
4410					endif 
4410 cd eb 11				call string_to_uint16 
4413			 
4413					if DEBUG_FORTH_WORDS 
4413						DMARK "S2b" 
4413 f5				push af  
4414 3a 28 44			ld a, (.dmark)  
4417 32 6e fe			ld (debug_mark),a  
441a 3a 29 44			ld a, (.dmark+1)  
441d 32 6f fe			ld (debug_mark+1),a  
4420 3a 2a 44			ld a, (.dmark+2)  
4423 32 70 fe			ld (debug_mark+2),a  
4426 18 03			jr .pastdmark  
4428 ..			.dmark: db "S2b"  
442b f1			.pastdmark: pop af  
442c			endm  
# End of macro DMARK
442c						CALLMONITOR 
442c cd 9d 17			call break_point_state  
442f				endm  
# End of macro CALLMONITOR
442f					endif 
442f			;		push hl 
442f					FORTH_DSP_POP 
442f cd ba 20			call macro_forth_dsp_pop 
4432				endm 
# End of macro FORTH_DSP_POP
4432			;		pop hl 
4432					 
4432					if DEBUG_FORTH_WORDS 
4432						DMARK "S2b" 
4432 f5				push af  
4433 3a 47 44			ld a, (.dmark)  
4436 32 6e fe			ld (debug_mark),a  
4439 3a 48 44			ld a, (.dmark+1)  
443c 32 6f fe			ld (debug_mark+1),a  
443f 3a 49 44			ld a, (.dmark+2)  
4442 32 70 fe			ld (debug_mark+2),a  
4445 18 03			jr .pastdmark  
4447 ..			.dmark: db "S2b"  
444a f1			.pastdmark: pop af  
444b			endm  
# End of macro DMARK
444b						CALLMONITOR 
444b cd 9d 17			call break_point_state  
444e				endm  
# End of macro CALLMONITOR
444e					endif 
444e cd 0b 1e				call forth_push_numhl	 
4451			 
4451				 
4451				       NEXTW 
4451 c3 74 21			jp macro_next 
4454				endm 
# End of macro NEXTW
4454			.NUM2STR: 
4454				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4454 48				db WORD_SYS_CORE+52             
4455 63 44			dw .CONCAT            
4457 08				db 7 + 1 
4458 .. 00			db "NUM2STR",0              
4460				endm 
# End of macro CWHEAD
4460			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4460			 
4460			;		; malloc a string to target 
4460			;		ld hl, 10     ; TODO max string size should be fine 
4460			;		call malloc 
4460			;		push hl    ; save malloc location 
4460			; 
4460			; 
4460			;; TODO check int type 
4460			;		FORTH_DSP_VALUEHL 
4460			;		ld a, l 
4460			;		call DispAToASCII   
4460			;;TODO need to chage above call to dump into string 
4460			; 
4460			; 
4460			 
4460				       NEXTW 
4460 c3 74 21			jp macro_next 
4463				endm 
# End of macro NEXTW
4463			 
4463			.CONCAT: 
4463				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4463 48				db WORD_SYS_CORE+52             
4464 16 45			dw .FIND            
4466 07				db 6 + 1 
4467 .. 00			db "CONCAT",0              
446e				endm 
# End of macro CWHEAD
446e			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
446e			 
446e			; TODO check string type 
446e			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
446e			 
446e					if DEBUG_FORTH_WORDS_KEY 
446e						DMARK "CON" 
446e f5				push af  
446f 3a 83 44			ld a, (.dmark)  
4472 32 6e fe			ld (debug_mark),a  
4475 3a 84 44			ld a, (.dmark+1)  
4478 32 6f fe			ld (debug_mark+1),a  
447b 3a 85 44			ld a, (.dmark+2)  
447e 32 70 fe			ld (debug_mark+2),a  
4481 18 03			jr .pastdmark  
4483 ..			.dmark: db "CON"  
4486 f1			.pastdmark: pop af  
4487			endm  
# End of macro DMARK
4487						CALLMONITOR 
4487 cd 9d 17			call break_point_state  
448a				endm  
# End of macro CALLMONITOR
448a					endif 
448a			 
448a			 
448a					FORTH_DSP_VALUE 
448a cd eb 1f			call macro_forth_dsp_value 
448d				endm 
# End of macro FORTH_DSP_VALUE
448d e5					push hl   ; s2 
448e			 
448e					FORTH_DSP_POP 
448e cd ba 20			call macro_forth_dsp_pop 
4491				endm 
# End of macro FORTH_DSP_POP
4491			 
4491					FORTH_DSP_VALUE 
4491 cd eb 1f			call macro_forth_dsp_value 
4494				endm 
# End of macro FORTH_DSP_VALUE
4494			 
4494 e5					push hl   ; s1 
4495			 
4495					FORTH_DSP_POP 
4495 cd ba 20			call macro_forth_dsp_pop 
4498				endm 
# End of macro FORTH_DSP_POP
4498					 
4498			 
4498					; copy s1 
4498			 
4498				 
4498					; save ptr 
4498 e1					pop hl  
4499 e5					push hl 
449a 3e 00				ld a, 0 
449c cd 5f 12				call strlent 
449f					;inc hl    ; zer0 
449f 06 00				ld b, 0 
44a1 4d					ld c, l 
44a2 e1					pop hl		 
44a3 11 d4 f2				ld de, scratch	 
44a6					if DEBUG_FORTH_WORDS 
44a6						DMARK "CO1" 
44a6 f5				push af  
44a7 3a bb 44			ld a, (.dmark)  
44aa 32 6e fe			ld (debug_mark),a  
44ad 3a bc 44			ld a, (.dmark+1)  
44b0 32 6f fe			ld (debug_mark+1),a  
44b3 3a bd 44			ld a, (.dmark+2)  
44b6 32 70 fe			ld (debug_mark+2),a  
44b9 18 03			jr .pastdmark  
44bb ..			.dmark: db "CO1"  
44be f1			.pastdmark: pop af  
44bf			endm  
# End of macro DMARK
44bf						CALLMONITOR 
44bf cd 9d 17			call break_point_state  
44c2				endm  
# End of macro CALLMONITOR
44c2					endif 
44c2 ed b0				ldir 
44c4			 
44c4 e1					pop hl 
44c5 e5					push hl 
44c6 d5					push de 
44c7			 
44c7			 
44c7 3e 00				ld a, 0 
44c9 cd 5f 12				call strlent 
44cc 23					inc hl    ; zer0 
44cd 23					inc hl 
44ce 06 00				ld b, 0 
44d0 4d					ld c, l 
44d1 d1					pop de 
44d2 e1					pop hl		 
44d3					if DEBUG_FORTH_WORDS 
44d3						DMARK "CO2" 
44d3 f5				push af  
44d4 3a e8 44			ld a, (.dmark)  
44d7 32 6e fe			ld (debug_mark),a  
44da 3a e9 44			ld a, (.dmark+1)  
44dd 32 6f fe			ld (debug_mark+1),a  
44e0 3a ea 44			ld a, (.dmark+2)  
44e3 32 70 fe			ld (debug_mark+2),a  
44e6 18 03			jr .pastdmark  
44e8 ..			.dmark: db "CO2"  
44eb f1			.pastdmark: pop af  
44ec			endm  
# End of macro DMARK
44ec						CALLMONITOR 
44ec cd 9d 17			call break_point_state  
44ef				endm  
# End of macro CALLMONITOR
44ef					endif 
44ef ed b0				ldir 
44f1			 
44f1			 
44f1			 
44f1 21 d4 f2				ld hl, scratch 
44f4					if DEBUG_FORTH_WORDS 
44f4						DMARK "CO5" 
44f4 f5				push af  
44f5 3a 09 45			ld a, (.dmark)  
44f8 32 6e fe			ld (debug_mark),a  
44fb 3a 0a 45			ld a, (.dmark+1)  
44fe 32 6f fe			ld (debug_mark+1),a  
4501 3a 0b 45			ld a, (.dmark+2)  
4504 32 70 fe			ld (debug_mark+2),a  
4507 18 03			jr .pastdmark  
4509 ..			.dmark: db "CO5"  
450c f1			.pastdmark: pop af  
450d			endm  
# End of macro DMARK
450d						CALLMONITOR 
450d cd 9d 17			call break_point_state  
4510				endm  
# End of macro CALLMONITOR
4510					endif 
4510			 
4510 cd 79 1e				call forth_push_str 
4513			 
4513			 
4513			 
4513			 
4513				       NEXTW 
4513 c3 74 21			jp macro_next 
4516				endm 
# End of macro NEXTW
4516			 
4516			 
4516			.FIND: 
4516				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4516 4b				db WORD_SYS_CORE+55             
4517 d4 45			dw .LEN            
4519 05				db 4 + 1 
451a .. 00			db "FIND",0              
451f				endm 
# End of macro CWHEAD
451f			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
451f			 
451f					if DEBUG_FORTH_WORDS_KEY 
451f						DMARK "FND" 
451f f5				push af  
4520 3a 34 45			ld a, (.dmark)  
4523 32 6e fe			ld (debug_mark),a  
4526 3a 35 45			ld a, (.dmark+1)  
4529 32 6f fe			ld (debug_mark+1),a  
452c 3a 36 45			ld a, (.dmark+2)  
452f 32 70 fe			ld (debug_mark+2),a  
4532 18 03			jr .pastdmark  
4534 ..			.dmark: db "FND"  
4537 f1			.pastdmark: pop af  
4538			endm  
# End of macro DMARK
4538						CALLMONITOR 
4538 cd 9d 17			call break_point_state  
453b				endm  
# End of macro CALLMONITOR
453b					endif 
453b			 
453b			; TODO check string type 
453b					FORTH_DSP_VALUE 
453b cd eb 1f			call macro_forth_dsp_value 
453e				endm 
# End of macro FORTH_DSP_VALUE
453e			 
453e e5					push hl    
453f 7e					ld a,(hl)    ; char to find   
4540			; TODO change char to substr 
4540			 
4540 f5					push af 
4541					 
4541			 
4541			 
4541					if DEBUG_FORTH_WORDS 
4541						DMARK "FN1" 
4541 f5				push af  
4542 3a 56 45			ld a, (.dmark)  
4545 32 6e fe			ld (debug_mark),a  
4548 3a 57 45			ld a, (.dmark+1)  
454b 32 6f fe			ld (debug_mark+1),a  
454e 3a 58 45			ld a, (.dmark+2)  
4551 32 70 fe			ld (debug_mark+2),a  
4554 18 03			jr .pastdmark  
4556 ..			.dmark: db "FN1"  
4559 f1			.pastdmark: pop af  
455a			endm  
# End of macro DMARK
455a						CALLMONITOR 
455a cd 9d 17			call break_point_state  
455d				endm  
# End of macro CALLMONITOR
455d					endif 
455d			 
455d					FORTH_DSP_POP 
455d cd ba 20			call macro_forth_dsp_pop 
4560				endm 
# End of macro FORTH_DSP_POP
4560			 
4560					; string to search 
4560			 
4560					FORTH_DSP_VALUE 
4560 cd eb 1f			call macro_forth_dsp_value 
4563				endm 
# End of macro FORTH_DSP_VALUE
4563			 
4563 d1					pop de  ; d is char to find  
4564			 
4564					if DEBUG_FORTH_WORDS 
4564						DMARK "FN2" 
4564 f5				push af  
4565 3a 79 45			ld a, (.dmark)  
4568 32 6e fe			ld (debug_mark),a  
456b 3a 7a 45			ld a, (.dmark+1)  
456e 32 6f fe			ld (debug_mark+1),a  
4571 3a 7b 45			ld a, (.dmark+2)  
4574 32 70 fe			ld (debug_mark+2),a  
4577 18 03			jr .pastdmark  
4579 ..			.dmark: db "FN2"  
457c f1			.pastdmark: pop af  
457d			endm  
# End of macro DMARK
457d						CALLMONITOR 
457d cd 9d 17			call break_point_state  
4580				endm  
# End of macro CALLMONITOR
4580					endif 
4580					 
4580 01 00 00				ld bc, 0 
4583 7e			.findchar:      ld a,(hl) 
4584 fe 00				cp 0   		 
4586 28 27				jr z, .finddone     
4588 ba					cp d 
4589 28 20				jr z, .foundchar 
458b 03					inc bc 
458c 23					inc hl 
458d					if DEBUG_FORTH_WORDS 
458d						DMARK "FN3" 
458d f5				push af  
458e 3a a2 45			ld a, (.dmark)  
4591 32 6e fe			ld (debug_mark),a  
4594 3a a3 45			ld a, (.dmark+1)  
4597 32 6f fe			ld (debug_mark+1),a  
459a 3a a4 45			ld a, (.dmark+2)  
459d 32 70 fe			ld (debug_mark+2),a  
45a0 18 03			jr .pastdmark  
45a2 ..			.dmark: db "FN3"  
45a5 f1			.pastdmark: pop af  
45a6			endm  
# End of macro DMARK
45a6						CALLMONITOR 
45a6 cd 9d 17			call break_point_state  
45a9				endm  
# End of macro CALLMONITOR
45a9					endif 
45a9 18 d8				jr .findchar 
45ab			 
45ab			 
45ab c5			.foundchar:	push bc 
45ac e1					pop hl 
45ad 18 03				jr .findexit 
45af			 
45af			 
45af							 
45af			 
45af			.finddone:     ; got to end of string with no find 
45af 21 00 00				ld hl, 0 
45b2			.findexit: 
45b2			 
45b2					if DEBUG_FORTH_WORDS 
45b2						DMARK "FNd" 
45b2 f5				push af  
45b3 3a c7 45			ld a, (.dmark)  
45b6 32 6e fe			ld (debug_mark),a  
45b9 3a c8 45			ld a, (.dmark+1)  
45bc 32 6f fe			ld (debug_mark+1),a  
45bf 3a c9 45			ld a, (.dmark+2)  
45c2 32 70 fe			ld (debug_mark+2),a  
45c5 18 03			jr .pastdmark  
45c7 ..			.dmark: db "FNd"  
45ca f1			.pastdmark: pop af  
45cb			endm  
# End of macro DMARK
45cb						CALLMONITOR 
45cb cd 9d 17			call break_point_state  
45ce				endm  
# End of macro CALLMONITOR
45ce					endif 
45ce cd 0b 1e			call forth_push_numhl 
45d1			 
45d1				       NEXTW 
45d1 c3 74 21			jp macro_next 
45d4				endm 
# End of macro NEXTW
45d4			 
45d4			.LEN: 
45d4				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
45d4 4c				db WORD_SYS_CORE+56             
45d5 09 46			dw .CHAR            
45d7 06				db 5 + 1 
45d8 .. 00			db "COUNT",0              
45de				endm 
# End of macro CWHEAD
45de			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
45de			 
45de					if DEBUG_FORTH_WORDS_KEY 
45de						DMARK "CNT" 
45de f5				push af  
45df 3a f3 45			ld a, (.dmark)  
45e2 32 6e fe			ld (debug_mark),a  
45e5 3a f4 45			ld a, (.dmark+1)  
45e8 32 6f fe			ld (debug_mark+1),a  
45eb 3a f5 45			ld a, (.dmark+2)  
45ee 32 70 fe			ld (debug_mark+2),a  
45f1 18 03			jr .pastdmark  
45f3 ..			.dmark: db "CNT"  
45f6 f1			.pastdmark: pop af  
45f7			endm  
# End of macro DMARK
45f7						CALLMONITOR 
45f7 cd 9d 17			call break_point_state  
45fa				endm  
# End of macro CALLMONITOR
45fa					endif 
45fa			; TODO check string type 
45fa					FORTH_DSP 
45fa cd c8 1f			call macro_forth_dsp 
45fd				endm 
# End of macro FORTH_DSP
45fd					;v5FORTH_DSP_VALUE 
45fd			 
45fd 23					inc hl 
45fe			 
45fe 3e 00				ld a, 0 
4600 cd 5f 12				call strlent 
4603			 
4603 cd 0b 1e				call forth_push_numhl 
4606			 
4606			 
4606			 
4606				       NEXTW 
4606 c3 74 21			jp macro_next 
4609				endm 
# End of macro NEXTW
4609			.CHAR: 
4609				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4609 4d				db WORD_SYS_CORE+57             
460a 3f 46			dw .ENDSTR            
460c 05				db 4 + 1 
460d .. 00			db "CHAR",0              
4612				endm 
# End of macro CWHEAD
4612			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4612					if DEBUG_FORTH_WORDS_KEY 
4612						DMARK "CHR" 
4612 f5				push af  
4613 3a 27 46			ld a, (.dmark)  
4616 32 6e fe			ld (debug_mark),a  
4619 3a 28 46			ld a, (.dmark+1)  
461c 32 6f fe			ld (debug_mark+1),a  
461f 3a 29 46			ld a, (.dmark+2)  
4622 32 70 fe			ld (debug_mark+2),a  
4625 18 03			jr .pastdmark  
4627 ..			.dmark: db "CHR"  
462a f1			.pastdmark: pop af  
462b			endm  
# End of macro DMARK
462b						CALLMONITOR 
462b cd 9d 17			call break_point_state  
462e				endm  
# End of macro CALLMONITOR
462e					endif 
462e					FORTH_DSP 
462e cd c8 1f			call macro_forth_dsp 
4631				endm 
# End of macro FORTH_DSP
4631					;v5 FORTH_DSP_VALUE 
4631 23					inc hl      ; now at start of numeric as string 
4632			 
4632			;		push hl 
4632			 
4632					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4632 cd ba 20			call macro_forth_dsp_pop 
4635				endm 
# End of macro FORTH_DSP_POP
4635			 
4635			;		pop hl 
4635			 
4635					; push the content of a onto the stack as a value 
4635			 
4635 7e					ld a,(hl)   ; get char 
4636 26 00				ld h,0 
4638 6f					ld l,a 
4639 cd 0b 1e				call forth_push_numhl 
463c			 
463c				       NEXTW 
463c c3 74 21			jp macro_next 
463f				endm 
# End of macro NEXTW
463f			 
463f			 
463f			 
463f			 
463f			.ENDSTR: 
463f			; eof 
463f			 
# End of file forth_words_str.asm
463f			include "forth_words_key.asm" 
463f			 
463f			; | ## Keyboard Words 
463f			 
463f			.KEY: 
463f				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
463f 3e				db WORD_SYS_CORE+42             
4640 6f 46			dw .WAITK            
4642 04				db 3 + 1 
4643 .. 00			db "KEY",0              
4647				endm 
# End of macro CWHEAD
4647			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4647			 
4647					if DEBUG_FORTH_WORDS_KEY 
4647						DMARK "KEY" 
4647 f5				push af  
4648 3a 5c 46			ld a, (.dmark)  
464b 32 6e fe			ld (debug_mark),a  
464e 3a 5d 46			ld a, (.dmark+1)  
4651 32 6f fe			ld (debug_mark+1),a  
4654 3a 5e 46			ld a, (.dmark+2)  
4657 32 70 fe			ld (debug_mark+2),a  
465a 18 03			jr .pastdmark  
465c ..			.dmark: db "KEY"  
465f f1			.pastdmark: pop af  
4660			endm  
# End of macro DMARK
4660						CALLMONITOR 
4660 cd 9d 17			call break_point_state  
4663				endm  
# End of macro CALLMONITOR
4663					endif 
4663			; TODO currently waits 
4663 cd 54 6b				call cin 
4666					;call cin_wait 
4666 6f					ld l, a 
4667 26 00				ld h, 0 
4669 cd 0b 1e				call forth_push_numhl 
466c					NEXTW 
466c c3 74 21			jp macro_next 
466f				endm 
# End of macro NEXTW
466f			.WAITK: 
466f				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
466f 3f				db WORD_SYS_CORE+43             
4670 a1 46			dw .ACCEPT            
4672 06				db 5 + 1 
4673 .. 00			db "WAITK",0              
4679				endm 
# End of macro CWHEAD
4679			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4679					if DEBUG_FORTH_WORDS_KEY 
4679						DMARK "WAI" 
4679 f5				push af  
467a 3a 8e 46			ld a, (.dmark)  
467d 32 6e fe			ld (debug_mark),a  
4680 3a 8f 46			ld a, (.dmark+1)  
4683 32 6f fe			ld (debug_mark+1),a  
4686 3a 90 46			ld a, (.dmark+2)  
4689 32 70 fe			ld (debug_mark+2),a  
468c 18 03			jr .pastdmark  
468e ..			.dmark: db "WAI"  
4691 f1			.pastdmark: pop af  
4692			endm  
# End of macro DMARK
4692						CALLMONITOR 
4692 cd 9d 17			call break_point_state  
4695				endm  
# End of macro CALLMONITOR
4695					endif 
4695 cd 43 6b				call cin_wait 
4698 6f					ld l, a 
4699 26 00				ld h, 0 
469b cd 0b 1e				call forth_push_numhl 
469e					NEXTW 
469e c3 74 21			jp macro_next 
46a1				endm 
# End of macro NEXTW
46a1			.ACCEPT: 
46a1				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
46a1 40				db WORD_SYS_CORE+44             
46a2 ff 46			dw .EDIT            
46a4 07				db 6 + 1 
46a5 .. 00			db "ACCEPT",0              
46ac				endm 
# End of macro CWHEAD
46ac			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
46ac					; TODO crashes on push 
46ac					if DEBUG_FORTH_WORDS_KEY 
46ac						DMARK "ACC" 
46ac f5				push af  
46ad 3a c1 46			ld a, (.dmark)  
46b0 32 6e fe			ld (debug_mark),a  
46b3 3a c2 46			ld a, (.dmark+1)  
46b6 32 6f fe			ld (debug_mark+1),a  
46b9 3a c3 46			ld a, (.dmark+2)  
46bc 32 70 fe			ld (debug_mark+2),a  
46bf 18 03			jr .pastdmark  
46c1 ..			.dmark: db "ACC"  
46c4 f1			.pastdmark: pop af  
46c5			endm  
# End of macro DMARK
46c5						CALLMONITOR 
46c5 cd 9d 17			call break_point_state  
46c8				endm  
# End of macro CALLMONITOR
46c8					endif 
46c8 21 d2 f4				ld hl, os_input 
46cb 3e 00				ld a, 0 
46cd 77					ld (hl),a 
46ce 3a 3d fb				ld a,(f_cursor_ptr) 
46d1 16 64				ld d, 100 
46d3 0e 00				ld c, 0 
46d5 1e 28				ld e, 40 
46d7 cd 23 0e				call input_str 
46da					; TODO perhaps do a type check and wrap in quotes if not a number 
46da 21 d2 f4				ld hl, os_input 
46dd					if DEBUG_FORTH_WORDS 
46dd						DMARK "AC1" 
46dd f5				push af  
46de 3a f2 46			ld a, (.dmark)  
46e1 32 6e fe			ld (debug_mark),a  
46e4 3a f3 46			ld a, (.dmark+1)  
46e7 32 6f fe			ld (debug_mark+1),a  
46ea 3a f4 46			ld a, (.dmark+2)  
46ed 32 70 fe			ld (debug_mark+2),a  
46f0 18 03			jr .pastdmark  
46f2 ..			.dmark: db "AC1"  
46f5 f1			.pastdmark: pop af  
46f6			endm  
# End of macro DMARK
46f6						CALLMONITOR 
46f6 cd 9d 17			call break_point_state  
46f9				endm  
# End of macro CALLMONITOR
46f9					endif 
46f9 cd 79 1e				call forth_push_str 
46fc					NEXTW 
46fc c3 74 21			jp macro_next 
46ff				endm 
# End of macro NEXTW
46ff			 
46ff			.EDIT: 
46ff				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
46ff 40				db WORD_SYS_CORE+44             
4700 a1 47			dw .ENDKEY            
4702 05				db 4 + 1 
4703 .. 00			db "EDIT",0              
4708				endm 
# End of macro CWHEAD
4708			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4708			 
4708					; TODO does not copy from stack 
4708					if DEBUG_FORTH_WORDS_KEY 
4708						DMARK "EDT" 
4708 f5				push af  
4709 3a 1d 47			ld a, (.dmark)  
470c 32 6e fe			ld (debug_mark),a  
470f 3a 1e 47			ld a, (.dmark+1)  
4712 32 6f fe			ld (debug_mark+1),a  
4715 3a 1f 47			ld a, (.dmark+2)  
4718 32 70 fe			ld (debug_mark+2),a  
471b 18 03			jr .pastdmark  
471d ..			.dmark: db "EDT"  
4720 f1			.pastdmark: pop af  
4721			endm  
# End of macro DMARK
4721						CALLMONITOR 
4721 cd 9d 17			call break_point_state  
4724				endm  
# End of macro CALLMONITOR
4724					endif 
4724			 
4724					;FORTH_DSP 
4724					FORTH_DSP_VALUEHL 
4724 cd 02 20			call macro_dsp_valuehl 
4727				endm 
# End of macro FORTH_DSP_VALUEHL
4727			;		inc hl    ; TODO do type check 
4727			 
4727			;		call get_word_hl 
4727 e5					push hl 
4728					if DEBUG_FORTH_WORDS 
4728						DMARK "EDp" 
4728 f5				push af  
4729 3a 3d 47			ld a, (.dmark)  
472c 32 6e fe			ld (debug_mark),a  
472f 3a 3e 47			ld a, (.dmark+1)  
4732 32 6f fe			ld (debug_mark+1),a  
4735 3a 3f 47			ld a, (.dmark+2)  
4738 32 70 fe			ld (debug_mark+2),a  
473b 18 03			jr .pastdmark  
473d ..			.dmark: db "EDp"  
4740 f1			.pastdmark: pop af  
4741			endm  
# End of macro DMARK
4741						CALLMONITOR 
4741 cd 9d 17			call break_point_state  
4744				endm  
# End of macro CALLMONITOR
4744					endif 
4744				;	ld a, 0 
4744 cd 54 12				call strlenz 
4747 23					inc hl 
4748			 
4748 06 00				ld b, 0 
474a 4d					ld c, l 
474b			 
474b e1					pop hl 
474c 11 d2 f4				ld de, os_input 
474f					if DEBUG_FORTH_WORDS_KEY 
474f						DMARK "EDc" 
474f f5				push af  
4750 3a 64 47			ld a, (.dmark)  
4753 32 6e fe			ld (debug_mark),a  
4756 3a 65 47			ld a, (.dmark+1)  
4759 32 6f fe			ld (debug_mark+1),a  
475c 3a 66 47			ld a, (.dmark+2)  
475f 32 70 fe			ld (debug_mark+2),a  
4762 18 03			jr .pastdmark  
4764 ..			.dmark: db "EDc"  
4767 f1			.pastdmark: pop af  
4768			endm  
# End of macro DMARK
4768						CALLMONITOR 
4768 cd 9d 17			call break_point_state  
476b				endm  
# End of macro CALLMONITOR
476b					endif 
476b ed b0				ldir 
476d			 
476d			 
476d 21 d2 f4				ld hl, os_input 
4770					;ld a, 0 
4770					;ld (hl),a 
4770 3a 3d fb				ld a,(f_cursor_ptr) 
4773 16 64				ld d, 100 
4775 0e 00				ld c, 0 
4777 1e 28				ld e, 40 
4779 cd 23 0e				call input_str 
477c					; TODO perhaps do a type check and wrap in quotes if not a number 
477c 21 d2 f4				ld hl, os_input 
477f					if DEBUG_FORTH_WORDS 
477f						DMARK "ED1" 
477f f5				push af  
4780 3a 94 47			ld a, (.dmark)  
4783 32 6e fe			ld (debug_mark),a  
4786 3a 95 47			ld a, (.dmark+1)  
4789 32 6f fe			ld (debug_mark+1),a  
478c 3a 96 47			ld a, (.dmark+2)  
478f 32 70 fe			ld (debug_mark+2),a  
4792 18 03			jr .pastdmark  
4794 ..			.dmark: db "ED1"  
4797 f1			.pastdmark: pop af  
4798			endm  
# End of macro DMARK
4798						CALLMONITOR 
4798 cd 9d 17			call break_point_state  
479b				endm  
# End of macro CALLMONITOR
479b					endif 
479b cd 79 1e				call forth_push_str 
479e					NEXTW 
479e c3 74 21			jp macro_next 
47a1				endm 
# End of macro NEXTW
47a1			 
47a1			 
47a1			 
47a1			.ENDKEY: 
47a1			; eof 
47a1			 
# End of file forth_words_key.asm
47a1			 
47a1			if STORAGE_SE 
47a1			   	include "forth_words_storage.asm" 
47a1			 
47a1			; | ## Fixed Storage Words 
47a1			 
47a1			.RECORD: 
47a1			  
47a1				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
47a1 3a				db WORD_SYS_CORE+38             
47a2 45 48			dw .BREAD            
47a4 07				db 6 + 1 
47a5 .. 00			db "RECORD",0              
47ac				endm 
# End of macro CWHEAD
47ac			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
47ac			 
47ac					if DEBUG_FORTH_WORDS_KEY 
47ac						DMARK "REC" 
47ac f5				push af  
47ad 3a c1 47			ld a, (.dmark)  
47b0 32 6e fe			ld (debug_mark),a  
47b3 3a c2 47			ld a, (.dmark+1)  
47b6 32 6f fe			ld (debug_mark+1),a  
47b9 3a c3 47			ld a, (.dmark+2)  
47bc 32 70 fe			ld (debug_mark+2),a  
47bf 18 03			jr .pastdmark  
47c1 ..			.dmark: db "REC"  
47c4 f1			.pastdmark: pop af  
47c5			endm  
# End of macro DMARK
47c5						CALLMONITOR 
47c5 cd 9d 17			call break_point_state  
47c8				endm  
# End of macro CALLMONITOR
47c8					endif 
47c8			 
47c8					FORTH_DSP_VALUEHL 
47c8 cd 02 20			call macro_dsp_valuehl 
47cb				endm 
# End of macro FORTH_DSP_VALUEHL
47cb			 
47cb e5					push hl    ; id 
47cc			 
47cc					FORTH_DSP_POP 
47cc cd ba 20			call macro_forth_dsp_pop 
47cf				endm 
# End of macro FORTH_DSP_POP
47cf			 
47cf					FORTH_DSP_VALUEHL 
47cf cd 02 20			call macro_dsp_valuehl 
47d2				endm 
# End of macro FORTH_DSP_VALUEHL
47d2			 
47d2					FORTH_DSP_POP 
47d2 cd ba 20			call macro_forth_dsp_pop 
47d5				endm 
# End of macro FORTH_DSP_POP
47d5			 
47d5 d1					pop de     ; get file id 
47d6			 
47d6					; e = file id 
47d6					; l = file extent 
47d6			 
47d6			 
47d6					; construct request to access file extent 
47d6			 
47d6			;		ld a, e 
47d6 63					ld h, e 
47d7					 
47d7					 
47d7					 
47d7			 
47d7					; e has id 
47d7			 
47d7 11 59 fb			ld de, store_page 
47da					if DEBUG_FORTH_WORDS 
47da						DMARK "REr" 
47da f5				push af  
47db 3a ef 47			ld a, (.dmark)  
47de 32 6e fe			ld (debug_mark),a  
47e1 3a f0 47			ld a, (.dmark+1)  
47e4 32 6f fe			ld (debug_mark+1),a  
47e7 3a f1 47			ld a, (.dmark+2)  
47ea 32 70 fe			ld (debug_mark+2),a  
47ed 18 03			jr .pastdmark  
47ef ..			.dmark: db "REr"  
47f2 f1			.pastdmark: pop af  
47f3			endm  
# End of macro DMARK
47f3						CALLMONITOR 
47f3 cd 9d 17			call break_point_state  
47f6				endm  
# End of macro CALLMONITOR
47f6					endif 
47f6 cd 2d 09				call storage_read 
47f9 cd 1f 0e			call ishlzero 
47fc 28 22			jr z, .recnotfound 
47fe			 
47fe			 
47fe					if DEBUG_FORTH_WORDS 
47fe						DMARK "REe" 
47fe f5				push af  
47ff 3a 13 48			ld a, (.dmark)  
4802 32 6e fe			ld (debug_mark),a  
4805 3a 14 48			ld a, (.dmark+1)  
4808 32 6f fe			ld (debug_mark+1),a  
480b 3a 15 48			ld a, (.dmark+2)  
480e 32 70 fe			ld (debug_mark+2),a  
4811 18 03			jr .pastdmark  
4813 ..			.dmark: db "REe"  
4816 f1			.pastdmark: pop af  
4817			endm  
# End of macro DMARK
4817						CALLMONITOR 
4817 cd 9d 17			call break_point_state  
481a				endm  
# End of macro CALLMONITOR
481a					endif 
481a cd 79 1e			call forth_push_str 
481d			 
481d					NEXTW 
481d c3 74 21			jp macro_next 
4820				endm 
# End of macro NEXTW
4820			 
4820			.recnotfound: 
4820					if DEBUG_FORTH_WORDS 
4820						DMARK "REf" 
4820 f5				push af  
4821 3a 35 48			ld a, (.dmark)  
4824 32 6e fe			ld (debug_mark),a  
4827 3a 36 48			ld a, (.dmark+1)  
482a 32 6f fe			ld (debug_mark+1),a  
482d 3a 37 48			ld a, (.dmark+2)  
4830 32 70 fe			ld (debug_mark+2),a  
4833 18 03			jr .pastdmark  
4835 ..			.dmark: db "REf"  
4838 f1			.pastdmark: pop af  
4839			endm  
# End of macro DMARK
4839						CALLMONITOR 
4839 cd 9d 17			call break_point_state  
483c				endm  
# End of macro CALLMONITOR
483c					endif 
483c 21 ff 00			ld hl, 255 
483f cd 0b 1e			call forth_push_numhl 
4842				NEXTW 
4842 c3 74 21			jp macro_next 
4845				endm 
# End of macro NEXTW
4845			 
4845			 
4845			.BREAD: 
4845			  
4845				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4845 3a				db WORD_SYS_CORE+38             
4846 c8 48			dw .BWRITE            
4848 06				db 5 + 1 
4849 .. 00			db "BREAD",0              
484f				endm 
# End of macro CWHEAD
484f			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
484f				 
484f					if DEBUG_FORTH_WORDS_KEY 
484f						DMARK "BRD" 
484f f5				push af  
4850 3a 64 48			ld a, (.dmark)  
4853 32 6e fe			ld (debug_mark),a  
4856 3a 65 48			ld a, (.dmark+1)  
4859 32 6f fe			ld (debug_mark+1),a  
485c 3a 66 48			ld a, (.dmark+2)  
485f 32 70 fe			ld (debug_mark+2),a  
4862 18 03			jr .pastdmark  
4864 ..			.dmark: db "BRD"  
4867 f1			.pastdmark: pop af  
4868			endm  
# End of macro DMARK
4868						CALLMONITOR 
4868 cd 9d 17			call break_point_state  
486b				endm  
# End of macro CALLMONITOR
486b					endif 
486b			 
486b				FORTH_DSP_VALUEHL 
486b cd 02 20			call macro_dsp_valuehl 
486e				endm 
# End of macro FORTH_DSP_VALUEHL
486e			 
486e				FORTH_DSP_POP 
486e cd ba 20			call macro_forth_dsp_pop 
4871				endm 
# End of macro FORTH_DSP_POP
4871			 
4871				; calc block address 
4871			 
4871 eb				ex de, hl 
4872 3e 40			ld a, STORE_BLOCK_PHY 
4874 cd 79 0d			call Mult16 
4877			 
4877			 
4877 11 59 fb			ld de, store_page 
487a			 
487a					if DEBUG_FORTH_WORDS 
487a						DMARK "BR1" 
487a f5				push af  
487b 3a 8f 48			ld a, (.dmark)  
487e 32 6e fe			ld (debug_mark),a  
4881 3a 90 48			ld a, (.dmark+1)  
4884 32 6f fe			ld (debug_mark+1),a  
4887 3a 91 48			ld a, (.dmark+2)  
488a 32 70 fe			ld (debug_mark+2),a  
488d 18 03			jr .pastdmark  
488f ..			.dmark: db "BR1"  
4892 f1			.pastdmark: pop af  
4893			endm  
# End of macro DMARK
4893						CALLMONITOR 
4893 cd 9d 17			call break_point_state  
4896				endm  
# End of macro CALLMONITOR
4896					endif 
4896			 
4896 cd d4 03			call storage_read_block 
4899			 
4899 cd 1f 0e			call ishlzero 
489c 20 05			jr nz, .brfound 
489e			 
489e cd 0b 1e			call forth_push_numhl 
48a1 18 22			jr .brdone 
48a3			 
48a3			 
48a3			.brfound: 
48a3 21 5b fb		        ld hl, store_page+2 
48a6			 
48a6					if DEBUG_FORTH_WORDS 
48a6						DMARK "BR2" 
48a6 f5				push af  
48a7 3a bb 48			ld a, (.dmark)  
48aa 32 6e fe			ld (debug_mark),a  
48ad 3a bc 48			ld a, (.dmark+1)  
48b0 32 6f fe			ld (debug_mark+1),a  
48b3 3a bd 48			ld a, (.dmark+2)  
48b6 32 70 fe			ld (debug_mark+2),a  
48b9 18 03			jr .pastdmark  
48bb ..			.dmark: db "BR2"  
48be f1			.pastdmark: pop af  
48bf			endm  
# End of macro DMARK
48bf						CALLMONITOR 
48bf cd 9d 17			call break_point_state  
48c2				endm  
# End of macro CALLMONITOR
48c2					endif 
48c2			 
48c2 cd 79 1e			call forth_push_str 
48c5			 
48c5			 
48c5			.brdone: 
48c5			 
48c5					NEXTW 
48c5 c3 74 21			jp macro_next 
48c8				endm 
# End of macro NEXTW
48c8			.BWRITE: 
48c8				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
48c8 3a				db WORD_SYS_CORE+38             
48c9 5d 49			dw .BUPD            
48cb 07				db 6 + 1 
48cc .. 00			db "BWRITE",0              
48d3				endm 
# End of macro CWHEAD
48d3			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
48d3			 
48d3					if DEBUG_FORTH_WORDS_KEY 
48d3						DMARK "BWR" 
48d3 f5				push af  
48d4 3a e8 48			ld a, (.dmark)  
48d7 32 6e fe			ld (debug_mark),a  
48da 3a e9 48			ld a, (.dmark+1)  
48dd 32 6f fe			ld (debug_mark+1),a  
48e0 3a ea 48			ld a, (.dmark+2)  
48e3 32 70 fe			ld (debug_mark+2),a  
48e6 18 03			jr .pastdmark  
48e8 ..			.dmark: db "BWR"  
48eb f1			.pastdmark: pop af  
48ec			endm  
# End of macro DMARK
48ec						CALLMONITOR 
48ec cd 9d 17			call break_point_state  
48ef				endm  
# End of macro CALLMONITOR
48ef					endif 
48ef			 
48ef				FORTH_DSP_VALUEHL 
48ef cd 02 20			call macro_dsp_valuehl 
48f2				endm 
# End of macro FORTH_DSP_VALUEHL
48f2			 
48f2				; calc block address 
48f2			 
48f2 eb				ex de, hl 
48f3 3e 40			ld a, STORE_BLOCK_PHY 
48f5 cd 79 0d			call Mult16 
48f8			 
48f8 e5				push hl         ; address 
48f9			 
48f9				FORTH_DSP_POP 
48f9 cd ba 20			call macro_forth_dsp_pop 
48fc				endm 
# End of macro FORTH_DSP_POP
48fc			 
48fc				FORTH_DSP_VALUEHL 
48fc cd 02 20			call macro_dsp_valuehl 
48ff				endm 
# End of macro FORTH_DSP_VALUEHL
48ff			 
48ff				FORTH_DSP_POP 
48ff cd ba 20			call macro_forth_dsp_pop 
4902				endm 
# End of macro FORTH_DSP_POP
4902			 
4902 cd 02 0b			call storage_clear_page 
4905			 
4905				; copy string to store page 
4905			 
4905 e5				push hl     ; save string address 
4906			 
4906 3e 00			ld a, 0 
4908 cd 5f 12			call strlent 
490b			 
490b 23				inc hl 
490c			 
490c 4d				ld c, l 
490d 06 00			ld b, 0 
490f			 
490f e1				pop hl 
4910 11 5b fb			ld de, store_page + 2 
4913					if DEBUG_FORTH_WORDS 
4913						DMARK "BW1" 
4913 f5				push af  
4914 3a 28 49			ld a, (.dmark)  
4917 32 6e fe			ld (debug_mark),a  
491a 3a 29 49			ld a, (.dmark+1)  
491d 32 6f fe			ld (debug_mark+1),a  
4920 3a 2a 49			ld a, (.dmark+2)  
4923 32 70 fe			ld (debug_mark+2),a  
4926 18 03			jr .pastdmark  
4928 ..			.dmark: db "BW1"  
492b f1			.pastdmark: pop af  
492c			endm  
# End of macro DMARK
492c						CALLMONITOR 
492c cd 9d 17			call break_point_state  
492f				endm  
# End of macro CALLMONITOR
492f					endif 
492f ed b0			ldir 
4931			 
4931			 
4931				; poke the start of the block with flags to prevent high level file ops hitting the block 
4931			 
4931 21 ff ff			ld hl, $ffff 
4934			 
4934 22 59 fb			ld (store_page), hl	 
4937				 
4937 e1				pop hl    ; get address 
4938 11 59 fb			ld de, store_page 
493b			 
493b					if DEBUG_FORTH_WORDS 
493b						DMARK "BW2" 
493b f5				push af  
493c 3a 50 49			ld a, (.dmark)  
493f 32 6e fe			ld (debug_mark),a  
4942 3a 51 49			ld a, (.dmark+1)  
4945 32 6f fe			ld (debug_mark+1),a  
4948 3a 52 49			ld a, (.dmark+2)  
494b 32 70 fe			ld (debug_mark+2),a  
494e 18 03			jr .pastdmark  
4950 ..			.dmark: db "BW2"  
4953 f1			.pastdmark: pop af  
4954			endm  
# End of macro DMARK
4954						CALLMONITOR 
4954 cd 9d 17			call break_point_state  
4957				endm  
# End of macro CALLMONITOR
4957					endif 
4957			 
4957 cd 39 04			call storage_write_block 
495a			 
495a					NEXTW 
495a c3 74 21			jp macro_next 
495d				endm 
# End of macro NEXTW
495d			 
495d			.BUPD: 
495d				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
495d 3a				db WORD_SYS_CORE+38             
495e b3 49			dw .BYID            
4960 05				db 4 + 1 
4961 .. 00			db "BUPD",0              
4966				endm 
# End of macro CWHEAD
4966			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4966			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4966			; | | or completely different file system structure. 
4966			 
4966					if DEBUG_FORTH_WORDS_KEY 
4966						DMARK "BUD" 
4966 f5				push af  
4967 3a 7b 49			ld a, (.dmark)  
496a 32 6e fe			ld (debug_mark),a  
496d 3a 7c 49			ld a, (.dmark+1)  
4970 32 6f fe			ld (debug_mark+1),a  
4973 3a 7d 49			ld a, (.dmark+2)  
4976 32 70 fe			ld (debug_mark+2),a  
4979 18 03			jr .pastdmark  
497b ..			.dmark: db "BUD"  
497e f1			.pastdmark: pop af  
497f			endm  
# End of macro DMARK
497f						CALLMONITOR 
497f cd 9d 17			call break_point_state  
4982				endm  
# End of macro CALLMONITOR
4982					endif 
4982			 
4982				FORTH_DSP_VALUEHL 
4982 cd 02 20			call macro_dsp_valuehl 
4985				endm 
# End of macro FORTH_DSP_VALUEHL
4985			 
4985				; calc block address 
4985			 
4985 eb				ex de, hl 
4986 3e 40			ld a, STORE_BLOCK_PHY 
4988 cd 79 0d			call Mult16 
498b			 
498b				FORTH_DSP_POP 
498b cd ba 20			call macro_forth_dsp_pop 
498e				endm 
# End of macro FORTH_DSP_POP
498e			 
498e			 
498e 11 59 fb			ld de, store_page 
4991			 
4991					if DEBUG_FORTH_WORDS 
4991						DMARK "BUe" 
4991 f5				push af  
4992 3a a6 49			ld a, (.dmark)  
4995 32 6e fe			ld (debug_mark),a  
4998 3a a7 49			ld a, (.dmark+1)  
499b 32 6f fe			ld (debug_mark+1),a  
499e 3a a8 49			ld a, (.dmark+2)  
49a1 32 70 fe			ld (debug_mark+2),a  
49a4 18 03			jr .pastdmark  
49a6 ..			.dmark: db "BUe"  
49a9 f1			.pastdmark: pop af  
49aa			endm  
# End of macro DMARK
49aa						CALLMONITOR 
49aa cd 9d 17			call break_point_state  
49ad				endm  
# End of macro CALLMONITOR
49ad					endif 
49ad			 
49ad cd 39 04			call storage_write_block 
49b0			 
49b0					NEXTW 
49b0 c3 74 21			jp macro_next 
49b3				endm 
# End of macro NEXTW
49b3			 
49b3			.BYID: 
49b3			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
49b3			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
49b3			; 
49b3			;		 
49b3			;		if DEBUG_FORTH_WORDS_KEY 
49b3			;			DMARK "BYID" 
49b3			;			CALLMONITOR 
49b3			;		endif 
49b3			; 
49b3			;		; get direct address 
49b3			; 
49b3			;		FORTH_DSP_VALUEHL 
49b3			; 
49b3			;		FORTH_DSP_POP 
49b3			; 
49b3			;	; calc block address 
49b3			; 
49b3			;	ex de, hl 
49b3			;	ld a, STORE_BLOCK_PHY 
49b3			;	call Mult16 
49b3			;	;	do BREAD with number as param 
49b3			;	; push the file name	 
49b3			;	ld de, store_page 
49b3			;	call storage_read_block 
49b3			 ;       ld hl, store_page+2 
49b3			; 
49b3			; 
49b3			;		NEXTW 
49b3			;.BYNAME: 
49b3				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
49b3 3a				db WORD_SYS_CORE+38             
49b4 cc 49			dw .DIR            
49b6 06				db 5 + 1 
49b7 .. 00			db "GETID",0              
49bd				endm 
# End of macro CWHEAD
49bd			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
49bd			 
49bd					; get pointer to file name to seek 
49bd			 
49bd					FORTH_DSP_VALUEHL 
49bd cd 02 20			call macro_dsp_valuehl 
49c0				endm 
# End of macro FORTH_DSP_VALUEHL
49c0			 
49c0			 
49c0 cd fb 02				call storage_getid  
49c3			 
49c3					FORTH_DSP_POP 
49c3 cd ba 20			call macro_forth_dsp_pop 
49c6				endm 
# End of macro FORTH_DSP_POP
49c6			 
49c6 cd 0b 1e				call forth_push_numhl 
49c9			 
49c9					NEXTW 
49c9 c3 74 21			jp macro_next 
49cc				endm 
# End of macro NEXTW
49cc			; 
49cc			.DIR: 
49cc				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
49cc 3a				db WORD_SYS_CORE+38             
49cd d0 4a			dw .SAVE            
49cf 04				db 3 + 1 
49d0 .. 00			db "DIR",0              
49d4				endm 
# End of macro CWHEAD
49d4			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
49d4			 
49d4					if DEBUG_FORTH_WORDS_KEY 
49d4						DMARK "DIR" 
49d4 f5				push af  
49d5 3a e9 49			ld a, (.dmark)  
49d8 32 6e fe			ld (debug_mark),a  
49db 3a ea 49			ld a, (.dmark+1)  
49de 32 6f fe			ld (debug_mark+1),a  
49e1 3a eb 49			ld a, (.dmark+2)  
49e4 32 70 fe			ld (debug_mark+2),a  
49e7 18 03			jr .pastdmark  
49e9 ..			.dmark: db "DIR"  
49ec f1			.pastdmark: pop af  
49ed			endm  
# End of macro DMARK
49ed						CALLMONITOR 
49ed cd 9d 17			call break_point_state  
49f0				endm  
# End of macro CALLMONITOR
49f0					endif 
49f0 cd 85 04			call storage_get_block_0 
49f3			 
49f3 21 59 fb			ld hl, store_page     ; get current id count 
49f6 46				ld b, (hl) 
49f7 0e 00			ld c, 0    ; count of files   
49f9					if DEBUG_FORTH_WORDS 
49f9						DMARK "DI1" 
49f9 f5				push af  
49fa 3a 0e 4a			ld a, (.dmark)  
49fd 32 6e fe			ld (debug_mark),a  
4a00 3a 0f 4a			ld a, (.dmark+1)  
4a03 32 6f fe			ld (debug_mark+1),a  
4a06 3a 10 4a			ld a, (.dmark+2)  
4a09 32 70 fe			ld (debug_mark+2),a  
4a0c 18 03			jr .pastdmark  
4a0e ..			.dmark: db "DI1"  
4a11 f1			.pastdmark: pop af  
4a12			endm  
# End of macro DMARK
4a12						CALLMONITOR 
4a12 cd 9d 17			call break_point_state  
4a15				endm  
# End of macro CALLMONITOR
4a15					endif 
4a15			 
4a15				; check for empty drive 
4a15			 
4a15 3e 00			ld a, 0 
4a17 b8				cp b 
4a18 ca 86 4a			jp z, .dirdone 
4a1b			 
4a1b				; for each of the current ids do a search for them and if found push to stack 
4a1b			 
4a1b c5			.diritem:	push bc 
4a1c 21 40 00				ld hl, STORE_BLOCK_PHY 
4a1f 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4a21 58					ld e,b 
4a22			 
4a22			;		if DEBUG_FORTH_WORDS 
4a22			;			DMARK "DI2" 
4a22			;			CALLMONITOR 
4a22			;		endif 
4a22			 
4a22 cd 07 07				call storage_findnextid 
4a25			 
4a25			;		if DEBUG_FORTH_WORDS 
4a25			;			DMARK "DI3" 
4a25			;			CALLMONITOR 
4a25			;		endif 
4a25			 
4a25					; if found hl will be non zero 
4a25			 
4a25 cd 1f 0e				call ishlzero 
4a28			;		ld a, l 
4a28			;		add h 
4a28			; 
4a28			;		cp 0 
4a28 28 59				jr z, .dirnotfound 
4a2a			 
4a2a					; increase count 
4a2a			 
4a2a c1					pop bc	 
4a2b 0c					inc c 
4a2c c5					push bc 
4a2d					 
4a2d			 
4a2d					; get file header and push the file name 
4a2d			 
4a2d 11 59 fb				ld de, store_page 
4a30 cd d4 03				call storage_read_block 
4a33			 
4a33					; push file id to stack 
4a33				 
4a33 3a 59 fb				ld a, (store_page) 
4a36 26 00				ld h, 0 
4a38 6f					ld l, a 
4a39 cd 0b 1e				call forth_push_numhl 
4a3c			 
4a3c					; push extent count to stack  
4a3c				 
4a3c 3a 5b fb				ld a, (store_page+2) 
4a3f 26 00				ld h, 0 
4a41 6f					ld l, a 
4a42 cd 0b 1e				call forth_push_numhl 
4a45			 
4a45					; push file name 
4a45			 
4a45 21 5c fb				ld hl, store_page+3 
4a48					if DEBUG_FORTH_WORDS 
4a48						DMARK "DI5" 
4a48 f5				push af  
4a49 3a 5d 4a			ld a, (.dmark)  
4a4c 32 6e fe			ld (debug_mark),a  
4a4f 3a 5e 4a			ld a, (.dmark+1)  
4a52 32 6f fe			ld (debug_mark+1),a  
4a55 3a 5f 4a			ld a, (.dmark+2)  
4a58 32 70 fe			ld (debug_mark+2),a  
4a5b 18 03			jr .pastdmark  
4a5d ..			.dmark: db "DI5"  
4a60 f1			.pastdmark: pop af  
4a61			endm  
# End of macro DMARK
4a61						CALLMONITOR 
4a61 cd 9d 17			call break_point_state  
4a64				endm  
# End of macro CALLMONITOR
4a64					endif 
4a64 cd 79 1e				call forth_push_str 
4a67					if DEBUG_FORTH_WORDS 
4a67						DMARK "DI6" 
4a67 f5				push af  
4a68 3a 7c 4a			ld a, (.dmark)  
4a6b 32 6e fe			ld (debug_mark),a  
4a6e 3a 7d 4a			ld a, (.dmark+1)  
4a71 32 6f fe			ld (debug_mark+1),a  
4a74 3a 7e 4a			ld a, (.dmark+2)  
4a77 32 70 fe			ld (debug_mark+2),a  
4a7a 18 03			jr .pastdmark  
4a7c ..			.dmark: db "DI6"  
4a7f f1			.pastdmark: pop af  
4a80			endm  
# End of macro DMARK
4a80						CALLMONITOR 
4a80 cd 9d 17			call break_point_state  
4a83				endm  
# End of macro CALLMONITOR
4a83					endif 
4a83			.dirnotfound: 
4a83 c1					pop bc     
4a84 10 95				djnz .diritem 
4a86				 
4a86			.dirdone:	 
4a86					if DEBUG_FORTH_WORDS 
4a86						DMARK "DI7" 
4a86 f5				push af  
4a87 3a 9b 4a			ld a, (.dmark)  
4a8a 32 6e fe			ld (debug_mark),a  
4a8d 3a 9c 4a			ld a, (.dmark+1)  
4a90 32 6f fe			ld (debug_mark+1),a  
4a93 3a 9d 4a			ld a, (.dmark+2)  
4a96 32 70 fe			ld (debug_mark+2),a  
4a99 18 03			jr .pastdmark  
4a9b ..			.dmark: db "DI7"  
4a9e f1			.pastdmark: pop af  
4a9f			endm  
# End of macro DMARK
4a9f						CALLMONITOR 
4a9f cd 9d 17			call break_point_state  
4aa2				endm  
# End of macro CALLMONITOR
4aa2					endif 
4aa2			 
4aa2					; push a count of the dir items found 
4aa2			 
4aa2 26 00				ld h, 0 
4aa4 69					ld l, c 
4aa5 cd 0b 1e				call forth_push_numhl 
4aa8			 
4aa8					; push the bank label 
4aa8			 
4aa8 cd 85 04				call storage_get_block_0 
4aab			 
4aab				 
4aab 21 5c fb		 		ld hl, store_page+3 
4aae			 
4aae					if DEBUG_FORTH_WORDS 
4aae						DMARK "DI8" 
4aae f5				push af  
4aaf 3a c3 4a			ld a, (.dmark)  
4ab2 32 6e fe			ld (debug_mark),a  
4ab5 3a c4 4a			ld a, (.dmark+1)  
4ab8 32 6f fe			ld (debug_mark+1),a  
4abb 3a c5 4a			ld a, (.dmark+2)  
4abe 32 70 fe			ld (debug_mark+2),a  
4ac1 18 03			jr .pastdmark  
4ac3 ..			.dmark: db "DI8"  
4ac6 f1			.pastdmark: pop af  
4ac7			endm  
# End of macro DMARK
4ac7						CALLMONITOR 
4ac7 cd 9d 17			call break_point_state  
4aca				endm  
# End of macro CALLMONITOR
4aca					endif 
4aca cd 79 1e				call forth_push_str 
4acd			 
4acd			 
4acd				 
4acd					NEXTW 
4acd c3 74 21			jp macro_next 
4ad0				endm 
# End of macro NEXTW
4ad0			.SAVE: 
4ad0			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4ad0			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4ad0			;		NEXTW 
4ad0			;.LOAD: 
4ad0			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4ad0			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4ad0			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4ad0			;; > > The LOAD command can not be used in any user words or compound lines. 
4ad0			; 
4ad0			;		; store_openext use it. If zero it is EOF 
4ad0			; 
4ad0			;		; read block from current stream id 
4ad0			;		; if the block does not contain zero term keep reading blocks until zero found 
4ad0			;		; push the block to stack 
4ad0			;		; save the block id to stream 
4ad0			; 
4ad0			; 
4ad0			;		FORTH_DSP_VALUEHL 
4ad0			; 
4ad0			;;		push hl 
4ad0			; 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LOA" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			;		FORTH_DSP_POP 
4ad0			; 
4ad0			;;		pop hl 
4ad0			; 
4ad0			;		ld h, l 
4ad0			;		ld l, 0 
4ad0			; 
4ad0			;		push hl     ; stack holds current file id and extent to work with 
4ad0			; 
4ad0			; 
4ad0			;		ld de, store_page      ; get block zero of file 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LO0" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			;		call storage_read 
4ad0			; 
4ad0			;		ld a, (store_page+2)    ; max extents for this file 
4ad0			;		ld  (store_openmaxext),a   ; get our limit 
4ad0			; 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LOE" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			; 
4ad0			;; TODO dont know why max extents are not present 
4ad0			;;		cp 0 
4ad0			;;		jp z, .loadeof     ; dont read past eof 
4ad0			; 
4ad0			;;		ld a, 1   ; start from the head of the file 
4ad0			; 
4ad0			;.loadline:	pop hl 
4ad0			;		inc hl 
4ad0			;		ld  a, (store_openmaxext)   ; get our limit 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LOx" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			;		inc a 
4ad0			;		cp l 
4ad0			;		jp z, .loadeof 
4ad0			;		push hl    ; save current extent 
4ad0			; 
4ad0			;		ld de, store_page 
4ad0			; 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LO1" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			;		call storage_read 
4ad0			; 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LO2" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			;	call ishlzero 
4ad0			;	ld a, l 
4ad0			;	add h 
4ad0			;	cp 0 
4ad0			;	jr z, .loadeof 
4ad0			; 
4ad0			;	; not eof so hl should point to data to exec 
4ad0			; 
4ad0			;	; will need to add the FORTH_END_BUFFER flag 
4ad0			 ; 
4ad0			;	ld hl, store_page+2 
4ad0			;	ld bc, 255 
4ad0			;	ld a, 0 
4ad0			;	cpir 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LOt" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			;	dec hl 
4ad0			;	ld a, ' ' 
4ad0			;	ld (hl), a 
4ad0			;	inc hl 
4ad0			;	ld (hl), a 
4ad0			;	inc hl 
4ad0			;	ld (hl), a 
4ad0			;	inc hl 
4ad0			;	ld a, FORTH_END_BUFFER 
4ad0			;	ld (hl), a 
4ad0			; 
4ad0			;	; TODO handle more than a single block read 
4ad0			; 
4ad0			; 
4ad0			;	ld hl, store_page+2 
4ad0			; 
4ad0			;	ld (os_tok_ptr), hl 
4ad0			; 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LO3" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			; 
4ad0			;	call forthparse 
4ad0			;	call forthexec 
4ad0			;	call forthexec_cleanup 
4ad0			; 
4ad0			;	; go to next extent 
4ad0			; 
4ad0			;	; get next block  or mark as eof 
4ad0			;	jp .loadline 
4ad0			; 
4ad0			; 
4ad0			; 
4ad0			;	       NEXTW 
4ad0			;.loadeof:	ld a, 0 
4ad0			;		ld (store_openext), a 
4ad0			; 
4ad0			;	if DEBUG_STORESE 
4ad0			;		DMARK "LOF" 
4ad0			;		CALLMONITOR 
4ad0			;	endif 
4ad0			;		ret 
4ad0			;		;NEXTW 
4ad0			;.BSAVE:   
4ad0			; 
4ad0			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4ad0			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4ad0			;		NEXTW 
4ad0			;.BLOAD: 
4ad0			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4ad0			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4ad0			;		NEXTW 
4ad0			;;;; counter gap 
4ad0			 
4ad0			 
4ad0			.SEO: 
4ad0				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4ad0 64				db WORD_SYS_CORE+80             
4ad1 ef 4a			dw .SEI            
4ad3 04				db 3 + 1 
4ad4 .. 00			db "SEO",0              
4ad8				endm 
# End of macro CWHEAD
4ad8			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4ad8			 
4ad8					; get port 
4ad8			 
4ad8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ad8 cd 02 20			call macro_dsp_valuehl 
4adb				endm 
# End of macro FORTH_DSP_VALUEHL
4adb			 
4adb e5					push hl    ; u2 - byte 
4adc			 
4adc					; destroy value TOS 
4adc			 
4adc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4adc cd ba 20			call macro_forth_dsp_pop 
4adf				endm 
# End of macro FORTH_DSP_POP
4adf			 
4adf					; get byte to send 
4adf			 
4adf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4adf cd 02 20			call macro_dsp_valuehl 
4ae2				endm 
# End of macro FORTH_DSP_VALUEHL
4ae2			 
4ae2 e5					push hl    ; u1 - addr 
4ae3			 
4ae3					; destroy value TOS 
4ae3			 
4ae3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae3 cd ba 20			call macro_forth_dsp_pop 
4ae6				endm 
# End of macro FORTH_DSP_POP
4ae6			 
4ae6					; one value on hl get other one back 
4ae6			 
4ae6 d1					pop de   ; u1 - byte 
4ae7			 
4ae7 e1					pop hl   ; u2 - addr 
4ae8			 
4ae8					; TODO Send SPI byte 
4ae8			 
4ae8			 
4ae8 7b					ld a, e 
4ae9 cd d9 01				call se_writebyte 
4aec			 
4aec					 
4aec			 
4aec					NEXTW 
4aec c3 74 21			jp macro_next 
4aef				endm 
# End of macro NEXTW
4aef			 
4aef			.SEI: 
4aef				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4aef 65				db WORD_SYS_CORE+81             
4af0 09 4b			dw .SFREE            
4af2 04				db 3 + 1 
4af3 .. 00			db "SEI",0              
4af7				endm 
# End of macro CWHEAD
4af7			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4af7			 
4af7					; get port 
4af7			 
4af7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4af7 cd 02 20			call macro_dsp_valuehl 
4afa				endm 
# End of macro FORTH_DSP_VALUEHL
4afa			 
4afa			;		push hl 
4afa			 
4afa					; destroy value TOS 
4afa			 
4afa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4afa cd ba 20			call macro_forth_dsp_pop 
4afd				endm 
# End of macro FORTH_DSP_POP
4afd			 
4afd					; one value on hl get other one back 
4afd			 
4afd			;		pop hl 
4afd			 
4afd			 
4afd					; TODO Get SPI byte 
4afd			 
4afd cd 7b 02				call se_readbyte 
4b00			 
4b00 26 00				ld h, 0 
4b02 6f					ld l, a 
4b03 cd 0b 1e				call forth_push_numhl 
4b06			 
4b06					NEXTW 
4b06 c3 74 21			jp macro_next 
4b09				endm 
# End of macro NEXTW
4b09			 
4b09			.SFREE: 
4b09				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4b09 67				db WORD_SYS_CORE+83             
4b0a 38 4b			dw .SIZE            
4b0c 06				db 5 + 1 
4b0d .. 00			db "FFREE",0              
4b13				endm 
# End of macro CWHEAD
4b13			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4b13					if DEBUG_FORTH_WORDS_KEY 
4b13						DMARK "FFR" 
4b13 f5				push af  
4b14 3a 28 4b			ld a, (.dmark)  
4b17 32 6e fe			ld (debug_mark),a  
4b1a 3a 29 4b			ld a, (.dmark+1)  
4b1d 32 6f fe			ld (debug_mark+1),a  
4b20 3a 2a 4b			ld a, (.dmark+2)  
4b23 32 70 fe			ld (debug_mark+2),a  
4b26 18 03			jr .pastdmark  
4b28 ..			.dmark: db "FFR"  
4b2b f1			.pastdmark: pop af  
4b2c			endm  
# End of macro DMARK
4b2c						CALLMONITOR 
4b2c cd 9d 17			call break_point_state  
4b2f				endm  
# End of macro CALLMONITOR
4b2f					endif 
4b2f			 
4b2f cd a1 07				call storage_freeblocks 
4b32			 
4b32 cd 0b 1e				call forth_push_numhl 
4b35			 
4b35				       NEXTW 
4b35 c3 74 21			jp macro_next 
4b38				endm 
# End of macro NEXTW
4b38			.SIZE: 
4b38				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4b38 67				db WORD_SYS_CORE+83             
4b39 6c 4b			dw .CREATE            
4b3b 05				db 4 + 1 
4b3c .. 00			db "SIZE",0              
4b41				endm 
# End of macro CWHEAD
4b41			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4b41					if DEBUG_FORTH_WORDS_KEY 
4b41						DMARK "SIZ" 
4b41 f5				push af  
4b42 3a 56 4b			ld a, (.dmark)  
4b45 32 6e fe			ld (debug_mark),a  
4b48 3a 57 4b			ld a, (.dmark+1)  
4b4b 32 6f fe			ld (debug_mark+1),a  
4b4e 3a 58 4b			ld a, (.dmark+2)  
4b51 32 70 fe			ld (debug_mark+2),a  
4b54 18 03			jr .pastdmark  
4b56 ..			.dmark: db "SIZ"  
4b59 f1			.pastdmark: pop af  
4b5a			endm  
# End of macro DMARK
4b5a						CALLMONITOR 
4b5a cd 9d 17			call break_point_state  
4b5d				endm  
# End of macro CALLMONITOR
4b5d					endif 
4b5d			 
4b5d					FORTH_DSP_VALUEHL 
4b5d cd 02 20			call macro_dsp_valuehl 
4b60				endm 
# End of macro FORTH_DSP_VALUEHL
4b60			;		push hl 
4b60					FORTH_DSP_POP 
4b60 cd ba 20			call macro_forth_dsp_pop 
4b63				endm 
# End of macro FORTH_DSP_POP
4b63			;		pop hl 
4b63 cd 03 04				call storage_file_size 
4b66			 
4b66 cd 0b 1e				call forth_push_numhl 
4b69			  
4b69			 
4b69				       NEXTW 
4b69 c3 74 21			jp macro_next 
4b6c				endm 
# End of macro NEXTW
4b6c			 
4b6c			.CREATE: 
4b6c				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4b6c 68				db WORD_SYS_CORE+84             
4b6d da 4b			dw .APPEND            
4b6f 07				db 6 + 1 
4b70 .. 00			db "CREATE",0              
4b77				endm 
# End of macro CWHEAD
4b77			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4b77			; | | e.g.  
4b77			; | | TestProgram CREATE 
4b77			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4b77			; | |  
4b77			; | | Max file IDs are 255. 
4b77			; | |  
4b77					 
4b77					if DEBUG_FORTH_WORDS_KEY 
4b77						DMARK "CRT" 
4b77 f5				push af  
4b78 3a 8c 4b			ld a, (.dmark)  
4b7b 32 6e fe			ld (debug_mark),a  
4b7e 3a 8d 4b			ld a, (.dmark+1)  
4b81 32 6f fe			ld (debug_mark+1),a  
4b84 3a 8e 4b			ld a, (.dmark+2)  
4b87 32 70 fe			ld (debug_mark+2),a  
4b8a 18 03			jr .pastdmark  
4b8c ..			.dmark: db "CRT"  
4b8f f1			.pastdmark: pop af  
4b90			endm  
# End of macro DMARK
4b90						CALLMONITOR 
4b90 cd 9d 17			call break_point_state  
4b93				endm  
# End of macro CALLMONITOR
4b93					endif 
4b93			;		call storage_get_block_0 
4b93			 
4b93					; TODO pop hl 
4b93			 
4b93					;v5 FORTH_DSP_VALUE 
4b93					FORTH_DSP_VALUE 
4b93 cd eb 1f			call macro_forth_dsp_value 
4b96				endm 
# End of macro FORTH_DSP_VALUE
4b96			 
4b96				if DEBUG_STORESE 
4b96					DMARK "CR1" 
4b96 f5				push af  
4b97 3a ab 4b			ld a, (.dmark)  
4b9a 32 6e fe			ld (debug_mark),a  
4b9d 3a ac 4b			ld a, (.dmark+1)  
4ba0 32 6f fe			ld (debug_mark+1),a  
4ba3 3a ad 4b			ld a, (.dmark+2)  
4ba6 32 70 fe			ld (debug_mark+2),a  
4ba9 18 03			jr .pastdmark  
4bab ..			.dmark: db "CR1"  
4bae f1			.pastdmark: pop af  
4baf			endm  
# End of macro DMARK
4baf					CALLMONITOR 
4baf cd 9d 17			call break_point_state  
4bb2				endm  
# End of macro CALLMONITOR
4bb2				endif 
4bb2			;		push hl 
4bb2			;		FORTH_DSP_POP 
4bb2			;		pop hl 
4bb2			 
4bb2			;		inc hl   ; move past the type marker 
4bb2			 
4bb2 cd d7 07				call storage_create 
4bb5			 
4bb5				if DEBUG_STORESE 
4bb5					DMARK "CT1" 
4bb5 f5				push af  
4bb6 3a ca 4b			ld a, (.dmark)  
4bb9 32 6e fe			ld (debug_mark),a  
4bbc 3a cb 4b			ld a, (.dmark+1)  
4bbf 32 6f fe			ld (debug_mark+1),a  
4bc2 3a cc 4b			ld a, (.dmark+2)  
4bc5 32 70 fe			ld (debug_mark+2),a  
4bc8 18 03			jr .pastdmark  
4bca ..			.dmark: db "CT1"  
4bcd f1			.pastdmark: pop af  
4bce			endm  
# End of macro DMARK
4bce					CALLMONITOR 
4bce cd 9d 17			call break_point_state  
4bd1				endm  
# End of macro CALLMONITOR
4bd1				endif 
4bd1			;		push hl 
4bd1					FORTH_DSP_POP 
4bd1 cd ba 20			call macro_forth_dsp_pop 
4bd4				endm 
# End of macro FORTH_DSP_POP
4bd4			;		pop hl 
4bd4					; push file id to stack 
4bd4 cd 0b 1e				call forth_push_numhl 
4bd7			 
4bd7			 
4bd7			 
4bd7				       NEXTW 
4bd7 c3 74 21			jp macro_next 
4bda				endm 
# End of macro NEXTW
4bda			 
4bda			.APPEND: 
4bda				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4bda 69				db WORD_SYS_CORE+85             
4bdb 6b 4c			dw .SDEL            
4bdd 07				db 6 + 1 
4bde .. 00			db "APPEND",0              
4be5				endm 
# End of macro CWHEAD
4be5			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4be5			; | | e.g. 
4be5			; | | Test CREATE      -> $01 
4be5			; | | "A string to add to file" $01 APPEND 
4be5			; | |  
4be5			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4be5					if DEBUG_FORTH_WORDS_KEY 
4be5						DMARK "APP" 
4be5 f5				push af  
4be6 3a fa 4b			ld a, (.dmark)  
4be9 32 6e fe			ld (debug_mark),a  
4bec 3a fb 4b			ld a, (.dmark+1)  
4bef 32 6f fe			ld (debug_mark+1),a  
4bf2 3a fc 4b			ld a, (.dmark+2)  
4bf5 32 70 fe			ld (debug_mark+2),a  
4bf8 18 03			jr .pastdmark  
4bfa ..			.dmark: db "APP"  
4bfd f1			.pastdmark: pop af  
4bfe			endm  
# End of macro DMARK
4bfe						CALLMONITOR 
4bfe cd 9d 17			call break_point_state  
4c01				endm  
# End of macro CALLMONITOR
4c01					endif 
4c01			 
4c01					FORTH_DSP_VALUEHL 
4c01 cd 02 20			call macro_dsp_valuehl 
4c04				endm 
# End of macro FORTH_DSP_VALUEHL
4c04 e5					push hl 	; save file id 
4c05			 
4c05				if DEBUG_STORESE 
4c05					DMARK "AP1" 
4c05 f5				push af  
4c06 3a 1a 4c			ld a, (.dmark)  
4c09 32 6e fe			ld (debug_mark),a  
4c0c 3a 1b 4c			ld a, (.dmark+1)  
4c0f 32 6f fe			ld (debug_mark+1),a  
4c12 3a 1c 4c			ld a, (.dmark+2)  
4c15 32 70 fe			ld (debug_mark+2),a  
4c18 18 03			jr .pastdmark  
4c1a ..			.dmark: db "AP1"  
4c1d f1			.pastdmark: pop af  
4c1e			endm  
# End of macro DMARK
4c1e					CALLMONITOR 
4c1e cd 9d 17			call break_point_state  
4c21				endm  
# End of macro CALLMONITOR
4c21				endif 
4c21					FORTH_DSP_POP 
4c21 cd ba 20			call macro_forth_dsp_pop 
4c24				endm 
# End of macro FORTH_DSP_POP
4c24			 
4c24					FORTH_DSP_VALUEHL 
4c24 cd 02 20			call macro_dsp_valuehl 
4c27				endm 
# End of macro FORTH_DSP_VALUEHL
4c27					;v5 FORTH_DSP_VALUE 
4c27 e5					push hl 	; save ptr to string to save 
4c28			 
4c28				if DEBUG_STORESE 
4c28					DMARK "AP1" 
4c28 f5				push af  
4c29 3a 3d 4c			ld a, (.dmark)  
4c2c 32 6e fe			ld (debug_mark),a  
4c2f 3a 3e 4c			ld a, (.dmark+1)  
4c32 32 6f fe			ld (debug_mark+1),a  
4c35 3a 3f 4c			ld a, (.dmark+2)  
4c38 32 70 fe			ld (debug_mark+2),a  
4c3b 18 03			jr .pastdmark  
4c3d ..			.dmark: db "AP1"  
4c40 f1			.pastdmark: pop af  
4c41			endm  
# End of macro DMARK
4c41					CALLMONITOR 
4c41 cd 9d 17			call break_point_state  
4c44				endm  
# End of macro CALLMONITOR
4c44				endif 
4c44					FORTH_DSP_POP 
4c44 cd ba 20			call macro_forth_dsp_pop 
4c47				endm 
# End of macro FORTH_DSP_POP
4c47			 
4c47 d1					pop de 
4c48 e1					pop hl 
4c49				if DEBUG_STORESE 
4c49					DMARK "AP2" 
4c49 f5				push af  
4c4a 3a 5e 4c			ld a, (.dmark)  
4c4d 32 6e fe			ld (debug_mark),a  
4c50 3a 5f 4c			ld a, (.dmark+1)  
4c53 32 6f fe			ld (debug_mark+1),a  
4c56 3a 60 4c			ld a, (.dmark+2)  
4c59 32 70 fe			ld (debug_mark+2),a  
4c5c 18 03			jr .pastdmark  
4c5e ..			.dmark: db "AP2"  
4c61 f1			.pastdmark: pop af  
4c62			endm  
# End of macro DMARK
4c62					CALLMONITOR 
4c62 cd 9d 17			call break_point_state  
4c65				endm  
# End of macro CALLMONITOR
4c65				endif 
4c65					;inc de ; skip var type indicator 
4c65			 
4c65					; TODO how to append numerics???? 
4c65			 
4c65 cd b6 09				call storage_append		 
4c68			 
4c68				       NEXTW 
4c68 c3 74 21			jp macro_next 
4c6b				endm 
# End of macro NEXTW
4c6b			.SDEL: 
4c6b				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4c6b 6a				db WORD_SYS_CORE+86             
4c6c b7 4c			dw .OPEN            
4c6e 05				db 4 + 1 
4c6f .. 00			db "ERA",0              
4c73				endm 
# End of macro CWHEAD
4c73			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4c73					FORTH_DSP_VALUEHL 
4c73 cd 02 20			call macro_dsp_valuehl 
4c76				endm 
# End of macro FORTH_DSP_VALUEHL
4c76			;		push hl 	; save file id 
4c76			 
4c76					if DEBUG_FORTH_WORDS_KEY 
4c76						DMARK "ERA" 
4c76 f5				push af  
4c77 3a 8b 4c			ld a, (.dmark)  
4c7a 32 6e fe			ld (debug_mark),a  
4c7d 3a 8c 4c			ld a, (.dmark+1)  
4c80 32 6f fe			ld (debug_mark+1),a  
4c83 3a 8d 4c			ld a, (.dmark+2)  
4c86 32 70 fe			ld (debug_mark+2),a  
4c89 18 03			jr .pastdmark  
4c8b ..			.dmark: db "ERA"  
4c8e f1			.pastdmark: pop af  
4c8f			endm  
# End of macro DMARK
4c8f						CALLMONITOR 
4c8f cd 9d 17			call break_point_state  
4c92				endm  
# End of macro CALLMONITOR
4c92					endif 
4c92				if DEBUG_STORESE 
4c92					DMARK "ER1" 
4c92 f5				push af  
4c93 3a a7 4c			ld a, (.dmark)  
4c96 32 6e fe			ld (debug_mark),a  
4c99 3a a8 4c			ld a, (.dmark+1)  
4c9c 32 6f fe			ld (debug_mark+1),a  
4c9f 3a a9 4c			ld a, (.dmark+2)  
4ca2 32 70 fe			ld (debug_mark+2),a  
4ca5 18 03			jr .pastdmark  
4ca7 ..			.dmark: db "ER1"  
4caa f1			.pastdmark: pop af  
4cab			endm  
# End of macro DMARK
4cab					CALLMONITOR 
4cab cd 9d 17			call break_point_state  
4cae				endm  
# End of macro CALLMONITOR
4cae				endif 
4cae					FORTH_DSP_POP 
4cae cd ba 20			call macro_forth_dsp_pop 
4cb1				endm 
# End of macro FORTH_DSP_POP
4cb1			 
4cb1			;		pop hl 
4cb1			 
4cb1 cd 16 06				call storage_erase 
4cb4				       NEXTW 
4cb4 c3 74 21			jp macro_next 
4cb7				endm 
# End of macro NEXTW
4cb7			 
4cb7			.OPEN: 
4cb7				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4cb7 6b				db WORD_SYS_CORE+87             
4cb8 47 4d			dw .READ            
4cba 05				db 4 + 1 
4cbb .. 00			db "OPEN",0              
4cc0				endm 
# End of macro CWHEAD
4cc0			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4cc0			; | | e.g. 
4cc0			; | | $01 OPEN $01 DO $01 READ . LOOP 
4cc0			; | | 
4cc0			; | | Will return with 255 blocks if the file does not exist 
4cc0			 
4cc0					if DEBUG_FORTH_WORDS_KEY 
4cc0						DMARK "OPN" 
4cc0 f5				push af  
4cc1 3a d5 4c			ld a, (.dmark)  
4cc4 32 6e fe			ld (debug_mark),a  
4cc7 3a d6 4c			ld a, (.dmark+1)  
4cca 32 6f fe			ld (debug_mark+1),a  
4ccd 3a d7 4c			ld a, (.dmark+2)  
4cd0 32 70 fe			ld (debug_mark+2),a  
4cd3 18 03			jr .pastdmark  
4cd5 ..			.dmark: db "OPN"  
4cd8 f1			.pastdmark: pop af  
4cd9			endm  
# End of macro DMARK
4cd9						CALLMONITOR 
4cd9 cd 9d 17			call break_point_state  
4cdc				endm  
# End of macro CALLMONITOR
4cdc					endif 
4cdc					; TODO handle multiple file opens 
4cdc			 
4cdc 3e 01			       	ld a, 1 
4cde 32 50 fb				ld (store_openext), a 
4ce1			 
4ce1					; get max extents for this file 
4ce1				 
4ce1								 
4ce1					FORTH_DSP_VALUEHL 
4ce1 cd 02 20			call macro_dsp_valuehl 
4ce4				endm 
# End of macro FORTH_DSP_VALUEHL
4ce4			 
4ce4 65					ld h, l 
4ce5 2e 00				ld l, 0 
4ce7			 
4ce7				if DEBUG_STORESE 
4ce7					DMARK "OPN" 
4ce7 f5				push af  
4ce8 3a fc 4c			ld a, (.dmark)  
4ceb 32 6e fe			ld (debug_mark),a  
4cee 3a fd 4c			ld a, (.dmark+1)  
4cf1 32 6f fe			ld (debug_mark+1),a  
4cf4 3a fe 4c			ld a, (.dmark+2)  
4cf7 32 70 fe			ld (debug_mark+2),a  
4cfa 18 03			jr .pastdmark  
4cfc ..			.dmark: db "OPN"  
4cff f1			.pastdmark: pop af  
4d00			endm  
# End of macro DMARK
4d00					CALLMONITOR 
4d00 cd 9d 17			call break_point_state  
4d03				endm  
# End of macro CALLMONITOR
4d03				endif 
4d03			;		push hl 
4d03					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4d03 cd ba 20			call macro_forth_dsp_pop 
4d06				endm 
# End of macro FORTH_DSP_POP
4d06			;		pop hl 
4d06						 
4d06 11 59 fb				ld de, store_page      ; get block zero of file 
4d09 cd 2d 09				call storage_read 
4d0c cd 1f 0e			call ishlzero 
4d0f 20 04			jr nz, .opfound 
4d11			 
4d11				; file does not exist so indicate with 255 extents in use 
4d11			 
4d11 3e ff			ld a, 255 
4d13 18 29			jr .skipopeneof 
4d15			 
4d15			 
4d15			.opfound: 
4d15			 
4d15			 
4d15 3a 5b fb				ld a, (store_page+2)    ; max extents for this file 
4d18 32 4f fb				ld  (store_openmaxext), a   ; get our limit and push 
4d1b					 
4d1b				if DEBUG_STORESE 
4d1b					DMARK "OPx" 
4d1b f5				push af  
4d1c 3a 30 4d			ld a, (.dmark)  
4d1f 32 6e fe			ld (debug_mark),a  
4d22 3a 31 4d			ld a, (.dmark+1)  
4d25 32 6f fe			ld (debug_mark+1),a  
4d28 3a 32 4d			ld a, (.dmark+2)  
4d2b 32 70 fe			ld (debug_mark+2),a  
4d2e 18 03			jr .pastdmark  
4d30 ..			.dmark: db "OPx"  
4d33 f1			.pastdmark: pop af  
4d34			endm  
# End of macro DMARK
4d34					CALLMONITOR 
4d34 cd 9d 17			call break_point_state  
4d37				endm  
# End of macro CALLMONITOR
4d37				endif 
4d37 fe 00				cp 0 
4d39 20 03				jr nz, .skipopeneof 
4d3b					; have opened an empty file 
4d3b					 
4d3b 32 50 fb				ld (store_openext), a 
4d3e			 
4d3e			.skipopeneof: 
4d3e			 
4d3e 6f					ld l, a 
4d3f 26 00				ld h, 0 
4d41 cd 0b 1e				call forth_push_numhl 
4d44			 
4d44			 
4d44				       NEXTW 
4d44 c3 74 21			jp macro_next 
4d47				endm 
# End of macro NEXTW
4d47			.READ: 
4d47				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4d47 6c				db WORD_SYS_CORE+88             
4d48 8e 4e			dw .EOF            
4d4a 05				db 4 + 1 
4d4b .. 00			db "READ",0              
4d50				endm 
# End of macro CWHEAD
4d50			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4d50			; | | e.g. 
4d50			; | | $01 OPEN $01 DO $01 READ . LOOP 
4d50			 
4d50					if DEBUG_FORTH_WORDS_KEY 
4d50						DMARK "REA" 
4d50 f5				push af  
4d51 3a 65 4d			ld a, (.dmark)  
4d54 32 6e fe			ld (debug_mark),a  
4d57 3a 66 4d			ld a, (.dmark+1)  
4d5a 32 6f fe			ld (debug_mark+1),a  
4d5d 3a 67 4d			ld a, (.dmark+2)  
4d60 32 70 fe			ld (debug_mark+2),a  
4d63 18 03			jr .pastdmark  
4d65 ..			.dmark: db "REA"  
4d68 f1			.pastdmark: pop af  
4d69			endm  
# End of macro DMARK
4d69						CALLMONITOR 
4d69 cd 9d 17			call break_point_state  
4d6c				endm  
# End of macro CALLMONITOR
4d6c					endif 
4d6c					; store_openext use it. If zero it is EOF 
4d6c			 
4d6c					; read block from current stream id 
4d6c					; if the block does not contain zero term keep reading blocks until zero found 
4d6c					; push the block to stack 
4d6c					; save the block id to stream 
4d6c			 
4d6c			 
4d6c					FORTH_DSP_VALUEHL 
4d6c cd 02 20			call macro_dsp_valuehl 
4d6f				endm 
# End of macro FORTH_DSP_VALUEHL
4d6f			 
4d6f			;		push hl 
4d6f			 
4d6f				if DEBUG_STORESE 
4d6f					DMARK "REA" 
4d6f f5				push af  
4d70 3a 84 4d			ld a, (.dmark)  
4d73 32 6e fe			ld (debug_mark),a  
4d76 3a 85 4d			ld a, (.dmark+1)  
4d79 32 6f fe			ld (debug_mark+1),a  
4d7c 3a 86 4d			ld a, (.dmark+2)  
4d7f 32 70 fe			ld (debug_mark+2),a  
4d82 18 03			jr .pastdmark  
4d84 ..			.dmark: db "REA"  
4d87 f1			.pastdmark: pop af  
4d88			endm  
# End of macro DMARK
4d88					CALLMONITOR 
4d88 cd 9d 17			call break_point_state  
4d8b				endm  
# End of macro CALLMONITOR
4d8b				endif 
4d8b					FORTH_DSP_POP 
4d8b cd ba 20			call macro_forth_dsp_pop 
4d8e				endm 
# End of macro FORTH_DSP_POP
4d8e			 
4d8e			;		pop hl 
4d8e				 
4d8e 65					ld h,l 
4d8f			 
4d8f 3a 50 fb				ld a, (store_openext) 
4d92 6f					ld l, a 
4d93					 
4d93 fe 00				cp 0 
4d95 ca 60 4e				jp z, .ateof     ; dont read past eof 
4d98			 
4d98			 
4d98 11 59 fb				ld de, store_page 
4d9b				if DEBUG_STORESE 
4d9b					DMARK "RE1" 
4d9b f5				push af  
4d9c 3a b0 4d			ld a, (.dmark)  
4d9f 32 6e fe			ld (debug_mark),a  
4da2 3a b1 4d			ld a, (.dmark+1)  
4da5 32 6f fe			ld (debug_mark+1),a  
4da8 3a b2 4d			ld a, (.dmark+2)  
4dab 32 70 fe			ld (debug_mark+2),a  
4dae 18 03			jr .pastdmark  
4db0 ..			.dmark: db "RE1"  
4db3 f1			.pastdmark: pop af  
4db4			endm  
# End of macro DMARK
4db4					CALLMONITOR 
4db4 cd 9d 17			call break_point_state  
4db7				endm  
# End of macro CALLMONITOR
4db7				endif 
4db7 cd 2d 09				call storage_read 
4dba			 
4dba				if DEBUG_STORESE 
4dba					DMARK "RE2" 
4dba f5				push af  
4dbb 3a cf 4d			ld a, (.dmark)  
4dbe 32 6e fe			ld (debug_mark),a  
4dc1 3a d0 4d			ld a, (.dmark+1)  
4dc4 32 6f fe			ld (debug_mark+1),a  
4dc7 3a d1 4d			ld a, (.dmark+2)  
4dca 32 70 fe			ld (debug_mark+2),a  
4dcd 18 03			jr .pastdmark  
4dcf ..			.dmark: db "RE2"  
4dd2 f1			.pastdmark: pop af  
4dd3			endm  
# End of macro DMARK
4dd3					CALLMONITOR 
4dd3 cd 9d 17			call break_point_state  
4dd6				endm  
# End of macro CALLMONITOR
4dd6				endif 
4dd6 cd 1f 0e			call ishlzero 
4dd9			;	ld a, l 
4dd9			;	add h 
4dd9			;	cp 0 
4dd9 ca 66 4e			jp z, .readeof 
4ddc			 
4ddc				; not eof so hl should point to data to push to stack 
4ddc			 
4ddc				if DEBUG_STORESE 
4ddc					DMARK "RE3" 
4ddc f5				push af  
4ddd 3a f1 4d			ld a, (.dmark)  
4de0 32 6e fe			ld (debug_mark),a  
4de3 3a f2 4d			ld a, (.dmark+1)  
4de6 32 6f fe			ld (debug_mark+1),a  
4de9 3a f3 4d			ld a, (.dmark+2)  
4dec 32 70 fe			ld (debug_mark+2),a  
4def 18 03			jr .pastdmark  
4df1 ..			.dmark: db "RE3"  
4df4 f1			.pastdmark: pop af  
4df5			endm  
# End of macro DMARK
4df5					CALLMONITOR 
4df5 cd 9d 17			call break_point_state  
4df8				endm  
# End of macro CALLMONITOR
4df8				endif 
4df8 cd 79 1e			call forth_push_str 
4dfb			 
4dfb				if DEBUG_STORESE 
4dfb					DMARK "RE4" 
4dfb f5				push af  
4dfc 3a 10 4e			ld a, (.dmark)  
4dff 32 6e fe			ld (debug_mark),a  
4e02 3a 11 4e			ld a, (.dmark+1)  
4e05 32 6f fe			ld (debug_mark+1),a  
4e08 3a 12 4e			ld a, (.dmark+2)  
4e0b 32 70 fe			ld (debug_mark+2),a  
4e0e 18 03			jr .pastdmark  
4e10 ..			.dmark: db "RE4"  
4e13 f1			.pastdmark: pop af  
4e14			endm  
# End of macro DMARK
4e14					CALLMONITOR 
4e14 cd 9d 17			call break_point_state  
4e17				endm  
# End of macro CALLMONITOR
4e17				endif 
4e17				; get next block  or mark as eof 
4e17			 
4e17 3a 4f fb			ld a, (store_openmaxext)   ; get our limit 
4e1a 4f				ld c, a	 
4e1b 3a 50 fb			ld a, (store_openext) 
4e1e			 
4e1e				if DEBUG_STORESE 
4e1e					DMARK "RE5" 
4e1e f5				push af  
4e1f 3a 33 4e			ld a, (.dmark)  
4e22 32 6e fe			ld (debug_mark),a  
4e25 3a 34 4e			ld a, (.dmark+1)  
4e28 32 6f fe			ld (debug_mark+1),a  
4e2b 3a 35 4e			ld a, (.dmark+2)  
4e2e 32 70 fe			ld (debug_mark+2),a  
4e31 18 03			jr .pastdmark  
4e33 ..			.dmark: db "RE5"  
4e36 f1			.pastdmark: pop af  
4e37			endm  
# End of macro DMARK
4e37					CALLMONITOR 
4e37 cd 9d 17			call break_point_state  
4e3a				endm  
# End of macro CALLMONITOR
4e3a				endif 
4e3a b9				cp c 
4e3b 28 29			jr z, .readeof     ; at last extent 
4e3d			 
4e3d 3c					inc a 
4e3e 32 50 fb				ld (store_openext), a 
4e41			 
4e41				if DEBUG_STORESE 
4e41					DMARK "RE6" 
4e41 f5				push af  
4e42 3a 56 4e			ld a, (.dmark)  
4e45 32 6e fe			ld (debug_mark),a  
4e48 3a 57 4e			ld a, (.dmark+1)  
4e4b 32 6f fe			ld (debug_mark+1),a  
4e4e 3a 58 4e			ld a, (.dmark+2)  
4e51 32 70 fe			ld (debug_mark+2),a  
4e54 18 03			jr .pastdmark  
4e56 ..			.dmark: db "RE6"  
4e59 f1			.pastdmark: pop af  
4e5a			endm  
# End of macro DMARK
4e5a					CALLMONITOR 
4e5a cd 9d 17			call break_point_state  
4e5d				endm  
# End of macro CALLMONITOR
4e5d				endif 
4e5d			 
4e5d			 
4e5d				       NEXTW 
4e5d c3 74 21			jp macro_next 
4e60				endm 
# End of macro NEXTW
4e60			.ateof: 
4e60 21 8a 4e				ld hl, .showeof 
4e63 cd 79 1e				call forth_push_str 
4e66 3e 00		.readeof:	ld a, 0 
4e68 32 50 fb				ld (store_openext), a 
4e6b			 
4e6b					 
4e6b				if DEBUG_STORESE 
4e6b					DMARK "REF" 
4e6b f5				push af  
4e6c 3a 80 4e			ld a, (.dmark)  
4e6f 32 6e fe			ld (debug_mark),a  
4e72 3a 81 4e			ld a, (.dmark+1)  
4e75 32 6f fe			ld (debug_mark+1),a  
4e78 3a 82 4e			ld a, (.dmark+2)  
4e7b 32 70 fe			ld (debug_mark+2),a  
4e7e 18 03			jr .pastdmark  
4e80 ..			.dmark: db "REF"  
4e83 f1			.pastdmark: pop af  
4e84			endm  
# End of macro DMARK
4e84					CALLMONITOR 
4e84 cd 9d 17			call break_point_state  
4e87				endm  
# End of macro CALLMONITOR
4e87				endif 
4e87				       NEXTW 
4e87 c3 74 21			jp macro_next 
4e8a				endm 
# End of macro NEXTW
4e8a			 
4e8a .. 00		.showeof:   db "eof", 0 
4e8e			 
4e8e			 
4e8e			.EOF: 
4e8e				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4e8e 6d				db WORD_SYS_CORE+89             
4e8f cf 4e			dw .FORMAT            
4e91 04				db 3 + 1 
4e92 .. 00			db "EOF",0              
4e96				endm 
# End of macro CWHEAD
4e96			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4e96			; | | e.g. 
4e96			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4e96					; TODO if current block id for stream is zero then push true else false 
4e96			 
4e96					if DEBUG_FORTH_WORDS_KEY 
4e96						DMARK "EOF" 
4e96 f5				push af  
4e97 3a ab 4e			ld a, (.dmark)  
4e9a 32 6e fe			ld (debug_mark),a  
4e9d 3a ac 4e			ld a, (.dmark+1)  
4ea0 32 6f fe			ld (debug_mark+1),a  
4ea3 3a ad 4e			ld a, (.dmark+2)  
4ea6 32 70 fe			ld (debug_mark+2),a  
4ea9 18 03			jr .pastdmark  
4eab ..			.dmark: db "EOF"  
4eae f1			.pastdmark: pop af  
4eaf			endm  
# End of macro DMARK
4eaf						CALLMONITOR 
4eaf cd 9d 17			call break_point_state  
4eb2				endm  
# End of macro CALLMONITOR
4eb2					endif 
4eb2			 
4eb2					; TODO handlue multiple file streams 
4eb2			 
4eb2					FORTH_DSP_POP     ; for now just get rid of stream id 
4eb2 cd ba 20			call macro_forth_dsp_pop 
4eb5				endm 
# End of macro FORTH_DSP_POP
4eb5			 
4eb5 2e 01				ld l, 1 
4eb7 3a 4f fb				ld a, (store_openmaxext) 
4eba fe 00				cp 0 
4ebc 28 09				jr  z, .eofdone   ; empty file 
4ebe 3a 50 fb				ld a, (store_openext) 
4ec1 fe 00				cp 0 
4ec3 28 02				jr  z, .eofdone 
4ec5 2e 00				ld l, 0 
4ec7 26 00		.eofdone:	ld h, 0 
4ec9 cd 0b 1e				call forth_push_numhl 
4ecc			 
4ecc			 
4ecc				       NEXTW 
4ecc c3 74 21			jp macro_next 
4ecf				endm 
# End of macro NEXTW
4ecf			 
4ecf			.FORMAT: 
4ecf				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4ecf 6d				db WORD_SYS_CORE+89             
4ed0 20 4f			dw .LABEL            
4ed2 07				db 6 + 1 
4ed3 .. 00			db "FORMAT",0              
4eda				endm 
# End of macro CWHEAD
4eda			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4eda					; TODO if current block id for stream is zero then push true else false 
4eda				 
4eda				if DEBUG_STORESE 
4eda					DMARK "FOR" 
4eda f5				push af  
4edb 3a ef 4e			ld a, (.dmark)  
4ede 32 6e fe			ld (debug_mark),a  
4ee1 3a f0 4e			ld a, (.dmark+1)  
4ee4 32 6f fe			ld (debug_mark+1),a  
4ee7 3a f1 4e			ld a, (.dmark+2)  
4eea 32 70 fe			ld (debug_mark+2),a  
4eed 18 03			jr .pastdmark  
4eef ..			.dmark: db "FOR"  
4ef2 f1			.pastdmark: pop af  
4ef3			endm  
# End of macro DMARK
4ef3					CALLMONITOR 
4ef3 cd 9d 17			call break_point_state  
4ef6				endm  
# End of macro CALLMONITOR
4ef6				endif 
4ef6					; Wipes the bank check flags to cause a reformat on next block 0 read 
4ef6			 
4ef6 21 01 00				ld hl, 1 
4ef9 3e 00				ld a, 0 
4efb cd d9 01				call se_writebyte 
4efe			 
4efe				if DEBUG_STORESE 
4efe					DMARK "FO0" 
4efe f5				push af  
4eff 3a 13 4f			ld a, (.dmark)  
4f02 32 6e fe			ld (debug_mark),a  
4f05 3a 14 4f			ld a, (.dmark+1)  
4f08 32 6f fe			ld (debug_mark+1),a  
4f0b 3a 15 4f			ld a, (.dmark+2)  
4f0e 32 70 fe			ld (debug_mark+2),a  
4f11 18 03			jr .pastdmark  
4f13 ..			.dmark: db "FO0"  
4f16 f1			.pastdmark: pop af  
4f17			endm  
# End of macro DMARK
4f17					CALLMONITOR 
4f17 cd 9d 17			call break_point_state  
4f1a				endm  
# End of macro CALLMONITOR
4f1a				endif 
4f1a					; force bank init 
4f1a			 
4f1a cd 85 04				call storage_get_block_0 
4f1d					 
4f1d				       NEXTW 
4f1d c3 74 21			jp macro_next 
4f20				endm 
# End of macro NEXTW
4f20			.LABEL: 
4f20				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4f20 6d				db WORD_SYS_CORE+89             
4f21 6e 4f			dw .STOREPAGE            
4f23 06				db 5 + 1 
4f24 .. 00			db "LABEL",0              
4f2a				endm 
# End of macro CWHEAD
4f2a			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4f2a					; TODO test to see if bank is selected 
4f2a				 
4f2a					if DEBUG_FORTH_WORDS_KEY 
4f2a						DMARK "LBL" 
4f2a f5				push af  
4f2b 3a 3f 4f			ld a, (.dmark)  
4f2e 32 6e fe			ld (debug_mark),a  
4f31 3a 40 4f			ld a, (.dmark+1)  
4f34 32 6f fe			ld (debug_mark+1),a  
4f37 3a 41 4f			ld a, (.dmark+2)  
4f3a 32 70 fe			ld (debug_mark+2),a  
4f3d 18 03			jr .pastdmark  
4f3f ..			.dmark: db "LBL"  
4f42 f1			.pastdmark: pop af  
4f43			endm  
# End of macro DMARK
4f43						CALLMONITOR 
4f43 cd 9d 17			call break_point_state  
4f46				endm  
# End of macro CALLMONITOR
4f46					endif 
4f46			;	if DEBUG_STORESE 
4f46			;		DMARK "LBL" 
4f46			;		CALLMONITOR 
4f46			;	endif 
4f46					FORTH_DSP_VALUEHL 
4f46 cd 02 20			call macro_dsp_valuehl 
4f49				endm 
# End of macro FORTH_DSP_VALUEHL
4f49					;v5FORTH_DSP_VALUE 
4f49					 
4f49			;		push hl 
4f49					FORTH_DSP_POP 
4f49 cd ba 20			call macro_forth_dsp_pop 
4f4c				endm 
# End of macro FORTH_DSP_POP
4f4c			;		pop hl 
4f4c			 
4f4c			;v5		inc hl   ; move past the type marker 
4f4c			 
4f4c				if DEBUG_STORESE 
4f4c					DMARK "LBl" 
4f4c f5				push af  
4f4d 3a 61 4f			ld a, (.dmark)  
4f50 32 6e fe			ld (debug_mark),a  
4f53 3a 62 4f			ld a, (.dmark+1)  
4f56 32 6f fe			ld (debug_mark+1),a  
4f59 3a 63 4f			ld a, (.dmark+2)  
4f5c 32 70 fe			ld (debug_mark+2),a  
4f5f 18 03			jr .pastdmark  
4f61 ..			.dmark: db "LBl"  
4f64 f1			.pastdmark: pop af  
4f65			endm  
# End of macro DMARK
4f65					CALLMONITOR 
4f65 cd 9d 17			call break_point_state  
4f68				endm  
# End of macro CALLMONITOR
4f68				endif 
4f68 cd a9 05				call storage_label 
4f6b			 
4f6b				       NEXTW 
4f6b c3 74 21			jp macro_next 
4f6e				endm 
# End of macro NEXTW
4f6e			.STOREPAGE: 
4f6e				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4f6e 6d				db WORD_SYS_CORE+89             
4f6f a1 4f			dw .LABELS            
4f71 0a				db 9 + 1 
4f72 .. 00			db "STOREPAGE",0              
4f7c				endm 
# End of macro CWHEAD
4f7c			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4f7c					; TODO test to see if bank is selected 
4f7c				 
4f7c					if DEBUG_FORTH_WORDS_KEY 
4f7c						DMARK "STP" 
4f7c f5				push af  
4f7d 3a 91 4f			ld a, (.dmark)  
4f80 32 6e fe			ld (debug_mark),a  
4f83 3a 92 4f			ld a, (.dmark+1)  
4f86 32 6f fe			ld (debug_mark+1),a  
4f89 3a 93 4f			ld a, (.dmark+2)  
4f8c 32 70 fe			ld (debug_mark+2),a  
4f8f 18 03			jr .pastdmark  
4f91 ..			.dmark: db "STP"  
4f94 f1			.pastdmark: pop af  
4f95			endm  
# End of macro DMARK
4f95						CALLMONITOR 
4f95 cd 9d 17			call break_point_state  
4f98				endm  
# End of macro CALLMONITOR
4f98					endif 
4f98			;	if DEBUG_STORESE 
4f98			;		DMARK "STP" 
4f98			;		CALLMONITOR 
4f98			;	endif 
4f98			 
4f98 21 59 fb			ld hl, store_page 
4f9b cd 0b 1e			call forth_push_numhl 
4f9e			 
4f9e			 
4f9e				       NEXTW 
4f9e c3 74 21			jp macro_next 
4fa1				endm 
# End of macro NEXTW
4fa1			.LABELS: 
4fa1				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4fa1 6d				db WORD_SYS_CORE+89             
4fa2 2b 50			dw .ENDSTORAGE            
4fa4 07				db 6 + 1 
4fa5 .. 00			db "LABELS",0              
4fac				endm 
# End of macro CWHEAD
4fac			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4fac					;  
4fac			 
4fac					; save the current device selected to restore afterwards 
4fac				 
4fac 3a 3f fb				ld a, (spi_device) 
4faf f5					push af 
4fb0			 
4fb0			 
4fb0					; run through each of the banks 
4fb0			 
4fb0 21 01 00				ld hl, 1 
4fb3 cd 0b 1e				call forth_push_numhl 
4fb6 3e ff				ld a, SPI_CE_HIGH 
4fb8 cb 87				res SPI_CE0, a 
4fba 32 3f fb				ld (spi_device), a 
4fbd cd 85 04				call storage_get_block_0 
4fc0 21 5c fb				ld hl, store_page+3 
4fc3 cd 79 1e				call forth_push_str 
4fc6			 
4fc6					 
4fc6 21 02 00				ld hl, 2 
4fc9 cd 0b 1e				call forth_push_numhl 
4fcc 3e ff				ld a, SPI_CE_HIGH 
4fce cb 8f				res SPI_CE1, a 
4fd0 32 3f fb				ld (spi_device), a 
4fd3 cd 85 04				call storage_get_block_0 
4fd6 21 5c fb				ld hl, store_page+3 
4fd9 cd 79 1e				call forth_push_str 
4fdc			 
4fdc					 
4fdc 21 03 00				ld hl, 3 
4fdf cd 0b 1e				call forth_push_numhl 
4fe2 3e ff				ld a, SPI_CE_HIGH 
4fe4 cb 97				res SPI_CE2, a 
4fe6 32 3f fb				ld (spi_device), a 
4fe9 cd 85 04				call storage_get_block_0 
4fec 21 5c fb				ld hl, store_page+3 
4fef cd 79 1e				call forth_push_str 
4ff2			 
4ff2			 
4ff2 21 04 00				ld hl, 4 
4ff5 cd 0b 1e				call forth_push_numhl 
4ff8 3e ff				ld a, SPI_CE_HIGH 
4ffa cb 9f				res SPI_CE3, a 
4ffc 32 3f fb				ld (spi_device), a 
4fff cd 85 04				call storage_get_block_0 
5002 21 5c fb				ld hl, store_page+3 
5005 cd 79 1e				call forth_push_str 
5008			 
5008					 
5008			 
5008 21 05 00				ld hl, 5 
500b cd 0b 1e				call forth_push_numhl 
500e 3e ff				ld a, SPI_CE_HIGH 
5010 cb a7				res SPI_CE4, a 
5012 32 3f fb				ld (spi_device), a 
5015 cd 85 04				call storage_get_block_0 
5018 21 5c fb				ld hl, store_page+3 
501b cd 79 1e				call forth_push_str 
501e			 
501e					 
501e					; push fixed count of storage devices (on board) for now 
501e			 
501e 21 05 00				ld hl, 5 
5021 cd 0b 1e				call forth_push_numhl 
5024			 
5024					; restore selected device  
5024				 
5024 f1					pop af 
5025 32 3f fb				ld (spi_device), a 
5028			 
5028				       NEXTW 
5028 c3 74 21			jp macro_next 
502b				endm 
# End of macro NEXTW
502b			 
502b			.ENDSTORAGE: 
502b			; eof 
# End of file forth_words_storage.asm
502b			endif 
502b				include "forth_words_device.asm" 
502b			; Device related words 
502b			 
502b			; | ## Device Words 
502b			 
502b			if SOUND_ENABLE 
502b			.NOTE: 
502b				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
502b 33				db WORD_SYS_CORE+31             
502c 53 50			dw .AFTERSOUND            
502e 05				db 4 + 1 
502f .. 00			db "NOTE",0              
5034				endm 
# End of macro CWHEAD
5034			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
5034					if DEBUG_FORTH_WORDS_KEY 
5034						DMARK "NTE" 
5034 f5				push af  
5035 3a 49 50			ld a, (.dmark)  
5038 32 6e fe			ld (debug_mark),a  
503b 3a 4a 50			ld a, (.dmark+1)  
503e 32 6f fe			ld (debug_mark+1),a  
5041 3a 4b 50			ld a, (.dmark+2)  
5044 32 70 fe			ld (debug_mark+2),a  
5047 18 03			jr .pastdmark  
5049 ..			.dmark: db "NTE"  
504c f1			.pastdmark: pop af  
504d			endm  
# End of macro DMARK
504d						CALLMONITOR 
504d cd 9d 17			call break_point_state  
5050				endm  
# End of macro CALLMONITOR
5050					endif 
5050			 
5050				 
5050			 
5050					NEXTW 
5050 c3 74 21			jp macro_next 
5053				endm 
# End of macro NEXTW
5053			.AFTERSOUND: 
5053			endif 
5053			 
5053			 
5053			USE_GPIO: equ 0 
5053			 
5053			if USE_GPIO 
5053			.GP1: 
5053				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5053			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
5053					NEXTW 
5053			.GP2: 
5053				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5053			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
5053			 
5053					NEXTW 
5053			 
5053			.GP3: 
5053				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5053			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
5053			 
5053					NEXTW 
5053			 
5053			.GP4: 
5053				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5053			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
5053			 
5053					NEXTW 
5053			.SIN: 
5053			 
5053			 
5053			endif 
5053			 
5053			 
5053				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5053 33				db WORD_SYS_CORE+31             
5054 88 50			dw .SOUT            
5056 03				db 2 + 1 
5057 .. 00			db "IN",0              
505a				endm 
# End of macro CWHEAD
505a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
505a					if DEBUG_FORTH_WORDS_KEY 
505a						DMARK "IN." 
505a f5				push af  
505b 3a 6f 50			ld a, (.dmark)  
505e 32 6e fe			ld (debug_mark),a  
5061 3a 70 50			ld a, (.dmark+1)  
5064 32 6f fe			ld (debug_mark+1),a  
5067 3a 71 50			ld a, (.dmark+2)  
506a 32 70 fe			ld (debug_mark+2),a  
506d 18 03			jr .pastdmark  
506f ..			.dmark: db "IN."  
5072 f1			.pastdmark: pop af  
5073			endm  
# End of macro DMARK
5073						CALLMONITOR 
5073 cd 9d 17			call break_point_state  
5076				endm  
# End of macro CALLMONITOR
5076					endif 
5076					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5076 cd 02 20			call macro_dsp_valuehl 
5079				endm 
# End of macro FORTH_DSP_VALUEHL
5079			 
5079 e5					push hl 
507a			 
507a					; destroy value TOS 
507a			 
507a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
507a cd ba 20			call macro_forth_dsp_pop 
507d				endm 
# End of macro FORTH_DSP_POP
507d			 
507d					; one value on hl get other one back 
507d			 
507d c1					pop bc 
507e			 
507e					; do the sub 
507e			;		ex de, hl 
507e			 
507e ed 68				in l,(c) 
5080			 
5080					; save it 
5080			 
5080 26 00				ld h,0 
5082			 
5082					; TODO push value back onto stack for another op etc 
5082			 
5082 cd 0b 1e				call forth_push_numhl 
5085					NEXTW 
5085 c3 74 21			jp macro_next 
5088				endm 
# End of macro NEXTW
5088			.SOUT: 
5088				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5088 34				db WORD_SYS_CORE+32             
5089 db 50			dw .SPIO            
508b 04				db 3 + 1 
508c .. 00			db "OUT",0              
5090				endm 
# End of macro CWHEAD
5090			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5090					if DEBUG_FORTH_WORDS_KEY 
5090						DMARK "OUT" 
5090 f5				push af  
5091 3a a5 50			ld a, (.dmark)  
5094 32 6e fe			ld (debug_mark),a  
5097 3a a6 50			ld a, (.dmark+1)  
509a 32 6f fe			ld (debug_mark+1),a  
509d 3a a7 50			ld a, (.dmark+2)  
50a0 32 70 fe			ld (debug_mark+2),a  
50a3 18 03			jr .pastdmark  
50a5 ..			.dmark: db "OUT"  
50a8 f1			.pastdmark: pop af  
50a9			endm  
# End of macro DMARK
50a9						CALLMONITOR 
50a9 cd 9d 17			call break_point_state  
50ac				endm  
# End of macro CALLMONITOR
50ac					endif 
50ac			 
50ac					; get port 
50ac			 
50ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ac cd 02 20			call macro_dsp_valuehl 
50af				endm 
# End of macro FORTH_DSP_VALUEHL
50af			 
50af e5					push hl 
50b0			 
50b0					; destroy value TOS 
50b0			 
50b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b0 cd ba 20			call macro_forth_dsp_pop 
50b3				endm 
# End of macro FORTH_DSP_POP
50b3			 
50b3					; get byte to send 
50b3			 
50b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50b3 cd 02 20			call macro_dsp_valuehl 
50b6				endm 
# End of macro FORTH_DSP_VALUEHL
50b6			 
50b6			;		push hl 
50b6			 
50b6					; destroy value TOS 
50b6			 
50b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b6 cd ba 20			call macro_forth_dsp_pop 
50b9				endm 
# End of macro FORTH_DSP_POP
50b9			 
50b9					; one value on hl get other one back 
50b9			 
50b9			;		pop hl 
50b9			 
50b9 c1					pop bc 
50ba			 
50ba					if DEBUG_FORTH_WORDS 
50ba						DMARK "OUT" 
50ba f5				push af  
50bb 3a cf 50			ld a, (.dmark)  
50be 32 6e fe			ld (debug_mark),a  
50c1 3a d0 50			ld a, (.dmark+1)  
50c4 32 6f fe			ld (debug_mark+1),a  
50c7 3a d1 50			ld a, (.dmark+2)  
50ca 32 70 fe			ld (debug_mark+2),a  
50cd 18 03			jr .pastdmark  
50cf ..			.dmark: db "OUT"  
50d2 f1			.pastdmark: pop af  
50d3			endm  
# End of macro DMARK
50d3						CALLMONITOR 
50d3 cd 9d 17			call break_point_state  
50d6				endm  
# End of macro CALLMONITOR
50d6					endif 
50d6			 
50d6 ed 69				out (c), l 
50d8			 
50d8					NEXTW 
50d8 c3 74 21			jp macro_next 
50db				endm 
# End of macro NEXTW
50db			 
50db			 
50db			.SPIO: 
50db			 
50db			if STORAGE_SE 
50db				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
50db 51				db WORD_SYS_CORE+61             
50dc ec 50			dw .SPICEH            
50de 07				db 6 + 1 
50df .. 00			db "SPICEL",0              
50e6				endm 
# End of macro CWHEAD
50e6			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
50e6			 
50e6 cd 87 01				call spi_ce_low 
50e9			    NEXTW 
50e9 c3 74 21			jp macro_next 
50ec				endm 
# End of macro NEXTW
50ec			 
50ec			.SPICEH: 
50ec				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
50ec 51				db WORD_SYS_CORE+61             
50ed fd 50			dw .SPIOb            
50ef 07				db 6 + 1 
50f0 .. 00			db "SPICEH",0              
50f7				endm 
# End of macro CWHEAD
50f7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
50f7			 
50f7 cd 76 01				call spi_ce_high 
50fa			    NEXTW 
50fa c3 74 21			jp macro_next 
50fd				endm 
# End of macro NEXTW
50fd			 
50fd			 
50fd			.SPIOb: 
50fd			 
50fd				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
50fd 51				db WORD_SYS_CORE+61             
50fe 13 51			dw .SPII            
5100 05				db 4 + 1 
5101 .. 00			db "SPIO",0              
5106				endm 
# End of macro CWHEAD
5106			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5106			 
5106					; get port 
5106			 
5106			 
5106					; get byte to send 
5106			 
5106					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5106 cd 02 20			call macro_dsp_valuehl 
5109				endm 
# End of macro FORTH_DSP_VALUEHL
5109			 
5109			;		push hl    ; u1  
5109			 
5109					; destroy value TOS 
5109			 
5109					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5109 cd ba 20			call macro_forth_dsp_pop 
510c				endm 
# End of macro FORTH_DSP_POP
510c			 
510c					; one value on hl get other one back 
510c			 
510c			;		pop hl   ; u2 - addr 
510c			 
510c					; TODO Send SPI byte 
510c			 
510c 7d					ld a, l 
510d cd ab 00				call spi_send_byte 
5110			 
5110					NEXTW 
5110 c3 74 21			jp macro_next 
5113				endm 
# End of macro NEXTW
5113			 
5113			.SPII: 
5113				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5113 52				db WORD_SYS_CORE+62             
5114 28 51			dw .SESEL            
5116 06				db 5 + 1 
5117 .. 00			db "SPII",0              
511c				endm 
# End of macro CWHEAD
511c			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
511c			 
511c					; TODO Get SPI byte 
511c			 
511c cd cc 00				call spi_read_byte 
511f			 
511f 26 00				ld h, 0 
5121 6f					ld l, a 
5122 cd 0b 1e				call forth_push_numhl 
5125			 
5125					NEXTW 
5125 c3 74 21			jp macro_next 
5128				endm 
# End of macro NEXTW
5128			 
5128			 
5128			 
5128			.SESEL: 
5128				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5128 66				db WORD_SYS_CORE+82             
5129 cc 51			dw .CARTDEV            
512b 05				db 4 + 1 
512c .. 00			db "BANK",0              
5131				endm 
# End of macro CWHEAD
5131			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5131					if DEBUG_FORTH_WORDS_KEY 
5131						DMARK "BNK" 
5131 f5				push af  
5132 3a 46 51			ld a, (.dmark)  
5135 32 6e fe			ld (debug_mark),a  
5138 3a 47 51			ld a, (.dmark+1)  
513b 32 6f fe			ld (debug_mark+1),a  
513e 3a 48 51			ld a, (.dmark+2)  
5141 32 70 fe			ld (debug_mark+2),a  
5144 18 03			jr .pastdmark  
5146 ..			.dmark: db "BNK"  
5149 f1			.pastdmark: pop af  
514a			endm  
# End of macro DMARK
514a						CALLMONITOR 
514a cd 9d 17			call break_point_state  
514d				endm  
# End of macro CALLMONITOR
514d					endif 
514d			 
514d 3e ff				ld a, 255 
514f 32 42 fb				ld (spi_cartdev), a 
5152			 
5152					; get bank 
5152			 
5152					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5152 cd 02 20			call macro_dsp_valuehl 
5155				endm 
# End of macro FORTH_DSP_VALUEHL
5155			 
5155			;		push hl 
5155			 
5155					; destroy value TOS 
5155			 
5155					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5155 cd ba 20			call macro_forth_dsp_pop 
5158				endm 
# End of macro FORTH_DSP_POP
5158			 
5158					; one value on hl get other one back 
5158			 
5158			;		pop hl 
5158			 
5158			 
5158 0e ff				ld c, SPI_CE_HIGH 
515a 06 30				ld b, '0'    ; human readable bank number 
515c			 
515c 7d					ld a, l 
515d			 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "BNK" 
515d f5				push af  
515e 3a 72 51			ld a, (.dmark)  
5161 32 6e fe			ld (debug_mark),a  
5164 3a 73 51			ld a, (.dmark+1)  
5167 32 6f fe			ld (debug_mark+1),a  
516a 3a 74 51			ld a, (.dmark+2)  
516d 32 70 fe			ld (debug_mark+2),a  
5170 18 03			jr .pastdmark  
5172 ..			.dmark: db "BNK"  
5175 f1			.pastdmark: pop af  
5176			endm  
# End of macro DMARK
5176						CALLMONITOR 
5176 cd 9d 17			call break_point_state  
5179				endm  
# End of macro CALLMONITOR
5179					endif 
5179			 
5179					; active low 
5179			 
5179 fe 00				cp 0 
517b 28 28				jr z, .bset 
517d fe 01				cp 1 
517f 20 04				jr nz, .b2 
5181 cb 81				res 0, c 
5183 06 31				ld b, '1'    ; human readable bank number 
5185 fe 02		.b2:		cp 2 
5187 20 04				jr nz, .b3 
5189 cb 89				res 1, c 
518b 06 32				ld b, '2'    ; human readable bank number 
518d fe 03		.b3:		cp 3 
518f 20 04				jr nz, .b4 
5191 cb 91				res 2, c 
5193 06 33				ld b, '3'    ; human readable bank number 
5195 fe 04		.b4:		cp 4 
5197 20 04				jr nz, .b5 
5199 cb 99				res 3, c 
519b 06 34				ld b, '4'    ; human readable bank number 
519d fe 05		.b5:		cp 5 
519f 20 04				jr nz, .bset 
51a1 cb a1				res 4, c 
51a3 06 35				ld b, '5'    ; human readable bank number 
51a5			 
51a5			.bset: 
51a5 79					ld a, c 
51a6 32 3f fb				ld (spi_device),a 
51a9 78					ld a, b 
51aa 32 3e fb				ld (spi_device_id),a 
51ad					if DEBUG_FORTH_WORDS 
51ad						DMARK "BN2" 
51ad f5				push af  
51ae 3a c2 51			ld a, (.dmark)  
51b1 32 6e fe			ld (debug_mark),a  
51b4 3a c3 51			ld a, (.dmark+1)  
51b7 32 6f fe			ld (debug_mark+1),a  
51ba 3a c4 51			ld a, (.dmark+2)  
51bd 32 70 fe			ld (debug_mark+2),a  
51c0 18 03			jr .pastdmark  
51c2 ..			.dmark: db "BN2"  
51c5 f1			.pastdmark: pop af  
51c6			endm  
# End of macro DMARK
51c6						CALLMONITOR 
51c6 cd 9d 17			call break_point_state  
51c9				endm  
# End of macro CALLMONITOR
51c9					endif 
51c9			 
51c9					NEXTW 
51c9 c3 74 21			jp macro_next 
51cc				endm 
# End of macro NEXTW
51cc			 
51cc			.CARTDEV: 
51cc				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
51cc 66				db WORD_SYS_CORE+82             
51cd 75 52			dw .ENDDEVICE            
51cf 08				db 7 + 1 
51d0 .. 00			db "CARTDEV",0              
51d8				endm 
# End of macro CWHEAD
51d8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
51d8					if DEBUG_FORTH_WORDS_KEY 
51d8						DMARK "CDV" 
51d8 f5				push af  
51d9 3a ed 51			ld a, (.dmark)  
51dc 32 6e fe			ld (debug_mark),a  
51df 3a ee 51			ld a, (.dmark+1)  
51e2 32 6f fe			ld (debug_mark+1),a  
51e5 3a ef 51			ld a, (.dmark+2)  
51e8 32 70 fe			ld (debug_mark+2),a  
51eb 18 03			jr .pastdmark  
51ed ..			.dmark: db "CDV"  
51f0 f1			.pastdmark: pop af  
51f1			endm  
# End of macro DMARK
51f1						CALLMONITOR 
51f1 cd 9d 17			call break_point_state  
51f4				endm  
# End of macro CALLMONITOR
51f4					endif 
51f4			 
51f4					; disable se storage bank selection 
51f4			 
51f4 3e ff				ld a, SPI_CE_HIGH		; ce high 
51f6 32 3f fb				ld (spi_device), a 
51f9			 
51f9					; get bank 
51f9			 
51f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51f9 cd 02 20			call macro_dsp_valuehl 
51fc				endm 
# End of macro FORTH_DSP_VALUEHL
51fc			 
51fc			;		push hl 
51fc			 
51fc					; destroy value TOS 
51fc			 
51fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51fc cd ba 20			call macro_forth_dsp_pop 
51ff				endm 
# End of macro FORTH_DSP_POP
51ff			 
51ff					; one value on hl get other one back 
51ff			 
51ff			;		pop hl 
51ff			 
51ff					; active low 
51ff			 
51ff 0e ff				ld c, 255 
5201			 
5201 7d					ld a, l 
5202					if DEBUG_FORTH_WORDS 
5202						DMARK "CDV" 
5202 f5				push af  
5203 3a 17 52			ld a, (.dmark)  
5206 32 6e fe			ld (debug_mark),a  
5209 3a 18 52			ld a, (.dmark+1)  
520c 32 6f fe			ld (debug_mark+1),a  
520f 3a 19 52			ld a, (.dmark+2)  
5212 32 70 fe			ld (debug_mark+2),a  
5215 18 03			jr .pastdmark  
5217 ..			.dmark: db "CDV"  
521a f1			.pastdmark: pop af  
521b			endm  
# End of macro DMARK
521b						CALLMONITOR 
521b cd 9d 17			call break_point_state  
521e				endm  
# End of macro CALLMONITOR
521e					endif 
521e fe 00				cp 0 
5220 28 30				jr z, .cset 
5222 fe 01				cp 1 
5224 20 02				jr nz, .c2 
5226 cb 81				res 0, c 
5228 fe 02		.c2:		cp 2 
522a 20 02				jr nz, .c3 
522c cb 89				res 1, c 
522e fe 03		.c3:		cp 3 
5230 20 02				jr nz, .c4 
5232 cb 91				res 2, c 
5234 fe 04		.c4:		cp 4 
5236 20 02				jr nz, .c5 
5238 cb 99				res 3, c 
523a fe 05		.c5:		cp 5 
523c 20 02				jr nz, .c6 
523e cb a1				res 4, c 
5240 fe 06		.c6:		cp 6 
5242 20 02				jr nz, .c7 
5244 cb a9				res 5, c 
5246 fe 07		.c7:		cp 7 
5248 20 02				jr nz, .c8 
524a cb b1				res 6, c 
524c fe 08		.c8:		cp 8 
524e 20 02				jr nz, .cset 
5250 cb b9				res 7, c 
5252 79			.cset:		ld a, c 
5253 32 42 fb				ld (spi_cartdev),a 
5256			 
5256					if DEBUG_FORTH_WORDS 
5256						DMARK "CD2" 
5256 f5				push af  
5257 3a 6b 52			ld a, (.dmark)  
525a 32 6e fe			ld (debug_mark),a  
525d 3a 6c 52			ld a, (.dmark+1)  
5260 32 6f fe			ld (debug_mark+1),a  
5263 3a 6d 52			ld a, (.dmark+2)  
5266 32 70 fe			ld (debug_mark+2),a  
5269 18 03			jr .pastdmark  
526b ..			.dmark: db "CD2"  
526e f1			.pastdmark: pop af  
526f			endm  
# End of macro DMARK
526f						CALLMONITOR 
526f cd 9d 17			call break_point_state  
5272				endm  
# End of macro CALLMONITOR
5272					endif 
5272					NEXTW 
5272 c3 74 21			jp macro_next 
5275				endm 
# End of macro NEXTW
5275			endif 
5275			 
5275			.ENDDEVICE: 
5275			; eof 
5275			 
# End of file forth_words_device.asm
5275			 
5275			; var handler 
5275			 
5275			 
5275			.VARS: 
5275				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5275 78				db WORD_SYS_CORE+100             
5276 8d 52			dw .V0Q            
5278 04				db 3 + 1 
5279 .. 00			db "V0!",0              
527d				endm 
# End of macro CWHEAD
527d			;| V0! ( u1 -- )  Store value to v0  | DONE 
527d			 
527d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
527d cd 02 20			call macro_dsp_valuehl 
5280				endm 
# End of macro FORTH_DSP_VALUEHL
5280			 
5280 11 07 fb				ld de, cli_var_array 
5283			 
5283 eb					ex de, hl 
5284 73					ld (hl), e 
5285 23					inc hl 
5286 72					ld (hl), d 
5287			 
5287					; destroy value TOS 
5287			 
5287					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5287 cd ba 20			call macro_forth_dsp_pop 
528a				endm 
# End of macro FORTH_DSP_POP
528a			 
528a				       NEXTW 
528a c3 74 21			jp macro_next 
528d				endm 
# End of macro NEXTW
528d			.V0Q: 
528d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
528d 79				db WORD_SYS_CORE+101             
528e 9e 52			dw .V1S            
5290 04				db 3 + 1 
5291 .. 00			db "V0@",0              
5295				endm 
# End of macro CWHEAD
5295			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5295 2a 07 fb				ld hl, (cli_var_array) 
5298 cd 0b 1e				call forth_push_numhl 
529b			 
529b				       NEXTW 
529b c3 74 21			jp macro_next 
529e				endm 
# End of macro NEXTW
529e			.V1S: 
529e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
529e 7a				db WORD_SYS_CORE+102             
529f b6 52			dw .V1Q            
52a1 04				db 3 + 1 
52a2 .. 00			db "V1!",0              
52a6				endm 
# End of macro CWHEAD
52a6			;| V1! ( u1 -- )  Store value to v1 | DONE 
52a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52a6 cd 02 20			call macro_dsp_valuehl 
52a9				endm 
# End of macro FORTH_DSP_VALUEHL
52a9			 
52a9 11 09 fb				ld de, cli_var_array+2 
52ac				 
52ac eb					ex de, hl 
52ad 73					ld (hl), e 
52ae 23					inc hl 
52af 72					ld (hl), d 
52b0			 
52b0					; destroy value TOS 
52b0			 
52b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52b0 cd ba 20			call macro_forth_dsp_pop 
52b3				endm 
# End of macro FORTH_DSP_POP
52b3				       NEXTW 
52b3 c3 74 21			jp macro_next 
52b6				endm 
# End of macro NEXTW
52b6			.V1Q: 
52b6				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
52b6 7b				db WORD_SYS_CORE+103             
52b7 c7 52			dw .V2S            
52b9 04				db 3 + 1 
52ba .. 00			db "V1@",0              
52be				endm 
# End of macro CWHEAD
52be			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
52be 2a 09 fb				ld hl, (cli_var_array+2) 
52c1 cd 0b 1e				call forth_push_numhl 
52c4				       NEXTW 
52c4 c3 74 21			jp macro_next 
52c7				endm 
# End of macro NEXTW
52c7			.V2S: 
52c7				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
52c7 7c				db WORD_SYS_CORE+104             
52c8 df 52			dw .V2Q            
52ca 04				db 3 + 1 
52cb .. 00			db "V2!",0              
52cf				endm 
# End of macro CWHEAD
52cf			;| V2! ( u1 -- )  Store value to v2 | DONE 
52cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52cf cd 02 20			call macro_dsp_valuehl 
52d2				endm 
# End of macro FORTH_DSP_VALUEHL
52d2			 
52d2 11 0b fb				ld de, cli_var_array+4 
52d5				 
52d5 eb					ex de, hl 
52d6 73					ld (hl), e 
52d7 23					inc hl 
52d8 72					ld (hl), d 
52d9			 
52d9					; destroy value TOS 
52d9			 
52d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52d9 cd ba 20			call macro_forth_dsp_pop 
52dc				endm 
# End of macro FORTH_DSP_POP
52dc				       NEXTW 
52dc c3 74 21			jp macro_next 
52df				endm 
# End of macro NEXTW
52df			.V2Q: 
52df				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
52df 7d				db WORD_SYS_CORE+105             
52e0 f0 52			dw .V3S            
52e2 04				db 3 + 1 
52e3 .. 00			db "V2@",0              
52e7				endm 
# End of macro CWHEAD
52e7			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
52e7 2a 0b fb				ld hl, (cli_var_array+4) 
52ea cd 0b 1e				call forth_push_numhl 
52ed				       NEXTW 
52ed c3 74 21			jp macro_next 
52f0				endm 
# End of macro NEXTW
52f0			.V3S: 
52f0				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
52f0 7c				db WORD_SYS_CORE+104             
52f1 08 53			dw .V3Q            
52f3 04				db 3 + 1 
52f4 .. 00			db "V3!",0              
52f8				endm 
# End of macro CWHEAD
52f8			;| V3! ( u1 -- )  Store value to v3 | DONE 
52f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52f8 cd 02 20			call macro_dsp_valuehl 
52fb				endm 
# End of macro FORTH_DSP_VALUEHL
52fb			 
52fb 11 0d fb				ld de, cli_var_array+6 
52fe				 
52fe eb					ex de, hl 
52ff 73					ld (hl), e 
5300 23					inc hl 
5301 72					ld (hl), d 
5302			 
5302					; destroy value TOS 
5302			 
5302					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5302 cd ba 20			call macro_forth_dsp_pop 
5305				endm 
# End of macro FORTH_DSP_POP
5305				       NEXTW 
5305 c3 74 21			jp macro_next 
5308				endm 
# End of macro NEXTW
5308			.V3Q: 
5308				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5308 7d				db WORD_SYS_CORE+105             
5309 19 53			dw .END            
530b 04				db 3 + 1 
530c .. 00			db "V3@",0              
5310				endm 
# End of macro CWHEAD
5310			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5310 2a 0d fb				ld hl, (cli_var_array+6) 
5313 cd 0b 1e				call forth_push_numhl 
5316				       NEXTW 
5316 c3 74 21			jp macro_next 
5319				endm 
# End of macro NEXTW
5319			 
5319			 
5319			 
5319			 
5319			 
5319			; end of dict marker 
5319			 
5319 00			.END:    db WORD_SYS_END 
531a 00 00			dw 0 
531c 00				db 0 
531d			 
531d			; use to jp here for user dict words to save on macro expansion  
531d			 
531d			user_dict_next: 
531d				NEXTW 
531d c3 74 21			jp macro_next 
5320				endm 
# End of macro NEXTW
5320			 
5320			 
5320			user_exec: 
5320				;    ld hl, <word code> 
5320				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5320				;    call forthexec 
5320				;    jp user_dict_next   (NEXT) 
5320			        ;    <word code bytes> 
5320 eb				ex de, hl 
5321 2a d5 f5			ld hl,(os_tok_ptr) 
5324				 
5324				FORTH_RSP_NEXT 
5324 cd b2 1d			call macro_forth_rsp_next 
5327				endm 
# End of macro FORTH_RSP_NEXT
5327			 
5327			if DEBUG_FORTH_UWORD 
5327						DMARK "UEX" 
5327 f5				push af  
5328 3a 3c 53			ld a, (.dmark)  
532b 32 6e fe			ld (debug_mark),a  
532e 3a 3d 53			ld a, (.dmark+1)  
5331 32 6f fe			ld (debug_mark+1),a  
5334 3a 3e 53			ld a, (.dmark+2)  
5337 32 70 fe			ld (debug_mark+2),a  
533a 18 03			jr .pastdmark  
533c ..			.dmark: db "UEX"  
533f f1			.pastdmark: pop af  
5340			endm  
# End of macro DMARK
5340				CALLMONITOR 
5340 cd 9d 17			call break_point_state  
5343				endm  
# End of macro CALLMONITOR
5343			endif 
5343			 
5343			 
5343			 
5343 eb				ex de, hl 
5344 22 d5 f5			ld (os_tok_ptr), hl 
5347				 
5347				; Don't use next - Skips the first word in uword. 
5347			 
5347 c3 05 22			jp exec1 
534a			;	NEXT 
534a			 
534a			 
534a			; eof 
# End of file forth_wordsv4.asm
534a			endif 
534a			;;;;;;;;;;;;;; Debug code 
534a			 
534a			 
534a			;if DEBUG_FORTH_PARSE 
534a .. 00		.nowordfound: db "No match",0 
5353 .. 00		.compword:	db "Comparing word ",0 
5363 .. 00		.nextwordat:	db "Next word at",0 
5370 .. 00		.charmatch:	db "Char match",0 
537b			;endif 
537b			if DEBUG_FORTH_JP 
537b			.foundword:	db "Word match. Exec..",0 
537b			endif 
537b			;if DEBUG_FORTH_PUSH 
537b .. 00		.enddict:	db "Dict end. Push.",0 
538b .. 00		.push_str:	db "Pushing string",0 
539a .. 00		.push_num:	db "Pushing number",0 
53a9 .. 00		.data_sp:	db "SP:",0 
53ad .. 00		.wordinhl:	db "Word in HL (2/0):",0 
53bf .. 00		.wordinde:	db "Word in DE (3/0):",0 
53d1 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
53e3			;endif 
53e3			;if DEBUG_FORTH_MALLOC 
53e3 .. 00		.push_malloc:	db "Malloc address",0 
53f2			;endif 
53f2			 
53f2			 
53f2			 
53f2			; display malloc address and current data stack pointer  
53f2			 
53f2			malloc_error: 
53f2 d5				push de 
53f3 f5				push af 
53f4 e5				push hl 
53f5 cd c2 0b			call clear_display 
53f8 11 1a 54			ld de, .mallocerr 
53fb 3e 00			ld a,0 
53fd			;	ld de,os_word_scratch 
53fd cd d5 0b			call str_at_display 
5400 3e 11			ld a, display_row_1+17 
5402 11 6e fe			ld de, debug_mark 
5405 cd d5 0b			call str_at_display 
5408 cd e5 0b			call update_display 
540b				;call break_point_state 
540b cd 43 6b			call cin_wait 
540e			 
540e 3e 20			ld a, ' ' 
5410 32 c5 f2			ld (os_view_disable), a 
5413 e1				pop hl 
5414 f1				pop af 
5415 d1				pop de	 
5416				CALLMONITOR 
5416 cd 9d 17			call break_point_state  
5419				endm  
# End of macro CALLMONITOR
5419 c9				ret 
541a			 
541a .. 00		.mallocerr: 	db "Malloc Error",0 
5427			;if DEBUG_FORTH_PUSH 
5427			display_data_sp: 
5427 f5				push af 
5428			 
5428				; see if disabled 
5428			 
5428 3a c5 f2			ld a, (os_view_disable) 
542b fe 2a			cp '*' 
542d 28 67			jr z, .skipdsp 
542f			 
542f e5				push hl 
5430 e5				push hl 
5431 e5			push hl 
5432 cd c2 0b			call clear_display 
5435 e1			pop hl 
5436 7c				ld a,h 
5437 21 d9 f5			ld hl, os_word_scratch 
543a cd f7 10			call hexout 
543d e1				pop hl 
543e 7d				ld a,l 
543f 21 db f5			ld hl, os_word_scratch+2 
5442 cd f7 10			call hexout 
5445 21 dd f5			ld hl, os_word_scratch+4 
5448 3e 00			ld a,0 
544a 77				ld (hl),a 
544b 11 d9 f5			ld de,os_word_scratch 
544e 3e 28				ld a, display_row_2 
5450 cd d5 0b				call str_at_display 
5453 11 ad 53			ld de, .wordinhl 
5456 3e 00			ld a, display_row_1 
5458			 
5458 cd d5 0b				call str_at_display 
545b 11 6e fe			ld de, debug_mark 
545e 3e 11			ld a, display_row_1+17 
5460			 
5460 cd d5 0b				call str_at_display 
5463			 
5463				; display current data stack pointer 
5463 11 a9 53			ld de,.data_sp 
5466 3e 30				ld a, display_row_2 + 8 
5468 cd d5 0b				call str_at_display 
546b			 
546b 2a 01 fb			ld hl,(cli_data_sp) 
546e e5				push hl 
546f 7c				ld a,h 
5470 21 d9 f5			ld hl, os_word_scratch 
5473 cd f7 10			call hexout 
5476 e1				pop hl 
5477 7d				ld a,l 
5478 21 db f5			ld hl, os_word_scratch+2 
547b cd f7 10			call hexout 
547e 21 dd f5			ld hl, os_word_scratch+4 
5481 3e 00			ld a,0 
5483 77				ld (hl),a 
5484 11 d9 f5			ld de,os_word_scratch 
5487 3e 33				ld a, display_row_2 + 11 
5489 cd d5 0b				call str_at_display 
548c			 
548c			 
548c cd e5 0b			call update_display 
548f cd 3f 0b			call delay1s 
5492 cd 3f 0b			call delay1s 
5495 e1				pop hl 
5496			.skipdsp: 
5496 f1				pop af 
5497 c9				ret 
5498			 
5498			display_data_malloc: 
5498			 
5498 f5				push af 
5499 e5				push hl 
549a e5				push hl 
549b e5			push hl 
549c cd c2 0b			call clear_display 
549f e1			pop hl 
54a0 7c				ld a,h 
54a1 21 d9 f5			ld hl, os_word_scratch 
54a4 cd f7 10			call hexout 
54a7 e1				pop hl 
54a8 7d				ld a,l 
54a9 21 db f5			ld hl, os_word_scratch+2 
54ac cd f7 10			call hexout 
54af 21 dd f5			ld hl, os_word_scratch+4 
54b2 3e 00			ld a,0 
54b4 77				ld (hl),a 
54b5 11 d9 f5			ld de,os_word_scratch 
54b8 3e 28				ld a, display_row_2 
54ba cd d5 0b				call str_at_display 
54bd 11 e3 53			ld de, .push_malloc 
54c0 3e 00			ld a, display_row_1 
54c2			 
54c2 cd d5 0b				call str_at_display 
54c5			 
54c5				; display current data stack pointer 
54c5 11 a9 53			ld de,.data_sp 
54c8 3e 30				ld a, display_row_2 + 8 
54ca cd d5 0b				call str_at_display 
54cd			 
54cd 2a 01 fb			ld hl,(cli_data_sp) 
54d0 e5				push hl 
54d1 7c				ld a,h 
54d2 21 d9 f5			ld hl, os_word_scratch 
54d5 cd f7 10			call hexout 
54d8 e1				pop hl 
54d9 7d				ld a,l 
54da 21 db f5			ld hl, os_word_scratch+2 
54dd cd f7 10			call hexout 
54e0 21 dd f5			ld hl, os_word_scratch+4 
54e3 3e 00			ld a,0 
54e5 77				ld (hl),a 
54e6 11 d9 f5			ld de,os_word_scratch 
54e9 3e 33				ld a, display_row_2 + 11 
54eb cd d5 0b				call str_at_display 
54ee			 
54ee cd e5 0b			call update_display 
54f1 cd 3f 0b			call delay1s 
54f4 cd 3f 0b			call delay1s 
54f7 e1				pop hl 
54f8 f1				pop af 
54f9 c9				ret 
54fa			;endif 
54fa			 
54fa			include "forth_autostart.asm" 
54fa			; list of commands to perform at system start up 
54fa			 
54fa			startcmds: 
54fa			;	dw test11 
54fa			;	dw test12 
54fa			;	dw test13 
54fa			;	dw test14 
54fa			;	dw test15 
54fa			;	dw test16 
54fa			;	dw test17 
54fa			;	dw ifthtest1 
54fa			;	dw ifthtest2 
54fa			;	dw ifthtest3 
54fa			;	dw mmtest1 
54fa			;	dw mmtest2 
54fa			;	dw mmtest3 
54fa			;	dw mmtest4 
54fa			;	dw mmtest5 
54fa			;	dw mmtest6 
54fa			;	dw iftest1 
54fa			;	dw iftest2 
54fa			;	dw iftest3 
54fa			;	dw looptest1 
54fa			;	dw looptest2 
54fa			;	dw test1 
54fa			;	dw test2 
54fa			;	dw test3 
54fa			;	dw test4 
54fa			;	dw game2r 
54fa			;	dw game2b1 
54fa			;	dw game2b2 
54fa			 
54fa				; start up words that are actually useful 
54fa			 
54fa 58 55			dw clrstack 
54fc 8b 55			dw type 
54fe 7b 57			dw stest 
5500 af 55			dw strncpy 
5502 11 57			dw list 
5504 10 56			dw start1 
5506 22 56			dw start2 
5508			;	dw start3 
5508 35 56			dw start3b 
550a b1 56			dw start3c 
550c			 
550c				; (unit) testing words 
550c			 
550c f2 57			dw mtesta 
550e a7 58			dw mtestb 
5510 4a 59			dw mtestc 
5512 ff 59			dw mtestd 
5514 a3 5a			dw mteste 
5516			 
5516				; demo/game words 
5516			 
5516 af 61		        dw game3w 
5518 dd 61		        dw game3p 
551a fb 61		        dw game3sc 
551c 2c 62		        dw game3vsi 
551e 58 62		        dw game3vs 
5520				 
5520 a2 5f			dw game2b 
5522 10 60			dw game2bf 
5524 5a 60			dw game2mba 
5526 f0 60			dw game2mbas 
5528 32 61			dw game2mb 
552a			 
552a 63 5c			dw game1 
552c 74 5c			dw game1a 
552e d6 5c			dw game1b 
5530 0b 5d			dw game1c 
5532 41 5d			dw game1d 
5534 72 5d			dw game1s 
5536 86 5d			dw game1t 
5538 9b 5d			dw game1f 
553a cf 5d			dw game1z 
553c 13 5e			dw game1zz 
553e			 
553e 59 5b			dw test5 
5540 91 5b			dw test6 
5542 c9 5b			dw test7 
5544 dd 5b			dw test8 
5546 09 5c			dw test9 
5548 1f 5c			dw test10 
554a				 
554a ea 5e		        dw ssv5 
554c ce 5e		        dw ssv4 
554e b2 5e		        dw ssv3 
5550 7c 5e		        dw ssv2 
5552 03 5f		        dw ssv1 
5554 4b 5f		        dw ssv1cpm 
5556			;	dw keyup 
5556			;	dw keydown 
5556			;	dw keyleft 
5556			;	dw keyright 
5556			;	dw 	keyf1 
5556			;	dw keyf2 
5556			;	dw keyf3 
5556			;	dw keyf4 
5556			;	dw keyf5 
5556			;	dw keyf6 
5556			;	dw keyf7 
5556			;	dw keyf8 
5556			;	dw keyf9 
5556			;	dw keyf10 
5556			;	dw keyf11 
5556			;	dw keyf12 
5556			;	dw keytab 
5556			;	dw keycr 
5556			;	dw keyhome 
5556			;	dw keyend 
5556			;	dw keybs 
5556 00 00			db 0, 0	 
5558			 
5558			 
5558			; clear stack  
5558			 
5558 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
558b			 
558b			; type ( addr count - ) 
558b .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
55af			 
55af			; some direct memory words 
55af			; strncpy ( len t f -- t ) 
55af			 
55af .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5610			 
5610 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5622 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5635 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
56b1 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5711			 
5711			 
5711			; a handy word to list items on the stack 
5711			 
5711 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
577b			 
577b			 
577b			; test stack  
577b			; rnd8 stest 
577b			 
577b .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
57f2			 
57f2			; random malloc and free cycles 
57f2			 
57f2 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
58a7			 
58a7			; fixed malloc and free cycles 
58a7			 
58a7 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
594a			 
594a			; fixed double string push and drop cycle  
594a			 
594a .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
59ff			 
59ff			; consistent fixed string push and drop cycle  
59ff			 
59ff .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5aa3			 
5aa3 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b59			 
5b59			;test1:		db ": aa 1 2 3 ;", 0 
5b59			;test2:     	db "111 aa 888 999",0 
5b59			;test3:     	db ": bb 77 ;",0 
5b59			;test4:     	db "$02 $01 do i . loop bb",0 
5b59			 
5b59 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5b91 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5bc9 .. 00		test7:     	db ": box hline vline ;",0 
5bdd .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5c09 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5c1f .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5c44 .. 00		test11:     	db "hello create .",0 
5c53 .. 00		test12:     	db "hello2 create .",0 
5c63			 
5c63			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5c63			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5c63			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5c63			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5c63			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5c63			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5c63			 
5c63			;iftest1:     	db "$0001 IF cls .",0 
5c63			;iftest2:     	db "$0000 IF cls .",0 
5c63			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5c63			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5c63			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5c63			 
5c63			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c63			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c63			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c63			 
5c63			 
5c63			 
5c63			; a small guess the number game 
5c63			 
5c63 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5c74 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5cd6			 
5cd6 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5d0b .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5d41 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5d72 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5d86 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5d9b .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5dcf .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5e13			 
5e13			; Using 'ga' save a high score across multiple runs using external storage 
5e13			 
5e13 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5e7c			 
5e7c			 
5e7c			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5e7c			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e7c			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e7c			 
5e7c			; simple screen saver to test code memory reuse to destruction 
5e7c			 
5e7c .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5eb2 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5ece .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5eea .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5f03 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5f4b .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5fa2			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5fa2			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5fa2			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5fa2			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5fa2			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5fa2			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5fa2			 
5fa2			 
5fa2			 
5fa2			; minesweeper/battleship finding game 
5fa2			; draws a game board of random ship/mine positions 
5fa2			; user enters coords to see if it hits on 
5fa2			; game ends when all are hit 
5fa2			; when hit or miss says how many may be in the area 
5fa2			 
5fa2			; setup the game board and then hide it 
5fa2 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6010 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
605a			; prompt for where to target 
605a .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
60f0 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6115			; TODO see if the entered coords hits or misses pushes char hit of miss 
6115 .. 00		game2mbht:      db ": mbckht nop ;",0 
6124 .. 00		game2mbms:      db ": mbcms nop ;",0 
6132			; TODO how many might be near by 
6132 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
61af			 
61af			; Game 3 
61af			 
61af			; Vert scroller ski game - avoid the trees! 
61af			 
61af			; v0 score (ie turns) 
61af			; v1 player pos 
61af			; v2 left wall 
61af			; v3 right wall 
61af			 
61af			; Draw side walls randomly 
61af			 
61af .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
61dd			 
61dd			; Draw player 
61dd .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
61fb			 
61fb			; TODO Get Key 
61fb			 
61fb			; TODO Move left right 
61fb			 
61fb			; scroll and move walls a bit 
61fb			 
61fb .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
622c			 
622c			; main game loop 
622c			 
622c .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6258 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6297			 
6297			; key board defs 
6297			 
6297 .. 00		keyup:       db ": keyup $05 ;",0 
62a5 .. 00		keydown:       db ": keydown $0a ;",0 
62b5 .. 00		keyleft:       db ": keyleft $0b ;",0 
62c5 .. 00		keyright:       db ": keyright $0c ;",0 
62d6 .. 00		keyf1:       db ": keyf1 $10 ;",0 
62e4 .. 00		keyf2:       db ": keyf2 $11 ;",0 
62f2 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6300 .. 00		keyf4:       db ": keyf4 $13 ;",0 
630e .. 00		keyf5:       db ": keyf5 $14 ;",0 
631c .. 00		keyf6:       db ": keyf6 $15 ;",0 
632a .. 00		keyf7:       db ": keyf7 $16 ;",0 
6338 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6346 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6354 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6363 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6372 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6381			 
6381 .. 00		keytab:       db ": keytab $09 ;",0 
6390 .. 00		keycr:       db ": keycr $0d ;",0 
639e .. 00		keyhome:       db ": keyhome $0e ;",0 
63ae .. 00		keyend:       db ": keyend $0f ;",0 
63bd .. 00		keybs:       db ": keybs $08 ;",0 
63cb			 
63cb			   
63cb			 
63cb			 
63cb			 
63cb			; eof 
# End of file forth_autostart.asm
63cb			 
63cb .. 00		sprompt1: db "Startup load...",0 
63db .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63f1			 
63f1			 
63f1			 
63f1			 
63f1			forth_startup: 
63f1 21 fa 54			ld hl, startcmds 
63f4 3e 00			ld a, 0 
63f6 32 fa f6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63f9			 
63f9 e5			.start1:	push hl 
63fa cd c2 0b			call clear_display 
63fd 11 cb 63			ld de, sprompt1 
6400 3e 00		        ld a, display_row_1 
6402 cd d5 0b			call str_at_display 
6405 11 db 63			ld de, sprompt2 
6408 3e 28		        ld a, display_row_2 
640a cd d5 0b			call str_at_display 
640d e1				pop hl 
640e e5				push hl 
640f 5e				ld e,(hl) 
6410 23				inc hl 
6411 56				ld d,(hl) 
6412 3e 50		        ld a, display_row_3 
6414 cd d5 0b			call str_at_display 
6417 cd e5 0b			call update_display 
641a			 
641a			 
641a 3a fa f6			ld a, (os_last_cmd) 
641d fe 00			cp 0 
641f 28 05			jr z, .startprompt 
6421 cd 33 0b			call delay250ms 
6424 18 24			jr .startdo 
6426				 
6426				 
6426			 
6426			.startprompt: 
6426			 
6426 3e 9f			ld a,display_row_4 + display_cols - 1 
6428 11 81 1d		        ld de, endprg 
642b cd d5 0b			call str_at_display 
642e cd e5 0b			call update_display 
6431 cd 3f 0b			call delay1s 
6434 cd 43 6b			call cin_wait 
6437						 
6437 fe 2a			cp '*' 
6439 28 5e			jr z, .startupend1 
643b fe 23			cp '#' 
643d 20 07			jr nz, .startno 
643f 3e 01			ld a, 1 
6441 32 fa f6			ld (os_last_cmd),a 
6444 18 04			jr .startdo 
6446 fe 31		.startno:	cp '1' 
6448 28 3a			jr z,.startnxt  
644a			 
644a				; exec startup line 
644a			.startdo:	 
644a e1				pop hl 
644b e5				push hl 
644c				 
644c 5e				ld e,(hl) 
644d 23				inc hl 
644e 56				ld d,(hl) 
644f eb				ex de,hl 
6450			 
6450 e5				push hl 
6451			 
6451 3e 00			ld a, 0 
6453				;ld a, FORTH_END_BUFFER 
6453 cd 5f 12			call strlent 
6456 23				inc hl   ; include zero term to copy 
6457 06 00			ld b,0 
6459 4d				ld c,l 
645a e1				pop hl 
645b 11 d4 f2			ld de, scratch 
645e ed b0			ldir 
6460			 
6460			 
6460 21 d4 f2			ld hl, scratch 
6463 cd c2 21			call forthparse 
6466 cd 02 22			call forthexec 
6469 cd 19 21			call forthexec_cleanup 
646c			 
646c 3e 78			ld a, display_row_4 
646e 11 25 1b			ld de, endprog 
6471			 
6471 cd e5 0b			call update_display		 
6474			 
6474 3a fa f6			ld a, (os_last_cmd) 
6477 fe 00			cp 0 
6479 20 09			jr nz, .startnxt 
647b cd 83 1d			call next_page_prompt 
647e cd c2 0b		        call clear_display 
6481 cd e5 0b			call update_display		 
6484			 
6484				; move onto next startup line? 
6484			.startnxt: 
6484			 
6484 cd 33 0b			call delay250ms 
6487 e1				pop hl 
6488			 
6488 23				inc hl 
6489 23				inc hl 
648a			 
648a e5				push hl 
648b 5e				ld e, (hl) 
648c 23				inc hl 
648d 56				ld d, (hl) 
648e e1				pop hl 
648f				; TODO replace 0 test 
648f			 
648f eb				ex de, hl 
6490 cd 1f 0e			call ishlzero 
6493			;	ld a,e 
6493			;	add d 
6493			;	cp 0    ; any left to do? 
6493 eb				ex de, hl 
6494 c2 f9 63			jp nz, .start1 
6497 18 01			jr .startupend 
6499			 
6499 e1			.startupend1: pop hl 
649a			.startupend: 
649a			 
649a cd c2 0b			call clear_display 
649d cd e5 0b			call update_display 
64a0 c9				ret 
64a1			 
64a1			 
64a1			; stack over and underflow checks 
64a1			 
64a1			; init the words to detect the under/overflow 
64a1			 
64a1			chk_stk_init: 
64a1				; a vague random number to check so we dont get any "lucky" hits 
64a1 3e 2d			ld a, 45 
64a3 6f				ld l, a 
64a4 00				nop 
64a5 3e 17			ld a, 23 
64a7 67				ld h, a 
64a8			 
64a8 22 bb f2			ld (chk_word), hl     ; the word we need to check against 
64ab			 
64ab			;	ld (chk_stund), hl	; stack points.... 
64ab 22 fd fe			ld (chk_stovr), hl 
64ae 22 ff fa			ld (chk_ret_und), hl 
64b1 22 bd fa			ld (chk_ret_ovr), hl 
64b4 22 3b fa			ld (chk_loop_ovr), hl 
64b7 22 39 f8			ld (chk_data_ovr), hl 
64ba c9				ret 
64bb				 
64bb			check_stacks: 
64bb				; check all stack words 
64bb			 
64bb e5				push hl 
64bc d5				push de 
64bd			 
64bd			;	ld de,(chk_word) 
64bd			;	ld hl, (chk_stund)	; stack points.... 
64bd			;	if DEBUG_STK_FAULT 
64bd			;		DMARK "FAa" 
64bd			;		CALLMONITOR 
64bd			;	endif 
64bd			;	call cmp16 
64bd			;	jp z, .chk_faulta 
64bd			; 
64bd			;	ld de, sfaultsu 
64bd			;	jp .chk_fault 
64bd			 
64bd 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
64c0 ed 5b bb f2		ld de,(chk_word) 
64c4				if DEBUG_STK_FAULT 
64c4					DMARK "FAb" 
64c4					CALLMONITOR 
64c4				endif 
64c4 cd 14 0e			call cmp16 
64c7 28 06			jr z, .chk_fault1 
64c9 11 6a 65			ld de, sfaultso 
64cc c3 1e 65			jp .chk_fault 
64cf			.chk_fault1:  
64cf 2a ff fa			ld hl, (chk_ret_und) 
64d2 ed 5b bb f2		ld de,(chk_word) 
64d6				if DEBUG_STK_FAULT 
64d6					DMARK "FAU" 
64d6					CALLMONITOR 
64d6				endif 
64d6 cd 14 0e			call cmp16 
64d9 ca e2 64			jp z, .chk_fault2 
64dc 11 7a 65			ld de, sfaultru 
64df c3 1e 65			jp .chk_fault 
64e2			.chk_fault2:  
64e2 2a bd fa			ld hl, (chk_ret_ovr) 
64e5 ed 5b bb f2		ld de,(chk_word) 
64e9				if DEBUG_STK_FAULT 
64e9					DMARK "FA1" 
64e9					CALLMONITOR 
64e9				endif 
64e9 cd 14 0e			call cmp16 
64ec ca f5 64			jp z, .chk_fault3 
64ef 11 88 65			ld de, sfaultro 
64f2 c3 1e 65			jp .chk_fault 
64f5			.chk_fault3:  
64f5 2a 3b fa			ld hl, (chk_loop_ovr) 
64f8 ed 5b bb f2		ld de,(chk_word) 
64fc				if DEBUG_STK_FAULT 
64fc					DMARK "FA2" 
64fc					CALLMONITOR 
64fc				endif 
64fc cd 14 0e			call cmp16 
64ff ca 08 65			jp z, .chk_fault4 
6502 11 a2 65			ld de, sfaultlo 
6505 c3 1e 65			jp .chk_fault 
6508			.chk_fault4:  
6508 2a 39 f8			ld hl, (chk_data_ovr) 
650b ed 5b bb f2		ld de,(chk_word) 
650f				if DEBUG_STK_FAULT 
650f					DMARK "FA3" 
650f					CALLMONITOR 
650f				endif 
650f cd 14 0e			call cmp16 
6512 ca 1b 65			jp z, .chk_fault5 
6515 11 bc 65			ld de, sfaultdo 
6518 c3 1e 65			jp .chk_fault 
651b			 
651b			 
651b			.chk_fault5:  
651b d1				pop de 
651c e1				pop hl 
651d			 
651d c9				ret 
651e			 
651e cd c2 0b		.chk_fault: 	call clear_display 
6521 3e 28				ld a, display_row_2 
6523 cd d5 0b				call str_at_display 
6526 11 4c 65				   ld de, .stackfault 
6529 3e 00				ld a, display_row_1 
652b cd d5 0b				call str_at_display 
652e 11 6e fe				    ld de, debug_mark 
6531 3e 11				ld a, display_row_1+17 
6533 cd d5 0b				call str_at_display 
6536 cd e5 0b				call update_display 
6539			 
6539				; prompt before entering montior for investigating issue 
6539			 
6539 3e 78			ld a, display_row_4 
653b 11 25 1b			ld de, endprog 
653e			 
653e cd e5 0b			call update_display		 
6541			 
6541 cd 83 1d			call next_page_prompt 
6544			 
6544 d1				pop de 
6545 e1				pop hl 
6546 cd 79 1b				call monitor 
6549 c3 70 1a				jp warmstart 
654c					;jp 0 
654c					;halt 
654c			 
654c			 
654c			 
654c .. 00		.stackfault: 	db "Stack fault:",0 
6559			 
6559 .. 00		sfaultsu: 	db	"Stack under flow",0 
656a .. 00		sfaultso: 	db	"Stack over flow",0 
657a .. 00		sfaultru:	db "RTS underflow",0 
6588 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
65a2 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
65bc .. 00		sfaultdo:	db "DTS overflow", 0 
65c9			 
65c9			 
65c9			fault_dsp_under: 
65c9 11 db 65			ld de, .dsp_under 
65cc c3 8b 66			jp .show_fault 
65cf			 
65cf			fault_rsp_under: 
65cf 11 e9 65			ld de, .rsp_under 
65d2 c3 8b 66			jp .show_fault 
65d5			fault_loop_under: 
65d5 11 f7 65			ld de, .loop_under 
65d8 c3 8b 66			jp .show_fault 
65db			 
65db .. 00		.dsp_under: db "DSP Underflow",0 
65e9 .. 00		.rsp_under: db "RSP Underflow",0 
65f7 .. 00		.loop_under: db "LOOP Underflow",0 
6606			 
6606			 
6606 d5			type_faultn: 	push de 
6607 e5					push hl 
6608 cd c2 0b				call clear_display 
660b 11 32 66				   ld de, .typefaultn 
660e 3e 00				ld a, display_row_1 
6610 cd d5 0b				call str_at_display 
6613 11 6e fe				    ld de, debug_mark 
6616 3e 11				ld a, display_row_1+17 
6618 cd d5 0b				call str_at_display 
661b cd e5 0b				call update_display 
661e			 
661e				; prompt before entering montior for investigating issue 
661e			 
661e 3e 78			ld a, display_row_4 
6620 11 25 1b			ld de, endprog 
6623			 
6623 cd e5 0b			call update_display		 
6626			 
6626 cd 83 1d			call next_page_prompt 
6629			 
6629 e5					push hl 
662a d5					push de 
662b cd 79 1b				call monitor 
662e c3 70 1a				jp warmstart 
6631 76					halt 
6632			 
6632			 
6632 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6649			 
6649 d5			type_faults: 	push de 
664a e5					push hl 
664b cd c2 0b				call clear_display 
664e 11 74 66				   ld de, .typefaults 
6651 3e 00				ld a, display_row_1 
6653 cd d5 0b				call str_at_display 
6656 11 6e fe				    ld de, debug_mark 
6659 3e 11				ld a, display_row_1+17 
665b cd d5 0b				call str_at_display 
665e cd e5 0b				call update_display 
6661			 
6661				; prompt before entering montior for investigating issue 
6661			 
6661 3e 78			ld a, display_row_4 
6663 11 25 1b			ld de, endprog 
6666			 
6666 cd e5 0b			call update_display		 
6669			 
6669 cd 83 1d			call next_page_prompt 
666c			 
666c e1					pop hl 
666d d1					pop de 
666e cd 79 1b				call monitor 
6671 c3 70 1a				jp warmstart 
6674			 
6674			 
6674 .. 00		.typefaults: db "STR Type Expected TOS!",0 
668b			 
668b			.show_fault: 	 
668b d5					push de 
668c cd c2 0b				call clear_display 
668f d1					pop de 
6690 3e 00				ld a, display_row_1 
6692 cd d5 0b				call str_at_display 
6695 11 6e fe				    ld de, debug_mark 
6698 3e 11				ld a, display_row_1+17 
669a cd d5 0b				call str_at_display 
669d cd e5 0b				call update_display 
66a0			 
66a0				; prompt before entering montior for investigating issue 
66a0			 
66a0 3e 78			ld a, display_row_4 
66a2 11 25 1b			ld de, endprog 
66a5			 
66a5 cd e5 0b			call update_display		 
66a8			 
66a8 cd 83 1d			call next_page_prompt 
66ab			 
66ab e1					pop hl 
66ac d1					pop de 
66ad cd 79 1b				call monitor 
66b0			; do a dump to cli and not warmstart so we preserve all of the uwords.  
66b0			; TODO Make optional fault restart to cli or warm boot? 
66b0					;jp warmstart 
66b0 c3 cb 1a				jp cli 
66b3 76					halt 
66b4			 
66b4			; handle the auto run of code from files in storage 
66b4			 
66b4			 
66b4			if STORAGE_SE 
66b4			 
66b4 .. 00		sprompt3: db "Loading from start-up file?:",0 
66d1 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
66e2			 
66e2			 
66e2			forth_autoload: 
66e2			 
66e2				; load block 0 of store 1 
66e2				 
66e2 3e fe			ld a, $fe      ; bit 0 clear 
66e4 32 3f fb			ld (spi_device), a 
66e7			 
66e7 cd 85 04			call storage_get_block_0 
66ea			 
66ea 3a 7a fb			ld a, (store_page+STORE_0_AUTOFILE) 
66ed			 
66ed fe 00			cp 0 
66ef c8				ret z     ; auto start not enabled 
66f0			 
66f0 cd c2 0b			call clear_display 
66f3			 
66f3				; set bank 
66f3			 
66f3 3a 7c fb				ld a, (store_page+STORE_0_BANKRUN) 
66f6 32 3f fb				ld (spi_device), a 
66f9			 
66f9				; get file id to load from and get the file name to display 
66f9			 
66f9 3a 7d fb				ld a, (store_page+STORE_0_FILERUN) 
66fc			 
66fc 2e 00				ld l, 0 
66fe 67					ld h, a 
66ff 11 59 fb				ld de, store_page 
6702			 
6702					if DEBUG_FORTH_WORDS 
6702						DMARK "ASp" 
6702 f5				push af  
6703 3a 17 67			ld a, (.dmark)  
6706 32 6e fe			ld (debug_mark),a  
6709 3a 18 67			ld a, (.dmark+1)  
670c 32 6f fe			ld (debug_mark+1),a  
670f 3a 19 67			ld a, (.dmark+2)  
6712 32 70 fe			ld (debug_mark+2),a  
6715 18 03			jr .pastdmark  
6717 ..			.dmark: db "ASp"  
671a f1			.pastdmark: pop af  
671b			endm  
# End of macro DMARK
671b						CALLMONITOR 
671b cd 9d 17			call break_point_state  
671e				endm  
# End of macro CALLMONITOR
671e					endif 
671e cd 2d 09				call storage_read 
6721			 
6721					if DEBUG_FORTH_WORDS 
6721						DMARK "ASr" 
6721 f5				push af  
6722 3a 36 67			ld a, (.dmark)  
6725 32 6e fe			ld (debug_mark),a  
6728 3a 37 67			ld a, (.dmark+1)  
672b 32 6f fe			ld (debug_mark+1),a  
672e 3a 38 67			ld a, (.dmark+2)  
6731 32 70 fe			ld (debug_mark+2),a  
6734 18 03			jr .pastdmark  
6736 ..			.dmark: db "ASr"  
6739 f1			.pastdmark: pop af  
673a			endm  
# End of macro DMARK
673a						CALLMONITOR 
673a cd 9d 17			call break_point_state  
673d				endm  
# End of macro CALLMONITOR
673d					endif 
673d			 
673d cd 1f 0e				call ishlzero 
6740 c8					ret z             ; file not found 
6741			 
6741 3e 32				ld a, display_row_2 + 10 
6743 11 5c fb				ld de, store_page+3 
6746 cd d5 0b				call str_at_display 
6749				 
6749			; 
6749			 
6749 3e 05			ld a, display_row_1+5 
674b 11 b4 66			ld de, sprompt3 
674e cd d5 0b			call str_at_display 
6751 3e 5f			ld a, display_row_3+15 
6753 11 d1 66			ld de, sprompt4 
6756 cd d5 0b			call str_at_display 
6759			 
6759 cd e5 0b			call update_display 
675c			 
675c cd 43 6b			call cin_wait 
675f fe 6e			cp 'n' 
6761 c8				ret z 
6762 fe 4e			cp 'N' 
6764 c8				ret z 
6765			 
6765 cd 3f 0b			call delay1s 
6768			 
6768 3a 5b fb			ld a, (store_page+2) 
676b 32 4f fb			ld (store_openmaxext), a    ; save count of ext 
676e 3e 01			ld a, 1  
6770 32 50 fb			ld (store_openext), a    ; save count of ext 
6773			 
6773			.autof:  
6773 6f				ld l , a 
6774				 
6774 3a 59 fb			ld a, (store_page) 
6777 67				ld h, a	 
6778 11 59 fb			ld de, store_page 
677b					if DEBUG_FORTH_WORDS 
677b						DMARK "ASl" 
677b f5				push af  
677c 3a 90 67			ld a, (.dmark)  
677f 32 6e fe			ld (debug_mark),a  
6782 3a 91 67			ld a, (.dmark+1)  
6785 32 6f fe			ld (debug_mark+1),a  
6788 3a 92 67			ld a, (.dmark+2)  
678b 32 70 fe			ld (debug_mark+2),a  
678e 18 03			jr .pastdmark  
6790 ..			.dmark: db "ASl"  
6793 f1			.pastdmark: pop af  
6794			endm  
# End of macro DMARK
6794						CALLMONITOR 
6794 cd 9d 17			call break_point_state  
6797				endm  
# End of macro CALLMONITOR
6797					endif 
6797 cd 2d 09				call storage_read 
679a cd 1f 0e			call ishlzero 
679d c8				ret z 
679e			;	jr z, .autoend 
679e			 
679e					if DEBUG_FORTH_WORDS 
679e						DMARK "ASc" 
679e f5				push af  
679f 3a b3 67			ld a, (.dmark)  
67a2 32 6e fe			ld (debug_mark),a  
67a5 3a b4 67			ld a, (.dmark+1)  
67a8 32 6f fe			ld (debug_mark+1),a  
67ab 3a b5 67			ld a, (.dmark+2)  
67ae 32 70 fe			ld (debug_mark+2),a  
67b1 18 03			jr .pastdmark  
67b3 ..			.dmark: db "ASc"  
67b6 f1			.pastdmark: pop af  
67b7			endm  
# End of macro DMARK
67b7						CALLMONITOR 
67b7 cd 9d 17			call break_point_state  
67ba				endm  
# End of macro CALLMONITOR
67ba					endif 
67ba 11 5b fb			ld de, store_page+2 
67bd 3e 78			ld a, display_row_4 
67bf cd d5 0b			call str_at_display 
67c2			 
67c2 cd e5 0b			call update_display 
67c5 cd 33 0b			call delay250ms 
67c8			 
67c8			 
67c8			 
67c8 21 5b fb			ld hl, store_page+2 
67cb cd c2 21			call forthparse 
67ce cd 02 22			call forthexec 
67d1 cd 19 21			call forthexec_cleanup 
67d4			 
67d4				 
67d4 3a 50 fb			ld a, (store_openext) 
67d7 3c				inc a 
67d8 32 50 fb			ld (store_openext), a    ; save count of ext 
67db			 
67db 18 96			jr .autof 
67dd			;.autofdone: 
67dd			; 
67dd			;		if DEBUG_FORTH_WORDS 
67dd			;			DMARK "ASx" 
67dd			;			CALLMONITOR 
67dd			;		endif 
67dd			;;	call clear_display 
67dd			;	ret 
67dd			 
67dd			 
67dd			 
67dd			endif 
67dd			 
67dd			 
67dd			; eof 
# End of file forth_kernel.asm
67dd			;include "nascombasic.asm" 
67dd			 
67dd			 
67dd			; find out where the code ends if loaded into RAM (for SC114) 
67dd			;endofcode:  
67dd			;	nop 
67dd			 
67dd			 
67dd			; eof 
67dd			 
# End of file main.asm
67dd			include "firmware_lcd_4x40.asm" 
67dd			; **********************************************************************  
67dd			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
67dd			; **********************************************************************  
67dd			;  
67dd			; **  Written as a Small Computer Monitor App  
67dd			; **  www.scc.me.uk  
67dd			;  
67dd			; History  
67dd			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
67dd			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
67dd			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
67dd			;  
67dd			; **********************************************************************  
67dd			;  
67dd			; This program is an example of one of the methods of interfacing an   
67dd			; alphanumeric LCD module.   
67dd			;  
67dd			; In this example the display is connected to either a Z80 PIO or a   
67dd			; simple 8-bit output port.   
67dd			;  
67dd			; This interfacing method uses 4-bit data mode and uses time delays  
67dd			; rather than polling the display's ready status. As a result the   
67dd			; interface only requires 6 simple output lines:  
67dd			;   Output bit 0 = not used  
67dd			;   Output bit 1 = not used  
67dd			;   Output bit 2 = RS         High = data, Low = instruction  
67dd			;   Output bit 3 = E          Active high  
67dd			;   Output bit 4 = DB4  
67dd			;   Output bit 5 = DB5  
67dd			;   Output bit 6 = DB6  
67dd			;   Output bit 7 = DB7  
67dd			; Display's R/W is connected to 0v so it is always in write mode  
67dd			;  
67dd			; This set up should work with any system supporting the RC2014 bus  
67dd			  
67dd			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
67dd			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
67dd			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
67dd			;  
67dd			; **********************************************************************  
67dd			  
67dd			; Additonal for 4x40. E1 and E2 instead of just E   
67dd			; TODO swipe vidout signal on port a to activate E2  
67dd			  
67dd			; **********************************************************************  
67dd			; **  Constants  
67dd			; **********************************************************************  
67dd			; LCD constants required by LCD support module  
67dd			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
67dd			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
67dd			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
67dd			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
67dd			; TODO Decide which E is being set  
67dd			kLCDWidth:  EQU display_cols             ;Width in characters  
67dd			  
67dd			; **********************************************************************  
67dd			; **  Code library usage  
67dd			; **********************************************************************  
67dd			  
67dd			; send character to current cursor position  
67dd			; wraps and/or scrolls screen automatically  
67dd			  
67dd			  
67dd			  
67dd			lcd_init:  
67dd			  
67dd			; SCMonAPI functions used  
67dd			  
67dd			; Alphanumeric LCD functions used  
67dd			; no need to specify specific functions for this module  
67dd			  
67dd 3e cf		            LD   A, 11001111b  
67df d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
67e1 3e 00		            LD   A, 00000000b  
67e3 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
67e5			  
67e5			; Initialise alphanumeric LCD module  
67e5 3e 00				ld a, 0  
67e7 32 ce fb				ld (display_lcde1e2), a  
67ea cd 6b 68		            CALL fLCD_Init      ;Initialise LCD module  
67ed 3e 01				ld a, 1  
67ef 32 ce fb				ld (display_lcde1e2), a  
67f2 cd 6b 68		            CALL fLCD_Init      ;Initialise LCD module  
67f5			  
67f5 c9				ret  
67f6			  
67f6			;  
67f6			;;  
67f6			; lcd functions  
67f6			;  
67f6			;  
67f6			  
67f6			; what is at cursor position   
67f6			  
67f6			;get_cursor:	ld de, (cursor_row)   ;  row + col  
67f6			;		call curptr  
67f6			;		ret  
67f6			  
67f6			  
67f6			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
67f6			  
67f6			curptr:  
67f6 c5				push bc  
67f7 21 b4 fd			ld hl, display_fb0  
67fa			cpr:	  
67fa				; loop for cursor whole row  
67fa 0e 28			ld c, display_cols  
67fc 23			cpr1:	inc hl  
67fd 0d				dec c  
67fe 20 fc			jr nz, cpr1  
6800 05				dec b  
6801 20 f7			jr nz, cpr  
6803			  
6803				; add col	  
6803			  
6803 23			cpr2:	inc hl  
6804 1d				dec e  
6805 20 fc			jr nz, cpr2  
6807			  
6807 c1				pop bc  
6808 c9				ret  
6809				  
6809			  
6809			  
6809			  
6809			  
6809			; write the frame buffer given in hl to hardware   
6809 22 cc fb		write_display: ld (display_write_tmp), hl 	   
680c 3e 00			ld a, kLCD_Line1  
680e cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6811 06 28			ld b, display_cols  
6813 ed 5b cc fb		ld de, (display_write_tmp)  
6817 cd 63 68			call write_len_string  
681a				  
681a				  
681a 2a cc fb			ld hl, (display_write_tmp)  
681d 11 28 00			ld de, display_cols  
6820 19				add hl,de  
6821 22 cc fb			ld (display_write_tmp),hl  
6824			  
6824				  
6824 3e 28			ld a, kLCD_Line2  
6826 cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6829 06 28			ld b, display_cols  
682b ed 5b cc fb		ld de, (display_write_tmp)  
682f cd 63 68			call write_len_string  
6832				  
6832 2a cc fb			ld hl, (display_write_tmp)  
6835 11 28 00			ld de, display_cols  
6838 19				add hl,de  
6839 22 cc fb			ld (display_write_tmp),hl  
683c			  
683c				  
683c 3e 50			ld a, kLCD_Line3  
683e cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6841 06 28			ld b, display_cols  
6843 ed 5b cc fb		ld de, (display_write_tmp)  
6847 cd 63 68			call write_len_string  
684a				  
684a 2a cc fb			ld hl, (display_write_tmp)  
684d 11 28 00			ld de, display_cols  
6850 19				add hl,de  
6851 22 cc fb			ld (display_write_tmp),hl  
6854			  
6854				  
6854 3e 78			ld a, kLCD_Line4  
6856 cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6859 06 28			ld b, display_cols  
685b ed 5b cc fb		ld de, (display_write_tmp)  
685f cd 63 68			call write_len_string  
6862 c9					ret  
6863				  
6863				; write out a fixed length string given in b from de  
6863			  
6863 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6864 cd d0 68		            CALL fLCD_Data      ;Write character to display  
6867 13				inc de  
6868 10 f9			djnz write_len_string  
686a c9				ret  
686b			  
686b			; Some other things to do  
686b			;            LD   A, kLCD_Clear ;Display clear  
686b			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
686b			;            LD   A, kLCD_Under ;Display on with underscore cursor  
686b			;            LD   A, kLCD_On     ;Display on with no cursor  
686b			;            ;LD   A, kLCD_Off   ;Display off  
686b			;            CALL fLCD_Inst      ;Send instruction to display  
686b			;  
686b			;  
686b			;            halt  
686b			;  
686b			;  
686b			;MsgHello:   DB  "Hello World!",0  
686b			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
686b			  
686b			; Custom characters 5 pixels wide by 8 pixels high  
686b			; Up to 8 custom characters can be defined  
686b			;BitMaps:      
686b			;; Character 0x00 = Battery icon  
686b			;            DB  01110b  
686b			;            DB  11011b  
686b			;            DB  10001b  
686b			;            DB  10001b  
686b			;            DB  11111b  
686b			;            DB  11111b  
686b			;            DB  11111b  
686b			;            DB  11111b  
686b			;; Character 0x01 = Bluetooth icon  
686b			;            DB  01100b  
686b			;            DB  01010b  
686b			;            DB  11100b  
686b			;            DB  01000b  
686b			;            DB  11100b  
686b			;            DB  01010b  
686b			;            DB  01100b  
686b			;            DB  00000b  
686b			;  
686b			  
686b			  
686b			; **********************************************************************  
686b			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
686b			; **********************************************************************  
686b			;  
686b			; **  Written as a Small Computer Monitor App   
686b			; **  Version 0.1 SCC 2018-05-16  
686b			; **  www.scc.me.uk  
686b			;  
686b			; **********************************************************************  
686b			;  
686b			; This module provides support for alphanumeric LCD modules using with  
686b			; *  HD44780 (or compatible) controller  
686b			; *  5 x 7 pixel fonts  
686b			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
686b			; *  Interface via six digital outputs to the display (see below)  
686b			;  
686b			; LCD module pinout:  
686b			;   1  Vss   0v supply  
686b			;   2  Vdd   5v supply  
686b			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
686b			;   4  RS    High = data, Low = instruction  
686b			;   5  R/W   High = Read, Low = Write  
686b			;   6  E     Enable signal (active high)  
686b			;   7  DB0   Data bit 0  
686b			;   8  DB1   Data bit 1  
686b			;   9  DB2   Data bit 2  
686b			;  10  DB3   Data bit 3  
686b			;  11  DB4   Data bit 4  
686b			;  12  DB5   Data bit 5  
686b			;  13  DB6   Data bit 6  
686b			;  14  DB7   Data bit 7  
686b			;  15  A     Backlight anode (+)  
686b			;  16  K     Backlight cathode (-)  
686b			;  
686b			; This interfacing method uses 4-bit data mode and uses time delays  
686b			; rather than polling the display's ready status. As a result the   
686b			; interface only requires 6 simple output lines:  
686b			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
686b			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
686b			;   LCD DB4 = Microcomputer output port bit 4  
686b			;   LCD DB5 = Microcomputer output port bit 5  
686b			;   LCD DB6 = Microcomputer output port bit 6  
686b			;   LCD DB7 = Microcomputer output port bit 7  
686b			; Display's R/W is connected to 0v so it is always in write mode  
686b			; All 6 connections must be on the same port address <kLCDPrt>  
686b			; This method also allows a decent length of cable from micro to LCD  
686b			;  
686b			; **********************************************************************  
686b			;  
686b			; To include the code for any given function provided by this module,   
686b			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
686b			; the parent source file.  
686b			; For example:  #REQUIRES   uHexPrefix  
686b			;  
686b			; Also #INCLUDE this file at some point after the #REQUIRES statements  
686b			; in the parent source file.  
686b			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
686b			;  
686b			; These are the function names provided by this module:  
686b			; fLCD_Init                     ;Initialise LCD  
686b			; fLCD_Inst                     ;Send instruction to LCD  
686b			; fLCD_Data                     ;Send data byte to LCD  
686b			; fLCD_Pos                      ;Position cursor  
686b			; fLCD_Str                      ;Display string  
686b			; fLCD_Def                      ;Define custom character  
686b			;  
686b			; **********************************************************************  
686b			;  
686b			; Requires SCMonAPI.asm to also be included in the project  
686b			;  
686b			  
686b			  
686b			; **********************************************************************  
686b			; **  Constants  
686b			; **********************************************************************  
686b			  
686b			; Constants that must be defined externally  
686b			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
686b			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
686b			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
686b			;kLCDWidth: EQU 20             ;Width in characters  
686b			  
686b			; general line offsets in any frame buffer  
686b			  
686b			  
686b			display_row_1: equ 0  
686b			display_row_2: equ display_row_1+display_cols  
686b			display_row_3: equ display_row_2 + display_cols  
686b			display_row_4: equ display_row_3 + display_cols  
686b			;display_row_4_eol:   
686b			  
686b			  
686b			; Cursor position values for the start of each line  
686b			  
686b			; E  
686b			kLCD_Line1: EQU 0x00   
686b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
686b			; E1  
686b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
686b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
686b			  
686b			; Instructions to send as A register to fLCD_Inst  
686b			kLCD_Clear: EQU 00000001b     ;LCD clear  
686b			kLCD_Off:   EQU 00001000b     ;LCD off  
686b			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
686b			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
686b			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
686b			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
686b			  
686b			; Constants used by this code module  
686b			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
686b			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
686b			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
686b			  
686b			  
686b			  
686b			; **********************************************************************  
686b			; **  LCD support functions  
686b			; **********************************************************************  
686b			  
686b			; Initialise alphanumeric LCD module  
686b			; LCD control register codes:  
686b			;   DL   0 = 4-bit mode        1 = 8-bit mode  
686b			;   N    0 = 1-line mode       1 = 2-line mode  
686b			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
686b			;   D    0 = Display off       1 = Display on  
686b			;   C    0 = Cursor off        1 = Cursor on  
686b			;   B    0 = Blinking off      1 = Blinking on  
686b			;   ID   0 = Decrement mode    1 = Increment mode  
686b			;   SH   0 = Entire shift off  1 = Entire shift on  
686b 3e 28		fLCD_Init:  LD   A, 40  
686d cd 92 69		            CALL LCDDelay       ;Delay 40ms after power up  
6870			; For reliable reset set 8-bit mode - 3 times  
6870 cd 62 69		            CALL WrFn8bit       ;Function = 8-bit mode  
6873 cd 62 69		            CALL WrFn8bit       ;Function = 8-bit mode  
6876 cd 62 69		            CALL WrFn8bit       ;Function = 8-bit mode  
6879			; Set 4-bit mode  
6879 cd 5e 69		            CALL WrFn4bit       ;Function = 4-bit mode  
687c cd 90 69		            CALL LCDDelay1      ;Delay 37 us or more  
687f			; Function set  
687f 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6881 cd 94 68		            CALL fLCD_Inst      ;2 line, display on  
6884			; Display On/Off control  
6884 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6886 cd 94 68		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6889			; Display Clear  
6889 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
688b cd 94 68		            CALL fLCD_Inst      ;Clear display  
688e			; Entry mode  
688e 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6890 cd 94 68		            CALL fLCD_Inst      ;Increment mode, shift off  
6893			; Display module now initialised  
6893 c9			            RET  
6894			; ok to here  
6894			  
6894			; Write instruction to LCD  
6894			;   On entry: A = Instruction byte to be written  
6894			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6894 f5			fLCD_Inst:  PUSH AF  
6895 f5			            PUSH AF  
6896 cd a8 68		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6899 f1			            POP  AF  
689a 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
689b 17			            RLA  
689c 17			            RLA  
689d 17			            RLA  
689e cd a8 68		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
68a1 3e 02		            LD   A, 2  
68a3 cd 92 69		            CALL LCDDelay       ;Delay 2 ms to complete   
68a6 f1			            POP  AF  
68a7 c9			            RET  
68a8			Wr4bits:   
68a8 f5					push af  
68a9 3a ce fb				ld a, (display_lcde1e2)  
68ac fe 00				cp 0     ; e  
68ae 20 10				jr nz, .wea2	  
68b0 f1					pop af  
68b1 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
68b3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68b5 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
68b7 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
68b9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
68bb cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
68bd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68bf c9			            RET  
68c0 f1			.wea2:		pop af  
68c1 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
68c3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68c5 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
68c7 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
68c9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
68cb cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
68cd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68cf c9			            RET  
68d0			  
68d0			  
68d0			; Write data to LCD  
68d0			;   On entry: A = Data byte to be written  
68d0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
68d0 f5			fLCD_Data:  PUSH AF  
68d1 f5			            PUSH AF  
68d2 cd e4 68		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
68d5 f1			            POP  AF  
68d6 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
68d7 17			            RLA  
68d8 17			            RLA  
68d9 17			            RLA  
68da cd e4 68		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
68dd 3e 96		            LD   A, 150  
68df 3d			Wait:      DEC  A              ;Wait a while to allow data   
68e0 20 fd		            JR   NZ, Wait      ;  write to complete  
68e2 f1			            POP  AF  
68e3 c9			            RET  
68e4			Wr4bitsa:     
68e4 f5					push af  
68e5 3a ce fb				ld a, (display_lcde1e2)  
68e8 fe 00				cp 0     ; e1  
68ea 20 16				jr nz, .we2	  
68ec f1					pop af  
68ed e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
68ef cb d7		            SET  kLCDBitRS, A  
68f1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
68f3 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
68f5 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
68f7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
68f9 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
68fb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
68fd cb 97		            RES  kLCDBitRS, A  
68ff d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6901 c9			            RET  
6902 f1			.we2:		pop af  
6903 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6905 cb d7		            SET  kLCDBitRS, A  
6907 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6909 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
690b cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
690d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
690f cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6911 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6913 cb 97		            RES  kLCDBitRS, A  
6915 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6917 c9			            RET  
6918			  
6918			  
6918			; Position cursor to specified location  
6918			;   On entry: A = Cursor position  
6918			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6918 f5			fLCD_Pos:   PUSH AF  
6919					; at this point set the E1 or E2 flag depending on position  
6919			  
6919 c5					push bc  
691a			;		push af  
691a 06 00				ld b, 0  
691c 4f					ld c, a  
691d 3e 4f				ld a, kLCD_Line3-1  
691f b7			 		or a      ;clear carry flag  
6920 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6921 38 04				jr c, .pe1  
6923			  
6923					; E selection  
6923 cb 80				res 0, b         ; bit 0 unset e  
6925			;		pop af    ; before line 3 so recover orig pos  
6925			;		ld c, a    ; save for poking back  
6925 18 06				jr .peset	          
6927			.pe1:          	; E2 selection  
6927 cb c0				set 0, b         ; bit 0 set e1  
6929 79					ld a, c  
692a de 4f				sbc a, kLCD_Line3-1  
692c 4f					ld c, a	         ; save caculated offset  
692d			;		pop af     ; bin this original value now we have calculated form  
692d			  
692d			.peset:		; set bit  
692d 78					ld a, b  
692e 32 ce fb				ld (display_lcde1e2), a 	  
6931 79					ld a, c  
6932 c1					pop bc  
6933			  
6933 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6935 cd 94 68		            CALL fLCD_Inst      ;Write instruction to LCD  
6938 f1			            POP  AF  
6939 c9			            RET  
693a			  
693a			  
693a			; Output text string to LCD  
693a			;   On entry: DE = Pointer to null terminated text string  
693a			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
693a 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
693b b7			            OR   A              ;Null terminator?  
693c c8			            RET  Z              ;Yes, so finished  
693d cd d0 68		            CALL fLCD_Data      ;Write character to display  
6940 13			            INC  DE             ;Point to next character  
6941 18 f7		            JR   fLCD_Str       ;Repeat  
6943 c9					ret  
6944			  
6944			; Define custom character  
6944			;   On entry: A = Character number (0 to 7)  
6944			;             DE = Pointer to character bitmap data  
6944			;   On exit:  A = Next character number  
6944			;             DE = Next location following bitmap  
6944			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6944			; Character is   
6944 c5			fLCD_Def:   PUSH BC  
6945 f5			            PUSH AF  
6946 07			            RLCA                ;Calculate location  
6947 07			            RLCA                ;  for bitmap data  
6948 07			            RLCA                ;  = 8 x CharacterNumber  
6949 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
694b cd 94 68		            CALL fLCD_Inst      ;Write instruction to LCD  
694e 06 00		            LD   B, 0  
6950 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6951 cd d0 68		            CALL fLCD_Data      ;Write byte to display  
6954 13			            INC  DE             ;Point to next byte  
6955 04			            INC  B              ;Count bytes  
6956 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6958 28 f6		            JR   Z, Loop       ;No, so repeat  
695a f1			            POP  AF  
695b 3c			            INC  A              ;Increment character number  
695c c1			            POP  BC  
695d c9			            RET  
695e			  
695e			  
695e			; **********************************************************************  
695e			; **  Private functions  
695e			; **********************************************************************  
695e			  
695e			; Write function to LCD  
695e			;   On entry: A = Function byte to be written  
695e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
695e 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6960 18 02		            JR   WrFunc  
6962 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6964 f5			WrFunc:     PUSH AF  
6965 f5					push af  
6966 3a ce fb				ld a, (display_lcde1e2)  
6969 fe 00				cp 0     ; e1  
696b 20 0f				jr nz, .wfea2	  
696d f1					pop af  
696e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6970 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6972 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6974 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6976 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6978 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
697a 18 0d			jr .wfskip  
697c f1			.wfea2:		pop af  
697d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
697f cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6981 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6983 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6985 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6987 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6989 3e 05		.wfskip:            LD  A, 5  
698b cd 92 69		            CALL LCDDelay       ;Delay 5 ms to complete  
698e f1			            POP  AF  
698f c9			            RET  
6990			  
6990			  
6990			; Delay in milliseconds  
6990			;   On entry: A = Number of milliseconds delay  
6990			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6990 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6992 d5			LCDDelay:   PUSH DE  
6993 5f			            LD   E, A           ;Delay by 'A' ms  
6994 16 00		            LD   D, 0  
6996 cd 24 0b		            CALL aDelayInMS  
6999 d1			            POP  DE  
699a c9			            RET  
699b			  
699b			  
699b			testlcd:  
699b 3e 00			ld a, kLCD_Line1  
699d cd 18 69			call fLCD_Pos  
69a0 06 28			ld b, 40  
69a2 11 d0 69			ld de, .ttext1  
69a5 cd 63 68			call write_len_string  
69a8			  
69a8 3e 28			ld a, kLCD_Line2  
69aa cd 18 69			call fLCD_Pos  
69ad 06 28			ld b, 40  
69af 11 f9 69			ld de, .ttext2  
69b2 cd 63 68			call write_len_string  
69b5 3e 50			ld a, kLCD_Line3  
69b7 cd 18 69			call fLCD_Pos  
69ba 06 28			ld b, 40  
69bc 11 22 6a			ld de, .ttext3  
69bf cd 63 68			call write_len_string  
69c2 3e 78			ld a, kLCD_Line4  
69c4 cd 18 69			call fLCD_Pos  
69c7 06 28			ld b, 40  
69c9 11 4b 6a			ld de, .ttext4  
69cc cd 63 68			call write_len_string  
69cf			  
69cf 76				halt  
69d0			  
69d0			  
69d0 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
69f9 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6a22 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6a4b .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6a74			   
6a74			  
6a74			  
6a74			; eof  
6a74			  
# End of file firmware_lcd_4x40.asm
6a74			;include "firmware_lcd_4x20.asm" 
6a74			include "firmware_key_5x10.asm" 
6a74			; 5 x 10 decade counter scanner  
6a74			  
6a74			  
6a74			; TODO do cursor shape change for shift keys  
6a74			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6a74			  
6a74			  
6a74			; bit mask for each scan column and row for teing the matrix  
6a74			  
6a74			  
6a74			key_init:  
6a74			  
6a74			; SCMonAPI functions used  
6a74			  
6a74			; Alphanumeric LCD functions used  
6a74			; no need to specify specific functions for this module  
6a74			  
6a74			  
6a74 3e cf		            LD   A, 11001111b  
6a76 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6a78			;            LD   A, 00000000b  
6a78 3e 1f		            LD   A, 00011111b  
6a7a d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6a7c			  
6a7c			  
6a7c				; TODO Configure cursor shapes  
6a7c			  
6a7c				; Load cursor shapes   
6a7c 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6a7e 11 8e 6a		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6a81 06 02		            LD   B, 2           ;Number of characters to define  
6a83 cd 44 69		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6a86 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6a88			  
6a88 3e 01				ld a, 1  
6a8a 32 c7 fb			ld (cursor_shape),a  
6a8d c9				ret  
6a8e			  
6a8e			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6a8e			; Up to 8 custom characters can be defined  
6a8e			.cursor_shapes:      
6a8e			;; Character 0x00 = Normal  
6a8e 1f			            DB  11111b  
6a8f 1f			            DB  11111b  
6a90 1f			            DB  11111b  
6a91 1f			            DB  11111b  
6a92 1f			            DB  11111b  
6a93 1f			            DB  11111b  
6a94 1f			            DB  11111b  
6a95 1f			            DB  11111b  
6a96			;; Character 0x01 = Modifier  
6a96 1f			            DB  11111b  
6a97 1b			            DB  11011b  
6a98 1b			            DB  11011b  
6a99 1b			            DB  11011b  
6a9a 1b			            DB  11011b  
6a9b 1f			            DB  11111b  
6a9c 1b			            DB  11011b  
6a9d 1f			            DB  11111b  
6a9e			  
6a9e			  
6a9e			  
6a9e			  
6a9e			; Display custom character 0  
6a9e			;            LD   A, kLCD_Line1+14  
6a9e			;            CALL fLCD_Pos       ;Position cursor to location in A  
6a9e			;            LD   A, 0  
6a9e			;            CALL fLCD_Data      ;Write character in A at cursor  
6a9e			  
6a9e			; Display custom character 1  
6a9e			;            LD   A, kLCD_Line2+14  
6a9e			;            CALL fLCD_Pos      ;Position cursor to location in A  
6a9e			;            LD   A, 1  
6a9e			;            CALL fLCD_Data     ;Write character in A at cursor  
6a9e			  
6a9e			; keyboard scanning   
6a9e			  
6a9e			; character in from keyboard  
6a9e			  
6a9e			; mapping for the pcb layout  
6a9e			  
6a9e			.matrix_to_char:  
6a9e .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6aa9 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6ab4 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6abf 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6aca .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6ad5			.matrix_to_shift:  
6ad5			  
6ad5 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6ae0 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6aeb 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6af6 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6b01 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6b0c			  
6b0c			.matrix_to_symbolshift:  
6b0c			  
6b0c fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6b17 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6b22 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6b2d			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6b2d 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6b38 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6b43			  
6b43			  
6b43			  
6b43			; mapping for a simple straight through breadboard layout  
6b43			  
6b43			;.matrix_to_char:  
6b43			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6b43			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6b43			;		db "asdfghjkl",KEY_CR,0  
6b43			;		db "qwertyuiop",0  
6b43			;		 db "1234567890",0  
6b43			;.matrix_to_shift:  
6b43			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6b43			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6b43			;		db "ASDFGHJKL",KEY_CR,0  
6b43			;		db "QWERTYUIOP",0  
6b43			;		 db "!",'"',"#$%^&*()",0  
6b43			;.matrix_to_symbolshift:  
6b43			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6b43			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6b43			;		db "_?*fghjk=",KEY_CR,0  
6b43			;		db "-/+*[]{}@#",0  
6b43			;		 db "1234567890",0  
6b43			  
6b43			;.matrix_to_char: db "D#0*C987B654A321"  
6b43			  
6b43			  
6b43				  
6b43			  
6b43			; add cin and cin_wait  
6b43			  
6b43 cd 54 6b		cin_wait: 	call cin  
6b46						if DEBUG_KEYCINWAIT  
6b46							push af  
6b46							  
6b46							ld hl,key_repeat_ct  
6b46							ld (hl),a  
6b46							inc hl  
6b46							call hexout  
6b46							ld hl,key_repeat_ct+3  
6b46							ld a,0  
6b46							ld (hl),a  
6b46			  
6b46							    LD   A, kLCD_Line1+11  
6b46							    CALL fLCD_Pos       ;Position cursor to location in A  
6b46							    LD   DE, key_repeat_ct  
6b46							    ;LD   DE, MsgHello  
6b46							    CALL fLCD_Str       ;Display string pointed to by DE  
6b46			  
6b46			  
6b46			  
6b46							pop af  
6b46						endif  
6b46 fe 00			cp 0  
6b48 28 f9			jr z, cin_wait   ; block until key press  
6b4a			  
6b4a							if DEBUG_KEYCINWAIT  
6b4a								push af  
6b4a			  
6b4a								ld a, 'A'	  
6b4a								ld hl,key_repeat_ct  
6b4a								ld (hl),a  
6b4a								inc hl  
6b4a								ld a,0  
6b4a								ld (hl),a  
6b4a			  
6b4a								    LD   A, kLCD_Line2+11  
6b4a								    CALL fLCD_Pos       ;Position cursor to location in A  
6b4a								    LD   DE, key_repeat_ct  
6b4a								    ;LD   DE, MsgHello  
6b4a								    CALL fLCD_Str       ;Display string pointed to by DE  
6b4a			  
6b4a							call delay500ms  
6b4a			  
6b4a								pop af  
6b4a							endif  
6b4a f5				push af   ; save key pressed  
6b4b			  
6b4b			.cin_wait1:	  
6b4b							if DEBUG_KEYCINWAIT  
6b4b								push af  
6b4b			  
6b4b								ld a, 'b'	  
6b4b								ld hl,key_repeat_ct  
6b4b								ld (hl),a  
6b4b								inc hl  
6b4b								ld a,0  
6b4b								ld (hl),a  
6b4b			  
6b4b								    LD   A, kLCD_Line2+11  
6b4b								    CALL fLCD_Pos       ;Position cursor to location in A  
6b4b								    LD   DE, key_repeat_ct  
6b4b								    ;LD   DE, MsgHello  
6b4b								    CALL fLCD_Str       ;Display string pointed to by DE  
6b4b			  
6b4b			  
6b4b							call delay500ms  
6b4b			  
6b4b								pop af  
6b4b							endif  
6b4b			  
6b4b cd 54 6b		call cin  
6b4e fe 00			cp 0  
6b50 20 f9			jr nz, .cin_wait1  	; wait for key release  
6b52			if DEBUG_KEYCINWAIT  
6b52				push af  
6b52			  
6b52				ld a, '3'	  
6b52				ld hl,key_repeat_ct  
6b52				ld (hl),a  
6b52				inc hl  
6b52				ld a,0  
6b52				ld (hl),a  
6b52			  
6b52			            LD   A, kLCD_Line2+11  
6b52			            CALL fLCD_Pos       ;Position cursor to location in A  
6b52			            LD   DE, key_repeat_ct  
6b52			            ;LD   DE, MsgHello  
6b52			            CALL fLCD_Str       ;Display string pointed to by DE  
6b52			  
6b52			  
6b52			call delay500ms  
6b52			  
6b52				pop af  
6b52			endif  
6b52			  
6b52 f1				pop af   ; get key  
6b53 c9				ret  
6b54			  
6b54			  
6b54 cd 68 6b		cin: 	call .mtoc  
6b57			  
6b57			if DEBUG_KEYCIN  
6b57				push af  
6b57				  
6b57				ld hl,key_repeat_ct  
6b57				ld (hl),a  
6b57				inc hl  
6b57				call hexout  
6b57				ld hl,key_repeat_ct+3  
6b57				ld a,0  
6b57				ld (hl),a  
6b57			  
6b57			            LD   A, kLCD_Line3+15  
6b57			            CALL fLCD_Pos       ;Position cursor to location in A  
6b57			            LD   DE, key_repeat_ct  
6b57			            ;LD   DE, MsgHello  
6b57			            CALL fLCD_Str       ;Display string pointed to by DE  
6b57			  
6b57			  
6b57			call delay500ms  
6b57			  
6b57				pop af  
6b57			endif  
6b57			  
6b57			  
6b57				; no key held  
6b57 fe 00			cp 0  
6b59 c8				ret z  
6b5a			  
6b5a			if DEBUG_KEYCIN  
6b5a				push af  
6b5a			  
6b5a				ld a, '1'	  
6b5a				ld hl,key_repeat_ct  
6b5a				ld (hl),a  
6b5a				inc hl  
6b5a				ld a,0  
6b5a				ld (hl),a  
6b5a			  
6b5a			            LD   A, kLCD_Line4+15  
6b5a			            CALL fLCD_Pos       ;Position cursor to location in A  
6b5a			            LD   DE, key_repeat_ct  
6b5a			            ;LD   DE, MsgHello  
6b5a			            CALL fLCD_Str       ;Display string pointed to by DE  
6b5a			  
6b5a			  
6b5a			call delay500ms  
6b5a			  
6b5a				pop af  
6b5a			endif  
6b5a			  
6b5a				; stop key bounce  
6b5a			  
6b5a 32 88 fe			ld (key_held),a		 ; save it  
6b5d 47				ld b, a  
6b5e			  
6b5e c5			.cina1:	push bc  
6b5f			if DEBUG_KEYCIN  
6b5f				push af  
6b5f			  
6b5f				ld hl,key_repeat_ct  
6b5f				inc hl  
6b5f				call hexout  
6b5f				ld hl,key_repeat_ct+3  
6b5f				ld a,0  
6b5f				ld (hl),a  
6b5f				ld hl,key_repeat_ct  
6b5f				ld a, '2'	  
6b5f				ld (hl),a  
6b5f			  
6b5f			            LD   A, kLCD_Line4+15  
6b5f			            CALL fLCD_Pos       ;Position cursor to location in A  
6b5f			            LD   DE, key_repeat_ct  
6b5f			            ;LD   DE, MsgHello  
6b5f			            CALL fLCD_Str       ;Display string pointed to by DE  
6b5f			  
6b5f				pop af  
6b5f			endif  
6b5f cd 68 6b			call .mtoc  
6b62 c1				pop bc  
6b63 b8				cp b  
6b64 28 f8			jr z, .cina1  
6b66 78				ld a,b		  
6b67			if DEBUG_KEYCIN  
6b67				push af  
6b67			  
6b67				ld hl,key_repeat_ct  
6b67				inc hl  
6b67				call hexout  
6b67				ld hl,key_repeat_ct+3  
6b67				ld a,0  
6b67				ld (hl),a  
6b67				ld hl,key_repeat_ct  
6b67				ld a, '3'	  
6b67				ld (hl),a  
6b67			  
6b67			            LD   A, kLCD_Line4+15  
6b67			            CALL fLCD_Pos       ;Position cursor to location in A  
6b67			            LD   DE, key_repeat_ct  
6b67			            ;LD   DE, MsgHello  
6b67			            CALL fLCD_Str       ;Display string pointed to by DE  
6b67			  
6b67				pop af  
6b67			endif  
6b67 c9				ret  
6b68			  
6b68			; detect keyboard modifier key press and apply new overlay to the face key held  
6b68			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6b68			  
6b68			;.cin_map_modifier:   
6b68			;	ld a, (hl)  
6b68			;	and 255  
6b68			;	ret NZ		; modifier key not flagged  
6b68			;  
6b68			;	; get key face  
6b68			;  
6b68			;	ld b,(key_face_held)  
6b68			;  
6b68			;	ld b, key_cols * key_rows  
6b68			;  
6b68			;	push de  
6b68			;	pop hl  
6b68			;  
6b68			;.mmod1: ld a,(hl)   ; get map test  
6b68			;	cp b  
6b68			;	jr z, .mmod2  
6b68			;  
6b68			;  
6b68			;  
6b68			;.mmod2: inc hl    ;   
6b68			;  
6b68			;	  
6b68			;  
6b68			;	  
6b68			;  
6b68			;	ld hl,key_actual_pressed  
6b68			;	ld (hl),a,  
6b68			;	ret  
6b68			  
6b68			; map matrix key held to char on face of key  
6b68			  
6b68			.mtoc:  
6b68			  
6b68			; test decade counter strobes  
6b68			  
6b68			;.decadetest1:  
6b68			  
6b68			; reset counter  
6b68			;ld a, 128  
6b68			;out (portbdata),a  
6b68			  
6b68			  
6b68			;ld b, 5  
6b68			;.dec1:  
6b68			;ld a, 0  
6b68			;out (portbdata),a  
6b68			;call delay1s  
6b68			  
6b68			;ld a, 32  
6b68			;out (portbdata),a  
6b68			;call delay1s  
6b68			;call delay1s  
6b68			;call delay1s  
6b68			;  
6b68			;ld a, 64+32  
6b68			;out (portbdata),a  
6b68			;call delay1s  
6b68			;;djnz .dec1  
6b68			;  
6b68			;jp .decadetest1  
6b68			  
6b68			  
6b68			  
6b68			  
6b68			  
6b68			  
6b68			  
6b68			  
6b68			  
6b68			  
6b68				; scan keyboard matrix and generate raw scan map  
6b68 cd fb 6b			call matrix  
6b6b			  
6b6b				; reuse c bit 0 left modifer button - ie shift  
6b6b			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6b6b				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6b6b			  
6b6b 0e 00			ld c, 0  
6b6d			  
6b6d				; TODO set flags for modifer key presses   
6b6d				; TODO do a search for modifer key...  
6b6d			  
6b6d				;ld hl,keyscan_table_row4  
6b6d 21 e7 fe			ld hl,keyscan_table_row2  
6b70			  
6b70 7e				ld a, (hl)  
6b71 fe 23			cp '#'  
6b73 20 07			jr nz, .nextmodcheck  
6b75 cb c1			set 0, c  
6b77 21 d5 6a			ld hl, .matrix_to_shift  
6b7a 18 21			jr .dokeymap  
6b7c				; TODO for now igonre  
6b7c			.nextmodcheck:  
6b7c 21 dc fe			ld hl,keyscan_table_row3  
6b7f			  
6b7f 7e				ld a, (hl)  
6b80 fe 23			cp '#'  
6b82 20 07			jr nz, .nextmodcheck2  
6b84 cb c9			set 1, c   
6b86 21 0c 6b			ld hl, .matrix_to_symbolshift  
6b89 18 12			jr .dokeymap  
6b8b			.nextmodcheck2:  
6b8b 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
6b8e			  
6b8e 7e				ld a, (hl)  
6b8f fe 23			cp '#'  
6b91 20 07			jr nz, .donemodcheck  
6b93 cb c9			set 1, c   
6b95 21 d5 6a			ld hl, .matrix_to_shift  
6b98 18 03			jr .dokeymap  
6b9a			  
6b9a				; no modifer found so just map to normal keys  
6b9a				; get mtoc map matrix to respective keys  
6b9a			;	ld hl, .matrix_to_char  
6b9a			;	ld hl, .matrix_to_char  
6b9a			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6b9a			;	ld a, KEY_SHIFT  
6b9a			;	call findchar  
6b9a			;  
6b9a			;	; got offset to key modifer in b  
6b9a			;  
6b9a			;	ld hl,keyscan_table_row5  
6b9a			;  
6b9a			;	ld a,b  
6b9a			;	call addatohl  
6b9a			;	ld a,(hl)  
6b9a			;  
6b9a			;	cp '#'  
6b9a			;	jr nz, .nextmodcheck  
6b9a			;	set 0, c  
6b9a			;	ld hl, .matrix_to_char  
6b9a			;	jr .dokeymap  
6b9a			;	; TODO for now igonre  
6b9a			;.nextmodcheck:  
6b9a			;	ld hl, .matrix_to_symbolshift  
6b9a			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6b9a			;	ld a, KEY_SYMBOLSHIFT  
6b9a			;	call findchar  
6b9a			;  
6b9a			;  
6b9a			;	; got offset to key modifer in b  
6b9a			;  
6b9a			;	ld hl,keyscan_table_row5  
6b9a			;  
6b9a			;	ld a,b  
6b9a			;	call addatohl  
6b9a			;	ld a,(hl)  
6b9a			;  
6b9a			;	cp '#'  
6b9a			;	jr nz, .donemodcheck  
6b9a			;	set 1, c   
6b9a			;	ld hl, .matrix_to_symbolshift  
6b9a			;	jr .dokeymap  
6b9a			  
6b9a			  
6b9a			  
6b9a			.donemodcheck:  
6b9a				; no modifer found so just map to normal keys  
6b9a				; get mtoc map matrix to respective keys  
6b9a 21 9e 6a			ld hl, .matrix_to_char  
6b9d			  
6b9d			.dokeymap:  
6b9d				;ld (key_fa), c   
6b9d cd b6 6b			call .mapkeys  
6ba0			  
6ba0			  
6ba0			if DEBUG_KEY  
6ba0			  
6ba0			; Display text on first line  
6ba0			            LD   A, kLCD_Line1  
6ba0			            CALL fLCD_Pos       ;Position cursor to location in A  
6ba0			            LD   DE, keyscan_table_row1  
6ba0			            ;LD   DE, MsgHello  
6ba0			            CALL fLCD_Str       ;Display string pointed to by DE  
6ba0			  
6ba0			; Display text on second line  
6ba0			            LD   A, kLCD_Line2  
6ba0			            CALL fLCD_Pos       ;Position cursor to location in A  
6ba0			            LD   DE, keyscan_table_row2  
6ba0			            CALL fLCD_Str       ;Display string pointed to by DE  
6ba0			            LD   A, kLCD_Line3  
6ba0			            CALL fLCD_Pos       ;Position cursor to location in A  
6ba0			            LD   DE, keyscan_table_row3  
6ba0			            CALL fLCD_Str       ;Display string pointed to by DE  
6ba0			            LD   A, kLCD_Line4  
6ba0			            CALL fLCD_Pos       ;Position cursor to location in A  
6ba0			            LD   DE, keyscan_table_row4  
6ba0			            CALL fLCD_Str       ;Display string pointed to by DE  
6ba0			            LD   A, kLCD_Line1+10  
6ba0			            CALL fLCD_Pos       ;Position cursor to location in A  
6ba0			            LD   DE, keyscan_table_row5  
6ba0			            CALL fLCD_Str       ;Display string pointed to by DE  
6ba0			  
6ba0				;call delay250ms  
6ba0			endif  
6ba0			;	jp testkey  
6ba0			  
6ba0			; get first char reported  
6ba0			  
6ba0 21 c6 fe			ld hl,keyscan_table_row5  
6ba3			  
6ba3				;ld b, 46   ; 30 keys to remap + 8 nulls   
6ba3 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6ba5			.findkey:  
6ba5 7e				ld a,(hl)  
6ba6 fe 00			cp 0  
6ba8 28 04			jr z, .nextkey  
6baa fe 7e			cp KEY_MATRIX_NO_PRESS  
6bac 20 06			jr nz, .foundkey  
6bae			.nextkey:  
6bae 23				inc hl  
6baf 10 f4			djnz .findkey  
6bb1 3e 00			ld a,0  
6bb3 c9				ret  
6bb4			.foundkey:  
6bb4 7e				ld a,(hl)  
6bb5 c9				ret  
6bb6				  
6bb6			  
6bb6			; convert the raw key map given hl for destination key  
6bb6			.mapkeys:  
6bb6 11 c6 fe			ld de,keyscan_table_row5  
6bb9			  
6bb9 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6bbb			.remap:  
6bbb 1a				ld a,(de)  
6bbc fe 23			cp '#'  
6bbe 20 02			jr nz, .remapnext  
6bc0				;CALLMONITOR  
6bc0 7e				ld a,(hl)  
6bc1 12				ld (de),a  
6bc2			  
6bc2			  
6bc2			  
6bc2			.remapnext:  
6bc2 23				inc hl  
6bc3 13				inc de  
6bc4 10 f5			djnz .remap  
6bc6				  
6bc6 c9				ret  
6bc7			  
6bc7			  
6bc7			  
6bc7			.mtocold2:  
6bc7			  
6bc7			;	; flag if key D is held down and remove from reporting  
6bc7			;	ld bc, .key_map_fd    
6bc7			;	ld hl, keyscan_table  
6bc7			;	ld de, key_fd  
6bc7			;	call .key_shift_hold  
6bc7			;	cp 255  
6bc7			;	jr z, .cinmap  
6bc7			;	; flag if key C is held down and remove from reporting  
6bc7			;	ld bc, .key_map_fc    
6bc7			;	ld hl, keyscan_table+key_cols  
6bc7			;	ld de, key_fc  
6bc7			;	call .key_shift_hold  
6bc7			;	cp 255  
6bc7			;	jr z, .cinmap  
6bc7			;	; flag if key B is held down and remove from reporting  
6bc7			;	ld bc, .key_map_fb    
6bc7			;	ld hl, keyscan_table+(key_cols*2)  
6bc7			;	ld de, key_fb  
6bc7			;	call .key_shift_hold  
6bc7			;	cp 255  
6bc7			;	jr z, .cinmap  
6bc7			;	; flag if key A is held down and remove from reporting  
6bc7			;	ld bc, .key_map_fa    
6bc7			;	ld hl, keyscan_table+(key_cols*3)  
6bc7			;	ld de, key_fa  
6bc7			;	call .key_shift_hold  
6bc7			;	cp 255  
6bc7			;	jr z, .cinmap  
6bc7			  
6bc7 11 9e 6a			ld de, .matrix_to_char  
6bca			  
6bca			  
6bca			.cinmap1:   
6bca				if DEBUG_KEY  
6bca			            LD   A, kLCD_Line4  
6bca			            CALL fLCD_Pos       ;Position cursor to location in A  
6bca					push de  
6bca			            LD   DE, keyscan_table  
6bca			            CALL fLCD_Str       ;Display string pointed to by DE  
6bca					pop de  
6bca				endif  
6bca			  
6bca				; scan key matrix table for any held key  
6bca			  
6bca				; de holds either the default matrix or one selected above  
6bca			  
6bca 21 93 fe			ld hl, keyscan_table  
6bcd 06 32			ld b,key_cols*key_rows  
6bcf			  
6bcf 7e			.cin11:	ld a,(hl)  
6bd0 fe 23			cp '#'  
6bd2 28 08			jr z, .cinhit1  
6bd4 23				inc hl  
6bd5 13				inc de  
6bd6 05				dec b  
6bd7 20 f6			jr nz, .cin11  
6bd9				; no key found held  
6bd9 3e 00			ld a,0  
6bdb c9				ret  
6bdc d5			.cinhit1: push de  
6bdd e1				pop hl  
6bde 7e				ld a,(hl)  
6bdf c9				ret  
6be0			  
6be0			; flag a control key is held   
6be0			; hl is key pin, de is flag indicator  
6be0			  
6be0			.key_shift_hold1:  
6be0 c5				push bc  
6be1 3e 01			ld a, 1  
6be3 32 c7 fb			ld (cursor_shape),a  
6be6 06 00			ld b, 0  
6be8 7e				ld a, (hl)  
6be9 fe 2e			cp '.'  
6beb 28 0a			jr z, .key_shift11  
6bed 06 ff			ld b, 255  
6bef 3e 2b			ld a, '+'    ; hide key from later scans  
6bf1 77				ld (hl),a  
6bf2 3e 02			ld a, 2  
6bf4 32 c7 fb			ld (cursor_shape),a  
6bf7			.key_shift11:  
6bf7				; write flag indicator  
6bf7 78				ld a,b  
6bf8 12				ld (de),a  
6bf9			  
6bf9 d1				pop de    ; de now holds the key map ptr  
6bfa c9				ret  
6bfb			  
6bfb				  
6bfb			  
6bfb			; scans keyboard matrix and flags key press in memory array	  
6bfb				  
6bfb			matrix:  
6bfb				;call matrix  
6bfb				; TODO optimise the code....  
6bfb			  
6bfb			  
6bfb			;ld hl, keyscan_table_row1  
6bfb			;ld de, keyscan_table_row1+1  
6bfb			;ld bc,46  
6bfb			;ld a,KEY_MATRIX_NO_PRESS  
6bfb			;ldir  
6bfb			  
6bfb			  
6bfb			  
6bfb			; reset counter  
6bfb 3e 80		ld a, 128  
6bfd d3 c1		out (portbdata),a  
6bff			  
6bff 06 0a		ld b, 10  
6c01 0e 00		ld c, 0       ; current clock toggle  
6c03			  
6c03			.colscan:  
6c03			  
6c03			; set current column  
6c03			; disable clock enable and set clock low  
6c03			  
6c03			;ld a, 0  
6c03			;out (portbdata),a  
6c03			  
6c03			; For each column scan for switches  
6c03			  
6c03 c5			push bc  
6c04 21 89 fe		ld hl, keyscan_scancol  
6c07 cd 10 6d		call .rowscan  
6c0a c1			pop bc  
6c0b			  
6c0b			  
6c0b			; get back current column  
6c0b			  
6c0b			; translate the row scan  
6c0b			  
6c0b			;   
6c0b			; row 1  
6c0b			  
6c0b 78			ld a,b  
6c0c			  
6c0c 21 fc fe		LD   hl, keyscan_table_row1+10  
6c0f			  
6c0f cd 08 0e		call subafromhl  
6c12			;call addatohl  
6c12			  
6c12 11 89 fe		ld de, keyscan_scancol  
6c15			  
6c15 1a			ld a,(de)  
6c16 77			ld (hl),a  
6c17			  
6c17			  
6c17			  
6c17			  
6c17			; row 2  
6c17			  
6c17 78			ld a,b  
6c18			  
6c18 21 f1 fe		LD   hl, keyscan_table_row2+10  
6c1b			  
6c1b			;call addatohl  
6c1b cd 08 0e		call subafromhl  
6c1e			  
6c1e			  
6c1e 11 8a fe		ld de, keyscan_scancol+1  
6c21			  
6c21 1a			ld a,(de)  
6c22 77			ld (hl),a  
6c23			  
6c23			  
6c23			; row 3  
6c23			  
6c23 78			ld a,b  
6c24			  
6c24 21 e6 fe		LD   hl, keyscan_table_row3+10  
6c27			  
6c27			;call addatohl  
6c27 cd 08 0e		call subafromhl  
6c2a			  
6c2a 11 8b fe		ld de, keyscan_scancol+2  
6c2d			  
6c2d 1a			ld a,(de)  
6c2e 77			ld (hl),a  
6c2f			  
6c2f			  
6c2f			  
6c2f			; row 4  
6c2f			  
6c2f 78			ld a,b  
6c30			  
6c30 21 db fe		LD   hl, keyscan_table_row4+10  
6c33			  
6c33			;call addatohl  
6c33 cd 08 0e		call subafromhl  
6c36			  
6c36 11 8c fe		ld de, keyscan_scancol+3  
6c39			  
6c39 1a			ld a,(de)  
6c3a 77			ld (hl),a  
6c3b			  
6c3b			; row 5  
6c3b			  
6c3b 78			ld a,b  
6c3c			  
6c3c 21 d0 fe		LD   hl, keyscan_table_row5+10  
6c3f			  
6c3f			;call addatohl  
6c3f cd 08 0e		call subafromhl  
6c42			  
6c42 11 8d fe		ld de, keyscan_scancol+4  
6c45			  
6c45 1a			ld a,(de)  
6c46 77			ld (hl),a  
6c47			  
6c47			; handshake next column  
6c47			  
6c47			  
6c47 3e 40		ld a, 64  
6c49 d3 c1		out (portbdata),a  
6c4b			  
6c4b 3e 00		ld a, 0  
6c4d d3 c1		out (portbdata),a  
6c4f			  
6c4f			; toggle clk and move to next column  
6c4f			;ld a, 64  
6c4f			;cp c  
6c4f			;  
6c4f			;jr z, .coltoglow  
6c4f			;ld c, a  
6c4f			;jr .coltog  
6c4f			;.coltoglow:  
6c4f			;ld c, 0  
6c4f			;.coltog:  
6c4f			;ld a, c  
6c4f			;out (portbdata),a  
6c4f			  
6c4f 10 b2		djnz .colscan  
6c51			  
6c51 3e 0a		ld a,10  
6c53 21 f2 fe		LD   hl, keyscan_table_row1  
6c56 cd f6 0d		call addatohl  
6c59 3e 00		ld a, 0  
6c5b 77			ld (hl), a  
6c5c			  
6c5c			  
6c5c 3e 0a		ld a,10  
6c5e 21 e7 fe		LD   hl, keyscan_table_row2  
6c61 cd f6 0d		call addatohl  
6c64 3e 00		ld a, 0  
6c66 77			ld (hl), a  
6c67			  
6c67 3e 0a		ld a,10  
6c69 21 dc fe		LD   hl, keyscan_table_row3  
6c6c cd f6 0d		call addatohl  
6c6f 3e 00		ld a, 0  
6c71 77			ld (hl), a  
6c72			  
6c72 3e 0a		ld a,10  
6c74 21 d1 fe		LD   hl, keyscan_table_row4  
6c77 cd f6 0d		call addatohl  
6c7a 3e 00		ld a, 0  
6c7c 77			ld (hl), a  
6c7d			  
6c7d 3e 0a		ld a,10  
6c7f 21 c6 fe		LD   hl, keyscan_table_row5  
6c82 cd f6 0d		call addatohl  
6c85 3e 00		ld a, 0  
6c87 77			ld (hl), a  
6c88			  
6c88			if DEBUG_KEY_MATRIX  
6c88			  
6c88			; Display text on first line  
6c88			            LD   A, kLCD_Line1  
6c88			            CALL fLCD_Pos       ;Position cursor to location in A  
6c88			            LD   DE, keyscan_table_row1  
6c88			            ;LD   DE, MsgHello  
6c88			            CALL fLCD_Str       ;Display string pointed to by DE  
6c88			  
6c88			; Display text on second line  
6c88			            LD   A, kLCD_Line2  
6c88			            CALL fLCD_Pos       ;Position cursor to location in A  
6c88			            LD   DE, keyscan_table_row2  
6c88			            CALL fLCD_Str       ;Display string pointed to by DE  
6c88			            LD   A, kLCD_Line3  
6c88			            CALL fLCD_Pos       ;Position cursor to location in A  
6c88			            LD   DE, keyscan_table_row3  
6c88			            CALL fLCD_Str       ;Display string pointed to by DE  
6c88			            LD   A, kLCD_Line4  
6c88			            CALL fLCD_Pos       ;Position cursor to location in A  
6c88			            LD   DE, keyscan_table_row4  
6c88			            CALL fLCD_Str       ;Display string pointed to by DE  
6c88			            LD   A, kLCD_Line4+10  
6c88			            CALL fLCD_Pos       ;Position cursor to location in A  
6c88			            LD   DE, keyscan_table_row5  
6c88			            CALL fLCD_Str       ;Display string pointed to by DE  
6c88			  
6c88			;call delay250ms  
6c88				jp matrix  
6c88			endif  
6c88 c9			ret  
6c89			  
6c89			; using decade counter....  
6c89			  
6c89			  
6c89			; TODO reset decade counter to start of scan  
6c89			  
6c89			; reset 15  
6c89			; clock 14  
6c89			; ce 13  
6c89			  
6c89			; 1 - q5  
6c89			; 2 - q1  
6c89			; 3 - q0  
6c89			; 4 - q2  
6c89			; 5 - q6  
6c89			; 6 - q7  
6c89			; 7 - q3  
6c89			; 8 - vss  
6c89			; 9 - q8  
6c89			; 10 - q4  
6c89			; 11 - q9  
6c89			; 12 - cout  
6c89			; 16 - vdd  
6c89			  
6c89			; clock      ce       reset     output  
6c89			; 0          x        0         n  
6c89			; x          1        0         n  
6c89			; x          x        1         q0  
6c89			; rising     0        0         n+1  
6c89			; falling    x        0         n  
6c89			; x          rising   0         n  
6c89			; 1          falling  0         x+1  
6c89			;  
6c89			; x = dont care, if n < 5 carry = 1 otherwise 0  
6c89			  
6c89			;   
6c89			; reset   
6c89			; 13=0, 14=0, 15=1 .. 15=0  
6c89			;  
6c89			; handshake line  
6c89			; 14=1.... read line 14=0  
6c89			  
6c89			  
6c89			  
6c89			  
6c89			  
6c89			; TODO hand shake clock for next column scan  
6c89			; TODO detect each row  
6c89			  
6c89			  
6c89			  
6c89			  
6c89			; reset 128  
6c89			; clock 64  
6c89			; ce 32  
6c89			  
6c89			  
6c89			.cyclestart:  
6c89			  
6c89			; reset counter  
6c89 3e 80		ld a, 128  
6c8b d3 c1		out (portbdata),a  
6c8d			  
6c8d			; loop leds  
6c8d 06 0a		ld b,10  
6c8f			  
6c8f			.cycle1:  
6c8f c5			push bc  
6c90 3e 00		ld a, 0  
6c92 d3 c1		out (portbdata),a  
6c94 cd 33 0b		call delay250ms  
6c97			  
6c97 3e 40		ld a, 64  
6c99 d3 c1		out (portbdata),a  
6c9b cd 33 0b		call delay250ms  
6c9e			  
6c9e 3e 00		ld a, 0  
6ca0 d3 c1		out (portbdata),a  
6ca2 cd 33 0b		call delay250ms  
6ca5			  
6ca5 c1			pop bc  
6ca6 10 e7		djnz .cycle1  
6ca8			  
6ca8			  
6ca8 18 df		jr .cyclestart  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			; map matrix key held to char on face of key  
6caa			  
6caa			;.mtocold:  
6caa			;  
6caa			;  
6caa			;; reset counter  
6caa			;ld a, 128  
6caa			;out (portbdata),a  
6caa			;  
6caa			;  
6caa			;; scan keyboard row 1  
6caa			;ld a, 0  
6caa			;out (portbdata),a  
6caa			;;ld a, 64  
6caa			;;out (portbdata),a  
6caa			;  
6caa			;  
6caa			;	ld a, 128  
6caa			;	ld hl, keyscan_table  
6caa			;	call .rowscan  
6caa			;  
6caa			;;ld a, 0  
6caa			;;out (portbdata),a  
6caa			;ld a, 64  
6caa			;out (portbdata),a  
6caa			;  
6caa			;	ld a, 64  
6caa			;	ld hl, keyscan_table+key_cols  
6caa			;	call .rowscan  
6caa			;  
6caa			;ld a, 0  
6caa			;out (portbdata),a  
6caa			;;ld a, 64  
6caa			;;out (portbdata),a  
6caa			;	ld a, 32  
6caa			;	ld hl, keyscan_table+(key_cols*2)  
6caa			;	call .rowscan  
6caa			;  
6caa			;  
6caa			;;ld a, 0  
6caa			;;out (portbdata),a  
6caa			;ld a, 64  
6caa			;out (portbdata),a  
6caa			;  
6caa			;	ld a, 16  
6caa			;	ld hl, keyscan_table+(key_cols*3)  
6caa			;	call .rowscan  
6caa			;  
6caa			;  
6caa			;	; flag if key D is held down and remove from reporting  
6caa			;	ld bc, .key_map_fd    
6caa			;	ld hl, keyscan_table  
6caa			;	ld de, key_fd  
6caa			;	call .key_shift_hold  
6caa			;	cp 255  
6caa			;	jr z, .cinmap  
6caa			;	; flag if key C is held down and remove from reporting  
6caa			;	ld bc, .key_map_fc    
6caa			;	ld hl, keyscan_table+key_cols  
6caa			;	ld de, key_fc  
6caa			;	call .key_shift_hold  
6caa			;	cp 255  
6caa			;	jr z, .cinmap  
6caa			;	; flag if key B is held down and remove from reporting  
6caa			;	ld bc, .key_map_fb    
6caa			;	ld hl, keyscan_table+(key_cols*2)  
6caa			;	ld de, key_fb  
6caa			;	call .key_shift_hold  
6caa			;	cp 255  
6caa			;	jr z, .cinmap  
6caa			;	; flag if key A is held down and remove from reporting  
6caa			;	ld bc, .key_map_fa    
6caa			;	ld hl, keyscan_table+(key_cols*3)  
6caa			;	ld de, key_fa  
6caa			;	call .key_shift_hold  
6caa			;	cp 255  
6caa			;	jr z, .cinmap  
6caa			;  
6caa			;	ld de, .matrix_to_char  
6caa			;  
6caa			;  
6caa			;.cinmap:   
6caa			;	if DEBUG_KEY  
6caa			;            LD   A, kLCD_Line4  
6caa			;            CALL fLCD_Pos       ;Position cursor to location in A  
6caa			;		push de  
6caa			;            LD   DE, keyscan_table  
6caa			;            CALL fLCD_Str       ;Display string pointed to by DE  
6caa			;		pop de  
6caa			;	endif  
6caa			  
6caa				; scan key matrix table for any held key  
6caa			  
6caa				; de holds either the default matrix or one selected above  
6caa			  
6caa			;	ld hl, keyscan_table  
6caa			;	ld b,key_cols*key_rows  
6caa			;  
6caa			;.cin1:	ld a,(hl)  
6caa			;	cp '#'  
6caa			;	jr z, .cinhit  
6caa			;	inc hl  
6caa			;	inc de  
6caa			;	dec b  
6caa			;	jr nz, .cin1  
6caa			;	; no key found held  
6caa			;	ld a,0  
6caa			;	ret  
6caa			;.cinhit: push de  
6caa			;	pop hl  
6caa			;	ld a,(hl)  
6caa			;	ret  
6caa			  
6caa			; flag a control key is held   
6caa			; hl is key pin, de is flag indicator  
6caa			  
6caa			;.key_shift_hold:  
6caa			;	push bc  
6caa			;	ld a, 1  
6caa			;	ld (cursor_shape),a  
6caa			;	ld b, 0  
6caa			;	ld a, (hl)  
6caa			;	cp '.'  
6caa			;	jr z, .key_shift1  
6caa			;	ld b, 255  
6caa			;	ld a, '+'    ; hide key from later scans  
6caa			;	ld (hl),a  
6caa			;	ld a, 2  
6caa			;	ld (cursor_shape),a  
6caa			;.key_shift1:  
6caa			;	; write flag indicator  
6caa			;	ld a,b  
6caa			;	ld (de),a  
6caa			;  
6caa			;	pop de    ; de now holds the key map ptr  
6caa			;	ret  
6caa			  
6caa				  
6caa				  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			;	push hl  
6caa			;	push de  
6caa			;	push bc  
6caa			;	call keyscan  
6caa			;	; map key matrix to ascii value of key face  
6caa			;  
6caa			;	ld hl, key_face_map  
6caa			;	ld de, keyscan_table  
6caa			;  
6caa			;	; get how many keys to look at  
6caa			;	ld b, keyscan_table_len  
6caa			;	  
6caa			;  
6caa			;	; at this stage fall out on first key hit  
6caa			;	; TODO handle multiple key press  
6caa			;  
6caa			;map1:	ld a,(hl)  
6caa			;	cp '#'  
6caa			;	jr z, keyhit  
6caa			;	inc hl  
6caa			;	inc de  
6caa			;	dec b  
6caa			;	jr nz, map1  
6caa			;nohit:	ld a, 0  
6caa			;	jr keydone  
6caa			;keyhit: push de  
6caa			;	pop hl  
6caa			;	ld a,(hl)  
6caa			;keydone:  
6caa			;	push bc  
6caa			;	push de  
6caa			; 	push hl  
6caa			;	ret   
6caa			;  
6caa			  
6caa			  
6caa			  
6caa			  
6caa			; scan physical key matrix  
6caa			  
6caa			  
6caa			;keyscan:  
6caa			;  
6caa			;; for each key_row use keyscanr bit mask for out  
6caa			;; then read in for keyscanc bitmask  
6caa			;; save result of row scan to keyscantable  
6caa			;  
6caa			;; scan keyboard row 1  
6caa			;  
6caa			;	ld b, key_rows  
6caa			;	ld hl, key_scanr  
6caa			;	ld de, keyscan_table  
6caa			;  
6caa			;rowloop:  
6caa			;  
6caa			;	ld a,(hl)		; out bit mask to energise keyboard row  
6caa			;	call rowscan  
6caa			;	inc hl  
6caa			;	dec b  
6caa			;	jr nz, rowloop  
6caa			;  
6caa			;	ret  
6caa			;  
6caa			;  
6caa			;; pass a out bitmask, b row number  
6caa			;arowscan:   
6caa			;	push bc  
6caa			;  
6caa			;	ld d, b  
6caa			;  
6caa			;	; calculate buffer location for this row  
6caa			;  
6caa			;	ld hl, keyscan_table	  
6caa			;kbufr:  ld e, key_cols  
6caa			;kbufc:	inc hl  
6caa			;	dec e  
6caa			;	jr nz, kbufc  
6caa			;	dec d  
6caa			;	jr nz, kbufr  
6caa			;  
6caa			;	; energise row and read columns  
6caa			;  
6caa			;	out (portbdata),a  
6caa			;	in a,(portbdata)  
6caa			;	ld c,a  
6caa			;  
6caa			;  
6caa			;	; save buffer loc  
6caa			;  
6caa			;	ld (keybufptr), hl  
6caa			;  
6caa			;	ld hl, key_scanc  
6caa			;	ld d, key_cols  
6caa			;  
6caa			;	; for each column check each bit mask  
6caa			;  
6caa			;colloop:  
6caa			;	  
6caa			;  
6caa			;	; reset flags for the row   
6caa			;  
6caa			;	ld b,'.'  
6caa			;	and (hl)  
6caa			;	jr z, maskskip  
6caa			;	ld b,'#'  
6caa			;maskskip:  
6caa			;	; save  key state  
6caa			;	push hl  
6caa			;	ld hl, (keybufptr)  
6caa			;	ld (hl), b  
6caa			;	inc hl  
6caa			;	ld (keybufptr), hl  
6caa			;  
6caa			;	; move to next bit mask  
6caa			;	pop hl  
6caa			;	inc hl  
6caa			;  
6caa			;	dec d  
6caa			;	jr nz, colloop  
6caa			;  
6caa			;	ret  
6caa			;  
6caa			;  
6caa			;;  
6caa			; lcd functions  
6caa			;  
6caa			;  
6caa			  
6caa			;if DEBUG_KEY_MATRIX  
6caa			  
6caa			; test function to display hardware view of matrix state  
6caa			  
6caa			matrixold:  
6caa			  
6caa			  
6caa			  
6caa			; reset counter  
6caa 3e 80		ld a, 128  
6cac d3 c1		out (portbdata),a  
6cae			; scan keyboard row 1  
6cae 3e 00		ld a, 0  
6cb0 d3 c1		out (portbdata),a  
6cb2			;ld a, 64  
6cb2			;out (portbdata),a  
6cb2 3e 80			ld a, 128  
6cb4 21 f2 fe			ld hl, keyscan_table_row1  
6cb7 cd 10 6d			call .rowscan  
6cba			  
6cba			;ld a, 0  
6cba			;out (portbdata),a  
6cba 3e 40		ld a, 64  
6cbc d3 c1		out (portbdata),a  
6cbe 3e 40			ld a, 64  
6cc0 21 e7 fe			ld hl, keyscan_table_row2  
6cc3 cd 10 6d			call .rowscan  
6cc6			  
6cc6 3e 00		ld a, 0  
6cc8 d3 c1		out (portbdata),a  
6cca			;ld a, 64  
6cca			;out (portbdata),a  
6cca 3e 20			ld a, 32  
6ccc 21 dc fe			ld hl, keyscan_table_row3  
6ccf cd 10 6d			call .rowscan  
6cd2			  
6cd2			;ld a, 0  
6cd2			;out (portbdata),a  
6cd2 3e 40		ld a, 64  
6cd4 d3 c1		out (portbdata),a  
6cd6 3e 10			ld a, 16  
6cd8 21 d1 fe			ld hl, keyscan_table_row4  
6cdb cd 10 6d			call .rowscan  
6cde			  
6cde			; Display text on first line  
6cde 3e 00		            LD   A, kLCD_Line1  
6ce0 cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6ce3 11 f2 fe		            LD   DE, keyscan_table_row1  
6ce6			            ;LD   DE, MsgHello  
6ce6 cd 3a 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6ce9			  
6ce9			; Display text on second line  
6ce9 3e 28		            LD   A, kLCD_Line2  
6ceb cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6cee 11 e7 fe		            LD   DE, keyscan_table_row2  
6cf1 cd 3a 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6cf4 3e 50		            LD   A, kLCD_Line3  
6cf6 cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6cf9 11 dc fe		            LD   DE, keyscan_table_row3  
6cfc cd 3a 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6cff 3e 78		            LD   A, kLCD_Line4  
6d01 cd 18 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6d04 11 d1 fe		            LD   DE, keyscan_table_row4  
6d07 cd 3a 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6d0a			  
6d0a cd 33 0b			call delay250ms  
6d0d c3 fb 6b			jp matrix  
6d10			  
6d10			; pass de as row display flags  
6d10			.rowscan:   
6d10			;	out (portbdata),a  
6d10 db c1			in a,(portbdata)  
6d12 4f				ld c,a  
6d13				; reset flags for the row   
6d13 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d15 e6 01			and 1  
6d17 28 02			jr z, .p1on  
6d19 06 23			ld b,'#'  
6d1b			.p1on:  
6d1b 70				ld (hl), b  
6d1c 23				inc hl  
6d1d			  
6d1d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d1f 79				ld a,c  
6d20 e6 02			and 2  
6d22			;	bit 0,a  
6d22 28 02			jr z, .p2on  
6d24 06 23			ld b,'#'  
6d26			.p2on:  
6d26 70				ld (hl), b  
6d27 23				inc hl  
6d28			;  
6d28 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d2a 79				ld a,c  
6d2b e6 04			and 4  
6d2d			;;	bit 0,a  
6d2d 28 02			jr z, .p3on  
6d2f 06 23			ld b,'#'  
6d31			.p3on:  
6d31 70				ld (hl), b  
6d32 23				inc hl  
6d33			;;  
6d33 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d35			;;	bit 0,a  
6d35 79				ld a,c  
6d36 e6 08			and 8  
6d38 28 02			jr z, .p4on  
6d3a 06 23			ld b,'#'  
6d3c			.p4on:  
6d3c 70				ld (hl), b  
6d3d 23				inc hl  
6d3e			  
6d3e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d40			;;	bit 0,a  
6d40 79				ld a,c  
6d41 e6 10			and 16  
6d43 28 02			jr z, .p5on  
6d45 06 23			ld b,'#'  
6d47			.p5on:  
6d47 70				ld (hl), b  
6d48 23				inc hl  
6d49			; zero term  
6d49 06 00			ld b,0  
6d4b 70				ld (hl), b  
6d4c			  
6d4c c9			.rscandone: ret  
6d4d			  
6d4d			;addatohl:  
6d4d			;  
6d4d			 ;add   a, l    ; A = A+L  
6d4d			  ;  ld    l, a    ; L = A+L  
6d4d			   ; adc   a, h    ; A = A+L+H+carry  
6d4d			   ; sub   l       ; A = H+carry  
6d4d			   ; ld    h, a    ; H = H+carry  
6d4d			  
6d4d			;ret  
6d4d			; eof  
# End of file firmware_key_5x10.asm
6d4d			;include "firmware_key_4x10.asm" 
6d4d			 
6d4d			heap_size:    equ heap_end - heap_start 
6d4d			;eof 
# End of file os_mega.asm
6d4d
