# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 13 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 offsets for settings  
0003			  
0003			; if set then skip prompt for start up and accept all  
0003			  
0003			STORE_0_QUICKSTART: equ $25  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0003			  
0003			hardware_config: equ key_face_held - 10  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_config - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003				  
0003			  
0003					;ld a, 0  
0003					;ld (hardware_diag), a  
0003			  
0003					; clear all the buffers  
0003			  
0003 21 f9 fa				ld hl, display_fb1  
0006 22 55 fa				ld (display_fb_active), hl  
0009			  
0009 cd e4 0a				call clear_display  
000c			  
000c 21 57 fa				ld hl, display_fb2  
000f 22 55 fa				ld (display_fb_active), hl  
0012			  
0012 cd e4 0a				call clear_display  
0015			  
0015					; init primary frame buffer area  
0015 21 4a fb				ld hl, display_fb0  
0018 22 55 fa				ld (display_fb_active), hl  
001b			  
001b cd e4 0a				call clear_display  
001e			  
001e			  
001e cd 8b 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0021			  
0021 cd d4 66			call key_init  
0024 cd c4 01			call storage_init  
0027			  
0027				; setup malloc functions  
0027			  
0027				if MALLOC_1  
0027 cd bb 11				call  heap_init  
002a				endif  
002a				if MALLOC_4  
002a					call  heap_init  
002a				endif  
002a			  
002a				; init sound hardware if present  
002a			  
002a				if SOUND_ENABLE  
002a					call sound_init  
002a				endif  
002a			  
002a				; lcd test sequence  
002a					  
002a cd 07 0b			call update_display  
002d cd 61 0a			call delay1s  
0030 3e 2b			ld a,'+'  
0032 cd e9 0a			call fill_display  
0035 cd 07 0b			call update_display  
0038 cd 61 0a			call delay1s  
003b 3e 2a			ld a,'*'  
003d cd e9 0a			call fill_display  
0040 cd 07 0b			call update_display  
0043 cd 61 0a			call delay1s  
0046 3e 2d			ld a,'-'  
0048 cd e9 0a			call fill_display  
004b cd 07 0b			call update_display  
004e cd 61 0a			call delay1s  
0051			  
0051			; boot splash screen  
0051			if display_cols == 20	  
0051 3e 00		        ld a, display_row_1    
0053			else  
0053			        ld a, display_row_1 +10   
0053			endif  
0053 11 84 00			ld de, bootmsg  
0056 cd f7 0a			call str_at_display  
0059 cd 07 0b			call update_display  
005c			  
005c			  
005c cd 61 0a			call delay1s  
005f cd 61 0a			call delay1s  
0062			if display_cols == 20	  
0062 3e 2a		            LD   A, display_row_3+2  
0064			else  
0064			            LD   A, display_row_3+12  
0064			endif  
0064 11 99 00			ld de, bootmsg1  
0067 cd f7 0a			call str_at_display  
006a cd 07 0b			call update_display  
006d cd 61 0a			call delay1s  
0070 cd 61 0a			call delay1s  
0073			  
0073			;	ld a, display_row_4+3  
0073			;	ld de, bootmsg2  
0073			;	call str_at_display  
0073			;	call update_display  
0073			;	call delay1s  
0073			;	call delay1s  
0073			  
0073			; debug mark setup  
0073			  
0073 3e 5f		ld a, '_'  
0075 32 b4 fb		ld (debug_mark),a  
0078 32 b5 fb		ld (debug_mark+1),a  
007b 32 b6 fb		ld (debug_mark+2),a  
007e 3e 00		ld a,0  
0080 32 b7 fb		ld (debug_mark+3),a  
0083			  
0083 c9					ret  
0084			  
0084			  
0084 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
0099 .. 00		bootmsg1:	db "by Kevin Groves",0  
00a9			;bootmsg2:	db "Firmware v0.1",0  
00a9			  
00a9			; a 4x20 lcd  
00a9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a9			  
00a9			;if display_cols == 20  
00a9			;	include "firmware_lcd_4x20.asm"  
00a9			;endif  
00a9			  
00a9			;if display_cols == 40  
00a9			;	include "firmware_lcd_4x40.asm"  
00a9			;endif  
00a9			  
00a9			;  
00a9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a9			; TODO abstract the bit bang video out interface for dual display  
00a9			; TODO wire video out to tx pin on rc2014 bus  
00a9			  
00a9			; must supply cin, and cin_wait for low level hardware abstraction   
00a9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a9			; test scancode  
00a9			  
00a9			;;;;;  
00a9			;;;  
00a9			; Moved out to mini and maxi versions  
00a9			;  
00a9			; include "firmware_key_4x4.asm"  
00a9			; using existing 4 wire x 4 resistor array for input  
00a9			;include "firmware_key_4x10.asm"  
00a9			; need to mod the board for 5 rows due to resistor array  
00a9			;include "firmware_key_5x10.asm"  
00a9			  
00a9			; storage hardware interface  
00a9			  
00a9			; use microchip serial eeprom for storage  
00a9			  
00a9			  
00a9			if STORAGE_SE  
00a9				include "firmware_spi.asm"  
00a9			; my spi protocol (used by storage) 
00a9			 
00a9			; SPI pins 
00a9			 
00a9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a9			 
00a9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a9			; chip pin 4 gnd 
00a9			 
00a9			 
00a9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a9			SPI_CE1: equ 1      ;    port a1 pin 14  
00a9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a9			SPI_CE4: equ 4      ; port a4     pin 10 
00a9			 
00a9			; active low AND masks 
00a9			 
00a9			;SPI_CE0_MASK: equ    255-1 
00a9			;SPI_CE1_MASK: equ   255-2 
00a9			;SPI_CE2_MASK: equ   255-4 
00a9			;SPI_CE3_MASK: equ   255-8 
00a9			;SPI_CE4_MASK: equ   255-16 
00a9			SPI_CE_HIGH:  equ 255 
00a9			 
00a9			 
00a9			 
00a9			 
00a9			; TODO store port id for spi device ie dev c 
00a9			; TODO store pin for SO 
00a9			; TODO store pin for SI 
00a9			; TODO store pin for SCLK 
00a9			 
00a9			; 
00a9			 
00a9			; ensure that spi bus is in a stable state with default pins  
00a9			 
00a9			se_stable_spi:   
00a9			 
00a9				 ; set DI high, CE high , SCLK low 
00a9				;ld a, SPI_DI | SPI_CE0 
00a9 3e 07			ld a, SPI_DI  
00ab cd 7f 01			call spi_ce_high 
00ae d3 80			 out (storage_adata),a 
00b0 32 c6 f9			ld (spi_portbyte),a 
00b3			 
00b3				if DEBUG_SPI 
00b3					push hl 
00b3					ld l, a 
00b3					DMARK "SPI" 
00b3					CALLMONITOR 
00b3					pop hl 
00b3				endif 
00b3 c9				ret 
00b4			 
00b4			; byte to send in a 
00b4			 
00b4			spi_send_byte: 
00b4				; save byte to send for bit mask shift out 
00b4 4f			        ld c,a 
00b5 3a c6 f9			ld a,(spi_portbyte) 
00b8				  
00b8				; clock out	each bit of the byte msb first 
00b8			 
00b8 06 08			ld b, 8 
00ba			.ssb1: 
00ba				; clear so bit  
00ba cb bf			res SPI_DI, a 
00bc cb 11			rl c 
00be				; if bit 7 is set then carry is set 
00be 30 02			jr nc, .ssb2 
00c0 cb ff			set SPI_DI,a 
00c2			.ssb2:  ; output bit to ensure it is stable 
00c2 d3 80			out (storage_adata),a 
00c4 00				nop 
00c5				; clock bit high 
00c5 cb ef			set SPI_SCLK,a 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; then low 
00ca cb af			res SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf 10 e9			djnz .ssb1 
00d1			 
00d1 32 c6 f9			ld (spi_portbyte),a 
00d4 c9				ret 
00d5			 
00d5			; TODO low level get byte into A on spi 
00d5			 
00d5			spi_read_byte:  
00d5			 
00d5				; save byte to send for bit mask shift out 
00d5 0e 00		    ld c,0 
00d7 3a c6 f9			ld a,(spi_portbyte) 
00da				  
00da				; clock out	each bit of the byte msb first 
00da			 
00da			 
00da				; clock bit high 
00da cb ef			set SPI_SCLK,a 
00dc d3 80			out (storage_adata),a 
00de 00				nop 
00df			 
00df			    ; read DO  
00df			 
00df cb f9		    set 7,c 
00e1 db 80			in a,(storage_adata) 
00e3 cb 77		    bit SPI_DO,a 
00e5 20 02		    jr nz, .b7 
00e7 cb b9		    res 7,c 
00e9			.b7: 
00e9				; then low 
00e9 cb af			res SPI_SCLK,a 
00eb d3 80			out (storage_adata),a 
00ed 00				nop 
00ee			     
00ee			 
00ee				; clock bit high 
00ee cb ef			set SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			 
00f3			    ; read DO  
00f3			 
00f3 cb f1		    set 6,c 
00f5 db 80			in a,(storage_adata) 
00f7 cb 77		    bit SPI_DO,a 
00f9 20 02		    jr nz, .b6 
00fb cb b1		    res 6,c 
00fd			.b6: 
00fd				; then low 
00fd cb af			res SPI_SCLK,a 
00ff d3 80			out (storage_adata),a 
0101 00				nop 
0102			 
0102				; clock bit high 
0102 cb ef			set SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107			 
0107			    ; read DO  
0107			 
0107 cb e9		    set 5,c 
0109 db 80			in a,(storage_adata) 
010b cb 77		    bit SPI_DO,a 
010d 20 02		    jr nz, .b5 
010f cb a9		    res 5,c 
0111			.b5: 
0111				; then low 
0111 cb af			res SPI_SCLK,a 
0113 d3 80			out (storage_adata),a 
0115 00				nop 
0116				; clock bit high 
0116 cb ef			set SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b			 
011b			    ; read DO  
011b			 
011b cb e1		    set 4,c 
011d db 80			in a,(storage_adata) 
011f cb 77		    bit SPI_DO,a 
0121 20 02		    jr nz, .b4 
0123 cb a1		    res 4,c 
0125			.b4: 
0125				; then low 
0125 cb af			res SPI_SCLK,a 
0127 d3 80			out (storage_adata),a 
0129 00				nop 
012a				; clock bit high 
012a cb ef			set SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f			 
012f			    ; read DO  
012f			 
012f cb d9		    set 3,c 
0131 db 80			in a,(storage_adata) 
0133 cb 77		    bit SPI_DO,a 
0135 20 02		    jr nz, .b3 
0137 cb 99		    res 3,c 
0139			.b3: 
0139				; then low 
0139 cb af			res SPI_SCLK,a 
013b d3 80			out (storage_adata),a 
013d 00				nop 
013e				; clock bit high 
013e cb ef			set SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143			 
0143			    ; read DO  
0143			 
0143 cb d1		    set 2,c 
0145 db 80			in a,(storage_adata) 
0147 cb 77		    bit SPI_DO,a 
0149 20 02		    jr nz, .b2 
014b cb 91		    res 2,c 
014d			.b2: 
014d				; then low 
014d cb af			res SPI_SCLK,a 
014f d3 80			out (storage_adata),a 
0151 00				nop 
0152				; clock bit high 
0152 cb ef			set SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157			 
0157			    ; read DO  
0157			 
0157 cb c9		    set 1,c 
0159 db 80			in a,(storage_adata) 
015b cb 77		    bit SPI_DO,a 
015d 20 02		    jr nz, .b1 
015f cb 89		    res 1,c 
0161			.b1: 
0161				; then low 
0161 cb af			res SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b			 
016b			    ; read DO  
016b			 
016b cb c1		    set 0,c 
016d db 80			in a,(storage_adata) 
016f cb 77		    bit SPI_DO,a 
0171 20 02		    jr nz, .b0 
0173 cb 81		    res 0,c 
0175			.b0: 
0175				; then low 
0175 cb af			res SPI_SCLK,a 
0177 d3 80			out (storage_adata),a 
0179 00				nop 
017a			 
017a			 
017a 32 c6 f9			ld (spi_portbyte),a 
017d			 
017d			    ; return byte 
017d 79			    ld a,c 
017e			 
017e			 
017e c9				ret 
017f			 
017f			 
017f			 
017f			spi_ce_high: 
017f			 
017f				if DEBUG_SPI_HARD_CE0 
017f			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
017f					ret 
017f			 
017f				endif 
017f			 
017f			 
017f f5				push af 
0180			 
0180				; send direct ce to port b 
0180 3e ff			ld a, 255 
0182 d3 81			out (storage_bdata), a 
0184			 
0184 f1				pop af 
0185			 
0185				; for port a that shares with spi lines AND the mask 
0185			  
0185				if DEBUG_SPI 
0185					push hl 
0185					ld h, a 
0185				endif 
0185			;	ld c, SPI_CE_HIGH 
0185			;	and c 
0185 cb c7			set SPI_CE0, a 
0187 cb cf			set SPI_CE1, a 
0189 cb d7			set SPI_CE2, a 
018b cb df			set SPI_CE3, a 
018d cb e7			set SPI_CE4, a 
018f			 
018f				if DEBUG_SPI 
018f					ld l, a 
018f					DMARK "CEh" 
018f					CALLMONITOR 
018f					pop hl 
018f				endif 
018f c9				ret 
0190			 
0190			 
0190			spi_ce_low: 
0190			 
0190				if DEBUG_SPI_HARD_CE0 
0190			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0190					ret 
0190			 
0190				endif 
0190			 
0190 c5				push bc 
0191 f5				push af 
0192			 
0192				; send direct ce to port b 
0192 3a c8 f9			ld a, (spi_cartdev) 
0195 d3 81			out (storage_bdata), a 
0197			 
0197			 
0197			 
0197				; for port a that shares with spi lines AND the mask 
0197			 
0197 3a c5 f9			ld a, (spi_device)  
019a 4f				ld c, a 
019b			 
019b f1				pop af 
019c			 
019c				; detect CEx 
019c			 
019c				if DEBUG_SPI 
019c					push hl 
019c					ld h, a 
019c				endif 
019c			 
019c cb 41			bit SPI_CE0, c 
019e 20 04			jr nz, .cel1 
01a0 cb 87			res SPI_CE0, a 
01a2 18 1e			jr .celn 
01a4			.cel1: 
01a4 cb 49			bit SPI_CE1, c 
01a6 20 04			jr nz, .cel2 
01a8 cb 8f			res SPI_CE1, a 
01aa 18 16			jr .celn 
01ac			.cel2: 
01ac cb 51			bit SPI_CE2, c 
01ae 20 04			jr nz, .cel3 
01b0 cb 97			res SPI_CE2, a 
01b2 18 0e			jr .celn 
01b4			.cel3: 
01b4 cb 59			bit SPI_CE3, c 
01b6 20 04			jr nz, .cel4 
01b8 cb 9f			res SPI_CE3, a 
01ba 18 06			jr .celn 
01bc			.cel4: 
01bc cb 61			bit SPI_CE4, c 
01be 20 02			jr nz, .celn 
01c0 cb a7			res SPI_CE4, a 
01c2			.celn: 
01c2			 
01c2			 
01c2			 
01c2			;	add c 
01c2			 
01c2				if DEBUG_SPI 
01c2					ld l, a 
01c2					DMARK "CEl" 
01c2					CALLMONITOR 
01c2					pop hl 
01c2				endif 
01c2 c1				pop bc 
01c3 c9				ret 
01c4			 
01c4			 
01c4			 
01c4			; eof 
01c4			 
01c4			 
01c4			 
01c4			 
01c4			 
# End of file firmware_spi.asm
01c4				include "firmware_seeprom.asm"  
01c4			; 
01c4			; persisent storage interface via microchip serial eeprom 
01c4			 
01c4			; port a pio 2 
01c4			; pa 7 - si 
01c4			; pa 6 - sclk  
01c4			; pa 5 - so 
01c4			; pa 4 - cs 
01c4			; pa 3 - cs 
01c4			; pa 2 - cs 
01c4			; pa 1 - cs 
01c4			; pa 0 - cs 
01c4			; 
01c4			; TODO get block 
01c4			; TODO save block 
01c4			; TODO load file 
01c4			; TODO save file 
01c4			; TODO get dir  
01c4			 
01c4			;  
01c4			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c4			storage_actl: equ Device_C+2     ; device c port a 
01c4			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c4			storage_bctl: equ Device_C+3     ; device c port b 
01c4			 
01c4			 
01c4			; TODO move these to hardware driver file 
01c4			 
01c4			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c4			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c4			; storage bank file system format 
01c4			; 
01c4			; first page of bank: 
01c4			; 	addr 0 - status check 
01c4			;       addr 1 - write protect flag 
01c4			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c4			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c4			;         TODO see if scanning whole of for available next file id is fast enough 
01c4			;	addr 4 > zero term string of bank label 
01c4			; 
01c4			;        
01c4			;  
01c4			; first page of any file: 
01c4			;      byte 0 - file id  
01c4			;      byte 1-17 - fixed file name  
01c4			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c4			; 
01c4			; other pages of any file: 
01c4			;      byte 0 - file id 
01c4			;      byte 1> - file data 
01c4			; 
01c4			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c4			;  
01c4			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c4			 
01c4			 
01c4			;storage_so_bit: 5 
01c4			;storage_si_bit: 7 
01c4			;storage_sclk_bit: 6 
01c4			  
01c4			 
01c4			; init storage pio 
01c4			 
01c4			storage_init: 
01c4			 
01c4 3e cf		            LD   A, 11001111b 
01c6 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01c8 3e 00		            LD   A, 00000000b 
01ca cb f7			set SPI_DO,a 
01cc			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01cc d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01ce			 
01ce 3e cf		            LD   A, 11001111b 
01d0 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d2 3e 00		            LD   A, 00000000b 
01d4 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01d6			 
01d6				; set all external spi devices off 
01d6 3e 00			ld a, 0 
01d8 32 c5 f9			ld (spi_device), a 
01db 32 c8 f9			ld (spi_cartdev), a 
01de			 
01de					; ensure the spi bus is in a default stable state 
01de cd a9 00				call se_stable_spi 
01e1			 
01e1			; TODO scan spi bus and gather which storage banks are present 
01e1			 
01e1			; populate store_bank_active  
01e1			; for each ce line activate and attempt to write first byte of bank and read back 
01e1			; if zero is returned then bank is empty 
01e1			;   
01e1			; 
01e1			 
01e1					; init file extent cache to save on slow reads 
01e1			 
01e1			;	ld hl, store_filecache 
01e1			;	ld de, 0 
01e1			;	ld hl,(de)	 
01e1			 
01e1			 
01e1 c9			    ret 
01e2			 
01e2			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e2			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e2			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e2			 
01e2			; INSTRUCTION SET 
01e2			; READ 0000 0011 Read data from memory array beginning at selected address 
01e2			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e2			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e2			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e2			; RDSR 0000 0101 Read STATUS register 
01e2			; WRSR 0000 0001 Write STATUS register 
01e2			; PE 0100 0010 Page Erase – erase one page in memory array 
01e2			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e2			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e2			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e2			 
01e2			; TODO send byte steam for page without setting the address for every single byte 
01e2			; TODO read byte  
01e2			 
01e2			; byte in a 
01e2			; address in hl  
01e2			se_writebyte: 
01e2			        
01e2			    ;   ld c, a 
01e2 f5			        push af 
01e3 e5			        push hl 
01e4			 
01e4			    ; initi write mode 
01e4			    ; 
01e4			    ;CS low 
01e4			 
01e4 3a c6 f9		       ld a,(spi_portbyte) 
01e7 cd 90 01			call spi_ce_low 
01ea			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ea d3 80		       out (storage_adata),a 
01ec 32 c6 f9		       ld (spi_portbyte), a 
01ef			 
01ef			    ;clock out wren instruction 
01ef			 
01ef 3e 06		    ld a, store_wren_ins 
01f1 cd b4 00		    call spi_send_byte  
01f4			 
01f4			    ;cs high to enable write latch 
01f4			 
01f4 3a c6 f9		       ld a,(spi_portbyte) 
01f7 cd 7f 01			call spi_ce_high 
01fa			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fa d3 80		       out (storage_adata),a 
01fc 32 c6 f9		       ld (spi_portbyte), a 
01ff			 
01ff 00				nop 
0200			    ; 
0200			    ; intial write data 
0200			    ; 
0200			    ; cs low 
0200			     
0200 3a c6 f9		       ld a,(spi_portbyte) 
0203 cd 90 01			call spi_ce_low 
0206			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0206 d3 80		       out (storage_adata),a 
0208 32 c6 f9		       ld (spi_portbyte), a 
020b			 
020b			    ; clock out write instruction 
020b			     
020b 3e 02		    ld a, store_write_ins  
020d cd b4 00		    call spi_send_byte  
0210			 
0210			    ; clock out address (depending on address size) 
0210			     
0210 e1			    pop hl 
0211 7c			    ld a,h    ; address out msb first 
0212 cd b4 00		    call spi_send_byte  
0215 7d			    ld a,l 
0216 cd b4 00		    call spi_send_byte  
0219			 
0219			    ; clock out byte(s) for page 
0219			 
0219 f1			    pop af 
021a cd b4 00		    call spi_send_byte  
021d			 
021d			    ; end write with ce high 
021d 3a c6 f9		       ld a,(spi_portbyte) 
0220			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0220 cd 7f 01			call spi_ce_high 
0223 d3 80		       out (storage_adata),a 
0225 32 c6 f9		       ld (spi_portbyte), a 
0228			 
0228				; pause for internal write cycle 
0228 3e 0a			ld a, 10 
022a cd 46 0a			call aDelayInMS 
022d c9			    ret 
022e			 
022e			; buffer to write in de 
022e			; address in hl  
022e			se_writepage: 
022e			        
022e			    ;   ld c, a 
022e d5				push de 
022f e5			        push hl 
0230			 
0230			    ; initi write mode 
0230			    ; 
0230			    ;CS low 
0230			 
0230 3a c6 f9		       ld a,(spi_portbyte) 
0233 cd 90 01			call spi_ce_low 
0236			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0236 d3 80		       out (storage_adata),a 
0238 32 c6 f9		       ld (spi_portbyte), a 
023b			 
023b			    ;clock out wren instruction 
023b			 
023b 3e 06		    ld a, store_wren_ins 
023d cd b4 00		    call spi_send_byte  
0240			 
0240			    ;cs high to enable write latch 
0240			 
0240 3a c6 f9		       ld a,(spi_portbyte) 
0243 cd 7f 01			call spi_ce_high 
0246			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0246 d3 80		       out (storage_adata),a 
0248 32 c6 f9		       ld (spi_portbyte), a 
024b			 
024b 00				nop 
024c			    ; 
024c			    ; intial write data 
024c			    ; 
024c			    ; cs low 
024c			     
024c 3a c6 f9		       ld a,(spi_portbyte) 
024f			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
024f cd 90 01			call spi_ce_low 
0252 d3 80		       out (storage_adata),a 
0254 32 c6 f9		       ld (spi_portbyte), a 
0257			 
0257			    ; clock out write instruction 
0257			     
0257 3e 02		    ld a, store_write_ins  
0259 cd b4 00		    call spi_send_byte  
025c			 
025c			    ; clock out address (depending on address size) 
025c			     
025c e1			    pop hl 
025d 7c			    ld a,h    ; address out msb first 
025e cd b4 00		    call spi_send_byte  
0261 7d			    ld a,l 
0262 cd b4 00		    call spi_send_byte  
0265			 
0265			    ; clock out byte(s) for page 
0265			 
0265 e1				pop hl 
0266 06 40			ld b, STORE_BLOCK_PHY 
0268			.bytewrite: 
0268			 
0268 7e				ld a,(hl) 
0269 e5			    push hl 
026a c5				push bc 
026b cd b4 00		    call spi_send_byte  
026e c1				pop bc 
026f e1				pop hl 
0270			 
0270			    ; end write with ce high 
0270 3a c6 f9		       ld a,(spi_portbyte) 
0273 cd 7f 01			call spi_ce_high 
0276			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0276 d3 80		       out (storage_adata),a 
0278 32 c6 f9		       ld (spi_portbyte), a 
027b			 
027b 23				inc hl 
027c 10 ea			djnz .bytewrite 
027e			 
027e				; pause for internal write cycle 
027e 3e 64			ld a, 100 
0280 cd 46 0a			call aDelayInMS 
0283 c9			    ret 
0284			; returns byte in a 
0284			; address in hl  
0284			se_readbyte: 
0284 d5				push de 
0285 c5				push bc 
0286			 
0286			    ;   ld c, a 
0286 e5			        push hl 
0287			 
0287			    ; initi write mode 
0287			    ; 
0287			    ;CS low 
0287			 
0287 3a c6 f9		       ld a,(spi_portbyte) 
028a cd 90 01			call spi_ce_low 
028d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028d d3 80		       out (storage_adata),a 
028f 32 c6 f9		       ld (spi_portbyte), a 
0292			 
0292			    ;clock out wren instruction 
0292			 
0292 3e 03		    ld a, store_read_ins 
0294 cd b4 00		    call spi_send_byte  
0297			 
0297			 
0297			    ; clock out address (depending on address size) 
0297			     
0297 e1			    pop hl 
0298 7c			    ld a,h    ; address out msb first 
0299 cd b4 00		    call spi_send_byte  
029c 7d			    ld a,l 
029d cd b4 00		    call spi_send_byte  
02a0			 
02a0			    ; clock in byte(s) for page 
02a0			 
02a0 cd d5 00		    call spi_read_byte  
02a3 f5				push af 
02a4			 
02a4			    ; end write with ce high 
02a4 3a c6 f9		       ld a,(spi_portbyte) 
02a7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a7 cd 7f 01			call spi_ce_high 
02aa d3 80		       out (storage_adata),a 
02ac 32 c6 f9		       ld (spi_portbyte), a 
02af			 
02af f1				pop af 
02b0			 
02b0 c1				pop bc 
02b1 d1				pop de 
02b2			 
02b2 c9			    ret 
02b3			 
02b3			if DEBUG_STORESE 
02b3			 
02b3			storageput:  
02b3			 
02b3			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b3			 
02b3 21 9c ef			ld hl,scratch+2 
02b6 cd cf 10			call get_word_hl 
02b9			 
02b9				; stuff it here for the moment as it will be overwritten later anyway 
02b9			 
02b9 22 bd f2			ld (os_cur_ptr),hl	 
02bc			 
02bc			 
02bc			; get pointer to start of string 
02bc			 
02bc 21 a1 ef			ld hl, scratch+7 
02bf			 
02bf			; loop writing char of string to eeprom 
02bf			 
02bf 7e			.writestr:	ld a,(hl) 
02c0 fe 00				cp 0 
02c2 28 12				jr z, .wsdone		; done writing 
02c4 e5					push hl 
02c5 2a bd f2				ld hl,(os_cur_ptr) 
02c8 cd e2 01				call se_writebyte 
02cb			 
02cb 2a bd f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02ce 23					inc hl 
02cf 22 bd f2				ld (os_cur_ptr),hl 
02d2			 
02d2					; restore string pointer and get next char 
02d2			 
02d2 e1					pop hl 
02d3 23					inc hl 
02d4 18 e9				jr .writestr 
02d6			 
02d6			 
02d6			 
02d6			.wsdone: 
02d6			 
02d6			 
02d6			; when done load first page into a buffer  
02d6			 
02d6 21 00 80				ld hl,08000h		; start in ram 
02d9 22 bd f2				ld (os_cur_ptr),hl 
02dc 21 00 00				ld hl, 0		 ; start of page 
02df 22 c2 ef				ld (scratch+40),hl	; hang on to it 
02e2			 
02e2 06 80				ld b, 128		; actually get more then one page 
02e4 c5			.wsload:	push bc 
02e5 2a c2 ef				ld hl,(scratch+40) 
02e8 e5					push hl 
02e9 cd 84 02				call se_readbyte 
02ec			 
02ec					; a now as the byte 
02ec			 
02ec 2a bd f2				ld hl,(os_cur_ptr) 
02ef 77					ld (hl),a 
02f0					; inc next buffer area 
02f0 23					inc hl 
02f1 22 bd f2				ld (os_cur_ptr),hl 
02f4			 
02f4					; get eeprom position, inc and save for next round 
02f4 e1					pop hl		 
02f5 23					inc hl 
02f6 22 c2 ef				ld (scratch+40),hl 
02f9 c1					pop bc 
02fa 10 e8				djnz .wsload 
02fc			 
02fc			; set 'd' pointer to start of buffer 
02fc			 
02fc 21 00 80				ld hl,08000h 
02ff 22 bd f2				ld (os_cur_ptr),hl 
0302			 
0302			 
0302 c9			ret 
0303			 
0303			 
0303 c9			storageread: ret 
0304			 
0304			 
0304			 
0304			 
0304			 
0304			 
0304			endif 
0304			 
0304			 
0304			 
# End of file firmware_seeprom.asm
0304			else  
0304			   ; create some stubs for the labels  
0304			se_readbyte: ret  
0304			se_writebyte: ret  
0304			storage_init: ret  
0304			  
0304			endif  
0304			  
0304			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0304			;include "firmware_cf.asm"  
0304			  
0304			; load up high level storage hardward abstractions  
0304			include "firmware_storage.asm"  
0304			 
0304			; persisent storage hardware abstraction layer  
0304			 
0304			 
0304			 
0304			; Block 0 on storage is a config state 
0304			 
0304			 
0304			 
0304			; TODO add read phy block and write phy block functions 
0304			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0304			 
0304			; Abstraction layer  
0304			 
0304			; Logocial block size is same size as physical size - using tape concept 
0304			 
0304			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0304			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0304			 
0304			 
0304			 
0304			; Filesystem layout (Logical layout) 
0304			; 
0304			; Block 0 - Bank config  
0304			; 
0304			;      Byte - 0 file id counter 
0304			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0304			;      Byte - 3-20 zero terminated bank label 
0304			; 
0304			; Block 1 > File storage 
0304			; 
0304			;      Byte 0 file id    - block 0 file details 
0304			;      Byte 1 block id - block 0 is file  
0304			;            Byte 2-15 - File name 
0304			; 
0304			;       - to end of block data 
0304			; 
0304			 
0304			 
0304			; Read Block 
0304			; ---------- 
0304			; 
0304			; With current bank 
0304			;  
0304			; Get block number to read 
0304			; Load physical blocks starting at start block into buffer 
0304			 
0304			; de points to buffer to use 
0304			; hl holds logical block number  
0304			 
0304			storage_read_block: 
0304			 
0304				; TODO bank selection 
0304			 
0304				; for each of the physical blocks read it into the buffer 
0304 06 40			ld b, STORE_BLOCK_PHY 
0306			 
0306				if DEBUG_STORESE 
0306 d5					push de 
0307				endif 
0307				 
0307			.rl1:    
0307			 
0307				; read physical block at hl into de 
0307			        ; increment hl and de to next read position on exit 
0307			 
0307 e5				push hl 
0308 d5				push de	 
0309 c5				push bc 
030a			;	if DEBUG_STORESE 
030a			;		push af 
030a			;		ld a, 'R' 
030a			;		ld (debug_mark),a 
030a			;		pop af 
030a			;		CALLMONITOR 
030a			;	endif 
030a cd 84 02			call se_readbyte 
030d			;	if DEBUG_STORESE 
030d			;		ld a,(spi_portbyte) 
030d			;		ld l, a 
030d			;		push af 
030d			;		ld a, '1' 
030d			;		ld (debug_mark),a 
030d			;		pop af 
030d			;		CALLMONITOR 
030d			;	endif 
030d c1				pop bc 
030e d1				pop de 
030f e1				pop hl 
0310 12				ld (de),a 
0311 23				inc hl 
0312 13				inc de 
0313			 
0313			;	if DEBUG_STORESE 
0313			;		push af 
0313			;		ld a, 'r' 
0313			;		ld (debug_mark),a 
0313			;		pop af 
0313			;		CALLMONITOR 
0313			;	endif 
0313			 
0313 10 f2			djnz .rl1 
0315			 
0315				if DEBUG_STORESE 
0315					DMARK "SRB" 
0315 f5				push af  
0316 3a 2a 03			ld a, (.dmark)  
0319 32 b4 fb			ld (debug_mark),a  
031c 3a 2b 03			ld a, (.dmark+1)  
031f 32 b5 fb			ld (debug_mark+1),a  
0322 3a 2c 03			ld a, (.dmark+2)  
0325 32 b6 fb			ld (debug_mark+2),a  
0328 18 03			jr .pastdmark  
032a ..			.dmark: db "SRB"  
032d f1			.pastdmark: pop af  
032e			endm  
# End of macro DMARK
032e d1					pop de 
032f			; 
032f			;		push af 
032f			;		ld a, 'R' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd 3d 17			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332 c9				ret	 
0333				 
0333			 
0333			; File Size 
0333			; --------- 
0333			; 
0333			;   hl file id 
0333			; 
0333			;  returns in hl the number of blocks 
0333			 
0333			storage_file_size: 
0333 5d				ld e, l 
0334 16 00			ld d, 0 
0336 21 40 00			ld hl, STORE_BLOCK_PHY 
0339					if DEBUG_FORTH_WORDS 
0339						DMARK "SIZ" 
0339 f5				push af  
033a 3a 4e 03			ld a, (.dmark)  
033d 32 b4 fb			ld (debug_mark),a  
0340 3a 4f 03			ld a, (.dmark+1)  
0343 32 b5 fb			ld (debug_mark+1),a  
0346 3a 50 03			ld a, (.dmark+2)  
0349 32 b6 fb			ld (debug_mark+2),a  
034c 18 03			jr .pastdmark  
034e ..			.dmark: db "SIZ"  
0351 f1			.pastdmark: pop af  
0352			endm  
# End of macro DMARK
0352						CALLMONITOR 
0352 cd 3d 17			call break_point_state  
0355				endm  
# End of macro CALLMONITOR
0355					endif 
0355 cd 29 06			call storage_findnextid 
0358			 
0358 cd 41 0d			call ishlzero 
035b			;	ld a, l 
035b			;	add h 
035b			;	cp 0 
035b c8				ret z			; block not found so EOF 
035c			 
035c 11 df f9			ld de, store_page 
035f cd 04 03			call storage_read_block 
0362			 
0362 3a e1 f9			ld a, (store_page+2)	 ; get extent count 
0365 6f				ld l, a 
0366 26 00			ld h, 0 
0368 c9			 	ret 
0369			 
0369			 
0369			; Write Block 
0369			; ----------- 
0369			; 
0369			; With current bank 
0369			;  
0369			; Get block number to write 
0369			; Write physical blocks starting at start block from buffer 
0369			  
0369			storage_write_block: 
0369				; TODO bank selection 
0369			 
0369				; for each of the physical blocks read it into the buffer 
0369 06 40			ld b, STORE_BLOCK_PHY 
036b			 
036b				if DEBUG_STORESE 
036b					DMARK "SWB" 
036b f5				push af  
036c 3a 80 03			ld a, (.dmark)  
036f 32 b4 fb			ld (debug_mark),a  
0372 3a 81 03			ld a, (.dmark+1)  
0375 32 b5 fb			ld (debug_mark+1),a  
0378 3a 82 03			ld a, (.dmark+2)  
037b 32 b6 fb			ld (debug_mark+2),a  
037e 18 03			jr .pastdmark  
0380 ..			.dmark: db "SWB"  
0383 f1			.pastdmark: pop af  
0384			endm  
# End of macro DMARK
0384			 
0384					;push af 
0384					;ld a, 'W' 
0384					;ld (debug_mark),a 
0384					;pop af 
0384					CALLMONITOR 
0384 cd 3d 17			call break_point_state  
0387				endm  
# End of macro CALLMONITOR
0387				endif 
0387			 
0387			; might not be working 
0387			;	call se_writepage 
0387			 
0387			;	ret 
0387			; 
0387			 
0387			 
0387			 
0387			.wl1:    
0387			 
0387				; read physical block at hl into de 
0387			        ; increment hl and de to next read position on exit 
0387			 
0387 e5				push hl 
0388 d5				push de	 
0389 c5				push bc 
038a 1a				ld a,(de) 
038b				;if DEBUG_STORESE 
038b			;		push af 
038b			;		ld a, 'W' 
038b			;		ld (debug_mark),a 
038b			;		pop af 
038b			;		CALLMONITOR 
038b			;	endif 
038b cd e2 01			call se_writebyte 
038e			;	call delay250ms 
038e 00				nop 
038f 00				nop 
0390 00				nop 
0391			;	if DEBUG_STORESE 
0391			;		push af 
0391			;		ld a, 'w' 
0391			;		ld (debug_mark),a 
0391			;		pop af 
0391			;		CALLMONITOR 
0391			;	endif 
0391 c1				pop bc 
0392 d1				pop de 
0393 e1				pop hl 
0394 23				inc hl 
0395 13				inc de 
0396			 
0396			 
0396 10 ef			djnz .wl1 
0398			 
0398				if DEBUG_STORESE 
0398					DMARK "SW2" 
0398 f5				push af  
0399 3a ad 03			ld a, (.dmark)  
039c 32 b4 fb			ld (debug_mark),a  
039f 3a ae 03			ld a, (.dmark+1)  
03a2 32 b5 fb			ld (debug_mark+1),a  
03a5 3a af 03			ld a, (.dmark+2)  
03a8 32 b6 fb			ld (debug_mark+2),a  
03ab 18 03			jr .pastdmark  
03ad ..			.dmark: db "SW2"  
03b0 f1			.pastdmark: pop af  
03b1			endm  
# End of macro DMARK
03b1			 
03b1					;push af 
03b1					;ld a, 'W' 
03b1					;ld (debug_mark),a 
03b1					;pop af 
03b1					CALLMONITOR 
03b1 cd 3d 17			call break_point_state  
03b4				endm  
# End of macro CALLMONITOR
03b4				endif 
03b4 c9				ret	 
03b5			 
03b5			; Init bank 
03b5			; --------- 
03b5			; 
03b5			; With current bank 
03b5			; 
03b5			; Setup block 0 config 
03b5			;     Set 0 file id counter 
03b5			;     Set formatted byte pattern 
03b5			;     Zero out bank label 
03b5			;      
03b5			; For every logical block write 0-1 byte as null 
03b5			 
03b5			storage_get_block_0: 
03b5			 
03b5				; TODO check presence 
03b5			 
03b5				; get block 0 config 
03b5			 
03b5 21 00 00			ld hl, 0 
03b8 11 df f9			ld de, store_page 
03bb cd 04 03			call storage_read_block 
03be			 
03be				if DEBUG_STORESE 
03be					DMARK "SB0" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 b4 fb			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 b5 fb			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 b6 fb			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB0"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7 11 df f9				ld de, store_page 
03da			;		push af 
03da			;		ld a, 'i' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da					CALLMONITOR 
03da cd 3d 17			call break_point_state  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd			 
03dd				; is this area formatted? 
03dd			 
03dd			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03dd 2a e0 f9			ld hl, (store_page+1) 
03e0 3e 80			ld a,0x80 
03e2 bd				cp l 
03e3 20 22			jr nz, .ininotformatted 
03e5				; do a double check 
03e5 3e 27			ld a, 0x27 
03e7 bc				cp h 
03e8 20 1d			jr nz, .ininotformatted 
03ea			 
03ea				; formatted then 
03ea			 
03ea				if DEBUG_STORESE 
03ea					DMARK "SB1" 
03ea f5				push af  
03eb 3a ff 03			ld a, (.dmark)  
03ee 32 b4 fb			ld (debug_mark),a  
03f1 3a 00 04			ld a, (.dmark+1)  
03f4 32 b5 fb			ld (debug_mark+1),a  
03f7 3a 01 04			ld a, (.dmark+2)  
03fa 32 b6 fb			ld (debug_mark+2),a  
03fd 18 03			jr .pastdmark  
03ff ..			.dmark: db "SB1"  
0402 f1			.pastdmark: pop af  
0403			endm  
# End of macro DMARK
0403					;push af 
0403					;ld a, 'I' 
0403					;ld (debug_mark),a 
0403					;pop af 
0403					CALLMONITOR 
0403 cd 3d 17			call break_point_state  
0406				endm  
# End of macro CALLMONITOR
0406				endif 
0406 c9				ret 
0407			 
0407			.ininotformatted: 
0407				; bank not formatted so poke various bits to make sure 
0407			 
0407				if DEBUG_STORESE 
0407					DMARK "SB2" 
0407 f5				push af  
0408 3a 1c 04			ld a, (.dmark)  
040b 32 b4 fb			ld (debug_mark),a  
040e 3a 1d 04			ld a, (.dmark+1)  
0411 32 b5 fb			ld (debug_mark+1),a  
0414 3a 1e 04			ld a, (.dmark+2)  
0417 32 b6 fb			ld (debug_mark+2),a  
041a 18 03			jr .pastdmark  
041c ..			.dmark: db "SB2"  
041f f1			.pastdmark: pop af  
0420			endm  
# End of macro DMARK
0420					;push af 
0420					;ld a, 'f' 
0420					;ld (debug_mark),a 
0420					;pop af 
0420					CALLMONITOR 
0420 cd 3d 17			call break_point_state  
0423				endm  
# End of macro CALLMONITOR
0423				endif 
0423			 
0423 cd 24 0a			call storage_clear_page 
0426			 
0426 21 df f9			ld hl, store_page 
0429 3e 00			ld a, 0 
042b				 
042b 77				ld (hl),a   ; reset file counter 
042c			 
042c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
042f 22 e0 f9		 	ld (store_page+1), hl	 
0432			 
0432				; set default label 
0432			 
0432 21 ce 04			ld hl, .defaultbanklabl 
0435 11 e2 f9		 	ld de, store_page+3 
0438 01 0f 00			ld bc, 15 
043b ed b0			ldir 
043d			 
043d				; Append the current bank id 
043d 21 eb f9			ld hl, store_page+3+9 
0440 3a c4 f9			ld a, (spi_device_id) 
0443 77				ld (hl), a 
0444			 
0444				; save default page 0 
0444			 
0444 21 00 00			ld hl, 0 
0447 11 df f9			ld de, store_page 
044a				if DEBUG_STORESE 
044a					DMARK "SB3" 
044a f5				push af  
044b 3a 5f 04			ld a, (.dmark)  
044e 32 b4 fb			ld (debug_mark),a  
0451 3a 60 04			ld a, (.dmark+1)  
0454 32 b5 fb			ld (debug_mark+1),a  
0457 3a 61 04			ld a, (.dmark+2)  
045a 32 b6 fb			ld (debug_mark+2),a  
045d 18 03			jr .pastdmark  
045f ..			.dmark: db "SB3"  
0462 f1			.pastdmark: pop af  
0463			endm  
# End of macro DMARK
0463			;		push af 
0463			;		ld a, 'F' 
0463			;		ld (debug_mark),a 
0463			;		pop af 
0463					CALLMONITOR 
0463 cd 3d 17			call break_point_state  
0466				endm  
# End of macro CALLMONITOR
0466				endif 
0466 cd 69 03			call storage_write_block 
0469				if DEBUG_STORESE 
0469					DMARK "SB4" 
0469 f5				push af  
046a 3a 7e 04			ld a, (.dmark)  
046d 32 b4 fb			ld (debug_mark),a  
0470 3a 7f 04			ld a, (.dmark+1)  
0473 32 b5 fb			ld (debug_mark+1),a  
0476 3a 80 04			ld a, (.dmark+2)  
0479 32 b6 fb			ld (debug_mark+2),a  
047c 18 03			jr .pastdmark  
047e ..			.dmark: db "SB4"  
0481 f1			.pastdmark: pop af  
0482			endm  
# End of macro DMARK
0482			;		push af 
0482			;		ld a, '>' 
0482			;		ld (debug_mark),a 
0482			;		pop af 
0482					CALLMONITOR 
0482 cd 3d 17			call break_point_state  
0485				endm  
# End of macro CALLMONITOR
0485				endif 
0485			 
0485 00				nop 
0486 00				nop 
0487 00				nop 
0488			 
0488				; now set 0 in every page to mark as a free block 
0488			 
0488 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048a 21 40 00			ld hl, STORE_BLOCK_PHY 
048d			 
048d 3e 00		.setmark1:   	ld a,0 
048f e5					push hl 
0490 c5					push bc 
0491 cd e2 01				call se_writebyte 
0494 3e 0a			ld a, 10 
0496 cd 46 0a			call aDelayInMS 
0499 23				inc hl 
049a cd e2 01				call se_writebyte 
049d 3e 0a			ld a, 10 
049f cd 46 0a			call aDelayInMS 
04a2 2b				dec hl 
04a3 c1					pop bc 
04a4 e1					pop hl 
04a5 3e 40				ld a, STORE_BLOCK_PHY 
04a7 cd 18 0d				call addatohl 
04aa 10 e1				djnz .setmark1 
04ac			 
04ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04ae 3e 00		.setmark2:   	ld a,0 
04b0 e5					push hl 
04b1 c5					push bc 
04b2 cd e2 01				call se_writebyte 
04b5 3e 0a			ld a, 10 
04b7 cd 46 0a			call aDelayInMS 
04ba 23				inc hl 
04bb cd e2 01				call se_writebyte 
04be 3e 0a			ld a, 10 
04c0 cd 46 0a			call aDelayInMS 
04c3 2b				dec hl 
04c4 c1					pop bc 
04c5 e1					pop hl 
04c6 3e 40				ld a, STORE_BLOCK_PHY 
04c8 cd 18 0d				call addatohl 
04cb 10 e1				djnz .setmark2 
04cd			 
04cd					 
04cd			 
04cd			 
04cd c9				ret 
04ce			 
04ce			 
04ce			 
04ce			 
04ce .. 00		.defaultbanklabl:   db "BankLabel_",0 
04d9			 
04d9			 
04d9			 
04d9			; Label Bank 
04d9			; ---------- 
04d9			; 
04d9			; With current bank 
04d9			; Read block 0 
04d9			; Set label 
04d9			; Write block 0 
04d9			 
04d9			; label str pointer in hl 
04d9			 
04d9			storage_label:     
04d9			 
04d9				if DEBUG_STORESE 
04d9					DMARK "LBL" 
04d9 f5				push af  
04da 3a ee 04			ld a, (.dmark)  
04dd 32 b4 fb			ld (debug_mark),a  
04e0 3a ef 04			ld a, (.dmark+1)  
04e3 32 b5 fb			ld (debug_mark+1),a  
04e6 3a f0 04			ld a, (.dmark+2)  
04e9 32 b6 fb			ld (debug_mark+2),a  
04ec 18 03			jr .pastdmark  
04ee ..			.dmark: db "LBL"  
04f1 f1			.pastdmark: pop af  
04f2			endm  
# End of macro DMARK
04f2					CALLMONITOR 
04f2 cd 3d 17			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5 e5				push hl 
04f6			 
04f6 cd b5 03			call storage_get_block_0 
04f9			 
04f9				; set default label 
04f9			 
04f9 e1				pop hl 
04fa			 
04fa 11 e2 f9		 	ld de, store_page+3 
04fd 01 0f 00			ld bc, 15 
0500				if DEBUG_STORESE 
0500					DMARK "LB3" 
0500 f5				push af  
0501 3a 15 05			ld a, (.dmark)  
0504 32 b4 fb			ld (debug_mark),a  
0507 3a 16 05			ld a, (.dmark+1)  
050a 32 b5 fb			ld (debug_mark+1),a  
050d 3a 17 05			ld a, (.dmark+2)  
0510 32 b6 fb			ld (debug_mark+2),a  
0513 18 03			jr .pastdmark  
0515 ..			.dmark: db "LB3"  
0518 f1			.pastdmark: pop af  
0519			endm  
# End of macro DMARK
0519					CALLMONITOR 
0519 cd 3d 17			call break_point_state  
051c				endm  
# End of macro CALLMONITOR
051c				endif 
051c ed b0			ldir 
051e				; save default page 0 
051e			 
051e 21 00 00			ld hl, 0 
0521 11 df f9			ld de, store_page 
0524				if DEBUG_STORESE 
0524					DMARK "LBW" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 b4 fb			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 b5 fb			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 b6 fb			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "LBW"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d					CALLMONITOR 
053d cd 3d 17			call break_point_state  
0540				endm  
# End of macro CALLMONITOR
0540				endif 
0540 cd 69 03			call storage_write_block 
0543			 
0543 c9				ret 
0544			 
0544			 
0544			 
0544			; Read Block 0 - Config 
0544			; --------------------- 
0544			; 
0544			; With current bank 
0544			; Call presence test 
0544			;    If not present format/init bank  
0544			; Read block 0  
0544			;  
0544			 
0544			 
0544			; Dir 
0544			; --- 
0544			; 
0544			; With current bank 
0544			; Load Block 0 Config 
0544			; Get max file id number 
0544			; For each logical block 
0544			;    Read block read byte 2 
0544			;      if first block of file 
0544			;         Display file name 
0544			;         Display type flags for file 
0544			;        
0544			 
0544			; moving to words as this requires stack control 
0544			 
0544			 
0544			; Delete File 
0544			; ----------- 
0544			; 
0544			; With current bank 
0544			; 
0544			; Load Block 0 Config 
0544			; Get max file id number 
0544			; For each logical block 
0544			;    Read block file id 
0544			;      If first block of file and dont have file id 
0544			;         if file to delete 
0544			;         Save file id 
0544			;         Null file id 
0544			;         Write this block back 
0544			;      If file id is one saved 
0544			;         Null file id 
0544			;         Write this block back 
0544			 
0544			storage_erase: 
0544			 
0544				; hl contains the file id 
0544			 
0544 5d				ld e, l 
0545 16 00			ld d, 0 
0547 21 40 00			ld hl, STORE_BLOCK_PHY 
054a					if DEBUG_FORTH_WORDS 
054a						DMARK "ERA" 
054a f5				push af  
054b 3a 5f 05			ld a, (.dmark)  
054e 32 b4 fb			ld (debug_mark),a  
0551 3a 60 05			ld a, (.dmark+1)  
0554 32 b5 fb			ld (debug_mark+1),a  
0557 3a 61 05			ld a, (.dmark+2)  
055a 32 b6 fb			ld (debug_mark+2),a  
055d 18 03			jr .pastdmark  
055f ..			.dmark: db "ERA"  
0562 f1			.pastdmark: pop af  
0563			endm  
# End of macro DMARK
0563						CALLMONITOR 
0563 cd 3d 17			call break_point_state  
0566				endm  
# End of macro CALLMONITOR
0566					endif 
0566 cd 29 06			call storage_findnextid 
0569 cd 41 0d			call ishlzero 
056c c8				ret z 
056d			 
056d e5				push hl 
056e			 
056e				; TODO check file not found 
056e			 
056e 11 df f9			ld de, store_page 
0571 cd 04 03			call storage_read_block 
0574			 
0574					if DEBUG_FORTH_WORDS 
0574						DMARK "ER1" 
0574 f5				push af  
0575 3a 89 05			ld a, (.dmark)  
0578 32 b4 fb			ld (debug_mark),a  
057b 3a 8a 05			ld a, (.dmark+1)  
057e 32 b5 fb			ld (debug_mark+1),a  
0581 3a 8b 05			ld a, (.dmark+2)  
0584 32 b6 fb			ld (debug_mark+2),a  
0587 18 03			jr .pastdmark  
0589 ..			.dmark: db "ER1"  
058c f1			.pastdmark: pop af  
058d			endm  
# End of macro DMARK
058d						CALLMONITOR 
058d cd 3d 17			call break_point_state  
0590				endm  
# End of macro CALLMONITOR
0590					endif 
0590 3a df f9			ld a, (store_page)	; get file id 
0593 32 d8 f9			ld (store_tmpid), a 
0596			 
0596 3a e1 f9			ld a, (store_page+2)    ; get count of extends 
0599 32 d7 f9			ld (store_tmpext), a 
059c			 
059c				; wipe file header 
059c			 
059c e1				pop hl 
059d 3e 00			ld a, 0 
059f 32 df f9			ld (store_page), a 
05a2 32 e0 f9			ld (store_page+1),a 
05a5 11 df f9			ld de, store_page 
05a8					if DEBUG_FORTH_WORDS 
05a8						DMARK "ER2" 
05a8 f5				push af  
05a9 3a bd 05			ld a, (.dmark)  
05ac 32 b4 fb			ld (debug_mark),a  
05af 3a be 05			ld a, (.dmark+1)  
05b2 32 b5 fb			ld (debug_mark+1),a  
05b5 3a bf 05			ld a, (.dmark+2)  
05b8 32 b6 fb			ld (debug_mark+2),a  
05bb 18 03			jr .pastdmark  
05bd ..			.dmark: db "ER2"  
05c0 f1			.pastdmark: pop af  
05c1			endm  
# End of macro DMARK
05c1						CALLMONITOR 
05c1 cd 3d 17			call break_point_state  
05c4				endm  
# End of macro CALLMONITOR
05c4					endif 
05c4 cd 69 03			call storage_write_block 
05c7			 
05c7			 
05c7				; wipe file extents 
05c7			 
05c7 3a d7 f9			ld a, (store_tmpext) 
05ca 47				ld b, a 
05cb			 
05cb			.eraext:	  
05cb c5				push bc 
05cc			 
05cc 21 40 00			ld hl, STORE_BLOCK_PHY 
05cf 3a d8 f9			ld a,(store_tmpid) 
05d2 5f				ld e, a 
05d3 50				ld d, b	 
05d4					if DEBUG_FORTH_WORDS 
05d4						DMARK "ER3" 
05d4 f5				push af  
05d5 3a e9 05			ld a, (.dmark)  
05d8 32 b4 fb			ld (debug_mark),a  
05db 3a ea 05			ld a, (.dmark+1)  
05de 32 b5 fb			ld (debug_mark+1),a  
05e1 3a eb 05			ld a, (.dmark+2)  
05e4 32 b6 fb			ld (debug_mark+2),a  
05e7 18 03			jr .pastdmark  
05e9 ..			.dmark: db "ER3"  
05ec f1			.pastdmark: pop af  
05ed			endm  
# End of macro DMARK
05ed						CALLMONITOR 
05ed cd 3d 17			call break_point_state  
05f0				endm  
# End of macro CALLMONITOR
05f0					endif 
05f0 cd 29 06			call storage_findnextid 
05f3			 
05f3 e5				push hl 
05f4 11 df f9			ld de, store_page 
05f7 cd 04 03			call storage_read_block 
05fa			 
05fa				; free block	 
05fa			 
05fa 3e 00			ld a, 0 
05fc 32 df f9			ld (store_page), a 
05ff 32 e0 f9			ld (store_page+1),a 
0602 11 df f9			ld de, store_page 
0605 e1				pop hl 
0606					if DEBUG_FORTH_WORDS 
0606						DMARK "ER4" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 b4 fb			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 b5 fb			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 b6 fb			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "ER4"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f						CALLMONITOR 
061f cd 3d 17			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622 cd 69 03			call storage_write_block 
0625			 
0625 c1				pop bc 
0626 10 a3			djnz .eraext 
0628			 
0628 c9				ret 
0629			 
0629			 
0629			; Find Free Block 
0629			; --------------- 
0629			; 
0629			; With current bank 
0629			;  
0629			; From given starting logical block 
0629			;    Read block  
0629			;    If no file id 
0629			;         Return block id 
0629			 
0629			 
0629			; hl starting page number 
0629			; hl contains free page number or zero if no pages free 
0629			; e contains the file id to locate 
0629			; d contains the block number 
0629			 
0629			; TODO change to find file id and use zero for free block 
0629			 
0629			storage_findnextid: 
0629			 
0629				; now locate first 0 page to mark as a free block 
0629			 
0629 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062b			;	ld hl, STORE_BLOCK_PHY 
062b			 
062b					if DEBUG_FORTH_WORDS 
062b					DMARK "FNI" 
062b f5				push af  
062c 3a 40 06			ld a, (.dmark)  
062f 32 b4 fb			ld (debug_mark),a  
0632 3a 41 06			ld a, (.dmark+1)  
0635 32 b5 fb			ld (debug_mark+1),a  
0638 3a 42 06			ld a, (.dmark+2)  
063b 32 b6 fb			ld (debug_mark+2),a  
063e 18 03			jr .pastdmark  
0640 ..			.dmark: db "FNI"  
0643 f1			.pastdmark: pop af  
0644			endm  
# End of macro DMARK
0644						CALLMONITOR 
0644 cd 3d 17			call break_point_state  
0647				endm  
# End of macro CALLMONITOR
0647					endif 
0647			.ff1:   	 
0647 e5					push hl 
0648 c5					push bc 
0649 d5					push de 
064a cd 84 02				call se_readbyte 
064d 5f					ld e,a 
064e 23					inc hl 
064f cd 84 02				call se_readbyte 
0652 57					ld d, a 
0653 e1					pop hl 
0654 e5					push hl 
0655 cd 36 0d				call cmp16 
0658 28 49				jr z, .fffound 
065a			 
065a d1					pop de 
065b c1					pop bc 
065c e1					pop hl 
065d			 
065d					; is found? 
065d					;cp e 
065d					;ret z 
065d			 
065d 3e 40				ld a, STORE_BLOCK_PHY 
065f cd 18 0d				call addatohl 
0662 10 e3				djnz .ff1 
0664			 
0664 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0666			.ff2:   	 
0666			 
0666 e5					push hl 
0667 c5					push bc 
0668 d5					push de 
0669 cd 84 02				call se_readbyte 
066c 5f					ld e,a 
066d 23					inc hl 
066e cd 84 02				call se_readbyte 
0671 57					ld d, a 
0672			 
0672 e1					pop hl 
0673 e5					push hl 
0674 cd 36 0d				call cmp16 
0677 28 2a				jr z, .fffound 
0679			 
0679 d1					pop de 
067a c1					pop bc 
067b e1					pop hl 
067c					; is found? 
067c					;cp e 
067c					;ret z 
067c			 
067c 3e 40				ld a, STORE_BLOCK_PHY 
067e cd 18 0d				call addatohl 
0681 10 e3				djnz .ff2 
0683			 
0683			 
0683					if DEBUG_FORTH_WORDS 
0683					DMARK "FN-" 
0683 f5				push af  
0684 3a 98 06			ld a, (.dmark)  
0687 32 b4 fb			ld (debug_mark),a  
068a 3a 99 06			ld a, (.dmark+1)  
068d 32 b5 fb			ld (debug_mark+1),a  
0690 3a 9a 06			ld a, (.dmark+2)  
0693 32 b6 fb			ld (debug_mark+2),a  
0696 18 03			jr .pastdmark  
0698 ..			.dmark: db "FN-"  
069b f1			.pastdmark: pop af  
069c			endm  
# End of macro DMARK
069c					;	push af 
069c					;	ld a, 'n' 
069c					;	ld (debug_mark),a 
069c					;	pop af 
069c						CALLMONITOR 
069c cd 3d 17			call break_point_state  
069f				endm  
# End of macro CALLMONITOR
069f					endif 
069f				; no free marks! 
069f 21 00 00				ld hl, 0 
06a2 c9				ret 
06a3			.fffound: 
06a3				 
06a3			 
06a3 d1					pop de 
06a4 c1					pop bc 
06a5 e1					pop hl 
06a6					if DEBUG_FORTH_WORDS 
06a6					DMARK "FNF" 
06a6 f5				push af  
06a7 3a bb 06			ld a, (.dmark)  
06aa 32 b4 fb			ld (debug_mark),a  
06ad 3a bc 06			ld a, (.dmark+1)  
06b0 32 b5 fb			ld (debug_mark+1),a  
06b3 3a bd 06			ld a, (.dmark+2)  
06b6 32 b6 fb			ld (debug_mark+2),a  
06b9 18 03			jr .pastdmark  
06bb ..			.dmark: db "FNF"  
06be f1			.pastdmark: pop af  
06bf			endm  
# End of macro DMARK
06bf					;	push af 
06bf					;	ld a, 'n' 
06bf					;	ld (debug_mark),a 
06bf					;	pop af 
06bf						CALLMONITOR 
06bf cd 3d 17			call break_point_state  
06c2				endm  
# End of macro CALLMONITOR
06c2					endif 
06c2 c9				ret 
06c3			 
06c3			 
06c3			 
06c3			; Free Space 
06c3			; ---------- 
06c3			; 
06c3			; With current bank 
06c3			; 
06c3			; Set block count to zero 
06c3			; Starting with first logical block 
06c3			;      Find free block  
06c3			;      If block id given, increment block count 
06c3			; 
06c3			;  
06c3			 
06c3			 
06c3			; hl contains count of free blocks 
06c3			 
06c3			storage_freeblocks: 
06c3			 
06c3				; now locate first 0 page to mark as a free block 
06c3			 
06c3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c5 21 40 00			ld hl, STORE_BLOCK_PHY 
06c8 11 00 00			ld de, 0 
06cb			 
06cb			.fb1:   	 
06cb e5					push hl 
06cc c5					push bc 
06cd d5					push de 
06ce cd 84 02				call se_readbyte 
06d1 d1					pop de 
06d2 c1					pop bc 
06d3 e1					pop hl 
06d4			 
06d4					; is free? 
06d4 fe 00				cp 0 
06d6 20 01				jr nz, .ff1cont 
06d8 13					inc de 
06d9			 
06d9			.ff1cont: 
06d9			 
06d9			 
06d9 3e 40				ld a, STORE_BLOCK_PHY 
06db cd 18 0d				call addatohl 
06de 10 eb				djnz .fb1 
06e0			 
06e0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e2			.fb2:   	 
06e2 e5					push hl 
06e3 c5					push bc 
06e4 d5					push de 
06e5 cd 84 02				call se_readbyte 
06e8 d1					pop de 
06e9 c1					pop bc 
06ea e1					pop hl 
06eb			 
06eb					; is free? 
06eb fe 00				cp 0 
06ed 20 01				jr nz, .ff2cont 
06ef 13					inc de 
06f0			 
06f0			.ff2cont: 
06f0			 
06f0 3e 40				ld a, STORE_BLOCK_PHY 
06f2 cd 18 0d				call addatohl 
06f5 10 eb				djnz .fb2 
06f7			 
06f7 eb				ex de, hl 
06f8 c9				ret 
06f9			 
06f9			; Get File ID 
06f9			; ----------- 
06f9			; 
06f9			; With current bank 
06f9			;  
06f9			; Load Block 0 Config 
06f9			; Get max file id number 
06f9			; For each logical block 
06f9			;    Read block file id 
06f9			;      If first block of file and dont have file id 
06f9			;         if file get id and exit 
06f9			 
06f9			 
06f9			 
06f9			 
06f9			; Create File 
06f9			; ----------- 
06f9			; 
06f9			; With current bank  
06f9			; Load Block 0 Config 
06f9			; Get max file id number 
06f9			; Increment file id number 
06f9			; Save Config 
06f9			; Find free block 
06f9			; Set buffer with file name and file id 
06f9			; Write buffer to free block  
06f9			 
06f9			 
06f9			; hl point to file name 
06f9			; hl returns file id 
06f9			 
06f9			; file format: 
06f9			; byte 0 - file id 
06f9			; byte 1 - extent number 
06f9			; byte 2-> data 
06f9			 
06f9			; format for extent number 0: 
06f9			; 
06f9			; byte 0 - file id 
06f9			; byte 1 - extent 0 
06f9			; byte 2 - extent count 
06f9			; byte 3 -> file name and meta data 
06f9			 
06f9			 
06f9			storage_create: 
06f9				if DEBUG_STORESE 
06f9					DMARK "SCR" 
06f9 f5				push af  
06fa 3a 0e 07			ld a, (.dmark)  
06fd 32 b4 fb			ld (debug_mark),a  
0700 3a 0f 07			ld a, (.dmark+1)  
0703 32 b5 fb			ld (debug_mark+1),a  
0706 3a 10 07			ld a, (.dmark+2)  
0709 32 b6 fb			ld (debug_mark+2),a  
070c 18 03			jr .pastdmark  
070e ..			.dmark: db "SCR"  
0711 f1			.pastdmark: pop af  
0712			endm  
# End of macro DMARK
0712					CALLMONITOR 
0712 cd 3d 17			call break_point_state  
0715				endm  
# End of macro CALLMONITOR
0715				endif 
0715			 
0715 e5				push hl		; save file name pointer 
0716			 
0716 cd b5 03			call storage_get_block_0 
0719			 
0719 3a df f9			ld a,(store_page)	; get current file id 
071c 3c				inc a 
071d 32 df f9			ld (store_page),a 
0720				 
0720 32 d8 f9			ld (store_tmpid),a			; save id 
0723			 
0723 21 00 00			ld hl, 0 
0726 11 df f9			ld de, store_page 
0729				if DEBUG_STORESE 
0729					DMARK "SCw" 
0729 f5				push af  
072a 3a 3e 07			ld a, (.dmark)  
072d 32 b4 fb			ld (debug_mark),a  
0730 3a 3f 07			ld a, (.dmark+1)  
0733 32 b5 fb			ld (debug_mark+1),a  
0736 3a 40 07			ld a, (.dmark+2)  
0739 32 b6 fb			ld (debug_mark+2),a  
073c 18 03			jr .pastdmark  
073e ..			.dmark: db "SCw"  
0741 f1			.pastdmark: pop af  
0742			endm  
# End of macro DMARK
0742					CALLMONITOR 
0742 cd 3d 17			call break_point_state  
0745				endm  
# End of macro CALLMONITOR
0745				endif 
0745 cd 69 03			call storage_write_block	 ; save update 
0748			 
0748				if DEBUG_STORESE 
0748 11 df f9				ld de, store_page 
074b					DMARK "SCC" 
074b f5				push af  
074c 3a 60 07			ld a, (.dmark)  
074f 32 b4 fb			ld (debug_mark),a  
0752 3a 61 07			ld a, (.dmark+1)  
0755 32 b5 fb			ld (debug_mark+1),a  
0758 3a 62 07			ld a, (.dmark+2)  
075b 32 b6 fb			ld (debug_mark+2),a  
075e 18 03			jr .pastdmark  
0760 ..			.dmark: db "SCC"  
0763 f1			.pastdmark: pop af  
0764			endm  
# End of macro DMARK
0764					CALLMONITOR 
0764 cd 3d 17			call break_point_state  
0767				endm  
# End of macro CALLMONITOR
0767				endif 
0767				;  
0767				 
0767 21 40 00			ld hl, STORE_BLOCK_PHY 
076a 11 00 00			ld de, 0 
076d cd 29 06			call storage_findnextid 
0770			 
0770 22 c9 f9			ld (store_tmppageid), hl    ; save page to use  
0773			 
0773				; TODO detect 0 = no spare blocks 
0773			 
0773				; hl now contains the free page to use for the file header page 
0773			 
0773				if DEBUG_STORESE 
0773				DMARK "SCF" 
0773 f5				push af  
0774 3a 88 07			ld a, (.dmark)  
0777 32 b4 fb			ld (debug_mark),a  
077a 3a 89 07			ld a, (.dmark+1)  
077d 32 b5 fb			ld (debug_mark+1),a  
0780 3a 8a 07			ld a, (.dmark+2)  
0783 32 b6 fb			ld (debug_mark+2),a  
0786 18 03			jr .pastdmark  
0788 ..			.dmark: db "SCF"  
078b f1			.pastdmark: pop af  
078c			endm  
# End of macro DMARK
078c					CALLMONITOR 
078c cd 3d 17			call break_point_state  
078f				endm  
# End of macro CALLMONITOR
078f				endif 
078f			 
078f 22 c9 f9			ld (store_tmppageid), hl 
0792				 
0792 3a d8 f9			ld a,(store_tmpid)    ; get file id 
0795			;	ld a, (store_filecache)			; save to cache 
0795			 
0795 32 df f9			ld (store_page),a    ; set page id 
0798 3e 00			ld a, 0			 ; extent 0 is file header 
079a 32 e0 f9			ld (store_page+1), a   ; set file extent 
079d			 
079d 32 e1 f9			ld (store_page+2), a   ; extent count for the file 
07a0			 
07a0			;	inc hl 		; init block 0 of file 
07a0			;	inc hl   		; skip file and extent id 
07a0			 ;       ld a, 0 
07a0			;	ld (hl),a 
07a0			;	ld a, (store_filecache+1)  	; save to cache 
07a0			 
07a0			;	inc hl    ; file name 
07a0				 
07a0				 
07a0 11 e2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a3				if DEBUG_STORESE 
07a3					DMARK "SCc" 
07a3 f5				push af  
07a4 3a b8 07			ld a, (.dmark)  
07a7 32 b4 fb			ld (debug_mark),a  
07aa 3a b9 07			ld a, (.dmark+1)  
07ad 32 b5 fb			ld (debug_mark+1),a  
07b0 3a ba 07			ld a, (.dmark+2)  
07b3 32 b6 fb			ld (debug_mark+2),a  
07b6 18 03			jr .pastdmark  
07b8 ..			.dmark: db "SCc"  
07bb f1			.pastdmark: pop af  
07bc			endm  
# End of macro DMARK
07bc					CALLMONITOR 
07bc cd 3d 17			call break_point_state  
07bf				endm  
# End of macro CALLMONITOR
07bf				endif 
07bf e1				pop hl    ; get zero term string 
07c0 e5				push hl 
07c1 3e 00			ld a, 0 
07c3 cd 81 11			call strlent 
07c6 23				inc hl   ; cover zero term 
07c7 06 00			ld b,0 
07c9 4d				ld c,l 
07ca e1				pop hl 
07cb				;ex de, hl 
07cb				if DEBUG_STORESE 
07cb					DMARK "SCa" 
07cb f5				push af  
07cc 3a e0 07			ld a, (.dmark)  
07cf 32 b4 fb			ld (debug_mark),a  
07d2 3a e1 07			ld a, (.dmark+1)  
07d5 32 b5 fb			ld (debug_mark+1),a  
07d8 3a e2 07			ld a, (.dmark+2)  
07db 32 b6 fb			ld (debug_mark+2),a  
07de 18 03			jr .pastdmark  
07e0 ..			.dmark: db "SCa"  
07e3 f1			.pastdmark: pop af  
07e4			endm  
# End of macro DMARK
07e4					;push af 
07e4					;ld a, 'a' 
07e4					;ld (debug_mark),a 
07e4					;pop af 
07e4					CALLMONITOR 
07e4 cd 3d 17			call break_point_state  
07e7				endm  
# End of macro CALLMONITOR
07e7				endif 
07e7 ed b0			ldir    ; copy zero term string 
07e9				if DEBUG_STORESE 
07e9					DMARK "SCA" 
07e9 f5				push af  
07ea 3a fe 07			ld a, (.dmark)  
07ed 32 b4 fb			ld (debug_mark),a  
07f0 3a ff 07			ld a, (.dmark+1)  
07f3 32 b5 fb			ld (debug_mark+1),a  
07f6 3a 00 08			ld a, (.dmark+2)  
07f9 32 b6 fb			ld (debug_mark+2),a  
07fc 18 03			jr .pastdmark  
07fe ..			.dmark: db "SCA"  
0801 f1			.pastdmark: pop af  
0802			endm  
# End of macro DMARK
0802					CALLMONITOR 
0802 cd 3d 17			call break_point_state  
0805				endm  
# End of macro CALLMONITOR
0805				endif 
0805			 
0805				; write file header page 
0805			 
0805 2a c9 f9			ld hl,(store_tmppageid) 
0808 11 df f9			ld de, store_page 
080b				if DEBUG_STORESE 
080b					DMARK "SCb" 
080b f5				push af  
080c 3a 20 08			ld a, (.dmark)  
080f 32 b4 fb			ld (debug_mark),a  
0812 3a 21 08			ld a, (.dmark+1)  
0815 32 b5 fb			ld (debug_mark+1),a  
0818 3a 22 08			ld a, (.dmark+2)  
081b 32 b6 fb			ld (debug_mark+2),a  
081e 18 03			jr .pastdmark  
0820 ..			.dmark: db "SCb"  
0823 f1			.pastdmark: pop af  
0824			endm  
# End of macro DMARK
0824					;push af 
0824					;ld a, 'b' 
0824					;ld (debug_mark),a 
0824					;pop af 
0824					CALLMONITOR 
0824 cd 3d 17			call break_point_state  
0827				endm  
# End of macro CALLMONITOR
0827				endif 
0827 cd 69 03			call storage_write_block 
082a			 
082a 3a d8 f9			ld a, (store_tmpid) 
082d 6f				ld l, a 
082e 26 00			ld h,0 
0830				if DEBUG_STORESE 
0830					DMARK "SCz" 
0830 f5				push af  
0831 3a 45 08			ld a, (.dmark)  
0834 32 b4 fb			ld (debug_mark),a  
0837 3a 46 08			ld a, (.dmark+1)  
083a 32 b5 fb			ld (debug_mark+1),a  
083d 3a 47 08			ld a, (.dmark+2)  
0840 32 b6 fb			ld (debug_mark+2),a  
0843 18 03			jr .pastdmark  
0845 ..			.dmark: db "SCz"  
0848 f1			.pastdmark: pop af  
0849			endm  
# End of macro DMARK
0849					CALLMONITOR 
0849 cd 3d 17			call break_point_state  
084c				endm  
# End of macro CALLMONITOR
084c				endif 
084c c9				ret 
084d				 
084d			 
084d			 
084d			; 
084d			; Read File 
084d			; 
084d			; h - file id to locate 
084d			; l - extent to locate 
084d			; de - pointer to string to read into 
084d			; 
084d			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084d			 
084d			.sr_fail: 
084d d1				pop de 
084e c9				ret 
084f			 
084f			storage_read: 
084f d5				push de 
0850			 
0850			; TODO BUG the above push is it popped before the RET Z? 
0850			 
0850			; TODO how to handle multiple part blocks 
0850			 
0850				; locate file extent to read 
0850			 
0850 5c				ld e, h 
0851 55				ld d, l 
0852 21 40 00			ld hl, STORE_BLOCK_PHY 
0855				if DEBUG_STORESE 
0855					DMARK "SRE" 
0855 f5				push af  
0856 3a 6a 08			ld a, (.dmark)  
0859 32 b4 fb			ld (debug_mark),a  
085c 3a 6b 08			ld a, (.dmark+1)  
085f 32 b5 fb			ld (debug_mark+1),a  
0862 3a 6c 08			ld a, (.dmark+2)  
0865 32 b6 fb			ld (debug_mark+2),a  
0868 18 03			jr .pastdmark  
086a ..			.dmark: db "SRE"  
086d f1			.pastdmark: pop af  
086e			endm  
# End of macro DMARK
086e					CALLMONITOR 
086e cd 3d 17			call break_point_state  
0871				endm  
# End of macro CALLMONITOR
0871				endif 
0871 cd 29 06			call storage_findnextid 
0874			 
0874				if DEBUG_STORESE 
0874					DMARK "SRf" 
0874 f5				push af  
0875 3a 89 08			ld a, (.dmark)  
0878 32 b4 fb			ld (debug_mark),a  
087b 3a 8a 08			ld a, (.dmark+1)  
087e 32 b5 fb			ld (debug_mark+1),a  
0881 3a 8b 08			ld a, (.dmark+2)  
0884 32 b6 fb			ld (debug_mark+2),a  
0887 18 03			jr .pastdmark  
0889 ..			.dmark: db "SRf"  
088c f1			.pastdmark: pop af  
088d			endm  
# End of macro DMARK
088d					CALLMONITOR 
088d cd 3d 17			call break_point_state  
0890				endm  
# End of macro CALLMONITOR
0890				endif 
0890 cd 41 0d			call ishlzero 
0893			;	ld a, l 
0893			;	add h 
0893			;	cp 0 
0893 28 b8			jr z,.sr_fail			; block not found so EOF 
0895			 
0895				; hl contains page number to load 
0895 d1				pop de   ; get storage 
0896 d5				push de 
0897				if DEBUG_STORESE 
0897					DMARK "SRg" 
0897 f5				push af  
0898 3a ac 08			ld a, (.dmark)  
089b 32 b4 fb			ld (debug_mark),a  
089e 3a ad 08			ld a, (.dmark+1)  
08a1 32 b5 fb			ld (debug_mark+1),a  
08a4 3a ae 08			ld a, (.dmark+2)  
08a7 32 b6 fb			ld (debug_mark+2),a  
08aa 18 03			jr .pastdmark  
08ac ..			.dmark: db "SRg"  
08af f1			.pastdmark: pop af  
08b0			endm  
# End of macro DMARK
08b0					CALLMONITOR 
08b0 cd 3d 17			call break_point_state  
08b3				endm  
# End of macro CALLMONITOR
08b3				endif 
08b3 cd 04 03			call storage_read_block 
08b6			 
08b6			 
08b6			; TODO if block has no zeros then need to read next block  
08b6			 
08b6			 
08b6					 
08b6 e1				pop hl 		 ; return start of data to show as not EOF 
08b7 23				inc hl   ; past file id 
08b8 23				inc hl   ; past ext 
08b9				if DEBUG_STORESE 
08b9					DMARK "SRe" 
08b9 f5				push af  
08ba 3a ce 08			ld a, (.dmark)  
08bd 32 b4 fb			ld (debug_mark),a  
08c0 3a cf 08			ld a, (.dmark+1)  
08c3 32 b5 fb			ld (debug_mark+1),a  
08c6 3a d0 08			ld a, (.dmark+2)  
08c9 32 b6 fb			ld (debug_mark+2),a  
08cc 18 03			jr .pastdmark  
08ce ..			.dmark: db "SRe"  
08d1 f1			.pastdmark: pop af  
08d2			endm  
# End of macro DMARK
08d2					CALLMONITOR 
08d2 cd 3d 17			call break_point_state  
08d5				endm  
# End of macro CALLMONITOR
08d5				endif 
08d5 c9					ret 
08d6			 
08d6			 
08d6			 
08d6			; 
08d6			; Append File 
08d6			; 
08d6			; hl - file id to locate 
08d6			; de - pointer to (multi block) string to write 
08d6			 
08d6			.sa_notfound: 
08d6 d1				pop de 
08d7 c9				ret 
08d8			 
08d8			 
08d8			storage_append: 
08d8				; hl -  file id to append to 
08d8				; de - string to append 
08d8			 
08d8 d5				push de 
08d9				 
08d9				if DEBUG_STORESE 
08d9					DMARK "AP1" 
08d9 f5				push af  
08da 3a ee 08			ld a, (.dmark)  
08dd 32 b4 fb			ld (debug_mark),a  
08e0 3a ef 08			ld a, (.dmark+1)  
08e3 32 b5 fb			ld (debug_mark+1),a  
08e6 3a f0 08			ld a, (.dmark+2)  
08e9 32 b6 fb			ld (debug_mark+2),a  
08ec 18 03			jr .pastdmark  
08ee ..			.dmark: db "AP1"  
08f1 f1			.pastdmark: pop af  
08f2			endm  
# End of macro DMARK
08f2					CALLMONITOR 
08f2 cd 3d 17			call break_point_state  
08f5				endm  
# End of macro CALLMONITOR
08f5				endif 
08f5			 
08f5 7d				ld a, l 
08f6 32 d8 f9			ld (store_tmpid), a 
08f9			 
08f9				; get file header  
08f9			 
08f9 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fb 3a d8 f9			ld a, (store_tmpid) 
08fe 5f				ld e, a 
08ff			 
08ff 21 40 00				ld hl, STORE_BLOCK_PHY 
0902 cd 29 06				call storage_findnextid 
0905			 
0905 cd 41 0d			call ishlzero 
0908 28 cc			jr z, .sa_notfound 
090a			 
090a 22 c9 f9			ld (store_tmppageid), hl 
090d			 
090d				; TODO handle file id not found 
090d			 
090d				if DEBUG_STORESE 
090d					DMARK "AP2" 
090d f5				push af  
090e 3a 22 09			ld a, (.dmark)  
0911 32 b4 fb			ld (debug_mark),a  
0914 3a 23 09			ld a, (.dmark+1)  
0917 32 b5 fb			ld (debug_mark+1),a  
091a 3a 24 09			ld a, (.dmark+2)  
091d 32 b6 fb			ld (debug_mark+2),a  
0920 18 03			jr .pastdmark  
0922 ..			.dmark: db "AP2"  
0925 f1			.pastdmark: pop af  
0926			endm  
# End of macro DMARK
0926					CALLMONITOR 
0926 cd 3d 17			call break_point_state  
0929				endm  
# End of macro CALLMONITOR
0929				endif 
0929			 
0929				; update file extent count 
0929			 
0929 11 df f9			ld de, store_page 
092c			 
092c cd 04 03			call storage_read_block 
092f			 
092f				if DEBUG_STORESE 
092f					DMARK "AP3" 
092f f5				push af  
0930 3a 44 09			ld a, (.dmark)  
0933 32 b4 fb			ld (debug_mark),a  
0936 3a 45 09			ld a, (.dmark+1)  
0939 32 b5 fb			ld (debug_mark+1),a  
093c 3a 46 09			ld a, (.dmark+2)  
093f 32 b6 fb			ld (debug_mark+2),a  
0942 18 03			jr .pastdmark  
0944 ..			.dmark: db "AP3"  
0947 f1			.pastdmark: pop af  
0948			endm  
# End of macro DMARK
0948					CALLMONITOR 
0948 cd 3d 17			call break_point_state  
094b				endm  
# End of macro CALLMONITOR
094b				endif 
094b			;	ld (store_tmppageid), hl 
094b			 
094b 3a e1 f9			ld a, (store_page+2) 
094e 3c				inc a 
094f 32 e1 f9			ld (store_page+2), a 
0952 32 d7 f9			ld (store_tmpext), a 
0955				 
0955				if DEBUG_STORESE 
0955					DMARK "AP3" 
0955 f5				push af  
0956 3a 6a 09			ld a, (.dmark)  
0959 32 b4 fb			ld (debug_mark),a  
095c 3a 6b 09			ld a, (.dmark+1)  
095f 32 b5 fb			ld (debug_mark+1),a  
0962 3a 6c 09			ld a, (.dmark+2)  
0965 32 b6 fb			ld (debug_mark+2),a  
0968 18 03			jr .pastdmark  
096a ..			.dmark: db "AP3"  
096d f1			.pastdmark: pop af  
096e			endm  
# End of macro DMARK
096e					CALLMONITOR 
096e cd 3d 17			call break_point_state  
0971				endm  
# End of macro CALLMONITOR
0971				endif 
0971 2a c9 f9			ld hl, (store_tmppageid) 
0974 11 df f9			ld de, store_page 
0977 cd 69 03			call storage_write_block 
097a			 
097a				; find free block 
097a			 
097a 11 00 00			ld de, 0			 ; file extent to locate 
097d			 
097d 21 40 00				ld hl, STORE_BLOCK_PHY 
0980 cd 29 06				call storage_findnextid 
0983 cd 41 0d			call ishlzero 
0986 ca d6 08			jp z, .sa_notfound 
0989			 
0989					; TODO handle no space left 
0989					 
0989 22 c9 f9				ld (store_tmppageid), hl 
098c			 
098c				if DEBUG_STORESE 
098c					DMARK "AP4" 
098c f5				push af  
098d 3a a1 09			ld a, (.dmark)  
0990 32 b4 fb			ld (debug_mark),a  
0993 3a a2 09			ld a, (.dmark+1)  
0996 32 b5 fb			ld (debug_mark+1),a  
0999 3a a3 09			ld a, (.dmark+2)  
099c 32 b6 fb			ld (debug_mark+2),a  
099f 18 03			jr .pastdmark  
09a1 ..			.dmark: db "AP4"  
09a4 f1			.pastdmark: pop af  
09a5			endm  
# End of macro DMARK
09a5					CALLMONITOR 
09a5 cd 3d 17			call break_point_state  
09a8				endm  
# End of macro CALLMONITOR
09a8				endif 
09a8					; init the buffer with zeros so we can id if the buffer is full or not 
09a8			 
09a8 e5					push hl 
09a9 c5					push bc 
09aa			 
09aa 21 df f9				ld hl, store_page 
09ad 06 40				ld b, STORE_BLOCK_PHY 
09af 3e 00				ld a, 0 
09b1 77			.zeroblock:	ld (hl), a 
09b2 23					inc hl 
09b3 10 fc				djnz .zeroblock 
09b5			 
09b5 c1					pop bc 
09b6 e1					pop hl 
09b7			 
09b7					; construct block 
09b7			 
09b7 3a d8 f9				ld a, (store_tmpid) 
09ba 32 df f9				ld (store_page), a   ; file id 
09bd 3a d7 f9				ld a, (store_tmpext)   ; extent for this block 
09c0 32 e0 f9				ld (store_page+1), a 
09c3			 
09c3 e1					pop hl    ; get string to write 
09c4 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09c6 11 e1 f9				ld de, store_page+2 
09c9			 
09c9				if DEBUG_STORESE 
09c9					DMARK "AP5" 
09c9 f5				push af  
09ca 3a de 09			ld a, (.dmark)  
09cd 32 b4 fb			ld (debug_mark),a  
09d0 3a df 09			ld a, (.dmark+1)  
09d3 32 b5 fb			ld (debug_mark+1),a  
09d6 3a e0 09			ld a, (.dmark+2)  
09d9 32 b6 fb			ld (debug_mark+2),a  
09dc 18 03			jr .pastdmark  
09de ..			.dmark: db "AP5"  
09e1 f1			.pastdmark: pop af  
09e2			endm  
# End of macro DMARK
09e2					CALLMONITOR 
09e2 cd 3d 17			call break_point_state  
09e5				endm  
# End of macro CALLMONITOR
09e5				endif 
09e5			 
09e5			 
09e5			 
09e5					; fill buffer with data until end of string or full block 
09e5			 
09e5 7e			.appd:		ld a, (hl) 
09e6 12					ld (de), a 
09e7 fe 00				cp 0 
09e9 28 04				jr z, .appdone 
09eb 23					inc hl 
09ec 13					inc de 
09ed 10 f6				djnz .appd 
09ef			 
09ef e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09f0 f5					push af   		; save last byte dumped 
09f1			 
09f1			 
09f1 2a c9 f9			ld hl, (store_tmppageid) 
09f4 11 df f9			ld de, store_page 
09f7				if DEBUG_STORESE 
09f7					DMARK "AP6" 
09f7 f5				push af  
09f8 3a 0c 0a			ld a, (.dmark)  
09fb 32 b4 fb			ld (debug_mark),a  
09fe 3a 0d 0a			ld a, (.dmark+1)  
0a01 32 b5 fb			ld (debug_mark+1),a  
0a04 3a 0e 0a			ld a, (.dmark+2)  
0a07 32 b6 fb			ld (debug_mark+2),a  
0a0a 18 03			jr .pastdmark  
0a0c ..			.dmark: db "AP6"  
0a0f f1			.pastdmark: pop af  
0a10			endm  
# End of macro DMARK
0a10					CALLMONITOR 
0a10 cd 3d 17			call break_point_state  
0a13				endm  
# End of macro CALLMONITOR
0a13				endif 
0a13 cd 69 03				call storage_write_block 
0a16			 
0a16			 
0a16				; was that a full block of data written? 
0a16				; any more to write out? 
0a16			 
0a16				; if yes then set vars and jump to start of function again 
0a16			 
0a16 f1					pop af 
0a17 d1					pop de 
0a18			 
0a18 fe 00				cp 0		 ; no, string was fully written 
0a1a c8					ret z 
0a1b			 
0a1b					; setup vars for next cycle 
0a1b			 
0a1b 3a d8 f9				ld a, (store_tmpid) 
0a1e 6f					ld l, a 
0a1f 26 00				ld h, 0 
0a21			 
0a21 c3 d8 08			 	jp storage_append	 ; yes, need to write out some more 
0a24			 
0a24			 
0a24			 
0a24			 
0a24			 
0a24			 
0a24			 
0a24			if DEBUG_STORECF 
0a24			storageput:	 
0a24					ret 
0a24			storageread: 
0a24					ld hl, store_page 
0a24					ld b, 200 
0a24					ld a,0 
0a24			.src:		ld (hl),a 
0a24					inc hl 
0a24					djnz .src 
0a24					 
0a24			 
0a24					ld de, 0 
0a24					ld bc, 1 
0a24					ld hl, store_page 
0a24					call cfRead 
0a24			 
0a24				call cfGetError 
0a24				ld hl,scratch 
0a24				call hexout 
0a24				ld hl, scratch+2 
0a24				ld a, 0 
0a24				ld (hl),a 
0a24				ld de, scratch 
0a24				ld a,display_row_1 
0a24				call str_at_display 
0a24				call update_display 
0a24			 
0a24					ld hl, store_page 
0a24					ld (os_cur_ptr),hl 
0a24			 
0a24					ret 
0a24			endif 
0a24			 
0a24			 
0a24			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a24			 
0a24			storage_clear_page: 
0a24 e5				push hl 
0a25 d5				push de 
0a26 c5				push bc 
0a27 21 df f9			ld hl, store_page 
0a2a 3e 00			ld a, 0 
0a2c 77				ld (hl), a 
0a2d			 
0a2d 11 e0 f9			ld de, store_page+1 
0a30 01 40 00			ld bc, STORE_BLOCK_PHY 
0a33			 
0a33 ed b0			ldir 
0a35				 
0a35 c1				pop bc 
0a36 d1				pop de 
0a37 e1				pop hl 
0a38 c9				ret 
0a39			 
0a39			; eof 
# End of file firmware_storage.asm
0a39			  
0a39			; support routines for above hardware abstraction layer  
0a39			  
0a39			include "firmware_general.asm"        ; general support functions  
0a39			 
0a39			; word look up 
0a39			 
0a39			; in 
0a39			; a is the index 
0a39			; hl is pointer start of array 
0a39			; 
0a39			; returns 
0a39			; hl to the word 
0a39			; 
0a39			 
0a39			table_lookup:  
0a39 d5					push de 
0a3a eb					ex de, hl 
0a3b			 
0a3b 6f					ld l, a 
0a3c 26 00				ld h, 0 
0a3e 29					add hl, hl 
0a3f 19					add hl, de 
0a40 7e					ld a, (hl) 
0a41 23					inc hl 
0a42 66					ld h,(hl) 
0a43 6f					ld l, a 
0a44			 
0a44 d1					pop de 
0a45 c9					ret 
0a46			 
0a46			; Delay loops 
0a46			 
0a46			 
0a46			 
0a46			aDelayInMS: 
0a46 c5				push bc 
0a47 47				ld b,a 
0a48			msdelay: 
0a48 c5				push bc 
0a49				 
0a49			 
0a49 01 41 00			ld bc,041h 
0a4c cd 64 0a			call delayloop 
0a4f c1				pop bc 
0a50 05				dec b 
0a51 20 f5			jr nz,msdelay 
0a53			 
0a53			;if CPU_CLOCK_8MHZ 
0a53			;msdelay8: 
0a53			;	push bc 
0a53			;	 
0a53			; 
0a53			;	ld bc,041h 
0a53			;	call delayloop 
0a53			;	pop bc 
0a53			;	dec b 
0a53			;	jr nz,msdelay8 
0a53			;endif 
0a53			 
0a53			 
0a53 c1				pop bc 
0a54 c9				ret 
0a55			 
0a55			 
0a55			delay250ms: 
0a55				;push de 
0a55 01 00 40			ld bc, 04000h 
0a58 c3 64 0a			jp delayloop 
0a5b			delay500ms: 
0a5b				;push de 
0a5b 01 00 80			ld bc, 08000h 
0a5e c3 64 0a			jp delayloop 
0a61			delay1s: 
0a61				;push bc 
0a61			   ; Clobbers A, d and e 
0a61 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a64			delayloop: 
0a64 c5			    push bc 
0a65			 
0a65			if BASE_CPM 
0a65				ld bc, CPM_DELAY_TUNE 
0a65			.cpmloop: 
0a65				push bc 
0a65			 
0a65			endif 
0a65			 
0a65			 
0a65			 
0a65			delayloopi: 
0a65			;	push bc 
0a65			;.dl: 
0a65 cb 47		    bit     0,a    	; 8 
0a67 cb 47		    bit     0,a    	; 8 
0a69 cb 47		    bit     0,a    	; 8 
0a6b e6 ff		    and     255  	; 7 
0a6d 0b			    dec     bc      	; 6 
0a6e 79			    ld      a,c     	; 4 
0a6f b0			    or      b     	; 4 
0a70 c2 65 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a73			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a73				;pop de 
0a73			;pop bc 
0a73			 
0a73			if BASE_CPM 
0a73				pop bc 
0a73				 
0a73			    dec     bc      	; 6 
0a73			    ld      a,c     	; 4 
0a73			    or      b     	; 4 
0a73			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a73				 
0a73			 
0a73			endif 
0a73			;if CPU_CLOCK_8MHZ 
0a73			;    pop bc 
0a73			;    push bc 
0a73			;.dl8: 
0a73			;    bit     0,a    	; 8 
0a73			;    bit     0,a    	; 8 
0a73			;    bit     0,a    	; 8 
0a73			;    and     255  	; 7 
0a73			;    dec     bc      	; 6 
0a73			;    ld      a,c     	; 4 
0a73			;    or      b     	; 4 
0a73			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a73			;endif 
0a73			 
0a73			;if CPU_CLOCK_10MHZ 
0a73			;    pop bc 
0a73			;    push bc 
0a73			;.dl8: 
0a73			;    bit     0,a    	; 8 
0a73			;    bit     0,a    	; 8 
0a73			;    bit     0,a    	; 8 
0a73			;    and     255  	; 7 
0a73			;    dec     bc      	; 6 
0a73			;    ld      a,c     	; 4 
0a73			;    or      b     	; 4 
0a73			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a73			;endif 
0a73 c1			    pop bc 
0a74			 
0a74 c9				ret 
0a75			 
0a75			 
0a75			 
0a75			; eof 
# End of file firmware_general.asm
0a75			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a75			; display routines that use the physical hardware abstraction layer 
0a75			 
0a75			 
0a75			; information window 
0a75			 
0a75			; pass hl with 1st string to display 
0a75			; pass de with 2nd string to display 
0a75			 
0a75			info_panel: 
0a75 e5				push hl 
0a76			 
0a76 2a 55 fa			ld hl, (display_fb_active) 
0a79 e5				push hl    ; future de destination 
0a7a 21 4a fb				ld hl, display_fb0 
0a7d 22 55 fa				ld (display_fb_active), hl 
0a80			 
0a80			;	call clear_display 
0a80			 
0a80				if BASE_CPM 
0a80				ld a, '.' 
0a80				else 
0a80 3e a5			ld a, 165 
0a82				endif 
0a82 cd e9 0a			call fill_display 
0a85			 
0a85			 
0a85 3e 2d			ld a, display_row_3 + 5 
0a87 cd f7 0a			call str_at_display 
0a8a			 
0a8a e1				pop hl 
0a8b d1				pop de 
0a8c			 
0a8c e5				push hl 
0a8d			 
0a8d			 
0a8d 3e 19			ld a, display_row_2 + 5 
0a8f cd f7 0a			call str_at_display 
0a92			 
0a92			 
0a92 cd 07 0b			call update_display 
0a95 cd 45 1c			call next_page_prompt 
0a98 cd e4 0a			call clear_display 
0a9b			 
0a9b				 
0a9b 21 f9 fa				ld hl, display_fb1 
0a9e 22 55 fa				ld (display_fb_active), hl 
0aa1 cd 07 0b			call update_display 
0aa4			 
0aa4 e1				pop hl 
0aa5			 
0aa5 c9				ret 
0aa6			 
0aa6			 
0aa6			 
0aa6			 
0aa6			; TODO windowing? 
0aa6			 
0aa6			; TODO scroll line up 
0aa6			 
0aa6			scroll_up: 
0aa6			 
0aa6 e5				push hl 
0aa7 d5				push de 
0aa8 c5				push bc 
0aa9			 
0aa9				; get frame buffer  
0aa9			 
0aa9 2a 55 fa			ld hl, (display_fb_active) 
0aac e5				push hl    ; future de destination 
0aad			 
0aad 11 14 00			ld  de, display_cols 
0ab0 19				add hl, de 
0ab1			 
0ab1 d1				pop de 
0ab2			 
0ab2				;ex de, hl 
0ab2 01 4f 00			ld bc, display_fb_len -1  
0ab5			;if DEBUG_FORTH_WORDS 
0ab5			;	DMARK "SCL" 
0ab5			;	CALLMONITOR 
0ab5			;endif	 
0ab5 ed b0			ldir 
0ab7			 
0ab7				; wipe bottom row 
0ab7			 
0ab7			 
0ab7 2a 55 fa			ld hl, (display_fb_active) 
0aba 11 50 00			ld de, display_cols*display_rows 
0abd 19				add hl, de 
0abe 06 14			ld b, display_cols 
0ac0 3e 20			ld a, ' ' 
0ac2			.scwipe: 
0ac2 77				ld (hl), a 
0ac3 2b				dec hl 
0ac4 10 fc			djnz .scwipe 
0ac6			 
0ac6				;pop hl 
0ac6			 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9			 
0ac9 c9				ret 
0aca			 
0aca			 
0aca			;scroll_upo: 
0aca			;	ld de, display_row_1 
0aca			 ;	ld hl, display_row_2 
0aca			;	ld bc, display_cols 
0aca			;	ldir 
0aca			;	ld de, display_row_2 
0aca			 ;	ld hl, display_row_3 
0aca			;	ld bc, display_cols 
0aca			;	ldir 
0aca			;	ld de, display_row_3 
0aca			 ;	ld hl, display_row_4 
0aca			;	ld bc, display_cols 
0aca			;	ldir 
0aca			 
0aca			; TODO clear row 4 
0aca			 
0aca			;	ret 
0aca			 
0aca				 
0aca			scroll_down: 
0aca			 
0aca e5				push hl 
0acb d5				push de 
0acc c5				push bc 
0acd			 
0acd				; get frame buffer  
0acd			 
0acd 2a 55 fa			ld hl, (display_fb_active) 
0ad0			 
0ad0 11 4f 00			ld de, display_fb_len - 1 
0ad3 19				add hl, de 
0ad4			 
0ad4 e5			push hl    ; future de destination 
0ad5			 
0ad5 11 14 00			ld  de, display_cols 
0ad8 ed 52			sbc hl, de 
0ada			 
0ada			 
0ada d1				pop de 
0adb			 
0adb			;	ex de, hl 
0adb 01 4f 00			ld bc, display_fb_len -1  
0ade			 
0ade			 
0ade				 
0ade			 
0ade ed b0			ldir 
0ae0			 
0ae0				; wipe bottom row 
0ae0			 
0ae0			 
0ae0			;	ld hl, (display_fb_active) 
0ae0			;;	ld de, display_cols*display_rows 
0ae0			;;	add hl, de 
0ae0			;	ld b, display_cols 
0ae0			;	ld a, ' ' 
0ae0			;.scwiped: 
0ae0			;	ld (hl), a 
0ae0			;	dec hl 
0ae0			;	djnz .scwiped 
0ae0			 
0ae0				;pop hl 
0ae0			 
0ae0 c1				pop bc 
0ae1 d1				pop de 
0ae2 e1				pop hl 
0ae3			 
0ae3 c9				ret 
0ae4			;scroll_down: 
0ae4			;	ld de, display_row_4 
0ae4			;	ld hl, display_row_3 
0ae4			;	ld bc, display_cols 
0ae4			;	ldir 
0ae4			;	ld de, display_row_3 
0ae4			; 	ld hl, display_row_2 
0ae4			;	ld bc, display_cols 
0ae4			;	ldir 
0ae4			;	ld de, display_row_2 
0ae4			;	ld hl, display_row_1 
0ae4			;	ld bc, display_cols 
0ae4			;	ldir 
0ae4			;;; TODO clear row 1 
0ae4			;	ret 
0ae4			 
0ae4			 
0ae4			 
0ae4			 
0ae4			 
0ae4			; clear active frame buffer 
0ae4			 
0ae4			clear_display: 
0ae4 3e 20			ld a, ' ' 
0ae6 c3 e9 0a			jp fill_display 
0ae9			 
0ae9			; fill active frame buffer with a char in A 
0ae9			 
0ae9			fill_display: 
0ae9 06 50			ld b,display_fb_len 
0aeb 2a 55 fa			ld hl, (display_fb_active) 
0aee 77			.fd1:	ld (hl),a 
0aef 23				inc hl 
0af0 10 fc			djnz .fd1 
0af2 23				inc hl 
0af3 3e 00			ld a,0 
0af5 77				ld (hl),a 
0af6			 
0af6			 
0af6 c9				ret 
0af7			; Write string (DE) at pos (A) to active frame buffer 
0af7			 
0af7 2a 55 fa		str_at_display:    ld hl,(display_fb_active) 
0afa 06 00					ld b,0 
0afc 4f					ld c,a 
0afd 09					add hl,bc 
0afe 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aff b7			            OR   A              ;Null terminator? 
0b00 c8			            RET  Z              ;Yes, so finished 
0b01 77					ld (hl),a 
0b02 23				inc hl 
0b03 13			            INC  DE             ;Point to next character 
0b04 18 f8		            JR   .sad1     ;Repeat 
0b06 c9					ret 
0b07			 
0b07			; using current frame buffer write to physical display 
0b07			 
0b07			update_display: 
0b07 e5				push hl 
0b08 2a 55 fa			ld hl, (display_fb_active) 
0b0b cd aa 65			call write_display 
0b0e e1				pop hl 
0b0f c9				ret 
0b10			 
0b10			; TODO scrolling 
0b10			 
0b10			 
0b10			; move cursor right one char 
0b10			cursor_right: 
0b10			 
0b10				; TODO shift right 
0b10				; TODO if beyond max col 
0b10				; TODO       cursor_next_line 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			cursor_next_line: 
0b11				; TODO first char 
0b11				; TODO line down 
0b11				; TODO if past last row 
0b11				; TODO    scroll up 
0b11			 
0b11 c9				ret 
0b12			 
0b12			cursor_left: 
0b12				; TODO shift left 
0b12				; TODO if beyond left  
0b12				; TODO     cursor prev line 
0b12				 
0b12 c9				ret 
0b13			 
0b13			cursor_prev_line: 
0b13				; TODO last char 
0b13				; TODO line up 
0b13				; TODO if past first row 
0b13				; TODO   scroll down 
0b13			 
0b13 c9				ret 
0b14			 
0b14			 
0b14			cout: 
0b14				; A - char 
0b14 c9				ret 
0b15			 
0b15			 
0b15			; Display a menu and allow item selection (optional toggle items) 
0b15			; 
0b15			; format: 
0b15			; hl pointer to word array with zero term for items 
0b15			; e.g.    db item1 
0b15			;         db .... 
0b15			;         db 0 
0b15			; 
0b15			; a = starting menu item  
0b15			; 
0b15			; de = pointer item toggle array   (todo) 
0b15			; 
0b15			; returns item selected in a 1-... 
0b15			; returns 0 if back button pressed 
0b15			; 
0b15			; NOTE: Uses system frame buffer to display 
0b15			; 
0b15			; LEFT, Q = go back 
0b15			; RIGHT, SPACE, CR = select 
0b15			; UP, A - Up 
0b15			; DOWN, Z - Down 
0b15			 
0b15			 
0b15			 
0b15			 
0b15			 
0b15			menu: 
0b15			 
0b15					; keep array pointer 
0b15			 
0b15 22 dd f9				ld (store_tmp1), hl 
0b18 32 db f9				ld (store_tmp2), a 
0b1b			 
0b1b					; check for key bounce 
0b1b			 
0b1b			if BASE_KEV 
0b1b			 
0b1b cd 5f 67		.mbounce:	call cin 
0b1e fe 00				cp 0 
0b20 20 f9				jr nz, .mbounce 
0b22			endif 
0b22					; for ease use ex 
0b22			 
0b22					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b22 21 4a fb				ld hl, display_fb0 
0b25 22 55 fa				ld (display_fb_active), hl 
0b28			 
0b28 cd e4 0a		.mloop:		call clear_display 
0b2b cd 07 0b				call update_display 
0b2e			 
0b2e					; draw selection id '>' at 1 
0b2e			 
0b2e					; init start of list display 
0b2e			 
0b2e 3e 05				ld a, 5 
0b30 32 d9 f9				ld (store_tmp3), a   ; display row count 
0b33 3a db f9				ld a,( store_tmp2) 
0b36 32 dc f9				ld (store_tmp2+1), a   ; display item count 
0b39			 
0b39					 
0b39			.mitem:	 
0b39			 
0b39			 
0b39 3a dc f9				ld a,(store_tmp2+1) 
0b3c 6f					ld l, a 
0b3d 26 00				ld h, 0 
0b3f 29					add hl, hl 
0b40 ed 5b dd f9			ld de, (store_tmp1) 
0b44 19					add hl, de 
0b45 7e					ld a, (hl) 
0b46 23					inc hl 
0b47 66					ld h,(hl) 
0b48 6f					ld l, a 
0b49			 
0b49 cd 41 0d				call ishlzero 
0b4c 28 1a				jr z, .mdone 
0b4e			 
0b4e eb					ex de, hl 
0b4f 3a d9 f9				ld a, (store_tmp3) 
0b52 cd f7 0a				call str_at_display 
0b55					 
0b55			 
0b55					; next item 
0b55 3a dc f9				ld a, (store_tmp2+1) 
0b58 3c					inc a 
0b59 32 dc f9				ld (store_tmp2+1), a   ; display item count 
0b5c			 
0b5c			 		; next row 
0b5c			 
0b5c 3a d9 f9				ld a, (store_tmp3) 
0b5f c6 14				add display_cols 
0b61 32 d9 f9				ld (store_tmp3), a 
0b64			 
0b64					; at end of screen? 
0b64			 
0b64 fe 10				cp display_rows*4 
0b66 20 d1				jr nz, .mitem 
0b68			 
0b68			 
0b68			.mdone: 
0b68 cd 41 0d				call ishlzero 
0b6b 28 08				jr z, .nodn 
0b6d			 
0b6d 3e 3c				ld a, display_row_4 
0b6f 11 ee 0b				ld de, .mdown 
0b72 cd f7 0a				call str_at_display 
0b75			 
0b75					; draw options to fill the screens with active item on line 1 
0b75					; if current option is 2 or more then display ^ in top 
0b75			 
0b75 3a db f9		.nodn:		ld a, (store_tmp2) 
0b78 fe 00				cp 0 
0b7a 28 08				jr z, .noup 
0b7c			 
0b7c 3e 00				ld a, 0 
0b7e 11 ec 0b				ld de, .mup 
0b81 cd f7 0a				call str_at_display 
0b84			 
0b84 3e 02		.noup:		ld a, 2 
0b86 11 ea 0b				ld de, .msel 
0b89 cd f7 0a				call str_at_display 
0b8c			 
0b8c					; if current option + 1 is not null then display V in bottom 
0b8c					; get key 
0b8c cd 07 0b				call update_display 
0b8f			 
0b8f			 
0b8f					; handle key 
0b8f			 
0b8f cd 4e 67				call cin_wait 
0b92			 
0b92 fe 05				cp KEY_UP 
0b94 28 2b				jr z, .mgoup 
0b96 fe 61				cp 'a' 
0b98 28 27				jr z, .mgoup 
0b9a fe 0a				cp KEY_DOWN 
0b9c 28 32				jr z, .mgod 
0b9e fe 7a				cp 'z' 
0ba0 28 2e				jr z, .mgod 
0ba2 fe 20				cp ' ' 
0ba4 28 34				jr z, .goend 
0ba6 fe 0c				cp KEY_RIGHT 
0ba8 28 30				jr z, .goend 
0baa fe 0d				cp KEY_CR 
0bac 28 2c				jr z, .goend 
0bae fe 71				cp 'q' 
0bb0 28 0b				jr z, .goback 
0bb2			 
0bb2 fe 0b				cp KEY_LEFT 
0bb4 28 07				jr z, .goback 
0bb6 fe 08				cp KEY_BS 
0bb8 28 03				jr z, .goback 
0bba c3 28 0b				jp .mloop 
0bbd			 
0bbd			.goback: 
0bbd 3e 00			ld a, 0 
0bbf 18 1d			jr .goend2 
0bc1			 
0bc1				; move up one 
0bc1			.mgoup: 
0bc1 3a db f9				ld a, (store_tmp2) 
0bc4 fe 00				cp 0 
0bc6 ca 28 0b				jp z, .mloop 
0bc9 3d					dec a 
0bca 32 db f9				ld (store_tmp2), a 
0bcd c3 28 0b				jp .mloop 
0bd0			 
0bd0				; move down one 
0bd0			.mgod: 
0bd0 3a db f9				ld a, (store_tmp2) 
0bd3 3c					inc a 
0bd4 32 db f9				ld (store_tmp2), a 
0bd7 c3 28 0b				jp .mloop 
0bda			 
0bda			 
0bda			.goend: 
0bda					; get selected item number 
0bda			 
0bda 3a db f9				ld a, (store_tmp2) 
0bdd 3c					inc a 
0bde			 
0bde			.goend2: 
0bde f5					push af 
0bdf			 
0bdf					; restore active fb 
0bdf					; TODO BUG assumes fb1 
0bdf			 
0bdf 21 f9 fa				ld hl, display_fb1 
0be2 22 55 fa				ld (display_fb_active), hl 
0be5			 
0be5					; restore main regs 
0be5			 
0be5			 
0be5 cd 07 0b				call update_display 
0be8			 
0be8 f1					pop af 
0be9			 
0be9 c9				ret 
0bea			 
0bea .. 00		.msel:   db ">",0 
0bec .. 00		.mup:   db "^",0 
0bee .. 00		.mdown:   db "v",0 
0bf0			 
0bf0			 
0bf0			; eof 
0bf0			 
# End of file firmware_display.asm
0bf0			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bf0			; random number generators 
0bf0			 
0bf0			 
0bf0			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bf0			 
0bf0			 
0bf0			;-----> Generate a random number 
0bf0			; output a=answer 0<=a<=255 
0bf0			; all registers are preserved except: af 
0bf0			random: 
0bf0 e5			        push    hl 
0bf1 d5			        push    de 
0bf2 2a 37 fa		        ld      hl,(randData) 
0bf5 ed 5f		        ld      a,r 
0bf7 57			        ld      d,a 
0bf8 5e			        ld      e,(hl) 
0bf9 19			        add     hl,de 
0bfa 85			        add     a,l 
0bfb ac			        xor     h 
0bfc 22 37 fa		        ld      (randData),hl 
0bff d1			        pop     de 
0c00 e1			        pop     hl 
0c01 c9			        ret 
0c02			 
0c02			 
0c02			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c02			 
0c02			 
0c02			 
0c02			;------LFSR------ 
0c02			;James Montelongo 
0c02			;optimized by Spencer Putt 
0c02			;out: 
0c02			; a = 8 bit random number 
0c02			RandLFSR: 
0c02 21 3d fa		        ld hl,LFSRSeed+4 
0c05 5e			        ld e,(hl) 
0c06 23			        inc hl 
0c07 56			        ld d,(hl) 
0c08 23			        inc hl 
0c09 4e			        ld c,(hl) 
0c0a 23			        inc hl 
0c0b 7e			        ld a,(hl) 
0c0c 47			        ld b,a 
0c0d cb 13		        rl e  
0c0f cb 12			rl d 
0c11 cb 11		        rl c  
0c13 17				rla 
0c14 cb 13		        rl e  
0c16 cb 12			rl d 
0c18 cb 11		        rl c  
0c1a 17				rla 
0c1b cb 13		        rl e  
0c1d cb 12			rl d 
0c1f cb 11		        rl c  
0c21 17				rla 
0c22 67			        ld h,a 
0c23 cb 13		        rl e  
0c25 cb 12			rl d 
0c27 cb 11		        rl c  
0c29 17				rla 
0c2a a8			        xor b 
0c2b cb 13		        rl e  
0c2d cb 12			rl d 
0c2f ac			        xor h 
0c30 a9			        xor c 
0c31 aa			        xor d 
0c32 21 3f fa		        ld hl,LFSRSeed+6 
0c35 11 40 fa		        ld de,LFSRSeed+7 
0c38 01 07 00		        ld bc,7 
0c3b ed b8		        lddr 
0c3d 12			        ld (de),a 
0c3e c9			        ret 
0c3f			 
0c3f			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c3f			 
0c3f			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c3f			 
0c3f			 
0c3f			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c3f			 
0c3f			prng16: 
0c3f			;Inputs: 
0c3f			;   (seed1) contains a 16-bit seed value 
0c3f			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c3f			;Outputs: 
0c3f			;   HL is the result 
0c3f			;   BC is the result of the LCG, so not that great of quality 
0c3f			;   DE is preserved 
0c3f			;Destroys: 
0c3f			;   AF 
0c3f			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c3f			;160cc 
0c3f			;26 bytes 
0c3f 2a 31 fa		    ld hl,(seed1) 
0c42 44			    ld b,h 
0c43 4d			    ld c,l 
0c44 29			    add hl,hl 
0c45 29			    add hl,hl 
0c46 2c			    inc l 
0c47 09			    add hl,bc 
0c48 22 31 fa		    ld (seed1),hl 
0c4b 2a 2f fa		    ld hl,(seed2) 
0c4e 29			    add hl,hl 
0c4f 9f			    sbc a,a 
0c50 e6 2d		    and %00101101 
0c52 ad			    xor l 
0c53 6f			    ld l,a 
0c54 22 2f fa		    ld (seed2),hl 
0c57 09			    add hl,bc 
0c58 c9			    ret 
0c59			 
0c59			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c59			 
0c59			rand32: 
0c59			;Inputs: 
0c59			;   (seed1_0) holds the lower 16 bits of the first seed 
0c59			;   (seed1_1) holds the upper 16 bits of the first seed 
0c59			;   (seed2_0) holds the lower 16 bits of the second seed 
0c59			;   (seed2_1) holds the upper 16 bits of the second seed 
0c59			;   **NOTE: seed2 must be non-zero 
0c59			;Outputs: 
0c59			;   HL is the result 
0c59			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c59			;Destroys: 
0c59			;   AF 
0c59			;Tested and passes all CAcert tests 
0c59			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c59			;it has a period of 18,446,744,069,414,584,320 
0c59			;roughly 18.4 quintillion. 
0c59			;LFSR taps: 0,2,6,7  = 11000101 
0c59			;291cc 
0c59			;seed1_0=$+1 
0c59			;    ld hl,12345 
0c59			;seed1_1=$+1 
0c59			;    ld de,6789 
0c59			;    ld b,h 
0c59			;    ld c,l 
0c59			;    add hl,hl \ rl e \ rl d 
0c59			;    add hl,hl \ rl e \ rl d 
0c59			;    inc l 
0c59			;    add hl,bc 
0c59			;    ld (seed1_0),hl 
0c59			;    ld hl,(seed1_1) 
0c59			;    adc hl,de 
0c59			;    ld (seed1_1),hl 
0c59			;    ex de,hl 
0c59			;seed2_0=$+1 
0c59			;    ld hl,9876 
0c59			;seed2_1=$+1 
0c59			;    ld bc,54321 
0c59			;    add hl,hl \ rl c \ rl b 
0c59			;    ld (seed2_1),bc 
0c59			;    sbc a,a 
0c59			;    and %11000101 
0c59			;    xor l 
0c59			;    ld l,a 
0c59			;    ld (seed2_0),hl 
0c59			;    ex de,hl 
0c59			;    add hl,bc 
0c59			;    ret 
0c59			; 
0c59			 
0c59			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c59			; 20 bytes, 86 cycles (excluding ret) 
0c59			 
0c59			; returns   hl = pseudorandom number 
0c59			; corrupts   a 
0c59			 
0c59			; generates 16-bit pseudorandom numbers with a period of 65535 
0c59			; using the xorshift method: 
0c59			 
0c59			; hl ^= hl << 7 
0c59			; hl ^= hl >> 9 
0c59			; hl ^= hl << 8 
0c59			 
0c59			; some alternative shift triplets which also perform well are: 
0c59			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c59			 
0c59			;  org 32768 
0c59			 
0c59			xrnd: 
0c59 2a 35 fa		  ld hl,(xrandc)       ; seed must not be 0 
0c5c 3e 00		  ld a,0 
0c5e bd			  cp l 
0c5f 20 02		  jr nz, .xrnd1 
0c61 2e 01		  ld l, 1 
0c63			.xrnd1: 
0c63			 
0c63 7c			  ld a,h 
0c64 1f			  rra 
0c65 7d			  ld a,l 
0c66 1f			  rra 
0c67 ac			  xor h 
0c68 67			  ld h,a 
0c69 7d			  ld a,l 
0c6a 1f			  rra 
0c6b 7c			  ld a,h 
0c6c 1f			  rra 
0c6d ad			  xor l 
0c6e 6f			  ld l,a 
0c6f ac			  xor h 
0c70 67			  ld h,a 
0c71			 
0c71 22 35 fa		  ld (xrandc),hl 
0c74			 
0c74 c9			  ret 
0c75			;  
0c75			 
0c75			 
0c75			;;;; int maths 
0c75			 
0c75			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c75			; Divide 16-bit values (with 16-bit result) 
0c75			; In: Divide BC by divider DE 
0c75			; Out: BC = result, HL = rest 
0c75			; 
0c75			Div16: 
0c75 21 00 00		    ld hl,0 
0c78 78			    ld a,b 
0c79 06 08		    ld b,8 
0c7b			Div16_Loop1: 
0c7b 17			    rla 
0c7c ed 6a		    adc hl,hl 
0c7e ed 52		    sbc hl,de 
0c80 30 01		    jr nc,Div16_NoAdd1 
0c82 19			    add hl,de 
0c83			Div16_NoAdd1: 
0c83 10 f6		    djnz Div16_Loop1 
0c85 17			    rla 
0c86 2f			    cpl 
0c87 47			    ld b,a 
0c88 79			    ld a,c 
0c89 48			    ld c,b 
0c8a 06 08		    ld b,8 
0c8c			Div16_Loop2: 
0c8c 17			    rla 
0c8d ed 6a		    adc hl,hl 
0c8f ed 52		    sbc hl,de 
0c91 30 01		    jr nc,Div16_NoAdd2 
0c93 19			    add hl,de 
0c94			Div16_NoAdd2: 
0c94 10 f6		    djnz Div16_Loop2 
0c96 17			    rla 
0c97 2f			    cpl 
0c98 41			    ld b,c 
0c99 4f			    ld c,a 
0c9a c9			ret 
0c9b			 
0c9b			 
0c9b			;http://z80-heaven.wikidot.com/math 
0c9b			; 
0c9b			;Inputs: 
0c9b			;     DE and A are factors 
0c9b			;Outputs: 
0c9b			;     A is not changed 
0c9b			;     B is 0 
0c9b			;     C is not changed 
0c9b			;     DE is not changed 
0c9b			;     HL is the product 
0c9b			;Time: 
0c9b			;     342+6x 
0c9b			; 
0c9b			Mult16: 
0c9b			 
0c9b 06 08		     ld b,8          ;7           7 
0c9d 21 00 00		     ld hl,0         ;10         10 
0ca0 29			       add hl,hl     ;11*8       88 
0ca1 07			       rlca          ;4*8        32 
0ca2 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ca4 19			         add hl,de   ;--         -- 
0ca5 10 f9		       djnz $-5      ;13*7+8     99 
0ca7 c9			ret 
0ca8			 
0ca8			; 
0ca8			; Square root of 16-bit value 
0ca8			; In:  HL = value 
0ca8			; Out:  D = result (rounded down) 
0ca8			; 
0ca8			;Sqr16: 
0ca8			;    ld de,#0040 
0ca8			;    ld a,l 
0ca8			;    ld l,h 
0ca8			;    ld h,d 
0ca8			;    or a 
0ca8			;    ld b,8 
0ca8			;Sqr16_Loop: 
0ca8			;    sbc hl,de 
0ca8			;    jr nc,Sqr16_Skip 
0ca8			;    add hl,de 
0ca8			;Sqr16_Skip: 
0ca8			;    ccf 
0ca8			;    rl d 
0ca8			;    add a,a 
0ca8			;    adc hl,hl 
0ca8			;    add a,a 
0ca8			;    adc hl,hl 
0ca8			;    djnz Sqr16_Loop 
0ca8			;    ret 
0ca8			; 
0ca8			; 
0ca8			; Divide 8-bit values 
0ca8			; In: Divide E by divider C 
0ca8			; Out: A = result, B = rest 
0ca8			; 
0ca8			Div8: 
0ca8 af			    xor a 
0ca9 06 08		    ld b,8 
0cab			Div8_Loop: 
0cab cb 13		    rl e 
0cad 17			    rla 
0cae 91			    sub c 
0caf 30 01		    jr nc,Div8_NoAdd 
0cb1 81			    add a,c 
0cb2			Div8_NoAdd: 
0cb2 10 f7		    djnz Div8_Loop 
0cb4 47			    ld b,a 
0cb5 7b			    ld a,e 
0cb6 17			    rla 
0cb7 2f			    cpl 
0cb8 c9			    ret 
0cb9			 
0cb9			; 
0cb9			; Multiply 8-bit value with a 16-bit value (unrolled) 
0cb9			; In: Multiply A with DE 
0cb9			; Out: HL = result 
0cb9			; 
0cb9			Mult12U: 
0cb9 2e 00		    ld l,0 
0cbb 87			    add a,a 
0cbc 30 01		    jr nc,Mult12U_NoAdd0 
0cbe 19			    add hl,de 
0cbf			Mult12U_NoAdd0: 
0cbf 29			    add hl,hl 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd1 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd1: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd2 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd2: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd3 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd3: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 30 01		    jr nc,Mult12U_NoAdd4 
0cd2 19			    add hl,de 
0cd3			Mult12U_NoAdd4: 
0cd3 29			    add hl,hl 
0cd4 87			    add a,a 
0cd5 30 01		    jr nc,Mult12U_NoAdd5 
0cd7 19			    add hl,de 
0cd8			Mult12U_NoAdd5: 
0cd8 29			    add hl,hl 
0cd9 87			    add a,a 
0cda 30 01		    jr nc,Mult12U_NoAdd6 
0cdc 19			    add hl,de 
0cdd			Mult12U_NoAdd6: 
0cdd 29			    add hl,hl 
0cde 87			    add a,a 
0cdf d0			    ret nc 
0ce0 19			    add hl,de 
0ce1 c9			    ret 
0ce2			 
0ce2			; 
0ce2			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ce2			; In: Multiply A with DE 
0ce2			;      Put lowest value in A for most efficient calculation 
0ce2			; Out: HL = result 
0ce2			; 
0ce2			Mult12R: 
0ce2 21 00 00		    ld hl,0 
0ce5			Mult12R_Loop: 
0ce5 cb 3f		    srl a 
0ce7 30 01		    jr nc,Mult12R_NoAdd 
0ce9 19			    add hl,de 
0cea			Mult12R_NoAdd: 
0cea cb 23		    sla e 
0cec cb 12		    rl d 
0cee b7			    or a 
0cef c2 e5 0c		    jp nz,Mult12R_Loop 
0cf2 c9			    ret 
0cf3			 
0cf3			; 
0cf3			; Multiply 16-bit values (with 32-bit result) 
0cf3			; In: Multiply BC with DE 
0cf3			; Out: BCHL = result 
0cf3			; 
0cf3			Mult32: 
0cf3 79			    ld a,c 
0cf4 48			    ld c,b 
0cf5 21 00 00		    ld hl,0 
0cf8 06 10		    ld b,16 
0cfa			Mult32_Loop: 
0cfa 29			    add hl,hl 
0cfb 17			    rla 
0cfc cb 11		    rl c 
0cfe 30 07		    jr nc,Mult32_NoAdd 
0d00 19			    add hl,de 
0d01 ce 00		    adc a,0 
0d03 d2 07 0d		    jp nc,Mult32_NoAdd 
0d06 0c			    inc c 
0d07			Mult32_NoAdd: 
0d07 10 f1		    djnz Mult32_Loop 
0d09 41			    ld b,c 
0d0a 4f			    ld c,a 
0d0b c9			    ret 
0d0c			 
0d0c			 
0d0c			 
0d0c			; 
0d0c			; Multiply 8-bit values 
0d0c			; In:  Multiply H with E 
0d0c			; Out: HL = result 
0d0c			; 
0d0c			Mult8: 
0d0c 16 00		    ld d,0 
0d0e 6a			    ld l,d 
0d0f 06 08		    ld b,8 
0d11			Mult8_Loop: 
0d11 29			    add hl,hl 
0d12 30 01		    jr nc,Mult8_NoAdd 
0d14 19			    add hl,de 
0d15			Mult8_NoAdd: 
0d15 10 fa		    djnz Mult8_Loop 
0d17 c9			    ret 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			;;http://z80-heaven.wikidot.com/math 
0d18			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d18			; 
0d18			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d18			;     ld a,16        ;7 
0d18			;     ld hl,0        ;10 
0d18			;     jp $+5         ;10 
0d18			;.DivLoop: 
0d18			;       add hl,bc    ;-- 
0d18			;       dec a        ;64 
0d18			;       jr z,.DivLoopEnd        ;86 
0d18			; 
0d18			;       sla e        ;128 
0d18			;       rl d         ;128 
0d18			;       adc hl,hl    ;240 
0d18			;       sbc hl,bc    ;240 
0d18			;       jr nc,.DivLoop ;23|21 
0d18			;       inc e        ;-- 
0d18			;       jp .DivLoop+1 
0d18			; 
0d18			;.DivLoopEnd: 
0d18			 
0d18			;HL_Div_C: 
0d18			;Inputs: 
0d18			;     HL is the numerator 
0d18			;     C is the denominator 
0d18			;Outputs: 
0d18			;     A is the remainder 
0d18			;     B is 0 
0d18			;     C is not changed 
0d18			;     DE is not changed 
0d18			;     HL is the quotient 
0d18			; 
0d18			;       ld b,16 
0d18			;       xor a 
0d18			;         add hl,hl 
0d18			;         rla 
0d18			;         cp c 
0d18			;         jr c,$+4 
0d18			;           inc l 
0d18			;           sub c 
0d18			;         djnz $-7 
0d18			 
0d18			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d18			 
0d18			addatohl: 
0d18 85			    add   a, l    ; A = A+L 
0d19 6f			    ld    l, a    ; L = A+L 
0d1a 8c			    adc   a, h    ; A = A+L+H+carry 
0d1b 95			    sub   l       ; A = H+carry 
0d1c 67			    ld    h, a    ; H = H+carry 
0d1d c9			ret 
0d1e			 
0d1e			addatode: 
0d1e 83			    add   a, e    ; A = A+L 
0d1f 5f			    ld    e, a    ; L = A+L 
0d20 8a			    adc   a, d    ; A = A+L+H+carry 
0d21 93			    sub   e       ; A = H+carry 
0d22 57			    ld    d, a    ; H = H+carry 
0d23 c9			ret 
0d24			 
0d24			 
0d24			addatobc: 
0d24 81			    add   a, c    ; A = A+L 
0d25 4f			    ld    c, a    ; L = A+L 
0d26 88			    adc   a, b    ; A = A+L+H+carry 
0d27 91			    sub   c       ; A = H+carry 
0d28 47			    ld    b, a    ; H = H+carry 
0d29 c9			ret 
0d2a			 
0d2a			subafromhl: 
0d2a			   ; If A=0 do nothing 
0d2a			    ; Otherwise flip A's sign. Since 
0d2a			    ; the upper byte becomes -1, also 
0d2a			    ; substract 1 from H. 
0d2a ed 44		    neg 
0d2c ca 35 0d		    jp    z, Skip 
0d2f 25			    dec   h 
0d30			     
0d30			    ; Now add the low byte as usual 
0d30			    ; Two's complement takes care of 
0d30			    ; ensuring the result is correct 
0d30 85			    add   a, l 
0d31 6f			    ld    l, a 
0d32 8c			    adc   a, h 
0d33 95			    sub   l 
0d34 67			    ld    h, a 
0d35			Skip: 
0d35 c9				ret 
0d36			 
0d36			 
0d36			; compare hl and de 
0d36			; returns:  
0d36			; if hl = de, z=1, s=0, c0=0 
0d36			; if hl > de, z=0, s=0, c=0 
0d36			; if hl < de, z=0, s=1, c=1 
0d36			cmp16:	 
0d36 b7				or a 
0d37 ed 52			sbc hl,de 
0d39 e0				ret po 
0d3a 7c				ld a,h 
0d3b 1f				rra 
0d3c ee 40			xor 01000000B 
0d3e 37				scf 
0d3f 8f				adc a,a 
0d40 c9				ret 
0d41			 
0d41			 
0d41			; test if hl contains zero   - A is destroyed 
0d41			 
0d41			ishlzero:    
0d41 b7				or a     ; reset flags 
0d42 7c				ld a, h 
0d43 b5				or l        	 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			 
0d45			 
0d45			if FORTH_ENABLE_FLOATMATH 
0d45			;include "float/bbcmath.z80" 
0d45			include "float/lpfpcalc.asm" 
0d45			endif 
0d45			 
0d45			 
0d45			; eof 
0d45			 
# End of file firmware_maths.asm
0d45			include "firmware_strings.asm"   ; string handling  
0d45			 
0d45			 
0d45			; TODO string len 
0d45			; input text string, end on cr with zero term 
0d45			; a offset into frame buffer to start prompt 
0d45			; d is max length 
0d45			; e is display size TODO 
0d45			; c is current cursor position 
0d45			; hl is ptr to where string will be stored 
0d45			 
0d45			 
0d45			; TODO check limit of buffer for new inserts 
0d45			; TODO check insert does not push beyond buffer 
0d45			; TODO scroll in a limited display area 
0d45			; TODO scroll whole screen on page wrap 
0d45			 
0d45			 
0d45			; TODO handle KEY_PREVWORD 
0d45			; TODO handle KEY_NEXTWORD 
0d45			; TODO handle KEY_HOME 
0d45			; TODO handle KEY_END 
0d45			; TODO use LCD cursor? 
0d45			 
0d45 32 ad fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d48 81					add c 
0d49 32 ab fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d4c 22 b0 fb				ld (input_start), hl     ; save ptr to buffer 
0d4f 79					ld a, c 
0d50 cd 18 0d				call addatohl 
0d53 22 b2 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d56 7a					ld a,d 
0d57 32 af fb			        ld (input_size), a       ; save length of input area 
0d5a 79					ld a, c 
0d5b 32 9e fb				ld (input_cursor),a      ; init cursor start position  
0d5e 7b					ld a,e 
0d5f 32 ae fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d62					 
0d62					 
0d62			 
0d62			;		ld a,(input_ptr) 
0d62			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d62			 
0d62			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d62					; init cursor shape if not set by the cin routines 
0d62 21 4d fa				ld hl, cursor_shape 
0d65 3e ff				ld a, 255 
0d67 77					ld (hl), a 
0d68 23					inc hl 
0d69 3e 00				ld a, 0 
0d6b 77					ld (hl), a 
0d6c			 
0d6c 3e 0f				ld a, CUR_BLINK_RATE 
0d6e 32 a9 fb				ld (input_cur_flash), a 
0d71 3e 01				ld a, 1 
0d73 32 a8 fb				ld (input_cur_onoff),a 
0d76			 
0d76			;	if DEBUG_INPUT 
0d76			;		push af 
0d76			;		ld a, 'I' 
0d76			;		ld (debug_mark),a 
0d76			;		pop af 
0d76			;		CALLMONITOR 
0d76			;	endif 
0d76			.is1:		; main entry loop 
0d76			 
0d76			 
0d76			 
0d76					; pause 1ms 
0d76			 
0d76 3e 01				ld a, 1 
0d78 cd 46 0a				call aDelayInMS 
0d7b			 
0d7b					; dec flash counter 
0d7b 3a a9 fb				ld a, (input_cur_flash) 
0d7e 3d					dec a 
0d7f 32 a9 fb				ld (input_cur_flash), a 
0d82 fe 00				cp 0 
0d84 20 0d				jr nz, .nochgstate 
0d86			 
0d86			 
0d86					; change state 
0d86 3a a8 fb				ld a,(input_cur_onoff) 
0d89 ed 44				neg 
0d8b 32 a8 fb				ld (input_cur_onoff),a 
0d8e			 
0d8e			 
0d8e					; reset on change of state 
0d8e 3e 0f				ld a, CUR_BLINK_RATE 
0d90 32 a9 fb				ld (input_cur_flash), a 
0d93			 
0d93			.nochgstate: 
0d93					 
0d93					 
0d93			 
0d93					; display cursor  
0d93			 
0d93			;		ld hl, (input_start) 
0d93			;		ld a, (input_cursor) 
0d93			;		call addatohl 
0d93			 
0d93					; get char under cursor and replace with cursor 
0d93 2a b2 fb		ld hl, (input_ptr) 
0d96			;		ld a, (hl) 
0d96			;		ld (input_under_cursor),a 
0d96			;		ld a, '_' 
0d96			;		ld (hl), a 
0d96			 
0d96					; display string 
0d96			 
0d96 ed 5b b0 fb			ld de, (input_start) 
0d9a 3a ad fb				ld a, (input_at_pos) 
0d9d cd f7 0a				call str_at_display 
0da0			;	        call update_display 
0da0			 
0da0					; find place to put the cursor 
0da0			;		add h 
0da0			;		ld l, display_row_1 
0da0			;		sub l 
0da0			; (input_at_pos) 
0da0					;ld c, a 
0da0			;		ld a, (input_cursor) 
0da0			;		ld l, (input_at_pos) 
0da0			;		;ld b, h 
0da0			;		add l 
0da0			;		ld (input_at_cursor),a 
0da0					;ld l,h 
0da0			 
0da0			;		ld h, 0 
0da0			;		ld l,(input_at_pos) 
0da0			;		ld a, (input_cursor) 
0da0			;		call addatohl 
0da0			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0da0			;		call subafromhl 
0da0			;		ld a,l 
0da0			;		ld (input_at_cursor), a 
0da0			 
0da0				if DEBUG_INPUT 
0da0					ld a, (hardware_diag) 
0da0					cp 0 
0da0					jr z, .skip_input_diag 
0da0			 
0da0					ld a,(input_at_pos) 
0da0					ld hl, LFSRSeed 
0da0					call hexout 
0da0					ld a, (input_cursor) 
0da0					ld hl, LFSRSeed+2 
0da0					call hexout 
0da0					ld a,(input_at_cursor) 
0da0					ld hl, LFSRSeed+4 
0da0					call hexout 
0da0			 
0da0					ld a,(input_cur_onoff) 
0da0					ld hl, LFSRSeed+6 
0da0					call hexout 
0da0			 
0da0					ld a,(input_cur_flash) 
0da0					ld hl, LFSRSeed+8 
0da0					call hexout 
0da0			 
0da0					ld a,(input_len) 
0da0					ld hl, LFSRSeed+10 
0da0					call hexout 
0da0					ld hl, LFSRSeed+12 
0da0					ld a, 0 
0da0					ld (hl),a 
0da0					ld a, display_row_4 
0da0					ld de, LFSRSeed 
0da0					call str_at_display 
0da0					.skip_input_diag: 
0da0				endif 
0da0			 
0da0					; decide on if we are showing the cursor this time round 
0da0			 
0da0 3a a8 fb				ld a, (input_cur_onoff) 
0da3 fe ff				cp 255 
0da5 28 13				jr z, .skipcur 
0da7			 
0da7			 
0da7 3a ab fb				ld a,(input_at_cursor) 
0daa 11 4d fa				ld de, cursor_shape 
0dad cd f7 0a				call str_at_display 
0db0			 
0db0					; save length of current input string 
0db0 2a b0 fb				ld hl, (input_start) 
0db3 cd 76 11				call strlenz 
0db6 7d					ld a,l 
0db7 32 a3 fb				ld (input_len),a 
0dba			 
0dba			.skipcur: 
0dba			 
0dba cd 07 0b			        call update_display 
0dbd					 
0dbd			 
0dbd			 
0dbd					; wait 
0dbd				 
0dbd					; TODO loop without wait to flash the cursor and char under cursor	 
0dbd cd 5f 67				call cin    ; _wait 
0dc0			 
0dc0 fe 00				cp 0 
0dc2 ca 76 0d				jp z, .is1 
0dc5			 
0dc5					; get ptr to char to input into 
0dc5			 
0dc5 4f					ld c,a 
0dc6 2a b0 fb				ld hl, (input_start) 
0dc9 3a 9e fb				ld a, (input_cursor) 
0dcc cd 18 0d				call addatohl 
0dcf 22 b2 fb				ld (input_ptr), hl 
0dd2 79					ld a,c 
0dd3			 
0dd3					; replace char under cursor 
0dd3			 
0dd3			;		ld hl, (input_ptr) 
0dd3			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dd3			;		ld (hl), a 
0dd3			 
0dd3			;	if DEBUG_INPUT 
0dd3			;		push af 
0dd3			;		ld a, 'i' 
0dd3			;		ld (debug_mark),a 
0dd3			;		pop af 
0dd3			;		CALLMONITOR 
0dd3			;	endif 
0dd3 fe 0e				cp KEY_HOME 
0dd5 20 0e				jr nz, .iske 
0dd7			 
0dd7 3a ad fb				ld a, (input_at_pos) 
0dda 32 ab fb				ld (input_at_cursor),a 
0ddd 3e 00				ld a, 0 
0ddf 32 9e fb				ld (input_cursor), a 
0de2 c3 76 0d				jp .is1 
0de5					 
0de5 fe 0f		.iske:		cp KEY_END 
0de7 20 03				jr nz, .isknw 
0de9 c3 76 0d				jp .is1 
0dec			 
0dec fe 06		.isknw:		cp KEY_NEXTWORD 
0dee 20 1b				jr nz, .iskpw 
0df0			 
0df0 2a b2 fb		.isknwm:	ld hl, (input_ptr) 
0df3 7e					ld a,(hl)	 
0df4 fe 00				cp 0 
0df6 ca 76 0d				jp z, .is1    ; end of string 
0df9 fe 20				cp ' ' 
0dfb ca 76 0d				jp z, .is1    ; end of word 
0dfe 23					inc hl 
0dff 22 b2 fb				ld (input_ptr), hl 
0e02 3a ab fb				ld a, (input_at_cursor) 
0e05 3c					inc a 
0e06 32 ab fb				ld (input_at_cursor), a 
0e09 18 e5				jr .isknwm 
0e0b			 
0e0b fe 07		.iskpw:		cp KEY_PREVWORD 
0e0d 20 1b				jr nz, .iskl 
0e0f			.iskpwm:	 
0e0f 2a b2 fb				ld hl, (input_ptr) 
0e12 7e					ld a,(hl)	 
0e13 fe 00				cp 0  
0e15 ca 76 0d				jp z, .is1    ; end of string 
0e18 fe 20				cp ' ' 
0e1a ca 76 0d				jp z, .is1    ; end of word 
0e1d 2b					dec hl 
0e1e 22 b2 fb				ld (input_ptr), hl 
0e21 3a ab fb				ld a, (input_at_cursor) 
0e24 3d					dec a 
0e25 32 ab fb				ld (input_at_cursor), a 
0e28 18 e5				jr .iskpwm 
0e2a			 
0e2a			 
0e2a fe 0b		.iskl:		cp KEY_LEFT 
0e2c 20 27				jr nz, .isk1 
0e2e			 
0e2e 3a 9e fb				ld a, (input_cursor) 
0e31			 
0e31 fe 00				cp 0 
0e33 ca 76 0d				jp z, .is1 		; at start of line to ignore  
0e36			 
0e36 3d					dec  a 		; TODO check underflow 
0e37 32 9e fb				ld (input_cursor), a 
0e3a			 
0e3a 2a b2 fb				ld hl, (input_ptr) 
0e3d 2b					dec hl 
0e3e 22 b2 fb				ld (input_ptr), hl 
0e41					 
0e41 3a ab fb				ld a, (input_at_cursor) 
0e44 3d					dec a 
0e45 32 ab fb				ld (input_at_cursor), a 
0e48			 
0e48 3e 01				ld a, 1		; show cursor moving 
0e4a 32 a8 fb				ld (input_cur_onoff),a 
0e4d 3e 0f				ld a, CUR_BLINK_RATE 
0e4f 32 a9 fb				ld (input_cur_flash), a 
0e52			 
0e52 c3 76 0d				jp .is1 
0e55			 
0e55 fe 0c		.isk1:		cp KEY_RIGHT 
0e57 20 2a				jr nz, .isk2 
0e59			 
0e59 3a a3 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e5c 5f					ld e,a 
0e5d 3a 9e fb				ld a, (input_cursor) 
0e60 bb					cp e 
0e61 ca 76 0d				jp z, .is1		; at the end of string so dont go right 
0e64			 
0e64 3c					inc  a 		; TODO check overflow 
0e65 32 9e fb				ld (input_cursor), a 
0e68			 
0e68 3a ab fb				ld a, (input_at_cursor) 
0e6b 3c					inc a 
0e6c 32 ab fb				ld (input_at_cursor), a 
0e6f			 
0e6f 2a b2 fb				ld hl, (input_ptr) 
0e72 23					inc hl 
0e73 22 b2 fb				ld (input_ptr), hl 
0e76			 
0e76 3e 01				ld a, 1		; show cursor moving 
0e78 32 a8 fb				ld (input_cur_onoff),a 
0e7b 3e 0f				ld a, CUR_BLINK_RATE 
0e7d 32 a9 fb				ld (input_cur_flash), a 
0e80			 
0e80 c3 76 0d				jp .is1 
0e83			 
0e83 fe 05		.isk2:		cp KEY_UP 
0e85			 
0e85 20 26				jr nz, .isk3 
0e87			 
0e87					; swap last command with the current on 
0e87			 
0e87					; move cursor to start of string 
0e87 2a b0 fb				ld hl, (input_start) 
0e8a 22 b2 fb				ld (input_ptr), hl 
0e8d			 
0e8d 3a ad fb				ld a, (input_at_pos) 
0e90 32 ab fb				ld (input_at_cursor), a 
0e93			 
0e93 3e 00				ld a, 0 
0e95 32 9e fb				ld (input_cursor), a 
0e98					 
0e98					; swap input and last command buffers 
0e98			 
0e98 21 c1 f2				ld hl, os_cli_cmd 
0e9b 11 c0 f3				ld de, os_last_cmd 
0e9e 06 ff				ld b, 255 
0ea0 7e			.swap1:		ld a, (hl) 
0ea1 4f					ld c,a 
0ea2 1a					ld a, (de) 
0ea3 77					ld (hl), a 
0ea4 79					ld a,c 
0ea5 12					ld (de),a 
0ea6 23					inc hl 
0ea7 13					inc de 
0ea8 10 f6				djnz .swap1 
0eaa			 
0eaa			 
0eaa			 
0eaa			 
0eaa			 
0eaa c3 76 0d				jp .is1 
0ead			 
0ead fe 08		.isk3:		cp KEY_BS 
0eaf 20 3c				jr nz, .isk4 
0eb1			 
0eb1 3a 9e fb				ld a, (input_cursor) 
0eb4			 
0eb4 fe 00				cp 0 
0eb6 ca 76 0d				jp z, .is1 		; at start of line to ignore  
0eb9			 
0eb9 3d					dec  a 		; TODO check underflow 
0eba 32 9e fb				ld (input_cursor), a 
0ebd			 
0ebd					; hl is source 
0ebd					; de needs to be source - 1 
0ebd			 
0ebd			;		ld a, 0 
0ebd			;		dec hl 
0ebd			;		ld (hl), a 
0ebd			 
0ebd 2a b2 fb				ld hl, (input_ptr) 
0ec0 2b					dec hl 
0ec1 22 b2 fb				ld (input_ptr), hl 
0ec4			 
0ec4					; shift all data 
0ec4			 
0ec4 e5					push hl 
0ec5 23					inc hl 
0ec6 d1					pop de 
0ec7 3a a3 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eca 4f					ld c,a 
0ecb 06 00				ld b,0 
0ecd ed b0				ldir  
0ecf			 
0ecf			 
0ecf			 
0ecf			 
0ecf 3a ab fb				ld a, (input_at_cursor) 
0ed2 3d					dec a 
0ed3 32 ab fb				ld (input_at_cursor), a 
0ed6			 
0ed6			 
0ed6 3e 01				ld a, 1		; show cursor moving 
0ed8 32 a8 fb				ld (input_cur_onoff),a 
0edb 3e 0f				ld a, CUR_BLINK_RATE 
0edd 32 a9 fb				ld (input_cur_flash), a 
0ee0			 
0ee0					; remove char 
0ee0 3a ab fb				ld a, (input_at_cursor) 
0ee3 3c					inc a 
0ee4 11 6e 0f				ld de,.iblank 
0ee7 cd f7 0a				call str_at_display 
0eea			 
0eea c3 76 0d				jp .is1 
0eed			 
0eed fe 0d		.isk4:		cp KEY_CR 
0eef 28 6c				jr z, .endinput 
0ef1			 
0ef1					; else add the key press to the end 
0ef1			 
0ef1 4f					ld c, a			; save key pressed 
0ef2			 
0ef2 7e					ld a,(hl)		; get what is currently under char 
0ef3			 
0ef3 fe 00				cp 0			; we are at the end of the string 
0ef5 20 2f				jr nz, .onchar 
0ef7					 
0ef7					; add a char to the end of the string 
0ef7				 
0ef7 71					ld (hl),c 
0ef8 23					inc hl 
0ef9			;		ld a,' ' 
0ef9			;		ld (hl),a 
0ef9			;		inc hl 
0ef9 3e 00				ld a,0 
0efb 77					ld (hl),a 
0efc 2b					dec hl 
0efd			 
0efd 3a 9e fb				ld a, (input_cursor) 
0f00 3c					inc a				; TODO check max string length and scroll  
0f01 32 9e fb				ld (input_cursor), a		; inc cursor pos 
0f04							 
0f04 3a ab fb				ld a, (input_at_cursor) 
0f07 3c					inc a 
0f08 32 ab fb				ld (input_at_cursor), a 
0f0b			 
0f0b 2a b2 fb				ld hl, (input_ptr) 
0f0e 23					inc hl 
0f0f 22 b2 fb				ld (input_ptr), hl 
0f12			 
0f12 2a b2 fb				ld hl, (input_ptr) 
0f15 23					inc hl 
0f16 22 b2 fb				ld (input_ptr), hl 
0f19			;	if DEBUG_INPUT 
0f19			;		push af 
0f19			;		ld a, '+' 
0f19			;		ld (debug_mark),a 
0f19			;		pop af 
0f19			;		CALLMONITOR 
0f19			;	endif 
0f19 3e 01				ld a, 1		; show cursor moving 
0f1b 32 a8 fb				ld (input_cur_onoff),a 
0f1e 3e 0f				ld a, CUR_BLINK_RATE 
0f20 32 a9 fb				ld (input_cur_flash), a 
0f23 c3 76 0d				jp .is1 
0f26					 
0f26			 
0f26			 
0f26					; if on a char then insert 
0f26			.onchar: 
0f26			 
0f26					; TODO over flow check: make sure insert does not blow out buffer 
0f26			 
0f26					; need to do some maths to use lddr 
0f26			 
0f26 e5					push hl   ; save char pos 
0f27 c5					push bc 
0f28			 
0f28 2a b0 fb				ld hl, (input_start) 
0f2b 3a a3 fb				ld a, (input_len) 
0f2e cd 18 0d				call addatohl  		; end of string 
0f31 23					inc hl 
0f32 23					inc hl		; past zero term 
0f33 e5					push hl 
0f34 23					inc hl 
0f35 e5					push hl  
0f36			 
0f36								; start and end of lddr set, now how much to move? 
0f36			 
0f36							 
0f36 3a 9e fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f39 47					ld b,a 
0f3a 3a a3 fb				ld a,(input_len) 
0f3d 5f					ld e,a 
0f3e 90					sub b 
0f3f 3c					inc a		;?? 
0f40 3c					inc a		;?? 
0f41 3c					inc a		;?? 
0f42			 
0f42 06 00				ld b,0 
0f44 4f					ld c,a 
0f45			 
0f45				if DEBUG_INPUT 
0f45					push af 
0f45					ld a, 'i' 
0f45					ld (debug_mark),a 
0f45					pop af 
0f45			;		CALLMONITOR 
0f45				endif 
0f45 d1					pop de 
0f46 e1					pop hl 
0f47				if DEBUG_INPUT 
0f47					push af 
0f47					ld a, 'I' 
0f47					ld (debug_mark),a 
0f47					pop af 
0f47			;		CALLMONITOR 
0f47				endif 
0f47 ed b8				lddr 
0f49				 
0f49			 
0f49			 
0f49					; TODO have a key for insert/overwrite mode???? 
0f49 c1					pop bc 
0f4a e1					pop hl 
0f4b 71					ld (hl), c		; otherwise overwrite current char 
0f4c					 
0f4c			 
0f4c			 
0f4c			 
0f4c 3a 9e fb				ld a, (input_cursor) 
0f4f 3c					inc  a 		; TODO check overflow 
0f50 32 9e fb				ld (input_cursor), a 
0f53			 
0f53 3a ab fb				ld a, (input_at_cursor) 
0f56 3c					inc a 
0f57 32 ab fb				ld (input_at_cursor), a 
0f5a			 
0f5a c3 76 0d				jp .is1 
0f5d			 
0f5d			.endinput:	; TODO look for end of string 
0f5d			 
0f5d					; add trailing space for end of token 
0f5d			 
0f5d 2a b0 fb				ld hl, (input_start) 
0f60 3a a3 fb				ld a,(input_len) 
0f63 cd 18 0d				call addatohl 
0f66 3e 20				ld a, ' ' 
0f68 77					ld (hl),a 
0f69					; TODO eof of parse marker 
0f69			 
0f69 23					inc hl 
0f6a 3e 00				ld a, 0 
0f6c 77					ld (hl),a 
0f6d			 
0f6d			 
0f6d c9					ret 
0f6e			 
0f6e .. 00		.iblank: db " ",0 
0f70			 
0f70			 
0f70 32 ad fb		input_str_prev:	ld (input_at_pos), a 
0f73 22 b0 fb				ld (input_start), hl 
0f76 3e 01				ld a,1			; add cursor 
0f78 77					ld (hl),a 
0f79 23					inc hl 
0f7a 3e 00				ld a,0 
0f7c 77					ld (hl),a 
0f7d 22 b2 fb				ld (input_ptr), hl 
0f80 7a					ld a,d 
0f81 32 af fb				ld (input_size), a 
0f84 3e 00				ld a,0 
0f86 32 9e fb				ld (input_cursor),a 
0f89			.instr1:	 
0f89			 
0f89					; TODO do block cursor 
0f89					; TODO switch cursor depending on the modifer key 
0f89			 
0f89					; update cursor shape change on key hold 
0f89			 
0f89 2a b2 fb				ld hl, (input_ptr) 
0f8c 2b					dec hl 
0f8d 3a 4d fa				ld a,(cursor_shape) 
0f90 77					ld (hl), a 
0f91			 
0f91					; display entered text 
0f91 3a ad fb				ld a,(input_at_pos) 
0f94 cd 7d 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f97 ed 5b b0 fb	            	LD   de, (input_start) 
0f9b cd 85 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f9e			 
0f9e cd 5f 67				call cin 
0fa1 fe 00				cp 0 
0fa3 28 e4				jr z, .instr1 
0fa5			 
0fa5					; proecess keyboard controls first 
0fa5			 
0fa5 2a b2 fb				ld hl,(input_ptr) 
0fa8			 
0fa8 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0faa 28 5a				jr z, .instrcr 
0fac			 
0fac fe 08				cp KEY_BS 	; back space 
0fae 20 0f				jr nz, .instr2 
0fb0					; process back space 
0fb0			 
0fb0					; TODO stop back space if at start of string 
0fb0 2b					dec hl 
0fb1 2b					dec hl ; to over write cursor 
0fb2 3a 4d fa				ld a,(cursor_shape) 
0fb5					;ld a,0 
0fb5 77					ld (hl),a 
0fb6 23					inc hl 
0fb7 3e 20				ld a," " 
0fb9 77					ld (hl),a 
0fba 22 b2 fb				ld (input_ptr),hl 
0fbd					 
0fbd			 
0fbd 18 ca				jr .instr1 
0fbf			 
0fbf fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fc1 20 06				jr nz, .instr3 
0fc3 2b					dec hl 
0fc4 22 b2 fb				ld (input_ptr),hl 
0fc7 18 c0				jr .instr1 
0fc9				 
0fc9 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fcb 20 06				jr nz, .instr4 
0fcd 23					inc hl 
0fce 22 b2 fb				ld (input_ptr),hl 
0fd1 18 b6				jr .instr1 
0fd3			 
0fd3 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fd5 20 06				jr nz, .instr5 
0fd7 2b					dec hl 
0fd8 22 b2 fb				ld (input_ptr),hl 
0fdb 18 ac				jr .instr1 
0fdd			 
0fdd fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fdf 20 06				jr nz, .instr6 
0fe1 2b					dec hl 
0fe2 22 b2 fb				ld (input_ptr),hl 
0fe5 18 a2				jr .instr1 
0fe7 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fe9 20 0b				jr nz, .instrnew 
0feb			 
0feb 21 9a ef			ld hl, scratch 
0fee 11 c0 f3			ld de, os_last_cmd 
0ff1 cd 0f 10			call strcpy 
0ff4 18 93				jr .instr1 
0ff6			 
0ff6			 
0ff6			.instrnew:	; no special key pressed to see if we have room to store it 
0ff6			 
0ff6					; TODO do string size test 
0ff6			 
0ff6 2b					dec hl ; to over write cursor 
0ff7 77					ld (hl),a 
0ff8 23					inc hl 
0ff9 3a 4d fa				ld a,(cursor_shape) 
0ffc 77					ld (hl),a 
0ffd 23					inc hl 
0ffe 3e 00				ld a,0 
1000 77					ld (hl),a 
1001			 
1001 22 b2 fb				ld (input_ptr),hl 
1004					 
1004 18 83				jr .instr1 
1006 2b			.instrcr:	dec hl		; remove cursor 
1007 3e 20				ld a,' '	; TODO add a trailing space for safety 
1009 77					ld (hl),a 
100a 23					inc hl 
100b 3e 00				ld a,0 
100d 77					ld (hl),a 
100e			 
100e			 
100e					; if at end of line scroll up    
100e					; TODO detecting only end of line 4 for scroll up  
100e			 
100e					;ld   
100e			 
100e c9					ret 
100f			 
100f			 
100f			; strcpy hl = dest, de source 
100f			 
100f 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1010 b7			            OR   A              ;Null terminator? 
1011 c8			            RET  Z              ;Yes, so finished 
1012 1a					ld a,(de) 
1013 77					ld (hl),a 
1014 13			            INC  DE             ;Point to next character 
1015 23					inc hl 
1016 18 f7		            JR   strcpy       ;Repeat 
1018 c9					ret 
1019			 
1019			 
1019			; TODO string_at  
1019			; pass string which starts with lcd offset address and then null term string 
1019			 
1019			; TODO string to dec 
1019			; TODO string to hex 
1019			; TODO byte to string hex 
1019			; TODO byte to string dec 
1019			 
1019			 
1019			 
1019			; from z80uartmonitor 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1019			; pass hl for where to put the text 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019 c5			hexout:	PUSH BC 
101a f5					PUSH AF 
101b 47					LD B, A 
101c					; Upper nybble 
101c cb 3f				SRL A 
101e cb 3f				SRL A 
1020 cb 3f				SRL A 
1022 cb 3f				SRL A 
1024 cd 34 10				CALL tohex 
1027 77					ld (hl),a 
1028 23					inc hl	 
1029					 
1029					; Lower nybble 
1029 78					LD A, B 
102a e6 0f				AND 0FH 
102c cd 34 10				CALL tohex 
102f 77					ld (hl),a 
1030 23					inc hl	 
1031					 
1031 f1					POP AF 
1032 c1					POP BC 
1033 c9					RET 
1034					 
1034			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1034			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1034			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1034			tohex: 
1034 e5					PUSH HL 
1035 d5					PUSH DE 
1036 16 00				LD D, 0 
1038 5f					LD E, A 
1039 21 41 10				LD HL, .DATA 
103c 19					ADD HL, DE 
103d 7e					LD A, (HL) 
103e d1					POP DE 
103f e1					POP HL 
1040 c9					RET 
1041			 
1041			.DATA: 
1041 30					DEFB	30h	; 0 
1042 31					DEFB	31h	; 1 
1043 32					DEFB	32h	; 2 
1044 33					DEFB	33h	; 3 
1045 34					DEFB	34h	; 4 
1046 35					DEFB	35h	; 5 
1047 36					DEFB	36h	; 6 
1048 37					DEFB	37h	; 7 
1049 38					DEFB	38h	; 8 
104a 39					DEFB	39h	; 9 
104b 41					DEFB	41h	; A 
104c 42					DEFB	42h	; B 
104d 43					DEFB	43h	; C 
104e 44					DEFB	44h	; D 
104f 45					DEFB	45h	; E 
1050 46					DEFB	46h	; F 
1051			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1051			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1051			;;    subtract $30, if result > 9 then subtract $7 more 
1051			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1051			atohex: 
1051 d6 30				SUB $30 
1053 fe 0a				CP 10 
1055 f8					RET M		; If result negative it was 0-9 so we're done 
1056 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1058 c9					RET		 
1059			 
1059			 
1059			 
1059			 
1059			; Get 2 ASCII characters as hex byte from pointer in hl 
1059			 
1059			BYTERD: 
1059 16 00			LD	D,00h		;Set up 
105b cd 63 10			CALL	HEXCON		;Get byte and convert to hex 
105e 87				ADD	A,A		;First nibble so 
105f 87				ADD	A,A		;multiply by 16 
1060 87				ADD	A,A		; 
1061 87				ADD	A,A		; 
1062 57				LD	D,A		;Save hi nibble in D 
1063			HEXCON: 
1063 7e				ld a, (hl)		;Get next chr 
1064 23				inc hl 
1065 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1067 fe 0a			CP	00Ah		;Is it 0-9 ? 
1069 38 02			JR	C,NALPHA	;If so miss next bit 
106b d6 07			SUB	007h		;Else convert alpha 
106d			NALPHA: 
106d b2				OR	D		;Add hi nibble back 
106e c9				RET			; 
106f			 
106f			 
106f			; 
106f			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
106f			; Since the routines get_byte and therefore get_nibble are called, only valid 
106f			; characters (0-9a-f) are accepted. 
106f			; 
106f			;get_word        push    af 
106f			;                call    get_byte        ; Get the upper byte 
106f			;                ld      h, a 
106f			;                call    get_byte        ; Get the lower byte 
106f			;                ld      l, a 
106f			;                pop     af 
106f			;                ret 
106f			; 
106f			; Get a byte in hexadecimal notation. The result is returned in A. Since 
106f			; the routine get_nibble is used only valid characters are accepted - the  
106f			; input routine only accepts characters 0-9a-f. 
106f			; 
106f c5			get_byte:        push    bc              ; Save contents of B (and C) 
1070 7e					ld a,(hl) 
1071 23					inc hl 
1072 cd 97 10		                call    nibble2val      ; Get upper nibble 
1075 cb 07		                rlc     a 
1077 cb 07		                rlc     a 
1079 cb 07		                rlc     a 
107b cb 07		                rlc     a 
107d 47			                ld      b, a            ; Save upper four bits 
107e 7e					ld a,(hl) 
107f cd 97 10		                call    nibble2val      ; Get lower nibble 
1082 b0			                or      b               ; Combine both nibbles 
1083 c1			                pop     bc              ; Restore B (and C) 
1084 c9			                ret 
1085			; 
1085			; Get a hexadecimal digit from the serial line. This routine blocks until 
1085			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1085			; to the serial line interface. The lower 4 bits of A contain the value of  
1085			; that particular digit. 
1085			; 
1085			;get_nibble      ld a,(hl)           ; Read a character 
1085			;                call    to_upper        ; Convert to upper case 
1085			;                call    is_hex          ; Was it a hex digit? 
1085			;                jr      nc, get_nibble  ; No, get another character 
1085			 ;               call    nibble2val      ; Convert nibble to value 
1085			 ;               call    print_nibble 
1085			 ;               ret 
1085			; 
1085			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1085			; A valid hexadecimal digit is denoted by a set C flag. 
1085			; 
1085			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1085			;                ret     nc              ; Yes 
1085			;                cp      '0'             ; Less than '0'? 
1085			;                jr      nc, is_hex_1    ; No, continue 
1085			;                ccf                     ; Complement carry (i.e. clear it) 
1085			;                ret 
1085			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1085			;                ret     c               ; Yes 
1085			;                cp      'A'             ; Less than 'A'? 
1085			;                jr      nc, is_hex_2    ; No, continue 
1085			;                ccf                     ; Yes - clear carry and return 
1085			;                ret 
1085			;is_hex_2        scf                     ; Set carry 
1085			;                ret 
1085			; 
1085			; Convert a single character contained in A to upper case: 
1085			; 
1085 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1087 d8			                ret     c 
1088 fe 7b		                cp      'z' + 1         ; > 'z'? 
108a d0			                ret     nc              ; Nothing to do, either 
108b e6 5f		                and     $5f             ; Convert to upper case 
108d c9			                ret 
108e			 
108e			 
108e			to_lower: 
108e			 
108e			   ; if char is in [A-Z] make it lower case 
108e			 
108e			   ; enter : a = char 
108e			   ; exit  : a = lower case char 
108e			   ; uses  : af 
108e			 
108e fe 41		   cp 'A' 
1090 d8			   ret c 
1091			    
1091 fe 5b		   cp 'Z'+1 
1093 d0			   ret nc 
1094			    
1094 f6 20		   or $20 
1096 c9			   ret 
1097			 
1097			; 
1097			; Expects a hexadecimal digit (upper case!) in A and returns the 
1097			; corresponding value in A. 
1097			; 
1097 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1099 38 02		                jr      c, nibble2val_1 ; Yes 
109b d6 07		                sub     7               ; Adjust for A-F 
109d d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
109f e6 0f		                and     $f              ; Only return lower 4 bits 
10a1 c9			                ret 
10a2			; 
10a2			; Print_nibble prints a single hex nibble which is contained in the lower  
10a2			; four bits of A: 
10a2			; 
10a2			;print_nibble    push    af              ; We won't destroy the contents of A 
10a2			;                and     $f              ; Just in case... 
10a2			;                add     a, '0'             ; If we have a digit we are done here. 
10a2			;                cp      '9' + 1         ; Is the result > 9? 
10a2			;                jr      c, print_nibble_1 
10a2			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10a2			;print_nibble_1  call    putc            ; Print the nibble and 
10a2			;                pop     af              ; restore the original value of A 
10a2			;                ret 
10a2			;; 
10a2			;; Send a CR/LF pair: 
10a2			; 
10a2			;crlf            push    af 
10a2			;                ld      a, cr 
10a2			;                call    putc 
10a2			;                ld      a, lf 
10a2			;                call    putc 
10a2			;                pop     af 
10a2			;                ret 
10a2			; 
10a2			; Print_word prints the four hex digits of a word to the serial line. The  
10a2			; word is expected to be in HL. 
10a2			; 
10a2			;print_word      push    hl 
10a2			;                push    af 
10a2			;                ld      a, h 
10a2			;                call    print_byte 
10a2			;                ld      a, l 
10a2			;                call    print_byte 
10a2			;                pop     af 
10a2			;                pop     hl 
10a2			;                ret 
10a2			; 
10a2			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10a2			; The byte to be printed is expected to be in A. 
10a2			; 
10a2			;print_byte      push    af              ; Save the contents of the registers 
10a2			;                push    bc 
10a2			;                ld      b, a 
10a2			;                rrca 
10a2			;                rrca 
10a2			;                rrca 
10a2			;                rrca 
10a2			;                call    print_nibble    ; Print high nibble 
10a2			;                ld      a, b 
10a2			;                call    print_nibble    ; Print low nibble 
10a2			;                pop     bc              ; Restore original register contents 
10a2			;                pop     af 
10a2			;                ret 
10a2			 
10a2			 
10a2			 
10a2			 
10a2			 
10a2			fourehexhl:  
10a2 7e				ld a,(hl) 
10a3 cd 51 10			call atohex 
10a6 cb 3f				SRL A 
10a8 cb 3f				SRL A 
10aa cb 3f				SRL A 
10ac cb 3f				SRL A 
10ae 47				ld b, a 
10af 23				inc hl 
10b0 7e				ld a,(hl) 
10b1 23				inc hl 
10b2 cd 51 10			call atohex 
10b5 80				add b 
10b6 57				ld d,a 
10b7 7e				ld a,(hl) 
10b8 cd 51 10			call atohex 
10bb cb 3f				SRL A 
10bd cb 3f				SRL A 
10bf cb 3f				SRL A 
10c1 cb 3f				SRL A 
10c3 47				ld b, a 
10c4 23				inc hl 
10c5 7e				ld a,(hl) 
10c6 23				inc hl 
10c7 cd 51 10			call atohex 
10ca 80				add b 
10cb 5f				ld e, a 
10cc d5				push de 
10cd e1				pop hl 
10ce c9				ret 
10cf			 
10cf			; pass hl. returns z set if the byte at hl is a digit 
10cf			;isdigithl:  
10cf			;	push bc 
10cf			;	ld a,(hl) 
10cf			;	cp ':' 
10cf			;	jr nc, .isdf 		; > 
10cf			;	cp '0' 
10cf			;	jr c, .isdf		; < 
10cf			; 
10cf			;	; TODO find a better way to set z 
10cf			; 
10cf			;	ld b,a 
10cf			;	cp b 
10cf			;	pop bc 
10cf			;	ret 
10cf			; 
10cf			;.isdf:	; not digit so clear z 
10cf			; 
10cf			;	; TODO find a better way to unset z 
10cf			; 
10cf			;	ld b,a 
10cf			;	inc b 
10cf			;	cp b 
10cf			; 
10cf			;	pop bc 
10cf			;	ret 
10cf				 
10cf				 
10cf			 
10cf			 
10cf			; pass hl as the four byte address to load 
10cf			 
10cf			get_word_hl:  
10cf e5				push hl 
10d0 cd 6f 10			call get_byte 
10d3				 
10d3 47				ld b, a 
10d4			 
10d4 e1				pop hl 
10d5 23				inc hl 
10d6 23				inc hl 
10d7			 
10d7			; TODO not able to handle a-f  
10d7 7e				ld a,(hl) 
10d8			;	;cp ':' 
10d8			;	cp 'g' 
10d8			;	jr nc, .single_byte_hl 		; > 
10d8			;	cp 'G' 
10d8			;	jr nc, .single_byte_hl 		; > 
10d8			;	cp '0' 
10d8			;	jr c, .single_byte_hl		; < 
10d8			 
10d8				;call isdigithl 
10d8 fe 00			cp 0 
10da 28 06			jr z, .single_byte_hl 
10dc			 
10dc			.getwhln:   ; hex word so get next byte 
10dc			 
10dc cd 6f 10			call get_byte 
10df 6f				ld l, a 
10e0 60				ld h,b 
10e1 c9				ret 
10e2 68			.single_byte_hl:   ld l,b 
10e3 26 00				ld h,0 
10e5 c9					ret 
10e6			 
10e6			 
10e6			 
10e6			 
10e6 21 e4 19			ld hl,asc+1 
10e9			;	ld a, (hl) 
10e9			;	call nibble2val 
10e9 cd 6f 10			call get_byte 
10ec			 
10ec			;	call fourehexhl 
10ec 32 ce ef			ld (scratch+52),a 
10ef				 
10ef 21 cc ef			ld hl,scratch+50 
10f2 22 bd f2			ld (os_cur_ptr),hl 
10f5			 
10f5 c9				ret 
10f6			 
10f6			 
10f6			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10f6			 
10f6			; Decimal Unsigned Version 
10f6			 
10f6			;Number in a to decimal ASCII 
10f6			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10f6			;Example: display a=56 as "056" 
10f6			;input: a = number 
10f6			;Output: a=0,value of a in the screen 
10f6			;destroys af,bc (don't know about hl and de) 
10f6			DispAToASCII: 
10f6 0e 9c			ld	c,-100 
10f8 cd 02 11			call	.Na1 
10fb 0e f6			ld	c,-10 
10fd cd 02 11			call	.Na1 
1100 0e ff			ld	c,-1 
1102 06 2f		.Na1:	ld	b,'0'-1 
1104 04			.Na2:	inc	b 
1105 81				add	a,c 
1106 38 fc			jr	c,.Na2 
1108 91				sub	c		;works as add 100/10/1 
1109 f5				push af		;safer than ld c,a 
110a 78				ld	a,b		;char is in b 
110b			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
110b f1				pop af		;safer than ld a,c 
110c c9				ret 
110d			 
110d			; Decimal Signed Version 
110d			 
110d			; DispA 
110d			; -------------------------------------------------------------- 
110d			; Converts a signed integer value to a zero-terminated ASCII 
110d			; string representative of that value (using radix 10). 
110d			; -------------------------------------------------------------- 
110d			; INPUTS: 
110d			;     HL     Value to convert (two's complement integer). 
110d			;     DE     Base address of string destination. (pointer). 
110d			; -------------------------------------------------------------- 
110d			; OUTPUTS: 
110d			;     None 
110d			; -------------------------------------------------------------- 
110d			; REGISTERS/MEMORY DESTROYED 
110d			; AF HL 
110d			; -------------------------------------------------------------- 
110d			 
110d			;DispHLToASCII: 
110d			;   push    de 
110d			;   push    bc 
110d			; 
110d			;; Detect sign of HL. 
110d			;    bit    7, h 
110d			;    jr     z, ._DoConvert 
110d			; 
110d			;; HL is negative. Output '-' to string and negate HL. 
110d			;    ld     a, '-' 
110d			;    ld     (de), a 
110d			;    inc    de 
110d			; 
110d			;; Negate HL (using two's complement) 
110d			;    xor    a 
110d			;    sub    l 
110d			;    ld     l, a 
110d			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
110d			;    sbc    a, h 
110d			;    ld     h, a 
110d			; 
110d			;; Convert HL to digit characters 
110d			;._DoConvert: 
110d			;    ld     b, 0     ; B will count character length of number 
110d			;-   ld     a, 10 
110d			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
110d			;    push   af 
110d			;    inc    b 
110d			;    ld     a, h 
110d			;    or     l 
110d			;    jr     nz, - 
110d			; 
110d			;; Retrieve digits from stack 
110d			;-   pop    af 
110d			;    or     $30 
110d			;    ld     (de), a 
110d			;    inc    de 
110d			;    djnz   - 
110d			; 
110d			;; Terminate string with NULL 
110d			;    xor    a 
110d			;    ld     (de), a 
110d			; 
110d			;    pop    bc 
110d			;    pop    de 
110d			;    ret 
110d			 
110d			;Comments 
110d			; 
110d			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
110d			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
110d			;    Note that the output string will not be fixed-width. 
110d			; 
110d			;Example Usage 
110d			; 
110d			;    ld    hl, -1004 
110d			;    ld    de, OP1 
110d			;    call  DispA 
110d			;    ld    hl, OP1 
110d			;    syscall  PutS 
110d			 
110d			 
110d			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
110d			 
110d			 
110d			;Converts an ASCII string to an unsigned 16-bit integer 
110d			;Quits when it reaches a non-decimal digit 
110d			 
110d			string_to_uint16: 
110d			atoui_16: 
110d			;Input: 
110d			;     DE points to the string 
110d			;Outputs: 
110d			;     HL is the result 
110d			;     A is the 8-bit value of the number 
110d			;     DE points to the byte after the number 
110d			;Destroys: 
110d			;     BC 
110d			;       if the string is non-empty, BC is HL/10 
110d			;Size:  24 bytes 
110d			;Speed: 42+d(104+{0,9}) 
110d			;       d is the number of digits in the number 
110d			;       max is 640 cycles for a 5 digit number 
110d			;Assuming no leading zeros: 
110d			;1 digit:  146cc 
110d			;2 digit:  250cc 
110d			;3 digit:  354cc or 363cc (avg: 354.126cc) 
110d			;4 digit:  458cc or 467cc (avg: 458.27cc) 
110d			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
110d			;avg: 544.81158447265625cc (544+13297/16384) 
110d			;=============================================================== 
110d 21 00 00		  ld hl,0 
1110			.u16a: 
1110 1a			  ld a,(de) 
1111 d6 30		  sub 30h 
1113 fe 0a		  cp 10 
1115 d0			  ret nc 
1116 13			  inc de 
1117 44			  ld b,h 
1118 4d			  ld c,l 
1119 29			  add hl,hl 
111a 29			  add hl,hl 
111b 09			  add hl,bc 
111c 29			  add hl,hl 
111d 85			  add a,l 
111e 6f			  ld l,a 
111f 30 ef		  jr nc,.u16a 
1121 24			  inc h 
1122 c3 10 11		  jp .u16a 
1125			 
1125			 
1125			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1125			 
1125			;written by Zeda 
1125			;Converts a 16-bit unsigned integer to an ASCII string. 
1125			 
1125			uitoa_16: 
1125			;Input: 
1125			;   DE is the number to convert 
1125			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1125			;Output: 
1125			;   HL points to the null-terminated ASCII string 
1125			;      NOTE: This isn't necessarily the same as the input HL. 
1125 d5			  push de 
1126 c5			  push bc 
1127 f5			  push af 
1128 eb			  ex de,hl 
1129			 
1129 01 f0 d8		  ld bc,-10000 
112c 3e 2f		  ld a,'0'-1 
112e 3c			  inc a 
112f 09			  add hl,bc  
1130 38 fc		   jr c,$-2 
1132 12			  ld (de),a 
1133 13			  inc de 
1134			 
1134 01 e8 03		  ld bc,1000 
1137 3e 3a		  ld a,'9'+1 
1139 3d			  dec a  
113a 09			  add hl,bc  
113b 30 fc		   jr nc,$-2 
113d 12			  ld (de),a 
113e 13			  inc de 
113f			 
113f 01 9c ff		  ld bc,-100 
1142 3e 2f		  ld a,'0'-1 
1144 3c			  inc a  
1145 09			  add hl,bc  
1146 38 fc		   jr c,$-2 
1148 12			  ld (de),a 
1149 13			  inc de 
114a			 
114a 7d			  ld a,l 
114b 26 3a		  ld h,'9'+1 
114d 25			  dec h  
114e c6 0a		  add a,10  
1150 30 fb		   jr nc,$-3 
1152 c6 30		  add a,'0' 
1154 eb			  ex de,hl 
1155 72			  ld (hl),d 
1156 23			  inc hl 
1157 77			  ld (hl),a 
1158 23			  inc hl 
1159 36 00		  ld (hl),0 
115b			 
115b			;Now strip the leading zeros 
115b 0e fa		  ld c,-6 
115d 09			  add hl,bc 
115e 3e 30		  ld a,'0' 
1160 23			  inc hl  
1161 be			  cp (hl)  
1162 28 fc		  jr z,$-2 
1164			 
1164			;Make sure that the string is non-empty! 
1164 7e			  ld a,(hl) 
1165 b7			  or a 
1166 20 01		  jr nz,.atoub 
1168 2b			  dec hl 
1169			.atoub: 
1169			 
1169 f1			  pop af 
116a c1			  pop bc 
116b d1			  pop de 
116c c9			  ret 
116d			 
116d			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
116d			 
116d			toUpper: 
116d			;A is the char. 
116d			;If A is a lowercase letter, this sets it to the matching uppercase 
116d			;18cc or 30cc or 41cc 
116d			;avg: 26.75cc 
116d fe 61		  cp 'a' 
116f d8			  ret c 
1170 fe 7b		  cp 'z'+1 
1172 d0			  ret nc 
1173 d6 20		  sub 'a'-'A' 
1175 c9			  ret 
1176			 
1176			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1176			 
1176			; String Length 
1176			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1176			 
1176			; Get the length of the null-terminated string starting at $8000 hl 
1176			;    LD     HL, $8000 
1176			 
1176			strlenz: 
1176			 
1176 af			    XOR    A               ; Zero is the value we are looking for. 
1177 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1178 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1179			                           ; 65, 536 bytes (the entire addressable memory space). 
1179 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
117b			 
117b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
117b 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
117c 6f			    LD     L, A             ; number of bytes 
117d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117f 2b			    DEC    HL              ; Compensate for null. 
1180 c9				ret 
1181			 
1181			; Get the length of the A terminated string starting at $8000 hl 
1181			;    LD     HL, $8000 
1181			 
1181			strlent: 
1181			 
1181			                  ; A is the value we are looking for. 
1181 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1183 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1185			                           ; 65, 536 bytes (the entire addressable memory space). 
1185 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1187			 
1187			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1187 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1189 2e 00		    LD     L, 0             ; number of bytes 
118b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
118d 2b			    DEC    HL              ; Compensate for null. 
118e c9				ret 
118f			 
118f			 
118f			;Comparing Strings 
118f			 
118f			;IN    HL     Address of string1. 
118f			;      DE     Address of string2. 
118f			 
118f			; doc given but wrong??? 
118f			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
118f			;      carry  Set if string1 > string2, reset if string1 <= string2. 
118f			; tested 
118f			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
118f			 
118f			strcmp_old: 
118f e5			    PUSH   HL 
1190 d5			    PUSH   DE 
1191			 
1191 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1192 be			    CP     (HL)            ; (want to minimize work). 
1193 38 01		    JR     C, Str1IsBigger 
1195 7e			    LD     A, (HL) 
1196			 
1196			Str1IsBigger: 
1196 4f			    LD     C, A             ; Put length in BC 
1197 06 00		    LD     B, 0 
1199 13			    INC    DE              ; Increment pointers to meat of string. 
119a 23			    INC    HL 
119b			 
119b			CmpLoop: 
119b 1a			    LD     A, (DE)          ; Compare bytes. 
119c ed a1		    CPI 
119e 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11a0 13			    INC    DE              ; Update pointer. 
11a1 ea 9b 11		    JP     PE, CmpLoop 
11a4			 
11a4 d1			    POP    DE 
11a5 e1			    POP    HL 
11a6 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
11a7 be			    CP     (HL) 
11a8 c9			    RET 
11a9			 
11a9			NoMatch: 
11a9 2b			    DEC    HL 
11aa be			    CP     (HL)            ; Compare again to affect carry. 
11ab d1			    POP    DE 
11ac e1			    POP    HL 
11ad c9			    RET 
11ae			 
11ae			;; test strmp 
11ae			; 
11ae			;ld de, .str1 
11ae			;ld hl, .str2 
11ae			;call strcmp 
11ae			;jr z, .z1 
11ae			;;this 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "NZ1" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			;.z1: 
11ae			; 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "ZZ1" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			; 
11ae			;ld de, .str1 
11ae			;ld hl, .str1 
11ae			;call strcmp 
11ae			;jr z, .z2 
11ae			;;this 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "NZ2" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			;.z2: 
11ae			; 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "ZZ2" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			; 
11ae			;ld de, .str1 
11ae			;ld hl, .str2 
11ae			;call strcmp 
11ae			;jr c, .c1 
11ae			; 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "Nc1" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			;.c1: 
11ae			;;this 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "cc1" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			; 
11ae			;ld de, .str1 
11ae			;ld hl, .str1 
11ae			;call strcmp 
11ae			;jr c, .c2 
11ae			;;this 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "Nc2" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			;.c2: 
11ae			; 
11ae			;	if DEBUG_FORTH_WORDS 
11ae			;		DMARK "cc2" 
11ae			;		CALLMONITOR 
11ae			;	endif 
11ae			;	NEXTW 
11ae			;.str1:   db "string1",0 
11ae			;.str2:   db "string2",0 
11ae			 
11ae			; only care about direct match or not 
11ae			; hl and de strings 
11ae			; zero set if the same 
11ae			 
11ae			strcmp: 
11ae 1a				ld a, (de) 
11af be				cp (hl) 
11b0 28 02			jr z, .ssame 
11b2 b7				or a 
11b3 c9				ret 
11b4			 
11b4			.ssame:  
11b4 fe 00			cp 0 
11b6 c8				ret z 
11b7			 
11b7 23				inc hl 
11b8 13				inc de 
11b9 18 f3			jr strcmp 
11bb				 
11bb				 
11bb			 
11bb			 
11bb			 
11bb			 
11bb			; eof 
11bb			 
11bb			 
11bb			 
11bb			 
11bb			 
11bb			 
# End of file firmware_strings.asm
11bb			include "firmware_memory.asm"   ; malloc and free  
11bb			 
11bb			if DEBUG_FORTH_MALLOC_HIGH 
11bb			.mallocsize: db "Wants malloc >256",0 
11bb			.mallocasize: db "MALLOC gives >256",0 
11bb			.malloczero: db "MALLOC gives zero",0 
11bb			 
11bb			malloc_guard_zerolen: 
11bb				push hl 
11bb				push de 
11bb				push af 
11bb			 
11bb				ld de, 0 
11bb			        call cmp16 
11bb				jr nz, .lowalloz 
11bb			 
11bb				push hl 
11bb				push de 
11bb					ld hl, display_fb0 
11bb					ld (display_fb_active), hl 
11bb				call clear_display 
11bb				ld a, 0 
11bb				ld de, .malloczero 
11bb				call str_at_display 
11bb				call update_display 
11bb				call delay1s 
11bb				call delay1s 
11bb				ld a, 0 
11bb				ld (os_view_disable), a 
11bb			 
11bb				pop de 
11bb				pop hl 
11bb			 
11bb				 
11bb			 
11bb				CALLMONITOR 
11bb			.lowalloz: 
11bb			 
11bb			 
11bb				pop af 
11bb				pop de 
11bb				pop hl 
11bb			ret 
11bb			 
11bb			malloc_guard_entry: 
11bb				push hl 
11bb				push de 
11bb				push af 
11bb			 
11bb			 	or a      ;clear carry flag 
11bb				push hl 
11bb				ld de, 255 
11bb				sbc hl, de 
11bb				jr c, .lowalloc 
11bb			 
11bb				push de 
11bb					ld hl, display_fb0 
11bb					ld (display_fb_active), hl 
11bb				call clear_display 
11bb				ld a, 0 
11bb				ld de, .mallocsize 
11bb				call str_at_display 
11bb				call update_display 
11bb				call delay1s 
11bb				call delay1s 
11bb				ld a, 0 
11bb				ld (os_view_disable), a 
11bb			 
11bb				pop de 
11bb				pop hl 
11bb			 
11bb				 
11bb			 
11bb				CALLMONITOR 
11bb				jr .lowdone 
11bb			.lowalloc: 
11bb			 
11bb			 
11bb				pop hl 
11bb			.lowdone:	pop af 
11bb				pop de 
11bb				pop hl 
11bb			ret 
11bb			 
11bb			malloc_guard_exit: 
11bb				push hl 
11bb				push de 
11bb				push af 
11bb			 
11bb			 	or a      ;clear carry flag 
11bb				push hl 
11bb				ld de, 255 
11bb				sbc hl, de 
11bb				jr c, .lowallocx 
11bb			 
11bb				push de 
11bb					ld hl, display_fb0 
11bb					ld (display_fb_active), hl 
11bb				call clear_display 
11bb				ld a, 0 
11bb				ld de, .mallocasize 
11bb				call str_at_display 
11bb				call update_display 
11bb				call delay1s 
11bb				call delay1s 
11bb				ld a, 0 
11bb				ld (os_view_disable), a 
11bb				pop de 
11bb				pop hl 
11bb			 
11bb				CALLMONITOR 
11bb				jr .lowdonex 
11bb			.lowallocx: 
11bb			 
11bb				pop hl 
11bb			.lowdonex:	pop af 
11bb				pop de 
11bb				pop hl 
11bb			ret 
11bb			endif 
11bb			 
11bb			if MALLOC_2 
11bb			; Z80 Malloc and Free Functions 
11bb			 
11bb			; Malloc Function: 
11bb			; Input: 
11bb			;   HL: Size of block to allocate 
11bb			; Output: 
11bb			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11bb			 
11bb			malloc: 
11bb				 
11bb			if DEBUG_FORTH_MALLOC_HIGH 
11bb			call malloc_guard_entry 
11bb			endif 
11bb			 
11bb			 
11bb			 
11bb			 
11bb					if DEBUG_FORTH_MALLOC 
11bb						DMARK "mal" 
11bb						CALLMONITOR 
11bb					endif 
11bb			    push af            ; Save AF register 
11bb			    ld a, l            ; Load low byte of size into A 
11bb			    or h               ; Check if size is zero 
11bb			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11bb			 
11bb			    ; Allocate memory 
11bb			    ld hl, (heap_start) ; Load start of heap into HL 
11bb					if DEBUG_FORTH_MALLOC 
11bb						DMARK "ma1" 
11bb						CALLMONITOR 
11bb					endif 
11bb			    call malloc_internal ; Call internal malloc function 
11bb			    pop af             ; Restore AF register 
11bb			if DEBUG_FORTH_MALLOC_HIGH 
11bb			call malloc_guard_exit 
11bb			call malloc_guard_zerolen 
11bb			endif 
11bb			    ret                ; Return 
11bb			 
11bb			; Free Function: 
11bb			; Input: 
11bb			;   HL: Pointer to memory block to free 
11bb			; Output: 
11bb			;   None 
11bb			 
11bb			free: 
11bb			    push af            ; Save AF register 
11bb			    ld a, l            ; Load low byte of pointer into A 
11bb			    or h               ; Check if pointer is NULL 
11bb			    jp z, free_exit    ; If pointer is NULL, exit 
11bb			 
11bb			    ; Free memory 
11bb			    ld hl, (heap_start) ; Load start of heap into HL 
11bb			    call free_internal  ; Call internal free function 
11bb			    pop af             ; Restore AF register 
11bb			    ret                ; Return 
11bb			 
11bb			; Internal Malloc Function: 
11bb			; Input: 
11bb			;   HL: Size of block to allocate 
11bb			; Output: 
11bb			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11bb			 
11bb			malloc_internal: 
11bb			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11bb			    add hl, bc         ; Add management overhead to requested size 
11bb			    ex de, hl          ; Save total size in DE, and keep it in HL 
11bb					if DEBUG_FORTH_MALLOC 
11bb						DMARK "ma2" 
11bb						CALLMONITOR 
11bb					endif 
11bb			 
11bb			    ; Search for free memory block 
11bb			    ld de, (heap_end)  ; Load end of heap into DE 
11bb			    ld bc, 0           ; Initialize counter 
11bb			 
11bb					if DEBUG_FORTH_MALLOC 
11bb						DMARK "ma2" 
11bb						CALLMONITOR 
11bb					endif 
11bb			malloc_search_loop: 
11bb			    ; Check if current block is free 
11bb			    ld a, (hl)         ; Load current block's status (free or used) 
11bb			    cp 0               ; Compare with zero (free) 
11bb			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11bb			 
11bb			    ; Check if current block is large enough 
11bb			    ld a, (hl+1)       ; Load high byte of block size 
11bb			    cp l               ; Compare with low byte of requested size 
11bb			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11bb			 
11bb			    ld a, (hl+2)       ; Load low byte of block size 
11bb			    cp h               ; Compare with high byte of requested size 
11bb			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11bb			 
11bb			    ; Mark block as used 
11bb			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11bb			 
11bb			    ; Calculate remaining space in block 
11bb			    ld bc, 0           ; Clear BC 
11bb			    add hl, bc         ; Increment HL to point to start of data block 
11bb			    add hl, de         ; HL = HL + DE (total size) 
11bb			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11bb			    add hl, bc         ; Add management overhead to start of data block 
11bb			 
11bb			    ; Save pointer to allocated block in HL 
11bb			if DEBUG_FORTH_MALLOC_HIGH 
11bb						DMARK "ma5" 
11bb			call malloc_guard_exit 
11bb			call malloc_guard_zerolen 
11bb			endif 
11bb			    ret 
11bb			 
11bb			malloc_skip_block_check: 
11bb			    ; Move to the next block 
11bb			    ld bc, 3           ; Size of management overhead 
11bb			    add hl, bc         ; Move to the next block 
11bb			    inc de             ; Increment counter 
11bb			 
11bb			    ; Check if we have reached the end of heap 
11bb			    ld a, e            ; Load low byte of heap end address 
11bb			    cp (hl)            ; Compare with low byte of current address 
11bb			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11bb			    ld a, d            ; Load high byte of heap end address 
11bb			    cp 0               ; Check if it's zero (end of memory) 
11bb			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11bb			 
11bb			    ; If we reached here, allocation failed 
11bb			    xor a              ; Set result to NULL 
11bb			if DEBUG_FORTH_MALLOC_HIGH 
11bb						DMARK "ma6" 
11bb			call malloc_guard_exit 
11bb			call malloc_guard_zerolen 
11bb			endif 
11bb			    ret 
11bb			malloc_exit: 
11bb			if DEBUG_FORTH_MALLOC_HIGH 
11bb						DMARK "ma7" 
11bb			call malloc_guard_exit 
11bb			call malloc_guard_zerolen 
11bb			endif 
11bb			    ret 
11bb			 
11bb			; Internal Free Function: 
11bb			; Input: 
11bb			;   HL: Pointer to memory block to free 
11bb			; Output: 
11bb			;   None 
11bb			 
11bb			free_internal: 
11bb			    ld de, (heap_start) ; Load start of heap into DE 
11bb			    ld bc, 0            ; Initialize counter 
11bb			 
11bb			free_search_loop: 
11bb			    ; Check if current block contains the pointer 
11bb			    ld a, l             ; Load low byte of pointer 
11bb			    cp (hl+1)           ; Compare with high byte of current block's address 
11bb			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11bb			    ld a, h             ; Load high byte of pointer 
11bb			    cp (hl+2)           ; Compare with low byte of current block's address 
11bb			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11bb			 
11bb			    ; Mark block as free 
11bb			    ld (hl), 0          ; Set status byte to indicate free block 
11bb			    ret                 ; Return 
11bb			 
11bb			free_skip_block_check: 
11bb			    ; Move to the next block 
11bb			    ld bc, 3            ; Size of management overhead 
11bb			    add hl, bc          ; Move to the next block 
11bb			    inc de              ; Increment counter 
11bb			 
11bb			    ; Check if we have reached the end of heap 
11bb			    ld a, e             ; Load low byte of heap end address 
11bb			    cp (hl)             ; Compare with low byte of current address 
11bb			    jr nz, free_search_loop  ; If not equal, continue searching 
11bb			    ld a, d             ; Load high byte of heap end address 
11bb			    cp 0                ; Check if it's zero (end of memory) 
11bb			    jr nz, free_search_loop  ; If not zero, continue searching 
11bb			 
11bb			    ; If we reached here, pointer is not found in heap 
11bb			    ret 
11bb			 
11bb			free_exit: 
11bb			    ret                 ; Return 
11bb			 
11bb			; Define heap start and end addresses 
11bb			;heap_start:    .dw 0xC000   ; Start of heap 
11bb			;heap_end:      .dw 0xE000   ; End of heap 
11bb			 
11bb			endif 
11bb			 
11bb			 
11bb			if MALLOC_1 
11bb			 
11bb			 
11bb			 
11bb			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11bb			 
11bb			;moved to firmware.asm 
11bb			;heap_start        .equ  0x9000      ; Starting address of heap 
11bb			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11bb			 
11bb			;      .org 0 
11bb			;      jp    main 
11bb			 
11bb			 
11bb			;      .org  0x100 
11bb			;main: 
11bb			;      ld    HL, 0x8100 
11bb			;      ld    SP, HL 
11bb			; 
11bb			;      call  heap_init 
11bb			; 
11bb			;      ; Make some allocations 
11bb			;      ld    HL, 12 
11bb			;      call  malloc            ; Allocates 0x9004 
11bb			; 
11bb			;      ld    HL, 12 
11bb			;      call  malloc            ; Allocates 0x9014 
11bb			; 
11bb			;      ld    HL, 12 
11bb			;      call  malloc            ; Allocates 0x9024 
11bb			; 
11bb			;      ; Free some allocations 
11bb			;      ld    HL, 0x9014 
11bb			;      call  free 
11bb			; 
11bb			;      ld    HL, 0x9004 
11bb			;      call  free 
11bb			; 
11bb			;      ld    HL, 0x9024 
11bb			;      call  free 
11bb			; 
11bb			; 
11bb			;      halt 
11bb			 
11bb			 
11bb			;------------------------------------------------------------------------------ 
11bb			;     heap_init                                                               : 
11bb			;                                                                             : 
11bb			; Description                                                                 : 
11bb			;     Initialise the heap and make it ready for malloc and free operations.   : 
11bb			;                                                                             : 
11bb			;     The heap is maintained as a linked list, starting with an initial       : 
11bb			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11bb			;     the first free block in the heap. Each block then points to the next    : 
11bb			;     free block within the heap, and the free list ends at the first block   : 
11bb			;     with a null pointer to the next free block.                             : 
11bb			;                                                                             : 
11bb			; Parameters                                                                  : 
11bb			;     Inputs are compile-time only. Two defines which specify the starting    : 
11bb			;     address of the heap and its size are required, along with a memory      : 
11bb			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11bb			;     principally stores a pointer to the first free block in the heap.       : 
11bb			;                                                                             : 
11bb			; Returns                                                                     : 
11bb			;     Nothing                                                                 : 
11bb			;------------------------------------------------------------------------------ 
11bb			heap_init: 
11bb e5			      push  HL 
11bc			 
11bc			      ; Initialise free list struct 
11bc 21 0e 80		      ld    HL, heap_start 
11bf 22 0a 80		      ld    (free_list), HL 
11c2 21 00 00		      ld    HL, 0 
11c5 22 0c 80		      ld    (free_list+2), HL 
11c8			 
11c8			      ; Insert first free block at bottom of heap, consumes entire heap 
11c8 21 0a 80		      ld    HL, heap_start+heap_size-4 
11cb 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11ce 21 fc ff		      ld    HL, heap_size-4 
11d1 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11d4			 
11d4			      ; Insert end of free list block at top of heap - two null words will 
11d4			      ; terminate the free list 
11d4 21 00 00		      ld    HL, 0 
11d7 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11da 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11dd			 
11dd e1			      pop   HL 
11de			 
11de c9			      ret 
11df			 
11df			 
11df			;------------------------------------------------------------------------------ 
11df			;     malloc                                                                  : 
11df			;                                                                             : 
11df			; Description                                                                 : 
11df			;     Allocates the wanted space from the heap and returns the address of the : 
11df			;     first useable byte of the allocation.                                   : 
11df			;                                                                             : 
11df			;     Allocations can happen in one of two ways:                              : 
11df			;                                                                             : 
11df			;     1. A free block may be found which is the exact size wanted. In this    : 
11df			;        case the block is removed from the free list and retuedn to the      : 
11df			;        caller.                                                              : 
11df			;     2. A free block may be found which is larger than the size wanted. In   : 
11df			;        this case, the larger block is split into two. The first portion of  : 
11df			;        this block will become the requested space by the malloc call and    : 
11df			;        is returned to the caller. The second portion becomes a new free     : 
11df			;        block, and the free list is adjusted to maintain continuity via this : 
11df			;        newly created block.                                                 : 
11df			;                                                                             : 
11df			;     malloc does not set any initial value in the allocated space, the       : 
11df			;     caller is required to do this as required.                              : 
11df			;                                                                             : 
11df			;     This implementation of malloc uses the stack exclusively, and is        : 
11df			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11df			;     advisable to disable interrupts before calling malloc, and recommended  : 
11df			;     to avoid the use of malloc inside ISRs in general.                      : 
11df			;                                                                             : 
11df			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11df			;                                                                             : 
11df			; Parameters                                                                  : 
11df			;     HL  Number of bytes wanted                                              : 
11df			;                                                                             : 
11df			; Returns                                                                     : 
11df			;     HL  Address of the first useable byte of the allocation                 : 
11df			;                                                                             : 
11df			; Flags                                                                       : 
11df			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11df			;                                                                             : 
11df			; Stack frame                                                                 : 
11df			;       |             |                                                       : 
11df			;       +-------------+                                                       : 
11df			;       |     BC      |                                                       : 
11df			;       +-------------+                                                       : 
11df			;       |     DE      |                                                       : 
11df			;       +-------------+                                                       : 
11df			;       |     IX      |                                                       : 
11df			;       +-------------+                                                       : 
11df			;       |  prev_free  |                                                       : 
11df			;   +4  +-------------+                                                       : 
11df			;       |  this_free  |                                                       : 
11df			;   +2  +-------------+                                                       : 
11df			;       |  next_free  |                                                       : 
11df			;   +0  +-------------+                                                       : 
11df			;       |             |                                                       : 
11df			;                                                                             : 
11df			;------------------------------------------------------------------------------ 
11df			 
11df			 
11df			;malloc: 
11df			; 
11df			;	SAVESP ON 1 
11df			; 
11df			;	call malloc_code 
11df			; 
11df			;	CHECKSP ON 1 
11df			;	ret 
11df			 
11df			 
11df			malloc: 
11df c5			      push  BC 
11e0 d5			      push  DE 
11e1 dd e5		      push  IX 
11e3			if DEBUG_FORTH_MALLOC_HIGH 
11e3			call malloc_guard_entry 
11e3			endif 
11e3			 
11e3					if DEBUG_FORTH_MALLOC 
11e3						DMARK "mal" 
11e3						CALLMONITOR 
11e3					endif 
11e3 7c			      ld    A, H                    ; Exit if no space requested 
11e4 b5			      or    L 
11e5 ca a4 12		      jp    Z, malloc_early_exit 
11e8			 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			; 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			;inc hl 
11e8			 
11e8			 
11e8			 
11e8			 
11e8					if DEBUG_FORTH_MALLOC 
11e8						DMARK "maA" 
11e8						CALLMONITOR 
11e8					endif 
11e8			      ; Set up stack frame 
11e8 eb			      ex    DE, HL 
11e9 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11ec 39			      add   HL, SP 
11ed f9			      ld    SP, HL 
11ee dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11f2 dd 39		      add   IX, SP 
11f4			 
11f4			      ; Setup initial state 
11f4 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11f7 19			      add   HL, DE 
11f8			 
11f8 44			      ld    B, H                    ; Move want to BC 
11f9 4d			      ld    C, L 
11fa			 
11fa 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11fd dd 75 04		      ld    (IX+4), L 
1200 dd 74 05		      ld    (IX+5), H 
1203			 
1203 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1204 23			      inc   HL 
1205 56			      ld    D, (HL) 
1206 dd 73 02		      ld    (IX+2), E 
1209 dd 72 03		      ld    (IX+3), D 
120c eb			      ex    DE, HL                  ; this_free ptr into HL 
120d			 
120d					if DEBUG_FORTH_MALLOC 
120d						DMARK "maB" 
120d						CALLMONITOR 
120d					endif 
120d			      ; Loop through free block list to find some space 
120d			malloc_find_space: 
120d 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1211 b3			      or    E 
1212 ca 9e 12		      jp    Z, malloc_no_space 
1215			 
1215 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1218 dd 72 01		      ld    (IX+1), D 
121b			 
121b			      ; Does this block have enough space to make the allocation? 
121b 23			      inc   HL                      ; Load free block size into DE 
121c 5e			      ld    E, (HL) 
121d 23			      inc   HL 
121e 56			      ld    D, (HL) 
121f			 
121f eb			      ex    DE, HL                  ; Check size of block against want 
1220 b7			      or    A                       ; Ensure carry flag clear 
1221 ed 42		      sbc   HL, BC 
1223 e5			      push  HL                      ; Store the result for later (new block size) 
1224			 
1224 ca 73 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1227 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1229			 
1229			      ; this_free block is not big enough, setup ptrs to test next free block 
1229 e1			      pop   HL                      ; Discard previous result 
122a			 
122a dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
122d dd 66 03		      ld    H, (IX+3) 
1230 dd 75 04		      ld    (IX+4), L 
1233 dd 74 05		      ld    (IX+5), H 
1236			 
1236 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1239 dd 66 01		      ld    H, (IX+1) 
123c dd 75 02		      ld    (IX+2), L 
123f dd 74 03		      ld    (IX+3), H 
1242			 
1242					if DEBUG_FORTH_MALLOC 
1242						DMARK "MA>" 
1242						CALLMONITOR 
1242					endif 
1242 18 c9		      jr    malloc_find_space 
1244			 
1244			      ; split a bigger block into two - requested size and remaining size 
1244			malloc_alloc_split: 
1244					if DEBUG_FORTH_MALLOC 
1244						DMARK "MAs" 
1244						CALLMONITOR 
1244					endif 
1244 eb			      ex    DE, HL                  ; Calculate address of new free block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248 09			      add   HL, BC 
1249			 
1249			      ; Create a new block and point it at next_free 
1249 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
124c dd 56 01		      ld    D, (IX+1) 
124f			 
124f 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1250 23			      inc   HL 
1251 72			      ld    (HL), D 
1252			 
1252 d1			      pop   DE                      ; Store size of new block into new block 
1253 23			      inc   HL 
1254 73			      ld    (HL), E 
1255 23			      inc   HL 
1256 72			      ld    (HL), D 
1257			 
1257			      ; Update this_free ptr to point to new block 
1257 2b			      dec   HL 
1258 2b			      dec   HL 
1259 2b			      dec   HL 
125a			 
125a dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
125d dd 56 03		      ld    D, (IX+3) 
1260			 
1260 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1263 dd 74 03		      ld    (IX+3), H 
1266			 
1266			      ; Modify this_free block to be allocation 
1266 eb			      ex    DE, HL 
1267 af			      xor   A                       ; Null the next block ptr of allocated block 
1268 77			      ld    (HL), A 
1269 23			      inc   HL 
126a 77			      ld    (HL), A 
126b			 
126b 23			      inc   HL                      ; Store want size into allocated block 
126c 71			      ld    (HL), C 
126d 23			      inc   HL 
126e 70			      ld    (HL), B 
126f 23			      inc   HL 
1270 e5			      push  HL                      ; Address of allocation to return 
1271			 
1271 18 19		      jr    malloc_update_links 
1273			 
1273			malloc_alloc_fit: 
1273 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1274			 
1274					if DEBUG_FORTH_MALLOC 
1274						DMARK "MAf" 
1274						CALLMONITOR 
1274					endif 
1274			      ; Modify this_free block to be allocation 
1274 eb			      ex    DE, HL 
1275 2b			      dec   HL 
1276 2b			      dec   HL 
1277 2b			      dec   HL 
1278			 
1278 af			      xor   A                       ; Null the next block ptr of allocated block 
1279 77			      ld    (HL), A 
127a 23			      inc   HL 
127b 77			      ld    (HL), A 
127c			 
127c 23			      inc   HL                      ; Store address of allocation to return 
127d 23			      inc   HL 
127e 23			      inc   HL 
127f e5			      push  HL 
1280			 
1280			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1280 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1283 dd 66 01		      ld    H, (IX+1) 
1286			 
1286 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1289 dd 74 03		      ld    (IX+3), H 
128c			 
128c			 
128c			malloc_update_links: 
128c			      ; Update prev_free ptr to point to this_free 
128c dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
128f dd 66 05		      ld    H, (IX+5) 
1292			 
1292 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1295 dd 56 03		      ld    D, (IX+3) 
1298			 
1298 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1299 23			      inc   HL 
129a 72			      ld    (HL), D 
129b			 
129b					if DEBUG_FORTH_MALLOC 
129b						DMARK "Mul" 
129b						CALLMONITOR 
129b					endif 
129b			      ; Clear the Z flag to indicate successful allocation 
129b 7a			      ld    A, D 
129c b3			      or    E 
129d			 
129d d1			      pop   DE                      ; Address of allocation 
129e					if DEBUG_FORTH_MALLOC 
129e						DMARK "MAu" 
129e						CALLMONITOR 
129e					endif 
129e			 
129e			malloc_no_space: 
129e 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12a1 39			      add   HL, SP 
12a2 f9			      ld    SP, HL 
12a3			 
12a3 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
12a4					if DEBUG_FORTH_MALLOC 
12a4						DMARK "MAN" 
12a4						CALLMONITOR 
12a4					endif 
12a4			 
12a4			malloc_early_exit: 
12a4					if DEBUG_FORTH_MALLOC 
12a4						DMARK "MAx" 
12a4						CALLMONITOR 
12a4					endif 
12a4 dd e1		      pop   IX 
12a6 d1			      pop   DE 
12a7 c1			      pop   BC 
12a8			 
12a8			if DEBUG_FORTH_MALLOC_HIGH 
12a8			call malloc_guard_exit 
12a8			call malloc_guard_zerolen 
12a8			endif 
12a8 c9			      ret 
12a9			 
12a9			 
12a9			;------------------------------------------------------------------------------ 
12a9			;     free                                                                    : 
12a9			;                                                                             : 
12a9			; Description                                                                 : 
12a9			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12a9			;     returned by malloc, otherwise the behaviour is undefined.               : 
12a9			;                                                                             : 
12a9			;     Where possible, directly adjacent free blocks will be merged together   : 
12a9			;     into larger blocks to help ensure that the heap does not become         : 
12a9			;     excessively fragmented.                                                 : 
12a9			;                                                                             : 
12a9			;     free does not clear or set any other value into the freed space, and    : 
12a9			;     therefore its contents may be visible through subsequent malloc's. The  : 
12a9			;     caller should clear the freed space as required.                        : 
12a9			;                                                                             : 
12a9			;     This implementation of free uses the stack exclusively, and is          : 
12a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12a9			;     advisable to disable interrupts before calling free, and recommended    : 
12a9			;     to avoid the use of free inside ISRs in general.                        : 
12a9			;                                                                             : 
12a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12a9			;                                                                             : 
12a9			; Parameters                                                                  : 
12a9			;     HL  Pointer to address of first byte of allocation to be freed          : 
12a9			;                                                                             : 
12a9			; Returns                                                                     : 
12a9			;     Nothing                                                                 : 
12a9			;                                                                             : 
12a9			; Stack frame                                                                 : 
12a9			;       |             |                                                       : 
12a9			;       +-------------+                                                       : 
12a9			;       |     BC      |                                                       : 
12a9			;       +-------------+                                                       : 
12a9			;       |     DE      |                                                       : 
12a9			;       +-------------+                                                       : 
12a9			;       |     IX      |                                                       : 
12a9			;       +-------------+                                                       : 
12a9			;       |  prev_free  |                                                       : 
12a9			;   +2  +-------------+                                                       : 
12a9			;       |  next_free  |                                                       : 
12a9			;   +0  +-------------+                                                       : 
12a9			;       |             |                                                       : 
12a9			;                                                                             : 
12a9			;------------------------------------------------------------------------------ 
12a9			free: 
12a9 c5			      push  BC 
12aa d5			      push  DE 
12ab dd e5		      push  IX 
12ad			 
12ad 7c			      ld    A, H                    ; Exit if ptr is null 
12ae b5			      or    L 
12af ca 73 13		      jp    Z, free_early_exit 
12b2			 
12b2			      ; Set up stack frame 
12b2 eb			      ex    DE, HL 
12b3 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12b6 39			      add   HL, SP 
12b7 f9			      ld    SP, HL 
12b8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12bc dd 39		      add   IX, SP 
12be			 
12be			      ; The address in HL points to the start of the useable allocated space, 
12be			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12be			      ; address of the block itself. 
12be eb			      ex    DE, HL 
12bf 11 fc ff		      ld    DE, -4 
12c2 19			      add   HL, DE 
12c3			 
12c3			      ; An allocated block must have a null next block pointer in it 
12c3 7e			      ld    A, (HL) 
12c4 23			      inc   HL 
12c5 b6			      or    (HL) 
12c6 c2 6e 13		      jp    NZ, free_done 
12c9			 
12c9 2b			      dec   HL 
12ca			 
12ca 44			      ld    B, H                    ; Copy HL to BC 
12cb 4d			      ld    C, L 
12cc			 
12cc			      ; Loop through the free list to find the first block with an address 
12cc			      ; higher than the block being freed 
12cc 21 0a 80		      ld    HL, free_list 
12cf			 
12cf			free_find_higher_block: 
12cf 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12d0 23			      inc   HL 
12d1 56			      ld    D, (HL) 
12d2 2b			      dec   HL 
12d3			 
12d3 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12d6 dd 72 01		      ld    (IX+1), D 
12d9 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12dc dd 74 03		      ld    (IX+3), H 
12df			 
12df 78			      ld    A, B                    ; Check if DE is greater than BC 
12e0 ba			      cp    D                       ; Compare MSB first 
12e1 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12e3 30 04		      jr    NC, free_find_higher_block_skip 
12e5 79			      ld    A, C 
12e6 bb			      cp    E                       ; Then compare LSB 
12e7 38 08		      jr    C, free_found_higher_block 
12e9			 
12e9			free_find_higher_block_skip: 
12e9 7a			      ld    A, D                    ; Reached the end of the free list? 
12ea b3			      or    E 
12eb ca 6e 13		      jp    Z, free_done 
12ee			 
12ee eb			      ex    DE, HL 
12ef			 
12ef 18 de		      jr    free_find_higher_block 
12f1			 
12f1			free_found_higher_block: 
12f1			      ; Insert freed block between prev and next free blocks 
12f1 71			      ld    (HL), C                 ; Point prev free block to freed block 
12f2 23			      inc   HL 
12f3 70			      ld    (HL), B 
12f4			 
12f4 60			      ld    H, B                    ; Point freed block at next free block 
12f5 69			      ld    L, C 
12f6 73			      ld    (HL), E 
12f7 23			      inc   HL 
12f8 72			      ld    (HL), D 
12f9			 
12f9			      ; Check if the freed block is adjacent to the next free block 
12f9 23			      inc   HL                      ; Load size of freed block into HL 
12fa 5e			      ld    E, (HL) 
12fb 23			      inc   HL 
12fc 56			      ld    D, (HL) 
12fd eb			      ex    DE, HL 
12fe			 
12fe 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ff			 
12ff dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1302 dd 56 01		      ld    D, (IX+1) 
1305			 
1305 b7			      or    A                       ; Clear the carry flag 
1306 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1308 20 22		      jr    NZ, free_check_adjacent_to_prev 
130a			 
130a			      ; Freed block is adjacent to next, merge into one bigger block 
130a eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
130b 5e			      ld    E, (HL) 
130c 23			      inc   HL 
130d 56			      ld    D, (HL) 
130e e5			      push  HL                      ; Save ptr to next block for later 
130f			 
130f 60			      ld    H, B                    ; Store ptr from next block into freed block 
1310 69			      ld    L, C 
1311 73			      ld    (HL), E 
1312 23			      inc   HL 
1313 72			      ld    (HL), D 
1314			 
1314 e1			      pop   HL                      ; Restore ptr to next block 
1315 23			      inc   HL                      ; Load size of next block into DE 
1316 5e			      ld    E, (HL) 
1317 23			      inc   HL 
1318 56			      ld    D, (HL) 
1319 d5			      push  DE                      ; Save next block size for later 
131a			 
131a 60			      ld    H, B                    ; Load size of freed block into HL 
131b 69			      ld    L, C 
131c 23			      inc   HL 
131d 23			      inc   HL 
131e 5e			      ld    E, (HL) 
131f 23			      inc   HL 
1320 56			      ld    D, (HL) 
1321 eb			      ex    DE, HL 
1322			 
1322 d1			      pop   DE                      ; Restore size of next block 
1323 19			      add   HL, DE                  ; Add sizes of both blocks 
1324 eb			      ex    DE, HL 
1325			 
1325 60			      ld    H, B                    ; Store new bigger size into freed block 
1326 69			      ld    L, C 
1327 23			      inc   HL 
1328 23			      inc   HL 
1329 73			      ld    (HL), E 
132a 23			      inc   HL 
132b 72			      ld    (HL), D 
132c			 
132c			free_check_adjacent_to_prev: 
132c			      ; Check if the freed block is adjacent to the prev free block 
132c dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
132f dd 66 03		      ld    H, (IX+3) 
1332			 
1332 23			      inc   HL                      ; Size of prev free block into DE 
1333 23			      inc   HL 
1334 5e			      ld    E, (HL) 
1335 23			      inc   HL 
1336 56			      ld    D, (HL) 
1337 2b			      dec   HL 
1338 2b			      dec   HL 
1339 2b			      dec   HL 
133a			 
133a 19			      add   HL, DE                  ; Add prev block addr and size 
133b			 
133b b7			      or    A                       ; Clear the carry flag 
133c ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
133e 20 2e		      jr    NZ, free_done 
1340			 
1340			      ; Freed block is adjacent to prev, merge into one bigger block 
1340 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1341 69			      ld    L, C 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 e5			      push  HL                      ; Save freed block ptr for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1349 dd 66 03		      ld    H, (IX+3) 
134c 73			      ld    (HL), E 
134d 23			      inc   HL 
134e 72			      ld    (HL), D 
134f			 
134f e1			      pop   HL                      ; Restore freed block ptr 
1350 23			      inc   HL                      ; Load size of freed block into DE 
1351 5e			      ld    E, (HL) 
1352 23			      inc   HL 
1353 56			      ld    D, (HL) 
1354 d5			      push  DE                      ; Save freed block size for later 
1355			 
1355 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1358 dd 66 03		      ld    H, (IX+3) 
135b 23			      inc   HL 
135c 23			      inc   HL 
135d 5e			      ld    E, (HL) 
135e 23			      inc   HL 
135f 56			      ld    D, (HL) 
1360			 
1360 e1			      pop   HL                      ; Add sizes of both blocks 
1361 19			      add   HL, DE 
1362 eb			      ex    DE, HL 
1363			 
1363 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366 dd 66 03		      ld    H, (IX+3) 
1369 23			      inc   HL 
136a 23			      inc   HL 
136b 73			      ld    (HL), E 
136c 23			      inc   HL 
136d 72			      ld    (HL), D 
136e			 
136e			free_done: 
136e 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1371 39			      add   HL, SP 
1372 f9			      ld    SP, HL 
1373			 
1373			free_early_exit: 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377 c9			      ret 
1378			 
1378			; moved to firmware.asm 
1378			; 
1378			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1378			;                  .dw   0 
1378			 
1378			 
1378			endif 
1378			 
1378			 
1378			if MALLOC_3 
1378			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1378			;heap_start        .equ  0x9000      ; Starting address of heap 
1378			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1378			; 
1378			 ;     .org 0 
1378			  ;    jp    main 
1378			; 
1378			; 
1378			 ;     .org  0x100 
1378			;main: 
1378			 ;     ld    HL, 0x8100 
1378			  ;    ld    SP, HL 
1378			; 
1378			;      call  heap_init 
1378			 
1378			      ; Make some allocations 
1378			;      ld    HL, 12 
1378			;      call  malloc            ; Allocates 0x9004 
1378			; 
1378			 ;     ld    HL, 12 
1378			;      call  malloc            ; Allocates 0x9014 
1378			 
1378			;      ld    HL, 12 
1378			;      call  malloc            ; Allocates 0x9024 
1378			 
1378			      ; Free some allocations 
1378			;      ld    HL, 0x9014 
1378			;      call  free 
1378			 
1378			;      ld    HL, 0x9004 
1378			;      call  free 
1378			; 
1378			;      ld    HL, 0x9024 
1378			;      call  free 
1378			 
1378			 
1378			 ;     halt 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     heap_init                                                               : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Initialise the heap and make it ready for malloc and free operations.   : 
1378			;                                                                             : 
1378			;     The heap is maintained as a linked list, starting with an initial       : 
1378			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1378			;     the first free block in the heap. Each block then points to the next    : 
1378			;     free block within the heap, and the free list ends at the first block   : 
1378			;     with a null pointer to the next free block.                             : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     Inputs are compile-time only. Two defines which specify the starting    : 
1378			;     address of the heap and its size are required, along with a memory      : 
1378			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1378			;     principally stores a pointer to the first free block in the heap.       : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;------------------------------------------------------------------------------ 
1378			heap_init: 
1378			      push  HL 
1378			 
1378			      ; Initialise free list struct 
1378			      ld    HL, heap_start 
1378			      ld    (free_list), HL 
1378			      ld    HL, 0 
1378			      ld    (free_list+2), HL 
1378			 
1378			      ; Insert first free block at bottom of heap, consumes entire heap 
1378			      ld    HL, heap_start+heap_size-4 
1378			      ld    (heap_start), HL        ; Next block (end of free list) 
1378			      ld    HL, heap_size-4 
1378			      ld    (heap_start+2), HL      ; Block size 
1378			 
1378			      ; Insert end of free list block at top of heap - two null words will 
1378			      ; terminate the free list 
1378			      ld    HL, 0 
1378			      ld    (heap_start+heap_size-2), HL 
1378			      ld    (heap_start+heap_size-4), HL 
1378			 
1378			      pop   HL 
1378			 
1378			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     malloc                                                                  : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Allocates the wanted space from the heap and returns the address of the : 
1378			;     first useable byte of the allocation.                                   : 
1378			;                                                                             : 
1378			;     Allocations can happen in one of two ways:                              : 
1378			;                                                                             : 
1378			;     1. A free block may be found which is the exact size wanted. In this    : 
1378			;        case the block is removed from the free list and retuedn to the      : 
1378			;        caller.                                                              : 
1378			;     2. A free block may be found which is larger than the size wanted. In   : 
1378			;        this case, the larger block is split into two. The first portion of  : 
1378			;        this block will become the requested space by the malloc call and    : 
1378			;        is returned to the caller. The second portion becomes a new free     : 
1378			;        block, and the free list is adjusted to maintain continuity via this : 
1378			;        newly created block.                                                 : 
1378			;                                                                             : 
1378			;     malloc does not set any initial value in the allocated space, the       : 
1378			;     caller is required to do this as required.                              : 
1378			;                                                                             : 
1378			;     This implementation of malloc uses the stack exclusively, and is        : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling malloc, and recommended  : 
1378			;     to avoid the use of malloc inside ISRs in general.                      : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Number of bytes wanted                                              : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     HL  Address of the first useable byte of the allocation                 : 
1378			;                                                                             : 
1378			; Flags                                                                       : 
1378			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +4  +-------------+                                                       : 
1378			;       |  this_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			malloc: 
1378			      push  BC 
1378			      push  DE 
1378			      push  IX 
1378			 
1378			      ld    A, H                    ; Exit if no space requested 
1378			      or    L 
1378			      jp    Z, malloc_early_exit 
1378			 
1378			      ; Set up stack frame 
1378			      ex    DE, HL 
1378			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1378			      add   HL, SP 
1378			      ld    SP, HL 
1378			      ld    IX, 0                   ; Use IX as a frame pointer 
1378			      add   IX, SP 
1378			 
1378			      ; Setup initial state 
1378			      ld    HL, 4                   ; want must also include space used by block struct 
1378			      add   HL, DE 
1378			 
1378			      ld    B, H                    ; Move want to BC 
1378			      ld    C, L 
1378			 
1378			      ld    HL, free_list           ; Store prev_free ptr to stack 
1378			      ld    (IX+4), L 
1378			      ld    (IX+5), H 
1378			 
1378			      ld    E, (HL)                 ; Store this_free ptr to stack 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      ld    (IX+2), E 
1378			      ld    (IX+3), D 
1378			      ex    DE, HL                  ; this_free ptr into HL 
1378			 
1378			      ; Loop through free block list to find some space 
1378			malloc_find_space: 
1378			      ld    E, (HL)                 ; Load next_free ptr into DE 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			 
1378			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1378			      or    E 
1378			      jp    Z, malloc_no_space 
1378			 
1378			      ld    (IX+0), E               ; Store next_free ptr to stack 
1378			      ld    (IX+1), D 
1378			 
1378			      ; Does this block have enough space to make the allocation? 
1378			      inc   HL                      ; Load free block size into DE 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			 
1378			      ex    DE, HL                  ; Check size of block against want 
1378			      or    A                       ; Ensure carry flag clear 
1378			      sbc   HL, BC 
1378			      push  HL                      ; Store the result for later (new block size) 
1378			 
1378			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1378			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1378			 
1378			      ; this_free block is not big enough, setup ptrs to test next free block 
1378			      pop   HL                      ; Discard previous result 
1378			 
1378			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1378			      ld    H, (IX+3) 
1378			      ld    (IX+4), L 
1378			      ld    (IX+5), H 
1378			 
1378			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1378			      ld    H, (IX+1) 
1378			      ld    (IX+2), L 
1378			      ld    (IX+3), H 
1378			 
1378			      jr    malloc_find_space 
1378			 
1378			      ; split a bigger block into two - requested size and remaining size 
1378			malloc_alloc_split: 
1378			      ex    DE, HL                  ; Calculate address of new free block 
1378			      dec   HL 
1378			      dec   HL 
1378			      dec   HL 
1378			      add   HL, BC 
1378			 
1378			      ; Create a new block and point it at next_free 
1378			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1378			      ld    D, (IX+1) 
1378			 
1378			      ld    (HL), E                 ; Store next_free ptr into new block 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			      pop   DE                      ; Store size of new block into new block 
1378			      inc   HL 
1378			      ld    (HL), E 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			      ; Update this_free ptr to point to new block 
1378			      dec   HL 
1378			      dec   HL 
1378			      dec   HL 
1378			 
1378			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1378			      ld    D, (IX+3) 
1378			 
1378			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1378			      ld    (IX+3), H 
1378			 
1378			      ; Modify this_free block to be allocation 
1378			      ex    DE, HL 
1378			      xor   A                       ; Null the next block ptr of allocated block 
1378			      ld    (HL), A 
1378			      inc   HL 
1378			      ld    (HL), A 
1378			 
1378			      inc   HL                      ; Store want size into allocated block 
1378			      ld    (HL), C 
1378			      inc   HL 
1378			      ld    (HL), B 
1378			      inc   HL 
1378			      push  HL                      ; Address of allocation to return 
1378			 
1378			      jr    malloc_update_links 
1378			 
1378			malloc_alloc_fit: 
1378			      pop   HL                      ; Dont need new block size, want is exact fit 
1378			 
1378			      ; Modify this_free block to be allocation 
1378			      ex    DE, HL 
1378			      dec   HL 
1378			      dec   HL 
1378			      dec   HL 
1378			 
1378			      xor   A                       ; Null the next block ptr of allocated block 
1378			      ld    (HL), A 
1378			      inc   HL 
1378			      ld    (HL), A 
1378			 
1378			      inc   HL                      ; Store address of allocation to return 
1378			      inc   HL 
1378			      inc   HL 
1378			      push  HL 
1378			 
1378			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1378			      ld    L, (IX+0)               ; next_free to HL 
1378			      ld    H, (IX+1) 
1378			 
1378			      ld    (IX+2), L               ; HL to this_free 
1378			      ld    (IX+3), H 
1378			 
1378			 
1378			malloc_update_links: 
1378			      ; Update prev_free ptr to point to this_free 
1378			      ld    L, (IX+4)               ; prev_free ptr to HL 
1378			      ld    H, (IX+5) 
1378			 
1378			      ld    E, (IX+2)               ; this_free ptr to DE 
1378			      ld    D, (IX+3) 
1378			 
1378			      ld    (HL), E                 ; this_free ptr into prev_free 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			      ; Clear the Z flag to indicate successful allocation 
1378			      ld    A, D 
1378			      or    E 
1378			 
1378			      pop   DE                      ; Address of allocation 
1378			 
1378			malloc_no_space: 
1378			      ld    HL, 6                   ; Clean up stack frame 
1378			      add   HL, SP 
1378			      ld    SP, HL 
1378			 
1378			      ex    DE, HL                  ; Alloc addr into HL for return 
1378			 
1378			malloc_early_exit: 
1378			      pop   IX 
1378			      pop   DE 
1378			      pop   BC 
1378			 
1378			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378			      push  BC 
1378			      push  DE 
1378			      push  IX 
1378			 
1378			      ld    A, H                    ; Exit if ptr is null 
1378			      or    L 
1378			      jp    Z, free_early_exit 
1378			 
1378			      ; Set up stack frame 
1378			      ex    DE, HL 
1378			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1378			      add   HL, SP 
1378			      ld    SP, HL 
1378			      ld    IX, 0                   ; Use IX as a frame pointer 
1378			      add   IX, SP 
1378			 
1378			      ; The address in HL points to the start of the useable allocated space, 
1378			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1378			      ; address of the block itself. 
1378			      ex    DE, HL 
1378			      ld    DE, -4 
1378			      add   HL, DE 
1378			 
1378			      ; An allocated block must have a null next block pointer in it 
1378			      ld    A, (HL) 
1378			      inc   HL 
1378			      or    (HL) 
1378			      jp    NZ, free_done 
1378			 
1378			      dec   HL 
1378			 
1378			      ld    B, H                    ; Copy HL to BC 
1378			      ld    C, L 
1378			 
1378			      ; Loop through the free list to find the first block with an address 
1378			      ; higher than the block being freed 
1378			      ld    HL, free_list 
1378			 
1378			free_find_higher_block: 
1378			      ld    E, (HL)                 ; Load next ptr from free block 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      dec   HL 
1378			 
1378			      ld    (IX+0), E               ; Save ptr to next free block 
1378			      ld    (IX+1), D 
1378			      ld    (IX+2), L               ; Save ptr to prev free block 
1378			      ld    (IX+3), H 
1378			 
1378			      ld    A, B                    ; Check if DE is greater than BC 
1378			      cp    D                       ; Compare MSB first 
1378			      jr    Z, $+4                  ; MSB the same, compare LSB 
1378			      jr    NC, free_find_higher_block_skip 
1378			      ld    A, C 
1378			      cp    E                       ; Then compare LSB 
1378			      jr    C, free_found_higher_block 
1378			 
1378			free_find_higher_block_skip: 
1378			      ld    A, D                    ; Reached the end of the free list? 
1378			      or    E 
1378			      jp    Z, free_done 
1378			 
1378			      ex    DE, HL 
1378			 
1378			      jr    free_find_higher_block 
1378			 
1378			free_found_higher_block: 
1378			      ; Insert freed block between prev and next free blocks 
1378			      ld    (HL), C                 ; Point prev free block to freed block 
1378			      inc   HL 
1378			      ld    (HL), B 
1378			 
1378			      ld    H, B                    ; Point freed block at next free block 
1378			      ld    L, C 
1378			      ld    (HL), E 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			      ; Check if the freed block is adjacent to the next free block 
1378			      inc   HL                      ; Load size of freed block into HL 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      ex    DE, HL 
1378			 
1378			      add   HL, BC                  ; Add addr of freed block and its size 
1378			 
1378			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1378			      ld    D, (IX+1) 
1378			 
1378			      or    A                       ; Clear the carry flag 
1378			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1378			      jr    NZ, free_check_adjacent_to_prev 
1378			 
1378			      ; Freed block is adjacent to next, merge into one bigger block 
1378			      ex    DE, HL                  ; Load next ptr from next block into DE 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      push  HL                      ; Save ptr to next block for later 
1378			 
1378			      ld    H, B                    ; Store ptr from next block into freed block 
1378			      ld    L, C 
1378			      ld    (HL), E 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			      pop   HL                      ; Restore ptr to next block 
1378			      inc   HL                      ; Load size of next block into DE 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      push  DE                      ; Save next block size for later 
1378			 
1378			      ld    H, B                    ; Load size of freed block into HL 
1378			      ld    L, C 
1378			      inc   HL 
1378			      inc   HL 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      ex    DE, HL 
1378			 
1378			      pop   DE                      ; Restore size of next block 
1378			      add   HL, DE                  ; Add sizes of both blocks 
1378			      ex    DE, HL 
1378			 
1378			      ld    H, B                    ; Store new bigger size into freed block 
1378			      ld    L, C 
1378			      inc   HL 
1378			      inc   HL 
1378			      ld    (HL), E 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			free_check_adjacent_to_prev: 
1378			      ; Check if the freed block is adjacent to the prev free block 
1378			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1378			      ld    H, (IX+3) 
1378			 
1378			      inc   HL                      ; Size of prev free block into DE 
1378			      inc   HL 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      dec   HL 
1378			      dec   HL 
1378			      dec   HL 
1378			 
1378			      add   HL, DE                  ; Add prev block addr and size 
1378			 
1378			      or    A                       ; Clear the carry flag 
1378			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1378			      jr    NZ, free_done 
1378			 
1378			      ; Freed block is adjacent to prev, merge into one bigger block 
1378			      ld    H, B                    ; Load next ptr from freed block into DE 
1378			      ld    L, C 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      push  HL                      ; Save freed block ptr for later 
1378			 
1378			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1378			      ld    H, (IX+3) 
1378			      ld    (HL), E 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			      pop   HL                      ; Restore freed block ptr 
1378			      inc   HL                      ; Load size of freed block into DE 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			      push  DE                      ; Save freed block size for later 
1378			 
1378			      ld    L, (IX+2)               ; Load size of prev block into DE 
1378			      ld    H, (IX+3) 
1378			      inc   HL 
1378			      inc   HL 
1378			      ld    E, (HL) 
1378			      inc   HL 
1378			      ld    D, (HL) 
1378			 
1378			      pop   HL                      ; Add sizes of both blocks 
1378			      add   HL, DE 
1378			      ex    DE, HL 
1378			 
1378			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1378			      ld    H, (IX+3) 
1378			      inc   HL 
1378			      inc   HL 
1378			      ld    (HL), E 
1378			      inc   HL 
1378			      ld    (HL), D 
1378			 
1378			free_done: 
1378			      ld    HL, 4                   ; Clean up stack frame 
1378			      add   HL, SP 
1378			      ld    SP, HL 
1378			 
1378			free_early_exit: 
1378			      pop   IX 
1378			      pop   DE 
1378			      pop   BC 
1378			 
1378			      ret 
1378			 
1378			 
1378			;      .org 0x8000 
1378			; 
1378			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1378			 ;                 .dw   0 
1378			 
1378			endif 
1378			 
1378			 
1378			if MALLOC_4 
1378			 
1378			; My memory allocation code. Very very simple.... 
1378			; allocate space under 250 chars 
1378			 
1378			heap_init: 
1378				; init start of heap as zero 
1378				;  
1378			 
1378				ld hl, heap_start 
1378				ld a, 0 
1378				ld (hl), a      ; empty block 
1378				inc hl 
1378				ld a, 0 
1378				ld (hl), a      ; length of block 
1378				; write end of list 
1378				inc hl 
1378				ld a,(hl) 
1378				inc hl 
1378				ld a,(hl) 
1378				 
1378			 
1378				; init some malloc vars 
1378			 
1378				ld hl, 0 
1378				ld (free_list), hl       ; store last malloc location 
1378			 
1378				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1378				ld a, 0 
1378				ld (hl), a 
1378			 
1378			 
1378				ld hl, heap_start 
1378				;  
1378				  
1378				ret 
1378			 
1378			 
1378			;    free block marker 
1378			;    requested size  
1378			;    pointer to next block 
1378			;    .... 
1378			;    next block marker 
1378			 
1378			 
1378			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1378			; 
1378			 
1378			 
1378			malloc:  
1378				push de 
1378				push bc 
1378				push af 
1378			 
1378				; hl space required 
1378				 
1378				ld c, l    ; hold space   (TODO only a max of 255) 
1378			 
1378			;	inc c     ; TODO BUG need to fix memory leak on push str 
1378			;	inc c 
1378			;	inc c 
1378			;	inc c 
1378			;	inc c 
1378			;	inc c 
1378			;	inc c 
1378			 
1378			 
1378			 
1378				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1378			 
1378				ld a, (free_list+3) 
1378				cp 0 
1378				jr z, .contheap 
1378			 
1378				ld hl, (free_list)     ; get last alloc 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "mrs" 
1378						CALLMONITOR 
1378					endif 
1378				jr .startalloc 
1378			 
1378			.contheap: 
1378				ld hl, heap_start 
1378			 
1378			.startalloc: 
1378			 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "mym" 
1378						CALLMONITOR 
1378					endif 
1378			.findblock: 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "mmf" 
1378						CALLMONITOR 
1378					endif 
1378			 
1378				ld a,(hl)  
1378				; if byte is zero then clear to use 
1378			 
1378				cp 0 
1378				jr z, .foundemptyblock 
1378			 
1378				; if byte is not clear 
1378				;     then byte is offset to next block 
1378			 
1378				inc hl 
1378				ld a, (hl) ; get size 
1378			.nextblock:	inc hl 
1378					ld e, (hl) 
1378					inc hl 
1378					ld d, (hl) 
1378					ex de, hl 
1378			;	inc hl  ; move past the store space 
1378			;	inc hl  ; move past zero index  
1378			 
1378				; TODO detect no more space 
1378			 
1378				push hl 
1378				ld de, heap_end 
1378				call cmp16 
1378				pop hl 
1378				jr nc, .nospace 
1378			 
1378				jr .findblock 
1378			 
1378			.nospace: ld hl, 0 
1378				jp .exit 
1378			 
1378			 
1378			.foundemptyblock:	 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "mme" 
1378						CALLMONITOR 
1378					endif 
1378			 
1378			; TODO has block enough space if reusing??? 
1378			 
1378				;  
1378			 
1378			; see if this block has been previously used 
1378				inc hl 
1378				ld a, (hl) 
1378				dec hl 
1378				cp 0 
1378				jr z, .newblock 
1378			 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "meR" 
1378						CALLMONITOR 
1378					endif 
1378			 
1378			; no reusing previously allocated block 
1378			 
1378			; is it smaller than previously used? 
1378				 
1378				inc hl    ; move to size 
1378				ld a, c 
1378				sub (hl)        ; we want c < (hl) 
1378				dec hl    ; move back to marker 
1378			        jr z, .findblock 
1378			 
1378				; update with the new size which should be lower 
1378			 
1378			        ;inc  hl   ; negate next move. move back to size  
1378			 
1378			.newblock: 
1378				; need to be at marker here 
1378			 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "meN" 
1378						CALLMONITOR 
1378					endif 
1378			 
1378			 
1378				ld a, c 
1378			 
1378				ld (free_list+3), a	 ; flag resume from last malloc  
1378				ld (free_list), hl    ; save out last location 
1378			 
1378			 
1378				;inc a     ; space for length byte 
1378				ld (hl), a     ; save block in use marker 
1378			 
1378				inc hl   ; move to space marker 
1378				ld (hl), a    ; save new space 
1378			 
1378				inc hl   ; move to start of allocated area 
1378				 
1378			;	push hl     ; save where we are - 1  
1378			 
1378			;	inc hl  ; move past zero index  
1378				; skip space to set down new marker 
1378			 
1378				; provide some extra space for now 
1378			 
1378				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1378				inc a 
1378				inc a 
1378			 
1378				push hl   ; save where we are in the node block 
1378			 
1378				call addatohl 
1378			 
1378				; write linked list point 
1378			 
1378				pop de     ; get our node position 
1378				ex de, hl 
1378			 
1378				ld (hl), e 
1378				inc hl 
1378				ld (hl), d 
1378			 
1378				inc hl 
1378			 
1378				; now at start of allocated data so save pointer 
1378			 
1378				push hl 
1378			 
1378				; jump to position of next node and setup empty header in DE 
1378			 
1378				ex de, hl 
1378			 
1378			;	inc hl ; move past end of block 
1378			 
1378				ld a, 0 
1378				ld (hl), a   ; empty marker 
1378				inc hl 
1378				ld (hl), a   ; size 
1378				inc hl  
1378				ld (hl), a   ; ptr 
1378				inc hl 
1378				ld (hl), a   ; ptr 
1378			 
1378			 
1378				pop hl 
1378			 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "mmr" 
1378						CALLMONITOR 
1378					endif 
1378			 
1378			.exit: 
1378				pop af 
1378				pop bc 
1378				pop de  
1378				ret 
1378			 
1378			 
1378			 
1378			 
1378			free:  
1378				push hl 
1378				push af 
1378				; get address in hl 
1378			 
1378					if DEBUG_FORTH_MALLOC_INT 
1378						DMARK "fre" 
1378						CALLMONITOR 
1378					endif 
1378				; data is at hl - move to block count 
1378				dec hl 
1378				dec hl    ; get past pointer 
1378				dec hl 
1378			 
1378				ld a, (hl)    ; need this for a validation check 
1378			 
1378				dec hl    ; move to block marker 
1378			 
1378				; now check that the block count and block marker are the same  
1378			        ; this checks that we are on a malloc node and not random memory 
1378			        ; OK a faint chance this could be a problem but rare - famous last words! 
1378			 
1378				ld c, a 
1378				ld a, (hl)    
1378			 
1378				cp c 
1378				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1378			 
1378				; yes good chance we are on a malloc node 
1378			 
1378				ld a, 0      
1378				ld (hl), a   ; mark as free 
1378			 
1378				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1378			 
1378			.freeignore:  
1378			 
1378				pop af 
1378				pop hl 
1378			 
1378				ret 
1378			 
1378			 
1378			 
1378			endif 
1378			 
1378			; eof 
# End of file firmware_memory.asm
1378			  
1378			; device C  
1378			if SOUND_ENABLE  
1378				include "firmware_sound.asm"  
1378			endif  
1378			  
1378			include "firmware_diags.asm"  
1378			; Hardware diags menu 
1378			 
1378			 
1378			config: 
1378			 
1378 3e 00			ld a, 0 
137a 21 a8 13			ld hl, .configmn 
137d cd 15 0b			call menu 
1380			 
1380 fe 00			cp 0 
1382 c8				ret z 
1383			 
1383 fe 01			cp 1 
1385 cc 12 15			call z, .savetostore 
1388			 
1388 fe 02			cp 2 
138a cc 60 14			call z, .selautoload 
138d fe 03			cp 3 
138f cc 49 14			call z, .disautoload 
1392 fe 04			cp 4 
1394 cc 10 15			call z, .selbank 
1397 fe 05			cp 5 
1399 cc 04 16			call z, .debug_tog 
139c fe 06			cp 6 
139e cc 47 17			call z, .bpsgo 
13a1 fe 07			cp 7 
13a3 cc 2a 16			call z, hardware_diags 
13a6			 
13a6 18 d0			jr config 
13a8			 
13a8			.configmn: 
13a8 b8 13			dw .c3 
13aa cf 13			dw .c2 
13ac e4 13			dw .c2a 
13ae fa 13			dw .c2b 
13b0			;	dw .c4 
13b0 17 14			dw .m4 
13b2 32 14			dw .m4b 
13b4 3a 14			dw .c1 
13b6 00 00			dw 0 
13b8				 
13b8			 
13b8 .. 00		.c3: db "Add Dictionary To File",0 
13cf .. 00		.c2: db "Select Autoload File",0 
13e4 .. 00		.c2a: db "Disable Autoload File", 0 
13fa .. 00		.c2b: db "Select Storage Bank",0 
140e .. 00		.c4: db "Settings",0 
1417 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1432 .. 00		.m4b:   db "Monitor",0 
143a .. 00		.c1: db "Hardware Diags",0 
1449			 
1449			 
1449			.disautoload: 
1449				if STORAGE_SE 
1449 3e fe			ld a, $fe      ; bit 0 clear 
144b 32 c5 f9			ld (spi_device), a 
144e			 
144e cd b5 03			call storage_get_block_0 
1451			 
1451 3e 00			ld a, 0 
1453 32 00 fa			ld (store_page+STORE_0_AUTOFILE), a 
1456			 
1456 21 00 00				ld hl, 0 
1459 11 df f9				ld de, store_page 
145c cd 69 03			call storage_write_block	 ; save update 
145f				else 
145f			 
145f				ld hl, .notav 
145f				ld de, .empty 
145f				call info_panel 
145f				endif 
145f			 
145f			 
145f c9				ret 
1460			 
1460			 
1460			 
1460			; Select auto start 
1460			 
1460			.selautoload: 
1460			 
1460				 
1460				if STORAGE_SE 
1460			 
1460 cd 4e 15				call config_dir 
1463 21 9a ef			        ld hl, scratch 
1466 3e 00				ld a, 0 
1468 cd 15 0b				call menu 
146b			 
146b fe 00				cp 0 
146d c8					ret z 
146e			 
146e 3d					dec a 
146f			 
146f			 
146f					; locate menu option 
146f			 
146f 21 9a ef				ld hl, scratch 
1472 cd 39 0a				call table_lookup 
1475			 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "ALl" 
1475 f5				push af  
1476 3a 8a 14			ld a, (.dmark)  
1479 32 b4 fb			ld (debug_mark),a  
147c 3a 8b 14			ld a, (.dmark+1)  
147f 32 b5 fb			ld (debug_mark+1),a  
1482 3a 8c 14			ld a, (.dmark+2)  
1485 32 b6 fb			ld (debug_mark+2),a  
1488 18 03			jr .pastdmark  
148a ..			.dmark: db "ALl"  
148d f1			.pastdmark: pop af  
148e			endm  
# End of macro DMARK
148e						CALLMONITOR 
148e cd 3d 17			call break_point_state  
1491				endm  
# End of macro CALLMONITOR
1491					endif 
1491					; with the pointer to the menu it, the byte following the zero term is the file id 
1491			 
1491 3e 00				ld a, 0 
1493 01 32 00				ld bc, 50   ; max of bytes to look at 
1496 ed b1				cpir  
1498			 
1498					if DEBUG_FORTH_WORDS 
1498						DMARK "ALb" 
1498 f5				push af  
1499 3a ad 14			ld a, (.dmark)  
149c 32 b4 fb			ld (debug_mark),a  
149f 3a ae 14			ld a, (.dmark+1)  
14a2 32 b5 fb			ld (debug_mark+1),a  
14a5 3a af 14			ld a, (.dmark+2)  
14a8 32 b6 fb			ld (debug_mark+2),a  
14ab 18 03			jr .pastdmark  
14ad ..			.dmark: db "ALb"  
14b0 f1			.pastdmark: pop af  
14b1			endm  
# End of macro DMARK
14b1						CALLMONITOR 
14b1 cd 3d 17			call break_point_state  
14b4				endm  
# End of macro CALLMONITOR
14b4					endif 
14b4					;inc hl 
14b4			 
14b4 7e					ld a, (hl)   ; file id 
14b5					 
14b5				        ; save bank and file ids 
14b5			 
14b5 f5					push af 
14b6			 
14b6			; TODO need to save to block 0 on bank 1	 
14b6			 
14b6 cd b5 03				call storage_get_block_0 
14b9			 
14b9					if DEBUG_FORTH_WORDS 
14b9						DMARK "AL0" 
14b9 f5				push af  
14ba 3a ce 14			ld a, (.dmark)  
14bd 32 b4 fb			ld (debug_mark),a  
14c0 3a cf 14			ld a, (.dmark+1)  
14c3 32 b5 fb			ld (debug_mark+1),a  
14c6 3a d0 14			ld a, (.dmark+2)  
14c9 32 b6 fb			ld (debug_mark+2),a  
14cc 18 03			jr .pastdmark  
14ce ..			.dmark: db "AL0"  
14d1 f1			.pastdmark: pop af  
14d2			endm  
# End of macro DMARK
14d2						CALLMONITOR 
14d2 cd 3d 17			call break_point_state  
14d5				endm  
# End of macro CALLMONITOR
14d5					endif 
14d5 f1					pop af 
14d6			 
14d6 32 03 fa				ld (store_page+STORE_0_FILERUN),a 
14d9					 
14d9					; save bank id 
14d9			 
14d9 3a c5 f9				ld a,(spi_device) 
14dc 32 02 fa				ld (store_page+STORE_0_BANKRUN),a 
14df			 
14df					; enable auto run of store file 
14df			 
14df 3e 01				ld a, 1 
14e1 32 00 fa				ld (store_page+STORE_0_AUTOFILE),a 
14e4			 
14e4					; save buffer 
14e4			 
14e4 21 00 00				ld hl, 0 
14e7 11 df f9				ld de, store_page 
14ea					if DEBUG_FORTH_WORDS 
14ea						DMARK "ALw" 
14ea f5				push af  
14eb 3a ff 14			ld a, (.dmark)  
14ee 32 b4 fb			ld (debug_mark),a  
14f1 3a 00 15			ld a, (.dmark+1)  
14f4 32 b5 fb			ld (debug_mark+1),a  
14f7 3a 01 15			ld a, (.dmark+2)  
14fa 32 b6 fb			ld (debug_mark+2),a  
14fd 18 03			jr .pastdmark  
14ff ..			.dmark: db "ALw"  
1502 f1			.pastdmark: pop af  
1503			endm  
# End of macro DMARK
1503						CALLMONITOR 
1503 cd 3d 17			call break_point_state  
1506				endm  
# End of macro CALLMONITOR
1506					endif 
1506 cd 69 03			call storage_write_block	 ; save update 
1509			  
1509			 
1509			 
1509			 
1509 21 9a ef				ld hl, scratch 
150c cd 3b 15				call config_fdir 
150f			 
150f				else 
150f			 
150f				ld hl, .notav 
150f				ld de, .empty 
150f				call info_panel 
150f			 
150f				endif 
150f c9				ret 
1510			 
1510			 
1510			 
1510			; Select storage bank 
1510			 
1510			.selbank: 
1510			 
1510				if STORAGE_SE 
1510				else 
1510			 
1510				ld hl, .notav 
1510				ld de, .empty 
1510				call info_panel 
1510				endif 
1510				 
1510 c9				ret 
1511			 
1511			if STORAGE_SE 
1511			 
1511			.config_ldir:   
1511				; Load storage bank labels into menu array 
1511			 
1511				 
1511			 
1511			 
1511 c9				ret 
1512			 
1512			 
1512			endif 
1512			 
1512			 
1512			; Save user words to storage 
1512			 
1512			.savetostore: 
1512			 
1512				if STORAGE_SE 
1512			 
1512 cd 4e 15				call config_dir 
1515 21 9a ef			        ld hl, scratch 
1518 3e 00				ld a, 0 
151a cd 15 0b				call menu 
151d					 
151d 21 9a ef				ld hl, scratch 
1520 cd 3b 15				call config_fdir 
1523			 
1523				else 
1523			 
1523				ld hl, .notav 
1523				ld de, .empty 
1523				call info_panel 
1523			 
1523				endif 
1523			 
1523 c9				ret 
1524 .. 00		.notav:    db "Feature not available",0 
153a .. 00		.empty:    db "",0 
153b			 
153b			 
153b			 
153b			if STORAGE_SE 
153b			 
153b			config_fdir: 
153b				; using the scratch dir go through and release the memory allocated for each string 
153b				 
153b 21 9a ef			ld hl, scratch 
153e 5e			.cfdir:	ld e,(hl) 
153f 23				inc hl 
1540 56				ld d,(hl) 
1541 23				inc hl 
1542			 
1542 eb				ex de, hl 
1543 cd 41 0d			call ishlzero 
1546 c8				ret z     ; return on null pointer 
1547 cd a9 12			call free 
154a eb				ex de, hl 
154b 18 f1			jr .cfdir 
154d			 
154d			 
154d c9				ret 
154e			 
154e			 
154e			config_dir: 
154e			 
154e				; for the config menus that need to build a directory of storage call this routine 
154e				; it will construct a menu in scratch to pass to menu 
154e			 
154e				; open storage device 
154e			 
154e				; execute DIR to build a list of files and their ids into scratch in menu format 
154e				; once the menu has finished then will need to call config_fdir to release the strings 
154e				 
154e				; c = number items 
154e			 
154e				 
154e cd b5 03			call storage_get_block_0 
1551			 
1551 21 df f9			ld hl, store_page     ; get current id count 
1554 46				ld b, (hl) 
1555 0e 00			ld c, 0    ; count of files   
1557			 
1557			 
1557 21 9a ef			ld hl, scratch 
155a 22 db f9			ld (store_tmp2), hl    ; location to poke strings 
155d			 
155d				; check for empty drive 
155d			 
155d 3e 00			ld a, 0 
155f b8				cp b 
1560 ca fa 15			jp z, .dirdone 
1563			 
1563				 
1563					if DEBUG_FORTH_WORDS 
1563						DMARK "Cdc" 
1563 f5				push af  
1564 3a 78 15			ld a, (.dmark)  
1567 32 b4 fb			ld (debug_mark),a  
156a 3a 79 15			ld a, (.dmark+1)  
156d 32 b5 fb			ld (debug_mark+1),a  
1570 3a 7a 15			ld a, (.dmark+2)  
1573 32 b6 fb			ld (debug_mark+2),a  
1576 18 03			jr .pastdmark  
1578 ..			.dmark: db "Cdc"  
157b f1			.pastdmark: pop af  
157c			endm  
# End of macro DMARK
157c						CALLMONITOR 
157c cd 3d 17			call break_point_state  
157f				endm  
# End of macro CALLMONITOR
157f					endif 
157f			 
157f			 
157f			.diritem:	 
157f c5				push bc 
1580				; for each of the current ids do a search for them and if found push to stack 
1580			 
1580 21 40 00				ld hl, STORE_BLOCK_PHY 
1583 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1585 58					ld e,b 
1586			 
1586 cd 29 06				call storage_findnextid 
1589			 
1589			 
1589					; if found hl will be non zero 
1589			 
1589 cd 41 0d				call ishlzero 
158c 28 69				jr z, .dirnotfound 
158e			 
158e					; increase count 
158e			 
158e c1					pop bc	 
158f 0c					inc c 
1590 c5					push bc 
1591					 
1591			 
1591					; get file header and push the file name 
1591			 
1591 11 df f9				ld de, store_page 
1594 cd 04 03				call storage_read_block 
1597			 
1597					; push file id to stack 
1597				 
1597 3a df f9				ld a, (store_page) 
159a 26 00				ld h, 0 
159c 6f					ld l, a 
159d			 
159d					;call forth_push_numhl 
159d					; TODO store id 
159d			 
159d e5					push hl 
159e			 
159e					; push extent count to stack  
159e				 
159e 21 e2 f9				ld hl, store_page+3 
15a1			 
15a1					; get file name length 
15a1			 
15a1 cd 76 11				call strlenz   
15a4			 
15a4 23					inc hl   ; cover zero term 
15a5 23					inc hl  ; stick the id at the end of the area 
15a6			 
15a6 e5					push hl 
15a7 c1					pop bc    ; move length to bc 
15a8			 
15a8 cd df 11				call malloc 
15ab			 
15ab					; TODO save malloc area to scratch 
15ab			 
15ab eb					ex de, hl 
15ac 2a db f9				ld hl, (store_tmp2) 
15af 73					ld (hl), e 
15b0 23					inc hl 
15b1 72					ld (hl), d 
15b2 23					inc hl 
15b3 22 db f9				ld (store_tmp2), hl 
15b6			 
15b6					 
15b6			 
15b6					;pop hl   ; get source 
15b6			;		ex de, hl    ; swap aronund	 
15b6			 
15b6 21 e2 f9				ld hl, store_page+3 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "CFd" 
15b9 f5				push af  
15ba 3a ce 15			ld a, (.dmark)  
15bd 32 b4 fb			ld (debug_mark),a  
15c0 3a cf 15			ld a, (.dmark+1)  
15c3 32 b5 fb			ld (debug_mark+1),a  
15c6 3a d0 15			ld a, (.dmark+2)  
15c9 32 b6 fb			ld (debug_mark+2),a  
15cc 18 03			jr .pastdmark  
15ce ..			.dmark: db "CFd"  
15d1 f1			.pastdmark: pop af  
15d2			endm  
# End of macro DMARK
15d2						CALLMONITOR 
15d2 cd 3d 17			call break_point_state  
15d5				endm  
# End of macro CALLMONITOR
15d5					endif 
15d5 ed b0				ldir 
15d7			 
15d7					; de is past string, move back one and store id 
15d7					 
15d7 1b					dec de 
15d8			 
15d8					; store file id 
15d8			 
15d8 e1					pop hl 
15d9 eb					ex de,hl 
15da 73					ld (hl), e 
15db			 
15db					if DEBUG_FORTH_WORDS 
15db						DMARK "Cdi" 
15db f5				push af  
15dc 3a f0 15			ld a, (.dmark)  
15df 32 b4 fb			ld (debug_mark),a  
15e2 3a f1 15			ld a, (.dmark+1)  
15e5 32 b5 fb			ld (debug_mark+1),a  
15e8 3a f2 15			ld a, (.dmark+2)  
15eb 32 b6 fb			ld (debug_mark+2),a  
15ee 18 03			jr .pastdmark  
15f0 ..			.dmark: db "Cdi"  
15f3 f1			.pastdmark: pop af  
15f4			endm  
# End of macro DMARK
15f4						CALLMONITOR 
15f4 cd 3d 17			call break_point_state  
15f7				endm  
# End of macro CALLMONITOR
15f7					endif 
15f7					 
15f7			.dirnotfound: 
15f7 c1					pop bc     
15f8 10 85				djnz .diritem 
15fa				 
15fa			.dirdone:	 
15fa			 
15fa 3e 00				ld a, 0 
15fc 2a db f9				ld hl, (store_tmp2) 
15ff 77					ld (hl), a 
1600 23					inc hl 
1601 77					ld (hl), a 
1602 23					inc hl 
1603					; push a count of the dir items found 
1603			 
1603			;		ld h, 0 
1603			;		ld l, c 
1603			 
1603 c9				ret 
1604			 
1604			endif 
1604			 
1604			 
1604			; Settings 
1604			; Run  
1604			 
1604			 
1604			 
1604			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1604			;;hd_menu2:   db "        2: Editor",0   
1604			;hd_menu2:   db "        2: Editor       6: Menu",0   
1604			;hd_menu3:   db "        3: Storage",0 
1604			;hd_menu4:   db "0=quit  4: Debug",0 
1604			;hd_don:     db "ON",0 
1604			;hd_doff:     db "OFF",0 
1604			; 
1604			; 
1604			; 
1604			;hardware_diags_old:       
1604			; 
1604			;.diagmenu: 
1604			;	call clear_display 
1604			;	ld a, display_row_1 
1604			;	ld de, hd_menu1 
1604			;	call str_at_display 
1604			; 
1604			;	ld a, display_row_2 
1604			;	ld de, hd_menu2 
1604			;	call str_at_display 
1604			; 
1604			;	ld a, display_row_3 
1604			;	ld de, hd_menu3 
1604			;	call str_at_display 
1604			; 
1604			;	ld a,  display_row_4 
1604			;	ld de, hd_menu4 
1604			;	call str_at_display 
1604			; 
1604			;	; display debug state 
1604			; 
1604			;	ld de, hd_don 
1604			;	ld a, (os_view_disable) 
1604			;	cp 0 
1604			;	jr z, .distog 
1604			;	ld de, hd_doff 
1604			;.distog: ld a, display_row_4+17 
1604			;	call str_at_display 
1604			; 
1604			;	call update_display 
1604			; 
1604			;	call cin_wait 
1604			; 
1604			; 
1604			; 
1604			;	cp '4' 
1604			;	jr nz, .diagn1 
1604			; 
1604			;	; debug toggle 
1604			; 
1604			;	ld a, (os_view_disable) 
1604			;	ld b, '*' 
1604			;	cp 0 
1604			;	jr z, .debtog 
1604			;	ld b, 0 
1604			;.debtog:	 
1604			;	ld a,b 
1604			;	ld (os_view_disable),a 
1604			; 
1604			;.diagn1: cp '0' 
1604			;	 ret z 
1604			; 
1604			;;	cp '1' 
1604			;;       jp z, matrix	 
1604			;;   TODO keyboard matrix test 
1604			; 
1604			;	cp '2' 
1604			;	jp z, .diagedit 
1604			; 
1604			;;	cp '6' 
1604			;;	jp z, .menutest 
1604			;;if ENABLE_BASIC 
1604			;;	cp '6' 
1604			;;	jp z, basic 
1604			;;endif 
1604			 ; 
1604			;	jp .diagmenu 
1604			; 
1604			; 
1604			;	ret 
1604			 
1604			 
1604			.debug_tog: 
1604 21 4b 16			ld hl, .menudebug 
1607				 
1607 3a 8b ef			ld a, (os_view_disable) 
160a fe 2a			cp '*' 
160c 20 04			jr nz,.tdon  
160e 3e 01			ld a, 1 
1610 18 02			jr .tog1 
1612 3e 00		.tdon: ld a, 0 
1614			 
1614			.tog1: 
1614 cd 15 0b			call menu 
1617 fe 00			cp 0 
1619 c8				ret z 
161a fe 01			cp 1    ; disable debug 
161c 28 04			jr z, .dtog0 
161e 3e 2a			ld a, '*' 
1620 18 02			jr .dtogset 
1622 3e 00		.dtog0: ld a, 0 
1624 32 8b ef		.dtogset:  ld (os_view_disable), a 
1627 c3 04 16			jp .debug_tog 
162a			 
162a			 
162a			hardware_diags:       
162a			 
162a			.diagm: 
162a 21 3d 16			ld hl, .menuitems 
162d 3e 00			ld a, 0 
162f cd 15 0b			call menu 
1632			 
1632 fe 00		         cp 0 
1634 c8				 ret z 
1635			 
1635 fe 02			cp 2 
1637 ca 96 16			jp z, .diagedit 
163a			 
163a			;	cp '6' 
163a			;	jp z, .menutest 
163a			;if ENABLE_BASIC 
163a			;	cp '6' 
163a			;	jp z, basic 
163a			;endif 
163a			  
163a c3 2a 16			jp .diagm 
163d			 
163d				 
163d 51 16		.menuitems:   	dw .m1 
163f 5c 16				dw .m2 
1641 63 16				dw .m3 
1643 6b 16				dw .m5 
1645 71 16				dw .m5a 
1647 7a 16				dw .m5b 
1649 00 00				dw 0 
164b			 
164b			.menudebug: 
164b 83 16				dw .m6 
164d 8c 16				dw .m7 
164f 00 00				dw 0 
1651			 
1651 .. 00		.m1:   db "Key Matrix",0 
165c .. 00		.m2:   db "Editor",0 
1663 .. 00		.m3:   db "Storage",0 
166b .. 00		.m5:   db "Sound",0 
1671 .. 00		.m5a:  db "RAM Test",0 
167a .. 00		.m5b:  db "LCD Test",0 
1683			 
1683 .. 00		.m6:   db "Debug ON",0 
168c .. 00		.m7:   db "Debug OFF",0 
1696			 
1696			; debug editor 
1696			 
1696			.diagedit: 
1696			 
1696 21 9a ef			ld hl, scratch 
1699			;	ld bc, 250 
1699			;	ldir 
1699				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1699 3e 00			ld a, 0 
169b 77				ld (hl), a 
169c 23				inc hl 
169d 77				ld (hl), a 
169e 23				inc hl 
169f 77				ld (hl), a 
16a0			 
16a0 cd e4 0a		        call clear_display 
16a3 cd 07 0b			call update_display 
16a6				;ld a, 1 
16a6				;ld (hardware_diag), a 
16a6			.diloop: 
16a6 3e 00			ld a, display_row_1 
16a8 0e 00			ld c, 0 
16aa 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16ac 1e 28			ld e, 40 
16ae			 
16ae 21 9a ef			ld hl, scratch	 
16b1 cd 45 0d			call input_str 
16b4			 
16b4 3e 14			ld a, display_row_2 
16b6 11 9a ef			ld de, scratch 
16b9 cd f7 0a			call str_at_display 
16bc cd 07 0b			call update_display 
16bf			 
16bf c3 a6 16			jp .diloop 
16c2			 
16c2			 
16c2			; pass word in hl 
16c2			; a has display location 
16c2			display_word_at: 
16c2 f5				push af 
16c3 e5				push hl 
16c4 7c				ld a,h 
16c5 21 9f f2			ld hl, os_word_scratch 
16c8 cd 19 10			call hexout 
16cb e1				pop hl 
16cc 7d				ld a,l 
16cd 21 a1 f2			ld hl, os_word_scratch+2 
16d0 cd 19 10			call hexout 
16d3 21 a3 f2			ld hl, os_word_scratch+4 
16d6 3e 00			ld a,0 
16d8 77				ld (hl),a 
16d9 11 9f f2			ld de,os_word_scratch 
16dc f1				pop af 
16dd cd f7 0a				call str_at_display 
16e0 c9				ret 
16e1			 
16e1			display_ptr_state: 
16e1			 
16e1				; to restore afterwards 
16e1			 
16e1 d5				push de 
16e2 c5				push bc 
16e3 e5				push hl 
16e4 f5				push af 
16e5			 
16e5				; for use in here 
16e5			 
16e5			;	push bc 
16e5			;	push de 
16e5			;	push hl 
16e5			;	push af 
16e5			 
16e5 cd e4 0a			call clear_display 
16e8			 
16e8 11 bb 18			ld de, .ptrstate 
16eb 3e 00			ld a, display_row_1 
16ed cd f7 0a			call str_at_display 
16f0			 
16f0				; display debug step 
16f0			 
16f0			 
16f0 11 b4 fb			ld de, debug_mark 
16f3 3e 12			ld a, display_row_1+display_cols-2 
16f5 cd f7 0a			call str_at_display 
16f8			 
16f8				; display a 
16f8 11 c5 18			ld de, .ptrcliptr 
16fb 3e 14			ld a, display_row_2 
16fd cd f7 0a			call str_at_display 
1700			 
1700 f1				pop af 
1701 2a a5 f9			ld hl,(cli_ptr) 
1704 3e 1c			ld a, display_row_2+8 
1706 cd c2 16			call display_word_at 
1709			 
1709			 
1709				; display hl 
1709			 
1709			 
1709 11 cd 18			ld de, .ptrclioptr 
170c 3e 1e			ld a, display_row_2+10 
170e cd f7 0a			call str_at_display 
1711			; 
1711			;	pop hl 
1711 3e 21			ld a, display_row_2+13 
1713 2a a3 f9			ld hl,(cli_origptr) 
1716 cd c2 16			call display_word_at 
1719			; 
1719			;	 
1719			;	; display de 
1719			 
1719			;	ld de, .regstatede 
1719			;	ld a, display_row_3 
1719			;	call str_at_display 
1719			 
1719			;	pop de 
1719			;	ld h,d 
1719			;	ld l, e 
1719			;	ld a, display_row_3+3 
1719			;	call display_word_at 
1719			 
1719			 
1719				; display bc 
1719			 
1719			;	ld de, .regstatebc 
1719			;	ld a, display_row_3+10 
1719			;	call str_at_display 
1719			 
1719			;	pop bc 
1719			;	ld h,b 
1719			;	ld l, c 
1719			;	ld a, display_row_3+13 
1719			;	call display_word_at 
1719			 
1719			 
1719				; display dsp 
1719			 
1719			;	ld de, .regstatedsp 
1719			;	ld a, display_row_4 
1719			;	call str_at_display 
1719			 
1719				 
1719			;	ld hl,(cli_data_sp) 
1719			;	ld a, display_row_4+4 
1719			;	call display_word_at 
1719			 
1719				; display rsp 
1719			 
1719 11 fc 18			ld de, .regstatersp 
171c 3e 46			ld a, display_row_4+10 
171e cd f7 0a			call str_at_display 
1721			 
1721				 
1721 2a 8b f9			ld hl,(cli_ret_sp) 
1724 3e 4a			ld a, display_row_4+14 
1726 cd c2 16			call display_word_at 
1729			 
1729 cd 07 0b			call update_display 
172c			 
172c cd 61 0a			call delay1s 
172f cd 61 0a			call delay1s 
1732 cd 61 0a			call delay1s 
1735			 
1735			 
1735 cd 45 1c			call next_page_prompt 
1738			 
1738				; restore  
1738			 
1738 f1				pop af 
1739 e1				pop hl 
173a c1				pop bc 
173b d1				pop de 
173c c9				ret 
173d			 
173d			break_point_state: 
173d f5				push af 
173e			 
173e				; see if disabled 
173e			 
173e 3a 8b ef			ld a, (os_view_disable) 
1741 fe 2a			cp '*' 
1743 20 02			jr nz, .bpsgo 
1745 f1				pop af 
1746 c9				ret 
1747			 
1747			.bpsgo: 
1747 f1				pop af 
1748 f5				push af 
1749 22 87 ef			ld (os_view_hl), hl 
174c ed 53 85 ef		ld (os_view_de), de 
1750 ed 43 83 ef		ld (os_view_bc), bc 
1754 e5				push hl 
1755 6f				ld l, a 
1756 26 00			ld h, 0 
1758 22 89 ef			ld (os_view_af),hl 
175b			 
175b 21 4a fb				ld hl, display_fb0 
175e 22 55 fa				ld (display_fb_active), hl 
1761 e1				pop hl	 
1762			 
1762 3e 31			ld a, '1' 
1764 fe 2a		.bps1:  cp '*' 
1766 20 03			jr nz, .bps1b 
1768 32 8b ef			ld (os_view_disable),a 
176b fe 31		.bps1b:  cp '1' 
176d 20 14			jr nz, .bps2 
176f			 
176f				; display reg 
176f			 
176f				 
176f			 
176f 3a 89 ef			ld a, (os_view_af) 
1772 2a 87 ef			ld hl, (os_view_hl) 
1775 ed 5b 85 ef		ld de, (os_view_de) 
1779 ed 4b 83 ef		ld bc, (os_view_bc) 
177d cd 17 18			call display_reg_state 
1780 c3 03 18			jp .bpschk 
1783			 
1783 fe 32		.bps2:  cp '2' 
1785 20 08			jr nz, .bps3 
1787				 
1787				; display hl 
1787 2a 87 ef			ld hl, (os_view_hl) 
178a cd 01 19			call display_dump_at_hl 
178d			 
178d 18 74			jr .bpschk 
178f			 
178f fe 33		.bps3:  cp '3' 
1791 20 08			jr nz, .bps4 
1793			 
1793			        ; display de 
1793 2a 85 ef			ld hl, (os_view_de) 
1796 cd 01 19			call display_dump_at_hl 
1799			 
1799 18 68			jr .bpschk 
179b fe 34		.bps4:  cp '4' 
179d 20 08			jr nz, .bps5 
179f			 
179f			        ; display bc 
179f 2a 83 ef			ld hl, (os_view_bc) 
17a2 cd 01 19			call display_dump_at_hl 
17a5			 
17a5 18 5c			jr .bpschk 
17a7 fe 35		.bps5:  cp '5' 
17a9 20 08		        jr nz, .bps7 
17ab			 
17ab				; display cur ptr 
17ab 2a a5 f9			ld hl, (cli_ptr) 
17ae cd 01 19			call display_dump_at_hl 
17b1			 
17b1 18 50			jr .bpschk 
17b3 fe 36		.bps7:  cp '6' 
17b5 20 08			jr nz, .bps8b 
17b7				 
17b7				; display cur orig ptr 
17b7 2a a3 f9			ld hl, (cli_origptr) 
17ba cd 01 19			call display_dump_at_hl 
17bd 18 44			jr .bpschk 
17bf fe 37		.bps8b:  cp '7' 
17c1 20 08			jr nz, .bps9 
17c3				 
17c3				; display dsp 
17c3 2a 87 f9			ld hl, (cli_data_sp) 
17c6 cd 01 19			call display_dump_at_hl 
17c9			 
17c9 18 38			jr .bpschk 
17cb fe 39		.bps9:  cp '9' 
17cd 20 05			jr nz, .bps8c 
17cf				 
17cf				; display SP 
17cf			;	ld hl, sp 
17cf cd 01 19			call display_dump_at_hl 
17d2			 
17d2 18 2f			jr .bpschk 
17d4 fe 38		.bps8c:  cp '8' 
17d6 20 08			jr nz, .bps8d 
17d8				 
17d8				; display rsp 
17d8 2a 8b f9			ld hl, (cli_ret_sp) 
17db cd 01 19			call display_dump_at_hl 
17de			 
17de 18 23			jr .bpschk 
17e0 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17e2 20 05			jr nz, .bps8 
17e4 cd 3b 1a			call monitor 
17e7			 
17e7 18 1a			jr .bpschk 
17e9 fe 30		.bps8:  cp '0' 
17eb 20 16			jr nz, .bpschk 
17ed			 
17ed 21 f9 fa				ld hl, display_fb1 
17f0 22 55 fa				ld (display_fb_active), hl 
17f3 cd 07 0b				call update_display 
17f6			 
17f6				;ld a, (os_view_af) 
17f6 2a 87 ef			ld hl, (os_view_hl) 
17f9 ed 5b 85 ef		ld de, (os_view_de) 
17fd ed 4b 83 ef		ld bc, (os_view_bc) 
1801 f1				pop af 
1802 c9				ret 
1803			 
1803			.bpschk:   
1803 cd 61 0a			call delay1s 
1806 3e 4f		ld a,display_row_4 + display_cols - 1 
1808 11 43 1c		        ld de, endprg 
180b cd f7 0a			call str_at_display 
180e cd 07 0b			call update_display 
1811 cd 4e 67			call cin_wait 
1814			 
1814 c3 64 17			jp .bps1 
1817			 
1817			 
1817			display_reg_state: 
1817			 
1817				; to restore afterwards 
1817			 
1817 d5				push de 
1818 c5				push bc 
1819 e5				push hl 
181a f5				push af 
181b			 
181b				; for use in here 
181b			 
181b c5				push bc 
181c d5				push de 
181d e5				push hl 
181e f5				push af 
181f			 
181f cd e4 0a			call clear_display 
1822			 
1822 11 d7 18			ld de, .regstate 
1825 3e 00			ld a, display_row_1 
1827 cd f7 0a			call str_at_display 
182a			 
182a				; display debug step 
182a			 
182a			 
182a 11 b4 fb			ld de, debug_mark 
182d 3e 11			ld a, display_row_1+display_cols-3 
182f cd f7 0a			call str_at_display 
1832			 
1832				; display a 
1832 11 f3 18			ld de, .regstatea 
1835 3e 14			ld a, display_row_2 
1837 cd f7 0a			call str_at_display 
183a			 
183a e1				pop hl 
183b			;	ld h,0 
183b			;	ld l, a 
183b 3e 17			ld a, display_row_2+3 
183d cd c2 16			call display_word_at 
1840			 
1840			 
1840				; display hl 
1840			 
1840			 
1840 11 e7 18			ld de, .regstatehl 
1843 3e 1e			ld a, display_row_2+10 
1845 cd f7 0a			call str_at_display 
1848			 
1848 e1				pop hl 
1849 3e 21			ld a, display_row_2+13 
184b cd c2 16			call display_word_at 
184e			 
184e				 
184e				; display de 
184e			 
184e 11 eb 18			ld de, .regstatede 
1851 3e 28			ld a, display_row_3 
1853 cd f7 0a			call str_at_display 
1856			 
1856 e1				pop hl 
1857			;	ld h,d 
1857			;	ld l, e 
1857 3e 2b			ld a, display_row_3+3 
1859 cd c2 16			call display_word_at 
185c			 
185c			 
185c				; display bc 
185c			 
185c 11 ef 18			ld de, .regstatebc 
185f 3e 32			ld a, display_row_3+10 
1861 cd f7 0a			call str_at_display 
1864			 
1864 e1				pop hl 
1865			;	ld h,b 
1865			;	ld l, c 
1865 3e 35			ld a, display_row_3+13 
1867 cd c2 16			call display_word_at 
186a			 
186a			 
186a				; display dsp 
186a			 
186a 11 f7 18			ld de, .regstatedsp 
186d 3e 3c			ld a, display_row_4 
186f cd f7 0a			call str_at_display 
1872			 
1872				 
1872 2a 87 f9			ld hl,(cli_data_sp) 
1875 3e 40			ld a, display_row_4+4 
1877 cd c2 16			call display_word_at 
187a			 
187a				; display rsp 
187a			 
187a 11 fc 18			ld de, .regstatersp 
187d 3e 46			ld a, display_row_4+10 
187f cd f7 0a			call str_at_display 
1882			 
1882				 
1882 2a 8b f9			ld hl,(cli_ret_sp) 
1885 3e 4a			ld a, display_row_4+14 
1887 cd c2 16			call display_word_at 
188a			 
188a cd 07 0b			call update_display 
188d			 
188d			;	call delay1s 
188d			;	call delay1s 
188d			;	call delay1s 
188d			 
188d			 
188d			;	call next_page_prompt 
188d			 
188d				; restore  
188d			 
188d f1				pop af 
188e e1				pop hl 
188f c1				pop bc 
1890 d1				pop de 
1891 c9				ret 
1892			 
1892 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18a6 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18bb .. 00		.ptrstate:	db "Ptr State",0 
18c5 .. 00		.ptrcliptr:     db "cli_ptr",0 
18cd .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18d7 .. 00		.regstate:	db "Reg State (1/0)",0 
18e7 .. 00		.regstatehl:	db "HL:",0 
18eb .. 00		.regstatede:	db "DE:",0 
18ef .. 00		.regstatebc:	db "BC:",0 
18f3 .. 00		.regstatea:	db "A :",0 
18f7 .. 00		.regstatedsp:	db "DSP:",0 
18fc .. 00		.regstatersp:	db "RSP:",0 
1901			 
1901			display_dump_at_hl: 
1901 e5				push hl 
1902 d5				push de 
1903 c5				push bc 
1904 f5				push af 
1905			 
1905 22 bd f2			ld (os_cur_ptr),hl	 
1908 cd e4 0a			call clear_display 
190b cd 4d 1b			call dumpcont 
190e			;	call delay1s 
190e			;	call next_page_prompt 
190e			 
190e			 
190e f1				pop af 
190f c1				pop bc 
1910 d1				pop de 
1911 e1				pop hl 
1912 c9				ret 
1913			 
1913			;if ENABLE_BASIC 
1913			;	include "nascombasic.asm" 
1913			;	basic: 
1913			;	include "forth/FORTH.ASM" 
1913			;endif 
1913			 
1913			; eof 
1913			 
1913			 
# End of file firmware_diags.asm
1913			  
1913			  
1913			  
1913			  
1913			; eof  
1913			  
# End of file firmware.asm
1913			 
1913			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1913			;if BASE_KEV  
1913			;baseram: equ 08000h 
1913			;endif 
1913			 
1913			;if BASE_SC114 
1913			;baseram:     equ    endofcode 
1913			;endif 
1913			 
1913			 
1913			; start system 
1913			 
1913			coldstart: 
1913				; set sp 
1913				; di/ei 
1913			 
1913 f3				di 
1914 31 fd ff			ld sp, tos 
1917			;	ei 
1917			 
1917			 
1917				; disable breakpoint by default 
1917			 
1917 3e 2a			ld a,'*' 
1919 32 8b ef			ld (os_view_disable),a 
191c			 
191c				; init hardware 
191c			 
191c				; init keyboard and screen hardware 
191c			 
191c cd 03 00			call hardware_init 
191f			 
191f			 
191f				; detect if any keys are held down to enable breakpoints at start up 
191f			 
191f cd 5f 67			call cin  
1922 fe 00			cp 0 
1924 28 03			jr z, .nokeys 
1926			 
1926				;call hardware_diags 
1926 cd 78 13			call config 
1929			 
1929			;	ld de, .bpen 
1929			;	ld a, display_row_4 
1929			;	call str_at_display 
1929			;	call update_display 
1929			; 
1929			;	ld a,0 
1929			;	ld (os_view_disable),a 
1929			; 
1929			;.bpwait: 
1929			;	call cin 
1929			;	cp 0 
1929			;	jr z, .bpwait 
1929			;	jr .nokeys 
1929			; 
1929			; 
1929			;.bpen:  db "Break points enabled!",0 
1929			 
1929			 
1929			 
1929			 
1929			 
1929			 
1929			.nokeys: 
1929			 
1929			 
1929				 
1929			 
1929			;jp  testkey 
1929			 
1929			;call storage_get_block_0 
1929			; 
1929			;ld hl, 0 
1929			;ld de, store_page 
1929			;call storage_read_block 
1929			 
1929				 
1929			;ld hl, 10 
1929			;ld de, store_page 
1929			;call storage_read_block 
1929			 
1929			 
1929			 
1929			 
1929			 
1929			;stop:	nop 
1929			;	jp stop 
1929			 
1929			 
1929			 
1929			main: 
1929 cd e4 0a			call clear_display 
192c cd 07 0b			call update_display 
192f			 
192f			 
192f			 
192f			;	call testlcd 
192f			 
192f			 
192f			 
192f cd 0b 20			call forth_init 
1932			 
1932			 
1932			warmstart: 
1932 cd e1 1f			call forth_warmstart 
1935			 
1935				; run startup word load 
1935			        ; TODO prevent this running at warmstart after crash  
1935			 
1935				if STARTUP_ENABLE 
1935					if STORAGE_SE 
1935 cd 90 64					call forth_autoload 
1938					endif 
1938 cd 9f 61				call forth_startup 
193b			 
193b			 
193b				endif 
193b			 
193b				; show free memory after boot 
193b 11 d5 19			ld de, freeram 
193e 3e 00			ld a, display_row_1 
1940 cd f7 0a			call str_at_display 
1943			 
1943			; Or use heap_size word???? 
1943 21 80 ef			ld hl, heap_end 
1946 11 0e 80			ld de, heap_start 
1949 ed 52			sbc hl, de 
194b e5				push hl 
194c 7c				ld a,h	         	 
194d 21 9f f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1950 cd 19 10			call hexout 
1953 e1			   	pop hl 
1954			 
1954 7d				ld a,l 
1955 21 a1 f2			ld hl, os_word_scratch+2 
1958 cd 19 10			call hexout 
195b 21 a3 f2			ld hl, os_word_scratch+4 
195e 3e 00			ld a, 0 
1960 77				ld (hl),a 
1961 11 9f f2			ld de, os_word_scratch 
1964 3e 0d			ld a, display_row_1 + 13 
1966 cd f7 0a			call str_at_display 
1969 cd 07 0b			call update_display 
196c			 
196c			 
196c				;call demo 
196c			 
196c			 
196c				; init scratch input area for cli commands 
196c			 
196c 21 c1 f2			ld hl, os_cli_cmd 
196f 3e 00			ld a,0 
1971 77				ld (hl),a 
1972 23				inc hl 
1973 77				ld (hl),a 
1974			 
1974 3e 00			ld a,0 
1976 32 c0 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1979			 
1979 32 bd f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
197c 32 be f2			ld (os_cur_ptr+1),a	 
197f			 
197f 32 9f f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1982 32 a0 f2			ld (os_word_scratch+1),a	 
1985				 
1985			 
1985				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1985 21 c1 f2			ld hl, os_cli_cmd 
1988			 
1988 3e 00			ld a, 0		 ; init cli input 
198a 77				ld (hl), a 
198b 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
198d			cli: 
198d				; show cli prompt 
198d				;push af 
198d				;ld a, 0 
198d				;ld de, prompt 
198d				;call str_at_display 
198d			 
198d				;call update_display 
198d				;pop af 
198d				;inc a 
198d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
198d 0e 00			ld c, 0 
198f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1991 1e 28			ld e, 40 
1993			 
1993 21 c1 f2			ld hl, os_cli_cmd 
1996			 
1996				STACKFRAME OFF $fefe $9f9f 
1996				if DEBUG_STACK_IMB 
1996					if OFF 
1996						exx 
1996						ld de, $fefe 
1996						ld a, d 
1996						ld hl, curframe 
1996						call hexout 
1996						ld a, e 
1996						ld hl, curframe+2 
1996						call hexout 
1996						ld hl, $fefe 
1996						push hl 
1996						ld hl, $9f9f 
1996						push hl 
1996						exx 
1996					endif 
1996				endif 
1996			endm 
# End of macro STACKFRAME
1996			 
1996 cd 45 0d			call input_str 
1999			 
1999				STACKFRAMECHK OFF $fefe $9f9f 
1999				if DEBUG_STACK_IMB 
1999					if OFF 
1999						exx 
1999						ld hl, $9f9f 
1999						pop de   ; $9f9f 
1999						call cmp16 
1999						jr nz, .spnosame 
1999						ld hl, $fefe 
1999						pop de   ; $fefe 
1999						call cmp16 
1999						jr z, .spfrsame 
1999						.spnosame: call showsperror 
1999						.spfrsame: nop 
1999						exx 
1999					endif 
1999				endif 
1999			endm 
# End of macro STACKFRAMECHK
1999			 
1999				; copy input to last command 
1999			 
1999 21 c1 f2			ld hl, os_cli_cmd 
199c 11 c0 f3			ld de, os_last_cmd 
199f 01 ff 00			ld bc, 255 
19a2 ed b0			ldir 
19a4			 
19a4				; wipe current buffer 
19a4			 
19a4			;	ld a, 0 
19a4			;	ld hl, os_cli_cmd 
19a4			;	ld de, os_cli_cmd+1 
19a4			;	ld bc, 254 
19a4			;	ldir 
19a4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19a4			;	call strcpy 
19a4			;	ld a, 0 
19a4			;	ld (hl), a 
19a4			;	inc hl 
19a4			;	ld (hl), a 
19a4			;	inc hl 
19a4			;	ld (hl), a 
19a4			 
19a4				; switch frame buffer to program  
19a4			 
19a4 21 f9 fa				ld hl, display_fb1 
19a7 22 55 fa				ld (display_fb_active), hl 
19aa			 
19aa			;	nop 
19aa				STACKFRAME ON $fbfe $8f9f 
19aa				if DEBUG_STACK_IMB 
19aa					if ON 
19aa						exx 
19aa						ld de, $fbfe 
19aa						ld a, d 
19aa						ld hl, curframe 
19aa						call hexout 
19aa						ld a, e 
19aa						ld hl, curframe+2 
19aa						call hexout 
19aa						ld hl, $fbfe 
19aa						push hl 
19aa						ld hl, $8f9f 
19aa						push hl 
19aa						exx 
19aa					endif 
19aa				endif 
19aa			endm 
# End of macro STACKFRAME
19aa				; first time into the parser so pass over the current scratch pad 
19aa 21 c1 f2			ld hl,os_cli_cmd 
19ad				; tokenise the entered statement(s) in HL 
19ad cd 84 20			call forthparse 
19b0			        ; exec forth statements in top of return stack 
19b0 cd c4 20			call forthexec 
19b3				;call forthexec_cleanup 
19b3			;	call parsenext 
19b3			 
19b3				STACKFRAMECHK ON $fbfe $8f9f 
19b3				if DEBUG_STACK_IMB 
19b3					if ON 
19b3						exx 
19b3						ld hl, $8f9f 
19b3						pop de   ; $8f9f 
19b3						call cmp16 
19b3						jr nz, .spnosame 
19b3						ld hl, $fbfe 
19b3						pop de   ; $fbfe 
19b3						call cmp16 
19b3						jr z, .spfrsame 
19b3						.spnosame: call showsperror 
19b3						.spfrsame: nop 
19b3						exx 
19b3					endif 
19b3				endif 
19b3			endm 
# End of macro STACKFRAMECHK
19b3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19b3			 
19b3 3e 3c			ld a, display_row_4 
19b5 11 e7 19			ld de, endprog 
19b8			 
19b8 cd 07 0b			call update_display		 
19bb			 
19bb cd 45 1c			call next_page_prompt 
19be			 
19be				; switch frame buffer to cli 
19be			 
19be 21 4a fb				ld hl, display_fb0 
19c1 22 55 fa				ld (display_fb_active), hl 
19c4			 
19c4			 
19c4 cd e4 0a		        call clear_display 
19c7 cd 07 0b			call update_display		 
19ca			 
19ca 21 c1 f2			ld hl, os_cli_cmd 
19cd			 
19cd 3e 00			ld a, 0		 ; init cli input 
19cf 77				ld (hl), a 
19d0			 
19d0				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19d0			 
19d0				; now on last line 
19d0			 
19d0				; TODO scroll screen up 
19d0			 
19d0				; TODO instead just clear screen and place at top of screen 
19d0			 
19d0			;	ld a, 0 
19d0			;	ld (f_cursor_ptr),a 
19d0			 
19d0				;call clear_display 
19d0				;call update_display 
19d0			 
19d0				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19d0 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19d2 c3 8d 19			jp cli 
19d5			 
19d5 .. 00		freeram: db "Free bytes: $",0 
19e3 ..			asc: db "1A2F" 
19e7 .. 00		endprog: db "End prog...",0 
19f3			 
19f3			testenter2:   
19f3 21 cc ef			ld hl,scratch+50 
19f6 22 bd f2			ld (os_cur_ptr),hl 
19f9 c3 8d 19			jp cli 
19fc			 
19fc			testenter:  
19fc			 
19fc 21 e3 19			ld hl,asc 
19ff			;	ld a,(hl) 
19ff			;	call nibble2val 
19ff cd 6f 10			call get_byte 
1a02			 
1a02			 
1a02			;	ld a,(hl) 
1a02			;	call atohex 
1a02			 
1a02			;	call fourehexhl 
1a02 32 cc ef			ld (scratch+50),a 
1a05			 
1a05			 
1a05			 
1a05 21 e5 19			ld hl,asc+2 
1a08			;	ld a, (hl) 
1a08			;	call nibble2val 
1a08 cd 6f 10			call get_byte 
1a0b			 
1a0b			;	call fourehexhl 
1a0b 32 ce ef			ld (scratch+52),a 
1a0e				 
1a0e 21 cc ef			ld hl,scratch+50 
1a11 22 bd f2			ld (os_cur_ptr),hl 
1a14 c3 8d 19			jp cli 
1a17			 
1a17			enter:	 
1a17 3a 9e ef			ld a,(scratch+4) 
1a1a fe 00			cp 0 
1a1c 28 0c			jr z, .entercont 
1a1e				; no, not a null term line so has an address to work out.... 
1a1e			 
1a1e 21 9c ef			ld hl,scratch+2 
1a21 cd cf 10			call get_word_hl 
1a24			 
1a24 22 bd f2			ld (os_cur_ptr),hl	 
1a27 c3 8d 19			jp cli 
1a2a			 
1a2a			 
1a2a			.entercont:  
1a2a			 
1a2a 21 9c ef			ld hl, scratch+2 
1a2d cd 6f 10			call get_byte 
1a30			 
1a30 2a bd f2		   	ld hl,(os_cur_ptr) 
1a33 77					ld (hl),a 
1a34 23					inc hl 
1a35 22 bd f2				ld (os_cur_ptr),hl 
1a38				 
1a38			; get byte  
1a38			 
1a38			 
1a38 c3 8d 19			jp cli 
1a3b			 
1a3b			 
1a3b			; basic monitor support 
1a3b			 
1a3b			monitor: 
1a3b				;  
1a3b cd e4 0a			call clear_display 
1a3e 3e 00			ld a, 0 
1a40 11 88 1a			ld de, .monprompt 
1a43 cd f7 0a			call str_at_display 
1a46 cd 07 0b			call update_display 
1a49			 
1a49				; get a monitor command 
1a49			 
1a49 0e 00			ld c, 0     ; entry at top left 
1a4b 16 64			ld d, 100   ; max buffer size 
1a4d 1e 0f			ld e, 15    ; input scroll area 
1a4f 3e 00			ld a, 0     ; init string 
1a51 21 98 f1			ld hl, os_input 
1a54 77				ld (hl), a 
1a55 23				inc hl 
1a56 77				ld (hl), a 
1a57 21 98 f1			ld hl, os_input 
1a5a 3e 01			ld a, 1     ; init string 
1a5c cd 45 0d			call input_str 
1a5f			 
1a5f cd e4 0a		        call clear_display 
1a62 cd 07 0b			call update_display		 
1a65			 
1a65 3a 98 f1			ld a, (os_input) 
1a68 cd 6d 11			call toUpper 
1a6b fe 48		        cp 'H' 
1a6d 28 6f		        jr z, .monhelp 
1a6f fe 44			cp 'D'		; dump 
1a71 ca ff 1a			jp z, .mondump	 
1a74 fe 43			cp 'C'		; dump 
1a76 ca 19 1b			jp z, .moncdump	 
1a79 fe 4d			cp 'M'		; dump 
1a7b ca 8a 1a			jp z, .moneditstart 
1a7e fe 55			cp 'U'		; dump 
1a80 28 14			jr z, .monedit	 
1a82 fe 51			cp 'Q'		; dump 
1a84 c8				ret z	 
1a85			 
1a85			 
1a85				; TODO "S" to access symbol by name and not need the address 
1a85				; TODO "F" to find a string in memory 
1a85			 
1a85 c3 3b 1a			jp monitor 
1a88			 
1a88 .. 00		.monprompt: db ">", 0 
1a8a			 
1a8a			.moneditstart: 
1a8a				; get starting address 
1a8a			 
1a8a 21 9a f1			ld hl,os_input+2 
1a8d cd cf 10			call get_word_hl 
1a90			 
1a90 22 bd f2			ld (os_cur_ptr),hl	 
1a93			 
1a93 c3 3b 1a			jp monitor 
1a96			 
1a96			.monedit: 
1a96				; get byte to load 
1a96			 
1a96 21 9a f1			ld hl,os_input+2 
1a99 cd 6f 10			call get_byte 
1a9c			 
1a9c				; get address to update 
1a9c 2a bd f2			ld hl, (os_cur_ptr) 
1a9f			 
1a9f				; update byte 
1a9f			 
1a9f 77				ld (hl), a 
1aa0			 
1aa0				; move to next address and save it 
1aa0			 
1aa0 23				inc hl 
1aa1 22 bd f2			ld (os_cur_ptr),hl	 
1aa4			 
1aa4 c3 3b 1a			jp monitor 
1aa7			 
1aa7			 
1aa7 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1abb .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ad7 .. 00		.monhelptext3:  db "Q-Quit",0 
1ade			        
1ade			.monhelp: 
1ade 3e 00			ld a, display_row_1 
1ae0 11 a7 1a		        ld de, .monhelptext1 
1ae3			 
1ae3 cd f7 0a			call str_at_display 
1ae6 3e 14			ld a, display_row_2 
1ae8 11 bb 1a		        ld de, .monhelptext2 
1aeb					 
1aeb cd f7 0a			call str_at_display 
1aee 3e 28			ld a, display_row_3 
1af0 11 d7 1a		        ld de, .monhelptext3 
1af3					 
1af3 cd f7 0a			call str_at_display 
1af6 cd 07 0b			call update_display		 
1af9			 
1af9 cd 45 1c			call next_page_prompt 
1afc c3 3b 1a			jp monitor 
1aff			 
1aff			.mondump:    
1aff 21 9a f1			ld hl,os_input+2 
1b02 cd cf 10			call get_word_hl 
1b05			 
1b05 22 bd f2			ld (os_cur_ptr),hl	 
1b08 cd 4d 1b			call dumpcont 
1b0b 3e 3c			ld a, display_row_4 
1b0d 11 e7 19			ld de, endprog 
1b10			 
1b10 cd 07 0b			call update_display		 
1b13			 
1b13 cd 45 1c			call next_page_prompt 
1b16 c3 3b 1a			jp monitor 
1b19			.moncdump: 
1b19 cd 4d 1b			call dumpcont 
1b1c 3e 3c			ld a, display_row_4 
1b1e 11 e7 19			ld de, endprog 
1b21			 
1b21 cd 07 0b			call update_display		 
1b24			 
1b24 cd 45 1c			call next_page_prompt 
1b27 c3 3b 1a			jp monitor 
1b2a			 
1b2a			 
1b2a			; TODO symbol access  
1b2a			 
1b2a			.symbols:     ;; A list of symbols that can be called up  
1b2a 4a fb			dw display_fb0 
1b2c .. 00			db "fb0",0  
1b30 df f9		     	dw store_page 
1b32 .. 00			db "store_page",0 
1b3d			 
1b3d			 
1b3d			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b3d			 
1b3d 3a 9b ef			ld a,(scratch+1) 
1b40 fe 00			cp 0 
1b42 28 09			jr z, dumpcont 
1b44			 
1b44				; no, not a null term line so has an address to work out.... 
1b44			 
1b44 21 9c ef			ld hl,scratch+2 
1b47 cd cf 10			call get_word_hl 
1b4a			 
1b4a 22 bd f2			ld (os_cur_ptr),hl	 
1b4d			 
1b4d			 
1b4d			 
1b4d			dumpcont: 
1b4d			 
1b4d				; dump bytes at ptr 
1b4d			 
1b4d			 
1b4d 3e 00			ld a, display_row_1 
1b4f 2a 55 fa			ld hl, (display_fb_active) 
1b52 cd 18 0d			call addatohl 
1b55 cd 7d 1b			call .dumpbyterow 
1b58			 
1b58 3e 14			ld a, display_row_2 
1b5a 2a 55 fa			ld hl, (display_fb_active) 
1b5d cd 18 0d			call addatohl 
1b60 cd 7d 1b			call .dumpbyterow 
1b63			 
1b63			 
1b63 3e 28			ld a, display_row_3 
1b65 2a 55 fa			ld hl, (display_fb_active) 
1b68 cd 18 0d			call addatohl 
1b6b cd 7d 1b			call .dumpbyterow 
1b6e			 
1b6e 3e 3c			ld a, display_row_4 
1b70 2a 55 fa			ld hl, (display_fb_active) 
1b73 cd 18 0d			call addatohl 
1b76 cd 7d 1b			call .dumpbyterow 
1b79			 
1b79 cd 07 0b			call update_display 
1b7c			;		jp cli 
1b7c c9				ret 
1b7d			 
1b7d			.dumpbyterow: 
1b7d			 
1b7d				;push af 
1b7d			 
1b7d e5				push hl 
1b7e			 
1b7e				; calc where to poke the ascii 
1b7e			if display_cols == 20 
1b7e 3e 10			ld a, 16 
1b80			else 
1b80				ld a, 31 
1b80			endif 
1b80			 
1b80 cd 18 0d			call addatohl 
1b83 22 9f f2			ld (os_word_scratch),hl  		; save pos for later 
1b86			 
1b86			 
1b86			; display decoding address 
1b86 2a bd f2		   	ld hl,(os_cur_ptr) 
1b89			 
1b89 7c				ld a,h 
1b8a e1				pop hl 
1b8b e5				push hl 
1b8c			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b8c cd 19 10			call hexout 
1b8f 2a bd f2		   	ld hl,(os_cur_ptr) 
1b92			 
1b92 7d				ld a,l 
1b93 e1				pop hl 
1b94 23				inc hl 
1b95 23				inc hl 
1b96 e5				push hl 
1b97			;	ld hl, os_word_scratch+2 
1b97 cd 19 10			call hexout 
1b9a e1				pop hl 
1b9b 23				inc hl 
1b9c 23				inc hl 
1b9d				;ld hl, os_word_scratch+4 
1b9d 3e 3a			ld a, ':' 
1b9f 77				ld (hl),a 
1ba0 23				inc hl 
1ba1				;ld a, 0 
1ba1				;ld (hl),a 
1ba1				;ld de, os_word_scratch 
1ba1				;pop af 
1ba1				;push af 
1ba1			;		ld a, display_row_2 
1ba1			;		call str_at_display 
1ba1			;		call update_display 
1ba1			 
1ba1			 
1ba1			;pop af 
1ba1			;	add 5 
1ba1			 
1ba1			if display_cols == 20 
1ba1 06 04			ld b, 4 
1ba3			else 
1ba3				ld b, 8 
1ba3			endif	 
1ba3			 
1ba3			.dumpbyte: 
1ba3 c5				push bc 
1ba4 e5				push hl 
1ba5			 
1ba5			 
1ba5 2a bd f2		   	ld hl,(os_cur_ptr) 
1ba8 7e					ld a,(hl) 
1ba9			 
1ba9					; poke the ascii to display 
1ba9 2a 9f f2				ld hl,(os_word_scratch) 
1bac 77					ld (hl),a 
1bad 23					inc hl 
1bae 22 9f f2				ld (os_word_scratch),hl 
1bb1			 
1bb1					 
1bb1			 
1bb1			 
1bb1 e1					pop hl 
1bb2 e5					push hl 
1bb3			 
1bb3 cd 19 10				call hexout 
1bb6			 
1bb6					 
1bb6 2a bd f2		   	ld hl,(os_cur_ptr) 
1bb9 23				inc hl 
1bba 22 bd f2		   	ld (os_cur_ptr),hl 
1bbd			 
1bbd e1					pop hl 
1bbe 23					inc hl 
1bbf 23					inc hl 
1bc0 23					inc hl 
1bc1			 
1bc1			 
1bc1			 
1bc1					;ld a,0 
1bc1					;ld (os_word_scratch+2),a 
1bc1					;pop af 
1bc1					;push af 
1bc1			 
1bc1					;ld de, os_word_scratch 
1bc1					;call str_at_display 
1bc1			;		call update_display 
1bc1			;		pop af 
1bc1 c1					pop bc 
1bc2 c6 03				add 3 
1bc4 10 dd			djnz .dumpbyte 
1bc6			 
1bc6				 
1bc6			 
1bc6 c9				ret 
1bc7			 
1bc7			jump:	 
1bc7			 
1bc7 21 9c ef			ld hl,scratch+2 
1bca cd cf 10			call get_word_hl 
1bcd				;ld hl,(scratch+2) 
1bcd				;call fourehexhl 
1bcd			 
1bcd 22 bd f2			ld (os_cur_ptr),hl	 
1bd0			 
1bd0 e9				jp (hl) 
1bd1			 
1bd1			 
1bd1			 
1bd1			; TODO implement a basic monitor mode to start with 
1bd1			 
1bd1			 
1bd1			 
1bd1			 
1bd1			 
1bd1			 
1bd1			 
1bd1			 
1bd1			 
1bd1			; testing and demo code during development 
1bd1			 
1bd1			 
1bd1 .. 00		str1: db "Enter some text...",0 
1be4 .. 00		clear: db "                    ",0 
1bf9			 
1bf9			demo: 
1bf9			 
1bf9			 
1bf9			 
1bf9			;	call update_display 
1bf9			 
1bf9				; init scratch input area for testing 
1bf9 21 9a ef			ld hl, scratch	 
1bfc 3e 00			ld a,0 
1bfe 77				ld (hl),a 
1bff			 
1bff			 
1bff 3e 14		            LD   A, display_row_2 
1c01			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c01 11 d1 1b		            LD   DE, str1 
1c04 cd f7 0a			call str_at_display 
1c07			 
1c07			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c07			cloop:	 
1c07 3e 28		            LD   A, display_row_3 
1c09			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c09 11 e4 1b		            LD   DE, clear 
1c0c			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c0c cd f7 0a				call str_at_display 
1c0f 3e 3c			ld a, display_row_4 
1c11 11 41 1c			ld de, prompt 
1c14			 
1c14 cd f7 0a				call str_at_display 
1c17 cd 07 0b			call update_display 
1c1a			 
1c1a 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c1c 16 0a			ld d, 10 
1c1e 21 9a ef			ld hl, scratch	 
1c21 cd 45 0d			call input_str 
1c24			 
1c24			;	call clear_display 
1c24			;'	call update_display 
1c24			 
1c24 3e 00		            LD   A, display_row_1 
1c26			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c26 11 e4 1b		            LD   DE, clear 
1c29 cd f7 0a				call str_at_display 
1c2c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c2c 3e 00		            LD   A, display_row_1 
1c2e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c2e 11 9a ef		            LD   DE, scratch 
1c31			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c31 cd f7 0a				call str_at_display 
1c34 cd 07 0b			call update_display 
1c37			 
1c37 3e 00				ld a,0 
1c39 21 9a ef			ld hl, scratch 
1c3c 77				ld (hl),a 
1c3d			 
1c3d 00				nop 
1c3e c3 07 1c			jp cloop 
1c41			 
1c41			 
1c41			 
1c41			; OS Prompt 
1c41			 
1c41 .. 00		prompt: db ">",0 
1c43 .. 00		endprg: db "?",0 
1c45			 
1c45			 
1c45			; handy next page prompt 
1c45			next_page_prompt: 
1c45 e5				push hl 
1c46 d5				push de 
1c47 f5				push af 
1c48 c5				push bc 
1c49			 
1c49 3e 4f			ld a,display_row_4 + display_cols - 1 
1c4b 11 43 1c		        ld de, endprg 
1c4e cd f7 0a			call str_at_display 
1c51 cd 07 0b			call update_display 
1c54 cd 4e 67			call cin_wait 
1c57 c1				pop bc 
1c58 f1				pop af 
1c59 d1				pop de 
1c5a e1				pop hl 
1c5b			 
1c5b			 
1c5b c9				ret 
1c5c			 
1c5c			 
1c5c			; forth parser 
1c5c			 
1c5c			; My forth kernel 
1c5c			include "forth_kernel.asm" 
1c5c			; 
1c5c			; kernel to the forth OS 
1c5c			 
1c5c			DS_TYPE_STR: equ 1     ; string type 
1c5c			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c5c			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c5c			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c5c			 
1c5c			FORTH_PARSEV1: equ 0 
1c5c			FORTH_PARSEV2: equ 0 
1c5c			FORTH_PARSEV3: equ 0 
1c5c			FORTH_PARSEV4: equ 0 
1c5c			FORTH_PARSEV5: equ 1 
1c5c			 
1c5c			;if FORTH_PARSEV5 
1c5c			;	FORTH_END_BUFFER: equ 0 
1c5c			;else 
1c5c			FORTH_END_BUFFER: equ 127 
1c5c			;endif 
1c5c			 
1c5c			FORTH_TRUE: equ 1 
1c5c			FORTH_FALSE: equ 0 
1c5c			 
1c5c			if FORTH_PARSEV4 
1c5c			include "forth_stackops.asm" 
1c5c			endif 
1c5c			 
1c5c			if FORTH_PARSEV5 
1c5c			include "forth_stackopsv5.asm" 
1c5c			 
1c5c			; Stack operations for v5 parser on wards 
1c5c			; * DATA stack 
1c5c			; * LOOP stack 
1c5c			; * RETURN stack 
1c5c			 
1c5c			 
1c5c			 
1c5c			FORTH_CHK_DSP_UNDER: macro 
1c5c				push hl 
1c5c				push de 
1c5c				ld hl,(cli_data_sp) 
1c5c				ld de, cli_data_stack 
1c5c				call cmp16 
1c5c				jp c, fault_dsp_under 
1c5c				pop de 
1c5c				pop hl 
1c5c				endm 
1c5c			 
1c5c			 
1c5c			FORTH_CHK_RSP_UNDER: macro 
1c5c				push hl 
1c5c				push de 
1c5c				ld hl,(cli_ret_sp) 
1c5c				ld de, cli_ret_stack 
1c5c				call cmp16 
1c5c				jp c, fault_rsp_under 
1c5c				pop de 
1c5c				pop hl 
1c5c				endm 
1c5c			 
1c5c			FORTH_CHK_LOOP_UNDER: macro 
1c5c				push hl 
1c5c				push de 
1c5c				ld hl,(cli_loop_sp) 
1c5c				ld de, cli_loop_stack 
1c5c				call cmp16 
1c5c				jp c, fault_loop_under 
1c5c				pop de 
1c5c				pop hl 
1c5c				endm 
1c5c			 
1c5c			FORTH_ERR_TOS_NOTSTR: macro 
1c5c				; TOSO might need more for checks when used 
1c5c				push af 
1c5c				ld a,(hl) 
1c5c				cp DS_TYPE_STR 
1c5c				jp nz, type_faultn   
1c5c				pop af 
1c5c				endm 
1c5c			 
1c5c			FORTH_ERR_TOS_NOTNUM: macro 
1c5c				push af 
1c5c				ld a,(hl) 
1c5c				cp DS_TYPE_INUM 
1c5c				jp nz, type_faultn   
1c5c				pop af 
1c5c				endm 
1c5c			 
1c5c			 
1c5c			; increase data stack pointer and save hl to it 
1c5c				 
1c5c			FORTH_DSP_NEXT: macro 
1c5c				call macro_forth_dsp_next 
1c5c				endm 
1c5c			 
1c5c			 
1c5c			macro_forth_dsp_next: 
1c5c				if DEBUG_FORTH_STACK_GUARD 
1c5c cd 69 62				call check_stacks 
1c5f				endif 
1c5f e5				push hl 
1c60 d5				push de 
1c61 eb				ex de,hl 
1c62 2a 87 f9			ld hl,(cli_data_sp) 
1c65 23				inc hl 
1c66 23				inc hl 
1c67			 
1c67			; PARSEV5 
1c67 23				inc hl 
1c68 22 87 f9			ld (cli_data_sp),hl 
1c6b 73				ld (hl), e 
1c6c 23				inc hl 
1c6d 72				ld (hl), d 
1c6e d1				pop de 
1c6f e1				pop hl 
1c70				if DEBUG_FORTH_STACK_GUARD 
1c70 cd 69 62				call check_stacks 
1c73				endif 
1c73 c9				ret 
1c74			 
1c74			 
1c74			; increase ret stack pointer and save hl to it 
1c74				 
1c74			FORTH_RSP_NEXT: macro 
1c74				call macro_forth_rsp_next 
1c74				endm 
1c74			 
1c74			macro_forth_rsp_next: 
1c74				if DEBUG_FORTH_STACK_GUARD 
1c74 cd 69 62				call check_stacks 
1c77				endif 
1c77 e5				push hl 
1c78 d5				push de 
1c79 eb				ex de,hl 
1c7a 2a 8b f9			ld hl,(cli_ret_sp) 
1c7d 23				inc hl 
1c7e 23				inc hl 
1c7f 22 8b f9			ld (cli_ret_sp),hl 
1c82 73				ld (hl), e 
1c83 23				inc hl 
1c84 72				ld (hl), d 
1c85 d1				pop de 
1c86 e1				pop hl 
1c87				if DEBUG_FORTH_STACK_GUARD 
1c87 cd 69 62				call check_stacks 
1c8a				endif 
1c8a c9				ret 
1c8b			 
1c8b			; get current ret stack pointer and save to hl  
1c8b				 
1c8b			FORTH_RSP_TOS: macro 
1c8b				call macro_forth_rsp_tos 
1c8b				endm 
1c8b			 
1c8b			macro_forth_rsp_tos: 
1c8b				;push de 
1c8b 2a 8b f9			ld hl,(cli_ret_sp) 
1c8e cd c6 1c			call loadhlptrtohl 
1c91				;ld e, (hl) 
1c91				;inc hl 
1c91				;ld d, (hl) 
1c91				;ex de, hl 
1c91					if DEBUG_FORTH_WORDS 
1c91			;			DMARK "RST" 
1c91						CALLMONITOR 
1c91 cd 3d 17			call break_point_state  
1c94				endm  
# End of macro CALLMONITOR
1c94					endif 
1c94				;pop de 
1c94 c9				ret 
1c95			 
1c95			; pop ret stack pointer 
1c95				 
1c95			FORTH_RSP_POP: macro 
1c95				call macro_forth_rsp_pop 
1c95				endm 
1c95			 
1c95			 
1c95			macro_forth_rsp_pop: 
1c95				if DEBUG_FORTH_STACK_GUARD 
1c95			;		DMARK "RPP" 
1c95 cd 69 62				call check_stacks 
1c98					FORTH_CHK_RSP_UNDER 
1c98 e5				push hl 
1c99 d5				push de 
1c9a 2a 8b f9			ld hl,(cli_ret_sp) 
1c9d 11 05 f9			ld de, cli_ret_stack 
1ca0 cd 36 0d			call cmp16 
1ca3 da 7d 63			jp c, fault_rsp_under 
1ca6 d1				pop de 
1ca7 e1				pop hl 
1ca8				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ca8				endif 
1ca8 e5				push hl 
1ca9 2a 8b f9			ld hl,(cli_ret_sp) 
1cac			 
1cac			 
1cac				if FORTH_ENABLE_FREE 
1cac			 
1cac					; get pointer 
1cac			 
1cac					push de 
1cac					push hl 
1cac			 
1cac					ld e, (hl) 
1cac					inc hl 
1cac					ld d, (hl) 
1cac			 
1cac					ex de, hl 
1cac					call free 
1cac			 
1cac					pop hl 
1cac					pop de 
1cac			 
1cac			 
1cac				endif 
1cac			 
1cac			 
1cac 2b				dec hl 
1cad 2b				dec hl 
1cae 22 8b f9			ld (cli_ret_sp), hl 
1cb1				; do stack underflow checks 
1cb1 e1				pop hl 
1cb2				if DEBUG_FORTH_STACK_GUARD 
1cb2 cd 69 62				call check_stacks 
1cb5					FORTH_CHK_RSP_UNDER 
1cb5 e5				push hl 
1cb6 d5				push de 
1cb7 2a 8b f9			ld hl,(cli_ret_sp) 
1cba 11 05 f9			ld de, cli_ret_stack 
1cbd cd 36 0d			call cmp16 
1cc0 da 7d 63			jp c, fault_rsp_under 
1cc3 d1				pop de 
1cc4 e1				pop hl 
1cc5				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cc5				endif 
1cc5 c9				ret 
1cc6			 
1cc6			 
1cc6			 
1cc6			; routine to load word pointed to by hl into hl 
1cc6			 
1cc6			loadhlptrtohl: 
1cc6			 
1cc6 d5				push de 
1cc7 5e				ld e, (hl) 
1cc8 23				inc hl 
1cc9 56				ld d, (hl) 
1cca eb				ex de, hl 
1ccb d1				pop de 
1ccc			 
1ccc c9				ret 
1ccd			 
1ccd			 
1ccd			 
1ccd			 
1ccd			 
1ccd			; push a number held in HL onto the data stack 
1ccd			; entry point for pushing a value when already in hl used in function above 
1ccd			 
1ccd			forth_push_numhl: 
1ccd			 
1ccd e5				push hl    ; save value to push 
1cce			 
1cce			if DEBUG_FORTH_PUSH 
1cce				; see if disabled 
1cce			 
1cce			 
1cce f5				push af 
1ccf 3a 8b ef			ld a, (os_view_disable) 
1cd2 fe 2a			cp '*' 
1cd4 28 34			jr z, .pskip2 
1cd6 e5				push hl 
1cd7 e5			push hl 
1cd8 cd e4 0a			call clear_display 
1cdb e1			pop hl 
1cdc 7c				ld a,h 
1cdd 21 9f f2			ld hl, os_word_scratch 
1ce0 cd 19 10			call hexout 
1ce3 e1				pop hl 
1ce4 7d				ld a,l 
1ce5 21 a1 f2			ld hl, os_word_scratch+2 
1ce8 cd 19 10			call hexout 
1ceb			 
1ceb 21 a3 f2			ld hl, os_word_scratch+4 
1cee 3e 00			ld a,0 
1cf0 77				ld (hl),a 
1cf1 11 9f f2			ld de,os_word_scratch 
1cf4 3e 14				ld a, display_row_2 
1cf6 cd f7 0a				call str_at_display 
1cf9 11 77 51			ld de, .push_num 
1cfc 3e 00			ld a, display_row_1 
1cfe			 
1cfe cd f7 0a				call str_at_display 
1d01			 
1d01			 
1d01 cd 07 0b			call update_display 
1d04 cd 61 0a			call delay1s 
1d07 cd 61 0a			call delay1s 
1d0a			.pskip2:  
1d0a			 
1d0a f1				pop af 
1d0b			endif	 
1d0b			 
1d0b			 
1d0b				FORTH_DSP_NEXT 
1d0b cd 5c 1c			call macro_forth_dsp_next 
1d0e				endm 
# End of macro FORTH_DSP_NEXT
1d0e			 
1d0e 2a 87 f9			ld hl, (cli_data_sp) 
1d11			 
1d11				; save item type 
1d11 3e 02			ld a,  DS_TYPE_INUM 
1d13 77				ld (hl), a 
1d14 23				inc hl 
1d15			 
1d15				; get word off stack 
1d15 d1				pop de 
1d16 7b				ld a,e 
1d17 77				ld (hl), a 
1d18 23				inc hl 
1d19 7a				ld a,d 
1d1a 77				ld (hl), a 
1d1b			 
1d1b			if DEBUG_FORTH_PUSH 
1d1b 2b				dec hl 
1d1c 2b				dec hl 
1d1d 2b				dec hl 
1d1e						DMARK "PH5" 
1d1e f5				push af  
1d1f 3a 33 1d			ld a, (.dmark)  
1d22 32 b4 fb			ld (debug_mark),a  
1d25 3a 34 1d			ld a, (.dmark+1)  
1d28 32 b5 fb			ld (debug_mark+1),a  
1d2b 3a 35 1d			ld a, (.dmark+2)  
1d2e 32 b6 fb			ld (debug_mark+2),a  
1d31 18 03			jr .pastdmark  
1d33 ..			.dmark: db "PH5"  
1d36 f1			.pastdmark: pop af  
1d37			endm  
# End of macro DMARK
1d37				CALLMONITOR 
1d37 cd 3d 17			call break_point_state  
1d3a				endm  
# End of macro CALLMONITOR
1d3a			endif	 
1d3a			 
1d3a c9				ret 
1d3b			 
1d3b			 
1d3b			; Push a string to stack pointed to by hl 
1d3b			 
1d3b			forth_push_str: 
1d3b			 
1d3b			if DEBUG_FORTH_PUSH 
1d3b						DMARK "PSQ" 
1d3b f5				push af  
1d3c 3a 50 1d			ld a, (.dmark)  
1d3f 32 b4 fb			ld (debug_mark),a  
1d42 3a 51 1d			ld a, (.dmark+1)  
1d45 32 b5 fb			ld (debug_mark+1),a  
1d48 3a 52 1d			ld a, (.dmark+2)  
1d4b 32 b6 fb			ld (debug_mark+2),a  
1d4e 18 03			jr .pastdmark  
1d50 ..			.dmark: db "PSQ"  
1d53 f1			.pastdmark: pop af  
1d54			endm  
# End of macro DMARK
1d54				CALLMONITOR 
1d54 cd 3d 17			call break_point_state  
1d57				endm  
# End of macro CALLMONITOR
1d57			endif	 
1d57			    
1d57 e5				push hl 
1d58 e5				push hl 
1d59			 
1d59			;	ld a, 0   ; find end of string 
1d59 cd 76 11			call strlenz 
1d5c			if DEBUG_FORTH_PUSH 
1d5c						DMARK "PQ2" 
1d5c f5				push af  
1d5d 3a 71 1d			ld a, (.dmark)  
1d60 32 b4 fb			ld (debug_mark),a  
1d63 3a 72 1d			ld a, (.dmark+1)  
1d66 32 b5 fb			ld (debug_mark+1),a  
1d69 3a 73 1d			ld a, (.dmark+2)  
1d6c 32 b6 fb			ld (debug_mark+2),a  
1d6f 18 03			jr .pastdmark  
1d71 ..			.dmark: db "PQ2"  
1d74 f1			.pastdmark: pop af  
1d75			endm  
# End of macro DMARK
1d75				CALLMONITOR 
1d75 cd 3d 17			call break_point_state  
1d78				endm  
# End of macro CALLMONITOR
1d78			endif	 
1d78 eb				ex de, hl 
1d79 e1				pop hl   ; get ptr to start of string 
1d7a			if DEBUG_FORTH_PUSH 
1d7a						DMARK "PQ3" 
1d7a f5				push af  
1d7b 3a 8f 1d			ld a, (.dmark)  
1d7e 32 b4 fb			ld (debug_mark),a  
1d81 3a 90 1d			ld a, (.dmark+1)  
1d84 32 b5 fb			ld (debug_mark+1),a  
1d87 3a 91 1d			ld a, (.dmark+2)  
1d8a 32 b6 fb			ld (debug_mark+2),a  
1d8d 18 03			jr .pastdmark  
1d8f ..			.dmark: db "PQ3"  
1d92 f1			.pastdmark: pop af  
1d93			endm  
# End of macro DMARK
1d93				CALLMONITOR 
1d93 cd 3d 17			call break_point_state  
1d96				endm  
# End of macro CALLMONITOR
1d96			endif	 
1d96 19				add hl,de 
1d97			if DEBUG_FORTH_PUSH 
1d97						DMARK "PQE" 
1d97 f5				push af  
1d98 3a ac 1d			ld a, (.dmark)  
1d9b 32 b4 fb			ld (debug_mark),a  
1d9e 3a ad 1d			ld a, (.dmark+1)  
1da1 32 b5 fb			ld (debug_mark+1),a  
1da4 3a ae 1d			ld a, (.dmark+2)  
1da7 32 b6 fb			ld (debug_mark+2),a  
1daa 18 03			jr .pastdmark  
1dac ..			.dmark: db "PQE"  
1daf f1			.pastdmark: pop af  
1db0			endm  
# End of macro DMARK
1db0				CALLMONITOR 
1db0 cd 3d 17			call break_point_state  
1db3				endm  
# End of macro CALLMONITOR
1db3			endif	 
1db3			 
1db3 2b				dec hl    ; see if there is an optional trailing double quote 
1db4 7e				ld a,(hl) 
1db5 fe 22			cp '"' 
1db7 20 03			jr nz, .strnoq 
1db9 3e 00			ld a, 0      ; get rid of double quote 
1dbb 77				ld (hl), a 
1dbc 23			.strnoq: inc hl 
1dbd			 
1dbd 3e 00			ld a, 0 
1dbf 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1dc0			 
1dc0 13				inc de ; add one for the type string 
1dc1 13				inc de ; add one for null term??? 
1dc2			 
1dc2				; tos is get string pointer again 
1dc2				; de contains space to allocate 
1dc2				 
1dc2 d5				push de 
1dc3			 
1dc3 eb				ex de, hl 
1dc4			 
1dc4				;push af 
1dc4			 
1dc4			if DEBUG_FORTH_PUSH 
1dc4						DMARK "PHm" 
1dc4 f5				push af  
1dc5 3a d9 1d			ld a, (.dmark)  
1dc8 32 b4 fb			ld (debug_mark),a  
1dcb 3a da 1d			ld a, (.dmark+1)  
1dce 32 b5 fb			ld (debug_mark+1),a  
1dd1 3a db 1d			ld a, (.dmark+2)  
1dd4 32 b6 fb			ld (debug_mark+2),a  
1dd7 18 03			jr .pastdmark  
1dd9 ..			.dmark: db "PHm"  
1ddc f1			.pastdmark: pop af  
1ddd			endm  
# End of macro DMARK
1ddd				CALLMONITOR 
1ddd cd 3d 17			call break_point_state  
1de0				endm  
# End of macro CALLMONITOR
1de0			endif	 
1de0 cd df 11			call malloc	; on ret hl now contains allocated memory 
1de3				if DEBUG_FORTH_MALLOC_GUARD 
1de3 cc cf 51				call z,malloc_error 
1de6				endif 
1de6			 
1de6				 
1de6 c1				pop bc    ; get length 
1de7 d1				pop de   ;  get string start    
1de8			 
1de8				; hl has destination from malloc 
1de8			 
1de8 eb				ex de, hl    ; prep for ldir 
1de9			 
1de9 d5				push de   ; save malloc area for DSP later 
1dea				;push hl   ; save malloc area for DSP later 
1dea			 
1dea			if DEBUG_FORTH_PUSH 
1dea						DMARK "PHc" 
1dea f5				push af  
1deb 3a ff 1d			ld a, (.dmark)  
1dee 32 b4 fb			ld (debug_mark),a  
1df1 3a 00 1e			ld a, (.dmark+1)  
1df4 32 b5 fb			ld (debug_mark+1),a  
1df7 3a 01 1e			ld a, (.dmark+2)  
1dfa 32 b6 fb			ld (debug_mark+2),a  
1dfd 18 03			jr .pastdmark  
1dff ..			.dmark: db "PHc"  
1e02 f1			.pastdmark: pop af  
1e03			endm  
# End of macro DMARK
1e03				CALLMONITOR 
1e03 cd 3d 17			call break_point_state  
1e06				endm  
# End of macro CALLMONITOR
1e06			endif	 
1e06			 
1e06			 
1e06 ed b0			ldir 
1e08			 
1e08			 
1e08				; push malloc to data stack     macro?????  
1e08			 
1e08				FORTH_DSP_NEXT 
1e08 cd 5c 1c			call macro_forth_dsp_next 
1e0b				endm 
# End of macro FORTH_DSP_NEXT
1e0b			 
1e0b				; save value and type 
1e0b			 
1e0b 2a 87 f9			ld hl, (cli_data_sp) 
1e0e			 
1e0e				; save item type 
1e0e 3e 01			ld a,  DS_TYPE_STR 
1e10 77				ld (hl), a 
1e11 23				inc hl 
1e12			 
1e12				; get malloc word off stack 
1e12 d1				pop de 
1e13 73				ld (hl), e 
1e14 23				inc hl 
1e15 72				ld (hl), d 
1e16			 
1e16			 
1e16			 
1e16			if DEBUG_FORTH_PUSH 
1e16 2a 87 f9			ld hl, (cli_data_sp) 
1e19						DMARK "PHS" 
1e19 f5				push af  
1e1a 3a 2e 1e			ld a, (.dmark)  
1e1d 32 b4 fb			ld (debug_mark),a  
1e20 3a 2f 1e			ld a, (.dmark+1)  
1e23 32 b5 fb			ld (debug_mark+1),a  
1e26 3a 30 1e			ld a, (.dmark+2)  
1e29 32 b6 fb			ld (debug_mark+2),a  
1e2c 18 03			jr .pastdmark  
1e2e ..			.dmark: db "PHS"  
1e31 f1			.pastdmark: pop af  
1e32			endm  
# End of macro DMARK
1e32				CALLMONITOR 
1e32 cd 3d 17			call break_point_state  
1e35				endm  
# End of macro CALLMONITOR
1e35			;	ex de,hl 
1e35			endif	 
1e35				; in case of spaces, skip the ptr past the copied string 
1e35				;pop af 
1e35				;ld (cli_origptr),hl 
1e35			 
1e35 c9				ret 
1e36			 
1e36			 
1e36			 
1e36			; TODO ascii push input onto stack given hl to start of input 
1e36			 
1e36			; identify type 
1e36			; if starts with a " then a string 
1e36			; otherwise it is a number 
1e36			;  
1e36			; if a string 
1e36			;     scan for ending " to get length of string to malloc for + 1 
1e36			;     malloc 
1e36			;     put pointer to string on stack first byte flags as string 
1e36			; 
1e36			; else a number 
1e36			;    look for number format identifier 
1e36			;    $xx hex 
1e36			;    %xxxxx bin 
1e36			;    xxxxx decimal 
1e36			;    convert number to 16bit word.  
1e36			;    malloc word + 1 with flag to identiy as num 
1e36			;    put pointer to number on stack 
1e36			;   
1e36			;  
1e36			  
1e36			forth_apush: 
1e36				; kernel push 
1e36			 
1e36			if DEBUG_FORTH_PUSH 
1e36						DMARK "PSH" 
1e36 f5				push af  
1e37 3a 4b 1e			ld a, (.dmark)  
1e3a 32 b4 fb			ld (debug_mark),a  
1e3d 3a 4c 1e			ld a, (.dmark+1)  
1e40 32 b5 fb			ld (debug_mark+1),a  
1e43 3a 4d 1e			ld a, (.dmark+2)  
1e46 32 b6 fb			ld (debug_mark+2),a  
1e49 18 03			jr .pastdmark  
1e4b ..			.dmark: db "PSH"  
1e4e f1			.pastdmark: pop af  
1e4f			endm  
# End of macro DMARK
1e4f				CALLMONITOR 
1e4f cd 3d 17			call break_point_state  
1e52				endm  
# End of macro CALLMONITOR
1e52			endif	 
1e52				; identify input type 
1e52			 
1e52 7e				ld a,(hl) 
1e53 fe 22			cp '"' 
1e55 28 0a			jr z, .fapstr 
1e57 fe 24			cp '$' 
1e59 ca 81 1e			jp z, .faphex 
1e5c fe 25			cp '%' 
1e5e ca 69 1e			jp z, .fapbin 
1e61			;	cp 'b' 
1e61			;	jp z, .fabin 
1e61				; else decimal 
1e61			 
1e61				; TODO do decimal conversion 
1e61				; decimal is stored as a 16bit word 
1e61			 
1e61				; by default everything is a string if type is not detected 
1e61			.fapstr: ; 
1e61 fe 22			cp '"' 
1e63 20 01			jr nz, .strnoqu 
1e65 23				inc hl 
1e66			.strnoqu: 
1e66 c3 3b 1d			jp forth_push_str 
1e69			 
1e69			 
1e69			 
1e69			.fapbin:    ; push a binary string.  
1e69 11 00 00			ld de, 0   ; hold a 16bit value 
1e6c			 
1e6c 23			.fapbinshift:	inc hl  
1e6d 7e				ld a,(hl) 
1e6e fe 00			cp 0     ; done scanning  
1e70 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e72			 
1e72				; left shift de 
1e72 eb				ex de, hl	 
1e73 29				add hl, hl 
1e74			 
1e74				; is 1 
1e74 fe 31			cp '1' 
1e76 20 02			jr nz, .binzero 
1e78 cb 4d			bit 1, l 
1e7a			.binzero: 
1e7a eb				ex de, hl	 ; save current de 
1e7b 18 ef			jr .fapbinshift 
1e7d			 
1e7d			.fapbdone: 
1e7d eb				ex de, hl 
1e7e c3 cd 1c			jp forth_push_numhl 
1e81			 
1e81			 
1e81			.faphex:   ; hex is always stored as a 16bit word 
1e81				; skip number prefix 
1e81 23				inc hl 
1e82				; turn ascii into number 
1e82 cd cf 10			call get_word_hl	; ret 16bit word in hl 
1e85			 
1e85 c3 cd 1c			jp forth_push_numhl 
1e88			 
1e88 00				 nop 
1e89			 
1e89			.fabin:   ; TODO bin conversion 
1e89			 
1e89			 
1e89 c9				ret 
1e8a			 
1e8a			 
1e8a			; get either a string ptr or a 16bit word from the data stack 
1e8a			 
1e8a			FORTH_DSP: macro 
1e8a				call macro_forth_dsp 
1e8a				endm 
1e8a			 
1e8a			macro_forth_dsp: 
1e8a				; data stack pointer points to current word on tos 
1e8a			 
1e8a 2a 87 f9			ld hl,(cli_data_sp) 
1e8d			 
1e8d				if DEBUG_FORTH_PUSH 
1e8d						DMARK "DSP" 
1e8d f5				push af  
1e8e 3a a2 1e			ld a, (.dmark)  
1e91 32 b4 fb			ld (debug_mark),a  
1e94 3a a3 1e			ld a, (.dmark+1)  
1e97 32 b5 fb			ld (debug_mark+1),a  
1e9a 3a a4 1e			ld a, (.dmark+2)  
1e9d 32 b6 fb			ld (debug_mark+2),a  
1ea0 18 03			jr .pastdmark  
1ea2 ..			.dmark: db "DSP"  
1ea5 f1			.pastdmark: pop af  
1ea6			endm  
# End of macro DMARK
1ea6			 
1ea6 cd 04 52				call display_data_sp 
1ea9				;call break_point_state 
1ea9				;rst 030h 
1ea9				CALLMONITOR 
1ea9 cd 3d 17			call break_point_state  
1eac				endm  
# End of macro CALLMONITOR
1eac				endif 
1eac			 
1eac c9				ret 
1ead			 
1ead			; return hl to start of value on stack 
1ead			 
1ead			FORTH_DSP_VALUE: macro 
1ead				call macro_forth_dsp_value 
1ead				endm 
1ead			 
1ead			macro_forth_dsp_value: 
1ead			 
1ead				FORTH_DSP 
1ead cd 8a 1e			call macro_forth_dsp 
1eb0				endm 
# End of macro FORTH_DSP
1eb0			 
1eb0 d5				push de 
1eb1			 
1eb1 23				inc hl ; skip type 
1eb2			 
1eb2 5e				ld e, (hl) 
1eb3 23				inc hl 
1eb4 56				ld d, (hl) 
1eb5 eb				ex de,hl  
1eb6			 
1eb6 d1				pop de 
1eb7			 
1eb7 c9				ret 
1eb8			 
1eb8			; return hl to start of value to second item on stack 
1eb8			 
1eb8			FORTH_DSP_VALUEM1: macro 
1eb8				call macro_forth_dsp_value_m1 
1eb8				endm 
1eb8			 
1eb8			macro_forth_dsp_value_m1: 
1eb8			 
1eb8				FORTH_DSP 
1eb8 cd 8a 1e			call macro_forth_dsp 
1ebb				endm 
# End of macro FORTH_DSP
1ebb			 
1ebb 2b				dec hl 
1ebc 2b				dec hl 
1ebd			;	dec hl 
1ebd			 
1ebd d5				push de 
1ebe			 
1ebe 5e				ld e, (hl) 
1ebf 23				inc hl 
1ec0 56				ld d, (hl) 
1ec1 eb				ex de,hl  
1ec2			 
1ec2 d1				pop de 
1ec3			 
1ec3 c9				ret 
1ec4			 
1ec4				 
1ec4			 
1ec4			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ec4			 
1ec4			FORTH_DSP_POP: macro 
1ec4				call macro_forth_dsp_pop 
1ec4				endm 
1ec4			 
1ec4			 
1ec4			; get the tos data type 
1ec4			 
1ec4			FORTH_DSP_TYPE:   macro 
1ec4			 
1ec4				;FORTH_DSP_VALUE 
1ec4				FORTH_DSP 
1ec4				 
1ec4				; hl points to value 
1ec4				; check type 
1ec4			 
1ec4				ld a,(hl) 
1ec4			 
1ec4				endm 
1ec4			 
1ec4			; load the tos value into hl 
1ec4			 
1ec4			 
1ec4			FORTH_DSP_VALUEHL:  macro 
1ec4				call macro_dsp_valuehl 
1ec4				endm 
1ec4			 
1ec4			 
1ec4			 
1ec4			macro_dsp_valuehl: 
1ec4				FORTH_DSP_VALUE 
1ec4 cd ad 1e			call macro_forth_dsp_value 
1ec7				endm 
# End of macro FORTH_DSP_VALUE
1ec7			 
1ec7				;FORTH_ERR_TOS_NOTNUM 
1ec7			 
1ec7				;inc hl   ; skip type id 
1ec7			 
1ec7			;	push de 
1ec7			; 
1ec7			;	ld e, (hl) 
1ec7			;	inc hl 
1ec7			;	ld d, (hl) 
1ec7			;	ex de,hl  
1ec7			 
1ec7			;	pop de 
1ec7			 
1ec7				if DEBUG_FORTH_PUSH 
1ec7						DMARK "DVL" 
1ec7 f5				push af  
1ec8 3a dc 1e			ld a, (.dmark)  
1ecb 32 b4 fb			ld (debug_mark),a  
1ece 3a dd 1e			ld a, (.dmark+1)  
1ed1 32 b5 fb			ld (debug_mark+1),a  
1ed4 3a de 1e			ld a, (.dmark+2)  
1ed7 32 b6 fb			ld (debug_mark+2),a  
1eda 18 03			jr .pastdmark  
1edc ..			.dmark: db "DVL"  
1edf f1			.pastdmark: pop af  
1ee0			endm  
# End of macro DMARK
1ee0				CALLMONITOR 
1ee0 cd 3d 17			call break_point_state  
1ee3				endm  
# End of macro CALLMONITOR
1ee3				endif 
1ee3 c9				ret 
1ee4			 
1ee4			forth_apushstrhl:      
1ee4				; push of string requires use of cli_origptr 
1ee4				; bodge use 
1ee4			 
1ee4				; get current cli_origptr, save, update with temp pointer  
1ee4 ed 5b a3 f9		ld de, (cli_origptr) 
1ee8 22 a3 f9			ld (cli_origptr), hl 
1eeb d5				push de 
1eec cd 36 1e			call forth_apush 
1eef d1				pop de 
1ef0 ed 53 a3 f9		ld (cli_origptr), de 
1ef4 c9			        ret	 
1ef5			 
1ef5			 
1ef5			; increase loop stack pointer and save hl to it 
1ef5				 
1ef5			FORTH_LOOP_NEXT: macro 
1ef5				call macro_forth_loop_next 
1ef5				;nop 
1ef5				endm 
1ef5			 
1ef5			macro_forth_loop_next: 
1ef5				if DEBUG_FORTH_STACK_GUARD 
1ef5 cd 69 62				call check_stacks 
1ef8				endif 
1ef8 e5				push hl 
1ef9 d5				push de 
1efa eb				ex de,hl 
1efb 2a 89 f9			ld hl,(cli_loop_sp) 
1efe 23				inc hl 
1eff 23				inc hl 
1f00					if DEBUG_FORTH_WORDS 
1f00						DMARK "LNX" 
1f00 f5				push af  
1f01 3a 15 1f			ld a, (.dmark)  
1f04 32 b4 fb			ld (debug_mark),a  
1f07 3a 16 1f			ld a, (.dmark+1)  
1f0a 32 b5 fb			ld (debug_mark+1),a  
1f0d 3a 17 1f			ld a, (.dmark+2)  
1f10 32 b6 fb			ld (debug_mark+2),a  
1f13 18 03			jr .pastdmark  
1f15 ..			.dmark: db "LNX"  
1f18 f1			.pastdmark: pop af  
1f19			endm  
# End of macro DMARK
1f19						CALLMONITOR 
1f19 cd 3d 17			call break_point_state  
1f1c				endm  
# End of macro CALLMONITOR
1f1c					endif 
1f1c 22 89 f9			ld (cli_loop_sp),hl 
1f1f 73				ld (hl), e 
1f20 23				inc hl 
1f21 72				ld (hl), d 
1f22 d1				pop de    ; been reversed so save a swap on restore 
1f23 e1				pop hl 
1f24				if DEBUG_FORTH_STACK_GUARD 
1f24 cd 69 62				call check_stacks 
1f27				endif 
1f27 c9				ret 
1f28			 
1f28			; get current ret stack pointer and save to hl  
1f28				 
1f28			FORTH_LOOP_TOS: macro 
1f28				call macro_forth_loop_tos 
1f28				endm 
1f28			 
1f28			macro_forth_loop_tos: 
1f28 d5				push de 
1f29 2a 89 f9			ld hl,(cli_loop_sp) 
1f2c 5e				ld e, (hl) 
1f2d 23				inc hl 
1f2e 56				ld d, (hl) 
1f2f eb				ex de, hl 
1f30 d1				pop de 
1f31 c9				ret 
1f32			 
1f32			; pop loop stack pointer 
1f32				 
1f32			FORTH_LOOP_POP: macro 
1f32				call macro_forth_loop_pop 
1f32				endm 
1f32			 
1f32			 
1f32			macro_forth_loop_pop: 
1f32				if DEBUG_FORTH_STACK_GUARD 
1f32					DMARK "LPP" 
1f32 f5				push af  
1f33 3a 47 1f			ld a, (.dmark)  
1f36 32 b4 fb			ld (debug_mark),a  
1f39 3a 48 1f			ld a, (.dmark+1)  
1f3c 32 b5 fb			ld (debug_mark+1),a  
1f3f 3a 49 1f			ld a, (.dmark+2)  
1f42 32 b6 fb			ld (debug_mark+2),a  
1f45 18 03			jr .pastdmark  
1f47 ..			.dmark: db "LPP"  
1f4a f1			.pastdmark: pop af  
1f4b			endm  
# End of macro DMARK
1f4b cd 69 62				call check_stacks 
1f4e					FORTH_CHK_LOOP_UNDER 
1f4e e5				push hl 
1f4f d5				push de 
1f50 2a 89 f9			ld hl,(cli_loop_sp) 
1f53 11 03 f7			ld de, cli_loop_stack 
1f56 cd 36 0d			call cmp16 
1f59 da 83 63			jp c, fault_loop_under 
1f5c d1				pop de 
1f5d e1				pop hl 
1f5e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f5e				endif 
1f5e e5				push hl 
1f5f 2a 89 f9			ld hl,(cli_loop_sp) 
1f62 2b				dec hl 
1f63 2b				dec hl 
1f64 22 89 f9			ld (cli_loop_sp), hl 
1f67				; TODO do stack underflow checks 
1f67 e1				pop hl 
1f68				if DEBUG_FORTH_STACK_GUARD 
1f68 cd 69 62				call check_stacks 
1f6b					FORTH_CHK_LOOP_UNDER 
1f6b e5				push hl 
1f6c d5				push de 
1f6d 2a 89 f9			ld hl,(cli_loop_sp) 
1f70 11 03 f7			ld de, cli_loop_stack 
1f73 cd 36 0d			call cmp16 
1f76 da 83 63			jp c, fault_loop_under 
1f79 d1				pop de 
1f7a e1				pop hl 
1f7b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f7b				endif 
1f7b c9				ret 
1f7c			 
1f7c			macro_forth_dsp_pop: 
1f7c			 
1f7c e5				push hl 
1f7d			 
1f7d				; release malloc data 
1f7d			 
1f7d				if DEBUG_FORTH_STACK_GUARD 
1f7d cd 69 62				call check_stacks 
1f80					FORTH_CHK_DSP_UNDER 
1f80 e5				push hl 
1f81 d5				push de 
1f82 2a 87 f9			ld hl,(cli_data_sp) 
1f85 11 01 f5			ld de, cli_data_stack 
1f88 cd 36 0d			call cmp16 
1f8b da 77 63			jp c, fault_dsp_under 
1f8e d1				pop de 
1f8f e1				pop hl 
1f90				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f90				endif 
1f90				;ld hl,(cli_data_sp) 
1f90			if DEBUG_FORTH_DOT 
1f90				DMARK "DPP" 
1f90				CALLMONITOR 
1f90			endif	 
1f90			 
1f90			 
1f90			if FORTH_ENABLE_DSPPOPFREE 
1f90			 
1f90				FORTH_DSP 
1f90 cd 8a 1e			call macro_forth_dsp 
1f93				endm 
# End of macro FORTH_DSP
1f93			 
1f93 7e				ld a, (hl) 
1f94 fe 01			cp DS_TYPE_STR 
1f96 20 07			jr nz, .skippopfree 
1f98			 
1f98				FORTH_DSP_VALUEHL 
1f98 cd c4 1e			call macro_dsp_valuehl 
1f9b				endm 
# End of macro FORTH_DSP_VALUEHL
1f9b 00				nop 
1f9c			if DEBUG_FORTH_DOT 
1f9c				DMARK "DPf" 
1f9c				CALLMONITOR 
1f9c			endif	 
1f9c cd a9 12			call free 
1f9f			.skippopfree: 
1f9f				 
1f9f			 
1f9f			endif 
1f9f			 
1f9f			if DEBUG_FORTH_DOT_KEY 
1f9f				DMARK "DP2" 
1f9f				CALLMONITOR 
1f9f			endif	 
1f9f			 
1f9f				; move pointer down 
1f9f			 
1f9f 2a 87 f9			ld hl,(cli_data_sp) 
1fa2 2b				dec hl 
1fa3 2b				dec hl 
1fa4			; PARSEV5 
1fa4 2b				dec hl 
1fa5 22 87 f9			ld (cli_data_sp), hl 
1fa8			 
1fa8				if DEBUG_FORTH_STACK_GUARD 
1fa8 cd 69 62				call check_stacks 
1fab					FORTH_CHK_DSP_UNDER 
1fab e5				push hl 
1fac d5				push de 
1fad 2a 87 f9			ld hl,(cli_data_sp) 
1fb0 11 01 f5			ld de, cli_data_stack 
1fb3 cd 36 0d			call cmp16 
1fb6 da 77 63			jp c, fault_dsp_under 
1fb9 d1				pop de 
1fba e1				pop hl 
1fbb				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fbb				endif 
1fbb			 
1fbb e1				pop hl 
1fbc			 
1fbc c9				ret 
1fbd			 
1fbd			getwordathl: 
1fbd				; hl points to an address 
1fbd				; load hl with the word at that address 
1fbd			 
1fbd d5				push de 
1fbe			 
1fbe 5e				ld e, (hl) 
1fbf 23				inc hl 
1fc0 56				ld d, (hl) 
1fc1 eb				ex de, hl 
1fc2			 
1fc2 d1				pop de 
1fc3 c9				ret 
1fc4			 
1fc4			 
1fc4			 
1fc4			 
1fc4			 
1fc4			; eof 
1fc4			 
# End of file forth_stackopsv5.asm
1fc4			endif 
1fc4			 
1fc4			user_word_eol:  
1fc4				; hl contains the pointer to where to create a linked list item from the end 
1fc4				; of the user dict to continue on at the system word dict 
1fc4				 
1fc4				; poke the stub of the word list linked list to repoint to rom words 
1fc4			 
1fc4				; stub format 
1fc4				; db   word id 
1fc4				; dw    link to next word 
1fc4			        ; db char length of token 
1fc4				; db string + 0 term 
1fc4				; db exec code....  
1fc4			 
1fc4 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fc6 77				ld (hl), a		; word id 
1fc7 23				inc hl 
1fc8			 
1fc8 11 8e 21			ld de, sysdict 
1fcb 73				ld (hl), e		; next word link ie system dict 
1fcc 23				inc hl 
1fcd 72				ld (hl), d		; next word link ie system dict 
1fce 23				inc hl	 
1fcf			 
1fcf			;	ld (hl), sysdict		; next word link ie system dict 
1fcf			;	inc hl 
1fcf			;	inc hl 
1fcf			 
1fcf			;	inc hl 
1fcf			;	inc hl 
1fcf			 
1fcf 3e 02			ld a, 2			; word length is 0 
1fd1 77				ld (hl), a	 
1fd2 23				inc hl 
1fd3			 
1fd3 3e 7e			ld a, '~'			; word length is 0 
1fd5 77				ld (hl), a	 
1fd6 23				inc hl 
1fd7 3e 00			ld a, 0			; save empty word 
1fd9 77				ld (hl), a 
1fda			 
1fda c9				ret 
1fdb			 
1fdb				 
1fdb			 
1fdb			forthexec_cleanup: 
1fdb				FORTH_RSP_POP 
1fdb cd 95 1c			call macro_forth_rsp_pop 
1fde				endm 
# End of macro FORTH_RSP_POP
1fde c9				ret 
1fdf			 
1fdf			forth_call_hl: 
1fdf				; taking hl 
1fdf e5				push hl 
1fe0 c9				ret 
1fe1			 
1fe1			; this is called to reset Forth system but keep existing uwords etc 
1fe1			 
1fe1			forth_warmstart: 
1fe1				; setup stack over/under flow checks 
1fe1				if DEBUG_FORTH_STACK_GUARD 
1fe1 cd 4f 62				call chk_stk_init 
1fe4				endif 
1fe4			 
1fe4				; init stack pointers  - * these stacks go upwards *  
1fe4 21 05 f9			ld hl, cli_ret_stack 
1fe7 22 8b f9			ld (cli_ret_sp), hl	 
1fea				; set bottom of stack 
1fea 3e 00			ld a,0 
1fec 77				ld (hl),a 
1fed 23				inc hl 
1fee 77				ld (hl),a 
1fef			 
1fef 21 01 f5			ld hl, cli_data_stack 
1ff2 22 87 f9			ld (cli_data_sp), hl	 
1ff5				; set bottom of stack 
1ff5 3e 00			ld a,0 
1ff7 77				ld (hl),a 
1ff8 23				inc hl 
1ff9 77				ld (hl),a 
1ffa			 
1ffa 21 03 f7			ld hl, cli_loop_stack 
1ffd 22 89 f9			ld (cli_loop_sp), hl	 
2000				; set bottom of stack 
2000 3e 00			ld a,0 
2002 77				ld (hl),a 
2003 23				inc hl 
2004 77				ld (hl),a 
2005			 
2005				; init extent of current open file 
2005			 
2005 3e 00			ld a, 0 
2007 32 d6 f9			ld (store_openext), a 
200a			 
200a c9				ret 
200b			 
200b			 
200b			; Cold Start - this is called to setup the whole Forth system 
200b			 
200b			forth_init: 
200b			 
200b				; setup stack over/under flow checks 
200b			 
200b			;	if DEBUG_FORTH_STACK_GUARD 
200b			;		call chk_stk_init 
200b			;	endif 
200b			 
200b				; enable auto display updates (slow.....) 
200b			 
200b 3e 01			ld a, 1 
200d 32 a1 f9			ld (cli_autodisplay), a 
2010			 
2010			 
2010			 
2010				; show start up screen 
2010			 
2010 cd e4 0a			call clear_display 
2013			 
2013 3e 00			ld a,0 
2015 32 c3 f9			ld (f_cursor_ptr), a 
2018			 
2018				; set start of word list in start of ram - for use when creating user words 
2018			 
2018 21 00 80			ld hl, baseram 
201b 22 97 f2			ld (os_last_new_uword), hl 
201e cd c4 1f			call user_word_eol 
2021				 
2021			;		call display_data_sp 
2021			;		call next_page_prompt 
2021			 
2021			 
2021			 
2021			 
2021 c9				ret 
2022			 
2022 .. 00		.bootforth: db " Forth Kernel Init ",0 
2036			 
2036			; TODO push to stack 
2036			 
2036			;  
2036			 
2036			if FORTH_PARSEV2 
2036			 
2036			 
2036				include "forth_parserv2.asm" 
2036			 
2036			endif 
2036			 
2036			 
2036			; parse cli version 1 
2036			 
2036			if FORTH_PARSEV1 
2036			 
2036			 
2036			 
2036			      include "forth_parserv1.asm" 
2036			endif 
2036				 
2036			if FORTH_PARSEV3 
2036			 
2036			 
2036			 
2036			      include "forth_parserv3.asm" 
2036				include "forth_wordsv3.asm" 
2036			endif 
2036			 
2036			if FORTH_PARSEV4 
2036			 
2036			 
2036			 
2036			      include "forth_parserv4.asm" 
2036				include "forth_wordsv4.asm" 
2036			endif 
2036			 
2036			if FORTH_PARSEV5 
2036			 
2036			 
2036			 
2036			      include "forth_parserv5.asm" 
2036			 
2036			 
2036			; A better parser without using malloc and string copies all over the place.  
2036			; Exec in situ should be faster 
2036			 
2036			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2036			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2036			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2036			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2036			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2036			WORD_SYS_END: equ 0   ; Opcode for all user words 
2036			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2036			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2036			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2036			 
2036			; Core word preamble macro 
2036			 
2036			CWHEAD:   macro nxtword opcode lit len opflags 
2036				db WORD_SYS_CORE+opcode             
2036				; internal op code number 
2036				dw nxtword            
2036				; link to next dict word block 
2036				db len + 1 
2036				; literal length of dict word inc zero term 
2036				db lit,0              
2036				; literal dict word 
2036			        ; TODO db opflags        
2036				endm 
2036			 
2036			 
2036			NEXTW: macro  
2036				jp macro_next 
2036				endm 
2036			 
2036			macro_next: 
2036			if DEBUG_FORTH_PARSE_KEY 
2036				DMARK "NXT" 
2036				CALLMONITOR 
2036			endif	 
2036			;	inc hl  ; skip token null term  
2036 ed 4b a5 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
203a ed 5b a3 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
203e 2a 9b f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2041			if DEBUG_FORTH_PARSE_KEY 
2041				DMARK "}AA" 
2041				CALLMONITOR 
2041			endif	 
2041 c3 44 21			jp execnext 
2044				;jp exec1 
2044			       
2044			 
2044			 
2044			; Another go at the parser to compile  
2044			 
2044			 
2044			; TODO rework parser to change all of the string words to byte tokens 
2044			; TODO do a search for  
2044			 
2044			; TODO first run normal parser to zero term sections 
2044			; TODO for each word do a token look up to get the op code 
2044			; TODO need some means to flag to the exec that this is a byte code form    
2044			 
2044			 
2044			forthcompile: 
2044			 
2044			; 
2044			; line parse: 
2044			;       parse raw input buffer 
2044			;       tokenise the words 
2044			;       malloc new copy (for looping etc) 
2044			;       copy to malloc + current pc in line to start of string and add line term 
2044			;       save on new rsp 
2044			; 
2044			 
2044			; hl to point to the line to tokenise 
2044			 
2044			;	push hl 
2044 22 9b f2			ld (os_tok_ptr), hl  ; save ptr to string 
2047			 
2047			;	ld a,0		; string term on input 
2047			;	call strlent 
2047			 
2047			;	ld (os_tok_len), hl	 ; save string length 
2047			 
2047			;if DEBUG_FORTH_TOK 
2047			;	ex de,hl		 
2047			;endif 
2047			 
2047			;	pop hl 		; get back string pointer 
2047			 
2047			if DEBUG_FORTH_TOK 
2047						DMARK "TOc" 
2047				CALLMONITOR 
2047			endif 
2047 7e			.cptoken2:    ld a,(hl) 
2048 23				inc hl 
2049 fe 7f			cp FORTH_END_BUFFER 
204b 28 29			jr z, .cptokendone2 
204d fe 00			cp 0 
204f 28 25			jr z, .cptokendone2 
2051 fe 22			cp '"' 
2053 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2055 fe 20			cp ' ' 
2057 20 ee			jr nz,  .cptoken2 
2059			 
2059			; TODO consume comments held between ( and ) 
2059			 
2059				; we have a space so change to zero term for dict match later 
2059 2b				dec hl 
205a 3e 00			ld a,0 
205c 77				ld (hl), a 
205d 23				inc hl 
205e 18 e7			jr .cptoken2 
2060				 
2060			 
2060			.cptokenstr2: 
2060				; skip all white space until either eol (because forgot to term) or end double quote 
2060			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2060				;inc hl ; skip current double quote 
2060 7e				ld a,(hl) 
2061 23				inc hl 
2062 fe 22			cp '"' 
2064 28 e1			jr z, .cptoken2 
2066 fe 7f			cp FORTH_END_BUFFER 
2068 28 0c			jr z, .cptokendone2 
206a fe 00			cp 0 
206c 28 08			jr z, .cptokendone2 
206e fe 20			cp ' ' 
2070 28 02			jr z, .cptmp2 
2072 18 ec			jr .cptokenstr2 
2074			 
2074			.cptmp2:	; we have a space so change to zero term for dict match later 
2074				;dec hl 
2074				;ld a,"-"	; TODO remove this when working 
2074				;ld (hl), a 
2074				;inc hl 
2074 18 ea			jr .cptokenstr2 
2076			 
2076			.cptokendone2: 
2076				;inc hl 
2076 3e 7f			ld a, FORTH_END_BUFFER 
2078 77				ld (hl),a 
2079 23				inc hl 
207a 3e 21			ld a, '!' 
207c 77				ld (hl),a 
207d			 
207d 2a 9b f2			ld hl,(os_tok_ptr) 
2080			         
2080			if DEBUG_FORTH_TOK 
2080						DMARK "Tc1" 
2080				CALLMONITOR 
2080			endif 
2080			 
2080				; push exec string to top of return stack 
2080				FORTH_RSP_NEXT 
2080 cd 74 1c			call macro_forth_rsp_next 
2083				endm 
# End of macro FORTH_RSP_NEXT
2083 c9				ret 
2084			 
2084			; Another go at the parser need to simplify the process 
2084			 
2084			forthparse: 
2084			 
2084			; 
2084			; line parse: 
2084			;       parse raw input buffer 
2084			;       tokenise the words 
2084			;       malloc new copy (for looping etc) 
2084			;       copy to malloc + current pc in line to start of string and add line term 
2084			;       save on new rsp 
2084			; 
2084			 
2084			; hl to point to the line to tokenise 
2084			 
2084			;	push hl 
2084 22 9b f2			ld (os_tok_ptr), hl  ; save ptr to string 
2087			 
2087			;	ld a,0		; string term on input 
2087			;	call strlent 
2087			 
2087			;	ld (os_tok_len), hl	 ; save string length 
2087			 
2087			;if DEBUG_FORTH_TOK 
2087			;	ex de,hl		 
2087			;endif 
2087			 
2087			;	pop hl 		; get back string pointer 
2087			 
2087			if DEBUG_FORTH_TOK 
2087						DMARK "TOK" 
2087				CALLMONITOR 
2087			endif 
2087 7e			.ptoken2:    ld a,(hl) 
2088 23				inc hl 
2089 fe 7f			cp FORTH_END_BUFFER 
208b 28 29			jr z, .ptokendone2 
208d fe 00			cp 0 
208f 28 25			jr z, .ptokendone2 
2091 fe 22			cp '"' 
2093 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2095 fe 20			cp ' ' 
2097 20 ee			jr nz,  .ptoken2 
2099			 
2099			; TODO consume comments held between ( and ) 
2099			 
2099				; we have a space so change to zero term for dict match later 
2099 2b				dec hl 
209a 3e 00			ld a,0 
209c 77				ld (hl), a 
209d 23				inc hl 
209e 18 e7			jr .ptoken2 
20a0				 
20a0			 
20a0			.ptokenstr2: 
20a0				; skip all white space until either eol (because forgot to term) or end double quote 
20a0			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20a0				;inc hl ; skip current double quote 
20a0 7e				ld a,(hl) 
20a1 23				inc hl 
20a2 fe 22			cp '"' 
20a4 28 e1			jr z, .ptoken2 
20a6 fe 7f			cp FORTH_END_BUFFER 
20a8 28 0c			jr z, .ptokendone2 
20aa fe 00			cp 0 
20ac 28 08			jr z, .ptokendone2 
20ae fe 20			cp ' ' 
20b0 28 02			jr z, .ptmp2 
20b2 18 ec			jr .ptokenstr2 
20b4			 
20b4			.ptmp2:	; we have a space so change to zero term for dict match later 
20b4				;dec hl 
20b4				;ld a,"-"	; TODO remove this when working 
20b4				;ld (hl), a 
20b4				;inc hl 
20b4 18 ea			jr .ptokenstr2 
20b6			 
20b6			.ptokendone2: 
20b6				;inc hl 
20b6 3e 7f			ld a, FORTH_END_BUFFER 
20b8 77				ld (hl),a 
20b9 23				inc hl 
20ba 3e 21			ld a, '!' 
20bc 77				ld (hl),a 
20bd			 
20bd 2a 9b f2			ld hl,(os_tok_ptr) 
20c0			         
20c0			if DEBUG_FORTH_TOK 
20c0						DMARK "TK1" 
20c0				CALLMONITOR 
20c0			endif 
20c0			 
20c0				; push exec string to top of return stack 
20c0				FORTH_RSP_NEXT 
20c0 cd 74 1c			call macro_forth_rsp_next 
20c3				endm 
# End of macro FORTH_RSP_NEXT
20c3 c9				ret 
20c4			 
20c4			; 
20c4			;	; malloc size + buffer pointer + if is loop flag 
20c4			;	ld hl,(os_tok_len) 		 ; get string length 
20c4			; 
20c4			;	ld a,l 
20c4			; 
20c4			;	cp 0			; we dont want to use a null string 
20c4			;	ret z 
20c4			; 
20c4			;;	add 3    ; prefix malloc with buffer for current word ptr 
20c4			; 
20c4			;	add 5     ; TODO when certain not over writing memory remove 
20c4			; 
20c4			;		 
20c4			; 
20c4			;if DEBUG_FORTH_TOK 
20c4			;			DMARK "TKE" 
20c4			;	CALLMONITOR 
20c4			;endif 
20c4			; 
20c4			;	ld l,a 
20c4			;	ld h,0 
20c4			;;	push hl   ; save required space for the copy later 
20c4			;	call malloc 
20c4			;if DEBUG_FORTH_TOK 
20c4			;			DMARK "TKM" 
20c4			;	CALLMONITOR 
20c4			;endif 
20c4			;	if DEBUG_FORTH_MALLOC_GUARD 
20c4			;		push af 
20c4			;		call ishlzero 
20c4			;;		ld a, l 
20c4			;;		add h 
20c4			;;		cp 0 
20c4			;		pop af 
20c4			;		 
20c4			;		call z,malloc_error 
20c4			;	endif 
20c4			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20c4			; 
20c4			; 
20c4			;if DEBUG_FORTH_TOK 
20c4			;			DMARK "TKR" 
20c4			;	CALLMONITOR 
20c4			;endif 
20c4			; 
20c4			;	FORTH_RSP_NEXT 
20c4			; 
20c4			;	;inc hl	 ; go past current buffer pointer 
20c4			;	;inc hl 
20c4			;	;inc hl   ; and past if loop flag 
20c4			;		; TODO Need to set flag  
20c4			; 
20c4			;	 
20c4			;	 
20c4			;	ex de,hl	; malloc is dest 
20c4			;	ld hl, (os_tok_len) 
20c4			;;	pop bc 
20c4			;	ld c, l                
20c4			;	ld b,0 
20c4			;	ld hl, (os_tok_ptr) 
20c4			; 
20c4			;if DEBUG_FORTH_TOK 
20c4			;			DMARK "TKT" 
20c4			;	CALLMONITOR 
20c4			;endif 
20c4			; 
20c4			;	; do str cpy 
20c4			; 
20c4			;	ldir      ; copy byte in hl to de 
20c4			; 
20c4			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20c4			; 
20c4			;if DEBUG_FORTH_TOK 
20c4			; 
20c4			;			DMARK "TKY" 
20c4			;	CALLMONITOR 
20c4			;endif 
20c4			;	;ld a,0 
20c4			;	;ld a,FORTH_END_BUFFER 
20c4			;	ex de, hl 
20c4			;	;dec hl			 ; go back over the space delim at the end of word 
20c4			;	;ld (hl),a 
20c4			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20c4			;	ld a,FORTH_END_BUFFER 
20c4			;	ld (hl),a 
20c4			;	inc hl 
20c4			;	ld a,FORTH_END_BUFFER 
20c4			;	ld (hl),a 
20c4			; 
20c4			;	; init the malloc area data 
20c4			;	; set pc for in current area 
20c4			;	;ld hl, (os_tok_malloc) 
20c4			;	;inc hl 
20c4			;	;inc hl 
20c4			;	;inc hl 
20c4			;	;ex de,hl 
20c4			;	;ld hl, (os_tok_malloc) 
20c4			;	;ld (hl),e 
20c4			;	;inc hl 
20c4			;	;ld (hl),d 
20c4			; 
20c4			; 
20c4			;	ld hl,(os_tok_malloc) 
20c4			;if DEBUG_FORTH_PARSE_KEY 
20c4			;			DMARK "TKU" 
20c4			;	CALLMONITOR 
20c4			;endif 
20c4			; 
20c4			;	ret 
20c4			 
20c4			forthexec: 
20c4			 
20c4			; line exec: 
20c4			; forth parser 
20c4			 
20c4			; 
20c4			;       get current exec line on rsp 
20c4			 
20c4				FORTH_RSP_TOS 
20c4 cd 8b 1c			call macro_forth_rsp_tos 
20c7				endm 
# End of macro FORTH_RSP_TOS
20c7			 
20c7			;       restore current pc - hl points to malloc of data 
20c7			 
20c7				;ld e, (hl) 
20c7				;inc hl 
20c7				;ld d, (hl) 
20c7				;ex de,hl 
20c7			 
20c7			 
20c7			exec1: 
20c7 22 9b f2			ld (os_tok_ptr), hl 
20ca			 
20ca				; copy our PC to working vars  
20ca 22 a5 f9			ld (cli_ptr), hl 
20cd 22 a3 f9			ld (cli_origptr), hl 
20d0			 
20d0 7e				ld a,(hl) 
20d1 fe 7f			cp FORTH_END_BUFFER 
20d3 c8				ret z 
20d4			 
20d4				; skip any nulls 
20d4			 
20d4 fe 00			cp 0 
20d6 20 03			jr nz, .execword 
20d8 23				inc hl 
20d9 18 ec			jr exec1 
20db			 
20db			 
20db			.execword: 
20db			 
20db			 
20db			 
20db			if DEBUG_FORTH_PARSE_KEY 
20db						DMARK "KYQ" 
20db				CALLMONITOR 
20db			endif 
20db			;       while at start of word: 
20db			; get start of dict (in user area first) 
20db			 
20db 21 00 80		ld hl, baseram 
20de			;ld hl, sysdict 
20de 22 a7 f9		ld (cli_nextword),hl 
20e1			;           match word at pc 
20e1			;           exec word 
20e1			;           or push to dsp 
20e1			;           forward to next token 
20e1			;           if line term pop rsp and exit 
20e1			;        
20e1			 
20e1			if DEBUG_FORTH_PARSE_KEY 
20e1						DMARK "KYq" 
20e1				CALLMONITOR 
20e1			endif 
20e1			 
20e1			; 
20e1			; word comp 
20e1			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20e1			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20e1			;    move to start of word  
20e1			;    compare word to cli_token 
20e1			 
20e1			.execpnword:	; HL at start of a word in the dictionary to check 
20e1			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20e1			;	ld (cli_ptr), hl 
20e1			 
20e1 2a a7 f9			ld hl,(cli_nextword) 
20e4			 
20e4 cd 87 21			call forth_tok_next 
20e7			; tok next start here 
20e7			;	; TODO skip compiled symbol for now 
20e7			;	inc hl 
20e7			; 
20e7			;	; save pointer to next word 
20e7			; 
20e7			;	; hl now points to the address of the next word pointer  
20e7			;	ld e, (hl) 
20e7			;	inc hl 
20e7			;	ld d, (hl) 
20e7			;	inc l 
20e7			; 
20e7			;	ex de,hl 
20e7			;if DEBUG_FORTH_PARSE_NEXTWORD 
20e7			;	push bc 
20e7			;	ld bc, (cli_nextword) 
20e7			;			DMARK "NXW" 
20e7			;	CALLMONITOR 
20e7			;	pop bc 
20e7			;endif 
20e7			; tok next end here 
20e7 22 a7 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
20ea eb				ex de, hl 
20eb			 
20eb			 
20eb				; save the pointer of the current token - 1 to check against 
20eb				 
20eb 22 ab f9			ld (cli_token), hl   
20ee				; TODO maybe remove below save if no debug 
20ee				; save token string ptr for any debug later 
20ee 23				inc hl  
20ef 22 ad f9			ld (cli_origtoken), hl 
20f2 2b				dec hl 
20f3				; save pointer to the start of the next dictionay word 
20f3 7e				ld a,(hl)   ; get string length 
20f4 47				ld b,a 
20f5			.execpnwordinc:  
20f5 23				inc hl 
20f6 10 fd			djnz .execpnwordinc 
20f8 22 a9 f9			ld (cli_execword), hl      ; save start of this words code 
20fb			 
20fb				; now check the word token against the string being parsed 
20fb			 
20fb 2a ab f9			ld hl,(cli_token) 
20fe 23				inc hl     ; skip string length (use zero term instead to end) 
20ff 22 ab f9			ld (cli_token), hl 
2102			 
2102			if DEBUG_FORTH_PARSE_KEY 
2102						DMARK "KY2" 
2102			endif 
2102			if DEBUG_FORTH_PARSE_EXEC 
2102				; see if disabled 
2102			 
2102				ld a, (os_view_disable) 
2102				cp '*' 
2102				jr z, .skip 
2102			 
2102				push hl 
2102				push hl 
2102				call clear_display 
2102				ld de, .compword 
2102				ld a, display_row_1 
2102				call str_at_display 
2102				pop de 
2102				ld a, display_row_2 
2102				call str_at_display 
2102				ld hl,(cli_ptr) 
2102				ld a,(hl) 
2102			        ld hl, os_word_scratch 
2102				ld (hl),a 
2102				ld a,0 
2102				inc hl 
2102				ld (hl),a 	 
2102				ld de, os_word_scratch 
2102				ld a, display_row_2+10 
2102				call str_at_display 
2102				call update_display 
2102				ld a, 100 
2102				call aDelayInMS 
2102				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2102				call delay250ms 
2102				endif 
2102				pop hl 
2102			.skip:  
2102			endif	 
2102			.execpnchar:    ; compare char between token and string to parse 
2102			 
2102			if DEBUG_FORTH_PARSE_KEY 
2102						DMARK "Ky3" 
2102			endif 
2102			if DEBUG_FORTH_PARSE_EXEC 
2102				; see if disabled 
2102			 
2102				ld a, (os_view_disable) 
2102				cp '*' 
2102				jr z, .skip2 
2102			 
2102			;	call clear_display 
2102			ld hl,(cli_token) 
2102			ld a,(hl) 
2102			ld (os_word_scratch),a 
2102				ld hl,(cli_ptr) 
2102			ld a,(hl) 
2102				ld (os_word_scratch+1),a 
2102				ld a,0 
2102				ld (os_word_scratch+2),a 
2102				ld de,os_word_scratch 
2102				ld a,display_row_4 
2102				call str_at_display 
2102				call update_display 
2102			.skip2:  
2102			endif 
2102 2a ab f9			ld hl,(cli_token) 
2105 7e				ld a, (hl)	 ; char in word token 
2106 23				inc hl 		; move to next char 
2107 22 ab f9			ld (cli_token), hl ; and save it 
210a 47				ld b,a 
210b			 
210b 2a a5 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
210e 7e				ld a,(hl) 
210f 23				inc hl 
2110 22 a5 f9			ld (cli_ptr), hl		; move to next char 
2113 cd 6d 11			call toUpper 		; make sure the input string matches case 
2116			 
2116			if DEBUG_FORTH_PARSE 
2116			endif 
2116			 
2116				; input stream end of token is a space so get rid of it 
2116			 
2116			;	cp ' ' 
2116			;	jr nz, .pnskipspace 
2116			; 
2116			;	ld a, 0		; make same term as word token term 
2116			; 
2116			;.pnskipspace: 
2116			 
2116			if DEBUG_FORTH_PARSE_KEY 
2116						DMARK "KY7" 
2116			endif 
2116 b8				cp b 
2117 c2 2d 21			jp nz, .execpnskipword	 ; no match so move to next word 
211a				 
211a			;    if same 
211a			;       scan for string terms 0 for token and 32 for input 
211a			 
211a				 
211a			if DEBUG_FORTH_PARSE_KEY 
211a						DMARK "KY8" 
211a			endif 
211a			 
211a 80				add b			 
211b fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
211d							; TODO need to make sure last word in zero term string is accounted for 
211d 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
211f			 
211f			 
211f				; at end of both strings so both are exact match 
211f			 
211f			;       skip ptr for next word 
211f			 
211f 2a a5 f9			ld hl,(cli_ptr) 	; at input string term 
2122 23				inc hl			 ; at next char 
2123 22 a5 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2126 22 a3 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2129				 
2129				 
2129			if DEBUG_FORTH_PARSE_KEY 
2129						DMARK "KY3" 
2129			endif 
2129			 
2129			 
2129			 
2129			;       exec code block 
2129			if DEBUG_FORTH_JP 
2129				call clear_display 
2129				call update_display 
2129				call delay1s 
2129				ld hl, (cli_execword)     ; save for next check if no match on this word 
2129				ld a,h 
2129				ld hl, os_word_scratch 
2129				call hexout 
2129				ld hl, (cli_execword)     ; save for next check if no match on this word 
2129				ld a,l 
2129				ld hl, os_word_scratch+2 
2129				call hexout 
2129				ld hl, os_word_scratch+4 
2129				ld a,0 
2129				ld (hl),a 
2129				ld de,os_word_scratch 
2129				call str_at_display 
2129					ld a, display_row_2 
2129					call str_at_display 
2129				ld de, (cli_origtoken) 
2129				ld a, display_row_1+10 
2129					call str_at_display 
2129			 
2129				ld a,display_row_1 
2129				ld de, .foundword 
2129				ld a, display_row_3 
2129				call str_at_display 
2129				call update_display 
2129				call delay1s 
2129				call delay1s 
2129				call delay1s 
2129			endif 
2129			 
2129			if DEBUG_FORTH_PARSE_KEY 
2129						DMARK "KYj" 
2129			endif 
2129				; TODO save the word pointer in this exec 
2129			 
2129 2a a9 f9			ld hl,(cli_execword) 
212c e9				jp (hl) 
212d			 
212d			 
212d			;    if not same 
212d			;	scan for zero term 
212d			;	get ptr for next word 
212d			;	goto word comp 
212d			 
212d			.execpnskipword:	; get pointer to next word 
212d 2a a7 f9			ld hl,(cli_nextword) 
2130			 
2130 7e				ld a,(hl) 
2131 fe 00			cp WORD_SYS_END 
2133			;	cp 0 
2133 28 09			jr z, .execendofdict			 ; at end of words 
2135			 
2135			if DEBUG_FORTH_PARSE_KEY 
2135						DMARK "KY4" 
2135			endif 
2135			if DEBUG_FORTH_PARSE_EXEC 
2135			 
2135				; see if disabled 
2135			 
2135				ld a, (os_view_disable) 
2135				cp '*' 
2135				jr z, .noskip 
2135			 
2135			 
2135				ld de, .nowordfound 
2135				ld a, display_row_3 
2135				call str_at_display 
2135				call update_display 
2135				ld a, 100 
2135				call aDelayInMS 
2135				 
2135				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2135					call delay250ms 
2135				endif 
2135			.noskip:  
2135			 
2135			endif	 
2135			 
2135 2a a3 f9			ld hl,(cli_origptr) 
2138 22 a5 f9			ld (cli_ptr),hl 
213b			 
213b			if DEBUG_FORTH_PARSE_KEY 
213b						DMARK "KY5" 
213b			endif 
213b c3 e1 20			jp .execpnword			; else go to next word 
213e			 
213e			.execendofdict:  
213e			 
213e			if DEBUG_FORTH_PARSE_KEY 
213e						DMARK "KYe" 
213e			endif 
213e			if DEBUG_FORTH_PARSE_EXEC 
213e				; see if disabled 
213e			 
213e				ld a, (os_view_disable) 
213e				cp '*' 
213e				jr z, .ispskip 
213e			 
213e				call clear_display 
213e				call update_display 
213e				call delay1s 
213e				ld de, (cli_origptr) 
213e				ld a, display_row_1 
213e				call str_at_display 
213e				 
213e				ld de, .enddict 
213e				ld a, display_row_3 
213e				call str_at_display 
213e				call update_display 
213e				ld a, 100 
213e				call aDelayInMS 
213e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
213e				call delay1s 
213e				call delay1s 
213e				call delay1s 
213e				endif 
213e			.ispskip:  
213e				 
213e			endif	 
213e			 
213e			 
213e			 
213e				; if the word is not a keyword then must be a literal so push it to stack 
213e			 
213e			; push token to stack to end of word 
213e			 
213e				STACKFRAME ON $1efe $2f9f 
213e				if DEBUG_STACK_IMB 
213e					if ON 
213e						exx 
213e						ld de, $1efe 
213e						ld a, d 
213e						ld hl, curframe 
213e						call hexout 
213e						ld a, e 
213e						ld hl, curframe+2 
213e						call hexout 
213e						ld hl, $1efe 
213e						push hl 
213e						ld hl, $2f9f 
213e						push hl 
213e						exx 
213e					endif 
213e				endif 
213e			endm 
# End of macro STACKFRAME
213e			 
213e 2a 9b f2		ld hl,(os_tok_ptr) 
2141 cd 36 1e		call forth_apush 
2144			 
2144				STACKFRAMECHK ON $1efe $2f9f 
2144				if DEBUG_STACK_IMB 
2144					if ON 
2144						exx 
2144						ld hl, $2f9f 
2144						pop de   ; $2f9f 
2144						call cmp16 
2144						jr nz, .spnosame 
2144						ld hl, $1efe 
2144						pop de   ; $1efe 
2144						call cmp16 
2144						jr z, .spfrsame 
2144						.spnosame: call showsperror 
2144						.spfrsame: nop 
2144						exx 
2144					endif 
2144				endif 
2144			endm 
# End of macro STACKFRAMECHK
2144			 
2144			execnext: 
2144			 
2144			if DEBUG_FORTH_PARSE_KEY 
2144						DMARK "KY>" 
2144			endif 
2144			; move past token to next word 
2144			 
2144 2a 9b f2		ld hl, (os_tok_ptr) 
2147 3e 00		ld a, 0 
2149 01 ff 00		ld bc, 255     ; input buffer size 
214c ed b1		cpir 
214e			 
214e			if DEBUG_FORTH_PARSE_KEY 
214e						DMARK "KY!" 
214e				CALLMONITOR 
214e			endif	 
214e			; TODO this might place hl on the null, so will need to forward on??? 
214e			;inc hl   ; see if this gets onto the next item 
214e			 
214e			 
214e			; TODO pass a pointer to the buffer to push 
214e			; TODO call function to push 
214e			 
214e			; look for end of input 
214e			 
214e			;inc hl 
214e			;ld a,(hl) 
214e			;cp FORTH_END_BUFFER 
214e			;ret z 
214e			 
214e			 
214e c3 c7 20		jp exec1 
2151			 
2151			 
2151			 
2151			 
2151			 
2151			 
2151			 
2151			 
2151			 
2151			findnexttok: 
2151			 
2151				; hl is pointer to move 
2151				; de is the token to locate 
2151			 
2151					if DEBUG_FORTH 
2151						DMARK "NTK" 
2151						CALLMONITOR 
2151					endif 
2151 d5				push de 
2152			 
2152			.fnt1:	 
2152				; find first char of token to locate 
2152			 
2152 1a				ld a, (de) 
2153 4f				ld c,a 
2154 7e				ld a,(hl) 
2155 cd 6d 11			call toUpper 
2158					if DEBUG_FORTH 
2158						DMARK "NT1" 
2158						CALLMONITOR 
2158					endif 
2158 b9				cp c 
2159			 
2159 28 03			jr z, .fnt2cmpmorefirst	 
215b			 
215b				; first char not found move to next char 
215b			 
215b 23				inc hl 
215c 18 f4			jr .fnt1 
215e			 
215e			.fnt2cmpmorefirst:	 
215e				; first char of token found.  
215e			 
215e e5				push hl     ; save start of token just in case it is the right one 
215f d9				exx 
2160 e1				pop hl        ; save it to hl' 
2161 d9				exx 
2162			 
2162			 
2162			.fnt2cmpmore:	 
2162				; compare the rest 
2162				 
2162 23				inc hl 
2163 13				inc de 
2164				 
2164 1a				ld a, (de) 
2165 4f				ld c,a 
2166 7e				ld a,(hl) 
2167 cd 6d 11			call toUpper 
216a			 
216a					if DEBUG_FORTH 
216a						DMARK "NT2" 
216a						CALLMONITOR 
216a					endif 
216a				; c has the token to find char 
216a				; a has the mem to scan char 
216a			 
216a b9				cp c 
216b 28 04			jr z,.fntmatch1 
216d			 
216d				; they are not the same 
216d			 
216d					if DEBUG_FORTH 
216d						DMARK "NT3" 
216d						CALLMONITOR 
216d					endif 
216d d1				pop de	; reset de token to look for 
216e d5				push de 
216f 18 e1			jr .fnt1 
2171				 
2171			.fntmatch1: 
2171			 
2171				; is the same char a null which means we might have a full hit? 
2171					if DEBUG_FORTH 
2171						DMARK "NT4" 
2171						CALLMONITOR 
2171					endif 
2171			 
2171 fe 00			cp 0 
2173 28 0b			jr z, .fntmatchyes 
2175			 
2175				; are we at the end of the token to find? 
2175			 
2175					if DEBUG_FORTH 
2175						DMARK "NT5" 
2175						CALLMONITOR 
2175					endif 
2175 3e 00			ld a, 0 
2177 b9				cp c 
2178			 
2178 c2 62 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
217b			 
217b					if DEBUG_FORTH 
217b						DMARK "NT6" 
217b						CALLMONITOR 
217b					endif 
217b				; token to find is exhusted but no match to stream 
217b			 
217b				; restore tok pointer and continue on 
217b d1				pop de 
217c d5				push de 
217d c3 52 21			jp .fnt1 
2180			 
2180			 
2180			.fntmatchyes: 
2180			 
2180				; hl now contains the end of the found token 
2180			 
2180				; get rid of saved token pointer to find 
2180			 
2180 d1				pop de 
2181			 
2181					if DEBUG_FORTH 
2181						DMARK "NT9" 
2181						CALLMONITOR 
2181					endif 
2181			 
2181				; hl will be on the null term so forward on 
2181			 
2181				; get back the saved start of the token 
2181			 
2181 d9				exx 
2182 e5				push hl     ; save start of token just in case it is the right one 
2183 d9				exx 
2184 e1				pop hl        ; save it to hl 
2185			 
2185 c9				ret 
2186			 
2186			 
2186			; LIST needs to find a specific token   
2186			; FORGET needs to find a spefici token 
2186			 
2186			; SAVE needs to find all tokens by flag 
2186			; WORDS just needs to scan through all  by flag 
2186			; UWORDS needs to scan through all by flag 
2186			 
2186			 
2186			; given hl as pointer to start of dict look up string 
2186			; return hl as pointer to start of word block 
2186			; or 0 if not found 
2186			 
2186			forth_find_tok: 
2186 c9				ret 
2187			 
2187			; given hl as pointer to dict structure 
2187			; move to the next dict block structure 
2187			 
2187			forth_tok_next: 
2187				; hl now points to the address of the next word pointer  
2187				; TODO skip compiled symbol for now 
2187			;	push de 
2187 23				inc hl 
2188 5e				ld e, (hl) 
2189 23				inc hl 
218a 56				ld d, (hl) 
218b 23				inc hl 
218c			 
218c eb				ex de,hl 
218d			if DEBUG_FORTH_PARSE_NEXTWORD 
218d				push bc 
218d				ld bc, (cli_nextword) 
218d						DMARK "NXW" 
218d				CALLMONITOR 
218d				pop bc 
218d			endif 
218d			;	pop de	 
218d c9				ret 
218e			 
218e			 
218e			 
218e			; eof 
# End of file forth_parserv5.asm
218e				include "forth_wordsv4.asm" 
218e			 
218e			; the core word dictionary v4 
218e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
218e			 
218e			; this is a linked list for each of the system words used 
218e			; user defined words will follow the same format but will be in ram 
218e			 
218e			 
218e			; 
218e			; 
218e			; define linked list: 
218e			; 
218e			; 1. compiled byte op code 
218e			; 2. len of text word 
218e			; 3. text word 
218e			; 4. ptr to next dictionary word 
218e			; 5. asm, calls etc for the word 
218e			; 
218e			;  if 1 == 0 then last word in dict  
218e			;   
218e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
218e			;  
218e			;  
218e			; create basic standard set of words 
218e			; 
218e			;  
218e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
218e			; 2DUP 2DROP 2SWAP  
218e			; @ C@ - get byte  
218e			; ! C! - store byte 
218e			; 0< true if less than zero 
218e			; 0= true if zero 
218e			; < >  
218e			; = true if same 
218e			; variables 
218e			 
218e			 
218e			; Hardware specific words I may need 
218e			; 
218e			; IN OUT  
218e			; calls to key util functions 
218e			; calls to hardward abstraction stuff 
218e			; easy control of frame buffers and lcd i/o 
218e			; keyboard  
218e			 
218e			 
218e			;DICT: macro 
218e			; op_code, len, word, next 
218e			;    word: 
218e			;    db op_code 
218e			;    ds word zero term 
218e			;    dw next 
218e			;    endm 
218e			 
218e			 
218e			 
218e			 
218e			; op code 1 is a flag for user define words which are to be handled differently 
218e			 
218e			 
218e			; 
218e			; 
218e			;    TODO on entry to a word this should be the expected environment 
218e			;    hl - tos value if number then held, if string this is the ptr 
218e			;    de -  
218e			 
218e			 
218e			; opcode ranges 
218e			; 0 - end of word dict 
218e			; 255 - user define words 
218e			 
218e			sysdict: 
218e			include "forth_opcodes.asm" 
218e			; op codes for forth keywords 
218e			; free to use code 0  
218e				OPCODE_HEAP: equ  1 
218e				OPCODE_EXEC: equ 2 
218e				OPCODE_DUP: equ 3 
218e				OPCODE_SWAP: equ 4 
218e				OPCODE_COLN: equ 5 
218e				OPCODE_SCOLN: equ 6 
218e				OPCODE_DROP: equ 7 
218e				OPCODE_DUP2: equ 8 
218e				OPCODE_DROP2: equ 9 
218e				OPCODE_SWAP2: equ 10 
218e				OPCODE_AT: equ 11 
218e				OPCODE_CAT: equ 12 
218e				OPCODE_BANG: equ 13 
218e				OPCODE_CBANG: equ 14 
218e				OPCODE_SCALL: equ 15 
218e				OPCODE_DEPTH: equ 16 
218e				OPCODE_OVER: equ 17 
218e				OPCODE_PAUSE: equ 18 
218e				OPCODE_PAUSES: equ 19 
218e				OPCODE_ROT: equ 20 
218e			;free to reuse	OPCODE_WORDS: equ 21 
218e			        OPCODE_NOT: equ 21 
218e				OPCODE_UWORDS: equ 22 
218e				OPCODE_BP: equ 23 
218e				OPCODE_MONITOR: equ 24  
218e				OPCODE_MALLOC: equ 25 
218e				OPCODE_FREE: equ 26 
218e				OPCODE_LIST: equ 27 
218e				OPCODE_FORGET: equ 28 
218e				OPCODE_NOP: equ 29 
218e				OPCODE_COMO: equ 30 
218e				OPCODE_COMC: equ 31 
218e			;free to reuse	OPCODE_ENDCORE: equ 32 
218e				OPCODE_AFTERSOUND: equ 33 
218e				OPCODE_GP2: equ 34 
218e				OPCODE_GP3: equ 35 
218e				OPCODE_GP4: equ 36 
218e				OPCODE_SIN: equ 37 
218e				OPCODE_SOUT: equ 38 
218e				OPCODE_SPIO: equ 39 
218e				OPCODE_SPICEH: equ 40 
218e				OPCODE_SPIOb: equ 41 
218e				OPCODE_SPII: equ 42 
218e				OPCODE_SESEL: equ 43 
218e				OPCODE_CARTDEV: equ 44 
218e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
218e				OPCODE_FB: equ 46 
218e				OPCODE_EMIT: equ 47 
218e				OPCODE_DOTH: equ 48 
218e				OPCODE_DOTF: equ 49 
218e				OPCODE_DOT: equ 50 
218e				OPCODE_CLS: equ 51 
218e				OPCODE_DRAW: equ 52 
218e				OPCODE_DUMP: equ 53 
218e				OPCODE_CDUMP: equ 54 
218e				OPCODE_DAT: equ 55 
218e				OPCODE_HOME: equ 56 
218e				OPCODE_SPACE: equ 57 
218e				OPCODE_SPACES: equ 58 
218e				OPCODE_SCROLL: equ 59 
218e				OPCODE_ATQ: equ 60 
218e				OPCODE_AUTODSP: equ 61 
218e				OPCODE_MENU: equ 62 
218e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
218e				OPCODE_THEN: equ 64 
218e				OPCODE_ELSE: equ 65 
218e				OPCODE_DO: equ 66 
218e				OPCODE_LOOP: equ 67 
218e				OPCODE_I: equ 68 
218e				OPCODE_DLOOP: equ 69  
218e				OPCODE_REPEAT: equ 70  
218e				OPCODE_UNTIL: equ 71 
218e				OPCODE_ENDFLOW: equ 72 
218e				OPCODE_WAITK: equ 73 
218e				OPCODE_ACCEPT: equ 74 
218e				OPCODE_EDIT: equ 75 
218e			;free to reuse	OPCODE_ENDKEY: equ 76 
218e				OPCODE_LZERO: equ 77 
218e				OPCODE_TZERO: equ 78 
218e				OPCODE_LESS: equ 79 
218e				OPCODE_GT: equ 80 
218e				OPCODE_EQUAL: equ 81  
218e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
218e				OPCODE_NEG: equ 83 
218e				OPCODE_DIV: equ 84 
218e				OPCODE_MUL: equ 85 
218e				OPCODE_MIN: equ 86 
218e				OPCODE_MAX: equ 87 
218e				OPCODE_RND16: equ 88 
218e				OPCODE_RND8: equ 89 
218e				OPCODE_RND: equ 90 
218e			;free to reuse	OPCODE_ENDMATHS: equ 91  
218e				OPCODE_BYNAME: equ 92 
218e				OPCODE_DIR: equ 93 
218e				OPCODE_SAVE: equ 94 
218e				OPCODE_LOAD: equ 95 
218e				OPCODE_BSAVE: equ 96 
218e				OPCODE_BLOAD: equ 97 
218e				OPCODE_SEO: equ 98  
218e				OPCODE_SEI: equ 99 
218e				OPCODE_SFREE: equ 100 
218e				OPCODE_SIZE: equ 101 
218e				OPCODE_CREATE: equ 102 
218e				OPCODE_APPEND: equ 103 
218e				OPCODE_SDEL: equ 104 
218e				OPCODE_OPEN: equ 105 
218e				OPCODE_READ: equ 106 
218e				OPCODE_EOF: equ 106 
218e				OPCODE_FORMAT: equ 107 
218e				OPCODE_LABEL: equ 108 
218e				OPCODE_LABELS: equ 109 
218e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
218e				OPCODE_UPPER: equ 111 
218e				OPCODE_LOWER: equ 112 
218e				OPCODE_SUBSTR: equ 113 
218e				OPCODE_LEFT: equ 114 
218e				OPCODE_RIGHT: equ 115 
218e				OPCODE_STR2NUM: equ 116 
218e				OPCODE_NUM2STR: equ 117 
218e				OPCODE_CONCAT: equ 118 
218e				OPCODE_FIND: equ 119 
218e				OPCODE_LEN: equ 120 
218e				OPCODE_CHAR: equ 121 
218e			; free to reuse	OPCODE_STRLEN: equ 122 
218e			; free to reuse	OPCODE_ENDSTR: equ 123 
218e				OPCODE_V0S: equ 124 
218e				OPCODE_V0Q: equ 125 
218e				OPCODE_V1S: equ 126 
218e				OPCODE_V1Q: equ 127 
218e				OPCODE_V2S: equ 128 
218e				OPCODE_V2Q: equ 129 
218e				OPCODE_V3S: equ 130 
218e				OPCODE_V3Q: equ 131 
218e			;free to reuse	OPCODE_END: equ 132 
218e				OPCODE_ZDUP: equ 133 
218e			 
218e			; eof 
# End of file forth_opcodes.asm
218e			 
218e			include "forth_words_core.asm" 
218e			 
218e			; | ## Core Words 
218e			 
218e			;if MALLOC_4 
218e			 
218e			.HEAP: 
218e				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
218e 15				db WORD_SYS_CORE+OPCODE_HEAP             
218f cd 21			dw .EXEC            
2191 05				db 4 + 1 
2192 .. 00			db "HEAP",0              
2197				endm 
# End of macro CWHEAD
2197			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2197			; | | u1 - Current number of bytes in the heap 
2197			; | | u2 - Remaining bytes left on the heap 
2197			; | |  
2197			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2197			 
2197			 
2197					if DEBUG_FORTH_WORDS_KEY 
2197						DMARK "HEP" 
2197 f5				push af  
2198 3a ac 21			ld a, (.dmark)  
219b 32 b4 fb			ld (debug_mark),a  
219e 3a ad 21			ld a, (.dmark+1)  
21a1 32 b5 fb			ld (debug_mark+1),a  
21a4 3a ae 21			ld a, (.dmark+2)  
21a7 32 b6 fb			ld (debug_mark+2),a  
21aa 18 03			jr .pastdmark  
21ac ..			.dmark: db "HEP"  
21af f1			.pastdmark: pop af  
21b0			endm  
# End of macro DMARK
21b0						CALLMONITOR 
21b0 cd 3d 17			call break_point_state  
21b3				endm  
# End of macro CALLMONITOR
21b3					endif 
21b3 2a 0a 80				ld hl, (free_list )      
21b6 11 0e 80				ld de, heap_start 
21b9			 
21b9 ed 52				sbc hl, de  
21bb			 
21bb cd cd 1c				call forth_push_numhl 
21be			 
21be			 
21be ed 5b 0a 80			ld de, (free_list )      
21c2 21 80 ef				ld hl, heap_end 
21c5			 
21c5 ed 52				sbc hl, de 
21c7			 
21c7 cd cd 1c				call forth_push_numhl 
21ca					 
21ca			 
21ca					 
21ca			 
21ca			 
21ca			 
21ca					NEXTW 
21ca c3 36 20			jp macro_next 
21cd				endm 
# End of macro NEXTW
21cd			;endif 
21cd			 
21cd			.EXEC: 
21cd			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21cd			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21cd			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21cd			;; > > 
21cd			;; > >   
21cd			;	STACKFRAME OFF $5efe $5f9f 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS_KEY 
21cd			;			DMARK "EXE" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			; 
21cd			;	FORTH_DSP_VALUEHL 
21cd			; 
21cd			;	FORTH_DSP_POP 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EX1" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;;	ld e,(hl) 
21cd			;;	inc hl 
21cd			;;	ld d,(hl) 
21cd			;;	ex de,hl 
21cd			; 
21cd			;;		if DEBUG_FORTH_WORDS 
21cd			;;			DMARK "EX2" 
21cd			;;			CALLMONITOR 
21cd			;;		endif 
21cd			;	push hl 
21cd			; 
21cd			;	;ld a, 0 
21cd			;	;ld a, FORTH_END_BUFFER 
21cd			;	call strlenz 
21cd			;	inc hl   ; include zero term to copy 
21cd			;	inc hl   ; include term 
21cd			;	inc hl   ; include term 
21cd			;	ld b,0 
21cd			;	ld c,l 
21cd			;	pop hl 
21cd			;	ld de, execscratch 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EX3" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;	ldir 
21cd			; 
21cd			; 
21cd			;	ld hl, execscratch 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EXe" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			; 
21cd			;	call forthparse 
21cd			;	call forthexec 
21cd			;;	call forthexec_cleanup 
21cd			;;	call forthparse 
21cd			;;	call forthexec 
21cd			; 
21cd			;	STACKFRAMECHK OFF $5efe $5f9f 
21cd			; 
21cd			;	; an immediate word so no need to process any more words 
21cd			;	ret 
21cd			;	NEXTW 
21cd			 
21cd			; dead code - old version  
21cd			;	FORTH_RSP_NEXT 
21cd			 
21cd			;  
21cd			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21cd			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21cd			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21cd			;	push hl 
21cd			;	push de 
21cd			;	push bc 
21cd			; 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS_KEY 
21cd			;			DMARK "EXR" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			; 
21cd			; 
21cd			; 
21cd			;	;v5 FORTH_DSP_VALUE 
21cd			;	FORTH_DSP_VALUEHL 
21cd			; 
21cd			;	; TODO do string type checks 
21cd			; 
21cd			;;v5	inc hl   ; skip type 
21cd			; 
21cd			;	push hl  ; source code  
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EX1" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;	ld a, 0 
21cd			;	call strlent 
21cd			; 
21cd			;	inc hl 
21cd			;	inc hl 
21cd			;	inc hl 
21cd			;	inc hl 
21cd			; 
21cd			;	push hl    ; size 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EX2" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;	call malloc 
21cd			; 
21cd			;	ex de, hl    ; de now contains malloc area 
21cd			;	pop bc   	; get byte count 
21cd			;	pop hl      ; get string to copy 
21cd			; 
21cd			;	push de     ; save malloc for free later 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EX3" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;	ldir       ; duplicate string 
21cd			; 
21cd			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21cd			;	 
21cd			;	; TODO fix the parse would be better than this...  
21cd			;	ex de, hl 
21cd			;	dec hl 
21cd			;	ld a, 0 
21cd			;	ld (hl), a 
21cd			;	dec hl 
21cd			;	ld a, ' ' 
21cd			;	ld (hl), a 
21cd			;	dec hl 
21cd			;	ld (hl), a 
21cd			; 
21cd			;	dec hl 
21cd			;	ld (hl), a 
21cd			; 
21cd			; 
21cd			;	FORTH_DSP_POP  
21cd			; 
21cd			;	pop hl     
21cd			;	push hl    ; save malloc area 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EX4" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			; 
21cd			;	call forthparse 
21cd			;	call forthexec 
21cd			;	 
21cd			;	pop hl 
21cd			;	if DEBUG_FORTH_WORDS 
21cd			;		DMARK "EX5" 
21cd			;		CALLMONITOR 
21cd			;	endif 
21cd			; 
21cd			;	if FORTH_ENABLE_FREE 
21cd			;	call free 
21cd			;	endif 
21cd			; 
21cd			;	if DEBUG_FORTH_WORDS 
21cd			;		DMARK "EX6" 
21cd			;		CALLMONITOR 
21cd			;	endif 
21cd			; 
21cd			;	pop bc 
21cd			;	pop de 
21cd			;	pop hl 
21cd			;;	FORTH_RSP_POP	  
21cd			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21cd			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21cd			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21cd			; 
21cd			;	if DEBUG_FORTH_WORDS 
21cd			;		DMARK "EX7" 
21cd			;		CALLMONITOR 
21cd			;	endif 
21cd			;	NEXTW 
21cd			 
21cd			;.STKEXEC: 
21cd			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21cd			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21cd			; 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS_KEY 
21cd			;			DMARK "STX" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			; 
21cd			;	FORTH_DSP_VALUEHL 
21cd			; 
21cd			;	ld (store_tmp1), hl    ; count 
21cd			; 
21cd			;	FORTH_DSP_POP 
21cd			;.stkexec1: 
21cd			;	ld hl, (store_tmp1)   ; count 
21cd			;	ld a, 0 
21cd			;	cp l 
21cd			;	ret z 
21cd			; 
21cd			;	dec hl 
21cd			;	ld (store_tmp1), hl    ; count 
21cd			;	 
21cd			;	FORTH_DSP_VALUEHL 
21cd			;	push hl 
21cd			;	 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EXp" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;	FORTH_DSP_POP 
21cd			; 
21cd			;	call strlenz 
21cd			;	inc hl   ; include zero term to copy 
21cd			;	inc hl   ; include zero term to copy 
21cd			;	inc hl   ; include zero term to copy 
21cd			;	ld b,0 
21cd			;	ld c,l 
21cd			;	pop hl 
21cd			;	ld de, execscratch 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EX3" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;	ldir 
21cd			; 
21cd			; 
21cd			;	ld hl, execscratch 
21cd			; 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EXP" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			; 
21cd			;	call forthparse 
21cd			;	ld hl, execscratch 
21cd			;		if DEBUG_FORTH_WORDS 
21cd			;			DMARK "EXx" 
21cd			;			CALLMONITOR 
21cd			;		endif 
21cd			;	call forthexec 
21cd			; 
21cd			;	jp .stkexec1 
21cd			; 
21cd			;	ret 
21cd			 
21cd			 
21cd			.DUP: 
21cd				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21cd 17				db WORD_SYS_CORE+OPCODE_DUP             
21ce 43 22			dw .ZDUP            
21d0 04				db 3 + 1 
21d1 .. 00			db "DUP",0              
21d5				endm 
# End of macro CWHEAD
21d5			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21d5			 
21d5					if DEBUG_FORTH_WORDS_KEY 
21d5						DMARK "DUP" 
21d5 f5				push af  
21d6 3a ea 21			ld a, (.dmark)  
21d9 32 b4 fb			ld (debug_mark),a  
21dc 3a eb 21			ld a, (.dmark+1)  
21df 32 b5 fb			ld (debug_mark+1),a  
21e2 3a ec 21			ld a, (.dmark+2)  
21e5 32 b6 fb			ld (debug_mark+2),a  
21e8 18 03			jr .pastdmark  
21ea ..			.dmark: db "DUP"  
21ed f1			.pastdmark: pop af  
21ee			endm  
# End of macro DMARK
21ee						CALLMONITOR 
21ee cd 3d 17			call break_point_state  
21f1				endm  
# End of macro CALLMONITOR
21f1					endif 
21f1			 
21f1					FORTH_DSP 
21f1 cd 8a 1e			call macro_forth_dsp 
21f4				endm 
# End of macro FORTH_DSP
21f4			 
21f4 7e					ld a, (HL) 
21f5 fe 01				cp DS_TYPE_STR 
21f7 20 25				jr nz, .dupinum 
21f9			 
21f9					; push another string 
21f9			 
21f9					FORTH_DSP_VALUEHL     		 
21f9 cd c4 1e			call macro_dsp_valuehl 
21fc				endm 
# End of macro FORTH_DSP_VALUEHL
21fc			 
21fc				if DEBUG_FORTH_WORDS 
21fc					DMARK "DUs" 
21fc f5				push af  
21fd 3a 11 22			ld a, (.dmark)  
2200 32 b4 fb			ld (debug_mark),a  
2203 3a 12 22			ld a, (.dmark+1)  
2206 32 b5 fb			ld (debug_mark+1),a  
2209 3a 13 22			ld a, (.dmark+2)  
220c 32 b6 fb			ld (debug_mark+2),a  
220f 18 03			jr .pastdmark  
2211 ..			.dmark: db "DUs"  
2214 f1			.pastdmark: pop af  
2215			endm  
# End of macro DMARK
2215					CALLMONITOR 
2215 cd 3d 17			call break_point_state  
2218				endm  
# End of macro CALLMONITOR
2218				endif 
2218 cd 3b 1d				call forth_push_str 
221b			 
221b					NEXTW 
221b c3 36 20			jp macro_next 
221e				endm 
# End of macro NEXTW
221e			 
221e			 
221e			.dupinum: 
221e					 
221e			 
221e			 
221e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
221e cd c4 1e			call macro_dsp_valuehl 
2221				endm 
# End of macro FORTH_DSP_VALUEHL
2221			 
2221				; TODO add floating point number detection 
2221			 
2221				if DEBUG_FORTH_WORDS 
2221					DMARK "DUi" 
2221 f5				push af  
2222 3a 36 22			ld a, (.dmark)  
2225 32 b4 fb			ld (debug_mark),a  
2228 3a 37 22			ld a, (.dmark+1)  
222b 32 b5 fb			ld (debug_mark+1),a  
222e 3a 38 22			ld a, (.dmark+2)  
2231 32 b6 fb			ld (debug_mark+2),a  
2234 18 03			jr .pastdmark  
2236 ..			.dmark: db "DUi"  
2239 f1			.pastdmark: pop af  
223a			endm  
# End of macro DMARK
223a					CALLMONITOR 
223a cd 3d 17			call break_point_state  
223d				endm  
# End of macro CALLMONITOR
223d				endif 
223d			 
223d cd cd 1c				call forth_push_numhl 
2240					NEXTW 
2240 c3 36 20			jp macro_next 
2243				endm 
# End of macro NEXTW
2243			.ZDUP: 
2243				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2243 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2244 7b 22			dw .SWAP            
2246 05				db 4 + 1 
2247 .. 00			db "?DUP",0              
224c				endm 
# End of macro CWHEAD
224c			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
224c			 
224c					if DEBUG_FORTH_WORDS_KEY 
224c						DMARK "qDU" 
224c f5				push af  
224d 3a 61 22			ld a, (.dmark)  
2250 32 b4 fb			ld (debug_mark),a  
2253 3a 62 22			ld a, (.dmark+1)  
2256 32 b5 fb			ld (debug_mark+1),a  
2259 3a 63 22			ld a, (.dmark+2)  
225c 32 b6 fb			ld (debug_mark+2),a  
225f 18 03			jr .pastdmark  
2261 ..			.dmark: db "qDU"  
2264 f1			.pastdmark: pop af  
2265			endm  
# End of macro DMARK
2265						CALLMONITOR 
2265 cd 3d 17			call break_point_state  
2268				endm  
# End of macro CALLMONITOR
2268					endif 
2268					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2268 cd c4 1e			call macro_dsp_valuehl 
226b				endm 
# End of macro FORTH_DSP_VALUEHL
226b			 
226b e5					push hl 
226c			 
226c					; is it a zero? 
226c			 
226c 3e 00				ld a, 0 
226e 84					add h 
226f 85					add l 
2270			 
2270 e1					pop hl 
2271			 
2271 fe 00				cp 0 
2273 28 03				jr z, .dup2orig 
2275			 
2275			 
2275 cd cd 1c				call forth_push_numhl 
2278			 
2278			 
2278				; TODO add floating point number detection 
2278			 
2278			.dup2orig: 
2278			 
2278					NEXTW 
2278 c3 36 20			jp macro_next 
227b				endm 
# End of macro NEXTW
227b			.SWAP: 
227b				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
227b 18				db WORD_SYS_CORE+OPCODE_SWAP             
227c ba 22			dw .COLN            
227e 05				db 4 + 1 
227f .. 00			db "SWAP",0              
2284				endm 
# End of macro CWHEAD
2284			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2284					if DEBUG_FORTH_WORDS_KEY 
2284						DMARK "SWP" 
2284 f5				push af  
2285 3a 99 22			ld a, (.dmark)  
2288 32 b4 fb			ld (debug_mark),a  
228b 3a 9a 22			ld a, (.dmark+1)  
228e 32 b5 fb			ld (debug_mark+1),a  
2291 3a 9b 22			ld a, (.dmark+2)  
2294 32 b6 fb			ld (debug_mark+2),a  
2297 18 03			jr .pastdmark  
2299 ..			.dmark: db "SWP"  
229c f1			.pastdmark: pop af  
229d			endm  
# End of macro DMARK
229d						CALLMONITOR 
229d cd 3d 17			call break_point_state  
22a0				endm  
# End of macro CALLMONITOR
22a0					endif 
22a0			 
22a0					FORTH_DSP_VALUEHL 
22a0 cd c4 1e			call macro_dsp_valuehl 
22a3				endm 
# End of macro FORTH_DSP_VALUEHL
22a3 e5					push hl     ; w2 
22a4			 
22a4					FORTH_DSP_POP 
22a4 cd 7c 1f			call macro_forth_dsp_pop 
22a7				endm 
# End of macro FORTH_DSP_POP
22a7			 
22a7					FORTH_DSP_VALUEHL 
22a7 cd c4 1e			call macro_dsp_valuehl 
22aa				endm 
# End of macro FORTH_DSP_VALUEHL
22aa			 
22aa					FORTH_DSP_POP 
22aa cd 7c 1f			call macro_forth_dsp_pop 
22ad				endm 
# End of macro FORTH_DSP_POP
22ad			 
22ad d1					pop de     ; w2	, hl = w1 
22ae			 
22ae eb					ex de, hl 
22af d5					push de 
22b0			 
22b0 cd cd 1c				call forth_push_numhl 
22b3			 
22b3 e1					pop hl 
22b4			 
22b4 cd cd 1c				call forth_push_numhl 
22b7					 
22b7			 
22b7					NEXTW 
22b7 c3 36 20			jp macro_next 
22ba				endm 
# End of macro NEXTW
22ba			.COLN: 
22ba				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22ba 19				db WORD_SYS_CORE+OPCODE_COLN             
22bb 46 24			dw .SCOLN            
22bd 02				db 1 + 1 
22be .. 00			db ":",0              
22c0				endm 
# End of macro CWHEAD
22c0			; | : ( -- )         Create new word | DONE 
22c0			 
22c0					if DEBUG_FORTH_WORDS_KEY 
22c0						DMARK "CLN" 
22c0 f5				push af  
22c1 3a d5 22			ld a, (.dmark)  
22c4 32 b4 fb			ld (debug_mark),a  
22c7 3a d6 22			ld a, (.dmark+1)  
22ca 32 b5 fb			ld (debug_mark+1),a  
22cd 3a d7 22			ld a, (.dmark+2)  
22d0 32 b6 fb			ld (debug_mark+2),a  
22d3 18 03			jr .pastdmark  
22d5 ..			.dmark: db "CLN"  
22d8 f1			.pastdmark: pop af  
22d9			endm  
# End of macro DMARK
22d9						CALLMONITOR 
22d9 cd 3d 17			call break_point_state  
22dc				endm  
# End of macro CALLMONITOR
22dc					endif 
22dc				STACKFRAME OFF $8efe $989f 
22dc				if DEBUG_STACK_IMB 
22dc					if OFF 
22dc						exx 
22dc						ld de, $8efe 
22dc						ld a, d 
22dc						ld hl, curframe 
22dc						call hexout 
22dc						ld a, e 
22dc						ld hl, curframe+2 
22dc						call hexout 
22dc						ld hl, $8efe 
22dc						push hl 
22dc						ld hl, $989f 
22dc						push hl 
22dc						exx 
22dc					endif 
22dc				endif 
22dc			endm 
# End of macro STACKFRAME
22dc				; get parser buffer length  of new word 
22dc			 
22dc				 
22dc			 
22dc					; move tok past this to start of name defintition 
22dc					; TODO get word to define 
22dc					; TODO Move past word token 
22dc					; TODO get length of string up to the ';' 
22dc			 
22dc 2a 9b f2			ld hl, (os_tok_ptr) 
22df 23				inc hl 
22e0 23				inc hl 
22e1			 
22e1 3e 3b			ld a, ';' 
22e3 cd 81 11			call strlent 
22e6			 
22e6 7d				ld a,l 
22e7 32 96 ef			ld (os_new_parse_len), a 
22ea			 
22ea			 
22ea			if DEBUG_FORTH_UWORD 
22ea ed 5b 9b f2		ld de, (os_tok_ptr) 
22ee						DMARK ":01" 
22ee f5				push af  
22ef 3a 03 23			ld a, (.dmark)  
22f2 32 b4 fb			ld (debug_mark),a  
22f5 3a 04 23			ld a, (.dmark+1)  
22f8 32 b5 fb			ld (debug_mark+1),a  
22fb 3a 05 23			ld a, (.dmark+2)  
22fe 32 b6 fb			ld (debug_mark+2),a  
2301 18 03			jr .pastdmark  
2303 ..			.dmark: db ":01"  
2306 f1			.pastdmark: pop af  
2307			endm  
# End of macro DMARK
2307				CALLMONITOR 
2307 cd 3d 17			call break_point_state  
230a				endm  
# End of macro CALLMONITOR
230a			endif 
230a			 
230a			; 
230a			;  new word memory layout: 
230a			;  
230a			;    : adg 6666 ;  
230a			; 
230a			;    db   1     ; user defined word  
230a 23				inc hl    
230b			;    dw   sysdict 
230b 23				inc hl 
230c 23				inc hl 
230d			;    db <word len>+1 (for null) 
230d 23				inc hl 
230e			;    db .... <word> 
230e			; 
230e			 
230e 23				inc hl    ; some extras for the word preamble before the above 
230f 23				inc hl 
2310 23				inc hl 
2311 23				inc hl 
2312 23				inc hl 
2313 23				inc hl 
2314 23				inc hl  
2315 23				inc hl 
2316 23				inc hl 
2317 23				inc hl 
2318 23				inc hl 
2319 23				inc hl 
231a 23				inc hl 
231b 23				inc hl     ; TODO how many do we really need?     maybe only 6 
231c			;       exec word buffer 
231c			;	<ptr word>   
231c 23				inc hl 
231d 23				inc hl 
231e			;       <word list><null term> 7F final term 
231e			 
231e			 
231e			if DEBUG_FORTH_UWORD 
231e						DMARK ":02" 
231e f5				push af  
231f 3a 33 23			ld a, (.dmark)  
2322 32 b4 fb			ld (debug_mark),a  
2325 3a 34 23			ld a, (.dmark+1)  
2328 32 b5 fb			ld (debug_mark+1),a  
232b 3a 35 23			ld a, (.dmark+2)  
232e 32 b6 fb			ld (debug_mark+2),a  
2331 18 03			jr .pastdmark  
2333 ..			.dmark: db ":02"  
2336 f1			.pastdmark: pop af  
2337			endm  
# End of macro DMARK
2337				CALLMONITOR 
2337 cd 3d 17			call break_point_state  
233a				endm  
# End of macro CALLMONITOR
233a			endif 
233a			 
233a				 
233a					; malloc the size 
233a			 
233a cd df 11				call malloc 
233d 22 98 ef				ld (os_new_malloc), hl     ; save malloc start 
2340			 
2340			;    db   1     ; user defined word  
2340 3e 01				ld a, WORD_SYS_UWORD  
2342 77					ld (hl), a 
2343				 
2343 23				inc hl    
2344			;    dw   sysdict 
2344 11 8e 21			ld de, sysdict       ; continue on with the scan to the system dict 
2347 73				ld (hl), e 
2348 23				inc hl 
2349 72				ld (hl), d 
234a 23				inc hl 
234b			 
234b			 
234b			;    Setup dict word 
234b			 
234b 23				inc hl 
234c 22 92 ef			ld (os_new_work_ptr), hl     ; save start of dict word  
234f			 
234f				; 1. get length of dict word 
234f			 
234f			 
234f 2a 9b f2			ld hl, (os_tok_ptr) 
2352 23				inc hl 
2353 23				inc hl    ; position to start of dict word 
2354 3e 00			ld a, 0 
2356 cd 81 11			call strlent 
2359			 
2359			 
2359 23				inc hl    ; to include null??? 
235a			 
235a				; write length of dict word 
235a			 
235a ed 5b 92 ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
235e 1b				dec de 
235f eb				ex de, hl 
2360 73				ld (hl), e 
2361 eb				ex de, hl 
2362			 
2362				 
2362			 
2362				; copy  
2362 4d				ld c, l 
2363 06 00			ld b, 0 
2365 ed 5b 92 ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2369 2a 9b f2			ld hl, (os_tok_ptr) 
236c 23				inc hl 
236d 23				inc hl    ; position to start of dict word 
236e				 
236e			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
236e				 
236e				; TODO need to convert word to upper case 
236e			 
236e			ucasetok:	 
236e 7e				ld a,(hl) 
236f cd 6d 11			call toUpper 
2372 77				ld (hl),a 
2373 ed a0			ldi 
2375 f2 6e 23		 	jp p, ucasetok 
2378			 
2378			 
2378			 
2378				; de now points to start of where the word body code should be placed 
2378 ed 53 92 ef		ld (os_new_work_ptr), de 
237c				; hl now points to the words to throw at forthexec which needs to be copied 
237c 22 90 ef			ld (os_new_src_ptr), hl 
237f			 
237f				; TODO add 'call to forthexec' 
237f			 
237f			if DEBUG_FORTH_UWORD 
237f c5				push bc 
2380 ed 4b 98 ef		ld bc, (os_new_malloc) 
2384						DMARK ":0x" 
2384 f5				push af  
2385 3a 99 23			ld a, (.dmark)  
2388 32 b4 fb			ld (debug_mark),a  
238b 3a 9a 23			ld a, (.dmark+1)  
238e 32 b5 fb			ld (debug_mark+1),a  
2391 3a 9b 23			ld a, (.dmark+2)  
2394 32 b6 fb			ld (debug_mark+2),a  
2397 18 03			jr .pastdmark  
2399 ..			.dmark: db ":0x"  
239c f1			.pastdmark: pop af  
239d			endm  
# End of macro DMARK
239d				CALLMONITOR 
239d cd 3d 17			call break_point_state  
23a0				endm  
# End of macro CALLMONITOR
23a0 c1				pop bc 
23a1			endif 
23a1			 
23a1			 
23a1				; create word preamble which should be: 
23a1			 
23a1			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23a1			 
23a1				;    ld hl, <word code> 
23a1				;    jp user_exec 
23a1			        ;    <word code bytes> 
23a1			 
23a1			 
23a1			;	inc de     ; TODO ??? or are we already past the word's null 
23a1 eb				ex de, hl 
23a2			 
23a2 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23a4			 
23a4 23				inc hl 
23a5 22 8c ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23a8 23				inc hl 
23a9			 
23a9 23				inc hl 
23aa 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23ac			 
23ac 01 fd 50			ld bc, user_exec 
23af 23				inc hl 
23b0 71				ld (hl), c     ; poke address of user_exec 
23b1 23				inc hl 
23b2 70				ld (hl), b     
23b3			 ; 
23b3			;	inc hl 
23b3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23b3			; 
23b3			; 
23b3			;	ld bc, macro_forth_rsp_next 
23b3			;	inc hl 
23b3			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23b3			;	inc hl 
23b3			;	ld (hl), b     
23b3			 ; 
23b3			;	inc hl 
23b3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23b3			; 
23b3			; 
23b3			;	inc hl 
23b3			;	ld bc, forthexec 
23b3			;	ld (hl), c     ; poke address of forthexec 
23b3			;	inc hl 
23b3			;	ld (hl), b      
23b3			; 
23b3			;	inc hl 
23b3			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23b3			; 
23b3			;	ld bc, user_dict_next 
23b3			;	inc hl 
23b3			;	ld (hl), c     ; poke address of forthexec 
23b3			;	inc hl 
23b3			;	ld (hl), b      
23b3			 
23b3				; hl is now where we need to copy the word byte data to save this 
23b3			 
23b3 23				inc hl 
23b4 22 8e ef			ld (os_new_exec), hl 
23b7				 
23b7				; copy definition 
23b7			 
23b7 eb				ex de, hl 
23b8			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23b8			;	inc de    ; skip the PC for this parse 
23b8 3a 96 ef			ld a, (os_new_parse_len) 
23bb 4f				ld c, a 
23bc 06 00			ld b, 0 
23be ed b0			ldir		 ; copy defintion 
23c0			 
23c0			 
23c0				; poke the address of where the new word bytes live for forthexec 
23c0			 
23c0 2a 8c ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23c3			 
23c3 ed 5b 8e ef		ld de, (os_new_exec)      
23c7				 
23c7 73				ld (hl), e 
23c8 23				inc hl 
23c9 72				ld (hl), d 
23ca			 
23ca					; TODO copy last user dict word next link to this word 
23ca					; TODO update last user dict word to point to this word 
23ca			; 
23ca			; hl f923 de 812a ; bc 811a 
23ca			 
23ca			if DEBUG_FORTH_UWORD 
23ca c5				push bc 
23cb ed 4b 98 ef		ld bc, (os_new_malloc) 
23cf						DMARK ":0A" 
23cf f5				push af  
23d0 3a e4 23			ld a, (.dmark)  
23d3 32 b4 fb			ld (debug_mark),a  
23d6 3a e5 23			ld a, (.dmark+1)  
23d9 32 b5 fb			ld (debug_mark+1),a  
23dc 3a e6 23			ld a, (.dmark+2)  
23df 32 b6 fb			ld (debug_mark+2),a  
23e2 18 03			jr .pastdmark  
23e4 ..			.dmark: db ":0A"  
23e7 f1			.pastdmark: pop af  
23e8			endm  
# End of macro DMARK
23e8				CALLMONITOR 
23e8 cd 3d 17			call break_point_state  
23eb				endm  
# End of macro CALLMONITOR
23eb c1				pop bc 
23ec			endif 
23ec			if DEBUG_FORTH_UWORD 
23ec c5				push bc 
23ed ed 4b 98 ef		ld bc, (os_new_malloc) 
23f1 03				inc bc 
23f2 03				inc bc 
23f3 03				inc bc 
23f4 03				inc bc 
23f5 03				inc bc 
23f6 03				inc bc 
23f7 03				inc bc 
23f8 03				inc bc 
23f9			 
23f9						DMARK ":0B" 
23f9 f5				push af  
23fa 3a 0e 24			ld a, (.dmark)  
23fd 32 b4 fb			ld (debug_mark),a  
2400 3a 0f 24			ld a, (.dmark+1)  
2403 32 b5 fb			ld (debug_mark+1),a  
2406 3a 10 24			ld a, (.dmark+2)  
2409 32 b6 fb			ld (debug_mark+2),a  
240c 18 03			jr .pastdmark  
240e ..			.dmark: db ":0B"  
2411 f1			.pastdmark: pop af  
2412			endm  
# End of macro DMARK
2412				CALLMONITOR 
2412 cd 3d 17			call break_point_state  
2415				endm  
# End of macro CALLMONITOR
2415 c1				pop bc 
2416			endif 
2416			 
2416			; update word dict linked list for new word 
2416			 
2416			 
2416 2a 97 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2419 23			inc hl     ; move to next work linked list ptr 
241a			 
241a ed 5b 98 ef	ld de, (os_new_malloc)		 ; new next word 
241e 73			ld (hl), e 
241f 23			inc hl 
2420 72			ld (hl), d 
2421			 
2421			if DEBUG_FORTH_UWORD 
2421 ed 4b 97 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2425			endif 
2425			 
2425 ed 53 97 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
2429			 
2429			 
2429			if DEBUG_FORTH_UWORD 
2429						DMARK ":0+" 
2429 f5				push af  
242a 3a 3e 24			ld a, (.dmark)  
242d 32 b4 fb			ld (debug_mark),a  
2430 3a 3f 24			ld a, (.dmark+1)  
2433 32 b5 fb			ld (debug_mark+1),a  
2436 3a 40 24			ld a, (.dmark+2)  
2439 32 b6 fb			ld (debug_mark+2),a  
243c 18 03			jr .pastdmark  
243e ..			.dmark: db ":0+"  
2441 f1			.pastdmark: pop af  
2442			endm  
# End of macro DMARK
2442				CALLMONITOR 
2442 cd 3d 17			call break_point_state  
2445				endm  
# End of macro CALLMONITOR
2445			endif 
2445			 
2445				STACKFRAMECHK OFF $8efe $989f 
2445				if DEBUG_STACK_IMB 
2445					if OFF 
2445						exx 
2445						ld hl, $989f 
2445						pop de   ; $989f 
2445						call cmp16 
2445						jr nz, .spnosame 
2445						ld hl, $8efe 
2445						pop de   ; $8efe 
2445						call cmp16 
2445						jr z, .spfrsame 
2445						.spnosame: call showsperror 
2445						.spfrsame: nop 
2445						exx 
2445					endif 
2445				endif 
2445			endm 
# End of macro STACKFRAMECHK
2445			 
2445 c9			ret    ; dont process any remaining parser tokens as they form new word 
2446			 
2446			 
2446			 
2446			 
2446			;		NEXT 
2446			.SCOLN: 
2446			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2446 06				db OPCODE_SCOLN 
2447 92 24			dw .DROP 
2449 02				db 2 
244a .. 00			db ";",0           
244c			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
244c					if DEBUG_FORTH_WORDS_KEY 
244c						DMARK "SCN" 
244c f5				push af  
244d 3a 61 24			ld a, (.dmark)  
2450 32 b4 fb			ld (debug_mark),a  
2453 3a 62 24			ld a, (.dmark+1)  
2456 32 b5 fb			ld (debug_mark+1),a  
2459 3a 63 24			ld a, (.dmark+2)  
245c 32 b6 fb			ld (debug_mark+2),a  
245f 18 03			jr .pastdmark  
2461 ..			.dmark: db "SCN"  
2464 f1			.pastdmark: pop af  
2465			endm  
# End of macro DMARK
2465						CALLMONITOR 
2465 cd 3d 17			call break_point_state  
2468				endm  
# End of macro CALLMONITOR
2468					endif 
2468					FORTH_RSP_TOS 
2468 cd 8b 1c			call macro_forth_rsp_tos 
246b				endm 
# End of macro FORTH_RSP_TOS
246b e5					push hl 
246c					FORTH_RSP_POP 
246c cd 95 1c			call macro_forth_rsp_pop 
246f				endm 
# End of macro FORTH_RSP_POP
246f e1					pop hl 
2470			;		ex de,hl 
2470 22 9b f2				ld (os_tok_ptr),hl 
2473			 
2473			if DEBUG_FORTH_UWORD 
2473						DMARK "SCL" 
2473 f5				push af  
2474 3a 88 24			ld a, (.dmark)  
2477 32 b4 fb			ld (debug_mark),a  
247a 3a 89 24			ld a, (.dmark+1)  
247d 32 b5 fb			ld (debug_mark+1),a  
2480 3a 8a 24			ld a, (.dmark+2)  
2483 32 b6 fb			ld (debug_mark+2),a  
2486 18 03			jr .pastdmark  
2488 ..			.dmark: db "SCL"  
248b f1			.pastdmark: pop af  
248c			endm  
# End of macro DMARK
248c				CALLMONITOR 
248c cd 3d 17			call break_point_state  
248f				endm  
# End of macro CALLMONITOR
248f			endif 
248f					NEXTW 
248f c3 36 20			jp macro_next 
2492				endm 
# End of macro NEXTW
2492			 
2492			.DROP: 
2492				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2492 1b				db WORD_SYS_CORE+OPCODE_DROP             
2493 bd 24			dw .DUP2            
2495 05				db 4 + 1 
2496 .. 00			db "DROP",0              
249b				endm 
# End of macro CWHEAD
249b			; | DROP ( w -- )   drop the TOS item   | DONE 
249b					if DEBUG_FORTH_WORDS_KEY 
249b						DMARK "DRP" 
249b f5				push af  
249c 3a b0 24			ld a, (.dmark)  
249f 32 b4 fb			ld (debug_mark),a  
24a2 3a b1 24			ld a, (.dmark+1)  
24a5 32 b5 fb			ld (debug_mark+1),a  
24a8 3a b2 24			ld a, (.dmark+2)  
24ab 32 b6 fb			ld (debug_mark+2),a  
24ae 18 03			jr .pastdmark  
24b0 ..			.dmark: db "DRP"  
24b3 f1			.pastdmark: pop af  
24b4			endm  
# End of macro DMARK
24b4						CALLMONITOR 
24b4 cd 3d 17			call break_point_state  
24b7				endm  
# End of macro CALLMONITOR
24b7					endif 
24b7					FORTH_DSP_POP 
24b7 cd 7c 1f			call macro_forth_dsp_pop 
24ba				endm 
# End of macro FORTH_DSP_POP
24ba					NEXTW 
24ba c3 36 20			jp macro_next 
24bd				endm 
# End of macro NEXTW
24bd			.DUP2: 
24bd				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24bd 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24be 02 25			dw .DROP2            
24c0 05				db 4 + 1 
24c1 .. 00			db "2DUP",0              
24c6				endm 
# End of macro CWHEAD
24c6			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24c6					if DEBUG_FORTH_WORDS_KEY 
24c6						DMARK "2DU" 
24c6 f5				push af  
24c7 3a db 24			ld a, (.dmark)  
24ca 32 b4 fb			ld (debug_mark),a  
24cd 3a dc 24			ld a, (.dmark+1)  
24d0 32 b5 fb			ld (debug_mark+1),a  
24d3 3a dd 24			ld a, (.dmark+2)  
24d6 32 b6 fb			ld (debug_mark+2),a  
24d9 18 03			jr .pastdmark  
24db ..			.dmark: db "2DU"  
24de f1			.pastdmark: pop af  
24df			endm  
# End of macro DMARK
24df						CALLMONITOR 
24df cd 3d 17			call break_point_state  
24e2				endm  
# End of macro CALLMONITOR
24e2					endif 
24e2					FORTH_DSP_VALUEHL 
24e2 cd c4 1e			call macro_dsp_valuehl 
24e5				endm 
# End of macro FORTH_DSP_VALUEHL
24e5 e5					push hl      ; 2 
24e6			 
24e6					FORTH_DSP_POP 
24e6 cd 7c 1f			call macro_forth_dsp_pop 
24e9				endm 
# End of macro FORTH_DSP_POP
24e9					 
24e9					FORTH_DSP_VALUEHL 
24e9 cd c4 1e			call macro_dsp_valuehl 
24ec				endm 
# End of macro FORTH_DSP_VALUEHL
24ec			;		push hl      ; 1 
24ec			 
24ec					FORTH_DSP_POP 
24ec cd 7c 1f			call macro_forth_dsp_pop 
24ef				endm 
# End of macro FORTH_DSP_POP
24ef			 
24ef			;		pop hl       ; 1 
24ef d1					pop de       ; 2 
24f0			 
24f0 cd cd 1c				call forth_push_numhl 
24f3 eb					ex de, hl 
24f4 cd cd 1c				call forth_push_numhl 
24f7			 
24f7					 
24f7 eb					ex de, hl 
24f8			 
24f8 cd cd 1c				call forth_push_numhl 
24fb eb					ex de, hl 
24fc cd cd 1c				call forth_push_numhl 
24ff			 
24ff			 
24ff					NEXTW 
24ff c3 36 20			jp macro_next 
2502				endm 
# End of macro NEXTW
2502			.DROP2: 
2502				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2502 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2503 31 25			dw .SWAP2            
2505 06				db 5 + 1 
2506 .. 00			db "2DROP",0              
250c				endm 
# End of macro CWHEAD
250c			; | 2DROP ( w w -- )    Double drop | DONE 
250c					if DEBUG_FORTH_WORDS_KEY 
250c						DMARK "2DR" 
250c f5				push af  
250d 3a 21 25			ld a, (.dmark)  
2510 32 b4 fb			ld (debug_mark),a  
2513 3a 22 25			ld a, (.dmark+1)  
2516 32 b5 fb			ld (debug_mark+1),a  
2519 3a 23 25			ld a, (.dmark+2)  
251c 32 b6 fb			ld (debug_mark+2),a  
251f 18 03			jr .pastdmark  
2521 ..			.dmark: db "2DR"  
2524 f1			.pastdmark: pop af  
2525			endm  
# End of macro DMARK
2525						CALLMONITOR 
2525 cd 3d 17			call break_point_state  
2528				endm  
# End of macro CALLMONITOR
2528					endif 
2528					FORTH_DSP_POP 
2528 cd 7c 1f			call macro_forth_dsp_pop 
252b				endm 
# End of macro FORTH_DSP_POP
252b					FORTH_DSP_POP 
252b cd 7c 1f			call macro_forth_dsp_pop 
252e				endm 
# End of macro FORTH_DSP_POP
252e					NEXTW 
252e c3 36 20			jp macro_next 
2531				endm 
# End of macro NEXTW
2531			.SWAP2: 
2531				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2531 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2532 5a 25			dw .AT            
2534 06				db 5 + 1 
2535 .. 00			db "2SWAP",0              
253b				endm 
# End of macro CWHEAD
253b			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
253b					if DEBUG_FORTH_WORDS_KEY 
253b						DMARK "2SW" 
253b f5				push af  
253c 3a 50 25			ld a, (.dmark)  
253f 32 b4 fb			ld (debug_mark),a  
2542 3a 51 25			ld a, (.dmark+1)  
2545 32 b5 fb			ld (debug_mark+1),a  
2548 3a 52 25			ld a, (.dmark+2)  
254b 32 b6 fb			ld (debug_mark+2),a  
254e 18 03			jr .pastdmark  
2550 ..			.dmark: db "2SW"  
2553 f1			.pastdmark: pop af  
2554			endm  
# End of macro DMARK
2554						CALLMONITOR 
2554 cd 3d 17			call break_point_state  
2557				endm  
# End of macro CALLMONITOR
2557					endif 
2557					NEXTW 
2557 c3 36 20			jp macro_next 
255a				endm 
# End of macro NEXTW
255a			.AT: 
255a				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
255a 1f				db WORD_SYS_CORE+OPCODE_AT             
255b 8c 25			dw .CAT            
255d 02				db 1 + 1 
255e .. 00			db "@",0              
2560				endm 
# End of macro CWHEAD
2560			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2560			 
2560					if DEBUG_FORTH_WORDS_KEY 
2560						DMARK "AT." 
2560 f5				push af  
2561 3a 75 25			ld a, (.dmark)  
2564 32 b4 fb			ld (debug_mark),a  
2567 3a 76 25			ld a, (.dmark+1)  
256a 32 b5 fb			ld (debug_mark+1),a  
256d 3a 77 25			ld a, (.dmark+2)  
2570 32 b6 fb			ld (debug_mark+2),a  
2573 18 03			jr .pastdmark  
2575 ..			.dmark: db "AT."  
2578 f1			.pastdmark: pop af  
2579			endm  
# End of macro DMARK
2579						CALLMONITOR 
2579 cd 3d 17			call break_point_state  
257c				endm  
# End of macro CALLMONITOR
257c					endif 
257c			.getbyteat:	 
257c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
257c cd c4 1e			call macro_dsp_valuehl 
257f				endm 
# End of macro FORTH_DSP_VALUEHL
257f					 
257f			;		push hl 
257f				 
257f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
257f cd 7c 1f			call macro_forth_dsp_pop 
2582				endm 
# End of macro FORTH_DSP_POP
2582			 
2582			;		pop hl 
2582			 
2582 7e					ld a, (hl) 
2583			 
2583 6f					ld l, a 
2584 26 00				ld h, 0 
2586 cd cd 1c				call forth_push_numhl 
2589			 
2589					NEXTW 
2589 c3 36 20			jp macro_next 
258c				endm 
# End of macro NEXTW
258c			.CAT: 
258c				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
258c 20				db WORD_SYS_CORE+OPCODE_CAT             
258d b5 25			dw .BANG            
258f 03				db 2 + 1 
2590 .. 00			db "C@",0              
2593				endm 
# End of macro CWHEAD
2593			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2593					if DEBUG_FORTH_WORDS_KEY 
2593						DMARK "CAA" 
2593 f5				push af  
2594 3a a8 25			ld a, (.dmark)  
2597 32 b4 fb			ld (debug_mark),a  
259a 3a a9 25			ld a, (.dmark+1)  
259d 32 b5 fb			ld (debug_mark+1),a  
25a0 3a aa 25			ld a, (.dmark+2)  
25a3 32 b6 fb			ld (debug_mark+2),a  
25a6 18 03			jr .pastdmark  
25a8 ..			.dmark: db "CAA"  
25ab f1			.pastdmark: pop af  
25ac			endm  
# End of macro DMARK
25ac						CALLMONITOR 
25ac cd 3d 17			call break_point_state  
25af				endm  
# End of macro CALLMONITOR
25af					endif 
25af c3 7c 25				jp .getbyteat 
25b2					NEXTW 
25b2 c3 36 20			jp macro_next 
25b5				endm 
# End of macro NEXTW
25b5			.BANG: 
25b5				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25b5 21				db WORD_SYS_CORE+OPCODE_BANG             
25b6 eb 25			dw .CBANG            
25b8 02				db 1 + 1 
25b9 .. 00			db "!",0              
25bb				endm 
# End of macro CWHEAD
25bb			; | ! ( x w -- ) Store x at address w      | DONE 
25bb					if DEBUG_FORTH_WORDS_KEY 
25bb						DMARK "BNG" 
25bb f5				push af  
25bc 3a d0 25			ld a, (.dmark)  
25bf 32 b4 fb			ld (debug_mark),a  
25c2 3a d1 25			ld a, (.dmark+1)  
25c5 32 b5 fb			ld (debug_mark+1),a  
25c8 3a d2 25			ld a, (.dmark+2)  
25cb 32 b6 fb			ld (debug_mark+2),a  
25ce 18 03			jr .pastdmark  
25d0 ..			.dmark: db "BNG"  
25d3 f1			.pastdmark: pop af  
25d4			endm  
# End of macro DMARK
25d4						CALLMONITOR 
25d4 cd 3d 17			call break_point_state  
25d7				endm  
# End of macro CALLMONITOR
25d7					endif 
25d7			 
25d7			.storebyteat:		 
25d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d7 cd c4 1e			call macro_dsp_valuehl 
25da				endm 
# End of macro FORTH_DSP_VALUEHL
25da					 
25da e5					push hl 
25db				 
25db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25db cd 7c 1f			call macro_forth_dsp_pop 
25de				endm 
# End of macro FORTH_DSP_POP
25de			 
25de					; get byte to poke 
25de			 
25de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25de cd c4 1e			call macro_dsp_valuehl 
25e1				endm 
# End of macro FORTH_DSP_VALUEHL
25e1 e5					push hl 
25e2			 
25e2			 
25e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25e2 cd 7c 1f			call macro_forth_dsp_pop 
25e5				endm 
# End of macro FORTH_DSP_POP
25e5			 
25e5			 
25e5 d1					pop de 
25e6 e1					pop hl 
25e7			 
25e7 73					ld (hl),e 
25e8			 
25e8			 
25e8					NEXTW 
25e8 c3 36 20			jp macro_next 
25eb				endm 
# End of macro NEXTW
25eb			.CBANG: 
25eb				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25eb 22				db WORD_SYS_CORE+OPCODE_CBANG             
25ec 14 26			dw .SCALL            
25ee 03				db 2 + 1 
25ef .. 00			db "C!",0              
25f2				endm 
# End of macro CWHEAD
25f2			; | C!  ( x w -- ) Store x at address w  | DONE 
25f2					if DEBUG_FORTH_WORDS_KEY 
25f2						DMARK "CBA" 
25f2 f5				push af  
25f3 3a 07 26			ld a, (.dmark)  
25f6 32 b4 fb			ld (debug_mark),a  
25f9 3a 08 26			ld a, (.dmark+1)  
25fc 32 b5 fb			ld (debug_mark+1),a  
25ff 3a 09 26			ld a, (.dmark+2)  
2602 32 b6 fb			ld (debug_mark+2),a  
2605 18 03			jr .pastdmark  
2607 ..			.dmark: db "CBA"  
260a f1			.pastdmark: pop af  
260b			endm  
# End of macro DMARK
260b						CALLMONITOR 
260b cd 3d 17			call break_point_state  
260e				endm  
# End of macro CALLMONITOR
260e					endif 
260e c3 d7 25				jp .storebyteat 
2611					NEXTW 
2611 c3 36 20			jp macro_next 
2614				endm 
# End of macro NEXTW
2614			.SCALL: 
2614				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2614 23				db WORD_SYS_CORE+OPCODE_SCALL             
2615 48 26			dw .DEPTH            
2617 05				db 4 + 1 
2618 .. 00			db "CALL",0              
261d				endm 
# End of macro CWHEAD
261d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
261d					if DEBUG_FORTH_WORDS_KEY 
261d						DMARK "CLL" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 b4 fb			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 b5 fb			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 b6 fb			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db "CLL"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636						CALLMONITOR 
2636 cd 3d 17			call break_point_state  
2639				endm  
# End of macro CALLMONITOR
2639					endif 
2639			 
2639					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2639 cd c4 1e			call macro_dsp_valuehl 
263c				endm 
# End of macro FORTH_DSP_VALUEHL
263c			 
263c			;		push hl 
263c			 
263c					; destroy value TOS 
263c			 
263c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
263c cd 7c 1f			call macro_forth_dsp_pop 
263f				endm 
# End of macro FORTH_DSP_POP
263f			 
263f						 
263f			;		pop hl 
263f			 
263f					; how to do a call with hl???? save SP? 
263f cd df 1f				call forth_call_hl 
2642			 
2642			 
2642					; TODO push value back onto stack for another op etc 
2642			 
2642 cd cd 1c				call forth_push_numhl 
2645					NEXTW 
2645 c3 36 20			jp macro_next 
2648				endm 
# End of macro NEXTW
2648			.DEPTH: 
2648				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2648 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2649 85 26			dw .OVER            
264b 06				db 5 + 1 
264c .. 00			db "DEPTH",0              
2652				endm 
# End of macro CWHEAD
2652			; | DEPTH ( -- u ) Push count of stack | DONE 
2652					; take current TOS and remove from base value div by two to get count 
2652					if DEBUG_FORTH_WORDS_KEY 
2652						DMARK "DEP" 
2652 f5				push af  
2653 3a 67 26			ld a, (.dmark)  
2656 32 b4 fb			ld (debug_mark),a  
2659 3a 68 26			ld a, (.dmark+1)  
265c 32 b5 fb			ld (debug_mark+1),a  
265f 3a 69 26			ld a, (.dmark+2)  
2662 32 b6 fb			ld (debug_mark+2),a  
2665 18 03			jr .pastdmark  
2667 ..			.dmark: db "DEP"  
266a f1			.pastdmark: pop af  
266b			endm  
# End of macro DMARK
266b						CALLMONITOR 
266b cd 3d 17			call break_point_state  
266e				endm  
# End of macro CALLMONITOR
266e					endif 
266e			 
266e			 
266e 2a 87 f9			ld hl, (cli_data_sp) 
2671 11 01 f5			ld de, cli_data_stack 
2674 ed 52			sbc hl,de 
2676				 
2676				; div by size of stack item 
2676			 
2676 5d				ld e,l 
2677 0e 03			ld c, 3 
2679 cd a8 0c			call Div8 
267c			 
267c 6f				ld l,a 
267d 26 00			ld h,0 
267f			 
267f				;srl h 
267f				;rr l 
267f			 
267f cd cd 1c				call forth_push_numhl 
2682					NEXTW 
2682 c3 36 20			jp macro_next 
2685				endm 
# End of macro NEXTW
2685			.OVER: 
2685				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2685 42				db WORD_SYS_CORE+46             
2686 cc 26			dw .PAUSE            
2688 05				db 4 + 1 
2689 .. 00			db "OVER",0              
268e				endm 
# End of macro CWHEAD
268e			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
268e					if DEBUG_FORTH_WORDS_KEY 
268e						DMARK "OVR" 
268e f5				push af  
268f 3a a3 26			ld a, (.dmark)  
2692 32 b4 fb			ld (debug_mark),a  
2695 3a a4 26			ld a, (.dmark+1)  
2698 32 b5 fb			ld (debug_mark+1),a  
269b 3a a5 26			ld a, (.dmark+2)  
269e 32 b6 fb			ld (debug_mark+2),a  
26a1 18 03			jr .pastdmark  
26a3 ..			.dmark: db "OVR"  
26a6 f1			.pastdmark: pop af  
26a7			endm  
# End of macro DMARK
26a7						CALLMONITOR 
26a7 cd 3d 17			call break_point_state  
26aa				endm  
# End of macro CALLMONITOR
26aa					endif 
26aa			 
26aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26aa cd c4 1e			call macro_dsp_valuehl 
26ad				endm 
# End of macro FORTH_DSP_VALUEHL
26ad e5					push hl    ; n2 
26ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ae cd 7c 1f			call macro_forth_dsp_pop 
26b1				endm 
# End of macro FORTH_DSP_POP
26b1			 
26b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b1 cd c4 1e			call macro_dsp_valuehl 
26b4				endm 
# End of macro FORTH_DSP_VALUEHL
26b4 e5					push hl    ; n1 
26b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b5 cd 7c 1f			call macro_forth_dsp_pop 
26b8				endm 
# End of macro FORTH_DSP_POP
26b8			 
26b8 d1					pop de     ; n1 
26b9 e1					pop hl     ; n2 
26ba			 
26ba d5					push de 
26bb e5					push hl 
26bc d5					push de 
26bd			 
26bd					; push back  
26bd			 
26bd e1					pop hl 
26be cd cd 1c				call forth_push_numhl 
26c1 e1					pop hl 
26c2 cd cd 1c				call forth_push_numhl 
26c5 e1					pop hl 
26c6 cd cd 1c				call forth_push_numhl 
26c9					NEXTW 
26c9 c3 36 20			jp macro_next 
26cc				endm 
# End of macro NEXTW
26cc			 
26cc			.PAUSE: 
26cc				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26cc 43				db WORD_SYS_CORE+47             
26cd 01 27			dw .PAUSES            
26cf 08				db 7 + 1 
26d0 .. 00			db "PAUSEMS",0              
26d8				endm 
# End of macro CWHEAD
26d8			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26d8					if DEBUG_FORTH_WORDS_KEY 
26d8						DMARK "PMS" 
26d8 f5				push af  
26d9 3a ed 26			ld a, (.dmark)  
26dc 32 b4 fb			ld (debug_mark),a  
26df 3a ee 26			ld a, (.dmark+1)  
26e2 32 b5 fb			ld (debug_mark+1),a  
26e5 3a ef 26			ld a, (.dmark+2)  
26e8 32 b6 fb			ld (debug_mark+2),a  
26eb 18 03			jr .pastdmark  
26ed ..			.dmark: db "PMS"  
26f0 f1			.pastdmark: pop af  
26f1			endm  
# End of macro DMARK
26f1						CALLMONITOR 
26f1 cd 3d 17			call break_point_state  
26f4				endm  
# End of macro CALLMONITOR
26f4					endif 
26f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f4 cd c4 1e			call macro_dsp_valuehl 
26f7				endm 
# End of macro FORTH_DSP_VALUEHL
26f7			;		push hl    ; n2 
26f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f7 cd 7c 1f			call macro_forth_dsp_pop 
26fa				endm 
# End of macro FORTH_DSP_POP
26fa			;		pop hl 
26fa			 
26fa 7d					ld a, l 
26fb cd 46 0a				call aDelayInMS 
26fe				       NEXTW 
26fe c3 36 20			jp macro_next 
2701				endm 
# End of macro NEXTW
2701			.PAUSES:  
2701				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2701 44				db WORD_SYS_CORE+48             
2702 70 27			dw .ROT            
2704 06				db 5 + 1 
2705 .. 00			db "PAUSE",0              
270b				endm 
# End of macro CWHEAD
270b			; | PAUSE ( n -- )  Pause for n seconds | DONE 
270b					if DEBUG_FORTH_WORDS_KEY 
270b						DMARK "PAU" 
270b f5				push af  
270c 3a 20 27			ld a, (.dmark)  
270f 32 b4 fb			ld (debug_mark),a  
2712 3a 21 27			ld a, (.dmark+1)  
2715 32 b5 fb			ld (debug_mark+1),a  
2718 3a 22 27			ld a, (.dmark+2)  
271b 32 b6 fb			ld (debug_mark+2),a  
271e 18 03			jr .pastdmark  
2720 ..			.dmark: db "PAU"  
2723 f1			.pastdmark: pop af  
2724			endm  
# End of macro DMARK
2724						CALLMONITOR 
2724 cd 3d 17			call break_point_state  
2727				endm  
# End of macro CALLMONITOR
2727					endif 
2727					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2727 cd c4 1e			call macro_dsp_valuehl 
272a				endm 
# End of macro FORTH_DSP_VALUEHL
272a			;		push hl    ; n2 
272a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
272a cd 7c 1f			call macro_forth_dsp_pop 
272d				endm 
# End of macro FORTH_DSP_POP
272d			;		pop hl 
272d 45					ld b, l 
272e					if DEBUG_FORTH_WORDS 
272e						DMARK "PAU" 
272e f5				push af  
272f 3a 43 27			ld a, (.dmark)  
2732 32 b4 fb			ld (debug_mark),a  
2735 3a 44 27			ld a, (.dmark+1)  
2738 32 b5 fb			ld (debug_mark+1),a  
273b 3a 45 27			ld a, (.dmark+2)  
273e 32 b6 fb			ld (debug_mark+2),a  
2741 18 03			jr .pastdmark  
2743 ..			.dmark: db "PAU"  
2746 f1			.pastdmark: pop af  
2747			endm  
# End of macro DMARK
2747						CALLMONITOR 
2747 cd 3d 17			call break_point_state  
274a				endm  
# End of macro CALLMONITOR
274a					endif 
274a c5			.pauses1:	push bc 
274b cd 61 0a				call delay1s 
274e c1					pop bc 
274f					if DEBUG_FORTH_WORDS 
274f						DMARK "PA1" 
274f f5				push af  
2750 3a 64 27			ld a, (.dmark)  
2753 32 b4 fb			ld (debug_mark),a  
2756 3a 65 27			ld a, (.dmark+1)  
2759 32 b5 fb			ld (debug_mark+1),a  
275c 3a 66 27			ld a, (.dmark+2)  
275f 32 b6 fb			ld (debug_mark+2),a  
2762 18 03			jr .pastdmark  
2764 ..			.dmark: db "PA1"  
2767 f1			.pastdmark: pop af  
2768			endm  
# End of macro DMARK
2768						CALLMONITOR 
2768 cd 3d 17			call break_point_state  
276b				endm  
# End of macro CALLMONITOR
276b					endif 
276b 10 dd				djnz .pauses1 
276d			 
276d				       NEXTW 
276d c3 36 20			jp macro_next 
2770				endm 
# End of macro NEXTW
2770			.ROT: 
2770				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2770 45				db WORD_SYS_CORE+49             
2771 be 27			dw .UWORDS            
2773 04				db 3 + 1 
2774 .. 00			db "ROT",0              
2778				endm 
# End of macro CWHEAD
2778			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2778					if DEBUG_FORTH_WORDS_KEY 
2778						DMARK "ROT" 
2778 f5				push af  
2779 3a 8d 27			ld a, (.dmark)  
277c 32 b4 fb			ld (debug_mark),a  
277f 3a 8e 27			ld a, (.dmark+1)  
2782 32 b5 fb			ld (debug_mark+1),a  
2785 3a 8f 27			ld a, (.dmark+2)  
2788 32 b6 fb			ld (debug_mark+2),a  
278b 18 03			jr .pastdmark  
278d ..			.dmark: db "ROT"  
2790 f1			.pastdmark: pop af  
2791			endm  
# End of macro DMARK
2791						CALLMONITOR 
2791 cd 3d 17			call break_point_state  
2794				endm  
# End of macro CALLMONITOR
2794					endif 
2794			 
2794					FORTH_DSP_VALUEHL 
2794 cd c4 1e			call macro_dsp_valuehl 
2797				endm 
# End of macro FORTH_DSP_VALUEHL
2797 e5					push hl    ; u3  
2798			 
2798					FORTH_DSP_POP 
2798 cd 7c 1f			call macro_forth_dsp_pop 
279b				endm 
# End of macro FORTH_DSP_POP
279b			   
279b					FORTH_DSP_VALUEHL 
279b cd c4 1e			call macro_dsp_valuehl 
279e				endm 
# End of macro FORTH_DSP_VALUEHL
279e e5					push hl     ; u2 
279f			 
279f					FORTH_DSP_POP 
279f cd 7c 1f			call macro_forth_dsp_pop 
27a2				endm 
# End of macro FORTH_DSP_POP
27a2			 
27a2					FORTH_DSP_VALUEHL 
27a2 cd c4 1e			call macro_dsp_valuehl 
27a5				endm 
# End of macro FORTH_DSP_VALUEHL
27a5 e5					push hl     ; u1 
27a6			 
27a6					FORTH_DSP_POP 
27a6 cd 7c 1f			call macro_forth_dsp_pop 
27a9				endm 
# End of macro FORTH_DSP_POP
27a9			 
27a9 c1					pop bc      ; u1 
27aa e1					pop hl      ; u2 
27ab d1					pop de      ; u3 
27ac			 
27ac			 
27ac c5					push bc 
27ad d5					push de 
27ae e5					push hl 
27af			 
27af			 
27af e1					pop hl 
27b0 cd cd 1c				call forth_push_numhl 
27b3			 
27b3 e1					pop hl 
27b4 cd cd 1c				call forth_push_numhl 
27b7			 
27b7 e1					pop hl 
27b8 cd cd 1c				call forth_push_numhl 
27bb					 
27bb			 
27bb			 
27bb			 
27bb			 
27bb			 
27bb				       NEXTW 
27bb c3 36 20			jp macro_next 
27be				endm 
# End of macro NEXTW
27be			 
27be			.UWORDS: 
27be				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27be 50				db WORD_SYS_CORE+60             
27bf 80 28			dw .BP            
27c1 07				db 6 + 1 
27c2 .. 00			db "UWORDS",0              
27c9				endm 
# End of macro CWHEAD
27c9			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27c9			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27c9			; | | Following the count are the individual words. 
27c9			; | | 
27c9			; | | e.g. UWORDS 
27c9			; | | BOX DIRLIST 2 
27c9			; | |  
27c9			; | | Can be used to save the words to storage via: 
27c9			; | | UWORDS $01 DO $01 APPEND LOOP 
27c9				if DEBUG_FORTH_WORDS_KEY 
27c9					DMARK "UWR" 
27c9 f5				push af  
27ca 3a de 27			ld a, (.dmark)  
27cd 32 b4 fb			ld (debug_mark),a  
27d0 3a df 27			ld a, (.dmark+1)  
27d3 32 b5 fb			ld (debug_mark+1),a  
27d6 3a e0 27			ld a, (.dmark+2)  
27d9 32 b6 fb			ld (debug_mark+2),a  
27dc 18 03			jr .pastdmark  
27de ..			.dmark: db "UWR"  
27e1 f1			.pastdmark: pop af  
27e2			endm  
# End of macro DMARK
27e2					CALLMONITOR 
27e2 cd 3d 17			call break_point_state  
27e5				endm  
# End of macro CALLMONITOR
27e5				endif 
27e5 21 00 80				ld hl, baseram 
27e8					;ld hl, baseusermem 
27e8 01 00 00				ld bc, 0    ; start a counter 
27eb			 
27eb				; skip dict stub 
27eb			 
27eb cd 87 21				call forth_tok_next 
27ee			 
27ee			 
27ee			; while we have words to look for 
27ee			 
27ee 7e			.douscan:	ld a, (hl)      
27ef				if DEBUG_FORTH_WORDS 
27ef					DMARK "UWs" 
27ef f5				push af  
27f0 3a 04 28			ld a, (.dmark)  
27f3 32 b4 fb			ld (debug_mark),a  
27f6 3a 05 28			ld a, (.dmark+1)  
27f9 32 b5 fb			ld (debug_mark+1),a  
27fc 3a 06 28			ld a, (.dmark+2)  
27ff 32 b6 fb			ld (debug_mark+2),a  
2802 18 03			jr .pastdmark  
2804 ..			.dmark: db "UWs"  
2807 f1			.pastdmark: pop af  
2808			endm  
# End of macro DMARK
2808					CALLMONITOR 
2808 cd 3d 17			call break_point_state  
280b				endm  
# End of macro CALLMONITOR
280b				endif 
280b fe 00				cp WORD_SYS_END 
280d 28 4d				jr z, .udone 
280f fe 01				cp WORD_SYS_UWORD 
2811 20 44				jr nz, .nuword 
2813			 
2813				if DEBUG_FORTH_WORDS 
2813					DMARK "UWu" 
2813 f5				push af  
2814 3a 28 28			ld a, (.dmark)  
2817 32 b4 fb			ld (debug_mark),a  
281a 3a 29 28			ld a, (.dmark+1)  
281d 32 b5 fb			ld (debug_mark+1),a  
2820 3a 2a 28			ld a, (.dmark+2)  
2823 32 b6 fb			ld (debug_mark+2),a  
2826 18 03			jr .pastdmark  
2828 ..			.dmark: db "UWu"  
282b f1			.pastdmark: pop af  
282c			endm  
# End of macro DMARK
282c					CALLMONITOR 
282c cd 3d 17			call break_point_state  
282f				endm  
# End of macro CALLMONITOR
282f				endif 
282f					; we have a uword so push its name to the stack 
282f			 
282f e5				   	push hl  ; save so we can move to next dict block 
2830			 
2830					; skip opcode 
2830 23					inc hl  
2831					; skip next ptr 
2831 23					inc hl  
2832 23					inc hl 
2833					; skip len 
2833 23					inc hl 
2834				if DEBUG_FORTH_WORDS 
2834					DMARK "UWt" 
2834 f5				push af  
2835 3a 49 28			ld a, (.dmark)  
2838 32 b4 fb			ld (debug_mark),a  
283b 3a 4a 28			ld a, (.dmark+1)  
283e 32 b5 fb			ld (debug_mark+1),a  
2841 3a 4b 28			ld a, (.dmark+2)  
2844 32 b6 fb			ld (debug_mark+2),a  
2847 18 03			jr .pastdmark  
2849 ..			.dmark: db "UWt"  
284c f1			.pastdmark: pop af  
284d			endm  
# End of macro DMARK
284d					CALLMONITOR 
284d cd 3d 17			call break_point_state  
2850				endm  
# End of macro CALLMONITOR
2850				endif 
2850 03					inc bc 
2851			 
2851 c5					push bc 
2852 cd 3b 1d				call forth_push_str 
2855 c1					pop bc 
2856			 
2856 e1					pop hl 	 
2857			 
2857 cd 87 21		.nuword:	call forth_tok_next 
285a 18 92				jr .douscan  
285c			 
285c			.udone:		 ; push count of uwords found 
285c c5					push bc 
285d e1					pop hl 
285e			 
285e				if DEBUG_FORTH_WORDS 
285e					DMARK "UWc" 
285e f5				push af  
285f 3a 73 28			ld a, (.dmark)  
2862 32 b4 fb			ld (debug_mark),a  
2865 3a 74 28			ld a, (.dmark+1)  
2868 32 b5 fb			ld (debug_mark+1),a  
286b 3a 75 28			ld a, (.dmark+2)  
286e 32 b6 fb			ld (debug_mark+2),a  
2871 18 03			jr .pastdmark  
2873 ..			.dmark: db "UWc"  
2876 f1			.pastdmark: pop af  
2877			endm  
# End of macro DMARK
2877					CALLMONITOR 
2877 cd 3d 17			call break_point_state  
287a				endm  
# End of macro CALLMONITOR
287a				endif 
287a cd cd 1c				call forth_push_numhl 
287d			 
287d			 
287d				       NEXTW 
287d c3 36 20			jp macro_next 
2880				endm 
# End of macro NEXTW
2880			 
2880			.BP: 
2880				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2880 54				db WORD_SYS_CORE+64             
2881 b6 28			dw .MONITOR            
2883 03				db 2 + 1 
2884 .. 00			db "BP",0              
2887				endm 
# End of macro CWHEAD
2887			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2887			; | | $00 Will enable the break points within specific code paths 
2887			; | | $01 Will disable break points 
2887			; | |  
2887			; | | By default break points are off. Either the above can be used to enable them 
2887			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2887			; | | and on release of the pressed key a message will be disaplayed to notify 
2887			; | | that break points are enabled. Pressing any key will then continue boot process. 
2887					; get byte count 
2887					if DEBUG_FORTH_WORDS_KEY 
2887						DMARK "BP." 
2887 f5				push af  
2888 3a 9c 28			ld a, (.dmark)  
288b 32 b4 fb			ld (debug_mark),a  
288e 3a 9d 28			ld a, (.dmark+1)  
2891 32 b5 fb			ld (debug_mark+1),a  
2894 3a 9e 28			ld a, (.dmark+2)  
2897 32 b6 fb			ld (debug_mark+2),a  
289a 18 03			jr .pastdmark  
289c ..			.dmark: db "BP."  
289f f1			.pastdmark: pop af  
28a0			endm  
# End of macro DMARK
28a0						CALLMONITOR 
28a0 cd 3d 17			call break_point_state  
28a3				endm  
# End of macro CALLMONITOR
28a3					endif 
28a3			 
28a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28a3 cd c4 1e			call macro_dsp_valuehl 
28a6				endm 
# End of macro FORTH_DSP_VALUEHL
28a6			 
28a6			;		push hl 
28a6			 
28a6					; destroy value TOS 
28a6			 
28a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28a6 cd 7c 1f			call macro_forth_dsp_pop 
28a9				endm 
# End of macro FORTH_DSP_POP
28a9			 
28a9			;		pop hl 
28a9			 
28a9 3e 00				ld a,0 
28ab bd					cp l 
28ac 28 02				jr z, .bpset 
28ae 3e 2a				ld a, '*' 
28b0			 
28b0 32 8b ef		.bpset:		ld (os_view_disable), a 
28b3			 
28b3			 
28b3					NEXTW 
28b3 c3 36 20			jp macro_next 
28b6				endm 
# End of macro NEXTW
28b6			 
28b6			 
28b6			.MONITOR: 
28b6				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28b6 55				db WORD_SYS_CORE+65             
28b7 e9 28			dw .MALLOC            
28b9 08				db 7 + 1 
28ba .. 00			db "MONITOR",0              
28c2				endm 
# End of macro CWHEAD
28c2			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28c2			; | | At start the current various registers will be displayed with contents. 
28c2			; | | Top right corner will show the most recent debug marker seen. 
28c2			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28c2			; | | and the return stack pointer (RSP). 
28c2			; | | Pressing: 
28c2			; | |    1 - Initial screen 
28c2			; | |    2 - Display a data dump of HL 
28c2			; | |    3 - Display a data dump of DE 
28c2			; | |    4 - Display a data dump of BC 
28c2			; | |    5 - Display a data dump of HL 
28c2			; | |    6 - Display a data dump of DSP 
28c2			; | |    7 - Display a data dump of RSP 
28c2			; | |    8 - Display a data dump of what is at DSP 
28c2			; | |    9 - Display a data dump of what is at RSP 
28c2			; | |    0 - Exit monitor and continue running. This will also enable break points 
28c2			; | |    * - Disable break points 
28c2			; | |    # - Enter traditional monitor mode 
28c2			; | | 
28c2			; | | Monitor Mode 
28c2			; | | ------------ 
28c2			; | | A prompt of '>' will be shown for various commands: 
28c2			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28c2			; | |    C - Continue display a data dump from the last set address 
28c2			; | |    M xxxx - Set start of memory edit at address xx 
28c2			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28c2			; | |    Q - Return to previous 
28c2					if DEBUG_FORTH_WORDS_KEY 
28c2						DMARK "MON" 
28c2 f5				push af  
28c3 3a d7 28			ld a, (.dmark)  
28c6 32 b4 fb			ld (debug_mark),a  
28c9 3a d8 28			ld a, (.dmark+1)  
28cc 32 b5 fb			ld (debug_mark+1),a  
28cf 3a d9 28			ld a, (.dmark+2)  
28d2 32 b6 fb			ld (debug_mark+2),a  
28d5 18 03			jr .pastdmark  
28d7 ..			.dmark: db "MON"  
28da f1			.pastdmark: pop af  
28db			endm  
# End of macro DMARK
28db						CALLMONITOR 
28db cd 3d 17			call break_point_state  
28de				endm  
# End of macro CALLMONITOR
28de					endif 
28de 3e 00				ld a, 0 
28e0 32 8b ef				ld (os_view_disable), a 
28e3			 
28e3					CALLMONITOR 
28e3 cd 3d 17			call break_point_state  
28e6				endm  
# End of macro CALLMONITOR
28e6			 
28e6			;	call monitor 
28e6			 
28e6					NEXTW 
28e6 c3 36 20			jp macro_next 
28e9				endm 
# End of macro NEXTW
28e9			 
28e9			 
28e9			.MALLOC: 
28e9				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28e9 56				db WORD_SYS_CORE+66             
28ea 12 29			dw .MALLOC2            
28ec 06				db 5 + 1 
28ed .. 00			db "ALLOT",0              
28f3				endm 
# End of macro CWHEAD
28f3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28f3					if DEBUG_FORTH_WORDS_KEY 
28f3						DMARK "ALL" 
28f3 f5				push af  
28f4 3a 08 29			ld a, (.dmark)  
28f7 32 b4 fb			ld (debug_mark),a  
28fa 3a 09 29			ld a, (.dmark+1)  
28fd 32 b5 fb			ld (debug_mark+1),a  
2900 3a 0a 29			ld a, (.dmark+2)  
2903 32 b6 fb			ld (debug_mark+2),a  
2906 18 03			jr .pastdmark  
2908 ..			.dmark: db "ALL"  
290b f1			.pastdmark: pop af  
290c			endm  
# End of macro DMARK
290c						CALLMONITOR 
290c cd 3d 17			call break_point_state  
290f				endm  
# End of macro CALLMONITOR
290f					endif 
290f c3 39 29				jp .mallocc 
2912			.MALLOC2: 
2912				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2912 56				db WORD_SYS_CORE+66             
2913 50 29			dw .FREE            
2915 07				db 6 + 1 
2916 .. 00			db "MALLOC",0              
291d				endm 
# End of macro CWHEAD
291d			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
291d					; get byte count 
291d					if DEBUG_FORTH_WORDS_KEY 
291d						DMARK "MAL" 
291d f5				push af  
291e 3a 32 29			ld a, (.dmark)  
2921 32 b4 fb			ld (debug_mark),a  
2924 3a 33 29			ld a, (.dmark+1)  
2927 32 b5 fb			ld (debug_mark+1),a  
292a 3a 34 29			ld a, (.dmark+2)  
292d 32 b6 fb			ld (debug_mark+2),a  
2930 18 03			jr .pastdmark  
2932 ..			.dmark: db "MAL"  
2935 f1			.pastdmark: pop af  
2936			endm  
# End of macro DMARK
2936						CALLMONITOR 
2936 cd 3d 17			call break_point_state  
2939				endm  
# End of macro CALLMONITOR
2939					endif 
2939			.mallocc: 
2939					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2939 cd c4 1e			call macro_dsp_valuehl 
293c				endm 
# End of macro FORTH_DSP_VALUEHL
293c			 
293c			;		push hl 
293c			 
293c					; destroy value TOS 
293c			 
293c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
293c cd 7c 1f			call macro_forth_dsp_pop 
293f				endm 
# End of macro FORTH_DSP_POP
293f			 
293f			;		pop hl 
293f cd df 11				call malloc 
2942				if DEBUG_FORTH_MALLOC_GUARD 
2942 f5					push af 
2943 cd 41 0d				call ishlzero 
2946			;		ld a, l 
2946			;		add h 
2946			;		cp 0 
2946 f1					pop af 
2947					 
2947 cc cf 51				call z,malloc_error 
294a				endif 
294a			 
294a cd cd 1c				call forth_push_numhl 
294d					NEXTW 
294d c3 36 20			jp macro_next 
2950				endm 
# End of macro NEXTW
2950			 
2950			.FREE: 
2950				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2950 57				db WORD_SYS_CORE+67             
2951 81 29			dw .LIST            
2953 05				db 4 + 1 
2954 .. 00			db "FREE",0              
2959				endm 
# End of macro CWHEAD
2959			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2959					if DEBUG_FORTH_WORDS_KEY 
2959						DMARK "FRE" 
2959 f5				push af  
295a 3a 6e 29			ld a, (.dmark)  
295d 32 b4 fb			ld (debug_mark),a  
2960 3a 6f 29			ld a, (.dmark+1)  
2963 32 b5 fb			ld (debug_mark+1),a  
2966 3a 70 29			ld a, (.dmark+2)  
2969 32 b6 fb			ld (debug_mark+2),a  
296c 18 03			jr .pastdmark  
296e ..			.dmark: db "FRE"  
2971 f1			.pastdmark: pop af  
2972			endm  
# End of macro DMARK
2972						CALLMONITOR 
2972 cd 3d 17			call break_point_state  
2975				endm  
# End of macro CALLMONITOR
2975					endif 
2975					; get address 
2975			 
2975					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2975 cd c4 1e			call macro_dsp_valuehl 
2978				endm 
# End of macro FORTH_DSP_VALUEHL
2978			 
2978			;		push hl 
2978			 
2978					; destroy value TOS 
2978			 
2978					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2978 cd 7c 1f			call macro_forth_dsp_pop 
297b				endm 
# End of macro FORTH_DSP_POP
297b			 
297b			;		pop hl 
297b			if FORTH_ENABLE_MALLOCFREE 
297b cd a9 12				call free 
297e			endif 
297e					NEXTW 
297e c3 36 20			jp macro_next 
2981				endm 
# End of macro NEXTW
2981			.LIST: 
2981				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2981 5c				db WORD_SYS_CORE+72             
2982 6f 2b			dw .FORGET            
2984 05				db 4 + 1 
2985 .. 00			db "LIST",0              
298a				endm 
# End of macro CWHEAD
298a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
298a			; | | The quoted word must be in upper case. 
298a				if DEBUG_FORTH_WORDS_KEY 
298a					DMARK "LST" 
298a f5				push af  
298b 3a 9f 29			ld a, (.dmark)  
298e 32 b4 fb			ld (debug_mark),a  
2991 3a a0 29			ld a, (.dmark+1)  
2994 32 b5 fb			ld (debug_mark+1),a  
2997 3a a1 29			ld a, (.dmark+2)  
299a 32 b6 fb			ld (debug_mark+2),a  
299d 18 03			jr .pastdmark  
299f ..			.dmark: db "LST"  
29a2 f1			.pastdmark: pop af  
29a3			endm  
# End of macro DMARK
29a3					CALLMONITOR 
29a3 cd 3d 17			call break_point_state  
29a6				endm  
# End of macro CALLMONITOR
29a6				endif 
29a6			 
29a6					FORTH_DSP_VALUEHL 
29a6 cd c4 1e			call macro_dsp_valuehl 
29a9				endm 
# End of macro FORTH_DSP_VALUEHL
29a9			 
29a9 e5					push hl 
29aa					FORTH_DSP_POP 
29aa cd 7c 1f			call macro_forth_dsp_pop 
29ad				endm 
# End of macro FORTH_DSP_POP
29ad c1					pop bc 
29ae			 
29ae			; Start format of scratch string 
29ae			 
29ae 21 9a ef				ld hl, scratch 
29b1			 
29b1 3e 3a				ld a, ':' 
29b3 77					ld (hl),a 
29b4 23					inc hl 
29b5 3e 20				ld a, ' ' 
29b7 77					ld (hl), a 
29b8			 
29b8					; Get ptr to the word we need to look up 
29b8			 
29b8			;		FORTH_DSP_VALUEHL 
29b8					;v5 FORTH_DSP_VALUE 
29b8				; TODO type check 
29b8			;		inc hl    ; Skip type check  
29b8			;		push hl 
29b8			;		ex de, hl    ; put into DE 
29b8			 
29b8			 
29b8 21 00 80				ld hl, baseram 
29bb					;ld hl, baseusermem 
29bb			 
29bb e5			push hl   ; sacreifical push 
29bc			 
29bc			.ldouscanm: 
29bc e1				pop hl 
29bd			.ldouscan: 
29bd				if DEBUG_FORTH_WORDS 
29bd					DMARK "LSs" 
29bd f5				push af  
29be 3a d2 29			ld a, (.dmark)  
29c1 32 b4 fb			ld (debug_mark),a  
29c4 3a d3 29			ld a, (.dmark+1)  
29c7 32 b5 fb			ld (debug_mark+1),a  
29ca 3a d4 29			ld a, (.dmark+2)  
29cd 32 b6 fb			ld (debug_mark+2),a  
29d0 18 03			jr .pastdmark  
29d2 ..			.dmark: db "LSs"  
29d5 f1			.pastdmark: pop af  
29d6			endm  
# End of macro DMARK
29d6					CALLMONITOR 
29d6 cd 3d 17			call break_point_state  
29d9				endm  
# End of macro CALLMONITOR
29d9				endif 
29d9				; skip dict stub 
29d9 cd 87 21				call forth_tok_next 
29dc			 
29dc			 
29dc			; while we have words to look for 
29dc			 
29dc 7e				ld a, (hl)      
29dd				if DEBUG_FORTH_WORDS 
29dd					DMARK "LSk" 
29dd f5				push af  
29de 3a f2 29			ld a, (.dmark)  
29e1 32 b4 fb			ld (debug_mark),a  
29e4 3a f3 29			ld a, (.dmark+1)  
29e7 32 b5 fb			ld (debug_mark+1),a  
29ea 3a f4 29			ld a, (.dmark+2)  
29ed 32 b6 fb			ld (debug_mark+2),a  
29f0 18 03			jr .pastdmark  
29f2 ..			.dmark: db "LSk"  
29f5 f1			.pastdmark: pop af  
29f6			endm  
# End of macro DMARK
29f6					CALLMONITOR 
29f6 cd 3d 17			call break_point_state  
29f9				endm  
# End of macro CALLMONITOR
29f9				endif 
29f9					;cp WORD_SYS_END 
29f9					;jp z, .lunotfound 
29f9			 
29f9					; if we hit non uwords then gone too far 
29f9 fe 01				cp WORD_SYS_UWORD 
29fb c2 2b 2b				jp nz, .lunotfound 
29fe			 
29fe				if DEBUG_FORTH_WORDS 
29fe					DMARK "LSu" 
29fe f5				push af  
29ff 3a 13 2a			ld a, (.dmark)  
2a02 32 b4 fb			ld (debug_mark),a  
2a05 3a 14 2a			ld a, (.dmark+1)  
2a08 32 b5 fb			ld (debug_mark+1),a  
2a0b 3a 15 2a			ld a, (.dmark+2)  
2a0e 32 b6 fb			ld (debug_mark+2),a  
2a11 18 03			jr .pastdmark  
2a13 ..			.dmark: db "LSu"  
2a16 f1			.pastdmark: pop af  
2a17			endm  
# End of macro DMARK
2a17					CALLMONITOR 
2a17 cd 3d 17			call break_point_state  
2a1a				endm  
# End of macro CALLMONITOR
2a1a				endif 
2a1a			 
2a1a					; found a uword but is it the one we want... 
2a1a			 
2a1a c5					push bc     ; uword to find is on bc 
2a1b d1					pop de 
2a1c			 
2a1c e5					push hl  ; to save the ptr 
2a1d			 
2a1d					; skip opcode 
2a1d 23					inc hl  
2a1e					; skip next ptr 
2a1e 23					inc hl  
2a1f 23					inc hl 
2a20					; skip len 
2a20 23					inc hl 
2a21			 
2a21				if DEBUG_FORTH_WORDS 
2a21					DMARK "LSc" 
2a21 f5				push af  
2a22 3a 36 2a			ld a, (.dmark)  
2a25 32 b4 fb			ld (debug_mark),a  
2a28 3a 37 2a			ld a, (.dmark+1)  
2a2b 32 b5 fb			ld (debug_mark+1),a  
2a2e 3a 38 2a			ld a, (.dmark+2)  
2a31 32 b6 fb			ld (debug_mark+2),a  
2a34 18 03			jr .pastdmark  
2a36 ..			.dmark: db "LSc"  
2a39 f1			.pastdmark: pop af  
2a3a			endm  
# End of macro DMARK
2a3a					CALLMONITOR 
2a3a cd 3d 17			call break_point_state  
2a3d				endm  
# End of macro CALLMONITOR
2a3d				endif 
2a3d cd ae 11				call strcmp 
2a40 c2 bc 29				jp nz, .ldouscanm 
2a43				 
2a43			 
2a43			 
2a43					; we have a uword so push its name to the stack 
2a43			 
2a43			;	   	push hl  ; save so we can move to next dict block 
2a43 e1			pop hl 
2a44			 
2a44				if DEBUG_FORTH_WORDS 
2a44					DMARK "LSm" 
2a44 f5				push af  
2a45 3a 59 2a			ld a, (.dmark)  
2a48 32 b4 fb			ld (debug_mark),a  
2a4b 3a 5a 2a			ld a, (.dmark+1)  
2a4e 32 b5 fb			ld (debug_mark+1),a  
2a51 3a 5b 2a			ld a, (.dmark+2)  
2a54 32 b6 fb			ld (debug_mark+2),a  
2a57 18 03			jr .pastdmark  
2a59 ..			.dmark: db "LSm"  
2a5c f1			.pastdmark: pop af  
2a5d			endm  
# End of macro DMARK
2a5d					CALLMONITOR 
2a5d cd 3d 17			call break_point_state  
2a60				endm  
# End of macro CALLMONITOR
2a60				endif 
2a60			 
2a60					; skip opcode 
2a60 23					inc hl  
2a61					; skip next ptr 
2a61 23					inc hl  
2a62 23					inc hl 
2a63					; skip len 
2a63 7e					ld a, (hl)   ; save length to add 
2a64				if DEBUG_FORTH_WORDS 
2a64					DMARK "LS2" 
2a64 f5				push af  
2a65 3a 79 2a			ld a, (.dmark)  
2a68 32 b4 fb			ld (debug_mark),a  
2a6b 3a 7a 2a			ld a, (.dmark+1)  
2a6e 32 b5 fb			ld (debug_mark+1),a  
2a71 3a 7b 2a			ld a, (.dmark+2)  
2a74 32 b6 fb			ld (debug_mark+2),a  
2a77 18 03			jr .pastdmark  
2a79 ..			.dmark: db "LS2"  
2a7c f1			.pastdmark: pop af  
2a7d			endm  
# End of macro DMARK
2a7d					CALLMONITOR 
2a7d cd 3d 17			call break_point_state  
2a80				endm  
# End of macro CALLMONITOR
2a80				endif 
2a80			 
2a80					; save this location 
2a80				 
2a80 e5					push hl 
2a81			 
2a81 23					inc hl 
2a82 11 9c ef				ld de, scratch+2 
2a85 4f					ld c, a 
2a86 06 00				ld b, 0 
2a88			 
2a88				if DEBUG_FORTH_WORDS 
2a88					DMARK "LSn" 
2a88 f5				push af  
2a89 3a 9d 2a			ld a, (.dmark)  
2a8c 32 b4 fb			ld (debug_mark),a  
2a8f 3a 9e 2a			ld a, (.dmark+1)  
2a92 32 b5 fb			ld (debug_mark+1),a  
2a95 3a 9f 2a			ld a, (.dmark+2)  
2a98 32 b6 fb			ld (debug_mark+2),a  
2a9b 18 03			jr .pastdmark  
2a9d ..			.dmark: db "LSn"  
2aa0 f1			.pastdmark: pop af  
2aa1			endm  
# End of macro DMARK
2aa1					CALLMONITOR 
2aa1 cd 3d 17			call break_point_state  
2aa4				endm  
# End of macro CALLMONITOR
2aa4				endif 
2aa4			 
2aa4					; copy uword name to scratch 
2aa4			 
2aa4 ed b0				ldir 
2aa6			 
2aa6 1b					dec de 
2aa7 3e 20				ld a, ' '    ; change null to space 
2aa9 12					ld (de), a 
2aaa			 
2aaa 13					inc de 
2aab			 
2aab d5					push de 
2aac c1					pop bc     ; move scratch pointer to end of word name and save it 
2aad			 
2aad e1					pop hl 
2aae 7e					ld a, (hl) 
2aaf					;inc hl 
2aaf					; skip word string 
2aaf cd 18 0d				call addatohl 
2ab2			 
2ab2 23					inc hl 
2ab3			 
2ab3				if DEBUG_FORTH_WORDS 
2ab3					DMARK "LS3" 
2ab3 f5				push af  
2ab4 3a c8 2a			ld a, (.dmark)  
2ab7 32 b4 fb			ld (debug_mark),a  
2aba 3a c9 2a			ld a, (.dmark+1)  
2abd 32 b5 fb			ld (debug_mark+1),a  
2ac0 3a ca 2a			ld a, (.dmark+2)  
2ac3 32 b6 fb			ld (debug_mark+2),a  
2ac6 18 03			jr .pastdmark  
2ac8 ..			.dmark: db "LS3"  
2acb f1			.pastdmark: pop af  
2acc			endm  
# End of macro DMARK
2acc					CALLMONITOR 
2acc cd 3d 17			call break_point_state  
2acf				endm  
# End of macro CALLMONITOR
2acf				endif 
2acf					; should now be at the start of the machine code to setup the eval of the uword 
2acf					; now locate the ptr to the string defintion 
2acf			 
2acf					; skip ld hl, 
2acf					; then load the ptr 
2acf			; TODO use get from hl ptr 
2acf 23					inc hl 
2ad0 5e					ld e, (hl) 
2ad1 23					inc hl 
2ad2 56					ld d, (hl) 
2ad3 eb					ex de, hl 
2ad4			 
2ad4			 
2ad4				if DEBUG_FORTH_WORDS 
2ad4					DMARK "LSt" 
2ad4 f5				push af  
2ad5 3a e9 2a			ld a, (.dmark)  
2ad8 32 b4 fb			ld (debug_mark),a  
2adb 3a ea 2a			ld a, (.dmark+1)  
2ade 32 b5 fb			ld (debug_mark+1),a  
2ae1 3a eb 2a			ld a, (.dmark+2)  
2ae4 32 b6 fb			ld (debug_mark+2),a  
2ae7 18 03			jr .pastdmark  
2ae9 ..			.dmark: db "LSt"  
2aec f1			.pastdmark: pop af  
2aed			endm  
# End of macro DMARK
2aed					CALLMONITOR 
2aed cd 3d 17			call break_point_state  
2af0				endm  
# End of macro CALLMONITOR
2af0				endif 
2af0			 
2af0			; cant push right now due to tokenised strings  
2af0			 
2af0			; get the destination of where to copy this definition to. 
2af0			 
2af0 c5					push bc 
2af1 d1					pop de 
2af2			 
2af2 7e			.listl:         ld a,(hl) 
2af3 fe 00				cp 0 
2af5 28 09				jr z, .lreplsp     ; replace zero with space 
2af7					;cp FORTH_END_BUFFER 
2af7 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2af9 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2afb				 
2afb					; just copy this char as is then 
2afb			 
2afb 12					ld (de), a 
2afc			 
2afc 23			.listnxt:	inc hl 
2afd 13					inc de 
2afe 18 f2				jr .listl 
2b00			 
2b00 3e 20		.lreplsp:	ld a,' ' 
2b02 12					ld (de), a 
2b03 18 f7				jr .listnxt 
2b05			 
2b05			; close up uword def 
2b05			 
2b05			.listdone: 
2b05 12					ld (de), a 
2b06 13					inc de 
2b07 3e 00				ld a, 0 
2b09 12					ld (de), a 
2b0a			 
2b0a			; now have def so clean up and push to stack 
2b0a			 
2b0a 21 9a ef				ld hl, scratch 
2b0d				if DEBUG_FORTH_WORDS 
2b0d					DMARK "Ltp" 
2b0d f5				push af  
2b0e 3a 22 2b			ld a, (.dmark)  
2b11 32 b4 fb			ld (debug_mark),a  
2b14 3a 23 2b			ld a, (.dmark+1)  
2b17 32 b5 fb			ld (debug_mark+1),a  
2b1a 3a 24 2b			ld a, (.dmark+2)  
2b1d 32 b6 fb			ld (debug_mark+2),a  
2b20 18 03			jr .pastdmark  
2b22 ..			.dmark: db "Ltp"  
2b25 f1			.pastdmark: pop af  
2b26			endm  
# End of macro DMARK
2b26					CALLMONITOR 
2b26 cd 3d 17			call break_point_state  
2b29				endm  
# End of macro CALLMONITOR
2b29				endif 
2b29			 
2b29 18 1f			jr .listpush 
2b2b			 
2b2b			;.lnuword:	pop hl 
2b2b			;		call forth_tok_next 
2b2b			;		jp .ldouscan  
2b2b			 
2b2b			.lunotfound:		  
2b2b			 
2b2b				if DEBUG_FORTH_WORDS 
2b2b					DMARK "LSn" 
2b2b f5				push af  
2b2c 3a 40 2b			ld a, (.dmark)  
2b2f 32 b4 fb			ld (debug_mark),a  
2b32 3a 41 2b			ld a, (.dmark+1)  
2b35 32 b5 fb			ld (debug_mark+1),a  
2b38 3a 42 2b			ld a, (.dmark+2)  
2b3b 32 b6 fb			ld (debug_mark+2),a  
2b3e 18 03			jr .pastdmark  
2b40 ..			.dmark: db "LSn"  
2b43 f1			.pastdmark: pop af  
2b44			endm  
# End of macro DMARK
2b44					CALLMONITOR 
2b44 cd 3d 17			call break_point_state  
2b47				endm  
# End of macro CALLMONITOR
2b47				endif 
2b47			 
2b47					 
2b47			;		FORTH_DSP_POP 
2b47			;		ld hl, .luno 
2b47			 
2b47					NEXTW			 
2b47 c3 36 20			jp macro_next 
2b4a				endm 
# End of macro NEXTW
2b4a			 
2b4a			.listpush: 
2b4a				if DEBUG_FORTH_WORDS 
2b4a					DMARK "LS>" 
2b4a f5				push af  
2b4b 3a 5f 2b			ld a, (.dmark)  
2b4e 32 b4 fb			ld (debug_mark),a  
2b51 3a 60 2b			ld a, (.dmark+1)  
2b54 32 b5 fb			ld (debug_mark+1),a  
2b57 3a 61 2b			ld a, (.dmark+2)  
2b5a 32 b6 fb			ld (debug_mark+2),a  
2b5d 18 03			jr .pastdmark  
2b5f ..			.dmark: db "LS>"  
2b62 f1			.pastdmark: pop af  
2b63			endm  
# End of macro DMARK
2b63					CALLMONITOR 
2b63 cd 3d 17			call break_point_state  
2b66				endm  
# End of macro CALLMONITOR
2b66				endif 
2b66 cd 3b 1d				call forth_push_str 
2b69			 
2b69			 
2b69			 
2b69					NEXTW 
2b69 c3 36 20			jp macro_next 
2b6c				endm 
# End of macro NEXTW
2b6c			 
2b6c			;.luno:    db "Word not found",0 
2b6c			 
2b6c			 
2b6c			 
2b6c			 
2b6c			 
2b6c			;		push hl   ; save pointer to start of uword def string 
2b6c			; 
2b6c			;; look for FORTH_EOL_LINE 
2b6c			;		ld a, FORTH_END_BUFFER 
2b6c			;		call strlent 
2b6c			; 
2b6c			;		inc hl		 ; space for coln def 
2b6c			;		inc hl 
2b6c			;		inc hl          ; space for terms 
2b6c			;		inc hl 
2b6c			; 
2b6c			;		ld a, 20   ; TODO get actual length 
2b6c			;		call addatohl    ; include a random amount of room for the uword name 
2b6c			; 
2b6c			;		 
2b6c			;	if DEBUG_FORTH_WORDS 
2b6c			;		DMARK "Lt1" 
2b6c			;		CALLMONITOR 
2b6c			;	endif 
2b6c			;		 
2b6c			; 
2b6c			;; malloc space for the string because we cant change it 
2b6c			; 
2b6c			;		call malloc 
2b6c			;	if DEBUG_FORTH_MALLOC_GUARD 
2b6c			;		push af 
2b6c			;		call ishlzero 
2b6c			;		pop af 
2b6c			;		 
2b6c			;		call z,malloc_error 
2b6c			;	endif 
2b6c			; 
2b6c			;	if DEBUG_FORTH_WORDS 
2b6c			;		DMARK "Lt2" 
2b6c			;		CALLMONITOR 
2b6c			;	endif 
2b6c			;		pop de 
2b6c			;		push hl    ; push the malloc to release later 
2b6c			;		push hl   ;  push back a copy for the later stack push 
2b6c			;		 
2b6c			;; copy the string swapping out the zero terms for spaces 
2b6c			; 
2b6c			;		; de has our source 
2b6c			;		; hl has our dest 
2b6c			; 
2b6c			;; add the coln def 
2b6c			; 
2b6c			;		ld a, ':' 
2b6c			;		ld (hl), a 
2b6c			;		inc hl 
2b6c			;		ld a, ' ' 
2b6c			;		ld (hl), a 
2b6c			;		inc hl 
2b6c			; 
2b6c			;; add the uname word 
2b6c			;		push de   ; save our string for now 
2b6c			;		ex de, hl 
2b6c			; 
2b6c			;		FORTH_DSP_VALUE 
2b6c			;		;v5 FORTH_DSP_VALUE 
2b6c			; 
2b6c			;		inc hl   ; skip type but we know by now this is OK 
2b6c			; 
2b6c			;.luword:	ld a,(hl) 
2b6c			;		cp 0 
2b6c			;		jr z, .luword2 
2b6c			;		ld (de), a 
2b6c			;		inc de 
2b6c			;		inc hl 
2b6c			;		jr .luword 
2b6c			; 
2b6c			;.luword2:	ld a, ' ' 
2b6c			;		ld (de), a 
2b6c			;;		inc hl 
2b6c			;;		inc de 
2b6c			;;		ld (de), a 
2b6c			;;		inc hl 
2b6c			;		inc de 
2b6c			; 
2b6c			;		ex de, hl 
2b6c			;		pop de 
2b6c			;		 
2b6c			;		 
2b6c			; 
2b6c			;; detoken that string and copy it 
2b6c			; 
2b6c			;	if DEBUG_FORTH_WORDS 
2b6c			;		DMARK "Lt2" 
2b6c			;		CALLMONITOR 
2b6c			;	endif 
2b6c			;.ldetok:	ld a, (de) 
2b6c			;		cp FORTH_END_BUFFER 
2b6c			;		jr z, .ldetokend 
2b6c			;		; swap out any zero term for space 
2b6c			;		cp 0 
2b6c			;		jr nz, .ldetoknext 
2b6c			;		ld a, ' ' 
2b6c			; 
2b6c			;	if DEBUG_FORTH_WORDS 
2b6c			;		DMARK "LtS" 
2b6c			;		CALLMONITOR 
2b6c			;	endif 
2b6c			;.ldetoknext:	ld (hl), a 
2b6c			;		inc de 
2b6c			;		inc hl 
2b6c			;		jr .ldetok 
2b6c			; 
2b6c			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b6c			;		ld (hl), a  
2b6c			; 
2b6c			;; free that temp malloc 
2b6c			; 
2b6c			;		pop hl    
2b6c			; 
2b6c			;	if DEBUG_FORTH_WORDS 
2b6c			;		DMARK "Lt4" 
2b6c			;		CALLMONITOR 
2b6c			;	endif 
2b6c			;		call forth_apushstrhl 
2b6c			; 
2b6c			;		; get rid of temp malloc area 
2b6c			; 
2b6c			;		pop hl 
2b6c			;		call free 
2b6c			; 
2b6c			;		jr .ludone 
2b6c			; 
2b6c			;.lnuword:	pop hl 
2b6c			;		call forth_tok_next 
2b6c			;		jp .ldouscan  
2b6c			; 
2b6c			;.ludone:		 pop hl 
2b6c			; 
2b6c					NEXTW 
2b6c c3 36 20			jp macro_next 
2b6f				endm 
# End of macro NEXTW
2b6f			 
2b6f			.FORGET: 
2b6f				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b6f 5d				db WORD_SYS_CORE+73             
2b70 e8 2b			dw .NOP            
2b72 07				db 6 + 1 
2b73 .. 00			db "FORGET",0              
2b7a				endm 
# End of macro CWHEAD
2b7a			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b7a			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b7a			; | |  
2b7a			; | | e.g. "MORE" forget 
2b7a					if DEBUG_FORTH_WORDS_KEY 
2b7a						DMARK "FRG" 
2b7a f5				push af  
2b7b 3a 8f 2b			ld a, (.dmark)  
2b7e 32 b4 fb			ld (debug_mark),a  
2b81 3a 90 2b			ld a, (.dmark+1)  
2b84 32 b5 fb			ld (debug_mark+1),a  
2b87 3a 91 2b			ld a, (.dmark+2)  
2b8a 32 b6 fb			ld (debug_mark+2),a  
2b8d 18 03			jr .pastdmark  
2b8f ..			.dmark: db "FRG"  
2b92 f1			.pastdmark: pop af  
2b93			endm  
# End of macro DMARK
2b93						CALLMONITOR 
2b93 cd 3d 17			call break_point_state  
2b96				endm  
# End of macro CALLMONITOR
2b96					endif 
2b96			 
2b96				; find uword 
2b96			        ; update start of word with "_" 
2b96				; replace uword with deleted flag 
2b96			 
2b96			 
2b96			;	if DEBUG_FORTH_WORDS 
2b96			;		DMARK "FOG" 
2b96			;		CALLMONITOR 
2b96			;	endif 
2b96			 
2b96			 
2b96					; Get ptr to the word we need to look up 
2b96			 
2b96					FORTH_DSP_VALUEHL 
2b96 cd c4 1e			call macro_dsp_valuehl 
2b99				endm 
# End of macro FORTH_DSP_VALUEHL
2b99					;v5 FORTH_DSP_VALUE 
2b99				; TODO type check 
2b99			;		inc hl    ; Skip type check  
2b99 e5					push hl 
2b9a c1					pop bc 
2b9b			;		ex de, hl    ; put into DE 
2b9b			 
2b9b			 
2b9b 21 00 80				ld hl, baseram 
2b9e					;ld hl, baseusermem 
2b9e			 
2b9e				; skip dict stub 
2b9e			;	call forth_tok_next 
2b9e e5			push hl   ; sacreifical push 
2b9f			 
2b9f			.fldouscanm: 
2b9f e1				pop hl 
2ba0			.fldouscan: 
2ba0			;	if DEBUG_FORTH_WORDS 
2ba0			;		DMARK "LSs" 
2ba0			;		CALLMONITOR 
2ba0			;	endif 
2ba0				; skip dict stub 
2ba0 cd 87 21				call forth_tok_next 
2ba3			 
2ba3			 
2ba3			; while we have words to look for 
2ba3			 
2ba3 7e				ld a, (hl)      
2ba4			;	if DEBUG_FORTH_WORDS 
2ba4			;		DMARK "LSk" 
2ba4			;		CALLMONITOR 
2ba4			;	endif 
2ba4 fe 00				cp WORD_SYS_END 
2ba6 ca e2 2b				jp z, .flunotfound 
2ba9 fe 01				cp WORD_SYS_UWORD 
2bab c2 a0 2b				jp nz, .fldouscan 
2bae			 
2bae			;	if DEBUG_FORTH_WORDS 
2bae			;		DMARK "LSu" 
2bae			;		CALLMONITOR 
2bae			;	endif 
2bae			 
2bae					; found a uword but is it the one we want... 
2bae			 
2bae c5					push bc     ; uword to find is on bc 
2baf d1					pop de 
2bb0			 
2bb0 e5					push hl  ; to save the ptr 
2bb1			 
2bb1					; skip opcode 
2bb1 23					inc hl  
2bb2					; skip next ptr 
2bb2 23					inc hl  
2bb3 23					inc hl 
2bb4					; skip len 
2bb4 23					inc hl 
2bb5			 
2bb5			;	if DEBUG_FORTH_WORDS 
2bb5			;		DMARK "LSc" 
2bb5			;		CALLMONITOR 
2bb5			;	endif 
2bb5 cd ae 11				call strcmp 
2bb8 c2 9f 2b				jp nz, .fldouscanm 
2bbb			; 
2bbb			; 
2bbb			;; while we have words to look for 
2bbb			; 
2bbb			;.fdouscan:	ld a, (hl)      
2bbb			;	if DEBUG_FORTH_WORDS 
2bbb			;		DMARK "LSs" 
2bbb			;		CALLMONITOR 
2bbb			;	endif 
2bbb			;		cp WORD_SYS_END 
2bbb			;		jp z, .fudone 
2bbb			;		cp WORD_SYS_UWORD 
2bbb			;		jp nz, .fnuword 
2bbb			; 
2bbb			;	if DEBUG_FORTH_WORDS 
2bbb			;		DMARK "FGu" 
2bbb			;		CALLMONITOR 
2bbb			;	endif 
2bbb			; 
2bbb			;		; found a uword but is it the one we want... 
2bbb			; 
2bbb			; 
2bbb			;	        pop de   ; get back the dsp name 
2bbb			;		push de 
2bbb			; 
2bbb			;		push hl  ; to save the ptr 
2bbb			; 
2bbb			;		; skip opcode 
2bbb			;		inc hl  
2bbb			;		; skip next ptr 
2bbb			;		inc hl  
2bbb			;		inc hl 
2bbb			;		; skip len 
2bbb			;		inc hl 
2bbb			; 
2bbb			;	if DEBUG_FORTH_WORDS 
2bbb			;		DMARK "FGc" 
2bbb			;		CALLMONITOR 
2bbb			;	endif 
2bbb			;		call strcmp 
2bbb			;		jp nz, .fnuword 
2bbb			 
2bbb			 
2bbb e1			pop hl 
2bbc			 
2bbc				 
2bbc				if DEBUG_FORTH_WORDS 
2bbc					DMARK "FGm" 
2bbc f5				push af  
2bbd 3a d1 2b			ld a, (.dmark)  
2bc0 32 b4 fb			ld (debug_mark),a  
2bc3 3a d2 2b			ld a, (.dmark+1)  
2bc6 32 b5 fb			ld (debug_mark+1),a  
2bc9 3a d3 2b			ld a, (.dmark+2)  
2bcc 32 b6 fb			ld (debug_mark+2),a  
2bcf 18 03			jr .pastdmark  
2bd1 ..			.dmark: db "FGm"  
2bd4 f1			.pastdmark: pop af  
2bd5			endm  
# End of macro DMARK
2bd5					CALLMONITOR 
2bd5 cd 3d 17			call break_point_state  
2bd8				endm  
# End of macro CALLMONITOR
2bd8				endif 
2bd8			 
2bd8			 
2bd8			 
2bd8					; we have a uword so push its name to the stack 
2bd8			 
2bd8			;	   	push hl  ; save so we can move to next dict block 
2bd8			;pop hl 
2bd8			 
2bd8					; update opcode to deleted 
2bd8 3e 03				ld a, WORD_SYS_DELETED 
2bda 77					ld (hl), a 
2bdb			 
2bdb 23					inc hl  
2bdc					; skip next ptr 
2bdc 23					inc hl  
2bdd 23					inc hl 
2bde					; skip len 
2bde 23					inc hl 
2bdf			 
2bdf					; TODO change parser to skip deleted words but for now mark it out 
2bdf 3e 5f				ld a, "_" 
2be1 77					ld  (hl),a 
2be2			 
2be2			;		jr .fudone 
2be2			; 
2be2			;.fnuword:	pop hl 
2be2			;		call forth_tok_next 
2be2			;		jp .fdouscan  
2be2			 
2be2			.flunotfound:		  
2be2			 
2be2			 
2be2					 
2be2					FORTH_DSP_POP 
2be2 cd 7c 1f			call macro_forth_dsp_pop 
2be5				endm 
# End of macro FORTH_DSP_POP
2be5			;		ld hl, .luno 
2be5			;.fudone:		 pop hl 
2be5					NEXTW 
2be5 c3 36 20			jp macro_next 
2be8				endm 
# End of macro NEXTW
2be8			.NOP: 
2be8				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2be8 61				db WORD_SYS_CORE+77             
2be9 0f 2c			dw .COMO            
2beb 04				db 3 + 1 
2bec .. 00			db "NOP",0              
2bf0				endm 
# End of macro CWHEAD
2bf0			; | NOP (  --  ) Do nothing | DONE 
2bf0					if DEBUG_FORTH_WORDS_KEY 
2bf0						DMARK "NOP" 
2bf0 f5				push af  
2bf1 3a 05 2c			ld a, (.dmark)  
2bf4 32 b4 fb			ld (debug_mark),a  
2bf7 3a 06 2c			ld a, (.dmark+1)  
2bfa 32 b5 fb			ld (debug_mark+1),a  
2bfd 3a 07 2c			ld a, (.dmark+2)  
2c00 32 b6 fb			ld (debug_mark+2),a  
2c03 18 03			jr .pastdmark  
2c05 ..			.dmark: db "NOP"  
2c08 f1			.pastdmark: pop af  
2c09			endm  
# End of macro DMARK
2c09						CALLMONITOR 
2c09 cd 3d 17			call break_point_state  
2c0c				endm  
# End of macro CALLMONITOR
2c0c					endif 
2c0c				       NEXTW 
2c0c c3 36 20			jp macro_next 
2c0f				endm 
# End of macro NEXTW
2c0f			.COMO: 
2c0f				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c0f 6e				db WORD_SYS_CORE+90             
2c10 61 2c			dw .COMC            
2c12 02				db 1 + 1 
2c13 .. 00			db "(",0              
2c15				endm 
# End of macro CWHEAD
2c15			; | ( ( -- )  Start of comment | DONE 
2c15			 
2c15			 
2c15 2a 9b f2				ld hl, ( os_tok_ptr) 
2c18 11 5c 2c			ld de, .closepar 
2c1b					 
2c1b					if DEBUG_FORTH_WORDS 
2c1b						DMARK ").." 
2c1b f5				push af  
2c1c 3a 30 2c			ld a, (.dmark)  
2c1f 32 b4 fb			ld (debug_mark),a  
2c22 3a 31 2c			ld a, (.dmark+1)  
2c25 32 b5 fb			ld (debug_mark+1),a  
2c28 3a 32 2c			ld a, (.dmark+2)  
2c2b 32 b6 fb			ld (debug_mark+2),a  
2c2e 18 03			jr .pastdmark  
2c30 ..			.dmark: db ").."  
2c33 f1			.pastdmark: pop af  
2c34			endm  
# End of macro DMARK
2c34						CALLMONITOR 
2c34 cd 3d 17			call break_point_state  
2c37				endm  
# End of macro CALLMONITOR
2c37					endif 
2c37 cd 51 21			call findnexttok  
2c3a			 
2c3a					if DEBUG_FORTH_WORDS 
2c3a						DMARK "IF5" 
2c3a f5				push af  
2c3b 3a 4f 2c			ld a, (.dmark)  
2c3e 32 b4 fb			ld (debug_mark),a  
2c41 3a 50 2c			ld a, (.dmark+1)  
2c44 32 b5 fb			ld (debug_mark+1),a  
2c47 3a 51 2c			ld a, (.dmark+2)  
2c4a 32 b6 fb			ld (debug_mark+2),a  
2c4d 18 03			jr .pastdmark  
2c4f ..			.dmark: db "IF5"  
2c52 f1			.pastdmark: pop af  
2c53			endm  
# End of macro DMARK
2c53						CALLMONITOR 
2c53 cd 3d 17			call break_point_state  
2c56				endm  
# End of macro CALLMONITOR
2c56					endif 
2c56				; replace below with ) exec using tok_ptr 
2c56 22 9b f2			ld (os_tok_ptr), hl 
2c59 c3 c7 20			jp exec1 
2c5c			 
2c5c .. 00			.closepar:   db ")",0 
2c5e			 
2c5e				       NEXTW 
2c5e c3 36 20			jp macro_next 
2c61				endm 
# End of macro NEXTW
2c61			.COMC: 
2c61				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c61 6f				db WORD_SYS_CORE+91             
2c62 6a 2c			dw .SCRATCH            
2c64 02				db 1 + 1 
2c65 .. 00			db ")",0              
2c67				endm 
# End of macro CWHEAD
2c67			; | ) ( -- )  End of comment |  DONE  
2c67				       NEXTW 
2c67 c3 36 20			jp macro_next 
2c6a				endm 
# End of macro NEXTW
2c6a			 
2c6a			.SCRATCH: 
2c6a				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c6a 6f				db WORD_SYS_CORE+91             
2c6b a5 2c			dw .INC            
2c6d 08				db 7 + 1 
2c6e .. 00			db "SCRATCH",0              
2c76				endm 
# End of macro CWHEAD
2c76			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c76			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c76			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c76			; | |  
2c76			; | | e.g.    : score $00 scratch ; 
2c76			; | |  
2c76			; | | $00 score ! 
2c76			; | | $01 score +! 
2c76			; | |  
2c76			; | | e.g.   : varword $0a scratch ;  
2c76			; | | 
2c76			; | | $8000 varword ! 
2c76					if DEBUG_FORTH_WORDS_KEY 
2c76						DMARK "SCR" 
2c76 f5				push af  
2c77 3a 8b 2c			ld a, (.dmark)  
2c7a 32 b4 fb			ld (debug_mark),a  
2c7d 3a 8c 2c			ld a, (.dmark+1)  
2c80 32 b5 fb			ld (debug_mark+1),a  
2c83 3a 8d 2c			ld a, (.dmark+2)  
2c86 32 b6 fb			ld (debug_mark+2),a  
2c89 18 03			jr .pastdmark  
2c8b ..			.dmark: db "SCR"  
2c8e f1			.pastdmark: pop af  
2c8f			endm  
# End of macro DMARK
2c8f						CALLMONITOR 
2c8f cd 3d 17			call break_point_state  
2c92				endm  
# End of macro CALLMONITOR
2c92					endif 
2c92			 
2c92					FORTH_DSP_VALUEHL 
2c92 cd c4 1e			call macro_dsp_valuehl 
2c95				endm 
# End of macro FORTH_DSP_VALUEHL
2c95				 
2c95					FORTH_DSP_POP 
2c95 cd 7c 1f			call macro_forth_dsp_pop 
2c98				endm 
# End of macro FORTH_DSP_POP
2c98			 
2c98 7d					ld a, l 
2c99 21 bf f4				ld hl, os_var_array 
2c9c cd 18 0d				call addatohl 
2c9f			 
2c9f cd cd 1c				call forth_push_numhl 
2ca2			 
2ca2				       NEXTW 
2ca2 c3 36 20			jp macro_next 
2ca5				endm 
# End of macro NEXTW
2ca5			 
2ca5			.INC: 
2ca5				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ca5 6f				db WORD_SYS_CORE+91             
2ca6 f9 2c			dw .DEC            
2ca8 03				db 2 + 1 
2ca9 .. 00			db "+!",0              
2cac				endm 
# End of macro CWHEAD
2cac			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2cac					if DEBUG_FORTH_WORDS_KEY 
2cac						DMARK "+s_" 
2cac f5				push af  
2cad 3a c1 2c			ld a, (.dmark)  
2cb0 32 b4 fb			ld (debug_mark),a  
2cb3 3a c2 2c			ld a, (.dmark+1)  
2cb6 32 b5 fb			ld (debug_mark+1),a  
2cb9 3a c3 2c			ld a, (.dmark+2)  
2cbc 32 b6 fb			ld (debug_mark+2),a  
2cbf 18 03			jr .pastdmark  
2cc1 ..			.dmark: db "+s_"  
2cc4 f1			.pastdmark: pop af  
2cc5			endm  
# End of macro DMARK
2cc5						CALLMONITOR 
2cc5 cd 3d 17			call break_point_state  
2cc8				endm  
# End of macro CALLMONITOR
2cc8					endif 
2cc8			 
2cc8					FORTH_DSP_VALUEHL 
2cc8 cd c4 1e			call macro_dsp_valuehl 
2ccb				endm 
# End of macro FORTH_DSP_VALUEHL
2ccb			 
2ccb e5					push hl   ; save address 
2ccc			 
2ccc					FORTH_DSP_POP 
2ccc cd 7c 1f			call macro_forth_dsp_pop 
2ccf				endm 
# End of macro FORTH_DSP_POP
2ccf			 
2ccf					FORTH_DSP_VALUEHL 
2ccf cd c4 1e			call macro_dsp_valuehl 
2cd2				endm 
# End of macro FORTH_DSP_VALUEHL
2cd2			 
2cd2					FORTH_DSP_POP 
2cd2 cd 7c 1f			call macro_forth_dsp_pop 
2cd5				endm 
# End of macro FORTH_DSP_POP
2cd5			 
2cd5					; hl contains value to add to byte at a 
2cd5				 
2cd5 eb					ex de, hl 
2cd6			 
2cd6 e1					pop hl 
2cd7			 
2cd7					if DEBUG_FORTH_WORDS 
2cd7						DMARK "INC" 
2cd7 f5				push af  
2cd8 3a ec 2c			ld a, (.dmark)  
2cdb 32 b4 fb			ld (debug_mark),a  
2cde 3a ed 2c			ld a, (.dmark+1)  
2ce1 32 b5 fb			ld (debug_mark+1),a  
2ce4 3a ee 2c			ld a, (.dmark+2)  
2ce7 32 b6 fb			ld (debug_mark+2),a  
2cea 18 03			jr .pastdmark  
2cec ..			.dmark: db "INC"  
2cef f1			.pastdmark: pop af  
2cf0			endm  
# End of macro DMARK
2cf0						CALLMONITOR 
2cf0 cd 3d 17			call break_point_state  
2cf3				endm  
# End of macro CALLMONITOR
2cf3					endif 
2cf3			 
2cf3 7e					ld a,(hl) 
2cf4 83					add e 
2cf5 77					ld (hl),a 
2cf6			 
2cf6			 
2cf6			 
2cf6				       NEXTW 
2cf6 c3 36 20			jp macro_next 
2cf9				endm 
# End of macro NEXTW
2cf9			 
2cf9			.DEC: 
2cf9				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cf9 6f				db WORD_SYS_CORE+91             
2cfa 4a 2d			dw .INC2            
2cfc 03				db 2 + 1 
2cfd .. 00			db "-!",0              
2d00				endm 
# End of macro CWHEAD
2d00			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d00					if DEBUG_FORTH_WORDS_KEY 
2d00						DMARK "-s_" 
2d00 f5				push af  
2d01 3a 15 2d			ld a, (.dmark)  
2d04 32 b4 fb			ld (debug_mark),a  
2d07 3a 16 2d			ld a, (.dmark+1)  
2d0a 32 b5 fb			ld (debug_mark+1),a  
2d0d 3a 17 2d			ld a, (.dmark+2)  
2d10 32 b6 fb			ld (debug_mark+2),a  
2d13 18 03			jr .pastdmark  
2d15 ..			.dmark: db "-s_"  
2d18 f1			.pastdmark: pop af  
2d19			endm  
# End of macro DMARK
2d19						CALLMONITOR 
2d19 cd 3d 17			call break_point_state  
2d1c				endm  
# End of macro CALLMONITOR
2d1c					endif 
2d1c			 
2d1c					FORTH_DSP_VALUEHL 
2d1c cd c4 1e			call macro_dsp_valuehl 
2d1f				endm 
# End of macro FORTH_DSP_VALUEHL
2d1f			 
2d1f e5					push hl   ; save address 
2d20			 
2d20					FORTH_DSP_POP 
2d20 cd 7c 1f			call macro_forth_dsp_pop 
2d23				endm 
# End of macro FORTH_DSP_POP
2d23			 
2d23					FORTH_DSP_VALUEHL 
2d23 cd c4 1e			call macro_dsp_valuehl 
2d26				endm 
# End of macro FORTH_DSP_VALUEHL
2d26			 
2d26					; hl contains value to add to byte at a 
2d26				 
2d26 eb					ex de, hl 
2d27			 
2d27 e1					pop hl 
2d28			 
2d28					if DEBUG_FORTH_WORDS 
2d28						DMARK "DEC" 
2d28 f5				push af  
2d29 3a 3d 2d			ld a, (.dmark)  
2d2c 32 b4 fb			ld (debug_mark),a  
2d2f 3a 3e 2d			ld a, (.dmark+1)  
2d32 32 b5 fb			ld (debug_mark+1),a  
2d35 3a 3f 2d			ld a, (.dmark+2)  
2d38 32 b6 fb			ld (debug_mark+2),a  
2d3b 18 03			jr .pastdmark  
2d3d ..			.dmark: db "DEC"  
2d40 f1			.pastdmark: pop af  
2d41			endm  
# End of macro DMARK
2d41						CALLMONITOR 
2d41 cd 3d 17			call break_point_state  
2d44				endm  
# End of macro CALLMONITOR
2d44					endif 
2d44			 
2d44 7e					ld a,(hl) 
2d45 93					sub e 
2d46 77					ld (hl),a 
2d47			 
2d47			 
2d47			 
2d47				       NEXTW 
2d47 c3 36 20			jp macro_next 
2d4a				endm 
# End of macro NEXTW
2d4a			 
2d4a			.INC2: 
2d4a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d4a 6f				db WORD_SYS_CORE+91             
2d4b f4 2d			dw .DEC2            
2d4d 04				db 3 + 1 
2d4e .. 00			db "+2!",0              
2d52				endm 
# End of macro CWHEAD
2d52			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d52			 
2d52					if DEBUG_FORTH_WORDS_KEY 
2d52						DMARK "+2s" 
2d52 f5				push af  
2d53 3a 67 2d			ld a, (.dmark)  
2d56 32 b4 fb			ld (debug_mark),a  
2d59 3a 68 2d			ld a, (.dmark+1)  
2d5c 32 b5 fb			ld (debug_mark+1),a  
2d5f 3a 69 2d			ld a, (.dmark+2)  
2d62 32 b6 fb			ld (debug_mark+2),a  
2d65 18 03			jr .pastdmark  
2d67 ..			.dmark: db "+2s"  
2d6a f1			.pastdmark: pop af  
2d6b			endm  
# End of macro DMARK
2d6b						CALLMONITOR 
2d6b cd 3d 17			call break_point_state  
2d6e				endm  
# End of macro CALLMONITOR
2d6e					endif 
2d6e			 
2d6e					; Address 
2d6e			 
2d6e					FORTH_DSP_VALUEHL 
2d6e cd c4 1e			call macro_dsp_valuehl 
2d71				endm 
# End of macro FORTH_DSP_VALUEHL
2d71			 
2d71 e5					push hl    ; save address 
2d72			 
2d72					; load content into de 
2d72			 
2d72 5e					ld e,(hl) 
2d73 23					inc hl 
2d74 56					ld d, (hl) 
2d75			 
2d75					if DEBUG_FORTH_WORDS 
2d75						DMARK "+2a" 
2d75 f5				push af  
2d76 3a 8a 2d			ld a, (.dmark)  
2d79 32 b4 fb			ld (debug_mark),a  
2d7c 3a 8b 2d			ld a, (.dmark+1)  
2d7f 32 b5 fb			ld (debug_mark+1),a  
2d82 3a 8c 2d			ld a, (.dmark+2)  
2d85 32 b6 fb			ld (debug_mark+2),a  
2d88 18 03			jr .pastdmark  
2d8a ..			.dmark: db "+2a"  
2d8d f1			.pastdmark: pop af  
2d8e			endm  
# End of macro DMARK
2d8e						CALLMONITOR 
2d8e cd 3d 17			call break_point_state  
2d91				endm  
# End of macro CALLMONITOR
2d91					endif 
2d91			 
2d91					FORTH_DSP_POP 
2d91 cd 7c 1f			call macro_forth_dsp_pop 
2d94				endm 
# End of macro FORTH_DSP_POP
2d94			 
2d94					; Get value to add 
2d94			 
2d94					FORTH_DSP_VALUE 
2d94 cd ad 1e			call macro_forth_dsp_value 
2d97				endm 
# End of macro FORTH_DSP_VALUE
2d97			 
2d97					if DEBUG_FORTH_WORDS 
2d97						DMARK "+2v" 
2d97 f5				push af  
2d98 3a ac 2d			ld a, (.dmark)  
2d9b 32 b4 fb			ld (debug_mark),a  
2d9e 3a ad 2d			ld a, (.dmark+1)  
2da1 32 b5 fb			ld (debug_mark+1),a  
2da4 3a ae 2d			ld a, (.dmark+2)  
2da7 32 b6 fb			ld (debug_mark+2),a  
2daa 18 03			jr .pastdmark  
2dac ..			.dmark: db "+2v"  
2daf f1			.pastdmark: pop af  
2db0			endm  
# End of macro DMARK
2db0						CALLMONITOR 
2db0 cd 3d 17			call break_point_state  
2db3				endm  
# End of macro CALLMONITOR
2db3					endif 
2db3			 
2db3 19					add hl, de 
2db4			 
2db4					if DEBUG_FORTH_WORDS 
2db4						DMARK "+2+" 
2db4 f5				push af  
2db5 3a c9 2d			ld a, (.dmark)  
2db8 32 b4 fb			ld (debug_mark),a  
2dbb 3a ca 2d			ld a, (.dmark+1)  
2dbe 32 b5 fb			ld (debug_mark+1),a  
2dc1 3a cb 2d			ld a, (.dmark+2)  
2dc4 32 b6 fb			ld (debug_mark+2),a  
2dc7 18 03			jr .pastdmark  
2dc9 ..			.dmark: db "+2+"  
2dcc f1			.pastdmark: pop af  
2dcd			endm  
# End of macro DMARK
2dcd						CALLMONITOR 
2dcd cd 3d 17			call break_point_state  
2dd0				endm  
# End of macro CALLMONITOR
2dd0					endif 
2dd0			 
2dd0					; move result to de 
2dd0			 
2dd0 eb					ex de, hl 
2dd1			 
2dd1					; Address 
2dd1			 
2dd1 e1					pop hl 
2dd2			 
2dd2					; save it back 
2dd2			 
2dd2 73					ld (hl), e 
2dd3 23					inc hl 
2dd4 72					ld (hl), d 
2dd5			 
2dd5					if DEBUG_FORTH_WORDS 
2dd5						DMARK "+2e" 
2dd5 f5				push af  
2dd6 3a ea 2d			ld a, (.dmark)  
2dd9 32 b4 fb			ld (debug_mark),a  
2ddc 3a eb 2d			ld a, (.dmark+1)  
2ddf 32 b5 fb			ld (debug_mark+1),a  
2de2 3a ec 2d			ld a, (.dmark+2)  
2de5 32 b6 fb			ld (debug_mark+2),a  
2de8 18 03			jr .pastdmark  
2dea ..			.dmark: db "+2e"  
2ded f1			.pastdmark: pop af  
2dee			endm  
# End of macro DMARK
2dee						CALLMONITOR 
2dee cd 3d 17			call break_point_state  
2df1				endm  
# End of macro CALLMONITOR
2df1					endif 
2df1			 
2df1			 
2df1			 
2df1			 
2df1			 
2df1				       NEXTW 
2df1 c3 36 20			jp macro_next 
2df4				endm 
# End of macro NEXTW
2df4			 
2df4			.DEC2: 
2df4				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2df4 6f				db WORD_SYS_CORE+91             
2df5 a0 2e			dw .GET2            
2df7 04				db 3 + 1 
2df8 .. 00			db "-2!",0              
2dfc				endm 
# End of macro CWHEAD
2dfc			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dfc			 
2dfc			 
2dfc					if DEBUG_FORTH_WORDS_KEY 
2dfc						DMARK "-2s" 
2dfc f5				push af  
2dfd 3a 11 2e			ld a, (.dmark)  
2e00 32 b4 fb			ld (debug_mark),a  
2e03 3a 12 2e			ld a, (.dmark+1)  
2e06 32 b5 fb			ld (debug_mark+1),a  
2e09 3a 13 2e			ld a, (.dmark+2)  
2e0c 32 b6 fb			ld (debug_mark+2),a  
2e0f 18 03			jr .pastdmark  
2e11 ..			.dmark: db "-2s"  
2e14 f1			.pastdmark: pop af  
2e15			endm  
# End of macro DMARK
2e15						CALLMONITOR 
2e15 cd 3d 17			call break_point_state  
2e18				endm  
# End of macro CALLMONITOR
2e18					endif 
2e18			 
2e18					; Address 
2e18			 
2e18					FORTH_DSP_VALUEHL 
2e18 cd c4 1e			call macro_dsp_valuehl 
2e1b				endm 
# End of macro FORTH_DSP_VALUEHL
2e1b			 
2e1b e5					push hl    ; save address 
2e1c			 
2e1c					; load content into de 
2e1c			 
2e1c 5e					ld e,(hl) 
2e1d 23					inc hl 
2e1e 56					ld d, (hl) 
2e1f			 
2e1f					if DEBUG_FORTH_WORDS 
2e1f						DMARK "-2a" 
2e1f f5				push af  
2e20 3a 34 2e			ld a, (.dmark)  
2e23 32 b4 fb			ld (debug_mark),a  
2e26 3a 35 2e			ld a, (.dmark+1)  
2e29 32 b5 fb			ld (debug_mark+1),a  
2e2c 3a 36 2e			ld a, (.dmark+2)  
2e2f 32 b6 fb			ld (debug_mark+2),a  
2e32 18 03			jr .pastdmark  
2e34 ..			.dmark: db "-2a"  
2e37 f1			.pastdmark: pop af  
2e38			endm  
# End of macro DMARK
2e38						CALLMONITOR 
2e38 cd 3d 17			call break_point_state  
2e3b				endm  
# End of macro CALLMONITOR
2e3b					endif 
2e3b			 
2e3b					FORTH_DSP_POP 
2e3b cd 7c 1f			call macro_forth_dsp_pop 
2e3e				endm 
# End of macro FORTH_DSP_POP
2e3e			 
2e3e					; Get value to remove 
2e3e			 
2e3e					FORTH_DSP_VALUE 
2e3e cd ad 1e			call macro_forth_dsp_value 
2e41				endm 
# End of macro FORTH_DSP_VALUE
2e41			 
2e41					if DEBUG_FORTH_WORDS 
2e41						DMARK "-2v" 
2e41 f5				push af  
2e42 3a 56 2e			ld a, (.dmark)  
2e45 32 b4 fb			ld (debug_mark),a  
2e48 3a 57 2e			ld a, (.dmark+1)  
2e4b 32 b5 fb			ld (debug_mark+1),a  
2e4e 3a 58 2e			ld a, (.dmark+2)  
2e51 32 b6 fb			ld (debug_mark+2),a  
2e54 18 03			jr .pastdmark  
2e56 ..			.dmark: db "-2v"  
2e59 f1			.pastdmark: pop af  
2e5a			endm  
# End of macro DMARK
2e5a						CALLMONITOR 
2e5a cd 3d 17			call break_point_state  
2e5d				endm  
# End of macro CALLMONITOR
2e5d					endif 
2e5d			 
2e5d eb					ex de, hl 
2e5e ed 52				sbc hl, de 
2e60			 
2e60					if DEBUG_FORTH_WORDS 
2e60						DMARK "-2d" 
2e60 f5				push af  
2e61 3a 75 2e			ld a, (.dmark)  
2e64 32 b4 fb			ld (debug_mark),a  
2e67 3a 76 2e			ld a, (.dmark+1)  
2e6a 32 b5 fb			ld (debug_mark+1),a  
2e6d 3a 77 2e			ld a, (.dmark+2)  
2e70 32 b6 fb			ld (debug_mark+2),a  
2e73 18 03			jr .pastdmark  
2e75 ..			.dmark: db "-2d"  
2e78 f1			.pastdmark: pop af  
2e79			endm  
# End of macro DMARK
2e79						CALLMONITOR 
2e79 cd 3d 17			call break_point_state  
2e7c				endm  
# End of macro CALLMONITOR
2e7c					endif 
2e7c			 
2e7c					; move result to de 
2e7c			 
2e7c eb					ex de, hl 
2e7d			 
2e7d					; Address 
2e7d			 
2e7d e1					pop hl 
2e7e			 
2e7e					; save it back 
2e7e			 
2e7e 73					ld (hl), e 
2e7f 23					inc hl 
2e80 72					ld (hl), d 
2e81			 
2e81					if DEBUG_FORTH_WORDS 
2e81						DMARK "-2e" 
2e81 f5				push af  
2e82 3a 96 2e			ld a, (.dmark)  
2e85 32 b4 fb			ld (debug_mark),a  
2e88 3a 97 2e			ld a, (.dmark+1)  
2e8b 32 b5 fb			ld (debug_mark+1),a  
2e8e 3a 98 2e			ld a, (.dmark+2)  
2e91 32 b6 fb			ld (debug_mark+2),a  
2e94 18 03			jr .pastdmark  
2e96 ..			.dmark: db "-2e"  
2e99 f1			.pastdmark: pop af  
2e9a			endm  
# End of macro DMARK
2e9a						CALLMONITOR 
2e9a cd 3d 17			call break_point_state  
2e9d				endm  
# End of macro CALLMONITOR
2e9d					endif 
2e9d			 
2e9d			 
2e9d			 
2e9d			 
2e9d			 
2e9d				       NEXTW 
2e9d c3 36 20			jp macro_next 
2ea0				endm 
# End of macro NEXTW
2ea0			.GET2: 
2ea0				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2ea0 6f				db WORD_SYS_CORE+91             
2ea1 d0 2e			dw .BANG2            
2ea3 03				db 2 + 1 
2ea4 .. 00			db "2@",0              
2ea7				endm 
# End of macro CWHEAD
2ea7			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ea7					if DEBUG_FORTH_WORDS_KEY 
2ea7						DMARK "2A_" 
2ea7 f5				push af  
2ea8 3a bc 2e			ld a, (.dmark)  
2eab 32 b4 fb			ld (debug_mark),a  
2eae 3a bd 2e			ld a, (.dmark+1)  
2eb1 32 b5 fb			ld (debug_mark+1),a  
2eb4 3a be 2e			ld a, (.dmark+2)  
2eb7 32 b6 fb			ld (debug_mark+2),a  
2eba 18 03			jr .pastdmark  
2ebc ..			.dmark: db "2A_"  
2ebf f1			.pastdmark: pop af  
2ec0			endm  
# End of macro DMARK
2ec0						CALLMONITOR 
2ec0 cd 3d 17			call break_point_state  
2ec3				endm  
# End of macro CALLMONITOR
2ec3					endif 
2ec3			 
2ec3					FORTH_DSP_VALUEHL 
2ec3 cd c4 1e			call macro_dsp_valuehl 
2ec6				endm 
# End of macro FORTH_DSP_VALUEHL
2ec6			 
2ec6 5e					ld e, (hl) 
2ec7 23					inc hl 
2ec8 56					ld d, (hl) 
2ec9			 
2ec9 eb					ex de, hl 
2eca			 
2eca cd cd 1c				call forth_push_numhl 
2ecd			 
2ecd				       NEXTW 
2ecd c3 36 20			jp macro_next 
2ed0				endm 
# End of macro NEXTW
2ed0			.BANG2: 
2ed0				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ed0 6f				db WORD_SYS_CORE+91             
2ed1 08 2f			dw .CONFIG            
2ed3 03				db 2 + 1 
2ed4 .. 00			db "2!",0              
2ed7				endm 
# End of macro CWHEAD
2ed7			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ed7					if DEBUG_FORTH_WORDS_KEY 
2ed7						DMARK "2S_" 
2ed7 f5				push af  
2ed8 3a ec 2e			ld a, (.dmark)  
2edb 32 b4 fb			ld (debug_mark),a  
2ede 3a ed 2e			ld a, (.dmark+1)  
2ee1 32 b5 fb			ld (debug_mark+1),a  
2ee4 3a ee 2e			ld a, (.dmark+2)  
2ee7 32 b6 fb			ld (debug_mark+2),a  
2eea 18 03			jr .pastdmark  
2eec ..			.dmark: db "2S_"  
2eef f1			.pastdmark: pop af  
2ef0			endm  
# End of macro DMARK
2ef0						CALLMONITOR 
2ef0 cd 3d 17			call break_point_state  
2ef3				endm  
# End of macro CALLMONITOR
2ef3					endif 
2ef3			 
2ef3					FORTH_DSP_VALUEHL 
2ef3 cd c4 1e			call macro_dsp_valuehl 
2ef6				endm 
# End of macro FORTH_DSP_VALUEHL
2ef6			 
2ef6 e5					push hl   ; save address 
2ef7			 
2ef7			 
2ef7					FORTH_DSP_POP 
2ef7 cd 7c 1f			call macro_forth_dsp_pop 
2efa				endm 
# End of macro FORTH_DSP_POP
2efa			 
2efa					 
2efa					FORTH_DSP_VALUEHL 
2efa cd c4 1e			call macro_dsp_valuehl 
2efd				endm 
# End of macro FORTH_DSP_VALUEHL
2efd			 
2efd					FORTH_DSP_POP 
2efd cd 7c 1f			call macro_forth_dsp_pop 
2f00				endm 
# End of macro FORTH_DSP_POP
2f00			 
2f00 eb					ex de, hl    ; value now in de 
2f01			 
2f01 e1					pop hl 
2f02			 
2f02 73					ld (hl), e 
2f03			 
2f03 23					inc hl 
2f04			 
2f04 72					ld (hl), d 
2f05			 
2f05			 
2f05				       NEXTW 
2f05 c3 36 20			jp macro_next 
2f08				endm 
# End of macro NEXTW
2f08			.CONFIG: 
2f08				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f08 6f				db WORD_SYS_CORE+91             
2f09 19 2f			dw .ENDCORE            
2f0b 07				db 6 + 1 
2f0c .. 00			db "CONFIG",0              
2f13				endm 
# End of macro CWHEAD
2f13			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f13			 
2f13 cd 78 13				call config 
2f16					NEXTW 
2f16 c3 36 20			jp macro_next 
2f19				endm 
# End of macro NEXTW
2f19			.ENDCORE: 
2f19			 
2f19			; eof 
2f19			 
2f19			 
# End of file forth_words_core.asm
2f19			include "forth_words_flow.asm" 
2f19			 
2f19			; | ## Program Flow Words 
2f19			 
2f19			.IF: 
2f19				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f19 1e				db WORD_SYS_CORE+10             
2f1a 0e 30			dw .THEN            
2f1c 03				db 2 + 1 
2f1d .. 00			db "IF",0              
2f20				endm 
# End of macro CWHEAD
2f20			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f20			; 
2f20					if DEBUG_FORTH_WORDS_KEY 
2f20						DMARK "IF." 
2f20 f5				push af  
2f21 3a 35 2f			ld a, (.dmark)  
2f24 32 b4 fb			ld (debug_mark),a  
2f27 3a 36 2f			ld a, (.dmark+1)  
2f2a 32 b5 fb			ld (debug_mark+1),a  
2f2d 3a 37 2f			ld a, (.dmark+2)  
2f30 32 b6 fb			ld (debug_mark+2),a  
2f33 18 03			jr .pastdmark  
2f35 ..			.dmark: db "IF."  
2f38 f1			.pastdmark: pop af  
2f39			endm  
# End of macro DMARK
2f39						CALLMONITOR 
2f39 cd 3d 17			call break_point_state  
2f3c				endm  
# End of macro CALLMONITOR
2f3c					endif 
2f3c			; eval TOS 
2f3c			 
2f3c				FORTH_DSP_VALUEHL 
2f3c cd c4 1e			call macro_dsp_valuehl 
2f3f				endm 
# End of macro FORTH_DSP_VALUEHL
2f3f			 
2f3f			;	push hl 
2f3f				FORTH_DSP_POP 
2f3f cd 7c 1f			call macro_forth_dsp_pop 
2f42				endm 
# End of macro FORTH_DSP_POP
2f42			;	pop hl 
2f42			 
2f42					if DEBUG_FORTH_WORDS 
2f42						DMARK "IF1" 
2f42 f5				push af  
2f43 3a 57 2f			ld a, (.dmark)  
2f46 32 b4 fb			ld (debug_mark),a  
2f49 3a 58 2f			ld a, (.dmark+1)  
2f4c 32 b5 fb			ld (debug_mark+1),a  
2f4f 3a 59 2f			ld a, (.dmark+2)  
2f52 32 b6 fb			ld (debug_mark+2),a  
2f55 18 03			jr .pastdmark  
2f57 ..			.dmark: db "IF1"  
2f5a f1			.pastdmark: pop af  
2f5b			endm  
# End of macro DMARK
2f5b						CALLMONITOR 
2f5b cd 3d 17			call break_point_state  
2f5e				endm  
# End of macro CALLMONITOR
2f5e					endif 
2f5e b7				or a        ; clear carry flag 
2f5f 11 00 00			ld de, 0 
2f62 eb				ex de,hl 
2f63 ed 52			sbc hl, de 
2f65 c2 ef 2f			jp nz, .iftrue 
2f68			 
2f68					if DEBUG_FORTH_WORDS 
2f68						DMARK "IF2" 
2f68 f5				push af  
2f69 3a 7d 2f			ld a, (.dmark)  
2f6c 32 b4 fb			ld (debug_mark),a  
2f6f 3a 7e 2f			ld a, (.dmark+1)  
2f72 32 b5 fb			ld (debug_mark+1),a  
2f75 3a 7f 2f			ld a, (.dmark+2)  
2f78 32 b6 fb			ld (debug_mark+2),a  
2f7b 18 03			jr .pastdmark  
2f7d ..			.dmark: db "IF2"  
2f80 f1			.pastdmark: pop af  
2f81			endm  
# End of macro DMARK
2f81						CALLMONITOR 
2f81 cd 3d 17			call break_point_state  
2f84				endm  
# End of macro CALLMONITOR
2f84					endif 
2f84			 
2f84			; if not true then skip to THEN 
2f84			 
2f84				; TODO get tok_ptr 
2f84				; TODO consume toks until we get to THEN 
2f84			 
2f84 2a 9b f2			ld hl, (os_tok_ptr) 
2f87					if DEBUG_FORTH_WORDS 
2f87						DMARK "IF3" 
2f87 f5				push af  
2f88 3a 9c 2f			ld a, (.dmark)  
2f8b 32 b4 fb			ld (debug_mark),a  
2f8e 3a 9d 2f			ld a, (.dmark+1)  
2f91 32 b5 fb			ld (debug_mark+1),a  
2f94 3a 9e 2f			ld a, (.dmark+2)  
2f97 32 b6 fb			ld (debug_mark+2),a  
2f9a 18 03			jr .pastdmark  
2f9c ..			.dmark: db "IF3"  
2f9f f1			.pastdmark: pop af  
2fa0			endm  
# End of macro DMARK
2fa0						CALLMONITOR 
2fa0 cd 3d 17			call break_point_state  
2fa3				endm  
# End of macro CALLMONITOR
2fa3						 
2fa3					endif 
2fa3 11 ea 2f			ld de, .ifthen 
2fa6					if DEBUG_FORTH_WORDS 
2fa6						DMARK "IF4" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 b4 fb			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 b5 fb			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 b6 fb			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "IF4"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf						CALLMONITOR 
2fbf cd 3d 17			call break_point_state  
2fc2				endm  
# End of macro CALLMONITOR
2fc2					endif 
2fc2 cd 51 21			call findnexttok  
2fc5			 
2fc5					if DEBUG_FORTH_WORDS 
2fc5						DMARK "IF5" 
2fc5 f5				push af  
2fc6 3a da 2f			ld a, (.dmark)  
2fc9 32 b4 fb			ld (debug_mark),a  
2fcc 3a db 2f			ld a, (.dmark+1)  
2fcf 32 b5 fb			ld (debug_mark+1),a  
2fd2 3a dc 2f			ld a, (.dmark+2)  
2fd5 32 b6 fb			ld (debug_mark+2),a  
2fd8 18 03			jr .pastdmark  
2fda ..			.dmark: db "IF5"  
2fdd f1			.pastdmark: pop af  
2fde			endm  
# End of macro DMARK
2fde						CALLMONITOR 
2fde cd 3d 17			call break_point_state  
2fe1				endm  
# End of macro CALLMONITOR
2fe1					endif 
2fe1				; TODO replace below with ; exec using tok_ptr 
2fe1 22 9b f2			ld (os_tok_ptr), hl 
2fe4 c3 c7 20			jp exec1 
2fe7				NEXTW 
2fe7 c3 36 20			jp macro_next 
2fea				endm 
# End of macro NEXTW
2fea			 
2fea .. 00		.ifthen:  db "THEN",0 
2fef			 
2fef			.iftrue:		 
2fef				; Exec next words normally 
2fef			 
2fef				; if true then exec following IF as normal 
2fef					if DEBUG_FORTH_WORDS 
2fef						DMARK "IFT" 
2fef f5				push af  
2ff0 3a 04 30			ld a, (.dmark)  
2ff3 32 b4 fb			ld (debug_mark),a  
2ff6 3a 05 30			ld a, (.dmark+1)  
2ff9 32 b5 fb			ld (debug_mark+1),a  
2ffc 3a 06 30			ld a, (.dmark+2)  
2fff 32 b6 fb			ld (debug_mark+2),a  
3002 18 03			jr .pastdmark  
3004 ..			.dmark: db "IFT"  
3007 f1			.pastdmark: pop af  
3008			endm  
# End of macro DMARK
3008						CALLMONITOR 
3008 cd 3d 17			call break_point_state  
300b				endm  
# End of macro CALLMONITOR
300b					endif 
300b			 
300b					NEXTW 
300b c3 36 20			jp macro_next 
300e				endm 
# End of macro NEXTW
300e			.THEN: 
300e				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
300e 1f				db WORD_SYS_CORE+11             
300f 36 30			dw .ELSE            
3011 05				db 4 + 1 
3012 .. 00			db "THEN",0              
3017				endm 
# End of macro CWHEAD
3017			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3017					if DEBUG_FORTH_WORDS_KEY 
3017						DMARK "THN" 
3017 f5				push af  
3018 3a 2c 30			ld a, (.dmark)  
301b 32 b4 fb			ld (debug_mark),a  
301e 3a 2d 30			ld a, (.dmark+1)  
3021 32 b5 fb			ld (debug_mark+1),a  
3024 3a 2e 30			ld a, (.dmark+2)  
3027 32 b6 fb			ld (debug_mark+2),a  
302a 18 03			jr .pastdmark  
302c ..			.dmark: db "THN"  
302f f1			.pastdmark: pop af  
3030			endm  
# End of macro DMARK
3030						CALLMONITOR 
3030 cd 3d 17			call break_point_state  
3033				endm  
# End of macro CALLMONITOR
3033					endif 
3033					NEXTW 
3033 c3 36 20			jp macro_next 
3036				endm 
# End of macro NEXTW
3036			.ELSE: 
3036				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3036 20				db WORD_SYS_CORE+12             
3037 5e 30			dw .DO            
3039 03				db 2 + 1 
303a .. 00			db "ELSE",0              
303f				endm 
# End of macro CWHEAD
303f			; | ELSE ( -- ) Not supported - does nothing | TODO 
303f			 
303f					if DEBUG_FORTH_WORDS_KEY 
303f						DMARK "ELS" 
303f f5				push af  
3040 3a 54 30			ld a, (.dmark)  
3043 32 b4 fb			ld (debug_mark),a  
3046 3a 55 30			ld a, (.dmark+1)  
3049 32 b5 fb			ld (debug_mark+1),a  
304c 3a 56 30			ld a, (.dmark+2)  
304f 32 b6 fb			ld (debug_mark+2),a  
3052 18 03			jr .pastdmark  
3054 ..			.dmark: db "ELS"  
3057 f1			.pastdmark: pop af  
3058			endm  
# End of macro DMARK
3058						CALLMONITOR 
3058 cd 3d 17			call break_point_state  
305b				endm  
# End of macro CALLMONITOR
305b					endif 
305b			 
305b			 
305b					NEXTW 
305b c3 36 20			jp macro_next 
305e				endm 
# End of macro NEXTW
305e			.DO: 
305e				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
305e 21				db WORD_SYS_CORE+13             
305f 85 31			dw .LOOP            
3061 03				db 2 + 1 
3062 .. 00			db "DO",0              
3065				endm 
# End of macro CWHEAD
3065			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3065			 
3065					if DEBUG_FORTH_WORDS_KEY 
3065						DMARK "DO." 
3065 f5				push af  
3066 3a 7a 30			ld a, (.dmark)  
3069 32 b4 fb			ld (debug_mark),a  
306c 3a 7b 30			ld a, (.dmark+1)  
306f 32 b5 fb			ld (debug_mark+1),a  
3072 3a 7c 30			ld a, (.dmark+2)  
3075 32 b6 fb			ld (debug_mark+2),a  
3078 18 03			jr .pastdmark  
307a ..			.dmark: db "DO."  
307d f1			.pastdmark: pop af  
307e			endm  
# End of macro DMARK
307e						CALLMONITOR 
307e cd 3d 17			call break_point_state  
3081				endm  
# End of macro CALLMONITOR
3081					endif 
3081			;  push pc to rsp stack past the DO 
3081			 
3081 2a 9b f2				ld hl, (os_tok_ptr) 
3084 23					inc hl   ; D 
3085 23					inc hl  ; O 
3086 23					inc hl   ; null 
3087					if DEBUG_FORTH_WORDS 
3087						DMARK "DO2" 
3087 f5				push af  
3088 3a 9c 30			ld a, (.dmark)  
308b 32 b4 fb			ld (debug_mark),a  
308e 3a 9d 30			ld a, (.dmark+1)  
3091 32 b5 fb			ld (debug_mark+1),a  
3094 3a 9e 30			ld a, (.dmark+2)  
3097 32 b6 fb			ld (debug_mark+2),a  
309a 18 03			jr .pastdmark  
309c ..			.dmark: db "DO2"  
309f f1			.pastdmark: pop af  
30a0			endm  
# End of macro DMARK
30a0						CALLMONITOR 
30a0 cd 3d 17			call break_point_state  
30a3				endm  
# End of macro CALLMONITOR
30a3					endif 
30a3					FORTH_RSP_NEXT 
30a3 cd 74 1c			call macro_forth_rsp_next 
30a6				endm 
# End of macro FORTH_RSP_NEXT
30a6					if DEBUG_FORTH_WORDS 
30a6						DMARK "DO3" 
30a6 f5				push af  
30a7 3a bb 30			ld a, (.dmark)  
30aa 32 b4 fb			ld (debug_mark),a  
30ad 3a bc 30			ld a, (.dmark+1)  
30b0 32 b5 fb			ld (debug_mark+1),a  
30b3 3a bd 30			ld a, (.dmark+2)  
30b6 32 b6 fb			ld (debug_mark+2),a  
30b9 18 03			jr .pastdmark  
30bb ..			.dmark: db "DO3"  
30be f1			.pastdmark: pop af  
30bf			endm  
# End of macro DMARK
30bf						CALLMONITOR 
30bf cd 3d 17			call break_point_state  
30c2				endm  
# End of macro CALLMONITOR
30c2					endif 
30c2			 
30c2					;if DEBUG_FORTH_WORDS 
30c2				;		push hl 
30c2			;		endif  
30c2			 
30c2			; get counters from data stack 
30c2			 
30c2			 
30c2					FORTH_DSP_VALUEHL 
30c2 cd c4 1e			call macro_dsp_valuehl 
30c5				endm 
# End of macro FORTH_DSP_VALUEHL
30c5 e5					push hl		 ; hl now has starting counter which needs to be tos 
30c6			 
30c6					if DEBUG_FORTH_WORDS 
30c6						DMARK "DO4" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 b4 fb			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 b5 fb			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 b6 fb			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "DO4"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df						CALLMONITOR 
30df cd 3d 17			call break_point_state  
30e2				endm  
# End of macro CALLMONITOR
30e2					endif 
30e2					FORTH_DSP_POP 
30e2 cd 7c 1f			call macro_forth_dsp_pop 
30e5				endm 
# End of macro FORTH_DSP_POP
30e5			 
30e5					if DEBUG_FORTH_WORDS 
30e5						DMARK "DO5" 
30e5 f5				push af  
30e6 3a fa 30			ld a, (.dmark)  
30e9 32 b4 fb			ld (debug_mark),a  
30ec 3a fb 30			ld a, (.dmark+1)  
30ef 32 b5 fb			ld (debug_mark+1),a  
30f2 3a fc 30			ld a, (.dmark+2)  
30f5 32 b6 fb			ld (debug_mark+2),a  
30f8 18 03			jr .pastdmark  
30fa ..			.dmark: db "DO5"  
30fd f1			.pastdmark: pop af  
30fe			endm  
# End of macro DMARK
30fe						CALLMONITOR 
30fe cd 3d 17			call break_point_state  
3101				endm  
# End of macro CALLMONITOR
3101					endif 
3101			 
3101					FORTH_DSP_VALUEHL 
3101 cd c4 1e			call macro_dsp_valuehl 
3104				endm 
# End of macro FORTH_DSP_VALUEHL
3104			;		push hl		 ; hl now has starting limit counter 
3104			 
3104					if DEBUG_FORTH_WORDS 
3104						DMARK "DO6" 
3104 f5				push af  
3105 3a 19 31			ld a, (.dmark)  
3108 32 b4 fb			ld (debug_mark),a  
310b 3a 1a 31			ld a, (.dmark+1)  
310e 32 b5 fb			ld (debug_mark+1),a  
3111 3a 1b 31			ld a, (.dmark+2)  
3114 32 b6 fb			ld (debug_mark+2),a  
3117 18 03			jr .pastdmark  
3119 ..			.dmark: db "DO6"  
311c f1			.pastdmark: pop af  
311d			endm  
# End of macro DMARK
311d						CALLMONITOR 
311d cd 3d 17			call break_point_state  
3120				endm  
# End of macro CALLMONITOR
3120					endif 
3120					FORTH_DSP_POP 
3120 cd 7c 1f			call macro_forth_dsp_pop 
3123				endm 
# End of macro FORTH_DSP_POP
3123			 
3123			; put counters on the loop stack 
3123			 
3123			;		pop hl			 ; limit counter 
3123 d1					pop de			; start counter 
3124			 
3124					; push limit counter 
3124			 
3124					if DEBUG_FORTH_WORDS 
3124						DMARK "DO7" 
3124 f5				push af  
3125 3a 39 31			ld a, (.dmark)  
3128 32 b4 fb			ld (debug_mark),a  
312b 3a 3a 31			ld a, (.dmark+1)  
312e 32 b5 fb			ld (debug_mark+1),a  
3131 3a 3b 31			ld a, (.dmark+2)  
3134 32 b6 fb			ld (debug_mark+2),a  
3137 18 03			jr .pastdmark  
3139 ..			.dmark: db "DO7"  
313c f1			.pastdmark: pop af  
313d			endm  
# End of macro DMARK
313d						CALLMONITOR 
313d cd 3d 17			call break_point_state  
3140				endm  
# End of macro CALLMONITOR
3140					endif 
3140					FORTH_LOOP_NEXT 
3140 cd f5 1e			call macro_forth_loop_next 
3143				endm 
# End of macro FORTH_LOOP_NEXT
3143			 
3143					; push start counter 
3143			 
3143 eb					ex de, hl 
3144					if DEBUG_FORTH_WORDS 
3144						DMARK "DO7" 
3144 f5				push af  
3145 3a 59 31			ld a, (.dmark)  
3148 32 b4 fb			ld (debug_mark),a  
314b 3a 5a 31			ld a, (.dmark+1)  
314e 32 b5 fb			ld (debug_mark+1),a  
3151 3a 5b 31			ld a, (.dmark+2)  
3154 32 b6 fb			ld (debug_mark+2),a  
3157 18 03			jr .pastdmark  
3159 ..			.dmark: db "DO7"  
315c f1			.pastdmark: pop af  
315d			endm  
# End of macro DMARK
315d						CALLMONITOR 
315d cd 3d 17			call break_point_state  
3160				endm  
# End of macro CALLMONITOR
3160					endif 
3160					FORTH_LOOP_NEXT 
3160 cd f5 1e			call macro_forth_loop_next 
3163				endm 
# End of macro FORTH_LOOP_NEXT
3163			 
3163			 
3163					; init first round of I counter 
3163			 
3163 22 bf f2				ld (os_current_i), hl 
3166			 
3166					if DEBUG_FORTH_WORDS 
3166						DMARK "DO8" 
3166 f5				push af  
3167 3a 7b 31			ld a, (.dmark)  
316a 32 b4 fb			ld (debug_mark),a  
316d 3a 7c 31			ld a, (.dmark+1)  
3170 32 b5 fb			ld (debug_mark+1),a  
3173 3a 7d 31			ld a, (.dmark+2)  
3176 32 b6 fb			ld (debug_mark+2),a  
3179 18 03			jr .pastdmark  
317b ..			.dmark: db "DO8"  
317e f1			.pastdmark: pop af  
317f			endm  
# End of macro DMARK
317f						CALLMONITOR 
317f cd 3d 17			call break_point_state  
3182				endm  
# End of macro CALLMONITOR
3182					endif 
3182			 
3182					NEXTW 
3182 c3 36 20			jp macro_next 
3185				endm 
# End of macro NEXTW
3185			.LOOP: 
3185				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3185 22				db WORD_SYS_CORE+14             
3186 9d 32			dw .I            
3188 05				db 4 + 1 
3189 .. 00			db "LOOP",0              
318e				endm 
# End of macro CWHEAD
318e			; | LOOP ( -- ) Increment and test loop counter  | DONE 
318e			 
318e				; pop tos as current loop count to hl 
318e			 
318e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
318e			 
318e				FORTH_LOOP_TOS 
318e cd 28 1f			call macro_forth_loop_tos 
3191				endm 
# End of macro FORTH_LOOP_TOS
3191 e5				push hl 
3192			 
3192					if DEBUG_FORTH_WORDS_KEY 
3192						DMARK "LOP" 
3192 f5				push af  
3193 3a a7 31			ld a, (.dmark)  
3196 32 b4 fb			ld (debug_mark),a  
3199 3a a8 31			ld a, (.dmark+1)  
319c 32 b5 fb			ld (debug_mark+1),a  
319f 3a a9 31			ld a, (.dmark+2)  
31a2 32 b6 fb			ld (debug_mark+2),a  
31a5 18 03			jr .pastdmark  
31a7 ..			.dmark: db "LOP"  
31aa f1			.pastdmark: pop af  
31ab			endm  
# End of macro DMARK
31ab						CALLMONITOR 
31ab cd 3d 17			call break_point_state  
31ae				endm  
# End of macro CALLMONITOR
31ae					endif 
31ae				; next item on the stack is the limit. get it 
31ae			 
31ae			 
31ae				FORTH_LOOP_POP 
31ae cd 32 1f			call macro_forth_loop_pop 
31b1				endm 
# End of macro FORTH_LOOP_POP
31b1			 
31b1				FORTH_LOOP_TOS 
31b1 cd 28 1f			call macro_forth_loop_tos 
31b4				endm 
# End of macro FORTH_LOOP_TOS
31b4			 
31b4 d1				pop de		 ; de = i, hl = limit 
31b5			 
31b5					if DEBUG_FORTH_WORDS 
31b5						DMARK "LP1" 
31b5 f5				push af  
31b6 3a ca 31			ld a, (.dmark)  
31b9 32 b4 fb			ld (debug_mark),a  
31bc 3a cb 31			ld a, (.dmark+1)  
31bf 32 b5 fb			ld (debug_mark+1),a  
31c2 3a cc 31			ld a, (.dmark+2)  
31c5 32 b6 fb			ld (debug_mark+2),a  
31c8 18 03			jr .pastdmark  
31ca ..			.dmark: db "LP1"  
31cd f1			.pastdmark: pop af  
31ce			endm  
# End of macro DMARK
31ce						CALLMONITOR 
31ce cd 3d 17			call break_point_state  
31d1				endm  
# End of macro CALLMONITOR
31d1					endif 
31d1			 
31d1				; go back to previous word 
31d1			 
31d1 d5				push de    ; save I for inc later 
31d2			 
31d2			 
31d2				; get limit 
31d2				;  is I at limit? 
31d2			 
31d2			 
31d2					if DEBUG_FORTH_WORDS 
31d2						DMARK "LP1" 
31d2 f5				push af  
31d3 3a e7 31			ld a, (.dmark)  
31d6 32 b4 fb			ld (debug_mark),a  
31d9 3a e8 31			ld a, (.dmark+1)  
31dc 32 b5 fb			ld (debug_mark+1),a  
31df 3a e9 31			ld a, (.dmark+2)  
31e2 32 b6 fb			ld (debug_mark+2),a  
31e5 18 03			jr .pastdmark  
31e7 ..			.dmark: db "LP1"  
31ea f1			.pastdmark: pop af  
31eb			endm  
# End of macro DMARK
31eb						CALLMONITOR 
31eb cd 3d 17			call break_point_state  
31ee				endm  
# End of macro CALLMONITOR
31ee					endif 
31ee			 
31ee ed 52			sbc hl, de 
31f0			 
31f0			 
31f0				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31f0			 
31f0 20 26				jr nz, .loopnotdone 
31f2			 
31f2 e1				pop hl   ; get rid of saved I 
31f3				FORTH_LOOP_POP     ; get rid of limit 
31f3 cd 32 1f			call macro_forth_loop_pop 
31f6				endm 
# End of macro FORTH_LOOP_POP
31f6			 
31f6				FORTH_RSP_POP     ; get rid of DO ptr 
31f6 cd 95 1c			call macro_forth_rsp_pop 
31f9				endm 
# End of macro FORTH_RSP_POP
31f9			 
31f9			if DEBUG_FORTH_WORDS 
31f9						DMARK "LP>" 
31f9 f5				push af  
31fa 3a 0e 32			ld a, (.dmark)  
31fd 32 b4 fb			ld (debug_mark),a  
3200 3a 0f 32			ld a, (.dmark+1)  
3203 32 b5 fb			ld (debug_mark+1),a  
3206 3a 10 32			ld a, (.dmark+2)  
3209 32 b6 fb			ld (debug_mark+2),a  
320c 18 03			jr .pastdmark  
320e ..			.dmark: db "LP>"  
3211 f1			.pastdmark: pop af  
3212			endm  
# End of macro DMARK
3212				CALLMONITOR 
3212 cd 3d 17			call break_point_state  
3215				endm  
# End of macro CALLMONITOR
3215			endif 
3215			 
3215					NEXTW 
3215 c3 36 20			jp macro_next 
3218				endm 
# End of macro NEXTW
3218				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3218			 
3218			.loopnotdone: 
3218			 
3218 e1				pop hl    ; get I 
3219 23				inc hl 
321a			 
321a			   	; save new I 
321a			 
321a			 
321a					; set I counter 
321a			 
321a 22 bf f2				ld (os_current_i), hl 
321d			 
321d					if DEBUG_FORTH_WORDS 
321d						DMARK "LPN" 
321d f5				push af  
321e 3a 32 32			ld a, (.dmark)  
3221 32 b4 fb			ld (debug_mark),a  
3224 3a 33 32			ld a, (.dmark+1)  
3227 32 b5 fb			ld (debug_mark+1),a  
322a 3a 34 32			ld a, (.dmark+2)  
322d 32 b6 fb			ld (debug_mark+2),a  
3230 18 03			jr .pastdmark  
3232 ..			.dmark: db "LPN"  
3235 f1			.pastdmark: pop af  
3236			endm  
# End of macro DMARK
3236					CALLMONITOR 
3236 cd 3d 17			call break_point_state  
3239				endm  
# End of macro CALLMONITOR
3239					endif 
3239					 
3239				FORTH_LOOP_NEXT 
3239 cd f5 1e			call macro_forth_loop_next 
323c				endm 
# End of macro FORTH_LOOP_NEXT
323c			 
323c			 
323c					if DEBUG_FORTH_WORDS 
323c eb						ex de,hl 
323d					endif 
323d			 
323d			;	; get DO ptr 
323d			; 
323d					if DEBUG_FORTH_WORDS 
323d						DMARK "LP7" 
323d f5				push af  
323e 3a 52 32			ld a, (.dmark)  
3241 32 b4 fb			ld (debug_mark),a  
3244 3a 53 32			ld a, (.dmark+1)  
3247 32 b5 fb			ld (debug_mark+1),a  
324a 3a 54 32			ld a, (.dmark+2)  
324d 32 b6 fb			ld (debug_mark+2),a  
3250 18 03			jr .pastdmark  
3252 ..			.dmark: db "LP7"  
3255 f1			.pastdmark: pop af  
3256			endm  
# End of macro DMARK
3256					CALLMONITOR 
3256 cd 3d 17			call break_point_state  
3259				endm  
# End of macro CALLMONITOR
3259					endif 
3259				FORTH_RSP_TOS 
3259 cd 8b 1c			call macro_forth_rsp_tos 
325c				endm 
# End of macro FORTH_RSP_TOS
325c			 
325c					if DEBUG_FORTH_WORDS 
325c						DMARK "LP8" 
325c f5				push af  
325d 3a 71 32			ld a, (.dmark)  
3260 32 b4 fb			ld (debug_mark),a  
3263 3a 72 32			ld a, (.dmark+1)  
3266 32 b5 fb			ld (debug_mark+1),a  
3269 3a 73 32			ld a, (.dmark+2)  
326c 32 b6 fb			ld (debug_mark+2),a  
326f 18 03			jr .pastdmark  
3271 ..			.dmark: db "LP8"  
3274 f1			.pastdmark: pop af  
3275			endm  
# End of macro DMARK
3275					CALLMONITOR 
3275 cd 3d 17			call break_point_state  
3278				endm  
# End of macro CALLMONITOR
3278					endif 
3278				;push hl 
3278			 
3278				; not going to DO any more 
3278				; get rid of the RSP pointer as DO will add it back in 
3278				;FORTH_RSP_POP 
3278				;pop hl 
3278			 
3278				;ld hl,(cli_ret_sp) 
3278				;ld e, (hl) 
3278				;inc hl 
3278				;ld d, (hl) 
3278				;ex de,hl 
3278 22 9b f2			ld (os_tok_ptr), hl 
327b					if DEBUG_FORTH_WORDS 
327b						DMARK "LP<" 
327b f5				push af  
327c 3a 90 32			ld a, (.dmark)  
327f 32 b4 fb			ld (debug_mark),a  
3282 3a 91 32			ld a, (.dmark+1)  
3285 32 b5 fb			ld (debug_mark+1),a  
3288 3a 92 32			ld a, (.dmark+2)  
328b 32 b6 fb			ld (debug_mark+2),a  
328e 18 03			jr .pastdmark  
3290 ..			.dmark: db "LP<"  
3293 f1			.pastdmark: pop af  
3294			endm  
# End of macro DMARK
3294					CALLMONITOR 
3294 cd 3d 17			call break_point_state  
3297				endm  
# End of macro CALLMONITOR
3297				endif 
3297 c3 c7 20			jp exec1 
329a			 
329a					 
329a			 
329a			 
329a					NEXTW 
329a c3 36 20			jp macro_next 
329d				endm 
# End of macro NEXTW
329d			.I:  
329d			 
329d				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
329d 5e				db WORD_SYS_CORE+74             
329e c8 32			dw .DLOOP            
32a0 02				db 1 + 1 
32a1 .. 00			db "I",0              
32a3				endm 
# End of macro CWHEAD
32a3			; | I ( -- ) Current loop counter | DONE 
32a3					if DEBUG_FORTH_WORDS_KEY 
32a3						DMARK "I.." 
32a3 f5				push af  
32a4 3a b8 32			ld a, (.dmark)  
32a7 32 b4 fb			ld (debug_mark),a  
32aa 3a b9 32			ld a, (.dmark+1)  
32ad 32 b5 fb			ld (debug_mark+1),a  
32b0 3a ba 32			ld a, (.dmark+2)  
32b3 32 b6 fb			ld (debug_mark+2),a  
32b6 18 03			jr .pastdmark  
32b8 ..			.dmark: db "I.."  
32bb f1			.pastdmark: pop af  
32bc			endm  
# End of macro DMARK
32bc						CALLMONITOR 
32bc cd 3d 17			call break_point_state  
32bf				endm  
# End of macro CALLMONITOR
32bf					endif 
32bf			 
32bf 2a bf f2				ld hl,(os_current_i) 
32c2 cd cd 1c				call forth_push_numhl 
32c5			 
32c5					NEXTW 
32c5 c3 36 20			jp macro_next 
32c8				endm 
# End of macro NEXTW
32c8			.DLOOP: 
32c8				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32c8 5f				db WORD_SYS_CORE+75             
32c9 a9 33			dw .REPEAT            
32cb 06				db 5 + 1 
32cc .. 00			db "-LOOP",0              
32d2				endm 
# End of macro CWHEAD
32d2			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32d2				; pop tos as current loop count to hl 
32d2					if DEBUG_FORTH_WORDS_KEY 
32d2						DMARK "-LP" 
32d2 f5				push af  
32d3 3a e7 32			ld a, (.dmark)  
32d6 32 b4 fb			ld (debug_mark),a  
32d9 3a e8 32			ld a, (.dmark+1)  
32dc 32 b5 fb			ld (debug_mark+1),a  
32df 3a e9 32			ld a, (.dmark+2)  
32e2 32 b6 fb			ld (debug_mark+2),a  
32e5 18 03			jr .pastdmark  
32e7 ..			.dmark: db "-LP"  
32ea f1			.pastdmark: pop af  
32eb			endm  
# End of macro DMARK
32eb						CALLMONITOR 
32eb cd 3d 17			call break_point_state  
32ee				endm  
# End of macro CALLMONITOR
32ee					endif 
32ee			 
32ee				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32ee			 
32ee				FORTH_LOOP_TOS 
32ee cd 28 1f			call macro_forth_loop_tos 
32f1				endm 
# End of macro FORTH_LOOP_TOS
32f1 e5				push hl 
32f2			 
32f2					if DEBUG_FORTH_WORDS 
32f2						DMARK "-LP" 
32f2 f5				push af  
32f3 3a 07 33			ld a, (.dmark)  
32f6 32 b4 fb			ld (debug_mark),a  
32f9 3a 08 33			ld a, (.dmark+1)  
32fc 32 b5 fb			ld (debug_mark+1),a  
32ff 3a 09 33			ld a, (.dmark+2)  
3302 32 b6 fb			ld (debug_mark+2),a  
3305 18 03			jr .pastdmark  
3307 ..			.dmark: db "-LP"  
330a f1			.pastdmark: pop af  
330b			endm  
# End of macro DMARK
330b						CALLMONITOR 
330b cd 3d 17			call break_point_state  
330e				endm  
# End of macro CALLMONITOR
330e					endif 
330e				; next item on the stack is the limit. get it 
330e			 
330e			 
330e				FORTH_LOOP_POP 
330e cd 32 1f			call macro_forth_loop_pop 
3311				endm 
# End of macro FORTH_LOOP_POP
3311			 
3311				FORTH_LOOP_TOS 
3311 cd 28 1f			call macro_forth_loop_tos 
3314				endm 
# End of macro FORTH_LOOP_TOS
3314			 
3314 d1				pop de		 ; de = i, hl = limit 
3315			 
3315					if DEBUG_FORTH_WORDS 
3315						DMARK "-L1" 
3315 f5				push af  
3316 3a 2a 33			ld a, (.dmark)  
3319 32 b4 fb			ld (debug_mark),a  
331c 3a 2b 33			ld a, (.dmark+1)  
331f 32 b5 fb			ld (debug_mark+1),a  
3322 3a 2c 33			ld a, (.dmark+2)  
3325 32 b6 fb			ld (debug_mark+2),a  
3328 18 03			jr .pastdmark  
332a ..			.dmark: db "-L1"  
332d f1			.pastdmark: pop af  
332e			endm  
# End of macro DMARK
332e						CALLMONITOR 
332e cd 3d 17			call break_point_state  
3331				endm  
# End of macro CALLMONITOR
3331					endif 
3331			 
3331				; go back to previous word 
3331			 
3331 d5				push de    ; save I for inc later 
3332			 
3332			 
3332				; get limit 
3332				;  is I at limit? 
3332			 
3332			 
3332					if DEBUG_FORTH_WORDS 
3332						DMARK "-L1" 
3332 f5				push af  
3333 3a 47 33			ld a, (.dmark)  
3336 32 b4 fb			ld (debug_mark),a  
3339 3a 48 33			ld a, (.dmark+1)  
333c 32 b5 fb			ld (debug_mark+1),a  
333f 3a 49 33			ld a, (.dmark+2)  
3342 32 b6 fb			ld (debug_mark+2),a  
3345 18 03			jr .pastdmark  
3347 ..			.dmark: db "-L1"  
334a f1			.pastdmark: pop af  
334b			endm  
# End of macro DMARK
334b						CALLMONITOR 
334b cd 3d 17			call break_point_state  
334e				endm  
# End of macro CALLMONITOR
334e					endif 
334e			 
334e ed 52			sbc hl, de 
3350			 
3350			 
3350				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3350			 
3350 20 26				jr nz, .mloopnotdone 
3352			 
3352 e1				pop hl   ; get rid of saved I 
3353				FORTH_LOOP_POP     ; get rid of limit 
3353 cd 32 1f			call macro_forth_loop_pop 
3356				endm 
# End of macro FORTH_LOOP_POP
3356			 
3356				FORTH_RSP_POP     ; get rid of DO ptr 
3356 cd 95 1c			call macro_forth_rsp_pop 
3359				endm 
# End of macro FORTH_RSP_POP
3359			 
3359			if DEBUG_FORTH_WORDS 
3359						DMARK "-L>" 
3359 f5				push af  
335a 3a 6e 33			ld a, (.dmark)  
335d 32 b4 fb			ld (debug_mark),a  
3360 3a 6f 33			ld a, (.dmark+1)  
3363 32 b5 fb			ld (debug_mark+1),a  
3366 3a 70 33			ld a, (.dmark+2)  
3369 32 b6 fb			ld (debug_mark+2),a  
336c 18 03			jr .pastdmark  
336e ..			.dmark: db "-L>"  
3371 f1			.pastdmark: pop af  
3372			endm  
# End of macro DMARK
3372				CALLMONITOR 
3372 cd 3d 17			call break_point_state  
3375				endm  
# End of macro CALLMONITOR
3375			endif 
3375			 
3375					NEXTW 
3375 c3 36 20			jp macro_next 
3378				endm 
# End of macro NEXTW
3378				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3378			 
3378			.mloopnotdone: 
3378			 
3378 e1				pop hl    ; get I 
3379 2b				dec hl 
337a			 
337a			   	; save new I 
337a			 
337a			 
337a					; set I counter 
337a			 
337a 22 bf f2				ld (os_current_i), hl 
337d			 
337d					 
337d				FORTH_LOOP_NEXT 
337d cd f5 1e			call macro_forth_loop_next 
3380				endm 
# End of macro FORTH_LOOP_NEXT
3380			 
3380			 
3380					if DEBUG_FORTH_WORDS 
3380 eb						ex de,hl 
3381					endif 
3381			 
3381			;	; get DO ptr 
3381			; 
3381				FORTH_RSP_TOS 
3381 cd 8b 1c			call macro_forth_rsp_tos 
3384				endm 
# End of macro FORTH_RSP_TOS
3384			 
3384				;push hl 
3384			 
3384				; not going to DO any more 
3384				; get rid of the RSP pointer as DO will add it back in 
3384				;FORTH_RSP_POP 
3384				;pop hl 
3384			 
3384			 
3384 22 9b f2			ld (os_tok_ptr), hl 
3387					if DEBUG_FORTH_WORDS 
3387						DMARK "-L<" 
3387 f5				push af  
3388 3a 9c 33			ld a, (.dmark)  
338b 32 b4 fb			ld (debug_mark),a  
338e 3a 9d 33			ld a, (.dmark+1)  
3391 32 b5 fb			ld (debug_mark+1),a  
3394 3a 9e 33			ld a, (.dmark+2)  
3397 32 b6 fb			ld (debug_mark+2),a  
339a 18 03			jr .pastdmark  
339c ..			.dmark: db "-L<"  
339f f1			.pastdmark: pop af  
33a0			endm  
# End of macro DMARK
33a0					CALLMONITOR 
33a0 cd 3d 17			call break_point_state  
33a3				endm  
# End of macro CALLMONITOR
33a3				endif 
33a3 c3 c7 20			jp exec1 
33a6			 
33a6					 
33a6			 
33a6			 
33a6			 
33a6				NEXTW 
33a6 c3 36 20			jp macro_next 
33a9				endm 
# End of macro NEXTW
33a9			 
33a9			 
33a9			 
33a9			 
33a9			.REPEAT: 
33a9				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33a9 71				db WORD_SYS_CORE+93             
33aa fc 33			dw .UNTIL            
33ac 06				db 5 + 1 
33ad .. 00			db "REPEAT",0              
33b4				endm 
# End of macro CWHEAD
33b4			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33b4			;  push pc to rsp stack past the REPEAT 
33b4					if DEBUG_FORTH_WORDS_KEY 
33b4						DMARK "REP" 
33b4 f5				push af  
33b5 3a c9 33			ld a, (.dmark)  
33b8 32 b4 fb			ld (debug_mark),a  
33bb 3a ca 33			ld a, (.dmark+1)  
33be 32 b5 fb			ld (debug_mark+1),a  
33c1 3a cb 33			ld a, (.dmark+2)  
33c4 32 b6 fb			ld (debug_mark+2),a  
33c7 18 03			jr .pastdmark  
33c9 ..			.dmark: db "REP"  
33cc f1			.pastdmark: pop af  
33cd			endm  
# End of macro DMARK
33cd						CALLMONITOR 
33cd cd 3d 17			call break_point_state  
33d0				endm  
# End of macro CALLMONITOR
33d0					endif 
33d0			 
33d0 2a 9b f2				ld hl, (os_tok_ptr) 
33d3 23					inc hl   ; R 
33d4 23					inc hl  ; E 
33d5 23					inc hl   ; P 
33d6 23					inc hl   ; E 
33d7 23					inc hl   ; A 
33d8 23					inc hl   ; T 
33d9 23					inc hl   ; zero 
33da					FORTH_RSP_NEXT 
33da cd 74 1c			call macro_forth_rsp_next 
33dd				endm 
# End of macro FORTH_RSP_NEXT
33dd			 
33dd			 
33dd					if DEBUG_FORTH_WORDS 
33dd						DMARK "REP" 
33dd f5				push af  
33de 3a f2 33			ld a, (.dmark)  
33e1 32 b4 fb			ld (debug_mark),a  
33e4 3a f3 33			ld a, (.dmark+1)  
33e7 32 b5 fb			ld (debug_mark+1),a  
33ea 3a f4 33			ld a, (.dmark+2)  
33ed 32 b6 fb			ld (debug_mark+2),a  
33f0 18 03			jr .pastdmark  
33f2 ..			.dmark: db "REP"  
33f5 f1			.pastdmark: pop af  
33f6			endm  
# End of macro DMARK
33f6						;pop bc    ; TODO BUG ?????? what is this for???? 
33f6						CALLMONITOR 
33f6 cd 3d 17			call break_point_state  
33f9				endm  
# End of macro CALLMONITOR
33f9					endif 
33f9			 
33f9					NEXTW 
33f9 c3 36 20			jp macro_next 
33fc				endm 
# End of macro NEXTW
33fc			;	       NEXTW 
33fc			 
33fc			.UNTIL: 
33fc				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33fc 72				db WORD_SYS_CORE+94             
33fd 93 34			dw .ENDFLOW            
33ff 06				db 5 + 1 
3400 .. 00			db "UNTIL",0              
3406				endm 
# End of macro CWHEAD
3406			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3406			 
3406				; pop tos as check 
3406			 
3406				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3406			 
3406				FORTH_DSP_VALUEHL 
3406 cd c4 1e			call macro_dsp_valuehl 
3409				endm 
# End of macro FORTH_DSP_VALUEHL
3409			 
3409					if DEBUG_FORTH_WORDS_KEY 
3409						DMARK "UNT" 
3409 f5				push af  
340a 3a 1e 34			ld a, (.dmark)  
340d 32 b4 fb			ld (debug_mark),a  
3410 3a 1f 34			ld a, (.dmark+1)  
3413 32 b5 fb			ld (debug_mark+1),a  
3416 3a 20 34			ld a, (.dmark+2)  
3419 32 b6 fb			ld (debug_mark+2),a  
341c 18 03			jr .pastdmark  
341e ..			.dmark: db "UNT"  
3421 f1			.pastdmark: pop af  
3422			endm  
# End of macro DMARK
3422						CALLMONITOR 
3422 cd 3d 17			call break_point_state  
3425				endm  
# End of macro CALLMONITOR
3425					endif 
3425			 
3425			;	push hl 
3425				FORTH_DSP_POP 
3425 cd 7c 1f			call macro_forth_dsp_pop 
3428				endm 
# End of macro FORTH_DSP_POP
3428			 
3428			;	pop hl 
3428			 
3428				; test if true 
3428			 
3428 cd 41 0d			call ishlzero 
342b			;	ld a,l 
342b			;	add h 
342b			; 
342b			;	cp 0 
342b			 
342b 20 3e			jr nz, .untilnotdone 
342d			 
342d					if DEBUG_FORTH_WORDS 
342d						DMARK "UNf" 
342d f5				push af  
342e 3a 42 34			ld a, (.dmark)  
3431 32 b4 fb			ld (debug_mark),a  
3434 3a 43 34			ld a, (.dmark+1)  
3437 32 b5 fb			ld (debug_mark+1),a  
343a 3a 44 34			ld a, (.dmark+2)  
343d 32 b6 fb			ld (debug_mark+2),a  
3440 18 03			jr .pastdmark  
3442 ..			.dmark: db "UNf"  
3445 f1			.pastdmark: pop af  
3446			endm  
# End of macro DMARK
3446						CALLMONITOR 
3446 cd 3d 17			call break_point_state  
3449				endm  
# End of macro CALLMONITOR
3449					endif 
3449			 
3449			 
3449			 
3449				FORTH_RSP_POP     ; get rid of DO ptr 
3449 cd 95 1c			call macro_forth_rsp_pop 
344c				endm 
# End of macro FORTH_RSP_POP
344c			 
344c			if DEBUG_FORTH_WORDS 
344c						DMARK "UN>" 
344c f5				push af  
344d 3a 61 34			ld a, (.dmark)  
3450 32 b4 fb			ld (debug_mark),a  
3453 3a 62 34			ld a, (.dmark+1)  
3456 32 b5 fb			ld (debug_mark+1),a  
3459 3a 63 34			ld a, (.dmark+2)  
345c 32 b6 fb			ld (debug_mark+2),a  
345f 18 03			jr .pastdmark  
3461 ..			.dmark: db "UN>"  
3464 f1			.pastdmark: pop af  
3465			endm  
# End of macro DMARK
3465				CALLMONITOR 
3465 cd 3d 17			call break_point_state  
3468				endm  
# End of macro CALLMONITOR
3468			endif 
3468			 
3468					NEXTW 
3468 c3 36 20			jp macro_next 
346b				endm 
# End of macro NEXTW
346b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
346b			 
346b			.untilnotdone: 
346b			 
346b			 
346b			;	; get DO ptr 
346b			; 
346b				FORTH_RSP_TOS 
346b cd 8b 1c			call macro_forth_rsp_tos 
346e				endm 
# End of macro FORTH_RSP_TOS
346e			 
346e				;push hl 
346e			 
346e				; not going to DO any more 
346e				; get rid of the RSP pointer as DO will add it back in 
346e				;FORTH_RSP_POP 
346e				;pop hl 
346e			 
346e			 
346e 22 9b f2			ld (os_tok_ptr), hl 
3471					if DEBUG_FORTH_WORDS 
3471						DMARK "UN<" 
3471 f5				push af  
3472 3a 86 34			ld a, (.dmark)  
3475 32 b4 fb			ld (debug_mark),a  
3478 3a 87 34			ld a, (.dmark+1)  
347b 32 b5 fb			ld (debug_mark+1),a  
347e 3a 88 34			ld a, (.dmark+2)  
3481 32 b6 fb			ld (debug_mark+2),a  
3484 18 03			jr .pastdmark  
3486 ..			.dmark: db "UN<"  
3489 f1			.pastdmark: pop af  
348a			endm  
# End of macro DMARK
348a					CALLMONITOR 
348a cd 3d 17			call break_point_state  
348d				endm  
# End of macro CALLMONITOR
348d				endif 
348d c3 c7 20			jp exec1 
3490			 
3490					 
3490			 
3490			 
3490					NEXTW 
3490 c3 36 20			jp macro_next 
3493				endm 
# End of macro NEXTW
3493			 
3493			 
3493			.ENDFLOW: 
3493			 
3493			; eof 
3493			 
# End of file forth_words_flow.asm
3493			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3493			include "forth_words_logic.asm" 
3493			 
3493			; | ## Logic Words 
3493			 
3493			.NOT: 
3493				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3493 2d				db WORD_SYS_CORE+25             
3494 db 34			dw .IS            
3496 04				db 3 + 1 
3497 .. 00			db "NOT",0              
349b				endm 
# End of macro CWHEAD
349b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
349b					if DEBUG_FORTH_WORDS_KEY 
349b						DMARK "NOT" 
349b f5				push af  
349c 3a b0 34			ld a, (.dmark)  
349f 32 b4 fb			ld (debug_mark),a  
34a2 3a b1 34			ld a, (.dmark+1)  
34a5 32 b5 fb			ld (debug_mark+1),a  
34a8 3a b2 34			ld a, (.dmark+2)  
34ab 32 b6 fb			ld (debug_mark+2),a  
34ae 18 03			jr .pastdmark  
34b0 ..			.dmark: db "NOT"  
34b3 f1			.pastdmark: pop af  
34b4			endm  
# End of macro DMARK
34b4						CALLMONITOR 
34b4 cd 3d 17			call break_point_state  
34b7				endm  
# End of macro CALLMONITOR
34b7					endif 
34b7					FORTH_DSP 
34b7 cd 8a 1e			call macro_forth_dsp 
34ba				endm 
# End of macro FORTH_DSP
34ba 7e					ld a,(hl)	; get type of value on TOS 
34bb fe 02				cp DS_TYPE_INUM  
34bd 28 03				jr z, .noti 
34bf					NEXTW 
34bf c3 36 20			jp macro_next 
34c2				endm 
# End of macro NEXTW
34c2			.noti:          FORTH_DSP_VALUEHL 
34c2 cd c4 1e			call macro_dsp_valuehl 
34c5				endm 
# End of macro FORTH_DSP_VALUEHL
34c5			;		push hl 
34c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c5 cd 7c 1f			call macro_forth_dsp_pop 
34c8				endm 
# End of macro FORTH_DSP_POP
34c8			;		pop hl 
34c8 3e 00				ld a,0 
34ca bd					cp l 
34cb 28 04				jr z, .not2t 
34cd 2e 00				ld l, 0 
34cf 18 02				jr .notip 
34d1			 
34d1 2e ff		.not2t:		ld l, 255 
34d3			 
34d3 26 00		.notip:		ld h, 0	 
34d5			 
34d5 cd cd 1c				call forth_push_numhl 
34d8					NEXTW 
34d8 c3 36 20			jp macro_next 
34db				endm 
# End of macro NEXTW
34db			 
34db			.IS: 
34db				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34db 2d				db WORD_SYS_CORE+25             
34dc 01 35			dw .LZERO            
34de 03				db 2 + 1 
34df .. 00			db "IS",0              
34e2				endm 
# End of macro CWHEAD
34e2			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34e2					if DEBUG_FORTH_WORDS_KEY 
34e2						DMARK "IS." 
34e2 f5				push af  
34e3 3a f7 34			ld a, (.dmark)  
34e6 32 b4 fb			ld (debug_mark),a  
34e9 3a f8 34			ld a, (.dmark+1)  
34ec 32 b5 fb			ld (debug_mark+1),a  
34ef 3a f9 34			ld a, (.dmark+2)  
34f2 32 b6 fb			ld (debug_mark+2),a  
34f5 18 03			jr .pastdmark  
34f7 ..			.dmark: db "IS."  
34fa f1			.pastdmark: pop af  
34fb			endm  
# End of macro DMARK
34fb						CALLMONITOR 
34fb cd 3d 17			call break_point_state  
34fe				endm  
# End of macro CALLMONITOR
34fe					endif 
34fe					NEXTW 
34fe c3 36 20			jp macro_next 
3501				endm 
# End of macro NEXTW
3501			.LZERO: 
3501				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3501 2d				db WORD_SYS_CORE+25             
3502 0b 35			dw .TZERO            
3504 03				db 2 + 1 
3505 .. 00			db "0<",0              
3508				endm 
# End of macro CWHEAD
3508			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3508					NEXTW 
3508 c3 36 20			jp macro_next 
350b				endm 
# End of macro NEXTW
350b			.TZERO: 
350b				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
350b 2e				db WORD_SYS_CORE+26             
350c 52 35			dw .LESS            
350e 03				db 2 + 1 
350f .. 00			db "0=",0              
3512				endm 
# End of macro CWHEAD
3512			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3512				; TODO add floating point number detection 
3512					;v5 FORTH_DSP_VALUE 
3512					if DEBUG_FORTH_WORDS_KEY 
3512						DMARK "0=." 
3512 f5				push af  
3513 3a 27 35			ld a, (.dmark)  
3516 32 b4 fb			ld (debug_mark),a  
3519 3a 28 35			ld a, (.dmark+1)  
351c 32 b5 fb			ld (debug_mark+1),a  
351f 3a 29 35			ld a, (.dmark+2)  
3522 32 b6 fb			ld (debug_mark+2),a  
3525 18 03			jr .pastdmark  
3527 ..			.dmark: db "0=."  
352a f1			.pastdmark: pop af  
352b			endm  
# End of macro DMARK
352b						CALLMONITOR 
352b cd 3d 17			call break_point_state  
352e				endm  
# End of macro CALLMONITOR
352e					endif 
352e					FORTH_DSP 
352e cd 8a 1e			call macro_forth_dsp 
3531				endm 
# End of macro FORTH_DSP
3531 7e					ld a,(hl)	; get type of value on TOS 
3532 fe 02				cp DS_TYPE_INUM  
3534 28 00				jr z, .tz_inum 
3536			 
3536				if FORTH_ENABLE_FLOATMATH 
3536					jr .tz_done 
3536			 
3536				endif 
3536					 
3536			 
3536			.tz_inum: 
3536					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3536 cd c4 1e			call macro_dsp_valuehl 
3539				endm 
# End of macro FORTH_DSP_VALUEHL
3539			 
3539			;		push hl 
3539			 
3539					; destroy value TOS 
3539			 
3539					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3539 cd 7c 1f			call macro_forth_dsp_pop 
353c				endm 
# End of macro FORTH_DSP_POP
353c			 
353c			;		pop hl 
353c			 
353c 3e 00				ld a,0 
353e			 
353e bd					cp l 
353f 20 08				jr nz, .tz_notzero 
3541			 
3541 bc					cp h 
3542			 
3542 20 05				jr nz, .tz_notzero 
3544			 
3544			 
3544 21 01 00				ld hl, FORTH_TRUE 
3547 18 03				jr .tz_done 
3549			 
3549 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
354c			 
354c					; push value back onto stack for another op etc 
354c			 
354c			.tz_done: 
354c cd cd 1c				call forth_push_numhl 
354f			 
354f					NEXTW 
354f c3 36 20			jp macro_next 
3552				endm 
# End of macro NEXTW
3552			.LESS: 
3552				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3552 2f				db WORD_SYS_CORE+27             
3553 bb 35			dw .GT            
3555 02				db 1 + 1 
3556 .. 00			db "<",0              
3558				endm 
# End of macro CWHEAD
3558			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3558				; TODO add floating point number detection 
3558					if DEBUG_FORTH_WORDS_KEY 
3558						DMARK "LES" 
3558 f5				push af  
3559 3a 6d 35			ld a, (.dmark)  
355c 32 b4 fb			ld (debug_mark),a  
355f 3a 6e 35			ld a, (.dmark+1)  
3562 32 b5 fb			ld (debug_mark+1),a  
3565 3a 6f 35			ld a, (.dmark+2)  
3568 32 b6 fb			ld (debug_mark+2),a  
356b 18 03			jr .pastdmark  
356d ..			.dmark: db "LES"  
3570 f1			.pastdmark: pop af  
3571			endm  
# End of macro DMARK
3571						CALLMONITOR 
3571 cd 3d 17			call break_point_state  
3574				endm  
# End of macro CALLMONITOR
3574					endif 
3574					FORTH_DSP 
3574 cd 8a 1e			call macro_forth_dsp 
3577				endm 
# End of macro FORTH_DSP
3577					;v5 FORTH_DSP_VALUE 
3577 7e					ld a,(hl)	; get type of value on TOS 
3578 fe 02				cp DS_TYPE_INUM  
357a 28 00				jr z, .less_inum 
357c			 
357c				if FORTH_ENABLE_FLOATMATH 
357c					jr .less_done 
357c			 
357c				endif 
357c					 
357c			 
357c			.less_inum: 
357c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
357c cd c4 1e			call macro_dsp_valuehl 
357f				endm 
# End of macro FORTH_DSP_VALUEHL
357f			 
357f e5					push hl  ; u2 
3580			 
3580					; destroy value TOS 
3580			 
3580					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3580 cd 7c 1f			call macro_forth_dsp_pop 
3583				endm 
# End of macro FORTH_DSP_POP
3583			 
3583			 
3583					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3583 cd c4 1e			call macro_dsp_valuehl 
3586				endm 
# End of macro FORTH_DSP_VALUEHL
3586			 
3586 e5					push hl    ; u1 
3587			 
3587					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3587 cd 7c 1f			call macro_forth_dsp_pop 
358a				endm 
# End of macro FORTH_DSP_POP
358a			 
358a			 
358a b7			 or a      ;clear carry flag 
358b 01 00 00		 ld bc, FORTH_FALSE 
358e e1			  pop hl    ; u1 
358f d1			  pop de    ; u2 
3590 ed 52		  sbc hl,de 
3592 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3594			 
3594 01 01 00		 ld bc, FORTH_TRUE 
3597			.lscont:  
3597 c5					push bc 
3598 e1					pop hl 
3599			 
3599					if DEBUG_FORTH_WORDS 
3599						DMARK "LT1" 
3599 f5				push af  
359a 3a ae 35			ld a, (.dmark)  
359d 32 b4 fb			ld (debug_mark),a  
35a0 3a af 35			ld a, (.dmark+1)  
35a3 32 b5 fb			ld (debug_mark+1),a  
35a6 3a b0 35			ld a, (.dmark+2)  
35a9 32 b6 fb			ld (debug_mark+2),a  
35ac 18 03			jr .pastdmark  
35ae ..			.dmark: db "LT1"  
35b1 f1			.pastdmark: pop af  
35b2			endm  
# End of macro DMARK
35b2						CALLMONITOR 
35b2 cd 3d 17			call break_point_state  
35b5				endm  
# End of macro CALLMONITOR
35b5					endif 
35b5 cd cd 1c				call forth_push_numhl 
35b8			 
35b8					NEXTW 
35b8 c3 36 20			jp macro_next 
35bb				endm 
# End of macro NEXTW
35bb			.GT: 
35bb				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35bb 30				db WORD_SYS_CORE+28             
35bc 24 36			dw .EQUAL            
35be 02				db 1 + 1 
35bf .. 00			db ">",0              
35c1				endm 
# End of macro CWHEAD
35c1			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35c1				; TODO add floating point number detection 
35c1					if DEBUG_FORTH_WORDS_KEY 
35c1						DMARK "GRT" 
35c1 f5				push af  
35c2 3a d6 35			ld a, (.dmark)  
35c5 32 b4 fb			ld (debug_mark),a  
35c8 3a d7 35			ld a, (.dmark+1)  
35cb 32 b5 fb			ld (debug_mark+1),a  
35ce 3a d8 35			ld a, (.dmark+2)  
35d1 32 b6 fb			ld (debug_mark+2),a  
35d4 18 03			jr .pastdmark  
35d6 ..			.dmark: db "GRT"  
35d9 f1			.pastdmark: pop af  
35da			endm  
# End of macro DMARK
35da						CALLMONITOR 
35da cd 3d 17			call break_point_state  
35dd				endm  
# End of macro CALLMONITOR
35dd					endif 
35dd					FORTH_DSP 
35dd cd 8a 1e			call macro_forth_dsp 
35e0				endm 
# End of macro FORTH_DSP
35e0					;FORTH_DSP_VALUE 
35e0 7e					ld a,(hl)	; get type of value on TOS 
35e1 fe 02				cp DS_TYPE_INUM  
35e3 28 00				jr z, .gt_inum 
35e5			 
35e5				if FORTH_ENABLE_FLOATMATH 
35e5					jr .gt_done 
35e5			 
35e5				endif 
35e5					 
35e5			 
35e5			.gt_inum: 
35e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e5 cd c4 1e			call macro_dsp_valuehl 
35e8				endm 
# End of macro FORTH_DSP_VALUEHL
35e8			 
35e8 e5					push hl  ; u2 
35e9			 
35e9					; destroy value TOS 
35e9			 
35e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e9 cd 7c 1f			call macro_forth_dsp_pop 
35ec				endm 
# End of macro FORTH_DSP_POP
35ec			 
35ec			 
35ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ec cd c4 1e			call macro_dsp_valuehl 
35ef				endm 
# End of macro FORTH_DSP_VALUEHL
35ef			 
35ef e5					push hl    ; u1 
35f0			 
35f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f0 cd 7c 1f			call macro_forth_dsp_pop 
35f3				endm 
# End of macro FORTH_DSP_POP
35f3			 
35f3			 
35f3 b7			 or a      ;clear carry flag 
35f4 01 00 00		 ld bc, FORTH_FALSE 
35f7 e1			  pop hl    ; u1 
35f8 d1			  pop de    ; u2 
35f9 ed 52		  sbc hl,de 
35fb 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35fd			 
35fd 01 01 00		 ld bc, FORTH_TRUE 
3600			.gtcont:  
3600 c5					push bc 
3601 e1					pop hl 
3602			 
3602					if DEBUG_FORTH_WORDS 
3602						DMARK "GT1" 
3602 f5				push af  
3603 3a 17 36			ld a, (.dmark)  
3606 32 b4 fb			ld (debug_mark),a  
3609 3a 18 36			ld a, (.dmark+1)  
360c 32 b5 fb			ld (debug_mark+1),a  
360f 3a 19 36			ld a, (.dmark+2)  
3612 32 b6 fb			ld (debug_mark+2),a  
3615 18 03			jr .pastdmark  
3617 ..			.dmark: db "GT1"  
361a f1			.pastdmark: pop af  
361b			endm  
# End of macro DMARK
361b						CALLMONITOR 
361b cd 3d 17			call break_point_state  
361e				endm  
# End of macro CALLMONITOR
361e					endif 
361e cd cd 1c				call forth_push_numhl 
3621			 
3621					NEXTW 
3621 c3 36 20			jp macro_next 
3624				endm 
# End of macro NEXTW
3624			.EQUAL: 
3624				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3624 31				db WORD_SYS_CORE+29             
3625 8f 36			dw .ENDLOGIC            
3627 02				db 1 + 1 
3628 .. 00			db "=",0              
362a				endm 
# End of macro CWHEAD
362a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
362a				; TODO add floating point number detection 
362a					if DEBUG_FORTH_WORDS_KEY 
362a						DMARK "EQ." 
362a f5				push af  
362b 3a 3f 36			ld a, (.dmark)  
362e 32 b4 fb			ld (debug_mark),a  
3631 3a 40 36			ld a, (.dmark+1)  
3634 32 b5 fb			ld (debug_mark+1),a  
3637 3a 41 36			ld a, (.dmark+2)  
363a 32 b6 fb			ld (debug_mark+2),a  
363d 18 03			jr .pastdmark  
363f ..			.dmark: db "EQ."  
3642 f1			.pastdmark: pop af  
3643			endm  
# End of macro DMARK
3643						CALLMONITOR 
3643 cd 3d 17			call break_point_state  
3646				endm  
# End of macro CALLMONITOR
3646					endif 
3646					FORTH_DSP 
3646 cd 8a 1e			call macro_forth_dsp 
3649				endm 
# End of macro FORTH_DSP
3649					;v5 FORTH_DSP_VALUE 
3649 7e					ld a,(hl)	; get type of value on TOS 
364a fe 02				cp DS_TYPE_INUM  
364c 28 00				jr z, .eq_inum 
364e			 
364e				if FORTH_ENABLE_FLOATMATH 
364e					jr .eq_done 
364e			 
364e				endif 
364e					 
364e			 
364e			.eq_inum: 
364e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
364e cd c4 1e			call macro_dsp_valuehl 
3651				endm 
# End of macro FORTH_DSP_VALUEHL
3651			 
3651 e5					push hl 
3652			 
3652					; destroy value TOS 
3652			 
3652					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3652 cd 7c 1f			call macro_forth_dsp_pop 
3655				endm 
# End of macro FORTH_DSP_POP
3655			 
3655			 
3655					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3655 cd c4 1e			call macro_dsp_valuehl 
3658				endm 
# End of macro FORTH_DSP_VALUEHL
3658			 
3658					; one value on hl get other one back 
3658			 
3658 e5					push hl 
3659			 
3659					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3659 cd 7c 1f			call macro_forth_dsp_pop 
365c				endm 
# End of macro FORTH_DSP_POP
365c			 
365c 0e 00				ld c, FORTH_FALSE 
365e			 
365e e1					pop hl 
365f d1					pop de 
3660			 
3660 7b					ld a, e 
3661 bd					cp l 
3662			 
3662 20 06				jr nz, .eq_done 
3664			 
3664 7a					ld a, d 
3665 bc					cp h 
3666			 
3666 20 02				jr nz, .eq_done 
3668			 
3668 0e 01				ld c, FORTH_TRUE 
366a					 
366a			 
366a			 
366a			.eq_done: 
366a			 
366a					; TODO push value back onto stack for another op etc 
366a			 
366a 26 00				ld h, 0 
366c 69					ld l, c 
366d					if DEBUG_FORTH_WORDS 
366d						DMARK "EQ1" 
366d f5				push af  
366e 3a 82 36			ld a, (.dmark)  
3671 32 b4 fb			ld (debug_mark),a  
3674 3a 83 36			ld a, (.dmark+1)  
3677 32 b5 fb			ld (debug_mark+1),a  
367a 3a 84 36			ld a, (.dmark+2)  
367d 32 b6 fb			ld (debug_mark+2),a  
3680 18 03			jr .pastdmark  
3682 ..			.dmark: db "EQ1"  
3685 f1			.pastdmark: pop af  
3686			endm  
# End of macro DMARK
3686						CALLMONITOR 
3686 cd 3d 17			call break_point_state  
3689				endm  
# End of macro CALLMONITOR
3689					endif 
3689 cd cd 1c				call forth_push_numhl 
368c			 
368c					NEXTW 
368c c3 36 20			jp macro_next 
368f				endm 
# End of macro NEXTW
368f			 
368f			 
368f			.ENDLOGIC: 
368f			; eof 
368f			 
368f			 
# End of file forth_words_logic.asm
368f			include "forth_words_maths.asm" 
368f			 
368f			; | ## Maths Words 
368f			 
368f			.PLUS:	 
368f				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
368f 15				db WORD_SYS_CORE+1             
3690 d1 36			dw .NEG            
3692 02				db 1 + 1 
3693 .. 00			db "+",0              
3695				endm 
# End of macro CWHEAD
3695			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3695					if DEBUG_FORTH_WORDS_KEY 
3695						DMARK "PLU" 
3695 f5				push af  
3696 3a aa 36			ld a, (.dmark)  
3699 32 b4 fb			ld (debug_mark),a  
369c 3a ab 36			ld a, (.dmark+1)  
369f 32 b5 fb			ld (debug_mark+1),a  
36a2 3a ac 36			ld a, (.dmark+2)  
36a5 32 b6 fb			ld (debug_mark+2),a  
36a8 18 03			jr .pastdmark  
36aa ..			.dmark: db "PLU"  
36ad f1			.pastdmark: pop af  
36ae			endm  
# End of macro DMARK
36ae						CALLMONITOR 
36ae cd 3d 17			call break_point_state  
36b1				endm  
# End of macro CALLMONITOR
36b1					endif 
36b1					; add top two values and push back result 
36b1			 
36b1					;for v5 FORTH_DSP_VALUE 
36b1					FORTH_DSP 
36b1 cd 8a 1e			call macro_forth_dsp 
36b4				endm 
# End of macro FORTH_DSP
36b4 7e					ld a,(hl)	; get type of value on TOS 
36b5 fe 02				cp DS_TYPE_INUM  
36b7 28 03				jr z, .dot_inum 
36b9			 
36b9					NEXTW 
36b9 c3 36 20			jp macro_next 
36bc				endm 
# End of macro NEXTW
36bc			 
36bc			; float maths 
36bc			 
36bc				if FORTH_ENABLE_FLOATMATH 
36bc						inc hl      ; now at start of numeric as string 
36bc			 
36bc					if DEBUG_FORTH_MATHS 
36bc						DMARK "ADD" 
36bc				CALLMONITOR 
36bc					endif 
36bc			 
36bc					;ld ix, hl 
36bc					call CON 
36bc			 
36bc			 
36bc					push hl 
36bc					 
36bc					 
36bc			 
36bc						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36bc			 
36bc					; get next number 
36bc			 
36bc						FORTH_DSP_VALUE 
36bc			 
36bc						inc hl      ; now at start of numeric as string 
36bc			 
36bc					;ld ix, hl 
36bc					call CON 
36bc			 
36bc					push hl 
36bc			 
36bc			 
36bc						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36bc			 
36bc						; TODO do add 
36bc			 
36bc						call IADD 
36bc			 
36bc						; TODO get result back as ascii 
36bc			 
36bc						; TODO push result  
36bc			 
36bc			 
36bc			 
36bc						jr .dot_done 
36bc				endif 
36bc			 
36bc			.dot_inum: 
36bc			 
36bc			 
36bc					if DEBUG_FORTH_DOT 
36bc						DMARK "+IT" 
36bc				CALLMONITOR 
36bc					endif 
36bc			 
36bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36bc cd c4 1e			call macro_dsp_valuehl 
36bf				endm 
# End of macro FORTH_DSP_VALUEHL
36bf			 
36bf				; TODO add floating point number detection 
36bf			 
36bf e5					push hl 
36c0			 
36c0					; destroy value TOS 
36c0			 
36c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c0 cd 7c 1f			call macro_forth_dsp_pop 
36c3				endm 
# End of macro FORTH_DSP_POP
36c3			 
36c3			 
36c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c3 cd c4 1e			call macro_dsp_valuehl 
36c6				endm 
# End of macro FORTH_DSP_VALUEHL
36c6			 
36c6					; one value on hl get other one back 
36c6			 
36c6 d1					pop de 
36c7			 
36c7					; do the add 
36c7			 
36c7 19					add hl,de 
36c8			 
36c8					; save it 
36c8			 
36c8			;		push hl	 
36c8			 
36c8					; 
36c8			 
36c8					; destroy value TOS 
36c8			 
36c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c8 cd 7c 1f			call macro_forth_dsp_pop 
36cb				endm 
# End of macro FORTH_DSP_POP
36cb			 
36cb					; TODO push value back onto stack for another op etc 
36cb			 
36cb			;		pop hl 
36cb			 
36cb			.dot_done: 
36cb cd cd 1c				call forth_push_numhl 
36ce			 
36ce					NEXTW 
36ce c3 36 20			jp macro_next 
36d1				endm 
# End of macro NEXTW
36d1			.NEG: 
36d1			 
36d1				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36d1 17				db WORD_SYS_CORE+3             
36d2 14 37			dw .DIV            
36d4 02				db 1 + 1 
36d5 .. 00			db "-",0              
36d7				endm 
# End of macro CWHEAD
36d7			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36d7					if DEBUG_FORTH_WORDS_KEY 
36d7						DMARK "SUB" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 b4 fb			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 b5 fb			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 b6 fb			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "SUB"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0						CALLMONITOR 
36f0 cd 3d 17			call break_point_state  
36f3				endm  
# End of macro CALLMONITOR
36f3					endif 
36f3			 
36f3			 
36f3				; TODO add floating point number detection 
36f3					; v5 FORTH_DSP_VALUE 
36f3					FORTH_DSP 
36f3 cd 8a 1e			call macro_forth_dsp 
36f6				endm 
# End of macro FORTH_DSP
36f6 7e					ld a,(hl)	; get type of value on TOS 
36f7 fe 02				cp DS_TYPE_INUM  
36f9 28 03				jr z, .neg_inum 
36fb			 
36fb					NEXTW 
36fb c3 36 20			jp macro_next 
36fe				endm 
# End of macro NEXTW
36fe			 
36fe			; float maths 
36fe			 
36fe				if FORTH_ENABLE_FLOATMATH 
36fe					jr .neg_done 
36fe			 
36fe				endif 
36fe					 
36fe			 
36fe			.neg_inum: 
36fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fe cd c4 1e			call macro_dsp_valuehl 
3701				endm 
# End of macro FORTH_DSP_VALUEHL
3701			 
3701 e5					push hl 
3702			 
3702					; destroy value TOS 
3702			 
3702					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3702 cd 7c 1f			call macro_forth_dsp_pop 
3705				endm 
# End of macro FORTH_DSP_POP
3705			 
3705			 
3705					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3705 cd c4 1e			call macro_dsp_valuehl 
3708				endm 
# End of macro FORTH_DSP_VALUEHL
3708			 
3708					; one value on hl get other one back 
3708			 
3708 d1					pop de 
3709			 
3709					; do the sub 
3709			;		ex de, hl 
3709			 
3709 ed 52				sbc hl,de 
370b			 
370b					; save it 
370b			 
370b			;		push hl	 
370b			 
370b					; 
370b			 
370b					; destroy value TOS 
370b			 
370b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370b cd 7c 1f			call macro_forth_dsp_pop 
370e				endm 
# End of macro FORTH_DSP_POP
370e			 
370e					; TODO push value back onto stack for another op etc 
370e			 
370e			;		pop hl 
370e			 
370e cd cd 1c				call forth_push_numhl 
3711			.neg_done: 
3711			 
3711					NEXTW 
3711 c3 36 20			jp macro_next 
3714				endm 
# End of macro NEXTW
3714			.DIV: 
3714				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3714 18				db WORD_SYS_CORE+4             
3715 61 37			dw .MUL            
3717 02				db 1 + 1 
3718 .. 00			db "/",0              
371a				endm 
# End of macro CWHEAD
371a			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
371a					if DEBUG_FORTH_WORDS_KEY 
371a						DMARK "DIV" 
371a f5				push af  
371b 3a 2f 37			ld a, (.dmark)  
371e 32 b4 fb			ld (debug_mark),a  
3721 3a 30 37			ld a, (.dmark+1)  
3724 32 b5 fb			ld (debug_mark+1),a  
3727 3a 31 37			ld a, (.dmark+2)  
372a 32 b6 fb			ld (debug_mark+2),a  
372d 18 03			jr .pastdmark  
372f ..			.dmark: db "DIV"  
3732 f1			.pastdmark: pop af  
3733			endm  
# End of macro DMARK
3733						CALLMONITOR 
3733 cd 3d 17			call break_point_state  
3736				endm  
# End of macro CALLMONITOR
3736					endif 
3736				; TODO add floating point number detection 
3736					; v5 FORTH_DSP_VALUE 
3736					FORTH_DSP 
3736 cd 8a 1e			call macro_forth_dsp 
3739				endm 
# End of macro FORTH_DSP
3739 7e					ld a,(hl)	; get type of value on TOS 
373a fe 02				cp DS_TYPE_INUM  
373c 28 03				jr z, .div_inum 
373e			 
373e				if FORTH_ENABLE_FLOATMATH 
373e					jr .div_done 
373e			 
373e				endif 
373e					NEXTW 
373e c3 36 20			jp macro_next 
3741				endm 
# End of macro NEXTW
3741			.div_inum: 
3741			 
3741					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3741 cd c4 1e			call macro_dsp_valuehl 
3744				endm 
# End of macro FORTH_DSP_VALUEHL
3744			 
3744 e5					push hl    ; to go to bc 
3745			 
3745					; destroy value TOS 
3745			 
3745					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3745 cd 7c 1f			call macro_forth_dsp_pop 
3748				endm 
# End of macro FORTH_DSP_POP
3748			 
3748			 
3748					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3748 cd c4 1e			call macro_dsp_valuehl 
374b				endm 
# End of macro FORTH_DSP_VALUEHL
374b			 
374b					; hl to go to de 
374b			 
374b e5					push hl 
374c			 
374c c1					pop bc 
374d d1					pop de		 
374e			 
374e			 
374e					if DEBUG_FORTH_MATHS 
374e						DMARK "DIV" 
374e				CALLMONITOR 
374e					endif 
374e					; one value on hl but move to a get other one back 
374e			 
374e			        
374e cd 75 0c			call Div16 
3751			 
3751			;	push af	 
3751 e5				push hl 
3752 c5				push bc 
3753			 
3753					if DEBUG_FORTH_MATHS 
3753						DMARK "DI1" 
3753				CALLMONITOR 
3753					endif 
3753			 
3753					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3753 cd 7c 1f			call macro_forth_dsp_pop 
3756				endm 
# End of macro FORTH_DSP_POP
3756			 
3756			 
3756			 
3756 e1					pop hl    ; result 
3757			 
3757 cd cd 1c				call forth_push_numhl 
375a			 
375a e1					pop hl    ; reminder 
375b			;		ld h,0 
375b			;		ld l,d 
375b			 
375b cd cd 1c				call forth_push_numhl 
375e			.div_done: 
375e					NEXTW 
375e c3 36 20			jp macro_next 
3761				endm 
# End of macro NEXTW
3761			.MUL: 
3761				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3761 19				db WORD_SYS_CORE+5             
3762 a6 37			dw .MIN            
3764 02				db 1 + 1 
3765 .. 00			db "*",0              
3767				endm 
# End of macro CWHEAD
3767			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3767				; TODO add floating point number detection 
3767					if DEBUG_FORTH_WORDS_KEY 
3767						DMARK "MUL" 
3767 f5				push af  
3768 3a 7c 37			ld a, (.dmark)  
376b 32 b4 fb			ld (debug_mark),a  
376e 3a 7d 37			ld a, (.dmark+1)  
3771 32 b5 fb			ld (debug_mark+1),a  
3774 3a 7e 37			ld a, (.dmark+2)  
3777 32 b6 fb			ld (debug_mark+2),a  
377a 18 03			jr .pastdmark  
377c ..			.dmark: db "MUL"  
377f f1			.pastdmark: pop af  
3780			endm  
# End of macro DMARK
3780						CALLMONITOR 
3780 cd 3d 17			call break_point_state  
3783				endm  
# End of macro CALLMONITOR
3783					endif 
3783					FORTH_DSP 
3783 cd 8a 1e			call macro_forth_dsp 
3786				endm 
# End of macro FORTH_DSP
3786					; v5 FORTH_DSP_VALUE 
3786 7e					ld a,(hl)	; get type of value on TOS 
3787 fe 02				cp DS_TYPE_INUM  
3789 28 03				jr z, .mul_inum 
378b			 
378b				if FORTH_ENABLE_FLOATMATH 
378b					jr .mul_done 
378b			 
378b				endif 
378b			 
378b					NEXTW 
378b c3 36 20			jp macro_next 
378e				endm 
# End of macro NEXTW
378e			.mul_inum:	 
378e			 
378e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378e cd c4 1e			call macro_dsp_valuehl 
3791				endm 
# End of macro FORTH_DSP_VALUEHL
3791			 
3791 e5					push hl 
3792			 
3792					; destroy value TOS 
3792			 
3792					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3792 cd 7c 1f			call macro_forth_dsp_pop 
3795				endm 
# End of macro FORTH_DSP_POP
3795			 
3795			 
3795					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3795 cd c4 1e			call macro_dsp_valuehl 
3798				endm 
# End of macro FORTH_DSP_VALUEHL
3798			 
3798					; one value on hl but move to a get other one back 
3798			 
3798 7d					ld a, l 
3799			 
3799 d1					pop de 
379a			 
379a					; do the mull 
379a			;		ex de, hl 
379a			 
379a cd 9b 0c				call Mult16 
379d					; save it 
379d			 
379d			;		push hl	 
379d			 
379d					; 
379d			 
379d					; destroy value TOS 
379d			 
379d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379d cd 7c 1f			call macro_forth_dsp_pop 
37a0				endm 
# End of macro FORTH_DSP_POP
37a0			 
37a0					; TODO push value back onto stack for another op etc 
37a0			 
37a0			;		pop hl 
37a0			 
37a0 cd cd 1c				call forth_push_numhl 
37a3			 
37a3			.mul_done: 
37a3					NEXTW 
37a3 c3 36 20			jp macro_next 
37a6				endm 
# End of macro NEXTW
37a6			 
37a6			 
37a6			 
37a6			 
37a6			.MIN: 
37a6				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37a6 49				db WORD_SYS_CORE+53             
37a7 27 38			dw .MAX            
37a9 04				db 3 + 1 
37aa .. 00			db "MIN",0              
37ae				endm 
# End of macro CWHEAD
37ae			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37ae					if DEBUG_FORTH_WORDS_KEY 
37ae						DMARK "MIN" 
37ae f5				push af  
37af 3a c3 37			ld a, (.dmark)  
37b2 32 b4 fb			ld (debug_mark),a  
37b5 3a c4 37			ld a, (.dmark+1)  
37b8 32 b5 fb			ld (debug_mark+1),a  
37bb 3a c5 37			ld a, (.dmark+2)  
37be 32 b6 fb			ld (debug_mark+2),a  
37c1 18 03			jr .pastdmark  
37c3 ..			.dmark: db "MIN"  
37c6 f1			.pastdmark: pop af  
37c7			endm  
# End of macro DMARK
37c7						CALLMONITOR 
37c7 cd 3d 17			call break_point_state  
37ca				endm  
# End of macro CALLMONITOR
37ca					endif 
37ca					; get u2 
37ca			 
37ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ca cd c4 1e			call macro_dsp_valuehl 
37cd				endm 
# End of macro FORTH_DSP_VALUEHL
37cd			 
37cd e5					push hl   ; u2 
37ce			 
37ce					; destroy value TOS 
37ce			 
37ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ce cd 7c 1f			call macro_forth_dsp_pop 
37d1				endm 
# End of macro FORTH_DSP_POP
37d1			 
37d1					; get u1 
37d1			 
37d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d1 cd c4 1e			call macro_dsp_valuehl 
37d4				endm 
# End of macro FORTH_DSP_VALUEHL
37d4			 
37d4 e5					push hl  ; u1 
37d5			 
37d5					; destroy value TOS 
37d5			 
37d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d5 cd 7c 1f			call macro_forth_dsp_pop 
37d8				endm 
# End of macro FORTH_DSP_POP
37d8			 
37d8 b7			 or a      ;clear carry flag 
37d9 e1			  pop hl    ; u1 
37da d1			  pop de    ; u2 
37db e5				push hl   ; saved in case hl is lowest 
37dc ed 52		  sbc hl,de 
37de 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37e0			 
37e0 e1				pop hl 
37e1					if DEBUG_FORTH_WORDS 
37e1						DMARK "MIN" 
37e1 f5				push af  
37e2 3a f6 37			ld a, (.dmark)  
37e5 32 b4 fb			ld (debug_mark),a  
37e8 3a f7 37			ld a, (.dmark+1)  
37eb 32 b5 fb			ld (debug_mark+1),a  
37ee 3a f8 37			ld a, (.dmark+2)  
37f1 32 b6 fb			ld (debug_mark+2),a  
37f4 18 03			jr .pastdmark  
37f6 ..			.dmark: db "MIN"  
37f9 f1			.pastdmark: pop af  
37fa			endm  
# End of macro DMARK
37fa						CALLMONITOR 
37fa cd 3d 17			call break_point_state  
37fd				endm  
# End of macro CALLMONITOR
37fd					endif 
37fd cd cd 1c				call forth_push_numhl 
3800			 
3800				       NEXTW 
3800 c3 36 20			jp macro_next 
3803				endm 
# End of macro NEXTW
3803			 
3803			.mincont:  
3803 c1				pop bc   ; tidy up 
3804 eb				ex de , hl  
3805					if DEBUG_FORTH_WORDS 
3805						DMARK "MI1" 
3805 f5				push af  
3806 3a 1a 38			ld a, (.dmark)  
3809 32 b4 fb			ld (debug_mark),a  
380c 3a 1b 38			ld a, (.dmark+1)  
380f 32 b5 fb			ld (debug_mark+1),a  
3812 3a 1c 38			ld a, (.dmark+2)  
3815 32 b6 fb			ld (debug_mark+2),a  
3818 18 03			jr .pastdmark  
381a ..			.dmark: db "MI1"  
381d f1			.pastdmark: pop af  
381e			endm  
# End of macro DMARK
381e						CALLMONITOR 
381e cd 3d 17			call break_point_state  
3821				endm  
# End of macro CALLMONITOR
3821					endif 
3821 cd cd 1c				call forth_push_numhl 
3824			 
3824				       NEXTW 
3824 c3 36 20			jp macro_next 
3827				endm 
# End of macro NEXTW
3827			.MAX: 
3827				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3827 4a				db WORD_SYS_CORE+54             
3828 a8 38			dw .RND16            
382a 04				db 3 + 1 
382b .. 00			db "MAX",0              
382f				endm 
# End of macro CWHEAD
382f			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
382f					if DEBUG_FORTH_WORDS_KEY 
382f						DMARK "MAX" 
382f f5				push af  
3830 3a 44 38			ld a, (.dmark)  
3833 32 b4 fb			ld (debug_mark),a  
3836 3a 45 38			ld a, (.dmark+1)  
3839 32 b5 fb			ld (debug_mark+1),a  
383c 3a 46 38			ld a, (.dmark+2)  
383f 32 b6 fb			ld (debug_mark+2),a  
3842 18 03			jr .pastdmark  
3844 ..			.dmark: db "MAX"  
3847 f1			.pastdmark: pop af  
3848			endm  
# End of macro DMARK
3848						CALLMONITOR 
3848 cd 3d 17			call break_point_state  
384b				endm  
# End of macro CALLMONITOR
384b					endif 
384b					; get u2 
384b			 
384b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
384b cd c4 1e			call macro_dsp_valuehl 
384e				endm 
# End of macro FORTH_DSP_VALUEHL
384e			 
384e e5					push hl   ; u2 
384f			 
384f					; destroy value TOS 
384f			 
384f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
384f cd 7c 1f			call macro_forth_dsp_pop 
3852				endm 
# End of macro FORTH_DSP_POP
3852			 
3852					; get u1 
3852			 
3852					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3852 cd c4 1e			call macro_dsp_valuehl 
3855				endm 
# End of macro FORTH_DSP_VALUEHL
3855			 
3855 e5					push hl  ; u1 
3856			 
3856					; destroy value TOS 
3856			 
3856					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3856 cd 7c 1f			call macro_forth_dsp_pop 
3859				endm 
# End of macro FORTH_DSP_POP
3859			 
3859 b7			 or a      ;clear carry flag 
385a e1			  pop hl    ; u1 
385b d1			  pop de    ; u2 
385c e5				push hl   ; saved in case hl is lowest 
385d ed 52		  sbc hl,de 
385f 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3861			 
3861 e1				pop hl 
3862					if DEBUG_FORTH_WORDS 
3862						DMARK "MAX" 
3862 f5				push af  
3863 3a 77 38			ld a, (.dmark)  
3866 32 b4 fb			ld (debug_mark),a  
3869 3a 78 38			ld a, (.dmark+1)  
386c 32 b5 fb			ld (debug_mark+1),a  
386f 3a 79 38			ld a, (.dmark+2)  
3872 32 b6 fb			ld (debug_mark+2),a  
3875 18 03			jr .pastdmark  
3877 ..			.dmark: db "MAX"  
387a f1			.pastdmark: pop af  
387b			endm  
# End of macro DMARK
387b						CALLMONITOR 
387b cd 3d 17			call break_point_state  
387e				endm  
# End of macro CALLMONITOR
387e					endif 
387e cd cd 1c				call forth_push_numhl 
3881			 
3881				       NEXTW 
3881 c3 36 20			jp macro_next 
3884				endm 
# End of macro NEXTW
3884			 
3884			.maxcont:  
3884 c1				pop bc   ; tidy up 
3885 eb				ex de , hl  
3886					if DEBUG_FORTH_WORDS 
3886						DMARK "MA1" 
3886 f5				push af  
3887 3a 9b 38			ld a, (.dmark)  
388a 32 b4 fb			ld (debug_mark),a  
388d 3a 9c 38			ld a, (.dmark+1)  
3890 32 b5 fb			ld (debug_mark+1),a  
3893 3a 9d 38			ld a, (.dmark+2)  
3896 32 b6 fb			ld (debug_mark+2),a  
3899 18 03			jr .pastdmark  
389b ..			.dmark: db "MA1"  
389e f1			.pastdmark: pop af  
389f			endm  
# End of macro DMARK
389f						CALLMONITOR 
389f cd 3d 17			call break_point_state  
38a2				endm  
# End of macro CALLMONITOR
38a2					endif 
38a2 cd cd 1c				call forth_push_numhl 
38a5				       NEXTW 
38a5 c3 36 20			jp macro_next 
38a8				endm 
# End of macro NEXTW
38a8			 
38a8			.RND16: 
38a8				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38a8 4e				db WORD_SYS_CORE+58             
38a9 d7 38			dw .RND8            
38ab 06				db 5 + 1 
38ac .. 00			db "RND16",0              
38b2				endm 
# End of macro CWHEAD
38b2			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38b2					if DEBUG_FORTH_WORDS_KEY 
38b2						DMARK "R16" 
38b2 f5				push af  
38b3 3a c7 38			ld a, (.dmark)  
38b6 32 b4 fb			ld (debug_mark),a  
38b9 3a c8 38			ld a, (.dmark+1)  
38bc 32 b5 fb			ld (debug_mark+1),a  
38bf 3a c9 38			ld a, (.dmark+2)  
38c2 32 b6 fb			ld (debug_mark+2),a  
38c5 18 03			jr .pastdmark  
38c7 ..			.dmark: db "R16"  
38ca f1			.pastdmark: pop af  
38cb			endm  
# End of macro DMARK
38cb						CALLMONITOR 
38cb cd 3d 17			call break_point_state  
38ce				endm  
# End of macro CALLMONITOR
38ce					endif 
38ce cd 3f 0c				call prng16  
38d1 cd cd 1c				call forth_push_numhl 
38d4				       NEXTW 
38d4 c3 36 20			jp macro_next 
38d7				endm 
# End of macro NEXTW
38d7			.RND8: 
38d7				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38d7 60				db WORD_SYS_CORE+76             
38d8 0c 39			dw .RND            
38da 05				db 4 + 1 
38db .. 00			db "RND8",0              
38e0				endm 
# End of macro CWHEAD
38e0			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38e0					if DEBUG_FORTH_WORDS_KEY 
38e0						DMARK "RN8" 
38e0 f5				push af  
38e1 3a f5 38			ld a, (.dmark)  
38e4 32 b4 fb			ld (debug_mark),a  
38e7 3a f6 38			ld a, (.dmark+1)  
38ea 32 b5 fb			ld (debug_mark+1),a  
38ed 3a f7 38			ld a, (.dmark+2)  
38f0 32 b6 fb			ld (debug_mark+2),a  
38f3 18 03			jr .pastdmark  
38f5 ..			.dmark: db "RN8"  
38f8 f1			.pastdmark: pop af  
38f9			endm  
# End of macro DMARK
38f9						CALLMONITOR 
38f9 cd 3d 17			call break_point_state  
38fc				endm  
# End of macro CALLMONITOR
38fc					endif 
38fc 2a 35 fa				ld hl,(xrandc) 
38ff 23					inc hl 
3900 cd 59 0c				call xrnd 
3903 6f					ld l,a	 
3904 26 00				ld h,0 
3906 cd cd 1c				call forth_push_numhl 
3909				       NEXTW 
3909 c3 36 20			jp macro_next 
390c				endm 
# End of macro NEXTW
390c			.RND: 
390c				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
390c 60				db WORD_SYS_CORE+76             
390d 12 3a			dw .ENDMATHS            
390f 04				db 3 + 1 
3910 .. 00			db "RND",0              
3914				endm 
# End of macro CWHEAD
3914			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3914			 
3914					if DEBUG_FORTH_WORDS_KEY 
3914						DMARK "RND" 
3914 f5				push af  
3915 3a 29 39			ld a, (.dmark)  
3918 32 b4 fb			ld (debug_mark),a  
391b 3a 2a 39			ld a, (.dmark+1)  
391e 32 b5 fb			ld (debug_mark+1),a  
3921 3a 2b 39			ld a, (.dmark+2)  
3924 32 b6 fb			ld (debug_mark+2),a  
3927 18 03			jr .pastdmark  
3929 ..			.dmark: db "RND"  
392c f1			.pastdmark: pop af  
392d			endm  
# End of macro DMARK
392d						CALLMONITOR 
392d cd 3d 17			call break_point_state  
3930				endm  
# End of macro CALLMONITOR
3930					endif 
3930					 
3930					FORTH_DSP_VALUEHL    ; upper range 
3930 cd c4 1e			call macro_dsp_valuehl 
3933				endm 
# End of macro FORTH_DSP_VALUEHL
3933			 
3933 22 39 fa				ld (LFSRSeed), hl	 
3936			 
3936					if DEBUG_FORTH_WORDS 
3936						DMARK "RN1" 
3936 f5				push af  
3937 3a 4b 39			ld a, (.dmark)  
393a 32 b4 fb			ld (debug_mark),a  
393d 3a 4c 39			ld a, (.dmark+1)  
3940 32 b5 fb			ld (debug_mark+1),a  
3943 3a 4d 39			ld a, (.dmark+2)  
3946 32 b6 fb			ld (debug_mark+2),a  
3949 18 03			jr .pastdmark  
394b ..			.dmark: db "RN1"  
394e f1			.pastdmark: pop af  
394f			endm  
# End of macro DMARK
394f						CALLMONITOR 
394f cd 3d 17			call break_point_state  
3952				endm  
# End of macro CALLMONITOR
3952					endif 
3952					FORTH_DSP_POP 
3952 cd 7c 1f			call macro_forth_dsp_pop 
3955				endm 
# End of macro FORTH_DSP_POP
3955			 
3955					FORTH_DSP_VALUEHL    ; low range 
3955 cd c4 1e			call macro_dsp_valuehl 
3958				endm 
# End of macro FORTH_DSP_VALUEHL
3958			 
3958					if DEBUG_FORTH_WORDS 
3958						DMARK "RN2" 
3958 f5				push af  
3959 3a 6d 39			ld a, (.dmark)  
395c 32 b4 fb			ld (debug_mark),a  
395f 3a 6e 39			ld a, (.dmark+1)  
3962 32 b5 fb			ld (debug_mark+1),a  
3965 3a 6f 39			ld a, (.dmark+2)  
3968 32 b6 fb			ld (debug_mark+2),a  
396b 18 03			jr .pastdmark  
396d ..			.dmark: db "RN2"  
3970 f1			.pastdmark: pop af  
3971			endm  
# End of macro DMARK
3971						CALLMONITOR 
3971 cd 3d 17			call break_point_state  
3974				endm  
# End of macro CALLMONITOR
3974					endif 
3974 22 3b fa				ld (LFSRSeed+2), hl 
3977			 
3977					FORTH_DSP_POP 
3977 cd 7c 1f			call macro_forth_dsp_pop 
397a				endm 
# End of macro FORTH_DSP_POP
397a			 
397a e5					push hl 
397b			 
397b e1			.inrange:	pop hl 
397c cd 3f 0c				call prng16  
397f					if DEBUG_FORTH_WORDS 
397f						DMARK "RN3" 
397f f5				push af  
3980 3a 94 39			ld a, (.dmark)  
3983 32 b4 fb			ld (debug_mark),a  
3986 3a 95 39			ld a, (.dmark+1)  
3989 32 b5 fb			ld (debug_mark+1),a  
398c 3a 96 39			ld a, (.dmark+2)  
398f 32 b6 fb			ld (debug_mark+2),a  
3992 18 03			jr .pastdmark  
3994 ..			.dmark: db "RN3"  
3997 f1			.pastdmark: pop af  
3998			endm  
# End of macro DMARK
3998						CALLMONITOR 
3998 cd 3d 17			call break_point_state  
399b				endm  
# End of macro CALLMONITOR
399b					endif 
399b					 
399b					; if the range is 8bit knock out the high byte 
399b			 
399b ed 5b 39 fa			ld de, (LFSRSeed)     ; check high level 
399f			 
399f 3e 00				ld a, 0 
39a1 ba					cp d  
39a2 20 1e				jr nz, .hirange 
39a4 26 00				ld h, 0   ; knock it down to 8bit 
39a6			 
39a6					if DEBUG_FORTH_WORDS 
39a6						DMARK "RNk" 
39a6 f5				push af  
39a7 3a bb 39			ld a, (.dmark)  
39aa 32 b4 fb			ld (debug_mark),a  
39ad 3a bc 39			ld a, (.dmark+1)  
39b0 32 b5 fb			ld (debug_mark+1),a  
39b3 3a bd 39			ld a, (.dmark+2)  
39b6 32 b6 fb			ld (debug_mark+2),a  
39b9 18 03			jr .pastdmark  
39bb ..			.dmark: db "RNk"  
39be f1			.pastdmark: pop af  
39bf			endm  
# End of macro DMARK
39bf						CALLMONITOR 
39bf cd 3d 17			call break_point_state  
39c2				endm  
# End of macro CALLMONITOR
39c2					endif 
39c2			.hirange:   
39c2 e5					push hl  
39c3 b7					or a  
39c4 ed 52		                sbc hl, de 
39c6			 
39c6					;call cmp16 
39c6			 
39c6 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39c8 e1					pop hl 
39c9 e5					push hl 
39ca			 
39ca					if DEBUG_FORTH_WORDS 
39ca						DMARK "RN4" 
39ca f5				push af  
39cb 3a df 39			ld a, (.dmark)  
39ce 32 b4 fb			ld (debug_mark),a  
39d1 3a e0 39			ld a, (.dmark+1)  
39d4 32 b5 fb			ld (debug_mark+1),a  
39d7 3a e1 39			ld a, (.dmark+2)  
39da 32 b6 fb			ld (debug_mark+2),a  
39dd 18 03			jr .pastdmark  
39df ..			.dmark: db "RN4"  
39e2 f1			.pastdmark: pop af  
39e3			endm  
# End of macro DMARK
39e3						CALLMONITOR 
39e3 cd 3d 17			call break_point_state  
39e6				endm  
# End of macro CALLMONITOR
39e6					endif 
39e6 ed 5b 3b fa			ld de, (LFSRSeed+2)   ; check low range 
39ea					;call cmp16 
39ea				 
39ea b7					or a  
39eb ed 52		                sbc hl, de 
39ed 38 8c				jr c, .inrange 
39ef			 
39ef e1					pop hl 
39f0					 
39f0					if DEBUG_FORTH_WORDS 
39f0						DMARK "RNd" 
39f0 f5				push af  
39f1 3a 05 3a			ld a, (.dmark)  
39f4 32 b4 fb			ld (debug_mark),a  
39f7 3a 06 3a			ld a, (.dmark+1)  
39fa 32 b5 fb			ld (debug_mark+1),a  
39fd 3a 07 3a			ld a, (.dmark+2)  
3a00 32 b6 fb			ld (debug_mark+2),a  
3a03 18 03			jr .pastdmark  
3a05 ..			.dmark: db "RNd"  
3a08 f1			.pastdmark: pop af  
3a09			endm  
# End of macro DMARK
3a09						CALLMONITOR 
3a09 cd 3d 17			call break_point_state  
3a0c				endm  
# End of macro CALLMONITOR
3a0c					endif 
3a0c			 
3a0c			 
3a0c cd cd 1c				call forth_push_numhl 
3a0f				       NEXTW 
3a0f c3 36 20			jp macro_next 
3a12				endm 
# End of macro NEXTW
3a12			 
3a12			.ENDMATHS: 
3a12			 
3a12			; eof 
3a12			 
# End of file forth_words_maths.asm
3a12			include "forth_words_display.asm" 
3a12			 
3a12			; | ## Display Words 
3a12			 
3a12			.INFO: 
3a12			 
3a12				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a12 62				db WORD_SYS_CORE+78             
3a13 2f 3a			dw .ATP            
3a15 05				db 4 + 1 
3a16 .. 00			db "INFO",0              
3a1b				endm 
# End of macro CWHEAD
3a1b			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a1b					FORTH_DSP_VALUEHL 
3a1b cd c4 1e			call macro_dsp_valuehl 
3a1e				endm 
# End of macro FORTH_DSP_VALUEHL
3a1e			 
3a1e					FORTH_DSP_POP 
3a1e cd 7c 1f			call macro_forth_dsp_pop 
3a21				endm 
# End of macro FORTH_DSP_POP
3a21			 
3a21 e5					push hl 
3a22			 
3a22					FORTH_DSP_VALUEHL 
3a22 cd c4 1e			call macro_dsp_valuehl 
3a25				endm 
# End of macro FORTH_DSP_VALUEHL
3a25			 
3a25					FORTH_DSP_POP 
3a25 cd 7c 1f			call macro_forth_dsp_pop 
3a28				endm 
# End of macro FORTH_DSP_POP
3a28			 
3a28 d1					pop de 
3a29			 
3a29 cd 75 0a				call info_panel 
3a2c			 
3a2c			 
3a2c					NEXTW 
3a2c c3 36 20			jp macro_next 
3a2f				endm 
# End of macro NEXTW
3a2f			.ATP: 
3a2f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a2f 62				db WORD_SYS_CORE+78             
3a30 a6 3a			dw .FB            
3a32 04				db 3 + 1 
3a33 .. 00			db "AT?",0              
3a37				endm 
# End of macro CWHEAD
3a37			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a37					if DEBUG_FORTH_WORDS_KEY 
3a37						DMARK "AT?" 
3a37 f5				push af  
3a38 3a 4c 3a			ld a, (.dmark)  
3a3b 32 b4 fb			ld (debug_mark),a  
3a3e 3a 4d 3a			ld a, (.dmark+1)  
3a41 32 b5 fb			ld (debug_mark+1),a  
3a44 3a 4e 3a			ld a, (.dmark+2)  
3a47 32 b6 fb			ld (debug_mark+2),a  
3a4a 18 03			jr .pastdmark  
3a4c ..			.dmark: db "AT?"  
3a4f f1			.pastdmark: pop af  
3a50			endm  
# End of macro DMARK
3a50						CALLMONITOR 
3a50 cd 3d 17			call break_point_state  
3a53				endm  
# End of macro CALLMONITOR
3a53					endif 
3a53 3a c3 f9				ld a, (f_cursor_ptr) 
3a56			 
3a56			if DEBUG_FORTH_WORDS 
3a56				DMARK "AT?" 
3a56 f5				push af  
3a57 3a 6b 3a			ld a, (.dmark)  
3a5a 32 b4 fb			ld (debug_mark),a  
3a5d 3a 6c 3a			ld a, (.dmark+1)  
3a60 32 b5 fb			ld (debug_mark+1),a  
3a63 3a 6d 3a			ld a, (.dmark+2)  
3a66 32 b6 fb			ld (debug_mark+2),a  
3a69 18 03			jr .pastdmark  
3a6b ..			.dmark: db "AT?"  
3a6e f1			.pastdmark: pop af  
3a6f			endm  
# End of macro DMARK
3a6f				CALLMONITOR 
3a6f cd 3d 17			call break_point_state  
3a72				endm  
# End of macro CALLMONITOR
3a72			endif	 
3a72					; count the number of rows 
3a72			 
3a72 06 00				ld b, 0 
3a74 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a75 d6 14				sub display_cols 
3a77 f2 7d 3a				jp p, .atprunder 
3a7a 04					inc b 
3a7b 18 f7				jr .atpr 
3a7d			.atprunder:	 
3a7d			if DEBUG_FORTH_WORDS 
3a7d				DMARK "A?2" 
3a7d f5				push af  
3a7e 3a 92 3a			ld a, (.dmark)  
3a81 32 b4 fb			ld (debug_mark),a  
3a84 3a 93 3a			ld a, (.dmark+1)  
3a87 32 b5 fb			ld (debug_mark+1),a  
3a8a 3a 94 3a			ld a, (.dmark+2)  
3a8d 32 b6 fb			ld (debug_mark+2),a  
3a90 18 03			jr .pastdmark  
3a92 ..			.dmark: db "A?2"  
3a95 f1			.pastdmark: pop af  
3a96			endm  
# End of macro DMARK
3a96				CALLMONITOR 
3a96 cd 3d 17			call break_point_state  
3a99				endm  
# End of macro CALLMONITOR
3a99			endif	 
3a99 26 00				ld h, 0 
3a9b 69					ld l, c 
3a9c cd cd 1c				call forth_push_numhl 
3a9f 68					ld l, b  
3aa0 cd cd 1c				call forth_push_numhl 
3aa3			 
3aa3			 
3aa3				NEXTW 
3aa3 c3 36 20			jp macro_next 
3aa6				endm 
# End of macro NEXTW
3aa6			 
3aa6			.FB: 
3aa6				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3aa6 1b				db WORD_SYS_CORE+7             
3aa7 f4 3a			dw .EMIT            
3aa9 03				db 2 + 1 
3aaa .. 00			db "FB",0              
3aad				endm 
# End of macro CWHEAD
3aad			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3aad			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3aad			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3aad			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3aad					if DEBUG_FORTH_WORDS_KEY 
3aad						DMARK "FB." 
3aad f5				push af  
3aae 3a c2 3a			ld a, (.dmark)  
3ab1 32 b4 fb			ld (debug_mark),a  
3ab4 3a c3 3a			ld a, (.dmark+1)  
3ab7 32 b5 fb			ld (debug_mark+1),a  
3aba 3a c4 3a			ld a, (.dmark+2)  
3abd 32 b6 fb			ld (debug_mark+2),a  
3ac0 18 03			jr .pastdmark  
3ac2 ..			.dmark: db "FB."  
3ac5 f1			.pastdmark: pop af  
3ac6			endm  
# End of macro DMARK
3ac6						CALLMONITOR 
3ac6 cd 3d 17			call break_point_state  
3ac9				endm  
# End of macro CALLMONITOR
3ac9					endif 
3ac9			 
3ac9					FORTH_DSP_VALUEHL 
3ac9 cd c4 1e			call macro_dsp_valuehl 
3acc				endm 
# End of macro FORTH_DSP_VALUEHL
3acc			 
3acc 7d					ld a, l 
3acd fe 01				cp 1 
3acf 20 05				jr nz, .fbn1 
3ad1 21 f9 fa				ld hl, display_fb1 
3ad4 18 15				jr .fbset 
3ad6 fe 02		.fbn1:		cp 2 
3ad8 20 05				jr nz, .fbn2 
3ada 21 57 fa				ld hl, display_fb2 
3add 18 0c				jr .fbset 
3adf fe 03		.fbn2:		cp 3 
3ae1 20 05				jr nz, .fbn3 
3ae3 21 a8 fa				ld hl, display_fb3 
3ae6 18 03				jr .fbset 
3ae8			.fbn3:		 ; if invalid number select first 
3ae8 21 f9 fa				ld hl, display_fb1 
3aeb 22 55 fa		.fbset:		ld (display_fb_active), hl 
3aee			 
3aee					FORTH_DSP_POP 
3aee cd 7c 1f			call macro_forth_dsp_pop 
3af1				endm 
# End of macro FORTH_DSP_POP
3af1			 
3af1					NEXTW 
3af1 c3 36 20			jp macro_next 
3af4				endm 
# End of macro NEXTW
3af4			 
3af4			 
3af4			.EMIT: 
3af4				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3af4 1b				db WORD_SYS_CORE+7             
3af5 45 3b			dw .DOTH            
3af7 05				db 4 + 1 
3af8 .. 00			db "EMIT",0              
3afd				endm 
# End of macro CWHEAD
3afd			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3afd					; get value off TOS and display it 
3afd			 
3afd					if DEBUG_FORTH_WORDS_KEY 
3afd						DMARK "EMT" 
3afd f5				push af  
3afe 3a 12 3b			ld a, (.dmark)  
3b01 32 b4 fb			ld (debug_mark),a  
3b04 3a 13 3b			ld a, (.dmark+1)  
3b07 32 b5 fb			ld (debug_mark+1),a  
3b0a 3a 14 3b			ld a, (.dmark+2)  
3b0d 32 b6 fb			ld (debug_mark+2),a  
3b10 18 03			jr .pastdmark  
3b12 ..			.dmark: db "EMT"  
3b15 f1			.pastdmark: pop af  
3b16			endm  
# End of macro DMARK
3b16						CALLMONITOR 
3b16 cd 3d 17			call break_point_state  
3b19				endm  
# End of macro CALLMONITOR
3b19					endif 
3b19			 
3b19					FORTH_DSP_VALUEHL 
3b19 cd c4 1e			call macro_dsp_valuehl 
3b1c				endm 
# End of macro FORTH_DSP_VALUEHL
3b1c			 
3b1c 7d					ld a,l 
3b1d			 
3b1d					; TODO write to display 
3b1d			 
3b1d 32 98 f1				ld (os_input), a 
3b20 3e 00				ld a, 0 
3b22 32 99 f1				ld (os_input+1), a 
3b25					 
3b25 3a c3 f9				ld a, (f_cursor_ptr) 
3b28 11 98 f1				ld de, os_input 
3b2b cd f7 0a				call str_at_display 
3b2e			 
3b2e			 
3b2e 3a a1 f9				ld a,(cli_autodisplay) 
3b31 fe 00				cp 0 
3b33 28 03				jr z, .enoupdate 
3b35 cd 07 0b						call update_display 
3b38					.enoupdate: 
3b38			 
3b38 3a c3 f9				ld a, (f_cursor_ptr) 
3b3b 3c					inc a 
3b3c 32 c3 f9				ld (f_cursor_ptr), a   ; save new pos 
3b3f			 
3b3f			 
3b3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b3f cd 7c 1f			call macro_forth_dsp_pop 
3b42				endm 
# End of macro FORTH_DSP_POP
3b42			  
3b42			 
3b42					NEXTW 
3b42 c3 36 20			jp macro_next 
3b45				endm 
# End of macro NEXTW
3b45			.DOTH: 
3b45				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b45 1c				db WORD_SYS_CORE+8             
3b46 75 3b			dw .DOTF            
3b48 03				db 2 + 1 
3b49 .. 00			db ".-",0              
3b4c				endm 
# End of macro CWHEAD
3b4c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b4c					; get value off TOS and display it 
3b4c					if DEBUG_FORTH_WORDS_KEY 
3b4c						DMARK "DTD" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 b4 fb			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 b5 fb			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 b6 fb			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "DTD"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						CALLMONITOR 
3b65 cd 3d 17			call break_point_state  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b6a 3e 00			ld a, 0 
3b6c 32 a2 f9			ld (cli_mvdot), a 
3b6f c3 cc 3b			jp .dotgo 
3b72				NEXTW 
3b72 c3 36 20			jp macro_next 
3b75				endm 
# End of macro NEXTW
3b75			.DOTF: 
3b75				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b75 1c				db WORD_SYS_CORE+8             
3b76 a3 3b			dw .DOT            
3b78 03				db 2 + 1 
3b79 .. 00			db ".>",0              
3b7c				endm 
# End of macro CWHEAD
3b7c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b7c					; get value off TOS and display it 
3b7c			        ; TODO BUG adds extra spaces 
3b7c			        ; TODO BUG handle numerics? 
3b7c					if DEBUG_FORTH_WORDS_KEY 
3b7c						DMARK "DTC" 
3b7c f5				push af  
3b7d 3a 91 3b			ld a, (.dmark)  
3b80 32 b4 fb			ld (debug_mark),a  
3b83 3a 92 3b			ld a, (.dmark+1)  
3b86 32 b5 fb			ld (debug_mark+1),a  
3b89 3a 93 3b			ld a, (.dmark+2)  
3b8c 32 b6 fb			ld (debug_mark+2),a  
3b8f 18 03			jr .pastdmark  
3b91 ..			.dmark: db "DTC"  
3b94 f1			.pastdmark: pop af  
3b95			endm  
# End of macro DMARK
3b95						CALLMONITOR 
3b95 cd 3d 17			call break_point_state  
3b98				endm  
# End of macro CALLMONITOR
3b98					endif 
3b98 3e 01			ld a, 1 
3b9a 32 a2 f9			ld (cli_mvdot), a 
3b9d c3 cc 3b			jp .dotgo 
3ba0				NEXTW 
3ba0 c3 36 20			jp macro_next 
3ba3				endm 
# End of macro NEXTW
3ba3			 
3ba3			.DOT: 
3ba3				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ba3 1c				db WORD_SYS_CORE+8             
3ba4 2f 3c			dw .CLS            
3ba6 02				db 1 + 1 
3ba7 .. 00			db ".",0              
3ba9				endm 
# End of macro CWHEAD
3ba9			        ; | . ( u -- ) Display TOS | DONE 
3ba9					; get value off TOS and display it 
3ba9			 
3ba9					if DEBUG_FORTH_WORDS_KEY 
3ba9						DMARK "DOT" 
3ba9 f5				push af  
3baa 3a be 3b			ld a, (.dmark)  
3bad 32 b4 fb			ld (debug_mark),a  
3bb0 3a bf 3b			ld a, (.dmark+1)  
3bb3 32 b5 fb			ld (debug_mark+1),a  
3bb6 3a c0 3b			ld a, (.dmark+2)  
3bb9 32 b6 fb			ld (debug_mark+2),a  
3bbc 18 03			jr .pastdmark  
3bbe ..			.dmark: db "DOT"  
3bc1 f1			.pastdmark: pop af  
3bc2			endm  
# End of macro DMARK
3bc2						CALLMONITOR 
3bc2 cd 3d 17			call break_point_state  
3bc5				endm  
# End of macro CALLMONITOR
3bc5					endif 
3bc5 3e 00			ld a, 0 
3bc7 32 a2 f9			ld (cli_mvdot), a 
3bca 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bcc				 
3bcc			 
3bcc			.dotgo: 
3bcc			 
3bcc			; move up type to on stack for parserv5 
3bcc					FORTH_DSP 
3bcc cd 8a 1e			call macro_forth_dsp 
3bcf				endm 
# End of macro FORTH_DSP
3bcf				;FORTH_DSP_VALUE  
3bcf			 
3bcf			if DEBUG_FORTH_DOT 
3bcf				DMARK "DOT" 
3bcf				CALLMONITOR 
3bcf			endif	 
3bcf			;		.print: 
3bcf			 
3bcf 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bd0 23				inc hl   ; position to the actual value 
3bd1 fe 01			cp DS_TYPE_STR 
3bd3 20 06			jr nz, .dotnum1  
3bd5			 
3bd5			; display string 
3bd5				FORTH_DSP_VALUE  
3bd5 cd ad 1e			call macro_forth_dsp_value 
3bd8				endm 
# End of macro FORTH_DSP_VALUE
3bd8 eb				ex de,hl 
3bd9 18 11			jr .dotwrite 
3bdb			 
3bdb			.dotnum1: 
3bdb fe 02			cp DS_TYPE_INUM 
3bdd 20 0c			jr nz, .dotflot 
3bdf			 
3bdf			 
3bdf			; display number 
3bdf			 
3bdf			;	push hl 
3bdf			;	call clear_display 
3bdf			;	pop hl 
3bdf			 
3bdf 5e				ld e, (hl) 
3be0 23				inc hl 
3be1 56				ld d, (hl) 
3be2 21 9a ef			ld hl, scratch 
3be5			if DEBUG_FORTH_DOT 
3be5				DMARK "DT1" 
3be5				CALLMONITOR 
3be5			endif	 
3be5			 
3be5 cd 25 11			call uitoa_16 
3be8 eb				ex de,hl 
3be9			 
3be9			if DEBUG_FORTH_DOT 
3be9				DMARK "DT2" 
3be9				CALLMONITOR 
3be9			endif	 
3be9			 
3be9			;	ld de, os_word_scratch 
3be9 18 01			jr .dotwrite 
3beb			 
3beb 00			.dotflot:   nop 
3bec			; TODO print floating point number 
3bec			 
3bec			.dotwrite:		 
3bec			 
3bec					; if c is set then set all '-' to spaces 
3bec					; need to also take into account .>  
3bec			 
3bec 3e 01				ld a, 1 
3bee b9					cp c 
3bef 20 13				jr nz, .nodashswap 
3bf1			 
3bf1					; DE has the string to write, working with HL 
3bf1			 
3bf1 06 ff				ld b, 255 
3bf3 d5					push de 
3bf4 e1					pop hl 
3bf5			 
3bf5			if DEBUG_FORTH_DOT 
3bf5				DMARK "DT-" 
3bf5				CALLMONITOR 
3bf5			endif	 
3bf5 7e			.dashscan:	ld a, (hl) 
3bf6 fe 00				cp 0 
3bf8 28 0a				jr z, .nodashswap 
3bfa fe 2d				cp '-' 
3bfc 20 03				jr nz, .dashskip 
3bfe 3e 20				ld a, ' ' 
3c00 77					ld (hl), a 
3c01 23			.dashskip:	inc hl 
3c02			if DEBUG_FORTH_DOT 
3c02				DMARK "D-2" 
3c02				CALLMONITOR 
3c02			endif	 
3c02 10 f1				djnz .dashscan 
3c04			 
3c04			if DEBUG_FORTH_DOT 
3c04				DMARK "D-1" 
3c04				CALLMONITOR 
3c04			endif	 
3c04			 
3c04			.nodashswap: 
3c04			 
3c04 e5					push hl   ; save string start in case we need to advance print 
3c05			 
3c05 3a c3 f9				ld a, (f_cursor_ptr) 
3c08 cd f7 0a				call str_at_display 
3c0b 3a a1 f9				ld a,(cli_autodisplay) 
3c0e fe 00				cp 0 
3c10 28 03				jr z, .noupdate 
3c12 cd 07 0b						call update_display 
3c15					.noupdate: 
3c15			 
3c15			 
3c15					; see if we need to advance the print position 
3c15			 
3c15 e1					pop hl   ; get back string 
3c16			 
3c16 3a a2 f9				ld a, (cli_mvdot) 
3c19			if DEBUG_FORTH_DOT 
3c19					ld e,a 
3c19				DMARK "D>1" 
3c19				CALLMONITOR 
3c19			endif	 
3c19 fe 00				cp 0 
3c1b 28 0c				jr z, .noadv 
3c1d					; yes, lets advance the print position 
3c1d 3e 00				ld a, 0 
3c1f cd 81 11				call strlent 
3c22 3a c3 f9				ld a, (f_cursor_ptr) 
3c25 85					add a,l 
3c26					;call addatohl 
3c26					;ld a, l 
3c26 32 c3 f9				ld (f_cursor_ptr), a   ; save new pos 
3c29			 
3c29			if DEBUG_FORTH_DOT 
3c29				DMARK "D->" 
3c29				CALLMONITOR 
3c29			endif	 
3c29			 
3c29			.noadv:	 
3c29			 
3c29					if DEBUG_FORTH_DOT_WAIT 
3c29							call next_page_prompt 
3c29					endif	 
3c29			; TODO this pop off the stack causes a crash. i dont know why 
3c29			 
3c29			 
3c29			if DEBUG_FORTH_DOT 
3c29				DMARK "DTh" 
3c29				CALLMONITOR 
3c29			endif	 
3c29			 
3c29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c29 cd 7c 1f			call macro_forth_dsp_pop 
3c2c				endm 
# End of macro FORTH_DSP_POP
3c2c			 
3c2c			if DEBUG_FORTH_DOT 
3c2c				DMARK "DTi" 
3c2c				CALLMONITOR 
3c2c			endif	 
3c2c			 
3c2c			 
3c2c					NEXTW 
3c2c c3 36 20			jp macro_next 
3c2f				endm 
# End of macro NEXTW
3c2f			 
3c2f			.CLS: 
3c2f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c2f 35				db WORD_SYS_CORE+33             
3c30 5c 3c			dw .DRAW            
3c32 04				db 3 + 1 
3c33 .. 00			db "CLS",0              
3c37				endm 
# End of macro CWHEAD
3c37			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c37					if DEBUG_FORTH_WORDS_KEY 
3c37						DMARK "CLS" 
3c37 f5				push af  
3c38 3a 4c 3c			ld a, (.dmark)  
3c3b 32 b4 fb			ld (debug_mark),a  
3c3e 3a 4d 3c			ld a, (.dmark+1)  
3c41 32 b5 fb			ld (debug_mark+1),a  
3c44 3a 4e 3c			ld a, (.dmark+2)  
3c47 32 b6 fb			ld (debug_mark+2),a  
3c4a 18 03			jr .pastdmark  
3c4c ..			.dmark: db "CLS"  
3c4f f1			.pastdmark: pop af  
3c50			endm  
# End of macro DMARK
3c50						CALLMONITOR 
3c50 cd 3d 17			call break_point_state  
3c53				endm  
# End of macro CALLMONITOR
3c53					endif 
3c53 cd e4 0a				call clear_display 
3c56 c3 6a 3d				jp .home		; and home cursor 
3c59					NEXTW 
3c59 c3 36 20			jp macro_next 
3c5c				endm 
# End of macro NEXTW
3c5c			 
3c5c			.DRAW: 
3c5c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c5c 36				db WORD_SYS_CORE+34             
3c5d 87 3c			dw .DUMP            
3c5f 05				db 4 + 1 
3c60 .. 00			db "DRAW",0              
3c65				endm 
# End of macro CWHEAD
3c65			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c65					if DEBUG_FORTH_WORDS_KEY 
3c65						DMARK "DRW" 
3c65 f5				push af  
3c66 3a 7a 3c			ld a, (.dmark)  
3c69 32 b4 fb			ld (debug_mark),a  
3c6c 3a 7b 3c			ld a, (.dmark+1)  
3c6f 32 b5 fb			ld (debug_mark+1),a  
3c72 3a 7c 3c			ld a, (.dmark+2)  
3c75 32 b6 fb			ld (debug_mark+2),a  
3c78 18 03			jr .pastdmark  
3c7a ..			.dmark: db "DRW"  
3c7d f1			.pastdmark: pop af  
3c7e			endm  
# End of macro DMARK
3c7e						CALLMONITOR 
3c7e cd 3d 17			call break_point_state  
3c81				endm  
# End of macro CALLMONITOR
3c81					endif 
3c81 cd 07 0b				call update_display 
3c84					NEXTW 
3c84 c3 36 20			jp macro_next 
3c87				endm 
# End of macro NEXTW
3c87			 
3c87			.DUMP: 
3c87				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c87 37				db WORD_SYS_CORE+35             
3c88 bf 3c			dw .CDUMP            
3c8a 05				db 4 + 1 
3c8b .. 00			db "DUMP",0              
3c90				endm 
# End of macro CWHEAD
3c90			; | DUMP ( x -- ) With address x display dump   | DONE 
3c90			; TODO pop address to use off of the stack 
3c90					if DEBUG_FORTH_WORDS_KEY 
3c90						DMARK "DUM" 
3c90 f5				push af  
3c91 3a a5 3c			ld a, (.dmark)  
3c94 32 b4 fb			ld (debug_mark),a  
3c97 3a a6 3c			ld a, (.dmark+1)  
3c9a 32 b5 fb			ld (debug_mark+1),a  
3c9d 3a a7 3c			ld a, (.dmark+2)  
3ca0 32 b6 fb			ld (debug_mark+2),a  
3ca3 18 03			jr .pastdmark  
3ca5 ..			.dmark: db "DUM"  
3ca8 f1			.pastdmark: pop af  
3ca9			endm  
# End of macro DMARK
3ca9						CALLMONITOR 
3ca9 cd 3d 17			call break_point_state  
3cac				endm  
# End of macro CALLMONITOR
3cac					endif 
3cac cd e4 0a				call clear_display 
3caf			 
3caf					; get address 
3caf			 
3caf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3caf cd c4 1e			call macro_dsp_valuehl 
3cb2				endm 
# End of macro FORTH_DSP_VALUEHL
3cb2				 
3cb2					; save it for cdump 
3cb2			 
3cb2 22 bd f2				ld (os_cur_ptr),hl 
3cb5			 
3cb5					; destroy value TOS 
3cb5			 
3cb5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb5 cd 7c 1f			call macro_forth_dsp_pop 
3cb8				endm 
# End of macro FORTH_DSP_POP
3cb8			 
3cb8 cd 4d 1b				call dumpcont	; skip old style of param parsing	 
3cbb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3cbc					NEXTW 
3cbc c3 36 20			jp macro_next 
3cbf				endm 
# End of macro NEXTW
3cbf			.CDUMP: 
3cbf				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3cbf 38				db WORD_SYS_CORE+36             
3cc0 ef 3c			dw .DAT            
3cc2 06				db 5 + 1 
3cc3 .. 00			db "CDUMP",0              
3cc9				endm 
# End of macro CWHEAD
3cc9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3cc9					if DEBUG_FORTH_WORDS_KEY 
3cc9						DMARK "CDP" 
3cc9 f5				push af  
3cca 3a de 3c			ld a, (.dmark)  
3ccd 32 b4 fb			ld (debug_mark),a  
3cd0 3a df 3c			ld a, (.dmark+1)  
3cd3 32 b5 fb			ld (debug_mark+1),a  
3cd6 3a e0 3c			ld a, (.dmark+2)  
3cd9 32 b6 fb			ld (debug_mark+2),a  
3cdc 18 03			jr .pastdmark  
3cde ..			.dmark: db "CDP"  
3ce1 f1			.pastdmark: pop af  
3ce2			endm  
# End of macro DMARK
3ce2						CALLMONITOR 
3ce2 cd 3d 17			call break_point_state  
3ce5				endm  
# End of macro CALLMONITOR
3ce5					endif 
3ce5 cd e4 0a				call clear_display 
3ce8 cd 4d 1b				call dumpcont	 
3ceb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cec					NEXTW 
3cec c3 36 20			jp macro_next 
3cef				endm 
# End of macro NEXTW
3cef			 
3cef			 
3cef			 
3cef			 
3cef			.DAT: 
3cef				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cef 3d				db WORD_SYS_CORE+41             
3cf0 45 3d			dw .HOME            
3cf2 03				db 2 + 1 
3cf3 .. 00			db "AT",0              
3cf6				endm 
# End of macro CWHEAD
3cf6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3cf6					if DEBUG_FORTH_WORDS_KEY 
3cf6						DMARK "AT." 
3cf6 f5				push af  
3cf7 3a 0b 3d			ld a, (.dmark)  
3cfa 32 b4 fb			ld (debug_mark),a  
3cfd 3a 0c 3d			ld a, (.dmark+1)  
3d00 32 b5 fb			ld (debug_mark+1),a  
3d03 3a 0d 3d			ld a, (.dmark+2)  
3d06 32 b6 fb			ld (debug_mark+2),a  
3d09 18 03			jr .pastdmark  
3d0b ..			.dmark: db "AT."  
3d0e f1			.pastdmark: pop af  
3d0f			endm  
# End of macro DMARK
3d0f						CALLMONITOR 
3d0f cd 3d 17			call break_point_state  
3d12				endm  
# End of macro CALLMONITOR
3d12					endif 
3d12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d12 cd c4 1e			call macro_dsp_valuehl 
3d15				endm 
# End of macro FORTH_DSP_VALUEHL
3d15			 
3d15			 
3d15					; TODO save cursor row 
3d15 7d					ld a,l 
3d16 fe 02				cp 2 
3d18 20 04				jr nz, .crow3 
3d1a 3e 14				ld a, display_row_2 
3d1c 18 12				jr .ccol1 
3d1e fe 03		.crow3:		cp 3 
3d20 20 04				jr nz, .crow4 
3d22 3e 28				ld a, display_row_3 
3d24 18 0a				jr .ccol1 
3d26 fe 04		.crow4:		cp 4 
3d28 20 04				jr nz, .crow1 
3d2a 3e 3c				ld a, display_row_4 
3d2c 18 02				jr .ccol1 
3d2e 3e 00		.crow1:		ld a,display_row_1 
3d30 f5			.ccol1:		push af			; got row offset 
3d31 6f					ld l,a 
3d32 26 00				ld h,0 
3d34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d34 cd 7c 1f			call macro_forth_dsp_pop 
3d37				endm 
# End of macro FORTH_DSP_POP
3d37					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d37 cd c4 1e			call macro_dsp_valuehl 
3d3a				endm 
# End of macro FORTH_DSP_VALUEHL
3d3a					; TODO save cursor col 
3d3a f1					pop af 
3d3b 85					add l		; add col offset 
3d3c 32 c3 f9				ld (f_cursor_ptr), a 
3d3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3f cd 7c 1f			call macro_forth_dsp_pop 
3d42				endm 
# End of macro FORTH_DSP_POP
3d42			 
3d42					; calculate  
3d42			 
3d42					NEXTW 
3d42 c3 36 20			jp macro_next 
3d45				endm 
# End of macro NEXTW
3d45			 
3d45			 
3d45			.HOME: 
3d45				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d45 41				db WORD_SYS_CORE+45             
3d46 72 3d			dw .SPACE            
3d48 05				db 4 + 1 
3d49 .. 00			db "HOME",0              
3d4e				endm 
# End of macro CWHEAD
3d4e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d4e					if DEBUG_FORTH_WORDS_KEY 
3d4e						DMARK "HOM" 
3d4e f5				push af  
3d4f 3a 63 3d			ld a, (.dmark)  
3d52 32 b4 fb			ld (debug_mark),a  
3d55 3a 64 3d			ld a, (.dmark+1)  
3d58 32 b5 fb			ld (debug_mark+1),a  
3d5b 3a 65 3d			ld a, (.dmark+2)  
3d5e 32 b6 fb			ld (debug_mark+2),a  
3d61 18 03			jr .pastdmark  
3d63 ..			.dmark: db "HOM"  
3d66 f1			.pastdmark: pop af  
3d67			endm  
# End of macro DMARK
3d67						CALLMONITOR 
3d67 cd 3d 17			call break_point_state  
3d6a				endm  
# End of macro CALLMONITOR
3d6a					endif 
3d6a 3e 00		.home:		ld a, 0		; and home cursor 
3d6c 32 c3 f9				ld (f_cursor_ptr), a 
3d6f					NEXTW 
3d6f c3 36 20			jp macro_next 
3d72				endm 
# End of macro NEXTW
3d72			 
3d72			 
3d72			.SPACE: 
3d72				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d72 46				db WORD_SYS_CORE+50             
3d73 a0 3d			dw .SPACES            
3d75 03				db 2 + 1 
3d76 .. 00			db "BL",0              
3d79				endm 
# End of macro CWHEAD
3d79			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d79					if DEBUG_FORTH_WORDS_KEY 
3d79						DMARK "BL." 
3d79 f5				push af  
3d7a 3a 8e 3d			ld a, (.dmark)  
3d7d 32 b4 fb			ld (debug_mark),a  
3d80 3a 8f 3d			ld a, (.dmark+1)  
3d83 32 b5 fb			ld (debug_mark+1),a  
3d86 3a 90 3d			ld a, (.dmark+2)  
3d89 32 b6 fb			ld (debug_mark+2),a  
3d8c 18 03			jr .pastdmark  
3d8e ..			.dmark: db "BL."  
3d91 f1			.pastdmark: pop af  
3d92			endm  
# End of macro DMARK
3d92						CALLMONITOR 
3d92 cd 3d 17			call break_point_state  
3d95				endm  
# End of macro CALLMONITOR
3d95					endif 
3d95 21 9e 3d				ld hl, .blstr 
3d98 cd 3b 1d				call forth_push_str 
3d9b					 
3d9b				       NEXTW 
3d9b c3 36 20			jp macro_next 
3d9e				endm 
# End of macro NEXTW
3d9e			 
3d9e .. 00		.blstr: db " ", 0 
3da0			 
3da0			.SPACES: 
3da0				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3da0 47				db WORD_SYS_CORE+51             
3da1 3b 3e			dw .SCROLL            
3da3 07				db 6 + 1 
3da4 .. 00			db "SPACES",0              
3dab				endm 
# End of macro CWHEAD
3dab			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3dab					if DEBUG_FORTH_WORDS_KEY 
3dab						DMARK "SPS" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 b4 fb			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 b5 fb			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 b6 fb			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "SPS"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4						CALLMONITOR 
3dc4 cd 3d 17			call break_point_state  
3dc7				endm  
# End of macro CALLMONITOR
3dc7					endif 
3dc7			 
3dc7			 
3dc7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc7 cd c4 1e			call macro_dsp_valuehl 
3dca				endm 
# End of macro FORTH_DSP_VALUEHL
3dca			 
3dca			;		push hl    ; u 
3dca					if DEBUG_FORTH_WORDS 
3dca						DMARK "SPA" 
3dca f5				push af  
3dcb 3a df 3d			ld a, (.dmark)  
3dce 32 b4 fb			ld (debug_mark),a  
3dd1 3a e0 3d			ld a, (.dmark+1)  
3dd4 32 b5 fb			ld (debug_mark+1),a  
3dd7 3a e1 3d			ld a, (.dmark+2)  
3dda 32 b6 fb			ld (debug_mark+2),a  
3ddd 18 03			jr .pastdmark  
3ddf ..			.dmark: db "SPA"  
3de2 f1			.pastdmark: pop af  
3de3			endm  
# End of macro DMARK
3de3						CALLMONITOR 
3de3 cd 3d 17			call break_point_state  
3de6				endm  
# End of macro CALLMONITOR
3de6					endif 
3de6			 
3de6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de6 cd 7c 1f			call macro_forth_dsp_pop 
3de9				endm 
# End of macro FORTH_DSP_POP
3de9			;		pop hl 
3de9 4d					ld c, l 
3dea 06 00				ld b, 0 
3dec 21 9a ef				ld hl, scratch  
3def			 
3def					if DEBUG_FORTH_WORDS 
3def						DMARK "SP2" 
3def f5				push af  
3df0 3a 04 3e			ld a, (.dmark)  
3df3 32 b4 fb			ld (debug_mark),a  
3df6 3a 05 3e			ld a, (.dmark+1)  
3df9 32 b5 fb			ld (debug_mark+1),a  
3dfc 3a 06 3e			ld a, (.dmark+2)  
3dff 32 b6 fb			ld (debug_mark+2),a  
3e02 18 03			jr .pastdmark  
3e04 ..			.dmark: db "SP2"  
3e07 f1			.pastdmark: pop af  
3e08			endm  
# End of macro DMARK
3e08						CALLMONITOR 
3e08 cd 3d 17			call break_point_state  
3e0b				endm  
# End of macro CALLMONITOR
3e0b					endif 
3e0b 3e 20				ld a, ' ' 
3e0d c5			.spaces1:	push bc 
3e0e 77					ld (hl),a 
3e0f 23					inc hl 
3e10 c1					pop bc 
3e11 10 fa				djnz .spaces1 
3e13 3e 00				ld a,0 
3e15 77					ld (hl),a 
3e16 21 9a ef				ld hl, scratch 
3e19					if DEBUG_FORTH_WORDS 
3e19						DMARK "SP3" 
3e19 f5				push af  
3e1a 3a 2e 3e			ld a, (.dmark)  
3e1d 32 b4 fb			ld (debug_mark),a  
3e20 3a 2f 3e			ld a, (.dmark+1)  
3e23 32 b5 fb			ld (debug_mark+1),a  
3e26 3a 30 3e			ld a, (.dmark+2)  
3e29 32 b6 fb			ld (debug_mark+2),a  
3e2c 18 03			jr .pastdmark  
3e2e ..			.dmark: db "SP3"  
3e31 f1			.pastdmark: pop af  
3e32			endm  
# End of macro DMARK
3e32						CALLMONITOR 
3e32 cd 3d 17			call break_point_state  
3e35				endm  
# End of macro CALLMONITOR
3e35					endif 
3e35 cd 36 1e				call forth_apush 
3e38			 
3e38				       NEXTW 
3e38 c3 36 20			jp macro_next 
3e3b				endm 
# End of macro NEXTW
3e3b			 
3e3b			 
3e3b			 
3e3b			.SCROLL: 
3e3b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e3b 53				db WORD_SYS_CORE+63             
3e3c 68 3e			dw .SCROLLD            
3e3e 07				db 6 + 1 
3e3f .. 00			db "SCROLL",0              
3e46				endm 
# End of macro CWHEAD
3e46			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e46					if DEBUG_FORTH_WORDS_KEY 
3e46						DMARK "SCR" 
3e46 f5				push af  
3e47 3a 5b 3e			ld a, (.dmark)  
3e4a 32 b4 fb			ld (debug_mark),a  
3e4d 3a 5c 3e			ld a, (.dmark+1)  
3e50 32 b5 fb			ld (debug_mark+1),a  
3e53 3a 5d 3e			ld a, (.dmark+2)  
3e56 32 b6 fb			ld (debug_mark+2),a  
3e59 18 03			jr .pastdmark  
3e5b ..			.dmark: db "SCR"  
3e5e f1			.pastdmark: pop af  
3e5f			endm  
# End of macro DMARK
3e5f						CALLMONITOR 
3e5f cd 3d 17			call break_point_state  
3e62				endm  
# End of macro CALLMONITOR
3e62					endif 
3e62			 
3e62 cd a6 0a			call scroll_up 
3e65			;	call update_display 
3e65			 
3e65					NEXTW 
3e65 c3 36 20			jp macro_next 
3e68				endm 
# End of macro NEXTW
3e68			 
3e68			 
3e68			 
3e68			;		; get dir 
3e68			; 
3e68			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e68			; 
3e68			;		push hl 
3e68			; 
3e68			;		; destroy value TOS 
3e68			; 
3e68			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e68			; 
3e68			;		; get count 
3e68			; 
3e68			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e68			; 
3e68			;		push hl 
3e68			; 
3e68			;		; destroy value TOS 
3e68			; 
3e68			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e68			; 
3e68			;		; one value on hl get other one back 
3e68			; 
3e68			;		pop bc    ; count 
3e68			; 
3e68			;		pop de   ; dir 
3e68			; 
3e68			; 
3e68			;		ld b, c 
3e68			; 
3e68			;.scrolldir:     push bc 
3e68			;		push de 
3e68			; 
3e68			;		ld a, 0 
3e68			;		cp e 
3e68			;		jr z, .scrollup  
3e68			;		call scroll_down 
3e68			;		jr .scrollnext 
3e68			;.scrollup:	call scroll_up 
3e68			; 
3e68			;		 
3e68			;.scrollnext: 
3e68			;		pop de 
3e68			;		pop bc 
3e68			;		djnz .scrolldir 
3e68			; 
3e68			; 
3e68			; 
3e68			; 
3e68			; 
3e68			;		NEXTW 
3e68			 
3e68			.SCROLLD: 
3e68				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e68 53				db WORD_SYS_CORE+63             
3e69 96 3e			dw .ATQ            
3e6b 08				db 7 + 1 
3e6c .. 00			db "SCROLLD",0              
3e74				endm 
# End of macro CWHEAD
3e74			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e74					if DEBUG_FORTH_WORDS_KEY 
3e74						DMARK "SCD" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 b4 fb			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 b5 fb			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 b6 fb			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "SCD"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd 3d 17			call break_point_state  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90			 
3e90 cd ca 0a			call scroll_down 
3e93			;	call update_display 
3e93			 
3e93					NEXTW 
3e93 c3 36 20			jp macro_next 
3e96				endm 
# End of macro NEXTW
3e96			 
3e96			 
3e96			.ATQ: 
3e96				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e96 62				db WORD_SYS_CORE+78             
3e97 f4 3e			dw .AUTODSP            
3e99 04				db 3 + 1 
3e9a .. 00			db "AT@",0              
3e9e				endm 
# End of macro CWHEAD
3e9e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e9e					if DEBUG_FORTH_WORDS_KEY 
3e9e						DMARK "ATA" 
3e9e f5				push af  
3e9f 3a b3 3e			ld a, (.dmark)  
3ea2 32 b4 fb			ld (debug_mark),a  
3ea5 3a b4 3e			ld a, (.dmark+1)  
3ea8 32 b5 fb			ld (debug_mark+1),a  
3eab 3a b5 3e			ld a, (.dmark+2)  
3eae 32 b6 fb			ld (debug_mark+2),a  
3eb1 18 03			jr .pastdmark  
3eb3 ..			.dmark: db "ATA"  
3eb6 f1			.pastdmark: pop af  
3eb7			endm  
# End of macro DMARK
3eb7						CALLMONITOR 
3eb7 cd 3d 17			call break_point_state  
3eba				endm  
# End of macro CALLMONITOR
3eba					endif 
3eba			 
3eba			 
3eba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eba cd c4 1e			call macro_dsp_valuehl 
3ebd				endm 
# End of macro FORTH_DSP_VALUEHL
3ebd			 
3ebd					; TODO save cursor row 
3ebd 7d					ld a,l 
3ebe fe 02				cp 2 
3ec0 20 04				jr nz, .crow3aq 
3ec2 3e 14				ld a, display_row_2 
3ec4 18 12				jr .ccol1aq 
3ec6 fe 03		.crow3aq:		cp 3 
3ec8 20 04				jr nz, .crow4aq 
3eca 3e 28				ld a, display_row_3 
3ecc 18 0a				jr .ccol1aq 
3ece fe 04		.crow4aq:		cp 4 
3ed0 20 04				jr nz, .crow1aq 
3ed2 3e 3c				ld a, display_row_4 
3ed4 18 02				jr .ccol1aq 
3ed6 3e 00		.crow1aq:		ld a,display_row_1 
3ed8 f5			.ccol1aq:		push af			; got row offset 
3ed9 6f					ld l,a 
3eda 26 00				ld h,0 
3edc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3edc cd 7c 1f			call macro_forth_dsp_pop 
3edf				endm 
# End of macro FORTH_DSP_POP
3edf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3edf cd c4 1e			call macro_dsp_valuehl 
3ee2				endm 
# End of macro FORTH_DSP_VALUEHL
3ee2					; TODO save cursor col 
3ee2 f1					pop af 
3ee3 85					add l		; add col offset 
3ee4			 
3ee4					; add current frame buffer address 
3ee4 2a 55 fa				ld hl, (display_fb_active) 
3ee7 cd 18 0d				call addatohl 
3eea			 
3eea			 
3eea			 
3eea			 
3eea					; get char frame buffer location offset in hl 
3eea			 
3eea 7e					ld a,(hl) 
3eeb 26 00				ld h, 0 
3eed 6f					ld l, a 
3eee			 
3eee cd cd 1c				call forth_push_numhl 
3ef1			 
3ef1			 
3ef1					NEXTW 
3ef1 c3 36 20			jp macro_next 
3ef4				endm 
# End of macro NEXTW
3ef4			 
3ef4			.AUTODSP: 
3ef4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ef4 63				db WORD_SYS_CORE+79             
3ef5 0a 3f			dw .MENU            
3ef7 05				db 4 + 1 
3ef8 .. 00			db "ADSP",0              
3efd				endm 
# End of macro CWHEAD
3efd			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3efd			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3efd			 
3efd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3efd cd c4 1e			call macro_dsp_valuehl 
3f00				endm 
# End of macro FORTH_DSP_VALUEHL
3f00			 
3f00			;		push hl 
3f00			 
3f00					; destroy value TOS 
3f00			 
3f00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f00 cd 7c 1f			call macro_forth_dsp_pop 
3f03				endm 
# End of macro FORTH_DSP_POP
3f03			 
3f03			;		pop hl 
3f03			 
3f03 7d					ld a,l 
3f04 32 a1 f9				ld (cli_autodisplay), a 
3f07				       NEXTW 
3f07 c3 36 20			jp macro_next 
3f0a				endm 
# End of macro NEXTW
3f0a			 
3f0a			.MENU: 
3f0a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f0a 70				db WORD_SYS_CORE+92             
3f0b b3 3f			dw .ENDDISPLAY            
3f0d 05				db 4 + 1 
3f0e .. 00			db "MENU",0              
3f13				endm 
# End of macro CWHEAD
3f13			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f13			 
3f13			;		; get number of items on the stack 
3f13			; 
3f13				 
3f13					FORTH_DSP_VALUEHL 
3f13 cd c4 1e			call macro_dsp_valuehl 
3f16				endm 
# End of macro FORTH_DSP_VALUEHL
3f16				 
3f16					if DEBUG_FORTH_WORDS_KEY 
3f16						DMARK "MNU" 
3f16 f5				push af  
3f17 3a 2b 3f			ld a, (.dmark)  
3f1a 32 b4 fb			ld (debug_mark),a  
3f1d 3a 2c 3f			ld a, (.dmark+1)  
3f20 32 b5 fb			ld (debug_mark+1),a  
3f23 3a 2d 3f			ld a, (.dmark+2)  
3f26 32 b6 fb			ld (debug_mark+2),a  
3f29 18 03			jr .pastdmark  
3f2b ..			.dmark: db "MNU"  
3f2e f1			.pastdmark: pop af  
3f2f			endm  
# End of macro DMARK
3f2f						CALLMONITOR 
3f2f cd 3d 17			call break_point_state  
3f32				endm  
# End of macro CALLMONITOR
3f32					endif 
3f32			 
3f32 45					ld b, l	 
3f33 05					dec b 
3f34			 
3f34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f34 cd 7c 1f			call macro_forth_dsp_pop 
3f37				endm 
# End of macro FORTH_DSP_POP
3f37			 
3f37			 
3f37					; go directly through the stack to pluck out the string pointers and build an array 
3f37			 
3f37			;		FORTH_DSP 
3f37			 
3f37					; hl contains top most stack item 
3f37				 
3f37 11 9a ef				ld de, scratch 
3f3a			 
3f3a			.mbuild: 
3f3a			 
3f3a					FORTH_DSP_VALUEHL 
3f3a cd c4 1e			call macro_dsp_valuehl 
3f3d				endm 
# End of macro FORTH_DSP_VALUEHL
3f3d			 
3f3d					if DEBUG_FORTH_WORDS 
3f3d						DMARK "MN3" 
3f3d f5				push af  
3f3e 3a 52 3f			ld a, (.dmark)  
3f41 32 b4 fb			ld (debug_mark),a  
3f44 3a 53 3f			ld a, (.dmark+1)  
3f47 32 b5 fb			ld (debug_mark+1),a  
3f4a 3a 54 3f			ld a, (.dmark+2)  
3f4d 32 b6 fb			ld (debug_mark+2),a  
3f50 18 03			jr .pastdmark  
3f52 ..			.dmark: db "MN3"  
3f55 f1			.pastdmark: pop af  
3f56			endm  
# End of macro DMARK
3f56						CALLMONITOR 
3f56 cd 3d 17			call break_point_state  
3f59				endm  
# End of macro CALLMONITOR
3f59					endif 
3f59 eb					ex de, hl 
3f5a 73					ld (hl), e 
3f5b 23					inc hl 
3f5c 72					ld (hl), d 
3f5d 23					inc hl 
3f5e eb					ex de, hl 
3f5f			 
3f5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5f cd 7c 1f			call macro_forth_dsp_pop 
3f62				endm 
# End of macro FORTH_DSP_POP
3f62			 
3f62 10 d6				djnz .mbuild 
3f64			 
3f64					; done add term 
3f64			 
3f64 eb					ex de, hl 
3f65 36 00				ld (hl), 0 
3f67 23					inc hl 
3f68 36 00				ld (hl), 0 
3f6a			 
3f6a				 
3f6a					 
3f6a 21 9a ef				ld hl, scratch 
3f6d			 
3f6d					if DEBUG_FORTH_WORDS 
3f6d						DMARK "MNx" 
3f6d f5				push af  
3f6e 3a 82 3f			ld a, (.dmark)  
3f71 32 b4 fb			ld (debug_mark),a  
3f74 3a 83 3f			ld a, (.dmark+1)  
3f77 32 b5 fb			ld (debug_mark+1),a  
3f7a 3a 84 3f			ld a, (.dmark+2)  
3f7d 32 b6 fb			ld (debug_mark+2),a  
3f80 18 03			jr .pastdmark  
3f82 ..			.dmark: db "MNx"  
3f85 f1			.pastdmark: pop af  
3f86			endm  
# End of macro DMARK
3f86						CALLMONITOR 
3f86 cd 3d 17			call break_point_state  
3f89				endm  
# End of macro CALLMONITOR
3f89					endif 
3f89			 
3f89			 
3f89			 
3f89 3e 00				ld a, 0 
3f8b cd 15 0b				call menu 
3f8e			 
3f8e			 
3f8e 6f					ld l, a 
3f8f 26 00				ld h, 0 
3f91			 
3f91					if DEBUG_FORTH_WORDS 
3f91						DMARK "MNr" 
3f91 f5				push af  
3f92 3a a6 3f			ld a, (.dmark)  
3f95 32 b4 fb			ld (debug_mark),a  
3f98 3a a7 3f			ld a, (.dmark+1)  
3f9b 32 b5 fb			ld (debug_mark+1),a  
3f9e 3a a8 3f			ld a, (.dmark+2)  
3fa1 32 b6 fb			ld (debug_mark+2),a  
3fa4 18 03			jr .pastdmark  
3fa6 ..			.dmark: db "MNr"  
3fa9 f1			.pastdmark: pop af  
3faa			endm  
# End of macro DMARK
3faa						CALLMONITOR 
3faa cd 3d 17			call break_point_state  
3fad				endm  
# End of macro CALLMONITOR
3fad					endif 
3fad			 
3fad cd cd 1c				call forth_push_numhl 
3fb0			 
3fb0			 
3fb0			 
3fb0			 
3fb0				       NEXTW 
3fb0 c3 36 20			jp macro_next 
3fb3				endm 
# End of macro NEXTW
3fb3			 
3fb3			 
3fb3			.ENDDISPLAY: 
3fb3			 
3fb3			; eof 
# End of file forth_words_display.asm
3fb3			include "forth_words_str.asm" 
3fb3			 
3fb3			; | ## String Words 
3fb3			 
3fb3			.PTR:   
3fb3			 
3fb3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fb3 48				db WORD_SYS_CORE+52             
3fb4 e0 3f			dw .STYPE            
3fb6 04				db 3 + 1 
3fb7 .. 00			db "PTR",0              
3fbb				endm 
# End of macro CWHEAD
3fbb			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3fbb			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3fbb			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3fbb			 
3fbb					if DEBUG_FORTH_WORDS_KEY 
3fbb						DMARK "PTR" 
3fbb f5				push af  
3fbc 3a d0 3f			ld a, (.dmark)  
3fbf 32 b4 fb			ld (debug_mark),a  
3fc2 3a d1 3f			ld a, (.dmark+1)  
3fc5 32 b5 fb			ld (debug_mark+1),a  
3fc8 3a d2 3f			ld a, (.dmark+2)  
3fcb 32 b6 fb			ld (debug_mark+2),a  
3fce 18 03			jr .pastdmark  
3fd0 ..			.dmark: db "PTR"  
3fd3 f1			.pastdmark: pop af  
3fd4			endm  
# End of macro DMARK
3fd4						CALLMONITOR 
3fd4 cd 3d 17			call break_point_state  
3fd7				endm  
# End of macro CALLMONITOR
3fd7					endif 
3fd7					FORTH_DSP_VALUEHL 
3fd7 cd c4 1e			call macro_dsp_valuehl 
3fda				endm 
# End of macro FORTH_DSP_VALUEHL
3fda cd cd 1c				call forth_push_numhl 
3fdd			 
3fdd			 
3fdd					NEXTW 
3fdd c3 36 20			jp macro_next 
3fe0				endm 
# End of macro NEXTW
3fe0			.STYPE: 
3fe0				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fe0 48				db WORD_SYS_CORE+52             
3fe1 2f 40			dw .UPPER            
3fe3 06				db 5 + 1 
3fe4 .. 00			db "STYPE",0              
3fea				endm 
# End of macro CWHEAD
3fea			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3fea					if DEBUG_FORTH_WORDS_KEY 
3fea						DMARK "STY" 
3fea f5				push af  
3feb 3a ff 3f			ld a, (.dmark)  
3fee 32 b4 fb			ld (debug_mark),a  
3ff1 3a 00 40			ld a, (.dmark+1)  
3ff4 32 b5 fb			ld (debug_mark+1),a  
3ff7 3a 01 40			ld a, (.dmark+2)  
3ffa 32 b6 fb			ld (debug_mark+2),a  
3ffd 18 03			jr .pastdmark  
3fff ..			.dmark: db "STY"  
4002 f1			.pastdmark: pop af  
4003			endm  
# End of macro DMARK
4003						CALLMONITOR 
4003 cd 3d 17			call break_point_state  
4006				endm  
# End of macro CALLMONITOR
4006					endif 
4006					FORTH_DSP 
4006 cd 8a 1e			call macro_forth_dsp 
4009				endm 
# End of macro FORTH_DSP
4009					;v5 FORTH_DSP_VALUE 
4009			 
4009 7e					ld a, (hl) 
400a			 
400a f5					push af 
400b			 
400b			; Dont destroy TOS		FORTH_DSP_POP 
400b			 
400b f1					pop af 
400c			 
400c fe 01				cp DS_TYPE_STR 
400e 28 09				jr z, .typestr 
4010			 
4010 fe 02				cp DS_TYPE_INUM 
4012 28 0a				jr z, .typeinum 
4014			 
4014 21 2d 40				ld hl, .tna 
4017 18 0a				jr .tpush 
4019			 
4019 21 29 40		.typestr:	ld hl, .tstr 
401c 18 05				jr .tpush 
401e 21 2b 40		.typeinum:	ld hl, .tinum 
4021 18 00				jr .tpush 
4023			 
4023			.tpush: 
4023			 
4023 cd 3b 1d				call forth_push_str 
4026			 
4026					NEXTW 
4026 c3 36 20			jp macro_next 
4029				endm 
# End of macro NEXTW
4029 .. 00		.tstr:	db "s",0 
402b .. 00		.tinum:  db "i",0 
402d .. 00		.tna:   db "?", 0 
402f			 
402f			 
402f			.UPPER: 
402f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
402f 48				db WORD_SYS_CORE+52             
4030 6a 40			dw .LOWER            
4032 06				db 5 + 1 
4033 .. 00			db "UPPER",0              
4039				endm 
# End of macro CWHEAD
4039			; | UPPER ( s -- s ) Upper case string s  | DONE 
4039					if DEBUG_FORTH_WORDS_KEY 
4039						DMARK "UPR" 
4039 f5				push af  
403a 3a 4e 40			ld a, (.dmark)  
403d 32 b4 fb			ld (debug_mark),a  
4040 3a 4f 40			ld a, (.dmark+1)  
4043 32 b5 fb			ld (debug_mark+1),a  
4046 3a 50 40			ld a, (.dmark+2)  
4049 32 b6 fb			ld (debug_mark+2),a  
404c 18 03			jr .pastdmark  
404e ..			.dmark: db "UPR"  
4051 f1			.pastdmark: pop af  
4052			endm  
# End of macro DMARK
4052						CALLMONITOR 
4052 cd 3d 17			call break_point_state  
4055				endm  
# End of macro CALLMONITOR
4055					endif 
4055			 
4055					FORTH_DSP 
4055 cd 8a 1e			call macro_forth_dsp 
4058				endm 
# End of macro FORTH_DSP
4058					 
4058			; TODO check is string type 
4058			 
4058					FORTH_DSP_VALUEHL 
4058 cd c4 1e			call macro_dsp_valuehl 
405b				endm 
# End of macro FORTH_DSP_VALUEHL
405b			; get pointer to string in hl 
405b			 
405b 7e			.toup:		ld a, (hl) 
405c fe 00				cp 0 
405e 28 07				jr z, .toupdone 
4060			 
4060 cd 85 10				call to_upper 
4063			 
4063 77					ld (hl), a 
4064 23					inc hl 
4065 18 f4				jr .toup 
4067			 
4067					 
4067			 
4067			 
4067			; for each char convert to upper 
4067					 
4067			.toupdone: 
4067			 
4067			 
4067					NEXTW 
4067 c3 36 20			jp macro_next 
406a				endm 
# End of macro NEXTW
406a			.LOWER: 
406a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
406a 48				db WORD_SYS_CORE+52             
406b a5 40			dw .TCASE            
406d 06				db 5 + 1 
406e .. 00			db "LOWER",0              
4074				endm 
# End of macro CWHEAD
4074			; | LOWER ( s -- s ) Lower case string s  | DONE 
4074					if DEBUG_FORTH_WORDS_KEY 
4074						DMARK "LWR" 
4074 f5				push af  
4075 3a 89 40			ld a, (.dmark)  
4078 32 b4 fb			ld (debug_mark),a  
407b 3a 8a 40			ld a, (.dmark+1)  
407e 32 b5 fb			ld (debug_mark+1),a  
4081 3a 8b 40			ld a, (.dmark+2)  
4084 32 b6 fb			ld (debug_mark+2),a  
4087 18 03			jr .pastdmark  
4089 ..			.dmark: db "LWR"  
408c f1			.pastdmark: pop af  
408d			endm  
# End of macro DMARK
408d						CALLMONITOR 
408d cd 3d 17			call break_point_state  
4090				endm  
# End of macro CALLMONITOR
4090					endif 
4090			 
4090					FORTH_DSP 
4090 cd 8a 1e			call macro_forth_dsp 
4093				endm 
# End of macro FORTH_DSP
4093					 
4093			; TODO check is string type 
4093			 
4093					FORTH_DSP_VALUEHL 
4093 cd c4 1e			call macro_dsp_valuehl 
4096				endm 
# End of macro FORTH_DSP_VALUEHL
4096			; get pointer to string in hl 
4096			 
4096 7e			.tolow:		ld a, (hl) 
4097 fe 00				cp 0 
4099 28 07				jr z, .tolowdone 
409b			 
409b cd 8e 10				call to_lower 
409e			 
409e 77					ld (hl), a 
409f 23					inc hl 
40a0 18 f4				jr .tolow 
40a2			 
40a2					 
40a2			 
40a2			 
40a2			; for each char convert to low 
40a2					 
40a2			.tolowdone: 
40a2					NEXTW 
40a2 c3 36 20			jp macro_next 
40a5				endm 
# End of macro NEXTW
40a5			.TCASE: 
40a5				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40a5 48				db WORD_SYS_CORE+52             
40a6 db 41			dw .SUBSTR            
40a8 06				db 5 + 1 
40a9 .. 00			db "TCASE",0              
40af				endm 
# End of macro CWHEAD
40af			; | TCASE ( s -- s ) Title case string s  | DONE 
40af					if DEBUG_FORTH_WORDS_KEY 
40af						DMARK "TCS" 
40af f5				push af  
40b0 3a c4 40			ld a, (.dmark)  
40b3 32 b4 fb			ld (debug_mark),a  
40b6 3a c5 40			ld a, (.dmark+1)  
40b9 32 b5 fb			ld (debug_mark+1),a  
40bc 3a c6 40			ld a, (.dmark+2)  
40bf 32 b6 fb			ld (debug_mark+2),a  
40c2 18 03			jr .pastdmark  
40c4 ..			.dmark: db "TCS"  
40c7 f1			.pastdmark: pop af  
40c8			endm  
# End of macro DMARK
40c8						CALLMONITOR 
40c8 cd 3d 17			call break_point_state  
40cb				endm  
# End of macro CALLMONITOR
40cb					endif 
40cb			 
40cb					FORTH_DSP 
40cb cd 8a 1e			call macro_forth_dsp 
40ce				endm 
# End of macro FORTH_DSP
40ce					 
40ce			; TODO check is string type 
40ce			 
40ce					FORTH_DSP_VALUEHL 
40ce cd c4 1e			call macro_dsp_valuehl 
40d1				endm 
# End of macro FORTH_DSP_VALUEHL
40d1			; get pointer to string in hl 
40d1			 
40d1					if DEBUG_FORTH_WORDS 
40d1						DMARK "TC1" 
40d1 f5				push af  
40d2 3a e6 40			ld a, (.dmark)  
40d5 32 b4 fb			ld (debug_mark),a  
40d8 3a e7 40			ld a, (.dmark+1)  
40db 32 b5 fb			ld (debug_mark+1),a  
40de 3a e8 40			ld a, (.dmark+2)  
40e1 32 b6 fb			ld (debug_mark+2),a  
40e4 18 03			jr .pastdmark  
40e6 ..			.dmark: db "TC1"  
40e9 f1			.pastdmark: pop af  
40ea			endm  
# End of macro DMARK
40ea						CALLMONITOR 
40ea cd 3d 17			call break_point_state  
40ed				endm  
# End of macro CALLMONITOR
40ed					endif 
40ed			 
40ed					; first time in turn to upper case first char 
40ed			 
40ed 7e					ld a, (hl) 
40ee c3 78 41				jp .totsiptou 
40f1			 
40f1			 
40f1 7e			.tot:		ld a, (hl) 
40f2 fe 00				cp 0 
40f4 ca bc 41				jp z, .totdone 
40f7			 
40f7					if DEBUG_FORTH_WORDS 
40f7						DMARK "TC2" 
40f7 f5				push af  
40f8 3a 0c 41			ld a, (.dmark)  
40fb 32 b4 fb			ld (debug_mark),a  
40fe 3a 0d 41			ld a, (.dmark+1)  
4101 32 b5 fb			ld (debug_mark+1),a  
4104 3a 0e 41			ld a, (.dmark+2)  
4107 32 b6 fb			ld (debug_mark+2),a  
410a 18 03			jr .pastdmark  
410c ..			.dmark: db "TC2"  
410f f1			.pastdmark: pop af  
4110			endm  
# End of macro DMARK
4110						CALLMONITOR 
4110 cd 3d 17			call break_point_state  
4113				endm  
# End of macro CALLMONITOR
4113					endif 
4113					; check to see if current char is a space 
4113			 
4113 fe 20				cp ' ' 
4115 28 21				jr z, .totsp 
4117 cd 8e 10				call to_lower 
411a					if DEBUG_FORTH_WORDS 
411a						DMARK "TC3" 
411a f5				push af  
411b 3a 2f 41			ld a, (.dmark)  
411e 32 b4 fb			ld (debug_mark),a  
4121 3a 30 41			ld a, (.dmark+1)  
4124 32 b5 fb			ld (debug_mark+1),a  
4127 3a 31 41			ld a, (.dmark+2)  
412a 32 b6 fb			ld (debug_mark+2),a  
412d 18 03			jr .pastdmark  
412f ..			.dmark: db "TC3"  
4132 f1			.pastdmark: pop af  
4133			endm  
# End of macro DMARK
4133						CALLMONITOR 
4133 cd 3d 17			call break_point_state  
4136				endm  
# End of macro CALLMONITOR
4136					endif 
4136 18 63				jr .totnxt 
4138			 
4138			.totsp:         ; on a space, find next char which should be upper 
4138			 
4138					if DEBUG_FORTH_WORDS 
4138						DMARK "TC4" 
4138 f5				push af  
4139 3a 4d 41			ld a, (.dmark)  
413c 32 b4 fb			ld (debug_mark),a  
413f 3a 4e 41			ld a, (.dmark+1)  
4142 32 b5 fb			ld (debug_mark+1),a  
4145 3a 4f 41			ld a, (.dmark+2)  
4148 32 b6 fb			ld (debug_mark+2),a  
414b 18 03			jr .pastdmark  
414d ..			.dmark: db "TC4"  
4150 f1			.pastdmark: pop af  
4151			endm  
# End of macro DMARK
4151						CALLMONITOR 
4151 cd 3d 17			call break_point_state  
4154				endm  
# End of macro CALLMONITOR
4154					endif 
4154					;; 
4154			 
4154 fe 20				cp ' ' 
4156 20 20				jr nz, .totsiptou 
4158 23					inc hl 
4159 7e					ld a, (hl) 
415a					if DEBUG_FORTH_WORDS 
415a						DMARK "TC5" 
415a f5				push af  
415b 3a 6f 41			ld a, (.dmark)  
415e 32 b4 fb			ld (debug_mark),a  
4161 3a 70 41			ld a, (.dmark+1)  
4164 32 b5 fb			ld (debug_mark+1),a  
4167 3a 71 41			ld a, (.dmark+2)  
416a 32 b6 fb			ld (debug_mark+2),a  
416d 18 03			jr .pastdmark  
416f ..			.dmark: db "TC5"  
4172 f1			.pastdmark: pop af  
4173			endm  
# End of macro DMARK
4173						CALLMONITOR 
4173 cd 3d 17			call break_point_state  
4176				endm  
# End of macro CALLMONITOR
4176					endif 
4176 18 c0				jr .totsp 
4178 fe 00		.totsiptou:    cp 0 
417a 28 40				jr z, .totdone 
417c					; not space and not zero term so upper case it 
417c cd 85 10				call to_upper 
417f			 
417f					if DEBUG_FORTH_WORDS 
417f						DMARK "TC6" 
417f f5				push af  
4180 3a 94 41			ld a, (.dmark)  
4183 32 b4 fb			ld (debug_mark),a  
4186 3a 95 41			ld a, (.dmark+1)  
4189 32 b5 fb			ld (debug_mark+1),a  
418c 3a 96 41			ld a, (.dmark+2)  
418f 32 b6 fb			ld (debug_mark+2),a  
4192 18 03			jr .pastdmark  
4194 ..			.dmark: db "TC6"  
4197 f1			.pastdmark: pop af  
4198			endm  
# End of macro DMARK
4198						CALLMONITOR 
4198 cd 3d 17			call break_point_state  
419b				endm  
# End of macro CALLMONITOR
419b					endif 
419b			 
419b			 
419b			.totnxt: 
419b			 
419b 77					ld (hl), a 
419c 23					inc hl 
419d					if DEBUG_FORTH_WORDS 
419d						DMARK "TC7" 
419d f5				push af  
419e 3a b2 41			ld a, (.dmark)  
41a1 32 b4 fb			ld (debug_mark),a  
41a4 3a b3 41			ld a, (.dmark+1)  
41a7 32 b5 fb			ld (debug_mark+1),a  
41aa 3a b4 41			ld a, (.dmark+2)  
41ad 32 b6 fb			ld (debug_mark+2),a  
41b0 18 03			jr .pastdmark  
41b2 ..			.dmark: db "TC7"  
41b5 f1			.pastdmark: pop af  
41b6			endm  
# End of macro DMARK
41b6						CALLMONITOR 
41b6 cd 3d 17			call break_point_state  
41b9				endm  
# End of macro CALLMONITOR
41b9					endif 
41b9 c3 f1 40				jp .tot 
41bc			 
41bc					 
41bc			 
41bc			 
41bc			; for each char convert to low 
41bc					 
41bc			.totdone: 
41bc					if DEBUG_FORTH_WORDS 
41bc						DMARK "TCd" 
41bc f5				push af  
41bd 3a d1 41			ld a, (.dmark)  
41c0 32 b4 fb			ld (debug_mark),a  
41c3 3a d2 41			ld a, (.dmark+1)  
41c6 32 b5 fb			ld (debug_mark+1),a  
41c9 3a d3 41			ld a, (.dmark+2)  
41cc 32 b6 fb			ld (debug_mark+2),a  
41cf 18 03			jr .pastdmark  
41d1 ..			.dmark: db "TCd"  
41d4 f1			.pastdmark: pop af  
41d5			endm  
# End of macro DMARK
41d5						CALLMONITOR 
41d5 cd 3d 17			call break_point_state  
41d8				endm  
# End of macro CALLMONITOR
41d8					endif 
41d8					NEXTW 
41d8 c3 36 20			jp macro_next 
41db				endm 
# End of macro NEXTW
41db			 
41db			.SUBSTR: 
41db				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41db 48				db WORD_SYS_CORE+52             
41dc 39 42			dw .LEFT            
41de 07				db 6 + 1 
41df .. 00			db "SUBSTR",0              
41e6				endm 
# End of macro CWHEAD
41e6			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41e6			 
41e6					if DEBUG_FORTH_WORDS_KEY 
41e6						DMARK "SST" 
41e6 f5				push af  
41e7 3a fb 41			ld a, (.dmark)  
41ea 32 b4 fb			ld (debug_mark),a  
41ed 3a fc 41			ld a, (.dmark+1)  
41f0 32 b5 fb			ld (debug_mark+1),a  
41f3 3a fd 41			ld a, (.dmark+2)  
41f6 32 b6 fb			ld (debug_mark+2),a  
41f9 18 03			jr .pastdmark  
41fb ..			.dmark: db "SST"  
41fe f1			.pastdmark: pop af  
41ff			endm  
# End of macro DMARK
41ff						CALLMONITOR 
41ff cd 3d 17			call break_point_state  
4202				endm  
# End of macro CALLMONITOR
4202					endif 
4202			; TODO check string type 
4202					FORTH_DSP_VALUEHL 
4202 cd c4 1e			call macro_dsp_valuehl 
4205				endm 
# End of macro FORTH_DSP_VALUEHL
4205			 
4205 e5					push hl      ; string length 
4206			 
4206					FORTH_DSP_POP 
4206 cd 7c 1f			call macro_forth_dsp_pop 
4209				endm 
# End of macro FORTH_DSP_POP
4209			 
4209					FORTH_DSP_VALUEHL 
4209 cd c4 1e			call macro_dsp_valuehl 
420c				endm 
# End of macro FORTH_DSP_VALUEHL
420c			 
420c e5					push hl     ; start char 
420d			 
420d					FORTH_DSP_POP 
420d cd 7c 1f			call macro_forth_dsp_pop 
4210				endm 
# End of macro FORTH_DSP_POP
4210			 
4210			 
4210					FORTH_DSP_VALUE 
4210 cd ad 1e			call macro_forth_dsp_value 
4213				endm 
# End of macro FORTH_DSP_VALUE
4213			 
4213 d1					pop de    ; get start post offset 
4214			 
4214 19					add hl, de    ; starting offset 
4215			 
4215 c1					pop bc 
4216 c5					push bc      ; grab size of string 
4217			 
4217 e5					push hl    ; save string start  
4218			 
4218 26 00				ld h, 0 
421a 69					ld l, c 
421b 23					inc hl 
421c 23					inc hl 
421d			 
421d cd df 11				call malloc 
4220				if DEBUG_FORTH_MALLOC_GUARD 
4220 cc cf 51				call z,malloc_error 
4223				endif 
4223			 
4223 eb					ex de, hl      ; save malloc area for string copy 
4224 e1					pop hl    ; get back source 
4225 c1					pop bc    ; get length of string back 
4226			 
4226 d5					push de    ; save malloc area for after we push 
4227 ed b0				ldir     ; copy substr 
4229			 
4229			 
4229 eb					ex de, hl 
422a 3e 00				ld a, 0 
422c 77					ld (hl), a   ; term substr 
422d			 
422d					 
422d e1					pop hl    ; get malloc so we can push it 
422e e5					push hl   ; save so we can free it afterwards 
422f			 
422f cd 3b 1d				call forth_push_str 
4232			 
4232 e1					pop hl 
4233 cd a9 12				call free 
4236			 
4236					 
4236					 
4236			 
4236			 
4236					NEXTW 
4236 c3 36 20			jp macro_next 
4239				endm 
# End of macro NEXTW
4239			 
4239			.LEFT: 
4239				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4239 48				db WORD_SYS_CORE+52             
423a 61 42			dw .RIGHT            
423c 05				db 4 + 1 
423d .. 00			db "LEFT",0              
4242				endm 
# End of macro CWHEAD
4242			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4242					if DEBUG_FORTH_WORDS_KEY 
4242						DMARK "LEF" 
4242 f5				push af  
4243 3a 57 42			ld a, (.dmark)  
4246 32 b4 fb			ld (debug_mark),a  
4249 3a 58 42			ld a, (.dmark+1)  
424c 32 b5 fb			ld (debug_mark+1),a  
424f 3a 59 42			ld a, (.dmark+2)  
4252 32 b6 fb			ld (debug_mark+2),a  
4255 18 03			jr .pastdmark  
4257 ..			.dmark: db "LEF"  
425a f1			.pastdmark: pop af  
425b			endm  
# End of macro DMARK
425b						CALLMONITOR 
425b cd 3d 17			call break_point_state  
425e				endm  
# End of macro CALLMONITOR
425e					endif 
425e			 
425e					NEXTW 
425e c3 36 20			jp macro_next 
4261				endm 
# End of macro NEXTW
4261			.RIGHT: 
4261				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4261 48				db WORD_SYS_CORE+52             
4262 8a 42			dw .STR2NUM            
4264 06				db 5 + 1 
4265 .. 00			db "RIGHT",0              
426b				endm 
# End of macro CWHEAD
426b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
426b					if DEBUG_FORTH_WORDS_KEY 
426b						DMARK "RIG" 
426b f5				push af  
426c 3a 80 42			ld a, (.dmark)  
426f 32 b4 fb			ld (debug_mark),a  
4272 3a 81 42			ld a, (.dmark+1)  
4275 32 b5 fb			ld (debug_mark+1),a  
4278 3a 82 42			ld a, (.dmark+2)  
427b 32 b6 fb			ld (debug_mark+2),a  
427e 18 03			jr .pastdmark  
4280 ..			.dmark: db "RIG"  
4283 f1			.pastdmark: pop af  
4284			endm  
# End of macro DMARK
4284						CALLMONITOR 
4284 cd 3d 17			call break_point_state  
4287				endm  
# End of macro CALLMONITOR
4287					endif 
4287			 
4287					NEXTW 
4287 c3 36 20			jp macro_next 
428a				endm 
# End of macro NEXTW
428a			 
428a			 
428a			.STR2NUM: 
428a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
428a 48				db WORD_SYS_CORE+52             
428b 16 43			dw .NUM2STR            
428d 08				db 7 + 1 
428e .. 00			db "STR2NUM",0              
4296				endm 
# End of macro CWHEAD
4296			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4296			 
4296			 
4296			; TODO STR type check to do 
4296					if DEBUG_FORTH_WORDS_KEY 
4296						DMARK "S2N" 
4296 f5				push af  
4297 3a ab 42			ld a, (.dmark)  
429a 32 b4 fb			ld (debug_mark),a  
429d 3a ac 42			ld a, (.dmark+1)  
42a0 32 b5 fb			ld (debug_mark+1),a  
42a3 3a ad 42			ld a, (.dmark+2)  
42a6 32 b6 fb			ld (debug_mark+2),a  
42a9 18 03			jr .pastdmark  
42ab ..			.dmark: db "S2N"  
42ae f1			.pastdmark: pop af  
42af			endm  
# End of macro DMARK
42af						CALLMONITOR 
42af cd 3d 17			call break_point_state  
42b2				endm  
# End of macro CALLMONITOR
42b2					endif 
42b2			 
42b2					;FORTH_DSP 
42b2					FORTH_DSP_VALUE 
42b2 cd ad 1e			call macro_forth_dsp_value 
42b5				endm 
# End of macro FORTH_DSP_VALUE
42b5					;inc hl 
42b5			 
42b5 eb					ex de, hl 
42b6					if DEBUG_FORTH_WORDS 
42b6						DMARK "S2a" 
42b6 f5				push af  
42b7 3a cb 42			ld a, (.dmark)  
42ba 32 b4 fb			ld (debug_mark),a  
42bd 3a cc 42			ld a, (.dmark+1)  
42c0 32 b5 fb			ld (debug_mark+1),a  
42c3 3a cd 42			ld a, (.dmark+2)  
42c6 32 b6 fb			ld (debug_mark+2),a  
42c9 18 03			jr .pastdmark  
42cb ..			.dmark: db "S2a"  
42ce f1			.pastdmark: pop af  
42cf			endm  
# End of macro DMARK
42cf						CALLMONITOR 
42cf cd 3d 17			call break_point_state  
42d2				endm  
# End of macro CALLMONITOR
42d2					endif 
42d2 cd 0d 11				call string_to_uint16 
42d5			 
42d5					if DEBUG_FORTH_WORDS 
42d5						DMARK "S2b" 
42d5 f5				push af  
42d6 3a ea 42			ld a, (.dmark)  
42d9 32 b4 fb			ld (debug_mark),a  
42dc 3a eb 42			ld a, (.dmark+1)  
42df 32 b5 fb			ld (debug_mark+1),a  
42e2 3a ec 42			ld a, (.dmark+2)  
42e5 32 b6 fb			ld (debug_mark+2),a  
42e8 18 03			jr .pastdmark  
42ea ..			.dmark: db "S2b"  
42ed f1			.pastdmark: pop af  
42ee			endm  
# End of macro DMARK
42ee						CALLMONITOR 
42ee cd 3d 17			call break_point_state  
42f1				endm  
# End of macro CALLMONITOR
42f1					endif 
42f1			;		push hl 
42f1					FORTH_DSP_POP 
42f1 cd 7c 1f			call macro_forth_dsp_pop 
42f4				endm 
# End of macro FORTH_DSP_POP
42f4			;		pop hl 
42f4					 
42f4					if DEBUG_FORTH_WORDS 
42f4						DMARK "S2b" 
42f4 f5				push af  
42f5 3a 09 43			ld a, (.dmark)  
42f8 32 b4 fb			ld (debug_mark),a  
42fb 3a 0a 43			ld a, (.dmark+1)  
42fe 32 b5 fb			ld (debug_mark+1),a  
4301 3a 0b 43			ld a, (.dmark+2)  
4304 32 b6 fb			ld (debug_mark+2),a  
4307 18 03			jr .pastdmark  
4309 ..			.dmark: db "S2b"  
430c f1			.pastdmark: pop af  
430d			endm  
# End of macro DMARK
430d						CALLMONITOR 
430d cd 3d 17			call break_point_state  
4310				endm  
# End of macro CALLMONITOR
4310					endif 
4310 cd cd 1c				call forth_push_numhl	 
4313			 
4313				 
4313				       NEXTW 
4313 c3 36 20			jp macro_next 
4316				endm 
# End of macro NEXTW
4316			.NUM2STR: 
4316				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4316 48				db WORD_SYS_CORE+52             
4317 25 43			dw .CONCAT            
4319 08				db 7 + 1 
431a .. 00			db "NUM2STR",0              
4322				endm 
# End of macro CWHEAD
4322			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4322			 
4322			;		; malloc a string to target 
4322			;		ld hl, 10     ; TODO max string size should be fine 
4322			;		call malloc 
4322			;		push hl    ; save malloc location 
4322			; 
4322			; 
4322			;; TODO check int type 
4322			;		FORTH_DSP_VALUEHL 
4322			;		ld a, l 
4322			;		call DispAToASCII   
4322			;;TODO need to chage above call to dump into string 
4322			; 
4322			; 
4322			 
4322				       NEXTW 
4322 c3 36 20			jp macro_next 
4325				endm 
# End of macro NEXTW
4325			 
4325			.CONCAT: 
4325				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4325 48				db WORD_SYS_CORE+52             
4326 d8 43			dw .FIND            
4328 07				db 6 + 1 
4329 .. 00			db "CONCAT",0              
4330				endm 
# End of macro CWHEAD
4330			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4330			 
4330			; TODO check string type 
4330			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4330			 
4330					if DEBUG_FORTH_WORDS_KEY 
4330						DMARK "CON" 
4330 f5				push af  
4331 3a 45 43			ld a, (.dmark)  
4334 32 b4 fb			ld (debug_mark),a  
4337 3a 46 43			ld a, (.dmark+1)  
433a 32 b5 fb			ld (debug_mark+1),a  
433d 3a 47 43			ld a, (.dmark+2)  
4340 32 b6 fb			ld (debug_mark+2),a  
4343 18 03			jr .pastdmark  
4345 ..			.dmark: db "CON"  
4348 f1			.pastdmark: pop af  
4349			endm  
# End of macro DMARK
4349						CALLMONITOR 
4349 cd 3d 17			call break_point_state  
434c				endm  
# End of macro CALLMONITOR
434c					endif 
434c			 
434c			 
434c					FORTH_DSP_VALUE 
434c cd ad 1e			call macro_forth_dsp_value 
434f				endm 
# End of macro FORTH_DSP_VALUE
434f e5					push hl   ; s2 
4350			 
4350					FORTH_DSP_POP 
4350 cd 7c 1f			call macro_forth_dsp_pop 
4353				endm 
# End of macro FORTH_DSP_POP
4353			 
4353					FORTH_DSP_VALUE 
4353 cd ad 1e			call macro_forth_dsp_value 
4356				endm 
# End of macro FORTH_DSP_VALUE
4356			 
4356 e5					push hl   ; s1 
4357			 
4357					FORTH_DSP_POP 
4357 cd 7c 1f			call macro_forth_dsp_pop 
435a				endm 
# End of macro FORTH_DSP_POP
435a					 
435a			 
435a					; copy s1 
435a			 
435a				 
435a					; save ptr 
435a e1					pop hl  
435b e5					push hl 
435c 3e 00				ld a, 0 
435e cd 81 11				call strlent 
4361					;inc hl    ; zer0 
4361 06 00				ld b, 0 
4363 4d					ld c, l 
4364 e1					pop hl		 
4365 11 9a ef				ld de, scratch	 
4368					if DEBUG_FORTH_WORDS 
4368						DMARK "CO1" 
4368 f5				push af  
4369 3a 7d 43			ld a, (.dmark)  
436c 32 b4 fb			ld (debug_mark),a  
436f 3a 7e 43			ld a, (.dmark+1)  
4372 32 b5 fb			ld (debug_mark+1),a  
4375 3a 7f 43			ld a, (.dmark+2)  
4378 32 b6 fb			ld (debug_mark+2),a  
437b 18 03			jr .pastdmark  
437d ..			.dmark: db "CO1"  
4380 f1			.pastdmark: pop af  
4381			endm  
# End of macro DMARK
4381						CALLMONITOR 
4381 cd 3d 17			call break_point_state  
4384				endm  
# End of macro CALLMONITOR
4384					endif 
4384 ed b0				ldir 
4386			 
4386 e1					pop hl 
4387 e5					push hl 
4388 d5					push de 
4389			 
4389			 
4389 3e 00				ld a, 0 
438b cd 81 11				call strlent 
438e 23					inc hl    ; zer0 
438f 23					inc hl 
4390 06 00				ld b, 0 
4392 4d					ld c, l 
4393 d1					pop de 
4394 e1					pop hl		 
4395					if DEBUG_FORTH_WORDS 
4395						DMARK "CO2" 
4395 f5				push af  
4396 3a aa 43			ld a, (.dmark)  
4399 32 b4 fb			ld (debug_mark),a  
439c 3a ab 43			ld a, (.dmark+1)  
439f 32 b5 fb			ld (debug_mark+1),a  
43a2 3a ac 43			ld a, (.dmark+2)  
43a5 32 b6 fb			ld (debug_mark+2),a  
43a8 18 03			jr .pastdmark  
43aa ..			.dmark: db "CO2"  
43ad f1			.pastdmark: pop af  
43ae			endm  
# End of macro DMARK
43ae						CALLMONITOR 
43ae cd 3d 17			call break_point_state  
43b1				endm  
# End of macro CALLMONITOR
43b1					endif 
43b1 ed b0				ldir 
43b3			 
43b3			 
43b3			 
43b3 21 9a ef				ld hl, scratch 
43b6					if DEBUG_FORTH_WORDS 
43b6						DMARK "CO5" 
43b6 f5				push af  
43b7 3a cb 43			ld a, (.dmark)  
43ba 32 b4 fb			ld (debug_mark),a  
43bd 3a cc 43			ld a, (.dmark+1)  
43c0 32 b5 fb			ld (debug_mark+1),a  
43c3 3a cd 43			ld a, (.dmark+2)  
43c6 32 b6 fb			ld (debug_mark+2),a  
43c9 18 03			jr .pastdmark  
43cb ..			.dmark: db "CO5"  
43ce f1			.pastdmark: pop af  
43cf			endm  
# End of macro DMARK
43cf						CALLMONITOR 
43cf cd 3d 17			call break_point_state  
43d2				endm  
# End of macro CALLMONITOR
43d2					endif 
43d2			 
43d2 cd 3b 1d				call forth_push_str 
43d5			 
43d5			 
43d5			 
43d5			 
43d5				       NEXTW 
43d5 c3 36 20			jp macro_next 
43d8				endm 
# End of macro NEXTW
43d8			 
43d8			 
43d8			.FIND: 
43d8				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43d8 4b				db WORD_SYS_CORE+55             
43d9 96 44			dw .LEN            
43db 05				db 4 + 1 
43dc .. 00			db "FIND",0              
43e1				endm 
# End of macro CWHEAD
43e1			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43e1			 
43e1					if DEBUG_FORTH_WORDS_KEY 
43e1						DMARK "FND" 
43e1 f5				push af  
43e2 3a f6 43			ld a, (.dmark)  
43e5 32 b4 fb			ld (debug_mark),a  
43e8 3a f7 43			ld a, (.dmark+1)  
43eb 32 b5 fb			ld (debug_mark+1),a  
43ee 3a f8 43			ld a, (.dmark+2)  
43f1 32 b6 fb			ld (debug_mark+2),a  
43f4 18 03			jr .pastdmark  
43f6 ..			.dmark: db "FND"  
43f9 f1			.pastdmark: pop af  
43fa			endm  
# End of macro DMARK
43fa						CALLMONITOR 
43fa cd 3d 17			call break_point_state  
43fd				endm  
# End of macro CALLMONITOR
43fd					endif 
43fd			 
43fd			; TODO check string type 
43fd					FORTH_DSP_VALUE 
43fd cd ad 1e			call macro_forth_dsp_value 
4400				endm 
# End of macro FORTH_DSP_VALUE
4400			 
4400 e5					push hl    
4401 7e					ld a,(hl)    ; char to find   
4402			; TODO change char to substr 
4402			 
4402 f5					push af 
4403					 
4403			 
4403			 
4403					if DEBUG_FORTH_WORDS 
4403						DMARK "FN1" 
4403 f5				push af  
4404 3a 18 44			ld a, (.dmark)  
4407 32 b4 fb			ld (debug_mark),a  
440a 3a 19 44			ld a, (.dmark+1)  
440d 32 b5 fb			ld (debug_mark+1),a  
4410 3a 1a 44			ld a, (.dmark+2)  
4413 32 b6 fb			ld (debug_mark+2),a  
4416 18 03			jr .pastdmark  
4418 ..			.dmark: db "FN1"  
441b f1			.pastdmark: pop af  
441c			endm  
# End of macro DMARK
441c						CALLMONITOR 
441c cd 3d 17			call break_point_state  
441f				endm  
# End of macro CALLMONITOR
441f					endif 
441f			 
441f					FORTH_DSP_POP 
441f cd 7c 1f			call macro_forth_dsp_pop 
4422				endm 
# End of macro FORTH_DSP_POP
4422			 
4422					; string to search 
4422			 
4422					FORTH_DSP_VALUE 
4422 cd ad 1e			call macro_forth_dsp_value 
4425				endm 
# End of macro FORTH_DSP_VALUE
4425			 
4425 d1					pop de  ; d is char to find  
4426			 
4426					if DEBUG_FORTH_WORDS 
4426						DMARK "FN2" 
4426 f5				push af  
4427 3a 3b 44			ld a, (.dmark)  
442a 32 b4 fb			ld (debug_mark),a  
442d 3a 3c 44			ld a, (.dmark+1)  
4430 32 b5 fb			ld (debug_mark+1),a  
4433 3a 3d 44			ld a, (.dmark+2)  
4436 32 b6 fb			ld (debug_mark+2),a  
4439 18 03			jr .pastdmark  
443b ..			.dmark: db "FN2"  
443e f1			.pastdmark: pop af  
443f			endm  
# End of macro DMARK
443f						CALLMONITOR 
443f cd 3d 17			call break_point_state  
4442				endm  
# End of macro CALLMONITOR
4442					endif 
4442					 
4442 01 00 00				ld bc, 0 
4445 7e			.findchar:      ld a,(hl) 
4446 fe 00				cp 0   		 
4448 28 27				jr z, .finddone     
444a ba					cp d 
444b 28 20				jr z, .foundchar 
444d 03					inc bc 
444e 23					inc hl 
444f					if DEBUG_FORTH_WORDS 
444f						DMARK "FN3" 
444f f5				push af  
4450 3a 64 44			ld a, (.dmark)  
4453 32 b4 fb			ld (debug_mark),a  
4456 3a 65 44			ld a, (.dmark+1)  
4459 32 b5 fb			ld (debug_mark+1),a  
445c 3a 66 44			ld a, (.dmark+2)  
445f 32 b6 fb			ld (debug_mark+2),a  
4462 18 03			jr .pastdmark  
4464 ..			.dmark: db "FN3"  
4467 f1			.pastdmark: pop af  
4468			endm  
# End of macro DMARK
4468						CALLMONITOR 
4468 cd 3d 17			call break_point_state  
446b				endm  
# End of macro CALLMONITOR
446b					endif 
446b 18 d8				jr .findchar 
446d			 
446d			 
446d c5			.foundchar:	push bc 
446e e1					pop hl 
446f 18 03				jr .findexit 
4471			 
4471			 
4471							 
4471			 
4471			.finddone:     ; got to end of string with no find 
4471 21 00 00				ld hl, 0 
4474			.findexit: 
4474			 
4474					if DEBUG_FORTH_WORDS 
4474						DMARK "FNd" 
4474 f5				push af  
4475 3a 89 44			ld a, (.dmark)  
4478 32 b4 fb			ld (debug_mark),a  
447b 3a 8a 44			ld a, (.dmark+1)  
447e 32 b5 fb			ld (debug_mark+1),a  
4481 3a 8b 44			ld a, (.dmark+2)  
4484 32 b6 fb			ld (debug_mark+2),a  
4487 18 03			jr .pastdmark  
4489 ..			.dmark: db "FNd"  
448c f1			.pastdmark: pop af  
448d			endm  
# End of macro DMARK
448d						CALLMONITOR 
448d cd 3d 17			call break_point_state  
4490				endm  
# End of macro CALLMONITOR
4490					endif 
4490 cd cd 1c			call forth_push_numhl 
4493			 
4493				       NEXTW 
4493 c3 36 20			jp macro_next 
4496				endm 
# End of macro NEXTW
4496			 
4496			.LEN: 
4496				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4496 4c				db WORD_SYS_CORE+56             
4497 cb 44			dw .CHAR            
4499 06				db 5 + 1 
449a .. 00			db "COUNT",0              
44a0				endm 
# End of macro CWHEAD
44a0			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44a0			 
44a0					if DEBUG_FORTH_WORDS_KEY 
44a0						DMARK "CNT" 
44a0 f5				push af  
44a1 3a b5 44			ld a, (.dmark)  
44a4 32 b4 fb			ld (debug_mark),a  
44a7 3a b6 44			ld a, (.dmark+1)  
44aa 32 b5 fb			ld (debug_mark+1),a  
44ad 3a b7 44			ld a, (.dmark+2)  
44b0 32 b6 fb			ld (debug_mark+2),a  
44b3 18 03			jr .pastdmark  
44b5 ..			.dmark: db "CNT"  
44b8 f1			.pastdmark: pop af  
44b9			endm  
# End of macro DMARK
44b9						CALLMONITOR 
44b9 cd 3d 17			call break_point_state  
44bc				endm  
# End of macro CALLMONITOR
44bc					endif 
44bc			; TODO check string type 
44bc					FORTH_DSP 
44bc cd 8a 1e			call macro_forth_dsp 
44bf				endm 
# End of macro FORTH_DSP
44bf					;v5FORTH_DSP_VALUE 
44bf			 
44bf 23					inc hl 
44c0			 
44c0 3e 00				ld a, 0 
44c2 cd 81 11				call strlent 
44c5			 
44c5 cd cd 1c				call forth_push_numhl 
44c8			 
44c8			 
44c8			 
44c8				       NEXTW 
44c8 c3 36 20			jp macro_next 
44cb				endm 
# End of macro NEXTW
44cb			.CHAR: 
44cb				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
44cb 4d				db WORD_SYS_CORE+57             
44cc 01 45			dw .ENDSTR            
44ce 05				db 4 + 1 
44cf .. 00			db "CHAR",0              
44d4				endm 
# End of macro CWHEAD
44d4			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
44d4					if DEBUG_FORTH_WORDS_KEY 
44d4						DMARK "CHR" 
44d4 f5				push af  
44d5 3a e9 44			ld a, (.dmark)  
44d8 32 b4 fb			ld (debug_mark),a  
44db 3a ea 44			ld a, (.dmark+1)  
44de 32 b5 fb			ld (debug_mark+1),a  
44e1 3a eb 44			ld a, (.dmark+2)  
44e4 32 b6 fb			ld (debug_mark+2),a  
44e7 18 03			jr .pastdmark  
44e9 ..			.dmark: db "CHR"  
44ec f1			.pastdmark: pop af  
44ed			endm  
# End of macro DMARK
44ed						CALLMONITOR 
44ed cd 3d 17			call break_point_state  
44f0				endm  
# End of macro CALLMONITOR
44f0					endif 
44f0					FORTH_DSP 
44f0 cd 8a 1e			call macro_forth_dsp 
44f3				endm 
# End of macro FORTH_DSP
44f3					;v5 FORTH_DSP_VALUE 
44f3 23					inc hl      ; now at start of numeric as string 
44f4			 
44f4			;		push hl 
44f4			 
44f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44f4 cd 7c 1f			call macro_forth_dsp_pop 
44f7				endm 
# End of macro FORTH_DSP_POP
44f7			 
44f7			;		pop hl 
44f7			 
44f7					; push the content of a onto the stack as a value 
44f7			 
44f7 7e					ld a,(hl)   ; get char 
44f8 26 00				ld h,0 
44fa 6f					ld l,a 
44fb cd cd 1c				call forth_push_numhl 
44fe			 
44fe				       NEXTW 
44fe c3 36 20			jp macro_next 
4501				endm 
# End of macro NEXTW
4501			 
4501			 
4501			 
4501			 
4501			.ENDSTR: 
4501			; eof 
4501			 
# End of file forth_words_str.asm
4501			include "forth_words_key.asm" 
4501			 
4501			; | ## Keyboard Words 
4501			 
4501			.KEY: 
4501				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4501 3e				db WORD_SYS_CORE+42             
4502 31 45			dw .WAITK            
4504 04				db 3 + 1 
4505 .. 00			db "KEY",0              
4509				endm 
# End of macro CWHEAD
4509			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4509			 
4509					if DEBUG_FORTH_WORDS_KEY 
4509						DMARK "KEY" 
4509 f5				push af  
450a 3a 1e 45			ld a, (.dmark)  
450d 32 b4 fb			ld (debug_mark),a  
4510 3a 1f 45			ld a, (.dmark+1)  
4513 32 b5 fb			ld (debug_mark+1),a  
4516 3a 20 45			ld a, (.dmark+2)  
4519 32 b6 fb			ld (debug_mark+2),a  
451c 18 03			jr .pastdmark  
451e ..			.dmark: db "KEY"  
4521 f1			.pastdmark: pop af  
4522			endm  
# End of macro DMARK
4522						CALLMONITOR 
4522 cd 3d 17			call break_point_state  
4525				endm  
# End of macro CALLMONITOR
4525					endif 
4525			; TODO currently waits 
4525 cd 5f 67				call cin 
4528					;call cin_wait 
4528 6f					ld l, a 
4529 26 00				ld h, 0 
452b cd cd 1c				call forth_push_numhl 
452e					NEXTW 
452e c3 36 20			jp macro_next 
4531				endm 
# End of macro NEXTW
4531			.WAITK: 
4531				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4531 3f				db WORD_SYS_CORE+43             
4532 63 45			dw .ACCEPT            
4534 06				db 5 + 1 
4535 .. 00			db "WAITK",0              
453b				endm 
# End of macro CWHEAD
453b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
453b					if DEBUG_FORTH_WORDS_KEY 
453b						DMARK "WAI" 
453b f5				push af  
453c 3a 50 45			ld a, (.dmark)  
453f 32 b4 fb			ld (debug_mark),a  
4542 3a 51 45			ld a, (.dmark+1)  
4545 32 b5 fb			ld (debug_mark+1),a  
4548 3a 52 45			ld a, (.dmark+2)  
454b 32 b6 fb			ld (debug_mark+2),a  
454e 18 03			jr .pastdmark  
4550 ..			.dmark: db "WAI"  
4553 f1			.pastdmark: pop af  
4554			endm  
# End of macro DMARK
4554						CALLMONITOR 
4554 cd 3d 17			call break_point_state  
4557				endm  
# End of macro CALLMONITOR
4557					endif 
4557 cd 4e 67				call cin_wait 
455a 6f					ld l, a 
455b 26 00				ld h, 0 
455d cd cd 1c				call forth_push_numhl 
4560					NEXTW 
4560 c3 36 20			jp macro_next 
4563				endm 
# End of macro NEXTW
4563			.ACCEPT: 
4563				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4563 40				db WORD_SYS_CORE+44             
4564 c1 45			dw .EDIT            
4566 07				db 6 + 1 
4567 .. 00			db "ACCEPT",0              
456e				endm 
# End of macro CWHEAD
456e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
456e					; TODO crashes on push 
456e					if DEBUG_FORTH_WORDS_KEY 
456e						DMARK "ACC" 
456e f5				push af  
456f 3a 83 45			ld a, (.dmark)  
4572 32 b4 fb			ld (debug_mark),a  
4575 3a 84 45			ld a, (.dmark+1)  
4578 32 b5 fb			ld (debug_mark+1),a  
457b 3a 85 45			ld a, (.dmark+2)  
457e 32 b6 fb			ld (debug_mark+2),a  
4581 18 03			jr .pastdmark  
4583 ..			.dmark: db "ACC"  
4586 f1			.pastdmark: pop af  
4587			endm  
# End of macro DMARK
4587						CALLMONITOR 
4587 cd 3d 17			call break_point_state  
458a				endm  
# End of macro CALLMONITOR
458a					endif 
458a 21 98 f1				ld hl, os_input 
458d 3e 00				ld a, 0 
458f 77					ld (hl),a 
4590 3a c3 f9				ld a,(f_cursor_ptr) 
4593 16 64				ld d, 100 
4595 0e 00				ld c, 0 
4597 1e 28				ld e, 40 
4599 cd 45 0d				call input_str 
459c					; TODO perhaps do a type check and wrap in quotes if not a number 
459c 21 98 f1				ld hl, os_input 
459f					if DEBUG_FORTH_WORDS 
459f						DMARK "AC1" 
459f f5				push af  
45a0 3a b4 45			ld a, (.dmark)  
45a3 32 b4 fb			ld (debug_mark),a  
45a6 3a b5 45			ld a, (.dmark+1)  
45a9 32 b5 fb			ld (debug_mark+1),a  
45ac 3a b6 45			ld a, (.dmark+2)  
45af 32 b6 fb			ld (debug_mark+2),a  
45b2 18 03			jr .pastdmark  
45b4 ..			.dmark: db "AC1"  
45b7 f1			.pastdmark: pop af  
45b8			endm  
# End of macro DMARK
45b8						CALLMONITOR 
45b8 cd 3d 17			call break_point_state  
45bb				endm  
# End of macro CALLMONITOR
45bb					endif 
45bb cd 3b 1d				call forth_push_str 
45be					NEXTW 
45be c3 36 20			jp macro_next 
45c1				endm 
# End of macro NEXTW
45c1			 
45c1			.EDIT: 
45c1				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45c1 40				db WORD_SYS_CORE+44             
45c2 63 46			dw .ENDKEY            
45c4 05				db 4 + 1 
45c5 .. 00			db "EDIT",0              
45ca				endm 
# End of macro CWHEAD
45ca			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
45ca			 
45ca					; TODO does not copy from stack 
45ca					if DEBUG_FORTH_WORDS_KEY 
45ca						DMARK "EDT" 
45ca f5				push af  
45cb 3a df 45			ld a, (.dmark)  
45ce 32 b4 fb			ld (debug_mark),a  
45d1 3a e0 45			ld a, (.dmark+1)  
45d4 32 b5 fb			ld (debug_mark+1),a  
45d7 3a e1 45			ld a, (.dmark+2)  
45da 32 b6 fb			ld (debug_mark+2),a  
45dd 18 03			jr .pastdmark  
45df ..			.dmark: db "EDT"  
45e2 f1			.pastdmark: pop af  
45e3			endm  
# End of macro DMARK
45e3						CALLMONITOR 
45e3 cd 3d 17			call break_point_state  
45e6				endm  
# End of macro CALLMONITOR
45e6					endif 
45e6			 
45e6					;FORTH_DSP 
45e6					FORTH_DSP_VALUEHL 
45e6 cd c4 1e			call macro_dsp_valuehl 
45e9				endm 
# End of macro FORTH_DSP_VALUEHL
45e9			;		inc hl    ; TODO do type check 
45e9			 
45e9			;		call get_word_hl 
45e9 e5					push hl 
45ea					if DEBUG_FORTH_WORDS 
45ea						DMARK "EDp" 
45ea f5				push af  
45eb 3a ff 45			ld a, (.dmark)  
45ee 32 b4 fb			ld (debug_mark),a  
45f1 3a 00 46			ld a, (.dmark+1)  
45f4 32 b5 fb			ld (debug_mark+1),a  
45f7 3a 01 46			ld a, (.dmark+2)  
45fa 32 b6 fb			ld (debug_mark+2),a  
45fd 18 03			jr .pastdmark  
45ff ..			.dmark: db "EDp"  
4602 f1			.pastdmark: pop af  
4603			endm  
# End of macro DMARK
4603						CALLMONITOR 
4603 cd 3d 17			call break_point_state  
4606				endm  
# End of macro CALLMONITOR
4606					endif 
4606				;	ld a, 0 
4606 cd 76 11				call strlenz 
4609 23					inc hl 
460a			 
460a 06 00				ld b, 0 
460c 4d					ld c, l 
460d			 
460d e1					pop hl 
460e 11 98 f1				ld de, os_input 
4611					if DEBUG_FORTH_WORDS_KEY 
4611						DMARK "EDc" 
4611 f5				push af  
4612 3a 26 46			ld a, (.dmark)  
4615 32 b4 fb			ld (debug_mark),a  
4618 3a 27 46			ld a, (.dmark+1)  
461b 32 b5 fb			ld (debug_mark+1),a  
461e 3a 28 46			ld a, (.dmark+2)  
4621 32 b6 fb			ld (debug_mark+2),a  
4624 18 03			jr .pastdmark  
4626 ..			.dmark: db "EDc"  
4629 f1			.pastdmark: pop af  
462a			endm  
# End of macro DMARK
462a						CALLMONITOR 
462a cd 3d 17			call break_point_state  
462d				endm  
# End of macro CALLMONITOR
462d					endif 
462d ed b0				ldir 
462f			 
462f			 
462f 21 98 f1				ld hl, os_input 
4632					;ld a, 0 
4632					;ld (hl),a 
4632 3a c3 f9				ld a,(f_cursor_ptr) 
4635 16 64				ld d, 100 
4637 0e 00				ld c, 0 
4639 1e 28				ld e, 40 
463b cd 45 0d				call input_str 
463e					; TODO perhaps do a type check and wrap in quotes if not a number 
463e 21 98 f1				ld hl, os_input 
4641					if DEBUG_FORTH_WORDS 
4641						DMARK "ED1" 
4641 f5				push af  
4642 3a 56 46			ld a, (.dmark)  
4645 32 b4 fb			ld (debug_mark),a  
4648 3a 57 46			ld a, (.dmark+1)  
464b 32 b5 fb			ld (debug_mark+1),a  
464e 3a 58 46			ld a, (.dmark+2)  
4651 32 b6 fb			ld (debug_mark+2),a  
4654 18 03			jr .pastdmark  
4656 ..			.dmark: db "ED1"  
4659 f1			.pastdmark: pop af  
465a			endm  
# End of macro DMARK
465a						CALLMONITOR 
465a cd 3d 17			call break_point_state  
465d				endm  
# End of macro CALLMONITOR
465d					endif 
465d cd 3b 1d				call forth_push_str 
4660					NEXTW 
4660 c3 36 20			jp macro_next 
4663				endm 
# End of macro NEXTW
4663			 
4663			 
4663			 
4663			.ENDKEY: 
4663			; eof 
4663			 
# End of file forth_words_key.asm
4663			 
4663			if STORAGE_SE 
4663			   	include "forth_words_storage.asm" 
4663			 
4663			; | ## Fixed Storage Words 
4663			 
4663			 
4663			.BREAD: 
4663			  
4663				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4663 3a				db WORD_SYS_CORE+38             
4664 e6 46			dw .BWRITE            
4666 06				db 5 + 1 
4667 .. 00			db "BREAD",0              
466d				endm 
# End of macro CWHEAD
466d			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
466d				 
466d					if DEBUG_FORTH_WORDS_KEY 
466d						DMARK "BRD" 
466d f5				push af  
466e 3a 82 46			ld a, (.dmark)  
4671 32 b4 fb			ld (debug_mark),a  
4674 3a 83 46			ld a, (.dmark+1)  
4677 32 b5 fb			ld (debug_mark+1),a  
467a 3a 84 46			ld a, (.dmark+2)  
467d 32 b6 fb			ld (debug_mark+2),a  
4680 18 03			jr .pastdmark  
4682 ..			.dmark: db "BRD"  
4685 f1			.pastdmark: pop af  
4686			endm  
# End of macro DMARK
4686						CALLMONITOR 
4686 cd 3d 17			call break_point_state  
4689				endm  
# End of macro CALLMONITOR
4689					endif 
4689			 
4689				FORTH_DSP_VALUEHL 
4689 cd c4 1e			call macro_dsp_valuehl 
468c				endm 
# End of macro FORTH_DSP_VALUEHL
468c			 
468c				FORTH_DSP_POP 
468c cd 7c 1f			call macro_forth_dsp_pop 
468f				endm 
# End of macro FORTH_DSP_POP
468f			 
468f				; calc block address 
468f			 
468f eb				ex de, hl 
4690 3e 40			ld a, STORE_BLOCK_PHY 
4692 cd 9b 0c			call Mult16 
4695			 
4695			 
4695 11 df f9			ld de, store_page 
4698			 
4698					if DEBUG_FORTH_WORDS 
4698						DMARK "BR1" 
4698 f5				push af  
4699 3a ad 46			ld a, (.dmark)  
469c 32 b4 fb			ld (debug_mark),a  
469f 3a ae 46			ld a, (.dmark+1)  
46a2 32 b5 fb			ld (debug_mark+1),a  
46a5 3a af 46			ld a, (.dmark+2)  
46a8 32 b6 fb			ld (debug_mark+2),a  
46ab 18 03			jr .pastdmark  
46ad ..			.dmark: db "BR1"  
46b0 f1			.pastdmark: pop af  
46b1			endm  
# End of macro DMARK
46b1						CALLMONITOR 
46b1 cd 3d 17			call break_point_state  
46b4				endm  
# End of macro CALLMONITOR
46b4					endif 
46b4			 
46b4 cd 04 03			call storage_read_block 
46b7			 
46b7 cd 41 0d			call ishlzero 
46ba 20 05			jr nz, .brfound 
46bc			 
46bc cd cd 1c			call forth_push_numhl 
46bf 18 22			jr .brdone 
46c1			 
46c1			 
46c1			.brfound: 
46c1 21 e1 f9		        ld hl, store_page+2 
46c4			 
46c4					if DEBUG_FORTH_WORDS 
46c4						DMARK "BR2" 
46c4 f5				push af  
46c5 3a d9 46			ld a, (.dmark)  
46c8 32 b4 fb			ld (debug_mark),a  
46cb 3a da 46			ld a, (.dmark+1)  
46ce 32 b5 fb			ld (debug_mark+1),a  
46d1 3a db 46			ld a, (.dmark+2)  
46d4 32 b6 fb			ld (debug_mark+2),a  
46d7 18 03			jr .pastdmark  
46d9 ..			.dmark: db "BR2"  
46dc f1			.pastdmark: pop af  
46dd			endm  
# End of macro DMARK
46dd						CALLMONITOR 
46dd cd 3d 17			call break_point_state  
46e0				endm  
# End of macro CALLMONITOR
46e0					endif 
46e0			 
46e0 cd 3b 1d			call forth_push_str 
46e3			 
46e3			 
46e3			.brdone: 
46e3			 
46e3					NEXTW 
46e3 c3 36 20			jp macro_next 
46e6				endm 
# End of macro NEXTW
46e6			.BWRITE: 
46e6				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
46e6 3a				db WORD_SYS_CORE+38             
46e7 7b 47			dw .BUPD            
46e9 07				db 6 + 1 
46ea .. 00			db "BWRITE",0              
46f1				endm 
# End of macro CWHEAD
46f1			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
46f1			 
46f1					if DEBUG_FORTH_WORDS_KEY 
46f1						DMARK "BWR" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 b4 fb			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 b5 fb			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 b6 fb			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "BWR"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a						CALLMONITOR 
470a cd 3d 17			call break_point_state  
470d				endm  
# End of macro CALLMONITOR
470d					endif 
470d			 
470d				FORTH_DSP_VALUEHL 
470d cd c4 1e			call macro_dsp_valuehl 
4710				endm 
# End of macro FORTH_DSP_VALUEHL
4710			 
4710				; calc block address 
4710			 
4710 eb				ex de, hl 
4711 3e 40			ld a, STORE_BLOCK_PHY 
4713 cd 9b 0c			call Mult16 
4716			 
4716 e5				push hl         ; address 
4717			 
4717				FORTH_DSP_POP 
4717 cd 7c 1f			call macro_forth_dsp_pop 
471a				endm 
# End of macro FORTH_DSP_POP
471a			 
471a				FORTH_DSP_VALUEHL 
471a cd c4 1e			call macro_dsp_valuehl 
471d				endm 
# End of macro FORTH_DSP_VALUEHL
471d			 
471d				FORTH_DSP_POP 
471d cd 7c 1f			call macro_forth_dsp_pop 
4720				endm 
# End of macro FORTH_DSP_POP
4720			 
4720 cd 24 0a			call storage_clear_page 
4723			 
4723				; copy string to store page 
4723			 
4723 e5				push hl     ; save string address 
4724			 
4724 3e 00			ld a, 0 
4726 cd 81 11			call strlent 
4729			 
4729 23				inc hl 
472a			 
472a 4d				ld c, l 
472b 06 00			ld b, 0 
472d			 
472d e1				pop hl 
472e 11 e1 f9			ld de, store_page + 2 
4731					if DEBUG_FORTH_WORDS 
4731						DMARK "BW1" 
4731 f5				push af  
4732 3a 46 47			ld a, (.dmark)  
4735 32 b4 fb			ld (debug_mark),a  
4738 3a 47 47			ld a, (.dmark+1)  
473b 32 b5 fb			ld (debug_mark+1),a  
473e 3a 48 47			ld a, (.dmark+2)  
4741 32 b6 fb			ld (debug_mark+2),a  
4744 18 03			jr .pastdmark  
4746 ..			.dmark: db "BW1"  
4749 f1			.pastdmark: pop af  
474a			endm  
# End of macro DMARK
474a						CALLMONITOR 
474a cd 3d 17			call break_point_state  
474d				endm  
# End of macro CALLMONITOR
474d					endif 
474d ed b0			ldir 
474f			 
474f			 
474f				; poke the start of the block with flags to prevent high level file ops hitting the block 
474f			 
474f 21 ff ff			ld hl, $ffff 
4752			 
4752 22 df f9			ld (store_page), hl	 
4755				 
4755 e1				pop hl    ; get address 
4756 11 df f9			ld de, store_page 
4759			 
4759					if DEBUG_FORTH_WORDS 
4759						DMARK "BW2" 
4759 f5				push af  
475a 3a 6e 47			ld a, (.dmark)  
475d 32 b4 fb			ld (debug_mark),a  
4760 3a 6f 47			ld a, (.dmark+1)  
4763 32 b5 fb			ld (debug_mark+1),a  
4766 3a 70 47			ld a, (.dmark+2)  
4769 32 b6 fb			ld (debug_mark+2),a  
476c 18 03			jr .pastdmark  
476e ..			.dmark: db "BW2"  
4771 f1			.pastdmark: pop af  
4772			endm  
# End of macro DMARK
4772						CALLMONITOR 
4772 cd 3d 17			call break_point_state  
4775				endm  
# End of macro CALLMONITOR
4775					endif 
4775			 
4775 cd 69 03			call storage_write_block 
4778			 
4778					NEXTW 
4778 c3 36 20			jp macro_next 
477b				endm 
# End of macro NEXTW
477b			 
477b			.BUPD: 
477b				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
477b 3a				db WORD_SYS_CORE+38             
477c d1 47			dw .BYID            
477e 05				db 4 + 1 
477f .. 00			db "BUPD",0              
4784				endm 
# End of macro CWHEAD
4784			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4784			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4784			; | | or completely different file system structure. 
4784			 
4784					if DEBUG_FORTH_WORDS_KEY 
4784						DMARK "BUD" 
4784 f5				push af  
4785 3a 99 47			ld a, (.dmark)  
4788 32 b4 fb			ld (debug_mark),a  
478b 3a 9a 47			ld a, (.dmark+1)  
478e 32 b5 fb			ld (debug_mark+1),a  
4791 3a 9b 47			ld a, (.dmark+2)  
4794 32 b6 fb			ld (debug_mark+2),a  
4797 18 03			jr .pastdmark  
4799 ..			.dmark: db "BUD"  
479c f1			.pastdmark: pop af  
479d			endm  
# End of macro DMARK
479d						CALLMONITOR 
479d cd 3d 17			call break_point_state  
47a0				endm  
# End of macro CALLMONITOR
47a0					endif 
47a0			 
47a0				FORTH_DSP_VALUEHL 
47a0 cd c4 1e			call macro_dsp_valuehl 
47a3				endm 
# End of macro FORTH_DSP_VALUEHL
47a3			 
47a3				; calc block address 
47a3			 
47a3 eb				ex de, hl 
47a4 3e 40			ld a, STORE_BLOCK_PHY 
47a6 cd 9b 0c			call Mult16 
47a9			 
47a9				FORTH_DSP_POP 
47a9 cd 7c 1f			call macro_forth_dsp_pop 
47ac				endm 
# End of macro FORTH_DSP_POP
47ac			 
47ac			 
47ac 11 df f9			ld de, store_page 
47af			 
47af					if DEBUG_FORTH_WORDS 
47af						DMARK "BUe" 
47af f5				push af  
47b0 3a c4 47			ld a, (.dmark)  
47b3 32 b4 fb			ld (debug_mark),a  
47b6 3a c5 47			ld a, (.dmark+1)  
47b9 32 b5 fb			ld (debug_mark+1),a  
47bc 3a c6 47			ld a, (.dmark+2)  
47bf 32 b6 fb			ld (debug_mark+2),a  
47c2 18 03			jr .pastdmark  
47c4 ..			.dmark: db "BUe"  
47c7 f1			.pastdmark: pop af  
47c8			endm  
# End of macro DMARK
47c8						CALLMONITOR 
47c8 cd 3d 17			call break_point_state  
47cb				endm  
# End of macro CALLMONITOR
47cb					endif 
47cb			 
47cb cd 69 03			call storage_write_block 
47ce			 
47ce					NEXTW 
47ce c3 36 20			jp macro_next 
47d1				endm 
# End of macro NEXTW
47d1			 
47d1			.BYID: 
47d1			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47d1			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47d1			; 
47d1			;		 
47d1			;		if DEBUG_FORTH_WORDS_KEY 
47d1			;			DMARK "BYID" 
47d1			;			CALLMONITOR 
47d1			;		endif 
47d1			; 
47d1			;		; get direct address 
47d1			; 
47d1			;		FORTH_DSP_VALUEHL 
47d1			; 
47d1			;		FORTH_DSP_POP 
47d1			; 
47d1			;	; calc block address 
47d1			; 
47d1			;	ex de, hl 
47d1			;	ld a, STORE_BLOCK_PHY 
47d1			;	call Mult16 
47d1			;	;	do BREAD with number as param 
47d1			;	; push the file name	 
47d1			;	ld de, store_page 
47d1			;	call storage_read_block 
47d1			 ;       ld hl, store_page+2 
47d1			; 
47d1			; 
47d1			;		NEXTW 
47d1			;.BYNAME: 
47d1			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47d1			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47d1			;		NEXTW 
47d1			; 
47d1			.DIR: 
47d1				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47d1 3a				db WORD_SYS_CORE+38             
47d2 d5 48			dw .SAVE            
47d4 04				db 3 + 1 
47d5 .. 00			db "DIR",0              
47d9				endm 
# End of macro CWHEAD
47d9			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
47d9			 
47d9					if DEBUG_FORTH_WORDS_KEY 
47d9						DMARK "DIR" 
47d9 f5				push af  
47da 3a ee 47			ld a, (.dmark)  
47dd 32 b4 fb			ld (debug_mark),a  
47e0 3a ef 47			ld a, (.dmark+1)  
47e3 32 b5 fb			ld (debug_mark+1),a  
47e6 3a f0 47			ld a, (.dmark+2)  
47e9 32 b6 fb			ld (debug_mark+2),a  
47ec 18 03			jr .pastdmark  
47ee ..			.dmark: db "DIR"  
47f1 f1			.pastdmark: pop af  
47f2			endm  
# End of macro DMARK
47f2						CALLMONITOR 
47f2 cd 3d 17			call break_point_state  
47f5				endm  
# End of macro CALLMONITOR
47f5					endif 
47f5 cd b5 03			call storage_get_block_0 
47f8			 
47f8 21 df f9			ld hl, store_page     ; get current id count 
47fb 46				ld b, (hl) 
47fc 0e 00			ld c, 0    ; count of files   
47fe					if DEBUG_FORTH_WORDS 
47fe						DMARK "DI1" 
47fe f5				push af  
47ff 3a 13 48			ld a, (.dmark)  
4802 32 b4 fb			ld (debug_mark),a  
4805 3a 14 48			ld a, (.dmark+1)  
4808 32 b5 fb			ld (debug_mark+1),a  
480b 3a 15 48			ld a, (.dmark+2)  
480e 32 b6 fb			ld (debug_mark+2),a  
4811 18 03			jr .pastdmark  
4813 ..			.dmark: db "DI1"  
4816 f1			.pastdmark: pop af  
4817			endm  
# End of macro DMARK
4817						CALLMONITOR 
4817 cd 3d 17			call break_point_state  
481a				endm  
# End of macro CALLMONITOR
481a					endif 
481a			 
481a				; check for empty drive 
481a			 
481a 3e 00			ld a, 0 
481c b8				cp b 
481d ca 8b 48			jp z, .dirdone 
4820			 
4820				; for each of the current ids do a search for them and if found push to stack 
4820			 
4820 c5			.diritem:	push bc 
4821 21 40 00				ld hl, STORE_BLOCK_PHY 
4824 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4826 58					ld e,b 
4827			 
4827			;		if DEBUG_FORTH_WORDS 
4827			;			DMARK "DI2" 
4827			;			CALLMONITOR 
4827			;		endif 
4827			 
4827 cd 29 06				call storage_findnextid 
482a			 
482a			;		if DEBUG_FORTH_WORDS 
482a			;			DMARK "DI3" 
482a			;			CALLMONITOR 
482a			;		endif 
482a			 
482a					; if found hl will be non zero 
482a			 
482a cd 41 0d				call ishlzero 
482d			;		ld a, l 
482d			;		add h 
482d			; 
482d			;		cp 0 
482d 28 59				jr z, .dirnotfound 
482f			 
482f					; increase count 
482f			 
482f c1					pop bc	 
4830 0c					inc c 
4831 c5					push bc 
4832					 
4832			 
4832					; get file header and push the file name 
4832			 
4832 11 df f9				ld de, store_page 
4835 cd 04 03				call storage_read_block 
4838			 
4838					; push file id to stack 
4838				 
4838 3a df f9				ld a, (store_page) 
483b 26 00				ld h, 0 
483d 6f					ld l, a 
483e cd cd 1c				call forth_push_numhl 
4841			 
4841					; push extent count to stack  
4841				 
4841 3a e1 f9				ld a, (store_page+2) 
4844 26 00				ld h, 0 
4846 6f					ld l, a 
4847 cd cd 1c				call forth_push_numhl 
484a			 
484a					; push file name 
484a			 
484a 21 e2 f9				ld hl, store_page+3 
484d					if DEBUG_FORTH_WORDS 
484d						DMARK "DI5" 
484d f5				push af  
484e 3a 62 48			ld a, (.dmark)  
4851 32 b4 fb			ld (debug_mark),a  
4854 3a 63 48			ld a, (.dmark+1)  
4857 32 b5 fb			ld (debug_mark+1),a  
485a 3a 64 48			ld a, (.dmark+2)  
485d 32 b6 fb			ld (debug_mark+2),a  
4860 18 03			jr .pastdmark  
4862 ..			.dmark: db "DI5"  
4865 f1			.pastdmark: pop af  
4866			endm  
# End of macro DMARK
4866						CALLMONITOR 
4866 cd 3d 17			call break_point_state  
4869				endm  
# End of macro CALLMONITOR
4869					endif 
4869 cd 3b 1d				call forth_push_str 
486c					if DEBUG_FORTH_WORDS 
486c						DMARK "DI6" 
486c f5				push af  
486d 3a 81 48			ld a, (.dmark)  
4870 32 b4 fb			ld (debug_mark),a  
4873 3a 82 48			ld a, (.dmark+1)  
4876 32 b5 fb			ld (debug_mark+1),a  
4879 3a 83 48			ld a, (.dmark+2)  
487c 32 b6 fb			ld (debug_mark+2),a  
487f 18 03			jr .pastdmark  
4881 ..			.dmark: db "DI6"  
4884 f1			.pastdmark: pop af  
4885			endm  
# End of macro DMARK
4885						CALLMONITOR 
4885 cd 3d 17			call break_point_state  
4888				endm  
# End of macro CALLMONITOR
4888					endif 
4888			.dirnotfound: 
4888 c1					pop bc     
4889 10 95				djnz .diritem 
488b				 
488b			.dirdone:	 
488b					if DEBUG_FORTH_WORDS 
488b						DMARK "DI7" 
488b f5				push af  
488c 3a a0 48			ld a, (.dmark)  
488f 32 b4 fb			ld (debug_mark),a  
4892 3a a1 48			ld a, (.dmark+1)  
4895 32 b5 fb			ld (debug_mark+1),a  
4898 3a a2 48			ld a, (.dmark+2)  
489b 32 b6 fb			ld (debug_mark+2),a  
489e 18 03			jr .pastdmark  
48a0 ..			.dmark: db "DI7"  
48a3 f1			.pastdmark: pop af  
48a4			endm  
# End of macro DMARK
48a4						CALLMONITOR 
48a4 cd 3d 17			call break_point_state  
48a7				endm  
# End of macro CALLMONITOR
48a7					endif 
48a7			 
48a7					; push a count of the dir items found 
48a7			 
48a7 26 00				ld h, 0 
48a9 69					ld l, c 
48aa cd cd 1c				call forth_push_numhl 
48ad			 
48ad					; push the bank label 
48ad			 
48ad cd b5 03				call storage_get_block_0 
48b0			 
48b0				 
48b0 21 e2 f9		 		ld hl, store_page+3 
48b3			 
48b3					if DEBUG_FORTH_WORDS 
48b3						DMARK "DI8" 
48b3 f5				push af  
48b4 3a c8 48			ld a, (.dmark)  
48b7 32 b4 fb			ld (debug_mark),a  
48ba 3a c9 48			ld a, (.dmark+1)  
48bd 32 b5 fb			ld (debug_mark+1),a  
48c0 3a ca 48			ld a, (.dmark+2)  
48c3 32 b6 fb			ld (debug_mark+2),a  
48c6 18 03			jr .pastdmark  
48c8 ..			.dmark: db "DI8"  
48cb f1			.pastdmark: pop af  
48cc			endm  
# End of macro DMARK
48cc						CALLMONITOR 
48cc cd 3d 17			call break_point_state  
48cf				endm  
# End of macro CALLMONITOR
48cf					endif 
48cf cd 3b 1d				call forth_push_str 
48d2			 
48d2			 
48d2				 
48d2					NEXTW 
48d2 c3 36 20			jp macro_next 
48d5				endm 
# End of macro NEXTW
48d5			.SAVE: 
48d5			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
48d5			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
48d5			;		NEXTW 
48d5			;.LOAD: 
48d5			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
48d5			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
48d5			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
48d5			;; > > The LOAD command can not be used in any user words or compound lines. 
48d5			; 
48d5			;		; store_openext use it. If zero it is EOF 
48d5			; 
48d5			;		; read block from current stream id 
48d5			;		; if the block does not contain zero term keep reading blocks until zero found 
48d5			;		; push the block to stack 
48d5			;		; save the block id to stream 
48d5			; 
48d5			; 
48d5			;		FORTH_DSP_VALUEHL 
48d5			; 
48d5			;;		push hl 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOA" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		FORTH_DSP_POP 
48d5			; 
48d5			;;		pop hl 
48d5			; 
48d5			;		ld h, l 
48d5			;		ld l, 0 
48d5			; 
48d5			;		push hl     ; stack holds current file id and extent to work with 
48d5			; 
48d5			; 
48d5			;		ld de, store_page      ; get block zero of file 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO0" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		call storage_read 
48d5			; 
48d5			;		ld a, (store_page+2)    ; max extents for this file 
48d5			;		ld  (store_openmaxext),a   ; get our limit 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOE" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			; 
48d5			;; TODO dont know why max extents are not present 
48d5			;;		cp 0 
48d5			;;		jp z, .loadeof     ; dont read past eof 
48d5			; 
48d5			;;		ld a, 1   ; start from the head of the file 
48d5			; 
48d5			;.loadline:	pop hl 
48d5			;		inc hl 
48d5			;		ld  a, (store_openmaxext)   ; get our limit 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOx" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		inc a 
48d5			;		cp l 
48d5			;		jp z, .loadeof 
48d5			;		push hl    ; save current extent 
48d5			; 
48d5			;		ld de, store_page 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO1" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		call storage_read 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO2" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;	call ishlzero 
48d5			;	ld a, l 
48d5			;	add h 
48d5			;	cp 0 
48d5			;	jr z, .loadeof 
48d5			; 
48d5			;	; not eof so hl should point to data to exec 
48d5			; 
48d5			;	; will need to add the FORTH_END_BUFFER flag 
48d5			 ; 
48d5			;	ld hl, store_page+2 
48d5			;	ld bc, 255 
48d5			;	ld a, 0 
48d5			;	cpir 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOt" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;	dec hl 
48d5			;	ld a, ' ' 
48d5			;	ld (hl), a 
48d5			;	inc hl 
48d5			;	ld (hl), a 
48d5			;	inc hl 
48d5			;	ld (hl), a 
48d5			;	inc hl 
48d5			;	ld a, FORTH_END_BUFFER 
48d5			;	ld (hl), a 
48d5			; 
48d5			;	; TODO handle more than a single block read 
48d5			; 
48d5			; 
48d5			;	ld hl, store_page+2 
48d5			; 
48d5			;	ld (os_tok_ptr), hl 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO3" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			; 
48d5			;	call forthparse 
48d5			;	call forthexec 
48d5			;	call forthexec_cleanup 
48d5			; 
48d5			;	; go to next extent 
48d5			; 
48d5			;	; get next block  or mark as eof 
48d5			;	jp .loadline 
48d5			; 
48d5			; 
48d5			; 
48d5			;	       NEXTW 
48d5			;.loadeof:	ld a, 0 
48d5			;		ld (store_openext), a 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOF" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		ret 
48d5			;		;NEXTW 
48d5			;.BSAVE:   
48d5			; 
48d5			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
48d5			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
48d5			;		NEXTW 
48d5			;.BLOAD: 
48d5			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
48d5			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
48d5			;		NEXTW 
48d5			;;;; counter gap 
48d5			 
48d5			 
48d5			.SEO: 
48d5				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
48d5 64				db WORD_SYS_CORE+80             
48d6 f4 48			dw .SEI            
48d8 04				db 3 + 1 
48d9 .. 00			db "SEO",0              
48dd				endm 
# End of macro CWHEAD
48dd			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
48dd			 
48dd					; get port 
48dd			 
48dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48dd cd c4 1e			call macro_dsp_valuehl 
48e0				endm 
# End of macro FORTH_DSP_VALUEHL
48e0			 
48e0 e5					push hl    ; u2 - byte 
48e1			 
48e1					; destroy value TOS 
48e1			 
48e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48e1 cd 7c 1f			call macro_forth_dsp_pop 
48e4				endm 
# End of macro FORTH_DSP_POP
48e4			 
48e4					; get byte to send 
48e4			 
48e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48e4 cd c4 1e			call macro_dsp_valuehl 
48e7				endm 
# End of macro FORTH_DSP_VALUEHL
48e7			 
48e7 e5					push hl    ; u1 - addr 
48e8			 
48e8					; destroy value TOS 
48e8			 
48e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48e8 cd 7c 1f			call macro_forth_dsp_pop 
48eb				endm 
# End of macro FORTH_DSP_POP
48eb			 
48eb					; one value on hl get other one back 
48eb			 
48eb d1					pop de   ; u1 - byte 
48ec			 
48ec e1					pop hl   ; u2 - addr 
48ed			 
48ed					; TODO Send SPI byte 
48ed			 
48ed			 
48ed 7b					ld a, e 
48ee cd e2 01				call se_writebyte 
48f1			 
48f1					 
48f1			 
48f1					NEXTW 
48f1 c3 36 20			jp macro_next 
48f4				endm 
# End of macro NEXTW
48f4			 
48f4			.SEI: 
48f4				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
48f4 65				db WORD_SYS_CORE+81             
48f5 0e 49			dw .SFREE            
48f7 04				db 3 + 1 
48f8 .. 00			db "SEI",0              
48fc				endm 
# End of macro CWHEAD
48fc			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
48fc			 
48fc					; get port 
48fc			 
48fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48fc cd c4 1e			call macro_dsp_valuehl 
48ff				endm 
# End of macro FORTH_DSP_VALUEHL
48ff			 
48ff			;		push hl 
48ff			 
48ff					; destroy value TOS 
48ff			 
48ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48ff cd 7c 1f			call macro_forth_dsp_pop 
4902				endm 
# End of macro FORTH_DSP_POP
4902			 
4902					; one value on hl get other one back 
4902			 
4902			;		pop hl 
4902			 
4902			 
4902					; TODO Get SPI byte 
4902			 
4902 cd 84 02				call se_readbyte 
4905			 
4905 26 00				ld h, 0 
4907 6f					ld l, a 
4908 cd cd 1c				call forth_push_numhl 
490b			 
490b					NEXTW 
490b c3 36 20			jp macro_next 
490e				endm 
# End of macro NEXTW
490e			 
490e			.SFREE: 
490e				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
490e 67				db WORD_SYS_CORE+83             
490f 3d 49			dw .SIZE            
4911 06				db 5 + 1 
4912 .. 00			db "FFREE",0              
4918				endm 
# End of macro CWHEAD
4918			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4918					if DEBUG_FORTH_WORDS_KEY 
4918						DMARK "FFR" 
4918 f5				push af  
4919 3a 2d 49			ld a, (.dmark)  
491c 32 b4 fb			ld (debug_mark),a  
491f 3a 2e 49			ld a, (.dmark+1)  
4922 32 b5 fb			ld (debug_mark+1),a  
4925 3a 2f 49			ld a, (.dmark+2)  
4928 32 b6 fb			ld (debug_mark+2),a  
492b 18 03			jr .pastdmark  
492d ..			.dmark: db "FFR"  
4930 f1			.pastdmark: pop af  
4931			endm  
# End of macro DMARK
4931						CALLMONITOR 
4931 cd 3d 17			call break_point_state  
4934				endm  
# End of macro CALLMONITOR
4934					endif 
4934			 
4934 cd c3 06				call storage_freeblocks 
4937			 
4937 cd cd 1c				call forth_push_numhl 
493a			 
493a				       NEXTW 
493a c3 36 20			jp macro_next 
493d				endm 
# End of macro NEXTW
493d			.SIZE: 
493d				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
493d 67				db WORD_SYS_CORE+83             
493e 71 49			dw .CREATE            
4940 05				db 4 + 1 
4941 .. 00			db "SIZE",0              
4946				endm 
# End of macro CWHEAD
4946			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4946					if DEBUG_FORTH_WORDS_KEY 
4946						DMARK "SIZ" 
4946 f5				push af  
4947 3a 5b 49			ld a, (.dmark)  
494a 32 b4 fb			ld (debug_mark),a  
494d 3a 5c 49			ld a, (.dmark+1)  
4950 32 b5 fb			ld (debug_mark+1),a  
4953 3a 5d 49			ld a, (.dmark+2)  
4956 32 b6 fb			ld (debug_mark+2),a  
4959 18 03			jr .pastdmark  
495b ..			.dmark: db "SIZ"  
495e f1			.pastdmark: pop af  
495f			endm  
# End of macro DMARK
495f						CALLMONITOR 
495f cd 3d 17			call break_point_state  
4962				endm  
# End of macro CALLMONITOR
4962					endif 
4962			 
4962					FORTH_DSP_VALUEHL 
4962 cd c4 1e			call macro_dsp_valuehl 
4965				endm 
# End of macro FORTH_DSP_VALUEHL
4965			;		push hl 
4965					FORTH_DSP_POP 
4965 cd 7c 1f			call macro_forth_dsp_pop 
4968				endm 
# End of macro FORTH_DSP_POP
4968			;		pop hl 
4968 cd 33 03				call storage_file_size 
496b			 
496b cd cd 1c				call forth_push_numhl 
496e			  
496e			 
496e				       NEXTW 
496e c3 36 20			jp macro_next 
4971				endm 
# End of macro NEXTW
4971			 
4971			.CREATE: 
4971				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4971 68				db WORD_SYS_CORE+84             
4972 df 49			dw .APPEND            
4974 07				db 6 + 1 
4975 .. 00			db "CREATE",0              
497c				endm 
# End of macro CWHEAD
497c			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
497c			; | | e.g.  
497c			; | | TestProgram CREATE 
497c			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
497c			; | |  
497c			; | | Max file IDs are 255. 
497c			; | |  
497c					 
497c					if DEBUG_FORTH_WORDS_KEY 
497c						DMARK "CRT" 
497c f5				push af  
497d 3a 91 49			ld a, (.dmark)  
4980 32 b4 fb			ld (debug_mark),a  
4983 3a 92 49			ld a, (.dmark+1)  
4986 32 b5 fb			ld (debug_mark+1),a  
4989 3a 93 49			ld a, (.dmark+2)  
498c 32 b6 fb			ld (debug_mark+2),a  
498f 18 03			jr .pastdmark  
4991 ..			.dmark: db "CRT"  
4994 f1			.pastdmark: pop af  
4995			endm  
# End of macro DMARK
4995						CALLMONITOR 
4995 cd 3d 17			call break_point_state  
4998				endm  
# End of macro CALLMONITOR
4998					endif 
4998			;		call storage_get_block_0 
4998			 
4998					; TODO pop hl 
4998			 
4998					;v5 FORTH_DSP_VALUE 
4998					FORTH_DSP_VALUE 
4998 cd ad 1e			call macro_forth_dsp_value 
499b				endm 
# End of macro FORTH_DSP_VALUE
499b			 
499b				if DEBUG_STORESE 
499b					DMARK "CR1" 
499b f5				push af  
499c 3a b0 49			ld a, (.dmark)  
499f 32 b4 fb			ld (debug_mark),a  
49a2 3a b1 49			ld a, (.dmark+1)  
49a5 32 b5 fb			ld (debug_mark+1),a  
49a8 3a b2 49			ld a, (.dmark+2)  
49ab 32 b6 fb			ld (debug_mark+2),a  
49ae 18 03			jr .pastdmark  
49b0 ..			.dmark: db "CR1"  
49b3 f1			.pastdmark: pop af  
49b4			endm  
# End of macro DMARK
49b4					CALLMONITOR 
49b4 cd 3d 17			call break_point_state  
49b7				endm  
# End of macro CALLMONITOR
49b7				endif 
49b7			;		push hl 
49b7			;		FORTH_DSP_POP 
49b7			;		pop hl 
49b7			 
49b7			;		inc hl   ; move past the type marker 
49b7			 
49b7 cd f9 06				call storage_create 
49ba			 
49ba				if DEBUG_STORESE 
49ba					DMARK "CT1" 
49ba f5				push af  
49bb 3a cf 49			ld a, (.dmark)  
49be 32 b4 fb			ld (debug_mark),a  
49c1 3a d0 49			ld a, (.dmark+1)  
49c4 32 b5 fb			ld (debug_mark+1),a  
49c7 3a d1 49			ld a, (.dmark+2)  
49ca 32 b6 fb			ld (debug_mark+2),a  
49cd 18 03			jr .pastdmark  
49cf ..			.dmark: db "CT1"  
49d2 f1			.pastdmark: pop af  
49d3			endm  
# End of macro DMARK
49d3					CALLMONITOR 
49d3 cd 3d 17			call break_point_state  
49d6				endm  
# End of macro CALLMONITOR
49d6				endif 
49d6			;		push hl 
49d6					FORTH_DSP_POP 
49d6 cd 7c 1f			call macro_forth_dsp_pop 
49d9				endm 
# End of macro FORTH_DSP_POP
49d9			;		pop hl 
49d9					; push file id to stack 
49d9 cd cd 1c				call forth_push_numhl 
49dc			 
49dc			 
49dc			 
49dc				       NEXTW 
49dc c3 36 20			jp macro_next 
49df				endm 
# End of macro NEXTW
49df			 
49df			.APPEND: 
49df				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
49df 69				db WORD_SYS_CORE+85             
49e0 70 4a			dw .SDEL            
49e2 07				db 6 + 1 
49e3 .. 00			db "APPEND",0              
49ea				endm 
# End of macro CWHEAD
49ea			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
49ea			; | | e.g. 
49ea			; | | Test CREATE      -> $01 
49ea			; | | "A string to add to file" $01 APPEND 
49ea			; | |  
49ea			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
49ea					if DEBUG_FORTH_WORDS_KEY 
49ea						DMARK "APP" 
49ea f5				push af  
49eb 3a ff 49			ld a, (.dmark)  
49ee 32 b4 fb			ld (debug_mark),a  
49f1 3a 00 4a			ld a, (.dmark+1)  
49f4 32 b5 fb			ld (debug_mark+1),a  
49f7 3a 01 4a			ld a, (.dmark+2)  
49fa 32 b6 fb			ld (debug_mark+2),a  
49fd 18 03			jr .pastdmark  
49ff ..			.dmark: db "APP"  
4a02 f1			.pastdmark: pop af  
4a03			endm  
# End of macro DMARK
4a03						CALLMONITOR 
4a03 cd 3d 17			call break_point_state  
4a06				endm  
# End of macro CALLMONITOR
4a06					endif 
4a06			 
4a06					FORTH_DSP_VALUEHL 
4a06 cd c4 1e			call macro_dsp_valuehl 
4a09				endm 
# End of macro FORTH_DSP_VALUEHL
4a09 e5					push hl 	; save file id 
4a0a			 
4a0a				if DEBUG_STORESE 
4a0a					DMARK "AP1" 
4a0a f5				push af  
4a0b 3a 1f 4a			ld a, (.dmark)  
4a0e 32 b4 fb			ld (debug_mark),a  
4a11 3a 20 4a			ld a, (.dmark+1)  
4a14 32 b5 fb			ld (debug_mark+1),a  
4a17 3a 21 4a			ld a, (.dmark+2)  
4a1a 32 b6 fb			ld (debug_mark+2),a  
4a1d 18 03			jr .pastdmark  
4a1f ..			.dmark: db "AP1"  
4a22 f1			.pastdmark: pop af  
4a23			endm  
# End of macro DMARK
4a23					CALLMONITOR 
4a23 cd 3d 17			call break_point_state  
4a26				endm  
# End of macro CALLMONITOR
4a26				endif 
4a26					FORTH_DSP_POP 
4a26 cd 7c 1f			call macro_forth_dsp_pop 
4a29				endm 
# End of macro FORTH_DSP_POP
4a29			 
4a29					FORTH_DSP_VALUEHL 
4a29 cd c4 1e			call macro_dsp_valuehl 
4a2c				endm 
# End of macro FORTH_DSP_VALUEHL
4a2c					;v5 FORTH_DSP_VALUE 
4a2c e5					push hl 	; save ptr to string to save 
4a2d			 
4a2d				if DEBUG_STORESE 
4a2d					DMARK "AP1" 
4a2d f5				push af  
4a2e 3a 42 4a			ld a, (.dmark)  
4a31 32 b4 fb			ld (debug_mark),a  
4a34 3a 43 4a			ld a, (.dmark+1)  
4a37 32 b5 fb			ld (debug_mark+1),a  
4a3a 3a 44 4a			ld a, (.dmark+2)  
4a3d 32 b6 fb			ld (debug_mark+2),a  
4a40 18 03			jr .pastdmark  
4a42 ..			.dmark: db "AP1"  
4a45 f1			.pastdmark: pop af  
4a46			endm  
# End of macro DMARK
4a46					CALLMONITOR 
4a46 cd 3d 17			call break_point_state  
4a49				endm  
# End of macro CALLMONITOR
4a49				endif 
4a49					FORTH_DSP_POP 
4a49 cd 7c 1f			call macro_forth_dsp_pop 
4a4c				endm 
# End of macro FORTH_DSP_POP
4a4c			 
4a4c d1					pop de 
4a4d e1					pop hl 
4a4e				if DEBUG_STORESE 
4a4e					DMARK "AP2" 
4a4e f5				push af  
4a4f 3a 63 4a			ld a, (.dmark)  
4a52 32 b4 fb			ld (debug_mark),a  
4a55 3a 64 4a			ld a, (.dmark+1)  
4a58 32 b5 fb			ld (debug_mark+1),a  
4a5b 3a 65 4a			ld a, (.dmark+2)  
4a5e 32 b6 fb			ld (debug_mark+2),a  
4a61 18 03			jr .pastdmark  
4a63 ..			.dmark: db "AP2"  
4a66 f1			.pastdmark: pop af  
4a67			endm  
# End of macro DMARK
4a67					CALLMONITOR 
4a67 cd 3d 17			call break_point_state  
4a6a				endm  
# End of macro CALLMONITOR
4a6a				endif 
4a6a					;inc de ; skip var type indicator 
4a6a			 
4a6a					; TODO how to append numerics???? 
4a6a			 
4a6a cd d8 08				call storage_append		 
4a6d			 
4a6d				       NEXTW 
4a6d c3 36 20			jp macro_next 
4a70				endm 
# End of macro NEXTW
4a70			.SDEL: 
4a70				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a70 6a				db WORD_SYS_CORE+86             
4a71 bc 4a			dw .OPEN            
4a73 05				db 4 + 1 
4a74 .. 00			db "ERA",0              
4a78				endm 
# End of macro CWHEAD
4a78			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a78					FORTH_DSP_VALUEHL 
4a78 cd c4 1e			call macro_dsp_valuehl 
4a7b				endm 
# End of macro FORTH_DSP_VALUEHL
4a7b			;		push hl 	; save file id 
4a7b			 
4a7b					if DEBUG_FORTH_WORDS_KEY 
4a7b						DMARK "ERA" 
4a7b f5				push af  
4a7c 3a 90 4a			ld a, (.dmark)  
4a7f 32 b4 fb			ld (debug_mark),a  
4a82 3a 91 4a			ld a, (.dmark+1)  
4a85 32 b5 fb			ld (debug_mark+1),a  
4a88 3a 92 4a			ld a, (.dmark+2)  
4a8b 32 b6 fb			ld (debug_mark+2),a  
4a8e 18 03			jr .pastdmark  
4a90 ..			.dmark: db "ERA"  
4a93 f1			.pastdmark: pop af  
4a94			endm  
# End of macro DMARK
4a94						CALLMONITOR 
4a94 cd 3d 17			call break_point_state  
4a97				endm  
# End of macro CALLMONITOR
4a97					endif 
4a97				if DEBUG_STORESE 
4a97					DMARK "ER1" 
4a97 f5				push af  
4a98 3a ac 4a			ld a, (.dmark)  
4a9b 32 b4 fb			ld (debug_mark),a  
4a9e 3a ad 4a			ld a, (.dmark+1)  
4aa1 32 b5 fb			ld (debug_mark+1),a  
4aa4 3a ae 4a			ld a, (.dmark+2)  
4aa7 32 b6 fb			ld (debug_mark+2),a  
4aaa 18 03			jr .pastdmark  
4aac ..			.dmark: db "ER1"  
4aaf f1			.pastdmark: pop af  
4ab0			endm  
# End of macro DMARK
4ab0					CALLMONITOR 
4ab0 cd 3d 17			call break_point_state  
4ab3				endm  
# End of macro CALLMONITOR
4ab3				endif 
4ab3					FORTH_DSP_POP 
4ab3 cd 7c 1f			call macro_forth_dsp_pop 
4ab6				endm 
# End of macro FORTH_DSP_POP
4ab6			 
4ab6			;		pop hl 
4ab6			 
4ab6 cd 44 05				call storage_erase 
4ab9				       NEXTW 
4ab9 c3 36 20			jp macro_next 
4abc				endm 
# End of macro NEXTW
4abc			 
4abc			.OPEN: 
4abc				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4abc 6b				db WORD_SYS_CORE+87             
4abd 4c 4b			dw .READ            
4abf 05				db 4 + 1 
4ac0 .. 00			db "OPEN",0              
4ac5				endm 
# End of macro CWHEAD
4ac5			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4ac5			; | | e.g. 
4ac5			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ac5			; | | 
4ac5			; | | Will return with 255 blocks if the file does not exist 
4ac5			 
4ac5					if DEBUG_FORTH_WORDS_KEY 
4ac5						DMARK "OPN" 
4ac5 f5				push af  
4ac6 3a da 4a			ld a, (.dmark)  
4ac9 32 b4 fb			ld (debug_mark),a  
4acc 3a db 4a			ld a, (.dmark+1)  
4acf 32 b5 fb			ld (debug_mark+1),a  
4ad2 3a dc 4a			ld a, (.dmark+2)  
4ad5 32 b6 fb			ld (debug_mark+2),a  
4ad8 18 03			jr .pastdmark  
4ada ..			.dmark: db "OPN"  
4add f1			.pastdmark: pop af  
4ade			endm  
# End of macro DMARK
4ade						CALLMONITOR 
4ade cd 3d 17			call break_point_state  
4ae1				endm  
# End of macro CALLMONITOR
4ae1					endif 
4ae1					; TODO handle multiple file opens 
4ae1			 
4ae1 3e 01			       	ld a, 1 
4ae3 32 d6 f9				ld (store_openext), a 
4ae6			 
4ae6					; get max extents for this file 
4ae6				 
4ae6								 
4ae6					FORTH_DSP_VALUEHL 
4ae6 cd c4 1e			call macro_dsp_valuehl 
4ae9				endm 
# End of macro FORTH_DSP_VALUEHL
4ae9			 
4ae9 65					ld h, l 
4aea 2e 00				ld l, 0 
4aec			 
4aec				if DEBUG_STORESE 
4aec					DMARK "OPN" 
4aec f5				push af  
4aed 3a 01 4b			ld a, (.dmark)  
4af0 32 b4 fb			ld (debug_mark),a  
4af3 3a 02 4b			ld a, (.dmark+1)  
4af6 32 b5 fb			ld (debug_mark+1),a  
4af9 3a 03 4b			ld a, (.dmark+2)  
4afc 32 b6 fb			ld (debug_mark+2),a  
4aff 18 03			jr .pastdmark  
4b01 ..			.dmark: db "OPN"  
4b04 f1			.pastdmark: pop af  
4b05			endm  
# End of macro DMARK
4b05					CALLMONITOR 
4b05 cd 3d 17			call break_point_state  
4b08				endm  
# End of macro CALLMONITOR
4b08				endif 
4b08			;		push hl 
4b08					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b08 cd 7c 1f			call macro_forth_dsp_pop 
4b0b				endm 
# End of macro FORTH_DSP_POP
4b0b			;		pop hl 
4b0b						 
4b0b 11 df f9				ld de, store_page      ; get block zero of file 
4b0e cd 4f 08				call storage_read 
4b11 cd 41 0d			call ishlzero 
4b14 20 04			jr nz, .opfound 
4b16			 
4b16				; file does not exist so indicate with 255 extents in use 
4b16			 
4b16 3e ff			ld a, 255 
4b18 18 29			jr .skipopeneof 
4b1a			 
4b1a			 
4b1a			.opfound: 
4b1a			 
4b1a			 
4b1a 3a e1 f9				ld a, (store_page+2)    ; max extents for this file 
4b1d 32 d5 f9				ld  (store_openmaxext), a   ; get our limit and push 
4b20					 
4b20				if DEBUG_STORESE 
4b20					DMARK "OPx" 
4b20 f5				push af  
4b21 3a 35 4b			ld a, (.dmark)  
4b24 32 b4 fb			ld (debug_mark),a  
4b27 3a 36 4b			ld a, (.dmark+1)  
4b2a 32 b5 fb			ld (debug_mark+1),a  
4b2d 3a 37 4b			ld a, (.dmark+2)  
4b30 32 b6 fb			ld (debug_mark+2),a  
4b33 18 03			jr .pastdmark  
4b35 ..			.dmark: db "OPx"  
4b38 f1			.pastdmark: pop af  
4b39			endm  
# End of macro DMARK
4b39					CALLMONITOR 
4b39 cd 3d 17			call break_point_state  
4b3c				endm  
# End of macro CALLMONITOR
4b3c				endif 
4b3c fe 00				cp 0 
4b3e 20 03				jr nz, .skipopeneof 
4b40					; have opened an empty file 
4b40					 
4b40 32 d6 f9				ld (store_openext), a 
4b43			 
4b43			.skipopeneof: 
4b43			 
4b43 6f					ld l, a 
4b44 26 00				ld h, 0 
4b46 cd cd 1c				call forth_push_numhl 
4b49			 
4b49			 
4b49				       NEXTW 
4b49 c3 36 20			jp macro_next 
4b4c				endm 
# End of macro NEXTW
4b4c			.READ: 
4b4c				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b4c 6c				db WORD_SYS_CORE+88             
4b4d 93 4c			dw .EOF            
4b4f 05				db 4 + 1 
4b50 .. 00			db "READ",0              
4b55				endm 
# End of macro CWHEAD
4b55			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b55			; | | e.g. 
4b55			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b55			 
4b55					if DEBUG_FORTH_WORDS_KEY 
4b55						DMARK "REA" 
4b55 f5				push af  
4b56 3a 6a 4b			ld a, (.dmark)  
4b59 32 b4 fb			ld (debug_mark),a  
4b5c 3a 6b 4b			ld a, (.dmark+1)  
4b5f 32 b5 fb			ld (debug_mark+1),a  
4b62 3a 6c 4b			ld a, (.dmark+2)  
4b65 32 b6 fb			ld (debug_mark+2),a  
4b68 18 03			jr .pastdmark  
4b6a ..			.dmark: db "REA"  
4b6d f1			.pastdmark: pop af  
4b6e			endm  
# End of macro DMARK
4b6e						CALLMONITOR 
4b6e cd 3d 17			call break_point_state  
4b71				endm  
# End of macro CALLMONITOR
4b71					endif 
4b71					; store_openext use it. If zero it is EOF 
4b71			 
4b71					; read block from current stream id 
4b71					; if the block does not contain zero term keep reading blocks until zero found 
4b71					; push the block to stack 
4b71					; save the block id to stream 
4b71			 
4b71			 
4b71					FORTH_DSP_VALUEHL 
4b71 cd c4 1e			call macro_dsp_valuehl 
4b74				endm 
# End of macro FORTH_DSP_VALUEHL
4b74			 
4b74			;		push hl 
4b74			 
4b74				if DEBUG_STORESE 
4b74					DMARK "REA" 
4b74 f5				push af  
4b75 3a 89 4b			ld a, (.dmark)  
4b78 32 b4 fb			ld (debug_mark),a  
4b7b 3a 8a 4b			ld a, (.dmark+1)  
4b7e 32 b5 fb			ld (debug_mark+1),a  
4b81 3a 8b 4b			ld a, (.dmark+2)  
4b84 32 b6 fb			ld (debug_mark+2),a  
4b87 18 03			jr .pastdmark  
4b89 ..			.dmark: db "REA"  
4b8c f1			.pastdmark: pop af  
4b8d			endm  
# End of macro DMARK
4b8d					CALLMONITOR 
4b8d cd 3d 17			call break_point_state  
4b90				endm  
# End of macro CALLMONITOR
4b90				endif 
4b90					FORTH_DSP_POP 
4b90 cd 7c 1f			call macro_forth_dsp_pop 
4b93				endm 
# End of macro FORTH_DSP_POP
4b93			 
4b93			;		pop hl 
4b93				 
4b93 65					ld h,l 
4b94			 
4b94 3a d6 f9				ld a, (store_openext) 
4b97 6f					ld l, a 
4b98					 
4b98 fe 00				cp 0 
4b9a ca 65 4c				jp z, .ateof     ; dont read past eof 
4b9d			 
4b9d			 
4b9d 11 df f9				ld de, store_page 
4ba0				if DEBUG_STORESE 
4ba0					DMARK "RE1" 
4ba0 f5				push af  
4ba1 3a b5 4b			ld a, (.dmark)  
4ba4 32 b4 fb			ld (debug_mark),a  
4ba7 3a b6 4b			ld a, (.dmark+1)  
4baa 32 b5 fb			ld (debug_mark+1),a  
4bad 3a b7 4b			ld a, (.dmark+2)  
4bb0 32 b6 fb			ld (debug_mark+2),a  
4bb3 18 03			jr .pastdmark  
4bb5 ..			.dmark: db "RE1"  
4bb8 f1			.pastdmark: pop af  
4bb9			endm  
# End of macro DMARK
4bb9					CALLMONITOR 
4bb9 cd 3d 17			call break_point_state  
4bbc				endm  
# End of macro CALLMONITOR
4bbc				endif 
4bbc cd 4f 08				call storage_read 
4bbf			 
4bbf				if DEBUG_STORESE 
4bbf					DMARK "RE2" 
4bbf f5				push af  
4bc0 3a d4 4b			ld a, (.dmark)  
4bc3 32 b4 fb			ld (debug_mark),a  
4bc6 3a d5 4b			ld a, (.dmark+1)  
4bc9 32 b5 fb			ld (debug_mark+1),a  
4bcc 3a d6 4b			ld a, (.dmark+2)  
4bcf 32 b6 fb			ld (debug_mark+2),a  
4bd2 18 03			jr .pastdmark  
4bd4 ..			.dmark: db "RE2"  
4bd7 f1			.pastdmark: pop af  
4bd8			endm  
# End of macro DMARK
4bd8					CALLMONITOR 
4bd8 cd 3d 17			call break_point_state  
4bdb				endm  
# End of macro CALLMONITOR
4bdb				endif 
4bdb cd 41 0d			call ishlzero 
4bde			;	ld a, l 
4bde			;	add h 
4bde			;	cp 0 
4bde ca 6b 4c			jp z, .readeof 
4be1			 
4be1				; not eof so hl should point to data to push to stack 
4be1			 
4be1				if DEBUG_STORESE 
4be1					DMARK "RE3" 
4be1 f5				push af  
4be2 3a f6 4b			ld a, (.dmark)  
4be5 32 b4 fb			ld (debug_mark),a  
4be8 3a f7 4b			ld a, (.dmark+1)  
4beb 32 b5 fb			ld (debug_mark+1),a  
4bee 3a f8 4b			ld a, (.dmark+2)  
4bf1 32 b6 fb			ld (debug_mark+2),a  
4bf4 18 03			jr .pastdmark  
4bf6 ..			.dmark: db "RE3"  
4bf9 f1			.pastdmark: pop af  
4bfa			endm  
# End of macro DMARK
4bfa					CALLMONITOR 
4bfa cd 3d 17			call break_point_state  
4bfd				endm  
# End of macro CALLMONITOR
4bfd				endif 
4bfd cd 3b 1d			call forth_push_str 
4c00			 
4c00				if DEBUG_STORESE 
4c00					DMARK "RE4" 
4c00 f5				push af  
4c01 3a 15 4c			ld a, (.dmark)  
4c04 32 b4 fb			ld (debug_mark),a  
4c07 3a 16 4c			ld a, (.dmark+1)  
4c0a 32 b5 fb			ld (debug_mark+1),a  
4c0d 3a 17 4c			ld a, (.dmark+2)  
4c10 32 b6 fb			ld (debug_mark+2),a  
4c13 18 03			jr .pastdmark  
4c15 ..			.dmark: db "RE4"  
4c18 f1			.pastdmark: pop af  
4c19			endm  
# End of macro DMARK
4c19					CALLMONITOR 
4c19 cd 3d 17			call break_point_state  
4c1c				endm  
# End of macro CALLMONITOR
4c1c				endif 
4c1c				; get next block  or mark as eof 
4c1c			 
4c1c 3a d5 f9			ld a, (store_openmaxext)   ; get our limit 
4c1f 4f				ld c, a	 
4c20 3a d6 f9			ld a, (store_openext) 
4c23			 
4c23				if DEBUG_STORESE 
4c23					DMARK "RE5" 
4c23 f5				push af  
4c24 3a 38 4c			ld a, (.dmark)  
4c27 32 b4 fb			ld (debug_mark),a  
4c2a 3a 39 4c			ld a, (.dmark+1)  
4c2d 32 b5 fb			ld (debug_mark+1),a  
4c30 3a 3a 4c			ld a, (.dmark+2)  
4c33 32 b6 fb			ld (debug_mark+2),a  
4c36 18 03			jr .pastdmark  
4c38 ..			.dmark: db "RE5"  
4c3b f1			.pastdmark: pop af  
4c3c			endm  
# End of macro DMARK
4c3c					CALLMONITOR 
4c3c cd 3d 17			call break_point_state  
4c3f				endm  
# End of macro CALLMONITOR
4c3f				endif 
4c3f b9				cp c 
4c40 28 29			jr z, .readeof     ; at last extent 
4c42			 
4c42 3c					inc a 
4c43 32 d6 f9				ld (store_openext), a 
4c46			 
4c46				if DEBUG_STORESE 
4c46					DMARK "RE6" 
4c46 f5				push af  
4c47 3a 5b 4c			ld a, (.dmark)  
4c4a 32 b4 fb			ld (debug_mark),a  
4c4d 3a 5c 4c			ld a, (.dmark+1)  
4c50 32 b5 fb			ld (debug_mark+1),a  
4c53 3a 5d 4c			ld a, (.dmark+2)  
4c56 32 b6 fb			ld (debug_mark+2),a  
4c59 18 03			jr .pastdmark  
4c5b ..			.dmark: db "RE6"  
4c5e f1			.pastdmark: pop af  
4c5f			endm  
# End of macro DMARK
4c5f					CALLMONITOR 
4c5f cd 3d 17			call break_point_state  
4c62				endm  
# End of macro CALLMONITOR
4c62				endif 
4c62			 
4c62			 
4c62				       NEXTW 
4c62 c3 36 20			jp macro_next 
4c65				endm 
# End of macro NEXTW
4c65			.ateof: 
4c65 21 8f 4c				ld hl, .showeof 
4c68 cd 3b 1d				call forth_push_str 
4c6b 3e 00		.readeof:	ld a, 0 
4c6d 32 d6 f9				ld (store_openext), a 
4c70			 
4c70					 
4c70				if DEBUG_STORESE 
4c70					DMARK "REF" 
4c70 f5				push af  
4c71 3a 85 4c			ld a, (.dmark)  
4c74 32 b4 fb			ld (debug_mark),a  
4c77 3a 86 4c			ld a, (.dmark+1)  
4c7a 32 b5 fb			ld (debug_mark+1),a  
4c7d 3a 87 4c			ld a, (.dmark+2)  
4c80 32 b6 fb			ld (debug_mark+2),a  
4c83 18 03			jr .pastdmark  
4c85 ..			.dmark: db "REF"  
4c88 f1			.pastdmark: pop af  
4c89			endm  
# End of macro DMARK
4c89					CALLMONITOR 
4c89 cd 3d 17			call break_point_state  
4c8c				endm  
# End of macro CALLMONITOR
4c8c				endif 
4c8c				       NEXTW 
4c8c c3 36 20			jp macro_next 
4c8f				endm 
# End of macro NEXTW
4c8f			 
4c8f .. 00		.showeof:   db "eof", 0 
4c93			 
4c93			 
4c93			.EOF: 
4c93				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c93 6d				db WORD_SYS_CORE+89             
4c94 d4 4c			dw .FORMAT            
4c96 04				db 3 + 1 
4c97 .. 00			db "EOF",0              
4c9b				endm 
# End of macro CWHEAD
4c9b			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c9b			; | | e.g. 
4c9b			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c9b					; TODO if current block id for stream is zero then push true else false 
4c9b			 
4c9b					if DEBUG_FORTH_WORDS_KEY 
4c9b						DMARK "EOF" 
4c9b f5				push af  
4c9c 3a b0 4c			ld a, (.dmark)  
4c9f 32 b4 fb			ld (debug_mark),a  
4ca2 3a b1 4c			ld a, (.dmark+1)  
4ca5 32 b5 fb			ld (debug_mark+1),a  
4ca8 3a b2 4c			ld a, (.dmark+2)  
4cab 32 b6 fb			ld (debug_mark+2),a  
4cae 18 03			jr .pastdmark  
4cb0 ..			.dmark: db "EOF"  
4cb3 f1			.pastdmark: pop af  
4cb4			endm  
# End of macro DMARK
4cb4						CALLMONITOR 
4cb4 cd 3d 17			call break_point_state  
4cb7				endm  
# End of macro CALLMONITOR
4cb7					endif 
4cb7			 
4cb7					; TODO handlue multiple file streams 
4cb7			 
4cb7					FORTH_DSP_POP     ; for now just get rid of stream id 
4cb7 cd 7c 1f			call macro_forth_dsp_pop 
4cba				endm 
# End of macro FORTH_DSP_POP
4cba			 
4cba 2e 01				ld l, 1 
4cbc 3a d5 f9				ld a, (store_openmaxext) 
4cbf fe 00				cp 0 
4cc1 28 09				jr  z, .eofdone   ; empty file 
4cc3 3a d6 f9				ld a, (store_openext) 
4cc6 fe 00				cp 0 
4cc8 28 02				jr  z, .eofdone 
4cca 2e 00				ld l, 0 
4ccc 26 00		.eofdone:	ld h, 0 
4cce cd cd 1c				call forth_push_numhl 
4cd1			 
4cd1			 
4cd1				       NEXTW 
4cd1 c3 36 20			jp macro_next 
4cd4				endm 
# End of macro NEXTW
4cd4			 
4cd4			.FORMAT: 
4cd4				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4cd4 6d				db WORD_SYS_CORE+89             
4cd5 25 4d			dw .LABEL            
4cd7 07				db 6 + 1 
4cd8 .. 00			db "FORMAT",0              
4cdf				endm 
# End of macro CWHEAD
4cdf			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4cdf					; TODO if current block id for stream is zero then push true else false 
4cdf				 
4cdf				if DEBUG_STORESE 
4cdf					DMARK "FOR" 
4cdf f5				push af  
4ce0 3a f4 4c			ld a, (.dmark)  
4ce3 32 b4 fb			ld (debug_mark),a  
4ce6 3a f5 4c			ld a, (.dmark+1)  
4ce9 32 b5 fb			ld (debug_mark+1),a  
4cec 3a f6 4c			ld a, (.dmark+2)  
4cef 32 b6 fb			ld (debug_mark+2),a  
4cf2 18 03			jr .pastdmark  
4cf4 ..			.dmark: db "FOR"  
4cf7 f1			.pastdmark: pop af  
4cf8			endm  
# End of macro DMARK
4cf8					CALLMONITOR 
4cf8 cd 3d 17			call break_point_state  
4cfb				endm  
# End of macro CALLMONITOR
4cfb				endif 
4cfb					; Wipes the bank check flags to cause a reformat on next block 0 read 
4cfb			 
4cfb 21 01 00				ld hl, 1 
4cfe 3e 00				ld a, 0 
4d00 cd e2 01				call se_writebyte 
4d03			 
4d03				if DEBUG_STORESE 
4d03					DMARK "FO0" 
4d03 f5				push af  
4d04 3a 18 4d			ld a, (.dmark)  
4d07 32 b4 fb			ld (debug_mark),a  
4d0a 3a 19 4d			ld a, (.dmark+1)  
4d0d 32 b5 fb			ld (debug_mark+1),a  
4d10 3a 1a 4d			ld a, (.dmark+2)  
4d13 32 b6 fb			ld (debug_mark+2),a  
4d16 18 03			jr .pastdmark  
4d18 ..			.dmark: db "FO0"  
4d1b f1			.pastdmark: pop af  
4d1c			endm  
# End of macro DMARK
4d1c					CALLMONITOR 
4d1c cd 3d 17			call break_point_state  
4d1f				endm  
# End of macro CALLMONITOR
4d1f				endif 
4d1f					; force bank init 
4d1f			 
4d1f cd b5 03				call storage_get_block_0 
4d22					 
4d22				       NEXTW 
4d22 c3 36 20			jp macro_next 
4d25				endm 
# End of macro NEXTW
4d25			.LABEL: 
4d25				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d25 6d				db WORD_SYS_CORE+89             
4d26 73 4d			dw .STOREPAGE            
4d28 06				db 5 + 1 
4d29 .. 00			db "LABEL",0              
4d2f				endm 
# End of macro CWHEAD
4d2f			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d2f					; TODO test to see if bank is selected 
4d2f				 
4d2f					if DEBUG_FORTH_WORDS_KEY 
4d2f						DMARK "LBL" 
4d2f f5				push af  
4d30 3a 44 4d			ld a, (.dmark)  
4d33 32 b4 fb			ld (debug_mark),a  
4d36 3a 45 4d			ld a, (.dmark+1)  
4d39 32 b5 fb			ld (debug_mark+1),a  
4d3c 3a 46 4d			ld a, (.dmark+2)  
4d3f 32 b6 fb			ld (debug_mark+2),a  
4d42 18 03			jr .pastdmark  
4d44 ..			.dmark: db "LBL"  
4d47 f1			.pastdmark: pop af  
4d48			endm  
# End of macro DMARK
4d48						CALLMONITOR 
4d48 cd 3d 17			call break_point_state  
4d4b				endm  
# End of macro CALLMONITOR
4d4b					endif 
4d4b			;	if DEBUG_STORESE 
4d4b			;		DMARK "LBL" 
4d4b			;		CALLMONITOR 
4d4b			;	endif 
4d4b					FORTH_DSP_VALUEHL 
4d4b cd c4 1e			call macro_dsp_valuehl 
4d4e				endm 
# End of macro FORTH_DSP_VALUEHL
4d4e					;v5FORTH_DSP_VALUE 
4d4e					 
4d4e			;		push hl 
4d4e					FORTH_DSP_POP 
4d4e cd 7c 1f			call macro_forth_dsp_pop 
4d51				endm 
# End of macro FORTH_DSP_POP
4d51			;		pop hl 
4d51			 
4d51			;v5		inc hl   ; move past the type marker 
4d51			 
4d51				if DEBUG_STORESE 
4d51					DMARK "LBl" 
4d51 f5				push af  
4d52 3a 66 4d			ld a, (.dmark)  
4d55 32 b4 fb			ld (debug_mark),a  
4d58 3a 67 4d			ld a, (.dmark+1)  
4d5b 32 b5 fb			ld (debug_mark+1),a  
4d5e 3a 68 4d			ld a, (.dmark+2)  
4d61 32 b6 fb			ld (debug_mark+2),a  
4d64 18 03			jr .pastdmark  
4d66 ..			.dmark: db "LBl"  
4d69 f1			.pastdmark: pop af  
4d6a			endm  
# End of macro DMARK
4d6a					CALLMONITOR 
4d6a cd 3d 17			call break_point_state  
4d6d				endm  
# End of macro CALLMONITOR
4d6d				endif 
4d6d cd d9 04				call storage_label 
4d70			 
4d70				       NEXTW 
4d70 c3 36 20			jp macro_next 
4d73				endm 
# End of macro NEXTW
4d73			.STOREPAGE: 
4d73				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d73 6d				db WORD_SYS_CORE+89             
4d74 a6 4d			dw .LABELS            
4d76 0a				db 9 + 1 
4d77 .. 00			db "STOREPAGE",0              
4d81				endm 
# End of macro CWHEAD
4d81			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d81					; TODO test to see if bank is selected 
4d81				 
4d81					if DEBUG_FORTH_WORDS_KEY 
4d81						DMARK "STP" 
4d81 f5				push af  
4d82 3a 96 4d			ld a, (.dmark)  
4d85 32 b4 fb			ld (debug_mark),a  
4d88 3a 97 4d			ld a, (.dmark+1)  
4d8b 32 b5 fb			ld (debug_mark+1),a  
4d8e 3a 98 4d			ld a, (.dmark+2)  
4d91 32 b6 fb			ld (debug_mark+2),a  
4d94 18 03			jr .pastdmark  
4d96 ..			.dmark: db "STP"  
4d99 f1			.pastdmark: pop af  
4d9a			endm  
# End of macro DMARK
4d9a						CALLMONITOR 
4d9a cd 3d 17			call break_point_state  
4d9d				endm  
# End of macro CALLMONITOR
4d9d					endif 
4d9d			;	if DEBUG_STORESE 
4d9d			;		DMARK "STP" 
4d9d			;		CALLMONITOR 
4d9d			;	endif 
4d9d			 
4d9d 21 df f9			ld hl, store_page 
4da0 cd cd 1c			call forth_push_numhl 
4da3			 
4da3			 
4da3				       NEXTW 
4da3 c3 36 20			jp macro_next 
4da6				endm 
# End of macro NEXTW
4da6			.LABELS: 
4da6				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4da6 6d				db WORD_SYS_CORE+89             
4da7 30 4e			dw .ENDSTORAGE            
4da9 07				db 6 + 1 
4daa .. 00			db "LABELS",0              
4db1				endm 
# End of macro CWHEAD
4db1			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4db1					;  
4db1			 
4db1					; save the current device selected to restore afterwards 
4db1				 
4db1 3a c5 f9				ld a, (spi_device) 
4db4 f5					push af 
4db5			 
4db5			 
4db5					; run through each of the banks 
4db5			 
4db5 21 01 00				ld hl, 1 
4db8 cd cd 1c				call forth_push_numhl 
4dbb 3e ff				ld a, SPI_CE_HIGH 
4dbd cb 87				res SPI_CE0, a 
4dbf 32 c5 f9				ld (spi_device), a 
4dc2 cd b5 03				call storage_get_block_0 
4dc5 21 e2 f9				ld hl, store_page+3 
4dc8 cd 3b 1d				call forth_push_str 
4dcb			 
4dcb					 
4dcb 21 02 00				ld hl, 2 
4dce cd cd 1c				call forth_push_numhl 
4dd1 3e ff				ld a, SPI_CE_HIGH 
4dd3 cb 8f				res SPI_CE1, a 
4dd5 32 c5 f9				ld (spi_device), a 
4dd8 cd b5 03				call storage_get_block_0 
4ddb 21 e2 f9				ld hl, store_page+3 
4dde cd 3b 1d				call forth_push_str 
4de1			 
4de1					 
4de1 21 03 00				ld hl, 3 
4de4 cd cd 1c				call forth_push_numhl 
4de7 3e ff				ld a, SPI_CE_HIGH 
4de9 cb 97				res SPI_CE2, a 
4deb 32 c5 f9				ld (spi_device), a 
4dee cd b5 03				call storage_get_block_0 
4df1 21 e2 f9				ld hl, store_page+3 
4df4 cd 3b 1d				call forth_push_str 
4df7			 
4df7			 
4df7 21 04 00				ld hl, 4 
4dfa cd cd 1c				call forth_push_numhl 
4dfd 3e ff				ld a, SPI_CE_HIGH 
4dff cb 9f				res SPI_CE3, a 
4e01 32 c5 f9				ld (spi_device), a 
4e04 cd b5 03				call storage_get_block_0 
4e07 21 e2 f9				ld hl, store_page+3 
4e0a cd 3b 1d				call forth_push_str 
4e0d			 
4e0d					 
4e0d			 
4e0d 21 05 00				ld hl, 5 
4e10 cd cd 1c				call forth_push_numhl 
4e13 3e ff				ld a, SPI_CE_HIGH 
4e15 cb a7				res SPI_CE4, a 
4e17 32 c5 f9				ld (spi_device), a 
4e1a cd b5 03				call storage_get_block_0 
4e1d 21 e2 f9				ld hl, store_page+3 
4e20 cd 3b 1d				call forth_push_str 
4e23			 
4e23					 
4e23					; push fixed count of storage devices (on board) for now 
4e23			 
4e23 21 05 00				ld hl, 5 
4e26 cd cd 1c				call forth_push_numhl 
4e29			 
4e29					; restore selected device  
4e29				 
4e29 f1					pop af 
4e2a 32 c5 f9				ld (spi_device), a 
4e2d			 
4e2d				       NEXTW 
4e2d c3 36 20			jp macro_next 
4e30				endm 
# End of macro NEXTW
4e30			 
4e30			.ENDSTORAGE: 
4e30			; eof 
# End of file forth_words_storage.asm
4e30			endif 
4e30				include "forth_words_device.asm" 
4e30			; Device related words 
4e30			 
4e30			; | ## Device Words 
4e30			 
4e30			if SOUND_ENABLE 
4e30			.NOTE: 
4e30				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e30			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e30					if DEBUG_FORTH_WORDS_KEY 
4e30						DMARK "NTE" 
4e30						CALLMONITOR 
4e30					endif 
4e30			 
4e30				 
4e30			 
4e30					NEXTW 
4e30			.AFTERSOUND: 
4e30			endif 
4e30			 
4e30			 
4e30			USE_GPIO: equ 0 
4e30			 
4e30			if USE_GPIO 
4e30			.GP1: 
4e30				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e30			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e30					NEXTW 
4e30			.GP2: 
4e30				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e30			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e30			 
4e30					NEXTW 
4e30			 
4e30			.GP3: 
4e30				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e30			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e30			 
4e30					NEXTW 
4e30			 
4e30			.GP4: 
4e30				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e30			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e30			 
4e30					NEXTW 
4e30			.SIN: 
4e30			 
4e30			 
4e30			endif 
4e30			 
4e30			 
4e30				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e30 33				db WORD_SYS_CORE+31             
4e31 65 4e			dw .SOUT            
4e33 03				db 2 + 1 
4e34 .. 00			db "IN",0              
4e37				endm 
# End of macro CWHEAD
4e37			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e37					if DEBUG_FORTH_WORDS_KEY 
4e37						DMARK "IN." 
4e37 f5				push af  
4e38 3a 4c 4e			ld a, (.dmark)  
4e3b 32 b4 fb			ld (debug_mark),a  
4e3e 3a 4d 4e			ld a, (.dmark+1)  
4e41 32 b5 fb			ld (debug_mark+1),a  
4e44 3a 4e 4e			ld a, (.dmark+2)  
4e47 32 b6 fb			ld (debug_mark+2),a  
4e4a 18 03			jr .pastdmark  
4e4c ..			.dmark: db "IN."  
4e4f f1			.pastdmark: pop af  
4e50			endm  
# End of macro DMARK
4e50						CALLMONITOR 
4e50 cd 3d 17			call break_point_state  
4e53				endm  
# End of macro CALLMONITOR
4e53					endif 
4e53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e53 cd c4 1e			call macro_dsp_valuehl 
4e56				endm 
# End of macro FORTH_DSP_VALUEHL
4e56			 
4e56 e5					push hl 
4e57			 
4e57					; destroy value TOS 
4e57			 
4e57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e57 cd 7c 1f			call macro_forth_dsp_pop 
4e5a				endm 
# End of macro FORTH_DSP_POP
4e5a			 
4e5a					; one value on hl get other one back 
4e5a			 
4e5a c1					pop bc 
4e5b			 
4e5b					; do the sub 
4e5b			;		ex de, hl 
4e5b			 
4e5b ed 68				in l,(c) 
4e5d			 
4e5d					; save it 
4e5d			 
4e5d 26 00				ld h,0 
4e5f			 
4e5f					; TODO push value back onto stack for another op etc 
4e5f			 
4e5f cd cd 1c				call forth_push_numhl 
4e62					NEXTW 
4e62 c3 36 20			jp macro_next 
4e65				endm 
# End of macro NEXTW
4e65			.SOUT: 
4e65				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e65 34				db WORD_SYS_CORE+32             
4e66 b8 4e			dw .SPIO            
4e68 04				db 3 + 1 
4e69 .. 00			db "OUT",0              
4e6d				endm 
# End of macro CWHEAD
4e6d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e6d					if DEBUG_FORTH_WORDS_KEY 
4e6d						DMARK "OUT" 
4e6d f5				push af  
4e6e 3a 82 4e			ld a, (.dmark)  
4e71 32 b4 fb			ld (debug_mark),a  
4e74 3a 83 4e			ld a, (.dmark+1)  
4e77 32 b5 fb			ld (debug_mark+1),a  
4e7a 3a 84 4e			ld a, (.dmark+2)  
4e7d 32 b6 fb			ld (debug_mark+2),a  
4e80 18 03			jr .pastdmark  
4e82 ..			.dmark: db "OUT"  
4e85 f1			.pastdmark: pop af  
4e86			endm  
# End of macro DMARK
4e86						CALLMONITOR 
4e86 cd 3d 17			call break_point_state  
4e89				endm  
# End of macro CALLMONITOR
4e89					endif 
4e89			 
4e89					; get port 
4e89			 
4e89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e89 cd c4 1e			call macro_dsp_valuehl 
4e8c				endm 
# End of macro FORTH_DSP_VALUEHL
4e8c			 
4e8c e5					push hl 
4e8d			 
4e8d					; destroy value TOS 
4e8d			 
4e8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e8d cd 7c 1f			call macro_forth_dsp_pop 
4e90				endm 
# End of macro FORTH_DSP_POP
4e90			 
4e90					; get byte to send 
4e90			 
4e90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e90 cd c4 1e			call macro_dsp_valuehl 
4e93				endm 
# End of macro FORTH_DSP_VALUEHL
4e93			 
4e93			;		push hl 
4e93			 
4e93					; destroy value TOS 
4e93			 
4e93					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e93 cd 7c 1f			call macro_forth_dsp_pop 
4e96				endm 
# End of macro FORTH_DSP_POP
4e96			 
4e96					; one value on hl get other one back 
4e96			 
4e96			;		pop hl 
4e96			 
4e96 c1					pop bc 
4e97			 
4e97					if DEBUG_FORTH_WORDS 
4e97						DMARK "OUT" 
4e97 f5				push af  
4e98 3a ac 4e			ld a, (.dmark)  
4e9b 32 b4 fb			ld (debug_mark),a  
4e9e 3a ad 4e			ld a, (.dmark+1)  
4ea1 32 b5 fb			ld (debug_mark+1),a  
4ea4 3a ae 4e			ld a, (.dmark+2)  
4ea7 32 b6 fb			ld (debug_mark+2),a  
4eaa 18 03			jr .pastdmark  
4eac ..			.dmark: db "OUT"  
4eaf f1			.pastdmark: pop af  
4eb0			endm  
# End of macro DMARK
4eb0						CALLMONITOR 
4eb0 cd 3d 17			call break_point_state  
4eb3				endm  
# End of macro CALLMONITOR
4eb3					endif 
4eb3			 
4eb3 ed 69				out (c), l 
4eb5			 
4eb5					NEXTW 
4eb5 c3 36 20			jp macro_next 
4eb8				endm 
# End of macro NEXTW
4eb8			 
4eb8			 
4eb8			.SPIO: 
4eb8			 
4eb8			if STORAGE_SE 
4eb8				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4eb8 51				db WORD_SYS_CORE+61             
4eb9 c9 4e			dw .SPICEH            
4ebb 07				db 6 + 1 
4ebc .. 00			db "SPICEL",0              
4ec3				endm 
# End of macro CWHEAD
4ec3			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ec3			 
4ec3 cd 90 01				call spi_ce_low 
4ec6			    NEXTW 
4ec6 c3 36 20			jp macro_next 
4ec9				endm 
# End of macro NEXTW
4ec9			 
4ec9			.SPICEH: 
4ec9				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ec9 51				db WORD_SYS_CORE+61             
4eca da 4e			dw .SPIOb            
4ecc 07				db 6 + 1 
4ecd .. 00			db "SPICEH",0              
4ed4				endm 
# End of macro CWHEAD
4ed4			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ed4			 
4ed4 cd 7f 01				call spi_ce_high 
4ed7			    NEXTW 
4ed7 c3 36 20			jp macro_next 
4eda				endm 
# End of macro NEXTW
4eda			 
4eda			 
4eda			.SPIOb: 
4eda			 
4eda				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4eda 51				db WORD_SYS_CORE+61             
4edb f0 4e			dw .SPII            
4edd 05				db 4 + 1 
4ede .. 00			db "SPIO",0              
4ee3				endm 
# End of macro CWHEAD
4ee3			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ee3			 
4ee3					; get port 
4ee3			 
4ee3			 
4ee3					; get byte to send 
4ee3			 
4ee3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ee3 cd c4 1e			call macro_dsp_valuehl 
4ee6				endm 
# End of macro FORTH_DSP_VALUEHL
4ee6			 
4ee6			;		push hl    ; u1  
4ee6			 
4ee6					; destroy value TOS 
4ee6			 
4ee6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ee6 cd 7c 1f			call macro_forth_dsp_pop 
4ee9				endm 
# End of macro FORTH_DSP_POP
4ee9			 
4ee9					; one value on hl get other one back 
4ee9			 
4ee9			;		pop hl   ; u2 - addr 
4ee9			 
4ee9					; TODO Send SPI byte 
4ee9			 
4ee9 7d					ld a, l 
4eea cd b4 00				call spi_send_byte 
4eed			 
4eed					NEXTW 
4eed c3 36 20			jp macro_next 
4ef0				endm 
# End of macro NEXTW
4ef0			 
4ef0			.SPII: 
4ef0				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ef0 52				db WORD_SYS_CORE+62             
4ef1 05 4f			dw .SESEL            
4ef3 06				db 5 + 1 
4ef4 .. 00			db "SPII",0              
4ef9				endm 
# End of macro CWHEAD
4ef9			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ef9			 
4ef9					; TODO Get SPI byte 
4ef9			 
4ef9 cd d5 00				call spi_read_byte 
4efc			 
4efc 26 00				ld h, 0 
4efe 6f					ld l, a 
4eff cd cd 1c				call forth_push_numhl 
4f02			 
4f02					NEXTW 
4f02 c3 36 20			jp macro_next 
4f05				endm 
# End of macro NEXTW
4f05			 
4f05			 
4f05			 
4f05			.SESEL: 
4f05				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f05 66				db WORD_SYS_CORE+82             
4f06 a9 4f			dw .CARTDEV            
4f08 05				db 4 + 1 
4f09 .. 00			db "BANK",0              
4f0e				endm 
# End of macro CWHEAD
4f0e			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f0e					if DEBUG_FORTH_WORDS_KEY 
4f0e						DMARK "BNK" 
4f0e f5				push af  
4f0f 3a 23 4f			ld a, (.dmark)  
4f12 32 b4 fb			ld (debug_mark),a  
4f15 3a 24 4f			ld a, (.dmark+1)  
4f18 32 b5 fb			ld (debug_mark+1),a  
4f1b 3a 25 4f			ld a, (.dmark+2)  
4f1e 32 b6 fb			ld (debug_mark+2),a  
4f21 18 03			jr .pastdmark  
4f23 ..			.dmark: db "BNK"  
4f26 f1			.pastdmark: pop af  
4f27			endm  
# End of macro DMARK
4f27						CALLMONITOR 
4f27 cd 3d 17			call break_point_state  
4f2a				endm  
# End of macro CALLMONITOR
4f2a					endif 
4f2a			 
4f2a 3e ff				ld a, 255 
4f2c 32 c8 f9				ld (spi_cartdev), a 
4f2f			 
4f2f					; get bank 
4f2f			 
4f2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f2f cd c4 1e			call macro_dsp_valuehl 
4f32				endm 
# End of macro FORTH_DSP_VALUEHL
4f32			 
4f32			;		push hl 
4f32			 
4f32					; destroy value TOS 
4f32			 
4f32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f32 cd 7c 1f			call macro_forth_dsp_pop 
4f35				endm 
# End of macro FORTH_DSP_POP
4f35			 
4f35					; one value on hl get other one back 
4f35			 
4f35			;		pop hl 
4f35			 
4f35			 
4f35 0e ff				ld c, SPI_CE_HIGH 
4f37 06 30				ld b, '0'    ; human readable bank number 
4f39			 
4f39 7d					ld a, l 
4f3a			 
4f3a					if DEBUG_FORTH_WORDS 
4f3a						DMARK "BNK" 
4f3a f5				push af  
4f3b 3a 4f 4f			ld a, (.dmark)  
4f3e 32 b4 fb			ld (debug_mark),a  
4f41 3a 50 4f			ld a, (.dmark+1)  
4f44 32 b5 fb			ld (debug_mark+1),a  
4f47 3a 51 4f			ld a, (.dmark+2)  
4f4a 32 b6 fb			ld (debug_mark+2),a  
4f4d 18 03			jr .pastdmark  
4f4f ..			.dmark: db "BNK"  
4f52 f1			.pastdmark: pop af  
4f53			endm  
# End of macro DMARK
4f53						CALLMONITOR 
4f53 cd 3d 17			call break_point_state  
4f56				endm  
# End of macro CALLMONITOR
4f56					endif 
4f56			 
4f56					; active low 
4f56			 
4f56 fe 00				cp 0 
4f58 28 28				jr z, .bset 
4f5a fe 01				cp 1 
4f5c 20 04				jr nz, .b2 
4f5e cb 81				res 0, c 
4f60 06 31				ld b, '1'    ; human readable bank number 
4f62 fe 02		.b2:		cp 2 
4f64 20 04				jr nz, .b3 
4f66 cb 89				res 1, c 
4f68 06 32				ld b, '2'    ; human readable bank number 
4f6a fe 03		.b3:		cp 3 
4f6c 20 04				jr nz, .b4 
4f6e cb 91				res 2, c 
4f70 06 33				ld b, '3'    ; human readable bank number 
4f72 fe 04		.b4:		cp 4 
4f74 20 04				jr nz, .b5 
4f76 cb 99				res 3, c 
4f78 06 34				ld b, '4'    ; human readable bank number 
4f7a fe 05		.b5:		cp 5 
4f7c 20 04				jr nz, .bset 
4f7e cb a1				res 4, c 
4f80 06 35				ld b, '5'    ; human readable bank number 
4f82			 
4f82			.bset: 
4f82 79					ld a, c 
4f83 32 c5 f9				ld (spi_device),a 
4f86 78					ld a, b 
4f87 32 c4 f9				ld (spi_device_id),a 
4f8a					if DEBUG_FORTH_WORDS 
4f8a						DMARK "BN2" 
4f8a f5				push af  
4f8b 3a 9f 4f			ld a, (.dmark)  
4f8e 32 b4 fb			ld (debug_mark),a  
4f91 3a a0 4f			ld a, (.dmark+1)  
4f94 32 b5 fb			ld (debug_mark+1),a  
4f97 3a a1 4f			ld a, (.dmark+2)  
4f9a 32 b6 fb			ld (debug_mark+2),a  
4f9d 18 03			jr .pastdmark  
4f9f ..			.dmark: db "BN2"  
4fa2 f1			.pastdmark: pop af  
4fa3			endm  
# End of macro DMARK
4fa3						CALLMONITOR 
4fa3 cd 3d 17			call break_point_state  
4fa6				endm  
# End of macro CALLMONITOR
4fa6					endif 
4fa6			 
4fa6					NEXTW 
4fa6 c3 36 20			jp macro_next 
4fa9				endm 
# End of macro NEXTW
4fa9			 
4fa9			.CARTDEV: 
4fa9				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fa9 66				db WORD_SYS_CORE+82             
4faa 52 50			dw .ENDDEVICE            
4fac 08				db 7 + 1 
4fad .. 00			db "CARTDEV",0              
4fb5				endm 
# End of macro CWHEAD
4fb5			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fb5					if DEBUG_FORTH_WORDS_KEY 
4fb5						DMARK "CDV" 
4fb5 f5				push af  
4fb6 3a ca 4f			ld a, (.dmark)  
4fb9 32 b4 fb			ld (debug_mark),a  
4fbc 3a cb 4f			ld a, (.dmark+1)  
4fbf 32 b5 fb			ld (debug_mark+1),a  
4fc2 3a cc 4f			ld a, (.dmark+2)  
4fc5 32 b6 fb			ld (debug_mark+2),a  
4fc8 18 03			jr .pastdmark  
4fca ..			.dmark: db "CDV"  
4fcd f1			.pastdmark: pop af  
4fce			endm  
# End of macro DMARK
4fce						CALLMONITOR 
4fce cd 3d 17			call break_point_state  
4fd1				endm  
# End of macro CALLMONITOR
4fd1					endif 
4fd1			 
4fd1					; disable se storage bank selection 
4fd1			 
4fd1 3e ff				ld a, SPI_CE_HIGH		; ce high 
4fd3 32 c5 f9				ld (spi_device), a 
4fd6			 
4fd6					; get bank 
4fd6			 
4fd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fd6 cd c4 1e			call macro_dsp_valuehl 
4fd9				endm 
# End of macro FORTH_DSP_VALUEHL
4fd9			 
4fd9			;		push hl 
4fd9			 
4fd9					; destroy value TOS 
4fd9			 
4fd9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fd9 cd 7c 1f			call macro_forth_dsp_pop 
4fdc				endm 
# End of macro FORTH_DSP_POP
4fdc			 
4fdc					; one value on hl get other one back 
4fdc			 
4fdc			;		pop hl 
4fdc			 
4fdc					; active low 
4fdc			 
4fdc 0e ff				ld c, 255 
4fde			 
4fde 7d					ld a, l 
4fdf					if DEBUG_FORTH_WORDS 
4fdf						DMARK "CDV" 
4fdf f5				push af  
4fe0 3a f4 4f			ld a, (.dmark)  
4fe3 32 b4 fb			ld (debug_mark),a  
4fe6 3a f5 4f			ld a, (.dmark+1)  
4fe9 32 b5 fb			ld (debug_mark+1),a  
4fec 3a f6 4f			ld a, (.dmark+2)  
4fef 32 b6 fb			ld (debug_mark+2),a  
4ff2 18 03			jr .pastdmark  
4ff4 ..			.dmark: db "CDV"  
4ff7 f1			.pastdmark: pop af  
4ff8			endm  
# End of macro DMARK
4ff8						CALLMONITOR 
4ff8 cd 3d 17			call break_point_state  
4ffb				endm  
# End of macro CALLMONITOR
4ffb					endif 
4ffb fe 00				cp 0 
4ffd 28 30				jr z, .cset 
4fff fe 01				cp 1 
5001 20 02				jr nz, .c2 
5003 cb 81				res 0, c 
5005 fe 02		.c2:		cp 2 
5007 20 02				jr nz, .c3 
5009 cb 89				res 1, c 
500b fe 03		.c3:		cp 3 
500d 20 02				jr nz, .c4 
500f cb 91				res 2, c 
5011 fe 04		.c4:		cp 4 
5013 20 02				jr nz, .c5 
5015 cb 99				res 3, c 
5017 fe 05		.c5:		cp 5 
5019 20 02				jr nz, .c6 
501b cb a1				res 4, c 
501d fe 06		.c6:		cp 6 
501f 20 02				jr nz, .c7 
5021 cb a9				res 5, c 
5023 fe 07		.c7:		cp 7 
5025 20 02				jr nz, .c8 
5027 cb b1				res 6, c 
5029 fe 08		.c8:		cp 8 
502b 20 02				jr nz, .cset 
502d cb b9				res 7, c 
502f 79			.cset:		ld a, c 
5030 32 c8 f9				ld (spi_cartdev),a 
5033			 
5033					if DEBUG_FORTH_WORDS 
5033						DMARK "CD2" 
5033 f5				push af  
5034 3a 48 50			ld a, (.dmark)  
5037 32 b4 fb			ld (debug_mark),a  
503a 3a 49 50			ld a, (.dmark+1)  
503d 32 b5 fb			ld (debug_mark+1),a  
5040 3a 4a 50			ld a, (.dmark+2)  
5043 32 b6 fb			ld (debug_mark+2),a  
5046 18 03			jr .pastdmark  
5048 ..			.dmark: db "CD2"  
504b f1			.pastdmark: pop af  
504c			endm  
# End of macro DMARK
504c						CALLMONITOR 
504c cd 3d 17			call break_point_state  
504f				endm  
# End of macro CALLMONITOR
504f					endif 
504f					NEXTW 
504f c3 36 20			jp macro_next 
5052				endm 
# End of macro NEXTW
5052			endif 
5052			 
5052			.ENDDEVICE: 
5052			; eof 
5052			 
# End of file forth_words_device.asm
5052			 
5052			; var handler 
5052			 
5052			 
5052			.VARS: 
5052				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5052 78				db WORD_SYS_CORE+100             
5053 6a 50			dw .V0Q            
5055 04				db 3 + 1 
5056 .. 00			db "V0!",0              
505a				endm 
# End of macro CWHEAD
505a			;| V0! ( u1 -- )  Store value to v0  | DONE 
505a			 
505a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
505a cd c4 1e			call macro_dsp_valuehl 
505d				endm 
# End of macro FORTH_DSP_VALUEHL
505d			 
505d 11 8d f9				ld de, cli_var_array 
5060			 
5060 eb					ex de, hl 
5061 73					ld (hl), e 
5062 23					inc hl 
5063 72					ld (hl), d 
5064			 
5064					; destroy value TOS 
5064			 
5064					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5064 cd 7c 1f			call macro_forth_dsp_pop 
5067				endm 
# End of macro FORTH_DSP_POP
5067			 
5067				       NEXTW 
5067 c3 36 20			jp macro_next 
506a				endm 
# End of macro NEXTW
506a			.V0Q: 
506a				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
506a 79				db WORD_SYS_CORE+101             
506b 7b 50			dw .V1S            
506d 04				db 3 + 1 
506e .. 00			db "V0@",0              
5072				endm 
# End of macro CWHEAD
5072			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5072 2a 8d f9				ld hl, (cli_var_array) 
5075 cd cd 1c				call forth_push_numhl 
5078			 
5078				       NEXTW 
5078 c3 36 20			jp macro_next 
507b				endm 
# End of macro NEXTW
507b			.V1S: 
507b				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
507b 7a				db WORD_SYS_CORE+102             
507c 93 50			dw .V1Q            
507e 04				db 3 + 1 
507f .. 00			db "V1!",0              
5083				endm 
# End of macro CWHEAD
5083			;| V1! ( u1 -- )  Store value to v1 | DONE 
5083					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5083 cd c4 1e			call macro_dsp_valuehl 
5086				endm 
# End of macro FORTH_DSP_VALUEHL
5086			 
5086 11 8f f9				ld de, cli_var_array+2 
5089				 
5089 eb					ex de, hl 
508a 73					ld (hl), e 
508b 23					inc hl 
508c 72					ld (hl), d 
508d			 
508d					; destroy value TOS 
508d			 
508d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
508d cd 7c 1f			call macro_forth_dsp_pop 
5090				endm 
# End of macro FORTH_DSP_POP
5090				       NEXTW 
5090 c3 36 20			jp macro_next 
5093				endm 
# End of macro NEXTW
5093			.V1Q: 
5093				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5093 7b				db WORD_SYS_CORE+103             
5094 a4 50			dw .V2S            
5096 04				db 3 + 1 
5097 .. 00			db "V1@",0              
509b				endm 
# End of macro CWHEAD
509b			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
509b 2a 8f f9				ld hl, (cli_var_array+2) 
509e cd cd 1c				call forth_push_numhl 
50a1				       NEXTW 
50a1 c3 36 20			jp macro_next 
50a4				endm 
# End of macro NEXTW
50a4			.V2S: 
50a4				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50a4 7c				db WORD_SYS_CORE+104             
50a5 bc 50			dw .V2Q            
50a7 04				db 3 + 1 
50a8 .. 00			db "V2!",0              
50ac				endm 
# End of macro CWHEAD
50ac			;| V2! ( u1 -- )  Store value to v2 | DONE 
50ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ac cd c4 1e			call macro_dsp_valuehl 
50af				endm 
# End of macro FORTH_DSP_VALUEHL
50af			 
50af 11 91 f9				ld de, cli_var_array+4 
50b2				 
50b2 eb					ex de, hl 
50b3 73					ld (hl), e 
50b4 23					inc hl 
50b5 72					ld (hl), d 
50b6			 
50b6					; destroy value TOS 
50b6			 
50b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b6 cd 7c 1f			call macro_forth_dsp_pop 
50b9				endm 
# End of macro FORTH_DSP_POP
50b9				       NEXTW 
50b9 c3 36 20			jp macro_next 
50bc				endm 
# End of macro NEXTW
50bc			.V2Q: 
50bc				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50bc 7d				db WORD_SYS_CORE+105             
50bd cd 50			dw .V3S            
50bf 04				db 3 + 1 
50c0 .. 00			db "V2@",0              
50c4				endm 
# End of macro CWHEAD
50c4			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50c4 2a 91 f9				ld hl, (cli_var_array+4) 
50c7 cd cd 1c				call forth_push_numhl 
50ca				       NEXTW 
50ca c3 36 20			jp macro_next 
50cd				endm 
# End of macro NEXTW
50cd			.V3S: 
50cd				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50cd 7c				db WORD_SYS_CORE+104             
50ce e5 50			dw .V3Q            
50d0 04				db 3 + 1 
50d1 .. 00			db "V3!",0              
50d5				endm 
# End of macro CWHEAD
50d5			;| V3! ( u1 -- )  Store value to v3 | DONE 
50d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d5 cd c4 1e			call macro_dsp_valuehl 
50d8				endm 
# End of macro FORTH_DSP_VALUEHL
50d8			 
50d8 11 93 f9				ld de, cli_var_array+6 
50db				 
50db eb					ex de, hl 
50dc 73					ld (hl), e 
50dd 23					inc hl 
50de 72					ld (hl), d 
50df			 
50df					; destroy value TOS 
50df			 
50df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50df cd 7c 1f			call macro_forth_dsp_pop 
50e2				endm 
# End of macro FORTH_DSP_POP
50e2				       NEXTW 
50e2 c3 36 20			jp macro_next 
50e5				endm 
# End of macro NEXTW
50e5			.V3Q: 
50e5				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
50e5 7d				db WORD_SYS_CORE+105             
50e6 f6 50			dw .END            
50e8 04				db 3 + 1 
50e9 .. 00			db "V3@",0              
50ed				endm 
# End of macro CWHEAD
50ed			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
50ed 2a 93 f9				ld hl, (cli_var_array+6) 
50f0 cd cd 1c				call forth_push_numhl 
50f3				       NEXTW 
50f3 c3 36 20			jp macro_next 
50f6				endm 
# End of macro NEXTW
50f6			 
50f6			 
50f6			 
50f6			 
50f6			 
50f6			; end of dict marker 
50f6			 
50f6 00			.END:    db WORD_SYS_END 
50f7 00 00			dw 0 
50f9 00				db 0 
50fa			 
50fa			; use to jp here for user dict words to save on macro expansion  
50fa			 
50fa			user_dict_next: 
50fa				NEXTW 
50fa c3 36 20			jp macro_next 
50fd				endm 
# End of macro NEXTW
50fd			 
50fd			 
50fd			user_exec: 
50fd				;    ld hl, <word code> 
50fd				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
50fd				;    call forthexec 
50fd				;    jp user_dict_next   (NEXT) 
50fd			        ;    <word code bytes> 
50fd eb				ex de, hl 
50fe 2a 9b f2			ld hl,(os_tok_ptr) 
5101				 
5101				FORTH_RSP_NEXT 
5101 cd 74 1c			call macro_forth_rsp_next 
5104				endm 
# End of macro FORTH_RSP_NEXT
5104			 
5104			if DEBUG_FORTH_UWORD 
5104						DMARK "UEX" 
5104 f5				push af  
5105 3a 19 51			ld a, (.dmark)  
5108 32 b4 fb			ld (debug_mark),a  
510b 3a 1a 51			ld a, (.dmark+1)  
510e 32 b5 fb			ld (debug_mark+1),a  
5111 3a 1b 51			ld a, (.dmark+2)  
5114 32 b6 fb			ld (debug_mark+2),a  
5117 18 03			jr .pastdmark  
5119 ..			.dmark: db "UEX"  
511c f1			.pastdmark: pop af  
511d			endm  
# End of macro DMARK
511d				CALLMONITOR 
511d cd 3d 17			call break_point_state  
5120				endm  
# End of macro CALLMONITOR
5120			endif 
5120			 
5120			 
5120			 
5120 eb				ex de, hl 
5121 22 9b f2			ld (os_tok_ptr), hl 
5124				 
5124				; Don't use next - Skips the first word in uword. 
5124			 
5124 c3 c7 20			jp exec1 
5127			;	NEXT 
5127			 
5127			 
5127			; eof 
# End of file forth_wordsv4.asm
5127			endif 
5127			;;;;;;;;;;;;;; Debug code 
5127			 
5127			 
5127			;if DEBUG_FORTH_PARSE 
5127 .. 00		.nowordfound: db "No match",0 
5130 .. 00		.compword:	db "Comparing word ",0 
5140 .. 00		.nextwordat:	db "Next word at",0 
514d .. 00		.charmatch:	db "Char match",0 
5158			;endif 
5158			if DEBUG_FORTH_JP 
5158			.foundword:	db "Word match. Exec..",0 
5158			endif 
5158			;if DEBUG_FORTH_PUSH 
5158 .. 00		.enddict:	db "Dict end. Push.",0 
5168 .. 00		.push_str:	db "Pushing string",0 
5177 .. 00		.push_num:	db "Pushing number",0 
5186 .. 00		.data_sp:	db "SP:",0 
518a .. 00		.wordinhl:	db "Word in HL (2/0):",0 
519c .. 00		.wordinde:	db "Word in DE (3/0):",0 
51ae .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51c0			;endif 
51c0			;if DEBUG_FORTH_MALLOC 
51c0 .. 00		.push_malloc:	db "Malloc address",0 
51cf			;endif 
51cf			 
51cf			 
51cf			 
51cf			; display malloc address and current data stack pointer  
51cf			 
51cf			malloc_error: 
51cf d5				push de 
51d0 f5				push af 
51d1 e5				push hl 
51d2 cd e4 0a			call clear_display 
51d5 11 f7 51			ld de, .mallocerr 
51d8 3e 00			ld a,0 
51da			;	ld de,os_word_scratch 
51da cd f7 0a			call str_at_display 
51dd 3e 11			ld a, display_row_1+17 
51df 11 b4 fb			ld de, debug_mark 
51e2 cd f7 0a			call str_at_display 
51e5 cd 07 0b			call update_display 
51e8				;call break_point_state 
51e8 cd 4e 67			call cin_wait 
51eb			 
51eb 3e 20			ld a, ' ' 
51ed 32 8b ef			ld (os_view_disable), a 
51f0 e1				pop hl 
51f1 f1				pop af 
51f2 d1				pop de	 
51f3				CALLMONITOR 
51f3 cd 3d 17			call break_point_state  
51f6				endm  
# End of macro CALLMONITOR
51f6 c9				ret 
51f7			 
51f7 .. 00		.mallocerr: 	db "Malloc Error",0 
5204			;if DEBUG_FORTH_PUSH 
5204			display_data_sp: 
5204 f5				push af 
5205			 
5205				; see if disabled 
5205			 
5205 3a 8b ef			ld a, (os_view_disable) 
5208 fe 2a			cp '*' 
520a 28 67			jr z, .skipdsp 
520c			 
520c e5				push hl 
520d e5				push hl 
520e e5			push hl 
520f cd e4 0a			call clear_display 
5212 e1			pop hl 
5213 7c				ld a,h 
5214 21 9f f2			ld hl, os_word_scratch 
5217 cd 19 10			call hexout 
521a e1				pop hl 
521b 7d				ld a,l 
521c 21 a1 f2			ld hl, os_word_scratch+2 
521f cd 19 10			call hexout 
5222 21 a3 f2			ld hl, os_word_scratch+4 
5225 3e 00			ld a,0 
5227 77				ld (hl),a 
5228 11 9f f2			ld de,os_word_scratch 
522b 3e 14				ld a, display_row_2 
522d cd f7 0a				call str_at_display 
5230 11 8a 51			ld de, .wordinhl 
5233 3e 00			ld a, display_row_1 
5235			 
5235 cd f7 0a				call str_at_display 
5238 11 b4 fb			ld de, debug_mark 
523b 3e 11			ld a, display_row_1+17 
523d			 
523d cd f7 0a				call str_at_display 
5240			 
5240				; display current data stack pointer 
5240 11 86 51			ld de,.data_sp 
5243 3e 1c				ld a, display_row_2 + 8 
5245 cd f7 0a				call str_at_display 
5248			 
5248 2a 87 f9			ld hl,(cli_data_sp) 
524b e5				push hl 
524c 7c				ld a,h 
524d 21 9f f2			ld hl, os_word_scratch 
5250 cd 19 10			call hexout 
5253 e1				pop hl 
5254 7d				ld a,l 
5255 21 a1 f2			ld hl, os_word_scratch+2 
5258 cd 19 10			call hexout 
525b 21 a3 f2			ld hl, os_word_scratch+4 
525e 3e 00			ld a,0 
5260 77				ld (hl),a 
5261 11 9f f2			ld de,os_word_scratch 
5264 3e 1f				ld a, display_row_2 + 11 
5266 cd f7 0a				call str_at_display 
5269			 
5269			 
5269 cd 07 0b			call update_display 
526c cd 61 0a			call delay1s 
526f cd 61 0a			call delay1s 
5272 e1				pop hl 
5273			.skipdsp: 
5273 f1				pop af 
5274 c9				ret 
5275			 
5275			display_data_malloc: 
5275			 
5275 f5				push af 
5276 e5				push hl 
5277 e5				push hl 
5278 e5			push hl 
5279 cd e4 0a			call clear_display 
527c e1			pop hl 
527d 7c				ld a,h 
527e 21 9f f2			ld hl, os_word_scratch 
5281 cd 19 10			call hexout 
5284 e1				pop hl 
5285 7d				ld a,l 
5286 21 a1 f2			ld hl, os_word_scratch+2 
5289 cd 19 10			call hexout 
528c 21 a3 f2			ld hl, os_word_scratch+4 
528f 3e 00			ld a,0 
5291 77				ld (hl),a 
5292 11 9f f2			ld de,os_word_scratch 
5295 3e 14				ld a, display_row_2 
5297 cd f7 0a				call str_at_display 
529a 11 c0 51			ld de, .push_malloc 
529d 3e 00			ld a, display_row_1 
529f			 
529f cd f7 0a				call str_at_display 
52a2			 
52a2				; display current data stack pointer 
52a2 11 86 51			ld de,.data_sp 
52a5 3e 1c				ld a, display_row_2 + 8 
52a7 cd f7 0a				call str_at_display 
52aa			 
52aa 2a 87 f9			ld hl,(cli_data_sp) 
52ad e5				push hl 
52ae 7c				ld a,h 
52af 21 9f f2			ld hl, os_word_scratch 
52b2 cd 19 10			call hexout 
52b5 e1				pop hl 
52b6 7d				ld a,l 
52b7 21 a1 f2			ld hl, os_word_scratch+2 
52ba cd 19 10			call hexout 
52bd 21 a3 f2			ld hl, os_word_scratch+4 
52c0 3e 00			ld a,0 
52c2 77				ld (hl),a 
52c3 11 9f f2			ld de,os_word_scratch 
52c6 3e 1f				ld a, display_row_2 + 11 
52c8 cd f7 0a				call str_at_display 
52cb			 
52cb cd 07 0b			call update_display 
52ce cd 61 0a			call delay1s 
52d1 cd 61 0a			call delay1s 
52d4 e1				pop hl 
52d5 f1				pop af 
52d6 c9				ret 
52d7			;endif 
52d7			 
52d7			include "forth_autostart.asm" 
52d7			; list of commands to perform at system start up 
52d7			 
52d7			startcmds: 
52d7			;	dw test11 
52d7			;	dw test12 
52d7			;	dw test13 
52d7			;	dw test14 
52d7			;	dw test15 
52d7			;	dw test16 
52d7			;	dw test17 
52d7			;	dw ifthtest1 
52d7			;	dw ifthtest2 
52d7			;	dw ifthtest3 
52d7			;	dw mmtest1 
52d7			;	dw mmtest2 
52d7			;	dw mmtest3 
52d7			;	dw mmtest4 
52d7			;	dw mmtest5 
52d7			;	dw mmtest6 
52d7			;	dw iftest1 
52d7			;	dw iftest2 
52d7			;	dw iftest3 
52d7			;	dw looptest1 
52d7			;	dw looptest2 
52d7			;	dw test1 
52d7			;	dw test2 
52d7			;	dw test3 
52d7			;	dw test4 
52d7			;	dw game2r 
52d7			;	dw game2b1 
52d7			;	dw game2b2 
52d7			 
52d7				; start up words that are actually useful 
52d7			 
52d7 35 53			dw clrstack 
52d9 68 53			dw type 
52db 29 55			dw stest 
52dd 8c 53			dw strncpy 
52df ca 54			dw list 
52e1 ed 53			dw start1 
52e3 ff 53			dw start2 
52e5			;	dw start3 
52e5 12 54			dw start3b 
52e7 6a 54			dw start3c 
52e9			 
52e9				; (unit) testing words 
52e9			 
52e9 a0 55			dw mtesta 
52eb 55 56			dw mtestb 
52ed f8 56			dw mtestc 
52ef ad 57			dw mtestd 
52f1 51 58			dw mteste 
52f3			 
52f3				; demo/game words 
52f3			 
52f3 5d 5f		        dw game3w 
52f5 8b 5f		        dw game3p 
52f7 a9 5f		        dw game3sc 
52f9 da 5f		        dw game3vsi 
52fb 06 60		        dw game3vs 
52fd				 
52fd 50 5d			dw game2b 
52ff be 5d			dw game2bf 
5301 08 5e			dw game2mba 
5303 9e 5e			dw game2mbas 
5305 e0 5e			dw game2mb 
5307			 
5307 11 5a			dw game1 
5309 22 5a			dw game1a 
530b 84 5a			dw game1b 
530d b9 5a			dw game1c 
530f ef 5a			dw game1d 
5311 20 5b			dw game1s 
5313 34 5b			dw game1t 
5315 49 5b			dw game1f 
5317 7d 5b			dw game1z 
5319 c1 5b			dw game1zz 
531b			 
531b 07 59			dw test5 
531d 3f 59			dw test6 
531f 77 59			dw test7 
5321 8b 59			dw test8 
5323 b7 59			dw test9 
5325 cd 59			dw test10 
5327				 
5327 98 5c		        dw ssv5 
5329 7c 5c		        dw ssv4 
532b 60 5c		        dw ssv3 
532d 2a 5c		        dw ssv2 
532f b1 5c		        dw ssv1 
5331 f9 5c		        dw ssv1cpm 
5333			;	dw keyup 
5333			;	dw keydown 
5333			;	dw keyleft 
5333			;	dw keyright 
5333			;	dw 	keyf1 
5333			;	dw keyf2 
5333			;	dw keyf3 
5333			;	dw keyf4 
5333			;	dw keyf5 
5333			;	dw keyf6 
5333			;	dw keyf7 
5333			;	dw keyf8 
5333			;	dw keyf9 
5333			;	dw keyf10 
5333			;	dw keyf11 
5333			;	dw keyf12 
5333			;	dw keytab 
5333			;	dw keycr 
5333			;	dw keyhome 
5333			;	dw keyend 
5333			;	dw keybs 
5333 00 00			db 0, 0	 
5335			 
5335			 
5335			; clear stack  
5335			 
5335 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5368			 
5368			; type ( addr count - ) 
5368 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
538c			 
538c			; some direct memory words 
538c			; strncpy ( len t f -- t ) 
538c			 
538c .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53ed			 
53ed .. 00		start1:     	db ": bpon $0000 bp ;",0 
53ff .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5412			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5412 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
546a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54ca			 
54ca			 
54ca			; a handy word to list items on the stack 
54ca			 
54ca .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5529			 
5529			 
5529			; test stack  
5529			; rnd8 stest 
5529			 
5529 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55a0			 
55a0			; random malloc and free cycles 
55a0			 
55a0 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5655			 
5655			; fixed malloc and free cycles 
5655			 
5655 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56f8			 
56f8			; fixed double string push and drop cycle  
56f8			 
56f8 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57ad			 
57ad			; consistent fixed string push and drop cycle  
57ad			 
57ad .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5851			 
5851 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5907			 
5907			;test1:		db ": aa 1 2 3 ;", 0 
5907			;test2:     	db "111 aa 888 999",0 
5907			;test3:     	db ": bb 77 ;",0 
5907			;test4:     	db "$02 $01 do i . loop bb",0 
5907			 
5907 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
593f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5977 .. 00		test7:     	db ": box hline vline ;",0 
598b .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59b7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
59cd .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
59f2 .. 00		test11:     	db "hello create .",0 
5a01 .. 00		test12:     	db "hello2 create .",0 
5a11			 
5a11			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a11			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a11			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a11			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a11			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a11			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a11			 
5a11			;iftest1:     	db "$0001 IF cls .",0 
5a11			;iftest2:     	db "$0000 IF cls .",0 
5a11			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a11			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a11			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a11			 
5a11			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a11			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a11			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a11			 
5a11			 
5a11			 
5a11			; a small guess the number game 
5a11			 
5a11 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a22 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a84			 
5a84 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ab9 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5aef .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b20 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b34 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b49 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b7d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bc1			 
5bc1			; Using 'ga' save a high score across multiple runs using external storage 
5bc1			 
5bc1 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c2a			 
5c2a			 
5c2a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c2a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c2a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c2a			 
5c2a			; simple screen saver to test code memory reuse to destruction 
5c2a			 
5c2a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c60 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c7c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c98 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cb1 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cf9 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d50			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d50			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d50			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d50			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d50			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d50			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d50			 
5d50			 
5d50			 
5d50			; minesweeper/battleship finding game 
5d50			; draws a game board of random ship/mine positions 
5d50			; user enters coords to see if it hits on 
5d50			; game ends when all are hit 
5d50			; when hit or miss says how many may be in the area 
5d50			 
5d50			; setup the game board and then hide it 
5d50 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dbe .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e08			; prompt for where to target 
5e08 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e9e .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ec3			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ec3 .. 00		game2mbht:      db ": mbckht nop ;",0 
5ed2 .. 00		game2mbms:      db ": mbcms nop ;",0 
5ee0			; TODO how many might be near by 
5ee0 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f5d			 
5f5d			; Game 3 
5f5d			 
5f5d			; Vert scroller ski game - avoid the trees! 
5f5d			 
5f5d			; v0 score (ie turns) 
5f5d			; v1 player pos 
5f5d			; v2 left wall 
5f5d			; v3 right wall 
5f5d			 
5f5d			; Draw side walls randomly 
5f5d			 
5f5d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f8b			 
5f8b			; Draw player 
5f8b .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fa9			 
5fa9			; TODO Get Key 
5fa9			 
5fa9			; TODO Move left right 
5fa9			 
5fa9			; scroll and move walls a bit 
5fa9			 
5fa9 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fda			 
5fda			; main game loop 
5fda			 
5fda .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6006 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6045			 
6045			; key board defs 
6045			 
6045 .. 00		keyup:       db ": keyup $05 ;",0 
6053 .. 00		keydown:       db ": keydown $0a ;",0 
6063 .. 00		keyleft:       db ": keyleft $0b ;",0 
6073 .. 00		keyright:       db ": keyright $0c ;",0 
6084 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6092 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60a0 .. 00		keyf3:       db ": keyf3 $12 ;",0 
60ae .. 00		keyf4:       db ": keyf4 $13 ;",0 
60bc .. 00		keyf5:       db ": keyf5 $14 ;",0 
60ca .. 00		keyf6:       db ": keyf6 $15 ;",0 
60d8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60e6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
60f4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6102 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6111 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6120 .. 00		keyf12:       db ": keyf12 $1b ;",0 
612f			 
612f .. 00		keytab:       db ": keytab $09 ;",0 
613e .. 00		keycr:       db ": keycr $0d ;",0 
614c .. 00		keyhome:       db ": keyhome $0e ;",0 
615c .. 00		keyend:       db ": keyend $0f ;",0 
616b .. 00		keybs:       db ": keybs $08 ;",0 
6179			 
6179			   
6179			 
6179			 
6179			 
6179			; eof 
# End of file forth_autostart.asm
6179			 
6179 .. 00		sprompt1: db "Startup load...",0 
6189 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
619f			 
619f			 
619f			 
619f			 
619f			forth_startup: 
619f 21 d7 52			ld hl, startcmds 
61a2 3e 00			ld a, 0 
61a4 32 c0 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61a7			 
61a7 e5			.start1:	push hl 
61a8 cd e4 0a			call clear_display 
61ab 11 79 61			ld de, sprompt1 
61ae 3e 00		        ld a, display_row_1 
61b0 cd f7 0a			call str_at_display 
61b3 11 89 61			ld de, sprompt2 
61b6 3e 14		        ld a, display_row_2 
61b8 cd f7 0a			call str_at_display 
61bb e1				pop hl 
61bc e5				push hl 
61bd 5e				ld e,(hl) 
61be 23				inc hl 
61bf 56				ld d,(hl) 
61c0 3e 28		        ld a, display_row_3 
61c2 cd f7 0a			call str_at_display 
61c5 cd 07 0b			call update_display 
61c8			 
61c8			 
61c8 3a c0 f3			ld a, (os_last_cmd) 
61cb fe 00			cp 0 
61cd 28 05			jr z, .startprompt 
61cf cd 55 0a			call delay250ms 
61d2 18 24			jr .startdo 
61d4				 
61d4				 
61d4			 
61d4			.startprompt: 
61d4			 
61d4 3e 4f			ld a,display_row_4 + display_cols - 1 
61d6 11 43 1c		        ld de, endprg 
61d9 cd f7 0a			call str_at_display 
61dc cd 07 0b			call update_display 
61df cd 61 0a			call delay1s 
61e2 cd 4e 67			call cin_wait 
61e5						 
61e5 fe 2a			cp '*' 
61e7 28 5e			jr z, .startupend1 
61e9 fe 23			cp '#' 
61eb 20 07			jr nz, .startno 
61ed 3e 01			ld a, 1 
61ef 32 c0 f3			ld (os_last_cmd),a 
61f2 18 04			jr .startdo 
61f4 fe 31		.startno:	cp '1' 
61f6 28 3a			jr z,.startnxt  
61f8			 
61f8				; exec startup line 
61f8			.startdo:	 
61f8 e1				pop hl 
61f9 e5				push hl 
61fa				 
61fa 5e				ld e,(hl) 
61fb 23				inc hl 
61fc 56				ld d,(hl) 
61fd eb				ex de,hl 
61fe			 
61fe e5				push hl 
61ff			 
61ff 3e 00			ld a, 0 
6201				;ld a, FORTH_END_BUFFER 
6201 cd 81 11			call strlent 
6204 23				inc hl   ; include zero term to copy 
6205 06 00			ld b,0 
6207 4d				ld c,l 
6208 e1				pop hl 
6209 11 9a ef			ld de, scratch 
620c ed b0			ldir 
620e			 
620e			 
620e 21 9a ef			ld hl, scratch 
6211 cd 84 20			call forthparse 
6214 cd c4 20			call forthexec 
6217 cd db 1f			call forthexec_cleanup 
621a			 
621a 3e 3c			ld a, display_row_4 
621c 11 e7 19			ld de, endprog 
621f			 
621f cd 07 0b			call update_display		 
6222			 
6222 3a c0 f3			ld a, (os_last_cmd) 
6225 fe 00			cp 0 
6227 20 09			jr nz, .startnxt 
6229 cd 45 1c			call next_page_prompt 
622c cd e4 0a		        call clear_display 
622f cd 07 0b			call update_display		 
6232			 
6232				; move onto next startup line? 
6232			.startnxt: 
6232			 
6232 cd 55 0a			call delay250ms 
6235 e1				pop hl 
6236			 
6236 23				inc hl 
6237 23				inc hl 
6238			 
6238 e5				push hl 
6239 5e				ld e, (hl) 
623a 23				inc hl 
623b 56				ld d, (hl) 
623c e1				pop hl 
623d				; TODO replace 0 test 
623d			 
623d eb				ex de, hl 
623e cd 41 0d			call ishlzero 
6241			;	ld a,e 
6241			;	add d 
6241			;	cp 0    ; any left to do? 
6241 eb				ex de, hl 
6242 c2 a7 61			jp nz, .start1 
6245 18 01			jr .startupend 
6247			 
6247 e1			.startupend1: pop hl 
6248			.startupend: 
6248			 
6248 cd e4 0a			call clear_display 
624b cd 07 0b			call update_display 
624e c9				ret 
624f			 
624f			 
624f			; stack over and underflow checks 
624f			 
624f			; init the words to detect the under/overflow 
624f			 
624f			chk_stk_init: 
624f				; a vague random number to check so we dont get any "lucky" hits 
624f 3e 2d			ld a, 45 
6251 6f				ld l, a 
6252 00				nop 
6253 3e 17			ld a, 23 
6255 67				ld h, a 
6256			 
6256 22 81 ef			ld (chk_word), hl     ; the word we need to check against 
6259			 
6259			;	ld (chk_stund), hl	; stack points.... 
6259 22 fd fb			ld (chk_stovr), hl 
625c 22 85 f9			ld (chk_ret_und), hl 
625f 22 03 f9			ld (chk_ret_ovr), hl 
6262 22 01 f7			ld (chk_loop_ovr), hl 
6265 22 ff f4			ld (chk_data_ovr), hl 
6268 c9				ret 
6269				 
6269			check_stacks: 
6269				; check all stack words 
6269			 
6269 e5				push hl 
626a d5				push de 
626b			 
626b			;	ld de,(chk_word) 
626b			;	ld hl, (chk_stund)	; stack points.... 
626b			;	if DEBUG_STK_FAULT 
626b			;		DMARK "FAa" 
626b			;		CALLMONITOR 
626b			;	endif 
626b			;	call cmp16 
626b			;	jp z, .chk_faulta 
626b			; 
626b			;	ld de, sfaultsu 
626b			;	jp .chk_fault 
626b			 
626b 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
626e ed 5b 81 ef		ld de,(chk_word) 
6272				if DEBUG_STK_FAULT 
6272					DMARK "FAb" 
6272					CALLMONITOR 
6272				endif 
6272 cd 36 0d			call cmp16 
6275 28 06			jr z, .chk_fault1 
6277 11 18 63			ld de, sfaultso 
627a c3 cc 62			jp .chk_fault 
627d			.chk_fault1:  
627d 2a 85 f9			ld hl, (chk_ret_und) 
6280 ed 5b 81 ef		ld de,(chk_word) 
6284				if DEBUG_STK_FAULT 
6284					DMARK "FAU" 
6284					CALLMONITOR 
6284				endif 
6284 cd 36 0d			call cmp16 
6287 ca 90 62			jp z, .chk_fault2 
628a 11 28 63			ld de, sfaultru 
628d c3 cc 62			jp .chk_fault 
6290			.chk_fault2:  
6290 2a 03 f9			ld hl, (chk_ret_ovr) 
6293 ed 5b 81 ef		ld de,(chk_word) 
6297				if DEBUG_STK_FAULT 
6297					DMARK "FA1" 
6297					CALLMONITOR 
6297				endif 
6297 cd 36 0d			call cmp16 
629a ca a3 62			jp z, .chk_fault3 
629d 11 36 63			ld de, sfaultro 
62a0 c3 cc 62			jp .chk_fault 
62a3			.chk_fault3:  
62a3 2a 01 f7			ld hl, (chk_loop_ovr) 
62a6 ed 5b 81 ef		ld de,(chk_word) 
62aa				if DEBUG_STK_FAULT 
62aa					DMARK "FA2" 
62aa					CALLMONITOR 
62aa				endif 
62aa cd 36 0d			call cmp16 
62ad ca b6 62			jp z, .chk_fault4 
62b0 11 50 63			ld de, sfaultlo 
62b3 c3 cc 62			jp .chk_fault 
62b6			.chk_fault4:  
62b6 2a ff f4			ld hl, (chk_data_ovr) 
62b9 ed 5b 81 ef		ld de,(chk_word) 
62bd				if DEBUG_STK_FAULT 
62bd					DMARK "FA3" 
62bd					CALLMONITOR 
62bd				endif 
62bd cd 36 0d			call cmp16 
62c0 ca c9 62			jp z, .chk_fault5 
62c3 11 6a 63			ld de, sfaultdo 
62c6 c3 cc 62			jp .chk_fault 
62c9			 
62c9			 
62c9			.chk_fault5:  
62c9 d1				pop de 
62ca e1				pop hl 
62cb			 
62cb c9				ret 
62cc			 
62cc cd e4 0a		.chk_fault: 	call clear_display 
62cf 3e 14				ld a, display_row_2 
62d1 cd f7 0a				call str_at_display 
62d4 11 fa 62				   ld de, .stackfault 
62d7 3e 00				ld a, display_row_1 
62d9 cd f7 0a				call str_at_display 
62dc 11 b4 fb				    ld de, debug_mark 
62df 3e 11				ld a, display_row_1+17 
62e1 cd f7 0a				call str_at_display 
62e4 cd 07 0b				call update_display 
62e7			 
62e7				; prompt before entering montior for investigating issue 
62e7			 
62e7 3e 3c			ld a, display_row_4 
62e9 11 e7 19			ld de, endprog 
62ec			 
62ec cd 07 0b			call update_display		 
62ef			 
62ef cd 45 1c			call next_page_prompt 
62f2			 
62f2 d1				pop de 
62f3 e1				pop hl 
62f4 cd 3b 1a				call monitor 
62f7 c3 32 19				jp warmstart 
62fa					;jp 0 
62fa					;halt 
62fa			 
62fa			 
62fa			 
62fa .. 00		.stackfault: 	db "Stack fault:",0 
6307			 
6307 .. 00		sfaultsu: 	db	"Stack under flow",0 
6318 .. 00		sfaultso: 	db	"Stack over flow",0 
6328 .. 00		sfaultru:	db "RTS underflow",0 
6336 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6350 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
636a .. 00		sfaultdo:	db "DTS overflow", 0 
6377			 
6377			 
6377			fault_dsp_under: 
6377 11 89 63			ld de, .dsp_under 
637a c3 39 64			jp .show_fault 
637d			 
637d			fault_rsp_under: 
637d 11 97 63			ld de, .rsp_under 
6380 c3 39 64			jp .show_fault 
6383			fault_loop_under: 
6383 11 a5 63			ld de, .loop_under 
6386 c3 39 64			jp .show_fault 
6389			 
6389 .. 00		.dsp_under: db "DSP Underflow",0 
6397 .. 00		.rsp_under: db "RSP Underflow",0 
63a5 .. 00		.loop_under: db "LOOP Underflow",0 
63b4			 
63b4			 
63b4 d5			type_faultn: 	push de 
63b5 e5					push hl 
63b6 cd e4 0a				call clear_display 
63b9 11 e0 63				   ld de, .typefaultn 
63bc 3e 00				ld a, display_row_1 
63be cd f7 0a				call str_at_display 
63c1 11 b4 fb				    ld de, debug_mark 
63c4 3e 11				ld a, display_row_1+17 
63c6 cd f7 0a				call str_at_display 
63c9 cd 07 0b				call update_display 
63cc			 
63cc				; prompt before entering montior for investigating issue 
63cc			 
63cc 3e 3c			ld a, display_row_4 
63ce 11 e7 19			ld de, endprog 
63d1			 
63d1 cd 07 0b			call update_display		 
63d4			 
63d4 cd 45 1c			call next_page_prompt 
63d7			 
63d7 e5					push hl 
63d8 d5					push de 
63d9 cd 3b 1a				call monitor 
63dc c3 32 19				jp warmstart 
63df 76					halt 
63e0			 
63e0			 
63e0 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
63f7			 
63f7 d5			type_faults: 	push de 
63f8 e5					push hl 
63f9 cd e4 0a				call clear_display 
63fc 11 22 64				   ld de, .typefaults 
63ff 3e 00				ld a, display_row_1 
6401 cd f7 0a				call str_at_display 
6404 11 b4 fb				    ld de, debug_mark 
6407 3e 11				ld a, display_row_1+17 
6409 cd f7 0a				call str_at_display 
640c cd 07 0b				call update_display 
640f			 
640f				; prompt before entering montior for investigating issue 
640f			 
640f 3e 3c			ld a, display_row_4 
6411 11 e7 19			ld de, endprog 
6414			 
6414 cd 07 0b			call update_display		 
6417			 
6417 cd 45 1c			call next_page_prompt 
641a			 
641a e1					pop hl 
641b d1					pop de 
641c cd 3b 1a				call monitor 
641f c3 32 19				jp warmstart 
6422			 
6422			 
6422 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6439			 
6439			.show_fault: 	 
6439 d5					push de 
643a cd e4 0a				call clear_display 
643d d1					pop de 
643e 3e 00				ld a, display_row_1 
6440 cd f7 0a				call str_at_display 
6443 11 b4 fb				    ld de, debug_mark 
6446 3e 11				ld a, display_row_1+17 
6448 cd f7 0a				call str_at_display 
644b cd 07 0b				call update_display 
644e			 
644e				; prompt before entering montior for investigating issue 
644e			 
644e 3e 3c			ld a, display_row_4 
6450 11 e7 19			ld de, endprog 
6453			 
6453 cd 07 0b			call update_display		 
6456			 
6456 cd 45 1c			call next_page_prompt 
6459			 
6459 e1					pop hl 
645a d1					pop de 
645b cd 3b 1a				call monitor 
645e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
645e			; TODO Make optional fault restart to cli or warm boot? 
645e					;jp warmstart 
645e c3 8d 19				jp cli 
6461 76					halt 
6462			 
6462			; handle the auto run of code from files in storage 
6462			 
6462			 
6462			if STORAGE_SE 
6462			 
6462 .. 00		sprompt3: db "Loading from start-up file?:",0 
647f .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6490			 
6490			 
6490			forth_autoload: 
6490			 
6490				; load block 0 of store 1 
6490				 
6490 3e fe			ld a, $fe      ; bit 0 clear 
6492 32 c5 f9			ld (spi_device), a 
6495			 
6495 cd b5 03			call storage_get_block_0 
6498			 
6498 3a 00 fa			ld a, (store_page+STORE_0_AUTOFILE) 
649b			 
649b fe 00			cp 0 
649d c8				ret z     ; auto start not enabled 
649e			 
649e cd e4 0a			call clear_display 
64a1			 
64a1				; set bank 
64a1			 
64a1 3a 02 fa				ld a, (store_page+STORE_0_BANKRUN) 
64a4 32 c5 f9				ld (spi_device), a 
64a7			 
64a7				; get file id to load from and get the file name to display 
64a7			 
64a7 3a 03 fa				ld a, (store_page+STORE_0_FILERUN) 
64aa			 
64aa 2e 00				ld l, 0 
64ac 67					ld h, a 
64ad 11 df f9				ld de, store_page 
64b0			 
64b0					if DEBUG_FORTH_WORDS 
64b0						DMARK "ASp" 
64b0 f5				push af  
64b1 3a c5 64			ld a, (.dmark)  
64b4 32 b4 fb			ld (debug_mark),a  
64b7 3a c6 64			ld a, (.dmark+1)  
64ba 32 b5 fb			ld (debug_mark+1),a  
64bd 3a c7 64			ld a, (.dmark+2)  
64c0 32 b6 fb			ld (debug_mark+2),a  
64c3 18 03			jr .pastdmark  
64c5 ..			.dmark: db "ASp"  
64c8 f1			.pastdmark: pop af  
64c9			endm  
# End of macro DMARK
64c9						CALLMONITOR 
64c9 cd 3d 17			call break_point_state  
64cc				endm  
# End of macro CALLMONITOR
64cc					endif 
64cc cd 4f 08				call storage_read 
64cf			 
64cf					if DEBUG_FORTH_WORDS 
64cf						DMARK "ASr" 
64cf f5				push af  
64d0 3a e4 64			ld a, (.dmark)  
64d3 32 b4 fb			ld (debug_mark),a  
64d6 3a e5 64			ld a, (.dmark+1)  
64d9 32 b5 fb			ld (debug_mark+1),a  
64dc 3a e6 64			ld a, (.dmark+2)  
64df 32 b6 fb			ld (debug_mark+2),a  
64e2 18 03			jr .pastdmark  
64e4 ..			.dmark: db "ASr"  
64e7 f1			.pastdmark: pop af  
64e8			endm  
# End of macro DMARK
64e8						CALLMONITOR 
64e8 cd 3d 17			call break_point_state  
64eb				endm  
# End of macro CALLMONITOR
64eb					endif 
64eb			 
64eb cd 41 0d				call ishlzero 
64ee c8					ret z             ; file not found 
64ef			 
64ef 3e 1e				ld a, display_row_2 + 10 
64f1 11 e2 f9				ld de, store_page+3 
64f4 cd f7 0a				call str_at_display 
64f7				 
64f7			; 
64f7			 
64f7 3e 05			ld a, display_row_1+5 
64f9 11 62 64			ld de, sprompt3 
64fc cd f7 0a			call str_at_display 
64ff 3e 37			ld a, display_row_3+15 
6501 11 7f 64			ld de, sprompt4 
6504 cd f7 0a			call str_at_display 
6507			 
6507 cd 07 0b			call update_display 
650a			 
650a cd 4e 67			call cin_wait 
650d fe 6e			cp 'n' 
650f c8				ret z 
6510 fe 4e			cp 'N' 
6512 c8				ret z 
6513			 
6513 cd 61 0a			call delay1s 
6516			 
6516 3a e1 f9			ld a, (store_page+2) 
6519 32 d5 f9			ld (store_openmaxext), a    ; save count of ext 
651c 3e 01			ld a, 1  
651e 32 d6 f9			ld (store_openext), a    ; save count of ext 
6521			 
6521			.autof:  
6521 6f				ld l , a 
6522				 
6522 3a df f9			ld a, (store_page) 
6525 67				ld h, a	 
6526 11 df f9			ld de, store_page 
6529					if DEBUG_FORTH_WORDS 
6529						DMARK "ASl" 
6529 f5				push af  
652a 3a 3e 65			ld a, (.dmark)  
652d 32 b4 fb			ld (debug_mark),a  
6530 3a 3f 65			ld a, (.dmark+1)  
6533 32 b5 fb			ld (debug_mark+1),a  
6536 3a 40 65			ld a, (.dmark+2)  
6539 32 b6 fb			ld (debug_mark+2),a  
653c 18 03			jr .pastdmark  
653e ..			.dmark: db "ASl"  
6541 f1			.pastdmark: pop af  
6542			endm  
# End of macro DMARK
6542						CALLMONITOR 
6542 cd 3d 17			call break_point_state  
6545				endm  
# End of macro CALLMONITOR
6545					endif 
6545 cd 4f 08				call storage_read 
6548 cd 41 0d			call ishlzero 
654b c8				ret z 
654c			;	jr z, .autoend 
654c			 
654c					if DEBUG_FORTH_WORDS 
654c						DMARK "ASc" 
654c f5				push af  
654d 3a 61 65			ld a, (.dmark)  
6550 32 b4 fb			ld (debug_mark),a  
6553 3a 62 65			ld a, (.dmark+1)  
6556 32 b5 fb			ld (debug_mark+1),a  
6559 3a 63 65			ld a, (.dmark+2)  
655c 32 b6 fb			ld (debug_mark+2),a  
655f 18 03			jr .pastdmark  
6561 ..			.dmark: db "ASc"  
6564 f1			.pastdmark: pop af  
6565			endm  
# End of macro DMARK
6565						CALLMONITOR 
6565 cd 3d 17			call break_point_state  
6568				endm  
# End of macro CALLMONITOR
6568					endif 
6568 11 e1 f9			ld de, store_page+2 
656b 3e 3c			ld a, display_row_4 
656d cd f7 0a			call str_at_display 
6570			 
6570 cd 07 0b			call update_display 
6573 cd 55 0a			call delay250ms 
6576			 
6576			 
6576			 
6576 21 e1 f9			ld hl, store_page+2 
6579 cd 84 20			call forthparse 
657c cd c4 20			call forthexec 
657f cd db 1f			call forthexec_cleanup 
6582			 
6582				 
6582 3a d6 f9			ld a, (store_openext) 
6585 3c				inc a 
6586 32 d6 f9			ld (store_openext), a    ; save count of ext 
6589			 
6589 18 96			jr .autof 
658b			;.autofdone: 
658b			; 
658b			;		if DEBUG_FORTH_WORDS 
658b			;			DMARK "ASx" 
658b			;			CALLMONITOR 
658b			;		endif 
658b			;;	call clear_display 
658b			;	ret 
658b			 
658b			 
658b			 
658b			endif 
658b			 
658b			 
658b			; eof 
# End of file forth_kernel.asm
658b			;include "nascombasic.asm" 
658b			 
658b			 
658b			; find out where the code ends if loaded into RAM (for SC114) 
658b			;endofcode:  
658b			;	nop 
658b			 
658b			 
658b			; eof 
658b			 
# End of file main.asm
658b			include "firmware_lcd_4x20.asm" 
658b			; **********************************************************************  
658b			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
658b			; **********************************************************************  
658b			;  
658b			; **  Written as a Small Computer Monitor App  
658b			; **  www.scc.me.uk  
658b			;  
658b			; History  
658b			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
658b			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
658b			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
658b			;  
658b			; **********************************************************************  
658b			;  
658b			; This program is an example of one of the methods of interfacing an   
658b			; alphanumeric LCD module.   
658b			;  
658b			; In this example the display is connected to either a Z80 PIO or a   
658b			; simple 8-bit output port.   
658b			;  
658b			; This interfacing method uses 4-bit data mode and uses time delays  
658b			; rather than polling the display's ready status. As a result the   
658b			; interface only requires 6 simple output lines:  
658b			;   Output bit 0 = not used  
658b			;   Output bit 1 = not used  
658b			;   Output bit 2 = RS         High = data, Low = instruction  
658b			;   Output bit 3 = E          Active high  
658b			;   Output bit 4 = DB4  
658b			;   Output bit 5 = DB5  
658b			;   Output bit 6 = DB6  
658b			;   Output bit 7 = DB7  
658b			; Display's R/W is connected to 0v so it is always in write mode  
658b			;  
658b			; This set up should work with any system supporting the RC2014 bus  
658b			  
658b			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
658b			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
658b			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
658b			;  
658b			; **********************************************************************  
658b			  
658b			; **********************************************************************  
658b			; **  Constants  
658b			; **********************************************************************  
658b			; LCD constants required by LCD support module  
658b			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
658b			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
658b			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
658b			kLCDWidth:  EQU display_cols             ;Width in characters  
658b			  
658b			; **********************************************************************  
658b			; **  Code library usage  
658b			; **********************************************************************  
658b			  
658b			; send character to current cursor position  
658b			; wraps and/or scrolls screen automatically  
658b			  
658b			  
658b			lcd_init:  
658b			  
658b			; SCMonAPI functions used  
658b			  
658b			; Alphanumeric LCD functions used  
658b			; no need to specify specific functions for this module  
658b			  
658b 3e cf		            LD   A, 11001111b  
658d d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
658f 3e 00		            LD   A, 00000000b  
6591 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6593			  
6593			; Initialise alphanumeric LCD module  
6593 cd 0c 66		            CALL fLCD_Init      ;Initialise LCD module  
6596			  
6596 c9				ret  
6597			  
6597			;  
6597			;;  
6597			; lcd functions  
6597			;  
6597			;  
6597			  
6597			; what is at cursor position   
6597			  
6597			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6597			;		call curptr  
6597			;		ret  
6597			  
6597			  
6597			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6597			  
6597			curptr:  
6597 c5				push bc  
6598 21 4a fb			ld hl, display_fb0  
659b			cpr:	  
659b				; loop for cursor whole row  
659b 0e 14			ld c, display_cols  
659d 23			cpr1:	inc hl  
659e 0d				dec c  
659f 20 fc			jr nz, cpr1  
65a1 05				dec b  
65a2 20 f7			jr nz, cpr  
65a4			  
65a4				; add col	  
65a4			  
65a4 23			cpr2:	inc hl  
65a5 1d				dec e  
65a6 20 fc			jr nz, cpr2  
65a8			  
65a8 c1				pop bc  
65a9 c9				ret  
65aa				  
65aa			  
65aa			  
65aa			  
65aa			  
65aa			; write the frame buffer given in hl to hardware   
65aa 22 52 fa		write_display: ld (display_write_tmp), hl 	   
65ad 3e 00			ld a, kLCD_Line1  
65af cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65b2 06 14			ld b, display_cols  
65b4 ed 5b 52 fa		ld de, (display_write_tmp)  
65b8 cd 04 66			call write_len_string  
65bb				  
65bb				  
65bb 2a 52 fa			ld hl, (display_write_tmp)  
65be 11 14 00			ld de, display_cols  
65c1 19				add hl,de  
65c2 22 52 fa			ld (display_write_tmp),hl  
65c5			  
65c5				  
65c5 3e 40			ld a, kLCD_Line2  
65c7 cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65ca 06 14			ld b, display_cols  
65cc ed 5b 52 fa		ld de, (display_write_tmp)  
65d0 cd 04 66			call write_len_string  
65d3				  
65d3 2a 52 fa			ld hl, (display_write_tmp)  
65d6 11 14 00			ld de, display_cols  
65d9 19				add hl,de  
65da 22 52 fa			ld (display_write_tmp),hl  
65dd			  
65dd				  
65dd 3e 14			ld a, kLCD_Line3  
65df cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65e2 06 14			ld b, display_cols  
65e4 ed 5b 52 fa		ld de, (display_write_tmp)  
65e8 cd 04 66			call write_len_string  
65eb				  
65eb 2a 52 fa			ld hl, (display_write_tmp)  
65ee 11 14 00			ld de, display_cols  
65f1 19				add hl,de  
65f2 22 52 fa			ld (display_write_tmp),hl  
65f5			  
65f5				  
65f5 3e 54			ld a, kLCD_Line4  
65f7 cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65fa 06 14			ld b, display_cols  
65fc ed 5b 52 fa		ld de, (display_write_tmp)  
6600 cd 04 66			call write_len_string  
6603 c9					ret  
6604				  
6604				; write out a fixed length string given in b from de  
6604			  
6604 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6605 cd 56 66		            CALL fLCD_Data      ;Write character to display  
6608 13				inc de  
6609 10 f9			djnz write_len_string  
660b c9				ret  
660c			  
660c			; Some other things to do  
660c			;            LD   A, kLCD_Clear ;Display clear  
660c			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
660c			;            LD   A, kLCD_Under ;Display on with underscore cursor  
660c			;            LD   A, kLCD_On     ;Display on with no cursor  
660c			;            ;LD   A, kLCD_Off   ;Display off  
660c			;            CALL fLCD_Inst      ;Send instruction to display  
660c			;  
660c			;  
660c			;            halt  
660c			;  
660c			;  
660c			;MsgHello:   DB  "Hello World!",0  
660c			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
660c			  
660c			; Custom characters 5 pixels wide by 8 pixels high  
660c			; Up to 8 custom characters can be defined  
660c			;BitMaps:      
660c			;; Character 0x00 = Battery icon  
660c			;            DB  01110b  
660c			;            DB  11011b  
660c			;            DB  10001b  
660c			;            DB  10001b  
660c			;            DB  11111b  
660c			;            DB  11111b  
660c			;            DB  11111b  
660c			;            DB  11111b  
660c			;; Character 0x01 = Bluetooth icon  
660c			;            DB  01100b  
660c			;            DB  01010b  
660c			;            DB  11100b  
660c			;            DB  01000b  
660c			;            DB  11100b  
660c			;            DB  01010b  
660c			;            DB  01100b  
660c			;            DB  00000b  
660c			;  
660c			  
660c			  
660c			; **********************************************************************  
660c			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
660c			; **********************************************************************  
660c			;  
660c			; **  Written as a Small Computer Monitor App   
660c			; **  Version 0.1 SCC 2018-05-16  
660c			; **  www.scc.me.uk  
660c			;  
660c			; **********************************************************************  
660c			;  
660c			; This module provides support for alphanumeric LCD modules using with  
660c			; *  HD44780 (or compatible) controller  
660c			; *  5 x 7 pixel fonts  
660c			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
660c			; *  Interface via six digital outputs to the display (see below)  
660c			;  
660c			; LCD module pinout:  
660c			;   1  Vss   0v supply  
660c			;   2  Vdd   5v supply  
660c			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
660c			;   4  RS    High = data, Low = instruction  
660c			;   5  R/W   High = Read, Low = Write  
660c			;   6  E     Enable signal (active high)  
660c			;   7  DB0   Data bit 0  
660c			;   8  DB1   Data bit 1  
660c			;   9  DB2   Data bit 2  
660c			;  10  DB3   Data bit 3  
660c			;  11  DB4   Data bit 4  
660c			;  12  DB5   Data bit 5  
660c			;  13  DB6   Data bit 6  
660c			;  14  DB7   Data bit 7  
660c			;  15  A     Backlight anode (+)  
660c			;  16  K     Backlight cathode (-)  
660c			;  
660c			; This interfacing method uses 4-bit data mode and uses time delays  
660c			; rather than polling the display's ready status. As a result the   
660c			; interface only requires 6 simple output lines:  
660c			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
660c			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
660c			;   LCD DB4 = Microcomputer output port bit 4  
660c			;   LCD DB5 = Microcomputer output port bit 5  
660c			;   LCD DB6 = Microcomputer output port bit 6  
660c			;   LCD DB7 = Microcomputer output port bit 7  
660c			; Display's R/W is connected to 0v so it is always in write mode  
660c			; All 6 connections must be on the same port address <kLCDPrt>  
660c			; This method also allows a decent length of cable from micro to LCD  
660c			;  
660c			; **********************************************************************  
660c			;  
660c			; To include the code for any given function provided by this module,   
660c			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
660c			; the parent source file.  
660c			; For example:  #REQUIRES   uHexPrefix  
660c			;  
660c			; Also #INCLUDE this file at some point after the #REQUIRES statements  
660c			; in the parent source file.  
660c			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
660c			;  
660c			; These are the function names provided by this module:  
660c			; fLCD_Init                     ;Initialise LCD  
660c			; fLCD_Inst                     ;Send instruction to LCD  
660c			; fLCD_Data                     ;Send data byte to LCD  
660c			; fLCD_Pos                      ;Position cursor  
660c			; fLCD_Str                      ;Display string  
660c			; fLCD_Def                      ;Define custom character  
660c			;  
660c			; **********************************************************************  
660c			;  
660c			; Requires SCMonAPI.asm to also be included in the project  
660c			;  
660c			  
660c			  
660c			; **********************************************************************  
660c			; **  Constants  
660c			; **********************************************************************  
660c			  
660c			; Constants that must be defined externally  
660c			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
660c			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
660c			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
660c			;kLCDWidth: EQU 20             ;Width in characters  
660c			  
660c			; general line offsets in any frame buffer  
660c			  
660c			  
660c			display_row_1: equ 0  
660c			display_row_2: equ display_row_1+display_cols  
660c			display_row_3: equ display_row_2 + display_cols  
660c			display_row_4: equ display_row_3 + display_cols  
660c			;display_row_4_eol:   
660c			  
660c			  
660c			; Cursor position values for the start of each line  
660c			kLCD_Line1: EQU 0x00   
660c			kLCD_Line2: EQU 0x40    
660c			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
660c			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
660c			  
660c			; Instructions to send as A register to fLCD_Inst  
660c			kLCD_Clear: EQU 00000001b     ;LCD clear  
660c			kLCD_Off:   EQU 00001000b     ;LCD off  
660c			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
660c			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
660c			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
660c			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
660c			  
660c			; Constants used by this code module  
660c			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
660c			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
660c			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
660c			  
660c			  
660c			  
660c			; **********************************************************************  
660c			; **  LCD support functions  
660c			; **********************************************************************  
660c			  
660c			; Initialise alphanumeric LCD module  
660c			; LCD control register codes:  
660c			;   DL   0 = 4-bit mode        1 = 8-bit mode  
660c			;   N    0 = 1-line mode       1 = 2-line mode  
660c			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
660c			;   D    0 = Display off       1 = Display on  
660c			;   C    0 = Cursor off        1 = Cursor on  
660c			;   B    0 = Blinking off      1 = Blinking on  
660c			;   ID   0 = Decrement mode    1 = Increment mode  
660c			;   SH   0 = Entire shift off  1 = Entire shift on  
660c 3e 28		fLCD_Init:  LD   A, 40  
660e cd c3 66		            CALL LCDDelay       ;Delay 40ms after power up  
6611			; For reliable reset set 8-bit mode - 3 times  
6611 cd ad 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6614 cd ad 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6617 cd ad 66		            CALL WrFn8bit       ;Function = 8-bit mode  
661a			; Set 4-bit mode  
661a cd a9 66		            CALL WrFn4bit       ;Function = 4-bit mode  
661d cd c1 66		            CALL LCDDelay1      ;Delay 37 us or more  
6620			; Function set  
6620 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6622 cd 35 66		            CALL fLCD_Inst      ;2 line, display on  
6625			; Display On/Off control  
6625 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6627 cd 35 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
662a			; Display Clear  
662a 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
662c cd 35 66		            CALL fLCD_Inst      ;Clear display  
662f			; Entry mode  
662f 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6631 cd 35 66		            CALL fLCD_Inst      ;Increment mode, shift off  
6634			; Display module now initialised  
6634 c9			            RET  
6635			; ok to here  
6635			  
6635			; Write instruction to LCD  
6635			;   On entry: A = Instruction byte to be written  
6635			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6635 f5			fLCD_Inst:  PUSH AF  
6636 f5			            PUSH AF  
6637 cd 49 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
663a f1			            POP  AF  
663b 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
663c 17			            RLA  
663d 17			            RLA  
663e 17			            RLA  
663f cd 49 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6642 3e 02		            LD   A, 2  
6644 cd c3 66		            CALL LCDDelay       ;Delay 2 ms to complete   
6647 f1			            POP  AF  
6648 c9			            RET  
6649 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
664b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
664d cb df		            SET  kLCDBitE, A  
664f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6651 cb 9f		            RES  kLCDBitE, A  
6653 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6655 c9			            RET  
6656			  
6656			  
6656			; Write data to LCD  
6656			;   On entry: A = Data byte to be written  
6656			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6656 f5			fLCD_Data:  PUSH AF  
6657 f5			            PUSH AF  
6658 cd 6a 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
665b f1			            POP  AF  
665c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
665d 17			            RLA  
665e 17			            RLA  
665f 17			            RLA  
6660 cd 6a 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6663 3e 96		            LD   A, 150  
6665 3d			Wait:      DEC  A              ;Wait a while to allow data   
6666 20 fd		            JR   NZ, Wait      ;  write to complete  
6668 f1			            POP  AF  
6669 c9			            RET  
666a e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
666c cb d7		            SET  kLCDBitRS, A  
666e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6670 cb df		            SET  kLCDBitE, A  
6672 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6674 cb 9f		            RES  kLCDBitE, A  
6676 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6678 cb 97		            RES  kLCDBitRS, A  
667a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
667c c9			            RET  
667d			  
667d			  
667d			; Position cursor to specified location  
667d			;   On entry: A = Cursor position  
667d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
667d f5			fLCD_Pos:   PUSH AF  
667e f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6680 cd 35 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6683 f1			            POP  AF  
6684 c9			            RET  
6685			  
6685			  
6685			; Output text string to LCD  
6685			;   On entry: DE = Pointer to null terminated text string  
6685			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6685 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6686 b7			            OR   A              ;Null terminator?  
6687 c8			            RET  Z              ;Yes, so finished  
6688 cd 56 66		            CALL fLCD_Data      ;Write character to display  
668b 13			            INC  DE             ;Point to next character  
668c 18 f7		            JR   fLCD_Str       ;Repeat  
668e c9					ret  
668f			  
668f			; Define custom character  
668f			;   On entry: A = Character number (0 to 7)  
668f			;             DE = Pointer to character bitmap data  
668f			;   On exit:  A = Next character number  
668f			;             DE = Next location following bitmap  
668f			;             BC HL IX IY I AF' BC' DE' HL' preserved  
668f			; Character is   
668f c5			fLCD_Def:   PUSH BC  
6690 f5			            PUSH AF  
6691 07			            RLCA                ;Calculate location  
6692 07			            RLCA                ;  for bitmap data  
6693 07			            RLCA                ;  = 8 x CharacterNumber  
6694 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6696 cd 35 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6699 06 00		            LD   B, 0  
669b 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
669c cd 56 66		            CALL fLCD_Data      ;Write byte to display  
669f 13			            INC  DE             ;Point to next byte  
66a0 04			            INC  B              ;Count bytes  
66a1 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
66a3 28 f6		            JR   Z, Loop       ;No, so repeat  
66a5 f1			            POP  AF  
66a6 3c			            INC  A              ;Increment character number  
66a7 c1			            POP  BC  
66a8 c9			            RET  
66a9			  
66a9			  
66a9			; **********************************************************************  
66a9			; **  Private functions  
66a9			; **********************************************************************  
66a9			  
66a9			; Write function to LCD  
66a9			;   On entry: A = Function byte to be written  
66a9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66a9 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
66ab 18 02		            JR   WrFunc  
66ad 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
66af f5			WrFunc:     PUSH AF  
66b0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66b2 cb df		            SET  kLCDBitE, A  
66b4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66b6 cb 9f		            RES  kLCDBitE, A  
66b8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66ba 3e 05		            LD   A, 5  
66bc cd c3 66		            CALL LCDDelay       ;Delay 5 ms to complete  
66bf f1			            POP  AF  
66c0 c9			            RET  
66c1			  
66c1			  
66c1			; Delay in milliseconds  
66c1			;   On entry: A = Number of milliseconds delay  
66c1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66c1 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
66c3 d5			LCDDelay:   PUSH DE  
66c4 5f			            LD   E, A           ;Delay by 'A' ms  
66c5 16 00		            LD   D, 0  
66c7 cd 46 0a		            CALL aDelayInMS  
66ca d1			            POP  DE  
66cb c9			            RET  
66cc			  
66cc			  
66cc			  
66cc			  
66cc			; eof  
66cc			  
# End of file firmware_lcd_4x20.asm
66cc			include "firmware_key_4x4.asm" 
66cc			  
66cc			  
66cc			; bit mask for each scan column and row for teing the matrix  
66cc			  
66cc			; out   
66cc 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
66d0			; in  
66d0 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
66d4			  
66d4			; row/col to character map  
66d4			  
66d4			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
66d4			;    
66d4			  
66d4			; physical key matrix map to face of key  
66d4			  
66d4			  
66d4			;      	1	2	3	A  
66d4			;   	abc”	def&	ghi$	s1  
66d4			;			  
66d4			;	4	5	6	B  
66d4			; 	jkl,	mno.	pqr:	s2  
66d4			;			  
66d4			; 	7	8	9	C  
66d4			;	stu;	vwx@	yz?!	s3  
66d4			;			  
66d4			; 	*	0	#	D  
66d4			; 	shift lck '	Space < >	Enter ( )	s4  
66d4			;       tab bs 		  
66d4			  
66d4			  
66d4			  
66d4			  
66d4			key_init:  
66d4			  
66d4			; SCMonAPI functions used  
66d4			  
66d4			; Alphanumeric LCD functions used  
66d4			; no need to specify specific functions for this module  
66d4			  
66d4			  
66d4 3e cf		            LD   A, 11001111b  
66d6 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
66d8			;            LD   A, 00000000b  
66d8 3e 0f		            LD   A, 00001111b  
66da d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
66dc			  
66dc			  
66dc				; TODO Configure cursor shapes  
66dc			  
66dc				; Load cursor shapes   
66dc 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
66de 11 ee 66		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
66e1 06 02		            LD   B, 2           ;Number of characters to define  
66e3 cd 8f 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
66e6 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
66e8			  
66e8 3e 01				ld a, 1  
66ea 32 4d fa			ld (cursor_shape),a  
66ed c9				ret  
66ee			  
66ee			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
66ee			; Up to 8 custom characters can be defined  
66ee			.cursor_shapes:      
66ee			;; Character 0x00 = Normal  
66ee 1f			            DB  11111b  
66ef 1f			            DB  11111b  
66f0 1f			            DB  11111b  
66f1 1f			            DB  11111b  
66f2 1f			            DB  11111b  
66f3 1f			            DB  11111b  
66f4 1f			            DB  11111b  
66f5 1f			            DB  11111b  
66f6			;; Character 0x01 = Modifier  
66f6 1f			            DB  11111b  
66f7 1b			            DB  11011b  
66f8 1b			            DB  11011b  
66f9 1b			            DB  11011b  
66fa 1b			            DB  11011b  
66fb 1f			            DB  11111b  
66fc 1b			            DB  11011b  
66fd 1f			            DB  11111b  
66fe			  
66fe			  
66fe			  
66fe			  
66fe			; Display custom character 0  
66fe			;            LD   A, kLCD_Line1+14  
66fe			;            CALL fLCD_Pos       ;Position cursor to location in A  
66fe			;            LD   A, 0  
66fe			;            CALL fLCD_Data      ;Write character in A at cursor  
66fe			  
66fe			; Display custom character 1  
66fe			;            LD   A, kLCD_Line2+14  
66fe			;            CALL fLCD_Pos      ;Position cursor to location in A  
66fe			;            LD   A, 1  
66fe			;            CALL fLCD_Data     ;Write character in A at cursor  
66fe			  
66fe			; keyboard scanning   
66fe			  
66fe			  
66fe			; key_rows: equ 4  
66fe			; key_cols: equ 4  
66fe			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
66fe			  
66fe			; key_scanr: equ key_row_bitmask  
66fe			; key_scanc: equ key_col_bitmask  
66fe			  
66fe			; key_char_map: equ key_map  
66fe			  
66fe			  
66fe			  
66fe			; character in from keyboard  
66fe			  
66fe ..			.matrix_to_char: db "D#0*C987B654A321"  
670e			  
670e			  
670e			; map the physical key to a char dependant on state  
670e			  
670e			.key_map_fa:   
670e			  
670e ..					db 'D'  
670f 0d					db KEY_CR    ; cr  
6710 ..					db ' '  
6711 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6712 ..					db 'C'  
6713 ..					db 'y'  
6714 ..					db 'v'  
6715 ..					db 's'  
6716 ..					db 'B'  
6717 ..					db 'p'  
6718 ..					db 'm'  
6719 ..					db 'j'  
671a ..					db 'A'  
671b ..					db 'g'  
671c ..					db 'd'  
671d ..					db 'a'  
671e			  
671e			.key_map_fb:  
671e			  
671e ..					db 'A'  
671f ..					db '+'   
6720 ..					db '<'  
6721 ..					db  "'"    
6722			  
6722 ..					db 'A'  
6723 ..					db 'z'  
6724 ..					db 'w'  
6725 ..					db 't'  
6726 ..					db 'A'  
6727 ..					db 'q'  
6728 ..					db 'n'  
6729 ..					db 'k'  
672a ..					db 'A'  
672b ..					db 'h'  
672c ..					db 'e'  
672d ..			 		db 'b'  
672e			  
672e			.key_map_fc:   
672e			  
672e			  
672e ..					db 'A'  
672f ..					db '-'   
6730 ..					db '>'  
6731 ..					db  '='   	  
6732 ..					db 'A'  
6733 ..					db '?'  
6734 ..					db 'x'  
6735 ..					db 'u'  
6736 ..					db 'A'  
6737 ..					db 'r'  
6738 ..					db 'o'  
6739 ..					db 'l'  
673a ..					db 'A'  
673b ..					db 'i'  
673c ..					db 'f'  
673d ..					db 'c'  
673e			  
673e				  
673e			.key_map_fd:  
673e			  
673e ..					db 'A'  
673f ..					db '/'   
6740 ..					db '%'   
6741 08					db KEY_BS  ; back space  
6742 ..					db 'A'  
6743 ..					db '!'  
6744 ..					db '@'  
6745 ..					db ';'  
6746 ..					db 'A'  
6747 ..					db ':'  
6748 ..					db '.'  
6749 ..					db ','  
674a ..					db 'A'  
674b ..					db '$'  
674c ..					db '&'  
674d ..				 	db '"'  
674e			  
674e					  
674e				  
674e			  
674e			; add cin and cin_wait  
674e			  
674e cd 5f 67		cin_wait: 	call cin  
6751 fe 00			cp 0  
6753 28 f9			jr z, cin_wait   ; block until key press  
6755			  
6755 f5				push af   ; save key pressed  
6756			  
6756 cd 5f 67		.cin_wait1:	call cin  
6759 fe 00			cp 0  
675b 20 f9			jr nz, .cin_wait1  	; wait for key release  
675d			  
675d f1				pop af   ; get key  
675e c9				ret  
675f			  
675f			  
675f cd 70 67		cin: 	call .mtoc  
6762			  
6762				; no key held  
6762 fe 00			cp 0  
6764 c8				ret z  
6765			  
6765				; stop key bounce  
6765			  
6765			;	ld (key_held),a		 ; save it  
6765 47				ld b, a  
6766			  
6766 c5			.cina1:	push bc  
6767 cd 70 67			call .mtoc  
676a c1				pop bc  
676b b8				cp b  
676c 28 f8			jr z, .cina1  
676e 78				ld a,b		  
676f c9				ret  
6770			  
6770			; detect keyboard modifier key press and apply new overlay to the face key held  
6770			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6770			  
6770			;.cin_map_modifier:   
6770			;	ld a, (hl)  
6770			;	and 255  
6770			;	ret NZ		; modifier key not flagged  
6770			;  
6770			;	; get key face  
6770			;  
6770			;	ld b,(key_face_held)  
6770			;  
6770			;	ld b, key_cols * key_rows  
6770			;  
6770			;	push de  
6770			;	pop hl  
6770			;  
6770			;.mmod1: ld a,(hl)   ; get map test  
6770			;	cp b  
6770			;	jr z, .mmod2  
6770			;  
6770			;  
6770			;  
6770			;.mmod2: inc hl    ;   
6770			;  
6770			;	  
6770			;  
6770			;	  
6770			;  
6770			;	ld hl,key_actual_pressed  
6770			;	ld (hl),a,  
6770			;	ret  
6770			  
6770				  
6770			  
6770			; map matrix key held to char on face of key  
6770			  
6770			.mtoc:  
6770			  
6770			  
6770				; TODO optimise the code....  
6770			  
6770			; scan keyboard row 1  
6770 3e 80			ld a, 128  
6772 21 d3 fb			ld hl, keyscan_table  
6775 cd 57 68			call .rowscan  
6778			  
6778				   
6778			  
6778 3e 40			ld a, 64  
677a 21 d7 fb			ld hl, keyscan_table+key_cols  
677d cd 57 68			call .rowscan  
6780			  
6780			  
6780			  
6780			  
6780 3e 20			ld a, 32  
6782 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6785 cd 57 68			call .rowscan  
6788			  
6788			  
6788			  
6788 3e 10			ld a, 16  
678a 21 df fb			ld hl, keyscan_table+(key_cols*3)  
678d cd 57 68			call .rowscan  
6790			  
6790			  
6790				; flag if key D is held down and remove from reporting  
6790 01 3e 67			ld bc, .key_map_fd    
6793 21 d3 fb			ld hl, keyscan_table  
6796 11 c5 fb			ld de, key_fd  
6799 cd e9 67			call .key_shift_hold  
679c fe ff			cp 255  
679e 28 33			jr z, .cinmap  
67a0				; flag if key C is held down and remove from reporting  
67a0 01 2e 67			ld bc, .key_map_fc    
67a3 21 d7 fb			ld hl, keyscan_table+key_cols  
67a6 11 c6 fb			ld de, key_fc  
67a9 cd e9 67			call .key_shift_hold  
67ac fe ff			cp 255  
67ae 28 23			jr z, .cinmap  
67b0				; flag if key B is held down and remove from reporting  
67b0 01 1e 67			ld bc, .key_map_fb    
67b3 21 db fb			ld hl, keyscan_table+(key_cols*2)  
67b6 11 c7 fb			ld de, key_fb  
67b9 cd e9 67			call .key_shift_hold  
67bc fe ff			cp 255  
67be 28 13			jr z, .cinmap  
67c0				; flag if key A is held down and remove from reporting  
67c0 01 0e 67			ld bc, .key_map_fa    
67c3 21 df fb			ld hl, keyscan_table+(key_cols*3)  
67c6 11 c8 fb			ld de, key_fa  
67c9 cd e9 67			call .key_shift_hold  
67cc fe ff			cp 255  
67ce 28 03			jr z, .cinmap  
67d0			  
67d0 11 fe 66			ld de, .matrix_to_char  
67d3			  
67d3			  
67d3			.cinmap:   
67d3				if DEBUG_KEY  
67d3			            LD   A, kLCD_Line4  
67d3			            CALL fLCD_Pos       ;Position cursor to location in A  
67d3					push de  
67d3			            LD   DE, keyscan_table  
67d3			            CALL fLCD_Str       ;Display string pointed to by DE  
67d3					pop de  
67d3				endif  
67d3			  
67d3				; scan key matrix table for any held key  
67d3			  
67d3				; de holds either the default matrix or one selected above  
67d3			  
67d3 21 d3 fb			ld hl, keyscan_table  
67d6 06 10			ld b,key_cols*key_rows  
67d8			  
67d8 7e			.cin1:	ld a,(hl)  
67d9 fe 23			cp '#'  
67db 28 08			jr z, .cinhit  
67dd 23				inc hl  
67de 13				inc de  
67df 05				dec b  
67e0 20 f6			jr nz, .cin1  
67e2				; no key found held  
67e2 3e 00			ld a,0  
67e4 c9				ret  
67e5 d5			.cinhit: push de  
67e6 e1				pop hl  
67e7 7e				ld a,(hl)  
67e8 c9				ret  
67e9			  
67e9			; flag a control key is held   
67e9			; hl is key pin, de is flag indicator  
67e9			  
67e9			.key_shift_hold:  
67e9 c5				push bc  
67ea 3e 01			ld a, 1  
67ec 32 4d fa			ld (cursor_shape),a  
67ef 06 00			ld b, 0  
67f1 7e				ld a, (hl)  
67f2 fe 2e			cp '.'  
67f4 28 0a			jr z, .key_shift1  
67f6 06 ff			ld b, 255  
67f8 3e 2b			ld a, '+'    ; hide key from later scans  
67fa 77				ld (hl),a  
67fb 3e 02			ld a, 2  
67fd 32 4d fa			ld (cursor_shape),a  
6800			.key_shift1:  
6800				; write flag indicator  
6800 78				ld a,b  
6801 12				ld (de),a  
6802			  
6802 d1				pop de    ; de now holds the key map ptr  
6803 c9				ret  
6804			  
6804				  
6804				  
6804			  
6804			  
6804			  
6804			  
6804			  
6804			  
6804			  
6804			  
6804			  
6804			  
6804 c9				ret  
6805			  
6805			;	push hl  
6805			;	push de  
6805			;	push bc  
6805			;	call keyscan  
6805			;	; map key matrix to ascii value of key face  
6805			;  
6805			;	ld hl, key_face_map  
6805			;	ld de, keyscan_table  
6805			;  
6805			;	; get how many keys to look at  
6805			;	ld b, keyscan_table_len  
6805			;	  
6805			;  
6805			;	; at this stage fall out on first key hit  
6805			;	; TODO handle multiple key press  
6805			;  
6805			;map1:	ld a,(hl)  
6805			;	cp '#'  
6805			;	jr z, keyhit  
6805			;	inc hl  
6805			;	inc de  
6805			;	dec b  
6805			;	jr nz, map1  
6805			;nohit:	ld a, 0  
6805			;	jr keydone  
6805			;keyhit: push de  
6805			;	pop hl  
6805			;	ld a,(hl)  
6805			;keydone:  
6805			;	push bc  
6805			;	push de  
6805			; 	push hl  
6805			;	ret   
6805			;  
6805			  
6805			  
6805			  
6805			  
6805			; scan physical key matrix  
6805			  
6805			  
6805			;keyscan:  
6805			;  
6805			;; for each key_row use keyscanr bit mask for out  
6805			;; then read in for keyscanc bitmask  
6805			;; save result of row scan to keyscantable  
6805			;  
6805			;; scan keyboard row 1  
6805			;  
6805			;	ld b, key_rows  
6805			;	ld hl, key_scanr  
6805			;	ld de, keyscan_table  
6805			;  
6805			;rowloop:  
6805			;  
6805			;	ld a,(hl)		; out bit mask to energise keyboard row  
6805			;	call rowscan  
6805			;	inc hl  
6805			;	dec b  
6805			;	jr nz, rowloop  
6805			;  
6805			;	ret  
6805			;  
6805			;  
6805			;; pass a out bitmask, b row number  
6805			;arowscan:   
6805			;	push bc  
6805			;  
6805			;	ld d, b  
6805			;  
6805			;	; calculate buffer location for this row  
6805			;  
6805			;	ld hl, keyscan_table	  
6805			;kbufr:  ld e, key_cols  
6805			;kbufc:	inc hl  
6805			;	dec e  
6805			;	jr nz, kbufc  
6805			;	dec d  
6805			;	jr nz, kbufr  
6805			;  
6805			;	; energise row and read columns  
6805			;  
6805			;	out (portbdata),a  
6805			;	in a,(portbdata)  
6805			;	ld c,a  
6805			;  
6805			;  
6805			;	; save buffer loc  
6805			;  
6805			;	ld (keybufptr), hl  
6805			;  
6805			;	ld hl, key_scanc  
6805			;	ld d, key_cols  
6805			;  
6805			;	; for each column check each bit mask  
6805			;  
6805			;colloop:  
6805			;	  
6805			;  
6805			;	; reset flags for the row   
6805			;  
6805			;	ld b,'.'  
6805			;	and (hl)  
6805			;	jr z, maskskip  
6805			;	ld b,'#'  
6805			;maskskip:  
6805			;	; save  key state  
6805			;	push hl  
6805			;	ld hl, (keybufptr)  
6805			;	ld (hl), b  
6805			;	inc hl  
6805			;	ld (keybufptr), hl  
6805			;  
6805			;	; move to next bit mask  
6805			;	pop hl  
6805			;	inc hl  
6805			;  
6805			;	dec d  
6805			;	jr nz, colloop  
6805			;  
6805			;	ret  
6805			;  
6805			;  
6805			;;  
6805			; lcd functions  
6805			;  
6805			;  
6805			  
6805			;if DEBUG_KEY_MATRIX  
6805			  
6805			; test function to display hardware view of matrix state  
6805			  
6805			matrix:  
6805			  
6805			  
6805			  
6805			; scan keyboard row 1  
6805 3e 80			ld a, 128  
6807 21 f8 fb			ld hl, keyscan_table_row1  
680a cd 57 68			call .rowscan  
680d			  
680d 3e 40			ld a, 64  
680f 21 f3 fb			ld hl, keyscan_table_row2  
6812 cd 57 68			call .rowscan  
6815			  
6815 3e 20			ld a, 32  
6817 21 ee fb			ld hl, keyscan_table_row3  
681a cd 57 68			call .rowscan  
681d			  
681d 3e 10			ld a, 16  
681f 21 e9 fb			ld hl, keyscan_table_row4  
6822 cd 57 68			call .rowscan  
6825			  
6825			; Display text on first line  
6825 3e 00		            LD   A, kLCD_Line1  
6827 cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
682a 11 f8 fb		            LD   DE, keyscan_table_row1  
682d			            ;LD   DE, MsgHello  
682d cd 85 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6830			  
6830			; Display text on second line  
6830 3e 40		            LD   A, kLCD_Line2  
6832 cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6835 11 f3 fb		            LD   DE, keyscan_table_row2  
6838 cd 85 66		            CALL fLCD_Str       ;Display string pointed to by DE  
683b 3e 14		            LD   A, kLCD_Line3  
683d cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6840 11 ee fb		            LD   DE, keyscan_table_row3  
6843 cd 85 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6846 3e 54		            LD   A, kLCD_Line4  
6848 cd 7d 66		            CALL fLCD_Pos       ;Position cursor to location in A  
684b 11 e9 fb		            LD   DE, keyscan_table_row4  
684e cd 85 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6851			  
6851 cd 55 0a			call delay250ms  
6854 c3 05 68			jp matrix  
6857			  
6857			; pass de as row display flags  
6857			.rowscan:   
6857 d3 c1			out (portbdata),a  
6859 db c1			in a,(portbdata)  
685b 4f				ld c,a  
685c				; reset flags for the row   
685c 06 2e			ld b,'.'  
685e e6 01			and 1  
6860 28 02			jr z, .p1on  
6862 06 23			ld b,'#'  
6864			.p1on:  
6864 70				ld (hl), b  
6865 23				inc hl  
6866			  
6866 06 2e			ld b,'.'  
6868 79				ld a,c  
6869 e6 02			and 2  
686b			;	bit 0,a  
686b 28 02			jr z, .p2on  
686d 06 23			ld b,'#'  
686f			.p2on:  
686f 70				ld (hl), b  
6870 23				inc hl  
6871			;  
6871 06 2e			ld b,'.'  
6873 79				ld a,c  
6874 e6 04			and 4  
6876			;;	bit 0,a  
6876 28 02			jr z, .p3on  
6878 06 23			ld b,'#'  
687a			.p3on:  
687a 70				ld (hl), b  
687b 23				inc hl  
687c			;;  
687c 06 2e			ld b,'.'  
687e			;;	bit 0,a  
687e 79				ld a,c  
687f e6 08			and 8  
6881 28 02			jr z, .p4on  
6883 06 23			ld b,'#'  
6885			.p4on:  
6885 70				ld (hl), b  
6886 23				inc hl  
6887			  
6887			; zero term  
6887 06 00			ld b,0  
6889 70				ld (hl), b  
688a			  
688a c9			.rscandone: ret  
688b			  
688b			  
688b			  
688b			;endif  
688b			  
688b			  
688b			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
688b
