# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 6e 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-11 12:33' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			  
801f			debug_mark: equ debug_vector - 4  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 10 ed				ld hl, display_fb1  
8022 22 cc eb				ld (display_fb_active), hl  
8025			  
8025 cd ba 8a				call clear_display  
8028			  
8028 21 ce eb				ld hl, display_fb2  
802b 22 cc eb				ld (display_fb_active), hl  
802e			  
802e cd ba 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 b1 ed				ld hl, display_fb0  
8034 22 cc eb				ld (display_fb_active), hl  
8037			  
8037 cd ba 8a				call clear_display  
803a			  
803a			  
803a cd 7a dc				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd 1c dd			call key_init  
8040 cd aa 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd 9e 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd dd 8a			call update_display  
8049 cd fd 89			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd bf 8a			call fill_display  
8051 cd dd 8a			call update_display  
8054 cd fd 89			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd bf 8a			call fill_display  
805c cd dd 8a			call update_display  
805f cd fd 89			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd bf 8a			call fill_display  
8067 cd dd 8a			call update_display  
806a cd fd 89			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 cc 95			ld de, prom_bootmsg  
8072 cd cd 8a			call str_at_display  
8075 cd dd 8a			call update_display  
8078			  
8078			  
8078 cd fd 89			call delay1s  
807b cd fd 89			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 e1 95			ld de, prom_bootmsg1  
8083 cd cd 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd cd 8a			call str_at_display  
808e			  
808e cd dd 8a			call update_display  
8091 cd fd 89			call delay1s  
8094 cd fd 89			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 6b ee		ld (debug_mark),a  
809c 32 6c ee		ld (debug_mark+1),a  
809f 32 6d ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 6e ee		ld (debug_mark+3),a  
80a7			  
80a7 c9					ret  
80a8			  
80a8			  
80a8			;bootmsg2:	db "Firmware v0.1",0  
80a8			  
80a8			; a 4x20 lcd  
80a8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80a8			  
80a8			;if display_cols == 20  
80a8			;	include "firmware_lcd_4x20.asm"  
80a8			;endif  
80a8			  
80a8			;if display_cols == 40  
80a8			;	include "firmware_lcd_4x40.asm"  
80a8			;endif  
80a8			  
80a8			;  
80a8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80a8			; TODO abstract the bit bang video out interface for dual display  
80a8			; TODO wire video out to tx pin on rc2014 bus  
80a8			  
80a8			; must supply cin, and cin_wait for low level hardware abstraction   
80a8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80a8			; test scancode  
80a8			  
80a8			;;;;;  
80a8			;;;  
80a8			; Moved out to mini and maxi versions  
80a8			;  
80a8			; include "firmware_key_4x4.asm"  
80a8			; using existing 4 wire x 4 resistor array for input  
80a8			;include "firmware_key_4x10.asm"  
80a8			; need to mod the board for 5 rows due to resistor array  
80a8			;include "firmware_key_5x10.asm"  
80a8			  
80a8			; storage hardware interface  
80a8			  
80a8			; use microchip serial eeprom for storage  
80a8			  
80a8			  
80a8			if STORAGE_SE  
80a8				include "firmware_spi.asm"  
80a8				include "firmware_seeprom.asm"  
80a8			else  
80a8			   ; create some stubs for the labels  
80a8 c9			se_readbyte: ret  
80a9 c9			se_writebyte: ret  
80aa c9			storage_init: ret  
80ab			  
80ab			endif  
80ab			  
80ab			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ab			;include "firmware_cf.asm"  
80ab			  
80ab			; load up high level storage hardward abstractions  
80ab			include "firmware_storage.asm"  
80ab			 
80ab			; persisent storage hardware abstraction layer  
80ab			 
80ab			 
80ab			 
80ab			; Block 0 on storage is a config state 
80ab			 
80ab			 
80ab			 
80ab			; TODO add read phy block and write phy block functions 
80ab			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ab			 
80ab			; Abstraction layer  
80ab			 
80ab			; Logocial block size is same size as physical size - using tape concept 
80ab			 
80ab			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ab			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ab			 
80ab			 
80ab			 
80ab			; Filesystem layout (Logical layout) 
80ab			; 
80ab			; Block 0 - Bank config  
80ab			; 
80ab			;      Byte - 0 file id counter 
80ab			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ab			;      Byte - 3-20 zero terminated bank label 
80ab			; 
80ab			; Block 1 > File storage 
80ab			; 
80ab			;      Byte 0 file id    - block 0 file details 
80ab			;      Byte 1 block id - block 0 is file  
80ab			;            Byte 2-15 - File name 
80ab			; 
80ab			;       - to end of block data 
80ab			; 
80ab			 
80ab			; Get ID for the file named in pointer held HL 
80ab			; Returns ID in HL = 255 if no file found 
80ab			 
80ab			storage_getid: 
80ab			 
80ab 22 73 ea			ld (store_tmp1), hl 
80ae			 
80ae				if DEBUG_STORESE 
80ae					DMARK "SGI" 
80ae f5				push af  
80af 3a c3 80			ld a, (.dmark)  
80b2 32 6b ee			ld (debug_mark),a  
80b5 3a c4 80			ld a, (.dmark+1)  
80b8 32 6c ee			ld (debug_mark+1),a  
80bb 3a c5 80			ld a, (.dmark+2)  
80be 32 6d ee			ld (debug_mark+2),a  
80c1 18 03			jr .pastdmark  
80c3 ..			.dmark: db "SGI"  
80c6 f1			.pastdmark: pop af  
80c7			endm  
# End of macro DMARK
80c7					CALLMONITOR 
80c7 cd 6f ee			call debug_vector  
80ca				endm  
# End of macro CALLMONITOR
80ca				endif 
80ca				; get block 0 and set counter for number of files to scan 
80ca			 
80ca cd 35 82			call storage_get_block_0 
80cd			 
80cd 3a 7a ea			ld a, (store_page) 
80d0 47				ld b, a 
80d1			 
80d1				; get extent 0 of each file id 
80d1			 
80d1				if DEBUG_STORESE 
80d1					DMARK "SGc" 
80d1 f5				push af  
80d2 3a e6 80			ld a, (.dmark)  
80d5 32 6b ee			ld (debug_mark),a  
80d8 3a e7 80			ld a, (.dmark+1)  
80db 32 6c ee			ld (debug_mark+1),a  
80de 3a e8 80			ld a, (.dmark+2)  
80e1 32 6d ee			ld (debug_mark+2),a  
80e4 18 03			jr .pastdmark  
80e6 ..			.dmark: db "SGc"  
80e9 f1			.pastdmark: pop af  
80ea			endm  
# End of macro DMARK
80ea					CALLMONITOR 
80ea cd 6f ee			call debug_vector  
80ed				endm  
# End of macro CALLMONITOR
80ed				endif 
80ed 60			.getloop:	ld h, b 
80ee 2e 00				ld l, 0 
80f0 c5					push bc 
80f1			 
80f1 11 7a ea				ld de, store_page 
80f4				if DEBUG_STORESE 
80f4					DMARK "SGr" 
80f4 f5				push af  
80f5 3a 09 81			ld a, (.dmark)  
80f8 32 6b ee			ld (debug_mark),a  
80fb 3a 0a 81			ld a, (.dmark+1)  
80fe 32 6c ee			ld (debug_mark+1),a  
8101 3a 0b 81			ld a, (.dmark+2)  
8104 32 6d ee			ld (debug_mark+2),a  
8107 18 03			jr .pastdmark  
8109 ..			.dmark: db "SGr"  
810c f1			.pastdmark: pop af  
810d			endm  
# End of macro DMARK
810d					CALLMONITOR 
810d cd 6f ee			call debug_vector  
8110				endm  
# End of macro CALLMONITOR
8110				endif 
8110 cd dd 86				call storage_read 
8113 cd 10 8d				call ishlzero 
8116 28 2d				jr z, .gap 
8118					 
8118					; have a file name read. Is it one we want. 
8118			 
8118 2a 73 ea				ld hl, (store_tmp1) 
811b 11 7d ea				ld de, store_page+3   ; file name 
811e			 
811e				if DEBUG_STORESE 
811e					DMARK "SGc" 
811e f5				push af  
811f 3a 33 81			ld a, (.dmark)  
8122 32 6b ee			ld (debug_mark),a  
8125 3a 34 81			ld a, (.dmark+1)  
8128 32 6c ee			ld (debug_mark+1),a  
812b 3a 35 81			ld a, (.dmark+2)  
812e 32 6d ee			ld (debug_mark+2),a  
8131 18 03			jr .pastdmark  
8133 ..			.dmark: db "SGc"  
8136 f1			.pastdmark: pop af  
8137			endm  
# End of macro DMARK
8137					CALLMONITOR 
8137 cd 6f ee			call debug_vector  
813a				endm  
# End of macro CALLMONITOR
813a				endif 
813a cd 85 90				call strcmp 
813d 20 06				jr nz, .gap   ; not this one 
813f			 
813f c1				        pop bc 
8140			 
8140 26 00				ld h, 0 
8142 68					ld l, b 
8143 18 22				jr .getdone 
8145						 
8145			 
8145			 
8145			 
8145			.gap: 
8145				if DEBUG_STORESE 
8145					DMARK "SGg" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 6b ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 6c ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 6d ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SGg"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e					CALLMONITOR 
815e cd 6f ee			call debug_vector  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161			 
8161 c1					pop bc 
8162 10 89				djnz .getloop 
8164 21 ff 00				ld hl, 255 
8167			.getdone: 
8167			 
8167				if DEBUG_STORESE 
8167					DMARK "SGe" 
8167 f5				push af  
8168 3a 7c 81			ld a, (.dmark)  
816b 32 6b ee			ld (debug_mark),a  
816e 3a 7d 81			ld a, (.dmark+1)  
8171 32 6c ee			ld (debug_mark+1),a  
8174 3a 7e 81			ld a, (.dmark+2)  
8177 32 6d ee			ld (debug_mark+2),a  
817a 18 03			jr .pastdmark  
817c ..			.dmark: db "SGe"  
817f f1			.pastdmark: pop af  
8180			endm  
# End of macro DMARK
8180					CALLMONITOR 
8180 cd 6f ee			call debug_vector  
8183				endm  
# End of macro CALLMONITOR
8183				endif 
8183			 
8183 c9				ret 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			; Read Block 
8184			; ---------- 
8184			; 
8184			; With current bank 
8184			;  
8184			; Get block number to read 
8184			; Load physical blocks starting at start block into buffer 
8184			 
8184			; de points to buffer to use 
8184			; hl holds logical block number  
8184			 
8184			storage_read_block: 
8184			 
8184				; TODO bank selection 
8184			 
8184				; for each of the physical blocks read it into the buffer 
8184 06 40			ld b, STORE_BLOCK_PHY 
8186			 
8186				if DEBUG_STORESE 
8186 d5					push de 
8187				endif 
8187				 
8187			.rl1:    
8187			 
8187				; read physical block at hl into de 
8187			        ; increment hl and de to next read position on exit 
8187			 
8187 e5				push hl 
8188 d5				push de	 
8189 c5				push bc 
818a			;	if DEBUG_STORESE 
818a			;		push af 
818a			;		ld a, 'R' 
818a			;		ld (debug_mark),a 
818a			;		pop af 
818a			;		CALLMONITOR 
818a			;	endif 
818a cd a8 80			call se_readbyte 
818d			;	if DEBUG_STORESE 
818d			;		ld a,(spi_portbyte) 
818d			;		ld l, a 
818d			;		push af 
818d			;		ld a, '1' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d c1				pop bc 
818e d1				pop de 
818f e1				pop hl 
8190 12				ld (de),a 
8191 23				inc hl 
8192 13				inc de 
8193			 
8193			;	if DEBUG_STORESE 
8193			;		push af 
8193			;		ld a, 'r' 
8193			;		ld (debug_mark),a 
8193			;		pop af 
8193			;		CALLMONITOR 
8193			;	endif 
8193			 
8193 10 f2			djnz .rl1 
8195			 
8195				if DEBUG_STORESE 
8195					DMARK "SRB" 
8195 f5				push af  
8196 3a aa 81			ld a, (.dmark)  
8199 32 6b ee			ld (debug_mark),a  
819c 3a ab 81			ld a, (.dmark+1)  
819f 32 6c ee			ld (debug_mark+1),a  
81a2 3a ac 81			ld a, (.dmark+2)  
81a5 32 6d ee			ld (debug_mark+2),a  
81a8 18 03			jr .pastdmark  
81aa ..			.dmark: db "SRB"  
81ad f1			.pastdmark: pop af  
81ae			endm  
# End of macro DMARK
81ae d1					pop de 
81af			; 
81af			;		push af 
81af			;		ld a, 'R' 
81af			;		ld (debug_mark),a 
81af			;		pop af 
81af					CALLMONITOR 
81af cd 6f ee			call debug_vector  
81b2				endm  
# End of macro CALLMONITOR
81b2				endif 
81b2 c9				ret	 
81b3				 
81b3			 
81b3			; File Size 
81b3			; --------- 
81b3			; 
81b3			;   hl file id 
81b3			; 
81b3			;  returns in hl the number of blocks 
81b3			 
81b3			storage_file_size: 
81b3 5d				ld e, l 
81b4 16 00			ld d, 0 
81b6 21 40 00			ld hl, STORE_BLOCK_PHY 
81b9					if DEBUG_FORTH_WORDS 
81b9						DMARK "SIZ" 
81b9 f5				push af  
81ba 3a ce 81			ld a, (.dmark)  
81bd 32 6b ee			ld (debug_mark),a  
81c0 3a cf 81			ld a, (.dmark+1)  
81c3 32 6c ee			ld (debug_mark+1),a  
81c6 3a d0 81			ld a, (.dmark+2)  
81c9 32 6d ee			ld (debug_mark+2),a  
81cc 18 03			jr .pastdmark  
81ce ..			.dmark: db "SIZ"  
81d1 f1			.pastdmark: pop af  
81d2			endm  
# End of macro DMARK
81d2						CALLMONITOR 
81d2 cd 6f ee			call debug_vector  
81d5				endm  
# End of macro CALLMONITOR
81d5					endif 
81d5 cd b7 84			call storage_findnextid 
81d8			 
81d8 cd 10 8d			call ishlzero 
81db			;	ld a, l 
81db			;	add h 
81db			;	cp 0 
81db c8				ret z			; block not found so EOF 
81dc			 
81dc 11 7a ea			ld de, store_page 
81df cd 84 81			call storage_read_block 
81e2			 
81e2 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81e5 6f				ld l, a 
81e6 26 00			ld h, 0 
81e8 c9			 	ret 
81e9			 
81e9			 
81e9			; Write Block 
81e9			; ----------- 
81e9			; 
81e9			; With current bank 
81e9			;  
81e9			; Get block number to write 
81e9			; Write physical blocks starting at start block from buffer 
81e9			  
81e9			storage_write_block: 
81e9				; TODO bank selection 
81e9			 
81e9				; for each of the physical blocks read it into the buffer 
81e9 06 40			ld b, STORE_BLOCK_PHY 
81eb			 
81eb				if DEBUG_STORESE 
81eb					DMARK "SWB" 
81eb f5				push af  
81ec 3a 00 82			ld a, (.dmark)  
81ef 32 6b ee			ld (debug_mark),a  
81f2 3a 01 82			ld a, (.dmark+1)  
81f5 32 6c ee			ld (debug_mark+1),a  
81f8 3a 02 82			ld a, (.dmark+2)  
81fb 32 6d ee			ld (debug_mark+2),a  
81fe 18 03			jr .pastdmark  
8200 ..			.dmark: db "SWB"  
8203 f1			.pastdmark: pop af  
8204			endm  
# End of macro DMARK
8204			 
8204					;push af 
8204					;ld a, 'W' 
8204					;ld (debug_mark),a 
8204					;pop af 
8204					CALLMONITOR 
8204 cd 6f ee			call debug_vector  
8207				endm  
# End of macro CALLMONITOR
8207				endif 
8207			 
8207			; might not be working 
8207			;	call se_writepage 
8207			 
8207			;	ret 
8207			; 
8207			 
8207			 
8207			 
8207			.wl1:    
8207			 
8207				; read physical block at hl into de 
8207			        ; increment hl and de to next read position on exit 
8207			 
8207 e5				push hl 
8208 d5				push de	 
8209 c5				push bc 
820a 1a				ld a,(de) 
820b				;if DEBUG_STORESE 
820b			;		push af 
820b			;		ld a, 'W' 
820b			;		ld (debug_mark),a 
820b			;		pop af 
820b			;		CALLMONITOR 
820b			;	endif 
820b cd a9 80			call se_writebyte 
820e			;	call delay250ms 
820e 00				nop 
820f 00				nop 
8210 00				nop 
8211			;	if DEBUG_STORESE 
8211			;		push af 
8211			;		ld a, 'w' 
8211			;		ld (debug_mark),a 
8211			;		pop af 
8211			;		CALLMONITOR 
8211			;	endif 
8211 c1				pop bc 
8212 d1				pop de 
8213 e1				pop hl 
8214 23				inc hl 
8215 13				inc de 
8216			 
8216			 
8216 10 ef			djnz .wl1 
8218			 
8218				if DEBUG_STORESE 
8218					DMARK "SW2" 
8218 f5				push af  
8219 3a 2d 82			ld a, (.dmark)  
821c 32 6b ee			ld (debug_mark),a  
821f 3a 2e 82			ld a, (.dmark+1)  
8222 32 6c ee			ld (debug_mark+1),a  
8225 3a 2f 82			ld a, (.dmark+2)  
8228 32 6d ee			ld (debug_mark+2),a  
822b 18 03			jr .pastdmark  
822d ..			.dmark: db "SW2"  
8230 f1			.pastdmark: pop af  
8231			endm  
# End of macro DMARK
8231			 
8231					;push af 
8231					;ld a, 'W' 
8231					;ld (debug_mark),a 
8231					;pop af 
8231					CALLMONITOR 
8231 cd 6f ee			call debug_vector  
8234				endm  
# End of macro CALLMONITOR
8234				endif 
8234 c9				ret	 
8235			 
8235			; Init bank 
8235			; --------- 
8235			; 
8235			; With current bank 
8235			; 
8235			; Setup block 0 config 
8235			;     Set 0 file id counter 
8235			;     Set formatted byte pattern 
8235			;     Zero out bank label 
8235			;      
8235			; For every logical block write 0-1 byte as null 
8235			 
8235			storage_get_block_0: 
8235			 
8235				; TODO check presence 
8235			 
8235				; get block 0 config 
8235			 
8235 21 00 00			ld hl, 0 
8238 11 7a ea			ld de, store_page 
823b cd 84 81			call storage_read_block 
823e			 
823e				if DEBUG_STORESE 
823e					DMARK "SB0" 
823e f5				push af  
823f 3a 53 82			ld a, (.dmark)  
8242 32 6b ee			ld (debug_mark),a  
8245 3a 54 82			ld a, (.dmark+1)  
8248 32 6c ee			ld (debug_mark+1),a  
824b 3a 55 82			ld a, (.dmark+2)  
824e 32 6d ee			ld (debug_mark+2),a  
8251 18 03			jr .pastdmark  
8253 ..			.dmark: db "SB0"  
8256 f1			.pastdmark: pop af  
8257			endm  
# End of macro DMARK
8257 11 7a ea				ld de, store_page 
825a			;		push af 
825a			;		ld a, 'i' 
825a			;		ld (debug_mark),a 
825a			;		pop af 
825a					CALLMONITOR 
825a cd 6f ee			call debug_vector  
825d				endm  
# End of macro CALLMONITOR
825d				endif 
825d			 
825d				; is this area formatted? 
825d			 
825d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
825d 2a 7b ea			ld hl, (store_page+1) 
8260 3e 80			ld a,0x80 
8262 bd				cp l 
8263 20 22			jr nz, .ininotformatted 
8265				; do a double check 
8265 3e 27			ld a, 0x27 
8267 bc				cp h 
8268 20 1d			jr nz, .ininotformatted 
826a			 
826a				; formatted then 
826a			 
826a				if DEBUG_STORESE 
826a					DMARK "SB1" 
826a f5				push af  
826b 3a 7f 82			ld a, (.dmark)  
826e 32 6b ee			ld (debug_mark),a  
8271 3a 80 82			ld a, (.dmark+1)  
8274 32 6c ee			ld (debug_mark+1),a  
8277 3a 81 82			ld a, (.dmark+2)  
827a 32 6d ee			ld (debug_mark+2),a  
827d 18 03			jr .pastdmark  
827f ..			.dmark: db "SB1"  
8282 f1			.pastdmark: pop af  
8283			endm  
# End of macro DMARK
8283					;push af 
8283					;ld a, 'I' 
8283					;ld (debug_mark),a 
8283					;pop af 
8283					CALLMONITOR 
8283 cd 6f ee			call debug_vector  
8286				endm  
# End of macro CALLMONITOR
8286				endif 
8286 c9				ret 
8287			 
8287			.ininotformatted: 
8287				; bank not formatted so poke various bits to make sure 
8287			 
8287				if DEBUG_STORESE 
8287					DMARK "SB2" 
8287 f5				push af  
8288 3a 9c 82			ld a, (.dmark)  
828b 32 6b ee			ld (debug_mark),a  
828e 3a 9d 82			ld a, (.dmark+1)  
8291 32 6c ee			ld (debug_mark+1),a  
8294 3a 9e 82			ld a, (.dmark+2)  
8297 32 6d ee			ld (debug_mark+2),a  
829a 18 03			jr .pastdmark  
829c ..			.dmark: db "SB2"  
829f f1			.pastdmark: pop af  
82a0			endm  
# End of macro DMARK
82a0					;push af 
82a0					;ld a, 'f' 
82a0					;ld (debug_mark),a 
82a0					;pop af 
82a0					CALLMONITOR 
82a0 cd 6f ee			call debug_vector  
82a3				endm  
# End of macro CALLMONITOR
82a3				endif 
82a3			 
82a3 cd c0 89			call storage_clear_page 
82a6			 
82a6 21 7a ea			ld hl, store_page 
82a9 3e 00			ld a, 0 
82ab				 
82ab 77				ld (hl),a   ; reset file counter 
82ac			 
82ac 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82af 22 7b ea		 	ld (store_page+1), hl	 
82b2			 
82b2				; set default label 
82b2			 
82b2 21 4e 83			ld hl, .defaultbanklabl 
82b5 11 7d ea		 	ld de, store_page+3 
82b8 01 0f 00			ld bc, 15 
82bb ed b0			ldir 
82bd			 
82bd				; Append the current bank id 
82bd 21 86 ea			ld hl, store_page+3+9 
82c0 3a 5f ea			ld a, (spi_device_id) 
82c3 77				ld (hl), a 
82c4			 
82c4				; save default page 0 
82c4			 
82c4 21 00 00			ld hl, 0 
82c7 11 7a ea			ld de, store_page 
82ca				if DEBUG_STORESE 
82ca					DMARK "SB3" 
82ca f5				push af  
82cb 3a df 82			ld a, (.dmark)  
82ce 32 6b ee			ld (debug_mark),a  
82d1 3a e0 82			ld a, (.dmark+1)  
82d4 32 6c ee			ld (debug_mark+1),a  
82d7 3a e1 82			ld a, (.dmark+2)  
82da 32 6d ee			ld (debug_mark+2),a  
82dd 18 03			jr .pastdmark  
82df ..			.dmark: db "SB3"  
82e2 f1			.pastdmark: pop af  
82e3			endm  
# End of macro DMARK
82e3			;		push af 
82e3			;		ld a, 'F' 
82e3			;		ld (debug_mark),a 
82e3			;		pop af 
82e3					CALLMONITOR 
82e3 cd 6f ee			call debug_vector  
82e6				endm  
# End of macro CALLMONITOR
82e6				endif 
82e6 cd e9 81			call storage_write_block 
82e9				if DEBUG_STORESE 
82e9					DMARK "SB4" 
82e9 f5				push af  
82ea 3a fe 82			ld a, (.dmark)  
82ed 32 6b ee			ld (debug_mark),a  
82f0 3a ff 82			ld a, (.dmark+1)  
82f3 32 6c ee			ld (debug_mark+1),a  
82f6 3a 00 83			ld a, (.dmark+2)  
82f9 32 6d ee			ld (debug_mark+2),a  
82fc 18 03			jr .pastdmark  
82fe ..			.dmark: db "SB4"  
8301 f1			.pastdmark: pop af  
8302			endm  
# End of macro DMARK
8302			;		push af 
8302			;		ld a, '>' 
8302			;		ld (debug_mark),a 
8302			;		pop af 
8302					CALLMONITOR 
8302 cd 6f ee			call debug_vector  
8305				endm  
# End of macro CALLMONITOR
8305				endif 
8305			 
8305 00				nop 
8306 00				nop 
8307 00				nop 
8308			 
8308				; now set 0 in every page to mark as a free block 
8308			 
8308 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
830a 21 40 00			ld hl, STORE_BLOCK_PHY 
830d			 
830d 3e 00		.setmark1:   	ld a,0 
830f e5					push hl 
8310 c5					push bc 
8311 cd a9 80				call se_writebyte 
8314 3e 0a			ld a, 10 
8316 cd e2 89			call aDelayInMS 
8319 23				inc hl 
831a cd a9 80				call se_writebyte 
831d 3e 0a			ld a, 10 
831f cd e2 89			call aDelayInMS 
8322 2b				dec hl 
8323 c1					pop bc 
8324 e1					pop hl 
8325 3e 40				ld a, STORE_BLOCK_PHY 
8327 cd e7 8c				call addatohl 
832a 10 e1				djnz .setmark1 
832c			 
832c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
832e 3e 00		.setmark2:   	ld a,0 
8330 e5					push hl 
8331 c5					push bc 
8332 cd a9 80				call se_writebyte 
8335 3e 0a			ld a, 10 
8337 cd e2 89			call aDelayInMS 
833a 23				inc hl 
833b cd a9 80				call se_writebyte 
833e 3e 0a			ld a, 10 
8340 cd e2 89			call aDelayInMS 
8343 2b				dec hl 
8344 c1					pop bc 
8345 e1					pop hl 
8346 3e 40				ld a, STORE_BLOCK_PHY 
8348 cd e7 8c				call addatohl 
834b 10 e1				djnz .setmark2 
834d			 
834d					 
834d			 
834d			 
834d c9				ret 
834e			 
834e			 
834e			 
834e			 
834e .. 00		.defaultbanklabl:   db "BankLabel_",0 
8359			 
8359			 
8359			 
8359			; Label Bank 
8359			; ---------- 
8359			; 
8359			; With current bank 
8359			; Read block 0 
8359			; Set label 
8359			; Write block 0 
8359			 
8359			; label str pointer in hl 
8359			 
8359			storage_label:     
8359			 
8359				if DEBUG_STORESE 
8359					DMARK "LBL" 
8359 f5				push af  
835a 3a 6e 83			ld a, (.dmark)  
835d 32 6b ee			ld (debug_mark),a  
8360 3a 6f 83			ld a, (.dmark+1)  
8363 32 6c ee			ld (debug_mark+1),a  
8366 3a 70 83			ld a, (.dmark+2)  
8369 32 6d ee			ld (debug_mark+2),a  
836c 18 03			jr .pastdmark  
836e ..			.dmark: db "LBL"  
8371 f1			.pastdmark: pop af  
8372			endm  
# End of macro DMARK
8372					CALLMONITOR 
8372 cd 6f ee			call debug_vector  
8375				endm  
# End of macro CALLMONITOR
8375				endif 
8375			 
8375 e5				push hl 
8376			 
8376 cd 35 82			call storage_get_block_0 
8379			 
8379				; set default label 
8379			 
8379 e1				pop hl 
837a			 
837a 11 7d ea		 	ld de, store_page+3 
837d 01 0f 00			ld bc, 15 
8380				if DEBUG_STORESE 
8380					DMARK "LB3" 
8380 f5				push af  
8381 3a 95 83			ld a, (.dmark)  
8384 32 6b ee			ld (debug_mark),a  
8387 3a 96 83			ld a, (.dmark+1)  
838a 32 6c ee			ld (debug_mark+1),a  
838d 3a 97 83			ld a, (.dmark+2)  
8390 32 6d ee			ld (debug_mark+2),a  
8393 18 03			jr .pastdmark  
8395 ..			.dmark: db "LB3"  
8398 f1			.pastdmark: pop af  
8399			endm  
# End of macro DMARK
8399					CALLMONITOR 
8399 cd 6f ee			call debug_vector  
839c				endm  
# End of macro CALLMONITOR
839c				endif 
839c ed b0			ldir 
839e				; save default page 0 
839e			 
839e 21 00 00			ld hl, 0 
83a1 11 7a ea			ld de, store_page 
83a4				if DEBUG_STORESE 
83a4					DMARK "LBW" 
83a4 f5				push af  
83a5 3a b9 83			ld a, (.dmark)  
83a8 32 6b ee			ld (debug_mark),a  
83ab 3a ba 83			ld a, (.dmark+1)  
83ae 32 6c ee			ld (debug_mark+1),a  
83b1 3a bb 83			ld a, (.dmark+2)  
83b4 32 6d ee			ld (debug_mark+2),a  
83b7 18 03			jr .pastdmark  
83b9 ..			.dmark: db "LBW"  
83bc f1			.pastdmark: pop af  
83bd			endm  
# End of macro DMARK
83bd					CALLMONITOR 
83bd cd 6f ee			call debug_vector  
83c0				endm  
# End of macro CALLMONITOR
83c0				endif 
83c0 cd e9 81			call storage_write_block 
83c3			 
83c3 c9				ret 
83c4			 
83c4			 
83c4			 
83c4			; Read Block 0 - Config 
83c4			; --------------------- 
83c4			; 
83c4			; With current bank 
83c4			; Call presence test 
83c4			;    If not present format/init bank  
83c4			; Read block 0  
83c4			;  
83c4			 
83c4			 
83c4			; Dir 
83c4			; --- 
83c4			; 
83c4			; With current bank 
83c4			; Load Block 0 Config 
83c4			; Get max file id number 
83c4			; For each logical block 
83c4			;    Read block read byte 2 
83c4			;      if first block of file 
83c4			;         Display file name 
83c4			;         Display type flags for file 
83c4			;        
83c4			 
83c4			; moving to words as this requires stack control 
83c4			 
83c4			 
83c4			; Delete File 
83c4			; ----------- 
83c4			; 
83c4			; With current bank 
83c4			; 
83c4			; Load Block 0 Config 
83c4			; Get max file id number 
83c4			; For each logical block 
83c4			;    Read block file id 
83c4			;      If first block of file and dont have file id 
83c4			;         if file to delete 
83c4			;         Save file id 
83c4			;         Null file id 
83c4			;         Write this block back 
83c4			;      If file id is one saved 
83c4			;         Null file id 
83c4			;         Write this block back 
83c4			 
83c4			 
83c4			.se_done: 
83c4 e1				pop hl 
83c5 c9				ret 
83c6			 
83c6			storage_erase: 
83c6			 
83c6				; hl contains the file id 
83c6			 
83c6 5d				ld e, l 
83c7 16 00			ld d, 0 
83c9 21 40 00			ld hl, STORE_BLOCK_PHY 
83cc					if DEBUG_FORTH_WORDS 
83cc						DMARK "ERA" 
83cc f5				push af  
83cd 3a e1 83			ld a, (.dmark)  
83d0 32 6b ee			ld (debug_mark),a  
83d3 3a e2 83			ld a, (.dmark+1)  
83d6 32 6c ee			ld (debug_mark+1),a  
83d9 3a e3 83			ld a, (.dmark+2)  
83dc 32 6d ee			ld (debug_mark+2),a  
83df 18 03			jr .pastdmark  
83e1 ..			.dmark: db "ERA"  
83e4 f1			.pastdmark: pop af  
83e5			endm  
# End of macro DMARK
83e5						CALLMONITOR 
83e5 cd 6f ee			call debug_vector  
83e8				endm  
# End of macro CALLMONITOR
83e8					endif 
83e8 cd b7 84			call storage_findnextid 
83eb cd 10 8d			call ishlzero 
83ee c8				ret z 
83ef			 
83ef e5				push hl 
83f0			 
83f0				; TODO check file not found 
83f0			 
83f0 11 7a ea			ld de, store_page 
83f3 cd 84 81			call storage_read_block 
83f6			 
83f6 cd 10 8d			call ishlzero 
83f9 ca c4 83			jp z,.se_done 
83fc			 
83fc					if DEBUG_FORTH_WORDS 
83fc						DMARK "ER1" 
83fc f5				push af  
83fd 3a 11 84			ld a, (.dmark)  
8400 32 6b ee			ld (debug_mark),a  
8403 3a 12 84			ld a, (.dmark+1)  
8406 32 6c ee			ld (debug_mark+1),a  
8409 3a 13 84			ld a, (.dmark+2)  
840c 32 6d ee			ld (debug_mark+2),a  
840f 18 03			jr .pastdmark  
8411 ..			.dmark: db "ER1"  
8414 f1			.pastdmark: pop af  
8415			endm  
# End of macro DMARK
8415						CALLMONITOR 
8415 cd 6f ee			call debug_vector  
8418				endm  
# End of macro CALLMONITOR
8418					endif 
8418 3a 7a ea			ld a, (store_page)	; get file id 
841b 32 6e ea			ld (store_tmpid), a 
841e			 
841e 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8421 32 6d ea			ld (store_tmpext), a 
8424			 
8424				; wipe file header 
8424			 
8424 e1				pop hl 
8425 3e 00			ld a, 0 
8427 32 7a ea			ld (store_page), a 
842a 32 7b ea			ld (store_page+1),a 
842d 11 7a ea			ld de, store_page 
8430					if DEBUG_FORTH_WORDS 
8430						DMARK "ER2" 
8430 f5				push af  
8431 3a 45 84			ld a, (.dmark)  
8434 32 6b ee			ld (debug_mark),a  
8437 3a 46 84			ld a, (.dmark+1)  
843a 32 6c ee			ld (debug_mark+1),a  
843d 3a 47 84			ld a, (.dmark+2)  
8440 32 6d ee			ld (debug_mark+2),a  
8443 18 03			jr .pastdmark  
8445 ..			.dmark: db "ER2"  
8448 f1			.pastdmark: pop af  
8449			endm  
# End of macro DMARK
8449						CALLMONITOR 
8449 cd 6f ee			call debug_vector  
844c				endm  
# End of macro CALLMONITOR
844c					endif 
844c cd e9 81			call storage_write_block 
844f			 
844f			 
844f				; wipe file extents 
844f			 
844f 3a 6d ea			ld a, (store_tmpext) 
8452 47				ld b, a 
8453			 
8453			.eraext:	  
8453 c5				push bc 
8454			 
8454 21 40 00			ld hl, STORE_BLOCK_PHY 
8457 3a 6e ea			ld a,(store_tmpid) 
845a 5f				ld e, a 
845b 50				ld d, b	 
845c					if DEBUG_FORTH_WORDS 
845c						DMARK "ER3" 
845c f5				push af  
845d 3a 71 84			ld a, (.dmark)  
8460 32 6b ee			ld (debug_mark),a  
8463 3a 72 84			ld a, (.dmark+1)  
8466 32 6c ee			ld (debug_mark+1),a  
8469 3a 73 84			ld a, (.dmark+2)  
846c 32 6d ee			ld (debug_mark+2),a  
846f 18 03			jr .pastdmark  
8471 ..			.dmark: db "ER3"  
8474 f1			.pastdmark: pop af  
8475			endm  
# End of macro DMARK
8475						CALLMONITOR 
8475 cd 6f ee			call debug_vector  
8478				endm  
# End of macro CALLMONITOR
8478					endif 
8478 cd b7 84			call storage_findnextid 
847b cd 10 8d			call ishlzero 
847e ca c4 83			jp z,.se_done 
8481			 
8481 e5				push hl 
8482 11 7a ea			ld de, store_page 
8485 cd 84 81			call storage_read_block 
8488			 
8488				; free block	 
8488			 
8488 3e 00			ld a, 0 
848a 32 7a ea			ld (store_page), a 
848d 32 7b ea			ld (store_page+1),a 
8490 11 7a ea			ld de, store_page 
8493 e1				pop hl 
8494					if DEBUG_FORTH_WORDS 
8494						DMARK "ER4" 
8494 f5				push af  
8495 3a a9 84			ld a, (.dmark)  
8498 32 6b ee			ld (debug_mark),a  
849b 3a aa 84			ld a, (.dmark+1)  
849e 32 6c ee			ld (debug_mark+1),a  
84a1 3a ab 84			ld a, (.dmark+2)  
84a4 32 6d ee			ld (debug_mark+2),a  
84a7 18 03			jr .pastdmark  
84a9 ..			.dmark: db "ER4"  
84ac f1			.pastdmark: pop af  
84ad			endm  
# End of macro DMARK
84ad						CALLMONITOR 
84ad cd 6f ee			call debug_vector  
84b0				endm  
# End of macro CALLMONITOR
84b0					endif 
84b0 cd e9 81			call storage_write_block 
84b3			 
84b3 c1				pop bc 
84b4 10 9d			djnz .eraext 
84b6			 
84b6 c9				ret 
84b7			 
84b7			 
84b7			; Find Free Block 
84b7			; --------------- 
84b7			; 
84b7			; With current bank 
84b7			;  
84b7			; From given starting logical block 
84b7			;    Read block  
84b7			;    If no file id 
84b7			;         Return block id 
84b7			 
84b7			 
84b7			; hl starting page number 
84b7			; hl contains free page number or zero if no pages free 
84b7			; e contains the file id to locate 
84b7			; d contains the block number 
84b7			 
84b7			; TODO change to find file id and use zero for free block 
84b7			 
84b7			storage_findnextid: 
84b7			 
84b7				; now locate first 0 page to mark as a free block 
84b7			 
84b7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84b9			;	ld hl, STORE_BLOCK_PHY 
84b9			 
84b9					if DEBUG_FORTH_WORDS 
84b9					DMARK "FNI" 
84b9 f5				push af  
84ba 3a ce 84			ld a, (.dmark)  
84bd 32 6b ee			ld (debug_mark),a  
84c0 3a cf 84			ld a, (.dmark+1)  
84c3 32 6c ee			ld (debug_mark+1),a  
84c6 3a d0 84			ld a, (.dmark+2)  
84c9 32 6d ee			ld (debug_mark+2),a  
84cc 18 03			jr .pastdmark  
84ce ..			.dmark: db "FNI"  
84d1 f1			.pastdmark: pop af  
84d2			endm  
# End of macro DMARK
84d2						CALLMONITOR 
84d2 cd 6f ee			call debug_vector  
84d5				endm  
# End of macro CALLMONITOR
84d5					endif 
84d5			.ff1:   	 
84d5 e5					push hl 
84d6 c5					push bc 
84d7 d5					push de 
84d8 cd a8 80				call se_readbyte 
84db 5f					ld e,a 
84dc 23					inc hl 
84dd cd a8 80				call se_readbyte 
84e0 57					ld d, a 
84e1 e1					pop hl 
84e2 e5					push hl 
84e3 cd 05 8d				call cmp16 
84e6 28 49				jr z, .fffound 
84e8			 
84e8 d1					pop de 
84e9 c1					pop bc 
84ea e1					pop hl 
84eb			 
84eb					; is found? 
84eb					;cp e 
84eb					;ret z 
84eb			 
84eb 3e 40				ld a, STORE_BLOCK_PHY 
84ed cd e7 8c				call addatohl 
84f0 10 e3				djnz .ff1 
84f2			 
84f2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f4			.ff2:   	 
84f4			 
84f4 e5					push hl 
84f5 c5					push bc 
84f6 d5					push de 
84f7 cd a8 80				call se_readbyte 
84fa 5f					ld e,a 
84fb 23					inc hl 
84fc cd a8 80				call se_readbyte 
84ff 57					ld d, a 
8500			 
8500 e1					pop hl 
8501 e5					push hl 
8502 cd 05 8d				call cmp16 
8505 28 2a				jr z, .fffound 
8507			 
8507 d1					pop de 
8508 c1					pop bc 
8509 e1					pop hl 
850a					; is found? 
850a					;cp e 
850a					;ret z 
850a			 
850a 3e 40				ld a, STORE_BLOCK_PHY 
850c cd e7 8c				call addatohl 
850f 10 e3				djnz .ff2 
8511			 
8511			 
8511					if DEBUG_FORTH_WORDS 
8511					DMARK "FN-" 
8511 f5				push af  
8512 3a 26 85			ld a, (.dmark)  
8515 32 6b ee			ld (debug_mark),a  
8518 3a 27 85			ld a, (.dmark+1)  
851b 32 6c ee			ld (debug_mark+1),a  
851e 3a 28 85			ld a, (.dmark+2)  
8521 32 6d ee			ld (debug_mark+2),a  
8524 18 03			jr .pastdmark  
8526 ..			.dmark: db "FN-"  
8529 f1			.pastdmark: pop af  
852a			endm  
# End of macro DMARK
852a					;	push af 
852a					;	ld a, 'n' 
852a					;	ld (debug_mark),a 
852a					;	pop af 
852a						CALLMONITOR 
852a cd 6f ee			call debug_vector  
852d				endm  
# End of macro CALLMONITOR
852d					endif 
852d				; no free marks! 
852d 21 00 00				ld hl, 0 
8530 c9				ret 
8531			.fffound: 
8531				 
8531			 
8531 d1					pop de 
8532 c1					pop bc 
8533 e1					pop hl 
8534					if DEBUG_FORTH_WORDS 
8534					DMARK "FNF" 
8534 f5				push af  
8535 3a 49 85			ld a, (.dmark)  
8538 32 6b ee			ld (debug_mark),a  
853b 3a 4a 85			ld a, (.dmark+1)  
853e 32 6c ee			ld (debug_mark+1),a  
8541 3a 4b 85			ld a, (.dmark+2)  
8544 32 6d ee			ld (debug_mark+2),a  
8547 18 03			jr .pastdmark  
8549 ..			.dmark: db "FNF"  
854c f1			.pastdmark: pop af  
854d			endm  
# End of macro DMARK
854d					;	push af 
854d					;	ld a, 'n' 
854d					;	ld (debug_mark),a 
854d					;	pop af 
854d						CALLMONITOR 
854d cd 6f ee			call debug_vector  
8550				endm  
# End of macro CALLMONITOR
8550					endif 
8550 c9				ret 
8551			 
8551			 
8551			 
8551			; Free Space 
8551			; ---------- 
8551			; 
8551			; With current bank 
8551			; 
8551			; Set block count to zero 
8551			; Starting with first logical block 
8551			;      Find free block  
8551			;      If block id given, increment block count 
8551			; 
8551			;  
8551			 
8551			 
8551			; hl contains count of free blocks 
8551			 
8551			storage_freeblocks: 
8551			 
8551				; now locate first 0 page to mark as a free block 
8551			 
8551 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8553 21 40 00			ld hl, STORE_BLOCK_PHY 
8556 11 00 00			ld de, 0 
8559			 
8559			.fb1:   	 
8559 e5					push hl 
855a c5					push bc 
855b d5					push de 
855c cd a8 80				call se_readbyte 
855f d1					pop de 
8560 c1					pop bc 
8561 e1					pop hl 
8562			 
8562					; is free? 
8562 fe 00				cp 0 
8564 20 01				jr nz, .ff1cont 
8566 13					inc de 
8567			 
8567			.ff1cont: 
8567			 
8567			 
8567 3e 40				ld a, STORE_BLOCK_PHY 
8569 cd e7 8c				call addatohl 
856c 10 eb				djnz .fb1 
856e			 
856e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8570			.fb2:   	 
8570 e5					push hl 
8571 c5					push bc 
8572 d5					push de 
8573 cd a8 80				call se_readbyte 
8576 d1					pop de 
8577 c1					pop bc 
8578 e1					pop hl 
8579			 
8579					; is free? 
8579 fe 00				cp 0 
857b 20 01				jr nz, .ff2cont 
857d 13					inc de 
857e			 
857e			.ff2cont: 
857e			 
857e 3e 40				ld a, STORE_BLOCK_PHY 
8580 cd e7 8c				call addatohl 
8583 10 eb				djnz .fb2 
8585			 
8585 eb				ex de, hl 
8586 c9				ret 
8587			 
8587			; Get File ID 
8587			; ----------- 
8587			; 
8587			; With current bank 
8587			;  
8587			; Load Block 0 Config 
8587			; Get max file id number 
8587			; For each logical block 
8587			;    Read block file id 
8587			;      If first block of file and dont have file id 
8587			;         if file get id and exit 
8587			 
8587			 
8587			 
8587			 
8587			; Create File 
8587			; ----------- 
8587			; 
8587			; With current bank  
8587			; Load Block 0 Config 
8587			; Get max file id number 
8587			; Increment file id number 
8587			; Save Config 
8587			; Find free block 
8587			; Set buffer with file name and file id 
8587			; Write buffer to free block  
8587			 
8587			 
8587			; hl point to file name 
8587			; hl returns file id 
8587			 
8587			; file format: 
8587			; byte 0 - file id 
8587			; byte 1 - extent number 
8587			; byte 2-> data 
8587			 
8587			; format for extent number 0: 
8587			; 
8587			; byte 0 - file id 
8587			; byte 1 - extent 0 
8587			; byte 2 - extent count 
8587			; byte 3 -> file name and meta data 
8587			 
8587			 
8587			storage_create: 
8587				if DEBUG_STORESE 
8587					DMARK "SCR" 
8587 f5				push af  
8588 3a 9c 85			ld a, (.dmark)  
858b 32 6b ee			ld (debug_mark),a  
858e 3a 9d 85			ld a, (.dmark+1)  
8591 32 6c ee			ld (debug_mark+1),a  
8594 3a 9e 85			ld a, (.dmark+2)  
8597 32 6d ee			ld (debug_mark+2),a  
859a 18 03			jr .pastdmark  
859c ..			.dmark: db "SCR"  
859f f1			.pastdmark: pop af  
85a0			endm  
# End of macro DMARK
85a0					CALLMONITOR 
85a0 cd 6f ee			call debug_vector  
85a3				endm  
# End of macro CALLMONITOR
85a3				endif 
85a3			 
85a3 e5				push hl		; save file name pointer 
85a4			 
85a4 cd 35 82			call storage_get_block_0 
85a7			 
85a7 3a 7a ea			ld a,(store_page)	; get current file id 
85aa 3c				inc a 
85ab 32 7a ea			ld (store_page),a 
85ae				 
85ae 32 6e ea			ld (store_tmpid),a			; save id 
85b1			 
85b1 21 00 00			ld hl, 0 
85b4 11 7a ea			ld de, store_page 
85b7				if DEBUG_STORESE 
85b7					DMARK "SCw" 
85b7 f5				push af  
85b8 3a cc 85			ld a, (.dmark)  
85bb 32 6b ee			ld (debug_mark),a  
85be 3a cd 85			ld a, (.dmark+1)  
85c1 32 6c ee			ld (debug_mark+1),a  
85c4 3a ce 85			ld a, (.dmark+2)  
85c7 32 6d ee			ld (debug_mark+2),a  
85ca 18 03			jr .pastdmark  
85cc ..			.dmark: db "SCw"  
85cf f1			.pastdmark: pop af  
85d0			endm  
# End of macro DMARK
85d0					CALLMONITOR 
85d0 cd 6f ee			call debug_vector  
85d3				endm  
# End of macro CALLMONITOR
85d3				endif 
85d3 cd e9 81			call storage_write_block	 ; save update 
85d6			 
85d6				if DEBUG_STORESE 
85d6 11 7a ea				ld de, store_page 
85d9					DMARK "SCC" 
85d9 f5				push af  
85da 3a ee 85			ld a, (.dmark)  
85dd 32 6b ee			ld (debug_mark),a  
85e0 3a ef 85			ld a, (.dmark+1)  
85e3 32 6c ee			ld (debug_mark+1),a  
85e6 3a f0 85			ld a, (.dmark+2)  
85e9 32 6d ee			ld (debug_mark+2),a  
85ec 18 03			jr .pastdmark  
85ee ..			.dmark: db "SCC"  
85f1 f1			.pastdmark: pop af  
85f2			endm  
# End of macro DMARK
85f2					CALLMONITOR 
85f2 cd 6f ee			call debug_vector  
85f5				endm  
# End of macro CALLMONITOR
85f5				endif 
85f5				;  
85f5				 
85f5 21 40 00			ld hl, STORE_BLOCK_PHY 
85f8 11 00 00			ld de, 0 
85fb cd b7 84			call storage_findnextid 
85fe			 
85fe 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
8601			 
8601				; TODO detect 0 = no spare blocks 
8601			 
8601				; hl now contains the free page to use for the file header page 
8601			 
8601				if DEBUG_STORESE 
8601				DMARK "SCF" 
8601 f5				push af  
8602 3a 16 86			ld a, (.dmark)  
8605 32 6b ee			ld (debug_mark),a  
8608 3a 17 86			ld a, (.dmark+1)  
860b 32 6c ee			ld (debug_mark+1),a  
860e 3a 18 86			ld a, (.dmark+2)  
8611 32 6d ee			ld (debug_mark+2),a  
8614 18 03			jr .pastdmark  
8616 ..			.dmark: db "SCF"  
8619 f1			.pastdmark: pop af  
861a			endm  
# End of macro DMARK
861a					CALLMONITOR 
861a cd 6f ee			call debug_vector  
861d				endm  
# End of macro CALLMONITOR
861d				endif 
861d			 
861d 22 65 ea			ld (store_tmppageid), hl 
8620				 
8620 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8623			;	ld a, (store_filecache)			; save to cache 
8623			 
8623 32 7a ea			ld (store_page),a    ; set page id 
8626 3e 00			ld a, 0			 ; extent 0 is file header 
8628 32 7b ea			ld (store_page+1), a   ; set file extent 
862b			 
862b 32 7c ea			ld (store_page+2), a   ; extent count for the file 
862e			 
862e			;	inc hl 		; init block 0 of file 
862e			;	inc hl   		; skip file and extent id 
862e			 ;       ld a, 0 
862e			;	ld (hl),a 
862e			;	ld a, (store_filecache+1)  	; save to cache 
862e			 
862e			;	inc hl    ; file name 
862e				 
862e				 
862e 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8631				if DEBUG_STORESE 
8631					DMARK "SCc" 
8631 f5				push af  
8632 3a 46 86			ld a, (.dmark)  
8635 32 6b ee			ld (debug_mark),a  
8638 3a 47 86			ld a, (.dmark+1)  
863b 32 6c ee			ld (debug_mark+1),a  
863e 3a 48 86			ld a, (.dmark+2)  
8641 32 6d ee			ld (debug_mark+2),a  
8644 18 03			jr .pastdmark  
8646 ..			.dmark: db "SCc"  
8649 f1			.pastdmark: pop af  
864a			endm  
# End of macro DMARK
864a					CALLMONITOR 
864a cd 6f ee			call debug_vector  
864d				endm  
# End of macro CALLMONITOR
864d				endif 
864d e1				pop hl    ; get zero term string 
864e e5				push hl 
864f 3e 00			ld a, 0 
8651 cd 58 90			call strlent 
8654 23				inc hl   ; cover zero term 
8655 06 00			ld b,0 
8657 4d				ld c,l 
8658 e1				pop hl 
8659				;ex de, hl 
8659				if DEBUG_STORESE 
8659					DMARK "SCa" 
8659 f5				push af  
865a 3a 6e 86			ld a, (.dmark)  
865d 32 6b ee			ld (debug_mark),a  
8660 3a 6f 86			ld a, (.dmark+1)  
8663 32 6c ee			ld (debug_mark+1),a  
8666 3a 70 86			ld a, (.dmark+2)  
8669 32 6d ee			ld (debug_mark+2),a  
866c 18 03			jr .pastdmark  
866e ..			.dmark: db "SCa"  
8671 f1			.pastdmark: pop af  
8672			endm  
# End of macro DMARK
8672					;push af 
8672					;ld a, 'a' 
8672					;ld (debug_mark),a 
8672					;pop af 
8672					CALLMONITOR 
8672 cd 6f ee			call debug_vector  
8675				endm  
# End of macro CALLMONITOR
8675				endif 
8675 ed b0			ldir    ; copy zero term string 
8677				if DEBUG_STORESE 
8677					DMARK "SCA" 
8677 f5				push af  
8678 3a 8c 86			ld a, (.dmark)  
867b 32 6b ee			ld (debug_mark),a  
867e 3a 8d 86			ld a, (.dmark+1)  
8681 32 6c ee			ld (debug_mark+1),a  
8684 3a 8e 86			ld a, (.dmark+2)  
8687 32 6d ee			ld (debug_mark+2),a  
868a 18 03			jr .pastdmark  
868c ..			.dmark: db "SCA"  
868f f1			.pastdmark: pop af  
8690			endm  
# End of macro DMARK
8690					CALLMONITOR 
8690 cd 6f ee			call debug_vector  
8693				endm  
# End of macro CALLMONITOR
8693				endif 
8693			 
8693				; write file header page 
8693			 
8693 2a 65 ea			ld hl,(store_tmppageid) 
8696 11 7a ea			ld de, store_page 
8699				if DEBUG_STORESE 
8699					DMARK "SCb" 
8699 f5				push af  
869a 3a ae 86			ld a, (.dmark)  
869d 32 6b ee			ld (debug_mark),a  
86a0 3a af 86			ld a, (.dmark+1)  
86a3 32 6c ee			ld (debug_mark+1),a  
86a6 3a b0 86			ld a, (.dmark+2)  
86a9 32 6d ee			ld (debug_mark+2),a  
86ac 18 03			jr .pastdmark  
86ae ..			.dmark: db "SCb"  
86b1 f1			.pastdmark: pop af  
86b2			endm  
# End of macro DMARK
86b2					;push af 
86b2					;ld a, 'b' 
86b2					;ld (debug_mark),a 
86b2					;pop af 
86b2					CALLMONITOR 
86b2 cd 6f ee			call debug_vector  
86b5				endm  
# End of macro CALLMONITOR
86b5				endif 
86b5 cd e9 81			call storage_write_block 
86b8			 
86b8 3a 6e ea			ld a, (store_tmpid) 
86bb 6f				ld l, a 
86bc 26 00			ld h,0 
86be				if DEBUG_STORESE 
86be					DMARK "SCz" 
86be f5				push af  
86bf 3a d3 86			ld a, (.dmark)  
86c2 32 6b ee			ld (debug_mark),a  
86c5 3a d4 86			ld a, (.dmark+1)  
86c8 32 6c ee			ld (debug_mark+1),a  
86cb 3a d5 86			ld a, (.dmark+2)  
86ce 32 6d ee			ld (debug_mark+2),a  
86d1 18 03			jr .pastdmark  
86d3 ..			.dmark: db "SCz"  
86d6 f1			.pastdmark: pop af  
86d7			endm  
# End of macro DMARK
86d7					CALLMONITOR 
86d7 cd 6f ee			call debug_vector  
86da				endm  
# End of macro CALLMONITOR
86da				endif 
86da c9				ret 
86db				 
86db			 
86db			 
86db			; 
86db			; Read File 
86db			; 
86db			; h - file id to locate 
86db			; l - extent to locate 
86db			; de - pointer to string to read into 
86db			; 
86db			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86db			 
86db			.sr_fail: 
86db d1				pop de 
86dc c9				ret 
86dd			 
86dd			storage_read: 
86dd			 
86dd			 
86dd d5				push de 
86de			 
86de			; TODO BUG the above push is it popped before the RET Z? 
86de			 
86de			; TODO how to handle multiple part blocks 
86de			 
86de				; locate file extent to read 
86de			 
86de 5c				ld e, h 
86df 55				ld d, l 
86e0			 
86e0			.srext: 
86e0 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86e3 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86e7			 
86e7 21 40 00			ld hl, STORE_BLOCK_PHY 
86ea				if DEBUG_STORESE 
86ea					DMARK "sre" 
86ea f5				push af  
86eb 3a ff 86			ld a, (.dmark)  
86ee 32 6b ee			ld (debug_mark),a  
86f1 3a 00 87			ld a, (.dmark+1)  
86f4 32 6c ee			ld (debug_mark+1),a  
86f7 3a 01 87			ld a, (.dmark+2)  
86fa 32 6d ee			ld (debug_mark+2),a  
86fd 18 03			jr .pastdmark  
86ff ..			.dmark: db "sre"  
8702 f1			.pastdmark: pop af  
8703			endm  
# End of macro DMARK
8703					CALLMONITOR 
8703 cd 6f ee			call debug_vector  
8706				endm  
# End of macro CALLMONITOR
8706				endif 
8706 cd b7 84			call storage_findnextid 
8709			 
8709				if DEBUG_STORESE 
8709					DMARK "srf" 
8709 f5				push af  
870a 3a 1e 87			ld a, (.dmark)  
870d 32 6b ee			ld (debug_mark),a  
8710 3a 1f 87			ld a, (.dmark+1)  
8713 32 6c ee			ld (debug_mark+1),a  
8716 3a 20 87			ld a, (.dmark+2)  
8719 32 6d ee			ld (debug_mark+2),a  
871c 18 03			jr .pastdmark  
871e ..			.dmark: db "srf"  
8721 f1			.pastdmark: pop af  
8722			endm  
# End of macro DMARK
8722					CALLMONITOR 
8722 cd 6f ee			call debug_vector  
8725				endm  
# End of macro CALLMONITOR
8725				endif 
8725 cd 10 8d			call ishlzero 
8728			;	ld a, l 
8728			;	add h 
8728			;	cp 0 
8728 28 b1			jr z,.sr_fail			; block not found so EOF 
872a			 
872a				; save current address for use by higher level words etc 
872a			 
872a 22 6b ea			ld (store_openaddr),hl 
872d			 
872d			 
872d				; hl contains page number to load 
872d d1				pop de   ; get storage 
872e ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8732 d5				push de 
8733				if DEBUG_STORESE 
8733					DMARK "srg" 
8733 f5				push af  
8734 3a 48 87			ld a, (.dmark)  
8737 32 6b ee			ld (debug_mark),a  
873a 3a 49 87			ld a, (.dmark+1)  
873d 32 6c ee			ld (debug_mark+1),a  
8740 3a 4a 87			ld a, (.dmark+2)  
8743 32 6d ee			ld (debug_mark+2),a  
8746 18 03			jr .pastdmark  
8748 ..			.dmark: db "srg"  
874b f1			.pastdmark: pop af  
874c			endm  
# End of macro DMARK
874c					CALLMONITOR 
874c cd 6f ee			call debug_vector  
874f				endm  
# End of macro CALLMONITOR
874f				endif 
874f cd 84 81			call storage_read_block 
8752			 
8752				; if this a continuation read??? 
8752			 
8752 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8755			 
8755 3e 3f			ld a, STORE_BLOCK_PHY-1 
8757 cd e7 8c			call addatohl 
875a 7e				ld a,(hl) 
875b fe 00			cp 0 
875d 28 02			jr z, .markiscont 
875f 3e ff			ld a, 255 
8761			 
8761			.markiscont: 
8761 32 6d ea			ld (store_readcont), a 
8764			 
8764				if DEBUG_STORESE 
8764					DMARK "srC" 
8764 f5				push af  
8765 3a 79 87			ld a, (.dmark)  
8768 32 6b ee			ld (debug_mark),a  
876b 3a 7a 87			ld a, (.dmark+1)  
876e 32 6c ee			ld (debug_mark+1),a  
8771 3a 7b 87			ld a, (.dmark+2)  
8774 32 6d ee			ld (debug_mark+2),a  
8777 18 03			jr .pastdmark  
8779 ..			.dmark: db "srC"  
877c f1			.pastdmark: pop af  
877d			endm  
# End of macro DMARK
877d					CALLMONITOR 
877d cd 6f ee			call debug_vector  
8780				endm  
# End of macro CALLMONITOR
8780				endif 
8780				; only short reads enabled 
8780			 
8780 3a 75 ea			ld a, (store_longread) 
8783 fe 00			cp 0 
8785 ca 52 88			jp z, .readdone 
8788			 
8788			; TODO if block has no zeros then need to read next block  
8788			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
8788			; check last byte of physical block. 
8788			; if not zero then the next block needs to be loaded 
8788			 
8788			 
8788 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
878b			 
878b 3e 3f			ld a, STORE_BLOCK_PHY-1 
878d cd e7 8c			call addatohl 
8790				;dec hl 
8790 7e				ld a,(hl) 
8791				if DEBUG_STORESE 
8791					DMARK "sr?" 
8791 f5				push af  
8792 3a a6 87			ld a, (.dmark)  
8795 32 6b ee			ld (debug_mark),a  
8798 3a a7 87			ld a, (.dmark+1)  
879b 32 6c ee			ld (debug_mark+1),a  
879e 3a a8 87			ld a, (.dmark+2)  
87a1 32 6d ee			ld (debug_mark+2),a  
87a4 18 03			jr .pastdmark  
87a6 ..			.dmark: db "sr?"  
87a9 f1			.pastdmark: pop af  
87aa			endm  
# End of macro DMARK
87aa					CALLMONITOR 
87aa cd 6f ee			call debug_vector  
87ad				endm  
# End of macro CALLMONITOR
87ad				endif 
87ad fe 00			cp 0 
87af ca 52 88			jp z, .readdone 
87b2			 
87b2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87b2			 
87b2 23				inc hl 
87b3			 
87b3 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87b6			 
87b6 ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ba			 
87ba eb				ex de, hl 
87bb			 
87bb				; next ext 
87bb			 
87bb 23				inc hl 
87bc 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87bf			 
87bf				if DEBUG_STORESE 
87bf					DMARK "sF2" 
87bf f5				push af  
87c0 3a d4 87			ld a, (.dmark)  
87c3 32 6b ee			ld (debug_mark),a  
87c6 3a d5 87			ld a, (.dmark+1)  
87c9 32 6c ee			ld (debug_mark+1),a  
87cc 3a d6 87			ld a, (.dmark+2)  
87cf 32 6d ee			ld (debug_mark+2),a  
87d2 18 03			jr .pastdmark  
87d4 ..			.dmark: db "sF2"  
87d7 f1			.pastdmark: pop af  
87d8			endm  
# End of macro DMARK
87d8					CALLMONITOR 
87d8 cd 6f ee			call debug_vector  
87db				endm  
# End of macro CALLMONITOR
87db				endif 
87db			 
87db				; get and load block 
87db			 
87db cd b7 84			call storage_findnextid 
87de			 
87de				if DEBUG_STORESE 
87de					DMARK "sf2" 
87de f5				push af  
87df 3a f3 87			ld a, (.dmark)  
87e2 32 6b ee			ld (debug_mark),a  
87e5 3a f4 87			ld a, (.dmark+1)  
87e8 32 6c ee			ld (debug_mark+1),a  
87eb 3a f5 87			ld a, (.dmark+2)  
87ee 32 6d ee			ld (debug_mark+2),a  
87f1 18 03			jr .pastdmark  
87f3 ..			.dmark: db "sf2"  
87f6 f1			.pastdmark: pop af  
87f7			endm  
# End of macro DMARK
87f7					CALLMONITOR 
87f7 cd 6f ee			call debug_vector  
87fa				endm  
# End of macro CALLMONITOR
87fa				endif 
87fa cd 10 8d			call ishlzero 
87fd			;	ld a, l 
87fd			;	add h 
87fd			;	cp 0 
87fd ca db 86			jp z,.sr_fail			; block not found so EOF 
8800				 
8800				; save current address for use by higher level words etc 
8800			 
8800 22 6b ea			ld (store_openaddr),hl 
8803			 
8803 cd 84 81			call storage_read_block 
8806			 
8806				; on a continuation block, we now have the file id and ext in the middle of the block 
8806				; we need to pull everything back  
8806			 
8806 ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
880a 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
880d 23				inc hl 
880e 23				inc hl     ; skip id and ext 
880f 01 40 00			ld bc, STORE_BLOCK_PHY 
8812				if DEBUG_STORESE 
8812					DMARK "SR<" 
8812 f5				push af  
8813 3a 27 88			ld a, (.dmark)  
8816 32 6b ee			ld (debug_mark),a  
8819 3a 28 88			ld a, (.dmark+1)  
881c 32 6c ee			ld (debug_mark+1),a  
881f 3a 29 88			ld a, (.dmark+2)  
8822 32 6d ee			ld (debug_mark+2),a  
8825 18 03			jr .pastdmark  
8827 ..			.dmark: db "SR<"  
882a f1			.pastdmark: pop af  
882b			endm  
# End of macro DMARK
882b					CALLMONITOR 
882b cd 6f ee			call debug_vector  
882e				endm  
# End of macro CALLMONITOR
882e				endif 
882e ed b0			ldir     ; copy data 
8830			 
8830				; move the pointer back and pretend we have a full buffer for next recheck 
8830			 
8830 1b				dec de 
8831 1b				dec de 
8832			 
8832			; TODO do pop below now short circuit loop????? 
8832 c1				pop bc     ; get rid of spare de on stack 
8833				if DEBUG_STORESE 
8833					DMARK "SR>" 
8833 f5				push af  
8834 3a 48 88			ld a, (.dmark)  
8837 32 6b ee			ld (debug_mark),a  
883a 3a 49 88			ld a, (.dmark+1)  
883d 32 6c ee			ld (debug_mark+1),a  
8840 3a 4a 88			ld a, (.dmark+2)  
8843 32 6d ee			ld (debug_mark+2),a  
8846 18 03			jr .pastdmark  
8848 ..			.dmark: db "SR>"  
884b f1			.pastdmark: pop af  
884c			endm  
# End of macro DMARK
884c					CALLMONITOR 
884c cd 6f ee			call debug_vector  
884f				endm  
# End of macro CALLMONITOR
884f				endif 
884f c3 e0 86			jp .srext 
8852			 
8852			 
8852			 
8852			 
8852			 
8852			.readdone:		 
8852 e1				pop hl 		 ; return start of data to show as not EOF 
8853 23				inc hl   ; past file id 
8854 23				inc hl   ; past ext 
8855				if DEBUG_STORESE 
8855					DMARK "SRe" 
8855 f5				push af  
8856 3a 6a 88			ld a, (.dmark)  
8859 32 6b ee			ld (debug_mark),a  
885c 3a 6b 88			ld a, (.dmark+1)  
885f 32 6c ee			ld (debug_mark+1),a  
8862 3a 6c 88			ld a, (.dmark+2)  
8865 32 6d ee			ld (debug_mark+2),a  
8868 18 03			jr .pastdmark  
886a ..			.dmark: db "SRe"  
886d f1			.pastdmark: pop af  
886e			endm  
# End of macro DMARK
886e					CALLMONITOR 
886e cd 6f ee			call debug_vector  
8871				endm  
# End of macro CALLMONITOR
8871				endif 
8871 c9					ret 
8872			 
8872			 
8872			 
8872			; 
8872			; Append File 
8872			; 
8872			; hl - file id to locate 
8872			; de - pointer to (multi block) string to write 
8872			 
8872			.sa_notfound: 
8872 d1				pop de 
8873 c9				ret 
8874			 
8874			 
8874			storage_append: 
8874				; hl -  file id to append to 
8874				; de - string to append 
8874			 
8874 d5				push de 
8875				 
8875				if DEBUG_STORESE 
8875					DMARK "AP1" 
8875 f5				push af  
8876 3a 8a 88			ld a, (.dmark)  
8879 32 6b ee			ld (debug_mark),a  
887c 3a 8b 88			ld a, (.dmark+1)  
887f 32 6c ee			ld (debug_mark+1),a  
8882 3a 8c 88			ld a, (.dmark+2)  
8885 32 6d ee			ld (debug_mark+2),a  
8888 18 03			jr .pastdmark  
888a ..			.dmark: db "AP1"  
888d f1			.pastdmark: pop af  
888e			endm  
# End of macro DMARK
888e					CALLMONITOR 
888e cd 6f ee			call debug_vector  
8891				endm  
# End of macro CALLMONITOR
8891				endif 
8891			 
8891 7d				ld a, l 
8892 32 6e ea			ld (store_tmpid), a 
8895			 
8895				; get file header  
8895			 
8895 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8897 3a 6e ea			ld a, (store_tmpid) 
889a 5f				ld e, a 
889b			 
889b 21 40 00				ld hl, STORE_BLOCK_PHY 
889e cd b7 84				call storage_findnextid 
88a1			 
88a1 cd 10 8d			call ishlzero 
88a4 28 cc			jr z, .sa_notfound 
88a6			 
88a6 22 65 ea			ld (store_tmppageid), hl 
88a9			 
88a9				; TODO handle file id not found 
88a9			 
88a9				if DEBUG_STORESE 
88a9					DMARK "AP2" 
88a9 f5				push af  
88aa 3a be 88			ld a, (.dmark)  
88ad 32 6b ee			ld (debug_mark),a  
88b0 3a bf 88			ld a, (.dmark+1)  
88b3 32 6c ee			ld (debug_mark+1),a  
88b6 3a c0 88			ld a, (.dmark+2)  
88b9 32 6d ee			ld (debug_mark+2),a  
88bc 18 03			jr .pastdmark  
88be ..			.dmark: db "AP2"  
88c1 f1			.pastdmark: pop af  
88c2			endm  
# End of macro DMARK
88c2					CALLMONITOR 
88c2 cd 6f ee			call debug_vector  
88c5				endm  
# End of macro CALLMONITOR
88c5				endif 
88c5			 
88c5				; update file extent count 
88c5			 
88c5 11 7a ea			ld de, store_page 
88c8			 
88c8 cd 84 81			call storage_read_block 
88cb			 
88cb				if DEBUG_STORESE 
88cb					DMARK "AP3" 
88cb f5				push af  
88cc 3a e0 88			ld a, (.dmark)  
88cf 32 6b ee			ld (debug_mark),a  
88d2 3a e1 88			ld a, (.dmark+1)  
88d5 32 6c ee			ld (debug_mark+1),a  
88d8 3a e2 88			ld a, (.dmark+2)  
88db 32 6d ee			ld (debug_mark+2),a  
88de 18 03			jr .pastdmark  
88e0 ..			.dmark: db "AP3"  
88e3 f1			.pastdmark: pop af  
88e4			endm  
# End of macro DMARK
88e4					CALLMONITOR 
88e4 cd 6f ee			call debug_vector  
88e7				endm  
# End of macro CALLMONITOR
88e7				endif 
88e7			;	ld (store_tmppageid), hl 
88e7			 
88e7 3a 7c ea			ld a, (store_page+2) 
88ea 3c				inc a 
88eb 32 7c ea			ld (store_page+2), a 
88ee 32 6d ea			ld (store_tmpext), a 
88f1				 
88f1				if DEBUG_STORESE 
88f1					DMARK "AP3" 
88f1 f5				push af  
88f2 3a 06 89			ld a, (.dmark)  
88f5 32 6b ee			ld (debug_mark),a  
88f8 3a 07 89			ld a, (.dmark+1)  
88fb 32 6c ee			ld (debug_mark+1),a  
88fe 3a 08 89			ld a, (.dmark+2)  
8901 32 6d ee			ld (debug_mark+2),a  
8904 18 03			jr .pastdmark  
8906 ..			.dmark: db "AP3"  
8909 f1			.pastdmark: pop af  
890a			endm  
# End of macro DMARK
890a					CALLMONITOR 
890a cd 6f ee			call debug_vector  
890d				endm  
# End of macro CALLMONITOR
890d				endif 
890d 2a 65 ea			ld hl, (store_tmppageid) 
8910 11 7a ea			ld de, store_page 
8913 cd e9 81			call storage_write_block 
8916			 
8916				; find free block 
8916			 
8916 11 00 00			ld de, 0			 ; file extent to locate 
8919			 
8919 21 40 00				ld hl, STORE_BLOCK_PHY 
891c cd b7 84				call storage_findnextid 
891f cd 10 8d			call ishlzero 
8922 ca 72 88			jp z, .sa_notfound 
8925			 
8925					; TODO handle no space left 
8925					 
8925 22 65 ea				ld (store_tmppageid), hl 
8928			 
8928				if DEBUG_STORESE 
8928					DMARK "AP4" 
8928 f5				push af  
8929 3a 3d 89			ld a, (.dmark)  
892c 32 6b ee			ld (debug_mark),a  
892f 3a 3e 89			ld a, (.dmark+1)  
8932 32 6c ee			ld (debug_mark+1),a  
8935 3a 3f 89			ld a, (.dmark+2)  
8938 32 6d ee			ld (debug_mark+2),a  
893b 18 03			jr .pastdmark  
893d ..			.dmark: db "AP4"  
8940 f1			.pastdmark: pop af  
8941			endm  
# End of macro DMARK
8941					CALLMONITOR 
8941 cd 6f ee			call debug_vector  
8944				endm  
# End of macro CALLMONITOR
8944				endif 
8944					; init the buffer with zeros so we can id if the buffer is full or not 
8944			 
8944 e5					push hl 
8945 c5					push bc 
8946			 
8946 21 7a ea				ld hl, store_page 
8949 06 40				ld b, STORE_BLOCK_PHY 
894b 3e 00				ld a, 0 
894d 77			.zeroblock:	ld (hl), a 
894e 23					inc hl 
894f 10 fc				djnz .zeroblock 
8951			 
8951 c1					pop bc 
8952 e1					pop hl 
8953			 
8953					; construct block 
8953			 
8953 3a 6e ea				ld a, (store_tmpid) 
8956 32 7a ea				ld (store_page), a   ; file id 
8959 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
895c 32 7b ea				ld (store_page+1), a 
895f			 
895f e1					pop hl    ; get string to write 
8960 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8962 11 7c ea				ld de, store_page+2 
8965			 
8965				if DEBUG_STORESE 
8965					DMARK "AP5" 
8965 f5				push af  
8966 3a 7a 89			ld a, (.dmark)  
8969 32 6b ee			ld (debug_mark),a  
896c 3a 7b 89			ld a, (.dmark+1)  
896f 32 6c ee			ld (debug_mark+1),a  
8972 3a 7c 89			ld a, (.dmark+2)  
8975 32 6d ee			ld (debug_mark+2),a  
8978 18 03			jr .pastdmark  
897a ..			.dmark: db "AP5"  
897d f1			.pastdmark: pop af  
897e			endm  
# End of macro DMARK
897e					CALLMONITOR 
897e cd 6f ee			call debug_vector  
8981				endm  
# End of macro CALLMONITOR
8981				endif 
8981			 
8981			 
8981			 
8981					; fill buffer with data until end of string or full block 
8981			 
8981 7e			.appd:		ld a, (hl) 
8982 12					ld (de), a 
8983 fe 00				cp 0 
8985 28 04				jr z, .appdone 
8987 23					inc hl 
8988 13					inc de 
8989 10 f6				djnz .appd 
898b			 
898b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
898c f5					push af   		; save last byte dumped 
898d			 
898d			 
898d 2a 65 ea			ld hl, (store_tmppageid) 
8990 11 7a ea			ld de, store_page 
8993				if DEBUG_STORESE 
8993					DMARK "AP6" 
8993 f5				push af  
8994 3a a8 89			ld a, (.dmark)  
8997 32 6b ee			ld (debug_mark),a  
899a 3a a9 89			ld a, (.dmark+1)  
899d 32 6c ee			ld (debug_mark+1),a  
89a0 3a aa 89			ld a, (.dmark+2)  
89a3 32 6d ee			ld (debug_mark+2),a  
89a6 18 03			jr .pastdmark  
89a8 ..			.dmark: db "AP6"  
89ab f1			.pastdmark: pop af  
89ac			endm  
# End of macro DMARK
89ac					CALLMONITOR 
89ac cd 6f ee			call debug_vector  
89af				endm  
# End of macro CALLMONITOR
89af				endif 
89af cd e9 81				call storage_write_block 
89b2			 
89b2			 
89b2				; was that a full block of data written? 
89b2				; any more to write out? 
89b2			 
89b2				; if yes then set vars and jump to start of function again 
89b2			 
89b2 f1					pop af 
89b3 d1					pop de 
89b4			 
89b4 fe 00				cp 0		 ; no, string was fully written 
89b6 c8					ret z 
89b7			 
89b7					; setup vars for next cycle 
89b7			 
89b7 3a 6e ea				ld a, (store_tmpid) 
89ba 6f					ld l, a 
89bb 26 00				ld h, 0 
89bd			 
89bd c3 74 88			 	jp storage_append	 ; yes, need to write out some more 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			if DEBUG_STORECF 
89c0			storageput:	 
89c0					ret 
89c0			storageread: 
89c0					ld hl, store_page 
89c0					ld b, 200 
89c0					ld a,0 
89c0			.src:		ld (hl),a 
89c0					inc hl 
89c0					djnz .src 
89c0					 
89c0			 
89c0					ld de, 0 
89c0					ld bc, 1 
89c0					ld hl, store_page 
89c0					call cfRead 
89c0			 
89c0				call cfGetError 
89c0				ld hl,scratch 
89c0				call hexout 
89c0				ld hl, scratch+2 
89c0				ld a, 0 
89c0				ld (hl),a 
89c0				ld de, scratch 
89c0				ld a,display_row_1 
89c0				call str_at_display 
89c0				call update_display 
89c0			 
89c0					ld hl, store_page 
89c0					ld (os_cur_ptr),hl 
89c0			 
89c0					ret 
89c0			endif 
89c0			 
89c0			 
89c0			; Clear out the main buffer store (used to remove junk before writing a new block) 
89c0			 
89c0			storage_clear_page: 
89c0 e5				push hl 
89c1 d5				push de 
89c2 c5				push bc 
89c3 21 7a ea			ld hl, store_page 
89c6 3e 00			ld a, 0 
89c8 77				ld (hl), a 
89c9			 
89c9 11 7b ea			ld de, store_page+1 
89cc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89cf			 
89cf ed b0			ldir 
89d1				 
89d1 c1				pop bc 
89d2 d1				pop de 
89d3 e1				pop hl 
89d4 c9				ret 
89d5			 
89d5			; eof 
# End of file firmware_storage.asm
89d5			  
89d5			; support routines for above hardware abstraction layer  
89d5			  
89d5			include "firmware_general.asm"        ; general support functions  
89d5			 
89d5			; word look up 
89d5			 
89d5			; in 
89d5			; a is the index 
89d5			; hl is pointer start of array 
89d5			; 
89d5			; returns 
89d5			; hl to the word 
89d5			; 
89d5			 
89d5			table_lookup:  
89d5 d5					push de 
89d6 eb					ex de, hl 
89d7			 
89d7 6f					ld l, a 
89d8 26 00				ld h, 0 
89da 29					add hl, hl 
89db 19					add hl, de 
89dc 7e					ld a, (hl) 
89dd 23					inc hl 
89de 66					ld h,(hl) 
89df 6f					ld l, a 
89e0			 
89e0 d1					pop de 
89e1 c9					ret 
89e2			 
89e2			; Delay loops 
89e2			 
89e2			 
89e2			 
89e2			aDelayInMS: 
89e2 c5				push bc 
89e3 47				ld b,a 
89e4			msdelay: 
89e4 c5				push bc 
89e5				 
89e5			 
89e5 01 41 00			ld bc,041h 
89e8 cd 00 8a			call delayloop 
89eb c1				pop bc 
89ec 05				dec b 
89ed 20 f5			jr nz,msdelay 
89ef			 
89ef			;if CPU_CLOCK_8MHZ 
89ef			;msdelay8: 
89ef			;	push bc 
89ef			;	 
89ef			; 
89ef			;	ld bc,041h 
89ef			;	call delayloop 
89ef			;	pop bc 
89ef			;	dec b 
89ef			;	jr nz,msdelay8 
89ef			;endif 
89ef			 
89ef			 
89ef c1				pop bc 
89f0 c9				ret 
89f1			 
89f1			 
89f1			delay250ms: 
89f1				;push de 
89f1 01 00 40			ld bc, 04000h 
89f4 c3 00 8a			jp delayloop 
89f7			delay500ms: 
89f7				;push de 
89f7 01 00 80			ld bc, 08000h 
89fa c3 00 8a			jp delayloop 
89fd			delay1s: 
89fd				;push bc 
89fd			   ; Clobbers A, d and e 
89fd 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8a00			delayloop: 
8a00 c5			    push bc 
8a01			 
8a01			if BASE_CPM 
8a01				ld bc, CPM_DELAY_TUNE 
8a01			.cpmloop: 
8a01				push bc 
8a01			 
8a01			endif 
8a01			 
8a01			 
8a01			 
8a01			delayloopi: 
8a01			;	push bc 
8a01			;.dl: 
8a01 cb 47		    bit     0,a    	; 8 
8a03 cb 47		    bit     0,a    	; 8 
8a05 cb 47		    bit     0,a    	; 8 
8a07 e6 ff		    and     255  	; 7 
8a09 0b			    dec     bc      	; 6 
8a0a 79			    ld      a,c     	; 4 
8a0b b0			    or      b     	; 4 
8a0c c2 01 8a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a0f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a0f				;pop de 
8a0f			;pop bc 
8a0f			 
8a0f			if BASE_CPM 
8a0f				pop bc 
8a0f				 
8a0f			    dec     bc      	; 6 
8a0f			    ld      a,c     	; 4 
8a0f			    or      b     	; 4 
8a0f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a0f				 
8a0f			 
8a0f			endif 
8a0f			;if CPU_CLOCK_8MHZ 
8a0f			;    pop bc 
8a0f			;    push bc 
8a0f			;.dl8: 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    and     255  	; 7 
8a0f			;    dec     bc      	; 6 
8a0f			;    ld      a,c     	; 4 
8a0f			;    or      b     	; 4 
8a0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a0f			;endif 
8a0f			 
8a0f			;if CPU_CLOCK_10MHZ 
8a0f			;    pop bc 
8a0f			;    push bc 
8a0f			;.dl8: 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    and     255  	; 7 
8a0f			;    dec     bc      	; 6 
8a0f			;    ld      a,c     	; 4 
8a0f			;    or      b     	; 4 
8a0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a0f			;endif 
8a0f c1			    pop bc 
8a10			 
8a10 c9				ret 
8a11			 
8a11			 
8a11			 
8a11			; eof 
# End of file firmware_general.asm
8a11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a11			; display routines that use the physical hardware abstraction layer 
8a11			 
8a11			 
8a11			; Display an activity indicator 
8a11			; Each call returns the new char pointed to in hl 
8a11			 
8a11			active: 
8a11 3a c6 eb			ld a, (display_active) 
8a14 fe 06			cp 6 
8a16			 
8a16 20 02			jr nz, .sne 
8a18				; gone past the last one reset sequence 
8a18 3e ff			ld a, 255 
8a1a			 
8a1a			.sne:   
8a1a				; get the next char in seq 
8a1a 3c				inc a 
8a1b 32 c6 eb			ld (display_active), a 
8a1e			 
8a1e				; look up the string in the table 
8a1e 21 35 8a			ld hl, actseq 
8a21 cb 27			sla a 
8a23 cd e7 8c			call addatohl 
8a26 cd ab 9d			call loadwordinhl 
8a29			 
8a29				; forth will write the to string when pushing so move from rom to ram 
8a29			 
8a29 11 c7 eb			ld de, display_active+1 
8a2c 01 02 00			ld bc, 2 
8a2f ed b0			ldir 
8a31			 
8a31 21 c7 eb			ld hl, display_active+1 
8a34 c9				ret 
8a35				 
8a35				 
8a35			 
8a35			 
8a35			;db "|/-\|-\" 
8a35			 
8a35			actseq: 
8a35			 
8a35 43 8a		dw spin0 
8a37 45 8a		dw spin1 
8a39 47 8a		dw spin2 
8a3b 49 8a		dw spin3 
8a3d 47 8a		dw spin2 
8a3f 45 8a		dw spin1 
8a41 43 8a		dw spin0 
8a43			 
8a43 .. 00		spin0: db " ", 0 
8a45 .. 00		spin1: db "-", 0 
8a47 .. 00		spin2: db "+", 0 
8a49 .. 00		spin3: db "#", 0 
8a4b			 
8a4b			 
8a4b			; information window 
8a4b			 
8a4b			; pass hl with 1st string to display 
8a4b			; pass de with 2nd string to display 
8a4b			 
8a4b			info_panel: 
8a4b e5				push hl 
8a4c			 
8a4c 2a cc eb			ld hl, (display_fb_active) 
8a4f e5				push hl    ; future de destination 
8a50 21 b1 ed				ld hl, display_fb0 
8a53 22 cc eb				ld (display_fb_active), hl 
8a56			 
8a56			;	call clear_display 
8a56			 
8a56				if BASE_CPM 
8a56				ld a, '.' 
8a56				else 
8a56 3e a5			ld a, 165 
8a58				endif 
8a58 cd bf 8a			call fill_display 
8a5b			 
8a5b			 
8a5b 3e 55			ld a, display_row_3 + 5 
8a5d cd cd 8a			call str_at_display 
8a60			 
8a60 e1				pop hl 
8a61 d1				pop de 
8a62			 
8a62 e5				push hl 
8a63			 
8a63			 
8a63 3e 2d			ld a, display_row_2 + 5 
8a65 cd cd 8a			call str_at_display 
8a68			 
8a68			 
8a68 cd dd 8a			call update_display 
8a6b cd e6 99			call next_page_prompt 
8a6e cd ba 8a			call clear_display 
8a71			 
8a71				 
8a71 21 10 ed				ld hl, display_fb1 
8a74 22 cc eb				ld (display_fb_active), hl 
8a77 cd dd 8a			call update_display 
8a7a			 
8a7a e1				pop hl 
8a7b			 
8a7b c9				ret 
8a7c			 
8a7c			 
8a7c			 
8a7c			 
8a7c			; TODO windowing? 
8a7c			 
8a7c			; TODO scroll line up 
8a7c			 
8a7c			scroll_up: 
8a7c			 
8a7c e5				push hl 
8a7d d5				push de 
8a7e c5				push bc 
8a7f			 
8a7f				; get frame buffer  
8a7f			 
8a7f 2a cc eb			ld hl, (display_fb_active) 
8a82 e5				push hl    ; future de destination 
8a83			 
8a83 11 28 00			ld  de, display_cols 
8a86 19				add hl, de 
8a87			 
8a87 d1				pop de 
8a88			 
8a88				;ex de, hl 
8a88 01 9f 00			ld bc, display_fb_len -1  
8a8b			;if DEBUG_FORTH_WORDS 
8a8b			;	DMARK "SCL" 
8a8b			;	CALLMONITOR 
8a8b			;endif	 
8a8b ed b0			ldir 
8a8d			 
8a8d				; wipe bottom row 
8a8d			 
8a8d			 
8a8d 2a cc eb			ld hl, (display_fb_active) 
8a90 11 a0 00			ld de, display_cols*display_rows 
8a93 19				add hl, de 
8a94 06 28			ld b, display_cols 
8a96 3e 20			ld a, ' ' 
8a98			.scwipe: 
8a98 77				ld (hl), a 
8a99 2b				dec hl 
8a9a 10 fc			djnz .scwipe 
8a9c			 
8a9c				;pop hl 
8a9c			 
8a9c c1				pop bc 
8a9d d1				pop de 
8a9e e1				pop hl 
8a9f			 
8a9f c9				ret 
8aa0			 
8aa0			 
8aa0			;scroll_upo: 
8aa0			;	ld de, display_row_1 
8aa0			 ;	ld hl, display_row_2 
8aa0			;	ld bc, display_cols 
8aa0			;	ldir 
8aa0			;	ld de, display_row_2 
8aa0			 ;	ld hl, display_row_3 
8aa0			;	ld bc, display_cols 
8aa0			;	ldir 
8aa0			;	ld de, display_row_3 
8aa0			 ;	ld hl, display_row_4 
8aa0			;	ld bc, display_cols 
8aa0			;	ldir 
8aa0			 
8aa0			; TODO clear row 4 
8aa0			 
8aa0			;	ret 
8aa0			 
8aa0				 
8aa0			scroll_down: 
8aa0			 
8aa0 e5				push hl 
8aa1 d5				push de 
8aa2 c5				push bc 
8aa3			 
8aa3				; get frame buffer  
8aa3			 
8aa3 2a cc eb			ld hl, (display_fb_active) 
8aa6			 
8aa6 11 9f 00			ld de, display_fb_len - 1 
8aa9 19				add hl, de 
8aaa			 
8aaa e5			push hl    ; future de destination 
8aab			 
8aab 11 28 00			ld  de, display_cols 
8aae ed 52			sbc hl, de 
8ab0			 
8ab0			 
8ab0 d1				pop de 
8ab1			 
8ab1			;	ex de, hl 
8ab1 01 9f 00			ld bc, display_fb_len -1  
8ab4			 
8ab4			 
8ab4				 
8ab4			 
8ab4 ed b0			ldir 
8ab6			 
8ab6				; wipe bottom row 
8ab6			 
8ab6			 
8ab6			;	ld hl, (display_fb_active) 
8ab6			;;	ld de, display_cols*display_rows 
8ab6			;;	add hl, de 
8ab6			;	ld b, display_cols 
8ab6			;	ld a, ' ' 
8ab6			;.scwiped: 
8ab6			;	ld (hl), a 
8ab6			;	dec hl 
8ab6			;	djnz .scwiped 
8ab6			 
8ab6				;pop hl 
8ab6			 
8ab6 c1				pop bc 
8ab7 d1				pop de 
8ab8 e1				pop hl 
8ab9			 
8ab9 c9				ret 
8aba			;scroll_down: 
8aba			;	ld de, display_row_4 
8aba			;	ld hl, display_row_3 
8aba			;	ld bc, display_cols 
8aba			;	ldir 
8aba			;	ld de, display_row_3 
8aba			; 	ld hl, display_row_2 
8aba			;	ld bc, display_cols 
8aba			;	ldir 
8aba			;	ld de, display_row_2 
8aba			;	ld hl, display_row_1 
8aba			;	ld bc, display_cols 
8aba			;	ldir 
8aba			;;; TODO clear row 1 
8aba			;	ret 
8aba			 
8aba			 
8aba			 
8aba			 
8aba			 
8aba			; clear active frame buffer 
8aba			 
8aba			clear_display: 
8aba 3e 20			ld a, ' ' 
8abc c3 bf 8a			jp fill_display 
8abf			 
8abf			; fill active frame buffer with a char in A 
8abf			 
8abf			fill_display: 
8abf 06 a0			ld b,display_fb_len 
8ac1 2a cc eb			ld hl, (display_fb_active) 
8ac4 77			.fd1:	ld (hl),a 
8ac5 23				inc hl 
8ac6 10 fc			djnz .fd1 
8ac8 23				inc hl 
8ac9 3e 00			ld a,0 
8acb 77				ld (hl),a 
8acc			 
8acc			 
8acc c9				ret 
8acd			; Write string (DE) at pos (A) to active frame buffer 
8acd			 
8acd 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ad0 06 00					ld b,0 
8ad2 4f					ld c,a 
8ad3 09					add hl,bc 
8ad4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ad5 b7			            OR   A              ;Null terminator? 
8ad6 c8			            RET  Z              ;Yes, so finished 
8ad7 77					ld (hl),a 
8ad8 23				inc hl 
8ad9 13			            INC  DE             ;Point to next character 
8ada 18 f8		            JR   .sad1     ;Repeat 
8adc c9					ret 
8add			 
8add			; using current frame buffer write to physical display 
8add			 
8add			update_display: 
8add e5				push hl 
8ade 2a cc eb			ld hl, (display_fb_active) 
8ae1 cd 91 dc			call write_display 
8ae4 e1				pop hl 
8ae5 c9				ret 
8ae6			 
8ae6			; TODO scrolling 
8ae6			 
8ae6			 
8ae6			; move cursor right one char 
8ae6			cursor_right: 
8ae6			 
8ae6				; TODO shift right 
8ae6				; TODO if beyond max col 
8ae6				; TODO       cursor_next_line 
8ae6			 
8ae6 c9				ret 
8ae7			 
8ae7			 
8ae7			cursor_next_line: 
8ae7				; TODO first char 
8ae7				; TODO line down 
8ae7				; TODO if past last row 
8ae7				; TODO    scroll up 
8ae7			 
8ae7 c9				ret 
8ae8			 
8ae8			cursor_left: 
8ae8				; TODO shift left 
8ae8				; TODO if beyond left  
8ae8				; TODO     cursor prev line 
8ae8				 
8ae8 c9				ret 
8ae9			 
8ae9			cursor_prev_line: 
8ae9				; TODO last char 
8ae9				; TODO line up 
8ae9				; TODO if past first row 
8ae9				; TODO   scroll down 
8ae9			 
8ae9 c9				ret 
8aea			 
8aea			 
8aea			cout: 
8aea				; A - char 
8aea c9				ret 
8aeb			 
8aeb			 
8aeb			; Display a menu and allow item selection (optional toggle items) 
8aeb			; 
8aeb			; format: 
8aeb			; hl pointer to word array with zero term for items 
8aeb			; e.g.    db item1 
8aeb			;         db .... 
8aeb			;         db 0 
8aeb			; 
8aeb			; a = starting menu item  
8aeb			; 
8aeb			; de = pointer item toggle array   (todo) 
8aeb			; 
8aeb			; returns item selected in a 1-... 
8aeb			; returns 0 if back button pressed 
8aeb			; 
8aeb			; NOTE: Uses system frame buffer to display 
8aeb			; 
8aeb			; LEFT, Q = go back 
8aeb			; RIGHT, SPACE, CR = select 
8aeb			; UP, A - Up 
8aeb			; DOWN, Z - Down 
8aeb			 
8aeb			 
8aeb			 
8aeb			 
8aeb			 
8aeb			menu: 
8aeb			 
8aeb					; keep array pointer 
8aeb			 
8aeb 22 73 ea				ld (store_tmp1), hl 
8aee 32 71 ea				ld (store_tmp2), a 
8af1			 
8af1					; check for key bounce 
8af1			 
8af1			if BASE_KEV 
8af1			 
8af1			.mbounce:	call cin 
8af1					cp 0 
8af1					jr nz, .mbounce 
8af1			endif 
8af1					; for ease use ex 
8af1			 
8af1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8af1 21 b1 ed				ld hl, display_fb0 
8af4 22 cc eb				ld (display_fb_active), hl 
8af7			 
8af7 cd ba 8a		.mloop:		call clear_display 
8afa cd dd 8a				call update_display 
8afd			 
8afd					; draw selection id '>' at 1 
8afd			 
8afd					; init start of list display 
8afd			 
8afd 3e 05				ld a, 5 
8aff 32 6f ea				ld (store_tmp3), a   ; display row count 
8b02 3a 71 ea				ld a,( store_tmp2) 
8b05 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b08			 
8b08					 
8b08			.mitem:	 
8b08			 
8b08			 
8b08 3a 72 ea				ld a,(store_tmp2+1) 
8b0b 6f					ld l, a 
8b0c 26 00				ld h, 0 
8b0e 29					add hl, hl 
8b0f ed 5b 73 ea			ld de, (store_tmp1) 
8b13 19					add hl, de 
8b14 7e					ld a, (hl) 
8b15 23					inc hl 
8b16 66					ld h,(hl) 
8b17 6f					ld l, a 
8b18			 
8b18 cd 10 8d				call ishlzero 
8b1b 28 1a				jr z, .mdone 
8b1d			 
8b1d eb					ex de, hl 
8b1e 3a 6f ea				ld a, (store_tmp3) 
8b21 cd cd 8a				call str_at_display 
8b24					 
8b24			 
8b24					; next item 
8b24 3a 72 ea				ld a, (store_tmp2+1) 
8b27 3c					inc a 
8b28 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b2b			 
8b2b			 		; next row 
8b2b			 
8b2b 3a 6f ea				ld a, (store_tmp3) 
8b2e c6 28				add display_cols 
8b30 32 6f ea				ld (store_tmp3), a 
8b33			 
8b33					; at end of screen? 
8b33			 
8b33 fe 10				cp display_rows*4 
8b35 20 d1				jr nz, .mitem 
8b37			 
8b37			 
8b37			.mdone: 
8b37 cd 10 8d				call ishlzero 
8b3a 28 08				jr z, .nodn 
8b3c			 
8b3c 3e 78				ld a, display_row_4 
8b3e 11 bd 8b				ld de, .mdown 
8b41 cd cd 8a				call str_at_display 
8b44			 
8b44					; draw options to fill the screens with active item on line 1 
8b44					; if current option is 2 or more then display ^ in top 
8b44			 
8b44 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b47 fe 00				cp 0 
8b49 28 08				jr z, .noup 
8b4b			 
8b4b 3e 00				ld a, 0 
8b4d 11 bb 8b				ld de, .mup 
8b50 cd cd 8a				call str_at_display 
8b53			 
8b53 3e 02		.noup:		ld a, 2 
8b55 11 b9 8b				ld de, .msel 
8b58 cd cd 8a				call str_at_display 
8b5b			 
8b5b					; if current option + 1 is not null then display V in bottom 
8b5b					; get key 
8b5b cd dd 8a				call update_display 
8b5e			 
8b5e			 
8b5e					; handle key 
8b5e			 
8b5e cd 1d dd				call cin_wait 
8b61			 
8b61 fe 05				cp KEY_UP 
8b63 28 2b				jr z, .mgoup 
8b65 fe 61				cp 'a' 
8b67 28 27				jr z, .mgoup 
8b69 fe 0a				cp KEY_DOWN 
8b6b 28 32				jr z, .mgod 
8b6d fe 7a				cp 'z' 
8b6f 28 2e				jr z, .mgod 
8b71 fe 20				cp ' ' 
8b73 28 34				jr z, .goend 
8b75 fe 0c				cp KEY_RIGHT 
8b77 28 30				jr z, .goend 
8b79 fe 0d				cp KEY_CR 
8b7b 28 2c				jr z, .goend 
8b7d fe 71				cp 'q' 
8b7f 28 0b				jr z, .goback 
8b81			 
8b81 fe 0b				cp KEY_LEFT 
8b83 28 07				jr z, .goback 
8b85 fe 08				cp KEY_BS 
8b87 28 03				jr z, .goback 
8b89 c3 f7 8a				jp .mloop 
8b8c			 
8b8c			.goback: 
8b8c 3e 00			ld a, 0 
8b8e 18 1d			jr .goend2 
8b90			 
8b90				; move up one 
8b90			.mgoup: 
8b90 3a 71 ea				ld a, (store_tmp2) 
8b93 fe 00				cp 0 
8b95 ca f7 8a				jp z, .mloop 
8b98 3d					dec a 
8b99 32 71 ea				ld (store_tmp2), a 
8b9c c3 f7 8a				jp .mloop 
8b9f			 
8b9f				; move down one 
8b9f			.mgod: 
8b9f 3a 71 ea				ld a, (store_tmp2) 
8ba2 3c					inc a 
8ba3 32 71 ea				ld (store_tmp2), a 
8ba6 c3 f7 8a				jp .mloop 
8ba9			 
8ba9			 
8ba9			.goend: 
8ba9					; get selected item number 
8ba9			 
8ba9 3a 71 ea				ld a, (store_tmp2) 
8bac 3c					inc a 
8bad			 
8bad			.goend2: 
8bad f5					push af 
8bae			 
8bae					; restore active fb 
8bae					; TODO BUG assumes fb1 
8bae			 
8bae 21 10 ed				ld hl, display_fb1 
8bb1 22 cc eb				ld (display_fb_active), hl 
8bb4			 
8bb4					; restore main regs 
8bb4			 
8bb4			 
8bb4 cd dd 8a				call update_display 
8bb7			 
8bb7 f1					pop af 
8bb8			 
8bb8 c9				ret 
8bb9			 
8bb9 .. 00		.msel:   db ">",0 
8bbb .. 00		.mup:   db "^",0 
8bbd .. 00		.mdown:   db "v",0 
8bbf			 
8bbf			 
8bbf			; eof 
8bbf			 
# End of file firmware_display.asm
8bbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bbf			; random number generators 
8bbf			 
8bbf			 
8bbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bbf			 
8bbf			 
8bbf			;-----> Generate a random number 
8bbf			; output a=answer 0<=a<=255 
8bbf			; all registers are preserved except: af 
8bbf			random: 
8bbf e5			        push    hl 
8bc0 d5			        push    de 
8bc1 2a ab eb		        ld      hl,(randData) 
8bc4 ed 5f		        ld      a,r 
8bc6 57			        ld      d,a 
8bc7 5e			        ld      e,(hl) 
8bc8 19			        add     hl,de 
8bc9 85			        add     a,l 
8bca ac			        xor     h 
8bcb 22 ab eb		        ld      (randData),hl 
8bce d1			        pop     de 
8bcf e1			        pop     hl 
8bd0 c9			        ret 
8bd1			 
8bd1			 
8bd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bd1			 
8bd1			 
8bd1			 
8bd1			;------LFSR------ 
8bd1			;James Montelongo 
8bd1			;optimized by Spencer Putt 
8bd1			;out: 
8bd1			; a = 8 bit random number 
8bd1			RandLFSR: 
8bd1 21 b1 eb		        ld hl,LFSRSeed+4 
8bd4 5e			        ld e,(hl) 
8bd5 23			        inc hl 
8bd6 56			        ld d,(hl) 
8bd7 23			        inc hl 
8bd8 4e			        ld c,(hl) 
8bd9 23			        inc hl 
8bda 7e			        ld a,(hl) 
8bdb 47			        ld b,a 
8bdc cb 13		        rl e  
8bde cb 12			rl d 
8be0 cb 11		        rl c  
8be2 17				rla 
8be3 cb 13		        rl e  
8be5 cb 12			rl d 
8be7 cb 11		        rl c  
8be9 17				rla 
8bea cb 13		        rl e  
8bec cb 12			rl d 
8bee cb 11		        rl c  
8bf0 17				rla 
8bf1 67			        ld h,a 
8bf2 cb 13		        rl e  
8bf4 cb 12			rl d 
8bf6 cb 11		        rl c  
8bf8 17				rla 
8bf9 a8			        xor b 
8bfa cb 13		        rl e  
8bfc cb 12			rl d 
8bfe ac			        xor h 
8bff a9			        xor c 
8c00 aa			        xor d 
8c01 21 b3 eb		        ld hl,LFSRSeed+6 
8c04 11 b4 eb		        ld de,LFSRSeed+7 
8c07 01 07 00		        ld bc,7 
8c0a ed b8		        lddr 
8c0c 12			        ld (de),a 
8c0d c9			        ret 
8c0e			 
8c0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c0e			 
8c0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c0e			 
8c0e			 
8c0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c0e			 
8c0e			prng16: 
8c0e			;Inputs: 
8c0e			;   (seed1) contains a 16-bit seed value 
8c0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c0e			;Outputs: 
8c0e			;   HL is the result 
8c0e			;   BC is the result of the LCG, so not that great of quality 
8c0e			;   DE is preserved 
8c0e			;Destroys: 
8c0e			;   AF 
8c0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c0e			;160cc 
8c0e			;26 bytes 
8c0e 2a a5 eb		    ld hl,(seed1) 
8c11 44			    ld b,h 
8c12 4d			    ld c,l 
8c13 29			    add hl,hl 
8c14 29			    add hl,hl 
8c15 2c			    inc l 
8c16 09			    add hl,bc 
8c17 22 a5 eb		    ld (seed1),hl 
8c1a 2a a3 eb		    ld hl,(seed2) 
8c1d 29			    add hl,hl 
8c1e 9f			    sbc a,a 
8c1f e6 2d		    and %00101101 
8c21 ad			    xor l 
8c22 6f			    ld l,a 
8c23 22 a3 eb		    ld (seed2),hl 
8c26 09			    add hl,bc 
8c27 c9			    ret 
8c28			 
8c28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c28			 
8c28			rand32: 
8c28			;Inputs: 
8c28			;   (seed1_0) holds the lower 16 bits of the first seed 
8c28			;   (seed1_1) holds the upper 16 bits of the first seed 
8c28			;   (seed2_0) holds the lower 16 bits of the second seed 
8c28			;   (seed2_1) holds the upper 16 bits of the second seed 
8c28			;   **NOTE: seed2 must be non-zero 
8c28			;Outputs: 
8c28			;   HL is the result 
8c28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c28			;Destroys: 
8c28			;   AF 
8c28			;Tested and passes all CAcert tests 
8c28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c28			;it has a period of 18,446,744,069,414,584,320 
8c28			;roughly 18.4 quintillion. 
8c28			;LFSR taps: 0,2,6,7  = 11000101 
8c28			;291cc 
8c28			;seed1_0=$+1 
8c28			;    ld hl,12345 
8c28			;seed1_1=$+1 
8c28			;    ld de,6789 
8c28			;    ld b,h 
8c28			;    ld c,l 
8c28			;    add hl,hl \ rl e \ rl d 
8c28			;    add hl,hl \ rl e \ rl d 
8c28			;    inc l 
8c28			;    add hl,bc 
8c28			;    ld (seed1_0),hl 
8c28			;    ld hl,(seed1_1) 
8c28			;    adc hl,de 
8c28			;    ld (seed1_1),hl 
8c28			;    ex de,hl 
8c28			;seed2_0=$+1 
8c28			;    ld hl,9876 
8c28			;seed2_1=$+1 
8c28			;    ld bc,54321 
8c28			;    add hl,hl \ rl c \ rl b 
8c28			;    ld (seed2_1),bc 
8c28			;    sbc a,a 
8c28			;    and %11000101 
8c28			;    xor l 
8c28			;    ld l,a 
8c28			;    ld (seed2_0),hl 
8c28			;    ex de,hl 
8c28			;    add hl,bc 
8c28			;    ret 
8c28			; 
8c28			 
8c28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c28			; 20 bytes, 86 cycles (excluding ret) 
8c28			 
8c28			; returns   hl = pseudorandom number 
8c28			; corrupts   a 
8c28			 
8c28			; generates 16-bit pseudorandom numbers with a period of 65535 
8c28			; using the xorshift method: 
8c28			 
8c28			; hl ^= hl << 7 
8c28			; hl ^= hl >> 9 
8c28			; hl ^= hl << 8 
8c28			 
8c28			; some alternative shift triplets which also perform well are: 
8c28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c28			 
8c28			;  org 32768 
8c28			 
8c28			xrnd: 
8c28 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c2b 3e 00		  ld a,0 
8c2d bd			  cp l 
8c2e 20 02		  jr nz, .xrnd1 
8c30 2e 01		  ld l, 1 
8c32			.xrnd1: 
8c32			 
8c32 7c			  ld a,h 
8c33 1f			  rra 
8c34 7d			  ld a,l 
8c35 1f			  rra 
8c36 ac			  xor h 
8c37 67			  ld h,a 
8c38 7d			  ld a,l 
8c39 1f			  rra 
8c3a 7c			  ld a,h 
8c3b 1f			  rra 
8c3c ad			  xor l 
8c3d 6f			  ld l,a 
8c3e ac			  xor h 
8c3f 67			  ld h,a 
8c40			 
8c40 22 a9 eb		  ld (xrandc),hl 
8c43			 
8c43 c9			  ret 
8c44			;  
8c44			 
8c44			 
8c44			;;;; int maths 
8c44			 
8c44			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c44			; Divide 16-bit values (with 16-bit result) 
8c44			; In: Divide BC by divider DE 
8c44			; Out: BC = result, HL = rest 
8c44			; 
8c44			Div16: 
8c44 21 00 00		    ld hl,0 
8c47 78			    ld a,b 
8c48 06 08		    ld b,8 
8c4a			Div16_Loop1: 
8c4a 17			    rla 
8c4b ed 6a		    adc hl,hl 
8c4d ed 52		    sbc hl,de 
8c4f 30 01		    jr nc,Div16_NoAdd1 
8c51 19			    add hl,de 
8c52			Div16_NoAdd1: 
8c52 10 f6		    djnz Div16_Loop1 
8c54 17			    rla 
8c55 2f			    cpl 
8c56 47			    ld b,a 
8c57 79			    ld a,c 
8c58 48			    ld c,b 
8c59 06 08		    ld b,8 
8c5b			Div16_Loop2: 
8c5b 17			    rla 
8c5c ed 6a		    adc hl,hl 
8c5e ed 52		    sbc hl,de 
8c60 30 01		    jr nc,Div16_NoAdd2 
8c62 19			    add hl,de 
8c63			Div16_NoAdd2: 
8c63 10 f6		    djnz Div16_Loop2 
8c65 17			    rla 
8c66 2f			    cpl 
8c67 41			    ld b,c 
8c68 4f			    ld c,a 
8c69 c9			ret 
8c6a			 
8c6a			 
8c6a			;http://z80-heaven.wikidot.com/math 
8c6a			; 
8c6a			;Inputs: 
8c6a			;     DE and A are factors 
8c6a			;Outputs: 
8c6a			;     A is not changed 
8c6a			;     B is 0 
8c6a			;     C is not changed 
8c6a			;     DE is not changed 
8c6a			;     HL is the product 
8c6a			;Time: 
8c6a			;     342+6x 
8c6a			; 
8c6a			Mult16: 
8c6a			 
8c6a 06 08		     ld b,8          ;7           7 
8c6c 21 00 00		     ld hl,0         ;10         10 
8c6f 29			       add hl,hl     ;11*8       88 
8c70 07			       rlca          ;4*8        32 
8c71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c73 19			         add hl,de   ;--         -- 
8c74 10 f9		       djnz $-5      ;13*7+8     99 
8c76 c9			ret 
8c77			 
8c77			; 
8c77			; Square root of 16-bit value 
8c77			; In:  HL = value 
8c77			; Out:  D = result (rounded down) 
8c77			; 
8c77			;Sqr16: 
8c77			;    ld de,#0040 
8c77			;    ld a,l 
8c77			;    ld l,h 
8c77			;    ld h,d 
8c77			;    or a 
8c77			;    ld b,8 
8c77			;Sqr16_Loop: 
8c77			;    sbc hl,de 
8c77			;    jr nc,Sqr16_Skip 
8c77			;    add hl,de 
8c77			;Sqr16_Skip: 
8c77			;    ccf 
8c77			;    rl d 
8c77			;    add a,a 
8c77			;    adc hl,hl 
8c77			;    add a,a 
8c77			;    adc hl,hl 
8c77			;    djnz Sqr16_Loop 
8c77			;    ret 
8c77			; 
8c77			; 
8c77			; Divide 8-bit values 
8c77			; In: Divide E by divider C 
8c77			; Out: A = result, B = rest 
8c77			; 
8c77			Div8: 
8c77 af			    xor a 
8c78 06 08		    ld b,8 
8c7a			Div8_Loop: 
8c7a cb 13		    rl e 
8c7c 17			    rla 
8c7d 91			    sub c 
8c7e 30 01		    jr nc,Div8_NoAdd 
8c80 81			    add a,c 
8c81			Div8_NoAdd: 
8c81 10 f7		    djnz Div8_Loop 
8c83 47			    ld b,a 
8c84 7b			    ld a,e 
8c85 17			    rla 
8c86 2f			    cpl 
8c87 c9			    ret 
8c88			 
8c88			; 
8c88			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c88			; In: Multiply A with DE 
8c88			; Out: HL = result 
8c88			; 
8c88			Mult12U: 
8c88 2e 00		    ld l,0 
8c8a 87			    add a,a 
8c8b 30 01		    jr nc,Mult12U_NoAdd0 
8c8d 19			    add hl,de 
8c8e			Mult12U_NoAdd0: 
8c8e 29			    add hl,hl 
8c8f 87			    add a,a 
8c90 30 01		    jr nc,Mult12U_NoAdd1 
8c92 19			    add hl,de 
8c93			Mult12U_NoAdd1: 
8c93 29			    add hl,hl 
8c94 87			    add a,a 
8c95 30 01		    jr nc,Mult12U_NoAdd2 
8c97 19			    add hl,de 
8c98			Mult12U_NoAdd2: 
8c98 29			    add hl,hl 
8c99 87			    add a,a 
8c9a 30 01		    jr nc,Mult12U_NoAdd3 
8c9c 19			    add hl,de 
8c9d			Mult12U_NoAdd3: 
8c9d 29			    add hl,hl 
8c9e 87			    add a,a 
8c9f 30 01		    jr nc,Mult12U_NoAdd4 
8ca1 19			    add hl,de 
8ca2			Mult12U_NoAdd4: 
8ca2 29			    add hl,hl 
8ca3 87			    add a,a 
8ca4 30 01		    jr nc,Mult12U_NoAdd5 
8ca6 19			    add hl,de 
8ca7			Mult12U_NoAdd5: 
8ca7 29			    add hl,hl 
8ca8 87			    add a,a 
8ca9 30 01		    jr nc,Mult12U_NoAdd6 
8cab 19			    add hl,de 
8cac			Mult12U_NoAdd6: 
8cac 29			    add hl,hl 
8cad 87			    add a,a 
8cae d0			    ret nc 
8caf 19			    add hl,de 
8cb0 c9			    ret 
8cb1			 
8cb1			; 
8cb1			; Multiply 8-bit value with a 16-bit value (right rotating) 
8cb1			; In: Multiply A with DE 
8cb1			;      Put lowest value in A for most efficient calculation 
8cb1			; Out: HL = result 
8cb1			; 
8cb1			Mult12R: 
8cb1 21 00 00		    ld hl,0 
8cb4			Mult12R_Loop: 
8cb4 cb 3f		    srl a 
8cb6 30 01		    jr nc,Mult12R_NoAdd 
8cb8 19			    add hl,de 
8cb9			Mult12R_NoAdd: 
8cb9 cb 23		    sla e 
8cbb cb 12		    rl d 
8cbd b7			    or a 
8cbe c2 b4 8c		    jp nz,Mult12R_Loop 
8cc1 c9			    ret 
8cc2			 
8cc2			; 
8cc2			; Multiply 16-bit values (with 32-bit result) 
8cc2			; In: Multiply BC with DE 
8cc2			; Out: BCHL = result 
8cc2			; 
8cc2			Mult32: 
8cc2 79			    ld a,c 
8cc3 48			    ld c,b 
8cc4 21 00 00		    ld hl,0 
8cc7 06 10		    ld b,16 
8cc9			Mult32_Loop: 
8cc9 29			    add hl,hl 
8cca 17			    rla 
8ccb cb 11		    rl c 
8ccd 30 07		    jr nc,Mult32_NoAdd 
8ccf 19			    add hl,de 
8cd0 ce 00		    adc a,0 
8cd2 d2 d6 8c		    jp nc,Mult32_NoAdd 
8cd5 0c			    inc c 
8cd6			Mult32_NoAdd: 
8cd6 10 f1		    djnz Mult32_Loop 
8cd8 41			    ld b,c 
8cd9 4f			    ld c,a 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			; 
8cdb			; Multiply 8-bit values 
8cdb			; In:  Multiply H with E 
8cdb			; Out: HL = result 
8cdb			; 
8cdb			Mult8: 
8cdb 16 00		    ld d,0 
8cdd 6a			    ld l,d 
8cde 06 08		    ld b,8 
8ce0			Mult8_Loop: 
8ce0 29			    add hl,hl 
8ce1 30 01		    jr nc,Mult8_NoAdd 
8ce3 19			    add hl,de 
8ce4			Mult8_NoAdd: 
8ce4 10 fa		    djnz Mult8_Loop 
8ce6 c9			    ret 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			;;http://z80-heaven.wikidot.com/math 
8ce7			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ce7			; 
8ce7			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ce7			;     ld a,16        ;7 
8ce7			;     ld hl,0        ;10 
8ce7			;     jp $+5         ;10 
8ce7			;.DivLoop: 
8ce7			;       add hl,bc    ;-- 
8ce7			;       dec a        ;64 
8ce7			;       jr z,.DivLoopEnd        ;86 
8ce7			; 
8ce7			;       sla e        ;128 
8ce7			;       rl d         ;128 
8ce7			;       adc hl,hl    ;240 
8ce7			;       sbc hl,bc    ;240 
8ce7			;       jr nc,.DivLoop ;23|21 
8ce7			;       inc e        ;-- 
8ce7			;       jp .DivLoop+1 
8ce7			; 
8ce7			;.DivLoopEnd: 
8ce7			 
8ce7			;HL_Div_C: 
8ce7			;Inputs: 
8ce7			;     HL is the numerator 
8ce7			;     C is the denominator 
8ce7			;Outputs: 
8ce7			;     A is the remainder 
8ce7			;     B is 0 
8ce7			;     C is not changed 
8ce7			;     DE is not changed 
8ce7			;     HL is the quotient 
8ce7			; 
8ce7			;       ld b,16 
8ce7			;       xor a 
8ce7			;         add hl,hl 
8ce7			;         rla 
8ce7			;         cp c 
8ce7			;         jr c,$+4 
8ce7			;           inc l 
8ce7			;           sub c 
8ce7			;         djnz $-7 
8ce7			 
8ce7			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ce7			 
8ce7			addatohl: 
8ce7 85			    add   a, l    ; A = A+L 
8ce8 6f			    ld    l, a    ; L = A+L 
8ce9 8c			    adc   a, h    ; A = A+L+H+carry 
8cea 95			    sub   l       ; A = H+carry 
8ceb 67			    ld    h, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			addatode: 
8ced 83			    add   a, e    ; A = A+L 
8cee 5f			    ld    e, a    ; L = A+L 
8cef 8a			    adc   a, d    ; A = A+L+H+carry 
8cf0 93			    sub   e       ; A = H+carry 
8cf1 57			    ld    d, a    ; H = H+carry 
8cf2 c9			ret 
8cf3			 
8cf3			 
8cf3			addatobc: 
8cf3 81			    add   a, c    ; A = A+L 
8cf4 4f			    ld    c, a    ; L = A+L 
8cf5 88			    adc   a, b    ; A = A+L+H+carry 
8cf6 91			    sub   c       ; A = H+carry 
8cf7 47			    ld    b, a    ; H = H+carry 
8cf8 c9			ret 
8cf9			 
8cf9			subafromhl: 
8cf9			   ; If A=0 do nothing 
8cf9			    ; Otherwise flip A's sign. Since 
8cf9			    ; the upper byte becomes -1, also 
8cf9			    ; substract 1 from H. 
8cf9 ed 44		    neg 
8cfb ca 04 8d		    jp    z, Skip 
8cfe 25			    dec   h 
8cff			     
8cff			    ; Now add the low byte as usual 
8cff			    ; Two's complement takes care of 
8cff			    ; ensuring the result is correct 
8cff 85			    add   a, l 
8d00 6f			    ld    l, a 
8d01 8c			    adc   a, h 
8d02 95			    sub   l 
8d03 67			    ld    h, a 
8d04			Skip: 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; compare hl and de 
8d05			; returns:  
8d05			; if hl = de, z=1, s=0, c0=0 
8d05			; if hl > de, z=0, s=0, c=0 
8d05			; if hl < de, z=0, s=1, c=1 
8d05			cmp16:	 
8d05 b7				or a 
8d06 ed 52			sbc hl,de 
8d08 e0				ret po 
8d09 7c				ld a,h 
8d0a 1f				rra 
8d0b ee 40			xor 01000000B 
8d0d 37				scf 
8d0e 8f				adc a,a 
8d0f c9				ret 
8d10			 
8d10			 
8d10			; test if hl contains zero   - A is destroyed 
8d10			 
8d10			ishlzero:    
8d10 b7				or a     ; reset flags 
8d11 7c				ld a, h 
8d12 b5				or l        	 
8d13			 
8d13 c9				ret 
8d14			 
8d14			 
8d14			 
8d14			 
8d14			if FORTH_ENABLE_FLOATMATH 
8d14			;include "float/bbcmath.z80" 
8d14			include "float/lpfpcalc.asm" 
8d14			endif 
8d14			 
8d14			 
8d14			; eof 
8d14			 
# End of file firmware_maths.asm
8d14			include "firmware_strings.asm"   ; string handling  
8d14			 
8d14			 
8d14			; TODO string len 
8d14			; input text string, end on cr with zero term 
8d14			; a offset into frame buffer to start prompt 
8d14			; d is max length 
8d14			; e is display size TODO 
8d14			; c is current cursor position 
8d14			; hl is ptr to where string will be stored and edited directly 
8d14			 
8d14			 
8d14			; TODO check limit of buffer for new inserts 
8d14			; TODO check insert does not push beyond buffer 
8d14			; TODO scroll in a limited display area 
8d14			; TODO scroll whole screen on page wrap 
8d14			 
8d14			 
8d14			; TODO use LCD cursor? 
8d14			 
8d14			EDIT_V1: equ 0 
8d14			EDIT_V2: equ 1 
8d14			 
8d14			 
8d14			 
8d14			if EDIT_V2 
8d14			input_str: 
8d14			 
8d14 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8d17			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d17 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d1a			;		ld a, c 
8d1a			;		call addatohl 
8d1a			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d22 7b					ld a,e 
8d23 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26			 
8d26			 
8d26					; add a trailing space to make screen refresh nicer 
8d26			 
8d26					;ld hl, (input_start) 
8d26					;push hl 
8d26					;ld a, 0 
8d26					;call strlent 
8d26					;ld a, l 
8d26					;pop hl 
8d26					;call addatohl 
8d26					;dec hl 
8d26					;ld a, ' ' 
8d26					;ld (hl), a 
8d26					;inc hl 
8d26					;ld (hl), a 
8d26					;inc hl 
8d26					;ld a, 0 
8d26					;ld (hl), a 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c1 eb				ld hl, cursor_shape 
8d29			if BASE_KEV 
8d29					ld a, 255 
8d29			else 
8d29 3e 23				ld a, '#' 
8d2b			endif 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 09				ld a, CUR_BLINK_RATE 
8d32 32 60 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 5f ee				ld (input_cur_onoff),a 
8d3a			.inmain:	 
8d3a			 
8d3a cd 62 8e				call input_disp_ref 
8d3d			 
8d3d					; save current length of string 
8d3d			 
8d3d 2a 67 ee				ld hl, (input_start) 
8d40 3e 00				ld a, 0 
8d42 cd 58 90				call strlent 
8d45 7d					ld a,l 
8d46 32 5a ee				ld (input_len), a 
8d49			 
8d49					;call input_disp_oncur 
8d49			 
8d49					; display current state of input buffer 
8d49			 
8d49					; clean any backspace chars 
8d49			 
8d49 3e 20				ld a, " " 
8d4b 32 c1 e2				ld (scratch),a 
8d4e 3e 00				ld a, 0 
8d50 32 c2 e2				ld (scratch+1),a 
8d53 3a 64 ee				ld a,(input_at_pos) 
8d56 85					add l 
8d57 11 c1 e2				ld de, scratch 
8d5a cd cd 8a				call str_at_display 
8d5d			 
8d5d					; pause 1ms 
8d5d			 
8d5d 3e 01				ld a, 1 
8d5f cd e2 89				call aDelayInMS 
8d62			 
8d62			; display cursor if visible on this cycle 
8d62			 
8d62					; dec flash counter 
8d62 3a 60 ee				ld a, (input_cur_flash) 
8d65 3d					dec a 
8d66 32 60 ee				ld (input_cur_flash), a 
8d69 fe 00				cp 0 
8d6b 20 0d				jr nz, .inochgstate 
8d6d			 
8d6d			 
8d6d					; reset on change of state 
8d6d 3e 09				ld a, CUR_BLINK_RATE 
8d6f 32 60 ee				ld (input_cur_flash), a 
8d72			 
8d72					; change state 
8d72 3a 5f ee				ld a,(input_cur_onoff) 
8d75 ed 44				neg 
8d77 32 5f ee				ld (input_cur_onoff),a 
8d7a			 
8d7a			 
8d7a			 
8d7a			 
8d7a					; TODO is cursor visible? 
8d7a					; TODO if so then over write the char at curspos pos with the cursor shape 
8d7a			 
8d7a								 
8d7a			 
8d7a			.inochgstate: 
8d7a 3a 5f ee				ld a,(input_cur_onoff) 
8d7d fe ff				cp 255 
8d7f 28 0e				jr z, .skipcursor 
8d81 3a 64 ee				ld a, (input_at_pos) 
8d84 47					ld b, a 
8d85 3a 55 ee				ld a, (input_cursor) 
8d88 80					add b 
8d89 11 c1 eb				ld de, cursor_shape 
8d8c					 
8d8c cd cd 8a				call str_at_display 
8d8f			 
8d8f			.skipcursor: 
8d8f				if DEBUG_INPUTV2 
8d8f			 
8d8f					ld a,(input_at_pos) 
8d8f					ld hl, LFSRSeed 
8d8f					call hexout 
8d8f					ld a, (input_cursor) 
8d8f					ld hl, LFSRSeed+2 
8d8f					call hexout 
8d8f					ld a,(input_size) 
8d8f					ld hl, LFSRSeed+4 
8d8f					call hexout 
8d8f			 
8d8f					ld a,(input_cur_onoff) 
8d8f					ld hl, LFSRSeed+6 
8d8f					call hexout 
8d8f			 
8d8f					ld a,(input_cur_flash) 
8d8f					ld hl, LFSRSeed+8 
8d8f					call hexout 
8d8f			 
8d8f					ld a,(input_len) 
8d8f					ld hl, LFSRSeed+10 
8d8f					call hexout 
8d8f					ld hl, LFSRSeed+12 
8d8f					ld a, 0 
8d8f					ld (hl),a 
8d8f					ld a, display_row_4 
8d8f					ld de, LFSRSeed 
8d8f					call str_at_display 
8d8f				endif 
8d8f cd dd 8a				call update_display 
8d92			 
8d92					; TODO keyboard processing 
8d92			 
8d92			if BASE_CPM 
8d92					call cin_wait 
8d92			else 
8d92 cd 23 dd				call cin    ; _wait 
8d95			endif 
8d95 fe 00				cp 0 
8d97 ca 3a 8d				jp z, .inmain 
8d9a			 
8d9a fe 0b				cp KEY_LEFT    ; cursor left 
8d9c ca 54 8e				jp z, input_left 
8d9f				 
8d9f fe 0c				cp KEY_RIGHT      ; cursor right 
8da1 ca 5b 8e				jp z, input_right 
8da4			 
8da4 fe 0d				cp KEY_CR 
8da6 c8					ret z 
8da7			 
8da7 fe 08				cp KEY_BS 
8da9 ca c9 8e				jp z, input_delchar 
8dac			 
8dac fe 06				cp KEY_NEXTWORD 
8dae ca d5 8d				jp z, input_nxtword 
8db1			 
8db1 fe 07				cp KEY_PREVWORD 
8db3 ca fc 8d				jp z, input_prvword 
8db6			 
8db6 fe 0e				cp KEY_HOME    ; jump to start of line 
8db8 20 08				jr nz, .ikh 
8dba 3e 00				ld a, 0 
8dbc 32 55 ee				ld (input_cursor), a 
8dbf ca 3a 8d				jp z, .inmain 
8dc2			.ikh: 
8dc2			 
8dc2 fe 0f				cp KEY_END     ; jump to end of line 
8dc4 20 09				jr nz, .ike 
8dc6 3a 5a ee				ld a, (input_len) 
8dc9 32 55 ee				ld (input_cursor),a 
8dcc ca 3a 8d				jp z, .inmain 
8dcf			.ike: 
8dcf fe 05			        cp KEY_UP      ; recall last command 
8dd1 c8					ret z 
8dd2			;jr nz, .irec 
8dd2			; TODO next word 
8dd2			; TODO prev word 
8dd2			;  
8dd2			; 
8dd2			;	ld hl, scratch 
8dd2			;	ld de, os_last_cmd 
8dd2			;	call strcpy 
8dd2			;		jp  .inmain 
8dd2			.irec: 
8dd2			;		jr .instr1 
8dd2			 
8dd2			 
8dd2			 
8dd2					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dd2			 
8dd2			; TODO return if any special keys are given 
8dd2			;		ld l, a 
8dd2			;		ld a, 28 ; KEY_F12   ; 27 
8dd2			;		sub l 
8dd2			;		ret m 
8dd2			;		ld a, l 
8dd2					; if no special key then insert as a char 
8dd2			 
8dd2 c3 9b 8e				jp input_inschr 
8dd5			 
8dd5				 
8dd5			input_nxtword: 
8dd5				; jump to start next word after the cursor 
8dd5			 
8dd5			.insknwn:	 
8dd5 cd 91 8e				call input_curptr	 
8dd8 7e					ld a,(hl)	 
8dd9 fe 00				cp 0 
8ddb ca 3a 8d				jp z, .inmain    ; end of string 
8dde			 
8dde			; if we are on a word, then move off of it 
8dde			 
8dde fe 20				cp ' ' 
8de0 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8de2 21 55 ee				ld hl, input_cursor 
8de5 34					inc (hl) 
8de6 18 ed				jr .insknwn 
8de8			 
8de8			.inspace: 
8de8			 
8de8 cd 91 8e				call input_curptr	 
8deb 7e					ld a,(hl)	 
8dec fe 00				cp 0 
8dee ca 3a 8d				jp z, .inmain    ; end of string 
8df1			 
8df1			; if we are on a word, then move off of it 
8df1			 
8df1 fe 20				cp ' ' 
8df3 c2 3a 8d				jp nz, .inmain     ; we are on non space so at next word 
8df6 21 55 ee				ld hl, input_cursor 
8df9 34					inc (hl) 
8dfa 18 ec				jr .inspace 
8dfc			 
8dfc			 
8dfc			 
8dfc			 
8dfc			input_prvword: 
8dfc				; jump to the start of previous word before the cursor 
8dfc			 
8dfc			; where are we to start with currently? 
8dfc			 
8dfc cd 91 8e				call input_curptr	 
8dff 7e					ld a, (hl) 
8e00 fe 20				cp ' ' 
8e02 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e04			 
8e04			 
8e04			 
8e04			.inskpwn:	 
8e04 3a 55 ee				ld a,(input_cursor) 
8e07 fe 00				cp 0 
8e09 ca 3a 8d				jp z, .inmain    ; start of string 
8e0c			 
8e0c			;if we are on a word, then move off of it 
8e0c			 
8e0c cd 91 8e				call input_curptr	 
8e0f 7e					ld a, (hl) 
8e10 fe 20				cp ' ' 
8e12 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e14					;jp z, .inmain    ; start of string 
8e14 21 55 ee				ld hl, input_cursor 
8e17 35					dec (hl) 
8e18 18 ea				jr .inskpwn 
8e1a			.iwstart: 
8e1a 21 55 ee				ld hl, input_cursor 
8e1d 34					inc (hl) 
8e1e c3 3a 8d				jp .inmain 
8e21					 
8e21			 
8e21			.inspacep: 
8e21			 
8e21					;jp .inmain    ; start of string 
8e21			 
8e21			 
8e21			 
8e21 3a 55 ee				ld a,(input_cursor) 
8e24 fe 00				cp 0 
8e26 ca 3a 8d				jp z, .inmain    ; start of string 
8e29			 
8e29			; if we are on a word, then move off of it 
8e29			 
8e29 cd 91 8e				call input_curptr	 
8e2c 7e					ld a, (hl) 
8e2d fe 20				cp ' ' 
8e2f c2 38 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e32 21 55 ee				ld hl, input_cursor 
8e35 35					dec (hl) 
8e36 18 e9				jr .inspacep 
8e38			 
8e38			 
8e38			.incharp:	 
8e38					; eat the word to get to the start 
8e38 3a 55 ee				ld a,(input_cursor) 
8e3b fe 00				cp 0 
8e3d ca 3a 8d				jp z, .inmain    ; start of string 
8e40			 
8e40			; if we are on a word, then move off of it 
8e40			 
8e40 cd 91 8e				call input_curptr	 
8e43 7e					ld a, (hl) 
8e44 fe 20				cp ' ' 
8e46 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e48 21 55 ee				ld hl, input_cursor 
8e4b 35					dec (hl) 
8e4c 18 ea				jr .incharp 
8e4e			.ipwordst: 
8e4e					; at space before the prev word so reposition over it 
8e4e 21 55 ee				ld hl, input_cursor 
8e51 34					inc (hl) 
8e52 18 b0				jr .inskpwn 
8e54					 
8e54			 
8e54			 
8e54			input_left: 
8e54				; move cursor left 
8e54 21 55 ee			ld hl, input_cursor 
8e57 35				dec (hl) 
8e58			;	cp 0 
8e58			;	jp z, .inmain    ; ignore left as at the start of the string 
8e58 c3 3a 8d			jp .inmain 
8e5b			 
8e5b			input_right: 
8e5b				; move cursor right 
8e5b				 
8e5b				;ld a, (input_size) 
8e5b				;ld b, a 
8e5b 21 55 ee			ld hl, input_cursor 
8e5e 34				inc (hl) 
8e5f				;dec b 
8e5f				;cp 0 
8e5f				;jp z, .inmain   ; ignore as at end of the string buffer 
8e5f				;ld a, b 
8e5f				;inc a 
8e5f				;ld (input_cursor), a 
8e5f c3 3a 8d			jp .inmain 
8e62			 
8e62			 
8e62			 
8e62			input_disp_ref: 
8e62				; display the text from start of buffer (ie full refresh) 
8e62 3a 64 ee			ld a, (input_at_pos) 
8e65 2a 67 ee			ld hl,(input_start) 
8e68 eb				ex de, hl 
8e69 cd cd 8a			call str_at_display  
8e6c c9				ret 
8e6d			input_disp_oncur: 
8e6d				; display the text from cursor position to end of buffer 
8e6d				; TODO position start of string at cursor position on screen 
8e6d				; TODO draw from that point on 
8e6d 3a 55 ee			ld a, (input_cursor) 
8e70 47				ld b, a 
8e71 3a 64 ee			ld a, (input_at_pos) 
8e74 80				add b 
8e75 48				ld c, b     ; save a 
8e76 78				ld a, b     ; inc string start for cursor 
8e77 2a 67 ee			ld hl,(input_start) 
8e7a cd e7 8c			call addatohl 
8e7d eb				ex de, hl 
8e7e 79				ld a, c 
8e7f cd cd 8a			call str_at_display  
8e82 c9				ret 
8e83			 
8e83			input_nxtw: 
8e83				; Find next word 
8e83 c9				ret 
8e84			 
8e84			input_prvw: 
8e84				; Find previous word 
8e84 c9				ret 
8e85			 
8e85			input_lenrem:   
8e85				; Calculate the length of string remaining from current cursor 
8e85				; position to end of buffer (exc null term) 
8e85				 
8e85 3a 55 ee			ld a, (input_cursor) 
8e88 4f				ld c, a 
8e89 3a 66 ee			ld a, (input_size) 
8e8c 91				sub c 
8e8d 06 00			ld b, 0 
8e8f 0d				dec c 
8e90 c9				ret	 
8e91			 
8e91			input_curptr: 
8e91				; calc address of the character under the cursor 
8e91				 
8e91 2a 67 ee			ld hl, (input_start) 
8e94 3a 55 ee			ld a, (input_cursor) 
8e97 cd e7 8c			call addatohl 
8e9a c9				ret 
8e9b			 
8e9b			input_inschr: 
8e9b				; Insert char at cursor position 
8e9b f5				push af   ; save char 
8e9c				;call input_lenrem    ; get bc length of remaining string 
8e9c			 
8e9c				 
8e9c cd 91 8e			call input_curptr 
8e9f			;	ld hl, (input_start) 
8e9f			;	ld a, (input_cursor) 
8e9f			;	call addatohl 
8e9f				;push hl   ; save to come back to 
8e9f			 
8e9f				; shift everything up one to end of buffer 
8e9f			 
8e9f				;push hl 
8e9f				;dec de 
8e9f				;inc de 
8e9f			;	ldir 
8e9f				 
8e9f				;pop hl 
8e9f			 
8e9f				; are we adding to the end of line? 
8e9f			 
8e9f 3a 55 ee			ld a, (input_cursor) 
8ea2 47				ld b, a 
8ea3 3a 5a ee			ld a, (input_len) 
8ea6 b8				cp b 
8ea7 20 09			jr nz, .insmid   ; no, insert in middle of text 
8ea9			 
8ea9				; tack on the end of the line 
8ea9 f1				pop af 
8eaa 77				ld (hl), a   ; save new char 
8eab 23				inc hl 
8eac 3e 00			ld a, 0 
8eae 77				ld (hl), a 
8eaf c3 5b 8e			jp input_right 
8eb2				 
8eb2			.insmid: 
8eb2				; hl has insertion point so move everything up one to allow for insertion 
8eb2				;call input_shiftright 
8eb2 f1				pop af 
8eb3			 
8eb3			.shufinsmid: 
8eb3 47				ld b, a     ; b contains new char, c prev char at this position  
8eb4 7e				ld a, (hl) 
8eb5			 
8eb5 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eb7 28 07			jr z, .endinsmid 
8eb9 4f				ld c, a 
8eba 78				ld a, b 
8ebb 77				ld (hl), a 
8ebc 23				inc hl 
8ebd 79				ld a, c 
8ebe 18 f3			jr .shufinsmid 
8ec0				 
8ec0			 
8ec0			 
8ec0			 
8ec0			.endinsmid: 
8ec0 78				ld a, b 
8ec1 77				ld (hl), a 
8ec2 23				inc hl 
8ec3 3e 00			ld a, 0 
8ec5 77				ld (hl), a 
8ec6			 
8ec6			 
8ec6			;	ld (hl), a   ; save new char 
8ec6			 
8ec6 c3 5b 8e			jp input_right 
8ec9			 
8ec9			;input_shiftright: 
8ec9			;	; shift text right at cursor, hl has shift start 
8ec9			;	push hl 
8ec9			;	push de 
8ec9			;	push bc 
8ec9			; 
8ec9			; 
8ec9			;	; move to end of string past zero term 
8ec9			;	ld hl,(input_start) 
8ec9			;	ld a, (input_len) 
8ec9			;	call addatohl 
8ec9			;	inc hl 
8ec9			;;	inc hl 
8ec9			;;	inc hl 
8ec9			;	ld a, 0 
8ec9			;	ld (hl), a 
8ec9			;;	dec hl 
8ec9			;	 
8ec9			;;	ld (hl), a 
8ec9			;;	dec hl 
8ec9			; 
8ec9			;	push hl 
8ec9			;	pop de 
8ec9			;	inc de 
8ec9			;	 
8ec9			; 
8ec9			;;	ld hl,(input_start) 
8ec9			;;	ld a, (input_cursor) 
8ec9			;;	call addatohl 
8ec9			; 
8ec9			; 
8ec9			;	; calc how many bytes from cursor pos to end of string we need to shift 
8ec9			;	call input_lenrem    ; get bc length of remaining string 
8ec9			;	;ld a, (input_cursor) 
8ec9			;	;ld c, a 
8ec9			;	ld a, (input_len) 
8ec9			;	cp 2 
8ec9			;	jr z, .iskipzero	 
8ec9			;	;sub c 
8ec9			;	;inc a 
8ec9			;	;ld c, a 
8ec9			;	;ld b, 0 
8ec9			;	inc c 
8ec9			;	inc c 
8ec9			;	; move data 
8ec9			;	lddr 
8ec9			;.iskipzero: 
8ec9			; 
8ec9			;	pop bc 
8ec9			;	pop de 
8ec9			;	pop hl 
8ec9			;	ret	 
8ec9			 
8ec9			input_delchar: 
8ec9				; Delete char at cursor position 
8ec9 cd 85 8e			call input_lenrem    ; get bc length of remaining string 
8ecc 2a 67 ee			ld hl, (input_start) 
8ecf 3a 55 ee			ld a, (input_cursor) 
8ed2 cd e7 8c			call addatohl 
8ed5			 
8ed5 e5				push hl 
8ed6 d1				pop de 
8ed7 1b				dec de 
8ed8			 
8ed8			.dl:	 
8ed8 ed a0			ldi  
8eda 7e				ld a, (hl) 
8edb fe 00			cp 0 
8edd 28 02			jr z, .dldone 
8edf 18 f7			jr .dl 
8ee1			.dldone: 
8ee1 ed a0			ldi 
8ee3			 
8ee3 c3 54 8e			jp input_left 
8ee6			 
8ee6			 
8ee6			endif 
8ee6			 
8ee6			 
8ee6			 
8ee6			if EDIT_V1 
8ee6			input_str: 
8ee6			 
8ee6				    	ld (input_at_pos),a      ; save display position to start 
8ee6					add c 
8ee6					ld (input_at_cursor),a	; save draw pos of cursor 
8ee6					ld (input_start), hl     ; save ptr to buffer 
8ee6					ld a, c 
8ee6					call addatohl 
8ee6					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ee6					ld a,d 
8ee6				        ld (input_size), a       ; save length of input area 
8ee6					ld a, c 
8ee6					ld (input_cursor),a      ; init cursor start position  
8ee6					ld a,e 
8ee6				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ee6					 
8ee6					 
8ee6			 
8ee6			;		ld a,(input_ptr) 
8ee6			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ee6			 
8ee6			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ee6					; init cursor shape if not set by the cin routines 
8ee6					ld hl, cursor_shape 
8ee6			if BASE_KEV 
8ee6					ld a, 255 
8ee6			else 
8ee6					ld a, '#' 
8ee6			endif 
8ee6					ld (hl), a 
8ee6					inc hl 
8ee6					ld a, 0 
8ee6					ld (hl), a 
8ee6			 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6					ld a, 1 
8ee6					ld (input_cur_onoff),a 
8ee6			 
8ee6			;	if DEBUG_INPUT 
8ee6			;		push af 
8ee6			;		ld a, 'I' 
8ee6			;		ld (debug_mark),a 
8ee6			;		pop af 
8ee6			;		CALLMONITOR 
8ee6			;	endif 
8ee6			.is1:		; main entry loop 
8ee6			 
8ee6			 
8ee6			 
8ee6					; pause 1ms 
8ee6			 
8ee6					ld a, 1 
8ee6					call aDelayInMS 
8ee6			 
8ee6					; dec flash counter 
8ee6					ld a, (input_cur_flash) 
8ee6					dec a 
8ee6					ld (input_cur_flash), a 
8ee6					cp 0 
8ee6					jr nz, .nochgstate 
8ee6			 
8ee6			 
8ee6					; change state 
8ee6					ld a,(input_cur_onoff) 
8ee6					neg 
8ee6					ld (input_cur_onoff),a 
8ee6			 
8ee6			 
8ee6					; reset on change of state 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6			.nochgstate: 
8ee6					 
8ee6					 
8ee6			 
8ee6					; display cursor  
8ee6			 
8ee6			;		ld hl, (input_start) 
8ee6			;		ld a, (input_cursor) 
8ee6			;		call addatohl 
8ee6			 
8ee6					; get char under cursor and replace with cursor 
8ee6			ld hl, (input_ptr) 
8ee6			;		ld a, (hl) 
8ee6			;		ld (input_under_cursor),a 
8ee6			;		ld a, '_' 
8ee6			;		ld (hl), a 
8ee6			 
8ee6					; display string 
8ee6			 
8ee6					ld de, (input_start) 
8ee6					ld a, (input_at_pos) 
8ee6					call str_at_display 
8ee6			;	        call update_display 
8ee6			 
8ee6					; find place to put the cursor 
8ee6			;		add h 
8ee6			;		ld l, display_row_1 
8ee6			;		sub l 
8ee6			; (input_at_pos) 
8ee6					;ld c, a 
8ee6			;		ld a, (input_cursor) 
8ee6			;		ld l, (input_at_pos) 
8ee6			;		;ld b, h 
8ee6			;		add l 
8ee6			;		ld (input_at_cursor),a 
8ee6					;ld l,h 
8ee6			 
8ee6			;		ld h, 0 
8ee6			;		ld l,(input_at_pos) 
8ee6			;		ld a, (input_cursor) 
8ee6			;		call addatohl 
8ee6			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ee6			;		call subafromhl 
8ee6			;		ld a,l 
8ee6			;		ld (input_at_cursor), a 
8ee6			 
8ee6				if DEBUG_INPUT 
8ee6					ld a, (hardware_diag) 
8ee6					cp 0 
8ee6					jr z, .skip_input_diag 
8ee6			 
8ee6					ld a,(input_at_pos) 
8ee6					ld hl, LFSRSeed 
8ee6					call hexout 
8ee6					ld a, (input_cursor) 
8ee6					ld hl, LFSRSeed+2 
8ee6					call hexout 
8ee6					ld a,(input_at_cursor) 
8ee6					ld hl, LFSRSeed+4 
8ee6					call hexout 
8ee6			 
8ee6					ld a,(input_cur_onoff) 
8ee6					ld hl, LFSRSeed+6 
8ee6					call hexout 
8ee6			 
8ee6					ld a,(input_cur_flash) 
8ee6					ld hl, LFSRSeed+8 
8ee6					call hexout 
8ee6			 
8ee6					ld a,(input_len) 
8ee6					ld hl, LFSRSeed+10 
8ee6					call hexout 
8ee6					ld hl, LFSRSeed+12 
8ee6					ld a, 0 
8ee6					ld (hl),a 
8ee6					ld a, display_row_4 
8ee6					ld de, LFSRSeed 
8ee6					call str_at_display 
8ee6					.skip_input_diag: 
8ee6				endif 
8ee6			 
8ee6					; decide on if we are showing the cursor this time round 
8ee6			 
8ee6					ld a, (input_cur_onoff) 
8ee6					cp 255 
8ee6					jr z, .skipcur 
8ee6			 
8ee6			 
8ee6					ld a,(input_at_cursor) 
8ee6					ld de, cursor_shape 
8ee6					call str_at_display 
8ee6			 
8ee6					; save length of current input string 
8ee6					ld hl, (input_start) 
8ee6					ld a, 0 
8ee6					call strlent 
8ee6					ld a,l 
8ee6					ld (input_len),a 
8ee6			 
8ee6			.skipcur: 
8ee6			 
8ee6				        call update_display 
8ee6					 
8ee6			 
8ee6			 
8ee6					; wait 
8ee6				 
8ee6					; TODO loop without wait to flash the cursor and char under cursor	 
8ee6					call cin    ; _wait 
8ee6			 
8ee6					cp 0 
8ee6					jp z, .is1 
8ee6			 
8ee6					; get ptr to char to input into 
8ee6			 
8ee6					ld c,a 
8ee6					ld hl, (input_start) 
8ee6					ld a, (input_cursor) 
8ee6					call addatohl 
8ee6					ld (input_ptr), hl 
8ee6					ld a,c 
8ee6			 
8ee6					; replace char under cursor 
8ee6			 
8ee6			;		ld hl, (input_ptr) 
8ee6			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ee6			;		ld (hl), a 
8ee6			 
8ee6			;	if DEBUG_INPUT 
8ee6			;		push af 
8ee6			;		ld a, 'i' 
8ee6			;		ld (debug_mark),a 
8ee6			;		pop af 
8ee6			;		CALLMONITOR 
8ee6			;	endif 
8ee6					cp KEY_HOME 
8ee6					jr nz, .iske 
8ee6			 
8ee6					ld a, (input_at_pos) 
8ee6					ld (input_at_cursor),a 
8ee6					ld a, 0 
8ee6					ld (input_cursor), a 
8ee6					jp .is1 
8ee6					 
8ee6			.iske:		cp KEY_END 
8ee6					jr nz, .isknw 
8ee6					jp .is1 
8ee6			 
8ee6			.isknw:		cp KEY_NEXTWORD 
8ee6					jr nz, .iskpw 
8ee6			 
8ee6			.isknwm:	ld hl, (input_ptr) 
8ee6					ld a,(hl)	 
8ee6					cp 0 
8ee6					jp z, .is1    ; end of string 
8ee6					cp ' ' 
8ee6					jp z, .is1    ; end of word 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6					jr .isknwm 
8ee6			 
8ee6			.iskpw:		cp KEY_PREVWORD 
8ee6					jr nz, .iskl 
8ee6			.iskpwm:	 
8ee6					ld hl, (input_ptr) 
8ee6					ld a,(hl)	 
8ee6					cp 0  
8ee6					jp z, .is1    ; end of string 
8ee6					cp ' ' 
8ee6					jp z, .is1    ; end of word 
8ee6					dec hl 
8ee6					ld (input_ptr), hl 
8ee6					ld a, (input_at_cursor) 
8ee6					dec a 
8ee6					ld (input_at_cursor), a 
8ee6					jr .iskpwm 
8ee6			 
8ee6			 
8ee6			.iskl:		cp KEY_LEFT 
8ee6					jr nz, .isk1 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6			 
8ee6					cp 0 
8ee6					jp z, .is1 		; at start of line to ignore  
8ee6			 
8ee6					dec  a 		; TODO check underflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					dec hl 
8ee6					ld (input_ptr), hl 
8ee6					 
8ee6					ld a, (input_at_cursor) 
8ee6					dec a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk1:		cp KEY_RIGHT 
8ee6					jr nz, .isk2 
8ee6			 
8ee6					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ee6					ld e,a 
8ee6					ld a, (input_cursor) 
8ee6					cp e 
8ee6					jp z, .is1		; at the end of string so dont go right 
8ee6			 
8ee6					inc  a 		; TODO check overflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk2:		cp KEY_UP 
8ee6			 
8ee6					jr nz, .isk3 
8ee6			 
8ee6					; swap last command with the current on 
8ee6			 
8ee6					; move cursor to start of string 
8ee6					ld hl, (input_start) 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					ld a, (input_at_pos) 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld a, 0 
8ee6					ld (input_cursor), a 
8ee6					 
8ee6					; swap input and last command buffers 
8ee6			 
8ee6					ld hl, os_cli_cmd 
8ee6					ld de, os_last_cmd 
8ee6					ld b, 255 
8ee6			.swap1:		ld a, (hl) 
8ee6					ld c,a 
8ee6					ld a, (de) 
8ee6					ld (hl), a 
8ee6					ld a,c 
8ee6					ld (de),a 
8ee6					inc hl 
8ee6					inc de 
8ee6					djnz .swap1 
8ee6			 
8ee6			 
8ee6			 
8ee6			 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk3:		cp KEY_BS 
8ee6					jr nz, .isk4 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6			 
8ee6					cp 0 
8ee6					jp z, .is1 		; at start of line to ignore  
8ee6			 
8ee6					dec  a 		; TODO check underflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					; hl is source 
8ee6					; de needs to be source - 1 
8ee6			 
8ee6			;		ld a, 0 
8ee6			;		dec hl 
8ee6			;		ld (hl), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					dec hl 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					; shift all data 
8ee6			 
8ee6					push hl 
8ee6					inc hl 
8ee6					pop de 
8ee6					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ee6					ld c,a 
8ee6					ld b,0 
8ee6					ldir  
8ee6			 
8ee6			 
8ee6			 
8ee6			 
8ee6					ld a, (input_at_cursor) 
8ee6					dec a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6			 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6					; remove char 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld de,.iblank 
8ee6					call str_at_display 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk4:		cp KEY_CR 
8ee6					jr z, .endinput 
8ee6			 
8ee6					; else add the key press to the end 
8ee6			 
8ee6					ld c, a			; save key pressed 
8ee6			 
8ee6					ld a,(hl)		; get what is currently under char 
8ee6			 
8ee6					cp 0			; we are at the end of the string 
8ee6					jr nz, .onchar 
8ee6					 
8ee6					; add a char to the end of the string 
8ee6				 
8ee6					ld (hl),c 
8ee6					inc hl 
8ee6			;		ld a,' ' 
8ee6			;		ld (hl),a 
8ee6			;		inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6					dec hl 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6					inc a				; TODO check max string length and scroll  
8ee6					ld (input_cursor), a		; inc cursor pos 
8ee6							 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6			;	if DEBUG_INPUT 
8ee6			;		push af 
8ee6			;		ld a, '+' 
8ee6			;		ld (debug_mark),a 
8ee6			;		pop af 
8ee6			;		CALLMONITOR 
8ee6			;	endif 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6					jp .is1 
8ee6					 
8ee6			 
8ee6			 
8ee6					; if on a char then insert 
8ee6			.onchar: 
8ee6			 
8ee6					; TODO over flow check: make sure insert does not blow out buffer 
8ee6			 
8ee6					; need to do some maths to use lddr 
8ee6			 
8ee6					push hl   ; save char pos 
8ee6					push bc 
8ee6			 
8ee6					ld hl, (input_start) 
8ee6					ld a, (input_len) 
8ee6					call addatohl  		; end of string 
8ee6					inc hl 
8ee6					inc hl		; past zero term 
8ee6					push hl 
8ee6					inc hl 
8ee6					push hl  
8ee6			 
8ee6								; start and end of lddr set, now how much to move? 
8ee6			 
8ee6							 
8ee6					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ee6					ld b,a 
8ee6					ld a,(input_len) 
8ee6					ld e,a 
8ee6					sub b 
8ee6					inc a		;?? 
8ee6					inc a		;?? 
8ee6					inc a		;?? 
8ee6			 
8ee6					ld b,0 
8ee6					ld c,a 
8ee6			 
8ee6				if DEBUG_INPUT 
8ee6					push af 
8ee6					ld a, 'i' 
8ee6					ld (debug_mark),a 
8ee6					pop af 
8ee6			;		CALLMONITOR 
8ee6				endif 
8ee6					pop de 
8ee6					pop hl 
8ee6				if DEBUG_INPUT 
8ee6					push af 
8ee6					ld a, 'I' 
8ee6					ld (debug_mark),a 
8ee6					pop af 
8ee6			;		CALLMONITOR 
8ee6				endif 
8ee6					lddr 
8ee6				 
8ee6			 
8ee6			 
8ee6					; TODO have a key for insert/overwrite mode???? 
8ee6					pop bc 
8ee6					pop hl 
8ee6					ld (hl), c		; otherwise overwrite current char 
8ee6					 
8ee6			 
8ee6			 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6					inc  a 		; TODO check overflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.endinput:	; TODO look for end of string 
8ee6			 
8ee6					; add trailing space for end of token 
8ee6			 
8ee6					ld hl, (input_start) 
8ee6					ld a,(input_len) 
8ee6					call addatohl 
8ee6					ld a, ' ' 
8ee6					ld (hl),a 
8ee6					; TODO eof of parse marker 
8ee6			 
8ee6					inc hl 
8ee6					ld a, 0 
8ee6					ld (hl),a 
8ee6			 
8ee6			 
8ee6					ret 
8ee6			 
8ee6			.iblank: db " ",0 
8ee6			 
8ee6			 
8ee6			input_str_prev:	ld (input_at_pos), a 
8ee6					ld (input_start), hl 
8ee6					ld a,1			; add cursor 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6					ld (input_ptr), hl 
8ee6					ld a,d 
8ee6					ld (input_size), a 
8ee6					ld a,0 
8ee6					ld (input_cursor),a 
8ee6			.instr1:	 
8ee6			 
8ee6					; TODO do block cursor 
8ee6					; TODO switch cursor depending on the modifer key 
8ee6			 
8ee6					; update cursor shape change on key hold 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					dec hl 
8ee6					ld a,(cursor_shape) 
8ee6					ld (hl), a 
8ee6			 
8ee6					; display entered text 
8ee6					ld a,(input_at_pos) 
8ee6			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ee6			            	LD   de, (input_start) 
8ee6			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ee6			 
8ee6					call cin 
8ee6					cp 0 
8ee6					jr z, .instr1 
8ee6			 
8ee6					; proecess keyboard controls first 
8ee6			 
8ee6					ld hl,(input_ptr) 
8ee6			 
8ee6					cp KEY_CR	 ; pressing enter ends input 
8ee6					jr z, .instrcr 
8ee6			 
8ee6					cp KEY_BS 	; back space 
8ee6					jr nz, .instr2 
8ee6					; process back space 
8ee6			 
8ee6					; TODO stop back space if at start of string 
8ee6					dec hl 
8ee6					dec hl ; to over write cursor 
8ee6					ld a,(cursor_shape) 
8ee6					;ld a,0 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a," " 
8ee6					ld (hl),a 
8ee6					ld (input_ptr),hl 
8ee6					 
8ee6			 
8ee6					jr .instr1 
8ee6			 
8ee6			.instr2:	cp KEY_LEFT    ; cursor left 
8ee6					jr nz, .instr3 
8ee6					dec hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6				 
8ee6			.instr3:	cp KEY_RIGHT      ; cursor right 
8ee6					jr nz, .instr4 
8ee6					inc hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6			 
8ee6			.instr4:	cp KEY_HOME    ; jump to start of line 
8ee6					jr nz, .instr5 
8ee6					dec hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6			 
8ee6			.instr5:	cp KEY_END     ; jump to end of line 
8ee6					jr nz, .instr6 
8ee6					dec hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6			.instr6:        cp KEY_UP      ; recall last command 
8ee6					jr nz, .instrnew 
8ee6			 
8ee6				ld hl, scratch 
8ee6				ld de, os_last_cmd 
8ee6				call strcpy 
8ee6					jr .instr1 
8ee6			 
8ee6			 
8ee6			.instrnew:	; no special key pressed to see if we have room to store it 
8ee6			 
8ee6					; TODO do string size test 
8ee6			 
8ee6					dec hl ; to over write cursor 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,(cursor_shape) 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6			 
8ee6					ld (input_ptr),hl 
8ee6					 
8ee6					jr .instr1 
8ee6			.instrcr:	dec hl		; remove cursor 
8ee6					ld a,' '	; TODO add a trailing space for safety 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6			 
8ee6			 
8ee6					; if at end of line scroll up    
8ee6					; TODO detecting only end of line 4 for scroll up  
8ee6			 
8ee6					;ld   
8ee6			 
8ee6					ret 
8ee6			 
8ee6			 
8ee6			endif 
8ee6			; strcpy hl = dest, de source 
8ee6			 
8ee6 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8ee7 b7			            OR   A              ;Null terminator? 
8ee8 c8			            RET  Z              ;Yes, so finished 
8ee9 1a					ld a,(de) 
8eea 77					ld (hl),a 
8eeb 13			            INC  DE             ;Point to next character 
8eec 23					inc hl 
8eed 18 f7		            JR   strcpy       ;Repeat 
8eef c9					ret 
8ef0			 
8ef0			 
8ef0			; TODO string_at  
8ef0			; pass string which starts with lcd offset address and then null term string 
8ef0			 
8ef0			; TODO string to dec 
8ef0			; TODO string to hex 
8ef0			; TODO byte to string hex 
8ef0			; TODO byte to string dec 
8ef0			 
8ef0			 
8ef0			 
8ef0			; from z80uartmonitor 
8ef0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef0			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ef0			; pass hl for where to put the text 
8ef0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef0 c5			hexout:	PUSH BC 
8ef1 f5					PUSH AF 
8ef2 47					LD B, A 
8ef3					; Upper nybble 
8ef3 cb 3f				SRL A 
8ef5 cb 3f				SRL A 
8ef7 cb 3f				SRL A 
8ef9 cb 3f				SRL A 
8efb cd 0b 8f				CALL tohex 
8efe 77					ld (hl),a 
8eff 23					inc hl	 
8f00					 
8f00					; Lower nybble 
8f00 78					LD A, B 
8f01 e6 0f				AND 0FH 
8f03 cd 0b 8f				CALL tohex 
8f06 77					ld (hl),a 
8f07 23					inc hl	 
8f08					 
8f08 f1					POP AF 
8f09 c1					POP BC 
8f0a c9					RET 
8f0b					 
8f0b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0b			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f0b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0b			tohex: 
8f0b e5					PUSH HL 
8f0c d5					PUSH DE 
8f0d 16 00				LD D, 0 
8f0f 5f					LD E, A 
8f10 21 18 8f				LD HL, .DATA 
8f13 19					ADD HL, DE 
8f14 7e					LD A, (HL) 
8f15 d1					POP DE 
8f16 e1					POP HL 
8f17 c9					RET 
8f18			 
8f18			.DATA: 
8f18 30					DEFB	30h	; 0 
8f19 31					DEFB	31h	; 1 
8f1a 32					DEFB	32h	; 2 
8f1b 33					DEFB	33h	; 3 
8f1c 34					DEFB	34h	; 4 
8f1d 35					DEFB	35h	; 5 
8f1e 36					DEFB	36h	; 6 
8f1f 37					DEFB	37h	; 7 
8f20 38					DEFB	38h	; 8 
8f21 39					DEFB	39h	; 9 
8f22 41					DEFB	41h	; A 
8f23 42					DEFB	42h	; B 
8f24 43					DEFB	43h	; C 
8f25 44					DEFB	44h	; D 
8f26 45					DEFB	45h	; E 
8f27 46					DEFB	46h	; F 
8f28			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f28			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f28			;;    subtract $30, if result > 9 then subtract $7 more 
8f28			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f28			atohex: 
8f28 d6 30				SUB $30 
8f2a fe 0a				CP 10 
8f2c f8					RET M		; If result negative it was 0-9 so we're done 
8f2d d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f2f c9					RET		 
8f30			 
8f30			 
8f30			 
8f30			 
8f30			; Get 2 ASCII characters as hex byte from pointer in hl 
8f30			 
8f30			BYTERD: 
8f30 16 00			LD	D,00h		;Set up 
8f32 cd 3a 8f			CALL	HEXCON		;Get byte and convert to hex 
8f35 87				ADD	A,A		;First nibble so 
8f36 87				ADD	A,A		;multiply by 16 
8f37 87				ADD	A,A		; 
8f38 87				ADD	A,A		; 
8f39 57				LD	D,A		;Save hi nibble in D 
8f3a			HEXCON: 
8f3a 7e				ld a, (hl)		;Get next chr 
8f3b 23				inc hl 
8f3c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f3e fe 0a			CP	00Ah		;Is it 0-9 ? 
8f40 38 02			JR	C,NALPHA	;If so miss next bit 
8f42 d6 07			SUB	007h		;Else convert alpha 
8f44			NALPHA: 
8f44 b2				OR	D		;Add hi nibble back 
8f45 c9				RET			; 
8f46			 
8f46			 
8f46			; 
8f46			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f46			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f46			; characters (0-9a-f) are accepted. 
8f46			; 
8f46			;get_word        push    af 
8f46			;                call    get_byte        ; Get the upper byte 
8f46			;                ld      h, a 
8f46			;                call    get_byte        ; Get the lower byte 
8f46			;                ld      l, a 
8f46			;                pop     af 
8f46			;                ret 
8f46			; 
8f46			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f46			; the routine get_nibble is used only valid characters are accepted - the  
8f46			; input routine only accepts characters 0-9a-f. 
8f46			; 
8f46 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f47 7e					ld a,(hl) 
8f48 23					inc hl 
8f49 cd 6e 8f		                call    nibble2val      ; Get upper nibble 
8f4c cb 07		                rlc     a 
8f4e cb 07		                rlc     a 
8f50 cb 07		                rlc     a 
8f52 cb 07		                rlc     a 
8f54 47			                ld      b, a            ; Save upper four bits 
8f55 7e					ld a,(hl) 
8f56 cd 6e 8f		                call    nibble2val      ; Get lower nibble 
8f59 b0			                or      b               ; Combine both nibbles 
8f5a c1			                pop     bc              ; Restore B (and C) 
8f5b c9			                ret 
8f5c			; 
8f5c			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f5c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f5c			; to the serial line interface. The lower 4 bits of A contain the value of  
8f5c			; that particular digit. 
8f5c			; 
8f5c			;get_nibble      ld a,(hl)           ; Read a character 
8f5c			;                call    to_upper        ; Convert to upper case 
8f5c			;                call    is_hex          ; Was it a hex digit? 
8f5c			;                jr      nc, get_nibble  ; No, get another character 
8f5c			 ;               call    nibble2val      ; Convert nibble to value 
8f5c			 ;               call    print_nibble 
8f5c			 ;               ret 
8f5c			; 
8f5c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f5c			; A valid hexadecimal digit is denoted by a set C flag. 
8f5c			; 
8f5c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f5c			;                ret     nc              ; Yes 
8f5c			;                cp      '0'             ; Less than '0'? 
8f5c			;                jr      nc, is_hex_1    ; No, continue 
8f5c			;                ccf                     ; Complement carry (i.e. clear it) 
8f5c			;                ret 
8f5c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f5c			;                ret     c               ; Yes 
8f5c			;                cp      'A'             ; Less than 'A'? 
8f5c			;                jr      nc, is_hex_2    ; No, continue 
8f5c			;                ccf                     ; Yes - clear carry and return 
8f5c			;                ret 
8f5c			;is_hex_2        scf                     ; Set carry 
8f5c			;                ret 
8f5c			; 
8f5c			; Convert a single character contained in A to upper case: 
8f5c			; 
8f5c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f5e d8			                ret     c 
8f5f fe 7b		                cp      'z' + 1         ; > 'z'? 
8f61 d0			                ret     nc              ; Nothing to do, either 
8f62 e6 5f		                and     $5f             ; Convert to upper case 
8f64 c9			                ret 
8f65			 
8f65			 
8f65			to_lower: 
8f65			 
8f65			   ; if char is in [A-Z] make it lower case 
8f65			 
8f65			   ; enter : a = char 
8f65			   ; exit  : a = lower case char 
8f65			   ; uses  : af 
8f65			 
8f65 fe 41		   cp 'A' 
8f67 d8			   ret c 
8f68			    
8f68 fe 5b		   cp 'Z'+1 
8f6a d0			   ret nc 
8f6b			    
8f6b f6 20		   or $20 
8f6d c9			   ret 
8f6e			 
8f6e			; 
8f6e			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f6e			; corresponding value in A. 
8f6e			; 
8f6e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f70 38 02		                jr      c, nibble2val_1 ; Yes 
8f72 d6 07		                sub     7               ; Adjust for A-F 
8f74 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f76 e6 0f		                and     $f              ; Only return lower 4 bits 
8f78 c9			                ret 
8f79			; 
8f79			; Print_nibble prints a single hex nibble which is contained in the lower  
8f79			; four bits of A: 
8f79			; 
8f79			;print_nibble    push    af              ; We won't destroy the contents of A 
8f79			;                and     $f              ; Just in case... 
8f79			;                add     a, '0'             ; If we have a digit we are done here. 
8f79			;                cp      '9' + 1         ; Is the result > 9? 
8f79			;                jr      c, print_nibble_1 
8f79			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f79			;print_nibble_1  call    putc            ; Print the nibble and 
8f79			;                pop     af              ; restore the original value of A 
8f79			;                ret 
8f79			;; 
8f79			;; Send a CR/LF pair: 
8f79			; 
8f79			;crlf            push    af 
8f79			;                ld      a, cr 
8f79			;                call    putc 
8f79			;                ld      a, lf 
8f79			;                call    putc 
8f79			;                pop     af 
8f79			;                ret 
8f79			; 
8f79			; Print_word prints the four hex digits of a word to the serial line. The  
8f79			; word is expected to be in HL. 
8f79			; 
8f79			;print_word      push    hl 
8f79			;                push    af 
8f79			;                ld      a, h 
8f79			;                call    print_byte 
8f79			;                ld      a, l 
8f79			;                call    print_byte 
8f79			;                pop     af 
8f79			;                pop     hl 
8f79			;                ret 
8f79			; 
8f79			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f79			; The byte to be printed is expected to be in A. 
8f79			; 
8f79			;print_byte      push    af              ; Save the contents of the registers 
8f79			;                push    bc 
8f79			;                ld      b, a 
8f79			;                rrca 
8f79			;                rrca 
8f79			;                rrca 
8f79			;                rrca 
8f79			;                call    print_nibble    ; Print high nibble 
8f79			;                ld      a, b 
8f79			;                call    print_nibble    ; Print low nibble 
8f79			;                pop     bc              ; Restore original register contents 
8f79			;                pop     af 
8f79			;                ret 
8f79			 
8f79			 
8f79			 
8f79			 
8f79			 
8f79			fourehexhl:  
8f79 7e				ld a,(hl) 
8f7a cd 28 8f			call atohex 
8f7d cb 3f				SRL A 
8f7f cb 3f				SRL A 
8f81 cb 3f				SRL A 
8f83 cb 3f				SRL A 
8f85 47				ld b, a 
8f86 23				inc hl 
8f87 7e				ld a,(hl) 
8f88 23				inc hl 
8f89 cd 28 8f			call atohex 
8f8c 80				add b 
8f8d 57				ld d,a 
8f8e 7e				ld a,(hl) 
8f8f cd 28 8f			call atohex 
8f92 cb 3f				SRL A 
8f94 cb 3f				SRL A 
8f96 cb 3f				SRL A 
8f98 cb 3f				SRL A 
8f9a 47				ld b, a 
8f9b 23				inc hl 
8f9c 7e				ld a,(hl) 
8f9d 23				inc hl 
8f9e cd 28 8f			call atohex 
8fa1 80				add b 
8fa2 5f				ld e, a 
8fa3 d5				push de 
8fa4 e1				pop hl 
8fa5 c9				ret 
8fa6			 
8fa6			; pass hl. returns z set if the byte at hl is a digit 
8fa6			;isdigithl:  
8fa6			;	push bc 
8fa6			;	ld a,(hl) 
8fa6			;	cp ':' 
8fa6			;	jr nc, .isdf 		; > 
8fa6			;	cp '0' 
8fa6			;	jr c, .isdf		; < 
8fa6			; 
8fa6			;	; TODO find a better way to set z 
8fa6			; 
8fa6			;	ld b,a 
8fa6			;	cp b 
8fa6			;	pop bc 
8fa6			;	ret 
8fa6			; 
8fa6			;.isdf:	; not digit so clear z 
8fa6			; 
8fa6			;	; TODO find a better way to unset z 
8fa6			; 
8fa6			;	ld b,a 
8fa6			;	inc b 
8fa6			;	cp b 
8fa6			; 
8fa6			;	pop bc 
8fa6			;	ret 
8fa6				 
8fa6				 
8fa6			 
8fa6			 
8fa6			; pass hl as the four byte address to load 
8fa6			 
8fa6			get_word_hl:  
8fa6 e5				push hl 
8fa7 cd 46 8f			call get_byte 
8faa				 
8faa 47				ld b, a 
8fab			 
8fab e1				pop hl 
8fac 23				inc hl 
8fad 23				inc hl 
8fae			 
8fae			; TODO not able to handle a-f  
8fae 7e				ld a,(hl) 
8faf			;	;cp ':' 
8faf			;	cp 'g' 
8faf			;	jr nc, .single_byte_hl 		; > 
8faf			;	cp 'G' 
8faf			;	jr nc, .single_byte_hl 		; > 
8faf			;	cp '0' 
8faf			;	jr c, .single_byte_hl		; < 
8faf			 
8faf				;call isdigithl 
8faf fe 00			cp 0 
8fb1 28 06			jr z, .single_byte_hl 
8fb3			 
8fb3			.getwhln:   ; hex word so get next byte 
8fb3			 
8fb3 cd 46 8f			call get_byte 
8fb6 6f				ld l, a 
8fb7 60				ld h,b 
8fb8 c9				ret 
8fb9 68			.single_byte_hl:   ld l,b 
8fba 26 00				ld h,0 
8fbc c9					ret 
8fbd			 
8fbd			 
8fbd			 
8fbd			 
8fbd 21 5d 97			ld hl,asc+1 
8fc0			;	ld a, (hl) 
8fc0			;	call nibble2val 
8fc0 cd 46 8f			call get_byte 
8fc3			 
8fc3			;	call fourehexhl 
8fc3 32 f5 e2			ld (scratch+52),a 
8fc6				 
8fc6 21 f3 e2			ld hl,scratch+50 
8fc9 22 e4 e5			ld (os_cur_ptr),hl 
8fcc			 
8fcc c9				ret 
8fcd			 
8fcd			 
8fcd			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fcd			 
8fcd			; Decimal Unsigned Version 
8fcd			 
8fcd			;Number in a to decimal ASCII 
8fcd			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fcd			;Example: display a=56 as "056" 
8fcd			;input: a = number 
8fcd			;Output: a=0,value of a in the screen 
8fcd			;destroys af,bc (don't know about hl and de) 
8fcd			DispAToASCII: 
8fcd 0e 9c			ld	c,-100 
8fcf cd d9 8f			call	.Na1 
8fd2 0e f6			ld	c,-10 
8fd4 cd d9 8f			call	.Na1 
8fd7 0e ff			ld	c,-1 
8fd9 06 2f		.Na1:	ld	b,'0'-1 
8fdb 04			.Na2:	inc	b 
8fdc 81				add	a,c 
8fdd 38 fc			jr	c,.Na2 
8fdf 91				sub	c		;works as add 100/10/1 
8fe0 f5				push af		;safer than ld c,a 
8fe1 78				ld	a,b		;char is in b 
8fe2			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fe2 f1				pop af		;safer than ld a,c 
8fe3 c9				ret 
8fe4			 
8fe4			; Decimal Signed Version 
8fe4			 
8fe4			; DispA 
8fe4			; -------------------------------------------------------------- 
8fe4			; Converts a signed integer value to a zero-terminated ASCII 
8fe4			; string representative of that value (using radix 10). 
8fe4			; -------------------------------------------------------------- 
8fe4			; INPUTS: 
8fe4			;     HL     Value to convert (two's complement integer). 
8fe4			;     DE     Base address of string destination. (pointer). 
8fe4			; -------------------------------------------------------------- 
8fe4			; OUTPUTS: 
8fe4			;     None 
8fe4			; -------------------------------------------------------------- 
8fe4			; REGISTERS/MEMORY DESTROYED 
8fe4			; AF HL 
8fe4			; -------------------------------------------------------------- 
8fe4			 
8fe4			;DispHLToASCII: 
8fe4			;   push    de 
8fe4			;   push    bc 
8fe4			; 
8fe4			;; Detect sign of HL. 
8fe4			;    bit    7, h 
8fe4			;    jr     z, ._DoConvert 
8fe4			; 
8fe4			;; HL is negative. Output '-' to string and negate HL. 
8fe4			;    ld     a, '-' 
8fe4			;    ld     (de), a 
8fe4			;    inc    de 
8fe4			; 
8fe4			;; Negate HL (using two's complement) 
8fe4			;    xor    a 
8fe4			;    sub    l 
8fe4			;    ld     l, a 
8fe4			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fe4			;    sbc    a, h 
8fe4			;    ld     h, a 
8fe4			; 
8fe4			;; Convert HL to digit characters 
8fe4			;._DoConvert: 
8fe4			;    ld     b, 0     ; B will count character length of number 
8fe4			;-   ld     a, 10 
8fe4			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fe4			;    push   af 
8fe4			;    inc    b 
8fe4			;    ld     a, h 
8fe4			;    or     l 
8fe4			;    jr     nz, - 
8fe4			; 
8fe4			;; Retrieve digits from stack 
8fe4			;-   pop    af 
8fe4			;    or     $30 
8fe4			;    ld     (de), a 
8fe4			;    inc    de 
8fe4			;    djnz   - 
8fe4			; 
8fe4			;; Terminate string with NULL 
8fe4			;    xor    a 
8fe4			;    ld     (de), a 
8fe4			; 
8fe4			;    pop    bc 
8fe4			;    pop    de 
8fe4			;    ret 
8fe4			 
8fe4			;Comments 
8fe4			; 
8fe4			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fe4			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fe4			;    Note that the output string will not be fixed-width. 
8fe4			; 
8fe4			;Example Usage 
8fe4			; 
8fe4			;    ld    hl, -1004 
8fe4			;    ld    de, OP1 
8fe4			;    call  DispA 
8fe4			;    ld    hl, OP1 
8fe4			;    syscall  PutS 
8fe4			 
8fe4			 
8fe4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fe4			 
8fe4			 
8fe4			;Converts an ASCII string to an unsigned 16-bit integer 
8fe4			;Quits when it reaches a non-decimal digit 
8fe4			 
8fe4			string_to_uint16: 
8fe4			atoui_16: 
8fe4			;Input: 
8fe4			;     DE points to the string 
8fe4			;Outputs: 
8fe4			;     HL is the result 
8fe4			;     A is the 8-bit value of the number 
8fe4			;     DE points to the byte after the number 
8fe4			;Destroys: 
8fe4			;     BC 
8fe4			;       if the string is non-empty, BC is HL/10 
8fe4			;Size:  24 bytes 
8fe4			;Speed: 42+d(104+{0,9}) 
8fe4			;       d is the number of digits in the number 
8fe4			;       max is 640 cycles for a 5 digit number 
8fe4			;Assuming no leading zeros: 
8fe4			;1 digit:  146cc 
8fe4			;2 digit:  250cc 
8fe4			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fe4			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fe4			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fe4			;avg: 544.81158447265625cc (544+13297/16384) 
8fe4			;=============================================================== 
8fe4 21 00 00		  ld hl,0 
8fe7			.u16a: 
8fe7 1a			  ld a,(de) 
8fe8 d6 30		  sub 30h 
8fea fe 0a		  cp 10 
8fec d0			  ret nc 
8fed 13			  inc de 
8fee 44			  ld b,h 
8fef 4d			  ld c,l 
8ff0 29			  add hl,hl 
8ff1 29			  add hl,hl 
8ff2 09			  add hl,bc 
8ff3 29			  add hl,hl 
8ff4 85			  add a,l 
8ff5 6f			  ld l,a 
8ff6 30 ef		  jr nc,.u16a 
8ff8 24			  inc h 
8ff9 c3 e7 8f		  jp .u16a 
8ffc			 
8ffc			 
8ffc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ffc			 
8ffc			;written by Zeda 
8ffc			;Converts a 16-bit unsigned integer to an ASCII string. 
8ffc			 
8ffc			uitoa_16: 
8ffc			;Input: 
8ffc			;   DE is the number to convert 
8ffc			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ffc			;Output: 
8ffc			;   HL points to the null-terminated ASCII string 
8ffc			;      NOTE: This isn't necessarily the same as the input HL. 
8ffc d5			  push de 
8ffd c5			  push bc 
8ffe f5			  push af 
8fff eb			  ex de,hl 
9000			 
9000 01 f0 d8		  ld bc,-10000 
9003 3e 2f		  ld a,'0'-1 
9005 3c			  inc a 
9006 09			  add hl,bc  
9007 38 fc		   jr c,$-2 
9009 12			  ld (de),a 
900a 13			  inc de 
900b			 
900b 01 e8 03		  ld bc,1000 
900e 3e 3a		  ld a,'9'+1 
9010 3d			  dec a  
9011 09			  add hl,bc  
9012 30 fc		   jr nc,$-2 
9014 12			  ld (de),a 
9015 13			  inc de 
9016			 
9016 01 9c ff		  ld bc,-100 
9019 3e 2f		  ld a,'0'-1 
901b 3c			  inc a  
901c 09			  add hl,bc  
901d 38 fc		   jr c,$-2 
901f 12			  ld (de),a 
9020 13			  inc de 
9021			 
9021 7d			  ld a,l 
9022 26 3a		  ld h,'9'+1 
9024 25			  dec h  
9025 c6 0a		  add a,10  
9027 30 fb		   jr nc,$-3 
9029 c6 30		  add a,'0' 
902b eb			  ex de,hl 
902c 72			  ld (hl),d 
902d 23			  inc hl 
902e 77			  ld (hl),a 
902f 23			  inc hl 
9030 36 00		  ld (hl),0 
9032			 
9032			;Now strip the leading zeros 
9032 0e fa		  ld c,-6 
9034 09			  add hl,bc 
9035 3e 30		  ld a,'0' 
9037 23			  inc hl  
9038 be			  cp (hl)  
9039 28 fc		  jr z,$-2 
903b			 
903b			;Make sure that the string is non-empty! 
903b 7e			  ld a,(hl) 
903c b7			  or a 
903d 20 01		  jr nz,.atoub 
903f 2b			  dec hl 
9040			.atoub: 
9040			 
9040 f1			  pop af 
9041 c1			  pop bc 
9042 d1			  pop de 
9043 c9			  ret 
9044			 
9044			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9044			 
9044			toUpper: 
9044			;A is the char. 
9044			;If A is a lowercase letter, this sets it to the matching uppercase 
9044			;18cc or 30cc or 41cc 
9044			;avg: 26.75cc 
9044 fe 61		  cp 'a' 
9046 d8			  ret c 
9047 fe 7b		  cp 'z'+1 
9049 d0			  ret nc 
904a d6 20		  sub 'a'-'A' 
904c c9			  ret 
904d			 
904d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
904d			 
904d			; String Length 
904d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
904d			 
904d			; Get the length of the null-terminated string starting at $8000 hl 
904d			;    LD     HL, $8000 
904d			 
904d			strlenz: 
904d			 
904d af			    XOR    A               ; Zero is the value we are looking for. 
904e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
904f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9050			                           ; 65, 536 bytes (the entire addressable memory space). 
9050 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9052			 
9052			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9052 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9053 6f			    LD     L, A             ; number of bytes 
9054 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9056 2b			    DEC    HL              ; Compensate for null. 
9057 c9				ret 
9058			 
9058			; Get the length of the A terminated string starting at $8000 hl 
9058			;    LD     HL, $8000 
9058			 
9058			strlent: 
9058			 
9058			                  ; A is the value we are looking for. 
9058 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
905a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
905c			                           ; 65, 536 bytes (the entire addressable memory space). 
905c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
905e			 
905e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
905e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9060 2e 00		    LD     L, 0             ; number of bytes 
9062 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9064 2b			    DEC    HL              ; Compensate for null. 
9065 c9				ret 
9066			 
9066			 
9066			;Comparing Strings 
9066			 
9066			;IN    HL     Address of string1. 
9066			;      DE     Address of string2. 
9066			 
9066			; doc given but wrong??? 
9066			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9066			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9066			; tested 
9066			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9066			 
9066			strcmp_old: 
9066 e5			    PUSH   HL 
9067 d5			    PUSH   DE 
9068			 
9068 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9069 be			    CP     (HL)            ; (want to minimize work). 
906a 38 01		    JR     C, Str1IsBigger 
906c 7e			    LD     A, (HL) 
906d			 
906d			Str1IsBigger: 
906d 4f			    LD     C, A             ; Put length in BC 
906e 06 00		    LD     B, 0 
9070 13			    INC    DE              ; Increment pointers to meat of string. 
9071 23			    INC    HL 
9072			 
9072			CmpLoop: 
9072 1a			    LD     A, (DE)          ; Compare bytes. 
9073 ed a1		    CPI 
9075 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9077 13			    INC    DE              ; Update pointer. 
9078 ea 72 90		    JP     PE, CmpLoop 
907b			 
907b d1			    POP    DE 
907c e1			    POP    HL 
907d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
907e be			    CP     (HL) 
907f c9			    RET 
9080			 
9080			NoMatch: 
9080 2b			    DEC    HL 
9081 be			    CP     (HL)            ; Compare again to affect carry. 
9082 d1			    POP    DE 
9083 e1			    POP    HL 
9084 c9			    RET 
9085			 
9085			;; test strmp 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str2 
9085			;call strcmp 
9085			;jr z, .z1 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "NZ1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.z1: 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "ZZ1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str1 
9085			;call strcmp 
9085			;jr z, .z2 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "NZ2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.z2: 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "ZZ2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str2 
9085			;call strcmp 
9085			;jr c, .c1 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "Nc1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.c1: 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "cc1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str1 
9085			;call strcmp 
9085			;jr c, .c2 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "Nc2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.c2: 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "cc2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;	NEXTW 
9085			;.str1:   db "string1",0 
9085			;.str2:   db "string2",0 
9085			 
9085			; only care about direct match or not 
9085			; hl and de strings 
9085			; zero set if the same 
9085			 
9085			strcmp: 
9085 1a				ld a, (de) 
9086 be				cp (hl) 
9087 28 02			jr z, .ssame 
9089 b7				or a 
908a c9				ret 
908b			 
908b			.ssame:  
908b fe 00			cp 0 
908d c8				ret z 
908e			 
908e 23				inc hl 
908f 13				inc de 
9090 18 f3			jr strcmp 
9092				 
9092				 
9092			 
9092			;Copyright (c) 2014, Luke Maurits 
9092			;All rights reserved. 
9092			; 
9092			;Redistribution and use in source and binary forms, with or without 
9092			;modification, are permitted provided that the following conditions are met: 
9092			; 
9092			;* Redistributions of source code must retain the above copyright notice, this 
9092			;  list of conditions and the following disclaimer. 
9092			; 
9092			;* Redistributions in binary form must reproduce the above copyright notice, 
9092			;  this list of conditions and the following disclaimer in the documentation 
9092			;  and/or other materials provided with the distribution. 
9092			; 
9092			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9092			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9092			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9092			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9092			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9092			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9092			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9092			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9092			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9092			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9092			 
9092			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9092			 
9092			StrictStrCmp: 
9092				; Load next chars of each string 
9092 1a				ld a, (de) 
9093 47				ld b, a 
9094 7e				ld a, (hl) 
9095				; Compare 
9095 b8				cp b 
9096				; Return non-zero if chars don't match 
9096 c0				ret nz 
9097				; Check for end of both strings 
9097 fe 00			cp "\0" 
9099				; Return if strings have ended 
9099 c8				ret z 
909a				; Otherwise, advance to next chars 
909a 23				inc hl 
909b 13				inc de 
909c 18 f4			jr StrictStrCmp 
909e			 
909e			;end 
909e			; eof 
909e			 
909e			 
909e			 
909e			 
909e			 
909e			 
# End of file firmware_strings.asm
909e			include "firmware_memory.asm"   ; malloc and free  
909e			 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e			.mallocsize: db "Wants malloc >256",0 
909e			.mallocasize: db "MALLOC gives >256",0 
909e			.malloczero: db "MALLOC gives zero",0 
909e			 
909e			malloc_guard_zerolen: 
909e				push hl 
909e				push de 
909e				push af 
909e			 
909e				ld de, 0 
909e			        call cmp16 
909e				jr nz, .lowalloz 
909e			 
909e				push hl 
909e				push de 
909e					ld hl, display_fb0 
909e					ld (display_fb_active), hl 
909e				call clear_display 
909e				ld a, 0 
909e				ld de, .malloczero 
909e				call str_at_display 
909e				call update_display 
909e				call delay1s 
909e				call delay1s 
909e				call bp_on 
909e			;	ld a, 0 
909e			;	ld (os_view_disable), a 
909e			 
909e				pop de 
909e				pop hl 
909e			 
909e				 
909e			 
909e				CALLMONITOR 
909e			.lowalloz: 
909e			 
909e			 
909e				pop af 
909e				pop de 
909e				pop hl 
909e			ret 
909e			 
909e			malloc_guard_entry: 
909e				push hl 
909e				push de 
909e				push af 
909e			 
909e			 	or a      ;clear carry flag 
909e				push hl 
909e				ld de, 255 
909e				sbc hl, de 
909e				jr c, .lowalloc 
909e			 
909e				push de 
909e					ld hl, display_fb0 
909e					ld (display_fb_active), hl 
909e				call clear_display 
909e				ld a, 0 
909e				ld de, .mallocsize 
909e				call str_at_display 
909e				call update_display 
909e				call delay1s 
909e				call delay1s 
909e			;	ld a, 0 
909e			;	ld (os_view_disable), a 
909e				call bp_on 
909e			 
909e				pop de 
909e				pop hl 
909e			 
909e				 
909e			 
909e				CALLMONITOR 
909e				jr .lowdone 
909e			.lowalloc: 
909e			 
909e			 
909e				pop hl 
909e			.lowdone:	pop af 
909e				pop de 
909e				pop hl 
909e			ret 
909e			 
909e			malloc_guard_exit: 
909e				push hl 
909e				push de 
909e				push af 
909e			 
909e			 	or a      ;clear carry flag 
909e				push hl 
909e				ld de, 255 
909e				sbc hl, de 
909e				jr c, .lowallocx 
909e			 
909e				push de 
909e					ld hl, display_fb0 
909e					ld (display_fb_active), hl 
909e				call clear_display 
909e				ld a, 0 
909e				ld de, .mallocasize 
909e				call str_at_display 
909e				call update_display 
909e				call delay1s 
909e				call delay1s 
909e			;	ld a, 0 
909e			;	ld (os_view_disable), a 
909e				call bp_on 
909e				pop de 
909e				pop hl 
909e			 
909e				CALLMONITOR 
909e				jr .lowdonex 
909e			.lowallocx: 
909e			 
909e				pop hl 
909e			.lowdonex:	pop af 
909e				pop de 
909e				pop hl 
909e			ret 
909e			endif 
909e			 
909e			if MALLOC_2 
909e			; Z80 Malloc and Free Functions 
909e			 
909e			; Malloc Function: 
909e			; Input: 
909e			;   HL: Size of block to allocate 
909e			; Output: 
909e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
909e			 
909e			malloc: 
909e				 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e			call malloc_guard_entry 
909e			endif 
909e			 
909e			 
909e			 
909e			 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "mal" 
909e						CALLMONITOR 
909e					endif 
909e			    push af            ; Save AF register 
909e			    ld a, l            ; Load low byte of size into A 
909e			    or h               ; Check if size is zero 
909e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
909e			 
909e			    ; Allocate memory 
909e			    ld hl, (heap_start) ; Load start of heap into HL 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "ma1" 
909e						CALLMONITOR 
909e					endif 
909e			    call malloc_internal ; Call internal malloc function 
909e			    pop af             ; Restore AF register 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret                ; Return 
909e			 
909e			; Free Function: 
909e			; Input: 
909e			;   HL: Pointer to memory block to free 
909e			; Output: 
909e			;   None 
909e			 
909e			free: 
909e			    push af            ; Save AF register 
909e			    ld a, l            ; Load low byte of pointer into A 
909e			    or h               ; Check if pointer is NULL 
909e			    jp z, free_exit    ; If pointer is NULL, exit 
909e			 
909e			    ; Free memory 
909e			    ld hl, (heap_start) ; Load start of heap into HL 
909e			    call free_internal  ; Call internal free function 
909e			    pop af             ; Restore AF register 
909e			    ret                ; Return 
909e			 
909e			; Internal Malloc Function: 
909e			; Input: 
909e			;   HL: Size of block to allocate 
909e			; Output: 
909e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
909e			 
909e			malloc_internal: 
909e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
909e			    add hl, bc         ; Add management overhead to requested size 
909e			    ex de, hl          ; Save total size in DE, and keep it in HL 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "ma2" 
909e						CALLMONITOR 
909e					endif 
909e			 
909e			    ; Search for free memory block 
909e			    ld de, (heap_end)  ; Load end of heap into DE 
909e			    ld bc, 0           ; Initialize counter 
909e			 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "ma2" 
909e						CALLMONITOR 
909e					endif 
909e			malloc_search_loop: 
909e			    ; Check if current block is free 
909e			    ld a, (hl)         ; Load current block's status (free or used) 
909e			    cp 0               ; Compare with zero (free) 
909e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
909e			 
909e			    ; Check if current block is large enough 
909e			    ld a, (hl+1)       ; Load high byte of block size 
909e			    cp l               ; Compare with low byte of requested size 
909e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
909e			 
909e			    ld a, (hl+2)       ; Load low byte of block size 
909e			    cp h               ; Compare with high byte of requested size 
909e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
909e			 
909e			    ; Mark block as used 
909e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
909e			 
909e			    ; Calculate remaining space in block 
909e			    ld bc, 0           ; Clear BC 
909e			    add hl, bc         ; Increment HL to point to start of data block 
909e			    add hl, de         ; HL = HL + DE (total size) 
909e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
909e			    add hl, bc         ; Add management overhead to start of data block 
909e			 
909e			    ; Save pointer to allocated block in HL 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e						DMARK "ma5" 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret 
909e			 
909e			malloc_skip_block_check: 
909e			    ; Move to the next block 
909e			    ld bc, 3           ; Size of management overhead 
909e			    add hl, bc         ; Move to the next block 
909e			    inc de             ; Increment counter 
909e			 
909e			    ; Check if we have reached the end of heap 
909e			    ld a, e            ; Load low byte of heap end address 
909e			    cp (hl)            ; Compare with low byte of current address 
909e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
909e			    ld a, d            ; Load high byte of heap end address 
909e			    cp 0               ; Check if it's zero (end of memory) 
909e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
909e			 
909e			    ; If we reached here, allocation failed 
909e			    xor a              ; Set result to NULL 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e						DMARK "ma6" 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret 
909e			malloc_exit: 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e						DMARK "ma7" 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret 
909e			 
909e			; Internal Free Function: 
909e			; Input: 
909e			;   HL: Pointer to memory block to free 
909e			; Output: 
909e			;   None 
909e			 
909e			free_internal: 
909e			    ld de, (heap_start) ; Load start of heap into DE 
909e			    ld bc, 0            ; Initialize counter 
909e			 
909e			free_search_loop: 
909e			    ; Check if current block contains the pointer 
909e			    ld a, l             ; Load low byte of pointer 
909e			    cp (hl+1)           ; Compare with high byte of current block's address 
909e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
909e			    ld a, h             ; Load high byte of pointer 
909e			    cp (hl+2)           ; Compare with low byte of current block's address 
909e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
909e			 
909e			    ; Mark block as free 
909e			    ld (hl), 0          ; Set status byte to indicate free block 
909e			    ret                 ; Return 
909e			 
909e			free_skip_block_check: 
909e			    ; Move to the next block 
909e			    ld bc, 3            ; Size of management overhead 
909e			    add hl, bc          ; Move to the next block 
909e			    inc de              ; Increment counter 
909e			 
909e			    ; Check if we have reached the end of heap 
909e			    ld a, e             ; Load low byte of heap end address 
909e			    cp (hl)             ; Compare with low byte of current address 
909e			    jr nz, free_search_loop  ; If not equal, continue searching 
909e			    ld a, d             ; Load high byte of heap end address 
909e			    cp 0                ; Check if it's zero (end of memory) 
909e			    jr nz, free_search_loop  ; If not zero, continue searching 
909e			 
909e			    ; If we reached here, pointer is not found in heap 
909e			    ret 
909e			 
909e			free_exit: 
909e			    ret                 ; Return 
909e			 
909e			; Define heap start and end addresses 
909e			;heap_start:    .dw 0xC000   ; Start of heap 
909e			;heap_end:      .dw 0xE000   ; End of heap 
909e			 
909e			endif 
909e			 
909e			 
909e			if MALLOC_1 
909e			 
909e			 
909e			 
909e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
909e			 
909e			;moved to firmware.asm 
909e			;heap_start        .equ  0x9000      ; Starting address of heap 
909e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
909e			 
909e			;      .org 0 
909e			;      jp    main 
909e			 
909e			 
909e			;      .org  0x100 
909e			;main: 
909e			;      ld    HL, 0x8100 
909e			;      ld    SP, HL 
909e			; 
909e			;      call  heap_init 
909e			; 
909e			;      ; Make some allocations 
909e			;      ld    HL, 12 
909e			;      call  malloc            ; Allocates 0x9004 
909e			; 
909e			;      ld    HL, 12 
909e			;      call  malloc            ; Allocates 0x9014 
909e			; 
909e			;      ld    HL, 12 
909e			;      call  malloc            ; Allocates 0x9024 
909e			; 
909e			;      ; Free some allocations 
909e			;      ld    HL, 0x9014 
909e			;      call  free 
909e			; 
909e			;      ld    HL, 0x9004 
909e			;      call  free 
909e			; 
909e			;      ld    HL, 0x9024 
909e			;      call  free 
909e			; 
909e			; 
909e			;      halt 
909e			 
909e			 
909e			;------------------------------------------------------------------------------ 
909e			;     heap_init                                                               : 
909e			;                                                                             : 
909e			; Description                                                                 : 
909e			;     Initialise the heap and make it ready for malloc and free operations.   : 
909e			;                                                                             : 
909e			;     The heap is maintained as a linked list, starting with an initial       : 
909e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
909e			;     the first free block in the heap. Each block then points to the next    : 
909e			;     free block within the heap, and the free list ends at the first block   : 
909e			;     with a null pointer to the next free block.                             : 
909e			;                                                                             : 
909e			; Parameters                                                                  : 
909e			;     Inputs are compile-time only. Two defines which specify the starting    : 
909e			;     address of the heap and its size are required, along with a memory      : 
909e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
909e			;     principally stores a pointer to the first free block in the heap.       : 
909e			;                                                                             : 
909e			; Returns                                                                     : 
909e			;     Nothing                                                                 : 
909e			;------------------------------------------------------------------------------ 
909e			heap_init: 
909e e5			      push  HL 
909f			 
909f			      ; Initialise free list struct 
909f 21 41 dd		      ld    HL, heap_start 
90a2 22 3c dd		      ld    (free_list), HL 
90a5 21 00 00		      ld    HL, 0 
90a8 22 3e dd		      ld    (free_list+2), HL 
90ab			 
90ab			      ; Insert first free block at bottom of heap, consumes entire heap 
90ab 21 98 e2		      ld    HL, heap_start+heap_size-4 
90ae 22 41 dd		      ld    (heap_start), HL        ; Next block (end of free list) 
90b1 21 57 05		      ld    HL, heap_size-4 
90b4 22 43 dd		      ld    (heap_start+2), HL      ; Block size 
90b7			 
90b7			      ; Insert end of free list block at top of heap - two null words will 
90b7			      ; terminate the free list 
90b7 21 00 00		      ld    HL, 0 
90ba 22 9a e2		      ld    (heap_start+heap_size-2), HL 
90bd 22 98 e2		      ld    (heap_start+heap_size-4), HL 
90c0			 
90c0 e1			      pop   HL 
90c1			 
90c1 c9			      ret 
90c2			 
90c2			 
90c2			;------------------------------------------------------------------------------ 
90c2			;     malloc                                                                  : 
90c2			;                                                                             : 
90c2			; Description                                                                 : 
90c2			;     Allocates the wanted space from the heap and returns the address of the : 
90c2			;     first useable byte of the allocation.                                   : 
90c2			;                                                                             : 
90c2			;     Allocations can happen in one of two ways:                              : 
90c2			;                                                                             : 
90c2			;     1. A free block may be found which is the exact size wanted. In this    : 
90c2			;        case the block is removed from the free list and retuedn to the      : 
90c2			;        caller.                                                              : 
90c2			;     2. A free block may be found which is larger than the size wanted. In   : 
90c2			;        this case, the larger block is split into two. The first portion of  : 
90c2			;        this block will become the requested space by the malloc call and    : 
90c2			;        is returned to the caller. The second portion becomes a new free     : 
90c2			;        block, and the free list is adjusted to maintain continuity via this : 
90c2			;        newly created block.                                                 : 
90c2			;                                                                             : 
90c2			;     malloc does not set any initial value in the allocated space, the       : 
90c2			;     caller is required to do this as required.                              : 
90c2			;                                                                             : 
90c2			;     This implementation of malloc uses the stack exclusively, and is        : 
90c2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c2			;     advisable to disable interrupts before calling malloc, and recommended  : 
90c2			;     to avoid the use of malloc inside ISRs in general.                      : 
90c2			;                                                                             : 
90c2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c2			;                                                                             : 
90c2			; Parameters                                                                  : 
90c2			;     HL  Number of bytes wanted                                              : 
90c2			;                                                                             : 
90c2			; Returns                                                                     : 
90c2			;     HL  Address of the first useable byte of the allocation                 : 
90c2			;                                                                             : 
90c2			; Flags                                                                       : 
90c2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90c2			;                                                                             : 
90c2			; Stack frame                                                                 : 
90c2			;       |             |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |     BC      |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |     DE      |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |     IX      |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |  prev_free  |                                                       : 
90c2			;   +4  +-------------+                                                       : 
90c2			;       |  this_free  |                                                       : 
90c2			;   +2  +-------------+                                                       : 
90c2			;       |  next_free  |                                                       : 
90c2			;   +0  +-------------+                                                       : 
90c2			;       |             |                                                       : 
90c2			;                                                                             : 
90c2			;------------------------------------------------------------------------------ 
90c2			 
90c2			 
90c2			;malloc: 
90c2			; 
90c2			;	SAVESP ON 1 
90c2			; 
90c2			;	call malloc_code 
90c2			; 
90c2			;	CHECKSP ON 1 
90c2			;	ret 
90c2			 
90c2			 
90c2			malloc: 
90c2 c5			      push  BC 
90c3 d5			      push  DE 
90c4 dd e5		      push  IX 
90c6			if DEBUG_FORTH_MALLOC_HIGH 
90c6			call malloc_guard_entry 
90c6			endif 
90c6			 
90c6					if DEBUG_FORTH_MALLOC 
90c6						DMARK "mal" 
90c6						CALLMONITOR 
90c6					endif 
90c6 7c			      ld    A, H                    ; Exit if no space requested 
90c7 b5			      or    L 
90c8 ca 87 91		      jp    Z, malloc_early_exit 
90cb			 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			; 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			 
90cb			 
90cb			 
90cb			 
90cb					if DEBUG_FORTH_MALLOC 
90cb						DMARK "maA" 
90cb						CALLMONITOR 
90cb					endif 
90cb			      ; Set up stack frame 
90cb eb			      ex    DE, HL 
90cc 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90cf 39			      add   HL, SP 
90d0 f9			      ld    SP, HL 
90d1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90d5 dd 39		      add   IX, SP 
90d7			 
90d7			      ; Setup initial state 
90d7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90da 19			      add   HL, DE 
90db			 
90db 44			      ld    B, H                    ; Move want to BC 
90dc 4d			      ld    C, L 
90dd			 
90dd 21 3c dd		      ld    HL, free_list           ; Store prev_free ptr to stack 
90e0 dd 75 04		      ld    (IX+4), L 
90e3 dd 74 05		      ld    (IX+5), H 
90e6			 
90e6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90e7 23			      inc   HL 
90e8 56			      ld    D, (HL) 
90e9 dd 73 02		      ld    (IX+2), E 
90ec dd 72 03		      ld    (IX+3), D 
90ef eb			      ex    DE, HL                  ; this_free ptr into HL 
90f0			 
90f0					if DEBUG_FORTH_MALLOC 
90f0						DMARK "maB" 
90f0						CALLMONITOR 
90f0					endif 
90f0			      ; Loop through free block list to find some space 
90f0			malloc_find_space: 
90f0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90f1 23			      inc   HL 
90f2 56			      ld    D, (HL) 
90f3			 
90f3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90f4 b3			      or    E 
90f5 ca 81 91		      jp    Z, malloc_no_space 
90f8			 
90f8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90fb dd 72 01		      ld    (IX+1), D 
90fe			 
90fe			      ; Does this block have enough space to make the allocation? 
90fe 23			      inc   HL                      ; Load free block size into DE 
90ff 5e			      ld    E, (HL) 
9100 23			      inc   HL 
9101 56			      ld    D, (HL) 
9102			 
9102 eb			      ex    DE, HL                  ; Check size of block against want 
9103 b7			      or    A                       ; Ensure carry flag clear 
9104 ed 42		      sbc   HL, BC 
9106 e5			      push  HL                      ; Store the result for later (new block size) 
9107			 
9107 ca 56 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
910a 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
910c			 
910c			      ; this_free block is not big enough, setup ptrs to test next free block 
910c e1			      pop   HL                      ; Discard previous result 
910d			 
910d dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9110 dd 66 03		      ld    H, (IX+3) 
9113 dd 75 04		      ld    (IX+4), L 
9116 dd 74 05		      ld    (IX+5), H 
9119			 
9119 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911c dd 66 01		      ld    H, (IX+1) 
911f dd 75 02		      ld    (IX+2), L 
9122 dd 74 03		      ld    (IX+3), H 
9125			 
9125					if DEBUG_FORTH_MALLOC 
9125						DMARK "MA>" 
9125						CALLMONITOR 
9125					endif 
9125 18 c9		      jr    malloc_find_space 
9127			 
9127			      ; split a bigger block into two - requested size and remaining size 
9127			malloc_alloc_split: 
9127					if DEBUG_FORTH_MALLOC 
9127						DMARK "MAs" 
9127						CALLMONITOR 
9127					endif 
9127 eb			      ex    DE, HL                  ; Calculate address of new free block 
9128 2b			      dec   HL 
9129 2b			      dec   HL 
912a 2b			      dec   HL 
912b 09			      add   HL, BC 
912c			 
912c			      ; Create a new block and point it at next_free 
912c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
912f dd 56 01		      ld    D, (IX+1) 
9132			 
9132 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9133 23			      inc   HL 
9134 72			      ld    (HL), D 
9135			 
9135 d1			      pop   DE                      ; Store size of new block into new block 
9136 23			      inc   HL 
9137 73			      ld    (HL), E 
9138 23			      inc   HL 
9139 72			      ld    (HL), D 
913a			 
913a			      ; Update this_free ptr to point to new block 
913a 2b			      dec   HL 
913b 2b			      dec   HL 
913c 2b			      dec   HL 
913d			 
913d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9140 dd 56 03		      ld    D, (IX+3) 
9143			 
9143 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9146 dd 74 03		      ld    (IX+3), H 
9149			 
9149			      ; Modify this_free block to be allocation 
9149 eb			      ex    DE, HL 
914a af			      xor   A                       ; Null the next block ptr of allocated block 
914b 77			      ld    (HL), A 
914c 23			      inc   HL 
914d 77			      ld    (HL), A 
914e			 
914e 23			      inc   HL                      ; Store want size into allocated block 
914f 71			      ld    (HL), C 
9150 23			      inc   HL 
9151 70			      ld    (HL), B 
9152 23			      inc   HL 
9153 e5			      push  HL                      ; Address of allocation to return 
9154			 
9154 18 19		      jr    malloc_update_links 
9156			 
9156			malloc_alloc_fit: 
9156 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9157			 
9157					if DEBUG_FORTH_MALLOC 
9157						DMARK "MAf" 
9157						CALLMONITOR 
9157					endif 
9157			      ; Modify this_free block to be allocation 
9157 eb			      ex    DE, HL 
9158 2b			      dec   HL 
9159 2b			      dec   HL 
915a 2b			      dec   HL 
915b			 
915b af			      xor   A                       ; Null the next block ptr of allocated block 
915c 77			      ld    (HL), A 
915d 23			      inc   HL 
915e 77			      ld    (HL), A 
915f			 
915f 23			      inc   HL                      ; Store address of allocation to return 
9160 23			      inc   HL 
9161 23			      inc   HL 
9162 e5			      push  HL 
9163			 
9163			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9163 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9166 dd 66 01		      ld    H, (IX+1) 
9169			 
9169 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
916c dd 74 03		      ld    (IX+3), H 
916f			 
916f			 
916f			malloc_update_links: 
916f			      ; Update prev_free ptr to point to this_free 
916f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9172 dd 66 05		      ld    H, (IX+5) 
9175			 
9175 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9178 dd 56 03		      ld    D, (IX+3) 
917b			 
917b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
917c 23			      inc   HL 
917d 72			      ld    (HL), D 
917e			 
917e					if DEBUG_FORTH_MALLOC 
917e						DMARK "Mul" 
917e						CALLMONITOR 
917e					endif 
917e			      ; Clear the Z flag to indicate successful allocation 
917e 7a			      ld    A, D 
917f b3			      or    E 
9180			 
9180 d1			      pop   DE                      ; Address of allocation 
9181					if DEBUG_FORTH_MALLOC 
9181						DMARK "MAu" 
9181						CALLMONITOR 
9181					endif 
9181			 
9181			malloc_no_space: 
9181 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9184 39			      add   HL, SP 
9185 f9			      ld    SP, HL 
9186			 
9186 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9187					if DEBUG_FORTH_MALLOC 
9187						DMARK "MAN" 
9187						CALLMONITOR 
9187					endif 
9187			 
9187			malloc_early_exit: 
9187					if DEBUG_FORTH_MALLOC 
9187						DMARK "MAx" 
9187						CALLMONITOR 
9187					endif 
9187 dd e1		      pop   IX 
9189 d1			      pop   DE 
918a c1			      pop   BC 
918b			 
918b			if DEBUG_FORTH_MALLOC_HIGH 
918b			call malloc_guard_exit 
918b			call malloc_guard_zerolen 
918b			endif 
918b c9			      ret 
918c			 
918c			 
918c			;------------------------------------------------------------------------------ 
918c			;     free                                                                    : 
918c			;                                                                             : 
918c			; Description                                                                 : 
918c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
918c			;     returned by malloc, otherwise the behaviour is undefined.               : 
918c			;                                                                             : 
918c			;     Where possible, directly adjacent free blocks will be merged together   : 
918c			;     into larger blocks to help ensure that the heap does not become         : 
918c			;     excessively fragmented.                                                 : 
918c			;                                                                             : 
918c			;     free does not clear or set any other value into the freed space, and    : 
918c			;     therefore its contents may be visible through subsequent malloc's. The  : 
918c			;     caller should clear the freed space as required.                        : 
918c			;                                                                             : 
918c			;     This implementation of free uses the stack exclusively, and is          : 
918c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
918c			;     advisable to disable interrupts before calling free, and recommended    : 
918c			;     to avoid the use of free inside ISRs in general.                        : 
918c			;                                                                             : 
918c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
918c			;                                                                             : 
918c			; Parameters                                                                  : 
918c			;     HL  Pointer to address of first byte of allocation to be freed          : 
918c			;                                                                             : 
918c			; Returns                                                                     : 
918c			;     Nothing                                                                 : 
918c			;                                                                             : 
918c			; Stack frame                                                                 : 
918c			;       |             |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |     BC      |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |     DE      |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |     IX      |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |  prev_free  |                                                       : 
918c			;   +2  +-------------+                                                       : 
918c			;       |  next_free  |                                                       : 
918c			;   +0  +-------------+                                                       : 
918c			;       |             |                                                       : 
918c			;                                                                             : 
918c			;------------------------------------------------------------------------------ 
918c			free: 
918c c5			      push  BC 
918d d5			      push  DE 
918e dd e5		      push  IX 
9190			 
9190 7c			      ld    A, H                    ; Exit if ptr is null 
9191 b5			      or    L 
9192 ca 56 92		      jp    Z, free_early_exit 
9195			 
9195			      ; Set up stack frame 
9195 eb			      ex    DE, HL 
9196 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9199 39			      add   HL, SP 
919a f9			      ld    SP, HL 
919b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
919f dd 39		      add   IX, SP 
91a1			 
91a1			      ; The address in HL points to the start of the useable allocated space, 
91a1			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91a1			      ; address of the block itself. 
91a1 eb			      ex    DE, HL 
91a2 11 fc ff		      ld    DE, -4 
91a5 19			      add   HL, DE 
91a6			 
91a6			      ; An allocated block must have a null next block pointer in it 
91a6 7e			      ld    A, (HL) 
91a7 23			      inc   HL 
91a8 b6			      or    (HL) 
91a9 c2 51 92		      jp    NZ, free_done 
91ac			 
91ac 2b			      dec   HL 
91ad			 
91ad 44			      ld    B, H                    ; Copy HL to BC 
91ae 4d			      ld    C, L 
91af			 
91af			      ; Loop through the free list to find the first block with an address 
91af			      ; higher than the block being freed 
91af 21 3c dd		      ld    HL, free_list 
91b2			 
91b2			free_find_higher_block: 
91b2 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91b3 23			      inc   HL 
91b4 56			      ld    D, (HL) 
91b5 2b			      dec   HL 
91b6			 
91b6 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91b9 dd 72 01		      ld    (IX+1), D 
91bc dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91bf dd 74 03		      ld    (IX+3), H 
91c2			 
91c2 78			      ld    A, B                    ; Check if DE is greater than BC 
91c3 ba			      cp    D                       ; Compare MSB first 
91c4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91c6 30 04		      jr    NC, free_find_higher_block_skip 
91c8 79			      ld    A, C 
91c9 bb			      cp    E                       ; Then compare LSB 
91ca 38 08		      jr    C, free_found_higher_block 
91cc			 
91cc			free_find_higher_block_skip: 
91cc 7a			      ld    A, D                    ; Reached the end of the free list? 
91cd b3			      or    E 
91ce ca 51 92		      jp    Z, free_done 
91d1			 
91d1 eb			      ex    DE, HL 
91d2			 
91d2 18 de		      jr    free_find_higher_block 
91d4			 
91d4			free_found_higher_block: 
91d4			      ; Insert freed block between prev and next free blocks 
91d4 71			      ld    (HL), C                 ; Point prev free block to freed block 
91d5 23			      inc   HL 
91d6 70			      ld    (HL), B 
91d7			 
91d7 60			      ld    H, B                    ; Point freed block at next free block 
91d8 69			      ld    L, C 
91d9 73			      ld    (HL), E 
91da 23			      inc   HL 
91db 72			      ld    (HL), D 
91dc			 
91dc			      ; Check if the freed block is adjacent to the next free block 
91dc 23			      inc   HL                      ; Load size of freed block into HL 
91dd 5e			      ld    E, (HL) 
91de 23			      inc   HL 
91df 56			      ld    D, (HL) 
91e0 eb			      ex    DE, HL 
91e1			 
91e1 09			      add   HL, BC                  ; Add addr of freed block and its size 
91e2			 
91e2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91e5 dd 56 01		      ld    D, (IX+1) 
91e8			 
91e8 b7			      or    A                       ; Clear the carry flag 
91e9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91eb 20 22		      jr    NZ, free_check_adjacent_to_prev 
91ed			 
91ed			      ; Freed block is adjacent to next, merge into one bigger block 
91ed eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91ee 5e			      ld    E, (HL) 
91ef 23			      inc   HL 
91f0 56			      ld    D, (HL) 
91f1 e5			      push  HL                      ; Save ptr to next block for later 
91f2			 
91f2 60			      ld    H, B                    ; Store ptr from next block into freed block 
91f3 69			      ld    L, C 
91f4 73			      ld    (HL), E 
91f5 23			      inc   HL 
91f6 72			      ld    (HL), D 
91f7			 
91f7 e1			      pop   HL                      ; Restore ptr to next block 
91f8 23			      inc   HL                      ; Load size of next block into DE 
91f9 5e			      ld    E, (HL) 
91fa 23			      inc   HL 
91fb 56			      ld    D, (HL) 
91fc d5			      push  DE                      ; Save next block size for later 
91fd			 
91fd 60			      ld    H, B                    ; Load size of freed block into HL 
91fe 69			      ld    L, C 
91ff 23			      inc   HL 
9200 23			      inc   HL 
9201 5e			      ld    E, (HL) 
9202 23			      inc   HL 
9203 56			      ld    D, (HL) 
9204 eb			      ex    DE, HL 
9205			 
9205 d1			      pop   DE                      ; Restore size of next block 
9206 19			      add   HL, DE                  ; Add sizes of both blocks 
9207 eb			      ex    DE, HL 
9208			 
9208 60			      ld    H, B                    ; Store new bigger size into freed block 
9209 69			      ld    L, C 
920a 23			      inc   HL 
920b 23			      inc   HL 
920c 73			      ld    (HL), E 
920d 23			      inc   HL 
920e 72			      ld    (HL), D 
920f			 
920f			free_check_adjacent_to_prev: 
920f			      ; Check if the freed block is adjacent to the prev free block 
920f dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9212 dd 66 03		      ld    H, (IX+3) 
9215			 
9215 23			      inc   HL                      ; Size of prev free block into DE 
9216 23			      inc   HL 
9217 5e			      ld    E, (HL) 
9218 23			      inc   HL 
9219 56			      ld    D, (HL) 
921a 2b			      dec   HL 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d			 
921d 19			      add   HL, DE                  ; Add prev block addr and size 
921e			 
921e b7			      or    A                       ; Clear the carry flag 
921f ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9221 20 2e		      jr    NZ, free_done 
9223			 
9223			      ; Freed block is adjacent to prev, merge into one bigger block 
9223 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9224 69			      ld    L, C 
9225 5e			      ld    E, (HL) 
9226 23			      inc   HL 
9227 56			      ld    D, (HL) 
9228 e5			      push  HL                      ; Save freed block ptr for later 
9229			 
9229 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
922c dd 66 03		      ld    H, (IX+3) 
922f 73			      ld    (HL), E 
9230 23			      inc   HL 
9231 72			      ld    (HL), D 
9232			 
9232 e1			      pop   HL                      ; Restore freed block ptr 
9233 23			      inc   HL                      ; Load size of freed block into DE 
9234 5e			      ld    E, (HL) 
9235 23			      inc   HL 
9236 56			      ld    D, (HL) 
9237 d5			      push  DE                      ; Save freed block size for later 
9238			 
9238 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
923b dd 66 03		      ld    H, (IX+3) 
923e 23			      inc   HL 
923f 23			      inc   HL 
9240 5e			      ld    E, (HL) 
9241 23			      inc   HL 
9242 56			      ld    D, (HL) 
9243			 
9243 e1			      pop   HL                      ; Add sizes of both blocks 
9244 19			      add   HL, DE 
9245 eb			      ex    DE, HL 
9246			 
9246 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9249 dd 66 03		      ld    H, (IX+3) 
924c 23			      inc   HL 
924d 23			      inc   HL 
924e 73			      ld    (HL), E 
924f 23			      inc   HL 
9250 72			      ld    (HL), D 
9251			 
9251			free_done: 
9251 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9254 39			      add   HL, SP 
9255 f9			      ld    SP, HL 
9256			 
9256			free_early_exit: 
9256 dd e1		      pop   IX 
9258 d1			      pop   DE 
9259 c1			      pop   BC 
925a			 
925a c9			      ret 
925b			 
925b			; moved to firmware.asm 
925b			; 
925b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925b			;                  .dw   0 
925b			 
925b			 
925b			endif 
925b			 
925b			 
925b			if MALLOC_3 
925b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
925b			;heap_start        .equ  0x9000      ; Starting address of heap 
925b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
925b			; 
925b			 ;     .org 0 
925b			  ;    jp    main 
925b			; 
925b			; 
925b			 ;     .org  0x100 
925b			;main: 
925b			 ;     ld    HL, 0x8100 
925b			  ;    ld    SP, HL 
925b			; 
925b			;      call  heap_init 
925b			 
925b			      ; Make some allocations 
925b			;      ld    HL, 12 
925b			;      call  malloc            ; Allocates 0x9004 
925b			; 
925b			 ;     ld    HL, 12 
925b			;      call  malloc            ; Allocates 0x9014 
925b			 
925b			;      ld    HL, 12 
925b			;      call  malloc            ; Allocates 0x9024 
925b			 
925b			      ; Free some allocations 
925b			;      ld    HL, 0x9014 
925b			;      call  free 
925b			 
925b			;      ld    HL, 0x9004 
925b			;      call  free 
925b			; 
925b			;      ld    HL, 0x9024 
925b			;      call  free 
925b			 
925b			 
925b			 ;     halt 
925b			 
925b			 
925b			;------------------------------------------------------------------------------ 
925b			;     heap_init                                                               : 
925b			;                                                                             : 
925b			; Description                                                                 : 
925b			;     Initialise the heap and make it ready for malloc and free operations.   : 
925b			;                                                                             : 
925b			;     The heap is maintained as a linked list, starting with an initial       : 
925b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
925b			;     the first free block in the heap. Each block then points to the next    : 
925b			;     free block within the heap, and the free list ends at the first block   : 
925b			;     with a null pointer to the next free block.                             : 
925b			;                                                                             : 
925b			; Parameters                                                                  : 
925b			;     Inputs are compile-time only. Two defines which specify the starting    : 
925b			;     address of the heap and its size are required, along with a memory      : 
925b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
925b			;     principally stores a pointer to the first free block in the heap.       : 
925b			;                                                                             : 
925b			; Returns                                                                     : 
925b			;     Nothing                                                                 : 
925b			;------------------------------------------------------------------------------ 
925b			heap_init: 
925b			      push  HL 
925b			 
925b			      ; Initialise free list struct 
925b			      ld    HL, heap_start 
925b			      ld    (free_list), HL 
925b			      ld    HL, 0 
925b			      ld    (free_list+2), HL 
925b			 
925b			      ; Insert first free block at bottom of heap, consumes entire heap 
925b			      ld    HL, heap_start+heap_size-4 
925b			      ld    (heap_start), HL        ; Next block (end of free list) 
925b			      ld    HL, heap_size-4 
925b			      ld    (heap_start+2), HL      ; Block size 
925b			 
925b			      ; Insert end of free list block at top of heap - two null words will 
925b			      ; terminate the free list 
925b			      ld    HL, 0 
925b			      ld    (heap_start+heap_size-2), HL 
925b			      ld    (heap_start+heap_size-4), HL 
925b			 
925b			      pop   HL 
925b			 
925b			      ret 
925b			 
925b			 
925b			;------------------------------------------------------------------------------ 
925b			;     malloc                                                                  : 
925b			;                                                                             : 
925b			; Description                                                                 : 
925b			;     Allocates the wanted space from the heap and returns the address of the : 
925b			;     first useable byte of the allocation.                                   : 
925b			;                                                                             : 
925b			;     Allocations can happen in one of two ways:                              : 
925b			;                                                                             : 
925b			;     1. A free block may be found which is the exact size wanted. In this    : 
925b			;        case the block is removed from the free list and retuedn to the      : 
925b			;        caller.                                                              : 
925b			;     2. A free block may be found which is larger than the size wanted. In   : 
925b			;        this case, the larger block is split into two. The first portion of  : 
925b			;        this block will become the requested space by the malloc call and    : 
925b			;        is returned to the caller. The second portion becomes a new free     : 
925b			;        block, and the free list is adjusted to maintain continuity via this : 
925b			;        newly created block.                                                 : 
925b			;                                                                             : 
925b			;     malloc does not set any initial value in the allocated space, the       : 
925b			;     caller is required to do this as required.                              : 
925b			;                                                                             : 
925b			;     This implementation of malloc uses the stack exclusively, and is        : 
925b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925b			;     advisable to disable interrupts before calling malloc, and recommended  : 
925b			;     to avoid the use of malloc inside ISRs in general.                      : 
925b			;                                                                             : 
925b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925b			;                                                                             : 
925b			; Parameters                                                                  : 
925b			;     HL  Number of bytes wanted                                              : 
925b			;                                                                             : 
925b			; Returns                                                                     : 
925b			;     HL  Address of the first useable byte of the allocation                 : 
925b			;                                                                             : 
925b			; Flags                                                                       : 
925b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
925b			;                                                                             : 
925b			; Stack frame                                                                 : 
925b			;       |             |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     BC      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     DE      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     IX      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |  prev_free  |                                                       : 
925b			;   +4  +-------------+                                                       : 
925b			;       |  this_free  |                                                       : 
925b			;   +2  +-------------+                                                       : 
925b			;       |  next_free  |                                                       : 
925b			;   +0  +-------------+                                                       : 
925b			;       |             |                                                       : 
925b			;                                                                             : 
925b			;------------------------------------------------------------------------------ 
925b			malloc: 
925b			      push  BC 
925b			      push  DE 
925b			      push  IX 
925b			 
925b			      ld    A, H                    ; Exit if no space requested 
925b			      or    L 
925b			      jp    Z, malloc_early_exit 
925b			 
925b			      ; Set up stack frame 
925b			      ex    DE, HL 
925b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			      ld    IX, 0                   ; Use IX as a frame pointer 
925b			      add   IX, SP 
925b			 
925b			      ; Setup initial state 
925b			      ld    HL, 4                   ; want must also include space used by block struct 
925b			      add   HL, DE 
925b			 
925b			      ld    B, H                    ; Move want to BC 
925b			      ld    C, L 
925b			 
925b			      ld    HL, free_list           ; Store prev_free ptr to stack 
925b			      ld    (IX+4), L 
925b			      ld    (IX+5), H 
925b			 
925b			      ld    E, (HL)                 ; Store this_free ptr to stack 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      ld    (IX+2), E 
925b			      ld    (IX+3), D 
925b			      ex    DE, HL                  ; this_free ptr into HL 
925b			 
925b			      ; Loop through free block list to find some space 
925b			malloc_find_space: 
925b			      ld    E, (HL)                 ; Load next_free ptr into DE 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			 
925b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
925b			      or    E 
925b			      jp    Z, malloc_no_space 
925b			 
925b			      ld    (IX+0), E               ; Store next_free ptr to stack 
925b			      ld    (IX+1), D 
925b			 
925b			      ; Does this block have enough space to make the allocation? 
925b			      inc   HL                      ; Load free block size into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			 
925b			      ex    DE, HL                  ; Check size of block against want 
925b			      or    A                       ; Ensure carry flag clear 
925b			      sbc   HL, BC 
925b			      push  HL                      ; Store the result for later (new block size) 
925b			 
925b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
925b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
925b			 
925b			      ; this_free block is not big enough, setup ptrs to test next free block 
925b			      pop   HL                      ; Discard previous result 
925b			 
925b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
925b			      ld    H, (IX+3) 
925b			      ld    (IX+4), L 
925b			      ld    (IX+5), H 
925b			 
925b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
925b			      ld    H, (IX+1) 
925b			      ld    (IX+2), L 
925b			      ld    (IX+3), H 
925b			 
925b			      jr    malloc_find_space 
925b			 
925b			      ; split a bigger block into two - requested size and remaining size 
925b			malloc_alloc_split: 
925b			      ex    DE, HL                  ; Calculate address of new free block 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			      add   HL, BC 
925b			 
925b			      ; Create a new block and point it at next_free 
925b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
925b			      ld    D, (IX+1) 
925b			 
925b			      ld    (HL), E                 ; Store next_free ptr into new block 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      pop   DE                      ; Store size of new block into new block 
925b			      inc   HL 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      ; Update this_free ptr to point to new block 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			 
925b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
925b			      ld    D, (IX+3) 
925b			 
925b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
925b			      ld    (IX+3), H 
925b			 
925b			      ; Modify this_free block to be allocation 
925b			      ex    DE, HL 
925b			      xor   A                       ; Null the next block ptr of allocated block 
925b			      ld    (HL), A 
925b			      inc   HL 
925b			      ld    (HL), A 
925b			 
925b			      inc   HL                      ; Store want size into allocated block 
925b			      ld    (HL), C 
925b			      inc   HL 
925b			      ld    (HL), B 
925b			      inc   HL 
925b			      push  HL                      ; Address of allocation to return 
925b			 
925b			      jr    malloc_update_links 
925b			 
925b			malloc_alloc_fit: 
925b			      pop   HL                      ; Dont need new block size, want is exact fit 
925b			 
925b			      ; Modify this_free block to be allocation 
925b			      ex    DE, HL 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			 
925b			      xor   A                       ; Null the next block ptr of allocated block 
925b			      ld    (HL), A 
925b			      inc   HL 
925b			      ld    (HL), A 
925b			 
925b			      inc   HL                      ; Store address of allocation to return 
925b			      inc   HL 
925b			      inc   HL 
925b			      push  HL 
925b			 
925b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
925b			      ld    L, (IX+0)               ; next_free to HL 
925b			      ld    H, (IX+1) 
925b			 
925b			      ld    (IX+2), L               ; HL to this_free 
925b			      ld    (IX+3), H 
925b			 
925b			 
925b			malloc_update_links: 
925b			      ; Update prev_free ptr to point to this_free 
925b			      ld    L, (IX+4)               ; prev_free ptr to HL 
925b			      ld    H, (IX+5) 
925b			 
925b			      ld    E, (IX+2)               ; this_free ptr to DE 
925b			      ld    D, (IX+3) 
925b			 
925b			      ld    (HL), E                 ; this_free ptr into prev_free 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      ; Clear the Z flag to indicate successful allocation 
925b			      ld    A, D 
925b			      or    E 
925b			 
925b			      pop   DE                      ; Address of allocation 
925b			 
925b			malloc_no_space: 
925b			      ld    HL, 6                   ; Clean up stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			 
925b			      ex    DE, HL                  ; Alloc addr into HL for return 
925b			 
925b			malloc_early_exit: 
925b			      pop   IX 
925b			      pop   DE 
925b			      pop   BC 
925b			 
925b			      ret 
925b			 
925b			 
925b			;------------------------------------------------------------------------------ 
925b			;     free                                                                    : 
925b			;                                                                             : 
925b			; Description                                                                 : 
925b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
925b			;     returned by malloc, otherwise the behaviour is undefined.               : 
925b			;                                                                             : 
925b			;     Where possible, directly adjacent free blocks will be merged together   : 
925b			;     into larger blocks to help ensure that the heap does not become         : 
925b			;     excessively fragmented.                                                 : 
925b			;                                                                             : 
925b			;     free does not clear or set any other value into the freed space, and    : 
925b			;     therefore its contents may be visible through subsequent malloc's. The  : 
925b			;     caller should clear the freed space as required.                        : 
925b			;                                                                             : 
925b			;     This implementation of free uses the stack exclusively, and is          : 
925b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925b			;     advisable to disable interrupts before calling free, and recommended    : 
925b			;     to avoid the use of free inside ISRs in general.                        : 
925b			;                                                                             : 
925b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925b			;                                                                             : 
925b			; Parameters                                                                  : 
925b			;     HL  Pointer to address of first byte of allocation to be freed          : 
925b			;                                                                             : 
925b			; Returns                                                                     : 
925b			;     Nothing                                                                 : 
925b			;                                                                             : 
925b			; Stack frame                                                                 : 
925b			;       |             |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     BC      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     DE      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     IX      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |  prev_free  |                                                       : 
925b			;   +2  +-------------+                                                       : 
925b			;       |  next_free  |                                                       : 
925b			;   +0  +-------------+                                                       : 
925b			;       |             |                                                       : 
925b			;                                                                             : 
925b			;------------------------------------------------------------------------------ 
925b			free: 
925b			      push  BC 
925b			      push  DE 
925b			      push  IX 
925b			 
925b			      ld    A, H                    ; Exit if ptr is null 
925b			      or    L 
925b			      jp    Z, free_early_exit 
925b			 
925b			      ; Set up stack frame 
925b			      ex    DE, HL 
925b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			      ld    IX, 0                   ; Use IX as a frame pointer 
925b			      add   IX, SP 
925b			 
925b			      ; The address in HL points to the start of the useable allocated space, 
925b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
925b			      ; address of the block itself. 
925b			      ex    DE, HL 
925b			      ld    DE, -4 
925b			      add   HL, DE 
925b			 
925b			      ; An allocated block must have a null next block pointer in it 
925b			      ld    A, (HL) 
925b			      inc   HL 
925b			      or    (HL) 
925b			      jp    NZ, free_done 
925b			 
925b			      dec   HL 
925b			 
925b			      ld    B, H                    ; Copy HL to BC 
925b			      ld    C, L 
925b			 
925b			      ; Loop through the free list to find the first block with an address 
925b			      ; higher than the block being freed 
925b			      ld    HL, free_list 
925b			 
925b			free_find_higher_block: 
925b			      ld    E, (HL)                 ; Load next ptr from free block 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      dec   HL 
925b			 
925b			      ld    (IX+0), E               ; Save ptr to next free block 
925b			      ld    (IX+1), D 
925b			      ld    (IX+2), L               ; Save ptr to prev free block 
925b			      ld    (IX+3), H 
925b			 
925b			      ld    A, B                    ; Check if DE is greater than BC 
925b			      cp    D                       ; Compare MSB first 
925b			      jr    Z, $+4                  ; MSB the same, compare LSB 
925b			      jr    NC, free_find_higher_block_skip 
925b			      ld    A, C 
925b			      cp    E                       ; Then compare LSB 
925b			      jr    C, free_found_higher_block 
925b			 
925b			free_find_higher_block_skip: 
925b			      ld    A, D                    ; Reached the end of the free list? 
925b			      or    E 
925b			      jp    Z, free_done 
925b			 
925b			      ex    DE, HL 
925b			 
925b			      jr    free_find_higher_block 
925b			 
925b			free_found_higher_block: 
925b			      ; Insert freed block between prev and next free blocks 
925b			      ld    (HL), C                 ; Point prev free block to freed block 
925b			      inc   HL 
925b			      ld    (HL), B 
925b			 
925b			      ld    H, B                    ; Point freed block at next free block 
925b			      ld    L, C 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      ; Check if the freed block is adjacent to the next free block 
925b			      inc   HL                      ; Load size of freed block into HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      ex    DE, HL 
925b			 
925b			      add   HL, BC                  ; Add addr of freed block and its size 
925b			 
925b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
925b			      ld    D, (IX+1) 
925b			 
925b			      or    A                       ; Clear the carry flag 
925b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
925b			      jr    NZ, free_check_adjacent_to_prev 
925b			 
925b			      ; Freed block is adjacent to next, merge into one bigger block 
925b			      ex    DE, HL                  ; Load next ptr from next block into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  HL                      ; Save ptr to next block for later 
925b			 
925b			      ld    H, B                    ; Store ptr from next block into freed block 
925b			      ld    L, C 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      pop   HL                      ; Restore ptr to next block 
925b			      inc   HL                      ; Load size of next block into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  DE                      ; Save next block size for later 
925b			 
925b			      ld    H, B                    ; Load size of freed block into HL 
925b			      ld    L, C 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      ex    DE, HL 
925b			 
925b			      pop   DE                      ; Restore size of next block 
925b			      add   HL, DE                  ; Add sizes of both blocks 
925b			      ex    DE, HL 
925b			 
925b			      ld    H, B                    ; Store new bigger size into freed block 
925b			      ld    L, C 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			free_check_adjacent_to_prev: 
925b			      ; Check if the freed block is adjacent to the prev free block 
925b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
925b			      ld    H, (IX+3) 
925b			 
925b			      inc   HL                      ; Size of prev free block into DE 
925b			      inc   HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			 
925b			      add   HL, DE                  ; Add prev block addr and size 
925b			 
925b			      or    A                       ; Clear the carry flag 
925b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
925b			      jr    NZ, free_done 
925b			 
925b			      ; Freed block is adjacent to prev, merge into one bigger block 
925b			      ld    H, B                    ; Load next ptr from freed block into DE 
925b			      ld    L, C 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  HL                      ; Save freed block ptr for later 
925b			 
925b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
925b			      ld    H, (IX+3) 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      pop   HL                      ; Restore freed block ptr 
925b			      inc   HL                      ; Load size of freed block into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  DE                      ; Save freed block size for later 
925b			 
925b			      ld    L, (IX+2)               ; Load size of prev block into DE 
925b			      ld    H, (IX+3) 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			 
925b			      pop   HL                      ; Add sizes of both blocks 
925b			      add   HL, DE 
925b			      ex    DE, HL 
925b			 
925b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
925b			      ld    H, (IX+3) 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			free_done: 
925b			      ld    HL, 4                   ; Clean up stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			 
925b			free_early_exit: 
925b			      pop   IX 
925b			      pop   DE 
925b			      pop   BC 
925b			 
925b			      ret 
925b			 
925b			 
925b			;      .org 0x8000 
925b			; 
925b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925b			 ;                 .dw   0 
925b			 
925b			endif 
925b			 
925b			 
925b			if MALLOC_4 
925b			 
925b			; My memory allocation code. Very very simple.... 
925b			; allocate space under 250 chars 
925b			 
925b			heap_init: 
925b				; init start of heap as zero 
925b				;  
925b			 
925b				ld hl, heap_start 
925b				ld a, 0 
925b				ld (hl), a      ; empty block 
925b				inc hl 
925b				ld a, 0 
925b				ld (hl), a      ; length of block 
925b				; write end of list 
925b				inc hl 
925b				ld a,(hl) 
925b				inc hl 
925b				ld a,(hl) 
925b				 
925b			 
925b				; init some malloc vars 
925b			 
925b				ld hl, 0 
925b				ld (free_list), hl       ; store last malloc location 
925b			 
925b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
925b				ld a, 0 
925b				ld (hl), a 
925b			 
925b			 
925b				ld hl, heap_start 
925b				;  
925b				  
925b				ret 
925b			 
925b			 
925b			;    free block marker 
925b			;    requested size  
925b			;    pointer to next block 
925b			;    .... 
925b			;    next block marker 
925b			 
925b			 
925b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
925b			; 
925b			 
925b			 
925b			malloc:  
925b				push de 
925b				push bc 
925b				push af 
925b			 
925b				; hl space required 
925b				 
925b				ld c, l    ; hold space   (TODO only a max of 255) 
925b			 
925b			;	inc c     ; TODO BUG need to fix memory leak on push str 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			 
925b			 
925b			 
925b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
925b			 
925b				ld a, (free_list+3) 
925b				cp 0 
925b				jr z, .contheap 
925b			 
925b				ld hl, (free_list)     ; get last alloc 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mrs" 
925b						CALLMONITOR 
925b					endif 
925b				jr .startalloc 
925b			 
925b			.contheap: 
925b				ld hl, heap_start 
925b			 
925b			.startalloc: 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mym" 
925b						CALLMONITOR 
925b					endif 
925b			.findblock: 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mmf" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b				ld a,(hl)  
925b				; if byte is zero then clear to use 
925b			 
925b				cp 0 
925b				jr z, .foundemptyblock 
925b			 
925b				; if byte is not clear 
925b				;     then byte is offset to next block 
925b			 
925b				inc hl 
925b				ld a, (hl) ; get size 
925b			.nextblock:	inc hl 
925b					ld e, (hl) 
925b					inc hl 
925b					ld d, (hl) 
925b					ex de, hl 
925b			;	inc hl  ; move past the store space 
925b			;	inc hl  ; move past zero index  
925b			 
925b				; TODO detect no more space 
925b			 
925b				push hl 
925b				ld de, heap_end 
925b				call cmp16 
925b				pop hl 
925b				jr nc, .nospace 
925b			 
925b				jr .findblock 
925b			 
925b			.nospace: ld hl, 0 
925b				jp .exit 
925b			 
925b			 
925b			.foundemptyblock:	 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mme" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			; TODO has block enough space if reusing??? 
925b			 
925b				;  
925b			 
925b			; see if this block has been previously used 
925b				inc hl 
925b				ld a, (hl) 
925b				dec hl 
925b				cp 0 
925b				jr z, .newblock 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "meR" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			; no reusing previously allocated block 
925b			 
925b			; is it smaller than previously used? 
925b				 
925b				inc hl    ; move to size 
925b				ld a, c 
925b				sub (hl)        ; we want c < (hl) 
925b				dec hl    ; move back to marker 
925b			        jr z, .findblock 
925b			 
925b				; update with the new size which should be lower 
925b			 
925b			        ;inc  hl   ; negate next move. move back to size  
925b			 
925b			.newblock: 
925b				; need to be at marker here 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "meN" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			 
925b				ld a, c 
925b			 
925b				ld (free_list+3), a	 ; flag resume from last malloc  
925b				ld (free_list), hl    ; save out last location 
925b			 
925b			 
925b				;inc a     ; space for length byte 
925b				ld (hl), a     ; save block in use marker 
925b			 
925b				inc hl   ; move to space marker 
925b				ld (hl), a    ; save new space 
925b			 
925b				inc hl   ; move to start of allocated area 
925b				 
925b			;	push hl     ; save where we are - 1  
925b			 
925b			;	inc hl  ; move past zero index  
925b				; skip space to set down new marker 
925b			 
925b				; provide some extra space for now 
925b			 
925b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
925b				inc a 
925b				inc a 
925b			 
925b				push hl   ; save where we are in the node block 
925b			 
925b				call addatohl 
925b			 
925b				; write linked list point 
925b			 
925b				pop de     ; get our node position 
925b				ex de, hl 
925b			 
925b				ld (hl), e 
925b				inc hl 
925b				ld (hl), d 
925b			 
925b				inc hl 
925b			 
925b				; now at start of allocated data so save pointer 
925b			 
925b				push hl 
925b			 
925b				; jump to position of next node and setup empty header in DE 
925b			 
925b				ex de, hl 
925b			 
925b			;	inc hl ; move past end of block 
925b			 
925b				ld a, 0 
925b				ld (hl), a   ; empty marker 
925b				inc hl 
925b				ld (hl), a   ; size 
925b				inc hl  
925b				ld (hl), a   ; ptr 
925b				inc hl 
925b				ld (hl), a   ; ptr 
925b			 
925b			 
925b				pop hl 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mmr" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			.exit: 
925b				pop af 
925b				pop bc 
925b				pop de  
925b				ret 
925b			 
925b			 
925b			 
925b			 
925b			free:  
925b				push hl 
925b				push af 
925b				; get address in hl 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "fre" 
925b						CALLMONITOR 
925b					endif 
925b				; data is at hl - move to block count 
925b				dec hl 
925b				dec hl    ; get past pointer 
925b				dec hl 
925b			 
925b				ld a, (hl)    ; need this for a validation check 
925b			 
925b				dec hl    ; move to block marker 
925b			 
925b				; now check that the block count and block marker are the same  
925b			        ; this checks that we are on a malloc node and not random memory 
925b			        ; OK a faint chance this could be a problem but rare - famous last words! 
925b			 
925b				ld c, a 
925b				ld a, (hl)    
925b			 
925b				cp c 
925b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
925b			 
925b				; yes good chance we are on a malloc node 
925b			 
925b				ld a, 0      
925b				ld (hl), a   ; mark as free 
925b			 
925b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
925b			 
925b			.freeignore:  
925b			 
925b				pop af 
925b				pop hl 
925b			 
925b				ret 
925b			 
925b			 
925b			 
925b			endif 
925b			 
925b			; eof 
# End of file firmware_memory.asm
925b			  
925b			; device C  
925b			; Now handled by SPI  
925b			;if SOUND_ENABLE  
925b			;	include "firmware_sound.asm"  
925b			;endif  
925b			  
925b			include "firmware_diags.asm"  
925b			; Hardware diags menu 
925b			 
925b			 
925b			config: 
925b			 
925b 3e 00			ld a, 0 
925d 21 81 92			ld hl, .configmn 
9260 cd eb 8a			call menu 
9263			 
9263 fe 00			cp 0 
9265 c8				ret z 
9266			 
9266			;	cp 1 
9266			;	call z, .savetostore 
9266			 
9266 fe 01			cp 1 
9268			if STARTUP_V1 
9268 cc 97 92			call z, .selautoload 
926b			endif 
926b			 
926b			if STARTUP_V2 
926b				call z, .enautoload 
926b			endif 
926b fe 02			cp 2 
926d cc 8d 92			call z, .disautoload 
9270			;	cp 3 
9270			;	call z, .selbank 
9270 fe 03			cp 3 
9272 cc b5 92			call z, .debug_tog 
9275 fe 04			cp 4 
9277 cc 03 94			call z, .bpsgo 
927a fe 05			cp 5 
927c cc de 92			call z, hardware_diags 
927f			if STARTUP_V2 
927f				cp 6 
927f				call z, create_startup 
927f			endif 
927f 18 da			jr config 
9281			 
9281			.configmn: 
9281			;	dw prom_c3 
9281 f1 95			dw prom_c2 
9283 06 96			dw prom_c2a 
9285			;	dw prom_c2b 
9285			;	dw prom_c4 
9285 25 96			dw prom_m4 
9287 40 96			dw prom_m4b 
9289 48 96			dw prom_c1 
928b			if STARTUP_V2 
928b				dw prom_c9 
928b			endif 
928b 00 00			dw 0 
928d				 
928d			 
928d			if STARTUP_V2 
928d			.enautoload: 
928d				if STORAGE_SE 
928d				ld a, $fe      ; bit 0 clear 
928d				ld (spi_device), a 
928d			 
928d				call storage_get_block_0 
928d			 
928d				ld a, 1 
928d				ld (store_page+STORE_0_AUTOFILE), a 
928d			 
928d					ld hl, 0 
928d					ld de, store_page 
928d				call storage_write_block	 ; save update 
928d				else 
928d			 
928d				ld hl, prom_notav 
928d				ld de, prom_empty 
928d				call info_panel 
928d				endif 
928d			 
928d			 
928d				ret 
928d			endif 
928d			 
928d			.disautoload: 
928d				if STORAGE_SE 
928d				ld a, $fe      ; bit 0 clear 
928d				ld (spi_device), a 
928d			 
928d				call storage_get_block_0 
928d			 
928d				ld a, 0 
928d				ld (store_page+STORE_0_AUTOFILE), a 
928d			 
928d					ld hl, 0 
928d					ld de, store_page 
928d				call storage_write_block	 ; save update 
928d				else 
928d			 
928d 21 57 96			ld hl, prom_notav 
9290 11 6d 96			ld de, prom_empty 
9293 cd 4b 8a			call info_panel 
9296				endif 
9296			 
9296			 
9296 c9				ret 
9297			 
9297			if STARTUP_V1 
9297			 
9297			; Select auto start 
9297			 
9297			.selautoload: 
9297			 
9297				 
9297				if STORAGE_SE 
9297			 
9297					call config_dir 
9297				        ld hl, scratch 
9297					ld a, 0 
9297					call menu 
9297			 
9297					cp 0 
9297					ret z 
9297			 
9297					dec a 
9297			 
9297			 
9297					; locate menu option 
9297			 
9297					ld hl, scratch 
9297					call table_lookup 
9297			 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "ALl" 
9297						CALLMONITOR 
9297					endif 
9297					; with the pointer to the menu it, the byte following the zero term is the file id 
9297			 
9297					ld a, 0 
9297					ld bc, 50   ; max of bytes to look at 
9297					cpir  
9297			 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "ALb" 
9297						CALLMONITOR 
9297					endif 
9297					;inc hl 
9297			 
9297					ld a, (hl)   ; file id 
9297					 
9297				        ; save bank and file ids 
9297			 
9297					push af 
9297			 
9297			; TODO need to save to block 0 on bank 1	 
9297			 
9297					call storage_get_block_0 
9297			 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "AL0" 
9297						CALLMONITOR 
9297					endif 
9297					pop af 
9297			 
9297					ld (store_page+STORE_0_FILERUN),a 
9297					 
9297					; save bank id 
9297			 
9297					ld a,(spi_device) 
9297					ld (store_page+STORE_0_BANKRUN),a 
9297			 
9297					; enable auto run of store file 
9297			 
9297					ld a, 1 
9297					ld (store_page+STORE_0_AUTOFILE),a 
9297			 
9297					; save buffer 
9297			 
9297					ld hl, 0 
9297					ld de, store_page 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "ALw" 
9297						CALLMONITOR 
9297					endif 
9297				call storage_write_block	 ; save update 
9297			  
9297			 
9297			 
9297			 
9297					ld hl, scratch 
9297					call config_fdir 
9297			 
9297				else 
9297			 
9297 21 57 96			ld hl, prom_notav 
929a 11 6d 96			ld de, prom_empty 
929d cd 4b 8a			call info_panel 
92a0			 
92a0				endif 
92a0 c9				ret 
92a1			endif 
92a1			 
92a1			 
92a1			; Select storage bank 
92a1			 
92a1			.selbank: 
92a1			 
92a1			;	if STORAGE_SE 
92a1			;	else 
92a1			 
92a1 21 57 96			ld hl, prom_notav 
92a4 11 6d 96			ld de, prom_empty 
92a7 cd 4b 8a			call info_panel 
92aa			;	endif 
92aa				 
92aa c9				ret 
92ab			 
92ab			if STORAGE_SE 
92ab			 
92ab			.config_ldir:   
92ab				; Load storage bank labels into menu array 
92ab			 
92ab				 
92ab			 
92ab			 
92ab				ret 
92ab			 
92ab			 
92ab			endif 
92ab			 
92ab			 
92ab			; Save user words to storage 
92ab			 
92ab			.savetostore: 
92ab			 
92ab			;	if STORAGE_SE 
92ab			; 
92ab			;		call config_dir 
92ab			;	        ld hl, scratch 
92ab			;		ld a, 0 
92ab			;		call menu 
92ab			;		 
92ab			;		ld hl, scratch 
92ab			;		call config_fdir 
92ab			; 
92ab			;	else 
92ab			 
92ab 21 57 96			ld hl, prom_notav 
92ae 11 6d 96			ld de, prom_empty 
92b1 cd 4b 8a			call info_panel 
92b4			 
92b4			;	endif 
92b4			 
92b4 c9				ret 
92b5			 
92b5			if STARTUP_V2 
92b5			 
92b5			create_startup: 
92b5			 
92b5				ld a, 0 
92b5				ld hl, .crstart 
92b5				call menu 
92b5			 
92b5				cp 0 
92b5				ret z 
92b5			 
92b5				cp 1 
92b5				call z, .genlsword 
92b5				cp 2 
92b5				call z, .genedword 
92b5			 
92b5				cp 3 
92b5				call z, .gendemword 
92b5			 
92b5				cp 4 
92b5				call z, .genutlword 
92b5				cp 5 
92b5				call z, .genspiword 
92b5				cp 6 
92b5				call z, .genkeyword 
92b5				cp 7 
92b5				call z, .gensoundword 
92b5				cp 7 
92b5				call z, .genhwword 
92b5				jr create_startup 
92b5			 
92b5			.genhwword: 
92b5				ld hl, crs_hw 
92b5				ld de, .hwworddef 
92b5				call .genfile 
92b5				ret 
92b5			.gensoundword: 
92b5				ld hl, crs_sound 
92b5				ld de, .soundworddef 
92b5				call .genfile 
92b5				ret 
92b5			.genlsword: 
92b5				ld hl, crs_s1 
92b5				ld de, .lsworddef 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			.genedword: 
92b5				ld de, .edworddef 
92b5				ld hl, crs_s2 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			.gendemword: 
92b5				ld de, .demoworddef 
92b5				ld hl, crs_s3 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			.genutlword: 
92b5				ld hl, crs_s4 
92b5				ld de, .utilwordef 
92b5				call .genfile 
92b5				ret 
92b5			.genspiword: 
92b5				ld hl, crs_s5 
92b5				ld de, .spiworddef 
92b5				call .genfile 
92b5				ret 
92b5			.genkeyword: 
92b5				ld hl, crs_s6 
92b5				ld de, .keyworddef 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			; hl - points to file name 
92b5			; de - points to strings to add to file 
92b5			 
92b5			.genfile: 
92b5				push hl 
92b5				push de 
92b5			 
92b5				call clear_display 
92b5				ld a, display_row_1 
92b5				ld de, .genfiletxt 
92b5				call str_at_display 
92b5				call update_display 
92b5			 
92b5				pop de 
92b5				pop hl 
92b5			 
92b5			 
92b5				push de 
92b5				call storage_create 
92b5				; id in hl 
92b5				pop de   ; table of strings to add 
92b5			 
92b5			.genloop: 
92b5			 
92b5				push hl ; save id for next time around 
92b5				push de ; save de for next time around 
92b5			 
92b5				ex de, hl 
92b5				call loadwordinhl 
92b5				ex de, hl 
92b5			 
92b5				; need hl to be the id 
92b5				; need de to be the string ptr 
92b5				 
92b5				call storage_append 
92b5			 
92b5				pop de 
92b5				pop hl 
92b5			 
92b5				inc de 
92b5				inc de 
92b5			 
92b5				ld a,(de) 
92b5				cp 0 
92b5				jr nz, .genloop 
92b5				inc de 
92b5				ld a, (de) 
92b5				dec de 
92b5				cp 0 
92b5				jr nz, .genloop	 
92b5			 
92b5				ret 
92b5			 
92b5			.genfiletxt:  db "Creating file...",0 
92b5			 
92b5			.hwworddef: 
92b5				dw test5 
92b5				dw test6 
92b5				dw test7 
92b5				dw test8 
92b5				dw test9 
92b5				dw test10 
92b5				dw 0 
92b5			 
92b5			.soundworddef: 
92b5				dw sound1 
92b5				dw sound2 
92b5				dw sound3 
92b5				dw sound4 
92b5				dw sound5 
92b5				dw sound6 
92b5				dw sound7 
92b5				dw sound8 
92b5				dw sound9 
92b5				dw 0 
92b5			 
92b5			.utilwordef: 
92b5				dw strncpy 
92b5				dw type 
92b5				dw clrstack 
92b5				dw longread 
92b5				dw start1 
92b5				dw start2 
92b5			; duplicated 
92b5			;	dw start3b 
92b5			;	dw start3c 
92b5				dw list 
92b5				dw 0 
92b5			 
92b5			.lsworddef: 
92b5				dw start3b 
92b5				dw 0 
92b5			 
92b5			.edworddef: 
92b5				dw edit1 
92b5				dw edit2 
92b5				dw edit3 
92b5				dw 0 
92b5			 
92b5			.demoworddef: 
92b5				dw game1 
92b5				dw game1a 
92b5				dw game1b 
92b5				dw game1c 
92b5				dw game1d 
92b5				dw game1s 
92b5				dw game1t 
92b5				dw game1f 
92b5				dw game1z 
92b5				dw game1zz 
92b5				dw ssv2 
92b5				dw ssv3 
92b5				dw ssv4 
92b5				dw ssv5 
92b5				dw ssv1 
92b5				dw ssv1cpm	 
92b5			;	dw game2b 
92b5			;	dw game2bf 
92b5			;	dw game2mba 
92b5			;	dw game2mbas	 
92b5			;	dw game2mbht 
92b5			;	dw game2mbms 
92b5			;	dw game2mb 
92b5			;	dw game3w 
92b5			;	dw game3p 
92b5			;	dw game3sc 
92b5			;	dw game3vsi 
92b5			;	dw game3vs 
92b5				dw 0 
92b5			 
92b5			 
92b5			.spiworddef: 
92b5			 
92b5			    dw spi1 
92b5			    dw spi2 
92b5			    dw spi2b 
92b5			    dw spi3 
92b5			    dw spi4 
92b5			    dw spi5 
92b5			;    dw spi6 
92b5			;    dw spi7 
92b5			 
92b5			;    dw spi8 
92b5			;    dw spi9 
92b5			;    dw spi10 
92b5			    dw 0 
92b5			 
92b5			.keyworddef: 
92b5			 
92b5				dw keyup 
92b5				dw keydown 
92b5				dw keyleft 
92b5				dw keyright 
92b5				dw 	keyf1 
92b5				dw keyf2 
92b5				dw keyf3 
92b5				dw keyf4 
92b5				dw keyf5 
92b5				dw keyf6 
92b5				dw keyf7 
92b5				dw keyf8 
92b5				dw keyf9 
92b5				dw keyf10 
92b5				dw keyf11 
92b5				dw keyf12 
92b5				dw keytab 
92b5				dw keycr 
92b5				dw keyhome 
92b5				dw keyend 
92b5				dw keybs 
92b5				dw 0 
92b5			 
92b5			.crstart: 
92b5				dw crs_s1 
92b5				dw crs_s2 
92b5				dw crs_s3 
92b5				dw crs_s4 
92b5				dw crs_s5 
92b5				dw crs_s6 
92b5				dw crs_sound 
92b5				dw crs_hw 
92b5				dw 0 
92b5			 
92b5			endif 
92b5			 
92b5			 
92b5			if STORAGE_SE 
92b5			 
92b5			config_fdir: 
92b5				; using the scratch dir go through and release the memory allocated for each string 
92b5				 
92b5				ld hl, scratch 
92b5			.cfdir:	ld e,(hl) 
92b5				inc hl 
92b5				ld d,(hl) 
92b5				inc hl 
92b5			 
92b5				ex de, hl 
92b5				call ishlzero 
92b5				ret z     ; return on null pointer 
92b5				call free 
92b5				ex de, hl 
92b5				jr .cfdir 
92b5			 
92b5			 
92b5				ret 
92b5			 
92b5			 
92b5			config_dir: 
92b5			 
92b5				; for the config menus that need to build a directory of storage call this routine 
92b5				; it will construct a menu in scratch to pass to menu 
92b5			 
92b5				; open storage device 
92b5			 
92b5				; execute DIR to build a list of files and their ids into scratch in menu format 
92b5				; once the menu has finished then will need to call config_fdir to release the strings 
92b5				 
92b5				; c = number items 
92b5			 
92b5				 
92b5				call storage_get_block_0 
92b5			 
92b5				ld hl, store_page     ; get current id count 
92b5				ld b, (hl) 
92b5				ld c, 0    ; count of files   
92b5			 
92b5			 
92b5				ld hl, scratch 
92b5				ld (store_tmp2), hl    ; location to poke strings 
92b5			 
92b5				; check for empty drive 
92b5			 
92b5				ld a, 0 
92b5				cp b 
92b5				jp z, .dirdone 
92b5			 
92b5				 
92b5					if DEBUG_FORTH_WORDS 
92b5						DMARK "Cdc" 
92b5						CALLMONITOR 
92b5					endif 
92b5			 
92b5			 
92b5			.diritem:	 
92b5				push bc 
92b5				; for each of the current ids do a search for them and if found push to stack 
92b5			 
92b5					ld hl, STORE_BLOCK_PHY 
92b5					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92b5					ld e,b 
92b5			 
92b5					call storage_findnextid 
92b5			 
92b5			 
92b5					; if found hl will be non zero 
92b5			 
92b5					call ishlzero 
92b5					jr z, .dirnotfound 
92b5			 
92b5					; increase count 
92b5			 
92b5					pop bc	 
92b5					inc c 
92b5					push bc 
92b5					 
92b5			 
92b5					; get file header and push the file name 
92b5			 
92b5					ld de, store_page 
92b5					call storage_read_block 
92b5			 
92b5					; push file id to stack 
92b5				 
92b5					ld a, (store_page) 
92b5					ld h, 0 
92b5					ld l, a 
92b5			 
92b5					;call forth_push_numhl 
92b5					; TODO store id 
92b5			 
92b5					push hl 
92b5			 
92b5					; push extent count to stack  
92b5				 
92b5					ld hl, store_page+3 
92b5			 
92b5					; get file name length 
92b5			 
92b5					call strlenz   
92b5			 
92b5					inc hl   ; cover zero term 
92b5					inc hl  ; stick the id at the end of the area 
92b5			 
92b5					push hl 
92b5					pop bc    ; move length to bc 
92b5			 
92b5					call malloc 
92b5			 
92b5					; TODO save malloc area to scratch 
92b5			 
92b5					ex de, hl 
92b5					ld hl, (store_tmp2) 
92b5					ld (hl), e 
92b5					inc hl 
92b5					ld (hl), d 
92b5					inc hl 
92b5					ld (store_tmp2), hl 
92b5			 
92b5					 
92b5			 
92b5					;pop hl   ; get source 
92b5			;		ex de, hl    ; swap aronund	 
92b5			 
92b5					ld hl, store_page+3 
92b5					if DEBUG_FORTH_WORDS 
92b5						DMARK "CFd" 
92b5						CALLMONITOR 
92b5					endif 
92b5					ldir 
92b5			 
92b5					; de is past string, move back one and store id 
92b5					 
92b5					dec de 
92b5			 
92b5					; store file id 
92b5			 
92b5					pop hl 
92b5					ex de,hl 
92b5					ld (hl), e 
92b5			 
92b5					if DEBUG_FORTH_WORDS 
92b5						DMARK "Cdi" 
92b5						CALLMONITOR 
92b5					endif 
92b5					 
92b5			.dirnotfound: 
92b5					pop bc     
92b5					djnz .diritem 
92b5				 
92b5			.dirdone:	 
92b5			 
92b5					ld a, 0 
92b5					ld hl, (store_tmp2) 
92b5					ld (hl), a 
92b5					inc hl 
92b5					ld (hl), a 
92b5					inc hl 
92b5					; push a count of the dir items found 
92b5			 
92b5			;		ld h, 0 
92b5			;		ld l, c 
92b5			 
92b5				ret 
92b5			 
92b5			endif 
92b5			 
92b5			 
92b5			; Settings 
92b5			; Run  
92b5			 
92b5			 
92b5			 
92b5			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92b5			;;hd_menu2:   db "        2: Editor",0   
92b5			;hd_menu2:   db "        2: Editor       6: Menu",0   
92b5			;hd_menu3:   db "        3: Storage",0 
92b5			;hd_menu4:   db "0=quit  4: Debug",0 
92b5			;hd_don:     db "ON",0 
92b5			;hd_doff:     db "OFF",0 
92b5			; 
92b5			; 
92b5			; 
92b5			;hardware_diags_old:       
92b5			; 
92b5			;.diagmenu: 
92b5			;	call clear_display 
92b5			;	ld a, display_row_1 
92b5			;	ld de, hd_menu1 
92b5			;	call str_at_display 
92b5			; 
92b5			;	ld a, display_row_2 
92b5			;	ld de, hd_menu2 
92b5			;	call str_at_display 
92b5			; 
92b5			;	ld a, display_row_3 
92b5			;	ld de, hd_menu3 
92b5			;	call str_at_display 
92b5			; 
92b5			;	ld a,  display_row_4 
92b5			;	ld de, hd_menu4 
92b5			;	call str_at_display 
92b5			; 
92b5			;	; display debug state 
92b5			; 
92b5			;	ld de, hd_don 
92b5			;	ld a, (os_view_disable) 
92b5			;	cp 0 
92b5			;	jr z, .distog 
92b5			;	ld de, hd_doff 
92b5			;.distog: ld a, display_row_4+17 
92b5			;	call str_at_display 
92b5			; 
92b5			;	call update_display 
92b5			; 
92b5			;	call cin_wait 
92b5			; 
92b5			; 
92b5			; 
92b5			;	cp '4' 
92b5			;	jr nz, .diagn1 
92b5			; 
92b5			;	; debug toggle 
92b5			; 
92b5			;	ld a, (os_view_disable) 
92b5			;	ld b, '*' 
92b5			;	cp 0 
92b5			;	jr z, .debtog 
92b5			;	ld b, 0 
92b5			;.debtog:	 
92b5			;	ld a,b 
92b5			;	ld (os_view_disable),a 
92b5			; 
92b5			;.diagn1: cp '0' 
92b5			;	 ret z 
92b5			; 
92b5			;;	cp '1' 
92b5			;;       jp z, matrix	 
92b5			;;   TODO keyboard matrix test 
92b5			; 
92b5			;	cp '2' 
92b5			;	jp z, .diagedit 
92b5			; 
92b5			;;	cp '6' 
92b5			;;	jp z, .menutest 
92b5			;;if ENABLE_BASIC 
92b5			;;	cp '6' 
92b5			;;	jp z, basic 
92b5			;;endif 
92b5			 ; 
92b5			;	jp .diagmenu 
92b5			; 
92b5			; 
92b5			;	ret 
92b5			 
92b5			 
92b5			.debug_tog: 
92b5 21 ff 92			ld hl, .menudebug 
92b8				 
92b8			;	ld a, (os_view_disable) 
92b8			;	cp '*' 
92b8 3a 6f ee			ld a,(debug_vector) 
92bb fe c9			cp $C9   ; RET 
92bd 20 04			jr nz,.tdon  
92bf 3e 01			ld a, 1 
92c1 18 02			jr .tog1 
92c3 3e 00		.tdon: ld a, 0 
92c5			 
92c5			.tog1: 
92c5 cd eb 8a			call menu 
92c8 fe 00			cp 0 
92ca c8				ret z 
92cb fe 01			cp 1    ; disable debug 
92cd 28 04			jr z, .dtog0 
92cf 3e 2a			ld a, '*' 
92d1 18 05			jr .dtogset 
92d3			.dtog0:  
92d3				;ld a, 0 
92d3 cd f1 93			call bp_on 
92d6 18 dd			jr .debug_tog 
92d8			.dtogset:  
92d8				; ld (os_view_disable), a 
92d8 cd fd 93			call bp_off 
92db c3 b5 92			jp .debug_tog 
92de			 
92de			 
92de			hardware_diags:       
92de			 
92de			.diagm: 
92de 21 f1 92			ld hl, .menuitems 
92e1 3e 00			ld a, 0 
92e3 cd eb 8a			call menu 
92e6			 
92e6 fe 00		         cp 0 
92e8 c8				 ret z 
92e9			 
92e9 fe 02			cp 2 
92eb ca 4a 93			jp z, .diagedit 
92ee			 
92ee			;	cp '6' 
92ee			;	jp z, .menutest 
92ee			;if ENABLE_BASIC 
92ee			;	cp '6' 
92ee			;	jp z, basic 
92ee			;endif 
92ee			  
92ee c3 de 92			jp .diagm 
92f1			 
92f1				 
92f1 05 93		.menuitems:   	dw .m1 
92f3 10 93				dw .m2 
92f5 17 93				dw .m3 
92f7 1f 93				dw .m5 
92f9 25 93				dw .m5a 
92fb 2e 93				dw .m5b 
92fd 00 00				dw 0 
92ff			 
92ff			.menudebug: 
92ff 37 93				dw .m6 
9301 40 93				dw .m7 
9303 00 00				dw 0 
9305			 
9305 .. 00		.m1:   db "Key Matrix",0 
9310 .. 00		.m2:   db "Editor",0 
9317 .. 00		.m3:   db "Storage",0 
931f .. 00		.m5:   db "Sound",0 
9325 .. 00		.m5a:  db "RAM Test",0 
932e .. 00		.m5b:  db "LCD Test",0 
9337			 
9337 .. 00		.m6:   db "Debug ON",0 
9340 .. 00		.m7:   db "Debug OFF",0 
934a			 
934a			; debug editor 
934a			 
934a			.diagedit: 
934a			 
934a 21 c1 e2			ld hl, scratch 
934d			;	ld bc, 250 
934d			;	ldir 
934d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
934d 3e 00			ld a, 0 
934f 77				ld (hl), a 
9350 23				inc hl 
9351 77				ld (hl), a 
9352 23				inc hl 
9353 77				ld (hl), a 
9354			 
9354 cd ba 8a		        call clear_display 
9357 cd dd 8a			call update_display 
935a				;ld a, 1 
935a				;ld (hardware_diag), a 
935a			.diloop: 
935a 3e 00			ld a, display_row_1 
935c 0e 00			ld c, 0 
935e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9360 1e 28			ld e, 40 
9362			 
9362 21 c1 e2			ld hl, scratch	 
9365 cd 14 8d			call input_str 
9368			 
9368 3e 28			ld a, display_row_2 
936a 11 c1 e2			ld de, scratch 
936d cd cd 8a			call str_at_display 
9370 cd dd 8a			call update_display 
9373			 
9373 c3 5a 93			jp .diloop 
9376			 
9376			 
9376			; pass word in hl 
9376			; a has display location 
9376			display_word_at: 
9376 f5				push af 
9377 e5				push hl 
9378 7c				ld a,h 
9379 21 c6 e5			ld hl, os_word_scratch 
937c cd f0 8e			call hexout 
937f e1				pop hl 
9380 7d				ld a,l 
9381 21 c8 e5			ld hl, os_word_scratch+2 
9384 cd f0 8e			call hexout 
9387 21 ca e5			ld hl, os_word_scratch+4 
938a 3e 00			ld a,0 
938c 77				ld (hl),a 
938d 11 c6 e5			ld de,os_word_scratch 
9390 f1				pop af 
9391 cd cd 8a				call str_at_display 
9394 c9				ret 
9395			 
9395			display_ptr_state: 
9395			 
9395				; to restore afterwards 
9395			 
9395 d5				push de 
9396 c5				push bc 
9397 e5				push hl 
9398 f5				push af 
9399			 
9399				; for use in here 
9399			 
9399			;	push bc 
9399			;	push de 
9399			;	push hl 
9399			;	push af 
9399			 
9399 cd ba 8a			call clear_display 
939c			 
939c 11 74 95			ld de, .ptrstate 
939f 3e 00			ld a, display_row_1 
93a1 cd cd 8a			call str_at_display 
93a4			 
93a4				; display debug step 
93a4			 
93a4			 
93a4 11 6b ee			ld de, debug_mark 
93a7 3e 26			ld a, display_row_1+display_cols-2 
93a9 cd cd 8a			call str_at_display 
93ac			 
93ac				; display a 
93ac 11 7e 95			ld de, .ptrcliptr 
93af 3e 28			ld a, display_row_2 
93b1 cd cd 8a			call str_at_display 
93b4			 
93b4 f1				pop af 
93b5 2a 40 ea			ld hl,(cli_ptr) 
93b8 3e 30			ld a, display_row_2+8 
93ba cd 76 93			call display_word_at 
93bd			 
93bd			 
93bd				; display hl 
93bd			 
93bd			 
93bd 11 86 95			ld de, .ptrclioptr 
93c0 3e 32			ld a, display_row_2+10 
93c2 cd cd 8a			call str_at_display 
93c5			; 
93c5			;	pop hl 
93c5 3e 35			ld a, display_row_2+13 
93c7 2a 3e ea			ld hl,(cli_origptr) 
93ca cd 76 93			call display_word_at 
93cd			; 
93cd			;	 
93cd			;	; display de 
93cd			 
93cd			;	ld de, .regstatede 
93cd			;	ld a, display_row_3 
93cd			;	call str_at_display 
93cd			 
93cd			;	pop de 
93cd			;	ld h,d 
93cd			;	ld l, e 
93cd			;	ld a, display_row_3+3 
93cd			;	call display_word_at 
93cd			 
93cd			 
93cd				; display bc 
93cd			 
93cd			;	ld de, .regstatebc 
93cd			;	ld a, display_row_3+10 
93cd			;	call str_at_display 
93cd			 
93cd			;	pop bc 
93cd			;	ld h,b 
93cd			;	ld l, c 
93cd			;	ld a, display_row_3+13 
93cd			;	call display_word_at 
93cd			 
93cd			 
93cd				; display dsp 
93cd			 
93cd			;	ld de, .regstatedsp 
93cd			;	ld a, display_row_4 
93cd			;	call str_at_display 
93cd			 
93cd				 
93cd			;	ld hl,(cli_data_sp) 
93cd			;	ld a, display_row_4+4 
93cd			;	call display_word_at 
93cd			 
93cd				; display rsp 
93cd			 
93cd 11 b5 95			ld de, .regstatersp 
93d0 3e 82			ld a, display_row_4+10 
93d2 cd cd 8a			call str_at_display 
93d5			 
93d5				 
93d5 2a f2 e9			ld hl,(cli_ret_sp) 
93d8 3e 86			ld a, display_row_4+14 
93da cd 76 93			call display_word_at 
93dd			 
93dd cd dd 8a			call update_display 
93e0			 
93e0 cd fd 89			call delay1s 
93e3 cd fd 89			call delay1s 
93e6 cd fd 89			call delay1s 
93e9			 
93e9			 
93e9 cd e6 99			call next_page_prompt 
93ec			 
93ec				; restore  
93ec			 
93ec f1				pop af 
93ed e1				pop hl 
93ee c1				pop bc 
93ef d1				pop de 
93f0 c9				ret 
93f1			 
93f1			; Update the break point vector so that the user can hook a new routine 
93f1			 
93f1			bp_on: 
93f1 3e c3			ld a, $c3    ; JP 
93f3 32 6f ee			ld (debug_vector), a 
93f6 21 03 94			ld hl, break_point_state 
93f9 22 70 ee			ld (debug_vector+1), hl 
93fc c9				ret 
93fd			 
93fd			bp_off: 
93fd 3e c9			ld a, $c9    ; RET 
93ff 32 6f ee			ld (debug_vector), a 
9402 c9				ret 
9403			 
9403			 
9403			break_point_state: 
9403			;	push af 
9403			; 
9403			;	; see if disabled 
9403			; 
9403			;	ld a, (os_view_disable) 
9403			;	cp '*' 
9403			;	jr nz, .bpsgo 
9403			;	pop af 
9403			;	ret 
9403			 
9403			.bpsgo: 
9403			;	pop af 
9403 f5				push af 
9404 22 a3 e2			ld (os_view_hl), hl 
9407 ed 53 a1 e2		ld (os_view_de), de 
940b ed 43 9f e2		ld (os_view_bc), bc 
940f e5				push hl 
9410 6f				ld l, a 
9411 26 00			ld h, 0 
9413 22 a5 e2			ld (os_view_af),hl 
9416			 
9416 21 b1 ed				ld hl, display_fb0 
9419 22 cc eb				ld (display_fb_active), hl 
941c e1				pop hl	 
941d			 
941d 3e 31			ld a, '1' 
941f fe 2a		.bps1:  cp '*' 
9421 cc fd 93			call z, bp_off 
9424			;	jr nz, .bps1b 
9424			;	ld (os_view_disable),a 
9424 fe 31		.bps1b:  cp '1' 
9426 20 14			jr nz, .bps2 
9428			 
9428				; display reg 
9428			 
9428				 
9428			 
9428 3a a5 e2			ld a, (os_view_af) 
942b 2a a3 e2			ld hl, (os_view_hl) 
942e ed 5b a1 e2		ld de, (os_view_de) 
9432 ed 4b 9f e2		ld bc, (os_view_bc) 
9436 cd d0 94			call display_reg_state 
9439 c3 bc 94			jp .bpschk 
943c			 
943c fe 32		.bps2:  cp '2' 
943e 20 08			jr nz, .bps3 
9440				 
9440				; display hl 
9440 2a a3 e2			ld hl, (os_view_hl) 
9443 cd ba 95			call display_dump_at_hl 
9446			 
9446 18 74			jr .bpschk 
9448			 
9448 fe 33		.bps3:  cp '3' 
944a 20 08			jr nz, .bps4 
944c			 
944c			        ; display de 
944c 2a a1 e2			ld hl, (os_view_de) 
944f cd ba 95			call display_dump_at_hl 
9452			 
9452 18 68			jr .bpschk 
9454 fe 34		.bps4:  cp '4' 
9456 20 08			jr nz, .bps5 
9458			 
9458			        ; display bc 
9458 2a 9f e2			ld hl, (os_view_bc) 
945b cd ba 95			call display_dump_at_hl 
945e			 
945e 18 5c			jr .bpschk 
9460 fe 35		.bps5:  cp '5' 
9462 20 08		        jr nz, .bps7 
9464			 
9464				; display cur ptr 
9464 2a 40 ea			ld hl, (cli_ptr) 
9467 cd ba 95			call display_dump_at_hl 
946a			 
946a 18 50			jr .bpschk 
946c fe 36		.bps7:  cp '6' 
946e 20 08			jr nz, .bps8b 
9470				 
9470				; display cur orig ptr 
9470 2a 3e ea			ld hl, (cli_origptr) 
9473 cd ba 95			call display_dump_at_hl 
9476 18 44			jr .bpschk 
9478 fe 37		.bps8b:  cp '7' 
947a 20 08			jr nz, .bps9 
947c				 
947c				; display dsp 
947c 2a ee e9			ld hl, (cli_data_sp) 
947f cd ba 95			call display_dump_at_hl 
9482			 
9482 18 38			jr .bpschk 
9484 fe 39		.bps9:  cp '9' 
9486 20 05			jr nz, .bps8c 
9488				 
9488				; display SP 
9488			;	ld hl, sp 
9488 cd ba 95			call display_dump_at_hl 
948b			 
948b 18 2f			jr .bpschk 
948d fe 38		.bps8c:  cp '8' 
948f 20 08			jr nz, .bps8d 
9491				 
9491				; display rsp 
9491 2a f2 e9			ld hl, (cli_ret_sp) 
9494 cd ba 95			call display_dump_at_hl 
9497			 
9497 18 23			jr .bpschk 
9499 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
949b 20 05			jr nz, .bps8 
949d cd b4 97			call monitor 
94a0			 
94a0 18 1a			jr .bpschk 
94a2 fe 30		.bps8:  cp '0' 
94a4 20 16			jr nz, .bpschk 
94a6			 
94a6 21 10 ed				ld hl, display_fb1 
94a9 22 cc eb				ld (display_fb_active), hl 
94ac cd dd 8a				call update_display 
94af			 
94af				;ld a, (os_view_af) 
94af 2a a3 e2			ld hl, (os_view_hl) 
94b2 ed 5b a1 e2		ld de, (os_view_de) 
94b6 ed 4b 9f e2		ld bc, (os_view_bc) 
94ba f1				pop af 
94bb c9				ret 
94bc			 
94bc			.bpschk:   
94bc cd fd 89			call delay1s 
94bf 3e 9f		ld a,display_row_4 + display_cols - 1 
94c1 11 e4 99		        ld de, endprg 
94c4 cd cd 8a			call str_at_display 
94c7 cd dd 8a			call update_display 
94ca cd 1d dd			call cin_wait 
94cd			 
94cd c3 1f 94			jp .bps1 
94d0			 
94d0			 
94d0			display_reg_state: 
94d0			 
94d0				; to restore afterwards 
94d0			 
94d0 d5				push de 
94d1 c5				push bc 
94d2 e5				push hl 
94d3 f5				push af 
94d4			 
94d4				; for use in here 
94d4			 
94d4 c5				push bc 
94d5 d5				push de 
94d6 e5				push hl 
94d7 f5				push af 
94d8			 
94d8 cd ba 8a			call clear_display 
94db			 
94db 11 90 95			ld de, .regstate 
94de 3e 00			ld a, display_row_1 
94e0 cd cd 8a			call str_at_display 
94e3			 
94e3				; display debug step 
94e3			 
94e3			 
94e3 11 6b ee			ld de, debug_mark 
94e6 3e 25			ld a, display_row_1+display_cols-3 
94e8 cd cd 8a			call str_at_display 
94eb			 
94eb				; display a 
94eb 11 ac 95			ld de, .regstatea 
94ee 3e 28			ld a, display_row_2 
94f0 cd cd 8a			call str_at_display 
94f3			 
94f3 e1				pop hl 
94f4			;	ld h,0 
94f4			;	ld l, a 
94f4 3e 2b			ld a, display_row_2+3 
94f6 cd 76 93			call display_word_at 
94f9			 
94f9			 
94f9				; display hl 
94f9			 
94f9			 
94f9 11 a0 95			ld de, .regstatehl 
94fc 3e 32			ld a, display_row_2+10 
94fe cd cd 8a			call str_at_display 
9501			 
9501 e1				pop hl 
9502 3e 35			ld a, display_row_2+13 
9504 cd 76 93			call display_word_at 
9507			 
9507				 
9507				; display de 
9507			 
9507 11 a4 95			ld de, .regstatede 
950a 3e 50			ld a, display_row_3 
950c cd cd 8a			call str_at_display 
950f			 
950f e1				pop hl 
9510			;	ld h,d 
9510			;	ld l, e 
9510 3e 53			ld a, display_row_3+3 
9512 cd 76 93			call display_word_at 
9515			 
9515			 
9515				; display bc 
9515			 
9515 11 a8 95			ld de, .regstatebc 
9518 3e 5a			ld a, display_row_3+10 
951a cd cd 8a			call str_at_display 
951d			 
951d e1				pop hl 
951e			;	ld h,b 
951e			;	ld l, c 
951e 3e 5d			ld a, display_row_3+13 
9520 cd 76 93			call display_word_at 
9523			 
9523			 
9523				; display dsp 
9523			 
9523 11 b0 95			ld de, .regstatedsp 
9526 3e 78			ld a, display_row_4 
9528 cd cd 8a			call str_at_display 
952b			 
952b				 
952b 2a ee e9			ld hl,(cli_data_sp) 
952e 3e 7c			ld a, display_row_4+4 
9530 cd 76 93			call display_word_at 
9533			 
9533				; display rsp 
9533			 
9533 11 b5 95			ld de, .regstatersp 
9536 3e 82			ld a, display_row_4+10 
9538 cd cd 8a			call str_at_display 
953b			 
953b				 
953b 2a f2 e9			ld hl,(cli_ret_sp) 
953e 3e 86			ld a, display_row_4+14 
9540 cd 76 93			call display_word_at 
9543			 
9543 cd dd 8a			call update_display 
9546			 
9546			;	call delay1s 
9546			;	call delay1s 
9546			;	call delay1s 
9546			 
9546			 
9546			;	call next_page_prompt 
9546			 
9546				; restore  
9546			 
9546 f1				pop af 
9547 e1				pop hl 
9548 c1				pop bc 
9549 d1				pop de 
954a c9				ret 
954b			 
954b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
955f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9574 .. 00		.ptrstate:	db "Ptr State",0 
957e .. 00		.ptrcliptr:     db "cli_ptr",0 
9586 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9590 .. 00		.regstate:	db "Reg State (1/0)",0 
95a0 .. 00		.regstatehl:	db "HL:",0 
95a4 .. 00		.regstatede:	db "DE:",0 
95a8 .. 00		.regstatebc:	db "BC:",0 
95ac .. 00		.regstatea:	db "A :",0 
95b0 .. 00		.regstatedsp:	db "DSP:",0 
95b5 .. 00		.regstatersp:	db "RSP:",0 
95ba			 
95ba			display_dump_at_hl: 
95ba e5				push hl 
95bb d5				push de 
95bc c5				push bc 
95bd f5				push af 
95be			 
95be 22 e4 e5			ld (os_cur_ptr),hl	 
95c1 cd ba 8a			call clear_display 
95c4 cd ee 98			call dumpcont 
95c7			;	call delay1s 
95c7			;	call next_page_prompt 
95c7			 
95c7			 
95c7 f1				pop af 
95c8 c1				pop bc 
95c9 d1				pop de 
95ca e1				pop hl 
95cb c9				ret 
95cc			 
95cc			;if ENABLE_BASIC 
95cc			;	include "nascombasic.asm" 
95cc			;	basic: 
95cc			;	include "forth/FORTH.ASM" 
95cc			;endif 
95cc			 
95cc			; eof 
95cc			 
95cc			 
# End of file firmware_diags.asm
95cc			  
95cc			include "firmware_prompts.asm"  
95cc			; Prompts  
95cc			 
95cc			; boot messages 
95cc			 
95cc .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
95e1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
95f1			 
95f1			 
95f1			; config menus 
95f1			 
95f1			;prom_c3: db "Add Dictionary To File",0 
95f1			 
95f1			if STARTUP_V1 
95f1 .. 00		prom_c2: db "Select Autoload File",0 
9606 .. 00		prom_c2a: db "Disable Autoload File", 0 
961c			endif 
961c			 
961c			if STARTUP_V2 
961c			prom_c2: db "Enable Autoload Files",0 
961c			prom_c2a: db "Disable Autoload Files", 0 
961c			 
961c			crs_s1: db "*ls-word", 0 
961c			crs_s2: db "*ed-word", 0 
961c			crs_s3: db "*Demo-Games", 0 
961c			crs_s4: db "*Utils", 0 
961c			crs_s5: db "*SPI-Util", 0 
961c			crs_s6: db "*Key-Constants", 0 
961c			crs_sound: db "*Sound-Util", 0 
961c			crs_hw: db "*Hello-World",0 
961c			 
961c			 
961c			 
961c			endif 
961c			;prom_c2b: db "Select Storage Bank",0 
961c .. 00		prom_c4: db "Settings",0 
9625 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9640 .. 00		prom_m4b:   db "Monitor",0 
9648 .. 00		prom_c1: db "Hardware Diags",0 
9657			 
9657			 
9657			if STARTUP_V2 
9657			prom_c9: db "Create Startup Files",0 
9657			endif 
9657			 
9657 .. 00		prom_notav:    db "Feature not available",0 
966d .. 00		prom_empty:    db "",0 
966e			 
966e			; eof 
966e			 
# End of file firmware_prompts.asm
966e			  
966e			  
966e			; eof  
966e			  
# End of file firmware.asm
966e			 
966e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
966e			;if BASE_KEV  
966e			;baseram: equ 08000h 
966e			;endif 
966e			 
966e			;if BASE_SC114 
966e			;baseram:     equ    endofcode 
966e			;endif 
966e			 
966e			 
966e			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
966e			 
966e			; start system 
966e			 
966e			coldstart: 
966e				; set sp 
966e				; di/ei 
966e			 
966e f3				di 
966f 31 00 f0			ld sp, tos 
9672 cd 67 dc			call init_nmi 
9675			;	ei 
9675			 
9675				; init spinner 
9675 3e 00			ld a,0 
9677 32 c6 eb			ld (display_active), a 
967a			 
967a				; disable breakpoint by default 
967a			 
967a				;ld a,'*' 
967a			;	ld a,' ' 
967a			;	ld (os_view_disable),a 
967a			 
967a				; set break point vector as new break point on or off 
967a cd fd 93			call bp_off 
967d			 
967d				; init hardware 
967d			 
967d				; init keyboard and screen hardware 
967d			 
967d cd 1f 80			call hardware_init 
9680			 
9680			 
9680 cd fd 89			call delay1s 
9683 3e 58			ld a, display_row_3+8 
9685 11 03 80			ld de, buildtime 
9688 cd cd 8a			call str_at_display 
968b cd dd 8a			call update_display 
968e			 
968e cd fd 89			call delay1s 
9691 cd fd 89			call delay1s 
9694 cd fd 89			call delay1s 
9697			 
9697				; detect if any keys are held down to enable breakpoints at start up 
9697			 
9697 cd 23 dd			call cin  
969a fe 00			cp 0 
969c 28 03			jr z, .nokeys 
969e			 
969e				;call hardware_diags 
969e cd 5b 92			call config 
96a1			 
96a1			;	ld de, .bpen 
96a1			;	ld a, display_row_4 
96a1			;	call str_at_display 
96a1			;	call update_display 
96a1			; 
96a1			;	ld a,0 
96a1			;	ld (os_view_disable),a 
96a1			; 
96a1			;.bpwait: 
96a1			;	call cin 
96a1			;	cp 0 
96a1			;	jr z, .bpwait 
96a1			;	jr .nokeys 
96a1			; 
96a1			; 
96a1			;.bpen:  db "Break points enabled!",0 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			.nokeys: 
96a1			 
96a1			 
96a1				 
96a1			 
96a1			;jp  testkey 
96a1			 
96a1			;call storage_get_block_0 
96a1			; 
96a1			;ld hl, 0 
96a1			;ld de, store_page 
96a1			;call storage_read_block 
96a1			 
96a1				 
96a1			;ld hl, 10 
96a1			;ld de, store_page 
96a1			;call storage_read_block 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			;stop:	nop 
96a1			;	jp stop 
96a1			 
96a1			 
96a1			 
96a1			main: 
96a1 cd ba 8a			call clear_display 
96a4 cd dd 8a			call update_display 
96a7			 
96a7			 
96a7			 
96a7			;	call testlcd 
96a7			 
96a7			 
96a7			 
96a7 cd f9 9d			call forth_init 
96aa			 
96aa			 
96aa			warmstart: 
96aa cd cf 9d			call forth_warmstart 
96ad			 
96ad				; run startup word load 
96ad			        ; TODO prevent this running at warmstart after crash  
96ad			 
96ad				if STARTUP_ENABLE 
96ad			 
96ad					if STARTUP_V1 
96ad			 
96ad						if STORAGE_SE 
96ad							call forth_autoload 
96ad						endif 
96ad cd b7 db					call forth_startup 
96b0					endif 
96b0			 
96b0					if STARTUP_V2 
96b0			 
96b0						if STORAGE_SE 
96b0							call forth_autoload 
96b0						else 
96b0							call forth_startup 
96b0						endif 
96b0			 
96b0			 
96b0					endif 
96b0			 
96b0				endif 
96b0			 
96b0			warmstart_afterauto: 
96b0			 
96b0				; show free memory after boot 
96b0 11 4f 97			ld de, freeram 
96b3 3e 00			ld a, display_row_1 
96b5 cd cd 8a			call str_at_display 
96b8			 
96b8				; get current heap start after loading any uwords 
96b8			 
96b8				;ld de, (os_last_new_uword) 
96b8				;ex de, hl 
96b8			 
96b8			; Or use heap_size word???? 
96b8				;ld hl, heap_end 
96b8				;ld hl, heap_size 
96b8				;ld de, topusermem 
96b8				;ld de, heap_start 
96b8 ed 5b 3c dd			ld de, (free_list )      
96bc 21 9c e2				ld hl, heap_end 
96bf ed 52			sbc hl, de 
96c1				;push hl 
96c1				;ld a,h	         	 
96c1				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96c1				;call hexout 
96c1			   	;pop hl 
96c1			; 
96c1			;	ld a,l 
96c1			;	ld hl, os_word_scratch+2 
96c1			;	call hexout 
96c1			;	ld hl, os_word_scratch+4 
96c1			;	ld a, 0 
96c1			;	ld (hl),a 
96c1 eb				ex de, hl 
96c2 21 c6 e5			ld hl, os_word_scratch 
96c5 cd fc 8f			call uitoa_16 
96c8			 
96c8			 
96c8 11 c6 e5			ld de, os_word_scratch 
96cb 3e 0d			ld a, display_row_1 + 13 
96cd cd cd 8a			call str_at_display 
96d0 cd dd 8a			call update_display 
96d3			 
96d3			 
96d3				;call demo 
96d3			 
96d3			 
96d3				; init scratch input area for cli commands 
96d3			 
96d3 21 e8 e5			ld hl, os_cli_cmd 
96d6 3e 00			ld a,0 
96d8 77				ld (hl),a 
96d9 23				inc hl 
96da 77				ld (hl),a 
96db			 
96db 3e 00			ld a,0 
96dd 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
96e0			 
96e0 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
96e3 32 e5 e5			ld (os_cur_ptr+1),a	 
96e6			 
96e6 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
96e9 32 c7 e5			ld (os_word_scratch+1),a	 
96ec				 
96ec			 
96ec				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96ec 21 e8 e5			ld hl, os_cli_cmd 
96ef			 
96ef 3e 00			ld a, 0		 ; init cli input 
96f1 77				ld (hl), a 
96f2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96f4			cli: 
96f4				; show cli prompt 
96f4				;push af 
96f4				;ld a, 0 
96f4				;ld de, prompt 
96f4				;call str_at_display 
96f4			 
96f4				;call update_display 
96f4				;pop af 
96f4				;inc a 
96f4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
96f4			 
96f4			.lastrecall: 
96f4			 
96f4 0e 00			ld c, 0 
96f6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
96f8 1e 28			ld e, 40 
96fa			 
96fa 21 e8 e5			ld hl, os_cli_cmd 
96fd			 
96fd				STACKFRAME OFF $fefe $9f9f 
96fd				if DEBUG_STACK_IMB 
96fd					if OFF 
96fd						exx 
96fd						ld de, $fefe 
96fd						ld a, d 
96fd						ld hl, curframe 
96fd						call hexout 
96fd						ld a, e 
96fd						ld hl, curframe+2 
96fd						call hexout 
96fd						ld hl, $fefe 
96fd						push hl 
96fd						ld hl, $9f9f 
96fd						push hl 
96fd						exx 
96fd					endif 
96fd				endif 
96fd			endm 
# End of macro STACKFRAME
96fd			 
96fd cd 14 8d			call input_str 
9700			 
9700				STACKFRAMECHK OFF $fefe $9f9f 
9700				if DEBUG_STACK_IMB 
9700					if OFF 
9700						exx 
9700						ld hl, $9f9f 
9700						pop de   ; $9f9f 
9700						call cmp16 
9700						jr nz, .spnosame 
9700						ld hl, $fefe 
9700						pop de   ; $fefe 
9700						call cmp16 
9700						jr z, .spfrsame 
9700						.spnosame: call showsperror 
9700						.spfrsame: nop 
9700						exx 
9700					endif 
9700				endif 
9700			endm 
# End of macro STACKFRAMECHK
9700			 
9700			 
9700				; check to see if last line recall has been requested 
9700			 
9700			if EDIT_V2 
9700 fe 05			cp KEY_UP 
9702 20 0f			jr nz, .noexecline 
9704			 
9704 11 e8 e5			ld de, os_cli_cmd 
9707 21 e7 e6			ld hl, os_last_cmd 
970a 01 ff 00			ld bc, 255 
970d ed b0			ldir 
970f 3e 00			ld a, 0 
9711 18 e1			jr .lastrecall 
9713			endif 
9713			 
9713			.noexecline: 
9713				; no so exec the line		 
9713			 
9713				; copy input to last command 
9713			 
9713 21 e8 e5			ld hl, os_cli_cmd 
9716 11 e7 e6			ld de, os_last_cmd 
9719 01 ff 00			ld bc, 255 
971c ed b0			ldir 
971e			 
971e				; wipe current buffer 
971e			 
971e			;	ld a, 0 
971e			;	ld hl, os_cli_cmd 
971e			;	ld de, os_cli_cmd+1 
971e			;	ld bc, 254 
971e			;	ldir 
971e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
971e			;	call strcpy 
971e			;	ld a, 0 
971e			;	ld (hl), a 
971e			;	inc hl 
971e			;	ld (hl), a 
971e			;	inc hl 
971e			;	ld (hl), a 
971e			 
971e				; switch frame buffer to program  
971e			 
971e 21 10 ed				ld hl, display_fb1 
9721 22 cc eb				ld (display_fb_active), hl 
9724			 
9724			;	nop 
9724				STACKFRAME ON $fbfe $8f9f 
9724				if DEBUG_STACK_IMB 
9724					if ON 
9724						exx 
9724						ld de, $fbfe 
9724						ld a, d 
9724						ld hl, curframe 
9724						call hexout 
9724						ld a, e 
9724						ld hl, curframe+2 
9724						call hexout 
9724						ld hl, $fbfe 
9724						push hl 
9724						ld hl, $8f9f 
9724						push hl 
9724						exx 
9724					endif 
9724				endif 
9724			endm 
# End of macro STACKFRAME
9724				; first time into the parser so pass over the current scratch pad 
9724 21 e8 e5			ld hl,os_cli_cmd 
9727				; tokenise the entered statement(s) in HL 
9727 cd 77 9e			call forthparse 
972a			        ; exec forth statements in top of return stack 
972a cd b7 9e			call forthexec 
972d				;call forthexec_cleanup 
972d			;	call parsenext 
972d			 
972d				STACKFRAMECHK ON $fbfe $8f9f 
972d				if DEBUG_STACK_IMB 
972d					if ON 
972d						exx 
972d						ld hl, $8f9f 
972d						pop de   ; $8f9f 
972d						call cmp16 
972d						jr nz, .spnosame 
972d						ld hl, $fbfe 
972d						pop de   ; $fbfe 
972d						call cmp16 
972d						jr z, .spfrsame 
972d						.spnosame: call showsperror 
972d						.spfrsame: nop 
972d						exx 
972d					endif 
972d				endif 
972d			endm 
# End of macro STACKFRAMECHK
972d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
972d			 
972d 3e 78			ld a, display_row_4 
972f 11 60 97			ld de, endprog 
9732			 
9732 cd dd 8a			call update_display		 
9735			 
9735 cd e6 99			call next_page_prompt 
9738			 
9738				; switch frame buffer to cli 
9738			 
9738 21 b1 ed				ld hl, display_fb0 
973b 22 cc eb				ld (display_fb_active), hl 
973e			 
973e			 
973e cd ba 8a		        call clear_display 
9741 cd dd 8a			call update_display		 
9744			 
9744 21 e8 e5			ld hl, os_cli_cmd 
9747			 
9747 3e 00			ld a, 0		 ; init cli input 
9749 77				ld (hl), a 
974a			 
974a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
974a			 
974a				; now on last line 
974a			 
974a				; TODO scroll screen up 
974a			 
974a				; TODO instead just clear screen and place at top of screen 
974a			 
974a			;	ld a, 0 
974a			;	ld (f_cursor_ptr),a 
974a			 
974a				;call clear_display 
974a				;call update_display 
974a			 
974a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974c c3 f4 96			jp cli 
974f			 
974f .. 00		freeram: db "Free bytes: ",0 
975c ..			asc: db "1A2F" 
9760 .. 00		endprog: db "End prog...",0 
976c			 
976c			testenter2:   
976c 21 f3 e2			ld hl,scratch+50 
976f 22 e4 e5			ld (os_cur_ptr),hl 
9772 c3 f4 96			jp cli 
9775			 
9775			testenter:  
9775			 
9775 21 5c 97			ld hl,asc 
9778			;	ld a,(hl) 
9778			;	call nibble2val 
9778 cd 46 8f			call get_byte 
977b			 
977b			 
977b			;	ld a,(hl) 
977b			;	call atohex 
977b			 
977b			;	call fourehexhl 
977b 32 f3 e2			ld (scratch+50),a 
977e			 
977e			 
977e			 
977e 21 5e 97			ld hl,asc+2 
9781			;	ld a, (hl) 
9781			;	call nibble2val 
9781 cd 46 8f			call get_byte 
9784			 
9784			;	call fourehexhl 
9784 32 f5 e2			ld (scratch+52),a 
9787				 
9787 21 f3 e2			ld hl,scratch+50 
978a 22 e4 e5			ld (os_cur_ptr),hl 
978d c3 f4 96			jp cli 
9790			 
9790			enter:	 
9790 3a c5 e2			ld a,(scratch+4) 
9793 fe 00			cp 0 
9795 28 0c			jr z, .entercont 
9797				; no, not a null term line so has an address to work out.... 
9797			 
9797 21 c3 e2			ld hl,scratch+2 
979a cd a6 8f			call get_word_hl 
979d			 
979d 22 e4 e5			ld (os_cur_ptr),hl	 
97a0 c3 f4 96			jp cli 
97a3			 
97a3			 
97a3			.entercont:  
97a3			 
97a3 21 c3 e2			ld hl, scratch+2 
97a6 cd 46 8f			call get_byte 
97a9			 
97a9 2a e4 e5		   	ld hl,(os_cur_ptr) 
97ac 77					ld (hl),a 
97ad 23					inc hl 
97ae 22 e4 e5				ld (os_cur_ptr),hl 
97b1				 
97b1			; get byte  
97b1			 
97b1			 
97b1 c3 f4 96			jp cli 
97b4			 
97b4			 
97b4			; basic monitor support 
97b4			 
97b4			monitor: 
97b4				;  
97b4 cd ba 8a			call clear_display 
97b7 3e 00			ld a, 0 
97b9 11 08 98			ld de, .monprompt 
97bc cd cd 8a			call str_at_display 
97bf cd dd 8a			call update_display 
97c2			 
97c2				; get a monitor command 
97c2			 
97c2 0e 00			ld c, 0     ; entry at top left 
97c4 16 64			ld d, 100   ; max buffer size 
97c6 1e 0f			ld e, 15    ; input scroll area 
97c8 3e 00			ld a, 0     ; init string 
97ca 21 bf e4			ld hl, os_input 
97cd 77				ld (hl), a 
97ce 23				inc hl 
97cf 77				ld (hl), a 
97d0 21 bf e4			ld hl, os_input 
97d3 3e 01			ld a, 1     ; init string 
97d5 cd 14 8d			call input_str 
97d8			 
97d8 cd ba 8a		        call clear_display 
97db cd dd 8a			call update_display		 
97de			 
97de 3a bf e4			ld a, (os_input) 
97e1 cd 44 90			call toUpper 
97e4 fe 48		        cp 'H' 
97e6 ca 6d 98		        jp z, .monhelp 
97e9 fe 44			cp 'D'		; dump 
97eb ca a0 98			jp z, .mondump	 
97ee fe 43			cp 'C'		; dump 
97f0 ca ba 98			jp z, .moncdump	 
97f3 fe 4d			cp 'M'		; dump 
97f5 ca 0a 98			jp z, .moneditstart 
97f8 fe 55			cp 'U'		; dump 
97fa ca 16 98			jp z, .monedit	 
97fd fe 47			cp 'G'		; dump 
97ff ca 96 98			jp z, .monjump 
9802 fe 51			cp 'Q'		; dump 
9804 c8				ret z	 
9805			 
9805			 
9805				; TODO "S" to access symbol by name and not need the address 
9805				; TODO "F" to find a string in memory 
9805			 
9805 c3 b4 97			jp monitor 
9808			 
9808 .. 00		.monprompt: db ">", 0 
980a			 
980a			.moneditstart: 
980a				; get starting address 
980a			 
980a 21 c1 e4			ld hl,os_input+2 
980d cd a6 8f			call get_word_hl 
9810			 
9810 22 e4 e5			ld (os_cur_ptr),hl	 
9813			 
9813 c3 b4 97			jp monitor 
9816			 
9816			.monedit: 
9816				; get byte to load 
9816			 
9816 21 c1 e4			ld hl,os_input+2 
9819 cd 46 8f			call get_byte 
981c			 
981c				; get address to update 
981c 2a e4 e5			ld hl, (os_cur_ptr) 
981f			 
981f				; update byte 
981f			 
981f 77				ld (hl), a 
9820			 
9820				; move to next address and save it 
9820			 
9820 23				inc hl 
9821 22 e4 e5			ld (os_cur_ptr),hl	 
9824			 
9824 c3 b4 97			jp monitor 
9827			 
9827			 
9827 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
983b .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9857 .. 00		.monhelptext3:  db "G-Call address",0 
9866 .. 00		.monhelptext4:  db "Q-Quit",0 
986d			        
986d			.monhelp: 
986d 3e 00			ld a, display_row_1 
986f 11 27 98		        ld de, .monhelptext1 
9872			 
9872 cd cd 8a			call str_at_display 
9875 3e 28			ld a, display_row_2 
9877 11 3b 98		        ld de, .monhelptext2 
987a					 
987a cd cd 8a			call str_at_display 
987d 3e 50			ld a, display_row_3 
987f 11 57 98		        ld de, .monhelptext3 
9882					 
9882 cd cd 8a			call str_at_display 
9885 3e 78			ld a, display_row_4 
9887 11 66 98		        ld de, .monhelptext4 
988a cd cd 8a			call str_at_display 
988d			 
988d cd dd 8a			call update_display		 
9890			 
9890 cd e6 99			call next_page_prompt 
9893 c3 b4 97			jp monitor 
9896			 
9896			.monjump:    
9896 21 c1 e4			ld hl,os_input+2 
9899 cd a6 8f			call get_word_hl 
989c			 
989c e9				jp (hl) 
989d c3 b4 97			jp monitor 
98a0			 
98a0			.mondump:    
98a0 21 c1 e4			ld hl,os_input+2 
98a3 cd a6 8f			call get_word_hl 
98a6			 
98a6 22 e4 e5			ld (os_cur_ptr),hl	 
98a9 cd ee 98			call dumpcont 
98ac 3e 78			ld a, display_row_4 
98ae 11 60 97			ld de, endprog 
98b1			 
98b1 cd dd 8a			call update_display		 
98b4			 
98b4 cd e6 99			call next_page_prompt 
98b7 c3 b4 97			jp monitor 
98ba			.moncdump: 
98ba cd ee 98			call dumpcont 
98bd 3e 78			ld a, display_row_4 
98bf 11 60 97			ld de, endprog 
98c2			 
98c2 cd dd 8a			call update_display		 
98c5			 
98c5 cd e6 99			call next_page_prompt 
98c8 c3 b4 97			jp monitor 
98cb			 
98cb			 
98cb			; TODO symbol access  
98cb			 
98cb			.symbols:     ;; A list of symbols that can be called up  
98cb b1 ed			dw display_fb0 
98cd .. 00			db "fb0",0  
98d1 7a ea		     	dw store_page 
98d3 .. 00			db "store_page",0 
98de			 
98de			 
98de			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
98de			 
98de 3a c2 e2			ld a,(scratch+1) 
98e1 fe 00			cp 0 
98e3 28 09			jr z, dumpcont 
98e5			 
98e5				; no, not a null term line so has an address to work out.... 
98e5			 
98e5 21 c3 e2			ld hl,scratch+2 
98e8 cd a6 8f			call get_word_hl 
98eb			 
98eb 22 e4 e5			ld (os_cur_ptr),hl	 
98ee			 
98ee			 
98ee			 
98ee			dumpcont: 
98ee			 
98ee				; dump bytes at ptr 
98ee			 
98ee			 
98ee 3e 00			ld a, display_row_1 
98f0 2a cc eb			ld hl, (display_fb_active) 
98f3 cd e7 8c			call addatohl 
98f6 cd 1e 99			call .dumpbyterow 
98f9			 
98f9 3e 28			ld a, display_row_2 
98fb 2a cc eb			ld hl, (display_fb_active) 
98fe cd e7 8c			call addatohl 
9901 cd 1e 99			call .dumpbyterow 
9904			 
9904			 
9904 3e 50			ld a, display_row_3 
9906 2a cc eb			ld hl, (display_fb_active) 
9909 cd e7 8c			call addatohl 
990c cd 1e 99			call .dumpbyterow 
990f			 
990f 3e 78			ld a, display_row_4 
9911 2a cc eb			ld hl, (display_fb_active) 
9914 cd e7 8c			call addatohl 
9917 cd 1e 99			call .dumpbyterow 
991a			 
991a cd dd 8a			call update_display 
991d			;		jp cli 
991d c9				ret 
991e			 
991e			.dumpbyterow: 
991e			 
991e				;push af 
991e			 
991e e5				push hl 
991f			 
991f				; calc where to poke the ascii 
991f			if display_cols == 20 
991f				ld a, 16 
991f			else 
991f 3e 1f			ld a, 31 
9921			endif 
9921			 
9921 cd e7 8c			call addatohl 
9924 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9927			 
9927			 
9927			; display decoding address 
9927 2a e4 e5		   	ld hl,(os_cur_ptr) 
992a			 
992a 7c				ld a,h 
992b e1				pop hl 
992c e5				push hl 
992d			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
992d cd f0 8e			call hexout 
9930 2a e4 e5		   	ld hl,(os_cur_ptr) 
9933			 
9933 7d				ld a,l 
9934 e1				pop hl 
9935 23				inc hl 
9936 23				inc hl 
9937 e5				push hl 
9938			;	ld hl, os_word_scratch+2 
9938 cd f0 8e			call hexout 
993b e1				pop hl 
993c 23				inc hl 
993d 23				inc hl 
993e				;ld hl, os_word_scratch+4 
993e 3e 3a			ld a, ':' 
9940 77				ld (hl),a 
9941 23				inc hl 
9942				;ld a, 0 
9942				;ld (hl),a 
9942				;ld de, os_word_scratch 
9942				;pop af 
9942				;push af 
9942			;		ld a, display_row_2 
9942			;		call str_at_display 
9942			;		call update_display 
9942			 
9942			 
9942			;pop af 
9942			;	add 5 
9942			 
9942			if display_cols == 20 
9942				ld b, 4 
9942			else 
9942 06 08			ld b, 8 
9944			endif	 
9944			 
9944			.dumpbyte: 
9944 c5				push bc 
9945 e5				push hl 
9946			 
9946			 
9946 2a e4 e5		   	ld hl,(os_cur_ptr) 
9949 7e					ld a,(hl) 
994a			 
994a					; poke the ascii to display 
994a 2a c6 e5				ld hl,(os_word_scratch) 
994d 77					ld (hl),a 
994e 23					inc hl 
994f 22 c6 e5				ld (os_word_scratch),hl 
9952			 
9952					 
9952			 
9952			 
9952 e1					pop hl 
9953 e5					push hl 
9954			 
9954 cd f0 8e				call hexout 
9957			 
9957					 
9957 2a e4 e5		   	ld hl,(os_cur_ptr) 
995a 23				inc hl 
995b 22 e4 e5		   	ld (os_cur_ptr),hl 
995e			 
995e e1					pop hl 
995f 23					inc hl 
9960 23					inc hl 
9961 23					inc hl 
9962			 
9962			 
9962			 
9962					;ld a,0 
9962					;ld (os_word_scratch+2),a 
9962					;pop af 
9962					;push af 
9962			 
9962					;ld de, os_word_scratch 
9962					;call str_at_display 
9962			;		call update_display 
9962			;		pop af 
9962 c1					pop bc 
9963 c6 03				add 3 
9965 10 dd			djnz .dumpbyte 
9967			 
9967				 
9967			 
9967 c9				ret 
9968			 
9968			jump:	 
9968			 
9968 21 c3 e2			ld hl,scratch+2 
996b cd a6 8f			call get_word_hl 
996e				;ld hl,(scratch+2) 
996e				;call fourehexhl 
996e			 
996e 22 e4 e5			ld (os_cur_ptr),hl	 
9971			 
9971 e9				jp (hl) 
9972			 
9972			 
9972			 
9972			; TODO implement a basic monitor mode to start with 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			; testing and demo code during development 
9972			 
9972			 
9972 .. 00		str1: db "Enter some text...",0 
9985 .. 00		clear: db "                    ",0 
999a			 
999a			demo: 
999a			 
999a			 
999a			 
999a			;	call update_display 
999a			 
999a				; init scratch input area for testing 
999a 21 c1 e2			ld hl, scratch	 
999d 3e 00			ld a,0 
999f 77				ld (hl),a 
99a0			 
99a0			 
99a0 3e 28		            LD   A, display_row_2 
99a2			;            CALL fLCD_Pos       ;Position cursor to location in A 
99a2 11 72 99		            LD   DE, str1 
99a5 cd cd 8a			call str_at_display 
99a8			 
99a8			;            CALL fLCD_Str       ;Display string pointed to by DE 
99a8			cloop:	 
99a8 3e 50		            LD   A, display_row_3 
99aa			;            CALL fLCD_Pos       ;Position cursor to location in A 
99aa 11 85 99		            LD   DE, clear 
99ad			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
99ad cd cd 8a				call str_at_display 
99b0 3e 78			ld a, display_row_4 
99b2 11 e2 99			ld de, prompt 
99b5			 
99b5 cd cd 8a				call str_at_display 
99b8 cd dd 8a			call update_display 
99bb			 
99bb 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99bd 16 0a			ld d, 10 
99bf 21 c1 e2			ld hl, scratch	 
99c2 cd 14 8d			call input_str 
99c5			 
99c5			;	call clear_display 
99c5			;'	call update_display 
99c5			 
99c5 3e 00		            LD   A, display_row_1 
99c7			;            CALL fLCD_Pos       ;Position cursor to location in A 
99c7 11 85 99		            LD   DE, clear 
99ca cd cd 8a				call str_at_display 
99cd			;            CALL fLCD_Str       ;Display string pointed to by DE 
99cd 3e 00		            LD   A, display_row_1 
99cf			;            CALL fLCD_Pos       ;Position cursor to location in A 
99cf 11 c1 e2		            LD   DE, scratch 
99d2			;            CALL fLCD_Str       ;Display string pointed to by DE 
99d2 cd cd 8a				call str_at_display 
99d5 cd dd 8a			call update_display 
99d8			 
99d8 3e 00				ld a,0 
99da 21 c1 e2			ld hl, scratch 
99dd 77				ld (hl),a 
99de			 
99de 00				nop 
99df c3 a8 99			jp cloop 
99e2			 
99e2			 
99e2			 
99e2			; OS Prompt 
99e2			 
99e2 .. 00		prompt: db ">",0 
99e4 .. 00		endprg: db "?",0 
99e6			 
99e6			 
99e6			; handy next page prompt 
99e6			next_page_prompt: 
99e6 e5				push hl 
99e7 d5				push de 
99e8 f5				push af 
99e9 c5				push bc 
99ea			 
99ea 3e 9f			ld a,display_row_4 + display_cols - 1 
99ec 11 e4 99		        ld de, endprg 
99ef cd cd 8a			call str_at_display 
99f2 cd dd 8a			call update_display 
99f5 cd 1d dd			call cin_wait 
99f8 c1				pop bc 
99f9 f1				pop af 
99fa d1				pop de 
99fb e1				pop hl 
99fc			 
99fc			 
99fc c9				ret 
99fd			 
99fd			 
99fd			; forth parser 
99fd			 
99fd			; My forth kernel 
99fd			include "forth_kernel.asm" 
99fd			; 
99fd			; kernel to the forth OS 
99fd			 
99fd			DS_TYPE_STR: equ 1     ; string type 
99fd			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
99fd			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
99fd			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
99fd			 
99fd			FORTH_PARSEV1: equ 0 
99fd			FORTH_PARSEV2: equ 0 
99fd			FORTH_PARSEV3: equ 0 
99fd			FORTH_PARSEV4: equ 0 
99fd			FORTH_PARSEV5: equ 1 
99fd			 
99fd			;if FORTH_PARSEV5 
99fd			;	FORTH_END_BUFFER: equ 0 
99fd			;else 
99fd			FORTH_END_BUFFER: equ 127 
99fd			;endif 
99fd			 
99fd			FORTH_TRUE: equ 1 
99fd			FORTH_FALSE: equ 0 
99fd			 
99fd			if FORTH_PARSEV4 
99fd			include "forth_stackops.asm" 
99fd			endif 
99fd			 
99fd			if FORTH_PARSEV5 
99fd			include "forth_stackopsv5.asm" 
99fd			 
99fd			; Stack operations for v5 parser on wards 
99fd			; * DATA stack 
99fd			; * LOOP stack 
99fd			; * RETURN stack 
99fd			 
99fd			 
99fd			 
99fd			FORTH_CHK_DSP_UNDER: macro 
99fd				push hl 
99fd				push de 
99fd				ld hl,(cli_data_sp) 
99fd				ld de, cli_data_stack 
99fd				call cmp16 
99fd				jp c, fault_dsp_under 
99fd				pop de 
99fd				pop hl 
99fd				endm 
99fd			 
99fd			 
99fd			FORTH_CHK_RSP_UNDER: macro 
99fd				push hl 
99fd				push de 
99fd				ld hl,(cli_ret_sp) 
99fd				ld de, cli_ret_stack 
99fd				call cmp16 
99fd				jp c, fault_rsp_under 
99fd				pop de 
99fd				pop hl 
99fd				endm 
99fd			 
99fd			FORTH_CHK_LOOP_UNDER: macro 
99fd				push hl 
99fd				push de 
99fd				ld hl,(cli_loop_sp) 
99fd				ld de, cli_loop_stack 
99fd				call cmp16 
99fd				jp c, fault_loop_under 
99fd				pop de 
99fd				pop hl 
99fd				endm 
99fd			 
99fd			FORTH_ERR_TOS_NOTSTR: macro 
99fd				; TOSO might need more for checks when used 
99fd				push af 
99fd				ld a,(hl) 
99fd				cp DS_TYPE_STR 
99fd				jp nz, type_faultn   
99fd				pop af 
99fd				endm 
99fd			 
99fd			FORTH_ERR_TOS_NOTNUM: macro 
99fd				push af 
99fd				ld a,(hl) 
99fd				cp DS_TYPE_INUM 
99fd				jp nz, type_faultn   
99fd				pop af 
99fd				endm 
99fd			 
99fd			 
99fd			; increase data stack pointer and save hl to it 
99fd				 
99fd			FORTH_DSP_NEXT: macro 
99fd				call macro_forth_dsp_next 
99fd				endm 
99fd			 
99fd			 
99fd			macro_forth_dsp_next: 
99fd				if DEBUG_FORTH_STACK_GUARD 
99fd cd 8f d9				call check_stacks 
9a00				endif 
9a00 e5				push hl 
9a01 d5				push de 
9a02 eb				ex de,hl 
9a03 2a ee e9			ld hl,(cli_data_sp) 
9a06 23				inc hl 
9a07 23				inc hl 
9a08			 
9a08			; PARSEV5 
9a08 23				inc hl 
9a09 22 ee e9			ld (cli_data_sp),hl 
9a0c 73				ld (hl), e 
9a0d 23				inc hl 
9a0e 72				ld (hl), d 
9a0f d1				pop de 
9a10 e1				pop hl 
9a11				if DEBUG_FORTH_STACK_GUARD 
9a11 cd 8f d9				call check_stacks 
9a14				endif 
9a14 c9				ret 
9a15			 
9a15			 
9a15			; increase ret stack pointer and save hl to it 
9a15				 
9a15			FORTH_RSP_NEXT: macro 
9a15				call macro_forth_rsp_next 
9a15				endm 
9a15			 
9a15			macro_forth_rsp_next: 
9a15				if DEBUG_FORTH_STACK_GUARD 
9a15 cd 8f d9				call check_stacks 
9a18				endif 
9a18 e5				push hl 
9a19 d5				push de 
9a1a eb				ex de,hl 
9a1b 2a f2 e9			ld hl,(cli_ret_sp) 
9a1e 23				inc hl 
9a1f 23				inc hl 
9a20 22 f2 e9			ld (cli_ret_sp),hl 
9a23 73				ld (hl), e 
9a24 23				inc hl 
9a25 72				ld (hl), d 
9a26 d1				pop de 
9a27 e1				pop hl 
9a28				if DEBUG_FORTH_STACK_GUARD 
9a28 cd 8f d9				call check_stacks 
9a2b				endif 
9a2b c9				ret 
9a2c			 
9a2c			; get current ret stack pointer and save to hl  
9a2c				 
9a2c			FORTH_RSP_TOS: macro 
9a2c				call macro_forth_rsp_tos 
9a2c				endm 
9a2c			 
9a2c			macro_forth_rsp_tos: 
9a2c				;push de 
9a2c 2a f2 e9			ld hl,(cli_ret_sp) 
9a2f cd 67 9a			call loadhlptrtohl 
9a32				;ld e, (hl) 
9a32				;inc hl 
9a32				;ld d, (hl) 
9a32				;ex de, hl 
9a32					if DEBUG_FORTH_WORDS 
9a32			;			DMARK "RST" 
9a32						CALLMONITOR 
9a32 cd 6f ee			call debug_vector  
9a35				endm  
# End of macro CALLMONITOR
9a35					endif 
9a35				;pop de 
9a35 c9				ret 
9a36			 
9a36			; pop ret stack pointer 
9a36				 
9a36			FORTH_RSP_POP: macro 
9a36				call macro_forth_rsp_pop 
9a36				endm 
9a36			 
9a36			 
9a36			macro_forth_rsp_pop: 
9a36				if DEBUG_FORTH_STACK_GUARD 
9a36			;		DMARK "RPP" 
9a36 cd 8f d9				call check_stacks 
9a39					FORTH_CHK_RSP_UNDER 
9a39 e5				push hl 
9a3a d5				push de 
9a3b 2a f2 e9			ld hl,(cli_ret_sp) 
9a3e 11 ac e9			ld de, cli_ret_stack 
9a41 cd 05 8d			call cmp16 
9a44 da a6 da			jp c, fault_rsp_under 
9a47 d1				pop de 
9a48 e1				pop hl 
9a49				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a49				endif 
9a49 e5				push hl 
9a4a 2a f2 e9			ld hl,(cli_ret_sp) 
9a4d			 
9a4d			 
9a4d				if FORTH_ENABLE_FREE 
9a4d			 
9a4d					; get pointer 
9a4d			 
9a4d					push de 
9a4d					push hl 
9a4d			 
9a4d					ld e, (hl) 
9a4d					inc hl 
9a4d					ld d, (hl) 
9a4d			 
9a4d					ex de, hl 
9a4d					call free 
9a4d			 
9a4d					pop hl 
9a4d					pop de 
9a4d			 
9a4d			 
9a4d				endif 
9a4d			 
9a4d			 
9a4d 2b				dec hl 
9a4e 2b				dec hl 
9a4f 22 f2 e9			ld (cli_ret_sp), hl 
9a52				; do stack underflow checks 
9a52 e1				pop hl 
9a53				if DEBUG_FORTH_STACK_GUARD 
9a53 cd 8f d9				call check_stacks 
9a56					FORTH_CHK_RSP_UNDER 
9a56 e5				push hl 
9a57 d5				push de 
9a58 2a f2 e9			ld hl,(cli_ret_sp) 
9a5b 11 ac e9			ld de, cli_ret_stack 
9a5e cd 05 8d			call cmp16 
9a61 da a6 da			jp c, fault_rsp_under 
9a64 d1				pop de 
9a65 e1				pop hl 
9a66				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a66				endif 
9a66 c9				ret 
9a67			 
9a67			 
9a67			 
9a67			; routine to load word pointed to by hl into hl 
9a67			 
9a67			loadhlptrtohl: 
9a67			 
9a67 d5				push de 
9a68 5e				ld e, (hl) 
9a69 23				inc hl 
9a6a 56				ld d, (hl) 
9a6b eb				ex de, hl 
9a6c d1				pop de 
9a6d			 
9a6d c9				ret 
9a6e			 
9a6e			 
9a6e			 
9a6e			 
9a6e			 
9a6e			; push a number held in HL onto the data stack 
9a6e			; entry point for pushing a value when already in hl used in function above 
9a6e			 
9a6e			forth_push_numhl: 
9a6e			 
9a6e e5				push hl    ; save value to push 
9a6f			 
9a6f			if DEBUG_FORTH_PUSH 
9a6f				; see if disabled 
9a6f			 
9a6f			 
9a6f f5				push af 
9a70 3a 6f ee			ld a,(debug_vector) 
9a73 fe c9			cp $c9   ; ret 
9a75			;	ld a, (os_view_disable) 
9a75			;	cp '*' 
9a75 28 34			jr z, .pskip2 
9a77 e5				push hl 
9a78 e5			push hl 
9a79 cd ba 8a			call clear_display 
9a7c e1			pop hl 
9a7d 7c				ld a,h 
9a7e 21 c6 e5			ld hl, os_word_scratch 
9a81 cd f0 8e			call hexout 
9a84 e1				pop hl 
9a85 7d				ld a,l 
9a86 21 c8 e5			ld hl, os_word_scratch+2 
9a89 cd f0 8e			call hexout 
9a8c			 
9a8c 21 ca e5			ld hl, os_word_scratch+4 
9a8f 3e 00			ld a,0 
9a91 77				ld (hl),a 
9a92 11 c6 e5			ld de,os_word_scratch 
9a95 3e 28				ld a, display_row_2 
9a97 cd cd 8a				call str_at_display 
9a9a 11 9d cb			ld de, .push_num 
9a9d 3e 00			ld a, display_row_1 
9a9f			 
9a9f cd cd 8a				call str_at_display 
9aa2			 
9aa2			 
9aa2 cd dd 8a			call update_display 
9aa5 cd fd 89			call delay1s 
9aa8 cd fd 89			call delay1s 
9aab			.pskip2:  
9aab			 
9aab f1				pop af 
9aac			endif	 
9aac			 
9aac			 
9aac				FORTH_DSP_NEXT 
9aac cd fd 99			call macro_forth_dsp_next 
9aaf				endm 
# End of macro FORTH_DSP_NEXT
9aaf			 
9aaf 2a ee e9			ld hl, (cli_data_sp) 
9ab2			 
9ab2				; save item type 
9ab2 3e 02			ld a,  DS_TYPE_INUM 
9ab4 77				ld (hl), a 
9ab5 23				inc hl 
9ab6			 
9ab6				; get word off stack 
9ab6 d1				pop de 
9ab7 7b				ld a,e 
9ab8 77				ld (hl), a 
9ab9 23				inc hl 
9aba 7a				ld a,d 
9abb 77				ld (hl), a 
9abc			 
9abc			if DEBUG_FORTH_PUSH 
9abc 2b				dec hl 
9abd 2b				dec hl 
9abe 2b				dec hl 
9abf						DMARK "PH5" 
9abf f5				push af  
9ac0 3a d4 9a			ld a, (.dmark)  
9ac3 32 6b ee			ld (debug_mark),a  
9ac6 3a d5 9a			ld a, (.dmark+1)  
9ac9 32 6c ee			ld (debug_mark+1),a  
9acc 3a d6 9a			ld a, (.dmark+2)  
9acf 32 6d ee			ld (debug_mark+2),a  
9ad2 18 03			jr .pastdmark  
9ad4 ..			.dmark: db "PH5"  
9ad7 f1			.pastdmark: pop af  
9ad8			endm  
# End of macro DMARK
9ad8				CALLMONITOR 
9ad8 cd 6f ee			call debug_vector  
9adb				endm  
# End of macro CALLMONITOR
9adb			endif	 
9adb			 
9adb c9				ret 
9adc			 
9adc			 
9adc			; Push a string to stack pointed to by hl 
9adc			 
9adc			forth_push_str: 
9adc			 
9adc			if DEBUG_FORTH_PUSH 
9adc						DMARK "PSQ" 
9adc f5				push af  
9add 3a f1 9a			ld a, (.dmark)  
9ae0 32 6b ee			ld (debug_mark),a  
9ae3 3a f2 9a			ld a, (.dmark+1)  
9ae6 32 6c ee			ld (debug_mark+1),a  
9ae9 3a f3 9a			ld a, (.dmark+2)  
9aec 32 6d ee			ld (debug_mark+2),a  
9aef 18 03			jr .pastdmark  
9af1 ..			.dmark: db "PSQ"  
9af4 f1			.pastdmark: pop af  
9af5			endm  
# End of macro DMARK
9af5				CALLMONITOR 
9af5 cd 6f ee			call debug_vector  
9af8				endm  
# End of macro CALLMONITOR
9af8			endif	 
9af8			 
9af8			 
9af8			    
9af8 e5				push hl 
9af9 e5				push hl 
9afa			 
9afa			;	ld a, 0   ; find end of string 
9afa cd 4d 90			call strlenz 
9afd			if DEBUG_FORTH_PUSH 
9afd						DMARK "PQ2" 
9afd f5				push af  
9afe 3a 12 9b			ld a, (.dmark)  
9b01 32 6b ee			ld (debug_mark),a  
9b04 3a 13 9b			ld a, (.dmark+1)  
9b07 32 6c ee			ld (debug_mark+1),a  
9b0a 3a 14 9b			ld a, (.dmark+2)  
9b0d 32 6d ee			ld (debug_mark+2),a  
9b10 18 03			jr .pastdmark  
9b12 ..			.dmark: db "PQ2"  
9b15 f1			.pastdmark: pop af  
9b16			endm  
# End of macro DMARK
9b16				CALLMONITOR 
9b16 cd 6f ee			call debug_vector  
9b19				endm  
# End of macro CALLMONITOR
9b19			endif	 
9b19 eb				ex de, hl 
9b1a e1				pop hl   ; get ptr to start of string 
9b1b			if DEBUG_FORTH_PUSH 
9b1b						DMARK "PQ3" 
9b1b f5				push af  
9b1c 3a 30 9b			ld a, (.dmark)  
9b1f 32 6b ee			ld (debug_mark),a  
9b22 3a 31 9b			ld a, (.dmark+1)  
9b25 32 6c ee			ld (debug_mark+1),a  
9b28 3a 32 9b			ld a, (.dmark+2)  
9b2b 32 6d ee			ld (debug_mark+2),a  
9b2e 18 03			jr .pastdmark  
9b30 ..			.dmark: db "PQ3"  
9b33 f1			.pastdmark: pop af  
9b34			endm  
# End of macro DMARK
9b34				CALLMONITOR 
9b34 cd 6f ee			call debug_vector  
9b37				endm  
# End of macro CALLMONITOR
9b37			endif	 
9b37 19				add hl,de 
9b38			if DEBUG_FORTH_PUSH 
9b38						DMARK "PQE" 
9b38 f5				push af  
9b39 3a 4d 9b			ld a, (.dmark)  
9b3c 32 6b ee			ld (debug_mark),a  
9b3f 3a 4e 9b			ld a, (.dmark+1)  
9b42 32 6c ee			ld (debug_mark+1),a  
9b45 3a 4f 9b			ld a, (.dmark+2)  
9b48 32 6d ee			ld (debug_mark+2),a  
9b4b 18 03			jr .pastdmark  
9b4d ..			.dmark: db "PQE"  
9b50 f1			.pastdmark: pop af  
9b51			endm  
# End of macro DMARK
9b51				CALLMONITOR 
9b51 cd 6f ee			call debug_vector  
9b54				endm  
# End of macro CALLMONITOR
9b54			endif	 
9b54			 
9b54 2b				dec hl    ; see if there is an optional trailing double quote 
9b55 7e				ld a,(hl) 
9b56 fe 22			cp '"' 
9b58 20 03			jr nz, .strnoq 
9b5a 3e 00			ld a, 0      ; get rid of double quote 
9b5c 77				ld (hl), a 
9b5d 23			.strnoq: inc hl 
9b5e			 
9b5e 3e 00			ld a, 0 
9b60 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9b61			 
9b61 13				inc de ; add one for the type string 
9b62 13				inc de ; add one for null term??? 
9b63			 
9b63				; tos is get string pointer again 
9b63				; de contains space to allocate 
9b63				 
9b63 d5				push de 
9b64			 
9b64 eb				ex de, hl 
9b65			 
9b65				;push af 
9b65			 
9b65			if DEBUG_FORTH_PUSH 
9b65						DMARK "PHm" 
9b65 f5				push af  
9b66 3a 7a 9b			ld a, (.dmark)  
9b69 32 6b ee			ld (debug_mark),a  
9b6c 3a 7b 9b			ld a, (.dmark+1)  
9b6f 32 6c ee			ld (debug_mark+1),a  
9b72 3a 7c 9b			ld a, (.dmark+2)  
9b75 32 6d ee			ld (debug_mark+2),a  
9b78 18 03			jr .pastdmark  
9b7a ..			.dmark: db "PHm"  
9b7d f1			.pastdmark: pop af  
9b7e			endm  
# End of macro DMARK
9b7e				CALLMONITOR 
9b7e cd 6f ee			call debug_vector  
9b81				endm  
# End of macro CALLMONITOR
9b81			endif	 
9b81 cd c2 90			call malloc	; on ret hl now contains allocated memory 
9b84				if DEBUG_FORTH_MALLOC_GUARD 
9b84 cc f5 cb				call z,malloc_error 
9b87				endif 
9b87			 
9b87				 
9b87 c1				pop bc    ; get length 
9b88 d1				pop de   ;  get string start    
9b89			 
9b89				; hl has destination from malloc 
9b89			 
9b89 eb				ex de, hl    ; prep for ldir 
9b8a			 
9b8a d5				push de   ; save malloc area for DSP later 
9b8b				;push hl   ; save malloc area for DSP later 
9b8b			 
9b8b			if DEBUG_FORTH_PUSH 
9b8b						DMARK "PHc" 
9b8b f5				push af  
9b8c 3a a0 9b			ld a, (.dmark)  
9b8f 32 6b ee			ld (debug_mark),a  
9b92 3a a1 9b			ld a, (.dmark+1)  
9b95 32 6c ee			ld (debug_mark+1),a  
9b98 3a a2 9b			ld a, (.dmark+2)  
9b9b 32 6d ee			ld (debug_mark+2),a  
9b9e 18 03			jr .pastdmark  
9ba0 ..			.dmark: db "PHc"  
9ba3 f1			.pastdmark: pop af  
9ba4			endm  
# End of macro DMARK
9ba4				CALLMONITOR 
9ba4 cd 6f ee			call debug_vector  
9ba7				endm  
# End of macro CALLMONITOR
9ba7			endif	 
9ba7			 
9ba7			 
9ba7 ed b0			ldir 
9ba9			 
9ba9			 
9ba9				; push malloc to data stack     macro?????  
9ba9			 
9ba9				FORTH_DSP_NEXT 
9ba9 cd fd 99			call macro_forth_dsp_next 
9bac				endm 
# End of macro FORTH_DSP_NEXT
9bac			 
9bac				; save value and type 
9bac			 
9bac 2a ee e9			ld hl, (cli_data_sp) 
9baf			 
9baf				; save item type 
9baf 3e 01			ld a,  DS_TYPE_STR 
9bb1 77				ld (hl), a 
9bb2 23				inc hl 
9bb3			 
9bb3				; get malloc word off stack 
9bb3 d1				pop de 
9bb4 73				ld (hl), e 
9bb5 23				inc hl 
9bb6 72				ld (hl), d 
9bb7			 
9bb7			 
9bb7			 
9bb7			if DEBUG_FORTH_PUSH 
9bb7 2a ee e9			ld hl, (cli_data_sp) 
9bba						DMARK "PHS" 
9bba f5				push af  
9bbb 3a cf 9b			ld a, (.dmark)  
9bbe 32 6b ee			ld (debug_mark),a  
9bc1 3a d0 9b			ld a, (.dmark+1)  
9bc4 32 6c ee			ld (debug_mark+1),a  
9bc7 3a d1 9b			ld a, (.dmark+2)  
9bca 32 6d ee			ld (debug_mark+2),a  
9bcd 18 03			jr .pastdmark  
9bcf ..			.dmark: db "PHS"  
9bd2 f1			.pastdmark: pop af  
9bd3			endm  
# End of macro DMARK
9bd3				CALLMONITOR 
9bd3 cd 6f ee			call debug_vector  
9bd6				endm  
# End of macro CALLMONITOR
9bd6			;	ex de,hl 
9bd6			endif	 
9bd6				; in case of spaces, skip the ptr past the copied string 
9bd6				;pop af 
9bd6				;ld (cli_origptr),hl 
9bd6			 
9bd6 c9				ret 
9bd7			 
9bd7			 
9bd7			 
9bd7			; TODO ascii push input onto stack given hl to start of input 
9bd7			 
9bd7			; identify type 
9bd7			; if starts with a " then a string 
9bd7			; otherwise it is a number 
9bd7			;  
9bd7			; if a string 
9bd7			;     scan for ending " to get length of string to malloc for + 1 
9bd7			;     malloc 
9bd7			;     put pointer to string on stack first byte flags as string 
9bd7			; 
9bd7			; else a number 
9bd7			;    look for number format identifier 
9bd7			;    $xx hex 
9bd7			;    %xxxxx bin 
9bd7			;    xxxxx decimal 
9bd7			;    convert number to 16bit word.  
9bd7			;    malloc word + 1 with flag to identiy as num 
9bd7			;    put pointer to number on stack 
9bd7			;   
9bd7			;  
9bd7			  
9bd7			forth_apush: 
9bd7				; kernel push 
9bd7			 
9bd7			if DEBUG_FORTH_PUSH 
9bd7						DMARK "PSH" 
9bd7 f5				push af  
9bd8 3a ec 9b			ld a, (.dmark)  
9bdb 32 6b ee			ld (debug_mark),a  
9bde 3a ed 9b			ld a, (.dmark+1)  
9be1 32 6c ee			ld (debug_mark+1),a  
9be4 3a ee 9b			ld a, (.dmark+2)  
9be7 32 6d ee			ld (debug_mark+2),a  
9bea 18 03			jr .pastdmark  
9bec ..			.dmark: db "PSH"  
9bef f1			.pastdmark: pop af  
9bf0			endm  
# End of macro DMARK
9bf0				CALLMONITOR 
9bf0 cd 6f ee			call debug_vector  
9bf3				endm  
# End of macro CALLMONITOR
9bf3			endif	 
9bf3				; identify input type 
9bf3			 
9bf3 7e				ld a,(hl) 
9bf4			 
9bf4 fe 23			cp '#' 
9bf6 ca 30 9c			jp z, .fapdec 
9bf9			 
9bf9			 
9bf9 fe 22			cp '"' 
9bfb 28 0a			jr z, .fapstr 
9bfd fe 24			cp '$' 
9bff ca 27 9c			jp z, .faphex 
9c02 fe 25			cp '%' 
9c04 ca 0f 9c			jp z, .fapbin 
9c07			;	cp 'b' 
9c07			;	jp z, .fabin 
9c07				; else decimal 
9c07			 
9c07				; TODO do decimal conversion 
9c07				; decimal is stored as a 16bit word 
9c07			 
9c07				; by default everything is a string if type is not detected 
9c07			.fapstr: ; 
9c07 fe 22			cp '"' 
9c09 20 01			jr nz, .strnoqu 
9c0b 23				inc hl 
9c0c			.strnoqu: 
9c0c c3 dc 9a			jp forth_push_str 
9c0f			 
9c0f			 
9c0f			 
9c0f			.fapbin:    ; push a binary string.  
9c0f 11 00 00			ld de, 0   ; hold a 16bit value 
9c12			 
9c12 23			.fapbinshift:	inc hl  
9c13 7e				ld a,(hl) 
9c14 fe 00			cp 0     ; done scanning  
9c16 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c18			 
9c18				; left shift de 
9c18 eb				ex de, hl	 
9c19 29				add hl, hl 
9c1a			 
9c1a				; is 1 
9c1a fe 31			cp '1' 
9c1c 20 02			jr nz, .binzero 
9c1e cb 4d			bit 1, l 
9c20			.binzero: 
9c20 eb				ex de, hl	 ; save current de 
9c21 18 ef			jr .fapbinshift 
9c23			 
9c23			.fapbdone: 
9c23 eb				ex de, hl 
9c24 c3 6e 9a			jp forth_push_numhl 
9c27			 
9c27			 
9c27			.faphex:   ; hex is always stored as a 16bit word 
9c27				; skip number prefix 
9c27 23				inc hl 
9c28				; turn ascii into number 
9c28 cd a6 8f			call get_word_hl	; ret 16bit word in hl 
9c2b			 
9c2b c3 6e 9a			jp forth_push_numhl 
9c2e			 
9c2e 00				 nop 
9c2f			 
9c2f			.fabin:   ; TODO bin conversion 
9c2f			 
9c2f			 
9c2f c9				ret 
9c30			.fapdec:	 
9c30				; string to dec conversion 
9c30 23				inc hl 
9c31 eb				ex de, hl 
9c32 cd e4 8f			call string_to_uint16 
9c35 c3 6e 9a			jp forth_push_numhl 
9c38 c9				ret 
9c39				 
9c39			;atoui_16: 
9c39			 
9c39			; get either a string ptr or a 16bit word from the data stack 
9c39			 
9c39			FORTH_DSP: macro 
9c39				call macro_forth_dsp 
9c39				endm 
9c39			 
9c39			macro_forth_dsp: 
9c39				; data stack pointer points to current word on tos 
9c39			 
9c39 2a ee e9			ld hl,(cli_data_sp) 
9c3c			 
9c3c				if DEBUG_FORTH_PUSH 
9c3c						DMARK "DSP" 
9c3c f5				push af  
9c3d 3a 51 9c			ld a, (.dmark)  
9c40 32 6b ee			ld (debug_mark),a  
9c43 3a 52 9c			ld a, (.dmark+1)  
9c46 32 6c ee			ld (debug_mark+1),a  
9c49 3a 53 9c			ld a, (.dmark+2)  
9c4c 32 6d ee			ld (debug_mark+2),a  
9c4f 18 03			jr .pastdmark  
9c51 ..			.dmark: db "DSP"  
9c54 f1			.pastdmark: pop af  
9c55			endm  
# End of macro DMARK
9c55			 
9c55 cd 28 cc				call display_data_sp 
9c58				;call break_point_state 
9c58				;rst 030h 
9c58				CALLMONITOR 
9c58 cd 6f ee			call debug_vector  
9c5b				endm  
# End of macro CALLMONITOR
9c5b				endif 
9c5b			 
9c5b c9				ret 
9c5c			 
9c5c			; return hl to start of value on stack 
9c5c			 
9c5c			FORTH_DSP_VALUE: macro 
9c5c				call macro_forth_dsp_value 
9c5c				endm 
9c5c			 
9c5c			macro_forth_dsp_value: 
9c5c			 
9c5c				FORTH_DSP 
9c5c cd 39 9c			call macro_forth_dsp 
9c5f				endm 
# End of macro FORTH_DSP
9c5f			 
9c5f d5				push de 
9c60			 
9c60 23				inc hl ; skip type 
9c61			 
9c61 5e				ld e, (hl) 
9c62 23				inc hl 
9c63 56				ld d, (hl) 
9c64 eb				ex de,hl  
9c65			 
9c65 d1				pop de 
9c66			 
9c66 c9				ret 
9c67			 
9c67			; return hl to start of value to second item on stack 
9c67			 
9c67			FORTH_DSP_VALUEM1: macro 
9c67				call macro_forth_dsp_value_m1 
9c67				endm 
9c67			 
9c67			macro_forth_dsp_value_m1: 
9c67			 
9c67				FORTH_DSP 
9c67 cd 39 9c			call macro_forth_dsp 
9c6a				endm 
# End of macro FORTH_DSP
9c6a			 
9c6a 2b				dec hl 
9c6b 2b				dec hl 
9c6c			;	dec hl 
9c6c			 
9c6c d5				push de 
9c6d			 
9c6d 5e				ld e, (hl) 
9c6e 23				inc hl 
9c6f 56				ld d, (hl) 
9c70 eb				ex de,hl  
9c71			 
9c71 d1				pop de 
9c72			 
9c72 c9				ret 
9c73			 
9c73				 
9c73			 
9c73			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9c73			 
9c73			FORTH_DSP_POP: macro 
9c73				call macro_forth_dsp_pop 
9c73				endm 
9c73			 
9c73			 
9c73			; get the tos data type 
9c73			 
9c73			FORTH_DSP_TYPE:   macro 
9c73			 
9c73				;FORTH_DSP_VALUE 
9c73				FORTH_DSP 
9c73				 
9c73				; hl points to value 
9c73				; check type 
9c73			 
9c73				ld a,(hl) 
9c73			 
9c73				endm 
9c73			 
9c73			; load the tos value into hl 
9c73			 
9c73			 
9c73			FORTH_DSP_VALUEHL:  macro 
9c73				call macro_dsp_valuehl 
9c73				endm 
9c73			 
9c73			 
9c73			 
9c73			macro_dsp_valuehl: 
9c73				FORTH_DSP_VALUE 
9c73 cd 5c 9c			call macro_forth_dsp_value 
9c76				endm 
# End of macro FORTH_DSP_VALUE
9c76			 
9c76				;FORTH_ERR_TOS_NOTNUM 
9c76			 
9c76				;inc hl   ; skip type id 
9c76			 
9c76			;	push de 
9c76			; 
9c76			;	ld e, (hl) 
9c76			;	inc hl 
9c76			;	ld d, (hl) 
9c76			;	ex de,hl  
9c76			 
9c76			;	pop de 
9c76			 
9c76				if DEBUG_FORTH_PUSH 
9c76						DMARK "DVL" 
9c76 f5				push af  
9c77 3a 8b 9c			ld a, (.dmark)  
9c7a 32 6b ee			ld (debug_mark),a  
9c7d 3a 8c 9c			ld a, (.dmark+1)  
9c80 32 6c ee			ld (debug_mark+1),a  
9c83 3a 8d 9c			ld a, (.dmark+2)  
9c86 32 6d ee			ld (debug_mark+2),a  
9c89 18 03			jr .pastdmark  
9c8b ..			.dmark: db "DVL"  
9c8e f1			.pastdmark: pop af  
9c8f			endm  
# End of macro DMARK
9c8f				CALLMONITOR 
9c8f cd 6f ee			call debug_vector  
9c92				endm  
# End of macro CALLMONITOR
9c92				endif 
9c92 c9				ret 
9c93			 
9c93			forth_apushstrhl:      
9c93				; push of string requires use of cli_origptr 
9c93				; bodge use 
9c93			 
9c93				; get current cli_origptr, save, update with temp pointer  
9c93 ed 5b 3e ea		ld de, (cli_origptr) 
9c97 22 3e ea			ld (cli_origptr), hl 
9c9a d5				push de 
9c9b cd d7 9b			call forth_apush 
9c9e d1				pop de 
9c9f ed 53 3e ea		ld (cli_origptr), de 
9ca3 c9			        ret	 
9ca4			 
9ca4			 
9ca4			; increase loop stack pointer and save hl to it 
9ca4				 
9ca4			FORTH_LOOP_NEXT: macro 
9ca4				call macro_forth_loop_next 
9ca4				;nop 
9ca4				endm 
9ca4			 
9ca4			macro_forth_loop_next: 
9ca4				if DEBUG_FORTH_STACK_GUARD 
9ca4 cd 8f d9				call check_stacks 
9ca7				endif 
9ca7 e5				push hl 
9ca8 d5				push de 
9ca9 eb				ex de,hl 
9caa 2a f0 e9			ld hl,(cli_loop_sp) 
9cad 23				inc hl 
9cae 23				inc hl 
9caf					if DEBUG_FORTH_WORDS 
9caf						DMARK "LNX" 
9caf f5				push af  
9cb0 3a c4 9c			ld a, (.dmark)  
9cb3 32 6b ee			ld (debug_mark),a  
9cb6 3a c5 9c			ld a, (.dmark+1)  
9cb9 32 6c ee			ld (debug_mark+1),a  
9cbc 3a c6 9c			ld a, (.dmark+2)  
9cbf 32 6d ee			ld (debug_mark+2),a  
9cc2 18 03			jr .pastdmark  
9cc4 ..			.dmark: db "LNX"  
9cc7 f1			.pastdmark: pop af  
9cc8			endm  
# End of macro DMARK
9cc8						CALLMONITOR 
9cc8 cd 6f ee			call debug_vector  
9ccb				endm  
# End of macro CALLMONITOR
9ccb					endif 
9ccb 22 f0 e9			ld (cli_loop_sp),hl 
9cce 73				ld (hl), e 
9ccf 23				inc hl 
9cd0 72				ld (hl), d 
9cd1 d1				pop de    ; been reversed so save a swap on restore 
9cd2 e1				pop hl 
9cd3				if DEBUG_FORTH_STACK_GUARD 
9cd3 cd 8f d9				call check_stacks 
9cd6				endif 
9cd6 c9				ret 
9cd7			 
9cd7			; get current ret stack pointer and save to hl  
9cd7				 
9cd7			FORTH_LOOP_TOS: macro 
9cd7				call macro_forth_loop_tos 
9cd7				endm 
9cd7			 
9cd7			macro_forth_loop_tos: 
9cd7 d5				push de 
9cd8 2a f0 e9			ld hl,(cli_loop_sp) 
9cdb 5e				ld e, (hl) 
9cdc 23				inc hl 
9cdd 56				ld d, (hl) 
9cde eb				ex de, hl 
9cdf d1				pop de 
9ce0 c9				ret 
9ce1			 
9ce1			; pop loop stack pointer 
9ce1				 
9ce1			FORTH_LOOP_POP: macro 
9ce1				call macro_forth_loop_pop 
9ce1				endm 
9ce1			 
9ce1			 
9ce1			macro_forth_loop_pop: 
9ce1				if DEBUG_FORTH_STACK_GUARD 
9ce1					DMARK "LPP" 
9ce1 f5				push af  
9ce2 3a f6 9c			ld a, (.dmark)  
9ce5 32 6b ee			ld (debug_mark),a  
9ce8 3a f7 9c			ld a, (.dmark+1)  
9ceb 32 6c ee			ld (debug_mark+1),a  
9cee 3a f8 9c			ld a, (.dmark+2)  
9cf1 32 6d ee			ld (debug_mark+2),a  
9cf4 18 03			jr .pastdmark  
9cf6 ..			.dmark: db "LPP"  
9cf9 f1			.pastdmark: pop af  
9cfa			endm  
# End of macro DMARK
9cfa cd 8f d9				call check_stacks 
9cfd					FORTH_CHK_LOOP_UNDER 
9cfd e5				push hl 
9cfe d5				push de 
9cff 2a f0 e9			ld hl,(cli_loop_sp) 
9d02 11 2a e9			ld de, cli_loop_stack 
9d05 cd 05 8d			call cmp16 
9d08 da ac da			jp c, fault_loop_under 
9d0b d1				pop de 
9d0c e1				pop hl 
9d0d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d0d				endif 
9d0d e5				push hl 
9d0e 2a f0 e9			ld hl,(cli_loop_sp) 
9d11 2b				dec hl 
9d12 2b				dec hl 
9d13 22 f0 e9			ld (cli_loop_sp), hl 
9d16				; TODO do stack underflow checks 
9d16 e1				pop hl 
9d17				if DEBUG_FORTH_STACK_GUARD 
9d17 cd 8f d9				call check_stacks 
9d1a					FORTH_CHK_LOOP_UNDER 
9d1a e5				push hl 
9d1b d5				push de 
9d1c 2a f0 e9			ld hl,(cli_loop_sp) 
9d1f 11 2a e9			ld de, cli_loop_stack 
9d22 cd 05 8d			call cmp16 
9d25 da ac da			jp c, fault_loop_under 
9d28 d1				pop de 
9d29 e1				pop hl 
9d2a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d2a				endif 
9d2a c9				ret 
9d2b			 
9d2b			macro_forth_dsp_pop: 
9d2b			 
9d2b e5				push hl 
9d2c			 
9d2c				; release malloc data 
9d2c			 
9d2c				if DEBUG_FORTH_STACK_GUARD 
9d2c cd 8f d9				call check_stacks 
9d2f					FORTH_CHK_DSP_UNDER 
9d2f e5				push hl 
9d30 d5				push de 
9d31 2a ee e9			ld hl,(cli_data_sp) 
9d34 11 28 e8			ld de, cli_data_stack 
9d37 cd 05 8d			call cmp16 
9d3a da a0 da			jp c, fault_dsp_under 
9d3d d1				pop de 
9d3e e1				pop hl 
9d3f				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d3f				endif 
9d3f				;ld hl,(cli_data_sp) 
9d3f			if DEBUG_FORTH_DOT 
9d3f				DMARK "DPP" 
9d3f f5				push af  
9d40 3a 54 9d			ld a, (.dmark)  
9d43 32 6b ee			ld (debug_mark),a  
9d46 3a 55 9d			ld a, (.dmark+1)  
9d49 32 6c ee			ld (debug_mark+1),a  
9d4c 3a 56 9d			ld a, (.dmark+2)  
9d4f 32 6d ee			ld (debug_mark+2),a  
9d52 18 03			jr .pastdmark  
9d54 ..			.dmark: db "DPP"  
9d57 f1			.pastdmark: pop af  
9d58			endm  
# End of macro DMARK
9d58				CALLMONITOR 
9d58 cd 6f ee			call debug_vector  
9d5b				endm  
# End of macro CALLMONITOR
9d5b			endif	 
9d5b			 
9d5b			 
9d5b			if FORTH_ENABLE_DSPPOPFREE 
9d5b			 
9d5b				FORTH_DSP 
9d5b cd 39 9c			call macro_forth_dsp 
9d5e				endm 
# End of macro FORTH_DSP
9d5e			 
9d5e 7e				ld a, (hl) 
9d5f fe 01			cp DS_TYPE_STR 
9d61 20 23			jr nz, .skippopfree 
9d63			 
9d63				FORTH_DSP_VALUEHL 
9d63 cd 73 9c			call macro_dsp_valuehl 
9d66				endm 
# End of macro FORTH_DSP_VALUEHL
9d66 00				nop 
9d67			if DEBUG_FORTH_DOT 
9d67				DMARK "DPf" 
9d67 f5				push af  
9d68 3a 7c 9d			ld a, (.dmark)  
9d6b 32 6b ee			ld (debug_mark),a  
9d6e 3a 7d 9d			ld a, (.dmark+1)  
9d71 32 6c ee			ld (debug_mark+1),a  
9d74 3a 7e 9d			ld a, (.dmark+2)  
9d77 32 6d ee			ld (debug_mark+2),a  
9d7a 18 03			jr .pastdmark  
9d7c ..			.dmark: db "DPf"  
9d7f f1			.pastdmark: pop af  
9d80			endm  
# End of macro DMARK
9d80				CALLMONITOR 
9d80 cd 6f ee			call debug_vector  
9d83				endm  
# End of macro CALLMONITOR
9d83			endif	 
9d83 cd 8c 91			call free 
9d86			.skippopfree: 
9d86				 
9d86			 
9d86			endif 
9d86			 
9d86			if DEBUG_FORTH_DOT_KEY 
9d86				DMARK "DP2" 
9d86				CALLMONITOR 
9d86			endif	 
9d86			 
9d86				; move pointer down 
9d86			 
9d86 2a ee e9			ld hl,(cli_data_sp) 
9d89 2b				dec hl 
9d8a 2b				dec hl 
9d8b			; PARSEV5 
9d8b 2b				dec hl 
9d8c 22 ee e9			ld (cli_data_sp), hl 
9d8f			 
9d8f				if DEBUG_FORTH_STACK_GUARD 
9d8f cd 8f d9				call check_stacks 
9d92					FORTH_CHK_DSP_UNDER 
9d92 e5				push hl 
9d93 d5				push de 
9d94 2a ee e9			ld hl,(cli_data_sp) 
9d97 11 28 e8			ld de, cli_data_stack 
9d9a cd 05 8d			call cmp16 
9d9d da a0 da			jp c, fault_dsp_under 
9da0 d1				pop de 
9da1 e1				pop hl 
9da2				endm 
# End of macro FORTH_CHK_DSP_UNDER
9da2				endif 
9da2			 
9da2 e1				pop hl 
9da3			 
9da3 c9				ret 
9da4			 
9da4			getwordathl: 
9da4				; hl points to an address 
9da4				; load hl with the word at that address 
9da4			 
9da4 d5				push de 
9da5			 
9da5 5e				ld e, (hl) 
9da6 23				inc hl 
9da7 56				ld d, (hl) 
9da8 eb				ex de, hl 
9da9			 
9da9 d1				pop de 
9daa c9				ret 
9dab			 
9dab			 
9dab			 
9dab			 
9dab			 
9dab			; eof 
9dab			 
# End of file forth_stackopsv5.asm
9dab			endif 
9dab			 
9dab			loadwordinhl:	 
9dab			 
9dab d5				push de 
9dac			 
9dac 5e				ld e, (hl) 
9dad 23				inc hl 
9dae 56				ld d, (hl) 
9daf eb				ex de,hl  
9db0			 
9db0 d1				pop de 
9db1			 
9db1 c9				ret 
9db2			 
9db2			user_word_eol:  
9db2				; hl contains the pointer to where to create a linked list item from the end 
9db2				; of the user dict to continue on at the system word dict 
9db2				 
9db2				; poke the stub of the word list linked list to repoint to rom words 
9db2			 
9db2				; stub format 
9db2				; db   word id 
9db2				; dw    link to next word 
9db2			        ; db char length of token 
9db2				; db string + 0 term 
9db2				; db exec code....  
9db2			 
9db2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9db4 77				ld (hl), a		; word id 
9db5 23				inc hl 
9db6			 
9db6 11 81 9f			ld de, sysdict 
9db9 73				ld (hl), e		; next word link ie system dict 
9dba 23				inc hl 
9dbb 72				ld (hl), d		; next word link ie system dict 
9dbc 23				inc hl	 
9dbd			 
9dbd			;	ld (hl), sysdict		; next word link ie system dict 
9dbd			;	inc hl 
9dbd			;	inc hl 
9dbd			 
9dbd			;	inc hl 
9dbd			;	inc hl 
9dbd			 
9dbd 3e 02			ld a, 2			; word length is 0 
9dbf 77				ld (hl), a	 
9dc0 23				inc hl 
9dc1			 
9dc1 3e 7e			ld a, '~'			; word length is 0 
9dc3 77				ld (hl), a	 
9dc4 23				inc hl 
9dc5 3e 00			ld a, 0			; save empty word 
9dc7 77				ld (hl), a 
9dc8			 
9dc8 c9				ret 
9dc9			 
9dc9				 
9dc9			 
9dc9			forthexec_cleanup: 
9dc9				FORTH_RSP_POP 
9dc9 cd 36 9a			call macro_forth_rsp_pop 
9dcc				endm 
# End of macro FORTH_RSP_POP
9dcc c9				ret 
9dcd			 
9dcd			forth_call_hl: 
9dcd				; taking hl 
9dcd e5				push hl 
9dce c9				ret 
9dcf			 
9dcf			; this is called to reset Forth system but keep existing uwords etc 
9dcf			 
9dcf			forth_warmstart: 
9dcf				; setup stack over/under flow checks 
9dcf				if DEBUG_FORTH_STACK_GUARD 
9dcf cd 75 d9				call chk_stk_init 
9dd2				endif 
9dd2			 
9dd2				; init stack pointers  - * these stacks go upwards *  
9dd2 21 ac e9			ld hl, cli_ret_stack 
9dd5 22 f2 e9			ld (cli_ret_sp), hl	 
9dd8				; set bottom of stack 
9dd8 3e 00			ld a,0 
9dda 77				ld (hl),a 
9ddb 23				inc hl 
9ddc 77				ld (hl),a 
9ddd			 
9ddd 21 28 e8			ld hl, cli_data_stack 
9de0 22 ee e9			ld (cli_data_sp), hl	 
9de3				; set bottom of stack 
9de3 3e 00			ld a,0 
9de5 77				ld (hl),a 
9de6 23				inc hl 
9de7 77				ld (hl),a 
9de8			 
9de8 21 2a e9			ld hl, cli_loop_stack 
9deb 22 f0 e9			ld (cli_loop_sp), hl	 
9dee				; set bottom of stack 
9dee 3e 00			ld a,0 
9df0 77				ld (hl),a 
9df1 23				inc hl 
9df2 77				ld (hl),a 
9df3			 
9df3				; init extent of current open file 
9df3			 
9df3 3e 00			ld a, 0 
9df5 32 6a ea			ld (store_openext), a 
9df8			 
9df8 c9				ret 
9df9			 
9df9			 
9df9			 
9df9			; Cold Start - this is called to setup the whole Forth system 
9df9			 
9df9			forth_init: 
9df9			 
9df9				; setup stack over/under flow checks 
9df9			 
9df9			;	if DEBUG_FORTH_STACK_GUARD 
9df9			;		call chk_stk_init 
9df9			;	endif 
9df9			 
9df9				; enable auto display updates (slow.....) 
9df9			 
9df9 3e 01			ld a, 1 
9dfb 32 3c ea			ld (cli_autodisplay), a 
9dfe			 
9dfe				; if storage is in use disable long reads for now 
9dfe 3e 00			ld a, 0 
9e00 32 75 ea			ld (store_longread), a 
9e03			 
9e03			 
9e03				; show start up screen 
9e03			 
9e03 cd ba 8a			call clear_display 
9e06			 
9e06 3e 00			ld a,0 
9e08 32 5e ea			ld (f_cursor_ptr), a 
9e0b			 
9e0b				; set start of word list in start of ram - for use when creating user words 
9e0b			 
9e0b 21 32 dd			ld hl, baseram 
9e0e 22 be e5			ld (os_last_new_uword), hl 
9e11 cd b2 9d			call user_word_eol 
9e14				 
9e14			;		call display_data_sp 
9e14			;		call next_page_prompt 
9e14			 
9e14			 
9e14			 
9e14			 
9e14 c9				ret 
9e15			 
9e15 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e29			 
9e29			; TODO push to stack 
9e29			 
9e29			;  
9e29			 
9e29			if FORTH_PARSEV2 
9e29			 
9e29			 
9e29				include "forth_parserv2.asm" 
9e29			 
9e29			endif 
9e29			 
9e29			 
9e29			; parse cli version 1 
9e29			 
9e29			if FORTH_PARSEV1 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv1.asm" 
9e29			endif 
9e29				 
9e29			if FORTH_PARSEV3 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv3.asm" 
9e29				include "forth_wordsv3.asm" 
9e29			endif 
9e29			 
9e29			if FORTH_PARSEV4 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv4.asm" 
9e29				include "forth_wordsv4.asm" 
9e29			endif 
9e29			 
9e29			if FORTH_PARSEV5 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv5.asm" 
9e29			 
9e29			 
9e29			; A better parser without using malloc and string copies all over the place.  
9e29			; Exec in situ should be faster 
9e29			 
9e29			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e29			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e29			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e29			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e29			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e29			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e29			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e29			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e29			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e29			 
9e29			; Core word preamble macro 
9e29			 
9e29			CWHEAD:   macro nxtword opcode lit len opflags 
9e29				db WORD_SYS_CORE+opcode             
9e29				; internal op code number 
9e29				dw nxtword            
9e29				; link to next dict word block 
9e29				db len + 1 
9e29				; literal length of dict word inc zero term 
9e29				db lit,0              
9e29				; literal dict word 
9e29			        ; TODO db opflags        
9e29				endm 
9e29			 
9e29			 
9e29			NEXTW: macro  
9e29				jp macro_next 
9e29				endm 
9e29			 
9e29			macro_next: 
9e29			if DEBUG_FORTH_PARSE_KEY 
9e29				DMARK "NXT" 
9e29				CALLMONITOR 
9e29			endif	 
9e29			;	inc hl  ; skip token null term  
9e29 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e2d ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e31 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e34			if DEBUG_FORTH_PARSE_KEY 
9e34				DMARK "}AA" 
9e34				CALLMONITOR 
9e34			endif	 
9e34 c3 37 9f			jp execnext 
9e37				;jp exec1 
9e37			       
9e37			 
9e37			 
9e37			; Another go at the parser to compile  
9e37			 
9e37			 
9e37			; TODO rework parser to change all of the string words to byte tokens 
9e37			; TODO do a search for  
9e37			 
9e37			; TODO first run normal parser to zero term sections 
9e37			; TODO for each word do a token look up to get the op code 
9e37			; TODO need some means to flag to the exec that this is a byte code form    
9e37			 
9e37			 
9e37			forthcompile: 
9e37			 
9e37			; 
9e37			; line parse: 
9e37			;       parse raw input buffer 
9e37			;       tokenise the words 
9e37			;       malloc new copy (for looping etc) 
9e37			;       copy to malloc + current pc in line to start of string and add line term 
9e37			;       save on new rsp 
9e37			; 
9e37			 
9e37			; hl to point to the line to tokenise 
9e37			 
9e37			;	push hl 
9e37 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e3a			 
9e3a			;	ld a,0		; string term on input 
9e3a			;	call strlent 
9e3a			 
9e3a			;	ld (os_tok_len), hl	 ; save string length 
9e3a			 
9e3a			;if DEBUG_FORTH_TOK 
9e3a			;	ex de,hl		 
9e3a			;endif 
9e3a			 
9e3a			;	pop hl 		; get back string pointer 
9e3a			 
9e3a			if DEBUG_FORTH_TOK 
9e3a						DMARK "TOc" 
9e3a				CALLMONITOR 
9e3a			endif 
9e3a 7e			.cptoken2:    ld a,(hl) 
9e3b 23				inc hl 
9e3c fe 7f			cp FORTH_END_BUFFER 
9e3e 28 29			jr z, .cptokendone2 
9e40 fe 00			cp 0 
9e42 28 25			jr z, .cptokendone2 
9e44 fe 22			cp '"' 
9e46 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e48 fe 20			cp ' ' 
9e4a 20 ee			jr nz,  .cptoken2 
9e4c			 
9e4c			; TODO consume comments held between ( and ) 
9e4c			 
9e4c				; we have a space so change to zero term for dict match later 
9e4c 2b				dec hl 
9e4d 3e 00			ld a,0 
9e4f 77				ld (hl), a 
9e50 23				inc hl 
9e51 18 e7			jr .cptoken2 
9e53				 
9e53			 
9e53			.cptokenstr2: 
9e53				; skip all white space until either eol (because forgot to term) or end double quote 
9e53			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e53				;inc hl ; skip current double quote 
9e53 7e				ld a,(hl) 
9e54 23				inc hl 
9e55 fe 22			cp '"' 
9e57 28 e1			jr z, .cptoken2 
9e59 fe 7f			cp FORTH_END_BUFFER 
9e5b 28 0c			jr z, .cptokendone2 
9e5d fe 00			cp 0 
9e5f 28 08			jr z, .cptokendone2 
9e61 fe 20			cp ' ' 
9e63 28 02			jr z, .cptmp2 
9e65 18 ec			jr .cptokenstr2 
9e67			 
9e67			.cptmp2:	; we have a space so change to zero term for dict match later 
9e67				;dec hl 
9e67				;ld a,"-"	; TODO remove this when working 
9e67				;ld (hl), a 
9e67				;inc hl 
9e67 18 ea			jr .cptokenstr2 
9e69			 
9e69			.cptokendone2: 
9e69				;inc hl 
9e69 3e 7f			ld a, FORTH_END_BUFFER 
9e6b 77				ld (hl),a 
9e6c 23				inc hl 
9e6d 3e 21			ld a, '!' 
9e6f 77				ld (hl),a 
9e70			 
9e70 2a c2 e5			ld hl,(os_tok_ptr) 
9e73			         
9e73			if DEBUG_FORTH_TOK 
9e73						DMARK "Tc1" 
9e73				CALLMONITOR 
9e73			endif 
9e73			 
9e73				; push exec string to top of return stack 
9e73				FORTH_RSP_NEXT 
9e73 cd 15 9a			call macro_forth_rsp_next 
9e76				endm 
# End of macro FORTH_RSP_NEXT
9e76 c9				ret 
9e77			 
9e77			; Another go at the parser need to simplify the process 
9e77			 
9e77			forthparse: 
9e77			 
9e77			; 
9e77			; line parse: 
9e77			;       parse raw input buffer 
9e77			;       tokenise the words 
9e77			;       malloc new copy (for looping etc) 
9e77			;       copy to malloc + current pc in line to start of string and add line term 
9e77			;       save on new rsp 
9e77			; 
9e77			 
9e77			; hl to point to the line to tokenise 
9e77			 
9e77			;	push hl 
9e77 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e7a			 
9e7a			;	ld a,0		; string term on input 
9e7a			;	call strlent 
9e7a			 
9e7a			;	ld (os_tok_len), hl	 ; save string length 
9e7a			 
9e7a			;if DEBUG_FORTH_TOK 
9e7a			;	ex de,hl		 
9e7a			;endif 
9e7a			 
9e7a			;	pop hl 		; get back string pointer 
9e7a			 
9e7a			if DEBUG_FORTH_TOK 
9e7a						DMARK "TOK" 
9e7a				CALLMONITOR 
9e7a			endif 
9e7a 7e			.ptoken2:    ld a,(hl) 
9e7b 23				inc hl 
9e7c fe 7f			cp FORTH_END_BUFFER 
9e7e 28 29			jr z, .ptokendone2 
9e80 fe 00			cp 0 
9e82 28 25			jr z, .ptokendone2 
9e84 fe 22			cp '"' 
9e86 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e88 fe 20			cp ' ' 
9e8a 20 ee			jr nz,  .ptoken2 
9e8c			 
9e8c			; TODO consume comments held between ( and ) 
9e8c			 
9e8c				; we have a space so change to zero term for dict match later 
9e8c 2b				dec hl 
9e8d 3e 00			ld a,0 
9e8f 77				ld (hl), a 
9e90 23				inc hl 
9e91 18 e7			jr .ptoken2 
9e93				 
9e93			 
9e93			.ptokenstr2: 
9e93				; skip all white space until either eol (because forgot to term) or end double quote 
9e93			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e93				;inc hl ; skip current double quote 
9e93 7e				ld a,(hl) 
9e94 23				inc hl 
9e95 fe 22			cp '"' 
9e97 28 e1			jr z, .ptoken2 
9e99 fe 7f			cp FORTH_END_BUFFER 
9e9b 28 0c			jr z, .ptokendone2 
9e9d fe 00			cp 0 
9e9f 28 08			jr z, .ptokendone2 
9ea1 fe 20			cp ' ' 
9ea3 28 02			jr z, .ptmp2 
9ea5 18 ec			jr .ptokenstr2 
9ea7			 
9ea7			.ptmp2:	; we have a space so change to zero term for dict match later 
9ea7				;dec hl 
9ea7				;ld a,"-"	; TODO remove this when working 
9ea7				;ld (hl), a 
9ea7				;inc hl 
9ea7 18 ea			jr .ptokenstr2 
9ea9			 
9ea9			.ptokendone2: 
9ea9				;inc hl 
9ea9 3e 7f			ld a, FORTH_END_BUFFER 
9eab 77				ld (hl),a 
9eac 23				inc hl 
9ead 3e 21			ld a, '!' 
9eaf 77				ld (hl),a 
9eb0			 
9eb0 2a c2 e5			ld hl,(os_tok_ptr) 
9eb3			         
9eb3			if DEBUG_FORTH_TOK 
9eb3						DMARK "TK1" 
9eb3				CALLMONITOR 
9eb3			endif 
9eb3			 
9eb3				; push exec string to top of return stack 
9eb3				FORTH_RSP_NEXT 
9eb3 cd 15 9a			call macro_forth_rsp_next 
9eb6				endm 
# End of macro FORTH_RSP_NEXT
9eb6 c9				ret 
9eb7			 
9eb7			; 
9eb7			;	; malloc size + buffer pointer + if is loop flag 
9eb7			;	ld hl,(os_tok_len) 		 ; get string length 
9eb7			; 
9eb7			;	ld a,l 
9eb7			; 
9eb7			;	cp 0			; we dont want to use a null string 
9eb7			;	ret z 
9eb7			; 
9eb7			;;	add 3    ; prefix malloc with buffer for current word ptr 
9eb7			; 
9eb7			;	add 5     ; TODO when certain not over writing memory remove 
9eb7			; 
9eb7			;		 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKE" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	ld l,a 
9eb7			;	ld h,0 
9eb7			;;	push hl   ; save required space for the copy later 
9eb7			;	call malloc 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKM" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			;	if DEBUG_FORTH_MALLOC_GUARD 
9eb7			;		push af 
9eb7			;		call ishlzero 
9eb7			;;		ld a, l 
9eb7			;;		add h 
9eb7			;;		cp 0 
9eb7			;		pop af 
9eb7			;		 
9eb7			;		call z,malloc_error 
9eb7			;	endif 
9eb7			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9eb7			; 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKR" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	FORTH_RSP_NEXT 
9eb7			; 
9eb7			;	;inc hl	 ; go past current buffer pointer 
9eb7			;	;inc hl 
9eb7			;	;inc hl   ; and past if loop flag 
9eb7			;		; TODO Need to set flag  
9eb7			; 
9eb7			;	 
9eb7			;	 
9eb7			;	ex de,hl	; malloc is dest 
9eb7			;	ld hl, (os_tok_len) 
9eb7			;;	pop bc 
9eb7			;	ld c, l                
9eb7			;	ld b,0 
9eb7			;	ld hl, (os_tok_ptr) 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKT" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	; do str cpy 
9eb7			; 
9eb7			;	ldir      ; copy byte in hl to de 
9eb7			; 
9eb7			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			; 
9eb7			;			DMARK "TKY" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			;	;ld a,0 
9eb7			;	;ld a,FORTH_END_BUFFER 
9eb7			;	ex de, hl 
9eb7			;	;dec hl			 ; go back over the space delim at the end of word 
9eb7			;	;ld (hl),a 
9eb7			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9eb7			;	ld a,FORTH_END_BUFFER 
9eb7			;	ld (hl),a 
9eb7			;	inc hl 
9eb7			;	ld a,FORTH_END_BUFFER 
9eb7			;	ld (hl),a 
9eb7			; 
9eb7			;	; init the malloc area data 
9eb7			;	; set pc for in current area 
9eb7			;	;ld hl, (os_tok_malloc) 
9eb7			;	;inc hl 
9eb7			;	;inc hl 
9eb7			;	;inc hl 
9eb7			;	;ex de,hl 
9eb7			;	;ld hl, (os_tok_malloc) 
9eb7			;	;ld (hl),e 
9eb7			;	;inc hl 
9eb7			;	;ld (hl),d 
9eb7			; 
9eb7			; 
9eb7			;	ld hl,(os_tok_malloc) 
9eb7			;if DEBUG_FORTH_PARSE_KEY 
9eb7			;			DMARK "TKU" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	ret 
9eb7			 
9eb7			forthexec: 
9eb7			 
9eb7			; line exec: 
9eb7			; forth parser 
9eb7			 
9eb7			; 
9eb7			;       get current exec line on rsp 
9eb7			 
9eb7				FORTH_RSP_TOS 
9eb7 cd 2c 9a			call macro_forth_rsp_tos 
9eba				endm 
# End of macro FORTH_RSP_TOS
9eba			 
9eba			;       restore current pc - hl points to malloc of data 
9eba			 
9eba				;ld e, (hl) 
9eba				;inc hl 
9eba				;ld d, (hl) 
9eba				;ex de,hl 
9eba			 
9eba			 
9eba			exec1: 
9eba 22 c2 e5			ld (os_tok_ptr), hl 
9ebd			 
9ebd				; copy our PC to working vars  
9ebd 22 40 ea			ld (cli_ptr), hl 
9ec0 22 3e ea			ld (cli_origptr), hl 
9ec3			 
9ec3 7e				ld a,(hl) 
9ec4 fe 7f			cp FORTH_END_BUFFER 
9ec6 c8				ret z 
9ec7			 
9ec7				; skip any nulls 
9ec7			 
9ec7 fe 00			cp 0 
9ec9 20 03			jr nz, .execword 
9ecb 23				inc hl 
9ecc 18 ec			jr exec1 
9ece			 
9ece			 
9ece			.execword: 
9ece			 
9ece			 
9ece			 
9ece			if DEBUG_FORTH_PARSE_KEY 
9ece						DMARK "KYQ" 
9ece				CALLMONITOR 
9ece			endif 
9ece			;       while at start of word: 
9ece			; get start of dict (in user area first) 
9ece			 
9ece 21 32 dd		ld hl, baseram 
9ed1			;ld hl, sysdict 
9ed1 22 42 ea		ld (cli_nextword),hl 
9ed4			;           match word at pc 
9ed4			;           exec word 
9ed4			;           or push to dsp 
9ed4			;           forward to next token 
9ed4			;           if line term pop rsp and exit 
9ed4			;        
9ed4			 
9ed4			if DEBUG_FORTH_PARSE_KEY 
9ed4						DMARK "KYq" 
9ed4				CALLMONITOR 
9ed4			endif 
9ed4			 
9ed4			; 
9ed4			; word comp 
9ed4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ed4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ed4			;    move to start of word  
9ed4			;    compare word to cli_token 
9ed4			 
9ed4			.execpnword:	; HL at start of a word in the dictionary to check 
9ed4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ed4			;	ld (cli_ptr), hl 
9ed4			 
9ed4 2a 42 ea			ld hl,(cli_nextword) 
9ed7			 
9ed7 cd 7a 9f			call forth_tok_next 
9eda			; tok next start here 
9eda			;	; TODO skip compiled symbol for now 
9eda			;	inc hl 
9eda			; 
9eda			;	; save pointer to next word 
9eda			; 
9eda			;	; hl now points to the address of the next word pointer  
9eda			;	ld e, (hl) 
9eda			;	inc hl 
9eda			;	ld d, (hl) 
9eda			;	inc l 
9eda			; 
9eda			;	ex de,hl 
9eda			;if DEBUG_FORTH_PARSE_NEXTWORD 
9eda			;	push bc 
9eda			;	ld bc, (cli_nextword) 
9eda			;			DMARK "NXW" 
9eda			;	CALLMONITOR 
9eda			;	pop bc 
9eda			;endif 
9eda			; tok next end here 
9eda 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9edd eb				ex de, hl 
9ede			 
9ede			 
9ede				; save the pointer of the current token - 1 to check against 
9ede				 
9ede 22 46 ea			ld (cli_token), hl   
9ee1				; TODO maybe remove below save if no debug 
9ee1				; save token string ptr for any debug later 
9ee1 23				inc hl  
9ee2 22 48 ea			ld (cli_origtoken), hl 
9ee5 2b				dec hl 
9ee6				; save pointer to the start of the next dictionay word 
9ee6 7e				ld a,(hl)   ; get string length 
9ee7 47				ld b,a 
9ee8			.execpnwordinc:  
9ee8 23				inc hl 
9ee9 10 fd			djnz .execpnwordinc 
9eeb 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9eee			 
9eee				; now check the word token against the string being parsed 
9eee			 
9eee 2a 46 ea			ld hl,(cli_token) 
9ef1 23				inc hl     ; skip string length (use zero term instead to end) 
9ef2 22 46 ea			ld (cli_token), hl 
9ef5			 
9ef5			if DEBUG_FORTH_PARSE_KEY 
9ef5						DMARK "KY2" 
9ef5			endif 
9ef5			if DEBUG_FORTH_PARSE_EXEC 
9ef5				; see if disabled 
9ef5			 
9ef5			;	ld a, (os_view_disable) 
9ef5			;	cp '*' 
9ef5				ld a, (debug_vector) 
9ef5				cp $c9   ; RET  
9ef5				jr z, .skip 
9ef5			 
9ef5				push hl 
9ef5				push hl 
9ef5				call clear_display 
9ef5				ld de, .compword 
9ef5				ld a, display_row_1 
9ef5				call str_at_display 
9ef5				pop de 
9ef5				ld a, display_row_2 
9ef5				call str_at_display 
9ef5				ld hl,(cli_ptr) 
9ef5				ld a,(hl) 
9ef5			        ld hl, os_word_scratch 
9ef5				ld (hl),a 
9ef5				ld a,0 
9ef5				inc hl 
9ef5				ld (hl),a 	 
9ef5				ld de, os_word_scratch 
9ef5				ld a, display_row_2+10 
9ef5				call str_at_display 
9ef5				call update_display 
9ef5				ld a, 100 
9ef5				call aDelayInMS 
9ef5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ef5				call delay250ms 
9ef5				endif 
9ef5				pop hl 
9ef5			.skip:  
9ef5			endif	 
9ef5			.execpnchar:    ; compare char between token and string to parse 
9ef5			 
9ef5			if DEBUG_FORTH_PARSE_KEY 
9ef5						DMARK "Ky3" 
9ef5			endif 
9ef5			if DEBUG_FORTH_PARSE_EXEC 
9ef5				; see if disabled 
9ef5			 
9ef5			;	ld a, (os_view_disable) 
9ef5			;	cp '*' 
9ef5				ld a, (debug_vector) 
9ef5				cp $C9  ; RET 
9ef5				jr z, .skip2 
9ef5			 
9ef5			;	call clear_display 
9ef5			ld hl,(cli_token) 
9ef5			ld a,(hl) 
9ef5			ld (os_word_scratch),a 
9ef5				ld hl,(cli_ptr) 
9ef5			ld a,(hl) 
9ef5				ld (os_word_scratch+1),a 
9ef5				ld a,0 
9ef5				ld (os_word_scratch+2),a 
9ef5				ld de,os_word_scratch 
9ef5				ld a,display_row_4 
9ef5				call str_at_display 
9ef5				call update_display 
9ef5			.skip2:  
9ef5			endif 
9ef5 2a 46 ea			ld hl,(cli_token) 
9ef8 7e				ld a, (hl)	 ; char in word token 
9ef9 23				inc hl 		; move to next char 
9efa 22 46 ea			ld (cli_token), hl ; and save it 
9efd 47				ld b,a 
9efe			 
9efe 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f01 7e				ld a,(hl) 
9f02 23				inc hl 
9f03 22 40 ea			ld (cli_ptr), hl		; move to next char 
9f06 cd 44 90			call toUpper 		; make sure the input string matches case 
9f09			 
9f09			if DEBUG_FORTH_PARSE 
9f09			endif 
9f09			 
9f09				; input stream end of token is a space so get rid of it 
9f09			 
9f09			;	cp ' ' 
9f09			;	jr nz, .pnskipspace 
9f09			; 
9f09			;	ld a, 0		; make same term as word token term 
9f09			; 
9f09			;.pnskipspace: 
9f09			 
9f09			if DEBUG_FORTH_PARSE_KEY 
9f09						DMARK "KY7" 
9f09			endif 
9f09 b8				cp b 
9f0a c2 20 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f0d				 
9f0d			;    if same 
9f0d			;       scan for string terms 0 for token and 32 for input 
9f0d			 
9f0d				 
9f0d			if DEBUG_FORTH_PARSE_KEY 
9f0d						DMARK "KY8" 
9f0d			endif 
9f0d			 
9f0d 80				add b			 
9f0e fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f10							; TODO need to make sure last word in zero term string is accounted for 
9f10 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9f12			 
9f12			 
9f12				; at end of both strings so both are exact match 
9f12			 
9f12			;       skip ptr for next word 
9f12			 
9f12 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9f15 23				inc hl			 ; at next char 
9f16 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f19 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f1c				 
9f1c				 
9f1c			if DEBUG_FORTH_PARSE_KEY 
9f1c						DMARK "KY3" 
9f1c			endif 
9f1c			 
9f1c			 
9f1c			 
9f1c			;       exec code block 
9f1c			if DEBUG_FORTH_JP 
9f1c				call clear_display 
9f1c				call update_display 
9f1c				call delay1s 
9f1c				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f1c				ld a,h 
9f1c				ld hl, os_word_scratch 
9f1c				call hexout 
9f1c				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f1c				ld a,l 
9f1c				ld hl, os_word_scratch+2 
9f1c				call hexout 
9f1c				ld hl, os_word_scratch+4 
9f1c				ld a,0 
9f1c				ld (hl),a 
9f1c				ld de,os_word_scratch 
9f1c				call str_at_display 
9f1c					ld a, display_row_2 
9f1c					call str_at_display 
9f1c				ld de, (cli_origtoken) 
9f1c				ld a, display_row_1+10 
9f1c					call str_at_display 
9f1c			 
9f1c				ld a,display_row_1 
9f1c				ld de, .foundword 
9f1c				ld a, display_row_3 
9f1c				call str_at_display 
9f1c				call update_display 
9f1c				call delay1s 
9f1c				call delay1s 
9f1c				call delay1s 
9f1c			endif 
9f1c			 
9f1c			if DEBUG_FORTH_PARSE_KEY 
9f1c						DMARK "KYj" 
9f1c			endif 
9f1c				; TODO save the word pointer in this exec 
9f1c			 
9f1c 2a 44 ea			ld hl,(cli_execword) 
9f1f e9				jp (hl) 
9f20			 
9f20			 
9f20			;    if not same 
9f20			;	scan for zero term 
9f20			;	get ptr for next word 
9f20			;	goto word comp 
9f20			 
9f20			.execpnskipword:	; get pointer to next word 
9f20 2a 42 ea			ld hl,(cli_nextword) 
9f23			 
9f23 7e				ld a,(hl) 
9f24 fe 00			cp WORD_SYS_END 
9f26			;	cp 0 
9f26 28 09			jr z, .execendofdict			 ; at end of words 
9f28			 
9f28			if DEBUG_FORTH_PARSE_KEY 
9f28						DMARK "KY4" 
9f28			endif 
9f28			if DEBUG_FORTH_PARSE_EXEC 
9f28			 
9f28				; see if disabled 
9f28			 
9f28			;	ld a, (os_view_disable) 
9f28			;	cp '*' 
9f28				ld a,(debug_vector) 
9f28				cp $c9   ; RET 
9f28				jr z, .noskip 
9f28			 
9f28			 
9f28				ld de, .nowordfound 
9f28				ld a, display_row_3 
9f28				call str_at_display 
9f28				call update_display 
9f28				ld a, 100 
9f28				call aDelayInMS 
9f28				 
9f28				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f28					call delay250ms 
9f28				endif 
9f28			.noskip:  
9f28			 
9f28			endif	 
9f28			 
9f28 2a 3e ea			ld hl,(cli_origptr) 
9f2b 22 40 ea			ld (cli_ptr),hl 
9f2e			 
9f2e			if DEBUG_FORTH_PARSE_KEY 
9f2e						DMARK "KY5" 
9f2e			endif 
9f2e c3 d4 9e			jp .execpnword			; else go to next word 
9f31			 
9f31			.execendofdict:  
9f31			 
9f31			if DEBUG_FORTH_PARSE_KEY 
9f31						DMARK "KYe" 
9f31			endif 
9f31			if DEBUG_FORTH_PARSE_EXEC 
9f31				; see if disabled 
9f31			 
9f31			;	ld a, (os_view_disable) 
9f31			;	cp '*' 
9f31				ld a,(debug_vector) 
9f31				cp $c9   ; ret 
9f31				jr z, .ispskip 
9f31			 
9f31				call clear_display 
9f31				call update_display 
9f31				call delay1s 
9f31				ld de, (cli_origptr) 
9f31				ld a, display_row_1 
9f31				call str_at_display 
9f31				 
9f31				ld de, .enddict 
9f31				ld a, display_row_3 
9f31				call str_at_display 
9f31				call update_display 
9f31				ld a, 100 
9f31				call aDelayInMS 
9f31				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f31				call delay1s 
9f31				call delay1s 
9f31				call delay1s 
9f31				endif 
9f31			.ispskip:  
9f31				 
9f31			endif	 
9f31			 
9f31			 
9f31			 
9f31				; if the word is not a keyword then must be a literal so push it to stack 
9f31			 
9f31			; push token to stack to end of word 
9f31			 
9f31				STACKFRAME ON $1efe $2f9f 
9f31				if DEBUG_STACK_IMB 
9f31					if ON 
9f31						exx 
9f31						ld de, $1efe 
9f31						ld a, d 
9f31						ld hl, curframe 
9f31						call hexout 
9f31						ld a, e 
9f31						ld hl, curframe+2 
9f31						call hexout 
9f31						ld hl, $1efe 
9f31						push hl 
9f31						ld hl, $2f9f 
9f31						push hl 
9f31						exx 
9f31					endif 
9f31				endif 
9f31			endm 
# End of macro STACKFRAME
9f31			 
9f31 2a c2 e5		ld hl,(os_tok_ptr) 
9f34 cd d7 9b		call forth_apush 
9f37			 
9f37				STACKFRAMECHK ON $1efe $2f9f 
9f37				if DEBUG_STACK_IMB 
9f37					if ON 
9f37						exx 
9f37						ld hl, $2f9f 
9f37						pop de   ; $2f9f 
9f37						call cmp16 
9f37						jr nz, .spnosame 
9f37						ld hl, $1efe 
9f37						pop de   ; $1efe 
9f37						call cmp16 
9f37						jr z, .spfrsame 
9f37						.spnosame: call showsperror 
9f37						.spfrsame: nop 
9f37						exx 
9f37					endif 
9f37				endif 
9f37			endm 
# End of macro STACKFRAMECHK
9f37			 
9f37			execnext: 
9f37			 
9f37			if DEBUG_FORTH_PARSE_KEY 
9f37						DMARK "KY>" 
9f37			endif 
9f37			; move past token to next word 
9f37			 
9f37 2a c2 e5		ld hl, (os_tok_ptr) 
9f3a 3e 00		ld a, 0 
9f3c 01 ff 00		ld bc, 255     ; input buffer size 
9f3f ed b1		cpir 
9f41			 
9f41			if DEBUG_FORTH_PARSE_KEY 
9f41						DMARK "KY!" 
9f41				CALLMONITOR 
9f41			endif	 
9f41			; TODO this might place hl on the null, so will need to forward on??? 
9f41			;inc hl   ; see if this gets onto the next item 
9f41			 
9f41			 
9f41			; TODO pass a pointer to the buffer to push 
9f41			; TODO call function to push 
9f41			 
9f41			; look for end of input 
9f41			 
9f41			;inc hl 
9f41			;ld a,(hl) 
9f41			;cp FORTH_END_BUFFER 
9f41			;ret z 
9f41			 
9f41			 
9f41 c3 ba 9e		jp exec1 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			findnexttok: 
9f44			 
9f44				; hl is pointer to move 
9f44				; de is the token to locate 
9f44			 
9f44					if DEBUG_FORTH 
9f44						DMARK "NTK" 
9f44						CALLMONITOR 
9f44					endif 
9f44 d5				push de 
9f45			 
9f45			.fnt1:	 
9f45				; find first char of token to locate 
9f45			 
9f45 1a				ld a, (de) 
9f46 4f				ld c,a 
9f47 7e				ld a,(hl) 
9f48 cd 44 90			call toUpper 
9f4b					if DEBUG_FORTH 
9f4b						DMARK "NT1" 
9f4b						CALLMONITOR 
9f4b					endif 
9f4b b9				cp c 
9f4c			 
9f4c 28 03			jr z, .fnt2cmpmorefirst	 
9f4e			 
9f4e				; first char not found move to next char 
9f4e			 
9f4e 23				inc hl 
9f4f 18 f4			jr .fnt1 
9f51			 
9f51			.fnt2cmpmorefirst:	 
9f51				; first char of token found.  
9f51			 
9f51 e5				push hl     ; save start of token just in case it is the right one 
9f52 d9				exx 
9f53 e1				pop hl        ; save it to hl' 
9f54 d9				exx 
9f55			 
9f55			 
9f55			.fnt2cmpmore:	 
9f55				; compare the rest 
9f55				 
9f55 23				inc hl 
9f56 13				inc de 
9f57				 
9f57 1a				ld a, (de) 
9f58 4f				ld c,a 
9f59 7e				ld a,(hl) 
9f5a cd 44 90			call toUpper 
9f5d			 
9f5d					if DEBUG_FORTH 
9f5d						DMARK "NT2" 
9f5d						CALLMONITOR 
9f5d					endif 
9f5d				; c has the token to find char 
9f5d				; a has the mem to scan char 
9f5d			 
9f5d b9				cp c 
9f5e 28 04			jr z,.fntmatch1 
9f60			 
9f60				; they are not the same 
9f60			 
9f60					if DEBUG_FORTH 
9f60						DMARK "NT3" 
9f60						CALLMONITOR 
9f60					endif 
9f60 d1				pop de	; reset de token to look for 
9f61 d5				push de 
9f62 18 e1			jr .fnt1 
9f64				 
9f64			.fntmatch1: 
9f64			 
9f64				; is the same char a null which means we might have a full hit? 
9f64					if DEBUG_FORTH 
9f64						DMARK "NT4" 
9f64						CALLMONITOR 
9f64					endif 
9f64			 
9f64 fe 00			cp 0 
9f66 28 0b			jr z, .fntmatchyes 
9f68			 
9f68				; are we at the end of the token to find? 
9f68			 
9f68					if DEBUG_FORTH 
9f68						DMARK "NT5" 
9f68						CALLMONITOR 
9f68					endif 
9f68 3e 00			ld a, 0 
9f6a b9				cp c 
9f6b			 
9f6b c2 55 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9f6e			 
9f6e					if DEBUG_FORTH 
9f6e						DMARK "NT6" 
9f6e						CALLMONITOR 
9f6e					endif 
9f6e				; token to find is exhusted but no match to stream 
9f6e			 
9f6e				; restore tok pointer and continue on 
9f6e d1				pop de 
9f6f d5				push de 
9f70 c3 45 9f			jp .fnt1 
9f73			 
9f73			 
9f73			.fntmatchyes: 
9f73			 
9f73				; hl now contains the end of the found token 
9f73			 
9f73				; get rid of saved token pointer to find 
9f73			 
9f73 d1				pop de 
9f74			 
9f74					if DEBUG_FORTH 
9f74						DMARK "NT9" 
9f74						CALLMONITOR 
9f74					endif 
9f74			 
9f74				; hl will be on the null term so forward on 
9f74			 
9f74				; get back the saved start of the token 
9f74			 
9f74 d9				exx 
9f75 e5				push hl     ; save start of token just in case it is the right one 
9f76 d9				exx 
9f77 e1				pop hl        ; save it to hl 
9f78			 
9f78 c9				ret 
9f79			 
9f79			 
9f79			; LIST needs to find a specific token   
9f79			; FORGET needs to find a spefici token 
9f79			 
9f79			; SAVE needs to find all tokens by flag 
9f79			; WORDS just needs to scan through all  by flag 
9f79			; UWORDS needs to scan through all by flag 
9f79			 
9f79			 
9f79			; given hl as pointer to start of dict look up string 
9f79			; return hl as pointer to start of word block 
9f79			; or 0 if not found 
9f79			 
9f79			forth_find_tok: 
9f79 c9				ret 
9f7a			 
9f7a			; given hl as pointer to dict structure 
9f7a			; move to the next dict block structure 
9f7a			 
9f7a			forth_tok_next: 
9f7a				; hl now points to the address of the next word pointer  
9f7a				; TODO skip compiled symbol for now 
9f7a			;	push de 
9f7a 23				inc hl 
9f7b 5e				ld e, (hl) 
9f7c 23				inc hl 
9f7d 56				ld d, (hl) 
9f7e 23				inc hl 
9f7f			 
9f7f eb				ex de,hl 
9f80			if DEBUG_FORTH_PARSE_NEXTWORD 
9f80				push bc 
9f80				ld bc, (cli_nextword) 
9f80						DMARK "NXW" 
9f80				CALLMONITOR 
9f80				pop bc 
9f80			endif 
9f80			;	pop de	 
9f80 c9				ret 
9f81			 
9f81			 
9f81			 
9f81			; eof 
# End of file forth_parserv5.asm
9f81				include "forth_wordsv4.asm" 
9f81			 
9f81			; the core word dictionary v4 
9f81			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9f81			 
9f81			; this is a linked list for each of the system words used 
9f81			; user defined words will follow the same format but will be in ram 
9f81			 
9f81			 
9f81			; 
9f81			; 
9f81			; define linked list: 
9f81			; 
9f81			; 1. compiled byte op code 
9f81			; 2. len of text word 
9f81			; 3. text word 
9f81			; 4. ptr to next dictionary word 
9f81			; 5. asm, calls etc for the word 
9f81			; 
9f81			;  if 1 == 0 then last word in dict  
9f81			;   
9f81			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9f81			;  
9f81			;  
9f81			; create basic standard set of words 
9f81			; 
9f81			;  
9f81			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9f81			; 2DUP 2DROP 2SWAP  
9f81			; @ C@ - get byte  
9f81			; ! C! - store byte 
9f81			; 0< true if less than zero 
9f81			; 0= true if zero 
9f81			; < >  
9f81			; = true if same 
9f81			; variables 
9f81			 
9f81			 
9f81			; Hardware specific words I may need 
9f81			; 
9f81			; IN OUT  
9f81			; calls to key util functions 
9f81			; calls to hardward abstraction stuff 
9f81			; easy control of frame buffers and lcd i/o 
9f81			; keyboard  
9f81			 
9f81			 
9f81			;DICT: macro 
9f81			; op_code, len, word, next 
9f81			;    word: 
9f81			;    db op_code 
9f81			;    ds word zero term 
9f81			;    dw next 
9f81			;    endm 
9f81			 
9f81			 
9f81			 
9f81			 
9f81			; op code 1 is a flag for user define words which are to be handled differently 
9f81			 
9f81			 
9f81			; 
9f81			; 
9f81			;    TODO on entry to a word this should be the expected environment 
9f81			;    hl - tos value if number then held, if string this is the ptr 
9f81			;    de -  
9f81			 
9f81			 
9f81			; opcode ranges 
9f81			; 0 - end of word dict 
9f81			; 255 - user define words 
9f81			 
9f81			sysdict: 
9f81			include "forth_opcodes.asm" 
9f81			; op codes for forth keywords 
9f81			; free to use code 0  
9f81				OPCODE_HEAP: equ  1 
9f81				OPCODE_EXEC: equ 2 
9f81				OPCODE_DUP: equ 3 
9f81				OPCODE_SWAP: equ 4 
9f81				OPCODE_COLN: equ 5 
9f81				OPCODE_SCOLN: equ 6 
9f81				OPCODE_DROP: equ 7 
9f81				OPCODE_DUP2: equ 8 
9f81				OPCODE_DROP2: equ 9 
9f81				OPCODE_SWAP2: equ 10 
9f81				OPCODE_AT: equ 11 
9f81				OPCODE_CAT: equ 12 
9f81				OPCODE_BANG: equ 13 
9f81				OPCODE_CBANG: equ 14 
9f81				OPCODE_SCALL: equ 15 
9f81				OPCODE_DEPTH: equ 16 
9f81				OPCODE_OVER: equ 17 
9f81				OPCODE_PAUSE: equ 18 
9f81				OPCODE_PAUSES: equ 19 
9f81				OPCODE_ROT: equ 20 
9f81			;free to reuse	OPCODE_WORDS: equ 21 
9f81			        OPCODE_NOT: equ 21 
9f81				OPCODE_UWORDS: equ 22 
9f81				OPCODE_BP: equ 23 
9f81				OPCODE_MONITOR: equ 24  
9f81				OPCODE_MALLOC: equ 25 
9f81				OPCODE_FREE: equ 26 
9f81				OPCODE_LIST: equ 27 
9f81				OPCODE_FORGET: equ 28 
9f81				OPCODE_NOP: equ 29 
9f81				OPCODE_COMO: equ 30 
9f81				OPCODE_COMC: equ 31 
9f81			;free to reuse	OPCODE_ENDCORE: equ 32 
9f81				OPCODE_AFTERSOUND: equ 33 
9f81				OPCODE_GP2: equ 34 
9f81				OPCODE_GP3: equ 35 
9f81				OPCODE_GP4: equ 36 
9f81				OPCODE_SIN: equ 37 
9f81				OPCODE_SOUT: equ 38 
9f81				OPCODE_SPIO: equ 39 
9f81				OPCODE_SPICEH: equ 40 
9f81				OPCODE_SPIOb: equ 41 
9f81				OPCODE_SPII: equ 42 
9f81				OPCODE_SESEL: equ 43 
9f81				OPCODE_CARTDEV: equ 44 
9f81			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9f81				OPCODE_FB: equ 46 
9f81				OPCODE_EMIT: equ 47 
9f81				OPCODE_DOTH: equ 48 
9f81				OPCODE_DOTF: equ 49 
9f81				OPCODE_DOT: equ 50 
9f81				OPCODE_CLS: equ 51 
9f81				OPCODE_DRAW: equ 52 
9f81				OPCODE_DUMP: equ 53 
9f81				OPCODE_CDUMP: equ 54 
9f81				OPCODE_DAT: equ 55 
9f81				OPCODE_HOME: equ 56 
9f81				OPCODE_SPACE: equ 57 
9f81				OPCODE_SPACES: equ 58 
9f81				OPCODE_SCROLL: equ 59 
9f81				OPCODE_ATQ: equ 60 
9f81				OPCODE_AUTODSP: equ 61 
9f81				OPCODE_MENU: equ 62 
9f81			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9f81				OPCODE_THEN: equ 64 
9f81				OPCODE_ELSE: equ 65 
9f81				OPCODE_DO: equ 66 
9f81				OPCODE_LOOP: equ 67 
9f81				OPCODE_I: equ 68 
9f81				OPCODE_DLOOP: equ 69  
9f81				OPCODE_REPEAT: equ 70  
9f81				OPCODE_UNTIL: equ 71 
9f81				OPCODE_ENDFLOW: equ 72 
9f81				OPCODE_WAITK: equ 73 
9f81				OPCODE_ACCEPT: equ 74 
9f81				OPCODE_EDIT: equ 75 
9f81			;free to reuse	OPCODE_ENDKEY: equ 76 
9f81				OPCODE_LZERO: equ 77 
9f81				OPCODE_TZERO: equ 78 
9f81				OPCODE_LESS: equ 79 
9f81				OPCODE_GT: equ 80 
9f81				OPCODE_EQUAL: equ 81  
9f81			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9f81				OPCODE_NEG: equ 83 
9f81				OPCODE_DIV: equ 84 
9f81				OPCODE_MUL: equ 85 
9f81				OPCODE_MIN: equ 86 
9f81				OPCODE_MAX: equ 87 
9f81				OPCODE_RND16: equ 88 
9f81				OPCODE_RND8: equ 89 
9f81				OPCODE_RND: equ 90 
9f81			;free to reuse	OPCODE_ENDMATHS: equ 91  
9f81				OPCODE_BYNAME: equ 92 
9f81				OPCODE_DIR: equ 93 
9f81				OPCODE_SAVE: equ 94 
9f81				OPCODE_LOAD: equ 95 
9f81				OPCODE_BSAVE: equ 96 
9f81				OPCODE_BLOAD: equ 97 
9f81				OPCODE_SEO: equ 98  
9f81				OPCODE_SEI: equ 99 
9f81				OPCODE_SFREE: equ 100 
9f81				OPCODE_SIZE: equ 101 
9f81				OPCODE_CREATE: equ 102 
9f81				OPCODE_APPEND: equ 103 
9f81				OPCODE_SDEL: equ 104 
9f81				OPCODE_OPEN: equ 105 
9f81				OPCODE_READ: equ 106 
9f81				OPCODE_EOF: equ 106 
9f81				OPCODE_FORMAT: equ 107 
9f81				OPCODE_LABEL: equ 108 
9f81				OPCODE_LABELS: equ 109 
9f81			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9f81				OPCODE_UPPER: equ 111 
9f81				OPCODE_LOWER: equ 112 
9f81				OPCODE_SUBSTR: equ 113 
9f81				OPCODE_LEFT: equ 114 
9f81				OPCODE_RIGHT: equ 115 
9f81				OPCODE_STR2NUM: equ 116 
9f81				OPCODE_NUM2STR: equ 117 
9f81				OPCODE_CONCAT: equ 118 
9f81				OPCODE_FIND: equ 119 
9f81				OPCODE_LEN: equ 120 
9f81				OPCODE_CHAR: equ 121 
9f81			; free to reuse	OPCODE_STRLEN: equ 122 
9f81			; free to reuse	OPCODE_ENDSTR: equ 123 
9f81				OPCODE_V0S: equ 124 
9f81				OPCODE_V0Q: equ 125 
9f81				OPCODE_V1S: equ 126 
9f81				OPCODE_V1Q: equ 127 
9f81				OPCODE_V2S: equ 128 
9f81				OPCODE_V2Q: equ 129 
9f81				OPCODE_V3S: equ 130 
9f81				OPCODE_V3Q: equ 131 
9f81			;free to reuse	OPCODE_END: equ 132 
9f81				OPCODE_ZDUP: equ 133 
9f81			 
9f81			; eof 
# End of file forth_opcodes.asm
9f81			 
9f81			include "forth_words_core.asm" 
9f81			 
9f81			; | ## Core Words 
9f81			 
9f81			;if MALLOC_4 
9f81			 
9f81			.HEAP: 
9f81			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9f81 15				db WORD_SYS_CORE+OPCODE_HEAP             
9f82 c0 9f			dw .EXEC            
9f84 05				db 4 + 1 
9f85 .. 00			db "HEAP",0              
9f8a				endm 
# End of macro CWHEAD
9f8a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9f8a			; | | u1 - Current number of bytes in the heap 
9f8a			; | | u2 - Remaining bytes left on the heap 
9f8a			; | |  
9f8a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9f8a			 
9f8a			 
9f8a				if DEBUG_FORTH_WORDS_KEY 
9f8a					DMARK "HEP" 
9f8a f5				push af  
9f8b 3a 9f 9f			ld a, (.dmark)  
9f8e 32 6b ee			ld (debug_mark),a  
9f91 3a a0 9f			ld a, (.dmark+1)  
9f94 32 6c ee			ld (debug_mark+1),a  
9f97 3a a1 9f			ld a, (.dmark+2)  
9f9a 32 6d ee			ld (debug_mark+2),a  
9f9d 18 03			jr .pastdmark  
9f9f ..			.dmark: db "HEP"  
9fa2 f1			.pastdmark: pop af  
9fa3			endm  
# End of macro DMARK
9fa3					CALLMONITOR 
9fa3 cd 6f ee			call debug_vector  
9fa6				endm  
# End of macro CALLMONITOR
9fa6				endif 
9fa6 2a 3c dd			ld hl, (free_list )      
9fa9 11 41 dd			ld de, heap_start 
9fac			 
9fac ed 52			sbc hl, de  
9fae			 
9fae cd 6e 9a			call forth_push_numhl 
9fb1			 
9fb1			 
9fb1 ed 5b 3c dd		ld de, (free_list )      
9fb5 21 9c e2			ld hl, heap_end 
9fb8			 
9fb8 ed 52			sbc hl, de 
9fba			 
9fba cd 6e 9a			call forth_push_numhl 
9fbd				 
9fbd			 
9fbd				 
9fbd			 
9fbd			 
9fbd			 
9fbd				NEXTW 
9fbd c3 29 9e			jp macro_next 
9fc0				endm 
# End of macro NEXTW
9fc0			;endif 
9fc0			 
9fc0			.EXEC: 
9fc0			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9fc0			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9fc0			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9fc0			;; > > 
9fc0			;; > >   
9fc0			;	STACKFRAME OFF $5efe $5f9f 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS_KEY 
9fc0			;			DMARK "EXE" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			; 
9fc0			;	FORTH_DSP_POP 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX1" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;;	ld e,(hl) 
9fc0			;;	inc hl 
9fc0			;;	ld d,(hl) 
9fc0			;;	ex de,hl 
9fc0			; 
9fc0			;;		if DEBUG_FORTH_WORDS 
9fc0			;;			DMARK "EX2" 
9fc0			;;			CALLMONITOR 
9fc0			;;		endif 
9fc0			;	push hl 
9fc0			; 
9fc0			;	;ld a, 0 
9fc0			;	;ld a, FORTH_END_BUFFER 
9fc0			;	call strlenz 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	inc hl   ; include term 
9fc0			;	inc hl   ; include term 
9fc0			;	ld b,0 
9fc0			;	ld c,l 
9fc0			;	pop hl 
9fc0			;	ld de, execscratch 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX3" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ldir 
9fc0			; 
9fc0			; 
9fc0			;	ld hl, execscratch 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXe" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	call forthparse 
9fc0			;	call forthexec 
9fc0			;;	call forthexec_cleanup 
9fc0			;;	call forthparse 
9fc0			;;	call forthexec 
9fc0			; 
9fc0			;	STACKFRAMECHK OFF $5efe $5f9f 
9fc0			; 
9fc0			;	; an immediate word so no need to process any more words 
9fc0			;	ret 
9fc0			;	NEXTW 
9fc0			 
9fc0			; dead code - old version  
9fc0			;	FORTH_RSP_NEXT 
9fc0			 
9fc0			;  
9fc0			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9fc0			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9fc0			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9fc0			;	push hl 
9fc0			;	push de 
9fc0			;	push bc 
9fc0			; 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS_KEY 
9fc0			;			DMARK "EXR" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			; 
9fc0			; 
9fc0			;	;v5 FORTH_DSP_VALUE 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			; 
9fc0			;	; TODO do string type checks 
9fc0			; 
9fc0			;;v5	inc hl   ; skip type 
9fc0			; 
9fc0			;	push hl  ; source code  
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX1" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ld a, 0 
9fc0			;	call strlent 
9fc0			; 
9fc0			;	inc hl 
9fc0			;	inc hl 
9fc0			;	inc hl 
9fc0			;	inc hl 
9fc0			; 
9fc0			;	push hl    ; size 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX2" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	call malloc 
9fc0			; 
9fc0			;	ex de, hl    ; de now contains malloc area 
9fc0			;	pop bc   	; get byte count 
9fc0			;	pop hl      ; get string to copy 
9fc0			; 
9fc0			;	push de     ; save malloc for free later 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX3" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ldir       ; duplicate string 
9fc0			; 
9fc0			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9fc0			;	 
9fc0			;	; TODO fix the parse would be better than this...  
9fc0			;	ex de, hl 
9fc0			;	dec hl 
9fc0			;	ld a, 0 
9fc0			;	ld (hl), a 
9fc0			;	dec hl 
9fc0			;	ld a, ' ' 
9fc0			;	ld (hl), a 
9fc0			;	dec hl 
9fc0			;	ld (hl), a 
9fc0			; 
9fc0			;	dec hl 
9fc0			;	ld (hl), a 
9fc0			; 
9fc0			; 
9fc0			;	FORTH_DSP_POP  
9fc0			; 
9fc0			;	pop hl     
9fc0			;	push hl    ; save malloc area 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX4" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	call forthparse 
9fc0			;	call forthexec 
9fc0			;	 
9fc0			;	pop hl 
9fc0			;	if DEBUG_FORTH_WORDS 
9fc0			;		DMARK "EX5" 
9fc0			;		CALLMONITOR 
9fc0			;	endif 
9fc0			; 
9fc0			;	if FORTH_ENABLE_FREE 
9fc0			;	call free 
9fc0			;	endif 
9fc0			; 
9fc0			;	if DEBUG_FORTH_WORDS 
9fc0			;		DMARK "EX6" 
9fc0			;		CALLMONITOR 
9fc0			;	endif 
9fc0			; 
9fc0			;	pop bc 
9fc0			;	pop de 
9fc0			;	pop hl 
9fc0			;;	FORTH_RSP_POP	  
9fc0			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9fc0			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9fc0			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9fc0			; 
9fc0			;	if DEBUG_FORTH_WORDS 
9fc0			;		DMARK "EX7" 
9fc0			;		CALLMONITOR 
9fc0			;	endif 
9fc0			;	NEXTW 
9fc0			 
9fc0			;.STKEXEC: 
9fc0			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9fc0			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9fc0			; 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS_KEY 
9fc0			;			DMARK "STX" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			; 
9fc0			;	ld (store_tmp1), hl    ; count 
9fc0			; 
9fc0			;	FORTH_DSP_POP 
9fc0			;.stkexec1: 
9fc0			;	ld hl, (store_tmp1)   ; count 
9fc0			;	ld a, 0 
9fc0			;	cp l 
9fc0			;	ret z 
9fc0			; 
9fc0			;	dec hl 
9fc0			;	ld (store_tmp1), hl    ; count 
9fc0			;	 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			;	push hl 
9fc0			;	 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXp" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	FORTH_DSP_POP 
9fc0			; 
9fc0			;	call strlenz 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	ld b,0 
9fc0			;	ld c,l 
9fc0			;	pop hl 
9fc0			;	ld de, execscratch 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX3" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ldir 
9fc0			; 
9fc0			; 
9fc0			;	ld hl, execscratch 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXP" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	call forthparse 
9fc0			;	ld hl, execscratch 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXx" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	call forthexec 
9fc0			; 
9fc0			;	jp .stkexec1 
9fc0			; 
9fc0			;	ret 
9fc0			 
9fc0			 
9fc0			.DUP: 
9fc0			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9fc0 17				db WORD_SYS_CORE+OPCODE_DUP             
9fc1 36 a0			dw .ZDUP            
9fc3 04				db 3 + 1 
9fc4 .. 00			db "DUP",0              
9fc8				endm 
# End of macro CWHEAD
9fc8			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9fc8			 
9fc8				if DEBUG_FORTH_WORDS_KEY 
9fc8					DMARK "DUP" 
9fc8 f5				push af  
9fc9 3a dd 9f			ld a, (.dmark)  
9fcc 32 6b ee			ld (debug_mark),a  
9fcf 3a de 9f			ld a, (.dmark+1)  
9fd2 32 6c ee			ld (debug_mark+1),a  
9fd5 3a df 9f			ld a, (.dmark+2)  
9fd8 32 6d ee			ld (debug_mark+2),a  
9fdb 18 03			jr .pastdmark  
9fdd ..			.dmark: db "DUP"  
9fe0 f1			.pastdmark: pop af  
9fe1			endm  
# End of macro DMARK
9fe1					CALLMONITOR 
9fe1 cd 6f ee			call debug_vector  
9fe4				endm  
# End of macro CALLMONITOR
9fe4				endif 
9fe4			 
9fe4				FORTH_DSP 
9fe4 cd 39 9c			call macro_forth_dsp 
9fe7				endm 
# End of macro FORTH_DSP
9fe7			 
9fe7 7e				ld a, (HL) 
9fe8 fe 01			cp DS_TYPE_STR 
9fea 20 25			jr nz, .dupinum 
9fec			 
9fec				; push another string 
9fec			 
9fec				FORTH_DSP_VALUEHL     		 
9fec cd 73 9c			call macro_dsp_valuehl 
9fef				endm 
# End of macro FORTH_DSP_VALUEHL
9fef			 
9fef			if DEBUG_FORTH_WORDS 
9fef				DMARK "DUs" 
9fef f5				push af  
9ff0 3a 04 a0			ld a, (.dmark)  
9ff3 32 6b ee			ld (debug_mark),a  
9ff6 3a 05 a0			ld a, (.dmark+1)  
9ff9 32 6c ee			ld (debug_mark+1),a  
9ffc 3a 06 a0			ld a, (.dmark+2)  
9fff 32 6d ee			ld (debug_mark+2),a  
a002 18 03			jr .pastdmark  
a004 ..			.dmark: db "DUs"  
a007 f1			.pastdmark: pop af  
a008			endm  
# End of macro DMARK
a008				CALLMONITOR 
a008 cd 6f ee			call debug_vector  
a00b				endm  
# End of macro CALLMONITOR
a00b			endif 
a00b cd dc 9a			call forth_push_str 
a00e			 
a00e				NEXTW 
a00e c3 29 9e			jp macro_next 
a011				endm 
# End of macro NEXTW
a011			 
a011			 
a011			.dupinum: 
a011				 
a011			 
a011			 
a011				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a011 cd 73 9c			call macro_dsp_valuehl 
a014				endm 
# End of macro FORTH_DSP_VALUEHL
a014			 
a014			; TODO add floating point number detection 
a014			 
a014			if DEBUG_FORTH_WORDS 
a014				DMARK "DUi" 
a014 f5				push af  
a015 3a 29 a0			ld a, (.dmark)  
a018 32 6b ee			ld (debug_mark),a  
a01b 3a 2a a0			ld a, (.dmark+1)  
a01e 32 6c ee			ld (debug_mark+1),a  
a021 3a 2b a0			ld a, (.dmark+2)  
a024 32 6d ee			ld (debug_mark+2),a  
a027 18 03			jr .pastdmark  
a029 ..			.dmark: db "DUi"  
a02c f1			.pastdmark: pop af  
a02d			endm  
# End of macro DMARK
a02d				CALLMONITOR 
a02d cd 6f ee			call debug_vector  
a030				endm  
# End of macro CALLMONITOR
a030			endif 
a030			 
a030 cd 6e 9a			call forth_push_numhl 
a033				NEXTW 
a033 c3 29 9e			jp macro_next 
a036				endm 
# End of macro NEXTW
a036			.ZDUP: 
a036			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a036 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a037 6e a0			dw .SWAP            
a039 05				db 4 + 1 
a03a .. 00			db "?DUP",0              
a03f				endm 
# End of macro CWHEAD
a03f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a03f			 
a03f				if DEBUG_FORTH_WORDS_KEY 
a03f					DMARK "qDU" 
a03f f5				push af  
a040 3a 54 a0			ld a, (.dmark)  
a043 32 6b ee			ld (debug_mark),a  
a046 3a 55 a0			ld a, (.dmark+1)  
a049 32 6c ee			ld (debug_mark+1),a  
a04c 3a 56 a0			ld a, (.dmark+2)  
a04f 32 6d ee			ld (debug_mark+2),a  
a052 18 03			jr .pastdmark  
a054 ..			.dmark: db "qDU"  
a057 f1			.pastdmark: pop af  
a058			endm  
# End of macro DMARK
a058					CALLMONITOR 
a058 cd 6f ee			call debug_vector  
a05b				endm  
# End of macro CALLMONITOR
a05b				endif 
a05b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a05b cd 73 9c			call macro_dsp_valuehl 
a05e				endm 
# End of macro FORTH_DSP_VALUEHL
a05e			 
a05e e5				push hl 
a05f			 
a05f				; is it a zero? 
a05f			 
a05f 3e 00			ld a, 0 
a061 84				add h 
a062 85				add l 
a063			 
a063 e1				pop hl 
a064			 
a064 fe 00			cp 0 
a066 28 03			jr z, .dup2orig 
a068			 
a068			 
a068 cd 6e 9a			call forth_push_numhl 
a06b			 
a06b			 
a06b			; TODO add floating point number detection 
a06b			 
a06b			.dup2orig: 
a06b			 
a06b				NEXTW 
a06b c3 29 9e			jp macro_next 
a06e				endm 
# End of macro NEXTW
a06e			.SWAP: 
a06e			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a06e 18				db WORD_SYS_CORE+OPCODE_SWAP             
a06f ad a0			dw .COLN            
a071 05				db 4 + 1 
a072 .. 00			db "SWAP",0              
a077				endm 
# End of macro CWHEAD
a077			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a077				if DEBUG_FORTH_WORDS_KEY 
a077					DMARK "SWP" 
a077 f5				push af  
a078 3a 8c a0			ld a, (.dmark)  
a07b 32 6b ee			ld (debug_mark),a  
a07e 3a 8d a0			ld a, (.dmark+1)  
a081 32 6c ee			ld (debug_mark+1),a  
a084 3a 8e a0			ld a, (.dmark+2)  
a087 32 6d ee			ld (debug_mark+2),a  
a08a 18 03			jr .pastdmark  
a08c ..			.dmark: db "SWP"  
a08f f1			.pastdmark: pop af  
a090			endm  
# End of macro DMARK
a090					CALLMONITOR 
a090 cd 6f ee			call debug_vector  
a093				endm  
# End of macro CALLMONITOR
a093				endif 
a093			 
a093			; TODO Use os stack swap memory 
a093				FORTH_DSP_VALUEHL 
a093 cd 73 9c			call macro_dsp_valuehl 
a096				endm 
# End of macro FORTH_DSP_VALUEHL
a096 e5				push hl     ; w2 
a097			 
a097				FORTH_DSP_POP 
a097 cd 2b 9d			call macro_forth_dsp_pop 
a09a				endm 
# End of macro FORTH_DSP_POP
a09a			 
a09a				FORTH_DSP_VALUEHL 
a09a cd 73 9c			call macro_dsp_valuehl 
a09d				endm 
# End of macro FORTH_DSP_VALUEHL
a09d			 
a09d				FORTH_DSP_POP 
a09d cd 2b 9d			call macro_forth_dsp_pop 
a0a0				endm 
# End of macro FORTH_DSP_POP
a0a0			 
a0a0 d1				pop de     ; w2	, hl = w1 
a0a1			 
a0a1 eb				ex de, hl 
a0a2 d5				push de 
a0a3			 
a0a3 cd 6e 9a			call forth_push_numhl 
a0a6			 
a0a6 e1				pop hl 
a0a7			 
a0a7 cd 6e 9a			call forth_push_numhl 
a0aa				 
a0aa			 
a0aa				NEXTW 
a0aa c3 29 9e			jp macro_next 
a0ad				endm 
# End of macro NEXTW
a0ad			.COLN: 
a0ad			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0ad 19				db WORD_SYS_CORE+OPCODE_COLN             
a0ae 39 a2			dw .SCOLN            
a0b0 02				db 1 + 1 
a0b1 .. 00			db ":",0              
a0b3				endm 
# End of macro CWHEAD
a0b3			; | : ( -- )         Create new word | DONE 
a0b3			 
a0b3				if DEBUG_FORTH_WORDS_KEY 
a0b3					DMARK "CLN" 
a0b3 f5				push af  
a0b4 3a c8 a0			ld a, (.dmark)  
a0b7 32 6b ee			ld (debug_mark),a  
a0ba 3a c9 a0			ld a, (.dmark+1)  
a0bd 32 6c ee			ld (debug_mark+1),a  
a0c0 3a ca a0			ld a, (.dmark+2)  
a0c3 32 6d ee			ld (debug_mark+2),a  
a0c6 18 03			jr .pastdmark  
a0c8 ..			.dmark: db "CLN"  
a0cb f1			.pastdmark: pop af  
a0cc			endm  
# End of macro DMARK
a0cc					CALLMONITOR 
a0cc cd 6f ee			call debug_vector  
a0cf				endm  
# End of macro CALLMONITOR
a0cf				endif 
a0cf			STACKFRAME OFF $8efe $989f 
a0cf				if DEBUG_STACK_IMB 
a0cf					if OFF 
a0cf						exx 
a0cf						ld de, $8efe 
a0cf						ld a, d 
a0cf						ld hl, curframe 
a0cf						call hexout 
a0cf						ld a, e 
a0cf						ld hl, curframe+2 
a0cf						call hexout 
a0cf						ld hl, $8efe 
a0cf						push hl 
a0cf						ld hl, $989f 
a0cf						push hl 
a0cf						exx 
a0cf					endif 
a0cf				endif 
a0cf			endm 
# End of macro STACKFRAME
a0cf			; get parser buffer length  of new word 
a0cf			 
a0cf			 
a0cf			 
a0cf				; move tok past this to start of name defintition 
a0cf				; TODO get word to define 
a0cf				; TODO Move past word token 
a0cf				; TODO get length of string up to the ';' 
a0cf			 
a0cf 2a c2 e5		ld hl, (os_tok_ptr) 
a0d2 23			inc hl 
a0d3 23			inc hl 
a0d4			 
a0d4 3e 3b		ld a, ';' 
a0d6 cd 58 90		call strlent 
a0d9			 
a0d9 7d			ld a,l 
a0da 32 b1 e2		ld (os_new_parse_len), a 
a0dd			 
a0dd			 
a0dd			if DEBUG_FORTH_UWORD 
a0dd ed 5b c2 e5	ld de, (os_tok_ptr) 
a0e1					DMARK ":01" 
a0e1 f5				push af  
a0e2 3a f6 a0			ld a, (.dmark)  
a0e5 32 6b ee			ld (debug_mark),a  
a0e8 3a f7 a0			ld a, (.dmark+1)  
a0eb 32 6c ee			ld (debug_mark+1),a  
a0ee 3a f8 a0			ld a, (.dmark+2)  
a0f1 32 6d ee			ld (debug_mark+2),a  
a0f4 18 03			jr .pastdmark  
a0f6 ..			.dmark: db ":01"  
a0f9 f1			.pastdmark: pop af  
a0fa			endm  
# End of macro DMARK
a0fa			CALLMONITOR 
a0fa cd 6f ee			call debug_vector  
a0fd				endm  
# End of macro CALLMONITOR
a0fd			endif 
a0fd			 
a0fd			; 
a0fd			;  new word memory layout: 
a0fd			;  
a0fd			;    : adg 6666 ;  
a0fd			; 
a0fd			;    db   1     ; user defined word  
a0fd 23			inc hl    
a0fe			;    dw   sysdict 
a0fe 23			inc hl 
a0ff 23			inc hl 
a100			;    db <word len>+1 (for null) 
a100 23			inc hl 
a101			;    db .... <word> 
a101			; 
a101			 
a101 23			inc hl    ; some extras for the word preamble before the above 
a102 23			inc hl 
a103 23			inc hl 
a104 23			inc hl 
a105 23			inc hl 
a106 23			inc hl 
a107 23			inc hl  
a108 23			inc hl 
a109 23			inc hl 
a10a 23			inc hl 
a10b 23			inc hl 
a10c 23			inc hl 
a10d 23			inc hl 
a10e 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a10f			;       exec word buffer 
a10f			;	<ptr word>   
a10f 23			inc hl 
a110 23			inc hl 
a111			;       <word list><null term> 7F final term 
a111			 
a111			 
a111			if DEBUG_FORTH_UWORD 
a111					DMARK ":02" 
a111 f5				push af  
a112 3a 26 a1			ld a, (.dmark)  
a115 32 6b ee			ld (debug_mark),a  
a118 3a 27 a1			ld a, (.dmark+1)  
a11b 32 6c ee			ld (debug_mark+1),a  
a11e 3a 28 a1			ld a, (.dmark+2)  
a121 32 6d ee			ld (debug_mark+2),a  
a124 18 03			jr .pastdmark  
a126 ..			.dmark: db ":02"  
a129 f1			.pastdmark: pop af  
a12a			endm  
# End of macro DMARK
a12a			CALLMONITOR 
a12a cd 6f ee			call debug_vector  
a12d				endm  
# End of macro CALLMONITOR
a12d			endif 
a12d			 
a12d			 
a12d				; malloc the size 
a12d			 
a12d cd c2 90			call malloc 
a130 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a133			 
a133			;    db   1     ; user defined word  
a133 3e 01			ld a, WORD_SYS_UWORD  
a135 77				ld (hl), a 
a136			 
a136 23			inc hl    
a137			;    dw   sysdict 
a137 11 81 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a13a 73			ld (hl), e 
a13b 23			inc hl 
a13c 72			ld (hl), d 
a13d 23			inc hl 
a13e			 
a13e			 
a13e			;    Setup dict word 
a13e			 
a13e 23			inc hl 
a13f 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a142			 
a142			; 1. get length of dict word 
a142			 
a142			 
a142 2a c2 e5		ld hl, (os_tok_ptr) 
a145 23			inc hl 
a146 23			inc hl    ; position to start of dict word 
a147 3e 00		ld a, 0 
a149 cd 58 90		call strlent 
a14c			 
a14c			 
a14c 23			inc hl    ; to include null??? 
a14d			 
a14d			; write length of dict word 
a14d			 
a14d ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a151 1b			dec de 
a152 eb			ex de, hl 
a153 73			ld (hl), e 
a154 eb			ex de, hl 
a155			 
a155			 
a155			 
a155			; copy  
a155 4d			ld c, l 
a156 06 00		ld b, 0 
a158 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a15c 2a c2 e5		ld hl, (os_tok_ptr) 
a15f 23			inc hl 
a160 23			inc hl    ; position to start of dict word 
a161			 
a161			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a161			 
a161			; TODO need to convert word to upper case 
a161			 
a161			ucasetok:	 
a161 7e			ld a,(hl) 
a162 cd 44 90		call toUpper 
a165 77			ld (hl),a 
a166 ed a0		ldi 
a168 f2 61 a1		jp p, ucasetok 
a16b			 
a16b			 
a16b			 
a16b			; de now points to start of where the word body code should be placed 
a16b ed 53 ad e2	ld (os_new_work_ptr), de 
a16f			; hl now points to the words to throw at forthexec which needs to be copied 
a16f 22 ab e2		ld (os_new_src_ptr), hl 
a172			 
a172			; TODO add 'call to forthexec' 
a172			 
a172			if DEBUG_FORTH_UWORD 
a172 c5			push bc 
a173 ed 4b b3 e2	ld bc, (os_new_malloc) 
a177					DMARK ":0x" 
a177 f5				push af  
a178 3a 8c a1			ld a, (.dmark)  
a17b 32 6b ee			ld (debug_mark),a  
a17e 3a 8d a1			ld a, (.dmark+1)  
a181 32 6c ee			ld (debug_mark+1),a  
a184 3a 8e a1			ld a, (.dmark+2)  
a187 32 6d ee			ld (debug_mark+2),a  
a18a 18 03			jr .pastdmark  
a18c ..			.dmark: db ":0x"  
a18f f1			.pastdmark: pop af  
a190			endm  
# End of macro DMARK
a190			CALLMONITOR 
a190 cd 6f ee			call debug_vector  
a193				endm  
# End of macro CALLMONITOR
a193 c1			pop bc 
a194			endif 
a194			 
a194			 
a194			; create word preamble which should be: 
a194			 
a194			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a194			 
a194			;    ld hl, <word code> 
a194			;    jp user_exec 
a194			;    <word code bytes> 
a194			 
a194			 
a194			;	inc de     ; TODO ??? or are we already past the word's null 
a194 eb			ex de, hl 
a195			 
a195 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a197			 
a197 23			inc hl 
a198 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a19b 23			inc hl 
a19c			 
a19c 23			inc hl 
a19d 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a19f			 
a19f 01 23 cb		ld bc, user_exec 
a1a2 23			inc hl 
a1a3 71			ld (hl), c     ; poke address of user_exec 
a1a4 23			inc hl 
a1a5 70			ld (hl), b     
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1a6			; 
a1a6			; 
a1a6			;	ld bc, macro_forth_rsp_next 
a1a6			;	inc hl 
a1a6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1a6			;	inc hl 
a1a6			;	ld (hl), b     
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1a6			; 
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld bc, forthexec 
a1a6			;	ld (hl), c     ; poke address of forthexec 
a1a6			;	inc hl 
a1a6			;	ld (hl), b      
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1a6			; 
a1a6			;	ld bc, user_dict_next 
a1a6			;	inc hl 
a1a6			;	ld (hl), c     ; poke address of forthexec 
a1a6			;	inc hl 
a1a6			;	ld (hl), b      
a1a6			 
a1a6			; hl is now where we need to copy the word byte data to save this 
a1a6			 
a1a6 23			inc hl 
a1a7 22 a9 e2		ld (os_new_exec), hl 
a1aa			 
a1aa			; copy definition 
a1aa			 
a1aa eb			ex de, hl 
a1ab			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1ab			;	inc de    ; skip the PC for this parse 
a1ab 3a b1 e2		ld a, (os_new_parse_len) 
a1ae 4f			ld c, a 
a1af 06 00		ld b, 0 
a1b1 ed b0		ldir		 ; copy defintion 
a1b3			 
a1b3			 
a1b3			; poke the address of where the new word bytes live for forthexec 
a1b3			 
a1b3 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1b6			 
a1b6 ed 5b a9 e2	ld de, (os_new_exec)      
a1ba			 
a1ba 73			ld (hl), e 
a1bb 23			inc hl 
a1bc 72			ld (hl), d 
a1bd			 
a1bd				; TODO copy last user dict word next link to this word 
a1bd				; TODO update last user dict word to point to this word 
a1bd			; 
a1bd			; hl f923 de 812a ; bc 811a 
a1bd			 
a1bd			if DEBUG_FORTH_UWORD 
a1bd c5			push bc 
a1be ed 4b b3 e2	ld bc, (os_new_malloc) 
a1c2					DMARK ":0A" 
a1c2 f5				push af  
a1c3 3a d7 a1			ld a, (.dmark)  
a1c6 32 6b ee			ld (debug_mark),a  
a1c9 3a d8 a1			ld a, (.dmark+1)  
a1cc 32 6c ee			ld (debug_mark+1),a  
a1cf 3a d9 a1			ld a, (.dmark+2)  
a1d2 32 6d ee			ld (debug_mark+2),a  
a1d5 18 03			jr .pastdmark  
a1d7 ..			.dmark: db ":0A"  
a1da f1			.pastdmark: pop af  
a1db			endm  
# End of macro DMARK
a1db			CALLMONITOR 
a1db cd 6f ee			call debug_vector  
a1de				endm  
# End of macro CALLMONITOR
a1de c1			pop bc 
a1df			endif 
a1df			if DEBUG_FORTH_UWORD 
a1df c5			push bc 
a1e0 ed 4b b3 e2	ld bc, (os_new_malloc) 
a1e4 03			inc bc 
a1e5 03			inc bc 
a1e6 03			inc bc 
a1e7 03			inc bc 
a1e8 03			inc bc 
a1e9 03			inc bc 
a1ea 03			inc bc 
a1eb 03			inc bc 
a1ec			 
a1ec					DMARK ":0B" 
a1ec f5				push af  
a1ed 3a 01 a2			ld a, (.dmark)  
a1f0 32 6b ee			ld (debug_mark),a  
a1f3 3a 02 a2			ld a, (.dmark+1)  
a1f6 32 6c ee			ld (debug_mark+1),a  
a1f9 3a 03 a2			ld a, (.dmark+2)  
a1fc 32 6d ee			ld (debug_mark+2),a  
a1ff 18 03			jr .pastdmark  
a201 ..			.dmark: db ":0B"  
a204 f1			.pastdmark: pop af  
a205			endm  
# End of macro DMARK
a205			CALLMONITOR 
a205 cd 6f ee			call debug_vector  
a208				endm  
# End of macro CALLMONITOR
a208 c1			pop bc 
a209			endif 
a209			 
a209			; update word dict linked list for new word 
a209			 
a209			 
a209 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a20c 23			inc hl     ; move to next work linked list ptr 
a20d			 
a20d ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a211 73			ld (hl), e 
a212 23			inc hl 
a213 72			ld (hl), d 
a214			 
a214			if DEBUG_FORTH_UWORD 
a214 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a218			endif 
a218			 
a218 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a21c			 
a21c			 
a21c			if DEBUG_FORTH_UWORD 
a21c					DMARK ":0+" 
a21c f5				push af  
a21d 3a 31 a2			ld a, (.dmark)  
a220 32 6b ee			ld (debug_mark),a  
a223 3a 32 a2			ld a, (.dmark+1)  
a226 32 6c ee			ld (debug_mark+1),a  
a229 3a 33 a2			ld a, (.dmark+2)  
a22c 32 6d ee			ld (debug_mark+2),a  
a22f 18 03			jr .pastdmark  
a231 ..			.dmark: db ":0+"  
a234 f1			.pastdmark: pop af  
a235			endm  
# End of macro DMARK
a235			CALLMONITOR 
a235 cd 6f ee			call debug_vector  
a238				endm  
# End of macro CALLMONITOR
a238			endif 
a238			 
a238			STACKFRAMECHK OFF $8efe $989f 
a238				if DEBUG_STACK_IMB 
a238					if OFF 
a238						exx 
a238						ld hl, $989f 
a238						pop de   ; $989f 
a238						call cmp16 
a238						jr nz, .spnosame 
a238						ld hl, $8efe 
a238						pop de   ; $8efe 
a238						call cmp16 
a238						jr z, .spfrsame 
a238						.spnosame: call showsperror 
a238						.spfrsame: nop 
a238						exx 
a238					endif 
a238				endif 
a238			endm 
# End of macro STACKFRAMECHK
a238			 
a238 c9			ret    ; dont process any remaining parser tokens as they form new word 
a239			 
a239			 
a239			 
a239			 
a239			;		NEXT 
a239			.SCOLN: 
a239			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a239 06			db OPCODE_SCOLN 
a23a 85 a2		dw .DROP 
a23c 02			db 2 
a23d .. 00		db ";",0           
a23f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a23f				if DEBUG_FORTH_WORDS_KEY 
a23f					DMARK "SCN" 
a23f f5				push af  
a240 3a 54 a2			ld a, (.dmark)  
a243 32 6b ee			ld (debug_mark),a  
a246 3a 55 a2			ld a, (.dmark+1)  
a249 32 6c ee			ld (debug_mark+1),a  
a24c 3a 56 a2			ld a, (.dmark+2)  
a24f 32 6d ee			ld (debug_mark+2),a  
a252 18 03			jr .pastdmark  
a254 ..			.dmark: db "SCN"  
a257 f1			.pastdmark: pop af  
a258			endm  
# End of macro DMARK
a258					CALLMONITOR 
a258 cd 6f ee			call debug_vector  
a25b				endm  
# End of macro CALLMONITOR
a25b				endif 
a25b				FORTH_RSP_TOS 
a25b cd 2c 9a			call macro_forth_rsp_tos 
a25e				endm 
# End of macro FORTH_RSP_TOS
a25e e5				push hl 
a25f				FORTH_RSP_POP 
a25f cd 36 9a			call macro_forth_rsp_pop 
a262				endm 
# End of macro FORTH_RSP_POP
a262 e1				pop hl 
a263			;		ex de,hl 
a263 22 c2 e5			ld (os_tok_ptr),hl 
a266			 
a266			if DEBUG_FORTH_UWORD 
a266					DMARK "SCL" 
a266 f5				push af  
a267 3a 7b a2			ld a, (.dmark)  
a26a 32 6b ee			ld (debug_mark),a  
a26d 3a 7c a2			ld a, (.dmark+1)  
a270 32 6c ee			ld (debug_mark+1),a  
a273 3a 7d a2			ld a, (.dmark+2)  
a276 32 6d ee			ld (debug_mark+2),a  
a279 18 03			jr .pastdmark  
a27b ..			.dmark: db "SCL"  
a27e f1			.pastdmark: pop af  
a27f			endm  
# End of macro DMARK
a27f			CALLMONITOR 
a27f cd 6f ee			call debug_vector  
a282				endm  
# End of macro CALLMONITOR
a282			endif 
a282				NEXTW 
a282 c3 29 9e			jp macro_next 
a285				endm 
# End of macro NEXTW
a285			 
a285			.DROP: 
a285			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a285 1b				db WORD_SYS_CORE+OPCODE_DROP             
a286 b0 a2			dw .DUP2            
a288 05				db 4 + 1 
a289 .. 00			db "DROP",0              
a28e				endm 
# End of macro CWHEAD
a28e			; | DROP ( w -- )   drop the TOS item   | DONE 
a28e				if DEBUG_FORTH_WORDS_KEY 
a28e					DMARK "DRP" 
a28e f5				push af  
a28f 3a a3 a2			ld a, (.dmark)  
a292 32 6b ee			ld (debug_mark),a  
a295 3a a4 a2			ld a, (.dmark+1)  
a298 32 6c ee			ld (debug_mark+1),a  
a29b 3a a5 a2			ld a, (.dmark+2)  
a29e 32 6d ee			ld (debug_mark+2),a  
a2a1 18 03			jr .pastdmark  
a2a3 ..			.dmark: db "DRP"  
a2a6 f1			.pastdmark: pop af  
a2a7			endm  
# End of macro DMARK
a2a7					CALLMONITOR 
a2a7 cd 6f ee			call debug_vector  
a2aa				endm  
# End of macro CALLMONITOR
a2aa				endif 
a2aa				FORTH_DSP_POP 
a2aa cd 2b 9d			call macro_forth_dsp_pop 
a2ad				endm 
# End of macro FORTH_DSP_POP
a2ad				NEXTW 
a2ad c3 29 9e			jp macro_next 
a2b0				endm 
# End of macro NEXTW
a2b0			.DUP2: 
a2b0			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2b0 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2b1 f5 a2			dw .DROP2            
a2b3 05				db 4 + 1 
a2b4 .. 00			db "2DUP",0              
a2b9				endm 
# End of macro CWHEAD
a2b9			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a2b9				if DEBUG_FORTH_WORDS_KEY 
a2b9					DMARK "2DU" 
a2b9 f5				push af  
a2ba 3a ce a2			ld a, (.dmark)  
a2bd 32 6b ee			ld (debug_mark),a  
a2c0 3a cf a2			ld a, (.dmark+1)  
a2c3 32 6c ee			ld (debug_mark+1),a  
a2c6 3a d0 a2			ld a, (.dmark+2)  
a2c9 32 6d ee			ld (debug_mark+2),a  
a2cc 18 03			jr .pastdmark  
a2ce ..			.dmark: db "2DU"  
a2d1 f1			.pastdmark: pop af  
a2d2			endm  
# End of macro DMARK
a2d2					CALLMONITOR 
a2d2 cd 6f ee			call debug_vector  
a2d5				endm  
# End of macro CALLMONITOR
a2d5				endif 
a2d5				FORTH_DSP_VALUEHL 
a2d5 cd 73 9c			call macro_dsp_valuehl 
a2d8				endm 
# End of macro FORTH_DSP_VALUEHL
a2d8 e5				push hl      ; 2 
a2d9			 
a2d9				FORTH_DSP_POP 
a2d9 cd 2b 9d			call macro_forth_dsp_pop 
a2dc				endm 
# End of macro FORTH_DSP_POP
a2dc				 
a2dc				FORTH_DSP_VALUEHL 
a2dc cd 73 9c			call macro_dsp_valuehl 
a2df				endm 
# End of macro FORTH_DSP_VALUEHL
a2df			;		push hl      ; 1 
a2df			 
a2df				FORTH_DSP_POP 
a2df cd 2b 9d			call macro_forth_dsp_pop 
a2e2				endm 
# End of macro FORTH_DSP_POP
a2e2			 
a2e2			;		pop hl       ; 1 
a2e2 d1				pop de       ; 2 
a2e3			 
a2e3 cd 6e 9a			call forth_push_numhl 
a2e6 eb				ex de, hl 
a2e7 cd 6e 9a			call forth_push_numhl 
a2ea			 
a2ea				 
a2ea eb				ex de, hl 
a2eb			 
a2eb cd 6e 9a			call forth_push_numhl 
a2ee eb				ex de, hl 
a2ef cd 6e 9a			call forth_push_numhl 
a2f2			 
a2f2			 
a2f2				NEXTW 
a2f2 c3 29 9e			jp macro_next 
a2f5				endm 
# End of macro NEXTW
a2f5			.DROP2: 
a2f5			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a2f5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a2f6 24 a3			dw .SWAP2            
a2f8 06				db 5 + 1 
a2f9 .. 00			db "2DROP",0              
a2ff				endm 
# End of macro CWHEAD
a2ff			; | 2DROP ( w w -- )    Double drop | DONE 
a2ff				if DEBUG_FORTH_WORDS_KEY 
a2ff					DMARK "2DR" 
a2ff f5				push af  
a300 3a 14 a3			ld a, (.dmark)  
a303 32 6b ee			ld (debug_mark),a  
a306 3a 15 a3			ld a, (.dmark+1)  
a309 32 6c ee			ld (debug_mark+1),a  
a30c 3a 16 a3			ld a, (.dmark+2)  
a30f 32 6d ee			ld (debug_mark+2),a  
a312 18 03			jr .pastdmark  
a314 ..			.dmark: db "2DR"  
a317 f1			.pastdmark: pop af  
a318			endm  
# End of macro DMARK
a318					CALLMONITOR 
a318 cd 6f ee			call debug_vector  
a31b				endm  
# End of macro CALLMONITOR
a31b				endif 
a31b				FORTH_DSP_POP 
a31b cd 2b 9d			call macro_forth_dsp_pop 
a31e				endm 
# End of macro FORTH_DSP_POP
a31e				FORTH_DSP_POP 
a31e cd 2b 9d			call macro_forth_dsp_pop 
a321				endm 
# End of macro FORTH_DSP_POP
a321				NEXTW 
a321 c3 29 9e			jp macro_next 
a324				endm 
# End of macro NEXTW
a324			.SWAP2: 
a324			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a324 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a325 4d a3			dw .AT            
a327 06				db 5 + 1 
a328 .. 00			db "2SWAP",0              
a32e				endm 
# End of macro CWHEAD
a32e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a32e				if DEBUG_FORTH_WORDS_KEY 
a32e					DMARK "2SW" 
a32e f5				push af  
a32f 3a 43 a3			ld a, (.dmark)  
a332 32 6b ee			ld (debug_mark),a  
a335 3a 44 a3			ld a, (.dmark+1)  
a338 32 6c ee			ld (debug_mark+1),a  
a33b 3a 45 a3			ld a, (.dmark+2)  
a33e 32 6d ee			ld (debug_mark+2),a  
a341 18 03			jr .pastdmark  
a343 ..			.dmark: db "2SW"  
a346 f1			.pastdmark: pop af  
a347			endm  
# End of macro DMARK
a347					CALLMONITOR 
a347 cd 6f ee			call debug_vector  
a34a				endm  
# End of macro CALLMONITOR
a34a				endif 
a34a			; TODO Use os stack swap memory 
a34a				NEXTW 
a34a c3 29 9e			jp macro_next 
a34d				endm 
# End of macro NEXTW
a34d			.AT: 
a34d			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a34d 1f				db WORD_SYS_CORE+OPCODE_AT             
a34e 7f a3			dw .CAT            
a350 02				db 1 + 1 
a351 .. 00			db "@",0              
a353				endm 
# End of macro CWHEAD
a353			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a353			 
a353				if DEBUG_FORTH_WORDS_KEY 
a353					DMARK "AT." 
a353 f5				push af  
a354 3a 68 a3			ld a, (.dmark)  
a357 32 6b ee			ld (debug_mark),a  
a35a 3a 69 a3			ld a, (.dmark+1)  
a35d 32 6c ee			ld (debug_mark+1),a  
a360 3a 6a a3			ld a, (.dmark+2)  
a363 32 6d ee			ld (debug_mark+2),a  
a366 18 03			jr .pastdmark  
a368 ..			.dmark: db "AT."  
a36b f1			.pastdmark: pop af  
a36c			endm  
# End of macro DMARK
a36c					CALLMONITOR 
a36c cd 6f ee			call debug_vector  
a36f				endm  
# End of macro CALLMONITOR
a36f				endif 
a36f			.getbyteat:	 
a36f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a36f cd 73 9c			call macro_dsp_valuehl 
a372				endm 
# End of macro FORTH_DSP_VALUEHL
a372				 
a372			;		push hl 
a372			 
a372				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a372 cd 2b 9d			call macro_forth_dsp_pop 
a375				endm 
# End of macro FORTH_DSP_POP
a375			 
a375			;		pop hl 
a375			 
a375 7e				ld a, (hl) 
a376			 
a376 6f				ld l, a 
a377 26 00			ld h, 0 
a379 cd 6e 9a			call forth_push_numhl 
a37c			 
a37c				NEXTW 
a37c c3 29 9e			jp macro_next 
a37f				endm 
# End of macro NEXTW
a37f			.CAT: 
a37f			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a37f 20				db WORD_SYS_CORE+OPCODE_CAT             
a380 a8 a3			dw .BANG            
a382 03				db 2 + 1 
a383 .. 00			db "C@",0              
a386				endm 
# End of macro CWHEAD
a386			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a386				if DEBUG_FORTH_WORDS_KEY 
a386					DMARK "CAA" 
a386 f5				push af  
a387 3a 9b a3			ld a, (.dmark)  
a38a 32 6b ee			ld (debug_mark),a  
a38d 3a 9c a3			ld a, (.dmark+1)  
a390 32 6c ee			ld (debug_mark+1),a  
a393 3a 9d a3			ld a, (.dmark+2)  
a396 32 6d ee			ld (debug_mark+2),a  
a399 18 03			jr .pastdmark  
a39b ..			.dmark: db "CAA"  
a39e f1			.pastdmark: pop af  
a39f			endm  
# End of macro DMARK
a39f					CALLMONITOR 
a39f cd 6f ee			call debug_vector  
a3a2				endm  
# End of macro CALLMONITOR
a3a2				endif 
a3a2 c3 6f a3			jp .getbyteat 
a3a5				NEXTW 
a3a5 c3 29 9e			jp macro_next 
a3a8				endm 
# End of macro NEXTW
a3a8			.BANG: 
a3a8			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a3a8 21				db WORD_SYS_CORE+OPCODE_BANG             
a3a9 de a3			dw .CBANG            
a3ab 02				db 1 + 1 
a3ac .. 00			db "!",0              
a3ae				endm 
# End of macro CWHEAD
a3ae			; | ! ( x w -- ) Store x at address w      | DONE 
a3ae				if DEBUG_FORTH_WORDS_KEY 
a3ae					DMARK "BNG" 
a3ae f5				push af  
a3af 3a c3 a3			ld a, (.dmark)  
a3b2 32 6b ee			ld (debug_mark),a  
a3b5 3a c4 a3			ld a, (.dmark+1)  
a3b8 32 6c ee			ld (debug_mark+1),a  
a3bb 3a c5 a3			ld a, (.dmark+2)  
a3be 32 6d ee			ld (debug_mark+2),a  
a3c1 18 03			jr .pastdmark  
a3c3 ..			.dmark: db "BNG"  
a3c6 f1			.pastdmark: pop af  
a3c7			endm  
# End of macro DMARK
a3c7					CALLMONITOR 
a3c7 cd 6f ee			call debug_vector  
a3ca				endm  
# End of macro CALLMONITOR
a3ca				endif 
a3ca			 
a3ca			.storebyteat:		 
a3ca				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3ca cd 73 9c			call macro_dsp_valuehl 
a3cd				endm 
# End of macro FORTH_DSP_VALUEHL
a3cd				 
a3cd e5				push hl 
a3ce			 
a3ce				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3ce cd 2b 9d			call macro_forth_dsp_pop 
a3d1				endm 
# End of macro FORTH_DSP_POP
a3d1			 
a3d1				; get byte to poke 
a3d1			 
a3d1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3d1 cd 73 9c			call macro_dsp_valuehl 
a3d4				endm 
# End of macro FORTH_DSP_VALUEHL
a3d4 e5				push hl 
a3d5			 
a3d5			 
a3d5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3d5 cd 2b 9d			call macro_forth_dsp_pop 
a3d8				endm 
# End of macro FORTH_DSP_POP
a3d8			 
a3d8			 
a3d8 d1				pop de 
a3d9 e1				pop hl 
a3da			 
a3da 73				ld (hl),e 
a3db			 
a3db			 
a3db				NEXTW 
a3db c3 29 9e			jp macro_next 
a3de				endm 
# End of macro NEXTW
a3de			.CBANG: 
a3de			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a3de 22				db WORD_SYS_CORE+OPCODE_CBANG             
a3df 07 a4			dw .SCALL            
a3e1 03				db 2 + 1 
a3e2 .. 00			db "C!",0              
a3e5				endm 
# End of macro CWHEAD
a3e5			; | C!  ( x w -- ) Store x at address w  | DONE 
a3e5				if DEBUG_FORTH_WORDS_KEY 
a3e5					DMARK "CBA" 
a3e5 f5				push af  
a3e6 3a fa a3			ld a, (.dmark)  
a3e9 32 6b ee			ld (debug_mark),a  
a3ec 3a fb a3			ld a, (.dmark+1)  
a3ef 32 6c ee			ld (debug_mark+1),a  
a3f2 3a fc a3			ld a, (.dmark+2)  
a3f5 32 6d ee			ld (debug_mark+2),a  
a3f8 18 03			jr .pastdmark  
a3fa ..			.dmark: db "CBA"  
a3fd f1			.pastdmark: pop af  
a3fe			endm  
# End of macro DMARK
a3fe					CALLMONITOR 
a3fe cd 6f ee			call debug_vector  
a401				endm  
# End of macro CALLMONITOR
a401				endif 
a401 c3 ca a3			jp .storebyteat 
a404				NEXTW 
a404 c3 29 9e			jp macro_next 
a407				endm 
# End of macro NEXTW
a407			.SCALL: 
a407			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a407 23				db WORD_SYS_CORE+OPCODE_SCALL             
a408 3b a4			dw .DEPTH            
a40a 05				db 4 + 1 
a40b .. 00			db "CALL",0              
a410				endm 
# End of macro CWHEAD
a410			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a410				if DEBUG_FORTH_WORDS_KEY 
a410					DMARK "CLL" 
a410 f5				push af  
a411 3a 25 a4			ld a, (.dmark)  
a414 32 6b ee			ld (debug_mark),a  
a417 3a 26 a4			ld a, (.dmark+1)  
a41a 32 6c ee			ld (debug_mark+1),a  
a41d 3a 27 a4			ld a, (.dmark+2)  
a420 32 6d ee			ld (debug_mark+2),a  
a423 18 03			jr .pastdmark  
a425 ..			.dmark: db "CLL"  
a428 f1			.pastdmark: pop af  
a429			endm  
# End of macro DMARK
a429					CALLMONITOR 
a429 cd 6f ee			call debug_vector  
a42c				endm  
# End of macro CALLMONITOR
a42c				endif 
a42c			 
a42c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a42c cd 73 9c			call macro_dsp_valuehl 
a42f				endm 
# End of macro FORTH_DSP_VALUEHL
a42f			 
a42f			;		push hl 
a42f			 
a42f				; destroy value TOS 
a42f			 
a42f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a42f cd 2b 9d			call macro_forth_dsp_pop 
a432				endm 
# End of macro FORTH_DSP_POP
a432			 
a432					 
a432			;		pop hl 
a432			 
a432				; how to do a call with hl???? save SP? 
a432 cd cd 9d			call forth_call_hl 
a435			 
a435			 
a435				; TODO push value back onto stack for another op etc 
a435			 
a435 cd 6e 9a			call forth_push_numhl 
a438				NEXTW 
a438 c3 29 9e			jp macro_next 
a43b				endm 
# End of macro NEXTW
a43b			.DEPTH: 
a43b			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a43b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a43c 78 a4			dw .OVER            
a43e 06				db 5 + 1 
a43f .. 00			db "DEPTH",0              
a445				endm 
# End of macro CWHEAD
a445			; | DEPTH ( -- u ) Push count of stack | DONE 
a445				; take current TOS and remove from base value div by two to get count 
a445				if DEBUG_FORTH_WORDS_KEY 
a445					DMARK "DEP" 
a445 f5				push af  
a446 3a 5a a4			ld a, (.dmark)  
a449 32 6b ee			ld (debug_mark),a  
a44c 3a 5b a4			ld a, (.dmark+1)  
a44f 32 6c ee			ld (debug_mark+1),a  
a452 3a 5c a4			ld a, (.dmark+2)  
a455 32 6d ee			ld (debug_mark+2),a  
a458 18 03			jr .pastdmark  
a45a ..			.dmark: db "DEP"  
a45d f1			.pastdmark: pop af  
a45e			endm  
# End of macro DMARK
a45e					CALLMONITOR 
a45e cd 6f ee			call debug_vector  
a461				endm  
# End of macro CALLMONITOR
a461				endif 
a461			 
a461			 
a461 2a ee e9		ld hl, (cli_data_sp) 
a464 11 28 e8		ld de, cli_data_stack 
a467 ed 52		sbc hl,de 
a469			 
a469			; div by size of stack item 
a469			 
a469 5d			ld e,l 
a46a 0e 03		ld c, 3 
a46c cd 77 8c		call Div8 
a46f			 
a46f 6f			ld l,a 
a470 26 00		ld h,0 
a472			 
a472			;srl h 
a472			;rr l 
a472			 
a472 cd 6e 9a			call forth_push_numhl 
a475				NEXTW 
a475 c3 29 9e			jp macro_next 
a478				endm 
# End of macro NEXTW
a478			.OVER: 
a478			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a478 42				db WORD_SYS_CORE+46             
a479 bf a4			dw .PAUSE            
a47b 05				db 4 + 1 
a47c .. 00			db "OVER",0              
a481				endm 
# End of macro CWHEAD
a481			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a481				if DEBUG_FORTH_WORDS_KEY 
a481					DMARK "OVR" 
a481 f5				push af  
a482 3a 96 a4			ld a, (.dmark)  
a485 32 6b ee			ld (debug_mark),a  
a488 3a 97 a4			ld a, (.dmark+1)  
a48b 32 6c ee			ld (debug_mark+1),a  
a48e 3a 98 a4			ld a, (.dmark+2)  
a491 32 6d ee			ld (debug_mark+2),a  
a494 18 03			jr .pastdmark  
a496 ..			.dmark: db "OVR"  
a499 f1			.pastdmark: pop af  
a49a			endm  
# End of macro DMARK
a49a					CALLMONITOR 
a49a cd 6f ee			call debug_vector  
a49d				endm  
# End of macro CALLMONITOR
a49d				endif 
a49d			 
a49d			; TODO Use os stack swap memory 
a49d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a49d cd 73 9c			call macro_dsp_valuehl 
a4a0				endm 
# End of macro FORTH_DSP_VALUEHL
a4a0 e5				push hl    ; n2 
a4a1				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a1 cd 2b 9d			call macro_forth_dsp_pop 
a4a4				endm 
# End of macro FORTH_DSP_POP
a4a4			 
a4a4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4a4 cd 73 9c			call macro_dsp_valuehl 
a4a7				endm 
# End of macro FORTH_DSP_VALUEHL
a4a7 e5				push hl    ; n1 
a4a8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a8 cd 2b 9d			call macro_forth_dsp_pop 
a4ab				endm 
# End of macro FORTH_DSP_POP
a4ab			 
a4ab d1				pop de     ; n1 
a4ac e1				pop hl     ; n2 
a4ad			 
a4ad d5				push de 
a4ae e5				push hl 
a4af d5				push de 
a4b0			 
a4b0				; push back  
a4b0			 
a4b0 e1				pop hl 
a4b1 cd 6e 9a			call forth_push_numhl 
a4b4 e1				pop hl 
a4b5 cd 6e 9a			call forth_push_numhl 
a4b8 e1				pop hl 
a4b9 cd 6e 9a			call forth_push_numhl 
a4bc				NEXTW 
a4bc c3 29 9e			jp macro_next 
a4bf				endm 
# End of macro NEXTW
a4bf			 
a4bf			.PAUSE: 
a4bf			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a4bf 43				db WORD_SYS_CORE+47             
a4c0 f4 a4			dw .PAUSES            
a4c2 08				db 7 + 1 
a4c3 .. 00			db "PAUSEMS",0              
a4cb				endm 
# End of macro CWHEAD
a4cb			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a4cb				if DEBUG_FORTH_WORDS_KEY 
a4cb					DMARK "PMS" 
a4cb f5				push af  
a4cc 3a e0 a4			ld a, (.dmark)  
a4cf 32 6b ee			ld (debug_mark),a  
a4d2 3a e1 a4			ld a, (.dmark+1)  
a4d5 32 6c ee			ld (debug_mark+1),a  
a4d8 3a e2 a4			ld a, (.dmark+2)  
a4db 32 6d ee			ld (debug_mark+2),a  
a4de 18 03			jr .pastdmark  
a4e0 ..			.dmark: db "PMS"  
a4e3 f1			.pastdmark: pop af  
a4e4			endm  
# End of macro DMARK
a4e4					CALLMONITOR 
a4e4 cd 6f ee			call debug_vector  
a4e7				endm  
# End of macro CALLMONITOR
a4e7				endif 
a4e7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4e7 cd 73 9c			call macro_dsp_valuehl 
a4ea				endm 
# End of macro FORTH_DSP_VALUEHL
a4ea			;		push hl    ; n2 
a4ea				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ea cd 2b 9d			call macro_forth_dsp_pop 
a4ed				endm 
# End of macro FORTH_DSP_POP
a4ed			;		pop hl 
a4ed			 
a4ed 7d				ld a, l 
a4ee cd e2 89			call aDelayInMS 
a4f1			       NEXTW 
a4f1 c3 29 9e			jp macro_next 
a4f4				endm 
# End of macro NEXTW
a4f4			.PAUSES:  
a4f4			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a4f4 44				db WORD_SYS_CORE+48             
a4f5 63 a5			dw .ROT            
a4f7 06				db 5 + 1 
a4f8 .. 00			db "PAUSE",0              
a4fe				endm 
# End of macro CWHEAD
a4fe			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a4fe				if DEBUG_FORTH_WORDS_KEY 
a4fe					DMARK "PAU" 
a4fe f5				push af  
a4ff 3a 13 a5			ld a, (.dmark)  
a502 32 6b ee			ld (debug_mark),a  
a505 3a 14 a5			ld a, (.dmark+1)  
a508 32 6c ee			ld (debug_mark+1),a  
a50b 3a 15 a5			ld a, (.dmark+2)  
a50e 32 6d ee			ld (debug_mark+2),a  
a511 18 03			jr .pastdmark  
a513 ..			.dmark: db "PAU"  
a516 f1			.pastdmark: pop af  
a517			endm  
# End of macro DMARK
a517					CALLMONITOR 
a517 cd 6f ee			call debug_vector  
a51a				endm  
# End of macro CALLMONITOR
a51a				endif 
a51a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a51a cd 73 9c			call macro_dsp_valuehl 
a51d				endm 
# End of macro FORTH_DSP_VALUEHL
a51d			;		push hl    ; n2 
a51d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a51d cd 2b 9d			call macro_forth_dsp_pop 
a520				endm 
# End of macro FORTH_DSP_POP
a520			;		pop hl 
a520 45				ld b, l 
a521				if DEBUG_FORTH_WORDS 
a521					DMARK "PAU" 
a521 f5				push af  
a522 3a 36 a5			ld a, (.dmark)  
a525 32 6b ee			ld (debug_mark),a  
a528 3a 37 a5			ld a, (.dmark+1)  
a52b 32 6c ee			ld (debug_mark+1),a  
a52e 3a 38 a5			ld a, (.dmark+2)  
a531 32 6d ee			ld (debug_mark+2),a  
a534 18 03			jr .pastdmark  
a536 ..			.dmark: db "PAU"  
a539 f1			.pastdmark: pop af  
a53a			endm  
# End of macro DMARK
a53a					CALLMONITOR 
a53a cd 6f ee			call debug_vector  
a53d				endm  
# End of macro CALLMONITOR
a53d				endif 
a53d c5			.pauses1:	push bc 
a53e cd fd 89			call delay1s 
a541 c1				pop bc 
a542				if DEBUG_FORTH_WORDS 
a542					DMARK "PA1" 
a542 f5				push af  
a543 3a 57 a5			ld a, (.dmark)  
a546 32 6b ee			ld (debug_mark),a  
a549 3a 58 a5			ld a, (.dmark+1)  
a54c 32 6c ee			ld (debug_mark+1),a  
a54f 3a 59 a5			ld a, (.dmark+2)  
a552 32 6d ee			ld (debug_mark+2),a  
a555 18 03			jr .pastdmark  
a557 ..			.dmark: db "PA1"  
a55a f1			.pastdmark: pop af  
a55b			endm  
# End of macro DMARK
a55b					CALLMONITOR 
a55b cd 6f ee			call debug_vector  
a55e				endm  
# End of macro CALLMONITOR
a55e				endif 
a55e 10 dd			djnz .pauses1 
a560			 
a560			       NEXTW 
a560 c3 29 9e			jp macro_next 
a563				endm 
# End of macro NEXTW
a563			.ROT: 
a563			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a563 45				db WORD_SYS_CORE+49             
a564 b1 a5			dw .UWORDS            
a566 04				db 3 + 1 
a567 .. 00			db "ROT",0              
a56b				endm 
# End of macro CWHEAD
a56b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a56b				if DEBUG_FORTH_WORDS_KEY 
a56b					DMARK "ROT" 
a56b f5				push af  
a56c 3a 80 a5			ld a, (.dmark)  
a56f 32 6b ee			ld (debug_mark),a  
a572 3a 81 a5			ld a, (.dmark+1)  
a575 32 6c ee			ld (debug_mark+1),a  
a578 3a 82 a5			ld a, (.dmark+2)  
a57b 32 6d ee			ld (debug_mark+2),a  
a57e 18 03			jr .pastdmark  
a580 ..			.dmark: db "ROT"  
a583 f1			.pastdmark: pop af  
a584			endm  
# End of macro DMARK
a584					CALLMONITOR 
a584 cd 6f ee			call debug_vector  
a587				endm  
# End of macro CALLMONITOR
a587				endif 
a587			 
a587			; TODO Use os stack swap memory 
a587				FORTH_DSP_VALUEHL 
a587 cd 73 9c			call macro_dsp_valuehl 
a58a				endm 
# End of macro FORTH_DSP_VALUEHL
a58a e5				push hl    ; u3  
a58b			 
a58b				FORTH_DSP_POP 
a58b cd 2b 9d			call macro_forth_dsp_pop 
a58e				endm 
# End of macro FORTH_DSP_POP
a58e			 
a58e				FORTH_DSP_VALUEHL 
a58e cd 73 9c			call macro_dsp_valuehl 
a591				endm 
# End of macro FORTH_DSP_VALUEHL
a591 e5				push hl     ; u2 
a592			 
a592				FORTH_DSP_POP 
a592 cd 2b 9d			call macro_forth_dsp_pop 
a595				endm 
# End of macro FORTH_DSP_POP
a595			 
a595				FORTH_DSP_VALUEHL 
a595 cd 73 9c			call macro_dsp_valuehl 
a598				endm 
# End of macro FORTH_DSP_VALUEHL
a598 e5				push hl     ; u1 
a599			 
a599				FORTH_DSP_POP 
a599 cd 2b 9d			call macro_forth_dsp_pop 
a59c				endm 
# End of macro FORTH_DSP_POP
a59c			 
a59c c1				pop bc      ; u1 
a59d e1				pop hl      ; u2 
a59e d1				pop de      ; u3 
a59f			 
a59f			 
a59f c5				push bc 
a5a0 d5				push de 
a5a1 e5				push hl 
a5a2			 
a5a2			 
a5a2 e1				pop hl 
a5a3 cd 6e 9a			call forth_push_numhl 
a5a6			 
a5a6 e1				pop hl 
a5a7 cd 6e 9a			call forth_push_numhl 
a5aa			 
a5aa e1				pop hl 
a5ab cd 6e 9a			call forth_push_numhl 
a5ae				 
a5ae			 
a5ae			 
a5ae			 
a5ae			 
a5ae			 
a5ae			       NEXTW 
a5ae c3 29 9e			jp macro_next 
a5b1				endm 
# End of macro NEXTW
a5b1			 
a5b1			.UWORDS: 
a5b1			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a5b1 50				db WORD_SYS_CORE+60             
a5b2 73 a6			dw .BP            
a5b4 07				db 6 + 1 
a5b5 .. 00			db "UWORDS",0              
a5bc				endm 
# End of macro CWHEAD
a5bc			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a5bc			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a5bc			; | | Following the count are the individual words. 
a5bc			; | | 
a5bc			; | | e.g. UWORDS 
a5bc			; | | BOX DIRLIST 2 
a5bc			; | |  
a5bc			; | | Can be used to save the words to storage via: 
a5bc			; | | UWORDS $01 DO $01 APPEND LOOP 
a5bc			if DEBUG_FORTH_WORDS_KEY 
a5bc				DMARK "UWR" 
a5bc f5				push af  
a5bd 3a d1 a5			ld a, (.dmark)  
a5c0 32 6b ee			ld (debug_mark),a  
a5c3 3a d2 a5			ld a, (.dmark+1)  
a5c6 32 6c ee			ld (debug_mark+1),a  
a5c9 3a d3 a5			ld a, (.dmark+2)  
a5cc 32 6d ee			ld (debug_mark+2),a  
a5cf 18 03			jr .pastdmark  
a5d1 ..			.dmark: db "UWR"  
a5d4 f1			.pastdmark: pop af  
a5d5			endm  
# End of macro DMARK
a5d5				CALLMONITOR 
a5d5 cd 6f ee			call debug_vector  
a5d8				endm  
# End of macro CALLMONITOR
a5d8			endif 
a5d8 21 32 dd			ld hl, baseram 
a5db				;ld hl, baseusermem 
a5db 01 00 00			ld bc, 0    ; start a counter 
a5de			 
a5de			; skip dict stub 
a5de			 
a5de cd 7a 9f			call forth_tok_next 
a5e1			 
a5e1			 
a5e1			; while we have words to look for 
a5e1			 
a5e1 7e			.douscan:	ld a, (hl)      
a5e2			if DEBUG_FORTH_WORDS 
a5e2				DMARK "UWs" 
a5e2 f5				push af  
a5e3 3a f7 a5			ld a, (.dmark)  
a5e6 32 6b ee			ld (debug_mark),a  
a5e9 3a f8 a5			ld a, (.dmark+1)  
a5ec 32 6c ee			ld (debug_mark+1),a  
a5ef 3a f9 a5			ld a, (.dmark+2)  
a5f2 32 6d ee			ld (debug_mark+2),a  
a5f5 18 03			jr .pastdmark  
a5f7 ..			.dmark: db "UWs"  
a5fa f1			.pastdmark: pop af  
a5fb			endm  
# End of macro DMARK
a5fb				CALLMONITOR 
a5fb cd 6f ee			call debug_vector  
a5fe				endm  
# End of macro CALLMONITOR
a5fe			endif 
a5fe fe 00			cp WORD_SYS_END 
a600 28 4d			jr z, .udone 
a602 fe 01			cp WORD_SYS_UWORD 
a604 20 44			jr nz, .nuword 
a606			 
a606			if DEBUG_FORTH_WORDS 
a606				DMARK "UWu" 
a606 f5				push af  
a607 3a 1b a6			ld a, (.dmark)  
a60a 32 6b ee			ld (debug_mark),a  
a60d 3a 1c a6			ld a, (.dmark+1)  
a610 32 6c ee			ld (debug_mark+1),a  
a613 3a 1d a6			ld a, (.dmark+2)  
a616 32 6d ee			ld (debug_mark+2),a  
a619 18 03			jr .pastdmark  
a61b ..			.dmark: db "UWu"  
a61e f1			.pastdmark: pop af  
a61f			endm  
# End of macro DMARK
a61f				CALLMONITOR 
a61f cd 6f ee			call debug_vector  
a622				endm  
# End of macro CALLMONITOR
a622			endif 
a622				; we have a uword so push its name to the stack 
a622			 
a622 e5				push hl  ; save so we can move to next dict block 
a623			 
a623				; skip opcode 
a623 23				inc hl  
a624				; skip next ptr 
a624 23				inc hl  
a625 23				inc hl 
a626				; skip len 
a626 23				inc hl 
a627			if DEBUG_FORTH_WORDS 
a627				DMARK "UWt" 
a627 f5				push af  
a628 3a 3c a6			ld a, (.dmark)  
a62b 32 6b ee			ld (debug_mark),a  
a62e 3a 3d a6			ld a, (.dmark+1)  
a631 32 6c ee			ld (debug_mark+1),a  
a634 3a 3e a6			ld a, (.dmark+2)  
a637 32 6d ee			ld (debug_mark+2),a  
a63a 18 03			jr .pastdmark  
a63c ..			.dmark: db "UWt"  
a63f f1			.pastdmark: pop af  
a640			endm  
# End of macro DMARK
a640				CALLMONITOR 
a640 cd 6f ee			call debug_vector  
a643				endm  
# End of macro CALLMONITOR
a643			endif 
a643 03				inc bc 
a644			 
a644 c5				push bc 
a645 cd dc 9a			call forth_push_str 
a648 c1				pop bc 
a649			 
a649 e1				pop hl 	 
a64a			 
a64a cd 7a 9f		.nuword:	call forth_tok_next 
a64d 18 92			jr .douscan  
a64f			 
a64f			.udone:		 ; push count of uwords found 
a64f c5				push bc 
a650 e1				pop hl 
a651			 
a651			if DEBUG_FORTH_WORDS 
a651				DMARK "UWc" 
a651 f5				push af  
a652 3a 66 a6			ld a, (.dmark)  
a655 32 6b ee			ld (debug_mark),a  
a658 3a 67 a6			ld a, (.dmark+1)  
a65b 32 6c ee			ld (debug_mark+1),a  
a65e 3a 68 a6			ld a, (.dmark+2)  
a661 32 6d ee			ld (debug_mark+2),a  
a664 18 03			jr .pastdmark  
a666 ..			.dmark: db "UWc"  
a669 f1			.pastdmark: pop af  
a66a			endm  
# End of macro DMARK
a66a				CALLMONITOR 
a66a cd 6f ee			call debug_vector  
a66d				endm  
# End of macro CALLMONITOR
a66d			endif 
a66d cd 6e 9a			call forth_push_numhl 
a670			 
a670			 
a670			       NEXTW 
a670 c3 29 9e			jp macro_next 
a673				endm 
# End of macro NEXTW
a673			 
a673			.BP: 
a673			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a673 54				db WORD_SYS_CORE+64             
a674 ad a6			dw .MONITOR            
a676 03				db 2 + 1 
a677 .. 00			db "BP",0              
a67a				endm 
# End of macro CWHEAD
a67a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a67a			; | | $00 Will enable the break points within specific code paths 
a67a			; | | $01 Will disable break points 
a67a			; | |  
a67a			; | | By default break points are off. Either the above can be used to enable them 
a67a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a67a			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a67a			; | | can disable break points. Exiting will then continue boot process. 
a67a				; get byte count 
a67a				if DEBUG_FORTH_WORDS_KEY 
a67a					DMARK "BP." 
a67a f5				push af  
a67b 3a 8f a6			ld a, (.dmark)  
a67e 32 6b ee			ld (debug_mark),a  
a681 3a 90 a6			ld a, (.dmark+1)  
a684 32 6c ee			ld (debug_mark+1),a  
a687 3a 91 a6			ld a, (.dmark+2)  
a68a 32 6d ee			ld (debug_mark+2),a  
a68d 18 03			jr .pastdmark  
a68f ..			.dmark: db "BP."  
a692 f1			.pastdmark: pop af  
a693			endm  
# End of macro DMARK
a693					CALLMONITOR 
a693 cd 6f ee			call debug_vector  
a696				endm  
# End of macro CALLMONITOR
a696				endif 
a696			 
a696				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a696 cd 73 9c			call macro_dsp_valuehl 
a699				endm 
# End of macro FORTH_DSP_VALUEHL
a699			 
a699			;		push hl 
a699			 
a699				; destroy value TOS 
a699			 
a699				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a699 cd 2b 9d			call macro_forth_dsp_pop 
a69c				endm 
# End of macro FORTH_DSP_POP
a69c			 
a69c			;		pop hl 
a69c			 
a69c 3e 00			ld a,0 
a69e bd				cp l 
a69f 28 06			jr z, .bpset 
a6a1			;		ld a, '*' 
a6a1 cd fd 93			call bp_off 
a6a4				NEXTW 
a6a4 c3 29 9e			jp macro_next 
a6a7				endm 
# End of macro NEXTW
a6a7			 
a6a7			.bpset:	 
a6a7				;	ld (os_view_disable), a 
a6a7 cd f1 93			call bp_on 
a6aa			 
a6aa			 
a6aa				NEXTW 
a6aa c3 29 9e			jp macro_next 
a6ad				endm 
# End of macro NEXTW
a6ad			 
a6ad			 
a6ad			.MONITOR: 
a6ad			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a6ad 55				db WORD_SYS_CORE+65             
a6ae de a6			dw .MALLOC            
a6b0 08				db 7 + 1 
a6b1 .. 00			db "MONITOR",0              
a6b9				endm 
# End of macro CWHEAD
a6b9			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a6b9			; | | At start the current various registers will be displayed with contents. 
a6b9			; | | Top right corner will show the most recent debug marker seen. 
a6b9			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a6b9			; | | and the return stack pointer (RSP). 
a6b9			; | | Pressing: 
a6b9			; | |    1 - Initial screen 
a6b9			; | |    2 - Display a data dump of HL 
a6b9			; | |    3 - Display a data dump of DE 
a6b9			; | |    4 - Display a data dump of BC 
a6b9			; | |    5 - Display a data dump of HL 
a6b9			; | |    6 - Display a data dump of DSP 
a6b9			; | |    7 - Display a data dump of RSP 
a6b9			; | |    8 - Display a data dump of what is at DSP 
a6b9			; | |    9 - Display a data dump of what is at RSP 
a6b9			; | |    0 - Exit monitor and continue running. This will also enable break points 
a6b9			; | |    * - Disable break points 
a6b9			; | |    # - Enter traditional monitor mode 
a6b9			; | | 
a6b9			; | | Monitor Mode 
a6b9			; | | ------------ 
a6b9			; | | A prompt of '>' will be shown for various commands: 
a6b9			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a6b9			; | |    C - Continue display a data dump from the last set address 
a6b9			; | |    M xxxx - Set start of memory edit at address xx 
a6b9			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a6b9			; | |    G xxxx - Exec code at specific address 
a6b9			; | |    Q - Return to previous 
a6b9				if DEBUG_FORTH_WORDS_KEY 
a6b9					DMARK "MON" 
a6b9 f5				push af  
a6ba 3a ce a6			ld a, (.dmark)  
a6bd 32 6b ee			ld (debug_mark),a  
a6c0 3a cf a6			ld a, (.dmark+1)  
a6c3 32 6c ee			ld (debug_mark+1),a  
a6c6 3a d0 a6			ld a, (.dmark+2)  
a6c9 32 6d ee			ld (debug_mark+2),a  
a6cc 18 03			jr .pastdmark  
a6ce ..			.dmark: db "MON"  
a6d1 f1			.pastdmark: pop af  
a6d2			endm  
# End of macro DMARK
a6d2					CALLMONITOR 
a6d2 cd 6f ee			call debug_vector  
a6d5				endm  
# End of macro CALLMONITOR
a6d5				endif 
a6d5			;		ld a, 0 
a6d5			;		ld (os_view_disable), a 
a6d5 cd f1 93			call bp_on 
a6d8			 
a6d8				CALLMONITOR 
a6d8 cd 6f ee			call debug_vector  
a6db				endm  
# End of macro CALLMONITOR
a6db			 
a6db			;	call monitor 
a6db			 
a6db				NEXTW 
a6db c3 29 9e			jp macro_next 
a6de				endm 
# End of macro NEXTW
a6de			 
a6de			 
a6de			.MALLOC: 
a6de			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a6de 56				db WORD_SYS_CORE+66             
a6df 07 a7			dw .MALLOC2            
a6e1 06				db 5 + 1 
a6e2 .. 00			db "ALLOT",0              
a6e8				endm 
# End of macro CWHEAD
a6e8			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a6e8				if DEBUG_FORTH_WORDS_KEY 
a6e8					DMARK "ALL" 
a6e8 f5				push af  
a6e9 3a fd a6			ld a, (.dmark)  
a6ec 32 6b ee			ld (debug_mark),a  
a6ef 3a fe a6			ld a, (.dmark+1)  
a6f2 32 6c ee			ld (debug_mark+1),a  
a6f5 3a ff a6			ld a, (.dmark+2)  
a6f8 32 6d ee			ld (debug_mark+2),a  
a6fb 18 03			jr .pastdmark  
a6fd ..			.dmark: db "ALL"  
a700 f1			.pastdmark: pop af  
a701			endm  
# End of macro DMARK
a701					CALLMONITOR 
a701 cd 6f ee			call debug_vector  
a704				endm  
# End of macro CALLMONITOR
a704				endif 
a704 c3 2e a7			jp .mallocc 
a707			.MALLOC2: 
a707			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a707 56				db WORD_SYS_CORE+66             
a708 45 a7			dw .FREE            
a70a 07				db 6 + 1 
a70b .. 00			db "MALLOC",0              
a712				endm 
# End of macro CWHEAD
a712			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a712				; get byte count 
a712				if DEBUG_FORTH_WORDS_KEY 
a712					DMARK "MAL" 
a712 f5				push af  
a713 3a 27 a7			ld a, (.dmark)  
a716 32 6b ee			ld (debug_mark),a  
a719 3a 28 a7			ld a, (.dmark+1)  
a71c 32 6c ee			ld (debug_mark+1),a  
a71f 3a 29 a7			ld a, (.dmark+2)  
a722 32 6d ee			ld (debug_mark+2),a  
a725 18 03			jr .pastdmark  
a727 ..			.dmark: db "MAL"  
a72a f1			.pastdmark: pop af  
a72b			endm  
# End of macro DMARK
a72b					CALLMONITOR 
a72b cd 6f ee			call debug_vector  
a72e				endm  
# End of macro CALLMONITOR
a72e				endif 
a72e			.mallocc: 
a72e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a72e cd 73 9c			call macro_dsp_valuehl 
a731				endm 
# End of macro FORTH_DSP_VALUEHL
a731			 
a731			;		push hl 
a731			 
a731				; destroy value TOS 
a731			 
a731				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a731 cd 2b 9d			call macro_forth_dsp_pop 
a734				endm 
# End of macro FORTH_DSP_POP
a734			 
a734			;		pop hl 
a734 cd c2 90			call malloc 
a737			if DEBUG_FORTH_MALLOC_GUARD 
a737 f5				push af 
a738 cd 10 8d			call ishlzero 
a73b			;		ld a, l 
a73b			;		add h 
a73b			;		cp 0 
a73b f1				pop af 
a73c				 
a73c cc f5 cb			call z,malloc_error 
a73f			endif 
a73f			 
a73f cd 6e 9a			call forth_push_numhl 
a742				NEXTW 
a742 c3 29 9e			jp macro_next 
a745				endm 
# End of macro NEXTW
a745			 
a745			.FREE: 
a745			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a745 57				db WORD_SYS_CORE+67             
a746 76 a7			dw .LIST            
a748 05				db 4 + 1 
a749 .. 00			db "FREE",0              
a74e				endm 
# End of macro CWHEAD
a74e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a74e				if DEBUG_FORTH_WORDS_KEY 
a74e					DMARK "FRE" 
a74e f5				push af  
a74f 3a 63 a7			ld a, (.dmark)  
a752 32 6b ee			ld (debug_mark),a  
a755 3a 64 a7			ld a, (.dmark+1)  
a758 32 6c ee			ld (debug_mark+1),a  
a75b 3a 65 a7			ld a, (.dmark+2)  
a75e 32 6d ee			ld (debug_mark+2),a  
a761 18 03			jr .pastdmark  
a763 ..			.dmark: db "FRE"  
a766 f1			.pastdmark: pop af  
a767			endm  
# End of macro DMARK
a767					CALLMONITOR 
a767 cd 6f ee			call debug_vector  
a76a				endm  
# End of macro CALLMONITOR
a76a				endif 
a76a				; get address 
a76a			 
a76a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a76a cd 73 9c			call macro_dsp_valuehl 
a76d				endm 
# End of macro FORTH_DSP_VALUEHL
a76d			 
a76d			;		push hl 
a76d			 
a76d				; destroy value TOS 
a76d			 
a76d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a76d cd 2b 9d			call macro_forth_dsp_pop 
a770				endm 
# End of macro FORTH_DSP_POP
a770			 
a770			;		pop hl 
a770			if FORTH_ENABLE_MALLOCFREE 
a770 cd 8c 91			call free 
a773			endif 
a773				NEXTW 
a773 c3 29 9e			jp macro_next 
a776				endm 
# End of macro NEXTW
a776			.LIST: 
a776			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a776 5c				db WORD_SYS_CORE+72             
a777 72 a9			dw .FORGET            
a779 05				db 4 + 1 
a77a .. 00			db "LIST",0              
a77f				endm 
# End of macro CWHEAD
a77f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a77f			; | | The quoted word must be in upper case. 
a77f			if DEBUG_FORTH_WORDS_KEY 
a77f				DMARK "LST" 
a77f f5				push af  
a780 3a 94 a7			ld a, (.dmark)  
a783 32 6b ee			ld (debug_mark),a  
a786 3a 95 a7			ld a, (.dmark+1)  
a789 32 6c ee			ld (debug_mark+1),a  
a78c 3a 96 a7			ld a, (.dmark+2)  
a78f 32 6d ee			ld (debug_mark+2),a  
a792 18 03			jr .pastdmark  
a794 ..			.dmark: db "LST"  
a797 f1			.pastdmark: pop af  
a798			endm  
# End of macro DMARK
a798				CALLMONITOR 
a798 cd 6f ee			call debug_vector  
a79b				endm  
# End of macro CALLMONITOR
a79b			endif 
a79b			 
a79b				FORTH_DSP_VALUEHL 
a79b cd 73 9c			call macro_dsp_valuehl 
a79e				endm 
# End of macro FORTH_DSP_VALUEHL
a79e			 
a79e e5				push hl 
a79f				FORTH_DSP_POP 
a79f cd 2b 9d			call macro_forth_dsp_pop 
a7a2				endm 
# End of macro FORTH_DSP_POP
a7a2 c1				pop bc 
a7a3			 
a7a3			; Start format of scratch string 
a7a3			 
a7a3 21 c1 e2			ld hl, scratch 
a7a6			 
a7a6 3e 3a			ld a, ':' 
a7a8 77				ld (hl),a 
a7a9 23				inc hl 
a7aa 3e 20			ld a, ' ' 
a7ac 77				ld (hl), a 
a7ad			 
a7ad				; Get ptr to the word we need to look up 
a7ad			 
a7ad			;		FORTH_DSP_VALUEHL 
a7ad				;v5 FORTH_DSP_VALUE 
a7ad			; TODO type check 
a7ad			;		inc hl    ; Skip type check  
a7ad			;		push hl 
a7ad			;		ex de, hl    ; put into DE 
a7ad			 
a7ad			 
a7ad 21 32 dd			ld hl, baseram 
a7b0				;ld hl, baseusermem 
a7b0			 
a7b0 e5			push hl   ; sacreifical push 
a7b1			 
a7b1			.ldouscanm: 
a7b1 e1			pop hl 
a7b2			.ldouscan: 
a7b2			if DEBUG_FORTH_WORDS 
a7b2				DMARK "LSs" 
a7b2 f5				push af  
a7b3 3a c7 a7			ld a, (.dmark)  
a7b6 32 6b ee			ld (debug_mark),a  
a7b9 3a c8 a7			ld a, (.dmark+1)  
a7bc 32 6c ee			ld (debug_mark+1),a  
a7bf 3a c9 a7			ld a, (.dmark+2)  
a7c2 32 6d ee			ld (debug_mark+2),a  
a7c5 18 03			jr .pastdmark  
a7c7 ..			.dmark: db "LSs"  
a7ca f1			.pastdmark: pop af  
a7cb			endm  
# End of macro DMARK
a7cb				CALLMONITOR 
a7cb cd 6f ee			call debug_vector  
a7ce				endm  
# End of macro CALLMONITOR
a7ce			endif 
a7ce			; skip dict stub 
a7ce cd 7a 9f			call forth_tok_next 
a7d1			 
a7d1			 
a7d1			; while we have words to look for 
a7d1			 
a7d1 7e			ld a, (hl)      
a7d2			if DEBUG_FORTH_WORDS 
a7d2				DMARK "LSk" 
a7d2 f5				push af  
a7d3 3a e7 a7			ld a, (.dmark)  
a7d6 32 6b ee			ld (debug_mark),a  
a7d9 3a e8 a7			ld a, (.dmark+1)  
a7dc 32 6c ee			ld (debug_mark+1),a  
a7df 3a e9 a7			ld a, (.dmark+2)  
a7e2 32 6d ee			ld (debug_mark+2),a  
a7e5 18 03			jr .pastdmark  
a7e7 ..			.dmark: db "LSk"  
a7ea f1			.pastdmark: pop af  
a7eb			endm  
# End of macro DMARK
a7eb				CALLMONITOR 
a7eb cd 6f ee			call debug_vector  
a7ee				endm  
# End of macro CALLMONITOR
a7ee			endif 
a7ee				;cp WORD_SYS_END 
a7ee				;jp z, .lunotfound 
a7ee			 
a7ee					; if we hit non uwords then gone too far 
a7ee fe 01				cp WORD_SYS_UWORD 
a7f0 c2 2e a9				jp nz, .lunotfound 
a7f3			 
a7f3				if DEBUG_FORTH_WORDS 
a7f3					DMARK "LSu" 
a7f3 f5				push af  
a7f4 3a 08 a8			ld a, (.dmark)  
a7f7 32 6b ee			ld (debug_mark),a  
a7fa 3a 09 a8			ld a, (.dmark+1)  
a7fd 32 6c ee			ld (debug_mark+1),a  
a800 3a 0a a8			ld a, (.dmark+2)  
a803 32 6d ee			ld (debug_mark+2),a  
a806 18 03			jr .pastdmark  
a808 ..			.dmark: db "LSu"  
a80b f1			.pastdmark: pop af  
a80c			endm  
# End of macro DMARK
a80c					CALLMONITOR 
a80c cd 6f ee			call debug_vector  
a80f				endm  
# End of macro CALLMONITOR
a80f				endif 
a80f			 
a80f					; found a uword but is it the one we want... 
a80f			 
a80f c5					push bc     ; uword to find is on bc 
a810 d1					pop de 
a811			 
a811 e5					push hl  ; to save the ptr 
a812			 
a812					; skip opcode 
a812 23					inc hl  
a813					; skip next ptr 
a813 23					inc hl  
a814 23					inc hl 
a815					; skip len 
a815 23					inc hl 
a816			 
a816				if DEBUG_FORTH_WORDS 
a816					DMARK "LSc" 
a816 f5				push af  
a817 3a 2b a8			ld a, (.dmark)  
a81a 32 6b ee			ld (debug_mark),a  
a81d 3a 2c a8			ld a, (.dmark+1)  
a820 32 6c ee			ld (debug_mark+1),a  
a823 3a 2d a8			ld a, (.dmark+2)  
a826 32 6d ee			ld (debug_mark+2),a  
a829 18 03			jr .pastdmark  
a82b ..			.dmark: db "LSc"  
a82e f1			.pastdmark: pop af  
a82f			endm  
# End of macro DMARK
a82f					CALLMONITOR 
a82f cd 6f ee			call debug_vector  
a832				endm  
# End of macro CALLMONITOR
a832				endif 
a832			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a832			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a832			; Nope that has gone the other way. It needs to be exact not on first zero 
a832			;		call strcmp 
a832 c5					push bc 
a833 cd 92 90				call StrictStrCmp 
a836 c1					pop bc 
a837 c2 b1 a7				jp nz, .ldouscanm 
a83a				 
a83a			 
a83a			 
a83a					; we have a uword so push its name to the stack 
a83a			 
a83a			;	   	push hl  ; save so we can move to next dict block 
a83a e1			pop hl 
a83b			 
a83b				if DEBUG_FORTH_WORDS 
a83b					DMARK "LSm" 
a83b f5				push af  
a83c 3a 50 a8			ld a, (.dmark)  
a83f 32 6b ee			ld (debug_mark),a  
a842 3a 51 a8			ld a, (.dmark+1)  
a845 32 6c ee			ld (debug_mark+1),a  
a848 3a 52 a8			ld a, (.dmark+2)  
a84b 32 6d ee			ld (debug_mark+2),a  
a84e 18 03			jr .pastdmark  
a850 ..			.dmark: db "LSm"  
a853 f1			.pastdmark: pop af  
a854			endm  
# End of macro DMARK
a854					CALLMONITOR 
a854 cd 6f ee			call debug_vector  
a857				endm  
# End of macro CALLMONITOR
a857				endif 
a857			 
a857					; skip opcode 
a857 23					inc hl  
a858					; skip next ptr 
a858 23					inc hl  
a859 23					inc hl 
a85a					; skip len 
a85a 7e					ld a, (hl)   ; save length to add 
a85b				if DEBUG_FORTH_WORDS 
a85b					DMARK "LS2" 
a85b f5				push af  
a85c 3a 70 a8			ld a, (.dmark)  
a85f 32 6b ee			ld (debug_mark),a  
a862 3a 71 a8			ld a, (.dmark+1)  
a865 32 6c ee			ld (debug_mark+1),a  
a868 3a 72 a8			ld a, (.dmark+2)  
a86b 32 6d ee			ld (debug_mark+2),a  
a86e 18 03			jr .pastdmark  
a870 ..			.dmark: db "LS2"  
a873 f1			.pastdmark: pop af  
a874			endm  
# End of macro DMARK
a874					CALLMONITOR 
a874 cd 6f ee			call debug_vector  
a877				endm  
# End of macro CALLMONITOR
a877				endif 
a877			 
a877					; save this location 
a877				 
a877 e5					push hl 
a878			 
a878 23					inc hl 
a879 11 c3 e2				ld de, scratch+2 
a87c 4f					ld c, a 
a87d 06 00				ld b, 0 
a87f			 
a87f				if DEBUG_FORTH_WORDS 
a87f					DMARK "LSn" 
a87f f5				push af  
a880 3a 94 a8			ld a, (.dmark)  
a883 32 6b ee			ld (debug_mark),a  
a886 3a 95 a8			ld a, (.dmark+1)  
a889 32 6c ee			ld (debug_mark+1),a  
a88c 3a 96 a8			ld a, (.dmark+2)  
a88f 32 6d ee			ld (debug_mark+2),a  
a892 18 03			jr .pastdmark  
a894 ..			.dmark: db "LSn"  
a897 f1			.pastdmark: pop af  
a898			endm  
# End of macro DMARK
a898					CALLMONITOR 
a898 cd 6f ee			call debug_vector  
a89b				endm  
# End of macro CALLMONITOR
a89b				endif 
a89b			 
a89b					; copy uword name to scratch 
a89b			 
a89b			;		ldir 
a89b			.licplw:	; copy uword name to scratch converting to lower case as we go 
a89b ed a0				ldi 
a89d 1b					dec de 
a89e 1a					ld a, (de) 
a89f cd 65 8f				call to_lower 
a8a2 12					ld (de),a 
a8a3 13					inc de 
a8a4 3e 00				ld a, 0 
a8a6 b9					cp c 
a8a7 20 f2				jr nz, .licplw 
a8a9			 
a8a9			 
a8a9			 
a8a9 1b					dec de 
a8aa 3e 20				ld a, ' '    ; change null to space 
a8ac 12					ld (de), a 
a8ad			 
a8ad 13					inc de 
a8ae			 
a8ae d5					push de 
a8af c1					pop bc     ; move scratch pointer to end of word name and save it 
a8b0			 
a8b0 e1					pop hl 
a8b1 7e					ld a, (hl) 
a8b2					;inc hl 
a8b2					; skip word string 
a8b2 cd e7 8c				call addatohl 
a8b5			 
a8b5 23					inc hl 
a8b6			 
a8b6				if DEBUG_FORTH_WORDS 
a8b6					DMARK "LS3" 
a8b6 f5				push af  
a8b7 3a cb a8			ld a, (.dmark)  
a8ba 32 6b ee			ld (debug_mark),a  
a8bd 3a cc a8			ld a, (.dmark+1)  
a8c0 32 6c ee			ld (debug_mark+1),a  
a8c3 3a cd a8			ld a, (.dmark+2)  
a8c6 32 6d ee			ld (debug_mark+2),a  
a8c9 18 03			jr .pastdmark  
a8cb ..			.dmark: db "LS3"  
a8ce f1			.pastdmark: pop af  
a8cf			endm  
# End of macro DMARK
a8cf					CALLMONITOR 
a8cf cd 6f ee			call debug_vector  
a8d2				endm  
# End of macro CALLMONITOR
a8d2				endif 
a8d2					; should now be at the start of the machine code to setup the eval of the uword 
a8d2					; now locate the ptr to the string defintion 
a8d2			 
a8d2					; skip ld hl, 
a8d2					; then load the ptr 
a8d2			; TODO use get from hl ptr 
a8d2 23					inc hl 
a8d3 5e					ld e, (hl) 
a8d4 23					inc hl 
a8d5 56					ld d, (hl) 
a8d6 eb					ex de, hl 
a8d7			 
a8d7			 
a8d7				if DEBUG_FORTH_WORDS 
a8d7					DMARK "LSt" 
a8d7 f5				push af  
a8d8 3a ec a8			ld a, (.dmark)  
a8db 32 6b ee			ld (debug_mark),a  
a8de 3a ed a8			ld a, (.dmark+1)  
a8e1 32 6c ee			ld (debug_mark+1),a  
a8e4 3a ee a8			ld a, (.dmark+2)  
a8e7 32 6d ee			ld (debug_mark+2),a  
a8ea 18 03			jr .pastdmark  
a8ec ..			.dmark: db "LSt"  
a8ef f1			.pastdmark: pop af  
a8f0			endm  
# End of macro DMARK
a8f0					CALLMONITOR 
a8f0 cd 6f ee			call debug_vector  
a8f3				endm  
# End of macro CALLMONITOR
a8f3				endif 
a8f3			 
a8f3			; cant push right now due to tokenised strings  
a8f3			 
a8f3			; get the destination of where to copy this definition to. 
a8f3			 
a8f3 c5					push bc 
a8f4 d1					pop de 
a8f5			 
a8f5 7e			.listl:         ld a,(hl) 
a8f6 fe 00				cp 0 
a8f8 28 09				jr z, .lreplsp     ; replace zero with space 
a8fa					;cp FORTH_END_BUFFER 
a8fa fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a8fc 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a8fe				 
a8fe					; just copy this char as is then 
a8fe			 
a8fe 12					ld (de), a 
a8ff			 
a8ff 23			.listnxt:	inc hl 
a900 13					inc de 
a901 18 f2				jr .listl 
a903			 
a903 3e 20		.lreplsp:	ld a,' ' 
a905 12					ld (de), a 
a906 18 f7				jr .listnxt 
a908			 
a908			; close up uword def 
a908			 
a908			.listdone: 
a908 12					ld (de), a 
a909 13					inc de 
a90a 3e 00				ld a, 0 
a90c 12					ld (de), a 
a90d			 
a90d			; now have def so clean up and push to stack 
a90d			 
a90d 21 c1 e2				ld hl, scratch 
a910				if DEBUG_FORTH_WORDS 
a910					DMARK "Ltp" 
a910 f5				push af  
a911 3a 25 a9			ld a, (.dmark)  
a914 32 6b ee			ld (debug_mark),a  
a917 3a 26 a9			ld a, (.dmark+1)  
a91a 32 6c ee			ld (debug_mark+1),a  
a91d 3a 27 a9			ld a, (.dmark+2)  
a920 32 6d ee			ld (debug_mark+2),a  
a923 18 03			jr .pastdmark  
a925 ..			.dmark: db "Ltp"  
a928 f1			.pastdmark: pop af  
a929			endm  
# End of macro DMARK
a929					CALLMONITOR 
a929 cd 6f ee			call debug_vector  
a92c				endm  
# End of macro CALLMONITOR
a92c				endif 
a92c			 
a92c 18 1f			jr .listpush 
a92e			 
a92e			;.lnuword:	pop hl 
a92e			;		call forth_tok_next 
a92e			;		jp .ldouscan  
a92e			 
a92e			.lunotfound:		  
a92e			 
a92e				if DEBUG_FORTH_WORDS 
a92e					DMARK "LSn" 
a92e f5				push af  
a92f 3a 43 a9			ld a, (.dmark)  
a932 32 6b ee			ld (debug_mark),a  
a935 3a 44 a9			ld a, (.dmark+1)  
a938 32 6c ee			ld (debug_mark+1),a  
a93b 3a 45 a9			ld a, (.dmark+2)  
a93e 32 6d ee			ld (debug_mark+2),a  
a941 18 03			jr .pastdmark  
a943 ..			.dmark: db "LSn"  
a946 f1			.pastdmark: pop af  
a947			endm  
# End of macro DMARK
a947					CALLMONITOR 
a947 cd 6f ee			call debug_vector  
a94a				endm  
# End of macro CALLMONITOR
a94a				endif 
a94a			 
a94a					 
a94a			;		FORTH_DSP_POP 
a94a			;		ld hl, .luno 
a94a			 
a94a					NEXTW			 
a94a c3 29 9e			jp macro_next 
a94d				endm 
# End of macro NEXTW
a94d			 
a94d			.listpush: 
a94d				if DEBUG_FORTH_WORDS 
a94d					DMARK "LS>" 
a94d f5				push af  
a94e 3a 62 a9			ld a, (.dmark)  
a951 32 6b ee			ld (debug_mark),a  
a954 3a 63 a9			ld a, (.dmark+1)  
a957 32 6c ee			ld (debug_mark+1),a  
a95a 3a 64 a9			ld a, (.dmark+2)  
a95d 32 6d ee			ld (debug_mark+2),a  
a960 18 03			jr .pastdmark  
a962 ..			.dmark: db "LS>"  
a965 f1			.pastdmark: pop af  
a966			endm  
# End of macro DMARK
a966					CALLMONITOR 
a966 cd 6f ee			call debug_vector  
a969				endm  
# End of macro CALLMONITOR
a969				endif 
a969 cd dc 9a				call forth_push_str 
a96c			 
a96c			 
a96c			 
a96c					NEXTW 
a96c c3 29 9e			jp macro_next 
a96f				endm 
# End of macro NEXTW
a96f			 
a96f			;.luno:    db "Word not found",0 
a96f			 
a96f			 
a96f			 
a96f			 
a96f			 
a96f			;		push hl   ; save pointer to start of uword def string 
a96f			; 
a96f			;; look for FORTH_EOL_LINE 
a96f			;		ld a, FORTH_END_BUFFER 
a96f			;		call strlent 
a96f			; 
a96f			;		inc hl		 ; space for coln def 
a96f			;		inc hl 
a96f			;		inc hl          ; space for terms 
a96f			;		inc hl 
a96f			; 
a96f			;		ld a, 20   ; TODO get actual length 
a96f			;		call addatohl    ; include a random amount of room for the uword name 
a96f			; 
a96f			;		 
a96f			;	if DEBUG_FORTH_WORDS 
a96f			;		DMARK "Lt1" 
a96f			;		CALLMONITOR 
a96f			;	endif 
a96f			;		 
a96f			; 
a96f			;; malloc space for the string because we cant change it 
a96f			; 
a96f			;		call malloc 
a96f			;	if DEBUG_FORTH_MALLOC_GUARD 
a96f			;		push af 
a96f			;		call ishlzero 
a96f			;		pop af 
a96f			;		 
a96f			;		call z,malloc_error 
a96f			;	endif 
a96f			; 
a96f			;	if DEBUG_FORTH_WORDS 
a96f			;		DMARK "Lt2" 
a96f			;		CALLMONITOR 
a96f			;	endif 
a96f			;		pop de 
a96f			;		push hl    ; push the malloc to release later 
a96f			;		push hl   ;  push back a copy for the later stack push 
a96f			;		 
a96f			;; copy the string swapping out the zero terms for spaces 
a96f			; 
a96f			;		; de has our source 
a96f			;		; hl has our dest 
a96f			; 
a96f			;; add the coln def 
a96f			; 
a96f			;		ld a, ':' 
a96f			;		ld (hl), a 
a96f			;		inc hl 
a96f			;		ld a, ' ' 
a96f			;		ld (hl), a 
a96f			;		inc hl 
a96f			; 
a96f			;; add the uname word 
a96f			;		push de   ; save our string for now 
a96f			;		ex de, hl 
a96f			; 
a96f			;		FORTH_DSP_VALUE 
a96f			;		;v5 FORTH_DSP_VALUE 
a96f			; 
a96f			;		inc hl   ; skip type but we know by now this is OK 
a96f			; 
a96f			;.luword:	ld a,(hl) 
a96f			;		cp 0 
a96f			;		jr z, .luword2 
a96f			;		ld (de), a 
a96f			;		inc de 
a96f			;		inc hl 
a96f			;		jr .luword 
a96f			; 
a96f			;.luword2:	ld a, ' ' 
a96f			;		ld (de), a 
a96f			;;		inc hl 
a96f			;;		inc de 
a96f			;;		ld (de), a 
a96f			;;		inc hl 
a96f			;		inc de 
a96f			; 
a96f			;		ex de, hl 
a96f			;		pop de 
a96f			;		 
a96f			;		 
a96f			; 
a96f			;; detoken that string and copy it 
a96f			; 
a96f			;	if DEBUG_FORTH_WORDS 
a96f			;		DMARK "Lt2" 
a96f			;		CALLMONITOR 
a96f			;	endif 
a96f			;.ldetok:	ld a, (de) 
a96f			;		cp FORTH_END_BUFFER 
a96f			;		jr z, .ldetokend 
a96f			;		; swap out any zero term for space 
a96f			;		cp 0 
a96f			;		jr nz, .ldetoknext 
a96f			;		ld a, ' ' 
a96f			; 
a96f			;	if DEBUG_FORTH_WORDS 
a96f			;		DMARK "LtS" 
a96f			;		CALLMONITOR 
a96f			;	endif 
a96f			;.ldetoknext:	ld (hl), a 
a96f			;		inc de 
a96f			;		inc hl 
a96f			;		jr .ldetok 
a96f			; 
a96f			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a96f			;		ld (hl), a  
a96f			; 
a96f			;; free that temp malloc 
a96f			; 
a96f			;		pop hl    
a96f			; 
a96f			;	if DEBUG_FORTH_WORDS 
a96f			;		DMARK "Lt4" 
a96f			;		CALLMONITOR 
a96f			;	endif 
a96f			;		call forth_apushstrhl 
a96f			; 
a96f			;		; get rid of temp malloc area 
a96f			; 
a96f			;		pop hl 
a96f			;		call free 
a96f			; 
a96f			;		jr .ludone 
a96f			; 
a96f			;.lnuword:	pop hl 
a96f			;		call forth_tok_next 
a96f			;		jp .ldouscan  
a96f			; 
a96f			;.ludone:		 pop hl 
a96f			; 
a96f					NEXTW 
a96f c3 29 9e			jp macro_next 
a972				endm 
# End of macro NEXTW
a972			 
a972			.FORGET: 
a972				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a972 5d				db WORD_SYS_CORE+73             
a973 eb a9			dw .NOP            
a975 07				db 6 + 1 
a976 .. 00			db "FORGET",0              
a97d				endm 
# End of macro CWHEAD
a97d			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a97d			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
a97d			; | |  
a97d			; | | e.g. "MORE" forget 
a97d					if DEBUG_FORTH_WORDS_KEY 
a97d						DMARK "FRG" 
a97d f5				push af  
a97e 3a 92 a9			ld a, (.dmark)  
a981 32 6b ee			ld (debug_mark),a  
a984 3a 93 a9			ld a, (.dmark+1)  
a987 32 6c ee			ld (debug_mark+1),a  
a98a 3a 94 a9			ld a, (.dmark+2)  
a98d 32 6d ee			ld (debug_mark+2),a  
a990 18 03			jr .pastdmark  
a992 ..			.dmark: db "FRG"  
a995 f1			.pastdmark: pop af  
a996			endm  
# End of macro DMARK
a996						CALLMONITOR 
a996 cd 6f ee			call debug_vector  
a999				endm  
# End of macro CALLMONITOR
a999					endif 
a999			 
a999				; find uword 
a999			        ; update start of word with "_" 
a999				; replace uword with deleted flag 
a999			 
a999			 
a999			;	if DEBUG_FORTH_WORDS 
a999			;		DMARK "FOG" 
a999			;		CALLMONITOR 
a999			;	endif 
a999			 
a999			 
a999					; Get ptr to the word we need to look up 
a999			 
a999					FORTH_DSP_VALUEHL 
a999 cd 73 9c			call macro_dsp_valuehl 
a99c				endm 
# End of macro FORTH_DSP_VALUEHL
a99c					;v5 FORTH_DSP_VALUE 
a99c				; TODO type check 
a99c			;		inc hl    ; Skip type check  
a99c e5					push hl 
a99d c1					pop bc 
a99e			;		ex de, hl    ; put into DE 
a99e			 
a99e			 
a99e 21 32 dd				ld hl, baseram 
a9a1					;ld hl, baseusermem 
a9a1			 
a9a1				; skip dict stub 
a9a1			;	call forth_tok_next 
a9a1 e5			push hl   ; sacreifical push 
a9a2			 
a9a2			.fldouscanm: 
a9a2 e1				pop hl 
a9a3			.fldouscan: 
a9a3			;	if DEBUG_FORTH_WORDS 
a9a3			;		DMARK "LSs" 
a9a3			;		CALLMONITOR 
a9a3			;	endif 
a9a3				; skip dict stub 
a9a3 cd 7a 9f				call forth_tok_next 
a9a6			 
a9a6			 
a9a6			; while we have words to look for 
a9a6			 
a9a6 7e				ld a, (hl)      
a9a7			;	if DEBUG_FORTH_WORDS 
a9a7			;		DMARK "LSk" 
a9a7			;		CALLMONITOR 
a9a7			;	endif 
a9a7 fe 00				cp WORD_SYS_END 
a9a9 ca e5 a9				jp z, .flunotfound 
a9ac fe 01				cp WORD_SYS_UWORD 
a9ae c2 a3 a9				jp nz, .fldouscan 
a9b1			 
a9b1			;	if DEBUG_FORTH_WORDS 
a9b1			;		DMARK "LSu" 
a9b1			;		CALLMONITOR 
a9b1			;	endif 
a9b1			 
a9b1					; found a uword but is it the one we want... 
a9b1			 
a9b1 c5					push bc     ; uword to find is on bc 
a9b2 d1					pop de 
a9b3			 
a9b3 e5					push hl  ; to save the ptr 
a9b4			 
a9b4					; skip opcode 
a9b4 23					inc hl  
a9b5					; skip next ptr 
a9b5 23					inc hl  
a9b6 23					inc hl 
a9b7					; skip len 
a9b7 23					inc hl 
a9b8			 
a9b8			;	if DEBUG_FORTH_WORDS 
a9b8			;		DMARK "LSc" 
a9b8			;		CALLMONITOR 
a9b8			;	endif 
a9b8 cd 85 90				call strcmp 
a9bb c2 a2 a9				jp nz, .fldouscanm 
a9be			; 
a9be			; 
a9be			;; while we have words to look for 
a9be			; 
a9be			;.fdouscan:	ld a, (hl)      
a9be			;	if DEBUG_FORTH_WORDS 
a9be			;		DMARK "LSs" 
a9be			;		CALLMONITOR 
a9be			;	endif 
a9be			;		cp WORD_SYS_END 
a9be			;		jp z, .fudone 
a9be			;		cp WORD_SYS_UWORD 
a9be			;		jp nz, .fnuword 
a9be			; 
a9be			;	if DEBUG_FORTH_WORDS 
a9be			;		DMARK "FGu" 
a9be			;		CALLMONITOR 
a9be			;	endif 
a9be			; 
a9be			;		; found a uword but is it the one we want... 
a9be			; 
a9be			; 
a9be			;	        pop de   ; get back the dsp name 
a9be			;		push de 
a9be			; 
a9be			;		push hl  ; to save the ptr 
a9be			; 
a9be			;		; skip opcode 
a9be			;		inc hl  
a9be			;		; skip next ptr 
a9be			;		inc hl  
a9be			;		inc hl 
a9be			;		; skip len 
a9be			;		inc hl 
a9be			; 
a9be			;	if DEBUG_FORTH_WORDS 
a9be			;		DMARK "FGc" 
a9be			;		CALLMONITOR 
a9be			;	endif 
a9be			;		call strcmp 
a9be			;		jp nz, .fnuword 
a9be			 
a9be			 
a9be e1			pop hl 
a9bf			 
a9bf				 
a9bf				if DEBUG_FORTH_WORDS 
a9bf					DMARK "FGm" 
a9bf f5				push af  
a9c0 3a d4 a9			ld a, (.dmark)  
a9c3 32 6b ee			ld (debug_mark),a  
a9c6 3a d5 a9			ld a, (.dmark+1)  
a9c9 32 6c ee			ld (debug_mark+1),a  
a9cc 3a d6 a9			ld a, (.dmark+2)  
a9cf 32 6d ee			ld (debug_mark+2),a  
a9d2 18 03			jr .pastdmark  
a9d4 ..			.dmark: db "FGm"  
a9d7 f1			.pastdmark: pop af  
a9d8			endm  
# End of macro DMARK
a9d8					CALLMONITOR 
a9d8 cd 6f ee			call debug_vector  
a9db				endm  
# End of macro CALLMONITOR
a9db				endif 
a9db			 
a9db			 
a9db			 
a9db					; we have a uword so push its name to the stack 
a9db			 
a9db			;	   	push hl  ; save so we can move to next dict block 
a9db			;pop hl 
a9db			 
a9db					; update opcode to deleted 
a9db 3e 03				ld a, WORD_SYS_DELETED 
a9dd 77					ld (hl), a 
a9de			 
a9de 23					inc hl  
a9df					; skip next ptr 
a9df 23					inc hl  
a9e0 23					inc hl 
a9e1					; skip len 
a9e1 23					inc hl 
a9e2			 
a9e2					; TODO change parser to skip deleted words but for now mark it out 
a9e2 3e 5f				ld a, "_" 
a9e4 77					ld  (hl),a 
a9e5			 
a9e5			;		jr .fudone 
a9e5			; 
a9e5			;.fnuword:	pop hl 
a9e5			;		call forth_tok_next 
a9e5			;		jp .fdouscan  
a9e5			 
a9e5			.flunotfound:		  
a9e5			 
a9e5			 
a9e5					 
a9e5					FORTH_DSP_POP 
a9e5 cd 2b 9d			call macro_forth_dsp_pop 
a9e8				endm 
# End of macro FORTH_DSP_POP
a9e8			;		ld hl, .luno 
a9e8			;.fudone:		 pop hl 
a9e8					NEXTW 
a9e8 c3 29 9e			jp macro_next 
a9eb				endm 
# End of macro NEXTW
a9eb			.NOP: 
a9eb				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a9eb 61				db WORD_SYS_CORE+77             
a9ec 12 aa			dw .COMO            
a9ee 04				db 3 + 1 
a9ef .. 00			db "NOP",0              
a9f3				endm 
# End of macro CWHEAD
a9f3			; | NOP (  --  ) Do nothing | DONE 
a9f3					if DEBUG_FORTH_WORDS_KEY 
a9f3						DMARK "NOP" 
a9f3 f5				push af  
a9f4 3a 08 aa			ld a, (.dmark)  
a9f7 32 6b ee			ld (debug_mark),a  
a9fa 3a 09 aa			ld a, (.dmark+1)  
a9fd 32 6c ee			ld (debug_mark+1),a  
aa00 3a 0a aa			ld a, (.dmark+2)  
aa03 32 6d ee			ld (debug_mark+2),a  
aa06 18 03			jr .pastdmark  
aa08 ..			.dmark: db "NOP"  
aa0b f1			.pastdmark: pop af  
aa0c			endm  
# End of macro DMARK
aa0c						CALLMONITOR 
aa0c cd 6f ee			call debug_vector  
aa0f				endm  
# End of macro CALLMONITOR
aa0f					endif 
aa0f				       NEXTW 
aa0f c3 29 9e			jp macro_next 
aa12				endm 
# End of macro NEXTW
aa12			.COMO: 
aa12				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa12 6e				db WORD_SYS_CORE+90             
aa13 64 aa			dw .COMC            
aa15 02				db 1 + 1 
aa16 .. 00			db "(",0              
aa18				endm 
# End of macro CWHEAD
aa18			; | ( ( -- )  Start of comment | DONE 
aa18			 
aa18			 
aa18 2a c2 e5				ld hl, ( os_tok_ptr) 
aa1b 11 5f aa			ld de, .closepar 
aa1e					 
aa1e					if DEBUG_FORTH_WORDS 
aa1e						DMARK ").." 
aa1e f5				push af  
aa1f 3a 33 aa			ld a, (.dmark)  
aa22 32 6b ee			ld (debug_mark),a  
aa25 3a 34 aa			ld a, (.dmark+1)  
aa28 32 6c ee			ld (debug_mark+1),a  
aa2b 3a 35 aa			ld a, (.dmark+2)  
aa2e 32 6d ee			ld (debug_mark+2),a  
aa31 18 03			jr .pastdmark  
aa33 ..			.dmark: db ").."  
aa36 f1			.pastdmark: pop af  
aa37			endm  
# End of macro DMARK
aa37						CALLMONITOR 
aa37 cd 6f ee			call debug_vector  
aa3a				endm  
# End of macro CALLMONITOR
aa3a					endif 
aa3a cd 44 9f			call findnexttok  
aa3d			 
aa3d					if DEBUG_FORTH_WORDS 
aa3d						DMARK "IF5" 
aa3d f5				push af  
aa3e 3a 52 aa			ld a, (.dmark)  
aa41 32 6b ee			ld (debug_mark),a  
aa44 3a 53 aa			ld a, (.dmark+1)  
aa47 32 6c ee			ld (debug_mark+1),a  
aa4a 3a 54 aa			ld a, (.dmark+2)  
aa4d 32 6d ee			ld (debug_mark+2),a  
aa50 18 03			jr .pastdmark  
aa52 ..			.dmark: db "IF5"  
aa55 f1			.pastdmark: pop af  
aa56			endm  
# End of macro DMARK
aa56						CALLMONITOR 
aa56 cd 6f ee			call debug_vector  
aa59				endm  
# End of macro CALLMONITOR
aa59					endif 
aa59				; replace below with ) exec using tok_ptr 
aa59 22 c2 e5			ld (os_tok_ptr), hl 
aa5c c3 ba 9e			jp exec1 
aa5f			 
aa5f .. 00			.closepar:   db ")",0 
aa61			 
aa61				       NEXTW 
aa61 c3 29 9e			jp macro_next 
aa64				endm 
# End of macro NEXTW
aa64			.COMC: 
aa64				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aa64 6f				db WORD_SYS_CORE+91             
aa65 6d aa			dw .SCRATCH            
aa67 02				db 1 + 1 
aa68 .. 00			db ")",0              
aa6a				endm 
# End of macro CWHEAD
aa6a			; | ) ( -- )  End of comment |  DONE  
aa6a				       NEXTW 
aa6a c3 29 9e			jp macro_next 
aa6d				endm 
# End of macro NEXTW
aa6d			 
aa6d			.SCRATCH: 
aa6d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aa6d 6f				db WORD_SYS_CORE+91             
aa6e a8 aa			dw .INC            
aa70 08				db 7 + 1 
aa71 .. 00			db "SCRATCH",0              
aa79				endm 
# End of macro CWHEAD
aa79			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aa79			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aa79			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aa79			; | |  
aa79			; | | e.g.    : score $00 scratch ; 
aa79			; | |  
aa79			; | | $00 score ! 
aa79			; | | $01 score +! 
aa79			; | |  
aa79			; | | e.g.   : varword $0a scratch ;  
aa79			; | | 
aa79			; | | $8000 varword ! 
aa79					if DEBUG_FORTH_WORDS_KEY 
aa79						DMARK "SCR" 
aa79 f5				push af  
aa7a 3a 8e aa			ld a, (.dmark)  
aa7d 32 6b ee			ld (debug_mark),a  
aa80 3a 8f aa			ld a, (.dmark+1)  
aa83 32 6c ee			ld (debug_mark+1),a  
aa86 3a 90 aa			ld a, (.dmark+2)  
aa89 32 6d ee			ld (debug_mark+2),a  
aa8c 18 03			jr .pastdmark  
aa8e ..			.dmark: db "SCR"  
aa91 f1			.pastdmark: pop af  
aa92			endm  
# End of macro DMARK
aa92						CALLMONITOR 
aa92 cd 6f ee			call debug_vector  
aa95				endm  
# End of macro CALLMONITOR
aa95					endif 
aa95			 
aa95					FORTH_DSP_VALUEHL 
aa95 cd 73 9c			call macro_dsp_valuehl 
aa98				endm 
# End of macro FORTH_DSP_VALUEHL
aa98				 
aa98					FORTH_DSP_POP 
aa98 cd 2b 9d			call macro_forth_dsp_pop 
aa9b				endm 
# End of macro FORTH_DSP_POP
aa9b			 
aa9b 7d					ld a, l 
aa9c 21 e6 e7				ld hl, os_var_array 
aa9f cd e7 8c				call addatohl 
aaa2			 
aaa2 cd 6e 9a				call forth_push_numhl 
aaa5			 
aaa5				       NEXTW 
aaa5 c3 29 9e			jp macro_next 
aaa8				endm 
# End of macro NEXTW
aaa8			 
aaa8			.INC: 
aaa8				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aaa8 6f				db WORD_SYS_CORE+91             
aaa9 fe aa			dw .DEC            
aaab 03				db 2 + 1 
aaac .. 00			db "+!",0              
aaaf				endm 
# End of macro CWHEAD
aaaf			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aaaf					if DEBUG_FORTH_WORDS_KEY 
aaaf						DMARK "+s_" 
aaaf f5				push af  
aab0 3a c4 aa			ld a, (.dmark)  
aab3 32 6b ee			ld (debug_mark),a  
aab6 3a c5 aa			ld a, (.dmark+1)  
aab9 32 6c ee			ld (debug_mark+1),a  
aabc 3a c6 aa			ld a, (.dmark+2)  
aabf 32 6d ee			ld (debug_mark+2),a  
aac2 18 03			jr .pastdmark  
aac4 ..			.dmark: db "+s_"  
aac7 f1			.pastdmark: pop af  
aac8			endm  
# End of macro DMARK
aac8						CALLMONITOR 
aac8 cd 6f ee			call debug_vector  
aacb				endm  
# End of macro CALLMONITOR
aacb					endif 
aacb			 
aacb					FORTH_DSP_VALUEHL 
aacb cd 73 9c			call macro_dsp_valuehl 
aace				endm 
# End of macro FORTH_DSP_VALUEHL
aace			 
aace e5					push hl   ; save address 
aacf			 
aacf					FORTH_DSP_POP 
aacf cd 2b 9d			call macro_forth_dsp_pop 
aad2				endm 
# End of macro FORTH_DSP_POP
aad2			 
aad2					FORTH_DSP_VALUEHL 
aad2 cd 73 9c			call macro_dsp_valuehl 
aad5				endm 
# End of macro FORTH_DSP_VALUEHL
aad5			 
aad5 e5					push hl 
aad6					FORTH_DSP_POP 
aad6 cd 2b 9d			call macro_forth_dsp_pop 
aad9				endm 
# End of macro FORTH_DSP_POP
aad9 e1					pop hl 
aada			 
aada					; hl contains value to add to byte at a 
aada				 
aada eb					ex de, hl 
aadb			 
aadb e1					pop hl 
aadc			 
aadc					if DEBUG_FORTH_WORDS 
aadc						DMARK "INC" 
aadc f5				push af  
aadd 3a f1 aa			ld a, (.dmark)  
aae0 32 6b ee			ld (debug_mark),a  
aae3 3a f2 aa			ld a, (.dmark+1)  
aae6 32 6c ee			ld (debug_mark+1),a  
aae9 3a f3 aa			ld a, (.dmark+2)  
aaec 32 6d ee			ld (debug_mark+2),a  
aaef 18 03			jr .pastdmark  
aaf1 ..			.dmark: db "INC"  
aaf4 f1			.pastdmark: pop af  
aaf5			endm  
# End of macro DMARK
aaf5						CALLMONITOR 
aaf5 cd 6f ee			call debug_vector  
aaf8				endm  
# End of macro CALLMONITOR
aaf8					endif 
aaf8			 
aaf8 7e					ld a,(hl) 
aaf9 83					add e 
aafa 77					ld (hl),a 
aafb			 
aafb			 
aafb			 
aafb				       NEXTW 
aafb c3 29 9e			jp macro_next 
aafe				endm 
# End of macro NEXTW
aafe			 
aafe			.DEC: 
aafe				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
aafe 6f				db WORD_SYS_CORE+91             
aaff 52 ab			dw .INC2            
ab01 03				db 2 + 1 
ab02 .. 00			db "-!",0              
ab05				endm 
# End of macro CWHEAD
ab05			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab05					if DEBUG_FORTH_WORDS_KEY 
ab05						DMARK "-s_" 
ab05 f5				push af  
ab06 3a 1a ab			ld a, (.dmark)  
ab09 32 6b ee			ld (debug_mark),a  
ab0c 3a 1b ab			ld a, (.dmark+1)  
ab0f 32 6c ee			ld (debug_mark+1),a  
ab12 3a 1c ab			ld a, (.dmark+2)  
ab15 32 6d ee			ld (debug_mark+2),a  
ab18 18 03			jr .pastdmark  
ab1a ..			.dmark: db "-s_"  
ab1d f1			.pastdmark: pop af  
ab1e			endm  
# End of macro DMARK
ab1e						CALLMONITOR 
ab1e cd 6f ee			call debug_vector  
ab21				endm  
# End of macro CALLMONITOR
ab21					endif 
ab21			 
ab21					FORTH_DSP_VALUEHL 
ab21 cd 73 9c			call macro_dsp_valuehl 
ab24				endm 
# End of macro FORTH_DSP_VALUEHL
ab24			 
ab24 e5					push hl   ; save address 
ab25			 
ab25					FORTH_DSP_POP 
ab25 cd 2b 9d			call macro_forth_dsp_pop 
ab28				endm 
# End of macro FORTH_DSP_POP
ab28			 
ab28					FORTH_DSP_VALUEHL 
ab28 cd 73 9c			call macro_dsp_valuehl 
ab2b				endm 
# End of macro FORTH_DSP_VALUEHL
ab2b			 
ab2b					; hl contains value to add to byte at a 
ab2b				 
ab2b eb					ex de, hl 
ab2c			 
ab2c e1					pop hl 
ab2d			 
ab2d					if DEBUG_FORTH_WORDS 
ab2d						DMARK "DEC" 
ab2d f5				push af  
ab2e 3a 42 ab			ld a, (.dmark)  
ab31 32 6b ee			ld (debug_mark),a  
ab34 3a 43 ab			ld a, (.dmark+1)  
ab37 32 6c ee			ld (debug_mark+1),a  
ab3a 3a 44 ab			ld a, (.dmark+2)  
ab3d 32 6d ee			ld (debug_mark+2),a  
ab40 18 03			jr .pastdmark  
ab42 ..			.dmark: db "DEC"  
ab45 f1			.pastdmark: pop af  
ab46			endm  
# End of macro DMARK
ab46						CALLMONITOR 
ab46 cd 6f ee			call debug_vector  
ab49				endm  
# End of macro CALLMONITOR
ab49					endif 
ab49			 
ab49 7e					ld a,(hl) 
ab4a 93					sub e 
ab4b 77					ld (hl),a 
ab4c			 
ab4c			 
ab4c					FORTH_DSP_POP 
ab4c cd 2b 9d			call macro_forth_dsp_pop 
ab4f				endm 
# End of macro FORTH_DSP_POP
ab4f			 
ab4f				       NEXTW 
ab4f c3 29 9e			jp macro_next 
ab52				endm 
# End of macro NEXTW
ab52			 
ab52			.INC2: 
ab52				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab52 6f				db WORD_SYS_CORE+91             
ab53 ff ab			dw .DEC2            
ab55 04				db 3 + 1 
ab56 .. 00			db "+2!",0              
ab5a				endm 
# End of macro CWHEAD
ab5a			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab5a			 
ab5a					if DEBUG_FORTH_WORDS_KEY 
ab5a						DMARK "+2s" 
ab5a f5				push af  
ab5b 3a 6f ab			ld a, (.dmark)  
ab5e 32 6b ee			ld (debug_mark),a  
ab61 3a 70 ab			ld a, (.dmark+1)  
ab64 32 6c ee			ld (debug_mark+1),a  
ab67 3a 71 ab			ld a, (.dmark+2)  
ab6a 32 6d ee			ld (debug_mark+2),a  
ab6d 18 03			jr .pastdmark  
ab6f ..			.dmark: db "+2s"  
ab72 f1			.pastdmark: pop af  
ab73			endm  
# End of macro DMARK
ab73						CALLMONITOR 
ab73 cd 6f ee			call debug_vector  
ab76				endm  
# End of macro CALLMONITOR
ab76					endif 
ab76			 
ab76					; Address 
ab76			 
ab76					FORTH_DSP_VALUEHL 
ab76 cd 73 9c			call macro_dsp_valuehl 
ab79				endm 
# End of macro FORTH_DSP_VALUEHL
ab79			 
ab79 e5					push hl    ; save address 
ab7a			 
ab7a					; load content into de 
ab7a			 
ab7a 5e					ld e,(hl) 
ab7b 23					inc hl 
ab7c 56					ld d, (hl) 
ab7d			 
ab7d					if DEBUG_FORTH_WORDS 
ab7d						DMARK "+2a" 
ab7d f5				push af  
ab7e 3a 92 ab			ld a, (.dmark)  
ab81 32 6b ee			ld (debug_mark),a  
ab84 3a 93 ab			ld a, (.dmark+1)  
ab87 32 6c ee			ld (debug_mark+1),a  
ab8a 3a 94 ab			ld a, (.dmark+2)  
ab8d 32 6d ee			ld (debug_mark+2),a  
ab90 18 03			jr .pastdmark  
ab92 ..			.dmark: db "+2a"  
ab95 f1			.pastdmark: pop af  
ab96			endm  
# End of macro DMARK
ab96						CALLMONITOR 
ab96 cd 6f ee			call debug_vector  
ab99				endm  
# End of macro CALLMONITOR
ab99					endif 
ab99			 
ab99					FORTH_DSP_POP 
ab99 cd 2b 9d			call macro_forth_dsp_pop 
ab9c				endm 
# End of macro FORTH_DSP_POP
ab9c			 
ab9c					; Get value to add 
ab9c			 
ab9c					FORTH_DSP_VALUE 
ab9c cd 5c 9c			call macro_forth_dsp_value 
ab9f				endm 
# End of macro FORTH_DSP_VALUE
ab9f			 
ab9f					if DEBUG_FORTH_WORDS 
ab9f						DMARK "+2v" 
ab9f f5				push af  
aba0 3a b4 ab			ld a, (.dmark)  
aba3 32 6b ee			ld (debug_mark),a  
aba6 3a b5 ab			ld a, (.dmark+1)  
aba9 32 6c ee			ld (debug_mark+1),a  
abac 3a b6 ab			ld a, (.dmark+2)  
abaf 32 6d ee			ld (debug_mark+2),a  
abb2 18 03			jr .pastdmark  
abb4 ..			.dmark: db "+2v"  
abb7 f1			.pastdmark: pop af  
abb8			endm  
# End of macro DMARK
abb8						CALLMONITOR 
abb8 cd 6f ee			call debug_vector  
abbb				endm  
# End of macro CALLMONITOR
abbb					endif 
abbb			 
abbb 19					add hl, de 
abbc			 
abbc					if DEBUG_FORTH_WORDS 
abbc						DMARK "+2+" 
abbc f5				push af  
abbd 3a d1 ab			ld a, (.dmark)  
abc0 32 6b ee			ld (debug_mark),a  
abc3 3a d2 ab			ld a, (.dmark+1)  
abc6 32 6c ee			ld (debug_mark+1),a  
abc9 3a d3 ab			ld a, (.dmark+2)  
abcc 32 6d ee			ld (debug_mark+2),a  
abcf 18 03			jr .pastdmark  
abd1 ..			.dmark: db "+2+"  
abd4 f1			.pastdmark: pop af  
abd5			endm  
# End of macro DMARK
abd5						CALLMONITOR 
abd5 cd 6f ee			call debug_vector  
abd8				endm  
# End of macro CALLMONITOR
abd8					endif 
abd8			 
abd8					; move result to de 
abd8			 
abd8 eb					ex de, hl 
abd9			 
abd9					; Address 
abd9			 
abd9 e1					pop hl 
abda			 
abda					; save it back 
abda			 
abda 73					ld (hl), e 
abdb 23					inc hl 
abdc 72					ld (hl), d 
abdd			 
abdd					if DEBUG_FORTH_WORDS 
abdd						DMARK "+2e" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 6b ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 6c ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 6d ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "+2e"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6						CALLMONITOR 
abf6 cd 6f ee			call debug_vector  
abf9				endm  
# End of macro CALLMONITOR
abf9					endif 
abf9			 
abf9			 
abf9			 
abf9					FORTH_DSP_POP 
abf9 cd 2b 9d			call macro_forth_dsp_pop 
abfc				endm 
# End of macro FORTH_DSP_POP
abfc			 
abfc			 
abfc				       NEXTW 
abfc c3 29 9e			jp macro_next 
abff				endm 
# End of macro NEXTW
abff			 
abff			.DEC2: 
abff				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
abff 6f				db WORD_SYS_CORE+91             
ac00 ae ac			dw .GET2            
ac02 04				db 3 + 1 
ac03 .. 00			db "-2!",0              
ac07				endm 
# End of macro CWHEAD
ac07			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac07			 
ac07			 
ac07					if DEBUG_FORTH_WORDS_KEY 
ac07						DMARK "-2s" 
ac07 f5				push af  
ac08 3a 1c ac			ld a, (.dmark)  
ac0b 32 6b ee			ld (debug_mark),a  
ac0e 3a 1d ac			ld a, (.dmark+1)  
ac11 32 6c ee			ld (debug_mark+1),a  
ac14 3a 1e ac			ld a, (.dmark+2)  
ac17 32 6d ee			ld (debug_mark+2),a  
ac1a 18 03			jr .pastdmark  
ac1c ..			.dmark: db "-2s"  
ac1f f1			.pastdmark: pop af  
ac20			endm  
# End of macro DMARK
ac20						CALLMONITOR 
ac20 cd 6f ee			call debug_vector  
ac23				endm  
# End of macro CALLMONITOR
ac23					endif 
ac23			 
ac23					; Address 
ac23			 
ac23					FORTH_DSP_VALUEHL 
ac23 cd 73 9c			call macro_dsp_valuehl 
ac26				endm 
# End of macro FORTH_DSP_VALUEHL
ac26			 
ac26 e5					push hl    ; save address 
ac27			 
ac27					; load content into de 
ac27			 
ac27 5e					ld e,(hl) 
ac28 23					inc hl 
ac29 56					ld d, (hl) 
ac2a			 
ac2a					if DEBUG_FORTH_WORDS 
ac2a						DMARK "-2a" 
ac2a f5				push af  
ac2b 3a 3f ac			ld a, (.dmark)  
ac2e 32 6b ee			ld (debug_mark),a  
ac31 3a 40 ac			ld a, (.dmark+1)  
ac34 32 6c ee			ld (debug_mark+1),a  
ac37 3a 41 ac			ld a, (.dmark+2)  
ac3a 32 6d ee			ld (debug_mark+2),a  
ac3d 18 03			jr .pastdmark  
ac3f ..			.dmark: db "-2a"  
ac42 f1			.pastdmark: pop af  
ac43			endm  
# End of macro DMARK
ac43						CALLMONITOR 
ac43 cd 6f ee			call debug_vector  
ac46				endm  
# End of macro CALLMONITOR
ac46					endif 
ac46			 
ac46					FORTH_DSP_POP 
ac46 cd 2b 9d			call macro_forth_dsp_pop 
ac49				endm 
# End of macro FORTH_DSP_POP
ac49			 
ac49					; Get value to remove 
ac49			 
ac49					FORTH_DSP_VALUE 
ac49 cd 5c 9c			call macro_forth_dsp_value 
ac4c				endm 
# End of macro FORTH_DSP_VALUE
ac4c			 
ac4c					if DEBUG_FORTH_WORDS 
ac4c						DMARK "-2v" 
ac4c f5				push af  
ac4d 3a 61 ac			ld a, (.dmark)  
ac50 32 6b ee			ld (debug_mark),a  
ac53 3a 62 ac			ld a, (.dmark+1)  
ac56 32 6c ee			ld (debug_mark+1),a  
ac59 3a 63 ac			ld a, (.dmark+2)  
ac5c 32 6d ee			ld (debug_mark+2),a  
ac5f 18 03			jr .pastdmark  
ac61 ..			.dmark: db "-2v"  
ac64 f1			.pastdmark: pop af  
ac65			endm  
# End of macro DMARK
ac65						CALLMONITOR 
ac65 cd 6f ee			call debug_vector  
ac68				endm  
# End of macro CALLMONITOR
ac68					endif 
ac68			 
ac68 eb					ex de, hl 
ac69 ed 52				sbc hl, de 
ac6b			 
ac6b					if DEBUG_FORTH_WORDS 
ac6b						DMARK "-2d" 
ac6b f5				push af  
ac6c 3a 80 ac			ld a, (.dmark)  
ac6f 32 6b ee			ld (debug_mark),a  
ac72 3a 81 ac			ld a, (.dmark+1)  
ac75 32 6c ee			ld (debug_mark+1),a  
ac78 3a 82 ac			ld a, (.dmark+2)  
ac7b 32 6d ee			ld (debug_mark+2),a  
ac7e 18 03			jr .pastdmark  
ac80 ..			.dmark: db "-2d"  
ac83 f1			.pastdmark: pop af  
ac84			endm  
# End of macro DMARK
ac84						CALLMONITOR 
ac84 cd 6f ee			call debug_vector  
ac87				endm  
# End of macro CALLMONITOR
ac87					endif 
ac87			 
ac87					; move result to de 
ac87			 
ac87 eb					ex de, hl 
ac88			 
ac88					; Address 
ac88			 
ac88 e1					pop hl 
ac89			 
ac89					; save it back 
ac89			 
ac89 73					ld (hl), e 
ac8a 23					inc hl 
ac8b 72					ld (hl), d 
ac8c			 
ac8c					if DEBUG_FORTH_WORDS 
ac8c						DMARK "-2e" 
ac8c f5				push af  
ac8d 3a a1 ac			ld a, (.dmark)  
ac90 32 6b ee			ld (debug_mark),a  
ac93 3a a2 ac			ld a, (.dmark+1)  
ac96 32 6c ee			ld (debug_mark+1),a  
ac99 3a a3 ac			ld a, (.dmark+2)  
ac9c 32 6d ee			ld (debug_mark+2),a  
ac9f 18 03			jr .pastdmark  
aca1 ..			.dmark: db "-2e"  
aca4 f1			.pastdmark: pop af  
aca5			endm  
# End of macro DMARK
aca5						CALLMONITOR 
aca5 cd 6f ee			call debug_vector  
aca8				endm  
# End of macro CALLMONITOR
aca8					endif 
aca8			 
aca8			 
aca8					FORTH_DSP_POP 
aca8 cd 2b 9d			call macro_forth_dsp_pop 
acab				endm 
# End of macro FORTH_DSP_POP
acab			 
acab			 
acab			 
acab				       NEXTW 
acab c3 29 9e			jp macro_next 
acae				endm 
# End of macro NEXTW
acae			.GET2: 
acae				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
acae 6f				db WORD_SYS_CORE+91             
acaf e3 ac			dw .BANG2            
acb1 03				db 2 + 1 
acb2 .. 00			db "2@",0              
acb5				endm 
# End of macro CWHEAD
acb5			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
acb5					if DEBUG_FORTH_WORDS_KEY 
acb5						DMARK "2A_" 
acb5 f5				push af  
acb6 3a ca ac			ld a, (.dmark)  
acb9 32 6b ee			ld (debug_mark),a  
acbc 3a cb ac			ld a, (.dmark+1)  
acbf 32 6c ee			ld (debug_mark+1),a  
acc2 3a cc ac			ld a, (.dmark+2)  
acc5 32 6d ee			ld (debug_mark+2),a  
acc8 18 03			jr .pastdmark  
acca ..			.dmark: db "2A_"  
accd f1			.pastdmark: pop af  
acce			endm  
# End of macro DMARK
acce						CALLMONITOR 
acce cd 6f ee			call debug_vector  
acd1				endm  
# End of macro CALLMONITOR
acd1					endif 
acd1			 
acd1					FORTH_DSP_VALUEHL 
acd1 cd 73 9c			call macro_dsp_valuehl 
acd4				endm 
# End of macro FORTH_DSP_VALUEHL
acd4			 
acd4 e5					push hl   ; save address 
acd5			 
acd5					FORTH_DSP_POP 
acd5 cd 2b 9d			call macro_forth_dsp_pop 
acd8				endm 
# End of macro FORTH_DSP_POP
acd8			 
acd8 e1					pop hl 
acd9			 
acd9 5e					ld e, (hl) 
acda 23					inc hl 
acdb 56					ld d, (hl) 
acdc			 
acdc eb					ex de, hl 
acdd			 
acdd cd 6e 9a				call forth_push_numhl 
ace0			 
ace0				       NEXTW 
ace0 c3 29 9e			jp macro_next 
ace3				endm 
# End of macro NEXTW
ace3			.BANG2: 
ace3				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ace3 6f				db WORD_SYS_CORE+91             
ace4 1b ad			dw .CONFIG            
ace6 03				db 2 + 1 
ace7 .. 00			db "2!",0              
acea				endm 
# End of macro CWHEAD
acea			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
acea					if DEBUG_FORTH_WORDS_KEY 
acea						DMARK "2S_" 
acea f5				push af  
aceb 3a ff ac			ld a, (.dmark)  
acee 32 6b ee			ld (debug_mark),a  
acf1 3a 00 ad			ld a, (.dmark+1)  
acf4 32 6c ee			ld (debug_mark+1),a  
acf7 3a 01 ad			ld a, (.dmark+2)  
acfa 32 6d ee			ld (debug_mark+2),a  
acfd 18 03			jr .pastdmark  
acff ..			.dmark: db "2S_"  
ad02 f1			.pastdmark: pop af  
ad03			endm  
# End of macro DMARK
ad03						CALLMONITOR 
ad03 cd 6f ee			call debug_vector  
ad06				endm  
# End of macro CALLMONITOR
ad06					endif 
ad06			 
ad06					FORTH_DSP_VALUEHL 
ad06 cd 73 9c			call macro_dsp_valuehl 
ad09				endm 
# End of macro FORTH_DSP_VALUEHL
ad09			 
ad09 e5					push hl   ; save address 
ad0a			 
ad0a			 
ad0a					FORTH_DSP_POP 
ad0a cd 2b 9d			call macro_forth_dsp_pop 
ad0d				endm 
# End of macro FORTH_DSP_POP
ad0d			 
ad0d					 
ad0d					FORTH_DSP_VALUEHL 
ad0d cd 73 9c			call macro_dsp_valuehl 
ad10				endm 
# End of macro FORTH_DSP_VALUEHL
ad10			 
ad10					FORTH_DSP_POP 
ad10 cd 2b 9d			call macro_forth_dsp_pop 
ad13				endm 
# End of macro FORTH_DSP_POP
ad13			 
ad13 eb					ex de, hl    ; value now in de 
ad14			 
ad14 e1					pop hl 
ad15			 
ad15 73					ld (hl), e 
ad16			 
ad16 23					inc hl 
ad17			 
ad17 72					ld (hl), d 
ad18			 
ad18			 
ad18				       NEXTW 
ad18 c3 29 9e			jp macro_next 
ad1b				endm 
# End of macro NEXTW
ad1b			.CONFIG: 
ad1b				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
ad1b 6f				db WORD_SYS_CORE+91             
ad1c 2c ad			dw .ADTOS            
ad1e 07				db 6 + 1 
ad1f .. 00			db "CONFIG",0              
ad26				endm 
# End of macro CWHEAD
ad26			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad26			 
ad26 cd 5b 92				call config 
ad29					NEXTW 
ad29 c3 29 9e			jp macro_next 
ad2c				endm 
# End of macro NEXTW
ad2c			 
ad2c			.ADTOS: 
ad2c				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
ad2c 6f				db WORD_SYS_CORE+91             
ad2d 42 ad			dw .SBTOS            
ad2f 03				db 2 + 1 
ad30 .. 00			db "1+",0              
ad33				endm 
# End of macro CWHEAD
ad33			; | 1+ ( u -- u )  Increment value on TOS | DONE 
ad33			 
ad33					FORTH_DSP_VALUEHL 
ad33 cd 73 9c			call macro_dsp_valuehl 
ad36				endm 
# End of macro FORTH_DSP_VALUEHL
ad36 e5					push hl 
ad37			 
ad37					FORTH_DSP_POP 
ad37 cd 2b 9d			call macro_forth_dsp_pop 
ad3a				endm 
# End of macro FORTH_DSP_POP
ad3a e1					pop hl 
ad3b			 
ad3b 23					inc hl 
ad3c cd 6e 9a				call forth_push_numhl 
ad3f					 
ad3f					NEXTW 
ad3f c3 29 9e			jp macro_next 
ad42				endm 
# End of macro NEXTW
ad42			.SBTOS: 
ad42				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ad42 6f				db WORD_SYS_CORE+91             
ad43 58 ad			dw .ADSTORE            
ad45 03				db 2 + 1 
ad46 .. 00			db "1-",0              
ad49				endm 
# End of macro CWHEAD
ad49			; | 1- ( u -- u )  Decrement value on TOS | DONE 
ad49			 
ad49					FORTH_DSP_VALUEHL 
ad49 cd 73 9c			call macro_dsp_valuehl 
ad4c				endm 
# End of macro FORTH_DSP_VALUEHL
ad4c e5					push hl 
ad4d			 
ad4d					FORTH_DSP_POP 
ad4d cd 2b 9d			call macro_forth_dsp_pop 
ad50				endm 
# End of macro FORTH_DSP_POP
ad50 e1					pop hl 
ad51			 
ad51 2b					dec hl 
ad52 cd 6e 9a				call forth_push_numhl 
ad55					 
ad55					NEXTW 
ad55 c3 29 9e			jp macro_next 
ad58				endm 
# End of macro NEXTW
ad58			.ADSTORE: 
ad58				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ad58 6f				db WORD_SYS_CORE+91             
ad59 6e ad			dw .ADWSTORE            
ad5b 04				db 3 + 1 
ad5c .. 00			db "1+!",0              
ad60				endm 
# End of macro CWHEAD
ad60			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ad60			 
ad60					FORTH_DSP_VALUEHL 
ad60 cd 73 9c			call macro_dsp_valuehl 
ad63				endm 
# End of macro FORTH_DSP_VALUEHL
ad63 e5					push hl 
ad64			 
ad64					FORTH_DSP_POP 
ad64 cd 2b 9d			call macro_forth_dsp_pop 
ad67				endm 
# End of macro FORTH_DSP_POP
ad67 e1					pop hl 
ad68			 
ad68 7e					ld a, (hl) 
ad69 3c					inc a 
ad6a 77					ld (hl), a 
ad6b					 
ad6b					NEXTW 
ad6b c3 29 9e			jp macro_next 
ad6e				endm 
# End of macro NEXTW
ad6e			.ADWSTORE: 
ad6e				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ad6e 6f				db WORD_SYS_CORE+91             
ad6f 8c ad			dw .SBSTORE            
ad71 05				db 4 + 1 
ad72 .. 00			db "1+2!",0              
ad77				endm 
# End of macro CWHEAD
ad77			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ad77			 
ad77					FORTH_DSP_VALUEHL 
ad77 cd 73 9c			call macro_dsp_valuehl 
ad7a				endm 
# End of macro FORTH_DSP_VALUEHL
ad7a e5					push hl 
ad7b			 
ad7b					FORTH_DSP_POP 
ad7b cd 2b 9d			call macro_forth_dsp_pop 
ad7e				endm 
# End of macro FORTH_DSP_POP
ad7e e1					pop hl 
ad7f			 
ad7f e5					push hl 
ad80			 
ad80 cd ab 9d				call loadwordinhl 
ad83 23					inc hl 
ad84			 
ad84 d1					pop de 
ad85 eb					ex de, hl 
ad86 73					ld (hl), e 
ad87 23					inc hl 
ad88 72					ld (hl), d 
ad89					 
ad89					NEXTW 
ad89 c3 29 9e			jp macro_next 
ad8c				endm 
# End of macro NEXTW
ad8c			.SBSTORE: 
ad8c				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ad8c 6f				db WORD_SYS_CORE+91             
ad8d a2 ad			dw .SBWSTORE            
ad8f 04				db 3 + 1 
ad90 .. 00			db "1-!",0              
ad94				endm 
# End of macro CWHEAD
ad94			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
ad94			 
ad94					FORTH_DSP_VALUEHL 
ad94 cd 73 9c			call macro_dsp_valuehl 
ad97				endm 
# End of macro FORTH_DSP_VALUEHL
ad97 e5					push hl 
ad98			 
ad98					FORTH_DSP_POP 
ad98 cd 2b 9d			call macro_forth_dsp_pop 
ad9b				endm 
# End of macro FORTH_DSP_POP
ad9b e1					pop hl 
ad9c			 
ad9c 7e					ld a, (hl) 
ad9d 3d					dec a 
ad9e 77					ld (hl), a 
ad9f					 
ad9f					NEXTW 
ad9f c3 29 9e			jp macro_next 
ada2				endm 
# End of macro NEXTW
ada2			.SBWSTORE: 
ada2				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
ada2 6f				db WORD_SYS_CORE+91             
ada3 c0 ad			dw .ENDCORE            
ada5 05				db 4 + 1 
ada6 .. 00			db "1-2!",0              
adab				endm 
# End of macro CWHEAD
adab			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
adab			 
adab					FORTH_DSP_VALUEHL 
adab cd 73 9c			call macro_dsp_valuehl 
adae				endm 
# End of macro FORTH_DSP_VALUEHL
adae e5					push hl 
adaf			 
adaf					FORTH_DSP_POP 
adaf cd 2b 9d			call macro_forth_dsp_pop 
adb2				endm 
# End of macro FORTH_DSP_POP
adb2 e1					pop hl 
adb3			 
adb3 e5					push hl 
adb4			 
adb4 cd ab 9d				call loadwordinhl 
adb7 2b					dec hl 
adb8			 
adb8 d1					pop de 
adb9 eb					ex de, hl 
adba 73					ld (hl), e 
adbb 23					inc hl 
adbc 72					ld (hl), d 
adbd					 
adbd					NEXTW 
adbd c3 29 9e			jp macro_next 
adc0				endm 
# End of macro NEXTW
adc0			.ENDCORE: 
adc0			 
adc0			; eof 
adc0			 
adc0			 
# End of file forth_words_core.asm
adc0			include "forth_words_flow.asm" 
adc0			 
adc0			; | ## Program Flow Words 
adc0			 
adc0			.IF: 
adc0				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
adc0 1e				db WORD_SYS_CORE+10             
adc1 b5 ae			dw .THEN            
adc3 03				db 2 + 1 
adc4 .. 00			db "IF",0              
adc7				endm 
# End of macro CWHEAD
adc7			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
adc7			; 
adc7					if DEBUG_FORTH_WORDS_KEY 
adc7						DMARK "IF." 
adc7 f5				push af  
adc8 3a dc ad			ld a, (.dmark)  
adcb 32 6b ee			ld (debug_mark),a  
adce 3a dd ad			ld a, (.dmark+1)  
add1 32 6c ee			ld (debug_mark+1),a  
add4 3a de ad			ld a, (.dmark+2)  
add7 32 6d ee			ld (debug_mark+2),a  
adda 18 03			jr .pastdmark  
addc ..			.dmark: db "IF."  
addf f1			.pastdmark: pop af  
ade0			endm  
# End of macro DMARK
ade0						CALLMONITOR 
ade0 cd 6f ee			call debug_vector  
ade3				endm  
# End of macro CALLMONITOR
ade3					endif 
ade3			; eval TOS 
ade3			 
ade3				FORTH_DSP_VALUEHL 
ade3 cd 73 9c			call macro_dsp_valuehl 
ade6				endm 
# End of macro FORTH_DSP_VALUEHL
ade6			 
ade6			;	push hl 
ade6				FORTH_DSP_POP 
ade6 cd 2b 9d			call macro_forth_dsp_pop 
ade9				endm 
# End of macro FORTH_DSP_POP
ade9			;	pop hl 
ade9			 
ade9					if DEBUG_FORTH_WORDS 
ade9						DMARK "IF1" 
ade9 f5				push af  
adea 3a fe ad			ld a, (.dmark)  
aded 32 6b ee			ld (debug_mark),a  
adf0 3a ff ad			ld a, (.dmark+1)  
adf3 32 6c ee			ld (debug_mark+1),a  
adf6 3a 00 ae			ld a, (.dmark+2)  
adf9 32 6d ee			ld (debug_mark+2),a  
adfc 18 03			jr .pastdmark  
adfe ..			.dmark: db "IF1"  
ae01 f1			.pastdmark: pop af  
ae02			endm  
# End of macro DMARK
ae02						CALLMONITOR 
ae02 cd 6f ee			call debug_vector  
ae05				endm  
# End of macro CALLMONITOR
ae05					endif 
ae05 b7				or a        ; clear carry flag 
ae06 11 00 00			ld de, 0 
ae09 eb				ex de,hl 
ae0a ed 52			sbc hl, de 
ae0c c2 96 ae			jp nz, .iftrue 
ae0f			 
ae0f					if DEBUG_FORTH_WORDS 
ae0f						DMARK "IF2" 
ae0f f5				push af  
ae10 3a 24 ae			ld a, (.dmark)  
ae13 32 6b ee			ld (debug_mark),a  
ae16 3a 25 ae			ld a, (.dmark+1)  
ae19 32 6c ee			ld (debug_mark+1),a  
ae1c 3a 26 ae			ld a, (.dmark+2)  
ae1f 32 6d ee			ld (debug_mark+2),a  
ae22 18 03			jr .pastdmark  
ae24 ..			.dmark: db "IF2"  
ae27 f1			.pastdmark: pop af  
ae28			endm  
# End of macro DMARK
ae28						CALLMONITOR 
ae28 cd 6f ee			call debug_vector  
ae2b				endm  
# End of macro CALLMONITOR
ae2b					endif 
ae2b			 
ae2b			; if not true then skip to THEN 
ae2b			 
ae2b				; TODO get tok_ptr 
ae2b				; TODO consume toks until we get to THEN 
ae2b			 
ae2b 2a c2 e5			ld hl, (os_tok_ptr) 
ae2e					if DEBUG_FORTH_WORDS 
ae2e						DMARK "IF3" 
ae2e f5				push af  
ae2f 3a 43 ae			ld a, (.dmark)  
ae32 32 6b ee			ld (debug_mark),a  
ae35 3a 44 ae			ld a, (.dmark+1)  
ae38 32 6c ee			ld (debug_mark+1),a  
ae3b 3a 45 ae			ld a, (.dmark+2)  
ae3e 32 6d ee			ld (debug_mark+2),a  
ae41 18 03			jr .pastdmark  
ae43 ..			.dmark: db "IF3"  
ae46 f1			.pastdmark: pop af  
ae47			endm  
# End of macro DMARK
ae47						CALLMONITOR 
ae47 cd 6f ee			call debug_vector  
ae4a				endm  
# End of macro CALLMONITOR
ae4a						 
ae4a					endif 
ae4a 11 91 ae			ld de, .ifthen 
ae4d					if DEBUG_FORTH_WORDS 
ae4d						DMARK "IF4" 
ae4d f5				push af  
ae4e 3a 62 ae			ld a, (.dmark)  
ae51 32 6b ee			ld (debug_mark),a  
ae54 3a 63 ae			ld a, (.dmark+1)  
ae57 32 6c ee			ld (debug_mark+1),a  
ae5a 3a 64 ae			ld a, (.dmark+2)  
ae5d 32 6d ee			ld (debug_mark+2),a  
ae60 18 03			jr .pastdmark  
ae62 ..			.dmark: db "IF4"  
ae65 f1			.pastdmark: pop af  
ae66			endm  
# End of macro DMARK
ae66						CALLMONITOR 
ae66 cd 6f ee			call debug_vector  
ae69				endm  
# End of macro CALLMONITOR
ae69					endif 
ae69 cd 44 9f			call findnexttok  
ae6c			 
ae6c					if DEBUG_FORTH_WORDS 
ae6c						DMARK "IF5" 
ae6c f5				push af  
ae6d 3a 81 ae			ld a, (.dmark)  
ae70 32 6b ee			ld (debug_mark),a  
ae73 3a 82 ae			ld a, (.dmark+1)  
ae76 32 6c ee			ld (debug_mark+1),a  
ae79 3a 83 ae			ld a, (.dmark+2)  
ae7c 32 6d ee			ld (debug_mark+2),a  
ae7f 18 03			jr .pastdmark  
ae81 ..			.dmark: db "IF5"  
ae84 f1			.pastdmark: pop af  
ae85			endm  
# End of macro DMARK
ae85						CALLMONITOR 
ae85 cd 6f ee			call debug_vector  
ae88				endm  
# End of macro CALLMONITOR
ae88					endif 
ae88				; TODO replace below with ; exec using tok_ptr 
ae88 22 c2 e5			ld (os_tok_ptr), hl 
ae8b c3 ba 9e			jp exec1 
ae8e				NEXTW 
ae8e c3 29 9e			jp macro_next 
ae91				endm 
# End of macro NEXTW
ae91			 
ae91 .. 00		.ifthen:  db "THEN",0 
ae96			 
ae96			.iftrue:		 
ae96				; Exec next words normally 
ae96			 
ae96				; if true then exec following IF as normal 
ae96					if DEBUG_FORTH_WORDS 
ae96						DMARK "IFT" 
ae96 f5				push af  
ae97 3a ab ae			ld a, (.dmark)  
ae9a 32 6b ee			ld (debug_mark),a  
ae9d 3a ac ae			ld a, (.dmark+1)  
aea0 32 6c ee			ld (debug_mark+1),a  
aea3 3a ad ae			ld a, (.dmark+2)  
aea6 32 6d ee			ld (debug_mark+2),a  
aea9 18 03			jr .pastdmark  
aeab ..			.dmark: db "IFT"  
aeae f1			.pastdmark: pop af  
aeaf			endm  
# End of macro DMARK
aeaf						CALLMONITOR 
aeaf cd 6f ee			call debug_vector  
aeb2				endm  
# End of macro CALLMONITOR
aeb2					endif 
aeb2			 
aeb2					NEXTW 
aeb2 c3 29 9e			jp macro_next 
aeb5				endm 
# End of macro NEXTW
aeb5			.THEN: 
aeb5				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aeb5 1f				db WORD_SYS_CORE+11             
aeb6 dd ae			dw .ELSE            
aeb8 05				db 4 + 1 
aeb9 .. 00			db "THEN",0              
aebe				endm 
# End of macro CWHEAD
aebe			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aebe					if DEBUG_FORTH_WORDS_KEY 
aebe						DMARK "THN" 
aebe f5				push af  
aebf 3a d3 ae			ld a, (.dmark)  
aec2 32 6b ee			ld (debug_mark),a  
aec5 3a d4 ae			ld a, (.dmark+1)  
aec8 32 6c ee			ld (debug_mark+1),a  
aecb 3a d5 ae			ld a, (.dmark+2)  
aece 32 6d ee			ld (debug_mark+2),a  
aed1 18 03			jr .pastdmark  
aed3 ..			.dmark: db "THN"  
aed6 f1			.pastdmark: pop af  
aed7			endm  
# End of macro DMARK
aed7						CALLMONITOR 
aed7 cd 6f ee			call debug_vector  
aeda				endm  
# End of macro CALLMONITOR
aeda					endif 
aeda					NEXTW 
aeda c3 29 9e			jp macro_next 
aedd				endm 
# End of macro NEXTW
aedd			.ELSE: 
aedd				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aedd 20				db WORD_SYS_CORE+12             
aede 05 af			dw .DO            
aee0 03				db 2 + 1 
aee1 .. 00			db "ELSE",0              
aee6				endm 
# End of macro CWHEAD
aee6			; | ELSE ( -- ) Not supported - does nothing | TODO 
aee6			 
aee6					if DEBUG_FORTH_WORDS_KEY 
aee6						DMARK "ELS" 
aee6 f5				push af  
aee7 3a fb ae			ld a, (.dmark)  
aeea 32 6b ee			ld (debug_mark),a  
aeed 3a fc ae			ld a, (.dmark+1)  
aef0 32 6c ee			ld (debug_mark+1),a  
aef3 3a fd ae			ld a, (.dmark+2)  
aef6 32 6d ee			ld (debug_mark+2),a  
aef9 18 03			jr .pastdmark  
aefb ..			.dmark: db "ELS"  
aefe f1			.pastdmark: pop af  
aeff			endm  
# End of macro DMARK
aeff						CALLMONITOR 
aeff cd 6f ee			call debug_vector  
af02				endm  
# End of macro CALLMONITOR
af02					endif 
af02			 
af02			 
af02					NEXTW 
af02 c3 29 9e			jp macro_next 
af05				endm 
# End of macro NEXTW
af05			.DO: 
af05				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af05 21				db WORD_SYS_CORE+13             
af06 2c b0			dw .LOOP            
af08 03				db 2 + 1 
af09 .. 00			db "DO",0              
af0c				endm 
# End of macro CWHEAD
af0c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af0c			 
af0c					if DEBUG_FORTH_WORDS_KEY 
af0c						DMARK "DO." 
af0c f5				push af  
af0d 3a 21 af			ld a, (.dmark)  
af10 32 6b ee			ld (debug_mark),a  
af13 3a 22 af			ld a, (.dmark+1)  
af16 32 6c ee			ld (debug_mark+1),a  
af19 3a 23 af			ld a, (.dmark+2)  
af1c 32 6d ee			ld (debug_mark+2),a  
af1f 18 03			jr .pastdmark  
af21 ..			.dmark: db "DO."  
af24 f1			.pastdmark: pop af  
af25			endm  
# End of macro DMARK
af25						CALLMONITOR 
af25 cd 6f ee			call debug_vector  
af28				endm  
# End of macro CALLMONITOR
af28					endif 
af28			;  push pc to rsp stack past the DO 
af28			 
af28 2a c2 e5				ld hl, (os_tok_ptr) 
af2b 23					inc hl   ; D 
af2c 23					inc hl  ; O 
af2d 23					inc hl   ; null 
af2e					if DEBUG_FORTH_WORDS 
af2e						DMARK "DO2" 
af2e f5				push af  
af2f 3a 43 af			ld a, (.dmark)  
af32 32 6b ee			ld (debug_mark),a  
af35 3a 44 af			ld a, (.dmark+1)  
af38 32 6c ee			ld (debug_mark+1),a  
af3b 3a 45 af			ld a, (.dmark+2)  
af3e 32 6d ee			ld (debug_mark+2),a  
af41 18 03			jr .pastdmark  
af43 ..			.dmark: db "DO2"  
af46 f1			.pastdmark: pop af  
af47			endm  
# End of macro DMARK
af47						CALLMONITOR 
af47 cd 6f ee			call debug_vector  
af4a				endm  
# End of macro CALLMONITOR
af4a					endif 
af4a					FORTH_RSP_NEXT 
af4a cd 15 9a			call macro_forth_rsp_next 
af4d				endm 
# End of macro FORTH_RSP_NEXT
af4d					if DEBUG_FORTH_WORDS 
af4d						DMARK "DO3" 
af4d f5				push af  
af4e 3a 62 af			ld a, (.dmark)  
af51 32 6b ee			ld (debug_mark),a  
af54 3a 63 af			ld a, (.dmark+1)  
af57 32 6c ee			ld (debug_mark+1),a  
af5a 3a 64 af			ld a, (.dmark+2)  
af5d 32 6d ee			ld (debug_mark+2),a  
af60 18 03			jr .pastdmark  
af62 ..			.dmark: db "DO3"  
af65 f1			.pastdmark: pop af  
af66			endm  
# End of macro DMARK
af66						CALLMONITOR 
af66 cd 6f ee			call debug_vector  
af69				endm  
# End of macro CALLMONITOR
af69					endif 
af69			 
af69					;if DEBUG_FORTH_WORDS 
af69				;		push hl 
af69			;		endif  
af69			 
af69			; get counters from data stack 
af69			 
af69			 
af69					FORTH_DSP_VALUEHL 
af69 cd 73 9c			call macro_dsp_valuehl 
af6c				endm 
# End of macro FORTH_DSP_VALUEHL
af6c e5					push hl		 ; hl now has starting counter which needs to be tos 
af6d			 
af6d					if DEBUG_FORTH_WORDS 
af6d						DMARK "DO4" 
af6d f5				push af  
af6e 3a 82 af			ld a, (.dmark)  
af71 32 6b ee			ld (debug_mark),a  
af74 3a 83 af			ld a, (.dmark+1)  
af77 32 6c ee			ld (debug_mark+1),a  
af7a 3a 84 af			ld a, (.dmark+2)  
af7d 32 6d ee			ld (debug_mark+2),a  
af80 18 03			jr .pastdmark  
af82 ..			.dmark: db "DO4"  
af85 f1			.pastdmark: pop af  
af86			endm  
# End of macro DMARK
af86						CALLMONITOR 
af86 cd 6f ee			call debug_vector  
af89				endm  
# End of macro CALLMONITOR
af89					endif 
af89					FORTH_DSP_POP 
af89 cd 2b 9d			call macro_forth_dsp_pop 
af8c				endm 
# End of macro FORTH_DSP_POP
af8c			 
af8c					if DEBUG_FORTH_WORDS 
af8c						DMARK "DO5" 
af8c f5				push af  
af8d 3a a1 af			ld a, (.dmark)  
af90 32 6b ee			ld (debug_mark),a  
af93 3a a2 af			ld a, (.dmark+1)  
af96 32 6c ee			ld (debug_mark+1),a  
af99 3a a3 af			ld a, (.dmark+2)  
af9c 32 6d ee			ld (debug_mark+2),a  
af9f 18 03			jr .pastdmark  
afa1 ..			.dmark: db "DO5"  
afa4 f1			.pastdmark: pop af  
afa5			endm  
# End of macro DMARK
afa5						CALLMONITOR 
afa5 cd 6f ee			call debug_vector  
afa8				endm  
# End of macro CALLMONITOR
afa8					endif 
afa8			 
afa8					FORTH_DSP_VALUEHL 
afa8 cd 73 9c			call macro_dsp_valuehl 
afab				endm 
# End of macro FORTH_DSP_VALUEHL
afab			;		push hl		 ; hl now has starting limit counter 
afab			 
afab					if DEBUG_FORTH_WORDS 
afab						DMARK "DO6" 
afab f5				push af  
afac 3a c0 af			ld a, (.dmark)  
afaf 32 6b ee			ld (debug_mark),a  
afb2 3a c1 af			ld a, (.dmark+1)  
afb5 32 6c ee			ld (debug_mark+1),a  
afb8 3a c2 af			ld a, (.dmark+2)  
afbb 32 6d ee			ld (debug_mark+2),a  
afbe 18 03			jr .pastdmark  
afc0 ..			.dmark: db "DO6"  
afc3 f1			.pastdmark: pop af  
afc4			endm  
# End of macro DMARK
afc4						CALLMONITOR 
afc4 cd 6f ee			call debug_vector  
afc7				endm  
# End of macro CALLMONITOR
afc7					endif 
afc7					FORTH_DSP_POP 
afc7 cd 2b 9d			call macro_forth_dsp_pop 
afca				endm 
# End of macro FORTH_DSP_POP
afca			 
afca			; put counters on the loop stack 
afca			 
afca			;		pop hl			 ; limit counter 
afca d1					pop de			; start counter 
afcb			 
afcb					; push limit counter 
afcb			 
afcb					if DEBUG_FORTH_WORDS 
afcb						DMARK "DO7" 
afcb f5				push af  
afcc 3a e0 af			ld a, (.dmark)  
afcf 32 6b ee			ld (debug_mark),a  
afd2 3a e1 af			ld a, (.dmark+1)  
afd5 32 6c ee			ld (debug_mark+1),a  
afd8 3a e2 af			ld a, (.dmark+2)  
afdb 32 6d ee			ld (debug_mark+2),a  
afde 18 03			jr .pastdmark  
afe0 ..			.dmark: db "DO7"  
afe3 f1			.pastdmark: pop af  
afe4			endm  
# End of macro DMARK
afe4						CALLMONITOR 
afe4 cd 6f ee			call debug_vector  
afe7				endm  
# End of macro CALLMONITOR
afe7					endif 
afe7					FORTH_LOOP_NEXT 
afe7 cd a4 9c			call macro_forth_loop_next 
afea				endm 
# End of macro FORTH_LOOP_NEXT
afea			 
afea					; push start counter 
afea			 
afea eb					ex de, hl 
afeb					if DEBUG_FORTH_WORDS 
afeb						DMARK "DO7" 
afeb f5				push af  
afec 3a 00 b0			ld a, (.dmark)  
afef 32 6b ee			ld (debug_mark),a  
aff2 3a 01 b0			ld a, (.dmark+1)  
aff5 32 6c ee			ld (debug_mark+1),a  
aff8 3a 02 b0			ld a, (.dmark+2)  
affb 32 6d ee			ld (debug_mark+2),a  
affe 18 03			jr .pastdmark  
b000 ..			.dmark: db "DO7"  
b003 f1			.pastdmark: pop af  
b004			endm  
# End of macro DMARK
b004						CALLMONITOR 
b004 cd 6f ee			call debug_vector  
b007				endm  
# End of macro CALLMONITOR
b007					endif 
b007					FORTH_LOOP_NEXT 
b007 cd a4 9c			call macro_forth_loop_next 
b00a				endm 
# End of macro FORTH_LOOP_NEXT
b00a			 
b00a			 
b00a					; init first round of I counter 
b00a			 
b00a 22 e6 e5				ld (os_current_i), hl 
b00d			 
b00d					if DEBUG_FORTH_WORDS 
b00d						DMARK "DO8" 
b00d f5				push af  
b00e 3a 22 b0			ld a, (.dmark)  
b011 32 6b ee			ld (debug_mark),a  
b014 3a 23 b0			ld a, (.dmark+1)  
b017 32 6c ee			ld (debug_mark+1),a  
b01a 3a 24 b0			ld a, (.dmark+2)  
b01d 32 6d ee			ld (debug_mark+2),a  
b020 18 03			jr .pastdmark  
b022 ..			.dmark: db "DO8"  
b025 f1			.pastdmark: pop af  
b026			endm  
# End of macro DMARK
b026						CALLMONITOR 
b026 cd 6f ee			call debug_vector  
b029				endm  
# End of macro CALLMONITOR
b029					endif 
b029			 
b029					NEXTW 
b029 c3 29 9e			jp macro_next 
b02c				endm 
# End of macro NEXTW
b02c			.LOOP: 
b02c				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b02c 22				db WORD_SYS_CORE+14             
b02d 44 b1			dw .I            
b02f 05				db 4 + 1 
b030 .. 00			db "LOOP",0              
b035				endm 
# End of macro CWHEAD
b035			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b035			 
b035				; pop tos as current loop count to hl 
b035			 
b035				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b035			 
b035				FORTH_LOOP_TOS 
b035 cd d7 9c			call macro_forth_loop_tos 
b038				endm 
# End of macro FORTH_LOOP_TOS
b038 e5				push hl 
b039			 
b039					if DEBUG_FORTH_WORDS_KEY 
b039						DMARK "LOP" 
b039 f5				push af  
b03a 3a 4e b0			ld a, (.dmark)  
b03d 32 6b ee			ld (debug_mark),a  
b040 3a 4f b0			ld a, (.dmark+1)  
b043 32 6c ee			ld (debug_mark+1),a  
b046 3a 50 b0			ld a, (.dmark+2)  
b049 32 6d ee			ld (debug_mark+2),a  
b04c 18 03			jr .pastdmark  
b04e ..			.dmark: db "LOP"  
b051 f1			.pastdmark: pop af  
b052			endm  
# End of macro DMARK
b052						CALLMONITOR 
b052 cd 6f ee			call debug_vector  
b055				endm  
# End of macro CALLMONITOR
b055					endif 
b055				; next item on the stack is the limit. get it 
b055			 
b055			 
b055				FORTH_LOOP_POP 
b055 cd e1 9c			call macro_forth_loop_pop 
b058				endm 
# End of macro FORTH_LOOP_POP
b058			 
b058				FORTH_LOOP_TOS 
b058 cd d7 9c			call macro_forth_loop_tos 
b05b				endm 
# End of macro FORTH_LOOP_TOS
b05b			 
b05b d1				pop de		 ; de = i, hl = limit 
b05c			 
b05c					if DEBUG_FORTH_WORDS 
b05c						DMARK "LP1" 
b05c f5				push af  
b05d 3a 71 b0			ld a, (.dmark)  
b060 32 6b ee			ld (debug_mark),a  
b063 3a 72 b0			ld a, (.dmark+1)  
b066 32 6c ee			ld (debug_mark+1),a  
b069 3a 73 b0			ld a, (.dmark+2)  
b06c 32 6d ee			ld (debug_mark+2),a  
b06f 18 03			jr .pastdmark  
b071 ..			.dmark: db "LP1"  
b074 f1			.pastdmark: pop af  
b075			endm  
# End of macro DMARK
b075						CALLMONITOR 
b075 cd 6f ee			call debug_vector  
b078				endm  
# End of macro CALLMONITOR
b078					endif 
b078			 
b078				; go back to previous word 
b078			 
b078 d5				push de    ; save I for inc later 
b079			 
b079			 
b079				; get limit 
b079				;  is I at limit? 
b079			 
b079			 
b079					if DEBUG_FORTH_WORDS 
b079						DMARK "LP1" 
b079 f5				push af  
b07a 3a 8e b0			ld a, (.dmark)  
b07d 32 6b ee			ld (debug_mark),a  
b080 3a 8f b0			ld a, (.dmark+1)  
b083 32 6c ee			ld (debug_mark+1),a  
b086 3a 90 b0			ld a, (.dmark+2)  
b089 32 6d ee			ld (debug_mark+2),a  
b08c 18 03			jr .pastdmark  
b08e ..			.dmark: db "LP1"  
b091 f1			.pastdmark: pop af  
b092			endm  
# End of macro DMARK
b092						CALLMONITOR 
b092 cd 6f ee			call debug_vector  
b095				endm  
# End of macro CALLMONITOR
b095					endif 
b095			 
b095 ed 52			sbc hl, de 
b097			 
b097			 
b097				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b097			 
b097 20 26				jr nz, .loopnotdone 
b099			 
b099 e1				pop hl   ; get rid of saved I 
b09a				FORTH_LOOP_POP     ; get rid of limit 
b09a cd e1 9c			call macro_forth_loop_pop 
b09d				endm 
# End of macro FORTH_LOOP_POP
b09d			 
b09d				FORTH_RSP_POP     ; get rid of DO ptr 
b09d cd 36 9a			call macro_forth_rsp_pop 
b0a0				endm 
# End of macro FORTH_RSP_POP
b0a0			 
b0a0			if DEBUG_FORTH_WORDS 
b0a0						DMARK "LP>" 
b0a0 f5				push af  
b0a1 3a b5 b0			ld a, (.dmark)  
b0a4 32 6b ee			ld (debug_mark),a  
b0a7 3a b6 b0			ld a, (.dmark+1)  
b0aa 32 6c ee			ld (debug_mark+1),a  
b0ad 3a b7 b0			ld a, (.dmark+2)  
b0b0 32 6d ee			ld (debug_mark+2),a  
b0b3 18 03			jr .pastdmark  
b0b5 ..			.dmark: db "LP>"  
b0b8 f1			.pastdmark: pop af  
b0b9			endm  
# End of macro DMARK
b0b9				CALLMONITOR 
b0b9 cd 6f ee			call debug_vector  
b0bc				endm  
# End of macro CALLMONITOR
b0bc			endif 
b0bc			 
b0bc					NEXTW 
b0bc c3 29 9e			jp macro_next 
b0bf				endm 
# End of macro NEXTW
b0bf				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0bf			 
b0bf			.loopnotdone: 
b0bf			 
b0bf e1				pop hl    ; get I 
b0c0 23				inc hl 
b0c1			 
b0c1			   	; save new I 
b0c1			 
b0c1			 
b0c1					; set I counter 
b0c1			 
b0c1 22 e6 e5				ld (os_current_i), hl 
b0c4			 
b0c4					if DEBUG_FORTH_WORDS 
b0c4						DMARK "LPN" 
b0c4 f5				push af  
b0c5 3a d9 b0			ld a, (.dmark)  
b0c8 32 6b ee			ld (debug_mark),a  
b0cb 3a da b0			ld a, (.dmark+1)  
b0ce 32 6c ee			ld (debug_mark+1),a  
b0d1 3a db b0			ld a, (.dmark+2)  
b0d4 32 6d ee			ld (debug_mark+2),a  
b0d7 18 03			jr .pastdmark  
b0d9 ..			.dmark: db "LPN"  
b0dc f1			.pastdmark: pop af  
b0dd			endm  
# End of macro DMARK
b0dd					CALLMONITOR 
b0dd cd 6f ee			call debug_vector  
b0e0				endm  
# End of macro CALLMONITOR
b0e0					endif 
b0e0					 
b0e0				FORTH_LOOP_NEXT 
b0e0 cd a4 9c			call macro_forth_loop_next 
b0e3				endm 
# End of macro FORTH_LOOP_NEXT
b0e3			 
b0e3			 
b0e3					if DEBUG_FORTH_WORDS 
b0e3 eb						ex de,hl 
b0e4					endif 
b0e4			 
b0e4			;	; get DO ptr 
b0e4			; 
b0e4					if DEBUG_FORTH_WORDS 
b0e4						DMARK "LP7" 
b0e4 f5				push af  
b0e5 3a f9 b0			ld a, (.dmark)  
b0e8 32 6b ee			ld (debug_mark),a  
b0eb 3a fa b0			ld a, (.dmark+1)  
b0ee 32 6c ee			ld (debug_mark+1),a  
b0f1 3a fb b0			ld a, (.dmark+2)  
b0f4 32 6d ee			ld (debug_mark+2),a  
b0f7 18 03			jr .pastdmark  
b0f9 ..			.dmark: db "LP7"  
b0fc f1			.pastdmark: pop af  
b0fd			endm  
# End of macro DMARK
b0fd					CALLMONITOR 
b0fd cd 6f ee			call debug_vector  
b100				endm  
# End of macro CALLMONITOR
b100					endif 
b100				FORTH_RSP_TOS 
b100 cd 2c 9a			call macro_forth_rsp_tos 
b103				endm 
# End of macro FORTH_RSP_TOS
b103			 
b103					if DEBUG_FORTH_WORDS 
b103						DMARK "LP8" 
b103 f5				push af  
b104 3a 18 b1			ld a, (.dmark)  
b107 32 6b ee			ld (debug_mark),a  
b10a 3a 19 b1			ld a, (.dmark+1)  
b10d 32 6c ee			ld (debug_mark+1),a  
b110 3a 1a b1			ld a, (.dmark+2)  
b113 32 6d ee			ld (debug_mark+2),a  
b116 18 03			jr .pastdmark  
b118 ..			.dmark: db "LP8"  
b11b f1			.pastdmark: pop af  
b11c			endm  
# End of macro DMARK
b11c					CALLMONITOR 
b11c cd 6f ee			call debug_vector  
b11f				endm  
# End of macro CALLMONITOR
b11f					endif 
b11f				;push hl 
b11f			 
b11f				; not going to DO any more 
b11f				; get rid of the RSP pointer as DO will add it back in 
b11f				;FORTH_RSP_POP 
b11f				;pop hl 
b11f			 
b11f				;ld hl,(cli_ret_sp) 
b11f				;ld e, (hl) 
b11f				;inc hl 
b11f				;ld d, (hl) 
b11f				;ex de,hl 
b11f 22 c2 e5			ld (os_tok_ptr), hl 
b122					if DEBUG_FORTH_WORDS 
b122						DMARK "LP<" 
b122 f5				push af  
b123 3a 37 b1			ld a, (.dmark)  
b126 32 6b ee			ld (debug_mark),a  
b129 3a 38 b1			ld a, (.dmark+1)  
b12c 32 6c ee			ld (debug_mark+1),a  
b12f 3a 39 b1			ld a, (.dmark+2)  
b132 32 6d ee			ld (debug_mark+2),a  
b135 18 03			jr .pastdmark  
b137 ..			.dmark: db "LP<"  
b13a f1			.pastdmark: pop af  
b13b			endm  
# End of macro DMARK
b13b					CALLMONITOR 
b13b cd 6f ee			call debug_vector  
b13e				endm  
# End of macro CALLMONITOR
b13e				endif 
b13e c3 ba 9e			jp exec1 
b141			 
b141					 
b141			 
b141			 
b141					NEXTW 
b141 c3 29 9e			jp macro_next 
b144				endm 
# End of macro NEXTW
b144			.I:  
b144			 
b144				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b144 5e				db WORD_SYS_CORE+74             
b145 6f b1			dw .DLOOP            
b147 02				db 1 + 1 
b148 .. 00			db "I",0              
b14a				endm 
# End of macro CWHEAD
b14a			; | I ( -- ) Current loop counter | DONE 
b14a					if DEBUG_FORTH_WORDS_KEY 
b14a						DMARK "I.." 
b14a f5				push af  
b14b 3a 5f b1			ld a, (.dmark)  
b14e 32 6b ee			ld (debug_mark),a  
b151 3a 60 b1			ld a, (.dmark+1)  
b154 32 6c ee			ld (debug_mark+1),a  
b157 3a 61 b1			ld a, (.dmark+2)  
b15a 32 6d ee			ld (debug_mark+2),a  
b15d 18 03			jr .pastdmark  
b15f ..			.dmark: db "I.."  
b162 f1			.pastdmark: pop af  
b163			endm  
# End of macro DMARK
b163						CALLMONITOR 
b163 cd 6f ee			call debug_vector  
b166				endm  
# End of macro CALLMONITOR
b166					endif 
b166			 
b166 2a e6 e5				ld hl,(os_current_i) 
b169 cd 6e 9a				call forth_push_numhl 
b16c			 
b16c					NEXTW 
b16c c3 29 9e			jp macro_next 
b16f				endm 
# End of macro NEXTW
b16f			.DLOOP: 
b16f				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b16f 5f				db WORD_SYS_CORE+75             
b170 50 b2			dw .REPEAT            
b172 06				db 5 + 1 
b173 .. 00			db "-LOOP",0              
b179				endm 
# End of macro CWHEAD
b179			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b179				; pop tos as current loop count to hl 
b179					if DEBUG_FORTH_WORDS_KEY 
b179						DMARK "-LP" 
b179 f5				push af  
b17a 3a 8e b1			ld a, (.dmark)  
b17d 32 6b ee			ld (debug_mark),a  
b180 3a 8f b1			ld a, (.dmark+1)  
b183 32 6c ee			ld (debug_mark+1),a  
b186 3a 90 b1			ld a, (.dmark+2)  
b189 32 6d ee			ld (debug_mark+2),a  
b18c 18 03			jr .pastdmark  
b18e ..			.dmark: db "-LP"  
b191 f1			.pastdmark: pop af  
b192			endm  
# End of macro DMARK
b192						CALLMONITOR 
b192 cd 6f ee			call debug_vector  
b195				endm  
# End of macro CALLMONITOR
b195					endif 
b195			 
b195				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b195			 
b195				FORTH_LOOP_TOS 
b195 cd d7 9c			call macro_forth_loop_tos 
b198				endm 
# End of macro FORTH_LOOP_TOS
b198 e5				push hl 
b199			 
b199					if DEBUG_FORTH_WORDS 
b199						DMARK "-LP" 
b199 f5				push af  
b19a 3a ae b1			ld a, (.dmark)  
b19d 32 6b ee			ld (debug_mark),a  
b1a0 3a af b1			ld a, (.dmark+1)  
b1a3 32 6c ee			ld (debug_mark+1),a  
b1a6 3a b0 b1			ld a, (.dmark+2)  
b1a9 32 6d ee			ld (debug_mark+2),a  
b1ac 18 03			jr .pastdmark  
b1ae ..			.dmark: db "-LP"  
b1b1 f1			.pastdmark: pop af  
b1b2			endm  
# End of macro DMARK
b1b2						CALLMONITOR 
b1b2 cd 6f ee			call debug_vector  
b1b5				endm  
# End of macro CALLMONITOR
b1b5					endif 
b1b5				; next item on the stack is the limit. get it 
b1b5			 
b1b5			 
b1b5				FORTH_LOOP_POP 
b1b5 cd e1 9c			call macro_forth_loop_pop 
b1b8				endm 
# End of macro FORTH_LOOP_POP
b1b8			 
b1b8				FORTH_LOOP_TOS 
b1b8 cd d7 9c			call macro_forth_loop_tos 
b1bb				endm 
# End of macro FORTH_LOOP_TOS
b1bb			 
b1bb d1				pop de		 ; de = i, hl = limit 
b1bc			 
b1bc					if DEBUG_FORTH_WORDS 
b1bc						DMARK "-L1" 
b1bc f5				push af  
b1bd 3a d1 b1			ld a, (.dmark)  
b1c0 32 6b ee			ld (debug_mark),a  
b1c3 3a d2 b1			ld a, (.dmark+1)  
b1c6 32 6c ee			ld (debug_mark+1),a  
b1c9 3a d3 b1			ld a, (.dmark+2)  
b1cc 32 6d ee			ld (debug_mark+2),a  
b1cf 18 03			jr .pastdmark  
b1d1 ..			.dmark: db "-L1"  
b1d4 f1			.pastdmark: pop af  
b1d5			endm  
# End of macro DMARK
b1d5						CALLMONITOR 
b1d5 cd 6f ee			call debug_vector  
b1d8				endm  
# End of macro CALLMONITOR
b1d8					endif 
b1d8			 
b1d8				; go back to previous word 
b1d8			 
b1d8 d5				push de    ; save I for inc later 
b1d9			 
b1d9			 
b1d9				; get limit 
b1d9				;  is I at limit? 
b1d9			 
b1d9			 
b1d9					if DEBUG_FORTH_WORDS 
b1d9						DMARK "-L1" 
b1d9 f5				push af  
b1da 3a ee b1			ld a, (.dmark)  
b1dd 32 6b ee			ld (debug_mark),a  
b1e0 3a ef b1			ld a, (.dmark+1)  
b1e3 32 6c ee			ld (debug_mark+1),a  
b1e6 3a f0 b1			ld a, (.dmark+2)  
b1e9 32 6d ee			ld (debug_mark+2),a  
b1ec 18 03			jr .pastdmark  
b1ee ..			.dmark: db "-L1"  
b1f1 f1			.pastdmark: pop af  
b1f2			endm  
# End of macro DMARK
b1f2						CALLMONITOR 
b1f2 cd 6f ee			call debug_vector  
b1f5				endm  
# End of macro CALLMONITOR
b1f5					endif 
b1f5			 
b1f5 ed 52			sbc hl, de 
b1f7			 
b1f7			 
b1f7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b1f7			 
b1f7 20 26				jr nz, .mloopnotdone 
b1f9			 
b1f9 e1				pop hl   ; get rid of saved I 
b1fa				FORTH_LOOP_POP     ; get rid of limit 
b1fa cd e1 9c			call macro_forth_loop_pop 
b1fd				endm 
# End of macro FORTH_LOOP_POP
b1fd			 
b1fd				FORTH_RSP_POP     ; get rid of DO ptr 
b1fd cd 36 9a			call macro_forth_rsp_pop 
b200				endm 
# End of macro FORTH_RSP_POP
b200			 
b200			if DEBUG_FORTH_WORDS 
b200						DMARK "-L>" 
b200 f5				push af  
b201 3a 15 b2			ld a, (.dmark)  
b204 32 6b ee			ld (debug_mark),a  
b207 3a 16 b2			ld a, (.dmark+1)  
b20a 32 6c ee			ld (debug_mark+1),a  
b20d 3a 17 b2			ld a, (.dmark+2)  
b210 32 6d ee			ld (debug_mark+2),a  
b213 18 03			jr .pastdmark  
b215 ..			.dmark: db "-L>"  
b218 f1			.pastdmark: pop af  
b219			endm  
# End of macro DMARK
b219				CALLMONITOR 
b219 cd 6f ee			call debug_vector  
b21c				endm  
# End of macro CALLMONITOR
b21c			endif 
b21c			 
b21c					NEXTW 
b21c c3 29 9e			jp macro_next 
b21f				endm 
# End of macro NEXTW
b21f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b21f			 
b21f			.mloopnotdone: 
b21f			 
b21f e1				pop hl    ; get I 
b220 2b				dec hl 
b221			 
b221			   	; save new I 
b221			 
b221			 
b221					; set I counter 
b221			 
b221 22 e6 e5				ld (os_current_i), hl 
b224			 
b224					 
b224				FORTH_LOOP_NEXT 
b224 cd a4 9c			call macro_forth_loop_next 
b227				endm 
# End of macro FORTH_LOOP_NEXT
b227			 
b227			 
b227					if DEBUG_FORTH_WORDS 
b227 eb						ex de,hl 
b228					endif 
b228			 
b228			;	; get DO ptr 
b228			; 
b228				FORTH_RSP_TOS 
b228 cd 2c 9a			call macro_forth_rsp_tos 
b22b				endm 
# End of macro FORTH_RSP_TOS
b22b			 
b22b				;push hl 
b22b			 
b22b				; not going to DO any more 
b22b				; get rid of the RSP pointer as DO will add it back in 
b22b				;FORTH_RSP_POP 
b22b				;pop hl 
b22b			 
b22b			 
b22b 22 c2 e5			ld (os_tok_ptr), hl 
b22e					if DEBUG_FORTH_WORDS 
b22e						DMARK "-L<" 
b22e f5				push af  
b22f 3a 43 b2			ld a, (.dmark)  
b232 32 6b ee			ld (debug_mark),a  
b235 3a 44 b2			ld a, (.dmark+1)  
b238 32 6c ee			ld (debug_mark+1),a  
b23b 3a 45 b2			ld a, (.dmark+2)  
b23e 32 6d ee			ld (debug_mark+2),a  
b241 18 03			jr .pastdmark  
b243 ..			.dmark: db "-L<"  
b246 f1			.pastdmark: pop af  
b247			endm  
# End of macro DMARK
b247					CALLMONITOR 
b247 cd 6f ee			call debug_vector  
b24a				endm  
# End of macro CALLMONITOR
b24a				endif 
b24a c3 ba 9e			jp exec1 
b24d			 
b24d					 
b24d			 
b24d			 
b24d			 
b24d				NEXTW 
b24d c3 29 9e			jp macro_next 
b250				endm 
# End of macro NEXTW
b250			 
b250			 
b250			 
b250			 
b250			.REPEAT: 
b250				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b250 71				db WORD_SYS_CORE+93             
b251 a3 b2			dw .UNTIL            
b253 06				db 5 + 1 
b254 .. 00			db "REPEAT",0              
b25b				endm 
# End of macro CWHEAD
b25b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b25b			;  push pc to rsp stack past the REPEAT 
b25b					if DEBUG_FORTH_WORDS_KEY 
b25b						DMARK "REP" 
b25b f5				push af  
b25c 3a 70 b2			ld a, (.dmark)  
b25f 32 6b ee			ld (debug_mark),a  
b262 3a 71 b2			ld a, (.dmark+1)  
b265 32 6c ee			ld (debug_mark+1),a  
b268 3a 72 b2			ld a, (.dmark+2)  
b26b 32 6d ee			ld (debug_mark+2),a  
b26e 18 03			jr .pastdmark  
b270 ..			.dmark: db "REP"  
b273 f1			.pastdmark: pop af  
b274			endm  
# End of macro DMARK
b274						CALLMONITOR 
b274 cd 6f ee			call debug_vector  
b277				endm  
# End of macro CALLMONITOR
b277					endif 
b277			 
b277 2a c2 e5				ld hl, (os_tok_ptr) 
b27a 23					inc hl   ; R 
b27b 23					inc hl  ; E 
b27c 23					inc hl   ; P 
b27d 23					inc hl   ; E 
b27e 23					inc hl   ; A 
b27f 23					inc hl   ; T 
b280 23					inc hl   ; zero 
b281					FORTH_RSP_NEXT 
b281 cd 15 9a			call macro_forth_rsp_next 
b284				endm 
# End of macro FORTH_RSP_NEXT
b284			 
b284			 
b284					if DEBUG_FORTH_WORDS 
b284						DMARK "REP" 
b284 f5				push af  
b285 3a 99 b2			ld a, (.dmark)  
b288 32 6b ee			ld (debug_mark),a  
b28b 3a 9a b2			ld a, (.dmark+1)  
b28e 32 6c ee			ld (debug_mark+1),a  
b291 3a 9b b2			ld a, (.dmark+2)  
b294 32 6d ee			ld (debug_mark+2),a  
b297 18 03			jr .pastdmark  
b299 ..			.dmark: db "REP"  
b29c f1			.pastdmark: pop af  
b29d			endm  
# End of macro DMARK
b29d						;pop bc    ; TODO BUG ?????? what is this for???? 
b29d						CALLMONITOR 
b29d cd 6f ee			call debug_vector  
b2a0				endm  
# End of macro CALLMONITOR
b2a0					endif 
b2a0			 
b2a0					NEXTW 
b2a0 c3 29 9e			jp macro_next 
b2a3				endm 
# End of macro NEXTW
b2a3			;	       NEXTW 
b2a3			 
b2a3			.UNTIL: 
b2a3				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b2a3 72				db WORD_SYS_CORE+94             
b2a4 3a b3			dw .ENDFLOW            
b2a6 06				db 5 + 1 
b2a7 .. 00			db "UNTIL",0              
b2ad				endm 
# End of macro CWHEAD
b2ad			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b2ad			 
b2ad				; pop tos as check 
b2ad			 
b2ad				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b2ad			 
b2ad				FORTH_DSP_VALUEHL 
b2ad cd 73 9c			call macro_dsp_valuehl 
b2b0				endm 
# End of macro FORTH_DSP_VALUEHL
b2b0			 
b2b0					if DEBUG_FORTH_WORDS_KEY 
b2b0						DMARK "UNT" 
b2b0 f5				push af  
b2b1 3a c5 b2			ld a, (.dmark)  
b2b4 32 6b ee			ld (debug_mark),a  
b2b7 3a c6 b2			ld a, (.dmark+1)  
b2ba 32 6c ee			ld (debug_mark+1),a  
b2bd 3a c7 b2			ld a, (.dmark+2)  
b2c0 32 6d ee			ld (debug_mark+2),a  
b2c3 18 03			jr .pastdmark  
b2c5 ..			.dmark: db "UNT"  
b2c8 f1			.pastdmark: pop af  
b2c9			endm  
# End of macro DMARK
b2c9						CALLMONITOR 
b2c9 cd 6f ee			call debug_vector  
b2cc				endm  
# End of macro CALLMONITOR
b2cc					endif 
b2cc			 
b2cc			;	push hl 
b2cc				FORTH_DSP_POP 
b2cc cd 2b 9d			call macro_forth_dsp_pop 
b2cf				endm 
# End of macro FORTH_DSP_POP
b2cf			 
b2cf			;	pop hl 
b2cf			 
b2cf				; test if true 
b2cf			 
b2cf cd 10 8d			call ishlzero 
b2d2			;	ld a,l 
b2d2			;	add h 
b2d2			; 
b2d2			;	cp 0 
b2d2			 
b2d2 20 3e			jr nz, .untilnotdone 
b2d4			 
b2d4					if DEBUG_FORTH_WORDS 
b2d4						DMARK "UNf" 
b2d4 f5				push af  
b2d5 3a e9 b2			ld a, (.dmark)  
b2d8 32 6b ee			ld (debug_mark),a  
b2db 3a ea b2			ld a, (.dmark+1)  
b2de 32 6c ee			ld (debug_mark+1),a  
b2e1 3a eb b2			ld a, (.dmark+2)  
b2e4 32 6d ee			ld (debug_mark+2),a  
b2e7 18 03			jr .pastdmark  
b2e9 ..			.dmark: db "UNf"  
b2ec f1			.pastdmark: pop af  
b2ed			endm  
# End of macro DMARK
b2ed						CALLMONITOR 
b2ed cd 6f ee			call debug_vector  
b2f0				endm  
# End of macro CALLMONITOR
b2f0					endif 
b2f0			 
b2f0			 
b2f0			 
b2f0				FORTH_RSP_POP     ; get rid of DO ptr 
b2f0 cd 36 9a			call macro_forth_rsp_pop 
b2f3				endm 
# End of macro FORTH_RSP_POP
b2f3			 
b2f3			if DEBUG_FORTH_WORDS 
b2f3						DMARK "UN>" 
b2f3 f5				push af  
b2f4 3a 08 b3			ld a, (.dmark)  
b2f7 32 6b ee			ld (debug_mark),a  
b2fa 3a 09 b3			ld a, (.dmark+1)  
b2fd 32 6c ee			ld (debug_mark+1),a  
b300 3a 0a b3			ld a, (.dmark+2)  
b303 32 6d ee			ld (debug_mark+2),a  
b306 18 03			jr .pastdmark  
b308 ..			.dmark: db "UN>"  
b30b f1			.pastdmark: pop af  
b30c			endm  
# End of macro DMARK
b30c				CALLMONITOR 
b30c cd 6f ee			call debug_vector  
b30f				endm  
# End of macro CALLMONITOR
b30f			endif 
b30f			 
b30f					NEXTW 
b30f c3 29 9e			jp macro_next 
b312				endm 
# End of macro NEXTW
b312				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b312			 
b312			.untilnotdone: 
b312			 
b312			 
b312			;	; get DO ptr 
b312			; 
b312				FORTH_RSP_TOS 
b312 cd 2c 9a			call macro_forth_rsp_tos 
b315				endm 
# End of macro FORTH_RSP_TOS
b315			 
b315				;push hl 
b315			 
b315				; not going to DO any more 
b315				; get rid of the RSP pointer as DO will add it back in 
b315				;FORTH_RSP_POP 
b315				;pop hl 
b315			 
b315			 
b315 22 c2 e5			ld (os_tok_ptr), hl 
b318					if DEBUG_FORTH_WORDS 
b318						DMARK "UN<" 
b318 f5				push af  
b319 3a 2d b3			ld a, (.dmark)  
b31c 32 6b ee			ld (debug_mark),a  
b31f 3a 2e b3			ld a, (.dmark+1)  
b322 32 6c ee			ld (debug_mark+1),a  
b325 3a 2f b3			ld a, (.dmark+2)  
b328 32 6d ee			ld (debug_mark+2),a  
b32b 18 03			jr .pastdmark  
b32d ..			.dmark: db "UN<"  
b330 f1			.pastdmark: pop af  
b331			endm  
# End of macro DMARK
b331					CALLMONITOR 
b331 cd 6f ee			call debug_vector  
b334				endm  
# End of macro CALLMONITOR
b334				endif 
b334 c3 ba 9e			jp exec1 
b337			 
b337					 
b337			 
b337			 
b337					NEXTW 
b337 c3 29 9e			jp macro_next 
b33a				endm 
# End of macro NEXTW
b33a			 
b33a			 
b33a			.ENDFLOW: 
b33a			 
b33a			; eof 
b33a			 
# End of file forth_words_flow.asm
b33a			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b33a			include "forth_words_logic.asm" 
b33a			 
b33a			; | ## Logic Words 
b33a			 
b33a			.NOT: 
b33a				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b33a 2d				db WORD_SYS_CORE+25             
b33b 82 b3			dw .IS            
b33d 04				db 3 + 1 
b33e .. 00			db "NOT",0              
b342				endm 
# End of macro CWHEAD
b342			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b342					if DEBUG_FORTH_WORDS_KEY 
b342						DMARK "NOT" 
b342 f5				push af  
b343 3a 57 b3			ld a, (.dmark)  
b346 32 6b ee			ld (debug_mark),a  
b349 3a 58 b3			ld a, (.dmark+1)  
b34c 32 6c ee			ld (debug_mark+1),a  
b34f 3a 59 b3			ld a, (.dmark+2)  
b352 32 6d ee			ld (debug_mark+2),a  
b355 18 03			jr .pastdmark  
b357 ..			.dmark: db "NOT"  
b35a f1			.pastdmark: pop af  
b35b			endm  
# End of macro DMARK
b35b						CALLMONITOR 
b35b cd 6f ee			call debug_vector  
b35e				endm  
# End of macro CALLMONITOR
b35e					endif 
b35e					FORTH_DSP 
b35e cd 39 9c			call macro_forth_dsp 
b361				endm 
# End of macro FORTH_DSP
b361 7e					ld a,(hl)	; get type of value on TOS 
b362 fe 02				cp DS_TYPE_INUM  
b364 28 03				jr z, .noti 
b366					NEXTW 
b366 c3 29 9e			jp macro_next 
b369				endm 
# End of macro NEXTW
b369			.noti:          FORTH_DSP_VALUEHL 
b369 cd 73 9c			call macro_dsp_valuehl 
b36c				endm 
# End of macro FORTH_DSP_VALUEHL
b36c			;		push hl 
b36c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b36c cd 2b 9d			call macro_forth_dsp_pop 
b36f				endm 
# End of macro FORTH_DSP_POP
b36f			;		pop hl 
b36f 3e 00				ld a,0 
b371 bd					cp l 
b372 28 04				jr z, .not2t 
b374 2e 00				ld l, 0 
b376 18 02				jr .notip 
b378			 
b378 2e ff		.not2t:		ld l, 255 
b37a			 
b37a 26 00		.notip:		ld h, 0	 
b37c			 
b37c cd 6e 9a				call forth_push_numhl 
b37f					NEXTW 
b37f c3 29 9e			jp macro_next 
b382				endm 
# End of macro NEXTW
b382			 
b382			.IS: 
b382				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b382 2d				db WORD_SYS_CORE+25             
b383 a8 b3			dw .LZERO            
b385 03				db 2 + 1 
b386 .. 00			db "IS",0              
b389				endm 
# End of macro CWHEAD
b389			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b389					if DEBUG_FORTH_WORDS_KEY 
b389						DMARK "IS." 
b389 f5				push af  
b38a 3a 9e b3			ld a, (.dmark)  
b38d 32 6b ee			ld (debug_mark),a  
b390 3a 9f b3			ld a, (.dmark+1)  
b393 32 6c ee			ld (debug_mark+1),a  
b396 3a a0 b3			ld a, (.dmark+2)  
b399 32 6d ee			ld (debug_mark+2),a  
b39c 18 03			jr .pastdmark  
b39e ..			.dmark: db "IS."  
b3a1 f1			.pastdmark: pop af  
b3a2			endm  
# End of macro DMARK
b3a2						CALLMONITOR 
b3a2 cd 6f ee			call debug_vector  
b3a5				endm  
# End of macro CALLMONITOR
b3a5					endif 
b3a5					NEXTW 
b3a5 c3 29 9e			jp macro_next 
b3a8				endm 
# End of macro NEXTW
b3a8			.LZERO: 
b3a8				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b3a8 2d				db WORD_SYS_CORE+25             
b3a9 b2 b3			dw .TZERO            
b3ab 03				db 2 + 1 
b3ac .. 00			db "0<",0              
b3af				endm 
# End of macro CWHEAD
b3af			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b3af					NEXTW 
b3af c3 29 9e			jp macro_next 
b3b2				endm 
# End of macro NEXTW
b3b2			.TZERO: 
b3b2				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b3b2 2e				db WORD_SYS_CORE+26             
b3b3 f9 b3			dw .LESS            
b3b5 03				db 2 + 1 
b3b6 .. 00			db "0=",0              
b3b9				endm 
# End of macro CWHEAD
b3b9			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b3b9				; TODO add floating point number detection 
b3b9					;v5 FORTH_DSP_VALUE 
b3b9					if DEBUG_FORTH_WORDS_KEY 
b3b9						DMARK "0=." 
b3b9 f5				push af  
b3ba 3a ce b3			ld a, (.dmark)  
b3bd 32 6b ee			ld (debug_mark),a  
b3c0 3a cf b3			ld a, (.dmark+1)  
b3c3 32 6c ee			ld (debug_mark+1),a  
b3c6 3a d0 b3			ld a, (.dmark+2)  
b3c9 32 6d ee			ld (debug_mark+2),a  
b3cc 18 03			jr .pastdmark  
b3ce ..			.dmark: db "0=."  
b3d1 f1			.pastdmark: pop af  
b3d2			endm  
# End of macro DMARK
b3d2						CALLMONITOR 
b3d2 cd 6f ee			call debug_vector  
b3d5				endm  
# End of macro CALLMONITOR
b3d5					endif 
b3d5					FORTH_DSP 
b3d5 cd 39 9c			call macro_forth_dsp 
b3d8				endm 
# End of macro FORTH_DSP
b3d8 7e					ld a,(hl)	; get type of value on TOS 
b3d9 fe 02				cp DS_TYPE_INUM  
b3db 28 00				jr z, .tz_inum 
b3dd			 
b3dd				if FORTH_ENABLE_FLOATMATH 
b3dd					jr .tz_done 
b3dd			 
b3dd				endif 
b3dd					 
b3dd			 
b3dd			.tz_inum: 
b3dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3dd cd 73 9c			call macro_dsp_valuehl 
b3e0				endm 
# End of macro FORTH_DSP_VALUEHL
b3e0			 
b3e0			;		push hl 
b3e0			 
b3e0					; destroy value TOS 
b3e0			 
b3e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3e0 cd 2b 9d			call macro_forth_dsp_pop 
b3e3				endm 
# End of macro FORTH_DSP_POP
b3e3			 
b3e3			;		pop hl 
b3e3			 
b3e3 3e 00				ld a,0 
b3e5			 
b3e5 bd					cp l 
b3e6 20 08				jr nz, .tz_notzero 
b3e8			 
b3e8 bc					cp h 
b3e9			 
b3e9 20 05				jr nz, .tz_notzero 
b3eb			 
b3eb			 
b3eb 21 01 00				ld hl, FORTH_TRUE 
b3ee 18 03				jr .tz_done 
b3f0			 
b3f0 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b3f3			 
b3f3					; push value back onto stack for another op etc 
b3f3			 
b3f3			.tz_done: 
b3f3 cd 6e 9a				call forth_push_numhl 
b3f6			 
b3f6					NEXTW 
b3f6 c3 29 9e			jp macro_next 
b3f9				endm 
# End of macro NEXTW
b3f9			.LESS: 
b3f9				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b3f9 2f				db WORD_SYS_CORE+27             
b3fa 62 b4			dw .GT            
b3fc 02				db 1 + 1 
b3fd .. 00			db "<",0              
b3ff				endm 
# End of macro CWHEAD
b3ff			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3ff				; TODO add floating point number detection 
b3ff					if DEBUG_FORTH_WORDS_KEY 
b3ff						DMARK "LES" 
b3ff f5				push af  
b400 3a 14 b4			ld a, (.dmark)  
b403 32 6b ee			ld (debug_mark),a  
b406 3a 15 b4			ld a, (.dmark+1)  
b409 32 6c ee			ld (debug_mark+1),a  
b40c 3a 16 b4			ld a, (.dmark+2)  
b40f 32 6d ee			ld (debug_mark+2),a  
b412 18 03			jr .pastdmark  
b414 ..			.dmark: db "LES"  
b417 f1			.pastdmark: pop af  
b418			endm  
# End of macro DMARK
b418						CALLMONITOR 
b418 cd 6f ee			call debug_vector  
b41b				endm  
# End of macro CALLMONITOR
b41b					endif 
b41b					FORTH_DSP 
b41b cd 39 9c			call macro_forth_dsp 
b41e				endm 
# End of macro FORTH_DSP
b41e					;v5 FORTH_DSP_VALUE 
b41e 7e					ld a,(hl)	; get type of value on TOS 
b41f fe 02				cp DS_TYPE_INUM  
b421 28 00				jr z, .less_inum 
b423			 
b423				if FORTH_ENABLE_FLOATMATH 
b423					jr .less_done 
b423			 
b423				endif 
b423					 
b423			 
b423			.less_inum: 
b423					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b423 cd 73 9c			call macro_dsp_valuehl 
b426				endm 
# End of macro FORTH_DSP_VALUEHL
b426			 
b426 e5					push hl  ; u2 
b427			 
b427					; destroy value TOS 
b427			 
b427					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b427 cd 2b 9d			call macro_forth_dsp_pop 
b42a				endm 
# End of macro FORTH_DSP_POP
b42a			 
b42a			 
b42a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b42a cd 73 9c			call macro_dsp_valuehl 
b42d				endm 
# End of macro FORTH_DSP_VALUEHL
b42d			 
b42d e5					push hl    ; u1 
b42e			 
b42e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b42e cd 2b 9d			call macro_forth_dsp_pop 
b431				endm 
# End of macro FORTH_DSP_POP
b431			 
b431			 
b431 b7			 or a      ;clear carry flag 
b432 01 00 00		 ld bc, FORTH_FALSE 
b435 e1			  pop hl    ; u1 
b436 d1			  pop de    ; u2 
b437 ed 52		  sbc hl,de 
b439 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b43b			 
b43b 01 01 00		 ld bc, FORTH_TRUE 
b43e			.lscont:  
b43e c5					push bc 
b43f e1					pop hl 
b440			 
b440					if DEBUG_FORTH_WORDS 
b440						DMARK "LT1" 
b440 f5				push af  
b441 3a 55 b4			ld a, (.dmark)  
b444 32 6b ee			ld (debug_mark),a  
b447 3a 56 b4			ld a, (.dmark+1)  
b44a 32 6c ee			ld (debug_mark+1),a  
b44d 3a 57 b4			ld a, (.dmark+2)  
b450 32 6d ee			ld (debug_mark+2),a  
b453 18 03			jr .pastdmark  
b455 ..			.dmark: db "LT1"  
b458 f1			.pastdmark: pop af  
b459			endm  
# End of macro DMARK
b459						CALLMONITOR 
b459 cd 6f ee			call debug_vector  
b45c				endm  
# End of macro CALLMONITOR
b45c					endif 
b45c cd 6e 9a				call forth_push_numhl 
b45f			 
b45f					NEXTW 
b45f c3 29 9e			jp macro_next 
b462				endm 
# End of macro NEXTW
b462			.GT: 
b462				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b462 30				db WORD_SYS_CORE+28             
b463 cb b4			dw .EQUAL            
b465 02				db 1 + 1 
b466 .. 00			db ">",0              
b468				endm 
# End of macro CWHEAD
b468			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b468				; TODO add floating point number detection 
b468					if DEBUG_FORTH_WORDS_KEY 
b468						DMARK "GRT" 
b468 f5				push af  
b469 3a 7d b4			ld a, (.dmark)  
b46c 32 6b ee			ld (debug_mark),a  
b46f 3a 7e b4			ld a, (.dmark+1)  
b472 32 6c ee			ld (debug_mark+1),a  
b475 3a 7f b4			ld a, (.dmark+2)  
b478 32 6d ee			ld (debug_mark+2),a  
b47b 18 03			jr .pastdmark  
b47d ..			.dmark: db "GRT"  
b480 f1			.pastdmark: pop af  
b481			endm  
# End of macro DMARK
b481						CALLMONITOR 
b481 cd 6f ee			call debug_vector  
b484				endm  
# End of macro CALLMONITOR
b484					endif 
b484					FORTH_DSP 
b484 cd 39 9c			call macro_forth_dsp 
b487				endm 
# End of macro FORTH_DSP
b487					;FORTH_DSP_VALUE 
b487 7e					ld a,(hl)	; get type of value on TOS 
b488 fe 02				cp DS_TYPE_INUM  
b48a 28 00				jr z, .gt_inum 
b48c			 
b48c				if FORTH_ENABLE_FLOATMATH 
b48c					jr .gt_done 
b48c			 
b48c				endif 
b48c					 
b48c			 
b48c			.gt_inum: 
b48c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b48c cd 73 9c			call macro_dsp_valuehl 
b48f				endm 
# End of macro FORTH_DSP_VALUEHL
b48f			 
b48f e5					push hl  ; u2 
b490			 
b490					; destroy value TOS 
b490			 
b490					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b490 cd 2b 9d			call macro_forth_dsp_pop 
b493				endm 
# End of macro FORTH_DSP_POP
b493			 
b493			 
b493					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b493 cd 73 9c			call macro_dsp_valuehl 
b496				endm 
# End of macro FORTH_DSP_VALUEHL
b496			 
b496 e5					push hl    ; u1 
b497			 
b497					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b497 cd 2b 9d			call macro_forth_dsp_pop 
b49a				endm 
# End of macro FORTH_DSP_POP
b49a			 
b49a			 
b49a b7			 or a      ;clear carry flag 
b49b 01 00 00		 ld bc, FORTH_FALSE 
b49e e1			  pop hl    ; u1 
b49f d1			  pop de    ; u2 
b4a0 ed 52		  sbc hl,de 
b4a2 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b4a4			 
b4a4 01 01 00		 ld bc, FORTH_TRUE 
b4a7			.gtcont:  
b4a7 c5					push bc 
b4a8 e1					pop hl 
b4a9			 
b4a9					if DEBUG_FORTH_WORDS 
b4a9						DMARK "GT1" 
b4a9 f5				push af  
b4aa 3a be b4			ld a, (.dmark)  
b4ad 32 6b ee			ld (debug_mark),a  
b4b0 3a bf b4			ld a, (.dmark+1)  
b4b3 32 6c ee			ld (debug_mark+1),a  
b4b6 3a c0 b4			ld a, (.dmark+2)  
b4b9 32 6d ee			ld (debug_mark+2),a  
b4bc 18 03			jr .pastdmark  
b4be ..			.dmark: db "GT1"  
b4c1 f1			.pastdmark: pop af  
b4c2			endm  
# End of macro DMARK
b4c2						CALLMONITOR 
b4c2 cd 6f ee			call debug_vector  
b4c5				endm  
# End of macro CALLMONITOR
b4c5					endif 
b4c5 cd 6e 9a				call forth_push_numhl 
b4c8			 
b4c8					NEXTW 
b4c8 c3 29 9e			jp macro_next 
b4cb				endm 
# End of macro NEXTW
b4cb			.EQUAL: 
b4cb				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4cb 31				db WORD_SYS_CORE+29             
b4cc 36 b5			dw .ENDLOGIC            
b4ce 02				db 1 + 1 
b4cf .. 00			db "=",0              
b4d1				endm 
# End of macro CWHEAD
b4d1			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4d1				; TODO add floating point number detection 
b4d1					if DEBUG_FORTH_WORDS_KEY 
b4d1						DMARK "EQ." 
b4d1 f5				push af  
b4d2 3a e6 b4			ld a, (.dmark)  
b4d5 32 6b ee			ld (debug_mark),a  
b4d8 3a e7 b4			ld a, (.dmark+1)  
b4db 32 6c ee			ld (debug_mark+1),a  
b4de 3a e8 b4			ld a, (.dmark+2)  
b4e1 32 6d ee			ld (debug_mark+2),a  
b4e4 18 03			jr .pastdmark  
b4e6 ..			.dmark: db "EQ."  
b4e9 f1			.pastdmark: pop af  
b4ea			endm  
# End of macro DMARK
b4ea						CALLMONITOR 
b4ea cd 6f ee			call debug_vector  
b4ed				endm  
# End of macro CALLMONITOR
b4ed					endif 
b4ed					FORTH_DSP 
b4ed cd 39 9c			call macro_forth_dsp 
b4f0				endm 
# End of macro FORTH_DSP
b4f0					;v5 FORTH_DSP_VALUE 
b4f0 7e					ld a,(hl)	; get type of value on TOS 
b4f1 fe 02				cp DS_TYPE_INUM  
b4f3 28 00				jr z, .eq_inum 
b4f5			 
b4f5				if FORTH_ENABLE_FLOATMATH 
b4f5					jr .eq_done 
b4f5			 
b4f5				endif 
b4f5					 
b4f5			 
b4f5			.eq_inum: 
b4f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4f5 cd 73 9c			call macro_dsp_valuehl 
b4f8				endm 
# End of macro FORTH_DSP_VALUEHL
b4f8			 
b4f8 e5					push hl 
b4f9			 
b4f9					; destroy value TOS 
b4f9			 
b4f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4f9 cd 2b 9d			call macro_forth_dsp_pop 
b4fc				endm 
# End of macro FORTH_DSP_POP
b4fc			 
b4fc			 
b4fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4fc cd 73 9c			call macro_dsp_valuehl 
b4ff				endm 
# End of macro FORTH_DSP_VALUEHL
b4ff			 
b4ff					; one value on hl get other one back 
b4ff			 
b4ff e5					push hl 
b500			 
b500					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b500 cd 2b 9d			call macro_forth_dsp_pop 
b503				endm 
# End of macro FORTH_DSP_POP
b503			 
b503 0e 00				ld c, FORTH_FALSE 
b505			 
b505 e1					pop hl 
b506 d1					pop de 
b507			 
b507 7b					ld a, e 
b508 bd					cp l 
b509			 
b509 20 06				jr nz, .eq_done 
b50b			 
b50b 7a					ld a, d 
b50c bc					cp h 
b50d			 
b50d 20 02				jr nz, .eq_done 
b50f			 
b50f 0e 01				ld c, FORTH_TRUE 
b511					 
b511			 
b511			 
b511			.eq_done: 
b511			 
b511					; TODO push value back onto stack for another op etc 
b511			 
b511 26 00				ld h, 0 
b513 69					ld l, c 
b514					if DEBUG_FORTH_WORDS 
b514						DMARK "EQ1" 
b514 f5				push af  
b515 3a 29 b5			ld a, (.dmark)  
b518 32 6b ee			ld (debug_mark),a  
b51b 3a 2a b5			ld a, (.dmark+1)  
b51e 32 6c ee			ld (debug_mark+1),a  
b521 3a 2b b5			ld a, (.dmark+2)  
b524 32 6d ee			ld (debug_mark+2),a  
b527 18 03			jr .pastdmark  
b529 ..			.dmark: db "EQ1"  
b52c f1			.pastdmark: pop af  
b52d			endm  
# End of macro DMARK
b52d						CALLMONITOR 
b52d cd 6f ee			call debug_vector  
b530				endm  
# End of macro CALLMONITOR
b530					endif 
b530 cd 6e 9a				call forth_push_numhl 
b533			 
b533					NEXTW 
b533 c3 29 9e			jp macro_next 
b536				endm 
# End of macro NEXTW
b536			 
b536			 
b536			.ENDLOGIC: 
b536			; eof 
b536			 
b536			 
# End of file forth_words_logic.asm
b536			include "forth_words_maths.asm" 
b536			 
b536			; | ## Maths Words 
b536			 
b536			.PLUS:	 
b536				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b536 15				db WORD_SYS_CORE+1             
b537 94 b5			dw .NEG            
b539 02				db 1 + 1 
b53a .. 00			db "+",0              
b53c				endm 
# End of macro CWHEAD
b53c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b53c					if DEBUG_FORTH_WORDS_KEY 
b53c						DMARK "PLU" 
b53c f5				push af  
b53d 3a 51 b5			ld a, (.dmark)  
b540 32 6b ee			ld (debug_mark),a  
b543 3a 52 b5			ld a, (.dmark+1)  
b546 32 6c ee			ld (debug_mark+1),a  
b549 3a 53 b5			ld a, (.dmark+2)  
b54c 32 6d ee			ld (debug_mark+2),a  
b54f 18 03			jr .pastdmark  
b551 ..			.dmark: db "PLU"  
b554 f1			.pastdmark: pop af  
b555			endm  
# End of macro DMARK
b555						CALLMONITOR 
b555 cd 6f ee			call debug_vector  
b558				endm  
# End of macro CALLMONITOR
b558					endif 
b558					; add top two values and push back result 
b558			 
b558					;for v5 FORTH_DSP_VALUE 
b558					FORTH_DSP 
b558 cd 39 9c			call macro_forth_dsp 
b55b				endm 
# End of macro FORTH_DSP
b55b 7e					ld a,(hl)	; get type of value on TOS 
b55c fe 02				cp DS_TYPE_INUM  
b55e 28 03				jr z, .dot_inum 
b560			 
b560					NEXTW 
b560 c3 29 9e			jp macro_next 
b563				endm 
# End of macro NEXTW
b563			 
b563			; float maths 
b563			 
b563				if FORTH_ENABLE_FLOATMATH 
b563						inc hl      ; now at start of numeric as string 
b563			 
b563					if DEBUG_FORTH_MATHS 
b563						DMARK "ADD" 
b563				CALLMONITOR 
b563					endif 
b563			 
b563					;ld ix, hl 
b563					call CON 
b563			 
b563			 
b563					push hl 
b563					 
b563					 
b563			 
b563						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b563			 
b563					; get next number 
b563			 
b563						FORTH_DSP_VALUE 
b563			 
b563						inc hl      ; now at start of numeric as string 
b563			 
b563					;ld ix, hl 
b563					call CON 
b563			 
b563					push hl 
b563			 
b563			 
b563						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b563			 
b563						; TODO do add 
b563			 
b563						call IADD 
b563			 
b563						; TODO get result back as ascii 
b563			 
b563						; TODO push result  
b563			 
b563			 
b563			 
b563						jr .dot_done 
b563				endif 
b563			 
b563			.dot_inum: 
b563			 
b563			 
b563					if DEBUG_FORTH_DOT 
b563						DMARK "+IT" 
b563 f5				push af  
b564 3a 78 b5			ld a, (.dmark)  
b567 32 6b ee			ld (debug_mark),a  
b56a 3a 79 b5			ld a, (.dmark+1)  
b56d 32 6c ee			ld (debug_mark+1),a  
b570 3a 7a b5			ld a, (.dmark+2)  
b573 32 6d ee			ld (debug_mark+2),a  
b576 18 03			jr .pastdmark  
b578 ..			.dmark: db "+IT"  
b57b f1			.pastdmark: pop af  
b57c			endm  
# End of macro DMARK
b57c				CALLMONITOR 
b57c cd 6f ee			call debug_vector  
b57f				endm  
# End of macro CALLMONITOR
b57f					endif 
b57f			 
b57f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b57f cd 73 9c			call macro_dsp_valuehl 
b582				endm 
# End of macro FORTH_DSP_VALUEHL
b582			 
b582				; TODO add floating point number detection 
b582			 
b582 e5					push hl 
b583			 
b583					; destroy value TOS 
b583			 
b583					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b583 cd 2b 9d			call macro_forth_dsp_pop 
b586				endm 
# End of macro FORTH_DSP_POP
b586			 
b586			 
b586					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b586 cd 73 9c			call macro_dsp_valuehl 
b589				endm 
# End of macro FORTH_DSP_VALUEHL
b589			 
b589					; one value on hl get other one back 
b589			 
b589 d1					pop de 
b58a			 
b58a					; do the add 
b58a			 
b58a 19					add hl,de 
b58b			 
b58b					; save it 
b58b			 
b58b			;		push hl	 
b58b			 
b58b					; 
b58b			 
b58b					; destroy value TOS 
b58b			 
b58b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b58b cd 2b 9d			call macro_forth_dsp_pop 
b58e				endm 
# End of macro FORTH_DSP_POP
b58e			 
b58e					; TODO push value back onto stack for another op etc 
b58e			 
b58e			;		pop hl 
b58e			 
b58e			.dot_done: 
b58e cd 6e 9a				call forth_push_numhl 
b591			 
b591					NEXTW 
b591 c3 29 9e			jp macro_next 
b594				endm 
# End of macro NEXTW
b594			.NEG: 
b594			 
b594				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b594 17				db WORD_SYS_CORE+3             
b595 d7 b5			dw .DIV            
b597 02				db 1 + 1 
b598 .. 00			db "-",0              
b59a				endm 
# End of macro CWHEAD
b59a			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b59a					if DEBUG_FORTH_WORDS_KEY 
b59a						DMARK "SUB" 
b59a f5				push af  
b59b 3a af b5			ld a, (.dmark)  
b59e 32 6b ee			ld (debug_mark),a  
b5a1 3a b0 b5			ld a, (.dmark+1)  
b5a4 32 6c ee			ld (debug_mark+1),a  
b5a7 3a b1 b5			ld a, (.dmark+2)  
b5aa 32 6d ee			ld (debug_mark+2),a  
b5ad 18 03			jr .pastdmark  
b5af ..			.dmark: db "SUB"  
b5b2 f1			.pastdmark: pop af  
b5b3			endm  
# End of macro DMARK
b5b3						CALLMONITOR 
b5b3 cd 6f ee			call debug_vector  
b5b6				endm  
# End of macro CALLMONITOR
b5b6					endif 
b5b6			 
b5b6			 
b5b6				; TODO add floating point number detection 
b5b6					; v5 FORTH_DSP_VALUE 
b5b6					FORTH_DSP 
b5b6 cd 39 9c			call macro_forth_dsp 
b5b9				endm 
# End of macro FORTH_DSP
b5b9 7e					ld a,(hl)	; get type of value on TOS 
b5ba fe 02				cp DS_TYPE_INUM  
b5bc 28 03				jr z, .neg_inum 
b5be			 
b5be					NEXTW 
b5be c3 29 9e			jp macro_next 
b5c1				endm 
# End of macro NEXTW
b5c1			 
b5c1			; float maths 
b5c1			 
b5c1				if FORTH_ENABLE_FLOATMATH 
b5c1					jr .neg_done 
b5c1			 
b5c1				endif 
b5c1					 
b5c1			 
b5c1			.neg_inum: 
b5c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5c1 cd 73 9c			call macro_dsp_valuehl 
b5c4				endm 
# End of macro FORTH_DSP_VALUEHL
b5c4			 
b5c4 e5					push hl 
b5c5			 
b5c5					; destroy value TOS 
b5c5			 
b5c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5c5 cd 2b 9d			call macro_forth_dsp_pop 
b5c8				endm 
# End of macro FORTH_DSP_POP
b5c8			 
b5c8			 
b5c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5c8 cd 73 9c			call macro_dsp_valuehl 
b5cb				endm 
# End of macro FORTH_DSP_VALUEHL
b5cb			 
b5cb					; one value on hl get other one back 
b5cb			 
b5cb d1					pop de 
b5cc			 
b5cc					; do the sub 
b5cc			;		ex de, hl 
b5cc			 
b5cc ed 52				sbc hl,de 
b5ce			 
b5ce					; save it 
b5ce			 
b5ce			;		push hl	 
b5ce			 
b5ce					; 
b5ce			 
b5ce					; destroy value TOS 
b5ce			 
b5ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ce cd 2b 9d			call macro_forth_dsp_pop 
b5d1				endm 
# End of macro FORTH_DSP_POP
b5d1			 
b5d1					; TODO push value back onto stack for another op etc 
b5d1			 
b5d1			;		pop hl 
b5d1			 
b5d1 cd 6e 9a				call forth_push_numhl 
b5d4			.neg_done: 
b5d4			 
b5d4					NEXTW 
b5d4 c3 29 9e			jp macro_next 
b5d7				endm 
# End of macro NEXTW
b5d7			.DIV: 
b5d7				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5d7 18				db WORD_SYS_CORE+4             
b5d8 24 b6			dw .MUL            
b5da 02				db 1 + 1 
b5db .. 00			db "/",0              
b5dd				endm 
# End of macro CWHEAD
b5dd			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5dd					if DEBUG_FORTH_WORDS_KEY 
b5dd						DMARK "DIV" 
b5dd f5				push af  
b5de 3a f2 b5			ld a, (.dmark)  
b5e1 32 6b ee			ld (debug_mark),a  
b5e4 3a f3 b5			ld a, (.dmark+1)  
b5e7 32 6c ee			ld (debug_mark+1),a  
b5ea 3a f4 b5			ld a, (.dmark+2)  
b5ed 32 6d ee			ld (debug_mark+2),a  
b5f0 18 03			jr .pastdmark  
b5f2 ..			.dmark: db "DIV"  
b5f5 f1			.pastdmark: pop af  
b5f6			endm  
# End of macro DMARK
b5f6						CALLMONITOR 
b5f6 cd 6f ee			call debug_vector  
b5f9				endm  
# End of macro CALLMONITOR
b5f9					endif 
b5f9				; TODO add floating point number detection 
b5f9					; v5 FORTH_DSP_VALUE 
b5f9					FORTH_DSP 
b5f9 cd 39 9c			call macro_forth_dsp 
b5fc				endm 
# End of macro FORTH_DSP
b5fc 7e					ld a,(hl)	; get type of value on TOS 
b5fd fe 02				cp DS_TYPE_INUM  
b5ff 28 03				jr z, .div_inum 
b601			 
b601				if FORTH_ENABLE_FLOATMATH 
b601					jr .div_done 
b601			 
b601				endif 
b601					NEXTW 
b601 c3 29 9e			jp macro_next 
b604				endm 
# End of macro NEXTW
b604			.div_inum: 
b604			 
b604					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b604 cd 73 9c			call macro_dsp_valuehl 
b607				endm 
# End of macro FORTH_DSP_VALUEHL
b607			 
b607 e5					push hl    ; to go to bc 
b608			 
b608					; destroy value TOS 
b608			 
b608					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b608 cd 2b 9d			call macro_forth_dsp_pop 
b60b				endm 
# End of macro FORTH_DSP_POP
b60b			 
b60b			 
b60b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b60b cd 73 9c			call macro_dsp_valuehl 
b60e				endm 
# End of macro FORTH_DSP_VALUEHL
b60e			 
b60e					; hl to go to de 
b60e			 
b60e e5					push hl 
b60f			 
b60f c1					pop bc 
b610 d1					pop de		 
b611			 
b611			 
b611					if DEBUG_FORTH_MATHS 
b611						DMARK "DIV" 
b611				CALLMONITOR 
b611					endif 
b611					; one value on hl but move to a get other one back 
b611			 
b611			        
b611 cd 44 8c			call Div16 
b614			 
b614			;	push af	 
b614 e5				push hl 
b615 c5				push bc 
b616			 
b616					if DEBUG_FORTH_MATHS 
b616						DMARK "DI1" 
b616				CALLMONITOR 
b616					endif 
b616			 
b616					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b616 cd 2b 9d			call macro_forth_dsp_pop 
b619				endm 
# End of macro FORTH_DSP_POP
b619			 
b619			 
b619			 
b619 e1					pop hl    ; result 
b61a			 
b61a cd 6e 9a				call forth_push_numhl 
b61d			 
b61d e1					pop hl    ; reminder 
b61e			;		ld h,0 
b61e			;		ld l,d 
b61e			 
b61e cd 6e 9a				call forth_push_numhl 
b621			.div_done: 
b621					NEXTW 
b621 c3 29 9e			jp macro_next 
b624				endm 
# End of macro NEXTW
b624			.MUL: 
b624				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b624 19				db WORD_SYS_CORE+5             
b625 69 b6			dw .MIN            
b627 02				db 1 + 1 
b628 .. 00			db "*",0              
b62a				endm 
# End of macro CWHEAD
b62a			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b62a				; TODO add floating point number detection 
b62a					if DEBUG_FORTH_WORDS_KEY 
b62a						DMARK "MUL" 
b62a f5				push af  
b62b 3a 3f b6			ld a, (.dmark)  
b62e 32 6b ee			ld (debug_mark),a  
b631 3a 40 b6			ld a, (.dmark+1)  
b634 32 6c ee			ld (debug_mark+1),a  
b637 3a 41 b6			ld a, (.dmark+2)  
b63a 32 6d ee			ld (debug_mark+2),a  
b63d 18 03			jr .pastdmark  
b63f ..			.dmark: db "MUL"  
b642 f1			.pastdmark: pop af  
b643			endm  
# End of macro DMARK
b643						CALLMONITOR 
b643 cd 6f ee			call debug_vector  
b646				endm  
# End of macro CALLMONITOR
b646					endif 
b646					FORTH_DSP 
b646 cd 39 9c			call macro_forth_dsp 
b649				endm 
# End of macro FORTH_DSP
b649					; v5 FORTH_DSP_VALUE 
b649 7e					ld a,(hl)	; get type of value on TOS 
b64a fe 02				cp DS_TYPE_INUM  
b64c 28 03				jr z, .mul_inum 
b64e			 
b64e				if FORTH_ENABLE_FLOATMATH 
b64e					jr .mul_done 
b64e			 
b64e				endif 
b64e			 
b64e					NEXTW 
b64e c3 29 9e			jp macro_next 
b651				endm 
# End of macro NEXTW
b651			.mul_inum:	 
b651			 
b651					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b651 cd 73 9c			call macro_dsp_valuehl 
b654				endm 
# End of macro FORTH_DSP_VALUEHL
b654			 
b654 e5					push hl 
b655			 
b655					; destroy value TOS 
b655			 
b655					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b655 cd 2b 9d			call macro_forth_dsp_pop 
b658				endm 
# End of macro FORTH_DSP_POP
b658			 
b658			 
b658					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b658 cd 73 9c			call macro_dsp_valuehl 
b65b				endm 
# End of macro FORTH_DSP_VALUEHL
b65b			 
b65b					; one value on hl but move to a get other one back 
b65b			 
b65b 7d					ld a, l 
b65c			 
b65c d1					pop de 
b65d			 
b65d					; do the mull 
b65d			;		ex de, hl 
b65d			 
b65d cd 6a 8c				call Mult16 
b660					; save it 
b660			 
b660			;		push hl	 
b660			 
b660					; 
b660			 
b660					; destroy value TOS 
b660			 
b660					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b660 cd 2b 9d			call macro_forth_dsp_pop 
b663				endm 
# End of macro FORTH_DSP_POP
b663			 
b663					; TODO push value back onto stack for another op etc 
b663			 
b663			;		pop hl 
b663			 
b663 cd 6e 9a				call forth_push_numhl 
b666			 
b666			.mul_done: 
b666					NEXTW 
b666 c3 29 9e			jp macro_next 
b669				endm 
# End of macro NEXTW
b669			 
b669			 
b669			 
b669			 
b669			.MIN: 
b669				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b669 49				db WORD_SYS_CORE+53             
b66a ea b6			dw .MAX            
b66c 04				db 3 + 1 
b66d .. 00			db "MIN",0              
b671				endm 
# End of macro CWHEAD
b671			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b671					if DEBUG_FORTH_WORDS_KEY 
b671						DMARK "MIN" 
b671 f5				push af  
b672 3a 86 b6			ld a, (.dmark)  
b675 32 6b ee			ld (debug_mark),a  
b678 3a 87 b6			ld a, (.dmark+1)  
b67b 32 6c ee			ld (debug_mark+1),a  
b67e 3a 88 b6			ld a, (.dmark+2)  
b681 32 6d ee			ld (debug_mark+2),a  
b684 18 03			jr .pastdmark  
b686 ..			.dmark: db "MIN"  
b689 f1			.pastdmark: pop af  
b68a			endm  
# End of macro DMARK
b68a						CALLMONITOR 
b68a cd 6f ee			call debug_vector  
b68d				endm  
# End of macro CALLMONITOR
b68d					endif 
b68d					; get u2 
b68d			 
b68d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b68d cd 73 9c			call macro_dsp_valuehl 
b690				endm 
# End of macro FORTH_DSP_VALUEHL
b690			 
b690 e5					push hl   ; u2 
b691			 
b691					; destroy value TOS 
b691			 
b691					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b691 cd 2b 9d			call macro_forth_dsp_pop 
b694				endm 
# End of macro FORTH_DSP_POP
b694			 
b694					; get u1 
b694			 
b694					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b694 cd 73 9c			call macro_dsp_valuehl 
b697				endm 
# End of macro FORTH_DSP_VALUEHL
b697			 
b697 e5					push hl  ; u1 
b698			 
b698					; destroy value TOS 
b698			 
b698					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b698 cd 2b 9d			call macro_forth_dsp_pop 
b69b				endm 
# End of macro FORTH_DSP_POP
b69b			 
b69b b7			 or a      ;clear carry flag 
b69c e1			  pop hl    ; u1 
b69d d1			  pop de    ; u2 
b69e e5				push hl   ; saved in case hl is lowest 
b69f ed 52		  sbc hl,de 
b6a1 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b6a3			 
b6a3 e1				pop hl 
b6a4					if DEBUG_FORTH_WORDS 
b6a4						DMARK "MIN" 
b6a4 f5				push af  
b6a5 3a b9 b6			ld a, (.dmark)  
b6a8 32 6b ee			ld (debug_mark),a  
b6ab 3a ba b6			ld a, (.dmark+1)  
b6ae 32 6c ee			ld (debug_mark+1),a  
b6b1 3a bb b6			ld a, (.dmark+2)  
b6b4 32 6d ee			ld (debug_mark+2),a  
b6b7 18 03			jr .pastdmark  
b6b9 ..			.dmark: db "MIN"  
b6bc f1			.pastdmark: pop af  
b6bd			endm  
# End of macro DMARK
b6bd						CALLMONITOR 
b6bd cd 6f ee			call debug_vector  
b6c0				endm  
# End of macro CALLMONITOR
b6c0					endif 
b6c0 cd 6e 9a				call forth_push_numhl 
b6c3			 
b6c3				       NEXTW 
b6c3 c3 29 9e			jp macro_next 
b6c6				endm 
# End of macro NEXTW
b6c6			 
b6c6			.mincont:  
b6c6 c1				pop bc   ; tidy up 
b6c7 eb				ex de , hl  
b6c8					if DEBUG_FORTH_WORDS 
b6c8						DMARK "MI1" 
b6c8 f5				push af  
b6c9 3a dd b6			ld a, (.dmark)  
b6cc 32 6b ee			ld (debug_mark),a  
b6cf 3a de b6			ld a, (.dmark+1)  
b6d2 32 6c ee			ld (debug_mark+1),a  
b6d5 3a df b6			ld a, (.dmark+2)  
b6d8 32 6d ee			ld (debug_mark+2),a  
b6db 18 03			jr .pastdmark  
b6dd ..			.dmark: db "MI1"  
b6e0 f1			.pastdmark: pop af  
b6e1			endm  
# End of macro DMARK
b6e1						CALLMONITOR 
b6e1 cd 6f ee			call debug_vector  
b6e4				endm  
# End of macro CALLMONITOR
b6e4					endif 
b6e4 cd 6e 9a				call forth_push_numhl 
b6e7			 
b6e7				       NEXTW 
b6e7 c3 29 9e			jp macro_next 
b6ea				endm 
# End of macro NEXTW
b6ea			.MAX: 
b6ea				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b6ea 4a				db WORD_SYS_CORE+54             
b6eb 6b b7			dw .RND16            
b6ed 04				db 3 + 1 
b6ee .. 00			db "MAX",0              
b6f2				endm 
# End of macro CWHEAD
b6f2			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b6f2					if DEBUG_FORTH_WORDS_KEY 
b6f2						DMARK "MAX" 
b6f2 f5				push af  
b6f3 3a 07 b7			ld a, (.dmark)  
b6f6 32 6b ee			ld (debug_mark),a  
b6f9 3a 08 b7			ld a, (.dmark+1)  
b6fc 32 6c ee			ld (debug_mark+1),a  
b6ff 3a 09 b7			ld a, (.dmark+2)  
b702 32 6d ee			ld (debug_mark+2),a  
b705 18 03			jr .pastdmark  
b707 ..			.dmark: db "MAX"  
b70a f1			.pastdmark: pop af  
b70b			endm  
# End of macro DMARK
b70b						CALLMONITOR 
b70b cd 6f ee			call debug_vector  
b70e				endm  
# End of macro CALLMONITOR
b70e					endif 
b70e					; get u2 
b70e			 
b70e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b70e cd 73 9c			call macro_dsp_valuehl 
b711				endm 
# End of macro FORTH_DSP_VALUEHL
b711			 
b711 e5					push hl   ; u2 
b712			 
b712					; destroy value TOS 
b712			 
b712					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b712 cd 2b 9d			call macro_forth_dsp_pop 
b715				endm 
# End of macro FORTH_DSP_POP
b715			 
b715					; get u1 
b715			 
b715					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b715 cd 73 9c			call macro_dsp_valuehl 
b718				endm 
# End of macro FORTH_DSP_VALUEHL
b718			 
b718 e5					push hl  ; u1 
b719			 
b719					; destroy value TOS 
b719			 
b719					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b719 cd 2b 9d			call macro_forth_dsp_pop 
b71c				endm 
# End of macro FORTH_DSP_POP
b71c			 
b71c b7			 or a      ;clear carry flag 
b71d e1			  pop hl    ; u1 
b71e d1			  pop de    ; u2 
b71f e5				push hl   ; saved in case hl is lowest 
b720 ed 52		  sbc hl,de 
b722 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b724			 
b724 e1				pop hl 
b725					if DEBUG_FORTH_WORDS 
b725						DMARK "MAX" 
b725 f5				push af  
b726 3a 3a b7			ld a, (.dmark)  
b729 32 6b ee			ld (debug_mark),a  
b72c 3a 3b b7			ld a, (.dmark+1)  
b72f 32 6c ee			ld (debug_mark+1),a  
b732 3a 3c b7			ld a, (.dmark+2)  
b735 32 6d ee			ld (debug_mark+2),a  
b738 18 03			jr .pastdmark  
b73a ..			.dmark: db "MAX"  
b73d f1			.pastdmark: pop af  
b73e			endm  
# End of macro DMARK
b73e						CALLMONITOR 
b73e cd 6f ee			call debug_vector  
b741				endm  
# End of macro CALLMONITOR
b741					endif 
b741 cd 6e 9a				call forth_push_numhl 
b744			 
b744				       NEXTW 
b744 c3 29 9e			jp macro_next 
b747				endm 
# End of macro NEXTW
b747			 
b747			.maxcont:  
b747 c1				pop bc   ; tidy up 
b748 eb				ex de , hl  
b749					if DEBUG_FORTH_WORDS 
b749						DMARK "MA1" 
b749 f5				push af  
b74a 3a 5e b7			ld a, (.dmark)  
b74d 32 6b ee			ld (debug_mark),a  
b750 3a 5f b7			ld a, (.dmark+1)  
b753 32 6c ee			ld (debug_mark+1),a  
b756 3a 60 b7			ld a, (.dmark+2)  
b759 32 6d ee			ld (debug_mark+2),a  
b75c 18 03			jr .pastdmark  
b75e ..			.dmark: db "MA1"  
b761 f1			.pastdmark: pop af  
b762			endm  
# End of macro DMARK
b762						CALLMONITOR 
b762 cd 6f ee			call debug_vector  
b765				endm  
# End of macro CALLMONITOR
b765					endif 
b765 cd 6e 9a				call forth_push_numhl 
b768				       NEXTW 
b768 c3 29 9e			jp macro_next 
b76b				endm 
# End of macro NEXTW
b76b			 
b76b			.RND16: 
b76b				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b76b 4e				db WORD_SYS_CORE+58             
b76c 9a b7			dw .RND8            
b76e 06				db 5 + 1 
b76f .. 00			db "RND16",0              
b775				endm 
# End of macro CWHEAD
b775			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b775					if DEBUG_FORTH_WORDS_KEY 
b775						DMARK "R16" 
b775 f5				push af  
b776 3a 8a b7			ld a, (.dmark)  
b779 32 6b ee			ld (debug_mark),a  
b77c 3a 8b b7			ld a, (.dmark+1)  
b77f 32 6c ee			ld (debug_mark+1),a  
b782 3a 8c b7			ld a, (.dmark+2)  
b785 32 6d ee			ld (debug_mark+2),a  
b788 18 03			jr .pastdmark  
b78a ..			.dmark: db "R16"  
b78d f1			.pastdmark: pop af  
b78e			endm  
# End of macro DMARK
b78e						CALLMONITOR 
b78e cd 6f ee			call debug_vector  
b791				endm  
# End of macro CALLMONITOR
b791					endif 
b791 cd 0e 8c				call prng16  
b794 cd 6e 9a				call forth_push_numhl 
b797				       NEXTW 
b797 c3 29 9e			jp macro_next 
b79a				endm 
# End of macro NEXTW
b79a			.RND8: 
b79a				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b79a 60				db WORD_SYS_CORE+76             
b79b cf b7			dw .RND            
b79d 05				db 4 + 1 
b79e .. 00			db "RND8",0              
b7a3				endm 
# End of macro CWHEAD
b7a3			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b7a3					if DEBUG_FORTH_WORDS_KEY 
b7a3						DMARK "RN8" 
b7a3 f5				push af  
b7a4 3a b8 b7			ld a, (.dmark)  
b7a7 32 6b ee			ld (debug_mark),a  
b7aa 3a b9 b7			ld a, (.dmark+1)  
b7ad 32 6c ee			ld (debug_mark+1),a  
b7b0 3a ba b7			ld a, (.dmark+2)  
b7b3 32 6d ee			ld (debug_mark+2),a  
b7b6 18 03			jr .pastdmark  
b7b8 ..			.dmark: db "RN8"  
b7bb f1			.pastdmark: pop af  
b7bc			endm  
# End of macro DMARK
b7bc						CALLMONITOR 
b7bc cd 6f ee			call debug_vector  
b7bf				endm  
# End of macro CALLMONITOR
b7bf					endif 
b7bf 2a a9 eb				ld hl,(xrandc) 
b7c2 23					inc hl 
b7c3 cd 28 8c				call xrnd 
b7c6 6f					ld l,a	 
b7c7 26 00				ld h,0 
b7c9 cd 6e 9a				call forth_push_numhl 
b7cc				       NEXTW 
b7cc c3 29 9e			jp macro_next 
b7cf				endm 
# End of macro NEXTW
b7cf			.RND: 
b7cf				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7cf 60				db WORD_SYS_CORE+76             
b7d0 d5 b8			dw .ENDMATHS            
b7d2 04				db 3 + 1 
b7d3 .. 00			db "RND",0              
b7d7				endm 
# End of macro CWHEAD
b7d7			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7d7			 
b7d7					if DEBUG_FORTH_WORDS_KEY 
b7d7						DMARK "RND" 
b7d7 f5				push af  
b7d8 3a ec b7			ld a, (.dmark)  
b7db 32 6b ee			ld (debug_mark),a  
b7de 3a ed b7			ld a, (.dmark+1)  
b7e1 32 6c ee			ld (debug_mark+1),a  
b7e4 3a ee b7			ld a, (.dmark+2)  
b7e7 32 6d ee			ld (debug_mark+2),a  
b7ea 18 03			jr .pastdmark  
b7ec ..			.dmark: db "RND"  
b7ef f1			.pastdmark: pop af  
b7f0			endm  
# End of macro DMARK
b7f0						CALLMONITOR 
b7f0 cd 6f ee			call debug_vector  
b7f3				endm  
# End of macro CALLMONITOR
b7f3					endif 
b7f3					 
b7f3					FORTH_DSP_VALUEHL    ; upper range 
b7f3 cd 73 9c			call macro_dsp_valuehl 
b7f6				endm 
# End of macro FORTH_DSP_VALUEHL
b7f6			 
b7f6 22 ad eb				ld (LFSRSeed), hl	 
b7f9			 
b7f9					if DEBUG_FORTH_WORDS 
b7f9						DMARK "RN1" 
b7f9 f5				push af  
b7fa 3a 0e b8			ld a, (.dmark)  
b7fd 32 6b ee			ld (debug_mark),a  
b800 3a 0f b8			ld a, (.dmark+1)  
b803 32 6c ee			ld (debug_mark+1),a  
b806 3a 10 b8			ld a, (.dmark+2)  
b809 32 6d ee			ld (debug_mark+2),a  
b80c 18 03			jr .pastdmark  
b80e ..			.dmark: db "RN1"  
b811 f1			.pastdmark: pop af  
b812			endm  
# End of macro DMARK
b812						CALLMONITOR 
b812 cd 6f ee			call debug_vector  
b815				endm  
# End of macro CALLMONITOR
b815					endif 
b815					FORTH_DSP_POP 
b815 cd 2b 9d			call macro_forth_dsp_pop 
b818				endm 
# End of macro FORTH_DSP_POP
b818			 
b818					FORTH_DSP_VALUEHL    ; low range 
b818 cd 73 9c			call macro_dsp_valuehl 
b81b				endm 
# End of macro FORTH_DSP_VALUEHL
b81b			 
b81b					if DEBUG_FORTH_WORDS 
b81b						DMARK "RN2" 
b81b f5				push af  
b81c 3a 30 b8			ld a, (.dmark)  
b81f 32 6b ee			ld (debug_mark),a  
b822 3a 31 b8			ld a, (.dmark+1)  
b825 32 6c ee			ld (debug_mark+1),a  
b828 3a 32 b8			ld a, (.dmark+2)  
b82b 32 6d ee			ld (debug_mark+2),a  
b82e 18 03			jr .pastdmark  
b830 ..			.dmark: db "RN2"  
b833 f1			.pastdmark: pop af  
b834			endm  
# End of macro DMARK
b834						CALLMONITOR 
b834 cd 6f ee			call debug_vector  
b837				endm  
# End of macro CALLMONITOR
b837					endif 
b837 22 af eb				ld (LFSRSeed+2), hl 
b83a			 
b83a					FORTH_DSP_POP 
b83a cd 2b 9d			call macro_forth_dsp_pop 
b83d				endm 
# End of macro FORTH_DSP_POP
b83d			 
b83d e5					push hl 
b83e			 
b83e e1			.inrange:	pop hl 
b83f cd 0e 8c				call prng16  
b842					if DEBUG_FORTH_WORDS 
b842						DMARK "RN3" 
b842 f5				push af  
b843 3a 57 b8			ld a, (.dmark)  
b846 32 6b ee			ld (debug_mark),a  
b849 3a 58 b8			ld a, (.dmark+1)  
b84c 32 6c ee			ld (debug_mark+1),a  
b84f 3a 59 b8			ld a, (.dmark+2)  
b852 32 6d ee			ld (debug_mark+2),a  
b855 18 03			jr .pastdmark  
b857 ..			.dmark: db "RN3"  
b85a f1			.pastdmark: pop af  
b85b			endm  
# End of macro DMARK
b85b						CALLMONITOR 
b85b cd 6f ee			call debug_vector  
b85e				endm  
# End of macro CALLMONITOR
b85e					endif 
b85e					 
b85e					; if the range is 8bit knock out the high byte 
b85e			 
b85e ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b862			 
b862 3e 00				ld a, 0 
b864 ba					cp d  
b865 20 1e				jr nz, .hirange 
b867 26 00				ld h, 0   ; knock it down to 8bit 
b869			 
b869					if DEBUG_FORTH_WORDS 
b869						DMARK "RNk" 
b869 f5				push af  
b86a 3a 7e b8			ld a, (.dmark)  
b86d 32 6b ee			ld (debug_mark),a  
b870 3a 7f b8			ld a, (.dmark+1)  
b873 32 6c ee			ld (debug_mark+1),a  
b876 3a 80 b8			ld a, (.dmark+2)  
b879 32 6d ee			ld (debug_mark+2),a  
b87c 18 03			jr .pastdmark  
b87e ..			.dmark: db "RNk"  
b881 f1			.pastdmark: pop af  
b882			endm  
# End of macro DMARK
b882						CALLMONITOR 
b882 cd 6f ee			call debug_vector  
b885				endm  
# End of macro CALLMONITOR
b885					endif 
b885			.hirange:   
b885 e5					push hl  
b886 b7					or a  
b887 ed 52		                sbc hl, de 
b889			 
b889					;call cmp16 
b889			 
b889 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b88b e1					pop hl 
b88c e5					push hl 
b88d			 
b88d					if DEBUG_FORTH_WORDS 
b88d						DMARK "RN4" 
b88d f5				push af  
b88e 3a a2 b8			ld a, (.dmark)  
b891 32 6b ee			ld (debug_mark),a  
b894 3a a3 b8			ld a, (.dmark+1)  
b897 32 6c ee			ld (debug_mark+1),a  
b89a 3a a4 b8			ld a, (.dmark+2)  
b89d 32 6d ee			ld (debug_mark+2),a  
b8a0 18 03			jr .pastdmark  
b8a2 ..			.dmark: db "RN4"  
b8a5 f1			.pastdmark: pop af  
b8a6			endm  
# End of macro DMARK
b8a6						CALLMONITOR 
b8a6 cd 6f ee			call debug_vector  
b8a9				endm  
# End of macro CALLMONITOR
b8a9					endif 
b8a9 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b8ad					;call cmp16 
b8ad				 
b8ad b7					or a  
b8ae ed 52		                sbc hl, de 
b8b0 38 8c				jr c, .inrange 
b8b2			 
b8b2 e1					pop hl 
b8b3					 
b8b3					if DEBUG_FORTH_WORDS 
b8b3						DMARK "RNd" 
b8b3 f5				push af  
b8b4 3a c8 b8			ld a, (.dmark)  
b8b7 32 6b ee			ld (debug_mark),a  
b8ba 3a c9 b8			ld a, (.dmark+1)  
b8bd 32 6c ee			ld (debug_mark+1),a  
b8c0 3a ca b8			ld a, (.dmark+2)  
b8c3 32 6d ee			ld (debug_mark+2),a  
b8c6 18 03			jr .pastdmark  
b8c8 ..			.dmark: db "RNd"  
b8cb f1			.pastdmark: pop af  
b8cc			endm  
# End of macro DMARK
b8cc						CALLMONITOR 
b8cc cd 6f ee			call debug_vector  
b8cf				endm  
# End of macro CALLMONITOR
b8cf					endif 
b8cf			 
b8cf			 
b8cf cd 6e 9a				call forth_push_numhl 
b8d2				       NEXTW 
b8d2 c3 29 9e			jp macro_next 
b8d5				endm 
# End of macro NEXTW
b8d5			 
b8d5			.ENDMATHS: 
b8d5			 
b8d5			; eof 
b8d5			 
# End of file forth_words_maths.asm
b8d5			include "forth_words_display.asm" 
b8d5			 
b8d5			; | ## Display Words 
b8d5			 
b8d5			.ACT: 
b8d5			 
b8d5				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8d5 62				db WORD_SYS_CORE+78             
b8d6 21 b9			dw .INFO            
b8d8 07				db 6 + 1 
b8d9 .. 00			db "ACTIVE",0              
b8e0				endm 
# End of macro CWHEAD
b8e0			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b8e0			;  
b8e0			; | | To display a pulsing activity indicator in a processing loop do this... 
b8e0			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
b8e0			 
b8e0					if DEBUG_FORTH_WORDS_KEY 
b8e0						DMARK "ACT" 
b8e0 f5				push af  
b8e1 3a f5 b8			ld a, (.dmark)  
b8e4 32 6b ee			ld (debug_mark),a  
b8e7 3a f6 b8			ld a, (.dmark+1)  
b8ea 32 6c ee			ld (debug_mark+1),a  
b8ed 3a f7 b8			ld a, (.dmark+2)  
b8f0 32 6d ee			ld (debug_mark+2),a  
b8f3 18 03			jr .pastdmark  
b8f5 ..			.dmark: db "ACT"  
b8f8 f1			.pastdmark: pop af  
b8f9			endm  
# End of macro DMARK
b8f9						CALLMONITOR 
b8f9 cd 6f ee			call debug_vector  
b8fc				endm  
# End of macro CALLMONITOR
b8fc					endif 
b8fc cd 11 8a				call active 
b8ff					if DEBUG_FORTH_WORDS 
b8ff						DMARK "ACp" 
b8ff f5				push af  
b900 3a 14 b9			ld a, (.dmark)  
b903 32 6b ee			ld (debug_mark),a  
b906 3a 15 b9			ld a, (.dmark+1)  
b909 32 6c ee			ld (debug_mark+1),a  
b90c 3a 16 b9			ld a, (.dmark+2)  
b90f 32 6d ee			ld (debug_mark+2),a  
b912 18 03			jr .pastdmark  
b914 ..			.dmark: db "ACp"  
b917 f1			.pastdmark: pop af  
b918			endm  
# End of macro DMARK
b918						CALLMONITOR 
b918 cd 6f ee			call debug_vector  
b91b				endm  
# End of macro CALLMONITOR
b91b					endif 
b91b cd dc 9a				call forth_push_str 
b91e			 
b91e					NEXTW 
b91e c3 29 9e			jp macro_next 
b921				endm 
# End of macro NEXTW
b921			.INFO: 
b921			 
b921				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b921 62				db WORD_SYS_CORE+78             
b922 3e b9			dw .ATP            
b924 05				db 4 + 1 
b925 .. 00			db "INFO",0              
b92a				endm 
# End of macro CWHEAD
b92a			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b92a					FORTH_DSP_VALUEHL 
b92a cd 73 9c			call macro_dsp_valuehl 
b92d				endm 
# End of macro FORTH_DSP_VALUEHL
b92d			 
b92d					FORTH_DSP_POP 
b92d cd 2b 9d			call macro_forth_dsp_pop 
b930				endm 
# End of macro FORTH_DSP_POP
b930			 
b930 e5					push hl 
b931			 
b931					FORTH_DSP_VALUEHL 
b931 cd 73 9c			call macro_dsp_valuehl 
b934				endm 
# End of macro FORTH_DSP_VALUEHL
b934			 
b934					FORTH_DSP_POP 
b934 cd 2b 9d			call macro_forth_dsp_pop 
b937				endm 
# End of macro FORTH_DSP_POP
b937			 
b937 d1					pop de 
b938			 
b938 cd 4b 8a				call info_panel 
b93b			 
b93b			 
b93b					NEXTW 
b93b c3 29 9e			jp macro_next 
b93e				endm 
# End of macro NEXTW
b93e			.ATP: 
b93e				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b93e 62				db WORD_SYS_CORE+78             
b93f b5 b9			dw .FB            
b941 04				db 3 + 1 
b942 .. 00			db "AT?",0              
b946				endm 
# End of macro CWHEAD
b946			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b946					if DEBUG_FORTH_WORDS_KEY 
b946						DMARK "AT?" 
b946 f5				push af  
b947 3a 5b b9			ld a, (.dmark)  
b94a 32 6b ee			ld (debug_mark),a  
b94d 3a 5c b9			ld a, (.dmark+1)  
b950 32 6c ee			ld (debug_mark+1),a  
b953 3a 5d b9			ld a, (.dmark+2)  
b956 32 6d ee			ld (debug_mark+2),a  
b959 18 03			jr .pastdmark  
b95b ..			.dmark: db "AT?"  
b95e f1			.pastdmark: pop af  
b95f			endm  
# End of macro DMARK
b95f						CALLMONITOR 
b95f cd 6f ee			call debug_vector  
b962				endm  
# End of macro CALLMONITOR
b962					endif 
b962 3a 5e ea				ld a, (f_cursor_ptr) 
b965			 
b965			if DEBUG_FORTH_WORDS 
b965				DMARK "AT?" 
b965 f5				push af  
b966 3a 7a b9			ld a, (.dmark)  
b969 32 6b ee			ld (debug_mark),a  
b96c 3a 7b b9			ld a, (.dmark+1)  
b96f 32 6c ee			ld (debug_mark+1),a  
b972 3a 7c b9			ld a, (.dmark+2)  
b975 32 6d ee			ld (debug_mark+2),a  
b978 18 03			jr .pastdmark  
b97a ..			.dmark: db "AT?"  
b97d f1			.pastdmark: pop af  
b97e			endm  
# End of macro DMARK
b97e				CALLMONITOR 
b97e cd 6f ee			call debug_vector  
b981				endm  
# End of macro CALLMONITOR
b981			endif	 
b981					; count the number of rows 
b981			 
b981 06 00				ld b, 0 
b983 4f			.atpr:		ld c, a    ; save in case we go below zero 
b984 d6 28				sub display_cols 
b986 f2 8c b9				jp p, .atprunder 
b989 04					inc b 
b98a 18 f7				jr .atpr 
b98c			.atprunder:	 
b98c			if DEBUG_FORTH_WORDS 
b98c				DMARK "A?2" 
b98c f5				push af  
b98d 3a a1 b9			ld a, (.dmark)  
b990 32 6b ee			ld (debug_mark),a  
b993 3a a2 b9			ld a, (.dmark+1)  
b996 32 6c ee			ld (debug_mark+1),a  
b999 3a a3 b9			ld a, (.dmark+2)  
b99c 32 6d ee			ld (debug_mark+2),a  
b99f 18 03			jr .pastdmark  
b9a1 ..			.dmark: db "A?2"  
b9a4 f1			.pastdmark: pop af  
b9a5			endm  
# End of macro DMARK
b9a5				CALLMONITOR 
b9a5 cd 6f ee			call debug_vector  
b9a8				endm  
# End of macro CALLMONITOR
b9a8			endif	 
b9a8 26 00				ld h, 0 
b9aa 69					ld l, c 
b9ab cd 6e 9a				call forth_push_numhl 
b9ae 68					ld l, b  
b9af cd 6e 9a				call forth_push_numhl 
b9b2			 
b9b2			 
b9b2				NEXTW 
b9b2 c3 29 9e			jp macro_next 
b9b5				endm 
# End of macro NEXTW
b9b5			 
b9b5			.FB: 
b9b5				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b9b5 1b				db WORD_SYS_CORE+7             
b9b6 03 ba			dw .EMIT            
b9b8 03				db 2 + 1 
b9b9 .. 00			db "FB",0              
b9bc				endm 
# End of macro CWHEAD
b9bc			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b9bc			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b9bc			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b9bc			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b9bc					if DEBUG_FORTH_WORDS_KEY 
b9bc						DMARK "FB." 
b9bc f5				push af  
b9bd 3a d1 b9			ld a, (.dmark)  
b9c0 32 6b ee			ld (debug_mark),a  
b9c3 3a d2 b9			ld a, (.dmark+1)  
b9c6 32 6c ee			ld (debug_mark+1),a  
b9c9 3a d3 b9			ld a, (.dmark+2)  
b9cc 32 6d ee			ld (debug_mark+2),a  
b9cf 18 03			jr .pastdmark  
b9d1 ..			.dmark: db "FB."  
b9d4 f1			.pastdmark: pop af  
b9d5			endm  
# End of macro DMARK
b9d5						CALLMONITOR 
b9d5 cd 6f ee			call debug_vector  
b9d8				endm  
# End of macro CALLMONITOR
b9d8					endif 
b9d8			 
b9d8					FORTH_DSP_VALUEHL 
b9d8 cd 73 9c			call macro_dsp_valuehl 
b9db				endm 
# End of macro FORTH_DSP_VALUEHL
b9db			 
b9db 7d					ld a, l 
b9dc fe 01				cp 1 
b9de 20 05				jr nz, .fbn1 
b9e0 21 10 ed				ld hl, display_fb1 
b9e3 18 15				jr .fbset 
b9e5 fe 02		.fbn1:		cp 2 
b9e7 20 05				jr nz, .fbn2 
b9e9 21 ce eb				ld hl, display_fb2 
b9ec 18 0c				jr .fbset 
b9ee fe 03		.fbn2:		cp 3 
b9f0 20 05				jr nz, .fbn3 
b9f2 21 6f ec				ld hl, display_fb3 
b9f5 18 03				jr .fbset 
b9f7			.fbn3:		 ; if invalid number select first 
b9f7 21 10 ed				ld hl, display_fb1 
b9fa 22 cc eb		.fbset:		ld (display_fb_active), hl 
b9fd			 
b9fd					FORTH_DSP_POP 
b9fd cd 2b 9d			call macro_forth_dsp_pop 
ba00				endm 
# End of macro FORTH_DSP_POP
ba00			 
ba00					NEXTW 
ba00 c3 29 9e			jp macro_next 
ba03				endm 
# End of macro NEXTW
ba03			 
ba03			 
ba03			.EMIT: 
ba03				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba03 1b				db WORD_SYS_CORE+7             
ba04 54 ba			dw .DOTH            
ba06 05				db 4 + 1 
ba07 .. 00			db "EMIT",0              
ba0c				endm 
# End of macro CWHEAD
ba0c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba0c					; get value off TOS and display it 
ba0c			 
ba0c					if DEBUG_FORTH_WORDS_KEY 
ba0c						DMARK "EMT" 
ba0c f5				push af  
ba0d 3a 21 ba			ld a, (.dmark)  
ba10 32 6b ee			ld (debug_mark),a  
ba13 3a 22 ba			ld a, (.dmark+1)  
ba16 32 6c ee			ld (debug_mark+1),a  
ba19 3a 23 ba			ld a, (.dmark+2)  
ba1c 32 6d ee			ld (debug_mark+2),a  
ba1f 18 03			jr .pastdmark  
ba21 ..			.dmark: db "EMT"  
ba24 f1			.pastdmark: pop af  
ba25			endm  
# End of macro DMARK
ba25						CALLMONITOR 
ba25 cd 6f ee			call debug_vector  
ba28				endm  
# End of macro CALLMONITOR
ba28					endif 
ba28			 
ba28					FORTH_DSP_VALUEHL 
ba28 cd 73 9c			call macro_dsp_valuehl 
ba2b				endm 
# End of macro FORTH_DSP_VALUEHL
ba2b			 
ba2b 7d					ld a,l 
ba2c			 
ba2c					; TODO write to display 
ba2c			 
ba2c 32 bf e4				ld (os_input), a 
ba2f 3e 00				ld a, 0 
ba31 32 c0 e4				ld (os_input+1), a 
ba34					 
ba34 3a 5e ea				ld a, (f_cursor_ptr) 
ba37 11 bf e4				ld de, os_input 
ba3a cd cd 8a				call str_at_display 
ba3d			 
ba3d			 
ba3d 3a 3c ea				ld a,(cli_autodisplay) 
ba40 fe 00				cp 0 
ba42 28 03				jr z, .enoupdate 
ba44 cd dd 8a						call update_display 
ba47					.enoupdate: 
ba47			 
ba47 3a 5e ea				ld a, (f_cursor_ptr) 
ba4a 3c					inc a 
ba4b 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
ba4e			 
ba4e			 
ba4e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba4e cd 2b 9d			call macro_forth_dsp_pop 
ba51				endm 
# End of macro FORTH_DSP_POP
ba51			  
ba51			 
ba51					NEXTW 
ba51 c3 29 9e			jp macro_next 
ba54				endm 
# End of macro NEXTW
ba54			.DOTH: 
ba54				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba54 1c				db WORD_SYS_CORE+8             
ba55 84 ba			dw .DOTF            
ba57 03				db 2 + 1 
ba58 .. 00			db ".-",0              
ba5b				endm 
# End of macro CWHEAD
ba5b			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba5b					; get value off TOS and display it 
ba5b					if DEBUG_FORTH_WORDS_KEY 
ba5b						DMARK "DTD" 
ba5b f5				push af  
ba5c 3a 70 ba			ld a, (.dmark)  
ba5f 32 6b ee			ld (debug_mark),a  
ba62 3a 71 ba			ld a, (.dmark+1)  
ba65 32 6c ee			ld (debug_mark+1),a  
ba68 3a 72 ba			ld a, (.dmark+2)  
ba6b 32 6d ee			ld (debug_mark+2),a  
ba6e 18 03			jr .pastdmark  
ba70 ..			.dmark: db "DTD"  
ba73 f1			.pastdmark: pop af  
ba74			endm  
# End of macro DMARK
ba74						CALLMONITOR 
ba74 cd 6f ee			call debug_vector  
ba77				endm  
# End of macro CALLMONITOR
ba77					endif 
ba77 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba79 3e 00			ld a, 0 
ba7b 32 3d ea			ld (cli_mvdot), a 
ba7e c3 db ba			jp .dotgo 
ba81				NEXTW 
ba81 c3 29 9e			jp macro_next 
ba84				endm 
# End of macro NEXTW
ba84			.DOTF: 
ba84				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba84 1c				db WORD_SYS_CORE+8             
ba85 b2 ba			dw .DOT            
ba87 03				db 2 + 1 
ba88 .. 00			db ".>",0              
ba8b				endm 
# End of macro CWHEAD
ba8b			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
ba8b					; get value off TOS and display it 
ba8b			        ; TODO BUG adds extra spaces 
ba8b			        ; TODO BUG handle numerics? 
ba8b					if DEBUG_FORTH_WORDS_KEY 
ba8b						DMARK "DTC" 
ba8b f5				push af  
ba8c 3a a0 ba			ld a, (.dmark)  
ba8f 32 6b ee			ld (debug_mark),a  
ba92 3a a1 ba			ld a, (.dmark+1)  
ba95 32 6c ee			ld (debug_mark+1),a  
ba98 3a a2 ba			ld a, (.dmark+2)  
ba9b 32 6d ee			ld (debug_mark+2),a  
ba9e 18 03			jr .pastdmark  
baa0 ..			.dmark: db "DTC"  
baa3 f1			.pastdmark: pop af  
baa4			endm  
# End of macro DMARK
baa4						CALLMONITOR 
baa4 cd 6f ee			call debug_vector  
baa7				endm  
# End of macro CALLMONITOR
baa7					endif 
baa7 3e 01			ld a, 1 
baa9 32 3d ea			ld (cli_mvdot), a 
baac c3 db ba			jp .dotgo 
baaf				NEXTW 
baaf c3 29 9e			jp macro_next 
bab2				endm 
# End of macro NEXTW
bab2			 
bab2			.DOT: 
bab2				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bab2 1c				db WORD_SYS_CORE+8             
bab3 8e bc			dw .CLS            
bab5 02				db 1 + 1 
bab6 .. 00			db ".",0              
bab8				endm 
# End of macro CWHEAD
bab8			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
bab8					; get value off TOS and display it 
bab8			 
bab8					if DEBUG_FORTH_WORDS_KEY 
bab8						DMARK "DOT" 
bab8 f5				push af  
bab9 3a cd ba			ld a, (.dmark)  
babc 32 6b ee			ld (debug_mark),a  
babf 3a ce ba			ld a, (.dmark+1)  
bac2 32 6c ee			ld (debug_mark+1),a  
bac5 3a cf ba			ld a, (.dmark+2)  
bac8 32 6d ee			ld (debug_mark+2),a  
bacb 18 03			jr .pastdmark  
bacd ..			.dmark: db "DOT"  
bad0 f1			.pastdmark: pop af  
bad1			endm  
# End of macro DMARK
bad1						CALLMONITOR 
bad1 cd 6f ee			call debug_vector  
bad4				endm  
# End of macro CALLMONITOR
bad4					endif 
bad4 3e 00			ld a, 0 
bad6 32 3d ea			ld (cli_mvdot), a 
bad9 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
badb				 
badb			 
badb			.dotgo: 
badb			 
badb			; move up type to on stack for parserv5 
badb					FORTH_DSP 
badb cd 39 9c			call macro_forth_dsp 
bade				endm 
# End of macro FORTH_DSP
bade				;FORTH_DSP_VALUE  
bade			 
bade			if DEBUG_FORTH_DOT 
bade				DMARK "DOT" 
bade f5				push af  
badf 3a f3 ba			ld a, (.dmark)  
bae2 32 6b ee			ld (debug_mark),a  
bae5 3a f4 ba			ld a, (.dmark+1)  
bae8 32 6c ee			ld (debug_mark+1),a  
baeb 3a f5 ba			ld a, (.dmark+2)  
baee 32 6d ee			ld (debug_mark+2),a  
baf1 18 03			jr .pastdmark  
baf3 ..			.dmark: db "DOT"  
baf6 f1			.pastdmark: pop af  
baf7			endm  
# End of macro DMARK
baf7				CALLMONITOR 
baf7 cd 6f ee			call debug_vector  
bafa				endm  
# End of macro CALLMONITOR
bafa			endif	 
bafa			;		.print: 
bafa			 
bafa 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bafb 23				inc hl   ; position to the actual value 
bafc fe 01			cp DS_TYPE_STR 
bafe 20 06			jr nz, .dotnum1  
bb00			 
bb00			; display string 
bb00				FORTH_DSP_VALUE  
bb00 cd 5c 9c			call macro_forth_dsp_value 
bb03				endm 
# End of macro FORTH_DSP_VALUE
bb03 eb				ex de,hl 
bb04 18 49			jr .dotwrite 
bb06			 
bb06			.dotnum1: 
bb06 fe 02			cp DS_TYPE_INUM 
bb08 20 44			jr nz, .dotflot 
bb0a			 
bb0a			 
bb0a			; display number 
bb0a			 
bb0a			;	push hl 
bb0a			;	call clear_display 
bb0a			;	pop hl 
bb0a			 
bb0a 5e				ld e, (hl) 
bb0b 23				inc hl 
bb0c 56				ld d, (hl) 
bb0d 21 c1 e2			ld hl, scratch 
bb10			if DEBUG_FORTH_DOT 
bb10				DMARK "DT1" 
bb10 f5				push af  
bb11 3a 25 bb			ld a, (.dmark)  
bb14 32 6b ee			ld (debug_mark),a  
bb17 3a 26 bb			ld a, (.dmark+1)  
bb1a 32 6c ee			ld (debug_mark+1),a  
bb1d 3a 27 bb			ld a, (.dmark+2)  
bb20 32 6d ee			ld (debug_mark+2),a  
bb23 18 03			jr .pastdmark  
bb25 ..			.dmark: db "DT1"  
bb28 f1			.pastdmark: pop af  
bb29			endm  
# End of macro DMARK
bb29				CALLMONITOR 
bb29 cd 6f ee			call debug_vector  
bb2c				endm  
# End of macro CALLMONITOR
bb2c			endif	 
bb2c			 
bb2c cd fc 8f			call uitoa_16 
bb2f eb				ex de,hl 
bb30			 
bb30			if DEBUG_FORTH_DOT 
bb30				DMARK "DT2" 
bb30 f5				push af  
bb31 3a 45 bb			ld a, (.dmark)  
bb34 32 6b ee			ld (debug_mark),a  
bb37 3a 46 bb			ld a, (.dmark+1)  
bb3a 32 6c ee			ld (debug_mark+1),a  
bb3d 3a 47 bb			ld a, (.dmark+2)  
bb40 32 6d ee			ld (debug_mark+2),a  
bb43 18 03			jr .pastdmark  
bb45 ..			.dmark: db "DT2"  
bb48 f1			.pastdmark: pop af  
bb49			endm  
# End of macro DMARK
bb49				CALLMONITOR 
bb49 cd 6f ee			call debug_vector  
bb4c				endm  
# End of macro CALLMONITOR
bb4c			endif	 
bb4c			 
bb4c			;	ld de, os_word_scratch 
bb4c 18 01			jr .dotwrite 
bb4e			 
bb4e 00			.dotflot:   nop 
bb4f			; TODO print floating point number 
bb4f			 
bb4f			.dotwrite:		 
bb4f			 
bb4f					; if c is set then set all '-' to spaces 
bb4f					; need to also take into account .>  
bb4f			 
bb4f 3e 01				ld a, 1 
bb51 b9					cp c 
bb52 20 67				jr nz, .nodashswap 
bb54			 
bb54					; DE has the string to write, working with HL 
bb54			 
bb54 06 ff				ld b, 255 
bb56 d5					push de 
bb57 e1					pop hl 
bb58			 
bb58			if DEBUG_FORTH_DOT 
bb58				DMARK "DT-" 
bb58 f5				push af  
bb59 3a 6d bb			ld a, (.dmark)  
bb5c 32 6b ee			ld (debug_mark),a  
bb5f 3a 6e bb			ld a, (.dmark+1)  
bb62 32 6c ee			ld (debug_mark+1),a  
bb65 3a 6f bb			ld a, (.dmark+2)  
bb68 32 6d ee			ld (debug_mark+2),a  
bb6b 18 03			jr .pastdmark  
bb6d ..			.dmark: db "DT-"  
bb70 f1			.pastdmark: pop af  
bb71			endm  
# End of macro DMARK
bb71				CALLMONITOR 
bb71 cd 6f ee			call debug_vector  
bb74				endm  
# End of macro CALLMONITOR
bb74			endif	 
bb74 7e			.dashscan:	ld a, (hl) 
bb75 fe 00				cp 0 
bb77 28 42				jr z, .nodashswap 
bb79 fe 2d				cp '-' 
bb7b 20 03				jr nz, .dashskip 
bb7d 3e 20				ld a, ' ' 
bb7f 77					ld (hl), a 
bb80 23			.dashskip:	inc hl 
bb81			if DEBUG_FORTH_DOT 
bb81				DMARK "D-2" 
bb81 f5				push af  
bb82 3a 96 bb			ld a, (.dmark)  
bb85 32 6b ee			ld (debug_mark),a  
bb88 3a 97 bb			ld a, (.dmark+1)  
bb8b 32 6c ee			ld (debug_mark+1),a  
bb8e 3a 98 bb			ld a, (.dmark+2)  
bb91 32 6d ee			ld (debug_mark+2),a  
bb94 18 03			jr .pastdmark  
bb96 ..			.dmark: db "D-2"  
bb99 f1			.pastdmark: pop af  
bb9a			endm  
# End of macro DMARK
bb9a				CALLMONITOR 
bb9a cd 6f ee			call debug_vector  
bb9d				endm  
# End of macro CALLMONITOR
bb9d			endif	 
bb9d 10 d5				djnz .dashscan 
bb9f			 
bb9f			if DEBUG_FORTH_DOT 
bb9f				DMARK "D-1" 
bb9f f5				push af  
bba0 3a b4 bb			ld a, (.dmark)  
bba3 32 6b ee			ld (debug_mark),a  
bba6 3a b5 bb			ld a, (.dmark+1)  
bba9 32 6c ee			ld (debug_mark+1),a  
bbac 3a b6 bb			ld a, (.dmark+2)  
bbaf 32 6d ee			ld (debug_mark+2),a  
bbb2 18 03			jr .pastdmark  
bbb4 ..			.dmark: db "D-1"  
bbb7 f1			.pastdmark: pop af  
bbb8			endm  
# End of macro DMARK
bbb8				CALLMONITOR 
bbb8 cd 6f ee			call debug_vector  
bbbb				endm  
# End of macro CALLMONITOR
bbbb			endif	 
bbbb			 
bbbb			.nodashswap: 
bbbb			 
bbbb			if DEBUG_FORTH_DOT 
bbbb				DMARK "D-o" 
bbbb f5				push af  
bbbc 3a d0 bb			ld a, (.dmark)  
bbbf 32 6b ee			ld (debug_mark),a  
bbc2 3a d1 bb			ld a, (.dmark+1)  
bbc5 32 6c ee			ld (debug_mark+1),a  
bbc8 3a d2 bb			ld a, (.dmark+2)  
bbcb 32 6d ee			ld (debug_mark+2),a  
bbce 18 03			jr .pastdmark  
bbd0 ..			.dmark: db "D-o"  
bbd3 f1			.pastdmark: pop af  
bbd4			endm  
# End of macro DMARK
bbd4				CALLMONITOR 
bbd4 cd 6f ee			call debug_vector  
bbd7				endm  
# End of macro CALLMONITOR
bbd7			endif	 
bbd7			 
bbd7 d5					push de   ; save string start in case we need to advance print 
bbd8			 
bbd8 3a 5e ea				ld a, (f_cursor_ptr) 
bbdb cd cd 8a				call str_at_display 
bbde 3a 3c ea				ld a,(cli_autodisplay) 
bbe1 fe 00				cp 0 
bbe3 28 03				jr z, .noupdate 
bbe5 cd dd 8a						call update_display 
bbe8					.noupdate: 
bbe8			 
bbe8			 
bbe8					; see if we need to advance the print position 
bbe8			 
bbe8 e1					pop hl   ; get back string 
bbe9			;		ex de,hl 
bbe9			 
bbe9 3a 3d ea				ld a, (cli_mvdot) 
bbec			if DEBUG_FORTH_DOT 
bbec			;		ld e,a 
bbec				DMARK "D>1" 
bbec f5				push af  
bbed 3a 01 bc			ld a, (.dmark)  
bbf0 32 6b ee			ld (debug_mark),a  
bbf3 3a 02 bc			ld a, (.dmark+1)  
bbf6 32 6c ee			ld (debug_mark+1),a  
bbf9 3a 03 bc			ld a, (.dmark+2)  
bbfc 32 6d ee			ld (debug_mark+2),a  
bbff 18 03			jr .pastdmark  
bc01 ..			.dmark: db "D>1"  
bc04 f1			.pastdmark: pop af  
bc05			endm  
# End of macro DMARK
bc05				CALLMONITOR 
bc05 cd 6f ee			call debug_vector  
bc08				endm  
# End of macro CALLMONITOR
bc08			endif	 
bc08 fe 00				cp 0 
bc0a 28 44				jr z, .noadv 
bc0c					; yes, lets advance the print position 
bc0c 3e 00				ld a, 0 
bc0e cd 58 90				call strlent 
bc11			if DEBUG_FORTH_DOT 
bc11				DMARK "D-?" 
bc11 f5				push af  
bc12 3a 26 bc			ld a, (.dmark)  
bc15 32 6b ee			ld (debug_mark),a  
bc18 3a 27 bc			ld a, (.dmark+1)  
bc1b 32 6c ee			ld (debug_mark+1),a  
bc1e 3a 28 bc			ld a, (.dmark+2)  
bc21 32 6d ee			ld (debug_mark+2),a  
bc24 18 03			jr .pastdmark  
bc26 ..			.dmark: db "D-?"  
bc29 f1			.pastdmark: pop af  
bc2a			endm  
# End of macro DMARK
bc2a				CALLMONITOR 
bc2a cd 6f ee			call debug_vector  
bc2d				endm  
# End of macro CALLMONITOR
bc2d			endif	 
bc2d 3a 5e ea				ld a, (f_cursor_ptr) 
bc30 85					add a,l 
bc31					;call addatohl 
bc31					;ld a, l 
bc31 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bc34			 
bc34			if DEBUG_FORTH_DOT 
bc34				DMARK "D->" 
bc34 f5				push af  
bc35 3a 49 bc			ld a, (.dmark)  
bc38 32 6b ee			ld (debug_mark),a  
bc3b 3a 4a bc			ld a, (.dmark+1)  
bc3e 32 6c ee			ld (debug_mark+1),a  
bc41 3a 4b bc			ld a, (.dmark+2)  
bc44 32 6d ee			ld (debug_mark+2),a  
bc47 18 03			jr .pastdmark  
bc49 ..			.dmark: db "D->"  
bc4c f1			.pastdmark: pop af  
bc4d			endm  
# End of macro DMARK
bc4d				CALLMONITOR 
bc4d cd 6f ee			call debug_vector  
bc50				endm  
# End of macro CALLMONITOR
bc50			endif	 
bc50			 
bc50			.noadv:	 
bc50			 
bc50					if DEBUG_FORTH_DOT_WAIT 
bc50							call next_page_prompt 
bc50					endif	 
bc50			; TODO this pop off the stack causes a crash. i dont know why 
bc50			 
bc50			 
bc50			if DEBUG_FORTH_DOT 
bc50				DMARK "DTh" 
bc50 f5				push af  
bc51 3a 65 bc			ld a, (.dmark)  
bc54 32 6b ee			ld (debug_mark),a  
bc57 3a 66 bc			ld a, (.dmark+1)  
bc5a 32 6c ee			ld (debug_mark+1),a  
bc5d 3a 67 bc			ld a, (.dmark+2)  
bc60 32 6d ee			ld (debug_mark+2),a  
bc63 18 03			jr .pastdmark  
bc65 ..			.dmark: db "DTh"  
bc68 f1			.pastdmark: pop af  
bc69			endm  
# End of macro DMARK
bc69				CALLMONITOR 
bc69 cd 6f ee			call debug_vector  
bc6c				endm  
# End of macro CALLMONITOR
bc6c			endif	 
bc6c			 
bc6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc6c cd 2b 9d			call macro_forth_dsp_pop 
bc6f				endm 
# End of macro FORTH_DSP_POP
bc6f			 
bc6f			if DEBUG_FORTH_DOT 
bc6f				DMARK "DTi" 
bc6f f5				push af  
bc70 3a 84 bc			ld a, (.dmark)  
bc73 32 6b ee			ld (debug_mark),a  
bc76 3a 85 bc			ld a, (.dmark+1)  
bc79 32 6c ee			ld (debug_mark+1),a  
bc7c 3a 86 bc			ld a, (.dmark+2)  
bc7f 32 6d ee			ld (debug_mark+2),a  
bc82 18 03			jr .pastdmark  
bc84 ..			.dmark: db "DTi"  
bc87 f1			.pastdmark: pop af  
bc88			endm  
# End of macro DMARK
bc88				CALLMONITOR 
bc88 cd 6f ee			call debug_vector  
bc8b				endm  
# End of macro CALLMONITOR
bc8b			endif	 
bc8b			 
bc8b			 
bc8b					NEXTW 
bc8b c3 29 9e			jp macro_next 
bc8e				endm 
# End of macro NEXTW
bc8e			 
bc8e			.CLS: 
bc8e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bc8e 35				db WORD_SYS_CORE+33             
bc8f bb bc			dw .DRAW            
bc91 04				db 3 + 1 
bc92 .. 00			db "CLS",0              
bc96				endm 
# End of macro CWHEAD
bc96			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bc96					if DEBUG_FORTH_WORDS_KEY 
bc96						DMARK "CLS" 
bc96 f5				push af  
bc97 3a ab bc			ld a, (.dmark)  
bc9a 32 6b ee			ld (debug_mark),a  
bc9d 3a ac bc			ld a, (.dmark+1)  
bca0 32 6c ee			ld (debug_mark+1),a  
bca3 3a ad bc			ld a, (.dmark+2)  
bca6 32 6d ee			ld (debug_mark+2),a  
bca9 18 03			jr .pastdmark  
bcab ..			.dmark: db "CLS"  
bcae f1			.pastdmark: pop af  
bcaf			endm  
# End of macro DMARK
bcaf						CALLMONITOR 
bcaf cd 6f ee			call debug_vector  
bcb2				endm  
# End of macro CALLMONITOR
bcb2					endif 
bcb2 cd ba 8a				call clear_display 
bcb5 c3 c9 bd				jp .home		; and home cursor 
bcb8					NEXTW 
bcb8 c3 29 9e			jp macro_next 
bcbb				endm 
# End of macro NEXTW
bcbb			 
bcbb			.DRAW: 
bcbb				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bcbb 36				db WORD_SYS_CORE+34             
bcbc e6 bc			dw .DUMP            
bcbe 05				db 4 + 1 
bcbf .. 00			db "DRAW",0              
bcc4				endm 
# End of macro CWHEAD
bcc4			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bcc4					if DEBUG_FORTH_WORDS_KEY 
bcc4						DMARK "DRW" 
bcc4 f5				push af  
bcc5 3a d9 bc			ld a, (.dmark)  
bcc8 32 6b ee			ld (debug_mark),a  
bccb 3a da bc			ld a, (.dmark+1)  
bcce 32 6c ee			ld (debug_mark+1),a  
bcd1 3a db bc			ld a, (.dmark+2)  
bcd4 32 6d ee			ld (debug_mark+2),a  
bcd7 18 03			jr .pastdmark  
bcd9 ..			.dmark: db "DRW"  
bcdc f1			.pastdmark: pop af  
bcdd			endm  
# End of macro DMARK
bcdd						CALLMONITOR 
bcdd cd 6f ee			call debug_vector  
bce0				endm  
# End of macro CALLMONITOR
bce0					endif 
bce0 cd dd 8a				call update_display 
bce3					NEXTW 
bce3 c3 29 9e			jp macro_next 
bce6				endm 
# End of macro NEXTW
bce6			 
bce6			.DUMP: 
bce6				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bce6 37				db WORD_SYS_CORE+35             
bce7 1e bd			dw .CDUMP            
bce9 05				db 4 + 1 
bcea .. 00			db "DUMP",0              
bcef				endm 
# End of macro CWHEAD
bcef			; | DUMP ( x -- ) With address x display dump   | DONE 
bcef			; TODO pop address to use off of the stack 
bcef					if DEBUG_FORTH_WORDS_KEY 
bcef						DMARK "DUM" 
bcef f5				push af  
bcf0 3a 04 bd			ld a, (.dmark)  
bcf3 32 6b ee			ld (debug_mark),a  
bcf6 3a 05 bd			ld a, (.dmark+1)  
bcf9 32 6c ee			ld (debug_mark+1),a  
bcfc 3a 06 bd			ld a, (.dmark+2)  
bcff 32 6d ee			ld (debug_mark+2),a  
bd02 18 03			jr .pastdmark  
bd04 ..			.dmark: db "DUM"  
bd07 f1			.pastdmark: pop af  
bd08			endm  
# End of macro DMARK
bd08						CALLMONITOR 
bd08 cd 6f ee			call debug_vector  
bd0b				endm  
# End of macro CALLMONITOR
bd0b					endif 
bd0b cd ba 8a				call clear_display 
bd0e			 
bd0e					; get address 
bd0e			 
bd0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd0e cd 73 9c			call macro_dsp_valuehl 
bd11				endm 
# End of macro FORTH_DSP_VALUEHL
bd11				 
bd11					; save it for cdump 
bd11			 
bd11 22 e4 e5				ld (os_cur_ptr),hl 
bd14			 
bd14					; destroy value TOS 
bd14			 
bd14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd14 cd 2b 9d			call macro_forth_dsp_pop 
bd17				endm 
# End of macro FORTH_DSP_POP
bd17			 
bd17 cd ee 98				call dumpcont	; skip old style of param parsing	 
bd1a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd1b					NEXTW 
bd1b c3 29 9e			jp macro_next 
bd1e				endm 
# End of macro NEXTW
bd1e			.CDUMP: 
bd1e				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd1e 38				db WORD_SYS_CORE+36             
bd1f 4e bd			dw .DAT            
bd21 06				db 5 + 1 
bd22 .. 00			db "CDUMP",0              
bd28				endm 
# End of macro CWHEAD
bd28			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd28					if DEBUG_FORTH_WORDS_KEY 
bd28						DMARK "CDP" 
bd28 f5				push af  
bd29 3a 3d bd			ld a, (.dmark)  
bd2c 32 6b ee			ld (debug_mark),a  
bd2f 3a 3e bd			ld a, (.dmark+1)  
bd32 32 6c ee			ld (debug_mark+1),a  
bd35 3a 3f bd			ld a, (.dmark+2)  
bd38 32 6d ee			ld (debug_mark+2),a  
bd3b 18 03			jr .pastdmark  
bd3d ..			.dmark: db "CDP"  
bd40 f1			.pastdmark: pop af  
bd41			endm  
# End of macro DMARK
bd41						CALLMONITOR 
bd41 cd 6f ee			call debug_vector  
bd44				endm  
# End of macro CALLMONITOR
bd44					endif 
bd44 cd ba 8a				call clear_display 
bd47 cd ee 98				call dumpcont	 
bd4a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd4b					NEXTW 
bd4b c3 29 9e			jp macro_next 
bd4e				endm 
# End of macro NEXTW
bd4e			 
bd4e			 
bd4e			 
bd4e			 
bd4e			.DAT: 
bd4e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd4e 3d				db WORD_SYS_CORE+41             
bd4f a4 bd			dw .HOME            
bd51 03				db 2 + 1 
bd52 .. 00			db "AT",0              
bd55				endm 
# End of macro CWHEAD
bd55			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd55					if DEBUG_FORTH_WORDS_KEY 
bd55						DMARK "AT." 
bd55 f5				push af  
bd56 3a 6a bd			ld a, (.dmark)  
bd59 32 6b ee			ld (debug_mark),a  
bd5c 3a 6b bd			ld a, (.dmark+1)  
bd5f 32 6c ee			ld (debug_mark+1),a  
bd62 3a 6c bd			ld a, (.dmark+2)  
bd65 32 6d ee			ld (debug_mark+2),a  
bd68 18 03			jr .pastdmark  
bd6a ..			.dmark: db "AT."  
bd6d f1			.pastdmark: pop af  
bd6e			endm  
# End of macro DMARK
bd6e						CALLMONITOR 
bd6e cd 6f ee			call debug_vector  
bd71				endm  
# End of macro CALLMONITOR
bd71					endif 
bd71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd71 cd 73 9c			call macro_dsp_valuehl 
bd74				endm 
# End of macro FORTH_DSP_VALUEHL
bd74			 
bd74			 
bd74					; TODO save cursor row 
bd74 7d					ld a,l 
bd75 fe 02				cp 2 
bd77 20 04				jr nz, .crow3 
bd79 3e 28				ld a, display_row_2 
bd7b 18 12				jr .ccol1 
bd7d fe 03		.crow3:		cp 3 
bd7f 20 04				jr nz, .crow4 
bd81 3e 50				ld a, display_row_3 
bd83 18 0a				jr .ccol1 
bd85 fe 04		.crow4:		cp 4 
bd87 20 04				jr nz, .crow1 
bd89 3e 78				ld a, display_row_4 
bd8b 18 02				jr .ccol1 
bd8d 3e 00		.crow1:		ld a,display_row_1 
bd8f f5			.ccol1:		push af			; got row offset 
bd90 6f					ld l,a 
bd91 26 00				ld h,0 
bd93					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd93 cd 2b 9d			call macro_forth_dsp_pop 
bd96				endm 
# End of macro FORTH_DSP_POP
bd96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd96 cd 73 9c			call macro_dsp_valuehl 
bd99				endm 
# End of macro FORTH_DSP_VALUEHL
bd99					; TODO save cursor col 
bd99 f1					pop af 
bd9a 85					add l		; add col offset 
bd9b 32 5e ea				ld (f_cursor_ptr), a 
bd9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd9e cd 2b 9d			call macro_forth_dsp_pop 
bda1				endm 
# End of macro FORTH_DSP_POP
bda1			 
bda1					; calculate  
bda1			 
bda1					NEXTW 
bda1 c3 29 9e			jp macro_next 
bda4				endm 
# End of macro NEXTW
bda4			 
bda4			 
bda4			.HOME: 
bda4				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
bda4 41				db WORD_SYS_CORE+45             
bda5 d1 bd			dw .CR            
bda7 05				db 4 + 1 
bda8 .. 00			db "HOME",0              
bdad				endm 
# End of macro CWHEAD
bdad			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bdad					if DEBUG_FORTH_WORDS_KEY 
bdad						DMARK "HOM" 
bdad f5				push af  
bdae 3a c2 bd			ld a, (.dmark)  
bdb1 32 6b ee			ld (debug_mark),a  
bdb4 3a c3 bd			ld a, (.dmark+1)  
bdb7 32 6c ee			ld (debug_mark+1),a  
bdba 3a c4 bd			ld a, (.dmark+2)  
bdbd 32 6d ee			ld (debug_mark+2),a  
bdc0 18 03			jr .pastdmark  
bdc2 ..			.dmark: db "HOM"  
bdc5 f1			.pastdmark: pop af  
bdc6			endm  
# End of macro DMARK
bdc6						CALLMONITOR 
bdc6 cd 6f ee			call debug_vector  
bdc9				endm  
# End of macro CALLMONITOR
bdc9					endif 
bdc9 3e 00		.home:		ld a, 0		; and home cursor 
bdcb 32 5e ea				ld (f_cursor_ptr), a 
bdce					NEXTW 
bdce c3 29 9e			jp macro_next 
bdd1				endm 
# End of macro NEXTW
bdd1			 
bdd1			 
bdd1			.CR: 
bdd1				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
bdd1 46				db WORD_SYS_CORE+50             
bdd2 0c be			dw .SPACE            
bdd4 03				db 2 + 1 
bdd5 .. 00			db "CR",0              
bdd8				endm 
# End of macro CWHEAD
bdd8			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
bdd8					if DEBUG_FORTH_WORDS_KEY 
bdd8						DMARK "CR." 
bdd8 f5				push af  
bdd9 3a ed bd			ld a, (.dmark)  
bddc 32 6b ee			ld (debug_mark),a  
bddf 3a ee bd			ld a, (.dmark+1)  
bde2 32 6c ee			ld (debug_mark+1),a  
bde5 3a ef bd			ld a, (.dmark+2)  
bde8 32 6d ee			ld (debug_mark+2),a  
bdeb 18 03			jr .pastdmark  
bded ..			.dmark: db "CR."  
bdf0 f1			.pastdmark: pop af  
bdf1			endm  
# End of macro DMARK
bdf1						CALLMONITOR 
bdf1 cd 6f ee			call debug_vector  
bdf4				endm  
# End of macro CALLMONITOR
bdf4					endif 
bdf4 3e 0d				ld a, 13 
bdf6 32 c1 e2				ld (scratch),a 
bdf9 3e 0a				ld a, 10 
bdfb 32 c2 e2				ld (scratch+1),a 
bdfe 3e 00				ld a, 0 
be00 32 c3 e2				ld (scratch+2),a 
be03 21 c1 e2				ld hl, scratch 
be06 cd dc 9a				call forth_push_str 
be09					 
be09				       NEXTW 
be09 c3 29 9e			jp macro_next 
be0c				endm 
# End of macro NEXTW
be0c			.SPACE: 
be0c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be0c 46				db WORD_SYS_CORE+50             
be0d 42 be			dw .SPACES            
be0f 03				db 2 + 1 
be10 .. 00			db "BL",0              
be13				endm 
# End of macro CWHEAD
be13			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be13					if DEBUG_FORTH_WORDS_KEY 
be13						DMARK "BL." 
be13 f5				push af  
be14 3a 28 be			ld a, (.dmark)  
be17 32 6b ee			ld (debug_mark),a  
be1a 3a 29 be			ld a, (.dmark+1)  
be1d 32 6c ee			ld (debug_mark+1),a  
be20 3a 2a be			ld a, (.dmark+2)  
be23 32 6d ee			ld (debug_mark+2),a  
be26 18 03			jr .pastdmark  
be28 ..			.dmark: db "BL."  
be2b f1			.pastdmark: pop af  
be2c			endm  
# End of macro DMARK
be2c						CALLMONITOR 
be2c cd 6f ee			call debug_vector  
be2f				endm  
# End of macro CALLMONITOR
be2f					endif 
be2f 3e 20				ld a, " " 
be31 32 c1 e2				ld (scratch),a 
be34 3e 00				ld a, 0 
be36 32 c2 e2				ld (scratch+1),a 
be39 21 c1 e2				ld hl, scratch 
be3c cd dc 9a				call forth_push_str 
be3f					 
be3f				       NEXTW 
be3f c3 29 9e			jp macro_next 
be42				endm 
# End of macro NEXTW
be42			 
be42			;.blstr: db " ", 0 
be42			 
be42			.SPACES: 
be42				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be42 47				db WORD_SYS_CORE+51             
be43 dd be			dw .SCROLL            
be45 07				db 6 + 1 
be46 .. 00			db "SPACES",0              
be4d				endm 
# End of macro CWHEAD
be4d			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be4d					if DEBUG_FORTH_WORDS_KEY 
be4d						DMARK "SPS" 
be4d f5				push af  
be4e 3a 62 be			ld a, (.dmark)  
be51 32 6b ee			ld (debug_mark),a  
be54 3a 63 be			ld a, (.dmark+1)  
be57 32 6c ee			ld (debug_mark+1),a  
be5a 3a 64 be			ld a, (.dmark+2)  
be5d 32 6d ee			ld (debug_mark+2),a  
be60 18 03			jr .pastdmark  
be62 ..			.dmark: db "SPS"  
be65 f1			.pastdmark: pop af  
be66			endm  
# End of macro DMARK
be66						CALLMONITOR 
be66 cd 6f ee			call debug_vector  
be69				endm  
# End of macro CALLMONITOR
be69					endif 
be69			 
be69			 
be69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be69 cd 73 9c			call macro_dsp_valuehl 
be6c				endm 
# End of macro FORTH_DSP_VALUEHL
be6c			 
be6c e5					push hl    ; u 
be6d					if DEBUG_FORTH_WORDS 
be6d						DMARK "SPA" 
be6d f5				push af  
be6e 3a 82 be			ld a, (.dmark)  
be71 32 6b ee			ld (debug_mark),a  
be74 3a 83 be			ld a, (.dmark+1)  
be77 32 6c ee			ld (debug_mark+1),a  
be7a 3a 84 be			ld a, (.dmark+2)  
be7d 32 6d ee			ld (debug_mark+2),a  
be80 18 03			jr .pastdmark  
be82 ..			.dmark: db "SPA"  
be85 f1			.pastdmark: pop af  
be86			endm  
# End of macro DMARK
be86						CALLMONITOR 
be86 cd 6f ee			call debug_vector  
be89				endm  
# End of macro CALLMONITOR
be89					endif 
be89			 
be89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be89 cd 2b 9d			call macro_forth_dsp_pop 
be8c				endm 
# End of macro FORTH_DSP_POP
be8c e1					pop hl 
be8d 0e 00				ld c, 0 
be8f 45					ld b, l 
be90 21 c1 e2				ld hl, scratch  
be93			 
be93					if DEBUG_FORTH_WORDS 
be93						DMARK "SP2" 
be93 f5				push af  
be94 3a a8 be			ld a, (.dmark)  
be97 32 6b ee			ld (debug_mark),a  
be9a 3a a9 be			ld a, (.dmark+1)  
be9d 32 6c ee			ld (debug_mark+1),a  
bea0 3a aa be			ld a, (.dmark+2)  
bea3 32 6d ee			ld (debug_mark+2),a  
bea6 18 03			jr .pastdmark  
bea8 ..			.dmark: db "SP2"  
beab f1			.pastdmark: pop af  
beac			endm  
# End of macro DMARK
beac						CALLMONITOR 
beac cd 6f ee			call debug_vector  
beaf				endm  
# End of macro CALLMONITOR
beaf					endif 
beaf 3e 20				ld a, ' ' 
beb1			.spaces1:	 
beb1 77					ld (hl),a 
beb2 23					inc hl 
beb3					 
beb3 10 fc				djnz .spaces1 
beb5 3e 00				ld a,0 
beb7 77					ld (hl),a 
beb8 21 c1 e2				ld hl, scratch 
bebb					if DEBUG_FORTH_WORDS 
bebb						DMARK "SP3" 
bebb f5				push af  
bebc 3a d0 be			ld a, (.dmark)  
bebf 32 6b ee			ld (debug_mark),a  
bec2 3a d1 be			ld a, (.dmark+1)  
bec5 32 6c ee			ld (debug_mark+1),a  
bec8 3a d2 be			ld a, (.dmark+2)  
becb 32 6d ee			ld (debug_mark+2),a  
bece 18 03			jr .pastdmark  
bed0 ..			.dmark: db "SP3"  
bed3 f1			.pastdmark: pop af  
bed4			endm  
# End of macro DMARK
bed4						CALLMONITOR 
bed4 cd 6f ee			call debug_vector  
bed7				endm  
# End of macro CALLMONITOR
bed7					endif 
bed7 cd dc 9a				call forth_push_str 
beda			 
beda				       NEXTW 
beda c3 29 9e			jp macro_next 
bedd				endm 
# End of macro NEXTW
bedd			 
bedd			 
bedd			 
bedd			.SCROLL: 
bedd				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bedd 53				db WORD_SYS_CORE+63             
bede 0a bf			dw .SCROLLD            
bee0 07				db 6 + 1 
bee1 .. 00			db "SCROLL",0              
bee8				endm 
# End of macro CWHEAD
bee8			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bee8					if DEBUG_FORTH_WORDS_KEY 
bee8						DMARK "SCR" 
bee8 f5				push af  
bee9 3a fd be			ld a, (.dmark)  
beec 32 6b ee			ld (debug_mark),a  
beef 3a fe be			ld a, (.dmark+1)  
bef2 32 6c ee			ld (debug_mark+1),a  
bef5 3a ff be			ld a, (.dmark+2)  
bef8 32 6d ee			ld (debug_mark+2),a  
befb 18 03			jr .pastdmark  
befd ..			.dmark: db "SCR"  
bf00 f1			.pastdmark: pop af  
bf01			endm  
# End of macro DMARK
bf01						CALLMONITOR 
bf01 cd 6f ee			call debug_vector  
bf04				endm  
# End of macro CALLMONITOR
bf04					endif 
bf04			 
bf04 cd 7c 8a			call scroll_up 
bf07			;	call update_display 
bf07			 
bf07					NEXTW 
bf07 c3 29 9e			jp macro_next 
bf0a				endm 
# End of macro NEXTW
bf0a			 
bf0a			 
bf0a			 
bf0a			;		; get dir 
bf0a			; 
bf0a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf0a			; 
bf0a			;		push hl 
bf0a			; 
bf0a			;		; destroy value TOS 
bf0a			; 
bf0a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf0a			; 
bf0a			;		; get count 
bf0a			; 
bf0a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf0a			; 
bf0a			;		push hl 
bf0a			; 
bf0a			;		; destroy value TOS 
bf0a			; 
bf0a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf0a			; 
bf0a			;		; one value on hl get other one back 
bf0a			; 
bf0a			;		pop bc    ; count 
bf0a			; 
bf0a			;		pop de   ; dir 
bf0a			; 
bf0a			; 
bf0a			;		ld b, c 
bf0a			; 
bf0a			;.scrolldir:     push bc 
bf0a			;		push de 
bf0a			; 
bf0a			;		ld a, 0 
bf0a			;		cp e 
bf0a			;		jr z, .scrollup  
bf0a			;		call scroll_down 
bf0a			;		jr .scrollnext 
bf0a			;.scrollup:	call scroll_up 
bf0a			; 
bf0a			;		 
bf0a			;.scrollnext: 
bf0a			;		pop de 
bf0a			;		pop bc 
bf0a			;		djnz .scrolldir 
bf0a			; 
bf0a			; 
bf0a			; 
bf0a			; 
bf0a			; 
bf0a			;		NEXTW 
bf0a			 
bf0a			.SCROLLD: 
bf0a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bf0a 53				db WORD_SYS_CORE+63             
bf0b 38 bf			dw .ATQ            
bf0d 08				db 7 + 1 
bf0e .. 00			db "SCROLLD",0              
bf16				endm 
# End of macro CWHEAD
bf16			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf16					if DEBUG_FORTH_WORDS_KEY 
bf16						DMARK "SCD" 
bf16 f5				push af  
bf17 3a 2b bf			ld a, (.dmark)  
bf1a 32 6b ee			ld (debug_mark),a  
bf1d 3a 2c bf			ld a, (.dmark+1)  
bf20 32 6c ee			ld (debug_mark+1),a  
bf23 3a 2d bf			ld a, (.dmark+2)  
bf26 32 6d ee			ld (debug_mark+2),a  
bf29 18 03			jr .pastdmark  
bf2b ..			.dmark: db "SCD"  
bf2e f1			.pastdmark: pop af  
bf2f			endm  
# End of macro DMARK
bf2f						CALLMONITOR 
bf2f cd 6f ee			call debug_vector  
bf32				endm  
# End of macro CALLMONITOR
bf32					endif 
bf32			 
bf32 cd a0 8a			call scroll_down 
bf35			;	call update_display 
bf35			 
bf35					NEXTW 
bf35 c3 29 9e			jp macro_next 
bf38				endm 
# End of macro NEXTW
bf38			 
bf38			 
bf38			.ATQ: 
bf38				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf38 62				db WORD_SYS_CORE+78             
bf39 96 bf			dw .AUTODSP            
bf3b 04				db 3 + 1 
bf3c .. 00			db "AT@",0              
bf40				endm 
# End of macro CWHEAD
bf40			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf40					if DEBUG_FORTH_WORDS_KEY 
bf40						DMARK "ATA" 
bf40 f5				push af  
bf41 3a 55 bf			ld a, (.dmark)  
bf44 32 6b ee			ld (debug_mark),a  
bf47 3a 56 bf			ld a, (.dmark+1)  
bf4a 32 6c ee			ld (debug_mark+1),a  
bf4d 3a 57 bf			ld a, (.dmark+2)  
bf50 32 6d ee			ld (debug_mark+2),a  
bf53 18 03			jr .pastdmark  
bf55 ..			.dmark: db "ATA"  
bf58 f1			.pastdmark: pop af  
bf59			endm  
# End of macro DMARK
bf59						CALLMONITOR 
bf59 cd 6f ee			call debug_vector  
bf5c				endm  
# End of macro CALLMONITOR
bf5c					endif 
bf5c			 
bf5c			 
bf5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf5c cd 73 9c			call macro_dsp_valuehl 
bf5f				endm 
# End of macro FORTH_DSP_VALUEHL
bf5f			 
bf5f					; TODO save cursor row 
bf5f 7d					ld a,l 
bf60 fe 02				cp 2 
bf62 20 04				jr nz, .crow3aq 
bf64 3e 28				ld a, display_row_2 
bf66 18 12				jr .ccol1aq 
bf68 fe 03		.crow3aq:		cp 3 
bf6a 20 04				jr nz, .crow4aq 
bf6c 3e 50				ld a, display_row_3 
bf6e 18 0a				jr .ccol1aq 
bf70 fe 04		.crow4aq:		cp 4 
bf72 20 04				jr nz, .crow1aq 
bf74 3e 78				ld a, display_row_4 
bf76 18 02				jr .ccol1aq 
bf78 3e 00		.crow1aq:		ld a,display_row_1 
bf7a f5			.ccol1aq:		push af			; got row offset 
bf7b 6f					ld l,a 
bf7c 26 00				ld h,0 
bf7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf7e cd 2b 9d			call macro_forth_dsp_pop 
bf81				endm 
# End of macro FORTH_DSP_POP
bf81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf81 cd 73 9c			call macro_dsp_valuehl 
bf84				endm 
# End of macro FORTH_DSP_VALUEHL
bf84					; TODO save cursor col 
bf84 f1					pop af 
bf85 85					add l		; add col offset 
bf86			 
bf86					; add current frame buffer address 
bf86 2a cc eb				ld hl, (display_fb_active) 
bf89 cd e7 8c				call addatohl 
bf8c			 
bf8c			 
bf8c			 
bf8c			 
bf8c					; get char frame buffer location offset in hl 
bf8c			 
bf8c 7e					ld a,(hl) 
bf8d 26 00				ld h, 0 
bf8f 6f					ld l, a 
bf90			 
bf90 cd 6e 9a				call forth_push_numhl 
bf93			 
bf93			 
bf93					NEXTW 
bf93 c3 29 9e			jp macro_next 
bf96				endm 
# End of macro NEXTW
bf96			 
bf96			.AUTODSP: 
bf96				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bf96 63				db WORD_SYS_CORE+79             
bf97 ac bf			dw .MENU            
bf99 05				db 4 + 1 
bf9a .. 00			db "ADSP",0              
bf9f				endm 
# End of macro CWHEAD
bf9f			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bf9f			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bf9f			 
bf9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf9f cd 73 9c			call macro_dsp_valuehl 
bfa2				endm 
# End of macro FORTH_DSP_VALUEHL
bfa2			 
bfa2			;		push hl 
bfa2			 
bfa2					; destroy value TOS 
bfa2			 
bfa2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfa2 cd 2b 9d			call macro_forth_dsp_pop 
bfa5				endm 
# End of macro FORTH_DSP_POP
bfa5			 
bfa5			;		pop hl 
bfa5			 
bfa5 7d					ld a,l 
bfa6 32 3c ea				ld (cli_autodisplay), a 
bfa9				       NEXTW 
bfa9 c3 29 9e			jp macro_next 
bfac				endm 
# End of macro NEXTW
bfac			 
bfac			.MENU: 
bfac				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bfac 70				db WORD_SYS_CORE+92             
bfad 55 c0			dw .ENDDISPLAY            
bfaf 05				db 4 + 1 
bfb0 .. 00			db "MENU",0              
bfb5				endm 
# End of macro CWHEAD
bfb5			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
bfb5			 
bfb5			;		; get number of items on the stack 
bfb5			; 
bfb5				 
bfb5					FORTH_DSP_VALUEHL 
bfb5 cd 73 9c			call macro_dsp_valuehl 
bfb8				endm 
# End of macro FORTH_DSP_VALUEHL
bfb8				 
bfb8					if DEBUG_FORTH_WORDS_KEY 
bfb8						DMARK "MNU" 
bfb8 f5				push af  
bfb9 3a cd bf			ld a, (.dmark)  
bfbc 32 6b ee			ld (debug_mark),a  
bfbf 3a ce bf			ld a, (.dmark+1)  
bfc2 32 6c ee			ld (debug_mark+1),a  
bfc5 3a cf bf			ld a, (.dmark+2)  
bfc8 32 6d ee			ld (debug_mark+2),a  
bfcb 18 03			jr .pastdmark  
bfcd ..			.dmark: db "MNU"  
bfd0 f1			.pastdmark: pop af  
bfd1			endm  
# End of macro DMARK
bfd1						CALLMONITOR 
bfd1 cd 6f ee			call debug_vector  
bfd4				endm  
# End of macro CALLMONITOR
bfd4					endif 
bfd4			 
bfd4 45					ld b, l	 
bfd5 05					dec b 
bfd6			 
bfd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfd6 cd 2b 9d			call macro_forth_dsp_pop 
bfd9				endm 
# End of macro FORTH_DSP_POP
bfd9			 
bfd9			 
bfd9					; go directly through the stack to pluck out the string pointers and build an array 
bfd9			 
bfd9			;		FORTH_DSP 
bfd9			 
bfd9					; hl contains top most stack item 
bfd9				 
bfd9 11 c1 e2				ld de, scratch 
bfdc			 
bfdc			.mbuild: 
bfdc			 
bfdc					FORTH_DSP_VALUEHL 
bfdc cd 73 9c			call macro_dsp_valuehl 
bfdf				endm 
# End of macro FORTH_DSP_VALUEHL
bfdf			 
bfdf					if DEBUG_FORTH_WORDS 
bfdf						DMARK "MN3" 
bfdf f5				push af  
bfe0 3a f4 bf			ld a, (.dmark)  
bfe3 32 6b ee			ld (debug_mark),a  
bfe6 3a f5 bf			ld a, (.dmark+1)  
bfe9 32 6c ee			ld (debug_mark+1),a  
bfec 3a f6 bf			ld a, (.dmark+2)  
bfef 32 6d ee			ld (debug_mark+2),a  
bff2 18 03			jr .pastdmark  
bff4 ..			.dmark: db "MN3"  
bff7 f1			.pastdmark: pop af  
bff8			endm  
# End of macro DMARK
bff8						CALLMONITOR 
bff8 cd 6f ee			call debug_vector  
bffb				endm  
# End of macro CALLMONITOR
bffb					endif 
bffb eb					ex de, hl 
bffc 73					ld (hl), e 
bffd 23					inc hl 
bffe 72					ld (hl), d 
bfff 23					inc hl 
c000 eb					ex de, hl 
c001			 
c001					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c001 cd 2b 9d			call macro_forth_dsp_pop 
c004				endm 
# End of macro FORTH_DSP_POP
c004			 
c004 10 d6				djnz .mbuild 
c006			 
c006					; done add term 
c006			 
c006 eb					ex de, hl 
c007 36 00				ld (hl), 0 
c009 23					inc hl 
c00a 36 00				ld (hl), 0 
c00c			 
c00c				 
c00c					 
c00c 21 c1 e2				ld hl, scratch 
c00f			 
c00f					if DEBUG_FORTH_WORDS 
c00f						DMARK "MNx" 
c00f f5				push af  
c010 3a 24 c0			ld a, (.dmark)  
c013 32 6b ee			ld (debug_mark),a  
c016 3a 25 c0			ld a, (.dmark+1)  
c019 32 6c ee			ld (debug_mark+1),a  
c01c 3a 26 c0			ld a, (.dmark+2)  
c01f 32 6d ee			ld (debug_mark+2),a  
c022 18 03			jr .pastdmark  
c024 ..			.dmark: db "MNx"  
c027 f1			.pastdmark: pop af  
c028			endm  
# End of macro DMARK
c028						CALLMONITOR 
c028 cd 6f ee			call debug_vector  
c02b				endm  
# End of macro CALLMONITOR
c02b					endif 
c02b			 
c02b			 
c02b			 
c02b 3e 00				ld a, 0 
c02d cd eb 8a				call menu 
c030			 
c030			 
c030 6f					ld l, a 
c031 26 00				ld h, 0 
c033			 
c033					if DEBUG_FORTH_WORDS 
c033						DMARK "MNr" 
c033 f5				push af  
c034 3a 48 c0			ld a, (.dmark)  
c037 32 6b ee			ld (debug_mark),a  
c03a 3a 49 c0			ld a, (.dmark+1)  
c03d 32 6c ee			ld (debug_mark+1),a  
c040 3a 4a c0			ld a, (.dmark+2)  
c043 32 6d ee			ld (debug_mark+2),a  
c046 18 03			jr .pastdmark  
c048 ..			.dmark: db "MNr"  
c04b f1			.pastdmark: pop af  
c04c			endm  
# End of macro DMARK
c04c						CALLMONITOR 
c04c cd 6f ee			call debug_vector  
c04f				endm  
# End of macro CALLMONITOR
c04f					endif 
c04f			 
c04f cd 6e 9a				call forth_push_numhl 
c052			 
c052			 
c052			 
c052			 
c052				       NEXTW 
c052 c3 29 9e			jp macro_next 
c055				endm 
# End of macro NEXTW
c055			 
c055			 
c055			.ENDDISPLAY: 
c055			 
c055			; eof 
# End of file forth_words_display.asm
c055			include "forth_words_str.asm" 
c055			 
c055			; | ## String Words 
c055			 
c055			.PTR:   
c055			 
c055				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c055 48				db WORD_SYS_CORE+52             
c056 82 c0			dw .STYPE            
c058 04				db 3 + 1 
c059 .. 00			db "PTR",0              
c05d				endm 
# End of macro CWHEAD
c05d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c05d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c05d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c05d			 
c05d					if DEBUG_FORTH_WORDS_KEY 
c05d						DMARK "PTR" 
c05d f5				push af  
c05e 3a 72 c0			ld a, (.dmark)  
c061 32 6b ee			ld (debug_mark),a  
c064 3a 73 c0			ld a, (.dmark+1)  
c067 32 6c ee			ld (debug_mark+1),a  
c06a 3a 74 c0			ld a, (.dmark+2)  
c06d 32 6d ee			ld (debug_mark+2),a  
c070 18 03			jr .pastdmark  
c072 ..			.dmark: db "PTR"  
c075 f1			.pastdmark: pop af  
c076			endm  
# End of macro DMARK
c076						CALLMONITOR 
c076 cd 6f ee			call debug_vector  
c079				endm  
# End of macro CALLMONITOR
c079					endif 
c079					FORTH_DSP_VALUEHL 
c079 cd 73 9c			call macro_dsp_valuehl 
c07c				endm 
# End of macro FORTH_DSP_VALUEHL
c07c cd 6e 9a				call forth_push_numhl 
c07f			 
c07f			 
c07f					NEXTW 
c07f c3 29 9e			jp macro_next 
c082				endm 
# End of macro NEXTW
c082			.STYPE: 
c082				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c082 48				db WORD_SYS_CORE+52             
c083 d1 c0			dw .UPPER            
c085 06				db 5 + 1 
c086 .. 00			db "STYPE",0              
c08c				endm 
# End of macro CWHEAD
c08c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c08c					if DEBUG_FORTH_WORDS_KEY 
c08c						DMARK "STY" 
c08c f5				push af  
c08d 3a a1 c0			ld a, (.dmark)  
c090 32 6b ee			ld (debug_mark),a  
c093 3a a2 c0			ld a, (.dmark+1)  
c096 32 6c ee			ld (debug_mark+1),a  
c099 3a a3 c0			ld a, (.dmark+2)  
c09c 32 6d ee			ld (debug_mark+2),a  
c09f 18 03			jr .pastdmark  
c0a1 ..			.dmark: db "STY"  
c0a4 f1			.pastdmark: pop af  
c0a5			endm  
# End of macro DMARK
c0a5						CALLMONITOR 
c0a5 cd 6f ee			call debug_vector  
c0a8				endm  
# End of macro CALLMONITOR
c0a8					endif 
c0a8					FORTH_DSP 
c0a8 cd 39 9c			call macro_forth_dsp 
c0ab				endm 
# End of macro FORTH_DSP
c0ab					;v5 FORTH_DSP_VALUE 
c0ab			 
c0ab 7e					ld a, (hl) 
c0ac			 
c0ac f5					push af 
c0ad			 
c0ad			; Dont destroy TOS		FORTH_DSP_POP 
c0ad			 
c0ad f1					pop af 
c0ae			 
c0ae fe 01				cp DS_TYPE_STR 
c0b0 28 09				jr z, .typestr 
c0b2			 
c0b2 fe 02				cp DS_TYPE_INUM 
c0b4 28 0a				jr z, .typeinum 
c0b6			 
c0b6 21 cf c0				ld hl, .tna 
c0b9 18 0a				jr .tpush 
c0bb			 
c0bb 21 cb c0		.typestr:	ld hl, .tstr 
c0be 18 05				jr .tpush 
c0c0 21 cd c0		.typeinum:	ld hl, .tinum 
c0c3 18 00				jr .tpush 
c0c5			 
c0c5			.tpush: 
c0c5			 
c0c5 cd dc 9a				call forth_push_str 
c0c8			 
c0c8					NEXTW 
c0c8 c3 29 9e			jp macro_next 
c0cb				endm 
# End of macro NEXTW
c0cb .. 00		.tstr:	db "s",0 
c0cd .. 00		.tinum:  db "i",0 
c0cf .. 00		.tna:   db "?", 0 
c0d1			 
c0d1			 
c0d1			.UPPER: 
c0d1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0d1 48				db WORD_SYS_CORE+52             
c0d2 0c c1			dw .LOWER            
c0d4 06				db 5 + 1 
c0d5 .. 00			db "UPPER",0              
c0db				endm 
# End of macro CWHEAD
c0db			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0db					if DEBUG_FORTH_WORDS_KEY 
c0db						DMARK "UPR" 
c0db f5				push af  
c0dc 3a f0 c0			ld a, (.dmark)  
c0df 32 6b ee			ld (debug_mark),a  
c0e2 3a f1 c0			ld a, (.dmark+1)  
c0e5 32 6c ee			ld (debug_mark+1),a  
c0e8 3a f2 c0			ld a, (.dmark+2)  
c0eb 32 6d ee			ld (debug_mark+2),a  
c0ee 18 03			jr .pastdmark  
c0f0 ..			.dmark: db "UPR"  
c0f3 f1			.pastdmark: pop af  
c0f4			endm  
# End of macro DMARK
c0f4						CALLMONITOR 
c0f4 cd 6f ee			call debug_vector  
c0f7				endm  
# End of macro CALLMONITOR
c0f7					endif 
c0f7			 
c0f7					FORTH_DSP 
c0f7 cd 39 9c			call macro_forth_dsp 
c0fa				endm 
# End of macro FORTH_DSP
c0fa					 
c0fa			; TODO check is string type 
c0fa			 
c0fa					FORTH_DSP_VALUEHL 
c0fa cd 73 9c			call macro_dsp_valuehl 
c0fd				endm 
# End of macro FORTH_DSP_VALUEHL
c0fd			; get pointer to string in hl 
c0fd			 
c0fd 7e			.toup:		ld a, (hl) 
c0fe fe 00				cp 0 
c100 28 07				jr z, .toupdone 
c102			 
c102 cd 5c 8f				call to_upper 
c105			 
c105 77					ld (hl), a 
c106 23					inc hl 
c107 18 f4				jr .toup 
c109			 
c109					 
c109			 
c109			 
c109			; for each char convert to upper 
c109					 
c109			.toupdone: 
c109			 
c109			 
c109					NEXTW 
c109 c3 29 9e			jp macro_next 
c10c				endm 
# End of macro NEXTW
c10c			.LOWER: 
c10c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c10c 48				db WORD_SYS_CORE+52             
c10d 47 c1			dw .TCASE            
c10f 06				db 5 + 1 
c110 .. 00			db "LOWER",0              
c116				endm 
# End of macro CWHEAD
c116			; | LOWER ( s -- s ) Lower case string s  | DONE 
c116					if DEBUG_FORTH_WORDS_KEY 
c116						DMARK "LWR" 
c116 f5				push af  
c117 3a 2b c1			ld a, (.dmark)  
c11a 32 6b ee			ld (debug_mark),a  
c11d 3a 2c c1			ld a, (.dmark+1)  
c120 32 6c ee			ld (debug_mark+1),a  
c123 3a 2d c1			ld a, (.dmark+2)  
c126 32 6d ee			ld (debug_mark+2),a  
c129 18 03			jr .pastdmark  
c12b ..			.dmark: db "LWR"  
c12e f1			.pastdmark: pop af  
c12f			endm  
# End of macro DMARK
c12f						CALLMONITOR 
c12f cd 6f ee			call debug_vector  
c132				endm  
# End of macro CALLMONITOR
c132					endif 
c132			 
c132					FORTH_DSP 
c132 cd 39 9c			call macro_forth_dsp 
c135				endm 
# End of macro FORTH_DSP
c135					 
c135			; TODO check is string type 
c135			 
c135					FORTH_DSP_VALUEHL 
c135 cd 73 9c			call macro_dsp_valuehl 
c138				endm 
# End of macro FORTH_DSP_VALUEHL
c138			; get pointer to string in hl 
c138			 
c138 7e			.tolow:		ld a, (hl) 
c139 fe 00				cp 0 
c13b 28 07				jr z, .tolowdone 
c13d			 
c13d cd 65 8f				call to_lower 
c140			 
c140 77					ld (hl), a 
c141 23					inc hl 
c142 18 f4				jr .tolow 
c144			 
c144					 
c144			 
c144			 
c144			; for each char convert to low 
c144					 
c144			.tolowdone: 
c144					NEXTW 
c144 c3 29 9e			jp macro_next 
c147				endm 
# End of macro NEXTW
c147			.TCASE: 
c147				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c147 48				db WORD_SYS_CORE+52             
c148 7d c2			dw .SUBSTR            
c14a 06				db 5 + 1 
c14b .. 00			db "TCASE",0              
c151				endm 
# End of macro CWHEAD
c151			; | TCASE ( s -- s ) Title case string s  | DONE 
c151					if DEBUG_FORTH_WORDS_KEY 
c151						DMARK "TCS" 
c151 f5				push af  
c152 3a 66 c1			ld a, (.dmark)  
c155 32 6b ee			ld (debug_mark),a  
c158 3a 67 c1			ld a, (.dmark+1)  
c15b 32 6c ee			ld (debug_mark+1),a  
c15e 3a 68 c1			ld a, (.dmark+2)  
c161 32 6d ee			ld (debug_mark+2),a  
c164 18 03			jr .pastdmark  
c166 ..			.dmark: db "TCS"  
c169 f1			.pastdmark: pop af  
c16a			endm  
# End of macro DMARK
c16a						CALLMONITOR 
c16a cd 6f ee			call debug_vector  
c16d				endm  
# End of macro CALLMONITOR
c16d					endif 
c16d			 
c16d					FORTH_DSP 
c16d cd 39 9c			call macro_forth_dsp 
c170				endm 
# End of macro FORTH_DSP
c170					 
c170			; TODO check is string type 
c170			 
c170					FORTH_DSP_VALUEHL 
c170 cd 73 9c			call macro_dsp_valuehl 
c173				endm 
# End of macro FORTH_DSP_VALUEHL
c173			; get pointer to string in hl 
c173			 
c173					if DEBUG_FORTH_WORDS 
c173						DMARK "TC1" 
c173 f5				push af  
c174 3a 88 c1			ld a, (.dmark)  
c177 32 6b ee			ld (debug_mark),a  
c17a 3a 89 c1			ld a, (.dmark+1)  
c17d 32 6c ee			ld (debug_mark+1),a  
c180 3a 8a c1			ld a, (.dmark+2)  
c183 32 6d ee			ld (debug_mark+2),a  
c186 18 03			jr .pastdmark  
c188 ..			.dmark: db "TC1"  
c18b f1			.pastdmark: pop af  
c18c			endm  
# End of macro DMARK
c18c						CALLMONITOR 
c18c cd 6f ee			call debug_vector  
c18f				endm  
# End of macro CALLMONITOR
c18f					endif 
c18f			 
c18f					; first time in turn to upper case first char 
c18f			 
c18f 7e					ld a, (hl) 
c190 c3 1a c2				jp .totsiptou 
c193			 
c193			 
c193 7e			.tot:		ld a, (hl) 
c194 fe 00				cp 0 
c196 ca 5e c2				jp z, .totdone 
c199			 
c199					if DEBUG_FORTH_WORDS 
c199						DMARK "TC2" 
c199 f5				push af  
c19a 3a ae c1			ld a, (.dmark)  
c19d 32 6b ee			ld (debug_mark),a  
c1a0 3a af c1			ld a, (.dmark+1)  
c1a3 32 6c ee			ld (debug_mark+1),a  
c1a6 3a b0 c1			ld a, (.dmark+2)  
c1a9 32 6d ee			ld (debug_mark+2),a  
c1ac 18 03			jr .pastdmark  
c1ae ..			.dmark: db "TC2"  
c1b1 f1			.pastdmark: pop af  
c1b2			endm  
# End of macro DMARK
c1b2						CALLMONITOR 
c1b2 cd 6f ee			call debug_vector  
c1b5				endm  
# End of macro CALLMONITOR
c1b5					endif 
c1b5					; check to see if current char is a space 
c1b5			 
c1b5 fe 20				cp ' ' 
c1b7 28 21				jr z, .totsp 
c1b9 cd 65 8f				call to_lower 
c1bc					if DEBUG_FORTH_WORDS 
c1bc						DMARK "TC3" 
c1bc f5				push af  
c1bd 3a d1 c1			ld a, (.dmark)  
c1c0 32 6b ee			ld (debug_mark),a  
c1c3 3a d2 c1			ld a, (.dmark+1)  
c1c6 32 6c ee			ld (debug_mark+1),a  
c1c9 3a d3 c1			ld a, (.dmark+2)  
c1cc 32 6d ee			ld (debug_mark+2),a  
c1cf 18 03			jr .pastdmark  
c1d1 ..			.dmark: db "TC3"  
c1d4 f1			.pastdmark: pop af  
c1d5			endm  
# End of macro DMARK
c1d5						CALLMONITOR 
c1d5 cd 6f ee			call debug_vector  
c1d8				endm  
# End of macro CALLMONITOR
c1d8					endif 
c1d8 18 63				jr .totnxt 
c1da			 
c1da			.totsp:         ; on a space, find next char which should be upper 
c1da			 
c1da					if DEBUG_FORTH_WORDS 
c1da						DMARK "TC4" 
c1da f5				push af  
c1db 3a ef c1			ld a, (.dmark)  
c1de 32 6b ee			ld (debug_mark),a  
c1e1 3a f0 c1			ld a, (.dmark+1)  
c1e4 32 6c ee			ld (debug_mark+1),a  
c1e7 3a f1 c1			ld a, (.dmark+2)  
c1ea 32 6d ee			ld (debug_mark+2),a  
c1ed 18 03			jr .pastdmark  
c1ef ..			.dmark: db "TC4"  
c1f2 f1			.pastdmark: pop af  
c1f3			endm  
# End of macro DMARK
c1f3						CALLMONITOR 
c1f3 cd 6f ee			call debug_vector  
c1f6				endm  
# End of macro CALLMONITOR
c1f6					endif 
c1f6					;; 
c1f6			 
c1f6 fe 20				cp ' ' 
c1f8 20 20				jr nz, .totsiptou 
c1fa 23					inc hl 
c1fb 7e					ld a, (hl) 
c1fc					if DEBUG_FORTH_WORDS 
c1fc						DMARK "TC5" 
c1fc f5				push af  
c1fd 3a 11 c2			ld a, (.dmark)  
c200 32 6b ee			ld (debug_mark),a  
c203 3a 12 c2			ld a, (.dmark+1)  
c206 32 6c ee			ld (debug_mark+1),a  
c209 3a 13 c2			ld a, (.dmark+2)  
c20c 32 6d ee			ld (debug_mark+2),a  
c20f 18 03			jr .pastdmark  
c211 ..			.dmark: db "TC5"  
c214 f1			.pastdmark: pop af  
c215			endm  
# End of macro DMARK
c215						CALLMONITOR 
c215 cd 6f ee			call debug_vector  
c218				endm  
# End of macro CALLMONITOR
c218					endif 
c218 18 c0				jr .totsp 
c21a fe 00		.totsiptou:    cp 0 
c21c 28 40				jr z, .totdone 
c21e					; not space and not zero term so upper case it 
c21e cd 5c 8f				call to_upper 
c221			 
c221					if DEBUG_FORTH_WORDS 
c221						DMARK "TC6" 
c221 f5				push af  
c222 3a 36 c2			ld a, (.dmark)  
c225 32 6b ee			ld (debug_mark),a  
c228 3a 37 c2			ld a, (.dmark+1)  
c22b 32 6c ee			ld (debug_mark+1),a  
c22e 3a 38 c2			ld a, (.dmark+2)  
c231 32 6d ee			ld (debug_mark+2),a  
c234 18 03			jr .pastdmark  
c236 ..			.dmark: db "TC6"  
c239 f1			.pastdmark: pop af  
c23a			endm  
# End of macro DMARK
c23a						CALLMONITOR 
c23a cd 6f ee			call debug_vector  
c23d				endm  
# End of macro CALLMONITOR
c23d					endif 
c23d			 
c23d			 
c23d			.totnxt: 
c23d			 
c23d 77					ld (hl), a 
c23e 23					inc hl 
c23f					if DEBUG_FORTH_WORDS 
c23f						DMARK "TC7" 
c23f f5				push af  
c240 3a 54 c2			ld a, (.dmark)  
c243 32 6b ee			ld (debug_mark),a  
c246 3a 55 c2			ld a, (.dmark+1)  
c249 32 6c ee			ld (debug_mark+1),a  
c24c 3a 56 c2			ld a, (.dmark+2)  
c24f 32 6d ee			ld (debug_mark+2),a  
c252 18 03			jr .pastdmark  
c254 ..			.dmark: db "TC7"  
c257 f1			.pastdmark: pop af  
c258			endm  
# End of macro DMARK
c258						CALLMONITOR 
c258 cd 6f ee			call debug_vector  
c25b				endm  
# End of macro CALLMONITOR
c25b					endif 
c25b c3 93 c1				jp .tot 
c25e			 
c25e					 
c25e			 
c25e			 
c25e			; for each char convert to low 
c25e					 
c25e			.totdone: 
c25e					if DEBUG_FORTH_WORDS 
c25e						DMARK "TCd" 
c25e f5				push af  
c25f 3a 73 c2			ld a, (.dmark)  
c262 32 6b ee			ld (debug_mark),a  
c265 3a 74 c2			ld a, (.dmark+1)  
c268 32 6c ee			ld (debug_mark+1),a  
c26b 3a 75 c2			ld a, (.dmark+2)  
c26e 32 6d ee			ld (debug_mark+2),a  
c271 18 03			jr .pastdmark  
c273 ..			.dmark: db "TCd"  
c276 f1			.pastdmark: pop af  
c277			endm  
# End of macro DMARK
c277						CALLMONITOR 
c277 cd 6f ee			call debug_vector  
c27a				endm  
# End of macro CALLMONITOR
c27a					endif 
c27a					NEXTW 
c27a c3 29 9e			jp macro_next 
c27d				endm 
# End of macro NEXTW
c27d			 
c27d			.SUBSTR: 
c27d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c27d 48				db WORD_SYS_CORE+52             
c27e db c2			dw .LEFT            
c280 07				db 6 + 1 
c281 .. 00			db "SUBSTR",0              
c288				endm 
# End of macro CWHEAD
c288			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c288			 
c288					if DEBUG_FORTH_WORDS_KEY 
c288						DMARK "SST" 
c288 f5				push af  
c289 3a 9d c2			ld a, (.dmark)  
c28c 32 6b ee			ld (debug_mark),a  
c28f 3a 9e c2			ld a, (.dmark+1)  
c292 32 6c ee			ld (debug_mark+1),a  
c295 3a 9f c2			ld a, (.dmark+2)  
c298 32 6d ee			ld (debug_mark+2),a  
c29b 18 03			jr .pastdmark  
c29d ..			.dmark: db "SST"  
c2a0 f1			.pastdmark: pop af  
c2a1			endm  
# End of macro DMARK
c2a1						CALLMONITOR 
c2a1 cd 6f ee			call debug_vector  
c2a4				endm  
# End of macro CALLMONITOR
c2a4					endif 
c2a4			; TODO check string type 
c2a4					FORTH_DSP_VALUEHL 
c2a4 cd 73 9c			call macro_dsp_valuehl 
c2a7				endm 
# End of macro FORTH_DSP_VALUEHL
c2a7			 
c2a7 e5					push hl      ; string length 
c2a8			 
c2a8					FORTH_DSP_POP 
c2a8 cd 2b 9d			call macro_forth_dsp_pop 
c2ab				endm 
# End of macro FORTH_DSP_POP
c2ab			 
c2ab					FORTH_DSP_VALUEHL 
c2ab cd 73 9c			call macro_dsp_valuehl 
c2ae				endm 
# End of macro FORTH_DSP_VALUEHL
c2ae			 
c2ae e5					push hl     ; start char 
c2af			 
c2af					FORTH_DSP_POP 
c2af cd 2b 9d			call macro_forth_dsp_pop 
c2b2				endm 
# End of macro FORTH_DSP_POP
c2b2			 
c2b2			 
c2b2					FORTH_DSP_VALUE 
c2b2 cd 5c 9c			call macro_forth_dsp_value 
c2b5				endm 
# End of macro FORTH_DSP_VALUE
c2b5			 
c2b5 d1					pop de    ; get start post offset 
c2b6			 
c2b6 19					add hl, de    ; starting offset 
c2b7			 
c2b7 c1					pop bc 
c2b8 c5					push bc      ; grab size of string 
c2b9			 
c2b9 e5					push hl    ; save string start  
c2ba			 
c2ba 26 00				ld h, 0 
c2bc 69					ld l, c 
c2bd 23					inc hl 
c2be 23					inc hl 
c2bf			 
c2bf cd c2 90				call malloc 
c2c2				if DEBUG_FORTH_MALLOC_GUARD 
c2c2 cc f5 cb				call z,malloc_error 
c2c5				endif 
c2c5			 
c2c5 eb					ex de, hl      ; save malloc area for string copy 
c2c6 e1					pop hl    ; get back source 
c2c7 c1					pop bc    ; get length of string back 
c2c8			 
c2c8 d5					push de    ; save malloc area for after we push 
c2c9 ed b0				ldir     ; copy substr 
c2cb			 
c2cb			 
c2cb eb					ex de, hl 
c2cc 3e 00				ld a, 0 
c2ce 77					ld (hl), a   ; term substr 
c2cf			 
c2cf					 
c2cf e1					pop hl    ; get malloc so we can push it 
c2d0 e5					push hl   ; save so we can free it afterwards 
c2d1			 
c2d1 cd dc 9a				call forth_push_str 
c2d4			 
c2d4 e1					pop hl 
c2d5 cd 8c 91				call free 
c2d8			 
c2d8					 
c2d8					 
c2d8			 
c2d8			 
c2d8					NEXTW 
c2d8 c3 29 9e			jp macro_next 
c2db				endm 
# End of macro NEXTW
c2db			 
c2db			.LEFT: 
c2db				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2db 48				db WORD_SYS_CORE+52             
c2dc 03 c3			dw .RIGHT            
c2de 05				db 4 + 1 
c2df .. 00			db "LEFT",0              
c2e4				endm 
# End of macro CWHEAD
c2e4			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2e4					if DEBUG_FORTH_WORDS_KEY 
c2e4						DMARK "LEF" 
c2e4 f5				push af  
c2e5 3a f9 c2			ld a, (.dmark)  
c2e8 32 6b ee			ld (debug_mark),a  
c2eb 3a fa c2			ld a, (.dmark+1)  
c2ee 32 6c ee			ld (debug_mark+1),a  
c2f1 3a fb c2			ld a, (.dmark+2)  
c2f4 32 6d ee			ld (debug_mark+2),a  
c2f7 18 03			jr .pastdmark  
c2f9 ..			.dmark: db "LEF"  
c2fc f1			.pastdmark: pop af  
c2fd			endm  
# End of macro DMARK
c2fd						CALLMONITOR 
c2fd cd 6f ee			call debug_vector  
c300				endm  
# End of macro CALLMONITOR
c300					endif 
c300			 
c300					NEXTW 
c300 c3 29 9e			jp macro_next 
c303				endm 
# End of macro NEXTW
c303			.RIGHT: 
c303				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c303 48				db WORD_SYS_CORE+52             
c304 2c c3			dw .STR2NUM            
c306 06				db 5 + 1 
c307 .. 00			db "RIGHT",0              
c30d				endm 
# End of macro CWHEAD
c30d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c30d					if DEBUG_FORTH_WORDS_KEY 
c30d						DMARK "RIG" 
c30d f5				push af  
c30e 3a 22 c3			ld a, (.dmark)  
c311 32 6b ee			ld (debug_mark),a  
c314 3a 23 c3			ld a, (.dmark+1)  
c317 32 6c ee			ld (debug_mark+1),a  
c31a 3a 24 c3			ld a, (.dmark+2)  
c31d 32 6d ee			ld (debug_mark+2),a  
c320 18 03			jr .pastdmark  
c322 ..			.dmark: db "RIG"  
c325 f1			.pastdmark: pop af  
c326			endm  
# End of macro DMARK
c326						CALLMONITOR 
c326 cd 6f ee			call debug_vector  
c329				endm  
# End of macro CALLMONITOR
c329					endif 
c329			 
c329					NEXTW 
c329 c3 29 9e			jp macro_next 
c32c				endm 
# End of macro NEXTW
c32c			 
c32c			 
c32c			.STR2NUM: 
c32c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c32c 48				db WORD_SYS_CORE+52             
c32d b8 c3			dw .NUM2STR            
c32f 08				db 7 + 1 
c330 .. 00			db "STR2NUM",0              
c338				endm 
# End of macro CWHEAD
c338			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c338			 
c338			 
c338			; TODO STR type check to do 
c338					if DEBUG_FORTH_WORDS_KEY 
c338						DMARK "S2N" 
c338 f5				push af  
c339 3a 4d c3			ld a, (.dmark)  
c33c 32 6b ee			ld (debug_mark),a  
c33f 3a 4e c3			ld a, (.dmark+1)  
c342 32 6c ee			ld (debug_mark+1),a  
c345 3a 4f c3			ld a, (.dmark+2)  
c348 32 6d ee			ld (debug_mark+2),a  
c34b 18 03			jr .pastdmark  
c34d ..			.dmark: db "S2N"  
c350 f1			.pastdmark: pop af  
c351			endm  
# End of macro DMARK
c351						CALLMONITOR 
c351 cd 6f ee			call debug_vector  
c354				endm  
# End of macro CALLMONITOR
c354					endif 
c354			 
c354					;FORTH_DSP 
c354					FORTH_DSP_VALUE 
c354 cd 5c 9c			call macro_forth_dsp_value 
c357				endm 
# End of macro FORTH_DSP_VALUE
c357					;inc hl 
c357			 
c357 eb					ex de, hl 
c358					if DEBUG_FORTH_WORDS 
c358						DMARK "S2a" 
c358 f5				push af  
c359 3a 6d c3			ld a, (.dmark)  
c35c 32 6b ee			ld (debug_mark),a  
c35f 3a 6e c3			ld a, (.dmark+1)  
c362 32 6c ee			ld (debug_mark+1),a  
c365 3a 6f c3			ld a, (.dmark+2)  
c368 32 6d ee			ld (debug_mark+2),a  
c36b 18 03			jr .pastdmark  
c36d ..			.dmark: db "S2a"  
c370 f1			.pastdmark: pop af  
c371			endm  
# End of macro DMARK
c371						CALLMONITOR 
c371 cd 6f ee			call debug_vector  
c374				endm  
# End of macro CALLMONITOR
c374					endif 
c374 cd e4 8f				call string_to_uint16 
c377			 
c377					if DEBUG_FORTH_WORDS 
c377						DMARK "S2b" 
c377 f5				push af  
c378 3a 8c c3			ld a, (.dmark)  
c37b 32 6b ee			ld (debug_mark),a  
c37e 3a 8d c3			ld a, (.dmark+1)  
c381 32 6c ee			ld (debug_mark+1),a  
c384 3a 8e c3			ld a, (.dmark+2)  
c387 32 6d ee			ld (debug_mark+2),a  
c38a 18 03			jr .pastdmark  
c38c ..			.dmark: db "S2b"  
c38f f1			.pastdmark: pop af  
c390			endm  
# End of macro DMARK
c390						CALLMONITOR 
c390 cd 6f ee			call debug_vector  
c393				endm  
# End of macro CALLMONITOR
c393					endif 
c393			;		push hl 
c393					FORTH_DSP_POP 
c393 cd 2b 9d			call macro_forth_dsp_pop 
c396				endm 
# End of macro FORTH_DSP_POP
c396			;		pop hl 
c396					 
c396					if DEBUG_FORTH_WORDS 
c396						DMARK "S2b" 
c396 f5				push af  
c397 3a ab c3			ld a, (.dmark)  
c39a 32 6b ee			ld (debug_mark),a  
c39d 3a ac c3			ld a, (.dmark+1)  
c3a0 32 6c ee			ld (debug_mark+1),a  
c3a3 3a ad c3			ld a, (.dmark+2)  
c3a6 32 6d ee			ld (debug_mark+2),a  
c3a9 18 03			jr .pastdmark  
c3ab ..			.dmark: db "S2b"  
c3ae f1			.pastdmark: pop af  
c3af			endm  
# End of macro DMARK
c3af						CALLMONITOR 
c3af cd 6f ee			call debug_vector  
c3b2				endm  
# End of macro CALLMONITOR
c3b2					endif 
c3b2 cd 6e 9a				call forth_push_numhl	 
c3b5			 
c3b5				 
c3b5				       NEXTW 
c3b5 c3 29 9e			jp macro_next 
c3b8				endm 
# End of macro NEXTW
c3b8			.NUM2STR: 
c3b8				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3b8 48				db WORD_SYS_CORE+52             
c3b9 c7 c3			dw .CONCAT            
c3bb 08				db 7 + 1 
c3bc .. 00			db "NUM2STR",0              
c3c4				endm 
# End of macro CWHEAD
c3c4			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c3c4			 
c3c4			;		; malloc a string to target 
c3c4			;		ld hl, 10     ; TODO max string size should be fine 
c3c4			;		call malloc 
c3c4			;		push hl    ; save malloc location 
c3c4			; 
c3c4			; 
c3c4			;; TODO check int type 
c3c4			;		FORTH_DSP_VALUEHL 
c3c4			;		ld a, l 
c3c4			;		call DispAToASCII   
c3c4			;;TODO need to chage above call to dump into string 
c3c4			; 
c3c4			; 
c3c4			 
c3c4				       NEXTW 
c3c4 c3 29 9e			jp macro_next 
c3c7				endm 
# End of macro NEXTW
c3c7			 
c3c7			.CONCAT: 
c3c7				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3c7 48				db WORD_SYS_CORE+52             
c3c8 7a c4			dw .FIND            
c3ca 07				db 6 + 1 
c3cb .. 00			db "CONCAT",0              
c3d2				endm 
# End of macro CWHEAD
c3d2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3d2			 
c3d2			; TODO check string type 
c3d2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3d2			 
c3d2					if DEBUG_FORTH_WORDS_KEY 
c3d2						DMARK "CON" 
c3d2 f5				push af  
c3d3 3a e7 c3			ld a, (.dmark)  
c3d6 32 6b ee			ld (debug_mark),a  
c3d9 3a e8 c3			ld a, (.dmark+1)  
c3dc 32 6c ee			ld (debug_mark+1),a  
c3df 3a e9 c3			ld a, (.dmark+2)  
c3e2 32 6d ee			ld (debug_mark+2),a  
c3e5 18 03			jr .pastdmark  
c3e7 ..			.dmark: db "CON"  
c3ea f1			.pastdmark: pop af  
c3eb			endm  
# End of macro DMARK
c3eb						CALLMONITOR 
c3eb cd 6f ee			call debug_vector  
c3ee				endm  
# End of macro CALLMONITOR
c3ee					endif 
c3ee			 
c3ee			 
c3ee					FORTH_DSP_VALUE 
c3ee cd 5c 9c			call macro_forth_dsp_value 
c3f1				endm 
# End of macro FORTH_DSP_VALUE
c3f1 e5					push hl   ; s2 
c3f2			 
c3f2					FORTH_DSP_POP 
c3f2 cd 2b 9d			call macro_forth_dsp_pop 
c3f5				endm 
# End of macro FORTH_DSP_POP
c3f5			 
c3f5					FORTH_DSP_VALUE 
c3f5 cd 5c 9c			call macro_forth_dsp_value 
c3f8				endm 
# End of macro FORTH_DSP_VALUE
c3f8			 
c3f8 e5					push hl   ; s1 
c3f9			 
c3f9					FORTH_DSP_POP 
c3f9 cd 2b 9d			call macro_forth_dsp_pop 
c3fc				endm 
# End of macro FORTH_DSP_POP
c3fc					 
c3fc			 
c3fc					; copy s1 
c3fc			 
c3fc				 
c3fc					; save ptr 
c3fc e1					pop hl  
c3fd e5					push hl 
c3fe 3e 00				ld a, 0 
c400 cd 58 90				call strlent 
c403					;inc hl    ; zer0 
c403 06 00				ld b, 0 
c405 4d					ld c, l 
c406 e1					pop hl		 
c407 11 c1 e2				ld de, scratch	 
c40a					if DEBUG_FORTH_WORDS 
c40a						DMARK "CO1" 
c40a f5				push af  
c40b 3a 1f c4			ld a, (.dmark)  
c40e 32 6b ee			ld (debug_mark),a  
c411 3a 20 c4			ld a, (.dmark+1)  
c414 32 6c ee			ld (debug_mark+1),a  
c417 3a 21 c4			ld a, (.dmark+2)  
c41a 32 6d ee			ld (debug_mark+2),a  
c41d 18 03			jr .pastdmark  
c41f ..			.dmark: db "CO1"  
c422 f1			.pastdmark: pop af  
c423			endm  
# End of macro DMARK
c423						CALLMONITOR 
c423 cd 6f ee			call debug_vector  
c426				endm  
# End of macro CALLMONITOR
c426					endif 
c426 ed b0				ldir 
c428			 
c428 e1					pop hl 
c429 e5					push hl 
c42a d5					push de 
c42b			 
c42b			 
c42b 3e 00				ld a, 0 
c42d cd 58 90				call strlent 
c430 23					inc hl    ; zer0 
c431 23					inc hl 
c432 06 00				ld b, 0 
c434 4d					ld c, l 
c435 d1					pop de 
c436 e1					pop hl		 
c437					if DEBUG_FORTH_WORDS 
c437						DMARK "CO2" 
c437 f5				push af  
c438 3a 4c c4			ld a, (.dmark)  
c43b 32 6b ee			ld (debug_mark),a  
c43e 3a 4d c4			ld a, (.dmark+1)  
c441 32 6c ee			ld (debug_mark+1),a  
c444 3a 4e c4			ld a, (.dmark+2)  
c447 32 6d ee			ld (debug_mark+2),a  
c44a 18 03			jr .pastdmark  
c44c ..			.dmark: db "CO2"  
c44f f1			.pastdmark: pop af  
c450			endm  
# End of macro DMARK
c450						CALLMONITOR 
c450 cd 6f ee			call debug_vector  
c453				endm  
# End of macro CALLMONITOR
c453					endif 
c453 ed b0				ldir 
c455			 
c455			 
c455			 
c455 21 c1 e2				ld hl, scratch 
c458					if DEBUG_FORTH_WORDS 
c458						DMARK "CO5" 
c458 f5				push af  
c459 3a 6d c4			ld a, (.dmark)  
c45c 32 6b ee			ld (debug_mark),a  
c45f 3a 6e c4			ld a, (.dmark+1)  
c462 32 6c ee			ld (debug_mark+1),a  
c465 3a 6f c4			ld a, (.dmark+2)  
c468 32 6d ee			ld (debug_mark+2),a  
c46b 18 03			jr .pastdmark  
c46d ..			.dmark: db "CO5"  
c470 f1			.pastdmark: pop af  
c471			endm  
# End of macro DMARK
c471						CALLMONITOR 
c471 cd 6f ee			call debug_vector  
c474				endm  
# End of macro CALLMONITOR
c474					endif 
c474			 
c474 cd dc 9a				call forth_push_str 
c477			 
c477			 
c477			 
c477			 
c477				       NEXTW 
c477 c3 29 9e			jp macro_next 
c47a				endm 
# End of macro NEXTW
c47a			 
c47a			 
c47a			.FIND: 
c47a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c47a 4b				db WORD_SYS_CORE+55             
c47b 38 c5			dw .LEN            
c47d 05				db 4 + 1 
c47e .. 00			db "FIND",0              
c483				endm 
# End of macro CWHEAD
c483			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c483			 
c483					if DEBUG_FORTH_WORDS_KEY 
c483						DMARK "FND" 
c483 f5				push af  
c484 3a 98 c4			ld a, (.dmark)  
c487 32 6b ee			ld (debug_mark),a  
c48a 3a 99 c4			ld a, (.dmark+1)  
c48d 32 6c ee			ld (debug_mark+1),a  
c490 3a 9a c4			ld a, (.dmark+2)  
c493 32 6d ee			ld (debug_mark+2),a  
c496 18 03			jr .pastdmark  
c498 ..			.dmark: db "FND"  
c49b f1			.pastdmark: pop af  
c49c			endm  
# End of macro DMARK
c49c						CALLMONITOR 
c49c cd 6f ee			call debug_vector  
c49f				endm  
# End of macro CALLMONITOR
c49f					endif 
c49f			 
c49f			; TODO check string type 
c49f					FORTH_DSP_VALUE 
c49f cd 5c 9c			call macro_forth_dsp_value 
c4a2				endm 
# End of macro FORTH_DSP_VALUE
c4a2			 
c4a2 e5					push hl    
c4a3 7e					ld a,(hl)    ; char to find   
c4a4			; TODO change char to substr 
c4a4			 
c4a4 f5					push af 
c4a5					 
c4a5			 
c4a5			 
c4a5					if DEBUG_FORTH_WORDS 
c4a5						DMARK "FN1" 
c4a5 f5				push af  
c4a6 3a ba c4			ld a, (.dmark)  
c4a9 32 6b ee			ld (debug_mark),a  
c4ac 3a bb c4			ld a, (.dmark+1)  
c4af 32 6c ee			ld (debug_mark+1),a  
c4b2 3a bc c4			ld a, (.dmark+2)  
c4b5 32 6d ee			ld (debug_mark+2),a  
c4b8 18 03			jr .pastdmark  
c4ba ..			.dmark: db "FN1"  
c4bd f1			.pastdmark: pop af  
c4be			endm  
# End of macro DMARK
c4be						CALLMONITOR 
c4be cd 6f ee			call debug_vector  
c4c1				endm  
# End of macro CALLMONITOR
c4c1					endif 
c4c1			 
c4c1					FORTH_DSP_POP 
c4c1 cd 2b 9d			call macro_forth_dsp_pop 
c4c4				endm 
# End of macro FORTH_DSP_POP
c4c4			 
c4c4					; string to search 
c4c4			 
c4c4					FORTH_DSP_VALUE 
c4c4 cd 5c 9c			call macro_forth_dsp_value 
c4c7				endm 
# End of macro FORTH_DSP_VALUE
c4c7			 
c4c7 d1					pop de  ; d is char to find  
c4c8			 
c4c8					if DEBUG_FORTH_WORDS 
c4c8						DMARK "FN2" 
c4c8 f5				push af  
c4c9 3a dd c4			ld a, (.dmark)  
c4cc 32 6b ee			ld (debug_mark),a  
c4cf 3a de c4			ld a, (.dmark+1)  
c4d2 32 6c ee			ld (debug_mark+1),a  
c4d5 3a df c4			ld a, (.dmark+2)  
c4d8 32 6d ee			ld (debug_mark+2),a  
c4db 18 03			jr .pastdmark  
c4dd ..			.dmark: db "FN2"  
c4e0 f1			.pastdmark: pop af  
c4e1			endm  
# End of macro DMARK
c4e1						CALLMONITOR 
c4e1 cd 6f ee			call debug_vector  
c4e4				endm  
# End of macro CALLMONITOR
c4e4					endif 
c4e4					 
c4e4 01 00 00				ld bc, 0 
c4e7 7e			.findchar:      ld a,(hl) 
c4e8 fe 00				cp 0   		 
c4ea 28 27				jr z, .finddone     
c4ec ba					cp d 
c4ed 28 20				jr z, .foundchar 
c4ef 03					inc bc 
c4f0 23					inc hl 
c4f1					if DEBUG_FORTH_WORDS 
c4f1						DMARK "FN3" 
c4f1 f5				push af  
c4f2 3a 06 c5			ld a, (.dmark)  
c4f5 32 6b ee			ld (debug_mark),a  
c4f8 3a 07 c5			ld a, (.dmark+1)  
c4fb 32 6c ee			ld (debug_mark+1),a  
c4fe 3a 08 c5			ld a, (.dmark+2)  
c501 32 6d ee			ld (debug_mark+2),a  
c504 18 03			jr .pastdmark  
c506 ..			.dmark: db "FN3"  
c509 f1			.pastdmark: pop af  
c50a			endm  
# End of macro DMARK
c50a						CALLMONITOR 
c50a cd 6f ee			call debug_vector  
c50d				endm  
# End of macro CALLMONITOR
c50d					endif 
c50d 18 d8				jr .findchar 
c50f			 
c50f			 
c50f c5			.foundchar:	push bc 
c510 e1					pop hl 
c511 18 03				jr .findexit 
c513			 
c513			 
c513							 
c513			 
c513			.finddone:     ; got to end of string with no find 
c513 21 00 00				ld hl, 0 
c516			.findexit: 
c516			 
c516					if DEBUG_FORTH_WORDS 
c516						DMARK "FNd" 
c516 f5				push af  
c517 3a 2b c5			ld a, (.dmark)  
c51a 32 6b ee			ld (debug_mark),a  
c51d 3a 2c c5			ld a, (.dmark+1)  
c520 32 6c ee			ld (debug_mark+1),a  
c523 3a 2d c5			ld a, (.dmark+2)  
c526 32 6d ee			ld (debug_mark+2),a  
c529 18 03			jr .pastdmark  
c52b ..			.dmark: db "FNd"  
c52e f1			.pastdmark: pop af  
c52f			endm  
# End of macro DMARK
c52f						CALLMONITOR 
c52f cd 6f ee			call debug_vector  
c532				endm  
# End of macro CALLMONITOR
c532					endif 
c532 cd 6e 9a			call forth_push_numhl 
c535			 
c535				       NEXTW 
c535 c3 29 9e			jp macro_next 
c538				endm 
# End of macro NEXTW
c538			 
c538			.LEN: 
c538				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c538 4c				db WORD_SYS_CORE+56             
c539 a2 c5			dw .ASC            
c53b 06				db 5 + 1 
c53c .. 00			db "COUNT",0              
c542				endm 
# End of macro CWHEAD
c542			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c542			 
c542					if DEBUG_FORTH_WORDS_KEY 
c542						DMARK "CNT" 
c542 f5				push af  
c543 3a 57 c5			ld a, (.dmark)  
c546 32 6b ee			ld (debug_mark),a  
c549 3a 58 c5			ld a, (.dmark+1)  
c54c 32 6c ee			ld (debug_mark+1),a  
c54f 3a 59 c5			ld a, (.dmark+2)  
c552 32 6d ee			ld (debug_mark+2),a  
c555 18 03			jr .pastdmark  
c557 ..			.dmark: db "CNT"  
c55a f1			.pastdmark: pop af  
c55b			endm  
# End of macro DMARK
c55b						CALLMONITOR 
c55b cd 6f ee			call debug_vector  
c55e				endm  
# End of macro CALLMONITOR
c55e					endif 
c55e			; TODO check string type 
c55e					FORTH_DSP_VALUE 
c55e cd 5c 9c			call macro_forth_dsp_value 
c561				endm 
# End of macro FORTH_DSP_VALUE
c561			 
c561			 
c561					if DEBUG_FORTH_WORDS 
c561						DMARK "CN?" 
c561 f5				push af  
c562 3a 76 c5			ld a, (.dmark)  
c565 32 6b ee			ld (debug_mark),a  
c568 3a 77 c5			ld a, (.dmark+1)  
c56b 32 6c ee			ld (debug_mark+1),a  
c56e 3a 78 c5			ld a, (.dmark+2)  
c571 32 6d ee			ld (debug_mark+2),a  
c574 18 03			jr .pastdmark  
c576 ..			.dmark: db "CN?"  
c579 f1			.pastdmark: pop af  
c57a			endm  
# End of macro DMARK
c57a						CALLMONITOR 
c57a cd 6f ee			call debug_vector  
c57d				endm  
# End of macro CALLMONITOR
c57d					endif 
c57d cd 4d 90				call strlenz 
c580					if DEBUG_FORTH_WORDS 
c580						DMARK "CNl" 
c580 f5				push af  
c581 3a 95 c5			ld a, (.dmark)  
c584 32 6b ee			ld (debug_mark),a  
c587 3a 96 c5			ld a, (.dmark+1)  
c58a 32 6c ee			ld (debug_mark+1),a  
c58d 3a 97 c5			ld a, (.dmark+2)  
c590 32 6d ee			ld (debug_mark+2),a  
c593 18 03			jr .pastdmark  
c595 ..			.dmark: db "CNl"  
c598 f1			.pastdmark: pop af  
c599			endm  
# End of macro DMARK
c599						CALLMONITOR 
c599 cd 6f ee			call debug_vector  
c59c				endm  
# End of macro CALLMONITOR
c59c					endif 
c59c			 
c59c cd 6e 9a				call forth_push_numhl 
c59f			 
c59f			 
c59f			 
c59f				       NEXTW 
c59f c3 29 9e			jp macro_next 
c5a2				endm 
# End of macro NEXTW
c5a2			.ASC: 
c5a2				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c5a2 4d				db WORD_SYS_CORE+57             
c5a3 10 c6			dw .CHR            
c5a5 04				db 3 + 1 
c5a6 .. 00			db "ASC",0              
c5aa				endm 
# End of macro CWHEAD
c5aa			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c5aa					if DEBUG_FORTH_WORDS_KEY 
c5aa						DMARK "ASC" 
c5aa f5				push af  
c5ab 3a bf c5			ld a, (.dmark)  
c5ae 32 6b ee			ld (debug_mark),a  
c5b1 3a c0 c5			ld a, (.dmark+1)  
c5b4 32 6c ee			ld (debug_mark+1),a  
c5b7 3a c1 c5			ld a, (.dmark+2)  
c5ba 32 6d ee			ld (debug_mark+2),a  
c5bd 18 03			jr .pastdmark  
c5bf ..			.dmark: db "ASC"  
c5c2 f1			.pastdmark: pop af  
c5c3			endm  
# End of macro DMARK
c5c3						CALLMONITOR 
c5c3 cd 6f ee			call debug_vector  
c5c6				endm  
# End of macro CALLMONITOR
c5c6					endif 
c5c6					FORTH_DSP_VALUE 
c5c6 cd 5c 9c			call macro_forth_dsp_value 
c5c9				endm 
# End of macro FORTH_DSP_VALUE
c5c9					;v5 FORTH_DSP_VALUE 
c5c9			;		inc hl      ; now at start of numeric as string 
c5c9			 
c5c9 e5					push hl 
c5ca			 
c5ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5ca cd 2b 9d			call macro_forth_dsp_pop 
c5cd				endm 
# End of macro FORTH_DSP_POP
c5cd			 
c5cd e1					pop hl 
c5ce			 
c5ce					if DEBUG_FORTH_WORDS 
c5ce						DMARK "AS1" 
c5ce f5				push af  
c5cf 3a e3 c5			ld a, (.dmark)  
c5d2 32 6b ee			ld (debug_mark),a  
c5d5 3a e4 c5			ld a, (.dmark+1)  
c5d8 32 6c ee			ld (debug_mark+1),a  
c5db 3a e5 c5			ld a, (.dmark+2)  
c5de 32 6d ee			ld (debug_mark+2),a  
c5e1 18 03			jr .pastdmark  
c5e3 ..			.dmark: db "AS1"  
c5e6 f1			.pastdmark: pop af  
c5e7			endm  
# End of macro DMARK
c5e7						CALLMONITOR 
c5e7 cd 6f ee			call debug_vector  
c5ea				endm  
# End of macro CALLMONITOR
c5ea					endif 
c5ea					; push the content of a onto the stack as a value 
c5ea			 
c5ea 7e					ld a,(hl)   ; get char 
c5eb 26 00				ld h,0 
c5ed 6f					ld l,a 
c5ee					if DEBUG_FORTH_WORDS 
c5ee						DMARK "AS2" 
c5ee f5				push af  
c5ef 3a 03 c6			ld a, (.dmark)  
c5f2 32 6b ee			ld (debug_mark),a  
c5f5 3a 04 c6			ld a, (.dmark+1)  
c5f8 32 6c ee			ld (debug_mark+1),a  
c5fb 3a 05 c6			ld a, (.dmark+2)  
c5fe 32 6d ee			ld (debug_mark+2),a  
c601 18 03			jr .pastdmark  
c603 ..			.dmark: db "AS2"  
c606 f1			.pastdmark: pop af  
c607			endm  
# End of macro DMARK
c607						CALLMONITOR 
c607 cd 6f ee			call debug_vector  
c60a				endm  
# End of macro CALLMONITOR
c60a					endif 
c60a cd 6e 9a				call forth_push_numhl 
c60d			 
c60d				       NEXTW 
c60d c3 29 9e			jp macro_next 
c610				endm 
# End of macro NEXTW
c610			 
c610			.CHR: 
c610				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c610 4d				db WORD_SYS_CORE+57             
c611 4c c6			dw .ENDSTR            
c613 04				db 3 + 1 
c614 .. 00			db "CHR",0              
c618				endm 
# End of macro CWHEAD
c618			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c618					if DEBUG_FORTH_WORDS_KEY 
c618						DMARK "CHR" 
c618 f5				push af  
c619 3a 2d c6			ld a, (.dmark)  
c61c 32 6b ee			ld (debug_mark),a  
c61f 3a 2e c6			ld a, (.dmark+1)  
c622 32 6c ee			ld (debug_mark+1),a  
c625 3a 2f c6			ld a, (.dmark+2)  
c628 32 6d ee			ld (debug_mark+2),a  
c62b 18 03			jr .pastdmark  
c62d ..			.dmark: db "CHR"  
c630 f1			.pastdmark: pop af  
c631			endm  
# End of macro DMARK
c631						CALLMONITOR 
c631 cd 6f ee			call debug_vector  
c634				endm  
# End of macro CALLMONITOR
c634					endif 
c634					FORTH_DSP_VALUEHL 
c634 cd 73 9c			call macro_dsp_valuehl 
c637				endm 
# End of macro FORTH_DSP_VALUEHL
c637			 
c637					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c637 cd 2b 9d			call macro_forth_dsp_pop 
c63a				endm 
# End of macro FORTH_DSP_POP
c63a			 
c63a					; save asci byte as a zero term string and push string 
c63a			 
c63a 7d					ld a,l 
c63b 32 c1 e2				ld (scratch), a 
c63e			 
c63e 3e 00				ld a, 0 
c640 32 c2 e2				ld (scratch+1), a 
c643			 
c643 21 c1 e2				ld hl, scratch 
c646 cd dc 9a				call forth_push_str 
c649			 
c649			 
c649				       NEXTW 
c649 c3 29 9e			jp macro_next 
c64c				endm 
# End of macro NEXTW
c64c			 
c64c			 
c64c			 
c64c			 
c64c			.ENDSTR: 
c64c			; eof 
c64c			 
# End of file forth_words_str.asm
c64c			include "forth_words_key.asm" 
c64c			 
c64c			; | ## Keyboard Words 
c64c			 
c64c			.KEY: 
c64c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c64c 3e				db WORD_SYS_CORE+42             
c64d 7c c6			dw .WAITK            
c64f 04				db 3 + 1 
c650 .. 00			db "KEY",0              
c654				endm 
# End of macro CWHEAD
c654			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
c654			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
c654			; | | Can use something like this to process: 
c654			; | | > repeat active . key ?dup if emit then #1 until  
c654			 
c654					if DEBUG_FORTH_WORDS_KEY 
c654						DMARK "KEY" 
c654 f5				push af  
c655 3a 69 c6			ld a, (.dmark)  
c658 32 6b ee			ld (debug_mark),a  
c65b 3a 6a c6			ld a, (.dmark+1)  
c65e 32 6c ee			ld (debug_mark+1),a  
c661 3a 6b c6			ld a, (.dmark+2)  
c664 32 6d ee			ld (debug_mark+2),a  
c667 18 03			jr .pastdmark  
c669 ..			.dmark: db "KEY"  
c66c f1			.pastdmark: pop af  
c66d			endm  
# End of macro DMARK
c66d						CALLMONITOR 
c66d cd 6f ee			call debug_vector  
c670				endm  
# End of macro CALLMONITOR
c670					endif 
c670			; TODO currently waits 
c670 cd 23 dd				call cin 
c673					;call cin_wait 
c673 6f					ld l, a 
c674 26 00				ld h, 0 
c676 cd 6e 9a				call forth_push_numhl 
c679					NEXTW 
c679 c3 29 9e			jp macro_next 
c67c				endm 
# End of macro NEXTW
c67c			.WAITK: 
c67c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c67c 3f				db WORD_SYS_CORE+43             
c67d ae c6			dw .ACCEPT            
c67f 06				db 5 + 1 
c680 .. 00			db "WAITK",0              
c686				endm 
# End of macro CWHEAD
c686			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c686					if DEBUG_FORTH_WORDS_KEY 
c686						DMARK "WAI" 
c686 f5				push af  
c687 3a 9b c6			ld a, (.dmark)  
c68a 32 6b ee			ld (debug_mark),a  
c68d 3a 9c c6			ld a, (.dmark+1)  
c690 32 6c ee			ld (debug_mark+1),a  
c693 3a 9d c6			ld a, (.dmark+2)  
c696 32 6d ee			ld (debug_mark+2),a  
c699 18 03			jr .pastdmark  
c69b ..			.dmark: db "WAI"  
c69e f1			.pastdmark: pop af  
c69f			endm  
# End of macro DMARK
c69f						CALLMONITOR 
c69f cd 6f ee			call debug_vector  
c6a2				endm  
# End of macro CALLMONITOR
c6a2					endif 
c6a2 cd 1d dd				call cin_wait 
c6a5 6f					ld l, a 
c6a6 26 00				ld h, 0 
c6a8 cd 6e 9a				call forth_push_numhl 
c6ab					NEXTW 
c6ab c3 29 9e			jp macro_next 
c6ae				endm 
# End of macro NEXTW
c6ae			.ACCEPT: 
c6ae				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c6ae 40				db WORD_SYS_CORE+44             
c6af 0c c7			dw .EDIT            
c6b1 07				db 6 + 1 
c6b2 .. 00			db "ACCEPT",0              
c6b9				endm 
# End of macro CWHEAD
c6b9			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6b9					; TODO crashes on push 
c6b9					if DEBUG_FORTH_WORDS_KEY 
c6b9						DMARK "ACC" 
c6b9 f5				push af  
c6ba 3a ce c6			ld a, (.dmark)  
c6bd 32 6b ee			ld (debug_mark),a  
c6c0 3a cf c6			ld a, (.dmark+1)  
c6c3 32 6c ee			ld (debug_mark+1),a  
c6c6 3a d0 c6			ld a, (.dmark+2)  
c6c9 32 6d ee			ld (debug_mark+2),a  
c6cc 18 03			jr .pastdmark  
c6ce ..			.dmark: db "ACC"  
c6d1 f1			.pastdmark: pop af  
c6d2			endm  
# End of macro DMARK
c6d2						CALLMONITOR 
c6d2 cd 6f ee			call debug_vector  
c6d5				endm  
# End of macro CALLMONITOR
c6d5					endif 
c6d5 21 bf e4				ld hl, os_input 
c6d8 3e 00				ld a, 0 
c6da 77					ld (hl),a 
c6db 3a 5e ea				ld a,(f_cursor_ptr) 
c6de 16 64				ld d, 100 
c6e0 0e 00				ld c, 0 
c6e2 1e 28				ld e, 40 
c6e4 cd 14 8d				call input_str 
c6e7					; TODO perhaps do a type check and wrap in quotes if not a number 
c6e7 21 bf e4				ld hl, os_input 
c6ea					if DEBUG_FORTH_WORDS 
c6ea						DMARK "AC1" 
c6ea f5				push af  
c6eb 3a ff c6			ld a, (.dmark)  
c6ee 32 6b ee			ld (debug_mark),a  
c6f1 3a 00 c7			ld a, (.dmark+1)  
c6f4 32 6c ee			ld (debug_mark+1),a  
c6f7 3a 01 c7			ld a, (.dmark+2)  
c6fa 32 6d ee			ld (debug_mark+2),a  
c6fd 18 03			jr .pastdmark  
c6ff ..			.dmark: db "AC1"  
c702 f1			.pastdmark: pop af  
c703			endm  
# End of macro DMARK
c703						CALLMONITOR 
c703 cd 6f ee			call debug_vector  
c706				endm  
# End of macro CALLMONITOR
c706					endif 
c706 cd dc 9a				call forth_push_str 
c709					NEXTW 
c709 c3 29 9e			jp macro_next 
c70c				endm 
# End of macro NEXTW
c70c			 
c70c			.EDIT: 
c70c				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c70c 40				db WORD_SYS_CORE+44             
c70d ae c7			dw .DEDIT            
c70f 05				db 4 + 1 
c710 .. 00			db "EDIT",0              
c715				endm 
# End of macro CWHEAD
c715			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c715			 
c715					; TODO does not copy from stack 
c715					if DEBUG_FORTH_WORDS_KEY 
c715						DMARK "EDT" 
c715 f5				push af  
c716 3a 2a c7			ld a, (.dmark)  
c719 32 6b ee			ld (debug_mark),a  
c71c 3a 2b c7			ld a, (.dmark+1)  
c71f 32 6c ee			ld (debug_mark+1),a  
c722 3a 2c c7			ld a, (.dmark+2)  
c725 32 6d ee			ld (debug_mark+2),a  
c728 18 03			jr .pastdmark  
c72a ..			.dmark: db "EDT"  
c72d f1			.pastdmark: pop af  
c72e			endm  
# End of macro DMARK
c72e						CALLMONITOR 
c72e cd 6f ee			call debug_vector  
c731				endm  
# End of macro CALLMONITOR
c731					endif 
c731			 
c731					;FORTH_DSP 
c731					FORTH_DSP_VALUEHL 
c731 cd 73 9c			call macro_dsp_valuehl 
c734				endm 
# End of macro FORTH_DSP_VALUEHL
c734			;		inc hl    ; TODO do type check 
c734			 
c734			;		call get_word_hl 
c734 e5					push hl 
c735					if DEBUG_FORTH_WORDS 
c735						DMARK "EDp" 
c735 f5				push af  
c736 3a 4a c7			ld a, (.dmark)  
c739 32 6b ee			ld (debug_mark),a  
c73c 3a 4b c7			ld a, (.dmark+1)  
c73f 32 6c ee			ld (debug_mark+1),a  
c742 3a 4c c7			ld a, (.dmark+2)  
c745 32 6d ee			ld (debug_mark+2),a  
c748 18 03			jr .pastdmark  
c74a ..			.dmark: db "EDp"  
c74d f1			.pastdmark: pop af  
c74e			endm  
# End of macro DMARK
c74e						CALLMONITOR 
c74e cd 6f ee			call debug_vector  
c751				endm  
# End of macro CALLMONITOR
c751					endif 
c751				;	ld a, 0 
c751 cd 4d 90				call strlenz 
c754 23					inc hl 
c755			 
c755 06 00				ld b, 0 
c757 4d					ld c, l 
c758			 
c758 e1					pop hl 
c759 11 bf e4				ld de, os_input 
c75c					if DEBUG_FORTH_WORDS_KEY 
c75c						DMARK "EDc" 
c75c f5				push af  
c75d 3a 71 c7			ld a, (.dmark)  
c760 32 6b ee			ld (debug_mark),a  
c763 3a 72 c7			ld a, (.dmark+1)  
c766 32 6c ee			ld (debug_mark+1),a  
c769 3a 73 c7			ld a, (.dmark+2)  
c76c 32 6d ee			ld (debug_mark+2),a  
c76f 18 03			jr .pastdmark  
c771 ..			.dmark: db "EDc"  
c774 f1			.pastdmark: pop af  
c775			endm  
# End of macro DMARK
c775						CALLMONITOR 
c775 cd 6f ee			call debug_vector  
c778				endm  
# End of macro CALLMONITOR
c778					endif 
c778 ed b0				ldir 
c77a			 
c77a			 
c77a 21 bf e4				ld hl, os_input 
c77d					;ld a, 0 
c77d					;ld (hl),a 
c77d 3a 5e ea				ld a,(f_cursor_ptr) 
c780 16 64				ld d, 100 
c782 0e 00				ld c, 0 
c784 1e 28				ld e, 40 
c786 cd 14 8d				call input_str 
c789					; TODO perhaps do a type check and wrap in quotes if not a number 
c789 21 bf e4				ld hl, os_input 
c78c					if DEBUG_FORTH_WORDS 
c78c						DMARK "ED1" 
c78c f5				push af  
c78d 3a a1 c7			ld a, (.dmark)  
c790 32 6b ee			ld (debug_mark),a  
c793 3a a2 c7			ld a, (.dmark+1)  
c796 32 6c ee			ld (debug_mark+1),a  
c799 3a a3 c7			ld a, (.dmark+2)  
c79c 32 6d ee			ld (debug_mark+2),a  
c79f 18 03			jr .pastdmark  
c7a1 ..			.dmark: db "ED1"  
c7a4 f1			.pastdmark: pop af  
c7a5			endm  
# End of macro DMARK
c7a5						CALLMONITOR 
c7a5 cd 6f ee			call debug_vector  
c7a8				endm  
# End of macro CALLMONITOR
c7a8					endif 
c7a8 cd dc 9a				call forth_push_str 
c7ab					NEXTW 
c7ab c3 29 9e			jp macro_next 
c7ae				endm 
# End of macro NEXTW
c7ae			 
c7ae			.DEDIT: 
c7ae				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c7ae 40				db WORD_SYS_CORE+44             
c7af 10 c8			dw .ENDKEY            
c7b1 06				db 5 + 1 
c7b2 .. 00			db "DEDIT",0              
c7b8				endm 
# End of macro CWHEAD
c7b8			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7b8			 
c7b8					; TODO does not copy from stack 
c7b8					if DEBUG_FORTH_WORDS_KEY 
c7b8						DMARK "DED" 
c7b8 f5				push af  
c7b9 3a cd c7			ld a, (.dmark)  
c7bc 32 6b ee			ld (debug_mark),a  
c7bf 3a ce c7			ld a, (.dmark+1)  
c7c2 32 6c ee			ld (debug_mark+1),a  
c7c5 3a cf c7			ld a, (.dmark+2)  
c7c8 32 6d ee			ld (debug_mark+2),a  
c7cb 18 03			jr .pastdmark  
c7cd ..			.dmark: db "DED"  
c7d0 f1			.pastdmark: pop af  
c7d1			endm  
# End of macro DMARK
c7d1						CALLMONITOR 
c7d1 cd 6f ee			call debug_vector  
c7d4				endm  
# End of macro CALLMONITOR
c7d4					endif 
c7d4			 
c7d4					;FORTH_DSP 
c7d4					FORTH_DSP_VALUEHL 
c7d4 cd 73 9c			call macro_dsp_valuehl 
c7d7				endm 
# End of macro FORTH_DSP_VALUEHL
c7d7			;		inc hl    ; TODO do type check 
c7d7			 
c7d7			;		call get_word_hl 
c7d7 e5					push hl 
c7d8 e5					push hl 
c7d9					FORTH_DSP_POP 
c7d9 cd 2b 9d			call macro_forth_dsp_pop 
c7dc				endm 
# End of macro FORTH_DSP_POP
c7dc e1					pop hl 
c7dd					if DEBUG_FORTH_WORDS 
c7dd						DMARK "EDp" 
c7dd f5				push af  
c7de 3a f2 c7			ld a, (.dmark)  
c7e1 32 6b ee			ld (debug_mark),a  
c7e4 3a f3 c7			ld a, (.dmark+1)  
c7e7 32 6c ee			ld (debug_mark+1),a  
c7ea 3a f4 c7			ld a, (.dmark+2)  
c7ed 32 6d ee			ld (debug_mark+2),a  
c7f0 18 03			jr .pastdmark  
c7f2 ..			.dmark: db "EDp"  
c7f5 f1			.pastdmark: pop af  
c7f6			endm  
# End of macro DMARK
c7f6						CALLMONITOR 
c7f6 cd 6f ee			call debug_vector  
c7f9				endm  
# End of macro CALLMONITOR
c7f9					endif 
c7f9				;	ld a, 0 
c7f9 cd 4d 90				call strlenz 
c7fc 23					inc hl 
c7fd			 
c7fd 06 00				ld b, 0 
c7ff 4d					ld c, l 
c800			 
c800 e1					pop hl 
c801			 
c801					;ld a, 0 
c801					;ld (hl),a 
c801 3a 5e ea				ld a,(f_cursor_ptr) 
c804 16 64				ld d, 100 
c806 0e 00				ld c, 0 
c808 1e 28				ld e, 40 
c80a cd 14 8d				call input_str 
c80d					; TODO perhaps do a type check and wrap in quotes if not a number 
c80d					NEXTW 
c80d c3 29 9e			jp macro_next 
c810				endm 
# End of macro NEXTW
c810			 
c810			 
c810			.ENDKEY: 
c810			; eof 
c810			 
# End of file forth_words_key.asm
c810			include "forth_words_const.asm" 
c810			 
c810			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c810			 
c810			 
c810			.SPITIME: 
c810				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c810 77				db WORD_SYS_CORE+99             
c811 25 c8			dw .VA            
c813 08				db 7 + 1 
c814 .. 00			db "SPITIME",0              
c81c				endm 
# End of macro CWHEAD
c81c			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
c81c			; 
c81c			; | | If using BANK devices then leave as is. 
c81c			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
c81c			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
c81c			 
c81c 21 64 ea				ld hl, spi_clktime  
c81f cd 6e 9a				call forth_push_numhl 
c822			 
c822					NEXTW 
c822 c3 29 9e			jp macro_next 
c825				endm 
# End of macro NEXTW
c825			 
c825			 
c825			.VA: 
c825				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c825 77				db WORD_SYS_CORE+99             
c826 35 c8			dw .SYMBOL            
c828 03				db 2 + 1 
c829 .. 00			db "VA",0              
c82c				endm 
# End of macro CWHEAD
c82c			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
c82c 21 28 ea				ld hl, cli_var_array 
c82f cd 6e 9a				call forth_push_numhl 
c832			 
c832					NEXTW 
c832 c3 29 9e			jp macro_next 
c835				endm 
# End of macro NEXTW
c835			 
c835			.SYMBOL: 
c835				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c835 77				db WORD_SYS_CORE+99             
c836 3f c9			dw .ENDCONST            
c838 07				db 6 + 1 
c839 .. 00			db "SYMBOL",0              
c840				endm 
# End of macro CWHEAD
c840			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c840			; | 
c840			; | | The value is the number reference and the final address is pushed to stack 
c840			 
c840			; | | ``` 
c840			; | | dw sym_table 
c840			; | | dw nmi_vector 
c840			; | | dw cli_autodisplay 
c840			; | | dw cli_data_sp 
c840			; | | dw cli_data_stack 
c840			; | | dw cli_loop_sp 
c840			; | | dw cli_loop_stack 
c840			; | | dw cli_var_array 
c840			; | | dw cursor_col 
c840			; | | dw cursor_ptr 
c840			; | | ; 10 
c840			; | | dw cursor_row 
c840			; | | dw debug_mark 
c840			; | | dw display_fb0 
c840			; | | dw display_fb1 
c840			; | | dw display_fb2 
c840			; | | dw display_fb3 
c840			; | | dw display_fb_active 
c840			; | | dw execscratch 
c840			; | | dw f_cursor_ptr 
c840			; | | dw hardware_word 
c840			; | | ;20 
c840			; | | dw input_at_cursor 
c840			; | | dw input_at_pos 
c840			; | | dw input_cur_flash 
c840			; | | dw input_cur_onoff 
c840			; | | dw input_cursor 
c840			; | | dw input_display_size 
c840			; | | dw input_len 
c840			; | | dw input_ptr 
c840			; | | dw input_size 
c840			; | | dw input_start 
c840			; | | ; 30 
c840			; | | dw input_str 
c840			; | | dw input_under_cursor 
c840			; | | dw os_cli_cmd 
c840			; | | dw os_cur_ptr 
c840			; | | dw os_current_i 
c840			; | | dw os_input 
c840			; | | dw os_last_cmd 
c840			; | | dw os_last_new_uword 
c840			; | | dw debug_vector 
c840			; | | dw os_view_hl 
c840			; | | ;40 
c840			; | | dw os_word_scratch 
c840			; | | dw portbctl 
c840			; | | dw portbdata 
c840			; | | dw spi_cartdev 
c840			; | | dw spi_cartdev2 
c840			; | | dw spi_clktime 
c840			; | | dw spi_device 
c840			; | | dw spi_device_id 
c840			; | | dw spi_portbyte 
c840			; | | dw stackstore 
c840			; | | ; 50 
c840			; | | if STORAGE_SE 
c840			; | | dw storage_actl 
c840			; | | dw storage_adata 
c840			; | | else 
c840			; | | dw 0 
c840			; | | dw 0 
c840			; | | endif 
c840			; | | dw storage_append 
c840			; | | if STORAGE_SE 
c840			; | | dw storage_bctl 
c840			; | | else 
c840			; | | dw 0 
c840			; | | endif 
c840			; | | dw store_bank_active 
c840			; | | dw store_filecache 
c840			; | | dw store_longread 
c840			; | | dw store_openaddr 
c840			; | | dw store_openext 
c840			; | | dw store_openmaxext 
c840			; | | ; 60 
c840			; | | dw store_page 
c840			; | | dw store_readbuf 
c840			; | | dw store_readcont 
c840			; | | dw store_readptr 
c840			; | | dw store_tmpext 
c840			; | | dw store_tmpid 
c840			; | | dw store_tmppageid 
c840			; | | dw malloc 
c840			; | | dw free 
c840			; | | dw cin 
c840			; | | ; 70 
c840			; | | dw cin_wait 
c840			; | | dw forth_push_numhl 
c840			; | | dw forth_push_str 
c840			; | | ``` 
c840			 
c840					if DEBUG_FORTH_WORDS_KEY 
c840						DMARK "SYM" 
c840 f5				push af  
c841 3a 55 c8			ld a, (.dmark)  
c844 32 6b ee			ld (debug_mark),a  
c847 3a 56 c8			ld a, (.dmark+1)  
c84a 32 6c ee			ld (debug_mark+1),a  
c84d 3a 57 c8			ld a, (.dmark+2)  
c850 32 6d ee			ld (debug_mark+2),a  
c853 18 03			jr .pastdmark  
c855 ..			.dmark: db "SYM"  
c858 f1			.pastdmark: pop af  
c859			endm  
# End of macro DMARK
c859						CALLMONITOR 
c859 cd 6f ee			call debug_vector  
c85c				endm  
# End of macro CALLMONITOR
c85c					endif 
c85c			 
c85c					FORTH_DSP_VALUEHL 
c85c cd 73 9c			call macro_dsp_valuehl 
c85f				endm 
# End of macro FORTH_DSP_VALUEHL
c85f			 
c85f 7d					ld a, l     
c860			 
c860			 
c860					if DEBUG_FORTH_WORDS 
c860						DMARK "SY1" 
c860 f5				push af  
c861 3a 75 c8			ld a, (.dmark)  
c864 32 6b ee			ld (debug_mark),a  
c867 3a 76 c8			ld a, (.dmark+1)  
c86a 32 6c ee			ld (debug_mark+1),a  
c86d 3a 77 c8			ld a, (.dmark+2)  
c870 32 6d ee			ld (debug_mark+2),a  
c873 18 03			jr .pastdmark  
c875 ..			.dmark: db "SY1"  
c878 f1			.pastdmark: pop af  
c879			endm  
# End of macro DMARK
c879						CALLMONITOR 
c879 cd 6f ee			call debug_vector  
c87c				endm  
# End of macro CALLMONITOR
c87c					endif 
c87c					 
c87c f5					push af	 
c87d					FORTH_DSP_POP 
c87d cd 2b 9d			call macro_forth_dsp_pop 
c880				endm 
# End of macro FORTH_DSP_POP
c880 f1					pop af 
c881			 
c881 cb 27				sla a  
c883				 
c883					 
c883					if DEBUG_FORTH_WORDS 
c883						DMARK "SY" 
c883 f5				push af  
c884 3a 98 c8			ld a, (.dmark)  
c887 32 6b ee			ld (debug_mark),a  
c88a 3a 99 c8			ld a, (.dmark+1)  
c88d 32 6c ee			ld (debug_mark+1),a  
c890 3a 9a c8			ld a, (.dmark+2)  
c893 32 6d ee			ld (debug_mark+2),a  
c896 18 02			jr .pastdmark  
c898 ..			.dmark: db "SY"  
c89a f1			.pastdmark: pop af  
c89b			endm  
# End of macro DMARK
c89b						CALLMONITOR 
c89b cd 6f ee			call debug_vector  
c89e				endm  
# End of macro CALLMONITOR
c89e					endif 
c89e			 
c89e 21 ad c8				ld hl, sym_table 
c8a1 cd e7 8c				call addatohl 
c8a4 cd ab 9d				call loadwordinhl 
c8a7 cd 6e 9a				call forth_push_numhl 
c8aa			 
c8aa			 
c8aa				       NEXTW 
c8aa c3 29 9e			jp macro_next 
c8ad				endm 
# End of macro NEXTW
c8ad			 
c8ad			sym_table: 
c8ad			 
c8ad			; 0 
c8ad ad c8		dw sym_table 
c8af 72 ee		dw nmi_vector 
c8b1 3c ea		dw cli_autodisplay 
c8b3 ee e9		dw cli_data_sp 
c8b5 28 e8		dw cli_data_stack 
c8b7 f0 e9		dw cli_loop_sp 
c8b9 2a e9		dw cli_loop_stack 
c8bb 28 ea		dw cli_var_array 
c8bd c5 eb		dw cursor_col 
c8bf c3 eb		dw cursor_ptr 
c8c1			; 10 
c8c1 c4 eb		dw cursor_row 
c8c3 6b ee		dw debug_mark 
c8c5 b1 ed		dw display_fb0 
c8c7 10 ed		dw display_fb1 
c8c9 ce eb		dw display_fb2 
c8cb 6f ec		dw display_fb3 
c8cd cc eb		dw display_fb_active 
c8cf c0 e3		dw execscratch 
c8d1 5e ea		dw f_cursor_ptr 
c8d3 75 ee		dw hardware_word 
c8d5			;20 
c8d5 62 ee		dw input_at_cursor 
c8d7 64 ee		dw input_at_pos 
c8d9 60 ee		dw input_cur_flash 
c8db 5f ee		dw input_cur_onoff 
c8dd 55 ee		dw input_cursor 
c8df 65 ee		dw input_display_size 
c8e1 5a ee		dw input_len 
c8e3 69 ee		dw input_ptr 
c8e5 66 ee		dw input_size 
c8e7 67 ee		dw input_start 
c8e9			; 30 
c8e9 14 8d		dw input_str 
c8eb 63 ee		dw input_under_cursor 
c8ed e8 e5		dw os_cli_cmd 
c8ef e4 e5		dw os_cur_ptr 
c8f1 e6 e5		dw os_current_i 
c8f3 bf e4		dw os_input 
c8f5 e7 e6		dw os_last_cmd 
c8f7 be e5		dw os_last_new_uword 
c8f9 6f ee		dw debug_vector 
c8fb a3 e2		dw os_view_hl 
c8fd			;40 
c8fd c6 e5		dw os_word_scratch 
c8ff c3 00		dw portbctl 
c901 c1 00		dw portbdata 
c903 63 ea		dw spi_cartdev 
c905 62 ea		dw spi_cartdev2 
c907 64 ea		dw spi_clktime 
c909 60 ea		dw spi_device 
c90b 5f ea		dw spi_device_id 
c90d 61 ea		dw spi_portbyte 
c90f a7 eb		dw stackstore 
c911			; 50 
c911			if STORAGE_SE 
c911			dw storage_actl 
c911			dw storage_adata 
c911			else 
c911 00 00		dw 0 
c913 00 00		dw 0 
c915			endif 
c915 74 88		dw storage_append 
c917			if STORAGE_SE 
c917			dw storage_bctl 
c917			else 
c917 00 00		dw 0 
c919			endif 
c919 93 eb		dw store_bank_active 
c91b 67 ea		dw store_filecache 
c91d 75 ea		dw store_longread 
c91f 6b ea		dw store_openaddr 
c921 6a ea		dw store_openext 
c923 69 ea		dw store_openmaxext 
c925			; 60 
c925 7a ea		dw store_page 
c927 76 ea		dw store_readbuf 
c929 6d ea		dw store_readcont 
c92b 78 ea		dw store_readptr 
c92d 6d ea		dw store_tmpext 
c92f 6e ea		dw store_tmpid 
c931 65 ea		dw store_tmppageid 
c933 c2 90		dw malloc 
c935 8c 91		dw free 
c937 23 dd		dw cin 
c939			; 70 
c939 1d dd		dw cin_wait 
c93b 6e 9a		dw forth_push_numhl 
c93d dc 9a		dw forth_push_str 
c93f			 
c93f			 
c93f			.ENDCONST: 
c93f			 
c93f			; eof 
c93f			 
c93f			 
# End of file forth_words_const.asm
c93f			 
c93f			if STORAGE_SE 
c93f			   	include "forth_words_storage.asm" 
c93f			endif 
c93f				include "forth_words_device.asm" 
c93f			; Device related words 
c93f			 
c93f			; | ## Device Words 
c93f			 
c93f			;if SOUND_ENABLE 
c93f			;.NOTE: 
c93f			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c93f			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
c93f			;		if DEBUG_FORTH_WORDS_KEY 
c93f			;			DMARK "NTE" 
c93f			;			CALLMONITOR 
c93f			;		endif 
c93f			; 
c93f			;	 
c93f			; 
c93f			;		NEXTW 
c93f			;.AFTERSOUND: 
c93f			;endif 
c93f			 
c93f			 
c93f			USE_GPIO: equ 0 
c93f			 
c93f			if USE_GPIO 
c93f			.GP1: 
c93f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c93f			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
c93f					NEXTW 
c93f			.GP2: 
c93f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c93f			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
c93f			 
c93f					NEXTW 
c93f			 
c93f			.GP3: 
c93f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c93f			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
c93f			 
c93f					NEXTW 
c93f			 
c93f			.GP4: 
c93f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c93f			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
c93f			 
c93f					NEXTW 
c93f			.SIN: 
c93f			 
c93f			 
c93f			endif 
c93f			 
c93f			 
c93f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c93f 33				db WORD_SYS_CORE+31             
c940 74 c9			dw .SOUT            
c942 03				db 2 + 1 
c943 .. 00			db "IN",0              
c946				endm 
# End of macro CWHEAD
c946			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c946					if DEBUG_FORTH_WORDS_KEY 
c946						DMARK "IN." 
c946 f5				push af  
c947 3a 5b c9			ld a, (.dmark)  
c94a 32 6b ee			ld (debug_mark),a  
c94d 3a 5c c9			ld a, (.dmark+1)  
c950 32 6c ee			ld (debug_mark+1),a  
c953 3a 5d c9			ld a, (.dmark+2)  
c956 32 6d ee			ld (debug_mark+2),a  
c959 18 03			jr .pastdmark  
c95b ..			.dmark: db "IN."  
c95e f1			.pastdmark: pop af  
c95f			endm  
# End of macro DMARK
c95f						CALLMONITOR 
c95f cd 6f ee			call debug_vector  
c962				endm  
# End of macro CALLMONITOR
c962					endif 
c962					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c962 cd 73 9c			call macro_dsp_valuehl 
c965				endm 
# End of macro FORTH_DSP_VALUEHL
c965			 
c965 e5					push hl 
c966			 
c966					; destroy value TOS 
c966			 
c966					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c966 cd 2b 9d			call macro_forth_dsp_pop 
c969				endm 
# End of macro FORTH_DSP_POP
c969			 
c969					; one value on hl get other one back 
c969			 
c969 c1					pop bc 
c96a			 
c96a					; do the sub 
c96a			;		ex de, hl 
c96a			 
c96a ed 68				in l,(c) 
c96c			 
c96c					; save it 
c96c			 
c96c 26 00				ld h,0 
c96e			 
c96e					; TODO push value back onto stack for another op etc 
c96e			 
c96e cd 6e 9a				call forth_push_numhl 
c971					NEXTW 
c971 c3 29 9e			jp macro_next 
c974				endm 
# End of macro NEXTW
c974			.SOUT: 
c974				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c974 34				db WORD_SYS_CORE+32             
c975 c7 c9			dw .SPIO            
c977 04				db 3 + 1 
c978 .. 00			db "OUT",0              
c97c				endm 
# End of macro CWHEAD
c97c			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c97c					if DEBUG_FORTH_WORDS_KEY 
c97c						DMARK "OUT" 
c97c f5				push af  
c97d 3a 91 c9			ld a, (.dmark)  
c980 32 6b ee			ld (debug_mark),a  
c983 3a 92 c9			ld a, (.dmark+1)  
c986 32 6c ee			ld (debug_mark+1),a  
c989 3a 93 c9			ld a, (.dmark+2)  
c98c 32 6d ee			ld (debug_mark+2),a  
c98f 18 03			jr .pastdmark  
c991 ..			.dmark: db "OUT"  
c994 f1			.pastdmark: pop af  
c995			endm  
# End of macro DMARK
c995						CALLMONITOR 
c995 cd 6f ee			call debug_vector  
c998				endm  
# End of macro CALLMONITOR
c998					endif 
c998			 
c998					; get port 
c998			 
c998					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c998 cd 73 9c			call macro_dsp_valuehl 
c99b				endm 
# End of macro FORTH_DSP_VALUEHL
c99b			 
c99b e5					push hl 
c99c			 
c99c					; destroy value TOS 
c99c			 
c99c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c99c cd 2b 9d			call macro_forth_dsp_pop 
c99f				endm 
# End of macro FORTH_DSP_POP
c99f			 
c99f					; get byte to send 
c99f			 
c99f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c99f cd 73 9c			call macro_dsp_valuehl 
c9a2				endm 
# End of macro FORTH_DSP_VALUEHL
c9a2			 
c9a2			;		push hl 
c9a2			 
c9a2					; destroy value TOS 
c9a2			 
c9a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9a2 cd 2b 9d			call macro_forth_dsp_pop 
c9a5				endm 
# End of macro FORTH_DSP_POP
c9a5			 
c9a5					; one value on hl get other one back 
c9a5			 
c9a5			;		pop hl 
c9a5			 
c9a5 c1					pop bc 
c9a6			 
c9a6					if DEBUG_FORTH_WORDS 
c9a6						DMARK "OUT" 
c9a6 f5				push af  
c9a7 3a bb c9			ld a, (.dmark)  
c9aa 32 6b ee			ld (debug_mark),a  
c9ad 3a bc c9			ld a, (.dmark+1)  
c9b0 32 6c ee			ld (debug_mark+1),a  
c9b3 3a bd c9			ld a, (.dmark+2)  
c9b6 32 6d ee			ld (debug_mark+2),a  
c9b9 18 03			jr .pastdmark  
c9bb ..			.dmark: db "OUT"  
c9be f1			.pastdmark: pop af  
c9bf			endm  
# End of macro DMARK
c9bf						CALLMONITOR 
c9bf cd 6f ee			call debug_vector  
c9c2				endm  
# End of macro CALLMONITOR
c9c2					endif 
c9c2			 
c9c2 ed 69				out (c), l 
c9c4			 
c9c4					NEXTW 
c9c4 c3 29 9e			jp macro_next 
c9c7				endm 
# End of macro NEXTW
c9c7			 
c9c7			 
c9c7			.SPIO: 
c9c7			 
c9c7			if STORAGE_SE 
c9c7				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9c7			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9c7			 
c9c7					call spi_ce_low 
c9c7			    NEXTW 
c9c7			 
c9c7			.SPICEH: 
c9c7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9c7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9c7			 
c9c7					call spi_ce_high 
c9c7			    NEXTW 
c9c7			 
c9c7			 
c9c7			.SPIOb: 
c9c7			 
c9c7				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9c7			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9c7			 
c9c7					if DEBUG_FORTH_WORDS_KEY 
c9c7						DMARK "SPo" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7					; get port 
c9c7			 
c9c7			 
c9c7					; get byte to send 
c9c7			 
c9c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9c7			 
c9c7			;		push hl    ; u1  
c9c7			 
c9c7					; destroy value TOS 
c9c7			 
c9c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9c7			 
c9c7					; one value on hl get other one back 
c9c7			 
c9c7			;		pop hl   ; u2 - addr 
c9c7			 
c9c7					; TODO Send SPI byte 
c9c7			 
c9c7			;		push hl 
c9c7			;		call spi_ce_low 
c9c7			;		pop hl 
c9c7					ld a, l 
c9c7					call spi_send_byte 
c9c7			;		call spi_ce_high 
c9c7			 
c9c7					NEXTW 
c9c7			 
c9c7			.SPII: 
c9c7				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9c7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9c7					if DEBUG_FORTH_WORDS_KEY 
c9c7						DMARK "SPi" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7			 
c9c7					; TODO Get SPI byte 
c9c7			 
c9c7					call spi_read_byte 
c9c7			 
c9c7					if DEBUG_FORTH_WORDS 
c9c7						DMARK "Si2" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7					ld h, 0 
c9c7					ld l, a 
c9c7					if DEBUG_FORTH_WORDS 
c9c7						DMARK "Si3" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7					call forth_push_numhl 
c9c7			 
c9c7					NEXTW 
c9c7			 
c9c7			 
c9c7			 
c9c7			.SESEL: 
c9c7				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9c7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9c7					if DEBUG_FORTH_WORDS_KEY 
c9c7						DMARK "BNK" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7			 
c9c7					ld a, 255 
c9c7					ld (spi_cartdev), a 
c9c7			 
c9c7					; get bank 
c9c7			 
c9c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9c7			 
c9c7			;		push hl 
c9c7			 
c9c7					; destroy value TOS 
c9c7			 
c9c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9c7			 
c9c7					; one value on hl get other one back 
c9c7			 
c9c7			;		pop hl 
c9c7			 
c9c7			 
c9c7					ld c, SPI_CE_HIGH 
c9c7					ld b, '0'    ; human readable bank number 
c9c7			 
c9c7					ld a, l 
c9c7			 
c9c7					if DEBUG_FORTH_WORDS 
c9c7						DMARK "BNK" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7			 
c9c7					; active low 
c9c7			 
c9c7					cp 0 
c9c7					jr z, .bset 
c9c7					cp 1 
c9c7					jr nz, .b2 
c9c7					res 0, c 
c9c7					ld b, '1'    ; human readable bank number 
c9c7			.b2:		cp 2 
c9c7					jr nz, .b3 
c9c7					res 1, c 
c9c7					ld b, '2'    ; human readable bank number 
c9c7			.b3:		cp 3 
c9c7					jr nz, .b4 
c9c7					res 2, c 
c9c7					ld b, '3'    ; human readable bank number 
c9c7			.b4:		cp 4 
c9c7					jr nz, .b5 
c9c7					res 3, c 
c9c7					ld b, '4'    ; human readable bank number 
c9c7			.b5:		cp 5 
c9c7					jr nz, .bset 
c9c7					res 4, c 
c9c7					ld b, '5'    ; human readable bank number 
c9c7			 
c9c7			.bset: 
c9c7					ld a, c 
c9c7					ld (spi_device),a 
c9c7					ld a, b 
c9c7					ld (spi_device_id),a 
c9c7					if DEBUG_FORTH_WORDS 
c9c7						DMARK "BN2" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7			 
c9c7					; set default SPI clk pulse time as disabled for BANK use 
c9c7			 
c9c7					ld a, 0 
c9c7					ld (spi_clktime), a 
c9c7			 
c9c7					NEXTW 
c9c7			 
c9c7			.CARTDEV: 
c9c7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9c7			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9c7					if DEBUG_FORTH_WORDS_KEY 
c9c7						DMARK "CDV" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7			 
c9c7					; disable se storage bank selection 
c9c7			 
c9c7					ld a, SPI_CE_HIGH		; ce high 
c9c7					ld (spi_device), a 
c9c7			 
c9c7					; get bank 
c9c7			 
c9c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9c7			 
c9c7			;		push hl 
c9c7			 
c9c7					; destroy value TOS 
c9c7			 
c9c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9c7			 
c9c7					; one value on hl get other one back 
c9c7			 
c9c7			;		pop hl 
c9c7			 
c9c7					; active low 
c9c7			 
c9c7					ld c, 255 
c9c7			 
c9c7					ld a, l 
c9c7					if DEBUG_FORTH_WORDS 
c9c7						DMARK "CDV" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7					cp 0 
c9c7					jr z, .cset 
c9c7					cp 1 
c9c7					jr nz, .c2 
c9c7					res 0, c 
c9c7			.c2:		cp 2 
c9c7					jr nz, .c3 
c9c7					res 1, c 
c9c7			.c3:		cp 3 
c9c7					jr nz, .c4 
c9c7					res 2, c 
c9c7			.c4:		cp 4 
c9c7					jr nz, .c5 
c9c7					res 3, c 
c9c7			.c5:		cp 5 
c9c7					jr nz, .c6 
c9c7					res 4, c 
c9c7			.c6:		cp 6 
c9c7					jr nz, .c7 
c9c7					res 5, c 
c9c7			.c7:		cp 7 
c9c7					jr nz, .c8 
c9c7					res 6, c 
c9c7			.c8:		cp 8 
c9c7					jr nz, .cset 
c9c7					res 7, c 
c9c7			.cset:		ld a, c 
c9c7					ld (spi_cartdev),a 
c9c7			 
c9c7					if DEBUG_FORTH_WORDS 
c9c7						DMARK "CD2" 
c9c7						CALLMONITOR 
c9c7					endif 
c9c7			 
c9c7					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9c7			 
c9c7					ld a, $0a 
c9c7					ld (spi_clktime), a 
c9c7					NEXTW 
c9c7			endif 
c9c7			 
c9c7			.ENDDEVICE: 
c9c7			; eof 
c9c7			 
# End of file forth_words_device.asm
c9c7			 
c9c7			; var handler 
c9c7			 
c9c7			 
c9c7			.VARS: 
c9c7				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9c7 77				db WORD_SYS_CORE+99             
c9c8 78 ca			dw .V0            
c9ca 04				db 3 + 1 
c9cb .. 00			db "VAR",0              
c9cf				endm 
# End of macro CWHEAD
c9cf			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9cf			;| 
c9cf			;| The variable name should consist of a single letter. e.g. "a" 
c9cf			;! If a full string is passed then only the first char is looked at 
c9cf			;| Any other char could exceed bounds checks!  
c9cf			 
c9cf					if DEBUG_FORTH_WORDS_KEY 
c9cf						DMARK "VAR" 
c9cf f5				push af  
c9d0 3a e4 c9			ld a, (.dmark)  
c9d3 32 6b ee			ld (debug_mark),a  
c9d6 3a e5 c9			ld a, (.dmark+1)  
c9d9 32 6c ee			ld (debug_mark+1),a  
c9dc 3a e6 c9			ld a, (.dmark+2)  
c9df 32 6d ee			ld (debug_mark+2),a  
c9e2 18 03			jr .pastdmark  
c9e4 ..			.dmark: db "VAR"  
c9e7 f1			.pastdmark: pop af  
c9e8			endm  
# End of macro DMARK
c9e8						CALLMONITOR 
c9e8 cd 6f ee			call debug_vector  
c9eb				endm  
# End of macro CALLMONITOR
c9eb					endif 
c9eb			 
c9eb					FORTH_DSP_VALUEHL 
c9eb cd 73 9c			call macro_dsp_valuehl 
c9ee				endm 
# End of macro FORTH_DSP_VALUEHL
c9ee			 
c9ee 7e					ld a, (hl)    ; get first char on of the string 
c9ef			 
c9ef			 
c9ef					if DEBUG_FORTH_WORDS 
c9ef						DMARK "VR1" 
c9ef f5				push af  
c9f0 3a 04 ca			ld a, (.dmark)  
c9f3 32 6b ee			ld (debug_mark),a  
c9f6 3a 05 ca			ld a, (.dmark+1)  
c9f9 32 6c ee			ld (debug_mark+1),a  
c9fc 3a 06 ca			ld a, (.dmark+2)  
c9ff 32 6d ee			ld (debug_mark+2),a  
ca02 18 03			jr .pastdmark  
ca04 ..			.dmark: db "VR1"  
ca07 f1			.pastdmark: pop af  
ca08			endm  
# End of macro DMARK
ca08						CALLMONITOR 
ca08 cd 6f ee			call debug_vector  
ca0b				endm  
# End of macro CALLMONITOR
ca0b					endif 
ca0b					 
ca0b f5					push af	 
ca0c					FORTH_DSP_POP 
ca0c cd 2b 9d			call macro_forth_dsp_pop 
ca0f				endm 
# End of macro FORTH_DSP_POP
ca0f f1					pop af 
ca10			 
ca10					; convert to upper 
ca10			 
ca10 cd 5c 8f				call to_upper 
ca13					if DEBUG_FORTH_WORDS 
ca13						DMARK "Vaa" 
ca13 f5				push af  
ca14 3a 28 ca			ld a, (.dmark)  
ca17 32 6b ee			ld (debug_mark),a  
ca1a 3a 29 ca			ld a, (.dmark+1)  
ca1d 32 6c ee			ld (debug_mark+1),a  
ca20 3a 2a ca			ld a, (.dmark+2)  
ca23 32 6d ee			ld (debug_mark+2),a  
ca26 18 03			jr .pastdmark  
ca28 ..			.dmark: db "Vaa"  
ca2b f1			.pastdmark: pop af  
ca2c			endm  
# End of macro DMARK
ca2c						CALLMONITOR 
ca2c cd 6f ee			call debug_vector  
ca2f				endm  
# End of macro CALLMONITOR
ca2f					endif 
ca2f 06 41				ld b, 'A' 
ca31 90					sub b			; set offset 
ca32					if DEBUG_FORTH_WORDS 
ca32						DMARK "Vbb" 
ca32 f5				push af  
ca33 3a 47 ca			ld a, (.dmark)  
ca36 32 6b ee			ld (debug_mark),a  
ca39 3a 48 ca			ld a, (.dmark+1)  
ca3c 32 6c ee			ld (debug_mark+1),a  
ca3f 3a 49 ca			ld a, (.dmark+2)  
ca42 32 6d ee			ld (debug_mark+2),a  
ca45 18 03			jr .pastdmark  
ca47 ..			.dmark: db "Vbb"  
ca4a f1			.pastdmark: pop af  
ca4b			endm  
# End of macro DMARK
ca4b						CALLMONITOR 
ca4b cd 6f ee			call debug_vector  
ca4e				endm  
# End of macro CALLMONITOR
ca4e					endif 
ca4e cb 27				sla a  
ca50				 
ca50					 
ca50					if DEBUG_FORTH_WORDS 
ca50						DMARK "VR2" 
ca50 f5				push af  
ca51 3a 65 ca			ld a, (.dmark)  
ca54 32 6b ee			ld (debug_mark),a  
ca57 3a 66 ca			ld a, (.dmark+1)  
ca5a 32 6c ee			ld (debug_mark+1),a  
ca5d 3a 67 ca			ld a, (.dmark+2)  
ca60 32 6d ee			ld (debug_mark+2),a  
ca63 18 03			jr .pastdmark  
ca65 ..			.dmark: db "VR2"  
ca68 f1			.pastdmark: pop af  
ca69			endm  
# End of macro DMARK
ca69						CALLMONITOR 
ca69 cd 6f ee			call debug_vector  
ca6c				endm  
# End of macro CALLMONITOR
ca6c					endif 
ca6c			 
ca6c 21 f4 e9				ld hl, cli_var_array2 
ca6f cd e7 8c				call addatohl 
ca72 cd 6e 9a				call forth_push_numhl 
ca75			 
ca75			 
ca75				       NEXTW 
ca75 c3 29 9e			jp macro_next 
ca78				endm 
# End of macro NEXTW
ca78			.V0: 
ca78				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca78 78				db WORD_SYS_CORE+100             
ca79 90 ca			dw .V0Q            
ca7b 04				db 3 + 1 
ca7c .. 00			db "V0!",0              
ca80				endm 
# End of macro CWHEAD
ca80			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca80			 
ca80					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca80 cd 73 9c			call macro_dsp_valuehl 
ca83				endm 
# End of macro FORTH_DSP_VALUEHL
ca83			 
ca83 11 28 ea				ld de, cli_var_array 
ca86			 
ca86 eb					ex de, hl 
ca87 73					ld (hl), e 
ca88 23					inc hl 
ca89 72					ld (hl), d 
ca8a			 
ca8a					; destroy value TOS 
ca8a			 
ca8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca8a cd 2b 9d			call macro_forth_dsp_pop 
ca8d				endm 
# End of macro FORTH_DSP_POP
ca8d			 
ca8d				       NEXTW 
ca8d c3 29 9e			jp macro_next 
ca90				endm 
# End of macro NEXTW
ca90			.V0Q: 
ca90				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ca90 79				db WORD_SYS_CORE+101             
ca91 a1 ca			dw .V1S            
ca93 04				db 3 + 1 
ca94 .. 00			db "V0@",0              
ca98				endm 
# End of macro CWHEAD
ca98			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ca98 2a 28 ea				ld hl, (cli_var_array) 
ca9b cd 6e 9a				call forth_push_numhl 
ca9e			 
ca9e				       NEXTW 
ca9e c3 29 9e			jp macro_next 
caa1				endm 
# End of macro NEXTW
caa1			.V1S: 
caa1				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
caa1 7a				db WORD_SYS_CORE+102             
caa2 b9 ca			dw .V1Q            
caa4 04				db 3 + 1 
caa5 .. 00			db "V1!",0              
caa9				endm 
# End of macro CWHEAD
caa9			;| V1! ( u1 -- )  Store value to v1 | DONE 
caa9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
caa9 cd 73 9c			call macro_dsp_valuehl 
caac				endm 
# End of macro FORTH_DSP_VALUEHL
caac			 
caac 11 2a ea				ld de, cli_var_array+2 
caaf				 
caaf eb					ex de, hl 
cab0 73					ld (hl), e 
cab1 23					inc hl 
cab2 72					ld (hl), d 
cab3			 
cab3					; destroy value TOS 
cab3			 
cab3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cab3 cd 2b 9d			call macro_forth_dsp_pop 
cab6				endm 
# End of macro FORTH_DSP_POP
cab6				       NEXTW 
cab6 c3 29 9e			jp macro_next 
cab9				endm 
# End of macro NEXTW
cab9			.V1Q: 
cab9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cab9 7b				db WORD_SYS_CORE+103             
caba ca ca			dw .V2S            
cabc 04				db 3 + 1 
cabd .. 00			db "V1@",0              
cac1				endm 
# End of macro CWHEAD
cac1			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cac1 2a 2a ea				ld hl, (cli_var_array+2) 
cac4 cd 6e 9a				call forth_push_numhl 
cac7				       NEXTW 
cac7 c3 29 9e			jp macro_next 
caca				endm 
# End of macro NEXTW
caca			.V2S: 
caca				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
caca 7c				db WORD_SYS_CORE+104             
cacb e2 ca			dw .V2Q            
cacd 04				db 3 + 1 
cace .. 00			db "V2!",0              
cad2				endm 
# End of macro CWHEAD
cad2			;| V2! ( u1 -- )  Store value to v2 | DONE 
cad2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cad2 cd 73 9c			call macro_dsp_valuehl 
cad5				endm 
# End of macro FORTH_DSP_VALUEHL
cad5			 
cad5 11 2c ea				ld de, cli_var_array+4 
cad8				 
cad8 eb					ex de, hl 
cad9 73					ld (hl), e 
cada 23					inc hl 
cadb 72					ld (hl), d 
cadc			 
cadc					; destroy value TOS 
cadc			 
cadc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cadc cd 2b 9d			call macro_forth_dsp_pop 
cadf				endm 
# End of macro FORTH_DSP_POP
cadf				       NEXTW 
cadf c3 29 9e			jp macro_next 
cae2				endm 
# End of macro NEXTW
cae2			.V2Q: 
cae2				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cae2 7d				db WORD_SYS_CORE+105             
cae3 f3 ca			dw .V3S            
cae5 04				db 3 + 1 
cae6 .. 00			db "V2@",0              
caea				endm 
# End of macro CWHEAD
caea			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
caea 2a 2c ea				ld hl, (cli_var_array+4) 
caed cd 6e 9a				call forth_push_numhl 
caf0				       NEXTW 
caf0 c3 29 9e			jp macro_next 
caf3				endm 
# End of macro NEXTW
caf3			.V3S: 
caf3				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
caf3 7c				db WORD_SYS_CORE+104             
caf4 0b cb			dw .V3Q            
caf6 04				db 3 + 1 
caf7 .. 00			db "V3!",0              
cafb				endm 
# End of macro CWHEAD
cafb			;| V3! ( u1 -- )  Store value to v3 | DONE 
cafb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cafb cd 73 9c			call macro_dsp_valuehl 
cafe				endm 
# End of macro FORTH_DSP_VALUEHL
cafe			 
cafe 11 2e ea				ld de, cli_var_array+6 
cb01				 
cb01 eb					ex de, hl 
cb02 73					ld (hl), e 
cb03 23					inc hl 
cb04 72					ld (hl), d 
cb05			 
cb05					; destroy value TOS 
cb05			 
cb05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb05 cd 2b 9d			call macro_forth_dsp_pop 
cb08				endm 
# End of macro FORTH_DSP_POP
cb08				       NEXTW 
cb08 c3 29 9e			jp macro_next 
cb0b				endm 
# End of macro NEXTW
cb0b			.V3Q: 
cb0b				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb0b 7d				db WORD_SYS_CORE+105             
cb0c 1c cb			dw .END            
cb0e 04				db 3 + 1 
cb0f .. 00			db "V3@",0              
cb13				endm 
# End of macro CWHEAD
cb13			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb13 2a 2e ea				ld hl, (cli_var_array+6) 
cb16 cd 6e 9a				call forth_push_numhl 
cb19				       NEXTW 
cb19 c3 29 9e			jp macro_next 
cb1c				endm 
# End of macro NEXTW
cb1c			 
cb1c			 
cb1c			 
cb1c			 
cb1c			 
cb1c			; end of dict marker 
cb1c			 
cb1c 00			.END:    db WORD_SYS_END 
cb1d 00 00			dw 0 
cb1f 00				db 0 
cb20			 
cb20			; use to jp here for user dict words to save on macro expansion  
cb20			 
cb20			user_dict_next: 
cb20				NEXTW 
cb20 c3 29 9e			jp macro_next 
cb23				endm 
# End of macro NEXTW
cb23			 
cb23			 
cb23			user_exec: 
cb23				;    ld hl, <word code> 
cb23				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb23				;    call forthexec 
cb23				;    jp user_dict_next   (NEXT) 
cb23			        ;    <word code bytes> 
cb23 eb				ex de, hl 
cb24 2a c2 e5			ld hl,(os_tok_ptr) 
cb27				 
cb27				FORTH_RSP_NEXT 
cb27 cd 15 9a			call macro_forth_rsp_next 
cb2a				endm 
# End of macro FORTH_RSP_NEXT
cb2a			 
cb2a			if DEBUG_FORTH_UWORD 
cb2a						DMARK "UEX" 
cb2a f5				push af  
cb2b 3a 3f cb			ld a, (.dmark)  
cb2e 32 6b ee			ld (debug_mark),a  
cb31 3a 40 cb			ld a, (.dmark+1)  
cb34 32 6c ee			ld (debug_mark+1),a  
cb37 3a 41 cb			ld a, (.dmark+2)  
cb3a 32 6d ee			ld (debug_mark+2),a  
cb3d 18 03			jr .pastdmark  
cb3f ..			.dmark: db "UEX"  
cb42 f1			.pastdmark: pop af  
cb43			endm  
# End of macro DMARK
cb43				CALLMONITOR 
cb43 cd 6f ee			call debug_vector  
cb46				endm  
# End of macro CALLMONITOR
cb46			endif 
cb46			 
cb46			 
cb46			 
cb46 eb				ex de, hl 
cb47 22 c2 e5			ld (os_tok_ptr), hl 
cb4a				 
cb4a				; Don't use next - Skips the first word in uword. 
cb4a			 
cb4a c3 ba 9e			jp exec1 
cb4d			;	NEXT 
cb4d			 
cb4d			 
cb4d			; eof 
# End of file forth_wordsv4.asm
cb4d			endif 
cb4d			;;;;;;;;;;;;;; Debug code 
cb4d			 
cb4d			 
cb4d			;if DEBUG_FORTH_PARSE 
cb4d .. 00		.nowordfound: db "No match",0 
cb56 .. 00		.compword:	db "Comparing word ",0 
cb66 .. 00		.nextwordat:	db "Next word at",0 
cb73 .. 00		.charmatch:	db "Char match",0 
cb7e			;endif 
cb7e			if DEBUG_FORTH_JP 
cb7e			.foundword:	db "Word match. Exec..",0 
cb7e			endif 
cb7e			;if DEBUG_FORTH_PUSH 
cb7e .. 00		.enddict:	db "Dict end. Push.",0 
cb8e .. 00		.push_str:	db "Pushing string",0 
cb9d .. 00		.push_num:	db "Pushing number",0 
cbac .. 00		.data_sp:	db "SP:",0 
cbb0 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbc2 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cbd4 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbe6			;endif 
cbe6			;if DEBUG_FORTH_MALLOC 
cbe6 .. 00		.push_malloc:	db "Malloc address",0 
cbf5			;endif 
cbf5			 
cbf5			 
cbf5			 
cbf5			; display malloc address and current data stack pointer  
cbf5			 
cbf5			malloc_error: 
cbf5 d5				push de 
cbf6 f5				push af 
cbf7 e5				push hl 
cbf8 cd ba 8a			call clear_display 
cbfb 11 1b cc			ld de, .mallocerr 
cbfe 3e 00			ld a,0 
cc00			;	ld de,os_word_scratch 
cc00 cd cd 8a			call str_at_display 
cc03 3e 11			ld a, display_row_1+17 
cc05 11 6b ee			ld de, debug_mark 
cc08 cd cd 8a			call str_at_display 
cc0b cd dd 8a			call update_display 
cc0e				;call break_point_state 
cc0e cd 1d dd			call cin_wait 
cc11			 
cc11			;	ld a, ' ' 
cc11			;	ld (os_view_disable), a 
cc11 cd f1 93			call bp_on 
cc14 e1				pop hl 
cc15 f1				pop af 
cc16 d1				pop de	 
cc17				CALLMONITOR 
cc17 cd 6f ee			call debug_vector  
cc1a				endm  
# End of macro CALLMONITOR
cc1a c9				ret 
cc1b			 
cc1b .. 00		.mallocerr: 	db "Malloc Error",0 
cc28			;if DEBUG_FORTH_PUSH 
cc28			display_data_sp: 
cc28 f5				push af 
cc29			 
cc29				; see if disabled 
cc29			 
cc29			 
cc29 3a 6f ee			ld a, (debug_vector) 
cc2c fe c9			cp $C9  ; RET 
cc2e				;ld a, (os_view_disable) 
cc2e				;cp '*' 
cc2e 28 67			jr z, .skipdsp 
cc30			 
cc30 e5				push hl 
cc31 e5				push hl 
cc32 e5			push hl 
cc33 cd ba 8a			call clear_display 
cc36 e1			pop hl 
cc37 7c				ld a,h 
cc38 21 c6 e5			ld hl, os_word_scratch 
cc3b cd f0 8e			call hexout 
cc3e e1				pop hl 
cc3f 7d				ld a,l 
cc40 21 c8 e5			ld hl, os_word_scratch+2 
cc43 cd f0 8e			call hexout 
cc46 21 ca e5			ld hl, os_word_scratch+4 
cc49 3e 00			ld a,0 
cc4b 77				ld (hl),a 
cc4c 11 c6 e5			ld de,os_word_scratch 
cc4f 3e 28				ld a, display_row_2 
cc51 cd cd 8a				call str_at_display 
cc54 11 b0 cb			ld de, .wordinhl 
cc57 3e 00			ld a, display_row_1 
cc59			 
cc59 cd cd 8a				call str_at_display 
cc5c 11 6b ee			ld de, debug_mark 
cc5f 3e 11			ld a, display_row_1+17 
cc61			 
cc61 cd cd 8a				call str_at_display 
cc64			 
cc64				; display current data stack pointer 
cc64 11 ac cb			ld de,.data_sp 
cc67 3e 30				ld a, display_row_2 + 8 
cc69 cd cd 8a				call str_at_display 
cc6c			 
cc6c 2a ee e9			ld hl,(cli_data_sp) 
cc6f e5				push hl 
cc70 7c				ld a,h 
cc71 21 c6 e5			ld hl, os_word_scratch 
cc74 cd f0 8e			call hexout 
cc77 e1				pop hl 
cc78 7d				ld a,l 
cc79 21 c8 e5			ld hl, os_word_scratch+2 
cc7c cd f0 8e			call hexout 
cc7f 21 ca e5			ld hl, os_word_scratch+4 
cc82 3e 00			ld a,0 
cc84 77				ld (hl),a 
cc85 11 c6 e5			ld de,os_word_scratch 
cc88 3e 33				ld a, display_row_2 + 11 
cc8a cd cd 8a				call str_at_display 
cc8d			 
cc8d			 
cc8d cd dd 8a			call update_display 
cc90 cd fd 89			call delay1s 
cc93 cd fd 89			call delay1s 
cc96 e1				pop hl 
cc97			.skipdsp: 
cc97 f1				pop af 
cc98 c9				ret 
cc99			 
cc99			display_data_malloc: 
cc99			 
cc99 f5				push af 
cc9a e5				push hl 
cc9b e5				push hl 
cc9c e5			push hl 
cc9d cd ba 8a			call clear_display 
cca0 e1			pop hl 
cca1 7c				ld a,h 
cca2 21 c6 e5			ld hl, os_word_scratch 
cca5 cd f0 8e			call hexout 
cca8 e1				pop hl 
cca9 7d				ld a,l 
ccaa 21 c8 e5			ld hl, os_word_scratch+2 
ccad cd f0 8e			call hexout 
ccb0 21 ca e5			ld hl, os_word_scratch+4 
ccb3 3e 00			ld a,0 
ccb5 77				ld (hl),a 
ccb6 11 c6 e5			ld de,os_word_scratch 
ccb9 3e 28				ld a, display_row_2 
ccbb cd cd 8a				call str_at_display 
ccbe 11 e6 cb			ld de, .push_malloc 
ccc1 3e 00			ld a, display_row_1 
ccc3			 
ccc3 cd cd 8a				call str_at_display 
ccc6			 
ccc6				; display current data stack pointer 
ccc6 11 ac cb			ld de,.data_sp 
ccc9 3e 30				ld a, display_row_2 + 8 
cccb cd cd 8a				call str_at_display 
ccce			 
ccce 2a ee e9			ld hl,(cli_data_sp) 
ccd1 e5				push hl 
ccd2 7c				ld a,h 
ccd3 21 c6 e5			ld hl, os_word_scratch 
ccd6 cd f0 8e			call hexout 
ccd9 e1				pop hl 
ccda 7d				ld a,l 
ccdb 21 c8 e5			ld hl, os_word_scratch+2 
ccde cd f0 8e			call hexout 
cce1 21 ca e5			ld hl, os_word_scratch+4 
cce4 3e 00			ld a,0 
cce6 77				ld (hl),a 
cce7 11 c6 e5			ld de,os_word_scratch 
ccea 3e 33				ld a, display_row_2 + 11 
ccec cd cd 8a				call str_at_display 
ccef			 
ccef cd dd 8a			call update_display 
ccf2 cd fd 89			call delay1s 
ccf5 cd fd 89			call delay1s 
ccf8 e1				pop hl 
ccf9 f1				pop af 
ccfa c9				ret 
ccfb			;endif 
ccfb			 
ccfb			include "forth_autostart.asm" 
ccfb			; list of commands to perform at system start up 
ccfb			 
ccfb			startcmds: 
ccfb			;	dw test11 
ccfb			;	dw test12 
ccfb			;	dw test13 
ccfb			;	dw test14 
ccfb			;	dw test15 
ccfb			;	dw test16 
ccfb			;	dw test17 
ccfb			;	dw ifthtest1 
ccfb			;	dw ifthtest2 
ccfb			;	dw ifthtest3 
ccfb			;	dw mmtest1 
ccfb			;	dw mmtest2 
ccfb			;	dw mmtest3 
ccfb			;	dw mmtest4 
ccfb			;	dw mmtest5 
ccfb			;	dw mmtest6 
ccfb			;	dw iftest1 
ccfb			;	dw iftest2 
ccfb			;	dw iftest3 
ccfb			;	dw looptest1 
ccfb			;	dw looptest2 
ccfb			;	dw test1 
ccfb			;	dw test2 
ccfb			;	dw test3 
ccfb			;	dw test4 
ccfb			;	dw game2r 
ccfb			;	dw game2b1 
ccfb			;	dw game2b2 
ccfb			 
ccfb				; start up words that are actually useful 
ccfb			 
ccfb			;    dw spi1 
ccfb			;    dw spi2 
ccfb			;    dw spi3 
ccfb			;    dw spi4 
ccfb			;    dw spi5 
ccfb			;    dw spi6 
ccfb			;    dw spi7 
ccfb			; 
ccfb			;    dw spi8 
ccfb			;    dw spi9 
ccfb			;    dw spi10 
ccfb			 
ccfb			; file editor 
ccfb			;	dw edit1 
ccfb			;	dw edit2 
ccfb			;	dw edit3 
ccfb			 
ccfb			;	dw longread 
ccfb 1b d1			dw clrstack 
ccfd 4f d1			dw type 
ccff			;	dw stest 
ccff 74 d1			dw strncpy 
cd01			;	dw list 
cd01 d5 d1			dw start1 
cd03 e5 d1			dw start2 
cd05			;	dw start3 
cd05			;	dw start3b 
cd05			;	dw start3c 
cd05			 
cd05				; (unit) testing words 
cd05			 
cd05			;	dw mtesta 
cd05			;	dw mtestb 
cd05			;	dw mtestc 
cd05			;	dw mtestd 
cd05			;	dw mteste 
cd05			 
cd05				; demo/game words 
cd05			 
cd05			;        dw game3w 
cd05			;        dw game3p 
cd05			;        dw game3sc 
cd05			;        dw game3vsi 
cd05			;        dw game3vs 
cd05				 
cd05			;	dw game2b 
cd05			;	dw game2bf 
cd05			;	dw game2mba 
cd05			;	dw game2mbas 
cd05			;	dw game2mb 
cd05			 
cd05 02 d5			dw game1 
cd07 13 d5			dw game1a 
cd09 75 d5			dw game1b 
cd0b aa d5			dw game1c 
cd0d e0 d5			dw game1d 
cd0f 11 d6			dw game1s 
cd11 25 d6			dw game1t 
cd13 3a d6			dw game1f 
cd15 6e d6			dw game1z 
cd17 b2 d6			dw game1zz 
cd19			 
cd19 3b d3			dw test5 
cd1b 73 d3			dw test6 
cd1d ab d3			dw test7 
cd1f bf d3			dw test8 
cd21 eb d3			dw test9 
cd23 01 d4			dw test10 
cd25				 
cd25 89 d7		        dw ssv5 
cd27 6d d7		        dw ssv4 
cd29 51 d7		        dw ssv3 
cd2b 1b d7		        dw ssv2 
cd2d a2 d7		        dw ssv1 
cd2f ea d7		        dw ssv1cpm 
cd31			;	dw keyup 
cd31			;	dw keydown 
cd31			;	dw keyleft 
cd31			;	dw keyright 
cd31			;	dw 	keyf1 
cd31			;	dw keyf2 
cd31			;	dw keyf3 
cd31			;	dw keyf4 
cd31			;	dw keyf5 
cd31			;	dw keyf6 
cd31			;	dw keyf7 
cd31			;	dw keyf8 
cd31			;	dw keyf9 
cd31			;	dw keyf10 
cd31			;	dw keyf11 
cd31			;	dw keyf12 
cd31			;	dw keytab 
cd31			;	dw keycr 
cd31			;	dw keyhome 
cd31			;	dw keyend 
cd31			;	dw keybs 
cd31 00 00			db 0, 0	 
cd33			 
cd33			 
cd33			; File Editor 
cd33			 
cd33			; ( id - ) use 'e' to edit the displayed line 
cd33 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd54 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd89			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd89 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cdc1			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cdc1			 
cdc1			; SPI Net support words 
cdc1			 
cdc1			; v0! = node to send to 
cdc1			; ( str count - ) 
cdc1 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce1a			 
ce1a			; spiputc ( char node - ) 
ce1a .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce4e			; spiputc ( u node - ) 
ce4e .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
ce7c			 
ce7c			; spigetc ( - n ) 
ce7c .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
cea5			 
cea5			; getnode ( - n ) 
cea5 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
ced2			 
ced2			; ( str node - )  
ced2 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf38			; store string ( str i - ) 
cf38			 
cf38			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf38 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cf8d			 
cf8d			; get string ( addr i -  )    TO FIX 
cf8d			 
cf8d .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cfe5			 
cfe5			 
cfe5			; NETCHAT (TODO) 
cfe5			; Program to allow two nodes to chat with eachother 
cfe5			; 
cfe5			; v0 - target node 
cfe5			;  
cfe5			; accept input at 0,0 
cfe5			; if input is string send spitype to target node 
cfe5			; starting at row 2,0 , while spigetchr is not zero ->  
cfe5			; 
cfe5			; 
cfe5			; TODO add paging of get request 
cfe5			 
cfe5			; ( node - ) 
cfe5 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d004 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d05c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0d4			 
d0d4			 
d0d4			; Long read of currently open file 
d0d4 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d11b			 
d11b			; clear stack  
d11b			 
d11b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d14f			 
d14f			; type ( addr count - ) 
d14f .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d174			 
d174			; some direct memory words 
d174			; strncpy ( len t f -- t ) 
d174			 
d174 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1d5			 
d1d5 .. 00		start1:     	db ": bpon $00 bp ;",0 
d1e5 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d1f6 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d271 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2d1			 
d2d1			 
d2d1			; a handy word to list items on the stack 
d2d1			 
d2d1 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d33b			 
d33b			 
d33b			; test stack  
d33b			; rnd8 stest 
d33b			 
d33b			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d33b			 
d33b			; random malloc and free cycles 
d33b			 
d33b			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d33b			 
d33b			; fixed malloc and free cycles 
d33b			 
d33b			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d33b			 
d33b			; fixed double string push and drop cycle  
d33b			 
d33b			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d33b			 
d33b			; consistent fixed string push and drop cycle  
d33b			 
d33b			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d33b			 
d33b			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d33b			 
d33b			;test1:		db ": aa 1 2 3 ;", 0 
d33b			;test2:     	db "111 aa 888 999",0 
d33b			;test3:     	db ": bb 77 ;",0 
d33b			;test4:     	db "$02 $01 do i . loop bb",0 
d33b			 
d33b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d373 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d3ab .. 00		test7:     	db ": box hline vline ;",0 
d3bf .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d3eb .. 00		test9:     	db ": sw $01 adsp world ;",0 
d401 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d426			;test11:     	db "hello create .",0 
d426			;test12:     	db "hello2 create .",0 
d426			 
d426			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d426			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d426			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d426			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d426			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d426			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d426			 
d426			;iftest1:     	db "$0001 IF cls .",0 
d426			;iftest2:     	db "$0000 IF cls .",0 
d426			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d426			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d426			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d426			 
d426			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d426			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d426			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d426			 
d426			 
d426 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d44a .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d47a .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d49f .. 00		sound4: db ": cha $00 ; ",0 
d4ac .. 00		sound5: db ": chb $20 ; ",0 
d4b9 .. 00		sound6: db ": chc $40 ; ",0 
d4c6 .. 00		sound7: db ": chd $60 ; ",0 
d4d3 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d4eb .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d502			 
d502			 
d502			 
d502			 
d502			; a small guess the number game 
d502			 
d502 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d513 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d575			 
d575 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d5aa .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d5e0 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d611 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d625 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d63a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d66e .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d6b2			 
d6b2			; Using 'ga' save a high score across multiple runs using external storage 
d6b2			 
d6b2 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d71b			 
d71b			 
d71b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d71b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d71b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d71b			 
d71b			; simple screen saver to test code memory reuse to destruction 
d71b			 
d71b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d751 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d76d .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d789 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d7a2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d7ea .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d841			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d841			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d841			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d841			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d841			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d841			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d841			 
d841			 
d841			 
d841			; minesweeper/battleship finding game 
d841			; draws a game board of random ship/mine positions 
d841			; user enters coords to see if it hits on 
d841			; game ends when all are hit 
d841			; when hit or miss says how many may be in the area 
d841			 
d841			; setup the game board and then hide it 
d841			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d841			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d841			;; prompt for where to target 
d841			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d841			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d841			;; TODO see if the entered coords hits or misses pushes char hit of miss 
d841			;game2mbht:      db ": mbckht nop ;",0 
d841			;game2mbms:      db ": mbcms nop ;",0 
d841			; TODO how many might be near by 
d841			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d841			 
d841			; Game 3 
d841			 
d841			; Vert scroller ski game - avoid the trees! 
d841			 
d841			; v0 score (ie turns) 
d841			; v1 player pos 
d841			; v2 left wall 
d841			; v3 right wall 
d841			 
d841			; Draw side walls randomly 
d841			 
d841			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d841			 
d841			; Draw player 
d841			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d841			 
d841			; TODO Get Key 
d841			 
d841			; TODO Move left right 
d841			 
d841			; scroll and move walls a bit 
d841			 
d841			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d841			 
d841			; main game loop 
d841			 
d841			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d841			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d841			 
d841			; key board defs 
d841			 
d841 .. 00		keyup:       db ": keyup $05 ;",0 
d84f .. 00		keydown:       db ": keydown $0a ;",0 
d85f .. 00		keyleft:       db ": keyleft $0b ;",0 
d86f .. 00		keyright:       db ": keyright $0c ;",0 
d880 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d88e .. 00		keyf2:       db ": keyf2 $11 ;",0 
d89c .. 00		keyf3:       db ": keyf3 $12 ;",0 
d8aa .. 00		keyf4:       db ": keyf4 $13 ;",0 
d8b8 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d8c6 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d8d4 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d8e2 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d8f0 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d8fe .. 00		keyf10:       db ": keyf10 $19 ;",0 
d90d .. 00		keyf11:       db ": keyf11 $1a ;",0 
d91c .. 00		keyf12:       db ": keyf12 $1b ;",0 
d92b			 
d92b .. 00		keytab:       db ": keytab $09 ;",0 
d93a .. 00		keycr:       db ": keycr $0d ;",0 
d948 .. 00		keyhome:       db ": keyhome $0e ;",0 
d958 .. 00		keyend:       db ": keyend $0f ;",0 
d967 .. 00		keybs:       db ": keybs $08 ;",0 
d975			 
d975			   
d975			 
d975			 
d975			 
d975			; eof 
# End of file forth_autostart.asm
d975			 
d975			 
d975			 
d975			; stack over and underflow checks 
d975			 
d975			; init the words to detect the under/overflow 
d975			 
d975			chk_stk_init: 
d975				; a vague random number to check so we dont get any "lucky" hits 
d975 3e 2d			ld a, 45 
d977 6f				ld l, a 
d978 00				nop 
d979 3e 17			ld a, 23 
d97b 67				ld h, a 
d97c			 
d97c 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
d97f			 
d97f			;	ld (chk_stund), hl	; stack points.... 
d97f 22 00 ef			ld (chk_stovr), hl 
d982 22 ec e9			ld (chk_ret_und), hl 
d985 22 aa e9			ld (chk_ret_ovr), hl 
d988 22 28 e9			ld (chk_loop_ovr), hl 
d98b 22 26 e8			ld (chk_data_ovr), hl 
d98e c9				ret 
d98f				 
d98f			check_stacks: 
d98f				; check all stack words 
d98f			 
d98f e5				push hl 
d990 d5				push de 
d991			 
d991			;	ld de,(chk_word) 
d991			;	ld hl, (chk_stund)	; stack points.... 
d991			;	if DEBUG_STK_FAULT 
d991			;		DMARK "FAa" 
d991			;		CALLMONITOR 
d991			;	endif 
d991			;	call cmp16 
d991			;	jp z, .chk_faulta 
d991			; 
d991			;	ld de, sfaultsu 
d991			;	jp .chk_fault 
d991			 
d991 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d994 ed 5b 9d e2		ld de,(chk_word) 
d998				if DEBUG_STK_FAULT 
d998					DMARK "FAb" 
d998					CALLMONITOR 
d998				endif 
d998 cd 05 8d			call cmp16 
d99b 28 06			jr z, .chk_fault1 
d99d 11 41 da			ld de, sfaultso 
d9a0 c3 f2 d9			jp .chk_fault 
d9a3			.chk_fault1:  
d9a3 2a ec e9			ld hl, (chk_ret_und) 
d9a6 ed 5b 9d e2		ld de,(chk_word) 
d9aa				if DEBUG_STK_FAULT 
d9aa					DMARK "FAU" 
d9aa					CALLMONITOR 
d9aa				endif 
d9aa cd 05 8d			call cmp16 
d9ad ca b6 d9			jp z, .chk_fault2 
d9b0 11 51 da			ld de, sfaultru 
d9b3 c3 f2 d9			jp .chk_fault 
d9b6			.chk_fault2:  
d9b6 2a aa e9			ld hl, (chk_ret_ovr) 
d9b9 ed 5b 9d e2		ld de,(chk_word) 
d9bd				if DEBUG_STK_FAULT 
d9bd					DMARK "FA1" 
d9bd					CALLMONITOR 
d9bd				endif 
d9bd cd 05 8d			call cmp16 
d9c0 ca c9 d9			jp z, .chk_fault3 
d9c3 11 5f da			ld de, sfaultro 
d9c6 c3 f2 d9			jp .chk_fault 
d9c9			.chk_fault3:  
d9c9 2a 28 e9			ld hl, (chk_loop_ovr) 
d9cc ed 5b 9d e2		ld de,(chk_word) 
d9d0				if DEBUG_STK_FAULT 
d9d0					DMARK "FA2" 
d9d0					CALLMONITOR 
d9d0				endif 
d9d0 cd 05 8d			call cmp16 
d9d3 ca dc d9			jp z, .chk_fault4 
d9d6 11 79 da			ld de, sfaultlo 
d9d9 c3 f2 d9			jp .chk_fault 
d9dc			.chk_fault4:  
d9dc 2a 26 e8			ld hl, (chk_data_ovr) 
d9df ed 5b 9d e2		ld de,(chk_word) 
d9e3				if DEBUG_STK_FAULT 
d9e3					DMARK "FA3" 
d9e3					CALLMONITOR 
d9e3				endif 
d9e3 cd 05 8d			call cmp16 
d9e6 ca ef d9			jp z, .chk_fault5 
d9e9 11 93 da			ld de, sfaultdo 
d9ec c3 f2 d9			jp .chk_fault 
d9ef			 
d9ef			 
d9ef			.chk_fault5:  
d9ef d1				pop de 
d9f0 e1				pop hl 
d9f1			 
d9f1 c9				ret 
d9f2			 
d9f2 cd ba 8a		.chk_fault: 	call clear_display 
d9f5 3e 28				ld a, display_row_2 
d9f7 cd cd 8a				call str_at_display 
d9fa 11 23 da				   ld de, .stackfault 
d9fd 3e 00				ld a, display_row_1 
d9ff cd cd 8a				call str_at_display 
da02 11 6b ee				    ld de, debug_mark 
da05 3e 11				ld a, display_row_1+17 
da07 cd cd 8a				call str_at_display 
da0a cd dd 8a				call update_display 
da0d			 
da0d				; prompt before entering montior for investigating issue 
da0d			 
da0d 3e 78			ld a, display_row_4 
da0f 11 60 97			ld de, endprog 
da12			 
da12 cd dd 8a			call update_display		 
da15			 
da15 cd e6 99			call next_page_prompt 
da18			 
da18 d1				pop de 
da19 e1				pop hl 
da1a cd b4 97				call monitor 
da1d cd cf 9d				call forth_warmstart 
da20 c3 b0 96				jp warmstart_afterauto 
da23					;jp 0 
da23					;halt 
da23			 
da23			 
da23			 
da23 .. 00		.stackfault: 	db "Stack fault:",0 
da30			 
da30 .. 00		sfaultsu: 	db	"Stack under flow",0 
da41 .. 00		sfaultso: 	db	"Stack over flow",0 
da51 .. 00		sfaultru:	db "RTS underflow",0 
da5f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
da79 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
da93 .. 00		sfaultdo:	db "DTS overflow", 0 
daa0			 
daa0			 
daa0			fault_dsp_under: 
daa0 11 b2 da			ld de, .dsp_under 
daa3 c3 68 db			jp .show_fault 
daa6			 
daa6			fault_rsp_under: 
daa6 11 c0 da			ld de, .rsp_under 
daa9 c3 68 db			jp .show_fault 
daac			fault_loop_under: 
daac 11 ce da			ld de, .loop_under 
daaf c3 68 db			jp .show_fault 
dab2			 
dab2 .. 00		.dsp_under: db "DSP Underflow",0 
dac0 .. 00		.rsp_under: db "RSP Underflow",0 
dace .. 00		.loop_under: db "LOOP Underflow",0 
dadd			 
dadd			 
dadd d5			type_faultn: 	push de 
dade e5					push hl 
dadf cd ba 8a				call clear_display 
dae2 11 0c db				   ld de, .typefaultn 
dae5 3e 00				ld a, display_row_1 
dae7 cd cd 8a				call str_at_display 
daea 11 6b ee				    ld de, debug_mark 
daed 3e 11				ld a, display_row_1+17 
daef cd cd 8a				call str_at_display 
daf2 cd dd 8a				call update_display 
daf5			 
daf5				; prompt before entering montior for investigating issue 
daf5			 
daf5 3e 78			ld a, display_row_4 
daf7 11 60 97			ld de, endprog 
dafa			 
dafa cd dd 8a			call update_display		 
dafd			 
dafd cd e6 99			call next_page_prompt 
db00			 
db00 e5					push hl 
db01 d5					push de 
db02 cd b4 97				call monitor 
db05 cd cf 9d				call forth_warmstart 
db08 c3 b0 96				jp warmstart_afterauto 
db0b 76					halt 
db0c			 
db0c			 
db0c .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
db23			 
db23 d5			type_faults: 	push de 
db24 e5					push hl 
db25 cd ba 8a				call clear_display 
db28 11 51 db				   ld de, .typefaults 
db2b 3e 00				ld a, display_row_1 
db2d cd cd 8a				call str_at_display 
db30 11 6b ee				    ld de, debug_mark 
db33 3e 11				ld a, display_row_1+17 
db35 cd cd 8a				call str_at_display 
db38 cd dd 8a				call update_display 
db3b			 
db3b				; prompt before entering montior for investigating issue 
db3b			 
db3b 3e 78			ld a, display_row_4 
db3d 11 60 97			ld de, endprog 
db40			 
db40 cd dd 8a			call update_display		 
db43			 
db43 cd e6 99			call next_page_prompt 
db46			 
db46 e1					pop hl 
db47 d1					pop de 
db48 cd b4 97				call monitor 
db4b cd cf 9d				call forth_warmstart 
db4e c3 b0 96				jp warmstart_afterauto 
db51			 
db51			 
db51 .. 00		.typefaults: db "STR Type Expected TOS!",0 
db68			 
db68			.show_fault: 	 
db68 d5					push de 
db69 cd ba 8a				call clear_display 
db6c d1					pop de 
db6d 3e 00				ld a, display_row_1 
db6f cd cd 8a				call str_at_display 
db72 11 6b ee				    ld de, debug_mark 
db75 3e 11				ld a, display_row_1+17 
db77 cd cd 8a				call str_at_display 
db7a cd dd 8a				call update_display 
db7d			 
db7d				; prompt before entering montior for investigating issue 
db7d			 
db7d 3e 78			ld a, display_row_4 
db7f 11 60 97			ld de, endprog 
db82			 
db82 cd dd 8a			call update_display		 
db85			 
db85 cd e6 99			call next_page_prompt 
db88			 
db88 e1					pop hl 
db89 d1					pop de 
db8a cd b4 97				call monitor 
db8d			; do a dump to cli and not warmstart so we preserve all of the uwords.  
db8d			; TODO Make optional fault restart to cli or warm boot? 
db8d					;jp warmstart 
db8d c3 f4 96				jp cli 
db90 76					halt 
db91			 
db91			; handle the auto run of code from files in storage 
db91			 
db91			 
db91			include "forth_startup.asm" 
db91			; Which startup method to use? 
db91			; 
db91			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
db91			; followed by loading of a list of scripts in eeprom 
db91			 
db91			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
db91			; from eeprom 
db91			 
db91			; Select with define in main stubs 
db91			 
db91			if STARTUP_V1 
db91				include "forth_startupv1.asm" 
db91			; Startup script loading version 1 
db91			 
db91			; If SE storage is available first stage is to use the selected file 
db91			; then go through the eeprom list 
db91			 
db91 .. 00		sprompt1: db "Startup load...",0 
dba1 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
dbb7			 
dbb7			 
dbb7			 
dbb7			 
dbb7			forth_startup: 
dbb7 21 fb cc			ld hl, startcmds 
dbba 3e 00			ld a, 0 
dbbc 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
dbbf			 
dbbf e5			.start1:	push hl 
dbc0 cd ba 8a			call clear_display 
dbc3 11 91 db			ld de, sprompt1 
dbc6 3e 00		        ld a, display_row_1 
dbc8 cd cd 8a			call str_at_display 
dbcb 11 a1 db			ld de, sprompt2 
dbce 3e 28		        ld a, display_row_2 
dbd0 cd cd 8a			call str_at_display 
dbd3 e1				pop hl 
dbd4 e5				push hl 
dbd5 5e				ld e,(hl) 
dbd6 23				inc hl 
dbd7 56				ld d,(hl) 
dbd8 3e 50		        ld a, display_row_3 
dbda cd cd 8a			call str_at_display 
dbdd cd dd 8a			call update_display 
dbe0			 
dbe0			 
dbe0 3a e7 e6			ld a, (os_last_cmd) 
dbe3 fe 00			cp 0 
dbe5 28 05			jr z, .startprompt 
dbe7 cd f1 89			call delay250ms 
dbea 18 24			jr .startdo 
dbec				 
dbec				 
dbec			 
dbec			.startprompt: 
dbec			 
dbec 3e 9f			ld a,display_row_4 + display_cols - 1 
dbee 11 e4 99		        ld de, endprg 
dbf1 cd cd 8a			call str_at_display 
dbf4 cd dd 8a			call update_display 
dbf7 cd fd 89			call delay1s 
dbfa cd 1d dd			call cin_wait 
dbfd						 
dbfd fe 2a			cp '*' 
dbff 28 5e			jr z, .startupend1 
dc01 fe 23			cp '#' 
dc03 20 07			jr nz, .startno 
dc05 3e 01			ld a, 1 
dc07 32 e7 e6			ld (os_last_cmd),a 
dc0a 18 04			jr .startdo 
dc0c fe 31		.startno:	cp '1' 
dc0e 28 3a			jr z,.startnxt  
dc10			 
dc10				; exec startup line 
dc10			.startdo:	 
dc10 e1				pop hl 
dc11 e5				push hl 
dc12				 
dc12 5e				ld e,(hl) 
dc13 23				inc hl 
dc14 56				ld d,(hl) 
dc15 eb				ex de,hl 
dc16			 
dc16 e5				push hl 
dc17			 
dc17 3e 00			ld a, 0 
dc19				;ld a, FORTH_END_BUFFER 
dc19 cd 58 90			call strlent 
dc1c 23				inc hl   ; include zero term to copy 
dc1d 06 00			ld b,0 
dc1f 4d				ld c,l 
dc20 e1				pop hl 
dc21 11 c1 e2			ld de, scratch 
dc24 ed b0			ldir 
dc26			 
dc26			 
dc26 21 c1 e2			ld hl, scratch 
dc29 cd 77 9e			call forthparse 
dc2c cd b7 9e			call forthexec 
dc2f cd c9 9d			call forthexec_cleanup 
dc32			 
dc32 3e 78			ld a, display_row_4 
dc34 11 60 97			ld de, endprog 
dc37			 
dc37 cd dd 8a			call update_display		 
dc3a			 
dc3a 3a e7 e6			ld a, (os_last_cmd) 
dc3d fe 00			cp 0 
dc3f 20 09			jr nz, .startnxt 
dc41 cd e6 99			call next_page_prompt 
dc44 cd ba 8a		        call clear_display 
dc47 cd dd 8a			call update_display		 
dc4a			 
dc4a				; move onto next startup line? 
dc4a			.startnxt: 
dc4a			 
dc4a cd f1 89			call delay250ms 
dc4d e1				pop hl 
dc4e			 
dc4e 23				inc hl 
dc4f 23				inc hl 
dc50			 
dc50 e5				push hl 
dc51 5e				ld e, (hl) 
dc52 23				inc hl 
dc53 56				ld d, (hl) 
dc54 e1				pop hl 
dc55				; TODO replace 0 test 
dc55			 
dc55 eb				ex de, hl 
dc56 cd 10 8d			call ishlzero 
dc59			;	ld a,e 
dc59			;	add d 
dc59			;	cp 0    ; any left to do? 
dc59 eb				ex de, hl 
dc5a c2 bf db			jp nz, .start1 
dc5d 18 01			jr .startupend 
dc5f			 
dc5f e1			.startupend1: pop hl 
dc60			.startupend: 
dc60			 
dc60 cd ba 8a			call clear_display 
dc63 cd dd 8a			call update_display 
dc66 c9				ret 
dc67			if STORAGE_SE 
dc67			 
dc67			sprompt3: db "Loading from start-up file?:",0 
dc67			sprompt4: db "(Y=Any key/N=No)",0 
dc67			 
dc67			 
dc67			forth_autoload: 
dc67			 
dc67				; load block 0 of store 1 
dc67				 
dc67				ld a, $fe      ; bit 0 clear 
dc67				ld (spi_device), a 
dc67			 
dc67				call storage_get_block_0 
dc67			 
dc67				ld a, (store_page+STORE_0_AUTOFILE) 
dc67			 
dc67				cp 0 
dc67				ret z     ; auto start not enabled 
dc67			 
dc67				call clear_display 
dc67			 
dc67				; set bank 
dc67			 
dc67					ld a, (store_page+STORE_0_BANKRUN) 
dc67					ld (spi_device), a 
dc67			 
dc67				; get file id to load from and get the file name to display 
dc67			 
dc67					ld a, (store_page+STORE_0_FILERUN) 
dc67			 
dc67					ld l, 0 
dc67					ld h, a 
dc67					ld de, store_page 
dc67			 
dc67					if DEBUG_FORTH_WORDS 
dc67						DMARK "ASp" 
dc67						CALLMONITOR 
dc67					endif 
dc67					call storage_read 
dc67			 
dc67					if DEBUG_FORTH_WORDS 
dc67						DMARK "ASr" 
dc67						CALLMONITOR 
dc67					endif 
dc67			 
dc67					call ishlzero 
dc67					ret z             ; file not found 
dc67			 
dc67					ld a, display_row_2 + 10 
dc67					ld de, store_page+3 
dc67					call str_at_display 
dc67				 
dc67			; 
dc67			 
dc67				ld a, display_row_1+5 
dc67				ld de, sprompt3 
dc67				call str_at_display 
dc67				ld a, display_row_3+15 
dc67				ld de, sprompt4 
dc67				call str_at_display 
dc67			 
dc67				call update_display 
dc67			 
dc67				call cin_wait 
dc67				cp 'n' 
dc67				ret z 
dc67				cp 'N' 
dc67				ret z 
dc67			 
dc67				call delay1s 
dc67			 
dc67				ld a, (store_page+2) 
dc67				ld (store_openmaxext), a    ; save count of ext 
dc67				ld a, 1  
dc67				ld (store_openext), a    ; save count of ext 
dc67			 
dc67			.autof:  
dc67				ld l , a 
dc67				 
dc67				ld a, (store_page) 
dc67				ld h, a	 
dc67				ld de, store_page 
dc67					if DEBUG_FORTH_WORDS 
dc67						DMARK "ASl" 
dc67						CALLMONITOR 
dc67					endif 
dc67					call storage_read 
dc67				call ishlzero 
dc67				ret z 
dc67			;	jr z, .autoend 
dc67			 
dc67					if DEBUG_FORTH_WORDS 
dc67						DMARK "ASc" 
dc67						CALLMONITOR 
dc67					endif 
dc67				ld de, store_page+2 
dc67				ld a, display_row_4 
dc67				call str_at_display 
dc67			 
dc67				call update_display 
dc67				call delay250ms 
dc67			 
dc67			 
dc67			 
dc67				ld hl, store_page+2 
dc67				call forthparse 
dc67				call forthexec 
dc67				call forthexec_cleanup 
dc67			 
dc67				 
dc67				ld a, (store_openext) 
dc67				inc a 
dc67				ld (store_openext), a    ; save count of ext 
dc67			 
dc67				jr .autof 
dc67			;.autofdone: 
dc67			; 
dc67			;		if DEBUG_FORTH_WORDS 
dc67			;			DMARK "ASx" 
dc67			;			CALLMONITOR 
dc67			;		endif 
dc67			;;	call clear_display 
dc67			;	ret 
dc67			 
dc67			 
dc67			 
dc67			endif 
# End of file forth_startupv1.asm
dc67			endif 
dc67			if STARTUP_V2 
dc67				include "forth_startupv2.asm" 
dc67			endif 
dc67			 
# End of file forth_startup.asm
dc67			 
dc67			; eof 
# End of file forth_kernel.asm
dc67			;include "nascombasic.asm" 
dc67			 
dc67			 
dc67			; find out where the code ends if loaded into RAM (for SC114) 
dc67			;endofcode:  
dc67			;	nop 
dc67			 
dc67			 
dc67			; jump to nmi vector 
dc67			 
dc67			init_nmi: 
dc67 3e c9			ld a, $c9   ; RET 
dc69 32 72 ee			ld (nmi_vector), a 
dc6c c9				ret 
dc6d			nmi: 
dc6d e5				push hl 
dc6e d5				push de 
dc6f c5				push bc 
dc70 f5				push af 
dc71 cd 72 ee			call nmi_vector 
dc74 f5				push af 
dc75 c5				push bc 
dc76 d5				push de 
dc77 e5				push hl 
dc78 ed 4d			reti 
dc7a			 
dc7a			 
dc7a			; eof 
dc7a			 
# End of file main.asm
dc7a			;include "firmware_lcd_4x40.asm" 
dc7a			;;include "firmware_lcd_4x20.asm" 
dc7a			include "firmware_serial_display.asm" 
dc7a			 
dc7a			; Serial display interface for SC114 
dc7a			 
dc7a			 
dc7a			display_row_1: equ 0 
dc7a			display_row_2: equ display_row_1+display_cols 
dc7a			display_row_3: equ display_row_2 + display_cols 
dc7a			display_row_4: equ display_row_3 + display_cols 
dc7a			 
dc7a			kLCDWidth:  EQU display_cols             ;Width in characters 
dc7a			kLCD_Line1: EQU 0x00  
dc7a			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
dc7a			; E1 
dc7a			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
dc7a			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
dc7a			 
dc7a			lcd_init: 
dc7a				; no init as handled by the SCM bios 
dc7a c9				ret 
dc7b			 
dc7b			 
dc7b			; low level functions for direct screen writes 
dc7b			 
dc7b			; output char at pos? 
dc7b			fLCD_Str: 
dc7b			        ;out (SC114_SIO_1_OUT),a 
dc7b c5				push bc 
dc7c 0e 02			ld c, $02 
dc7e f7				rst $30 
dc7f c1				pop bc 
dc80 c9				ret 
dc81			 
dc81			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
dc81			fLCD_Pos: 
dc81				; use ASCII escape to position 
dc81			        ;out (SC114_SIO_1_OUT),a 
dc81 c5				push bc 
dc82 0e 02			ld c, $02 
dc84 f7				rst $30 
dc85 c1				pop bc 
dc86			 
dc86 c9				ret 
dc87			 
dc87			; output char at pos 
dc87			fLCD_Data: 
dc87			      ;  out (SC114_SIO_1_OUT),a 
dc87 c5				push bc 
dc88 0e 02			ld c, $02 
dc8a f7				rst $30 
dc8b c1				pop bc 
dc8c			 
dc8c c9				ret 
dc8d			 
dc8d			; ascii cls  
dc8d			 
dc8d 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
dc91			 
dc91			; write the frame buffer given in hl to hardware  
dc91			write_display: 
dc91			 
dc91			API: equ 0 
dc91			 
dc91			if API 
dc91				push bc 
dc91				ld b, 4 
dc91			 
dc91			        ld (display_write_tmp), hl 	  
dc91			 
dc91				; clear and home cursor 
dc91			 
dc91				ld c, 6 
dc91				ld de, .cls 
dc91				rst $30 
dc91			 
dc91			 
dc91			.writeln: 
dc91			 
dc91				ld de, (display_write_tmp) 
dc91				ld c, 6 
dc91				rst $30 
dc91				ld c, 7 
dc91				rst $30 
dc91			 
dc91				ld hl, (display_write_tmp) 
dc91				ld de, display_cols 
dc91				add hl,de 
dc91				ld (display_write_tmp),hl 
dc91			 
dc91				djnz  .writeln 
dc91			 
dc91				pop bc 
dc91			 
dc91			 
dc91				ret 
dc91			endif 
dc91 e5				push hl 
dc92 c5				push bc 
dc93 d5				push de 
dc94			 
dc94			;	ld c, 2 
dc94			;	;ld de, .cls 
dc94			;	ld a, 27 
dc94			;	rst $30 
dc94			;	ld c, 2 
dc94			;	;ld de, .cls 
dc94			;	ld a, '[' 
dc94			;	rst $30 
dc94			; 
dc94			;	ld c, 2 
dc94			;	;ld de, .cls 
dc94			;	ld a, 'H' 
dc94			;	rst $30 
dc94			; 
dc94			 
dc94 0e 02			ld c, 2 
dc96				;ld de, .cls 
dc96 3e 1b			ld a, 27 
dc98 f7				rst $30 
dc99			 
dc99			 
dc99 0e 02			ld c, 2 
dc9b				;ld de, .cls 
dc9b 3e 5b			ld a, '[' 
dc9d f7				rst $30 
dc9e 0e 02			ld c, 2 
dca0				;ld de, .cls 
dca0 3e 32			ld a, '2' 
dca2 f7				rst $30 
dca3 0e 02			ld c, 2 
dca5				;ld de, .cls 
dca5 3e 4a			ld a, 'J' 
dca7 f7				rst $30 
dca8 d1				pop de 
dca9 c1				pop bc 
dcaa e1				pop hl 
dcab			 
dcab			 
dcab 22 c9 eb		        ld (display_write_tmp), hl 	  
dcae 3e 00			ld a, kLCD_Line1 
dcb0			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dcb0 06 28			ld b, display_cols 
dcb2 ed 5b c9 eb		ld de, (display_write_tmp) 
dcb6 cd 14 dd			call write_len_string 
dcb9				 
dcb9			 
dcb9 e5			push hl 
dcba d5			push de 
dcbb c5			push bc 
dcbc 0e 07			ld c, 7 
dcbe f7				rst $30 
dcbf c1			pop bc 
dcc0 d1			pop de 
dcc1 e1			pop hl 
dcc2			 
dcc2				 
dcc2 2a c9 eb			ld hl, (display_write_tmp) 
dcc5 11 28 00			ld de, display_cols 
dcc8 19				add hl,de 
dcc9 22 c9 eb			ld (display_write_tmp),hl 
dccc			 
dccc				 
dccc 3e 28			ld a, kLCD_Line2 
dcce			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dcce 06 28			ld b, display_cols 
dcd0 ed 5b c9 eb		ld de, (display_write_tmp) 
dcd4 cd 14 dd			call write_len_string 
dcd7				 
dcd7 2a c9 eb			ld hl, (display_write_tmp) 
dcda 11 28 00			ld de, display_cols 
dcdd 19				add hl,de 
dcde 22 c9 eb			ld (display_write_tmp),hl 
dce1			 
dce1 e5			push hl 
dce2 d5			push de 
dce3 c5			push bc 
dce4 0e 07			ld c, 7 
dce6 f7				rst $30 
dce7 c1			pop bc 
dce8 d1			pop de 
dce9 e1			pop hl 
dcea			 
dcea				 
dcea 3e 50			ld a, kLCD_Line3 
dcec			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
dcec 06 28			ld b, display_cols 
dcee ed 5b c9 eb		ld de, (display_write_tmp) 
dcf2 cd 14 dd			call write_len_string 
dcf5				 
dcf5 2a c9 eb			ld hl, (display_write_tmp) 
dcf8 11 28 00			ld de, display_cols 
dcfb 19				add hl,de 
dcfc 22 c9 eb			ld (display_write_tmp),hl 
dcff			 
dcff e5			push hl 
dd00 d5			push de 
dd01 c5			push bc 
dd02 0e 07			ld c, 7 
dd04 f7				rst $30 
dd05 c1			pop bc 
dd06 d1			pop de 
dd07 e1			pop hl 
dd08			 
dd08				 
dd08 3e 78			ld a, kLCD_Line4 
dd0a			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
dd0a 06 28			ld b, display_cols 
dd0c ed 5b c9 eb		ld de, (display_write_tmp) 
dd10 cd 14 dd			call write_len_string 
dd13 c9					ret 
dd14			 
dd14			 
dd14				; write out a fixed length string given in b from de 
dd14			 
dd14 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
dd15 cd 87 dc		            CALL fLCD_Data      ;Write character to display 
dd18 13				inc de 
dd19 10 f9			djnz write_len_string 
dd1b c9				ret 
dd1c			 
dd1c			 
dd1c			; eof 
# End of file firmware_serial_display.asm
dd1c			;include "firmware_key_5x10.asm" 
dd1c			;;include "firmware_key_4x10.asm" 
dd1c			include "firmware_key_serial.asm" 
dd1c			; Serial keyboard interface for SC114 
dd1c			 
dd1c			key_init: 
dd1c				; no init as handled by the SCM bios 
dd1c c9				ret 
dd1d			 
dd1d			 
dd1d			cin_wait: 
dd1d			;	ld a, 0 
dd1d			;	ret 
dd1d			 
dd1d				;in a,(SC114_SIO_1_IN) 
dd1d			        ; Use SCM API to get from whatever console device we are using 
dd1d c5				push bc 
dd1e 0e 01			ld c, $01 
dd20 f7				rst $30 
dd21 c1				pop bc 
dd22 c9				ret 
dd23			 
dd23			cin: 
dd23			 
dd23			 
dd23 c5				push bc 
dd24			 
dd24				; any key waiting to process? 
dd24 0e 03			ld c, $03 
dd26 f7				rst $30 
dd27 28 05			jr z, .cin_skip 
dd29			 
dd29				; yep, get it 
dd29			 
dd29 0e 01			ld c, $01 
dd2b f7				rst $30 
dd2c c1				pop bc 
dd2d c9				ret 
dd2e			.cin_skip: 
dd2e 3e 00			ld a, 0 
dd30 c1				pop bc 
dd31 c9				ret 
dd32			 
dd32			 
dd32			 
dd32			 
# End of file firmware_key_serial.asm
dd32			endofcode:  
dd32			baseram:  
dd32 00				nop 
dd33			 
dd33			heap_start: equ baseram+15  ; Starting address of heap 
dd33			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
dd33			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
dd33			;VDU:  EQU     endofcode           ; BASIC Work space 
dd33			; eof 
dd33			 
# End of file os_mega_sc114.asm
dd33
