# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 51 93			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 0   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ os_input  
8003			os_new_parse_len: equ os_new_malloc + 2  
8003			os_new_word_len: equ os_new_parse_len + 2  
8003			os_new_work_ptr: equ os_new_word_len + 2  
8003			os_new_src_ptr: equ os_new_work_ptr + 2  
8003			os_new_exec: equ os_new_src_ptr + 2  
8003			os_new_exec_ptr: equ os_new_exec + 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ scratch - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 80 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 1f ed				ld hl, display_fb1  
800b 22 db eb				ld (display_fb_active), hl  
800e			  
800e cd 5e 88				call clear_display  
8011			  
8011 21 dd eb				ld hl, display_fb2  
8014 22 db eb				ld (display_fb_active), hl  
8017			  
8017 cd 5e 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 c0 ed				ld hl, display_fb0  
801d 22 db eb				ld (display_fb_active), hl  
8020			  
8020 cd 5e 88				call clear_display  
8023			  
8023			  
8023 cd fc d3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 9e d4			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 5a 8e				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 81 88			call update_display  
8032 cd e2 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 63 88			call fill_display  
803a cd 81 88			call update_display  
803d cd e2 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 63 88			call fill_display  
8045 cd 81 88			call update_display  
8048 cd e2 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 63 88			call fill_display  
8050 cd 81 88			call update_display  
8053 cd e2 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056			        ld a, display_row_1    
8056			else  
8056 3e 0a		        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 71 88			call str_at_display  
805e cd 81 88			call update_display  
8061			  
8061			  
8061 cd e2 87			call delay1s  
8064 cd e2 87			call delay1s  
8067			if display_cols == 20	  
8067			            LD   A, display_row_3+2  
8067			else  
8067 3e 5c		            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 71 88			call str_at_display  
806f cd 81 88			call update_display  
8072 cd e2 87			call delay1s  
8075 cd e2 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 7a ee		ld (debug_mark),a  
807d 32 7b ee		ld (debug_mark+1),a  
8080 32 7c ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 7d ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 7a ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 7b ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 7c ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 7b 91			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 7a ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 7b ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 7c ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 7b 91			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd c7 83			call storage_findnextid 
8105			 
8105 cd e0 89			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 65 eb			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 7a ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 7b ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 7c ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 7b 91			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 7a ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 7b ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 7c ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 7b 91			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 65 eb			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 7a ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 7b ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 7c ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 65 eb				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 7b 91			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a 66 eb			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 7a ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 7b ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 7c ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 7b 91			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 7a ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 7b ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 7c ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 7b 91			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 21 65 eb			ld hl, store_page 
81d3 3e 00			ld a, 0 
81d5				 
81d5 77				ld (hl),a   ; reset file counter 
81d6			 
81d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81d9 22 66 eb		 	ld (store_page+1), hl	 
81dc			 
81dc				; set default label 
81dc			 
81dc 21 71 82			ld hl, .defaultbanklabl 
81df 11 68 eb		 	ld de, store_page+3 
81e2 01 0f 00			ld bc, 15 
81e5 ed b0			ldir 
81e7			 
81e7				; save default page 0 
81e7			 
81e7 21 00 00			ld hl, 0 
81ea 11 65 eb			ld de, store_page 
81ed				if DEBUG_STORESE 
81ed					DMARK "SB3" 
81ed f5				push af  
81ee 3a 02 82			ld a, (.dmark)  
81f1 32 7a ee			ld (debug_mark),a  
81f4 3a 03 82			ld a, (.dmark+1)  
81f7 32 7b ee			ld (debug_mark+1),a  
81fa 3a 04 82			ld a, (.dmark+2)  
81fd 32 7c ee			ld (debug_mark+2),a  
8200 18 03			jr .pastdmark  
8202 ..			.dmark: db "SB3"  
8205 f1			.pastdmark: pop af  
8206			endm  
# End of macro DMARK
8206			;		push af 
8206			;		ld a, 'F' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206					CALLMONITOR 
8206 cd 7b 91			call break_point_state  
8209				endm  
# End of macro CALLMONITOR
8209				endif 
8209 cd 16 81			call storage_write_block 
820c				if DEBUG_STORESE 
820c					DMARK "SB4" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 7a ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 7b ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 7c ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SB4"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			;		push af 
8225			;		ld a, '>' 
8225			;		ld (debug_mark),a 
8225			;		pop af 
8225					CALLMONITOR 
8225 cd 7b 91			call break_point_state  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228			 
8228 00				nop 
8229 00				nop 
822a 00				nop 
822b			 
822b				; now set 0 in every page to mark as a free block 
822b			 
822b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
822d 21 40 00			ld hl, STORE_BLOCK_PHY 
8230			 
8230 3e 00		.setmark1:   	ld a,0 
8232 e5					push hl 
8233 c5					push bc 
8234 cd af 80				call se_writebyte 
8237 3e 0a			ld a, 10 
8239 cd c7 87			call aDelayInMS 
823c 23				inc hl 
823d cd af 80				call se_writebyte 
8240 3e 0a			ld a, 10 
8242 cd c7 87			call aDelayInMS 
8245 2b				dec hl 
8246 c1					pop bc 
8247 e1					pop hl 
8248 3e 40				ld a, STORE_BLOCK_PHY 
824a cd b7 89				call addatohl 
824d 10 e1				djnz .setmark1 
824f			 
824f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8251 3e 00		.setmark2:   	ld a,0 
8253 e5					push hl 
8254 c5					push bc 
8255 cd af 80				call se_writebyte 
8258 3e 0a			ld a, 10 
825a cd c7 87			call aDelayInMS 
825d 23				inc hl 
825e cd af 80				call se_writebyte 
8261 3e 0a			ld a, 10 
8263 cd c7 87			call aDelayInMS 
8266 2b				dec hl 
8267 c1					pop bc 
8268 e1					pop hl 
8269 3e 40				ld a, STORE_BLOCK_PHY 
826b cd b7 89				call addatohl 
826e 10 e1				djnz .setmark2 
8270			 
8270					 
8270			 
8270			 
8270 c9				ret 
8271			 
8271			 
8271			 
8271			 
8271 .. 00		.defaultbanklabl:   db "BankLabel",0 
827b			 
827b			 
827b			 
827b			; Label Bank 
827b			; ---------- 
827b			; 
827b			; With current bank 
827b			; Read block 0 
827b			; Set label 
827b			; Write block 0 
827b			 
827b			; label str pointer in hl 
827b			 
827b			storage_label:     
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "LBL" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 7a ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 7b ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 7c ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "LBL"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					CALLMONITOR 
8294 cd 7b 91			call break_point_state  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 e5				push hl 
8298			 
8298 cd 62 81			call storage_get_block_0 
829b			 
829b				; set default label 
829b			 
829b e1				pop hl 
829c			 
829c 11 68 eb		 	ld de, store_page+3 
829f 01 0f 00			ld bc, 15 
82a2				if DEBUG_STORESE 
82a2					DMARK "LB3" 
82a2 f5				push af  
82a3 3a b7 82			ld a, (.dmark)  
82a6 32 7a ee			ld (debug_mark),a  
82a9 3a b8 82			ld a, (.dmark+1)  
82ac 32 7b ee			ld (debug_mark+1),a  
82af 3a b9 82			ld a, (.dmark+2)  
82b2 32 7c ee			ld (debug_mark+2),a  
82b5 18 03			jr .pastdmark  
82b7 ..			.dmark: db "LB3"  
82ba f1			.pastdmark: pop af  
82bb			endm  
# End of macro DMARK
82bb					CALLMONITOR 
82bb cd 7b 91			call break_point_state  
82be				endm  
# End of macro CALLMONITOR
82be				endif 
82be ed b0			ldir 
82c0				; save default page 0 
82c0			 
82c0 21 00 00			ld hl, 0 
82c3 11 65 eb			ld de, store_page 
82c6				if DEBUG_STORESE 
82c6					DMARK "LBW" 
82c6 f5				push af  
82c7 3a db 82			ld a, (.dmark)  
82ca 32 7a ee			ld (debug_mark),a  
82cd 3a dc 82			ld a, (.dmark+1)  
82d0 32 7b ee			ld (debug_mark+1),a  
82d3 3a dd 82			ld a, (.dmark+2)  
82d6 32 7c ee			ld (debug_mark+2),a  
82d9 18 03			jr .pastdmark  
82db ..			.dmark: db "LBW"  
82de f1			.pastdmark: pop af  
82df			endm  
# End of macro DMARK
82df					CALLMONITOR 
82df cd 7b 91			call break_point_state  
82e2				endm  
# End of macro CALLMONITOR
82e2				endif 
82e2 cd 16 81			call storage_write_block 
82e5			 
82e5 c9				ret 
82e6			 
82e6			 
82e6			 
82e6			; Read Block 0 - Config 
82e6			; --------------------- 
82e6			; 
82e6			; With current bank 
82e6			; Call presence test 
82e6			;    If not present format/init bank  
82e6			; Read block 0  
82e6			;  
82e6			 
82e6			 
82e6			; Dir 
82e6			; --- 
82e6			; 
82e6			; With current bank 
82e6			; Load Block 0 Config 
82e6			; Get max file id number 
82e6			; For each logical block 
82e6			;    Read block read byte 2 
82e6			;      if first block of file 
82e6			;         Display file name 
82e6			;         Display type flags for file 
82e6			;        
82e6			 
82e6			; moving to words as this requires stack control 
82e6			 
82e6			 
82e6			; Delete File 
82e6			; ----------- 
82e6			; 
82e6			; With current bank 
82e6			; 
82e6			; Load Block 0 Config 
82e6			; Get max file id number 
82e6			; For each logical block 
82e6			;    Read block file id 
82e6			;      If first block of file and dont have file id 
82e6			;         if file to delete 
82e6			;         Save file id 
82e6			;         Null file id 
82e6			;         Write this block back 
82e6			;      If file id is one saved 
82e6			;         Null file id 
82e6			;         Write this block back 
82e6			 
82e6			storage_erase: 
82e6			 
82e6				; hl contains the file id 
82e6			 
82e6 5d				ld e, l 
82e7 16 00			ld d, 0 
82e9 21 40 00			ld hl, STORE_BLOCK_PHY 
82ec					if DEBUG_FORTH_WORDS 
82ec						DMARK "ERA" 
82ec f5				push af  
82ed 3a 01 83			ld a, (.dmark)  
82f0 32 7a ee			ld (debug_mark),a  
82f3 3a 02 83			ld a, (.dmark+1)  
82f6 32 7b ee			ld (debug_mark+1),a  
82f9 3a 03 83			ld a, (.dmark+2)  
82fc 32 7c ee			ld (debug_mark+2),a  
82ff 18 03			jr .pastdmark  
8301 ..			.dmark: db "ERA"  
8304 f1			.pastdmark: pop af  
8305			endm  
# End of macro DMARK
8305						CALLMONITOR 
8305 cd 7b 91			call break_point_state  
8308				endm  
# End of macro CALLMONITOR
8308					endif 
8308 cd c7 83			call storage_findnextid 
830b			 
830b e5				push hl 
830c			 
830c				; TODO check file not found 
830c			 
830c 11 65 eb			ld de, store_page 
830f cd b1 80			call storage_read_block 
8312			 
8312					if DEBUG_FORTH_WORDS 
8312						DMARK "ER1" 
8312 f5				push af  
8313 3a 27 83			ld a, (.dmark)  
8316 32 7a ee			ld (debug_mark),a  
8319 3a 28 83			ld a, (.dmark+1)  
831c 32 7b ee			ld (debug_mark+1),a  
831f 3a 29 83			ld a, (.dmark+2)  
8322 32 7c ee			ld (debug_mark+2),a  
8325 18 03			jr .pastdmark  
8327 ..			.dmark: db "ER1"  
832a f1			.pastdmark: pop af  
832b			endm  
# End of macro DMARK
832b						CALLMONITOR 
832b cd 7b 91			call break_point_state  
832e				endm  
# End of macro CALLMONITOR
832e					endif 
832e 3a 65 eb			ld a, (store_page)	; get file id 
8331 32 5e eb			ld (store_tmpid), a 
8334			 
8334 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
8337 32 5d eb			ld (store_tmpext), a 
833a			 
833a				; wipe file header 
833a			 
833a e1				pop hl 
833b 3e 00			ld a, 0 
833d 32 65 eb			ld (store_page), a 
8340 32 66 eb			ld (store_page+1),a 
8343 11 65 eb			ld de, store_page 
8346					if DEBUG_FORTH_WORDS 
8346						DMARK "ER2" 
8346 f5				push af  
8347 3a 5b 83			ld a, (.dmark)  
834a 32 7a ee			ld (debug_mark),a  
834d 3a 5c 83			ld a, (.dmark+1)  
8350 32 7b ee			ld (debug_mark+1),a  
8353 3a 5d 83			ld a, (.dmark+2)  
8356 32 7c ee			ld (debug_mark+2),a  
8359 18 03			jr .pastdmark  
835b ..			.dmark: db "ER2"  
835e f1			.pastdmark: pop af  
835f			endm  
# End of macro DMARK
835f						CALLMONITOR 
835f cd 7b 91			call break_point_state  
8362				endm  
# End of macro CALLMONITOR
8362					endif 
8362 cd 16 81			call storage_write_block 
8365			 
8365			 
8365				; wipe file extents 
8365			 
8365 3a 5d eb			ld a, (store_tmpext) 
8368 47				ld b, a 
8369			 
8369			.eraext:	  
8369 c5				push bc 
836a			 
836a 21 40 00			ld hl, STORE_BLOCK_PHY 
836d 3a 5e eb			ld a,(store_tmpid) 
8370 5f				ld e, a 
8371 50				ld d, b	 
8372					if DEBUG_FORTH_WORDS 
8372						DMARK "ER3" 
8372 f5				push af  
8373 3a 87 83			ld a, (.dmark)  
8376 32 7a ee			ld (debug_mark),a  
8379 3a 88 83			ld a, (.dmark+1)  
837c 32 7b ee			ld (debug_mark+1),a  
837f 3a 89 83			ld a, (.dmark+2)  
8382 32 7c ee			ld (debug_mark+2),a  
8385 18 03			jr .pastdmark  
8387 ..			.dmark: db "ER3"  
838a f1			.pastdmark: pop af  
838b			endm  
# End of macro DMARK
838b						CALLMONITOR 
838b cd 7b 91			call break_point_state  
838e				endm  
# End of macro CALLMONITOR
838e					endif 
838e cd c7 83			call storage_findnextid 
8391			 
8391 e5				push hl 
8392 11 65 eb			ld de, store_page 
8395 cd b1 80			call storage_read_block 
8398			 
8398				; free block	 
8398			 
8398 3e 00			ld a, 0 
839a 32 65 eb			ld (store_page), a 
839d 32 66 eb			ld (store_page+1),a 
83a0 11 65 eb			ld de, store_page 
83a3 e1				pop hl 
83a4					if DEBUG_FORTH_WORDS 
83a4						DMARK "ER4" 
83a4 f5				push af  
83a5 3a b9 83			ld a, (.dmark)  
83a8 32 7a ee			ld (debug_mark),a  
83ab 3a ba 83			ld a, (.dmark+1)  
83ae 32 7b ee			ld (debug_mark+1),a  
83b1 3a bb 83			ld a, (.dmark+2)  
83b4 32 7c ee			ld (debug_mark+2),a  
83b7 18 03			jr .pastdmark  
83b9 ..			.dmark: db "ER4"  
83bc f1			.pastdmark: pop af  
83bd			endm  
# End of macro DMARK
83bd						CALLMONITOR 
83bd cd 7b 91			call break_point_state  
83c0				endm  
# End of macro CALLMONITOR
83c0					endif 
83c0 cd 16 81			call storage_write_block 
83c3			 
83c3 c1				pop bc 
83c4 10 a3			djnz .eraext 
83c6			 
83c6 c9				ret 
83c7			 
83c7			 
83c7			; Find Free Block 
83c7			; --------------- 
83c7			; 
83c7			; With current bank 
83c7			;  
83c7			; From given starting logical block 
83c7			;    Read block  
83c7			;    If no file id 
83c7			;         Return block id 
83c7			 
83c7			 
83c7			; hl starting page number 
83c7			; hl contains free page number or zero if no pages free 
83c7			; e contains the file id to locate 
83c7			; d contains the block number 
83c7			 
83c7			; TODO change to find file id and use zero for free block 
83c7			 
83c7			storage_findnextid: 
83c7			 
83c7				; now locate first 0 page to mark as a free block 
83c7			 
83c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83c9			;	ld hl, STORE_BLOCK_PHY 
83c9			 
83c9					if DEBUG_FORTH_WORDS 
83c9					DMARK "FNI" 
83c9 f5				push af  
83ca 3a de 83			ld a, (.dmark)  
83cd 32 7a ee			ld (debug_mark),a  
83d0 3a df 83			ld a, (.dmark+1)  
83d3 32 7b ee			ld (debug_mark+1),a  
83d6 3a e0 83			ld a, (.dmark+2)  
83d9 32 7c ee			ld (debug_mark+2),a  
83dc 18 03			jr .pastdmark  
83de ..			.dmark: db "FNI"  
83e1 f1			.pastdmark: pop af  
83e2			endm  
# End of macro DMARK
83e2						CALLMONITOR 
83e2 cd 7b 91			call break_point_state  
83e5				endm  
# End of macro CALLMONITOR
83e5					endif 
83e5			.ff1:   	 
83e5 e5					push hl 
83e6 c5					push bc 
83e7 d5					push de 
83e8 cd ae 80				call se_readbyte 
83eb 5f					ld e,a 
83ec 23					inc hl 
83ed cd ae 80				call se_readbyte 
83f0 57					ld d, a 
83f1 e1					pop hl 
83f2 e5					push hl 
83f3 cd d5 89				call cmp16 
83f6 28 49				jr z, .fffound 
83f8			 
83f8 d1					pop de 
83f9 c1					pop bc 
83fa e1					pop hl 
83fb			 
83fb					; is found? 
83fb					;cp e 
83fb					;ret z 
83fb			 
83fb 3e 40				ld a, STORE_BLOCK_PHY 
83fd cd b7 89				call addatohl 
8400 10 e3				djnz .ff1 
8402			 
8402 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8404			.ff2:   	 
8404			 
8404 e5					push hl 
8405 c5					push bc 
8406 d5					push de 
8407 cd ae 80				call se_readbyte 
840a 5f					ld e,a 
840b 23					inc hl 
840c cd ae 80				call se_readbyte 
840f 57					ld d, a 
8410			 
8410 e1					pop hl 
8411 e5					push hl 
8412 cd d5 89				call cmp16 
8415 28 2a				jr z, .fffound 
8417			 
8417 d1					pop de 
8418 c1					pop bc 
8419 e1					pop hl 
841a					; is found? 
841a					;cp e 
841a					;ret z 
841a			 
841a 3e 40				ld a, STORE_BLOCK_PHY 
841c cd b7 89				call addatohl 
841f 10 e3				djnz .ff2 
8421			 
8421			 
8421					if DEBUG_FORTH_WORDS 
8421					DMARK "FN-" 
8421 f5				push af  
8422 3a 36 84			ld a, (.dmark)  
8425 32 7a ee			ld (debug_mark),a  
8428 3a 37 84			ld a, (.dmark+1)  
842b 32 7b ee			ld (debug_mark+1),a  
842e 3a 38 84			ld a, (.dmark+2)  
8431 32 7c ee			ld (debug_mark+2),a  
8434 18 03			jr .pastdmark  
8436 ..			.dmark: db "FN-"  
8439 f1			.pastdmark: pop af  
843a			endm  
# End of macro DMARK
843a					;	push af 
843a					;	ld a, 'n' 
843a					;	ld (debug_mark),a 
843a					;	pop af 
843a						CALLMONITOR 
843a cd 7b 91			call break_point_state  
843d				endm  
# End of macro CALLMONITOR
843d					endif 
843d				; no free marks! 
843d 21 00 00				ld hl, 0 
8440 c9				ret 
8441			.fffound: 
8441				 
8441			 
8441 d1					pop de 
8442 c1					pop bc 
8443 e1					pop hl 
8444					if DEBUG_FORTH_WORDS 
8444					DMARK "FNF" 
8444 f5				push af  
8445 3a 59 84			ld a, (.dmark)  
8448 32 7a ee			ld (debug_mark),a  
844b 3a 5a 84			ld a, (.dmark+1)  
844e 32 7b ee			ld (debug_mark+1),a  
8451 3a 5b 84			ld a, (.dmark+2)  
8454 32 7c ee			ld (debug_mark+2),a  
8457 18 03			jr .pastdmark  
8459 ..			.dmark: db "FNF"  
845c f1			.pastdmark: pop af  
845d			endm  
# End of macro DMARK
845d					;	push af 
845d					;	ld a, 'n' 
845d					;	ld (debug_mark),a 
845d					;	pop af 
845d						CALLMONITOR 
845d cd 7b 91			call break_point_state  
8460				endm  
# End of macro CALLMONITOR
8460					endif 
8460 c9				ret 
8461			 
8461			 
8461			 
8461			; Free Space 
8461			; ---------- 
8461			; 
8461			; With current bank 
8461			; 
8461			; Set block count to zero 
8461			; Starting with first logical block 
8461			;      Find free block  
8461			;      If block id given, increment block count 
8461			; 
8461			;  
8461			 
8461			 
8461			; hl contains count of free blocks 
8461			 
8461			storage_freeblocks: 
8461			 
8461				; now locate first 0 page to mark as a free block 
8461			 
8461 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8463 21 40 00			ld hl, STORE_BLOCK_PHY 
8466 11 00 00			ld de, 0 
8469			 
8469			.fb1:   	 
8469 e5					push hl 
846a c5					push bc 
846b d5					push de 
846c cd ae 80				call se_readbyte 
846f d1					pop de 
8470 c1					pop bc 
8471 e1					pop hl 
8472			 
8472					; is free? 
8472 fe 00				cp 0 
8474 20 01				jr nz, .ff1cont 
8476 13					inc de 
8477			 
8477			.ff1cont: 
8477			 
8477			 
8477 3e 40				ld a, STORE_BLOCK_PHY 
8479 cd b7 89				call addatohl 
847c 10 eb				djnz .fb1 
847e			 
847e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8480			.fb2:   	 
8480 e5					push hl 
8481 c5					push bc 
8482 d5					push de 
8483 cd ae 80				call se_readbyte 
8486 d1					pop de 
8487 c1					pop bc 
8488 e1					pop hl 
8489			 
8489					; is free? 
8489 fe 00				cp 0 
848b 20 01				jr nz, .ff2cont 
848d 13					inc de 
848e			 
848e			.ff2cont: 
848e			 
848e 3e 40				ld a, STORE_BLOCK_PHY 
8490 cd b7 89				call addatohl 
8493 10 eb				djnz .fb2 
8495			 
8495 eb				ex de, hl 
8496 c9				ret 
8497			 
8497			; Get File ID 
8497			; ----------- 
8497			; 
8497			; With current bank 
8497			;  
8497			; Load Block 0 Config 
8497			; Get max file id number 
8497			; For each logical block 
8497			;    Read block file id 
8497			;      If first block of file and dont have file id 
8497			;         if file get id and exit 
8497			 
8497			 
8497			 
8497			 
8497			; Create File 
8497			; ----------- 
8497			; 
8497			; With current bank  
8497			; Load Block 0 Config 
8497			; Get max file id number 
8497			; Increment file id number 
8497			; Save Config 
8497			; Find free block 
8497			; Set buffer with file name and file id 
8497			; Write buffer to free block  
8497			 
8497			 
8497			; hl point to file name 
8497			; hl returns file id 
8497			 
8497			; file format: 
8497			; byte 0 - file id 
8497			; byte 1 - extent number 
8497			; byte 2-> data 
8497			 
8497			; format for extent number 0: 
8497			; 
8497			; byte 0 - file id 
8497			; byte 1 - extent 0 
8497			; byte 2 - extent count 
8497			; byte 3 -> file name and meta data 
8497			 
8497			 
8497			storage_create: 
8497				if DEBUG_STORESE 
8497					DMARK "SCR" 
8497 f5				push af  
8498 3a ac 84			ld a, (.dmark)  
849b 32 7a ee			ld (debug_mark),a  
849e 3a ad 84			ld a, (.dmark+1)  
84a1 32 7b ee			ld (debug_mark+1),a  
84a4 3a ae 84			ld a, (.dmark+2)  
84a7 32 7c ee			ld (debug_mark+2),a  
84aa 18 03			jr .pastdmark  
84ac ..			.dmark: db "SCR"  
84af f1			.pastdmark: pop af  
84b0			endm  
# End of macro DMARK
84b0					CALLMONITOR 
84b0 cd 7b 91			call break_point_state  
84b3				endm  
# End of macro CALLMONITOR
84b3				endif 
84b3			 
84b3 e5				push hl		; save file name pointer 
84b4			 
84b4 cd 62 81			call storage_get_block_0 
84b7			 
84b7 3a 65 eb			ld a,(store_page)	; get current file id 
84ba 3c				inc a 
84bb 32 65 eb			ld (store_page),a 
84be				 
84be 32 5e eb			ld (store_tmpid),a			; save id 
84c1			 
84c1 21 00 00			ld hl, 0 
84c4 11 65 eb			ld de, store_page 
84c7				if DEBUG_STORESE 
84c7					DMARK "SCw" 
84c7 f5				push af  
84c8 3a dc 84			ld a, (.dmark)  
84cb 32 7a ee			ld (debug_mark),a  
84ce 3a dd 84			ld a, (.dmark+1)  
84d1 32 7b ee			ld (debug_mark+1),a  
84d4 3a de 84			ld a, (.dmark+2)  
84d7 32 7c ee			ld (debug_mark+2),a  
84da 18 03			jr .pastdmark  
84dc ..			.dmark: db "SCw"  
84df f1			.pastdmark: pop af  
84e0			endm  
# End of macro DMARK
84e0					CALLMONITOR 
84e0 cd 7b 91			call break_point_state  
84e3				endm  
# End of macro CALLMONITOR
84e3				endif 
84e3 cd 16 81			call storage_write_block	 ; save update 
84e6			 
84e6				if DEBUG_STORESE 
84e6 11 65 eb				ld de, store_page 
84e9					DMARK "SCC" 
84e9 f5				push af  
84ea 3a fe 84			ld a, (.dmark)  
84ed 32 7a ee			ld (debug_mark),a  
84f0 3a ff 84			ld a, (.dmark+1)  
84f3 32 7b ee			ld (debug_mark+1),a  
84f6 3a 00 85			ld a, (.dmark+2)  
84f9 32 7c ee			ld (debug_mark+2),a  
84fc 18 03			jr .pastdmark  
84fe ..			.dmark: db "SCC"  
8501 f1			.pastdmark: pop af  
8502			endm  
# End of macro DMARK
8502					CALLMONITOR 
8502 cd 7b 91			call break_point_state  
8505				endm  
# End of macro CALLMONITOR
8505				endif 
8505				;  
8505				 
8505 21 40 00			ld hl, STORE_BLOCK_PHY 
8508 11 00 00			ld de, 0 
850b cd c7 83			call storage_findnextid 
850e			 
850e 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
8511			 
8511				; TODO detect 0 = no spare blocks 
8511			 
8511				; hl now contains the free page to use for the file header page 
8511			 
8511				if DEBUG_STORESE 
8511				DMARK "SCF" 
8511 f5				push af  
8512 3a 26 85			ld a, (.dmark)  
8515 32 7a ee			ld (debug_mark),a  
8518 3a 27 85			ld a, (.dmark+1)  
851b 32 7b ee			ld (debug_mark+1),a  
851e 3a 28 85			ld a, (.dmark+2)  
8521 32 7c ee			ld (debug_mark+2),a  
8524 18 03			jr .pastdmark  
8526 ..			.dmark: db "SCF"  
8529 f1			.pastdmark: pop af  
852a			endm  
# End of macro DMARK
852a					CALLMONITOR 
852a cd 7b 91			call break_point_state  
852d				endm  
# End of macro CALLMONITOR
852d				endif 
852d			 
852d 22 63 eb			ld (store_tmppageid), hl 
8530				 
8530 3a 5e eb			ld a,(store_tmpid)    ; get file id 
8533			;	ld a, (store_filecache)			; save to cache 
8533			 
8533 32 65 eb			ld (store_page),a    ; set page id 
8536 3e 00			ld a, 0			 ; extent 0 is file header 
8538 32 66 eb			ld (store_page+1), a   ; set file extent 
853b			 
853b 32 67 eb			ld (store_page+2), a   ; extent count for the file 
853e			 
853e			;	inc hl 		; init block 0 of file 
853e			;	inc hl   		; skip file and extent id 
853e			 ;       ld a, 0 
853e			;	ld (hl),a 
853e			;	ld a, (store_filecache+1)  	; save to cache 
853e			 
853e			;	inc hl    ; file name 
853e				 
853e				 
853e 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
8541				if DEBUG_STORESE 
8541					DMARK "SCc" 
8541 f5				push af  
8542 3a 56 85			ld a, (.dmark)  
8545 32 7a ee			ld (debug_mark),a  
8548 3a 57 85			ld a, (.dmark+1)  
854b 32 7b ee			ld (debug_mark+1),a  
854e 3a 58 85			ld a, (.dmark+2)  
8551 32 7c ee			ld (debug_mark+2),a  
8554 18 03			jr .pastdmark  
8556 ..			.dmark: db "SCc"  
8559 f1			.pastdmark: pop af  
855a			endm  
# End of macro DMARK
855a					CALLMONITOR 
855a cd 7b 91			call break_point_state  
855d				endm  
# End of macro CALLMONITOR
855d				endif 
855d e1				pop hl    ; get zero term string 
855e e5				push hl 
855f 3e 00			ld a, 0 
8561 cd 20 8e			call strlent 
8564 23				inc hl   ; cover zero term 
8565 06 00			ld b,0 
8567 4d				ld c,l 
8568 e1				pop hl 
8569				;ex de, hl 
8569				if DEBUG_STORESE 
8569					DMARK "SCa" 
8569 f5				push af  
856a 3a 7e 85			ld a, (.dmark)  
856d 32 7a ee			ld (debug_mark),a  
8570 3a 7f 85			ld a, (.dmark+1)  
8573 32 7b ee			ld (debug_mark+1),a  
8576 3a 80 85			ld a, (.dmark+2)  
8579 32 7c ee			ld (debug_mark+2),a  
857c 18 03			jr .pastdmark  
857e ..			.dmark: db "SCa"  
8581 f1			.pastdmark: pop af  
8582			endm  
# End of macro DMARK
8582					;push af 
8582					;ld a, 'a' 
8582					;ld (debug_mark),a 
8582					;pop af 
8582					CALLMONITOR 
8582 cd 7b 91			call break_point_state  
8585				endm  
# End of macro CALLMONITOR
8585				endif 
8585 ed b0			ldir    ; copy zero term string 
8587				if DEBUG_STORESE 
8587					DMARK "SCA" 
8587 f5				push af  
8588 3a 9c 85			ld a, (.dmark)  
858b 32 7a ee			ld (debug_mark),a  
858e 3a 9d 85			ld a, (.dmark+1)  
8591 32 7b ee			ld (debug_mark+1),a  
8594 3a 9e 85			ld a, (.dmark+2)  
8597 32 7c ee			ld (debug_mark+2),a  
859a 18 03			jr .pastdmark  
859c ..			.dmark: db "SCA"  
859f f1			.pastdmark: pop af  
85a0			endm  
# End of macro DMARK
85a0					CALLMONITOR 
85a0 cd 7b 91			call break_point_state  
85a3				endm  
# End of macro CALLMONITOR
85a3				endif 
85a3			 
85a3				; write file header page 
85a3			 
85a3 2a 63 eb			ld hl,(store_tmppageid) 
85a6 11 65 eb			ld de, store_page 
85a9				if DEBUG_STORESE 
85a9					DMARK "SCb" 
85a9 f5				push af  
85aa 3a be 85			ld a, (.dmark)  
85ad 32 7a ee			ld (debug_mark),a  
85b0 3a bf 85			ld a, (.dmark+1)  
85b3 32 7b ee			ld (debug_mark+1),a  
85b6 3a c0 85			ld a, (.dmark+2)  
85b9 32 7c ee			ld (debug_mark+2),a  
85bc 18 03			jr .pastdmark  
85be ..			.dmark: db "SCb"  
85c1 f1			.pastdmark: pop af  
85c2			endm  
# End of macro DMARK
85c2					;push af 
85c2					;ld a, 'b' 
85c2					;ld (debug_mark),a 
85c2					;pop af 
85c2					CALLMONITOR 
85c2 cd 7b 91			call break_point_state  
85c5				endm  
# End of macro CALLMONITOR
85c5				endif 
85c5 cd 16 81			call storage_write_block 
85c8			 
85c8 3a 5e eb			ld a, (store_tmpid) 
85cb 6f				ld l, a 
85cc 26 00			ld h,0 
85ce				if DEBUG_STORESE 
85ce					DMARK "SCz" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 7a ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 7b ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 7c ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCz"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 7b 91			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea c9				ret 
85eb				 
85eb			 
85eb			 
85eb			; 
85eb			; Read File 
85eb			; 
85eb			; h - file id to locate 
85eb			; l - extent to locate 
85eb			; de - pointer to string to read into 
85eb			; 
85eb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85eb			storage_read: 
85eb d5				push de 
85ec			 
85ec			; TODO BUG the above push is it popped before the RET Z? 
85ec			 
85ec			; TODO how to handle multiple part blocks 
85ec			 
85ec				; locate file extent to read 
85ec			 
85ec 5c				ld e, h 
85ed 55				ld d, l 
85ee 21 40 00			ld hl, STORE_BLOCK_PHY 
85f1				if DEBUG_STORESE 
85f1					DMARK "SRE" 
85f1 f5				push af  
85f2 3a 06 86			ld a, (.dmark)  
85f5 32 7a ee			ld (debug_mark),a  
85f8 3a 07 86			ld a, (.dmark+1)  
85fb 32 7b ee			ld (debug_mark+1),a  
85fe 3a 08 86			ld a, (.dmark+2)  
8601 32 7c ee			ld (debug_mark+2),a  
8604 18 03			jr .pastdmark  
8606 ..			.dmark: db "SRE"  
8609 f1			.pastdmark: pop af  
860a			endm  
# End of macro DMARK
860a					CALLMONITOR 
860a cd 7b 91			call break_point_state  
860d				endm  
# End of macro CALLMONITOR
860d				endif 
860d cd c7 83			call storage_findnextid 
8610			 
8610				if DEBUG_STORESE 
8610					DMARK "SRf" 
8610 f5				push af  
8611 3a 25 86			ld a, (.dmark)  
8614 32 7a ee			ld (debug_mark),a  
8617 3a 26 86			ld a, (.dmark+1)  
861a 32 7b ee			ld (debug_mark+1),a  
861d 3a 27 86			ld a, (.dmark+2)  
8620 32 7c ee			ld (debug_mark+2),a  
8623 18 03			jr .pastdmark  
8625 ..			.dmark: db "SRf"  
8628 f1			.pastdmark: pop af  
8629			endm  
# End of macro DMARK
8629					CALLMONITOR 
8629 cd 7b 91			call break_point_state  
862c				endm  
# End of macro CALLMONITOR
862c				endif 
862c cd e0 89			call ishlzero 
862f			;	ld a, l 
862f			;	add h 
862f			;	cp 0 
862f c8				ret z			; block not found so EOF 
8630			 
8630				; hl contains page number to load 
8630 d1				pop de   ; get storage 
8631 d5				push de 
8632				if DEBUG_STORESE 
8632					DMARK "SRg" 
8632 f5				push af  
8633 3a 47 86			ld a, (.dmark)  
8636 32 7a ee			ld (debug_mark),a  
8639 3a 48 86			ld a, (.dmark+1)  
863c 32 7b ee			ld (debug_mark+1),a  
863f 3a 49 86			ld a, (.dmark+2)  
8642 32 7c ee			ld (debug_mark+2),a  
8645 18 03			jr .pastdmark  
8647 ..			.dmark: db "SRg"  
864a f1			.pastdmark: pop af  
864b			endm  
# End of macro DMARK
864b					CALLMONITOR 
864b cd 7b 91			call break_point_state  
864e				endm  
# End of macro CALLMONITOR
864e				endif 
864e cd b1 80			call storage_read_block 
8651			 
8651			 
8651			; TODO if block has no zeros then need to read next block  
8651			 
8651			 
8651					 
8651 e1				pop hl 		 ; return start of data to show as not EOF 
8652 23				inc hl   ; past file id 
8653 23				inc hl   ; past ext 
8654				if DEBUG_STORESE 
8654					DMARK "SRe" 
8654 f5				push af  
8655 3a 69 86			ld a, (.dmark)  
8658 32 7a ee			ld (debug_mark),a  
865b 3a 6a 86			ld a, (.dmark+1)  
865e 32 7b ee			ld (debug_mark+1),a  
8661 3a 6b 86			ld a, (.dmark+2)  
8664 32 7c ee			ld (debug_mark+2),a  
8667 18 03			jr .pastdmark  
8669 ..			.dmark: db "SRe"  
866c f1			.pastdmark: pop af  
866d			endm  
# End of macro DMARK
866d					CALLMONITOR 
866d cd 7b 91			call break_point_state  
8670				endm  
# End of macro CALLMONITOR
8670				endif 
8670 c9					ret 
8671			 
8671			 
8671			 
8671			; 
8671			; Append File 
8671			; 
8671			; hl - file id to locate 
8671			; de - pointer to (multi block) string to write 
8671			 
8671			 
8671			storage_append: 
8671				; hl -  file id to append to 
8671				; de - string to append 
8671			 
8671 d5				push de 
8672				 
8672				if DEBUG_STORESE 
8672					DMARK "AP1" 
8672 f5				push af  
8673 3a 87 86			ld a, (.dmark)  
8676 32 7a ee			ld (debug_mark),a  
8679 3a 88 86			ld a, (.dmark+1)  
867c 32 7b ee			ld (debug_mark+1),a  
867f 3a 89 86			ld a, (.dmark+2)  
8682 32 7c ee			ld (debug_mark+2),a  
8685 18 03			jr .pastdmark  
8687 ..			.dmark: db "AP1"  
868a f1			.pastdmark: pop af  
868b			endm  
# End of macro DMARK
868b					CALLMONITOR 
868b cd 7b 91			call break_point_state  
868e				endm  
# End of macro CALLMONITOR
868e				endif 
868e			 
868e 7d				ld a, l 
868f 32 5e eb			ld (store_tmpid), a 
8692			 
8692				; get file header  
8692			 
8692 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8694 3a 5e eb			ld a, (store_tmpid) 
8697 5f				ld e, a 
8698			 
8698 21 40 00				ld hl, STORE_BLOCK_PHY 
869b cd c7 83				call storage_findnextid 
869e			 
869e 22 63 eb			ld (store_tmppageid), hl 
86a1			 
86a1				; TODO handle file id not found 
86a1			 
86a1				if DEBUG_STORESE 
86a1					DMARK "AP2" 
86a1 f5				push af  
86a2 3a b6 86			ld a, (.dmark)  
86a5 32 7a ee			ld (debug_mark),a  
86a8 3a b7 86			ld a, (.dmark+1)  
86ab 32 7b ee			ld (debug_mark+1),a  
86ae 3a b8 86			ld a, (.dmark+2)  
86b1 32 7c ee			ld (debug_mark+2),a  
86b4 18 03			jr .pastdmark  
86b6 ..			.dmark: db "AP2"  
86b9 f1			.pastdmark: pop af  
86ba			endm  
# End of macro DMARK
86ba					CALLMONITOR 
86ba cd 7b 91			call break_point_state  
86bd				endm  
# End of macro CALLMONITOR
86bd				endif 
86bd			 
86bd				; update file extent count 
86bd			 
86bd 11 65 eb			ld de, store_page 
86c0			 
86c0 cd b1 80			call storage_read_block 
86c3			 
86c3				if DEBUG_STORESE 
86c3					DMARK "AP3" 
86c3 f5				push af  
86c4 3a d8 86			ld a, (.dmark)  
86c7 32 7a ee			ld (debug_mark),a  
86ca 3a d9 86			ld a, (.dmark+1)  
86cd 32 7b ee			ld (debug_mark+1),a  
86d0 3a da 86			ld a, (.dmark+2)  
86d3 32 7c ee			ld (debug_mark+2),a  
86d6 18 03			jr .pastdmark  
86d8 ..			.dmark: db "AP3"  
86db f1			.pastdmark: pop af  
86dc			endm  
# End of macro DMARK
86dc					CALLMONITOR 
86dc cd 7b 91			call break_point_state  
86df				endm  
# End of macro CALLMONITOR
86df				endif 
86df			;	ld (store_tmppageid), hl 
86df			 
86df 3a 67 eb			ld a, (store_page+2) 
86e2 3c				inc a 
86e3 32 67 eb			ld (store_page+2), a 
86e6 32 5d eb			ld (store_tmpext), a 
86e9				 
86e9				if DEBUG_STORESE 
86e9					DMARK "AP3" 
86e9 f5				push af  
86ea 3a fe 86			ld a, (.dmark)  
86ed 32 7a ee			ld (debug_mark),a  
86f0 3a ff 86			ld a, (.dmark+1)  
86f3 32 7b ee			ld (debug_mark+1),a  
86f6 3a 00 87			ld a, (.dmark+2)  
86f9 32 7c ee			ld (debug_mark+2),a  
86fc 18 03			jr .pastdmark  
86fe ..			.dmark: db "AP3"  
8701 f1			.pastdmark: pop af  
8702			endm  
# End of macro DMARK
8702					CALLMONITOR 
8702 cd 7b 91			call break_point_state  
8705				endm  
# End of macro CALLMONITOR
8705				endif 
8705 2a 63 eb			ld hl, (store_tmppageid) 
8708 11 65 eb			ld de, store_page 
870b cd 16 81			call storage_write_block 
870e			 
870e				; find free block 
870e			 
870e 11 00 00			ld de, 0			 ; file extent to locate 
8711			 
8711 21 40 00				ld hl, STORE_BLOCK_PHY 
8714 cd c7 83				call storage_findnextid 
8717			 
8717					; TODO handle no space left 
8717					 
8717 22 63 eb				ld (store_tmppageid), hl 
871a			 
871a				if DEBUG_STORESE 
871a					DMARK "AP4" 
871a f5				push af  
871b 3a 2f 87			ld a, (.dmark)  
871e 32 7a ee			ld (debug_mark),a  
8721 3a 30 87			ld a, (.dmark+1)  
8724 32 7b ee			ld (debug_mark+1),a  
8727 3a 31 87			ld a, (.dmark+2)  
872a 32 7c ee			ld (debug_mark+2),a  
872d 18 03			jr .pastdmark  
872f ..			.dmark: db "AP4"  
8732 f1			.pastdmark: pop af  
8733			endm  
# End of macro DMARK
8733					CALLMONITOR 
8733 cd 7b 91			call break_point_state  
8736				endm  
# End of macro CALLMONITOR
8736				endif 
8736					; init the buffer with zeros so we can id if the buffer is full or not 
8736			 
8736 e5					push hl 
8737 c5					push bc 
8738			 
8738 21 65 eb				ld hl, store_page 
873b 06 40				ld b, STORE_BLOCK_PHY 
873d 3e 00				ld a, 0 
873f 77			.zeroblock:	ld (hl), a 
8740 23					inc hl 
8741 10 fc				djnz .zeroblock 
8743			 
8743 c1					pop bc 
8744 e1					pop hl 
8745			 
8745					; construct block 
8745			 
8745 3a 5e eb				ld a, (store_tmpid) 
8748 32 65 eb				ld (store_page), a   ; file id 
874b 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
874e 32 66 eb				ld (store_page+1), a 
8751			 
8751 e1					pop hl    ; get string to write 
8752 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8754 11 67 eb				ld de, store_page+2 
8757			 
8757				if DEBUG_STORESE 
8757					DMARK "AP5" 
8757 f5				push af  
8758 3a 6c 87			ld a, (.dmark)  
875b 32 7a ee			ld (debug_mark),a  
875e 3a 6d 87			ld a, (.dmark+1)  
8761 32 7b ee			ld (debug_mark+1),a  
8764 3a 6e 87			ld a, (.dmark+2)  
8767 32 7c ee			ld (debug_mark+2),a  
876a 18 03			jr .pastdmark  
876c ..			.dmark: db "AP5"  
876f f1			.pastdmark: pop af  
8770			endm  
# End of macro DMARK
8770					CALLMONITOR 
8770 cd 7b 91			call break_point_state  
8773				endm  
# End of macro CALLMONITOR
8773				endif 
8773			 
8773			 
8773			 
8773					; fill buffer with data until end of string or full block 
8773			 
8773 7e			.appd:		ld a, (hl) 
8774 12					ld (de), a 
8775 fe 00				cp 0 
8777 28 04				jr z, .appdone 
8779 23					inc hl 
877a 13					inc de 
877b 10 f6				djnz .appd 
877d			 
877d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
877e f5					push af   		; save last byte dumped 
877f			 
877f			 
877f 2a 63 eb			ld hl, (store_tmppageid) 
8782 11 65 eb			ld de, store_page 
8785				if DEBUG_STORESE 
8785					DMARK "AP6" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 7a ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 7b ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 7c ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "AP6"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 7b 91			call break_point_state  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 cd 16 81				call storage_write_block 
87a4			 
87a4			 
87a4				; was that a full block of data written? 
87a4				; any more to write out? 
87a4			 
87a4				; if yes then set vars and jump to start of function again 
87a4			 
87a4 f1					pop af 
87a5 d1					pop de 
87a6			 
87a6 fe 00				cp 0		 ; no, string was fully written 
87a8 c8					ret z 
87a9			 
87a9					; setup vars for next cycle 
87a9			 
87a9 3a 5e eb				ld a, (store_tmpid) 
87ac 6f					ld l, a 
87ad 26 00				ld h, 0 
87af			 
87af c3 71 86			 	jp storage_append	 ; yes, need to write out some more 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			if DEBUG_STORECF 
87b2			storageput:	 
87b2					ret 
87b2			storageread: 
87b2					ld hl, store_page 
87b2					ld b, 200 
87b2					ld a,0 
87b2			.src:		ld (hl),a 
87b2					inc hl 
87b2					djnz .src 
87b2					 
87b2			 
87b2					ld de, 0 
87b2					ld bc, 1 
87b2					ld hl, store_page 
87b2					call cfRead 
87b2			 
87b2				call cfGetError 
87b2				ld hl,scratch 
87b2				call hexout 
87b2				ld hl, scratch+2 
87b2				ld a, 0 
87b2				ld (hl),a 
87b2				ld de, scratch 
87b2				ld a,display_row_1 
87b2				call str_at_display 
87b2				call update_display 
87b2			 
87b2					ld hl, store_page 
87b2					ld (os_cur_ptr),hl 
87b2			 
87b2					ret 
87b2			endif 
87b2			 
87b2			 
87b2			; Clear out the main buffer store (used to remove junk before writing a new block) 
87b2			 
87b2			storage_clear_page: 
87b2 e5				push hl 
87b3 d5				push de 
87b4 c5				push bc 
87b5 21 65 eb			ld hl, store_page 
87b8 3e 00			ld a, 0 
87ba 77				ld (hl), a 
87bb			 
87bb 11 66 eb			ld de, store_page+1 
87be 01 40 00			ld bc, STORE_BLOCK_PHY 
87c1			 
87c1 ed b0			ldir 
87c3				 
87c3 c1				pop bc 
87c4 d1				pop de 
87c5 e1				pop hl 
87c6 c9				ret 
87c7			 
87c7			; eof 
# End of file firmware_storage.asm
87c7			  
87c7			; support routines for above hardware abstraction layer  
87c7			  
87c7			include "firmware_general.asm"        ; general support functions  
87c7			 
87c7			 
87c7			 
87c7			; Delay loops 
87c7			 
87c7			 
87c7			 
87c7			aDelayInMS: 
87c7 c5				push bc 
87c8 47				ld b,a 
87c9			msdelay: 
87c9 c5				push bc 
87ca				 
87ca			 
87ca 01 41 00			ld bc,041h 
87cd cd e5 87			call delayloop 
87d0 c1				pop bc 
87d1 05				dec b 
87d2 20 f5			jr nz,msdelay 
87d4			 
87d4			;if CPU_CLOCK_8MHZ 
87d4			;msdelay8: 
87d4			;	push bc 
87d4			;	 
87d4			; 
87d4			;	ld bc,041h 
87d4			;	call delayloop 
87d4			;	pop bc 
87d4			;	dec b 
87d4			;	jr nz,msdelay8 
87d4			;endif 
87d4			 
87d4			 
87d4 c1				pop bc 
87d5 c9				ret 
87d6			 
87d6			 
87d6			delay250ms: 
87d6				;push de 
87d6 01 00 40			ld bc, 04000h 
87d9 c3 e5 87			jp delayloop 
87dc			delay500ms: 
87dc				;push de 
87dc 01 00 80			ld bc, 08000h 
87df c3 e5 87			jp delayloop 
87e2			delay1s: 
87e2				;push bc 
87e2			   ; Clobbers A, d and e 
87e2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87e5			delayloop: 
87e5 c5			    push bc 
87e6			 
87e6			if BASE_CPM 
87e6				ld bc, CPM_DELAY_TUNE 
87e6			.cpmloop: 
87e6				push bc 
87e6			 
87e6			endif 
87e6			 
87e6			 
87e6			 
87e6			delayloopi: 
87e6			;	push bc 
87e6			;.dl: 
87e6 cb 47		    bit     0,a    	; 8 
87e8 cb 47		    bit     0,a    	; 8 
87ea cb 47		    bit     0,a    	; 8 
87ec e6 ff		    and     255  	; 7 
87ee 0b			    dec     bc      	; 6 
87ef 79			    ld      a,c     	; 4 
87f0 b0			    or      b     	; 4 
87f1 c2 e6 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
87f4			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
87f4				;pop de 
87f4			;pop bc 
87f4			 
87f4			if BASE_CPM 
87f4				pop bc 
87f4				 
87f4			    dec     bc      	; 6 
87f4			    ld      a,c     	; 4 
87f4			    or      b     	; 4 
87f4			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
87f4				 
87f4			 
87f4			endif 
87f4			;if CPU_CLOCK_8MHZ 
87f4			;    pop bc 
87f4			;    push bc 
87f4			;.dl8: 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    and     255  	; 7 
87f4			;    dec     bc      	; 6 
87f4			;    ld      a,c     	; 4 
87f4			;    or      b     	; 4 
87f4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87f4			;endif 
87f4			 
87f4			;if CPU_CLOCK_10MHZ 
87f4			;    pop bc 
87f4			;    push bc 
87f4			;.dl8: 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    and     255  	; 7 
87f4			;    dec     bc      	; 6 
87f4			;    ld      a,c     	; 4 
87f4			;    or      b     	; 4 
87f4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87f4			;endif 
87f4 c1			    pop bc 
87f5			 
87f5 c9				ret 
87f6			 
87f6			 
87f6			 
87f6			; eof 
# End of file firmware_general.asm
87f6			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
87f6			; display routines that use the physical hardware abstraction layer 
87f6			 
87f6			 
87f6			; TODO windowing? 
87f6			 
87f6			; TODO scroll line up 
87f6			 
87f6			scroll_up: 
87f6			 
87f6 e5				push hl 
87f7 d5				push de 
87f8 c5				push bc 
87f9			 
87f9				; get frame buffer  
87f9			 
87f9 2a db eb			ld hl, (display_fb_active) 
87fc e5				push hl    ; future de destination 
87fd			 
87fd 11 28 00			ld  de, display_cols 
8800 19				add hl, de 
8801			 
8801 d1				pop de 
8802			 
8802				;ex de, hl 
8802 01 9f 00			ld bc, display_fb_len -1  
8805			;if DEBUG_FORTH_WORDS 
8805			;	DMARK "SCL" 
8805			;	CALLMONITOR 
8805			;endif	 
8805 ed b0			ldir 
8807			 
8807				; wipe bottom row 
8807			 
8807			 
8807 2a db eb			ld hl, (display_fb_active) 
880a 11 a0 00			ld de, display_cols*display_rows 
880d 19				add hl, de 
880e 06 28			ld b, display_cols 
8810 3e 20			ld a, ' ' 
8812			.scwipe: 
8812 77				ld (hl), a 
8813 2b				dec hl 
8814 10 fc			djnz .scwipe 
8816			 
8816				;pop hl 
8816			 
8816 c1				pop bc 
8817 d1				pop de 
8818 e1				pop hl 
8819			 
8819 c9				ret 
881a			 
881a			 
881a			scroll_upo: 
881a 11 00 00			ld de, display_row_1 
881d 21 28 00		 	ld hl, display_row_2 
8820 01 28 00			ld bc, display_cols 
8823 ed b0			ldir 
8825 11 28 00			ld de, display_row_2 
8828 21 50 00		 	ld hl, display_row_3 
882b 01 28 00			ld bc, display_cols 
882e ed b0			ldir 
8830 11 50 00			ld de, display_row_3 
8833 21 78 00		 	ld hl, display_row_4 
8836 01 28 00			ld bc, display_cols 
8839 ed b0			ldir 
883b			 
883b			; TODO clear row 4 
883b			 
883b c9				ret 
883c				 
883c			scroll_down: 
883c 11 78 00			ld de, display_row_4 
883f 21 50 00		 	ld hl, display_row_3 
8842 01 28 00			ld bc, display_cols 
8845 ed b0			ldir 
8847 11 50 00			ld de, display_row_3 
884a 21 28 00		 	ld hl, display_row_2 
884d 01 28 00			ld bc, display_cols 
8850 ed b0			ldir 
8852 11 28 00			ld de, display_row_2 
8855 21 00 00		 	ld hl, display_row_1 
8858 01 28 00			ld bc, display_cols 
885b ed b0			ldir 
885d			; TODO clear row 1 
885d c9				ret 
885e			 
885e			 
885e			 
885e			 
885e			 
885e			; clear active frame buffer 
885e			 
885e			clear_display: 
885e 3e 20			ld a, ' ' 
8860 c3 63 88			jp fill_display 
8863			 
8863			; fill active frame buffer with a char in A 
8863			 
8863			fill_display: 
8863 06 a0			ld b,display_fb_len 
8865 2a db eb			ld hl, (display_fb_active) 
8868 77			.fd1:	ld (hl),a 
8869 23				inc hl 
886a 10 fc			djnz .fd1 
886c 23				inc hl 
886d 3e 00			ld a,0 
886f 77				ld (hl),a 
8870			 
8870			 
8870 c9				ret 
8871			; Write string (DE) at pos (A) to active frame buffer 
8871			 
8871 2a db eb		str_at_display:    ld hl,(display_fb_active) 
8874 06 00					ld b,0 
8876 4f					ld c,a 
8877 09					add hl,bc 
8878 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8879 b7			            OR   A              ;Null terminator? 
887a c8			            RET  Z              ;Yes, so finished 
887b 77					ld (hl),a 
887c 23				inc hl 
887d 13			            INC  DE             ;Point to next character 
887e 18 f8		            JR   .sad1     ;Repeat 
8880 c9					ret 
8881			 
8881			; using current frame buffer write to physical display 
8881			 
8881			update_display: 
8881 e5				push hl 
8882 2a db eb			ld hl, (display_fb_active) 
8885 cd 13 d4			call write_display 
8888 e1				pop hl 
8889 c9				ret 
888a			 
888a			; TODO scrolling 
888a			 
888a			 
888a			; move cursor right one char 
888a			cursor_right: 
888a			 
888a				; TODO shift right 
888a				; TODO if beyond max col 
888a				; TODO       cursor_next_line 
888a			 
888a c9				ret 
888b			 
888b			 
888b			cursor_next_line: 
888b				; TODO first char 
888b				; TODO line down 
888b				; TODO if past last row 
888b				; TODO    scroll up 
888b			 
888b c9				ret 
888c			 
888c			cursor_left: 
888c				; TODO shift left 
888c				; TODO if beyond left  
888c				; TODO     cursor prev line 
888c				 
888c c9				ret 
888d			 
888d			cursor_prev_line: 
888d				; TODO last char 
888d				; TODO line up 
888d				; TODO if past first row 
888d				; TODO   scroll down 
888d			 
888d c9				ret 
888e			 
888e			 
888e			cout: 
888e				; A - char 
888e c9				ret 
888f			 
888f			; eof 
888f			 
# End of file firmware_display.asm
888f			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
888f			; random number generators 
888f			 
888f			 
888f			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
888f			 
888f			 
888f			;-----> Generate a random number 
888f			; output a=answer 0<=a<=255 
888f			; all registers are preserved except: af 
888f			random: 
888f e5			        push    hl 
8890 d5			        push    de 
8891 2a bd eb		        ld      hl,(randData) 
8894 ed 5f		        ld      a,r 
8896 57			        ld      d,a 
8897 5e			        ld      e,(hl) 
8898 19			        add     hl,de 
8899 85			        add     a,l 
889a ac			        xor     h 
889b 22 bd eb		        ld      (randData),hl 
889e d1			        pop     de 
889f e1			        pop     hl 
88a0 c9			        ret 
88a1			 
88a1			 
88a1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
88a1			 
88a1			 
88a1			 
88a1			;------LFSR------ 
88a1			;James Montelongo 
88a1			;optimized by Spencer Putt 
88a1			;out: 
88a1			; a = 8 bit random number 
88a1			RandLFSR: 
88a1 21 c3 eb		        ld hl,LFSRSeed+4 
88a4 5e			        ld e,(hl) 
88a5 23			        inc hl 
88a6 56			        ld d,(hl) 
88a7 23			        inc hl 
88a8 4e			        ld c,(hl) 
88a9 23			        inc hl 
88aa 7e			        ld a,(hl) 
88ab 47			        ld b,a 
88ac cb 13		        rl e  
88ae cb 12			rl d 
88b0 cb 11		        rl c  
88b2 17				rla 
88b3 cb 13		        rl e  
88b5 cb 12			rl d 
88b7 cb 11		        rl c  
88b9 17				rla 
88ba cb 13		        rl e  
88bc cb 12			rl d 
88be cb 11		        rl c  
88c0 17				rla 
88c1 67			        ld h,a 
88c2 cb 13		        rl e  
88c4 cb 12			rl d 
88c6 cb 11		        rl c  
88c8 17				rla 
88c9 a8			        xor b 
88ca cb 13		        rl e  
88cc cb 12			rl d 
88ce ac			        xor h 
88cf a9			        xor c 
88d0 aa			        xor d 
88d1 21 c5 eb		        ld hl,LFSRSeed+6 
88d4 11 c6 eb		        ld de,LFSRSeed+7 
88d7 01 07 00		        ld bc,7 
88da ed b8		        lddr 
88dc 12			        ld (de),a 
88dd c9			        ret 
88de			 
88de			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
88de			 
88de			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
88de			 
88de			 
88de			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
88de			 
88de			prng16: 
88de			;Inputs: 
88de			;   (seed1) contains a 16-bit seed value 
88de			;   (seed2) contains a NON-ZERO 16-bit seed value 
88de			;Outputs: 
88de			;   HL is the result 
88de			;   BC is the result of the LCG, so not that great of quality 
88de			;   DE is preserved 
88de			;Destroys: 
88de			;   AF 
88de			;cycle: 4,294,901,760 (almost 4.3 billion) 
88de			;160cc 
88de			;26 bytes 
88de 2a b7 eb		    ld hl,(seed1) 
88e1 44			    ld b,h 
88e2 4d			    ld c,l 
88e3 29			    add hl,hl 
88e4 29			    add hl,hl 
88e5 2c			    inc l 
88e6 09			    add hl,bc 
88e7 22 b7 eb		    ld (seed1),hl 
88ea 2a b5 eb		    ld hl,(seed2) 
88ed 29			    add hl,hl 
88ee 9f			    sbc a,a 
88ef e6 2d		    and %00101101 
88f1 ad			    xor l 
88f2 6f			    ld l,a 
88f3 22 b5 eb		    ld (seed2),hl 
88f6 09			    add hl,bc 
88f7 c9			    ret 
88f8			 
88f8			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
88f8			 
88f8			rand32: 
88f8			;Inputs: 
88f8			;   (seed1_0) holds the lower 16 bits of the first seed 
88f8			;   (seed1_1) holds the upper 16 bits of the first seed 
88f8			;   (seed2_0) holds the lower 16 bits of the second seed 
88f8			;   (seed2_1) holds the upper 16 bits of the second seed 
88f8			;   **NOTE: seed2 must be non-zero 
88f8			;Outputs: 
88f8			;   HL is the result 
88f8			;   BC,DE can be used as lower quality values, but are not independent of HL. 
88f8			;Destroys: 
88f8			;   AF 
88f8			;Tested and passes all CAcert tests 
88f8			;Uses a very simple 32-bit LCG and 32-bit LFSR 
88f8			;it has a period of 18,446,744,069,414,584,320 
88f8			;roughly 18.4 quintillion. 
88f8			;LFSR taps: 0,2,6,7  = 11000101 
88f8			;291cc 
88f8			;seed1_0=$+1 
88f8			;    ld hl,12345 
88f8			;seed1_1=$+1 
88f8			;    ld de,6789 
88f8			;    ld b,h 
88f8			;    ld c,l 
88f8			;    add hl,hl \ rl e \ rl d 
88f8			;    add hl,hl \ rl e \ rl d 
88f8			;    inc l 
88f8			;    add hl,bc 
88f8			;    ld (seed1_0),hl 
88f8			;    ld hl,(seed1_1) 
88f8			;    adc hl,de 
88f8			;    ld (seed1_1),hl 
88f8			;    ex de,hl 
88f8			;seed2_0=$+1 
88f8			;    ld hl,9876 
88f8			;seed2_1=$+1 
88f8			;    ld bc,54321 
88f8			;    add hl,hl \ rl c \ rl b 
88f8			;    ld (seed2_1),bc 
88f8			;    sbc a,a 
88f8			;    and %11000101 
88f8			;    xor l 
88f8			;    ld l,a 
88f8			;    ld (seed2_0),hl 
88f8			;    ex de,hl 
88f8			;    add hl,bc 
88f8			;    ret 
88f8			; 
88f8			 
88f8			; 16-bit xorshift pseudorandom number generator by John Metcalf 
88f8			; 20 bytes, 86 cycles (excluding ret) 
88f8			 
88f8			; returns   hl = pseudorandom number 
88f8			; corrupts   a 
88f8			 
88f8			; generates 16-bit pseudorandom numbers with a period of 65535 
88f8			; using the xorshift method: 
88f8			 
88f8			; hl ^= hl << 7 
88f8			; hl ^= hl >> 9 
88f8			; hl ^= hl << 8 
88f8			 
88f8			; some alternative shift triplets which also perform well are: 
88f8			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
88f8			 
88f8			;  org 32768 
88f8			 
88f8			xrnd: 
88f8 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
88fb 3e 00		  ld a,0 
88fd bd			  cp l 
88fe 20 02		  jr nz, .xrnd1 
8900 2e 01		  ld l, 1 
8902			.xrnd1: 
8902			 
8902 7c			  ld a,h 
8903 1f			  rra 
8904 7d			  ld a,l 
8905 1f			  rra 
8906 ac			  xor h 
8907 67			  ld h,a 
8908 7d			  ld a,l 
8909 1f			  rra 
890a 7c			  ld a,h 
890b 1f			  rra 
890c ad			  xor l 
890d 6f			  ld l,a 
890e ac			  xor h 
890f 67			  ld h,a 
8910			 
8910 22 bb eb		  ld (xrandc),hl 
8913			 
8913 c9			  ret 
8914			;  
8914			 
8914			 
8914			;;;; int maths 
8914			 
8914			; https://map.grauw.nl/articles/mult_div_shifts.php 
8914			; Divide 16-bit values (with 16-bit result) 
8914			; In: Divide BC by divider DE 
8914			; Out: BC = result, HL = rest 
8914			; 
8914			Div16: 
8914 21 00 00		    ld hl,0 
8917 78			    ld a,b 
8918 06 08		    ld b,8 
891a			Div16_Loop1: 
891a 17			    rla 
891b ed 6a		    adc hl,hl 
891d ed 52		    sbc hl,de 
891f 30 01		    jr nc,Div16_NoAdd1 
8921 19			    add hl,de 
8922			Div16_NoAdd1: 
8922 10 f6		    djnz Div16_Loop1 
8924 17			    rla 
8925 2f			    cpl 
8926 47			    ld b,a 
8927 79			    ld a,c 
8928 48			    ld c,b 
8929 06 08		    ld b,8 
892b			Div16_Loop2: 
892b 17			    rla 
892c ed 6a		    adc hl,hl 
892e ed 52		    sbc hl,de 
8930 30 01		    jr nc,Div16_NoAdd2 
8932 19			    add hl,de 
8933			Div16_NoAdd2: 
8933 10 f6		    djnz Div16_Loop2 
8935 17			    rla 
8936 2f			    cpl 
8937 41			    ld b,c 
8938 4f			    ld c,a 
8939 c9			ret 
893a			 
893a			 
893a			;http://z80-heaven.wikidot.com/math 
893a			; 
893a			;Inputs: 
893a			;     DE and A are factors 
893a			;Outputs: 
893a			;     A is not changed 
893a			;     B is 0 
893a			;     C is not changed 
893a			;     DE is not changed 
893a			;     HL is the product 
893a			;Time: 
893a			;     342+6x 
893a			; 
893a			Mult16: 
893a			 
893a 06 08		     ld b,8          ;7           7 
893c 21 00 00		     ld hl,0         ;10         10 
893f 29			       add hl,hl     ;11*8       88 
8940 07			       rlca          ;4*8        32 
8941 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8943 19			         add hl,de   ;--         -- 
8944 10 f9		       djnz $-5      ;13*7+8     99 
8946 c9			ret 
8947			 
8947			; 
8947			; Square root of 16-bit value 
8947			; In:  HL = value 
8947			; Out:  D = result (rounded down) 
8947			; 
8947			;Sqr16: 
8947			;    ld de,#0040 
8947			;    ld a,l 
8947			;    ld l,h 
8947			;    ld h,d 
8947			;    or a 
8947			;    ld b,8 
8947			;Sqr16_Loop: 
8947			;    sbc hl,de 
8947			;    jr nc,Sqr16_Skip 
8947			;    add hl,de 
8947			;Sqr16_Skip: 
8947			;    ccf 
8947			;    rl d 
8947			;    add a,a 
8947			;    adc hl,hl 
8947			;    add a,a 
8947			;    adc hl,hl 
8947			;    djnz Sqr16_Loop 
8947			;    ret 
8947			; 
8947			; 
8947			; Divide 8-bit values 
8947			; In: Divide E by divider C 
8947			; Out: A = result, B = rest 
8947			; 
8947			Div8: 
8947 af			    xor a 
8948 06 08		    ld b,8 
894a			Div8_Loop: 
894a cb 13		    rl e 
894c 17			    rla 
894d 91			    sub c 
894e 30 01		    jr nc,Div8_NoAdd 
8950 81			    add a,c 
8951			Div8_NoAdd: 
8951 10 f7		    djnz Div8_Loop 
8953 47			    ld b,a 
8954 7b			    ld a,e 
8955 17			    rla 
8956 2f			    cpl 
8957 c9			    ret 
8958			 
8958			; 
8958			; Multiply 8-bit value with a 16-bit value (unrolled) 
8958			; In: Multiply A with DE 
8958			; Out: HL = result 
8958			; 
8958			Mult12U: 
8958 2e 00		    ld l,0 
895a 87			    add a,a 
895b 30 01		    jr nc,Mult12U_NoAdd0 
895d 19			    add hl,de 
895e			Mult12U_NoAdd0: 
895e 29			    add hl,hl 
895f 87			    add a,a 
8960 30 01		    jr nc,Mult12U_NoAdd1 
8962 19			    add hl,de 
8963			Mult12U_NoAdd1: 
8963 29			    add hl,hl 
8964 87			    add a,a 
8965 30 01		    jr nc,Mult12U_NoAdd2 
8967 19			    add hl,de 
8968			Mult12U_NoAdd2: 
8968 29			    add hl,hl 
8969 87			    add a,a 
896a 30 01		    jr nc,Mult12U_NoAdd3 
896c 19			    add hl,de 
896d			Mult12U_NoAdd3: 
896d 29			    add hl,hl 
896e 87			    add a,a 
896f 30 01		    jr nc,Mult12U_NoAdd4 
8971 19			    add hl,de 
8972			Mult12U_NoAdd4: 
8972 29			    add hl,hl 
8973 87			    add a,a 
8974 30 01		    jr nc,Mult12U_NoAdd5 
8976 19			    add hl,de 
8977			Mult12U_NoAdd5: 
8977 29			    add hl,hl 
8978 87			    add a,a 
8979 30 01		    jr nc,Mult12U_NoAdd6 
897b 19			    add hl,de 
897c			Mult12U_NoAdd6: 
897c 29			    add hl,hl 
897d 87			    add a,a 
897e d0			    ret nc 
897f 19			    add hl,de 
8980 c9			    ret 
8981			 
8981			; 
8981			; Multiply 8-bit value with a 16-bit value (right rotating) 
8981			; In: Multiply A with DE 
8981			;      Put lowest value in A for most efficient calculation 
8981			; Out: HL = result 
8981			; 
8981			Mult12R: 
8981 21 00 00		    ld hl,0 
8984			Mult12R_Loop: 
8984 cb 3f		    srl a 
8986 30 01		    jr nc,Mult12R_NoAdd 
8988 19			    add hl,de 
8989			Mult12R_NoAdd: 
8989 cb 23		    sla e 
898b cb 12		    rl d 
898d b7			    or a 
898e c2 84 89		    jp nz,Mult12R_Loop 
8991 c9			    ret 
8992			 
8992			; 
8992			; Multiply 16-bit values (with 32-bit result) 
8992			; In: Multiply BC with DE 
8992			; Out: BCHL = result 
8992			; 
8992			Mult32: 
8992 79			    ld a,c 
8993 48			    ld c,b 
8994 21 00 00		    ld hl,0 
8997 06 10		    ld b,16 
8999			Mult32_Loop: 
8999 29			    add hl,hl 
899a 17			    rla 
899b cb 11		    rl c 
899d 30 07		    jr nc,Mult32_NoAdd 
899f 19			    add hl,de 
89a0 ce 00		    adc a,0 
89a2 d2 a6 89		    jp nc,Mult32_NoAdd 
89a5 0c			    inc c 
89a6			Mult32_NoAdd: 
89a6 10 f1		    djnz Mult32_Loop 
89a8 41			    ld b,c 
89a9 4f			    ld c,a 
89aa c9			    ret 
89ab			 
89ab			 
89ab			 
89ab			; 
89ab			; Multiply 8-bit values 
89ab			; In:  Multiply H with E 
89ab			; Out: HL = result 
89ab			; 
89ab			Mult8: 
89ab 16 00		    ld d,0 
89ad 6a			    ld l,d 
89ae 06 08		    ld b,8 
89b0			Mult8_Loop: 
89b0 29			    add hl,hl 
89b1 30 01		    jr nc,Mult8_NoAdd 
89b3 19			    add hl,de 
89b4			Mult8_NoAdd: 
89b4 10 fa		    djnz Mult8_Loop 
89b6 c9			    ret 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			;;http://z80-heaven.wikidot.com/math 
89b7			;;This divides DE by BC, storing the result in DE, remainder in HL 
89b7			; 
89b7			;DE_Div_BC:          ;1281-2x, x is at most 16 
89b7			;     ld a,16        ;7 
89b7			;     ld hl,0        ;10 
89b7			;     jp $+5         ;10 
89b7			;.DivLoop: 
89b7			;       add hl,bc    ;-- 
89b7			;       dec a        ;64 
89b7			;       jr z,.DivLoopEnd        ;86 
89b7			; 
89b7			;       sla e        ;128 
89b7			;       rl d         ;128 
89b7			;       adc hl,hl    ;240 
89b7			;       sbc hl,bc    ;240 
89b7			;       jr nc,.DivLoop ;23|21 
89b7			;       inc e        ;-- 
89b7			;       jp .DivLoop+1 
89b7			; 
89b7			;.DivLoopEnd: 
89b7			 
89b7			;HL_Div_C: 
89b7			;Inputs: 
89b7			;     HL is the numerator 
89b7			;     C is the denominator 
89b7			;Outputs: 
89b7			;     A is the remainder 
89b7			;     B is 0 
89b7			;     C is not changed 
89b7			;     DE is not changed 
89b7			;     HL is the quotient 
89b7			; 
89b7			;       ld b,16 
89b7			;       xor a 
89b7			;         add hl,hl 
89b7			;         rla 
89b7			;         cp c 
89b7			;         jr c,$+4 
89b7			;           inc l 
89b7			;           sub c 
89b7			;         djnz $-7 
89b7			 
89b7			; https://plutiedev.com/z80-add-8bit-to-16bit 
89b7			 
89b7			addatohl: 
89b7 85			    add   a, l    ; A = A+L 
89b8 6f			    ld    l, a    ; L = A+L 
89b9 8c			    adc   a, h    ; A = A+L+H+carry 
89ba 95			    sub   l       ; A = H+carry 
89bb 67			    ld    h, a    ; H = H+carry 
89bc c9			ret 
89bd			 
89bd			addatode: 
89bd 83			    add   a, e    ; A = A+L 
89be 5f			    ld    e, a    ; L = A+L 
89bf 8a			    adc   a, d    ; A = A+L+H+carry 
89c0 93			    sub   e       ; A = H+carry 
89c1 57			    ld    d, a    ; H = H+carry 
89c2 c9			ret 
89c3			 
89c3			 
89c3			addatobc: 
89c3 81			    add   a, c    ; A = A+L 
89c4 4f			    ld    c, a    ; L = A+L 
89c5 88			    adc   a, b    ; A = A+L+H+carry 
89c6 91			    sub   c       ; A = H+carry 
89c7 47			    ld    b, a    ; H = H+carry 
89c8 c9			ret 
89c9			 
89c9			subafromhl: 
89c9			   ; If A=0 do nothing 
89c9			    ; Otherwise flip A's sign. Since 
89c9			    ; the upper byte becomes -1, also 
89c9			    ; substract 1 from H. 
89c9 ed 44		    neg 
89cb ca d4 89		    jp    z, Skip 
89ce 25			    dec   h 
89cf			     
89cf			    ; Now add the low byte as usual 
89cf			    ; Two's complement takes care of 
89cf			    ; ensuring the result is correct 
89cf 85			    add   a, l 
89d0 6f			    ld    l, a 
89d1 8c			    adc   a, h 
89d2 95			    sub   l 
89d3 67			    ld    h, a 
89d4			Skip: 
89d4 c9				ret 
89d5			 
89d5			 
89d5			; compare hl and de 
89d5			; returns:  
89d5			; if hl = de, z=1, s=0, c0=0 
89d5			; if hl > de, z=0, s=0, c=0 
89d5			; if hl < de, z=0, s=1, c=1 
89d5			cmp16:	 
89d5 b7				or a 
89d6 ed 52			sbc hl,de 
89d8 e0				ret po 
89d9 7c				ld a,h 
89da 1f				rra 
89db ee 40			xor 01000000B 
89dd 37				scf 
89de 8f				adc a,a 
89df c9				ret 
89e0			 
89e0			 
89e0			; test if hl contains zero   - A is destroyed 
89e0			 
89e0			ishlzero:    
89e0 b7				or a     ; reset flags 
89e1 7c				ld a, h 
89e2 b5				or l        	 
89e3			 
89e3 c9				ret 
89e4			 
89e4			 
89e4			 
89e4			 
89e4			if FORTH_ENABLE_FLOATMATH 
89e4			;include "float/bbcmath.z80" 
89e4			include "float/lpfpcalc.asm" 
89e4			endif 
89e4			 
89e4			 
89e4			; eof 
89e4			 
# End of file firmware_maths.asm
89e4			include "firmware_strings.asm"   ; string handling  
89e4			 
89e4			 
89e4			; TODO string len 
89e4			; input text string, end on cr with zero term 
89e4			; a offset into frame buffer to start prompt 
89e4			; d is max length 
89e4			; e is display size TODO 
89e4			; c is current cursor position 
89e4			; hl is ptr to where string will be stored 
89e4			 
89e4			 
89e4			; TODO check limit of buffer for new inserts 
89e4			; TODO check insert does not push beyond buffer 
89e4			; TODO scroll in a limited display area 
89e4			; TODO scroll whole screen on page wrap 
89e4			 
89e4			 
89e4			; TODO handle KEY_PREVWORD 
89e4			; TODO handle KEY_NEXTWORD 
89e4			; TODO handle KEY_HOME 
89e4			; TODO handle KEY_END 
89e4			; TODO use LCD cursor? 
89e4			 
89e4 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
89e7 81					add c 
89e8 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
89eb 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
89ee 79					ld a, c 
89ef cd b7 89				call addatohl 
89f2 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
89f5 7a					ld a,d 
89f6 32 75 ee			        ld (input_size), a       ; save length of input area 
89f9 79					ld a, c 
89fa 32 64 ee				ld (input_cursor),a      ; init cursor start position  
89fd 7b					ld a,e 
89fe 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8a01					 
8a01					 
8a01			 
8a01			;		ld a,(input_ptr) 
8a01			;		ld (input_under_cursor),a 	; save what is under the cursor 
8a01			 
8a01			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8a01					; init cursor shape if not set by the cin routines 
8a01 21 d3 eb				ld hl, cursor_shape 
8a04 3e ff				ld a, 255 
8a06 77					ld (hl), a 
8a07 23					inc hl 
8a08 3e 00				ld a, 0 
8a0a 77					ld (hl), a 
8a0b			 
8a0b 3e 0f				ld a, CUR_BLINK_RATE 
8a0d 32 6f ee				ld (input_cur_flash), a 
8a10 3e 01				ld a, 1 
8a12 32 6e ee				ld (input_cur_onoff),a 
8a15			 
8a15			;	if DEBUG_INPUT 
8a15			;		push af 
8a15			;		ld a, 'I' 
8a15			;		ld (debug_mark),a 
8a15			;		pop af 
8a15			;		CALLMONITOR 
8a15			;	endif 
8a15			.is1:		; main entry loop 
8a15			 
8a15			 
8a15			 
8a15					; pause 1ms 
8a15			 
8a15 3e 01				ld a, 1 
8a17 cd c7 87				call aDelayInMS 
8a1a			 
8a1a					; dec flash counter 
8a1a 3a 6f ee				ld a, (input_cur_flash) 
8a1d 3d					dec a 
8a1e 32 6f ee				ld (input_cur_flash), a 
8a21 fe 00				cp 0 
8a23 20 0d				jr nz, .nochgstate 
8a25			 
8a25			 
8a25					; change state 
8a25 3a 6e ee				ld a,(input_cur_onoff) 
8a28 ed 44				neg 
8a2a 32 6e ee				ld (input_cur_onoff),a 
8a2d			 
8a2d			 
8a2d					; reset on change of state 
8a2d 3e 0f				ld a, CUR_BLINK_RATE 
8a2f 32 6f ee				ld (input_cur_flash), a 
8a32			 
8a32			.nochgstate: 
8a32					 
8a32					 
8a32			 
8a32					; display cursor  
8a32			 
8a32			;		ld hl, (input_start) 
8a32			;		ld a, (input_cursor) 
8a32			;		call addatohl 
8a32			 
8a32					; get char under cursor and replace with cursor 
8a32 2a 78 ee		ld hl, (input_ptr) 
8a35			;		ld a, (hl) 
8a35			;		ld (input_under_cursor),a 
8a35			;		ld a, '_' 
8a35			;		ld (hl), a 
8a35			 
8a35					; display string 
8a35			 
8a35 ed 5b 76 ee			ld de, (input_start) 
8a39 3a 73 ee				ld a, (input_at_pos) 
8a3c cd 71 88				call str_at_display 
8a3f			;	        call update_display 
8a3f			 
8a3f					; find place to put the cursor 
8a3f			;		add h 
8a3f			;		ld l, display_row_1 
8a3f			;		sub l 
8a3f			; (input_at_pos) 
8a3f					;ld c, a 
8a3f			;		ld a, (input_cursor) 
8a3f			;		ld l, (input_at_pos) 
8a3f			;		;ld b, h 
8a3f			;		add l 
8a3f			;		ld (input_at_cursor),a 
8a3f					;ld l,h 
8a3f			 
8a3f			;		ld h, 0 
8a3f			;		ld l,(input_at_pos) 
8a3f			;		ld a, (input_cursor) 
8a3f			;		call addatohl 
8a3f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8a3f			;		call subafromhl 
8a3f			;		ld a,l 
8a3f			;		ld (input_at_cursor), a 
8a3f			 
8a3f				if DEBUG_INPUT 
8a3f					ld a, (hardware_diag) 
8a3f					cp 0 
8a3f					jr z, .skip_input_diag 
8a3f			 
8a3f					ld a,(input_at_pos) 
8a3f					ld hl, LFSRSeed 
8a3f					call hexout 
8a3f					ld a, (input_cursor) 
8a3f					ld hl, LFSRSeed+2 
8a3f					call hexout 
8a3f					ld a,(input_at_cursor) 
8a3f					ld hl, LFSRSeed+4 
8a3f					call hexout 
8a3f			 
8a3f					ld a,(input_cur_onoff) 
8a3f					ld hl, LFSRSeed+6 
8a3f					call hexout 
8a3f			 
8a3f					ld a,(input_cur_flash) 
8a3f					ld hl, LFSRSeed+8 
8a3f					call hexout 
8a3f			 
8a3f					ld a,(input_len) 
8a3f					ld hl, LFSRSeed+10 
8a3f					call hexout 
8a3f					ld hl, LFSRSeed+12 
8a3f					ld a, 0 
8a3f					ld (hl),a 
8a3f					ld a, display_row_4 
8a3f					ld de, LFSRSeed 
8a3f					call str_at_display 
8a3f					.skip_input_diag: 
8a3f				endif 
8a3f			 
8a3f					; decide on if we are showing the cursor this time round 
8a3f			 
8a3f 3a 6e ee				ld a, (input_cur_onoff) 
8a42 fe ff				cp 255 
8a44 28 13				jr z, .skipcur 
8a46			 
8a46			 
8a46 3a 71 ee				ld a,(input_at_cursor) 
8a49 11 d3 eb				ld de, cursor_shape 
8a4c cd 71 88				call str_at_display 
8a4f			 
8a4f					; save length of current input string 
8a4f 2a 76 ee				ld hl, (input_start) 
8a52 cd 15 8e				call strlenz 
8a55 7d					ld a,l 
8a56 32 69 ee				ld (input_len),a 
8a59			 
8a59			.skipcur: 
8a59			 
8a59 cd 81 88			        call update_display 
8a5c					 
8a5c			 
8a5c			 
8a5c					; wait 
8a5c				 
8a5c					; TODO loop without wait to flash the cursor and char under cursor	 
8a5c cd a5 d4				call cin    ; _wait 
8a5f			 
8a5f fe 00				cp 0 
8a61 ca 15 8a				jp z, .is1 
8a64			 
8a64					; get ptr to char to input into 
8a64			 
8a64 4f					ld c,a 
8a65 2a 76 ee				ld hl, (input_start) 
8a68 3a 64 ee				ld a, (input_cursor) 
8a6b cd b7 89				call addatohl 
8a6e 22 78 ee				ld (input_ptr), hl 
8a71 79					ld a,c 
8a72			 
8a72					; replace char under cursor 
8a72			 
8a72			;		ld hl, (input_ptr) 
8a72			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8a72			;		ld (hl), a 
8a72			 
8a72			;	if DEBUG_INPUT 
8a72			;		push af 
8a72			;		ld a, 'i' 
8a72			;		ld (debug_mark),a 
8a72			;		pop af 
8a72			;		CALLMONITOR 
8a72			;	endif 
8a72 fe 0e				cp KEY_HOME 
8a74 20 0e				jr nz, .iske 
8a76			 
8a76 3a 73 ee				ld a, (input_at_pos) 
8a79 32 71 ee				ld (input_at_cursor),a 
8a7c 3e 00				ld a, 0 
8a7e 32 64 ee				ld (input_cursor), a 
8a81 c3 15 8a				jp .is1 
8a84					 
8a84 fe 0f		.iske:		cp KEY_END 
8a86 20 03				jr nz, .isknw 
8a88 c3 15 8a				jp .is1 
8a8b			 
8a8b fe 06		.isknw:		cp KEY_NEXTWORD 
8a8d 20 1b				jr nz, .iskpw 
8a8f			 
8a8f 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
8a92 7e					ld a,(hl)	 
8a93 fe 00				cp 0 
8a95 ca 15 8a				jp z, .is1    ; end of string 
8a98 fe 20				cp ' ' 
8a9a ca 15 8a				jp z, .is1    ; end of word 
8a9d 23					inc hl 
8a9e 22 78 ee				ld (input_ptr), hl 
8aa1 3a 71 ee				ld a, (input_at_cursor) 
8aa4 3c					inc a 
8aa5 32 71 ee				ld (input_at_cursor), a 
8aa8 18 e5				jr .isknwm 
8aaa			 
8aaa fe 07		.iskpw:		cp KEY_PREVWORD 
8aac 20 1b				jr nz, .iskl 
8aae			.iskpwm:	 
8aae 2a 78 ee				ld hl, (input_ptr) 
8ab1 7e					ld a,(hl)	 
8ab2 fe 00				cp 0  
8ab4 ca 15 8a				jp z, .is1    ; end of string 
8ab7 fe 20				cp ' ' 
8ab9 ca 15 8a				jp z, .is1    ; end of word 
8abc 2b					dec hl 
8abd 22 78 ee				ld (input_ptr), hl 
8ac0 3a 71 ee				ld a, (input_at_cursor) 
8ac3 3d					dec a 
8ac4 32 71 ee				ld (input_at_cursor), a 
8ac7 18 e5				jr .iskpwm 
8ac9			 
8ac9			 
8ac9 fe 0b		.iskl:		cp KEY_LEFT 
8acb 20 27				jr nz, .isk1 
8acd			 
8acd 3a 64 ee				ld a, (input_cursor) 
8ad0			 
8ad0 fe 00				cp 0 
8ad2 ca 15 8a				jp z, .is1 		; at start of line to ignore  
8ad5			 
8ad5 3d					dec  a 		; TODO check underflow 
8ad6 32 64 ee				ld (input_cursor), a 
8ad9			 
8ad9 2a 78 ee				ld hl, (input_ptr) 
8adc 2b					dec hl 
8add 22 78 ee				ld (input_ptr), hl 
8ae0					 
8ae0 3a 71 ee				ld a, (input_at_cursor) 
8ae3 3d					dec a 
8ae4 32 71 ee				ld (input_at_cursor), a 
8ae7			 
8ae7 3e 01				ld a, 1		; show cursor moving 
8ae9 32 6e ee				ld (input_cur_onoff),a 
8aec 3e 0f				ld a, CUR_BLINK_RATE 
8aee 32 6f ee				ld (input_cur_flash), a 
8af1			 
8af1 c3 15 8a				jp .is1 
8af4			 
8af4 fe 0c		.isk1:		cp KEY_RIGHT 
8af6 20 2a				jr nz, .isk2 
8af8			 
8af8 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8afb 5f					ld e,a 
8afc 3a 64 ee				ld a, (input_cursor) 
8aff bb					cp e 
8b00 ca 15 8a				jp z, .is1		; at the end of string so dont go right 
8b03			 
8b03 3c					inc  a 		; TODO check overflow 
8b04 32 64 ee				ld (input_cursor), a 
8b07			 
8b07 3a 71 ee				ld a, (input_at_cursor) 
8b0a 3c					inc a 
8b0b 32 71 ee				ld (input_at_cursor), a 
8b0e			 
8b0e 2a 78 ee				ld hl, (input_ptr) 
8b11 23					inc hl 
8b12 22 78 ee				ld (input_ptr), hl 
8b15			 
8b15 3e 01				ld a, 1		; show cursor moving 
8b17 32 6e ee				ld (input_cur_onoff),a 
8b1a 3e 0f				ld a, CUR_BLINK_RATE 
8b1c 32 6f ee				ld (input_cur_flash), a 
8b1f			 
8b1f c3 15 8a				jp .is1 
8b22			 
8b22 fe 05		.isk2:		cp KEY_UP 
8b24			 
8b24 20 26				jr nz, .isk3 
8b26			 
8b26					; swap last command with the current on 
8b26			 
8b26					; move cursor to start of string 
8b26 2a 76 ee				ld hl, (input_start) 
8b29 22 78 ee				ld (input_ptr), hl 
8b2c			 
8b2c 3a 73 ee				ld a, (input_at_pos) 
8b2f 32 71 ee				ld (input_at_cursor), a 
8b32			 
8b32 3e 00				ld a, 0 
8b34 32 64 ee				ld (input_cursor), a 
8b37					 
8b37					; swap input and last command buffers 
8b37			 
8b37 21 9c e6				ld hl, os_cli_cmd 
8b3a 11 9b e7				ld de, os_last_cmd 
8b3d 06 ff				ld b, 255 
8b3f 7e			.swap1:		ld a, (hl) 
8b40 4f					ld c,a 
8b41 1a					ld a, (de) 
8b42 77					ld (hl), a 
8b43 79					ld a,c 
8b44 12					ld (de),a 
8b45 23					inc hl 
8b46 13					inc de 
8b47 10 f6				djnz .swap1 
8b49			 
8b49			 
8b49			 
8b49			 
8b49			 
8b49 c3 15 8a				jp .is1 
8b4c			 
8b4c fe 08		.isk3:		cp KEY_BS 
8b4e 20 3c				jr nz, .isk4 
8b50			 
8b50 3a 64 ee				ld a, (input_cursor) 
8b53			 
8b53 fe 00				cp 0 
8b55 ca 15 8a				jp z, .is1 		; at start of line to ignore  
8b58			 
8b58 3d					dec  a 		; TODO check underflow 
8b59 32 64 ee				ld (input_cursor), a 
8b5c			 
8b5c					; hl is source 
8b5c					; de needs to be source - 1 
8b5c			 
8b5c			;		ld a, 0 
8b5c			;		dec hl 
8b5c			;		ld (hl), a 
8b5c			 
8b5c 2a 78 ee				ld hl, (input_ptr) 
8b5f 2b					dec hl 
8b60 22 78 ee				ld (input_ptr), hl 
8b63			 
8b63					; shift all data 
8b63			 
8b63 e5					push hl 
8b64 23					inc hl 
8b65 d1					pop de 
8b66 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8b69 4f					ld c,a 
8b6a 06 00				ld b,0 
8b6c ed b0				ldir  
8b6e			 
8b6e			 
8b6e			 
8b6e			 
8b6e 3a 71 ee				ld a, (input_at_cursor) 
8b71 3d					dec a 
8b72 32 71 ee				ld (input_at_cursor), a 
8b75			 
8b75			 
8b75 3e 01				ld a, 1		; show cursor moving 
8b77 32 6e ee				ld (input_cur_onoff),a 
8b7a 3e 0f				ld a, CUR_BLINK_RATE 
8b7c 32 6f ee				ld (input_cur_flash), a 
8b7f			 
8b7f					; remove char 
8b7f 3a 71 ee				ld a, (input_at_cursor) 
8b82 3c					inc a 
8b83 11 0d 8c				ld de,.iblank 
8b86 cd 71 88				call str_at_display 
8b89			 
8b89 c3 15 8a				jp .is1 
8b8c			 
8b8c fe 0d		.isk4:		cp KEY_CR 
8b8e 28 6c				jr z, .endinput 
8b90			 
8b90					; else add the key press to the end 
8b90			 
8b90 4f					ld c, a			; save key pressed 
8b91			 
8b91 7e					ld a,(hl)		; get what is currently under char 
8b92			 
8b92 fe 00				cp 0			; we are at the end of the string 
8b94 20 2f				jr nz, .onchar 
8b96					 
8b96					; add a char to the end of the string 
8b96				 
8b96 71					ld (hl),c 
8b97 23					inc hl 
8b98			;		ld a,' ' 
8b98			;		ld (hl),a 
8b98			;		inc hl 
8b98 3e 00				ld a,0 
8b9a 77					ld (hl),a 
8b9b 2b					dec hl 
8b9c			 
8b9c 3a 64 ee				ld a, (input_cursor) 
8b9f 3c					inc a				; TODO check max string length and scroll  
8ba0 32 64 ee				ld (input_cursor), a		; inc cursor pos 
8ba3							 
8ba3 3a 71 ee				ld a, (input_at_cursor) 
8ba6 3c					inc a 
8ba7 32 71 ee				ld (input_at_cursor), a 
8baa			 
8baa 2a 78 ee				ld hl, (input_ptr) 
8bad 23					inc hl 
8bae 22 78 ee				ld (input_ptr), hl 
8bb1			 
8bb1 2a 78 ee				ld hl, (input_ptr) 
8bb4 23					inc hl 
8bb5 22 78 ee				ld (input_ptr), hl 
8bb8			;	if DEBUG_INPUT 
8bb8			;		push af 
8bb8			;		ld a, '+' 
8bb8			;		ld (debug_mark),a 
8bb8			;		pop af 
8bb8			;		CALLMONITOR 
8bb8			;	endif 
8bb8 3e 01				ld a, 1		; show cursor moving 
8bba 32 6e ee				ld (input_cur_onoff),a 
8bbd 3e 0f				ld a, CUR_BLINK_RATE 
8bbf 32 6f ee				ld (input_cur_flash), a 
8bc2 c3 15 8a				jp .is1 
8bc5					 
8bc5			 
8bc5			 
8bc5					; if on a char then insert 
8bc5			.onchar: 
8bc5			 
8bc5					; TODO over flow check: make sure insert does not blow out buffer 
8bc5			 
8bc5					; need to do some maths to use lddr 
8bc5			 
8bc5 e5					push hl   ; save char pos 
8bc6 c5					push bc 
8bc7			 
8bc7 2a 76 ee				ld hl, (input_start) 
8bca 3a 69 ee				ld a, (input_len) 
8bcd cd b7 89				call addatohl  		; end of string 
8bd0 23					inc hl 
8bd1 23					inc hl		; past zero term 
8bd2 e5					push hl 
8bd3 23					inc hl 
8bd4 e5					push hl  
8bd5			 
8bd5								; start and end of lddr set, now how much to move? 
8bd5			 
8bd5							 
8bd5 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8bd8 47					ld b,a 
8bd9 3a 69 ee				ld a,(input_len) 
8bdc 5f					ld e,a 
8bdd 90					sub b 
8bde 3c					inc a		;?? 
8bdf 3c					inc a		;?? 
8be0 3c					inc a		;?? 
8be1			 
8be1 06 00				ld b,0 
8be3 4f					ld c,a 
8be4			 
8be4				if DEBUG_INPUT 
8be4					push af 
8be4					ld a, 'i' 
8be4					ld (debug_mark),a 
8be4					pop af 
8be4			;		CALLMONITOR 
8be4				endif 
8be4 d1					pop de 
8be5 e1					pop hl 
8be6				if DEBUG_INPUT 
8be6					push af 
8be6					ld a, 'I' 
8be6					ld (debug_mark),a 
8be6					pop af 
8be6			;		CALLMONITOR 
8be6				endif 
8be6 ed b8				lddr 
8be8				 
8be8			 
8be8			 
8be8					; TODO have a key for insert/overwrite mode???? 
8be8 c1					pop bc 
8be9 e1					pop hl 
8bea 71					ld (hl), c		; otherwise overwrite current char 
8beb					 
8beb			 
8beb			 
8beb			 
8beb 3a 64 ee				ld a, (input_cursor) 
8bee 3c					inc  a 		; TODO check overflow 
8bef 32 64 ee				ld (input_cursor), a 
8bf2			 
8bf2 3a 71 ee				ld a, (input_at_cursor) 
8bf5 3c					inc a 
8bf6 32 71 ee				ld (input_at_cursor), a 
8bf9			 
8bf9 c3 15 8a				jp .is1 
8bfc			 
8bfc			.endinput:	; TODO look for end of string 
8bfc			 
8bfc					; add trailing space for end of token 
8bfc			 
8bfc 2a 76 ee				ld hl, (input_start) 
8bff 3a 69 ee				ld a,(input_len) 
8c02 cd b7 89				call addatohl 
8c05 3e 20				ld a, ' ' 
8c07 77					ld (hl),a 
8c08					; TODO eof of parse marker 
8c08			 
8c08 23					inc hl 
8c09 3e 00				ld a, 0 
8c0b 77					ld (hl),a 
8c0c			 
8c0c			 
8c0c c9					ret 
8c0d			 
8c0d .. 00		.iblank: db " ",0 
8c0f			 
8c0f			 
8c0f 32 73 ee		input_str_prev:	ld (input_at_pos), a 
8c12 22 76 ee				ld (input_start), hl 
8c15 3e 01				ld a,1			; add cursor 
8c17 77					ld (hl),a 
8c18 23					inc hl 
8c19 3e 00				ld a,0 
8c1b 77					ld (hl),a 
8c1c 22 78 ee				ld (input_ptr), hl 
8c1f 7a					ld a,d 
8c20 32 75 ee				ld (input_size), a 
8c23 3e 00				ld a,0 
8c25 32 64 ee				ld (input_cursor),a 
8c28			.instr1:	 
8c28			 
8c28					; TODO do block cursor 
8c28					; TODO switch cursor depending on the modifer key 
8c28			 
8c28					; update cursor shape change on key hold 
8c28			 
8c28 2a 78 ee				ld hl, (input_ptr) 
8c2b 2b					dec hl 
8c2c 3a d3 eb				ld a,(cursor_shape) 
8c2f 77					ld (hl), a 
8c30			 
8c30					; display entered text 
8c30 3a 73 ee				ld a,(input_at_pos) 
8c33 cd 03 d4		            	CALL fLCD_Pos       ;Position cursor to location in A 
8c36 ed 5b 76 ee	            	LD   de, (input_start) 
8c3a cd fd d3		            	CALL fLCD_Str       ;Display string pointed to by DE 
8c3d			 
8c3d cd a5 d4				call cin 
8c40 fe 00				cp 0 
8c42 28 e4				jr z, .instr1 
8c44			 
8c44					; proecess keyboard controls first 
8c44			 
8c44 2a 78 ee				ld hl,(input_ptr) 
8c47			 
8c47 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8c49 28 5a				jr z, .instrcr 
8c4b			 
8c4b fe 08				cp KEY_BS 	; back space 
8c4d 20 0f				jr nz, .instr2 
8c4f					; process back space 
8c4f			 
8c4f					; TODO stop back space if at start of string 
8c4f 2b					dec hl 
8c50 2b					dec hl ; to over write cursor 
8c51 3a d3 eb				ld a,(cursor_shape) 
8c54					;ld a,0 
8c54 77					ld (hl),a 
8c55 23					inc hl 
8c56 3e 20				ld a," " 
8c58 77					ld (hl),a 
8c59 22 78 ee				ld (input_ptr),hl 
8c5c					 
8c5c			 
8c5c 18 ca				jr .instr1 
8c5e			 
8c5e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8c60 20 06				jr nz, .instr3 
8c62 2b					dec hl 
8c63 22 78 ee				ld (input_ptr),hl 
8c66 18 c0				jr .instr1 
8c68				 
8c68 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8c6a 20 06				jr nz, .instr4 
8c6c 23					inc hl 
8c6d 22 78 ee				ld (input_ptr),hl 
8c70 18 b6				jr .instr1 
8c72			 
8c72 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8c74 20 06				jr nz, .instr5 
8c76 2b					dec hl 
8c77 22 78 ee				ld (input_ptr),hl 
8c7a 18 ac				jr .instr1 
8c7c			 
8c7c fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8c7e 20 06				jr nz, .instr6 
8c80 2b					dec hl 
8c81 22 78 ee				ld (input_ptr),hl 
8c84 18 a2				jr .instr1 
8c86 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8c88 20 0b				jr nz, .instrnew 
8c8a			 
8c8a 21 75 e3			ld hl, scratch 
8c8d 11 9b e7			ld de, os_last_cmd 
8c90 cd ae 8c			call strcpy 
8c93 18 93				jr .instr1 
8c95			 
8c95			 
8c95			.instrnew:	; no special key pressed to see if we have room to store it 
8c95			 
8c95					; TODO do string size test 
8c95			 
8c95 2b					dec hl ; to over write cursor 
8c96 77					ld (hl),a 
8c97 23					inc hl 
8c98 3a d3 eb				ld a,(cursor_shape) 
8c9b 77					ld (hl),a 
8c9c 23					inc hl 
8c9d 3e 00				ld a,0 
8c9f 77					ld (hl),a 
8ca0			 
8ca0 22 78 ee				ld (input_ptr),hl 
8ca3					 
8ca3 18 83				jr .instr1 
8ca5 2b			.instrcr:	dec hl		; remove cursor 
8ca6 3e 20				ld a,' '	; TODO add a trailing space for safety 
8ca8 77					ld (hl),a 
8ca9 23					inc hl 
8caa 3e 00				ld a,0 
8cac 77					ld (hl),a 
8cad			 
8cad			 
8cad					; if at end of line scroll up    
8cad					; TODO detecting only end of line 4 for scroll up  
8cad			 
8cad					;ld   
8cad			 
8cad c9					ret 
8cae			 
8cae			 
8cae			; strcpy hl = dest, de source 
8cae			 
8cae 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8caf b7			            OR   A              ;Null terminator? 
8cb0 c8			            RET  Z              ;Yes, so finished 
8cb1 1a					ld a,(de) 
8cb2 77					ld (hl),a 
8cb3 13			            INC  DE             ;Point to next character 
8cb4 23					inc hl 
8cb5 18 f7		            JR   strcpy       ;Repeat 
8cb7 c9					ret 
8cb8			 
8cb8			 
8cb8			; TODO string_at  
8cb8			; pass string which starts with lcd offset address and then null term string 
8cb8			 
8cb8			; TODO string to dec 
8cb8			; TODO string to hex 
8cb8			; TODO byte to string hex 
8cb8			; TODO byte to string dec 
8cb8			 
8cb8			 
8cb8			 
8cb8			; from z80uartmonitor 
8cb8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cb8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8cb8			; pass hl for where to put the text 
8cb8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cb8 c5			hexout:	PUSH BC 
8cb9 f5					PUSH AF 
8cba 47					LD B, A 
8cbb					; Upper nybble 
8cbb cb 3f				SRL A 
8cbd cb 3f				SRL A 
8cbf cb 3f				SRL A 
8cc1 cb 3f				SRL A 
8cc3 cd d3 8c				CALL tohex 
8cc6 77					ld (hl),a 
8cc7 23					inc hl	 
8cc8					 
8cc8					; Lower nybble 
8cc8 78					LD A, B 
8cc9 e6 0f				AND 0FH 
8ccb cd d3 8c				CALL tohex 
8cce 77					ld (hl),a 
8ccf 23					inc hl	 
8cd0					 
8cd0 f1					POP AF 
8cd1 c1					POP BC 
8cd2 c9					RET 
8cd3					 
8cd3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cd3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8cd3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cd3			tohex: 
8cd3 e5					PUSH HL 
8cd4 d5					PUSH DE 
8cd5 16 00				LD D, 0 
8cd7 5f					LD E, A 
8cd8 21 e0 8c				LD HL, .DATA 
8cdb 19					ADD HL, DE 
8cdc 7e					LD A, (HL) 
8cdd d1					POP DE 
8cde e1					POP HL 
8cdf c9					RET 
8ce0			 
8ce0			.DATA: 
8ce0 30					DEFB	30h	; 0 
8ce1 31					DEFB	31h	; 1 
8ce2 32					DEFB	32h	; 2 
8ce3 33					DEFB	33h	; 3 
8ce4 34					DEFB	34h	; 4 
8ce5 35					DEFB	35h	; 5 
8ce6 36					DEFB	36h	; 6 
8ce7 37					DEFB	37h	; 7 
8ce8 38					DEFB	38h	; 8 
8ce9 39					DEFB	39h	; 9 
8cea 41					DEFB	41h	; A 
8ceb 42					DEFB	42h	; B 
8cec 43					DEFB	43h	; C 
8ced 44					DEFB	44h	; D 
8cee 45					DEFB	45h	; E 
8cef 46					DEFB	46h	; F 
8cf0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8cf0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8cf0			;;    subtract $30, if result > 9 then subtract $7 more 
8cf0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8cf0			atohex: 
8cf0 d6 30				SUB $30 
8cf2 fe 0a				CP 10 
8cf4 f8					RET M		; If result negative it was 0-9 so we're done 
8cf5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8cf7 c9					RET		 
8cf8			 
8cf8			 
8cf8			 
8cf8			 
8cf8			; Get 2 ASCII characters as hex byte from pointer in hl 
8cf8			 
8cf8			BYTERD: 
8cf8 16 00			LD	D,00h		;Set up 
8cfa cd 02 8d			CALL	HEXCON		;Get byte and convert to hex 
8cfd 87				ADD	A,A		;First nibble so 
8cfe 87				ADD	A,A		;multiply by 16 
8cff 87				ADD	A,A		; 
8d00 87				ADD	A,A		; 
8d01 57				LD	D,A		;Save hi nibble in D 
8d02			HEXCON: 
8d02 7e				ld a, (hl)		;Get next chr 
8d03 23				inc hl 
8d04 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8d06 fe 0a			CP	00Ah		;Is it 0-9 ? 
8d08 38 02			JR	C,NALPHA	;If so miss next bit 
8d0a d6 07			SUB	007h		;Else convert alpha 
8d0c			NALPHA: 
8d0c b2				OR	D		;Add hi nibble back 
8d0d c9				RET			; 
8d0e			 
8d0e			 
8d0e			; 
8d0e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8d0e			; Since the routines get_byte and therefore get_nibble are called, only valid 
8d0e			; characters (0-9a-f) are accepted. 
8d0e			; 
8d0e			;get_word        push    af 
8d0e			;                call    get_byte        ; Get the upper byte 
8d0e			;                ld      h, a 
8d0e			;                call    get_byte        ; Get the lower byte 
8d0e			;                ld      l, a 
8d0e			;                pop     af 
8d0e			;                ret 
8d0e			; 
8d0e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8d0e			; the routine get_nibble is used only valid characters are accepted - the  
8d0e			; input routine only accepts characters 0-9a-f. 
8d0e			; 
8d0e c5			get_byte:        push    bc              ; Save contents of B (and C) 
8d0f 7e					ld a,(hl) 
8d10 23					inc hl 
8d11 cd 36 8d		                call    nibble2val      ; Get upper nibble 
8d14 cb 07		                rlc     a 
8d16 cb 07		                rlc     a 
8d18 cb 07		                rlc     a 
8d1a cb 07		                rlc     a 
8d1c 47			                ld      b, a            ; Save upper four bits 
8d1d 7e					ld a,(hl) 
8d1e cd 36 8d		                call    nibble2val      ; Get lower nibble 
8d21 b0			                or      b               ; Combine both nibbles 
8d22 c1			                pop     bc              ; Restore B (and C) 
8d23 c9			                ret 
8d24			; 
8d24			; Get a hexadecimal digit from the serial line. This routine blocks until 
8d24			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8d24			; to the serial line interface. The lower 4 bits of A contain the value of  
8d24			; that particular digit. 
8d24			; 
8d24			;get_nibble      ld a,(hl)           ; Read a character 
8d24			;                call    to_upper        ; Convert to upper case 
8d24			;                call    is_hex          ; Was it a hex digit? 
8d24			;                jr      nc, get_nibble  ; No, get another character 
8d24			 ;               call    nibble2val      ; Convert nibble to value 
8d24			 ;               call    print_nibble 
8d24			 ;               ret 
8d24			; 
8d24			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8d24			; A valid hexadecimal digit is denoted by a set C flag. 
8d24			; 
8d24			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8d24			;                ret     nc              ; Yes 
8d24			;                cp      '0'             ; Less than '0'? 
8d24			;                jr      nc, is_hex_1    ; No, continue 
8d24			;                ccf                     ; Complement carry (i.e. clear it) 
8d24			;                ret 
8d24			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8d24			;                ret     c               ; Yes 
8d24			;                cp      'A'             ; Less than 'A'? 
8d24			;                jr      nc, is_hex_2    ; No, continue 
8d24			;                ccf                     ; Yes - clear carry and return 
8d24			;                ret 
8d24			;is_hex_2        scf                     ; Set carry 
8d24			;                ret 
8d24			; 
8d24			; Convert a single character contained in A to upper case: 
8d24			; 
8d24 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8d26 d8			                ret     c 
8d27 fe 7b		                cp      'z' + 1         ; > 'z'? 
8d29 d0			                ret     nc              ; Nothing to do, either 
8d2a e6 5f		                and     $5f             ; Convert to upper case 
8d2c c9			                ret 
8d2d			 
8d2d			 
8d2d			to_lower: 
8d2d			 
8d2d			   ; if char is in [A-Z] make it lower case 
8d2d			 
8d2d			   ; enter : a = char 
8d2d			   ; exit  : a = lower case char 
8d2d			   ; uses  : af 
8d2d			 
8d2d fe 41		   cp 'A' 
8d2f d8			   ret c 
8d30			    
8d30 fe 5b		   cp 'Z'+1 
8d32 d0			   ret nc 
8d33			    
8d33 f6 20		   or $20 
8d35 c9			   ret 
8d36			 
8d36			; 
8d36			; Expects a hexadecimal digit (upper case!) in A and returns the 
8d36			; corresponding value in A. 
8d36			; 
8d36 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8d38 38 02		                jr      c, nibble2val_1 ; Yes 
8d3a d6 07		                sub     7               ; Adjust for A-F 
8d3c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8d3e e6 0f		                and     $f              ; Only return lower 4 bits 
8d40 c9			                ret 
8d41			; 
8d41			; Print_nibble prints a single hex nibble which is contained in the lower  
8d41			; four bits of A: 
8d41			; 
8d41			;print_nibble    push    af              ; We won't destroy the contents of A 
8d41			;                and     $f              ; Just in case... 
8d41			;                add     a, '0'             ; If we have a digit we are done here. 
8d41			;                cp      '9' + 1         ; Is the result > 9? 
8d41			;                jr      c, print_nibble_1 
8d41			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8d41			;print_nibble_1  call    putc            ; Print the nibble and 
8d41			;                pop     af              ; restore the original value of A 
8d41			;                ret 
8d41			;; 
8d41			;; Send a CR/LF pair: 
8d41			; 
8d41			;crlf            push    af 
8d41			;                ld      a, cr 
8d41			;                call    putc 
8d41			;                ld      a, lf 
8d41			;                call    putc 
8d41			;                pop     af 
8d41			;                ret 
8d41			; 
8d41			; Print_word prints the four hex digits of a word to the serial line. The  
8d41			; word is expected to be in HL. 
8d41			; 
8d41			;print_word      push    hl 
8d41			;                push    af 
8d41			;                ld      a, h 
8d41			;                call    print_byte 
8d41			;                ld      a, l 
8d41			;                call    print_byte 
8d41			;                pop     af 
8d41			;                pop     hl 
8d41			;                ret 
8d41			; 
8d41			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8d41			; The byte to be printed is expected to be in A. 
8d41			; 
8d41			;print_byte      push    af              ; Save the contents of the registers 
8d41			;                push    bc 
8d41			;                ld      b, a 
8d41			;                rrca 
8d41			;                rrca 
8d41			;                rrca 
8d41			;                rrca 
8d41			;                call    print_nibble    ; Print high nibble 
8d41			;                ld      a, b 
8d41			;                call    print_nibble    ; Print low nibble 
8d41			;                pop     bc              ; Restore original register contents 
8d41			;                pop     af 
8d41			;                ret 
8d41			 
8d41			 
8d41			 
8d41			 
8d41			 
8d41			fourehexhl:  
8d41 7e				ld a,(hl) 
8d42 cd f0 8c			call atohex 
8d45 cb 3f				SRL A 
8d47 cb 3f				SRL A 
8d49 cb 3f				SRL A 
8d4b cb 3f				SRL A 
8d4d 47				ld b, a 
8d4e 23				inc hl 
8d4f 7e				ld a,(hl) 
8d50 23				inc hl 
8d51 cd f0 8c			call atohex 
8d54 80				add b 
8d55 57				ld d,a 
8d56 7e				ld a,(hl) 
8d57 cd f0 8c			call atohex 
8d5a cb 3f				SRL A 
8d5c cb 3f				SRL A 
8d5e cb 3f				SRL A 
8d60 cb 3f				SRL A 
8d62 47				ld b, a 
8d63 23				inc hl 
8d64 7e				ld a,(hl) 
8d65 23				inc hl 
8d66 cd f0 8c			call atohex 
8d69 80				add b 
8d6a 5f				ld e, a 
8d6b d5				push de 
8d6c e1				pop hl 
8d6d c9				ret 
8d6e			 
8d6e			; pass hl. returns z set if the byte at hl is a digit 
8d6e			;isdigithl:  
8d6e			;	push bc 
8d6e			;	ld a,(hl) 
8d6e			;	cp ':' 
8d6e			;	jr nc, .isdf 		; > 
8d6e			;	cp '0' 
8d6e			;	jr c, .isdf		; < 
8d6e			; 
8d6e			;	; TODO find a better way to set z 
8d6e			; 
8d6e			;	ld b,a 
8d6e			;	cp b 
8d6e			;	pop bc 
8d6e			;	ret 
8d6e			; 
8d6e			;.isdf:	; not digit so clear z 
8d6e			; 
8d6e			;	; TODO find a better way to unset z 
8d6e			; 
8d6e			;	ld b,a 
8d6e			;	inc b 
8d6e			;	cp b 
8d6e			; 
8d6e			;	pop bc 
8d6e			;	ret 
8d6e				 
8d6e				 
8d6e			 
8d6e			 
8d6e			; pass hl as the four byte address to load 
8d6e			 
8d6e			get_word_hl:  
8d6e e5				push hl 
8d6f cd 0e 8d			call get_byte 
8d72				 
8d72 47				ld b, a 
8d73			 
8d73 e1				pop hl 
8d74 23				inc hl 
8d75 23				inc hl 
8d76			 
8d76			; TODO not able to handle a-f  
8d76 7e				ld a,(hl) 
8d77			;	;cp ':' 
8d77			;	cp 'g' 
8d77			;	jr nc, .single_byte_hl 		; > 
8d77			;	cp 'G' 
8d77			;	jr nc, .single_byte_hl 		; > 
8d77			;	cp '0' 
8d77			;	jr c, .single_byte_hl		; < 
8d77			 
8d77				;call isdigithl 
8d77 fe 00			cp 0 
8d79 28 06			jr z, .single_byte_hl 
8d7b			 
8d7b			.getwhln:   ; hex word so get next byte 
8d7b			 
8d7b cd 0e 8d			call get_byte 
8d7e 6f				ld l, a 
8d7f 60				ld h,b 
8d80 c9				ret 
8d81 68			.single_byte_hl:   ld l,b 
8d82 26 00				ld h,0 
8d84 c9					ret 
8d85			 
8d85			 
8d85			 
8d85			 
8d85 21 2c 94			ld hl,asc+1 
8d88			;	ld a, (hl) 
8d88			;	call nibble2val 
8d88 cd 0e 8d			call get_byte 
8d8b			 
8d8b			;	call fourehexhl 
8d8b 32 a9 e3			ld (scratch+52),a 
8d8e				 
8d8e 21 a7 e3			ld hl,scratch+50 
8d91 22 98 e6			ld (os_cur_ptr),hl 
8d94			 
8d94 c9				ret 
8d95			 
8d95			 
8d95			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8d95			 
8d95			; Decimal Unsigned Version 
8d95			 
8d95			;Number in a to decimal ASCII 
8d95			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8d95			;Example: display a=56 as "056" 
8d95			;input: a = number 
8d95			;Output: a=0,value of a in the screen 
8d95			;destroys af,bc (don't know about hl and de) 
8d95			DispAToASCII: 
8d95 0e 9c			ld	c,-100 
8d97 cd a1 8d			call	.Na1 
8d9a 0e f6			ld	c,-10 
8d9c cd a1 8d			call	.Na1 
8d9f 0e ff			ld	c,-1 
8da1 06 2f		.Na1:	ld	b,'0'-1 
8da3 04			.Na2:	inc	b 
8da4 81				add	a,c 
8da5 38 fc			jr	c,.Na2 
8da7 91				sub	c		;works as add 100/10/1 
8da8 f5				push af		;safer than ld c,a 
8da9 78				ld	a,b		;char is in b 
8daa			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8daa f1				pop af		;safer than ld a,c 
8dab c9				ret 
8dac			 
8dac			; Decimal Signed Version 
8dac			 
8dac			; DispA 
8dac			; -------------------------------------------------------------- 
8dac			; Converts a signed integer value to a zero-terminated ASCII 
8dac			; string representative of that value (using radix 10). 
8dac			; -------------------------------------------------------------- 
8dac			; INPUTS: 
8dac			;     HL     Value to convert (two's complement integer). 
8dac			;     DE     Base address of string destination. (pointer). 
8dac			; -------------------------------------------------------------- 
8dac			; OUTPUTS: 
8dac			;     None 
8dac			; -------------------------------------------------------------- 
8dac			; REGISTERS/MEMORY DESTROYED 
8dac			; AF HL 
8dac			; -------------------------------------------------------------- 
8dac			 
8dac			;DispHLToASCII: 
8dac			;   push    de 
8dac			;   push    bc 
8dac			; 
8dac			;; Detect sign of HL. 
8dac			;    bit    7, h 
8dac			;    jr     z, ._DoConvert 
8dac			; 
8dac			;; HL is negative. Output '-' to string and negate HL. 
8dac			;    ld     a, '-' 
8dac			;    ld     (de), a 
8dac			;    inc    de 
8dac			; 
8dac			;; Negate HL (using two's complement) 
8dac			;    xor    a 
8dac			;    sub    l 
8dac			;    ld     l, a 
8dac			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8dac			;    sbc    a, h 
8dac			;    ld     h, a 
8dac			; 
8dac			;; Convert HL to digit characters 
8dac			;._DoConvert: 
8dac			;    ld     b, 0     ; B will count character length of number 
8dac			;-   ld     a, 10 
8dac			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8dac			;    push   af 
8dac			;    inc    b 
8dac			;    ld     a, h 
8dac			;    or     l 
8dac			;    jr     nz, - 
8dac			; 
8dac			;; Retrieve digits from stack 
8dac			;-   pop    af 
8dac			;    or     $30 
8dac			;    ld     (de), a 
8dac			;    inc    de 
8dac			;    djnz   - 
8dac			; 
8dac			;; Terminate string with NULL 
8dac			;    xor    a 
8dac			;    ld     (de), a 
8dac			; 
8dac			;    pop    bc 
8dac			;    pop    de 
8dac			;    ret 
8dac			 
8dac			;Comments 
8dac			; 
8dac			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8dac			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8dac			;    Note that the output string will not be fixed-width. 
8dac			; 
8dac			;Example Usage 
8dac			; 
8dac			;    ld    hl, -1004 
8dac			;    ld    de, OP1 
8dac			;    call  DispA 
8dac			;    ld    hl, OP1 
8dac			;    syscall  PutS 
8dac			 
8dac			 
8dac			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8dac			 
8dac			 
8dac			;Converts an ASCII string to an unsigned 16-bit integer 
8dac			;Quits when it reaches a non-decimal digit 
8dac			 
8dac			string_to_uint16: 
8dac			atoui_16: 
8dac			;Input: 
8dac			;     DE points to the string 
8dac			;Outputs: 
8dac			;     HL is the result 
8dac			;     A is the 8-bit value of the number 
8dac			;     DE points to the byte after the number 
8dac			;Destroys: 
8dac			;     BC 
8dac			;       if the string is non-empty, BC is HL/10 
8dac			;Size:  24 bytes 
8dac			;Speed: 42+d(104+{0,9}) 
8dac			;       d is the number of digits in the number 
8dac			;       max is 640 cycles for a 5 digit number 
8dac			;Assuming no leading zeros: 
8dac			;1 digit:  146cc 
8dac			;2 digit:  250cc 
8dac			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8dac			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8dac			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8dac			;avg: 544.81158447265625cc (544+13297/16384) 
8dac			;=============================================================== 
8dac 21 00 00		  ld hl,0 
8daf			.u16a: 
8daf 1a			  ld a,(de) 
8db0 d6 30		  sub 30h 
8db2 fe 0a		  cp 10 
8db4 d0			  ret nc 
8db5 13			  inc de 
8db6 44			  ld b,h 
8db7 4d			  ld c,l 
8db8 29			  add hl,hl 
8db9 29			  add hl,hl 
8dba 09			  add hl,bc 
8dbb 29			  add hl,hl 
8dbc 85			  add a,l 
8dbd 6f			  ld l,a 
8dbe 30 ef		  jr nc,.u16a 
8dc0 24			  inc h 
8dc1 c3 af 8d		  jp .u16a 
8dc4			 
8dc4			 
8dc4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8dc4			 
8dc4			;written by Zeda 
8dc4			;Converts a 16-bit unsigned integer to an ASCII string. 
8dc4			 
8dc4			uitoa_16: 
8dc4			;Input: 
8dc4			;   DE is the number to convert 
8dc4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8dc4			;Output: 
8dc4			;   HL points to the null-terminated ASCII string 
8dc4			;      NOTE: This isn't necessarily the same as the input HL. 
8dc4 d5			  push de 
8dc5 c5			  push bc 
8dc6 f5			  push af 
8dc7 eb			  ex de,hl 
8dc8			 
8dc8 01 f0 d8		  ld bc,-10000 
8dcb 3e 2f		  ld a,'0'-1 
8dcd 3c			  inc a 
8dce 09			  add hl,bc  
8dcf 38 fc		   jr c,$-2 
8dd1 12			  ld (de),a 
8dd2 13			  inc de 
8dd3			 
8dd3 01 e8 03		  ld bc,1000 
8dd6 3e 3a		  ld a,'9'+1 
8dd8 3d			  dec a  
8dd9 09			  add hl,bc  
8dda 30 fc		   jr nc,$-2 
8ddc 12			  ld (de),a 
8ddd 13			  inc de 
8dde			 
8dde 01 9c ff		  ld bc,-100 
8de1 3e 2f		  ld a,'0'-1 
8de3 3c			  inc a  
8de4 09			  add hl,bc  
8de5 38 fc		   jr c,$-2 
8de7 12			  ld (de),a 
8de8 13			  inc de 
8de9			 
8de9 7d			  ld a,l 
8dea 26 3a		  ld h,'9'+1 
8dec 25			  dec h  
8ded c6 0a		  add a,10  
8def 30 fb		   jr nc,$-3 
8df1 c6 30		  add a,'0' 
8df3 eb			  ex de,hl 
8df4 72			  ld (hl),d 
8df5 23			  inc hl 
8df6 77			  ld (hl),a 
8df7 23			  inc hl 
8df8 36 00		  ld (hl),0 
8dfa			 
8dfa			;Now strip the leading zeros 
8dfa 0e fa		  ld c,-6 
8dfc 09			  add hl,bc 
8dfd 3e 30		  ld a,'0' 
8dff 23			  inc hl  
8e00 be			  cp (hl)  
8e01 28 fc		  jr z,$-2 
8e03			 
8e03			;Make sure that the string is non-empty! 
8e03 7e			  ld a,(hl) 
8e04 b7			  or a 
8e05 20 01		  jr nz,.atoub 
8e07 2b			  dec hl 
8e08			.atoub: 
8e08			 
8e08 f1			  pop af 
8e09 c1			  pop bc 
8e0a d1			  pop de 
8e0b c9			  ret 
8e0c			 
8e0c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8e0c			 
8e0c			toUpper: 
8e0c			;A is the char. 
8e0c			;If A is a lowercase letter, this sets it to the matching uppercase 
8e0c			;18cc or 30cc or 41cc 
8e0c			;avg: 26.75cc 
8e0c fe 61		  cp 'a' 
8e0e d8			  ret c 
8e0f fe 7b		  cp 'z'+1 
8e11 d0			  ret nc 
8e12 d6 20		  sub 'a'-'A' 
8e14 c9			  ret 
8e15			 
8e15			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8e15			 
8e15			; String Length 
8e15			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8e15			 
8e15			; Get the length of the null-terminated string starting at $8000 hl 
8e15			;    LD     HL, $8000 
8e15			 
8e15			strlenz: 
8e15			 
8e15 af			    XOR    A               ; Zero is the value we are looking for. 
8e16 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8e17 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8e18			                           ; 65, 536 bytes (the entire addressable memory space). 
8e18 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8e1a			 
8e1a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8e1a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8e1b 6f			    LD     L, A             ; number of bytes 
8e1c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8e1e 2b			    DEC    HL              ; Compensate for null. 
8e1f c9				ret 
8e20			 
8e20			; Get the length of the A terminated string starting at $8000 hl 
8e20			;    LD     HL, $8000 
8e20			 
8e20			strlent: 
8e20			 
8e20			                  ; A is the value we are looking for. 
8e20 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8e22 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8e24			                           ; 65, 536 bytes (the entire addressable memory space). 
8e24 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8e26			 
8e26			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8e26 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8e28 2e 00		    LD     L, 0             ; number of bytes 
8e2a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8e2c 2b			    DEC    HL              ; Compensate for null. 
8e2d c9				ret 
8e2e			 
8e2e			 
8e2e			;Comparing Strings 
8e2e			 
8e2e			;IN    HL     Address of string1. 
8e2e			;      DE     Address of string2. 
8e2e			 
8e2e			; doc given but wrong??? 
8e2e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8e2e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8e2e			; tested 
8e2e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8e2e			 
8e2e			strcmp_old: 
8e2e e5			    PUSH   HL 
8e2f d5			    PUSH   DE 
8e30			 
8e30 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8e31 be			    CP     (HL)            ; (want to minimize work). 
8e32 38 01		    JR     C, Str1IsBigger 
8e34 7e			    LD     A, (HL) 
8e35			 
8e35			Str1IsBigger: 
8e35 4f			    LD     C, A             ; Put length in BC 
8e36 06 00		    LD     B, 0 
8e38 13			    INC    DE              ; Increment pointers to meat of string. 
8e39 23			    INC    HL 
8e3a			 
8e3a			CmpLoop: 
8e3a 1a			    LD     A, (DE)          ; Compare bytes. 
8e3b ed a1		    CPI 
8e3d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8e3f 13			    INC    DE              ; Update pointer. 
8e40 ea 3a 8e		    JP     PE, CmpLoop 
8e43			 
8e43 d1			    POP    DE 
8e44 e1			    POP    HL 
8e45 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8e46 be			    CP     (HL) 
8e47 c9			    RET 
8e48			 
8e48			NoMatch: 
8e48 2b			    DEC    HL 
8e49 be			    CP     (HL)            ; Compare again to affect carry. 
8e4a d1			    POP    DE 
8e4b e1			    POP    HL 
8e4c c9			    RET 
8e4d			 
8e4d			;; test strmp 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str2 
8e4d			;call strcmp 
8e4d			;jr z, .z1 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "NZ1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.z1: 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "ZZ1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str1 
8e4d			;call strcmp 
8e4d			;jr z, .z2 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "NZ2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.z2: 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "ZZ2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str2 
8e4d			;call strcmp 
8e4d			;jr c, .c1 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "Nc1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.c1: 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "cc1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str1 
8e4d			;call strcmp 
8e4d			;jr c, .c2 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "Nc2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.c2: 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "cc2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;	NEXTW 
8e4d			;.str1:   db "string1",0 
8e4d			;.str2:   db "string2",0 
8e4d			 
8e4d			; only care about direct match or not 
8e4d			; hl and de strings 
8e4d			; zero set if the same 
8e4d			 
8e4d			strcmp: 
8e4d 1a				ld a, (de) 
8e4e be				cp (hl) 
8e4f 28 02			jr z, .ssame 
8e51 b7				or a 
8e52 c9				ret 
8e53			 
8e53			.ssame:  
8e53 fe 00			cp 0 
8e55 c8				ret z 
8e56			 
8e56 23				inc hl 
8e57 13				inc de 
8e58 18 f3			jr strcmp 
8e5a				 
8e5a				 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a			; eof 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
# End of file firmware_strings.asm
8e5a			include "firmware_memory.asm"   ; malloc and free  
8e5a			 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a			.mallocsize: db "Wants malloc >256",0 
8e5a			.mallocasize: db "MALLOC gives >256",0 
8e5a			.malloczero: db "MALLOC gives zero",0 
8e5a			 
8e5a			malloc_guard_zerolen: 
8e5a				push hl 
8e5a				push de 
8e5a				push af 
8e5a			 
8e5a				ld de, 0 
8e5a			        call cmp16 
8e5a				jr nz, .lowalloz 
8e5a			 
8e5a				push hl 
8e5a				push de 
8e5a					ld hl, display_fb0 
8e5a					ld (display_fb_active), hl 
8e5a				call clear_display 
8e5a				ld a, 0 
8e5a				ld de, .malloczero 
8e5a				call str_at_display 
8e5a				call update_display 
8e5a				call delay1s 
8e5a				call delay1s 
8e5a				ld a, 0 
8e5a				ld (os_view_disable), a 
8e5a			 
8e5a				pop de 
8e5a				pop hl 
8e5a			 
8e5a				 
8e5a			 
8e5a				CALLMONITOR 
8e5a			.lowalloz: 
8e5a			 
8e5a			 
8e5a				pop af 
8e5a				pop de 
8e5a				pop hl 
8e5a			ret 
8e5a			 
8e5a			malloc_guard_entry: 
8e5a				push hl 
8e5a				push de 
8e5a				push af 
8e5a			 
8e5a			 	or a      ;clear carry flag 
8e5a				push hl 
8e5a				ld de, 255 
8e5a				sbc hl, de 
8e5a				jr c, .lowalloc 
8e5a			 
8e5a				push de 
8e5a					ld hl, display_fb0 
8e5a					ld (display_fb_active), hl 
8e5a				call clear_display 
8e5a				ld a, 0 
8e5a				ld de, .mallocsize 
8e5a				call str_at_display 
8e5a				call update_display 
8e5a				call delay1s 
8e5a				call delay1s 
8e5a				ld a, 0 
8e5a				ld (os_view_disable), a 
8e5a			 
8e5a				pop de 
8e5a				pop hl 
8e5a			 
8e5a				 
8e5a			 
8e5a				CALLMONITOR 
8e5a				jr .lowdone 
8e5a			.lowalloc: 
8e5a			 
8e5a			 
8e5a				pop hl 
8e5a			.lowdone:	pop af 
8e5a				pop de 
8e5a				pop hl 
8e5a			ret 
8e5a			 
8e5a			malloc_guard_exit: 
8e5a				push hl 
8e5a				push de 
8e5a				push af 
8e5a			 
8e5a			 	or a      ;clear carry flag 
8e5a				push hl 
8e5a				ld de, 255 
8e5a				sbc hl, de 
8e5a				jr c, .lowallocx 
8e5a			 
8e5a				push de 
8e5a					ld hl, display_fb0 
8e5a					ld (display_fb_active), hl 
8e5a				call clear_display 
8e5a				ld a, 0 
8e5a				ld de, .mallocasize 
8e5a				call str_at_display 
8e5a				call update_display 
8e5a				call delay1s 
8e5a				call delay1s 
8e5a				ld a, 0 
8e5a				ld (os_view_disable), a 
8e5a				pop de 
8e5a				pop hl 
8e5a			 
8e5a				CALLMONITOR 
8e5a				jr .lowdonex 
8e5a			.lowallocx: 
8e5a			 
8e5a				pop hl 
8e5a			.lowdonex:	pop af 
8e5a				pop de 
8e5a				pop hl 
8e5a			ret 
8e5a			endif 
8e5a			 
8e5a			if MALLOC_2 
8e5a			; Z80 Malloc and Free Functions 
8e5a			 
8e5a			; Malloc Function: 
8e5a			; Input: 
8e5a			;   HL: Size of block to allocate 
8e5a			; Output: 
8e5a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8e5a			 
8e5a			malloc: 
8e5a				 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a			call malloc_guard_entry 
8e5a			endif 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "mal" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			    push af            ; Save AF register 
8e5a			    ld a, l            ; Load low byte of size into A 
8e5a			    or h               ; Check if size is zero 
8e5a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8e5a			 
8e5a			    ; Allocate memory 
8e5a			    ld hl, (heap_start) ; Load start of heap into HL 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "ma1" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			    call malloc_internal ; Call internal malloc function 
8e5a			    pop af             ; Restore AF register 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret                ; Return 
8e5a			 
8e5a			; Free Function: 
8e5a			; Input: 
8e5a			;   HL: Pointer to memory block to free 
8e5a			; Output: 
8e5a			;   None 
8e5a			 
8e5a			free: 
8e5a			    push af            ; Save AF register 
8e5a			    ld a, l            ; Load low byte of pointer into A 
8e5a			    or h               ; Check if pointer is NULL 
8e5a			    jp z, free_exit    ; If pointer is NULL, exit 
8e5a			 
8e5a			    ; Free memory 
8e5a			    ld hl, (heap_start) ; Load start of heap into HL 
8e5a			    call free_internal  ; Call internal free function 
8e5a			    pop af             ; Restore AF register 
8e5a			    ret                ; Return 
8e5a			 
8e5a			; Internal Malloc Function: 
8e5a			; Input: 
8e5a			;   HL: Size of block to allocate 
8e5a			; Output: 
8e5a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8e5a			 
8e5a			malloc_internal: 
8e5a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8e5a			    add hl, bc         ; Add management overhead to requested size 
8e5a			    ex de, hl          ; Save total size in DE, and keep it in HL 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "ma2" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			 
8e5a			    ; Search for free memory block 
8e5a			    ld de, (heap_end)  ; Load end of heap into DE 
8e5a			    ld bc, 0           ; Initialize counter 
8e5a			 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "ma2" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			malloc_search_loop: 
8e5a			    ; Check if current block is free 
8e5a			    ld a, (hl)         ; Load current block's status (free or used) 
8e5a			    cp 0               ; Compare with zero (free) 
8e5a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8e5a			 
8e5a			    ; Check if current block is large enough 
8e5a			    ld a, (hl+1)       ; Load high byte of block size 
8e5a			    cp l               ; Compare with low byte of requested size 
8e5a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8e5a			 
8e5a			    ld a, (hl+2)       ; Load low byte of block size 
8e5a			    cp h               ; Compare with high byte of requested size 
8e5a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8e5a			 
8e5a			    ; Mark block as used 
8e5a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8e5a			 
8e5a			    ; Calculate remaining space in block 
8e5a			    ld bc, 0           ; Clear BC 
8e5a			    add hl, bc         ; Increment HL to point to start of data block 
8e5a			    add hl, de         ; HL = HL + DE (total size) 
8e5a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8e5a			    add hl, bc         ; Add management overhead to start of data block 
8e5a			 
8e5a			    ; Save pointer to allocated block in HL 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a						DMARK "ma5" 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret 
8e5a			 
8e5a			malloc_skip_block_check: 
8e5a			    ; Move to the next block 
8e5a			    ld bc, 3           ; Size of management overhead 
8e5a			    add hl, bc         ; Move to the next block 
8e5a			    inc de             ; Increment counter 
8e5a			 
8e5a			    ; Check if we have reached the end of heap 
8e5a			    ld a, e            ; Load low byte of heap end address 
8e5a			    cp (hl)            ; Compare with low byte of current address 
8e5a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8e5a			    ld a, d            ; Load high byte of heap end address 
8e5a			    cp 0               ; Check if it's zero (end of memory) 
8e5a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8e5a			 
8e5a			    ; If we reached here, allocation failed 
8e5a			    xor a              ; Set result to NULL 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a						DMARK "ma6" 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret 
8e5a			malloc_exit: 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a						DMARK "ma7" 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret 
8e5a			 
8e5a			; Internal Free Function: 
8e5a			; Input: 
8e5a			;   HL: Pointer to memory block to free 
8e5a			; Output: 
8e5a			;   None 
8e5a			 
8e5a			free_internal: 
8e5a			    ld de, (heap_start) ; Load start of heap into DE 
8e5a			    ld bc, 0            ; Initialize counter 
8e5a			 
8e5a			free_search_loop: 
8e5a			    ; Check if current block contains the pointer 
8e5a			    ld a, l             ; Load low byte of pointer 
8e5a			    cp (hl+1)           ; Compare with high byte of current block's address 
8e5a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8e5a			    ld a, h             ; Load high byte of pointer 
8e5a			    cp (hl+2)           ; Compare with low byte of current block's address 
8e5a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8e5a			 
8e5a			    ; Mark block as free 
8e5a			    ld (hl), 0          ; Set status byte to indicate free block 
8e5a			    ret                 ; Return 
8e5a			 
8e5a			free_skip_block_check: 
8e5a			    ; Move to the next block 
8e5a			    ld bc, 3            ; Size of management overhead 
8e5a			    add hl, bc          ; Move to the next block 
8e5a			    inc de              ; Increment counter 
8e5a			 
8e5a			    ; Check if we have reached the end of heap 
8e5a			    ld a, e             ; Load low byte of heap end address 
8e5a			    cp (hl)             ; Compare with low byte of current address 
8e5a			    jr nz, free_search_loop  ; If not equal, continue searching 
8e5a			    ld a, d             ; Load high byte of heap end address 
8e5a			    cp 0                ; Check if it's zero (end of memory) 
8e5a			    jr nz, free_search_loop  ; If not zero, continue searching 
8e5a			 
8e5a			    ; If we reached here, pointer is not found in heap 
8e5a			    ret 
8e5a			 
8e5a			free_exit: 
8e5a			    ret                 ; Return 
8e5a			 
8e5a			; Define heap start and end addresses 
8e5a			;heap_start:    .dw 0xC000   ; Start of heap 
8e5a			;heap_end:      .dw 0xE000   ; End of heap 
8e5a			 
8e5a			endif 
8e5a			 
8e5a			 
8e5a			if MALLOC_1 
8e5a			 
8e5a			 
8e5a			 
8e5a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8e5a			 
8e5a			;moved to firmware.asm 
8e5a			;heap_start        .equ  0x9000      ; Starting address of heap 
8e5a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8e5a			 
8e5a			;      .org 0 
8e5a			;      jp    main 
8e5a			 
8e5a			 
8e5a			;      .org  0x100 
8e5a			;main: 
8e5a			;      ld    HL, 0x8100 
8e5a			;      ld    SP, HL 
8e5a			; 
8e5a			;      call  heap_init 
8e5a			; 
8e5a			;      ; Make some allocations 
8e5a			;      ld    HL, 12 
8e5a			;      call  malloc            ; Allocates 0x9004 
8e5a			; 
8e5a			;      ld    HL, 12 
8e5a			;      call  malloc            ; Allocates 0x9014 
8e5a			; 
8e5a			;      ld    HL, 12 
8e5a			;      call  malloc            ; Allocates 0x9024 
8e5a			; 
8e5a			;      ; Free some allocations 
8e5a			;      ld    HL, 0x9014 
8e5a			;      call  free 
8e5a			; 
8e5a			;      ld    HL, 0x9004 
8e5a			;      call  free 
8e5a			; 
8e5a			;      ld    HL, 0x9024 
8e5a			;      call  free 
8e5a			; 
8e5a			; 
8e5a			;      halt 
8e5a			 
8e5a			 
8e5a			;------------------------------------------------------------------------------ 
8e5a			;     heap_init                                                               : 
8e5a			;                                                                             : 
8e5a			; Description                                                                 : 
8e5a			;     Initialise the heap and make it ready for malloc and free operations.   : 
8e5a			;                                                                             : 
8e5a			;     The heap is maintained as a linked list, starting with an initial       : 
8e5a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8e5a			;     the first free block in the heap. Each block then points to the next    : 
8e5a			;     free block within the heap, and the free list ends at the first block   : 
8e5a			;     with a null pointer to the next free block.                             : 
8e5a			;                                                                             : 
8e5a			; Parameters                                                                  : 
8e5a			;     Inputs are compile-time only. Two defines which specify the starting    : 
8e5a			;     address of the heap and its size are required, along with a memory      : 
8e5a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8e5a			;     principally stores a pointer to the first free block in the heap.       : 
8e5a			;                                                                             : 
8e5a			; Returns                                                                     : 
8e5a			;     Nothing                                                                 : 
8e5a			;------------------------------------------------------------------------------ 
8e5a			heap_init: 
8e5a e5			      push  HL 
8e5b			 
8e5b			      ; Initialise free list struct 
8e5b 21 c3 d4		      ld    HL, heap_start 
8e5e 22 be d4		      ld    (free_list), HL 
8e61 21 00 00		      ld    HL, 0 
8e64 22 c0 d4		      ld    (free_list+2), HL 
8e67			 
8e67			      ; Insert first free block at bottom of heap, consumes entire heap 
8e67 21 65 e3		      ld    HL, heap_start+heap_size-4 
8e6a 22 c3 d4		      ld    (heap_start), HL        ; Next block (end of free list) 
8e6d 21 a2 0e		      ld    HL, heap_size-4 
8e70 22 c5 d4		      ld    (heap_start+2), HL      ; Block size 
8e73			 
8e73			      ; Insert end of free list block at top of heap - two null words will 
8e73			      ; terminate the free list 
8e73 21 00 00		      ld    HL, 0 
8e76 22 67 e3		      ld    (heap_start+heap_size-2), HL 
8e79 22 65 e3		      ld    (heap_start+heap_size-4), HL 
8e7c			 
8e7c e1			      pop   HL 
8e7d			 
8e7d c9			      ret 
8e7e			 
8e7e			 
8e7e			;------------------------------------------------------------------------------ 
8e7e			;     malloc                                                                  : 
8e7e			;                                                                             : 
8e7e			; Description                                                                 : 
8e7e			;     Allocates the wanted space from the heap and returns the address of the : 
8e7e			;     first useable byte of the allocation.                                   : 
8e7e			;                                                                             : 
8e7e			;     Allocations can happen in one of two ways:                              : 
8e7e			;                                                                             : 
8e7e			;     1. A free block may be found which is the exact size wanted. In this    : 
8e7e			;        case the block is removed from the free list and retuedn to the      : 
8e7e			;        caller.                                                              : 
8e7e			;     2. A free block may be found which is larger than the size wanted. In   : 
8e7e			;        this case, the larger block is split into two. The first portion of  : 
8e7e			;        this block will become the requested space by the malloc call and    : 
8e7e			;        is returned to the caller. The second portion becomes a new free     : 
8e7e			;        block, and the free list is adjusted to maintain continuity via this : 
8e7e			;        newly created block.                                                 : 
8e7e			;                                                                             : 
8e7e			;     malloc does not set any initial value in the allocated space, the       : 
8e7e			;     caller is required to do this as required.                              : 
8e7e			;                                                                             : 
8e7e			;     This implementation of malloc uses the stack exclusively, and is        : 
8e7e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8e7e			;     advisable to disable interrupts before calling malloc, and recommended  : 
8e7e			;     to avoid the use of malloc inside ISRs in general.                      : 
8e7e			;                                                                             : 
8e7e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8e7e			;                                                                             : 
8e7e			; Parameters                                                                  : 
8e7e			;     HL  Number of bytes wanted                                              : 
8e7e			;                                                                             : 
8e7e			; Returns                                                                     : 
8e7e			;     HL  Address of the first useable byte of the allocation                 : 
8e7e			;                                                                             : 
8e7e			; Flags                                                                       : 
8e7e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8e7e			;                                                                             : 
8e7e			; Stack frame                                                                 : 
8e7e			;       |             |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |     BC      |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |     DE      |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |     IX      |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |  prev_free  |                                                       : 
8e7e			;   +4  +-------------+                                                       : 
8e7e			;       |  this_free  |                                                       : 
8e7e			;   +2  +-------------+                                                       : 
8e7e			;       |  next_free  |                                                       : 
8e7e			;   +0  +-------------+                                                       : 
8e7e			;       |             |                                                       : 
8e7e			;                                                                             : 
8e7e			;------------------------------------------------------------------------------ 
8e7e			 
8e7e			 
8e7e			;malloc: 
8e7e			; 
8e7e			;	SAVESP ON 1 
8e7e			; 
8e7e			;	call malloc_code 
8e7e			; 
8e7e			;	CHECKSP ON 1 
8e7e			;	ret 
8e7e			 
8e7e			 
8e7e			malloc: 
8e7e c5			      push  BC 
8e7f d5			      push  DE 
8e80 dd e5		      push  IX 
8e82			if DEBUG_FORTH_MALLOC_HIGH 
8e82			call malloc_guard_entry 
8e82			endif 
8e82			 
8e82					if DEBUG_FORTH_MALLOC 
8e82						DMARK "mal" 
8e82						CALLMONITOR 
8e82					endif 
8e82 7c			      ld    A, H                    ; Exit if no space requested 
8e83 b5			      or    L 
8e84 ca 43 8f		      jp    Z, malloc_early_exit 
8e87			 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			; 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			 
8e87			 
8e87			 
8e87			 
8e87					if DEBUG_FORTH_MALLOC 
8e87						DMARK "maA" 
8e87						CALLMONITOR 
8e87					endif 
8e87			      ; Set up stack frame 
8e87 eb			      ex    DE, HL 
8e88 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8e8b 39			      add   HL, SP 
8e8c f9			      ld    SP, HL 
8e8d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8e91 dd 39		      add   IX, SP 
8e93			 
8e93			      ; Setup initial state 
8e93 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8e96 19			      add   HL, DE 
8e97			 
8e97 44			      ld    B, H                    ; Move want to BC 
8e98 4d			      ld    C, L 
8e99			 
8e99 21 be d4		      ld    HL, free_list           ; Store prev_free ptr to stack 
8e9c dd 75 04		      ld    (IX+4), L 
8e9f dd 74 05		      ld    (IX+5), H 
8ea2			 
8ea2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8ea3 23			      inc   HL 
8ea4 56			      ld    D, (HL) 
8ea5 dd 73 02		      ld    (IX+2), E 
8ea8 dd 72 03		      ld    (IX+3), D 
8eab eb			      ex    DE, HL                  ; this_free ptr into HL 
8eac			 
8eac					if DEBUG_FORTH_MALLOC 
8eac						DMARK "maB" 
8eac						CALLMONITOR 
8eac					endif 
8eac			      ; Loop through free block list to find some space 
8eac			malloc_find_space: 
8eac 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8ead 23			      inc   HL 
8eae 56			      ld    D, (HL) 
8eaf			 
8eaf 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8eb0 b3			      or    E 
8eb1 ca 3d 8f		      jp    Z, malloc_no_space 
8eb4			 
8eb4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8eb7 dd 72 01		      ld    (IX+1), D 
8eba			 
8eba			      ; Does this block have enough space to make the allocation? 
8eba 23			      inc   HL                      ; Load free block size into DE 
8ebb 5e			      ld    E, (HL) 
8ebc 23			      inc   HL 
8ebd 56			      ld    D, (HL) 
8ebe			 
8ebe eb			      ex    DE, HL                  ; Check size of block against want 
8ebf b7			      or    A                       ; Ensure carry flag clear 
8ec0 ed 42		      sbc   HL, BC 
8ec2 e5			      push  HL                      ; Store the result for later (new block size) 
8ec3			 
8ec3 ca 12 8f		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8ec6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8ec8			 
8ec8			      ; this_free block is not big enough, setup ptrs to test next free block 
8ec8 e1			      pop   HL                      ; Discard previous result 
8ec9			 
8ec9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8ecc dd 66 03		      ld    H, (IX+3) 
8ecf dd 75 04		      ld    (IX+4), L 
8ed2 dd 74 05		      ld    (IX+5), H 
8ed5			 
8ed5 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8ed8 dd 66 01		      ld    H, (IX+1) 
8edb dd 75 02		      ld    (IX+2), L 
8ede dd 74 03		      ld    (IX+3), H 
8ee1			 
8ee1					if DEBUG_FORTH_MALLOC 
8ee1						DMARK "MA>" 
8ee1						CALLMONITOR 
8ee1					endif 
8ee1 18 c9		      jr    malloc_find_space 
8ee3			 
8ee3			      ; split a bigger block into two - requested size and remaining size 
8ee3			malloc_alloc_split: 
8ee3					if DEBUG_FORTH_MALLOC 
8ee3						DMARK "MAs" 
8ee3						CALLMONITOR 
8ee3					endif 
8ee3 eb			      ex    DE, HL                  ; Calculate address of new free block 
8ee4 2b			      dec   HL 
8ee5 2b			      dec   HL 
8ee6 2b			      dec   HL 
8ee7 09			      add   HL, BC 
8ee8			 
8ee8			      ; Create a new block and point it at next_free 
8ee8 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8eeb dd 56 01		      ld    D, (IX+1) 
8eee			 
8eee 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8eef 23			      inc   HL 
8ef0 72			      ld    (HL), D 
8ef1			 
8ef1 d1			      pop   DE                      ; Store size of new block into new block 
8ef2 23			      inc   HL 
8ef3 73			      ld    (HL), E 
8ef4 23			      inc   HL 
8ef5 72			      ld    (HL), D 
8ef6			 
8ef6			      ; Update this_free ptr to point to new block 
8ef6 2b			      dec   HL 
8ef7 2b			      dec   HL 
8ef8 2b			      dec   HL 
8ef9			 
8ef9 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8efc dd 56 03		      ld    D, (IX+3) 
8eff			 
8eff dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8f02 dd 74 03		      ld    (IX+3), H 
8f05			 
8f05			      ; Modify this_free block to be allocation 
8f05 eb			      ex    DE, HL 
8f06 af			      xor   A                       ; Null the next block ptr of allocated block 
8f07 77			      ld    (HL), A 
8f08 23			      inc   HL 
8f09 77			      ld    (HL), A 
8f0a			 
8f0a 23			      inc   HL                      ; Store want size into allocated block 
8f0b 71			      ld    (HL), C 
8f0c 23			      inc   HL 
8f0d 70			      ld    (HL), B 
8f0e 23			      inc   HL 
8f0f e5			      push  HL                      ; Address of allocation to return 
8f10			 
8f10 18 19		      jr    malloc_update_links 
8f12			 
8f12			malloc_alloc_fit: 
8f12 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
8f13			 
8f13					if DEBUG_FORTH_MALLOC 
8f13						DMARK "MAf" 
8f13						CALLMONITOR 
8f13					endif 
8f13			      ; Modify this_free block to be allocation 
8f13 eb			      ex    DE, HL 
8f14 2b			      dec   HL 
8f15 2b			      dec   HL 
8f16 2b			      dec   HL 
8f17			 
8f17 af			      xor   A                       ; Null the next block ptr of allocated block 
8f18 77			      ld    (HL), A 
8f19 23			      inc   HL 
8f1a 77			      ld    (HL), A 
8f1b			 
8f1b 23			      inc   HL                      ; Store address of allocation to return 
8f1c 23			      inc   HL 
8f1d 23			      inc   HL 
8f1e e5			      push  HL 
8f1f			 
8f1f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
8f1f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
8f22 dd 66 01		      ld    H, (IX+1) 
8f25			 
8f25 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
8f28 dd 74 03		      ld    (IX+3), H 
8f2b			 
8f2b			 
8f2b			malloc_update_links: 
8f2b			      ; Update prev_free ptr to point to this_free 
8f2b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
8f2e dd 66 05		      ld    H, (IX+5) 
8f31			 
8f31 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
8f34 dd 56 03		      ld    D, (IX+3) 
8f37			 
8f37 73			      ld    (HL), E                 ; this_free ptr into prev_free 
8f38 23			      inc   HL 
8f39 72			      ld    (HL), D 
8f3a			 
8f3a					if DEBUG_FORTH_MALLOC 
8f3a						DMARK "Mul" 
8f3a						CALLMONITOR 
8f3a					endif 
8f3a			      ; Clear the Z flag to indicate successful allocation 
8f3a 7a			      ld    A, D 
8f3b b3			      or    E 
8f3c			 
8f3c d1			      pop   DE                      ; Address of allocation 
8f3d					if DEBUG_FORTH_MALLOC 
8f3d						DMARK "MAu" 
8f3d						CALLMONITOR 
8f3d					endif 
8f3d			 
8f3d			malloc_no_space: 
8f3d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
8f40 39			      add   HL, SP 
8f41 f9			      ld    SP, HL 
8f42			 
8f42 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
8f43					if DEBUG_FORTH_MALLOC 
8f43						DMARK "MAN" 
8f43						CALLMONITOR 
8f43					endif 
8f43			 
8f43			malloc_early_exit: 
8f43					if DEBUG_FORTH_MALLOC 
8f43						DMARK "MAx" 
8f43						CALLMONITOR 
8f43					endif 
8f43 dd e1		      pop   IX 
8f45 d1			      pop   DE 
8f46 c1			      pop   BC 
8f47			 
8f47			if DEBUG_FORTH_MALLOC_HIGH 
8f47			call malloc_guard_exit 
8f47			call malloc_guard_zerolen 
8f47			endif 
8f47 c9			      ret 
8f48			 
8f48			 
8f48			;------------------------------------------------------------------------------ 
8f48			;     free                                                                    : 
8f48			;                                                                             : 
8f48			; Description                                                                 : 
8f48			;     Return the space pointed to by HL to the heap. HL must be an address as : 
8f48			;     returned by malloc, otherwise the behaviour is undefined.               : 
8f48			;                                                                             : 
8f48			;     Where possible, directly adjacent free blocks will be merged together   : 
8f48			;     into larger blocks to help ensure that the heap does not become         : 
8f48			;     excessively fragmented.                                                 : 
8f48			;                                                                             : 
8f48			;     free does not clear or set any other value into the freed space, and    : 
8f48			;     therefore its contents may be visible through subsequent malloc's. The  : 
8f48			;     caller should clear the freed space as required.                        : 
8f48			;                                                                             : 
8f48			;     This implementation of free uses the stack exclusively, and is          : 
8f48			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f48			;     advisable to disable interrupts before calling free, and recommended    : 
8f48			;     to avoid the use of free inside ISRs in general.                        : 
8f48			;                                                                             : 
8f48			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f48			;                                                                             : 
8f48			; Parameters                                                                  : 
8f48			;     HL  Pointer to address of first byte of allocation to be freed          : 
8f48			;                                                                             : 
8f48			; Returns                                                                     : 
8f48			;     Nothing                                                                 : 
8f48			;                                                                             : 
8f48			; Stack frame                                                                 : 
8f48			;       |             |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |     BC      |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |     DE      |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |     IX      |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |  prev_free  |                                                       : 
8f48			;   +2  +-------------+                                                       : 
8f48			;       |  next_free  |                                                       : 
8f48			;   +0  +-------------+                                                       : 
8f48			;       |             |                                                       : 
8f48			;                                                                             : 
8f48			;------------------------------------------------------------------------------ 
8f48			free: 
8f48 c5			      push  BC 
8f49 d5			      push  DE 
8f4a dd e5		      push  IX 
8f4c			 
8f4c 7c			      ld    A, H                    ; Exit if ptr is null 
8f4d b5			      or    L 
8f4e ca 12 90		      jp    Z, free_early_exit 
8f51			 
8f51			      ; Set up stack frame 
8f51 eb			      ex    DE, HL 
8f52 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
8f55 39			      add   HL, SP 
8f56 f9			      ld    SP, HL 
8f57 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f5b dd 39		      add   IX, SP 
8f5d			 
8f5d			      ; The address in HL points to the start of the useable allocated space, 
8f5d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
8f5d			      ; address of the block itself. 
8f5d eb			      ex    DE, HL 
8f5e 11 fc ff		      ld    DE, -4 
8f61 19			      add   HL, DE 
8f62			 
8f62			      ; An allocated block must have a null next block pointer in it 
8f62 7e			      ld    A, (HL) 
8f63 23			      inc   HL 
8f64 b6			      or    (HL) 
8f65 c2 0d 90		      jp    NZ, free_done 
8f68			 
8f68 2b			      dec   HL 
8f69			 
8f69 44			      ld    B, H                    ; Copy HL to BC 
8f6a 4d			      ld    C, L 
8f6b			 
8f6b			      ; Loop through the free list to find the first block with an address 
8f6b			      ; higher than the block being freed 
8f6b 21 be d4		      ld    HL, free_list 
8f6e			 
8f6e			free_find_higher_block: 
8f6e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
8f6f 23			      inc   HL 
8f70 56			      ld    D, (HL) 
8f71 2b			      dec   HL 
8f72			 
8f72 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
8f75 dd 72 01		      ld    (IX+1), D 
8f78 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
8f7b dd 74 03		      ld    (IX+3), H 
8f7e			 
8f7e 78			      ld    A, B                    ; Check if DE is greater than BC 
8f7f ba			      cp    D                       ; Compare MSB first 
8f80 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
8f82 30 04		      jr    NC, free_find_higher_block_skip 
8f84 79			      ld    A, C 
8f85 bb			      cp    E                       ; Then compare LSB 
8f86 38 08		      jr    C, free_found_higher_block 
8f88			 
8f88			free_find_higher_block_skip: 
8f88 7a			      ld    A, D                    ; Reached the end of the free list? 
8f89 b3			      or    E 
8f8a ca 0d 90		      jp    Z, free_done 
8f8d			 
8f8d eb			      ex    DE, HL 
8f8e			 
8f8e 18 de		      jr    free_find_higher_block 
8f90			 
8f90			free_found_higher_block: 
8f90			      ; Insert freed block between prev and next free blocks 
8f90 71			      ld    (HL), C                 ; Point prev free block to freed block 
8f91 23			      inc   HL 
8f92 70			      ld    (HL), B 
8f93			 
8f93 60			      ld    H, B                    ; Point freed block at next free block 
8f94 69			      ld    L, C 
8f95 73			      ld    (HL), E 
8f96 23			      inc   HL 
8f97 72			      ld    (HL), D 
8f98			 
8f98			      ; Check if the freed block is adjacent to the next free block 
8f98 23			      inc   HL                      ; Load size of freed block into HL 
8f99 5e			      ld    E, (HL) 
8f9a 23			      inc   HL 
8f9b 56			      ld    D, (HL) 
8f9c eb			      ex    DE, HL 
8f9d			 
8f9d 09			      add   HL, BC                  ; Add addr of freed block and its size 
8f9e			 
8f9e dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
8fa1 dd 56 01		      ld    D, (IX+1) 
8fa4			 
8fa4 b7			      or    A                       ; Clear the carry flag 
8fa5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
8fa7 20 22		      jr    NZ, free_check_adjacent_to_prev 
8fa9			 
8fa9			      ; Freed block is adjacent to next, merge into one bigger block 
8fa9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
8faa 5e			      ld    E, (HL) 
8fab 23			      inc   HL 
8fac 56			      ld    D, (HL) 
8fad e5			      push  HL                      ; Save ptr to next block for later 
8fae			 
8fae 60			      ld    H, B                    ; Store ptr from next block into freed block 
8faf 69			      ld    L, C 
8fb0 73			      ld    (HL), E 
8fb1 23			      inc   HL 
8fb2 72			      ld    (HL), D 
8fb3			 
8fb3 e1			      pop   HL                      ; Restore ptr to next block 
8fb4 23			      inc   HL                      ; Load size of next block into DE 
8fb5 5e			      ld    E, (HL) 
8fb6 23			      inc   HL 
8fb7 56			      ld    D, (HL) 
8fb8 d5			      push  DE                      ; Save next block size for later 
8fb9			 
8fb9 60			      ld    H, B                    ; Load size of freed block into HL 
8fba 69			      ld    L, C 
8fbb 23			      inc   HL 
8fbc 23			      inc   HL 
8fbd 5e			      ld    E, (HL) 
8fbe 23			      inc   HL 
8fbf 56			      ld    D, (HL) 
8fc0 eb			      ex    DE, HL 
8fc1			 
8fc1 d1			      pop   DE                      ; Restore size of next block 
8fc2 19			      add   HL, DE                  ; Add sizes of both blocks 
8fc3 eb			      ex    DE, HL 
8fc4			 
8fc4 60			      ld    H, B                    ; Store new bigger size into freed block 
8fc5 69			      ld    L, C 
8fc6 23			      inc   HL 
8fc7 23			      inc   HL 
8fc8 73			      ld    (HL), E 
8fc9 23			      inc   HL 
8fca 72			      ld    (HL), D 
8fcb			 
8fcb			free_check_adjacent_to_prev: 
8fcb			      ; Check if the freed block is adjacent to the prev free block 
8fcb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
8fce dd 66 03		      ld    H, (IX+3) 
8fd1			 
8fd1 23			      inc   HL                      ; Size of prev free block into DE 
8fd2 23			      inc   HL 
8fd3 5e			      ld    E, (HL) 
8fd4 23			      inc   HL 
8fd5 56			      ld    D, (HL) 
8fd6 2b			      dec   HL 
8fd7 2b			      dec   HL 
8fd8 2b			      dec   HL 
8fd9			 
8fd9 19			      add   HL, DE                  ; Add prev block addr and size 
8fda			 
8fda b7			      or    A                       ; Clear the carry flag 
8fdb ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
8fdd 20 2e		      jr    NZ, free_done 
8fdf			 
8fdf			      ; Freed block is adjacent to prev, merge into one bigger block 
8fdf 60			      ld    H, B                    ; Load next ptr from freed block into DE 
8fe0 69			      ld    L, C 
8fe1 5e			      ld    E, (HL) 
8fe2 23			      inc   HL 
8fe3 56			      ld    D, (HL) 
8fe4 e5			      push  HL                      ; Save freed block ptr for later 
8fe5			 
8fe5 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
8fe8 dd 66 03		      ld    H, (IX+3) 
8feb 73			      ld    (HL), E 
8fec 23			      inc   HL 
8fed 72			      ld    (HL), D 
8fee			 
8fee e1			      pop   HL                      ; Restore freed block ptr 
8fef 23			      inc   HL                      ; Load size of freed block into DE 
8ff0 5e			      ld    E, (HL) 
8ff1 23			      inc   HL 
8ff2 56			      ld    D, (HL) 
8ff3 d5			      push  DE                      ; Save freed block size for later 
8ff4			 
8ff4 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
8ff7 dd 66 03		      ld    H, (IX+3) 
8ffa 23			      inc   HL 
8ffb 23			      inc   HL 
8ffc 5e			      ld    E, (HL) 
8ffd 23			      inc   HL 
8ffe 56			      ld    D, (HL) 
8fff			 
8fff e1			      pop   HL                      ; Add sizes of both blocks 
9000 19			      add   HL, DE 
9001 eb			      ex    DE, HL 
9002			 
9002 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9005 dd 66 03		      ld    H, (IX+3) 
9008 23			      inc   HL 
9009 23			      inc   HL 
900a 73			      ld    (HL), E 
900b 23			      inc   HL 
900c 72			      ld    (HL), D 
900d			 
900d			free_done: 
900d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9010 39			      add   HL, SP 
9011 f9			      ld    SP, HL 
9012			 
9012			free_early_exit: 
9012 dd e1		      pop   IX 
9014 d1			      pop   DE 
9015 c1			      pop   BC 
9016			 
9016 c9			      ret 
9017			 
9017			; moved to firmware.asm 
9017			; 
9017			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9017			;                  .dw   0 
9017			 
9017			 
9017			endif 
9017			 
9017			 
9017			if MALLOC_3 
9017			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9017			;heap_start        .equ  0x9000      ; Starting address of heap 
9017			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9017			; 
9017			 ;     .org 0 
9017			  ;    jp    main 
9017			; 
9017			; 
9017			 ;     .org  0x100 
9017			;main: 
9017			 ;     ld    HL, 0x8100 
9017			  ;    ld    SP, HL 
9017			; 
9017			;      call  heap_init 
9017			 
9017			      ; Make some allocations 
9017			;      ld    HL, 12 
9017			;      call  malloc            ; Allocates 0x9004 
9017			; 
9017			 ;     ld    HL, 12 
9017			;      call  malloc            ; Allocates 0x9014 
9017			 
9017			;      ld    HL, 12 
9017			;      call  malloc            ; Allocates 0x9024 
9017			 
9017			      ; Free some allocations 
9017			;      ld    HL, 0x9014 
9017			;      call  free 
9017			 
9017			;      ld    HL, 0x9004 
9017			;      call  free 
9017			; 
9017			;      ld    HL, 0x9024 
9017			;      call  free 
9017			 
9017			 
9017			 ;     halt 
9017			 
9017			 
9017			;------------------------------------------------------------------------------ 
9017			;     heap_init                                                               : 
9017			;                                                                             : 
9017			; Description                                                                 : 
9017			;     Initialise the heap and make it ready for malloc and free operations.   : 
9017			;                                                                             : 
9017			;     The heap is maintained as a linked list, starting with an initial       : 
9017			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9017			;     the first free block in the heap. Each block then points to the next    : 
9017			;     free block within the heap, and the free list ends at the first block   : 
9017			;     with a null pointer to the next free block.                             : 
9017			;                                                                             : 
9017			; Parameters                                                                  : 
9017			;     Inputs are compile-time only. Two defines which specify the starting    : 
9017			;     address of the heap and its size are required, along with a memory      : 
9017			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9017			;     principally stores a pointer to the first free block in the heap.       : 
9017			;                                                                             : 
9017			; Returns                                                                     : 
9017			;     Nothing                                                                 : 
9017			;------------------------------------------------------------------------------ 
9017			heap_init: 
9017			      push  HL 
9017			 
9017			      ; Initialise free list struct 
9017			      ld    HL, heap_start 
9017			      ld    (free_list), HL 
9017			      ld    HL, 0 
9017			      ld    (free_list+2), HL 
9017			 
9017			      ; Insert first free block at bottom of heap, consumes entire heap 
9017			      ld    HL, heap_start+heap_size-4 
9017			      ld    (heap_start), HL        ; Next block (end of free list) 
9017			      ld    HL, heap_size-4 
9017			      ld    (heap_start+2), HL      ; Block size 
9017			 
9017			      ; Insert end of free list block at top of heap - two null words will 
9017			      ; terminate the free list 
9017			      ld    HL, 0 
9017			      ld    (heap_start+heap_size-2), HL 
9017			      ld    (heap_start+heap_size-4), HL 
9017			 
9017			      pop   HL 
9017			 
9017			      ret 
9017			 
9017			 
9017			;------------------------------------------------------------------------------ 
9017			;     malloc                                                                  : 
9017			;                                                                             : 
9017			; Description                                                                 : 
9017			;     Allocates the wanted space from the heap and returns the address of the : 
9017			;     first useable byte of the allocation.                                   : 
9017			;                                                                             : 
9017			;     Allocations can happen in one of two ways:                              : 
9017			;                                                                             : 
9017			;     1. A free block may be found which is the exact size wanted. In this    : 
9017			;        case the block is removed from the free list and retuedn to the      : 
9017			;        caller.                                                              : 
9017			;     2. A free block may be found which is larger than the size wanted. In   : 
9017			;        this case, the larger block is split into two. The first portion of  : 
9017			;        this block will become the requested space by the malloc call and    : 
9017			;        is returned to the caller. The second portion becomes a new free     : 
9017			;        block, and the free list is adjusted to maintain continuity via this : 
9017			;        newly created block.                                                 : 
9017			;                                                                             : 
9017			;     malloc does not set any initial value in the allocated space, the       : 
9017			;     caller is required to do this as required.                              : 
9017			;                                                                             : 
9017			;     This implementation of malloc uses the stack exclusively, and is        : 
9017			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9017			;     advisable to disable interrupts before calling malloc, and recommended  : 
9017			;     to avoid the use of malloc inside ISRs in general.                      : 
9017			;                                                                             : 
9017			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9017			;                                                                             : 
9017			; Parameters                                                                  : 
9017			;     HL  Number of bytes wanted                                              : 
9017			;                                                                             : 
9017			; Returns                                                                     : 
9017			;     HL  Address of the first useable byte of the allocation                 : 
9017			;                                                                             : 
9017			; Flags                                                                       : 
9017			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9017			;                                                                             : 
9017			; Stack frame                                                                 : 
9017			;       |             |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     BC      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     DE      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     IX      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |  prev_free  |                                                       : 
9017			;   +4  +-------------+                                                       : 
9017			;       |  this_free  |                                                       : 
9017			;   +2  +-------------+                                                       : 
9017			;       |  next_free  |                                                       : 
9017			;   +0  +-------------+                                                       : 
9017			;       |             |                                                       : 
9017			;                                                                             : 
9017			;------------------------------------------------------------------------------ 
9017			malloc: 
9017			      push  BC 
9017			      push  DE 
9017			      push  IX 
9017			 
9017			      ld    A, H                    ; Exit if no space requested 
9017			      or    L 
9017			      jp    Z, malloc_early_exit 
9017			 
9017			      ; Set up stack frame 
9017			      ex    DE, HL 
9017			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			      ld    IX, 0                   ; Use IX as a frame pointer 
9017			      add   IX, SP 
9017			 
9017			      ; Setup initial state 
9017			      ld    HL, 4                   ; want must also include space used by block struct 
9017			      add   HL, DE 
9017			 
9017			      ld    B, H                    ; Move want to BC 
9017			      ld    C, L 
9017			 
9017			      ld    HL, free_list           ; Store prev_free ptr to stack 
9017			      ld    (IX+4), L 
9017			      ld    (IX+5), H 
9017			 
9017			      ld    E, (HL)                 ; Store this_free ptr to stack 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      ld    (IX+2), E 
9017			      ld    (IX+3), D 
9017			      ex    DE, HL                  ; this_free ptr into HL 
9017			 
9017			      ; Loop through free block list to find some space 
9017			malloc_find_space: 
9017			      ld    E, (HL)                 ; Load next_free ptr into DE 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			 
9017			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9017			      or    E 
9017			      jp    Z, malloc_no_space 
9017			 
9017			      ld    (IX+0), E               ; Store next_free ptr to stack 
9017			      ld    (IX+1), D 
9017			 
9017			      ; Does this block have enough space to make the allocation? 
9017			      inc   HL                      ; Load free block size into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			 
9017			      ex    DE, HL                  ; Check size of block against want 
9017			      or    A                       ; Ensure carry flag clear 
9017			      sbc   HL, BC 
9017			      push  HL                      ; Store the result for later (new block size) 
9017			 
9017			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9017			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9017			 
9017			      ; this_free block is not big enough, setup ptrs to test next free block 
9017			      pop   HL                      ; Discard previous result 
9017			 
9017			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9017			      ld    H, (IX+3) 
9017			      ld    (IX+4), L 
9017			      ld    (IX+5), H 
9017			 
9017			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9017			      ld    H, (IX+1) 
9017			      ld    (IX+2), L 
9017			      ld    (IX+3), H 
9017			 
9017			      jr    malloc_find_space 
9017			 
9017			      ; split a bigger block into two - requested size and remaining size 
9017			malloc_alloc_split: 
9017			      ex    DE, HL                  ; Calculate address of new free block 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			      add   HL, BC 
9017			 
9017			      ; Create a new block and point it at next_free 
9017			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9017			      ld    D, (IX+1) 
9017			 
9017			      ld    (HL), E                 ; Store next_free ptr into new block 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      pop   DE                      ; Store size of new block into new block 
9017			      inc   HL 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      ; Update this_free ptr to point to new block 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			 
9017			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9017			      ld    D, (IX+3) 
9017			 
9017			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9017			      ld    (IX+3), H 
9017			 
9017			      ; Modify this_free block to be allocation 
9017			      ex    DE, HL 
9017			      xor   A                       ; Null the next block ptr of allocated block 
9017			      ld    (HL), A 
9017			      inc   HL 
9017			      ld    (HL), A 
9017			 
9017			      inc   HL                      ; Store want size into allocated block 
9017			      ld    (HL), C 
9017			      inc   HL 
9017			      ld    (HL), B 
9017			      inc   HL 
9017			      push  HL                      ; Address of allocation to return 
9017			 
9017			      jr    malloc_update_links 
9017			 
9017			malloc_alloc_fit: 
9017			      pop   HL                      ; Dont need new block size, want is exact fit 
9017			 
9017			      ; Modify this_free block to be allocation 
9017			      ex    DE, HL 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			 
9017			      xor   A                       ; Null the next block ptr of allocated block 
9017			      ld    (HL), A 
9017			      inc   HL 
9017			      ld    (HL), A 
9017			 
9017			      inc   HL                      ; Store address of allocation to return 
9017			      inc   HL 
9017			      inc   HL 
9017			      push  HL 
9017			 
9017			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9017			      ld    L, (IX+0)               ; next_free to HL 
9017			      ld    H, (IX+1) 
9017			 
9017			      ld    (IX+2), L               ; HL to this_free 
9017			      ld    (IX+3), H 
9017			 
9017			 
9017			malloc_update_links: 
9017			      ; Update prev_free ptr to point to this_free 
9017			      ld    L, (IX+4)               ; prev_free ptr to HL 
9017			      ld    H, (IX+5) 
9017			 
9017			      ld    E, (IX+2)               ; this_free ptr to DE 
9017			      ld    D, (IX+3) 
9017			 
9017			      ld    (HL), E                 ; this_free ptr into prev_free 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      ; Clear the Z flag to indicate successful allocation 
9017			      ld    A, D 
9017			      or    E 
9017			 
9017			      pop   DE                      ; Address of allocation 
9017			 
9017			malloc_no_space: 
9017			      ld    HL, 6                   ; Clean up stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			 
9017			      ex    DE, HL                  ; Alloc addr into HL for return 
9017			 
9017			malloc_early_exit: 
9017			      pop   IX 
9017			      pop   DE 
9017			      pop   BC 
9017			 
9017			      ret 
9017			 
9017			 
9017			;------------------------------------------------------------------------------ 
9017			;     free                                                                    : 
9017			;                                                                             : 
9017			; Description                                                                 : 
9017			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9017			;     returned by malloc, otherwise the behaviour is undefined.               : 
9017			;                                                                             : 
9017			;     Where possible, directly adjacent free blocks will be merged together   : 
9017			;     into larger blocks to help ensure that the heap does not become         : 
9017			;     excessively fragmented.                                                 : 
9017			;                                                                             : 
9017			;     free does not clear or set any other value into the freed space, and    : 
9017			;     therefore its contents may be visible through subsequent malloc's. The  : 
9017			;     caller should clear the freed space as required.                        : 
9017			;                                                                             : 
9017			;     This implementation of free uses the stack exclusively, and is          : 
9017			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9017			;     advisable to disable interrupts before calling free, and recommended    : 
9017			;     to avoid the use of free inside ISRs in general.                        : 
9017			;                                                                             : 
9017			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9017			;                                                                             : 
9017			; Parameters                                                                  : 
9017			;     HL  Pointer to address of first byte of allocation to be freed          : 
9017			;                                                                             : 
9017			; Returns                                                                     : 
9017			;     Nothing                                                                 : 
9017			;                                                                             : 
9017			; Stack frame                                                                 : 
9017			;       |             |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     BC      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     DE      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     IX      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |  prev_free  |                                                       : 
9017			;   +2  +-------------+                                                       : 
9017			;       |  next_free  |                                                       : 
9017			;   +0  +-------------+                                                       : 
9017			;       |             |                                                       : 
9017			;                                                                             : 
9017			;------------------------------------------------------------------------------ 
9017			free: 
9017			      push  BC 
9017			      push  DE 
9017			      push  IX 
9017			 
9017			      ld    A, H                    ; Exit if ptr is null 
9017			      or    L 
9017			      jp    Z, free_early_exit 
9017			 
9017			      ; Set up stack frame 
9017			      ex    DE, HL 
9017			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			      ld    IX, 0                   ; Use IX as a frame pointer 
9017			      add   IX, SP 
9017			 
9017			      ; The address in HL points to the start of the useable allocated space, 
9017			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9017			      ; address of the block itself. 
9017			      ex    DE, HL 
9017			      ld    DE, -4 
9017			      add   HL, DE 
9017			 
9017			      ; An allocated block must have a null next block pointer in it 
9017			      ld    A, (HL) 
9017			      inc   HL 
9017			      or    (HL) 
9017			      jp    NZ, free_done 
9017			 
9017			      dec   HL 
9017			 
9017			      ld    B, H                    ; Copy HL to BC 
9017			      ld    C, L 
9017			 
9017			      ; Loop through the free list to find the first block with an address 
9017			      ; higher than the block being freed 
9017			      ld    HL, free_list 
9017			 
9017			free_find_higher_block: 
9017			      ld    E, (HL)                 ; Load next ptr from free block 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      dec   HL 
9017			 
9017			      ld    (IX+0), E               ; Save ptr to next free block 
9017			      ld    (IX+1), D 
9017			      ld    (IX+2), L               ; Save ptr to prev free block 
9017			      ld    (IX+3), H 
9017			 
9017			      ld    A, B                    ; Check if DE is greater than BC 
9017			      cp    D                       ; Compare MSB first 
9017			      jr    Z, $+4                  ; MSB the same, compare LSB 
9017			      jr    NC, free_find_higher_block_skip 
9017			      ld    A, C 
9017			      cp    E                       ; Then compare LSB 
9017			      jr    C, free_found_higher_block 
9017			 
9017			free_find_higher_block_skip: 
9017			      ld    A, D                    ; Reached the end of the free list? 
9017			      or    E 
9017			      jp    Z, free_done 
9017			 
9017			      ex    DE, HL 
9017			 
9017			      jr    free_find_higher_block 
9017			 
9017			free_found_higher_block: 
9017			      ; Insert freed block between prev and next free blocks 
9017			      ld    (HL), C                 ; Point prev free block to freed block 
9017			      inc   HL 
9017			      ld    (HL), B 
9017			 
9017			      ld    H, B                    ; Point freed block at next free block 
9017			      ld    L, C 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      ; Check if the freed block is adjacent to the next free block 
9017			      inc   HL                      ; Load size of freed block into HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      ex    DE, HL 
9017			 
9017			      add   HL, BC                  ; Add addr of freed block and its size 
9017			 
9017			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9017			      ld    D, (IX+1) 
9017			 
9017			      or    A                       ; Clear the carry flag 
9017			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9017			      jr    NZ, free_check_adjacent_to_prev 
9017			 
9017			      ; Freed block is adjacent to next, merge into one bigger block 
9017			      ex    DE, HL                  ; Load next ptr from next block into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  HL                      ; Save ptr to next block for later 
9017			 
9017			      ld    H, B                    ; Store ptr from next block into freed block 
9017			      ld    L, C 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      pop   HL                      ; Restore ptr to next block 
9017			      inc   HL                      ; Load size of next block into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  DE                      ; Save next block size for later 
9017			 
9017			      ld    H, B                    ; Load size of freed block into HL 
9017			      ld    L, C 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      ex    DE, HL 
9017			 
9017			      pop   DE                      ; Restore size of next block 
9017			      add   HL, DE                  ; Add sizes of both blocks 
9017			      ex    DE, HL 
9017			 
9017			      ld    H, B                    ; Store new bigger size into freed block 
9017			      ld    L, C 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			free_check_adjacent_to_prev: 
9017			      ; Check if the freed block is adjacent to the prev free block 
9017			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9017			      ld    H, (IX+3) 
9017			 
9017			      inc   HL                      ; Size of prev free block into DE 
9017			      inc   HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			 
9017			      add   HL, DE                  ; Add prev block addr and size 
9017			 
9017			      or    A                       ; Clear the carry flag 
9017			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9017			      jr    NZ, free_done 
9017			 
9017			      ; Freed block is adjacent to prev, merge into one bigger block 
9017			      ld    H, B                    ; Load next ptr from freed block into DE 
9017			      ld    L, C 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  HL                      ; Save freed block ptr for later 
9017			 
9017			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9017			      ld    H, (IX+3) 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      pop   HL                      ; Restore freed block ptr 
9017			      inc   HL                      ; Load size of freed block into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  DE                      ; Save freed block size for later 
9017			 
9017			      ld    L, (IX+2)               ; Load size of prev block into DE 
9017			      ld    H, (IX+3) 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			 
9017			      pop   HL                      ; Add sizes of both blocks 
9017			      add   HL, DE 
9017			      ex    DE, HL 
9017			 
9017			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9017			      ld    H, (IX+3) 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			free_done: 
9017			      ld    HL, 4                   ; Clean up stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			 
9017			free_early_exit: 
9017			      pop   IX 
9017			      pop   DE 
9017			      pop   BC 
9017			 
9017			      ret 
9017			 
9017			 
9017			;      .org 0x8000 
9017			; 
9017			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9017			 ;                 .dw   0 
9017			 
9017			endif 
9017			 
9017			 
9017			if MALLOC_4 
9017			 
9017			; My memory allocation code. Very very simple.... 
9017			; allocate space under 250 chars 
9017			 
9017			heap_init: 
9017				; init start of heap as zero 
9017				;  
9017			 
9017				ld hl, heap_start 
9017				ld a, 0 
9017				ld (hl), a      ; empty block 
9017				inc hl 
9017				ld a, 0 
9017				ld (hl), a      ; length of block 
9017				; write end of list 
9017				inc hl 
9017				ld a,(hl) 
9017				inc hl 
9017				ld a,(hl) 
9017				 
9017			 
9017				; init some malloc vars 
9017			 
9017				ld hl, 0 
9017				ld (free_list), hl       ; store last malloc location 
9017			 
9017				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9017				ld a, 0 
9017				ld (hl), a 
9017			 
9017			 
9017				ld hl, heap_start 
9017				;  
9017				  
9017				ret 
9017			 
9017			 
9017			;    free block marker 
9017			;    requested size  
9017			;    pointer to next block 
9017			;    .... 
9017			;    next block marker 
9017			 
9017			 
9017			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9017			; 
9017			 
9017			 
9017			malloc:  
9017				push de 
9017				push bc 
9017				push af 
9017			 
9017				; hl space required 
9017				 
9017				ld c, l    ; hold space   (TODO only a max of 255) 
9017			 
9017			;	inc c     ; TODO BUG need to fix memory leak on push str 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			 
9017			 
9017			 
9017				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9017			 
9017				ld a, (free_list+3) 
9017				cp 0 
9017				jr z, .contheap 
9017			 
9017				ld hl, (free_list)     ; get last alloc 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mrs" 
9017						CALLMONITOR 
9017					endif 
9017				jr .startalloc 
9017			 
9017			.contheap: 
9017				ld hl, heap_start 
9017			 
9017			.startalloc: 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mym" 
9017						CALLMONITOR 
9017					endif 
9017			.findblock: 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mmf" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017				ld a,(hl)  
9017				; if byte is zero then clear to use 
9017			 
9017				cp 0 
9017				jr z, .foundemptyblock 
9017			 
9017				; if byte is not clear 
9017				;     then byte is offset to next block 
9017			 
9017				inc hl 
9017				ld a, (hl) ; get size 
9017			.nextblock:	inc hl 
9017					ld e, (hl) 
9017					inc hl 
9017					ld d, (hl) 
9017					ex de, hl 
9017			;	inc hl  ; move past the store space 
9017			;	inc hl  ; move past zero index  
9017			 
9017				; TODO detect no more space 
9017			 
9017				push hl 
9017				ld de, heap_end 
9017				call cmp16 
9017				pop hl 
9017				jr nc, .nospace 
9017			 
9017				jr .findblock 
9017			 
9017			.nospace: ld hl, 0 
9017				jp .exit 
9017			 
9017			 
9017			.foundemptyblock:	 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mme" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			; TODO has block enough space if reusing??? 
9017			 
9017				;  
9017			 
9017			; see if this block has been previously used 
9017				inc hl 
9017				ld a, (hl) 
9017				dec hl 
9017				cp 0 
9017				jr z, .newblock 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "meR" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			; no reusing previously allocated block 
9017			 
9017			; is it smaller than previously used? 
9017				 
9017				inc hl    ; move to size 
9017				ld a, c 
9017				sub (hl)        ; we want c < (hl) 
9017				dec hl    ; move back to marker 
9017			        jr z, .findblock 
9017			 
9017				; update with the new size which should be lower 
9017			 
9017			        ;inc  hl   ; negate next move. move back to size  
9017			 
9017			.newblock: 
9017				; need to be at marker here 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "meN" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			 
9017				ld a, c 
9017			 
9017				ld (free_list+3), a	 ; flag resume from last malloc  
9017				ld (free_list), hl    ; save out last location 
9017			 
9017			 
9017				;inc a     ; space for length byte 
9017				ld (hl), a     ; save block in use marker 
9017			 
9017				inc hl   ; move to space marker 
9017				ld (hl), a    ; save new space 
9017			 
9017				inc hl   ; move to start of allocated area 
9017				 
9017			;	push hl     ; save where we are - 1  
9017			 
9017			;	inc hl  ; move past zero index  
9017				; skip space to set down new marker 
9017			 
9017				; provide some extra space for now 
9017			 
9017				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9017				inc a 
9017				inc a 
9017			 
9017				push hl   ; save where we are in the node block 
9017			 
9017				call addatohl 
9017			 
9017				; write linked list point 
9017			 
9017				pop de     ; get our node position 
9017				ex de, hl 
9017			 
9017				ld (hl), e 
9017				inc hl 
9017				ld (hl), d 
9017			 
9017				inc hl 
9017			 
9017				; now at start of allocated data so save pointer 
9017			 
9017				push hl 
9017			 
9017				; jump to position of next node and setup empty header in DE 
9017			 
9017				ex de, hl 
9017			 
9017			;	inc hl ; move past end of block 
9017			 
9017				ld a, 0 
9017				ld (hl), a   ; empty marker 
9017				inc hl 
9017				ld (hl), a   ; size 
9017				inc hl  
9017				ld (hl), a   ; ptr 
9017				inc hl 
9017				ld (hl), a   ; ptr 
9017			 
9017			 
9017				pop hl 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mmr" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			.exit: 
9017				pop af 
9017				pop bc 
9017				pop de  
9017				ret 
9017			 
9017			 
9017			 
9017			 
9017			free:  
9017				push hl 
9017				push af 
9017				; get address in hl 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "fre" 
9017						CALLMONITOR 
9017					endif 
9017				; data is at hl - move to block count 
9017				dec hl 
9017				dec hl    ; get past pointer 
9017				dec hl 
9017			 
9017				ld a, (hl)    ; need this for a validation check 
9017			 
9017				dec hl    ; move to block marker 
9017			 
9017				; now check that the block count and block marker are the same  
9017			        ; this checks that we are on a malloc node and not random memory 
9017			        ; OK a faint chance this could be a problem but rare - famous last words! 
9017			 
9017				ld c, a 
9017				ld a, (hl)    
9017			 
9017				cp c 
9017				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9017			 
9017				; yes good chance we are on a malloc node 
9017			 
9017				ld a, 0      
9017				ld (hl), a   ; mark as free 
9017			 
9017				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9017			 
9017			.freeignore:  
9017			 
9017				pop af 
9017				pop hl 
9017			 
9017				ret 
9017			 
9017			 
9017			 
9017			endif 
9017			 
9017			; eof 
# End of file firmware_memory.asm
9017			  
9017			; device C  
9017			if SOUND_ENABLE  
9017				include "firmware_sound.asm"  
9017			endif  
9017			  
9017			include "firmware_diags.asm"  
9017			; Hardware diags menu 
9017			 
9017			 
9017 .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9038 .. 00		hd_menu2:   db "        2: Editor",0   
904a			;hd_menu2:   db "        2: Editor       6: BASIC",0   
904a .. 00		hd_menu3:   db "        3: Storage",0 
905d .. 00		hd_menu4:   db "0=quit  4: Debug",0 
906e .. 00		hd_don:     db "ON",0 
9071 .. 00		hd_doff:     db "OFF",0 
9075			 
9075			 
9075			 
9075			hardware_diags:       
9075			 
9075			.diagmenu: 
9075 cd 5e 88			call clear_display 
9078 3e 00			ld a, display_row_1 
907a 11 17 90			ld de, hd_menu1 
907d cd 71 88			call str_at_display 
9080			 
9080 3e 28			ld a, display_row_2 
9082 11 38 90			ld de, hd_menu2 
9085 cd 71 88			call str_at_display 
9088			 
9088 3e 50			ld a, display_row_3 
908a 11 4a 90			ld de, hd_menu3 
908d cd 71 88			call str_at_display 
9090			 
9090 3e 78			ld a,  display_row_4 
9092 11 5d 90			ld de, hd_menu4 
9095 cd 71 88			call str_at_display 
9098			 
9098				; display debug state 
9098			 
9098 11 6e 90			ld de, hd_don 
909b 3a 74 e3			ld a, (os_view_disable) 
909e fe 00			cp 0 
90a0 28 03			jr z, .distog 
90a2 11 71 90			ld de, hd_doff 
90a5 3e 89		.distog: ld a, display_row_4+17 
90a7 cd 71 88			call str_at_display 
90aa			 
90aa cd 81 88			call update_display 
90ad			 
90ad cd 9f d4			call cin_wait 
90b0			 
90b0			 
90b0			 
90b0 fe 34			cp '4' 
90b2 20 0f			jr nz, .diagn1 
90b4			 
90b4				; debug toggle 
90b4			 
90b4 3a 74 e3			ld a, (os_view_disable) 
90b7 06 2a			ld b, '*' 
90b9 fe 00			cp 0 
90bb 28 02			jr z, .debtog 
90bd 06 00			ld b, 0 
90bf			.debtog:	 
90bf 78				ld a,b 
90c0 32 74 e3			ld (os_view_disable),a 
90c3			 
90c3 fe 30		.diagn1: cp '0' 
90c5 c8				 ret z 
90c6			 
90c6			;	cp '1' 
90c6			;       jp z, matrix	 
90c6			;   TODO keyboard matrix test 
90c6			 
90c6 fe 32			cp '2' 
90c8 ca cf 90			jp z, .diagedit 
90cb			 
90cb			;if ENABLE_BASIC 
90cb			;	cp '6' 
90cb			;	jp z, basic 
90cb			;endif 
90cb			  
90cb c3 75 90			jp .diagmenu 
90ce			 
90ce			 
90ce c9				ret 
90cf			 
90cf			; debug editor 
90cf			 
90cf			.diagedit: 
90cf			 
90cf 21 75 e3			ld hl, scratch 
90d2			;	ld bc, 250 
90d2			;	ldir 
90d2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
90d2 3e 00			ld a, 0 
90d4 77				ld (hl), a 
90d5 23				inc hl 
90d6 77				ld (hl), a 
90d7 23				inc hl 
90d8 77				ld (hl), a 
90d9			 
90d9 cd 5e 88		        call clear_display 
90dc cd 81 88			call update_display 
90df 3e 01			ld a, 1 
90e1 32 80 ee			ld (hardware_diag), a 
90e4			.diloop: 
90e4 3e 00			ld a, display_row_1 
90e6 0e 00			ld c, 0 
90e8 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
90ea 1e 28			ld e, 40 
90ec			 
90ec 21 75 e3			ld hl, scratch	 
90ef cd e4 89			call input_str 
90f2			 
90f2 3e 28			ld a, display_row_2 
90f4 11 75 e3			ld de, scratch 
90f7 cd 71 88			call str_at_display 
90fa cd 81 88			call update_display 
90fd			 
90fd c3 e4 90			jp .diloop 
9100			 
9100			 
9100			; pass word in hl 
9100			; a has display location 
9100			display_word_at: 
9100 f5				push af 
9101 e5				push hl 
9102 7c				ld a,h 
9103 21 7a e6			ld hl, os_word_scratch 
9106 cd b8 8c			call hexout 
9109 e1				pop hl 
910a 7d				ld a,l 
910b 21 7c e6			ld hl, os_word_scratch+2 
910e cd b8 8c			call hexout 
9111 21 7e e6			ld hl, os_word_scratch+4 
9114 3e 00			ld a,0 
9116 77				ld (hl),a 
9117 11 7a e6			ld de,os_word_scratch 
911a f1				pop af 
911b cd 71 88				call str_at_display 
911e c9				ret 
911f			 
911f			display_ptr_state: 
911f			 
911f				; to restore afterwards 
911f			 
911f d5				push de 
9120 c5				push bc 
9121 e5				push hl 
9122 f5				push af 
9123			 
9123				; for use in here 
9123			 
9123			;	push bc 
9123			;	push de 
9123			;	push hl 
9123			;	push af 
9123			 
9123 cd 5e 88			call clear_display 
9126			 
9126 11 f9 92			ld de, .ptrstate 
9129 3e 00			ld a, display_row_1 
912b cd 71 88			call str_at_display 
912e			 
912e				; display debug step 
912e			 
912e			 
912e 11 7a ee			ld de, debug_mark 
9131 3e 26			ld a, display_row_1+display_cols-2 
9133 cd 71 88			call str_at_display 
9136			 
9136				; display a 
9136 11 03 93			ld de, .ptrcliptr 
9139 3e 28			ld a, display_row_2 
913b cd 71 88			call str_at_display 
913e			 
913e f1				pop af 
913f 2a 40 eb			ld hl,(cli_ptr) 
9142 3e 30			ld a, display_row_2+8 
9144 cd 00 91			call display_word_at 
9147			 
9147			 
9147				; display hl 
9147			 
9147			 
9147 11 0b 93			ld de, .ptrclioptr 
914a 3e 32			ld a, display_row_2+10 
914c cd 71 88			call str_at_display 
914f			; 
914f			;	pop hl 
914f 3e 35			ld a, display_row_2+13 
9151 2a 3e eb			ld hl,(cli_origptr) 
9154 cd 00 91			call display_word_at 
9157			; 
9157			;	 
9157			;	; display de 
9157			 
9157			;	ld de, .regstatede 
9157			;	ld a, display_row_3 
9157			;	call str_at_display 
9157			 
9157			;	pop de 
9157			;	ld h,d 
9157			;	ld l, e 
9157			;	ld a, display_row_3+3 
9157			;	call display_word_at 
9157			 
9157			 
9157				; display bc 
9157			 
9157			;	ld de, .regstatebc 
9157			;	ld a, display_row_3+10 
9157			;	call str_at_display 
9157			 
9157			;	pop bc 
9157			;	ld h,b 
9157			;	ld l, c 
9157			;	ld a, display_row_3+13 
9157			;	call display_word_at 
9157			 
9157			 
9157				; display dsp 
9157			 
9157			;	ld de, .regstatedsp 
9157			;	ld a, display_row_4 
9157			;	call str_at_display 
9157			 
9157				 
9157			;	ld hl,(cli_data_sp) 
9157			;	ld a, display_row_4+4 
9157			;	call display_word_at 
9157			 
9157				; display rsp 
9157			 
9157 11 3a 93			ld de, .regstatersp 
915a 3e 82			ld a, display_row_4+10 
915c cd 71 88			call str_at_display 
915f			 
915f				 
915f 2a 26 eb			ld hl,(cli_ret_sp) 
9162 3e 86			ld a, display_row_4+14 
9164 cd 00 91			call display_word_at 
9167			 
9167 cd 81 88			call update_display 
916a			 
916a cd e2 87			call delay1s 
916d cd e2 87			call delay1s 
9170 cd e2 87			call delay1s 
9173			 
9173			 
9173 cd 8d 96			call next_page_prompt 
9176			 
9176				; restore  
9176			 
9176 f1				pop af 
9177 e1				pop hl 
9178 c1				pop bc 
9179 d1				pop de 
917a c9				ret 
917b			 
917b			break_point_state: 
917b f5				push af 
917c			 
917c				; see if disabled 
917c			 
917c 3a 74 e3			ld a, (os_view_disable) 
917f fe 2a			cp '*' 
9181 20 02			jr nz, .bpsgo 
9183 f1				pop af 
9184 c9				ret 
9185			 
9185			.bpsgo: 
9185 f1				pop af 
9186 f5				push af 
9187 22 70 e3			ld (os_view_hl), hl 
918a ed 53 6e e3		ld (os_view_de), de 
918e ed 43 6c e3		ld (os_view_bc), bc 
9192 e5				push hl 
9193 6f				ld l, a 
9194 26 00			ld h, 0 
9196 22 72 e3			ld (os_view_af),hl 
9199			 
9199 21 c0 ed				ld hl, display_fb0 
919c 22 db eb				ld (display_fb_active), hl 
919f e1				pop hl	 
91a0			 
91a0 3e 31			ld a, '1' 
91a2 fe 2a		.bps1:  cp '*' 
91a4 20 03			jr nz, .bps1b 
91a6 32 74 e3			ld (os_view_disable),a 
91a9 fe 31		.bps1b:  cp '1' 
91ab 20 14			jr nz, .bps2 
91ad			 
91ad				; display reg 
91ad			 
91ad				 
91ad			 
91ad 3a 72 e3			ld a, (os_view_af) 
91b0 2a 70 e3			ld hl, (os_view_hl) 
91b3 ed 5b 6e e3		ld de, (os_view_de) 
91b7 ed 4b 6c e3		ld bc, (os_view_bc) 
91bb cd 55 92			call display_reg_state 
91be c3 41 92			jp .bpschk 
91c1			 
91c1 fe 32		.bps2:  cp '2' 
91c3 20 08			jr nz, .bps3 
91c5				 
91c5				; display hl 
91c5 2a 70 e3			ld hl, (os_view_hl) 
91c8 cd 3f 93			call display_dump_at_hl 
91cb			 
91cb 18 74			jr .bpschk 
91cd			 
91cd fe 33		.bps3:  cp '3' 
91cf 20 08			jr nz, .bps4 
91d1			 
91d1			        ; display de 
91d1 2a 6e e3			ld hl, (os_view_de) 
91d4 cd 3f 93			call display_dump_at_hl 
91d7			 
91d7 18 68			jr .bpschk 
91d9 fe 34		.bps4:  cp '4' 
91db 20 08			jr nz, .bps5 
91dd			 
91dd			        ; display bc 
91dd 2a 6c e3			ld hl, (os_view_bc) 
91e0 cd 3f 93			call display_dump_at_hl 
91e3			 
91e3 18 5c			jr .bpschk 
91e5 fe 35		.bps5:  cp '5' 
91e7 20 08		        jr nz, .bps7 
91e9			 
91e9				; display cur ptr 
91e9 2a 40 eb			ld hl, (cli_ptr) 
91ec cd 3f 93			call display_dump_at_hl 
91ef			 
91ef 18 50			jr .bpschk 
91f1 fe 36		.bps7:  cp '6' 
91f3 20 08			jr nz, .bps8b 
91f5				 
91f5				; display cur orig ptr 
91f5 2a 3e eb			ld hl, (cli_origptr) 
91f8 cd 3f 93			call display_dump_at_hl 
91fb 18 44			jr .bpschk 
91fd fe 37		.bps8b:  cp '7' 
91ff 20 08			jr nz, .bps9 
9201				 
9201				; display dsp 
9201 2a 22 eb			ld hl, (cli_data_sp) 
9204 cd 3f 93			call display_dump_at_hl 
9207			 
9207 18 38			jr .bpschk 
9209 fe 39		.bps9:  cp '9' 
920b 20 05			jr nz, .bps8c 
920d				 
920d				; display SP 
920d			;	ld hl, sp 
920d cd 3f 93			call display_dump_at_hl 
9210			 
9210 18 2f			jr .bpschk 
9212 fe 38		.bps8c:  cp '8' 
9214 20 08			jr nz, .bps8d 
9216				 
9216				; display rsp 
9216 2a 26 eb			ld hl, (cli_ret_sp) 
9219 cd 3f 93			call display_dump_at_hl 
921c			 
921c 18 23			jr .bpschk 
921e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9220 20 05			jr nz, .bps8 
9222 cd 83 94			call monitor 
9225			 
9225 18 1a			jr .bpschk 
9227 fe 30		.bps8:  cp '0' 
9229 20 16			jr nz, .bpschk 
922b			 
922b 21 1f ed				ld hl, display_fb1 
922e 22 db eb				ld (display_fb_active), hl 
9231 cd 81 88				call update_display 
9234			 
9234				;ld a, (os_view_af) 
9234 2a 70 e3			ld hl, (os_view_hl) 
9237 ed 5b 6e e3		ld de, (os_view_de) 
923b ed 4b 6c e3		ld bc, (os_view_bc) 
923f f1				pop af 
9240 c9				ret 
9241			 
9241			.bpschk:   
9241 cd e2 87			call delay1s 
9244 3e 9f		ld a,display_row_4 + display_cols - 1 
9246 11 8b 96		        ld de, endprg 
9249 cd 71 88			call str_at_display 
924c cd 81 88			call update_display 
924f cd 9f d4			call cin_wait 
9252			 
9252 c3 a2 91			jp .bps1 
9255			 
9255			 
9255			display_reg_state: 
9255			 
9255				; to restore afterwards 
9255			 
9255 d5				push de 
9256 c5				push bc 
9257 e5				push hl 
9258 f5				push af 
9259			 
9259				; for use in here 
9259			 
9259 c5				push bc 
925a d5				push de 
925b e5				push hl 
925c f5				push af 
925d			 
925d cd 5e 88			call clear_display 
9260			 
9260 11 15 93			ld de, .regstate 
9263 3e 00			ld a, display_row_1 
9265 cd 71 88			call str_at_display 
9268			 
9268				; display debug step 
9268			 
9268			 
9268 11 7a ee			ld de, debug_mark 
926b 3e 25			ld a, display_row_1+display_cols-3 
926d cd 71 88			call str_at_display 
9270			 
9270				; display a 
9270 11 31 93			ld de, .regstatea 
9273 3e 28			ld a, display_row_2 
9275 cd 71 88			call str_at_display 
9278			 
9278 e1				pop hl 
9279			;	ld h,0 
9279			;	ld l, a 
9279 3e 2b			ld a, display_row_2+3 
927b cd 00 91			call display_word_at 
927e			 
927e			 
927e				; display hl 
927e			 
927e			 
927e 11 25 93			ld de, .regstatehl 
9281 3e 32			ld a, display_row_2+10 
9283 cd 71 88			call str_at_display 
9286			 
9286 e1				pop hl 
9287 3e 35			ld a, display_row_2+13 
9289 cd 00 91			call display_word_at 
928c			 
928c				 
928c				; display de 
928c			 
928c 11 29 93			ld de, .regstatede 
928f 3e 50			ld a, display_row_3 
9291 cd 71 88			call str_at_display 
9294			 
9294 e1				pop hl 
9295			;	ld h,d 
9295			;	ld l, e 
9295 3e 53			ld a, display_row_3+3 
9297 cd 00 91			call display_word_at 
929a			 
929a			 
929a				; display bc 
929a			 
929a 11 2d 93			ld de, .regstatebc 
929d 3e 5a			ld a, display_row_3+10 
929f cd 71 88			call str_at_display 
92a2			 
92a2 e1				pop hl 
92a3			;	ld h,b 
92a3			;	ld l, c 
92a3 3e 5d			ld a, display_row_3+13 
92a5 cd 00 91			call display_word_at 
92a8			 
92a8			 
92a8				; display dsp 
92a8			 
92a8 11 35 93			ld de, .regstatedsp 
92ab 3e 78			ld a, display_row_4 
92ad cd 71 88			call str_at_display 
92b0			 
92b0				 
92b0 2a 22 eb			ld hl,(cli_data_sp) 
92b3 3e 7c			ld a, display_row_4+4 
92b5 cd 00 91			call display_word_at 
92b8			 
92b8				; display rsp 
92b8			 
92b8 11 3a 93			ld de, .regstatersp 
92bb 3e 82			ld a, display_row_4+10 
92bd cd 71 88			call str_at_display 
92c0			 
92c0				 
92c0 2a 26 eb			ld hl,(cli_ret_sp) 
92c3 3e 86			ld a, display_row_4+14 
92c5 cd 00 91			call display_word_at 
92c8			 
92c8 cd 81 88			call update_display 
92cb			 
92cb			;	call delay1s 
92cb			;	call delay1s 
92cb			;	call delay1s 
92cb			 
92cb			 
92cb			;	call next_page_prompt 
92cb			 
92cb				; restore  
92cb			 
92cb f1				pop af 
92cc e1				pop hl 
92cd c1				pop bc 
92ce d1				pop de 
92cf c9				ret 
92d0			 
92d0 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
92e4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
92f9 .. 00		.ptrstate:	db "Ptr State",0 
9303 .. 00		.ptrcliptr:     db "cli_ptr",0 
930b .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9315 .. 00		.regstate:	db "Reg State (1/0)",0 
9325 .. 00		.regstatehl:	db "HL:",0 
9329 .. 00		.regstatede:	db "DE:",0 
932d .. 00		.regstatebc:	db "BC:",0 
9331 .. 00		.regstatea:	db "A :",0 
9335 .. 00		.regstatedsp:	db "DSP:",0 
933a .. 00		.regstatersp:	db "RSP:",0 
933f			 
933f			display_dump_at_hl: 
933f e5				push hl 
9340 d5				push de 
9341 c5				push bc 
9342 f5				push af 
9343			 
9343 22 98 e6			ld (os_cur_ptr),hl	 
9346 cd 5e 88			call clear_display 
9349 cd 95 95			call dumpcont 
934c			;	call delay1s 
934c			;	call next_page_prompt 
934c			 
934c			 
934c f1				pop af 
934d c1				pop bc 
934e d1				pop de 
934f e1				pop hl 
9350 c9				ret 
9351			 
9351			;if ENABLE_BASIC 
9351			;	include "nascombasic.asm" 
9351			;	basic: 
9351			;	include "forth/FORTH.ASM" 
9351			;endif 
9351			 
9351			; eof 
9351			 
9351			 
# End of file firmware_diags.asm
9351			  
9351			  
9351			  
9351			  
9351			; eof  
9351			  
# End of file firmware.asm
9351			 
9351			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9351			;if BASE_KEV  
9351			;baseram: equ 08000h 
9351			;endif 
9351			 
9351			;if BASE_SC114 
9351			;baseram:     equ    endofcode 
9351			;endif 
9351			 
9351			 
9351			; start system 
9351			 
9351			coldstart: 
9351				; set sp 
9351				; di/ei 
9351			 
9351 f3				di 
9352 31 00 f0			ld sp, tos 
9355			;	ei 
9355			 
9355			 
9355				; disable breakpoint by default 
9355			 
9355 3e 2a			ld a,'*' 
9357 32 74 e3			ld (os_view_disable),a 
935a			 
935a				; init hardware 
935a			 
935a				; init keyboard and screen hardware 
935a			 
935a cd 03 80			call hardware_init 
935d			 
935d			 
935d				; detect if any keys are held down to enable breakpoints at start up 
935d			 
935d cd a5 d4			call cin  
9360 fe 00			cp 0 
9362 28 03			jr z, .nokeys 
9364			 
9364 cd 75 90			call hardware_diags 
9367			 
9367			;	ld de, .bpen 
9367			;	ld a, display_row_4 
9367			;	call str_at_display 
9367			;	call update_display 
9367			; 
9367			;	ld a,0 
9367			;	ld (os_view_disable),a 
9367			; 
9367			;.bpwait: 
9367			;	call cin 
9367			;	cp 0 
9367			;	jr z, .bpwait 
9367			;	jr .nokeys 
9367			; 
9367			; 
9367			;.bpen:  db "Break points enabled!",0 
9367			 
9367			 
9367			 
9367			 
9367			 
9367			 
9367			.nokeys: 
9367			 
9367			 
9367				 
9367			 
9367			;jp  testkey 
9367			 
9367			;call storage_get_block_0 
9367			; 
9367			;ld hl, 0 
9367			;ld de, store_page 
9367			;call storage_read_block 
9367			 
9367				 
9367			;ld hl, 10 
9367			;ld de, store_page 
9367			;call storage_read_block 
9367			 
9367			 
9367			 
9367			 
9367			 
9367			;stop:	nop 
9367			;	jp stop 
9367			 
9367			 
9367			 
9367			main: 
9367 cd 5e 88			call clear_display 
936a cd 81 88			call update_display 
936d			 
936d			 
936d			 
936d			;	call testlcd 
936d			 
936d			 
936d			 
936d cd db 98			call forth_init 
9370			 
9370			 
9370			warmstart: 
9370 cd b1 98			call forth_warmstart 
9373			 
9373				; run startup word load 
9373			        ; TODO prevent this running at warmstart after crash  
9373			 
9373				if STARTUP_ENABLE 
9373 cd 39 d1				call forth_startup 
9376				endif 
9376			 
9376				; show free memory after boot 
9376 11 1d 94			ld de, freeram 
9379 3e 00			ld a, display_row_1 
937b cd 71 88			call str_at_display 
937e			 
937e			; Or use heap_size word???? 
937e 21 69 e3			ld hl, heap_end 
9381 11 c3 d4			ld de, heap_start 
9384 ed 52			sbc hl, de 
9386 e5				push hl 
9387 7c				ld a,h	         	 
9388 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
938b cd b8 8c			call hexout 
938e e1			   	pop hl 
938f			 
938f 7d				ld a,l 
9390 21 7c e6			ld hl, os_word_scratch+2 
9393 cd b8 8c			call hexout 
9396 21 7e e6			ld hl, os_word_scratch+4 
9399 3e 00			ld a, 0 
939b 77				ld (hl),a 
939c 11 7a e6			ld de, os_word_scratch 
939f 3e 0d			ld a, display_row_1 + 13 
93a1 cd 71 88			call str_at_display 
93a4 cd 81 88			call update_display 
93a7			 
93a7			 
93a7				;call demo 
93a7			 
93a7			 
93a7				; init scratch input area for cli commands 
93a7			 
93a7 21 9c e6			ld hl, os_cli_cmd 
93aa 3e 00			ld a,0 
93ac 77				ld (hl),a 
93ad 23				inc hl 
93ae 77				ld (hl),a 
93af			 
93af 3e 00			ld a,0 
93b1 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
93b4			 
93b4 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
93b7 32 99 e6			ld (os_cur_ptr+1),a	 
93ba			 
93ba 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
93bd 32 7b e6			ld (os_word_scratch+1),a	 
93c0				 
93c0			 
93c0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
93c0 21 9c e6			ld hl, os_cli_cmd 
93c3			 
93c3 3e 00			ld a, 0		 ; init cli input 
93c5 77				ld (hl), a 
93c6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
93c8			cli: 
93c8				; show cli prompt 
93c8				;push af 
93c8				;ld a, 0 
93c8				;ld de, prompt 
93c8				;call str_at_display 
93c8			 
93c8				;call update_display 
93c8				;pop af 
93c8				;inc a 
93c8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
93c8 0e 00			ld c, 0 
93ca 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
93cc 1e 28			ld e, 40 
93ce			 
93ce 21 9c e6			ld hl, os_cli_cmd 
93d1			 
93d1				STACKFRAME OFF $fefe $9f9f 
93d1				if DEBUG_STACK_IMB 
93d1					if OFF 
93d1						exx 
93d1						ld de, $fefe 
93d1						ld a, d 
93d1						ld hl, curframe 
93d1						call hexout 
93d1						ld a, e 
93d1						ld hl, curframe+2 
93d1						call hexout 
93d1						ld hl, $fefe 
93d1						push hl 
93d1						ld hl, $9f9f 
93d1						push hl 
93d1						exx 
93d1					endif 
93d1				endif 
93d1			endm 
# End of macro STACKFRAME
93d1			 
93d1 cd e4 89			call input_str 
93d4			 
93d4				STACKFRAMECHK OFF $fefe $9f9f 
93d4				if DEBUG_STACK_IMB 
93d4					if OFF 
93d4						exx 
93d4						ld hl, $9f9f 
93d4						pop de   ; $9f9f 
93d4						call cmp16 
93d4						jr nz, .spnosame 
93d4						ld hl, $fefe 
93d4						pop de   ; $fefe 
93d4						call cmp16 
93d4						jr z, .spfrsame 
93d4						.spnosame: call showsperror 
93d4						.spfrsame: nop 
93d4						exx 
93d4					endif 
93d4				endif 
93d4			endm 
# End of macro STACKFRAMECHK
93d4			 
93d4				; copy input to last command 
93d4			 
93d4 21 9c e6			ld hl, os_cli_cmd 
93d7 11 9b e7			ld de, os_last_cmd 
93da 01 ff 00			ld bc, 255 
93dd ed b0			ldir 
93df			 
93df				; wipe current buffer 
93df			 
93df 3e 00			ld a, 0 
93e1 21 9c e6			ld hl, os_cli_cmd 
93e4 11 9d e6			ld de, os_cli_cmd+1 
93e7 01 fe 00			ld bc, 254 
93ea ed b0			ldir 
93ec				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93ec			;	call strcpy 
93ec			;	ld a, 0 
93ec			;	ld (hl), a 
93ec			;	inc hl 
93ec			;	ld (hl), a 
93ec			;	inc hl 
93ec			;	ld (hl), a 
93ec			 
93ec				; switch frame buffer to program  
93ec			 
93ec 21 1f ed				ld hl, display_fb1 
93ef 22 db eb				ld (display_fb_active), hl 
93f2			 
93f2			;	nop 
93f2				STACKFRAME ON $fbfe $8f9f 
93f2				if DEBUG_STACK_IMB 
93f2					if ON 
93f2						exx 
93f2						ld de, $fbfe 
93f2						ld a, d 
93f2						ld hl, curframe 
93f2						call hexout 
93f2						ld a, e 
93f2						ld hl, curframe+2 
93f2						call hexout 
93f2						ld hl, $fbfe 
93f2						push hl 
93f2						ld hl, $8f9f 
93f2						push hl 
93f2						exx 
93f2					endif 
93f2				endif 
93f2			endm 
# End of macro STACKFRAME
93f2				; first time into the parser so pass over the current scratch pad 
93f2 21 9c e6			ld hl,os_cli_cmd 
93f5				; tokenise the entered statement(s) in HL 
93f5 cd 54 99			call forthparse 
93f8			        ; exec forth statements in top of return stack 
93f8 cd 94 99			call forthexec 
93fb				;call forthexec_cleanup 
93fb			;	call parsenext 
93fb			 
93fb				STACKFRAMECHK ON $fbfe $8f9f 
93fb				if DEBUG_STACK_IMB 
93fb					if ON 
93fb						exx 
93fb						ld hl, $8f9f 
93fb						pop de   ; $8f9f 
93fb						call cmp16 
93fb						jr nz, .spnosame 
93fb						ld hl, $fbfe 
93fb						pop de   ; $fbfe 
93fb						call cmp16 
93fb						jr z, .spfrsame 
93fb						.spnosame: call showsperror 
93fb						.spfrsame: nop 
93fb						exx 
93fb					endif 
93fb				endif 
93fb			endm 
# End of macro STACKFRAMECHK
93fb				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
93fb			 
93fb 3e 78			ld a, display_row_4 
93fd 11 2f 94			ld de, endprog 
9400			 
9400 cd 81 88			call update_display		 
9403			 
9403 cd 8d 96			call next_page_prompt 
9406			 
9406				; switch frame buffer to cli 
9406			 
9406 21 c0 ed				ld hl, display_fb0 
9409 22 db eb				ld (display_fb_active), hl 
940c			 
940c			 
940c cd 5e 88		        call clear_display 
940f cd 81 88			call update_display		 
9412			 
9412 21 9c e6			ld hl, os_cli_cmd 
9415			 
9415 3e 00			ld a, 0		 ; init cli input 
9417 77				ld (hl), a 
9418			 
9418				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9418			 
9418				; now on last line 
9418			 
9418				; TODO scroll screen up 
9418			 
9418				; TODO instead just clear screen and place at top of screen 
9418			 
9418			;	ld a, 0 
9418			;	ld (f_cursor_ptr),a 
9418			 
9418				;call clear_display 
9418				;call update_display 
9418			 
9418				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9418 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
941a c3 c8 93			jp cli 
941d			 
941d .. 00		freeram: db "Free bytes: $",0 
942b ..			asc: db "1A2F" 
942f .. 00		endprog: db "End prog...",0 
943b			 
943b			testenter2:   
943b 21 a7 e3			ld hl,scratch+50 
943e 22 98 e6			ld (os_cur_ptr),hl 
9441 c3 c8 93			jp cli 
9444			 
9444			testenter:  
9444			 
9444 21 2b 94			ld hl,asc 
9447			;	ld a,(hl) 
9447			;	call nibble2val 
9447 cd 0e 8d			call get_byte 
944a			 
944a			 
944a			;	ld a,(hl) 
944a			;	call atohex 
944a			 
944a			;	call fourehexhl 
944a 32 a7 e3			ld (scratch+50),a 
944d			 
944d			 
944d			 
944d 21 2d 94			ld hl,asc+2 
9450			;	ld a, (hl) 
9450			;	call nibble2val 
9450 cd 0e 8d			call get_byte 
9453			 
9453			;	call fourehexhl 
9453 32 a9 e3			ld (scratch+52),a 
9456				 
9456 21 a7 e3			ld hl,scratch+50 
9459 22 98 e6			ld (os_cur_ptr),hl 
945c c3 c8 93			jp cli 
945f			 
945f			enter:	 
945f 3a 79 e3			ld a,(scratch+4) 
9462 fe 00			cp 0 
9464 28 0c			jr z, .entercont 
9466				; no, not a null term line so has an address to work out.... 
9466			 
9466 21 77 e3			ld hl,scratch+2 
9469 cd 6e 8d			call get_word_hl 
946c			 
946c 22 98 e6			ld (os_cur_ptr),hl	 
946f c3 c8 93			jp cli 
9472			 
9472			 
9472			.entercont:  
9472			 
9472 21 77 e3			ld hl, scratch+2 
9475 cd 0e 8d			call get_byte 
9478			 
9478 2a 98 e6		   	ld hl,(os_cur_ptr) 
947b 77					ld (hl),a 
947c 23					inc hl 
947d 22 98 e6				ld (os_cur_ptr),hl 
9480				 
9480			; get byte  
9480			 
9480			 
9480 c3 c8 93			jp cli 
9483			 
9483			 
9483			; basic monitor support 
9483			 
9483			monitor: 
9483				;  
9483 cd 5e 88			call clear_display 
9486 3e 00			ld a, 0 
9488 11 d0 94			ld de, .monprompt 
948b cd 71 88			call str_at_display 
948e cd 81 88			call update_display 
9491			 
9491				; get a monitor command 
9491			 
9491 0e 00			ld c, 0     ; entry at top left 
9493 16 64			ld d, 100   ; max buffer size 
9495 1e 0f			ld e, 15    ; input scroll area 
9497 3e 00			ld a, 0     ; init string 
9499 21 73 e5			ld hl, os_input 
949c 77				ld (hl), a 
949d 23				inc hl 
949e 77				ld (hl), a 
949f 21 73 e5			ld hl, os_input 
94a2 3e 01			ld a, 1     ; init string 
94a4 cd e4 89			call input_str 
94a7			 
94a7 cd 5e 88		        call clear_display 
94aa cd 81 88			call update_display		 
94ad			 
94ad 3a 73 e5			ld a, (os_input) 
94b0 cd 0c 8e			call toUpper 
94b3 fe 48		        cp 'H' 
94b5 28 6f		        jr z, .monhelp 
94b7 fe 44			cp 'D'		; dump 
94b9 ca 47 95			jp z, .mondump	 
94bc fe 43			cp 'C'		; dump 
94be ca 61 95			jp z, .moncdump	 
94c1 fe 4d			cp 'M'		; dump 
94c3 ca d2 94			jp z, .moneditstart 
94c6 fe 55			cp 'U'		; dump 
94c8 28 14			jr z, .monedit	 
94ca fe 51			cp 'Q'		; dump 
94cc c8				ret z	 
94cd			 
94cd			 
94cd				; TODO "S" to access symbol by name and not need the address 
94cd				; TODO "F" to find a string in memory 
94cd			 
94cd c3 83 94			jp monitor 
94d0			 
94d0 .. 00		.monprompt: db ">", 0 
94d2			 
94d2			.moneditstart: 
94d2				; get starting address 
94d2			 
94d2 21 75 e5			ld hl,os_input+2 
94d5 cd 6e 8d			call get_word_hl 
94d8			 
94d8 22 98 e6			ld (os_cur_ptr),hl	 
94db			 
94db c3 83 94			jp monitor 
94de			 
94de			.monedit: 
94de				; get byte to load 
94de			 
94de 21 75 e5			ld hl,os_input+2 
94e1 cd 0e 8d			call get_byte 
94e4			 
94e4				; get address to update 
94e4 2a 98 e6			ld hl, (os_cur_ptr) 
94e7			 
94e7				; update byte 
94e7			 
94e7 77				ld (hl), a 
94e8			 
94e8				; move to next address and save it 
94e8			 
94e8 23				inc hl 
94e9 22 98 e6			ld (os_cur_ptr),hl	 
94ec			 
94ec c3 83 94			jp monitor 
94ef			 
94ef			 
94ef .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9503 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
951f .. 00		.monhelptext3:  db "Q-Quit",0 
9526			        
9526			.monhelp: 
9526 3e 00			ld a, display_row_1 
9528 11 ef 94		        ld de, .monhelptext1 
952b			 
952b cd 71 88			call str_at_display 
952e 3e 28			ld a, display_row_2 
9530 11 03 95		        ld de, .monhelptext2 
9533					 
9533 cd 71 88			call str_at_display 
9536 3e 50			ld a, display_row_3 
9538 11 1f 95		        ld de, .monhelptext3 
953b					 
953b cd 71 88			call str_at_display 
953e cd 81 88			call update_display		 
9541			 
9541 cd 8d 96			call next_page_prompt 
9544 c3 83 94			jp monitor 
9547			 
9547			.mondump:    
9547 21 75 e5			ld hl,os_input+2 
954a cd 6e 8d			call get_word_hl 
954d			 
954d 22 98 e6			ld (os_cur_ptr),hl	 
9550 cd 95 95			call dumpcont 
9553 3e 78			ld a, display_row_4 
9555 11 2f 94			ld de, endprog 
9558			 
9558 cd 81 88			call update_display		 
955b			 
955b cd 8d 96			call next_page_prompt 
955e c3 83 94			jp monitor 
9561			.moncdump: 
9561 cd 95 95			call dumpcont 
9564 3e 78			ld a, display_row_4 
9566 11 2f 94			ld de, endprog 
9569			 
9569 cd 81 88			call update_display		 
956c			 
956c cd 8d 96			call next_page_prompt 
956f c3 83 94			jp monitor 
9572			 
9572			 
9572			; TODO symbol access  
9572			 
9572			.symbols:     ;; A list of symbols that can be called up  
9572 c0 ed			dw display_fb0 
9574 .. 00			db "fb0",0  
9578 65 eb		     	dw store_page 
957a .. 00			db "store_page",0 
9585			 
9585			 
9585			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9585			 
9585 3a 76 e3			ld a,(scratch+1) 
9588 fe 00			cp 0 
958a 28 09			jr z, dumpcont 
958c			 
958c				; no, not a null term line so has an address to work out.... 
958c			 
958c 21 77 e3			ld hl,scratch+2 
958f cd 6e 8d			call get_word_hl 
9592			 
9592 22 98 e6			ld (os_cur_ptr),hl	 
9595			 
9595			 
9595			 
9595			dumpcont: 
9595			 
9595				; dump bytes at ptr 
9595			 
9595			 
9595 3e 00			ld a, display_row_1 
9597 2a db eb			ld hl, (display_fb_active) 
959a cd b7 89			call addatohl 
959d cd c5 95			call .dumpbyterow 
95a0			 
95a0 3e 28			ld a, display_row_2 
95a2 2a db eb			ld hl, (display_fb_active) 
95a5 cd b7 89			call addatohl 
95a8 cd c5 95			call .dumpbyterow 
95ab			 
95ab			 
95ab 3e 50			ld a, display_row_3 
95ad 2a db eb			ld hl, (display_fb_active) 
95b0 cd b7 89			call addatohl 
95b3 cd c5 95			call .dumpbyterow 
95b6			 
95b6 3e 78			ld a, display_row_4 
95b8 2a db eb			ld hl, (display_fb_active) 
95bb cd b7 89			call addatohl 
95be cd c5 95			call .dumpbyterow 
95c1			 
95c1 cd 81 88			call update_display 
95c4			;		jp cli 
95c4 c9				ret 
95c5			 
95c5			.dumpbyterow: 
95c5			 
95c5				;push af 
95c5			 
95c5 e5				push hl 
95c6			 
95c6				; calc where to poke the ascii 
95c6			if display_cols == 20 
95c6				ld a, 16 
95c6			else 
95c6 3e 1f			ld a, 31 
95c8			endif 
95c8			 
95c8 cd b7 89			call addatohl 
95cb 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
95ce			 
95ce			 
95ce			; display decoding address 
95ce 2a 98 e6		   	ld hl,(os_cur_ptr) 
95d1			 
95d1 7c				ld a,h 
95d2 e1				pop hl 
95d3 e5				push hl 
95d4			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
95d4 cd b8 8c			call hexout 
95d7 2a 98 e6		   	ld hl,(os_cur_ptr) 
95da			 
95da 7d				ld a,l 
95db e1				pop hl 
95dc 23				inc hl 
95dd 23				inc hl 
95de e5				push hl 
95df			;	ld hl, os_word_scratch+2 
95df cd b8 8c			call hexout 
95e2 e1				pop hl 
95e3 23				inc hl 
95e4 23				inc hl 
95e5				;ld hl, os_word_scratch+4 
95e5 3e 3a			ld a, ':' 
95e7 77				ld (hl),a 
95e8 23				inc hl 
95e9				;ld a, 0 
95e9				;ld (hl),a 
95e9				;ld de, os_word_scratch 
95e9				;pop af 
95e9				;push af 
95e9			;		ld a, display_row_2 
95e9			;		call str_at_display 
95e9			;		call update_display 
95e9			 
95e9			 
95e9			;pop af 
95e9			;	add 5 
95e9			 
95e9			if display_cols == 20 
95e9				ld b, 4 
95e9			else 
95e9 06 08			ld b, 8 
95eb			endif	 
95eb			 
95eb			.dumpbyte: 
95eb c5				push bc 
95ec e5				push hl 
95ed			 
95ed			 
95ed 2a 98 e6		   	ld hl,(os_cur_ptr) 
95f0 7e					ld a,(hl) 
95f1			 
95f1					; poke the ascii to display 
95f1 2a 7a e6				ld hl,(os_word_scratch) 
95f4 77					ld (hl),a 
95f5 23					inc hl 
95f6 22 7a e6				ld (os_word_scratch),hl 
95f9			 
95f9					 
95f9			 
95f9			 
95f9 e1					pop hl 
95fa e5					push hl 
95fb			 
95fb cd b8 8c				call hexout 
95fe			 
95fe					 
95fe 2a 98 e6		   	ld hl,(os_cur_ptr) 
9601 23				inc hl 
9602 22 98 e6		   	ld (os_cur_ptr),hl 
9605			 
9605 e1					pop hl 
9606 23					inc hl 
9607 23					inc hl 
9608 23					inc hl 
9609			 
9609			 
9609			 
9609					;ld a,0 
9609					;ld (os_word_scratch+2),a 
9609					;pop af 
9609					;push af 
9609			 
9609					;ld de, os_word_scratch 
9609					;call str_at_display 
9609			;		call update_display 
9609			;		pop af 
9609 c1					pop bc 
960a c6 03				add 3 
960c 10 dd			djnz .dumpbyte 
960e			 
960e				 
960e			 
960e c9				ret 
960f			 
960f			jump:	 
960f			 
960f 21 77 e3			ld hl,scratch+2 
9612 cd 6e 8d			call get_word_hl 
9615				;ld hl,(scratch+2) 
9615				;call fourehexhl 
9615			 
9615 22 98 e6			ld (os_cur_ptr),hl	 
9618			 
9618 e9				jp (hl) 
9619			 
9619			 
9619			 
9619			; TODO implement a basic monitor mode to start with 
9619			 
9619			 
9619			 
9619			 
9619			 
9619			 
9619			 
9619			 
9619			 
9619			; testing and demo code during development 
9619			 
9619			 
9619 .. 00		str1: db "Enter some text...",0 
962c .. 00		clear: db "                    ",0 
9641			 
9641			demo: 
9641			 
9641			 
9641			 
9641			;	call update_display 
9641			 
9641				; init scratch input area for testing 
9641 21 75 e3			ld hl, scratch	 
9644 3e 00			ld a,0 
9646 77				ld (hl),a 
9647			 
9647			 
9647 3e 28		            LD   A, display_row_2 
9649			;            CALL fLCD_Pos       ;Position cursor to location in A 
9649 11 19 96		            LD   DE, str1 
964c cd 71 88			call str_at_display 
964f			 
964f			;            CALL fLCD_Str       ;Display string pointed to by DE 
964f			cloop:	 
964f 3e 50		            LD   A, display_row_3 
9651			;            CALL fLCD_Pos       ;Position cursor to location in A 
9651 11 2c 96		            LD   DE, clear 
9654			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9654 cd 71 88				call str_at_display 
9657 3e 78			ld a, display_row_4 
9659 11 89 96			ld de, prompt 
965c			 
965c cd 71 88				call str_at_display 
965f cd 81 88			call update_display 
9662			 
9662 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9664 16 0a			ld d, 10 
9666 21 75 e3			ld hl, scratch	 
9669 cd e4 89			call input_str 
966c			 
966c			;	call clear_display 
966c			;'	call update_display 
966c			 
966c 3e 00		            LD   A, display_row_1 
966e			;            CALL fLCD_Pos       ;Position cursor to location in A 
966e 11 2c 96		            LD   DE, clear 
9671 cd 71 88				call str_at_display 
9674			;            CALL fLCD_Str       ;Display string pointed to by DE 
9674 3e 00		            LD   A, display_row_1 
9676			;            CALL fLCD_Pos       ;Position cursor to location in A 
9676 11 75 e3		            LD   DE, scratch 
9679			;            CALL fLCD_Str       ;Display string pointed to by DE 
9679 cd 71 88				call str_at_display 
967c cd 81 88			call update_display 
967f			 
967f 3e 00				ld a,0 
9681 21 75 e3			ld hl, scratch 
9684 77				ld (hl),a 
9685			 
9685 00				nop 
9686 c3 4f 96			jp cloop 
9689			 
9689			 
9689			 
9689			; OS Prompt 
9689			 
9689 .. 00		prompt: db ">",0 
968b .. 00		endprg: db "?",0 
968d			 
968d			 
968d			; handy next page prompt 
968d			next_page_prompt: 
968d e5				push hl 
968e d5				push de 
968f f5				push af 
9690 c5				push bc 
9691			 
9691 3e 9f			ld a,display_row_4 + display_cols - 1 
9693 11 8b 96		        ld de, endprg 
9696 cd 71 88			call str_at_display 
9699 cd 81 88			call update_display 
969c cd 9f d4			call cin_wait 
969f c1				pop bc 
96a0 f1				pop af 
96a1 d1				pop de 
96a2 e1				pop hl 
96a3			 
96a3			 
96a3 c9				ret 
96a4			 
96a4			 
96a4			; forth parser 
96a4			 
96a4			; My forth kernel 
96a4			include "forth_kernel.asm" 
96a4			; 
96a4			; kernel to the forth OS 
96a4			 
96a4			DS_TYPE_STR: equ 1     ; string type 
96a4			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
96a4			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
96a4			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
96a4			 
96a4			FORTH_PARSEV1: equ 0 
96a4			FORTH_PARSEV2: equ 0 
96a4			FORTH_PARSEV3: equ 0 
96a4			FORTH_PARSEV4: equ 0 
96a4			FORTH_PARSEV5: equ 1 
96a4			 
96a4			;if FORTH_PARSEV5 
96a4			;	FORTH_END_BUFFER: equ 0 
96a4			;else 
96a4			FORTH_END_BUFFER: equ 127 
96a4			;endif 
96a4			 
96a4			FORTH_TRUE: equ 1 
96a4			FORTH_FALSE: equ 0 
96a4			 
96a4			if FORTH_PARSEV4 
96a4			include "forth_stackops.asm" 
96a4			endif 
96a4			 
96a4			if FORTH_PARSEV5 
96a4			include "forth_stackopsv5.asm" 
96a4			 
96a4			; Stack operations for v5 parser on wards 
96a4			; * DATA stack 
96a4			; * LOOP stack 
96a4			; * RETURN stack 
96a4			 
96a4			 
96a4			 
96a4			FORTH_CHK_DSP_UNDER: macro 
96a4				push hl 
96a4				push de 
96a4				ld hl,(cli_data_sp) 
96a4				ld de, cli_data_stack 
96a4				call cmp16 
96a4				jp c, fault_dsp_under 
96a4				pop de 
96a4				pop hl 
96a4				endm 
96a4			 
96a4			 
96a4			FORTH_CHK_RSP_UNDER: macro 
96a4				push hl 
96a4				push de 
96a4				ld hl,(cli_ret_sp) 
96a4				ld de, cli_ret_stack 
96a4				call cmp16 
96a4				jp c, fault_rsp_under 
96a4				pop de 
96a4				pop hl 
96a4				endm 
96a4			 
96a4			FORTH_CHK_LOOP_UNDER: macro 
96a4				push hl 
96a4				push de 
96a4				ld hl,(cli_loop_sp) 
96a4				ld de, cli_loop_stack 
96a4				call cmp16 
96a4				jp c, fault_loop_under 
96a4				pop de 
96a4				pop hl 
96a4				endm 
96a4			 
96a4			FORTH_ERR_TOS_NOTSTR: macro 
96a4				; TOSO might need more for checks when used 
96a4				push af 
96a4				ld a,(hl) 
96a4				cp DS_TYPE_STR 
96a4				jp nz, type_faultn   
96a4				pop af 
96a4				endm 
96a4			 
96a4			FORTH_ERR_TOS_NOTNUM: macro 
96a4				push af 
96a4				ld a,(hl) 
96a4				cp DS_TYPE_INUM 
96a4				jp nz, type_faultn   
96a4				pop af 
96a4				endm 
96a4			 
96a4			 
96a4			; increase data stack pointer and save hl to it 
96a4				 
96a4			FORTH_DSP_NEXT: macro 
96a4				call macro_forth_dsp_next 
96a4				endm 
96a4			 
96a4			 
96a4			macro_forth_dsp_next: 
96a4				if DEBUG_FORTH_STACK_GUARD 
96a4 cd 03 d2				call check_stacks 
96a7				endif 
96a7 e5				push hl 
96a8 d5				push de 
96a9 eb				ex de,hl 
96aa 2a 22 eb			ld hl,(cli_data_sp) 
96ad 23				inc hl 
96ae 23				inc hl 
96af			 
96af			; PARSEV5 
96af 23				inc hl 
96b0 22 22 eb			ld (cli_data_sp),hl 
96b3 73				ld (hl), e 
96b4 23				inc hl 
96b5 72				ld (hl), d 
96b6 d1				pop de 
96b7 e1				pop hl 
96b8				if DEBUG_FORTH_STACK_GUARD 
96b8 cd 03 d2				call check_stacks 
96bb				endif 
96bb c9				ret 
96bc			 
96bc			 
96bc			; increase ret stack pointer and save hl to it 
96bc				 
96bc			FORTH_RSP_NEXT: macro 
96bc				call macro_forth_rsp_next 
96bc				endm 
96bc			 
96bc			macro_forth_rsp_next: 
96bc				if DEBUG_FORTH_STACK_GUARD 
96bc cd 03 d2				call check_stacks 
96bf				endif 
96bf e5				push hl 
96c0 d5				push de 
96c1 eb				ex de,hl 
96c2 2a 26 eb			ld hl,(cli_ret_sp) 
96c5 23				inc hl 
96c6 23				inc hl 
96c7 22 26 eb			ld (cli_ret_sp),hl 
96ca 73				ld (hl), e 
96cb 23				inc hl 
96cc 72				ld (hl), d 
96cd d1				pop de 
96ce e1				pop hl 
96cf				if DEBUG_FORTH_STACK_GUARD 
96cf cd 03 d2				call check_stacks 
96d2				endif 
96d2 c9				ret 
96d3			 
96d3			; get current ret stack pointer and save to hl  
96d3				 
96d3			FORTH_RSP_TOS: macro 
96d3				call macro_forth_rsp_tos 
96d3				endm 
96d3			 
96d3			macro_forth_rsp_tos: 
96d3				;push de 
96d3 2a 26 eb			ld hl,(cli_ret_sp) 
96d6 cd 0e 97			call loadhlptrtohl 
96d9				;ld e, (hl) 
96d9				;inc hl 
96d9				;ld d, (hl) 
96d9				;ex de, hl 
96d9					if DEBUG_FORTH_WORDS 
96d9			;			DMARK "RST" 
96d9						CALLMONITOR 
96d9 cd 7b 91			call break_point_state  
96dc				endm  
# End of macro CALLMONITOR
96dc					endif 
96dc				;pop de 
96dc c9				ret 
96dd			 
96dd			; pop ret stack pointer 
96dd				 
96dd			FORTH_RSP_POP: macro 
96dd				call macro_forth_rsp_pop 
96dd				endm 
96dd			 
96dd			 
96dd			macro_forth_rsp_pop: 
96dd				if DEBUG_FORTH_STACK_GUARD 
96dd			;		DMARK "RPP" 
96dd cd 03 d2				call check_stacks 
96e0					FORTH_CHK_RSP_UNDER 
96e0 e5				push hl 
96e1 d5				push de 
96e2 2a 26 eb			ld hl,(cli_ret_sp) 
96e5 11 e0 ea			ld de, cli_ret_stack 
96e8 cd d5 89			call cmp16 
96eb da 17 d3			jp c, fault_rsp_under 
96ee d1				pop de 
96ef e1				pop hl 
96f0				endm 
# End of macro FORTH_CHK_RSP_UNDER
96f0				endif 
96f0 e5				push hl 
96f1 2a 26 eb			ld hl,(cli_ret_sp) 
96f4			 
96f4			 
96f4				if FORTH_ENABLE_FREE 
96f4			 
96f4					; get pointer 
96f4			 
96f4					push de 
96f4					push hl 
96f4			 
96f4					ld e, (hl) 
96f4					inc hl 
96f4					ld d, (hl) 
96f4			 
96f4					ex de, hl 
96f4					call free 
96f4			 
96f4					pop hl 
96f4					pop de 
96f4			 
96f4			 
96f4				endif 
96f4			 
96f4			 
96f4 2b				dec hl 
96f5 2b				dec hl 
96f6 22 26 eb			ld (cli_ret_sp), hl 
96f9				; do stack underflow checks 
96f9 e1				pop hl 
96fa				if DEBUG_FORTH_STACK_GUARD 
96fa cd 03 d2				call check_stacks 
96fd					FORTH_CHK_RSP_UNDER 
96fd e5				push hl 
96fe d5				push de 
96ff 2a 26 eb			ld hl,(cli_ret_sp) 
9702 11 e0 ea			ld de, cli_ret_stack 
9705 cd d5 89			call cmp16 
9708 da 17 d3			jp c, fault_rsp_under 
970b d1				pop de 
970c e1				pop hl 
970d				endm 
# End of macro FORTH_CHK_RSP_UNDER
970d				endif 
970d c9				ret 
970e			 
970e			 
970e			 
970e			; routine to load word pointed to by hl into hl 
970e			 
970e			loadhlptrtohl: 
970e			 
970e d5				push de 
970f 5e				ld e, (hl) 
9710 23				inc hl 
9711 56				ld d, (hl) 
9712 eb				ex de, hl 
9713 d1				pop de 
9714			 
9714 c9				ret 
9715			 
9715			 
9715			 
9715			 
9715			 
9715			; push a number held in HL onto the data stack 
9715			; entry point for pushing a value when already in hl used in function above 
9715			 
9715			forth_push_numhl: 
9715			 
9715 e5				push hl    ; save value to push 
9716			 
9716			if DEBUG_FORTH_PUSH 
9716				; see if disabled 
9716			 
9716			 
9716				push af 
9716				ld a, (os_view_disable) 
9716				cp '*' 
9716				jr z, .pskip2 
9716				push hl 
9716			push hl 
9716				call clear_display 
9716			pop hl 
9716				ld a,h 
9716				ld hl, os_word_scratch 
9716				call hexout 
9716				pop hl 
9716				ld a,l 
9716				ld hl, os_word_scratch+2 
9716				call hexout 
9716			 
9716				ld hl, os_word_scratch+4 
9716				ld a,0 
9716				ld (hl),a 
9716				ld de,os_word_scratch 
9716					ld a, display_row_2 
9716					call str_at_display 
9716				ld de, .push_num 
9716				ld a, display_row_1 
9716			 
9716					call str_at_display 
9716			 
9716			 
9716				call update_display 
9716				call delay1s 
9716				call delay1s 
9716			.pskip2:  
9716			 
9716				pop af 
9716			endif	 
9716			 
9716			 
9716				FORTH_DSP_NEXT 
9716 cd a4 96			call macro_forth_dsp_next 
9719				endm 
# End of macro FORTH_DSP_NEXT
9719			 
9719 2a 22 eb			ld hl, (cli_data_sp) 
971c			 
971c				; save item type 
971c 3e 02			ld a,  DS_TYPE_INUM 
971e 77				ld (hl), a 
971f 23				inc hl 
9720			 
9720				; get word off stack 
9720 d1				pop de 
9721 7b				ld a,e 
9722 77				ld (hl), a 
9723 23				inc hl 
9724 7a				ld a,d 
9725 77				ld (hl), a 
9726			 
9726			if DEBUG_FORTH_PUSH 
9726				dec hl 
9726				dec hl 
9726				dec hl 
9726						DMARK "PH5" 
9726				CALLMONITOR 
9726			endif	 
9726			 
9726 c9				ret 
9727			 
9727			 
9727			; Push a string to stack pointed to by hl 
9727			 
9727			forth_push_str: 
9727			 
9727			if DEBUG_FORTH_PUSH 
9727						DMARK "PSQ" 
9727				CALLMONITOR 
9727			endif	 
9727			    
9727 e5				push hl 
9728 e5				push hl 
9729			 
9729 3e 00			ld a, 0   ; find end of string 
972b cd 20 8e			call strlent       
972e			if DEBUG_FORTH_PUSH 
972e						DMARK "PQ2" 
972e				CALLMONITOR 
972e			endif	 
972e eb				ex de, hl 
972f e1				pop hl   ; get ptr to start of string 
9730			if DEBUG_FORTH_PUSH 
9730						DMARK "PQ3" 
9730				CALLMONITOR 
9730			endif	 
9730 19				add hl,de 
9731			if DEBUG_FORTH_PUSH 
9731						DMARK "PQE" 
9731				CALLMONITOR 
9731			endif	 
9731			 
9731 2b				dec hl    ; see if there is an optional trailing double quote 
9732 7e				ld a,(hl) 
9733 fe 22			cp '"' 
9735 20 03			jr nz, .strnoq 
9737 3e 00			ld a, 0      ; get rid of double quote 
9739 77				ld (hl), a 
973a 23			.strnoq: inc hl 
973b			 
973b 3e 00			ld a, 0 
973d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
973e			 
973e 13				inc de ; add one for the type string 
973f 13				inc de ; add one for null term??? 
9740			 
9740				; tos is get string pointer again 
9740				; de contains space to allocate 
9740				 
9740 d5				push de 
9741			 
9741 eb				ex de, hl 
9742			 
9742				;push af 
9742			 
9742			if DEBUG_FORTH_PUSH 
9742						DMARK "PHm" 
9742				CALLMONITOR 
9742			endif	 
9742 cd 7e 8e			call malloc	; on ret hl now contains allocated memory 
9745				if DEBUG_FORTH_MALLOC_GUARD 
9745 cc 69 c1				call z,malloc_error 
9748				endif 
9748			 
9748				 
9748 c1				pop bc    ; get length 
9749 d1				pop de   ;  get string start    
974a			 
974a				; hl has destination from malloc 
974a			 
974a eb				ex de, hl    ; prep for ldir 
974b			 
974b e5				push hl   ; save malloc area for DSP later 
974c			 
974c			if DEBUG_FORTH_PUSH 
974c						DMARK "PHc" 
974c				CALLMONITOR 
974c			endif	 
974c			 
974c			 
974c ed b0			ldir 
974e			 
974e			 
974e				; push malloc to data stack     macro?????  
974e			 
974e				FORTH_DSP_NEXT 
974e cd a4 96			call macro_forth_dsp_next 
9751				endm 
# End of macro FORTH_DSP_NEXT
9751			 
9751				; save value and type 
9751			 
9751 2a 22 eb			ld hl, (cli_data_sp) 
9754			 
9754				; save item type 
9754 3e 01			ld a,  DS_TYPE_STR 
9756 77				ld (hl), a 
9757 23				inc hl 
9758			 
9758				; get malloc word off stack 
9758 d1				pop de 
9759 73				ld (hl), e 
975a 23				inc hl 
975b 72				ld (hl), d 
975c			 
975c			 
975c			 
975c			if DEBUG_FORTH_PUSH 
975c				ld hl, (cli_data_sp) 
975c						DMARK "PHS" 
975c				CALLMONITOR 
975c			;	ex de,hl 
975c			endif	 
975c				; in case of spaces, skip the ptr past the copied string 
975c				;pop af 
975c				;ld (cli_origptr),hl 
975c			 
975c c9				ret 
975d			 
975d			 
975d			 
975d			; TODO ascii push input onto stack given hl to start of input 
975d			 
975d			; identify type 
975d			; if starts with a " then a string 
975d			; otherwise it is a number 
975d			;  
975d			; if a string 
975d			;     scan for ending " to get length of string to malloc for + 1 
975d			;     malloc 
975d			;     put pointer to string on stack first byte flags as string 
975d			; 
975d			; else a number 
975d			;    look for number format identifier 
975d			;    $xx hex 
975d			;    %xxxxx bin 
975d			;    xxxxx decimal 
975d			;    convert number to 16bit word.  
975d			;    malloc word + 1 with flag to identiy as num 
975d			;    put pointer to number on stack 
975d			;   
975d			;  
975d			  
975d			forth_apush: 
975d				; kernel push 
975d			 
975d			if DEBUG_FORTH_PUSH 
975d						DMARK "PSH" 
975d				CALLMONITOR 
975d			endif	 
975d				; identify input type 
975d			 
975d 7e				ld a,(hl) 
975e fe 22			cp '"' 
9760 28 0a			jr z, .fapstr 
9762 fe 24			cp '$' 
9764 ca 8c 97			jp z, .faphex 
9767 fe 25			cp '%' 
9769 ca 74 97			jp z, .fapbin 
976c			;	cp 'b' 
976c			;	jp z, .fabin 
976c				; else decimal 
976c			 
976c				; TODO do decimal conversion 
976c				; decimal is stored as a 16bit word 
976c			 
976c				; by default everything is a string if type is not detected 
976c			.fapstr: ; 
976c fe 22			cp '"' 
976e 20 01			jr nz, .strnoqu 
9770 23				inc hl 
9771			.strnoqu: 
9771 c3 27 97			jp forth_push_str 
9774			 
9774			 
9774			 
9774			.fapbin:    ; push a binary string.  
9774 11 00 00			ld de, 0   ; hold a 16bit value 
9777			 
9777 23			.fapbinshift:	inc hl  
9778 7e				ld a,(hl) 
9779 fe 00			cp 0     ; done scanning  
977b 28 0b			jr z, .fapbdone  	; got it in HL so push  
977d			 
977d				; left shift de 
977d eb				ex de, hl	 
977e 29				add hl, hl 
977f			 
977f				; is 1 
977f fe 31			cp '1' 
9781 20 02			jr nz, .binzero 
9783 cb 4d			bit 1, l 
9785			.binzero: 
9785 eb				ex de, hl	 ; save current de 
9786 18 ef			jr .fapbinshift 
9788			 
9788			.fapbdone: 
9788 eb				ex de, hl 
9789 c3 15 97			jp forth_push_numhl 
978c			 
978c			 
978c			.faphex:   ; hex is always stored as a 16bit word 
978c				; skip number prefix 
978c 23				inc hl 
978d				; turn ascii into number 
978d cd 6e 8d			call get_word_hl	; ret 16bit word in hl 
9790			 
9790 c3 15 97			jp forth_push_numhl 
9793			 
9793 00				 nop 
9794			 
9794			.fabin:   ; TODO bin conversion 
9794			 
9794			 
9794 c9				ret 
9795			 
9795			 
9795			; get either a string ptr or a 16bit word from the data stack 
9795			 
9795			FORTH_DSP: macro 
9795				call macro_forth_dsp 
9795				endm 
9795			 
9795			macro_forth_dsp: 
9795				; data stack pointer points to current word on tos 
9795			 
9795 2a 22 eb			ld hl,(cli_data_sp) 
9798			 
9798				if DEBUG_FORTH_PUSH 
9798						DMARK "DSP" 
9798			 
9798					call display_data_sp 
9798				;call break_point_state 
9798				;rst 030h 
9798				CALLMONITOR 
9798				endif 
9798			 
9798 c9				ret 
9799			 
9799			; return hl to start of value on stack 
9799			 
9799			FORTH_DSP_VALUE: macro 
9799				call macro_forth_dsp_value 
9799				endm 
9799			 
9799			macro_forth_dsp_value: 
9799			 
9799				FORTH_DSP 
9799 cd 95 97			call macro_forth_dsp 
979c				endm 
# End of macro FORTH_DSP
979c			 
979c d5				push de 
979d			 
979d 23				inc hl ; skip type 
979e			 
979e 5e				ld e, (hl) 
979f 23				inc hl 
97a0 56				ld d, (hl) 
97a1 eb				ex de,hl  
97a2			 
97a2 d1				pop de 
97a3			 
97a3 c9				ret 
97a4			 
97a4			; return hl to start of value to second item on stack 
97a4			 
97a4			FORTH_DSP_VALUEM1: macro 
97a4				call macro_forth_dsp_value_m1 
97a4				endm 
97a4			 
97a4			macro_forth_dsp_value_m1: 
97a4			 
97a4				FORTH_DSP 
97a4 cd 95 97			call macro_forth_dsp 
97a7				endm 
# End of macro FORTH_DSP
97a7			 
97a7 2b				dec hl 
97a8 2b				dec hl 
97a9			;	dec hl 
97a9			 
97a9 d5				push de 
97aa			 
97aa 5e				ld e, (hl) 
97ab 23				inc hl 
97ac 56				ld d, (hl) 
97ad eb				ex de,hl  
97ae			 
97ae d1				pop de 
97af			 
97af c9				ret 
97b0			 
97b0				 
97b0			 
97b0			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
97b0			 
97b0			FORTH_DSP_POP: macro 
97b0				call macro_forth_dsp_pop 
97b0				endm 
97b0			 
97b0			 
97b0			; get the tos data type 
97b0			 
97b0			FORTH_DSP_TYPE:   macro 
97b0			 
97b0				;FORTH_DSP_VALUE 
97b0				FORTH_DSP 
97b0				 
97b0				; hl points to value 
97b0				; check type 
97b0			 
97b0				ld a,(hl) 
97b0			 
97b0				endm 
97b0			 
97b0			; load the tos value into hl 
97b0			 
97b0			 
97b0			FORTH_DSP_VALUEHL:  macro 
97b0				call macro_dsp_valuehl 
97b0				endm 
97b0			 
97b0			 
97b0			 
97b0			macro_dsp_valuehl: 
97b0				FORTH_DSP_VALUE 
97b0 cd 99 97			call macro_forth_dsp_value 
97b3				endm 
# End of macro FORTH_DSP_VALUE
97b3			 
97b3				;FORTH_ERR_TOS_NOTNUM 
97b3			 
97b3				;inc hl   ; skip type id 
97b3			 
97b3			;	push de 
97b3			; 
97b3			;	ld e, (hl) 
97b3			;	inc hl 
97b3			;	ld d, (hl) 
97b3			;	ex de,hl  
97b3			 
97b3			;	pop de 
97b3			 
97b3				if DEBUG_FORTH_PUSH 
97b3						DMARK "DVL" 
97b3				CALLMONITOR 
97b3				endif 
97b3 c9				ret 
97b4			 
97b4			forth_apushstrhl:      
97b4				; push of string requires use of cli_origptr 
97b4				; bodge use 
97b4			 
97b4				; get current cli_origptr, save, update with temp pointer  
97b4 ed 5b 3e eb		ld de, (cli_origptr) 
97b8 22 3e eb			ld (cli_origptr), hl 
97bb d5				push de 
97bc cd 5d 97			call forth_apush 
97bf d1				pop de 
97c0 ed 53 3e eb		ld (cli_origptr), de 
97c4 c9			        ret	 
97c5			 
97c5			 
97c5			; increase loop stack pointer and save hl to it 
97c5				 
97c5			FORTH_LOOP_NEXT: macro 
97c5				call macro_forth_loop_next 
97c5				;nop 
97c5				endm 
97c5			 
97c5			macro_forth_loop_next: 
97c5				if DEBUG_FORTH_STACK_GUARD 
97c5 cd 03 d2				call check_stacks 
97c8				endif 
97c8 e5				push hl 
97c9 d5				push de 
97ca eb				ex de,hl 
97cb 2a 24 eb			ld hl,(cli_loop_sp) 
97ce 23				inc hl 
97cf 23				inc hl 
97d0					if DEBUG_FORTH_WORDS 
97d0						DMARK "LNX" 
97d0 f5				push af  
97d1 3a e5 97			ld a, (.dmark)  
97d4 32 7a ee			ld (debug_mark),a  
97d7 3a e6 97			ld a, (.dmark+1)  
97da 32 7b ee			ld (debug_mark+1),a  
97dd 3a e7 97			ld a, (.dmark+2)  
97e0 32 7c ee			ld (debug_mark+2),a  
97e3 18 03			jr .pastdmark  
97e5 ..			.dmark: db "LNX"  
97e8 f1			.pastdmark: pop af  
97e9			endm  
# End of macro DMARK
97e9						CALLMONITOR 
97e9 cd 7b 91			call break_point_state  
97ec				endm  
# End of macro CALLMONITOR
97ec					endif 
97ec 22 24 eb			ld (cli_loop_sp),hl 
97ef 73				ld (hl), e 
97f0 23				inc hl 
97f1 72				ld (hl), d 
97f2 d1				pop de    ; been reversed so save a swap on restore 
97f3 e1				pop hl 
97f4				if DEBUG_FORTH_STACK_GUARD 
97f4 cd 03 d2				call check_stacks 
97f7				endif 
97f7 c9				ret 
97f8			 
97f8			; get current ret stack pointer and save to hl  
97f8				 
97f8			FORTH_LOOP_TOS: macro 
97f8				call macro_forth_loop_tos 
97f8				endm 
97f8			 
97f8			macro_forth_loop_tos: 
97f8 d5				push de 
97f9 2a 24 eb			ld hl,(cli_loop_sp) 
97fc 5e				ld e, (hl) 
97fd 23				inc hl 
97fe 56				ld d, (hl) 
97ff eb				ex de, hl 
9800 d1				pop de 
9801 c9				ret 
9802			 
9802			; pop loop stack pointer 
9802				 
9802			FORTH_LOOP_POP: macro 
9802				call macro_forth_loop_pop 
9802				endm 
9802			 
9802			 
9802			macro_forth_loop_pop: 
9802				if DEBUG_FORTH_STACK_GUARD 
9802					DMARK "LPP" 
9802 f5				push af  
9803 3a 17 98			ld a, (.dmark)  
9806 32 7a ee			ld (debug_mark),a  
9809 3a 18 98			ld a, (.dmark+1)  
980c 32 7b ee			ld (debug_mark+1),a  
980f 3a 19 98			ld a, (.dmark+2)  
9812 32 7c ee			ld (debug_mark+2),a  
9815 18 03			jr .pastdmark  
9817 ..			.dmark: db "LPP"  
981a f1			.pastdmark: pop af  
981b			endm  
# End of macro DMARK
981b cd 03 d2				call check_stacks 
981e					FORTH_CHK_LOOP_UNDER 
981e e5				push hl 
981f d5				push de 
9820 2a 24 eb			ld hl,(cli_loop_sp) 
9823 11 de e9			ld de, cli_loop_stack 
9826 cd d5 89			call cmp16 
9829 da 1d d3			jp c, fault_loop_under 
982c d1				pop de 
982d e1				pop hl 
982e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
982e				endif 
982e e5				push hl 
982f 2a 24 eb			ld hl,(cli_loop_sp) 
9832 2b				dec hl 
9833 2b				dec hl 
9834 22 24 eb			ld (cli_loop_sp), hl 
9837				; TODO do stack underflow checks 
9837 e1				pop hl 
9838				if DEBUG_FORTH_STACK_GUARD 
9838 cd 03 d2				call check_stacks 
983b					FORTH_CHK_LOOP_UNDER 
983b e5				push hl 
983c d5				push de 
983d 2a 24 eb			ld hl,(cli_loop_sp) 
9840 11 de e9			ld de, cli_loop_stack 
9843 cd d5 89			call cmp16 
9846 da 1d d3			jp c, fault_loop_under 
9849 d1				pop de 
984a e1				pop hl 
984b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
984b				endif 
984b c9				ret 
984c			 
984c			macro_forth_dsp_pop: 
984c			 
984c e5				push hl 
984d			 
984d				; release malloc data 
984d			 
984d				if DEBUG_FORTH_STACK_GUARD 
984d cd 03 d2				call check_stacks 
9850					FORTH_CHK_DSP_UNDER 
9850 e5				push hl 
9851 d5				push de 
9852 2a 22 eb			ld hl,(cli_data_sp) 
9855 11 dc e8			ld de, cli_data_stack 
9858 cd d5 89			call cmp16 
985b da 11 d3			jp c, fault_dsp_under 
985e d1				pop de 
985f e1				pop hl 
9860				endm 
# End of macro FORTH_CHK_DSP_UNDER
9860				endif 
9860				;ld hl,(cli_data_sp) 
9860			if DEBUG_FORTH_DOT 
9860				DMARK "DPP" 
9860				CALLMONITOR 
9860			endif	 
9860			 
9860			 
9860			if FORTH_ENABLE_DSPPOPFREE 
9860			 
9860				FORTH_DSP 
9860 cd 95 97			call macro_forth_dsp 
9863				endm 
# End of macro FORTH_DSP
9863			 
9863 7e				ld a, (hl) 
9864 fe 01			cp DS_TYPE_STR 
9866 20 07			jr nz, .skippopfree 
9868			 
9868				FORTH_DSP_VALUEHL 
9868 cd b0 97			call macro_dsp_valuehl 
986b				endm 
# End of macro FORTH_DSP_VALUEHL
986b 00				nop 
986c			if DEBUG_FORTH_DOT 
986c				DMARK "DPf" 
986c				CALLMONITOR 
986c			endif	 
986c cd 48 8f			call free 
986f			.skippopfree: 
986f				 
986f			 
986f			endif 
986f			 
986f			if DEBUG_FORTH_DOT_KEY 
986f				DMARK "DP2" 
986f				CALLMONITOR 
986f			endif	 
986f			 
986f				; move pointer down 
986f			 
986f 2a 22 eb			ld hl,(cli_data_sp) 
9872 2b				dec hl 
9873 2b				dec hl 
9874			; PARSEV5 
9874 2b				dec hl 
9875 22 22 eb			ld (cli_data_sp), hl 
9878			 
9878				if DEBUG_FORTH_STACK_GUARD 
9878 cd 03 d2				call check_stacks 
987b					FORTH_CHK_DSP_UNDER 
987b e5				push hl 
987c d5				push de 
987d 2a 22 eb			ld hl,(cli_data_sp) 
9880 11 dc e8			ld de, cli_data_stack 
9883 cd d5 89			call cmp16 
9886 da 11 d3			jp c, fault_dsp_under 
9889 d1				pop de 
988a e1				pop hl 
988b				endm 
# End of macro FORTH_CHK_DSP_UNDER
988b				endif 
988b			 
988b e1				pop hl 
988c			 
988c c9				ret 
988d			 
988d			getwordathl: 
988d				; hl points to an address 
988d				; load hl with the word at that address 
988d			 
988d d5				push de 
988e			 
988e 5e				ld e, (hl) 
988f 23				inc hl 
9890 56				ld d, (hl) 
9891 eb				ex de, hl 
9892			 
9892 d1				pop de 
9893 c9				ret 
9894			 
9894			 
9894			 
9894			 
9894			 
9894			; eof 
9894			 
# End of file forth_stackopsv5.asm
9894			endif 
9894			 
9894			user_word_eol:  
9894				; hl contains the pointer to where to create a linked list item from the end 
9894				; of the user dict to continue on at the system word dict 
9894				 
9894				; poke the stub of the word list linked list to repoint to rom words 
9894			 
9894				; stub format 
9894				; db   word id 
9894				; dw    link to next word 
9894			        ; db char length of token 
9894				; db string + 0 term 
9894				; db exec code....  
9894			 
9894 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9896 77				ld (hl), a		; word id 
9897 23				inc hl 
9898			 
9898 11 5e 9a			ld de, sysdict 
989b 73				ld (hl), e		; next word link ie system dict 
989c 23				inc hl 
989d 72				ld (hl), d		; next word link ie system dict 
989e 23				inc hl	 
989f			 
989f			;	ld (hl), sysdict		; next word link ie system dict 
989f			;	inc hl 
989f			;	inc hl 
989f			 
989f			;	inc hl 
989f			;	inc hl 
989f			 
989f 3e 02			ld a, 2			; word length is 0 
98a1 77				ld (hl), a	 
98a2 23				inc hl 
98a3			 
98a3 3e 7e			ld a, '~'			; word length is 0 
98a5 77				ld (hl), a	 
98a6 23				inc hl 
98a7 3e 00			ld a, 0			; save empty word 
98a9 77				ld (hl), a 
98aa			 
98aa c9				ret 
98ab			 
98ab				 
98ab			 
98ab			forthexec_cleanup: 
98ab				FORTH_RSP_POP 
98ab cd dd 96			call macro_forth_rsp_pop 
98ae				endm 
# End of macro FORTH_RSP_POP
98ae c9				ret 
98af			 
98af			forth_call_hl: 
98af				; taking hl 
98af e5				push hl 
98b0 c9				ret 
98b1			 
98b1			; this is called to reset Forth system but keep existing uwords etc 
98b1			 
98b1			forth_warmstart: 
98b1				; setup stack over/under flow checks 
98b1				if DEBUG_FORTH_STACK_GUARD 
98b1 cd e9 d1				call chk_stk_init 
98b4				endif 
98b4			 
98b4				; init stack pointers  - * these stacks go upwards *  
98b4 21 e0 ea			ld hl, cli_ret_stack 
98b7 22 26 eb			ld (cli_ret_sp), hl	 
98ba				; set bottom of stack 
98ba 3e 00			ld a,0 
98bc 77				ld (hl),a 
98bd 23				inc hl 
98be 77				ld (hl),a 
98bf			 
98bf 21 dc e8			ld hl, cli_data_stack 
98c2 22 22 eb			ld (cli_data_sp), hl	 
98c5				; set bottom of stack 
98c5 3e 00			ld a,0 
98c7 77				ld (hl),a 
98c8 23				inc hl 
98c9 77				ld (hl),a 
98ca			 
98ca 21 de e9			ld hl, cli_loop_stack 
98cd 22 24 eb			ld (cli_loop_sp), hl	 
98d0				; set bottom of stack 
98d0 3e 00			ld a,0 
98d2 77				ld (hl),a 
98d3 23				inc hl 
98d4 77				ld (hl),a 
98d5			 
98d5				; init extent of current open file 
98d5			 
98d5 3e 00			ld a, 0 
98d7 32 5c eb			ld (store_openext), a 
98da			 
98da c9				ret 
98db			 
98db			 
98db			; Cold Start - this is called to setup the whole Forth system 
98db			 
98db			forth_init: 
98db			 
98db				; setup stack over/under flow checks 
98db			 
98db			;	if DEBUG_FORTH_STACK_GUARD 
98db			;		call chk_stk_init 
98db			;	endif 
98db			 
98db				; enable auto display updates (slow.....) 
98db			 
98db 3e 01			ld a, 1 
98dd 32 3c eb			ld (cli_autodisplay), a 
98e0			 
98e0			 
98e0			 
98e0				; show start up screen 
98e0			 
98e0 cd 5e 88			call clear_display 
98e3			 
98e3 3e 00			ld a,0 
98e5 32 5e eb			ld (f_cursor_ptr), a 
98e8			 
98e8				; set start of word list in start of ram - for use when creating user words 
98e8			 
98e8 21 b4 d4			ld hl, baseram 
98eb 22 72 e6			ld (os_last_new_uword), hl 
98ee cd 94 98			call user_word_eol 
98f1				 
98f1			;		call display_data_sp 
98f1			;		call next_page_prompt 
98f1			 
98f1			 
98f1			 
98f1			 
98f1 c9				ret 
98f2			 
98f2 .. 00		.bootforth: db " Forth Kernel Init ",0 
9906			 
9906			; TODO push to stack 
9906			 
9906			;  
9906			 
9906			if FORTH_PARSEV2 
9906			 
9906			 
9906				include "forth_parserv2.asm" 
9906			 
9906			endif 
9906			 
9906			 
9906			; parse cli version 1 
9906			 
9906			if FORTH_PARSEV1 
9906			 
9906			 
9906			 
9906			      include "forth_parserv1.asm" 
9906			endif 
9906				 
9906			if FORTH_PARSEV3 
9906			 
9906			 
9906			 
9906			      include "forth_parserv3.asm" 
9906				include "forth_wordsv3.asm" 
9906			endif 
9906			 
9906			if FORTH_PARSEV4 
9906			 
9906			 
9906			 
9906			      include "forth_parserv4.asm" 
9906				include "forth_wordsv4.asm" 
9906			endif 
9906			 
9906			if FORTH_PARSEV5 
9906			 
9906			 
9906			 
9906			      include "forth_parserv5.asm" 
9906			 
9906			 
9906			; A better parser without using malloc and string copies all over the place.  
9906			; Exec in situ should be faster 
9906			 
9906			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9906			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9906			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9906			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9906			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9906			WORD_SYS_END: equ 0   ; Opcode for all user words 
9906			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9906			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9906			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9906			 
9906			; Core word preamble macro 
9906			 
9906			CWHEAD:   macro nxtword opcode lit len opflags 
9906				db WORD_SYS_CORE+opcode             
9906				; internal op code number 
9906				dw nxtword            
9906				; link to next dict word block 
9906				db len + 1 
9906				; literal length of dict word inc zero term 
9906				db lit,0              
9906				; literal dict word 
9906			        ; TODO db opflags        
9906				endm 
9906			 
9906			 
9906			NEXTW: macro  
9906				jp macro_next 
9906				endm 
9906			 
9906			macro_next: 
9906			if DEBUG_FORTH_PARSE_KEY 
9906				DMARK "NXT" 
9906				CALLMONITOR 
9906			endif	 
9906			;	inc hl  ; skip token null term  
9906 ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
990a ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
990e 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9911			if DEBUG_FORTH_PARSE_KEY 
9911				DMARK "}AA" 
9911				CALLMONITOR 
9911			endif	 
9911 c3 14 9a			jp execnext 
9914				;jp exec1 
9914			       
9914			 
9914			 
9914			; Another go at the parser to compile  
9914			 
9914			 
9914			; TODO rework parser to change all of the string words to byte tokens 
9914			; TODO do a search for  
9914			 
9914			; TODO first run normal parser to zero term sections 
9914			; TODO for each word do a token look up to get the op code 
9914			; TODO need some means to flag to the exec that this is a byte code form    
9914			 
9914			 
9914			forthcompile: 
9914			 
9914			; 
9914			; line parse: 
9914			;       parse raw input buffer 
9914			;       tokenise the words 
9914			;       malloc new copy (for looping etc) 
9914			;       copy to malloc + current pc in line to start of string and add line term 
9914			;       save on new rsp 
9914			; 
9914			 
9914			; hl to point to the line to tokenise 
9914			 
9914			;	push hl 
9914 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9917			 
9917			;	ld a,0		; string term on input 
9917			;	call strlent 
9917			 
9917			;	ld (os_tok_len), hl	 ; save string length 
9917			 
9917			;if DEBUG_FORTH_TOK 
9917			;	ex de,hl		 
9917			;endif 
9917			 
9917			;	pop hl 		; get back string pointer 
9917			 
9917			if DEBUG_FORTH_TOK 
9917						DMARK "TOc" 
9917				CALLMONITOR 
9917			endif 
9917 7e			.cptoken2:    ld a,(hl) 
9918 23				inc hl 
9919 fe 7f			cp FORTH_END_BUFFER 
991b 28 29			jr z, .cptokendone2 
991d fe 00			cp 0 
991f 28 25			jr z, .cptokendone2 
9921 fe 22			cp '"' 
9923 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9925 fe 20			cp ' ' 
9927 20 ee			jr nz,  .cptoken2 
9929			 
9929			; TODO consume comments held between ( and ) 
9929			 
9929				; we have a space so change to zero term for dict match later 
9929 2b				dec hl 
992a 3e 00			ld a,0 
992c 77				ld (hl), a 
992d 23				inc hl 
992e 18 e7			jr .cptoken2 
9930				 
9930			 
9930			.cptokenstr2: 
9930				; skip all white space until either eol (because forgot to term) or end double quote 
9930			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9930				;inc hl ; skip current double quote 
9930 7e				ld a,(hl) 
9931 23				inc hl 
9932 fe 22			cp '"' 
9934 28 e1			jr z, .cptoken2 
9936 fe 7f			cp FORTH_END_BUFFER 
9938 28 0c			jr z, .cptokendone2 
993a fe 00			cp 0 
993c 28 08			jr z, .cptokendone2 
993e fe 20			cp ' ' 
9940 28 02			jr z, .cptmp2 
9942 18 ec			jr .cptokenstr2 
9944			 
9944			.cptmp2:	; we have a space so change to zero term for dict match later 
9944				;dec hl 
9944				;ld a,"-"	; TODO remove this when working 
9944				;ld (hl), a 
9944				;inc hl 
9944 18 ea			jr .cptokenstr2 
9946			 
9946			.cptokendone2: 
9946				;inc hl 
9946 3e 7f			ld a, FORTH_END_BUFFER 
9948 77				ld (hl),a 
9949 23				inc hl 
994a 3e 21			ld a, '!' 
994c 77				ld (hl),a 
994d			 
994d 2a 76 e6			ld hl,(os_tok_ptr) 
9950			         
9950			if DEBUG_FORTH_TOK 
9950						DMARK "Tc1" 
9950				CALLMONITOR 
9950			endif 
9950			 
9950				; push exec string to top of return stack 
9950				FORTH_RSP_NEXT 
9950 cd bc 96			call macro_forth_rsp_next 
9953				endm 
# End of macro FORTH_RSP_NEXT
9953 c9				ret 
9954			 
9954			; Another go at the parser need to simplify the process 
9954			 
9954			forthparse: 
9954			 
9954			; 
9954			; line parse: 
9954			;       parse raw input buffer 
9954			;       tokenise the words 
9954			;       malloc new copy (for looping etc) 
9954			;       copy to malloc + current pc in line to start of string and add line term 
9954			;       save on new rsp 
9954			; 
9954			 
9954			; hl to point to the line to tokenise 
9954			 
9954			;	push hl 
9954 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9957			 
9957			;	ld a,0		; string term on input 
9957			;	call strlent 
9957			 
9957			;	ld (os_tok_len), hl	 ; save string length 
9957			 
9957			;if DEBUG_FORTH_TOK 
9957			;	ex de,hl		 
9957			;endif 
9957			 
9957			;	pop hl 		; get back string pointer 
9957			 
9957			if DEBUG_FORTH_TOK 
9957						DMARK "TOK" 
9957				CALLMONITOR 
9957			endif 
9957 7e			.ptoken2:    ld a,(hl) 
9958 23				inc hl 
9959 fe 7f			cp FORTH_END_BUFFER 
995b 28 29			jr z, .ptokendone2 
995d fe 00			cp 0 
995f 28 25			jr z, .ptokendone2 
9961 fe 22			cp '"' 
9963 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9965 fe 20			cp ' ' 
9967 20 ee			jr nz,  .ptoken2 
9969			 
9969			; TODO consume comments held between ( and ) 
9969			 
9969				; we have a space so change to zero term for dict match later 
9969 2b				dec hl 
996a 3e 00			ld a,0 
996c 77				ld (hl), a 
996d 23				inc hl 
996e 18 e7			jr .ptoken2 
9970				 
9970			 
9970			.ptokenstr2: 
9970				; skip all white space until either eol (because forgot to term) or end double quote 
9970			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9970				;inc hl ; skip current double quote 
9970 7e				ld a,(hl) 
9971 23				inc hl 
9972 fe 22			cp '"' 
9974 28 e1			jr z, .ptoken2 
9976 fe 7f			cp FORTH_END_BUFFER 
9978 28 0c			jr z, .ptokendone2 
997a fe 00			cp 0 
997c 28 08			jr z, .ptokendone2 
997e fe 20			cp ' ' 
9980 28 02			jr z, .ptmp2 
9982 18 ec			jr .ptokenstr2 
9984			 
9984			.ptmp2:	; we have a space so change to zero term for dict match later 
9984				;dec hl 
9984				;ld a,"-"	; TODO remove this when working 
9984				;ld (hl), a 
9984				;inc hl 
9984 18 ea			jr .ptokenstr2 
9986			 
9986			.ptokendone2: 
9986				;inc hl 
9986 3e 7f			ld a, FORTH_END_BUFFER 
9988 77				ld (hl),a 
9989 23				inc hl 
998a 3e 21			ld a, '!' 
998c 77				ld (hl),a 
998d			 
998d 2a 76 e6			ld hl,(os_tok_ptr) 
9990			         
9990			if DEBUG_FORTH_TOK 
9990						DMARK "TK1" 
9990				CALLMONITOR 
9990			endif 
9990			 
9990				; push exec string to top of return stack 
9990				FORTH_RSP_NEXT 
9990 cd bc 96			call macro_forth_rsp_next 
9993				endm 
# End of macro FORTH_RSP_NEXT
9993 c9				ret 
9994			 
9994			; 
9994			;	; malloc size + buffer pointer + if is loop flag 
9994			;	ld hl,(os_tok_len) 		 ; get string length 
9994			; 
9994			;	ld a,l 
9994			; 
9994			;	cp 0			; we dont want to use a null string 
9994			;	ret z 
9994			; 
9994			;;	add 3    ; prefix malloc with buffer for current word ptr 
9994			; 
9994			;	add 5     ; TODO when certain not over writing memory remove 
9994			; 
9994			;		 
9994			; 
9994			;if DEBUG_FORTH_TOK 
9994			;			DMARK "TKE" 
9994			;	CALLMONITOR 
9994			;endif 
9994			; 
9994			;	ld l,a 
9994			;	ld h,0 
9994			;;	push hl   ; save required space for the copy later 
9994			;	call malloc 
9994			;if DEBUG_FORTH_TOK 
9994			;			DMARK "TKM" 
9994			;	CALLMONITOR 
9994			;endif 
9994			;	if DEBUG_FORTH_MALLOC_GUARD 
9994			;		push af 
9994			;		call ishlzero 
9994			;;		ld a, l 
9994			;;		add h 
9994			;;		cp 0 
9994			;		pop af 
9994			;		 
9994			;		call z,malloc_error 
9994			;	endif 
9994			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9994			; 
9994			; 
9994			;if DEBUG_FORTH_TOK 
9994			;			DMARK "TKR" 
9994			;	CALLMONITOR 
9994			;endif 
9994			; 
9994			;	FORTH_RSP_NEXT 
9994			; 
9994			;	;inc hl	 ; go past current buffer pointer 
9994			;	;inc hl 
9994			;	;inc hl   ; and past if loop flag 
9994			;		; TODO Need to set flag  
9994			; 
9994			;	 
9994			;	 
9994			;	ex de,hl	; malloc is dest 
9994			;	ld hl, (os_tok_len) 
9994			;;	pop bc 
9994			;	ld c, l                
9994			;	ld b,0 
9994			;	ld hl, (os_tok_ptr) 
9994			; 
9994			;if DEBUG_FORTH_TOK 
9994			;			DMARK "TKT" 
9994			;	CALLMONITOR 
9994			;endif 
9994			; 
9994			;	; do str cpy 
9994			; 
9994			;	ldir      ; copy byte in hl to de 
9994			; 
9994			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9994			; 
9994			;if DEBUG_FORTH_TOK 
9994			; 
9994			;			DMARK "TKY" 
9994			;	CALLMONITOR 
9994			;endif 
9994			;	;ld a,0 
9994			;	;ld a,FORTH_END_BUFFER 
9994			;	ex de, hl 
9994			;	;dec hl			 ; go back over the space delim at the end of word 
9994			;	;ld (hl),a 
9994			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9994			;	ld a,FORTH_END_BUFFER 
9994			;	ld (hl),a 
9994			;	inc hl 
9994			;	ld a,FORTH_END_BUFFER 
9994			;	ld (hl),a 
9994			; 
9994			;	; init the malloc area data 
9994			;	; set pc for in current area 
9994			;	;ld hl, (os_tok_malloc) 
9994			;	;inc hl 
9994			;	;inc hl 
9994			;	;inc hl 
9994			;	;ex de,hl 
9994			;	;ld hl, (os_tok_malloc) 
9994			;	;ld (hl),e 
9994			;	;inc hl 
9994			;	;ld (hl),d 
9994			; 
9994			; 
9994			;	ld hl,(os_tok_malloc) 
9994			;if DEBUG_FORTH_PARSE_KEY 
9994			;			DMARK "TKU" 
9994			;	CALLMONITOR 
9994			;endif 
9994			; 
9994			;	ret 
9994			 
9994			forthexec: 
9994			 
9994			; line exec: 
9994			; forth parser 
9994			 
9994			; 
9994			;       get current exec line on rsp 
9994			 
9994				FORTH_RSP_TOS 
9994 cd d3 96			call macro_forth_rsp_tos 
9997				endm 
# End of macro FORTH_RSP_TOS
9997			 
9997			;       restore current pc - hl points to malloc of data 
9997			 
9997				;ld e, (hl) 
9997				;inc hl 
9997				;ld d, (hl) 
9997				;ex de,hl 
9997			 
9997			 
9997			exec1: 
9997 22 76 e6			ld (os_tok_ptr), hl 
999a			 
999a				; copy our PC to working vars  
999a 22 40 eb			ld (cli_ptr), hl 
999d 22 3e eb			ld (cli_origptr), hl 
99a0			 
99a0 7e				ld a,(hl) 
99a1 fe 7f			cp FORTH_END_BUFFER 
99a3 c8				ret z 
99a4			 
99a4				; skip any nulls 
99a4			 
99a4 fe 00			cp 0 
99a6 20 03			jr nz, .execword 
99a8 23				inc hl 
99a9 18 ec			jr exec1 
99ab			 
99ab			 
99ab			.execword: 
99ab			 
99ab			 
99ab			 
99ab			if DEBUG_FORTH_PARSE_KEY 
99ab						DMARK "KYQ" 
99ab				CALLMONITOR 
99ab			endif 
99ab			;       while at start of word: 
99ab			; get start of dict (in user area first) 
99ab			 
99ab 21 b4 d4		ld hl, baseram 
99ae			;ld hl, sysdict 
99ae 22 42 eb		ld (cli_nextword),hl 
99b1			;           match word at pc 
99b1			;           exec word 
99b1			;           or push to dsp 
99b1			;           forward to next token 
99b1			;           if line term pop rsp and exit 
99b1			;        
99b1			 
99b1			if DEBUG_FORTH_PARSE_KEY 
99b1						DMARK "KYq" 
99b1				CALLMONITOR 
99b1			endif 
99b1			 
99b1			; 
99b1			; word comp 
99b1			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
99b1			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
99b1			;    move to start of word  
99b1			;    compare word to cli_token 
99b1			 
99b1			.execpnword:	; HL at start of a word in the dictionary to check 
99b1			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
99b1			;	ld (cli_ptr), hl 
99b1			 
99b1 2a 42 eb			ld hl,(cli_nextword) 
99b4			 
99b4 cd 57 9a			call forth_tok_next 
99b7			; tok next start here 
99b7			;	; TODO skip compiled symbol for now 
99b7			;	inc hl 
99b7			; 
99b7			;	; save pointer to next word 
99b7			; 
99b7			;	; hl now points to the address of the next word pointer  
99b7			;	ld e, (hl) 
99b7			;	inc hl 
99b7			;	ld d, (hl) 
99b7			;	inc l 
99b7			; 
99b7			;	ex de,hl 
99b7			;if DEBUG_FORTH_PARSE_NEXTWORD 
99b7			;	push bc 
99b7			;	ld bc, (cli_nextword) 
99b7			;			DMARK "NXW" 
99b7			;	CALLMONITOR 
99b7			;	pop bc 
99b7			;endif 
99b7			; tok next end here 
99b7 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
99ba eb				ex de, hl 
99bb			 
99bb			 
99bb				; save the pointer of the current token - 1 to check against 
99bb				 
99bb 22 46 eb			ld (cli_token), hl   
99be				; TODO maybe remove below save if no debug 
99be				; save token string ptr for any debug later 
99be 23				inc hl  
99bf 22 48 eb			ld (cli_origtoken), hl 
99c2 2b				dec hl 
99c3				; save pointer to the start of the next dictionay word 
99c3 7e				ld a,(hl)   ; get string length 
99c4 47				ld b,a 
99c5			.execpnwordinc:  
99c5 23				inc hl 
99c6 10 fd			djnz .execpnwordinc 
99c8 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
99cb			 
99cb				; now check the word token against the string being parsed 
99cb			 
99cb 2a 46 eb			ld hl,(cli_token) 
99ce 23				inc hl     ; skip string length (use zero term instead to end) 
99cf 22 46 eb			ld (cli_token), hl 
99d2			 
99d2			if DEBUG_FORTH_PARSE_KEY 
99d2						DMARK "KY2" 
99d2			endif 
99d2			if DEBUG_FORTH_PARSE_EXEC 
99d2				; see if disabled 
99d2			 
99d2				ld a, (os_view_disable) 
99d2				cp '*' 
99d2				jr z, .skip 
99d2			 
99d2				push hl 
99d2				push hl 
99d2				call clear_display 
99d2				ld de, .compword 
99d2				ld a, display_row_1 
99d2				call str_at_display 
99d2				pop de 
99d2				ld a, display_row_2 
99d2				call str_at_display 
99d2				ld hl,(cli_ptr) 
99d2				ld a,(hl) 
99d2			        ld hl, os_word_scratch 
99d2				ld (hl),a 
99d2				ld a,0 
99d2				inc hl 
99d2				ld (hl),a 	 
99d2				ld de, os_word_scratch 
99d2				ld a, display_row_2+10 
99d2				call str_at_display 
99d2				call update_display 
99d2				ld a, 100 
99d2				call aDelayInMS 
99d2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
99d2				call delay250ms 
99d2				endif 
99d2				pop hl 
99d2			.skip:  
99d2			endif	 
99d2			.execpnchar:    ; compare char between token and string to parse 
99d2			 
99d2			if DEBUG_FORTH_PARSE_KEY 
99d2						DMARK "Ky3" 
99d2			endif 
99d2			if DEBUG_FORTH_PARSE_EXEC 
99d2				; see if disabled 
99d2			 
99d2				ld a, (os_view_disable) 
99d2				cp '*' 
99d2				jr z, .skip2 
99d2			 
99d2			;	call clear_display 
99d2			ld hl,(cli_token) 
99d2			ld a,(hl) 
99d2			ld (os_word_scratch),a 
99d2				ld hl,(cli_ptr) 
99d2			ld a,(hl) 
99d2				ld (os_word_scratch+1),a 
99d2				ld a,0 
99d2				ld (os_word_scratch+2),a 
99d2				ld de,os_word_scratch 
99d2				ld a,display_row_4 
99d2				call str_at_display 
99d2				call update_display 
99d2			.skip2:  
99d2			endif 
99d2 2a 46 eb			ld hl,(cli_token) 
99d5 7e				ld a, (hl)	 ; char in word token 
99d6 23				inc hl 		; move to next char 
99d7 22 46 eb			ld (cli_token), hl ; and save it 
99da 47				ld b,a 
99db			 
99db 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
99de 7e				ld a,(hl) 
99df 23				inc hl 
99e0 22 40 eb			ld (cli_ptr), hl		; move to next char 
99e3 cd 0c 8e			call toUpper 		; make sure the input string matches case 
99e6			 
99e6			if DEBUG_FORTH_PARSE 
99e6			endif 
99e6			 
99e6				; input stream end of token is a space so get rid of it 
99e6			 
99e6			;	cp ' ' 
99e6			;	jr nz, .pnskipspace 
99e6			; 
99e6			;	ld a, 0		; make same term as word token term 
99e6			; 
99e6			;.pnskipspace: 
99e6			 
99e6			if DEBUG_FORTH_PARSE_KEY 
99e6						DMARK "KY7" 
99e6			endif 
99e6 b8				cp b 
99e7 c2 fd 99			jp nz, .execpnskipword	 ; no match so move to next word 
99ea				 
99ea			;    if same 
99ea			;       scan for string terms 0 for token and 32 for input 
99ea			 
99ea				 
99ea			if DEBUG_FORTH_PARSE_KEY 
99ea						DMARK "KY8" 
99ea			endif 
99ea			 
99ea 80				add b			 
99eb fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
99ed							; TODO need to make sure last word in zero term string is accounted for 
99ed 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
99ef			 
99ef			 
99ef				; at end of both strings so both are exact match 
99ef			 
99ef			;       skip ptr for next word 
99ef			 
99ef 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
99f2 23				inc hl			 ; at next char 
99f3 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
99f6 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
99f9				 
99f9				 
99f9			if DEBUG_FORTH_PARSE_KEY 
99f9						DMARK "KY3" 
99f9			endif 
99f9			 
99f9			 
99f9			 
99f9			;       exec code block 
99f9			if DEBUG_FORTH_JP 
99f9				call clear_display 
99f9				call update_display 
99f9				call delay1s 
99f9				ld hl, (cli_execword)     ; save for next check if no match on this word 
99f9				ld a,h 
99f9				ld hl, os_word_scratch 
99f9				call hexout 
99f9				ld hl, (cli_execword)     ; save for next check if no match on this word 
99f9				ld a,l 
99f9				ld hl, os_word_scratch+2 
99f9				call hexout 
99f9				ld hl, os_word_scratch+4 
99f9				ld a,0 
99f9				ld (hl),a 
99f9				ld de,os_word_scratch 
99f9				call str_at_display 
99f9					ld a, display_row_2 
99f9					call str_at_display 
99f9				ld de, (cli_origtoken) 
99f9				ld a, display_row_1+10 
99f9					call str_at_display 
99f9			 
99f9				ld a,display_row_1 
99f9				ld de, .foundword 
99f9				ld a, display_row_3 
99f9				call str_at_display 
99f9				call update_display 
99f9				call delay1s 
99f9				call delay1s 
99f9				call delay1s 
99f9			endif 
99f9			 
99f9			if DEBUG_FORTH_PARSE_KEY 
99f9						DMARK "KYj" 
99f9			endif 
99f9				; TODO save the word pointer in this exec 
99f9			 
99f9 2a 44 eb			ld hl,(cli_execword) 
99fc e9				jp (hl) 
99fd			 
99fd			 
99fd			;    if not same 
99fd			;	scan for zero term 
99fd			;	get ptr for next word 
99fd			;	goto word comp 
99fd			 
99fd			.execpnskipword:	; get pointer to next word 
99fd 2a 42 eb			ld hl,(cli_nextword) 
9a00			 
9a00 7e				ld a,(hl) 
9a01 fe 00			cp WORD_SYS_END 
9a03			;	cp 0 
9a03 28 09			jr z, .execendofdict			 ; at end of words 
9a05			 
9a05			if DEBUG_FORTH_PARSE_KEY 
9a05						DMARK "KY4" 
9a05			endif 
9a05			if DEBUG_FORTH_PARSE_EXEC 
9a05			 
9a05				; see if disabled 
9a05			 
9a05				ld a, (os_view_disable) 
9a05				cp '*' 
9a05				jr z, .noskip 
9a05			 
9a05			 
9a05				ld de, .nowordfound 
9a05				ld a, display_row_3 
9a05				call str_at_display 
9a05				call update_display 
9a05				ld a, 100 
9a05				call aDelayInMS 
9a05				 
9a05				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9a05					call delay250ms 
9a05				endif 
9a05			.noskip:  
9a05			 
9a05			endif	 
9a05			 
9a05 2a 3e eb			ld hl,(cli_origptr) 
9a08 22 40 eb			ld (cli_ptr),hl 
9a0b			 
9a0b			if DEBUG_FORTH_PARSE_KEY 
9a0b						DMARK "KY5" 
9a0b			endif 
9a0b c3 b1 99			jp .execpnword			; else go to next word 
9a0e			 
9a0e			.execendofdict:  
9a0e			 
9a0e			if DEBUG_FORTH_PARSE_KEY 
9a0e						DMARK "KYe" 
9a0e			endif 
9a0e			if DEBUG_FORTH_PARSE_EXEC 
9a0e				; see if disabled 
9a0e			 
9a0e				ld a, (os_view_disable) 
9a0e				cp '*' 
9a0e				jr z, .ispskip 
9a0e			 
9a0e				call clear_display 
9a0e				call update_display 
9a0e				call delay1s 
9a0e				ld de, (cli_origptr) 
9a0e				ld a, display_row_1 
9a0e				call str_at_display 
9a0e				 
9a0e				ld de, .enddict 
9a0e				ld a, display_row_3 
9a0e				call str_at_display 
9a0e				call update_display 
9a0e				ld a, 100 
9a0e				call aDelayInMS 
9a0e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9a0e				call delay1s 
9a0e				call delay1s 
9a0e				call delay1s 
9a0e				endif 
9a0e			.ispskip:  
9a0e				 
9a0e			endif	 
9a0e			 
9a0e			 
9a0e			 
9a0e				; if the word is not a keyword then must be a literal so push it to stack 
9a0e			 
9a0e			; push token to stack to end of word 
9a0e			 
9a0e				STACKFRAME ON $1efe $2f9f 
9a0e				if DEBUG_STACK_IMB 
9a0e					if ON 
9a0e						exx 
9a0e						ld de, $1efe 
9a0e						ld a, d 
9a0e						ld hl, curframe 
9a0e						call hexout 
9a0e						ld a, e 
9a0e						ld hl, curframe+2 
9a0e						call hexout 
9a0e						ld hl, $1efe 
9a0e						push hl 
9a0e						ld hl, $2f9f 
9a0e						push hl 
9a0e						exx 
9a0e					endif 
9a0e				endif 
9a0e			endm 
# End of macro STACKFRAME
9a0e			 
9a0e 2a 76 e6		ld hl,(os_tok_ptr) 
9a11 cd 5d 97		call forth_apush 
9a14			 
9a14				STACKFRAMECHK ON $1efe $2f9f 
9a14				if DEBUG_STACK_IMB 
9a14					if ON 
9a14						exx 
9a14						ld hl, $2f9f 
9a14						pop de   ; $2f9f 
9a14						call cmp16 
9a14						jr nz, .spnosame 
9a14						ld hl, $1efe 
9a14						pop de   ; $1efe 
9a14						call cmp16 
9a14						jr z, .spfrsame 
9a14						.spnosame: call showsperror 
9a14						.spfrsame: nop 
9a14						exx 
9a14					endif 
9a14				endif 
9a14			endm 
# End of macro STACKFRAMECHK
9a14			 
9a14			execnext: 
9a14			 
9a14			if DEBUG_FORTH_PARSE_KEY 
9a14						DMARK "KY>" 
9a14			endif 
9a14			; move past token to next word 
9a14			 
9a14 2a 76 e6		ld hl, (os_tok_ptr) 
9a17 3e 00		ld a, 0 
9a19 01 ff 00		ld bc, 255     ; input buffer size 
9a1c ed b1		cpir 
9a1e			 
9a1e			if DEBUG_FORTH_PARSE_KEY 
9a1e						DMARK "KY!" 
9a1e				CALLMONITOR 
9a1e			endif	 
9a1e			; TODO this might place hl on the null, so will need to forward on??? 
9a1e			;inc hl   ; see if this gets onto the next item 
9a1e			 
9a1e			 
9a1e			; TODO pass a pointer to the buffer to push 
9a1e			; TODO call function to push 
9a1e			 
9a1e			; look for end of input 
9a1e			 
9a1e			;inc hl 
9a1e			;ld a,(hl) 
9a1e			;cp FORTH_END_BUFFER 
9a1e			;ret z 
9a1e			 
9a1e			 
9a1e c3 97 99		jp exec1 
9a21			 
9a21			 
9a21			 
9a21			 
9a21			 
9a21			 
9a21			 
9a21			 
9a21			 
9a21			findnexttok: 
9a21			 
9a21				; hl is pointer to move 
9a21				; de is the token to locate 
9a21			 
9a21					if DEBUG_FORTH 
9a21						DMARK "NTK" 
9a21						CALLMONITOR 
9a21					endif 
9a21 d5				push de 
9a22			 
9a22			.fnt1:	 
9a22				; find first char of token to locate 
9a22			 
9a22 1a				ld a, (de) 
9a23 4f				ld c,a 
9a24 7e				ld a,(hl) 
9a25 cd 0c 8e			call toUpper 
9a28					if DEBUG_FORTH 
9a28						DMARK "NT1" 
9a28						CALLMONITOR 
9a28					endif 
9a28 b9				cp c 
9a29			 
9a29 28 03			jr z, .fnt2cmpmorefirst	 
9a2b			 
9a2b				; first char not found move to next char 
9a2b			 
9a2b 23				inc hl 
9a2c 18 f4			jr .fnt1 
9a2e			 
9a2e			.fnt2cmpmorefirst:	 
9a2e				; first char of token found.  
9a2e			 
9a2e e5				push hl     ; save start of token just in case it is the right one 
9a2f d9				exx 
9a30 e1				pop hl        ; save it to hl' 
9a31 d9				exx 
9a32			 
9a32			 
9a32			.fnt2cmpmore:	 
9a32				; compare the rest 
9a32				 
9a32 23				inc hl 
9a33 13				inc de 
9a34				 
9a34 1a				ld a, (de) 
9a35 4f				ld c,a 
9a36 7e				ld a,(hl) 
9a37 cd 0c 8e			call toUpper 
9a3a			 
9a3a					if DEBUG_FORTH 
9a3a						DMARK "NT2" 
9a3a						CALLMONITOR 
9a3a					endif 
9a3a				; c has the token to find char 
9a3a				; a has the mem to scan char 
9a3a			 
9a3a b9				cp c 
9a3b 28 04			jr z,.fntmatch1 
9a3d			 
9a3d				; they are not the same 
9a3d			 
9a3d					if DEBUG_FORTH 
9a3d						DMARK "NT3" 
9a3d						CALLMONITOR 
9a3d					endif 
9a3d d1				pop de	; reset de token to look for 
9a3e d5				push de 
9a3f 18 e1			jr .fnt1 
9a41				 
9a41			.fntmatch1: 
9a41			 
9a41				; is the same char a null which means we might have a full hit? 
9a41					if DEBUG_FORTH 
9a41						DMARK "NT4" 
9a41						CALLMONITOR 
9a41					endif 
9a41			 
9a41 fe 00			cp 0 
9a43 28 0b			jr z, .fntmatchyes 
9a45			 
9a45				; are we at the end of the token to find? 
9a45			 
9a45					if DEBUG_FORTH 
9a45						DMARK "NT5" 
9a45						CALLMONITOR 
9a45					endif 
9a45 3e 00			ld a, 0 
9a47 b9				cp c 
9a48			 
9a48 c2 32 9a			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9a4b			 
9a4b					if DEBUG_FORTH 
9a4b						DMARK "NT6" 
9a4b						CALLMONITOR 
9a4b					endif 
9a4b				; token to find is exhusted but no match to stream 
9a4b			 
9a4b				; restore tok pointer and continue on 
9a4b d1				pop de 
9a4c d5				push de 
9a4d c3 22 9a			jp .fnt1 
9a50			 
9a50			 
9a50			.fntmatchyes: 
9a50			 
9a50				; hl now contains the end of the found token 
9a50			 
9a50				; get rid of saved token pointer to find 
9a50			 
9a50 d1				pop de 
9a51			 
9a51					if DEBUG_FORTH 
9a51						DMARK "NT9" 
9a51						CALLMONITOR 
9a51					endif 
9a51			 
9a51				; hl will be on the null term so forward on 
9a51			 
9a51				; get back the saved start of the token 
9a51			 
9a51 d9				exx 
9a52 e5				push hl     ; save start of token just in case it is the right one 
9a53 d9				exx 
9a54 e1				pop hl        ; save it to hl 
9a55			 
9a55 c9				ret 
9a56			 
9a56			 
9a56			; LIST needs to find a specific token   
9a56			; FORGET needs to find a spefici token 
9a56			 
9a56			; SAVE needs to find all tokens by flag 
9a56			; WORDS just needs to scan through all  by flag 
9a56			; UWORDS needs to scan through all by flag 
9a56			 
9a56			 
9a56			; given hl as pointer to start of dict look up string 
9a56			; return hl as pointer to start of word block 
9a56			; or 0 if not found 
9a56			 
9a56			forth_find_tok: 
9a56 c9				ret 
9a57			 
9a57			; given hl as pointer to dict structure 
9a57			; move to the next dict block structure 
9a57			 
9a57			forth_tok_next: 
9a57				; hl now points to the address of the next word pointer  
9a57				; TODO skip compiled symbol for now 
9a57			;	push de 
9a57 23				inc hl 
9a58 5e				ld e, (hl) 
9a59 23				inc hl 
9a5a 56				ld d, (hl) 
9a5b 23				inc hl 
9a5c			 
9a5c eb				ex de,hl 
9a5d			if DEBUG_FORTH_PARSE_NEXTWORD 
9a5d				push bc 
9a5d				ld bc, (cli_nextword) 
9a5d						DMARK "NXW" 
9a5d				CALLMONITOR 
9a5d				pop bc 
9a5d			endif 
9a5d			;	pop de	 
9a5d c9				ret 
9a5e			 
9a5e			 
9a5e			 
9a5e			; eof 
# End of file forth_parserv5.asm
9a5e				include "forth_wordsv4.asm" 
9a5e			 
9a5e			; the core word dictionary v4 
9a5e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9a5e			 
9a5e			; this is a linked list for each of the system words used 
9a5e			; user defined words will follow the same format but will be in ram 
9a5e			 
9a5e			 
9a5e			; 
9a5e			; 
9a5e			; define linked list: 
9a5e			; 
9a5e			; 1. compiled byte op code 
9a5e			; 2. len of text word 
9a5e			; 3. text word 
9a5e			; 4. ptr to next dictionary word 
9a5e			; 5. asm, calls etc for the word 
9a5e			; 
9a5e			;  if 1 == 0 then last word in dict  
9a5e			;   
9a5e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9a5e			;  
9a5e			;  
9a5e			; create basic standard set of words 
9a5e			; 
9a5e			;  
9a5e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9a5e			; 2DUP 2DROP 2SWAP  
9a5e			; @ C@ - get byte  
9a5e			; ! C! - store byte 
9a5e			; 0< true if less than zero 
9a5e			; 0= true if zero 
9a5e			; < >  
9a5e			; = true if same 
9a5e			; variables 
9a5e			 
9a5e			 
9a5e			; Hardware specific words I may need 
9a5e			; 
9a5e			; IN OUT  
9a5e			; calls to key util functions 
9a5e			; calls to hardward abstraction stuff 
9a5e			; easy control of frame buffers and lcd i/o 
9a5e			; keyboard  
9a5e			 
9a5e			 
9a5e			;DICT: macro 
9a5e			; op_code, len, word, next 
9a5e			;    word: 
9a5e			;    db op_code 
9a5e			;    ds word zero term 
9a5e			;    dw next 
9a5e			;    endm 
9a5e			 
9a5e			 
9a5e			 
9a5e			 
9a5e			; op code 1 is a flag for user define words which are to be handled differently 
9a5e			 
9a5e			 
9a5e			; 
9a5e			; 
9a5e			;    TODO on entry to a word this should be the expected environment 
9a5e			;    hl - tos value if number then held, if string this is the ptr 
9a5e			;    de -  
9a5e			 
9a5e			 
9a5e			; opcode ranges 
9a5e			; 0 - end of word dict 
9a5e			; 255 - user define words 
9a5e			 
9a5e			sysdict: 
9a5e			include "forth_opcodes.asm" 
9a5e			; op codes for forth keywords 
9a5e			; free to use code 0  
9a5e				OPCODE_HEAP: equ  1 
9a5e				OPCODE_EXEC: equ 2 
9a5e				OPCODE_DUP: equ 3 
9a5e				OPCODE_SWAP: equ 4 
9a5e				OPCODE_COLN: equ 5 
9a5e				OPCODE_SCOLN: equ 6 
9a5e				OPCODE_DROP: equ 7 
9a5e				OPCODE_DUP2: equ 8 
9a5e				OPCODE_DROP2: equ 9 
9a5e				OPCODE_SWAP2: equ 10 
9a5e				OPCODE_AT: equ 11 
9a5e				OPCODE_CAT: equ 12 
9a5e				OPCODE_BANG: equ 13 
9a5e				OPCODE_CBANG: equ 14 
9a5e				OPCODE_SCALL: equ 15 
9a5e				OPCODE_DEPTH: equ 16 
9a5e				OPCODE_OVER: equ 17 
9a5e				OPCODE_PAUSE: equ 18 
9a5e				OPCODE_PAUSES: equ 19 
9a5e				OPCODE_ROT: equ 20 
9a5e			;free to reuse	OPCODE_WORDS: equ 21 
9a5e			        OPCODE_NOT: equ 21 
9a5e				OPCODE_UWORDS: equ 22 
9a5e				OPCODE_BP: equ 23 
9a5e				OPCODE_MONITOR: equ 24  
9a5e				OPCODE_MALLOC: equ 25 
9a5e				OPCODE_FREE: equ 26 
9a5e				OPCODE_LIST: equ 27 
9a5e				OPCODE_FORGET: equ 28 
9a5e				OPCODE_NOP: equ 29 
9a5e				OPCODE_COMO: equ 30 
9a5e				OPCODE_COMC: equ 31 
9a5e			;free to reuse	OPCODE_ENDCORE: equ 32 
9a5e				OPCODE_AFTERSOUND: equ 33 
9a5e				OPCODE_GP2: equ 34 
9a5e				OPCODE_GP3: equ 35 
9a5e				OPCODE_GP4: equ 36 
9a5e				OPCODE_SIN: equ 37 
9a5e				OPCODE_SOUT: equ 38 
9a5e				OPCODE_SPIO: equ 39 
9a5e				OPCODE_SPICEH: equ 40 
9a5e				OPCODE_SPIOb: equ 41 
9a5e				OPCODE_SPII: equ 42 
9a5e				OPCODE_SESEL: equ 43 
9a5e				OPCODE_CARTDEV: equ 44 
9a5e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9a5e				OPCODE_FB: equ 46 
9a5e				OPCODE_EMIT: equ 47 
9a5e				OPCODE_DOTH: equ 48 
9a5e				OPCODE_DOTF: equ 49 
9a5e				OPCODE_DOT: equ 50 
9a5e				OPCODE_CLS: equ 51 
9a5e				OPCODE_DRAW: equ 52 
9a5e				OPCODE_DUMP: equ 53 
9a5e				OPCODE_CDUMP: equ 54 
9a5e				OPCODE_DAT: equ 55 
9a5e				OPCODE_HOME: equ 56 
9a5e				OPCODE_SPACE: equ 57 
9a5e				OPCODE_SPACES: equ 58 
9a5e				OPCODE_SCROLL: equ 59 
9a5e				OPCODE_ATQ: equ 60 
9a5e				OPCODE_AUTODSP: equ 61 
9a5e				OPCODE_MENU: equ 62 
9a5e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9a5e				OPCODE_THEN: equ 64 
9a5e				OPCODE_ELSE: equ 65 
9a5e				OPCODE_DO: equ 66 
9a5e				OPCODE_LOOP: equ 67 
9a5e				OPCODE_I: equ 68 
9a5e				OPCODE_DLOOP: equ 69  
9a5e				OPCODE_REPEAT: equ 70  
9a5e				OPCODE_UNTIL: equ 71 
9a5e				OPCODE_ENDFLOW: equ 72 
9a5e				OPCODE_WAITK: equ 73 
9a5e				OPCODE_ACCEPT: equ 74 
9a5e				OPCODE_EDIT: equ 75 
9a5e			;free to reuse	OPCODE_ENDKEY: equ 76 
9a5e				OPCODE_LZERO: equ 77 
9a5e				OPCODE_TZERO: equ 78 
9a5e				OPCODE_LESS: equ 79 
9a5e				OPCODE_GT: equ 80 
9a5e				OPCODE_EQUAL: equ 81  
9a5e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9a5e				OPCODE_NEG: equ 83 
9a5e				OPCODE_DIV: equ 84 
9a5e				OPCODE_MUL: equ 85 
9a5e				OPCODE_MIN: equ 86 
9a5e				OPCODE_MAX: equ 87 
9a5e				OPCODE_RND16: equ 88 
9a5e				OPCODE_RND8: equ 89 
9a5e				OPCODE_RND: equ 90 
9a5e			;free to reuse	OPCODE_ENDMATHS: equ 91  
9a5e				OPCODE_BYNAME: equ 92 
9a5e				OPCODE_DIR: equ 93 
9a5e				OPCODE_SAVE: equ 94 
9a5e				OPCODE_LOAD: equ 95 
9a5e				OPCODE_BSAVE: equ 96 
9a5e				OPCODE_BLOAD: equ 97 
9a5e				OPCODE_SEO: equ 98  
9a5e				OPCODE_SEI: equ 99 
9a5e				OPCODE_SFREE: equ 100 
9a5e				OPCODE_SIZE: equ 101 
9a5e				OPCODE_CREATE: equ 102 
9a5e				OPCODE_APPEND: equ 103 
9a5e				OPCODE_SDEL: equ 104 
9a5e				OPCODE_OPEN: equ 105 
9a5e				OPCODE_READ: equ 106 
9a5e				OPCODE_EOF: equ 106 
9a5e				OPCODE_FORMAT: equ 107 
9a5e				OPCODE_LABEL: equ 108 
9a5e				OPCODE_LABELS: equ 109 
9a5e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9a5e				OPCODE_UPPER: equ 111 
9a5e				OPCODE_LOWER: equ 112 
9a5e				OPCODE_SUBSTR: equ 113 
9a5e				OPCODE_LEFT: equ 114 
9a5e				OPCODE_RIGHT: equ 115 
9a5e				OPCODE_STR2NUM: equ 116 
9a5e				OPCODE_NUM2STR: equ 117 
9a5e				OPCODE_CONCAT: equ 118 
9a5e				OPCODE_FIND: equ 119 
9a5e				OPCODE_LEN: equ 120 
9a5e				OPCODE_CHAR: equ 121 
9a5e			; free to reuse	OPCODE_STRLEN: equ 122 
9a5e			; free to reuse	OPCODE_ENDSTR: equ 123 
9a5e				OPCODE_V0S: equ 124 
9a5e				OPCODE_V0Q: equ 125 
9a5e				OPCODE_V1S: equ 126 
9a5e				OPCODE_V1Q: equ 127 
9a5e				OPCODE_V2S: equ 128 
9a5e				OPCODE_V2Q: equ 129 
9a5e				OPCODE_V3S: equ 130 
9a5e				OPCODE_V3Q: equ 131 
9a5e			;free to reuse	OPCODE_END: equ 132 
9a5e				OPCODE_ZDUP: equ 133 
9a5e			 
9a5e			; eof 
# End of file forth_opcodes.asm
9a5e			 
9a5e			include "forth_words_core.asm" 
9a5e			 
9a5e			; | ## Core Words 
9a5e			 
9a5e			;if MALLOC_4 
9a5e			 
9a5e			.HEAP: 
9a5e				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9a5e 15				db WORD_SYS_CORE+OPCODE_HEAP             
9a5f 9d 9a			dw .EXEC            
9a61 05				db 4 + 1 
9a62 .. 00			db "HEAP",0              
9a67				endm 
# End of macro CWHEAD
9a67			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9a67			; | | u1 - Current number of bytes in the heap 
9a67			; | | u2 - Remaining bytes left on the heap 
9a67			; | |  
9a67			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9a67			 
9a67			 
9a67					if DEBUG_FORTH_WORDS_KEY 
9a67						DMARK "HEP" 
9a67 f5				push af  
9a68 3a 7c 9a			ld a, (.dmark)  
9a6b 32 7a ee			ld (debug_mark),a  
9a6e 3a 7d 9a			ld a, (.dmark+1)  
9a71 32 7b ee			ld (debug_mark+1),a  
9a74 3a 7e 9a			ld a, (.dmark+2)  
9a77 32 7c ee			ld (debug_mark+2),a  
9a7a 18 03			jr .pastdmark  
9a7c ..			.dmark: db "HEP"  
9a7f f1			.pastdmark: pop af  
9a80			endm  
# End of macro DMARK
9a80						CALLMONITOR 
9a80 cd 7b 91			call break_point_state  
9a83				endm  
# End of macro CALLMONITOR
9a83					endif 
9a83 2a be d4				ld hl, (free_list )      
9a86 11 c3 d4				ld de, heap_start 
9a89			 
9a89 ed 52				sbc hl, de  
9a8b			 
9a8b cd 15 97				call forth_push_numhl 
9a8e			 
9a8e			 
9a8e ed 5b be d4			ld de, (free_list )      
9a92 21 69 e3				ld hl, heap_end 
9a95			 
9a95 ed 52				sbc hl, de 
9a97			 
9a97 cd 15 97				call forth_push_numhl 
9a9a					 
9a9a			 
9a9a					 
9a9a			 
9a9a			 
9a9a			 
9a9a					NEXTW 
9a9a c3 06 99			jp macro_next 
9a9d				endm 
# End of macro NEXTW
9a9d			;endif 
9a9d			 
9a9d			.EXEC: 
9a9d				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9a9d 16				db WORD_SYS_CORE+OPCODE_EXEC             
9a9e 39 9b			dw .STKEXEC            
9aa0 05				db 4 + 1 
9aa1 .. 00			db "EXEC",0              
9aa6				endm 
# End of macro CWHEAD
9aa6			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
9aa6			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9aa6			; | | 
9aa6			; | |   
9aa6				STACKFRAME OFF $5efe $5f9f 
9aa6				if DEBUG_STACK_IMB 
9aa6					if OFF 
9aa6						exx 
9aa6						ld de, $5efe 
9aa6						ld a, d 
9aa6						ld hl, curframe 
9aa6						call hexout 
9aa6						ld a, e 
9aa6						ld hl, curframe+2 
9aa6						call hexout 
9aa6						ld hl, $5efe 
9aa6						push hl 
9aa6						ld hl, $5f9f 
9aa6						push hl 
9aa6						exx 
9aa6					endif 
9aa6				endif 
9aa6			endm 
# End of macro STACKFRAME
9aa6			 
9aa6					if DEBUG_FORTH_WORDS_KEY 
9aa6						DMARK "EXE" 
9aa6 f5				push af  
9aa7 3a bb 9a			ld a, (.dmark)  
9aaa 32 7a ee			ld (debug_mark),a  
9aad 3a bc 9a			ld a, (.dmark+1)  
9ab0 32 7b ee			ld (debug_mark+1),a  
9ab3 3a bd 9a			ld a, (.dmark+2)  
9ab6 32 7c ee			ld (debug_mark+2),a  
9ab9 18 03			jr .pastdmark  
9abb ..			.dmark: db "EXE"  
9abe f1			.pastdmark: pop af  
9abf			endm  
# End of macro DMARK
9abf						CALLMONITOR 
9abf cd 7b 91			call break_point_state  
9ac2				endm  
# End of macro CALLMONITOR
9ac2					endif 
9ac2			 
9ac2				FORTH_DSP_VALUEHL 
9ac2 cd b0 97			call macro_dsp_valuehl 
9ac5				endm 
# End of macro FORTH_DSP_VALUEHL
9ac5			 
9ac5				FORTH_DSP_POP 
9ac5 cd 4c 98			call macro_forth_dsp_pop 
9ac8				endm 
# End of macro FORTH_DSP_POP
9ac8			 
9ac8					if DEBUG_FORTH_WORDS 
9ac8						DMARK "EX1" 
9ac8 f5				push af  
9ac9 3a dd 9a			ld a, (.dmark)  
9acc 32 7a ee			ld (debug_mark),a  
9acf 3a de 9a			ld a, (.dmark+1)  
9ad2 32 7b ee			ld (debug_mark+1),a  
9ad5 3a df 9a			ld a, (.dmark+2)  
9ad8 32 7c ee			ld (debug_mark+2),a  
9adb 18 03			jr .pastdmark  
9add ..			.dmark: db "EX1"  
9ae0 f1			.pastdmark: pop af  
9ae1			endm  
# End of macro DMARK
9ae1						CALLMONITOR 
9ae1 cd 7b 91			call break_point_state  
9ae4				endm  
# End of macro CALLMONITOR
9ae4					endif 
9ae4			;	ld e,(hl) 
9ae4			;	inc hl 
9ae4			;	ld d,(hl) 
9ae4			;	ex de,hl 
9ae4			 
9ae4			;		if DEBUG_FORTH_WORDS 
9ae4			;			DMARK "EX2" 
9ae4			;			CALLMONITOR 
9ae4			;		endif 
9ae4 e5				push hl 
9ae5			 
9ae5				;ld a, 0 
9ae5				;ld a, FORTH_END_BUFFER 
9ae5 cd 15 8e			call strlenz 
9ae8 23				inc hl   ; include zero term to copy 
9ae9 23				inc hl   ; include term 
9aea 23				inc hl   ; include term 
9aeb 06 00			ld b,0 
9aed 4d				ld c,l 
9aee e1				pop hl 
9aef 11 74 e4			ld de, execscratch 
9af2					if DEBUG_FORTH_WORDS 
9af2						DMARK "EX3" 
9af2 f5				push af  
9af3 3a 07 9b			ld a, (.dmark)  
9af6 32 7a ee			ld (debug_mark),a  
9af9 3a 08 9b			ld a, (.dmark+1)  
9afc 32 7b ee			ld (debug_mark+1),a  
9aff 3a 09 9b			ld a, (.dmark+2)  
9b02 32 7c ee			ld (debug_mark+2),a  
9b05 18 03			jr .pastdmark  
9b07 ..			.dmark: db "EX3"  
9b0a f1			.pastdmark: pop af  
9b0b			endm  
# End of macro DMARK
9b0b						CALLMONITOR 
9b0b cd 7b 91			call break_point_state  
9b0e				endm  
# End of macro CALLMONITOR
9b0e					endif 
9b0e ed b0			ldir 
9b10			 
9b10			 
9b10 21 74 e4			ld hl, execscratch 
9b13			 
9b13					if DEBUG_FORTH_WORDS 
9b13						DMARK "EXe" 
9b13 f5				push af  
9b14 3a 28 9b			ld a, (.dmark)  
9b17 32 7a ee			ld (debug_mark),a  
9b1a 3a 29 9b			ld a, (.dmark+1)  
9b1d 32 7b ee			ld (debug_mark+1),a  
9b20 3a 2a 9b			ld a, (.dmark+2)  
9b23 32 7c ee			ld (debug_mark+2),a  
9b26 18 03			jr .pastdmark  
9b28 ..			.dmark: db "EXe"  
9b2b f1			.pastdmark: pop af  
9b2c			endm  
# End of macro DMARK
9b2c						CALLMONITOR 
9b2c cd 7b 91			call break_point_state  
9b2f				endm  
# End of macro CALLMONITOR
9b2f					endif 
9b2f			 
9b2f cd 54 99			call forthparse 
9b32 cd 94 99			call forthexec 
9b35			;	call forthexec_cleanup 
9b35			;	call forthparse 
9b35			;	call forthexec 
9b35			 
9b35				STACKFRAMECHK OFF $5efe $5f9f 
9b35				if DEBUG_STACK_IMB 
9b35					if OFF 
9b35						exx 
9b35						ld hl, $5f9f 
9b35						pop de   ; $5f9f 
9b35						call cmp16 
9b35						jr nz, .spnosame 
9b35						ld hl, $5efe 
9b35						pop de   ; $5efe 
9b35						call cmp16 
9b35						jr z, .spfrsame 
9b35						.spnosame: call showsperror 
9b35						.spfrsame: nop 
9b35						exx 
9b35					endif 
9b35				endif 
9b35			endm 
# End of macro STACKFRAMECHK
9b35			 
9b35				; an immediate word so no need to process any more words 
9b35 c9				ret 
9b36				NEXTW 
9b36 c3 06 99			jp macro_next 
9b39				endm 
# End of macro NEXTW
9b39			 
9b39			; dead code - old version  
9b39			;	FORTH_RSP_NEXT 
9b39			 
9b39			;  
9b39			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9b39			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9b39			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9b39			;	push hl 
9b39			;	push de 
9b39			;	push bc 
9b39			; 
9b39			; 
9b39			;		if DEBUG_FORTH_WORDS_KEY 
9b39			;			DMARK "EXR" 
9b39			;			CALLMONITOR 
9b39			;		endif 
9b39			; 
9b39			; 
9b39			; 
9b39			;	;v5 FORTH_DSP_VALUE 
9b39			;	FORTH_DSP_VALUEHL 
9b39			; 
9b39			;	; TODO do string type checks 
9b39			; 
9b39			;;v5	inc hl   ; skip type 
9b39			; 
9b39			;	push hl  ; source code  
9b39			;		if DEBUG_FORTH_WORDS 
9b39			;			DMARK "EX1" 
9b39			;			CALLMONITOR 
9b39			;		endif 
9b39			;	ld a, 0 
9b39			;	call strlent 
9b39			; 
9b39			;	inc hl 
9b39			;	inc hl 
9b39			;	inc hl 
9b39			;	inc hl 
9b39			; 
9b39			;	push hl    ; size 
9b39			; 
9b39			;		if DEBUG_FORTH_WORDS 
9b39			;			DMARK "EX2" 
9b39			;			CALLMONITOR 
9b39			;		endif 
9b39			;	call malloc 
9b39			; 
9b39			;	ex de, hl    ; de now contains malloc area 
9b39			;	pop bc   	; get byte count 
9b39			;	pop hl      ; get string to copy 
9b39			; 
9b39			;	push de     ; save malloc for free later 
9b39			; 
9b39			;		if DEBUG_FORTH_WORDS 
9b39			;			DMARK "EX3" 
9b39			;			CALLMONITOR 
9b39			;		endif 
9b39			;	ldir       ; duplicate string 
9b39			; 
9b39			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9b39			;	 
9b39			;	; TODO fix the parse would be better than this...  
9b39			;	ex de, hl 
9b39			;	dec hl 
9b39			;	ld a, 0 
9b39			;	ld (hl), a 
9b39			;	dec hl 
9b39			;	ld a, ' ' 
9b39			;	ld (hl), a 
9b39			;	dec hl 
9b39			;	ld (hl), a 
9b39			; 
9b39			;	dec hl 
9b39			;	ld (hl), a 
9b39			; 
9b39			; 
9b39			;	FORTH_DSP_POP  
9b39			; 
9b39			;	pop hl     
9b39			;	push hl    ; save malloc area 
9b39			; 
9b39			;		if DEBUG_FORTH_WORDS 
9b39			;			DMARK "EX4" 
9b39			;			CALLMONITOR 
9b39			;		endif 
9b39			; 
9b39			;	call forthparse 
9b39			;	call forthexec 
9b39			;	 
9b39			;	pop hl 
9b39			;	if DEBUG_FORTH_WORDS 
9b39			;		DMARK "EX5" 
9b39			;		CALLMONITOR 
9b39			;	endif 
9b39			; 
9b39			;	if FORTH_ENABLE_FREE 
9b39			;	call free 
9b39			;	endif 
9b39			; 
9b39			;	if DEBUG_FORTH_WORDS 
9b39			;		DMARK "EX6" 
9b39			;		CALLMONITOR 
9b39			;	endif 
9b39			; 
9b39			;	pop bc 
9b39			;	pop de 
9b39			;	pop hl 
9b39			;;	FORTH_RSP_POP	  
9b39			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9b39			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9b39			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9b39			; 
9b39			;	if DEBUG_FORTH_WORDS 
9b39			;		DMARK "EX7" 
9b39			;		CALLMONITOR 
9b39			;	endif 
9b39			;	NEXTW 
9b39			 
9b39			.STKEXEC: 
9b39				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9b39 3f				db WORD_SYS_CORE+43             
9b3a 81 9c			dw .ZDUP            
9b3c 08				db 7 + 1 
9b3d .. 00			db "STKEXEC",0              
9b45				endm 
# End of macro CWHEAD
9b45			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
9b45			 
9b45			 
9b45					if DEBUG_FORTH_WORDS_KEY 
9b45						DMARK "STX" 
9b45 f5				push af  
9b46 3a 5a 9b			ld a, (.dmark)  
9b49 32 7a ee			ld (debug_mark),a  
9b4c 3a 5b 9b			ld a, (.dmark+1)  
9b4f 32 7b ee			ld (debug_mark+1),a  
9b52 3a 5c 9b			ld a, (.dmark+2)  
9b55 32 7c ee			ld (debug_mark+2),a  
9b58 18 03			jr .pastdmark  
9b5a ..			.dmark: db "STX"  
9b5d f1			.pastdmark: pop af  
9b5e			endm  
# End of macro DMARK
9b5e						CALLMONITOR 
9b5e cd 7b 91			call break_point_state  
9b61				endm  
# End of macro CALLMONITOR
9b61					endif 
9b61			 
9b61				FORTH_DSP_VALUEHL 
9b61 cd b0 97			call macro_dsp_valuehl 
9b64				endm 
# End of macro FORTH_DSP_VALUEHL
9b64			 
9b64 22 63 eb			ld (store_tmp1), hl    ; count 
9b67			 
9b67				FORTH_DSP_POP 
9b67 cd 4c 98			call macro_forth_dsp_pop 
9b6a				endm 
# End of macro FORTH_DSP_POP
9b6a			.stkexec1: 
9b6a 2a 63 eb			ld hl, (store_tmp1)   ; count 
9b6d 3e 00			ld a, 0 
9b6f bd				cp l 
9b70 c8				ret z 
9b71			 
9b71 2b				dec hl 
9b72 22 63 eb			ld (store_tmp1), hl    ; count 
9b75				 
9b75				FORTH_DSP_VALUEHL 
9b75 cd b0 97			call macro_dsp_valuehl 
9b78				endm 
# End of macro FORTH_DSP_VALUEHL
9b78 e5				push hl 
9b79				 
9b79					if DEBUG_FORTH_WORDS 
9b79						DMARK "EXp" 
9b79 f5				push af  
9b7a 3a 8e 9b			ld a, (.dmark)  
9b7d 32 7a ee			ld (debug_mark),a  
9b80 3a 8f 9b			ld a, (.dmark+1)  
9b83 32 7b ee			ld (debug_mark+1),a  
9b86 3a 90 9b			ld a, (.dmark+2)  
9b89 32 7c ee			ld (debug_mark+2),a  
9b8c 18 03			jr .pastdmark  
9b8e ..			.dmark: db "EXp"  
9b91 f1			.pastdmark: pop af  
9b92			endm  
# End of macro DMARK
9b92						CALLMONITOR 
9b92 cd 7b 91			call break_point_state  
9b95				endm  
# End of macro CALLMONITOR
9b95					endif 
9b95				FORTH_DSP_POP 
9b95 cd 4c 98			call macro_forth_dsp_pop 
9b98				endm 
# End of macro FORTH_DSP_POP
9b98			 
9b98 cd 15 8e			call strlenz 
9b9b 23				inc hl   ; include zero term to copy 
9b9c 23				inc hl   ; include zero term to copy 
9b9d 23				inc hl   ; include zero term to copy 
9b9e 06 00			ld b,0 
9ba0 4d				ld c,l 
9ba1 e1				pop hl 
9ba2 11 74 e4			ld de, execscratch 
9ba5					if DEBUG_FORTH_WORDS 
9ba5						DMARK "EX3" 
9ba5 f5				push af  
9ba6 3a ba 9b			ld a, (.dmark)  
9ba9 32 7a ee			ld (debug_mark),a  
9bac 3a bb 9b			ld a, (.dmark+1)  
9baf 32 7b ee			ld (debug_mark+1),a  
9bb2 3a bc 9b			ld a, (.dmark+2)  
9bb5 32 7c ee			ld (debug_mark+2),a  
9bb8 18 03			jr .pastdmark  
9bba ..			.dmark: db "EX3"  
9bbd f1			.pastdmark: pop af  
9bbe			endm  
# End of macro DMARK
9bbe						CALLMONITOR 
9bbe cd 7b 91			call break_point_state  
9bc1				endm  
# End of macro CALLMONITOR
9bc1					endif 
9bc1 ed b0			ldir 
9bc3			 
9bc3			 
9bc3 21 74 e4			ld hl, execscratch 
9bc6			 
9bc6					if DEBUG_FORTH_WORDS 
9bc6						DMARK "EXP" 
9bc6 f5				push af  
9bc7 3a db 9b			ld a, (.dmark)  
9bca 32 7a ee			ld (debug_mark),a  
9bcd 3a dc 9b			ld a, (.dmark+1)  
9bd0 32 7b ee			ld (debug_mark+1),a  
9bd3 3a dd 9b			ld a, (.dmark+2)  
9bd6 32 7c ee			ld (debug_mark+2),a  
9bd9 18 03			jr .pastdmark  
9bdb ..			.dmark: db "EXP"  
9bde f1			.pastdmark: pop af  
9bdf			endm  
# End of macro DMARK
9bdf						CALLMONITOR 
9bdf cd 7b 91			call break_point_state  
9be2				endm  
# End of macro CALLMONITOR
9be2					endif 
9be2			 
9be2 cd 54 99			call forthparse 
9be5 21 74 e4			ld hl, execscratch 
9be8					if DEBUG_FORTH_WORDS 
9be8						DMARK "EXx" 
9be8 f5				push af  
9be9 3a fd 9b			ld a, (.dmark)  
9bec 32 7a ee			ld (debug_mark),a  
9bef 3a fe 9b			ld a, (.dmark+1)  
9bf2 32 7b ee			ld (debug_mark+1),a  
9bf5 3a ff 9b			ld a, (.dmark+2)  
9bf8 32 7c ee			ld (debug_mark+2),a  
9bfb 18 03			jr .pastdmark  
9bfd ..			.dmark: db "EXx"  
9c00 f1			.pastdmark: pop af  
9c01			endm  
# End of macro DMARK
9c01						CALLMONITOR 
9c01 cd 7b 91			call break_point_state  
9c04				endm  
# End of macro CALLMONITOR
9c04					endif 
9c04 cd 94 99			call forthexec 
9c07			 
9c07 c3 6a 9b			jp .stkexec1 
9c0a			 
9c0a c9				ret 
9c0b			 
9c0b			 
9c0b			.DUP: 
9c0b				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9c0b 17				db WORD_SYS_CORE+OPCODE_DUP             
9c0c 81 9c			dw .ZDUP            
9c0e 04				db 3 + 1 
9c0f .. 00			db "DUP",0              
9c13				endm 
# End of macro CWHEAD
9c13			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9c13			 
9c13					if DEBUG_FORTH_WORDS_KEY 
9c13						DMARK "DUP" 
9c13 f5				push af  
9c14 3a 28 9c			ld a, (.dmark)  
9c17 32 7a ee			ld (debug_mark),a  
9c1a 3a 29 9c			ld a, (.dmark+1)  
9c1d 32 7b ee			ld (debug_mark+1),a  
9c20 3a 2a 9c			ld a, (.dmark+2)  
9c23 32 7c ee			ld (debug_mark+2),a  
9c26 18 03			jr .pastdmark  
9c28 ..			.dmark: db "DUP"  
9c2b f1			.pastdmark: pop af  
9c2c			endm  
# End of macro DMARK
9c2c						CALLMONITOR 
9c2c cd 7b 91			call break_point_state  
9c2f				endm  
# End of macro CALLMONITOR
9c2f					endif 
9c2f			 
9c2f					FORTH_DSP 
9c2f cd 95 97			call macro_forth_dsp 
9c32				endm 
# End of macro FORTH_DSP
9c32			 
9c32 7e					ld a, (HL) 
9c33 fe 01				cp DS_TYPE_STR 
9c35 20 25				jr nz, .dupinum 
9c37			 
9c37					; push another string 
9c37			 
9c37					FORTH_DSP_VALUEHL     		 
9c37 cd b0 97			call macro_dsp_valuehl 
9c3a				endm 
# End of macro FORTH_DSP_VALUEHL
9c3a			 
9c3a				if DEBUG_FORTH_WORDS 
9c3a					DMARK "DUs" 
9c3a f5				push af  
9c3b 3a 4f 9c			ld a, (.dmark)  
9c3e 32 7a ee			ld (debug_mark),a  
9c41 3a 50 9c			ld a, (.dmark+1)  
9c44 32 7b ee			ld (debug_mark+1),a  
9c47 3a 51 9c			ld a, (.dmark+2)  
9c4a 32 7c ee			ld (debug_mark+2),a  
9c4d 18 03			jr .pastdmark  
9c4f ..			.dmark: db "DUs"  
9c52 f1			.pastdmark: pop af  
9c53			endm  
# End of macro DMARK
9c53					CALLMONITOR 
9c53 cd 7b 91			call break_point_state  
9c56				endm  
# End of macro CALLMONITOR
9c56				endif 
9c56 cd 27 97				call forth_push_str 
9c59			 
9c59					NEXTW 
9c59 c3 06 99			jp macro_next 
9c5c				endm 
# End of macro NEXTW
9c5c			 
9c5c			 
9c5c			.dupinum: 
9c5c					 
9c5c			 
9c5c			 
9c5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9c5c cd b0 97			call macro_dsp_valuehl 
9c5f				endm 
# End of macro FORTH_DSP_VALUEHL
9c5f			 
9c5f				; TODO add floating point number detection 
9c5f			 
9c5f				if DEBUG_FORTH_WORDS 
9c5f					DMARK "DUi" 
9c5f f5				push af  
9c60 3a 74 9c			ld a, (.dmark)  
9c63 32 7a ee			ld (debug_mark),a  
9c66 3a 75 9c			ld a, (.dmark+1)  
9c69 32 7b ee			ld (debug_mark+1),a  
9c6c 3a 76 9c			ld a, (.dmark+2)  
9c6f 32 7c ee			ld (debug_mark+2),a  
9c72 18 03			jr .pastdmark  
9c74 ..			.dmark: db "DUi"  
9c77 f1			.pastdmark: pop af  
9c78			endm  
# End of macro DMARK
9c78					CALLMONITOR 
9c78 cd 7b 91			call break_point_state  
9c7b				endm  
# End of macro CALLMONITOR
9c7b				endif 
9c7b			 
9c7b cd 15 97				call forth_push_numhl 
9c7e					NEXTW 
9c7e c3 06 99			jp macro_next 
9c81				endm 
# End of macro NEXTW
9c81			.ZDUP: 
9c81				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9c81 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9c82 b9 9c			dw .SWAP            
9c84 05				db 4 + 1 
9c85 .. 00			db "?DUP",0              
9c8a				endm 
# End of macro CWHEAD
9c8a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9c8a			 
9c8a					if DEBUG_FORTH_WORDS_KEY 
9c8a						DMARK "qDU" 
9c8a f5				push af  
9c8b 3a 9f 9c			ld a, (.dmark)  
9c8e 32 7a ee			ld (debug_mark),a  
9c91 3a a0 9c			ld a, (.dmark+1)  
9c94 32 7b ee			ld (debug_mark+1),a  
9c97 3a a1 9c			ld a, (.dmark+2)  
9c9a 32 7c ee			ld (debug_mark+2),a  
9c9d 18 03			jr .pastdmark  
9c9f ..			.dmark: db "qDU"  
9ca2 f1			.pastdmark: pop af  
9ca3			endm  
# End of macro DMARK
9ca3						CALLMONITOR 
9ca3 cd 7b 91			call break_point_state  
9ca6				endm  
# End of macro CALLMONITOR
9ca6					endif 
9ca6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9ca6 cd b0 97			call macro_dsp_valuehl 
9ca9				endm 
# End of macro FORTH_DSP_VALUEHL
9ca9			 
9ca9 e5					push hl 
9caa			 
9caa					; is it a zero? 
9caa			 
9caa 3e 00				ld a, 0 
9cac 84					add h 
9cad 85					add l 
9cae			 
9cae e1					pop hl 
9caf			 
9caf fe 00				cp 0 
9cb1 28 03				jr z, .dup2orig 
9cb3			 
9cb3			 
9cb3 cd 15 97				call forth_push_numhl 
9cb6			 
9cb6			 
9cb6				; TODO add floating point number detection 
9cb6			 
9cb6			.dup2orig: 
9cb6			 
9cb6					NEXTW 
9cb6 c3 06 99			jp macro_next 
9cb9				endm 
# End of macro NEXTW
9cb9			.SWAP: 
9cb9				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9cb9 18				db WORD_SYS_CORE+OPCODE_SWAP             
9cba f8 9c			dw .COLN            
9cbc 05				db 4 + 1 
9cbd .. 00			db "SWAP",0              
9cc2				endm 
# End of macro CWHEAD
9cc2			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9cc2					if DEBUG_FORTH_WORDS_KEY 
9cc2						DMARK "SWP" 
9cc2 f5				push af  
9cc3 3a d7 9c			ld a, (.dmark)  
9cc6 32 7a ee			ld (debug_mark),a  
9cc9 3a d8 9c			ld a, (.dmark+1)  
9ccc 32 7b ee			ld (debug_mark+1),a  
9ccf 3a d9 9c			ld a, (.dmark+2)  
9cd2 32 7c ee			ld (debug_mark+2),a  
9cd5 18 03			jr .pastdmark  
9cd7 ..			.dmark: db "SWP"  
9cda f1			.pastdmark: pop af  
9cdb			endm  
# End of macro DMARK
9cdb						CALLMONITOR 
9cdb cd 7b 91			call break_point_state  
9cde				endm  
# End of macro CALLMONITOR
9cde					endif 
9cde			 
9cde					FORTH_DSP_VALUEHL 
9cde cd b0 97			call macro_dsp_valuehl 
9ce1				endm 
# End of macro FORTH_DSP_VALUEHL
9ce1 e5					push hl     ; w2 
9ce2			 
9ce2					FORTH_DSP_POP 
9ce2 cd 4c 98			call macro_forth_dsp_pop 
9ce5				endm 
# End of macro FORTH_DSP_POP
9ce5			 
9ce5					FORTH_DSP_VALUEHL 
9ce5 cd b0 97			call macro_dsp_valuehl 
9ce8				endm 
# End of macro FORTH_DSP_VALUEHL
9ce8			 
9ce8					FORTH_DSP_POP 
9ce8 cd 4c 98			call macro_forth_dsp_pop 
9ceb				endm 
# End of macro FORTH_DSP_POP
9ceb			 
9ceb d1					pop de     ; w2	, hl = w1 
9cec			 
9cec eb					ex de, hl 
9ced d5					push de 
9cee			 
9cee cd 15 97				call forth_push_numhl 
9cf1			 
9cf1 e1					pop hl 
9cf2			 
9cf2 cd 15 97				call forth_push_numhl 
9cf5					 
9cf5			 
9cf5					NEXTW 
9cf5 c3 06 99			jp macro_next 
9cf8				endm 
# End of macro NEXTW
9cf8			.COLN: 
9cf8				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9cf8 19				db WORD_SYS_CORE+OPCODE_COLN             
9cf9 84 9e			dw .SCOLN            
9cfb 02				db 1 + 1 
9cfc .. 00			db ":",0              
9cfe				endm 
# End of macro CWHEAD
9cfe			; | : ( -- )         Create new word | DONE 
9cfe			 
9cfe					if DEBUG_FORTH_WORDS_KEY 
9cfe						DMARK "CLN" 
9cfe f5				push af  
9cff 3a 13 9d			ld a, (.dmark)  
9d02 32 7a ee			ld (debug_mark),a  
9d05 3a 14 9d			ld a, (.dmark+1)  
9d08 32 7b ee			ld (debug_mark+1),a  
9d0b 3a 15 9d			ld a, (.dmark+2)  
9d0e 32 7c ee			ld (debug_mark+2),a  
9d11 18 03			jr .pastdmark  
9d13 ..			.dmark: db "CLN"  
9d16 f1			.pastdmark: pop af  
9d17			endm  
# End of macro DMARK
9d17						CALLMONITOR 
9d17 cd 7b 91			call break_point_state  
9d1a				endm  
# End of macro CALLMONITOR
9d1a					endif 
9d1a				STACKFRAME OFF $8efe $989f 
9d1a				if DEBUG_STACK_IMB 
9d1a					if OFF 
9d1a						exx 
9d1a						ld de, $8efe 
9d1a						ld a, d 
9d1a						ld hl, curframe 
9d1a						call hexout 
9d1a						ld a, e 
9d1a						ld hl, curframe+2 
9d1a						call hexout 
9d1a						ld hl, $8efe 
9d1a						push hl 
9d1a						ld hl, $989f 
9d1a						push hl 
9d1a						exx 
9d1a					endif 
9d1a				endif 
9d1a			endm 
# End of macro STACKFRAME
9d1a				; get parser buffer length  of new word 
9d1a			 
9d1a				 
9d1a			 
9d1a					; move tok past this to start of name defintition 
9d1a					; TODO get word to define 
9d1a					; TODO Move past word token 
9d1a					; TODO get length of string up to the ';' 
9d1a			 
9d1a 2a 76 e6			ld hl, (os_tok_ptr) 
9d1d 23				inc hl 
9d1e 23				inc hl 
9d1f			 
9d1f 3e 3b			ld a, ';' 
9d21 cd 20 8e			call strlent 
9d24			 
9d24 7d				ld a,l 
9d25 32 75 e5			ld (os_new_parse_len), a 
9d28			 
9d28			 
9d28			if DEBUG_FORTH_UWORD 
9d28 ed 5b 76 e6		ld de, (os_tok_ptr) 
9d2c						DMARK ":01" 
9d2c f5				push af  
9d2d 3a 41 9d			ld a, (.dmark)  
9d30 32 7a ee			ld (debug_mark),a  
9d33 3a 42 9d			ld a, (.dmark+1)  
9d36 32 7b ee			ld (debug_mark+1),a  
9d39 3a 43 9d			ld a, (.dmark+2)  
9d3c 32 7c ee			ld (debug_mark+2),a  
9d3f 18 03			jr .pastdmark  
9d41 ..			.dmark: db ":01"  
9d44 f1			.pastdmark: pop af  
9d45			endm  
# End of macro DMARK
9d45				CALLMONITOR 
9d45 cd 7b 91			call break_point_state  
9d48				endm  
# End of macro CALLMONITOR
9d48			endif 
9d48			 
9d48			; 
9d48			;  new word memory layout: 
9d48			;  
9d48			;    : adg 6666 ;  
9d48			; 
9d48			;    db   1     ; user defined word  
9d48 23				inc hl    
9d49			;    dw   sysdict 
9d49 23				inc hl 
9d4a 23				inc hl 
9d4b			;    db <word len>+1 (for null) 
9d4b 23				inc hl 
9d4c			;    db .... <word> 
9d4c			; 
9d4c			 
9d4c 23				inc hl    ; some extras for the word preamble before the above 
9d4d 23				inc hl 
9d4e 23				inc hl 
9d4f 23				inc hl 
9d50 23				inc hl 
9d51 23				inc hl 
9d52 23				inc hl  
9d53 23				inc hl 
9d54 23				inc hl 
9d55 23				inc hl 
9d56 23				inc hl 
9d57 23				inc hl 
9d58 23				inc hl 
9d59 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9d5a			;       exec word buffer 
9d5a			;	<ptr word>   
9d5a 23				inc hl 
9d5b 23				inc hl 
9d5c			;       <word list><null term> 7F final term 
9d5c			 
9d5c			 
9d5c			if DEBUG_FORTH_UWORD 
9d5c						DMARK ":02" 
9d5c f5				push af  
9d5d 3a 71 9d			ld a, (.dmark)  
9d60 32 7a ee			ld (debug_mark),a  
9d63 3a 72 9d			ld a, (.dmark+1)  
9d66 32 7b ee			ld (debug_mark+1),a  
9d69 3a 73 9d			ld a, (.dmark+2)  
9d6c 32 7c ee			ld (debug_mark+2),a  
9d6f 18 03			jr .pastdmark  
9d71 ..			.dmark: db ":02"  
9d74 f1			.pastdmark: pop af  
9d75			endm  
# End of macro DMARK
9d75				CALLMONITOR 
9d75 cd 7b 91			call break_point_state  
9d78				endm  
# End of macro CALLMONITOR
9d78			endif 
9d78			 
9d78				 
9d78					; malloc the size 
9d78			 
9d78 cd 7e 8e				call malloc 
9d7b 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
9d7e			 
9d7e			;    db   1     ; user defined word  
9d7e 3e 01				ld a, WORD_SYS_UWORD  
9d80 77					ld (hl), a 
9d81				 
9d81 23				inc hl    
9d82			;    dw   sysdict 
9d82 11 5e 9a			ld de, sysdict       ; continue on with the scan to the system dict 
9d85 73				ld (hl), e 
9d86 23				inc hl 
9d87 72				ld (hl), d 
9d88 23				inc hl 
9d89			 
9d89			 
9d89			;    Setup dict word 
9d89			 
9d89 23				inc hl 
9d8a 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
9d8d			 
9d8d				; 1. get length of dict word 
9d8d			 
9d8d			 
9d8d 2a 76 e6			ld hl, (os_tok_ptr) 
9d90 23				inc hl 
9d91 23				inc hl    ; position to start of dict word 
9d92 3e 00			ld a, 0 
9d94 cd 20 8e			call strlent 
9d97			 
9d97			 
9d97 23				inc hl    ; to include null??? 
9d98			 
9d98				; write length of dict word 
9d98			 
9d98 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9d9c 1b				dec de 
9d9d eb				ex de, hl 
9d9e 73				ld (hl), e 
9d9f eb				ex de, hl 
9da0			 
9da0				 
9da0			 
9da0				; copy  
9da0 4d				ld c, l 
9da1 06 00			ld b, 0 
9da3 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9da7 2a 76 e6			ld hl, (os_tok_ptr) 
9daa 23				inc hl 
9dab 23				inc hl    ; position to start of dict word 
9dac				 
9dac			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9dac				 
9dac				; TODO need to convert word to upper case 
9dac			 
9dac			ucasetok:	 
9dac 7e				ld a,(hl) 
9dad cd 0c 8e			call toUpper 
9db0 77				ld (hl),a 
9db1 ed a0			ldi 
9db3 f2 ac 9d		 	jp p, ucasetok 
9db6			 
9db6			 
9db6			 
9db6				; de now points to start of where the word body code should be placed 
9db6 ed 53 79 e5		ld (os_new_work_ptr), de 
9dba				; hl now points to the words to throw at forthexec which needs to be copied 
9dba 22 7b e5			ld (os_new_src_ptr), hl 
9dbd			 
9dbd				; TODO add 'call to forthexec' 
9dbd			 
9dbd			if DEBUG_FORTH_UWORD 
9dbd c5				push bc 
9dbe ed 4b 73 e5		ld bc, (os_new_malloc) 
9dc2						DMARK ":0x" 
9dc2 f5				push af  
9dc3 3a d7 9d			ld a, (.dmark)  
9dc6 32 7a ee			ld (debug_mark),a  
9dc9 3a d8 9d			ld a, (.dmark+1)  
9dcc 32 7b ee			ld (debug_mark+1),a  
9dcf 3a d9 9d			ld a, (.dmark+2)  
9dd2 32 7c ee			ld (debug_mark+2),a  
9dd5 18 03			jr .pastdmark  
9dd7 ..			.dmark: db ":0x"  
9dda f1			.pastdmark: pop af  
9ddb			endm  
# End of macro DMARK
9ddb				CALLMONITOR 
9ddb cd 7b 91			call break_point_state  
9dde				endm  
# End of macro CALLMONITOR
9dde c1				pop bc 
9ddf			endif 
9ddf			 
9ddf			 
9ddf				; create word preamble which should be: 
9ddf			 
9ddf			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9ddf			 
9ddf				;    ld hl, <word code> 
9ddf				;    jp user_exec 
9ddf			        ;    <word code bytes> 
9ddf			 
9ddf			 
9ddf			;	inc de     ; TODO ??? or are we already past the word's null 
9ddf eb				ex de, hl 
9de0			 
9de0 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9de2			 
9de2 23				inc hl 
9de3 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9de6 23				inc hl 
9de7			 
9de7 23				inc hl 
9de8 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9dea			 
9dea 01 97 c0			ld bc, user_exec 
9ded 23				inc hl 
9dee 71				ld (hl), c     ; poke address of user_exec 
9def 23				inc hl 
9df0 70				ld (hl), b     
9df1			 ; 
9df1			;	inc hl 
9df1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9df1			; 
9df1			; 
9df1			;	ld bc, macro_forth_rsp_next 
9df1			;	inc hl 
9df1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9df1			;	inc hl 
9df1			;	ld (hl), b     
9df1			 ; 
9df1			;	inc hl 
9df1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9df1			; 
9df1			; 
9df1			;	inc hl 
9df1			;	ld bc, forthexec 
9df1			;	ld (hl), c     ; poke address of forthexec 
9df1			;	inc hl 
9df1			;	ld (hl), b      
9df1			; 
9df1			;	inc hl 
9df1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9df1			; 
9df1			;	ld bc, user_dict_next 
9df1			;	inc hl 
9df1			;	ld (hl), c     ; poke address of forthexec 
9df1			;	inc hl 
9df1			;	ld (hl), b      
9df1			 
9df1				; hl is now where we need to copy the word byte data to save this 
9df1			 
9df1 23				inc hl 
9df2 22 7d e5			ld (os_new_exec), hl 
9df5				 
9df5				; copy definition 
9df5			 
9df5 eb				ex de, hl 
9df6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9df6			;	inc de    ; skip the PC for this parse 
9df6 3a 75 e5			ld a, (os_new_parse_len) 
9df9 4f				ld c, a 
9dfa 06 00			ld b, 0 
9dfc ed b0			ldir		 ; copy defintion 
9dfe			 
9dfe			 
9dfe				; poke the address of where the new word bytes live for forthexec 
9dfe			 
9dfe 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9e01			 
9e01 ed 5b 7d e5		ld de, (os_new_exec)      
9e05				 
9e05 73				ld (hl), e 
9e06 23				inc hl 
9e07 72				ld (hl), d 
9e08			 
9e08					; TODO copy last user dict word next link to this word 
9e08					; TODO update last user dict word to point to this word 
9e08			; 
9e08			; hl f923 de 812a ; bc 811a 
9e08			 
9e08			if DEBUG_FORTH_UWORD 
9e08 c5				push bc 
9e09 ed 4b 73 e5		ld bc, (os_new_malloc) 
9e0d						DMARK ":0A" 
9e0d f5				push af  
9e0e 3a 22 9e			ld a, (.dmark)  
9e11 32 7a ee			ld (debug_mark),a  
9e14 3a 23 9e			ld a, (.dmark+1)  
9e17 32 7b ee			ld (debug_mark+1),a  
9e1a 3a 24 9e			ld a, (.dmark+2)  
9e1d 32 7c ee			ld (debug_mark+2),a  
9e20 18 03			jr .pastdmark  
9e22 ..			.dmark: db ":0A"  
9e25 f1			.pastdmark: pop af  
9e26			endm  
# End of macro DMARK
9e26				CALLMONITOR 
9e26 cd 7b 91			call break_point_state  
9e29				endm  
# End of macro CALLMONITOR
9e29 c1				pop bc 
9e2a			endif 
9e2a			if DEBUG_FORTH_UWORD 
9e2a c5				push bc 
9e2b ed 4b 73 e5		ld bc, (os_new_malloc) 
9e2f 03				inc bc 
9e30 03				inc bc 
9e31 03				inc bc 
9e32 03				inc bc 
9e33 03				inc bc 
9e34 03				inc bc 
9e35 03				inc bc 
9e36 03				inc bc 
9e37			 
9e37						DMARK ":0B" 
9e37 f5				push af  
9e38 3a 4c 9e			ld a, (.dmark)  
9e3b 32 7a ee			ld (debug_mark),a  
9e3e 3a 4d 9e			ld a, (.dmark+1)  
9e41 32 7b ee			ld (debug_mark+1),a  
9e44 3a 4e 9e			ld a, (.dmark+2)  
9e47 32 7c ee			ld (debug_mark+2),a  
9e4a 18 03			jr .pastdmark  
9e4c ..			.dmark: db ":0B"  
9e4f f1			.pastdmark: pop af  
9e50			endm  
# End of macro DMARK
9e50				CALLMONITOR 
9e50 cd 7b 91			call break_point_state  
9e53				endm  
# End of macro CALLMONITOR
9e53 c1				pop bc 
9e54			endif 
9e54			 
9e54			; update word dict linked list for new word 
9e54			 
9e54			 
9e54 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
9e57 23			inc hl     ; move to next work linked list ptr 
9e58			 
9e58 ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
9e5c 73			ld (hl), e 
9e5d 23			inc hl 
9e5e 72			ld (hl), d 
9e5f			 
9e5f			if DEBUG_FORTH_UWORD 
9e5f ed 4b 72 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
9e63			endif 
9e63			 
9e63 ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
9e67			 
9e67			 
9e67			if DEBUG_FORTH_UWORD 
9e67						DMARK ":0+" 
9e67 f5				push af  
9e68 3a 7c 9e			ld a, (.dmark)  
9e6b 32 7a ee			ld (debug_mark),a  
9e6e 3a 7d 9e			ld a, (.dmark+1)  
9e71 32 7b ee			ld (debug_mark+1),a  
9e74 3a 7e 9e			ld a, (.dmark+2)  
9e77 32 7c ee			ld (debug_mark+2),a  
9e7a 18 03			jr .pastdmark  
9e7c ..			.dmark: db ":0+"  
9e7f f1			.pastdmark: pop af  
9e80			endm  
# End of macro DMARK
9e80				CALLMONITOR 
9e80 cd 7b 91			call break_point_state  
9e83				endm  
# End of macro CALLMONITOR
9e83			endif 
9e83			 
9e83				STACKFRAMECHK OFF $8efe $989f 
9e83				if DEBUG_STACK_IMB 
9e83					if OFF 
9e83						exx 
9e83						ld hl, $989f 
9e83						pop de   ; $989f 
9e83						call cmp16 
9e83						jr nz, .spnosame 
9e83						ld hl, $8efe 
9e83						pop de   ; $8efe 
9e83						call cmp16 
9e83						jr z, .spfrsame 
9e83						.spnosame: call showsperror 
9e83						.spfrsame: nop 
9e83						exx 
9e83					endif 
9e83				endif 
9e83			endm 
# End of macro STACKFRAMECHK
9e83			 
9e83 c9			ret    ; dont process any remaining parser tokens as they form new word 
9e84			 
9e84			 
9e84			 
9e84			 
9e84			;		NEXT 
9e84			.SCOLN: 
9e84			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
9e84 06				db OPCODE_SCOLN 
9e85 d0 9e			dw .DROP 
9e87 02				db 2 
9e88 .. 00			db ";",0           
9e8a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
9e8a					if DEBUG_FORTH_WORDS_KEY 
9e8a						DMARK "SCN" 
9e8a f5				push af  
9e8b 3a 9f 9e			ld a, (.dmark)  
9e8e 32 7a ee			ld (debug_mark),a  
9e91 3a a0 9e			ld a, (.dmark+1)  
9e94 32 7b ee			ld (debug_mark+1),a  
9e97 3a a1 9e			ld a, (.dmark+2)  
9e9a 32 7c ee			ld (debug_mark+2),a  
9e9d 18 03			jr .pastdmark  
9e9f ..			.dmark: db "SCN"  
9ea2 f1			.pastdmark: pop af  
9ea3			endm  
# End of macro DMARK
9ea3						CALLMONITOR 
9ea3 cd 7b 91			call break_point_state  
9ea6				endm  
# End of macro CALLMONITOR
9ea6					endif 
9ea6					FORTH_RSP_TOS 
9ea6 cd d3 96			call macro_forth_rsp_tos 
9ea9				endm 
# End of macro FORTH_RSP_TOS
9ea9 e5					push hl 
9eaa					FORTH_RSP_POP 
9eaa cd dd 96			call macro_forth_rsp_pop 
9ead				endm 
# End of macro FORTH_RSP_POP
9ead e1					pop hl 
9eae			;		ex de,hl 
9eae 22 76 e6				ld (os_tok_ptr),hl 
9eb1			 
9eb1			if DEBUG_FORTH_UWORD 
9eb1						DMARK "SCL" 
9eb1 f5				push af  
9eb2 3a c6 9e			ld a, (.dmark)  
9eb5 32 7a ee			ld (debug_mark),a  
9eb8 3a c7 9e			ld a, (.dmark+1)  
9ebb 32 7b ee			ld (debug_mark+1),a  
9ebe 3a c8 9e			ld a, (.dmark+2)  
9ec1 32 7c ee			ld (debug_mark+2),a  
9ec4 18 03			jr .pastdmark  
9ec6 ..			.dmark: db "SCL"  
9ec9 f1			.pastdmark: pop af  
9eca			endm  
# End of macro DMARK
9eca				CALLMONITOR 
9eca cd 7b 91			call break_point_state  
9ecd				endm  
# End of macro CALLMONITOR
9ecd			endif 
9ecd					NEXTW 
9ecd c3 06 99			jp macro_next 
9ed0				endm 
# End of macro NEXTW
9ed0			 
9ed0			.DROP: 
9ed0				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
9ed0 1b				db WORD_SYS_CORE+OPCODE_DROP             
9ed1 fb 9e			dw .DUP2            
9ed3 05				db 4 + 1 
9ed4 .. 00			db "DROP",0              
9ed9				endm 
# End of macro CWHEAD
9ed9			; | DROP ( w -- )   drop the TOS item   | DONE 
9ed9					if DEBUG_FORTH_WORDS_KEY 
9ed9						DMARK "DRP" 
9ed9 f5				push af  
9eda 3a ee 9e			ld a, (.dmark)  
9edd 32 7a ee			ld (debug_mark),a  
9ee0 3a ef 9e			ld a, (.dmark+1)  
9ee3 32 7b ee			ld (debug_mark+1),a  
9ee6 3a f0 9e			ld a, (.dmark+2)  
9ee9 32 7c ee			ld (debug_mark+2),a  
9eec 18 03			jr .pastdmark  
9eee ..			.dmark: db "DRP"  
9ef1 f1			.pastdmark: pop af  
9ef2			endm  
# End of macro DMARK
9ef2						CALLMONITOR 
9ef2 cd 7b 91			call break_point_state  
9ef5				endm  
# End of macro CALLMONITOR
9ef5					endif 
9ef5					FORTH_DSP_POP 
9ef5 cd 4c 98			call macro_forth_dsp_pop 
9ef8				endm 
# End of macro FORTH_DSP_POP
9ef8					NEXTW 
9ef8 c3 06 99			jp macro_next 
9efb				endm 
# End of macro NEXTW
9efb			.DUP2: 
9efb				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
9efb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
9efc 40 9f			dw .DROP2            
9efe 05				db 4 + 1 
9eff .. 00			db "2DUP",0              
9f04				endm 
# End of macro CWHEAD
9f04			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
9f04					if DEBUG_FORTH_WORDS_KEY 
9f04						DMARK "2DU" 
9f04 f5				push af  
9f05 3a 19 9f			ld a, (.dmark)  
9f08 32 7a ee			ld (debug_mark),a  
9f0b 3a 1a 9f			ld a, (.dmark+1)  
9f0e 32 7b ee			ld (debug_mark+1),a  
9f11 3a 1b 9f			ld a, (.dmark+2)  
9f14 32 7c ee			ld (debug_mark+2),a  
9f17 18 03			jr .pastdmark  
9f19 ..			.dmark: db "2DU"  
9f1c f1			.pastdmark: pop af  
9f1d			endm  
# End of macro DMARK
9f1d						CALLMONITOR 
9f1d cd 7b 91			call break_point_state  
9f20				endm  
# End of macro CALLMONITOR
9f20					endif 
9f20					FORTH_DSP_VALUEHL 
9f20 cd b0 97			call macro_dsp_valuehl 
9f23				endm 
# End of macro FORTH_DSP_VALUEHL
9f23 e5					push hl      ; 2 
9f24			 
9f24					FORTH_DSP_POP 
9f24 cd 4c 98			call macro_forth_dsp_pop 
9f27				endm 
# End of macro FORTH_DSP_POP
9f27					 
9f27					FORTH_DSP_VALUEHL 
9f27 cd b0 97			call macro_dsp_valuehl 
9f2a				endm 
# End of macro FORTH_DSP_VALUEHL
9f2a			;		push hl      ; 1 
9f2a			 
9f2a					FORTH_DSP_POP 
9f2a cd 4c 98			call macro_forth_dsp_pop 
9f2d				endm 
# End of macro FORTH_DSP_POP
9f2d			 
9f2d			;		pop hl       ; 1 
9f2d d1					pop de       ; 2 
9f2e			 
9f2e cd 15 97				call forth_push_numhl 
9f31 eb					ex de, hl 
9f32 cd 15 97				call forth_push_numhl 
9f35			 
9f35					 
9f35 eb					ex de, hl 
9f36			 
9f36 cd 15 97				call forth_push_numhl 
9f39 eb					ex de, hl 
9f3a cd 15 97				call forth_push_numhl 
9f3d			 
9f3d			 
9f3d					NEXTW 
9f3d c3 06 99			jp macro_next 
9f40				endm 
# End of macro NEXTW
9f40			.DROP2: 
9f40				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
9f40 1d				db WORD_SYS_CORE+OPCODE_DROP2             
9f41 6f 9f			dw .SWAP2            
9f43 06				db 5 + 1 
9f44 .. 00			db "2DROP",0              
9f4a				endm 
# End of macro CWHEAD
9f4a			; | 2DROP ( w w -- )    Double drop | DONE 
9f4a					if DEBUG_FORTH_WORDS_KEY 
9f4a						DMARK "2DR" 
9f4a f5				push af  
9f4b 3a 5f 9f			ld a, (.dmark)  
9f4e 32 7a ee			ld (debug_mark),a  
9f51 3a 60 9f			ld a, (.dmark+1)  
9f54 32 7b ee			ld (debug_mark+1),a  
9f57 3a 61 9f			ld a, (.dmark+2)  
9f5a 32 7c ee			ld (debug_mark+2),a  
9f5d 18 03			jr .pastdmark  
9f5f ..			.dmark: db "2DR"  
9f62 f1			.pastdmark: pop af  
9f63			endm  
# End of macro DMARK
9f63						CALLMONITOR 
9f63 cd 7b 91			call break_point_state  
9f66				endm  
# End of macro CALLMONITOR
9f66					endif 
9f66					FORTH_DSP_POP 
9f66 cd 4c 98			call macro_forth_dsp_pop 
9f69				endm 
# End of macro FORTH_DSP_POP
9f69					FORTH_DSP_POP 
9f69 cd 4c 98			call macro_forth_dsp_pop 
9f6c				endm 
# End of macro FORTH_DSP_POP
9f6c					NEXTW 
9f6c c3 06 99			jp macro_next 
9f6f				endm 
# End of macro NEXTW
9f6f			.SWAP2: 
9f6f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
9f6f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
9f70 98 9f			dw .AT            
9f72 06				db 5 + 1 
9f73 .. 00			db "2SWAP",0              
9f79				endm 
# End of macro CWHEAD
9f79			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
9f79					if DEBUG_FORTH_WORDS_KEY 
9f79						DMARK "2SW" 
9f79 f5				push af  
9f7a 3a 8e 9f			ld a, (.dmark)  
9f7d 32 7a ee			ld (debug_mark),a  
9f80 3a 8f 9f			ld a, (.dmark+1)  
9f83 32 7b ee			ld (debug_mark+1),a  
9f86 3a 90 9f			ld a, (.dmark+2)  
9f89 32 7c ee			ld (debug_mark+2),a  
9f8c 18 03			jr .pastdmark  
9f8e ..			.dmark: db "2SW"  
9f91 f1			.pastdmark: pop af  
9f92			endm  
# End of macro DMARK
9f92						CALLMONITOR 
9f92 cd 7b 91			call break_point_state  
9f95				endm  
# End of macro CALLMONITOR
9f95					endif 
9f95					NEXTW 
9f95 c3 06 99			jp macro_next 
9f98				endm 
# End of macro NEXTW
9f98			.AT: 
9f98				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
9f98 1f				db WORD_SYS_CORE+OPCODE_AT             
9f99 ca 9f			dw .CAT            
9f9b 02				db 1 + 1 
9f9c .. 00			db "@",0              
9f9e				endm 
# End of macro CWHEAD
9f9e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
9f9e			 
9f9e					if DEBUG_FORTH_WORDS_KEY 
9f9e						DMARK "AT." 
9f9e f5				push af  
9f9f 3a b3 9f			ld a, (.dmark)  
9fa2 32 7a ee			ld (debug_mark),a  
9fa5 3a b4 9f			ld a, (.dmark+1)  
9fa8 32 7b ee			ld (debug_mark+1),a  
9fab 3a b5 9f			ld a, (.dmark+2)  
9fae 32 7c ee			ld (debug_mark+2),a  
9fb1 18 03			jr .pastdmark  
9fb3 ..			.dmark: db "AT."  
9fb6 f1			.pastdmark: pop af  
9fb7			endm  
# End of macro DMARK
9fb7						CALLMONITOR 
9fb7 cd 7b 91			call break_point_state  
9fba				endm  
# End of macro CALLMONITOR
9fba					endif 
9fba			.getbyteat:	 
9fba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9fba cd b0 97			call macro_dsp_valuehl 
9fbd				endm 
# End of macro FORTH_DSP_VALUEHL
9fbd					 
9fbd			;		push hl 
9fbd				 
9fbd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9fbd cd 4c 98			call macro_forth_dsp_pop 
9fc0				endm 
# End of macro FORTH_DSP_POP
9fc0			 
9fc0			;		pop hl 
9fc0			 
9fc0 7e					ld a, (hl) 
9fc1			 
9fc1 6f					ld l, a 
9fc2 26 00				ld h, 0 
9fc4 cd 15 97				call forth_push_numhl 
9fc7			 
9fc7					NEXTW 
9fc7 c3 06 99			jp macro_next 
9fca				endm 
# End of macro NEXTW
9fca			.CAT: 
9fca				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
9fca 20				db WORD_SYS_CORE+OPCODE_CAT             
9fcb f3 9f			dw .BANG            
9fcd 03				db 2 + 1 
9fce .. 00			db "C@",0              
9fd1				endm 
# End of macro CWHEAD
9fd1			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
9fd1					if DEBUG_FORTH_WORDS_KEY 
9fd1						DMARK "CAA" 
9fd1 f5				push af  
9fd2 3a e6 9f			ld a, (.dmark)  
9fd5 32 7a ee			ld (debug_mark),a  
9fd8 3a e7 9f			ld a, (.dmark+1)  
9fdb 32 7b ee			ld (debug_mark+1),a  
9fde 3a e8 9f			ld a, (.dmark+2)  
9fe1 32 7c ee			ld (debug_mark+2),a  
9fe4 18 03			jr .pastdmark  
9fe6 ..			.dmark: db "CAA"  
9fe9 f1			.pastdmark: pop af  
9fea			endm  
# End of macro DMARK
9fea						CALLMONITOR 
9fea cd 7b 91			call break_point_state  
9fed				endm  
# End of macro CALLMONITOR
9fed					endif 
9fed c3 ba 9f				jp .getbyteat 
9ff0					NEXTW 
9ff0 c3 06 99			jp macro_next 
9ff3				endm 
# End of macro NEXTW
9ff3			.BANG: 
9ff3				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
9ff3 21				db WORD_SYS_CORE+OPCODE_BANG             
9ff4 29 a0			dw .CBANG            
9ff6 02				db 1 + 1 
9ff7 .. 00			db "!",0              
9ff9				endm 
# End of macro CWHEAD
9ff9			; | ! ( x w -- ) Store x at address w      | DONE 
9ff9					if DEBUG_FORTH_WORDS_KEY 
9ff9						DMARK "BNG" 
9ff9 f5				push af  
9ffa 3a 0e a0			ld a, (.dmark)  
9ffd 32 7a ee			ld (debug_mark),a  
a000 3a 0f a0			ld a, (.dmark+1)  
a003 32 7b ee			ld (debug_mark+1),a  
a006 3a 10 a0			ld a, (.dmark+2)  
a009 32 7c ee			ld (debug_mark+2),a  
a00c 18 03			jr .pastdmark  
a00e ..			.dmark: db "BNG"  
a011 f1			.pastdmark: pop af  
a012			endm  
# End of macro DMARK
a012						CALLMONITOR 
a012 cd 7b 91			call break_point_state  
a015				endm  
# End of macro CALLMONITOR
a015					endif 
a015			 
a015			.storebyteat:		 
a015					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a015 cd b0 97			call macro_dsp_valuehl 
a018				endm 
# End of macro FORTH_DSP_VALUEHL
a018					 
a018 e5					push hl 
a019				 
a019					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a019 cd 4c 98			call macro_forth_dsp_pop 
a01c				endm 
# End of macro FORTH_DSP_POP
a01c			 
a01c					; get byte to poke 
a01c			 
a01c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a01c cd b0 97			call macro_dsp_valuehl 
a01f				endm 
# End of macro FORTH_DSP_VALUEHL
a01f e5					push hl 
a020			 
a020			 
a020					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a020 cd 4c 98			call macro_forth_dsp_pop 
a023				endm 
# End of macro FORTH_DSP_POP
a023			 
a023			 
a023 d1					pop de 
a024 e1					pop hl 
a025			 
a025 73					ld (hl),e 
a026			 
a026			 
a026					NEXTW 
a026 c3 06 99			jp macro_next 
a029				endm 
# End of macro NEXTW
a029			.CBANG: 
a029				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a029 22				db WORD_SYS_CORE+OPCODE_CBANG             
a02a 52 a0			dw .SCALL            
a02c 03				db 2 + 1 
a02d .. 00			db "C!",0              
a030				endm 
# End of macro CWHEAD
a030			; | C!  ( x w -- ) Store x at address w  | DONE 
a030					if DEBUG_FORTH_WORDS_KEY 
a030						DMARK "CBA" 
a030 f5				push af  
a031 3a 45 a0			ld a, (.dmark)  
a034 32 7a ee			ld (debug_mark),a  
a037 3a 46 a0			ld a, (.dmark+1)  
a03a 32 7b ee			ld (debug_mark+1),a  
a03d 3a 47 a0			ld a, (.dmark+2)  
a040 32 7c ee			ld (debug_mark+2),a  
a043 18 03			jr .pastdmark  
a045 ..			.dmark: db "CBA"  
a048 f1			.pastdmark: pop af  
a049			endm  
# End of macro DMARK
a049						CALLMONITOR 
a049 cd 7b 91			call break_point_state  
a04c				endm  
# End of macro CALLMONITOR
a04c					endif 
a04c c3 15 a0				jp .storebyteat 
a04f					NEXTW 
a04f c3 06 99			jp macro_next 
a052				endm 
# End of macro NEXTW
a052			.SCALL: 
a052				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a052 23				db WORD_SYS_CORE+OPCODE_SCALL             
a053 86 a0			dw .DEPTH            
a055 05				db 4 + 1 
a056 .. 00			db "CALL",0              
a05b				endm 
# End of macro CWHEAD
a05b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a05b					if DEBUG_FORTH_WORDS_KEY 
a05b						DMARK "CLL" 
a05b f5				push af  
a05c 3a 70 a0			ld a, (.dmark)  
a05f 32 7a ee			ld (debug_mark),a  
a062 3a 71 a0			ld a, (.dmark+1)  
a065 32 7b ee			ld (debug_mark+1),a  
a068 3a 72 a0			ld a, (.dmark+2)  
a06b 32 7c ee			ld (debug_mark+2),a  
a06e 18 03			jr .pastdmark  
a070 ..			.dmark: db "CLL"  
a073 f1			.pastdmark: pop af  
a074			endm  
# End of macro DMARK
a074						CALLMONITOR 
a074 cd 7b 91			call break_point_state  
a077				endm  
# End of macro CALLMONITOR
a077					endif 
a077			 
a077					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a077 cd b0 97			call macro_dsp_valuehl 
a07a				endm 
# End of macro FORTH_DSP_VALUEHL
a07a			 
a07a			;		push hl 
a07a			 
a07a					; destroy value TOS 
a07a			 
a07a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a07a cd 4c 98			call macro_forth_dsp_pop 
a07d				endm 
# End of macro FORTH_DSP_POP
a07d			 
a07d						 
a07d			;		pop hl 
a07d			 
a07d					; how to do a call with hl???? save SP? 
a07d cd af 98				call forth_call_hl 
a080			 
a080			 
a080					; TODO push value back onto stack for another op etc 
a080			 
a080 cd 15 97				call forth_push_numhl 
a083					NEXTW 
a083 c3 06 99			jp macro_next 
a086				endm 
# End of macro NEXTW
a086			.DEPTH: 
a086				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a086 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a087 c3 a0			dw .OVER            
a089 06				db 5 + 1 
a08a .. 00			db "DEPTH",0              
a090				endm 
# End of macro CWHEAD
a090			; | DEPTH ( -- u ) Push count of stack | DONE 
a090					; take current TOS and remove from base value div by two to get count 
a090					if DEBUG_FORTH_WORDS_KEY 
a090						DMARK "DEP" 
a090 f5				push af  
a091 3a a5 a0			ld a, (.dmark)  
a094 32 7a ee			ld (debug_mark),a  
a097 3a a6 a0			ld a, (.dmark+1)  
a09a 32 7b ee			ld (debug_mark+1),a  
a09d 3a a7 a0			ld a, (.dmark+2)  
a0a0 32 7c ee			ld (debug_mark+2),a  
a0a3 18 03			jr .pastdmark  
a0a5 ..			.dmark: db "DEP"  
a0a8 f1			.pastdmark: pop af  
a0a9			endm  
# End of macro DMARK
a0a9						CALLMONITOR 
a0a9 cd 7b 91			call break_point_state  
a0ac				endm  
# End of macro CALLMONITOR
a0ac					endif 
a0ac			 
a0ac			 
a0ac 2a 22 eb			ld hl, (cli_data_sp) 
a0af 11 dc e8			ld de, cli_data_stack 
a0b2 ed 52			sbc hl,de 
a0b4				 
a0b4				; div by size of stack item 
a0b4			 
a0b4 5d				ld e,l 
a0b5 0e 03			ld c, 3 
a0b7 cd 47 89			call Div8 
a0ba			 
a0ba 6f				ld l,a 
a0bb 26 00			ld h,0 
a0bd			 
a0bd				;srl h 
a0bd				;rr l 
a0bd			 
a0bd cd 15 97				call forth_push_numhl 
a0c0					NEXTW 
a0c0 c3 06 99			jp macro_next 
a0c3				endm 
# End of macro NEXTW
a0c3			.OVER: 
a0c3				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a0c3 42				db WORD_SYS_CORE+46             
a0c4 0a a1			dw .PAUSE            
a0c6 05				db 4 + 1 
a0c7 .. 00			db "OVER",0              
a0cc				endm 
# End of macro CWHEAD
a0cc			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a0cc					if DEBUG_FORTH_WORDS_KEY 
a0cc						DMARK "OVR" 
a0cc f5				push af  
a0cd 3a e1 a0			ld a, (.dmark)  
a0d0 32 7a ee			ld (debug_mark),a  
a0d3 3a e2 a0			ld a, (.dmark+1)  
a0d6 32 7b ee			ld (debug_mark+1),a  
a0d9 3a e3 a0			ld a, (.dmark+2)  
a0dc 32 7c ee			ld (debug_mark+2),a  
a0df 18 03			jr .pastdmark  
a0e1 ..			.dmark: db "OVR"  
a0e4 f1			.pastdmark: pop af  
a0e5			endm  
# End of macro DMARK
a0e5						CALLMONITOR 
a0e5 cd 7b 91			call break_point_state  
a0e8				endm  
# End of macro CALLMONITOR
a0e8					endif 
a0e8			 
a0e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0e8 cd b0 97			call macro_dsp_valuehl 
a0eb				endm 
# End of macro FORTH_DSP_VALUEHL
a0eb e5					push hl    ; n2 
a0ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a0ec cd 4c 98			call macro_forth_dsp_pop 
a0ef				endm 
# End of macro FORTH_DSP_POP
a0ef			 
a0ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0ef cd b0 97			call macro_dsp_valuehl 
a0f2				endm 
# End of macro FORTH_DSP_VALUEHL
a0f2 e5					push hl    ; n1 
a0f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a0f3 cd 4c 98			call macro_forth_dsp_pop 
a0f6				endm 
# End of macro FORTH_DSP_POP
a0f6			 
a0f6 d1					pop de     ; n1 
a0f7 e1					pop hl     ; n2 
a0f8			 
a0f8 d5					push de 
a0f9 e5					push hl 
a0fa d5					push de 
a0fb			 
a0fb					; push back  
a0fb			 
a0fb e1					pop hl 
a0fc cd 15 97				call forth_push_numhl 
a0ff e1					pop hl 
a100 cd 15 97				call forth_push_numhl 
a103 e1					pop hl 
a104 cd 15 97				call forth_push_numhl 
a107					NEXTW 
a107 c3 06 99			jp macro_next 
a10a				endm 
# End of macro NEXTW
a10a			 
a10a			.PAUSE: 
a10a				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a10a 43				db WORD_SYS_CORE+47             
a10b 3f a1			dw .PAUSES            
a10d 08				db 7 + 1 
a10e .. 00			db "PAUSEMS",0              
a116				endm 
# End of macro CWHEAD
a116			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a116					if DEBUG_FORTH_WORDS_KEY 
a116						DMARK "PMS" 
a116 f5				push af  
a117 3a 2b a1			ld a, (.dmark)  
a11a 32 7a ee			ld (debug_mark),a  
a11d 3a 2c a1			ld a, (.dmark+1)  
a120 32 7b ee			ld (debug_mark+1),a  
a123 3a 2d a1			ld a, (.dmark+2)  
a126 32 7c ee			ld (debug_mark+2),a  
a129 18 03			jr .pastdmark  
a12b ..			.dmark: db "PMS"  
a12e f1			.pastdmark: pop af  
a12f			endm  
# End of macro DMARK
a12f						CALLMONITOR 
a12f cd 7b 91			call break_point_state  
a132				endm  
# End of macro CALLMONITOR
a132					endif 
a132					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a132 cd b0 97			call macro_dsp_valuehl 
a135				endm 
# End of macro FORTH_DSP_VALUEHL
a135			;		push hl    ; n2 
a135					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a135 cd 4c 98			call macro_forth_dsp_pop 
a138				endm 
# End of macro FORTH_DSP_POP
a138			;		pop hl 
a138			 
a138 7d					ld a, l 
a139 cd c7 87				call aDelayInMS 
a13c				       NEXTW 
a13c c3 06 99			jp macro_next 
a13f				endm 
# End of macro NEXTW
a13f			.PAUSES:  
a13f				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a13f 44				db WORD_SYS_CORE+48             
a140 ae a1			dw .ROT            
a142 06				db 5 + 1 
a143 .. 00			db "PAUSE",0              
a149				endm 
# End of macro CWHEAD
a149			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a149					if DEBUG_FORTH_WORDS_KEY 
a149						DMARK "PAU" 
a149 f5				push af  
a14a 3a 5e a1			ld a, (.dmark)  
a14d 32 7a ee			ld (debug_mark),a  
a150 3a 5f a1			ld a, (.dmark+1)  
a153 32 7b ee			ld (debug_mark+1),a  
a156 3a 60 a1			ld a, (.dmark+2)  
a159 32 7c ee			ld (debug_mark+2),a  
a15c 18 03			jr .pastdmark  
a15e ..			.dmark: db "PAU"  
a161 f1			.pastdmark: pop af  
a162			endm  
# End of macro DMARK
a162						CALLMONITOR 
a162 cd 7b 91			call break_point_state  
a165				endm  
# End of macro CALLMONITOR
a165					endif 
a165					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a165 cd b0 97			call macro_dsp_valuehl 
a168				endm 
# End of macro FORTH_DSP_VALUEHL
a168			;		push hl    ; n2 
a168					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a168 cd 4c 98			call macro_forth_dsp_pop 
a16b				endm 
# End of macro FORTH_DSP_POP
a16b			;		pop hl 
a16b 45					ld b, l 
a16c					if DEBUG_FORTH_WORDS 
a16c						DMARK "PAU" 
a16c f5				push af  
a16d 3a 81 a1			ld a, (.dmark)  
a170 32 7a ee			ld (debug_mark),a  
a173 3a 82 a1			ld a, (.dmark+1)  
a176 32 7b ee			ld (debug_mark+1),a  
a179 3a 83 a1			ld a, (.dmark+2)  
a17c 32 7c ee			ld (debug_mark+2),a  
a17f 18 03			jr .pastdmark  
a181 ..			.dmark: db "PAU"  
a184 f1			.pastdmark: pop af  
a185			endm  
# End of macro DMARK
a185						CALLMONITOR 
a185 cd 7b 91			call break_point_state  
a188				endm  
# End of macro CALLMONITOR
a188					endif 
a188 c5			.pauses1:	push bc 
a189 cd e2 87				call delay1s 
a18c c1					pop bc 
a18d					if DEBUG_FORTH_WORDS 
a18d						DMARK "PA1" 
a18d f5				push af  
a18e 3a a2 a1			ld a, (.dmark)  
a191 32 7a ee			ld (debug_mark),a  
a194 3a a3 a1			ld a, (.dmark+1)  
a197 32 7b ee			ld (debug_mark+1),a  
a19a 3a a4 a1			ld a, (.dmark+2)  
a19d 32 7c ee			ld (debug_mark+2),a  
a1a0 18 03			jr .pastdmark  
a1a2 ..			.dmark: db "PA1"  
a1a5 f1			.pastdmark: pop af  
a1a6			endm  
# End of macro DMARK
a1a6						CALLMONITOR 
a1a6 cd 7b 91			call break_point_state  
a1a9				endm  
# End of macro CALLMONITOR
a1a9					endif 
a1a9 10 dd				djnz .pauses1 
a1ab			 
a1ab				       NEXTW 
a1ab c3 06 99			jp macro_next 
a1ae				endm 
# End of macro NEXTW
a1ae			.ROT: 
a1ae				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a1ae 45				db WORD_SYS_CORE+49             
a1af fc a1			dw .UWORDS            
a1b1 04				db 3 + 1 
a1b2 .. 00			db "ROT",0              
a1b6				endm 
# End of macro CWHEAD
a1b6			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a1b6					if DEBUG_FORTH_WORDS_KEY 
a1b6						DMARK "ROT" 
a1b6 f5				push af  
a1b7 3a cb a1			ld a, (.dmark)  
a1ba 32 7a ee			ld (debug_mark),a  
a1bd 3a cc a1			ld a, (.dmark+1)  
a1c0 32 7b ee			ld (debug_mark+1),a  
a1c3 3a cd a1			ld a, (.dmark+2)  
a1c6 32 7c ee			ld (debug_mark+2),a  
a1c9 18 03			jr .pastdmark  
a1cb ..			.dmark: db "ROT"  
a1ce f1			.pastdmark: pop af  
a1cf			endm  
# End of macro DMARK
a1cf						CALLMONITOR 
a1cf cd 7b 91			call break_point_state  
a1d2				endm  
# End of macro CALLMONITOR
a1d2					endif 
a1d2			 
a1d2					FORTH_DSP_VALUEHL 
a1d2 cd b0 97			call macro_dsp_valuehl 
a1d5				endm 
# End of macro FORTH_DSP_VALUEHL
a1d5 e5					push hl    ; u3  
a1d6			 
a1d6					FORTH_DSP_POP 
a1d6 cd 4c 98			call macro_forth_dsp_pop 
a1d9				endm 
# End of macro FORTH_DSP_POP
a1d9			   
a1d9					FORTH_DSP_VALUEHL 
a1d9 cd b0 97			call macro_dsp_valuehl 
a1dc				endm 
# End of macro FORTH_DSP_VALUEHL
a1dc e5					push hl     ; u2 
a1dd			 
a1dd					FORTH_DSP_POP 
a1dd cd 4c 98			call macro_forth_dsp_pop 
a1e0				endm 
# End of macro FORTH_DSP_POP
a1e0			 
a1e0					FORTH_DSP_VALUEHL 
a1e0 cd b0 97			call macro_dsp_valuehl 
a1e3				endm 
# End of macro FORTH_DSP_VALUEHL
a1e3 e5					push hl     ; u1 
a1e4			 
a1e4					FORTH_DSP_POP 
a1e4 cd 4c 98			call macro_forth_dsp_pop 
a1e7				endm 
# End of macro FORTH_DSP_POP
a1e7			 
a1e7 c1					pop bc      ; u1 
a1e8 e1					pop hl      ; u2 
a1e9 d1					pop de      ; u3 
a1ea			 
a1ea			 
a1ea c5					push bc 
a1eb d5					push de 
a1ec e5					push hl 
a1ed			 
a1ed			 
a1ed e1					pop hl 
a1ee cd 15 97				call forth_push_numhl 
a1f1			 
a1f1 e1					pop hl 
a1f2 cd 15 97				call forth_push_numhl 
a1f5			 
a1f5 e1					pop hl 
a1f6 cd 15 97				call forth_push_numhl 
a1f9					 
a1f9			 
a1f9			 
a1f9			 
a1f9			 
a1f9			 
a1f9				       NEXTW 
a1f9 c3 06 99			jp macro_next 
a1fc				endm 
# End of macro NEXTW
a1fc			 
a1fc			.UWORDS: 
a1fc				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a1fc 50				db WORD_SYS_CORE+60             
a1fd be a2			dw .BP            
a1ff 07				db 6 + 1 
a200 .. 00			db "UWORDS",0              
a207				endm 
# End of macro CWHEAD
a207			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a207			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a207			; | | Following the count are the individual words. 
a207			; | | 
a207			; | | e.g. UWORDS 
a207			; | | BOX DIRLIST 2 
a207			; | |  
a207			; | | Can be used to save the words to storage via: 
a207			; | | UWORDS $01 DO $01 APPEND LOOP 
a207				if DEBUG_FORTH_WORDS_KEY 
a207					DMARK "UWR" 
a207 f5				push af  
a208 3a 1c a2			ld a, (.dmark)  
a20b 32 7a ee			ld (debug_mark),a  
a20e 3a 1d a2			ld a, (.dmark+1)  
a211 32 7b ee			ld (debug_mark+1),a  
a214 3a 1e a2			ld a, (.dmark+2)  
a217 32 7c ee			ld (debug_mark+2),a  
a21a 18 03			jr .pastdmark  
a21c ..			.dmark: db "UWR"  
a21f f1			.pastdmark: pop af  
a220			endm  
# End of macro DMARK
a220					CALLMONITOR 
a220 cd 7b 91			call break_point_state  
a223				endm  
# End of macro CALLMONITOR
a223				endif 
a223 21 b4 d4				ld hl, baseram 
a226					;ld hl, baseusermem 
a226 01 00 00				ld bc, 0    ; start a counter 
a229			 
a229				; skip dict stub 
a229			 
a229 cd 57 9a				call forth_tok_next 
a22c			 
a22c			 
a22c			; while we have words to look for 
a22c			 
a22c 7e			.douscan:	ld a, (hl)      
a22d				if DEBUG_FORTH_WORDS 
a22d					DMARK "UWs" 
a22d f5				push af  
a22e 3a 42 a2			ld a, (.dmark)  
a231 32 7a ee			ld (debug_mark),a  
a234 3a 43 a2			ld a, (.dmark+1)  
a237 32 7b ee			ld (debug_mark+1),a  
a23a 3a 44 a2			ld a, (.dmark+2)  
a23d 32 7c ee			ld (debug_mark+2),a  
a240 18 03			jr .pastdmark  
a242 ..			.dmark: db "UWs"  
a245 f1			.pastdmark: pop af  
a246			endm  
# End of macro DMARK
a246					CALLMONITOR 
a246 cd 7b 91			call break_point_state  
a249				endm  
# End of macro CALLMONITOR
a249				endif 
a249 fe 00				cp WORD_SYS_END 
a24b 28 4d				jr z, .udone 
a24d fe 01				cp WORD_SYS_UWORD 
a24f 20 44				jr nz, .nuword 
a251			 
a251				if DEBUG_FORTH_WORDS 
a251					DMARK "UWu" 
a251 f5				push af  
a252 3a 66 a2			ld a, (.dmark)  
a255 32 7a ee			ld (debug_mark),a  
a258 3a 67 a2			ld a, (.dmark+1)  
a25b 32 7b ee			ld (debug_mark+1),a  
a25e 3a 68 a2			ld a, (.dmark+2)  
a261 32 7c ee			ld (debug_mark+2),a  
a264 18 03			jr .pastdmark  
a266 ..			.dmark: db "UWu"  
a269 f1			.pastdmark: pop af  
a26a			endm  
# End of macro DMARK
a26a					CALLMONITOR 
a26a cd 7b 91			call break_point_state  
a26d				endm  
# End of macro CALLMONITOR
a26d				endif 
a26d					; we have a uword so push its name to the stack 
a26d			 
a26d e5				   	push hl  ; save so we can move to next dict block 
a26e			 
a26e					; skip opcode 
a26e 23					inc hl  
a26f					; skip next ptr 
a26f 23					inc hl  
a270 23					inc hl 
a271					; skip len 
a271 23					inc hl 
a272				if DEBUG_FORTH_WORDS 
a272					DMARK "UWt" 
a272 f5				push af  
a273 3a 87 a2			ld a, (.dmark)  
a276 32 7a ee			ld (debug_mark),a  
a279 3a 88 a2			ld a, (.dmark+1)  
a27c 32 7b ee			ld (debug_mark+1),a  
a27f 3a 89 a2			ld a, (.dmark+2)  
a282 32 7c ee			ld (debug_mark+2),a  
a285 18 03			jr .pastdmark  
a287 ..			.dmark: db "UWt"  
a28a f1			.pastdmark: pop af  
a28b			endm  
# End of macro DMARK
a28b					CALLMONITOR 
a28b cd 7b 91			call break_point_state  
a28e				endm  
# End of macro CALLMONITOR
a28e				endif 
a28e 03					inc bc 
a28f			 
a28f c5					push bc 
a290 cd 27 97				call forth_push_str 
a293 c1					pop bc 
a294			 
a294 e1					pop hl 	 
a295			 
a295 cd 57 9a		.nuword:	call forth_tok_next 
a298 18 92				jr .douscan  
a29a			 
a29a			.udone:		 ; push count of uwords found 
a29a c5					push bc 
a29b e1					pop hl 
a29c			 
a29c				if DEBUG_FORTH_WORDS 
a29c					DMARK "UWc" 
a29c f5				push af  
a29d 3a b1 a2			ld a, (.dmark)  
a2a0 32 7a ee			ld (debug_mark),a  
a2a3 3a b2 a2			ld a, (.dmark+1)  
a2a6 32 7b ee			ld (debug_mark+1),a  
a2a9 3a b3 a2			ld a, (.dmark+2)  
a2ac 32 7c ee			ld (debug_mark+2),a  
a2af 18 03			jr .pastdmark  
a2b1 ..			.dmark: db "UWc"  
a2b4 f1			.pastdmark: pop af  
a2b5			endm  
# End of macro DMARK
a2b5					CALLMONITOR 
a2b5 cd 7b 91			call break_point_state  
a2b8				endm  
# End of macro CALLMONITOR
a2b8				endif 
a2b8 cd 15 97				call forth_push_numhl 
a2bb			 
a2bb			 
a2bb				       NEXTW 
a2bb c3 06 99			jp macro_next 
a2be				endm 
# End of macro NEXTW
a2be			 
a2be			.BP: 
a2be				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a2be 54				db WORD_SYS_CORE+64             
a2bf f4 a2			dw .MONITOR            
a2c1 03				db 2 + 1 
a2c2 .. 00			db "BP",0              
a2c5				endm 
# End of macro CWHEAD
a2c5			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a2c5			; | | $00 Will enable the break points within specific code paths 
a2c5			; | | $01 Will disable break points 
a2c5			; | |  
a2c5			; | | By default break points are off. Either the above can be used to enable them 
a2c5			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a2c5			; | | and on release of the pressed key a message will be disaplayed to notify 
a2c5			; | | that break points are enabled. Pressing any key will then continue boot process. 
a2c5					; get byte count 
a2c5					if DEBUG_FORTH_WORDS_KEY 
a2c5						DMARK "BP." 
a2c5 f5				push af  
a2c6 3a da a2			ld a, (.dmark)  
a2c9 32 7a ee			ld (debug_mark),a  
a2cc 3a db a2			ld a, (.dmark+1)  
a2cf 32 7b ee			ld (debug_mark+1),a  
a2d2 3a dc a2			ld a, (.dmark+2)  
a2d5 32 7c ee			ld (debug_mark+2),a  
a2d8 18 03			jr .pastdmark  
a2da ..			.dmark: db "BP."  
a2dd f1			.pastdmark: pop af  
a2de			endm  
# End of macro DMARK
a2de						CALLMONITOR 
a2de cd 7b 91			call break_point_state  
a2e1				endm  
# End of macro CALLMONITOR
a2e1					endif 
a2e1			 
a2e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2e1 cd b0 97			call macro_dsp_valuehl 
a2e4				endm 
# End of macro FORTH_DSP_VALUEHL
a2e4			 
a2e4			;		push hl 
a2e4			 
a2e4					; destroy value TOS 
a2e4			 
a2e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2e4 cd 4c 98			call macro_forth_dsp_pop 
a2e7				endm 
# End of macro FORTH_DSP_POP
a2e7			 
a2e7			;		pop hl 
a2e7			 
a2e7 3e 00				ld a,0 
a2e9 bd					cp l 
a2ea 28 02				jr z, .bpset 
a2ec 3e 2a				ld a, '*' 
a2ee			 
a2ee 32 74 e3		.bpset:		ld (os_view_disable), a 
a2f1			 
a2f1			 
a2f1					NEXTW 
a2f1 c3 06 99			jp macro_next 
a2f4				endm 
# End of macro NEXTW
a2f4			 
a2f4			 
a2f4			.MONITOR: 
a2f4				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a2f4 55				db WORD_SYS_CORE+65             
a2f5 27 a3			dw .MALLOC            
a2f7 08				db 7 + 1 
a2f8 .. 00			db "MONITOR",0              
a300				endm 
# End of macro CWHEAD
a300			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a300			; | | At start the current various registers will be displayed with contents. 
a300			; | | Top right corner will show the most recent debug marker seen. 
a300			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a300			; | | and the return stack pointer (RSP). 
a300			; | | Pressing: 
a300			; | |    1 - Initial screen 
a300			; | |    2 - Display a data dump of HL 
a300			; | |    3 - Display a data dump of DE 
a300			; | |    4 - Display a data dump of BC 
a300			; | |    5 - Display a data dump of HL 
a300			; | |    6 - Display a data dump of DSP 
a300			; | |    7 - Display a data dump of RSP 
a300			; | |    8 - Display a data dump of what is at DSP 
a300			; | |    9 - Display a data dump of what is at RSP 
a300			; | |    0 - Exit monitor and continue running. This will also enable break points 
a300			; | |    * - Disable break points 
a300			; | |    # - Enter traditional monitor mode 
a300			; | | 
a300			; | | Monitor Mode 
a300			; | | ------------ 
a300			; | | A prompt of '>' will be shown for various commands: 
a300			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a300			; | |    C - Continue display a data dump from the last set address 
a300			; | |    M xxxx - Set start of memory edit at address xx 
a300			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a300			; | |    Q - Return to previous 
a300					if DEBUG_FORTH_WORDS_KEY 
a300						DMARK "MON" 
a300 f5				push af  
a301 3a 15 a3			ld a, (.dmark)  
a304 32 7a ee			ld (debug_mark),a  
a307 3a 16 a3			ld a, (.dmark+1)  
a30a 32 7b ee			ld (debug_mark+1),a  
a30d 3a 17 a3			ld a, (.dmark+2)  
a310 32 7c ee			ld (debug_mark+2),a  
a313 18 03			jr .pastdmark  
a315 ..			.dmark: db "MON"  
a318 f1			.pastdmark: pop af  
a319			endm  
# End of macro DMARK
a319						CALLMONITOR 
a319 cd 7b 91			call break_point_state  
a31c				endm  
# End of macro CALLMONITOR
a31c					endif 
a31c 3e 00				ld a, 0 
a31e 32 74 e3				ld (os_view_disable), a 
a321			 
a321					CALLMONITOR 
a321 cd 7b 91			call break_point_state  
a324				endm  
# End of macro CALLMONITOR
a324			 
a324			;	call monitor 
a324			 
a324					NEXTW 
a324 c3 06 99			jp macro_next 
a327				endm 
# End of macro NEXTW
a327			 
a327			 
a327			.MALLOC: 
a327				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a327 56				db WORD_SYS_CORE+66             
a328 50 a3			dw .MALLOC2            
a32a 06				db 5 + 1 
a32b .. 00			db "ALLOT",0              
a331				endm 
# End of macro CWHEAD
a331			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a331					if DEBUG_FORTH_WORDS_KEY 
a331						DMARK "ALL" 
a331 f5				push af  
a332 3a 46 a3			ld a, (.dmark)  
a335 32 7a ee			ld (debug_mark),a  
a338 3a 47 a3			ld a, (.dmark+1)  
a33b 32 7b ee			ld (debug_mark+1),a  
a33e 3a 48 a3			ld a, (.dmark+2)  
a341 32 7c ee			ld (debug_mark+2),a  
a344 18 03			jr .pastdmark  
a346 ..			.dmark: db "ALL"  
a349 f1			.pastdmark: pop af  
a34a			endm  
# End of macro DMARK
a34a						CALLMONITOR 
a34a cd 7b 91			call break_point_state  
a34d				endm  
# End of macro CALLMONITOR
a34d					endif 
a34d c3 77 a3				jp .mallocc 
a350			.MALLOC2: 
a350				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a350 56				db WORD_SYS_CORE+66             
a351 8e a3			dw .FREE            
a353 07				db 6 + 1 
a354 .. 00			db "MALLOC",0              
a35b				endm 
# End of macro CWHEAD
a35b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a35b					; get byte count 
a35b					if DEBUG_FORTH_WORDS_KEY 
a35b						DMARK "MAL" 
a35b f5				push af  
a35c 3a 70 a3			ld a, (.dmark)  
a35f 32 7a ee			ld (debug_mark),a  
a362 3a 71 a3			ld a, (.dmark+1)  
a365 32 7b ee			ld (debug_mark+1),a  
a368 3a 72 a3			ld a, (.dmark+2)  
a36b 32 7c ee			ld (debug_mark+2),a  
a36e 18 03			jr .pastdmark  
a370 ..			.dmark: db "MAL"  
a373 f1			.pastdmark: pop af  
a374			endm  
# End of macro DMARK
a374						CALLMONITOR 
a374 cd 7b 91			call break_point_state  
a377				endm  
# End of macro CALLMONITOR
a377					endif 
a377			.mallocc: 
a377					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a377 cd b0 97			call macro_dsp_valuehl 
a37a				endm 
# End of macro FORTH_DSP_VALUEHL
a37a			 
a37a			;		push hl 
a37a			 
a37a					; destroy value TOS 
a37a			 
a37a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a37a cd 4c 98			call macro_forth_dsp_pop 
a37d				endm 
# End of macro FORTH_DSP_POP
a37d			 
a37d			;		pop hl 
a37d cd 7e 8e				call malloc 
a380				if DEBUG_FORTH_MALLOC_GUARD 
a380 f5					push af 
a381 cd e0 89				call ishlzero 
a384			;		ld a, l 
a384			;		add h 
a384			;		cp 0 
a384 f1					pop af 
a385					 
a385 cc 69 c1				call z,malloc_error 
a388				endif 
a388			 
a388 cd 15 97				call forth_push_numhl 
a38b					NEXTW 
a38b c3 06 99			jp macro_next 
a38e				endm 
# End of macro NEXTW
a38e			 
a38e			.FREE: 
a38e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a38e 57				db WORD_SYS_CORE+67             
a38f bf a3			dw .LIST            
a391 05				db 4 + 1 
a392 .. 00			db "FREE",0              
a397				endm 
# End of macro CWHEAD
a397			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a397					if DEBUG_FORTH_WORDS_KEY 
a397						DMARK "FRE" 
a397 f5				push af  
a398 3a ac a3			ld a, (.dmark)  
a39b 32 7a ee			ld (debug_mark),a  
a39e 3a ad a3			ld a, (.dmark+1)  
a3a1 32 7b ee			ld (debug_mark+1),a  
a3a4 3a ae a3			ld a, (.dmark+2)  
a3a7 32 7c ee			ld (debug_mark+2),a  
a3aa 18 03			jr .pastdmark  
a3ac ..			.dmark: db "FRE"  
a3af f1			.pastdmark: pop af  
a3b0			endm  
# End of macro DMARK
a3b0						CALLMONITOR 
a3b0 cd 7b 91			call break_point_state  
a3b3				endm  
# End of macro CALLMONITOR
a3b3					endif 
a3b3					; get address 
a3b3			 
a3b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3b3 cd b0 97			call macro_dsp_valuehl 
a3b6				endm 
# End of macro FORTH_DSP_VALUEHL
a3b6			 
a3b6			;		push hl 
a3b6			 
a3b6					; destroy value TOS 
a3b6			 
a3b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3b6 cd 4c 98			call macro_forth_dsp_pop 
a3b9				endm 
# End of macro FORTH_DSP_POP
a3b9			 
a3b9			;		pop hl 
a3b9			if FORTH_ENABLE_MALLOCFREE 
a3b9 cd 48 8f				call free 
a3bc			endif 
a3bc					NEXTW 
a3bc c3 06 99			jp macro_next 
a3bf				endm 
# End of macro NEXTW
a3bf			.LIST: 
a3bf				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a3bf 5c				db WORD_SYS_CORE+72             
a3c0 82 a5			dw .FORGET            
a3c2 05				db 4 + 1 
a3c3 .. 00			db "LIST",0              
a3c8				endm 
# End of macro CWHEAD
a3c8			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a3c8			; | | The quoted word must be in upper case. 
a3c8				if DEBUG_FORTH_WORDS_KEY 
a3c8					DMARK "LST" 
a3c8 f5				push af  
a3c9 3a dd a3			ld a, (.dmark)  
a3cc 32 7a ee			ld (debug_mark),a  
a3cf 3a de a3			ld a, (.dmark+1)  
a3d2 32 7b ee			ld (debug_mark+1),a  
a3d5 3a df a3			ld a, (.dmark+2)  
a3d8 32 7c ee			ld (debug_mark+2),a  
a3db 18 03			jr .pastdmark  
a3dd ..			.dmark: db "LST"  
a3e0 f1			.pastdmark: pop af  
a3e1			endm  
# End of macro DMARK
a3e1					CALLMONITOR 
a3e1 cd 7b 91			call break_point_state  
a3e4				endm  
# End of macro CALLMONITOR
a3e4				endif 
a3e4			 
a3e4					FORTH_DSP_VALUEHL 
a3e4 cd b0 97			call macro_dsp_valuehl 
a3e7				endm 
# End of macro FORTH_DSP_VALUEHL
a3e7			 
a3e7 e5					push hl 
a3e8 c1					pop bc 
a3e9			 
a3e9			; Start format of scratch string 
a3e9			 
a3e9 21 75 e3				ld hl, scratch 
a3ec			 
a3ec 3e 3a				ld a, ':' 
a3ee 77					ld (hl),a 
a3ef 23					inc hl 
a3f0 3e 20				ld a, ' ' 
a3f2 77					ld (hl), a 
a3f3			 
a3f3					; Get ptr to the word we need to look up 
a3f3			 
a3f3			;		FORTH_DSP_VALUEHL 
a3f3					;v5 FORTH_DSP_VALUE 
a3f3				; TODO type check 
a3f3			;		inc hl    ; Skip type check  
a3f3			;		push hl 
a3f3			;		ex de, hl    ; put into DE 
a3f3			 
a3f3			 
a3f3 21 b4 d4				ld hl, baseram 
a3f6					;ld hl, baseusermem 
a3f6			 
a3f6 e5			push hl   ; sacreifical push 
a3f7			 
a3f7			.ldouscanm: 
a3f7 e1				pop hl 
a3f8			.ldouscan: 
a3f8				if DEBUG_FORTH_WORDS 
a3f8					DMARK "LSs" 
a3f8 f5				push af  
a3f9 3a 0d a4			ld a, (.dmark)  
a3fc 32 7a ee			ld (debug_mark),a  
a3ff 3a 0e a4			ld a, (.dmark+1)  
a402 32 7b ee			ld (debug_mark+1),a  
a405 3a 0f a4			ld a, (.dmark+2)  
a408 32 7c ee			ld (debug_mark+2),a  
a40b 18 03			jr .pastdmark  
a40d ..			.dmark: db "LSs"  
a410 f1			.pastdmark: pop af  
a411			endm  
# End of macro DMARK
a411					CALLMONITOR 
a411 cd 7b 91			call break_point_state  
a414				endm  
# End of macro CALLMONITOR
a414				endif 
a414				; skip dict stub 
a414 cd 57 9a				call forth_tok_next 
a417			 
a417			 
a417			; while we have words to look for 
a417			 
a417 7e				ld a, (hl)      
a418				if DEBUG_FORTH_WORDS 
a418					DMARK "LSk" 
a418 f5				push af  
a419 3a 2d a4			ld a, (.dmark)  
a41c 32 7a ee			ld (debug_mark),a  
a41f 3a 2e a4			ld a, (.dmark+1)  
a422 32 7b ee			ld (debug_mark+1),a  
a425 3a 2f a4			ld a, (.dmark+2)  
a428 32 7c ee			ld (debug_mark+2),a  
a42b 18 03			jr .pastdmark  
a42d ..			.dmark: db "LSk"  
a430 f1			.pastdmark: pop af  
a431			endm  
# End of macro DMARK
a431					CALLMONITOR 
a431 cd 7b 91			call break_point_state  
a434				endm  
# End of macro CALLMONITOR
a434				endif 
a434 fe 00				cp WORD_SYS_END 
a436 ca 69 a5				jp z, .lunotfound 
a439 fe 01				cp WORD_SYS_UWORD 
a43b c2 f8 a3				jp nz, .ldouscan 
a43e			 
a43e				if DEBUG_FORTH_WORDS 
a43e					DMARK "LSu" 
a43e f5				push af  
a43f 3a 53 a4			ld a, (.dmark)  
a442 32 7a ee			ld (debug_mark),a  
a445 3a 54 a4			ld a, (.dmark+1)  
a448 32 7b ee			ld (debug_mark+1),a  
a44b 3a 55 a4			ld a, (.dmark+2)  
a44e 32 7c ee			ld (debug_mark+2),a  
a451 18 03			jr .pastdmark  
a453 ..			.dmark: db "LSu"  
a456 f1			.pastdmark: pop af  
a457			endm  
# End of macro DMARK
a457					CALLMONITOR 
a457 cd 7b 91			call break_point_state  
a45a				endm  
# End of macro CALLMONITOR
a45a				endif 
a45a			 
a45a					; found a uword but is it the one we want... 
a45a			 
a45a c5					push bc     ; uword to find is on bc 
a45b d1					pop de 
a45c			 
a45c e5					push hl  ; to save the ptr 
a45d			 
a45d					; skip opcode 
a45d 23					inc hl  
a45e					; skip next ptr 
a45e 23					inc hl  
a45f 23					inc hl 
a460					; skip len 
a460 23					inc hl 
a461			 
a461				if DEBUG_FORTH_WORDS 
a461					DMARK "LSc" 
a461 f5				push af  
a462 3a 76 a4			ld a, (.dmark)  
a465 32 7a ee			ld (debug_mark),a  
a468 3a 77 a4			ld a, (.dmark+1)  
a46b 32 7b ee			ld (debug_mark+1),a  
a46e 3a 78 a4			ld a, (.dmark+2)  
a471 32 7c ee			ld (debug_mark+2),a  
a474 18 03			jr .pastdmark  
a476 ..			.dmark: db "LSc"  
a479 f1			.pastdmark: pop af  
a47a			endm  
# End of macro DMARK
a47a					CALLMONITOR 
a47a cd 7b 91			call break_point_state  
a47d				endm  
# End of macro CALLMONITOR
a47d				endif 
a47d cd 4d 8e				call strcmp 
a480 c2 f7 a3				jp nz, .ldouscanm 
a483				 
a483			 
a483			 
a483					; we have a uword so push its name to the stack 
a483			 
a483			;	   	push hl  ; save so we can move to next dict block 
a483 e1			pop hl 
a484			 
a484				if DEBUG_FORTH_WORDS 
a484					DMARK "LSm" 
a484 f5				push af  
a485 3a 99 a4			ld a, (.dmark)  
a488 32 7a ee			ld (debug_mark),a  
a48b 3a 9a a4			ld a, (.dmark+1)  
a48e 32 7b ee			ld (debug_mark+1),a  
a491 3a 9b a4			ld a, (.dmark+2)  
a494 32 7c ee			ld (debug_mark+2),a  
a497 18 03			jr .pastdmark  
a499 ..			.dmark: db "LSm"  
a49c f1			.pastdmark: pop af  
a49d			endm  
# End of macro DMARK
a49d					CALLMONITOR 
a49d cd 7b 91			call break_point_state  
a4a0				endm  
# End of macro CALLMONITOR
a4a0				endif 
a4a0			 
a4a0					; skip opcode 
a4a0 23					inc hl  
a4a1					; skip next ptr 
a4a1 23					inc hl  
a4a2 23					inc hl 
a4a3					; skip len 
a4a3 7e					ld a, (hl)   ; save length to add 
a4a4				if DEBUG_FORTH_WORDS 
a4a4					DMARK "LS2" 
a4a4 f5				push af  
a4a5 3a b9 a4			ld a, (.dmark)  
a4a8 32 7a ee			ld (debug_mark),a  
a4ab 3a ba a4			ld a, (.dmark+1)  
a4ae 32 7b ee			ld (debug_mark+1),a  
a4b1 3a bb a4			ld a, (.dmark+2)  
a4b4 32 7c ee			ld (debug_mark+2),a  
a4b7 18 03			jr .pastdmark  
a4b9 ..			.dmark: db "LS2"  
a4bc f1			.pastdmark: pop af  
a4bd			endm  
# End of macro DMARK
a4bd					CALLMONITOR 
a4bd cd 7b 91			call break_point_state  
a4c0				endm  
# End of macro CALLMONITOR
a4c0				endif 
a4c0			 
a4c0					; save this location 
a4c0				 
a4c0 e5					push hl 
a4c1			 
a4c1 23					inc hl 
a4c2 11 77 e3				ld de, scratch+2 
a4c5 4f					ld c, a 
a4c6 06 00				ld b, 0 
a4c8			 
a4c8				if DEBUG_FORTH_WORDS 
a4c8					DMARK "LSn" 
a4c8 f5				push af  
a4c9 3a dd a4			ld a, (.dmark)  
a4cc 32 7a ee			ld (debug_mark),a  
a4cf 3a de a4			ld a, (.dmark+1)  
a4d2 32 7b ee			ld (debug_mark+1),a  
a4d5 3a df a4			ld a, (.dmark+2)  
a4d8 32 7c ee			ld (debug_mark+2),a  
a4db 18 03			jr .pastdmark  
a4dd ..			.dmark: db "LSn"  
a4e0 f1			.pastdmark: pop af  
a4e1			endm  
# End of macro DMARK
a4e1					CALLMONITOR 
a4e1 cd 7b 91			call break_point_state  
a4e4				endm  
# End of macro CALLMONITOR
a4e4				endif 
a4e4			 
a4e4					; copy uword name to scratch 
a4e4			 
a4e4 ed b0				ldir 
a4e6			 
a4e6 1b					dec de 
a4e7 3e 20				ld a, ' '    ; change null to space 
a4e9 12					ld (de), a 
a4ea			 
a4ea 13					inc de 
a4eb			 
a4eb d5					push de 
a4ec c1					pop bc     ; move scratch pointer to end of word name and save it 
a4ed			 
a4ed e1					pop hl 
a4ee 7e					ld a, (hl) 
a4ef					;inc hl 
a4ef					; skip word string 
a4ef cd b7 89				call addatohl 
a4f2			 
a4f2 23					inc hl 
a4f3			 
a4f3				if DEBUG_FORTH_WORDS 
a4f3					DMARK "LS3" 
a4f3 f5				push af  
a4f4 3a 08 a5			ld a, (.dmark)  
a4f7 32 7a ee			ld (debug_mark),a  
a4fa 3a 09 a5			ld a, (.dmark+1)  
a4fd 32 7b ee			ld (debug_mark+1),a  
a500 3a 0a a5			ld a, (.dmark+2)  
a503 32 7c ee			ld (debug_mark+2),a  
a506 18 03			jr .pastdmark  
a508 ..			.dmark: db "LS3"  
a50b f1			.pastdmark: pop af  
a50c			endm  
# End of macro DMARK
a50c					CALLMONITOR 
a50c cd 7b 91			call break_point_state  
a50f				endm  
# End of macro CALLMONITOR
a50f				endif 
a50f					; should now be at the start of the machine code to setup the eval of the uword 
a50f					; now locate the ptr to the string defintion 
a50f			 
a50f					; skip ld hl, 
a50f					; then load the ptr 
a50f			 
a50f 23					inc hl 
a510 5e					ld e, (hl) 
a511 23					inc hl 
a512 56					ld d, (hl) 
a513 eb					ex de, hl 
a514			 
a514			 
a514				if DEBUG_FORTH_WORDS 
a514					DMARK "LSt" 
a514 f5				push af  
a515 3a 29 a5			ld a, (.dmark)  
a518 32 7a ee			ld (debug_mark),a  
a51b 3a 2a a5			ld a, (.dmark+1)  
a51e 32 7b ee			ld (debug_mark+1),a  
a521 3a 2b a5			ld a, (.dmark+2)  
a524 32 7c ee			ld (debug_mark+2),a  
a527 18 03			jr .pastdmark  
a529 ..			.dmark: db "LSt"  
a52c f1			.pastdmark: pop af  
a52d			endm  
# End of macro DMARK
a52d					CALLMONITOR 
a52d cd 7b 91			call break_point_state  
a530				endm  
# End of macro CALLMONITOR
a530				endif 
a530			 
a530			; cant push right now due to tokenised strings  
a530			 
a530			; get the destination of where to copy this definition to. 
a530			 
a530 c5					push bc 
a531 d1					pop de 
a532			 
a532 7e			.listl:         ld a,(hl) 
a533 fe 00				cp 0 
a535 28 09				jr z, .lreplsp     ; replace zero with space 
a537 fe 7f				cp FORTH_END_BUFFER 
a539 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a53b				 
a53b					; just copy this char as is then 
a53b			 
a53b 12					ld (de), a 
a53c			 
a53c 23			.listnxt:	inc hl 
a53d 13					inc de 
a53e 18 f2				jr .listl 
a540			 
a540 3e 20		.lreplsp:	ld a,' ' 
a542 12					ld (de), a 
a543 18 f7				jr .listnxt 
a545			 
a545			; close up uword def 
a545			 
a545			.listdone: 
a545 3e 00				ld a, 0 
a547 12					ld (de), a 
a548			 
a548			; now have def so clean up and push to stack 
a548			 
a548 21 75 e3				ld hl, scratch 
a54b				if DEBUG_FORTH_WORDS 
a54b					DMARK "Ltp" 
a54b f5				push af  
a54c 3a 60 a5			ld a, (.dmark)  
a54f 32 7a ee			ld (debug_mark),a  
a552 3a 61 a5			ld a, (.dmark+1)  
a555 32 7b ee			ld (debug_mark+1),a  
a558 3a 62 a5			ld a, (.dmark+2)  
a55b 32 7c ee			ld (debug_mark+2),a  
a55e 18 03			jr .pastdmark  
a560 ..			.dmark: db "Ltp"  
a563 f1			.pastdmark: pop af  
a564			endm  
# End of macro DMARK
a564					CALLMONITOR 
a564 cd 7b 91			call break_point_state  
a567				endm  
# End of macro CALLMONITOR
a567				endif 
a567			 
a567 18 06			jr .listpush 
a569			 
a569			;.lnuword:	pop hl 
a569			;		call forth_tok_next 
a569			;		jp .ldouscan  
a569			 
a569			.lunotfound:		  
a569			 
a569			 
a569					 
a569					FORTH_DSP_POP 
a569 cd 4c 98			call macro_forth_dsp_pop 
a56c				endm 
# End of macro FORTH_DSP_POP
a56c 21 75 a5				ld hl, .luno 
a56f						 
a56f			 
a56f			.listpush: 
a56f cd 27 97				call forth_push_str 
a572			 
a572			 
a572			 
a572					NEXTW 
a572 c3 06 99			jp macro_next 
a575				endm 
# End of macro NEXTW
a575			 
a575 .. 00		.luno:    db "Not found",0 
a57f			 
a57f			 
a57f			 
a57f			 
a57f			 
a57f			;		push hl   ; save pointer to start of uword def string 
a57f			; 
a57f			;; look for FORTH_EOL_LINE 
a57f			;		ld a, FORTH_END_BUFFER 
a57f			;		call strlent 
a57f			; 
a57f			;		inc hl		 ; space for coln def 
a57f			;		inc hl 
a57f			;		inc hl          ; space for terms 
a57f			;		inc hl 
a57f			; 
a57f			;		ld a, 20   ; TODO get actual length 
a57f			;		call addatohl    ; include a random amount of room for the uword name 
a57f			; 
a57f			;		 
a57f			;	if DEBUG_FORTH_WORDS 
a57f			;		DMARK "Lt1" 
a57f			;		CALLMONITOR 
a57f			;	endif 
a57f			;		 
a57f			; 
a57f			;; malloc space for the string because we cant change it 
a57f			; 
a57f			;		call malloc 
a57f			;	if DEBUG_FORTH_MALLOC_GUARD 
a57f			;		push af 
a57f			;		call ishlzero 
a57f			;		pop af 
a57f			;		 
a57f			;		call z,malloc_error 
a57f			;	endif 
a57f			; 
a57f			;	if DEBUG_FORTH_WORDS 
a57f			;		DMARK "Lt2" 
a57f			;		CALLMONITOR 
a57f			;	endif 
a57f			;		pop de 
a57f			;		push hl    ; push the malloc to release later 
a57f			;		push hl   ;  push back a copy for the later stack push 
a57f			;		 
a57f			;; copy the string swapping out the zero terms for spaces 
a57f			; 
a57f			;		; de has our source 
a57f			;		; hl has our dest 
a57f			; 
a57f			;; add the coln def 
a57f			; 
a57f			;		ld a, ':' 
a57f			;		ld (hl), a 
a57f			;		inc hl 
a57f			;		ld a, ' ' 
a57f			;		ld (hl), a 
a57f			;		inc hl 
a57f			; 
a57f			;; add the uname word 
a57f			;		push de   ; save our string for now 
a57f			;		ex de, hl 
a57f			; 
a57f			;		FORTH_DSP_VALUE 
a57f			;		;v5 FORTH_DSP_VALUE 
a57f			; 
a57f			;		inc hl   ; skip type but we know by now this is OK 
a57f			; 
a57f			;.luword:	ld a,(hl) 
a57f			;		cp 0 
a57f			;		jr z, .luword2 
a57f			;		ld (de), a 
a57f			;		inc de 
a57f			;		inc hl 
a57f			;		jr .luword 
a57f			; 
a57f			;.luword2:	ld a, ' ' 
a57f			;		ld (de), a 
a57f			;;		inc hl 
a57f			;;		inc de 
a57f			;;		ld (de), a 
a57f			;;		inc hl 
a57f			;		inc de 
a57f			; 
a57f			;		ex de, hl 
a57f			;		pop de 
a57f			;		 
a57f			;		 
a57f			; 
a57f			;; detoken that string and copy it 
a57f			; 
a57f			;	if DEBUG_FORTH_WORDS 
a57f			;		DMARK "Lt2" 
a57f			;		CALLMONITOR 
a57f			;	endif 
a57f			;.ldetok:	ld a, (de) 
a57f			;		cp FORTH_END_BUFFER 
a57f			;		jr z, .ldetokend 
a57f			;		; swap out any zero term for space 
a57f			;		cp 0 
a57f			;		jr nz, .ldetoknext 
a57f			;		ld a, ' ' 
a57f			; 
a57f			;	if DEBUG_FORTH_WORDS 
a57f			;		DMARK "LtS" 
a57f			;		CALLMONITOR 
a57f			;	endif 
a57f			;.ldetoknext:	ld (hl), a 
a57f			;		inc de 
a57f			;		inc hl 
a57f			;		jr .ldetok 
a57f			; 
a57f			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a57f			;		ld (hl), a  
a57f			; 
a57f			;; free that temp malloc 
a57f			; 
a57f			;		pop hl    
a57f			; 
a57f			;	if DEBUG_FORTH_WORDS 
a57f			;		DMARK "Lt4" 
a57f			;		CALLMONITOR 
a57f			;	endif 
a57f			;		call forth_apushstrhl 
a57f			; 
a57f			;		; get rid of temp malloc area 
a57f			; 
a57f			;		pop hl 
a57f			;		call free 
a57f			; 
a57f			;		jr .ludone 
a57f			; 
a57f			;.lnuword:	pop hl 
a57f			;		call forth_tok_next 
a57f			;		jp .ldouscan  
a57f			; 
a57f			;.ludone:		 pop hl 
a57f			; 
a57f					NEXTW 
a57f c3 06 99			jp macro_next 
a582				endm 
# End of macro NEXTW
a582			 
a582			.FORGET: 
a582				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a582 5d				db WORD_SYS_CORE+73             
a583 fb a5			dw .NOP            
a585 07				db 6 + 1 
a586 .. 00			db "FORGET",0              
a58d				endm 
# End of macro CWHEAD
a58d			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a58d			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a58d			; | |  
a58d			; | | e.g. "MORE" forget 
a58d					if DEBUG_FORTH_WORDS_KEY 
a58d						DMARK "FRG" 
a58d f5				push af  
a58e 3a a2 a5			ld a, (.dmark)  
a591 32 7a ee			ld (debug_mark),a  
a594 3a a3 a5			ld a, (.dmark+1)  
a597 32 7b ee			ld (debug_mark+1),a  
a59a 3a a4 a5			ld a, (.dmark+2)  
a59d 32 7c ee			ld (debug_mark+2),a  
a5a0 18 03			jr .pastdmark  
a5a2 ..			.dmark: db "FRG"  
a5a5 f1			.pastdmark: pop af  
a5a6			endm  
# End of macro DMARK
a5a6						CALLMONITOR 
a5a6 cd 7b 91			call break_point_state  
a5a9				endm  
# End of macro CALLMONITOR
a5a9					endif 
a5a9			 
a5a9				; find uword 
a5a9			        ; update start of word with "_" 
a5a9				; replace uword with deleted flag 
a5a9			 
a5a9			 
a5a9			;	if DEBUG_FORTH_WORDS 
a5a9			;		DMARK "FOG" 
a5a9			;		CALLMONITOR 
a5a9			;	endif 
a5a9			 
a5a9			 
a5a9					; Get ptr to the word we need to look up 
a5a9			 
a5a9					FORTH_DSP_VALUEHL 
a5a9 cd b0 97			call macro_dsp_valuehl 
a5ac				endm 
# End of macro FORTH_DSP_VALUEHL
a5ac					;v5 FORTH_DSP_VALUE 
a5ac				; TODO type check 
a5ac			;		inc hl    ; Skip type check  
a5ac e5					push hl 
a5ad c1					pop bc 
a5ae			;		ex de, hl    ; put into DE 
a5ae			 
a5ae			 
a5ae 21 b4 d4				ld hl, baseram 
a5b1					;ld hl, baseusermem 
a5b1			 
a5b1				; skip dict stub 
a5b1			;	call forth_tok_next 
a5b1 e5			push hl   ; sacreifical push 
a5b2			 
a5b2			.fldouscanm: 
a5b2 e1				pop hl 
a5b3			.fldouscan: 
a5b3			;	if DEBUG_FORTH_WORDS 
a5b3			;		DMARK "LSs" 
a5b3			;		CALLMONITOR 
a5b3			;	endif 
a5b3				; skip dict stub 
a5b3 cd 57 9a				call forth_tok_next 
a5b6			 
a5b6			 
a5b6			; while we have words to look for 
a5b6			 
a5b6 7e				ld a, (hl)      
a5b7			;	if DEBUG_FORTH_WORDS 
a5b7			;		DMARK "LSk" 
a5b7			;		CALLMONITOR 
a5b7			;	endif 
a5b7 fe 00				cp WORD_SYS_END 
a5b9 ca f5 a5				jp z, .flunotfound 
a5bc fe 01				cp WORD_SYS_UWORD 
a5be c2 b3 a5				jp nz, .fldouscan 
a5c1			 
a5c1			;	if DEBUG_FORTH_WORDS 
a5c1			;		DMARK "LSu" 
a5c1			;		CALLMONITOR 
a5c1			;	endif 
a5c1			 
a5c1					; found a uword but is it the one we want... 
a5c1			 
a5c1 c5					push bc     ; uword to find is on bc 
a5c2 d1					pop de 
a5c3			 
a5c3 e5					push hl  ; to save the ptr 
a5c4			 
a5c4					; skip opcode 
a5c4 23					inc hl  
a5c5					; skip next ptr 
a5c5 23					inc hl  
a5c6 23					inc hl 
a5c7					; skip len 
a5c7 23					inc hl 
a5c8			 
a5c8			;	if DEBUG_FORTH_WORDS 
a5c8			;		DMARK "LSc" 
a5c8			;		CALLMONITOR 
a5c8			;	endif 
a5c8 cd 4d 8e				call strcmp 
a5cb c2 b2 a5				jp nz, .fldouscanm 
a5ce			; 
a5ce			; 
a5ce			;; while we have words to look for 
a5ce			; 
a5ce			;.fdouscan:	ld a, (hl)      
a5ce			;	if DEBUG_FORTH_WORDS 
a5ce			;		DMARK "LSs" 
a5ce			;		CALLMONITOR 
a5ce			;	endif 
a5ce			;		cp WORD_SYS_END 
a5ce			;		jp z, .fudone 
a5ce			;		cp WORD_SYS_UWORD 
a5ce			;		jp nz, .fnuword 
a5ce			; 
a5ce			;	if DEBUG_FORTH_WORDS 
a5ce			;		DMARK "FGu" 
a5ce			;		CALLMONITOR 
a5ce			;	endif 
a5ce			; 
a5ce			;		; found a uword but is it the one we want... 
a5ce			; 
a5ce			; 
a5ce			;	        pop de   ; get back the dsp name 
a5ce			;		push de 
a5ce			; 
a5ce			;		push hl  ; to save the ptr 
a5ce			; 
a5ce			;		; skip opcode 
a5ce			;		inc hl  
a5ce			;		; skip next ptr 
a5ce			;		inc hl  
a5ce			;		inc hl 
a5ce			;		; skip len 
a5ce			;		inc hl 
a5ce			; 
a5ce			;	if DEBUG_FORTH_WORDS 
a5ce			;		DMARK "FGc" 
a5ce			;		CALLMONITOR 
a5ce			;	endif 
a5ce			;		call strcmp 
a5ce			;		jp nz, .fnuword 
a5ce			 
a5ce			 
a5ce e1			pop hl 
a5cf			 
a5cf				 
a5cf				if DEBUG_FORTH_WORDS 
a5cf					DMARK "FGm" 
a5cf f5				push af  
a5d0 3a e4 a5			ld a, (.dmark)  
a5d3 32 7a ee			ld (debug_mark),a  
a5d6 3a e5 a5			ld a, (.dmark+1)  
a5d9 32 7b ee			ld (debug_mark+1),a  
a5dc 3a e6 a5			ld a, (.dmark+2)  
a5df 32 7c ee			ld (debug_mark+2),a  
a5e2 18 03			jr .pastdmark  
a5e4 ..			.dmark: db "FGm"  
a5e7 f1			.pastdmark: pop af  
a5e8			endm  
# End of macro DMARK
a5e8					CALLMONITOR 
a5e8 cd 7b 91			call break_point_state  
a5eb				endm  
# End of macro CALLMONITOR
a5eb				endif 
a5eb			 
a5eb			 
a5eb			 
a5eb					; we have a uword so push its name to the stack 
a5eb			 
a5eb			;	   	push hl  ; save so we can move to next dict block 
a5eb			;pop hl 
a5eb			 
a5eb					; update opcode to deleted 
a5eb 3e 03				ld a, WORD_SYS_DELETED 
a5ed 77					ld (hl), a 
a5ee			 
a5ee 23					inc hl  
a5ef					; skip next ptr 
a5ef 23					inc hl  
a5f0 23					inc hl 
a5f1					; skip len 
a5f1 23					inc hl 
a5f2			 
a5f2					; TODO change parser to skip deleted words but for now mark it out 
a5f2 3e 5f				ld a, "_" 
a5f4 77					ld  (hl),a 
a5f5			 
a5f5			;		jr .fudone 
a5f5			; 
a5f5			;.fnuword:	pop hl 
a5f5			;		call forth_tok_next 
a5f5			;		jp .fdouscan  
a5f5			 
a5f5			.flunotfound:		  
a5f5			 
a5f5			 
a5f5					 
a5f5					FORTH_DSP_POP 
a5f5 cd 4c 98			call macro_forth_dsp_pop 
a5f8				endm 
# End of macro FORTH_DSP_POP
a5f8			;		ld hl, .luno 
a5f8			;.fudone:		 pop hl 
a5f8					NEXTW 
a5f8 c3 06 99			jp macro_next 
a5fb				endm 
# End of macro NEXTW
a5fb			.NOP: 
a5fb				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a5fb 61				db WORD_SYS_CORE+77             
a5fc 22 a6			dw .COMO            
a5fe 04				db 3 + 1 
a5ff .. 00			db "NOP",0              
a603				endm 
# End of macro CWHEAD
a603			; | NOP (  --  ) Do nothing | DONE 
a603					if DEBUG_FORTH_WORDS_KEY 
a603						DMARK "NOP" 
a603 f5				push af  
a604 3a 18 a6			ld a, (.dmark)  
a607 32 7a ee			ld (debug_mark),a  
a60a 3a 19 a6			ld a, (.dmark+1)  
a60d 32 7b ee			ld (debug_mark+1),a  
a610 3a 1a a6			ld a, (.dmark+2)  
a613 32 7c ee			ld (debug_mark+2),a  
a616 18 03			jr .pastdmark  
a618 ..			.dmark: db "NOP"  
a61b f1			.pastdmark: pop af  
a61c			endm  
# End of macro DMARK
a61c						CALLMONITOR 
a61c cd 7b 91			call break_point_state  
a61f				endm  
# End of macro CALLMONITOR
a61f					endif 
a61f				       NEXTW 
a61f c3 06 99			jp macro_next 
a622				endm 
# End of macro NEXTW
a622			.COMO: 
a622				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a622 6e				db WORD_SYS_CORE+90             
a623 74 a6			dw .COMC            
a625 02				db 1 + 1 
a626 .. 00			db "(",0              
a628				endm 
# End of macro CWHEAD
a628			; | ( ( -- )  Start of comment | DONE 
a628			 
a628			 
a628 2a 76 e6				ld hl, ( os_tok_ptr) 
a62b 11 6f a6			ld de, .closepar 
a62e					 
a62e					if DEBUG_FORTH_WORDS 
a62e						DMARK ").." 
a62e f5				push af  
a62f 3a 43 a6			ld a, (.dmark)  
a632 32 7a ee			ld (debug_mark),a  
a635 3a 44 a6			ld a, (.dmark+1)  
a638 32 7b ee			ld (debug_mark+1),a  
a63b 3a 45 a6			ld a, (.dmark+2)  
a63e 32 7c ee			ld (debug_mark+2),a  
a641 18 03			jr .pastdmark  
a643 ..			.dmark: db ").."  
a646 f1			.pastdmark: pop af  
a647			endm  
# End of macro DMARK
a647						CALLMONITOR 
a647 cd 7b 91			call break_point_state  
a64a				endm  
# End of macro CALLMONITOR
a64a					endif 
a64a cd 21 9a			call findnexttok  
a64d			 
a64d					if DEBUG_FORTH_WORDS 
a64d						DMARK "IF5" 
a64d f5				push af  
a64e 3a 62 a6			ld a, (.dmark)  
a651 32 7a ee			ld (debug_mark),a  
a654 3a 63 a6			ld a, (.dmark+1)  
a657 32 7b ee			ld (debug_mark+1),a  
a65a 3a 64 a6			ld a, (.dmark+2)  
a65d 32 7c ee			ld (debug_mark+2),a  
a660 18 03			jr .pastdmark  
a662 ..			.dmark: db "IF5"  
a665 f1			.pastdmark: pop af  
a666			endm  
# End of macro DMARK
a666						CALLMONITOR 
a666 cd 7b 91			call break_point_state  
a669				endm  
# End of macro CALLMONITOR
a669					endif 
a669				; replace below with ) exec using tok_ptr 
a669 22 76 e6			ld (os_tok_ptr), hl 
a66c c3 97 99			jp exec1 
a66f			 
a66f .. 00			.closepar:   db ")",0 
a671			 
a671				       NEXTW 
a671 c3 06 99			jp macro_next 
a674				endm 
# End of macro NEXTW
a674			.COMC: 
a674				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a674 6f				db WORD_SYS_CORE+91             
a675 7d a6			dw .SCRATCH            
a677 02				db 1 + 1 
a678 .. 00			db ")",0              
a67a				endm 
# End of macro CWHEAD
a67a			; | ) ( -- )  End of comment |  DONE  
a67a				       NEXTW 
a67a c3 06 99			jp macro_next 
a67d				endm 
# End of macro NEXTW
a67d			 
a67d			.SCRATCH: 
a67d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a67d 6f				db WORD_SYS_CORE+91             
a67e b8 a6			dw .INC            
a680 08				db 7 + 1 
a681 .. 00			db "SCRATCH",0              
a689				endm 
# End of macro CWHEAD
a689			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a689			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a689			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a689			; | |  
a689			; | | e.g.    : score $00 scratch ; 
a689			; | |  
a689			; | | $00 score ! 
a689			; | | $01 score +! 
a689			; | |  
a689			; | | e.g.   : varword $0a scratch ;  
a689			; | | 
a689			; | | $8000 varword ! 
a689					if DEBUG_FORTH_WORDS_KEY 
a689						DMARK "SCR" 
a689 f5				push af  
a68a 3a 9e a6			ld a, (.dmark)  
a68d 32 7a ee			ld (debug_mark),a  
a690 3a 9f a6			ld a, (.dmark+1)  
a693 32 7b ee			ld (debug_mark+1),a  
a696 3a a0 a6			ld a, (.dmark+2)  
a699 32 7c ee			ld (debug_mark+2),a  
a69c 18 03			jr .pastdmark  
a69e ..			.dmark: db "SCR"  
a6a1 f1			.pastdmark: pop af  
a6a2			endm  
# End of macro DMARK
a6a2						CALLMONITOR 
a6a2 cd 7b 91			call break_point_state  
a6a5				endm  
# End of macro CALLMONITOR
a6a5					endif 
a6a5			 
a6a5					FORTH_DSP_VALUEHL 
a6a5 cd b0 97			call macro_dsp_valuehl 
a6a8				endm 
# End of macro FORTH_DSP_VALUEHL
a6a8				 
a6a8					FORTH_DSP_POP 
a6a8 cd 4c 98			call macro_forth_dsp_pop 
a6ab				endm 
# End of macro FORTH_DSP_POP
a6ab			 
a6ab 7d					ld a, l 
a6ac 21 9a e8				ld hl, os_var_array 
a6af cd b7 89				call addatohl 
a6b2			 
a6b2 cd 15 97				call forth_push_numhl 
a6b5			 
a6b5				       NEXTW 
a6b5 c3 06 99			jp macro_next 
a6b8				endm 
# End of macro NEXTW
a6b8			 
a6b8			.INC: 
a6b8				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a6b8 6f				db WORD_SYS_CORE+91             
a6b9 0c a7			dw .DEC            
a6bb 03				db 2 + 1 
a6bc .. 00			db "+!",0              
a6bf				endm 
# End of macro CWHEAD
a6bf			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a6bf					if DEBUG_FORTH_WORDS_KEY 
a6bf						DMARK "+s_" 
a6bf f5				push af  
a6c0 3a d4 a6			ld a, (.dmark)  
a6c3 32 7a ee			ld (debug_mark),a  
a6c6 3a d5 a6			ld a, (.dmark+1)  
a6c9 32 7b ee			ld (debug_mark+1),a  
a6cc 3a d6 a6			ld a, (.dmark+2)  
a6cf 32 7c ee			ld (debug_mark+2),a  
a6d2 18 03			jr .pastdmark  
a6d4 ..			.dmark: db "+s_"  
a6d7 f1			.pastdmark: pop af  
a6d8			endm  
# End of macro DMARK
a6d8						CALLMONITOR 
a6d8 cd 7b 91			call break_point_state  
a6db				endm  
# End of macro CALLMONITOR
a6db					endif 
a6db			 
a6db					FORTH_DSP_VALUEHL 
a6db cd b0 97			call macro_dsp_valuehl 
a6de				endm 
# End of macro FORTH_DSP_VALUEHL
a6de			 
a6de e5					push hl   ; save address 
a6df			 
a6df					FORTH_DSP_POP 
a6df cd 4c 98			call macro_forth_dsp_pop 
a6e2				endm 
# End of macro FORTH_DSP_POP
a6e2			 
a6e2					FORTH_DSP_VALUEHL 
a6e2 cd b0 97			call macro_dsp_valuehl 
a6e5				endm 
# End of macro FORTH_DSP_VALUEHL
a6e5			 
a6e5					FORTH_DSP_POP 
a6e5 cd 4c 98			call macro_forth_dsp_pop 
a6e8				endm 
# End of macro FORTH_DSP_POP
a6e8			 
a6e8					; hl contains value to add to byte at a 
a6e8				 
a6e8 eb					ex de, hl 
a6e9			 
a6e9 e1					pop hl 
a6ea			 
a6ea					if DEBUG_FORTH_WORDS 
a6ea						DMARK "INC" 
a6ea f5				push af  
a6eb 3a ff a6			ld a, (.dmark)  
a6ee 32 7a ee			ld (debug_mark),a  
a6f1 3a 00 a7			ld a, (.dmark+1)  
a6f4 32 7b ee			ld (debug_mark+1),a  
a6f7 3a 01 a7			ld a, (.dmark+2)  
a6fa 32 7c ee			ld (debug_mark+2),a  
a6fd 18 03			jr .pastdmark  
a6ff ..			.dmark: db "INC"  
a702 f1			.pastdmark: pop af  
a703			endm  
# End of macro DMARK
a703						CALLMONITOR 
a703 cd 7b 91			call break_point_state  
a706				endm  
# End of macro CALLMONITOR
a706					endif 
a706			 
a706 7e					ld a,(hl) 
a707 83					add e 
a708 77					ld (hl),a 
a709			 
a709			 
a709			 
a709				       NEXTW 
a709 c3 06 99			jp macro_next 
a70c				endm 
# End of macro NEXTW
a70c			 
a70c			.DEC: 
a70c				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a70c 6f				db WORD_SYS_CORE+91             
a70d 5d a7			dw .INC2            
a70f 03				db 2 + 1 
a710 .. 00			db "-!",0              
a713				endm 
# End of macro CWHEAD
a713			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a713					if DEBUG_FORTH_WORDS_KEY 
a713						DMARK "-s_" 
a713 f5				push af  
a714 3a 28 a7			ld a, (.dmark)  
a717 32 7a ee			ld (debug_mark),a  
a71a 3a 29 a7			ld a, (.dmark+1)  
a71d 32 7b ee			ld (debug_mark+1),a  
a720 3a 2a a7			ld a, (.dmark+2)  
a723 32 7c ee			ld (debug_mark+2),a  
a726 18 03			jr .pastdmark  
a728 ..			.dmark: db "-s_"  
a72b f1			.pastdmark: pop af  
a72c			endm  
# End of macro DMARK
a72c						CALLMONITOR 
a72c cd 7b 91			call break_point_state  
a72f				endm  
# End of macro CALLMONITOR
a72f					endif 
a72f			 
a72f					FORTH_DSP_VALUEHL 
a72f cd b0 97			call macro_dsp_valuehl 
a732				endm 
# End of macro FORTH_DSP_VALUEHL
a732			 
a732 e5					push hl   ; save address 
a733			 
a733					FORTH_DSP_POP 
a733 cd 4c 98			call macro_forth_dsp_pop 
a736				endm 
# End of macro FORTH_DSP_POP
a736			 
a736					FORTH_DSP_VALUEHL 
a736 cd b0 97			call macro_dsp_valuehl 
a739				endm 
# End of macro FORTH_DSP_VALUEHL
a739			 
a739					; hl contains value to add to byte at a 
a739				 
a739 eb					ex de, hl 
a73a			 
a73a e1					pop hl 
a73b			 
a73b					if DEBUG_FORTH_WORDS 
a73b						DMARK "DEC" 
a73b f5				push af  
a73c 3a 50 a7			ld a, (.dmark)  
a73f 32 7a ee			ld (debug_mark),a  
a742 3a 51 a7			ld a, (.dmark+1)  
a745 32 7b ee			ld (debug_mark+1),a  
a748 3a 52 a7			ld a, (.dmark+2)  
a74b 32 7c ee			ld (debug_mark+2),a  
a74e 18 03			jr .pastdmark  
a750 ..			.dmark: db "DEC"  
a753 f1			.pastdmark: pop af  
a754			endm  
# End of macro DMARK
a754						CALLMONITOR 
a754 cd 7b 91			call break_point_state  
a757				endm  
# End of macro CALLMONITOR
a757					endif 
a757			 
a757 7e					ld a,(hl) 
a758 93					sub e 
a759 77					ld (hl),a 
a75a			 
a75a			 
a75a			 
a75a				       NEXTW 
a75a c3 06 99			jp macro_next 
a75d				endm 
# End of macro NEXTW
a75d			 
a75d			.INC2: 
a75d				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a75d 6f				db WORD_SYS_CORE+91             
a75e 07 a8			dw .DEC2            
a760 04				db 3 + 1 
a761 .. 00			db "+2!",0              
a765				endm 
# End of macro CWHEAD
a765			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a765			 
a765					if DEBUG_FORTH_WORDS_KEY 
a765						DMARK "+2s" 
a765 f5				push af  
a766 3a 7a a7			ld a, (.dmark)  
a769 32 7a ee			ld (debug_mark),a  
a76c 3a 7b a7			ld a, (.dmark+1)  
a76f 32 7b ee			ld (debug_mark+1),a  
a772 3a 7c a7			ld a, (.dmark+2)  
a775 32 7c ee			ld (debug_mark+2),a  
a778 18 03			jr .pastdmark  
a77a ..			.dmark: db "+2s"  
a77d f1			.pastdmark: pop af  
a77e			endm  
# End of macro DMARK
a77e						CALLMONITOR 
a77e cd 7b 91			call break_point_state  
a781				endm  
# End of macro CALLMONITOR
a781					endif 
a781			 
a781					; Address 
a781			 
a781					FORTH_DSP_VALUEHL 
a781 cd b0 97			call macro_dsp_valuehl 
a784				endm 
# End of macro FORTH_DSP_VALUEHL
a784			 
a784 e5					push hl    ; save address 
a785			 
a785					; load content into de 
a785			 
a785 5e					ld e,(hl) 
a786 23					inc hl 
a787 56					ld d, (hl) 
a788			 
a788					if DEBUG_FORTH_WORDS 
a788						DMARK "+2a" 
a788 f5				push af  
a789 3a 9d a7			ld a, (.dmark)  
a78c 32 7a ee			ld (debug_mark),a  
a78f 3a 9e a7			ld a, (.dmark+1)  
a792 32 7b ee			ld (debug_mark+1),a  
a795 3a 9f a7			ld a, (.dmark+2)  
a798 32 7c ee			ld (debug_mark+2),a  
a79b 18 03			jr .pastdmark  
a79d ..			.dmark: db "+2a"  
a7a0 f1			.pastdmark: pop af  
a7a1			endm  
# End of macro DMARK
a7a1						CALLMONITOR 
a7a1 cd 7b 91			call break_point_state  
a7a4				endm  
# End of macro CALLMONITOR
a7a4					endif 
a7a4			 
a7a4					FORTH_DSP_POP 
a7a4 cd 4c 98			call macro_forth_dsp_pop 
a7a7				endm 
# End of macro FORTH_DSP_POP
a7a7			 
a7a7					; Get value to add 
a7a7			 
a7a7					FORTH_DSP_VALUE 
a7a7 cd 99 97			call macro_forth_dsp_value 
a7aa				endm 
# End of macro FORTH_DSP_VALUE
a7aa			 
a7aa					if DEBUG_FORTH_WORDS 
a7aa						DMARK "+2v" 
a7aa f5				push af  
a7ab 3a bf a7			ld a, (.dmark)  
a7ae 32 7a ee			ld (debug_mark),a  
a7b1 3a c0 a7			ld a, (.dmark+1)  
a7b4 32 7b ee			ld (debug_mark+1),a  
a7b7 3a c1 a7			ld a, (.dmark+2)  
a7ba 32 7c ee			ld (debug_mark+2),a  
a7bd 18 03			jr .pastdmark  
a7bf ..			.dmark: db "+2v"  
a7c2 f1			.pastdmark: pop af  
a7c3			endm  
# End of macro DMARK
a7c3						CALLMONITOR 
a7c3 cd 7b 91			call break_point_state  
a7c6				endm  
# End of macro CALLMONITOR
a7c6					endif 
a7c6			 
a7c6 19					add hl, de 
a7c7			 
a7c7					if DEBUG_FORTH_WORDS 
a7c7						DMARK "+2+" 
a7c7 f5				push af  
a7c8 3a dc a7			ld a, (.dmark)  
a7cb 32 7a ee			ld (debug_mark),a  
a7ce 3a dd a7			ld a, (.dmark+1)  
a7d1 32 7b ee			ld (debug_mark+1),a  
a7d4 3a de a7			ld a, (.dmark+2)  
a7d7 32 7c ee			ld (debug_mark+2),a  
a7da 18 03			jr .pastdmark  
a7dc ..			.dmark: db "+2+"  
a7df f1			.pastdmark: pop af  
a7e0			endm  
# End of macro DMARK
a7e0						CALLMONITOR 
a7e0 cd 7b 91			call break_point_state  
a7e3				endm  
# End of macro CALLMONITOR
a7e3					endif 
a7e3			 
a7e3					; move result to de 
a7e3			 
a7e3 eb					ex de, hl 
a7e4			 
a7e4					; Address 
a7e4			 
a7e4 e1					pop hl 
a7e5			 
a7e5					; save it back 
a7e5			 
a7e5 73					ld (hl), e 
a7e6 23					inc hl 
a7e7 72					ld (hl), d 
a7e8			 
a7e8					if DEBUG_FORTH_WORDS 
a7e8						DMARK "+2e" 
a7e8 f5				push af  
a7e9 3a fd a7			ld a, (.dmark)  
a7ec 32 7a ee			ld (debug_mark),a  
a7ef 3a fe a7			ld a, (.dmark+1)  
a7f2 32 7b ee			ld (debug_mark+1),a  
a7f5 3a ff a7			ld a, (.dmark+2)  
a7f8 32 7c ee			ld (debug_mark+2),a  
a7fb 18 03			jr .pastdmark  
a7fd ..			.dmark: db "+2e"  
a800 f1			.pastdmark: pop af  
a801			endm  
# End of macro DMARK
a801						CALLMONITOR 
a801 cd 7b 91			call break_point_state  
a804				endm  
# End of macro CALLMONITOR
a804					endif 
a804			 
a804			 
a804			 
a804			 
a804			 
a804				       NEXTW 
a804 c3 06 99			jp macro_next 
a807				endm 
# End of macro NEXTW
a807			 
a807			.DEC2: 
a807				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a807 6f				db WORD_SYS_CORE+91             
a808 b3 a8			dw .GET2            
a80a 04				db 3 + 1 
a80b .. 00			db "-2!",0              
a80f				endm 
# End of macro CWHEAD
a80f			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a80f			 
a80f			 
a80f					if DEBUG_FORTH_WORDS_KEY 
a80f						DMARK "-2s" 
a80f f5				push af  
a810 3a 24 a8			ld a, (.dmark)  
a813 32 7a ee			ld (debug_mark),a  
a816 3a 25 a8			ld a, (.dmark+1)  
a819 32 7b ee			ld (debug_mark+1),a  
a81c 3a 26 a8			ld a, (.dmark+2)  
a81f 32 7c ee			ld (debug_mark+2),a  
a822 18 03			jr .pastdmark  
a824 ..			.dmark: db "-2s"  
a827 f1			.pastdmark: pop af  
a828			endm  
# End of macro DMARK
a828						CALLMONITOR 
a828 cd 7b 91			call break_point_state  
a82b				endm  
# End of macro CALLMONITOR
a82b					endif 
a82b			 
a82b					; Address 
a82b			 
a82b					FORTH_DSP_VALUEHL 
a82b cd b0 97			call macro_dsp_valuehl 
a82e				endm 
# End of macro FORTH_DSP_VALUEHL
a82e			 
a82e e5					push hl    ; save address 
a82f			 
a82f					; load content into de 
a82f			 
a82f 5e					ld e,(hl) 
a830 23					inc hl 
a831 56					ld d, (hl) 
a832			 
a832					if DEBUG_FORTH_WORDS 
a832						DMARK "-2a" 
a832 f5				push af  
a833 3a 47 a8			ld a, (.dmark)  
a836 32 7a ee			ld (debug_mark),a  
a839 3a 48 a8			ld a, (.dmark+1)  
a83c 32 7b ee			ld (debug_mark+1),a  
a83f 3a 49 a8			ld a, (.dmark+2)  
a842 32 7c ee			ld (debug_mark+2),a  
a845 18 03			jr .pastdmark  
a847 ..			.dmark: db "-2a"  
a84a f1			.pastdmark: pop af  
a84b			endm  
# End of macro DMARK
a84b						CALLMONITOR 
a84b cd 7b 91			call break_point_state  
a84e				endm  
# End of macro CALLMONITOR
a84e					endif 
a84e			 
a84e					FORTH_DSP_POP 
a84e cd 4c 98			call macro_forth_dsp_pop 
a851				endm 
# End of macro FORTH_DSP_POP
a851			 
a851					; Get value to remove 
a851			 
a851					FORTH_DSP_VALUE 
a851 cd 99 97			call macro_forth_dsp_value 
a854				endm 
# End of macro FORTH_DSP_VALUE
a854			 
a854					if DEBUG_FORTH_WORDS 
a854						DMARK "-2v" 
a854 f5				push af  
a855 3a 69 a8			ld a, (.dmark)  
a858 32 7a ee			ld (debug_mark),a  
a85b 3a 6a a8			ld a, (.dmark+1)  
a85e 32 7b ee			ld (debug_mark+1),a  
a861 3a 6b a8			ld a, (.dmark+2)  
a864 32 7c ee			ld (debug_mark+2),a  
a867 18 03			jr .pastdmark  
a869 ..			.dmark: db "-2v"  
a86c f1			.pastdmark: pop af  
a86d			endm  
# End of macro DMARK
a86d						CALLMONITOR 
a86d cd 7b 91			call break_point_state  
a870				endm  
# End of macro CALLMONITOR
a870					endif 
a870			 
a870 eb					ex de, hl 
a871 ed 52				sbc hl, de 
a873			 
a873					if DEBUG_FORTH_WORDS 
a873						DMARK "-2d" 
a873 f5				push af  
a874 3a 88 a8			ld a, (.dmark)  
a877 32 7a ee			ld (debug_mark),a  
a87a 3a 89 a8			ld a, (.dmark+1)  
a87d 32 7b ee			ld (debug_mark+1),a  
a880 3a 8a a8			ld a, (.dmark+2)  
a883 32 7c ee			ld (debug_mark+2),a  
a886 18 03			jr .pastdmark  
a888 ..			.dmark: db "-2d"  
a88b f1			.pastdmark: pop af  
a88c			endm  
# End of macro DMARK
a88c						CALLMONITOR 
a88c cd 7b 91			call break_point_state  
a88f				endm  
# End of macro CALLMONITOR
a88f					endif 
a88f			 
a88f					; move result to de 
a88f			 
a88f eb					ex de, hl 
a890			 
a890					; Address 
a890			 
a890 e1					pop hl 
a891			 
a891					; save it back 
a891			 
a891 73					ld (hl), e 
a892 23					inc hl 
a893 72					ld (hl), d 
a894			 
a894					if DEBUG_FORTH_WORDS 
a894						DMARK "-2e" 
a894 f5				push af  
a895 3a a9 a8			ld a, (.dmark)  
a898 32 7a ee			ld (debug_mark),a  
a89b 3a aa a8			ld a, (.dmark+1)  
a89e 32 7b ee			ld (debug_mark+1),a  
a8a1 3a ab a8			ld a, (.dmark+2)  
a8a4 32 7c ee			ld (debug_mark+2),a  
a8a7 18 03			jr .pastdmark  
a8a9 ..			.dmark: db "-2e"  
a8ac f1			.pastdmark: pop af  
a8ad			endm  
# End of macro DMARK
a8ad						CALLMONITOR 
a8ad cd 7b 91			call break_point_state  
a8b0				endm  
# End of macro CALLMONITOR
a8b0					endif 
a8b0			 
a8b0			 
a8b0			 
a8b0			 
a8b0			 
a8b0				       NEXTW 
a8b0 c3 06 99			jp macro_next 
a8b3				endm 
# End of macro NEXTW
a8b3			.GET2: 
a8b3				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
a8b3 6f				db WORD_SYS_CORE+91             
a8b4 e3 a8			dw .BANG2            
a8b6 03				db 2 + 1 
a8b7 .. 00			db "2@",0              
a8ba				endm 
# End of macro CWHEAD
a8ba			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
a8ba					if DEBUG_FORTH_WORDS_KEY 
a8ba						DMARK "2A_" 
a8ba f5				push af  
a8bb 3a cf a8			ld a, (.dmark)  
a8be 32 7a ee			ld (debug_mark),a  
a8c1 3a d0 a8			ld a, (.dmark+1)  
a8c4 32 7b ee			ld (debug_mark+1),a  
a8c7 3a d1 a8			ld a, (.dmark+2)  
a8ca 32 7c ee			ld (debug_mark+2),a  
a8cd 18 03			jr .pastdmark  
a8cf ..			.dmark: db "2A_"  
a8d2 f1			.pastdmark: pop af  
a8d3			endm  
# End of macro DMARK
a8d3						CALLMONITOR 
a8d3 cd 7b 91			call break_point_state  
a8d6				endm  
# End of macro CALLMONITOR
a8d6					endif 
a8d6			 
a8d6					FORTH_DSP_VALUEHL 
a8d6 cd b0 97			call macro_dsp_valuehl 
a8d9				endm 
# End of macro FORTH_DSP_VALUEHL
a8d9			 
a8d9 5e					ld e, (hl) 
a8da 23					inc hl 
a8db 56					ld d, (hl) 
a8dc			 
a8dc eb					ex de, hl 
a8dd			 
a8dd cd 15 97				call forth_push_numhl 
a8e0			 
a8e0				       NEXTW 
a8e0 c3 06 99			jp macro_next 
a8e3				endm 
# End of macro NEXTW
a8e3			.BANG2: 
a8e3				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
a8e3 6f				db WORD_SYS_CORE+91             
a8e4 1b a9			dw .ENDCORE            
a8e6 03				db 2 + 1 
a8e7 .. 00			db "2!",0              
a8ea				endm 
# End of macro CWHEAD
a8ea			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
a8ea					if DEBUG_FORTH_WORDS_KEY 
a8ea						DMARK "2S_" 
a8ea f5				push af  
a8eb 3a ff a8			ld a, (.dmark)  
a8ee 32 7a ee			ld (debug_mark),a  
a8f1 3a 00 a9			ld a, (.dmark+1)  
a8f4 32 7b ee			ld (debug_mark+1),a  
a8f7 3a 01 a9			ld a, (.dmark+2)  
a8fa 32 7c ee			ld (debug_mark+2),a  
a8fd 18 03			jr .pastdmark  
a8ff ..			.dmark: db "2S_"  
a902 f1			.pastdmark: pop af  
a903			endm  
# End of macro DMARK
a903						CALLMONITOR 
a903 cd 7b 91			call break_point_state  
a906				endm  
# End of macro CALLMONITOR
a906					endif 
a906			 
a906					FORTH_DSP_VALUEHL 
a906 cd b0 97			call macro_dsp_valuehl 
a909				endm 
# End of macro FORTH_DSP_VALUEHL
a909			 
a909 e5					push hl   ; save address 
a90a			 
a90a			 
a90a					FORTH_DSP_POP 
a90a cd 4c 98			call macro_forth_dsp_pop 
a90d				endm 
# End of macro FORTH_DSP_POP
a90d			 
a90d					 
a90d					FORTH_DSP_VALUEHL 
a90d cd b0 97			call macro_dsp_valuehl 
a910				endm 
# End of macro FORTH_DSP_VALUEHL
a910			 
a910					FORTH_DSP_POP 
a910 cd 4c 98			call macro_forth_dsp_pop 
a913				endm 
# End of macro FORTH_DSP_POP
a913			 
a913 eb					ex de, hl    ; value now in de 
a914			 
a914 e1					pop hl 
a915			 
a915 73					ld (hl), e 
a916			 
a916 23					inc hl 
a917			 
a917 72					ld (hl), d 
a918			 
a918			 
a918				       NEXTW 
a918 c3 06 99			jp macro_next 
a91b				endm 
# End of macro NEXTW
a91b			.ENDCORE: 
a91b			 
a91b			; eof 
a91b			 
a91b			 
# End of file forth_words_core.asm
a91b			include "forth_words_flow.asm" 
a91b			 
a91b			; | ## Program Flow Words 
a91b			 
a91b			.IF: 
a91b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
a91b 1e				db WORD_SYS_CORE+10             
a91c 10 aa			dw .THEN            
a91e 03				db 2 + 1 
a91f .. 00			db "IF",0              
a922				endm 
# End of macro CWHEAD
a922			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
a922			; 
a922					if DEBUG_FORTH_WORDS_KEY 
a922						DMARK "IF." 
a922 f5				push af  
a923 3a 37 a9			ld a, (.dmark)  
a926 32 7a ee			ld (debug_mark),a  
a929 3a 38 a9			ld a, (.dmark+1)  
a92c 32 7b ee			ld (debug_mark+1),a  
a92f 3a 39 a9			ld a, (.dmark+2)  
a932 32 7c ee			ld (debug_mark+2),a  
a935 18 03			jr .pastdmark  
a937 ..			.dmark: db "IF."  
a93a f1			.pastdmark: pop af  
a93b			endm  
# End of macro DMARK
a93b						CALLMONITOR 
a93b cd 7b 91			call break_point_state  
a93e				endm  
# End of macro CALLMONITOR
a93e					endif 
a93e			; eval TOS 
a93e			 
a93e				FORTH_DSP_VALUEHL 
a93e cd b0 97			call macro_dsp_valuehl 
a941				endm 
# End of macro FORTH_DSP_VALUEHL
a941			 
a941			;	push hl 
a941				FORTH_DSP_POP 
a941 cd 4c 98			call macro_forth_dsp_pop 
a944				endm 
# End of macro FORTH_DSP_POP
a944			;	pop hl 
a944			 
a944					if DEBUG_FORTH_WORDS 
a944						DMARK "IF1" 
a944 f5				push af  
a945 3a 59 a9			ld a, (.dmark)  
a948 32 7a ee			ld (debug_mark),a  
a94b 3a 5a a9			ld a, (.dmark+1)  
a94e 32 7b ee			ld (debug_mark+1),a  
a951 3a 5b a9			ld a, (.dmark+2)  
a954 32 7c ee			ld (debug_mark+2),a  
a957 18 03			jr .pastdmark  
a959 ..			.dmark: db "IF1"  
a95c f1			.pastdmark: pop af  
a95d			endm  
# End of macro DMARK
a95d						CALLMONITOR 
a95d cd 7b 91			call break_point_state  
a960				endm  
# End of macro CALLMONITOR
a960					endif 
a960 b7				or a        ; clear carry flag 
a961 11 00 00			ld de, 0 
a964 eb				ex de,hl 
a965 ed 52			sbc hl, de 
a967 c2 f1 a9			jp nz, .iftrue 
a96a			 
a96a					if DEBUG_FORTH_WORDS 
a96a						DMARK "IF2" 
a96a f5				push af  
a96b 3a 7f a9			ld a, (.dmark)  
a96e 32 7a ee			ld (debug_mark),a  
a971 3a 80 a9			ld a, (.dmark+1)  
a974 32 7b ee			ld (debug_mark+1),a  
a977 3a 81 a9			ld a, (.dmark+2)  
a97a 32 7c ee			ld (debug_mark+2),a  
a97d 18 03			jr .pastdmark  
a97f ..			.dmark: db "IF2"  
a982 f1			.pastdmark: pop af  
a983			endm  
# End of macro DMARK
a983						CALLMONITOR 
a983 cd 7b 91			call break_point_state  
a986				endm  
# End of macro CALLMONITOR
a986					endif 
a986			 
a986			; if not true then skip to THEN 
a986			 
a986				; TODO get tok_ptr 
a986				; TODO consume toks until we get to THEN 
a986			 
a986 2a 76 e6			ld hl, (os_tok_ptr) 
a989					if DEBUG_FORTH_WORDS 
a989						DMARK "IF3" 
a989 f5				push af  
a98a 3a 9e a9			ld a, (.dmark)  
a98d 32 7a ee			ld (debug_mark),a  
a990 3a 9f a9			ld a, (.dmark+1)  
a993 32 7b ee			ld (debug_mark+1),a  
a996 3a a0 a9			ld a, (.dmark+2)  
a999 32 7c ee			ld (debug_mark+2),a  
a99c 18 03			jr .pastdmark  
a99e ..			.dmark: db "IF3"  
a9a1 f1			.pastdmark: pop af  
a9a2			endm  
# End of macro DMARK
a9a2						CALLMONITOR 
a9a2 cd 7b 91			call break_point_state  
a9a5				endm  
# End of macro CALLMONITOR
a9a5						 
a9a5					endif 
a9a5 11 ec a9			ld de, .ifthen 
a9a8					if DEBUG_FORTH_WORDS 
a9a8						DMARK "IF4" 
a9a8 f5				push af  
a9a9 3a bd a9			ld a, (.dmark)  
a9ac 32 7a ee			ld (debug_mark),a  
a9af 3a be a9			ld a, (.dmark+1)  
a9b2 32 7b ee			ld (debug_mark+1),a  
a9b5 3a bf a9			ld a, (.dmark+2)  
a9b8 32 7c ee			ld (debug_mark+2),a  
a9bb 18 03			jr .pastdmark  
a9bd ..			.dmark: db "IF4"  
a9c0 f1			.pastdmark: pop af  
a9c1			endm  
# End of macro DMARK
a9c1						CALLMONITOR 
a9c1 cd 7b 91			call break_point_state  
a9c4				endm  
# End of macro CALLMONITOR
a9c4					endif 
a9c4 cd 21 9a			call findnexttok  
a9c7			 
a9c7					if DEBUG_FORTH_WORDS 
a9c7						DMARK "IF5" 
a9c7 f5				push af  
a9c8 3a dc a9			ld a, (.dmark)  
a9cb 32 7a ee			ld (debug_mark),a  
a9ce 3a dd a9			ld a, (.dmark+1)  
a9d1 32 7b ee			ld (debug_mark+1),a  
a9d4 3a de a9			ld a, (.dmark+2)  
a9d7 32 7c ee			ld (debug_mark+2),a  
a9da 18 03			jr .pastdmark  
a9dc ..			.dmark: db "IF5"  
a9df f1			.pastdmark: pop af  
a9e0			endm  
# End of macro DMARK
a9e0						CALLMONITOR 
a9e0 cd 7b 91			call break_point_state  
a9e3				endm  
# End of macro CALLMONITOR
a9e3					endif 
a9e3				; TODO replace below with ; exec using tok_ptr 
a9e3 22 76 e6			ld (os_tok_ptr), hl 
a9e6 c3 97 99			jp exec1 
a9e9				NEXTW 
a9e9 c3 06 99			jp macro_next 
a9ec				endm 
# End of macro NEXTW
a9ec			 
a9ec .. 00		.ifthen:  db "THEN",0 
a9f1			 
a9f1			.iftrue:		 
a9f1				; Exec next words normally 
a9f1			 
a9f1				; if true then exec following IF as normal 
a9f1					if DEBUG_FORTH_WORDS 
a9f1						DMARK "IFT" 
a9f1 f5				push af  
a9f2 3a 06 aa			ld a, (.dmark)  
a9f5 32 7a ee			ld (debug_mark),a  
a9f8 3a 07 aa			ld a, (.dmark+1)  
a9fb 32 7b ee			ld (debug_mark+1),a  
a9fe 3a 08 aa			ld a, (.dmark+2)  
aa01 32 7c ee			ld (debug_mark+2),a  
aa04 18 03			jr .pastdmark  
aa06 ..			.dmark: db "IFT"  
aa09 f1			.pastdmark: pop af  
aa0a			endm  
# End of macro DMARK
aa0a						CALLMONITOR 
aa0a cd 7b 91			call break_point_state  
aa0d				endm  
# End of macro CALLMONITOR
aa0d					endif 
aa0d			 
aa0d					NEXTW 
aa0d c3 06 99			jp macro_next 
aa10				endm 
# End of macro NEXTW
aa10			.THEN: 
aa10				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aa10 1f				db WORD_SYS_CORE+11             
aa11 38 aa			dw .ELSE            
aa13 05				db 4 + 1 
aa14 .. 00			db "THEN",0              
aa19				endm 
# End of macro CWHEAD
aa19			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aa19					if DEBUG_FORTH_WORDS_KEY 
aa19						DMARK "THN" 
aa19 f5				push af  
aa1a 3a 2e aa			ld a, (.dmark)  
aa1d 32 7a ee			ld (debug_mark),a  
aa20 3a 2f aa			ld a, (.dmark+1)  
aa23 32 7b ee			ld (debug_mark+1),a  
aa26 3a 30 aa			ld a, (.dmark+2)  
aa29 32 7c ee			ld (debug_mark+2),a  
aa2c 18 03			jr .pastdmark  
aa2e ..			.dmark: db "THN"  
aa31 f1			.pastdmark: pop af  
aa32			endm  
# End of macro DMARK
aa32						CALLMONITOR 
aa32 cd 7b 91			call break_point_state  
aa35				endm  
# End of macro CALLMONITOR
aa35					endif 
aa35					NEXTW 
aa35 c3 06 99			jp macro_next 
aa38				endm 
# End of macro NEXTW
aa38			.ELSE: 
aa38				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aa38 20				db WORD_SYS_CORE+12             
aa39 60 aa			dw .DO            
aa3b 03				db 2 + 1 
aa3c .. 00			db "ELSE",0              
aa41				endm 
# End of macro CWHEAD
aa41			; | ELSE ( -- ) Not supported - does nothing | TODO 
aa41			 
aa41					if DEBUG_FORTH_WORDS_KEY 
aa41						DMARK "ELS" 
aa41 f5				push af  
aa42 3a 56 aa			ld a, (.dmark)  
aa45 32 7a ee			ld (debug_mark),a  
aa48 3a 57 aa			ld a, (.dmark+1)  
aa4b 32 7b ee			ld (debug_mark+1),a  
aa4e 3a 58 aa			ld a, (.dmark+2)  
aa51 32 7c ee			ld (debug_mark+2),a  
aa54 18 03			jr .pastdmark  
aa56 ..			.dmark: db "ELS"  
aa59 f1			.pastdmark: pop af  
aa5a			endm  
# End of macro DMARK
aa5a						CALLMONITOR 
aa5a cd 7b 91			call break_point_state  
aa5d				endm  
# End of macro CALLMONITOR
aa5d					endif 
aa5d			 
aa5d			 
aa5d					NEXTW 
aa5d c3 06 99			jp macro_next 
aa60				endm 
# End of macro NEXTW
aa60			.DO: 
aa60				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aa60 21				db WORD_SYS_CORE+13             
aa61 87 ab			dw .LOOP            
aa63 03				db 2 + 1 
aa64 .. 00			db "DO",0              
aa67				endm 
# End of macro CWHEAD
aa67			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aa67			 
aa67					if DEBUG_FORTH_WORDS_KEY 
aa67						DMARK "DO." 
aa67 f5				push af  
aa68 3a 7c aa			ld a, (.dmark)  
aa6b 32 7a ee			ld (debug_mark),a  
aa6e 3a 7d aa			ld a, (.dmark+1)  
aa71 32 7b ee			ld (debug_mark+1),a  
aa74 3a 7e aa			ld a, (.dmark+2)  
aa77 32 7c ee			ld (debug_mark+2),a  
aa7a 18 03			jr .pastdmark  
aa7c ..			.dmark: db "DO."  
aa7f f1			.pastdmark: pop af  
aa80			endm  
# End of macro DMARK
aa80						CALLMONITOR 
aa80 cd 7b 91			call break_point_state  
aa83				endm  
# End of macro CALLMONITOR
aa83					endif 
aa83			;  push pc to rsp stack past the DO 
aa83			 
aa83 2a 76 e6				ld hl, (os_tok_ptr) 
aa86 23					inc hl   ; D 
aa87 23					inc hl  ; O 
aa88 23					inc hl   ; null 
aa89					if DEBUG_FORTH_WORDS 
aa89						DMARK "DO2" 
aa89 f5				push af  
aa8a 3a 9e aa			ld a, (.dmark)  
aa8d 32 7a ee			ld (debug_mark),a  
aa90 3a 9f aa			ld a, (.dmark+1)  
aa93 32 7b ee			ld (debug_mark+1),a  
aa96 3a a0 aa			ld a, (.dmark+2)  
aa99 32 7c ee			ld (debug_mark+2),a  
aa9c 18 03			jr .pastdmark  
aa9e ..			.dmark: db "DO2"  
aaa1 f1			.pastdmark: pop af  
aaa2			endm  
# End of macro DMARK
aaa2						CALLMONITOR 
aaa2 cd 7b 91			call break_point_state  
aaa5				endm  
# End of macro CALLMONITOR
aaa5					endif 
aaa5					FORTH_RSP_NEXT 
aaa5 cd bc 96			call macro_forth_rsp_next 
aaa8				endm 
# End of macro FORTH_RSP_NEXT
aaa8					if DEBUG_FORTH_WORDS 
aaa8						DMARK "DO3" 
aaa8 f5				push af  
aaa9 3a bd aa			ld a, (.dmark)  
aaac 32 7a ee			ld (debug_mark),a  
aaaf 3a be aa			ld a, (.dmark+1)  
aab2 32 7b ee			ld (debug_mark+1),a  
aab5 3a bf aa			ld a, (.dmark+2)  
aab8 32 7c ee			ld (debug_mark+2),a  
aabb 18 03			jr .pastdmark  
aabd ..			.dmark: db "DO3"  
aac0 f1			.pastdmark: pop af  
aac1			endm  
# End of macro DMARK
aac1						CALLMONITOR 
aac1 cd 7b 91			call break_point_state  
aac4				endm  
# End of macro CALLMONITOR
aac4					endif 
aac4			 
aac4					;if DEBUG_FORTH_WORDS 
aac4				;		push hl 
aac4			;		endif  
aac4			 
aac4			; get counters from data stack 
aac4			 
aac4			 
aac4					FORTH_DSP_VALUEHL 
aac4 cd b0 97			call macro_dsp_valuehl 
aac7				endm 
# End of macro FORTH_DSP_VALUEHL
aac7 e5					push hl		 ; hl now has starting counter which needs to be tos 
aac8			 
aac8					if DEBUG_FORTH_WORDS 
aac8						DMARK "DO4" 
aac8 f5				push af  
aac9 3a dd aa			ld a, (.dmark)  
aacc 32 7a ee			ld (debug_mark),a  
aacf 3a de aa			ld a, (.dmark+1)  
aad2 32 7b ee			ld (debug_mark+1),a  
aad5 3a df aa			ld a, (.dmark+2)  
aad8 32 7c ee			ld (debug_mark+2),a  
aadb 18 03			jr .pastdmark  
aadd ..			.dmark: db "DO4"  
aae0 f1			.pastdmark: pop af  
aae1			endm  
# End of macro DMARK
aae1						CALLMONITOR 
aae1 cd 7b 91			call break_point_state  
aae4				endm  
# End of macro CALLMONITOR
aae4					endif 
aae4					FORTH_DSP_POP 
aae4 cd 4c 98			call macro_forth_dsp_pop 
aae7				endm 
# End of macro FORTH_DSP_POP
aae7			 
aae7					if DEBUG_FORTH_WORDS 
aae7						DMARK "DO5" 
aae7 f5				push af  
aae8 3a fc aa			ld a, (.dmark)  
aaeb 32 7a ee			ld (debug_mark),a  
aaee 3a fd aa			ld a, (.dmark+1)  
aaf1 32 7b ee			ld (debug_mark+1),a  
aaf4 3a fe aa			ld a, (.dmark+2)  
aaf7 32 7c ee			ld (debug_mark+2),a  
aafa 18 03			jr .pastdmark  
aafc ..			.dmark: db "DO5"  
aaff f1			.pastdmark: pop af  
ab00			endm  
# End of macro DMARK
ab00						CALLMONITOR 
ab00 cd 7b 91			call break_point_state  
ab03				endm  
# End of macro CALLMONITOR
ab03					endif 
ab03			 
ab03					FORTH_DSP_VALUEHL 
ab03 cd b0 97			call macro_dsp_valuehl 
ab06				endm 
# End of macro FORTH_DSP_VALUEHL
ab06			;		push hl		 ; hl now has starting limit counter 
ab06			 
ab06					if DEBUG_FORTH_WORDS 
ab06						DMARK "DO6" 
ab06 f5				push af  
ab07 3a 1b ab			ld a, (.dmark)  
ab0a 32 7a ee			ld (debug_mark),a  
ab0d 3a 1c ab			ld a, (.dmark+1)  
ab10 32 7b ee			ld (debug_mark+1),a  
ab13 3a 1d ab			ld a, (.dmark+2)  
ab16 32 7c ee			ld (debug_mark+2),a  
ab19 18 03			jr .pastdmark  
ab1b ..			.dmark: db "DO6"  
ab1e f1			.pastdmark: pop af  
ab1f			endm  
# End of macro DMARK
ab1f						CALLMONITOR 
ab1f cd 7b 91			call break_point_state  
ab22				endm  
# End of macro CALLMONITOR
ab22					endif 
ab22					FORTH_DSP_POP 
ab22 cd 4c 98			call macro_forth_dsp_pop 
ab25				endm 
# End of macro FORTH_DSP_POP
ab25			 
ab25			; put counters on the loop stack 
ab25			 
ab25			;		pop hl			 ; limit counter 
ab25 d1					pop de			; start counter 
ab26			 
ab26					; push limit counter 
ab26			 
ab26					if DEBUG_FORTH_WORDS 
ab26						DMARK "DO7" 
ab26 f5				push af  
ab27 3a 3b ab			ld a, (.dmark)  
ab2a 32 7a ee			ld (debug_mark),a  
ab2d 3a 3c ab			ld a, (.dmark+1)  
ab30 32 7b ee			ld (debug_mark+1),a  
ab33 3a 3d ab			ld a, (.dmark+2)  
ab36 32 7c ee			ld (debug_mark+2),a  
ab39 18 03			jr .pastdmark  
ab3b ..			.dmark: db "DO7"  
ab3e f1			.pastdmark: pop af  
ab3f			endm  
# End of macro DMARK
ab3f						CALLMONITOR 
ab3f cd 7b 91			call break_point_state  
ab42				endm  
# End of macro CALLMONITOR
ab42					endif 
ab42					FORTH_LOOP_NEXT 
ab42 cd c5 97			call macro_forth_loop_next 
ab45				endm 
# End of macro FORTH_LOOP_NEXT
ab45			 
ab45					; push start counter 
ab45			 
ab45 eb					ex de, hl 
ab46					if DEBUG_FORTH_WORDS 
ab46						DMARK "DO7" 
ab46 f5				push af  
ab47 3a 5b ab			ld a, (.dmark)  
ab4a 32 7a ee			ld (debug_mark),a  
ab4d 3a 5c ab			ld a, (.dmark+1)  
ab50 32 7b ee			ld (debug_mark+1),a  
ab53 3a 5d ab			ld a, (.dmark+2)  
ab56 32 7c ee			ld (debug_mark+2),a  
ab59 18 03			jr .pastdmark  
ab5b ..			.dmark: db "DO7"  
ab5e f1			.pastdmark: pop af  
ab5f			endm  
# End of macro DMARK
ab5f						CALLMONITOR 
ab5f cd 7b 91			call break_point_state  
ab62				endm  
# End of macro CALLMONITOR
ab62					endif 
ab62					FORTH_LOOP_NEXT 
ab62 cd c5 97			call macro_forth_loop_next 
ab65				endm 
# End of macro FORTH_LOOP_NEXT
ab65			 
ab65			 
ab65					; init first round of I counter 
ab65			 
ab65 22 9a e6				ld (os_current_i), hl 
ab68			 
ab68					if DEBUG_FORTH_WORDS 
ab68						DMARK "DO8" 
ab68 f5				push af  
ab69 3a 7d ab			ld a, (.dmark)  
ab6c 32 7a ee			ld (debug_mark),a  
ab6f 3a 7e ab			ld a, (.dmark+1)  
ab72 32 7b ee			ld (debug_mark+1),a  
ab75 3a 7f ab			ld a, (.dmark+2)  
ab78 32 7c ee			ld (debug_mark+2),a  
ab7b 18 03			jr .pastdmark  
ab7d ..			.dmark: db "DO8"  
ab80 f1			.pastdmark: pop af  
ab81			endm  
# End of macro DMARK
ab81						CALLMONITOR 
ab81 cd 7b 91			call break_point_state  
ab84				endm  
# End of macro CALLMONITOR
ab84					endif 
ab84			 
ab84					NEXTW 
ab84 c3 06 99			jp macro_next 
ab87				endm 
# End of macro NEXTW
ab87			.LOOP: 
ab87				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ab87 22				db WORD_SYS_CORE+14             
ab88 9f ac			dw .I            
ab8a 05				db 4 + 1 
ab8b .. 00			db "LOOP",0              
ab90				endm 
# End of macro CWHEAD
ab90			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ab90			 
ab90				; pop tos as current loop count to hl 
ab90			 
ab90				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ab90			 
ab90				FORTH_LOOP_TOS 
ab90 cd f8 97			call macro_forth_loop_tos 
ab93				endm 
# End of macro FORTH_LOOP_TOS
ab93 e5				push hl 
ab94			 
ab94					if DEBUG_FORTH_WORDS_KEY 
ab94						DMARK "LOP" 
ab94 f5				push af  
ab95 3a a9 ab			ld a, (.dmark)  
ab98 32 7a ee			ld (debug_mark),a  
ab9b 3a aa ab			ld a, (.dmark+1)  
ab9e 32 7b ee			ld (debug_mark+1),a  
aba1 3a ab ab			ld a, (.dmark+2)  
aba4 32 7c ee			ld (debug_mark+2),a  
aba7 18 03			jr .pastdmark  
aba9 ..			.dmark: db "LOP"  
abac f1			.pastdmark: pop af  
abad			endm  
# End of macro DMARK
abad						CALLMONITOR 
abad cd 7b 91			call break_point_state  
abb0				endm  
# End of macro CALLMONITOR
abb0					endif 
abb0				; next item on the stack is the limit. get it 
abb0			 
abb0			 
abb0				FORTH_LOOP_POP 
abb0 cd 02 98			call macro_forth_loop_pop 
abb3				endm 
# End of macro FORTH_LOOP_POP
abb3			 
abb3				FORTH_LOOP_TOS 
abb3 cd f8 97			call macro_forth_loop_tos 
abb6				endm 
# End of macro FORTH_LOOP_TOS
abb6			 
abb6 d1				pop de		 ; de = i, hl = limit 
abb7			 
abb7					if DEBUG_FORTH_WORDS 
abb7						DMARK "LP1" 
abb7 f5				push af  
abb8 3a cc ab			ld a, (.dmark)  
abbb 32 7a ee			ld (debug_mark),a  
abbe 3a cd ab			ld a, (.dmark+1)  
abc1 32 7b ee			ld (debug_mark+1),a  
abc4 3a ce ab			ld a, (.dmark+2)  
abc7 32 7c ee			ld (debug_mark+2),a  
abca 18 03			jr .pastdmark  
abcc ..			.dmark: db "LP1"  
abcf f1			.pastdmark: pop af  
abd0			endm  
# End of macro DMARK
abd0						CALLMONITOR 
abd0 cd 7b 91			call break_point_state  
abd3				endm  
# End of macro CALLMONITOR
abd3					endif 
abd3			 
abd3				; go back to previous word 
abd3			 
abd3 d5				push de    ; save I for inc later 
abd4			 
abd4			 
abd4				; get limit 
abd4				;  is I at limit? 
abd4			 
abd4			 
abd4					if DEBUG_FORTH_WORDS 
abd4						DMARK "LP1" 
abd4 f5				push af  
abd5 3a e9 ab			ld a, (.dmark)  
abd8 32 7a ee			ld (debug_mark),a  
abdb 3a ea ab			ld a, (.dmark+1)  
abde 32 7b ee			ld (debug_mark+1),a  
abe1 3a eb ab			ld a, (.dmark+2)  
abe4 32 7c ee			ld (debug_mark+2),a  
abe7 18 03			jr .pastdmark  
abe9 ..			.dmark: db "LP1"  
abec f1			.pastdmark: pop af  
abed			endm  
# End of macro DMARK
abed						CALLMONITOR 
abed cd 7b 91			call break_point_state  
abf0				endm  
# End of macro CALLMONITOR
abf0					endif 
abf0			 
abf0 ed 52			sbc hl, de 
abf2			 
abf2			 
abf2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
abf2			 
abf2 20 26				jr nz, .loopnotdone 
abf4			 
abf4 e1				pop hl   ; get rid of saved I 
abf5				FORTH_LOOP_POP     ; get rid of limit 
abf5 cd 02 98			call macro_forth_loop_pop 
abf8				endm 
# End of macro FORTH_LOOP_POP
abf8			 
abf8				FORTH_RSP_POP     ; get rid of DO ptr 
abf8 cd dd 96			call macro_forth_rsp_pop 
abfb				endm 
# End of macro FORTH_RSP_POP
abfb			 
abfb			if DEBUG_FORTH_WORDS 
abfb						DMARK "LP>" 
abfb f5				push af  
abfc 3a 10 ac			ld a, (.dmark)  
abff 32 7a ee			ld (debug_mark),a  
ac02 3a 11 ac			ld a, (.dmark+1)  
ac05 32 7b ee			ld (debug_mark+1),a  
ac08 3a 12 ac			ld a, (.dmark+2)  
ac0b 32 7c ee			ld (debug_mark+2),a  
ac0e 18 03			jr .pastdmark  
ac10 ..			.dmark: db "LP>"  
ac13 f1			.pastdmark: pop af  
ac14			endm  
# End of macro DMARK
ac14				CALLMONITOR 
ac14 cd 7b 91			call break_point_state  
ac17				endm  
# End of macro CALLMONITOR
ac17			endif 
ac17			 
ac17					NEXTW 
ac17 c3 06 99			jp macro_next 
ac1a				endm 
# End of macro NEXTW
ac1a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ac1a			 
ac1a			.loopnotdone: 
ac1a			 
ac1a e1				pop hl    ; get I 
ac1b 23				inc hl 
ac1c			 
ac1c			   	; save new I 
ac1c			 
ac1c			 
ac1c					; set I counter 
ac1c			 
ac1c 22 9a e6				ld (os_current_i), hl 
ac1f			 
ac1f					if DEBUG_FORTH_WORDS 
ac1f						DMARK "LPN" 
ac1f f5				push af  
ac20 3a 34 ac			ld a, (.dmark)  
ac23 32 7a ee			ld (debug_mark),a  
ac26 3a 35 ac			ld a, (.dmark+1)  
ac29 32 7b ee			ld (debug_mark+1),a  
ac2c 3a 36 ac			ld a, (.dmark+2)  
ac2f 32 7c ee			ld (debug_mark+2),a  
ac32 18 03			jr .pastdmark  
ac34 ..			.dmark: db "LPN"  
ac37 f1			.pastdmark: pop af  
ac38			endm  
# End of macro DMARK
ac38					CALLMONITOR 
ac38 cd 7b 91			call break_point_state  
ac3b				endm  
# End of macro CALLMONITOR
ac3b					endif 
ac3b					 
ac3b				FORTH_LOOP_NEXT 
ac3b cd c5 97			call macro_forth_loop_next 
ac3e				endm 
# End of macro FORTH_LOOP_NEXT
ac3e			 
ac3e			 
ac3e					if DEBUG_FORTH_WORDS 
ac3e eb						ex de,hl 
ac3f					endif 
ac3f			 
ac3f			;	; get DO ptr 
ac3f			; 
ac3f					if DEBUG_FORTH_WORDS 
ac3f						DMARK "LP7" 
ac3f f5				push af  
ac40 3a 54 ac			ld a, (.dmark)  
ac43 32 7a ee			ld (debug_mark),a  
ac46 3a 55 ac			ld a, (.dmark+1)  
ac49 32 7b ee			ld (debug_mark+1),a  
ac4c 3a 56 ac			ld a, (.dmark+2)  
ac4f 32 7c ee			ld (debug_mark+2),a  
ac52 18 03			jr .pastdmark  
ac54 ..			.dmark: db "LP7"  
ac57 f1			.pastdmark: pop af  
ac58			endm  
# End of macro DMARK
ac58					CALLMONITOR 
ac58 cd 7b 91			call break_point_state  
ac5b				endm  
# End of macro CALLMONITOR
ac5b					endif 
ac5b				FORTH_RSP_TOS 
ac5b cd d3 96			call macro_forth_rsp_tos 
ac5e				endm 
# End of macro FORTH_RSP_TOS
ac5e			 
ac5e					if DEBUG_FORTH_WORDS 
ac5e						DMARK "LP8" 
ac5e f5				push af  
ac5f 3a 73 ac			ld a, (.dmark)  
ac62 32 7a ee			ld (debug_mark),a  
ac65 3a 74 ac			ld a, (.dmark+1)  
ac68 32 7b ee			ld (debug_mark+1),a  
ac6b 3a 75 ac			ld a, (.dmark+2)  
ac6e 32 7c ee			ld (debug_mark+2),a  
ac71 18 03			jr .pastdmark  
ac73 ..			.dmark: db "LP8"  
ac76 f1			.pastdmark: pop af  
ac77			endm  
# End of macro DMARK
ac77					CALLMONITOR 
ac77 cd 7b 91			call break_point_state  
ac7a				endm  
# End of macro CALLMONITOR
ac7a					endif 
ac7a				;push hl 
ac7a			 
ac7a				; not going to DO any more 
ac7a				; get rid of the RSP pointer as DO will add it back in 
ac7a				;FORTH_RSP_POP 
ac7a				;pop hl 
ac7a			 
ac7a				;ld hl,(cli_ret_sp) 
ac7a				;ld e, (hl) 
ac7a				;inc hl 
ac7a				;ld d, (hl) 
ac7a				;ex de,hl 
ac7a 22 76 e6			ld (os_tok_ptr), hl 
ac7d					if DEBUG_FORTH_WORDS 
ac7d						DMARK "LP<" 
ac7d f5				push af  
ac7e 3a 92 ac			ld a, (.dmark)  
ac81 32 7a ee			ld (debug_mark),a  
ac84 3a 93 ac			ld a, (.dmark+1)  
ac87 32 7b ee			ld (debug_mark+1),a  
ac8a 3a 94 ac			ld a, (.dmark+2)  
ac8d 32 7c ee			ld (debug_mark+2),a  
ac90 18 03			jr .pastdmark  
ac92 ..			.dmark: db "LP<"  
ac95 f1			.pastdmark: pop af  
ac96			endm  
# End of macro DMARK
ac96					CALLMONITOR 
ac96 cd 7b 91			call break_point_state  
ac99				endm  
# End of macro CALLMONITOR
ac99				endif 
ac99 c3 97 99			jp exec1 
ac9c			 
ac9c					 
ac9c			 
ac9c			 
ac9c					NEXTW 
ac9c c3 06 99			jp macro_next 
ac9f				endm 
# End of macro NEXTW
ac9f			.I:  
ac9f			 
ac9f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
ac9f 5e				db WORD_SYS_CORE+74             
aca0 ca ac			dw .DLOOP            
aca2 02				db 1 + 1 
aca3 .. 00			db "I",0              
aca5				endm 
# End of macro CWHEAD
aca5			; | I ( -- ) Current loop counter | DONE 
aca5					if DEBUG_FORTH_WORDS_KEY 
aca5						DMARK "I.." 
aca5 f5				push af  
aca6 3a ba ac			ld a, (.dmark)  
aca9 32 7a ee			ld (debug_mark),a  
acac 3a bb ac			ld a, (.dmark+1)  
acaf 32 7b ee			ld (debug_mark+1),a  
acb2 3a bc ac			ld a, (.dmark+2)  
acb5 32 7c ee			ld (debug_mark+2),a  
acb8 18 03			jr .pastdmark  
acba ..			.dmark: db "I.."  
acbd f1			.pastdmark: pop af  
acbe			endm  
# End of macro DMARK
acbe						CALLMONITOR 
acbe cd 7b 91			call break_point_state  
acc1				endm  
# End of macro CALLMONITOR
acc1					endif 
acc1			 
acc1 2a 9a e6				ld hl,(os_current_i) 
acc4 cd 15 97				call forth_push_numhl 
acc7			 
acc7					NEXTW 
acc7 c3 06 99			jp macro_next 
acca				endm 
# End of macro NEXTW
acca			.DLOOP: 
acca				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
acca 5f				db WORD_SYS_CORE+75             
accb ab ad			dw .REPEAT            
accd 06				db 5 + 1 
acce .. 00			db "-LOOP",0              
acd4				endm 
# End of macro CWHEAD
acd4			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
acd4				; pop tos as current loop count to hl 
acd4					if DEBUG_FORTH_WORDS_KEY 
acd4						DMARK "-LP" 
acd4 f5				push af  
acd5 3a e9 ac			ld a, (.dmark)  
acd8 32 7a ee			ld (debug_mark),a  
acdb 3a ea ac			ld a, (.dmark+1)  
acde 32 7b ee			ld (debug_mark+1),a  
ace1 3a eb ac			ld a, (.dmark+2)  
ace4 32 7c ee			ld (debug_mark+2),a  
ace7 18 03			jr .pastdmark  
ace9 ..			.dmark: db "-LP"  
acec f1			.pastdmark: pop af  
aced			endm  
# End of macro DMARK
aced						CALLMONITOR 
aced cd 7b 91			call break_point_state  
acf0				endm  
# End of macro CALLMONITOR
acf0					endif 
acf0			 
acf0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
acf0			 
acf0				FORTH_LOOP_TOS 
acf0 cd f8 97			call macro_forth_loop_tos 
acf3				endm 
# End of macro FORTH_LOOP_TOS
acf3 e5				push hl 
acf4			 
acf4					if DEBUG_FORTH_WORDS 
acf4						DMARK "-LP" 
acf4 f5				push af  
acf5 3a 09 ad			ld a, (.dmark)  
acf8 32 7a ee			ld (debug_mark),a  
acfb 3a 0a ad			ld a, (.dmark+1)  
acfe 32 7b ee			ld (debug_mark+1),a  
ad01 3a 0b ad			ld a, (.dmark+2)  
ad04 32 7c ee			ld (debug_mark+2),a  
ad07 18 03			jr .pastdmark  
ad09 ..			.dmark: db "-LP"  
ad0c f1			.pastdmark: pop af  
ad0d			endm  
# End of macro DMARK
ad0d						CALLMONITOR 
ad0d cd 7b 91			call break_point_state  
ad10				endm  
# End of macro CALLMONITOR
ad10					endif 
ad10				; next item on the stack is the limit. get it 
ad10			 
ad10			 
ad10				FORTH_LOOP_POP 
ad10 cd 02 98			call macro_forth_loop_pop 
ad13				endm 
# End of macro FORTH_LOOP_POP
ad13			 
ad13				FORTH_LOOP_TOS 
ad13 cd f8 97			call macro_forth_loop_tos 
ad16				endm 
# End of macro FORTH_LOOP_TOS
ad16			 
ad16 d1				pop de		 ; de = i, hl = limit 
ad17			 
ad17					if DEBUG_FORTH_WORDS 
ad17						DMARK "-L1" 
ad17 f5				push af  
ad18 3a 2c ad			ld a, (.dmark)  
ad1b 32 7a ee			ld (debug_mark),a  
ad1e 3a 2d ad			ld a, (.dmark+1)  
ad21 32 7b ee			ld (debug_mark+1),a  
ad24 3a 2e ad			ld a, (.dmark+2)  
ad27 32 7c ee			ld (debug_mark+2),a  
ad2a 18 03			jr .pastdmark  
ad2c ..			.dmark: db "-L1"  
ad2f f1			.pastdmark: pop af  
ad30			endm  
# End of macro DMARK
ad30						CALLMONITOR 
ad30 cd 7b 91			call break_point_state  
ad33				endm  
# End of macro CALLMONITOR
ad33					endif 
ad33			 
ad33				; go back to previous word 
ad33			 
ad33 d5				push de    ; save I for inc later 
ad34			 
ad34			 
ad34				; get limit 
ad34				;  is I at limit? 
ad34			 
ad34			 
ad34					if DEBUG_FORTH_WORDS 
ad34						DMARK "-L1" 
ad34 f5				push af  
ad35 3a 49 ad			ld a, (.dmark)  
ad38 32 7a ee			ld (debug_mark),a  
ad3b 3a 4a ad			ld a, (.dmark+1)  
ad3e 32 7b ee			ld (debug_mark+1),a  
ad41 3a 4b ad			ld a, (.dmark+2)  
ad44 32 7c ee			ld (debug_mark+2),a  
ad47 18 03			jr .pastdmark  
ad49 ..			.dmark: db "-L1"  
ad4c f1			.pastdmark: pop af  
ad4d			endm  
# End of macro DMARK
ad4d						CALLMONITOR 
ad4d cd 7b 91			call break_point_state  
ad50				endm  
# End of macro CALLMONITOR
ad50					endif 
ad50			 
ad50 ed 52			sbc hl, de 
ad52			 
ad52			 
ad52				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ad52			 
ad52 20 26				jr nz, .mloopnotdone 
ad54			 
ad54 e1				pop hl   ; get rid of saved I 
ad55				FORTH_LOOP_POP     ; get rid of limit 
ad55 cd 02 98			call macro_forth_loop_pop 
ad58				endm 
# End of macro FORTH_LOOP_POP
ad58			 
ad58				FORTH_RSP_POP     ; get rid of DO ptr 
ad58 cd dd 96			call macro_forth_rsp_pop 
ad5b				endm 
# End of macro FORTH_RSP_POP
ad5b			 
ad5b			if DEBUG_FORTH_WORDS 
ad5b						DMARK "-L>" 
ad5b f5				push af  
ad5c 3a 70 ad			ld a, (.dmark)  
ad5f 32 7a ee			ld (debug_mark),a  
ad62 3a 71 ad			ld a, (.dmark+1)  
ad65 32 7b ee			ld (debug_mark+1),a  
ad68 3a 72 ad			ld a, (.dmark+2)  
ad6b 32 7c ee			ld (debug_mark+2),a  
ad6e 18 03			jr .pastdmark  
ad70 ..			.dmark: db "-L>"  
ad73 f1			.pastdmark: pop af  
ad74			endm  
# End of macro DMARK
ad74				CALLMONITOR 
ad74 cd 7b 91			call break_point_state  
ad77				endm  
# End of macro CALLMONITOR
ad77			endif 
ad77			 
ad77					NEXTW 
ad77 c3 06 99			jp macro_next 
ad7a				endm 
# End of macro NEXTW
ad7a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ad7a			 
ad7a			.mloopnotdone: 
ad7a			 
ad7a e1				pop hl    ; get I 
ad7b 2b				dec hl 
ad7c			 
ad7c			   	; save new I 
ad7c			 
ad7c			 
ad7c					; set I counter 
ad7c			 
ad7c 22 9a e6				ld (os_current_i), hl 
ad7f			 
ad7f					 
ad7f				FORTH_LOOP_NEXT 
ad7f cd c5 97			call macro_forth_loop_next 
ad82				endm 
# End of macro FORTH_LOOP_NEXT
ad82			 
ad82			 
ad82					if DEBUG_FORTH_WORDS 
ad82 eb						ex de,hl 
ad83					endif 
ad83			 
ad83			;	; get DO ptr 
ad83			; 
ad83				FORTH_RSP_TOS 
ad83 cd d3 96			call macro_forth_rsp_tos 
ad86				endm 
# End of macro FORTH_RSP_TOS
ad86			 
ad86				;push hl 
ad86			 
ad86				; not going to DO any more 
ad86				; get rid of the RSP pointer as DO will add it back in 
ad86				;FORTH_RSP_POP 
ad86				;pop hl 
ad86			 
ad86			 
ad86 22 76 e6			ld (os_tok_ptr), hl 
ad89					if DEBUG_FORTH_WORDS 
ad89						DMARK "-L<" 
ad89 f5				push af  
ad8a 3a 9e ad			ld a, (.dmark)  
ad8d 32 7a ee			ld (debug_mark),a  
ad90 3a 9f ad			ld a, (.dmark+1)  
ad93 32 7b ee			ld (debug_mark+1),a  
ad96 3a a0 ad			ld a, (.dmark+2)  
ad99 32 7c ee			ld (debug_mark+2),a  
ad9c 18 03			jr .pastdmark  
ad9e ..			.dmark: db "-L<"  
ada1 f1			.pastdmark: pop af  
ada2			endm  
# End of macro DMARK
ada2					CALLMONITOR 
ada2 cd 7b 91			call break_point_state  
ada5				endm  
# End of macro CALLMONITOR
ada5				endif 
ada5 c3 97 99			jp exec1 
ada8			 
ada8					 
ada8			 
ada8			 
ada8			 
ada8				NEXTW 
ada8 c3 06 99			jp macro_next 
adab				endm 
# End of macro NEXTW
adab			 
adab			 
adab			 
adab			 
adab			.REPEAT: 
adab				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
adab 71				db WORD_SYS_CORE+93             
adac fe ad			dw .UNTIL            
adae 06				db 5 + 1 
adaf .. 00			db "REPEAT",0              
adb6				endm 
# End of macro CWHEAD
adb6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
adb6			;  push pc to rsp stack past the REPEAT 
adb6					if DEBUG_FORTH_WORDS_KEY 
adb6						DMARK "REP" 
adb6 f5				push af  
adb7 3a cb ad			ld a, (.dmark)  
adba 32 7a ee			ld (debug_mark),a  
adbd 3a cc ad			ld a, (.dmark+1)  
adc0 32 7b ee			ld (debug_mark+1),a  
adc3 3a cd ad			ld a, (.dmark+2)  
adc6 32 7c ee			ld (debug_mark+2),a  
adc9 18 03			jr .pastdmark  
adcb ..			.dmark: db "REP"  
adce f1			.pastdmark: pop af  
adcf			endm  
# End of macro DMARK
adcf						CALLMONITOR 
adcf cd 7b 91			call break_point_state  
add2				endm  
# End of macro CALLMONITOR
add2					endif 
add2			 
add2 2a 76 e6				ld hl, (os_tok_ptr) 
add5 23					inc hl   ; R 
add6 23					inc hl  ; E 
add7 23					inc hl   ; P 
add8 23					inc hl   ; E 
add9 23					inc hl   ; A 
adda 23					inc hl   ; T 
addb 23					inc hl   ; zero 
addc					FORTH_RSP_NEXT 
addc cd bc 96			call macro_forth_rsp_next 
addf				endm 
# End of macro FORTH_RSP_NEXT
addf			 
addf			 
addf					if DEBUG_FORTH_WORDS 
addf						DMARK "REP" 
addf f5				push af  
ade0 3a f4 ad			ld a, (.dmark)  
ade3 32 7a ee			ld (debug_mark),a  
ade6 3a f5 ad			ld a, (.dmark+1)  
ade9 32 7b ee			ld (debug_mark+1),a  
adec 3a f6 ad			ld a, (.dmark+2)  
adef 32 7c ee			ld (debug_mark+2),a  
adf2 18 03			jr .pastdmark  
adf4 ..			.dmark: db "REP"  
adf7 f1			.pastdmark: pop af  
adf8			endm  
# End of macro DMARK
adf8						;pop bc    ; TODO BUG ?????? what is this for???? 
adf8						CALLMONITOR 
adf8 cd 7b 91			call break_point_state  
adfb				endm  
# End of macro CALLMONITOR
adfb					endif 
adfb			 
adfb					NEXTW 
adfb c3 06 99			jp macro_next 
adfe				endm 
# End of macro NEXTW
adfe			;	       NEXTW 
adfe			 
adfe			.UNTIL: 
adfe				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
adfe 72				db WORD_SYS_CORE+94             
adff 95 ae			dw .ENDFLOW            
ae01 06				db 5 + 1 
ae02 .. 00			db "UNTIL",0              
ae08				endm 
# End of macro CWHEAD
ae08			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
ae08			 
ae08				; pop tos as check 
ae08			 
ae08				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ae08			 
ae08				FORTH_DSP_VALUEHL 
ae08 cd b0 97			call macro_dsp_valuehl 
ae0b				endm 
# End of macro FORTH_DSP_VALUEHL
ae0b			 
ae0b					if DEBUG_FORTH_WORDS_KEY 
ae0b						DMARK "UNT" 
ae0b f5				push af  
ae0c 3a 20 ae			ld a, (.dmark)  
ae0f 32 7a ee			ld (debug_mark),a  
ae12 3a 21 ae			ld a, (.dmark+1)  
ae15 32 7b ee			ld (debug_mark+1),a  
ae18 3a 22 ae			ld a, (.dmark+2)  
ae1b 32 7c ee			ld (debug_mark+2),a  
ae1e 18 03			jr .pastdmark  
ae20 ..			.dmark: db "UNT"  
ae23 f1			.pastdmark: pop af  
ae24			endm  
# End of macro DMARK
ae24						CALLMONITOR 
ae24 cd 7b 91			call break_point_state  
ae27				endm  
# End of macro CALLMONITOR
ae27					endif 
ae27			 
ae27			;	push hl 
ae27				FORTH_DSP_POP 
ae27 cd 4c 98			call macro_forth_dsp_pop 
ae2a				endm 
# End of macro FORTH_DSP_POP
ae2a			 
ae2a			;	pop hl 
ae2a			 
ae2a				; test if true 
ae2a			 
ae2a cd e0 89			call ishlzero 
ae2d			;	ld a,l 
ae2d			;	add h 
ae2d			; 
ae2d			;	cp 0 
ae2d			 
ae2d 20 3e			jr nz, .untilnotdone 
ae2f			 
ae2f					if DEBUG_FORTH_WORDS 
ae2f						DMARK "UNf" 
ae2f f5				push af  
ae30 3a 44 ae			ld a, (.dmark)  
ae33 32 7a ee			ld (debug_mark),a  
ae36 3a 45 ae			ld a, (.dmark+1)  
ae39 32 7b ee			ld (debug_mark+1),a  
ae3c 3a 46 ae			ld a, (.dmark+2)  
ae3f 32 7c ee			ld (debug_mark+2),a  
ae42 18 03			jr .pastdmark  
ae44 ..			.dmark: db "UNf"  
ae47 f1			.pastdmark: pop af  
ae48			endm  
# End of macro DMARK
ae48						CALLMONITOR 
ae48 cd 7b 91			call break_point_state  
ae4b				endm  
# End of macro CALLMONITOR
ae4b					endif 
ae4b			 
ae4b			 
ae4b			 
ae4b				FORTH_RSP_POP     ; get rid of DO ptr 
ae4b cd dd 96			call macro_forth_rsp_pop 
ae4e				endm 
# End of macro FORTH_RSP_POP
ae4e			 
ae4e			if DEBUG_FORTH_WORDS 
ae4e						DMARK "UN>" 
ae4e f5				push af  
ae4f 3a 63 ae			ld a, (.dmark)  
ae52 32 7a ee			ld (debug_mark),a  
ae55 3a 64 ae			ld a, (.dmark+1)  
ae58 32 7b ee			ld (debug_mark+1),a  
ae5b 3a 65 ae			ld a, (.dmark+2)  
ae5e 32 7c ee			ld (debug_mark+2),a  
ae61 18 03			jr .pastdmark  
ae63 ..			.dmark: db "UN>"  
ae66 f1			.pastdmark: pop af  
ae67			endm  
# End of macro DMARK
ae67				CALLMONITOR 
ae67 cd 7b 91			call break_point_state  
ae6a				endm  
# End of macro CALLMONITOR
ae6a			endif 
ae6a			 
ae6a					NEXTW 
ae6a c3 06 99			jp macro_next 
ae6d				endm 
# End of macro NEXTW
ae6d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ae6d			 
ae6d			.untilnotdone: 
ae6d			 
ae6d			 
ae6d			;	; get DO ptr 
ae6d			; 
ae6d				FORTH_RSP_TOS 
ae6d cd d3 96			call macro_forth_rsp_tos 
ae70				endm 
# End of macro FORTH_RSP_TOS
ae70			 
ae70				;push hl 
ae70			 
ae70				; not going to DO any more 
ae70				; get rid of the RSP pointer as DO will add it back in 
ae70				;FORTH_RSP_POP 
ae70				;pop hl 
ae70			 
ae70			 
ae70 22 76 e6			ld (os_tok_ptr), hl 
ae73					if DEBUG_FORTH_WORDS 
ae73						DMARK "UN<" 
ae73 f5				push af  
ae74 3a 88 ae			ld a, (.dmark)  
ae77 32 7a ee			ld (debug_mark),a  
ae7a 3a 89 ae			ld a, (.dmark+1)  
ae7d 32 7b ee			ld (debug_mark+1),a  
ae80 3a 8a ae			ld a, (.dmark+2)  
ae83 32 7c ee			ld (debug_mark+2),a  
ae86 18 03			jr .pastdmark  
ae88 ..			.dmark: db "UN<"  
ae8b f1			.pastdmark: pop af  
ae8c			endm  
# End of macro DMARK
ae8c					CALLMONITOR 
ae8c cd 7b 91			call break_point_state  
ae8f				endm  
# End of macro CALLMONITOR
ae8f				endif 
ae8f c3 97 99			jp exec1 
ae92			 
ae92					 
ae92			 
ae92			 
ae92					NEXTW 
ae92 c3 06 99			jp macro_next 
ae95				endm 
# End of macro NEXTW
ae95			 
ae95			 
ae95			.ENDFLOW: 
ae95			 
ae95			; eof 
ae95			 
# End of file forth_words_flow.asm
ae95			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
ae95			include "forth_words_logic.asm" 
ae95			 
ae95			; | ## Logic Words 
ae95			 
ae95			.NOT: 
ae95				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
ae95 2d				db WORD_SYS_CORE+25             
ae96 dd ae			dw .IS            
ae98 04				db 3 + 1 
ae99 .. 00			db "NOT",0              
ae9d				endm 
# End of macro CWHEAD
ae9d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
ae9d					if DEBUG_FORTH_WORDS_KEY 
ae9d						DMARK "NOT" 
ae9d f5				push af  
ae9e 3a b2 ae			ld a, (.dmark)  
aea1 32 7a ee			ld (debug_mark),a  
aea4 3a b3 ae			ld a, (.dmark+1)  
aea7 32 7b ee			ld (debug_mark+1),a  
aeaa 3a b4 ae			ld a, (.dmark+2)  
aead 32 7c ee			ld (debug_mark+2),a  
aeb0 18 03			jr .pastdmark  
aeb2 ..			.dmark: db "NOT"  
aeb5 f1			.pastdmark: pop af  
aeb6			endm  
# End of macro DMARK
aeb6						CALLMONITOR 
aeb6 cd 7b 91			call break_point_state  
aeb9				endm  
# End of macro CALLMONITOR
aeb9					endif 
aeb9					FORTH_DSP 
aeb9 cd 95 97			call macro_forth_dsp 
aebc				endm 
# End of macro FORTH_DSP
aebc 7e					ld a,(hl)	; get type of value on TOS 
aebd fe 02				cp DS_TYPE_INUM  
aebf 28 03				jr z, .noti 
aec1					NEXTW 
aec1 c3 06 99			jp macro_next 
aec4				endm 
# End of macro NEXTW
aec4			.noti:          FORTH_DSP_VALUEHL 
aec4 cd b0 97			call macro_dsp_valuehl 
aec7				endm 
# End of macro FORTH_DSP_VALUEHL
aec7			;		push hl 
aec7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
aec7 cd 4c 98			call macro_forth_dsp_pop 
aeca				endm 
# End of macro FORTH_DSP_POP
aeca			;		pop hl 
aeca 3e 00				ld a,0 
aecc bd					cp l 
aecd 28 04				jr z, .not2t 
aecf 2e 00				ld l, 0 
aed1 18 02				jr .notip 
aed3			 
aed3 2e ff		.not2t:		ld l, 255 
aed5			 
aed5 26 00		.notip:		ld h, 0	 
aed7			 
aed7 cd 15 97				call forth_push_numhl 
aeda					NEXTW 
aeda c3 06 99			jp macro_next 
aedd				endm 
# End of macro NEXTW
aedd			 
aedd			.IS: 
aedd				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
aedd 2d				db WORD_SYS_CORE+25             
aede 03 af			dw .LZERO            
aee0 03				db 2 + 1 
aee1 .. 00			db "IS",0              
aee4				endm 
# End of macro CWHEAD
aee4			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
aee4					if DEBUG_FORTH_WORDS_KEY 
aee4						DMARK "IS." 
aee4 f5				push af  
aee5 3a f9 ae			ld a, (.dmark)  
aee8 32 7a ee			ld (debug_mark),a  
aeeb 3a fa ae			ld a, (.dmark+1)  
aeee 32 7b ee			ld (debug_mark+1),a  
aef1 3a fb ae			ld a, (.dmark+2)  
aef4 32 7c ee			ld (debug_mark+2),a  
aef7 18 03			jr .pastdmark  
aef9 ..			.dmark: db "IS."  
aefc f1			.pastdmark: pop af  
aefd			endm  
# End of macro DMARK
aefd						CALLMONITOR 
aefd cd 7b 91			call break_point_state  
af00				endm  
# End of macro CALLMONITOR
af00					endif 
af00					NEXTW 
af00 c3 06 99			jp macro_next 
af03				endm 
# End of macro NEXTW
af03			.LZERO: 
af03				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
af03 2d				db WORD_SYS_CORE+25             
af04 0d af			dw .TZERO            
af06 03				db 2 + 1 
af07 .. 00			db "0<",0              
af0a				endm 
# End of macro CWHEAD
af0a			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
af0a					NEXTW 
af0a c3 06 99			jp macro_next 
af0d				endm 
# End of macro NEXTW
af0d			.TZERO: 
af0d				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
af0d 2e				db WORD_SYS_CORE+26             
af0e 54 af			dw .LESS            
af10 03				db 2 + 1 
af11 .. 00			db "0=",0              
af14				endm 
# End of macro CWHEAD
af14			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
af14				; TODO add floating point number detection 
af14					;v5 FORTH_DSP_VALUE 
af14					if DEBUG_FORTH_WORDS_KEY 
af14						DMARK "0=." 
af14 f5				push af  
af15 3a 29 af			ld a, (.dmark)  
af18 32 7a ee			ld (debug_mark),a  
af1b 3a 2a af			ld a, (.dmark+1)  
af1e 32 7b ee			ld (debug_mark+1),a  
af21 3a 2b af			ld a, (.dmark+2)  
af24 32 7c ee			ld (debug_mark+2),a  
af27 18 03			jr .pastdmark  
af29 ..			.dmark: db "0=."  
af2c f1			.pastdmark: pop af  
af2d			endm  
# End of macro DMARK
af2d						CALLMONITOR 
af2d cd 7b 91			call break_point_state  
af30				endm  
# End of macro CALLMONITOR
af30					endif 
af30					FORTH_DSP 
af30 cd 95 97			call macro_forth_dsp 
af33				endm 
# End of macro FORTH_DSP
af33 7e					ld a,(hl)	; get type of value on TOS 
af34 fe 02				cp DS_TYPE_INUM  
af36 28 00				jr z, .tz_inum 
af38			 
af38				if FORTH_ENABLE_FLOATMATH 
af38					jr .tz_done 
af38			 
af38				endif 
af38					 
af38			 
af38			.tz_inum: 
af38					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
af38 cd b0 97			call macro_dsp_valuehl 
af3b				endm 
# End of macro FORTH_DSP_VALUEHL
af3b			 
af3b			;		push hl 
af3b			 
af3b					; destroy value TOS 
af3b			 
af3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
af3b cd 4c 98			call macro_forth_dsp_pop 
af3e				endm 
# End of macro FORTH_DSP_POP
af3e			 
af3e			;		pop hl 
af3e			 
af3e 3e 00				ld a,0 
af40			 
af40 bd					cp l 
af41 20 08				jr nz, .tz_notzero 
af43			 
af43 bc					cp h 
af44			 
af44 20 05				jr nz, .tz_notzero 
af46			 
af46			 
af46 21 01 00				ld hl, FORTH_TRUE 
af49 18 03				jr .tz_done 
af4b			 
af4b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
af4e			 
af4e					; push value back onto stack for another op etc 
af4e			 
af4e			.tz_done: 
af4e cd 15 97				call forth_push_numhl 
af51			 
af51					NEXTW 
af51 c3 06 99			jp macro_next 
af54				endm 
# End of macro NEXTW
af54			.LESS: 
af54				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
af54 2f				db WORD_SYS_CORE+27             
af55 bd af			dw .GT            
af57 02				db 1 + 1 
af58 .. 00			db "<",0              
af5a				endm 
# End of macro CWHEAD
af5a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
af5a				; TODO add floating point number detection 
af5a					if DEBUG_FORTH_WORDS_KEY 
af5a						DMARK "LES" 
af5a f5				push af  
af5b 3a 6f af			ld a, (.dmark)  
af5e 32 7a ee			ld (debug_mark),a  
af61 3a 70 af			ld a, (.dmark+1)  
af64 32 7b ee			ld (debug_mark+1),a  
af67 3a 71 af			ld a, (.dmark+2)  
af6a 32 7c ee			ld (debug_mark+2),a  
af6d 18 03			jr .pastdmark  
af6f ..			.dmark: db "LES"  
af72 f1			.pastdmark: pop af  
af73			endm  
# End of macro DMARK
af73						CALLMONITOR 
af73 cd 7b 91			call break_point_state  
af76				endm  
# End of macro CALLMONITOR
af76					endif 
af76					FORTH_DSP 
af76 cd 95 97			call macro_forth_dsp 
af79				endm 
# End of macro FORTH_DSP
af79					;v5 FORTH_DSP_VALUE 
af79 7e					ld a,(hl)	; get type of value on TOS 
af7a fe 02				cp DS_TYPE_INUM  
af7c 28 00				jr z, .less_inum 
af7e			 
af7e				if FORTH_ENABLE_FLOATMATH 
af7e					jr .less_done 
af7e			 
af7e				endif 
af7e					 
af7e			 
af7e			.less_inum: 
af7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
af7e cd b0 97			call macro_dsp_valuehl 
af81				endm 
# End of macro FORTH_DSP_VALUEHL
af81			 
af81 e5					push hl  ; u2 
af82			 
af82					; destroy value TOS 
af82			 
af82					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
af82 cd 4c 98			call macro_forth_dsp_pop 
af85				endm 
# End of macro FORTH_DSP_POP
af85			 
af85			 
af85					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
af85 cd b0 97			call macro_dsp_valuehl 
af88				endm 
# End of macro FORTH_DSP_VALUEHL
af88			 
af88 e5					push hl    ; u1 
af89			 
af89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
af89 cd 4c 98			call macro_forth_dsp_pop 
af8c				endm 
# End of macro FORTH_DSP_POP
af8c			 
af8c			 
af8c b7			 or a      ;clear carry flag 
af8d 01 00 00		 ld bc, FORTH_FALSE 
af90 e1			  pop hl    ; u1 
af91 d1			  pop de    ; u2 
af92 ed 52		  sbc hl,de 
af94 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
af96			 
af96 01 01 00		 ld bc, FORTH_TRUE 
af99			.lscont:  
af99 c5					push bc 
af9a e1					pop hl 
af9b			 
af9b					if DEBUG_FORTH_WORDS 
af9b						DMARK "LT1" 
af9b f5				push af  
af9c 3a b0 af			ld a, (.dmark)  
af9f 32 7a ee			ld (debug_mark),a  
afa2 3a b1 af			ld a, (.dmark+1)  
afa5 32 7b ee			ld (debug_mark+1),a  
afa8 3a b2 af			ld a, (.dmark+2)  
afab 32 7c ee			ld (debug_mark+2),a  
afae 18 03			jr .pastdmark  
afb0 ..			.dmark: db "LT1"  
afb3 f1			.pastdmark: pop af  
afb4			endm  
# End of macro DMARK
afb4						CALLMONITOR 
afb4 cd 7b 91			call break_point_state  
afb7				endm  
# End of macro CALLMONITOR
afb7					endif 
afb7 cd 15 97				call forth_push_numhl 
afba			 
afba					NEXTW 
afba c3 06 99			jp macro_next 
afbd				endm 
# End of macro NEXTW
afbd			.GT: 
afbd				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
afbd 30				db WORD_SYS_CORE+28             
afbe 26 b0			dw .EQUAL            
afc0 02				db 1 + 1 
afc1 .. 00			db ">",0              
afc3				endm 
# End of macro CWHEAD
afc3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
afc3				; TODO add floating point number detection 
afc3					if DEBUG_FORTH_WORDS_KEY 
afc3						DMARK "GRT" 
afc3 f5				push af  
afc4 3a d8 af			ld a, (.dmark)  
afc7 32 7a ee			ld (debug_mark),a  
afca 3a d9 af			ld a, (.dmark+1)  
afcd 32 7b ee			ld (debug_mark+1),a  
afd0 3a da af			ld a, (.dmark+2)  
afd3 32 7c ee			ld (debug_mark+2),a  
afd6 18 03			jr .pastdmark  
afd8 ..			.dmark: db "GRT"  
afdb f1			.pastdmark: pop af  
afdc			endm  
# End of macro DMARK
afdc						CALLMONITOR 
afdc cd 7b 91			call break_point_state  
afdf				endm  
# End of macro CALLMONITOR
afdf					endif 
afdf					FORTH_DSP 
afdf cd 95 97			call macro_forth_dsp 
afe2				endm 
# End of macro FORTH_DSP
afe2					;FORTH_DSP_VALUE 
afe2 7e					ld a,(hl)	; get type of value on TOS 
afe3 fe 02				cp DS_TYPE_INUM  
afe5 28 00				jr z, .gt_inum 
afe7			 
afe7				if FORTH_ENABLE_FLOATMATH 
afe7					jr .gt_done 
afe7			 
afe7				endif 
afe7					 
afe7			 
afe7			.gt_inum: 
afe7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
afe7 cd b0 97			call macro_dsp_valuehl 
afea				endm 
# End of macro FORTH_DSP_VALUEHL
afea			 
afea e5					push hl  ; u2 
afeb			 
afeb					; destroy value TOS 
afeb			 
afeb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
afeb cd 4c 98			call macro_forth_dsp_pop 
afee				endm 
# End of macro FORTH_DSP_POP
afee			 
afee			 
afee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
afee cd b0 97			call macro_dsp_valuehl 
aff1				endm 
# End of macro FORTH_DSP_VALUEHL
aff1			 
aff1 e5					push hl    ; u1 
aff2			 
aff2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
aff2 cd 4c 98			call macro_forth_dsp_pop 
aff5				endm 
# End of macro FORTH_DSP_POP
aff5			 
aff5			 
aff5 b7			 or a      ;clear carry flag 
aff6 01 00 00		 ld bc, FORTH_FALSE 
aff9 e1			  pop hl    ; u1 
affa d1			  pop de    ; u2 
affb ed 52		  sbc hl,de 
affd 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
afff			 
afff 01 01 00		 ld bc, FORTH_TRUE 
b002			.gtcont:  
b002 c5					push bc 
b003 e1					pop hl 
b004			 
b004					if DEBUG_FORTH_WORDS 
b004						DMARK "GT1" 
b004 f5				push af  
b005 3a 19 b0			ld a, (.dmark)  
b008 32 7a ee			ld (debug_mark),a  
b00b 3a 1a b0			ld a, (.dmark+1)  
b00e 32 7b ee			ld (debug_mark+1),a  
b011 3a 1b b0			ld a, (.dmark+2)  
b014 32 7c ee			ld (debug_mark+2),a  
b017 18 03			jr .pastdmark  
b019 ..			.dmark: db "GT1"  
b01c f1			.pastdmark: pop af  
b01d			endm  
# End of macro DMARK
b01d						CALLMONITOR 
b01d cd 7b 91			call break_point_state  
b020				endm  
# End of macro CALLMONITOR
b020					endif 
b020 cd 15 97				call forth_push_numhl 
b023			 
b023					NEXTW 
b023 c3 06 99			jp macro_next 
b026				endm 
# End of macro NEXTW
b026			.EQUAL: 
b026				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b026 31				db WORD_SYS_CORE+29             
b027 91 b0			dw .ENDLOGIC            
b029 02				db 1 + 1 
b02a .. 00			db "=",0              
b02c				endm 
# End of macro CWHEAD
b02c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b02c				; TODO add floating point number detection 
b02c					if DEBUG_FORTH_WORDS_KEY 
b02c						DMARK "EQ." 
b02c f5				push af  
b02d 3a 41 b0			ld a, (.dmark)  
b030 32 7a ee			ld (debug_mark),a  
b033 3a 42 b0			ld a, (.dmark+1)  
b036 32 7b ee			ld (debug_mark+1),a  
b039 3a 43 b0			ld a, (.dmark+2)  
b03c 32 7c ee			ld (debug_mark+2),a  
b03f 18 03			jr .pastdmark  
b041 ..			.dmark: db "EQ."  
b044 f1			.pastdmark: pop af  
b045			endm  
# End of macro DMARK
b045						CALLMONITOR 
b045 cd 7b 91			call break_point_state  
b048				endm  
# End of macro CALLMONITOR
b048					endif 
b048					FORTH_DSP 
b048 cd 95 97			call macro_forth_dsp 
b04b				endm 
# End of macro FORTH_DSP
b04b					;v5 FORTH_DSP_VALUE 
b04b 7e					ld a,(hl)	; get type of value on TOS 
b04c fe 02				cp DS_TYPE_INUM  
b04e 28 00				jr z, .eq_inum 
b050			 
b050				if FORTH_ENABLE_FLOATMATH 
b050					jr .eq_done 
b050			 
b050				endif 
b050					 
b050			 
b050			.eq_inum: 
b050					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b050 cd b0 97			call macro_dsp_valuehl 
b053				endm 
# End of macro FORTH_DSP_VALUEHL
b053			 
b053 e5					push hl 
b054			 
b054					; destroy value TOS 
b054			 
b054					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b054 cd 4c 98			call macro_forth_dsp_pop 
b057				endm 
# End of macro FORTH_DSP_POP
b057			 
b057			 
b057					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b057 cd b0 97			call macro_dsp_valuehl 
b05a				endm 
# End of macro FORTH_DSP_VALUEHL
b05a			 
b05a					; one value on hl get other one back 
b05a			 
b05a e5					push hl 
b05b			 
b05b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b05b cd 4c 98			call macro_forth_dsp_pop 
b05e				endm 
# End of macro FORTH_DSP_POP
b05e			 
b05e 0e 00				ld c, FORTH_FALSE 
b060			 
b060 e1					pop hl 
b061 d1					pop de 
b062			 
b062 7b					ld a, e 
b063 bd					cp l 
b064			 
b064 20 06				jr nz, .eq_done 
b066			 
b066 7a					ld a, d 
b067 bc					cp h 
b068			 
b068 20 02				jr nz, .eq_done 
b06a			 
b06a 0e 01				ld c, FORTH_TRUE 
b06c					 
b06c			 
b06c			 
b06c			.eq_done: 
b06c			 
b06c					; TODO push value back onto stack for another op etc 
b06c			 
b06c 26 00				ld h, 0 
b06e 69					ld l, c 
b06f					if DEBUG_FORTH_WORDS 
b06f						DMARK "EQ1" 
b06f f5				push af  
b070 3a 84 b0			ld a, (.dmark)  
b073 32 7a ee			ld (debug_mark),a  
b076 3a 85 b0			ld a, (.dmark+1)  
b079 32 7b ee			ld (debug_mark+1),a  
b07c 3a 86 b0			ld a, (.dmark+2)  
b07f 32 7c ee			ld (debug_mark+2),a  
b082 18 03			jr .pastdmark  
b084 ..			.dmark: db "EQ1"  
b087 f1			.pastdmark: pop af  
b088			endm  
# End of macro DMARK
b088						CALLMONITOR 
b088 cd 7b 91			call break_point_state  
b08b				endm  
# End of macro CALLMONITOR
b08b					endif 
b08b cd 15 97				call forth_push_numhl 
b08e			 
b08e					NEXTW 
b08e c3 06 99			jp macro_next 
b091				endm 
# End of macro NEXTW
b091			 
b091			 
b091			.ENDLOGIC: 
b091			; eof 
b091			 
b091			 
# End of file forth_words_logic.asm
b091			include "forth_words_maths.asm" 
b091			 
b091			; | ## Maths Words 
b091			 
b091			.PLUS:	 
b091				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b091 15				db WORD_SYS_CORE+1             
b092 d3 b0			dw .NEG            
b094 02				db 1 + 1 
b095 .. 00			db "+",0              
b097				endm 
# End of macro CWHEAD
b097			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b097					if DEBUG_FORTH_WORDS_KEY 
b097						DMARK "PLU" 
b097 f5				push af  
b098 3a ac b0			ld a, (.dmark)  
b09b 32 7a ee			ld (debug_mark),a  
b09e 3a ad b0			ld a, (.dmark+1)  
b0a1 32 7b ee			ld (debug_mark+1),a  
b0a4 3a ae b0			ld a, (.dmark+2)  
b0a7 32 7c ee			ld (debug_mark+2),a  
b0aa 18 03			jr .pastdmark  
b0ac ..			.dmark: db "PLU"  
b0af f1			.pastdmark: pop af  
b0b0			endm  
# End of macro DMARK
b0b0						CALLMONITOR 
b0b0 cd 7b 91			call break_point_state  
b0b3				endm  
# End of macro CALLMONITOR
b0b3					endif 
b0b3					; add top two values and push back result 
b0b3			 
b0b3					;for v5 FORTH_DSP_VALUE 
b0b3					FORTH_DSP 
b0b3 cd 95 97			call macro_forth_dsp 
b0b6				endm 
# End of macro FORTH_DSP
b0b6 7e					ld a,(hl)	; get type of value on TOS 
b0b7 fe 02				cp DS_TYPE_INUM  
b0b9 28 03				jr z, .dot_inum 
b0bb			 
b0bb					NEXTW 
b0bb c3 06 99			jp macro_next 
b0be				endm 
# End of macro NEXTW
b0be			 
b0be			; float maths 
b0be			 
b0be				if FORTH_ENABLE_FLOATMATH 
b0be						inc hl      ; now at start of numeric as string 
b0be			 
b0be					if DEBUG_FORTH_MATHS 
b0be						DMARK "ADD" 
b0be				CALLMONITOR 
b0be					endif 
b0be			 
b0be					;ld ix, hl 
b0be					call CON 
b0be			 
b0be			 
b0be					push hl 
b0be					 
b0be					 
b0be			 
b0be						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b0be			 
b0be					; get next number 
b0be			 
b0be						FORTH_DSP_VALUE 
b0be			 
b0be						inc hl      ; now at start of numeric as string 
b0be			 
b0be					;ld ix, hl 
b0be					call CON 
b0be			 
b0be					push hl 
b0be			 
b0be			 
b0be						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0be			 
b0be						; TODO do add 
b0be			 
b0be						call IADD 
b0be			 
b0be						; TODO get result back as ascii 
b0be			 
b0be						; TODO push result  
b0be			 
b0be			 
b0be			 
b0be						jr .dot_done 
b0be				endif 
b0be			 
b0be			.dot_inum: 
b0be			 
b0be			 
b0be					if DEBUG_FORTH_DOT 
b0be						DMARK "+IT" 
b0be				CALLMONITOR 
b0be					endif 
b0be			 
b0be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0be cd b0 97			call macro_dsp_valuehl 
b0c1				endm 
# End of macro FORTH_DSP_VALUEHL
b0c1			 
b0c1				; TODO add floating point number detection 
b0c1			 
b0c1 e5					push hl 
b0c2			 
b0c2					; destroy value TOS 
b0c2			 
b0c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0c2 cd 4c 98			call macro_forth_dsp_pop 
b0c5				endm 
# End of macro FORTH_DSP_POP
b0c5			 
b0c5			 
b0c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0c5 cd b0 97			call macro_dsp_valuehl 
b0c8				endm 
# End of macro FORTH_DSP_VALUEHL
b0c8			 
b0c8					; one value on hl get other one back 
b0c8			 
b0c8 d1					pop de 
b0c9			 
b0c9					; do the add 
b0c9			 
b0c9 19					add hl,de 
b0ca			 
b0ca					; save it 
b0ca			 
b0ca			;		push hl	 
b0ca			 
b0ca					; 
b0ca			 
b0ca					; destroy value TOS 
b0ca			 
b0ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0ca cd 4c 98			call macro_forth_dsp_pop 
b0cd				endm 
# End of macro FORTH_DSP_POP
b0cd			 
b0cd					; TODO push value back onto stack for another op etc 
b0cd			 
b0cd			;		pop hl 
b0cd			 
b0cd			.dot_done: 
b0cd cd 15 97				call forth_push_numhl 
b0d0			 
b0d0					NEXTW 
b0d0 c3 06 99			jp macro_next 
b0d3				endm 
# End of macro NEXTW
b0d3			.NEG: 
b0d3			 
b0d3				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b0d3 17				db WORD_SYS_CORE+3             
b0d4 16 b1			dw .DIV            
b0d6 02				db 1 + 1 
b0d7 .. 00			db "-",0              
b0d9				endm 
# End of macro CWHEAD
b0d9			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b0d9					if DEBUG_FORTH_WORDS_KEY 
b0d9						DMARK "SUB" 
b0d9 f5				push af  
b0da 3a ee b0			ld a, (.dmark)  
b0dd 32 7a ee			ld (debug_mark),a  
b0e0 3a ef b0			ld a, (.dmark+1)  
b0e3 32 7b ee			ld (debug_mark+1),a  
b0e6 3a f0 b0			ld a, (.dmark+2)  
b0e9 32 7c ee			ld (debug_mark+2),a  
b0ec 18 03			jr .pastdmark  
b0ee ..			.dmark: db "SUB"  
b0f1 f1			.pastdmark: pop af  
b0f2			endm  
# End of macro DMARK
b0f2						CALLMONITOR 
b0f2 cd 7b 91			call break_point_state  
b0f5				endm  
# End of macro CALLMONITOR
b0f5					endif 
b0f5			 
b0f5			 
b0f5				; TODO add floating point number detection 
b0f5					; v5 FORTH_DSP_VALUE 
b0f5					FORTH_DSP 
b0f5 cd 95 97			call macro_forth_dsp 
b0f8				endm 
# End of macro FORTH_DSP
b0f8 7e					ld a,(hl)	; get type of value on TOS 
b0f9 fe 02				cp DS_TYPE_INUM  
b0fb 28 03				jr z, .neg_inum 
b0fd			 
b0fd					NEXTW 
b0fd c3 06 99			jp macro_next 
b100				endm 
# End of macro NEXTW
b100			 
b100			; float maths 
b100			 
b100				if FORTH_ENABLE_FLOATMATH 
b100					jr .neg_done 
b100			 
b100				endif 
b100					 
b100			 
b100			.neg_inum: 
b100					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b100 cd b0 97			call macro_dsp_valuehl 
b103				endm 
# End of macro FORTH_DSP_VALUEHL
b103			 
b103 e5					push hl 
b104			 
b104					; destroy value TOS 
b104			 
b104					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b104 cd 4c 98			call macro_forth_dsp_pop 
b107				endm 
# End of macro FORTH_DSP_POP
b107			 
b107			 
b107					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b107 cd b0 97			call macro_dsp_valuehl 
b10a				endm 
# End of macro FORTH_DSP_VALUEHL
b10a			 
b10a					; one value on hl get other one back 
b10a			 
b10a d1					pop de 
b10b			 
b10b					; do the sub 
b10b			;		ex de, hl 
b10b			 
b10b ed 52				sbc hl,de 
b10d			 
b10d					; save it 
b10d			 
b10d			;		push hl	 
b10d			 
b10d					; 
b10d			 
b10d					; destroy value TOS 
b10d			 
b10d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b10d cd 4c 98			call macro_forth_dsp_pop 
b110				endm 
# End of macro FORTH_DSP_POP
b110			 
b110					; TODO push value back onto stack for another op etc 
b110			 
b110			;		pop hl 
b110			 
b110 cd 15 97				call forth_push_numhl 
b113			.neg_done: 
b113			 
b113					NEXTW 
b113 c3 06 99			jp macro_next 
b116				endm 
# End of macro NEXTW
b116			.DIV: 
b116				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b116 18				db WORD_SYS_CORE+4             
b117 63 b1			dw .MUL            
b119 02				db 1 + 1 
b11a .. 00			db "/",0              
b11c				endm 
# End of macro CWHEAD
b11c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b11c					if DEBUG_FORTH_WORDS_KEY 
b11c						DMARK "DIV" 
b11c f5				push af  
b11d 3a 31 b1			ld a, (.dmark)  
b120 32 7a ee			ld (debug_mark),a  
b123 3a 32 b1			ld a, (.dmark+1)  
b126 32 7b ee			ld (debug_mark+1),a  
b129 3a 33 b1			ld a, (.dmark+2)  
b12c 32 7c ee			ld (debug_mark+2),a  
b12f 18 03			jr .pastdmark  
b131 ..			.dmark: db "DIV"  
b134 f1			.pastdmark: pop af  
b135			endm  
# End of macro DMARK
b135						CALLMONITOR 
b135 cd 7b 91			call break_point_state  
b138				endm  
# End of macro CALLMONITOR
b138					endif 
b138				; TODO add floating point number detection 
b138					; v5 FORTH_DSP_VALUE 
b138					FORTH_DSP 
b138 cd 95 97			call macro_forth_dsp 
b13b				endm 
# End of macro FORTH_DSP
b13b 7e					ld a,(hl)	; get type of value on TOS 
b13c fe 02				cp DS_TYPE_INUM  
b13e 28 03				jr z, .div_inum 
b140			 
b140				if FORTH_ENABLE_FLOATMATH 
b140					jr .div_done 
b140			 
b140				endif 
b140					NEXTW 
b140 c3 06 99			jp macro_next 
b143				endm 
# End of macro NEXTW
b143			.div_inum: 
b143			 
b143					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b143 cd b0 97			call macro_dsp_valuehl 
b146				endm 
# End of macro FORTH_DSP_VALUEHL
b146			 
b146 e5					push hl    ; to go to bc 
b147			 
b147					; destroy value TOS 
b147			 
b147					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b147 cd 4c 98			call macro_forth_dsp_pop 
b14a				endm 
# End of macro FORTH_DSP_POP
b14a			 
b14a			 
b14a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b14a cd b0 97			call macro_dsp_valuehl 
b14d				endm 
# End of macro FORTH_DSP_VALUEHL
b14d			 
b14d					; hl to go to de 
b14d			 
b14d e5					push hl 
b14e			 
b14e c1					pop bc 
b14f d1					pop de		 
b150			 
b150			 
b150					if DEBUG_FORTH_MATHS 
b150						DMARK "DIV" 
b150				CALLMONITOR 
b150					endif 
b150					; one value on hl but move to a get other one back 
b150			 
b150			        
b150 cd 14 89			call Div16 
b153			 
b153			;	push af	 
b153 e5				push hl 
b154 c5				push bc 
b155			 
b155					if DEBUG_FORTH_MATHS 
b155						DMARK "DI1" 
b155				CALLMONITOR 
b155					endif 
b155			 
b155					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b155 cd 4c 98			call macro_forth_dsp_pop 
b158				endm 
# End of macro FORTH_DSP_POP
b158			 
b158			 
b158			 
b158 e1					pop hl    ; result 
b159			 
b159 cd 15 97				call forth_push_numhl 
b15c			 
b15c e1					pop hl    ; reminder 
b15d			;		ld h,0 
b15d			;		ld l,d 
b15d			 
b15d cd 15 97				call forth_push_numhl 
b160			.div_done: 
b160					NEXTW 
b160 c3 06 99			jp macro_next 
b163				endm 
# End of macro NEXTW
b163			.MUL: 
b163				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b163 19				db WORD_SYS_CORE+5             
b164 a8 b1			dw .MIN            
b166 02				db 1 + 1 
b167 .. 00			db "*",0              
b169				endm 
# End of macro CWHEAD
b169			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b169				; TODO add floating point number detection 
b169					if DEBUG_FORTH_WORDS_KEY 
b169						DMARK "MUL" 
b169 f5				push af  
b16a 3a 7e b1			ld a, (.dmark)  
b16d 32 7a ee			ld (debug_mark),a  
b170 3a 7f b1			ld a, (.dmark+1)  
b173 32 7b ee			ld (debug_mark+1),a  
b176 3a 80 b1			ld a, (.dmark+2)  
b179 32 7c ee			ld (debug_mark+2),a  
b17c 18 03			jr .pastdmark  
b17e ..			.dmark: db "MUL"  
b181 f1			.pastdmark: pop af  
b182			endm  
# End of macro DMARK
b182						CALLMONITOR 
b182 cd 7b 91			call break_point_state  
b185				endm  
# End of macro CALLMONITOR
b185					endif 
b185					FORTH_DSP 
b185 cd 95 97			call macro_forth_dsp 
b188				endm 
# End of macro FORTH_DSP
b188					; v5 FORTH_DSP_VALUE 
b188 7e					ld a,(hl)	; get type of value on TOS 
b189 fe 02				cp DS_TYPE_INUM  
b18b 28 03				jr z, .mul_inum 
b18d			 
b18d				if FORTH_ENABLE_FLOATMATH 
b18d					jr .mul_done 
b18d			 
b18d				endif 
b18d			 
b18d					NEXTW 
b18d c3 06 99			jp macro_next 
b190				endm 
# End of macro NEXTW
b190			.mul_inum:	 
b190			 
b190					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b190 cd b0 97			call macro_dsp_valuehl 
b193				endm 
# End of macro FORTH_DSP_VALUEHL
b193			 
b193 e5					push hl 
b194			 
b194					; destroy value TOS 
b194			 
b194					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b194 cd 4c 98			call macro_forth_dsp_pop 
b197				endm 
# End of macro FORTH_DSP_POP
b197			 
b197			 
b197					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b197 cd b0 97			call macro_dsp_valuehl 
b19a				endm 
# End of macro FORTH_DSP_VALUEHL
b19a			 
b19a					; one value on hl but move to a get other one back 
b19a			 
b19a 7d					ld a, l 
b19b			 
b19b d1					pop de 
b19c			 
b19c					; do the mull 
b19c			;		ex de, hl 
b19c			 
b19c cd 3a 89				call Mult16 
b19f					; save it 
b19f			 
b19f			;		push hl	 
b19f			 
b19f					; 
b19f			 
b19f					; destroy value TOS 
b19f			 
b19f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b19f cd 4c 98			call macro_forth_dsp_pop 
b1a2				endm 
# End of macro FORTH_DSP_POP
b1a2			 
b1a2					; TODO push value back onto stack for another op etc 
b1a2			 
b1a2			;		pop hl 
b1a2			 
b1a2 cd 15 97				call forth_push_numhl 
b1a5			 
b1a5			.mul_done: 
b1a5					NEXTW 
b1a5 c3 06 99			jp macro_next 
b1a8				endm 
# End of macro NEXTW
b1a8			 
b1a8			 
b1a8			 
b1a8			 
b1a8			.MIN: 
b1a8				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b1a8 49				db WORD_SYS_CORE+53             
b1a9 29 b2			dw .MAX            
b1ab 04				db 3 + 1 
b1ac .. 00			db "MIN",0              
b1b0				endm 
# End of macro CWHEAD
b1b0			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b1b0					if DEBUG_FORTH_WORDS_KEY 
b1b0						DMARK "MIN" 
b1b0 f5				push af  
b1b1 3a c5 b1			ld a, (.dmark)  
b1b4 32 7a ee			ld (debug_mark),a  
b1b7 3a c6 b1			ld a, (.dmark+1)  
b1ba 32 7b ee			ld (debug_mark+1),a  
b1bd 3a c7 b1			ld a, (.dmark+2)  
b1c0 32 7c ee			ld (debug_mark+2),a  
b1c3 18 03			jr .pastdmark  
b1c5 ..			.dmark: db "MIN"  
b1c8 f1			.pastdmark: pop af  
b1c9			endm  
# End of macro DMARK
b1c9						CALLMONITOR 
b1c9 cd 7b 91			call break_point_state  
b1cc				endm  
# End of macro CALLMONITOR
b1cc					endif 
b1cc					; get u2 
b1cc			 
b1cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1cc cd b0 97			call macro_dsp_valuehl 
b1cf				endm 
# End of macro FORTH_DSP_VALUEHL
b1cf			 
b1cf e5					push hl   ; u2 
b1d0			 
b1d0					; destroy value TOS 
b1d0			 
b1d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1d0 cd 4c 98			call macro_forth_dsp_pop 
b1d3				endm 
# End of macro FORTH_DSP_POP
b1d3			 
b1d3					; get u1 
b1d3			 
b1d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1d3 cd b0 97			call macro_dsp_valuehl 
b1d6				endm 
# End of macro FORTH_DSP_VALUEHL
b1d6			 
b1d6 e5					push hl  ; u1 
b1d7			 
b1d7					; destroy value TOS 
b1d7			 
b1d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1d7 cd 4c 98			call macro_forth_dsp_pop 
b1da				endm 
# End of macro FORTH_DSP_POP
b1da			 
b1da b7			 or a      ;clear carry flag 
b1db e1			  pop hl    ; u1 
b1dc d1			  pop de    ; u2 
b1dd e5				push hl   ; saved in case hl is lowest 
b1de ed 52		  sbc hl,de 
b1e0 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b1e2			 
b1e2 e1				pop hl 
b1e3					if DEBUG_FORTH_WORDS 
b1e3						DMARK "MIN" 
b1e3 f5				push af  
b1e4 3a f8 b1			ld a, (.dmark)  
b1e7 32 7a ee			ld (debug_mark),a  
b1ea 3a f9 b1			ld a, (.dmark+1)  
b1ed 32 7b ee			ld (debug_mark+1),a  
b1f0 3a fa b1			ld a, (.dmark+2)  
b1f3 32 7c ee			ld (debug_mark+2),a  
b1f6 18 03			jr .pastdmark  
b1f8 ..			.dmark: db "MIN"  
b1fb f1			.pastdmark: pop af  
b1fc			endm  
# End of macro DMARK
b1fc						CALLMONITOR 
b1fc cd 7b 91			call break_point_state  
b1ff				endm  
# End of macro CALLMONITOR
b1ff					endif 
b1ff cd 15 97				call forth_push_numhl 
b202			 
b202				       NEXTW 
b202 c3 06 99			jp macro_next 
b205				endm 
# End of macro NEXTW
b205			 
b205			.mincont:  
b205 c1				pop bc   ; tidy up 
b206 eb				ex de , hl  
b207					if DEBUG_FORTH_WORDS 
b207						DMARK "MI1" 
b207 f5				push af  
b208 3a 1c b2			ld a, (.dmark)  
b20b 32 7a ee			ld (debug_mark),a  
b20e 3a 1d b2			ld a, (.dmark+1)  
b211 32 7b ee			ld (debug_mark+1),a  
b214 3a 1e b2			ld a, (.dmark+2)  
b217 32 7c ee			ld (debug_mark+2),a  
b21a 18 03			jr .pastdmark  
b21c ..			.dmark: db "MI1"  
b21f f1			.pastdmark: pop af  
b220			endm  
# End of macro DMARK
b220						CALLMONITOR 
b220 cd 7b 91			call break_point_state  
b223				endm  
# End of macro CALLMONITOR
b223					endif 
b223 cd 15 97				call forth_push_numhl 
b226			 
b226				       NEXTW 
b226 c3 06 99			jp macro_next 
b229				endm 
# End of macro NEXTW
b229			.MAX: 
b229				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b229 4a				db WORD_SYS_CORE+54             
b22a aa b2			dw .RND16            
b22c 04				db 3 + 1 
b22d .. 00			db "MAX",0              
b231				endm 
# End of macro CWHEAD
b231			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b231					if DEBUG_FORTH_WORDS_KEY 
b231						DMARK "MAX" 
b231 f5				push af  
b232 3a 46 b2			ld a, (.dmark)  
b235 32 7a ee			ld (debug_mark),a  
b238 3a 47 b2			ld a, (.dmark+1)  
b23b 32 7b ee			ld (debug_mark+1),a  
b23e 3a 48 b2			ld a, (.dmark+2)  
b241 32 7c ee			ld (debug_mark+2),a  
b244 18 03			jr .pastdmark  
b246 ..			.dmark: db "MAX"  
b249 f1			.pastdmark: pop af  
b24a			endm  
# End of macro DMARK
b24a						CALLMONITOR 
b24a cd 7b 91			call break_point_state  
b24d				endm  
# End of macro CALLMONITOR
b24d					endif 
b24d					; get u2 
b24d			 
b24d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b24d cd b0 97			call macro_dsp_valuehl 
b250				endm 
# End of macro FORTH_DSP_VALUEHL
b250			 
b250 e5					push hl   ; u2 
b251			 
b251					; destroy value TOS 
b251			 
b251					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b251 cd 4c 98			call macro_forth_dsp_pop 
b254				endm 
# End of macro FORTH_DSP_POP
b254			 
b254					; get u1 
b254			 
b254					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b254 cd b0 97			call macro_dsp_valuehl 
b257				endm 
# End of macro FORTH_DSP_VALUEHL
b257			 
b257 e5					push hl  ; u1 
b258			 
b258					; destroy value TOS 
b258			 
b258					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b258 cd 4c 98			call macro_forth_dsp_pop 
b25b				endm 
# End of macro FORTH_DSP_POP
b25b			 
b25b b7			 or a      ;clear carry flag 
b25c e1			  pop hl    ; u1 
b25d d1			  pop de    ; u2 
b25e e5				push hl   ; saved in case hl is lowest 
b25f ed 52		  sbc hl,de 
b261 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b263			 
b263 e1				pop hl 
b264					if DEBUG_FORTH_WORDS 
b264						DMARK "MAX" 
b264 f5				push af  
b265 3a 79 b2			ld a, (.dmark)  
b268 32 7a ee			ld (debug_mark),a  
b26b 3a 7a b2			ld a, (.dmark+1)  
b26e 32 7b ee			ld (debug_mark+1),a  
b271 3a 7b b2			ld a, (.dmark+2)  
b274 32 7c ee			ld (debug_mark+2),a  
b277 18 03			jr .pastdmark  
b279 ..			.dmark: db "MAX"  
b27c f1			.pastdmark: pop af  
b27d			endm  
# End of macro DMARK
b27d						CALLMONITOR 
b27d cd 7b 91			call break_point_state  
b280				endm  
# End of macro CALLMONITOR
b280					endif 
b280 cd 15 97				call forth_push_numhl 
b283			 
b283				       NEXTW 
b283 c3 06 99			jp macro_next 
b286				endm 
# End of macro NEXTW
b286			 
b286			.maxcont:  
b286 c1				pop bc   ; tidy up 
b287 eb				ex de , hl  
b288					if DEBUG_FORTH_WORDS 
b288						DMARK "MA1" 
b288 f5				push af  
b289 3a 9d b2			ld a, (.dmark)  
b28c 32 7a ee			ld (debug_mark),a  
b28f 3a 9e b2			ld a, (.dmark+1)  
b292 32 7b ee			ld (debug_mark+1),a  
b295 3a 9f b2			ld a, (.dmark+2)  
b298 32 7c ee			ld (debug_mark+2),a  
b29b 18 03			jr .pastdmark  
b29d ..			.dmark: db "MA1"  
b2a0 f1			.pastdmark: pop af  
b2a1			endm  
# End of macro DMARK
b2a1						CALLMONITOR 
b2a1 cd 7b 91			call break_point_state  
b2a4				endm  
# End of macro CALLMONITOR
b2a4					endif 
b2a4 cd 15 97				call forth_push_numhl 
b2a7				       NEXTW 
b2a7 c3 06 99			jp macro_next 
b2aa				endm 
# End of macro NEXTW
b2aa			 
b2aa			.RND16: 
b2aa				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b2aa 4e				db WORD_SYS_CORE+58             
b2ab d9 b2			dw .RND8            
b2ad 06				db 5 + 1 
b2ae .. 00			db "RND16",0              
b2b4				endm 
# End of macro CWHEAD
b2b4			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b2b4					if DEBUG_FORTH_WORDS_KEY 
b2b4						DMARK "R16" 
b2b4 f5				push af  
b2b5 3a c9 b2			ld a, (.dmark)  
b2b8 32 7a ee			ld (debug_mark),a  
b2bb 3a ca b2			ld a, (.dmark+1)  
b2be 32 7b ee			ld (debug_mark+1),a  
b2c1 3a cb b2			ld a, (.dmark+2)  
b2c4 32 7c ee			ld (debug_mark+2),a  
b2c7 18 03			jr .pastdmark  
b2c9 ..			.dmark: db "R16"  
b2cc f1			.pastdmark: pop af  
b2cd			endm  
# End of macro DMARK
b2cd						CALLMONITOR 
b2cd cd 7b 91			call break_point_state  
b2d0				endm  
# End of macro CALLMONITOR
b2d0					endif 
b2d0 cd de 88				call prng16  
b2d3 cd 15 97				call forth_push_numhl 
b2d6				       NEXTW 
b2d6 c3 06 99			jp macro_next 
b2d9				endm 
# End of macro NEXTW
b2d9			.RND8: 
b2d9				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b2d9 60				db WORD_SYS_CORE+76             
b2da 0e b3			dw .RND            
b2dc 05				db 4 + 1 
b2dd .. 00			db "RND8",0              
b2e2				endm 
# End of macro CWHEAD
b2e2			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b2e2					if DEBUG_FORTH_WORDS_KEY 
b2e2						DMARK "RN8" 
b2e2 f5				push af  
b2e3 3a f7 b2			ld a, (.dmark)  
b2e6 32 7a ee			ld (debug_mark),a  
b2e9 3a f8 b2			ld a, (.dmark+1)  
b2ec 32 7b ee			ld (debug_mark+1),a  
b2ef 3a f9 b2			ld a, (.dmark+2)  
b2f2 32 7c ee			ld (debug_mark+2),a  
b2f5 18 03			jr .pastdmark  
b2f7 ..			.dmark: db "RN8"  
b2fa f1			.pastdmark: pop af  
b2fb			endm  
# End of macro DMARK
b2fb						CALLMONITOR 
b2fb cd 7b 91			call break_point_state  
b2fe				endm  
# End of macro CALLMONITOR
b2fe					endif 
b2fe 2a bb eb				ld hl,(xrandc) 
b301 23					inc hl 
b302 cd f8 88				call xrnd 
b305 6f					ld l,a	 
b306 26 00				ld h,0 
b308 cd 15 97				call forth_push_numhl 
b30b				       NEXTW 
b30b c3 06 99			jp macro_next 
b30e				endm 
# End of macro NEXTW
b30e			.RND: 
b30e				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b30e 60				db WORD_SYS_CORE+76             
b30f 14 b4			dw .ENDMATHS            
b311 04				db 3 + 1 
b312 .. 00			db "RND",0              
b316				endm 
# End of macro CWHEAD
b316			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b316			 
b316					if DEBUG_FORTH_WORDS_KEY 
b316						DMARK "RND" 
b316 f5				push af  
b317 3a 2b b3			ld a, (.dmark)  
b31a 32 7a ee			ld (debug_mark),a  
b31d 3a 2c b3			ld a, (.dmark+1)  
b320 32 7b ee			ld (debug_mark+1),a  
b323 3a 2d b3			ld a, (.dmark+2)  
b326 32 7c ee			ld (debug_mark+2),a  
b329 18 03			jr .pastdmark  
b32b ..			.dmark: db "RND"  
b32e f1			.pastdmark: pop af  
b32f			endm  
# End of macro DMARK
b32f						CALLMONITOR 
b32f cd 7b 91			call break_point_state  
b332				endm  
# End of macro CALLMONITOR
b332					endif 
b332					 
b332					FORTH_DSP_VALUEHL    ; upper range 
b332 cd b0 97			call macro_dsp_valuehl 
b335				endm 
# End of macro FORTH_DSP_VALUEHL
b335			 
b335 22 bf eb				ld (LFSRSeed), hl	 
b338			 
b338					if DEBUG_FORTH_WORDS 
b338						DMARK "RN1" 
b338 f5				push af  
b339 3a 4d b3			ld a, (.dmark)  
b33c 32 7a ee			ld (debug_mark),a  
b33f 3a 4e b3			ld a, (.dmark+1)  
b342 32 7b ee			ld (debug_mark+1),a  
b345 3a 4f b3			ld a, (.dmark+2)  
b348 32 7c ee			ld (debug_mark+2),a  
b34b 18 03			jr .pastdmark  
b34d ..			.dmark: db "RN1"  
b350 f1			.pastdmark: pop af  
b351			endm  
# End of macro DMARK
b351						CALLMONITOR 
b351 cd 7b 91			call break_point_state  
b354				endm  
# End of macro CALLMONITOR
b354					endif 
b354					FORTH_DSP_POP 
b354 cd 4c 98			call macro_forth_dsp_pop 
b357				endm 
# End of macro FORTH_DSP_POP
b357			 
b357					FORTH_DSP_VALUEHL    ; low range 
b357 cd b0 97			call macro_dsp_valuehl 
b35a				endm 
# End of macro FORTH_DSP_VALUEHL
b35a			 
b35a					if DEBUG_FORTH_WORDS 
b35a						DMARK "RN2" 
b35a f5				push af  
b35b 3a 6f b3			ld a, (.dmark)  
b35e 32 7a ee			ld (debug_mark),a  
b361 3a 70 b3			ld a, (.dmark+1)  
b364 32 7b ee			ld (debug_mark+1),a  
b367 3a 71 b3			ld a, (.dmark+2)  
b36a 32 7c ee			ld (debug_mark+2),a  
b36d 18 03			jr .pastdmark  
b36f ..			.dmark: db "RN2"  
b372 f1			.pastdmark: pop af  
b373			endm  
# End of macro DMARK
b373						CALLMONITOR 
b373 cd 7b 91			call break_point_state  
b376				endm  
# End of macro CALLMONITOR
b376					endif 
b376 22 c1 eb				ld (LFSRSeed+2), hl 
b379			 
b379					FORTH_DSP_POP 
b379 cd 4c 98			call macro_forth_dsp_pop 
b37c				endm 
# End of macro FORTH_DSP_POP
b37c			 
b37c e5					push hl 
b37d			 
b37d e1			.inrange:	pop hl 
b37e cd de 88				call prng16  
b381					if DEBUG_FORTH_WORDS 
b381						DMARK "RN3" 
b381 f5				push af  
b382 3a 96 b3			ld a, (.dmark)  
b385 32 7a ee			ld (debug_mark),a  
b388 3a 97 b3			ld a, (.dmark+1)  
b38b 32 7b ee			ld (debug_mark+1),a  
b38e 3a 98 b3			ld a, (.dmark+2)  
b391 32 7c ee			ld (debug_mark+2),a  
b394 18 03			jr .pastdmark  
b396 ..			.dmark: db "RN3"  
b399 f1			.pastdmark: pop af  
b39a			endm  
# End of macro DMARK
b39a						CALLMONITOR 
b39a cd 7b 91			call break_point_state  
b39d				endm  
# End of macro CALLMONITOR
b39d					endif 
b39d					 
b39d					; if the range is 8bit knock out the high byte 
b39d			 
b39d ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
b3a1			 
b3a1 3e 00				ld a, 0 
b3a3 ba					cp d  
b3a4 20 1e				jr nz, .hirange 
b3a6 26 00				ld h, 0   ; knock it down to 8bit 
b3a8			 
b3a8					if DEBUG_FORTH_WORDS 
b3a8						DMARK "RNk" 
b3a8 f5				push af  
b3a9 3a bd b3			ld a, (.dmark)  
b3ac 32 7a ee			ld (debug_mark),a  
b3af 3a be b3			ld a, (.dmark+1)  
b3b2 32 7b ee			ld (debug_mark+1),a  
b3b5 3a bf b3			ld a, (.dmark+2)  
b3b8 32 7c ee			ld (debug_mark+2),a  
b3bb 18 03			jr .pastdmark  
b3bd ..			.dmark: db "RNk"  
b3c0 f1			.pastdmark: pop af  
b3c1			endm  
# End of macro DMARK
b3c1						CALLMONITOR 
b3c1 cd 7b 91			call break_point_state  
b3c4				endm  
# End of macro CALLMONITOR
b3c4					endif 
b3c4			.hirange:   
b3c4 e5					push hl  
b3c5 b7					or a  
b3c6 ed 52		                sbc hl, de 
b3c8			 
b3c8					;call cmp16 
b3c8			 
b3c8 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b3ca e1					pop hl 
b3cb e5					push hl 
b3cc			 
b3cc					if DEBUG_FORTH_WORDS 
b3cc						DMARK "RN4" 
b3cc f5				push af  
b3cd 3a e1 b3			ld a, (.dmark)  
b3d0 32 7a ee			ld (debug_mark),a  
b3d3 3a e2 b3			ld a, (.dmark+1)  
b3d6 32 7b ee			ld (debug_mark+1),a  
b3d9 3a e3 b3			ld a, (.dmark+2)  
b3dc 32 7c ee			ld (debug_mark+2),a  
b3df 18 03			jr .pastdmark  
b3e1 ..			.dmark: db "RN4"  
b3e4 f1			.pastdmark: pop af  
b3e5			endm  
# End of macro DMARK
b3e5						CALLMONITOR 
b3e5 cd 7b 91			call break_point_state  
b3e8				endm  
# End of macro CALLMONITOR
b3e8					endif 
b3e8 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
b3ec					;call cmp16 
b3ec				 
b3ec b7					or a  
b3ed ed 52		                sbc hl, de 
b3ef 38 8c				jr c, .inrange 
b3f1			 
b3f1 e1					pop hl 
b3f2					 
b3f2					if DEBUG_FORTH_WORDS 
b3f2						DMARK "RNd" 
b3f2 f5				push af  
b3f3 3a 07 b4			ld a, (.dmark)  
b3f6 32 7a ee			ld (debug_mark),a  
b3f9 3a 08 b4			ld a, (.dmark+1)  
b3fc 32 7b ee			ld (debug_mark+1),a  
b3ff 3a 09 b4			ld a, (.dmark+2)  
b402 32 7c ee			ld (debug_mark+2),a  
b405 18 03			jr .pastdmark  
b407 ..			.dmark: db "RNd"  
b40a f1			.pastdmark: pop af  
b40b			endm  
# End of macro DMARK
b40b						CALLMONITOR 
b40b cd 7b 91			call break_point_state  
b40e				endm  
# End of macro CALLMONITOR
b40e					endif 
b40e			 
b40e			 
b40e cd 15 97				call forth_push_numhl 
b411				       NEXTW 
b411 c3 06 99			jp macro_next 
b414				endm 
# End of macro NEXTW
b414			 
b414			.ENDMATHS: 
b414			 
b414			; eof 
b414			 
# End of file forth_words_maths.asm
b414			include "forth_words_display.asm" 
b414			 
b414			; | ## Display Words 
b414			 
b414			.ATP: 
b414				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b414 62				db WORD_SYS_CORE+78             
b415 8b b4			dw .FB            
b417 04				db 3 + 1 
b418 .. 00			db "AT?",0              
b41c				endm 
# End of macro CWHEAD
b41c			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b41c					if DEBUG_FORTH_WORDS_KEY 
b41c						DMARK "AT?" 
b41c f5				push af  
b41d 3a 31 b4			ld a, (.dmark)  
b420 32 7a ee			ld (debug_mark),a  
b423 3a 32 b4			ld a, (.dmark+1)  
b426 32 7b ee			ld (debug_mark+1),a  
b429 3a 33 b4			ld a, (.dmark+2)  
b42c 32 7c ee			ld (debug_mark+2),a  
b42f 18 03			jr .pastdmark  
b431 ..			.dmark: db "AT?"  
b434 f1			.pastdmark: pop af  
b435			endm  
# End of macro DMARK
b435						CALLMONITOR 
b435 cd 7b 91			call break_point_state  
b438				endm  
# End of macro CALLMONITOR
b438					endif 
b438 3a 5e eb				ld a, (f_cursor_ptr) 
b43b			 
b43b			if DEBUG_FORTH_WORDS 
b43b				DMARK "AT?" 
b43b f5				push af  
b43c 3a 50 b4			ld a, (.dmark)  
b43f 32 7a ee			ld (debug_mark),a  
b442 3a 51 b4			ld a, (.dmark+1)  
b445 32 7b ee			ld (debug_mark+1),a  
b448 3a 52 b4			ld a, (.dmark+2)  
b44b 32 7c ee			ld (debug_mark+2),a  
b44e 18 03			jr .pastdmark  
b450 ..			.dmark: db "AT?"  
b453 f1			.pastdmark: pop af  
b454			endm  
# End of macro DMARK
b454				CALLMONITOR 
b454 cd 7b 91			call break_point_state  
b457				endm  
# End of macro CALLMONITOR
b457			endif	 
b457					; count the number of rows 
b457			 
b457 06 00				ld b, 0 
b459 4f			.atpr:		ld c, a    ; save in case we go below zero 
b45a d6 28				sub display_cols 
b45c f2 62 b4				jp p, .atprunder 
b45f 04					inc b 
b460 18 f7				jr .atpr 
b462			.atprunder:	 
b462			if DEBUG_FORTH_WORDS 
b462				DMARK "A?2" 
b462 f5				push af  
b463 3a 77 b4			ld a, (.dmark)  
b466 32 7a ee			ld (debug_mark),a  
b469 3a 78 b4			ld a, (.dmark+1)  
b46c 32 7b ee			ld (debug_mark+1),a  
b46f 3a 79 b4			ld a, (.dmark+2)  
b472 32 7c ee			ld (debug_mark+2),a  
b475 18 03			jr .pastdmark  
b477 ..			.dmark: db "A?2"  
b47a f1			.pastdmark: pop af  
b47b			endm  
# End of macro DMARK
b47b				CALLMONITOR 
b47b cd 7b 91			call break_point_state  
b47e				endm  
# End of macro CALLMONITOR
b47e			endif	 
b47e 26 00				ld h, 0 
b480 69					ld l, c 
b481 cd 15 97				call forth_push_numhl 
b484 68					ld l, b  
b485 cd 15 97				call forth_push_numhl 
b488			 
b488			 
b488				NEXTW 
b488 c3 06 99			jp macro_next 
b48b				endm 
# End of macro NEXTW
b48b			 
b48b			.FB: 
b48b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b48b 1b				db WORD_SYS_CORE+7             
b48c d9 b4			dw .EMIT            
b48e 03				db 2 + 1 
b48f .. 00			db "FB",0              
b492				endm 
# End of macro CWHEAD
b492			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b492			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b492			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b492			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b492					if DEBUG_FORTH_WORDS_KEY 
b492						DMARK "FB." 
b492 f5				push af  
b493 3a a7 b4			ld a, (.dmark)  
b496 32 7a ee			ld (debug_mark),a  
b499 3a a8 b4			ld a, (.dmark+1)  
b49c 32 7b ee			ld (debug_mark+1),a  
b49f 3a a9 b4			ld a, (.dmark+2)  
b4a2 32 7c ee			ld (debug_mark+2),a  
b4a5 18 03			jr .pastdmark  
b4a7 ..			.dmark: db "FB."  
b4aa f1			.pastdmark: pop af  
b4ab			endm  
# End of macro DMARK
b4ab						CALLMONITOR 
b4ab cd 7b 91			call break_point_state  
b4ae				endm  
# End of macro CALLMONITOR
b4ae					endif 
b4ae			 
b4ae					FORTH_DSP_VALUEHL 
b4ae cd b0 97			call macro_dsp_valuehl 
b4b1				endm 
# End of macro FORTH_DSP_VALUEHL
b4b1			 
b4b1 7d					ld a, l 
b4b2 fe 01				cp 1 
b4b4 20 05				jr nz, .fbn1 
b4b6 21 1f ed				ld hl, display_fb1 
b4b9 18 15				jr .fbset 
b4bb fe 02		.fbn1:		cp 2 
b4bd 20 05				jr nz, .fbn2 
b4bf 21 dd eb				ld hl, display_fb2 
b4c2 18 0c				jr .fbset 
b4c4 fe 03		.fbn2:		cp 3 
b4c6 20 05				jr nz, .fbn3 
b4c8 21 7e ec				ld hl, display_fb3 
b4cb 18 03				jr .fbset 
b4cd			.fbn3:		 ; if invalid number select first 
b4cd 21 1f ed				ld hl, display_fb1 
b4d0 22 db eb		.fbset:		ld (display_fb_active), hl 
b4d3			 
b4d3					FORTH_DSP_POP 
b4d3 cd 4c 98			call macro_forth_dsp_pop 
b4d6				endm 
# End of macro FORTH_DSP_POP
b4d6			 
b4d6					NEXTW 
b4d6 c3 06 99			jp macro_next 
b4d9				endm 
# End of macro NEXTW
b4d9			 
b4d9			 
b4d9			.EMIT: 
b4d9				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b4d9 1b				db WORD_SYS_CORE+7             
b4da 2a b5			dw .DOTH            
b4dc 05				db 4 + 1 
b4dd .. 00			db "EMIT",0              
b4e2				endm 
# End of macro CWHEAD
b4e2			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b4e2					; get value off TOS and display it 
b4e2			 
b4e2					if DEBUG_FORTH_WORDS_KEY 
b4e2						DMARK "EMT" 
b4e2 f5				push af  
b4e3 3a f7 b4			ld a, (.dmark)  
b4e6 32 7a ee			ld (debug_mark),a  
b4e9 3a f8 b4			ld a, (.dmark+1)  
b4ec 32 7b ee			ld (debug_mark+1),a  
b4ef 3a f9 b4			ld a, (.dmark+2)  
b4f2 32 7c ee			ld (debug_mark+2),a  
b4f5 18 03			jr .pastdmark  
b4f7 ..			.dmark: db "EMT"  
b4fa f1			.pastdmark: pop af  
b4fb			endm  
# End of macro DMARK
b4fb						CALLMONITOR 
b4fb cd 7b 91			call break_point_state  
b4fe				endm  
# End of macro CALLMONITOR
b4fe					endif 
b4fe			 
b4fe					FORTH_DSP_VALUEHL 
b4fe cd b0 97			call macro_dsp_valuehl 
b501				endm 
# End of macro FORTH_DSP_VALUEHL
b501			 
b501 7d					ld a,l 
b502			 
b502					; TODO write to display 
b502			 
b502 32 73 e5				ld (os_input), a 
b505 3e 00				ld a, 0 
b507 32 74 e5				ld (os_input+1), a 
b50a					 
b50a 3a 5e eb				ld a, (f_cursor_ptr) 
b50d 11 73 e5				ld de, os_input 
b510 cd 71 88				call str_at_display 
b513			 
b513			 
b513 3a 3c eb				ld a,(cli_autodisplay) 
b516 fe 00				cp 0 
b518 28 03				jr z, .enoupdate 
b51a cd 81 88						call update_display 
b51d					.enoupdate: 
b51d			 
b51d 3a 5e eb				ld a, (f_cursor_ptr) 
b520 3c					inc a 
b521 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
b524			 
b524			 
b524					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b524 cd 4c 98			call macro_forth_dsp_pop 
b527				endm 
# End of macro FORTH_DSP_POP
b527			  
b527			 
b527					NEXTW 
b527 c3 06 99			jp macro_next 
b52a				endm 
# End of macro NEXTW
b52a			.DOTH: 
b52a				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b52a 1c				db WORD_SYS_CORE+8             
b52b 5a b5			dw .DOTF            
b52d 03				db 2 + 1 
b52e .. 00			db ".-",0              
b531				endm 
# End of macro CWHEAD
b531			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b531					; get value off TOS and display it 
b531					if DEBUG_FORTH_WORDS_KEY 
b531						DMARK "DTD" 
b531 f5				push af  
b532 3a 46 b5			ld a, (.dmark)  
b535 32 7a ee			ld (debug_mark),a  
b538 3a 47 b5			ld a, (.dmark+1)  
b53b 32 7b ee			ld (debug_mark+1),a  
b53e 3a 48 b5			ld a, (.dmark+2)  
b541 32 7c ee			ld (debug_mark+2),a  
b544 18 03			jr .pastdmark  
b546 ..			.dmark: db "DTD"  
b549 f1			.pastdmark: pop af  
b54a			endm  
# End of macro DMARK
b54a						CALLMONITOR 
b54a cd 7b 91			call break_point_state  
b54d				endm  
# End of macro CALLMONITOR
b54d					endif 
b54d 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b54f 3e 00			ld a, 0 
b551 32 3d eb			ld (cli_mvdot), a 
b554 c3 b1 b5			jp .dotgo 
b557				NEXTW 
b557 c3 06 99			jp macro_next 
b55a				endm 
# End of macro NEXTW
b55a			.DOTF: 
b55a				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b55a 1c				db WORD_SYS_CORE+8             
b55b 88 b5			dw .DOT            
b55d 03				db 2 + 1 
b55e .. 00			db ".>",0              
b561				endm 
# End of macro CWHEAD
b561			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b561					; get value off TOS and display it 
b561			        ; TODO BUG adds extra spaces 
b561			        ; TODO BUG handle numerics? 
b561					if DEBUG_FORTH_WORDS_KEY 
b561						DMARK "DTC" 
b561 f5				push af  
b562 3a 76 b5			ld a, (.dmark)  
b565 32 7a ee			ld (debug_mark),a  
b568 3a 77 b5			ld a, (.dmark+1)  
b56b 32 7b ee			ld (debug_mark+1),a  
b56e 3a 78 b5			ld a, (.dmark+2)  
b571 32 7c ee			ld (debug_mark+2),a  
b574 18 03			jr .pastdmark  
b576 ..			.dmark: db "DTC"  
b579 f1			.pastdmark: pop af  
b57a			endm  
# End of macro DMARK
b57a						CALLMONITOR 
b57a cd 7b 91			call break_point_state  
b57d				endm  
# End of macro CALLMONITOR
b57d					endif 
b57d 3e 01			ld a, 1 
b57f 32 3d eb			ld (cli_mvdot), a 
b582 c3 b1 b5			jp .dotgo 
b585				NEXTW 
b585 c3 06 99			jp macro_next 
b588				endm 
# End of macro NEXTW
b588			 
b588			.DOT: 
b588				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b588 1c				db WORD_SYS_CORE+8             
b589 14 b6			dw .CLS            
b58b 02				db 1 + 1 
b58c .. 00			db ".",0              
b58e				endm 
# End of macro CWHEAD
b58e			        ; | . ( u -- ) Display TOS | DONE 
b58e					; get value off TOS and display it 
b58e			 
b58e					if DEBUG_FORTH_WORDS_KEY 
b58e						DMARK "DOT" 
b58e f5				push af  
b58f 3a a3 b5			ld a, (.dmark)  
b592 32 7a ee			ld (debug_mark),a  
b595 3a a4 b5			ld a, (.dmark+1)  
b598 32 7b ee			ld (debug_mark+1),a  
b59b 3a a5 b5			ld a, (.dmark+2)  
b59e 32 7c ee			ld (debug_mark+2),a  
b5a1 18 03			jr .pastdmark  
b5a3 ..			.dmark: db "DOT"  
b5a6 f1			.pastdmark: pop af  
b5a7			endm  
# End of macro DMARK
b5a7						CALLMONITOR 
b5a7 cd 7b 91			call break_point_state  
b5aa				endm  
# End of macro CALLMONITOR
b5aa					endif 
b5aa 3e 00			ld a, 0 
b5ac 32 3d eb			ld (cli_mvdot), a 
b5af 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b5b1				 
b5b1			 
b5b1			.dotgo: 
b5b1			 
b5b1			; move up type to on stack for parserv5 
b5b1					FORTH_DSP 
b5b1 cd 95 97			call macro_forth_dsp 
b5b4				endm 
# End of macro FORTH_DSP
b5b4				;FORTH_DSP_VALUE  
b5b4			 
b5b4			if DEBUG_FORTH_DOT 
b5b4				DMARK "DOT" 
b5b4				CALLMONITOR 
b5b4			endif	 
b5b4			;		.print: 
b5b4			 
b5b4 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b5b5 23				inc hl   ; position to the actual value 
b5b6 fe 01			cp DS_TYPE_STR 
b5b8 20 06			jr nz, .dotnum1  
b5ba			 
b5ba			; display string 
b5ba				FORTH_DSP_VALUE  
b5ba cd 99 97			call macro_forth_dsp_value 
b5bd				endm 
# End of macro FORTH_DSP_VALUE
b5bd eb				ex de,hl 
b5be 18 11			jr .dotwrite 
b5c0			 
b5c0			.dotnum1: 
b5c0 fe 02			cp DS_TYPE_INUM 
b5c2 20 0c			jr nz, .dotflot 
b5c4			 
b5c4			 
b5c4			; display number 
b5c4			 
b5c4			;	push hl 
b5c4			;	call clear_display 
b5c4			;	pop hl 
b5c4			 
b5c4 5e				ld e, (hl) 
b5c5 23				inc hl 
b5c6 56				ld d, (hl) 
b5c7 21 75 e3			ld hl, scratch 
b5ca			if DEBUG_FORTH_DOT 
b5ca				DMARK "DT1" 
b5ca				CALLMONITOR 
b5ca			endif	 
b5ca			 
b5ca cd c4 8d			call uitoa_16 
b5cd eb				ex de,hl 
b5ce			 
b5ce			if DEBUG_FORTH_DOT 
b5ce				DMARK "DT2" 
b5ce				CALLMONITOR 
b5ce			endif	 
b5ce			 
b5ce			;	ld de, os_word_scratch 
b5ce 18 01			jr .dotwrite 
b5d0			 
b5d0 00			.dotflot:   nop 
b5d1			; TODO print floating point number 
b5d1			 
b5d1			.dotwrite:		 
b5d1			 
b5d1					; if c is set then set all '-' to spaces 
b5d1					; need to also take into account .>  
b5d1			 
b5d1 3e 01				ld a, 1 
b5d3 b9					cp c 
b5d4 20 13				jr nz, .nodashswap 
b5d6			 
b5d6					; DE has the string to write, working with HL 
b5d6			 
b5d6 06 ff				ld b, 255 
b5d8 d5					push de 
b5d9 e1					pop hl 
b5da			 
b5da			if DEBUG_FORTH_DOT 
b5da				DMARK "DT-" 
b5da				CALLMONITOR 
b5da			endif	 
b5da 7e			.dashscan:	ld a, (hl) 
b5db fe 00				cp 0 
b5dd 28 0a				jr z, .nodashswap 
b5df fe 2d				cp '-' 
b5e1 20 03				jr nz, .dashskip 
b5e3 3e 20				ld a, ' ' 
b5e5 77					ld (hl), a 
b5e6 23			.dashskip:	inc hl 
b5e7			if DEBUG_FORTH_DOT 
b5e7				DMARK "D-2" 
b5e7				CALLMONITOR 
b5e7			endif	 
b5e7 10 f1				djnz .dashscan 
b5e9			 
b5e9			if DEBUG_FORTH_DOT 
b5e9				DMARK "D-1" 
b5e9				CALLMONITOR 
b5e9			endif	 
b5e9			 
b5e9			.nodashswap: 
b5e9			 
b5e9 e5					push hl   ; save string start in case we need to advance print 
b5ea			 
b5ea 3a 5e eb				ld a, (f_cursor_ptr) 
b5ed cd 71 88				call str_at_display 
b5f0 3a 3c eb				ld a,(cli_autodisplay) 
b5f3 fe 00				cp 0 
b5f5 28 03				jr z, .noupdate 
b5f7 cd 81 88						call update_display 
b5fa					.noupdate: 
b5fa			 
b5fa			 
b5fa					; see if we need to advance the print position 
b5fa			 
b5fa e1					pop hl   ; get back string 
b5fb			 
b5fb 3a 3d eb				ld a, (cli_mvdot) 
b5fe			if DEBUG_FORTH_DOT 
b5fe					ld e,a 
b5fe				DMARK "D>1" 
b5fe				CALLMONITOR 
b5fe			endif	 
b5fe fe 00				cp 0 
b600 28 0c				jr z, .noadv 
b602					; yes, lets advance the print position 
b602 3e 00				ld a, 0 
b604 cd 20 8e				call strlent 
b607 3a 5e eb				ld a, (f_cursor_ptr) 
b60a 85					add a,l 
b60b					;call addatohl 
b60b					;ld a, l 
b60b 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
b60e			 
b60e			if DEBUG_FORTH_DOT 
b60e				DMARK "D->" 
b60e				CALLMONITOR 
b60e			endif	 
b60e			 
b60e			.noadv:	 
b60e			 
b60e					if DEBUG_FORTH_DOT_WAIT 
b60e							call next_page_prompt 
b60e					endif	 
b60e			; TODO this pop off the stack causes a crash. i dont know why 
b60e			 
b60e			 
b60e			if DEBUG_FORTH_DOT 
b60e				DMARK "DTh" 
b60e				CALLMONITOR 
b60e			endif	 
b60e			 
b60e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b60e cd 4c 98			call macro_forth_dsp_pop 
b611				endm 
# End of macro FORTH_DSP_POP
b611			 
b611			if DEBUG_FORTH_DOT 
b611				DMARK "DTi" 
b611				CALLMONITOR 
b611			endif	 
b611			 
b611			 
b611					NEXTW 
b611 c3 06 99			jp macro_next 
b614				endm 
# End of macro NEXTW
b614			 
b614			.CLS: 
b614				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b614 35				db WORD_SYS_CORE+33             
b615 41 b6			dw .DRAW            
b617 04				db 3 + 1 
b618 .. 00			db "CLS",0              
b61c				endm 
# End of macro CWHEAD
b61c			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b61c					if DEBUG_FORTH_WORDS_KEY 
b61c						DMARK "CLS" 
b61c f5				push af  
b61d 3a 31 b6			ld a, (.dmark)  
b620 32 7a ee			ld (debug_mark),a  
b623 3a 32 b6			ld a, (.dmark+1)  
b626 32 7b ee			ld (debug_mark+1),a  
b629 3a 33 b6			ld a, (.dmark+2)  
b62c 32 7c ee			ld (debug_mark+2),a  
b62f 18 03			jr .pastdmark  
b631 ..			.dmark: db "CLS"  
b634 f1			.pastdmark: pop af  
b635			endm  
# End of macro DMARK
b635						CALLMONITOR 
b635 cd 7b 91			call break_point_state  
b638				endm  
# End of macro CALLMONITOR
b638					endif 
b638 cd 5e 88				call clear_display 
b63b c3 4f b7				jp .home		; and home cursor 
b63e					NEXTW 
b63e c3 06 99			jp macro_next 
b641				endm 
# End of macro NEXTW
b641			 
b641			.DRAW: 
b641				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b641 36				db WORD_SYS_CORE+34             
b642 6c b6			dw .DUMP            
b644 05				db 4 + 1 
b645 .. 00			db "DRAW",0              
b64a				endm 
# End of macro CWHEAD
b64a			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b64a					if DEBUG_FORTH_WORDS_KEY 
b64a						DMARK "DRW" 
b64a f5				push af  
b64b 3a 5f b6			ld a, (.dmark)  
b64e 32 7a ee			ld (debug_mark),a  
b651 3a 60 b6			ld a, (.dmark+1)  
b654 32 7b ee			ld (debug_mark+1),a  
b657 3a 61 b6			ld a, (.dmark+2)  
b65a 32 7c ee			ld (debug_mark+2),a  
b65d 18 03			jr .pastdmark  
b65f ..			.dmark: db "DRW"  
b662 f1			.pastdmark: pop af  
b663			endm  
# End of macro DMARK
b663						CALLMONITOR 
b663 cd 7b 91			call break_point_state  
b666				endm  
# End of macro CALLMONITOR
b666					endif 
b666 cd 81 88				call update_display 
b669					NEXTW 
b669 c3 06 99			jp macro_next 
b66c				endm 
# End of macro NEXTW
b66c			 
b66c			.DUMP: 
b66c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b66c 37				db WORD_SYS_CORE+35             
b66d a4 b6			dw .CDUMP            
b66f 05				db 4 + 1 
b670 .. 00			db "DUMP",0              
b675				endm 
# End of macro CWHEAD
b675			; | DUMP ( x -- ) With address x display dump   | DONE 
b675			; TODO pop address to use off of the stack 
b675					if DEBUG_FORTH_WORDS_KEY 
b675						DMARK "DUM" 
b675 f5				push af  
b676 3a 8a b6			ld a, (.dmark)  
b679 32 7a ee			ld (debug_mark),a  
b67c 3a 8b b6			ld a, (.dmark+1)  
b67f 32 7b ee			ld (debug_mark+1),a  
b682 3a 8c b6			ld a, (.dmark+2)  
b685 32 7c ee			ld (debug_mark+2),a  
b688 18 03			jr .pastdmark  
b68a ..			.dmark: db "DUM"  
b68d f1			.pastdmark: pop af  
b68e			endm  
# End of macro DMARK
b68e						CALLMONITOR 
b68e cd 7b 91			call break_point_state  
b691				endm  
# End of macro CALLMONITOR
b691					endif 
b691 cd 5e 88				call clear_display 
b694			 
b694					; get address 
b694			 
b694					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b694 cd b0 97			call macro_dsp_valuehl 
b697				endm 
# End of macro FORTH_DSP_VALUEHL
b697				 
b697					; save it for cdump 
b697			 
b697 22 98 e6				ld (os_cur_ptr),hl 
b69a			 
b69a					; destroy value TOS 
b69a			 
b69a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b69a cd 4c 98			call macro_forth_dsp_pop 
b69d				endm 
# End of macro FORTH_DSP_POP
b69d			 
b69d cd 95 95				call dumpcont	; skip old style of param parsing	 
b6a0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b6a1					NEXTW 
b6a1 c3 06 99			jp macro_next 
b6a4				endm 
# End of macro NEXTW
b6a4			.CDUMP: 
b6a4				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b6a4 38				db WORD_SYS_CORE+36             
b6a5 d4 b6			dw .DAT            
b6a7 06				db 5 + 1 
b6a8 .. 00			db "CDUMP",0              
b6ae				endm 
# End of macro CWHEAD
b6ae			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b6ae					if DEBUG_FORTH_WORDS_KEY 
b6ae						DMARK "CDP" 
b6ae f5				push af  
b6af 3a c3 b6			ld a, (.dmark)  
b6b2 32 7a ee			ld (debug_mark),a  
b6b5 3a c4 b6			ld a, (.dmark+1)  
b6b8 32 7b ee			ld (debug_mark+1),a  
b6bb 3a c5 b6			ld a, (.dmark+2)  
b6be 32 7c ee			ld (debug_mark+2),a  
b6c1 18 03			jr .pastdmark  
b6c3 ..			.dmark: db "CDP"  
b6c6 f1			.pastdmark: pop af  
b6c7			endm  
# End of macro DMARK
b6c7						CALLMONITOR 
b6c7 cd 7b 91			call break_point_state  
b6ca				endm  
# End of macro CALLMONITOR
b6ca					endif 
b6ca cd 5e 88				call clear_display 
b6cd cd 95 95				call dumpcont	 
b6d0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b6d1					NEXTW 
b6d1 c3 06 99			jp macro_next 
b6d4				endm 
# End of macro NEXTW
b6d4			 
b6d4			 
b6d4			 
b6d4			 
b6d4			.DAT: 
b6d4				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b6d4 3d				db WORD_SYS_CORE+41             
b6d5 2a b7			dw .HOME            
b6d7 03				db 2 + 1 
b6d8 .. 00			db "AT",0              
b6db				endm 
# End of macro CWHEAD
b6db			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b6db					if DEBUG_FORTH_WORDS_KEY 
b6db						DMARK "AT." 
b6db f5				push af  
b6dc 3a f0 b6			ld a, (.dmark)  
b6df 32 7a ee			ld (debug_mark),a  
b6e2 3a f1 b6			ld a, (.dmark+1)  
b6e5 32 7b ee			ld (debug_mark+1),a  
b6e8 3a f2 b6			ld a, (.dmark+2)  
b6eb 32 7c ee			ld (debug_mark+2),a  
b6ee 18 03			jr .pastdmark  
b6f0 ..			.dmark: db "AT."  
b6f3 f1			.pastdmark: pop af  
b6f4			endm  
# End of macro DMARK
b6f4						CALLMONITOR 
b6f4 cd 7b 91			call break_point_state  
b6f7				endm  
# End of macro CALLMONITOR
b6f7					endif 
b6f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f7 cd b0 97			call macro_dsp_valuehl 
b6fa				endm 
# End of macro FORTH_DSP_VALUEHL
b6fa			 
b6fa			 
b6fa					; TODO save cursor row 
b6fa 7d					ld a,l 
b6fb fe 02				cp 2 
b6fd 20 04				jr nz, .crow3 
b6ff 3e 28				ld a, display_row_2 
b701 18 12				jr .ccol1 
b703 fe 03		.crow3:		cp 3 
b705 20 04				jr nz, .crow4 
b707 3e 50				ld a, display_row_3 
b709 18 0a				jr .ccol1 
b70b fe 04		.crow4:		cp 4 
b70d 20 04				jr nz, .crow1 
b70f 3e 78				ld a, display_row_4 
b711 18 02				jr .ccol1 
b713 3e 00		.crow1:		ld a,display_row_1 
b715 f5			.ccol1:		push af			; got row offset 
b716 6f					ld l,a 
b717 26 00				ld h,0 
b719					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b719 cd 4c 98			call macro_forth_dsp_pop 
b71c				endm 
# End of macro FORTH_DSP_POP
b71c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b71c cd b0 97			call macro_dsp_valuehl 
b71f				endm 
# End of macro FORTH_DSP_VALUEHL
b71f					; TODO save cursor col 
b71f f1					pop af 
b720 85					add l		; add col offset 
b721 32 5e eb				ld (f_cursor_ptr), a 
b724					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b724 cd 4c 98			call macro_forth_dsp_pop 
b727				endm 
# End of macro FORTH_DSP_POP
b727			 
b727					; calculate  
b727			 
b727					NEXTW 
b727 c3 06 99			jp macro_next 
b72a				endm 
# End of macro NEXTW
b72a			 
b72a			 
b72a			.HOME: 
b72a				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b72a 41				db WORD_SYS_CORE+45             
b72b 57 b7			dw .SPACE            
b72d 05				db 4 + 1 
b72e .. 00			db "HOME",0              
b733				endm 
# End of macro CWHEAD
b733			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b733					if DEBUG_FORTH_WORDS_KEY 
b733						DMARK "HOM" 
b733 f5				push af  
b734 3a 48 b7			ld a, (.dmark)  
b737 32 7a ee			ld (debug_mark),a  
b73a 3a 49 b7			ld a, (.dmark+1)  
b73d 32 7b ee			ld (debug_mark+1),a  
b740 3a 4a b7			ld a, (.dmark+2)  
b743 32 7c ee			ld (debug_mark+2),a  
b746 18 03			jr .pastdmark  
b748 ..			.dmark: db "HOM"  
b74b f1			.pastdmark: pop af  
b74c			endm  
# End of macro DMARK
b74c						CALLMONITOR 
b74c cd 7b 91			call break_point_state  
b74f				endm  
# End of macro CALLMONITOR
b74f					endif 
b74f 3e 00		.home:		ld a, 0		; and home cursor 
b751 32 5e eb				ld (f_cursor_ptr), a 
b754					NEXTW 
b754 c3 06 99			jp macro_next 
b757				endm 
# End of macro NEXTW
b757			 
b757			 
b757			.SPACE: 
b757				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b757 46				db WORD_SYS_CORE+50             
b758 85 b7			dw .SPACES            
b75a 03				db 2 + 1 
b75b .. 00			db "BL",0              
b75e				endm 
# End of macro CWHEAD
b75e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b75e					if DEBUG_FORTH_WORDS_KEY 
b75e						DMARK "BL." 
b75e f5				push af  
b75f 3a 73 b7			ld a, (.dmark)  
b762 32 7a ee			ld (debug_mark),a  
b765 3a 74 b7			ld a, (.dmark+1)  
b768 32 7b ee			ld (debug_mark+1),a  
b76b 3a 75 b7			ld a, (.dmark+2)  
b76e 32 7c ee			ld (debug_mark+2),a  
b771 18 03			jr .pastdmark  
b773 ..			.dmark: db "BL."  
b776 f1			.pastdmark: pop af  
b777			endm  
# End of macro DMARK
b777						CALLMONITOR 
b777 cd 7b 91			call break_point_state  
b77a				endm  
# End of macro CALLMONITOR
b77a					endif 
b77a 21 83 b7				ld hl, .blstr 
b77d cd 27 97				call forth_push_str 
b780					 
b780				       NEXTW 
b780 c3 06 99			jp macro_next 
b783				endm 
# End of macro NEXTW
b783			 
b783 .. 00		.blstr: db " ", 0 
b785			 
b785			.SPACES: 
b785				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b785 47				db WORD_SYS_CORE+51             
b786 20 b8			dw .SCROLL            
b788 07				db 6 + 1 
b789 .. 00			db "SPACES",0              
b790				endm 
# End of macro CWHEAD
b790			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b790					if DEBUG_FORTH_WORDS_KEY 
b790						DMARK "SPS" 
b790 f5				push af  
b791 3a a5 b7			ld a, (.dmark)  
b794 32 7a ee			ld (debug_mark),a  
b797 3a a6 b7			ld a, (.dmark+1)  
b79a 32 7b ee			ld (debug_mark+1),a  
b79d 3a a7 b7			ld a, (.dmark+2)  
b7a0 32 7c ee			ld (debug_mark+2),a  
b7a3 18 03			jr .pastdmark  
b7a5 ..			.dmark: db "SPS"  
b7a8 f1			.pastdmark: pop af  
b7a9			endm  
# End of macro DMARK
b7a9						CALLMONITOR 
b7a9 cd 7b 91			call break_point_state  
b7ac				endm  
# End of macro CALLMONITOR
b7ac					endif 
b7ac			 
b7ac			 
b7ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7ac cd b0 97			call macro_dsp_valuehl 
b7af				endm 
# End of macro FORTH_DSP_VALUEHL
b7af			 
b7af			;		push hl    ; u 
b7af					if DEBUG_FORTH_WORDS 
b7af						DMARK "SPA" 
b7af f5				push af  
b7b0 3a c4 b7			ld a, (.dmark)  
b7b3 32 7a ee			ld (debug_mark),a  
b7b6 3a c5 b7			ld a, (.dmark+1)  
b7b9 32 7b ee			ld (debug_mark+1),a  
b7bc 3a c6 b7			ld a, (.dmark+2)  
b7bf 32 7c ee			ld (debug_mark+2),a  
b7c2 18 03			jr .pastdmark  
b7c4 ..			.dmark: db "SPA"  
b7c7 f1			.pastdmark: pop af  
b7c8			endm  
# End of macro DMARK
b7c8						CALLMONITOR 
b7c8 cd 7b 91			call break_point_state  
b7cb				endm  
# End of macro CALLMONITOR
b7cb					endif 
b7cb			 
b7cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7cb cd 4c 98			call macro_forth_dsp_pop 
b7ce				endm 
# End of macro FORTH_DSP_POP
b7ce			;		pop hl 
b7ce 4d					ld c, l 
b7cf 06 00				ld b, 0 
b7d1 21 75 e3				ld hl, scratch  
b7d4			 
b7d4					if DEBUG_FORTH_WORDS 
b7d4						DMARK "SP2" 
b7d4 f5				push af  
b7d5 3a e9 b7			ld a, (.dmark)  
b7d8 32 7a ee			ld (debug_mark),a  
b7db 3a ea b7			ld a, (.dmark+1)  
b7de 32 7b ee			ld (debug_mark+1),a  
b7e1 3a eb b7			ld a, (.dmark+2)  
b7e4 32 7c ee			ld (debug_mark+2),a  
b7e7 18 03			jr .pastdmark  
b7e9 ..			.dmark: db "SP2"  
b7ec f1			.pastdmark: pop af  
b7ed			endm  
# End of macro DMARK
b7ed						CALLMONITOR 
b7ed cd 7b 91			call break_point_state  
b7f0				endm  
# End of macro CALLMONITOR
b7f0					endif 
b7f0 3e 20				ld a, ' ' 
b7f2 c5			.spaces1:	push bc 
b7f3 77					ld (hl),a 
b7f4 23					inc hl 
b7f5 c1					pop bc 
b7f6 10 fa				djnz .spaces1 
b7f8 3e 00				ld a,0 
b7fa 77					ld (hl),a 
b7fb 21 75 e3				ld hl, scratch 
b7fe					if DEBUG_FORTH_WORDS 
b7fe						DMARK "SP3" 
b7fe f5				push af  
b7ff 3a 13 b8			ld a, (.dmark)  
b802 32 7a ee			ld (debug_mark),a  
b805 3a 14 b8			ld a, (.dmark+1)  
b808 32 7b ee			ld (debug_mark+1),a  
b80b 3a 15 b8			ld a, (.dmark+2)  
b80e 32 7c ee			ld (debug_mark+2),a  
b811 18 03			jr .pastdmark  
b813 ..			.dmark: db "SP3"  
b816 f1			.pastdmark: pop af  
b817			endm  
# End of macro DMARK
b817						CALLMONITOR 
b817 cd 7b 91			call break_point_state  
b81a				endm  
# End of macro CALLMONITOR
b81a					endif 
b81a cd 5d 97				call forth_apush 
b81d			 
b81d				       NEXTW 
b81d c3 06 99			jp macro_next 
b820				endm 
# End of macro NEXTW
b820			 
b820			 
b820			 
b820			.SCROLL: 
b820				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
b820 53				db WORD_SYS_CORE+63             
b821 4d b8			dw .ATQ            
b823 07				db 6 + 1 
b824 .. 00			db "SCROLL",0              
b82b				endm 
# End of macro CWHEAD
b82b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
b82b					if DEBUG_FORTH_WORDS_KEY 
b82b						DMARK "SCR" 
b82b f5				push af  
b82c 3a 40 b8			ld a, (.dmark)  
b82f 32 7a ee			ld (debug_mark),a  
b832 3a 41 b8			ld a, (.dmark+1)  
b835 32 7b ee			ld (debug_mark+1),a  
b838 3a 42 b8			ld a, (.dmark+2)  
b83b 32 7c ee			ld (debug_mark+2),a  
b83e 18 03			jr .pastdmark  
b840 ..			.dmark: db "SCR"  
b843 f1			.pastdmark: pop af  
b844			endm  
# End of macro DMARK
b844						CALLMONITOR 
b844 cd 7b 91			call break_point_state  
b847				endm  
# End of macro CALLMONITOR
b847					endif 
b847			 
b847 cd f6 87			call scroll_up 
b84a			;	call update_display 
b84a			 
b84a					NEXTW 
b84a c3 06 99			jp macro_next 
b84d				endm 
# End of macro NEXTW
b84d			 
b84d			 
b84d			 
b84d			;		; get dir 
b84d			; 
b84d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b84d			; 
b84d			;		push hl 
b84d			; 
b84d			;		; destroy value TOS 
b84d			; 
b84d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b84d			; 
b84d			;		; get count 
b84d			; 
b84d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b84d			; 
b84d			;		push hl 
b84d			; 
b84d			;		; destroy value TOS 
b84d			; 
b84d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b84d			; 
b84d			;		; one value on hl get other one back 
b84d			; 
b84d			;		pop bc    ; count 
b84d			; 
b84d			;		pop de   ; dir 
b84d			; 
b84d			; 
b84d			;		ld b, c 
b84d			; 
b84d			;.scrolldir:     push bc 
b84d			;		push de 
b84d			; 
b84d			;		ld a, 0 
b84d			;		cp e 
b84d			;		jr z, .scrollup  
b84d			;		call scroll_down 
b84d			;		jr .scrollnext 
b84d			;.scrollup:	call scroll_up 
b84d			; 
b84d			;		 
b84d			;.scrollnext: 
b84d			;		pop de 
b84d			;		pop bc 
b84d			;		djnz .scrolldir 
b84d			; 
b84d			; 
b84d			; 
b84d			; 
b84d			; 
b84d			;		NEXTW 
b84d			 
b84d			 
b84d			 
b84d			 
b84d			.ATQ: 
b84d				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
b84d 62				db WORD_SYS_CORE+78             
b84e ab b8			dw .AUTODSP            
b850 04				db 3 + 1 
b851 .. 00			db "AT@",0              
b855				endm 
# End of macro CWHEAD
b855			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
b855					if DEBUG_FORTH_WORDS_KEY 
b855						DMARK "ATA" 
b855 f5				push af  
b856 3a 6a b8			ld a, (.dmark)  
b859 32 7a ee			ld (debug_mark),a  
b85c 3a 6b b8			ld a, (.dmark+1)  
b85f 32 7b ee			ld (debug_mark+1),a  
b862 3a 6c b8			ld a, (.dmark+2)  
b865 32 7c ee			ld (debug_mark+2),a  
b868 18 03			jr .pastdmark  
b86a ..			.dmark: db "ATA"  
b86d f1			.pastdmark: pop af  
b86e			endm  
# End of macro DMARK
b86e						CALLMONITOR 
b86e cd 7b 91			call break_point_state  
b871				endm  
# End of macro CALLMONITOR
b871					endif 
b871			 
b871			 
b871					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b871 cd b0 97			call macro_dsp_valuehl 
b874				endm 
# End of macro FORTH_DSP_VALUEHL
b874			 
b874					; TODO save cursor row 
b874 7d					ld a,l 
b875 fe 02				cp 2 
b877 20 04				jr nz, .crow3aq 
b879 3e 28				ld a, display_row_2 
b87b 18 12				jr .ccol1aq 
b87d fe 03		.crow3aq:		cp 3 
b87f 20 04				jr nz, .crow4aq 
b881 3e 50				ld a, display_row_3 
b883 18 0a				jr .ccol1aq 
b885 fe 04		.crow4aq:		cp 4 
b887 20 04				jr nz, .crow1aq 
b889 3e 78				ld a, display_row_4 
b88b 18 02				jr .ccol1aq 
b88d 3e 00		.crow1aq:		ld a,display_row_1 
b88f f5			.ccol1aq:		push af			; got row offset 
b890 6f					ld l,a 
b891 26 00				ld h,0 
b893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b893 cd 4c 98			call macro_forth_dsp_pop 
b896				endm 
# End of macro FORTH_DSP_POP
b896					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b896 cd b0 97			call macro_dsp_valuehl 
b899				endm 
# End of macro FORTH_DSP_VALUEHL
b899					; TODO save cursor col 
b899 f1					pop af 
b89a 85					add l		; add col offset 
b89b			 
b89b					; add current frame buffer address 
b89b 2a db eb				ld hl, (display_fb_active) 
b89e cd b7 89				call addatohl 
b8a1			 
b8a1			 
b8a1			 
b8a1			 
b8a1					; get char frame buffer location offset in hl 
b8a1			 
b8a1 7e					ld a,(hl) 
b8a2 26 00				ld h, 0 
b8a4 6f					ld l, a 
b8a5			 
b8a5 cd 15 97				call forth_push_numhl 
b8a8			 
b8a8			 
b8a8					NEXTW 
b8a8 c3 06 99			jp macro_next 
b8ab				endm 
# End of macro NEXTW
b8ab			 
b8ab			.AUTODSP: 
b8ab				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
b8ab 63				db WORD_SYS_CORE+79             
b8ac c1 b8			dw .MENU            
b8ae 05				db 4 + 1 
b8af .. 00			db "ADSP",0              
b8b4				endm 
# End of macro CWHEAD
b8b4			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
b8b4			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
b8b4			 
b8b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8b4 cd b0 97			call macro_dsp_valuehl 
b8b7				endm 
# End of macro FORTH_DSP_VALUEHL
b8b7			 
b8b7			;		push hl 
b8b7			 
b8b7					; destroy value TOS 
b8b7			 
b8b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8b7 cd 4c 98			call macro_forth_dsp_pop 
b8ba				endm 
# End of macro FORTH_DSP_POP
b8ba			 
b8ba			;		pop hl 
b8ba			 
b8ba 7d					ld a,l 
b8bb 32 3c eb				ld (cli_autodisplay), a 
b8be				       NEXTW 
b8be c3 06 99			jp macro_next 
b8c1				endm 
# End of macro NEXTW
b8c1			 
b8c1			.MENU: 
b8c1				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
b8c1 70				db WORD_SYS_CORE+92             
b8c2 cd b8			dw .ENDDISPLAY            
b8c4 05				db 4 + 1 
b8c5 .. 00			db "MENU",0              
b8ca				endm 
# End of macro CWHEAD
b8ca			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
b8ca			 
b8ca					; get the title address and save it 
b8ca			 
b8ca			;		FORTH_DSP_VALUEHL 
b8ca			;		push hl 
b8ca			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8ca			; 
b8ca			;		; get number of items on the stack 
b8ca			; 
b8ca			;	 
b8ca			;		FORTH_DSP_VALUEHL 
b8ca			;		push hl 
b8ca			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8ca			 
b8ca			 
b8ca			 
b8ca			 
b8ca				       NEXTW 
b8ca c3 06 99			jp macro_next 
b8cd				endm 
# End of macro NEXTW
b8cd			 
b8cd			 
b8cd			.ENDDISPLAY: 
b8cd			 
b8cd			; eof 
# End of file forth_words_display.asm
b8cd			include "forth_words_str.asm" 
b8cd			 
b8cd			; | ## String Words 
b8cd			 
b8cd			.PTR:   
b8cd			 
b8cd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
b8cd 48				db WORD_SYS_CORE+52             
b8ce fa b8			dw .STYPE            
b8d0 04				db 3 + 1 
b8d1 .. 00			db "PTR",0              
b8d5				endm 
# End of macro CWHEAD
b8d5			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
b8d5			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
b8d5			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
b8d5			 
b8d5					if DEBUG_FORTH_WORDS_KEY 
b8d5						DMARK "PTR" 
b8d5 f5				push af  
b8d6 3a ea b8			ld a, (.dmark)  
b8d9 32 7a ee			ld (debug_mark),a  
b8dc 3a eb b8			ld a, (.dmark+1)  
b8df 32 7b ee			ld (debug_mark+1),a  
b8e2 3a ec b8			ld a, (.dmark+2)  
b8e5 32 7c ee			ld (debug_mark+2),a  
b8e8 18 03			jr .pastdmark  
b8ea ..			.dmark: db "PTR"  
b8ed f1			.pastdmark: pop af  
b8ee			endm  
# End of macro DMARK
b8ee						CALLMONITOR 
b8ee cd 7b 91			call break_point_state  
b8f1				endm  
# End of macro CALLMONITOR
b8f1					endif 
b8f1					FORTH_DSP_VALUEHL 
b8f1 cd b0 97			call macro_dsp_valuehl 
b8f4				endm 
# End of macro FORTH_DSP_VALUEHL
b8f4 cd 15 97				call forth_push_numhl 
b8f7			 
b8f7			 
b8f7					NEXTW 
b8f7 c3 06 99			jp macro_next 
b8fa				endm 
# End of macro NEXTW
b8fa			.STYPE: 
b8fa				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
b8fa 48				db WORD_SYS_CORE+52             
b8fb 49 b9			dw .UPPER            
b8fd 06				db 5 + 1 
b8fe .. 00			db "STYPE",0              
b904				endm 
# End of macro CWHEAD
b904			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
b904					if DEBUG_FORTH_WORDS_KEY 
b904						DMARK "STY" 
b904 f5				push af  
b905 3a 19 b9			ld a, (.dmark)  
b908 32 7a ee			ld (debug_mark),a  
b90b 3a 1a b9			ld a, (.dmark+1)  
b90e 32 7b ee			ld (debug_mark+1),a  
b911 3a 1b b9			ld a, (.dmark+2)  
b914 32 7c ee			ld (debug_mark+2),a  
b917 18 03			jr .pastdmark  
b919 ..			.dmark: db "STY"  
b91c f1			.pastdmark: pop af  
b91d			endm  
# End of macro DMARK
b91d						CALLMONITOR 
b91d cd 7b 91			call break_point_state  
b920				endm  
# End of macro CALLMONITOR
b920					endif 
b920					FORTH_DSP 
b920 cd 95 97			call macro_forth_dsp 
b923				endm 
# End of macro FORTH_DSP
b923					;v5 FORTH_DSP_VALUE 
b923			 
b923 7e					ld a, (hl) 
b924			 
b924 f5					push af 
b925			 
b925			; Dont destroy TOS		FORTH_DSP_POP 
b925			 
b925 f1					pop af 
b926			 
b926 fe 01				cp DS_TYPE_STR 
b928 28 09				jr z, .typestr 
b92a			 
b92a fe 02				cp DS_TYPE_INUM 
b92c 28 0a				jr z, .typeinum 
b92e			 
b92e 21 47 b9				ld hl, .tna 
b931 18 0a				jr .tpush 
b933			 
b933 21 43 b9		.typestr:	ld hl, .tstr 
b936 18 05				jr .tpush 
b938 21 45 b9		.typeinum:	ld hl, .tinum 
b93b 18 00				jr .tpush 
b93d			 
b93d			.tpush: 
b93d			 
b93d cd 27 97				call forth_push_str 
b940			 
b940					NEXTW 
b940 c3 06 99			jp macro_next 
b943				endm 
# End of macro NEXTW
b943 .. 00		.tstr:	db "s",0 
b945 .. 00		.tinum:  db "i",0 
b947 .. 00		.tna:   db "?", 0 
b949			 
b949			 
b949			.UPPER: 
b949				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
b949 48				db WORD_SYS_CORE+52             
b94a 84 b9			dw .LOWER            
b94c 06				db 5 + 1 
b94d .. 00			db "UPPER",0              
b953				endm 
# End of macro CWHEAD
b953			; | UPPER ( s -- s ) Upper case string s  | DONE 
b953					if DEBUG_FORTH_WORDS_KEY 
b953						DMARK "UPR" 
b953 f5				push af  
b954 3a 68 b9			ld a, (.dmark)  
b957 32 7a ee			ld (debug_mark),a  
b95a 3a 69 b9			ld a, (.dmark+1)  
b95d 32 7b ee			ld (debug_mark+1),a  
b960 3a 6a b9			ld a, (.dmark+2)  
b963 32 7c ee			ld (debug_mark+2),a  
b966 18 03			jr .pastdmark  
b968 ..			.dmark: db "UPR"  
b96b f1			.pastdmark: pop af  
b96c			endm  
# End of macro DMARK
b96c						CALLMONITOR 
b96c cd 7b 91			call break_point_state  
b96f				endm  
# End of macro CALLMONITOR
b96f					endif 
b96f			 
b96f					FORTH_DSP 
b96f cd 95 97			call macro_forth_dsp 
b972				endm 
# End of macro FORTH_DSP
b972					 
b972			; TODO check is string type 
b972			 
b972					FORTH_DSP_VALUEHL 
b972 cd b0 97			call macro_dsp_valuehl 
b975				endm 
# End of macro FORTH_DSP_VALUEHL
b975			; get pointer to string in hl 
b975			 
b975 7e			.toup:		ld a, (hl) 
b976 fe 00				cp 0 
b978 28 07				jr z, .toupdone 
b97a			 
b97a cd 24 8d				call to_upper 
b97d			 
b97d 77					ld (hl), a 
b97e 23					inc hl 
b97f 18 f4				jr .toup 
b981			 
b981					 
b981			 
b981			 
b981			; for each char convert to upper 
b981					 
b981			.toupdone: 
b981			 
b981			 
b981					NEXTW 
b981 c3 06 99			jp macro_next 
b984				endm 
# End of macro NEXTW
b984			.LOWER: 
b984				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
b984 48				db WORD_SYS_CORE+52             
b985 bf b9			dw .TCASE            
b987 06				db 5 + 1 
b988 .. 00			db "LOWER",0              
b98e				endm 
# End of macro CWHEAD
b98e			; | LOWER ( s -- s ) Lower case string s  | DONE 
b98e					if DEBUG_FORTH_WORDS_KEY 
b98e						DMARK "LWR" 
b98e f5				push af  
b98f 3a a3 b9			ld a, (.dmark)  
b992 32 7a ee			ld (debug_mark),a  
b995 3a a4 b9			ld a, (.dmark+1)  
b998 32 7b ee			ld (debug_mark+1),a  
b99b 3a a5 b9			ld a, (.dmark+2)  
b99e 32 7c ee			ld (debug_mark+2),a  
b9a1 18 03			jr .pastdmark  
b9a3 ..			.dmark: db "LWR"  
b9a6 f1			.pastdmark: pop af  
b9a7			endm  
# End of macro DMARK
b9a7						CALLMONITOR 
b9a7 cd 7b 91			call break_point_state  
b9aa				endm  
# End of macro CALLMONITOR
b9aa					endif 
b9aa			 
b9aa					FORTH_DSP 
b9aa cd 95 97			call macro_forth_dsp 
b9ad				endm 
# End of macro FORTH_DSP
b9ad					 
b9ad			; TODO check is string type 
b9ad			 
b9ad					FORTH_DSP_VALUEHL 
b9ad cd b0 97			call macro_dsp_valuehl 
b9b0				endm 
# End of macro FORTH_DSP_VALUEHL
b9b0			; get pointer to string in hl 
b9b0			 
b9b0 7e			.tolow:		ld a, (hl) 
b9b1 fe 00				cp 0 
b9b3 28 07				jr z, .tolowdone 
b9b5			 
b9b5 cd 2d 8d				call to_lower 
b9b8			 
b9b8 77					ld (hl), a 
b9b9 23					inc hl 
b9ba 18 f4				jr .tolow 
b9bc			 
b9bc					 
b9bc			 
b9bc			 
b9bc			; for each char convert to low 
b9bc					 
b9bc			.tolowdone: 
b9bc					NEXTW 
b9bc c3 06 99			jp macro_next 
b9bf				endm 
# End of macro NEXTW
b9bf			.TCASE: 
b9bf				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
b9bf 48				db WORD_SYS_CORE+52             
b9c0 f5 ba			dw .SUBSTR            
b9c2 06				db 5 + 1 
b9c3 .. 00			db "TCASE",0              
b9c9				endm 
# End of macro CWHEAD
b9c9			; | TCASE ( s -- s ) Title case string s  | DONE 
b9c9					if DEBUG_FORTH_WORDS_KEY 
b9c9						DMARK "TCS" 
b9c9 f5				push af  
b9ca 3a de b9			ld a, (.dmark)  
b9cd 32 7a ee			ld (debug_mark),a  
b9d0 3a df b9			ld a, (.dmark+1)  
b9d3 32 7b ee			ld (debug_mark+1),a  
b9d6 3a e0 b9			ld a, (.dmark+2)  
b9d9 32 7c ee			ld (debug_mark+2),a  
b9dc 18 03			jr .pastdmark  
b9de ..			.dmark: db "TCS"  
b9e1 f1			.pastdmark: pop af  
b9e2			endm  
# End of macro DMARK
b9e2						CALLMONITOR 
b9e2 cd 7b 91			call break_point_state  
b9e5				endm  
# End of macro CALLMONITOR
b9e5					endif 
b9e5			 
b9e5					FORTH_DSP 
b9e5 cd 95 97			call macro_forth_dsp 
b9e8				endm 
# End of macro FORTH_DSP
b9e8					 
b9e8			; TODO check is string type 
b9e8			 
b9e8					FORTH_DSP_VALUEHL 
b9e8 cd b0 97			call macro_dsp_valuehl 
b9eb				endm 
# End of macro FORTH_DSP_VALUEHL
b9eb			; get pointer to string in hl 
b9eb			 
b9eb					if DEBUG_FORTH_WORDS 
b9eb						DMARK "TC1" 
b9eb f5				push af  
b9ec 3a 00 ba			ld a, (.dmark)  
b9ef 32 7a ee			ld (debug_mark),a  
b9f2 3a 01 ba			ld a, (.dmark+1)  
b9f5 32 7b ee			ld (debug_mark+1),a  
b9f8 3a 02 ba			ld a, (.dmark+2)  
b9fb 32 7c ee			ld (debug_mark+2),a  
b9fe 18 03			jr .pastdmark  
ba00 ..			.dmark: db "TC1"  
ba03 f1			.pastdmark: pop af  
ba04			endm  
# End of macro DMARK
ba04						CALLMONITOR 
ba04 cd 7b 91			call break_point_state  
ba07				endm  
# End of macro CALLMONITOR
ba07					endif 
ba07			 
ba07					; first time in turn to upper case first char 
ba07			 
ba07 7e					ld a, (hl) 
ba08 c3 92 ba				jp .totsiptou 
ba0b			 
ba0b			 
ba0b 7e			.tot:		ld a, (hl) 
ba0c fe 00				cp 0 
ba0e ca d6 ba				jp z, .totdone 
ba11			 
ba11					if DEBUG_FORTH_WORDS 
ba11						DMARK "TC2" 
ba11 f5				push af  
ba12 3a 26 ba			ld a, (.dmark)  
ba15 32 7a ee			ld (debug_mark),a  
ba18 3a 27 ba			ld a, (.dmark+1)  
ba1b 32 7b ee			ld (debug_mark+1),a  
ba1e 3a 28 ba			ld a, (.dmark+2)  
ba21 32 7c ee			ld (debug_mark+2),a  
ba24 18 03			jr .pastdmark  
ba26 ..			.dmark: db "TC2"  
ba29 f1			.pastdmark: pop af  
ba2a			endm  
# End of macro DMARK
ba2a						CALLMONITOR 
ba2a cd 7b 91			call break_point_state  
ba2d				endm  
# End of macro CALLMONITOR
ba2d					endif 
ba2d					; check to see if current char is a space 
ba2d			 
ba2d fe 20				cp ' ' 
ba2f 28 21				jr z, .totsp 
ba31 cd 2d 8d				call to_lower 
ba34					if DEBUG_FORTH_WORDS 
ba34						DMARK "TC3" 
ba34 f5				push af  
ba35 3a 49 ba			ld a, (.dmark)  
ba38 32 7a ee			ld (debug_mark),a  
ba3b 3a 4a ba			ld a, (.dmark+1)  
ba3e 32 7b ee			ld (debug_mark+1),a  
ba41 3a 4b ba			ld a, (.dmark+2)  
ba44 32 7c ee			ld (debug_mark+2),a  
ba47 18 03			jr .pastdmark  
ba49 ..			.dmark: db "TC3"  
ba4c f1			.pastdmark: pop af  
ba4d			endm  
# End of macro DMARK
ba4d						CALLMONITOR 
ba4d cd 7b 91			call break_point_state  
ba50				endm  
# End of macro CALLMONITOR
ba50					endif 
ba50 18 63				jr .totnxt 
ba52			 
ba52			.totsp:         ; on a space, find next char which should be upper 
ba52			 
ba52					if DEBUG_FORTH_WORDS 
ba52						DMARK "TC4" 
ba52 f5				push af  
ba53 3a 67 ba			ld a, (.dmark)  
ba56 32 7a ee			ld (debug_mark),a  
ba59 3a 68 ba			ld a, (.dmark+1)  
ba5c 32 7b ee			ld (debug_mark+1),a  
ba5f 3a 69 ba			ld a, (.dmark+2)  
ba62 32 7c ee			ld (debug_mark+2),a  
ba65 18 03			jr .pastdmark  
ba67 ..			.dmark: db "TC4"  
ba6a f1			.pastdmark: pop af  
ba6b			endm  
# End of macro DMARK
ba6b						CALLMONITOR 
ba6b cd 7b 91			call break_point_state  
ba6e				endm  
# End of macro CALLMONITOR
ba6e					endif 
ba6e					;; 
ba6e			 
ba6e fe 20				cp ' ' 
ba70 20 20				jr nz, .totsiptou 
ba72 23					inc hl 
ba73 7e					ld a, (hl) 
ba74					if DEBUG_FORTH_WORDS 
ba74						DMARK "TC5" 
ba74 f5				push af  
ba75 3a 89 ba			ld a, (.dmark)  
ba78 32 7a ee			ld (debug_mark),a  
ba7b 3a 8a ba			ld a, (.dmark+1)  
ba7e 32 7b ee			ld (debug_mark+1),a  
ba81 3a 8b ba			ld a, (.dmark+2)  
ba84 32 7c ee			ld (debug_mark+2),a  
ba87 18 03			jr .pastdmark  
ba89 ..			.dmark: db "TC5"  
ba8c f1			.pastdmark: pop af  
ba8d			endm  
# End of macro DMARK
ba8d						CALLMONITOR 
ba8d cd 7b 91			call break_point_state  
ba90				endm  
# End of macro CALLMONITOR
ba90					endif 
ba90 18 c0				jr .totsp 
ba92 fe 00		.totsiptou:    cp 0 
ba94 28 40				jr z, .totdone 
ba96					; not space and not zero term so upper case it 
ba96 cd 24 8d				call to_upper 
ba99			 
ba99					if DEBUG_FORTH_WORDS 
ba99						DMARK "TC6" 
ba99 f5				push af  
ba9a 3a ae ba			ld a, (.dmark)  
ba9d 32 7a ee			ld (debug_mark),a  
baa0 3a af ba			ld a, (.dmark+1)  
baa3 32 7b ee			ld (debug_mark+1),a  
baa6 3a b0 ba			ld a, (.dmark+2)  
baa9 32 7c ee			ld (debug_mark+2),a  
baac 18 03			jr .pastdmark  
baae ..			.dmark: db "TC6"  
bab1 f1			.pastdmark: pop af  
bab2			endm  
# End of macro DMARK
bab2						CALLMONITOR 
bab2 cd 7b 91			call break_point_state  
bab5				endm  
# End of macro CALLMONITOR
bab5					endif 
bab5			 
bab5			 
bab5			.totnxt: 
bab5			 
bab5 77					ld (hl), a 
bab6 23					inc hl 
bab7					if DEBUG_FORTH_WORDS 
bab7						DMARK "TC7" 
bab7 f5				push af  
bab8 3a cc ba			ld a, (.dmark)  
babb 32 7a ee			ld (debug_mark),a  
babe 3a cd ba			ld a, (.dmark+1)  
bac1 32 7b ee			ld (debug_mark+1),a  
bac4 3a ce ba			ld a, (.dmark+2)  
bac7 32 7c ee			ld (debug_mark+2),a  
baca 18 03			jr .pastdmark  
bacc ..			.dmark: db "TC7"  
bacf f1			.pastdmark: pop af  
bad0			endm  
# End of macro DMARK
bad0						CALLMONITOR 
bad0 cd 7b 91			call break_point_state  
bad3				endm  
# End of macro CALLMONITOR
bad3					endif 
bad3 c3 0b ba				jp .tot 
bad6			 
bad6					 
bad6			 
bad6			 
bad6			; for each char convert to low 
bad6					 
bad6			.totdone: 
bad6					if DEBUG_FORTH_WORDS 
bad6						DMARK "TCd" 
bad6 f5				push af  
bad7 3a eb ba			ld a, (.dmark)  
bada 32 7a ee			ld (debug_mark),a  
badd 3a ec ba			ld a, (.dmark+1)  
bae0 32 7b ee			ld (debug_mark+1),a  
bae3 3a ed ba			ld a, (.dmark+2)  
bae6 32 7c ee			ld (debug_mark+2),a  
bae9 18 03			jr .pastdmark  
baeb ..			.dmark: db "TCd"  
baee f1			.pastdmark: pop af  
baef			endm  
# End of macro DMARK
baef						CALLMONITOR 
baef cd 7b 91			call break_point_state  
baf2				endm  
# End of macro CALLMONITOR
baf2					endif 
baf2					NEXTW 
baf2 c3 06 99			jp macro_next 
baf5				endm 
# End of macro NEXTW
baf5			 
baf5			.SUBSTR: 
baf5				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
baf5 48				db WORD_SYS_CORE+52             
baf6 53 bb			dw .LEFT            
baf8 07				db 6 + 1 
baf9 .. 00			db "SUBSTR",0              
bb00				endm 
# End of macro CWHEAD
bb00			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bb00			 
bb00					if DEBUG_FORTH_WORDS_KEY 
bb00						DMARK "SST" 
bb00 f5				push af  
bb01 3a 15 bb			ld a, (.dmark)  
bb04 32 7a ee			ld (debug_mark),a  
bb07 3a 16 bb			ld a, (.dmark+1)  
bb0a 32 7b ee			ld (debug_mark+1),a  
bb0d 3a 17 bb			ld a, (.dmark+2)  
bb10 32 7c ee			ld (debug_mark+2),a  
bb13 18 03			jr .pastdmark  
bb15 ..			.dmark: db "SST"  
bb18 f1			.pastdmark: pop af  
bb19			endm  
# End of macro DMARK
bb19						CALLMONITOR 
bb19 cd 7b 91			call break_point_state  
bb1c				endm  
# End of macro CALLMONITOR
bb1c					endif 
bb1c			; TODO check string type 
bb1c					FORTH_DSP_VALUEHL 
bb1c cd b0 97			call macro_dsp_valuehl 
bb1f				endm 
# End of macro FORTH_DSP_VALUEHL
bb1f			 
bb1f e5					push hl      ; string length 
bb20			 
bb20					FORTH_DSP_POP 
bb20 cd 4c 98			call macro_forth_dsp_pop 
bb23				endm 
# End of macro FORTH_DSP_POP
bb23			 
bb23					FORTH_DSP_VALUEHL 
bb23 cd b0 97			call macro_dsp_valuehl 
bb26				endm 
# End of macro FORTH_DSP_VALUEHL
bb26			 
bb26 e5					push hl     ; start char 
bb27			 
bb27					FORTH_DSP_POP 
bb27 cd 4c 98			call macro_forth_dsp_pop 
bb2a				endm 
# End of macro FORTH_DSP_POP
bb2a			 
bb2a			 
bb2a					FORTH_DSP_VALUE 
bb2a cd 99 97			call macro_forth_dsp_value 
bb2d				endm 
# End of macro FORTH_DSP_VALUE
bb2d			 
bb2d d1					pop de    ; get start post offset 
bb2e			 
bb2e 19					add hl, de    ; starting offset 
bb2f			 
bb2f c1					pop bc 
bb30 c5					push bc      ; grab size of string 
bb31			 
bb31 e5					push hl    ; save string start  
bb32			 
bb32 26 00				ld h, 0 
bb34 69					ld l, c 
bb35 23					inc hl 
bb36 23					inc hl 
bb37			 
bb37 cd 7e 8e				call malloc 
bb3a				if DEBUG_FORTH_MALLOC_GUARD 
bb3a cc 69 c1				call z,malloc_error 
bb3d				endif 
bb3d			 
bb3d eb					ex de, hl      ; save malloc area for string copy 
bb3e e1					pop hl    ; get back source 
bb3f c1					pop bc    ; get length of string back 
bb40			 
bb40 d5					push de    ; save malloc area for after we push 
bb41 ed b0				ldir     ; copy substr 
bb43			 
bb43			 
bb43 eb					ex de, hl 
bb44 3e 00				ld a, 0 
bb46 77					ld (hl), a   ; term substr 
bb47			 
bb47					 
bb47 e1					pop hl    ; get malloc so we can push it 
bb48 e5					push hl   ; save so we can free it afterwards 
bb49			 
bb49 cd 27 97				call forth_push_str 
bb4c			 
bb4c e1					pop hl 
bb4d cd 48 8f				call free 
bb50			 
bb50					 
bb50					 
bb50			 
bb50			 
bb50					NEXTW 
bb50 c3 06 99			jp macro_next 
bb53				endm 
# End of macro NEXTW
bb53			 
bb53			.LEFT: 
bb53				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bb53 48				db WORD_SYS_CORE+52             
bb54 7b bb			dw .RIGHT            
bb56 05				db 4 + 1 
bb57 .. 00			db "LEFT",0              
bb5c				endm 
# End of macro CWHEAD
bb5c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bb5c					if DEBUG_FORTH_WORDS_KEY 
bb5c						DMARK "LEF" 
bb5c f5				push af  
bb5d 3a 71 bb			ld a, (.dmark)  
bb60 32 7a ee			ld (debug_mark),a  
bb63 3a 72 bb			ld a, (.dmark+1)  
bb66 32 7b ee			ld (debug_mark+1),a  
bb69 3a 73 bb			ld a, (.dmark+2)  
bb6c 32 7c ee			ld (debug_mark+2),a  
bb6f 18 03			jr .pastdmark  
bb71 ..			.dmark: db "LEF"  
bb74 f1			.pastdmark: pop af  
bb75			endm  
# End of macro DMARK
bb75						CALLMONITOR 
bb75 cd 7b 91			call break_point_state  
bb78				endm  
# End of macro CALLMONITOR
bb78					endif 
bb78			 
bb78					NEXTW 
bb78 c3 06 99			jp macro_next 
bb7b				endm 
# End of macro NEXTW
bb7b			.RIGHT: 
bb7b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bb7b 48				db WORD_SYS_CORE+52             
bb7c a4 bb			dw .STR2NUM            
bb7e 06				db 5 + 1 
bb7f .. 00			db "RIGHT",0              
bb85				endm 
# End of macro CWHEAD
bb85			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bb85					if DEBUG_FORTH_WORDS_KEY 
bb85						DMARK "RIG" 
bb85 f5				push af  
bb86 3a 9a bb			ld a, (.dmark)  
bb89 32 7a ee			ld (debug_mark),a  
bb8c 3a 9b bb			ld a, (.dmark+1)  
bb8f 32 7b ee			ld (debug_mark+1),a  
bb92 3a 9c bb			ld a, (.dmark+2)  
bb95 32 7c ee			ld (debug_mark+2),a  
bb98 18 03			jr .pastdmark  
bb9a ..			.dmark: db "RIG"  
bb9d f1			.pastdmark: pop af  
bb9e			endm  
# End of macro DMARK
bb9e						CALLMONITOR 
bb9e cd 7b 91			call break_point_state  
bba1				endm  
# End of macro CALLMONITOR
bba1					endif 
bba1			 
bba1					NEXTW 
bba1 c3 06 99			jp macro_next 
bba4				endm 
# End of macro NEXTW
bba4			 
bba4			 
bba4			.STR2NUM: 
bba4				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bba4 48				db WORD_SYS_CORE+52             
bba5 30 bc			dw .NUM2STR            
bba7 08				db 7 + 1 
bba8 .. 00			db "STR2NUM",0              
bbb0				endm 
# End of macro CWHEAD
bbb0			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bbb0			 
bbb0			 
bbb0			; TODO STR type check to do 
bbb0					if DEBUG_FORTH_WORDS_KEY 
bbb0						DMARK "S2N" 
bbb0 f5				push af  
bbb1 3a c5 bb			ld a, (.dmark)  
bbb4 32 7a ee			ld (debug_mark),a  
bbb7 3a c6 bb			ld a, (.dmark+1)  
bbba 32 7b ee			ld (debug_mark+1),a  
bbbd 3a c7 bb			ld a, (.dmark+2)  
bbc0 32 7c ee			ld (debug_mark+2),a  
bbc3 18 03			jr .pastdmark  
bbc5 ..			.dmark: db "S2N"  
bbc8 f1			.pastdmark: pop af  
bbc9			endm  
# End of macro DMARK
bbc9						CALLMONITOR 
bbc9 cd 7b 91			call break_point_state  
bbcc				endm  
# End of macro CALLMONITOR
bbcc					endif 
bbcc			 
bbcc					;FORTH_DSP 
bbcc					FORTH_DSP_VALUE 
bbcc cd 99 97			call macro_forth_dsp_value 
bbcf				endm 
# End of macro FORTH_DSP_VALUE
bbcf					;inc hl 
bbcf			 
bbcf eb					ex de, hl 
bbd0					if DEBUG_FORTH_WORDS 
bbd0						DMARK "S2a" 
bbd0 f5				push af  
bbd1 3a e5 bb			ld a, (.dmark)  
bbd4 32 7a ee			ld (debug_mark),a  
bbd7 3a e6 bb			ld a, (.dmark+1)  
bbda 32 7b ee			ld (debug_mark+1),a  
bbdd 3a e7 bb			ld a, (.dmark+2)  
bbe0 32 7c ee			ld (debug_mark+2),a  
bbe3 18 03			jr .pastdmark  
bbe5 ..			.dmark: db "S2a"  
bbe8 f1			.pastdmark: pop af  
bbe9			endm  
# End of macro DMARK
bbe9						CALLMONITOR 
bbe9 cd 7b 91			call break_point_state  
bbec				endm  
# End of macro CALLMONITOR
bbec					endif 
bbec cd ac 8d				call string_to_uint16 
bbef			 
bbef					if DEBUG_FORTH_WORDS 
bbef						DMARK "S2b" 
bbef f5				push af  
bbf0 3a 04 bc			ld a, (.dmark)  
bbf3 32 7a ee			ld (debug_mark),a  
bbf6 3a 05 bc			ld a, (.dmark+1)  
bbf9 32 7b ee			ld (debug_mark+1),a  
bbfc 3a 06 bc			ld a, (.dmark+2)  
bbff 32 7c ee			ld (debug_mark+2),a  
bc02 18 03			jr .pastdmark  
bc04 ..			.dmark: db "S2b"  
bc07 f1			.pastdmark: pop af  
bc08			endm  
# End of macro DMARK
bc08						CALLMONITOR 
bc08 cd 7b 91			call break_point_state  
bc0b				endm  
# End of macro CALLMONITOR
bc0b					endif 
bc0b			;		push hl 
bc0b					FORTH_DSP_POP 
bc0b cd 4c 98			call macro_forth_dsp_pop 
bc0e				endm 
# End of macro FORTH_DSP_POP
bc0e			;		pop hl 
bc0e					 
bc0e					if DEBUG_FORTH_WORDS 
bc0e						DMARK "S2b" 
bc0e f5				push af  
bc0f 3a 23 bc			ld a, (.dmark)  
bc12 32 7a ee			ld (debug_mark),a  
bc15 3a 24 bc			ld a, (.dmark+1)  
bc18 32 7b ee			ld (debug_mark+1),a  
bc1b 3a 25 bc			ld a, (.dmark+2)  
bc1e 32 7c ee			ld (debug_mark+2),a  
bc21 18 03			jr .pastdmark  
bc23 ..			.dmark: db "S2b"  
bc26 f1			.pastdmark: pop af  
bc27			endm  
# End of macro DMARK
bc27						CALLMONITOR 
bc27 cd 7b 91			call break_point_state  
bc2a				endm  
# End of macro CALLMONITOR
bc2a					endif 
bc2a cd 15 97				call forth_push_numhl	 
bc2d			 
bc2d				 
bc2d				       NEXTW 
bc2d c3 06 99			jp macro_next 
bc30				endm 
# End of macro NEXTW
bc30			.NUM2STR: 
bc30				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bc30 48				db WORD_SYS_CORE+52             
bc31 3f bc			dw .CONCAT            
bc33 08				db 7 + 1 
bc34 .. 00			db "NUM2STR",0              
bc3c				endm 
# End of macro CWHEAD
bc3c			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bc3c			 
bc3c			;		; malloc a string to target 
bc3c			;		ld hl, 10     ; TODO max string size should be fine 
bc3c			;		call malloc 
bc3c			;		push hl    ; save malloc location 
bc3c			; 
bc3c			; 
bc3c			;; TODO check int type 
bc3c			;		FORTH_DSP_VALUEHL 
bc3c			;		ld a, l 
bc3c			;		call DispAToASCII   
bc3c			;;TODO need to chage above call to dump into string 
bc3c			; 
bc3c			; 
bc3c			 
bc3c				       NEXTW 
bc3c c3 06 99			jp macro_next 
bc3f				endm 
# End of macro NEXTW
bc3f			 
bc3f			.CONCAT: 
bc3f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bc3f 48				db WORD_SYS_CORE+52             
bc40 f2 bc			dw .FIND            
bc42 07				db 6 + 1 
bc43 .. 00			db "CONCAT",0              
bc4a				endm 
# End of macro CWHEAD
bc4a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bc4a			 
bc4a			; TODO check string type 
bc4a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bc4a			 
bc4a					if DEBUG_FORTH_WORDS_KEY 
bc4a						DMARK "CON" 
bc4a f5				push af  
bc4b 3a 5f bc			ld a, (.dmark)  
bc4e 32 7a ee			ld (debug_mark),a  
bc51 3a 60 bc			ld a, (.dmark+1)  
bc54 32 7b ee			ld (debug_mark+1),a  
bc57 3a 61 bc			ld a, (.dmark+2)  
bc5a 32 7c ee			ld (debug_mark+2),a  
bc5d 18 03			jr .pastdmark  
bc5f ..			.dmark: db "CON"  
bc62 f1			.pastdmark: pop af  
bc63			endm  
# End of macro DMARK
bc63						CALLMONITOR 
bc63 cd 7b 91			call break_point_state  
bc66				endm  
# End of macro CALLMONITOR
bc66					endif 
bc66			 
bc66			 
bc66					FORTH_DSP_VALUE 
bc66 cd 99 97			call macro_forth_dsp_value 
bc69				endm 
# End of macro FORTH_DSP_VALUE
bc69 e5					push hl   ; s2 
bc6a			 
bc6a					FORTH_DSP_POP 
bc6a cd 4c 98			call macro_forth_dsp_pop 
bc6d				endm 
# End of macro FORTH_DSP_POP
bc6d			 
bc6d					FORTH_DSP_VALUE 
bc6d cd 99 97			call macro_forth_dsp_value 
bc70				endm 
# End of macro FORTH_DSP_VALUE
bc70			 
bc70 e5					push hl   ; s1 
bc71			 
bc71					FORTH_DSP_POP 
bc71 cd 4c 98			call macro_forth_dsp_pop 
bc74				endm 
# End of macro FORTH_DSP_POP
bc74					 
bc74			 
bc74					; copy s1 
bc74			 
bc74				 
bc74					; save ptr 
bc74 e1					pop hl  
bc75 e5					push hl 
bc76 3e 00				ld a, 0 
bc78 cd 20 8e				call strlent 
bc7b					;inc hl    ; zer0 
bc7b 06 00				ld b, 0 
bc7d 4d					ld c, l 
bc7e e1					pop hl		 
bc7f 11 75 e3				ld de, scratch	 
bc82					if DEBUG_FORTH_WORDS 
bc82						DMARK "CO1" 
bc82 f5				push af  
bc83 3a 97 bc			ld a, (.dmark)  
bc86 32 7a ee			ld (debug_mark),a  
bc89 3a 98 bc			ld a, (.dmark+1)  
bc8c 32 7b ee			ld (debug_mark+1),a  
bc8f 3a 99 bc			ld a, (.dmark+2)  
bc92 32 7c ee			ld (debug_mark+2),a  
bc95 18 03			jr .pastdmark  
bc97 ..			.dmark: db "CO1"  
bc9a f1			.pastdmark: pop af  
bc9b			endm  
# End of macro DMARK
bc9b						CALLMONITOR 
bc9b cd 7b 91			call break_point_state  
bc9e				endm  
# End of macro CALLMONITOR
bc9e					endif 
bc9e ed b0				ldir 
bca0			 
bca0 e1					pop hl 
bca1 e5					push hl 
bca2 d5					push de 
bca3			 
bca3			 
bca3 3e 00				ld a, 0 
bca5 cd 20 8e				call strlent 
bca8 23					inc hl    ; zer0 
bca9 23					inc hl 
bcaa 06 00				ld b, 0 
bcac 4d					ld c, l 
bcad d1					pop de 
bcae e1					pop hl		 
bcaf					if DEBUG_FORTH_WORDS 
bcaf						DMARK "CO2" 
bcaf f5				push af  
bcb0 3a c4 bc			ld a, (.dmark)  
bcb3 32 7a ee			ld (debug_mark),a  
bcb6 3a c5 bc			ld a, (.dmark+1)  
bcb9 32 7b ee			ld (debug_mark+1),a  
bcbc 3a c6 bc			ld a, (.dmark+2)  
bcbf 32 7c ee			ld (debug_mark+2),a  
bcc2 18 03			jr .pastdmark  
bcc4 ..			.dmark: db "CO2"  
bcc7 f1			.pastdmark: pop af  
bcc8			endm  
# End of macro DMARK
bcc8						CALLMONITOR 
bcc8 cd 7b 91			call break_point_state  
bccb				endm  
# End of macro CALLMONITOR
bccb					endif 
bccb ed b0				ldir 
bccd			 
bccd			 
bccd			 
bccd 21 75 e3				ld hl, scratch 
bcd0					if DEBUG_FORTH_WORDS 
bcd0						DMARK "CO5" 
bcd0 f5				push af  
bcd1 3a e5 bc			ld a, (.dmark)  
bcd4 32 7a ee			ld (debug_mark),a  
bcd7 3a e6 bc			ld a, (.dmark+1)  
bcda 32 7b ee			ld (debug_mark+1),a  
bcdd 3a e7 bc			ld a, (.dmark+2)  
bce0 32 7c ee			ld (debug_mark+2),a  
bce3 18 03			jr .pastdmark  
bce5 ..			.dmark: db "CO5"  
bce8 f1			.pastdmark: pop af  
bce9			endm  
# End of macro DMARK
bce9						CALLMONITOR 
bce9 cd 7b 91			call break_point_state  
bcec				endm  
# End of macro CALLMONITOR
bcec					endif 
bcec			 
bcec cd 27 97				call forth_push_str 
bcef			 
bcef			 
bcef			 
bcef			 
bcef				       NEXTW 
bcef c3 06 99			jp macro_next 
bcf2				endm 
# End of macro NEXTW
bcf2			 
bcf2			 
bcf2			.FIND: 
bcf2				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bcf2 4b				db WORD_SYS_CORE+55             
bcf3 b0 bd			dw .LEN            
bcf5 05				db 4 + 1 
bcf6 .. 00			db "FIND",0              
bcfb				endm 
# End of macro CWHEAD
bcfb			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
bcfb			 
bcfb					if DEBUG_FORTH_WORDS_KEY 
bcfb						DMARK "FND" 
bcfb f5				push af  
bcfc 3a 10 bd			ld a, (.dmark)  
bcff 32 7a ee			ld (debug_mark),a  
bd02 3a 11 bd			ld a, (.dmark+1)  
bd05 32 7b ee			ld (debug_mark+1),a  
bd08 3a 12 bd			ld a, (.dmark+2)  
bd0b 32 7c ee			ld (debug_mark+2),a  
bd0e 18 03			jr .pastdmark  
bd10 ..			.dmark: db "FND"  
bd13 f1			.pastdmark: pop af  
bd14			endm  
# End of macro DMARK
bd14						CALLMONITOR 
bd14 cd 7b 91			call break_point_state  
bd17				endm  
# End of macro CALLMONITOR
bd17					endif 
bd17			 
bd17			; TODO check string type 
bd17					FORTH_DSP_VALUE 
bd17 cd 99 97			call macro_forth_dsp_value 
bd1a				endm 
# End of macro FORTH_DSP_VALUE
bd1a			 
bd1a e5					push hl    
bd1b 7e					ld a,(hl)    ; char to find   
bd1c			; TODO change char to substr 
bd1c			 
bd1c f5					push af 
bd1d					 
bd1d			 
bd1d			 
bd1d					if DEBUG_FORTH_WORDS 
bd1d						DMARK "FN1" 
bd1d f5				push af  
bd1e 3a 32 bd			ld a, (.dmark)  
bd21 32 7a ee			ld (debug_mark),a  
bd24 3a 33 bd			ld a, (.dmark+1)  
bd27 32 7b ee			ld (debug_mark+1),a  
bd2a 3a 34 bd			ld a, (.dmark+2)  
bd2d 32 7c ee			ld (debug_mark+2),a  
bd30 18 03			jr .pastdmark  
bd32 ..			.dmark: db "FN1"  
bd35 f1			.pastdmark: pop af  
bd36			endm  
# End of macro DMARK
bd36						CALLMONITOR 
bd36 cd 7b 91			call break_point_state  
bd39				endm  
# End of macro CALLMONITOR
bd39					endif 
bd39			 
bd39					FORTH_DSP_POP 
bd39 cd 4c 98			call macro_forth_dsp_pop 
bd3c				endm 
# End of macro FORTH_DSP_POP
bd3c			 
bd3c					; string to search 
bd3c			 
bd3c					FORTH_DSP_VALUE 
bd3c cd 99 97			call macro_forth_dsp_value 
bd3f				endm 
# End of macro FORTH_DSP_VALUE
bd3f			 
bd3f d1					pop de  ; d is char to find  
bd40			 
bd40					if DEBUG_FORTH_WORDS 
bd40						DMARK "FN2" 
bd40 f5				push af  
bd41 3a 55 bd			ld a, (.dmark)  
bd44 32 7a ee			ld (debug_mark),a  
bd47 3a 56 bd			ld a, (.dmark+1)  
bd4a 32 7b ee			ld (debug_mark+1),a  
bd4d 3a 57 bd			ld a, (.dmark+2)  
bd50 32 7c ee			ld (debug_mark+2),a  
bd53 18 03			jr .pastdmark  
bd55 ..			.dmark: db "FN2"  
bd58 f1			.pastdmark: pop af  
bd59			endm  
# End of macro DMARK
bd59						CALLMONITOR 
bd59 cd 7b 91			call break_point_state  
bd5c				endm  
# End of macro CALLMONITOR
bd5c					endif 
bd5c					 
bd5c 01 00 00				ld bc, 0 
bd5f 7e			.findchar:      ld a,(hl) 
bd60 fe 00				cp 0   		 
bd62 28 27				jr z, .finddone     
bd64 ba					cp d 
bd65 28 20				jr z, .foundchar 
bd67 03					inc bc 
bd68 23					inc hl 
bd69					if DEBUG_FORTH_WORDS 
bd69						DMARK "FN3" 
bd69 f5				push af  
bd6a 3a 7e bd			ld a, (.dmark)  
bd6d 32 7a ee			ld (debug_mark),a  
bd70 3a 7f bd			ld a, (.dmark+1)  
bd73 32 7b ee			ld (debug_mark+1),a  
bd76 3a 80 bd			ld a, (.dmark+2)  
bd79 32 7c ee			ld (debug_mark+2),a  
bd7c 18 03			jr .pastdmark  
bd7e ..			.dmark: db "FN3"  
bd81 f1			.pastdmark: pop af  
bd82			endm  
# End of macro DMARK
bd82						CALLMONITOR 
bd82 cd 7b 91			call break_point_state  
bd85				endm  
# End of macro CALLMONITOR
bd85					endif 
bd85 18 d8				jr .findchar 
bd87			 
bd87			 
bd87 c5			.foundchar:	push bc 
bd88 e1					pop hl 
bd89 18 03				jr .findexit 
bd8b			 
bd8b			 
bd8b							 
bd8b			 
bd8b			.finddone:     ; got to end of string with no find 
bd8b 21 00 00				ld hl, 0 
bd8e			.findexit: 
bd8e			 
bd8e					if DEBUG_FORTH_WORDS 
bd8e						DMARK "FNd" 
bd8e f5				push af  
bd8f 3a a3 bd			ld a, (.dmark)  
bd92 32 7a ee			ld (debug_mark),a  
bd95 3a a4 bd			ld a, (.dmark+1)  
bd98 32 7b ee			ld (debug_mark+1),a  
bd9b 3a a5 bd			ld a, (.dmark+2)  
bd9e 32 7c ee			ld (debug_mark+2),a  
bda1 18 03			jr .pastdmark  
bda3 ..			.dmark: db "FNd"  
bda6 f1			.pastdmark: pop af  
bda7			endm  
# End of macro DMARK
bda7						CALLMONITOR 
bda7 cd 7b 91			call break_point_state  
bdaa				endm  
# End of macro CALLMONITOR
bdaa					endif 
bdaa cd 15 97			call forth_push_numhl 
bdad			 
bdad				       NEXTW 
bdad c3 06 99			jp macro_next 
bdb0				endm 
# End of macro NEXTW
bdb0			 
bdb0			.LEN: 
bdb0				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
bdb0 4c				db WORD_SYS_CORE+56             
bdb1 e5 bd			dw .CHAR            
bdb3 06				db 5 + 1 
bdb4 .. 00			db "COUNT",0              
bdba				endm 
# End of macro CWHEAD
bdba			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
bdba			 
bdba					if DEBUG_FORTH_WORDS_KEY 
bdba						DMARK "CNT" 
bdba f5				push af  
bdbb 3a cf bd			ld a, (.dmark)  
bdbe 32 7a ee			ld (debug_mark),a  
bdc1 3a d0 bd			ld a, (.dmark+1)  
bdc4 32 7b ee			ld (debug_mark+1),a  
bdc7 3a d1 bd			ld a, (.dmark+2)  
bdca 32 7c ee			ld (debug_mark+2),a  
bdcd 18 03			jr .pastdmark  
bdcf ..			.dmark: db "CNT"  
bdd2 f1			.pastdmark: pop af  
bdd3			endm  
# End of macro DMARK
bdd3						CALLMONITOR 
bdd3 cd 7b 91			call break_point_state  
bdd6				endm  
# End of macro CALLMONITOR
bdd6					endif 
bdd6			; TODO check string type 
bdd6					FORTH_DSP 
bdd6 cd 95 97			call macro_forth_dsp 
bdd9				endm 
# End of macro FORTH_DSP
bdd9					;v5FORTH_DSP_VALUE 
bdd9			 
bdd9 23					inc hl 
bdda			 
bdda 3e 00				ld a, 0 
bddc cd 20 8e				call strlent 
bddf			 
bddf cd 15 97				call forth_push_numhl 
bde2			 
bde2			 
bde2			 
bde2				       NEXTW 
bde2 c3 06 99			jp macro_next 
bde5				endm 
# End of macro NEXTW
bde5			.CHAR: 
bde5				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
bde5 4d				db WORD_SYS_CORE+57             
bde6 1b be			dw .ENDSTR            
bde8 05				db 4 + 1 
bde9 .. 00			db "CHAR",0              
bdee				endm 
# End of macro CWHEAD
bdee			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
bdee					if DEBUG_FORTH_WORDS_KEY 
bdee						DMARK "CHR" 
bdee f5				push af  
bdef 3a 03 be			ld a, (.dmark)  
bdf2 32 7a ee			ld (debug_mark),a  
bdf5 3a 04 be			ld a, (.dmark+1)  
bdf8 32 7b ee			ld (debug_mark+1),a  
bdfb 3a 05 be			ld a, (.dmark+2)  
bdfe 32 7c ee			ld (debug_mark+2),a  
be01 18 03			jr .pastdmark  
be03 ..			.dmark: db "CHR"  
be06 f1			.pastdmark: pop af  
be07			endm  
# End of macro DMARK
be07						CALLMONITOR 
be07 cd 7b 91			call break_point_state  
be0a				endm  
# End of macro CALLMONITOR
be0a					endif 
be0a					FORTH_DSP 
be0a cd 95 97			call macro_forth_dsp 
be0d				endm 
# End of macro FORTH_DSP
be0d					;v5 FORTH_DSP_VALUE 
be0d 23					inc hl      ; now at start of numeric as string 
be0e			 
be0e			;		push hl 
be0e			 
be0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be0e cd 4c 98			call macro_forth_dsp_pop 
be11				endm 
# End of macro FORTH_DSP_POP
be11			 
be11			;		pop hl 
be11			 
be11					; push the content of a onto the stack as a value 
be11			 
be11 7e					ld a,(hl)   ; get char 
be12 26 00				ld h,0 
be14 6f					ld l,a 
be15 cd 15 97				call forth_push_numhl 
be18			 
be18				       NEXTW 
be18 c3 06 99			jp macro_next 
be1b				endm 
# End of macro NEXTW
be1b			 
be1b			 
be1b			 
be1b			 
be1b			.ENDSTR: 
be1b			; eof 
be1b			 
# End of file forth_words_str.asm
be1b			include "forth_words_key.asm" 
be1b			 
be1b			; | ## Keyboard Words 
be1b			 
be1b			.KEY: 
be1b				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
be1b 3e				db WORD_SYS_CORE+42             
be1c 4b be			dw .WAITK            
be1e 04				db 3 + 1 
be1f .. 00			db "KEY",0              
be23				endm 
# End of macro CWHEAD
be23			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
be23			 
be23					if DEBUG_FORTH_WORDS_KEY 
be23						DMARK "KEY" 
be23 f5				push af  
be24 3a 38 be			ld a, (.dmark)  
be27 32 7a ee			ld (debug_mark),a  
be2a 3a 39 be			ld a, (.dmark+1)  
be2d 32 7b ee			ld (debug_mark+1),a  
be30 3a 3a be			ld a, (.dmark+2)  
be33 32 7c ee			ld (debug_mark+2),a  
be36 18 03			jr .pastdmark  
be38 ..			.dmark: db "KEY"  
be3b f1			.pastdmark: pop af  
be3c			endm  
# End of macro DMARK
be3c						CALLMONITOR 
be3c cd 7b 91			call break_point_state  
be3f				endm  
# End of macro CALLMONITOR
be3f					endif 
be3f			; TODO currently waits 
be3f cd a5 d4				call cin 
be42					;call cin_wait 
be42 6f					ld l, a 
be43 26 00				ld h, 0 
be45 cd 15 97				call forth_push_numhl 
be48					NEXTW 
be48 c3 06 99			jp macro_next 
be4b				endm 
# End of macro NEXTW
be4b			.WAITK: 
be4b				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
be4b 3f				db WORD_SYS_CORE+43             
be4c 7d be			dw .ACCEPT            
be4e 06				db 5 + 1 
be4f .. 00			db "WAITK",0              
be55				endm 
# End of macro CWHEAD
be55			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
be55					if DEBUG_FORTH_WORDS_KEY 
be55						DMARK "WAI" 
be55 f5				push af  
be56 3a 6a be			ld a, (.dmark)  
be59 32 7a ee			ld (debug_mark),a  
be5c 3a 6b be			ld a, (.dmark+1)  
be5f 32 7b ee			ld (debug_mark+1),a  
be62 3a 6c be			ld a, (.dmark+2)  
be65 32 7c ee			ld (debug_mark+2),a  
be68 18 03			jr .pastdmark  
be6a ..			.dmark: db "WAI"  
be6d f1			.pastdmark: pop af  
be6e			endm  
# End of macro DMARK
be6e						CALLMONITOR 
be6e cd 7b 91			call break_point_state  
be71				endm  
# End of macro CALLMONITOR
be71					endif 
be71 cd 9f d4				call cin_wait 
be74 6f					ld l, a 
be75 26 00				ld h, 0 
be77 cd 15 97				call forth_push_numhl 
be7a					NEXTW 
be7a c3 06 99			jp macro_next 
be7d				endm 
# End of macro NEXTW
be7d			.ACCEPT: 
be7d				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
be7d 40				db WORD_SYS_CORE+44             
be7e db be			dw .EDIT            
be80 07				db 6 + 1 
be81 .. 00			db "ACCEPT",0              
be88				endm 
# End of macro CWHEAD
be88			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
be88					; TODO crashes on push 
be88					if DEBUG_FORTH_WORDS_KEY 
be88						DMARK "ACC" 
be88 f5				push af  
be89 3a 9d be			ld a, (.dmark)  
be8c 32 7a ee			ld (debug_mark),a  
be8f 3a 9e be			ld a, (.dmark+1)  
be92 32 7b ee			ld (debug_mark+1),a  
be95 3a 9f be			ld a, (.dmark+2)  
be98 32 7c ee			ld (debug_mark+2),a  
be9b 18 03			jr .pastdmark  
be9d ..			.dmark: db "ACC"  
bea0 f1			.pastdmark: pop af  
bea1			endm  
# End of macro DMARK
bea1						CALLMONITOR 
bea1 cd 7b 91			call break_point_state  
bea4				endm  
# End of macro CALLMONITOR
bea4					endif 
bea4 21 73 e5				ld hl, os_input 
bea7 3e 00				ld a, 0 
bea9 77					ld (hl),a 
beaa 3a 5e eb				ld a,(f_cursor_ptr) 
bead 16 64				ld d, 100 
beaf 0e 00				ld c, 0 
beb1 1e 28				ld e, 40 
beb3 cd e4 89				call input_str 
beb6					; TODO perhaps do a type check and wrap in quotes if not a number 
beb6 21 73 e5				ld hl, os_input 
beb9					if DEBUG_FORTH_WORDS 
beb9						DMARK "AC1" 
beb9 f5				push af  
beba 3a ce be			ld a, (.dmark)  
bebd 32 7a ee			ld (debug_mark),a  
bec0 3a cf be			ld a, (.dmark+1)  
bec3 32 7b ee			ld (debug_mark+1),a  
bec6 3a d0 be			ld a, (.dmark+2)  
bec9 32 7c ee			ld (debug_mark+2),a  
becc 18 03			jr .pastdmark  
bece ..			.dmark: db "AC1"  
bed1 f1			.pastdmark: pop af  
bed2			endm  
# End of macro DMARK
bed2						CALLMONITOR 
bed2 cd 7b 91			call break_point_state  
bed5				endm  
# End of macro CALLMONITOR
bed5					endif 
bed5 cd 27 97				call forth_push_str 
bed8					NEXTW 
bed8 c3 06 99			jp macro_next 
bedb				endm 
# End of macro NEXTW
bedb			 
bedb			.EDIT: 
bedb				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
bedb 40				db WORD_SYS_CORE+44             
bedc 64 bf			dw .ENDKEY            
bede 05				db 4 + 1 
bedf .. 00			db "EDIT",0              
bee4				endm 
# End of macro CWHEAD
bee4			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
bee4			 
bee4					; TODO does not copy from stack 
bee4					if DEBUG_FORTH_WORDS_KEY 
bee4						DMARK "EDT" 
bee4 f5				push af  
bee5 3a f9 be			ld a, (.dmark)  
bee8 32 7a ee			ld (debug_mark),a  
beeb 3a fa be			ld a, (.dmark+1)  
beee 32 7b ee			ld (debug_mark+1),a  
bef1 3a fb be			ld a, (.dmark+2)  
bef4 32 7c ee			ld (debug_mark+2),a  
bef7 18 03			jr .pastdmark  
bef9 ..			.dmark: db "EDT"  
befc f1			.pastdmark: pop af  
befd			endm  
# End of macro DMARK
befd						CALLMONITOR 
befd cd 7b 91			call break_point_state  
bf00				endm  
# End of macro CALLMONITOR
bf00					endif 
bf00			 
bf00					FORTH_DSP 
bf00 cd 95 97			call macro_forth_dsp 
bf03				endm 
# End of macro FORTH_DSP
bf03					;v5 FORTH_DSP_VALUE 
bf03 23					inc hl    ; TODO do type check 
bf04			 
bf04 e5					push hl 
bf05 3e 00				ld a, 0 
bf07 cd 20 8e				call strlent 
bf0a 23					inc hl 
bf0b			 
bf0b 06 00				ld b, 0 
bf0d 4d					ld c, l 
bf0e			 
bf0e e1					pop hl 
bf0f 11 73 e5				ld de, os_input 
bf12					if DEBUG_FORTH_WORDS_KEY 
bf12						DMARK "EDc" 
bf12 f5				push af  
bf13 3a 27 bf			ld a, (.dmark)  
bf16 32 7a ee			ld (debug_mark),a  
bf19 3a 28 bf			ld a, (.dmark+1)  
bf1c 32 7b ee			ld (debug_mark+1),a  
bf1f 3a 29 bf			ld a, (.dmark+2)  
bf22 32 7c ee			ld (debug_mark+2),a  
bf25 18 03			jr .pastdmark  
bf27 ..			.dmark: db "EDc"  
bf2a f1			.pastdmark: pop af  
bf2b			endm  
# End of macro DMARK
bf2b						CALLMONITOR 
bf2b cd 7b 91			call break_point_state  
bf2e				endm  
# End of macro CALLMONITOR
bf2e					endif 
bf2e ed b0				ldir 
bf30			 
bf30			 
bf30 21 73 e5				ld hl, os_input 
bf33					;ld a, 0 
bf33					;ld (hl),a 
bf33 3a 5e eb				ld a,(f_cursor_ptr) 
bf36 16 64				ld d, 100 
bf38 0e 00				ld c, 0 
bf3a 1e 28				ld e, 40 
bf3c cd e4 89				call input_str 
bf3f					; TODO perhaps do a type check and wrap in quotes if not a number 
bf3f 21 73 e5				ld hl, os_input 
bf42					if DEBUG_FORTH_WORDS 
bf42						DMARK "ED1" 
bf42 f5				push af  
bf43 3a 57 bf			ld a, (.dmark)  
bf46 32 7a ee			ld (debug_mark),a  
bf49 3a 58 bf			ld a, (.dmark+1)  
bf4c 32 7b ee			ld (debug_mark+1),a  
bf4f 3a 59 bf			ld a, (.dmark+2)  
bf52 32 7c ee			ld (debug_mark+2),a  
bf55 18 03			jr .pastdmark  
bf57 ..			.dmark: db "ED1"  
bf5a f1			.pastdmark: pop af  
bf5b			endm  
# End of macro DMARK
bf5b						CALLMONITOR 
bf5b cd 7b 91			call break_point_state  
bf5e				endm  
# End of macro CALLMONITOR
bf5e					endif 
bf5e cd 27 97				call forth_push_str 
bf61					NEXTW 
bf61 c3 06 99			jp macro_next 
bf64				endm 
# End of macro NEXTW
bf64			 
bf64			 
bf64			 
bf64			.ENDKEY: 
bf64			; eof 
bf64			 
# End of file forth_words_key.asm
bf64			 
bf64			if STORAGE_SE 
bf64			   	include "forth_words_storage.asm" 
bf64			endif 
bf64				include "forth_words_device.asm" 
bf64			; Device related words 
bf64			 
bf64			; | ## Device Words 
bf64			 
bf64			if SOUND_ENABLE 
bf64			.NOTE: 
bf64				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
bf64			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
bf64					if DEBUG_FORTH_WORDS_KEY 
bf64						DMARK "NTE" 
bf64						CALLMONITOR 
bf64					endif 
bf64			 
bf64				 
bf64			 
bf64					NEXTW 
bf64			.AFTERSOUND: 
bf64			endif 
bf64			 
bf64			 
bf64			USE_GPIO: equ 0 
bf64			 
bf64			if USE_GPIO 
bf64			.GP1: 
bf64				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
bf64			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
bf64					NEXTW 
bf64			.GP2: 
bf64				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
bf64			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
bf64			 
bf64					NEXTW 
bf64			 
bf64			.GP3: 
bf64				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
bf64			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
bf64			 
bf64					NEXTW 
bf64			 
bf64			.GP4: 
bf64				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
bf64			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
bf64			 
bf64					NEXTW 
bf64			.SIN: 
bf64			 
bf64			 
bf64			endif 
bf64			 
bf64			 
bf64				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
bf64 33				db WORD_SYS_CORE+31             
bf65 99 bf			dw .SOUT            
bf67 03				db 2 + 1 
bf68 .. 00			db "IN",0              
bf6b				endm 
# End of macro CWHEAD
bf6b			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
bf6b					if DEBUG_FORTH_WORDS_KEY 
bf6b						DMARK "IN." 
bf6b f5				push af  
bf6c 3a 80 bf			ld a, (.dmark)  
bf6f 32 7a ee			ld (debug_mark),a  
bf72 3a 81 bf			ld a, (.dmark+1)  
bf75 32 7b ee			ld (debug_mark+1),a  
bf78 3a 82 bf			ld a, (.dmark+2)  
bf7b 32 7c ee			ld (debug_mark+2),a  
bf7e 18 03			jr .pastdmark  
bf80 ..			.dmark: db "IN."  
bf83 f1			.pastdmark: pop af  
bf84			endm  
# End of macro DMARK
bf84						CALLMONITOR 
bf84 cd 7b 91			call break_point_state  
bf87				endm  
# End of macro CALLMONITOR
bf87					endif 
bf87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf87 cd b0 97			call macro_dsp_valuehl 
bf8a				endm 
# End of macro FORTH_DSP_VALUEHL
bf8a			 
bf8a e5					push hl 
bf8b			 
bf8b					; destroy value TOS 
bf8b			 
bf8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf8b cd 4c 98			call macro_forth_dsp_pop 
bf8e				endm 
# End of macro FORTH_DSP_POP
bf8e			 
bf8e					; one value on hl get other one back 
bf8e			 
bf8e c1					pop bc 
bf8f			 
bf8f					; do the sub 
bf8f			;		ex de, hl 
bf8f			 
bf8f ed 68				in l,(c) 
bf91			 
bf91					; save it 
bf91			 
bf91 26 00				ld h,0 
bf93			 
bf93					; TODO push value back onto stack for another op etc 
bf93			 
bf93 cd 15 97				call forth_push_numhl 
bf96					NEXTW 
bf96 c3 06 99			jp macro_next 
bf99				endm 
# End of macro NEXTW
bf99			.SOUT: 
bf99				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
bf99 34				db WORD_SYS_CORE+32             
bf9a ec bf			dw .SPIO            
bf9c 04				db 3 + 1 
bf9d .. 00			db "OUT",0              
bfa1				endm 
# End of macro CWHEAD
bfa1			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
bfa1					if DEBUG_FORTH_WORDS_KEY 
bfa1						DMARK "OUT" 
bfa1 f5				push af  
bfa2 3a b6 bf			ld a, (.dmark)  
bfa5 32 7a ee			ld (debug_mark),a  
bfa8 3a b7 bf			ld a, (.dmark+1)  
bfab 32 7b ee			ld (debug_mark+1),a  
bfae 3a b8 bf			ld a, (.dmark+2)  
bfb1 32 7c ee			ld (debug_mark+2),a  
bfb4 18 03			jr .pastdmark  
bfb6 ..			.dmark: db "OUT"  
bfb9 f1			.pastdmark: pop af  
bfba			endm  
# End of macro DMARK
bfba						CALLMONITOR 
bfba cd 7b 91			call break_point_state  
bfbd				endm  
# End of macro CALLMONITOR
bfbd					endif 
bfbd			 
bfbd					; get port 
bfbd			 
bfbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfbd cd b0 97			call macro_dsp_valuehl 
bfc0				endm 
# End of macro FORTH_DSP_VALUEHL
bfc0			 
bfc0 e5					push hl 
bfc1			 
bfc1					; destroy value TOS 
bfc1			 
bfc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfc1 cd 4c 98			call macro_forth_dsp_pop 
bfc4				endm 
# End of macro FORTH_DSP_POP
bfc4			 
bfc4					; get byte to send 
bfc4			 
bfc4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfc4 cd b0 97			call macro_dsp_valuehl 
bfc7				endm 
# End of macro FORTH_DSP_VALUEHL
bfc7			 
bfc7			;		push hl 
bfc7			 
bfc7					; destroy value TOS 
bfc7			 
bfc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfc7 cd 4c 98			call macro_forth_dsp_pop 
bfca				endm 
# End of macro FORTH_DSP_POP
bfca			 
bfca					; one value on hl get other one back 
bfca			 
bfca			;		pop hl 
bfca			 
bfca c1					pop bc 
bfcb			 
bfcb					if DEBUG_FORTH_WORDS 
bfcb						DMARK "OUT" 
bfcb f5				push af  
bfcc 3a e0 bf			ld a, (.dmark)  
bfcf 32 7a ee			ld (debug_mark),a  
bfd2 3a e1 bf			ld a, (.dmark+1)  
bfd5 32 7b ee			ld (debug_mark+1),a  
bfd8 3a e2 bf			ld a, (.dmark+2)  
bfdb 32 7c ee			ld (debug_mark+2),a  
bfde 18 03			jr .pastdmark  
bfe0 ..			.dmark: db "OUT"  
bfe3 f1			.pastdmark: pop af  
bfe4			endm  
# End of macro DMARK
bfe4						CALLMONITOR 
bfe4 cd 7b 91			call break_point_state  
bfe7				endm  
# End of macro CALLMONITOR
bfe7					endif 
bfe7			 
bfe7 ed 69				out (c), l 
bfe9			 
bfe9					NEXTW 
bfe9 c3 06 99			jp macro_next 
bfec				endm 
# End of macro NEXTW
bfec			 
bfec			 
bfec			.SPIO: 
bfec			 
bfec			if STORAGE_SE 
bfec				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
bfec			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
bfec			 
bfec					call spi_ce_low 
bfec			    NEXTW 
bfec			 
bfec			.SPICEH: 
bfec				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
bfec			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
bfec			 
bfec					call spi_ce_high 
bfec			    NEXTW 
bfec			 
bfec			 
bfec			.SPIOb: 
bfec			 
bfec				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
bfec			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
bfec			 
bfec					; get port 
bfec			 
bfec			 
bfec					; get byte to send 
bfec			 
bfec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfec			 
bfec			;		push hl    ; u1  
bfec			 
bfec					; destroy value TOS 
bfec			 
bfec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfec			 
bfec					; one value on hl get other one back 
bfec			 
bfec			;		pop hl   ; u2 - addr 
bfec			 
bfec					; TODO Send SPI byte 
bfec			 
bfec					ld a, l 
bfec					call spi_send_byte 
bfec			 
bfec					NEXTW 
bfec			 
bfec			.SPII: 
bfec				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
bfec			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
bfec			 
bfec					; TODO Get SPI byte 
bfec			 
bfec					call spi_read_byte 
bfec			 
bfec					ld h, 0 
bfec					ld l, a 
bfec					call forth_push_numhl 
bfec			 
bfec					NEXTW 
bfec			 
bfec			 
bfec			 
bfec			.SESEL: 
bfec				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
bfec			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
bfec					if DEBUG_FORTH_WORDS_KEY 
bfec						DMARK "BNK" 
bfec						CALLMONITOR 
bfec					endif 
bfec			 
bfec					ld a, 255 
bfec					ld (spi_cartdev), a 
bfec			 
bfec					; get bank 
bfec			 
bfec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfec			 
bfec			;		push hl 
bfec			 
bfec					; destroy value TOS 
bfec			 
bfec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfec			 
bfec					; one value on hl get other one back 
bfec			 
bfec			;		pop hl 
bfec			 
bfec			 
bfec					ld c, SPI_CE_HIGH 
bfec			 
bfec					ld a, l 
bfec			 
bfec					if DEBUG_FORTH_WORDS 
bfec						DMARK "BNK" 
bfec						CALLMONITOR 
bfec					endif 
bfec			 
bfec					; active low 
bfec			 
bfec					cp 0 
bfec					jr z, .bset 
bfec					cp 1 
bfec					jr nz, .b2 
bfec					res 0, c 
bfec			.b2:		cp 2 
bfec					jr nz, .b3 
bfec					res 1, c 
bfec			.b3:		cp 3 
bfec					jr nz, .b4 
bfec					res 2, c 
bfec			.b4:		cp 4 
bfec					jr nz, .b5 
bfec					res 3, c 
bfec			.b5:		cp 5 
bfec					jr nz, .bset 
bfec					res 4, c 
bfec			 
bfec			.bset: 
bfec					ld a, c 
bfec					ld (spi_device),a 
bfec					if DEBUG_FORTH_WORDS 
bfec						DMARK "BN2" 
bfec						CALLMONITOR 
bfec					endif 
bfec			 
bfec					NEXTW 
bfec			 
bfec			.CARTDEV: 
bfec				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
bfec			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
bfec					if DEBUG_FORTH_WORDS_KEY 
bfec						DMARK "CDV" 
bfec						CALLMONITOR 
bfec					endif 
bfec			 
bfec					; disable se storage bank selection 
bfec			 
bfec					ld a, SPI_CE_HIGH		; ce high 
bfec					ld (spi_device), a 
bfec			 
bfec					; get bank 
bfec			 
bfec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfec			 
bfec			;		push hl 
bfec			 
bfec					; destroy value TOS 
bfec			 
bfec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfec			 
bfec					; one value on hl get other one back 
bfec			 
bfec			;		pop hl 
bfec			 
bfec					; active low 
bfec			 
bfec					ld c, 255 
bfec			 
bfec					ld a, l 
bfec					if DEBUG_FORTH_WORDS 
bfec						DMARK "CDV" 
bfec						CALLMONITOR 
bfec					endif 
bfec					cp 0 
bfec					jr z, .cset 
bfec					cp 1 
bfec					jr nz, .c2 
bfec					res 0, c 
bfec			.c2:		cp 2 
bfec					jr nz, .c3 
bfec					res 1, c 
bfec			.c3:		cp 3 
bfec					jr nz, .c4 
bfec					res 2, c 
bfec			.c4:		cp 4 
bfec					jr nz, .c5 
bfec					res 3, c 
bfec			.c5:		cp 5 
bfec					jr nz, .c6 
bfec					res 4, c 
bfec			.c6:		cp 6 
bfec					jr nz, .c7 
bfec					res 5, c 
bfec			.c7:		cp 7 
bfec					jr nz, .c8 
bfec					res 6, c 
bfec			.c8:		cp 8 
bfec					jr nz, .cset 
bfec					res 7, c 
bfec			.cset:		ld a, c 
bfec					ld (spi_cartdev),a 
bfec			 
bfec					if DEBUG_FORTH_WORDS 
bfec						DMARK "CD2" 
bfec						CALLMONITOR 
bfec					endif 
bfec					NEXTW 
bfec			endif 
bfec			 
bfec			.ENDDEVICE: 
bfec			; eof 
bfec			 
# End of file forth_words_device.asm
bfec			 
bfec			; var handler 
bfec			 
bfec			 
bfec			.VARS: 
bfec				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
bfec 78				db WORD_SYS_CORE+100             
bfed 04 c0			dw .V0Q            
bfef 04				db 3 + 1 
bff0 .. 00			db "V0!",0              
bff4				endm 
# End of macro CWHEAD
bff4			;| V0! ( u1 -- )  Store value to v0  | DONE 
bff4			 
bff4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bff4 cd b0 97			call macro_dsp_valuehl 
bff7				endm 
# End of macro FORTH_DSP_VALUEHL
bff7			 
bff7 11 28 eb				ld de, cli_var_array 
bffa			 
bffa eb					ex de, hl 
bffb 73					ld (hl), e 
bffc 23					inc hl 
bffd 72					ld (hl), d 
bffe			 
bffe					; destroy value TOS 
bffe			 
bffe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bffe cd 4c 98			call macro_forth_dsp_pop 
c001				endm 
# End of macro FORTH_DSP_POP
c001			 
c001				       NEXTW 
c001 c3 06 99			jp macro_next 
c004				endm 
# End of macro NEXTW
c004			.V0Q: 
c004				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c004 79				db WORD_SYS_CORE+101             
c005 15 c0			dw .V1S            
c007 04				db 3 + 1 
c008 .. 00			db "V0@",0              
c00c				endm 
# End of macro CWHEAD
c00c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c00c 2a 28 eb				ld hl, (cli_var_array) 
c00f cd 15 97				call forth_push_numhl 
c012			 
c012				       NEXTW 
c012 c3 06 99			jp macro_next 
c015				endm 
# End of macro NEXTW
c015			.V1S: 
c015				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c015 7a				db WORD_SYS_CORE+102             
c016 2d c0			dw .V1Q            
c018 04				db 3 + 1 
c019 .. 00			db "V1!",0              
c01d				endm 
# End of macro CWHEAD
c01d			;| V1! ( u1 -- )  Store value to v1 | DONE 
c01d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c01d cd b0 97			call macro_dsp_valuehl 
c020				endm 
# End of macro FORTH_DSP_VALUEHL
c020			 
c020 11 2a eb				ld de, cli_var_array+2 
c023				 
c023 eb					ex de, hl 
c024 73					ld (hl), e 
c025 23					inc hl 
c026 72					ld (hl), d 
c027			 
c027					; destroy value TOS 
c027			 
c027					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c027 cd 4c 98			call macro_forth_dsp_pop 
c02a				endm 
# End of macro FORTH_DSP_POP
c02a				       NEXTW 
c02a c3 06 99			jp macro_next 
c02d				endm 
# End of macro NEXTW
c02d			.V1Q: 
c02d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c02d 7b				db WORD_SYS_CORE+103             
c02e 3e c0			dw .V2S            
c030 04				db 3 + 1 
c031 .. 00			db "V1@",0              
c035				endm 
# End of macro CWHEAD
c035			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c035 2a 2a eb				ld hl, (cli_var_array+2) 
c038 cd 15 97				call forth_push_numhl 
c03b				       NEXTW 
c03b c3 06 99			jp macro_next 
c03e				endm 
# End of macro NEXTW
c03e			.V2S: 
c03e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c03e 7c				db WORD_SYS_CORE+104             
c03f 56 c0			dw .V2Q            
c041 04				db 3 + 1 
c042 .. 00			db "V2!",0              
c046				endm 
# End of macro CWHEAD
c046			;| V2! ( u1 -- )  Store value to v2 | DONE 
c046					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c046 cd b0 97			call macro_dsp_valuehl 
c049				endm 
# End of macro FORTH_DSP_VALUEHL
c049			 
c049 11 2c eb				ld de, cli_var_array+4 
c04c				 
c04c eb					ex de, hl 
c04d 73					ld (hl), e 
c04e 23					inc hl 
c04f 72					ld (hl), d 
c050			 
c050					; destroy value TOS 
c050			 
c050					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c050 cd 4c 98			call macro_forth_dsp_pop 
c053				endm 
# End of macro FORTH_DSP_POP
c053				       NEXTW 
c053 c3 06 99			jp macro_next 
c056				endm 
# End of macro NEXTW
c056			.V2Q: 
c056				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c056 7d				db WORD_SYS_CORE+105             
c057 67 c0			dw .V3S            
c059 04				db 3 + 1 
c05a .. 00			db "V2@",0              
c05e				endm 
# End of macro CWHEAD
c05e			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c05e 2a 2c eb				ld hl, (cli_var_array+4) 
c061 cd 15 97				call forth_push_numhl 
c064				       NEXTW 
c064 c3 06 99			jp macro_next 
c067				endm 
# End of macro NEXTW
c067			.V3S: 
c067				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c067 7c				db WORD_SYS_CORE+104             
c068 7f c0			dw .V3Q            
c06a 04				db 3 + 1 
c06b .. 00			db "V3!",0              
c06f				endm 
# End of macro CWHEAD
c06f			;| V3! ( u1 -- )  Store value to v3 | DONE 
c06f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c06f cd b0 97			call macro_dsp_valuehl 
c072				endm 
# End of macro FORTH_DSP_VALUEHL
c072			 
c072 11 2e eb				ld de, cli_var_array+6 
c075				 
c075 eb					ex de, hl 
c076 73					ld (hl), e 
c077 23					inc hl 
c078 72					ld (hl), d 
c079			 
c079					; destroy value TOS 
c079			 
c079					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c079 cd 4c 98			call macro_forth_dsp_pop 
c07c				endm 
# End of macro FORTH_DSP_POP
c07c				       NEXTW 
c07c c3 06 99			jp macro_next 
c07f				endm 
# End of macro NEXTW
c07f			.V3Q: 
c07f				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c07f 7d				db WORD_SYS_CORE+105             
c080 90 c0			dw .END            
c082 04				db 3 + 1 
c083 .. 00			db "V3@",0              
c087				endm 
# End of macro CWHEAD
c087			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c087 2a 2e eb				ld hl, (cli_var_array+6) 
c08a cd 15 97				call forth_push_numhl 
c08d				       NEXTW 
c08d c3 06 99			jp macro_next 
c090				endm 
# End of macro NEXTW
c090			 
c090			 
c090			 
c090			 
c090			 
c090			; end of dict marker 
c090			 
c090 00			.END:    db WORD_SYS_END 
c091 00 00			dw 0 
c093 00				db 0 
c094			 
c094			; use to jp here for user dict words to save on macro expansion  
c094			 
c094			user_dict_next: 
c094				NEXTW 
c094 c3 06 99			jp macro_next 
c097				endm 
# End of macro NEXTW
c097			 
c097			 
c097			user_exec: 
c097				;    ld hl, <word code> 
c097				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c097				;    call forthexec 
c097				;    jp user_dict_next   (NEXT) 
c097			        ;    <word code bytes> 
c097 eb				ex de, hl 
c098 2a 76 e6			ld hl,(os_tok_ptr) 
c09b				 
c09b				FORTH_RSP_NEXT 
c09b cd bc 96			call macro_forth_rsp_next 
c09e				endm 
# End of macro FORTH_RSP_NEXT
c09e			 
c09e			if DEBUG_FORTH_UWORD 
c09e						DMARK "UEX" 
c09e f5				push af  
c09f 3a b3 c0			ld a, (.dmark)  
c0a2 32 7a ee			ld (debug_mark),a  
c0a5 3a b4 c0			ld a, (.dmark+1)  
c0a8 32 7b ee			ld (debug_mark+1),a  
c0ab 3a b5 c0			ld a, (.dmark+2)  
c0ae 32 7c ee			ld (debug_mark+2),a  
c0b1 18 03			jr .pastdmark  
c0b3 ..			.dmark: db "UEX"  
c0b6 f1			.pastdmark: pop af  
c0b7			endm  
# End of macro DMARK
c0b7				CALLMONITOR 
c0b7 cd 7b 91			call break_point_state  
c0ba				endm  
# End of macro CALLMONITOR
c0ba			endif 
c0ba			 
c0ba			 
c0ba			 
c0ba eb				ex de, hl 
c0bb 22 76 e6			ld (os_tok_ptr), hl 
c0be				 
c0be				; Don't use next - Skips the first word in uword. 
c0be			 
c0be c3 97 99			jp exec1 
c0c1			;	NEXT 
c0c1			 
c0c1			 
c0c1			; eof 
# End of file forth_wordsv4.asm
c0c1			endif 
c0c1			;;;;;;;;;;;;;; Debug code 
c0c1			 
c0c1			 
c0c1			;if DEBUG_FORTH_PARSE 
c0c1 .. 00		.nowordfound: db "No match",0 
c0ca .. 00		.compword:	db "Comparing word ",0 
c0da .. 00		.nextwordat:	db "Next word at",0 
c0e7 .. 00		.charmatch:	db "Char match",0 
c0f2			;endif 
c0f2			if DEBUG_FORTH_JP 
c0f2			.foundword:	db "Word match. Exec..",0 
c0f2			endif 
c0f2			;if DEBUG_FORTH_PUSH 
c0f2 .. 00		.enddict:	db "Dict end. Push.",0 
c102 .. 00		.push_str:	db "Pushing string",0 
c111 .. 00		.push_num:	db "Pushing number",0 
c120 .. 00		.data_sp:	db "SP:",0 
c124 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c136 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c148 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c15a			;endif 
c15a			;if DEBUG_FORTH_MALLOC 
c15a .. 00		.push_malloc:	db "Malloc address",0 
c169			;endif 
c169			 
c169			 
c169			 
c169			; display malloc address and current data stack pointer  
c169			 
c169			malloc_error: 
c169 d5				push de 
c16a f5				push af 
c16b e5				push hl 
c16c cd 5e 88			call clear_display 
c16f 11 91 c1			ld de, .mallocerr 
c172 3e 00			ld a,0 
c174			;	ld de,os_word_scratch 
c174 cd 71 88			call str_at_display 
c177 3e 11			ld a, display_row_1+17 
c179 11 7a ee			ld de, debug_mark 
c17c cd 71 88			call str_at_display 
c17f cd 81 88			call update_display 
c182				;call break_point_state 
c182 cd 9f d4			call cin_wait 
c185			 
c185 3e 20			ld a, ' ' 
c187 32 74 e3			ld (os_view_disable), a 
c18a e1				pop hl 
c18b f1				pop af 
c18c d1				pop de	 
c18d				CALLMONITOR 
c18d cd 7b 91			call break_point_state  
c190				endm  
# End of macro CALLMONITOR
c190 c9				ret 
c191			 
c191 .. 00		.mallocerr: 	db "Malloc Error",0 
c19e			;if DEBUG_FORTH_PUSH 
c19e			display_data_sp: 
c19e f5				push af 
c19f			 
c19f				; see if disabled 
c19f			 
c19f 3a 74 e3			ld a, (os_view_disable) 
c1a2 fe 2a			cp '*' 
c1a4 28 67			jr z, .skipdsp 
c1a6			 
c1a6 e5				push hl 
c1a7 e5				push hl 
c1a8 e5			push hl 
c1a9 cd 5e 88			call clear_display 
c1ac e1			pop hl 
c1ad 7c				ld a,h 
c1ae 21 7a e6			ld hl, os_word_scratch 
c1b1 cd b8 8c			call hexout 
c1b4 e1				pop hl 
c1b5 7d				ld a,l 
c1b6 21 7c e6			ld hl, os_word_scratch+2 
c1b9 cd b8 8c			call hexout 
c1bc 21 7e e6			ld hl, os_word_scratch+4 
c1bf 3e 00			ld a,0 
c1c1 77				ld (hl),a 
c1c2 11 7a e6			ld de,os_word_scratch 
c1c5 3e 28				ld a, display_row_2 
c1c7 cd 71 88				call str_at_display 
c1ca 11 24 c1			ld de, .wordinhl 
c1cd 3e 00			ld a, display_row_1 
c1cf			 
c1cf cd 71 88				call str_at_display 
c1d2 11 7a ee			ld de, debug_mark 
c1d5 3e 11			ld a, display_row_1+17 
c1d7			 
c1d7 cd 71 88				call str_at_display 
c1da			 
c1da				; display current data stack pointer 
c1da 11 20 c1			ld de,.data_sp 
c1dd 3e 30				ld a, display_row_2 + 8 
c1df cd 71 88				call str_at_display 
c1e2			 
c1e2 2a 22 eb			ld hl,(cli_data_sp) 
c1e5 e5				push hl 
c1e6 7c				ld a,h 
c1e7 21 7a e6			ld hl, os_word_scratch 
c1ea cd b8 8c			call hexout 
c1ed e1				pop hl 
c1ee 7d				ld a,l 
c1ef 21 7c e6			ld hl, os_word_scratch+2 
c1f2 cd b8 8c			call hexout 
c1f5 21 7e e6			ld hl, os_word_scratch+4 
c1f8 3e 00			ld a,0 
c1fa 77				ld (hl),a 
c1fb 11 7a e6			ld de,os_word_scratch 
c1fe 3e 33				ld a, display_row_2 + 11 
c200 cd 71 88				call str_at_display 
c203			 
c203			 
c203 cd 81 88			call update_display 
c206 cd e2 87			call delay1s 
c209 cd e2 87			call delay1s 
c20c e1				pop hl 
c20d			.skipdsp: 
c20d f1				pop af 
c20e c9				ret 
c20f			 
c20f			display_data_malloc: 
c20f			 
c20f f5				push af 
c210 e5				push hl 
c211 e5				push hl 
c212 e5			push hl 
c213 cd 5e 88			call clear_display 
c216 e1			pop hl 
c217 7c				ld a,h 
c218 21 7a e6			ld hl, os_word_scratch 
c21b cd b8 8c			call hexout 
c21e e1				pop hl 
c21f 7d				ld a,l 
c220 21 7c e6			ld hl, os_word_scratch+2 
c223 cd b8 8c			call hexout 
c226 21 7e e6			ld hl, os_word_scratch+4 
c229 3e 00			ld a,0 
c22b 77				ld (hl),a 
c22c 11 7a e6			ld de,os_word_scratch 
c22f 3e 28				ld a, display_row_2 
c231 cd 71 88				call str_at_display 
c234 11 5a c1			ld de, .push_malloc 
c237 3e 00			ld a, display_row_1 
c239			 
c239 cd 71 88				call str_at_display 
c23c			 
c23c				; display current data stack pointer 
c23c 11 20 c1			ld de,.data_sp 
c23f 3e 30				ld a, display_row_2 + 8 
c241 cd 71 88				call str_at_display 
c244			 
c244 2a 22 eb			ld hl,(cli_data_sp) 
c247 e5				push hl 
c248 7c				ld a,h 
c249 21 7a e6			ld hl, os_word_scratch 
c24c cd b8 8c			call hexout 
c24f e1				pop hl 
c250 7d				ld a,l 
c251 21 7c e6			ld hl, os_word_scratch+2 
c254 cd b8 8c			call hexout 
c257 21 7e e6			ld hl, os_word_scratch+4 
c25a 3e 00			ld a,0 
c25c 77				ld (hl),a 
c25d 11 7a e6			ld de,os_word_scratch 
c260 3e 33				ld a, display_row_2 + 11 
c262 cd 71 88				call str_at_display 
c265			 
c265 cd 81 88			call update_display 
c268 cd e2 87			call delay1s 
c26b cd e2 87			call delay1s 
c26e e1				pop hl 
c26f f1				pop af 
c270 c9				ret 
c271			;endif 
c271			 
c271			include "forth_autostart.asm" 
c271			; list of commands to perform at system start up 
c271			 
c271			startcmds: 
c271			;	dw test11 
c271			;	dw test12 
c271			;	dw test13 
c271			;	dw test14 
c271			;	dw test15 
c271			;	dw test16 
c271			;	dw test17 
c271			;	dw ifthtest1 
c271			;	dw ifthtest2 
c271			;	dw ifthtest3 
c271			;	dw mmtest1 
c271			;	dw mmtest2 
c271			;	dw mmtest3 
c271			;	dw mmtest4 
c271			;	dw mmtest5 
c271			;	dw mmtest6 
c271			;	dw iftest1 
c271			;	dw iftest2 
c271			;	dw iftest3 
c271			;	dw looptest1 
c271			;	dw looptest2 
c271			;	dw test1 
c271			;	dw test2 
c271			;	dw test3 
c271			;	dw test4 
c271			;	dw game2r 
c271			;	dw game2b1 
c271			;	dw game2b2 
c271			 
c271				; start up words that are actually useful 
c271			 
c271 cf c2			dw clrstack 
c273 02 c3			dw type 
c275 c3 c4			dw stest 
c277 26 c3			dw strncpy 
c279 64 c4			dw list 
c27b 87 c3			dw start1 
c27d 99 c3			dw start2 
c27f			;	dw start3 
c27f ac c3			dw start3b 
c281 04 c4			dw start3c 
c283			 
c283				; (unit) testing words 
c283			 
c283 3a c5			dw mtesta 
c285 ef c5			dw mtestb 
c287 92 c6			dw mtestc 
c289 47 c7			dw mtestd 
c28b eb c7			dw mteste 
c28d			 
c28d				; demo/game words 
c28d			 
c28d f7 ce		        dw game3w 
c28f 25 cf		        dw game3p 
c291 43 cf		        dw game3sc 
c293 74 cf		        dw game3vsi 
c295 a0 cf		        dw game3vs 
c297				 
c297 ea cc			dw game2b 
c299 58 cd			dw game2bf 
c29b a2 cd			dw game2mba 
c29d 38 ce			dw game2mbas 
c29f 7a ce			dw game2mb 
c2a1			 
c2a1 ab c9			dw game1 
c2a3 bc c9			dw game1a 
c2a5 1e ca			dw game1b 
c2a7 53 ca			dw game1c 
c2a9 89 ca			dw game1d 
c2ab ba ca			dw game1s 
c2ad ce ca			dw game1t 
c2af e3 ca			dw game1f 
c2b1 17 cb			dw game1z 
c2b3 5b cb			dw game1zz 
c2b5			 
c2b5 a1 c8			dw test5 
c2b7 d9 c8			dw test6 
c2b9 11 c9			dw test7 
c2bb 25 c9			dw test8 
c2bd 51 c9			dw test9 
c2bf 67 c9			dw test10 
c2c1				 
c2c1 32 cc		        dw ssv5 
c2c3 16 cc		        dw ssv4 
c2c5 fa cb		        dw ssv3 
c2c7 c4 cb		        dw ssv2 
c2c9 4b cc		        dw ssv1 
c2cb 93 cc		        dw ssv1cpm 
c2cd			;	dw keyup 
c2cd			;	dw keydown 
c2cd			;	dw keyleft 
c2cd			;	dw keyright 
c2cd			;	dw 	keyf1 
c2cd			;	dw keyf2 
c2cd			;	dw keyf3 
c2cd			;	dw keyf4 
c2cd			;	dw keyf5 
c2cd			;	dw keyf6 
c2cd			;	dw keyf7 
c2cd			;	dw keyf8 
c2cd			;	dw keyf9 
c2cd			;	dw keyf10 
c2cd			;	dw keyf11 
c2cd			;	dw keyf12 
c2cd			;	dw keytab 
c2cd			;	dw keycr 
c2cd			;	dw keyhome 
c2cd			;	dw keyend 
c2cd			;	dw keybs 
c2cd 00 00			db 0, 0	 
c2cf			 
c2cf			 
c2cf			; clear stack  
c2cf			 
c2cf .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c302			 
c302			; type ( addr count - ) 
c302 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c326			 
c326			; some direct memory words 
c326			; strncpy ( len t f -- t ) 
c326			 
c326 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c387			 
c387 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c399 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c3ac			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c3ac .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c404 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c464			 
c464			 
c464			; a handy word to list items on the stack 
c464			 
c464 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c4c3			 
c4c3			 
c4c3			; test stack  
c4c3			; rnd8 stest 
c4c3			 
c4c3 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c53a			 
c53a			; random malloc and free cycles 
c53a			 
c53a .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c5ef			 
c5ef			; fixed malloc and free cycles 
c5ef			 
c5ef .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c692			 
c692			; fixed double string push and drop cycle  
c692			 
c692 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
c747			 
c747			; consistent fixed string push and drop cycle  
c747			 
c747 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
c7eb			 
c7eb .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
c8a1			 
c8a1			;test1:		db ": aa 1 2 3 ;", 0 
c8a1			;test2:     	db "111 aa 888 999",0 
c8a1			;test3:     	db ": bb 77 ;",0 
c8a1			;test4:     	db "$02 $01 do i . loop bb",0 
c8a1			 
c8a1 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
c8d9 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
c911 .. 00		test7:     	db ": box hline vline ;",0 
c925 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
c951 .. 00		test9:     	db ": sw $01 adsp world ;",0 
c967 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
c98c .. 00		test11:     	db "hello create .",0 
c99b .. 00		test12:     	db "hello2 create .",0 
c9ab			 
c9ab			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
c9ab			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
c9ab			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
c9ab			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
c9ab			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
c9ab			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
c9ab			 
c9ab			;iftest1:     	db "$0001 IF cls .",0 
c9ab			;iftest2:     	db "$0000 IF cls .",0 
c9ab			;iftest3:     	db "$0002 $0003 - IF cls .",0 
c9ab			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
c9ab			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
c9ab			 
c9ab			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
c9ab			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
c9ab			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
c9ab			 
c9ab			 
c9ab			 
c9ab			; a small guess the number game 
c9ab			 
c9ab .. 00		game1:          db ": gsn rnd8 v1! ;",0 
c9bc .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
ca1e			 
ca1e .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
ca53 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
ca89 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
caba .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cace .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cae3 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cb17 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cb5b			 
cb5b			; Using 'ga' save a high score across multiple runs using external storage 
cb5b			 
cb5b .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cbc4			 
cbc4			 
cbc4			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cbc4			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cbc4			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cbc4			 
cbc4			; simple screen saver to test code memory reuse to destruction 
cbc4			 
cbc4 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cbfa .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cc16 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cc32 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cc4b .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cc93 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
ccea			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
ccea			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
ccea			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
ccea			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
ccea			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
ccea			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
ccea			 
ccea			 
ccea			 
ccea			; minesweeper/battleship finding game 
ccea			; draws a game board of random ship/mine positions 
ccea			; user enters coords to see if it hits on 
ccea			; game ends when all are hit 
ccea			; when hit or miss says how many may be in the area 
ccea			 
ccea			; setup the game board and then hide it 
ccea .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
cd58 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
cda2			; prompt for where to target 
cda2 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
ce38 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
ce5d			; TODO see if the entered coords hits or misses pushes char hit of miss 
ce5d .. 00		game2mbht:      db ": mbckht nop ;",0 
ce6c .. 00		game2mbms:      db ": mbcms nop ;",0 
ce7a			; TODO how many might be near by 
ce7a .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
cef7			 
cef7			; Game 3 
cef7			 
cef7			; Vert scroller ski game - avoid the trees! 
cef7			 
cef7			; v0 score (ie turns) 
cef7			; v1 player pos 
cef7			; v2 left wall 
cef7			; v3 right wall 
cef7			 
cef7			; Draw side walls randomly 
cef7			 
cef7 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
cf25			 
cf25			; Draw player 
cf25 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
cf43			 
cf43			; TODO Get Key 
cf43			 
cf43			; TODO Move left right 
cf43			 
cf43			; scroll and move walls a bit 
cf43			 
cf43 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
cf74			 
cf74			; main game loop 
cf74			 
cf74 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
cfa0 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
cfdf			 
cfdf			; key board defs 
cfdf			 
cfdf .. 00		keyup:       db ": keyup $05 ;",0 
cfed .. 00		keydown:       db ": keydown $0a ;",0 
cffd .. 00		keyleft:       db ": keyleft $0b ;",0 
d00d .. 00		keyright:       db ": keyright $0c ;",0 
d01e .. 00		keyf1:       db ": keyf1 $10 ;",0 
d02c .. 00		keyf2:       db ": keyf2 $11 ;",0 
d03a .. 00		keyf3:       db ": keyf3 $12 ;",0 
d048 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d056 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d064 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d072 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d080 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d08e .. 00		keyf9:       db ": keyf9 $18 ;",0 
d09c .. 00		keyf10:       db ": keyf10 $19 ;",0 
d0ab .. 00		keyf11:       db ": keyf11 $1a ;",0 
d0ba .. 00		keyf12:       db ": keyf12 $1b ;",0 
d0c9			 
d0c9 .. 00		keytab:       db ": keytab $09 ;",0 
d0d8 .. 00		keycr:       db ": keycr $0d ;",0 
d0e6 .. 00		keyhome:       db ": keyhome $0e ;",0 
d0f6 .. 00		keyend:       db ": keyend $0f ;",0 
d105 .. 00		keybs:       db ": keybs $08 ;",0 
d113			 
d113			   
d113			 
d113			 
d113			 
d113			; eof 
# End of file forth_autostart.asm
d113			 
d113 .. 00		sprompt1: db "Startup load...",0 
d123 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d139			 
d139			forth_startup: 
d139 21 71 c2			ld hl, startcmds 
d13c 3e 00			ld a, 0 
d13e 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d141			 
d141 e5			.start1:	push hl 
d142 cd 5e 88			call clear_display 
d145 11 13 d1			ld de, sprompt1 
d148 3e 00		        ld a, display_row_1 
d14a cd 71 88			call str_at_display 
d14d 11 23 d1			ld de, sprompt2 
d150 3e 28		        ld a, display_row_2 
d152 cd 71 88			call str_at_display 
d155 e1				pop hl 
d156 e5				push hl 
d157 5e				ld e,(hl) 
d158 23				inc hl 
d159 56				ld d,(hl) 
d15a 3e 50		        ld a, display_row_3 
d15c cd 71 88			call str_at_display 
d15f cd 81 88			call update_display 
d162			 
d162			 
d162 3a 9b e7			ld a, (os_last_cmd) 
d165 fe 00			cp 0 
d167 28 05			jr z, .startprompt 
d169 cd d6 87			call delay250ms 
d16c 18 24			jr .startdo 
d16e				 
d16e				 
d16e			 
d16e			.startprompt: 
d16e			 
d16e 3e 9f			ld a,display_row_4 + display_cols - 1 
d170 11 8b 96		        ld de, endprg 
d173 cd 71 88			call str_at_display 
d176 cd 81 88			call update_display 
d179 cd e2 87			call delay1s 
d17c cd 9f d4			call cin_wait 
d17f						 
d17f fe 2a			cp '*' 
d181 28 5e			jr z, .startupend1 
d183 fe 23			cp '#' 
d185 20 07			jr nz, .startno 
d187 3e 01			ld a, 1 
d189 32 9b e7			ld (os_last_cmd),a 
d18c 18 04			jr .startdo 
d18e fe 31		.startno:	cp '1' 
d190 28 3a			jr z,.startnxt  
d192			 
d192				; exec startup line 
d192			.startdo:	 
d192 e1				pop hl 
d193 e5				push hl 
d194				 
d194 5e				ld e,(hl) 
d195 23				inc hl 
d196 56				ld d,(hl) 
d197 eb				ex de,hl 
d198			 
d198 e5				push hl 
d199			 
d199 3e 00			ld a, 0 
d19b				;ld a, FORTH_END_BUFFER 
d19b cd 20 8e			call strlent 
d19e 23				inc hl   ; include zero term to copy 
d19f 06 00			ld b,0 
d1a1 4d				ld c,l 
d1a2 e1				pop hl 
d1a3 11 75 e3			ld de, scratch 
d1a6 ed b0			ldir 
d1a8			 
d1a8			 
d1a8 21 75 e3			ld hl, scratch 
d1ab cd 54 99			call forthparse 
d1ae cd 94 99			call forthexec 
d1b1 cd ab 98			call forthexec_cleanup 
d1b4			 
d1b4 3e 78			ld a, display_row_4 
d1b6 11 2f 94			ld de, endprog 
d1b9			 
d1b9 cd 81 88			call update_display		 
d1bc			 
d1bc 3a 9b e7			ld a, (os_last_cmd) 
d1bf fe 00			cp 0 
d1c1 20 09			jr nz, .startnxt 
d1c3 cd 8d 96			call next_page_prompt 
d1c6 cd 5e 88		        call clear_display 
d1c9 cd 81 88			call update_display		 
d1cc			 
d1cc				; move onto next startup line? 
d1cc			.startnxt: 
d1cc			 
d1cc cd d6 87			call delay250ms 
d1cf e1				pop hl 
d1d0			 
d1d0 23				inc hl 
d1d1 23				inc hl 
d1d2			 
d1d2 e5				push hl 
d1d3 5e				ld e, (hl) 
d1d4 23				inc hl 
d1d5 56				ld d, (hl) 
d1d6 e1				pop hl 
d1d7				; TODO replace 0 test 
d1d7			 
d1d7 eb				ex de, hl 
d1d8 cd e0 89			call ishlzero 
d1db			;	ld a,e 
d1db			;	add d 
d1db			;	cp 0    ; any left to do? 
d1db eb				ex de, hl 
d1dc c2 41 d1			jp nz, .start1 
d1df 18 01			jr .startupend 
d1e1			 
d1e1 e1			.startupend1: pop hl 
d1e2			.startupend: 
d1e2			 
d1e2 cd 5e 88			call clear_display 
d1e5 cd 81 88			call update_display 
d1e8 c9				ret 
d1e9			 
d1e9			 
d1e9			; stack over and underflow checks 
d1e9			 
d1e9			; init the words to detect the under/overflow 
d1e9			 
d1e9			chk_stk_init: 
d1e9				; a vague random number to check so we dont get any "lucky" hits 
d1e9 3e 2d			ld a, 45 
d1eb 6f				ld l, a 
d1ec 00				nop 
d1ed 3e 17			ld a, 23 
d1ef 67				ld h, a 
d1f0			 
d1f0 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
d1f3			 
d1f3			;	ld (chk_stund), hl	; stack points.... 
d1f3 22 00 ef			ld (chk_stovr), hl 
d1f6 22 20 eb			ld (chk_ret_und), hl 
d1f9 22 de ea			ld (chk_ret_ovr), hl 
d1fc 22 dc e9			ld (chk_loop_ovr), hl 
d1ff 22 da e8			ld (chk_data_ovr), hl 
d202 c9				ret 
d203				 
d203			check_stacks: 
d203				; check all stack words 
d203			 
d203 e5				push hl 
d204 d5				push de 
d205			 
d205			;	ld de,(chk_word) 
d205			;	ld hl, (chk_stund)	; stack points.... 
d205			;	if DEBUG_STK_FAULT 
d205			;		DMARK "FAa" 
d205			;		CALLMONITOR 
d205			;	endif 
d205			;	call cmp16 
d205			;	jp z, .chk_faulta 
d205			; 
d205			;	ld de, sfaultsu 
d205			;	jp .chk_fault 
d205			 
d205 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d208 ed 5b 6a e3		ld de,(chk_word) 
d20c				if DEBUG_STK_FAULT 
d20c					DMARK "FAb" 
d20c					CALLMONITOR 
d20c				endif 
d20c cd d5 89			call cmp16 
d20f 28 06			jr z, .chk_fault1 
d211 11 b2 d2			ld de, sfaultso 
d214 c3 66 d2			jp .chk_fault 
d217			.chk_fault1:  
d217 2a 20 eb			ld hl, (chk_ret_und) 
d21a ed 5b 6a e3		ld de,(chk_word) 
d21e				if DEBUG_STK_FAULT 
d21e					DMARK "FAU" 
d21e					CALLMONITOR 
d21e				endif 
d21e cd d5 89			call cmp16 
d221 ca 2a d2			jp z, .chk_fault2 
d224 11 c2 d2			ld de, sfaultru 
d227 c3 66 d2			jp .chk_fault 
d22a			.chk_fault2:  
d22a 2a de ea			ld hl, (chk_ret_ovr) 
d22d ed 5b 6a e3		ld de,(chk_word) 
d231				if DEBUG_STK_FAULT 
d231					DMARK "FA1" 
d231					CALLMONITOR 
d231				endif 
d231 cd d5 89			call cmp16 
d234 ca 3d d2			jp z, .chk_fault3 
d237 11 d0 d2			ld de, sfaultro 
d23a c3 66 d2			jp .chk_fault 
d23d			.chk_fault3:  
d23d 2a dc e9			ld hl, (chk_loop_ovr) 
d240 ed 5b 6a e3		ld de,(chk_word) 
d244				if DEBUG_STK_FAULT 
d244					DMARK "FA2" 
d244					CALLMONITOR 
d244				endif 
d244 cd d5 89			call cmp16 
d247 ca 50 d2			jp z, .chk_fault4 
d24a 11 ea d2			ld de, sfaultlo 
d24d c3 66 d2			jp .chk_fault 
d250			.chk_fault4:  
d250 2a da e8			ld hl, (chk_data_ovr) 
d253 ed 5b 6a e3		ld de,(chk_word) 
d257				if DEBUG_STK_FAULT 
d257					DMARK "FA3" 
d257					CALLMONITOR 
d257				endif 
d257 cd d5 89			call cmp16 
d25a ca 63 d2			jp z, .chk_fault5 
d25d 11 04 d3			ld de, sfaultdo 
d260 c3 66 d2			jp .chk_fault 
d263			 
d263			 
d263			.chk_fault5:  
d263 d1				pop de 
d264 e1				pop hl 
d265			 
d265 c9				ret 
d266			 
d266 cd 5e 88		.chk_fault: 	call clear_display 
d269 3e 28				ld a, display_row_2 
d26b cd 71 88				call str_at_display 
d26e 11 94 d2				   ld de, .stackfault 
d271 3e 00				ld a, display_row_1 
d273 cd 71 88				call str_at_display 
d276 11 7a ee				    ld de, debug_mark 
d279 3e 11				ld a, display_row_1+17 
d27b cd 71 88				call str_at_display 
d27e cd 81 88				call update_display 
d281			 
d281				; prompt before entering montior for investigating issue 
d281			 
d281 3e 78			ld a, display_row_4 
d283 11 2f 94			ld de, endprog 
d286			 
d286 cd 81 88			call update_display		 
d289			 
d289 cd 8d 96			call next_page_prompt 
d28c			 
d28c d1				pop de 
d28d e1				pop hl 
d28e cd 83 94				call monitor 
d291 c3 70 93				jp warmstart 
d294					;jp 0 
d294					;halt 
d294			 
d294			 
d294			 
d294 .. 00		.stackfault: 	db "Stack fault:",0 
d2a1			 
d2a1 .. 00		sfaultsu: 	db	"Stack under flow",0 
d2b2 .. 00		sfaultso: 	db	"Stack over flow",0 
d2c2 .. 00		sfaultru:	db "RTS underflow",0 
d2d0 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d2ea .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d304 .. 00		sfaultdo:	db "DTS overflow", 0 
d311			 
d311			 
d311			fault_dsp_under: 
d311 11 23 d3			ld de, .dsp_under 
d314 c3 d3 d3			jp .show_fault 
d317			 
d317			fault_rsp_under: 
d317 11 31 d3			ld de, .rsp_under 
d31a c3 d3 d3			jp .show_fault 
d31d			fault_loop_under: 
d31d 11 3f d3			ld de, .loop_under 
d320 c3 d3 d3			jp .show_fault 
d323			 
d323 .. 00		.dsp_under: db "DSP Underflow",0 
d331 .. 00		.rsp_under: db "RSP Underflow",0 
d33f .. 00		.loop_under: db "LOOP Underflow",0 
d34e			 
d34e			 
d34e d5			type_faultn: 	push de 
d34f e5					push hl 
d350 cd 5e 88				call clear_display 
d353 11 7a d3				   ld de, .typefaultn 
d356 3e 00				ld a, display_row_1 
d358 cd 71 88				call str_at_display 
d35b 11 7a ee				    ld de, debug_mark 
d35e 3e 11				ld a, display_row_1+17 
d360 cd 71 88				call str_at_display 
d363 cd 81 88				call update_display 
d366			 
d366				; prompt before entering montior for investigating issue 
d366			 
d366 3e 78			ld a, display_row_4 
d368 11 2f 94			ld de, endprog 
d36b			 
d36b cd 81 88			call update_display		 
d36e			 
d36e cd 8d 96			call next_page_prompt 
d371			 
d371 e5					push hl 
d372 d5					push de 
d373 cd 83 94				call monitor 
d376 c3 70 93				jp warmstart 
d379 76					halt 
d37a			 
d37a			 
d37a .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d391			 
d391 d5			type_faults: 	push de 
d392 e5					push hl 
d393 cd 5e 88				call clear_display 
d396 11 bc d3				   ld de, .typefaults 
d399 3e 00				ld a, display_row_1 
d39b cd 71 88				call str_at_display 
d39e 11 7a ee				    ld de, debug_mark 
d3a1 3e 11				ld a, display_row_1+17 
d3a3 cd 71 88				call str_at_display 
d3a6 cd 81 88				call update_display 
d3a9			 
d3a9				; prompt before entering montior for investigating issue 
d3a9			 
d3a9 3e 78			ld a, display_row_4 
d3ab 11 2f 94			ld de, endprog 
d3ae			 
d3ae cd 81 88			call update_display		 
d3b1			 
d3b1 cd 8d 96			call next_page_prompt 
d3b4			 
d3b4 e1					pop hl 
d3b5 d1					pop de 
d3b6 cd 83 94				call monitor 
d3b9 c3 70 93				jp warmstart 
d3bc			 
d3bc			 
d3bc .. 00		.typefaults: db "STR Type Expected TOS!",0 
d3d3			 
d3d3			.show_fault: 	 
d3d3 d5					push de 
d3d4 cd 5e 88				call clear_display 
d3d7 d1					pop de 
d3d8 3e 00				ld a, display_row_1 
d3da cd 71 88				call str_at_display 
d3dd 11 7a ee				    ld de, debug_mark 
d3e0 3e 11				ld a, display_row_1+17 
d3e2 cd 71 88				call str_at_display 
d3e5 cd 81 88				call update_display 
d3e8			 
d3e8				; prompt before entering montior for investigating issue 
d3e8			 
d3e8 3e 78			ld a, display_row_4 
d3ea 11 2f 94			ld de, endprog 
d3ed			 
d3ed cd 81 88			call update_display		 
d3f0			 
d3f0 cd 8d 96			call next_page_prompt 
d3f3			 
d3f3 e1					pop hl 
d3f4 d1					pop de 
d3f5 cd 83 94				call monitor 
d3f8			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d3f8			; TODO Make optional fault restart to cli or warm boot? 
d3f8					;jp warmstart 
d3f8 c3 c8 93				jp cli 
d3fb 76					halt 
d3fc			; eof 
# End of file forth_kernel.asm
d3fc			;include "nascombasic.asm" 
d3fc			 
d3fc			 
d3fc			; find out where the code ends if loaded into RAM (for SC114) 
d3fc			;endofcode:  
d3fc			;	nop 
d3fc			 
d3fc			 
d3fc			; eof 
d3fc			 
# End of file main.asm
d3fc			;include "firmware_lcd_4x40.asm" 
d3fc			;;include "firmware_lcd_4x20.asm" 
d3fc			include "firmware_serial_display.asm" 
d3fc			 
d3fc			; Serial display interface for SC114 
d3fc			 
d3fc			 
d3fc			display_row_1: equ 0 
d3fc			display_row_2: equ display_row_1+display_cols 
d3fc			display_row_3: equ display_row_2 + display_cols 
d3fc			display_row_4: equ display_row_3 + display_cols 
d3fc			 
d3fc			kLCDWidth:  EQU display_cols             ;Width in characters 
d3fc			kLCD_Line1: EQU 0x00  
d3fc			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d3fc			; E1 
d3fc			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d3fc			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d3fc			 
d3fc			lcd_init: 
d3fc				; no init as handled by the SCM bios 
d3fc c9				ret 
d3fd			 
d3fd			 
d3fd			; low level functions for direct screen writes 
d3fd			 
d3fd			; output char at pos? 
d3fd			fLCD_Str: 
d3fd			        ;out (SC114_SIO_1_OUT),a 
d3fd c5				push bc 
d3fe 0e 02			ld c, $02 
d400 f7				rst $30 
d401 c1				pop bc 
d402 c9				ret 
d403			 
d403			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d403			fLCD_Pos: 
d403				; use ASCII escape to position 
d403			        ;out (SC114_SIO_1_OUT),a 
d403 c5				push bc 
d404 0e 02			ld c, $02 
d406 f7				rst $30 
d407 c1				pop bc 
d408			 
d408 c9				ret 
d409			 
d409			; output char at pos 
d409			fLCD_Data: 
d409			      ;  out (SC114_SIO_1_OUT),a 
d409 c5				push bc 
d40a 0e 02			ld c, $02 
d40c f7				rst $30 
d40d c1				pop bc 
d40e			 
d40e c9				ret 
d40f			 
d40f			; ascii cls  
d40f			 
d40f 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d413			 
d413			; write the frame buffer given in hl to hardware  
d413			write_display: 
d413			 
d413			API: equ 0 
d413			 
d413			if API 
d413				push bc 
d413				ld b, 4 
d413			 
d413			        ld (display_write_tmp), hl 	  
d413			 
d413				; clear and home cursor 
d413			 
d413				ld c, 6 
d413				ld de, .cls 
d413				rst $30 
d413			 
d413			 
d413			.writeln: 
d413			 
d413				ld de, (display_write_tmp) 
d413				ld c, 6 
d413				rst $30 
d413				ld c, 7 
d413				rst $30 
d413			 
d413				ld hl, (display_write_tmp) 
d413				ld de, display_cols 
d413				add hl,de 
d413				ld (display_write_tmp),hl 
d413			 
d413				djnz  .writeln 
d413			 
d413				pop bc 
d413			 
d413			 
d413				ret 
d413			endif 
d413 e5				push hl 
d414 c5				push bc 
d415 d5				push de 
d416			 
d416			;	ld c, 2 
d416			;	;ld de, .cls 
d416			;	ld a, 27 
d416			;	rst $30 
d416			;	ld c, 2 
d416			;	;ld de, .cls 
d416			;	ld a, '[' 
d416			;	rst $30 
d416			; 
d416			;	ld c, 2 
d416			;	;ld de, .cls 
d416			;	ld a, 'H' 
d416			;	rst $30 
d416			; 
d416			 
d416 0e 02			ld c, 2 
d418				;ld de, .cls 
d418 3e 1b			ld a, 27 
d41a f7				rst $30 
d41b			 
d41b			 
d41b 0e 02			ld c, 2 
d41d				;ld de, .cls 
d41d 3e 5b			ld a, '[' 
d41f f7				rst $30 
d420 0e 02			ld c, 2 
d422				;ld de, .cls 
d422 3e 32			ld a, '2' 
d424 f7				rst $30 
d425 0e 02			ld c, 2 
d427				;ld de, .cls 
d427 3e 4a			ld a, 'J' 
d429 f7				rst $30 
d42a d1				pop de 
d42b c1				pop bc 
d42c e1				pop hl 
d42d			 
d42d			 
d42d 22 d8 eb		        ld (display_write_tmp), hl 	  
d430 3e 00			ld a, kLCD_Line1 
d432			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d432 06 28			ld b, display_cols 
d434 ed 5b d8 eb		ld de, (display_write_tmp) 
d438 cd 96 d4			call write_len_string 
d43b				 
d43b			 
d43b e5			push hl 
d43c d5			push de 
d43d c5			push bc 
d43e 0e 07			ld c, 7 
d440 f7				rst $30 
d441 c1			pop bc 
d442 d1			pop de 
d443 e1			pop hl 
d444			 
d444				 
d444 2a d8 eb			ld hl, (display_write_tmp) 
d447 11 28 00			ld de, display_cols 
d44a 19				add hl,de 
d44b 22 d8 eb			ld (display_write_tmp),hl 
d44e			 
d44e				 
d44e 3e 28			ld a, kLCD_Line2 
d450			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d450 06 28			ld b, display_cols 
d452 ed 5b d8 eb		ld de, (display_write_tmp) 
d456 cd 96 d4			call write_len_string 
d459				 
d459 2a d8 eb			ld hl, (display_write_tmp) 
d45c 11 28 00			ld de, display_cols 
d45f 19				add hl,de 
d460 22 d8 eb			ld (display_write_tmp),hl 
d463			 
d463 e5			push hl 
d464 d5			push de 
d465 c5			push bc 
d466 0e 07			ld c, 7 
d468 f7				rst $30 
d469 c1			pop bc 
d46a d1			pop de 
d46b e1			pop hl 
d46c			 
d46c				 
d46c 3e 50			ld a, kLCD_Line3 
d46e			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d46e 06 28			ld b, display_cols 
d470 ed 5b d8 eb		ld de, (display_write_tmp) 
d474 cd 96 d4			call write_len_string 
d477				 
d477 2a d8 eb			ld hl, (display_write_tmp) 
d47a 11 28 00			ld de, display_cols 
d47d 19				add hl,de 
d47e 22 d8 eb			ld (display_write_tmp),hl 
d481			 
d481 e5			push hl 
d482 d5			push de 
d483 c5			push bc 
d484 0e 07			ld c, 7 
d486 f7				rst $30 
d487 c1			pop bc 
d488 d1			pop de 
d489 e1			pop hl 
d48a			 
d48a				 
d48a 3e 78			ld a, kLCD_Line4 
d48c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d48c 06 28			ld b, display_cols 
d48e ed 5b d8 eb		ld de, (display_write_tmp) 
d492 cd 96 d4			call write_len_string 
d495 c9					ret 
d496			 
d496			 
d496				; write out a fixed length string given in b from de 
d496			 
d496 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d497 cd 09 d4		            CALL fLCD_Data      ;Write character to display 
d49a 13				inc de 
d49b 10 f9			djnz write_len_string 
d49d c9				ret 
d49e			 
d49e			 
d49e			; eof 
# End of file firmware_serial_display.asm
d49e			;include "firmware_key_5x10.asm" 
d49e			;;include "firmware_key_4x10.asm" 
d49e			include "firmware_key_serial.asm" 
d49e			; Serial keyboard interface for SC114 
d49e			 
d49e			key_init: 
d49e				; no init as handled by the SCM bios 
d49e c9				ret 
d49f			 
d49f			 
d49f			cin_wait: 
d49f			;	ld a, 0 
d49f			;	ret 
d49f			 
d49f				;in a,(SC114_SIO_1_IN) 
d49f			        ; Use SCM API to get from whatever console device we are using 
d49f c5				push bc 
d4a0 0e 01			ld c, $01 
d4a2 f7				rst $30 
d4a3 c1				pop bc 
d4a4 c9				ret 
d4a5			 
d4a5			cin: 
d4a5			 
d4a5			 
d4a5 c5				push bc 
d4a6			 
d4a6				; any key waiting to process? 
d4a6 0e 03			ld c, $03 
d4a8 f7				rst $30 
d4a9 28 05			jr z, .cin_skip 
d4ab			 
d4ab				; yep, get it 
d4ab			 
d4ab 0e 01			ld c, $01 
d4ad f7				rst $30 
d4ae c1				pop bc 
d4af c9				ret 
d4b0			.cin_skip: 
d4b0 3e 00			ld a, 0 
d4b2 c1				pop bc 
d4b3 c9				ret 
d4b4			 
d4b4			 
d4b4			 
d4b4			 
# End of file firmware_key_serial.asm
d4b4			endofcode:  
d4b4			baseram:  
d4b4 00				nop 
d4b5			 
d4b5			heap_start: equ baseram+15  ; Starting address of heap 
d4b5			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d4b5			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d4b5			;VDU:  EQU     endofcode           ; BASIC Work space 
d4b5			; eof 
d4b5			 
# End of file os_mega_sc114.asm
d4b5
