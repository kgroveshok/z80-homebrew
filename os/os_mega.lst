# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 40 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 offsets for settings  
0003			  
0003			; if set then skip prompt for start up and accept all  
0003			  
0003			STORE_0_QUICKSTART: equ $25  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0003			  
0003			hardware_config: equ key_face_held - 10  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_config - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003				  
0003			  
0003					;ld a, 0  
0003					;ld (hardware_diag), a  
0003			  
0003					; clear all the buffers  
0003			  
0003 21 13 fa				ld hl, display_fb1  
0006 22 cf f8				ld (display_fb_active), hl  
0009			  
0009 cd e7 0a				call clear_display  
000c			  
000c 21 d1 f8				ld hl, display_fb2  
000f 22 cf f8				ld (display_fb_active), hl  
0012			  
0012 cd e7 0a				call clear_display  
0015			  
0015					; init primary frame buffer area  
0015 21 b4 fa				ld hl, display_fb0  
0018 22 cf f8				ld (display_fb_active), hl  
001b			  
001b cd e7 0a				call clear_display  
001e			  
001e			  
001e cd e0 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0021			  
0021 cd 77 68			call key_init  
0024 cd c7 01			call storage_init  
0027			  
0027				; setup malloc functions  
0027			  
0027				if MALLOC_1  
0027 cd be 11				call  heap_init  
002a				endif  
002a				if MALLOC_4  
002a					call  heap_init  
002a				endif  
002a			  
002a				; init sound hardware if present  
002a			  
002a				if SOUND_ENABLE  
002a cd 7b 13				call sound_init  
002d				endif  
002d			  
002d				; lcd test sequence  
002d					  
002d cd 0a 0b			call update_display  
0030 cd 64 0a			call delay1s  
0033 3e 2b			ld a,'+'  
0035 cd ec 0a			call fill_display  
0038 cd 0a 0b			call update_display  
003b cd 64 0a			call delay1s  
003e 3e 2a			ld a,'*'  
0040 cd ec 0a			call fill_display  
0043 cd 0a 0b			call update_display  
0046 cd 64 0a			call delay1s  
0049 3e 2d			ld a,'-'  
004b cd ec 0a			call fill_display  
004e cd 0a 0b			call update_display  
0051 cd 64 0a			call delay1s  
0054			  
0054			; boot splash screen  
0054			if display_cols == 20	  
0054			        ld a, display_row_1    
0054			else  
0054 3e 0a		        ld a, display_row_1 +10   
0056			endif  
0056 11 87 00			ld de, bootmsg  
0059 cd fa 0a			call str_at_display  
005c cd 0a 0b			call update_display  
005f			  
005f			  
005f cd 64 0a			call delay1s  
0062 cd 64 0a			call delay1s  
0065			if display_cols == 20	  
0065			            LD   A, display_row_3+2  
0065			else  
0065 3e 5c		            LD   A, display_row_3+12  
0067			endif  
0067 11 9c 00			ld de, bootmsg1  
006a cd fa 0a			call str_at_display  
006d cd 0a 0b			call update_display  
0070 cd 64 0a			call delay1s  
0073 cd 64 0a			call delay1s  
0076			  
0076			;	ld a, display_row_4+3  
0076			;	ld de, bootmsg2  
0076			;	call str_at_display  
0076			;	call update_display  
0076			;	call delay1s  
0076			;	call delay1s  
0076			  
0076			; debug mark setup  
0076			  
0076 3e 5f		ld a, '_'  
0078 32 6e fb		ld (debug_mark),a  
007b 32 6f fb		ld (debug_mark+1),a  
007e 32 70 fb		ld (debug_mark+2),a  
0081 3e 00		ld a,0  
0083 32 71 fb		ld (debug_mark+3),a  
0086			  
0086 c9					ret  
0087			  
0087			  
0087 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009c .. 00		bootmsg1:	db "by Kevin Groves",0  
00ac			;bootmsg2:	db "Firmware v0.1",0  
00ac			  
00ac			; a 4x20 lcd  
00ac			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ac			  
00ac			;if display_cols == 20  
00ac			;	include "firmware_lcd_4x20.asm"  
00ac			;endif  
00ac			  
00ac			;if display_cols == 40  
00ac			;	include "firmware_lcd_4x40.asm"  
00ac			;endif  
00ac			  
00ac			;  
00ac			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ac			; TODO abstract the bit bang video out interface for dual display  
00ac			; TODO wire video out to tx pin on rc2014 bus  
00ac			  
00ac			; must supply cin, and cin_wait for low level hardware abstraction   
00ac			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ac			; test scancode  
00ac			  
00ac			;;;;;  
00ac			;;;  
00ac			; Moved out to mini and maxi versions  
00ac			;  
00ac			; include "firmware_key_4x4.asm"  
00ac			; using existing 4 wire x 4 resistor array for input  
00ac			;include "firmware_key_4x10.asm"  
00ac			; need to mod the board for 5 rows due to resistor array  
00ac			;include "firmware_key_5x10.asm"  
00ac			  
00ac			; storage hardware interface  
00ac			  
00ac			; use microchip serial eeprom for storage  
00ac			  
00ac			  
00ac			if STORAGE_SE  
00ac				include "firmware_spi.asm"  
00ac			; my spi protocol (used by storage) 
00ac			 
00ac			; SPI pins 
00ac			 
00ac			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ac			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ac			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ac			 
00ac			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ac			; chip pin 4 gnd 
00ac			 
00ac			 
00ac			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ac			SPI_CE1: equ 1      ;    port a1 pin 14  
00ac			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ac			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ac			SPI_CE4: equ 4      ; port a4     pin 10 
00ac			 
00ac			; active low AND masks 
00ac			 
00ac			;SPI_CE0_MASK: equ    255-1 
00ac			;SPI_CE1_MASK: equ   255-2 
00ac			;SPI_CE2_MASK: equ   255-4 
00ac			;SPI_CE3_MASK: equ   255-8 
00ac			;SPI_CE4_MASK: equ   255-16 
00ac			SPI_CE_HIGH:  equ 255 
00ac			 
00ac			 
00ac			 
00ac			 
00ac			; TODO store port id for spi device ie dev c 
00ac			; TODO store pin for SO 
00ac			; TODO store pin for SI 
00ac			; TODO store pin for SCLK 
00ac			 
00ac			; 
00ac			 
00ac			; ensure that spi bus is in a stable state with default pins  
00ac			 
00ac			se_stable_spi:   
00ac			 
00ac				 ; set DI high, CE high , SCLK low 
00ac				;ld a, SPI_DI | SPI_CE0 
00ac 3e 07			ld a, SPI_DI  
00ae cd 82 01			call spi_ce_high 
00b1 d3 80			 out (storage_adata),a 
00b3 32 40 f8			ld (spi_portbyte),a 
00b6			 
00b6				if DEBUG_SPI 
00b6					push hl 
00b6					ld l, a 
00b6					DMARK "SPI" 
00b6					CALLMONITOR 
00b6					pop hl 
00b6				endif 
00b6 c9				ret 
00b7			 
00b7			; byte to send in a 
00b7			 
00b7			spi_send_byte: 
00b7				; save byte to send for bit mask shift out 
00b7 4f			        ld c,a 
00b8 3a 40 f8			ld a,(spi_portbyte) 
00bb				  
00bb				; clock out	each bit of the byte msb first 
00bb			 
00bb 06 08			ld b, 8 
00bd			.ssb1: 
00bd				; clear so bit  
00bd cb bf			res SPI_DI, a 
00bf cb 11			rl c 
00c1				; if bit 7 is set then carry is set 
00c1 30 02			jr nc, .ssb2 
00c3 cb ff			set SPI_DI,a 
00c5			.ssb2:  ; output bit to ensure it is stable 
00c5 d3 80			out (storage_adata),a 
00c7 00				nop 
00c8				; clock bit high 
00c8 cb ef			set SPI_SCLK,a 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; then low 
00cd cb af			res SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2 10 e9			djnz .ssb1 
00d4			 
00d4 32 40 f8			ld (spi_portbyte),a 
00d7 c9				ret 
00d8			 
00d8			; TODO low level get byte into A on spi 
00d8			 
00d8			spi_read_byte:  
00d8			 
00d8				; save byte to send for bit mask shift out 
00d8 0e 00		    ld c,0 
00da 3a 40 f8			ld a,(spi_portbyte) 
00dd				  
00dd				; clock out	each bit of the byte msb first 
00dd			 
00dd			 
00dd				; clock bit high 
00dd cb ef			set SPI_SCLK,a 
00df d3 80			out (storage_adata),a 
00e1 00				nop 
00e2			 
00e2			    ; read DO  
00e2			 
00e2 cb f9		    set 7,c 
00e4 db 80			in a,(storage_adata) 
00e6 cb 77		    bit SPI_DO,a 
00e8 20 02		    jr nz, .b7 
00ea cb b9		    res 7,c 
00ec			.b7: 
00ec				; then low 
00ec cb af			res SPI_SCLK,a 
00ee d3 80			out (storage_adata),a 
00f0 00				nop 
00f1			     
00f1			 
00f1				; clock bit high 
00f1 cb ef			set SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			 
00f6			    ; read DO  
00f6			 
00f6 cb f1		    set 6,c 
00f8 db 80			in a,(storage_adata) 
00fa cb 77		    bit SPI_DO,a 
00fc 20 02		    jr nz, .b6 
00fe cb b1		    res 6,c 
0100			.b6: 
0100				; then low 
0100 cb af			res SPI_SCLK,a 
0102 d3 80			out (storage_adata),a 
0104 00				nop 
0105			 
0105				; clock bit high 
0105 cb ef			set SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a			 
010a			    ; read DO  
010a			 
010a cb e9		    set 5,c 
010c db 80			in a,(storage_adata) 
010e cb 77		    bit SPI_DO,a 
0110 20 02		    jr nz, .b5 
0112 cb a9		    res 5,c 
0114			.b5: 
0114				; then low 
0114 cb af			res SPI_SCLK,a 
0116 d3 80			out (storage_adata),a 
0118 00				nop 
0119				; clock bit high 
0119 cb ef			set SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e			 
011e			    ; read DO  
011e			 
011e cb e1		    set 4,c 
0120 db 80			in a,(storage_adata) 
0122 cb 77		    bit SPI_DO,a 
0124 20 02		    jr nz, .b4 
0126 cb a1		    res 4,c 
0128			.b4: 
0128				; then low 
0128 cb af			res SPI_SCLK,a 
012a d3 80			out (storage_adata),a 
012c 00				nop 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132			 
0132			    ; read DO  
0132			 
0132 cb d9		    set 3,c 
0134 db 80			in a,(storage_adata) 
0136 cb 77		    bit SPI_DO,a 
0138 20 02		    jr nz, .b3 
013a cb 99		    res 3,c 
013c			.b3: 
013c				; then low 
013c cb af			res SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141				; clock bit high 
0141 cb ef			set SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146			 
0146			    ; read DO  
0146			 
0146 cb d1		    set 2,c 
0148 db 80			in a,(storage_adata) 
014a cb 77		    bit SPI_DO,a 
014c 20 02		    jr nz, .b2 
014e cb 91		    res 2,c 
0150			.b2: 
0150				; then low 
0150 cb af			res SPI_SCLK,a 
0152 d3 80			out (storage_adata),a 
0154 00				nop 
0155				; clock bit high 
0155 cb ef			set SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a			 
015a			    ; read DO  
015a			 
015a cb c9		    set 1,c 
015c db 80			in a,(storage_adata) 
015e cb 77		    bit SPI_DO,a 
0160 20 02		    jr nz, .b1 
0162 cb 89		    res 1,c 
0164			.b1: 
0164				; then low 
0164 cb af			res SPI_SCLK,a 
0166 d3 80			out (storage_adata),a 
0168 00				nop 
0169				; clock bit high 
0169 cb ef			set SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e			 
016e			    ; read DO  
016e			 
016e cb c1		    set 0,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b0 
0176 cb 81		    res 0,c 
0178			.b0: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d			 
017d			 
017d 32 40 f8			ld (spi_portbyte),a 
0180			 
0180			    ; return byte 
0180 79			    ld a,c 
0181			 
0181			 
0181 c9				ret 
0182			 
0182			 
0182			 
0182			spi_ce_high: 
0182			 
0182				if DEBUG_SPI_HARD_CE0 
0182			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0182					ret 
0182			 
0182				endif 
0182			 
0182			 
0182 f5				push af 
0183			 
0183				; send direct ce to port b 
0183 3e ff			ld a, 255 
0185 d3 81			out (storage_bdata), a 
0187			 
0187 f1				pop af 
0188			 
0188				; for port a that shares with spi lines AND the mask 
0188			  
0188				if DEBUG_SPI 
0188					push hl 
0188					ld h, a 
0188				endif 
0188			;	ld c, SPI_CE_HIGH 
0188			;	and c 
0188 cb c7			set SPI_CE0, a 
018a cb cf			set SPI_CE1, a 
018c cb d7			set SPI_CE2, a 
018e cb df			set SPI_CE3, a 
0190 cb e7			set SPI_CE4, a 
0192			 
0192				if DEBUG_SPI 
0192					ld l, a 
0192					DMARK "CEh" 
0192					CALLMONITOR 
0192					pop hl 
0192				endif 
0192 c9				ret 
0193			 
0193			 
0193			spi_ce_low: 
0193			 
0193				if DEBUG_SPI_HARD_CE0 
0193			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0193					ret 
0193			 
0193				endif 
0193			 
0193 c5				push bc 
0194 f5				push af 
0195			 
0195				; send direct ce to port b 
0195 3a 42 f8			ld a, (spi_cartdev) 
0198 d3 81			out (storage_bdata), a 
019a			 
019a			 
019a			 
019a				; for port a that shares with spi lines AND the mask 
019a			 
019a 3a 3f f8			ld a, (spi_device)  
019d 4f				ld c, a 
019e			 
019e f1				pop af 
019f			 
019f				; detect CEx 
019f			 
019f				if DEBUG_SPI 
019f					push hl 
019f					ld h, a 
019f				endif 
019f			 
019f cb 41			bit SPI_CE0, c 
01a1 20 04			jr nz, .cel1 
01a3 cb 87			res SPI_CE0, a 
01a5 18 1e			jr .celn 
01a7			.cel1: 
01a7 cb 49			bit SPI_CE1, c 
01a9 20 04			jr nz, .cel2 
01ab cb 8f			res SPI_CE1, a 
01ad 18 16			jr .celn 
01af			.cel2: 
01af cb 51			bit SPI_CE2, c 
01b1 20 04			jr nz, .cel3 
01b3 cb 97			res SPI_CE2, a 
01b5 18 0e			jr .celn 
01b7			.cel3: 
01b7 cb 59			bit SPI_CE3, c 
01b9 20 04			jr nz, .cel4 
01bb cb 9f			res SPI_CE3, a 
01bd 18 06			jr .celn 
01bf			.cel4: 
01bf cb 61			bit SPI_CE4, c 
01c1 20 02			jr nz, .celn 
01c3 cb a7			res SPI_CE4, a 
01c5			.celn: 
01c5			 
01c5			 
01c5			 
01c5			;	add c 
01c5			 
01c5				if DEBUG_SPI 
01c5					ld l, a 
01c5					DMARK "CEl" 
01c5					CALLMONITOR 
01c5					pop hl 
01c5				endif 
01c5 c1				pop bc 
01c6 c9				ret 
01c7			 
01c7			 
01c7			 
01c7			; eof 
01c7			 
01c7			 
01c7			 
01c7			 
01c7			 
# End of file firmware_spi.asm
01c7				include "firmware_seeprom.asm"  
01c7			; 
01c7			; persisent storage interface via microchip serial eeprom 
01c7			 
01c7			; port a pio 2 
01c7			; pa 7 - si 
01c7			; pa 6 - sclk  
01c7			; pa 5 - so 
01c7			; pa 4 - cs 
01c7			; pa 3 - cs 
01c7			; pa 2 - cs 
01c7			; pa 1 - cs 
01c7			; pa 0 - cs 
01c7			; 
01c7			; TODO get block 
01c7			; TODO save block 
01c7			; TODO load file 
01c7			; TODO save file 
01c7			; TODO get dir  
01c7			 
01c7			;  
01c7			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c7			storage_actl: equ Device_C+2     ; device c port a 
01c7			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c7			storage_bctl: equ Device_C+3     ; device c port b 
01c7			 
01c7			 
01c7			; TODO move these to hardware driver file 
01c7			 
01c7			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c7			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c7			; storage bank file system format 
01c7			; 
01c7			; first page of bank: 
01c7			; 	addr 0 - status check 
01c7			;       addr 1 - write protect flag 
01c7			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c7			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c7			;         TODO see if scanning whole of for available next file id is fast enough 
01c7			;	addr 4 > zero term string of bank label 
01c7			; 
01c7			;        
01c7			;  
01c7			; first page of any file: 
01c7			;      byte 0 - file id  
01c7			;      byte 1-17 - fixed file name  
01c7			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c7			; 
01c7			; other pages of any file: 
01c7			;      byte 0 - file id 
01c7			;      byte 1> - file data 
01c7			; 
01c7			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c7			;  
01c7			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c7			 
01c7			 
01c7			;storage_so_bit: 5 
01c7			;storage_si_bit: 7 
01c7			;storage_sclk_bit: 6 
01c7			  
01c7			 
01c7			; init storage pio 
01c7			 
01c7			storage_init: 
01c7			 
01c7 3e cf		            LD   A, 11001111b 
01c9 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cb 3e 00		            LD   A, 00000000b 
01cd cb f7			set SPI_DO,a 
01cf			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01cf d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d1			 
01d1 3e cf		            LD   A, 11001111b 
01d3 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d5 3e 00		            LD   A, 00000000b 
01d7 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01d9			 
01d9				; set all external spi devices off 
01d9 3e 00			ld a, 0 
01db 32 3f f8			ld (spi_device), a 
01de 32 42 f8			ld (spi_cartdev), a 
01e1			 
01e1					; ensure the spi bus is in a default stable state 
01e1 cd ac 00				call se_stable_spi 
01e4			 
01e4			; TODO scan spi bus and gather which storage banks are present 
01e4			 
01e4			; populate store_bank_active  
01e4			; for each ce line activate and attempt to write first byte of bank and read back 
01e4			; if zero is returned then bank is empty 
01e4			;   
01e4			; 
01e4			 
01e4					; init file extent cache to save on slow reads 
01e4			 
01e4			;	ld hl, store_filecache 
01e4			;	ld de, 0 
01e4			;	ld hl,(de)	 
01e4			 
01e4			 
01e4 c9			    ret 
01e5			 
01e5			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e5			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e5			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e5			 
01e5			; INSTRUCTION SET 
01e5			; READ 0000 0011 Read data from memory array beginning at selected address 
01e5			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e5			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e5			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e5			; RDSR 0000 0101 Read STATUS register 
01e5			; WRSR 0000 0001 Write STATUS register 
01e5			; PE 0100 0010 Page Erase – erase one page in memory array 
01e5			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e5			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e5			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e5			 
01e5			; TODO send byte steam for page without setting the address for every single byte 
01e5			; TODO read byte  
01e5			 
01e5			; byte in a 
01e5			; address in hl  
01e5			se_writebyte: 
01e5			        
01e5			    ;   ld c, a 
01e5 f5			        push af 
01e6 e5			        push hl 
01e7			 
01e7			    ; initi write mode 
01e7			    ; 
01e7			    ;CS low 
01e7			 
01e7 3a 40 f8		       ld a,(spi_portbyte) 
01ea cd 93 01			call spi_ce_low 
01ed			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ed d3 80		       out (storage_adata),a 
01ef 32 40 f8		       ld (spi_portbyte), a 
01f2			 
01f2			    ;clock out wren instruction 
01f2			 
01f2 3e 06		    ld a, store_wren_ins 
01f4 cd b7 00		    call spi_send_byte  
01f7			 
01f7			    ;cs high to enable write latch 
01f7			 
01f7 3a 40 f8		       ld a,(spi_portbyte) 
01fa cd 82 01			call spi_ce_high 
01fd			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd d3 80		       out (storage_adata),a 
01ff 32 40 f8		       ld (spi_portbyte), a 
0202			 
0202 00				nop 
0203			    ; 
0203			    ; intial write data 
0203			    ; 
0203			    ; cs low 
0203			     
0203 3a 40 f8		       ld a,(spi_portbyte) 
0206 cd 93 01			call spi_ce_low 
0209			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0209 d3 80		       out (storage_adata),a 
020b 32 40 f8		       ld (spi_portbyte), a 
020e			 
020e			    ; clock out write instruction 
020e			     
020e 3e 02		    ld a, store_write_ins  
0210 cd b7 00		    call spi_send_byte  
0213			 
0213			    ; clock out address (depending on address size) 
0213			     
0213 e1			    pop hl 
0214 7c			    ld a,h    ; address out msb first 
0215 cd b7 00		    call spi_send_byte  
0218 7d			    ld a,l 
0219 cd b7 00		    call spi_send_byte  
021c			 
021c			    ; clock out byte(s) for page 
021c			 
021c f1			    pop af 
021d cd b7 00		    call spi_send_byte  
0220			 
0220			    ; end write with ce high 
0220 3a 40 f8		       ld a,(spi_portbyte) 
0223			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0223 cd 82 01			call spi_ce_high 
0226 d3 80		       out (storage_adata),a 
0228 32 40 f8		       ld (spi_portbyte), a 
022b			 
022b				; pause for internal write cycle 
022b 3e 0a			ld a, 10 
022d cd 49 0a			call aDelayInMS 
0230 c9			    ret 
0231			 
0231			; buffer to write in de 
0231			; address in hl  
0231			se_writepage: 
0231			        
0231			    ;   ld c, a 
0231 d5				push de 
0232 e5			        push hl 
0233			 
0233			    ; initi write mode 
0233			    ; 
0233			    ;CS low 
0233			 
0233 3a 40 f8		       ld a,(spi_portbyte) 
0236 cd 93 01			call spi_ce_low 
0239			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 40 f8		       ld (spi_portbyte), a 
023e			 
023e			    ;clock out wren instruction 
023e			 
023e 3e 06		    ld a, store_wren_ins 
0240 cd b7 00		    call spi_send_byte  
0243			 
0243			    ;cs high to enable write latch 
0243			 
0243 3a 40 f8		       ld a,(spi_portbyte) 
0246 cd 82 01			call spi_ce_high 
0249			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0249 d3 80		       out (storage_adata),a 
024b 32 40 f8		       ld (spi_portbyte), a 
024e			 
024e 00				nop 
024f			    ; 
024f			    ; intial write data 
024f			    ; 
024f			    ; cs low 
024f			     
024f 3a 40 f8		       ld a,(spi_portbyte) 
0252			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0252 cd 93 01			call spi_ce_low 
0255 d3 80		       out (storage_adata),a 
0257 32 40 f8		       ld (spi_portbyte), a 
025a			 
025a			    ; clock out write instruction 
025a			     
025a 3e 02		    ld a, store_write_ins  
025c cd b7 00		    call spi_send_byte  
025f			 
025f			    ; clock out address (depending on address size) 
025f			     
025f e1			    pop hl 
0260 7c			    ld a,h    ; address out msb first 
0261 cd b7 00		    call spi_send_byte  
0264 7d			    ld a,l 
0265 cd b7 00		    call spi_send_byte  
0268			 
0268			    ; clock out byte(s) for page 
0268			 
0268 e1				pop hl 
0269 06 40			ld b, STORE_BLOCK_PHY 
026b			.bytewrite: 
026b			 
026b 7e				ld a,(hl) 
026c e5			    push hl 
026d c5				push bc 
026e cd b7 00		    call spi_send_byte  
0271 c1				pop bc 
0272 e1				pop hl 
0273			 
0273			    ; end write with ce high 
0273 3a 40 f8		       ld a,(spi_portbyte) 
0276 cd 82 01			call spi_ce_high 
0279			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0279 d3 80		       out (storage_adata),a 
027b 32 40 f8		       ld (spi_portbyte), a 
027e			 
027e 23				inc hl 
027f 10 ea			djnz .bytewrite 
0281			 
0281				; pause for internal write cycle 
0281 3e 64			ld a, 100 
0283 cd 49 0a			call aDelayInMS 
0286 c9			    ret 
0287			; returns byte in a 
0287			; address in hl  
0287			se_readbyte: 
0287 d5				push de 
0288 c5				push bc 
0289			 
0289			    ;   ld c, a 
0289 e5			        push hl 
028a			 
028a			    ; initi write mode 
028a			    ; 
028a			    ;CS low 
028a			 
028a 3a 40 f8		       ld a,(spi_portbyte) 
028d cd 93 01			call spi_ce_low 
0290			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0290 d3 80		       out (storage_adata),a 
0292 32 40 f8		       ld (spi_portbyte), a 
0295			 
0295			    ;clock out wren instruction 
0295			 
0295 3e 03		    ld a, store_read_ins 
0297 cd b7 00		    call spi_send_byte  
029a			 
029a			 
029a			    ; clock out address (depending on address size) 
029a			     
029a e1			    pop hl 
029b 7c			    ld a,h    ; address out msb first 
029c cd b7 00		    call spi_send_byte  
029f 7d			    ld a,l 
02a0 cd b7 00		    call spi_send_byte  
02a3			 
02a3			    ; clock in byte(s) for page 
02a3			 
02a3 cd d8 00		    call spi_read_byte  
02a6 f5				push af 
02a7			 
02a7			    ; end write with ce high 
02a7 3a 40 f8		       ld a,(spi_portbyte) 
02aa			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02aa cd 82 01			call spi_ce_high 
02ad d3 80		       out (storage_adata),a 
02af 32 40 f8		       ld (spi_portbyte), a 
02b2			 
02b2 f1				pop af 
02b3			 
02b3 c1				pop bc 
02b4 d1				pop de 
02b5			 
02b5 c9			    ret 
02b6			 
02b6			if DEBUG_STORESE 
02b6			 
02b6			storageput:  
02b6			 
02b6			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b6			 
02b6 21 16 ee			ld hl,scratch+2 
02b9 cd d2 10			call get_word_hl 
02bc			 
02bc				; stuff it here for the moment as it will be overwritten later anyway 
02bc			 
02bc 22 37 f1			ld (os_cur_ptr),hl	 
02bf			 
02bf			 
02bf			; get pointer to start of string 
02bf			 
02bf 21 1b ee			ld hl, scratch+7 
02c2			 
02c2			; loop writing char of string to eeprom 
02c2			 
02c2 7e			.writestr:	ld a,(hl) 
02c3 fe 00				cp 0 
02c5 28 12				jr z, .wsdone		; done writing 
02c7 e5					push hl 
02c8 2a 37 f1				ld hl,(os_cur_ptr) 
02cb cd e5 01				call se_writebyte 
02ce			 
02ce 2a 37 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d1 23					inc hl 
02d2 22 37 f1				ld (os_cur_ptr),hl 
02d5			 
02d5					; restore string pointer and get next char 
02d5			 
02d5 e1					pop hl 
02d6 23					inc hl 
02d7 18 e9				jr .writestr 
02d9			 
02d9			 
02d9			 
02d9			.wsdone: 
02d9			 
02d9			 
02d9			; when done load first page into a buffer  
02d9			 
02d9 21 00 80				ld hl,08000h		; start in ram 
02dc 22 37 f1				ld (os_cur_ptr),hl 
02df 21 00 00				ld hl, 0		 ; start of page 
02e2 22 3c ee				ld (scratch+40),hl	; hang on to it 
02e5			 
02e5 06 80				ld b, 128		; actually get more then one page 
02e7 c5			.wsload:	push bc 
02e8 2a 3c ee				ld hl,(scratch+40) 
02eb e5					push hl 
02ec cd 87 02				call se_readbyte 
02ef			 
02ef					; a now as the byte 
02ef			 
02ef 2a 37 f1				ld hl,(os_cur_ptr) 
02f2 77					ld (hl),a 
02f3					; inc next buffer area 
02f3 23					inc hl 
02f4 22 37 f1				ld (os_cur_ptr),hl 
02f7			 
02f7					; get eeprom position, inc and save for next round 
02f7 e1					pop hl		 
02f8 23					inc hl 
02f9 22 3c ee				ld (scratch+40),hl 
02fc c1					pop bc 
02fd 10 e8				djnz .wsload 
02ff			 
02ff			; set 'd' pointer to start of buffer 
02ff			 
02ff 21 00 80				ld hl,08000h 
0302 22 37 f1				ld (os_cur_ptr),hl 
0305			 
0305			 
0305 c9			ret 
0306			 
0306			 
0306 c9			storageread: ret 
0307			 
0307			 
0307			 
0307			 
0307			 
0307			 
0307			endif 
0307			 
0307			 
0307			 
# End of file firmware_seeprom.asm
0307			else  
0307			   ; create some stubs for the labels  
0307			se_readbyte: ret  
0307			se_writebyte: ret  
0307			storage_init: ret  
0307			  
0307			endif  
0307			  
0307			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0307			;include "firmware_cf.asm"  
0307			  
0307			; load up high level storage hardward abstractions  
0307			include "firmware_storage.asm"  
0307			 
0307			; persisent storage hardware abstraction layer  
0307			 
0307			 
0307			 
0307			; Block 0 on storage is a config state 
0307			 
0307			 
0307			 
0307			; TODO add read phy block and write phy block functions 
0307			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0307			 
0307			; Abstraction layer  
0307			 
0307			; Logocial block size is same size as physical size - using tape concept 
0307			 
0307			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0307			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0307			 
0307			 
0307			 
0307			; Filesystem layout (Logical layout) 
0307			; 
0307			; Block 0 - Bank config  
0307			; 
0307			;      Byte - 0 file id counter 
0307			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0307			;      Byte - 3-20 zero terminated bank label 
0307			; 
0307			; Block 1 > File storage 
0307			; 
0307			;      Byte 0 file id    - block 0 file details 
0307			;      Byte 1 block id - block 0 is file  
0307			;            Byte 2-15 - File name 
0307			; 
0307			;       - to end of block data 
0307			; 
0307			 
0307			 
0307			; Read Block 
0307			; ---------- 
0307			; 
0307			; With current bank 
0307			;  
0307			; Get block number to read 
0307			; Load physical blocks starting at start block into buffer 
0307			 
0307			; de points to buffer to use 
0307			; hl holds logical block number  
0307			 
0307			storage_read_block: 
0307			 
0307				; TODO bank selection 
0307			 
0307				; for each of the physical blocks read it into the buffer 
0307 06 40			ld b, STORE_BLOCK_PHY 
0309			 
0309				if DEBUG_STORESE 
0309 d5					push de 
030a				endif 
030a				 
030a			.rl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d			;	if DEBUG_STORESE 
030d			;		push af 
030d			;		ld a, 'R' 
030d			;		ld (debug_mark),a 
030d			;		pop af 
030d			;		CALLMONITOR 
030d			;	endif 
030d cd 87 02			call se_readbyte 
0310			;	if DEBUG_STORESE 
0310			;		ld a,(spi_portbyte) 
0310			;		ld l, a 
0310			;		push af 
0310			;		ld a, '1' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310			;		CALLMONITOR 
0310			;	endif 
0310 c1				pop bc 
0311 d1				pop de 
0312 e1				pop hl 
0313 12				ld (de),a 
0314 23				inc hl 
0315 13				inc de 
0316			 
0316			;	if DEBUG_STORESE 
0316			;		push af 
0316			;		ld a, 'r' 
0316			;		ld (debug_mark),a 
0316			;		pop af 
0316			;		CALLMONITOR 
0316			;	endif 
0316			 
0316 10 f2			djnz .rl1 
0318			 
0318				if DEBUG_STORESE 
0318					DMARK "SRB" 
0318 f5				push af  
0319 3a 2d 03			ld a, (.dmark)  
031c 32 6e fb			ld (debug_mark),a  
031f 3a 2e 03			ld a, (.dmark+1)  
0322 32 6f fb			ld (debug_mark+1),a  
0325 3a 2f 03			ld a, (.dmark+2)  
0328 32 70 fb			ld (debug_mark+2),a  
032b 18 03			jr .pastdmark  
032d ..			.dmark: db "SRB"  
0330 f1			.pastdmark: pop af  
0331			endm  
# End of macro DMARK
0331 d1					pop de 
0332			; 
0332			;		push af 
0332			;		ld a, 'R' 
0332			;		ld (debug_mark),a 
0332			;		pop af 
0332					CALLMONITOR 
0332 cd 6a 17			call break_point_state  
0335				endm  
# End of macro CALLMONITOR
0335				endif 
0335 c9				ret	 
0336				 
0336			 
0336			; File Size 
0336			; --------- 
0336			; 
0336			;   hl file id 
0336			; 
0336			;  returns in hl the number of blocks 
0336			 
0336			storage_file_size: 
0336 5d				ld e, l 
0337 16 00			ld d, 0 
0339 21 40 00			ld hl, STORE_BLOCK_PHY 
033c					if DEBUG_FORTH_WORDS 
033c						DMARK "SIZ" 
033c f5				push af  
033d 3a 51 03			ld a, (.dmark)  
0340 32 6e fb			ld (debug_mark),a  
0343 3a 52 03			ld a, (.dmark+1)  
0346 32 6f fb			ld (debug_mark+1),a  
0349 3a 53 03			ld a, (.dmark+2)  
034c 32 70 fb			ld (debug_mark+2),a  
034f 18 03			jr .pastdmark  
0351 ..			.dmark: db "SIZ"  
0354 f1			.pastdmark: pop af  
0355			endm  
# End of macro DMARK
0355						CALLMONITOR 
0355 cd 6a 17			call break_point_state  
0358				endm  
# End of macro CALLMONITOR
0358					endif 
0358 cd 2c 06			call storage_findnextid 
035b			 
035b cd 44 0d			call ishlzero 
035e			;	ld a, l 
035e			;	add h 
035e			;	cp 0 
035e c8				ret z			; block not found so EOF 
035f			 
035f 11 59 f8			ld de, store_page 
0362 cd 07 03			call storage_read_block 
0365			 
0365 3a 5b f8			ld a, (store_page+2)	 ; get extent count 
0368 6f				ld l, a 
0369 26 00			ld h, 0 
036b c9			 	ret 
036c			 
036c			 
036c			; Write Block 
036c			; ----------- 
036c			; 
036c			; With current bank 
036c			;  
036c			; Get block number to write 
036c			; Write physical blocks starting at start block from buffer 
036c			  
036c			storage_write_block: 
036c				; TODO bank selection 
036c			 
036c				; for each of the physical blocks read it into the buffer 
036c 06 40			ld b, STORE_BLOCK_PHY 
036e			 
036e				if DEBUG_STORESE 
036e					DMARK "SWB" 
036e f5				push af  
036f 3a 83 03			ld a, (.dmark)  
0372 32 6e fb			ld (debug_mark),a  
0375 3a 84 03			ld a, (.dmark+1)  
0378 32 6f fb			ld (debug_mark+1),a  
037b 3a 85 03			ld a, (.dmark+2)  
037e 32 70 fb			ld (debug_mark+2),a  
0381 18 03			jr .pastdmark  
0383 ..			.dmark: db "SWB"  
0386 f1			.pastdmark: pop af  
0387			endm  
# End of macro DMARK
0387			 
0387					;push af 
0387					;ld a, 'W' 
0387					;ld (debug_mark),a 
0387					;pop af 
0387					CALLMONITOR 
0387 cd 6a 17			call break_point_state  
038a				endm  
# End of macro CALLMONITOR
038a				endif 
038a			 
038a			; might not be working 
038a			;	call se_writepage 
038a			 
038a			;	ret 
038a			; 
038a			 
038a			 
038a			 
038a			.wl1:    
038a			 
038a				; read physical block at hl into de 
038a			        ; increment hl and de to next read position on exit 
038a			 
038a e5				push hl 
038b d5				push de	 
038c c5				push bc 
038d 1a				ld a,(de) 
038e				;if DEBUG_STORESE 
038e			;		push af 
038e			;		ld a, 'W' 
038e			;		ld (debug_mark),a 
038e			;		pop af 
038e			;		CALLMONITOR 
038e			;	endif 
038e cd e5 01			call se_writebyte 
0391			;	call delay250ms 
0391 00				nop 
0392 00				nop 
0393 00				nop 
0394			;	if DEBUG_STORESE 
0394			;		push af 
0394			;		ld a, 'w' 
0394			;		ld (debug_mark),a 
0394			;		pop af 
0394			;		CALLMONITOR 
0394			;	endif 
0394 c1				pop bc 
0395 d1				pop de 
0396 e1				pop hl 
0397 23				inc hl 
0398 13				inc de 
0399			 
0399			 
0399 10 ef			djnz .wl1 
039b			 
039b				if DEBUG_STORESE 
039b					DMARK "SW2" 
039b f5				push af  
039c 3a b0 03			ld a, (.dmark)  
039f 32 6e fb			ld (debug_mark),a  
03a2 3a b1 03			ld a, (.dmark+1)  
03a5 32 6f fb			ld (debug_mark+1),a  
03a8 3a b2 03			ld a, (.dmark+2)  
03ab 32 70 fb			ld (debug_mark+2),a  
03ae 18 03			jr .pastdmark  
03b0 ..			.dmark: db "SW2"  
03b3 f1			.pastdmark: pop af  
03b4			endm  
# End of macro DMARK
03b4			 
03b4					;push af 
03b4					;ld a, 'W' 
03b4					;ld (debug_mark),a 
03b4					;pop af 
03b4					CALLMONITOR 
03b4 cd 6a 17			call break_point_state  
03b7				endm  
# End of macro CALLMONITOR
03b7				endif 
03b7 c9				ret	 
03b8			 
03b8			; Init bank 
03b8			; --------- 
03b8			; 
03b8			; With current bank 
03b8			; 
03b8			; Setup block 0 config 
03b8			;     Set 0 file id counter 
03b8			;     Set formatted byte pattern 
03b8			;     Zero out bank label 
03b8			;      
03b8			; For every logical block write 0-1 byte as null 
03b8			 
03b8			storage_get_block_0: 
03b8			 
03b8				; TODO check presence 
03b8			 
03b8				; get block 0 config 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 59 f8			ld de, store_page 
03be cd 07 03			call storage_read_block 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SB0" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 6e fb			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 6f fb			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 70 fb			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SB0"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da 11 59 f8				ld de, store_page 
03dd			;		push af 
03dd			;		ld a, 'i' 
03dd			;		ld (debug_mark),a 
03dd			;		pop af 
03dd					CALLMONITOR 
03dd cd 6a 17			call break_point_state  
03e0				endm  
# End of macro CALLMONITOR
03e0				endif 
03e0			 
03e0				; is this area formatted? 
03e0			 
03e0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e0 2a 5a f8			ld hl, (store_page+1) 
03e3 3e 80			ld a,0x80 
03e5 bd				cp l 
03e6 20 22			jr nz, .ininotformatted 
03e8				; do a double check 
03e8 3e 27			ld a, 0x27 
03ea bc				cp h 
03eb 20 1d			jr nz, .ininotformatted 
03ed			 
03ed				; formatted then 
03ed			 
03ed				if DEBUG_STORESE 
03ed					DMARK "SB1" 
03ed f5				push af  
03ee 3a 02 04			ld a, (.dmark)  
03f1 32 6e fb			ld (debug_mark),a  
03f4 3a 03 04			ld a, (.dmark+1)  
03f7 32 6f fb			ld (debug_mark+1),a  
03fa 3a 04 04			ld a, (.dmark+2)  
03fd 32 70 fb			ld (debug_mark+2),a  
0400 18 03			jr .pastdmark  
0402 ..			.dmark: db "SB1"  
0405 f1			.pastdmark: pop af  
0406			endm  
# End of macro DMARK
0406					;push af 
0406					;ld a, 'I' 
0406					;ld (debug_mark),a 
0406					;pop af 
0406					CALLMONITOR 
0406 cd 6a 17			call break_point_state  
0409				endm  
# End of macro CALLMONITOR
0409				endif 
0409 c9				ret 
040a			 
040a			.ininotformatted: 
040a				; bank not formatted so poke various bits to make sure 
040a			 
040a				if DEBUG_STORESE 
040a					DMARK "SB2" 
040a f5				push af  
040b 3a 1f 04			ld a, (.dmark)  
040e 32 6e fb			ld (debug_mark),a  
0411 3a 20 04			ld a, (.dmark+1)  
0414 32 6f fb			ld (debug_mark+1),a  
0417 3a 21 04			ld a, (.dmark+2)  
041a 32 70 fb			ld (debug_mark+2),a  
041d 18 03			jr .pastdmark  
041f ..			.dmark: db "SB2"  
0422 f1			.pastdmark: pop af  
0423			endm  
# End of macro DMARK
0423					;push af 
0423					;ld a, 'f' 
0423					;ld (debug_mark),a 
0423					;pop af 
0423					CALLMONITOR 
0423 cd 6a 17			call break_point_state  
0426				endm  
# End of macro CALLMONITOR
0426				endif 
0426			 
0426 cd 27 0a			call storage_clear_page 
0429			 
0429 21 59 f8			ld hl, store_page 
042c 3e 00			ld a, 0 
042e				 
042e 77				ld (hl),a   ; reset file counter 
042f			 
042f 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0432 22 5a f8		 	ld (store_page+1), hl	 
0435			 
0435				; set default label 
0435			 
0435 21 d1 04			ld hl, .defaultbanklabl 
0438 11 5c f8		 	ld de, store_page+3 
043b 01 0f 00			ld bc, 15 
043e ed b0			ldir 
0440			 
0440				; Append the current bank id 
0440 21 65 f8			ld hl, store_page+3+9 
0443 3a 3e f8			ld a, (spi_device_id) 
0446 77				ld (hl), a 
0447			 
0447				; save default page 0 
0447			 
0447 21 00 00			ld hl, 0 
044a 11 59 f8			ld de, store_page 
044d				if DEBUG_STORESE 
044d					DMARK "SB3" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6e fb			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6f fb			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 70 fb			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "SB3"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466			;		push af 
0466			;		ld a, 'F' 
0466			;		ld (debug_mark),a 
0466			;		pop af 
0466					CALLMONITOR 
0466 cd 6a 17			call break_point_state  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469 cd 6c 03			call storage_write_block 
046c				if DEBUG_STORESE 
046c					DMARK "SB4" 
046c f5				push af  
046d 3a 81 04			ld a, (.dmark)  
0470 32 6e fb			ld (debug_mark),a  
0473 3a 82 04			ld a, (.dmark+1)  
0476 32 6f fb			ld (debug_mark+1),a  
0479 3a 83 04			ld a, (.dmark+2)  
047c 32 70 fb			ld (debug_mark+2),a  
047f 18 03			jr .pastdmark  
0481 ..			.dmark: db "SB4"  
0484 f1			.pastdmark: pop af  
0485			endm  
# End of macro DMARK
0485			;		push af 
0485			;		ld a, '>' 
0485			;		ld (debug_mark),a 
0485			;		pop af 
0485					CALLMONITOR 
0485 cd 6a 17			call break_point_state  
0488				endm  
# End of macro CALLMONITOR
0488				endif 
0488			 
0488 00				nop 
0489 00				nop 
048a 00				nop 
048b			 
048b				; now set 0 in every page to mark as a free block 
048b			 
048b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048d 21 40 00			ld hl, STORE_BLOCK_PHY 
0490			 
0490 3e 00		.setmark1:   	ld a,0 
0492 e5					push hl 
0493 c5					push bc 
0494 cd e5 01				call se_writebyte 
0497 3e 0a			ld a, 10 
0499 cd 49 0a			call aDelayInMS 
049c 23				inc hl 
049d cd e5 01				call se_writebyte 
04a0 3e 0a			ld a, 10 
04a2 cd 49 0a			call aDelayInMS 
04a5 2b				dec hl 
04a6 c1					pop bc 
04a7 e1					pop hl 
04a8 3e 40				ld a, STORE_BLOCK_PHY 
04aa cd 1b 0d				call addatohl 
04ad 10 e1				djnz .setmark1 
04af			 
04af 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b1 3e 00		.setmark2:   	ld a,0 
04b3 e5					push hl 
04b4 c5					push bc 
04b5 cd e5 01				call se_writebyte 
04b8 3e 0a			ld a, 10 
04ba cd 49 0a			call aDelayInMS 
04bd 23				inc hl 
04be cd e5 01				call se_writebyte 
04c1 3e 0a			ld a, 10 
04c3 cd 49 0a			call aDelayInMS 
04c6 2b				dec hl 
04c7 c1					pop bc 
04c8 e1					pop hl 
04c9 3e 40				ld a, STORE_BLOCK_PHY 
04cb cd 1b 0d				call addatohl 
04ce 10 e1				djnz .setmark2 
04d0			 
04d0					 
04d0			 
04d0			 
04d0 c9				ret 
04d1			 
04d1			 
04d1			 
04d1			 
04d1 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04dc			 
04dc			 
04dc			 
04dc			; Label Bank 
04dc			; ---------- 
04dc			; 
04dc			; With current bank 
04dc			; Read block 0 
04dc			; Set label 
04dc			; Write block 0 
04dc			 
04dc			; label str pointer in hl 
04dc			 
04dc			storage_label:     
04dc			 
04dc				if DEBUG_STORESE 
04dc					DMARK "LBL" 
04dc f5				push af  
04dd 3a f1 04			ld a, (.dmark)  
04e0 32 6e fb			ld (debug_mark),a  
04e3 3a f2 04			ld a, (.dmark+1)  
04e6 32 6f fb			ld (debug_mark+1),a  
04e9 3a f3 04			ld a, (.dmark+2)  
04ec 32 70 fb			ld (debug_mark+2),a  
04ef 18 03			jr .pastdmark  
04f1 ..			.dmark: db "LBL"  
04f4 f1			.pastdmark: pop af  
04f5			endm  
# End of macro DMARK
04f5					CALLMONITOR 
04f5 cd 6a 17			call break_point_state  
04f8				endm  
# End of macro CALLMONITOR
04f8				endif 
04f8			 
04f8 e5				push hl 
04f9			 
04f9 cd b8 03			call storage_get_block_0 
04fc			 
04fc				; set default label 
04fc			 
04fc e1				pop hl 
04fd			 
04fd 11 5c f8		 	ld de, store_page+3 
0500 01 0f 00			ld bc, 15 
0503				if DEBUG_STORESE 
0503					DMARK "LB3" 
0503 f5				push af  
0504 3a 18 05			ld a, (.dmark)  
0507 32 6e fb			ld (debug_mark),a  
050a 3a 19 05			ld a, (.dmark+1)  
050d 32 6f fb			ld (debug_mark+1),a  
0510 3a 1a 05			ld a, (.dmark+2)  
0513 32 70 fb			ld (debug_mark+2),a  
0516 18 03			jr .pastdmark  
0518 ..			.dmark: db "LB3"  
051b f1			.pastdmark: pop af  
051c			endm  
# End of macro DMARK
051c					CALLMONITOR 
051c cd 6a 17			call break_point_state  
051f				endm  
# End of macro CALLMONITOR
051f				endif 
051f ed b0			ldir 
0521				; save default page 0 
0521			 
0521 21 00 00			ld hl, 0 
0524 11 59 f8			ld de, store_page 
0527				if DEBUG_STORESE 
0527					DMARK "LBW" 
0527 f5				push af  
0528 3a 3c 05			ld a, (.dmark)  
052b 32 6e fb			ld (debug_mark),a  
052e 3a 3d 05			ld a, (.dmark+1)  
0531 32 6f fb			ld (debug_mark+1),a  
0534 3a 3e 05			ld a, (.dmark+2)  
0537 32 70 fb			ld (debug_mark+2),a  
053a 18 03			jr .pastdmark  
053c ..			.dmark: db "LBW"  
053f f1			.pastdmark: pop af  
0540			endm  
# End of macro DMARK
0540					CALLMONITOR 
0540 cd 6a 17			call break_point_state  
0543				endm  
# End of macro CALLMONITOR
0543				endif 
0543 cd 6c 03			call storage_write_block 
0546			 
0546 c9				ret 
0547			 
0547			 
0547			 
0547			; Read Block 0 - Config 
0547			; --------------------- 
0547			; 
0547			; With current bank 
0547			; Call presence test 
0547			;    If not present format/init bank  
0547			; Read block 0  
0547			;  
0547			 
0547			 
0547			; Dir 
0547			; --- 
0547			; 
0547			; With current bank 
0547			; Load Block 0 Config 
0547			; Get max file id number 
0547			; For each logical block 
0547			;    Read block read byte 2 
0547			;      if first block of file 
0547			;         Display file name 
0547			;         Display type flags for file 
0547			;        
0547			 
0547			; moving to words as this requires stack control 
0547			 
0547			 
0547			; Delete File 
0547			; ----------- 
0547			; 
0547			; With current bank 
0547			; 
0547			; Load Block 0 Config 
0547			; Get max file id number 
0547			; For each logical block 
0547			;    Read block file id 
0547			;      If first block of file and dont have file id 
0547			;         if file to delete 
0547			;         Save file id 
0547			;         Null file id 
0547			;         Write this block back 
0547			;      If file id is one saved 
0547			;         Null file id 
0547			;         Write this block back 
0547			 
0547			storage_erase: 
0547			 
0547				; hl contains the file id 
0547			 
0547 5d				ld e, l 
0548 16 00			ld d, 0 
054a 21 40 00			ld hl, STORE_BLOCK_PHY 
054d					if DEBUG_FORTH_WORDS 
054d						DMARK "ERA" 
054d f5				push af  
054e 3a 62 05			ld a, (.dmark)  
0551 32 6e fb			ld (debug_mark),a  
0554 3a 63 05			ld a, (.dmark+1)  
0557 32 6f fb			ld (debug_mark+1),a  
055a 3a 64 05			ld a, (.dmark+2)  
055d 32 70 fb			ld (debug_mark+2),a  
0560 18 03			jr .pastdmark  
0562 ..			.dmark: db "ERA"  
0565 f1			.pastdmark: pop af  
0566			endm  
# End of macro DMARK
0566						CALLMONITOR 
0566 cd 6a 17			call break_point_state  
0569				endm  
# End of macro CALLMONITOR
0569					endif 
0569 cd 2c 06			call storage_findnextid 
056c cd 44 0d			call ishlzero 
056f c8				ret z 
0570			 
0570 e5				push hl 
0571			 
0571				; TODO check file not found 
0571			 
0571 11 59 f8			ld de, store_page 
0574 cd 07 03			call storage_read_block 
0577			 
0577					if DEBUG_FORTH_WORDS 
0577						DMARK "ER1" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 6e fb			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 6f fb			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 70 fb			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "ER1"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590						CALLMONITOR 
0590 cd 6a 17			call break_point_state  
0593				endm  
# End of macro CALLMONITOR
0593					endif 
0593 3a 59 f8			ld a, (store_page)	; get file id 
0596 32 52 f8			ld (store_tmpid), a 
0599			 
0599 3a 5b f8			ld a, (store_page+2)    ; get count of extends 
059c 32 51 f8			ld (store_tmpext), a 
059f			 
059f				; wipe file header 
059f			 
059f e1				pop hl 
05a0 3e 00			ld a, 0 
05a2 32 59 f8			ld (store_page), a 
05a5 32 5a f8			ld (store_page+1),a 
05a8 11 59 f8			ld de, store_page 
05ab					if DEBUG_FORTH_WORDS 
05ab						DMARK "ER2" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 6e fb			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 6f fb			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 70 fb			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "ER2"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4						CALLMONITOR 
05c4 cd 6a 17			call break_point_state  
05c7				endm  
# End of macro CALLMONITOR
05c7					endif 
05c7 cd 6c 03			call storage_write_block 
05ca			 
05ca			 
05ca				; wipe file extents 
05ca			 
05ca 3a 51 f8			ld a, (store_tmpext) 
05cd 47				ld b, a 
05ce			 
05ce			.eraext:	  
05ce c5				push bc 
05cf			 
05cf 21 40 00			ld hl, STORE_BLOCK_PHY 
05d2 3a 52 f8			ld a,(store_tmpid) 
05d5 5f				ld e, a 
05d6 50				ld d, b	 
05d7					if DEBUG_FORTH_WORDS 
05d7						DMARK "ER3" 
05d7 f5				push af  
05d8 3a ec 05			ld a, (.dmark)  
05db 32 6e fb			ld (debug_mark),a  
05de 3a ed 05			ld a, (.dmark+1)  
05e1 32 6f fb			ld (debug_mark+1),a  
05e4 3a ee 05			ld a, (.dmark+2)  
05e7 32 70 fb			ld (debug_mark+2),a  
05ea 18 03			jr .pastdmark  
05ec ..			.dmark: db "ER3"  
05ef f1			.pastdmark: pop af  
05f0			endm  
# End of macro DMARK
05f0						CALLMONITOR 
05f0 cd 6a 17			call break_point_state  
05f3				endm  
# End of macro CALLMONITOR
05f3					endif 
05f3 cd 2c 06			call storage_findnextid 
05f6			 
05f6 e5				push hl 
05f7 11 59 f8			ld de, store_page 
05fa cd 07 03			call storage_read_block 
05fd			 
05fd				; free block	 
05fd			 
05fd 3e 00			ld a, 0 
05ff 32 59 f8			ld (store_page), a 
0602 32 5a f8			ld (store_page+1),a 
0605 11 59 f8			ld de, store_page 
0608 e1				pop hl 
0609					if DEBUG_FORTH_WORDS 
0609						DMARK "ER4" 
0609 f5				push af  
060a 3a 1e 06			ld a, (.dmark)  
060d 32 6e fb			ld (debug_mark),a  
0610 3a 1f 06			ld a, (.dmark+1)  
0613 32 6f fb			ld (debug_mark+1),a  
0616 3a 20 06			ld a, (.dmark+2)  
0619 32 70 fb			ld (debug_mark+2),a  
061c 18 03			jr .pastdmark  
061e ..			.dmark: db "ER4"  
0621 f1			.pastdmark: pop af  
0622			endm  
# End of macro DMARK
0622						CALLMONITOR 
0622 cd 6a 17			call break_point_state  
0625				endm  
# End of macro CALLMONITOR
0625					endif 
0625 cd 6c 03			call storage_write_block 
0628			 
0628 c1				pop bc 
0629 10 a3			djnz .eraext 
062b			 
062b c9				ret 
062c			 
062c			 
062c			; Find Free Block 
062c			; --------------- 
062c			; 
062c			; With current bank 
062c			;  
062c			; From given starting logical block 
062c			;    Read block  
062c			;    If no file id 
062c			;         Return block id 
062c			 
062c			 
062c			; hl starting page number 
062c			; hl contains free page number or zero if no pages free 
062c			; e contains the file id to locate 
062c			; d contains the block number 
062c			 
062c			; TODO change to find file id and use zero for free block 
062c			 
062c			storage_findnextid: 
062c			 
062c				; now locate first 0 page to mark as a free block 
062c			 
062c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062e			;	ld hl, STORE_BLOCK_PHY 
062e			 
062e					if DEBUG_FORTH_WORDS 
062e					DMARK "FNI" 
062e f5				push af  
062f 3a 43 06			ld a, (.dmark)  
0632 32 6e fb			ld (debug_mark),a  
0635 3a 44 06			ld a, (.dmark+1)  
0638 32 6f fb			ld (debug_mark+1),a  
063b 3a 45 06			ld a, (.dmark+2)  
063e 32 70 fb			ld (debug_mark+2),a  
0641 18 03			jr .pastdmark  
0643 ..			.dmark: db "FNI"  
0646 f1			.pastdmark: pop af  
0647			endm  
# End of macro DMARK
0647						CALLMONITOR 
0647 cd 6a 17			call break_point_state  
064a				endm  
# End of macro CALLMONITOR
064a					endif 
064a			.ff1:   	 
064a e5					push hl 
064b c5					push bc 
064c d5					push de 
064d cd 87 02				call se_readbyte 
0650 5f					ld e,a 
0651 23					inc hl 
0652 cd 87 02				call se_readbyte 
0655 57					ld d, a 
0656 e1					pop hl 
0657 e5					push hl 
0658 cd 39 0d				call cmp16 
065b 28 49				jr z, .fffound 
065d			 
065d d1					pop de 
065e c1					pop bc 
065f e1					pop hl 
0660			 
0660					; is found? 
0660					;cp e 
0660					;ret z 
0660			 
0660 3e 40				ld a, STORE_BLOCK_PHY 
0662 cd 1b 0d				call addatohl 
0665 10 e3				djnz .ff1 
0667			 
0667 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0669			.ff2:   	 
0669			 
0669 e5					push hl 
066a c5					push bc 
066b d5					push de 
066c cd 87 02				call se_readbyte 
066f 5f					ld e,a 
0670 23					inc hl 
0671 cd 87 02				call se_readbyte 
0674 57					ld d, a 
0675			 
0675 e1					pop hl 
0676 e5					push hl 
0677 cd 39 0d				call cmp16 
067a 28 2a				jr z, .fffound 
067c			 
067c d1					pop de 
067d c1					pop bc 
067e e1					pop hl 
067f					; is found? 
067f					;cp e 
067f					;ret z 
067f			 
067f 3e 40				ld a, STORE_BLOCK_PHY 
0681 cd 1b 0d				call addatohl 
0684 10 e3				djnz .ff2 
0686			 
0686			 
0686					if DEBUG_FORTH_WORDS 
0686					DMARK "FN-" 
0686 f5				push af  
0687 3a 9b 06			ld a, (.dmark)  
068a 32 6e fb			ld (debug_mark),a  
068d 3a 9c 06			ld a, (.dmark+1)  
0690 32 6f fb			ld (debug_mark+1),a  
0693 3a 9d 06			ld a, (.dmark+2)  
0696 32 70 fb			ld (debug_mark+2),a  
0699 18 03			jr .pastdmark  
069b ..			.dmark: db "FN-"  
069e f1			.pastdmark: pop af  
069f			endm  
# End of macro DMARK
069f					;	push af 
069f					;	ld a, 'n' 
069f					;	ld (debug_mark),a 
069f					;	pop af 
069f						CALLMONITOR 
069f cd 6a 17			call break_point_state  
06a2				endm  
# End of macro CALLMONITOR
06a2					endif 
06a2				; no free marks! 
06a2 21 00 00				ld hl, 0 
06a5 c9				ret 
06a6			.fffound: 
06a6				 
06a6			 
06a6 d1					pop de 
06a7 c1					pop bc 
06a8 e1					pop hl 
06a9					if DEBUG_FORTH_WORDS 
06a9					DMARK "FNF" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 6e fb			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 6f fb			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 70 fb			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "FNF"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2					;	push af 
06c2					;	ld a, 'n' 
06c2					;	ld (debug_mark),a 
06c2					;	pop af 
06c2						CALLMONITOR 
06c2 cd 6a 17			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5					endif 
06c5 c9				ret 
06c6			 
06c6			 
06c6			 
06c6			; Free Space 
06c6			; ---------- 
06c6			; 
06c6			; With current bank 
06c6			; 
06c6			; Set block count to zero 
06c6			; Starting with first logical block 
06c6			;      Find free block  
06c6			;      If block id given, increment block count 
06c6			; 
06c6			;  
06c6			 
06c6			 
06c6			; hl contains count of free blocks 
06c6			 
06c6			storage_freeblocks: 
06c6			 
06c6				; now locate first 0 page to mark as a free block 
06c6			 
06c6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c8 21 40 00			ld hl, STORE_BLOCK_PHY 
06cb 11 00 00			ld de, 0 
06ce			 
06ce			.fb1:   	 
06ce e5					push hl 
06cf c5					push bc 
06d0 d5					push de 
06d1 cd 87 02				call se_readbyte 
06d4 d1					pop de 
06d5 c1					pop bc 
06d6 e1					pop hl 
06d7			 
06d7					; is free? 
06d7 fe 00				cp 0 
06d9 20 01				jr nz, .ff1cont 
06db 13					inc de 
06dc			 
06dc			.ff1cont: 
06dc			 
06dc			 
06dc 3e 40				ld a, STORE_BLOCK_PHY 
06de cd 1b 0d				call addatohl 
06e1 10 eb				djnz .fb1 
06e3			 
06e3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e5			.fb2:   	 
06e5 e5					push hl 
06e6 c5					push bc 
06e7 d5					push de 
06e8 cd 87 02				call se_readbyte 
06eb d1					pop de 
06ec c1					pop bc 
06ed e1					pop hl 
06ee			 
06ee					; is free? 
06ee fe 00				cp 0 
06f0 20 01				jr nz, .ff2cont 
06f2 13					inc de 
06f3			 
06f3			.ff2cont: 
06f3			 
06f3 3e 40				ld a, STORE_BLOCK_PHY 
06f5 cd 1b 0d				call addatohl 
06f8 10 eb				djnz .fb2 
06fa			 
06fa eb				ex de, hl 
06fb c9				ret 
06fc			 
06fc			; Get File ID 
06fc			; ----------- 
06fc			; 
06fc			; With current bank 
06fc			;  
06fc			; Load Block 0 Config 
06fc			; Get max file id number 
06fc			; For each logical block 
06fc			;    Read block file id 
06fc			;      If first block of file and dont have file id 
06fc			;         if file get id and exit 
06fc			 
06fc			 
06fc			 
06fc			 
06fc			; Create File 
06fc			; ----------- 
06fc			; 
06fc			; With current bank  
06fc			; Load Block 0 Config 
06fc			; Get max file id number 
06fc			; Increment file id number 
06fc			; Save Config 
06fc			; Find free block 
06fc			; Set buffer with file name and file id 
06fc			; Write buffer to free block  
06fc			 
06fc			 
06fc			; hl point to file name 
06fc			; hl returns file id 
06fc			 
06fc			; file format: 
06fc			; byte 0 - file id 
06fc			; byte 1 - extent number 
06fc			; byte 2-> data 
06fc			 
06fc			; format for extent number 0: 
06fc			; 
06fc			; byte 0 - file id 
06fc			; byte 1 - extent 0 
06fc			; byte 2 - extent count 
06fc			; byte 3 -> file name and meta data 
06fc			 
06fc			 
06fc			storage_create: 
06fc				if DEBUG_STORESE 
06fc					DMARK "SCR" 
06fc f5				push af  
06fd 3a 11 07			ld a, (.dmark)  
0700 32 6e fb			ld (debug_mark),a  
0703 3a 12 07			ld a, (.dmark+1)  
0706 32 6f fb			ld (debug_mark+1),a  
0709 3a 13 07			ld a, (.dmark+2)  
070c 32 70 fb			ld (debug_mark+2),a  
070f 18 03			jr .pastdmark  
0711 ..			.dmark: db "SCR"  
0714 f1			.pastdmark: pop af  
0715			endm  
# End of macro DMARK
0715					CALLMONITOR 
0715 cd 6a 17			call break_point_state  
0718				endm  
# End of macro CALLMONITOR
0718				endif 
0718			 
0718 e5				push hl		; save file name pointer 
0719			 
0719 cd b8 03			call storage_get_block_0 
071c			 
071c 3a 59 f8			ld a,(store_page)	; get current file id 
071f 3c				inc a 
0720 32 59 f8			ld (store_page),a 
0723				 
0723 32 52 f8			ld (store_tmpid),a			; save id 
0726			 
0726 21 00 00			ld hl, 0 
0729 11 59 f8			ld de, store_page 
072c				if DEBUG_STORESE 
072c					DMARK "SCw" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fb			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fb			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fb			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "SCw"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745					CALLMONITOR 
0745 cd 6a 17			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748				endif 
0748 cd 6c 03			call storage_write_block	 ; save update 
074b			 
074b				if DEBUG_STORESE 
074b 11 59 f8				ld de, store_page 
074e					DMARK "SCC" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 6e fb			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 6f fb			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 70 fb			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCC"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					CALLMONITOR 
0767 cd 6a 17			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a				;  
076a				 
076a 21 40 00			ld hl, STORE_BLOCK_PHY 
076d 11 00 00			ld de, 0 
0770 cd 2c 06			call storage_findnextid 
0773			 
0773 22 43 f8			ld (store_tmppageid), hl    ; save page to use  
0776			 
0776				; TODO detect 0 = no spare blocks 
0776			 
0776				; hl now contains the free page to use for the file header page 
0776			 
0776				if DEBUG_STORESE 
0776				DMARK "SCF" 
0776 f5				push af  
0777 3a 8b 07			ld a, (.dmark)  
077a 32 6e fb			ld (debug_mark),a  
077d 3a 8c 07			ld a, (.dmark+1)  
0780 32 6f fb			ld (debug_mark+1),a  
0783 3a 8d 07			ld a, (.dmark+2)  
0786 32 70 fb			ld (debug_mark+2),a  
0789 18 03			jr .pastdmark  
078b ..			.dmark: db "SCF"  
078e f1			.pastdmark: pop af  
078f			endm  
# End of macro DMARK
078f					CALLMONITOR 
078f cd 6a 17			call break_point_state  
0792				endm  
# End of macro CALLMONITOR
0792				endif 
0792			 
0792 22 43 f8			ld (store_tmppageid), hl 
0795				 
0795 3a 52 f8			ld a,(store_tmpid)    ; get file id 
0798			;	ld a, (store_filecache)			; save to cache 
0798			 
0798 32 59 f8			ld (store_page),a    ; set page id 
079b 3e 00			ld a, 0			 ; extent 0 is file header 
079d 32 5a f8			ld (store_page+1), a   ; set file extent 
07a0			 
07a0 32 5b f8			ld (store_page+2), a   ; extent count for the file 
07a3			 
07a3			;	inc hl 		; init block 0 of file 
07a3			;	inc hl   		; skip file and extent id 
07a3			 ;       ld a, 0 
07a3			;	ld (hl),a 
07a3			;	ld a, (store_filecache+1)  	; save to cache 
07a3			 
07a3			;	inc hl    ; file name 
07a3				 
07a3				 
07a3 11 5c f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07a6				if DEBUG_STORESE 
07a6					DMARK "SCc" 
07a6 f5				push af  
07a7 3a bb 07			ld a, (.dmark)  
07aa 32 6e fb			ld (debug_mark),a  
07ad 3a bc 07			ld a, (.dmark+1)  
07b0 32 6f fb			ld (debug_mark+1),a  
07b3 3a bd 07			ld a, (.dmark+2)  
07b6 32 70 fb			ld (debug_mark+2),a  
07b9 18 03			jr .pastdmark  
07bb ..			.dmark: db "SCc"  
07be f1			.pastdmark: pop af  
07bf			endm  
# End of macro DMARK
07bf					CALLMONITOR 
07bf cd 6a 17			call break_point_state  
07c2				endm  
# End of macro CALLMONITOR
07c2				endif 
07c2 e1				pop hl    ; get zero term string 
07c3 e5				push hl 
07c4 3e 00			ld a, 0 
07c6 cd 84 11			call strlent 
07c9 23				inc hl   ; cover zero term 
07ca 06 00			ld b,0 
07cc 4d				ld c,l 
07cd e1				pop hl 
07ce				;ex de, hl 
07ce				if DEBUG_STORESE 
07ce					DMARK "SCa" 
07ce f5				push af  
07cf 3a e3 07			ld a, (.dmark)  
07d2 32 6e fb			ld (debug_mark),a  
07d5 3a e4 07			ld a, (.dmark+1)  
07d8 32 6f fb			ld (debug_mark+1),a  
07db 3a e5 07			ld a, (.dmark+2)  
07de 32 70 fb			ld (debug_mark+2),a  
07e1 18 03			jr .pastdmark  
07e3 ..			.dmark: db "SCa"  
07e6 f1			.pastdmark: pop af  
07e7			endm  
# End of macro DMARK
07e7					;push af 
07e7					;ld a, 'a' 
07e7					;ld (debug_mark),a 
07e7					;pop af 
07e7					CALLMONITOR 
07e7 cd 6a 17			call break_point_state  
07ea				endm  
# End of macro CALLMONITOR
07ea				endif 
07ea ed b0			ldir    ; copy zero term string 
07ec				if DEBUG_STORESE 
07ec					DMARK "SCA" 
07ec f5				push af  
07ed 3a 01 08			ld a, (.dmark)  
07f0 32 6e fb			ld (debug_mark),a  
07f3 3a 02 08			ld a, (.dmark+1)  
07f6 32 6f fb			ld (debug_mark+1),a  
07f9 3a 03 08			ld a, (.dmark+2)  
07fc 32 70 fb			ld (debug_mark+2),a  
07ff 18 03			jr .pastdmark  
0801 ..			.dmark: db "SCA"  
0804 f1			.pastdmark: pop af  
0805			endm  
# End of macro DMARK
0805					CALLMONITOR 
0805 cd 6a 17			call break_point_state  
0808				endm  
# End of macro CALLMONITOR
0808				endif 
0808			 
0808				; write file header page 
0808			 
0808 2a 43 f8			ld hl,(store_tmppageid) 
080b 11 59 f8			ld de, store_page 
080e				if DEBUG_STORESE 
080e					DMARK "SCb" 
080e f5				push af  
080f 3a 23 08			ld a, (.dmark)  
0812 32 6e fb			ld (debug_mark),a  
0815 3a 24 08			ld a, (.dmark+1)  
0818 32 6f fb			ld (debug_mark+1),a  
081b 3a 25 08			ld a, (.dmark+2)  
081e 32 70 fb			ld (debug_mark+2),a  
0821 18 03			jr .pastdmark  
0823 ..			.dmark: db "SCb"  
0826 f1			.pastdmark: pop af  
0827			endm  
# End of macro DMARK
0827					;push af 
0827					;ld a, 'b' 
0827					;ld (debug_mark),a 
0827					;pop af 
0827					CALLMONITOR 
0827 cd 6a 17			call break_point_state  
082a				endm  
# End of macro CALLMONITOR
082a				endif 
082a cd 6c 03			call storage_write_block 
082d			 
082d 3a 52 f8			ld a, (store_tmpid) 
0830 6f				ld l, a 
0831 26 00			ld h,0 
0833				if DEBUG_STORESE 
0833					DMARK "SCz" 
0833 f5				push af  
0834 3a 48 08			ld a, (.dmark)  
0837 32 6e fb			ld (debug_mark),a  
083a 3a 49 08			ld a, (.dmark+1)  
083d 32 6f fb			ld (debug_mark+1),a  
0840 3a 4a 08			ld a, (.dmark+2)  
0843 32 70 fb			ld (debug_mark+2),a  
0846 18 03			jr .pastdmark  
0848 ..			.dmark: db "SCz"  
084b f1			.pastdmark: pop af  
084c			endm  
# End of macro DMARK
084c					CALLMONITOR 
084c cd 6a 17			call break_point_state  
084f				endm  
# End of macro CALLMONITOR
084f				endif 
084f c9				ret 
0850				 
0850			 
0850			 
0850			; 
0850			; Read File 
0850			; 
0850			; h - file id to locate 
0850			; l - extent to locate 
0850			; de - pointer to string to read into 
0850			; 
0850			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0850			 
0850			.sr_fail: 
0850 d1				pop de 
0851 c9				ret 
0852			 
0852			storage_read: 
0852 d5				push de 
0853			 
0853			; TODO BUG the above push is it popped before the RET Z? 
0853			 
0853			; TODO how to handle multiple part blocks 
0853			 
0853				; locate file extent to read 
0853			 
0853 5c				ld e, h 
0854 55				ld d, l 
0855 21 40 00			ld hl, STORE_BLOCK_PHY 
0858				if DEBUG_STORESE 
0858					DMARK "SRE" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6e fb			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6f fb			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 70 fb			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "SRE"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6a 17			call break_point_state  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874 cd 2c 06			call storage_findnextid 
0877			 
0877				if DEBUG_STORESE 
0877					DMARK "SRf" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 6e fb			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 6f fb			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 70 fb			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SRf"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd 6a 17			call break_point_state  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893 cd 44 0d			call ishlzero 
0896			;	ld a, l 
0896			;	add h 
0896			;	cp 0 
0896 28 b8			jr z,.sr_fail			; block not found so EOF 
0898			 
0898				; hl contains page number to load 
0898 d1				pop de   ; get storage 
0899 d5				push de 
089a				if DEBUG_STORESE 
089a					DMARK "SRg" 
089a f5				push af  
089b 3a af 08			ld a, (.dmark)  
089e 32 6e fb			ld (debug_mark),a  
08a1 3a b0 08			ld a, (.dmark+1)  
08a4 32 6f fb			ld (debug_mark+1),a  
08a7 3a b1 08			ld a, (.dmark+2)  
08aa 32 70 fb			ld (debug_mark+2),a  
08ad 18 03			jr .pastdmark  
08af ..			.dmark: db "SRg"  
08b2 f1			.pastdmark: pop af  
08b3			endm  
# End of macro DMARK
08b3					CALLMONITOR 
08b3 cd 6a 17			call break_point_state  
08b6				endm  
# End of macro CALLMONITOR
08b6				endif 
08b6 cd 07 03			call storage_read_block 
08b9			 
08b9			 
08b9			; TODO if block has no zeros then need to read next block  
08b9			 
08b9			 
08b9					 
08b9 e1				pop hl 		 ; return start of data to show as not EOF 
08ba 23				inc hl   ; past file id 
08bb 23				inc hl   ; past ext 
08bc				if DEBUG_STORESE 
08bc					DMARK "SRe" 
08bc f5				push af  
08bd 3a d1 08			ld a, (.dmark)  
08c0 32 6e fb			ld (debug_mark),a  
08c3 3a d2 08			ld a, (.dmark+1)  
08c6 32 6f fb			ld (debug_mark+1),a  
08c9 3a d3 08			ld a, (.dmark+2)  
08cc 32 70 fb			ld (debug_mark+2),a  
08cf 18 03			jr .pastdmark  
08d1 ..			.dmark: db "SRe"  
08d4 f1			.pastdmark: pop af  
08d5			endm  
# End of macro DMARK
08d5					CALLMONITOR 
08d5 cd 6a 17			call break_point_state  
08d8				endm  
# End of macro CALLMONITOR
08d8				endif 
08d8 c9					ret 
08d9			 
08d9			 
08d9			 
08d9			; 
08d9			; Append File 
08d9			; 
08d9			; hl - file id to locate 
08d9			; de - pointer to (multi block) string to write 
08d9			 
08d9			.sa_notfound: 
08d9 d1				pop de 
08da c9				ret 
08db			 
08db			 
08db			storage_append: 
08db				; hl -  file id to append to 
08db				; de - string to append 
08db			 
08db d5				push de 
08dc				 
08dc				if DEBUG_STORESE 
08dc					DMARK "AP1" 
08dc f5				push af  
08dd 3a f1 08			ld a, (.dmark)  
08e0 32 6e fb			ld (debug_mark),a  
08e3 3a f2 08			ld a, (.dmark+1)  
08e6 32 6f fb			ld (debug_mark+1),a  
08e9 3a f3 08			ld a, (.dmark+2)  
08ec 32 70 fb			ld (debug_mark+2),a  
08ef 18 03			jr .pastdmark  
08f1 ..			.dmark: db "AP1"  
08f4 f1			.pastdmark: pop af  
08f5			endm  
# End of macro DMARK
08f5					CALLMONITOR 
08f5 cd 6a 17			call break_point_state  
08f8				endm  
# End of macro CALLMONITOR
08f8				endif 
08f8			 
08f8 7d				ld a, l 
08f9 32 52 f8			ld (store_tmpid), a 
08fc			 
08fc				; get file header  
08fc			 
08fc 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fe 3a 52 f8			ld a, (store_tmpid) 
0901 5f				ld e, a 
0902			 
0902 21 40 00				ld hl, STORE_BLOCK_PHY 
0905 cd 2c 06				call storage_findnextid 
0908			 
0908 cd 44 0d			call ishlzero 
090b 28 cc			jr z, .sa_notfound 
090d			 
090d 22 43 f8			ld (store_tmppageid), hl 
0910			 
0910				; TODO handle file id not found 
0910			 
0910				if DEBUG_STORESE 
0910					DMARK "AP2" 
0910 f5				push af  
0911 3a 25 09			ld a, (.dmark)  
0914 32 6e fb			ld (debug_mark),a  
0917 3a 26 09			ld a, (.dmark+1)  
091a 32 6f fb			ld (debug_mark+1),a  
091d 3a 27 09			ld a, (.dmark+2)  
0920 32 70 fb			ld (debug_mark+2),a  
0923 18 03			jr .pastdmark  
0925 ..			.dmark: db "AP2"  
0928 f1			.pastdmark: pop af  
0929			endm  
# End of macro DMARK
0929					CALLMONITOR 
0929 cd 6a 17			call break_point_state  
092c				endm  
# End of macro CALLMONITOR
092c				endif 
092c			 
092c				; update file extent count 
092c			 
092c 11 59 f8			ld de, store_page 
092f			 
092f cd 07 03			call storage_read_block 
0932			 
0932				if DEBUG_STORESE 
0932					DMARK "AP3" 
0932 f5				push af  
0933 3a 47 09			ld a, (.dmark)  
0936 32 6e fb			ld (debug_mark),a  
0939 3a 48 09			ld a, (.dmark+1)  
093c 32 6f fb			ld (debug_mark+1),a  
093f 3a 49 09			ld a, (.dmark+2)  
0942 32 70 fb			ld (debug_mark+2),a  
0945 18 03			jr .pastdmark  
0947 ..			.dmark: db "AP3"  
094a f1			.pastdmark: pop af  
094b			endm  
# End of macro DMARK
094b					CALLMONITOR 
094b cd 6a 17			call break_point_state  
094e				endm  
# End of macro CALLMONITOR
094e				endif 
094e			;	ld (store_tmppageid), hl 
094e			 
094e 3a 5b f8			ld a, (store_page+2) 
0951 3c				inc a 
0952 32 5b f8			ld (store_page+2), a 
0955 32 51 f8			ld (store_tmpext), a 
0958				 
0958				if DEBUG_STORESE 
0958					DMARK "AP3" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 6e fb			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 6f fb			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 70 fb			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "AP3"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd 6a 17			call break_point_state  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974 2a 43 f8			ld hl, (store_tmppageid) 
0977 11 59 f8			ld de, store_page 
097a cd 6c 03			call storage_write_block 
097d			 
097d				; find free block 
097d			 
097d 11 00 00			ld de, 0			 ; file extent to locate 
0980			 
0980 21 40 00				ld hl, STORE_BLOCK_PHY 
0983 cd 2c 06				call storage_findnextid 
0986 cd 44 0d			call ishlzero 
0989 ca d9 08			jp z, .sa_notfound 
098c			 
098c					; TODO handle no space left 
098c					 
098c 22 43 f8				ld (store_tmppageid), hl 
098f			 
098f				if DEBUG_STORESE 
098f					DMARK "AP4" 
098f f5				push af  
0990 3a a4 09			ld a, (.dmark)  
0993 32 6e fb			ld (debug_mark),a  
0996 3a a5 09			ld a, (.dmark+1)  
0999 32 6f fb			ld (debug_mark+1),a  
099c 3a a6 09			ld a, (.dmark+2)  
099f 32 70 fb			ld (debug_mark+2),a  
09a2 18 03			jr .pastdmark  
09a4 ..			.dmark: db "AP4"  
09a7 f1			.pastdmark: pop af  
09a8			endm  
# End of macro DMARK
09a8					CALLMONITOR 
09a8 cd 6a 17			call break_point_state  
09ab				endm  
# End of macro CALLMONITOR
09ab				endif 
09ab					; init the buffer with zeros so we can id if the buffer is full or not 
09ab			 
09ab e5					push hl 
09ac c5					push bc 
09ad			 
09ad 21 59 f8				ld hl, store_page 
09b0 06 40				ld b, STORE_BLOCK_PHY 
09b2 3e 00				ld a, 0 
09b4 77			.zeroblock:	ld (hl), a 
09b5 23					inc hl 
09b6 10 fc				djnz .zeroblock 
09b8			 
09b8 c1					pop bc 
09b9 e1					pop hl 
09ba			 
09ba					; construct block 
09ba			 
09ba 3a 52 f8				ld a, (store_tmpid) 
09bd 32 59 f8				ld (store_page), a   ; file id 
09c0 3a 51 f8				ld a, (store_tmpext)   ; extent for this block 
09c3 32 5a f8				ld (store_page+1), a 
09c6			 
09c6 e1					pop hl    ; get string to write 
09c7 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09c9 11 5b f8				ld de, store_page+2 
09cc			 
09cc				if DEBUG_STORESE 
09cc					DMARK "AP5" 
09cc f5				push af  
09cd 3a e1 09			ld a, (.dmark)  
09d0 32 6e fb			ld (debug_mark),a  
09d3 3a e2 09			ld a, (.dmark+1)  
09d6 32 6f fb			ld (debug_mark+1),a  
09d9 3a e3 09			ld a, (.dmark+2)  
09dc 32 70 fb			ld (debug_mark+2),a  
09df 18 03			jr .pastdmark  
09e1 ..			.dmark: db "AP5"  
09e4 f1			.pastdmark: pop af  
09e5			endm  
# End of macro DMARK
09e5					CALLMONITOR 
09e5 cd 6a 17			call break_point_state  
09e8				endm  
# End of macro CALLMONITOR
09e8				endif 
09e8			 
09e8			 
09e8			 
09e8					; fill buffer with data until end of string or full block 
09e8			 
09e8 7e			.appd:		ld a, (hl) 
09e9 12					ld (de), a 
09ea fe 00				cp 0 
09ec 28 04				jr z, .appdone 
09ee 23					inc hl 
09ef 13					inc de 
09f0 10 f6				djnz .appd 
09f2			 
09f2 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09f3 f5					push af   		; save last byte dumped 
09f4			 
09f4			 
09f4 2a 43 f8			ld hl, (store_tmppageid) 
09f7 11 59 f8			ld de, store_page 
09fa				if DEBUG_STORESE 
09fa					DMARK "AP6" 
09fa f5				push af  
09fb 3a 0f 0a			ld a, (.dmark)  
09fe 32 6e fb			ld (debug_mark),a  
0a01 3a 10 0a			ld a, (.dmark+1)  
0a04 32 6f fb			ld (debug_mark+1),a  
0a07 3a 11 0a			ld a, (.dmark+2)  
0a0a 32 70 fb			ld (debug_mark+2),a  
0a0d 18 03			jr .pastdmark  
0a0f ..			.dmark: db "AP6"  
0a12 f1			.pastdmark: pop af  
0a13			endm  
# End of macro DMARK
0a13					CALLMONITOR 
0a13 cd 6a 17			call break_point_state  
0a16				endm  
# End of macro CALLMONITOR
0a16				endif 
0a16 cd 6c 03				call storage_write_block 
0a19			 
0a19			 
0a19				; was that a full block of data written? 
0a19				; any more to write out? 
0a19			 
0a19				; if yes then set vars and jump to start of function again 
0a19			 
0a19 f1					pop af 
0a1a d1					pop de 
0a1b			 
0a1b fe 00				cp 0		 ; no, string was fully written 
0a1d c8					ret z 
0a1e			 
0a1e					; setup vars for next cycle 
0a1e			 
0a1e 3a 52 f8				ld a, (store_tmpid) 
0a21 6f					ld l, a 
0a22 26 00				ld h, 0 
0a24			 
0a24 c3 db 08			 	jp storage_append	 ; yes, need to write out some more 
0a27			 
0a27			 
0a27			 
0a27			 
0a27			 
0a27			 
0a27			 
0a27			if DEBUG_STORECF 
0a27			storageput:	 
0a27					ret 
0a27			storageread: 
0a27					ld hl, store_page 
0a27					ld b, 200 
0a27					ld a,0 
0a27			.src:		ld (hl),a 
0a27					inc hl 
0a27					djnz .src 
0a27					 
0a27			 
0a27					ld de, 0 
0a27					ld bc, 1 
0a27					ld hl, store_page 
0a27					call cfRead 
0a27			 
0a27				call cfGetError 
0a27				ld hl,scratch 
0a27				call hexout 
0a27				ld hl, scratch+2 
0a27				ld a, 0 
0a27				ld (hl),a 
0a27				ld de, scratch 
0a27				ld a,display_row_1 
0a27				call str_at_display 
0a27				call update_display 
0a27			 
0a27					ld hl, store_page 
0a27					ld (os_cur_ptr),hl 
0a27			 
0a27					ret 
0a27			endif 
0a27			 
0a27			 
0a27			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a27			 
0a27			storage_clear_page: 
0a27 e5				push hl 
0a28 d5				push de 
0a29 c5				push bc 
0a2a 21 59 f8			ld hl, store_page 
0a2d 3e 00			ld a, 0 
0a2f 77				ld (hl), a 
0a30			 
0a30 11 5a f8			ld de, store_page+1 
0a33 01 40 00			ld bc, STORE_BLOCK_PHY 
0a36			 
0a36 ed b0			ldir 
0a38				 
0a38 c1				pop bc 
0a39 d1				pop de 
0a3a e1				pop hl 
0a3b c9				ret 
0a3c			 
0a3c			; eof 
# End of file firmware_storage.asm
0a3c			  
0a3c			; support routines for above hardware abstraction layer  
0a3c			  
0a3c			include "firmware_general.asm"        ; general support functions  
0a3c			 
0a3c			; word look up 
0a3c			 
0a3c			; in 
0a3c			; a is the index 
0a3c			; hl is pointer start of array 
0a3c			; 
0a3c			; returns 
0a3c			; hl to the word 
0a3c			; 
0a3c			 
0a3c			table_lookup:  
0a3c d5					push de 
0a3d eb					ex de, hl 
0a3e			 
0a3e 6f					ld l, a 
0a3f 26 00				ld h, 0 
0a41 29					add hl, hl 
0a42 19					add hl, de 
0a43 7e					ld a, (hl) 
0a44 23					inc hl 
0a45 66					ld h,(hl) 
0a46 6f					ld l, a 
0a47			 
0a47 d1					pop de 
0a48 c9					ret 
0a49			 
0a49			; Delay loops 
0a49			 
0a49			 
0a49			 
0a49			aDelayInMS: 
0a49 c5				push bc 
0a4a 47				ld b,a 
0a4b			msdelay: 
0a4b c5				push bc 
0a4c				 
0a4c			 
0a4c 01 41 00			ld bc,041h 
0a4f cd 67 0a			call delayloop 
0a52 c1				pop bc 
0a53 05				dec b 
0a54 20 f5			jr nz,msdelay 
0a56			 
0a56			;if CPU_CLOCK_8MHZ 
0a56			;msdelay8: 
0a56			;	push bc 
0a56			;	 
0a56			; 
0a56			;	ld bc,041h 
0a56			;	call delayloop 
0a56			;	pop bc 
0a56			;	dec b 
0a56			;	jr nz,msdelay8 
0a56			;endif 
0a56			 
0a56			 
0a56 c1				pop bc 
0a57 c9				ret 
0a58			 
0a58			 
0a58			delay250ms: 
0a58				;push de 
0a58 01 00 40			ld bc, 04000h 
0a5b c3 67 0a			jp delayloop 
0a5e			delay500ms: 
0a5e				;push de 
0a5e 01 00 80			ld bc, 08000h 
0a61 c3 67 0a			jp delayloop 
0a64			delay1s: 
0a64				;push bc 
0a64			   ; Clobbers A, d and e 
0a64 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a67			delayloop: 
0a67 c5			    push bc 
0a68			 
0a68			if BASE_CPM 
0a68				ld bc, CPM_DELAY_TUNE 
0a68			.cpmloop: 
0a68				push bc 
0a68			 
0a68			endif 
0a68			 
0a68			 
0a68			 
0a68			delayloopi: 
0a68			;	push bc 
0a68			;.dl: 
0a68 cb 47		    bit     0,a    	; 8 
0a6a cb 47		    bit     0,a    	; 8 
0a6c cb 47		    bit     0,a    	; 8 
0a6e e6 ff		    and     255  	; 7 
0a70 0b			    dec     bc      	; 6 
0a71 79			    ld      a,c     	; 4 
0a72 b0			    or      b     	; 4 
0a73 c2 68 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a76			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a76				;pop de 
0a76			;pop bc 
0a76			 
0a76			if BASE_CPM 
0a76				pop bc 
0a76				 
0a76			    dec     bc      	; 6 
0a76			    ld      a,c     	; 4 
0a76			    or      b     	; 4 
0a76			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a76				 
0a76			 
0a76			endif 
0a76			;if CPU_CLOCK_8MHZ 
0a76			;    pop bc 
0a76			;    push bc 
0a76			;.dl8: 
0a76			;    bit     0,a    	; 8 
0a76			;    bit     0,a    	; 8 
0a76			;    bit     0,a    	; 8 
0a76			;    and     255  	; 7 
0a76			;    dec     bc      	; 6 
0a76			;    ld      a,c     	; 4 
0a76			;    or      b     	; 4 
0a76			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a76			;endif 
0a76			 
0a76			;if CPU_CLOCK_10MHZ 
0a76			;    pop bc 
0a76			;    push bc 
0a76			;.dl8: 
0a76			;    bit     0,a    	; 8 
0a76			;    bit     0,a    	; 8 
0a76			;    bit     0,a    	; 8 
0a76			;    and     255  	; 7 
0a76			;    dec     bc      	; 6 
0a76			;    ld      a,c     	; 4 
0a76			;    or      b     	; 4 
0a76			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a76			;endif 
0a76 c1			    pop bc 
0a77			 
0a77 c9				ret 
0a78			 
0a78			 
0a78			 
0a78			; eof 
# End of file firmware_general.asm
0a78			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a78			; display routines that use the physical hardware abstraction layer 
0a78			 
0a78			 
0a78			; information window 
0a78			 
0a78			; pass hl with 1st string to display 
0a78			; pass de with 2nd string to display 
0a78			 
0a78			info_panel: 
0a78 e5				push hl 
0a79			 
0a79 2a cf f8			ld hl, (display_fb_active) 
0a7c e5				push hl    ; future de destination 
0a7d 21 b4 fa				ld hl, display_fb0 
0a80 22 cf f8				ld (display_fb_active), hl 
0a83			 
0a83			;	call clear_display 
0a83			 
0a83				if BASE_CPM 
0a83				ld a, '.' 
0a83				else 
0a83 3e a5			ld a, 165 
0a85				endif 
0a85 cd ec 0a			call fill_display 
0a88			 
0a88			 
0a88 3e 55			ld a, display_row_3 + 5 
0a8a cd fa 0a			call str_at_display 
0a8d			 
0a8d e1				pop hl 
0a8e d1				pop de 
0a8f			 
0a8f e5				push hl 
0a90			 
0a90			 
0a90 3e 2d			ld a, display_row_2 + 5 
0a92 cd fa 0a			call str_at_display 
0a95			 
0a95			 
0a95 cd 0a 0b			call update_display 
0a98 cd 72 1c			call next_page_prompt 
0a9b cd e7 0a			call clear_display 
0a9e			 
0a9e				 
0a9e 21 13 fa				ld hl, display_fb1 
0aa1 22 cf f8				ld (display_fb_active), hl 
0aa4 cd 0a 0b			call update_display 
0aa7			 
0aa7 e1				pop hl 
0aa8			 
0aa8 c9				ret 
0aa9			 
0aa9			 
0aa9			 
0aa9			 
0aa9			; TODO windowing? 
0aa9			 
0aa9			; TODO scroll line up 
0aa9			 
0aa9			scroll_up: 
0aa9			 
0aa9 e5				push hl 
0aaa d5				push de 
0aab c5				push bc 
0aac			 
0aac				; get frame buffer  
0aac			 
0aac 2a cf f8			ld hl, (display_fb_active) 
0aaf e5				push hl    ; future de destination 
0ab0			 
0ab0 11 28 00			ld  de, display_cols 
0ab3 19				add hl, de 
0ab4			 
0ab4 d1				pop de 
0ab5			 
0ab5				;ex de, hl 
0ab5 01 9f 00			ld bc, display_fb_len -1  
0ab8			;if DEBUG_FORTH_WORDS 
0ab8			;	DMARK "SCL" 
0ab8			;	CALLMONITOR 
0ab8			;endif	 
0ab8 ed b0			ldir 
0aba			 
0aba				; wipe bottom row 
0aba			 
0aba			 
0aba 2a cf f8			ld hl, (display_fb_active) 
0abd 11 a0 00			ld de, display_cols*display_rows 
0ac0 19				add hl, de 
0ac1 06 28			ld b, display_cols 
0ac3 3e 20			ld a, ' ' 
0ac5			.scwipe: 
0ac5 77				ld (hl), a 
0ac6 2b				dec hl 
0ac7 10 fc			djnz .scwipe 
0ac9			 
0ac9				;pop hl 
0ac9			 
0ac9 c1				pop bc 
0aca d1				pop de 
0acb e1				pop hl 
0acc			 
0acc c9				ret 
0acd			 
0acd			 
0acd			;scroll_upo: 
0acd			;	ld de, display_row_1 
0acd			 ;	ld hl, display_row_2 
0acd			;	ld bc, display_cols 
0acd			;	ldir 
0acd			;	ld de, display_row_2 
0acd			 ;	ld hl, display_row_3 
0acd			;	ld bc, display_cols 
0acd			;	ldir 
0acd			;	ld de, display_row_3 
0acd			 ;	ld hl, display_row_4 
0acd			;	ld bc, display_cols 
0acd			;	ldir 
0acd			 
0acd			; TODO clear row 4 
0acd			 
0acd			;	ret 
0acd			 
0acd				 
0acd			scroll_down: 
0acd			 
0acd e5				push hl 
0ace d5				push de 
0acf c5				push bc 
0ad0			 
0ad0				; get frame buffer  
0ad0			 
0ad0 2a cf f8			ld hl, (display_fb_active) 
0ad3			 
0ad3 11 9f 00			ld de, display_fb_len - 1 
0ad6 19				add hl, de 
0ad7			 
0ad7 e5			push hl    ; future de destination 
0ad8			 
0ad8 11 28 00			ld  de, display_cols 
0adb ed 52			sbc hl, de 
0add			 
0add			 
0add d1				pop de 
0ade			 
0ade			;	ex de, hl 
0ade 01 9f 00			ld bc, display_fb_len -1  
0ae1			 
0ae1			 
0ae1				 
0ae1			 
0ae1 ed b0			ldir 
0ae3			 
0ae3				; wipe bottom row 
0ae3			 
0ae3			 
0ae3			;	ld hl, (display_fb_active) 
0ae3			;;	ld de, display_cols*display_rows 
0ae3			;;	add hl, de 
0ae3			;	ld b, display_cols 
0ae3			;	ld a, ' ' 
0ae3			;.scwiped: 
0ae3			;	ld (hl), a 
0ae3			;	dec hl 
0ae3			;	djnz .scwiped 
0ae3			 
0ae3				;pop hl 
0ae3			 
0ae3 c1				pop bc 
0ae4 d1				pop de 
0ae5 e1				pop hl 
0ae6			 
0ae6 c9				ret 
0ae7			;scroll_down: 
0ae7			;	ld de, display_row_4 
0ae7			;	ld hl, display_row_3 
0ae7			;	ld bc, display_cols 
0ae7			;	ldir 
0ae7			;	ld de, display_row_3 
0ae7			; 	ld hl, display_row_2 
0ae7			;	ld bc, display_cols 
0ae7			;	ldir 
0ae7			;	ld de, display_row_2 
0ae7			;	ld hl, display_row_1 
0ae7			;	ld bc, display_cols 
0ae7			;	ldir 
0ae7			;;; TODO clear row 1 
0ae7			;	ret 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			; clear active frame buffer 
0ae7			 
0ae7			clear_display: 
0ae7 3e 20			ld a, ' ' 
0ae9 c3 ec 0a			jp fill_display 
0aec			 
0aec			; fill active frame buffer with a char in A 
0aec			 
0aec			fill_display: 
0aec 06 a0			ld b,display_fb_len 
0aee 2a cf f8			ld hl, (display_fb_active) 
0af1 77			.fd1:	ld (hl),a 
0af2 23				inc hl 
0af3 10 fc			djnz .fd1 
0af5 23				inc hl 
0af6 3e 00			ld a,0 
0af8 77				ld (hl),a 
0af9			 
0af9			 
0af9 c9				ret 
0afa			; Write string (DE) at pos (A) to active frame buffer 
0afa			 
0afa 2a cf f8		str_at_display:    ld hl,(display_fb_active) 
0afd 06 00					ld b,0 
0aff 4f					ld c,a 
0b00 09					add hl,bc 
0b01 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b02 b7			            OR   A              ;Null terminator? 
0b03 c8			            RET  Z              ;Yes, so finished 
0b04 77					ld (hl),a 
0b05 23				inc hl 
0b06 13			            INC  DE             ;Point to next character 
0b07 18 f8		            JR   .sad1     ;Repeat 
0b09 c9					ret 
0b0a			 
0b0a			; using current frame buffer write to physical display 
0b0a			 
0b0a			update_display: 
0b0a e5				push hl 
0b0b 2a cf f8			ld hl, (display_fb_active) 
0b0e cd 0c 66			call write_display 
0b11 e1				pop hl 
0b12 c9				ret 
0b13			 
0b13			; TODO scrolling 
0b13			 
0b13			 
0b13			; move cursor right one char 
0b13			cursor_right: 
0b13			 
0b13				; TODO shift right 
0b13				; TODO if beyond max col 
0b13				; TODO       cursor_next_line 
0b13			 
0b13 c9				ret 
0b14			 
0b14			 
0b14			cursor_next_line: 
0b14				; TODO first char 
0b14				; TODO line down 
0b14				; TODO if past last row 
0b14				; TODO    scroll up 
0b14			 
0b14 c9				ret 
0b15			 
0b15			cursor_left: 
0b15				; TODO shift left 
0b15				; TODO if beyond left  
0b15				; TODO     cursor prev line 
0b15				 
0b15 c9				ret 
0b16			 
0b16			cursor_prev_line: 
0b16				; TODO last char 
0b16				; TODO line up 
0b16				; TODO if past first row 
0b16				; TODO   scroll down 
0b16			 
0b16 c9				ret 
0b17			 
0b17			 
0b17			cout: 
0b17				; A - char 
0b17 c9				ret 
0b18			 
0b18			 
0b18			; Display a menu and allow item selection (optional toggle items) 
0b18			; 
0b18			; format: 
0b18			; hl pointer to word array with zero term for items 
0b18			; e.g.    db item1 
0b18			;         db .... 
0b18			;         db 0 
0b18			; 
0b18			; a = starting menu item  
0b18			; 
0b18			; de = pointer item toggle array   (todo) 
0b18			; 
0b18			; returns item selected in a 1-... 
0b18			; returns 0 if back button pressed 
0b18			; 
0b18			; NOTE: Uses system frame buffer to display 
0b18			; 
0b18			; LEFT, Q = go back 
0b18			; RIGHT, SPACE, CR = select 
0b18			; UP, A - Up 
0b18			; DOWN, Z - Down 
0b18			 
0b18			 
0b18			 
0b18			 
0b18			 
0b18			menu: 
0b18			 
0b18					; keep array pointer 
0b18			 
0b18 22 57 f8				ld (store_tmp1), hl 
0b1b 32 55 f8				ld (store_tmp2), a 
0b1e			 
0b1e					; check for key bounce 
0b1e			 
0b1e			if BASE_KEV 
0b1e			 
0b1e cd 57 69		.mbounce:	call cin 
0b21 fe 00				cp 0 
0b23 20 f9				jr nz, .mbounce 
0b25			endif 
0b25					; for ease use ex 
0b25			 
0b25					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b25 21 b4 fa				ld hl, display_fb0 
0b28 22 cf f8				ld (display_fb_active), hl 
0b2b			 
0b2b cd e7 0a		.mloop:		call clear_display 
0b2e cd 0a 0b				call update_display 
0b31			 
0b31					; draw selection id '>' at 1 
0b31			 
0b31					; init start of list display 
0b31			 
0b31 3e 05				ld a, 5 
0b33 32 53 f8				ld (store_tmp3), a   ; display row count 
0b36 3a 55 f8				ld a,( store_tmp2) 
0b39 32 56 f8				ld (store_tmp2+1), a   ; display item count 
0b3c			 
0b3c					 
0b3c			.mitem:	 
0b3c			 
0b3c			 
0b3c 3a 56 f8				ld a,(store_tmp2+1) 
0b3f 6f					ld l, a 
0b40 26 00				ld h, 0 
0b42 29					add hl, hl 
0b43 ed 5b 57 f8			ld de, (store_tmp1) 
0b47 19					add hl, de 
0b48 7e					ld a, (hl) 
0b49 23					inc hl 
0b4a 66					ld h,(hl) 
0b4b 6f					ld l, a 
0b4c			 
0b4c cd 44 0d				call ishlzero 
0b4f 28 1a				jr z, .mdone 
0b51			 
0b51 eb					ex de, hl 
0b52 3a 53 f8				ld a, (store_tmp3) 
0b55 cd fa 0a				call str_at_display 
0b58					 
0b58			 
0b58					; next item 
0b58 3a 56 f8				ld a, (store_tmp2+1) 
0b5b 3c					inc a 
0b5c 32 56 f8				ld (store_tmp2+1), a   ; display item count 
0b5f			 
0b5f			 		; next row 
0b5f			 
0b5f 3a 53 f8				ld a, (store_tmp3) 
0b62 c6 28				add display_cols 
0b64 32 53 f8				ld (store_tmp3), a 
0b67			 
0b67					; at end of screen? 
0b67			 
0b67 fe 10				cp display_rows*4 
0b69 20 d1				jr nz, .mitem 
0b6b			 
0b6b			 
0b6b			.mdone: 
0b6b cd 44 0d				call ishlzero 
0b6e 28 08				jr z, .nodn 
0b70			 
0b70 3e 78				ld a, display_row_4 
0b72 11 f1 0b				ld de, .mdown 
0b75 cd fa 0a				call str_at_display 
0b78			 
0b78					; draw options to fill the screens with active item on line 1 
0b78					; if current option is 2 or more then display ^ in top 
0b78			 
0b78 3a 55 f8		.nodn:		ld a, (store_tmp2) 
0b7b fe 00				cp 0 
0b7d 28 08				jr z, .noup 
0b7f			 
0b7f 3e 00				ld a, 0 
0b81 11 ef 0b				ld de, .mup 
0b84 cd fa 0a				call str_at_display 
0b87			 
0b87 3e 02		.noup:		ld a, 2 
0b89 11 ed 0b				ld de, .msel 
0b8c cd fa 0a				call str_at_display 
0b8f			 
0b8f					; if current option + 1 is not null then display V in bottom 
0b8f					; get key 
0b8f cd 0a 0b				call update_display 
0b92			 
0b92			 
0b92					; handle key 
0b92			 
0b92 cd 46 69				call cin_wait 
0b95			 
0b95 fe 05				cp KEY_UP 
0b97 28 2b				jr z, .mgoup 
0b99 fe 61				cp 'a' 
0b9b 28 27				jr z, .mgoup 
0b9d fe 0a				cp KEY_DOWN 
0b9f 28 32				jr z, .mgod 
0ba1 fe 7a				cp 'z' 
0ba3 28 2e				jr z, .mgod 
0ba5 fe 20				cp ' ' 
0ba7 28 34				jr z, .goend 
0ba9 fe 0c				cp KEY_RIGHT 
0bab 28 30				jr z, .goend 
0bad fe 0d				cp KEY_CR 
0baf 28 2c				jr z, .goend 
0bb1 fe 71				cp 'q' 
0bb3 28 0b				jr z, .goback 
0bb5			 
0bb5 fe 0b				cp KEY_LEFT 
0bb7 28 07				jr z, .goback 
0bb9 fe 08				cp KEY_BS 
0bbb 28 03				jr z, .goback 
0bbd c3 2b 0b				jp .mloop 
0bc0			 
0bc0			.goback: 
0bc0 3e 00			ld a, 0 
0bc2 18 1d			jr .goend2 
0bc4			 
0bc4				; move up one 
0bc4			.mgoup: 
0bc4 3a 55 f8				ld a, (store_tmp2) 
0bc7 fe 00				cp 0 
0bc9 ca 2b 0b				jp z, .mloop 
0bcc 3d					dec a 
0bcd 32 55 f8				ld (store_tmp2), a 
0bd0 c3 2b 0b				jp .mloop 
0bd3			 
0bd3				; move down one 
0bd3			.mgod: 
0bd3 3a 55 f8				ld a, (store_tmp2) 
0bd6 3c					inc a 
0bd7 32 55 f8				ld (store_tmp2), a 
0bda c3 2b 0b				jp .mloop 
0bdd			 
0bdd			 
0bdd			.goend: 
0bdd					; get selected item number 
0bdd			 
0bdd 3a 55 f8				ld a, (store_tmp2) 
0be0 3c					inc a 
0be1			 
0be1			.goend2: 
0be1 f5					push af 
0be2			 
0be2					; restore active fb 
0be2					; TODO BUG assumes fb1 
0be2			 
0be2 21 13 fa				ld hl, display_fb1 
0be5 22 cf f8				ld (display_fb_active), hl 
0be8			 
0be8					; restore main regs 
0be8			 
0be8			 
0be8 cd 0a 0b				call update_display 
0beb			 
0beb f1					pop af 
0bec			 
0bec c9				ret 
0bed			 
0bed .. 00		.msel:   db ">",0 
0bef .. 00		.mup:   db "^",0 
0bf1 .. 00		.mdown:   db "v",0 
0bf3			 
0bf3			 
0bf3			; eof 
0bf3			 
# End of file firmware_display.asm
0bf3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bf3			; random number generators 
0bf3			 
0bf3			 
0bf3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bf3			 
0bf3			 
0bf3			;-----> Generate a random number 
0bf3			; output a=answer 0<=a<=255 
0bf3			; all registers are preserved except: af 
0bf3			random: 
0bf3 e5			        push    hl 
0bf4 d5			        push    de 
0bf5 2a b1 f8		        ld      hl,(randData) 
0bf8 ed 5f		        ld      a,r 
0bfa 57			        ld      d,a 
0bfb 5e			        ld      e,(hl) 
0bfc 19			        add     hl,de 
0bfd 85			        add     a,l 
0bfe ac			        xor     h 
0bff 22 b1 f8		        ld      (randData),hl 
0c02 d1			        pop     de 
0c03 e1			        pop     hl 
0c04 c9			        ret 
0c05			 
0c05			 
0c05			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c05			 
0c05			 
0c05			 
0c05			;------LFSR------ 
0c05			;James Montelongo 
0c05			;optimized by Spencer Putt 
0c05			;out: 
0c05			; a = 8 bit random number 
0c05			RandLFSR: 
0c05 21 b7 f8		        ld hl,LFSRSeed+4 
0c08 5e			        ld e,(hl) 
0c09 23			        inc hl 
0c0a 56			        ld d,(hl) 
0c0b 23			        inc hl 
0c0c 4e			        ld c,(hl) 
0c0d 23			        inc hl 
0c0e 7e			        ld a,(hl) 
0c0f 47			        ld b,a 
0c10 cb 13		        rl e  
0c12 cb 12			rl d 
0c14 cb 11		        rl c  
0c16 17				rla 
0c17 cb 13		        rl e  
0c19 cb 12			rl d 
0c1b cb 11		        rl c  
0c1d 17				rla 
0c1e cb 13		        rl e  
0c20 cb 12			rl d 
0c22 cb 11		        rl c  
0c24 17				rla 
0c25 67			        ld h,a 
0c26 cb 13		        rl e  
0c28 cb 12			rl d 
0c2a cb 11		        rl c  
0c2c 17				rla 
0c2d a8			        xor b 
0c2e cb 13		        rl e  
0c30 cb 12			rl d 
0c32 ac			        xor h 
0c33 a9			        xor c 
0c34 aa			        xor d 
0c35 21 b9 f8		        ld hl,LFSRSeed+6 
0c38 11 ba f8		        ld de,LFSRSeed+7 
0c3b 01 07 00		        ld bc,7 
0c3e ed b8		        lddr 
0c40 12			        ld (de),a 
0c41 c9			        ret 
0c42			 
0c42			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c42			 
0c42			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c42			 
0c42			 
0c42			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c42			 
0c42			prng16: 
0c42			;Inputs: 
0c42			;   (seed1) contains a 16-bit seed value 
0c42			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c42			;Outputs: 
0c42			;   HL is the result 
0c42			;   BC is the result of the LCG, so not that great of quality 
0c42			;   DE is preserved 
0c42			;Destroys: 
0c42			;   AF 
0c42			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c42			;160cc 
0c42			;26 bytes 
0c42 2a ab f8		    ld hl,(seed1) 
0c45 44			    ld b,h 
0c46 4d			    ld c,l 
0c47 29			    add hl,hl 
0c48 29			    add hl,hl 
0c49 2c			    inc l 
0c4a 09			    add hl,bc 
0c4b 22 ab f8		    ld (seed1),hl 
0c4e 2a a9 f8		    ld hl,(seed2) 
0c51 29			    add hl,hl 
0c52 9f			    sbc a,a 
0c53 e6 2d		    and %00101101 
0c55 ad			    xor l 
0c56 6f			    ld l,a 
0c57 22 a9 f8		    ld (seed2),hl 
0c5a 09			    add hl,bc 
0c5b c9			    ret 
0c5c			 
0c5c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c5c			 
0c5c			rand32: 
0c5c			;Inputs: 
0c5c			;   (seed1_0) holds the lower 16 bits of the first seed 
0c5c			;   (seed1_1) holds the upper 16 bits of the first seed 
0c5c			;   (seed2_0) holds the lower 16 bits of the second seed 
0c5c			;   (seed2_1) holds the upper 16 bits of the second seed 
0c5c			;   **NOTE: seed2 must be non-zero 
0c5c			;Outputs: 
0c5c			;   HL is the result 
0c5c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c5c			;Destroys: 
0c5c			;   AF 
0c5c			;Tested and passes all CAcert tests 
0c5c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c5c			;it has a period of 18,446,744,069,414,584,320 
0c5c			;roughly 18.4 quintillion. 
0c5c			;LFSR taps: 0,2,6,7  = 11000101 
0c5c			;291cc 
0c5c			;seed1_0=$+1 
0c5c			;    ld hl,12345 
0c5c			;seed1_1=$+1 
0c5c			;    ld de,6789 
0c5c			;    ld b,h 
0c5c			;    ld c,l 
0c5c			;    add hl,hl \ rl e \ rl d 
0c5c			;    add hl,hl \ rl e \ rl d 
0c5c			;    inc l 
0c5c			;    add hl,bc 
0c5c			;    ld (seed1_0),hl 
0c5c			;    ld hl,(seed1_1) 
0c5c			;    adc hl,de 
0c5c			;    ld (seed1_1),hl 
0c5c			;    ex de,hl 
0c5c			;seed2_0=$+1 
0c5c			;    ld hl,9876 
0c5c			;seed2_1=$+1 
0c5c			;    ld bc,54321 
0c5c			;    add hl,hl \ rl c \ rl b 
0c5c			;    ld (seed2_1),bc 
0c5c			;    sbc a,a 
0c5c			;    and %11000101 
0c5c			;    xor l 
0c5c			;    ld l,a 
0c5c			;    ld (seed2_0),hl 
0c5c			;    ex de,hl 
0c5c			;    add hl,bc 
0c5c			;    ret 
0c5c			; 
0c5c			 
0c5c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c5c			; 20 bytes, 86 cycles (excluding ret) 
0c5c			 
0c5c			; returns   hl = pseudorandom number 
0c5c			; corrupts   a 
0c5c			 
0c5c			; generates 16-bit pseudorandom numbers with a period of 65535 
0c5c			; using the xorshift method: 
0c5c			 
0c5c			; hl ^= hl << 7 
0c5c			; hl ^= hl >> 9 
0c5c			; hl ^= hl << 8 
0c5c			 
0c5c			; some alternative shift triplets which also perform well are: 
0c5c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c5c			 
0c5c			;  org 32768 
0c5c			 
0c5c			xrnd: 
0c5c 2a af f8		  ld hl,(xrandc)       ; seed must not be 0 
0c5f 3e 00		  ld a,0 
0c61 bd			  cp l 
0c62 20 02		  jr nz, .xrnd1 
0c64 2e 01		  ld l, 1 
0c66			.xrnd1: 
0c66			 
0c66 7c			  ld a,h 
0c67 1f			  rra 
0c68 7d			  ld a,l 
0c69 1f			  rra 
0c6a ac			  xor h 
0c6b 67			  ld h,a 
0c6c 7d			  ld a,l 
0c6d 1f			  rra 
0c6e 7c			  ld a,h 
0c6f 1f			  rra 
0c70 ad			  xor l 
0c71 6f			  ld l,a 
0c72 ac			  xor h 
0c73 67			  ld h,a 
0c74			 
0c74 22 af f8		  ld (xrandc),hl 
0c77			 
0c77 c9			  ret 
0c78			;  
0c78			 
0c78			 
0c78			;;;; int maths 
0c78			 
0c78			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c78			; Divide 16-bit values (with 16-bit result) 
0c78			; In: Divide BC by divider DE 
0c78			; Out: BC = result, HL = rest 
0c78			; 
0c78			Div16: 
0c78 21 00 00		    ld hl,0 
0c7b 78			    ld a,b 
0c7c 06 08		    ld b,8 
0c7e			Div16_Loop1: 
0c7e 17			    rla 
0c7f ed 6a		    adc hl,hl 
0c81 ed 52		    sbc hl,de 
0c83 30 01		    jr nc,Div16_NoAdd1 
0c85 19			    add hl,de 
0c86			Div16_NoAdd1: 
0c86 10 f6		    djnz Div16_Loop1 
0c88 17			    rla 
0c89 2f			    cpl 
0c8a 47			    ld b,a 
0c8b 79			    ld a,c 
0c8c 48			    ld c,b 
0c8d 06 08		    ld b,8 
0c8f			Div16_Loop2: 
0c8f 17			    rla 
0c90 ed 6a		    adc hl,hl 
0c92 ed 52		    sbc hl,de 
0c94 30 01		    jr nc,Div16_NoAdd2 
0c96 19			    add hl,de 
0c97			Div16_NoAdd2: 
0c97 10 f6		    djnz Div16_Loop2 
0c99 17			    rla 
0c9a 2f			    cpl 
0c9b 41			    ld b,c 
0c9c 4f			    ld c,a 
0c9d c9			ret 
0c9e			 
0c9e			 
0c9e			;http://z80-heaven.wikidot.com/math 
0c9e			; 
0c9e			;Inputs: 
0c9e			;     DE and A are factors 
0c9e			;Outputs: 
0c9e			;     A is not changed 
0c9e			;     B is 0 
0c9e			;     C is not changed 
0c9e			;     DE is not changed 
0c9e			;     HL is the product 
0c9e			;Time: 
0c9e			;     342+6x 
0c9e			; 
0c9e			Mult16: 
0c9e			 
0c9e 06 08		     ld b,8          ;7           7 
0ca0 21 00 00		     ld hl,0         ;10         10 
0ca3 29			       add hl,hl     ;11*8       88 
0ca4 07			       rlca          ;4*8        32 
0ca5 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ca7 19			         add hl,de   ;--         -- 
0ca8 10 f9		       djnz $-5      ;13*7+8     99 
0caa c9			ret 
0cab			 
0cab			; 
0cab			; Square root of 16-bit value 
0cab			; In:  HL = value 
0cab			; Out:  D = result (rounded down) 
0cab			; 
0cab			;Sqr16: 
0cab			;    ld de,#0040 
0cab			;    ld a,l 
0cab			;    ld l,h 
0cab			;    ld h,d 
0cab			;    or a 
0cab			;    ld b,8 
0cab			;Sqr16_Loop: 
0cab			;    sbc hl,de 
0cab			;    jr nc,Sqr16_Skip 
0cab			;    add hl,de 
0cab			;Sqr16_Skip: 
0cab			;    ccf 
0cab			;    rl d 
0cab			;    add a,a 
0cab			;    adc hl,hl 
0cab			;    add a,a 
0cab			;    adc hl,hl 
0cab			;    djnz Sqr16_Loop 
0cab			;    ret 
0cab			; 
0cab			; 
0cab			; Divide 8-bit values 
0cab			; In: Divide E by divider C 
0cab			; Out: A = result, B = rest 
0cab			; 
0cab			Div8: 
0cab af			    xor a 
0cac 06 08		    ld b,8 
0cae			Div8_Loop: 
0cae cb 13		    rl e 
0cb0 17			    rla 
0cb1 91			    sub c 
0cb2 30 01		    jr nc,Div8_NoAdd 
0cb4 81			    add a,c 
0cb5			Div8_NoAdd: 
0cb5 10 f7		    djnz Div8_Loop 
0cb7 47			    ld b,a 
0cb8 7b			    ld a,e 
0cb9 17			    rla 
0cba 2f			    cpl 
0cbb c9			    ret 
0cbc			 
0cbc			; 
0cbc			; Multiply 8-bit value with a 16-bit value (unrolled) 
0cbc			; In: Multiply A with DE 
0cbc			; Out: HL = result 
0cbc			; 
0cbc			Mult12U: 
0cbc 2e 00		    ld l,0 
0cbe 87			    add a,a 
0cbf 30 01		    jr nc,Mult12U_NoAdd0 
0cc1 19			    add hl,de 
0cc2			Mult12U_NoAdd0: 
0cc2 29			    add hl,hl 
0cc3 87			    add a,a 
0cc4 30 01		    jr nc,Mult12U_NoAdd1 
0cc6 19			    add hl,de 
0cc7			Mult12U_NoAdd1: 
0cc7 29			    add hl,hl 
0cc8 87			    add a,a 
0cc9 30 01		    jr nc,Mult12U_NoAdd2 
0ccb 19			    add hl,de 
0ccc			Mult12U_NoAdd2: 
0ccc 29			    add hl,hl 
0ccd 87			    add a,a 
0cce 30 01		    jr nc,Mult12U_NoAdd3 
0cd0 19			    add hl,de 
0cd1			Mult12U_NoAdd3: 
0cd1 29			    add hl,hl 
0cd2 87			    add a,a 
0cd3 30 01		    jr nc,Mult12U_NoAdd4 
0cd5 19			    add hl,de 
0cd6			Mult12U_NoAdd4: 
0cd6 29			    add hl,hl 
0cd7 87			    add a,a 
0cd8 30 01		    jr nc,Mult12U_NoAdd5 
0cda 19			    add hl,de 
0cdb			Mult12U_NoAdd5: 
0cdb 29			    add hl,hl 
0cdc 87			    add a,a 
0cdd 30 01		    jr nc,Mult12U_NoAdd6 
0cdf 19			    add hl,de 
0ce0			Mult12U_NoAdd6: 
0ce0 29			    add hl,hl 
0ce1 87			    add a,a 
0ce2 d0			    ret nc 
0ce3 19			    add hl,de 
0ce4 c9			    ret 
0ce5			 
0ce5			; 
0ce5			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ce5			; In: Multiply A with DE 
0ce5			;      Put lowest value in A for most efficient calculation 
0ce5			; Out: HL = result 
0ce5			; 
0ce5			Mult12R: 
0ce5 21 00 00		    ld hl,0 
0ce8			Mult12R_Loop: 
0ce8 cb 3f		    srl a 
0cea 30 01		    jr nc,Mult12R_NoAdd 
0cec 19			    add hl,de 
0ced			Mult12R_NoAdd: 
0ced cb 23		    sla e 
0cef cb 12		    rl d 
0cf1 b7			    or a 
0cf2 c2 e8 0c		    jp nz,Mult12R_Loop 
0cf5 c9			    ret 
0cf6			 
0cf6			; 
0cf6			; Multiply 16-bit values (with 32-bit result) 
0cf6			; In: Multiply BC with DE 
0cf6			; Out: BCHL = result 
0cf6			; 
0cf6			Mult32: 
0cf6 79			    ld a,c 
0cf7 48			    ld c,b 
0cf8 21 00 00		    ld hl,0 
0cfb 06 10		    ld b,16 
0cfd			Mult32_Loop: 
0cfd 29			    add hl,hl 
0cfe 17			    rla 
0cff cb 11		    rl c 
0d01 30 07		    jr nc,Mult32_NoAdd 
0d03 19			    add hl,de 
0d04 ce 00		    adc a,0 
0d06 d2 0a 0d		    jp nc,Mult32_NoAdd 
0d09 0c			    inc c 
0d0a			Mult32_NoAdd: 
0d0a 10 f1		    djnz Mult32_Loop 
0d0c 41			    ld b,c 
0d0d 4f			    ld c,a 
0d0e c9			    ret 
0d0f			 
0d0f			 
0d0f			 
0d0f			; 
0d0f			; Multiply 8-bit values 
0d0f			; In:  Multiply H with E 
0d0f			; Out: HL = result 
0d0f			; 
0d0f			Mult8: 
0d0f 16 00		    ld d,0 
0d11 6a			    ld l,d 
0d12 06 08		    ld b,8 
0d14			Mult8_Loop: 
0d14 29			    add hl,hl 
0d15 30 01		    jr nc,Mult8_NoAdd 
0d17 19			    add hl,de 
0d18			Mult8_NoAdd: 
0d18 10 fa		    djnz Mult8_Loop 
0d1a c9			    ret 
0d1b			 
0d1b			 
0d1b			 
0d1b			 
0d1b			 
0d1b			 
0d1b			 
0d1b			 
0d1b			;;http://z80-heaven.wikidot.com/math 
0d1b			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d1b			; 
0d1b			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d1b			;     ld a,16        ;7 
0d1b			;     ld hl,0        ;10 
0d1b			;     jp $+5         ;10 
0d1b			;.DivLoop: 
0d1b			;       add hl,bc    ;-- 
0d1b			;       dec a        ;64 
0d1b			;       jr z,.DivLoopEnd        ;86 
0d1b			; 
0d1b			;       sla e        ;128 
0d1b			;       rl d         ;128 
0d1b			;       adc hl,hl    ;240 
0d1b			;       sbc hl,bc    ;240 
0d1b			;       jr nc,.DivLoop ;23|21 
0d1b			;       inc e        ;-- 
0d1b			;       jp .DivLoop+1 
0d1b			; 
0d1b			;.DivLoopEnd: 
0d1b			 
0d1b			;HL_Div_C: 
0d1b			;Inputs: 
0d1b			;     HL is the numerator 
0d1b			;     C is the denominator 
0d1b			;Outputs: 
0d1b			;     A is the remainder 
0d1b			;     B is 0 
0d1b			;     C is not changed 
0d1b			;     DE is not changed 
0d1b			;     HL is the quotient 
0d1b			; 
0d1b			;       ld b,16 
0d1b			;       xor a 
0d1b			;         add hl,hl 
0d1b			;         rla 
0d1b			;         cp c 
0d1b			;         jr c,$+4 
0d1b			;           inc l 
0d1b			;           sub c 
0d1b			;         djnz $-7 
0d1b			 
0d1b			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d1b			 
0d1b			addatohl: 
0d1b 85			    add   a, l    ; A = A+L 
0d1c 6f			    ld    l, a    ; L = A+L 
0d1d 8c			    adc   a, h    ; A = A+L+H+carry 
0d1e 95			    sub   l       ; A = H+carry 
0d1f 67			    ld    h, a    ; H = H+carry 
0d20 c9			ret 
0d21			 
0d21			addatode: 
0d21 83			    add   a, e    ; A = A+L 
0d22 5f			    ld    e, a    ; L = A+L 
0d23 8a			    adc   a, d    ; A = A+L+H+carry 
0d24 93			    sub   e       ; A = H+carry 
0d25 57			    ld    d, a    ; H = H+carry 
0d26 c9			ret 
0d27			 
0d27			 
0d27			addatobc: 
0d27 81			    add   a, c    ; A = A+L 
0d28 4f			    ld    c, a    ; L = A+L 
0d29 88			    adc   a, b    ; A = A+L+H+carry 
0d2a 91			    sub   c       ; A = H+carry 
0d2b 47			    ld    b, a    ; H = H+carry 
0d2c c9			ret 
0d2d			 
0d2d			subafromhl: 
0d2d			   ; If A=0 do nothing 
0d2d			    ; Otherwise flip A's sign. Since 
0d2d			    ; the upper byte becomes -1, also 
0d2d			    ; substract 1 from H. 
0d2d ed 44		    neg 
0d2f ca 38 0d		    jp    z, Skip 
0d32 25			    dec   h 
0d33			     
0d33			    ; Now add the low byte as usual 
0d33			    ; Two's complement takes care of 
0d33			    ; ensuring the result is correct 
0d33 85			    add   a, l 
0d34 6f			    ld    l, a 
0d35 8c			    adc   a, h 
0d36 95			    sub   l 
0d37 67			    ld    h, a 
0d38			Skip: 
0d38 c9				ret 
0d39			 
0d39			 
0d39			; compare hl and de 
0d39			; returns:  
0d39			; if hl = de, z=1, s=0, c0=0 
0d39			; if hl > de, z=0, s=0, c=0 
0d39			; if hl < de, z=0, s=1, c=1 
0d39			cmp16:	 
0d39 b7				or a 
0d3a ed 52			sbc hl,de 
0d3c e0				ret po 
0d3d 7c				ld a,h 
0d3e 1f				rra 
0d3f ee 40			xor 01000000B 
0d41 37				scf 
0d42 8f				adc a,a 
0d43 c9				ret 
0d44			 
0d44			 
0d44			; test if hl contains zero   - A is destroyed 
0d44			 
0d44			ishlzero:    
0d44 b7				or a     ; reset flags 
0d45 7c				ld a, h 
0d46 b5				or l        	 
0d47			 
0d47 c9				ret 
0d48			 
0d48			 
0d48			 
0d48			 
0d48			if FORTH_ENABLE_FLOATMATH 
0d48			;include "float/bbcmath.z80" 
0d48			include "float/lpfpcalc.asm" 
0d48			endif 
0d48			 
0d48			 
0d48			; eof 
0d48			 
# End of file firmware_maths.asm
0d48			include "firmware_strings.asm"   ; string handling  
0d48			 
0d48			 
0d48			; TODO string len 
0d48			; input text string, end on cr with zero term 
0d48			; a offset into frame buffer to start prompt 
0d48			; d is max length 
0d48			; e is display size TODO 
0d48			; c is current cursor position 
0d48			; hl is ptr to where string will be stored 
0d48			 
0d48			 
0d48			; TODO check limit of buffer for new inserts 
0d48			; TODO check insert does not push beyond buffer 
0d48			; TODO scroll in a limited display area 
0d48			; TODO scroll whole screen on page wrap 
0d48			 
0d48			 
0d48			; TODO handle KEY_PREVWORD 
0d48			; TODO handle KEY_NEXTWORD 
0d48			; TODO handle KEY_HOME 
0d48			; TODO handle KEY_END 
0d48			; TODO use LCD cursor? 
0d48			 
0d48 32 67 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d4b 81					add c 
0d4c 32 65 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d4f 22 6a fb				ld (input_start), hl     ; save ptr to buffer 
0d52 79					ld a, c 
0d53 cd 1b 0d				call addatohl 
0d56 22 6c fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d59 7a					ld a,d 
0d5a 32 69 fb			        ld (input_size), a       ; save length of input area 
0d5d 79					ld a, c 
0d5e 32 58 fb				ld (input_cursor),a      ; init cursor start position  
0d61 7b					ld a,e 
0d62 32 68 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d65					 
0d65					 
0d65			 
0d65			;		ld a,(input_ptr) 
0d65			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d65			 
0d65			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d65					; init cursor shape if not set by the cin routines 
0d65 21 c7 f8				ld hl, cursor_shape 
0d68 3e ff				ld a, 255 
0d6a 77					ld (hl), a 
0d6b 23					inc hl 
0d6c 3e 00				ld a, 0 
0d6e 77					ld (hl), a 
0d6f			 
0d6f 3e 0f				ld a, CUR_BLINK_RATE 
0d71 32 63 fb				ld (input_cur_flash), a 
0d74 3e 01				ld a, 1 
0d76 32 62 fb				ld (input_cur_onoff),a 
0d79			 
0d79			;	if DEBUG_INPUT 
0d79			;		push af 
0d79			;		ld a, 'I' 
0d79			;		ld (debug_mark),a 
0d79			;		pop af 
0d79			;		CALLMONITOR 
0d79			;	endif 
0d79			.is1:		; main entry loop 
0d79			 
0d79			 
0d79			 
0d79					; pause 1ms 
0d79			 
0d79 3e 01				ld a, 1 
0d7b cd 49 0a				call aDelayInMS 
0d7e			 
0d7e					; dec flash counter 
0d7e 3a 63 fb				ld a, (input_cur_flash) 
0d81 3d					dec a 
0d82 32 63 fb				ld (input_cur_flash), a 
0d85 fe 00				cp 0 
0d87 20 0d				jr nz, .nochgstate 
0d89			 
0d89			 
0d89					; change state 
0d89 3a 62 fb				ld a,(input_cur_onoff) 
0d8c ed 44				neg 
0d8e 32 62 fb				ld (input_cur_onoff),a 
0d91			 
0d91			 
0d91					; reset on change of state 
0d91 3e 0f				ld a, CUR_BLINK_RATE 
0d93 32 63 fb				ld (input_cur_flash), a 
0d96			 
0d96			.nochgstate: 
0d96					 
0d96					 
0d96			 
0d96					; display cursor  
0d96			 
0d96			;		ld hl, (input_start) 
0d96			;		ld a, (input_cursor) 
0d96			;		call addatohl 
0d96			 
0d96					; get char under cursor and replace with cursor 
0d96 2a 6c fb		ld hl, (input_ptr) 
0d99			;		ld a, (hl) 
0d99			;		ld (input_under_cursor),a 
0d99			;		ld a, '_' 
0d99			;		ld (hl), a 
0d99			 
0d99					; display string 
0d99			 
0d99 ed 5b 6a fb			ld de, (input_start) 
0d9d 3a 67 fb				ld a, (input_at_pos) 
0da0 cd fa 0a				call str_at_display 
0da3			;	        call update_display 
0da3			 
0da3					; find place to put the cursor 
0da3			;		add h 
0da3			;		ld l, display_row_1 
0da3			;		sub l 
0da3			; (input_at_pos) 
0da3					;ld c, a 
0da3			;		ld a, (input_cursor) 
0da3			;		ld l, (input_at_pos) 
0da3			;		;ld b, h 
0da3			;		add l 
0da3			;		ld (input_at_cursor),a 
0da3					;ld l,h 
0da3			 
0da3			;		ld h, 0 
0da3			;		ld l,(input_at_pos) 
0da3			;		ld a, (input_cursor) 
0da3			;		call addatohl 
0da3			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0da3			;		call subafromhl 
0da3			;		ld a,l 
0da3			;		ld (input_at_cursor), a 
0da3			 
0da3				if DEBUG_INPUT 
0da3					ld a, (hardware_diag) 
0da3					cp 0 
0da3					jr z, .skip_input_diag 
0da3			 
0da3					ld a,(input_at_pos) 
0da3					ld hl, LFSRSeed 
0da3					call hexout 
0da3					ld a, (input_cursor) 
0da3					ld hl, LFSRSeed+2 
0da3					call hexout 
0da3					ld a,(input_at_cursor) 
0da3					ld hl, LFSRSeed+4 
0da3					call hexout 
0da3			 
0da3					ld a,(input_cur_onoff) 
0da3					ld hl, LFSRSeed+6 
0da3					call hexout 
0da3			 
0da3					ld a,(input_cur_flash) 
0da3					ld hl, LFSRSeed+8 
0da3					call hexout 
0da3			 
0da3					ld a,(input_len) 
0da3					ld hl, LFSRSeed+10 
0da3					call hexout 
0da3					ld hl, LFSRSeed+12 
0da3					ld a, 0 
0da3					ld (hl),a 
0da3					ld a, display_row_4 
0da3					ld de, LFSRSeed 
0da3					call str_at_display 
0da3					.skip_input_diag: 
0da3				endif 
0da3			 
0da3					; decide on if we are showing the cursor this time round 
0da3			 
0da3 3a 62 fb				ld a, (input_cur_onoff) 
0da6 fe ff				cp 255 
0da8 28 13				jr z, .skipcur 
0daa			 
0daa			 
0daa 3a 65 fb				ld a,(input_at_cursor) 
0dad 11 c7 f8				ld de, cursor_shape 
0db0 cd fa 0a				call str_at_display 
0db3			 
0db3					; save length of current input string 
0db3 2a 6a fb				ld hl, (input_start) 
0db6 cd 79 11				call strlenz 
0db9 7d					ld a,l 
0dba 32 5d fb				ld (input_len),a 
0dbd			 
0dbd			.skipcur: 
0dbd			 
0dbd cd 0a 0b			        call update_display 
0dc0					 
0dc0			 
0dc0			 
0dc0					; wait 
0dc0				 
0dc0					; TODO loop without wait to flash the cursor and char under cursor	 
0dc0 cd 57 69				call cin    ; _wait 
0dc3			 
0dc3 fe 00				cp 0 
0dc5 ca 79 0d				jp z, .is1 
0dc8			 
0dc8					; get ptr to char to input into 
0dc8			 
0dc8 4f					ld c,a 
0dc9 2a 6a fb				ld hl, (input_start) 
0dcc 3a 58 fb				ld a, (input_cursor) 
0dcf cd 1b 0d				call addatohl 
0dd2 22 6c fb				ld (input_ptr), hl 
0dd5 79					ld a,c 
0dd6			 
0dd6					; replace char under cursor 
0dd6			 
0dd6			;		ld hl, (input_ptr) 
0dd6			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dd6			;		ld (hl), a 
0dd6			 
0dd6			;	if DEBUG_INPUT 
0dd6			;		push af 
0dd6			;		ld a, 'i' 
0dd6			;		ld (debug_mark),a 
0dd6			;		pop af 
0dd6			;		CALLMONITOR 
0dd6			;	endif 
0dd6 fe 0e				cp KEY_HOME 
0dd8 20 0e				jr nz, .iske 
0dda			 
0dda 3a 67 fb				ld a, (input_at_pos) 
0ddd 32 65 fb				ld (input_at_cursor),a 
0de0 3e 00				ld a, 0 
0de2 32 58 fb				ld (input_cursor), a 
0de5 c3 79 0d				jp .is1 
0de8					 
0de8 fe 0f		.iske:		cp KEY_END 
0dea 20 03				jr nz, .isknw 
0dec c3 79 0d				jp .is1 
0def			 
0def fe 06		.isknw:		cp KEY_NEXTWORD 
0df1 20 1b				jr nz, .iskpw 
0df3			 
0df3 2a 6c fb		.isknwm:	ld hl, (input_ptr) 
0df6 7e					ld a,(hl)	 
0df7 fe 00				cp 0 
0df9 ca 79 0d				jp z, .is1    ; end of string 
0dfc fe 20				cp ' ' 
0dfe ca 79 0d				jp z, .is1    ; end of word 
0e01 23					inc hl 
0e02 22 6c fb				ld (input_ptr), hl 
0e05 3a 65 fb				ld a, (input_at_cursor) 
0e08 3c					inc a 
0e09 32 65 fb				ld (input_at_cursor), a 
0e0c 18 e5				jr .isknwm 
0e0e			 
0e0e fe 07		.iskpw:		cp KEY_PREVWORD 
0e10 20 1b				jr nz, .iskl 
0e12			.iskpwm:	 
0e12 2a 6c fb				ld hl, (input_ptr) 
0e15 7e					ld a,(hl)	 
0e16 fe 00				cp 0  
0e18 ca 79 0d				jp z, .is1    ; end of string 
0e1b fe 20				cp ' ' 
0e1d ca 79 0d				jp z, .is1    ; end of word 
0e20 2b					dec hl 
0e21 22 6c fb				ld (input_ptr), hl 
0e24 3a 65 fb				ld a, (input_at_cursor) 
0e27 3d					dec a 
0e28 32 65 fb				ld (input_at_cursor), a 
0e2b 18 e5				jr .iskpwm 
0e2d			 
0e2d			 
0e2d fe 0b		.iskl:		cp KEY_LEFT 
0e2f 20 27				jr nz, .isk1 
0e31			 
0e31 3a 58 fb				ld a, (input_cursor) 
0e34			 
0e34 fe 00				cp 0 
0e36 ca 79 0d				jp z, .is1 		; at start of line to ignore  
0e39			 
0e39 3d					dec  a 		; TODO check underflow 
0e3a 32 58 fb				ld (input_cursor), a 
0e3d			 
0e3d 2a 6c fb				ld hl, (input_ptr) 
0e40 2b					dec hl 
0e41 22 6c fb				ld (input_ptr), hl 
0e44					 
0e44 3a 65 fb				ld a, (input_at_cursor) 
0e47 3d					dec a 
0e48 32 65 fb				ld (input_at_cursor), a 
0e4b			 
0e4b 3e 01				ld a, 1		; show cursor moving 
0e4d 32 62 fb				ld (input_cur_onoff),a 
0e50 3e 0f				ld a, CUR_BLINK_RATE 
0e52 32 63 fb				ld (input_cur_flash), a 
0e55			 
0e55 c3 79 0d				jp .is1 
0e58			 
0e58 fe 0c		.isk1:		cp KEY_RIGHT 
0e5a 20 2a				jr nz, .isk2 
0e5c			 
0e5c 3a 5d fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e5f 5f					ld e,a 
0e60 3a 58 fb				ld a, (input_cursor) 
0e63 bb					cp e 
0e64 ca 79 0d				jp z, .is1		; at the end of string so dont go right 
0e67			 
0e67 3c					inc  a 		; TODO check overflow 
0e68 32 58 fb				ld (input_cursor), a 
0e6b			 
0e6b 3a 65 fb				ld a, (input_at_cursor) 
0e6e 3c					inc a 
0e6f 32 65 fb				ld (input_at_cursor), a 
0e72			 
0e72 2a 6c fb				ld hl, (input_ptr) 
0e75 23					inc hl 
0e76 22 6c fb				ld (input_ptr), hl 
0e79			 
0e79 3e 01				ld a, 1		; show cursor moving 
0e7b 32 62 fb				ld (input_cur_onoff),a 
0e7e 3e 0f				ld a, CUR_BLINK_RATE 
0e80 32 63 fb				ld (input_cur_flash), a 
0e83			 
0e83 c3 79 0d				jp .is1 
0e86			 
0e86 fe 05		.isk2:		cp KEY_UP 
0e88			 
0e88 20 26				jr nz, .isk3 
0e8a			 
0e8a					; swap last command with the current on 
0e8a			 
0e8a					; move cursor to start of string 
0e8a 2a 6a fb				ld hl, (input_start) 
0e8d 22 6c fb				ld (input_ptr), hl 
0e90			 
0e90 3a 67 fb				ld a, (input_at_pos) 
0e93 32 65 fb				ld (input_at_cursor), a 
0e96			 
0e96 3e 00				ld a, 0 
0e98 32 58 fb				ld (input_cursor), a 
0e9b					 
0e9b					; swap input and last command buffers 
0e9b			 
0e9b 21 3b f1				ld hl, os_cli_cmd 
0e9e 11 3a f2				ld de, os_last_cmd 
0ea1 06 ff				ld b, 255 
0ea3 7e			.swap1:		ld a, (hl) 
0ea4 4f					ld c,a 
0ea5 1a					ld a, (de) 
0ea6 77					ld (hl), a 
0ea7 79					ld a,c 
0ea8 12					ld (de),a 
0ea9 23					inc hl 
0eaa 13					inc de 
0eab 10 f6				djnz .swap1 
0ead			 
0ead			 
0ead			 
0ead			 
0ead			 
0ead c3 79 0d				jp .is1 
0eb0			 
0eb0 fe 08		.isk3:		cp KEY_BS 
0eb2 20 3c				jr nz, .isk4 
0eb4			 
0eb4 3a 58 fb				ld a, (input_cursor) 
0eb7			 
0eb7 fe 00				cp 0 
0eb9 ca 79 0d				jp z, .is1 		; at start of line to ignore  
0ebc			 
0ebc 3d					dec  a 		; TODO check underflow 
0ebd 32 58 fb				ld (input_cursor), a 
0ec0			 
0ec0					; hl is source 
0ec0					; de needs to be source - 1 
0ec0			 
0ec0			;		ld a, 0 
0ec0			;		dec hl 
0ec0			;		ld (hl), a 
0ec0			 
0ec0 2a 6c fb				ld hl, (input_ptr) 
0ec3 2b					dec hl 
0ec4 22 6c fb				ld (input_ptr), hl 
0ec7			 
0ec7					; shift all data 
0ec7			 
0ec7 e5					push hl 
0ec8 23					inc hl 
0ec9 d1					pop de 
0eca 3a 5d fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ecd 4f					ld c,a 
0ece 06 00				ld b,0 
0ed0 ed b0				ldir  
0ed2			 
0ed2			 
0ed2			 
0ed2			 
0ed2 3a 65 fb				ld a, (input_at_cursor) 
0ed5 3d					dec a 
0ed6 32 65 fb				ld (input_at_cursor), a 
0ed9			 
0ed9			 
0ed9 3e 01				ld a, 1		; show cursor moving 
0edb 32 62 fb				ld (input_cur_onoff),a 
0ede 3e 0f				ld a, CUR_BLINK_RATE 
0ee0 32 63 fb				ld (input_cur_flash), a 
0ee3			 
0ee3					; remove char 
0ee3 3a 65 fb				ld a, (input_at_cursor) 
0ee6 3c					inc a 
0ee7 11 71 0f				ld de,.iblank 
0eea cd fa 0a				call str_at_display 
0eed			 
0eed c3 79 0d				jp .is1 
0ef0			 
0ef0 fe 0d		.isk4:		cp KEY_CR 
0ef2 28 6c				jr z, .endinput 
0ef4			 
0ef4					; else add the key press to the end 
0ef4			 
0ef4 4f					ld c, a			; save key pressed 
0ef5			 
0ef5 7e					ld a,(hl)		; get what is currently under char 
0ef6			 
0ef6 fe 00				cp 0			; we are at the end of the string 
0ef8 20 2f				jr nz, .onchar 
0efa					 
0efa					; add a char to the end of the string 
0efa				 
0efa 71					ld (hl),c 
0efb 23					inc hl 
0efc			;		ld a,' ' 
0efc			;		ld (hl),a 
0efc			;		inc hl 
0efc 3e 00				ld a,0 
0efe 77					ld (hl),a 
0eff 2b					dec hl 
0f00			 
0f00 3a 58 fb				ld a, (input_cursor) 
0f03 3c					inc a				; TODO check max string length and scroll  
0f04 32 58 fb				ld (input_cursor), a		; inc cursor pos 
0f07							 
0f07 3a 65 fb				ld a, (input_at_cursor) 
0f0a 3c					inc a 
0f0b 32 65 fb				ld (input_at_cursor), a 
0f0e			 
0f0e 2a 6c fb				ld hl, (input_ptr) 
0f11 23					inc hl 
0f12 22 6c fb				ld (input_ptr), hl 
0f15			 
0f15 2a 6c fb				ld hl, (input_ptr) 
0f18 23					inc hl 
0f19 22 6c fb				ld (input_ptr), hl 
0f1c			;	if DEBUG_INPUT 
0f1c			;		push af 
0f1c			;		ld a, '+' 
0f1c			;		ld (debug_mark),a 
0f1c			;		pop af 
0f1c			;		CALLMONITOR 
0f1c			;	endif 
0f1c 3e 01				ld a, 1		; show cursor moving 
0f1e 32 62 fb				ld (input_cur_onoff),a 
0f21 3e 0f				ld a, CUR_BLINK_RATE 
0f23 32 63 fb				ld (input_cur_flash), a 
0f26 c3 79 0d				jp .is1 
0f29					 
0f29			 
0f29			 
0f29					; if on a char then insert 
0f29			.onchar: 
0f29			 
0f29					; TODO over flow check: make sure insert does not blow out buffer 
0f29			 
0f29					; need to do some maths to use lddr 
0f29			 
0f29 e5					push hl   ; save char pos 
0f2a c5					push bc 
0f2b			 
0f2b 2a 6a fb				ld hl, (input_start) 
0f2e 3a 5d fb				ld a, (input_len) 
0f31 cd 1b 0d				call addatohl  		; end of string 
0f34 23					inc hl 
0f35 23					inc hl		; past zero term 
0f36 e5					push hl 
0f37 23					inc hl 
0f38 e5					push hl  
0f39			 
0f39								; start and end of lddr set, now how much to move? 
0f39			 
0f39							 
0f39 3a 58 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f3c 47					ld b,a 
0f3d 3a 5d fb				ld a,(input_len) 
0f40 5f					ld e,a 
0f41 90					sub b 
0f42 3c					inc a		;?? 
0f43 3c					inc a		;?? 
0f44 3c					inc a		;?? 
0f45			 
0f45 06 00				ld b,0 
0f47 4f					ld c,a 
0f48			 
0f48				if DEBUG_INPUT 
0f48					push af 
0f48					ld a, 'i' 
0f48					ld (debug_mark),a 
0f48					pop af 
0f48			;		CALLMONITOR 
0f48				endif 
0f48 d1					pop de 
0f49 e1					pop hl 
0f4a				if DEBUG_INPUT 
0f4a					push af 
0f4a					ld a, 'I' 
0f4a					ld (debug_mark),a 
0f4a					pop af 
0f4a			;		CALLMONITOR 
0f4a				endif 
0f4a ed b8				lddr 
0f4c				 
0f4c			 
0f4c			 
0f4c					; TODO have a key for insert/overwrite mode???? 
0f4c c1					pop bc 
0f4d e1					pop hl 
0f4e 71					ld (hl), c		; otherwise overwrite current char 
0f4f					 
0f4f			 
0f4f			 
0f4f			 
0f4f 3a 58 fb				ld a, (input_cursor) 
0f52 3c					inc  a 		; TODO check overflow 
0f53 32 58 fb				ld (input_cursor), a 
0f56			 
0f56 3a 65 fb				ld a, (input_at_cursor) 
0f59 3c					inc a 
0f5a 32 65 fb				ld (input_at_cursor), a 
0f5d			 
0f5d c3 79 0d				jp .is1 
0f60			 
0f60			.endinput:	; TODO look for end of string 
0f60			 
0f60					; add trailing space for end of token 
0f60			 
0f60 2a 6a fb				ld hl, (input_start) 
0f63 3a 5d fb				ld a,(input_len) 
0f66 cd 1b 0d				call addatohl 
0f69 3e 20				ld a, ' ' 
0f6b 77					ld (hl),a 
0f6c					; TODO eof of parse marker 
0f6c			 
0f6c 23					inc hl 
0f6d 3e 00				ld a, 0 
0f6f 77					ld (hl),a 
0f70			 
0f70			 
0f70 c9					ret 
0f71			 
0f71 .. 00		.iblank: db " ",0 
0f73			 
0f73			 
0f73 32 67 fb		input_str_prev:	ld (input_at_pos), a 
0f76 22 6a fb				ld (input_start), hl 
0f79 3e 01				ld a,1			; add cursor 
0f7b 77					ld (hl),a 
0f7c 23					inc hl 
0f7d 3e 00				ld a,0 
0f7f 77					ld (hl),a 
0f80 22 6c fb				ld (input_ptr), hl 
0f83 7a					ld a,d 
0f84 32 69 fb				ld (input_size), a 
0f87 3e 00				ld a,0 
0f89 32 58 fb				ld (input_cursor),a 
0f8c			.instr1:	 
0f8c			 
0f8c					; TODO do block cursor 
0f8c					; TODO switch cursor depending on the modifer key 
0f8c			 
0f8c					; update cursor shape change on key hold 
0f8c			 
0f8c 2a 6c fb				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 3a c7 f8				ld a,(cursor_shape) 
0f93 77					ld (hl), a 
0f94			 
0f94					; display entered text 
0f94 3a 67 fb				ld a,(input_at_pos) 
0f97 cd 1b 67		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f9a ed 5b 6a fb	            	LD   de, (input_start) 
0f9e cd 3d 67		            	CALL fLCD_Str       ;Display string pointed to by DE 
0fa1			 
0fa1 cd 57 69				call cin 
0fa4 fe 00				cp 0 
0fa6 28 e4				jr z, .instr1 
0fa8			 
0fa8					; proecess keyboard controls first 
0fa8			 
0fa8 2a 6c fb				ld hl,(input_ptr) 
0fab			 
0fab fe 0d				cp KEY_CR	 ; pressing enter ends input 
0fad 28 5a				jr z, .instrcr 
0faf			 
0faf fe 08				cp KEY_BS 	; back space 
0fb1 20 0f				jr nz, .instr2 
0fb3					; process back space 
0fb3			 
0fb3					; TODO stop back space if at start of string 
0fb3 2b					dec hl 
0fb4 2b					dec hl ; to over write cursor 
0fb5 3a c7 f8				ld a,(cursor_shape) 
0fb8					;ld a,0 
0fb8 77					ld (hl),a 
0fb9 23					inc hl 
0fba 3e 20				ld a," " 
0fbc 77					ld (hl),a 
0fbd 22 6c fb				ld (input_ptr),hl 
0fc0					 
0fc0			 
0fc0 18 ca				jr .instr1 
0fc2			 
0fc2 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fc4 20 06				jr nz, .instr3 
0fc6 2b					dec hl 
0fc7 22 6c fb				ld (input_ptr),hl 
0fca 18 c0				jr .instr1 
0fcc				 
0fcc fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fce 20 06				jr nz, .instr4 
0fd0 23					inc hl 
0fd1 22 6c fb				ld (input_ptr),hl 
0fd4 18 b6				jr .instr1 
0fd6			 
0fd6 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fd8 20 06				jr nz, .instr5 
0fda 2b					dec hl 
0fdb 22 6c fb				ld (input_ptr),hl 
0fde 18 ac				jr .instr1 
0fe0			 
0fe0 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fe2 20 06				jr nz, .instr6 
0fe4 2b					dec hl 
0fe5 22 6c fb				ld (input_ptr),hl 
0fe8 18 a2				jr .instr1 
0fea fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fec 20 0b				jr nz, .instrnew 
0fee			 
0fee 21 14 ee			ld hl, scratch 
0ff1 11 3a f2			ld de, os_last_cmd 
0ff4 cd 12 10			call strcpy 
0ff7 18 93				jr .instr1 
0ff9			 
0ff9			 
0ff9			.instrnew:	; no special key pressed to see if we have room to store it 
0ff9			 
0ff9					; TODO do string size test 
0ff9			 
0ff9 2b					dec hl ; to over write cursor 
0ffa 77					ld (hl),a 
0ffb 23					inc hl 
0ffc 3a c7 f8				ld a,(cursor_shape) 
0fff 77					ld (hl),a 
1000 23					inc hl 
1001 3e 00				ld a,0 
1003 77					ld (hl),a 
1004			 
1004 22 6c fb				ld (input_ptr),hl 
1007					 
1007 18 83				jr .instr1 
1009 2b			.instrcr:	dec hl		; remove cursor 
100a 3e 20				ld a,' '	; TODO add a trailing space for safety 
100c 77					ld (hl),a 
100d 23					inc hl 
100e 3e 00				ld a,0 
1010 77					ld (hl),a 
1011			 
1011			 
1011					; if at end of line scroll up    
1011					; TODO detecting only end of line 4 for scroll up  
1011			 
1011					;ld   
1011			 
1011 c9					ret 
1012			 
1012			 
1012			; strcpy hl = dest, de source 
1012			 
1012 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1013 b7			            OR   A              ;Null terminator? 
1014 c8			            RET  Z              ;Yes, so finished 
1015 1a					ld a,(de) 
1016 77					ld (hl),a 
1017 13			            INC  DE             ;Point to next character 
1018 23					inc hl 
1019 18 f7		            JR   strcpy       ;Repeat 
101b c9					ret 
101c			 
101c			 
101c			; TODO string_at  
101c			; pass string which starts with lcd offset address and then null term string 
101c			 
101c			; TODO string to dec 
101c			; TODO string to hex 
101c			; TODO byte to string hex 
101c			; TODO byte to string dec 
101c			 
101c			 
101c			 
101c			; from z80uartmonitor 
101c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101c			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
101c			; pass hl for where to put the text 
101c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101c c5			hexout:	PUSH BC 
101d f5					PUSH AF 
101e 47					LD B, A 
101f					; Upper nybble 
101f cb 3f				SRL A 
1021 cb 3f				SRL A 
1023 cb 3f				SRL A 
1025 cb 3f				SRL A 
1027 cd 37 10				CALL tohex 
102a 77					ld (hl),a 
102b 23					inc hl	 
102c					 
102c					; Lower nybble 
102c 78					LD A, B 
102d e6 0f				AND 0FH 
102f cd 37 10				CALL tohex 
1032 77					ld (hl),a 
1033 23					inc hl	 
1034					 
1034 f1					POP AF 
1035 c1					POP BC 
1036 c9					RET 
1037					 
1037			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1037			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1037			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1037			tohex: 
1037 e5					PUSH HL 
1038 d5					PUSH DE 
1039 16 00				LD D, 0 
103b 5f					LD E, A 
103c 21 44 10				LD HL, .DATA 
103f 19					ADD HL, DE 
1040 7e					LD A, (HL) 
1041 d1					POP DE 
1042 e1					POP HL 
1043 c9					RET 
1044			 
1044			.DATA: 
1044 30					DEFB	30h	; 0 
1045 31					DEFB	31h	; 1 
1046 32					DEFB	32h	; 2 
1047 33					DEFB	33h	; 3 
1048 34					DEFB	34h	; 4 
1049 35					DEFB	35h	; 5 
104a 36					DEFB	36h	; 6 
104b 37					DEFB	37h	; 7 
104c 38					DEFB	38h	; 8 
104d 39					DEFB	39h	; 9 
104e 41					DEFB	41h	; A 
104f 42					DEFB	42h	; B 
1050 43					DEFB	43h	; C 
1051 44					DEFB	44h	; D 
1052 45					DEFB	45h	; E 
1053 46					DEFB	46h	; F 
1054			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1054			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1054			;;    subtract $30, if result > 9 then subtract $7 more 
1054			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1054			atohex: 
1054 d6 30				SUB $30 
1056 fe 0a				CP 10 
1058 f8					RET M		; If result negative it was 0-9 so we're done 
1059 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
105b c9					RET		 
105c			 
105c			 
105c			 
105c			 
105c			; Get 2 ASCII characters as hex byte from pointer in hl 
105c			 
105c			BYTERD: 
105c 16 00			LD	D,00h		;Set up 
105e cd 66 10			CALL	HEXCON		;Get byte and convert to hex 
1061 87				ADD	A,A		;First nibble so 
1062 87				ADD	A,A		;multiply by 16 
1063 87				ADD	A,A		; 
1064 87				ADD	A,A		; 
1065 57				LD	D,A		;Save hi nibble in D 
1066			HEXCON: 
1066 7e				ld a, (hl)		;Get next chr 
1067 23				inc hl 
1068 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
106a fe 0a			CP	00Ah		;Is it 0-9 ? 
106c 38 02			JR	C,NALPHA	;If so miss next bit 
106e d6 07			SUB	007h		;Else convert alpha 
1070			NALPHA: 
1070 b2				OR	D		;Add hi nibble back 
1071 c9				RET			; 
1072			 
1072			 
1072			; 
1072			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1072			; Since the routines get_byte and therefore get_nibble are called, only valid 
1072			; characters (0-9a-f) are accepted. 
1072			; 
1072			;get_word        push    af 
1072			;                call    get_byte        ; Get the upper byte 
1072			;                ld      h, a 
1072			;                call    get_byte        ; Get the lower byte 
1072			;                ld      l, a 
1072			;                pop     af 
1072			;                ret 
1072			; 
1072			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1072			; the routine get_nibble is used only valid characters are accepted - the  
1072			; input routine only accepts characters 0-9a-f. 
1072			; 
1072 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1073 7e					ld a,(hl) 
1074 23					inc hl 
1075 cd 9a 10		                call    nibble2val      ; Get upper nibble 
1078 cb 07		                rlc     a 
107a cb 07		                rlc     a 
107c cb 07		                rlc     a 
107e cb 07		                rlc     a 
1080 47			                ld      b, a            ; Save upper four bits 
1081 7e					ld a,(hl) 
1082 cd 9a 10		                call    nibble2val      ; Get lower nibble 
1085 b0			                or      b               ; Combine both nibbles 
1086 c1			                pop     bc              ; Restore B (and C) 
1087 c9			                ret 
1088			; 
1088			; Get a hexadecimal digit from the serial line. This routine blocks until 
1088			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1088			; to the serial line interface. The lower 4 bits of A contain the value of  
1088			; that particular digit. 
1088			; 
1088			;get_nibble      ld a,(hl)           ; Read a character 
1088			;                call    to_upper        ; Convert to upper case 
1088			;                call    is_hex          ; Was it a hex digit? 
1088			;                jr      nc, get_nibble  ; No, get another character 
1088			 ;               call    nibble2val      ; Convert nibble to value 
1088			 ;               call    print_nibble 
1088			 ;               ret 
1088			; 
1088			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1088			; A valid hexadecimal digit is denoted by a set C flag. 
1088			; 
1088			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1088			;                ret     nc              ; Yes 
1088			;                cp      '0'             ; Less than '0'? 
1088			;                jr      nc, is_hex_1    ; No, continue 
1088			;                ccf                     ; Complement carry (i.e. clear it) 
1088			;                ret 
1088			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1088			;                ret     c               ; Yes 
1088			;                cp      'A'             ; Less than 'A'? 
1088			;                jr      nc, is_hex_2    ; No, continue 
1088			;                ccf                     ; Yes - clear carry and return 
1088			;                ret 
1088			;is_hex_2        scf                     ; Set carry 
1088			;                ret 
1088			; 
1088			; Convert a single character contained in A to upper case: 
1088			; 
1088 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
108a d8			                ret     c 
108b fe 7b		                cp      'z' + 1         ; > 'z'? 
108d d0			                ret     nc              ; Nothing to do, either 
108e e6 5f		                and     $5f             ; Convert to upper case 
1090 c9			                ret 
1091			 
1091			 
1091			to_lower: 
1091			 
1091			   ; if char is in [A-Z] make it lower case 
1091			 
1091			   ; enter : a = char 
1091			   ; exit  : a = lower case char 
1091			   ; uses  : af 
1091			 
1091 fe 41		   cp 'A' 
1093 d8			   ret c 
1094			    
1094 fe 5b		   cp 'Z'+1 
1096 d0			   ret nc 
1097			    
1097 f6 20		   or $20 
1099 c9			   ret 
109a			 
109a			; 
109a			; Expects a hexadecimal digit (upper case!) in A and returns the 
109a			; corresponding value in A. 
109a			; 
109a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
109c 38 02		                jr      c, nibble2val_1 ; Yes 
109e d6 07		                sub     7               ; Adjust for A-F 
10a0 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
10a2 e6 0f		                and     $f              ; Only return lower 4 bits 
10a4 c9			                ret 
10a5			; 
10a5			; Print_nibble prints a single hex nibble which is contained in the lower  
10a5			; four bits of A: 
10a5			; 
10a5			;print_nibble    push    af              ; We won't destroy the contents of A 
10a5			;                and     $f              ; Just in case... 
10a5			;                add     a, '0'             ; If we have a digit we are done here. 
10a5			;                cp      '9' + 1         ; Is the result > 9? 
10a5			;                jr      c, print_nibble_1 
10a5			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10a5			;print_nibble_1  call    putc            ; Print the nibble and 
10a5			;                pop     af              ; restore the original value of A 
10a5			;                ret 
10a5			;; 
10a5			;; Send a CR/LF pair: 
10a5			; 
10a5			;crlf            push    af 
10a5			;                ld      a, cr 
10a5			;                call    putc 
10a5			;                ld      a, lf 
10a5			;                call    putc 
10a5			;                pop     af 
10a5			;                ret 
10a5			; 
10a5			; Print_word prints the four hex digits of a word to the serial line. The  
10a5			; word is expected to be in HL. 
10a5			; 
10a5			;print_word      push    hl 
10a5			;                push    af 
10a5			;                ld      a, h 
10a5			;                call    print_byte 
10a5			;                ld      a, l 
10a5			;                call    print_byte 
10a5			;                pop     af 
10a5			;                pop     hl 
10a5			;                ret 
10a5			; 
10a5			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10a5			; The byte to be printed is expected to be in A. 
10a5			; 
10a5			;print_byte      push    af              ; Save the contents of the registers 
10a5			;                push    bc 
10a5			;                ld      b, a 
10a5			;                rrca 
10a5			;                rrca 
10a5			;                rrca 
10a5			;                rrca 
10a5			;                call    print_nibble    ; Print high nibble 
10a5			;                ld      a, b 
10a5			;                call    print_nibble    ; Print low nibble 
10a5			;                pop     bc              ; Restore original register contents 
10a5			;                pop     af 
10a5			;                ret 
10a5			 
10a5			 
10a5			 
10a5			 
10a5			 
10a5			fourehexhl:  
10a5 7e				ld a,(hl) 
10a6 cd 54 10			call atohex 
10a9 cb 3f				SRL A 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 47				ld b, a 
10b2 23				inc hl 
10b3 7e				ld a,(hl) 
10b4 23				inc hl 
10b5 cd 54 10			call atohex 
10b8 80				add b 
10b9 57				ld d,a 
10ba 7e				ld a,(hl) 
10bb cd 54 10			call atohex 
10be cb 3f				SRL A 
10c0 cb 3f				SRL A 
10c2 cb 3f				SRL A 
10c4 cb 3f				SRL A 
10c6 47				ld b, a 
10c7 23				inc hl 
10c8 7e				ld a,(hl) 
10c9 23				inc hl 
10ca cd 54 10			call atohex 
10cd 80				add b 
10ce 5f				ld e, a 
10cf d5				push de 
10d0 e1				pop hl 
10d1 c9				ret 
10d2			 
10d2			; pass hl. returns z set if the byte at hl is a digit 
10d2			;isdigithl:  
10d2			;	push bc 
10d2			;	ld a,(hl) 
10d2			;	cp ':' 
10d2			;	jr nc, .isdf 		; > 
10d2			;	cp '0' 
10d2			;	jr c, .isdf		; < 
10d2			; 
10d2			;	; TODO find a better way to set z 
10d2			; 
10d2			;	ld b,a 
10d2			;	cp b 
10d2			;	pop bc 
10d2			;	ret 
10d2			; 
10d2			;.isdf:	; not digit so clear z 
10d2			; 
10d2			;	; TODO find a better way to unset z 
10d2			; 
10d2			;	ld b,a 
10d2			;	inc b 
10d2			;	cp b 
10d2			; 
10d2			;	pop bc 
10d2			;	ret 
10d2				 
10d2				 
10d2			 
10d2			 
10d2			; pass hl as the four byte address to load 
10d2			 
10d2			get_word_hl:  
10d2 e5				push hl 
10d3 cd 72 10			call get_byte 
10d6				 
10d6 47				ld b, a 
10d7			 
10d7 e1				pop hl 
10d8 23				inc hl 
10d9 23				inc hl 
10da			 
10da			; TODO not able to handle a-f  
10da 7e				ld a,(hl) 
10db			;	;cp ':' 
10db			;	cp 'g' 
10db			;	jr nc, .single_byte_hl 		; > 
10db			;	cp 'G' 
10db			;	jr nc, .single_byte_hl 		; > 
10db			;	cp '0' 
10db			;	jr c, .single_byte_hl		; < 
10db			 
10db				;call isdigithl 
10db fe 00			cp 0 
10dd 28 06			jr z, .single_byte_hl 
10df			 
10df			.getwhln:   ; hex word so get next byte 
10df			 
10df cd 72 10			call get_byte 
10e2 6f				ld l, a 
10e3 60				ld h,b 
10e4 c9				ret 
10e5 68			.single_byte_hl:   ld l,b 
10e6 26 00				ld h,0 
10e8 c9					ret 
10e9			 
10e9			 
10e9			 
10e9			 
10e9 21 11 1a			ld hl,asc+1 
10ec			;	ld a, (hl) 
10ec			;	call nibble2val 
10ec cd 72 10			call get_byte 
10ef			 
10ef			;	call fourehexhl 
10ef 32 48 ee			ld (scratch+52),a 
10f2				 
10f2 21 46 ee			ld hl,scratch+50 
10f5 22 37 f1			ld (os_cur_ptr),hl 
10f8			 
10f8 c9				ret 
10f9			 
10f9			 
10f9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10f9			 
10f9			; Decimal Unsigned Version 
10f9			 
10f9			;Number in a to decimal ASCII 
10f9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10f9			;Example: display a=56 as "056" 
10f9			;input: a = number 
10f9			;Output: a=0,value of a in the screen 
10f9			;destroys af,bc (don't know about hl and de) 
10f9			DispAToASCII: 
10f9 0e 9c			ld	c,-100 
10fb cd 05 11			call	.Na1 
10fe 0e f6			ld	c,-10 
1100 cd 05 11			call	.Na1 
1103 0e ff			ld	c,-1 
1105 06 2f		.Na1:	ld	b,'0'-1 
1107 04			.Na2:	inc	b 
1108 81				add	a,c 
1109 38 fc			jr	c,.Na2 
110b 91				sub	c		;works as add 100/10/1 
110c f5				push af		;safer than ld c,a 
110d 78				ld	a,b		;char is in b 
110e			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
110e f1				pop af		;safer than ld a,c 
110f c9				ret 
1110			 
1110			; Decimal Signed Version 
1110			 
1110			; DispA 
1110			; -------------------------------------------------------------- 
1110			; Converts a signed integer value to a zero-terminated ASCII 
1110			; string representative of that value (using radix 10). 
1110			; -------------------------------------------------------------- 
1110			; INPUTS: 
1110			;     HL     Value to convert (two's complement integer). 
1110			;     DE     Base address of string destination. (pointer). 
1110			; -------------------------------------------------------------- 
1110			; OUTPUTS: 
1110			;     None 
1110			; -------------------------------------------------------------- 
1110			; REGISTERS/MEMORY DESTROYED 
1110			; AF HL 
1110			; -------------------------------------------------------------- 
1110			 
1110			;DispHLToASCII: 
1110			;   push    de 
1110			;   push    bc 
1110			; 
1110			;; Detect sign of HL. 
1110			;    bit    7, h 
1110			;    jr     z, ._DoConvert 
1110			; 
1110			;; HL is negative. Output '-' to string and negate HL. 
1110			;    ld     a, '-' 
1110			;    ld     (de), a 
1110			;    inc    de 
1110			; 
1110			;; Negate HL (using two's complement) 
1110			;    xor    a 
1110			;    sub    l 
1110			;    ld     l, a 
1110			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1110			;    sbc    a, h 
1110			;    ld     h, a 
1110			; 
1110			;; Convert HL to digit characters 
1110			;._DoConvert: 
1110			;    ld     b, 0     ; B will count character length of number 
1110			;-   ld     a, 10 
1110			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1110			;    push   af 
1110			;    inc    b 
1110			;    ld     a, h 
1110			;    or     l 
1110			;    jr     nz, - 
1110			; 
1110			;; Retrieve digits from stack 
1110			;-   pop    af 
1110			;    or     $30 
1110			;    ld     (de), a 
1110			;    inc    de 
1110			;    djnz   - 
1110			; 
1110			;; Terminate string with NULL 
1110			;    xor    a 
1110			;    ld     (de), a 
1110			; 
1110			;    pop    bc 
1110			;    pop    de 
1110			;    ret 
1110			 
1110			;Comments 
1110			; 
1110			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1110			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1110			;    Note that the output string will not be fixed-width. 
1110			; 
1110			;Example Usage 
1110			; 
1110			;    ld    hl, -1004 
1110			;    ld    de, OP1 
1110			;    call  DispA 
1110			;    ld    hl, OP1 
1110			;    syscall  PutS 
1110			 
1110			 
1110			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1110			 
1110			 
1110			;Converts an ASCII string to an unsigned 16-bit integer 
1110			;Quits when it reaches a non-decimal digit 
1110			 
1110			string_to_uint16: 
1110			atoui_16: 
1110			;Input: 
1110			;     DE points to the string 
1110			;Outputs: 
1110			;     HL is the result 
1110			;     A is the 8-bit value of the number 
1110			;     DE points to the byte after the number 
1110			;Destroys: 
1110			;     BC 
1110			;       if the string is non-empty, BC is HL/10 
1110			;Size:  24 bytes 
1110			;Speed: 42+d(104+{0,9}) 
1110			;       d is the number of digits in the number 
1110			;       max is 640 cycles for a 5 digit number 
1110			;Assuming no leading zeros: 
1110			;1 digit:  146cc 
1110			;2 digit:  250cc 
1110			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1110			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1110			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1110			;avg: 544.81158447265625cc (544+13297/16384) 
1110			;=============================================================== 
1110 21 00 00		  ld hl,0 
1113			.u16a: 
1113 1a			  ld a,(de) 
1114 d6 30		  sub 30h 
1116 fe 0a		  cp 10 
1118 d0			  ret nc 
1119 13			  inc de 
111a 44			  ld b,h 
111b 4d			  ld c,l 
111c 29			  add hl,hl 
111d 29			  add hl,hl 
111e 09			  add hl,bc 
111f 29			  add hl,hl 
1120 85			  add a,l 
1121 6f			  ld l,a 
1122 30 ef		  jr nc,.u16a 
1124 24			  inc h 
1125 c3 13 11		  jp .u16a 
1128			 
1128			 
1128			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1128			 
1128			;written by Zeda 
1128			;Converts a 16-bit unsigned integer to an ASCII string. 
1128			 
1128			uitoa_16: 
1128			;Input: 
1128			;   DE is the number to convert 
1128			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1128			;Output: 
1128			;   HL points to the null-terminated ASCII string 
1128			;      NOTE: This isn't necessarily the same as the input HL. 
1128 d5			  push de 
1129 c5			  push bc 
112a f5			  push af 
112b eb			  ex de,hl 
112c			 
112c 01 f0 d8		  ld bc,-10000 
112f 3e 2f		  ld a,'0'-1 
1131 3c			  inc a 
1132 09			  add hl,bc  
1133 38 fc		   jr c,$-2 
1135 12			  ld (de),a 
1136 13			  inc de 
1137			 
1137 01 e8 03		  ld bc,1000 
113a 3e 3a		  ld a,'9'+1 
113c 3d			  dec a  
113d 09			  add hl,bc  
113e 30 fc		   jr nc,$-2 
1140 12			  ld (de),a 
1141 13			  inc de 
1142			 
1142 01 9c ff		  ld bc,-100 
1145 3e 2f		  ld a,'0'-1 
1147 3c			  inc a  
1148 09			  add hl,bc  
1149 38 fc		   jr c,$-2 
114b 12			  ld (de),a 
114c 13			  inc de 
114d			 
114d 7d			  ld a,l 
114e 26 3a		  ld h,'9'+1 
1150 25			  dec h  
1151 c6 0a		  add a,10  
1153 30 fb		   jr nc,$-3 
1155 c6 30		  add a,'0' 
1157 eb			  ex de,hl 
1158 72			  ld (hl),d 
1159 23			  inc hl 
115a 77			  ld (hl),a 
115b 23			  inc hl 
115c 36 00		  ld (hl),0 
115e			 
115e			;Now strip the leading zeros 
115e 0e fa		  ld c,-6 
1160 09			  add hl,bc 
1161 3e 30		  ld a,'0' 
1163 23			  inc hl  
1164 be			  cp (hl)  
1165 28 fc		  jr z,$-2 
1167			 
1167			;Make sure that the string is non-empty! 
1167 7e			  ld a,(hl) 
1168 b7			  or a 
1169 20 01		  jr nz,.atoub 
116b 2b			  dec hl 
116c			.atoub: 
116c			 
116c f1			  pop af 
116d c1			  pop bc 
116e d1			  pop de 
116f c9			  ret 
1170			 
1170			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1170			 
1170			toUpper: 
1170			;A is the char. 
1170			;If A is a lowercase letter, this sets it to the matching uppercase 
1170			;18cc or 30cc or 41cc 
1170			;avg: 26.75cc 
1170 fe 61		  cp 'a' 
1172 d8			  ret c 
1173 fe 7b		  cp 'z'+1 
1175 d0			  ret nc 
1176 d6 20		  sub 'a'-'A' 
1178 c9			  ret 
1179			 
1179			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1179			 
1179			; String Length 
1179			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1179			 
1179			; Get the length of the null-terminated string starting at $8000 hl 
1179			;    LD     HL, $8000 
1179			 
1179			strlenz: 
1179			 
1179 af			    XOR    A               ; Zero is the value we are looking for. 
117a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
117b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
117c			                           ; 65, 536 bytes (the entire addressable memory space). 
117c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
117e			 
117e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
117e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
117f 6f			    LD     L, A             ; number of bytes 
1180 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1182 2b			    DEC    HL              ; Compensate for null. 
1183 c9				ret 
1184			 
1184			; Get the length of the A terminated string starting at $8000 hl 
1184			;    LD     HL, $8000 
1184			 
1184			strlent: 
1184			 
1184			                  ; A is the value we are looking for. 
1184 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1186 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1188			                           ; 65, 536 bytes (the entire addressable memory space). 
1188 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
118a			 
118a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
118a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
118c 2e 00		    LD     L, 0             ; number of bytes 
118e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1190 2b			    DEC    HL              ; Compensate for null. 
1191 c9				ret 
1192			 
1192			 
1192			;Comparing Strings 
1192			 
1192			;IN    HL     Address of string1. 
1192			;      DE     Address of string2. 
1192			 
1192			; doc given but wrong??? 
1192			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1192			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1192			; tested 
1192			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1192			 
1192			strcmp_old: 
1192 e5			    PUSH   HL 
1193 d5			    PUSH   DE 
1194			 
1194 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1195 be			    CP     (HL)            ; (want to minimize work). 
1196 38 01		    JR     C, Str1IsBigger 
1198 7e			    LD     A, (HL) 
1199			 
1199			Str1IsBigger: 
1199 4f			    LD     C, A             ; Put length in BC 
119a 06 00		    LD     B, 0 
119c 13			    INC    DE              ; Increment pointers to meat of string. 
119d 23			    INC    HL 
119e			 
119e			CmpLoop: 
119e 1a			    LD     A, (DE)          ; Compare bytes. 
119f ed a1		    CPI 
11a1 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11a3 13			    INC    DE              ; Update pointer. 
11a4 ea 9e 11		    JP     PE, CmpLoop 
11a7			 
11a7 d1			    POP    DE 
11a8 e1			    POP    HL 
11a9 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
11aa be			    CP     (HL) 
11ab c9			    RET 
11ac			 
11ac			NoMatch: 
11ac 2b			    DEC    HL 
11ad be			    CP     (HL)            ; Compare again to affect carry. 
11ae d1			    POP    DE 
11af e1			    POP    HL 
11b0 c9			    RET 
11b1			 
11b1			;; test strmp 
11b1			; 
11b1			;ld de, .str1 
11b1			;ld hl, .str2 
11b1			;call strcmp 
11b1			;jr z, .z1 
11b1			;;this 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "NZ1" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			;.z1: 
11b1			; 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "ZZ1" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			; 
11b1			;ld de, .str1 
11b1			;ld hl, .str1 
11b1			;call strcmp 
11b1			;jr z, .z2 
11b1			;;this 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "NZ2" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			;.z2: 
11b1			; 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "ZZ2" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			; 
11b1			;ld de, .str1 
11b1			;ld hl, .str2 
11b1			;call strcmp 
11b1			;jr c, .c1 
11b1			; 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "Nc1" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			;.c1: 
11b1			;;this 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "cc1" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			; 
11b1			;ld de, .str1 
11b1			;ld hl, .str1 
11b1			;call strcmp 
11b1			;jr c, .c2 
11b1			;;this 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "Nc2" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			;.c2: 
11b1			; 
11b1			;	if DEBUG_FORTH_WORDS 
11b1			;		DMARK "cc2" 
11b1			;		CALLMONITOR 
11b1			;	endif 
11b1			;	NEXTW 
11b1			;.str1:   db "string1",0 
11b1			;.str2:   db "string2",0 
11b1			 
11b1			; only care about direct match or not 
11b1			; hl and de strings 
11b1			; zero set if the same 
11b1			 
11b1			strcmp: 
11b1 1a				ld a, (de) 
11b2 be				cp (hl) 
11b3 28 02			jr z, .ssame 
11b5 b7				or a 
11b6 c9				ret 
11b7			 
11b7			.ssame:  
11b7 fe 00			cp 0 
11b9 c8				ret z 
11ba			 
11ba 23				inc hl 
11bb 13				inc de 
11bc 18 f3			jr strcmp 
11be				 
11be				 
11be			 
11be			 
11be			 
11be			 
11be			; eof 
11be			 
11be			 
11be			 
11be			 
11be			 
11be			 
# End of file firmware_strings.asm
11be			include "firmware_memory.asm"   ; malloc and free  
11be			 
11be			if DEBUG_FORTH_MALLOC_HIGH 
11be			.mallocsize: db "Wants malloc >256",0 
11be			.mallocasize: db "MALLOC gives >256",0 
11be			.malloczero: db "MALLOC gives zero",0 
11be			 
11be			malloc_guard_zerolen: 
11be				push hl 
11be				push de 
11be				push af 
11be			 
11be				ld de, 0 
11be			        call cmp16 
11be				jr nz, .lowalloz 
11be			 
11be				push hl 
11be				push de 
11be					ld hl, display_fb0 
11be					ld (display_fb_active), hl 
11be				call clear_display 
11be				ld a, 0 
11be				ld de, .malloczero 
11be				call str_at_display 
11be				call update_display 
11be				call delay1s 
11be				call delay1s 
11be				ld a, 0 
11be				ld (os_view_disable), a 
11be			 
11be				pop de 
11be				pop hl 
11be			 
11be				 
11be			 
11be				CALLMONITOR 
11be			.lowalloz: 
11be			 
11be			 
11be				pop af 
11be				pop de 
11be				pop hl 
11be			ret 
11be			 
11be			malloc_guard_entry: 
11be				push hl 
11be				push de 
11be				push af 
11be			 
11be			 	or a      ;clear carry flag 
11be				push hl 
11be				ld de, 255 
11be				sbc hl, de 
11be				jr c, .lowalloc 
11be			 
11be				push de 
11be					ld hl, display_fb0 
11be					ld (display_fb_active), hl 
11be				call clear_display 
11be				ld a, 0 
11be				ld de, .mallocsize 
11be				call str_at_display 
11be				call update_display 
11be				call delay1s 
11be				call delay1s 
11be				ld a, 0 
11be				ld (os_view_disable), a 
11be			 
11be				pop de 
11be				pop hl 
11be			 
11be				 
11be			 
11be				CALLMONITOR 
11be				jr .lowdone 
11be			.lowalloc: 
11be			 
11be			 
11be				pop hl 
11be			.lowdone:	pop af 
11be				pop de 
11be				pop hl 
11be			ret 
11be			 
11be			malloc_guard_exit: 
11be				push hl 
11be				push de 
11be				push af 
11be			 
11be			 	or a      ;clear carry flag 
11be				push hl 
11be				ld de, 255 
11be				sbc hl, de 
11be				jr c, .lowallocx 
11be			 
11be				push de 
11be					ld hl, display_fb0 
11be					ld (display_fb_active), hl 
11be				call clear_display 
11be				ld a, 0 
11be				ld de, .mallocasize 
11be				call str_at_display 
11be				call update_display 
11be				call delay1s 
11be				call delay1s 
11be				ld a, 0 
11be				ld (os_view_disable), a 
11be				pop de 
11be				pop hl 
11be			 
11be				CALLMONITOR 
11be				jr .lowdonex 
11be			.lowallocx: 
11be			 
11be				pop hl 
11be			.lowdonex:	pop af 
11be				pop de 
11be				pop hl 
11be			ret 
11be			endif 
11be			 
11be			if MALLOC_2 
11be			; Z80 Malloc and Free Functions 
11be			 
11be			; Malloc Function: 
11be			; Input: 
11be			;   HL: Size of block to allocate 
11be			; Output: 
11be			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11be			 
11be			malloc: 
11be				 
11be			if DEBUG_FORTH_MALLOC_HIGH 
11be			call malloc_guard_entry 
11be			endif 
11be			 
11be			 
11be			 
11be			 
11be					if DEBUG_FORTH_MALLOC 
11be						DMARK "mal" 
11be						CALLMONITOR 
11be					endif 
11be			    push af            ; Save AF register 
11be			    ld a, l            ; Load low byte of size into A 
11be			    or h               ; Check if size is zero 
11be			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11be			 
11be			    ; Allocate memory 
11be			    ld hl, (heap_start) ; Load start of heap into HL 
11be					if DEBUG_FORTH_MALLOC 
11be						DMARK "ma1" 
11be						CALLMONITOR 
11be					endif 
11be			    call malloc_internal ; Call internal malloc function 
11be			    pop af             ; Restore AF register 
11be			if DEBUG_FORTH_MALLOC_HIGH 
11be			call malloc_guard_exit 
11be			call malloc_guard_zerolen 
11be			endif 
11be			    ret                ; Return 
11be			 
11be			; Free Function: 
11be			; Input: 
11be			;   HL: Pointer to memory block to free 
11be			; Output: 
11be			;   None 
11be			 
11be			free: 
11be			    push af            ; Save AF register 
11be			    ld a, l            ; Load low byte of pointer into A 
11be			    or h               ; Check if pointer is NULL 
11be			    jp z, free_exit    ; If pointer is NULL, exit 
11be			 
11be			    ; Free memory 
11be			    ld hl, (heap_start) ; Load start of heap into HL 
11be			    call free_internal  ; Call internal free function 
11be			    pop af             ; Restore AF register 
11be			    ret                ; Return 
11be			 
11be			; Internal Malloc Function: 
11be			; Input: 
11be			;   HL: Size of block to allocate 
11be			; Output: 
11be			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11be			 
11be			malloc_internal: 
11be			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11be			    add hl, bc         ; Add management overhead to requested size 
11be			    ex de, hl          ; Save total size in DE, and keep it in HL 
11be					if DEBUG_FORTH_MALLOC 
11be						DMARK "ma2" 
11be						CALLMONITOR 
11be					endif 
11be			 
11be			    ; Search for free memory block 
11be			    ld de, (heap_end)  ; Load end of heap into DE 
11be			    ld bc, 0           ; Initialize counter 
11be			 
11be					if DEBUG_FORTH_MALLOC 
11be						DMARK "ma2" 
11be						CALLMONITOR 
11be					endif 
11be			malloc_search_loop: 
11be			    ; Check if current block is free 
11be			    ld a, (hl)         ; Load current block's status (free or used) 
11be			    cp 0               ; Compare with zero (free) 
11be			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11be			 
11be			    ; Check if current block is large enough 
11be			    ld a, (hl+1)       ; Load high byte of block size 
11be			    cp l               ; Compare with low byte of requested size 
11be			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11be			 
11be			    ld a, (hl+2)       ; Load low byte of block size 
11be			    cp h               ; Compare with high byte of requested size 
11be			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11be			 
11be			    ; Mark block as used 
11be			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11be			 
11be			    ; Calculate remaining space in block 
11be			    ld bc, 0           ; Clear BC 
11be			    add hl, bc         ; Increment HL to point to start of data block 
11be			    add hl, de         ; HL = HL + DE (total size) 
11be			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11be			    add hl, bc         ; Add management overhead to start of data block 
11be			 
11be			    ; Save pointer to allocated block in HL 
11be			if DEBUG_FORTH_MALLOC_HIGH 
11be						DMARK "ma5" 
11be			call malloc_guard_exit 
11be			call malloc_guard_zerolen 
11be			endif 
11be			    ret 
11be			 
11be			malloc_skip_block_check: 
11be			    ; Move to the next block 
11be			    ld bc, 3           ; Size of management overhead 
11be			    add hl, bc         ; Move to the next block 
11be			    inc de             ; Increment counter 
11be			 
11be			    ; Check if we have reached the end of heap 
11be			    ld a, e            ; Load low byte of heap end address 
11be			    cp (hl)            ; Compare with low byte of current address 
11be			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11be			    ld a, d            ; Load high byte of heap end address 
11be			    cp 0               ; Check if it's zero (end of memory) 
11be			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11be			 
11be			    ; If we reached here, allocation failed 
11be			    xor a              ; Set result to NULL 
11be			if DEBUG_FORTH_MALLOC_HIGH 
11be						DMARK "ma6" 
11be			call malloc_guard_exit 
11be			call malloc_guard_zerolen 
11be			endif 
11be			    ret 
11be			malloc_exit: 
11be			if DEBUG_FORTH_MALLOC_HIGH 
11be						DMARK "ma7" 
11be			call malloc_guard_exit 
11be			call malloc_guard_zerolen 
11be			endif 
11be			    ret 
11be			 
11be			; Internal Free Function: 
11be			; Input: 
11be			;   HL: Pointer to memory block to free 
11be			; Output: 
11be			;   None 
11be			 
11be			free_internal: 
11be			    ld de, (heap_start) ; Load start of heap into DE 
11be			    ld bc, 0            ; Initialize counter 
11be			 
11be			free_search_loop: 
11be			    ; Check if current block contains the pointer 
11be			    ld a, l             ; Load low byte of pointer 
11be			    cp (hl+1)           ; Compare with high byte of current block's address 
11be			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11be			    ld a, h             ; Load high byte of pointer 
11be			    cp (hl+2)           ; Compare with low byte of current block's address 
11be			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11be			 
11be			    ; Mark block as free 
11be			    ld (hl), 0          ; Set status byte to indicate free block 
11be			    ret                 ; Return 
11be			 
11be			free_skip_block_check: 
11be			    ; Move to the next block 
11be			    ld bc, 3            ; Size of management overhead 
11be			    add hl, bc          ; Move to the next block 
11be			    inc de              ; Increment counter 
11be			 
11be			    ; Check if we have reached the end of heap 
11be			    ld a, e             ; Load low byte of heap end address 
11be			    cp (hl)             ; Compare with low byte of current address 
11be			    jr nz, free_search_loop  ; If not equal, continue searching 
11be			    ld a, d             ; Load high byte of heap end address 
11be			    cp 0                ; Check if it's zero (end of memory) 
11be			    jr nz, free_search_loop  ; If not zero, continue searching 
11be			 
11be			    ; If we reached here, pointer is not found in heap 
11be			    ret 
11be			 
11be			free_exit: 
11be			    ret                 ; Return 
11be			 
11be			; Define heap start and end addresses 
11be			;heap_start:    .dw 0xC000   ; Start of heap 
11be			;heap_end:      .dw 0xE000   ; End of heap 
11be			 
11be			endif 
11be			 
11be			 
11be			if MALLOC_1 
11be			 
11be			 
11be			 
11be			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11be			 
11be			;moved to firmware.asm 
11be			;heap_start        .equ  0x9000      ; Starting address of heap 
11be			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11be			 
11be			;      .org 0 
11be			;      jp    main 
11be			 
11be			 
11be			;      .org  0x100 
11be			;main: 
11be			;      ld    HL, 0x8100 
11be			;      ld    SP, HL 
11be			; 
11be			;      call  heap_init 
11be			; 
11be			;      ; Make some allocations 
11be			;      ld    HL, 12 
11be			;      call  malloc            ; Allocates 0x9004 
11be			; 
11be			;      ld    HL, 12 
11be			;      call  malloc            ; Allocates 0x9014 
11be			; 
11be			;      ld    HL, 12 
11be			;      call  malloc            ; Allocates 0x9024 
11be			; 
11be			;      ; Free some allocations 
11be			;      ld    HL, 0x9014 
11be			;      call  free 
11be			; 
11be			;      ld    HL, 0x9004 
11be			;      call  free 
11be			; 
11be			;      ld    HL, 0x9024 
11be			;      call  free 
11be			; 
11be			; 
11be			;      halt 
11be			 
11be			 
11be			;------------------------------------------------------------------------------ 
11be			;     heap_init                                                               : 
11be			;                                                                             : 
11be			; Description                                                                 : 
11be			;     Initialise the heap and make it ready for malloc and free operations.   : 
11be			;                                                                             : 
11be			;     The heap is maintained as a linked list, starting with an initial       : 
11be			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11be			;     the first free block in the heap. Each block then points to the next    : 
11be			;     free block within the heap, and the free list ends at the first block   : 
11be			;     with a null pointer to the next free block.                             : 
11be			;                                                                             : 
11be			; Parameters                                                                  : 
11be			;     Inputs are compile-time only. Two defines which specify the starting    : 
11be			;     address of the heap and its size are required, along with a memory      : 
11be			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11be			;     principally stores a pointer to the first free block in the heap.       : 
11be			;                                                                             : 
11be			; Returns                                                                     : 
11be			;     Nothing                                                                 : 
11be			;------------------------------------------------------------------------------ 
11be			heap_init: 
11be e5			      push  HL 
11bf			 
11bf			      ; Initialise free list struct 
11bf 21 0e 80		      ld    HL, heap_start 
11c2 22 0a 80		      ld    (free_list), HL 
11c5 21 00 00		      ld    HL, 0 
11c8 22 0c 80		      ld    (free_list+2), HL 
11cb			 
11cb			      ; Insert first free block at bottom of heap, consumes entire heap 
11cb 21 f6 ed		      ld    HL, heap_start+heap_size-4 
11ce 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11d1 21 e8 6d		      ld    HL, heap_size-4 
11d4 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11d7			 
11d7			      ; Insert end of free list block at top of heap - two null words will 
11d7			      ; terminate the free list 
11d7 21 00 00		      ld    HL, 0 
11da 22 f8 ed		      ld    (heap_start+heap_size-2), HL 
11dd 22 f6 ed		      ld    (heap_start+heap_size-4), HL 
11e0			 
11e0 e1			      pop   HL 
11e1			 
11e1 c9			      ret 
11e2			 
11e2			 
11e2			;------------------------------------------------------------------------------ 
11e2			;     malloc                                                                  : 
11e2			;                                                                             : 
11e2			; Description                                                                 : 
11e2			;     Allocates the wanted space from the heap and returns the address of the : 
11e2			;     first useable byte of the allocation.                                   : 
11e2			;                                                                             : 
11e2			;     Allocations can happen in one of two ways:                              : 
11e2			;                                                                             : 
11e2			;     1. A free block may be found which is the exact size wanted. In this    : 
11e2			;        case the block is removed from the free list and retuedn to the      : 
11e2			;        caller.                                                              : 
11e2			;     2. A free block may be found which is larger than the size wanted. In   : 
11e2			;        this case, the larger block is split into two. The first portion of  : 
11e2			;        this block will become the requested space by the malloc call and    : 
11e2			;        is returned to the caller. The second portion becomes a new free     : 
11e2			;        block, and the free list is adjusted to maintain continuity via this : 
11e2			;        newly created block.                                                 : 
11e2			;                                                                             : 
11e2			;     malloc does not set any initial value in the allocated space, the       : 
11e2			;     caller is required to do this as required.                              : 
11e2			;                                                                             : 
11e2			;     This implementation of malloc uses the stack exclusively, and is        : 
11e2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11e2			;     advisable to disable interrupts before calling malloc, and recommended  : 
11e2			;     to avoid the use of malloc inside ISRs in general.                      : 
11e2			;                                                                             : 
11e2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11e2			;                                                                             : 
11e2			; Parameters                                                                  : 
11e2			;     HL  Number of bytes wanted                                              : 
11e2			;                                                                             : 
11e2			; Returns                                                                     : 
11e2			;     HL  Address of the first useable byte of the allocation                 : 
11e2			;                                                                             : 
11e2			; Flags                                                                       : 
11e2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11e2			;                                                                             : 
11e2			; Stack frame                                                                 : 
11e2			;       |             |                                                       : 
11e2			;       +-------------+                                                       : 
11e2			;       |     BC      |                                                       : 
11e2			;       +-------------+                                                       : 
11e2			;       |     DE      |                                                       : 
11e2			;       +-------------+                                                       : 
11e2			;       |     IX      |                                                       : 
11e2			;       +-------------+                                                       : 
11e2			;       |  prev_free  |                                                       : 
11e2			;   +4  +-------------+                                                       : 
11e2			;       |  this_free  |                                                       : 
11e2			;   +2  +-------------+                                                       : 
11e2			;       |  next_free  |                                                       : 
11e2			;   +0  +-------------+                                                       : 
11e2			;       |             |                                                       : 
11e2			;                                                                             : 
11e2			;------------------------------------------------------------------------------ 
11e2			 
11e2			 
11e2			;malloc: 
11e2			; 
11e2			;	SAVESP ON 1 
11e2			; 
11e2			;	call malloc_code 
11e2			; 
11e2			;	CHECKSP ON 1 
11e2			;	ret 
11e2			 
11e2			 
11e2			malloc: 
11e2 c5			      push  BC 
11e3 d5			      push  DE 
11e4 dd e5		      push  IX 
11e6			if DEBUG_FORTH_MALLOC_HIGH 
11e6			call malloc_guard_entry 
11e6			endif 
11e6			 
11e6					if DEBUG_FORTH_MALLOC 
11e6						DMARK "mal" 
11e6						CALLMONITOR 
11e6					endif 
11e6 7c			      ld    A, H                    ; Exit if no space requested 
11e7 b5			      or    L 
11e8 ca a7 12		      jp    Z, malloc_early_exit 
11eb			 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			; 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			;inc hl 
11eb			 
11eb			 
11eb			 
11eb			 
11eb					if DEBUG_FORTH_MALLOC 
11eb						DMARK "maA" 
11eb						CALLMONITOR 
11eb					endif 
11eb			      ; Set up stack frame 
11eb eb			      ex    DE, HL 
11ec 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11ef 39			      add   HL, SP 
11f0 f9			      ld    SP, HL 
11f1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11f5 dd 39		      add   IX, SP 
11f7			 
11f7			      ; Setup initial state 
11f7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11fa 19			      add   HL, DE 
11fb			 
11fb 44			      ld    B, H                    ; Move want to BC 
11fc 4d			      ld    C, L 
11fd			 
11fd 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1200 dd 75 04		      ld    (IX+4), L 
1203 dd 74 05		      ld    (IX+5), H 
1206			 
1206 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1207 23			      inc   HL 
1208 56			      ld    D, (HL) 
1209 dd 73 02		      ld    (IX+2), E 
120c dd 72 03		      ld    (IX+3), D 
120f eb			      ex    DE, HL                  ; this_free ptr into HL 
1210			 
1210					if DEBUG_FORTH_MALLOC 
1210						DMARK "maB" 
1210						CALLMONITOR 
1210					endif 
1210			      ; Loop through free block list to find some space 
1210			malloc_find_space: 
1210 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1211 23			      inc   HL 
1212 56			      ld    D, (HL) 
1213			 
1213 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1214 b3			      or    E 
1215 ca a1 12		      jp    Z, malloc_no_space 
1218			 
1218 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
121b dd 72 01		      ld    (IX+1), D 
121e			 
121e			      ; Does this block have enough space to make the allocation? 
121e 23			      inc   HL                      ; Load free block size into DE 
121f 5e			      ld    E, (HL) 
1220 23			      inc   HL 
1221 56			      ld    D, (HL) 
1222			 
1222 eb			      ex    DE, HL                  ; Check size of block against want 
1223 b7			      or    A                       ; Ensure carry flag clear 
1224 ed 42		      sbc   HL, BC 
1226 e5			      push  HL                      ; Store the result for later (new block size) 
1227			 
1227 ca 76 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
122a 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
122c			 
122c			      ; this_free block is not big enough, setup ptrs to test next free block 
122c e1			      pop   HL                      ; Discard previous result 
122d			 
122d dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1230 dd 66 03		      ld    H, (IX+3) 
1233 dd 75 04		      ld    (IX+4), L 
1236 dd 74 05		      ld    (IX+5), H 
1239			 
1239 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
123c dd 66 01		      ld    H, (IX+1) 
123f dd 75 02		      ld    (IX+2), L 
1242 dd 74 03		      ld    (IX+3), H 
1245			 
1245					if DEBUG_FORTH_MALLOC 
1245						DMARK "MA>" 
1245						CALLMONITOR 
1245					endif 
1245 18 c9		      jr    malloc_find_space 
1247			 
1247			      ; split a bigger block into two - requested size and remaining size 
1247			malloc_alloc_split: 
1247					if DEBUG_FORTH_MALLOC 
1247						DMARK "MAs" 
1247						CALLMONITOR 
1247					endif 
1247 eb			      ex    DE, HL                  ; Calculate address of new free block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b 09			      add   HL, BC 
124c			 
124c			      ; Create a new block and point it at next_free 
124c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
124f dd 56 01		      ld    D, (IX+1) 
1252			 
1252 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1253 23			      inc   HL 
1254 72			      ld    (HL), D 
1255			 
1255 d1			      pop   DE                      ; Store size of new block into new block 
1256 23			      inc   HL 
1257 73			      ld    (HL), E 
1258 23			      inc   HL 
1259 72			      ld    (HL), D 
125a			 
125a			      ; Update this_free ptr to point to new block 
125a 2b			      dec   HL 
125b 2b			      dec   HL 
125c 2b			      dec   HL 
125d			 
125d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1260 dd 56 03		      ld    D, (IX+3) 
1263			 
1263 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1266 dd 74 03		      ld    (IX+3), H 
1269			 
1269			      ; Modify this_free block to be allocation 
1269 eb			      ex    DE, HL 
126a af			      xor   A                       ; Null the next block ptr of allocated block 
126b 77			      ld    (HL), A 
126c 23			      inc   HL 
126d 77			      ld    (HL), A 
126e			 
126e 23			      inc   HL                      ; Store want size into allocated block 
126f 71			      ld    (HL), C 
1270 23			      inc   HL 
1271 70			      ld    (HL), B 
1272 23			      inc   HL 
1273 e5			      push  HL                      ; Address of allocation to return 
1274			 
1274 18 19		      jr    malloc_update_links 
1276			 
1276			malloc_alloc_fit: 
1276 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1277			 
1277					if DEBUG_FORTH_MALLOC 
1277						DMARK "MAf" 
1277						CALLMONITOR 
1277					endif 
1277			      ; Modify this_free block to be allocation 
1277 eb			      ex    DE, HL 
1278 2b			      dec   HL 
1279 2b			      dec   HL 
127a 2b			      dec   HL 
127b			 
127b af			      xor   A                       ; Null the next block ptr of allocated block 
127c 77			      ld    (HL), A 
127d 23			      inc   HL 
127e 77			      ld    (HL), A 
127f			 
127f 23			      inc   HL                      ; Store address of allocation to return 
1280 23			      inc   HL 
1281 23			      inc   HL 
1282 e5			      push  HL 
1283			 
1283			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1283 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1286 dd 66 01		      ld    H, (IX+1) 
1289			 
1289 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
128c dd 74 03		      ld    (IX+3), H 
128f			 
128f			 
128f			malloc_update_links: 
128f			      ; Update prev_free ptr to point to this_free 
128f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1292 dd 66 05		      ld    H, (IX+5) 
1295			 
1295 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1298 dd 56 03		      ld    D, (IX+3) 
129b			 
129b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
129c 23			      inc   HL 
129d 72			      ld    (HL), D 
129e			 
129e					if DEBUG_FORTH_MALLOC 
129e						DMARK "Mul" 
129e						CALLMONITOR 
129e					endif 
129e			      ; Clear the Z flag to indicate successful allocation 
129e 7a			      ld    A, D 
129f b3			      or    E 
12a0			 
12a0 d1			      pop   DE                      ; Address of allocation 
12a1					if DEBUG_FORTH_MALLOC 
12a1						DMARK "MAu" 
12a1						CALLMONITOR 
12a1					endif 
12a1			 
12a1			malloc_no_space: 
12a1 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6			 
12a6 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
12a7					if DEBUG_FORTH_MALLOC 
12a7						DMARK "MAN" 
12a7						CALLMONITOR 
12a7					endif 
12a7			 
12a7			malloc_early_exit: 
12a7					if DEBUG_FORTH_MALLOC 
12a7						DMARK "MAx" 
12a7						CALLMONITOR 
12a7					endif 
12a7 dd e1		      pop   IX 
12a9 d1			      pop   DE 
12aa c1			      pop   BC 
12ab			 
12ab			if DEBUG_FORTH_MALLOC_HIGH 
12ab			call malloc_guard_exit 
12ab			call malloc_guard_zerolen 
12ab			endif 
12ab c9			      ret 
12ac			 
12ac			 
12ac			;------------------------------------------------------------------------------ 
12ac			;     free                                                                    : 
12ac			;                                                                             : 
12ac			; Description                                                                 : 
12ac			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12ac			;     returned by malloc, otherwise the behaviour is undefined.               : 
12ac			;                                                                             : 
12ac			;     Where possible, directly adjacent free blocks will be merged together   : 
12ac			;     into larger blocks to help ensure that the heap does not become         : 
12ac			;     excessively fragmented.                                                 : 
12ac			;                                                                             : 
12ac			;     free does not clear or set any other value into the freed space, and    : 
12ac			;     therefore its contents may be visible through subsequent malloc's. The  : 
12ac			;     caller should clear the freed space as required.                        : 
12ac			;                                                                             : 
12ac			;     This implementation of free uses the stack exclusively, and is          : 
12ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ac			;     advisable to disable interrupts before calling free, and recommended    : 
12ac			;     to avoid the use of free inside ISRs in general.                        : 
12ac			;                                                                             : 
12ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ac			;                                                                             : 
12ac			; Parameters                                                                  : 
12ac			;     HL  Pointer to address of first byte of allocation to be freed          : 
12ac			;                                                                             : 
12ac			; Returns                                                                     : 
12ac			;     Nothing                                                                 : 
12ac			;                                                                             : 
12ac			; Stack frame                                                                 : 
12ac			;       |             |                                                       : 
12ac			;       +-------------+                                                       : 
12ac			;       |     BC      |                                                       : 
12ac			;       +-------------+                                                       : 
12ac			;       |     DE      |                                                       : 
12ac			;       +-------------+                                                       : 
12ac			;       |     IX      |                                                       : 
12ac			;       +-------------+                                                       : 
12ac			;       |  prev_free  |                                                       : 
12ac			;   +2  +-------------+                                                       : 
12ac			;       |  next_free  |                                                       : 
12ac			;   +0  +-------------+                                                       : 
12ac			;       |             |                                                       : 
12ac			;                                                                             : 
12ac			;------------------------------------------------------------------------------ 
12ac			free: 
12ac c5			      push  BC 
12ad d5			      push  DE 
12ae dd e5		      push  IX 
12b0			 
12b0 7c			      ld    A, H                    ; Exit if ptr is null 
12b1 b5			      or    L 
12b2 ca 76 13		      jp    Z, free_early_exit 
12b5			 
12b5			      ; Set up stack frame 
12b5 eb			      ex    DE, HL 
12b6 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12b9 39			      add   HL, SP 
12ba f9			      ld    SP, HL 
12bb dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12bf dd 39		      add   IX, SP 
12c1			 
12c1			      ; The address in HL points to the start of the useable allocated space, 
12c1			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12c1			      ; address of the block itself. 
12c1 eb			      ex    DE, HL 
12c2 11 fc ff		      ld    DE, -4 
12c5 19			      add   HL, DE 
12c6			 
12c6			      ; An allocated block must have a null next block pointer in it 
12c6 7e			      ld    A, (HL) 
12c7 23			      inc   HL 
12c8 b6			      or    (HL) 
12c9 c2 71 13		      jp    NZ, free_done 
12cc			 
12cc 2b			      dec   HL 
12cd			 
12cd 44			      ld    B, H                    ; Copy HL to BC 
12ce 4d			      ld    C, L 
12cf			 
12cf			      ; Loop through the free list to find the first block with an address 
12cf			      ; higher than the block being freed 
12cf 21 0a 80		      ld    HL, free_list 
12d2			 
12d2			free_find_higher_block: 
12d2 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 2b			      dec   HL 
12d6			 
12d6 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12d9 dd 72 01		      ld    (IX+1), D 
12dc dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12df dd 74 03		      ld    (IX+3), H 
12e2			 
12e2 78			      ld    A, B                    ; Check if DE is greater than BC 
12e3 ba			      cp    D                       ; Compare MSB first 
12e4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12e6 30 04		      jr    NC, free_find_higher_block_skip 
12e8 79			      ld    A, C 
12e9 bb			      cp    E                       ; Then compare LSB 
12ea 38 08		      jr    C, free_found_higher_block 
12ec			 
12ec			free_find_higher_block_skip: 
12ec 7a			      ld    A, D                    ; Reached the end of the free list? 
12ed b3			      or    E 
12ee ca 71 13		      jp    Z, free_done 
12f1			 
12f1 eb			      ex    DE, HL 
12f2			 
12f2 18 de		      jr    free_find_higher_block 
12f4			 
12f4			free_found_higher_block: 
12f4			      ; Insert freed block between prev and next free blocks 
12f4 71			      ld    (HL), C                 ; Point prev free block to freed block 
12f5 23			      inc   HL 
12f6 70			      ld    (HL), B 
12f7			 
12f7 60			      ld    H, B                    ; Point freed block at next free block 
12f8 69			      ld    L, C 
12f9 73			      ld    (HL), E 
12fa 23			      inc   HL 
12fb 72			      ld    (HL), D 
12fc			 
12fc			      ; Check if the freed block is adjacent to the next free block 
12fc 23			      inc   HL                      ; Load size of freed block into HL 
12fd 5e			      ld    E, (HL) 
12fe 23			      inc   HL 
12ff 56			      ld    D, (HL) 
1300 eb			      ex    DE, HL 
1301			 
1301 09			      add   HL, BC                  ; Add addr of freed block and its size 
1302			 
1302 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1305 dd 56 01		      ld    D, (IX+1) 
1308			 
1308 b7			      or    A                       ; Clear the carry flag 
1309 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
130b 20 22		      jr    NZ, free_check_adjacent_to_prev 
130d			 
130d			      ; Freed block is adjacent to next, merge into one bigger block 
130d eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
130e 5e			      ld    E, (HL) 
130f 23			      inc   HL 
1310 56			      ld    D, (HL) 
1311 e5			      push  HL                      ; Save ptr to next block for later 
1312			 
1312 60			      ld    H, B                    ; Store ptr from next block into freed block 
1313 69			      ld    L, C 
1314 73			      ld    (HL), E 
1315 23			      inc   HL 
1316 72			      ld    (HL), D 
1317			 
1317 e1			      pop   HL                      ; Restore ptr to next block 
1318 23			      inc   HL                      ; Load size of next block into DE 
1319 5e			      ld    E, (HL) 
131a 23			      inc   HL 
131b 56			      ld    D, (HL) 
131c d5			      push  DE                      ; Save next block size for later 
131d			 
131d 60			      ld    H, B                    ; Load size of freed block into HL 
131e 69			      ld    L, C 
131f 23			      inc   HL 
1320 23			      inc   HL 
1321 5e			      ld    E, (HL) 
1322 23			      inc   HL 
1323 56			      ld    D, (HL) 
1324 eb			      ex    DE, HL 
1325			 
1325 d1			      pop   DE                      ; Restore size of next block 
1326 19			      add   HL, DE                  ; Add sizes of both blocks 
1327 eb			      ex    DE, HL 
1328			 
1328 60			      ld    H, B                    ; Store new bigger size into freed block 
1329 69			      ld    L, C 
132a 23			      inc   HL 
132b 23			      inc   HL 
132c 73			      ld    (HL), E 
132d 23			      inc   HL 
132e 72			      ld    (HL), D 
132f			 
132f			free_check_adjacent_to_prev: 
132f			      ; Check if the freed block is adjacent to the prev free block 
132f dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1332 dd 66 03		      ld    H, (IX+3) 
1335			 
1335 23			      inc   HL                      ; Size of prev free block into DE 
1336 23			      inc   HL 
1337 5e			      ld    E, (HL) 
1338 23			      inc   HL 
1339 56			      ld    D, (HL) 
133a 2b			      dec   HL 
133b 2b			      dec   HL 
133c 2b			      dec   HL 
133d			 
133d 19			      add   HL, DE                  ; Add prev block addr and size 
133e			 
133e b7			      or    A                       ; Clear the carry flag 
133f ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1341 20 2e		      jr    NZ, free_done 
1343			 
1343			      ; Freed block is adjacent to prev, merge into one bigger block 
1343 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1344 69			      ld    L, C 
1345 5e			      ld    E, (HL) 
1346 23			      inc   HL 
1347 56			      ld    D, (HL) 
1348 e5			      push  HL                      ; Save freed block ptr for later 
1349			 
1349 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
134c dd 66 03		      ld    H, (IX+3) 
134f 73			      ld    (HL), E 
1350 23			      inc   HL 
1351 72			      ld    (HL), D 
1352			 
1352 e1			      pop   HL                      ; Restore freed block ptr 
1353 23			      inc   HL                      ; Load size of freed block into DE 
1354 5e			      ld    E, (HL) 
1355 23			      inc   HL 
1356 56			      ld    D, (HL) 
1357 d5			      push  DE                      ; Save freed block size for later 
1358			 
1358 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
135b dd 66 03		      ld    H, (IX+3) 
135e 23			      inc   HL 
135f 23			      inc   HL 
1360 5e			      ld    E, (HL) 
1361 23			      inc   HL 
1362 56			      ld    D, (HL) 
1363			 
1363 e1			      pop   HL                      ; Add sizes of both blocks 
1364 19			      add   HL, DE 
1365 eb			      ex    DE, HL 
1366			 
1366 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369 dd 66 03		      ld    H, (IX+3) 
136c 23			      inc   HL 
136d 23			      inc   HL 
136e 73			      ld    (HL), E 
136f 23			      inc   HL 
1370 72			      ld    (HL), D 
1371			 
1371			free_done: 
1371 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1374 39			      add   HL, SP 
1375 f9			      ld    SP, HL 
1376			 
1376			free_early_exit: 
1376 dd e1		      pop   IX 
1378 d1			      pop   DE 
1379 c1			      pop   BC 
137a			 
137a c9			      ret 
137b			 
137b			; moved to firmware.asm 
137b			; 
137b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137b			;                  .dw   0 
137b			 
137b			 
137b			endif 
137b			 
137b			 
137b			if MALLOC_3 
137b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
137b			;heap_start        .equ  0x9000      ; Starting address of heap 
137b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
137b			; 
137b			 ;     .org 0 
137b			  ;    jp    main 
137b			; 
137b			; 
137b			 ;     .org  0x100 
137b			;main: 
137b			 ;     ld    HL, 0x8100 
137b			  ;    ld    SP, HL 
137b			; 
137b			;      call  heap_init 
137b			 
137b			      ; Make some allocations 
137b			;      ld    HL, 12 
137b			;      call  malloc            ; Allocates 0x9004 
137b			; 
137b			 ;     ld    HL, 12 
137b			;      call  malloc            ; Allocates 0x9014 
137b			 
137b			;      ld    HL, 12 
137b			;      call  malloc            ; Allocates 0x9024 
137b			 
137b			      ; Free some allocations 
137b			;      ld    HL, 0x9014 
137b			;      call  free 
137b			 
137b			;      ld    HL, 0x9004 
137b			;      call  free 
137b			; 
137b			;      ld    HL, 0x9024 
137b			;      call  free 
137b			 
137b			 
137b			 ;     halt 
137b			 
137b			 
137b			;------------------------------------------------------------------------------ 
137b			;     heap_init                                                               : 
137b			;                                                                             : 
137b			; Description                                                                 : 
137b			;     Initialise the heap and make it ready for malloc and free operations.   : 
137b			;                                                                             : 
137b			;     The heap is maintained as a linked list, starting with an initial       : 
137b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
137b			;     the first free block in the heap. Each block then points to the next    : 
137b			;     free block within the heap, and the free list ends at the first block   : 
137b			;     with a null pointer to the next free block.                             : 
137b			;                                                                             : 
137b			; Parameters                                                                  : 
137b			;     Inputs are compile-time only. Two defines which specify the starting    : 
137b			;     address of the heap and its size are required, along with a memory      : 
137b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
137b			;     principally stores a pointer to the first free block in the heap.       : 
137b			;                                                                             : 
137b			; Returns                                                                     : 
137b			;     Nothing                                                                 : 
137b			;------------------------------------------------------------------------------ 
137b			heap_init: 
137b			      push  HL 
137b			 
137b			      ; Initialise free list struct 
137b			      ld    HL, heap_start 
137b			      ld    (free_list), HL 
137b			      ld    HL, 0 
137b			      ld    (free_list+2), HL 
137b			 
137b			      ; Insert first free block at bottom of heap, consumes entire heap 
137b			      ld    HL, heap_start+heap_size-4 
137b			      ld    (heap_start), HL        ; Next block (end of free list) 
137b			      ld    HL, heap_size-4 
137b			      ld    (heap_start+2), HL      ; Block size 
137b			 
137b			      ; Insert end of free list block at top of heap - two null words will 
137b			      ; terminate the free list 
137b			      ld    HL, 0 
137b			      ld    (heap_start+heap_size-2), HL 
137b			      ld    (heap_start+heap_size-4), HL 
137b			 
137b			      pop   HL 
137b			 
137b			      ret 
137b			 
137b			 
137b			;------------------------------------------------------------------------------ 
137b			;     malloc                                                                  : 
137b			;                                                                             : 
137b			; Description                                                                 : 
137b			;     Allocates the wanted space from the heap and returns the address of the : 
137b			;     first useable byte of the allocation.                                   : 
137b			;                                                                             : 
137b			;     Allocations can happen in one of two ways:                              : 
137b			;                                                                             : 
137b			;     1. A free block may be found which is the exact size wanted. In this    : 
137b			;        case the block is removed from the free list and retuedn to the      : 
137b			;        caller.                                                              : 
137b			;     2. A free block may be found which is larger than the size wanted. In   : 
137b			;        this case, the larger block is split into two. The first portion of  : 
137b			;        this block will become the requested space by the malloc call and    : 
137b			;        is returned to the caller. The second portion becomes a new free     : 
137b			;        block, and the free list is adjusted to maintain continuity via this : 
137b			;        newly created block.                                                 : 
137b			;                                                                             : 
137b			;     malloc does not set any initial value in the allocated space, the       : 
137b			;     caller is required to do this as required.                              : 
137b			;                                                                             : 
137b			;     This implementation of malloc uses the stack exclusively, and is        : 
137b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137b			;     advisable to disable interrupts before calling malloc, and recommended  : 
137b			;     to avoid the use of malloc inside ISRs in general.                      : 
137b			;                                                                             : 
137b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137b			;                                                                             : 
137b			; Parameters                                                                  : 
137b			;     HL  Number of bytes wanted                                              : 
137b			;                                                                             : 
137b			; Returns                                                                     : 
137b			;     HL  Address of the first useable byte of the allocation                 : 
137b			;                                                                             : 
137b			; Flags                                                                       : 
137b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
137b			;                                                                             : 
137b			; Stack frame                                                                 : 
137b			;       |             |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |     BC      |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |     DE      |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |     IX      |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |  prev_free  |                                                       : 
137b			;   +4  +-------------+                                                       : 
137b			;       |  this_free  |                                                       : 
137b			;   +2  +-------------+                                                       : 
137b			;       |  next_free  |                                                       : 
137b			;   +0  +-------------+                                                       : 
137b			;       |             |                                                       : 
137b			;                                                                             : 
137b			;------------------------------------------------------------------------------ 
137b			malloc: 
137b			      push  BC 
137b			      push  DE 
137b			      push  IX 
137b			 
137b			      ld    A, H                    ; Exit if no space requested 
137b			      or    L 
137b			      jp    Z, malloc_early_exit 
137b			 
137b			      ; Set up stack frame 
137b			      ex    DE, HL 
137b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
137b			      add   HL, SP 
137b			      ld    SP, HL 
137b			      ld    IX, 0                   ; Use IX as a frame pointer 
137b			      add   IX, SP 
137b			 
137b			      ; Setup initial state 
137b			      ld    HL, 4                   ; want must also include space used by block struct 
137b			      add   HL, DE 
137b			 
137b			      ld    B, H                    ; Move want to BC 
137b			      ld    C, L 
137b			 
137b			      ld    HL, free_list           ; Store prev_free ptr to stack 
137b			      ld    (IX+4), L 
137b			      ld    (IX+5), H 
137b			 
137b			      ld    E, (HL)                 ; Store this_free ptr to stack 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      ld    (IX+2), E 
137b			      ld    (IX+3), D 
137b			      ex    DE, HL                  ; this_free ptr into HL 
137b			 
137b			      ; Loop through free block list to find some space 
137b			malloc_find_space: 
137b			      ld    E, (HL)                 ; Load next_free ptr into DE 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			 
137b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
137b			      or    E 
137b			      jp    Z, malloc_no_space 
137b			 
137b			      ld    (IX+0), E               ; Store next_free ptr to stack 
137b			      ld    (IX+1), D 
137b			 
137b			      ; Does this block have enough space to make the allocation? 
137b			      inc   HL                      ; Load free block size into DE 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			 
137b			      ex    DE, HL                  ; Check size of block against want 
137b			      or    A                       ; Ensure carry flag clear 
137b			      sbc   HL, BC 
137b			      push  HL                      ; Store the result for later (new block size) 
137b			 
137b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
137b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
137b			 
137b			      ; this_free block is not big enough, setup ptrs to test next free block 
137b			      pop   HL                      ; Discard previous result 
137b			 
137b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
137b			      ld    H, (IX+3) 
137b			      ld    (IX+4), L 
137b			      ld    (IX+5), H 
137b			 
137b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
137b			      ld    H, (IX+1) 
137b			      ld    (IX+2), L 
137b			      ld    (IX+3), H 
137b			 
137b			      jr    malloc_find_space 
137b			 
137b			      ; split a bigger block into two - requested size and remaining size 
137b			malloc_alloc_split: 
137b			      ex    DE, HL                  ; Calculate address of new free block 
137b			      dec   HL 
137b			      dec   HL 
137b			      dec   HL 
137b			      add   HL, BC 
137b			 
137b			      ; Create a new block and point it at next_free 
137b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
137b			      ld    D, (IX+1) 
137b			 
137b			      ld    (HL), E                 ; Store next_free ptr into new block 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			      pop   DE                      ; Store size of new block into new block 
137b			      inc   HL 
137b			      ld    (HL), E 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			      ; Update this_free ptr to point to new block 
137b			      dec   HL 
137b			      dec   HL 
137b			      dec   HL 
137b			 
137b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
137b			      ld    D, (IX+3) 
137b			 
137b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
137b			      ld    (IX+3), H 
137b			 
137b			      ; Modify this_free block to be allocation 
137b			      ex    DE, HL 
137b			      xor   A                       ; Null the next block ptr of allocated block 
137b			      ld    (HL), A 
137b			      inc   HL 
137b			      ld    (HL), A 
137b			 
137b			      inc   HL                      ; Store want size into allocated block 
137b			      ld    (HL), C 
137b			      inc   HL 
137b			      ld    (HL), B 
137b			      inc   HL 
137b			      push  HL                      ; Address of allocation to return 
137b			 
137b			      jr    malloc_update_links 
137b			 
137b			malloc_alloc_fit: 
137b			      pop   HL                      ; Dont need new block size, want is exact fit 
137b			 
137b			      ; Modify this_free block to be allocation 
137b			      ex    DE, HL 
137b			      dec   HL 
137b			      dec   HL 
137b			      dec   HL 
137b			 
137b			      xor   A                       ; Null the next block ptr of allocated block 
137b			      ld    (HL), A 
137b			      inc   HL 
137b			      ld    (HL), A 
137b			 
137b			      inc   HL                      ; Store address of allocation to return 
137b			      inc   HL 
137b			      inc   HL 
137b			      push  HL 
137b			 
137b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
137b			      ld    L, (IX+0)               ; next_free to HL 
137b			      ld    H, (IX+1) 
137b			 
137b			      ld    (IX+2), L               ; HL to this_free 
137b			      ld    (IX+3), H 
137b			 
137b			 
137b			malloc_update_links: 
137b			      ; Update prev_free ptr to point to this_free 
137b			      ld    L, (IX+4)               ; prev_free ptr to HL 
137b			      ld    H, (IX+5) 
137b			 
137b			      ld    E, (IX+2)               ; this_free ptr to DE 
137b			      ld    D, (IX+3) 
137b			 
137b			      ld    (HL), E                 ; this_free ptr into prev_free 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			      ; Clear the Z flag to indicate successful allocation 
137b			      ld    A, D 
137b			      or    E 
137b			 
137b			      pop   DE                      ; Address of allocation 
137b			 
137b			malloc_no_space: 
137b			      ld    HL, 6                   ; Clean up stack frame 
137b			      add   HL, SP 
137b			      ld    SP, HL 
137b			 
137b			      ex    DE, HL                  ; Alloc addr into HL for return 
137b			 
137b			malloc_early_exit: 
137b			      pop   IX 
137b			      pop   DE 
137b			      pop   BC 
137b			 
137b			      ret 
137b			 
137b			 
137b			;------------------------------------------------------------------------------ 
137b			;     free                                                                    : 
137b			;                                                                             : 
137b			; Description                                                                 : 
137b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
137b			;     returned by malloc, otherwise the behaviour is undefined.               : 
137b			;                                                                             : 
137b			;     Where possible, directly adjacent free blocks will be merged together   : 
137b			;     into larger blocks to help ensure that the heap does not become         : 
137b			;     excessively fragmented.                                                 : 
137b			;                                                                             : 
137b			;     free does not clear or set any other value into the freed space, and    : 
137b			;     therefore its contents may be visible through subsequent malloc's. The  : 
137b			;     caller should clear the freed space as required.                        : 
137b			;                                                                             : 
137b			;     This implementation of free uses the stack exclusively, and is          : 
137b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137b			;     advisable to disable interrupts before calling free, and recommended    : 
137b			;     to avoid the use of free inside ISRs in general.                        : 
137b			;                                                                             : 
137b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137b			;                                                                             : 
137b			; Parameters                                                                  : 
137b			;     HL  Pointer to address of first byte of allocation to be freed          : 
137b			;                                                                             : 
137b			; Returns                                                                     : 
137b			;     Nothing                                                                 : 
137b			;                                                                             : 
137b			; Stack frame                                                                 : 
137b			;       |             |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |     BC      |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |     DE      |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |     IX      |                                                       : 
137b			;       +-------------+                                                       : 
137b			;       |  prev_free  |                                                       : 
137b			;   +2  +-------------+                                                       : 
137b			;       |  next_free  |                                                       : 
137b			;   +0  +-------------+                                                       : 
137b			;       |             |                                                       : 
137b			;                                                                             : 
137b			;------------------------------------------------------------------------------ 
137b			free: 
137b			      push  BC 
137b			      push  DE 
137b			      push  IX 
137b			 
137b			      ld    A, H                    ; Exit if ptr is null 
137b			      or    L 
137b			      jp    Z, free_early_exit 
137b			 
137b			      ; Set up stack frame 
137b			      ex    DE, HL 
137b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
137b			      add   HL, SP 
137b			      ld    SP, HL 
137b			      ld    IX, 0                   ; Use IX as a frame pointer 
137b			      add   IX, SP 
137b			 
137b			      ; The address in HL points to the start of the useable allocated space, 
137b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
137b			      ; address of the block itself. 
137b			      ex    DE, HL 
137b			      ld    DE, -4 
137b			      add   HL, DE 
137b			 
137b			      ; An allocated block must have a null next block pointer in it 
137b			      ld    A, (HL) 
137b			      inc   HL 
137b			      or    (HL) 
137b			      jp    NZ, free_done 
137b			 
137b			      dec   HL 
137b			 
137b			      ld    B, H                    ; Copy HL to BC 
137b			      ld    C, L 
137b			 
137b			      ; Loop through the free list to find the first block with an address 
137b			      ; higher than the block being freed 
137b			      ld    HL, free_list 
137b			 
137b			free_find_higher_block: 
137b			      ld    E, (HL)                 ; Load next ptr from free block 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      dec   HL 
137b			 
137b			      ld    (IX+0), E               ; Save ptr to next free block 
137b			      ld    (IX+1), D 
137b			      ld    (IX+2), L               ; Save ptr to prev free block 
137b			      ld    (IX+3), H 
137b			 
137b			      ld    A, B                    ; Check if DE is greater than BC 
137b			      cp    D                       ; Compare MSB first 
137b			      jr    Z, $+4                  ; MSB the same, compare LSB 
137b			      jr    NC, free_find_higher_block_skip 
137b			      ld    A, C 
137b			      cp    E                       ; Then compare LSB 
137b			      jr    C, free_found_higher_block 
137b			 
137b			free_find_higher_block_skip: 
137b			      ld    A, D                    ; Reached the end of the free list? 
137b			      or    E 
137b			      jp    Z, free_done 
137b			 
137b			      ex    DE, HL 
137b			 
137b			      jr    free_find_higher_block 
137b			 
137b			free_found_higher_block: 
137b			      ; Insert freed block between prev and next free blocks 
137b			      ld    (HL), C                 ; Point prev free block to freed block 
137b			      inc   HL 
137b			      ld    (HL), B 
137b			 
137b			      ld    H, B                    ; Point freed block at next free block 
137b			      ld    L, C 
137b			      ld    (HL), E 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			      ; Check if the freed block is adjacent to the next free block 
137b			      inc   HL                      ; Load size of freed block into HL 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      ex    DE, HL 
137b			 
137b			      add   HL, BC                  ; Add addr of freed block and its size 
137b			 
137b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
137b			      ld    D, (IX+1) 
137b			 
137b			      or    A                       ; Clear the carry flag 
137b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
137b			      jr    NZ, free_check_adjacent_to_prev 
137b			 
137b			      ; Freed block is adjacent to next, merge into one bigger block 
137b			      ex    DE, HL                  ; Load next ptr from next block into DE 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      push  HL                      ; Save ptr to next block for later 
137b			 
137b			      ld    H, B                    ; Store ptr from next block into freed block 
137b			      ld    L, C 
137b			      ld    (HL), E 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			      pop   HL                      ; Restore ptr to next block 
137b			      inc   HL                      ; Load size of next block into DE 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      push  DE                      ; Save next block size for later 
137b			 
137b			      ld    H, B                    ; Load size of freed block into HL 
137b			      ld    L, C 
137b			      inc   HL 
137b			      inc   HL 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      ex    DE, HL 
137b			 
137b			      pop   DE                      ; Restore size of next block 
137b			      add   HL, DE                  ; Add sizes of both blocks 
137b			      ex    DE, HL 
137b			 
137b			      ld    H, B                    ; Store new bigger size into freed block 
137b			      ld    L, C 
137b			      inc   HL 
137b			      inc   HL 
137b			      ld    (HL), E 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			free_check_adjacent_to_prev: 
137b			      ; Check if the freed block is adjacent to the prev free block 
137b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
137b			      ld    H, (IX+3) 
137b			 
137b			      inc   HL                      ; Size of prev free block into DE 
137b			      inc   HL 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      dec   HL 
137b			      dec   HL 
137b			      dec   HL 
137b			 
137b			      add   HL, DE                  ; Add prev block addr and size 
137b			 
137b			      or    A                       ; Clear the carry flag 
137b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
137b			      jr    NZ, free_done 
137b			 
137b			      ; Freed block is adjacent to prev, merge into one bigger block 
137b			      ld    H, B                    ; Load next ptr from freed block into DE 
137b			      ld    L, C 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      push  HL                      ; Save freed block ptr for later 
137b			 
137b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
137b			      ld    H, (IX+3) 
137b			      ld    (HL), E 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			      pop   HL                      ; Restore freed block ptr 
137b			      inc   HL                      ; Load size of freed block into DE 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			      push  DE                      ; Save freed block size for later 
137b			 
137b			      ld    L, (IX+2)               ; Load size of prev block into DE 
137b			      ld    H, (IX+3) 
137b			      inc   HL 
137b			      inc   HL 
137b			      ld    E, (HL) 
137b			      inc   HL 
137b			      ld    D, (HL) 
137b			 
137b			      pop   HL                      ; Add sizes of both blocks 
137b			      add   HL, DE 
137b			      ex    DE, HL 
137b			 
137b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
137b			      ld    H, (IX+3) 
137b			      inc   HL 
137b			      inc   HL 
137b			      ld    (HL), E 
137b			      inc   HL 
137b			      ld    (HL), D 
137b			 
137b			free_done: 
137b			      ld    HL, 4                   ; Clean up stack frame 
137b			      add   HL, SP 
137b			      ld    SP, HL 
137b			 
137b			free_early_exit: 
137b			      pop   IX 
137b			      pop   DE 
137b			      pop   BC 
137b			 
137b			      ret 
137b			 
137b			 
137b			;      .org 0x8000 
137b			; 
137b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137b			 ;                 .dw   0 
137b			 
137b			endif 
137b			 
137b			 
137b			if MALLOC_4 
137b			 
137b			; My memory allocation code. Very very simple.... 
137b			; allocate space under 250 chars 
137b			 
137b			heap_init: 
137b				; init start of heap as zero 
137b				;  
137b			 
137b				ld hl, heap_start 
137b				ld a, 0 
137b				ld (hl), a      ; empty block 
137b				inc hl 
137b				ld a, 0 
137b				ld (hl), a      ; length of block 
137b				; write end of list 
137b				inc hl 
137b				ld a,(hl) 
137b				inc hl 
137b				ld a,(hl) 
137b				 
137b			 
137b				; init some malloc vars 
137b			 
137b				ld hl, 0 
137b				ld (free_list), hl       ; store last malloc location 
137b			 
137b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
137b				ld a, 0 
137b				ld (hl), a 
137b			 
137b			 
137b				ld hl, heap_start 
137b				;  
137b				  
137b				ret 
137b			 
137b			 
137b			;    free block marker 
137b			;    requested size  
137b			;    pointer to next block 
137b			;    .... 
137b			;    next block marker 
137b			 
137b			 
137b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
137b			; 
137b			 
137b			 
137b			malloc:  
137b				push de 
137b				push bc 
137b				push af 
137b			 
137b				; hl space required 
137b				 
137b				ld c, l    ; hold space   (TODO only a max of 255) 
137b			 
137b			;	inc c     ; TODO BUG need to fix memory leak on push str 
137b			;	inc c 
137b			;	inc c 
137b			;	inc c 
137b			;	inc c 
137b			;	inc c 
137b			;	inc c 
137b			 
137b			 
137b			 
137b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
137b			 
137b				ld a, (free_list+3) 
137b				cp 0 
137b				jr z, .contheap 
137b			 
137b				ld hl, (free_list)     ; get last alloc 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "mrs" 
137b						CALLMONITOR 
137b					endif 
137b				jr .startalloc 
137b			 
137b			.contheap: 
137b				ld hl, heap_start 
137b			 
137b			.startalloc: 
137b			 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "mym" 
137b						CALLMONITOR 
137b					endif 
137b			.findblock: 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "mmf" 
137b						CALLMONITOR 
137b					endif 
137b			 
137b				ld a,(hl)  
137b				; if byte is zero then clear to use 
137b			 
137b				cp 0 
137b				jr z, .foundemptyblock 
137b			 
137b				; if byte is not clear 
137b				;     then byte is offset to next block 
137b			 
137b				inc hl 
137b				ld a, (hl) ; get size 
137b			.nextblock:	inc hl 
137b					ld e, (hl) 
137b					inc hl 
137b					ld d, (hl) 
137b					ex de, hl 
137b			;	inc hl  ; move past the store space 
137b			;	inc hl  ; move past zero index  
137b			 
137b				; TODO detect no more space 
137b			 
137b				push hl 
137b				ld de, heap_end 
137b				call cmp16 
137b				pop hl 
137b				jr nc, .nospace 
137b			 
137b				jr .findblock 
137b			 
137b			.nospace: ld hl, 0 
137b				jp .exit 
137b			 
137b			 
137b			.foundemptyblock:	 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "mme" 
137b						CALLMONITOR 
137b					endif 
137b			 
137b			; TODO has block enough space if reusing??? 
137b			 
137b				;  
137b			 
137b			; see if this block has been previously used 
137b				inc hl 
137b				ld a, (hl) 
137b				dec hl 
137b				cp 0 
137b				jr z, .newblock 
137b			 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "meR" 
137b						CALLMONITOR 
137b					endif 
137b			 
137b			; no reusing previously allocated block 
137b			 
137b			; is it smaller than previously used? 
137b				 
137b				inc hl    ; move to size 
137b				ld a, c 
137b				sub (hl)        ; we want c < (hl) 
137b				dec hl    ; move back to marker 
137b			        jr z, .findblock 
137b			 
137b				; update with the new size which should be lower 
137b			 
137b			        ;inc  hl   ; negate next move. move back to size  
137b			 
137b			.newblock: 
137b				; need to be at marker here 
137b			 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "meN" 
137b						CALLMONITOR 
137b					endif 
137b			 
137b			 
137b				ld a, c 
137b			 
137b				ld (free_list+3), a	 ; flag resume from last malloc  
137b				ld (free_list), hl    ; save out last location 
137b			 
137b			 
137b				;inc a     ; space for length byte 
137b				ld (hl), a     ; save block in use marker 
137b			 
137b				inc hl   ; move to space marker 
137b				ld (hl), a    ; save new space 
137b			 
137b				inc hl   ; move to start of allocated area 
137b				 
137b			;	push hl     ; save where we are - 1  
137b			 
137b			;	inc hl  ; move past zero index  
137b				; skip space to set down new marker 
137b			 
137b				; provide some extra space for now 
137b			 
137b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
137b				inc a 
137b				inc a 
137b			 
137b				push hl   ; save where we are in the node block 
137b			 
137b				call addatohl 
137b			 
137b				; write linked list point 
137b			 
137b				pop de     ; get our node position 
137b				ex de, hl 
137b			 
137b				ld (hl), e 
137b				inc hl 
137b				ld (hl), d 
137b			 
137b				inc hl 
137b			 
137b				; now at start of allocated data so save pointer 
137b			 
137b				push hl 
137b			 
137b				; jump to position of next node and setup empty header in DE 
137b			 
137b				ex de, hl 
137b			 
137b			;	inc hl ; move past end of block 
137b			 
137b				ld a, 0 
137b				ld (hl), a   ; empty marker 
137b				inc hl 
137b				ld (hl), a   ; size 
137b				inc hl  
137b				ld (hl), a   ; ptr 
137b				inc hl 
137b				ld (hl), a   ; ptr 
137b			 
137b			 
137b				pop hl 
137b			 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "mmr" 
137b						CALLMONITOR 
137b					endif 
137b			 
137b			.exit: 
137b				pop af 
137b				pop bc 
137b				pop de  
137b				ret 
137b			 
137b			 
137b			 
137b			 
137b			free:  
137b				push hl 
137b				push af 
137b				; get address in hl 
137b			 
137b					if DEBUG_FORTH_MALLOC_INT 
137b						DMARK "fre" 
137b						CALLMONITOR 
137b					endif 
137b				; data is at hl - move to block count 
137b				dec hl 
137b				dec hl    ; get past pointer 
137b				dec hl 
137b			 
137b				ld a, (hl)    ; need this for a validation check 
137b			 
137b				dec hl    ; move to block marker 
137b			 
137b				; now check that the block count and block marker are the same  
137b			        ; this checks that we are on a malloc node and not random memory 
137b			        ; OK a faint chance this could be a problem but rare - famous last words! 
137b			 
137b				ld c, a 
137b				ld a, (hl)    
137b			 
137b				cp c 
137b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
137b			 
137b				; yes good chance we are on a malloc node 
137b			 
137b				ld a, 0      
137b				ld (hl), a   ; mark as free 
137b			 
137b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
137b			 
137b			.freeignore:  
137b			 
137b				pop af 
137b				pop hl 
137b			 
137b				ret 
137b			 
137b			 
137b			 
137b			endif 
137b			 
137b			; eof 
# End of file firmware_memory.asm
137b			  
137b			; device C  
137b			if SOUND_ENABLE  
137b				include "firmware_sound.asm"  
137b			; Sound abstraction layer 
137b			 
137b			; support different sound chips through common interface 
137b			 
137b			SOUND_DEVICE_AY: equ 0 
137b			 
137b			SOUND_DEVICE: equ Device_A 
137b			 
137b			 
137b			 
137b			if SOUND_DEVICE_AY 
137b				include "firmware_sound_ay38910.asm" 
137b			else 
137b				include "firmware_sound_sn76489an.asm" 
137b			 
137b			; Device support for SN76489AN sound chip 
137b			 
137b			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
137b			; http://danceswithferrets.org/geekblog/?p=93 
137b			; https://www.smspower.org/Development/SN76489 
137b			 
137b			; D0 [ 3] 
137b			; D1 [ 2] 
137b			; D2 [ 1] 
137b			; D3 [15] 
137b			; D4 [13] 
137b			; D5 [12] 
137b			; D6 [11] 
137b			; D7 [10] 
137b			; /WE [ 5] 
137b			; CLK [14] 
137b			; /OE [ 6] 
137b			; AUDIO [ 7] 
137b			; GND 8 
137b			; +5 16 
137b			; 
137b			 
137b			; Write sequence: 
137b			; CE low 
137b			; Data bus 
137b			; WE low then high 
137b			; 32 clock cycles / 8ns write time at 4mhz 
137b			; 
137b			; https://github.com/jblang/SN76489 
137b			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
137b			; Tried: 
137b			; 
137b			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
137b			; 
137b			; Connected WE to OR too 
137b			;  
137b			; That enabled the clock when required 
137b			; However still random bus corruption. Need further investigation 
137b			 
137b			 
137b			SOUND_LATCH: equ 10000000B 
137b			SOUND_DATA: equ 0B 
137b			SOUND_CH0:  equ 0B    ; Tone 
137b			SOUND_CH1: equ 0100000B        ; Tone 
137b			SOUND_CH2: equ 1000000B   ; Tone 
137b			SOUND_CH3: equ 1100000B    ; Noise 
137b			SOUND_VOL: equ 10000B 
137b			SOUND_TONE: equ 0B 
137b			 
137b			 
137b			sound_init: 
137b 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
137d cd 92 13			call note_send_byte 
1380 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1382 cd 92 13			call note_send_byte 
1385 cd 58 0a			call delay250ms 
1388 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
138a cd 92 13			call note_send_byte 
138d cd 58 0a			call delay250ms 
1390 c9				ret 
1391			 
1391			; Play a note 
1391			; h = note 
1391			; l = duration 
1391			; a = channel 
1391			 
1391			 
1391			;  frequ = clock / ( 2 x reg valu x 32 )  
1391			 
1391			note:  
1391				 
1391			 
1391 c9				ret 
1392			 
1392			note_send_byte: 
1392				; byte in a 
1392			 
1392				; we high 
1392 d3 40			out (Device_B), a 
1394			;	ld a, 1 
1394			;	call aDelayInMS 
1394 00				nop  
1395 00				nop  
1396 00				nop  
1397 00				nop  
1398				; we low 
1398 d3 40			out (Device_B), a 
139a			;	ld a, 1 
139a			;	call aDelayInMS 
139a 00				nop  
139b 00				nop  
139c 00				nop  
139d 00				nop  
139e				; we high 
139e d3 40			out (Device_B), a 
13a0			;	ld a, 1 
13a0			;	call aDelayInMS 
13a0 00				nop  
13a1 00				nop  
13a2 00				nop  
13a3 00				nop  
13a4			 
13a4			 
13a4 c9				ret 
13a5			 
13a5			;void SilenceAllChannels() 
13a5			;{ 
13a5			;  SendByte(0x9f); 
13a5			;  SendByte(0xbf); 
13a5			;  SendByte(0xdf); 
13a5			;  SendByte(0xff); 
13a5			;} 
13a5			 
13a5			 
13a5			; eof 
13a5			 
# End of file firmware_sound_sn76489an.asm
13a5			endif 
13a5			 
13a5			 
13a5			; Abstraction entry points 
13a5			 
13a5			; init  
13a5			 
13a5			; sound_init in specific hardware files 
13a5			 
13a5			; Play a note 
13a5			; h = note 
13a5			; l = duration 
13a5			; a = channel 
13a5			 
13a5			;note:     
13a5			;	ret 
13a5			 
13a5			 
13a5			 
13a5			 
13a5			; eof 
13a5			 
# End of file firmware_sound.asm
13a5			endif  
13a5			  
13a5			include "firmware_diags.asm"  
13a5			; Hardware diags menu 
13a5			 
13a5			 
13a5			config: 
13a5			 
13a5 3e 00			ld a, 0 
13a7 21 d5 13			ld hl, .configmn 
13aa cd 18 0b			call menu 
13ad			 
13ad fe 00			cp 0 
13af c8				ret z 
13b0			 
13b0 fe 01			cp 1 
13b2 cc 3f 15			call z, .savetostore 
13b5			 
13b5 fe 02			cp 2 
13b7 cc 8d 14			call z, .selautoload 
13ba fe 03			cp 3 
13bc cc 76 14			call z, .disautoload 
13bf fe 04			cp 4 
13c1 cc 3d 15			call z, .selbank 
13c4 fe 05			cp 5 
13c6 cc 31 16			call z, .debug_tog 
13c9 fe 06			cp 6 
13cb cc 74 17			call z, .bpsgo 
13ce fe 07			cp 7 
13d0 cc 57 16			call z, hardware_diags 
13d3			 
13d3 18 d0			jr config 
13d5			 
13d5			.configmn: 
13d5 e5 13			dw .c3 
13d7 fc 13			dw .c2 
13d9 11 14			dw .c2a 
13db 27 14			dw .c2b 
13dd			;	dw .c4 
13dd 44 14			dw .m4 
13df 5f 14			dw .m4b 
13e1 67 14			dw .c1 
13e3 00 00			dw 0 
13e5				 
13e5			 
13e5 .. 00		.c3: db "Add Dictionary To File",0 
13fc .. 00		.c2: db "Select Autoload File",0 
1411 .. 00		.c2a: db "Disable Autoload File", 0 
1427 .. 00		.c2b: db "Select Storage Bank",0 
143b .. 00		.c4: db "Settings",0 
1444 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
145f .. 00		.m4b:   db "Monitor",0 
1467 .. 00		.c1: db "Hardware Diags",0 
1476			 
1476			 
1476			.disautoload: 
1476				if STORAGE_SE 
1476 3e fe			ld a, $fe      ; bit 0 clear 
1478 32 3f f8			ld (spi_device), a 
147b			 
147b cd b8 03			call storage_get_block_0 
147e			 
147e 3e 00			ld a, 0 
1480 32 7a f8			ld (store_page+STORE_0_AUTOFILE), a 
1483			 
1483 21 00 00				ld hl, 0 
1486 11 59 f8				ld de, store_page 
1489 cd 6c 03			call storage_write_block	 ; save update 
148c				else 
148c			 
148c				ld hl, .notav 
148c				ld de, .empty 
148c				call info_panel 
148c				endif 
148c			 
148c			 
148c c9				ret 
148d			 
148d			 
148d			 
148d			; Select auto start 
148d			 
148d			.selautoload: 
148d			 
148d				 
148d				if STORAGE_SE 
148d			 
148d cd 7b 15				call config_dir 
1490 21 14 ee			        ld hl, scratch 
1493 3e 00				ld a, 0 
1495 cd 18 0b				call menu 
1498			 
1498 fe 00				cp 0 
149a c8					ret z 
149b			 
149b 3d					dec a 
149c			 
149c			 
149c					; locate menu option 
149c			 
149c 21 14 ee				ld hl, scratch 
149f cd 3c 0a				call table_lookup 
14a2			 
14a2					if DEBUG_FORTH_WORDS 
14a2						DMARK "ALl" 
14a2 f5				push af  
14a3 3a b7 14			ld a, (.dmark)  
14a6 32 6e fb			ld (debug_mark),a  
14a9 3a b8 14			ld a, (.dmark+1)  
14ac 32 6f fb			ld (debug_mark+1),a  
14af 3a b9 14			ld a, (.dmark+2)  
14b2 32 70 fb			ld (debug_mark+2),a  
14b5 18 03			jr .pastdmark  
14b7 ..			.dmark: db "ALl"  
14ba f1			.pastdmark: pop af  
14bb			endm  
# End of macro DMARK
14bb						CALLMONITOR 
14bb cd 6a 17			call break_point_state  
14be				endm  
# End of macro CALLMONITOR
14be					endif 
14be					; with the pointer to the menu it, the byte following the zero term is the file id 
14be			 
14be 3e 00				ld a, 0 
14c0 01 32 00				ld bc, 50   ; max of bytes to look at 
14c3 ed b1				cpir  
14c5			 
14c5					if DEBUG_FORTH_WORDS 
14c5						DMARK "ALb" 
14c5 f5				push af  
14c6 3a da 14			ld a, (.dmark)  
14c9 32 6e fb			ld (debug_mark),a  
14cc 3a db 14			ld a, (.dmark+1)  
14cf 32 6f fb			ld (debug_mark+1),a  
14d2 3a dc 14			ld a, (.dmark+2)  
14d5 32 70 fb			ld (debug_mark+2),a  
14d8 18 03			jr .pastdmark  
14da ..			.dmark: db "ALb"  
14dd f1			.pastdmark: pop af  
14de			endm  
# End of macro DMARK
14de						CALLMONITOR 
14de cd 6a 17			call break_point_state  
14e1				endm  
# End of macro CALLMONITOR
14e1					endif 
14e1					;inc hl 
14e1			 
14e1 7e					ld a, (hl)   ; file id 
14e2					 
14e2				        ; save bank and file ids 
14e2			 
14e2 f5					push af 
14e3			 
14e3			; TODO need to save to block 0 on bank 1	 
14e3			 
14e3 cd b8 03				call storage_get_block_0 
14e6			 
14e6					if DEBUG_FORTH_WORDS 
14e6						DMARK "AL0" 
14e6 f5				push af  
14e7 3a fb 14			ld a, (.dmark)  
14ea 32 6e fb			ld (debug_mark),a  
14ed 3a fc 14			ld a, (.dmark+1)  
14f0 32 6f fb			ld (debug_mark+1),a  
14f3 3a fd 14			ld a, (.dmark+2)  
14f6 32 70 fb			ld (debug_mark+2),a  
14f9 18 03			jr .pastdmark  
14fb ..			.dmark: db "AL0"  
14fe f1			.pastdmark: pop af  
14ff			endm  
# End of macro DMARK
14ff						CALLMONITOR 
14ff cd 6a 17			call break_point_state  
1502				endm  
# End of macro CALLMONITOR
1502					endif 
1502 f1					pop af 
1503			 
1503 32 7d f8				ld (store_page+STORE_0_FILERUN),a 
1506					 
1506					; save bank id 
1506			 
1506 3a 3f f8				ld a,(spi_device) 
1509 32 7c f8				ld (store_page+STORE_0_BANKRUN),a 
150c			 
150c					; enable auto run of store file 
150c			 
150c 3e 01				ld a, 1 
150e 32 7a f8				ld (store_page+STORE_0_AUTOFILE),a 
1511			 
1511					; save buffer 
1511			 
1511 21 00 00				ld hl, 0 
1514 11 59 f8				ld de, store_page 
1517					if DEBUG_FORTH_WORDS 
1517						DMARK "ALw" 
1517 f5				push af  
1518 3a 2c 15			ld a, (.dmark)  
151b 32 6e fb			ld (debug_mark),a  
151e 3a 2d 15			ld a, (.dmark+1)  
1521 32 6f fb			ld (debug_mark+1),a  
1524 3a 2e 15			ld a, (.dmark+2)  
1527 32 70 fb			ld (debug_mark+2),a  
152a 18 03			jr .pastdmark  
152c ..			.dmark: db "ALw"  
152f f1			.pastdmark: pop af  
1530			endm  
# End of macro DMARK
1530						CALLMONITOR 
1530 cd 6a 17			call break_point_state  
1533				endm  
# End of macro CALLMONITOR
1533					endif 
1533 cd 6c 03			call storage_write_block	 ; save update 
1536			  
1536			 
1536			 
1536			 
1536 21 14 ee				ld hl, scratch 
1539 cd 68 15				call config_fdir 
153c			 
153c				else 
153c			 
153c				ld hl, .notav 
153c				ld de, .empty 
153c				call info_panel 
153c			 
153c				endif 
153c c9				ret 
153d			 
153d			 
153d			 
153d			; Select storage bank 
153d			 
153d			.selbank: 
153d			 
153d				if STORAGE_SE 
153d				else 
153d			 
153d				ld hl, .notav 
153d				ld de, .empty 
153d				call info_panel 
153d				endif 
153d				 
153d c9				ret 
153e			 
153e			if STORAGE_SE 
153e			 
153e			.config_ldir:   
153e				; Load storage bank labels into menu array 
153e			 
153e				 
153e			 
153e			 
153e c9				ret 
153f			 
153f			 
153f			endif 
153f			 
153f			 
153f			; Save user words to storage 
153f			 
153f			.savetostore: 
153f			 
153f				if STORAGE_SE 
153f			 
153f cd 7b 15				call config_dir 
1542 21 14 ee			        ld hl, scratch 
1545 3e 00				ld a, 0 
1547 cd 18 0b				call menu 
154a					 
154a 21 14 ee				ld hl, scratch 
154d cd 68 15				call config_fdir 
1550			 
1550				else 
1550			 
1550				ld hl, .notav 
1550				ld de, .empty 
1550				call info_panel 
1550			 
1550				endif 
1550			 
1550 c9				ret 
1551 .. 00		.notav:    db "Feature not available",0 
1567 .. 00		.empty:    db "",0 
1568			 
1568			 
1568			 
1568			if STORAGE_SE 
1568			 
1568			config_fdir: 
1568				; using the scratch dir go through and release the memory allocated for each string 
1568				 
1568 21 14 ee			ld hl, scratch 
156b 5e			.cfdir:	ld e,(hl) 
156c 23				inc hl 
156d 56				ld d,(hl) 
156e 23				inc hl 
156f			 
156f eb				ex de, hl 
1570 cd 44 0d			call ishlzero 
1573 c8				ret z     ; return on null pointer 
1574 cd ac 12			call free 
1577 eb				ex de, hl 
1578 18 f1			jr .cfdir 
157a			 
157a			 
157a c9				ret 
157b			 
157b			 
157b			config_dir: 
157b			 
157b				; for the config menus that need to build a directory of storage call this routine 
157b				; it will construct a menu in scratch to pass to menu 
157b			 
157b				; open storage device 
157b			 
157b				; execute DIR to build a list of files and their ids into scratch in menu format 
157b				; once the menu has finished then will need to call config_fdir to release the strings 
157b				 
157b				; c = number items 
157b			 
157b				 
157b cd b8 03			call storage_get_block_0 
157e			 
157e 21 59 f8			ld hl, store_page     ; get current id count 
1581 46				ld b, (hl) 
1582 0e 00			ld c, 0    ; count of files   
1584			 
1584			 
1584 21 14 ee			ld hl, scratch 
1587 22 55 f8			ld (store_tmp2), hl    ; location to poke strings 
158a			 
158a				; check for empty drive 
158a			 
158a 3e 00			ld a, 0 
158c b8				cp b 
158d ca 27 16			jp z, .dirdone 
1590			 
1590				 
1590					if DEBUG_FORTH_WORDS 
1590						DMARK "Cdc" 
1590 f5				push af  
1591 3a a5 15			ld a, (.dmark)  
1594 32 6e fb			ld (debug_mark),a  
1597 3a a6 15			ld a, (.dmark+1)  
159a 32 6f fb			ld (debug_mark+1),a  
159d 3a a7 15			ld a, (.dmark+2)  
15a0 32 70 fb			ld (debug_mark+2),a  
15a3 18 03			jr .pastdmark  
15a5 ..			.dmark: db "Cdc"  
15a8 f1			.pastdmark: pop af  
15a9			endm  
# End of macro DMARK
15a9						CALLMONITOR 
15a9 cd 6a 17			call break_point_state  
15ac				endm  
# End of macro CALLMONITOR
15ac					endif 
15ac			 
15ac			 
15ac			.diritem:	 
15ac c5				push bc 
15ad				; for each of the current ids do a search for them and if found push to stack 
15ad			 
15ad 21 40 00				ld hl, STORE_BLOCK_PHY 
15b0 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
15b2 58					ld e,b 
15b3			 
15b3 cd 2c 06				call storage_findnextid 
15b6			 
15b6			 
15b6					; if found hl will be non zero 
15b6			 
15b6 cd 44 0d				call ishlzero 
15b9 28 69				jr z, .dirnotfound 
15bb			 
15bb					; increase count 
15bb			 
15bb c1					pop bc	 
15bc 0c					inc c 
15bd c5					push bc 
15be					 
15be			 
15be					; get file header and push the file name 
15be			 
15be 11 59 f8				ld de, store_page 
15c1 cd 07 03				call storage_read_block 
15c4			 
15c4					; push file id to stack 
15c4				 
15c4 3a 59 f8				ld a, (store_page) 
15c7 26 00				ld h, 0 
15c9 6f					ld l, a 
15ca			 
15ca					;call forth_push_numhl 
15ca					; TODO store id 
15ca			 
15ca e5					push hl 
15cb			 
15cb					; push extent count to stack  
15cb				 
15cb 21 5c f8				ld hl, store_page+3 
15ce			 
15ce					; get file name length 
15ce			 
15ce cd 79 11				call strlenz   
15d1			 
15d1 23					inc hl   ; cover zero term 
15d2 23					inc hl  ; stick the id at the end of the area 
15d3			 
15d3 e5					push hl 
15d4 c1					pop bc    ; move length to bc 
15d5			 
15d5 cd e2 11				call malloc 
15d8			 
15d8					; TODO save malloc area to scratch 
15d8			 
15d8 eb					ex de, hl 
15d9 2a 55 f8				ld hl, (store_tmp2) 
15dc 73					ld (hl), e 
15dd 23					inc hl 
15de 72					ld (hl), d 
15df 23					inc hl 
15e0 22 55 f8				ld (store_tmp2), hl 
15e3			 
15e3					 
15e3			 
15e3					;pop hl   ; get source 
15e3			;		ex de, hl    ; swap aronund	 
15e3			 
15e3 21 5c f8				ld hl, store_page+3 
15e6					if DEBUG_FORTH_WORDS 
15e6						DMARK "CFd" 
15e6 f5				push af  
15e7 3a fb 15			ld a, (.dmark)  
15ea 32 6e fb			ld (debug_mark),a  
15ed 3a fc 15			ld a, (.dmark+1)  
15f0 32 6f fb			ld (debug_mark+1),a  
15f3 3a fd 15			ld a, (.dmark+2)  
15f6 32 70 fb			ld (debug_mark+2),a  
15f9 18 03			jr .pastdmark  
15fb ..			.dmark: db "CFd"  
15fe f1			.pastdmark: pop af  
15ff			endm  
# End of macro DMARK
15ff						CALLMONITOR 
15ff cd 6a 17			call break_point_state  
1602				endm  
# End of macro CALLMONITOR
1602					endif 
1602 ed b0				ldir 
1604			 
1604					; de is past string, move back one and store id 
1604					 
1604 1b					dec de 
1605			 
1605					; store file id 
1605			 
1605 e1					pop hl 
1606 eb					ex de,hl 
1607 73					ld (hl), e 
1608			 
1608					if DEBUG_FORTH_WORDS 
1608						DMARK "Cdi" 
1608 f5				push af  
1609 3a 1d 16			ld a, (.dmark)  
160c 32 6e fb			ld (debug_mark),a  
160f 3a 1e 16			ld a, (.dmark+1)  
1612 32 6f fb			ld (debug_mark+1),a  
1615 3a 1f 16			ld a, (.dmark+2)  
1618 32 70 fb			ld (debug_mark+2),a  
161b 18 03			jr .pastdmark  
161d ..			.dmark: db "Cdi"  
1620 f1			.pastdmark: pop af  
1621			endm  
# End of macro DMARK
1621						CALLMONITOR 
1621 cd 6a 17			call break_point_state  
1624				endm  
# End of macro CALLMONITOR
1624					endif 
1624					 
1624			.dirnotfound: 
1624 c1					pop bc     
1625 10 85				djnz .diritem 
1627				 
1627			.dirdone:	 
1627			 
1627 3e 00				ld a, 0 
1629 2a 55 f8				ld hl, (store_tmp2) 
162c 77					ld (hl), a 
162d 23					inc hl 
162e 77					ld (hl), a 
162f 23					inc hl 
1630					; push a count of the dir items found 
1630			 
1630			;		ld h, 0 
1630			;		ld l, c 
1630			 
1630 c9				ret 
1631			 
1631			endif 
1631			 
1631			 
1631			; Settings 
1631			; Run  
1631			 
1631			 
1631			 
1631			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1631			;;hd_menu2:   db "        2: Editor",0   
1631			;hd_menu2:   db "        2: Editor       6: Menu",0   
1631			;hd_menu3:   db "        3: Storage",0 
1631			;hd_menu4:   db "0=quit  4: Debug",0 
1631			;hd_don:     db "ON",0 
1631			;hd_doff:     db "OFF",0 
1631			; 
1631			; 
1631			; 
1631			;hardware_diags_old:       
1631			; 
1631			;.diagmenu: 
1631			;	call clear_display 
1631			;	ld a, display_row_1 
1631			;	ld de, hd_menu1 
1631			;	call str_at_display 
1631			; 
1631			;	ld a, display_row_2 
1631			;	ld de, hd_menu2 
1631			;	call str_at_display 
1631			; 
1631			;	ld a, display_row_3 
1631			;	ld de, hd_menu3 
1631			;	call str_at_display 
1631			; 
1631			;	ld a,  display_row_4 
1631			;	ld de, hd_menu4 
1631			;	call str_at_display 
1631			; 
1631			;	; display debug state 
1631			; 
1631			;	ld de, hd_don 
1631			;	ld a, (os_view_disable) 
1631			;	cp 0 
1631			;	jr z, .distog 
1631			;	ld de, hd_doff 
1631			;.distog: ld a, display_row_4+17 
1631			;	call str_at_display 
1631			; 
1631			;	call update_display 
1631			; 
1631			;	call cin_wait 
1631			; 
1631			; 
1631			; 
1631			;	cp '4' 
1631			;	jr nz, .diagn1 
1631			; 
1631			;	; debug toggle 
1631			; 
1631			;	ld a, (os_view_disable) 
1631			;	ld b, '*' 
1631			;	cp 0 
1631			;	jr z, .debtog 
1631			;	ld b, 0 
1631			;.debtog:	 
1631			;	ld a,b 
1631			;	ld (os_view_disable),a 
1631			; 
1631			;.diagn1: cp '0' 
1631			;	 ret z 
1631			; 
1631			;;	cp '1' 
1631			;;       jp z, matrix	 
1631			;;   TODO keyboard matrix test 
1631			; 
1631			;	cp '2' 
1631			;	jp z, .diagedit 
1631			; 
1631			;;	cp '6' 
1631			;;	jp z, .menutest 
1631			;;if ENABLE_BASIC 
1631			;;	cp '6' 
1631			;;	jp z, basic 
1631			;;endif 
1631			 ; 
1631			;	jp .diagmenu 
1631			; 
1631			; 
1631			;	ret 
1631			 
1631			 
1631			.debug_tog: 
1631 21 78 16			ld hl, .menudebug 
1634				 
1634 3a 05 ee			ld a, (os_view_disable) 
1637 fe 2a			cp '*' 
1639 20 04			jr nz,.tdon  
163b 3e 01			ld a, 1 
163d 18 02			jr .tog1 
163f 3e 00		.tdon: ld a, 0 
1641			 
1641			.tog1: 
1641 cd 18 0b			call menu 
1644 fe 00			cp 0 
1646 c8				ret z 
1647 fe 01			cp 1    ; disable debug 
1649 28 04			jr z, .dtog0 
164b 3e 2a			ld a, '*' 
164d 18 02			jr .dtogset 
164f 3e 00		.dtog0: ld a, 0 
1651 32 05 ee		.dtogset:  ld (os_view_disable), a 
1654 c3 31 16			jp .debug_tog 
1657			 
1657			 
1657			hardware_diags:       
1657			 
1657			.diagm: 
1657 21 6a 16			ld hl, .menuitems 
165a 3e 00			ld a, 0 
165c cd 18 0b			call menu 
165f			 
165f fe 00		         cp 0 
1661 c8				 ret z 
1662			 
1662 fe 02			cp 2 
1664 ca c3 16			jp z, .diagedit 
1667			 
1667			;	cp '6' 
1667			;	jp z, .menutest 
1667			;if ENABLE_BASIC 
1667			;	cp '6' 
1667			;	jp z, basic 
1667			;endif 
1667			  
1667 c3 57 16			jp .diagm 
166a			 
166a				 
166a 7e 16		.menuitems:   	dw .m1 
166c 89 16				dw .m2 
166e 90 16				dw .m3 
1670 98 16				dw .m5 
1672 9e 16				dw .m5a 
1674 a7 16				dw .m5b 
1676 00 00				dw 0 
1678			 
1678			.menudebug: 
1678 b0 16				dw .m6 
167a b9 16				dw .m7 
167c 00 00				dw 0 
167e			 
167e .. 00		.m1:   db "Key Matrix",0 
1689 .. 00		.m2:   db "Editor",0 
1690 .. 00		.m3:   db "Storage",0 
1698 .. 00		.m5:   db "Sound",0 
169e .. 00		.m5a:  db "RAM Test",0 
16a7 .. 00		.m5b:  db "LCD Test",0 
16b0			 
16b0 .. 00		.m6:   db "Debug ON",0 
16b9 .. 00		.m7:   db "Debug OFF",0 
16c3			 
16c3			; debug editor 
16c3			 
16c3			.diagedit: 
16c3			 
16c3 21 14 ee			ld hl, scratch 
16c6			;	ld bc, 250 
16c6			;	ldir 
16c6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16c6 3e 00			ld a, 0 
16c8 77				ld (hl), a 
16c9 23				inc hl 
16ca 77				ld (hl), a 
16cb 23				inc hl 
16cc 77				ld (hl), a 
16cd			 
16cd cd e7 0a		        call clear_display 
16d0 cd 0a 0b			call update_display 
16d3				;ld a, 1 
16d3				;ld (hardware_diag), a 
16d3			.diloop: 
16d3 3e 00			ld a, display_row_1 
16d5 0e 00			ld c, 0 
16d7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16d9 1e 28			ld e, 40 
16db			 
16db 21 14 ee			ld hl, scratch	 
16de cd 48 0d			call input_str 
16e1			 
16e1 3e 28			ld a, display_row_2 
16e3 11 14 ee			ld de, scratch 
16e6 cd fa 0a			call str_at_display 
16e9 cd 0a 0b			call update_display 
16ec			 
16ec c3 d3 16			jp .diloop 
16ef			 
16ef			 
16ef			; pass word in hl 
16ef			; a has display location 
16ef			display_word_at: 
16ef f5				push af 
16f0 e5				push hl 
16f1 7c				ld a,h 
16f2 21 19 f1			ld hl, os_word_scratch 
16f5 cd 1c 10			call hexout 
16f8 e1				pop hl 
16f9 7d				ld a,l 
16fa 21 1b f1			ld hl, os_word_scratch+2 
16fd cd 1c 10			call hexout 
1700 21 1d f1			ld hl, os_word_scratch+4 
1703 3e 00			ld a,0 
1705 77				ld (hl),a 
1706 11 19 f1			ld de,os_word_scratch 
1709 f1				pop af 
170a cd fa 0a				call str_at_display 
170d c9				ret 
170e			 
170e			display_ptr_state: 
170e			 
170e				; to restore afterwards 
170e			 
170e d5				push de 
170f c5				push bc 
1710 e5				push hl 
1711 f5				push af 
1712			 
1712				; for use in here 
1712			 
1712			;	push bc 
1712			;	push de 
1712			;	push hl 
1712			;	push af 
1712			 
1712 cd e7 0a			call clear_display 
1715			 
1715 11 e8 18			ld de, .ptrstate 
1718 3e 00			ld a, display_row_1 
171a cd fa 0a			call str_at_display 
171d			 
171d				; display debug step 
171d			 
171d			 
171d 11 6e fb			ld de, debug_mark 
1720 3e 26			ld a, display_row_1+display_cols-2 
1722 cd fa 0a			call str_at_display 
1725			 
1725				; display a 
1725 11 f2 18			ld de, .ptrcliptr 
1728 3e 28			ld a, display_row_2 
172a cd fa 0a			call str_at_display 
172d			 
172d f1				pop af 
172e 2a 1f f8			ld hl,(cli_ptr) 
1731 3e 30			ld a, display_row_2+8 
1733 cd ef 16			call display_word_at 
1736			 
1736			 
1736				; display hl 
1736			 
1736			 
1736 11 fa 18			ld de, .ptrclioptr 
1739 3e 32			ld a, display_row_2+10 
173b cd fa 0a			call str_at_display 
173e			; 
173e			;	pop hl 
173e 3e 35			ld a, display_row_2+13 
1740 2a 1d f8			ld hl,(cli_origptr) 
1743 cd ef 16			call display_word_at 
1746			; 
1746			;	 
1746			;	; display de 
1746			 
1746			;	ld de, .regstatede 
1746			;	ld a, display_row_3 
1746			;	call str_at_display 
1746			 
1746			;	pop de 
1746			;	ld h,d 
1746			;	ld l, e 
1746			;	ld a, display_row_3+3 
1746			;	call display_word_at 
1746			 
1746			 
1746				; display bc 
1746			 
1746			;	ld de, .regstatebc 
1746			;	ld a, display_row_3+10 
1746			;	call str_at_display 
1746			 
1746			;	pop bc 
1746			;	ld h,b 
1746			;	ld l, c 
1746			;	ld a, display_row_3+13 
1746			;	call display_word_at 
1746			 
1746			 
1746				; display dsp 
1746			 
1746			;	ld de, .regstatedsp 
1746			;	ld a, display_row_4 
1746			;	call str_at_display 
1746			 
1746				 
1746			;	ld hl,(cli_data_sp) 
1746			;	ld a, display_row_4+4 
1746			;	call display_word_at 
1746			 
1746				; display rsp 
1746			 
1746 11 29 19			ld de, .regstatersp 
1749 3e 82			ld a, display_row_4+10 
174b cd fa 0a			call str_at_display 
174e			 
174e				 
174e 2a 05 f8			ld hl,(cli_ret_sp) 
1751 3e 86			ld a, display_row_4+14 
1753 cd ef 16			call display_word_at 
1756			 
1756 cd 0a 0b			call update_display 
1759			 
1759 cd 64 0a			call delay1s 
175c cd 64 0a			call delay1s 
175f cd 64 0a			call delay1s 
1762			 
1762			 
1762 cd 72 1c			call next_page_prompt 
1765			 
1765				; restore  
1765			 
1765 f1				pop af 
1766 e1				pop hl 
1767 c1				pop bc 
1768 d1				pop de 
1769 c9				ret 
176a			 
176a			break_point_state: 
176a f5				push af 
176b			 
176b				; see if disabled 
176b			 
176b 3a 05 ee			ld a, (os_view_disable) 
176e fe 2a			cp '*' 
1770 20 02			jr nz, .bpsgo 
1772 f1				pop af 
1773 c9				ret 
1774			 
1774			.bpsgo: 
1774 f1				pop af 
1775 f5				push af 
1776 22 01 ee			ld (os_view_hl), hl 
1779 ed 53 ff ed		ld (os_view_de), de 
177d ed 43 fd ed		ld (os_view_bc), bc 
1781 e5				push hl 
1782 6f				ld l, a 
1783 26 00			ld h, 0 
1785 22 03 ee			ld (os_view_af),hl 
1788			 
1788 21 b4 fa				ld hl, display_fb0 
178b 22 cf f8				ld (display_fb_active), hl 
178e e1				pop hl	 
178f			 
178f 3e 31			ld a, '1' 
1791 fe 2a		.bps1:  cp '*' 
1793 20 03			jr nz, .bps1b 
1795 32 05 ee			ld (os_view_disable),a 
1798 fe 31		.bps1b:  cp '1' 
179a 20 14			jr nz, .bps2 
179c			 
179c				; display reg 
179c			 
179c				 
179c			 
179c 3a 03 ee			ld a, (os_view_af) 
179f 2a 01 ee			ld hl, (os_view_hl) 
17a2 ed 5b ff ed		ld de, (os_view_de) 
17a6 ed 4b fd ed		ld bc, (os_view_bc) 
17aa cd 44 18			call display_reg_state 
17ad c3 30 18			jp .bpschk 
17b0			 
17b0 fe 32		.bps2:  cp '2' 
17b2 20 08			jr nz, .bps3 
17b4				 
17b4				; display hl 
17b4 2a 01 ee			ld hl, (os_view_hl) 
17b7 cd 2e 19			call display_dump_at_hl 
17ba			 
17ba 18 74			jr .bpschk 
17bc			 
17bc fe 33		.bps3:  cp '3' 
17be 20 08			jr nz, .bps4 
17c0			 
17c0			        ; display de 
17c0 2a ff ed			ld hl, (os_view_de) 
17c3 cd 2e 19			call display_dump_at_hl 
17c6			 
17c6 18 68			jr .bpschk 
17c8 fe 34		.bps4:  cp '4' 
17ca 20 08			jr nz, .bps5 
17cc			 
17cc			        ; display bc 
17cc 2a fd ed			ld hl, (os_view_bc) 
17cf cd 2e 19			call display_dump_at_hl 
17d2			 
17d2 18 5c			jr .bpschk 
17d4 fe 35		.bps5:  cp '5' 
17d6 20 08		        jr nz, .bps7 
17d8			 
17d8				; display cur ptr 
17d8 2a 1f f8			ld hl, (cli_ptr) 
17db cd 2e 19			call display_dump_at_hl 
17de			 
17de 18 50			jr .bpschk 
17e0 fe 36		.bps7:  cp '6' 
17e2 20 08			jr nz, .bps8b 
17e4				 
17e4				; display cur orig ptr 
17e4 2a 1d f8			ld hl, (cli_origptr) 
17e7 cd 2e 19			call display_dump_at_hl 
17ea 18 44			jr .bpschk 
17ec fe 37		.bps8b:  cp '7' 
17ee 20 08			jr nz, .bps9 
17f0				 
17f0				; display dsp 
17f0 2a 01 f8			ld hl, (cli_data_sp) 
17f3 cd 2e 19			call display_dump_at_hl 
17f6			 
17f6 18 38			jr .bpschk 
17f8 fe 39		.bps9:  cp '9' 
17fa 20 05			jr nz, .bps8c 
17fc				 
17fc				; display SP 
17fc			;	ld hl, sp 
17fc cd 2e 19			call display_dump_at_hl 
17ff			 
17ff 18 2f			jr .bpschk 
1801 fe 38		.bps8c:  cp '8' 
1803 20 08			jr nz, .bps8d 
1805				 
1805				; display rsp 
1805 2a 05 f8			ld hl, (cli_ret_sp) 
1808 cd 2e 19			call display_dump_at_hl 
180b			 
180b 18 23			jr .bpschk 
180d fe 23		.bps8d:  cp '#'     ; access monitor sub system 
180f 20 05			jr nz, .bps8 
1811 cd 68 1a			call monitor 
1814			 
1814 18 1a			jr .bpschk 
1816 fe 30		.bps8:  cp '0' 
1818 20 16			jr nz, .bpschk 
181a			 
181a 21 13 fa				ld hl, display_fb1 
181d 22 cf f8				ld (display_fb_active), hl 
1820 cd 0a 0b				call update_display 
1823			 
1823				;ld a, (os_view_af) 
1823 2a 01 ee			ld hl, (os_view_hl) 
1826 ed 5b ff ed		ld de, (os_view_de) 
182a ed 4b fd ed		ld bc, (os_view_bc) 
182e f1				pop af 
182f c9				ret 
1830			 
1830			.bpschk:   
1830 cd 64 0a			call delay1s 
1833 3e 9f		ld a,display_row_4 + display_cols - 1 
1835 11 70 1c		        ld de, endprg 
1838 cd fa 0a			call str_at_display 
183b cd 0a 0b			call update_display 
183e cd 46 69			call cin_wait 
1841			 
1841 c3 91 17			jp .bps1 
1844			 
1844			 
1844			display_reg_state: 
1844			 
1844				; to restore afterwards 
1844			 
1844 d5				push de 
1845 c5				push bc 
1846 e5				push hl 
1847 f5				push af 
1848			 
1848				; for use in here 
1848			 
1848 c5				push bc 
1849 d5				push de 
184a e5				push hl 
184b f5				push af 
184c			 
184c cd e7 0a			call clear_display 
184f			 
184f 11 04 19			ld de, .regstate 
1852 3e 00			ld a, display_row_1 
1854 cd fa 0a			call str_at_display 
1857			 
1857				; display debug step 
1857			 
1857			 
1857 11 6e fb			ld de, debug_mark 
185a 3e 25			ld a, display_row_1+display_cols-3 
185c cd fa 0a			call str_at_display 
185f			 
185f				; display a 
185f 11 20 19			ld de, .regstatea 
1862 3e 28			ld a, display_row_2 
1864 cd fa 0a			call str_at_display 
1867			 
1867 e1				pop hl 
1868			;	ld h,0 
1868			;	ld l, a 
1868 3e 2b			ld a, display_row_2+3 
186a cd ef 16			call display_word_at 
186d			 
186d			 
186d				; display hl 
186d			 
186d			 
186d 11 14 19			ld de, .regstatehl 
1870 3e 32			ld a, display_row_2+10 
1872 cd fa 0a			call str_at_display 
1875			 
1875 e1				pop hl 
1876 3e 35			ld a, display_row_2+13 
1878 cd ef 16			call display_word_at 
187b			 
187b				 
187b				; display de 
187b			 
187b 11 18 19			ld de, .regstatede 
187e 3e 50			ld a, display_row_3 
1880 cd fa 0a			call str_at_display 
1883			 
1883 e1				pop hl 
1884			;	ld h,d 
1884			;	ld l, e 
1884 3e 53			ld a, display_row_3+3 
1886 cd ef 16			call display_word_at 
1889			 
1889			 
1889				; display bc 
1889			 
1889 11 1c 19			ld de, .regstatebc 
188c 3e 5a			ld a, display_row_3+10 
188e cd fa 0a			call str_at_display 
1891			 
1891 e1				pop hl 
1892			;	ld h,b 
1892			;	ld l, c 
1892 3e 5d			ld a, display_row_3+13 
1894 cd ef 16			call display_word_at 
1897			 
1897			 
1897				; display dsp 
1897			 
1897 11 24 19			ld de, .regstatedsp 
189a 3e 78			ld a, display_row_4 
189c cd fa 0a			call str_at_display 
189f			 
189f				 
189f 2a 01 f8			ld hl,(cli_data_sp) 
18a2 3e 7c			ld a, display_row_4+4 
18a4 cd ef 16			call display_word_at 
18a7			 
18a7				; display rsp 
18a7			 
18a7 11 29 19			ld de, .regstatersp 
18aa 3e 82			ld a, display_row_4+10 
18ac cd fa 0a			call str_at_display 
18af			 
18af				 
18af 2a 05 f8			ld hl,(cli_ret_sp) 
18b2 3e 86			ld a, display_row_4+14 
18b4 cd ef 16			call display_word_at 
18b7			 
18b7 cd 0a 0b			call update_display 
18ba			 
18ba			;	call delay1s 
18ba			;	call delay1s 
18ba			;	call delay1s 
18ba			 
18ba			 
18ba			;	call next_page_prompt 
18ba			 
18ba				; restore  
18ba			 
18ba f1				pop af 
18bb e1				pop hl 
18bc c1				pop bc 
18bd d1				pop de 
18be c9				ret 
18bf			 
18bf .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18d3 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18e8 .. 00		.ptrstate:	db "Ptr State",0 
18f2 .. 00		.ptrcliptr:     db "cli_ptr",0 
18fa .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1904 .. 00		.regstate:	db "Reg State (1/0)",0 
1914 .. 00		.regstatehl:	db "HL:",0 
1918 .. 00		.regstatede:	db "DE:",0 
191c .. 00		.regstatebc:	db "BC:",0 
1920 .. 00		.regstatea:	db "A :",0 
1924 .. 00		.regstatedsp:	db "DSP:",0 
1929 .. 00		.regstatersp:	db "RSP:",0 
192e			 
192e			display_dump_at_hl: 
192e e5				push hl 
192f d5				push de 
1930 c5				push bc 
1931 f5				push af 
1932			 
1932 22 37 f1			ld (os_cur_ptr),hl	 
1935 cd e7 0a			call clear_display 
1938 cd 7a 1b			call dumpcont 
193b			;	call delay1s 
193b			;	call next_page_prompt 
193b			 
193b			 
193b f1				pop af 
193c c1				pop bc 
193d d1				pop de 
193e e1				pop hl 
193f c9				ret 
1940			 
1940			;if ENABLE_BASIC 
1940			;	include "nascombasic.asm" 
1940			;	basic: 
1940			;	include "forth/FORTH.ASM" 
1940			;endif 
1940			 
1940			; eof 
1940			 
1940			 
# End of file firmware_diags.asm
1940			  
1940			  
1940			  
1940			  
1940			; eof  
1940			  
# End of file firmware.asm
1940			 
1940			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1940			;if BASE_KEV  
1940			;baseram: equ 08000h 
1940			;endif 
1940			 
1940			;if BASE_SC114 
1940			;baseram:     equ    endofcode 
1940			;endif 
1940			 
1940			 
1940			; start system 
1940			 
1940			coldstart: 
1940				; set sp 
1940				; di/ei 
1940			 
1940 f3				di 
1941 31 fd ff			ld sp, tos 
1944			;	ei 
1944			 
1944			 
1944				; disable breakpoint by default 
1944			 
1944 3e 2a			ld a,'*' 
1946 32 05 ee			ld (os_view_disable),a 
1949			 
1949				; init hardware 
1949			 
1949				; init keyboard and screen hardware 
1949			 
1949 cd 03 00			call hardware_init 
194c			 
194c			 
194c				; detect if any keys are held down to enable breakpoints at start up 
194c			 
194c cd 57 69			call cin  
194f fe 00			cp 0 
1951 28 03			jr z, .nokeys 
1953			 
1953				;call hardware_diags 
1953 cd a5 13			call config 
1956			 
1956			;	ld de, .bpen 
1956			;	ld a, display_row_4 
1956			;	call str_at_display 
1956			;	call update_display 
1956			; 
1956			;	ld a,0 
1956			;	ld (os_view_disable),a 
1956			; 
1956			;.bpwait: 
1956			;	call cin 
1956			;	cp 0 
1956			;	jr z, .bpwait 
1956			;	jr .nokeys 
1956			; 
1956			; 
1956			;.bpen:  db "Break points enabled!",0 
1956			 
1956			 
1956			 
1956			 
1956			 
1956			 
1956			.nokeys: 
1956			 
1956			 
1956				 
1956			 
1956			;jp  testkey 
1956			 
1956			;call storage_get_block_0 
1956			; 
1956			;ld hl, 0 
1956			;ld de, store_page 
1956			;call storage_read_block 
1956			 
1956				 
1956			;ld hl, 10 
1956			;ld de, store_page 
1956			;call storage_read_block 
1956			 
1956			 
1956			 
1956			 
1956			 
1956			;stop:	nop 
1956			;	jp stop 
1956			 
1956			 
1956			 
1956			main: 
1956 cd e7 0a			call clear_display 
1959 cd 0a 0b			call update_display 
195c			 
195c			 
195c			 
195c			;	call testlcd 
195c			 
195c			 
195c			 
195c cd 38 20			call forth_init 
195f			 
195f			 
195f			warmstart: 
195f cd 0e 20			call forth_warmstart 
1962			 
1962				; run startup word load 
1962			        ; TODO prevent this running at warmstart after crash  
1962			 
1962				if STARTUP_ENABLE 
1962					if STORAGE_SE 
1962 cd e5 64					call forth_autoload 
1965					endif 
1965 cd f4 61				call forth_startup 
1968			 
1968			 
1968				endif 
1968			 
1968				; show free memory after boot 
1968 11 02 1a			ld de, freeram 
196b 3e 00			ld a, display_row_1 
196d cd fa 0a			call str_at_display 
1970			 
1970			; Or use heap_size word???? 
1970 21 fa ed			ld hl, heap_end 
1973 11 0e 80			ld de, heap_start 
1976 ed 52			sbc hl, de 
1978 e5				push hl 
1979 7c				ld a,h	         	 
197a 21 19 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
197d cd 1c 10			call hexout 
1980 e1			   	pop hl 
1981			 
1981 7d				ld a,l 
1982 21 1b f1			ld hl, os_word_scratch+2 
1985 cd 1c 10			call hexout 
1988 21 1d f1			ld hl, os_word_scratch+4 
198b 3e 00			ld a, 0 
198d 77				ld (hl),a 
198e 11 19 f1			ld de, os_word_scratch 
1991 3e 0d			ld a, display_row_1 + 13 
1993 cd fa 0a			call str_at_display 
1996 cd 0a 0b			call update_display 
1999			 
1999			 
1999				;call demo 
1999			 
1999			 
1999				; init scratch input area for cli commands 
1999			 
1999 21 3b f1			ld hl, os_cli_cmd 
199c 3e 00			ld a,0 
199e 77				ld (hl),a 
199f 23				inc hl 
19a0 77				ld (hl),a 
19a1			 
19a1 3e 00			ld a,0 
19a3 32 3a f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
19a6			 
19a6 32 37 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
19a9 32 38 f1			ld (os_cur_ptr+1),a	 
19ac			 
19ac 32 19 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
19af 32 1a f1			ld (os_word_scratch+1),a	 
19b2				 
19b2			 
19b2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19b2 21 3b f1			ld hl, os_cli_cmd 
19b5			 
19b5 3e 00			ld a, 0		 ; init cli input 
19b7 77				ld (hl), a 
19b8 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19ba			cli: 
19ba				; show cli prompt 
19ba				;push af 
19ba				;ld a, 0 
19ba				;ld de, prompt 
19ba				;call str_at_display 
19ba			 
19ba				;call update_display 
19ba				;pop af 
19ba				;inc a 
19ba				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
19ba 0e 00			ld c, 0 
19bc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19be 1e 28			ld e, 40 
19c0			 
19c0 21 3b f1			ld hl, os_cli_cmd 
19c3			 
19c3				STACKFRAME OFF $fefe $9f9f 
19c3				if DEBUG_STACK_IMB 
19c3					if OFF 
19c3						exx 
19c3						ld de, $fefe 
19c3						ld a, d 
19c3						ld hl, curframe 
19c3						call hexout 
19c3						ld a, e 
19c3						ld hl, curframe+2 
19c3						call hexout 
19c3						ld hl, $fefe 
19c3						push hl 
19c3						ld hl, $9f9f 
19c3						push hl 
19c3						exx 
19c3					endif 
19c3				endif 
19c3			endm 
# End of macro STACKFRAME
19c3			 
19c3 cd 48 0d			call input_str 
19c6			 
19c6				STACKFRAMECHK OFF $fefe $9f9f 
19c6				if DEBUG_STACK_IMB 
19c6					if OFF 
19c6						exx 
19c6						ld hl, $9f9f 
19c6						pop de   ; $9f9f 
19c6						call cmp16 
19c6						jr nz, .spnosame 
19c6						ld hl, $fefe 
19c6						pop de   ; $fefe 
19c6						call cmp16 
19c6						jr z, .spfrsame 
19c6						.spnosame: call showsperror 
19c6						.spfrsame: nop 
19c6						exx 
19c6					endif 
19c6				endif 
19c6			endm 
# End of macro STACKFRAMECHK
19c6			 
19c6				; copy input to last command 
19c6			 
19c6 21 3b f1			ld hl, os_cli_cmd 
19c9 11 3a f2			ld de, os_last_cmd 
19cc 01 ff 00			ld bc, 255 
19cf ed b0			ldir 
19d1			 
19d1				; wipe current buffer 
19d1			 
19d1			;	ld a, 0 
19d1			;	ld hl, os_cli_cmd 
19d1			;	ld de, os_cli_cmd+1 
19d1			;	ld bc, 254 
19d1			;	ldir 
19d1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19d1			;	call strcpy 
19d1			;	ld a, 0 
19d1			;	ld (hl), a 
19d1			;	inc hl 
19d1			;	ld (hl), a 
19d1			;	inc hl 
19d1			;	ld (hl), a 
19d1			 
19d1				; switch frame buffer to program  
19d1			 
19d1 21 13 fa				ld hl, display_fb1 
19d4 22 cf f8				ld (display_fb_active), hl 
19d7			 
19d7			;	nop 
19d7				STACKFRAME ON $fbfe $8f9f 
19d7				if DEBUG_STACK_IMB 
19d7					if ON 
19d7						exx 
19d7						ld de, $fbfe 
19d7						ld a, d 
19d7						ld hl, curframe 
19d7						call hexout 
19d7						ld a, e 
19d7						ld hl, curframe+2 
19d7						call hexout 
19d7						ld hl, $fbfe 
19d7						push hl 
19d7						ld hl, $8f9f 
19d7						push hl 
19d7						exx 
19d7					endif 
19d7				endif 
19d7			endm 
# End of macro STACKFRAME
19d7				; first time into the parser so pass over the current scratch pad 
19d7 21 3b f1			ld hl,os_cli_cmd 
19da				; tokenise the entered statement(s) in HL 
19da cd b1 20			call forthparse 
19dd			        ; exec forth statements in top of return stack 
19dd cd f1 20			call forthexec 
19e0				;call forthexec_cleanup 
19e0			;	call parsenext 
19e0			 
19e0				STACKFRAMECHK ON $fbfe $8f9f 
19e0				if DEBUG_STACK_IMB 
19e0					if ON 
19e0						exx 
19e0						ld hl, $8f9f 
19e0						pop de   ; $8f9f 
19e0						call cmp16 
19e0						jr nz, .spnosame 
19e0						ld hl, $fbfe 
19e0						pop de   ; $fbfe 
19e0						call cmp16 
19e0						jr z, .spfrsame 
19e0						.spnosame: call showsperror 
19e0						.spfrsame: nop 
19e0						exx 
19e0					endif 
19e0				endif 
19e0			endm 
# End of macro STACKFRAMECHK
19e0				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19e0			 
19e0 3e 78			ld a, display_row_4 
19e2 11 14 1a			ld de, endprog 
19e5			 
19e5 cd 0a 0b			call update_display		 
19e8			 
19e8 cd 72 1c			call next_page_prompt 
19eb			 
19eb				; switch frame buffer to cli 
19eb			 
19eb 21 b4 fa				ld hl, display_fb0 
19ee 22 cf f8				ld (display_fb_active), hl 
19f1			 
19f1			 
19f1 cd e7 0a		        call clear_display 
19f4 cd 0a 0b			call update_display		 
19f7			 
19f7 21 3b f1			ld hl, os_cli_cmd 
19fa			 
19fa 3e 00			ld a, 0		 ; init cli input 
19fc 77				ld (hl), a 
19fd			 
19fd				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19fd			 
19fd				; now on last line 
19fd			 
19fd				; TODO scroll screen up 
19fd			 
19fd				; TODO instead just clear screen and place at top of screen 
19fd			 
19fd			;	ld a, 0 
19fd			;	ld (f_cursor_ptr),a 
19fd			 
19fd				;call clear_display 
19fd				;call update_display 
19fd			 
19fd				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19fd 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19ff c3 ba 19			jp cli 
1a02			 
1a02 .. 00		freeram: db "Free bytes: $",0 
1a10 ..			asc: db "1A2F" 
1a14 .. 00		endprog: db "End prog...",0 
1a20			 
1a20			testenter2:   
1a20 21 46 ee			ld hl,scratch+50 
1a23 22 37 f1			ld (os_cur_ptr),hl 
1a26 c3 ba 19			jp cli 
1a29			 
1a29			testenter:  
1a29			 
1a29 21 10 1a			ld hl,asc 
1a2c			;	ld a,(hl) 
1a2c			;	call nibble2val 
1a2c cd 72 10			call get_byte 
1a2f			 
1a2f			 
1a2f			;	ld a,(hl) 
1a2f			;	call atohex 
1a2f			 
1a2f			;	call fourehexhl 
1a2f 32 46 ee			ld (scratch+50),a 
1a32			 
1a32			 
1a32			 
1a32 21 12 1a			ld hl,asc+2 
1a35			;	ld a, (hl) 
1a35			;	call nibble2val 
1a35 cd 72 10			call get_byte 
1a38			 
1a38			;	call fourehexhl 
1a38 32 48 ee			ld (scratch+52),a 
1a3b				 
1a3b 21 46 ee			ld hl,scratch+50 
1a3e 22 37 f1			ld (os_cur_ptr),hl 
1a41 c3 ba 19			jp cli 
1a44			 
1a44			enter:	 
1a44 3a 18 ee			ld a,(scratch+4) 
1a47 fe 00			cp 0 
1a49 28 0c			jr z, .entercont 
1a4b				; no, not a null term line so has an address to work out.... 
1a4b			 
1a4b 21 16 ee			ld hl,scratch+2 
1a4e cd d2 10			call get_word_hl 
1a51			 
1a51 22 37 f1			ld (os_cur_ptr),hl	 
1a54 c3 ba 19			jp cli 
1a57			 
1a57			 
1a57			.entercont:  
1a57			 
1a57 21 16 ee			ld hl, scratch+2 
1a5a cd 72 10			call get_byte 
1a5d			 
1a5d 2a 37 f1		   	ld hl,(os_cur_ptr) 
1a60 77					ld (hl),a 
1a61 23					inc hl 
1a62 22 37 f1				ld (os_cur_ptr),hl 
1a65				 
1a65			; get byte  
1a65			 
1a65			 
1a65 c3 ba 19			jp cli 
1a68			 
1a68			 
1a68			; basic monitor support 
1a68			 
1a68			monitor: 
1a68				;  
1a68 cd e7 0a			call clear_display 
1a6b 3e 00			ld a, 0 
1a6d 11 b5 1a			ld de, .monprompt 
1a70 cd fa 0a			call str_at_display 
1a73 cd 0a 0b			call update_display 
1a76			 
1a76				; get a monitor command 
1a76			 
1a76 0e 00			ld c, 0     ; entry at top left 
1a78 16 64			ld d, 100   ; max buffer size 
1a7a 1e 0f			ld e, 15    ; input scroll area 
1a7c 3e 00			ld a, 0     ; init string 
1a7e 21 12 f0			ld hl, os_input 
1a81 77				ld (hl), a 
1a82 23				inc hl 
1a83 77				ld (hl), a 
1a84 21 12 f0			ld hl, os_input 
1a87 3e 01			ld a, 1     ; init string 
1a89 cd 48 0d			call input_str 
1a8c			 
1a8c cd e7 0a		        call clear_display 
1a8f cd 0a 0b			call update_display		 
1a92			 
1a92 3a 12 f0			ld a, (os_input) 
1a95 cd 70 11			call toUpper 
1a98 fe 48		        cp 'H' 
1a9a 28 6f		        jr z, .monhelp 
1a9c fe 44			cp 'D'		; dump 
1a9e ca 2c 1b			jp z, .mondump	 
1aa1 fe 43			cp 'C'		; dump 
1aa3 ca 46 1b			jp z, .moncdump	 
1aa6 fe 4d			cp 'M'		; dump 
1aa8 ca b7 1a			jp z, .moneditstart 
1aab fe 55			cp 'U'		; dump 
1aad 28 14			jr z, .monedit	 
1aaf fe 51			cp 'Q'		; dump 
1ab1 c8				ret z	 
1ab2			 
1ab2			 
1ab2				; TODO "S" to access symbol by name and not need the address 
1ab2				; TODO "F" to find a string in memory 
1ab2			 
1ab2 c3 68 1a			jp monitor 
1ab5			 
1ab5 .. 00		.monprompt: db ">", 0 
1ab7			 
1ab7			.moneditstart: 
1ab7				; get starting address 
1ab7			 
1ab7 21 14 f0			ld hl,os_input+2 
1aba cd d2 10			call get_word_hl 
1abd			 
1abd 22 37 f1			ld (os_cur_ptr),hl	 
1ac0			 
1ac0 c3 68 1a			jp monitor 
1ac3			 
1ac3			.monedit: 
1ac3				; get byte to load 
1ac3			 
1ac3 21 14 f0			ld hl,os_input+2 
1ac6 cd 72 10			call get_byte 
1ac9			 
1ac9				; get address to update 
1ac9 2a 37 f1			ld hl, (os_cur_ptr) 
1acc			 
1acc				; update byte 
1acc			 
1acc 77				ld (hl), a 
1acd			 
1acd				; move to next address and save it 
1acd			 
1acd 23				inc hl 
1ace 22 37 f1			ld (os_cur_ptr),hl	 
1ad1			 
1ad1 c3 68 1a			jp monitor 
1ad4			 
1ad4			 
1ad4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ae8 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1b04 .. 00		.monhelptext3:  db "Q-Quit",0 
1b0b			        
1b0b			.monhelp: 
1b0b 3e 00			ld a, display_row_1 
1b0d 11 d4 1a		        ld de, .monhelptext1 
1b10			 
1b10 cd fa 0a			call str_at_display 
1b13 3e 28			ld a, display_row_2 
1b15 11 e8 1a		        ld de, .monhelptext2 
1b18					 
1b18 cd fa 0a			call str_at_display 
1b1b 3e 50			ld a, display_row_3 
1b1d 11 04 1b		        ld de, .monhelptext3 
1b20					 
1b20 cd fa 0a			call str_at_display 
1b23 cd 0a 0b			call update_display		 
1b26			 
1b26 cd 72 1c			call next_page_prompt 
1b29 c3 68 1a			jp monitor 
1b2c			 
1b2c			.mondump:    
1b2c 21 14 f0			ld hl,os_input+2 
1b2f cd d2 10			call get_word_hl 
1b32			 
1b32 22 37 f1			ld (os_cur_ptr),hl	 
1b35 cd 7a 1b			call dumpcont 
1b38 3e 78			ld a, display_row_4 
1b3a 11 14 1a			ld de, endprog 
1b3d			 
1b3d cd 0a 0b			call update_display		 
1b40			 
1b40 cd 72 1c			call next_page_prompt 
1b43 c3 68 1a			jp monitor 
1b46			.moncdump: 
1b46 cd 7a 1b			call dumpcont 
1b49 3e 78			ld a, display_row_4 
1b4b 11 14 1a			ld de, endprog 
1b4e			 
1b4e cd 0a 0b			call update_display		 
1b51			 
1b51 cd 72 1c			call next_page_prompt 
1b54 c3 68 1a			jp monitor 
1b57			 
1b57			 
1b57			; TODO symbol access  
1b57			 
1b57			.symbols:     ;; A list of symbols that can be called up  
1b57 b4 fa			dw display_fb0 
1b59 .. 00			db "fb0",0  
1b5d 59 f8		     	dw store_page 
1b5f .. 00			db "store_page",0 
1b6a			 
1b6a			 
1b6a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b6a			 
1b6a 3a 15 ee			ld a,(scratch+1) 
1b6d fe 00			cp 0 
1b6f 28 09			jr z, dumpcont 
1b71			 
1b71				; no, not a null term line so has an address to work out.... 
1b71			 
1b71 21 16 ee			ld hl,scratch+2 
1b74 cd d2 10			call get_word_hl 
1b77			 
1b77 22 37 f1			ld (os_cur_ptr),hl	 
1b7a			 
1b7a			 
1b7a			 
1b7a			dumpcont: 
1b7a			 
1b7a				; dump bytes at ptr 
1b7a			 
1b7a			 
1b7a 3e 00			ld a, display_row_1 
1b7c 2a cf f8			ld hl, (display_fb_active) 
1b7f cd 1b 0d			call addatohl 
1b82 cd aa 1b			call .dumpbyterow 
1b85			 
1b85 3e 28			ld a, display_row_2 
1b87 2a cf f8			ld hl, (display_fb_active) 
1b8a cd 1b 0d			call addatohl 
1b8d cd aa 1b			call .dumpbyterow 
1b90			 
1b90			 
1b90 3e 50			ld a, display_row_3 
1b92 2a cf f8			ld hl, (display_fb_active) 
1b95 cd 1b 0d			call addatohl 
1b98 cd aa 1b			call .dumpbyterow 
1b9b			 
1b9b 3e 78			ld a, display_row_4 
1b9d 2a cf f8			ld hl, (display_fb_active) 
1ba0 cd 1b 0d			call addatohl 
1ba3 cd aa 1b			call .dumpbyterow 
1ba6			 
1ba6 cd 0a 0b			call update_display 
1ba9			;		jp cli 
1ba9 c9				ret 
1baa			 
1baa			.dumpbyterow: 
1baa			 
1baa				;push af 
1baa			 
1baa e5				push hl 
1bab			 
1bab				; calc where to poke the ascii 
1bab			if display_cols == 20 
1bab				ld a, 16 
1bab			else 
1bab 3e 1f			ld a, 31 
1bad			endif 
1bad			 
1bad cd 1b 0d			call addatohl 
1bb0 22 19 f1			ld (os_word_scratch),hl  		; save pos for later 
1bb3			 
1bb3			 
1bb3			; display decoding address 
1bb3 2a 37 f1		   	ld hl,(os_cur_ptr) 
1bb6			 
1bb6 7c				ld a,h 
1bb7 e1				pop hl 
1bb8 e5				push hl 
1bb9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bb9 cd 1c 10			call hexout 
1bbc 2a 37 f1		   	ld hl,(os_cur_ptr) 
1bbf			 
1bbf 7d				ld a,l 
1bc0 e1				pop hl 
1bc1 23				inc hl 
1bc2 23				inc hl 
1bc3 e5				push hl 
1bc4			;	ld hl, os_word_scratch+2 
1bc4 cd 1c 10			call hexout 
1bc7 e1				pop hl 
1bc8 23				inc hl 
1bc9 23				inc hl 
1bca				;ld hl, os_word_scratch+4 
1bca 3e 3a			ld a, ':' 
1bcc 77				ld (hl),a 
1bcd 23				inc hl 
1bce				;ld a, 0 
1bce				;ld (hl),a 
1bce				;ld de, os_word_scratch 
1bce				;pop af 
1bce				;push af 
1bce			;		ld a, display_row_2 
1bce			;		call str_at_display 
1bce			;		call update_display 
1bce			 
1bce			 
1bce			;pop af 
1bce			;	add 5 
1bce			 
1bce			if display_cols == 20 
1bce				ld b, 4 
1bce			else 
1bce 06 08			ld b, 8 
1bd0			endif	 
1bd0			 
1bd0			.dumpbyte: 
1bd0 c5				push bc 
1bd1 e5				push hl 
1bd2			 
1bd2			 
1bd2 2a 37 f1		   	ld hl,(os_cur_ptr) 
1bd5 7e					ld a,(hl) 
1bd6			 
1bd6					; poke the ascii to display 
1bd6 2a 19 f1				ld hl,(os_word_scratch) 
1bd9 77					ld (hl),a 
1bda 23					inc hl 
1bdb 22 19 f1				ld (os_word_scratch),hl 
1bde			 
1bde					 
1bde			 
1bde			 
1bde e1					pop hl 
1bdf e5					push hl 
1be0			 
1be0 cd 1c 10				call hexout 
1be3			 
1be3					 
1be3 2a 37 f1		   	ld hl,(os_cur_ptr) 
1be6 23				inc hl 
1be7 22 37 f1		   	ld (os_cur_ptr),hl 
1bea			 
1bea e1					pop hl 
1beb 23					inc hl 
1bec 23					inc hl 
1bed 23					inc hl 
1bee			 
1bee			 
1bee			 
1bee					;ld a,0 
1bee					;ld (os_word_scratch+2),a 
1bee					;pop af 
1bee					;push af 
1bee			 
1bee					;ld de, os_word_scratch 
1bee					;call str_at_display 
1bee			;		call update_display 
1bee			;		pop af 
1bee c1					pop bc 
1bef c6 03				add 3 
1bf1 10 dd			djnz .dumpbyte 
1bf3			 
1bf3				 
1bf3			 
1bf3 c9				ret 
1bf4			 
1bf4			jump:	 
1bf4			 
1bf4 21 16 ee			ld hl,scratch+2 
1bf7 cd d2 10			call get_word_hl 
1bfa				;ld hl,(scratch+2) 
1bfa				;call fourehexhl 
1bfa			 
1bfa 22 37 f1			ld (os_cur_ptr),hl	 
1bfd			 
1bfd e9				jp (hl) 
1bfe			 
1bfe			 
1bfe			 
1bfe			; TODO implement a basic monitor mode to start with 
1bfe			 
1bfe			 
1bfe			 
1bfe			 
1bfe			 
1bfe			 
1bfe			 
1bfe			 
1bfe			 
1bfe			; testing and demo code during development 
1bfe			 
1bfe			 
1bfe .. 00		str1: db "Enter some text...",0 
1c11 .. 00		clear: db "                    ",0 
1c26			 
1c26			demo: 
1c26			 
1c26			 
1c26			 
1c26			;	call update_display 
1c26			 
1c26				; init scratch input area for testing 
1c26 21 14 ee			ld hl, scratch	 
1c29 3e 00			ld a,0 
1c2b 77				ld (hl),a 
1c2c			 
1c2c			 
1c2c 3e 28		            LD   A, display_row_2 
1c2e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c2e 11 fe 1b		            LD   DE, str1 
1c31 cd fa 0a			call str_at_display 
1c34			 
1c34			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c34			cloop:	 
1c34 3e 50		            LD   A, display_row_3 
1c36			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c36 11 11 1c		            LD   DE, clear 
1c39			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c39 cd fa 0a				call str_at_display 
1c3c 3e 78			ld a, display_row_4 
1c3e 11 6e 1c			ld de, prompt 
1c41			 
1c41 cd fa 0a				call str_at_display 
1c44 cd 0a 0b			call update_display 
1c47			 
1c47 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c49 16 0a			ld d, 10 
1c4b 21 14 ee			ld hl, scratch	 
1c4e cd 48 0d			call input_str 
1c51			 
1c51			;	call clear_display 
1c51			;'	call update_display 
1c51			 
1c51 3e 00		            LD   A, display_row_1 
1c53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c53 11 11 1c		            LD   DE, clear 
1c56 cd fa 0a				call str_at_display 
1c59			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c59 3e 00		            LD   A, display_row_1 
1c5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c5b 11 14 ee		            LD   DE, scratch 
1c5e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c5e cd fa 0a				call str_at_display 
1c61 cd 0a 0b			call update_display 
1c64			 
1c64 3e 00				ld a,0 
1c66 21 14 ee			ld hl, scratch 
1c69 77				ld (hl),a 
1c6a			 
1c6a 00				nop 
1c6b c3 34 1c			jp cloop 
1c6e			 
1c6e			 
1c6e			 
1c6e			; OS Prompt 
1c6e			 
1c6e .. 00		prompt: db ">",0 
1c70 .. 00		endprg: db "?",0 
1c72			 
1c72			 
1c72			; handy next page prompt 
1c72			next_page_prompt: 
1c72 e5				push hl 
1c73 d5				push de 
1c74 f5				push af 
1c75 c5				push bc 
1c76			 
1c76 3e 9f			ld a,display_row_4 + display_cols - 1 
1c78 11 70 1c		        ld de, endprg 
1c7b cd fa 0a			call str_at_display 
1c7e cd 0a 0b			call update_display 
1c81 cd 46 69			call cin_wait 
1c84 c1				pop bc 
1c85 f1				pop af 
1c86 d1				pop de 
1c87 e1				pop hl 
1c88			 
1c88			 
1c88 c9				ret 
1c89			 
1c89			 
1c89			; forth parser 
1c89			 
1c89			; My forth kernel 
1c89			include "forth_kernel.asm" 
1c89			; 
1c89			; kernel to the forth OS 
1c89			 
1c89			DS_TYPE_STR: equ 1     ; string type 
1c89			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c89			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c89			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c89			 
1c89			FORTH_PARSEV1: equ 0 
1c89			FORTH_PARSEV2: equ 0 
1c89			FORTH_PARSEV3: equ 0 
1c89			FORTH_PARSEV4: equ 0 
1c89			FORTH_PARSEV5: equ 1 
1c89			 
1c89			;if FORTH_PARSEV5 
1c89			;	FORTH_END_BUFFER: equ 0 
1c89			;else 
1c89			FORTH_END_BUFFER: equ 127 
1c89			;endif 
1c89			 
1c89			FORTH_TRUE: equ 1 
1c89			FORTH_FALSE: equ 0 
1c89			 
1c89			if FORTH_PARSEV4 
1c89			include "forth_stackops.asm" 
1c89			endif 
1c89			 
1c89			if FORTH_PARSEV5 
1c89			include "forth_stackopsv5.asm" 
1c89			 
1c89			; Stack operations for v5 parser on wards 
1c89			; * DATA stack 
1c89			; * LOOP stack 
1c89			; * RETURN stack 
1c89			 
1c89			 
1c89			 
1c89			FORTH_CHK_DSP_UNDER: macro 
1c89				push hl 
1c89				push de 
1c89				ld hl,(cli_data_sp) 
1c89				ld de, cli_data_stack 
1c89				call cmp16 
1c89				jp c, fault_dsp_under 
1c89				pop de 
1c89				pop hl 
1c89				endm 
1c89			 
1c89			 
1c89			FORTH_CHK_RSP_UNDER: macro 
1c89				push hl 
1c89				push de 
1c89				ld hl,(cli_ret_sp) 
1c89				ld de, cli_ret_stack 
1c89				call cmp16 
1c89				jp c, fault_rsp_under 
1c89				pop de 
1c89				pop hl 
1c89				endm 
1c89			 
1c89			FORTH_CHK_LOOP_UNDER: macro 
1c89				push hl 
1c89				push de 
1c89				ld hl,(cli_loop_sp) 
1c89				ld de, cli_loop_stack 
1c89				call cmp16 
1c89				jp c, fault_loop_under 
1c89				pop de 
1c89				pop hl 
1c89				endm 
1c89			 
1c89			FORTH_ERR_TOS_NOTSTR: macro 
1c89				; TOSO might need more for checks when used 
1c89				push af 
1c89				ld a,(hl) 
1c89				cp DS_TYPE_STR 
1c89				jp nz, type_faultn   
1c89				pop af 
1c89				endm 
1c89			 
1c89			FORTH_ERR_TOS_NOTNUM: macro 
1c89				push af 
1c89				ld a,(hl) 
1c89				cp DS_TYPE_INUM 
1c89				jp nz, type_faultn   
1c89				pop af 
1c89				endm 
1c89			 
1c89			 
1c89			; increase data stack pointer and save hl to it 
1c89				 
1c89			FORTH_DSP_NEXT: macro 
1c89				call macro_forth_dsp_next 
1c89				endm 
1c89			 
1c89			 
1c89			macro_forth_dsp_next: 
1c89				if DEBUG_FORTH_STACK_GUARD 
1c89 cd be 62				call check_stacks 
1c8c				endif 
1c8c e5				push hl 
1c8d d5				push de 
1c8e eb				ex de,hl 
1c8f 2a 01 f8			ld hl,(cli_data_sp) 
1c92 23				inc hl 
1c93 23				inc hl 
1c94			 
1c94			; PARSEV5 
1c94 23				inc hl 
1c95 22 01 f8			ld (cli_data_sp),hl 
1c98 73				ld (hl), e 
1c99 23				inc hl 
1c9a 72				ld (hl), d 
1c9b d1				pop de 
1c9c e1				pop hl 
1c9d				if DEBUG_FORTH_STACK_GUARD 
1c9d cd be 62				call check_stacks 
1ca0				endif 
1ca0 c9				ret 
1ca1			 
1ca1			 
1ca1			; increase ret stack pointer and save hl to it 
1ca1				 
1ca1			FORTH_RSP_NEXT: macro 
1ca1				call macro_forth_rsp_next 
1ca1				endm 
1ca1			 
1ca1			macro_forth_rsp_next: 
1ca1				if DEBUG_FORTH_STACK_GUARD 
1ca1 cd be 62				call check_stacks 
1ca4				endif 
1ca4 e5				push hl 
1ca5 d5				push de 
1ca6 eb				ex de,hl 
1ca7 2a 05 f8			ld hl,(cli_ret_sp) 
1caa 23				inc hl 
1cab 23				inc hl 
1cac 22 05 f8			ld (cli_ret_sp),hl 
1caf 73				ld (hl), e 
1cb0 23				inc hl 
1cb1 72				ld (hl), d 
1cb2 d1				pop de 
1cb3 e1				pop hl 
1cb4				if DEBUG_FORTH_STACK_GUARD 
1cb4 cd be 62				call check_stacks 
1cb7				endif 
1cb7 c9				ret 
1cb8			 
1cb8			; get current ret stack pointer and save to hl  
1cb8				 
1cb8			FORTH_RSP_TOS: macro 
1cb8				call macro_forth_rsp_tos 
1cb8				endm 
1cb8			 
1cb8			macro_forth_rsp_tos: 
1cb8				;push de 
1cb8 2a 05 f8			ld hl,(cli_ret_sp) 
1cbb cd f3 1c			call loadhlptrtohl 
1cbe				;ld e, (hl) 
1cbe				;inc hl 
1cbe				;ld d, (hl) 
1cbe				;ex de, hl 
1cbe					if DEBUG_FORTH_WORDS 
1cbe			;			DMARK "RST" 
1cbe						CALLMONITOR 
1cbe cd 6a 17			call break_point_state  
1cc1				endm  
# End of macro CALLMONITOR
1cc1					endif 
1cc1				;pop de 
1cc1 c9				ret 
1cc2			 
1cc2			; pop ret stack pointer 
1cc2				 
1cc2			FORTH_RSP_POP: macro 
1cc2				call macro_forth_rsp_pop 
1cc2				endm 
1cc2			 
1cc2			 
1cc2			macro_forth_rsp_pop: 
1cc2				if DEBUG_FORTH_STACK_GUARD 
1cc2			;		DMARK "RPP" 
1cc2 cd be 62				call check_stacks 
1cc5					FORTH_CHK_RSP_UNDER 
1cc5 e5				push hl 
1cc6 d5				push de 
1cc7 2a 05 f8			ld hl,(cli_ret_sp) 
1cca 11 7f f7			ld de, cli_ret_stack 
1ccd cd 39 0d			call cmp16 
1cd0 da d2 63			jp c, fault_rsp_under 
1cd3 d1				pop de 
1cd4 e1				pop hl 
1cd5				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cd5				endif 
1cd5 e5				push hl 
1cd6 2a 05 f8			ld hl,(cli_ret_sp) 
1cd9			 
1cd9			 
1cd9				if FORTH_ENABLE_FREE 
1cd9			 
1cd9					; get pointer 
1cd9			 
1cd9					push de 
1cd9					push hl 
1cd9			 
1cd9					ld e, (hl) 
1cd9					inc hl 
1cd9					ld d, (hl) 
1cd9			 
1cd9					ex de, hl 
1cd9					call free 
1cd9			 
1cd9					pop hl 
1cd9					pop de 
1cd9			 
1cd9			 
1cd9				endif 
1cd9			 
1cd9			 
1cd9 2b				dec hl 
1cda 2b				dec hl 
1cdb 22 05 f8			ld (cli_ret_sp), hl 
1cde				; do stack underflow checks 
1cde e1				pop hl 
1cdf				if DEBUG_FORTH_STACK_GUARD 
1cdf cd be 62				call check_stacks 
1ce2					FORTH_CHK_RSP_UNDER 
1ce2 e5				push hl 
1ce3 d5				push de 
1ce4 2a 05 f8			ld hl,(cli_ret_sp) 
1ce7 11 7f f7			ld de, cli_ret_stack 
1cea cd 39 0d			call cmp16 
1ced da d2 63			jp c, fault_rsp_under 
1cf0 d1				pop de 
1cf1 e1				pop hl 
1cf2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cf2				endif 
1cf2 c9				ret 
1cf3			 
1cf3			 
1cf3			 
1cf3			; routine to load word pointed to by hl into hl 
1cf3			 
1cf3			loadhlptrtohl: 
1cf3			 
1cf3 d5				push de 
1cf4 5e				ld e, (hl) 
1cf5 23				inc hl 
1cf6 56				ld d, (hl) 
1cf7 eb				ex de, hl 
1cf8 d1				pop de 
1cf9			 
1cf9 c9				ret 
1cfa			 
1cfa			 
1cfa			 
1cfa			 
1cfa			 
1cfa			; push a number held in HL onto the data stack 
1cfa			; entry point for pushing a value when already in hl used in function above 
1cfa			 
1cfa			forth_push_numhl: 
1cfa			 
1cfa e5				push hl    ; save value to push 
1cfb			 
1cfb			if DEBUG_FORTH_PUSH 
1cfb				; see if disabled 
1cfb			 
1cfb			 
1cfb f5				push af 
1cfc 3a 05 ee			ld a, (os_view_disable) 
1cff fe 2a			cp '*' 
1d01 28 34			jr z, .pskip2 
1d03 e5				push hl 
1d04 e5			push hl 
1d05 cd e7 0a			call clear_display 
1d08 e1			pop hl 
1d09 7c				ld a,h 
1d0a 21 19 f1			ld hl, os_word_scratch 
1d0d cd 1c 10			call hexout 
1d10 e1				pop hl 
1d11 7d				ld a,l 
1d12 21 1b f1			ld hl, os_word_scratch+2 
1d15 cd 1c 10			call hexout 
1d18			 
1d18 21 1d f1			ld hl, os_word_scratch+4 
1d1b 3e 00			ld a,0 
1d1d 77				ld (hl),a 
1d1e 11 19 f1			ld de,os_word_scratch 
1d21 3e 28				ld a, display_row_2 
1d23 cd fa 0a				call str_at_display 
1d26 11 cc 51			ld de, .push_num 
1d29 3e 00			ld a, display_row_1 
1d2b			 
1d2b cd fa 0a				call str_at_display 
1d2e			 
1d2e			 
1d2e cd 0a 0b			call update_display 
1d31 cd 64 0a			call delay1s 
1d34 cd 64 0a			call delay1s 
1d37			.pskip2:  
1d37			 
1d37 f1				pop af 
1d38			endif	 
1d38			 
1d38			 
1d38				FORTH_DSP_NEXT 
1d38 cd 89 1c			call macro_forth_dsp_next 
1d3b				endm 
# End of macro FORTH_DSP_NEXT
1d3b			 
1d3b 2a 01 f8			ld hl, (cli_data_sp) 
1d3e			 
1d3e				; save item type 
1d3e 3e 02			ld a,  DS_TYPE_INUM 
1d40 77				ld (hl), a 
1d41 23				inc hl 
1d42			 
1d42				; get word off stack 
1d42 d1				pop de 
1d43 7b				ld a,e 
1d44 77				ld (hl), a 
1d45 23				inc hl 
1d46 7a				ld a,d 
1d47 77				ld (hl), a 
1d48			 
1d48			if DEBUG_FORTH_PUSH 
1d48 2b				dec hl 
1d49 2b				dec hl 
1d4a 2b				dec hl 
1d4b						DMARK "PH5" 
1d4b f5				push af  
1d4c 3a 60 1d			ld a, (.dmark)  
1d4f 32 6e fb			ld (debug_mark),a  
1d52 3a 61 1d			ld a, (.dmark+1)  
1d55 32 6f fb			ld (debug_mark+1),a  
1d58 3a 62 1d			ld a, (.dmark+2)  
1d5b 32 70 fb			ld (debug_mark+2),a  
1d5e 18 03			jr .pastdmark  
1d60 ..			.dmark: db "PH5"  
1d63 f1			.pastdmark: pop af  
1d64			endm  
# End of macro DMARK
1d64				CALLMONITOR 
1d64 cd 6a 17			call break_point_state  
1d67				endm  
# End of macro CALLMONITOR
1d67			endif	 
1d67			 
1d67 c9				ret 
1d68			 
1d68			 
1d68			; Push a string to stack pointed to by hl 
1d68			 
1d68			forth_push_str: 
1d68			 
1d68			if DEBUG_FORTH_PUSH 
1d68						DMARK "PSQ" 
1d68 f5				push af  
1d69 3a 7d 1d			ld a, (.dmark)  
1d6c 32 6e fb			ld (debug_mark),a  
1d6f 3a 7e 1d			ld a, (.dmark+1)  
1d72 32 6f fb			ld (debug_mark+1),a  
1d75 3a 7f 1d			ld a, (.dmark+2)  
1d78 32 70 fb			ld (debug_mark+2),a  
1d7b 18 03			jr .pastdmark  
1d7d ..			.dmark: db "PSQ"  
1d80 f1			.pastdmark: pop af  
1d81			endm  
# End of macro DMARK
1d81				CALLMONITOR 
1d81 cd 6a 17			call break_point_state  
1d84				endm  
# End of macro CALLMONITOR
1d84			endif	 
1d84			    
1d84 e5				push hl 
1d85 e5				push hl 
1d86			 
1d86			;	ld a, 0   ; find end of string 
1d86 cd 79 11			call strlenz 
1d89			if DEBUG_FORTH_PUSH 
1d89						DMARK "PQ2" 
1d89 f5				push af  
1d8a 3a 9e 1d			ld a, (.dmark)  
1d8d 32 6e fb			ld (debug_mark),a  
1d90 3a 9f 1d			ld a, (.dmark+1)  
1d93 32 6f fb			ld (debug_mark+1),a  
1d96 3a a0 1d			ld a, (.dmark+2)  
1d99 32 70 fb			ld (debug_mark+2),a  
1d9c 18 03			jr .pastdmark  
1d9e ..			.dmark: db "PQ2"  
1da1 f1			.pastdmark: pop af  
1da2			endm  
# End of macro DMARK
1da2				CALLMONITOR 
1da2 cd 6a 17			call break_point_state  
1da5				endm  
# End of macro CALLMONITOR
1da5			endif	 
1da5 eb				ex de, hl 
1da6 e1				pop hl   ; get ptr to start of string 
1da7			if DEBUG_FORTH_PUSH 
1da7						DMARK "PQ3" 
1da7 f5				push af  
1da8 3a bc 1d			ld a, (.dmark)  
1dab 32 6e fb			ld (debug_mark),a  
1dae 3a bd 1d			ld a, (.dmark+1)  
1db1 32 6f fb			ld (debug_mark+1),a  
1db4 3a be 1d			ld a, (.dmark+2)  
1db7 32 70 fb			ld (debug_mark+2),a  
1dba 18 03			jr .pastdmark  
1dbc ..			.dmark: db "PQ3"  
1dbf f1			.pastdmark: pop af  
1dc0			endm  
# End of macro DMARK
1dc0				CALLMONITOR 
1dc0 cd 6a 17			call break_point_state  
1dc3				endm  
# End of macro CALLMONITOR
1dc3			endif	 
1dc3 19				add hl,de 
1dc4			if DEBUG_FORTH_PUSH 
1dc4						DMARK "PQE" 
1dc4 f5				push af  
1dc5 3a d9 1d			ld a, (.dmark)  
1dc8 32 6e fb			ld (debug_mark),a  
1dcb 3a da 1d			ld a, (.dmark+1)  
1dce 32 6f fb			ld (debug_mark+1),a  
1dd1 3a db 1d			ld a, (.dmark+2)  
1dd4 32 70 fb			ld (debug_mark+2),a  
1dd7 18 03			jr .pastdmark  
1dd9 ..			.dmark: db "PQE"  
1ddc f1			.pastdmark: pop af  
1ddd			endm  
# End of macro DMARK
1ddd				CALLMONITOR 
1ddd cd 6a 17			call break_point_state  
1de0				endm  
# End of macro CALLMONITOR
1de0			endif	 
1de0			 
1de0 2b				dec hl    ; see if there is an optional trailing double quote 
1de1 7e				ld a,(hl) 
1de2 fe 22			cp '"' 
1de4 20 03			jr nz, .strnoq 
1de6 3e 00			ld a, 0      ; get rid of double quote 
1de8 77				ld (hl), a 
1de9 23			.strnoq: inc hl 
1dea			 
1dea 3e 00			ld a, 0 
1dec 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ded			 
1ded 13				inc de ; add one for the type string 
1dee 13				inc de ; add one for null term??? 
1def			 
1def				; tos is get string pointer again 
1def				; de contains space to allocate 
1def				 
1def d5				push de 
1df0			 
1df0 eb				ex de, hl 
1df1			 
1df1				;push af 
1df1			 
1df1			if DEBUG_FORTH_PUSH 
1df1						DMARK "PHm" 
1df1 f5				push af  
1df2 3a 06 1e			ld a, (.dmark)  
1df5 32 6e fb			ld (debug_mark),a  
1df8 3a 07 1e			ld a, (.dmark+1)  
1dfb 32 6f fb			ld (debug_mark+1),a  
1dfe 3a 08 1e			ld a, (.dmark+2)  
1e01 32 70 fb			ld (debug_mark+2),a  
1e04 18 03			jr .pastdmark  
1e06 ..			.dmark: db "PHm"  
1e09 f1			.pastdmark: pop af  
1e0a			endm  
# End of macro DMARK
1e0a				CALLMONITOR 
1e0a cd 6a 17			call break_point_state  
1e0d				endm  
# End of macro CALLMONITOR
1e0d			endif	 
1e0d cd e2 11			call malloc	; on ret hl now contains allocated memory 
1e10				if DEBUG_FORTH_MALLOC_GUARD 
1e10 cc 24 52				call z,malloc_error 
1e13				endif 
1e13			 
1e13				 
1e13 c1				pop bc    ; get length 
1e14 d1				pop de   ;  get string start    
1e15			 
1e15				; hl has destination from malloc 
1e15			 
1e15 eb				ex de, hl    ; prep for ldir 
1e16			 
1e16 d5				push de   ; save malloc area for DSP later 
1e17				;push hl   ; save malloc area for DSP later 
1e17			 
1e17			if DEBUG_FORTH_PUSH 
1e17						DMARK "PHc" 
1e17 f5				push af  
1e18 3a 2c 1e			ld a, (.dmark)  
1e1b 32 6e fb			ld (debug_mark),a  
1e1e 3a 2d 1e			ld a, (.dmark+1)  
1e21 32 6f fb			ld (debug_mark+1),a  
1e24 3a 2e 1e			ld a, (.dmark+2)  
1e27 32 70 fb			ld (debug_mark+2),a  
1e2a 18 03			jr .pastdmark  
1e2c ..			.dmark: db "PHc"  
1e2f f1			.pastdmark: pop af  
1e30			endm  
# End of macro DMARK
1e30				CALLMONITOR 
1e30 cd 6a 17			call break_point_state  
1e33				endm  
# End of macro CALLMONITOR
1e33			endif	 
1e33			 
1e33			 
1e33 ed b0			ldir 
1e35			 
1e35			 
1e35				; push malloc to data stack     macro?????  
1e35			 
1e35				FORTH_DSP_NEXT 
1e35 cd 89 1c			call macro_forth_dsp_next 
1e38				endm 
# End of macro FORTH_DSP_NEXT
1e38			 
1e38				; save value and type 
1e38			 
1e38 2a 01 f8			ld hl, (cli_data_sp) 
1e3b			 
1e3b				; save item type 
1e3b 3e 01			ld a,  DS_TYPE_STR 
1e3d 77				ld (hl), a 
1e3e 23				inc hl 
1e3f			 
1e3f				; get malloc word off stack 
1e3f d1				pop de 
1e40 73				ld (hl), e 
1e41 23				inc hl 
1e42 72				ld (hl), d 
1e43			 
1e43			 
1e43			 
1e43			if DEBUG_FORTH_PUSH 
1e43 2a 01 f8			ld hl, (cli_data_sp) 
1e46						DMARK "PHS" 
1e46 f5				push af  
1e47 3a 5b 1e			ld a, (.dmark)  
1e4a 32 6e fb			ld (debug_mark),a  
1e4d 3a 5c 1e			ld a, (.dmark+1)  
1e50 32 6f fb			ld (debug_mark+1),a  
1e53 3a 5d 1e			ld a, (.dmark+2)  
1e56 32 70 fb			ld (debug_mark+2),a  
1e59 18 03			jr .pastdmark  
1e5b ..			.dmark: db "PHS"  
1e5e f1			.pastdmark: pop af  
1e5f			endm  
# End of macro DMARK
1e5f				CALLMONITOR 
1e5f cd 6a 17			call break_point_state  
1e62				endm  
# End of macro CALLMONITOR
1e62			;	ex de,hl 
1e62			endif	 
1e62				; in case of spaces, skip the ptr past the copied string 
1e62				;pop af 
1e62				;ld (cli_origptr),hl 
1e62			 
1e62 c9				ret 
1e63			 
1e63			 
1e63			 
1e63			; TODO ascii push input onto stack given hl to start of input 
1e63			 
1e63			; identify type 
1e63			; if starts with a " then a string 
1e63			; otherwise it is a number 
1e63			;  
1e63			; if a string 
1e63			;     scan for ending " to get length of string to malloc for + 1 
1e63			;     malloc 
1e63			;     put pointer to string on stack first byte flags as string 
1e63			; 
1e63			; else a number 
1e63			;    look for number format identifier 
1e63			;    $xx hex 
1e63			;    %xxxxx bin 
1e63			;    xxxxx decimal 
1e63			;    convert number to 16bit word.  
1e63			;    malloc word + 1 with flag to identiy as num 
1e63			;    put pointer to number on stack 
1e63			;   
1e63			;  
1e63			  
1e63			forth_apush: 
1e63				; kernel push 
1e63			 
1e63			if DEBUG_FORTH_PUSH 
1e63						DMARK "PSH" 
1e63 f5				push af  
1e64 3a 78 1e			ld a, (.dmark)  
1e67 32 6e fb			ld (debug_mark),a  
1e6a 3a 79 1e			ld a, (.dmark+1)  
1e6d 32 6f fb			ld (debug_mark+1),a  
1e70 3a 7a 1e			ld a, (.dmark+2)  
1e73 32 70 fb			ld (debug_mark+2),a  
1e76 18 03			jr .pastdmark  
1e78 ..			.dmark: db "PSH"  
1e7b f1			.pastdmark: pop af  
1e7c			endm  
# End of macro DMARK
1e7c				CALLMONITOR 
1e7c cd 6a 17			call break_point_state  
1e7f				endm  
# End of macro CALLMONITOR
1e7f			endif	 
1e7f				; identify input type 
1e7f			 
1e7f 7e				ld a,(hl) 
1e80 fe 22			cp '"' 
1e82 28 0a			jr z, .fapstr 
1e84 fe 24			cp '$' 
1e86 ca ae 1e			jp z, .faphex 
1e89 fe 25			cp '%' 
1e8b ca 96 1e			jp z, .fapbin 
1e8e			;	cp 'b' 
1e8e			;	jp z, .fabin 
1e8e				; else decimal 
1e8e			 
1e8e				; TODO do decimal conversion 
1e8e				; decimal is stored as a 16bit word 
1e8e			 
1e8e				; by default everything is a string if type is not detected 
1e8e			.fapstr: ; 
1e8e fe 22			cp '"' 
1e90 20 01			jr nz, .strnoqu 
1e92 23				inc hl 
1e93			.strnoqu: 
1e93 c3 68 1d			jp forth_push_str 
1e96			 
1e96			 
1e96			 
1e96			.fapbin:    ; push a binary string.  
1e96 11 00 00			ld de, 0   ; hold a 16bit value 
1e99			 
1e99 23			.fapbinshift:	inc hl  
1e9a 7e				ld a,(hl) 
1e9b fe 00			cp 0     ; done scanning  
1e9d 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e9f			 
1e9f				; left shift de 
1e9f eb				ex de, hl	 
1ea0 29				add hl, hl 
1ea1			 
1ea1				; is 1 
1ea1 fe 31			cp '1' 
1ea3 20 02			jr nz, .binzero 
1ea5 cb 4d			bit 1, l 
1ea7			.binzero: 
1ea7 eb				ex de, hl	 ; save current de 
1ea8 18 ef			jr .fapbinshift 
1eaa			 
1eaa			.fapbdone: 
1eaa eb				ex de, hl 
1eab c3 fa 1c			jp forth_push_numhl 
1eae			 
1eae			 
1eae			.faphex:   ; hex is always stored as a 16bit word 
1eae				; skip number prefix 
1eae 23				inc hl 
1eaf				; turn ascii into number 
1eaf cd d2 10			call get_word_hl	; ret 16bit word in hl 
1eb2			 
1eb2 c3 fa 1c			jp forth_push_numhl 
1eb5			 
1eb5 00				 nop 
1eb6			 
1eb6			.fabin:   ; TODO bin conversion 
1eb6			 
1eb6			 
1eb6 c9				ret 
1eb7			 
1eb7			 
1eb7			; get either a string ptr or a 16bit word from the data stack 
1eb7			 
1eb7			FORTH_DSP: macro 
1eb7				call macro_forth_dsp 
1eb7				endm 
1eb7			 
1eb7			macro_forth_dsp: 
1eb7				; data stack pointer points to current word on tos 
1eb7			 
1eb7 2a 01 f8			ld hl,(cli_data_sp) 
1eba			 
1eba				if DEBUG_FORTH_PUSH 
1eba						DMARK "DSP" 
1eba f5				push af  
1ebb 3a cf 1e			ld a, (.dmark)  
1ebe 32 6e fb			ld (debug_mark),a  
1ec1 3a d0 1e			ld a, (.dmark+1)  
1ec4 32 6f fb			ld (debug_mark+1),a  
1ec7 3a d1 1e			ld a, (.dmark+2)  
1eca 32 70 fb			ld (debug_mark+2),a  
1ecd 18 03			jr .pastdmark  
1ecf ..			.dmark: db "DSP"  
1ed2 f1			.pastdmark: pop af  
1ed3			endm  
# End of macro DMARK
1ed3			 
1ed3 cd 59 52				call display_data_sp 
1ed6				;call break_point_state 
1ed6				;rst 030h 
1ed6				CALLMONITOR 
1ed6 cd 6a 17			call break_point_state  
1ed9				endm  
# End of macro CALLMONITOR
1ed9				endif 
1ed9			 
1ed9 c9				ret 
1eda			 
1eda			; return hl to start of value on stack 
1eda			 
1eda			FORTH_DSP_VALUE: macro 
1eda				call macro_forth_dsp_value 
1eda				endm 
1eda			 
1eda			macro_forth_dsp_value: 
1eda			 
1eda				FORTH_DSP 
1eda cd b7 1e			call macro_forth_dsp 
1edd				endm 
# End of macro FORTH_DSP
1edd			 
1edd d5				push de 
1ede			 
1ede 23				inc hl ; skip type 
1edf			 
1edf 5e				ld e, (hl) 
1ee0 23				inc hl 
1ee1 56				ld d, (hl) 
1ee2 eb				ex de,hl  
1ee3			 
1ee3 d1				pop de 
1ee4			 
1ee4 c9				ret 
1ee5			 
1ee5			; return hl to start of value to second item on stack 
1ee5			 
1ee5			FORTH_DSP_VALUEM1: macro 
1ee5				call macro_forth_dsp_value_m1 
1ee5				endm 
1ee5			 
1ee5			macro_forth_dsp_value_m1: 
1ee5			 
1ee5				FORTH_DSP 
1ee5 cd b7 1e			call macro_forth_dsp 
1ee8				endm 
# End of macro FORTH_DSP
1ee8			 
1ee8 2b				dec hl 
1ee9 2b				dec hl 
1eea			;	dec hl 
1eea			 
1eea d5				push de 
1eeb			 
1eeb 5e				ld e, (hl) 
1eec 23				inc hl 
1eed 56				ld d, (hl) 
1eee eb				ex de,hl  
1eef			 
1eef d1				pop de 
1ef0			 
1ef0 c9				ret 
1ef1			 
1ef1				 
1ef1			 
1ef1			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ef1			 
1ef1			FORTH_DSP_POP: macro 
1ef1				call macro_forth_dsp_pop 
1ef1				endm 
1ef1			 
1ef1			 
1ef1			; get the tos data type 
1ef1			 
1ef1			FORTH_DSP_TYPE:   macro 
1ef1			 
1ef1				;FORTH_DSP_VALUE 
1ef1				FORTH_DSP 
1ef1				 
1ef1				; hl points to value 
1ef1				; check type 
1ef1			 
1ef1				ld a,(hl) 
1ef1			 
1ef1				endm 
1ef1			 
1ef1			; load the tos value into hl 
1ef1			 
1ef1			 
1ef1			FORTH_DSP_VALUEHL:  macro 
1ef1				call macro_dsp_valuehl 
1ef1				endm 
1ef1			 
1ef1			 
1ef1			 
1ef1			macro_dsp_valuehl: 
1ef1				FORTH_DSP_VALUE 
1ef1 cd da 1e			call macro_forth_dsp_value 
1ef4				endm 
# End of macro FORTH_DSP_VALUE
1ef4			 
1ef4				;FORTH_ERR_TOS_NOTNUM 
1ef4			 
1ef4				;inc hl   ; skip type id 
1ef4			 
1ef4			;	push de 
1ef4			; 
1ef4			;	ld e, (hl) 
1ef4			;	inc hl 
1ef4			;	ld d, (hl) 
1ef4			;	ex de,hl  
1ef4			 
1ef4			;	pop de 
1ef4			 
1ef4				if DEBUG_FORTH_PUSH 
1ef4						DMARK "DVL" 
1ef4 f5				push af  
1ef5 3a 09 1f			ld a, (.dmark)  
1ef8 32 6e fb			ld (debug_mark),a  
1efb 3a 0a 1f			ld a, (.dmark+1)  
1efe 32 6f fb			ld (debug_mark+1),a  
1f01 3a 0b 1f			ld a, (.dmark+2)  
1f04 32 70 fb			ld (debug_mark+2),a  
1f07 18 03			jr .pastdmark  
1f09 ..			.dmark: db "DVL"  
1f0c f1			.pastdmark: pop af  
1f0d			endm  
# End of macro DMARK
1f0d				CALLMONITOR 
1f0d cd 6a 17			call break_point_state  
1f10				endm  
# End of macro CALLMONITOR
1f10				endif 
1f10 c9				ret 
1f11			 
1f11			forth_apushstrhl:      
1f11				; push of string requires use of cli_origptr 
1f11				; bodge use 
1f11			 
1f11				; get current cli_origptr, save, update with temp pointer  
1f11 ed 5b 1d f8		ld de, (cli_origptr) 
1f15 22 1d f8			ld (cli_origptr), hl 
1f18 d5				push de 
1f19 cd 63 1e			call forth_apush 
1f1c d1				pop de 
1f1d ed 53 1d f8		ld (cli_origptr), de 
1f21 c9			        ret	 
1f22			 
1f22			 
1f22			; increase loop stack pointer and save hl to it 
1f22				 
1f22			FORTH_LOOP_NEXT: macro 
1f22				call macro_forth_loop_next 
1f22				;nop 
1f22				endm 
1f22			 
1f22			macro_forth_loop_next: 
1f22				if DEBUG_FORTH_STACK_GUARD 
1f22 cd be 62				call check_stacks 
1f25				endif 
1f25 e5				push hl 
1f26 d5				push de 
1f27 eb				ex de,hl 
1f28 2a 03 f8			ld hl,(cli_loop_sp) 
1f2b 23				inc hl 
1f2c 23				inc hl 
1f2d					if DEBUG_FORTH_WORDS 
1f2d						DMARK "LNX" 
1f2d f5				push af  
1f2e 3a 42 1f			ld a, (.dmark)  
1f31 32 6e fb			ld (debug_mark),a  
1f34 3a 43 1f			ld a, (.dmark+1)  
1f37 32 6f fb			ld (debug_mark+1),a  
1f3a 3a 44 1f			ld a, (.dmark+2)  
1f3d 32 70 fb			ld (debug_mark+2),a  
1f40 18 03			jr .pastdmark  
1f42 ..			.dmark: db "LNX"  
1f45 f1			.pastdmark: pop af  
1f46			endm  
# End of macro DMARK
1f46						CALLMONITOR 
1f46 cd 6a 17			call break_point_state  
1f49				endm  
# End of macro CALLMONITOR
1f49					endif 
1f49 22 03 f8			ld (cli_loop_sp),hl 
1f4c 73				ld (hl), e 
1f4d 23				inc hl 
1f4e 72				ld (hl), d 
1f4f d1				pop de    ; been reversed so save a swap on restore 
1f50 e1				pop hl 
1f51				if DEBUG_FORTH_STACK_GUARD 
1f51 cd be 62				call check_stacks 
1f54				endif 
1f54 c9				ret 
1f55			 
1f55			; get current ret stack pointer and save to hl  
1f55				 
1f55			FORTH_LOOP_TOS: macro 
1f55				call macro_forth_loop_tos 
1f55				endm 
1f55			 
1f55			macro_forth_loop_tos: 
1f55 d5				push de 
1f56 2a 03 f8			ld hl,(cli_loop_sp) 
1f59 5e				ld e, (hl) 
1f5a 23				inc hl 
1f5b 56				ld d, (hl) 
1f5c eb				ex de, hl 
1f5d d1				pop de 
1f5e c9				ret 
1f5f			 
1f5f			; pop loop stack pointer 
1f5f				 
1f5f			FORTH_LOOP_POP: macro 
1f5f				call macro_forth_loop_pop 
1f5f				endm 
1f5f			 
1f5f			 
1f5f			macro_forth_loop_pop: 
1f5f				if DEBUG_FORTH_STACK_GUARD 
1f5f					DMARK "LPP" 
1f5f f5				push af  
1f60 3a 74 1f			ld a, (.dmark)  
1f63 32 6e fb			ld (debug_mark),a  
1f66 3a 75 1f			ld a, (.dmark+1)  
1f69 32 6f fb			ld (debug_mark+1),a  
1f6c 3a 76 1f			ld a, (.dmark+2)  
1f6f 32 70 fb			ld (debug_mark+2),a  
1f72 18 03			jr .pastdmark  
1f74 ..			.dmark: db "LPP"  
1f77 f1			.pastdmark: pop af  
1f78			endm  
# End of macro DMARK
1f78 cd be 62				call check_stacks 
1f7b					FORTH_CHK_LOOP_UNDER 
1f7b e5				push hl 
1f7c d5				push de 
1f7d 2a 03 f8			ld hl,(cli_loop_sp) 
1f80 11 7d f5			ld de, cli_loop_stack 
1f83 cd 39 0d			call cmp16 
1f86 da d8 63			jp c, fault_loop_under 
1f89 d1				pop de 
1f8a e1				pop hl 
1f8b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f8b				endif 
1f8b e5				push hl 
1f8c 2a 03 f8			ld hl,(cli_loop_sp) 
1f8f 2b				dec hl 
1f90 2b				dec hl 
1f91 22 03 f8			ld (cli_loop_sp), hl 
1f94				; TODO do stack underflow checks 
1f94 e1				pop hl 
1f95				if DEBUG_FORTH_STACK_GUARD 
1f95 cd be 62				call check_stacks 
1f98					FORTH_CHK_LOOP_UNDER 
1f98 e5				push hl 
1f99 d5				push de 
1f9a 2a 03 f8			ld hl,(cli_loop_sp) 
1f9d 11 7d f5			ld de, cli_loop_stack 
1fa0 cd 39 0d			call cmp16 
1fa3 da d8 63			jp c, fault_loop_under 
1fa6 d1				pop de 
1fa7 e1				pop hl 
1fa8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1fa8				endif 
1fa8 c9				ret 
1fa9			 
1fa9			macro_forth_dsp_pop: 
1fa9			 
1fa9 e5				push hl 
1faa			 
1faa				; release malloc data 
1faa			 
1faa				if DEBUG_FORTH_STACK_GUARD 
1faa cd be 62				call check_stacks 
1fad					FORTH_CHK_DSP_UNDER 
1fad e5				push hl 
1fae d5				push de 
1faf 2a 01 f8			ld hl,(cli_data_sp) 
1fb2 11 7b f3			ld de, cli_data_stack 
1fb5 cd 39 0d			call cmp16 
1fb8 da cc 63			jp c, fault_dsp_under 
1fbb d1				pop de 
1fbc e1				pop hl 
1fbd				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fbd				endif 
1fbd				;ld hl,(cli_data_sp) 
1fbd			if DEBUG_FORTH_DOT 
1fbd				DMARK "DPP" 
1fbd				CALLMONITOR 
1fbd			endif	 
1fbd			 
1fbd			 
1fbd			if FORTH_ENABLE_DSPPOPFREE 
1fbd			 
1fbd				FORTH_DSP 
1fbd cd b7 1e			call macro_forth_dsp 
1fc0				endm 
# End of macro FORTH_DSP
1fc0			 
1fc0 7e				ld a, (hl) 
1fc1 fe 01			cp DS_TYPE_STR 
1fc3 20 07			jr nz, .skippopfree 
1fc5			 
1fc5				FORTH_DSP_VALUEHL 
1fc5 cd f1 1e			call macro_dsp_valuehl 
1fc8				endm 
# End of macro FORTH_DSP_VALUEHL
1fc8 00				nop 
1fc9			if DEBUG_FORTH_DOT 
1fc9				DMARK "DPf" 
1fc9				CALLMONITOR 
1fc9			endif	 
1fc9 cd ac 12			call free 
1fcc			.skippopfree: 
1fcc				 
1fcc			 
1fcc			endif 
1fcc			 
1fcc			if DEBUG_FORTH_DOT_KEY 
1fcc				DMARK "DP2" 
1fcc				CALLMONITOR 
1fcc			endif	 
1fcc			 
1fcc				; move pointer down 
1fcc			 
1fcc 2a 01 f8			ld hl,(cli_data_sp) 
1fcf 2b				dec hl 
1fd0 2b				dec hl 
1fd1			; PARSEV5 
1fd1 2b				dec hl 
1fd2 22 01 f8			ld (cli_data_sp), hl 
1fd5			 
1fd5				if DEBUG_FORTH_STACK_GUARD 
1fd5 cd be 62				call check_stacks 
1fd8					FORTH_CHK_DSP_UNDER 
1fd8 e5				push hl 
1fd9 d5				push de 
1fda 2a 01 f8			ld hl,(cli_data_sp) 
1fdd 11 7b f3			ld de, cli_data_stack 
1fe0 cd 39 0d			call cmp16 
1fe3 da cc 63			jp c, fault_dsp_under 
1fe6 d1				pop de 
1fe7 e1				pop hl 
1fe8				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fe8				endif 
1fe8			 
1fe8 e1				pop hl 
1fe9			 
1fe9 c9				ret 
1fea			 
1fea			getwordathl: 
1fea				; hl points to an address 
1fea				; load hl with the word at that address 
1fea			 
1fea d5				push de 
1feb			 
1feb 5e				ld e, (hl) 
1fec 23				inc hl 
1fed 56				ld d, (hl) 
1fee eb				ex de, hl 
1fef			 
1fef d1				pop de 
1ff0 c9				ret 
1ff1			 
1ff1			 
1ff1			 
1ff1			 
1ff1			 
1ff1			; eof 
1ff1			 
# End of file forth_stackopsv5.asm
1ff1			endif 
1ff1			 
1ff1			user_word_eol:  
1ff1				; hl contains the pointer to where to create a linked list item from the end 
1ff1				; of the user dict to continue on at the system word dict 
1ff1				 
1ff1				; poke the stub of the word list linked list to repoint to rom words 
1ff1			 
1ff1				; stub format 
1ff1				; db   word id 
1ff1				; dw    link to next word 
1ff1			        ; db char length of token 
1ff1				; db string + 0 term 
1ff1				; db exec code....  
1ff1			 
1ff1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ff3 77				ld (hl), a		; word id 
1ff4 23				inc hl 
1ff5			 
1ff5 11 bb 21			ld de, sysdict 
1ff8 73				ld (hl), e		; next word link ie system dict 
1ff9 23				inc hl 
1ffa 72				ld (hl), d		; next word link ie system dict 
1ffb 23				inc hl	 
1ffc			 
1ffc			;	ld (hl), sysdict		; next word link ie system dict 
1ffc			;	inc hl 
1ffc			;	inc hl 
1ffc			 
1ffc			;	inc hl 
1ffc			;	inc hl 
1ffc			 
1ffc 3e 02			ld a, 2			; word length is 0 
1ffe 77				ld (hl), a	 
1fff 23				inc hl 
2000			 
2000 3e 7e			ld a, '~'			; word length is 0 
2002 77				ld (hl), a	 
2003 23				inc hl 
2004 3e 00			ld a, 0			; save empty word 
2006 77				ld (hl), a 
2007			 
2007 c9				ret 
2008			 
2008				 
2008			 
2008			forthexec_cleanup: 
2008				FORTH_RSP_POP 
2008 cd c2 1c			call macro_forth_rsp_pop 
200b				endm 
# End of macro FORTH_RSP_POP
200b c9				ret 
200c			 
200c			forth_call_hl: 
200c				; taking hl 
200c e5				push hl 
200d c9				ret 
200e			 
200e			; this is called to reset Forth system but keep existing uwords etc 
200e			 
200e			forth_warmstart: 
200e				; setup stack over/under flow checks 
200e				if DEBUG_FORTH_STACK_GUARD 
200e cd a4 62				call chk_stk_init 
2011				endif 
2011			 
2011				; init stack pointers  - * these stacks go upwards *  
2011 21 7f f7			ld hl, cli_ret_stack 
2014 22 05 f8			ld (cli_ret_sp), hl	 
2017				; set bottom of stack 
2017 3e 00			ld a,0 
2019 77				ld (hl),a 
201a 23				inc hl 
201b 77				ld (hl),a 
201c			 
201c 21 7b f3			ld hl, cli_data_stack 
201f 22 01 f8			ld (cli_data_sp), hl	 
2022				; set bottom of stack 
2022 3e 00			ld a,0 
2024 77				ld (hl),a 
2025 23				inc hl 
2026 77				ld (hl),a 
2027			 
2027 21 7d f5			ld hl, cli_loop_stack 
202a 22 03 f8			ld (cli_loop_sp), hl	 
202d				; set bottom of stack 
202d 3e 00			ld a,0 
202f 77				ld (hl),a 
2030 23				inc hl 
2031 77				ld (hl),a 
2032			 
2032				; init extent of current open file 
2032			 
2032 3e 00			ld a, 0 
2034 32 50 f8			ld (store_openext), a 
2037			 
2037 c9				ret 
2038			 
2038			 
2038			; Cold Start - this is called to setup the whole Forth system 
2038			 
2038			forth_init: 
2038			 
2038				; setup stack over/under flow checks 
2038			 
2038			;	if DEBUG_FORTH_STACK_GUARD 
2038			;		call chk_stk_init 
2038			;	endif 
2038			 
2038				; enable auto display updates (slow.....) 
2038			 
2038 3e 01			ld a, 1 
203a 32 1b f8			ld (cli_autodisplay), a 
203d			 
203d			 
203d			 
203d				; show start up screen 
203d			 
203d cd e7 0a			call clear_display 
2040			 
2040 3e 00			ld a,0 
2042 32 3d f8			ld (f_cursor_ptr), a 
2045			 
2045				; set start of word list in start of ram - for use when creating user words 
2045			 
2045 21 00 80			ld hl, baseram 
2048 22 11 f1			ld (os_last_new_uword), hl 
204b cd f1 1f			call user_word_eol 
204e				 
204e			;		call display_data_sp 
204e			;		call next_page_prompt 
204e			 
204e			 
204e			 
204e			 
204e c9				ret 
204f			 
204f .. 00		.bootforth: db " Forth Kernel Init ",0 
2063			 
2063			; TODO push to stack 
2063			 
2063			;  
2063			 
2063			if FORTH_PARSEV2 
2063			 
2063			 
2063				include "forth_parserv2.asm" 
2063			 
2063			endif 
2063			 
2063			 
2063			; parse cli version 1 
2063			 
2063			if FORTH_PARSEV1 
2063			 
2063			 
2063			 
2063			      include "forth_parserv1.asm" 
2063			endif 
2063				 
2063			if FORTH_PARSEV3 
2063			 
2063			 
2063			 
2063			      include "forth_parserv3.asm" 
2063				include "forth_wordsv3.asm" 
2063			endif 
2063			 
2063			if FORTH_PARSEV4 
2063			 
2063			 
2063			 
2063			      include "forth_parserv4.asm" 
2063				include "forth_wordsv4.asm" 
2063			endif 
2063			 
2063			if FORTH_PARSEV5 
2063			 
2063			 
2063			 
2063			      include "forth_parserv5.asm" 
2063			 
2063			 
2063			; A better parser without using malloc and string copies all over the place.  
2063			; Exec in situ should be faster 
2063			 
2063			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2063			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2063			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2063			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2063			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2063			WORD_SYS_END: equ 0   ; Opcode for all user words 
2063			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2063			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2063			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2063			 
2063			; Core word preamble macro 
2063			 
2063			CWHEAD:   macro nxtword opcode lit len opflags 
2063				db WORD_SYS_CORE+opcode             
2063				; internal op code number 
2063				dw nxtword            
2063				; link to next dict word block 
2063				db len + 1 
2063				; literal length of dict word inc zero term 
2063				db lit,0              
2063				; literal dict word 
2063			        ; TODO db opflags        
2063				endm 
2063			 
2063			 
2063			NEXTW: macro  
2063				jp macro_next 
2063				endm 
2063			 
2063			macro_next: 
2063			if DEBUG_FORTH_PARSE_KEY 
2063				DMARK "NXT" 
2063				CALLMONITOR 
2063			endif	 
2063			;	inc hl  ; skip token null term  
2063 ed 4b 1f f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2067 ed 5b 1d f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
206b 2a 15 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
206e			if DEBUG_FORTH_PARSE_KEY 
206e				DMARK "}AA" 
206e				CALLMONITOR 
206e			endif	 
206e c3 71 21			jp execnext 
2071				;jp exec1 
2071			       
2071			 
2071			 
2071			; Another go at the parser to compile  
2071			 
2071			 
2071			; TODO rework parser to change all of the string words to byte tokens 
2071			; TODO do a search for  
2071			 
2071			; TODO first run normal parser to zero term sections 
2071			; TODO for each word do a token look up to get the op code 
2071			; TODO need some means to flag to the exec that this is a byte code form    
2071			 
2071			 
2071			forthcompile: 
2071			 
2071			; 
2071			; line parse: 
2071			;       parse raw input buffer 
2071			;       tokenise the words 
2071			;       malloc new copy (for looping etc) 
2071			;       copy to malloc + current pc in line to start of string and add line term 
2071			;       save on new rsp 
2071			; 
2071			 
2071			; hl to point to the line to tokenise 
2071			 
2071			;	push hl 
2071 22 15 f1			ld (os_tok_ptr), hl  ; save ptr to string 
2074			 
2074			;	ld a,0		; string term on input 
2074			;	call strlent 
2074			 
2074			;	ld (os_tok_len), hl	 ; save string length 
2074			 
2074			;if DEBUG_FORTH_TOK 
2074			;	ex de,hl		 
2074			;endif 
2074			 
2074			;	pop hl 		; get back string pointer 
2074			 
2074			if DEBUG_FORTH_TOK 
2074						DMARK "TOc" 
2074				CALLMONITOR 
2074			endif 
2074 7e			.cptoken2:    ld a,(hl) 
2075 23				inc hl 
2076 fe 7f			cp FORTH_END_BUFFER 
2078 28 29			jr z, .cptokendone2 
207a fe 00			cp 0 
207c 28 25			jr z, .cptokendone2 
207e fe 22			cp '"' 
2080 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2082 fe 20			cp ' ' 
2084 20 ee			jr nz,  .cptoken2 
2086			 
2086			; TODO consume comments held between ( and ) 
2086			 
2086				; we have a space so change to zero term for dict match later 
2086 2b				dec hl 
2087 3e 00			ld a,0 
2089 77				ld (hl), a 
208a 23				inc hl 
208b 18 e7			jr .cptoken2 
208d				 
208d			 
208d			.cptokenstr2: 
208d				; skip all white space until either eol (because forgot to term) or end double quote 
208d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
208d				;inc hl ; skip current double quote 
208d 7e				ld a,(hl) 
208e 23				inc hl 
208f fe 22			cp '"' 
2091 28 e1			jr z, .cptoken2 
2093 fe 7f			cp FORTH_END_BUFFER 
2095 28 0c			jr z, .cptokendone2 
2097 fe 00			cp 0 
2099 28 08			jr z, .cptokendone2 
209b fe 20			cp ' ' 
209d 28 02			jr z, .cptmp2 
209f 18 ec			jr .cptokenstr2 
20a1			 
20a1			.cptmp2:	; we have a space so change to zero term for dict match later 
20a1				;dec hl 
20a1				;ld a,"-"	; TODO remove this when working 
20a1				;ld (hl), a 
20a1				;inc hl 
20a1 18 ea			jr .cptokenstr2 
20a3			 
20a3			.cptokendone2: 
20a3				;inc hl 
20a3 3e 7f			ld a, FORTH_END_BUFFER 
20a5 77				ld (hl),a 
20a6 23				inc hl 
20a7 3e 21			ld a, '!' 
20a9 77				ld (hl),a 
20aa			 
20aa 2a 15 f1			ld hl,(os_tok_ptr) 
20ad			         
20ad			if DEBUG_FORTH_TOK 
20ad						DMARK "Tc1" 
20ad				CALLMONITOR 
20ad			endif 
20ad			 
20ad				; push exec string to top of return stack 
20ad				FORTH_RSP_NEXT 
20ad cd a1 1c			call macro_forth_rsp_next 
20b0				endm 
# End of macro FORTH_RSP_NEXT
20b0 c9				ret 
20b1			 
20b1			; Another go at the parser need to simplify the process 
20b1			 
20b1			forthparse: 
20b1			 
20b1			; 
20b1			; line parse: 
20b1			;       parse raw input buffer 
20b1			;       tokenise the words 
20b1			;       malloc new copy (for looping etc) 
20b1			;       copy to malloc + current pc in line to start of string and add line term 
20b1			;       save on new rsp 
20b1			; 
20b1			 
20b1			; hl to point to the line to tokenise 
20b1			 
20b1			;	push hl 
20b1 22 15 f1			ld (os_tok_ptr), hl  ; save ptr to string 
20b4			 
20b4			;	ld a,0		; string term on input 
20b4			;	call strlent 
20b4			 
20b4			;	ld (os_tok_len), hl	 ; save string length 
20b4			 
20b4			;if DEBUG_FORTH_TOK 
20b4			;	ex de,hl		 
20b4			;endif 
20b4			 
20b4			;	pop hl 		; get back string pointer 
20b4			 
20b4			if DEBUG_FORTH_TOK 
20b4						DMARK "TOK" 
20b4				CALLMONITOR 
20b4			endif 
20b4 7e			.ptoken2:    ld a,(hl) 
20b5 23				inc hl 
20b6 fe 7f			cp FORTH_END_BUFFER 
20b8 28 29			jr z, .ptokendone2 
20ba fe 00			cp 0 
20bc 28 25			jr z, .ptokendone2 
20be fe 22			cp '"' 
20c0 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
20c2 fe 20			cp ' ' 
20c4 20 ee			jr nz,  .ptoken2 
20c6			 
20c6			; TODO consume comments held between ( and ) 
20c6			 
20c6				; we have a space so change to zero term for dict match later 
20c6 2b				dec hl 
20c7 3e 00			ld a,0 
20c9 77				ld (hl), a 
20ca 23				inc hl 
20cb 18 e7			jr .ptoken2 
20cd				 
20cd			 
20cd			.ptokenstr2: 
20cd				; skip all white space until either eol (because forgot to term) or end double quote 
20cd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20cd				;inc hl ; skip current double quote 
20cd 7e				ld a,(hl) 
20ce 23				inc hl 
20cf fe 22			cp '"' 
20d1 28 e1			jr z, .ptoken2 
20d3 fe 7f			cp FORTH_END_BUFFER 
20d5 28 0c			jr z, .ptokendone2 
20d7 fe 00			cp 0 
20d9 28 08			jr z, .ptokendone2 
20db fe 20			cp ' ' 
20dd 28 02			jr z, .ptmp2 
20df 18 ec			jr .ptokenstr2 
20e1			 
20e1			.ptmp2:	; we have a space so change to zero term for dict match later 
20e1				;dec hl 
20e1				;ld a,"-"	; TODO remove this when working 
20e1				;ld (hl), a 
20e1				;inc hl 
20e1 18 ea			jr .ptokenstr2 
20e3			 
20e3			.ptokendone2: 
20e3				;inc hl 
20e3 3e 7f			ld a, FORTH_END_BUFFER 
20e5 77				ld (hl),a 
20e6 23				inc hl 
20e7 3e 21			ld a, '!' 
20e9 77				ld (hl),a 
20ea			 
20ea 2a 15 f1			ld hl,(os_tok_ptr) 
20ed			         
20ed			if DEBUG_FORTH_TOK 
20ed						DMARK "TK1" 
20ed				CALLMONITOR 
20ed			endif 
20ed			 
20ed				; push exec string to top of return stack 
20ed				FORTH_RSP_NEXT 
20ed cd a1 1c			call macro_forth_rsp_next 
20f0				endm 
# End of macro FORTH_RSP_NEXT
20f0 c9				ret 
20f1			 
20f1			; 
20f1			;	; malloc size + buffer pointer + if is loop flag 
20f1			;	ld hl,(os_tok_len) 		 ; get string length 
20f1			; 
20f1			;	ld a,l 
20f1			; 
20f1			;	cp 0			; we dont want to use a null string 
20f1			;	ret z 
20f1			; 
20f1			;;	add 3    ; prefix malloc with buffer for current word ptr 
20f1			; 
20f1			;	add 5     ; TODO when certain not over writing memory remove 
20f1			; 
20f1			;		 
20f1			; 
20f1			;if DEBUG_FORTH_TOK 
20f1			;			DMARK "TKE" 
20f1			;	CALLMONITOR 
20f1			;endif 
20f1			; 
20f1			;	ld l,a 
20f1			;	ld h,0 
20f1			;;	push hl   ; save required space for the copy later 
20f1			;	call malloc 
20f1			;if DEBUG_FORTH_TOK 
20f1			;			DMARK "TKM" 
20f1			;	CALLMONITOR 
20f1			;endif 
20f1			;	if DEBUG_FORTH_MALLOC_GUARD 
20f1			;		push af 
20f1			;		call ishlzero 
20f1			;;		ld a, l 
20f1			;;		add h 
20f1			;;		cp 0 
20f1			;		pop af 
20f1			;		 
20f1			;		call z,malloc_error 
20f1			;	endif 
20f1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20f1			; 
20f1			; 
20f1			;if DEBUG_FORTH_TOK 
20f1			;			DMARK "TKR" 
20f1			;	CALLMONITOR 
20f1			;endif 
20f1			; 
20f1			;	FORTH_RSP_NEXT 
20f1			; 
20f1			;	;inc hl	 ; go past current buffer pointer 
20f1			;	;inc hl 
20f1			;	;inc hl   ; and past if loop flag 
20f1			;		; TODO Need to set flag  
20f1			; 
20f1			;	 
20f1			;	 
20f1			;	ex de,hl	; malloc is dest 
20f1			;	ld hl, (os_tok_len) 
20f1			;;	pop bc 
20f1			;	ld c, l                
20f1			;	ld b,0 
20f1			;	ld hl, (os_tok_ptr) 
20f1			; 
20f1			;if DEBUG_FORTH_TOK 
20f1			;			DMARK "TKT" 
20f1			;	CALLMONITOR 
20f1			;endif 
20f1			; 
20f1			;	; do str cpy 
20f1			; 
20f1			;	ldir      ; copy byte in hl to de 
20f1			; 
20f1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20f1			; 
20f1			;if DEBUG_FORTH_TOK 
20f1			; 
20f1			;			DMARK "TKY" 
20f1			;	CALLMONITOR 
20f1			;endif 
20f1			;	;ld a,0 
20f1			;	;ld a,FORTH_END_BUFFER 
20f1			;	ex de, hl 
20f1			;	;dec hl			 ; go back over the space delim at the end of word 
20f1			;	;ld (hl),a 
20f1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20f1			;	ld a,FORTH_END_BUFFER 
20f1			;	ld (hl),a 
20f1			;	inc hl 
20f1			;	ld a,FORTH_END_BUFFER 
20f1			;	ld (hl),a 
20f1			; 
20f1			;	; init the malloc area data 
20f1			;	; set pc for in current area 
20f1			;	;ld hl, (os_tok_malloc) 
20f1			;	;inc hl 
20f1			;	;inc hl 
20f1			;	;inc hl 
20f1			;	;ex de,hl 
20f1			;	;ld hl, (os_tok_malloc) 
20f1			;	;ld (hl),e 
20f1			;	;inc hl 
20f1			;	;ld (hl),d 
20f1			; 
20f1			; 
20f1			;	ld hl,(os_tok_malloc) 
20f1			;if DEBUG_FORTH_PARSE_KEY 
20f1			;			DMARK "TKU" 
20f1			;	CALLMONITOR 
20f1			;endif 
20f1			; 
20f1			;	ret 
20f1			 
20f1			forthexec: 
20f1			 
20f1			; line exec: 
20f1			; forth parser 
20f1			 
20f1			; 
20f1			;       get current exec line on rsp 
20f1			 
20f1				FORTH_RSP_TOS 
20f1 cd b8 1c			call macro_forth_rsp_tos 
20f4				endm 
# End of macro FORTH_RSP_TOS
20f4			 
20f4			;       restore current pc - hl points to malloc of data 
20f4			 
20f4				;ld e, (hl) 
20f4				;inc hl 
20f4				;ld d, (hl) 
20f4				;ex de,hl 
20f4			 
20f4			 
20f4			exec1: 
20f4 22 15 f1			ld (os_tok_ptr), hl 
20f7			 
20f7				; copy our PC to working vars  
20f7 22 1f f8			ld (cli_ptr), hl 
20fa 22 1d f8			ld (cli_origptr), hl 
20fd			 
20fd 7e				ld a,(hl) 
20fe fe 7f			cp FORTH_END_BUFFER 
2100 c8				ret z 
2101			 
2101				; skip any nulls 
2101			 
2101 fe 00			cp 0 
2103 20 03			jr nz, .execword 
2105 23				inc hl 
2106 18 ec			jr exec1 
2108			 
2108			 
2108			.execword: 
2108			 
2108			 
2108			 
2108			if DEBUG_FORTH_PARSE_KEY 
2108						DMARK "KYQ" 
2108				CALLMONITOR 
2108			endif 
2108			;       while at start of word: 
2108			; get start of dict (in user area first) 
2108			 
2108 21 00 80		ld hl, baseram 
210b			;ld hl, sysdict 
210b 22 21 f8		ld (cli_nextword),hl 
210e			;           match word at pc 
210e			;           exec word 
210e			;           or push to dsp 
210e			;           forward to next token 
210e			;           if line term pop rsp and exit 
210e			;        
210e			 
210e			if DEBUG_FORTH_PARSE_KEY 
210e						DMARK "KYq" 
210e				CALLMONITOR 
210e			endif 
210e			 
210e			; 
210e			; word comp 
210e			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
210e			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
210e			;    move to start of word  
210e			;    compare word to cli_token 
210e			 
210e			.execpnword:	; HL at start of a word in the dictionary to check 
210e			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
210e			;	ld (cli_ptr), hl 
210e			 
210e 2a 21 f8			ld hl,(cli_nextword) 
2111			 
2111 cd b4 21			call forth_tok_next 
2114			; tok next start here 
2114			;	; TODO skip compiled symbol for now 
2114			;	inc hl 
2114			; 
2114			;	; save pointer to next word 
2114			; 
2114			;	; hl now points to the address of the next word pointer  
2114			;	ld e, (hl) 
2114			;	inc hl 
2114			;	ld d, (hl) 
2114			;	inc l 
2114			; 
2114			;	ex de,hl 
2114			;if DEBUG_FORTH_PARSE_NEXTWORD 
2114			;	push bc 
2114			;	ld bc, (cli_nextword) 
2114			;			DMARK "NXW" 
2114			;	CALLMONITOR 
2114			;	pop bc 
2114			;endif 
2114			; tok next end here 
2114 22 21 f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
2117 eb				ex de, hl 
2118			 
2118			 
2118				; save the pointer of the current token - 1 to check against 
2118				 
2118 22 25 f8			ld (cli_token), hl   
211b				; TODO maybe remove below save if no debug 
211b				; save token string ptr for any debug later 
211b 23				inc hl  
211c 22 27 f8			ld (cli_origtoken), hl 
211f 2b				dec hl 
2120				; save pointer to the start of the next dictionay word 
2120 7e				ld a,(hl)   ; get string length 
2121 47				ld b,a 
2122			.execpnwordinc:  
2122 23				inc hl 
2123 10 fd			djnz .execpnwordinc 
2125 22 23 f8			ld (cli_execword), hl      ; save start of this words code 
2128			 
2128				; now check the word token against the string being parsed 
2128			 
2128 2a 25 f8			ld hl,(cli_token) 
212b 23				inc hl     ; skip string length (use zero term instead to end) 
212c 22 25 f8			ld (cli_token), hl 
212f			 
212f			if DEBUG_FORTH_PARSE_KEY 
212f						DMARK "KY2" 
212f			endif 
212f			if DEBUG_FORTH_PARSE_EXEC 
212f				; see if disabled 
212f			 
212f				ld a, (os_view_disable) 
212f				cp '*' 
212f				jr z, .skip 
212f			 
212f				push hl 
212f				push hl 
212f				call clear_display 
212f				ld de, .compword 
212f				ld a, display_row_1 
212f				call str_at_display 
212f				pop de 
212f				ld a, display_row_2 
212f				call str_at_display 
212f				ld hl,(cli_ptr) 
212f				ld a,(hl) 
212f			        ld hl, os_word_scratch 
212f				ld (hl),a 
212f				ld a,0 
212f				inc hl 
212f				ld (hl),a 	 
212f				ld de, os_word_scratch 
212f				ld a, display_row_2+10 
212f				call str_at_display 
212f				call update_display 
212f				ld a, 100 
212f				call aDelayInMS 
212f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
212f				call delay250ms 
212f				endif 
212f				pop hl 
212f			.skip:  
212f			endif	 
212f			.execpnchar:    ; compare char between token and string to parse 
212f			 
212f			if DEBUG_FORTH_PARSE_KEY 
212f						DMARK "Ky3" 
212f			endif 
212f			if DEBUG_FORTH_PARSE_EXEC 
212f				; see if disabled 
212f			 
212f				ld a, (os_view_disable) 
212f				cp '*' 
212f				jr z, .skip2 
212f			 
212f			;	call clear_display 
212f			ld hl,(cli_token) 
212f			ld a,(hl) 
212f			ld (os_word_scratch),a 
212f				ld hl,(cli_ptr) 
212f			ld a,(hl) 
212f				ld (os_word_scratch+1),a 
212f				ld a,0 
212f				ld (os_word_scratch+2),a 
212f				ld de,os_word_scratch 
212f				ld a,display_row_4 
212f				call str_at_display 
212f				call update_display 
212f			.skip2:  
212f			endif 
212f 2a 25 f8			ld hl,(cli_token) 
2132 7e				ld a, (hl)	 ; char in word token 
2133 23				inc hl 		; move to next char 
2134 22 25 f8			ld (cli_token), hl ; and save it 
2137 47				ld b,a 
2138			 
2138 2a 1f f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
213b 7e				ld a,(hl) 
213c 23				inc hl 
213d 22 1f f8			ld (cli_ptr), hl		; move to next char 
2140 cd 70 11			call toUpper 		; make sure the input string matches case 
2143			 
2143			if DEBUG_FORTH_PARSE 
2143			endif 
2143			 
2143				; input stream end of token is a space so get rid of it 
2143			 
2143			;	cp ' ' 
2143			;	jr nz, .pnskipspace 
2143			; 
2143			;	ld a, 0		; make same term as word token term 
2143			; 
2143			;.pnskipspace: 
2143			 
2143			if DEBUG_FORTH_PARSE_KEY 
2143						DMARK "KY7" 
2143			endif 
2143 b8				cp b 
2144 c2 5a 21			jp nz, .execpnskipword	 ; no match so move to next word 
2147				 
2147			;    if same 
2147			;       scan for string terms 0 for token and 32 for input 
2147			 
2147				 
2147			if DEBUG_FORTH_PARSE_KEY 
2147						DMARK "KY8" 
2147			endif 
2147			 
2147 80				add b			 
2148 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
214a							; TODO need to make sure last word in zero term string is accounted for 
214a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
214c			 
214c			 
214c				; at end of both strings so both are exact match 
214c			 
214c			;       skip ptr for next word 
214c			 
214c 2a 1f f8			ld hl,(cli_ptr) 	; at input string term 
214f 23				inc hl			 ; at next char 
2150 22 1f f8			ld (cli_ptr), hl     ; save for next round of the parser 
2153 22 1d f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2156				 
2156				 
2156			if DEBUG_FORTH_PARSE_KEY 
2156						DMARK "KY3" 
2156			endif 
2156			 
2156			 
2156			 
2156			;       exec code block 
2156			if DEBUG_FORTH_JP 
2156				call clear_display 
2156				call update_display 
2156				call delay1s 
2156				ld hl, (cli_execword)     ; save for next check if no match on this word 
2156				ld a,h 
2156				ld hl, os_word_scratch 
2156				call hexout 
2156				ld hl, (cli_execword)     ; save for next check if no match on this word 
2156				ld a,l 
2156				ld hl, os_word_scratch+2 
2156				call hexout 
2156				ld hl, os_word_scratch+4 
2156				ld a,0 
2156				ld (hl),a 
2156				ld de,os_word_scratch 
2156				call str_at_display 
2156					ld a, display_row_2 
2156					call str_at_display 
2156				ld de, (cli_origtoken) 
2156				ld a, display_row_1+10 
2156					call str_at_display 
2156			 
2156				ld a,display_row_1 
2156				ld de, .foundword 
2156				ld a, display_row_3 
2156				call str_at_display 
2156				call update_display 
2156				call delay1s 
2156				call delay1s 
2156				call delay1s 
2156			endif 
2156			 
2156			if DEBUG_FORTH_PARSE_KEY 
2156						DMARK "KYj" 
2156			endif 
2156				; TODO save the word pointer in this exec 
2156			 
2156 2a 23 f8			ld hl,(cli_execword) 
2159 e9				jp (hl) 
215a			 
215a			 
215a			;    if not same 
215a			;	scan for zero term 
215a			;	get ptr for next word 
215a			;	goto word comp 
215a			 
215a			.execpnskipword:	; get pointer to next word 
215a 2a 21 f8			ld hl,(cli_nextword) 
215d			 
215d 7e				ld a,(hl) 
215e fe 00			cp WORD_SYS_END 
2160			;	cp 0 
2160 28 09			jr z, .execendofdict			 ; at end of words 
2162			 
2162			if DEBUG_FORTH_PARSE_KEY 
2162						DMARK "KY4" 
2162			endif 
2162			if DEBUG_FORTH_PARSE_EXEC 
2162			 
2162				; see if disabled 
2162			 
2162				ld a, (os_view_disable) 
2162				cp '*' 
2162				jr z, .noskip 
2162			 
2162			 
2162				ld de, .nowordfound 
2162				ld a, display_row_3 
2162				call str_at_display 
2162				call update_display 
2162				ld a, 100 
2162				call aDelayInMS 
2162				 
2162				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2162					call delay250ms 
2162				endif 
2162			.noskip:  
2162			 
2162			endif	 
2162			 
2162 2a 1d f8			ld hl,(cli_origptr) 
2165 22 1f f8			ld (cli_ptr),hl 
2168			 
2168			if DEBUG_FORTH_PARSE_KEY 
2168						DMARK "KY5" 
2168			endif 
2168 c3 0e 21			jp .execpnword			; else go to next word 
216b			 
216b			.execendofdict:  
216b			 
216b			if DEBUG_FORTH_PARSE_KEY 
216b						DMARK "KYe" 
216b			endif 
216b			if DEBUG_FORTH_PARSE_EXEC 
216b				; see if disabled 
216b			 
216b				ld a, (os_view_disable) 
216b				cp '*' 
216b				jr z, .ispskip 
216b			 
216b				call clear_display 
216b				call update_display 
216b				call delay1s 
216b				ld de, (cli_origptr) 
216b				ld a, display_row_1 
216b				call str_at_display 
216b				 
216b				ld de, .enddict 
216b				ld a, display_row_3 
216b				call str_at_display 
216b				call update_display 
216b				ld a, 100 
216b				call aDelayInMS 
216b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
216b				call delay1s 
216b				call delay1s 
216b				call delay1s 
216b				endif 
216b			.ispskip:  
216b				 
216b			endif	 
216b			 
216b			 
216b			 
216b				; if the word is not a keyword then must be a literal so push it to stack 
216b			 
216b			; push token to stack to end of word 
216b			 
216b				STACKFRAME ON $1efe $2f9f 
216b				if DEBUG_STACK_IMB 
216b					if ON 
216b						exx 
216b						ld de, $1efe 
216b						ld a, d 
216b						ld hl, curframe 
216b						call hexout 
216b						ld a, e 
216b						ld hl, curframe+2 
216b						call hexout 
216b						ld hl, $1efe 
216b						push hl 
216b						ld hl, $2f9f 
216b						push hl 
216b						exx 
216b					endif 
216b				endif 
216b			endm 
# End of macro STACKFRAME
216b			 
216b 2a 15 f1		ld hl,(os_tok_ptr) 
216e cd 63 1e		call forth_apush 
2171			 
2171				STACKFRAMECHK ON $1efe $2f9f 
2171				if DEBUG_STACK_IMB 
2171					if ON 
2171						exx 
2171						ld hl, $2f9f 
2171						pop de   ; $2f9f 
2171						call cmp16 
2171						jr nz, .spnosame 
2171						ld hl, $1efe 
2171						pop de   ; $1efe 
2171						call cmp16 
2171						jr z, .spfrsame 
2171						.spnosame: call showsperror 
2171						.spfrsame: nop 
2171						exx 
2171					endif 
2171				endif 
2171			endm 
# End of macro STACKFRAMECHK
2171			 
2171			execnext: 
2171			 
2171			if DEBUG_FORTH_PARSE_KEY 
2171						DMARK "KY>" 
2171			endif 
2171			; move past token to next word 
2171			 
2171 2a 15 f1		ld hl, (os_tok_ptr) 
2174 3e 00		ld a, 0 
2176 01 ff 00		ld bc, 255     ; input buffer size 
2179 ed b1		cpir 
217b			 
217b			if DEBUG_FORTH_PARSE_KEY 
217b						DMARK "KY!" 
217b				CALLMONITOR 
217b			endif	 
217b			; TODO this might place hl on the null, so will need to forward on??? 
217b			;inc hl   ; see if this gets onto the next item 
217b			 
217b			 
217b			; TODO pass a pointer to the buffer to push 
217b			; TODO call function to push 
217b			 
217b			; look for end of input 
217b			 
217b			;inc hl 
217b			;ld a,(hl) 
217b			;cp FORTH_END_BUFFER 
217b			;ret z 
217b			 
217b			 
217b c3 f4 20		jp exec1 
217e			 
217e			 
217e			 
217e			 
217e			 
217e			 
217e			 
217e			 
217e			 
217e			findnexttok: 
217e			 
217e				; hl is pointer to move 
217e				; de is the token to locate 
217e			 
217e					if DEBUG_FORTH 
217e						DMARK "NTK" 
217e						CALLMONITOR 
217e					endif 
217e d5				push de 
217f			 
217f			.fnt1:	 
217f				; find first char of token to locate 
217f			 
217f 1a				ld a, (de) 
2180 4f				ld c,a 
2181 7e				ld a,(hl) 
2182 cd 70 11			call toUpper 
2185					if DEBUG_FORTH 
2185						DMARK "NT1" 
2185						CALLMONITOR 
2185					endif 
2185 b9				cp c 
2186			 
2186 28 03			jr z, .fnt2cmpmorefirst	 
2188			 
2188				; first char not found move to next char 
2188			 
2188 23				inc hl 
2189 18 f4			jr .fnt1 
218b			 
218b			.fnt2cmpmorefirst:	 
218b				; first char of token found.  
218b			 
218b e5				push hl     ; save start of token just in case it is the right one 
218c d9				exx 
218d e1				pop hl        ; save it to hl' 
218e d9				exx 
218f			 
218f			 
218f			.fnt2cmpmore:	 
218f				; compare the rest 
218f				 
218f 23				inc hl 
2190 13				inc de 
2191				 
2191 1a				ld a, (de) 
2192 4f				ld c,a 
2193 7e				ld a,(hl) 
2194 cd 70 11			call toUpper 
2197			 
2197					if DEBUG_FORTH 
2197						DMARK "NT2" 
2197						CALLMONITOR 
2197					endif 
2197				; c has the token to find char 
2197				; a has the mem to scan char 
2197			 
2197 b9				cp c 
2198 28 04			jr z,.fntmatch1 
219a			 
219a				; they are not the same 
219a			 
219a					if DEBUG_FORTH 
219a						DMARK "NT3" 
219a						CALLMONITOR 
219a					endif 
219a d1				pop de	; reset de token to look for 
219b d5				push de 
219c 18 e1			jr .fnt1 
219e				 
219e			.fntmatch1: 
219e			 
219e				; is the same char a null which means we might have a full hit? 
219e					if DEBUG_FORTH 
219e						DMARK "NT4" 
219e						CALLMONITOR 
219e					endif 
219e			 
219e fe 00			cp 0 
21a0 28 0b			jr z, .fntmatchyes 
21a2			 
21a2				; are we at the end of the token to find? 
21a2			 
21a2					if DEBUG_FORTH 
21a2						DMARK "NT5" 
21a2						CALLMONITOR 
21a2					endif 
21a2 3e 00			ld a, 0 
21a4 b9				cp c 
21a5			 
21a5 c2 8f 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
21a8			 
21a8					if DEBUG_FORTH 
21a8						DMARK "NT6" 
21a8						CALLMONITOR 
21a8					endif 
21a8				; token to find is exhusted but no match to stream 
21a8			 
21a8				; restore tok pointer and continue on 
21a8 d1				pop de 
21a9 d5				push de 
21aa c3 7f 21			jp .fnt1 
21ad			 
21ad			 
21ad			.fntmatchyes: 
21ad			 
21ad				; hl now contains the end of the found token 
21ad			 
21ad				; get rid of saved token pointer to find 
21ad			 
21ad d1				pop de 
21ae			 
21ae					if DEBUG_FORTH 
21ae						DMARK "NT9" 
21ae						CALLMONITOR 
21ae					endif 
21ae			 
21ae				; hl will be on the null term so forward on 
21ae			 
21ae				; get back the saved start of the token 
21ae			 
21ae d9				exx 
21af e5				push hl     ; save start of token just in case it is the right one 
21b0 d9				exx 
21b1 e1				pop hl        ; save it to hl 
21b2			 
21b2 c9				ret 
21b3			 
21b3			 
21b3			; LIST needs to find a specific token   
21b3			; FORGET needs to find a spefici token 
21b3			 
21b3			; SAVE needs to find all tokens by flag 
21b3			; WORDS just needs to scan through all  by flag 
21b3			; UWORDS needs to scan through all by flag 
21b3			 
21b3			 
21b3			; given hl as pointer to start of dict look up string 
21b3			; return hl as pointer to start of word block 
21b3			; or 0 if not found 
21b3			 
21b3			forth_find_tok: 
21b3 c9				ret 
21b4			 
21b4			; given hl as pointer to dict structure 
21b4			; move to the next dict block structure 
21b4			 
21b4			forth_tok_next: 
21b4				; hl now points to the address of the next word pointer  
21b4				; TODO skip compiled symbol for now 
21b4			;	push de 
21b4 23				inc hl 
21b5 5e				ld e, (hl) 
21b6 23				inc hl 
21b7 56				ld d, (hl) 
21b8 23				inc hl 
21b9			 
21b9 eb				ex de,hl 
21ba			if DEBUG_FORTH_PARSE_NEXTWORD 
21ba				push bc 
21ba				ld bc, (cli_nextword) 
21ba						DMARK "NXW" 
21ba				CALLMONITOR 
21ba				pop bc 
21ba			endif 
21ba			;	pop de	 
21ba c9				ret 
21bb			 
21bb			 
21bb			 
21bb			; eof 
# End of file forth_parserv5.asm
21bb				include "forth_wordsv4.asm" 
21bb			 
21bb			; the core word dictionary v4 
21bb			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
21bb			 
21bb			; this is a linked list for each of the system words used 
21bb			; user defined words will follow the same format but will be in ram 
21bb			 
21bb			 
21bb			; 
21bb			; 
21bb			; define linked list: 
21bb			; 
21bb			; 1. compiled byte op code 
21bb			; 2. len of text word 
21bb			; 3. text word 
21bb			; 4. ptr to next dictionary word 
21bb			; 5. asm, calls etc for the word 
21bb			; 
21bb			;  if 1 == 0 then last word in dict  
21bb			;   
21bb			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
21bb			;  
21bb			;  
21bb			; create basic standard set of words 
21bb			; 
21bb			;  
21bb			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
21bb			; 2DUP 2DROP 2SWAP  
21bb			; @ C@ - get byte  
21bb			; ! C! - store byte 
21bb			; 0< true if less than zero 
21bb			; 0= true if zero 
21bb			; < >  
21bb			; = true if same 
21bb			; variables 
21bb			 
21bb			 
21bb			; Hardware specific words I may need 
21bb			; 
21bb			; IN OUT  
21bb			; calls to key util functions 
21bb			; calls to hardward abstraction stuff 
21bb			; easy control of frame buffers and lcd i/o 
21bb			; keyboard  
21bb			 
21bb			 
21bb			;DICT: macro 
21bb			; op_code, len, word, next 
21bb			;    word: 
21bb			;    db op_code 
21bb			;    ds word zero term 
21bb			;    dw next 
21bb			;    endm 
21bb			 
21bb			 
21bb			 
21bb			 
21bb			; op code 1 is a flag for user define words which are to be handled differently 
21bb			 
21bb			 
21bb			; 
21bb			; 
21bb			;    TODO on entry to a word this should be the expected environment 
21bb			;    hl - tos value if number then held, if string this is the ptr 
21bb			;    de -  
21bb			 
21bb			 
21bb			; opcode ranges 
21bb			; 0 - end of word dict 
21bb			; 255 - user define words 
21bb			 
21bb			sysdict: 
21bb			include "forth_opcodes.asm" 
21bb			; op codes for forth keywords 
21bb			; free to use code 0  
21bb				OPCODE_HEAP: equ  1 
21bb				OPCODE_EXEC: equ 2 
21bb				OPCODE_DUP: equ 3 
21bb				OPCODE_SWAP: equ 4 
21bb				OPCODE_COLN: equ 5 
21bb				OPCODE_SCOLN: equ 6 
21bb				OPCODE_DROP: equ 7 
21bb				OPCODE_DUP2: equ 8 
21bb				OPCODE_DROP2: equ 9 
21bb				OPCODE_SWAP2: equ 10 
21bb				OPCODE_AT: equ 11 
21bb				OPCODE_CAT: equ 12 
21bb				OPCODE_BANG: equ 13 
21bb				OPCODE_CBANG: equ 14 
21bb				OPCODE_SCALL: equ 15 
21bb				OPCODE_DEPTH: equ 16 
21bb				OPCODE_OVER: equ 17 
21bb				OPCODE_PAUSE: equ 18 
21bb				OPCODE_PAUSES: equ 19 
21bb				OPCODE_ROT: equ 20 
21bb			;free to reuse	OPCODE_WORDS: equ 21 
21bb			        OPCODE_NOT: equ 21 
21bb				OPCODE_UWORDS: equ 22 
21bb				OPCODE_BP: equ 23 
21bb				OPCODE_MONITOR: equ 24  
21bb				OPCODE_MALLOC: equ 25 
21bb				OPCODE_FREE: equ 26 
21bb				OPCODE_LIST: equ 27 
21bb				OPCODE_FORGET: equ 28 
21bb				OPCODE_NOP: equ 29 
21bb				OPCODE_COMO: equ 30 
21bb				OPCODE_COMC: equ 31 
21bb			;free to reuse	OPCODE_ENDCORE: equ 32 
21bb				OPCODE_AFTERSOUND: equ 33 
21bb				OPCODE_GP2: equ 34 
21bb				OPCODE_GP3: equ 35 
21bb				OPCODE_GP4: equ 36 
21bb				OPCODE_SIN: equ 37 
21bb				OPCODE_SOUT: equ 38 
21bb				OPCODE_SPIO: equ 39 
21bb				OPCODE_SPICEH: equ 40 
21bb				OPCODE_SPIOb: equ 41 
21bb				OPCODE_SPII: equ 42 
21bb				OPCODE_SESEL: equ 43 
21bb				OPCODE_CARTDEV: equ 44 
21bb			; free to reuse	OPCODE_ENDDEVICE: equ 45 
21bb				OPCODE_FB: equ 46 
21bb				OPCODE_EMIT: equ 47 
21bb				OPCODE_DOTH: equ 48 
21bb				OPCODE_DOTF: equ 49 
21bb				OPCODE_DOT: equ 50 
21bb				OPCODE_CLS: equ 51 
21bb				OPCODE_DRAW: equ 52 
21bb				OPCODE_DUMP: equ 53 
21bb				OPCODE_CDUMP: equ 54 
21bb				OPCODE_DAT: equ 55 
21bb				OPCODE_HOME: equ 56 
21bb				OPCODE_SPACE: equ 57 
21bb				OPCODE_SPACES: equ 58 
21bb				OPCODE_SCROLL: equ 59 
21bb				OPCODE_ATQ: equ 60 
21bb				OPCODE_AUTODSP: equ 61 
21bb				OPCODE_MENU: equ 62 
21bb			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
21bb				OPCODE_THEN: equ 64 
21bb				OPCODE_ELSE: equ 65 
21bb				OPCODE_DO: equ 66 
21bb				OPCODE_LOOP: equ 67 
21bb				OPCODE_I: equ 68 
21bb				OPCODE_DLOOP: equ 69  
21bb				OPCODE_REPEAT: equ 70  
21bb				OPCODE_UNTIL: equ 71 
21bb				OPCODE_ENDFLOW: equ 72 
21bb				OPCODE_WAITK: equ 73 
21bb				OPCODE_ACCEPT: equ 74 
21bb				OPCODE_EDIT: equ 75 
21bb			;free to reuse	OPCODE_ENDKEY: equ 76 
21bb				OPCODE_LZERO: equ 77 
21bb				OPCODE_TZERO: equ 78 
21bb				OPCODE_LESS: equ 79 
21bb				OPCODE_GT: equ 80 
21bb				OPCODE_EQUAL: equ 81  
21bb			;free to reuse	OPCODE_ENDLOGIC: equ 82 
21bb				OPCODE_NEG: equ 83 
21bb				OPCODE_DIV: equ 84 
21bb				OPCODE_MUL: equ 85 
21bb				OPCODE_MIN: equ 86 
21bb				OPCODE_MAX: equ 87 
21bb				OPCODE_RND16: equ 88 
21bb				OPCODE_RND8: equ 89 
21bb				OPCODE_RND: equ 90 
21bb			;free to reuse	OPCODE_ENDMATHS: equ 91  
21bb				OPCODE_BYNAME: equ 92 
21bb				OPCODE_DIR: equ 93 
21bb				OPCODE_SAVE: equ 94 
21bb				OPCODE_LOAD: equ 95 
21bb				OPCODE_BSAVE: equ 96 
21bb				OPCODE_BLOAD: equ 97 
21bb				OPCODE_SEO: equ 98  
21bb				OPCODE_SEI: equ 99 
21bb				OPCODE_SFREE: equ 100 
21bb				OPCODE_SIZE: equ 101 
21bb				OPCODE_CREATE: equ 102 
21bb				OPCODE_APPEND: equ 103 
21bb				OPCODE_SDEL: equ 104 
21bb				OPCODE_OPEN: equ 105 
21bb				OPCODE_READ: equ 106 
21bb				OPCODE_EOF: equ 106 
21bb				OPCODE_FORMAT: equ 107 
21bb				OPCODE_LABEL: equ 108 
21bb				OPCODE_LABELS: equ 109 
21bb			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
21bb				OPCODE_UPPER: equ 111 
21bb				OPCODE_LOWER: equ 112 
21bb				OPCODE_SUBSTR: equ 113 
21bb				OPCODE_LEFT: equ 114 
21bb				OPCODE_RIGHT: equ 115 
21bb				OPCODE_STR2NUM: equ 116 
21bb				OPCODE_NUM2STR: equ 117 
21bb				OPCODE_CONCAT: equ 118 
21bb				OPCODE_FIND: equ 119 
21bb				OPCODE_LEN: equ 120 
21bb				OPCODE_CHAR: equ 121 
21bb			; free to reuse	OPCODE_STRLEN: equ 122 
21bb			; free to reuse	OPCODE_ENDSTR: equ 123 
21bb				OPCODE_V0S: equ 124 
21bb				OPCODE_V0Q: equ 125 
21bb				OPCODE_V1S: equ 126 
21bb				OPCODE_V1Q: equ 127 
21bb				OPCODE_V2S: equ 128 
21bb				OPCODE_V2Q: equ 129 
21bb				OPCODE_V3S: equ 130 
21bb				OPCODE_V3Q: equ 131 
21bb			;free to reuse	OPCODE_END: equ 132 
21bb				OPCODE_ZDUP: equ 133 
21bb			 
21bb			; eof 
# End of file forth_opcodes.asm
21bb			 
21bb			include "forth_words_core.asm" 
21bb			 
21bb			; | ## Core Words 
21bb			 
21bb			;if MALLOC_4 
21bb			 
21bb			.HEAP: 
21bb				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
21bb 15				db WORD_SYS_CORE+OPCODE_HEAP             
21bc fa 21			dw .EXEC            
21be 05				db 4 + 1 
21bf .. 00			db "HEAP",0              
21c4				endm 
# End of macro CWHEAD
21c4			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21c4			; | | u1 - Current number of bytes in the heap 
21c4			; | | u2 - Remaining bytes left on the heap 
21c4			; | |  
21c4			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21c4			 
21c4			 
21c4					if DEBUG_FORTH_WORDS_KEY 
21c4						DMARK "HEP" 
21c4 f5				push af  
21c5 3a d9 21			ld a, (.dmark)  
21c8 32 6e fb			ld (debug_mark),a  
21cb 3a da 21			ld a, (.dmark+1)  
21ce 32 6f fb			ld (debug_mark+1),a  
21d1 3a db 21			ld a, (.dmark+2)  
21d4 32 70 fb			ld (debug_mark+2),a  
21d7 18 03			jr .pastdmark  
21d9 ..			.dmark: db "HEP"  
21dc f1			.pastdmark: pop af  
21dd			endm  
# End of macro DMARK
21dd						CALLMONITOR 
21dd cd 6a 17			call break_point_state  
21e0				endm  
# End of macro CALLMONITOR
21e0					endif 
21e0 2a 0a 80				ld hl, (free_list )      
21e3 11 0e 80				ld de, heap_start 
21e6			 
21e6 ed 52				sbc hl, de  
21e8			 
21e8 cd fa 1c				call forth_push_numhl 
21eb			 
21eb			 
21eb ed 5b 0a 80			ld de, (free_list )      
21ef 21 fa ed				ld hl, heap_end 
21f2			 
21f2 ed 52				sbc hl, de 
21f4			 
21f4 cd fa 1c				call forth_push_numhl 
21f7					 
21f7			 
21f7					 
21f7			 
21f7			 
21f7			 
21f7					NEXTW 
21f7 c3 63 20			jp macro_next 
21fa				endm 
# End of macro NEXTW
21fa			;endif 
21fa			 
21fa			.EXEC: 
21fa			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21fa			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21fa			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21fa			;; > > 
21fa			;; > >   
21fa			;	STACKFRAME OFF $5efe $5f9f 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS_KEY 
21fa			;			DMARK "EXE" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			; 
21fa			;	FORTH_DSP_VALUEHL 
21fa			; 
21fa			;	FORTH_DSP_POP 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EX1" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;;	ld e,(hl) 
21fa			;;	inc hl 
21fa			;;	ld d,(hl) 
21fa			;;	ex de,hl 
21fa			; 
21fa			;;		if DEBUG_FORTH_WORDS 
21fa			;;			DMARK "EX2" 
21fa			;;			CALLMONITOR 
21fa			;;		endif 
21fa			;	push hl 
21fa			; 
21fa			;	;ld a, 0 
21fa			;	;ld a, FORTH_END_BUFFER 
21fa			;	call strlenz 
21fa			;	inc hl   ; include zero term to copy 
21fa			;	inc hl   ; include term 
21fa			;	inc hl   ; include term 
21fa			;	ld b,0 
21fa			;	ld c,l 
21fa			;	pop hl 
21fa			;	ld de, execscratch 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EX3" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;	ldir 
21fa			; 
21fa			; 
21fa			;	ld hl, execscratch 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EXe" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			; 
21fa			;	call forthparse 
21fa			;	call forthexec 
21fa			;;	call forthexec_cleanup 
21fa			;;	call forthparse 
21fa			;;	call forthexec 
21fa			; 
21fa			;	STACKFRAMECHK OFF $5efe $5f9f 
21fa			; 
21fa			;	; an immediate word so no need to process any more words 
21fa			;	ret 
21fa			;	NEXTW 
21fa			 
21fa			; dead code - old version  
21fa			;	FORTH_RSP_NEXT 
21fa			 
21fa			;  
21fa			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21fa			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21fa			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21fa			;	push hl 
21fa			;	push de 
21fa			;	push bc 
21fa			; 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS_KEY 
21fa			;			DMARK "EXR" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			; 
21fa			; 
21fa			; 
21fa			;	;v5 FORTH_DSP_VALUE 
21fa			;	FORTH_DSP_VALUEHL 
21fa			; 
21fa			;	; TODO do string type checks 
21fa			; 
21fa			;;v5	inc hl   ; skip type 
21fa			; 
21fa			;	push hl  ; source code  
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EX1" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;	ld a, 0 
21fa			;	call strlent 
21fa			; 
21fa			;	inc hl 
21fa			;	inc hl 
21fa			;	inc hl 
21fa			;	inc hl 
21fa			; 
21fa			;	push hl    ; size 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EX2" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;	call malloc 
21fa			; 
21fa			;	ex de, hl    ; de now contains malloc area 
21fa			;	pop bc   	; get byte count 
21fa			;	pop hl      ; get string to copy 
21fa			; 
21fa			;	push de     ; save malloc for free later 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EX3" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;	ldir       ; duplicate string 
21fa			; 
21fa			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21fa			;	 
21fa			;	; TODO fix the parse would be better than this...  
21fa			;	ex de, hl 
21fa			;	dec hl 
21fa			;	ld a, 0 
21fa			;	ld (hl), a 
21fa			;	dec hl 
21fa			;	ld a, ' ' 
21fa			;	ld (hl), a 
21fa			;	dec hl 
21fa			;	ld (hl), a 
21fa			; 
21fa			;	dec hl 
21fa			;	ld (hl), a 
21fa			; 
21fa			; 
21fa			;	FORTH_DSP_POP  
21fa			; 
21fa			;	pop hl     
21fa			;	push hl    ; save malloc area 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EX4" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			; 
21fa			;	call forthparse 
21fa			;	call forthexec 
21fa			;	 
21fa			;	pop hl 
21fa			;	if DEBUG_FORTH_WORDS 
21fa			;		DMARK "EX5" 
21fa			;		CALLMONITOR 
21fa			;	endif 
21fa			; 
21fa			;	if FORTH_ENABLE_FREE 
21fa			;	call free 
21fa			;	endif 
21fa			; 
21fa			;	if DEBUG_FORTH_WORDS 
21fa			;		DMARK "EX6" 
21fa			;		CALLMONITOR 
21fa			;	endif 
21fa			; 
21fa			;	pop bc 
21fa			;	pop de 
21fa			;	pop hl 
21fa			;;	FORTH_RSP_POP	  
21fa			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21fa			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21fa			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21fa			; 
21fa			;	if DEBUG_FORTH_WORDS 
21fa			;		DMARK "EX7" 
21fa			;		CALLMONITOR 
21fa			;	endif 
21fa			;	NEXTW 
21fa			 
21fa			;.STKEXEC: 
21fa			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21fa			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21fa			; 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS_KEY 
21fa			;			DMARK "STX" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			; 
21fa			;	FORTH_DSP_VALUEHL 
21fa			; 
21fa			;	ld (store_tmp1), hl    ; count 
21fa			; 
21fa			;	FORTH_DSP_POP 
21fa			;.stkexec1: 
21fa			;	ld hl, (store_tmp1)   ; count 
21fa			;	ld a, 0 
21fa			;	cp l 
21fa			;	ret z 
21fa			; 
21fa			;	dec hl 
21fa			;	ld (store_tmp1), hl    ; count 
21fa			;	 
21fa			;	FORTH_DSP_VALUEHL 
21fa			;	push hl 
21fa			;	 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EXp" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;	FORTH_DSP_POP 
21fa			; 
21fa			;	call strlenz 
21fa			;	inc hl   ; include zero term to copy 
21fa			;	inc hl   ; include zero term to copy 
21fa			;	inc hl   ; include zero term to copy 
21fa			;	ld b,0 
21fa			;	ld c,l 
21fa			;	pop hl 
21fa			;	ld de, execscratch 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EX3" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;	ldir 
21fa			; 
21fa			; 
21fa			;	ld hl, execscratch 
21fa			; 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EXP" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			; 
21fa			;	call forthparse 
21fa			;	ld hl, execscratch 
21fa			;		if DEBUG_FORTH_WORDS 
21fa			;			DMARK "EXx" 
21fa			;			CALLMONITOR 
21fa			;		endif 
21fa			;	call forthexec 
21fa			; 
21fa			;	jp .stkexec1 
21fa			; 
21fa			;	ret 
21fa			 
21fa			 
21fa			.DUP: 
21fa				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21fa 17				db WORD_SYS_CORE+OPCODE_DUP             
21fb 70 22			dw .ZDUP            
21fd 04				db 3 + 1 
21fe .. 00			db "DUP",0              
2202				endm 
# End of macro CWHEAD
2202			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2202			 
2202					if DEBUG_FORTH_WORDS_KEY 
2202						DMARK "DUP" 
2202 f5				push af  
2203 3a 17 22			ld a, (.dmark)  
2206 32 6e fb			ld (debug_mark),a  
2209 3a 18 22			ld a, (.dmark+1)  
220c 32 6f fb			ld (debug_mark+1),a  
220f 3a 19 22			ld a, (.dmark+2)  
2212 32 70 fb			ld (debug_mark+2),a  
2215 18 03			jr .pastdmark  
2217 ..			.dmark: db "DUP"  
221a f1			.pastdmark: pop af  
221b			endm  
# End of macro DMARK
221b						CALLMONITOR 
221b cd 6a 17			call break_point_state  
221e				endm  
# End of macro CALLMONITOR
221e					endif 
221e			 
221e					FORTH_DSP 
221e cd b7 1e			call macro_forth_dsp 
2221				endm 
# End of macro FORTH_DSP
2221			 
2221 7e					ld a, (HL) 
2222 fe 01				cp DS_TYPE_STR 
2224 20 25				jr nz, .dupinum 
2226			 
2226					; push another string 
2226			 
2226					FORTH_DSP_VALUEHL     		 
2226 cd f1 1e			call macro_dsp_valuehl 
2229				endm 
# End of macro FORTH_DSP_VALUEHL
2229			 
2229				if DEBUG_FORTH_WORDS 
2229					DMARK "DUs" 
2229 f5				push af  
222a 3a 3e 22			ld a, (.dmark)  
222d 32 6e fb			ld (debug_mark),a  
2230 3a 3f 22			ld a, (.dmark+1)  
2233 32 6f fb			ld (debug_mark+1),a  
2236 3a 40 22			ld a, (.dmark+2)  
2239 32 70 fb			ld (debug_mark+2),a  
223c 18 03			jr .pastdmark  
223e ..			.dmark: db "DUs"  
2241 f1			.pastdmark: pop af  
2242			endm  
# End of macro DMARK
2242					CALLMONITOR 
2242 cd 6a 17			call break_point_state  
2245				endm  
# End of macro CALLMONITOR
2245				endif 
2245 cd 68 1d				call forth_push_str 
2248			 
2248					NEXTW 
2248 c3 63 20			jp macro_next 
224b				endm 
# End of macro NEXTW
224b			 
224b			 
224b			.dupinum: 
224b					 
224b			 
224b			 
224b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
224b cd f1 1e			call macro_dsp_valuehl 
224e				endm 
# End of macro FORTH_DSP_VALUEHL
224e			 
224e				; TODO add floating point number detection 
224e			 
224e				if DEBUG_FORTH_WORDS 
224e					DMARK "DUi" 
224e f5				push af  
224f 3a 63 22			ld a, (.dmark)  
2252 32 6e fb			ld (debug_mark),a  
2255 3a 64 22			ld a, (.dmark+1)  
2258 32 6f fb			ld (debug_mark+1),a  
225b 3a 65 22			ld a, (.dmark+2)  
225e 32 70 fb			ld (debug_mark+2),a  
2261 18 03			jr .pastdmark  
2263 ..			.dmark: db "DUi"  
2266 f1			.pastdmark: pop af  
2267			endm  
# End of macro DMARK
2267					CALLMONITOR 
2267 cd 6a 17			call break_point_state  
226a				endm  
# End of macro CALLMONITOR
226a				endif 
226a			 
226a cd fa 1c				call forth_push_numhl 
226d					NEXTW 
226d c3 63 20			jp macro_next 
2270				endm 
# End of macro NEXTW
2270			.ZDUP: 
2270				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2270 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2271 a8 22			dw .SWAP            
2273 05				db 4 + 1 
2274 .. 00			db "?DUP",0              
2279				endm 
# End of macro CWHEAD
2279			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2279			 
2279					if DEBUG_FORTH_WORDS_KEY 
2279						DMARK "qDU" 
2279 f5				push af  
227a 3a 8e 22			ld a, (.dmark)  
227d 32 6e fb			ld (debug_mark),a  
2280 3a 8f 22			ld a, (.dmark+1)  
2283 32 6f fb			ld (debug_mark+1),a  
2286 3a 90 22			ld a, (.dmark+2)  
2289 32 70 fb			ld (debug_mark+2),a  
228c 18 03			jr .pastdmark  
228e ..			.dmark: db "qDU"  
2291 f1			.pastdmark: pop af  
2292			endm  
# End of macro DMARK
2292						CALLMONITOR 
2292 cd 6a 17			call break_point_state  
2295				endm  
# End of macro CALLMONITOR
2295					endif 
2295					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2295 cd f1 1e			call macro_dsp_valuehl 
2298				endm 
# End of macro FORTH_DSP_VALUEHL
2298			 
2298 e5					push hl 
2299			 
2299					; is it a zero? 
2299			 
2299 3e 00				ld a, 0 
229b 84					add h 
229c 85					add l 
229d			 
229d e1					pop hl 
229e			 
229e fe 00				cp 0 
22a0 28 03				jr z, .dup2orig 
22a2			 
22a2			 
22a2 cd fa 1c				call forth_push_numhl 
22a5			 
22a5			 
22a5				; TODO add floating point number detection 
22a5			 
22a5			.dup2orig: 
22a5			 
22a5					NEXTW 
22a5 c3 63 20			jp macro_next 
22a8				endm 
# End of macro NEXTW
22a8			.SWAP: 
22a8				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
22a8 18				db WORD_SYS_CORE+OPCODE_SWAP             
22a9 e7 22			dw .COLN            
22ab 05				db 4 + 1 
22ac .. 00			db "SWAP",0              
22b1				endm 
# End of macro CWHEAD
22b1			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
22b1					if DEBUG_FORTH_WORDS_KEY 
22b1						DMARK "SWP" 
22b1 f5				push af  
22b2 3a c6 22			ld a, (.dmark)  
22b5 32 6e fb			ld (debug_mark),a  
22b8 3a c7 22			ld a, (.dmark+1)  
22bb 32 6f fb			ld (debug_mark+1),a  
22be 3a c8 22			ld a, (.dmark+2)  
22c1 32 70 fb			ld (debug_mark+2),a  
22c4 18 03			jr .pastdmark  
22c6 ..			.dmark: db "SWP"  
22c9 f1			.pastdmark: pop af  
22ca			endm  
# End of macro DMARK
22ca						CALLMONITOR 
22ca cd 6a 17			call break_point_state  
22cd				endm  
# End of macro CALLMONITOR
22cd					endif 
22cd			 
22cd					FORTH_DSP_VALUEHL 
22cd cd f1 1e			call macro_dsp_valuehl 
22d0				endm 
# End of macro FORTH_DSP_VALUEHL
22d0 e5					push hl     ; w2 
22d1			 
22d1					FORTH_DSP_POP 
22d1 cd a9 1f			call macro_forth_dsp_pop 
22d4				endm 
# End of macro FORTH_DSP_POP
22d4			 
22d4					FORTH_DSP_VALUEHL 
22d4 cd f1 1e			call macro_dsp_valuehl 
22d7				endm 
# End of macro FORTH_DSP_VALUEHL
22d7			 
22d7					FORTH_DSP_POP 
22d7 cd a9 1f			call macro_forth_dsp_pop 
22da				endm 
# End of macro FORTH_DSP_POP
22da			 
22da d1					pop de     ; w2	, hl = w1 
22db			 
22db eb					ex de, hl 
22dc d5					push de 
22dd			 
22dd cd fa 1c				call forth_push_numhl 
22e0			 
22e0 e1					pop hl 
22e1			 
22e1 cd fa 1c				call forth_push_numhl 
22e4					 
22e4			 
22e4					NEXTW 
22e4 c3 63 20			jp macro_next 
22e7				endm 
# End of macro NEXTW
22e7			.COLN: 
22e7				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22e7 19				db WORD_SYS_CORE+OPCODE_COLN             
22e8 73 24			dw .SCOLN            
22ea 02				db 1 + 1 
22eb .. 00			db ":",0              
22ed				endm 
# End of macro CWHEAD
22ed			; | : ( -- )         Create new word | DONE 
22ed			 
22ed					if DEBUG_FORTH_WORDS_KEY 
22ed						DMARK "CLN" 
22ed f5				push af  
22ee 3a 02 23			ld a, (.dmark)  
22f1 32 6e fb			ld (debug_mark),a  
22f4 3a 03 23			ld a, (.dmark+1)  
22f7 32 6f fb			ld (debug_mark+1),a  
22fa 3a 04 23			ld a, (.dmark+2)  
22fd 32 70 fb			ld (debug_mark+2),a  
2300 18 03			jr .pastdmark  
2302 ..			.dmark: db "CLN"  
2305 f1			.pastdmark: pop af  
2306			endm  
# End of macro DMARK
2306						CALLMONITOR 
2306 cd 6a 17			call break_point_state  
2309				endm  
# End of macro CALLMONITOR
2309					endif 
2309				STACKFRAME OFF $8efe $989f 
2309				if DEBUG_STACK_IMB 
2309					if OFF 
2309						exx 
2309						ld de, $8efe 
2309						ld a, d 
2309						ld hl, curframe 
2309						call hexout 
2309						ld a, e 
2309						ld hl, curframe+2 
2309						call hexout 
2309						ld hl, $8efe 
2309						push hl 
2309						ld hl, $989f 
2309						push hl 
2309						exx 
2309					endif 
2309				endif 
2309			endm 
# End of macro STACKFRAME
2309				; get parser buffer length  of new word 
2309			 
2309				 
2309			 
2309					; move tok past this to start of name defintition 
2309					; TODO get word to define 
2309					; TODO Move past word token 
2309					; TODO get length of string up to the ';' 
2309			 
2309 2a 15 f1			ld hl, (os_tok_ptr) 
230c 23				inc hl 
230d 23				inc hl 
230e			 
230e 3e 3b			ld a, ';' 
2310 cd 84 11			call strlent 
2313			 
2313 7d				ld a,l 
2314 32 10 ee			ld (os_new_parse_len), a 
2317			 
2317			 
2317			if DEBUG_FORTH_UWORD 
2317 ed 5b 15 f1		ld de, (os_tok_ptr) 
231b						DMARK ":01" 
231b f5				push af  
231c 3a 30 23			ld a, (.dmark)  
231f 32 6e fb			ld (debug_mark),a  
2322 3a 31 23			ld a, (.dmark+1)  
2325 32 6f fb			ld (debug_mark+1),a  
2328 3a 32 23			ld a, (.dmark+2)  
232b 32 70 fb			ld (debug_mark+2),a  
232e 18 03			jr .pastdmark  
2330 ..			.dmark: db ":01"  
2333 f1			.pastdmark: pop af  
2334			endm  
# End of macro DMARK
2334				CALLMONITOR 
2334 cd 6a 17			call break_point_state  
2337				endm  
# End of macro CALLMONITOR
2337			endif 
2337			 
2337			; 
2337			;  new word memory layout: 
2337			;  
2337			;    : adg 6666 ;  
2337			; 
2337			;    db   1     ; user defined word  
2337 23				inc hl    
2338			;    dw   sysdict 
2338 23				inc hl 
2339 23				inc hl 
233a			;    db <word len>+1 (for null) 
233a 23				inc hl 
233b			;    db .... <word> 
233b			; 
233b			 
233b 23				inc hl    ; some extras for the word preamble before the above 
233c 23				inc hl 
233d 23				inc hl 
233e 23				inc hl 
233f 23				inc hl 
2340 23				inc hl 
2341 23				inc hl  
2342 23				inc hl 
2343 23				inc hl 
2344 23				inc hl 
2345 23				inc hl 
2346 23				inc hl 
2347 23				inc hl 
2348 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2349			;       exec word buffer 
2349			;	<ptr word>   
2349 23				inc hl 
234a 23				inc hl 
234b			;       <word list><null term> 7F final term 
234b			 
234b			 
234b			if DEBUG_FORTH_UWORD 
234b						DMARK ":02" 
234b f5				push af  
234c 3a 60 23			ld a, (.dmark)  
234f 32 6e fb			ld (debug_mark),a  
2352 3a 61 23			ld a, (.dmark+1)  
2355 32 6f fb			ld (debug_mark+1),a  
2358 3a 62 23			ld a, (.dmark+2)  
235b 32 70 fb			ld (debug_mark+2),a  
235e 18 03			jr .pastdmark  
2360 ..			.dmark: db ":02"  
2363 f1			.pastdmark: pop af  
2364			endm  
# End of macro DMARK
2364				CALLMONITOR 
2364 cd 6a 17			call break_point_state  
2367				endm  
# End of macro CALLMONITOR
2367			endif 
2367			 
2367				 
2367					; malloc the size 
2367			 
2367 cd e2 11				call malloc 
236a 22 12 ee				ld (os_new_malloc), hl     ; save malloc start 
236d			 
236d			;    db   1     ; user defined word  
236d 3e 01				ld a, WORD_SYS_UWORD  
236f 77					ld (hl), a 
2370				 
2370 23				inc hl    
2371			;    dw   sysdict 
2371 11 bb 21			ld de, sysdict       ; continue on with the scan to the system dict 
2374 73				ld (hl), e 
2375 23				inc hl 
2376 72				ld (hl), d 
2377 23				inc hl 
2378			 
2378			 
2378			;    Setup dict word 
2378			 
2378 23				inc hl 
2379 22 0c ee			ld (os_new_work_ptr), hl     ; save start of dict word  
237c			 
237c				; 1. get length of dict word 
237c			 
237c			 
237c 2a 15 f1			ld hl, (os_tok_ptr) 
237f 23				inc hl 
2380 23				inc hl    ; position to start of dict word 
2381 3e 00			ld a, 0 
2383 cd 84 11			call strlent 
2386			 
2386			 
2386 23				inc hl    ; to include null??? 
2387			 
2387				; write length of dict word 
2387			 
2387 ed 5b 0c ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
238b 1b				dec de 
238c eb				ex de, hl 
238d 73				ld (hl), e 
238e eb				ex de, hl 
238f			 
238f				 
238f			 
238f				; copy  
238f 4d				ld c, l 
2390 06 00			ld b, 0 
2392 ed 5b 0c ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2396 2a 15 f1			ld hl, (os_tok_ptr) 
2399 23				inc hl 
239a 23				inc hl    ; position to start of dict word 
239b				 
239b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
239b				 
239b				; TODO need to convert word to upper case 
239b			 
239b			ucasetok:	 
239b 7e				ld a,(hl) 
239c cd 70 11			call toUpper 
239f 77				ld (hl),a 
23a0 ed a0			ldi 
23a2 f2 9b 23		 	jp p, ucasetok 
23a5			 
23a5			 
23a5			 
23a5				; de now points to start of where the word body code should be placed 
23a5 ed 53 0c ee		ld (os_new_work_ptr), de 
23a9				; hl now points to the words to throw at forthexec which needs to be copied 
23a9 22 0a ee			ld (os_new_src_ptr), hl 
23ac			 
23ac				; TODO add 'call to forthexec' 
23ac			 
23ac			if DEBUG_FORTH_UWORD 
23ac c5				push bc 
23ad ed 4b 12 ee		ld bc, (os_new_malloc) 
23b1						DMARK ":0x" 
23b1 f5				push af  
23b2 3a c6 23			ld a, (.dmark)  
23b5 32 6e fb			ld (debug_mark),a  
23b8 3a c7 23			ld a, (.dmark+1)  
23bb 32 6f fb			ld (debug_mark+1),a  
23be 3a c8 23			ld a, (.dmark+2)  
23c1 32 70 fb			ld (debug_mark+2),a  
23c4 18 03			jr .pastdmark  
23c6 ..			.dmark: db ":0x"  
23c9 f1			.pastdmark: pop af  
23ca			endm  
# End of macro DMARK
23ca				CALLMONITOR 
23ca cd 6a 17			call break_point_state  
23cd				endm  
# End of macro CALLMONITOR
23cd c1				pop bc 
23ce			endif 
23ce			 
23ce			 
23ce				; create word preamble which should be: 
23ce			 
23ce			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23ce			 
23ce				;    ld hl, <word code> 
23ce				;    jp user_exec 
23ce			        ;    <word code bytes> 
23ce			 
23ce			 
23ce			;	inc de     ; TODO ??? or are we already past the word's null 
23ce eb				ex de, hl 
23cf			 
23cf 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23d1			 
23d1 23				inc hl 
23d2 22 06 ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23d5 23				inc hl 
23d6			 
23d6 23				inc hl 
23d7 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23d9			 
23d9 01 52 51			ld bc, user_exec 
23dc 23				inc hl 
23dd 71				ld (hl), c     ; poke address of user_exec 
23de 23				inc hl 
23df 70				ld (hl), b     
23e0			 ; 
23e0			;	inc hl 
23e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23e0			; 
23e0			; 
23e0			;	ld bc, macro_forth_rsp_next 
23e0			;	inc hl 
23e0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23e0			;	inc hl 
23e0			;	ld (hl), b     
23e0			 ; 
23e0			;	inc hl 
23e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23e0			; 
23e0			; 
23e0			;	inc hl 
23e0			;	ld bc, forthexec 
23e0			;	ld (hl), c     ; poke address of forthexec 
23e0			;	inc hl 
23e0			;	ld (hl), b      
23e0			; 
23e0			;	inc hl 
23e0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23e0			; 
23e0			;	ld bc, user_dict_next 
23e0			;	inc hl 
23e0			;	ld (hl), c     ; poke address of forthexec 
23e0			;	inc hl 
23e0			;	ld (hl), b      
23e0			 
23e0				; hl is now where we need to copy the word byte data to save this 
23e0			 
23e0 23				inc hl 
23e1 22 08 ee			ld (os_new_exec), hl 
23e4				 
23e4				; copy definition 
23e4			 
23e4 eb				ex de, hl 
23e5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23e5			;	inc de    ; skip the PC for this parse 
23e5 3a 10 ee			ld a, (os_new_parse_len) 
23e8 4f				ld c, a 
23e9 06 00			ld b, 0 
23eb ed b0			ldir		 ; copy defintion 
23ed			 
23ed			 
23ed				; poke the address of where the new word bytes live for forthexec 
23ed			 
23ed 2a 06 ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23f0			 
23f0 ed 5b 08 ee		ld de, (os_new_exec)      
23f4				 
23f4 73				ld (hl), e 
23f5 23				inc hl 
23f6 72				ld (hl), d 
23f7			 
23f7					; TODO copy last user dict word next link to this word 
23f7					; TODO update last user dict word to point to this word 
23f7			; 
23f7			; hl f923 de 812a ; bc 811a 
23f7			 
23f7			if DEBUG_FORTH_UWORD 
23f7 c5				push bc 
23f8 ed 4b 12 ee		ld bc, (os_new_malloc) 
23fc						DMARK ":0A" 
23fc f5				push af  
23fd 3a 11 24			ld a, (.dmark)  
2400 32 6e fb			ld (debug_mark),a  
2403 3a 12 24			ld a, (.dmark+1)  
2406 32 6f fb			ld (debug_mark+1),a  
2409 3a 13 24			ld a, (.dmark+2)  
240c 32 70 fb			ld (debug_mark+2),a  
240f 18 03			jr .pastdmark  
2411 ..			.dmark: db ":0A"  
2414 f1			.pastdmark: pop af  
2415			endm  
# End of macro DMARK
2415				CALLMONITOR 
2415 cd 6a 17			call break_point_state  
2418				endm  
# End of macro CALLMONITOR
2418 c1				pop bc 
2419			endif 
2419			if DEBUG_FORTH_UWORD 
2419 c5				push bc 
241a ed 4b 12 ee		ld bc, (os_new_malloc) 
241e 03				inc bc 
241f 03				inc bc 
2420 03				inc bc 
2421 03				inc bc 
2422 03				inc bc 
2423 03				inc bc 
2424 03				inc bc 
2425 03				inc bc 
2426			 
2426						DMARK ":0B" 
2426 f5				push af  
2427 3a 3b 24			ld a, (.dmark)  
242a 32 6e fb			ld (debug_mark),a  
242d 3a 3c 24			ld a, (.dmark+1)  
2430 32 6f fb			ld (debug_mark+1),a  
2433 3a 3d 24			ld a, (.dmark+2)  
2436 32 70 fb			ld (debug_mark+2),a  
2439 18 03			jr .pastdmark  
243b ..			.dmark: db ":0B"  
243e f1			.pastdmark: pop af  
243f			endm  
# End of macro DMARK
243f				CALLMONITOR 
243f cd 6a 17			call break_point_state  
2442				endm  
# End of macro CALLMONITOR
2442 c1				pop bc 
2443			endif 
2443			 
2443			; update word dict linked list for new word 
2443			 
2443			 
2443 2a 11 f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2446 23			inc hl     ; move to next work linked list ptr 
2447			 
2447 ed 5b 12 ee	ld de, (os_new_malloc)		 ; new next word 
244b 73			ld (hl), e 
244c 23			inc hl 
244d 72			ld (hl), d 
244e			 
244e			if DEBUG_FORTH_UWORD 
244e ed 4b 11 f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2452			endif 
2452			 
2452 ed 53 11 f1	ld (os_last_new_uword), de      ; update last new uword ptr 
2456			 
2456			 
2456			if DEBUG_FORTH_UWORD 
2456						DMARK ":0+" 
2456 f5				push af  
2457 3a 6b 24			ld a, (.dmark)  
245a 32 6e fb			ld (debug_mark),a  
245d 3a 6c 24			ld a, (.dmark+1)  
2460 32 6f fb			ld (debug_mark+1),a  
2463 3a 6d 24			ld a, (.dmark+2)  
2466 32 70 fb			ld (debug_mark+2),a  
2469 18 03			jr .pastdmark  
246b ..			.dmark: db ":0+"  
246e f1			.pastdmark: pop af  
246f			endm  
# End of macro DMARK
246f				CALLMONITOR 
246f cd 6a 17			call break_point_state  
2472				endm  
# End of macro CALLMONITOR
2472			endif 
2472			 
2472				STACKFRAMECHK OFF $8efe $989f 
2472				if DEBUG_STACK_IMB 
2472					if OFF 
2472						exx 
2472						ld hl, $989f 
2472						pop de   ; $989f 
2472						call cmp16 
2472						jr nz, .spnosame 
2472						ld hl, $8efe 
2472						pop de   ; $8efe 
2472						call cmp16 
2472						jr z, .spfrsame 
2472						.spnosame: call showsperror 
2472						.spfrsame: nop 
2472						exx 
2472					endif 
2472				endif 
2472			endm 
# End of macro STACKFRAMECHK
2472			 
2472 c9			ret    ; dont process any remaining parser tokens as they form new word 
2473			 
2473			 
2473			 
2473			 
2473			;		NEXT 
2473			.SCOLN: 
2473			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2473 06				db OPCODE_SCOLN 
2474 bf 24			dw .DROP 
2476 02				db 2 
2477 .. 00			db ";",0           
2479			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2479					if DEBUG_FORTH_WORDS_KEY 
2479						DMARK "SCN" 
2479 f5				push af  
247a 3a 8e 24			ld a, (.dmark)  
247d 32 6e fb			ld (debug_mark),a  
2480 3a 8f 24			ld a, (.dmark+1)  
2483 32 6f fb			ld (debug_mark+1),a  
2486 3a 90 24			ld a, (.dmark+2)  
2489 32 70 fb			ld (debug_mark+2),a  
248c 18 03			jr .pastdmark  
248e ..			.dmark: db "SCN"  
2491 f1			.pastdmark: pop af  
2492			endm  
# End of macro DMARK
2492						CALLMONITOR 
2492 cd 6a 17			call break_point_state  
2495				endm  
# End of macro CALLMONITOR
2495					endif 
2495					FORTH_RSP_TOS 
2495 cd b8 1c			call macro_forth_rsp_tos 
2498				endm 
# End of macro FORTH_RSP_TOS
2498 e5					push hl 
2499					FORTH_RSP_POP 
2499 cd c2 1c			call macro_forth_rsp_pop 
249c				endm 
# End of macro FORTH_RSP_POP
249c e1					pop hl 
249d			;		ex de,hl 
249d 22 15 f1				ld (os_tok_ptr),hl 
24a0			 
24a0			if DEBUG_FORTH_UWORD 
24a0						DMARK "SCL" 
24a0 f5				push af  
24a1 3a b5 24			ld a, (.dmark)  
24a4 32 6e fb			ld (debug_mark),a  
24a7 3a b6 24			ld a, (.dmark+1)  
24aa 32 6f fb			ld (debug_mark+1),a  
24ad 3a b7 24			ld a, (.dmark+2)  
24b0 32 70 fb			ld (debug_mark+2),a  
24b3 18 03			jr .pastdmark  
24b5 ..			.dmark: db "SCL"  
24b8 f1			.pastdmark: pop af  
24b9			endm  
# End of macro DMARK
24b9				CALLMONITOR 
24b9 cd 6a 17			call break_point_state  
24bc				endm  
# End of macro CALLMONITOR
24bc			endif 
24bc					NEXTW 
24bc c3 63 20			jp macro_next 
24bf				endm 
# End of macro NEXTW
24bf			 
24bf			.DROP: 
24bf				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24bf 1b				db WORD_SYS_CORE+OPCODE_DROP             
24c0 ea 24			dw .DUP2            
24c2 05				db 4 + 1 
24c3 .. 00			db "DROP",0              
24c8				endm 
# End of macro CWHEAD
24c8			; | DROP ( w -- )   drop the TOS item   | DONE 
24c8					if DEBUG_FORTH_WORDS_KEY 
24c8						DMARK "DRP" 
24c8 f5				push af  
24c9 3a dd 24			ld a, (.dmark)  
24cc 32 6e fb			ld (debug_mark),a  
24cf 3a de 24			ld a, (.dmark+1)  
24d2 32 6f fb			ld (debug_mark+1),a  
24d5 3a df 24			ld a, (.dmark+2)  
24d8 32 70 fb			ld (debug_mark+2),a  
24db 18 03			jr .pastdmark  
24dd ..			.dmark: db "DRP"  
24e0 f1			.pastdmark: pop af  
24e1			endm  
# End of macro DMARK
24e1						CALLMONITOR 
24e1 cd 6a 17			call break_point_state  
24e4				endm  
# End of macro CALLMONITOR
24e4					endif 
24e4					FORTH_DSP_POP 
24e4 cd a9 1f			call macro_forth_dsp_pop 
24e7				endm 
# End of macro FORTH_DSP_POP
24e7					NEXTW 
24e7 c3 63 20			jp macro_next 
24ea				endm 
# End of macro NEXTW
24ea			.DUP2: 
24ea				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24ea 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24eb 2f 25			dw .DROP2            
24ed 05				db 4 + 1 
24ee .. 00			db "2DUP",0              
24f3				endm 
# End of macro CWHEAD
24f3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24f3					if DEBUG_FORTH_WORDS_KEY 
24f3						DMARK "2DU" 
24f3 f5				push af  
24f4 3a 08 25			ld a, (.dmark)  
24f7 32 6e fb			ld (debug_mark),a  
24fa 3a 09 25			ld a, (.dmark+1)  
24fd 32 6f fb			ld (debug_mark+1),a  
2500 3a 0a 25			ld a, (.dmark+2)  
2503 32 70 fb			ld (debug_mark+2),a  
2506 18 03			jr .pastdmark  
2508 ..			.dmark: db "2DU"  
250b f1			.pastdmark: pop af  
250c			endm  
# End of macro DMARK
250c						CALLMONITOR 
250c cd 6a 17			call break_point_state  
250f				endm  
# End of macro CALLMONITOR
250f					endif 
250f					FORTH_DSP_VALUEHL 
250f cd f1 1e			call macro_dsp_valuehl 
2512				endm 
# End of macro FORTH_DSP_VALUEHL
2512 e5					push hl      ; 2 
2513			 
2513					FORTH_DSP_POP 
2513 cd a9 1f			call macro_forth_dsp_pop 
2516				endm 
# End of macro FORTH_DSP_POP
2516					 
2516					FORTH_DSP_VALUEHL 
2516 cd f1 1e			call macro_dsp_valuehl 
2519				endm 
# End of macro FORTH_DSP_VALUEHL
2519			;		push hl      ; 1 
2519			 
2519					FORTH_DSP_POP 
2519 cd a9 1f			call macro_forth_dsp_pop 
251c				endm 
# End of macro FORTH_DSP_POP
251c			 
251c			;		pop hl       ; 1 
251c d1					pop de       ; 2 
251d			 
251d cd fa 1c				call forth_push_numhl 
2520 eb					ex de, hl 
2521 cd fa 1c				call forth_push_numhl 
2524			 
2524					 
2524 eb					ex de, hl 
2525			 
2525 cd fa 1c				call forth_push_numhl 
2528 eb					ex de, hl 
2529 cd fa 1c				call forth_push_numhl 
252c			 
252c			 
252c					NEXTW 
252c c3 63 20			jp macro_next 
252f				endm 
# End of macro NEXTW
252f			.DROP2: 
252f				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
252f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2530 5e 25			dw .SWAP2            
2532 06				db 5 + 1 
2533 .. 00			db "2DROP",0              
2539				endm 
# End of macro CWHEAD
2539			; | 2DROP ( w w -- )    Double drop | DONE 
2539					if DEBUG_FORTH_WORDS_KEY 
2539						DMARK "2DR" 
2539 f5				push af  
253a 3a 4e 25			ld a, (.dmark)  
253d 32 6e fb			ld (debug_mark),a  
2540 3a 4f 25			ld a, (.dmark+1)  
2543 32 6f fb			ld (debug_mark+1),a  
2546 3a 50 25			ld a, (.dmark+2)  
2549 32 70 fb			ld (debug_mark+2),a  
254c 18 03			jr .pastdmark  
254e ..			.dmark: db "2DR"  
2551 f1			.pastdmark: pop af  
2552			endm  
# End of macro DMARK
2552						CALLMONITOR 
2552 cd 6a 17			call break_point_state  
2555				endm  
# End of macro CALLMONITOR
2555					endif 
2555					FORTH_DSP_POP 
2555 cd a9 1f			call macro_forth_dsp_pop 
2558				endm 
# End of macro FORTH_DSP_POP
2558					FORTH_DSP_POP 
2558 cd a9 1f			call macro_forth_dsp_pop 
255b				endm 
# End of macro FORTH_DSP_POP
255b					NEXTW 
255b c3 63 20			jp macro_next 
255e				endm 
# End of macro NEXTW
255e			.SWAP2: 
255e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
255e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
255f 87 25			dw .AT            
2561 06				db 5 + 1 
2562 .. 00			db "2SWAP",0              
2568				endm 
# End of macro CWHEAD
2568			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2568					if DEBUG_FORTH_WORDS_KEY 
2568						DMARK "2SW" 
2568 f5				push af  
2569 3a 7d 25			ld a, (.dmark)  
256c 32 6e fb			ld (debug_mark),a  
256f 3a 7e 25			ld a, (.dmark+1)  
2572 32 6f fb			ld (debug_mark+1),a  
2575 3a 7f 25			ld a, (.dmark+2)  
2578 32 70 fb			ld (debug_mark+2),a  
257b 18 03			jr .pastdmark  
257d ..			.dmark: db "2SW"  
2580 f1			.pastdmark: pop af  
2581			endm  
# End of macro DMARK
2581						CALLMONITOR 
2581 cd 6a 17			call break_point_state  
2584				endm  
# End of macro CALLMONITOR
2584					endif 
2584					NEXTW 
2584 c3 63 20			jp macro_next 
2587				endm 
# End of macro NEXTW
2587			.AT: 
2587				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2587 1f				db WORD_SYS_CORE+OPCODE_AT             
2588 b9 25			dw .CAT            
258a 02				db 1 + 1 
258b .. 00			db "@",0              
258d				endm 
# End of macro CWHEAD
258d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
258d			 
258d					if DEBUG_FORTH_WORDS_KEY 
258d						DMARK "AT." 
258d f5				push af  
258e 3a a2 25			ld a, (.dmark)  
2591 32 6e fb			ld (debug_mark),a  
2594 3a a3 25			ld a, (.dmark+1)  
2597 32 6f fb			ld (debug_mark+1),a  
259a 3a a4 25			ld a, (.dmark+2)  
259d 32 70 fb			ld (debug_mark+2),a  
25a0 18 03			jr .pastdmark  
25a2 ..			.dmark: db "AT."  
25a5 f1			.pastdmark: pop af  
25a6			endm  
# End of macro DMARK
25a6						CALLMONITOR 
25a6 cd 6a 17			call break_point_state  
25a9				endm  
# End of macro CALLMONITOR
25a9					endif 
25a9			.getbyteat:	 
25a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a9 cd f1 1e			call macro_dsp_valuehl 
25ac				endm 
# End of macro FORTH_DSP_VALUEHL
25ac					 
25ac			;		push hl 
25ac				 
25ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ac cd a9 1f			call macro_forth_dsp_pop 
25af				endm 
# End of macro FORTH_DSP_POP
25af			 
25af			;		pop hl 
25af			 
25af 7e					ld a, (hl) 
25b0			 
25b0 6f					ld l, a 
25b1 26 00				ld h, 0 
25b3 cd fa 1c				call forth_push_numhl 
25b6			 
25b6					NEXTW 
25b6 c3 63 20			jp macro_next 
25b9				endm 
# End of macro NEXTW
25b9			.CAT: 
25b9				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25b9 20				db WORD_SYS_CORE+OPCODE_CAT             
25ba e2 25			dw .BANG            
25bc 03				db 2 + 1 
25bd .. 00			db "C@",0              
25c0				endm 
# End of macro CWHEAD
25c0			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25c0					if DEBUG_FORTH_WORDS_KEY 
25c0						DMARK "CAA" 
25c0 f5				push af  
25c1 3a d5 25			ld a, (.dmark)  
25c4 32 6e fb			ld (debug_mark),a  
25c7 3a d6 25			ld a, (.dmark+1)  
25ca 32 6f fb			ld (debug_mark+1),a  
25cd 3a d7 25			ld a, (.dmark+2)  
25d0 32 70 fb			ld (debug_mark+2),a  
25d3 18 03			jr .pastdmark  
25d5 ..			.dmark: db "CAA"  
25d8 f1			.pastdmark: pop af  
25d9			endm  
# End of macro DMARK
25d9						CALLMONITOR 
25d9 cd 6a 17			call break_point_state  
25dc				endm  
# End of macro CALLMONITOR
25dc					endif 
25dc c3 a9 25				jp .getbyteat 
25df					NEXTW 
25df c3 63 20			jp macro_next 
25e2				endm 
# End of macro NEXTW
25e2			.BANG: 
25e2				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25e2 21				db WORD_SYS_CORE+OPCODE_BANG             
25e3 18 26			dw .CBANG            
25e5 02				db 1 + 1 
25e6 .. 00			db "!",0              
25e8				endm 
# End of macro CWHEAD
25e8			; | ! ( x w -- ) Store x at address w      | DONE 
25e8					if DEBUG_FORTH_WORDS_KEY 
25e8						DMARK "BNG" 
25e8 f5				push af  
25e9 3a fd 25			ld a, (.dmark)  
25ec 32 6e fb			ld (debug_mark),a  
25ef 3a fe 25			ld a, (.dmark+1)  
25f2 32 6f fb			ld (debug_mark+1),a  
25f5 3a ff 25			ld a, (.dmark+2)  
25f8 32 70 fb			ld (debug_mark+2),a  
25fb 18 03			jr .pastdmark  
25fd ..			.dmark: db "BNG"  
2600 f1			.pastdmark: pop af  
2601			endm  
# End of macro DMARK
2601						CALLMONITOR 
2601 cd 6a 17			call break_point_state  
2604				endm  
# End of macro CALLMONITOR
2604					endif 
2604			 
2604			.storebyteat:		 
2604					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2604 cd f1 1e			call macro_dsp_valuehl 
2607				endm 
# End of macro FORTH_DSP_VALUEHL
2607					 
2607 e5					push hl 
2608				 
2608					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2608 cd a9 1f			call macro_forth_dsp_pop 
260b				endm 
# End of macro FORTH_DSP_POP
260b			 
260b					; get byte to poke 
260b			 
260b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260b cd f1 1e			call macro_dsp_valuehl 
260e				endm 
# End of macro FORTH_DSP_VALUEHL
260e e5					push hl 
260f			 
260f			 
260f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
260f cd a9 1f			call macro_forth_dsp_pop 
2612				endm 
# End of macro FORTH_DSP_POP
2612			 
2612			 
2612 d1					pop de 
2613 e1					pop hl 
2614			 
2614 73					ld (hl),e 
2615			 
2615			 
2615					NEXTW 
2615 c3 63 20			jp macro_next 
2618				endm 
# End of macro NEXTW
2618			.CBANG: 
2618				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2618 22				db WORD_SYS_CORE+OPCODE_CBANG             
2619 41 26			dw .SCALL            
261b 03				db 2 + 1 
261c .. 00			db "C!",0              
261f				endm 
# End of macro CWHEAD
261f			; | C!  ( x w -- ) Store x at address w  | DONE 
261f					if DEBUG_FORTH_WORDS_KEY 
261f						DMARK "CBA" 
261f f5				push af  
2620 3a 34 26			ld a, (.dmark)  
2623 32 6e fb			ld (debug_mark),a  
2626 3a 35 26			ld a, (.dmark+1)  
2629 32 6f fb			ld (debug_mark+1),a  
262c 3a 36 26			ld a, (.dmark+2)  
262f 32 70 fb			ld (debug_mark+2),a  
2632 18 03			jr .pastdmark  
2634 ..			.dmark: db "CBA"  
2637 f1			.pastdmark: pop af  
2638			endm  
# End of macro DMARK
2638						CALLMONITOR 
2638 cd 6a 17			call break_point_state  
263b				endm  
# End of macro CALLMONITOR
263b					endif 
263b c3 04 26				jp .storebyteat 
263e					NEXTW 
263e c3 63 20			jp macro_next 
2641				endm 
# End of macro NEXTW
2641			.SCALL: 
2641				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2641 23				db WORD_SYS_CORE+OPCODE_SCALL             
2642 75 26			dw .DEPTH            
2644 05				db 4 + 1 
2645 .. 00			db "CALL",0              
264a				endm 
# End of macro CWHEAD
264a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
264a					if DEBUG_FORTH_WORDS_KEY 
264a						DMARK "CLL" 
264a f5				push af  
264b 3a 5f 26			ld a, (.dmark)  
264e 32 6e fb			ld (debug_mark),a  
2651 3a 60 26			ld a, (.dmark+1)  
2654 32 6f fb			ld (debug_mark+1),a  
2657 3a 61 26			ld a, (.dmark+2)  
265a 32 70 fb			ld (debug_mark+2),a  
265d 18 03			jr .pastdmark  
265f ..			.dmark: db "CLL"  
2662 f1			.pastdmark: pop af  
2663			endm  
# End of macro DMARK
2663						CALLMONITOR 
2663 cd 6a 17			call break_point_state  
2666				endm  
# End of macro CALLMONITOR
2666					endif 
2666			 
2666					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2666 cd f1 1e			call macro_dsp_valuehl 
2669				endm 
# End of macro FORTH_DSP_VALUEHL
2669			 
2669			;		push hl 
2669			 
2669					; destroy value TOS 
2669			 
2669					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2669 cd a9 1f			call macro_forth_dsp_pop 
266c				endm 
# End of macro FORTH_DSP_POP
266c			 
266c						 
266c			;		pop hl 
266c			 
266c					; how to do a call with hl???? save SP? 
266c cd 0c 20				call forth_call_hl 
266f			 
266f			 
266f					; TODO push value back onto stack for another op etc 
266f			 
266f cd fa 1c				call forth_push_numhl 
2672					NEXTW 
2672 c3 63 20			jp macro_next 
2675				endm 
# End of macro NEXTW
2675			.DEPTH: 
2675				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2675 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2676 b2 26			dw .OVER            
2678 06				db 5 + 1 
2679 .. 00			db "DEPTH",0              
267f				endm 
# End of macro CWHEAD
267f			; | DEPTH ( -- u ) Push count of stack | DONE 
267f					; take current TOS and remove from base value div by two to get count 
267f					if DEBUG_FORTH_WORDS_KEY 
267f						DMARK "DEP" 
267f f5				push af  
2680 3a 94 26			ld a, (.dmark)  
2683 32 6e fb			ld (debug_mark),a  
2686 3a 95 26			ld a, (.dmark+1)  
2689 32 6f fb			ld (debug_mark+1),a  
268c 3a 96 26			ld a, (.dmark+2)  
268f 32 70 fb			ld (debug_mark+2),a  
2692 18 03			jr .pastdmark  
2694 ..			.dmark: db "DEP"  
2697 f1			.pastdmark: pop af  
2698			endm  
# End of macro DMARK
2698						CALLMONITOR 
2698 cd 6a 17			call break_point_state  
269b				endm  
# End of macro CALLMONITOR
269b					endif 
269b			 
269b			 
269b 2a 01 f8			ld hl, (cli_data_sp) 
269e 11 7b f3			ld de, cli_data_stack 
26a1 ed 52			sbc hl,de 
26a3				 
26a3				; div by size of stack item 
26a3			 
26a3 5d				ld e,l 
26a4 0e 03			ld c, 3 
26a6 cd ab 0c			call Div8 
26a9			 
26a9 6f				ld l,a 
26aa 26 00			ld h,0 
26ac			 
26ac				;srl h 
26ac				;rr l 
26ac			 
26ac cd fa 1c				call forth_push_numhl 
26af					NEXTW 
26af c3 63 20			jp macro_next 
26b2				endm 
# End of macro NEXTW
26b2			.OVER: 
26b2				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26b2 42				db WORD_SYS_CORE+46             
26b3 f9 26			dw .PAUSE            
26b5 05				db 4 + 1 
26b6 .. 00			db "OVER",0              
26bb				endm 
# End of macro CWHEAD
26bb			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26bb					if DEBUG_FORTH_WORDS_KEY 
26bb						DMARK "OVR" 
26bb f5				push af  
26bc 3a d0 26			ld a, (.dmark)  
26bf 32 6e fb			ld (debug_mark),a  
26c2 3a d1 26			ld a, (.dmark+1)  
26c5 32 6f fb			ld (debug_mark+1),a  
26c8 3a d2 26			ld a, (.dmark+2)  
26cb 32 70 fb			ld (debug_mark+2),a  
26ce 18 03			jr .pastdmark  
26d0 ..			.dmark: db "OVR"  
26d3 f1			.pastdmark: pop af  
26d4			endm  
# End of macro DMARK
26d4						CALLMONITOR 
26d4 cd 6a 17			call break_point_state  
26d7				endm  
# End of macro CALLMONITOR
26d7					endif 
26d7			 
26d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d7 cd f1 1e			call macro_dsp_valuehl 
26da				endm 
# End of macro FORTH_DSP_VALUEHL
26da e5					push hl    ; n2 
26db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26db cd a9 1f			call macro_forth_dsp_pop 
26de				endm 
# End of macro FORTH_DSP_POP
26de			 
26de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26de cd f1 1e			call macro_dsp_valuehl 
26e1				endm 
# End of macro FORTH_DSP_VALUEHL
26e1 e5					push hl    ; n1 
26e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e2 cd a9 1f			call macro_forth_dsp_pop 
26e5				endm 
# End of macro FORTH_DSP_POP
26e5			 
26e5 d1					pop de     ; n1 
26e6 e1					pop hl     ; n2 
26e7			 
26e7 d5					push de 
26e8 e5					push hl 
26e9 d5					push de 
26ea			 
26ea					; push back  
26ea			 
26ea e1					pop hl 
26eb cd fa 1c				call forth_push_numhl 
26ee e1					pop hl 
26ef cd fa 1c				call forth_push_numhl 
26f2 e1					pop hl 
26f3 cd fa 1c				call forth_push_numhl 
26f6					NEXTW 
26f6 c3 63 20			jp macro_next 
26f9				endm 
# End of macro NEXTW
26f9			 
26f9			.PAUSE: 
26f9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26f9 43				db WORD_SYS_CORE+47             
26fa 2e 27			dw .PAUSES            
26fc 08				db 7 + 1 
26fd .. 00			db "PAUSEMS",0              
2705				endm 
# End of macro CWHEAD
2705			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2705					if DEBUG_FORTH_WORDS_KEY 
2705						DMARK "PMS" 
2705 f5				push af  
2706 3a 1a 27			ld a, (.dmark)  
2709 32 6e fb			ld (debug_mark),a  
270c 3a 1b 27			ld a, (.dmark+1)  
270f 32 6f fb			ld (debug_mark+1),a  
2712 3a 1c 27			ld a, (.dmark+2)  
2715 32 70 fb			ld (debug_mark+2),a  
2718 18 03			jr .pastdmark  
271a ..			.dmark: db "PMS"  
271d f1			.pastdmark: pop af  
271e			endm  
# End of macro DMARK
271e						CALLMONITOR 
271e cd 6a 17			call break_point_state  
2721				endm  
# End of macro CALLMONITOR
2721					endif 
2721					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2721 cd f1 1e			call macro_dsp_valuehl 
2724				endm 
# End of macro FORTH_DSP_VALUEHL
2724			;		push hl    ; n2 
2724					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2724 cd a9 1f			call macro_forth_dsp_pop 
2727				endm 
# End of macro FORTH_DSP_POP
2727			;		pop hl 
2727			 
2727 7d					ld a, l 
2728 cd 49 0a				call aDelayInMS 
272b				       NEXTW 
272b c3 63 20			jp macro_next 
272e				endm 
# End of macro NEXTW
272e			.PAUSES:  
272e				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
272e 44				db WORD_SYS_CORE+48             
272f 9d 27			dw .ROT            
2731 06				db 5 + 1 
2732 .. 00			db "PAUSE",0              
2738				endm 
# End of macro CWHEAD
2738			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2738					if DEBUG_FORTH_WORDS_KEY 
2738						DMARK "PAU" 
2738 f5				push af  
2739 3a 4d 27			ld a, (.dmark)  
273c 32 6e fb			ld (debug_mark),a  
273f 3a 4e 27			ld a, (.dmark+1)  
2742 32 6f fb			ld (debug_mark+1),a  
2745 3a 4f 27			ld a, (.dmark+2)  
2748 32 70 fb			ld (debug_mark+2),a  
274b 18 03			jr .pastdmark  
274d ..			.dmark: db "PAU"  
2750 f1			.pastdmark: pop af  
2751			endm  
# End of macro DMARK
2751						CALLMONITOR 
2751 cd 6a 17			call break_point_state  
2754				endm  
# End of macro CALLMONITOR
2754					endif 
2754					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2754 cd f1 1e			call macro_dsp_valuehl 
2757				endm 
# End of macro FORTH_DSP_VALUEHL
2757			;		push hl    ; n2 
2757					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2757 cd a9 1f			call macro_forth_dsp_pop 
275a				endm 
# End of macro FORTH_DSP_POP
275a			;		pop hl 
275a 45					ld b, l 
275b					if DEBUG_FORTH_WORDS 
275b						DMARK "PAU" 
275b f5				push af  
275c 3a 70 27			ld a, (.dmark)  
275f 32 6e fb			ld (debug_mark),a  
2762 3a 71 27			ld a, (.dmark+1)  
2765 32 6f fb			ld (debug_mark+1),a  
2768 3a 72 27			ld a, (.dmark+2)  
276b 32 70 fb			ld (debug_mark+2),a  
276e 18 03			jr .pastdmark  
2770 ..			.dmark: db "PAU"  
2773 f1			.pastdmark: pop af  
2774			endm  
# End of macro DMARK
2774						CALLMONITOR 
2774 cd 6a 17			call break_point_state  
2777				endm  
# End of macro CALLMONITOR
2777					endif 
2777 c5			.pauses1:	push bc 
2778 cd 64 0a				call delay1s 
277b c1					pop bc 
277c					if DEBUG_FORTH_WORDS 
277c						DMARK "PA1" 
277c f5				push af  
277d 3a 91 27			ld a, (.dmark)  
2780 32 6e fb			ld (debug_mark),a  
2783 3a 92 27			ld a, (.dmark+1)  
2786 32 6f fb			ld (debug_mark+1),a  
2789 3a 93 27			ld a, (.dmark+2)  
278c 32 70 fb			ld (debug_mark+2),a  
278f 18 03			jr .pastdmark  
2791 ..			.dmark: db "PA1"  
2794 f1			.pastdmark: pop af  
2795			endm  
# End of macro DMARK
2795						CALLMONITOR 
2795 cd 6a 17			call break_point_state  
2798				endm  
# End of macro CALLMONITOR
2798					endif 
2798 10 dd				djnz .pauses1 
279a			 
279a				       NEXTW 
279a c3 63 20			jp macro_next 
279d				endm 
# End of macro NEXTW
279d			.ROT: 
279d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
279d 45				db WORD_SYS_CORE+49             
279e eb 27			dw .UWORDS            
27a0 04				db 3 + 1 
27a1 .. 00			db "ROT",0              
27a5				endm 
# End of macro CWHEAD
27a5			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
27a5					if DEBUG_FORTH_WORDS_KEY 
27a5						DMARK "ROT" 
27a5 f5				push af  
27a6 3a ba 27			ld a, (.dmark)  
27a9 32 6e fb			ld (debug_mark),a  
27ac 3a bb 27			ld a, (.dmark+1)  
27af 32 6f fb			ld (debug_mark+1),a  
27b2 3a bc 27			ld a, (.dmark+2)  
27b5 32 70 fb			ld (debug_mark+2),a  
27b8 18 03			jr .pastdmark  
27ba ..			.dmark: db "ROT"  
27bd f1			.pastdmark: pop af  
27be			endm  
# End of macro DMARK
27be						CALLMONITOR 
27be cd 6a 17			call break_point_state  
27c1				endm  
# End of macro CALLMONITOR
27c1					endif 
27c1			 
27c1					FORTH_DSP_VALUEHL 
27c1 cd f1 1e			call macro_dsp_valuehl 
27c4				endm 
# End of macro FORTH_DSP_VALUEHL
27c4 e5					push hl    ; u3  
27c5			 
27c5					FORTH_DSP_POP 
27c5 cd a9 1f			call macro_forth_dsp_pop 
27c8				endm 
# End of macro FORTH_DSP_POP
27c8			   
27c8					FORTH_DSP_VALUEHL 
27c8 cd f1 1e			call macro_dsp_valuehl 
27cb				endm 
# End of macro FORTH_DSP_VALUEHL
27cb e5					push hl     ; u2 
27cc			 
27cc					FORTH_DSP_POP 
27cc cd a9 1f			call macro_forth_dsp_pop 
27cf				endm 
# End of macro FORTH_DSP_POP
27cf			 
27cf					FORTH_DSP_VALUEHL 
27cf cd f1 1e			call macro_dsp_valuehl 
27d2				endm 
# End of macro FORTH_DSP_VALUEHL
27d2 e5					push hl     ; u1 
27d3			 
27d3					FORTH_DSP_POP 
27d3 cd a9 1f			call macro_forth_dsp_pop 
27d6				endm 
# End of macro FORTH_DSP_POP
27d6			 
27d6 c1					pop bc      ; u1 
27d7 e1					pop hl      ; u2 
27d8 d1					pop de      ; u3 
27d9			 
27d9			 
27d9 c5					push bc 
27da d5					push de 
27db e5					push hl 
27dc			 
27dc			 
27dc e1					pop hl 
27dd cd fa 1c				call forth_push_numhl 
27e0			 
27e0 e1					pop hl 
27e1 cd fa 1c				call forth_push_numhl 
27e4			 
27e4 e1					pop hl 
27e5 cd fa 1c				call forth_push_numhl 
27e8					 
27e8			 
27e8			 
27e8			 
27e8			 
27e8			 
27e8				       NEXTW 
27e8 c3 63 20			jp macro_next 
27eb				endm 
# End of macro NEXTW
27eb			 
27eb			.UWORDS: 
27eb				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27eb 50				db WORD_SYS_CORE+60             
27ec ad 28			dw .BP            
27ee 07				db 6 + 1 
27ef .. 00			db "UWORDS",0              
27f6				endm 
# End of macro CWHEAD
27f6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27f6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27f6			; | | Following the count are the individual words. 
27f6			; | | 
27f6			; | | e.g. UWORDS 
27f6			; | | BOX DIRLIST 2 
27f6			; | |  
27f6			; | | Can be used to save the words to storage via: 
27f6			; | | UWORDS $01 DO $01 APPEND LOOP 
27f6				if DEBUG_FORTH_WORDS_KEY 
27f6					DMARK "UWR" 
27f6 f5				push af  
27f7 3a 0b 28			ld a, (.dmark)  
27fa 32 6e fb			ld (debug_mark),a  
27fd 3a 0c 28			ld a, (.dmark+1)  
2800 32 6f fb			ld (debug_mark+1),a  
2803 3a 0d 28			ld a, (.dmark+2)  
2806 32 70 fb			ld (debug_mark+2),a  
2809 18 03			jr .pastdmark  
280b ..			.dmark: db "UWR"  
280e f1			.pastdmark: pop af  
280f			endm  
# End of macro DMARK
280f					CALLMONITOR 
280f cd 6a 17			call break_point_state  
2812				endm  
# End of macro CALLMONITOR
2812				endif 
2812 21 00 80				ld hl, baseram 
2815					;ld hl, baseusermem 
2815 01 00 00				ld bc, 0    ; start a counter 
2818			 
2818				; skip dict stub 
2818			 
2818 cd b4 21				call forth_tok_next 
281b			 
281b			 
281b			; while we have words to look for 
281b			 
281b 7e			.douscan:	ld a, (hl)      
281c				if DEBUG_FORTH_WORDS 
281c					DMARK "UWs" 
281c f5				push af  
281d 3a 31 28			ld a, (.dmark)  
2820 32 6e fb			ld (debug_mark),a  
2823 3a 32 28			ld a, (.dmark+1)  
2826 32 6f fb			ld (debug_mark+1),a  
2829 3a 33 28			ld a, (.dmark+2)  
282c 32 70 fb			ld (debug_mark+2),a  
282f 18 03			jr .pastdmark  
2831 ..			.dmark: db "UWs"  
2834 f1			.pastdmark: pop af  
2835			endm  
# End of macro DMARK
2835					CALLMONITOR 
2835 cd 6a 17			call break_point_state  
2838				endm  
# End of macro CALLMONITOR
2838				endif 
2838 fe 00				cp WORD_SYS_END 
283a 28 4d				jr z, .udone 
283c fe 01				cp WORD_SYS_UWORD 
283e 20 44				jr nz, .nuword 
2840			 
2840				if DEBUG_FORTH_WORDS 
2840					DMARK "UWu" 
2840 f5				push af  
2841 3a 55 28			ld a, (.dmark)  
2844 32 6e fb			ld (debug_mark),a  
2847 3a 56 28			ld a, (.dmark+1)  
284a 32 6f fb			ld (debug_mark+1),a  
284d 3a 57 28			ld a, (.dmark+2)  
2850 32 70 fb			ld (debug_mark+2),a  
2853 18 03			jr .pastdmark  
2855 ..			.dmark: db "UWu"  
2858 f1			.pastdmark: pop af  
2859			endm  
# End of macro DMARK
2859					CALLMONITOR 
2859 cd 6a 17			call break_point_state  
285c				endm  
# End of macro CALLMONITOR
285c				endif 
285c					; we have a uword so push its name to the stack 
285c			 
285c e5				   	push hl  ; save so we can move to next dict block 
285d			 
285d					; skip opcode 
285d 23					inc hl  
285e					; skip next ptr 
285e 23					inc hl  
285f 23					inc hl 
2860					; skip len 
2860 23					inc hl 
2861				if DEBUG_FORTH_WORDS 
2861					DMARK "UWt" 
2861 f5				push af  
2862 3a 76 28			ld a, (.dmark)  
2865 32 6e fb			ld (debug_mark),a  
2868 3a 77 28			ld a, (.dmark+1)  
286b 32 6f fb			ld (debug_mark+1),a  
286e 3a 78 28			ld a, (.dmark+2)  
2871 32 70 fb			ld (debug_mark+2),a  
2874 18 03			jr .pastdmark  
2876 ..			.dmark: db "UWt"  
2879 f1			.pastdmark: pop af  
287a			endm  
# End of macro DMARK
287a					CALLMONITOR 
287a cd 6a 17			call break_point_state  
287d				endm  
# End of macro CALLMONITOR
287d				endif 
287d 03					inc bc 
287e			 
287e c5					push bc 
287f cd 68 1d				call forth_push_str 
2882 c1					pop bc 
2883			 
2883 e1					pop hl 	 
2884			 
2884 cd b4 21		.nuword:	call forth_tok_next 
2887 18 92				jr .douscan  
2889			 
2889			.udone:		 ; push count of uwords found 
2889 c5					push bc 
288a e1					pop hl 
288b			 
288b				if DEBUG_FORTH_WORDS 
288b					DMARK "UWc" 
288b f5				push af  
288c 3a a0 28			ld a, (.dmark)  
288f 32 6e fb			ld (debug_mark),a  
2892 3a a1 28			ld a, (.dmark+1)  
2895 32 6f fb			ld (debug_mark+1),a  
2898 3a a2 28			ld a, (.dmark+2)  
289b 32 70 fb			ld (debug_mark+2),a  
289e 18 03			jr .pastdmark  
28a0 ..			.dmark: db "UWc"  
28a3 f1			.pastdmark: pop af  
28a4			endm  
# End of macro DMARK
28a4					CALLMONITOR 
28a4 cd 6a 17			call break_point_state  
28a7				endm  
# End of macro CALLMONITOR
28a7				endif 
28a7 cd fa 1c				call forth_push_numhl 
28aa			 
28aa			 
28aa				       NEXTW 
28aa c3 63 20			jp macro_next 
28ad				endm 
# End of macro NEXTW
28ad			 
28ad			.BP: 
28ad				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
28ad 54				db WORD_SYS_CORE+64             
28ae e3 28			dw .MONITOR            
28b0 03				db 2 + 1 
28b1 .. 00			db "BP",0              
28b4				endm 
# End of macro CWHEAD
28b4			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
28b4			; | | $00 Will enable the break points within specific code paths 
28b4			; | | $01 Will disable break points 
28b4			; | |  
28b4			; | | By default break points are off. Either the above can be used to enable them 
28b4			; | | or if a key is held down during start up the spashscreen will appear to freeze 
28b4			; | | and on release of the pressed key a message will be disaplayed to notify 
28b4			; | | that break points are enabled. Pressing any key will then continue boot process. 
28b4					; get byte count 
28b4					if DEBUG_FORTH_WORDS_KEY 
28b4						DMARK "BP." 
28b4 f5				push af  
28b5 3a c9 28			ld a, (.dmark)  
28b8 32 6e fb			ld (debug_mark),a  
28bb 3a ca 28			ld a, (.dmark+1)  
28be 32 6f fb			ld (debug_mark+1),a  
28c1 3a cb 28			ld a, (.dmark+2)  
28c4 32 70 fb			ld (debug_mark+2),a  
28c7 18 03			jr .pastdmark  
28c9 ..			.dmark: db "BP."  
28cc f1			.pastdmark: pop af  
28cd			endm  
# End of macro DMARK
28cd						CALLMONITOR 
28cd cd 6a 17			call break_point_state  
28d0				endm  
# End of macro CALLMONITOR
28d0					endif 
28d0			 
28d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28d0 cd f1 1e			call macro_dsp_valuehl 
28d3				endm 
# End of macro FORTH_DSP_VALUEHL
28d3			 
28d3			;		push hl 
28d3			 
28d3					; destroy value TOS 
28d3			 
28d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d3 cd a9 1f			call macro_forth_dsp_pop 
28d6				endm 
# End of macro FORTH_DSP_POP
28d6			 
28d6			;		pop hl 
28d6			 
28d6 3e 00				ld a,0 
28d8 bd					cp l 
28d9 28 02				jr z, .bpset 
28db 3e 2a				ld a, '*' 
28dd			 
28dd 32 05 ee		.bpset:		ld (os_view_disable), a 
28e0			 
28e0			 
28e0					NEXTW 
28e0 c3 63 20			jp macro_next 
28e3				endm 
# End of macro NEXTW
28e3			 
28e3			 
28e3			.MONITOR: 
28e3				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28e3 55				db WORD_SYS_CORE+65             
28e4 16 29			dw .MALLOC            
28e6 08				db 7 + 1 
28e7 .. 00			db "MONITOR",0              
28ef				endm 
# End of macro CWHEAD
28ef			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28ef			; | | At start the current various registers will be displayed with contents. 
28ef			; | | Top right corner will show the most recent debug marker seen. 
28ef			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28ef			; | | and the return stack pointer (RSP). 
28ef			; | | Pressing: 
28ef			; | |    1 - Initial screen 
28ef			; | |    2 - Display a data dump of HL 
28ef			; | |    3 - Display a data dump of DE 
28ef			; | |    4 - Display a data dump of BC 
28ef			; | |    5 - Display a data dump of HL 
28ef			; | |    6 - Display a data dump of DSP 
28ef			; | |    7 - Display a data dump of RSP 
28ef			; | |    8 - Display a data dump of what is at DSP 
28ef			; | |    9 - Display a data dump of what is at RSP 
28ef			; | |    0 - Exit monitor and continue running. This will also enable break points 
28ef			; | |    * - Disable break points 
28ef			; | |    # - Enter traditional monitor mode 
28ef			; | | 
28ef			; | | Monitor Mode 
28ef			; | | ------------ 
28ef			; | | A prompt of '>' will be shown for various commands: 
28ef			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28ef			; | |    C - Continue display a data dump from the last set address 
28ef			; | |    M xxxx - Set start of memory edit at address xx 
28ef			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28ef			; | |    Q - Return to previous 
28ef					if DEBUG_FORTH_WORDS_KEY 
28ef						DMARK "MON" 
28ef f5				push af  
28f0 3a 04 29			ld a, (.dmark)  
28f3 32 6e fb			ld (debug_mark),a  
28f6 3a 05 29			ld a, (.dmark+1)  
28f9 32 6f fb			ld (debug_mark+1),a  
28fc 3a 06 29			ld a, (.dmark+2)  
28ff 32 70 fb			ld (debug_mark+2),a  
2902 18 03			jr .pastdmark  
2904 ..			.dmark: db "MON"  
2907 f1			.pastdmark: pop af  
2908			endm  
# End of macro DMARK
2908						CALLMONITOR 
2908 cd 6a 17			call break_point_state  
290b				endm  
# End of macro CALLMONITOR
290b					endif 
290b 3e 00				ld a, 0 
290d 32 05 ee				ld (os_view_disable), a 
2910			 
2910					CALLMONITOR 
2910 cd 6a 17			call break_point_state  
2913				endm  
# End of macro CALLMONITOR
2913			 
2913			;	call monitor 
2913			 
2913					NEXTW 
2913 c3 63 20			jp macro_next 
2916				endm 
# End of macro NEXTW
2916			 
2916			 
2916			.MALLOC: 
2916				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2916 56				db WORD_SYS_CORE+66             
2917 3f 29			dw .MALLOC2            
2919 06				db 5 + 1 
291a .. 00			db "ALLOT",0              
2920				endm 
# End of macro CWHEAD
2920			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2920					if DEBUG_FORTH_WORDS_KEY 
2920						DMARK "ALL" 
2920 f5				push af  
2921 3a 35 29			ld a, (.dmark)  
2924 32 6e fb			ld (debug_mark),a  
2927 3a 36 29			ld a, (.dmark+1)  
292a 32 6f fb			ld (debug_mark+1),a  
292d 3a 37 29			ld a, (.dmark+2)  
2930 32 70 fb			ld (debug_mark+2),a  
2933 18 03			jr .pastdmark  
2935 ..			.dmark: db "ALL"  
2938 f1			.pastdmark: pop af  
2939			endm  
# End of macro DMARK
2939						CALLMONITOR 
2939 cd 6a 17			call break_point_state  
293c				endm  
# End of macro CALLMONITOR
293c					endif 
293c c3 66 29				jp .mallocc 
293f			.MALLOC2: 
293f				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
293f 56				db WORD_SYS_CORE+66             
2940 7d 29			dw .FREE            
2942 07				db 6 + 1 
2943 .. 00			db "MALLOC",0              
294a				endm 
# End of macro CWHEAD
294a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
294a					; get byte count 
294a					if DEBUG_FORTH_WORDS_KEY 
294a						DMARK "MAL" 
294a f5				push af  
294b 3a 5f 29			ld a, (.dmark)  
294e 32 6e fb			ld (debug_mark),a  
2951 3a 60 29			ld a, (.dmark+1)  
2954 32 6f fb			ld (debug_mark+1),a  
2957 3a 61 29			ld a, (.dmark+2)  
295a 32 70 fb			ld (debug_mark+2),a  
295d 18 03			jr .pastdmark  
295f ..			.dmark: db "MAL"  
2962 f1			.pastdmark: pop af  
2963			endm  
# End of macro DMARK
2963						CALLMONITOR 
2963 cd 6a 17			call break_point_state  
2966				endm  
# End of macro CALLMONITOR
2966					endif 
2966			.mallocc: 
2966					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2966 cd f1 1e			call macro_dsp_valuehl 
2969				endm 
# End of macro FORTH_DSP_VALUEHL
2969			 
2969			;		push hl 
2969			 
2969					; destroy value TOS 
2969			 
2969					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2969 cd a9 1f			call macro_forth_dsp_pop 
296c				endm 
# End of macro FORTH_DSP_POP
296c			 
296c			;		pop hl 
296c cd e2 11				call malloc 
296f				if DEBUG_FORTH_MALLOC_GUARD 
296f f5					push af 
2970 cd 44 0d				call ishlzero 
2973			;		ld a, l 
2973			;		add h 
2973			;		cp 0 
2973 f1					pop af 
2974					 
2974 cc 24 52				call z,malloc_error 
2977				endif 
2977			 
2977 cd fa 1c				call forth_push_numhl 
297a					NEXTW 
297a c3 63 20			jp macro_next 
297d				endm 
# End of macro NEXTW
297d			 
297d			.FREE: 
297d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
297d 57				db WORD_SYS_CORE+67             
297e ae 29			dw .LIST            
2980 05				db 4 + 1 
2981 .. 00			db "FREE",0              
2986				endm 
# End of macro CWHEAD
2986			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2986					if DEBUG_FORTH_WORDS_KEY 
2986						DMARK "FRE" 
2986 f5				push af  
2987 3a 9b 29			ld a, (.dmark)  
298a 32 6e fb			ld (debug_mark),a  
298d 3a 9c 29			ld a, (.dmark+1)  
2990 32 6f fb			ld (debug_mark+1),a  
2993 3a 9d 29			ld a, (.dmark+2)  
2996 32 70 fb			ld (debug_mark+2),a  
2999 18 03			jr .pastdmark  
299b ..			.dmark: db "FRE"  
299e f1			.pastdmark: pop af  
299f			endm  
# End of macro DMARK
299f						CALLMONITOR 
299f cd 6a 17			call break_point_state  
29a2				endm  
# End of macro CALLMONITOR
29a2					endif 
29a2					; get address 
29a2			 
29a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29a2 cd f1 1e			call macro_dsp_valuehl 
29a5				endm 
# End of macro FORTH_DSP_VALUEHL
29a5			 
29a5			;		push hl 
29a5			 
29a5					; destroy value TOS 
29a5			 
29a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29a5 cd a9 1f			call macro_forth_dsp_pop 
29a8				endm 
# End of macro FORTH_DSP_POP
29a8			 
29a8			;		pop hl 
29a8			if FORTH_ENABLE_MALLOCFREE 
29a8 cd ac 12				call free 
29ab			endif 
29ab					NEXTW 
29ab c3 63 20			jp macro_next 
29ae				endm 
# End of macro NEXTW
29ae			.LIST: 
29ae				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
29ae 5c				db WORD_SYS_CORE+72             
29af 9c 2b			dw .FORGET            
29b1 05				db 4 + 1 
29b2 .. 00			db "LIST",0              
29b7				endm 
# End of macro CWHEAD
29b7			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
29b7			; | | The quoted word must be in upper case. 
29b7				if DEBUG_FORTH_WORDS_KEY 
29b7					DMARK "LST" 
29b7 f5				push af  
29b8 3a cc 29			ld a, (.dmark)  
29bb 32 6e fb			ld (debug_mark),a  
29be 3a cd 29			ld a, (.dmark+1)  
29c1 32 6f fb			ld (debug_mark+1),a  
29c4 3a ce 29			ld a, (.dmark+2)  
29c7 32 70 fb			ld (debug_mark+2),a  
29ca 18 03			jr .pastdmark  
29cc ..			.dmark: db "LST"  
29cf f1			.pastdmark: pop af  
29d0			endm  
# End of macro DMARK
29d0					CALLMONITOR 
29d0 cd 6a 17			call break_point_state  
29d3				endm  
# End of macro CALLMONITOR
29d3				endif 
29d3			 
29d3					FORTH_DSP_VALUEHL 
29d3 cd f1 1e			call macro_dsp_valuehl 
29d6				endm 
# End of macro FORTH_DSP_VALUEHL
29d6			 
29d6 e5					push hl 
29d7					FORTH_DSP_POP 
29d7 cd a9 1f			call macro_forth_dsp_pop 
29da				endm 
# End of macro FORTH_DSP_POP
29da c1					pop bc 
29db			 
29db			; Start format of scratch string 
29db			 
29db 21 14 ee				ld hl, scratch 
29de			 
29de 3e 3a				ld a, ':' 
29e0 77					ld (hl),a 
29e1 23					inc hl 
29e2 3e 20				ld a, ' ' 
29e4 77					ld (hl), a 
29e5			 
29e5					; Get ptr to the word we need to look up 
29e5			 
29e5			;		FORTH_DSP_VALUEHL 
29e5					;v5 FORTH_DSP_VALUE 
29e5				; TODO type check 
29e5			;		inc hl    ; Skip type check  
29e5			;		push hl 
29e5			;		ex de, hl    ; put into DE 
29e5			 
29e5			 
29e5 21 00 80				ld hl, baseram 
29e8					;ld hl, baseusermem 
29e8			 
29e8 e5			push hl   ; sacreifical push 
29e9			 
29e9			.ldouscanm: 
29e9 e1				pop hl 
29ea			.ldouscan: 
29ea				if DEBUG_FORTH_WORDS 
29ea					DMARK "LSs" 
29ea f5				push af  
29eb 3a ff 29			ld a, (.dmark)  
29ee 32 6e fb			ld (debug_mark),a  
29f1 3a 00 2a			ld a, (.dmark+1)  
29f4 32 6f fb			ld (debug_mark+1),a  
29f7 3a 01 2a			ld a, (.dmark+2)  
29fa 32 70 fb			ld (debug_mark+2),a  
29fd 18 03			jr .pastdmark  
29ff ..			.dmark: db "LSs"  
2a02 f1			.pastdmark: pop af  
2a03			endm  
# End of macro DMARK
2a03					CALLMONITOR 
2a03 cd 6a 17			call break_point_state  
2a06				endm  
# End of macro CALLMONITOR
2a06				endif 
2a06				; skip dict stub 
2a06 cd b4 21				call forth_tok_next 
2a09			 
2a09			 
2a09			; while we have words to look for 
2a09			 
2a09 7e				ld a, (hl)      
2a0a				if DEBUG_FORTH_WORDS 
2a0a					DMARK "LSk" 
2a0a f5				push af  
2a0b 3a 1f 2a			ld a, (.dmark)  
2a0e 32 6e fb			ld (debug_mark),a  
2a11 3a 20 2a			ld a, (.dmark+1)  
2a14 32 6f fb			ld (debug_mark+1),a  
2a17 3a 21 2a			ld a, (.dmark+2)  
2a1a 32 70 fb			ld (debug_mark+2),a  
2a1d 18 03			jr .pastdmark  
2a1f ..			.dmark: db "LSk"  
2a22 f1			.pastdmark: pop af  
2a23			endm  
# End of macro DMARK
2a23					CALLMONITOR 
2a23 cd 6a 17			call break_point_state  
2a26				endm  
# End of macro CALLMONITOR
2a26				endif 
2a26					;cp WORD_SYS_END 
2a26					;jp z, .lunotfound 
2a26			 
2a26					; if we hit non uwords then gone too far 
2a26 fe 01				cp WORD_SYS_UWORD 
2a28 c2 58 2b				jp nz, .lunotfound 
2a2b			 
2a2b				if DEBUG_FORTH_WORDS 
2a2b					DMARK "LSu" 
2a2b f5				push af  
2a2c 3a 40 2a			ld a, (.dmark)  
2a2f 32 6e fb			ld (debug_mark),a  
2a32 3a 41 2a			ld a, (.dmark+1)  
2a35 32 6f fb			ld (debug_mark+1),a  
2a38 3a 42 2a			ld a, (.dmark+2)  
2a3b 32 70 fb			ld (debug_mark+2),a  
2a3e 18 03			jr .pastdmark  
2a40 ..			.dmark: db "LSu"  
2a43 f1			.pastdmark: pop af  
2a44			endm  
# End of macro DMARK
2a44					CALLMONITOR 
2a44 cd 6a 17			call break_point_state  
2a47				endm  
# End of macro CALLMONITOR
2a47				endif 
2a47			 
2a47					; found a uword but is it the one we want... 
2a47			 
2a47 c5					push bc     ; uword to find is on bc 
2a48 d1					pop de 
2a49			 
2a49 e5					push hl  ; to save the ptr 
2a4a			 
2a4a					; skip opcode 
2a4a 23					inc hl  
2a4b					; skip next ptr 
2a4b 23					inc hl  
2a4c 23					inc hl 
2a4d					; skip len 
2a4d 23					inc hl 
2a4e			 
2a4e				if DEBUG_FORTH_WORDS 
2a4e					DMARK "LSc" 
2a4e f5				push af  
2a4f 3a 63 2a			ld a, (.dmark)  
2a52 32 6e fb			ld (debug_mark),a  
2a55 3a 64 2a			ld a, (.dmark+1)  
2a58 32 6f fb			ld (debug_mark+1),a  
2a5b 3a 65 2a			ld a, (.dmark+2)  
2a5e 32 70 fb			ld (debug_mark+2),a  
2a61 18 03			jr .pastdmark  
2a63 ..			.dmark: db "LSc"  
2a66 f1			.pastdmark: pop af  
2a67			endm  
# End of macro DMARK
2a67					CALLMONITOR 
2a67 cd 6a 17			call break_point_state  
2a6a				endm  
# End of macro CALLMONITOR
2a6a				endif 
2a6a cd b1 11				call strcmp 
2a6d c2 e9 29				jp nz, .ldouscanm 
2a70				 
2a70			 
2a70			 
2a70					; we have a uword so push its name to the stack 
2a70			 
2a70			;	   	push hl  ; save so we can move to next dict block 
2a70 e1			pop hl 
2a71			 
2a71				if DEBUG_FORTH_WORDS 
2a71					DMARK "LSm" 
2a71 f5				push af  
2a72 3a 86 2a			ld a, (.dmark)  
2a75 32 6e fb			ld (debug_mark),a  
2a78 3a 87 2a			ld a, (.dmark+1)  
2a7b 32 6f fb			ld (debug_mark+1),a  
2a7e 3a 88 2a			ld a, (.dmark+2)  
2a81 32 70 fb			ld (debug_mark+2),a  
2a84 18 03			jr .pastdmark  
2a86 ..			.dmark: db "LSm"  
2a89 f1			.pastdmark: pop af  
2a8a			endm  
# End of macro DMARK
2a8a					CALLMONITOR 
2a8a cd 6a 17			call break_point_state  
2a8d				endm  
# End of macro CALLMONITOR
2a8d				endif 
2a8d			 
2a8d					; skip opcode 
2a8d 23					inc hl  
2a8e					; skip next ptr 
2a8e 23					inc hl  
2a8f 23					inc hl 
2a90					; skip len 
2a90 7e					ld a, (hl)   ; save length to add 
2a91				if DEBUG_FORTH_WORDS 
2a91					DMARK "LS2" 
2a91 f5				push af  
2a92 3a a6 2a			ld a, (.dmark)  
2a95 32 6e fb			ld (debug_mark),a  
2a98 3a a7 2a			ld a, (.dmark+1)  
2a9b 32 6f fb			ld (debug_mark+1),a  
2a9e 3a a8 2a			ld a, (.dmark+2)  
2aa1 32 70 fb			ld (debug_mark+2),a  
2aa4 18 03			jr .pastdmark  
2aa6 ..			.dmark: db "LS2"  
2aa9 f1			.pastdmark: pop af  
2aaa			endm  
# End of macro DMARK
2aaa					CALLMONITOR 
2aaa cd 6a 17			call break_point_state  
2aad				endm  
# End of macro CALLMONITOR
2aad				endif 
2aad			 
2aad					; save this location 
2aad				 
2aad e5					push hl 
2aae			 
2aae 23					inc hl 
2aaf 11 16 ee				ld de, scratch+2 
2ab2 4f					ld c, a 
2ab3 06 00				ld b, 0 
2ab5			 
2ab5				if DEBUG_FORTH_WORDS 
2ab5					DMARK "LSn" 
2ab5 f5				push af  
2ab6 3a ca 2a			ld a, (.dmark)  
2ab9 32 6e fb			ld (debug_mark),a  
2abc 3a cb 2a			ld a, (.dmark+1)  
2abf 32 6f fb			ld (debug_mark+1),a  
2ac2 3a cc 2a			ld a, (.dmark+2)  
2ac5 32 70 fb			ld (debug_mark+2),a  
2ac8 18 03			jr .pastdmark  
2aca ..			.dmark: db "LSn"  
2acd f1			.pastdmark: pop af  
2ace			endm  
# End of macro DMARK
2ace					CALLMONITOR 
2ace cd 6a 17			call break_point_state  
2ad1				endm  
# End of macro CALLMONITOR
2ad1				endif 
2ad1			 
2ad1					; copy uword name to scratch 
2ad1			 
2ad1 ed b0				ldir 
2ad3			 
2ad3 1b					dec de 
2ad4 3e 20				ld a, ' '    ; change null to space 
2ad6 12					ld (de), a 
2ad7			 
2ad7 13					inc de 
2ad8			 
2ad8 d5					push de 
2ad9 c1					pop bc     ; move scratch pointer to end of word name and save it 
2ada			 
2ada e1					pop hl 
2adb 7e					ld a, (hl) 
2adc					;inc hl 
2adc					; skip word string 
2adc cd 1b 0d				call addatohl 
2adf			 
2adf 23					inc hl 
2ae0			 
2ae0				if DEBUG_FORTH_WORDS 
2ae0					DMARK "LS3" 
2ae0 f5				push af  
2ae1 3a f5 2a			ld a, (.dmark)  
2ae4 32 6e fb			ld (debug_mark),a  
2ae7 3a f6 2a			ld a, (.dmark+1)  
2aea 32 6f fb			ld (debug_mark+1),a  
2aed 3a f7 2a			ld a, (.dmark+2)  
2af0 32 70 fb			ld (debug_mark+2),a  
2af3 18 03			jr .pastdmark  
2af5 ..			.dmark: db "LS3"  
2af8 f1			.pastdmark: pop af  
2af9			endm  
# End of macro DMARK
2af9					CALLMONITOR 
2af9 cd 6a 17			call break_point_state  
2afc				endm  
# End of macro CALLMONITOR
2afc				endif 
2afc					; should now be at the start of the machine code to setup the eval of the uword 
2afc					; now locate the ptr to the string defintion 
2afc			 
2afc					; skip ld hl, 
2afc					; then load the ptr 
2afc			; TODO use get from hl ptr 
2afc 23					inc hl 
2afd 5e					ld e, (hl) 
2afe 23					inc hl 
2aff 56					ld d, (hl) 
2b00 eb					ex de, hl 
2b01			 
2b01			 
2b01				if DEBUG_FORTH_WORDS 
2b01					DMARK "LSt" 
2b01 f5				push af  
2b02 3a 16 2b			ld a, (.dmark)  
2b05 32 6e fb			ld (debug_mark),a  
2b08 3a 17 2b			ld a, (.dmark+1)  
2b0b 32 6f fb			ld (debug_mark+1),a  
2b0e 3a 18 2b			ld a, (.dmark+2)  
2b11 32 70 fb			ld (debug_mark+2),a  
2b14 18 03			jr .pastdmark  
2b16 ..			.dmark: db "LSt"  
2b19 f1			.pastdmark: pop af  
2b1a			endm  
# End of macro DMARK
2b1a					CALLMONITOR 
2b1a cd 6a 17			call break_point_state  
2b1d				endm  
# End of macro CALLMONITOR
2b1d				endif 
2b1d			 
2b1d			; cant push right now due to tokenised strings  
2b1d			 
2b1d			; get the destination of where to copy this definition to. 
2b1d			 
2b1d c5					push bc 
2b1e d1					pop de 
2b1f			 
2b1f 7e			.listl:         ld a,(hl) 
2b20 fe 00				cp 0 
2b22 28 09				jr z, .lreplsp     ; replace zero with space 
2b24					;cp FORTH_END_BUFFER 
2b24 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2b26 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b28				 
2b28					; just copy this char as is then 
2b28			 
2b28 12					ld (de), a 
2b29			 
2b29 23			.listnxt:	inc hl 
2b2a 13					inc de 
2b2b 18 f2				jr .listl 
2b2d			 
2b2d 3e 20		.lreplsp:	ld a,' ' 
2b2f 12					ld (de), a 
2b30 18 f7				jr .listnxt 
2b32			 
2b32			; close up uword def 
2b32			 
2b32			.listdone: 
2b32 12					ld (de), a 
2b33 13					inc de 
2b34 3e 00				ld a, 0 
2b36 12					ld (de), a 
2b37			 
2b37			; now have def so clean up and push to stack 
2b37			 
2b37 21 14 ee				ld hl, scratch 
2b3a				if DEBUG_FORTH_WORDS 
2b3a					DMARK "Ltp" 
2b3a f5				push af  
2b3b 3a 4f 2b			ld a, (.dmark)  
2b3e 32 6e fb			ld (debug_mark),a  
2b41 3a 50 2b			ld a, (.dmark+1)  
2b44 32 6f fb			ld (debug_mark+1),a  
2b47 3a 51 2b			ld a, (.dmark+2)  
2b4a 32 70 fb			ld (debug_mark+2),a  
2b4d 18 03			jr .pastdmark  
2b4f ..			.dmark: db "Ltp"  
2b52 f1			.pastdmark: pop af  
2b53			endm  
# End of macro DMARK
2b53					CALLMONITOR 
2b53 cd 6a 17			call break_point_state  
2b56				endm  
# End of macro CALLMONITOR
2b56				endif 
2b56			 
2b56 18 1f			jr .listpush 
2b58			 
2b58			;.lnuword:	pop hl 
2b58			;		call forth_tok_next 
2b58			;		jp .ldouscan  
2b58			 
2b58			.lunotfound:		  
2b58			 
2b58				if DEBUG_FORTH_WORDS 
2b58					DMARK "LSn" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 6e fb			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 6f fb			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 70 fb			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "LSn"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71					CALLMONITOR 
2b71 cd 6a 17			call break_point_state  
2b74				endm  
# End of macro CALLMONITOR
2b74				endif 
2b74			 
2b74					 
2b74			;		FORTH_DSP_POP 
2b74			;		ld hl, .luno 
2b74			 
2b74					NEXTW			 
2b74 c3 63 20			jp macro_next 
2b77				endm 
# End of macro NEXTW
2b77			 
2b77			.listpush: 
2b77				if DEBUG_FORTH_WORDS 
2b77					DMARK "LS>" 
2b77 f5				push af  
2b78 3a 8c 2b			ld a, (.dmark)  
2b7b 32 6e fb			ld (debug_mark),a  
2b7e 3a 8d 2b			ld a, (.dmark+1)  
2b81 32 6f fb			ld (debug_mark+1),a  
2b84 3a 8e 2b			ld a, (.dmark+2)  
2b87 32 70 fb			ld (debug_mark+2),a  
2b8a 18 03			jr .pastdmark  
2b8c ..			.dmark: db "LS>"  
2b8f f1			.pastdmark: pop af  
2b90			endm  
# End of macro DMARK
2b90					CALLMONITOR 
2b90 cd 6a 17			call break_point_state  
2b93				endm  
# End of macro CALLMONITOR
2b93				endif 
2b93 cd 68 1d				call forth_push_str 
2b96			 
2b96			 
2b96			 
2b96					NEXTW 
2b96 c3 63 20			jp macro_next 
2b99				endm 
# End of macro NEXTW
2b99			 
2b99			;.luno:    db "Word not found",0 
2b99			 
2b99			 
2b99			 
2b99			 
2b99			 
2b99			;		push hl   ; save pointer to start of uword def string 
2b99			; 
2b99			;; look for FORTH_EOL_LINE 
2b99			;		ld a, FORTH_END_BUFFER 
2b99			;		call strlent 
2b99			; 
2b99			;		inc hl		 ; space for coln def 
2b99			;		inc hl 
2b99			;		inc hl          ; space for terms 
2b99			;		inc hl 
2b99			; 
2b99			;		ld a, 20   ; TODO get actual length 
2b99			;		call addatohl    ; include a random amount of room for the uword name 
2b99			; 
2b99			;		 
2b99			;	if DEBUG_FORTH_WORDS 
2b99			;		DMARK "Lt1" 
2b99			;		CALLMONITOR 
2b99			;	endif 
2b99			;		 
2b99			; 
2b99			;; malloc space for the string because we cant change it 
2b99			; 
2b99			;		call malloc 
2b99			;	if DEBUG_FORTH_MALLOC_GUARD 
2b99			;		push af 
2b99			;		call ishlzero 
2b99			;		pop af 
2b99			;		 
2b99			;		call z,malloc_error 
2b99			;	endif 
2b99			; 
2b99			;	if DEBUG_FORTH_WORDS 
2b99			;		DMARK "Lt2" 
2b99			;		CALLMONITOR 
2b99			;	endif 
2b99			;		pop de 
2b99			;		push hl    ; push the malloc to release later 
2b99			;		push hl   ;  push back a copy for the later stack push 
2b99			;		 
2b99			;; copy the string swapping out the zero terms for spaces 
2b99			; 
2b99			;		; de has our source 
2b99			;		; hl has our dest 
2b99			; 
2b99			;; add the coln def 
2b99			; 
2b99			;		ld a, ':' 
2b99			;		ld (hl), a 
2b99			;		inc hl 
2b99			;		ld a, ' ' 
2b99			;		ld (hl), a 
2b99			;		inc hl 
2b99			; 
2b99			;; add the uname word 
2b99			;		push de   ; save our string for now 
2b99			;		ex de, hl 
2b99			; 
2b99			;		FORTH_DSP_VALUE 
2b99			;		;v5 FORTH_DSP_VALUE 
2b99			; 
2b99			;		inc hl   ; skip type but we know by now this is OK 
2b99			; 
2b99			;.luword:	ld a,(hl) 
2b99			;		cp 0 
2b99			;		jr z, .luword2 
2b99			;		ld (de), a 
2b99			;		inc de 
2b99			;		inc hl 
2b99			;		jr .luword 
2b99			; 
2b99			;.luword2:	ld a, ' ' 
2b99			;		ld (de), a 
2b99			;;		inc hl 
2b99			;;		inc de 
2b99			;;		ld (de), a 
2b99			;;		inc hl 
2b99			;		inc de 
2b99			; 
2b99			;		ex de, hl 
2b99			;		pop de 
2b99			;		 
2b99			;		 
2b99			; 
2b99			;; detoken that string and copy it 
2b99			; 
2b99			;	if DEBUG_FORTH_WORDS 
2b99			;		DMARK "Lt2" 
2b99			;		CALLMONITOR 
2b99			;	endif 
2b99			;.ldetok:	ld a, (de) 
2b99			;		cp FORTH_END_BUFFER 
2b99			;		jr z, .ldetokend 
2b99			;		; swap out any zero term for space 
2b99			;		cp 0 
2b99			;		jr nz, .ldetoknext 
2b99			;		ld a, ' ' 
2b99			; 
2b99			;	if DEBUG_FORTH_WORDS 
2b99			;		DMARK "LtS" 
2b99			;		CALLMONITOR 
2b99			;	endif 
2b99			;.ldetoknext:	ld (hl), a 
2b99			;		inc de 
2b99			;		inc hl 
2b99			;		jr .ldetok 
2b99			; 
2b99			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b99			;		ld (hl), a  
2b99			; 
2b99			;; free that temp malloc 
2b99			; 
2b99			;		pop hl    
2b99			; 
2b99			;	if DEBUG_FORTH_WORDS 
2b99			;		DMARK "Lt4" 
2b99			;		CALLMONITOR 
2b99			;	endif 
2b99			;		call forth_apushstrhl 
2b99			; 
2b99			;		; get rid of temp malloc area 
2b99			; 
2b99			;		pop hl 
2b99			;		call free 
2b99			; 
2b99			;		jr .ludone 
2b99			; 
2b99			;.lnuword:	pop hl 
2b99			;		call forth_tok_next 
2b99			;		jp .ldouscan  
2b99			; 
2b99			;.ludone:		 pop hl 
2b99			; 
2b99					NEXTW 
2b99 c3 63 20			jp macro_next 
2b9c				endm 
# End of macro NEXTW
2b9c			 
2b9c			.FORGET: 
2b9c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b9c 5d				db WORD_SYS_CORE+73             
2b9d 15 2c			dw .NOP            
2b9f 07				db 6 + 1 
2ba0 .. 00			db "FORGET",0              
2ba7				endm 
# End of macro CWHEAD
2ba7			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ba7			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2ba7			; | |  
2ba7			; | | e.g. "MORE" forget 
2ba7					if DEBUG_FORTH_WORDS_KEY 
2ba7						DMARK "FRG" 
2ba7 f5				push af  
2ba8 3a bc 2b			ld a, (.dmark)  
2bab 32 6e fb			ld (debug_mark),a  
2bae 3a bd 2b			ld a, (.dmark+1)  
2bb1 32 6f fb			ld (debug_mark+1),a  
2bb4 3a be 2b			ld a, (.dmark+2)  
2bb7 32 70 fb			ld (debug_mark+2),a  
2bba 18 03			jr .pastdmark  
2bbc ..			.dmark: db "FRG"  
2bbf f1			.pastdmark: pop af  
2bc0			endm  
# End of macro DMARK
2bc0						CALLMONITOR 
2bc0 cd 6a 17			call break_point_state  
2bc3				endm  
# End of macro CALLMONITOR
2bc3					endif 
2bc3			 
2bc3				; find uword 
2bc3			        ; update start of word with "_" 
2bc3				; replace uword with deleted flag 
2bc3			 
2bc3			 
2bc3			;	if DEBUG_FORTH_WORDS 
2bc3			;		DMARK "FOG" 
2bc3			;		CALLMONITOR 
2bc3			;	endif 
2bc3			 
2bc3			 
2bc3					; Get ptr to the word we need to look up 
2bc3			 
2bc3					FORTH_DSP_VALUEHL 
2bc3 cd f1 1e			call macro_dsp_valuehl 
2bc6				endm 
# End of macro FORTH_DSP_VALUEHL
2bc6					;v5 FORTH_DSP_VALUE 
2bc6				; TODO type check 
2bc6			;		inc hl    ; Skip type check  
2bc6 e5					push hl 
2bc7 c1					pop bc 
2bc8			;		ex de, hl    ; put into DE 
2bc8			 
2bc8			 
2bc8 21 00 80				ld hl, baseram 
2bcb					;ld hl, baseusermem 
2bcb			 
2bcb				; skip dict stub 
2bcb			;	call forth_tok_next 
2bcb e5			push hl   ; sacreifical push 
2bcc			 
2bcc			.fldouscanm: 
2bcc e1				pop hl 
2bcd			.fldouscan: 
2bcd			;	if DEBUG_FORTH_WORDS 
2bcd			;		DMARK "LSs" 
2bcd			;		CALLMONITOR 
2bcd			;	endif 
2bcd				; skip dict stub 
2bcd cd b4 21				call forth_tok_next 
2bd0			 
2bd0			 
2bd0			; while we have words to look for 
2bd0			 
2bd0 7e				ld a, (hl)      
2bd1			;	if DEBUG_FORTH_WORDS 
2bd1			;		DMARK "LSk" 
2bd1			;		CALLMONITOR 
2bd1			;	endif 
2bd1 fe 00				cp WORD_SYS_END 
2bd3 ca 0f 2c				jp z, .flunotfound 
2bd6 fe 01				cp WORD_SYS_UWORD 
2bd8 c2 cd 2b				jp nz, .fldouscan 
2bdb			 
2bdb			;	if DEBUG_FORTH_WORDS 
2bdb			;		DMARK "LSu" 
2bdb			;		CALLMONITOR 
2bdb			;	endif 
2bdb			 
2bdb					; found a uword but is it the one we want... 
2bdb			 
2bdb c5					push bc     ; uword to find is on bc 
2bdc d1					pop de 
2bdd			 
2bdd e5					push hl  ; to save the ptr 
2bde			 
2bde					; skip opcode 
2bde 23					inc hl  
2bdf					; skip next ptr 
2bdf 23					inc hl  
2be0 23					inc hl 
2be1					; skip len 
2be1 23					inc hl 
2be2			 
2be2			;	if DEBUG_FORTH_WORDS 
2be2			;		DMARK "LSc" 
2be2			;		CALLMONITOR 
2be2			;	endif 
2be2 cd b1 11				call strcmp 
2be5 c2 cc 2b				jp nz, .fldouscanm 
2be8			; 
2be8			; 
2be8			;; while we have words to look for 
2be8			; 
2be8			;.fdouscan:	ld a, (hl)      
2be8			;	if DEBUG_FORTH_WORDS 
2be8			;		DMARK "LSs" 
2be8			;		CALLMONITOR 
2be8			;	endif 
2be8			;		cp WORD_SYS_END 
2be8			;		jp z, .fudone 
2be8			;		cp WORD_SYS_UWORD 
2be8			;		jp nz, .fnuword 
2be8			; 
2be8			;	if DEBUG_FORTH_WORDS 
2be8			;		DMARK "FGu" 
2be8			;		CALLMONITOR 
2be8			;	endif 
2be8			; 
2be8			;		; found a uword but is it the one we want... 
2be8			; 
2be8			; 
2be8			;	        pop de   ; get back the dsp name 
2be8			;		push de 
2be8			; 
2be8			;		push hl  ; to save the ptr 
2be8			; 
2be8			;		; skip opcode 
2be8			;		inc hl  
2be8			;		; skip next ptr 
2be8			;		inc hl  
2be8			;		inc hl 
2be8			;		; skip len 
2be8			;		inc hl 
2be8			; 
2be8			;	if DEBUG_FORTH_WORDS 
2be8			;		DMARK "FGc" 
2be8			;		CALLMONITOR 
2be8			;	endif 
2be8			;		call strcmp 
2be8			;		jp nz, .fnuword 
2be8			 
2be8			 
2be8 e1			pop hl 
2be9			 
2be9				 
2be9				if DEBUG_FORTH_WORDS 
2be9					DMARK "FGm" 
2be9 f5				push af  
2bea 3a fe 2b			ld a, (.dmark)  
2bed 32 6e fb			ld (debug_mark),a  
2bf0 3a ff 2b			ld a, (.dmark+1)  
2bf3 32 6f fb			ld (debug_mark+1),a  
2bf6 3a 00 2c			ld a, (.dmark+2)  
2bf9 32 70 fb			ld (debug_mark+2),a  
2bfc 18 03			jr .pastdmark  
2bfe ..			.dmark: db "FGm"  
2c01 f1			.pastdmark: pop af  
2c02			endm  
# End of macro DMARK
2c02					CALLMONITOR 
2c02 cd 6a 17			call break_point_state  
2c05				endm  
# End of macro CALLMONITOR
2c05				endif 
2c05			 
2c05			 
2c05			 
2c05					; we have a uword so push its name to the stack 
2c05			 
2c05			;	   	push hl  ; save so we can move to next dict block 
2c05			;pop hl 
2c05			 
2c05					; update opcode to deleted 
2c05 3e 03				ld a, WORD_SYS_DELETED 
2c07 77					ld (hl), a 
2c08			 
2c08 23					inc hl  
2c09					; skip next ptr 
2c09 23					inc hl  
2c0a 23					inc hl 
2c0b					; skip len 
2c0b 23					inc hl 
2c0c			 
2c0c					; TODO change parser to skip deleted words but for now mark it out 
2c0c 3e 5f				ld a, "_" 
2c0e 77					ld  (hl),a 
2c0f			 
2c0f			;		jr .fudone 
2c0f			; 
2c0f			;.fnuword:	pop hl 
2c0f			;		call forth_tok_next 
2c0f			;		jp .fdouscan  
2c0f			 
2c0f			.flunotfound:		  
2c0f			 
2c0f			 
2c0f					 
2c0f					FORTH_DSP_POP 
2c0f cd a9 1f			call macro_forth_dsp_pop 
2c12				endm 
# End of macro FORTH_DSP_POP
2c12			;		ld hl, .luno 
2c12			;.fudone:		 pop hl 
2c12					NEXTW 
2c12 c3 63 20			jp macro_next 
2c15				endm 
# End of macro NEXTW
2c15			.NOP: 
2c15				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c15 61				db WORD_SYS_CORE+77             
2c16 3c 2c			dw .COMO            
2c18 04				db 3 + 1 
2c19 .. 00			db "NOP",0              
2c1d				endm 
# End of macro CWHEAD
2c1d			; | NOP (  --  ) Do nothing | DONE 
2c1d					if DEBUG_FORTH_WORDS_KEY 
2c1d						DMARK "NOP" 
2c1d f5				push af  
2c1e 3a 32 2c			ld a, (.dmark)  
2c21 32 6e fb			ld (debug_mark),a  
2c24 3a 33 2c			ld a, (.dmark+1)  
2c27 32 6f fb			ld (debug_mark+1),a  
2c2a 3a 34 2c			ld a, (.dmark+2)  
2c2d 32 70 fb			ld (debug_mark+2),a  
2c30 18 03			jr .pastdmark  
2c32 ..			.dmark: db "NOP"  
2c35 f1			.pastdmark: pop af  
2c36			endm  
# End of macro DMARK
2c36						CALLMONITOR 
2c36 cd 6a 17			call break_point_state  
2c39				endm  
# End of macro CALLMONITOR
2c39					endif 
2c39				       NEXTW 
2c39 c3 63 20			jp macro_next 
2c3c				endm 
# End of macro NEXTW
2c3c			.COMO: 
2c3c				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c3c 6e				db WORD_SYS_CORE+90             
2c3d 8e 2c			dw .COMC            
2c3f 02				db 1 + 1 
2c40 .. 00			db "(",0              
2c42				endm 
# End of macro CWHEAD
2c42			; | ( ( -- )  Start of comment | DONE 
2c42			 
2c42			 
2c42 2a 15 f1				ld hl, ( os_tok_ptr) 
2c45 11 89 2c			ld de, .closepar 
2c48					 
2c48					if DEBUG_FORTH_WORDS 
2c48						DMARK ").." 
2c48 f5				push af  
2c49 3a 5d 2c			ld a, (.dmark)  
2c4c 32 6e fb			ld (debug_mark),a  
2c4f 3a 5e 2c			ld a, (.dmark+1)  
2c52 32 6f fb			ld (debug_mark+1),a  
2c55 3a 5f 2c			ld a, (.dmark+2)  
2c58 32 70 fb			ld (debug_mark+2),a  
2c5b 18 03			jr .pastdmark  
2c5d ..			.dmark: db ").."  
2c60 f1			.pastdmark: pop af  
2c61			endm  
# End of macro DMARK
2c61						CALLMONITOR 
2c61 cd 6a 17			call break_point_state  
2c64				endm  
# End of macro CALLMONITOR
2c64					endif 
2c64 cd 7e 21			call findnexttok  
2c67			 
2c67					if DEBUG_FORTH_WORDS 
2c67						DMARK "IF5" 
2c67 f5				push af  
2c68 3a 7c 2c			ld a, (.dmark)  
2c6b 32 6e fb			ld (debug_mark),a  
2c6e 3a 7d 2c			ld a, (.dmark+1)  
2c71 32 6f fb			ld (debug_mark+1),a  
2c74 3a 7e 2c			ld a, (.dmark+2)  
2c77 32 70 fb			ld (debug_mark+2),a  
2c7a 18 03			jr .pastdmark  
2c7c ..			.dmark: db "IF5"  
2c7f f1			.pastdmark: pop af  
2c80			endm  
# End of macro DMARK
2c80						CALLMONITOR 
2c80 cd 6a 17			call break_point_state  
2c83				endm  
# End of macro CALLMONITOR
2c83					endif 
2c83				; replace below with ) exec using tok_ptr 
2c83 22 15 f1			ld (os_tok_ptr), hl 
2c86 c3 f4 20			jp exec1 
2c89			 
2c89 .. 00			.closepar:   db ")",0 
2c8b			 
2c8b				       NEXTW 
2c8b c3 63 20			jp macro_next 
2c8e				endm 
# End of macro NEXTW
2c8e			.COMC: 
2c8e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c8e 6f				db WORD_SYS_CORE+91             
2c8f 97 2c			dw .SCRATCH            
2c91 02				db 1 + 1 
2c92 .. 00			db ")",0              
2c94				endm 
# End of macro CWHEAD
2c94			; | ) ( -- )  End of comment |  DONE  
2c94				       NEXTW 
2c94 c3 63 20			jp macro_next 
2c97				endm 
# End of macro NEXTW
2c97			 
2c97			.SCRATCH: 
2c97				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c97 6f				db WORD_SYS_CORE+91             
2c98 d2 2c			dw .INC            
2c9a 08				db 7 + 1 
2c9b .. 00			db "SCRATCH",0              
2ca3				endm 
# End of macro CWHEAD
2ca3			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ca3			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ca3			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ca3			; | |  
2ca3			; | | e.g.    : score $00 scratch ; 
2ca3			; | |  
2ca3			; | | $00 score ! 
2ca3			; | | $01 score +! 
2ca3			; | |  
2ca3			; | | e.g.   : varword $0a scratch ;  
2ca3			; | | 
2ca3			; | | $8000 varword ! 
2ca3					if DEBUG_FORTH_WORDS_KEY 
2ca3						DMARK "SCR" 
2ca3 f5				push af  
2ca4 3a b8 2c			ld a, (.dmark)  
2ca7 32 6e fb			ld (debug_mark),a  
2caa 3a b9 2c			ld a, (.dmark+1)  
2cad 32 6f fb			ld (debug_mark+1),a  
2cb0 3a ba 2c			ld a, (.dmark+2)  
2cb3 32 70 fb			ld (debug_mark+2),a  
2cb6 18 03			jr .pastdmark  
2cb8 ..			.dmark: db "SCR"  
2cbb f1			.pastdmark: pop af  
2cbc			endm  
# End of macro DMARK
2cbc						CALLMONITOR 
2cbc cd 6a 17			call break_point_state  
2cbf				endm  
# End of macro CALLMONITOR
2cbf					endif 
2cbf			 
2cbf					FORTH_DSP_VALUEHL 
2cbf cd f1 1e			call macro_dsp_valuehl 
2cc2				endm 
# End of macro FORTH_DSP_VALUEHL
2cc2				 
2cc2					FORTH_DSP_POP 
2cc2 cd a9 1f			call macro_forth_dsp_pop 
2cc5				endm 
# End of macro FORTH_DSP_POP
2cc5			 
2cc5 7d					ld a, l 
2cc6 21 39 f3				ld hl, os_var_array 
2cc9 cd 1b 0d				call addatohl 
2ccc			 
2ccc cd fa 1c				call forth_push_numhl 
2ccf			 
2ccf				       NEXTW 
2ccf c3 63 20			jp macro_next 
2cd2				endm 
# End of macro NEXTW
2cd2			 
2cd2			.INC: 
2cd2				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2cd2 6f				db WORD_SYS_CORE+91             
2cd3 26 2d			dw .DEC            
2cd5 03				db 2 + 1 
2cd6 .. 00			db "+!",0              
2cd9				endm 
# End of macro CWHEAD
2cd9			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2cd9					if DEBUG_FORTH_WORDS_KEY 
2cd9						DMARK "+s_" 
2cd9 f5				push af  
2cda 3a ee 2c			ld a, (.dmark)  
2cdd 32 6e fb			ld (debug_mark),a  
2ce0 3a ef 2c			ld a, (.dmark+1)  
2ce3 32 6f fb			ld (debug_mark+1),a  
2ce6 3a f0 2c			ld a, (.dmark+2)  
2ce9 32 70 fb			ld (debug_mark+2),a  
2cec 18 03			jr .pastdmark  
2cee ..			.dmark: db "+s_"  
2cf1 f1			.pastdmark: pop af  
2cf2			endm  
# End of macro DMARK
2cf2						CALLMONITOR 
2cf2 cd 6a 17			call break_point_state  
2cf5				endm  
# End of macro CALLMONITOR
2cf5					endif 
2cf5			 
2cf5					FORTH_DSP_VALUEHL 
2cf5 cd f1 1e			call macro_dsp_valuehl 
2cf8				endm 
# End of macro FORTH_DSP_VALUEHL
2cf8			 
2cf8 e5					push hl   ; save address 
2cf9			 
2cf9					FORTH_DSP_POP 
2cf9 cd a9 1f			call macro_forth_dsp_pop 
2cfc				endm 
# End of macro FORTH_DSP_POP
2cfc			 
2cfc					FORTH_DSP_VALUEHL 
2cfc cd f1 1e			call macro_dsp_valuehl 
2cff				endm 
# End of macro FORTH_DSP_VALUEHL
2cff			 
2cff					FORTH_DSP_POP 
2cff cd a9 1f			call macro_forth_dsp_pop 
2d02				endm 
# End of macro FORTH_DSP_POP
2d02			 
2d02					; hl contains value to add to byte at a 
2d02				 
2d02 eb					ex de, hl 
2d03			 
2d03 e1					pop hl 
2d04			 
2d04					if DEBUG_FORTH_WORDS 
2d04						DMARK "INC" 
2d04 f5				push af  
2d05 3a 19 2d			ld a, (.dmark)  
2d08 32 6e fb			ld (debug_mark),a  
2d0b 3a 1a 2d			ld a, (.dmark+1)  
2d0e 32 6f fb			ld (debug_mark+1),a  
2d11 3a 1b 2d			ld a, (.dmark+2)  
2d14 32 70 fb			ld (debug_mark+2),a  
2d17 18 03			jr .pastdmark  
2d19 ..			.dmark: db "INC"  
2d1c f1			.pastdmark: pop af  
2d1d			endm  
# End of macro DMARK
2d1d						CALLMONITOR 
2d1d cd 6a 17			call break_point_state  
2d20				endm  
# End of macro CALLMONITOR
2d20					endif 
2d20			 
2d20 7e					ld a,(hl) 
2d21 83					add e 
2d22 77					ld (hl),a 
2d23			 
2d23			 
2d23			 
2d23				       NEXTW 
2d23 c3 63 20			jp macro_next 
2d26				endm 
# End of macro NEXTW
2d26			 
2d26			.DEC: 
2d26				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d26 6f				db WORD_SYS_CORE+91             
2d27 77 2d			dw .INC2            
2d29 03				db 2 + 1 
2d2a .. 00			db "-!",0              
2d2d				endm 
# End of macro CWHEAD
2d2d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d2d					if DEBUG_FORTH_WORDS_KEY 
2d2d						DMARK "-s_" 
2d2d f5				push af  
2d2e 3a 42 2d			ld a, (.dmark)  
2d31 32 6e fb			ld (debug_mark),a  
2d34 3a 43 2d			ld a, (.dmark+1)  
2d37 32 6f fb			ld (debug_mark+1),a  
2d3a 3a 44 2d			ld a, (.dmark+2)  
2d3d 32 70 fb			ld (debug_mark+2),a  
2d40 18 03			jr .pastdmark  
2d42 ..			.dmark: db "-s_"  
2d45 f1			.pastdmark: pop af  
2d46			endm  
# End of macro DMARK
2d46						CALLMONITOR 
2d46 cd 6a 17			call break_point_state  
2d49				endm  
# End of macro CALLMONITOR
2d49					endif 
2d49			 
2d49					FORTH_DSP_VALUEHL 
2d49 cd f1 1e			call macro_dsp_valuehl 
2d4c				endm 
# End of macro FORTH_DSP_VALUEHL
2d4c			 
2d4c e5					push hl   ; save address 
2d4d			 
2d4d					FORTH_DSP_POP 
2d4d cd a9 1f			call macro_forth_dsp_pop 
2d50				endm 
# End of macro FORTH_DSP_POP
2d50			 
2d50					FORTH_DSP_VALUEHL 
2d50 cd f1 1e			call macro_dsp_valuehl 
2d53				endm 
# End of macro FORTH_DSP_VALUEHL
2d53			 
2d53					; hl contains value to add to byte at a 
2d53				 
2d53 eb					ex de, hl 
2d54			 
2d54 e1					pop hl 
2d55			 
2d55					if DEBUG_FORTH_WORDS 
2d55						DMARK "DEC" 
2d55 f5				push af  
2d56 3a 6a 2d			ld a, (.dmark)  
2d59 32 6e fb			ld (debug_mark),a  
2d5c 3a 6b 2d			ld a, (.dmark+1)  
2d5f 32 6f fb			ld (debug_mark+1),a  
2d62 3a 6c 2d			ld a, (.dmark+2)  
2d65 32 70 fb			ld (debug_mark+2),a  
2d68 18 03			jr .pastdmark  
2d6a ..			.dmark: db "DEC"  
2d6d f1			.pastdmark: pop af  
2d6e			endm  
# End of macro DMARK
2d6e						CALLMONITOR 
2d6e cd 6a 17			call break_point_state  
2d71				endm  
# End of macro CALLMONITOR
2d71					endif 
2d71			 
2d71 7e					ld a,(hl) 
2d72 93					sub e 
2d73 77					ld (hl),a 
2d74			 
2d74			 
2d74			 
2d74				       NEXTW 
2d74 c3 63 20			jp macro_next 
2d77				endm 
# End of macro NEXTW
2d77			 
2d77			.INC2: 
2d77				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d77 6f				db WORD_SYS_CORE+91             
2d78 21 2e			dw .DEC2            
2d7a 04				db 3 + 1 
2d7b .. 00			db "+2!",0              
2d7f				endm 
# End of macro CWHEAD
2d7f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d7f			 
2d7f					if DEBUG_FORTH_WORDS_KEY 
2d7f						DMARK "+2s" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 6e fb			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 6f fb			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 70 fb			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "+2s"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98						CALLMONITOR 
2d98 cd 6a 17			call break_point_state  
2d9b				endm  
# End of macro CALLMONITOR
2d9b					endif 
2d9b			 
2d9b					; Address 
2d9b			 
2d9b					FORTH_DSP_VALUEHL 
2d9b cd f1 1e			call macro_dsp_valuehl 
2d9e				endm 
# End of macro FORTH_DSP_VALUEHL
2d9e			 
2d9e e5					push hl    ; save address 
2d9f			 
2d9f					; load content into de 
2d9f			 
2d9f 5e					ld e,(hl) 
2da0 23					inc hl 
2da1 56					ld d, (hl) 
2da2			 
2da2					if DEBUG_FORTH_WORDS 
2da2						DMARK "+2a" 
2da2 f5				push af  
2da3 3a b7 2d			ld a, (.dmark)  
2da6 32 6e fb			ld (debug_mark),a  
2da9 3a b8 2d			ld a, (.dmark+1)  
2dac 32 6f fb			ld (debug_mark+1),a  
2daf 3a b9 2d			ld a, (.dmark+2)  
2db2 32 70 fb			ld (debug_mark+2),a  
2db5 18 03			jr .pastdmark  
2db7 ..			.dmark: db "+2a"  
2dba f1			.pastdmark: pop af  
2dbb			endm  
# End of macro DMARK
2dbb						CALLMONITOR 
2dbb cd 6a 17			call break_point_state  
2dbe				endm  
# End of macro CALLMONITOR
2dbe					endif 
2dbe			 
2dbe					FORTH_DSP_POP 
2dbe cd a9 1f			call macro_forth_dsp_pop 
2dc1				endm 
# End of macro FORTH_DSP_POP
2dc1			 
2dc1					; Get value to add 
2dc1			 
2dc1					FORTH_DSP_VALUE 
2dc1 cd da 1e			call macro_forth_dsp_value 
2dc4				endm 
# End of macro FORTH_DSP_VALUE
2dc4			 
2dc4					if DEBUG_FORTH_WORDS 
2dc4						DMARK "+2v" 
2dc4 f5				push af  
2dc5 3a d9 2d			ld a, (.dmark)  
2dc8 32 6e fb			ld (debug_mark),a  
2dcb 3a da 2d			ld a, (.dmark+1)  
2dce 32 6f fb			ld (debug_mark+1),a  
2dd1 3a db 2d			ld a, (.dmark+2)  
2dd4 32 70 fb			ld (debug_mark+2),a  
2dd7 18 03			jr .pastdmark  
2dd9 ..			.dmark: db "+2v"  
2ddc f1			.pastdmark: pop af  
2ddd			endm  
# End of macro DMARK
2ddd						CALLMONITOR 
2ddd cd 6a 17			call break_point_state  
2de0				endm  
# End of macro CALLMONITOR
2de0					endif 
2de0			 
2de0 19					add hl, de 
2de1			 
2de1					if DEBUG_FORTH_WORDS 
2de1						DMARK "+2+" 
2de1 f5				push af  
2de2 3a f6 2d			ld a, (.dmark)  
2de5 32 6e fb			ld (debug_mark),a  
2de8 3a f7 2d			ld a, (.dmark+1)  
2deb 32 6f fb			ld (debug_mark+1),a  
2dee 3a f8 2d			ld a, (.dmark+2)  
2df1 32 70 fb			ld (debug_mark+2),a  
2df4 18 03			jr .pastdmark  
2df6 ..			.dmark: db "+2+"  
2df9 f1			.pastdmark: pop af  
2dfa			endm  
# End of macro DMARK
2dfa						CALLMONITOR 
2dfa cd 6a 17			call break_point_state  
2dfd				endm  
# End of macro CALLMONITOR
2dfd					endif 
2dfd			 
2dfd					; move result to de 
2dfd			 
2dfd eb					ex de, hl 
2dfe			 
2dfe					; Address 
2dfe			 
2dfe e1					pop hl 
2dff			 
2dff					; save it back 
2dff			 
2dff 73					ld (hl), e 
2e00 23					inc hl 
2e01 72					ld (hl), d 
2e02			 
2e02					if DEBUG_FORTH_WORDS 
2e02						DMARK "+2e" 
2e02 f5				push af  
2e03 3a 17 2e			ld a, (.dmark)  
2e06 32 6e fb			ld (debug_mark),a  
2e09 3a 18 2e			ld a, (.dmark+1)  
2e0c 32 6f fb			ld (debug_mark+1),a  
2e0f 3a 19 2e			ld a, (.dmark+2)  
2e12 32 70 fb			ld (debug_mark+2),a  
2e15 18 03			jr .pastdmark  
2e17 ..			.dmark: db "+2e"  
2e1a f1			.pastdmark: pop af  
2e1b			endm  
# End of macro DMARK
2e1b						CALLMONITOR 
2e1b cd 6a 17			call break_point_state  
2e1e				endm  
# End of macro CALLMONITOR
2e1e					endif 
2e1e			 
2e1e			 
2e1e			 
2e1e			 
2e1e			 
2e1e				       NEXTW 
2e1e c3 63 20			jp macro_next 
2e21				endm 
# End of macro NEXTW
2e21			 
2e21			.DEC2: 
2e21				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e21 6f				db WORD_SYS_CORE+91             
2e22 cd 2e			dw .GET2            
2e24 04				db 3 + 1 
2e25 .. 00			db "-2!",0              
2e29				endm 
# End of macro CWHEAD
2e29			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e29			 
2e29			 
2e29					if DEBUG_FORTH_WORDS_KEY 
2e29						DMARK "-2s" 
2e29 f5				push af  
2e2a 3a 3e 2e			ld a, (.dmark)  
2e2d 32 6e fb			ld (debug_mark),a  
2e30 3a 3f 2e			ld a, (.dmark+1)  
2e33 32 6f fb			ld (debug_mark+1),a  
2e36 3a 40 2e			ld a, (.dmark+2)  
2e39 32 70 fb			ld (debug_mark+2),a  
2e3c 18 03			jr .pastdmark  
2e3e ..			.dmark: db "-2s"  
2e41 f1			.pastdmark: pop af  
2e42			endm  
# End of macro DMARK
2e42						CALLMONITOR 
2e42 cd 6a 17			call break_point_state  
2e45				endm  
# End of macro CALLMONITOR
2e45					endif 
2e45			 
2e45					; Address 
2e45			 
2e45					FORTH_DSP_VALUEHL 
2e45 cd f1 1e			call macro_dsp_valuehl 
2e48				endm 
# End of macro FORTH_DSP_VALUEHL
2e48			 
2e48 e5					push hl    ; save address 
2e49			 
2e49					; load content into de 
2e49			 
2e49 5e					ld e,(hl) 
2e4a 23					inc hl 
2e4b 56					ld d, (hl) 
2e4c			 
2e4c					if DEBUG_FORTH_WORDS 
2e4c						DMARK "-2a" 
2e4c f5				push af  
2e4d 3a 61 2e			ld a, (.dmark)  
2e50 32 6e fb			ld (debug_mark),a  
2e53 3a 62 2e			ld a, (.dmark+1)  
2e56 32 6f fb			ld (debug_mark+1),a  
2e59 3a 63 2e			ld a, (.dmark+2)  
2e5c 32 70 fb			ld (debug_mark+2),a  
2e5f 18 03			jr .pastdmark  
2e61 ..			.dmark: db "-2a"  
2e64 f1			.pastdmark: pop af  
2e65			endm  
# End of macro DMARK
2e65						CALLMONITOR 
2e65 cd 6a 17			call break_point_state  
2e68				endm  
# End of macro CALLMONITOR
2e68					endif 
2e68			 
2e68					FORTH_DSP_POP 
2e68 cd a9 1f			call macro_forth_dsp_pop 
2e6b				endm 
# End of macro FORTH_DSP_POP
2e6b			 
2e6b					; Get value to remove 
2e6b			 
2e6b					FORTH_DSP_VALUE 
2e6b cd da 1e			call macro_forth_dsp_value 
2e6e				endm 
# End of macro FORTH_DSP_VALUE
2e6e			 
2e6e					if DEBUG_FORTH_WORDS 
2e6e						DMARK "-2v" 
2e6e f5				push af  
2e6f 3a 83 2e			ld a, (.dmark)  
2e72 32 6e fb			ld (debug_mark),a  
2e75 3a 84 2e			ld a, (.dmark+1)  
2e78 32 6f fb			ld (debug_mark+1),a  
2e7b 3a 85 2e			ld a, (.dmark+2)  
2e7e 32 70 fb			ld (debug_mark+2),a  
2e81 18 03			jr .pastdmark  
2e83 ..			.dmark: db "-2v"  
2e86 f1			.pastdmark: pop af  
2e87			endm  
# End of macro DMARK
2e87						CALLMONITOR 
2e87 cd 6a 17			call break_point_state  
2e8a				endm  
# End of macro CALLMONITOR
2e8a					endif 
2e8a			 
2e8a eb					ex de, hl 
2e8b ed 52				sbc hl, de 
2e8d			 
2e8d					if DEBUG_FORTH_WORDS 
2e8d						DMARK "-2d" 
2e8d f5				push af  
2e8e 3a a2 2e			ld a, (.dmark)  
2e91 32 6e fb			ld (debug_mark),a  
2e94 3a a3 2e			ld a, (.dmark+1)  
2e97 32 6f fb			ld (debug_mark+1),a  
2e9a 3a a4 2e			ld a, (.dmark+2)  
2e9d 32 70 fb			ld (debug_mark+2),a  
2ea0 18 03			jr .pastdmark  
2ea2 ..			.dmark: db "-2d"  
2ea5 f1			.pastdmark: pop af  
2ea6			endm  
# End of macro DMARK
2ea6						CALLMONITOR 
2ea6 cd 6a 17			call break_point_state  
2ea9				endm  
# End of macro CALLMONITOR
2ea9					endif 
2ea9			 
2ea9					; move result to de 
2ea9			 
2ea9 eb					ex de, hl 
2eaa			 
2eaa					; Address 
2eaa			 
2eaa e1					pop hl 
2eab			 
2eab					; save it back 
2eab			 
2eab 73					ld (hl), e 
2eac 23					inc hl 
2ead 72					ld (hl), d 
2eae			 
2eae					if DEBUG_FORTH_WORDS 
2eae						DMARK "-2e" 
2eae f5				push af  
2eaf 3a c3 2e			ld a, (.dmark)  
2eb2 32 6e fb			ld (debug_mark),a  
2eb5 3a c4 2e			ld a, (.dmark+1)  
2eb8 32 6f fb			ld (debug_mark+1),a  
2ebb 3a c5 2e			ld a, (.dmark+2)  
2ebe 32 70 fb			ld (debug_mark+2),a  
2ec1 18 03			jr .pastdmark  
2ec3 ..			.dmark: db "-2e"  
2ec6 f1			.pastdmark: pop af  
2ec7			endm  
# End of macro DMARK
2ec7						CALLMONITOR 
2ec7 cd 6a 17			call break_point_state  
2eca				endm  
# End of macro CALLMONITOR
2eca					endif 
2eca			 
2eca			 
2eca			 
2eca			 
2eca			 
2eca				       NEXTW 
2eca c3 63 20			jp macro_next 
2ecd				endm 
# End of macro NEXTW
2ecd			.GET2: 
2ecd				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2ecd 6f				db WORD_SYS_CORE+91             
2ece fd 2e			dw .BANG2            
2ed0 03				db 2 + 1 
2ed1 .. 00			db "2@",0              
2ed4				endm 
# End of macro CWHEAD
2ed4			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ed4					if DEBUG_FORTH_WORDS_KEY 
2ed4						DMARK "2A_" 
2ed4 f5				push af  
2ed5 3a e9 2e			ld a, (.dmark)  
2ed8 32 6e fb			ld (debug_mark),a  
2edb 3a ea 2e			ld a, (.dmark+1)  
2ede 32 6f fb			ld (debug_mark+1),a  
2ee1 3a eb 2e			ld a, (.dmark+2)  
2ee4 32 70 fb			ld (debug_mark+2),a  
2ee7 18 03			jr .pastdmark  
2ee9 ..			.dmark: db "2A_"  
2eec f1			.pastdmark: pop af  
2eed			endm  
# End of macro DMARK
2eed						CALLMONITOR 
2eed cd 6a 17			call break_point_state  
2ef0				endm  
# End of macro CALLMONITOR
2ef0					endif 
2ef0			 
2ef0					FORTH_DSP_VALUEHL 
2ef0 cd f1 1e			call macro_dsp_valuehl 
2ef3				endm 
# End of macro FORTH_DSP_VALUEHL
2ef3			 
2ef3 5e					ld e, (hl) 
2ef4 23					inc hl 
2ef5 56					ld d, (hl) 
2ef6			 
2ef6 eb					ex de, hl 
2ef7			 
2ef7 cd fa 1c				call forth_push_numhl 
2efa			 
2efa				       NEXTW 
2efa c3 63 20			jp macro_next 
2efd				endm 
# End of macro NEXTW
2efd			.BANG2: 
2efd				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2efd 6f				db WORD_SYS_CORE+91             
2efe 35 2f			dw .CONFIG            
2f00 03				db 2 + 1 
2f01 .. 00			db "2!",0              
2f04				endm 
# End of macro CWHEAD
2f04			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f04					if DEBUG_FORTH_WORDS_KEY 
2f04						DMARK "2S_" 
2f04 f5				push af  
2f05 3a 19 2f			ld a, (.dmark)  
2f08 32 6e fb			ld (debug_mark),a  
2f0b 3a 1a 2f			ld a, (.dmark+1)  
2f0e 32 6f fb			ld (debug_mark+1),a  
2f11 3a 1b 2f			ld a, (.dmark+2)  
2f14 32 70 fb			ld (debug_mark+2),a  
2f17 18 03			jr .pastdmark  
2f19 ..			.dmark: db "2S_"  
2f1c f1			.pastdmark: pop af  
2f1d			endm  
# End of macro DMARK
2f1d						CALLMONITOR 
2f1d cd 6a 17			call break_point_state  
2f20				endm  
# End of macro CALLMONITOR
2f20					endif 
2f20			 
2f20					FORTH_DSP_VALUEHL 
2f20 cd f1 1e			call macro_dsp_valuehl 
2f23				endm 
# End of macro FORTH_DSP_VALUEHL
2f23			 
2f23 e5					push hl   ; save address 
2f24			 
2f24			 
2f24					FORTH_DSP_POP 
2f24 cd a9 1f			call macro_forth_dsp_pop 
2f27				endm 
# End of macro FORTH_DSP_POP
2f27			 
2f27					 
2f27					FORTH_DSP_VALUEHL 
2f27 cd f1 1e			call macro_dsp_valuehl 
2f2a				endm 
# End of macro FORTH_DSP_VALUEHL
2f2a			 
2f2a					FORTH_DSP_POP 
2f2a cd a9 1f			call macro_forth_dsp_pop 
2f2d				endm 
# End of macro FORTH_DSP_POP
2f2d			 
2f2d eb					ex de, hl    ; value now in de 
2f2e			 
2f2e e1					pop hl 
2f2f			 
2f2f 73					ld (hl), e 
2f30			 
2f30 23					inc hl 
2f31			 
2f31 72					ld (hl), d 
2f32			 
2f32			 
2f32				       NEXTW 
2f32 c3 63 20			jp macro_next 
2f35				endm 
# End of macro NEXTW
2f35			.CONFIG: 
2f35				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f35 6f				db WORD_SYS_CORE+91             
2f36 46 2f			dw .ENDCORE            
2f38 07				db 6 + 1 
2f39 .. 00			db "CONFIG",0              
2f40				endm 
# End of macro CWHEAD
2f40			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f40			 
2f40 cd a5 13				call config 
2f43					NEXTW 
2f43 c3 63 20			jp macro_next 
2f46				endm 
# End of macro NEXTW
2f46			.ENDCORE: 
2f46			 
2f46			; eof 
2f46			 
2f46			 
# End of file forth_words_core.asm
2f46			include "forth_words_flow.asm" 
2f46			 
2f46			; | ## Program Flow Words 
2f46			 
2f46			.IF: 
2f46				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f46 1e				db WORD_SYS_CORE+10             
2f47 3b 30			dw .THEN            
2f49 03				db 2 + 1 
2f4a .. 00			db "IF",0              
2f4d				endm 
# End of macro CWHEAD
2f4d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f4d			; 
2f4d					if DEBUG_FORTH_WORDS_KEY 
2f4d						DMARK "IF." 
2f4d f5				push af  
2f4e 3a 62 2f			ld a, (.dmark)  
2f51 32 6e fb			ld (debug_mark),a  
2f54 3a 63 2f			ld a, (.dmark+1)  
2f57 32 6f fb			ld (debug_mark+1),a  
2f5a 3a 64 2f			ld a, (.dmark+2)  
2f5d 32 70 fb			ld (debug_mark+2),a  
2f60 18 03			jr .pastdmark  
2f62 ..			.dmark: db "IF."  
2f65 f1			.pastdmark: pop af  
2f66			endm  
# End of macro DMARK
2f66						CALLMONITOR 
2f66 cd 6a 17			call break_point_state  
2f69				endm  
# End of macro CALLMONITOR
2f69					endif 
2f69			; eval TOS 
2f69			 
2f69				FORTH_DSP_VALUEHL 
2f69 cd f1 1e			call macro_dsp_valuehl 
2f6c				endm 
# End of macro FORTH_DSP_VALUEHL
2f6c			 
2f6c			;	push hl 
2f6c				FORTH_DSP_POP 
2f6c cd a9 1f			call macro_forth_dsp_pop 
2f6f				endm 
# End of macro FORTH_DSP_POP
2f6f			;	pop hl 
2f6f			 
2f6f					if DEBUG_FORTH_WORDS 
2f6f						DMARK "IF1" 
2f6f f5				push af  
2f70 3a 84 2f			ld a, (.dmark)  
2f73 32 6e fb			ld (debug_mark),a  
2f76 3a 85 2f			ld a, (.dmark+1)  
2f79 32 6f fb			ld (debug_mark+1),a  
2f7c 3a 86 2f			ld a, (.dmark+2)  
2f7f 32 70 fb			ld (debug_mark+2),a  
2f82 18 03			jr .pastdmark  
2f84 ..			.dmark: db "IF1"  
2f87 f1			.pastdmark: pop af  
2f88			endm  
# End of macro DMARK
2f88						CALLMONITOR 
2f88 cd 6a 17			call break_point_state  
2f8b				endm  
# End of macro CALLMONITOR
2f8b					endif 
2f8b b7				or a        ; clear carry flag 
2f8c 11 00 00			ld de, 0 
2f8f eb				ex de,hl 
2f90 ed 52			sbc hl, de 
2f92 c2 1c 30			jp nz, .iftrue 
2f95			 
2f95					if DEBUG_FORTH_WORDS 
2f95						DMARK "IF2" 
2f95 f5				push af  
2f96 3a aa 2f			ld a, (.dmark)  
2f99 32 6e fb			ld (debug_mark),a  
2f9c 3a ab 2f			ld a, (.dmark+1)  
2f9f 32 6f fb			ld (debug_mark+1),a  
2fa2 3a ac 2f			ld a, (.dmark+2)  
2fa5 32 70 fb			ld (debug_mark+2),a  
2fa8 18 03			jr .pastdmark  
2faa ..			.dmark: db "IF2"  
2fad f1			.pastdmark: pop af  
2fae			endm  
# End of macro DMARK
2fae						CALLMONITOR 
2fae cd 6a 17			call break_point_state  
2fb1				endm  
# End of macro CALLMONITOR
2fb1					endif 
2fb1			 
2fb1			; if not true then skip to THEN 
2fb1			 
2fb1				; TODO get tok_ptr 
2fb1				; TODO consume toks until we get to THEN 
2fb1			 
2fb1 2a 15 f1			ld hl, (os_tok_ptr) 
2fb4					if DEBUG_FORTH_WORDS 
2fb4						DMARK "IF3" 
2fb4 f5				push af  
2fb5 3a c9 2f			ld a, (.dmark)  
2fb8 32 6e fb			ld (debug_mark),a  
2fbb 3a ca 2f			ld a, (.dmark+1)  
2fbe 32 6f fb			ld (debug_mark+1),a  
2fc1 3a cb 2f			ld a, (.dmark+2)  
2fc4 32 70 fb			ld (debug_mark+2),a  
2fc7 18 03			jr .pastdmark  
2fc9 ..			.dmark: db "IF3"  
2fcc f1			.pastdmark: pop af  
2fcd			endm  
# End of macro DMARK
2fcd						CALLMONITOR 
2fcd cd 6a 17			call break_point_state  
2fd0				endm  
# End of macro CALLMONITOR
2fd0						 
2fd0					endif 
2fd0 11 17 30			ld de, .ifthen 
2fd3					if DEBUG_FORTH_WORDS 
2fd3						DMARK "IF4" 
2fd3 f5				push af  
2fd4 3a e8 2f			ld a, (.dmark)  
2fd7 32 6e fb			ld (debug_mark),a  
2fda 3a e9 2f			ld a, (.dmark+1)  
2fdd 32 6f fb			ld (debug_mark+1),a  
2fe0 3a ea 2f			ld a, (.dmark+2)  
2fe3 32 70 fb			ld (debug_mark+2),a  
2fe6 18 03			jr .pastdmark  
2fe8 ..			.dmark: db "IF4"  
2feb f1			.pastdmark: pop af  
2fec			endm  
# End of macro DMARK
2fec						CALLMONITOR 
2fec cd 6a 17			call break_point_state  
2fef				endm  
# End of macro CALLMONITOR
2fef					endif 
2fef cd 7e 21			call findnexttok  
2ff2			 
2ff2					if DEBUG_FORTH_WORDS 
2ff2						DMARK "IF5" 
2ff2 f5				push af  
2ff3 3a 07 30			ld a, (.dmark)  
2ff6 32 6e fb			ld (debug_mark),a  
2ff9 3a 08 30			ld a, (.dmark+1)  
2ffc 32 6f fb			ld (debug_mark+1),a  
2fff 3a 09 30			ld a, (.dmark+2)  
3002 32 70 fb			ld (debug_mark+2),a  
3005 18 03			jr .pastdmark  
3007 ..			.dmark: db "IF5"  
300a f1			.pastdmark: pop af  
300b			endm  
# End of macro DMARK
300b						CALLMONITOR 
300b cd 6a 17			call break_point_state  
300e				endm  
# End of macro CALLMONITOR
300e					endif 
300e				; TODO replace below with ; exec using tok_ptr 
300e 22 15 f1			ld (os_tok_ptr), hl 
3011 c3 f4 20			jp exec1 
3014				NEXTW 
3014 c3 63 20			jp macro_next 
3017				endm 
# End of macro NEXTW
3017			 
3017 .. 00		.ifthen:  db "THEN",0 
301c			 
301c			.iftrue:		 
301c				; Exec next words normally 
301c			 
301c				; if true then exec following IF as normal 
301c					if DEBUG_FORTH_WORDS 
301c						DMARK "IFT" 
301c f5				push af  
301d 3a 31 30			ld a, (.dmark)  
3020 32 6e fb			ld (debug_mark),a  
3023 3a 32 30			ld a, (.dmark+1)  
3026 32 6f fb			ld (debug_mark+1),a  
3029 3a 33 30			ld a, (.dmark+2)  
302c 32 70 fb			ld (debug_mark+2),a  
302f 18 03			jr .pastdmark  
3031 ..			.dmark: db "IFT"  
3034 f1			.pastdmark: pop af  
3035			endm  
# End of macro DMARK
3035						CALLMONITOR 
3035 cd 6a 17			call break_point_state  
3038				endm  
# End of macro CALLMONITOR
3038					endif 
3038			 
3038					NEXTW 
3038 c3 63 20			jp macro_next 
303b				endm 
# End of macro NEXTW
303b			.THEN: 
303b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
303b 1f				db WORD_SYS_CORE+11             
303c 63 30			dw .ELSE            
303e 05				db 4 + 1 
303f .. 00			db "THEN",0              
3044				endm 
# End of macro CWHEAD
3044			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3044					if DEBUG_FORTH_WORDS_KEY 
3044						DMARK "THN" 
3044 f5				push af  
3045 3a 59 30			ld a, (.dmark)  
3048 32 6e fb			ld (debug_mark),a  
304b 3a 5a 30			ld a, (.dmark+1)  
304e 32 6f fb			ld (debug_mark+1),a  
3051 3a 5b 30			ld a, (.dmark+2)  
3054 32 70 fb			ld (debug_mark+2),a  
3057 18 03			jr .pastdmark  
3059 ..			.dmark: db "THN"  
305c f1			.pastdmark: pop af  
305d			endm  
# End of macro DMARK
305d						CALLMONITOR 
305d cd 6a 17			call break_point_state  
3060				endm  
# End of macro CALLMONITOR
3060					endif 
3060					NEXTW 
3060 c3 63 20			jp macro_next 
3063				endm 
# End of macro NEXTW
3063			.ELSE: 
3063				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3063 20				db WORD_SYS_CORE+12             
3064 8b 30			dw .DO            
3066 03				db 2 + 1 
3067 .. 00			db "ELSE",0              
306c				endm 
# End of macro CWHEAD
306c			; | ELSE ( -- ) Not supported - does nothing | TODO 
306c			 
306c					if DEBUG_FORTH_WORDS_KEY 
306c						DMARK "ELS" 
306c f5				push af  
306d 3a 81 30			ld a, (.dmark)  
3070 32 6e fb			ld (debug_mark),a  
3073 3a 82 30			ld a, (.dmark+1)  
3076 32 6f fb			ld (debug_mark+1),a  
3079 3a 83 30			ld a, (.dmark+2)  
307c 32 70 fb			ld (debug_mark+2),a  
307f 18 03			jr .pastdmark  
3081 ..			.dmark: db "ELS"  
3084 f1			.pastdmark: pop af  
3085			endm  
# End of macro DMARK
3085						CALLMONITOR 
3085 cd 6a 17			call break_point_state  
3088				endm  
# End of macro CALLMONITOR
3088					endif 
3088			 
3088			 
3088					NEXTW 
3088 c3 63 20			jp macro_next 
308b				endm 
# End of macro NEXTW
308b			.DO: 
308b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
308b 21				db WORD_SYS_CORE+13             
308c b2 31			dw .LOOP            
308e 03				db 2 + 1 
308f .. 00			db "DO",0              
3092				endm 
# End of macro CWHEAD
3092			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3092			 
3092					if DEBUG_FORTH_WORDS_KEY 
3092						DMARK "DO." 
3092 f5				push af  
3093 3a a7 30			ld a, (.dmark)  
3096 32 6e fb			ld (debug_mark),a  
3099 3a a8 30			ld a, (.dmark+1)  
309c 32 6f fb			ld (debug_mark+1),a  
309f 3a a9 30			ld a, (.dmark+2)  
30a2 32 70 fb			ld (debug_mark+2),a  
30a5 18 03			jr .pastdmark  
30a7 ..			.dmark: db "DO."  
30aa f1			.pastdmark: pop af  
30ab			endm  
# End of macro DMARK
30ab						CALLMONITOR 
30ab cd 6a 17			call break_point_state  
30ae				endm  
# End of macro CALLMONITOR
30ae					endif 
30ae			;  push pc to rsp stack past the DO 
30ae			 
30ae 2a 15 f1				ld hl, (os_tok_ptr) 
30b1 23					inc hl   ; D 
30b2 23					inc hl  ; O 
30b3 23					inc hl   ; null 
30b4					if DEBUG_FORTH_WORDS 
30b4						DMARK "DO2" 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 6e fb			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 6f fb			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 70 fb			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "DO2"  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd						CALLMONITOR 
30cd cd 6a 17			call break_point_state  
30d0				endm  
# End of macro CALLMONITOR
30d0					endif 
30d0					FORTH_RSP_NEXT 
30d0 cd a1 1c			call macro_forth_rsp_next 
30d3				endm 
# End of macro FORTH_RSP_NEXT
30d3					if DEBUG_FORTH_WORDS 
30d3						DMARK "DO3" 
30d3 f5				push af  
30d4 3a e8 30			ld a, (.dmark)  
30d7 32 6e fb			ld (debug_mark),a  
30da 3a e9 30			ld a, (.dmark+1)  
30dd 32 6f fb			ld (debug_mark+1),a  
30e0 3a ea 30			ld a, (.dmark+2)  
30e3 32 70 fb			ld (debug_mark+2),a  
30e6 18 03			jr .pastdmark  
30e8 ..			.dmark: db "DO3"  
30eb f1			.pastdmark: pop af  
30ec			endm  
# End of macro DMARK
30ec						CALLMONITOR 
30ec cd 6a 17			call break_point_state  
30ef				endm  
# End of macro CALLMONITOR
30ef					endif 
30ef			 
30ef					;if DEBUG_FORTH_WORDS 
30ef				;		push hl 
30ef			;		endif  
30ef			 
30ef			; get counters from data stack 
30ef			 
30ef			 
30ef					FORTH_DSP_VALUEHL 
30ef cd f1 1e			call macro_dsp_valuehl 
30f2				endm 
# End of macro FORTH_DSP_VALUEHL
30f2 e5					push hl		 ; hl now has starting counter which needs to be tos 
30f3			 
30f3					if DEBUG_FORTH_WORDS 
30f3						DMARK "DO4" 
30f3 f5				push af  
30f4 3a 08 31			ld a, (.dmark)  
30f7 32 6e fb			ld (debug_mark),a  
30fa 3a 09 31			ld a, (.dmark+1)  
30fd 32 6f fb			ld (debug_mark+1),a  
3100 3a 0a 31			ld a, (.dmark+2)  
3103 32 70 fb			ld (debug_mark+2),a  
3106 18 03			jr .pastdmark  
3108 ..			.dmark: db "DO4"  
310b f1			.pastdmark: pop af  
310c			endm  
# End of macro DMARK
310c						CALLMONITOR 
310c cd 6a 17			call break_point_state  
310f				endm  
# End of macro CALLMONITOR
310f					endif 
310f					FORTH_DSP_POP 
310f cd a9 1f			call macro_forth_dsp_pop 
3112				endm 
# End of macro FORTH_DSP_POP
3112			 
3112					if DEBUG_FORTH_WORDS 
3112						DMARK "DO5" 
3112 f5				push af  
3113 3a 27 31			ld a, (.dmark)  
3116 32 6e fb			ld (debug_mark),a  
3119 3a 28 31			ld a, (.dmark+1)  
311c 32 6f fb			ld (debug_mark+1),a  
311f 3a 29 31			ld a, (.dmark+2)  
3122 32 70 fb			ld (debug_mark+2),a  
3125 18 03			jr .pastdmark  
3127 ..			.dmark: db "DO5"  
312a f1			.pastdmark: pop af  
312b			endm  
# End of macro DMARK
312b						CALLMONITOR 
312b cd 6a 17			call break_point_state  
312e				endm  
# End of macro CALLMONITOR
312e					endif 
312e			 
312e					FORTH_DSP_VALUEHL 
312e cd f1 1e			call macro_dsp_valuehl 
3131				endm 
# End of macro FORTH_DSP_VALUEHL
3131			;		push hl		 ; hl now has starting limit counter 
3131			 
3131					if DEBUG_FORTH_WORDS 
3131						DMARK "DO6" 
3131 f5				push af  
3132 3a 46 31			ld a, (.dmark)  
3135 32 6e fb			ld (debug_mark),a  
3138 3a 47 31			ld a, (.dmark+1)  
313b 32 6f fb			ld (debug_mark+1),a  
313e 3a 48 31			ld a, (.dmark+2)  
3141 32 70 fb			ld (debug_mark+2),a  
3144 18 03			jr .pastdmark  
3146 ..			.dmark: db "DO6"  
3149 f1			.pastdmark: pop af  
314a			endm  
# End of macro DMARK
314a						CALLMONITOR 
314a cd 6a 17			call break_point_state  
314d				endm  
# End of macro CALLMONITOR
314d					endif 
314d					FORTH_DSP_POP 
314d cd a9 1f			call macro_forth_dsp_pop 
3150				endm 
# End of macro FORTH_DSP_POP
3150			 
3150			; put counters on the loop stack 
3150			 
3150			;		pop hl			 ; limit counter 
3150 d1					pop de			; start counter 
3151			 
3151					; push limit counter 
3151			 
3151					if DEBUG_FORTH_WORDS 
3151						DMARK "DO7" 
3151 f5				push af  
3152 3a 66 31			ld a, (.dmark)  
3155 32 6e fb			ld (debug_mark),a  
3158 3a 67 31			ld a, (.dmark+1)  
315b 32 6f fb			ld (debug_mark+1),a  
315e 3a 68 31			ld a, (.dmark+2)  
3161 32 70 fb			ld (debug_mark+2),a  
3164 18 03			jr .pastdmark  
3166 ..			.dmark: db "DO7"  
3169 f1			.pastdmark: pop af  
316a			endm  
# End of macro DMARK
316a						CALLMONITOR 
316a cd 6a 17			call break_point_state  
316d				endm  
# End of macro CALLMONITOR
316d					endif 
316d					FORTH_LOOP_NEXT 
316d cd 22 1f			call macro_forth_loop_next 
3170				endm 
# End of macro FORTH_LOOP_NEXT
3170			 
3170					; push start counter 
3170			 
3170 eb					ex de, hl 
3171					if DEBUG_FORTH_WORDS 
3171						DMARK "DO7" 
3171 f5				push af  
3172 3a 86 31			ld a, (.dmark)  
3175 32 6e fb			ld (debug_mark),a  
3178 3a 87 31			ld a, (.dmark+1)  
317b 32 6f fb			ld (debug_mark+1),a  
317e 3a 88 31			ld a, (.dmark+2)  
3181 32 70 fb			ld (debug_mark+2),a  
3184 18 03			jr .pastdmark  
3186 ..			.dmark: db "DO7"  
3189 f1			.pastdmark: pop af  
318a			endm  
# End of macro DMARK
318a						CALLMONITOR 
318a cd 6a 17			call break_point_state  
318d				endm  
# End of macro CALLMONITOR
318d					endif 
318d					FORTH_LOOP_NEXT 
318d cd 22 1f			call macro_forth_loop_next 
3190				endm 
# End of macro FORTH_LOOP_NEXT
3190			 
3190			 
3190					; init first round of I counter 
3190			 
3190 22 39 f1				ld (os_current_i), hl 
3193			 
3193					if DEBUG_FORTH_WORDS 
3193						DMARK "DO8" 
3193 f5				push af  
3194 3a a8 31			ld a, (.dmark)  
3197 32 6e fb			ld (debug_mark),a  
319a 3a a9 31			ld a, (.dmark+1)  
319d 32 6f fb			ld (debug_mark+1),a  
31a0 3a aa 31			ld a, (.dmark+2)  
31a3 32 70 fb			ld (debug_mark+2),a  
31a6 18 03			jr .pastdmark  
31a8 ..			.dmark: db "DO8"  
31ab f1			.pastdmark: pop af  
31ac			endm  
# End of macro DMARK
31ac						CALLMONITOR 
31ac cd 6a 17			call break_point_state  
31af				endm  
# End of macro CALLMONITOR
31af					endif 
31af			 
31af					NEXTW 
31af c3 63 20			jp macro_next 
31b2				endm 
# End of macro NEXTW
31b2			.LOOP: 
31b2				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31b2 22				db WORD_SYS_CORE+14             
31b3 ca 32			dw .I            
31b5 05				db 4 + 1 
31b6 .. 00			db "LOOP",0              
31bb				endm 
# End of macro CWHEAD
31bb			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31bb			 
31bb				; pop tos as current loop count to hl 
31bb			 
31bb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31bb			 
31bb				FORTH_LOOP_TOS 
31bb cd 55 1f			call macro_forth_loop_tos 
31be				endm 
# End of macro FORTH_LOOP_TOS
31be e5				push hl 
31bf			 
31bf					if DEBUG_FORTH_WORDS_KEY 
31bf						DMARK "LOP" 
31bf f5				push af  
31c0 3a d4 31			ld a, (.dmark)  
31c3 32 6e fb			ld (debug_mark),a  
31c6 3a d5 31			ld a, (.dmark+1)  
31c9 32 6f fb			ld (debug_mark+1),a  
31cc 3a d6 31			ld a, (.dmark+2)  
31cf 32 70 fb			ld (debug_mark+2),a  
31d2 18 03			jr .pastdmark  
31d4 ..			.dmark: db "LOP"  
31d7 f1			.pastdmark: pop af  
31d8			endm  
# End of macro DMARK
31d8						CALLMONITOR 
31d8 cd 6a 17			call break_point_state  
31db				endm  
# End of macro CALLMONITOR
31db					endif 
31db				; next item on the stack is the limit. get it 
31db			 
31db			 
31db				FORTH_LOOP_POP 
31db cd 5f 1f			call macro_forth_loop_pop 
31de				endm 
# End of macro FORTH_LOOP_POP
31de			 
31de				FORTH_LOOP_TOS 
31de cd 55 1f			call macro_forth_loop_tos 
31e1				endm 
# End of macro FORTH_LOOP_TOS
31e1			 
31e1 d1				pop de		 ; de = i, hl = limit 
31e2			 
31e2					if DEBUG_FORTH_WORDS 
31e2						DMARK "LP1" 
31e2 f5				push af  
31e3 3a f7 31			ld a, (.dmark)  
31e6 32 6e fb			ld (debug_mark),a  
31e9 3a f8 31			ld a, (.dmark+1)  
31ec 32 6f fb			ld (debug_mark+1),a  
31ef 3a f9 31			ld a, (.dmark+2)  
31f2 32 70 fb			ld (debug_mark+2),a  
31f5 18 03			jr .pastdmark  
31f7 ..			.dmark: db "LP1"  
31fa f1			.pastdmark: pop af  
31fb			endm  
# End of macro DMARK
31fb						CALLMONITOR 
31fb cd 6a 17			call break_point_state  
31fe				endm  
# End of macro CALLMONITOR
31fe					endif 
31fe			 
31fe				; go back to previous word 
31fe			 
31fe d5				push de    ; save I for inc later 
31ff			 
31ff			 
31ff				; get limit 
31ff				;  is I at limit? 
31ff			 
31ff			 
31ff					if DEBUG_FORTH_WORDS 
31ff						DMARK "LP1" 
31ff f5				push af  
3200 3a 14 32			ld a, (.dmark)  
3203 32 6e fb			ld (debug_mark),a  
3206 3a 15 32			ld a, (.dmark+1)  
3209 32 6f fb			ld (debug_mark+1),a  
320c 3a 16 32			ld a, (.dmark+2)  
320f 32 70 fb			ld (debug_mark+2),a  
3212 18 03			jr .pastdmark  
3214 ..			.dmark: db "LP1"  
3217 f1			.pastdmark: pop af  
3218			endm  
# End of macro DMARK
3218						CALLMONITOR 
3218 cd 6a 17			call break_point_state  
321b				endm  
# End of macro CALLMONITOR
321b					endif 
321b			 
321b ed 52			sbc hl, de 
321d			 
321d			 
321d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
321d			 
321d 20 26				jr nz, .loopnotdone 
321f			 
321f e1				pop hl   ; get rid of saved I 
3220				FORTH_LOOP_POP     ; get rid of limit 
3220 cd 5f 1f			call macro_forth_loop_pop 
3223				endm 
# End of macro FORTH_LOOP_POP
3223			 
3223				FORTH_RSP_POP     ; get rid of DO ptr 
3223 cd c2 1c			call macro_forth_rsp_pop 
3226				endm 
# End of macro FORTH_RSP_POP
3226			 
3226			if DEBUG_FORTH_WORDS 
3226						DMARK "LP>" 
3226 f5				push af  
3227 3a 3b 32			ld a, (.dmark)  
322a 32 6e fb			ld (debug_mark),a  
322d 3a 3c 32			ld a, (.dmark+1)  
3230 32 6f fb			ld (debug_mark+1),a  
3233 3a 3d 32			ld a, (.dmark+2)  
3236 32 70 fb			ld (debug_mark+2),a  
3239 18 03			jr .pastdmark  
323b ..			.dmark: db "LP>"  
323e f1			.pastdmark: pop af  
323f			endm  
# End of macro DMARK
323f				CALLMONITOR 
323f cd 6a 17			call break_point_state  
3242				endm  
# End of macro CALLMONITOR
3242			endif 
3242			 
3242					NEXTW 
3242 c3 63 20			jp macro_next 
3245				endm 
# End of macro NEXTW
3245				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3245			 
3245			.loopnotdone: 
3245			 
3245 e1				pop hl    ; get I 
3246 23				inc hl 
3247			 
3247			   	; save new I 
3247			 
3247			 
3247					; set I counter 
3247			 
3247 22 39 f1				ld (os_current_i), hl 
324a			 
324a					if DEBUG_FORTH_WORDS 
324a						DMARK "LPN" 
324a f5				push af  
324b 3a 5f 32			ld a, (.dmark)  
324e 32 6e fb			ld (debug_mark),a  
3251 3a 60 32			ld a, (.dmark+1)  
3254 32 6f fb			ld (debug_mark+1),a  
3257 3a 61 32			ld a, (.dmark+2)  
325a 32 70 fb			ld (debug_mark+2),a  
325d 18 03			jr .pastdmark  
325f ..			.dmark: db "LPN"  
3262 f1			.pastdmark: pop af  
3263			endm  
# End of macro DMARK
3263					CALLMONITOR 
3263 cd 6a 17			call break_point_state  
3266				endm  
# End of macro CALLMONITOR
3266					endif 
3266					 
3266				FORTH_LOOP_NEXT 
3266 cd 22 1f			call macro_forth_loop_next 
3269				endm 
# End of macro FORTH_LOOP_NEXT
3269			 
3269			 
3269					if DEBUG_FORTH_WORDS 
3269 eb						ex de,hl 
326a					endif 
326a			 
326a			;	; get DO ptr 
326a			; 
326a					if DEBUG_FORTH_WORDS 
326a						DMARK "LP7" 
326a f5				push af  
326b 3a 7f 32			ld a, (.dmark)  
326e 32 6e fb			ld (debug_mark),a  
3271 3a 80 32			ld a, (.dmark+1)  
3274 32 6f fb			ld (debug_mark+1),a  
3277 3a 81 32			ld a, (.dmark+2)  
327a 32 70 fb			ld (debug_mark+2),a  
327d 18 03			jr .pastdmark  
327f ..			.dmark: db "LP7"  
3282 f1			.pastdmark: pop af  
3283			endm  
# End of macro DMARK
3283					CALLMONITOR 
3283 cd 6a 17			call break_point_state  
3286				endm  
# End of macro CALLMONITOR
3286					endif 
3286				FORTH_RSP_TOS 
3286 cd b8 1c			call macro_forth_rsp_tos 
3289				endm 
# End of macro FORTH_RSP_TOS
3289			 
3289					if DEBUG_FORTH_WORDS 
3289						DMARK "LP8" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 6e fb			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 6f fb			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 70 fb			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "LP8"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2					CALLMONITOR 
32a2 cd 6a 17			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5				;push hl 
32a5			 
32a5				; not going to DO any more 
32a5				; get rid of the RSP pointer as DO will add it back in 
32a5				;FORTH_RSP_POP 
32a5				;pop hl 
32a5			 
32a5				;ld hl,(cli_ret_sp) 
32a5				;ld e, (hl) 
32a5				;inc hl 
32a5				;ld d, (hl) 
32a5				;ex de,hl 
32a5 22 15 f1			ld (os_tok_ptr), hl 
32a8					if DEBUG_FORTH_WORDS 
32a8						DMARK "LP<" 
32a8 f5				push af  
32a9 3a bd 32			ld a, (.dmark)  
32ac 32 6e fb			ld (debug_mark),a  
32af 3a be 32			ld a, (.dmark+1)  
32b2 32 6f fb			ld (debug_mark+1),a  
32b5 3a bf 32			ld a, (.dmark+2)  
32b8 32 70 fb			ld (debug_mark+2),a  
32bb 18 03			jr .pastdmark  
32bd ..			.dmark: db "LP<"  
32c0 f1			.pastdmark: pop af  
32c1			endm  
# End of macro DMARK
32c1					CALLMONITOR 
32c1 cd 6a 17			call break_point_state  
32c4				endm  
# End of macro CALLMONITOR
32c4				endif 
32c4 c3 f4 20			jp exec1 
32c7			 
32c7					 
32c7			 
32c7			 
32c7					NEXTW 
32c7 c3 63 20			jp macro_next 
32ca				endm 
# End of macro NEXTW
32ca			.I:  
32ca			 
32ca				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32ca 5e				db WORD_SYS_CORE+74             
32cb f5 32			dw .DLOOP            
32cd 02				db 1 + 1 
32ce .. 00			db "I",0              
32d0				endm 
# End of macro CWHEAD
32d0			; | I ( -- ) Current loop counter | DONE 
32d0					if DEBUG_FORTH_WORDS_KEY 
32d0						DMARK "I.." 
32d0 f5				push af  
32d1 3a e5 32			ld a, (.dmark)  
32d4 32 6e fb			ld (debug_mark),a  
32d7 3a e6 32			ld a, (.dmark+1)  
32da 32 6f fb			ld (debug_mark+1),a  
32dd 3a e7 32			ld a, (.dmark+2)  
32e0 32 70 fb			ld (debug_mark+2),a  
32e3 18 03			jr .pastdmark  
32e5 ..			.dmark: db "I.."  
32e8 f1			.pastdmark: pop af  
32e9			endm  
# End of macro DMARK
32e9						CALLMONITOR 
32e9 cd 6a 17			call break_point_state  
32ec				endm  
# End of macro CALLMONITOR
32ec					endif 
32ec			 
32ec 2a 39 f1				ld hl,(os_current_i) 
32ef cd fa 1c				call forth_push_numhl 
32f2			 
32f2					NEXTW 
32f2 c3 63 20			jp macro_next 
32f5				endm 
# End of macro NEXTW
32f5			.DLOOP: 
32f5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32f5 5f				db WORD_SYS_CORE+75             
32f6 d6 33			dw .REPEAT            
32f8 06				db 5 + 1 
32f9 .. 00			db "-LOOP",0              
32ff				endm 
# End of macro CWHEAD
32ff			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32ff				; pop tos as current loop count to hl 
32ff					if DEBUG_FORTH_WORDS_KEY 
32ff						DMARK "-LP" 
32ff f5				push af  
3300 3a 14 33			ld a, (.dmark)  
3303 32 6e fb			ld (debug_mark),a  
3306 3a 15 33			ld a, (.dmark+1)  
3309 32 6f fb			ld (debug_mark+1),a  
330c 3a 16 33			ld a, (.dmark+2)  
330f 32 70 fb			ld (debug_mark+2),a  
3312 18 03			jr .pastdmark  
3314 ..			.dmark: db "-LP"  
3317 f1			.pastdmark: pop af  
3318			endm  
# End of macro DMARK
3318						CALLMONITOR 
3318 cd 6a 17			call break_point_state  
331b				endm  
# End of macro CALLMONITOR
331b					endif 
331b			 
331b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
331b			 
331b				FORTH_LOOP_TOS 
331b cd 55 1f			call macro_forth_loop_tos 
331e				endm 
# End of macro FORTH_LOOP_TOS
331e e5				push hl 
331f			 
331f					if DEBUG_FORTH_WORDS 
331f						DMARK "-LP" 
331f f5				push af  
3320 3a 34 33			ld a, (.dmark)  
3323 32 6e fb			ld (debug_mark),a  
3326 3a 35 33			ld a, (.dmark+1)  
3329 32 6f fb			ld (debug_mark+1),a  
332c 3a 36 33			ld a, (.dmark+2)  
332f 32 70 fb			ld (debug_mark+2),a  
3332 18 03			jr .pastdmark  
3334 ..			.dmark: db "-LP"  
3337 f1			.pastdmark: pop af  
3338			endm  
# End of macro DMARK
3338						CALLMONITOR 
3338 cd 6a 17			call break_point_state  
333b				endm  
# End of macro CALLMONITOR
333b					endif 
333b				; next item on the stack is the limit. get it 
333b			 
333b			 
333b				FORTH_LOOP_POP 
333b cd 5f 1f			call macro_forth_loop_pop 
333e				endm 
# End of macro FORTH_LOOP_POP
333e			 
333e				FORTH_LOOP_TOS 
333e cd 55 1f			call macro_forth_loop_tos 
3341				endm 
# End of macro FORTH_LOOP_TOS
3341			 
3341 d1				pop de		 ; de = i, hl = limit 
3342			 
3342					if DEBUG_FORTH_WORDS 
3342						DMARK "-L1" 
3342 f5				push af  
3343 3a 57 33			ld a, (.dmark)  
3346 32 6e fb			ld (debug_mark),a  
3349 3a 58 33			ld a, (.dmark+1)  
334c 32 6f fb			ld (debug_mark+1),a  
334f 3a 59 33			ld a, (.dmark+2)  
3352 32 70 fb			ld (debug_mark+2),a  
3355 18 03			jr .pastdmark  
3357 ..			.dmark: db "-L1"  
335a f1			.pastdmark: pop af  
335b			endm  
# End of macro DMARK
335b						CALLMONITOR 
335b cd 6a 17			call break_point_state  
335e				endm  
# End of macro CALLMONITOR
335e					endif 
335e			 
335e				; go back to previous word 
335e			 
335e d5				push de    ; save I for inc later 
335f			 
335f			 
335f				; get limit 
335f				;  is I at limit? 
335f			 
335f			 
335f					if DEBUG_FORTH_WORDS 
335f						DMARK "-L1" 
335f f5				push af  
3360 3a 74 33			ld a, (.dmark)  
3363 32 6e fb			ld (debug_mark),a  
3366 3a 75 33			ld a, (.dmark+1)  
3369 32 6f fb			ld (debug_mark+1),a  
336c 3a 76 33			ld a, (.dmark+2)  
336f 32 70 fb			ld (debug_mark+2),a  
3372 18 03			jr .pastdmark  
3374 ..			.dmark: db "-L1"  
3377 f1			.pastdmark: pop af  
3378			endm  
# End of macro DMARK
3378						CALLMONITOR 
3378 cd 6a 17			call break_point_state  
337b				endm  
# End of macro CALLMONITOR
337b					endif 
337b			 
337b ed 52			sbc hl, de 
337d			 
337d			 
337d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
337d			 
337d 20 26				jr nz, .mloopnotdone 
337f			 
337f e1				pop hl   ; get rid of saved I 
3380				FORTH_LOOP_POP     ; get rid of limit 
3380 cd 5f 1f			call macro_forth_loop_pop 
3383				endm 
# End of macro FORTH_LOOP_POP
3383			 
3383				FORTH_RSP_POP     ; get rid of DO ptr 
3383 cd c2 1c			call macro_forth_rsp_pop 
3386				endm 
# End of macro FORTH_RSP_POP
3386			 
3386			if DEBUG_FORTH_WORDS 
3386						DMARK "-L>" 
3386 f5				push af  
3387 3a 9b 33			ld a, (.dmark)  
338a 32 6e fb			ld (debug_mark),a  
338d 3a 9c 33			ld a, (.dmark+1)  
3390 32 6f fb			ld (debug_mark+1),a  
3393 3a 9d 33			ld a, (.dmark+2)  
3396 32 70 fb			ld (debug_mark+2),a  
3399 18 03			jr .pastdmark  
339b ..			.dmark: db "-L>"  
339e f1			.pastdmark: pop af  
339f			endm  
# End of macro DMARK
339f				CALLMONITOR 
339f cd 6a 17			call break_point_state  
33a2				endm  
# End of macro CALLMONITOR
33a2			endif 
33a2			 
33a2					NEXTW 
33a2 c3 63 20			jp macro_next 
33a5				endm 
# End of macro NEXTW
33a5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33a5			 
33a5			.mloopnotdone: 
33a5			 
33a5 e1				pop hl    ; get I 
33a6 2b				dec hl 
33a7			 
33a7			   	; save new I 
33a7			 
33a7			 
33a7					; set I counter 
33a7			 
33a7 22 39 f1				ld (os_current_i), hl 
33aa			 
33aa					 
33aa				FORTH_LOOP_NEXT 
33aa cd 22 1f			call macro_forth_loop_next 
33ad				endm 
# End of macro FORTH_LOOP_NEXT
33ad			 
33ad			 
33ad					if DEBUG_FORTH_WORDS 
33ad eb						ex de,hl 
33ae					endif 
33ae			 
33ae			;	; get DO ptr 
33ae			; 
33ae				FORTH_RSP_TOS 
33ae cd b8 1c			call macro_forth_rsp_tos 
33b1				endm 
# End of macro FORTH_RSP_TOS
33b1			 
33b1				;push hl 
33b1			 
33b1				; not going to DO any more 
33b1				; get rid of the RSP pointer as DO will add it back in 
33b1				;FORTH_RSP_POP 
33b1				;pop hl 
33b1			 
33b1			 
33b1 22 15 f1			ld (os_tok_ptr), hl 
33b4					if DEBUG_FORTH_WORDS 
33b4						DMARK "-L<" 
33b4 f5				push af  
33b5 3a c9 33			ld a, (.dmark)  
33b8 32 6e fb			ld (debug_mark),a  
33bb 3a ca 33			ld a, (.dmark+1)  
33be 32 6f fb			ld (debug_mark+1),a  
33c1 3a cb 33			ld a, (.dmark+2)  
33c4 32 70 fb			ld (debug_mark+2),a  
33c7 18 03			jr .pastdmark  
33c9 ..			.dmark: db "-L<"  
33cc f1			.pastdmark: pop af  
33cd			endm  
# End of macro DMARK
33cd					CALLMONITOR 
33cd cd 6a 17			call break_point_state  
33d0				endm  
# End of macro CALLMONITOR
33d0				endif 
33d0 c3 f4 20			jp exec1 
33d3			 
33d3					 
33d3			 
33d3			 
33d3			 
33d3				NEXTW 
33d3 c3 63 20			jp macro_next 
33d6				endm 
# End of macro NEXTW
33d6			 
33d6			 
33d6			 
33d6			 
33d6			.REPEAT: 
33d6				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33d6 71				db WORD_SYS_CORE+93             
33d7 29 34			dw .UNTIL            
33d9 06				db 5 + 1 
33da .. 00			db "REPEAT",0              
33e1				endm 
# End of macro CWHEAD
33e1			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33e1			;  push pc to rsp stack past the REPEAT 
33e1					if DEBUG_FORTH_WORDS_KEY 
33e1						DMARK "REP" 
33e1 f5				push af  
33e2 3a f6 33			ld a, (.dmark)  
33e5 32 6e fb			ld (debug_mark),a  
33e8 3a f7 33			ld a, (.dmark+1)  
33eb 32 6f fb			ld (debug_mark+1),a  
33ee 3a f8 33			ld a, (.dmark+2)  
33f1 32 70 fb			ld (debug_mark+2),a  
33f4 18 03			jr .pastdmark  
33f6 ..			.dmark: db "REP"  
33f9 f1			.pastdmark: pop af  
33fa			endm  
# End of macro DMARK
33fa						CALLMONITOR 
33fa cd 6a 17			call break_point_state  
33fd				endm  
# End of macro CALLMONITOR
33fd					endif 
33fd			 
33fd 2a 15 f1				ld hl, (os_tok_ptr) 
3400 23					inc hl   ; R 
3401 23					inc hl  ; E 
3402 23					inc hl   ; P 
3403 23					inc hl   ; E 
3404 23					inc hl   ; A 
3405 23					inc hl   ; T 
3406 23					inc hl   ; zero 
3407					FORTH_RSP_NEXT 
3407 cd a1 1c			call macro_forth_rsp_next 
340a				endm 
# End of macro FORTH_RSP_NEXT
340a			 
340a			 
340a					if DEBUG_FORTH_WORDS 
340a						DMARK "REP" 
340a f5				push af  
340b 3a 1f 34			ld a, (.dmark)  
340e 32 6e fb			ld (debug_mark),a  
3411 3a 20 34			ld a, (.dmark+1)  
3414 32 6f fb			ld (debug_mark+1),a  
3417 3a 21 34			ld a, (.dmark+2)  
341a 32 70 fb			ld (debug_mark+2),a  
341d 18 03			jr .pastdmark  
341f ..			.dmark: db "REP"  
3422 f1			.pastdmark: pop af  
3423			endm  
# End of macro DMARK
3423						;pop bc    ; TODO BUG ?????? what is this for???? 
3423						CALLMONITOR 
3423 cd 6a 17			call break_point_state  
3426				endm  
# End of macro CALLMONITOR
3426					endif 
3426			 
3426					NEXTW 
3426 c3 63 20			jp macro_next 
3429				endm 
# End of macro NEXTW
3429			;	       NEXTW 
3429			 
3429			.UNTIL: 
3429				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3429 72				db WORD_SYS_CORE+94             
342a c0 34			dw .ENDFLOW            
342c 06				db 5 + 1 
342d .. 00			db "UNTIL",0              
3433				endm 
# End of macro CWHEAD
3433			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3433			 
3433				; pop tos as check 
3433			 
3433				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3433			 
3433				FORTH_DSP_VALUEHL 
3433 cd f1 1e			call macro_dsp_valuehl 
3436				endm 
# End of macro FORTH_DSP_VALUEHL
3436			 
3436					if DEBUG_FORTH_WORDS_KEY 
3436						DMARK "UNT" 
3436 f5				push af  
3437 3a 4b 34			ld a, (.dmark)  
343a 32 6e fb			ld (debug_mark),a  
343d 3a 4c 34			ld a, (.dmark+1)  
3440 32 6f fb			ld (debug_mark+1),a  
3443 3a 4d 34			ld a, (.dmark+2)  
3446 32 70 fb			ld (debug_mark+2),a  
3449 18 03			jr .pastdmark  
344b ..			.dmark: db "UNT"  
344e f1			.pastdmark: pop af  
344f			endm  
# End of macro DMARK
344f						CALLMONITOR 
344f cd 6a 17			call break_point_state  
3452				endm  
# End of macro CALLMONITOR
3452					endif 
3452			 
3452			;	push hl 
3452				FORTH_DSP_POP 
3452 cd a9 1f			call macro_forth_dsp_pop 
3455				endm 
# End of macro FORTH_DSP_POP
3455			 
3455			;	pop hl 
3455			 
3455				; test if true 
3455			 
3455 cd 44 0d			call ishlzero 
3458			;	ld a,l 
3458			;	add h 
3458			; 
3458			;	cp 0 
3458			 
3458 20 3e			jr nz, .untilnotdone 
345a			 
345a					if DEBUG_FORTH_WORDS 
345a						DMARK "UNf" 
345a f5				push af  
345b 3a 6f 34			ld a, (.dmark)  
345e 32 6e fb			ld (debug_mark),a  
3461 3a 70 34			ld a, (.dmark+1)  
3464 32 6f fb			ld (debug_mark+1),a  
3467 3a 71 34			ld a, (.dmark+2)  
346a 32 70 fb			ld (debug_mark+2),a  
346d 18 03			jr .pastdmark  
346f ..			.dmark: db "UNf"  
3472 f1			.pastdmark: pop af  
3473			endm  
# End of macro DMARK
3473						CALLMONITOR 
3473 cd 6a 17			call break_point_state  
3476				endm  
# End of macro CALLMONITOR
3476					endif 
3476			 
3476			 
3476			 
3476				FORTH_RSP_POP     ; get rid of DO ptr 
3476 cd c2 1c			call macro_forth_rsp_pop 
3479				endm 
# End of macro FORTH_RSP_POP
3479			 
3479			if DEBUG_FORTH_WORDS 
3479						DMARK "UN>" 
3479 f5				push af  
347a 3a 8e 34			ld a, (.dmark)  
347d 32 6e fb			ld (debug_mark),a  
3480 3a 8f 34			ld a, (.dmark+1)  
3483 32 6f fb			ld (debug_mark+1),a  
3486 3a 90 34			ld a, (.dmark+2)  
3489 32 70 fb			ld (debug_mark+2),a  
348c 18 03			jr .pastdmark  
348e ..			.dmark: db "UN>"  
3491 f1			.pastdmark: pop af  
3492			endm  
# End of macro DMARK
3492				CALLMONITOR 
3492 cd 6a 17			call break_point_state  
3495				endm  
# End of macro CALLMONITOR
3495			endif 
3495			 
3495					NEXTW 
3495 c3 63 20			jp macro_next 
3498				endm 
# End of macro NEXTW
3498				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3498			 
3498			.untilnotdone: 
3498			 
3498			 
3498			;	; get DO ptr 
3498			; 
3498				FORTH_RSP_TOS 
3498 cd b8 1c			call macro_forth_rsp_tos 
349b				endm 
# End of macro FORTH_RSP_TOS
349b			 
349b				;push hl 
349b			 
349b				; not going to DO any more 
349b				; get rid of the RSP pointer as DO will add it back in 
349b				;FORTH_RSP_POP 
349b				;pop hl 
349b			 
349b			 
349b 22 15 f1			ld (os_tok_ptr), hl 
349e					if DEBUG_FORTH_WORDS 
349e						DMARK "UN<" 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 6e fb			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 6f fb			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 70 fb			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "UN<"  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7					CALLMONITOR 
34b7 cd 6a 17			call break_point_state  
34ba				endm  
# End of macro CALLMONITOR
34ba				endif 
34ba c3 f4 20			jp exec1 
34bd			 
34bd					 
34bd			 
34bd			 
34bd					NEXTW 
34bd c3 63 20			jp macro_next 
34c0				endm 
# End of macro NEXTW
34c0			 
34c0			 
34c0			.ENDFLOW: 
34c0			 
34c0			; eof 
34c0			 
# End of file forth_words_flow.asm
34c0			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34c0			include "forth_words_logic.asm" 
34c0			 
34c0			; | ## Logic Words 
34c0			 
34c0			.NOT: 
34c0				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34c0 2d				db WORD_SYS_CORE+25             
34c1 08 35			dw .IS            
34c3 04				db 3 + 1 
34c4 .. 00			db "NOT",0              
34c8				endm 
# End of macro CWHEAD
34c8			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34c8					if DEBUG_FORTH_WORDS_KEY 
34c8						DMARK "NOT" 
34c8 f5				push af  
34c9 3a dd 34			ld a, (.dmark)  
34cc 32 6e fb			ld (debug_mark),a  
34cf 3a de 34			ld a, (.dmark+1)  
34d2 32 6f fb			ld (debug_mark+1),a  
34d5 3a df 34			ld a, (.dmark+2)  
34d8 32 70 fb			ld (debug_mark+2),a  
34db 18 03			jr .pastdmark  
34dd ..			.dmark: db "NOT"  
34e0 f1			.pastdmark: pop af  
34e1			endm  
# End of macro DMARK
34e1						CALLMONITOR 
34e1 cd 6a 17			call break_point_state  
34e4				endm  
# End of macro CALLMONITOR
34e4					endif 
34e4					FORTH_DSP 
34e4 cd b7 1e			call macro_forth_dsp 
34e7				endm 
# End of macro FORTH_DSP
34e7 7e					ld a,(hl)	; get type of value on TOS 
34e8 fe 02				cp DS_TYPE_INUM  
34ea 28 03				jr z, .noti 
34ec					NEXTW 
34ec c3 63 20			jp macro_next 
34ef				endm 
# End of macro NEXTW
34ef			.noti:          FORTH_DSP_VALUEHL 
34ef cd f1 1e			call macro_dsp_valuehl 
34f2				endm 
# End of macro FORTH_DSP_VALUEHL
34f2			;		push hl 
34f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34f2 cd a9 1f			call macro_forth_dsp_pop 
34f5				endm 
# End of macro FORTH_DSP_POP
34f5			;		pop hl 
34f5 3e 00				ld a,0 
34f7 bd					cp l 
34f8 28 04				jr z, .not2t 
34fa 2e 00				ld l, 0 
34fc 18 02				jr .notip 
34fe			 
34fe 2e ff		.not2t:		ld l, 255 
3500			 
3500 26 00		.notip:		ld h, 0	 
3502			 
3502 cd fa 1c				call forth_push_numhl 
3505					NEXTW 
3505 c3 63 20			jp macro_next 
3508				endm 
# End of macro NEXTW
3508			 
3508			.IS: 
3508				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3508 2d				db WORD_SYS_CORE+25             
3509 2e 35			dw .LZERO            
350b 03				db 2 + 1 
350c .. 00			db "IS",0              
350f				endm 
# End of macro CWHEAD
350f			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
350f					if DEBUG_FORTH_WORDS_KEY 
350f						DMARK "IS." 
350f f5				push af  
3510 3a 24 35			ld a, (.dmark)  
3513 32 6e fb			ld (debug_mark),a  
3516 3a 25 35			ld a, (.dmark+1)  
3519 32 6f fb			ld (debug_mark+1),a  
351c 3a 26 35			ld a, (.dmark+2)  
351f 32 70 fb			ld (debug_mark+2),a  
3522 18 03			jr .pastdmark  
3524 ..			.dmark: db "IS."  
3527 f1			.pastdmark: pop af  
3528			endm  
# End of macro DMARK
3528						CALLMONITOR 
3528 cd 6a 17			call break_point_state  
352b				endm  
# End of macro CALLMONITOR
352b					endif 
352b					NEXTW 
352b c3 63 20			jp macro_next 
352e				endm 
# End of macro NEXTW
352e			.LZERO: 
352e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
352e 2d				db WORD_SYS_CORE+25             
352f 38 35			dw .TZERO            
3531 03				db 2 + 1 
3532 .. 00			db "0<",0              
3535				endm 
# End of macro CWHEAD
3535			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3535					NEXTW 
3535 c3 63 20			jp macro_next 
3538				endm 
# End of macro NEXTW
3538			.TZERO: 
3538				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3538 2e				db WORD_SYS_CORE+26             
3539 7f 35			dw .LESS            
353b 03				db 2 + 1 
353c .. 00			db "0=",0              
353f				endm 
# End of macro CWHEAD
353f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
353f				; TODO add floating point number detection 
353f					;v5 FORTH_DSP_VALUE 
353f					if DEBUG_FORTH_WORDS_KEY 
353f						DMARK "0=." 
353f f5				push af  
3540 3a 54 35			ld a, (.dmark)  
3543 32 6e fb			ld (debug_mark),a  
3546 3a 55 35			ld a, (.dmark+1)  
3549 32 6f fb			ld (debug_mark+1),a  
354c 3a 56 35			ld a, (.dmark+2)  
354f 32 70 fb			ld (debug_mark+2),a  
3552 18 03			jr .pastdmark  
3554 ..			.dmark: db "0=."  
3557 f1			.pastdmark: pop af  
3558			endm  
# End of macro DMARK
3558						CALLMONITOR 
3558 cd 6a 17			call break_point_state  
355b				endm  
# End of macro CALLMONITOR
355b					endif 
355b					FORTH_DSP 
355b cd b7 1e			call macro_forth_dsp 
355e				endm 
# End of macro FORTH_DSP
355e 7e					ld a,(hl)	; get type of value on TOS 
355f fe 02				cp DS_TYPE_INUM  
3561 28 00				jr z, .tz_inum 
3563			 
3563				if FORTH_ENABLE_FLOATMATH 
3563					jr .tz_done 
3563			 
3563				endif 
3563					 
3563			 
3563			.tz_inum: 
3563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3563 cd f1 1e			call macro_dsp_valuehl 
3566				endm 
# End of macro FORTH_DSP_VALUEHL
3566			 
3566			;		push hl 
3566			 
3566					; destroy value TOS 
3566			 
3566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3566 cd a9 1f			call macro_forth_dsp_pop 
3569				endm 
# End of macro FORTH_DSP_POP
3569			 
3569			;		pop hl 
3569			 
3569 3e 00				ld a,0 
356b			 
356b bd					cp l 
356c 20 08				jr nz, .tz_notzero 
356e			 
356e bc					cp h 
356f			 
356f 20 05				jr nz, .tz_notzero 
3571			 
3571			 
3571 21 01 00				ld hl, FORTH_TRUE 
3574 18 03				jr .tz_done 
3576			 
3576 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3579			 
3579					; push value back onto stack for another op etc 
3579			 
3579			.tz_done: 
3579 cd fa 1c				call forth_push_numhl 
357c			 
357c					NEXTW 
357c c3 63 20			jp macro_next 
357f				endm 
# End of macro NEXTW
357f			.LESS: 
357f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
357f 2f				db WORD_SYS_CORE+27             
3580 e8 35			dw .GT            
3582 02				db 1 + 1 
3583 .. 00			db "<",0              
3585				endm 
# End of macro CWHEAD
3585			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3585				; TODO add floating point number detection 
3585					if DEBUG_FORTH_WORDS_KEY 
3585						DMARK "LES" 
3585 f5				push af  
3586 3a 9a 35			ld a, (.dmark)  
3589 32 6e fb			ld (debug_mark),a  
358c 3a 9b 35			ld a, (.dmark+1)  
358f 32 6f fb			ld (debug_mark+1),a  
3592 3a 9c 35			ld a, (.dmark+2)  
3595 32 70 fb			ld (debug_mark+2),a  
3598 18 03			jr .pastdmark  
359a ..			.dmark: db "LES"  
359d f1			.pastdmark: pop af  
359e			endm  
# End of macro DMARK
359e						CALLMONITOR 
359e cd 6a 17			call break_point_state  
35a1				endm  
# End of macro CALLMONITOR
35a1					endif 
35a1					FORTH_DSP 
35a1 cd b7 1e			call macro_forth_dsp 
35a4				endm 
# End of macro FORTH_DSP
35a4					;v5 FORTH_DSP_VALUE 
35a4 7e					ld a,(hl)	; get type of value on TOS 
35a5 fe 02				cp DS_TYPE_INUM  
35a7 28 00				jr z, .less_inum 
35a9			 
35a9				if FORTH_ENABLE_FLOATMATH 
35a9					jr .less_done 
35a9			 
35a9				endif 
35a9					 
35a9			 
35a9			.less_inum: 
35a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a9 cd f1 1e			call macro_dsp_valuehl 
35ac				endm 
# End of macro FORTH_DSP_VALUEHL
35ac			 
35ac e5					push hl  ; u2 
35ad			 
35ad					; destroy value TOS 
35ad			 
35ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ad cd a9 1f			call macro_forth_dsp_pop 
35b0				endm 
# End of macro FORTH_DSP_POP
35b0			 
35b0			 
35b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b0 cd f1 1e			call macro_dsp_valuehl 
35b3				endm 
# End of macro FORTH_DSP_VALUEHL
35b3			 
35b3 e5					push hl    ; u1 
35b4			 
35b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b4 cd a9 1f			call macro_forth_dsp_pop 
35b7				endm 
# End of macro FORTH_DSP_POP
35b7			 
35b7			 
35b7 b7			 or a      ;clear carry flag 
35b8 01 00 00		 ld bc, FORTH_FALSE 
35bb e1			  pop hl    ; u1 
35bc d1			  pop de    ; u2 
35bd ed 52		  sbc hl,de 
35bf 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35c1			 
35c1 01 01 00		 ld bc, FORTH_TRUE 
35c4			.lscont:  
35c4 c5					push bc 
35c5 e1					pop hl 
35c6			 
35c6					if DEBUG_FORTH_WORDS 
35c6						DMARK "LT1" 
35c6 f5				push af  
35c7 3a db 35			ld a, (.dmark)  
35ca 32 6e fb			ld (debug_mark),a  
35cd 3a dc 35			ld a, (.dmark+1)  
35d0 32 6f fb			ld (debug_mark+1),a  
35d3 3a dd 35			ld a, (.dmark+2)  
35d6 32 70 fb			ld (debug_mark+2),a  
35d9 18 03			jr .pastdmark  
35db ..			.dmark: db "LT1"  
35de f1			.pastdmark: pop af  
35df			endm  
# End of macro DMARK
35df						CALLMONITOR 
35df cd 6a 17			call break_point_state  
35e2				endm  
# End of macro CALLMONITOR
35e2					endif 
35e2 cd fa 1c				call forth_push_numhl 
35e5			 
35e5					NEXTW 
35e5 c3 63 20			jp macro_next 
35e8				endm 
# End of macro NEXTW
35e8			.GT: 
35e8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35e8 30				db WORD_SYS_CORE+28             
35e9 51 36			dw .EQUAL            
35eb 02				db 1 + 1 
35ec .. 00			db ">",0              
35ee				endm 
# End of macro CWHEAD
35ee			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35ee				; TODO add floating point number detection 
35ee					if DEBUG_FORTH_WORDS_KEY 
35ee						DMARK "GRT" 
35ee f5				push af  
35ef 3a 03 36			ld a, (.dmark)  
35f2 32 6e fb			ld (debug_mark),a  
35f5 3a 04 36			ld a, (.dmark+1)  
35f8 32 6f fb			ld (debug_mark+1),a  
35fb 3a 05 36			ld a, (.dmark+2)  
35fe 32 70 fb			ld (debug_mark+2),a  
3601 18 03			jr .pastdmark  
3603 ..			.dmark: db "GRT"  
3606 f1			.pastdmark: pop af  
3607			endm  
# End of macro DMARK
3607						CALLMONITOR 
3607 cd 6a 17			call break_point_state  
360a				endm  
# End of macro CALLMONITOR
360a					endif 
360a					FORTH_DSP 
360a cd b7 1e			call macro_forth_dsp 
360d				endm 
# End of macro FORTH_DSP
360d					;FORTH_DSP_VALUE 
360d 7e					ld a,(hl)	; get type of value on TOS 
360e fe 02				cp DS_TYPE_INUM  
3610 28 00				jr z, .gt_inum 
3612			 
3612				if FORTH_ENABLE_FLOATMATH 
3612					jr .gt_done 
3612			 
3612				endif 
3612					 
3612			 
3612			.gt_inum: 
3612					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3612 cd f1 1e			call macro_dsp_valuehl 
3615				endm 
# End of macro FORTH_DSP_VALUEHL
3615			 
3615 e5					push hl  ; u2 
3616			 
3616					; destroy value TOS 
3616			 
3616					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3616 cd a9 1f			call macro_forth_dsp_pop 
3619				endm 
# End of macro FORTH_DSP_POP
3619			 
3619			 
3619					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3619 cd f1 1e			call macro_dsp_valuehl 
361c				endm 
# End of macro FORTH_DSP_VALUEHL
361c			 
361c e5					push hl    ; u1 
361d			 
361d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361d cd a9 1f			call macro_forth_dsp_pop 
3620				endm 
# End of macro FORTH_DSP_POP
3620			 
3620			 
3620 b7			 or a      ;clear carry flag 
3621 01 00 00		 ld bc, FORTH_FALSE 
3624 e1			  pop hl    ; u1 
3625 d1			  pop de    ; u2 
3626 ed 52		  sbc hl,de 
3628 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
362a			 
362a 01 01 00		 ld bc, FORTH_TRUE 
362d			.gtcont:  
362d c5					push bc 
362e e1					pop hl 
362f			 
362f					if DEBUG_FORTH_WORDS 
362f						DMARK "GT1" 
362f f5				push af  
3630 3a 44 36			ld a, (.dmark)  
3633 32 6e fb			ld (debug_mark),a  
3636 3a 45 36			ld a, (.dmark+1)  
3639 32 6f fb			ld (debug_mark+1),a  
363c 3a 46 36			ld a, (.dmark+2)  
363f 32 70 fb			ld (debug_mark+2),a  
3642 18 03			jr .pastdmark  
3644 ..			.dmark: db "GT1"  
3647 f1			.pastdmark: pop af  
3648			endm  
# End of macro DMARK
3648						CALLMONITOR 
3648 cd 6a 17			call break_point_state  
364b				endm  
# End of macro CALLMONITOR
364b					endif 
364b cd fa 1c				call forth_push_numhl 
364e			 
364e					NEXTW 
364e c3 63 20			jp macro_next 
3651				endm 
# End of macro NEXTW
3651			.EQUAL: 
3651				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3651 31				db WORD_SYS_CORE+29             
3652 bc 36			dw .ENDLOGIC            
3654 02				db 1 + 1 
3655 .. 00			db "=",0              
3657				endm 
# End of macro CWHEAD
3657			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3657				; TODO add floating point number detection 
3657					if DEBUG_FORTH_WORDS_KEY 
3657						DMARK "EQ." 
3657 f5				push af  
3658 3a 6c 36			ld a, (.dmark)  
365b 32 6e fb			ld (debug_mark),a  
365e 3a 6d 36			ld a, (.dmark+1)  
3661 32 6f fb			ld (debug_mark+1),a  
3664 3a 6e 36			ld a, (.dmark+2)  
3667 32 70 fb			ld (debug_mark+2),a  
366a 18 03			jr .pastdmark  
366c ..			.dmark: db "EQ."  
366f f1			.pastdmark: pop af  
3670			endm  
# End of macro DMARK
3670						CALLMONITOR 
3670 cd 6a 17			call break_point_state  
3673				endm  
# End of macro CALLMONITOR
3673					endif 
3673					FORTH_DSP 
3673 cd b7 1e			call macro_forth_dsp 
3676				endm 
# End of macro FORTH_DSP
3676					;v5 FORTH_DSP_VALUE 
3676 7e					ld a,(hl)	; get type of value on TOS 
3677 fe 02				cp DS_TYPE_INUM  
3679 28 00				jr z, .eq_inum 
367b			 
367b				if FORTH_ENABLE_FLOATMATH 
367b					jr .eq_done 
367b			 
367b				endif 
367b					 
367b			 
367b			.eq_inum: 
367b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
367b cd f1 1e			call macro_dsp_valuehl 
367e				endm 
# End of macro FORTH_DSP_VALUEHL
367e			 
367e e5					push hl 
367f			 
367f					; destroy value TOS 
367f			 
367f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
367f cd a9 1f			call macro_forth_dsp_pop 
3682				endm 
# End of macro FORTH_DSP_POP
3682			 
3682			 
3682					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3682 cd f1 1e			call macro_dsp_valuehl 
3685				endm 
# End of macro FORTH_DSP_VALUEHL
3685			 
3685					; one value on hl get other one back 
3685			 
3685 e5					push hl 
3686			 
3686					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3686 cd a9 1f			call macro_forth_dsp_pop 
3689				endm 
# End of macro FORTH_DSP_POP
3689			 
3689 0e 00				ld c, FORTH_FALSE 
368b			 
368b e1					pop hl 
368c d1					pop de 
368d			 
368d 7b					ld a, e 
368e bd					cp l 
368f			 
368f 20 06				jr nz, .eq_done 
3691			 
3691 7a					ld a, d 
3692 bc					cp h 
3693			 
3693 20 02				jr nz, .eq_done 
3695			 
3695 0e 01				ld c, FORTH_TRUE 
3697					 
3697			 
3697			 
3697			.eq_done: 
3697			 
3697					; TODO push value back onto stack for another op etc 
3697			 
3697 26 00				ld h, 0 
3699 69					ld l, c 
369a					if DEBUG_FORTH_WORDS 
369a						DMARK "EQ1" 
369a f5				push af  
369b 3a af 36			ld a, (.dmark)  
369e 32 6e fb			ld (debug_mark),a  
36a1 3a b0 36			ld a, (.dmark+1)  
36a4 32 6f fb			ld (debug_mark+1),a  
36a7 3a b1 36			ld a, (.dmark+2)  
36aa 32 70 fb			ld (debug_mark+2),a  
36ad 18 03			jr .pastdmark  
36af ..			.dmark: db "EQ1"  
36b2 f1			.pastdmark: pop af  
36b3			endm  
# End of macro DMARK
36b3						CALLMONITOR 
36b3 cd 6a 17			call break_point_state  
36b6				endm  
# End of macro CALLMONITOR
36b6					endif 
36b6 cd fa 1c				call forth_push_numhl 
36b9			 
36b9					NEXTW 
36b9 c3 63 20			jp macro_next 
36bc				endm 
# End of macro NEXTW
36bc			 
36bc			 
36bc			.ENDLOGIC: 
36bc			; eof 
36bc			 
36bc			 
# End of file forth_words_logic.asm
36bc			include "forth_words_maths.asm" 
36bc			 
36bc			; | ## Maths Words 
36bc			 
36bc			.PLUS:	 
36bc				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36bc 15				db WORD_SYS_CORE+1             
36bd fe 36			dw .NEG            
36bf 02				db 1 + 1 
36c0 .. 00			db "+",0              
36c2				endm 
# End of macro CWHEAD
36c2			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36c2					if DEBUG_FORTH_WORDS_KEY 
36c2						DMARK "PLU" 
36c2 f5				push af  
36c3 3a d7 36			ld a, (.dmark)  
36c6 32 6e fb			ld (debug_mark),a  
36c9 3a d8 36			ld a, (.dmark+1)  
36cc 32 6f fb			ld (debug_mark+1),a  
36cf 3a d9 36			ld a, (.dmark+2)  
36d2 32 70 fb			ld (debug_mark+2),a  
36d5 18 03			jr .pastdmark  
36d7 ..			.dmark: db "PLU"  
36da f1			.pastdmark: pop af  
36db			endm  
# End of macro DMARK
36db						CALLMONITOR 
36db cd 6a 17			call break_point_state  
36de				endm  
# End of macro CALLMONITOR
36de					endif 
36de					; add top two values and push back result 
36de			 
36de					;for v5 FORTH_DSP_VALUE 
36de					FORTH_DSP 
36de cd b7 1e			call macro_forth_dsp 
36e1				endm 
# End of macro FORTH_DSP
36e1 7e					ld a,(hl)	; get type of value on TOS 
36e2 fe 02				cp DS_TYPE_INUM  
36e4 28 03				jr z, .dot_inum 
36e6			 
36e6					NEXTW 
36e6 c3 63 20			jp macro_next 
36e9				endm 
# End of macro NEXTW
36e9			 
36e9			; float maths 
36e9			 
36e9				if FORTH_ENABLE_FLOATMATH 
36e9						inc hl      ; now at start of numeric as string 
36e9			 
36e9					if DEBUG_FORTH_MATHS 
36e9						DMARK "ADD" 
36e9				CALLMONITOR 
36e9					endif 
36e9			 
36e9					;ld ix, hl 
36e9					call CON 
36e9			 
36e9			 
36e9					push hl 
36e9					 
36e9					 
36e9			 
36e9						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36e9			 
36e9					; get next number 
36e9			 
36e9						FORTH_DSP_VALUE 
36e9			 
36e9						inc hl      ; now at start of numeric as string 
36e9			 
36e9					;ld ix, hl 
36e9					call CON 
36e9			 
36e9					push hl 
36e9			 
36e9			 
36e9						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e9			 
36e9						; TODO do add 
36e9			 
36e9						call IADD 
36e9			 
36e9						; TODO get result back as ascii 
36e9			 
36e9						; TODO push result  
36e9			 
36e9			 
36e9			 
36e9						jr .dot_done 
36e9				endif 
36e9			 
36e9			.dot_inum: 
36e9			 
36e9			 
36e9					if DEBUG_FORTH_DOT 
36e9						DMARK "+IT" 
36e9				CALLMONITOR 
36e9					endif 
36e9			 
36e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e9 cd f1 1e			call macro_dsp_valuehl 
36ec				endm 
# End of macro FORTH_DSP_VALUEHL
36ec			 
36ec				; TODO add floating point number detection 
36ec			 
36ec e5					push hl 
36ed			 
36ed					; destroy value TOS 
36ed			 
36ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ed cd a9 1f			call macro_forth_dsp_pop 
36f0				endm 
# End of macro FORTH_DSP_POP
36f0			 
36f0			 
36f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f0 cd f1 1e			call macro_dsp_valuehl 
36f3				endm 
# End of macro FORTH_DSP_VALUEHL
36f3			 
36f3					; one value on hl get other one back 
36f3			 
36f3 d1					pop de 
36f4			 
36f4					; do the add 
36f4			 
36f4 19					add hl,de 
36f5			 
36f5					; save it 
36f5			 
36f5			;		push hl	 
36f5			 
36f5					; 
36f5			 
36f5					; destroy value TOS 
36f5			 
36f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f5 cd a9 1f			call macro_forth_dsp_pop 
36f8				endm 
# End of macro FORTH_DSP_POP
36f8			 
36f8					; TODO push value back onto stack for another op etc 
36f8			 
36f8			;		pop hl 
36f8			 
36f8			.dot_done: 
36f8 cd fa 1c				call forth_push_numhl 
36fb			 
36fb					NEXTW 
36fb c3 63 20			jp macro_next 
36fe				endm 
# End of macro NEXTW
36fe			.NEG: 
36fe			 
36fe				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36fe 17				db WORD_SYS_CORE+3             
36ff 41 37			dw .DIV            
3701 02				db 1 + 1 
3702 .. 00			db "-",0              
3704				endm 
# End of macro CWHEAD
3704			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3704					if DEBUG_FORTH_WORDS_KEY 
3704						DMARK "SUB" 
3704 f5				push af  
3705 3a 19 37			ld a, (.dmark)  
3708 32 6e fb			ld (debug_mark),a  
370b 3a 1a 37			ld a, (.dmark+1)  
370e 32 6f fb			ld (debug_mark+1),a  
3711 3a 1b 37			ld a, (.dmark+2)  
3714 32 70 fb			ld (debug_mark+2),a  
3717 18 03			jr .pastdmark  
3719 ..			.dmark: db "SUB"  
371c f1			.pastdmark: pop af  
371d			endm  
# End of macro DMARK
371d						CALLMONITOR 
371d cd 6a 17			call break_point_state  
3720				endm  
# End of macro CALLMONITOR
3720					endif 
3720			 
3720			 
3720				; TODO add floating point number detection 
3720					; v5 FORTH_DSP_VALUE 
3720					FORTH_DSP 
3720 cd b7 1e			call macro_forth_dsp 
3723				endm 
# End of macro FORTH_DSP
3723 7e					ld a,(hl)	; get type of value on TOS 
3724 fe 02				cp DS_TYPE_INUM  
3726 28 03				jr z, .neg_inum 
3728			 
3728					NEXTW 
3728 c3 63 20			jp macro_next 
372b				endm 
# End of macro NEXTW
372b			 
372b			; float maths 
372b			 
372b				if FORTH_ENABLE_FLOATMATH 
372b					jr .neg_done 
372b			 
372b				endif 
372b					 
372b			 
372b			.neg_inum: 
372b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372b cd f1 1e			call macro_dsp_valuehl 
372e				endm 
# End of macro FORTH_DSP_VALUEHL
372e			 
372e e5					push hl 
372f			 
372f					; destroy value TOS 
372f			 
372f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372f cd a9 1f			call macro_forth_dsp_pop 
3732				endm 
# End of macro FORTH_DSP_POP
3732			 
3732			 
3732					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3732 cd f1 1e			call macro_dsp_valuehl 
3735				endm 
# End of macro FORTH_DSP_VALUEHL
3735			 
3735					; one value on hl get other one back 
3735			 
3735 d1					pop de 
3736			 
3736					; do the sub 
3736			;		ex de, hl 
3736			 
3736 ed 52				sbc hl,de 
3738			 
3738					; save it 
3738			 
3738			;		push hl	 
3738			 
3738					; 
3738			 
3738					; destroy value TOS 
3738			 
3738					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3738 cd a9 1f			call macro_forth_dsp_pop 
373b				endm 
# End of macro FORTH_DSP_POP
373b			 
373b					; TODO push value back onto stack for another op etc 
373b			 
373b			;		pop hl 
373b			 
373b cd fa 1c				call forth_push_numhl 
373e			.neg_done: 
373e			 
373e					NEXTW 
373e c3 63 20			jp macro_next 
3741				endm 
# End of macro NEXTW
3741			.DIV: 
3741				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3741 18				db WORD_SYS_CORE+4             
3742 8e 37			dw .MUL            
3744 02				db 1 + 1 
3745 .. 00			db "/",0              
3747				endm 
# End of macro CWHEAD
3747			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3747					if DEBUG_FORTH_WORDS_KEY 
3747						DMARK "DIV" 
3747 f5				push af  
3748 3a 5c 37			ld a, (.dmark)  
374b 32 6e fb			ld (debug_mark),a  
374e 3a 5d 37			ld a, (.dmark+1)  
3751 32 6f fb			ld (debug_mark+1),a  
3754 3a 5e 37			ld a, (.dmark+2)  
3757 32 70 fb			ld (debug_mark+2),a  
375a 18 03			jr .pastdmark  
375c ..			.dmark: db "DIV"  
375f f1			.pastdmark: pop af  
3760			endm  
# End of macro DMARK
3760						CALLMONITOR 
3760 cd 6a 17			call break_point_state  
3763				endm  
# End of macro CALLMONITOR
3763					endif 
3763				; TODO add floating point number detection 
3763					; v5 FORTH_DSP_VALUE 
3763					FORTH_DSP 
3763 cd b7 1e			call macro_forth_dsp 
3766				endm 
# End of macro FORTH_DSP
3766 7e					ld a,(hl)	; get type of value on TOS 
3767 fe 02				cp DS_TYPE_INUM  
3769 28 03				jr z, .div_inum 
376b			 
376b				if FORTH_ENABLE_FLOATMATH 
376b					jr .div_done 
376b			 
376b				endif 
376b					NEXTW 
376b c3 63 20			jp macro_next 
376e				endm 
# End of macro NEXTW
376e			.div_inum: 
376e			 
376e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376e cd f1 1e			call macro_dsp_valuehl 
3771				endm 
# End of macro FORTH_DSP_VALUEHL
3771			 
3771 e5					push hl    ; to go to bc 
3772			 
3772					; destroy value TOS 
3772			 
3772					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3772 cd a9 1f			call macro_forth_dsp_pop 
3775				endm 
# End of macro FORTH_DSP_POP
3775			 
3775			 
3775					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3775 cd f1 1e			call macro_dsp_valuehl 
3778				endm 
# End of macro FORTH_DSP_VALUEHL
3778			 
3778					; hl to go to de 
3778			 
3778 e5					push hl 
3779			 
3779 c1					pop bc 
377a d1					pop de		 
377b			 
377b			 
377b					if DEBUG_FORTH_MATHS 
377b						DMARK "DIV" 
377b				CALLMONITOR 
377b					endif 
377b					; one value on hl but move to a get other one back 
377b			 
377b			        
377b cd 78 0c			call Div16 
377e			 
377e			;	push af	 
377e e5				push hl 
377f c5				push bc 
3780			 
3780					if DEBUG_FORTH_MATHS 
3780						DMARK "DI1" 
3780				CALLMONITOR 
3780					endif 
3780			 
3780					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3780 cd a9 1f			call macro_forth_dsp_pop 
3783				endm 
# End of macro FORTH_DSP_POP
3783			 
3783			 
3783			 
3783 e1					pop hl    ; result 
3784			 
3784 cd fa 1c				call forth_push_numhl 
3787			 
3787 e1					pop hl    ; reminder 
3788			;		ld h,0 
3788			;		ld l,d 
3788			 
3788 cd fa 1c				call forth_push_numhl 
378b			.div_done: 
378b					NEXTW 
378b c3 63 20			jp macro_next 
378e				endm 
# End of macro NEXTW
378e			.MUL: 
378e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
378e 19				db WORD_SYS_CORE+5             
378f d3 37			dw .MIN            
3791 02				db 1 + 1 
3792 .. 00			db "*",0              
3794				endm 
# End of macro CWHEAD
3794			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3794				; TODO add floating point number detection 
3794					if DEBUG_FORTH_WORDS_KEY 
3794						DMARK "MUL" 
3794 f5				push af  
3795 3a a9 37			ld a, (.dmark)  
3798 32 6e fb			ld (debug_mark),a  
379b 3a aa 37			ld a, (.dmark+1)  
379e 32 6f fb			ld (debug_mark+1),a  
37a1 3a ab 37			ld a, (.dmark+2)  
37a4 32 70 fb			ld (debug_mark+2),a  
37a7 18 03			jr .pastdmark  
37a9 ..			.dmark: db "MUL"  
37ac f1			.pastdmark: pop af  
37ad			endm  
# End of macro DMARK
37ad						CALLMONITOR 
37ad cd 6a 17			call break_point_state  
37b0				endm  
# End of macro CALLMONITOR
37b0					endif 
37b0					FORTH_DSP 
37b0 cd b7 1e			call macro_forth_dsp 
37b3				endm 
# End of macro FORTH_DSP
37b3					; v5 FORTH_DSP_VALUE 
37b3 7e					ld a,(hl)	; get type of value on TOS 
37b4 fe 02				cp DS_TYPE_INUM  
37b6 28 03				jr z, .mul_inum 
37b8			 
37b8				if FORTH_ENABLE_FLOATMATH 
37b8					jr .mul_done 
37b8			 
37b8				endif 
37b8			 
37b8					NEXTW 
37b8 c3 63 20			jp macro_next 
37bb				endm 
# End of macro NEXTW
37bb			.mul_inum:	 
37bb			 
37bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37bb cd f1 1e			call macro_dsp_valuehl 
37be				endm 
# End of macro FORTH_DSP_VALUEHL
37be			 
37be e5					push hl 
37bf			 
37bf					; destroy value TOS 
37bf			 
37bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37bf cd a9 1f			call macro_forth_dsp_pop 
37c2				endm 
# End of macro FORTH_DSP_POP
37c2			 
37c2			 
37c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c2 cd f1 1e			call macro_dsp_valuehl 
37c5				endm 
# End of macro FORTH_DSP_VALUEHL
37c5			 
37c5					; one value on hl but move to a get other one back 
37c5			 
37c5 7d					ld a, l 
37c6			 
37c6 d1					pop de 
37c7			 
37c7					; do the mull 
37c7			;		ex de, hl 
37c7			 
37c7 cd 9e 0c				call Mult16 
37ca					; save it 
37ca			 
37ca			;		push hl	 
37ca			 
37ca					; 
37ca			 
37ca					; destroy value TOS 
37ca			 
37ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ca cd a9 1f			call macro_forth_dsp_pop 
37cd				endm 
# End of macro FORTH_DSP_POP
37cd			 
37cd					; TODO push value back onto stack for another op etc 
37cd			 
37cd			;		pop hl 
37cd			 
37cd cd fa 1c				call forth_push_numhl 
37d0			 
37d0			.mul_done: 
37d0					NEXTW 
37d0 c3 63 20			jp macro_next 
37d3				endm 
# End of macro NEXTW
37d3			 
37d3			 
37d3			 
37d3			 
37d3			.MIN: 
37d3				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37d3 49				db WORD_SYS_CORE+53             
37d4 54 38			dw .MAX            
37d6 04				db 3 + 1 
37d7 .. 00			db "MIN",0              
37db				endm 
# End of macro CWHEAD
37db			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37db					if DEBUG_FORTH_WORDS_KEY 
37db						DMARK "MIN" 
37db f5				push af  
37dc 3a f0 37			ld a, (.dmark)  
37df 32 6e fb			ld (debug_mark),a  
37e2 3a f1 37			ld a, (.dmark+1)  
37e5 32 6f fb			ld (debug_mark+1),a  
37e8 3a f2 37			ld a, (.dmark+2)  
37eb 32 70 fb			ld (debug_mark+2),a  
37ee 18 03			jr .pastdmark  
37f0 ..			.dmark: db "MIN"  
37f3 f1			.pastdmark: pop af  
37f4			endm  
# End of macro DMARK
37f4						CALLMONITOR 
37f4 cd 6a 17			call break_point_state  
37f7				endm  
# End of macro CALLMONITOR
37f7					endif 
37f7					; get u2 
37f7			 
37f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f7 cd f1 1e			call macro_dsp_valuehl 
37fa				endm 
# End of macro FORTH_DSP_VALUEHL
37fa			 
37fa e5					push hl   ; u2 
37fb			 
37fb					; destroy value TOS 
37fb			 
37fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37fb cd a9 1f			call macro_forth_dsp_pop 
37fe				endm 
# End of macro FORTH_DSP_POP
37fe			 
37fe					; get u1 
37fe			 
37fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fe cd f1 1e			call macro_dsp_valuehl 
3801				endm 
# End of macro FORTH_DSP_VALUEHL
3801			 
3801 e5					push hl  ; u1 
3802			 
3802					; destroy value TOS 
3802			 
3802					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3802 cd a9 1f			call macro_forth_dsp_pop 
3805				endm 
# End of macro FORTH_DSP_POP
3805			 
3805 b7			 or a      ;clear carry flag 
3806 e1			  pop hl    ; u1 
3807 d1			  pop de    ; u2 
3808 e5				push hl   ; saved in case hl is lowest 
3809 ed 52		  sbc hl,de 
380b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
380d			 
380d e1				pop hl 
380e					if DEBUG_FORTH_WORDS 
380e						DMARK "MIN" 
380e f5				push af  
380f 3a 23 38			ld a, (.dmark)  
3812 32 6e fb			ld (debug_mark),a  
3815 3a 24 38			ld a, (.dmark+1)  
3818 32 6f fb			ld (debug_mark+1),a  
381b 3a 25 38			ld a, (.dmark+2)  
381e 32 70 fb			ld (debug_mark+2),a  
3821 18 03			jr .pastdmark  
3823 ..			.dmark: db "MIN"  
3826 f1			.pastdmark: pop af  
3827			endm  
# End of macro DMARK
3827						CALLMONITOR 
3827 cd 6a 17			call break_point_state  
382a				endm  
# End of macro CALLMONITOR
382a					endif 
382a cd fa 1c				call forth_push_numhl 
382d			 
382d				       NEXTW 
382d c3 63 20			jp macro_next 
3830				endm 
# End of macro NEXTW
3830			 
3830			.mincont:  
3830 c1				pop bc   ; tidy up 
3831 eb				ex de , hl  
3832					if DEBUG_FORTH_WORDS 
3832						DMARK "MI1" 
3832 f5				push af  
3833 3a 47 38			ld a, (.dmark)  
3836 32 6e fb			ld (debug_mark),a  
3839 3a 48 38			ld a, (.dmark+1)  
383c 32 6f fb			ld (debug_mark+1),a  
383f 3a 49 38			ld a, (.dmark+2)  
3842 32 70 fb			ld (debug_mark+2),a  
3845 18 03			jr .pastdmark  
3847 ..			.dmark: db "MI1"  
384a f1			.pastdmark: pop af  
384b			endm  
# End of macro DMARK
384b						CALLMONITOR 
384b cd 6a 17			call break_point_state  
384e				endm  
# End of macro CALLMONITOR
384e					endif 
384e cd fa 1c				call forth_push_numhl 
3851			 
3851				       NEXTW 
3851 c3 63 20			jp macro_next 
3854				endm 
# End of macro NEXTW
3854			.MAX: 
3854				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3854 4a				db WORD_SYS_CORE+54             
3855 d5 38			dw .RND16            
3857 04				db 3 + 1 
3858 .. 00			db "MAX",0              
385c				endm 
# End of macro CWHEAD
385c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
385c					if DEBUG_FORTH_WORDS_KEY 
385c						DMARK "MAX" 
385c f5				push af  
385d 3a 71 38			ld a, (.dmark)  
3860 32 6e fb			ld (debug_mark),a  
3863 3a 72 38			ld a, (.dmark+1)  
3866 32 6f fb			ld (debug_mark+1),a  
3869 3a 73 38			ld a, (.dmark+2)  
386c 32 70 fb			ld (debug_mark+2),a  
386f 18 03			jr .pastdmark  
3871 ..			.dmark: db "MAX"  
3874 f1			.pastdmark: pop af  
3875			endm  
# End of macro DMARK
3875						CALLMONITOR 
3875 cd 6a 17			call break_point_state  
3878				endm  
# End of macro CALLMONITOR
3878					endif 
3878					; get u2 
3878			 
3878					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3878 cd f1 1e			call macro_dsp_valuehl 
387b				endm 
# End of macro FORTH_DSP_VALUEHL
387b			 
387b e5					push hl   ; u2 
387c			 
387c					; destroy value TOS 
387c			 
387c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
387c cd a9 1f			call macro_forth_dsp_pop 
387f				endm 
# End of macro FORTH_DSP_POP
387f			 
387f					; get u1 
387f			 
387f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
387f cd f1 1e			call macro_dsp_valuehl 
3882				endm 
# End of macro FORTH_DSP_VALUEHL
3882			 
3882 e5					push hl  ; u1 
3883			 
3883					; destroy value TOS 
3883			 
3883					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3883 cd a9 1f			call macro_forth_dsp_pop 
3886				endm 
# End of macro FORTH_DSP_POP
3886			 
3886 b7			 or a      ;clear carry flag 
3887 e1			  pop hl    ; u1 
3888 d1			  pop de    ; u2 
3889 e5				push hl   ; saved in case hl is lowest 
388a ed 52		  sbc hl,de 
388c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
388e			 
388e e1				pop hl 
388f					if DEBUG_FORTH_WORDS 
388f						DMARK "MAX" 
388f f5				push af  
3890 3a a4 38			ld a, (.dmark)  
3893 32 6e fb			ld (debug_mark),a  
3896 3a a5 38			ld a, (.dmark+1)  
3899 32 6f fb			ld (debug_mark+1),a  
389c 3a a6 38			ld a, (.dmark+2)  
389f 32 70 fb			ld (debug_mark+2),a  
38a2 18 03			jr .pastdmark  
38a4 ..			.dmark: db "MAX"  
38a7 f1			.pastdmark: pop af  
38a8			endm  
# End of macro DMARK
38a8						CALLMONITOR 
38a8 cd 6a 17			call break_point_state  
38ab				endm  
# End of macro CALLMONITOR
38ab					endif 
38ab cd fa 1c				call forth_push_numhl 
38ae			 
38ae				       NEXTW 
38ae c3 63 20			jp macro_next 
38b1				endm 
# End of macro NEXTW
38b1			 
38b1			.maxcont:  
38b1 c1				pop bc   ; tidy up 
38b2 eb				ex de , hl  
38b3					if DEBUG_FORTH_WORDS 
38b3						DMARK "MA1" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 6e fb			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 6f fb			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 70 fb			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "MA1"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc						CALLMONITOR 
38cc cd 6a 17			call break_point_state  
38cf				endm  
# End of macro CALLMONITOR
38cf					endif 
38cf cd fa 1c				call forth_push_numhl 
38d2				       NEXTW 
38d2 c3 63 20			jp macro_next 
38d5				endm 
# End of macro NEXTW
38d5			 
38d5			.RND16: 
38d5				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38d5 4e				db WORD_SYS_CORE+58             
38d6 04 39			dw .RND8            
38d8 06				db 5 + 1 
38d9 .. 00			db "RND16",0              
38df				endm 
# End of macro CWHEAD
38df			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38df					if DEBUG_FORTH_WORDS_KEY 
38df						DMARK "R16" 
38df f5				push af  
38e0 3a f4 38			ld a, (.dmark)  
38e3 32 6e fb			ld (debug_mark),a  
38e6 3a f5 38			ld a, (.dmark+1)  
38e9 32 6f fb			ld (debug_mark+1),a  
38ec 3a f6 38			ld a, (.dmark+2)  
38ef 32 70 fb			ld (debug_mark+2),a  
38f2 18 03			jr .pastdmark  
38f4 ..			.dmark: db "R16"  
38f7 f1			.pastdmark: pop af  
38f8			endm  
# End of macro DMARK
38f8						CALLMONITOR 
38f8 cd 6a 17			call break_point_state  
38fb				endm  
# End of macro CALLMONITOR
38fb					endif 
38fb cd 42 0c				call prng16  
38fe cd fa 1c				call forth_push_numhl 
3901				       NEXTW 
3901 c3 63 20			jp macro_next 
3904				endm 
# End of macro NEXTW
3904			.RND8: 
3904				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3904 60				db WORD_SYS_CORE+76             
3905 39 39			dw .RND            
3907 05				db 4 + 1 
3908 .. 00			db "RND8",0              
390d				endm 
# End of macro CWHEAD
390d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
390d					if DEBUG_FORTH_WORDS_KEY 
390d						DMARK "RN8" 
390d f5				push af  
390e 3a 22 39			ld a, (.dmark)  
3911 32 6e fb			ld (debug_mark),a  
3914 3a 23 39			ld a, (.dmark+1)  
3917 32 6f fb			ld (debug_mark+1),a  
391a 3a 24 39			ld a, (.dmark+2)  
391d 32 70 fb			ld (debug_mark+2),a  
3920 18 03			jr .pastdmark  
3922 ..			.dmark: db "RN8"  
3925 f1			.pastdmark: pop af  
3926			endm  
# End of macro DMARK
3926						CALLMONITOR 
3926 cd 6a 17			call break_point_state  
3929				endm  
# End of macro CALLMONITOR
3929					endif 
3929 2a af f8				ld hl,(xrandc) 
392c 23					inc hl 
392d cd 5c 0c				call xrnd 
3930 6f					ld l,a	 
3931 26 00				ld h,0 
3933 cd fa 1c				call forth_push_numhl 
3936				       NEXTW 
3936 c3 63 20			jp macro_next 
3939				endm 
# End of macro NEXTW
3939			.RND: 
3939				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3939 60				db WORD_SYS_CORE+76             
393a 3f 3a			dw .ENDMATHS            
393c 04				db 3 + 1 
393d .. 00			db "RND",0              
3941				endm 
# End of macro CWHEAD
3941			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3941			 
3941					if DEBUG_FORTH_WORDS_KEY 
3941						DMARK "RND" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 6e fb			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 6f fb			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 70 fb			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "RND"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a						CALLMONITOR 
395a cd 6a 17			call break_point_state  
395d				endm  
# End of macro CALLMONITOR
395d					endif 
395d					 
395d					FORTH_DSP_VALUEHL    ; upper range 
395d cd f1 1e			call macro_dsp_valuehl 
3960				endm 
# End of macro FORTH_DSP_VALUEHL
3960			 
3960 22 b3 f8				ld (LFSRSeed), hl	 
3963			 
3963					if DEBUG_FORTH_WORDS 
3963						DMARK "RN1" 
3963 f5				push af  
3964 3a 78 39			ld a, (.dmark)  
3967 32 6e fb			ld (debug_mark),a  
396a 3a 79 39			ld a, (.dmark+1)  
396d 32 6f fb			ld (debug_mark+1),a  
3970 3a 7a 39			ld a, (.dmark+2)  
3973 32 70 fb			ld (debug_mark+2),a  
3976 18 03			jr .pastdmark  
3978 ..			.dmark: db "RN1"  
397b f1			.pastdmark: pop af  
397c			endm  
# End of macro DMARK
397c						CALLMONITOR 
397c cd 6a 17			call break_point_state  
397f				endm  
# End of macro CALLMONITOR
397f					endif 
397f					FORTH_DSP_POP 
397f cd a9 1f			call macro_forth_dsp_pop 
3982				endm 
# End of macro FORTH_DSP_POP
3982			 
3982					FORTH_DSP_VALUEHL    ; low range 
3982 cd f1 1e			call macro_dsp_valuehl 
3985				endm 
# End of macro FORTH_DSP_VALUEHL
3985			 
3985					if DEBUG_FORTH_WORDS 
3985						DMARK "RN2" 
3985 f5				push af  
3986 3a 9a 39			ld a, (.dmark)  
3989 32 6e fb			ld (debug_mark),a  
398c 3a 9b 39			ld a, (.dmark+1)  
398f 32 6f fb			ld (debug_mark+1),a  
3992 3a 9c 39			ld a, (.dmark+2)  
3995 32 70 fb			ld (debug_mark+2),a  
3998 18 03			jr .pastdmark  
399a ..			.dmark: db "RN2"  
399d f1			.pastdmark: pop af  
399e			endm  
# End of macro DMARK
399e						CALLMONITOR 
399e cd 6a 17			call break_point_state  
39a1				endm  
# End of macro CALLMONITOR
39a1					endif 
39a1 22 b5 f8				ld (LFSRSeed+2), hl 
39a4			 
39a4					FORTH_DSP_POP 
39a4 cd a9 1f			call macro_forth_dsp_pop 
39a7				endm 
# End of macro FORTH_DSP_POP
39a7			 
39a7 e5					push hl 
39a8			 
39a8 e1			.inrange:	pop hl 
39a9 cd 42 0c				call prng16  
39ac					if DEBUG_FORTH_WORDS 
39ac						DMARK "RN3" 
39ac f5				push af  
39ad 3a c1 39			ld a, (.dmark)  
39b0 32 6e fb			ld (debug_mark),a  
39b3 3a c2 39			ld a, (.dmark+1)  
39b6 32 6f fb			ld (debug_mark+1),a  
39b9 3a c3 39			ld a, (.dmark+2)  
39bc 32 70 fb			ld (debug_mark+2),a  
39bf 18 03			jr .pastdmark  
39c1 ..			.dmark: db "RN3"  
39c4 f1			.pastdmark: pop af  
39c5			endm  
# End of macro DMARK
39c5						CALLMONITOR 
39c5 cd 6a 17			call break_point_state  
39c8				endm  
# End of macro CALLMONITOR
39c8					endif 
39c8					 
39c8					; if the range is 8bit knock out the high byte 
39c8			 
39c8 ed 5b b3 f8			ld de, (LFSRSeed)     ; check high level 
39cc			 
39cc 3e 00				ld a, 0 
39ce ba					cp d  
39cf 20 1e				jr nz, .hirange 
39d1 26 00				ld h, 0   ; knock it down to 8bit 
39d3			 
39d3					if DEBUG_FORTH_WORDS 
39d3						DMARK "RNk" 
39d3 f5				push af  
39d4 3a e8 39			ld a, (.dmark)  
39d7 32 6e fb			ld (debug_mark),a  
39da 3a e9 39			ld a, (.dmark+1)  
39dd 32 6f fb			ld (debug_mark+1),a  
39e0 3a ea 39			ld a, (.dmark+2)  
39e3 32 70 fb			ld (debug_mark+2),a  
39e6 18 03			jr .pastdmark  
39e8 ..			.dmark: db "RNk"  
39eb f1			.pastdmark: pop af  
39ec			endm  
# End of macro DMARK
39ec						CALLMONITOR 
39ec cd 6a 17			call break_point_state  
39ef				endm  
# End of macro CALLMONITOR
39ef					endif 
39ef			.hirange:   
39ef e5					push hl  
39f0 b7					or a  
39f1 ed 52		                sbc hl, de 
39f3			 
39f3					;call cmp16 
39f3			 
39f3 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39f5 e1					pop hl 
39f6 e5					push hl 
39f7			 
39f7					if DEBUG_FORTH_WORDS 
39f7						DMARK "RN4" 
39f7 f5				push af  
39f8 3a 0c 3a			ld a, (.dmark)  
39fb 32 6e fb			ld (debug_mark),a  
39fe 3a 0d 3a			ld a, (.dmark+1)  
3a01 32 6f fb			ld (debug_mark+1),a  
3a04 3a 0e 3a			ld a, (.dmark+2)  
3a07 32 70 fb			ld (debug_mark+2),a  
3a0a 18 03			jr .pastdmark  
3a0c ..			.dmark: db "RN4"  
3a0f f1			.pastdmark: pop af  
3a10			endm  
# End of macro DMARK
3a10						CALLMONITOR 
3a10 cd 6a 17			call break_point_state  
3a13				endm  
# End of macro CALLMONITOR
3a13					endif 
3a13 ed 5b b5 f8			ld de, (LFSRSeed+2)   ; check low range 
3a17					;call cmp16 
3a17				 
3a17 b7					or a  
3a18 ed 52		                sbc hl, de 
3a1a 38 8c				jr c, .inrange 
3a1c			 
3a1c e1					pop hl 
3a1d					 
3a1d					if DEBUG_FORTH_WORDS 
3a1d						DMARK "RNd" 
3a1d f5				push af  
3a1e 3a 32 3a			ld a, (.dmark)  
3a21 32 6e fb			ld (debug_mark),a  
3a24 3a 33 3a			ld a, (.dmark+1)  
3a27 32 6f fb			ld (debug_mark+1),a  
3a2a 3a 34 3a			ld a, (.dmark+2)  
3a2d 32 70 fb			ld (debug_mark+2),a  
3a30 18 03			jr .pastdmark  
3a32 ..			.dmark: db "RNd"  
3a35 f1			.pastdmark: pop af  
3a36			endm  
# End of macro DMARK
3a36						CALLMONITOR 
3a36 cd 6a 17			call break_point_state  
3a39				endm  
# End of macro CALLMONITOR
3a39					endif 
3a39			 
3a39			 
3a39 cd fa 1c				call forth_push_numhl 
3a3c				       NEXTW 
3a3c c3 63 20			jp macro_next 
3a3f				endm 
# End of macro NEXTW
3a3f			 
3a3f			.ENDMATHS: 
3a3f			 
3a3f			; eof 
3a3f			 
# End of file forth_words_maths.asm
3a3f			include "forth_words_display.asm" 
3a3f			 
3a3f			; | ## Display Words 
3a3f			 
3a3f			.INFO: 
3a3f			 
3a3f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a3f 62				db WORD_SYS_CORE+78             
3a40 5c 3a			dw .ATP            
3a42 05				db 4 + 1 
3a43 .. 00			db "INFO",0              
3a48				endm 
# End of macro CWHEAD
3a48			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a48					FORTH_DSP_VALUEHL 
3a48 cd f1 1e			call macro_dsp_valuehl 
3a4b				endm 
# End of macro FORTH_DSP_VALUEHL
3a4b			 
3a4b					FORTH_DSP_POP 
3a4b cd a9 1f			call macro_forth_dsp_pop 
3a4e				endm 
# End of macro FORTH_DSP_POP
3a4e			 
3a4e e5					push hl 
3a4f			 
3a4f					FORTH_DSP_VALUEHL 
3a4f cd f1 1e			call macro_dsp_valuehl 
3a52				endm 
# End of macro FORTH_DSP_VALUEHL
3a52			 
3a52					FORTH_DSP_POP 
3a52 cd a9 1f			call macro_forth_dsp_pop 
3a55				endm 
# End of macro FORTH_DSP_POP
3a55			 
3a55 d1					pop de 
3a56			 
3a56 cd 78 0a				call info_panel 
3a59			 
3a59			 
3a59					NEXTW 
3a59 c3 63 20			jp macro_next 
3a5c				endm 
# End of macro NEXTW
3a5c			.ATP: 
3a5c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a5c 62				db WORD_SYS_CORE+78             
3a5d d3 3a			dw .FB            
3a5f 04				db 3 + 1 
3a60 .. 00			db "AT?",0              
3a64				endm 
# End of macro CWHEAD
3a64			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a64					if DEBUG_FORTH_WORDS_KEY 
3a64						DMARK "AT?" 
3a64 f5				push af  
3a65 3a 79 3a			ld a, (.dmark)  
3a68 32 6e fb			ld (debug_mark),a  
3a6b 3a 7a 3a			ld a, (.dmark+1)  
3a6e 32 6f fb			ld (debug_mark+1),a  
3a71 3a 7b 3a			ld a, (.dmark+2)  
3a74 32 70 fb			ld (debug_mark+2),a  
3a77 18 03			jr .pastdmark  
3a79 ..			.dmark: db "AT?"  
3a7c f1			.pastdmark: pop af  
3a7d			endm  
# End of macro DMARK
3a7d						CALLMONITOR 
3a7d cd 6a 17			call break_point_state  
3a80				endm  
# End of macro CALLMONITOR
3a80					endif 
3a80 3a 3d f8				ld a, (f_cursor_ptr) 
3a83			 
3a83			if DEBUG_FORTH_WORDS 
3a83				DMARK "AT?" 
3a83 f5				push af  
3a84 3a 98 3a			ld a, (.dmark)  
3a87 32 6e fb			ld (debug_mark),a  
3a8a 3a 99 3a			ld a, (.dmark+1)  
3a8d 32 6f fb			ld (debug_mark+1),a  
3a90 3a 9a 3a			ld a, (.dmark+2)  
3a93 32 70 fb			ld (debug_mark+2),a  
3a96 18 03			jr .pastdmark  
3a98 ..			.dmark: db "AT?"  
3a9b f1			.pastdmark: pop af  
3a9c			endm  
# End of macro DMARK
3a9c				CALLMONITOR 
3a9c cd 6a 17			call break_point_state  
3a9f				endm  
# End of macro CALLMONITOR
3a9f			endif	 
3a9f					; count the number of rows 
3a9f			 
3a9f 06 00				ld b, 0 
3aa1 4f			.atpr:		ld c, a    ; save in case we go below zero 
3aa2 d6 28				sub display_cols 
3aa4 f2 aa 3a				jp p, .atprunder 
3aa7 04					inc b 
3aa8 18 f7				jr .atpr 
3aaa			.atprunder:	 
3aaa			if DEBUG_FORTH_WORDS 
3aaa				DMARK "A?2" 
3aaa f5				push af  
3aab 3a bf 3a			ld a, (.dmark)  
3aae 32 6e fb			ld (debug_mark),a  
3ab1 3a c0 3a			ld a, (.dmark+1)  
3ab4 32 6f fb			ld (debug_mark+1),a  
3ab7 3a c1 3a			ld a, (.dmark+2)  
3aba 32 70 fb			ld (debug_mark+2),a  
3abd 18 03			jr .pastdmark  
3abf ..			.dmark: db "A?2"  
3ac2 f1			.pastdmark: pop af  
3ac3			endm  
# End of macro DMARK
3ac3				CALLMONITOR 
3ac3 cd 6a 17			call break_point_state  
3ac6				endm  
# End of macro CALLMONITOR
3ac6			endif	 
3ac6 26 00				ld h, 0 
3ac8 69					ld l, c 
3ac9 cd fa 1c				call forth_push_numhl 
3acc 68					ld l, b  
3acd cd fa 1c				call forth_push_numhl 
3ad0			 
3ad0			 
3ad0				NEXTW 
3ad0 c3 63 20			jp macro_next 
3ad3				endm 
# End of macro NEXTW
3ad3			 
3ad3			.FB: 
3ad3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ad3 1b				db WORD_SYS_CORE+7             
3ad4 21 3b			dw .EMIT            
3ad6 03				db 2 + 1 
3ad7 .. 00			db "FB",0              
3ada				endm 
# End of macro CWHEAD
3ada			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ada			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ada			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ada			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ada					if DEBUG_FORTH_WORDS_KEY 
3ada						DMARK "FB." 
3ada f5				push af  
3adb 3a ef 3a			ld a, (.dmark)  
3ade 32 6e fb			ld (debug_mark),a  
3ae1 3a f0 3a			ld a, (.dmark+1)  
3ae4 32 6f fb			ld (debug_mark+1),a  
3ae7 3a f1 3a			ld a, (.dmark+2)  
3aea 32 70 fb			ld (debug_mark+2),a  
3aed 18 03			jr .pastdmark  
3aef ..			.dmark: db "FB."  
3af2 f1			.pastdmark: pop af  
3af3			endm  
# End of macro DMARK
3af3						CALLMONITOR 
3af3 cd 6a 17			call break_point_state  
3af6				endm  
# End of macro CALLMONITOR
3af6					endif 
3af6			 
3af6					FORTH_DSP_VALUEHL 
3af6 cd f1 1e			call macro_dsp_valuehl 
3af9				endm 
# End of macro FORTH_DSP_VALUEHL
3af9			 
3af9 7d					ld a, l 
3afa fe 01				cp 1 
3afc 20 05				jr nz, .fbn1 
3afe 21 13 fa				ld hl, display_fb1 
3b01 18 15				jr .fbset 
3b03 fe 02		.fbn1:		cp 2 
3b05 20 05				jr nz, .fbn2 
3b07 21 d1 f8				ld hl, display_fb2 
3b0a 18 0c				jr .fbset 
3b0c fe 03		.fbn2:		cp 3 
3b0e 20 05				jr nz, .fbn3 
3b10 21 72 f9				ld hl, display_fb3 
3b13 18 03				jr .fbset 
3b15			.fbn3:		 ; if invalid number select first 
3b15 21 13 fa				ld hl, display_fb1 
3b18 22 cf f8		.fbset:		ld (display_fb_active), hl 
3b1b			 
3b1b					FORTH_DSP_POP 
3b1b cd a9 1f			call macro_forth_dsp_pop 
3b1e				endm 
# End of macro FORTH_DSP_POP
3b1e			 
3b1e					NEXTW 
3b1e c3 63 20			jp macro_next 
3b21				endm 
# End of macro NEXTW
3b21			 
3b21			 
3b21			.EMIT: 
3b21				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b21 1b				db WORD_SYS_CORE+7             
3b22 72 3b			dw .DOTH            
3b24 05				db 4 + 1 
3b25 .. 00			db "EMIT",0              
3b2a				endm 
# End of macro CWHEAD
3b2a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b2a					; get value off TOS and display it 
3b2a			 
3b2a					if DEBUG_FORTH_WORDS_KEY 
3b2a						DMARK "EMT" 
3b2a f5				push af  
3b2b 3a 3f 3b			ld a, (.dmark)  
3b2e 32 6e fb			ld (debug_mark),a  
3b31 3a 40 3b			ld a, (.dmark+1)  
3b34 32 6f fb			ld (debug_mark+1),a  
3b37 3a 41 3b			ld a, (.dmark+2)  
3b3a 32 70 fb			ld (debug_mark+2),a  
3b3d 18 03			jr .pastdmark  
3b3f ..			.dmark: db "EMT"  
3b42 f1			.pastdmark: pop af  
3b43			endm  
# End of macro DMARK
3b43						CALLMONITOR 
3b43 cd 6a 17			call break_point_state  
3b46				endm  
# End of macro CALLMONITOR
3b46					endif 
3b46			 
3b46					FORTH_DSP_VALUEHL 
3b46 cd f1 1e			call macro_dsp_valuehl 
3b49				endm 
# End of macro FORTH_DSP_VALUEHL
3b49			 
3b49 7d					ld a,l 
3b4a			 
3b4a					; TODO write to display 
3b4a			 
3b4a 32 12 f0				ld (os_input), a 
3b4d 3e 00				ld a, 0 
3b4f 32 13 f0				ld (os_input+1), a 
3b52					 
3b52 3a 3d f8				ld a, (f_cursor_ptr) 
3b55 11 12 f0				ld de, os_input 
3b58 cd fa 0a				call str_at_display 
3b5b			 
3b5b			 
3b5b 3a 1b f8				ld a,(cli_autodisplay) 
3b5e fe 00				cp 0 
3b60 28 03				jr z, .enoupdate 
3b62 cd 0a 0b						call update_display 
3b65					.enoupdate: 
3b65			 
3b65 3a 3d f8				ld a, (f_cursor_ptr) 
3b68 3c					inc a 
3b69 32 3d f8				ld (f_cursor_ptr), a   ; save new pos 
3b6c			 
3b6c			 
3b6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b6c cd a9 1f			call macro_forth_dsp_pop 
3b6f				endm 
# End of macro FORTH_DSP_POP
3b6f			  
3b6f			 
3b6f					NEXTW 
3b6f c3 63 20			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			.DOTH: 
3b72				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b72 1c				db WORD_SYS_CORE+8             
3b73 a2 3b			dw .DOTF            
3b75 03				db 2 + 1 
3b76 .. 00			db ".-",0              
3b79				endm 
# End of macro CWHEAD
3b79			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b79					; get value off TOS and display it 
3b79					if DEBUG_FORTH_WORDS_KEY 
3b79						DMARK "DTD" 
3b79 f5				push af  
3b7a 3a 8e 3b			ld a, (.dmark)  
3b7d 32 6e fb			ld (debug_mark),a  
3b80 3a 8f 3b			ld a, (.dmark+1)  
3b83 32 6f fb			ld (debug_mark+1),a  
3b86 3a 90 3b			ld a, (.dmark+2)  
3b89 32 70 fb			ld (debug_mark+2),a  
3b8c 18 03			jr .pastdmark  
3b8e ..			.dmark: db "DTD"  
3b91 f1			.pastdmark: pop af  
3b92			endm  
# End of macro DMARK
3b92						CALLMONITOR 
3b92 cd 6a 17			call break_point_state  
3b95				endm  
# End of macro CALLMONITOR
3b95					endif 
3b95 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b97 3e 00			ld a, 0 
3b99 32 1c f8			ld (cli_mvdot), a 
3b9c c3 f9 3b			jp .dotgo 
3b9f				NEXTW 
3b9f c3 63 20			jp macro_next 
3ba2				endm 
# End of macro NEXTW
3ba2			.DOTF: 
3ba2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3ba2 1c				db WORD_SYS_CORE+8             
3ba3 d0 3b			dw .DOT            
3ba5 03				db 2 + 1 
3ba6 .. 00			db ".>",0              
3ba9				endm 
# End of macro CWHEAD
3ba9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3ba9					; get value off TOS and display it 
3ba9			        ; TODO BUG adds extra spaces 
3ba9			        ; TODO BUG handle numerics? 
3ba9					if DEBUG_FORTH_WORDS_KEY 
3ba9						DMARK "DTC" 
3ba9 f5				push af  
3baa 3a be 3b			ld a, (.dmark)  
3bad 32 6e fb			ld (debug_mark),a  
3bb0 3a bf 3b			ld a, (.dmark+1)  
3bb3 32 6f fb			ld (debug_mark+1),a  
3bb6 3a c0 3b			ld a, (.dmark+2)  
3bb9 32 70 fb			ld (debug_mark+2),a  
3bbc 18 03			jr .pastdmark  
3bbe ..			.dmark: db "DTC"  
3bc1 f1			.pastdmark: pop af  
3bc2			endm  
# End of macro DMARK
3bc2						CALLMONITOR 
3bc2 cd 6a 17			call break_point_state  
3bc5				endm  
# End of macro CALLMONITOR
3bc5					endif 
3bc5 3e 01			ld a, 1 
3bc7 32 1c f8			ld (cli_mvdot), a 
3bca c3 f9 3b			jp .dotgo 
3bcd				NEXTW 
3bcd c3 63 20			jp macro_next 
3bd0				endm 
# End of macro NEXTW
3bd0			 
3bd0			.DOT: 
3bd0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bd0 1c				db WORD_SYS_CORE+8             
3bd1 5c 3c			dw .CLS            
3bd3 02				db 1 + 1 
3bd4 .. 00			db ".",0              
3bd6				endm 
# End of macro CWHEAD
3bd6			        ; | . ( u -- ) Display TOS | DONE 
3bd6					; get value off TOS and display it 
3bd6			 
3bd6					if DEBUG_FORTH_WORDS_KEY 
3bd6						DMARK "DOT" 
3bd6 f5				push af  
3bd7 3a eb 3b			ld a, (.dmark)  
3bda 32 6e fb			ld (debug_mark),a  
3bdd 3a ec 3b			ld a, (.dmark+1)  
3be0 32 6f fb			ld (debug_mark+1),a  
3be3 3a ed 3b			ld a, (.dmark+2)  
3be6 32 70 fb			ld (debug_mark+2),a  
3be9 18 03			jr .pastdmark  
3beb ..			.dmark: db "DOT"  
3bee f1			.pastdmark: pop af  
3bef			endm  
# End of macro DMARK
3bef						CALLMONITOR 
3bef cd 6a 17			call break_point_state  
3bf2				endm  
# End of macro CALLMONITOR
3bf2					endif 
3bf2 3e 00			ld a, 0 
3bf4 32 1c f8			ld (cli_mvdot), a 
3bf7 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bf9				 
3bf9			 
3bf9			.dotgo: 
3bf9			 
3bf9			; move up type to on stack for parserv5 
3bf9					FORTH_DSP 
3bf9 cd b7 1e			call macro_forth_dsp 
3bfc				endm 
# End of macro FORTH_DSP
3bfc				;FORTH_DSP_VALUE  
3bfc			 
3bfc			if DEBUG_FORTH_DOT 
3bfc				DMARK "DOT" 
3bfc				CALLMONITOR 
3bfc			endif	 
3bfc			;		.print: 
3bfc			 
3bfc 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bfd 23				inc hl   ; position to the actual value 
3bfe fe 01			cp DS_TYPE_STR 
3c00 20 06			jr nz, .dotnum1  
3c02			 
3c02			; display string 
3c02				FORTH_DSP_VALUE  
3c02 cd da 1e			call macro_forth_dsp_value 
3c05				endm 
# End of macro FORTH_DSP_VALUE
3c05 eb				ex de,hl 
3c06 18 11			jr .dotwrite 
3c08			 
3c08			.dotnum1: 
3c08 fe 02			cp DS_TYPE_INUM 
3c0a 20 0c			jr nz, .dotflot 
3c0c			 
3c0c			 
3c0c			; display number 
3c0c			 
3c0c			;	push hl 
3c0c			;	call clear_display 
3c0c			;	pop hl 
3c0c			 
3c0c 5e				ld e, (hl) 
3c0d 23				inc hl 
3c0e 56				ld d, (hl) 
3c0f 21 14 ee			ld hl, scratch 
3c12			if DEBUG_FORTH_DOT 
3c12				DMARK "DT1" 
3c12				CALLMONITOR 
3c12			endif	 
3c12			 
3c12 cd 28 11			call uitoa_16 
3c15 eb				ex de,hl 
3c16			 
3c16			if DEBUG_FORTH_DOT 
3c16				DMARK "DT2" 
3c16				CALLMONITOR 
3c16			endif	 
3c16			 
3c16			;	ld de, os_word_scratch 
3c16 18 01			jr .dotwrite 
3c18			 
3c18 00			.dotflot:   nop 
3c19			; TODO print floating point number 
3c19			 
3c19			.dotwrite:		 
3c19			 
3c19					; if c is set then set all '-' to spaces 
3c19					; need to also take into account .>  
3c19			 
3c19 3e 01				ld a, 1 
3c1b b9					cp c 
3c1c 20 13				jr nz, .nodashswap 
3c1e			 
3c1e					; DE has the string to write, working with HL 
3c1e			 
3c1e 06 ff				ld b, 255 
3c20 d5					push de 
3c21 e1					pop hl 
3c22			 
3c22			if DEBUG_FORTH_DOT 
3c22				DMARK "DT-" 
3c22				CALLMONITOR 
3c22			endif	 
3c22 7e			.dashscan:	ld a, (hl) 
3c23 fe 00				cp 0 
3c25 28 0a				jr z, .nodashswap 
3c27 fe 2d				cp '-' 
3c29 20 03				jr nz, .dashskip 
3c2b 3e 20				ld a, ' ' 
3c2d 77					ld (hl), a 
3c2e 23			.dashskip:	inc hl 
3c2f			if DEBUG_FORTH_DOT 
3c2f				DMARK "D-2" 
3c2f				CALLMONITOR 
3c2f			endif	 
3c2f 10 f1				djnz .dashscan 
3c31			 
3c31			if DEBUG_FORTH_DOT 
3c31				DMARK "D-1" 
3c31				CALLMONITOR 
3c31			endif	 
3c31			 
3c31			.nodashswap: 
3c31			 
3c31 e5					push hl   ; save string start in case we need to advance print 
3c32			 
3c32 3a 3d f8				ld a, (f_cursor_ptr) 
3c35 cd fa 0a				call str_at_display 
3c38 3a 1b f8				ld a,(cli_autodisplay) 
3c3b fe 00				cp 0 
3c3d 28 03				jr z, .noupdate 
3c3f cd 0a 0b						call update_display 
3c42					.noupdate: 
3c42			 
3c42			 
3c42					; see if we need to advance the print position 
3c42			 
3c42 e1					pop hl   ; get back string 
3c43			 
3c43 3a 1c f8				ld a, (cli_mvdot) 
3c46			if DEBUG_FORTH_DOT 
3c46					ld e,a 
3c46				DMARK "D>1" 
3c46				CALLMONITOR 
3c46			endif	 
3c46 fe 00				cp 0 
3c48 28 0c				jr z, .noadv 
3c4a					; yes, lets advance the print position 
3c4a 3e 00				ld a, 0 
3c4c cd 84 11				call strlent 
3c4f 3a 3d f8				ld a, (f_cursor_ptr) 
3c52 85					add a,l 
3c53					;call addatohl 
3c53					;ld a, l 
3c53 32 3d f8				ld (f_cursor_ptr), a   ; save new pos 
3c56			 
3c56			if DEBUG_FORTH_DOT 
3c56				DMARK "D->" 
3c56				CALLMONITOR 
3c56			endif	 
3c56			 
3c56			.noadv:	 
3c56			 
3c56					if DEBUG_FORTH_DOT_WAIT 
3c56							call next_page_prompt 
3c56					endif	 
3c56			; TODO this pop off the stack causes a crash. i dont know why 
3c56			 
3c56			 
3c56			if DEBUG_FORTH_DOT 
3c56				DMARK "DTh" 
3c56				CALLMONITOR 
3c56			endif	 
3c56			 
3c56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c56 cd a9 1f			call macro_forth_dsp_pop 
3c59				endm 
# End of macro FORTH_DSP_POP
3c59			 
3c59			if DEBUG_FORTH_DOT 
3c59				DMARK "DTi" 
3c59				CALLMONITOR 
3c59			endif	 
3c59			 
3c59			 
3c59					NEXTW 
3c59 c3 63 20			jp macro_next 
3c5c				endm 
# End of macro NEXTW
3c5c			 
3c5c			.CLS: 
3c5c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c5c 35				db WORD_SYS_CORE+33             
3c5d 89 3c			dw .DRAW            
3c5f 04				db 3 + 1 
3c60 .. 00			db "CLS",0              
3c64				endm 
# End of macro CWHEAD
3c64			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c64					if DEBUG_FORTH_WORDS_KEY 
3c64						DMARK "CLS" 
3c64 f5				push af  
3c65 3a 79 3c			ld a, (.dmark)  
3c68 32 6e fb			ld (debug_mark),a  
3c6b 3a 7a 3c			ld a, (.dmark+1)  
3c6e 32 6f fb			ld (debug_mark+1),a  
3c71 3a 7b 3c			ld a, (.dmark+2)  
3c74 32 70 fb			ld (debug_mark+2),a  
3c77 18 03			jr .pastdmark  
3c79 ..			.dmark: db "CLS"  
3c7c f1			.pastdmark: pop af  
3c7d			endm  
# End of macro DMARK
3c7d						CALLMONITOR 
3c7d cd 6a 17			call break_point_state  
3c80				endm  
# End of macro CALLMONITOR
3c80					endif 
3c80 cd e7 0a				call clear_display 
3c83 c3 97 3d				jp .home		; and home cursor 
3c86					NEXTW 
3c86 c3 63 20			jp macro_next 
3c89				endm 
# End of macro NEXTW
3c89			 
3c89			.DRAW: 
3c89				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c89 36				db WORD_SYS_CORE+34             
3c8a b4 3c			dw .DUMP            
3c8c 05				db 4 + 1 
3c8d .. 00			db "DRAW",0              
3c92				endm 
# End of macro CWHEAD
3c92			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c92					if DEBUG_FORTH_WORDS_KEY 
3c92						DMARK "DRW" 
3c92 f5				push af  
3c93 3a a7 3c			ld a, (.dmark)  
3c96 32 6e fb			ld (debug_mark),a  
3c99 3a a8 3c			ld a, (.dmark+1)  
3c9c 32 6f fb			ld (debug_mark+1),a  
3c9f 3a a9 3c			ld a, (.dmark+2)  
3ca2 32 70 fb			ld (debug_mark+2),a  
3ca5 18 03			jr .pastdmark  
3ca7 ..			.dmark: db "DRW"  
3caa f1			.pastdmark: pop af  
3cab			endm  
# End of macro DMARK
3cab						CALLMONITOR 
3cab cd 6a 17			call break_point_state  
3cae				endm  
# End of macro CALLMONITOR
3cae					endif 
3cae cd 0a 0b				call update_display 
3cb1					NEXTW 
3cb1 c3 63 20			jp macro_next 
3cb4				endm 
# End of macro NEXTW
3cb4			 
3cb4			.DUMP: 
3cb4				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3cb4 37				db WORD_SYS_CORE+35             
3cb5 ec 3c			dw .CDUMP            
3cb7 05				db 4 + 1 
3cb8 .. 00			db "DUMP",0              
3cbd				endm 
# End of macro CWHEAD
3cbd			; | DUMP ( x -- ) With address x display dump   | DONE 
3cbd			; TODO pop address to use off of the stack 
3cbd					if DEBUG_FORTH_WORDS_KEY 
3cbd						DMARK "DUM" 
3cbd f5				push af  
3cbe 3a d2 3c			ld a, (.dmark)  
3cc1 32 6e fb			ld (debug_mark),a  
3cc4 3a d3 3c			ld a, (.dmark+1)  
3cc7 32 6f fb			ld (debug_mark+1),a  
3cca 3a d4 3c			ld a, (.dmark+2)  
3ccd 32 70 fb			ld (debug_mark+2),a  
3cd0 18 03			jr .pastdmark  
3cd2 ..			.dmark: db "DUM"  
3cd5 f1			.pastdmark: pop af  
3cd6			endm  
# End of macro DMARK
3cd6						CALLMONITOR 
3cd6 cd 6a 17			call break_point_state  
3cd9				endm  
# End of macro CALLMONITOR
3cd9					endif 
3cd9 cd e7 0a				call clear_display 
3cdc			 
3cdc					; get address 
3cdc			 
3cdc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cdc cd f1 1e			call macro_dsp_valuehl 
3cdf				endm 
# End of macro FORTH_DSP_VALUEHL
3cdf				 
3cdf					; save it for cdump 
3cdf			 
3cdf 22 37 f1				ld (os_cur_ptr),hl 
3ce2			 
3ce2					; destroy value TOS 
3ce2			 
3ce2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ce2 cd a9 1f			call macro_forth_dsp_pop 
3ce5				endm 
# End of macro FORTH_DSP_POP
3ce5			 
3ce5 cd 7a 1b				call dumpcont	; skip old style of param parsing	 
3ce8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ce9					NEXTW 
3ce9 c3 63 20			jp macro_next 
3cec				endm 
# End of macro NEXTW
3cec			.CDUMP: 
3cec				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3cec 38				db WORD_SYS_CORE+36             
3ced 1c 3d			dw .DAT            
3cef 06				db 5 + 1 
3cf0 .. 00			db "CDUMP",0              
3cf6				endm 
# End of macro CWHEAD
3cf6			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3cf6					if DEBUG_FORTH_WORDS_KEY 
3cf6						DMARK "CDP" 
3cf6 f5				push af  
3cf7 3a 0b 3d			ld a, (.dmark)  
3cfa 32 6e fb			ld (debug_mark),a  
3cfd 3a 0c 3d			ld a, (.dmark+1)  
3d00 32 6f fb			ld (debug_mark+1),a  
3d03 3a 0d 3d			ld a, (.dmark+2)  
3d06 32 70 fb			ld (debug_mark+2),a  
3d09 18 03			jr .pastdmark  
3d0b ..			.dmark: db "CDP"  
3d0e f1			.pastdmark: pop af  
3d0f			endm  
# End of macro DMARK
3d0f						CALLMONITOR 
3d0f cd 6a 17			call break_point_state  
3d12				endm  
# End of macro CALLMONITOR
3d12					endif 
3d12 cd e7 0a				call clear_display 
3d15 cd 7a 1b				call dumpcont	 
3d18 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d19					NEXTW 
3d19 c3 63 20			jp macro_next 
3d1c				endm 
# End of macro NEXTW
3d1c			 
3d1c			 
3d1c			 
3d1c			 
3d1c			.DAT: 
3d1c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d1c 3d				db WORD_SYS_CORE+41             
3d1d 72 3d			dw .HOME            
3d1f 03				db 2 + 1 
3d20 .. 00			db "AT",0              
3d23				endm 
# End of macro CWHEAD
3d23			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d23					if DEBUG_FORTH_WORDS_KEY 
3d23						DMARK "AT." 
3d23 f5				push af  
3d24 3a 38 3d			ld a, (.dmark)  
3d27 32 6e fb			ld (debug_mark),a  
3d2a 3a 39 3d			ld a, (.dmark+1)  
3d2d 32 6f fb			ld (debug_mark+1),a  
3d30 3a 3a 3d			ld a, (.dmark+2)  
3d33 32 70 fb			ld (debug_mark+2),a  
3d36 18 03			jr .pastdmark  
3d38 ..			.dmark: db "AT."  
3d3b f1			.pastdmark: pop af  
3d3c			endm  
# End of macro DMARK
3d3c						CALLMONITOR 
3d3c cd 6a 17			call break_point_state  
3d3f				endm  
# End of macro CALLMONITOR
3d3f					endif 
3d3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d3f cd f1 1e			call macro_dsp_valuehl 
3d42				endm 
# End of macro FORTH_DSP_VALUEHL
3d42			 
3d42			 
3d42					; TODO save cursor row 
3d42 7d					ld a,l 
3d43 fe 02				cp 2 
3d45 20 04				jr nz, .crow3 
3d47 3e 28				ld a, display_row_2 
3d49 18 12				jr .ccol1 
3d4b fe 03		.crow3:		cp 3 
3d4d 20 04				jr nz, .crow4 
3d4f 3e 50				ld a, display_row_3 
3d51 18 0a				jr .ccol1 
3d53 fe 04		.crow4:		cp 4 
3d55 20 04				jr nz, .crow1 
3d57 3e 78				ld a, display_row_4 
3d59 18 02				jr .ccol1 
3d5b 3e 00		.crow1:		ld a,display_row_1 
3d5d f5			.ccol1:		push af			; got row offset 
3d5e 6f					ld l,a 
3d5f 26 00				ld h,0 
3d61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d61 cd a9 1f			call macro_forth_dsp_pop 
3d64				endm 
# End of macro FORTH_DSP_POP
3d64					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d64 cd f1 1e			call macro_dsp_valuehl 
3d67				endm 
# End of macro FORTH_DSP_VALUEHL
3d67					; TODO save cursor col 
3d67 f1					pop af 
3d68 85					add l		; add col offset 
3d69 32 3d f8				ld (f_cursor_ptr), a 
3d6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d6c cd a9 1f			call macro_forth_dsp_pop 
3d6f				endm 
# End of macro FORTH_DSP_POP
3d6f			 
3d6f					; calculate  
3d6f			 
3d6f					NEXTW 
3d6f c3 63 20			jp macro_next 
3d72				endm 
# End of macro NEXTW
3d72			 
3d72			 
3d72			.HOME: 
3d72				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d72 41				db WORD_SYS_CORE+45             
3d73 9f 3d			dw .SPACE            
3d75 05				db 4 + 1 
3d76 .. 00			db "HOME",0              
3d7b				endm 
# End of macro CWHEAD
3d7b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d7b					if DEBUG_FORTH_WORDS_KEY 
3d7b						DMARK "HOM" 
3d7b f5				push af  
3d7c 3a 90 3d			ld a, (.dmark)  
3d7f 32 6e fb			ld (debug_mark),a  
3d82 3a 91 3d			ld a, (.dmark+1)  
3d85 32 6f fb			ld (debug_mark+1),a  
3d88 3a 92 3d			ld a, (.dmark+2)  
3d8b 32 70 fb			ld (debug_mark+2),a  
3d8e 18 03			jr .pastdmark  
3d90 ..			.dmark: db "HOM"  
3d93 f1			.pastdmark: pop af  
3d94			endm  
# End of macro DMARK
3d94						CALLMONITOR 
3d94 cd 6a 17			call break_point_state  
3d97				endm  
# End of macro CALLMONITOR
3d97					endif 
3d97 3e 00		.home:		ld a, 0		; and home cursor 
3d99 32 3d f8				ld (f_cursor_ptr), a 
3d9c					NEXTW 
3d9c c3 63 20			jp macro_next 
3d9f				endm 
# End of macro NEXTW
3d9f			 
3d9f			 
3d9f			.SPACE: 
3d9f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d9f 46				db WORD_SYS_CORE+50             
3da0 cd 3d			dw .SPACES            
3da2 03				db 2 + 1 
3da3 .. 00			db "BL",0              
3da6				endm 
# End of macro CWHEAD
3da6			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3da6					if DEBUG_FORTH_WORDS_KEY 
3da6						DMARK "BL." 
3da6 f5				push af  
3da7 3a bb 3d			ld a, (.dmark)  
3daa 32 6e fb			ld (debug_mark),a  
3dad 3a bc 3d			ld a, (.dmark+1)  
3db0 32 6f fb			ld (debug_mark+1),a  
3db3 3a bd 3d			ld a, (.dmark+2)  
3db6 32 70 fb			ld (debug_mark+2),a  
3db9 18 03			jr .pastdmark  
3dbb ..			.dmark: db "BL."  
3dbe f1			.pastdmark: pop af  
3dbf			endm  
# End of macro DMARK
3dbf						CALLMONITOR 
3dbf cd 6a 17			call break_point_state  
3dc2				endm  
# End of macro CALLMONITOR
3dc2					endif 
3dc2 21 cb 3d				ld hl, .blstr 
3dc5 cd 68 1d				call forth_push_str 
3dc8					 
3dc8				       NEXTW 
3dc8 c3 63 20			jp macro_next 
3dcb				endm 
# End of macro NEXTW
3dcb			 
3dcb .. 00		.blstr: db " ", 0 
3dcd			 
3dcd			.SPACES: 
3dcd				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3dcd 47				db WORD_SYS_CORE+51             
3dce 68 3e			dw .SCROLL            
3dd0 07				db 6 + 1 
3dd1 .. 00			db "SPACES",0              
3dd8				endm 
# End of macro CWHEAD
3dd8			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3dd8					if DEBUG_FORTH_WORDS_KEY 
3dd8						DMARK "SPS" 
3dd8 f5				push af  
3dd9 3a ed 3d			ld a, (.dmark)  
3ddc 32 6e fb			ld (debug_mark),a  
3ddf 3a ee 3d			ld a, (.dmark+1)  
3de2 32 6f fb			ld (debug_mark+1),a  
3de5 3a ef 3d			ld a, (.dmark+2)  
3de8 32 70 fb			ld (debug_mark+2),a  
3deb 18 03			jr .pastdmark  
3ded ..			.dmark: db "SPS"  
3df0 f1			.pastdmark: pop af  
3df1			endm  
# End of macro DMARK
3df1						CALLMONITOR 
3df1 cd 6a 17			call break_point_state  
3df4				endm  
# End of macro CALLMONITOR
3df4					endif 
3df4			 
3df4			 
3df4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3df4 cd f1 1e			call macro_dsp_valuehl 
3df7				endm 
# End of macro FORTH_DSP_VALUEHL
3df7			 
3df7			;		push hl    ; u 
3df7					if DEBUG_FORTH_WORDS 
3df7						DMARK "SPA" 
3df7 f5				push af  
3df8 3a 0c 3e			ld a, (.dmark)  
3dfb 32 6e fb			ld (debug_mark),a  
3dfe 3a 0d 3e			ld a, (.dmark+1)  
3e01 32 6f fb			ld (debug_mark+1),a  
3e04 3a 0e 3e			ld a, (.dmark+2)  
3e07 32 70 fb			ld (debug_mark+2),a  
3e0a 18 03			jr .pastdmark  
3e0c ..			.dmark: db "SPA"  
3e0f f1			.pastdmark: pop af  
3e10			endm  
# End of macro DMARK
3e10						CALLMONITOR 
3e10 cd 6a 17			call break_point_state  
3e13				endm  
# End of macro CALLMONITOR
3e13					endif 
3e13			 
3e13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e13 cd a9 1f			call macro_forth_dsp_pop 
3e16				endm 
# End of macro FORTH_DSP_POP
3e16			;		pop hl 
3e16 4d					ld c, l 
3e17 06 00				ld b, 0 
3e19 21 14 ee				ld hl, scratch  
3e1c			 
3e1c					if DEBUG_FORTH_WORDS 
3e1c						DMARK "SP2" 
3e1c f5				push af  
3e1d 3a 31 3e			ld a, (.dmark)  
3e20 32 6e fb			ld (debug_mark),a  
3e23 3a 32 3e			ld a, (.dmark+1)  
3e26 32 6f fb			ld (debug_mark+1),a  
3e29 3a 33 3e			ld a, (.dmark+2)  
3e2c 32 70 fb			ld (debug_mark+2),a  
3e2f 18 03			jr .pastdmark  
3e31 ..			.dmark: db "SP2"  
3e34 f1			.pastdmark: pop af  
3e35			endm  
# End of macro DMARK
3e35						CALLMONITOR 
3e35 cd 6a 17			call break_point_state  
3e38				endm  
# End of macro CALLMONITOR
3e38					endif 
3e38 3e 20				ld a, ' ' 
3e3a c5			.spaces1:	push bc 
3e3b 77					ld (hl),a 
3e3c 23					inc hl 
3e3d c1					pop bc 
3e3e 10 fa				djnz .spaces1 
3e40 3e 00				ld a,0 
3e42 77					ld (hl),a 
3e43 21 14 ee				ld hl, scratch 
3e46					if DEBUG_FORTH_WORDS 
3e46						DMARK "SP3" 
3e46 f5				push af  
3e47 3a 5b 3e			ld a, (.dmark)  
3e4a 32 6e fb			ld (debug_mark),a  
3e4d 3a 5c 3e			ld a, (.dmark+1)  
3e50 32 6f fb			ld (debug_mark+1),a  
3e53 3a 5d 3e			ld a, (.dmark+2)  
3e56 32 70 fb			ld (debug_mark+2),a  
3e59 18 03			jr .pastdmark  
3e5b ..			.dmark: db "SP3"  
3e5e f1			.pastdmark: pop af  
3e5f			endm  
# End of macro DMARK
3e5f						CALLMONITOR 
3e5f cd 6a 17			call break_point_state  
3e62				endm  
# End of macro CALLMONITOR
3e62					endif 
3e62 cd 63 1e				call forth_apush 
3e65			 
3e65				       NEXTW 
3e65 c3 63 20			jp macro_next 
3e68				endm 
# End of macro NEXTW
3e68			 
3e68			 
3e68			 
3e68			.SCROLL: 
3e68				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e68 53				db WORD_SYS_CORE+63             
3e69 95 3e			dw .SCROLLD            
3e6b 07				db 6 + 1 
3e6c .. 00			db "SCROLL",0              
3e73				endm 
# End of macro CWHEAD
3e73			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e73					if DEBUG_FORTH_WORDS_KEY 
3e73						DMARK "SCR" 
3e73 f5				push af  
3e74 3a 88 3e			ld a, (.dmark)  
3e77 32 6e fb			ld (debug_mark),a  
3e7a 3a 89 3e			ld a, (.dmark+1)  
3e7d 32 6f fb			ld (debug_mark+1),a  
3e80 3a 8a 3e			ld a, (.dmark+2)  
3e83 32 70 fb			ld (debug_mark+2),a  
3e86 18 03			jr .pastdmark  
3e88 ..			.dmark: db "SCR"  
3e8b f1			.pastdmark: pop af  
3e8c			endm  
# End of macro DMARK
3e8c						CALLMONITOR 
3e8c cd 6a 17			call break_point_state  
3e8f				endm  
# End of macro CALLMONITOR
3e8f					endif 
3e8f			 
3e8f cd a9 0a			call scroll_up 
3e92			;	call update_display 
3e92			 
3e92					NEXTW 
3e92 c3 63 20			jp macro_next 
3e95				endm 
# End of macro NEXTW
3e95			 
3e95			 
3e95			 
3e95			;		; get dir 
3e95			; 
3e95			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e95			; 
3e95			;		push hl 
3e95			; 
3e95			;		; destroy value TOS 
3e95			; 
3e95			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e95			; 
3e95			;		; get count 
3e95			; 
3e95			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e95			; 
3e95			;		push hl 
3e95			; 
3e95			;		; destroy value TOS 
3e95			; 
3e95			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e95			; 
3e95			;		; one value on hl get other one back 
3e95			; 
3e95			;		pop bc    ; count 
3e95			; 
3e95			;		pop de   ; dir 
3e95			; 
3e95			; 
3e95			;		ld b, c 
3e95			; 
3e95			;.scrolldir:     push bc 
3e95			;		push de 
3e95			; 
3e95			;		ld a, 0 
3e95			;		cp e 
3e95			;		jr z, .scrollup  
3e95			;		call scroll_down 
3e95			;		jr .scrollnext 
3e95			;.scrollup:	call scroll_up 
3e95			; 
3e95			;		 
3e95			;.scrollnext: 
3e95			;		pop de 
3e95			;		pop bc 
3e95			;		djnz .scrolldir 
3e95			; 
3e95			; 
3e95			; 
3e95			; 
3e95			; 
3e95			;		NEXTW 
3e95			 
3e95			.SCROLLD: 
3e95				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e95 53				db WORD_SYS_CORE+63             
3e96 c3 3e			dw .ATQ            
3e98 08				db 7 + 1 
3e99 .. 00			db "SCROLLD",0              
3ea1				endm 
# End of macro CWHEAD
3ea1			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ea1					if DEBUG_FORTH_WORDS_KEY 
3ea1						DMARK "SCD" 
3ea1 f5				push af  
3ea2 3a b6 3e			ld a, (.dmark)  
3ea5 32 6e fb			ld (debug_mark),a  
3ea8 3a b7 3e			ld a, (.dmark+1)  
3eab 32 6f fb			ld (debug_mark+1),a  
3eae 3a b8 3e			ld a, (.dmark+2)  
3eb1 32 70 fb			ld (debug_mark+2),a  
3eb4 18 03			jr .pastdmark  
3eb6 ..			.dmark: db "SCD"  
3eb9 f1			.pastdmark: pop af  
3eba			endm  
# End of macro DMARK
3eba						CALLMONITOR 
3eba cd 6a 17			call break_point_state  
3ebd				endm  
# End of macro CALLMONITOR
3ebd					endif 
3ebd			 
3ebd cd cd 0a			call scroll_down 
3ec0			;	call update_display 
3ec0			 
3ec0					NEXTW 
3ec0 c3 63 20			jp macro_next 
3ec3				endm 
# End of macro NEXTW
3ec3			 
3ec3			 
3ec3			.ATQ: 
3ec3				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ec3 62				db WORD_SYS_CORE+78             
3ec4 21 3f			dw .AUTODSP            
3ec6 04				db 3 + 1 
3ec7 .. 00			db "AT@",0              
3ecb				endm 
# End of macro CWHEAD
3ecb			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ecb					if DEBUG_FORTH_WORDS_KEY 
3ecb						DMARK "ATA" 
3ecb f5				push af  
3ecc 3a e0 3e			ld a, (.dmark)  
3ecf 32 6e fb			ld (debug_mark),a  
3ed2 3a e1 3e			ld a, (.dmark+1)  
3ed5 32 6f fb			ld (debug_mark+1),a  
3ed8 3a e2 3e			ld a, (.dmark+2)  
3edb 32 70 fb			ld (debug_mark+2),a  
3ede 18 03			jr .pastdmark  
3ee0 ..			.dmark: db "ATA"  
3ee3 f1			.pastdmark: pop af  
3ee4			endm  
# End of macro DMARK
3ee4						CALLMONITOR 
3ee4 cd 6a 17			call break_point_state  
3ee7				endm  
# End of macro CALLMONITOR
3ee7					endif 
3ee7			 
3ee7			 
3ee7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee7 cd f1 1e			call macro_dsp_valuehl 
3eea				endm 
# End of macro FORTH_DSP_VALUEHL
3eea			 
3eea					; TODO save cursor row 
3eea 7d					ld a,l 
3eeb fe 02				cp 2 
3eed 20 04				jr nz, .crow3aq 
3eef 3e 28				ld a, display_row_2 
3ef1 18 12				jr .ccol1aq 
3ef3 fe 03		.crow3aq:		cp 3 
3ef5 20 04				jr nz, .crow4aq 
3ef7 3e 50				ld a, display_row_3 
3ef9 18 0a				jr .ccol1aq 
3efb fe 04		.crow4aq:		cp 4 
3efd 20 04				jr nz, .crow1aq 
3eff 3e 78				ld a, display_row_4 
3f01 18 02				jr .ccol1aq 
3f03 3e 00		.crow1aq:		ld a,display_row_1 
3f05 f5			.ccol1aq:		push af			; got row offset 
3f06 6f					ld l,a 
3f07 26 00				ld h,0 
3f09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f09 cd a9 1f			call macro_forth_dsp_pop 
3f0c				endm 
# End of macro FORTH_DSP_POP
3f0c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f0c cd f1 1e			call macro_dsp_valuehl 
3f0f				endm 
# End of macro FORTH_DSP_VALUEHL
3f0f					; TODO save cursor col 
3f0f f1					pop af 
3f10 85					add l		; add col offset 
3f11			 
3f11					; add current frame buffer address 
3f11 2a cf f8				ld hl, (display_fb_active) 
3f14 cd 1b 0d				call addatohl 
3f17			 
3f17			 
3f17			 
3f17			 
3f17					; get char frame buffer location offset in hl 
3f17			 
3f17 7e					ld a,(hl) 
3f18 26 00				ld h, 0 
3f1a 6f					ld l, a 
3f1b			 
3f1b cd fa 1c				call forth_push_numhl 
3f1e			 
3f1e			 
3f1e					NEXTW 
3f1e c3 63 20			jp macro_next 
3f21				endm 
# End of macro NEXTW
3f21			 
3f21			.AUTODSP: 
3f21				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f21 63				db WORD_SYS_CORE+79             
3f22 37 3f			dw .MENU            
3f24 05				db 4 + 1 
3f25 .. 00			db "ADSP",0              
3f2a				endm 
# End of macro CWHEAD
3f2a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f2a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f2a			 
3f2a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f2a cd f1 1e			call macro_dsp_valuehl 
3f2d				endm 
# End of macro FORTH_DSP_VALUEHL
3f2d			 
3f2d			;		push hl 
3f2d			 
3f2d					; destroy value TOS 
3f2d			 
3f2d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f2d cd a9 1f			call macro_forth_dsp_pop 
3f30				endm 
# End of macro FORTH_DSP_POP
3f30			 
3f30			;		pop hl 
3f30			 
3f30 7d					ld a,l 
3f31 32 1b f8				ld (cli_autodisplay), a 
3f34				       NEXTW 
3f34 c3 63 20			jp macro_next 
3f37				endm 
# End of macro NEXTW
3f37			 
3f37			.MENU: 
3f37				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f37 70				db WORD_SYS_CORE+92             
3f38 e0 3f			dw .ENDDISPLAY            
3f3a 05				db 4 + 1 
3f3b .. 00			db "MENU",0              
3f40				endm 
# End of macro CWHEAD
3f40			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f40			 
3f40			;		; get number of items on the stack 
3f40			; 
3f40				 
3f40					FORTH_DSP_VALUEHL 
3f40 cd f1 1e			call macro_dsp_valuehl 
3f43				endm 
# End of macro FORTH_DSP_VALUEHL
3f43				 
3f43					if DEBUG_FORTH_WORDS_KEY 
3f43						DMARK "MNU" 
3f43 f5				push af  
3f44 3a 58 3f			ld a, (.dmark)  
3f47 32 6e fb			ld (debug_mark),a  
3f4a 3a 59 3f			ld a, (.dmark+1)  
3f4d 32 6f fb			ld (debug_mark+1),a  
3f50 3a 5a 3f			ld a, (.dmark+2)  
3f53 32 70 fb			ld (debug_mark+2),a  
3f56 18 03			jr .pastdmark  
3f58 ..			.dmark: db "MNU"  
3f5b f1			.pastdmark: pop af  
3f5c			endm  
# End of macro DMARK
3f5c						CALLMONITOR 
3f5c cd 6a 17			call break_point_state  
3f5f				endm  
# End of macro CALLMONITOR
3f5f					endif 
3f5f			 
3f5f 45					ld b, l	 
3f60 05					dec b 
3f61			 
3f61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f61 cd a9 1f			call macro_forth_dsp_pop 
3f64				endm 
# End of macro FORTH_DSP_POP
3f64			 
3f64			 
3f64					; go directly through the stack to pluck out the string pointers and build an array 
3f64			 
3f64			;		FORTH_DSP 
3f64			 
3f64					; hl contains top most stack item 
3f64				 
3f64 11 14 ee				ld de, scratch 
3f67			 
3f67			.mbuild: 
3f67			 
3f67					FORTH_DSP_VALUEHL 
3f67 cd f1 1e			call macro_dsp_valuehl 
3f6a				endm 
# End of macro FORTH_DSP_VALUEHL
3f6a			 
3f6a					if DEBUG_FORTH_WORDS 
3f6a						DMARK "MN3" 
3f6a f5				push af  
3f6b 3a 7f 3f			ld a, (.dmark)  
3f6e 32 6e fb			ld (debug_mark),a  
3f71 3a 80 3f			ld a, (.dmark+1)  
3f74 32 6f fb			ld (debug_mark+1),a  
3f77 3a 81 3f			ld a, (.dmark+2)  
3f7a 32 70 fb			ld (debug_mark+2),a  
3f7d 18 03			jr .pastdmark  
3f7f ..			.dmark: db "MN3"  
3f82 f1			.pastdmark: pop af  
3f83			endm  
# End of macro DMARK
3f83						CALLMONITOR 
3f83 cd 6a 17			call break_point_state  
3f86				endm  
# End of macro CALLMONITOR
3f86					endif 
3f86 eb					ex de, hl 
3f87 73					ld (hl), e 
3f88 23					inc hl 
3f89 72					ld (hl), d 
3f8a 23					inc hl 
3f8b eb					ex de, hl 
3f8c			 
3f8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f8c cd a9 1f			call macro_forth_dsp_pop 
3f8f				endm 
# End of macro FORTH_DSP_POP
3f8f			 
3f8f 10 d6				djnz .mbuild 
3f91			 
3f91					; done add term 
3f91			 
3f91 eb					ex de, hl 
3f92 36 00				ld (hl), 0 
3f94 23					inc hl 
3f95 36 00				ld (hl), 0 
3f97			 
3f97				 
3f97					 
3f97 21 14 ee				ld hl, scratch 
3f9a			 
3f9a					if DEBUG_FORTH_WORDS 
3f9a						DMARK "MNx" 
3f9a f5				push af  
3f9b 3a af 3f			ld a, (.dmark)  
3f9e 32 6e fb			ld (debug_mark),a  
3fa1 3a b0 3f			ld a, (.dmark+1)  
3fa4 32 6f fb			ld (debug_mark+1),a  
3fa7 3a b1 3f			ld a, (.dmark+2)  
3faa 32 70 fb			ld (debug_mark+2),a  
3fad 18 03			jr .pastdmark  
3faf ..			.dmark: db "MNx"  
3fb2 f1			.pastdmark: pop af  
3fb3			endm  
# End of macro DMARK
3fb3						CALLMONITOR 
3fb3 cd 6a 17			call break_point_state  
3fb6				endm  
# End of macro CALLMONITOR
3fb6					endif 
3fb6			 
3fb6			 
3fb6			 
3fb6 3e 00				ld a, 0 
3fb8 cd 18 0b				call menu 
3fbb			 
3fbb			 
3fbb 6f					ld l, a 
3fbc 26 00				ld h, 0 
3fbe			 
3fbe					if DEBUG_FORTH_WORDS 
3fbe						DMARK "MNr" 
3fbe f5				push af  
3fbf 3a d3 3f			ld a, (.dmark)  
3fc2 32 6e fb			ld (debug_mark),a  
3fc5 3a d4 3f			ld a, (.dmark+1)  
3fc8 32 6f fb			ld (debug_mark+1),a  
3fcb 3a d5 3f			ld a, (.dmark+2)  
3fce 32 70 fb			ld (debug_mark+2),a  
3fd1 18 03			jr .pastdmark  
3fd3 ..			.dmark: db "MNr"  
3fd6 f1			.pastdmark: pop af  
3fd7			endm  
# End of macro DMARK
3fd7						CALLMONITOR 
3fd7 cd 6a 17			call break_point_state  
3fda				endm  
# End of macro CALLMONITOR
3fda					endif 
3fda			 
3fda cd fa 1c				call forth_push_numhl 
3fdd			 
3fdd			 
3fdd			 
3fdd			 
3fdd				       NEXTW 
3fdd c3 63 20			jp macro_next 
3fe0				endm 
# End of macro NEXTW
3fe0			 
3fe0			 
3fe0			.ENDDISPLAY: 
3fe0			 
3fe0			; eof 
# End of file forth_words_display.asm
3fe0			include "forth_words_str.asm" 
3fe0			 
3fe0			; | ## String Words 
3fe0			 
3fe0			.PTR:   
3fe0			 
3fe0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fe0 48				db WORD_SYS_CORE+52             
3fe1 0d 40			dw .STYPE            
3fe3 04				db 3 + 1 
3fe4 .. 00			db "PTR",0              
3fe8				endm 
# End of macro CWHEAD
3fe8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3fe8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3fe8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3fe8			 
3fe8					if DEBUG_FORTH_WORDS_KEY 
3fe8						DMARK "PTR" 
3fe8 f5				push af  
3fe9 3a fd 3f			ld a, (.dmark)  
3fec 32 6e fb			ld (debug_mark),a  
3fef 3a fe 3f			ld a, (.dmark+1)  
3ff2 32 6f fb			ld (debug_mark+1),a  
3ff5 3a ff 3f			ld a, (.dmark+2)  
3ff8 32 70 fb			ld (debug_mark+2),a  
3ffb 18 03			jr .pastdmark  
3ffd ..			.dmark: db "PTR"  
4000 f1			.pastdmark: pop af  
4001			endm  
# End of macro DMARK
4001						CALLMONITOR 
4001 cd 6a 17			call break_point_state  
4004				endm  
# End of macro CALLMONITOR
4004					endif 
4004					FORTH_DSP_VALUEHL 
4004 cd f1 1e			call macro_dsp_valuehl 
4007				endm 
# End of macro FORTH_DSP_VALUEHL
4007 cd fa 1c				call forth_push_numhl 
400a			 
400a			 
400a					NEXTW 
400a c3 63 20			jp macro_next 
400d				endm 
# End of macro NEXTW
400d			.STYPE: 
400d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
400d 48				db WORD_SYS_CORE+52             
400e 5c 40			dw .UPPER            
4010 06				db 5 + 1 
4011 .. 00			db "STYPE",0              
4017				endm 
# End of macro CWHEAD
4017			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4017					if DEBUG_FORTH_WORDS_KEY 
4017						DMARK "STY" 
4017 f5				push af  
4018 3a 2c 40			ld a, (.dmark)  
401b 32 6e fb			ld (debug_mark),a  
401e 3a 2d 40			ld a, (.dmark+1)  
4021 32 6f fb			ld (debug_mark+1),a  
4024 3a 2e 40			ld a, (.dmark+2)  
4027 32 70 fb			ld (debug_mark+2),a  
402a 18 03			jr .pastdmark  
402c ..			.dmark: db "STY"  
402f f1			.pastdmark: pop af  
4030			endm  
# End of macro DMARK
4030						CALLMONITOR 
4030 cd 6a 17			call break_point_state  
4033				endm  
# End of macro CALLMONITOR
4033					endif 
4033					FORTH_DSP 
4033 cd b7 1e			call macro_forth_dsp 
4036				endm 
# End of macro FORTH_DSP
4036					;v5 FORTH_DSP_VALUE 
4036			 
4036 7e					ld a, (hl) 
4037			 
4037 f5					push af 
4038			 
4038			; Dont destroy TOS		FORTH_DSP_POP 
4038			 
4038 f1					pop af 
4039			 
4039 fe 01				cp DS_TYPE_STR 
403b 28 09				jr z, .typestr 
403d			 
403d fe 02				cp DS_TYPE_INUM 
403f 28 0a				jr z, .typeinum 
4041			 
4041 21 5a 40				ld hl, .tna 
4044 18 0a				jr .tpush 
4046			 
4046 21 56 40		.typestr:	ld hl, .tstr 
4049 18 05				jr .tpush 
404b 21 58 40		.typeinum:	ld hl, .tinum 
404e 18 00				jr .tpush 
4050			 
4050			.tpush: 
4050			 
4050 cd 68 1d				call forth_push_str 
4053			 
4053					NEXTW 
4053 c3 63 20			jp macro_next 
4056				endm 
# End of macro NEXTW
4056 .. 00		.tstr:	db "s",0 
4058 .. 00		.tinum:  db "i",0 
405a .. 00		.tna:   db "?", 0 
405c			 
405c			 
405c			.UPPER: 
405c				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
405c 48				db WORD_SYS_CORE+52             
405d 97 40			dw .LOWER            
405f 06				db 5 + 1 
4060 .. 00			db "UPPER",0              
4066				endm 
# End of macro CWHEAD
4066			; | UPPER ( s -- s ) Upper case string s  | DONE 
4066					if DEBUG_FORTH_WORDS_KEY 
4066						DMARK "UPR" 
4066 f5				push af  
4067 3a 7b 40			ld a, (.dmark)  
406a 32 6e fb			ld (debug_mark),a  
406d 3a 7c 40			ld a, (.dmark+1)  
4070 32 6f fb			ld (debug_mark+1),a  
4073 3a 7d 40			ld a, (.dmark+2)  
4076 32 70 fb			ld (debug_mark+2),a  
4079 18 03			jr .pastdmark  
407b ..			.dmark: db "UPR"  
407e f1			.pastdmark: pop af  
407f			endm  
# End of macro DMARK
407f						CALLMONITOR 
407f cd 6a 17			call break_point_state  
4082				endm  
# End of macro CALLMONITOR
4082					endif 
4082			 
4082					FORTH_DSP 
4082 cd b7 1e			call macro_forth_dsp 
4085				endm 
# End of macro FORTH_DSP
4085					 
4085			; TODO check is string type 
4085			 
4085					FORTH_DSP_VALUEHL 
4085 cd f1 1e			call macro_dsp_valuehl 
4088				endm 
# End of macro FORTH_DSP_VALUEHL
4088			; get pointer to string in hl 
4088			 
4088 7e			.toup:		ld a, (hl) 
4089 fe 00				cp 0 
408b 28 07				jr z, .toupdone 
408d			 
408d cd 88 10				call to_upper 
4090			 
4090 77					ld (hl), a 
4091 23					inc hl 
4092 18 f4				jr .toup 
4094			 
4094					 
4094			 
4094			 
4094			; for each char convert to upper 
4094					 
4094			.toupdone: 
4094			 
4094			 
4094					NEXTW 
4094 c3 63 20			jp macro_next 
4097				endm 
# End of macro NEXTW
4097			.LOWER: 
4097				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4097 48				db WORD_SYS_CORE+52             
4098 d2 40			dw .TCASE            
409a 06				db 5 + 1 
409b .. 00			db "LOWER",0              
40a1				endm 
# End of macro CWHEAD
40a1			; | LOWER ( s -- s ) Lower case string s  | DONE 
40a1					if DEBUG_FORTH_WORDS_KEY 
40a1						DMARK "LWR" 
40a1 f5				push af  
40a2 3a b6 40			ld a, (.dmark)  
40a5 32 6e fb			ld (debug_mark),a  
40a8 3a b7 40			ld a, (.dmark+1)  
40ab 32 6f fb			ld (debug_mark+1),a  
40ae 3a b8 40			ld a, (.dmark+2)  
40b1 32 70 fb			ld (debug_mark+2),a  
40b4 18 03			jr .pastdmark  
40b6 ..			.dmark: db "LWR"  
40b9 f1			.pastdmark: pop af  
40ba			endm  
# End of macro DMARK
40ba						CALLMONITOR 
40ba cd 6a 17			call break_point_state  
40bd				endm  
# End of macro CALLMONITOR
40bd					endif 
40bd			 
40bd					FORTH_DSP 
40bd cd b7 1e			call macro_forth_dsp 
40c0				endm 
# End of macro FORTH_DSP
40c0					 
40c0			; TODO check is string type 
40c0			 
40c0					FORTH_DSP_VALUEHL 
40c0 cd f1 1e			call macro_dsp_valuehl 
40c3				endm 
# End of macro FORTH_DSP_VALUEHL
40c3			; get pointer to string in hl 
40c3			 
40c3 7e			.tolow:		ld a, (hl) 
40c4 fe 00				cp 0 
40c6 28 07				jr z, .tolowdone 
40c8			 
40c8 cd 91 10				call to_lower 
40cb			 
40cb 77					ld (hl), a 
40cc 23					inc hl 
40cd 18 f4				jr .tolow 
40cf			 
40cf					 
40cf			 
40cf			 
40cf			; for each char convert to low 
40cf					 
40cf			.tolowdone: 
40cf					NEXTW 
40cf c3 63 20			jp macro_next 
40d2				endm 
# End of macro NEXTW
40d2			.TCASE: 
40d2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40d2 48				db WORD_SYS_CORE+52             
40d3 08 42			dw .SUBSTR            
40d5 06				db 5 + 1 
40d6 .. 00			db "TCASE",0              
40dc				endm 
# End of macro CWHEAD
40dc			; | TCASE ( s -- s ) Title case string s  | DONE 
40dc					if DEBUG_FORTH_WORDS_KEY 
40dc						DMARK "TCS" 
40dc f5				push af  
40dd 3a f1 40			ld a, (.dmark)  
40e0 32 6e fb			ld (debug_mark),a  
40e3 3a f2 40			ld a, (.dmark+1)  
40e6 32 6f fb			ld (debug_mark+1),a  
40e9 3a f3 40			ld a, (.dmark+2)  
40ec 32 70 fb			ld (debug_mark+2),a  
40ef 18 03			jr .pastdmark  
40f1 ..			.dmark: db "TCS"  
40f4 f1			.pastdmark: pop af  
40f5			endm  
# End of macro DMARK
40f5						CALLMONITOR 
40f5 cd 6a 17			call break_point_state  
40f8				endm  
# End of macro CALLMONITOR
40f8					endif 
40f8			 
40f8					FORTH_DSP 
40f8 cd b7 1e			call macro_forth_dsp 
40fb				endm 
# End of macro FORTH_DSP
40fb					 
40fb			; TODO check is string type 
40fb			 
40fb					FORTH_DSP_VALUEHL 
40fb cd f1 1e			call macro_dsp_valuehl 
40fe				endm 
# End of macro FORTH_DSP_VALUEHL
40fe			; get pointer to string in hl 
40fe			 
40fe					if DEBUG_FORTH_WORDS 
40fe						DMARK "TC1" 
40fe f5				push af  
40ff 3a 13 41			ld a, (.dmark)  
4102 32 6e fb			ld (debug_mark),a  
4105 3a 14 41			ld a, (.dmark+1)  
4108 32 6f fb			ld (debug_mark+1),a  
410b 3a 15 41			ld a, (.dmark+2)  
410e 32 70 fb			ld (debug_mark+2),a  
4111 18 03			jr .pastdmark  
4113 ..			.dmark: db "TC1"  
4116 f1			.pastdmark: pop af  
4117			endm  
# End of macro DMARK
4117						CALLMONITOR 
4117 cd 6a 17			call break_point_state  
411a				endm  
# End of macro CALLMONITOR
411a					endif 
411a			 
411a					; first time in turn to upper case first char 
411a			 
411a 7e					ld a, (hl) 
411b c3 a5 41				jp .totsiptou 
411e			 
411e			 
411e 7e			.tot:		ld a, (hl) 
411f fe 00				cp 0 
4121 ca e9 41				jp z, .totdone 
4124			 
4124					if DEBUG_FORTH_WORDS 
4124						DMARK "TC2" 
4124 f5				push af  
4125 3a 39 41			ld a, (.dmark)  
4128 32 6e fb			ld (debug_mark),a  
412b 3a 3a 41			ld a, (.dmark+1)  
412e 32 6f fb			ld (debug_mark+1),a  
4131 3a 3b 41			ld a, (.dmark+2)  
4134 32 70 fb			ld (debug_mark+2),a  
4137 18 03			jr .pastdmark  
4139 ..			.dmark: db "TC2"  
413c f1			.pastdmark: pop af  
413d			endm  
# End of macro DMARK
413d						CALLMONITOR 
413d cd 6a 17			call break_point_state  
4140				endm  
# End of macro CALLMONITOR
4140					endif 
4140					; check to see if current char is a space 
4140			 
4140 fe 20				cp ' ' 
4142 28 21				jr z, .totsp 
4144 cd 91 10				call to_lower 
4147					if DEBUG_FORTH_WORDS 
4147						DMARK "TC3" 
4147 f5				push af  
4148 3a 5c 41			ld a, (.dmark)  
414b 32 6e fb			ld (debug_mark),a  
414e 3a 5d 41			ld a, (.dmark+1)  
4151 32 6f fb			ld (debug_mark+1),a  
4154 3a 5e 41			ld a, (.dmark+2)  
4157 32 70 fb			ld (debug_mark+2),a  
415a 18 03			jr .pastdmark  
415c ..			.dmark: db "TC3"  
415f f1			.pastdmark: pop af  
4160			endm  
# End of macro DMARK
4160						CALLMONITOR 
4160 cd 6a 17			call break_point_state  
4163				endm  
# End of macro CALLMONITOR
4163					endif 
4163 18 63				jr .totnxt 
4165			 
4165			.totsp:         ; on a space, find next char which should be upper 
4165			 
4165					if DEBUG_FORTH_WORDS 
4165						DMARK "TC4" 
4165 f5				push af  
4166 3a 7a 41			ld a, (.dmark)  
4169 32 6e fb			ld (debug_mark),a  
416c 3a 7b 41			ld a, (.dmark+1)  
416f 32 6f fb			ld (debug_mark+1),a  
4172 3a 7c 41			ld a, (.dmark+2)  
4175 32 70 fb			ld (debug_mark+2),a  
4178 18 03			jr .pastdmark  
417a ..			.dmark: db "TC4"  
417d f1			.pastdmark: pop af  
417e			endm  
# End of macro DMARK
417e						CALLMONITOR 
417e cd 6a 17			call break_point_state  
4181				endm  
# End of macro CALLMONITOR
4181					endif 
4181					;; 
4181			 
4181 fe 20				cp ' ' 
4183 20 20				jr nz, .totsiptou 
4185 23					inc hl 
4186 7e					ld a, (hl) 
4187					if DEBUG_FORTH_WORDS 
4187						DMARK "TC5" 
4187 f5				push af  
4188 3a 9c 41			ld a, (.dmark)  
418b 32 6e fb			ld (debug_mark),a  
418e 3a 9d 41			ld a, (.dmark+1)  
4191 32 6f fb			ld (debug_mark+1),a  
4194 3a 9e 41			ld a, (.dmark+2)  
4197 32 70 fb			ld (debug_mark+2),a  
419a 18 03			jr .pastdmark  
419c ..			.dmark: db "TC5"  
419f f1			.pastdmark: pop af  
41a0			endm  
# End of macro DMARK
41a0						CALLMONITOR 
41a0 cd 6a 17			call break_point_state  
41a3				endm  
# End of macro CALLMONITOR
41a3					endif 
41a3 18 c0				jr .totsp 
41a5 fe 00		.totsiptou:    cp 0 
41a7 28 40				jr z, .totdone 
41a9					; not space and not zero term so upper case it 
41a9 cd 88 10				call to_upper 
41ac			 
41ac					if DEBUG_FORTH_WORDS 
41ac						DMARK "TC6" 
41ac f5				push af  
41ad 3a c1 41			ld a, (.dmark)  
41b0 32 6e fb			ld (debug_mark),a  
41b3 3a c2 41			ld a, (.dmark+1)  
41b6 32 6f fb			ld (debug_mark+1),a  
41b9 3a c3 41			ld a, (.dmark+2)  
41bc 32 70 fb			ld (debug_mark+2),a  
41bf 18 03			jr .pastdmark  
41c1 ..			.dmark: db "TC6"  
41c4 f1			.pastdmark: pop af  
41c5			endm  
# End of macro DMARK
41c5						CALLMONITOR 
41c5 cd 6a 17			call break_point_state  
41c8				endm  
# End of macro CALLMONITOR
41c8					endif 
41c8			 
41c8			 
41c8			.totnxt: 
41c8			 
41c8 77					ld (hl), a 
41c9 23					inc hl 
41ca					if DEBUG_FORTH_WORDS 
41ca						DMARK "TC7" 
41ca f5				push af  
41cb 3a df 41			ld a, (.dmark)  
41ce 32 6e fb			ld (debug_mark),a  
41d1 3a e0 41			ld a, (.dmark+1)  
41d4 32 6f fb			ld (debug_mark+1),a  
41d7 3a e1 41			ld a, (.dmark+2)  
41da 32 70 fb			ld (debug_mark+2),a  
41dd 18 03			jr .pastdmark  
41df ..			.dmark: db "TC7"  
41e2 f1			.pastdmark: pop af  
41e3			endm  
# End of macro DMARK
41e3						CALLMONITOR 
41e3 cd 6a 17			call break_point_state  
41e6				endm  
# End of macro CALLMONITOR
41e6					endif 
41e6 c3 1e 41				jp .tot 
41e9			 
41e9					 
41e9			 
41e9			 
41e9			; for each char convert to low 
41e9					 
41e9			.totdone: 
41e9					if DEBUG_FORTH_WORDS 
41e9						DMARK "TCd" 
41e9 f5				push af  
41ea 3a fe 41			ld a, (.dmark)  
41ed 32 6e fb			ld (debug_mark),a  
41f0 3a ff 41			ld a, (.dmark+1)  
41f3 32 6f fb			ld (debug_mark+1),a  
41f6 3a 00 42			ld a, (.dmark+2)  
41f9 32 70 fb			ld (debug_mark+2),a  
41fc 18 03			jr .pastdmark  
41fe ..			.dmark: db "TCd"  
4201 f1			.pastdmark: pop af  
4202			endm  
# End of macro DMARK
4202						CALLMONITOR 
4202 cd 6a 17			call break_point_state  
4205				endm  
# End of macro CALLMONITOR
4205					endif 
4205					NEXTW 
4205 c3 63 20			jp macro_next 
4208				endm 
# End of macro NEXTW
4208			 
4208			.SUBSTR: 
4208				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4208 48				db WORD_SYS_CORE+52             
4209 66 42			dw .LEFT            
420b 07				db 6 + 1 
420c .. 00			db "SUBSTR",0              
4213				endm 
# End of macro CWHEAD
4213			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4213			 
4213					if DEBUG_FORTH_WORDS_KEY 
4213						DMARK "SST" 
4213 f5				push af  
4214 3a 28 42			ld a, (.dmark)  
4217 32 6e fb			ld (debug_mark),a  
421a 3a 29 42			ld a, (.dmark+1)  
421d 32 6f fb			ld (debug_mark+1),a  
4220 3a 2a 42			ld a, (.dmark+2)  
4223 32 70 fb			ld (debug_mark+2),a  
4226 18 03			jr .pastdmark  
4228 ..			.dmark: db "SST"  
422b f1			.pastdmark: pop af  
422c			endm  
# End of macro DMARK
422c						CALLMONITOR 
422c cd 6a 17			call break_point_state  
422f				endm  
# End of macro CALLMONITOR
422f					endif 
422f			; TODO check string type 
422f					FORTH_DSP_VALUEHL 
422f cd f1 1e			call macro_dsp_valuehl 
4232				endm 
# End of macro FORTH_DSP_VALUEHL
4232			 
4232 e5					push hl      ; string length 
4233			 
4233					FORTH_DSP_POP 
4233 cd a9 1f			call macro_forth_dsp_pop 
4236				endm 
# End of macro FORTH_DSP_POP
4236			 
4236					FORTH_DSP_VALUEHL 
4236 cd f1 1e			call macro_dsp_valuehl 
4239				endm 
# End of macro FORTH_DSP_VALUEHL
4239			 
4239 e5					push hl     ; start char 
423a			 
423a					FORTH_DSP_POP 
423a cd a9 1f			call macro_forth_dsp_pop 
423d				endm 
# End of macro FORTH_DSP_POP
423d			 
423d			 
423d					FORTH_DSP_VALUE 
423d cd da 1e			call macro_forth_dsp_value 
4240				endm 
# End of macro FORTH_DSP_VALUE
4240			 
4240 d1					pop de    ; get start post offset 
4241			 
4241 19					add hl, de    ; starting offset 
4242			 
4242 c1					pop bc 
4243 c5					push bc      ; grab size of string 
4244			 
4244 e5					push hl    ; save string start  
4245			 
4245 26 00				ld h, 0 
4247 69					ld l, c 
4248 23					inc hl 
4249 23					inc hl 
424a			 
424a cd e2 11				call malloc 
424d				if DEBUG_FORTH_MALLOC_GUARD 
424d cc 24 52				call z,malloc_error 
4250				endif 
4250			 
4250 eb					ex de, hl      ; save malloc area for string copy 
4251 e1					pop hl    ; get back source 
4252 c1					pop bc    ; get length of string back 
4253			 
4253 d5					push de    ; save malloc area for after we push 
4254 ed b0				ldir     ; copy substr 
4256			 
4256			 
4256 eb					ex de, hl 
4257 3e 00				ld a, 0 
4259 77					ld (hl), a   ; term substr 
425a			 
425a					 
425a e1					pop hl    ; get malloc so we can push it 
425b e5					push hl   ; save so we can free it afterwards 
425c			 
425c cd 68 1d				call forth_push_str 
425f			 
425f e1					pop hl 
4260 cd ac 12				call free 
4263			 
4263					 
4263					 
4263			 
4263			 
4263					NEXTW 
4263 c3 63 20			jp macro_next 
4266				endm 
# End of macro NEXTW
4266			 
4266			.LEFT: 
4266				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4266 48				db WORD_SYS_CORE+52             
4267 8e 42			dw .RIGHT            
4269 05				db 4 + 1 
426a .. 00			db "LEFT",0              
426f				endm 
# End of macro CWHEAD
426f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
426f					if DEBUG_FORTH_WORDS_KEY 
426f						DMARK "LEF" 
426f f5				push af  
4270 3a 84 42			ld a, (.dmark)  
4273 32 6e fb			ld (debug_mark),a  
4276 3a 85 42			ld a, (.dmark+1)  
4279 32 6f fb			ld (debug_mark+1),a  
427c 3a 86 42			ld a, (.dmark+2)  
427f 32 70 fb			ld (debug_mark+2),a  
4282 18 03			jr .pastdmark  
4284 ..			.dmark: db "LEF"  
4287 f1			.pastdmark: pop af  
4288			endm  
# End of macro DMARK
4288						CALLMONITOR 
4288 cd 6a 17			call break_point_state  
428b				endm  
# End of macro CALLMONITOR
428b					endif 
428b			 
428b					NEXTW 
428b c3 63 20			jp macro_next 
428e				endm 
# End of macro NEXTW
428e			.RIGHT: 
428e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
428e 48				db WORD_SYS_CORE+52             
428f b7 42			dw .STR2NUM            
4291 06				db 5 + 1 
4292 .. 00			db "RIGHT",0              
4298				endm 
# End of macro CWHEAD
4298			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4298					if DEBUG_FORTH_WORDS_KEY 
4298						DMARK "RIG" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 6e fb			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 6f fb			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 70 fb			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "RIG"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd 6a 17			call break_point_state  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4			 
42b4					NEXTW 
42b4 c3 63 20			jp macro_next 
42b7				endm 
# End of macro NEXTW
42b7			 
42b7			 
42b7			.STR2NUM: 
42b7				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
42b7 48				db WORD_SYS_CORE+52             
42b8 43 43			dw .NUM2STR            
42ba 08				db 7 + 1 
42bb .. 00			db "STR2NUM",0              
42c3				endm 
# End of macro CWHEAD
42c3			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42c3			 
42c3			 
42c3			; TODO STR type check to do 
42c3					if DEBUG_FORTH_WORDS_KEY 
42c3						DMARK "S2N" 
42c3 f5				push af  
42c4 3a d8 42			ld a, (.dmark)  
42c7 32 6e fb			ld (debug_mark),a  
42ca 3a d9 42			ld a, (.dmark+1)  
42cd 32 6f fb			ld (debug_mark+1),a  
42d0 3a da 42			ld a, (.dmark+2)  
42d3 32 70 fb			ld (debug_mark+2),a  
42d6 18 03			jr .pastdmark  
42d8 ..			.dmark: db "S2N"  
42db f1			.pastdmark: pop af  
42dc			endm  
# End of macro DMARK
42dc						CALLMONITOR 
42dc cd 6a 17			call break_point_state  
42df				endm  
# End of macro CALLMONITOR
42df					endif 
42df			 
42df					;FORTH_DSP 
42df					FORTH_DSP_VALUE 
42df cd da 1e			call macro_forth_dsp_value 
42e2				endm 
# End of macro FORTH_DSP_VALUE
42e2					;inc hl 
42e2			 
42e2 eb					ex de, hl 
42e3					if DEBUG_FORTH_WORDS 
42e3						DMARK "S2a" 
42e3 f5				push af  
42e4 3a f8 42			ld a, (.dmark)  
42e7 32 6e fb			ld (debug_mark),a  
42ea 3a f9 42			ld a, (.dmark+1)  
42ed 32 6f fb			ld (debug_mark+1),a  
42f0 3a fa 42			ld a, (.dmark+2)  
42f3 32 70 fb			ld (debug_mark+2),a  
42f6 18 03			jr .pastdmark  
42f8 ..			.dmark: db "S2a"  
42fb f1			.pastdmark: pop af  
42fc			endm  
# End of macro DMARK
42fc						CALLMONITOR 
42fc cd 6a 17			call break_point_state  
42ff				endm  
# End of macro CALLMONITOR
42ff					endif 
42ff cd 10 11				call string_to_uint16 
4302			 
4302					if DEBUG_FORTH_WORDS 
4302						DMARK "S2b" 
4302 f5				push af  
4303 3a 17 43			ld a, (.dmark)  
4306 32 6e fb			ld (debug_mark),a  
4309 3a 18 43			ld a, (.dmark+1)  
430c 32 6f fb			ld (debug_mark+1),a  
430f 3a 19 43			ld a, (.dmark+2)  
4312 32 70 fb			ld (debug_mark+2),a  
4315 18 03			jr .pastdmark  
4317 ..			.dmark: db "S2b"  
431a f1			.pastdmark: pop af  
431b			endm  
# End of macro DMARK
431b						CALLMONITOR 
431b cd 6a 17			call break_point_state  
431e				endm  
# End of macro CALLMONITOR
431e					endif 
431e			;		push hl 
431e					FORTH_DSP_POP 
431e cd a9 1f			call macro_forth_dsp_pop 
4321				endm 
# End of macro FORTH_DSP_POP
4321			;		pop hl 
4321					 
4321					if DEBUG_FORTH_WORDS 
4321						DMARK "S2b" 
4321 f5				push af  
4322 3a 36 43			ld a, (.dmark)  
4325 32 6e fb			ld (debug_mark),a  
4328 3a 37 43			ld a, (.dmark+1)  
432b 32 6f fb			ld (debug_mark+1),a  
432e 3a 38 43			ld a, (.dmark+2)  
4331 32 70 fb			ld (debug_mark+2),a  
4334 18 03			jr .pastdmark  
4336 ..			.dmark: db "S2b"  
4339 f1			.pastdmark: pop af  
433a			endm  
# End of macro DMARK
433a						CALLMONITOR 
433a cd 6a 17			call break_point_state  
433d				endm  
# End of macro CALLMONITOR
433d					endif 
433d cd fa 1c				call forth_push_numhl	 
4340			 
4340				 
4340				       NEXTW 
4340 c3 63 20			jp macro_next 
4343				endm 
# End of macro NEXTW
4343			.NUM2STR: 
4343				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4343 48				db WORD_SYS_CORE+52             
4344 52 43			dw .CONCAT            
4346 08				db 7 + 1 
4347 .. 00			db "NUM2STR",0              
434f				endm 
# End of macro CWHEAD
434f			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
434f			 
434f			;		; malloc a string to target 
434f			;		ld hl, 10     ; TODO max string size should be fine 
434f			;		call malloc 
434f			;		push hl    ; save malloc location 
434f			; 
434f			; 
434f			;; TODO check int type 
434f			;		FORTH_DSP_VALUEHL 
434f			;		ld a, l 
434f			;		call DispAToASCII   
434f			;;TODO need to chage above call to dump into string 
434f			; 
434f			; 
434f			 
434f				       NEXTW 
434f c3 63 20			jp macro_next 
4352				endm 
# End of macro NEXTW
4352			 
4352			.CONCAT: 
4352				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4352 48				db WORD_SYS_CORE+52             
4353 05 44			dw .FIND            
4355 07				db 6 + 1 
4356 .. 00			db "CONCAT",0              
435d				endm 
# End of macro CWHEAD
435d			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
435d			 
435d			; TODO check string type 
435d			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
435d			 
435d					if DEBUG_FORTH_WORDS_KEY 
435d						DMARK "CON" 
435d f5				push af  
435e 3a 72 43			ld a, (.dmark)  
4361 32 6e fb			ld (debug_mark),a  
4364 3a 73 43			ld a, (.dmark+1)  
4367 32 6f fb			ld (debug_mark+1),a  
436a 3a 74 43			ld a, (.dmark+2)  
436d 32 70 fb			ld (debug_mark+2),a  
4370 18 03			jr .pastdmark  
4372 ..			.dmark: db "CON"  
4375 f1			.pastdmark: pop af  
4376			endm  
# End of macro DMARK
4376						CALLMONITOR 
4376 cd 6a 17			call break_point_state  
4379				endm  
# End of macro CALLMONITOR
4379					endif 
4379			 
4379			 
4379					FORTH_DSP_VALUE 
4379 cd da 1e			call macro_forth_dsp_value 
437c				endm 
# End of macro FORTH_DSP_VALUE
437c e5					push hl   ; s2 
437d			 
437d					FORTH_DSP_POP 
437d cd a9 1f			call macro_forth_dsp_pop 
4380				endm 
# End of macro FORTH_DSP_POP
4380			 
4380					FORTH_DSP_VALUE 
4380 cd da 1e			call macro_forth_dsp_value 
4383				endm 
# End of macro FORTH_DSP_VALUE
4383			 
4383 e5					push hl   ; s1 
4384			 
4384					FORTH_DSP_POP 
4384 cd a9 1f			call macro_forth_dsp_pop 
4387				endm 
# End of macro FORTH_DSP_POP
4387					 
4387			 
4387					; copy s1 
4387			 
4387				 
4387					; save ptr 
4387 e1					pop hl  
4388 e5					push hl 
4389 3e 00				ld a, 0 
438b cd 84 11				call strlent 
438e					;inc hl    ; zer0 
438e 06 00				ld b, 0 
4390 4d					ld c, l 
4391 e1					pop hl		 
4392 11 14 ee				ld de, scratch	 
4395					if DEBUG_FORTH_WORDS 
4395						DMARK "CO1" 
4395 f5				push af  
4396 3a aa 43			ld a, (.dmark)  
4399 32 6e fb			ld (debug_mark),a  
439c 3a ab 43			ld a, (.dmark+1)  
439f 32 6f fb			ld (debug_mark+1),a  
43a2 3a ac 43			ld a, (.dmark+2)  
43a5 32 70 fb			ld (debug_mark+2),a  
43a8 18 03			jr .pastdmark  
43aa ..			.dmark: db "CO1"  
43ad f1			.pastdmark: pop af  
43ae			endm  
# End of macro DMARK
43ae						CALLMONITOR 
43ae cd 6a 17			call break_point_state  
43b1				endm  
# End of macro CALLMONITOR
43b1					endif 
43b1 ed b0				ldir 
43b3			 
43b3 e1					pop hl 
43b4 e5					push hl 
43b5 d5					push de 
43b6			 
43b6			 
43b6 3e 00				ld a, 0 
43b8 cd 84 11				call strlent 
43bb 23					inc hl    ; zer0 
43bc 23					inc hl 
43bd 06 00				ld b, 0 
43bf 4d					ld c, l 
43c0 d1					pop de 
43c1 e1					pop hl		 
43c2					if DEBUG_FORTH_WORDS 
43c2						DMARK "CO2" 
43c2 f5				push af  
43c3 3a d7 43			ld a, (.dmark)  
43c6 32 6e fb			ld (debug_mark),a  
43c9 3a d8 43			ld a, (.dmark+1)  
43cc 32 6f fb			ld (debug_mark+1),a  
43cf 3a d9 43			ld a, (.dmark+2)  
43d2 32 70 fb			ld (debug_mark+2),a  
43d5 18 03			jr .pastdmark  
43d7 ..			.dmark: db "CO2"  
43da f1			.pastdmark: pop af  
43db			endm  
# End of macro DMARK
43db						CALLMONITOR 
43db cd 6a 17			call break_point_state  
43de				endm  
# End of macro CALLMONITOR
43de					endif 
43de ed b0				ldir 
43e0			 
43e0			 
43e0			 
43e0 21 14 ee				ld hl, scratch 
43e3					if DEBUG_FORTH_WORDS 
43e3						DMARK "CO5" 
43e3 f5				push af  
43e4 3a f8 43			ld a, (.dmark)  
43e7 32 6e fb			ld (debug_mark),a  
43ea 3a f9 43			ld a, (.dmark+1)  
43ed 32 6f fb			ld (debug_mark+1),a  
43f0 3a fa 43			ld a, (.dmark+2)  
43f3 32 70 fb			ld (debug_mark+2),a  
43f6 18 03			jr .pastdmark  
43f8 ..			.dmark: db "CO5"  
43fb f1			.pastdmark: pop af  
43fc			endm  
# End of macro DMARK
43fc						CALLMONITOR 
43fc cd 6a 17			call break_point_state  
43ff				endm  
# End of macro CALLMONITOR
43ff					endif 
43ff			 
43ff cd 68 1d				call forth_push_str 
4402			 
4402			 
4402			 
4402			 
4402				       NEXTW 
4402 c3 63 20			jp macro_next 
4405				endm 
# End of macro NEXTW
4405			 
4405			 
4405			.FIND: 
4405				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4405 4b				db WORD_SYS_CORE+55             
4406 c3 44			dw .LEN            
4408 05				db 4 + 1 
4409 .. 00			db "FIND",0              
440e				endm 
# End of macro CWHEAD
440e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
440e			 
440e					if DEBUG_FORTH_WORDS_KEY 
440e						DMARK "FND" 
440e f5				push af  
440f 3a 23 44			ld a, (.dmark)  
4412 32 6e fb			ld (debug_mark),a  
4415 3a 24 44			ld a, (.dmark+1)  
4418 32 6f fb			ld (debug_mark+1),a  
441b 3a 25 44			ld a, (.dmark+2)  
441e 32 70 fb			ld (debug_mark+2),a  
4421 18 03			jr .pastdmark  
4423 ..			.dmark: db "FND"  
4426 f1			.pastdmark: pop af  
4427			endm  
# End of macro DMARK
4427						CALLMONITOR 
4427 cd 6a 17			call break_point_state  
442a				endm  
# End of macro CALLMONITOR
442a					endif 
442a			 
442a			; TODO check string type 
442a					FORTH_DSP_VALUE 
442a cd da 1e			call macro_forth_dsp_value 
442d				endm 
# End of macro FORTH_DSP_VALUE
442d			 
442d e5					push hl    
442e 7e					ld a,(hl)    ; char to find   
442f			; TODO change char to substr 
442f			 
442f f5					push af 
4430					 
4430			 
4430			 
4430					if DEBUG_FORTH_WORDS 
4430						DMARK "FN1" 
4430 f5				push af  
4431 3a 45 44			ld a, (.dmark)  
4434 32 6e fb			ld (debug_mark),a  
4437 3a 46 44			ld a, (.dmark+1)  
443a 32 6f fb			ld (debug_mark+1),a  
443d 3a 47 44			ld a, (.dmark+2)  
4440 32 70 fb			ld (debug_mark+2),a  
4443 18 03			jr .pastdmark  
4445 ..			.dmark: db "FN1"  
4448 f1			.pastdmark: pop af  
4449			endm  
# End of macro DMARK
4449						CALLMONITOR 
4449 cd 6a 17			call break_point_state  
444c				endm  
# End of macro CALLMONITOR
444c					endif 
444c			 
444c					FORTH_DSP_POP 
444c cd a9 1f			call macro_forth_dsp_pop 
444f				endm 
# End of macro FORTH_DSP_POP
444f			 
444f					; string to search 
444f			 
444f					FORTH_DSP_VALUE 
444f cd da 1e			call macro_forth_dsp_value 
4452				endm 
# End of macro FORTH_DSP_VALUE
4452			 
4452 d1					pop de  ; d is char to find  
4453			 
4453					if DEBUG_FORTH_WORDS 
4453						DMARK "FN2" 
4453 f5				push af  
4454 3a 68 44			ld a, (.dmark)  
4457 32 6e fb			ld (debug_mark),a  
445a 3a 69 44			ld a, (.dmark+1)  
445d 32 6f fb			ld (debug_mark+1),a  
4460 3a 6a 44			ld a, (.dmark+2)  
4463 32 70 fb			ld (debug_mark+2),a  
4466 18 03			jr .pastdmark  
4468 ..			.dmark: db "FN2"  
446b f1			.pastdmark: pop af  
446c			endm  
# End of macro DMARK
446c						CALLMONITOR 
446c cd 6a 17			call break_point_state  
446f				endm  
# End of macro CALLMONITOR
446f					endif 
446f					 
446f 01 00 00				ld bc, 0 
4472 7e			.findchar:      ld a,(hl) 
4473 fe 00				cp 0   		 
4475 28 27				jr z, .finddone     
4477 ba					cp d 
4478 28 20				jr z, .foundchar 
447a 03					inc bc 
447b 23					inc hl 
447c					if DEBUG_FORTH_WORDS 
447c						DMARK "FN3" 
447c f5				push af  
447d 3a 91 44			ld a, (.dmark)  
4480 32 6e fb			ld (debug_mark),a  
4483 3a 92 44			ld a, (.dmark+1)  
4486 32 6f fb			ld (debug_mark+1),a  
4489 3a 93 44			ld a, (.dmark+2)  
448c 32 70 fb			ld (debug_mark+2),a  
448f 18 03			jr .pastdmark  
4491 ..			.dmark: db "FN3"  
4494 f1			.pastdmark: pop af  
4495			endm  
# End of macro DMARK
4495						CALLMONITOR 
4495 cd 6a 17			call break_point_state  
4498				endm  
# End of macro CALLMONITOR
4498					endif 
4498 18 d8				jr .findchar 
449a			 
449a			 
449a c5			.foundchar:	push bc 
449b e1					pop hl 
449c 18 03				jr .findexit 
449e			 
449e			 
449e							 
449e			 
449e			.finddone:     ; got to end of string with no find 
449e 21 00 00				ld hl, 0 
44a1			.findexit: 
44a1			 
44a1					if DEBUG_FORTH_WORDS 
44a1						DMARK "FNd" 
44a1 f5				push af  
44a2 3a b6 44			ld a, (.dmark)  
44a5 32 6e fb			ld (debug_mark),a  
44a8 3a b7 44			ld a, (.dmark+1)  
44ab 32 6f fb			ld (debug_mark+1),a  
44ae 3a b8 44			ld a, (.dmark+2)  
44b1 32 70 fb			ld (debug_mark+2),a  
44b4 18 03			jr .pastdmark  
44b6 ..			.dmark: db "FNd"  
44b9 f1			.pastdmark: pop af  
44ba			endm  
# End of macro DMARK
44ba						CALLMONITOR 
44ba cd 6a 17			call break_point_state  
44bd				endm  
# End of macro CALLMONITOR
44bd					endif 
44bd cd fa 1c			call forth_push_numhl 
44c0			 
44c0				       NEXTW 
44c0 c3 63 20			jp macro_next 
44c3				endm 
# End of macro NEXTW
44c3			 
44c3			.LEN: 
44c3				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44c3 4c				db WORD_SYS_CORE+56             
44c4 f8 44			dw .CHAR            
44c6 06				db 5 + 1 
44c7 .. 00			db "COUNT",0              
44cd				endm 
# End of macro CWHEAD
44cd			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44cd			 
44cd					if DEBUG_FORTH_WORDS_KEY 
44cd						DMARK "CNT" 
44cd f5				push af  
44ce 3a e2 44			ld a, (.dmark)  
44d1 32 6e fb			ld (debug_mark),a  
44d4 3a e3 44			ld a, (.dmark+1)  
44d7 32 6f fb			ld (debug_mark+1),a  
44da 3a e4 44			ld a, (.dmark+2)  
44dd 32 70 fb			ld (debug_mark+2),a  
44e0 18 03			jr .pastdmark  
44e2 ..			.dmark: db "CNT"  
44e5 f1			.pastdmark: pop af  
44e6			endm  
# End of macro DMARK
44e6						CALLMONITOR 
44e6 cd 6a 17			call break_point_state  
44e9				endm  
# End of macro CALLMONITOR
44e9					endif 
44e9			; TODO check string type 
44e9					FORTH_DSP 
44e9 cd b7 1e			call macro_forth_dsp 
44ec				endm 
# End of macro FORTH_DSP
44ec					;v5FORTH_DSP_VALUE 
44ec			 
44ec 23					inc hl 
44ed			 
44ed 3e 00				ld a, 0 
44ef cd 84 11				call strlent 
44f2			 
44f2 cd fa 1c				call forth_push_numhl 
44f5			 
44f5			 
44f5			 
44f5				       NEXTW 
44f5 c3 63 20			jp macro_next 
44f8				endm 
# End of macro NEXTW
44f8			.CHAR: 
44f8				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
44f8 4d				db WORD_SYS_CORE+57             
44f9 2e 45			dw .ENDSTR            
44fb 05				db 4 + 1 
44fc .. 00			db "CHAR",0              
4501				endm 
# End of macro CWHEAD
4501			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4501					if DEBUG_FORTH_WORDS_KEY 
4501						DMARK "CHR" 
4501 f5				push af  
4502 3a 16 45			ld a, (.dmark)  
4505 32 6e fb			ld (debug_mark),a  
4508 3a 17 45			ld a, (.dmark+1)  
450b 32 6f fb			ld (debug_mark+1),a  
450e 3a 18 45			ld a, (.dmark+2)  
4511 32 70 fb			ld (debug_mark+2),a  
4514 18 03			jr .pastdmark  
4516 ..			.dmark: db "CHR"  
4519 f1			.pastdmark: pop af  
451a			endm  
# End of macro DMARK
451a						CALLMONITOR 
451a cd 6a 17			call break_point_state  
451d				endm  
# End of macro CALLMONITOR
451d					endif 
451d					FORTH_DSP 
451d cd b7 1e			call macro_forth_dsp 
4520				endm 
# End of macro FORTH_DSP
4520					;v5 FORTH_DSP_VALUE 
4520 23					inc hl      ; now at start of numeric as string 
4521			 
4521			;		push hl 
4521			 
4521					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4521 cd a9 1f			call macro_forth_dsp_pop 
4524				endm 
# End of macro FORTH_DSP_POP
4524			 
4524			;		pop hl 
4524			 
4524					; push the content of a onto the stack as a value 
4524			 
4524 7e					ld a,(hl)   ; get char 
4525 26 00				ld h,0 
4527 6f					ld l,a 
4528 cd fa 1c				call forth_push_numhl 
452b			 
452b				       NEXTW 
452b c3 63 20			jp macro_next 
452e				endm 
# End of macro NEXTW
452e			 
452e			 
452e			 
452e			 
452e			.ENDSTR: 
452e			; eof 
452e			 
# End of file forth_words_str.asm
452e			include "forth_words_key.asm" 
452e			 
452e			; | ## Keyboard Words 
452e			 
452e			.KEY: 
452e				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
452e 3e				db WORD_SYS_CORE+42             
452f 5e 45			dw .WAITK            
4531 04				db 3 + 1 
4532 .. 00			db "KEY",0              
4536				endm 
# End of macro CWHEAD
4536			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4536			 
4536					if DEBUG_FORTH_WORDS_KEY 
4536						DMARK "KEY" 
4536 f5				push af  
4537 3a 4b 45			ld a, (.dmark)  
453a 32 6e fb			ld (debug_mark),a  
453d 3a 4c 45			ld a, (.dmark+1)  
4540 32 6f fb			ld (debug_mark+1),a  
4543 3a 4d 45			ld a, (.dmark+2)  
4546 32 70 fb			ld (debug_mark+2),a  
4549 18 03			jr .pastdmark  
454b ..			.dmark: db "KEY"  
454e f1			.pastdmark: pop af  
454f			endm  
# End of macro DMARK
454f						CALLMONITOR 
454f cd 6a 17			call break_point_state  
4552				endm  
# End of macro CALLMONITOR
4552					endif 
4552			; TODO currently waits 
4552 cd 57 69				call cin 
4555					;call cin_wait 
4555 6f					ld l, a 
4556 26 00				ld h, 0 
4558 cd fa 1c				call forth_push_numhl 
455b					NEXTW 
455b c3 63 20			jp macro_next 
455e				endm 
# End of macro NEXTW
455e			.WAITK: 
455e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
455e 3f				db WORD_SYS_CORE+43             
455f 90 45			dw .ACCEPT            
4561 06				db 5 + 1 
4562 .. 00			db "WAITK",0              
4568				endm 
# End of macro CWHEAD
4568			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4568					if DEBUG_FORTH_WORDS_KEY 
4568						DMARK "WAI" 
4568 f5				push af  
4569 3a 7d 45			ld a, (.dmark)  
456c 32 6e fb			ld (debug_mark),a  
456f 3a 7e 45			ld a, (.dmark+1)  
4572 32 6f fb			ld (debug_mark+1),a  
4575 3a 7f 45			ld a, (.dmark+2)  
4578 32 70 fb			ld (debug_mark+2),a  
457b 18 03			jr .pastdmark  
457d ..			.dmark: db "WAI"  
4580 f1			.pastdmark: pop af  
4581			endm  
# End of macro DMARK
4581						CALLMONITOR 
4581 cd 6a 17			call break_point_state  
4584				endm  
# End of macro CALLMONITOR
4584					endif 
4584 cd 46 69				call cin_wait 
4587 6f					ld l, a 
4588 26 00				ld h, 0 
458a cd fa 1c				call forth_push_numhl 
458d					NEXTW 
458d c3 63 20			jp macro_next 
4590				endm 
# End of macro NEXTW
4590			.ACCEPT: 
4590				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4590 40				db WORD_SYS_CORE+44             
4591 ee 45			dw .EDIT            
4593 07				db 6 + 1 
4594 .. 00			db "ACCEPT",0              
459b				endm 
# End of macro CWHEAD
459b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
459b					; TODO crashes on push 
459b					if DEBUG_FORTH_WORDS_KEY 
459b						DMARK "ACC" 
459b f5				push af  
459c 3a b0 45			ld a, (.dmark)  
459f 32 6e fb			ld (debug_mark),a  
45a2 3a b1 45			ld a, (.dmark+1)  
45a5 32 6f fb			ld (debug_mark+1),a  
45a8 3a b2 45			ld a, (.dmark+2)  
45ab 32 70 fb			ld (debug_mark+2),a  
45ae 18 03			jr .pastdmark  
45b0 ..			.dmark: db "ACC"  
45b3 f1			.pastdmark: pop af  
45b4			endm  
# End of macro DMARK
45b4						CALLMONITOR 
45b4 cd 6a 17			call break_point_state  
45b7				endm  
# End of macro CALLMONITOR
45b7					endif 
45b7 21 12 f0				ld hl, os_input 
45ba 3e 00				ld a, 0 
45bc 77					ld (hl),a 
45bd 3a 3d f8				ld a,(f_cursor_ptr) 
45c0 16 64				ld d, 100 
45c2 0e 00				ld c, 0 
45c4 1e 28				ld e, 40 
45c6 cd 48 0d				call input_str 
45c9					; TODO perhaps do a type check and wrap in quotes if not a number 
45c9 21 12 f0				ld hl, os_input 
45cc					if DEBUG_FORTH_WORDS 
45cc						DMARK "AC1" 
45cc f5				push af  
45cd 3a e1 45			ld a, (.dmark)  
45d0 32 6e fb			ld (debug_mark),a  
45d3 3a e2 45			ld a, (.dmark+1)  
45d6 32 6f fb			ld (debug_mark+1),a  
45d9 3a e3 45			ld a, (.dmark+2)  
45dc 32 70 fb			ld (debug_mark+2),a  
45df 18 03			jr .pastdmark  
45e1 ..			.dmark: db "AC1"  
45e4 f1			.pastdmark: pop af  
45e5			endm  
# End of macro DMARK
45e5						CALLMONITOR 
45e5 cd 6a 17			call break_point_state  
45e8				endm  
# End of macro CALLMONITOR
45e8					endif 
45e8 cd 68 1d				call forth_push_str 
45eb					NEXTW 
45eb c3 63 20			jp macro_next 
45ee				endm 
# End of macro NEXTW
45ee			 
45ee			.EDIT: 
45ee				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45ee 40				db WORD_SYS_CORE+44             
45ef 90 46			dw .ENDKEY            
45f1 05				db 4 + 1 
45f2 .. 00			db "EDIT",0              
45f7				endm 
# End of macro CWHEAD
45f7			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
45f7			 
45f7					; TODO does not copy from stack 
45f7					if DEBUG_FORTH_WORDS_KEY 
45f7						DMARK "EDT" 
45f7 f5				push af  
45f8 3a 0c 46			ld a, (.dmark)  
45fb 32 6e fb			ld (debug_mark),a  
45fe 3a 0d 46			ld a, (.dmark+1)  
4601 32 6f fb			ld (debug_mark+1),a  
4604 3a 0e 46			ld a, (.dmark+2)  
4607 32 70 fb			ld (debug_mark+2),a  
460a 18 03			jr .pastdmark  
460c ..			.dmark: db "EDT"  
460f f1			.pastdmark: pop af  
4610			endm  
# End of macro DMARK
4610						CALLMONITOR 
4610 cd 6a 17			call break_point_state  
4613				endm  
# End of macro CALLMONITOR
4613					endif 
4613			 
4613					;FORTH_DSP 
4613					FORTH_DSP_VALUEHL 
4613 cd f1 1e			call macro_dsp_valuehl 
4616				endm 
# End of macro FORTH_DSP_VALUEHL
4616			;		inc hl    ; TODO do type check 
4616			 
4616			;		call get_word_hl 
4616 e5					push hl 
4617					if DEBUG_FORTH_WORDS 
4617						DMARK "EDp" 
4617 f5				push af  
4618 3a 2c 46			ld a, (.dmark)  
461b 32 6e fb			ld (debug_mark),a  
461e 3a 2d 46			ld a, (.dmark+1)  
4621 32 6f fb			ld (debug_mark+1),a  
4624 3a 2e 46			ld a, (.dmark+2)  
4627 32 70 fb			ld (debug_mark+2),a  
462a 18 03			jr .pastdmark  
462c ..			.dmark: db "EDp"  
462f f1			.pastdmark: pop af  
4630			endm  
# End of macro DMARK
4630						CALLMONITOR 
4630 cd 6a 17			call break_point_state  
4633				endm  
# End of macro CALLMONITOR
4633					endif 
4633				;	ld a, 0 
4633 cd 79 11				call strlenz 
4636 23					inc hl 
4637			 
4637 06 00				ld b, 0 
4639 4d					ld c, l 
463a			 
463a e1					pop hl 
463b 11 12 f0				ld de, os_input 
463e					if DEBUG_FORTH_WORDS_KEY 
463e						DMARK "EDc" 
463e f5				push af  
463f 3a 53 46			ld a, (.dmark)  
4642 32 6e fb			ld (debug_mark),a  
4645 3a 54 46			ld a, (.dmark+1)  
4648 32 6f fb			ld (debug_mark+1),a  
464b 3a 55 46			ld a, (.dmark+2)  
464e 32 70 fb			ld (debug_mark+2),a  
4651 18 03			jr .pastdmark  
4653 ..			.dmark: db "EDc"  
4656 f1			.pastdmark: pop af  
4657			endm  
# End of macro DMARK
4657						CALLMONITOR 
4657 cd 6a 17			call break_point_state  
465a				endm  
# End of macro CALLMONITOR
465a					endif 
465a ed b0				ldir 
465c			 
465c			 
465c 21 12 f0				ld hl, os_input 
465f					;ld a, 0 
465f					;ld (hl),a 
465f 3a 3d f8				ld a,(f_cursor_ptr) 
4662 16 64				ld d, 100 
4664 0e 00				ld c, 0 
4666 1e 28				ld e, 40 
4668 cd 48 0d				call input_str 
466b					; TODO perhaps do a type check and wrap in quotes if not a number 
466b 21 12 f0				ld hl, os_input 
466e					if DEBUG_FORTH_WORDS 
466e						DMARK "ED1" 
466e f5				push af  
466f 3a 83 46			ld a, (.dmark)  
4672 32 6e fb			ld (debug_mark),a  
4675 3a 84 46			ld a, (.dmark+1)  
4678 32 6f fb			ld (debug_mark+1),a  
467b 3a 85 46			ld a, (.dmark+2)  
467e 32 70 fb			ld (debug_mark+2),a  
4681 18 03			jr .pastdmark  
4683 ..			.dmark: db "ED1"  
4686 f1			.pastdmark: pop af  
4687			endm  
# End of macro DMARK
4687						CALLMONITOR 
4687 cd 6a 17			call break_point_state  
468a				endm  
# End of macro CALLMONITOR
468a					endif 
468a cd 68 1d				call forth_push_str 
468d					NEXTW 
468d c3 63 20			jp macro_next 
4690				endm 
# End of macro NEXTW
4690			 
4690			 
4690			 
4690			.ENDKEY: 
4690			; eof 
4690			 
# End of file forth_words_key.asm
4690			 
4690			if STORAGE_SE 
4690			   	include "forth_words_storage.asm" 
4690			 
4690			; | ## Fixed Storage Words 
4690			 
4690			 
4690			.BREAD: 
4690			  
4690				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4690 3a				db WORD_SYS_CORE+38             
4691 13 47			dw .BWRITE            
4693 06				db 5 + 1 
4694 .. 00			db "BREAD",0              
469a				endm 
# End of macro CWHEAD
469a			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
469a				 
469a					if DEBUG_FORTH_WORDS_KEY 
469a						DMARK "BRD" 
469a f5				push af  
469b 3a af 46			ld a, (.dmark)  
469e 32 6e fb			ld (debug_mark),a  
46a1 3a b0 46			ld a, (.dmark+1)  
46a4 32 6f fb			ld (debug_mark+1),a  
46a7 3a b1 46			ld a, (.dmark+2)  
46aa 32 70 fb			ld (debug_mark+2),a  
46ad 18 03			jr .pastdmark  
46af ..			.dmark: db "BRD"  
46b2 f1			.pastdmark: pop af  
46b3			endm  
# End of macro DMARK
46b3						CALLMONITOR 
46b3 cd 6a 17			call break_point_state  
46b6				endm  
# End of macro CALLMONITOR
46b6					endif 
46b6			 
46b6				FORTH_DSP_VALUEHL 
46b6 cd f1 1e			call macro_dsp_valuehl 
46b9				endm 
# End of macro FORTH_DSP_VALUEHL
46b9			 
46b9				FORTH_DSP_POP 
46b9 cd a9 1f			call macro_forth_dsp_pop 
46bc				endm 
# End of macro FORTH_DSP_POP
46bc			 
46bc				; calc block address 
46bc			 
46bc eb				ex de, hl 
46bd 3e 40			ld a, STORE_BLOCK_PHY 
46bf cd 9e 0c			call Mult16 
46c2			 
46c2			 
46c2 11 59 f8			ld de, store_page 
46c5			 
46c5					if DEBUG_FORTH_WORDS 
46c5						DMARK "BR1" 
46c5 f5				push af  
46c6 3a da 46			ld a, (.dmark)  
46c9 32 6e fb			ld (debug_mark),a  
46cc 3a db 46			ld a, (.dmark+1)  
46cf 32 6f fb			ld (debug_mark+1),a  
46d2 3a dc 46			ld a, (.dmark+2)  
46d5 32 70 fb			ld (debug_mark+2),a  
46d8 18 03			jr .pastdmark  
46da ..			.dmark: db "BR1"  
46dd f1			.pastdmark: pop af  
46de			endm  
# End of macro DMARK
46de						CALLMONITOR 
46de cd 6a 17			call break_point_state  
46e1				endm  
# End of macro CALLMONITOR
46e1					endif 
46e1			 
46e1 cd 07 03			call storage_read_block 
46e4			 
46e4 cd 44 0d			call ishlzero 
46e7 20 05			jr nz, .brfound 
46e9			 
46e9 cd fa 1c			call forth_push_numhl 
46ec 18 22			jr .brdone 
46ee			 
46ee			 
46ee			.brfound: 
46ee 21 5b f8		        ld hl, store_page+2 
46f1			 
46f1					if DEBUG_FORTH_WORDS 
46f1						DMARK "BR2" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 6e fb			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 6f fb			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 70 fb			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "BR2"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a						CALLMONITOR 
470a cd 6a 17			call break_point_state  
470d				endm  
# End of macro CALLMONITOR
470d					endif 
470d			 
470d cd 68 1d			call forth_push_str 
4710			 
4710			 
4710			.brdone: 
4710			 
4710					NEXTW 
4710 c3 63 20			jp macro_next 
4713				endm 
# End of macro NEXTW
4713			.BWRITE: 
4713				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4713 3a				db WORD_SYS_CORE+38             
4714 a8 47			dw .BUPD            
4716 07				db 6 + 1 
4717 .. 00			db "BWRITE",0              
471e				endm 
# End of macro CWHEAD
471e			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
471e			 
471e					if DEBUG_FORTH_WORDS_KEY 
471e						DMARK "BWR" 
471e f5				push af  
471f 3a 33 47			ld a, (.dmark)  
4722 32 6e fb			ld (debug_mark),a  
4725 3a 34 47			ld a, (.dmark+1)  
4728 32 6f fb			ld (debug_mark+1),a  
472b 3a 35 47			ld a, (.dmark+2)  
472e 32 70 fb			ld (debug_mark+2),a  
4731 18 03			jr .pastdmark  
4733 ..			.dmark: db "BWR"  
4736 f1			.pastdmark: pop af  
4737			endm  
# End of macro DMARK
4737						CALLMONITOR 
4737 cd 6a 17			call break_point_state  
473a				endm  
# End of macro CALLMONITOR
473a					endif 
473a			 
473a				FORTH_DSP_VALUEHL 
473a cd f1 1e			call macro_dsp_valuehl 
473d				endm 
# End of macro FORTH_DSP_VALUEHL
473d			 
473d				; calc block address 
473d			 
473d eb				ex de, hl 
473e 3e 40			ld a, STORE_BLOCK_PHY 
4740 cd 9e 0c			call Mult16 
4743			 
4743 e5				push hl         ; address 
4744			 
4744				FORTH_DSP_POP 
4744 cd a9 1f			call macro_forth_dsp_pop 
4747				endm 
# End of macro FORTH_DSP_POP
4747			 
4747				FORTH_DSP_VALUEHL 
4747 cd f1 1e			call macro_dsp_valuehl 
474a				endm 
# End of macro FORTH_DSP_VALUEHL
474a			 
474a				FORTH_DSP_POP 
474a cd a9 1f			call macro_forth_dsp_pop 
474d				endm 
# End of macro FORTH_DSP_POP
474d			 
474d cd 27 0a			call storage_clear_page 
4750			 
4750				; copy string to store page 
4750			 
4750 e5				push hl     ; save string address 
4751			 
4751 3e 00			ld a, 0 
4753 cd 84 11			call strlent 
4756			 
4756 23				inc hl 
4757			 
4757 4d				ld c, l 
4758 06 00			ld b, 0 
475a			 
475a e1				pop hl 
475b 11 5b f8			ld de, store_page + 2 
475e					if DEBUG_FORTH_WORDS 
475e						DMARK "BW1" 
475e f5				push af  
475f 3a 73 47			ld a, (.dmark)  
4762 32 6e fb			ld (debug_mark),a  
4765 3a 74 47			ld a, (.dmark+1)  
4768 32 6f fb			ld (debug_mark+1),a  
476b 3a 75 47			ld a, (.dmark+2)  
476e 32 70 fb			ld (debug_mark+2),a  
4771 18 03			jr .pastdmark  
4773 ..			.dmark: db "BW1"  
4776 f1			.pastdmark: pop af  
4777			endm  
# End of macro DMARK
4777						CALLMONITOR 
4777 cd 6a 17			call break_point_state  
477a				endm  
# End of macro CALLMONITOR
477a					endif 
477a ed b0			ldir 
477c			 
477c			 
477c				; poke the start of the block with flags to prevent high level file ops hitting the block 
477c			 
477c 21 ff ff			ld hl, $ffff 
477f			 
477f 22 59 f8			ld (store_page), hl	 
4782				 
4782 e1				pop hl    ; get address 
4783 11 59 f8			ld de, store_page 
4786			 
4786					if DEBUG_FORTH_WORDS 
4786						DMARK "BW2" 
4786 f5				push af  
4787 3a 9b 47			ld a, (.dmark)  
478a 32 6e fb			ld (debug_mark),a  
478d 3a 9c 47			ld a, (.dmark+1)  
4790 32 6f fb			ld (debug_mark+1),a  
4793 3a 9d 47			ld a, (.dmark+2)  
4796 32 70 fb			ld (debug_mark+2),a  
4799 18 03			jr .pastdmark  
479b ..			.dmark: db "BW2"  
479e f1			.pastdmark: pop af  
479f			endm  
# End of macro DMARK
479f						CALLMONITOR 
479f cd 6a 17			call break_point_state  
47a2				endm  
# End of macro CALLMONITOR
47a2					endif 
47a2			 
47a2 cd 6c 03			call storage_write_block 
47a5			 
47a5					NEXTW 
47a5 c3 63 20			jp macro_next 
47a8				endm 
# End of macro NEXTW
47a8			 
47a8			.BUPD: 
47a8				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47a8 3a				db WORD_SYS_CORE+38             
47a9 fe 47			dw .BYID            
47ab 05				db 4 + 1 
47ac .. 00			db "BUPD",0              
47b1				endm 
# End of macro CWHEAD
47b1			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47b1			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47b1			; | | or completely different file system structure. 
47b1			 
47b1					if DEBUG_FORTH_WORDS_KEY 
47b1						DMARK "BUD" 
47b1 f5				push af  
47b2 3a c6 47			ld a, (.dmark)  
47b5 32 6e fb			ld (debug_mark),a  
47b8 3a c7 47			ld a, (.dmark+1)  
47bb 32 6f fb			ld (debug_mark+1),a  
47be 3a c8 47			ld a, (.dmark+2)  
47c1 32 70 fb			ld (debug_mark+2),a  
47c4 18 03			jr .pastdmark  
47c6 ..			.dmark: db "BUD"  
47c9 f1			.pastdmark: pop af  
47ca			endm  
# End of macro DMARK
47ca						CALLMONITOR 
47ca cd 6a 17			call break_point_state  
47cd				endm  
# End of macro CALLMONITOR
47cd					endif 
47cd			 
47cd				FORTH_DSP_VALUEHL 
47cd cd f1 1e			call macro_dsp_valuehl 
47d0				endm 
# End of macro FORTH_DSP_VALUEHL
47d0			 
47d0				; calc block address 
47d0			 
47d0 eb				ex de, hl 
47d1 3e 40			ld a, STORE_BLOCK_PHY 
47d3 cd 9e 0c			call Mult16 
47d6			 
47d6				FORTH_DSP_POP 
47d6 cd a9 1f			call macro_forth_dsp_pop 
47d9				endm 
# End of macro FORTH_DSP_POP
47d9			 
47d9			 
47d9 11 59 f8			ld de, store_page 
47dc			 
47dc					if DEBUG_FORTH_WORDS 
47dc						DMARK "BUe" 
47dc f5				push af  
47dd 3a f1 47			ld a, (.dmark)  
47e0 32 6e fb			ld (debug_mark),a  
47e3 3a f2 47			ld a, (.dmark+1)  
47e6 32 6f fb			ld (debug_mark+1),a  
47e9 3a f3 47			ld a, (.dmark+2)  
47ec 32 70 fb			ld (debug_mark+2),a  
47ef 18 03			jr .pastdmark  
47f1 ..			.dmark: db "BUe"  
47f4 f1			.pastdmark: pop af  
47f5			endm  
# End of macro DMARK
47f5						CALLMONITOR 
47f5 cd 6a 17			call break_point_state  
47f8				endm  
# End of macro CALLMONITOR
47f8					endif 
47f8			 
47f8 cd 6c 03			call storage_write_block 
47fb			 
47fb					NEXTW 
47fb c3 63 20			jp macro_next 
47fe				endm 
# End of macro NEXTW
47fe			 
47fe			.BYID: 
47fe			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47fe			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47fe			; 
47fe			;		 
47fe			;		if DEBUG_FORTH_WORDS_KEY 
47fe			;			DMARK "BYID" 
47fe			;			CALLMONITOR 
47fe			;		endif 
47fe			; 
47fe			;		; get direct address 
47fe			; 
47fe			;		FORTH_DSP_VALUEHL 
47fe			; 
47fe			;		FORTH_DSP_POP 
47fe			; 
47fe			;	; calc block address 
47fe			; 
47fe			;	ex de, hl 
47fe			;	ld a, STORE_BLOCK_PHY 
47fe			;	call Mult16 
47fe			;	;	do BREAD with number as param 
47fe			;	; push the file name	 
47fe			;	ld de, store_page 
47fe			;	call storage_read_block 
47fe			 ;       ld hl, store_page+2 
47fe			; 
47fe			; 
47fe			;		NEXTW 
47fe			;.BYNAME: 
47fe			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47fe			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47fe			;		NEXTW 
47fe			; 
47fe			.DIR: 
47fe				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47fe 3a				db WORD_SYS_CORE+38             
47ff 02 49			dw .SAVE            
4801 04				db 3 + 1 
4802 .. 00			db "DIR",0              
4806				endm 
# End of macro CWHEAD
4806			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4806			 
4806					if DEBUG_FORTH_WORDS_KEY 
4806						DMARK "DIR" 
4806 f5				push af  
4807 3a 1b 48			ld a, (.dmark)  
480a 32 6e fb			ld (debug_mark),a  
480d 3a 1c 48			ld a, (.dmark+1)  
4810 32 6f fb			ld (debug_mark+1),a  
4813 3a 1d 48			ld a, (.dmark+2)  
4816 32 70 fb			ld (debug_mark+2),a  
4819 18 03			jr .pastdmark  
481b ..			.dmark: db "DIR"  
481e f1			.pastdmark: pop af  
481f			endm  
# End of macro DMARK
481f						CALLMONITOR 
481f cd 6a 17			call break_point_state  
4822				endm  
# End of macro CALLMONITOR
4822					endif 
4822 cd b8 03			call storage_get_block_0 
4825			 
4825 21 59 f8			ld hl, store_page     ; get current id count 
4828 46				ld b, (hl) 
4829 0e 00			ld c, 0    ; count of files   
482b					if DEBUG_FORTH_WORDS 
482b						DMARK "DI1" 
482b f5				push af  
482c 3a 40 48			ld a, (.dmark)  
482f 32 6e fb			ld (debug_mark),a  
4832 3a 41 48			ld a, (.dmark+1)  
4835 32 6f fb			ld (debug_mark+1),a  
4838 3a 42 48			ld a, (.dmark+2)  
483b 32 70 fb			ld (debug_mark+2),a  
483e 18 03			jr .pastdmark  
4840 ..			.dmark: db "DI1"  
4843 f1			.pastdmark: pop af  
4844			endm  
# End of macro DMARK
4844						CALLMONITOR 
4844 cd 6a 17			call break_point_state  
4847				endm  
# End of macro CALLMONITOR
4847					endif 
4847			 
4847				; check for empty drive 
4847			 
4847 3e 00			ld a, 0 
4849 b8				cp b 
484a ca b8 48			jp z, .dirdone 
484d			 
484d				; for each of the current ids do a search for them and if found push to stack 
484d			 
484d c5			.diritem:	push bc 
484e 21 40 00				ld hl, STORE_BLOCK_PHY 
4851 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4853 58					ld e,b 
4854			 
4854			;		if DEBUG_FORTH_WORDS 
4854			;			DMARK "DI2" 
4854			;			CALLMONITOR 
4854			;		endif 
4854			 
4854 cd 2c 06				call storage_findnextid 
4857			 
4857			;		if DEBUG_FORTH_WORDS 
4857			;			DMARK "DI3" 
4857			;			CALLMONITOR 
4857			;		endif 
4857			 
4857					; if found hl will be non zero 
4857			 
4857 cd 44 0d				call ishlzero 
485a			;		ld a, l 
485a			;		add h 
485a			; 
485a			;		cp 0 
485a 28 59				jr z, .dirnotfound 
485c			 
485c					; increase count 
485c			 
485c c1					pop bc	 
485d 0c					inc c 
485e c5					push bc 
485f					 
485f			 
485f					; get file header and push the file name 
485f			 
485f 11 59 f8				ld de, store_page 
4862 cd 07 03				call storage_read_block 
4865			 
4865					; push file id to stack 
4865				 
4865 3a 59 f8				ld a, (store_page) 
4868 26 00				ld h, 0 
486a 6f					ld l, a 
486b cd fa 1c				call forth_push_numhl 
486e			 
486e					; push extent count to stack  
486e				 
486e 3a 5b f8				ld a, (store_page+2) 
4871 26 00				ld h, 0 
4873 6f					ld l, a 
4874 cd fa 1c				call forth_push_numhl 
4877			 
4877					; push file name 
4877			 
4877 21 5c f8				ld hl, store_page+3 
487a					if DEBUG_FORTH_WORDS 
487a						DMARK "DI5" 
487a f5				push af  
487b 3a 8f 48			ld a, (.dmark)  
487e 32 6e fb			ld (debug_mark),a  
4881 3a 90 48			ld a, (.dmark+1)  
4884 32 6f fb			ld (debug_mark+1),a  
4887 3a 91 48			ld a, (.dmark+2)  
488a 32 70 fb			ld (debug_mark+2),a  
488d 18 03			jr .pastdmark  
488f ..			.dmark: db "DI5"  
4892 f1			.pastdmark: pop af  
4893			endm  
# End of macro DMARK
4893						CALLMONITOR 
4893 cd 6a 17			call break_point_state  
4896				endm  
# End of macro CALLMONITOR
4896					endif 
4896 cd 68 1d				call forth_push_str 
4899					if DEBUG_FORTH_WORDS 
4899						DMARK "DI6" 
4899 f5				push af  
489a 3a ae 48			ld a, (.dmark)  
489d 32 6e fb			ld (debug_mark),a  
48a0 3a af 48			ld a, (.dmark+1)  
48a3 32 6f fb			ld (debug_mark+1),a  
48a6 3a b0 48			ld a, (.dmark+2)  
48a9 32 70 fb			ld (debug_mark+2),a  
48ac 18 03			jr .pastdmark  
48ae ..			.dmark: db "DI6"  
48b1 f1			.pastdmark: pop af  
48b2			endm  
# End of macro DMARK
48b2						CALLMONITOR 
48b2 cd 6a 17			call break_point_state  
48b5				endm  
# End of macro CALLMONITOR
48b5					endif 
48b5			.dirnotfound: 
48b5 c1					pop bc     
48b6 10 95				djnz .diritem 
48b8				 
48b8			.dirdone:	 
48b8					if DEBUG_FORTH_WORDS 
48b8						DMARK "DI7" 
48b8 f5				push af  
48b9 3a cd 48			ld a, (.dmark)  
48bc 32 6e fb			ld (debug_mark),a  
48bf 3a ce 48			ld a, (.dmark+1)  
48c2 32 6f fb			ld (debug_mark+1),a  
48c5 3a cf 48			ld a, (.dmark+2)  
48c8 32 70 fb			ld (debug_mark+2),a  
48cb 18 03			jr .pastdmark  
48cd ..			.dmark: db "DI7"  
48d0 f1			.pastdmark: pop af  
48d1			endm  
# End of macro DMARK
48d1						CALLMONITOR 
48d1 cd 6a 17			call break_point_state  
48d4				endm  
# End of macro CALLMONITOR
48d4					endif 
48d4			 
48d4					; push a count of the dir items found 
48d4			 
48d4 26 00				ld h, 0 
48d6 69					ld l, c 
48d7 cd fa 1c				call forth_push_numhl 
48da			 
48da					; push the bank label 
48da			 
48da cd b8 03				call storage_get_block_0 
48dd			 
48dd				 
48dd 21 5c f8		 		ld hl, store_page+3 
48e0			 
48e0					if DEBUG_FORTH_WORDS 
48e0						DMARK "DI8" 
48e0 f5				push af  
48e1 3a f5 48			ld a, (.dmark)  
48e4 32 6e fb			ld (debug_mark),a  
48e7 3a f6 48			ld a, (.dmark+1)  
48ea 32 6f fb			ld (debug_mark+1),a  
48ed 3a f7 48			ld a, (.dmark+2)  
48f0 32 70 fb			ld (debug_mark+2),a  
48f3 18 03			jr .pastdmark  
48f5 ..			.dmark: db "DI8"  
48f8 f1			.pastdmark: pop af  
48f9			endm  
# End of macro DMARK
48f9						CALLMONITOR 
48f9 cd 6a 17			call break_point_state  
48fc				endm  
# End of macro CALLMONITOR
48fc					endif 
48fc cd 68 1d				call forth_push_str 
48ff			 
48ff			 
48ff				 
48ff					NEXTW 
48ff c3 63 20			jp macro_next 
4902				endm 
# End of macro NEXTW
4902			.SAVE: 
4902			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4902			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4902			;		NEXTW 
4902			;.LOAD: 
4902			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4902			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4902			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4902			;; > > The LOAD command can not be used in any user words or compound lines. 
4902			; 
4902			;		; store_openext use it. If zero it is EOF 
4902			; 
4902			;		; read block from current stream id 
4902			;		; if the block does not contain zero term keep reading blocks until zero found 
4902			;		; push the block to stack 
4902			;		; save the block id to stream 
4902			; 
4902			; 
4902			;		FORTH_DSP_VALUEHL 
4902			; 
4902			;;		push hl 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOA" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		FORTH_DSP_POP 
4902			; 
4902			;;		pop hl 
4902			; 
4902			;		ld h, l 
4902			;		ld l, 0 
4902			; 
4902			;		push hl     ; stack holds current file id and extent to work with 
4902			; 
4902			; 
4902			;		ld de, store_page      ; get block zero of file 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO0" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		call storage_read 
4902			; 
4902			;		ld a, (store_page+2)    ; max extents for this file 
4902			;		ld  (store_openmaxext),a   ; get our limit 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOE" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			; 
4902			;; TODO dont know why max extents are not present 
4902			;;		cp 0 
4902			;;		jp z, .loadeof     ; dont read past eof 
4902			; 
4902			;;		ld a, 1   ; start from the head of the file 
4902			; 
4902			;.loadline:	pop hl 
4902			;		inc hl 
4902			;		ld  a, (store_openmaxext)   ; get our limit 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOx" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		inc a 
4902			;		cp l 
4902			;		jp z, .loadeof 
4902			;		push hl    ; save current extent 
4902			; 
4902			;		ld de, store_page 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO1" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		call storage_read 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO2" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;	call ishlzero 
4902			;	ld a, l 
4902			;	add h 
4902			;	cp 0 
4902			;	jr z, .loadeof 
4902			; 
4902			;	; not eof so hl should point to data to exec 
4902			; 
4902			;	; will need to add the FORTH_END_BUFFER flag 
4902			 ; 
4902			;	ld hl, store_page+2 
4902			;	ld bc, 255 
4902			;	ld a, 0 
4902			;	cpir 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOt" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;	dec hl 
4902			;	ld a, ' ' 
4902			;	ld (hl), a 
4902			;	inc hl 
4902			;	ld (hl), a 
4902			;	inc hl 
4902			;	ld (hl), a 
4902			;	inc hl 
4902			;	ld a, FORTH_END_BUFFER 
4902			;	ld (hl), a 
4902			; 
4902			;	; TODO handle more than a single block read 
4902			; 
4902			; 
4902			;	ld hl, store_page+2 
4902			; 
4902			;	ld (os_tok_ptr), hl 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO3" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			; 
4902			;	call forthparse 
4902			;	call forthexec 
4902			;	call forthexec_cleanup 
4902			; 
4902			;	; go to next extent 
4902			; 
4902			;	; get next block  or mark as eof 
4902			;	jp .loadline 
4902			; 
4902			; 
4902			; 
4902			;	       NEXTW 
4902			;.loadeof:	ld a, 0 
4902			;		ld (store_openext), a 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOF" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		ret 
4902			;		;NEXTW 
4902			;.BSAVE:   
4902			; 
4902			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4902			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4902			;		NEXTW 
4902			;.BLOAD: 
4902			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4902			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4902			;		NEXTW 
4902			;;;; counter gap 
4902			 
4902			 
4902			.SEO: 
4902				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4902 64				db WORD_SYS_CORE+80             
4903 21 49			dw .SEI            
4905 04				db 3 + 1 
4906 .. 00			db "SEO",0              
490a				endm 
# End of macro CWHEAD
490a			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
490a			 
490a					; get port 
490a			 
490a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
490a cd f1 1e			call macro_dsp_valuehl 
490d				endm 
# End of macro FORTH_DSP_VALUEHL
490d			 
490d e5					push hl    ; u2 - byte 
490e			 
490e					; destroy value TOS 
490e			 
490e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
490e cd a9 1f			call macro_forth_dsp_pop 
4911				endm 
# End of macro FORTH_DSP_POP
4911			 
4911					; get byte to send 
4911			 
4911					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4911 cd f1 1e			call macro_dsp_valuehl 
4914				endm 
# End of macro FORTH_DSP_VALUEHL
4914			 
4914 e5					push hl    ; u1 - addr 
4915			 
4915					; destroy value TOS 
4915			 
4915					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4915 cd a9 1f			call macro_forth_dsp_pop 
4918				endm 
# End of macro FORTH_DSP_POP
4918			 
4918					; one value on hl get other one back 
4918			 
4918 d1					pop de   ; u1 - byte 
4919			 
4919 e1					pop hl   ; u2 - addr 
491a			 
491a					; TODO Send SPI byte 
491a			 
491a			 
491a 7b					ld a, e 
491b cd e5 01				call se_writebyte 
491e			 
491e					 
491e			 
491e					NEXTW 
491e c3 63 20			jp macro_next 
4921				endm 
# End of macro NEXTW
4921			 
4921			.SEI: 
4921				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4921 65				db WORD_SYS_CORE+81             
4922 3b 49			dw .SFREE            
4924 04				db 3 + 1 
4925 .. 00			db "SEI",0              
4929				endm 
# End of macro CWHEAD
4929			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4929			 
4929					; get port 
4929			 
4929					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4929 cd f1 1e			call macro_dsp_valuehl 
492c				endm 
# End of macro FORTH_DSP_VALUEHL
492c			 
492c			;		push hl 
492c			 
492c					; destroy value TOS 
492c			 
492c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
492c cd a9 1f			call macro_forth_dsp_pop 
492f				endm 
# End of macro FORTH_DSP_POP
492f			 
492f					; one value on hl get other one back 
492f			 
492f			;		pop hl 
492f			 
492f			 
492f					; TODO Get SPI byte 
492f			 
492f cd 87 02				call se_readbyte 
4932			 
4932 26 00				ld h, 0 
4934 6f					ld l, a 
4935 cd fa 1c				call forth_push_numhl 
4938			 
4938					NEXTW 
4938 c3 63 20			jp macro_next 
493b				endm 
# End of macro NEXTW
493b			 
493b			.SFREE: 
493b				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
493b 67				db WORD_SYS_CORE+83             
493c 6a 49			dw .SIZE            
493e 06				db 5 + 1 
493f .. 00			db "FFREE",0              
4945				endm 
# End of macro CWHEAD
4945			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4945					if DEBUG_FORTH_WORDS_KEY 
4945						DMARK "FFR" 
4945 f5				push af  
4946 3a 5a 49			ld a, (.dmark)  
4949 32 6e fb			ld (debug_mark),a  
494c 3a 5b 49			ld a, (.dmark+1)  
494f 32 6f fb			ld (debug_mark+1),a  
4952 3a 5c 49			ld a, (.dmark+2)  
4955 32 70 fb			ld (debug_mark+2),a  
4958 18 03			jr .pastdmark  
495a ..			.dmark: db "FFR"  
495d f1			.pastdmark: pop af  
495e			endm  
# End of macro DMARK
495e						CALLMONITOR 
495e cd 6a 17			call break_point_state  
4961				endm  
# End of macro CALLMONITOR
4961					endif 
4961			 
4961 cd c6 06				call storage_freeblocks 
4964			 
4964 cd fa 1c				call forth_push_numhl 
4967			 
4967				       NEXTW 
4967 c3 63 20			jp macro_next 
496a				endm 
# End of macro NEXTW
496a			.SIZE: 
496a				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
496a 67				db WORD_SYS_CORE+83             
496b 9e 49			dw .CREATE            
496d 05				db 4 + 1 
496e .. 00			db "SIZE",0              
4973				endm 
# End of macro CWHEAD
4973			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4973					if DEBUG_FORTH_WORDS_KEY 
4973						DMARK "SIZ" 
4973 f5				push af  
4974 3a 88 49			ld a, (.dmark)  
4977 32 6e fb			ld (debug_mark),a  
497a 3a 89 49			ld a, (.dmark+1)  
497d 32 6f fb			ld (debug_mark+1),a  
4980 3a 8a 49			ld a, (.dmark+2)  
4983 32 70 fb			ld (debug_mark+2),a  
4986 18 03			jr .pastdmark  
4988 ..			.dmark: db "SIZ"  
498b f1			.pastdmark: pop af  
498c			endm  
# End of macro DMARK
498c						CALLMONITOR 
498c cd 6a 17			call break_point_state  
498f				endm  
# End of macro CALLMONITOR
498f					endif 
498f			 
498f					FORTH_DSP_VALUEHL 
498f cd f1 1e			call macro_dsp_valuehl 
4992				endm 
# End of macro FORTH_DSP_VALUEHL
4992			;		push hl 
4992					FORTH_DSP_POP 
4992 cd a9 1f			call macro_forth_dsp_pop 
4995				endm 
# End of macro FORTH_DSP_POP
4995			;		pop hl 
4995 cd 36 03				call storage_file_size 
4998			 
4998 cd fa 1c				call forth_push_numhl 
499b			  
499b			 
499b				       NEXTW 
499b c3 63 20			jp macro_next 
499e				endm 
# End of macro NEXTW
499e			 
499e			.CREATE: 
499e				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
499e 68				db WORD_SYS_CORE+84             
499f 0c 4a			dw .APPEND            
49a1 07				db 6 + 1 
49a2 .. 00			db "CREATE",0              
49a9				endm 
# End of macro CWHEAD
49a9			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49a9			; | | e.g.  
49a9			; | | TestProgram CREATE 
49a9			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49a9			; | |  
49a9			; | | Max file IDs are 255. 
49a9			; | |  
49a9					 
49a9					if DEBUG_FORTH_WORDS_KEY 
49a9						DMARK "CRT" 
49a9 f5				push af  
49aa 3a be 49			ld a, (.dmark)  
49ad 32 6e fb			ld (debug_mark),a  
49b0 3a bf 49			ld a, (.dmark+1)  
49b3 32 6f fb			ld (debug_mark+1),a  
49b6 3a c0 49			ld a, (.dmark+2)  
49b9 32 70 fb			ld (debug_mark+2),a  
49bc 18 03			jr .pastdmark  
49be ..			.dmark: db "CRT"  
49c1 f1			.pastdmark: pop af  
49c2			endm  
# End of macro DMARK
49c2						CALLMONITOR 
49c2 cd 6a 17			call break_point_state  
49c5				endm  
# End of macro CALLMONITOR
49c5					endif 
49c5			;		call storage_get_block_0 
49c5			 
49c5					; TODO pop hl 
49c5			 
49c5					;v5 FORTH_DSP_VALUE 
49c5					FORTH_DSP_VALUE 
49c5 cd da 1e			call macro_forth_dsp_value 
49c8				endm 
# End of macro FORTH_DSP_VALUE
49c8			 
49c8				if DEBUG_STORESE 
49c8					DMARK "CR1" 
49c8 f5				push af  
49c9 3a dd 49			ld a, (.dmark)  
49cc 32 6e fb			ld (debug_mark),a  
49cf 3a de 49			ld a, (.dmark+1)  
49d2 32 6f fb			ld (debug_mark+1),a  
49d5 3a df 49			ld a, (.dmark+2)  
49d8 32 70 fb			ld (debug_mark+2),a  
49db 18 03			jr .pastdmark  
49dd ..			.dmark: db "CR1"  
49e0 f1			.pastdmark: pop af  
49e1			endm  
# End of macro DMARK
49e1					CALLMONITOR 
49e1 cd 6a 17			call break_point_state  
49e4				endm  
# End of macro CALLMONITOR
49e4				endif 
49e4			;		push hl 
49e4			;		FORTH_DSP_POP 
49e4			;		pop hl 
49e4			 
49e4			;		inc hl   ; move past the type marker 
49e4			 
49e4 cd fc 06				call storage_create 
49e7			 
49e7				if DEBUG_STORESE 
49e7					DMARK "CT1" 
49e7 f5				push af  
49e8 3a fc 49			ld a, (.dmark)  
49eb 32 6e fb			ld (debug_mark),a  
49ee 3a fd 49			ld a, (.dmark+1)  
49f1 32 6f fb			ld (debug_mark+1),a  
49f4 3a fe 49			ld a, (.dmark+2)  
49f7 32 70 fb			ld (debug_mark+2),a  
49fa 18 03			jr .pastdmark  
49fc ..			.dmark: db "CT1"  
49ff f1			.pastdmark: pop af  
4a00			endm  
# End of macro DMARK
4a00					CALLMONITOR 
4a00 cd 6a 17			call break_point_state  
4a03				endm  
# End of macro CALLMONITOR
4a03				endif 
4a03			;		push hl 
4a03					FORTH_DSP_POP 
4a03 cd a9 1f			call macro_forth_dsp_pop 
4a06				endm 
# End of macro FORTH_DSP_POP
4a06			;		pop hl 
4a06					; push file id to stack 
4a06 cd fa 1c				call forth_push_numhl 
4a09			 
4a09			 
4a09			 
4a09				       NEXTW 
4a09 c3 63 20			jp macro_next 
4a0c				endm 
# End of macro NEXTW
4a0c			 
4a0c			.APPEND: 
4a0c				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a0c 69				db WORD_SYS_CORE+85             
4a0d 9d 4a			dw .SDEL            
4a0f 07				db 6 + 1 
4a10 .. 00			db "APPEND",0              
4a17				endm 
# End of macro CWHEAD
4a17			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a17			; | | e.g. 
4a17			; | | Test CREATE      -> $01 
4a17			; | | "A string to add to file" $01 APPEND 
4a17			; | |  
4a17			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a17					if DEBUG_FORTH_WORDS_KEY 
4a17						DMARK "APP" 
4a17 f5				push af  
4a18 3a 2c 4a			ld a, (.dmark)  
4a1b 32 6e fb			ld (debug_mark),a  
4a1e 3a 2d 4a			ld a, (.dmark+1)  
4a21 32 6f fb			ld (debug_mark+1),a  
4a24 3a 2e 4a			ld a, (.dmark+2)  
4a27 32 70 fb			ld (debug_mark+2),a  
4a2a 18 03			jr .pastdmark  
4a2c ..			.dmark: db "APP"  
4a2f f1			.pastdmark: pop af  
4a30			endm  
# End of macro DMARK
4a30						CALLMONITOR 
4a30 cd 6a 17			call break_point_state  
4a33				endm  
# End of macro CALLMONITOR
4a33					endif 
4a33			 
4a33					FORTH_DSP_VALUEHL 
4a33 cd f1 1e			call macro_dsp_valuehl 
4a36				endm 
# End of macro FORTH_DSP_VALUEHL
4a36 e5					push hl 	; save file id 
4a37			 
4a37				if DEBUG_STORESE 
4a37					DMARK "AP1" 
4a37 f5				push af  
4a38 3a 4c 4a			ld a, (.dmark)  
4a3b 32 6e fb			ld (debug_mark),a  
4a3e 3a 4d 4a			ld a, (.dmark+1)  
4a41 32 6f fb			ld (debug_mark+1),a  
4a44 3a 4e 4a			ld a, (.dmark+2)  
4a47 32 70 fb			ld (debug_mark+2),a  
4a4a 18 03			jr .pastdmark  
4a4c ..			.dmark: db "AP1"  
4a4f f1			.pastdmark: pop af  
4a50			endm  
# End of macro DMARK
4a50					CALLMONITOR 
4a50 cd 6a 17			call break_point_state  
4a53				endm  
# End of macro CALLMONITOR
4a53				endif 
4a53					FORTH_DSP_POP 
4a53 cd a9 1f			call macro_forth_dsp_pop 
4a56				endm 
# End of macro FORTH_DSP_POP
4a56			 
4a56					FORTH_DSP_VALUEHL 
4a56 cd f1 1e			call macro_dsp_valuehl 
4a59				endm 
# End of macro FORTH_DSP_VALUEHL
4a59					;v5 FORTH_DSP_VALUE 
4a59 e5					push hl 	; save ptr to string to save 
4a5a			 
4a5a				if DEBUG_STORESE 
4a5a					DMARK "AP1" 
4a5a f5				push af  
4a5b 3a 6f 4a			ld a, (.dmark)  
4a5e 32 6e fb			ld (debug_mark),a  
4a61 3a 70 4a			ld a, (.dmark+1)  
4a64 32 6f fb			ld (debug_mark+1),a  
4a67 3a 71 4a			ld a, (.dmark+2)  
4a6a 32 70 fb			ld (debug_mark+2),a  
4a6d 18 03			jr .pastdmark  
4a6f ..			.dmark: db "AP1"  
4a72 f1			.pastdmark: pop af  
4a73			endm  
# End of macro DMARK
4a73					CALLMONITOR 
4a73 cd 6a 17			call break_point_state  
4a76				endm  
# End of macro CALLMONITOR
4a76				endif 
4a76					FORTH_DSP_POP 
4a76 cd a9 1f			call macro_forth_dsp_pop 
4a79				endm 
# End of macro FORTH_DSP_POP
4a79			 
4a79 d1					pop de 
4a7a e1					pop hl 
4a7b				if DEBUG_STORESE 
4a7b					DMARK "AP2" 
4a7b f5				push af  
4a7c 3a 90 4a			ld a, (.dmark)  
4a7f 32 6e fb			ld (debug_mark),a  
4a82 3a 91 4a			ld a, (.dmark+1)  
4a85 32 6f fb			ld (debug_mark+1),a  
4a88 3a 92 4a			ld a, (.dmark+2)  
4a8b 32 70 fb			ld (debug_mark+2),a  
4a8e 18 03			jr .pastdmark  
4a90 ..			.dmark: db "AP2"  
4a93 f1			.pastdmark: pop af  
4a94			endm  
# End of macro DMARK
4a94					CALLMONITOR 
4a94 cd 6a 17			call break_point_state  
4a97				endm  
# End of macro CALLMONITOR
4a97				endif 
4a97					;inc de ; skip var type indicator 
4a97			 
4a97					; TODO how to append numerics???? 
4a97			 
4a97 cd db 08				call storage_append		 
4a9a			 
4a9a				       NEXTW 
4a9a c3 63 20			jp macro_next 
4a9d				endm 
# End of macro NEXTW
4a9d			.SDEL: 
4a9d				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a9d 6a				db WORD_SYS_CORE+86             
4a9e e9 4a			dw .OPEN            
4aa0 05				db 4 + 1 
4aa1 .. 00			db "ERA",0              
4aa5				endm 
# End of macro CWHEAD
4aa5			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4aa5					FORTH_DSP_VALUEHL 
4aa5 cd f1 1e			call macro_dsp_valuehl 
4aa8				endm 
# End of macro FORTH_DSP_VALUEHL
4aa8			;		push hl 	; save file id 
4aa8			 
4aa8					if DEBUG_FORTH_WORDS_KEY 
4aa8						DMARK "ERA" 
4aa8 f5				push af  
4aa9 3a bd 4a			ld a, (.dmark)  
4aac 32 6e fb			ld (debug_mark),a  
4aaf 3a be 4a			ld a, (.dmark+1)  
4ab2 32 6f fb			ld (debug_mark+1),a  
4ab5 3a bf 4a			ld a, (.dmark+2)  
4ab8 32 70 fb			ld (debug_mark+2),a  
4abb 18 03			jr .pastdmark  
4abd ..			.dmark: db "ERA"  
4ac0 f1			.pastdmark: pop af  
4ac1			endm  
# End of macro DMARK
4ac1						CALLMONITOR 
4ac1 cd 6a 17			call break_point_state  
4ac4				endm  
# End of macro CALLMONITOR
4ac4					endif 
4ac4				if DEBUG_STORESE 
4ac4					DMARK "ER1" 
4ac4 f5				push af  
4ac5 3a d9 4a			ld a, (.dmark)  
4ac8 32 6e fb			ld (debug_mark),a  
4acb 3a da 4a			ld a, (.dmark+1)  
4ace 32 6f fb			ld (debug_mark+1),a  
4ad1 3a db 4a			ld a, (.dmark+2)  
4ad4 32 70 fb			ld (debug_mark+2),a  
4ad7 18 03			jr .pastdmark  
4ad9 ..			.dmark: db "ER1"  
4adc f1			.pastdmark: pop af  
4add			endm  
# End of macro DMARK
4add					CALLMONITOR 
4add cd 6a 17			call break_point_state  
4ae0				endm  
# End of macro CALLMONITOR
4ae0				endif 
4ae0					FORTH_DSP_POP 
4ae0 cd a9 1f			call macro_forth_dsp_pop 
4ae3				endm 
# End of macro FORTH_DSP_POP
4ae3			 
4ae3			;		pop hl 
4ae3			 
4ae3 cd 47 05				call storage_erase 
4ae6				       NEXTW 
4ae6 c3 63 20			jp macro_next 
4ae9				endm 
# End of macro NEXTW
4ae9			 
4ae9			.OPEN: 
4ae9				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4ae9 6b				db WORD_SYS_CORE+87             
4aea 79 4b			dw .READ            
4aec 05				db 4 + 1 
4aed .. 00			db "OPEN",0              
4af2				endm 
# End of macro CWHEAD
4af2			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4af2			; | | e.g. 
4af2			; | | $01 OPEN $01 DO $01 READ . LOOP 
4af2			; | | 
4af2			; | | Will return with 255 blocks if the file does not exist 
4af2			 
4af2					if DEBUG_FORTH_WORDS_KEY 
4af2						DMARK "OPN" 
4af2 f5				push af  
4af3 3a 07 4b			ld a, (.dmark)  
4af6 32 6e fb			ld (debug_mark),a  
4af9 3a 08 4b			ld a, (.dmark+1)  
4afc 32 6f fb			ld (debug_mark+1),a  
4aff 3a 09 4b			ld a, (.dmark+2)  
4b02 32 70 fb			ld (debug_mark+2),a  
4b05 18 03			jr .pastdmark  
4b07 ..			.dmark: db "OPN"  
4b0a f1			.pastdmark: pop af  
4b0b			endm  
# End of macro DMARK
4b0b						CALLMONITOR 
4b0b cd 6a 17			call break_point_state  
4b0e				endm  
# End of macro CALLMONITOR
4b0e					endif 
4b0e					; TODO handle multiple file opens 
4b0e			 
4b0e 3e 01			       	ld a, 1 
4b10 32 50 f8				ld (store_openext), a 
4b13			 
4b13					; get max extents for this file 
4b13				 
4b13								 
4b13					FORTH_DSP_VALUEHL 
4b13 cd f1 1e			call macro_dsp_valuehl 
4b16				endm 
# End of macro FORTH_DSP_VALUEHL
4b16			 
4b16 65					ld h, l 
4b17 2e 00				ld l, 0 
4b19			 
4b19				if DEBUG_STORESE 
4b19					DMARK "OPN" 
4b19 f5				push af  
4b1a 3a 2e 4b			ld a, (.dmark)  
4b1d 32 6e fb			ld (debug_mark),a  
4b20 3a 2f 4b			ld a, (.dmark+1)  
4b23 32 6f fb			ld (debug_mark+1),a  
4b26 3a 30 4b			ld a, (.dmark+2)  
4b29 32 70 fb			ld (debug_mark+2),a  
4b2c 18 03			jr .pastdmark  
4b2e ..			.dmark: db "OPN"  
4b31 f1			.pastdmark: pop af  
4b32			endm  
# End of macro DMARK
4b32					CALLMONITOR 
4b32 cd 6a 17			call break_point_state  
4b35				endm  
# End of macro CALLMONITOR
4b35				endif 
4b35			;		push hl 
4b35					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b35 cd a9 1f			call macro_forth_dsp_pop 
4b38				endm 
# End of macro FORTH_DSP_POP
4b38			;		pop hl 
4b38						 
4b38 11 59 f8				ld de, store_page      ; get block zero of file 
4b3b cd 52 08				call storage_read 
4b3e cd 44 0d			call ishlzero 
4b41 20 04			jr nz, .opfound 
4b43			 
4b43				; file does not exist so indicate with 255 extents in use 
4b43			 
4b43 3e ff			ld a, 255 
4b45 18 29			jr .skipopeneof 
4b47			 
4b47			 
4b47			.opfound: 
4b47			 
4b47			 
4b47 3a 5b f8				ld a, (store_page+2)    ; max extents for this file 
4b4a 32 4f f8				ld  (store_openmaxext), a   ; get our limit and push 
4b4d					 
4b4d				if DEBUG_STORESE 
4b4d					DMARK "OPx" 
4b4d f5				push af  
4b4e 3a 62 4b			ld a, (.dmark)  
4b51 32 6e fb			ld (debug_mark),a  
4b54 3a 63 4b			ld a, (.dmark+1)  
4b57 32 6f fb			ld (debug_mark+1),a  
4b5a 3a 64 4b			ld a, (.dmark+2)  
4b5d 32 70 fb			ld (debug_mark+2),a  
4b60 18 03			jr .pastdmark  
4b62 ..			.dmark: db "OPx"  
4b65 f1			.pastdmark: pop af  
4b66			endm  
# End of macro DMARK
4b66					CALLMONITOR 
4b66 cd 6a 17			call break_point_state  
4b69				endm  
# End of macro CALLMONITOR
4b69				endif 
4b69 fe 00				cp 0 
4b6b 20 03				jr nz, .skipopeneof 
4b6d					; have opened an empty file 
4b6d					 
4b6d 32 50 f8				ld (store_openext), a 
4b70			 
4b70			.skipopeneof: 
4b70			 
4b70 6f					ld l, a 
4b71 26 00				ld h, 0 
4b73 cd fa 1c				call forth_push_numhl 
4b76			 
4b76			 
4b76				       NEXTW 
4b76 c3 63 20			jp macro_next 
4b79				endm 
# End of macro NEXTW
4b79			.READ: 
4b79				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b79 6c				db WORD_SYS_CORE+88             
4b7a c0 4c			dw .EOF            
4b7c 05				db 4 + 1 
4b7d .. 00			db "READ",0              
4b82				endm 
# End of macro CWHEAD
4b82			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b82			; | | e.g. 
4b82			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b82			 
4b82					if DEBUG_FORTH_WORDS_KEY 
4b82						DMARK "REA" 
4b82 f5				push af  
4b83 3a 97 4b			ld a, (.dmark)  
4b86 32 6e fb			ld (debug_mark),a  
4b89 3a 98 4b			ld a, (.dmark+1)  
4b8c 32 6f fb			ld (debug_mark+1),a  
4b8f 3a 99 4b			ld a, (.dmark+2)  
4b92 32 70 fb			ld (debug_mark+2),a  
4b95 18 03			jr .pastdmark  
4b97 ..			.dmark: db "REA"  
4b9a f1			.pastdmark: pop af  
4b9b			endm  
# End of macro DMARK
4b9b						CALLMONITOR 
4b9b cd 6a 17			call break_point_state  
4b9e				endm  
# End of macro CALLMONITOR
4b9e					endif 
4b9e					; store_openext use it. If zero it is EOF 
4b9e			 
4b9e					; read block from current stream id 
4b9e					; if the block does not contain zero term keep reading blocks until zero found 
4b9e					; push the block to stack 
4b9e					; save the block id to stream 
4b9e			 
4b9e			 
4b9e					FORTH_DSP_VALUEHL 
4b9e cd f1 1e			call macro_dsp_valuehl 
4ba1				endm 
# End of macro FORTH_DSP_VALUEHL
4ba1			 
4ba1			;		push hl 
4ba1			 
4ba1				if DEBUG_STORESE 
4ba1					DMARK "REA" 
4ba1 f5				push af  
4ba2 3a b6 4b			ld a, (.dmark)  
4ba5 32 6e fb			ld (debug_mark),a  
4ba8 3a b7 4b			ld a, (.dmark+1)  
4bab 32 6f fb			ld (debug_mark+1),a  
4bae 3a b8 4b			ld a, (.dmark+2)  
4bb1 32 70 fb			ld (debug_mark+2),a  
4bb4 18 03			jr .pastdmark  
4bb6 ..			.dmark: db "REA"  
4bb9 f1			.pastdmark: pop af  
4bba			endm  
# End of macro DMARK
4bba					CALLMONITOR 
4bba cd 6a 17			call break_point_state  
4bbd				endm  
# End of macro CALLMONITOR
4bbd				endif 
4bbd					FORTH_DSP_POP 
4bbd cd a9 1f			call macro_forth_dsp_pop 
4bc0				endm 
# End of macro FORTH_DSP_POP
4bc0			 
4bc0			;		pop hl 
4bc0				 
4bc0 65					ld h,l 
4bc1			 
4bc1 3a 50 f8				ld a, (store_openext) 
4bc4 6f					ld l, a 
4bc5					 
4bc5 fe 00				cp 0 
4bc7 ca 92 4c				jp z, .ateof     ; dont read past eof 
4bca			 
4bca			 
4bca 11 59 f8				ld de, store_page 
4bcd				if DEBUG_STORESE 
4bcd					DMARK "RE1" 
4bcd f5				push af  
4bce 3a e2 4b			ld a, (.dmark)  
4bd1 32 6e fb			ld (debug_mark),a  
4bd4 3a e3 4b			ld a, (.dmark+1)  
4bd7 32 6f fb			ld (debug_mark+1),a  
4bda 3a e4 4b			ld a, (.dmark+2)  
4bdd 32 70 fb			ld (debug_mark+2),a  
4be0 18 03			jr .pastdmark  
4be2 ..			.dmark: db "RE1"  
4be5 f1			.pastdmark: pop af  
4be6			endm  
# End of macro DMARK
4be6					CALLMONITOR 
4be6 cd 6a 17			call break_point_state  
4be9				endm  
# End of macro CALLMONITOR
4be9				endif 
4be9 cd 52 08				call storage_read 
4bec			 
4bec				if DEBUG_STORESE 
4bec					DMARK "RE2" 
4bec f5				push af  
4bed 3a 01 4c			ld a, (.dmark)  
4bf0 32 6e fb			ld (debug_mark),a  
4bf3 3a 02 4c			ld a, (.dmark+1)  
4bf6 32 6f fb			ld (debug_mark+1),a  
4bf9 3a 03 4c			ld a, (.dmark+2)  
4bfc 32 70 fb			ld (debug_mark+2),a  
4bff 18 03			jr .pastdmark  
4c01 ..			.dmark: db "RE2"  
4c04 f1			.pastdmark: pop af  
4c05			endm  
# End of macro DMARK
4c05					CALLMONITOR 
4c05 cd 6a 17			call break_point_state  
4c08				endm  
# End of macro CALLMONITOR
4c08				endif 
4c08 cd 44 0d			call ishlzero 
4c0b			;	ld a, l 
4c0b			;	add h 
4c0b			;	cp 0 
4c0b ca 98 4c			jp z, .readeof 
4c0e			 
4c0e				; not eof so hl should point to data to push to stack 
4c0e			 
4c0e				if DEBUG_STORESE 
4c0e					DMARK "RE3" 
4c0e f5				push af  
4c0f 3a 23 4c			ld a, (.dmark)  
4c12 32 6e fb			ld (debug_mark),a  
4c15 3a 24 4c			ld a, (.dmark+1)  
4c18 32 6f fb			ld (debug_mark+1),a  
4c1b 3a 25 4c			ld a, (.dmark+2)  
4c1e 32 70 fb			ld (debug_mark+2),a  
4c21 18 03			jr .pastdmark  
4c23 ..			.dmark: db "RE3"  
4c26 f1			.pastdmark: pop af  
4c27			endm  
# End of macro DMARK
4c27					CALLMONITOR 
4c27 cd 6a 17			call break_point_state  
4c2a				endm  
# End of macro CALLMONITOR
4c2a				endif 
4c2a cd 68 1d			call forth_push_str 
4c2d			 
4c2d				if DEBUG_STORESE 
4c2d					DMARK "RE4" 
4c2d f5				push af  
4c2e 3a 42 4c			ld a, (.dmark)  
4c31 32 6e fb			ld (debug_mark),a  
4c34 3a 43 4c			ld a, (.dmark+1)  
4c37 32 6f fb			ld (debug_mark+1),a  
4c3a 3a 44 4c			ld a, (.dmark+2)  
4c3d 32 70 fb			ld (debug_mark+2),a  
4c40 18 03			jr .pastdmark  
4c42 ..			.dmark: db "RE4"  
4c45 f1			.pastdmark: pop af  
4c46			endm  
# End of macro DMARK
4c46					CALLMONITOR 
4c46 cd 6a 17			call break_point_state  
4c49				endm  
# End of macro CALLMONITOR
4c49				endif 
4c49				; get next block  or mark as eof 
4c49			 
4c49 3a 4f f8			ld a, (store_openmaxext)   ; get our limit 
4c4c 4f				ld c, a	 
4c4d 3a 50 f8			ld a, (store_openext) 
4c50			 
4c50				if DEBUG_STORESE 
4c50					DMARK "RE5" 
4c50 f5				push af  
4c51 3a 65 4c			ld a, (.dmark)  
4c54 32 6e fb			ld (debug_mark),a  
4c57 3a 66 4c			ld a, (.dmark+1)  
4c5a 32 6f fb			ld (debug_mark+1),a  
4c5d 3a 67 4c			ld a, (.dmark+2)  
4c60 32 70 fb			ld (debug_mark+2),a  
4c63 18 03			jr .pastdmark  
4c65 ..			.dmark: db "RE5"  
4c68 f1			.pastdmark: pop af  
4c69			endm  
# End of macro DMARK
4c69					CALLMONITOR 
4c69 cd 6a 17			call break_point_state  
4c6c				endm  
# End of macro CALLMONITOR
4c6c				endif 
4c6c b9				cp c 
4c6d 28 29			jr z, .readeof     ; at last extent 
4c6f			 
4c6f 3c					inc a 
4c70 32 50 f8				ld (store_openext), a 
4c73			 
4c73				if DEBUG_STORESE 
4c73					DMARK "RE6" 
4c73 f5				push af  
4c74 3a 88 4c			ld a, (.dmark)  
4c77 32 6e fb			ld (debug_mark),a  
4c7a 3a 89 4c			ld a, (.dmark+1)  
4c7d 32 6f fb			ld (debug_mark+1),a  
4c80 3a 8a 4c			ld a, (.dmark+2)  
4c83 32 70 fb			ld (debug_mark+2),a  
4c86 18 03			jr .pastdmark  
4c88 ..			.dmark: db "RE6"  
4c8b f1			.pastdmark: pop af  
4c8c			endm  
# End of macro DMARK
4c8c					CALLMONITOR 
4c8c cd 6a 17			call break_point_state  
4c8f				endm  
# End of macro CALLMONITOR
4c8f				endif 
4c8f			 
4c8f			 
4c8f				       NEXTW 
4c8f c3 63 20			jp macro_next 
4c92				endm 
# End of macro NEXTW
4c92			.ateof: 
4c92 21 bc 4c				ld hl, .showeof 
4c95 cd 68 1d				call forth_push_str 
4c98 3e 00		.readeof:	ld a, 0 
4c9a 32 50 f8				ld (store_openext), a 
4c9d			 
4c9d					 
4c9d				if DEBUG_STORESE 
4c9d					DMARK "REF" 
4c9d f5				push af  
4c9e 3a b2 4c			ld a, (.dmark)  
4ca1 32 6e fb			ld (debug_mark),a  
4ca4 3a b3 4c			ld a, (.dmark+1)  
4ca7 32 6f fb			ld (debug_mark+1),a  
4caa 3a b4 4c			ld a, (.dmark+2)  
4cad 32 70 fb			ld (debug_mark+2),a  
4cb0 18 03			jr .pastdmark  
4cb2 ..			.dmark: db "REF"  
4cb5 f1			.pastdmark: pop af  
4cb6			endm  
# End of macro DMARK
4cb6					CALLMONITOR 
4cb6 cd 6a 17			call break_point_state  
4cb9				endm  
# End of macro CALLMONITOR
4cb9				endif 
4cb9				       NEXTW 
4cb9 c3 63 20			jp macro_next 
4cbc				endm 
# End of macro NEXTW
4cbc			 
4cbc .. 00		.showeof:   db "eof", 0 
4cc0			 
4cc0			 
4cc0			.EOF: 
4cc0				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4cc0 6d				db WORD_SYS_CORE+89             
4cc1 01 4d			dw .FORMAT            
4cc3 04				db 3 + 1 
4cc4 .. 00			db "EOF",0              
4cc8				endm 
# End of macro CWHEAD
4cc8			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4cc8			; | | e.g. 
4cc8			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4cc8					; TODO if current block id for stream is zero then push true else false 
4cc8			 
4cc8					if DEBUG_FORTH_WORDS_KEY 
4cc8						DMARK "EOF" 
4cc8 f5				push af  
4cc9 3a dd 4c			ld a, (.dmark)  
4ccc 32 6e fb			ld (debug_mark),a  
4ccf 3a de 4c			ld a, (.dmark+1)  
4cd2 32 6f fb			ld (debug_mark+1),a  
4cd5 3a df 4c			ld a, (.dmark+2)  
4cd8 32 70 fb			ld (debug_mark+2),a  
4cdb 18 03			jr .pastdmark  
4cdd ..			.dmark: db "EOF"  
4ce0 f1			.pastdmark: pop af  
4ce1			endm  
# End of macro DMARK
4ce1						CALLMONITOR 
4ce1 cd 6a 17			call break_point_state  
4ce4				endm  
# End of macro CALLMONITOR
4ce4					endif 
4ce4			 
4ce4					; TODO handlue multiple file streams 
4ce4			 
4ce4					FORTH_DSP_POP     ; for now just get rid of stream id 
4ce4 cd a9 1f			call macro_forth_dsp_pop 
4ce7				endm 
# End of macro FORTH_DSP_POP
4ce7			 
4ce7 2e 01				ld l, 1 
4ce9 3a 4f f8				ld a, (store_openmaxext) 
4cec fe 00				cp 0 
4cee 28 09				jr  z, .eofdone   ; empty file 
4cf0 3a 50 f8				ld a, (store_openext) 
4cf3 fe 00				cp 0 
4cf5 28 02				jr  z, .eofdone 
4cf7 2e 00				ld l, 0 
4cf9 26 00		.eofdone:	ld h, 0 
4cfb cd fa 1c				call forth_push_numhl 
4cfe			 
4cfe			 
4cfe				       NEXTW 
4cfe c3 63 20			jp macro_next 
4d01				endm 
# End of macro NEXTW
4d01			 
4d01			.FORMAT: 
4d01				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4d01 6d				db WORD_SYS_CORE+89             
4d02 52 4d			dw .LABEL            
4d04 07				db 6 + 1 
4d05 .. 00			db "FORMAT",0              
4d0c				endm 
# End of macro CWHEAD
4d0c			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d0c					; TODO if current block id for stream is zero then push true else false 
4d0c				 
4d0c				if DEBUG_STORESE 
4d0c					DMARK "FOR" 
4d0c f5				push af  
4d0d 3a 21 4d			ld a, (.dmark)  
4d10 32 6e fb			ld (debug_mark),a  
4d13 3a 22 4d			ld a, (.dmark+1)  
4d16 32 6f fb			ld (debug_mark+1),a  
4d19 3a 23 4d			ld a, (.dmark+2)  
4d1c 32 70 fb			ld (debug_mark+2),a  
4d1f 18 03			jr .pastdmark  
4d21 ..			.dmark: db "FOR"  
4d24 f1			.pastdmark: pop af  
4d25			endm  
# End of macro DMARK
4d25					CALLMONITOR 
4d25 cd 6a 17			call break_point_state  
4d28				endm  
# End of macro CALLMONITOR
4d28				endif 
4d28					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d28			 
4d28 21 01 00				ld hl, 1 
4d2b 3e 00				ld a, 0 
4d2d cd e5 01				call se_writebyte 
4d30			 
4d30				if DEBUG_STORESE 
4d30					DMARK "FO0" 
4d30 f5				push af  
4d31 3a 45 4d			ld a, (.dmark)  
4d34 32 6e fb			ld (debug_mark),a  
4d37 3a 46 4d			ld a, (.dmark+1)  
4d3a 32 6f fb			ld (debug_mark+1),a  
4d3d 3a 47 4d			ld a, (.dmark+2)  
4d40 32 70 fb			ld (debug_mark+2),a  
4d43 18 03			jr .pastdmark  
4d45 ..			.dmark: db "FO0"  
4d48 f1			.pastdmark: pop af  
4d49			endm  
# End of macro DMARK
4d49					CALLMONITOR 
4d49 cd 6a 17			call break_point_state  
4d4c				endm  
# End of macro CALLMONITOR
4d4c				endif 
4d4c					; force bank init 
4d4c			 
4d4c cd b8 03				call storage_get_block_0 
4d4f					 
4d4f				       NEXTW 
4d4f c3 63 20			jp macro_next 
4d52				endm 
# End of macro NEXTW
4d52			.LABEL: 
4d52				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d52 6d				db WORD_SYS_CORE+89             
4d53 a0 4d			dw .STOREPAGE            
4d55 06				db 5 + 1 
4d56 .. 00			db "LABEL",0              
4d5c				endm 
# End of macro CWHEAD
4d5c			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d5c					; TODO test to see if bank is selected 
4d5c				 
4d5c					if DEBUG_FORTH_WORDS_KEY 
4d5c						DMARK "LBL" 
4d5c f5				push af  
4d5d 3a 71 4d			ld a, (.dmark)  
4d60 32 6e fb			ld (debug_mark),a  
4d63 3a 72 4d			ld a, (.dmark+1)  
4d66 32 6f fb			ld (debug_mark+1),a  
4d69 3a 73 4d			ld a, (.dmark+2)  
4d6c 32 70 fb			ld (debug_mark+2),a  
4d6f 18 03			jr .pastdmark  
4d71 ..			.dmark: db "LBL"  
4d74 f1			.pastdmark: pop af  
4d75			endm  
# End of macro DMARK
4d75						CALLMONITOR 
4d75 cd 6a 17			call break_point_state  
4d78				endm  
# End of macro CALLMONITOR
4d78					endif 
4d78			;	if DEBUG_STORESE 
4d78			;		DMARK "LBL" 
4d78			;		CALLMONITOR 
4d78			;	endif 
4d78					FORTH_DSP_VALUEHL 
4d78 cd f1 1e			call macro_dsp_valuehl 
4d7b				endm 
# End of macro FORTH_DSP_VALUEHL
4d7b					;v5FORTH_DSP_VALUE 
4d7b					 
4d7b			;		push hl 
4d7b					FORTH_DSP_POP 
4d7b cd a9 1f			call macro_forth_dsp_pop 
4d7e				endm 
# End of macro FORTH_DSP_POP
4d7e			;		pop hl 
4d7e			 
4d7e			;v5		inc hl   ; move past the type marker 
4d7e			 
4d7e				if DEBUG_STORESE 
4d7e					DMARK "LBl" 
4d7e f5				push af  
4d7f 3a 93 4d			ld a, (.dmark)  
4d82 32 6e fb			ld (debug_mark),a  
4d85 3a 94 4d			ld a, (.dmark+1)  
4d88 32 6f fb			ld (debug_mark+1),a  
4d8b 3a 95 4d			ld a, (.dmark+2)  
4d8e 32 70 fb			ld (debug_mark+2),a  
4d91 18 03			jr .pastdmark  
4d93 ..			.dmark: db "LBl"  
4d96 f1			.pastdmark: pop af  
4d97			endm  
# End of macro DMARK
4d97					CALLMONITOR 
4d97 cd 6a 17			call break_point_state  
4d9a				endm  
# End of macro CALLMONITOR
4d9a				endif 
4d9a cd dc 04				call storage_label 
4d9d			 
4d9d				       NEXTW 
4d9d c3 63 20			jp macro_next 
4da0				endm 
# End of macro NEXTW
4da0			.STOREPAGE: 
4da0				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4da0 6d				db WORD_SYS_CORE+89             
4da1 d3 4d			dw .LABELS            
4da3 0a				db 9 + 1 
4da4 .. 00			db "STOREPAGE",0              
4dae				endm 
# End of macro CWHEAD
4dae			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4dae					; TODO test to see if bank is selected 
4dae				 
4dae					if DEBUG_FORTH_WORDS_KEY 
4dae						DMARK "STP" 
4dae f5				push af  
4daf 3a c3 4d			ld a, (.dmark)  
4db2 32 6e fb			ld (debug_mark),a  
4db5 3a c4 4d			ld a, (.dmark+1)  
4db8 32 6f fb			ld (debug_mark+1),a  
4dbb 3a c5 4d			ld a, (.dmark+2)  
4dbe 32 70 fb			ld (debug_mark+2),a  
4dc1 18 03			jr .pastdmark  
4dc3 ..			.dmark: db "STP"  
4dc6 f1			.pastdmark: pop af  
4dc7			endm  
# End of macro DMARK
4dc7						CALLMONITOR 
4dc7 cd 6a 17			call break_point_state  
4dca				endm  
# End of macro CALLMONITOR
4dca					endif 
4dca			;	if DEBUG_STORESE 
4dca			;		DMARK "STP" 
4dca			;		CALLMONITOR 
4dca			;	endif 
4dca			 
4dca 21 59 f8			ld hl, store_page 
4dcd cd fa 1c			call forth_push_numhl 
4dd0			 
4dd0			 
4dd0				       NEXTW 
4dd0 c3 63 20			jp macro_next 
4dd3				endm 
# End of macro NEXTW
4dd3			.LABELS: 
4dd3				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4dd3 6d				db WORD_SYS_CORE+89             
4dd4 5d 4e			dw .ENDSTORAGE            
4dd6 07				db 6 + 1 
4dd7 .. 00			db "LABELS",0              
4dde				endm 
# End of macro CWHEAD
4dde			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dde					;  
4dde			 
4dde					; save the current device selected to restore afterwards 
4dde				 
4dde 3a 3f f8				ld a, (spi_device) 
4de1 f5					push af 
4de2			 
4de2			 
4de2					; run through each of the banks 
4de2			 
4de2 21 01 00				ld hl, 1 
4de5 cd fa 1c				call forth_push_numhl 
4de8 3e ff				ld a, SPI_CE_HIGH 
4dea cb 87				res SPI_CE0, a 
4dec 32 3f f8				ld (spi_device), a 
4def cd b8 03				call storage_get_block_0 
4df2 21 5c f8				ld hl, store_page+3 
4df5 cd 68 1d				call forth_push_str 
4df8			 
4df8					 
4df8 21 02 00				ld hl, 2 
4dfb cd fa 1c				call forth_push_numhl 
4dfe 3e ff				ld a, SPI_CE_HIGH 
4e00 cb 8f				res SPI_CE1, a 
4e02 32 3f f8				ld (spi_device), a 
4e05 cd b8 03				call storage_get_block_0 
4e08 21 5c f8				ld hl, store_page+3 
4e0b cd 68 1d				call forth_push_str 
4e0e			 
4e0e					 
4e0e 21 03 00				ld hl, 3 
4e11 cd fa 1c				call forth_push_numhl 
4e14 3e ff				ld a, SPI_CE_HIGH 
4e16 cb 97				res SPI_CE2, a 
4e18 32 3f f8				ld (spi_device), a 
4e1b cd b8 03				call storage_get_block_0 
4e1e 21 5c f8				ld hl, store_page+3 
4e21 cd 68 1d				call forth_push_str 
4e24			 
4e24			 
4e24 21 04 00				ld hl, 4 
4e27 cd fa 1c				call forth_push_numhl 
4e2a 3e ff				ld a, SPI_CE_HIGH 
4e2c cb 9f				res SPI_CE3, a 
4e2e 32 3f f8				ld (spi_device), a 
4e31 cd b8 03				call storage_get_block_0 
4e34 21 5c f8				ld hl, store_page+3 
4e37 cd 68 1d				call forth_push_str 
4e3a			 
4e3a					 
4e3a			 
4e3a 21 05 00				ld hl, 5 
4e3d cd fa 1c				call forth_push_numhl 
4e40 3e ff				ld a, SPI_CE_HIGH 
4e42 cb a7				res SPI_CE4, a 
4e44 32 3f f8				ld (spi_device), a 
4e47 cd b8 03				call storage_get_block_0 
4e4a 21 5c f8				ld hl, store_page+3 
4e4d cd 68 1d				call forth_push_str 
4e50			 
4e50					 
4e50					; push fixed count of storage devices (on board) for now 
4e50			 
4e50 21 05 00				ld hl, 5 
4e53 cd fa 1c				call forth_push_numhl 
4e56			 
4e56					; restore selected device  
4e56				 
4e56 f1					pop af 
4e57 32 3f f8				ld (spi_device), a 
4e5a			 
4e5a				       NEXTW 
4e5a c3 63 20			jp macro_next 
4e5d				endm 
# End of macro NEXTW
4e5d			 
4e5d			.ENDSTORAGE: 
4e5d			; eof 
# End of file forth_words_storage.asm
4e5d			endif 
4e5d				include "forth_words_device.asm" 
4e5d			; Device related words 
4e5d			 
4e5d			; | ## Device Words 
4e5d			 
4e5d			if SOUND_ENABLE 
4e5d			.NOTE: 
4e5d				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e5d 33				db WORD_SYS_CORE+31             
4e5e 85 4e			dw .AFTERSOUND            
4e60 05				db 4 + 1 
4e61 .. 00			db "NOTE",0              
4e66				endm 
# End of macro CWHEAD
4e66			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e66					if DEBUG_FORTH_WORDS_KEY 
4e66						DMARK "NTE" 
4e66 f5				push af  
4e67 3a 7b 4e			ld a, (.dmark)  
4e6a 32 6e fb			ld (debug_mark),a  
4e6d 3a 7c 4e			ld a, (.dmark+1)  
4e70 32 6f fb			ld (debug_mark+1),a  
4e73 3a 7d 4e			ld a, (.dmark+2)  
4e76 32 70 fb			ld (debug_mark+2),a  
4e79 18 03			jr .pastdmark  
4e7b ..			.dmark: db "NTE"  
4e7e f1			.pastdmark: pop af  
4e7f			endm  
# End of macro DMARK
4e7f						CALLMONITOR 
4e7f cd 6a 17			call break_point_state  
4e82				endm  
# End of macro CALLMONITOR
4e82					endif 
4e82			 
4e82				 
4e82			 
4e82					NEXTW 
4e82 c3 63 20			jp macro_next 
4e85				endm 
# End of macro NEXTW
4e85			.AFTERSOUND: 
4e85			endif 
4e85			 
4e85			 
4e85			USE_GPIO: equ 0 
4e85			 
4e85			if USE_GPIO 
4e85			.GP1: 
4e85				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e85			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e85					NEXTW 
4e85			.GP2: 
4e85				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e85			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e85			 
4e85					NEXTW 
4e85			 
4e85			.GP3: 
4e85				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e85			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e85			 
4e85					NEXTW 
4e85			 
4e85			.GP4: 
4e85				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e85			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e85			 
4e85					NEXTW 
4e85			.SIN: 
4e85			 
4e85			 
4e85			endif 
4e85			 
4e85			 
4e85				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e85 33				db WORD_SYS_CORE+31             
4e86 ba 4e			dw .SOUT            
4e88 03				db 2 + 1 
4e89 .. 00			db "IN",0              
4e8c				endm 
# End of macro CWHEAD
4e8c			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e8c					if DEBUG_FORTH_WORDS_KEY 
4e8c						DMARK "IN." 
4e8c f5				push af  
4e8d 3a a1 4e			ld a, (.dmark)  
4e90 32 6e fb			ld (debug_mark),a  
4e93 3a a2 4e			ld a, (.dmark+1)  
4e96 32 6f fb			ld (debug_mark+1),a  
4e99 3a a3 4e			ld a, (.dmark+2)  
4e9c 32 70 fb			ld (debug_mark+2),a  
4e9f 18 03			jr .pastdmark  
4ea1 ..			.dmark: db "IN."  
4ea4 f1			.pastdmark: pop af  
4ea5			endm  
# End of macro DMARK
4ea5						CALLMONITOR 
4ea5 cd 6a 17			call break_point_state  
4ea8				endm  
# End of macro CALLMONITOR
4ea8					endif 
4ea8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ea8 cd f1 1e			call macro_dsp_valuehl 
4eab				endm 
# End of macro FORTH_DSP_VALUEHL
4eab			 
4eab e5					push hl 
4eac			 
4eac					; destroy value TOS 
4eac			 
4eac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eac cd a9 1f			call macro_forth_dsp_pop 
4eaf				endm 
# End of macro FORTH_DSP_POP
4eaf			 
4eaf					; one value on hl get other one back 
4eaf			 
4eaf c1					pop bc 
4eb0			 
4eb0					; do the sub 
4eb0			;		ex de, hl 
4eb0			 
4eb0 ed 68				in l,(c) 
4eb2			 
4eb2					; save it 
4eb2			 
4eb2 26 00				ld h,0 
4eb4			 
4eb4					; TODO push value back onto stack for another op etc 
4eb4			 
4eb4 cd fa 1c				call forth_push_numhl 
4eb7					NEXTW 
4eb7 c3 63 20			jp macro_next 
4eba				endm 
# End of macro NEXTW
4eba			.SOUT: 
4eba				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4eba 34				db WORD_SYS_CORE+32             
4ebb 0d 4f			dw .SPIO            
4ebd 04				db 3 + 1 
4ebe .. 00			db "OUT",0              
4ec2				endm 
# End of macro CWHEAD
4ec2			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ec2					if DEBUG_FORTH_WORDS_KEY 
4ec2						DMARK "OUT" 
4ec2 f5				push af  
4ec3 3a d7 4e			ld a, (.dmark)  
4ec6 32 6e fb			ld (debug_mark),a  
4ec9 3a d8 4e			ld a, (.dmark+1)  
4ecc 32 6f fb			ld (debug_mark+1),a  
4ecf 3a d9 4e			ld a, (.dmark+2)  
4ed2 32 70 fb			ld (debug_mark+2),a  
4ed5 18 03			jr .pastdmark  
4ed7 ..			.dmark: db "OUT"  
4eda f1			.pastdmark: pop af  
4edb			endm  
# End of macro DMARK
4edb						CALLMONITOR 
4edb cd 6a 17			call break_point_state  
4ede				endm  
# End of macro CALLMONITOR
4ede					endif 
4ede			 
4ede					; get port 
4ede			 
4ede					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ede cd f1 1e			call macro_dsp_valuehl 
4ee1				endm 
# End of macro FORTH_DSP_VALUEHL
4ee1			 
4ee1 e5					push hl 
4ee2			 
4ee2					; destroy value TOS 
4ee2			 
4ee2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ee2 cd a9 1f			call macro_forth_dsp_pop 
4ee5				endm 
# End of macro FORTH_DSP_POP
4ee5			 
4ee5					; get byte to send 
4ee5			 
4ee5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ee5 cd f1 1e			call macro_dsp_valuehl 
4ee8				endm 
# End of macro FORTH_DSP_VALUEHL
4ee8			 
4ee8			;		push hl 
4ee8			 
4ee8					; destroy value TOS 
4ee8			 
4ee8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ee8 cd a9 1f			call macro_forth_dsp_pop 
4eeb				endm 
# End of macro FORTH_DSP_POP
4eeb			 
4eeb					; one value on hl get other one back 
4eeb			 
4eeb			;		pop hl 
4eeb			 
4eeb c1					pop bc 
4eec			 
4eec					if DEBUG_FORTH_WORDS 
4eec						DMARK "OUT" 
4eec f5				push af  
4eed 3a 01 4f			ld a, (.dmark)  
4ef0 32 6e fb			ld (debug_mark),a  
4ef3 3a 02 4f			ld a, (.dmark+1)  
4ef6 32 6f fb			ld (debug_mark+1),a  
4ef9 3a 03 4f			ld a, (.dmark+2)  
4efc 32 70 fb			ld (debug_mark+2),a  
4eff 18 03			jr .pastdmark  
4f01 ..			.dmark: db "OUT"  
4f04 f1			.pastdmark: pop af  
4f05			endm  
# End of macro DMARK
4f05						CALLMONITOR 
4f05 cd 6a 17			call break_point_state  
4f08				endm  
# End of macro CALLMONITOR
4f08					endif 
4f08			 
4f08 ed 69				out (c), l 
4f0a			 
4f0a					NEXTW 
4f0a c3 63 20			jp macro_next 
4f0d				endm 
# End of macro NEXTW
4f0d			 
4f0d			 
4f0d			.SPIO: 
4f0d			 
4f0d			if STORAGE_SE 
4f0d				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4f0d 51				db WORD_SYS_CORE+61             
4f0e 1e 4f			dw .SPICEH            
4f10 07				db 6 + 1 
4f11 .. 00			db "SPICEL",0              
4f18				endm 
# End of macro CWHEAD
4f18			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4f18			 
4f18 cd 93 01				call spi_ce_low 
4f1b			    NEXTW 
4f1b c3 63 20			jp macro_next 
4f1e				endm 
# End of macro NEXTW
4f1e			 
4f1e			.SPICEH: 
4f1e				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4f1e 51				db WORD_SYS_CORE+61             
4f1f 2f 4f			dw .SPIOb            
4f21 07				db 6 + 1 
4f22 .. 00			db "SPICEH",0              
4f29				endm 
# End of macro CWHEAD
4f29			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4f29			 
4f29 cd 82 01				call spi_ce_high 
4f2c			    NEXTW 
4f2c c3 63 20			jp macro_next 
4f2f				endm 
# End of macro NEXTW
4f2f			 
4f2f			 
4f2f			.SPIOb: 
4f2f			 
4f2f				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f2f 51				db WORD_SYS_CORE+61             
4f30 45 4f			dw .SPII            
4f32 05				db 4 + 1 
4f33 .. 00			db "SPIO",0              
4f38				endm 
# End of macro CWHEAD
4f38			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f38			 
4f38					; get port 
4f38			 
4f38			 
4f38					; get byte to send 
4f38			 
4f38					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f38 cd f1 1e			call macro_dsp_valuehl 
4f3b				endm 
# End of macro FORTH_DSP_VALUEHL
4f3b			 
4f3b			;		push hl    ; u1  
4f3b			 
4f3b					; destroy value TOS 
4f3b			 
4f3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f3b cd a9 1f			call macro_forth_dsp_pop 
4f3e				endm 
# End of macro FORTH_DSP_POP
4f3e			 
4f3e					; one value on hl get other one back 
4f3e			 
4f3e			;		pop hl   ; u2 - addr 
4f3e			 
4f3e					; TODO Send SPI byte 
4f3e			 
4f3e 7d					ld a, l 
4f3f cd b7 00				call spi_send_byte 
4f42			 
4f42					NEXTW 
4f42 c3 63 20			jp macro_next 
4f45				endm 
# End of macro NEXTW
4f45			 
4f45			.SPII: 
4f45				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f45 52				db WORD_SYS_CORE+62             
4f46 5a 4f			dw .SESEL            
4f48 06				db 5 + 1 
4f49 .. 00			db "SPII",0              
4f4e				endm 
# End of macro CWHEAD
4f4e			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f4e			 
4f4e					; TODO Get SPI byte 
4f4e			 
4f4e cd d8 00				call spi_read_byte 
4f51			 
4f51 26 00				ld h, 0 
4f53 6f					ld l, a 
4f54 cd fa 1c				call forth_push_numhl 
4f57			 
4f57					NEXTW 
4f57 c3 63 20			jp macro_next 
4f5a				endm 
# End of macro NEXTW
4f5a			 
4f5a			 
4f5a			 
4f5a			.SESEL: 
4f5a				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f5a 66				db WORD_SYS_CORE+82             
4f5b fe 4f			dw .CARTDEV            
4f5d 05				db 4 + 1 
4f5e .. 00			db "BANK",0              
4f63				endm 
# End of macro CWHEAD
4f63			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f63					if DEBUG_FORTH_WORDS_KEY 
4f63						DMARK "BNK" 
4f63 f5				push af  
4f64 3a 78 4f			ld a, (.dmark)  
4f67 32 6e fb			ld (debug_mark),a  
4f6a 3a 79 4f			ld a, (.dmark+1)  
4f6d 32 6f fb			ld (debug_mark+1),a  
4f70 3a 7a 4f			ld a, (.dmark+2)  
4f73 32 70 fb			ld (debug_mark+2),a  
4f76 18 03			jr .pastdmark  
4f78 ..			.dmark: db "BNK"  
4f7b f1			.pastdmark: pop af  
4f7c			endm  
# End of macro DMARK
4f7c						CALLMONITOR 
4f7c cd 6a 17			call break_point_state  
4f7f				endm  
# End of macro CALLMONITOR
4f7f					endif 
4f7f			 
4f7f 3e ff				ld a, 255 
4f81 32 42 f8				ld (spi_cartdev), a 
4f84			 
4f84					; get bank 
4f84			 
4f84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f84 cd f1 1e			call macro_dsp_valuehl 
4f87				endm 
# End of macro FORTH_DSP_VALUEHL
4f87			 
4f87			;		push hl 
4f87			 
4f87					; destroy value TOS 
4f87			 
4f87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f87 cd a9 1f			call macro_forth_dsp_pop 
4f8a				endm 
# End of macro FORTH_DSP_POP
4f8a			 
4f8a					; one value on hl get other one back 
4f8a			 
4f8a			;		pop hl 
4f8a			 
4f8a			 
4f8a 0e ff				ld c, SPI_CE_HIGH 
4f8c 06 30				ld b, '0'    ; human readable bank number 
4f8e			 
4f8e 7d					ld a, l 
4f8f			 
4f8f					if DEBUG_FORTH_WORDS 
4f8f						DMARK "BNK" 
4f8f f5				push af  
4f90 3a a4 4f			ld a, (.dmark)  
4f93 32 6e fb			ld (debug_mark),a  
4f96 3a a5 4f			ld a, (.dmark+1)  
4f99 32 6f fb			ld (debug_mark+1),a  
4f9c 3a a6 4f			ld a, (.dmark+2)  
4f9f 32 70 fb			ld (debug_mark+2),a  
4fa2 18 03			jr .pastdmark  
4fa4 ..			.dmark: db "BNK"  
4fa7 f1			.pastdmark: pop af  
4fa8			endm  
# End of macro DMARK
4fa8						CALLMONITOR 
4fa8 cd 6a 17			call break_point_state  
4fab				endm  
# End of macro CALLMONITOR
4fab					endif 
4fab			 
4fab					; active low 
4fab			 
4fab fe 00				cp 0 
4fad 28 28				jr z, .bset 
4faf fe 01				cp 1 
4fb1 20 04				jr nz, .b2 
4fb3 cb 81				res 0, c 
4fb5 06 31				ld b, '1'    ; human readable bank number 
4fb7 fe 02		.b2:		cp 2 
4fb9 20 04				jr nz, .b3 
4fbb cb 89				res 1, c 
4fbd 06 32				ld b, '2'    ; human readable bank number 
4fbf fe 03		.b3:		cp 3 
4fc1 20 04				jr nz, .b4 
4fc3 cb 91				res 2, c 
4fc5 06 33				ld b, '3'    ; human readable bank number 
4fc7 fe 04		.b4:		cp 4 
4fc9 20 04				jr nz, .b5 
4fcb cb 99				res 3, c 
4fcd 06 34				ld b, '4'    ; human readable bank number 
4fcf fe 05		.b5:		cp 5 
4fd1 20 04				jr nz, .bset 
4fd3 cb a1				res 4, c 
4fd5 06 35				ld b, '5'    ; human readable bank number 
4fd7			 
4fd7			.bset: 
4fd7 79					ld a, c 
4fd8 32 3f f8				ld (spi_device),a 
4fdb 78					ld a, b 
4fdc 32 3e f8				ld (spi_device_id),a 
4fdf					if DEBUG_FORTH_WORDS 
4fdf						DMARK "BN2" 
4fdf f5				push af  
4fe0 3a f4 4f			ld a, (.dmark)  
4fe3 32 6e fb			ld (debug_mark),a  
4fe6 3a f5 4f			ld a, (.dmark+1)  
4fe9 32 6f fb			ld (debug_mark+1),a  
4fec 3a f6 4f			ld a, (.dmark+2)  
4fef 32 70 fb			ld (debug_mark+2),a  
4ff2 18 03			jr .pastdmark  
4ff4 ..			.dmark: db "BN2"  
4ff7 f1			.pastdmark: pop af  
4ff8			endm  
# End of macro DMARK
4ff8						CALLMONITOR 
4ff8 cd 6a 17			call break_point_state  
4ffb				endm  
# End of macro CALLMONITOR
4ffb					endif 
4ffb			 
4ffb					NEXTW 
4ffb c3 63 20			jp macro_next 
4ffe				endm 
# End of macro NEXTW
4ffe			 
4ffe			.CARTDEV: 
4ffe				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4ffe 66				db WORD_SYS_CORE+82             
4fff a7 50			dw .ENDDEVICE            
5001 08				db 7 + 1 
5002 .. 00			db "CARTDEV",0              
500a				endm 
# End of macro CWHEAD
500a			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
500a					if DEBUG_FORTH_WORDS_KEY 
500a						DMARK "CDV" 
500a f5				push af  
500b 3a 1f 50			ld a, (.dmark)  
500e 32 6e fb			ld (debug_mark),a  
5011 3a 20 50			ld a, (.dmark+1)  
5014 32 6f fb			ld (debug_mark+1),a  
5017 3a 21 50			ld a, (.dmark+2)  
501a 32 70 fb			ld (debug_mark+2),a  
501d 18 03			jr .pastdmark  
501f ..			.dmark: db "CDV"  
5022 f1			.pastdmark: pop af  
5023			endm  
# End of macro DMARK
5023						CALLMONITOR 
5023 cd 6a 17			call break_point_state  
5026				endm  
# End of macro CALLMONITOR
5026					endif 
5026			 
5026					; disable se storage bank selection 
5026			 
5026 3e ff				ld a, SPI_CE_HIGH		; ce high 
5028 32 3f f8				ld (spi_device), a 
502b			 
502b					; get bank 
502b			 
502b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
502b cd f1 1e			call macro_dsp_valuehl 
502e				endm 
# End of macro FORTH_DSP_VALUEHL
502e			 
502e			;		push hl 
502e			 
502e					; destroy value TOS 
502e			 
502e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
502e cd a9 1f			call macro_forth_dsp_pop 
5031				endm 
# End of macro FORTH_DSP_POP
5031			 
5031					; one value on hl get other one back 
5031			 
5031			;		pop hl 
5031			 
5031					; active low 
5031			 
5031 0e ff				ld c, 255 
5033			 
5033 7d					ld a, l 
5034					if DEBUG_FORTH_WORDS 
5034						DMARK "CDV" 
5034 f5				push af  
5035 3a 49 50			ld a, (.dmark)  
5038 32 6e fb			ld (debug_mark),a  
503b 3a 4a 50			ld a, (.dmark+1)  
503e 32 6f fb			ld (debug_mark+1),a  
5041 3a 4b 50			ld a, (.dmark+2)  
5044 32 70 fb			ld (debug_mark+2),a  
5047 18 03			jr .pastdmark  
5049 ..			.dmark: db "CDV"  
504c f1			.pastdmark: pop af  
504d			endm  
# End of macro DMARK
504d						CALLMONITOR 
504d cd 6a 17			call break_point_state  
5050				endm  
# End of macro CALLMONITOR
5050					endif 
5050 fe 00				cp 0 
5052 28 30				jr z, .cset 
5054 fe 01				cp 1 
5056 20 02				jr nz, .c2 
5058 cb 81				res 0, c 
505a fe 02		.c2:		cp 2 
505c 20 02				jr nz, .c3 
505e cb 89				res 1, c 
5060 fe 03		.c3:		cp 3 
5062 20 02				jr nz, .c4 
5064 cb 91				res 2, c 
5066 fe 04		.c4:		cp 4 
5068 20 02				jr nz, .c5 
506a cb 99				res 3, c 
506c fe 05		.c5:		cp 5 
506e 20 02				jr nz, .c6 
5070 cb a1				res 4, c 
5072 fe 06		.c6:		cp 6 
5074 20 02				jr nz, .c7 
5076 cb a9				res 5, c 
5078 fe 07		.c7:		cp 7 
507a 20 02				jr nz, .c8 
507c cb b1				res 6, c 
507e fe 08		.c8:		cp 8 
5080 20 02				jr nz, .cset 
5082 cb b9				res 7, c 
5084 79			.cset:		ld a, c 
5085 32 42 f8				ld (spi_cartdev),a 
5088			 
5088					if DEBUG_FORTH_WORDS 
5088						DMARK "CD2" 
5088 f5				push af  
5089 3a 9d 50			ld a, (.dmark)  
508c 32 6e fb			ld (debug_mark),a  
508f 3a 9e 50			ld a, (.dmark+1)  
5092 32 6f fb			ld (debug_mark+1),a  
5095 3a 9f 50			ld a, (.dmark+2)  
5098 32 70 fb			ld (debug_mark+2),a  
509b 18 03			jr .pastdmark  
509d ..			.dmark: db "CD2"  
50a0 f1			.pastdmark: pop af  
50a1			endm  
# End of macro DMARK
50a1						CALLMONITOR 
50a1 cd 6a 17			call break_point_state  
50a4				endm  
# End of macro CALLMONITOR
50a4					endif 
50a4					NEXTW 
50a4 c3 63 20			jp macro_next 
50a7				endm 
# End of macro NEXTW
50a7			endif 
50a7			 
50a7			.ENDDEVICE: 
50a7			; eof 
50a7			 
# End of file forth_words_device.asm
50a7			 
50a7			; var handler 
50a7			 
50a7			 
50a7			.VARS: 
50a7				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
50a7 78				db WORD_SYS_CORE+100             
50a8 bf 50			dw .V0Q            
50aa 04				db 3 + 1 
50ab .. 00			db "V0!",0              
50af				endm 
# End of macro CWHEAD
50af			;| V0! ( u1 -- )  Store value to v0  | DONE 
50af			 
50af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50af cd f1 1e			call macro_dsp_valuehl 
50b2				endm 
# End of macro FORTH_DSP_VALUEHL
50b2			 
50b2 11 07 f8				ld de, cli_var_array 
50b5			 
50b5 eb					ex de, hl 
50b6 73					ld (hl), e 
50b7 23					inc hl 
50b8 72					ld (hl), d 
50b9			 
50b9					; destroy value TOS 
50b9			 
50b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b9 cd a9 1f			call macro_forth_dsp_pop 
50bc				endm 
# End of macro FORTH_DSP_POP
50bc			 
50bc				       NEXTW 
50bc c3 63 20			jp macro_next 
50bf				endm 
# End of macro NEXTW
50bf			.V0Q: 
50bf				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
50bf 79				db WORD_SYS_CORE+101             
50c0 d0 50			dw .V1S            
50c2 04				db 3 + 1 
50c3 .. 00			db "V0@",0              
50c7				endm 
# End of macro CWHEAD
50c7			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
50c7 2a 07 f8				ld hl, (cli_var_array) 
50ca cd fa 1c				call forth_push_numhl 
50cd			 
50cd				       NEXTW 
50cd c3 63 20			jp macro_next 
50d0				endm 
# End of macro NEXTW
50d0			.V1S: 
50d0				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
50d0 7a				db WORD_SYS_CORE+102             
50d1 e8 50			dw .V1Q            
50d3 04				db 3 + 1 
50d4 .. 00			db "V1!",0              
50d8				endm 
# End of macro CWHEAD
50d8			;| V1! ( u1 -- )  Store value to v1 | DONE 
50d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d8 cd f1 1e			call macro_dsp_valuehl 
50db				endm 
# End of macro FORTH_DSP_VALUEHL
50db			 
50db 11 09 f8				ld de, cli_var_array+2 
50de				 
50de eb					ex de, hl 
50df 73					ld (hl), e 
50e0 23					inc hl 
50e1 72					ld (hl), d 
50e2			 
50e2					; destroy value TOS 
50e2			 
50e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50e2 cd a9 1f			call macro_forth_dsp_pop 
50e5				endm 
# End of macro FORTH_DSP_POP
50e5				       NEXTW 
50e5 c3 63 20			jp macro_next 
50e8				endm 
# End of macro NEXTW
50e8			.V1Q: 
50e8				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50e8 7b				db WORD_SYS_CORE+103             
50e9 f9 50			dw .V2S            
50eb 04				db 3 + 1 
50ec .. 00			db "V1@",0              
50f0				endm 
# End of macro CWHEAD
50f0			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50f0 2a 09 f8				ld hl, (cli_var_array+2) 
50f3 cd fa 1c				call forth_push_numhl 
50f6				       NEXTW 
50f6 c3 63 20			jp macro_next 
50f9				endm 
# End of macro NEXTW
50f9			.V2S: 
50f9				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50f9 7c				db WORD_SYS_CORE+104             
50fa 11 51			dw .V2Q            
50fc 04				db 3 + 1 
50fd .. 00			db "V2!",0              
5101				endm 
# End of macro CWHEAD
5101			;| V2! ( u1 -- )  Store value to v2 | DONE 
5101					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5101 cd f1 1e			call macro_dsp_valuehl 
5104				endm 
# End of macro FORTH_DSP_VALUEHL
5104			 
5104 11 0b f8				ld de, cli_var_array+4 
5107				 
5107 eb					ex de, hl 
5108 73					ld (hl), e 
5109 23					inc hl 
510a 72					ld (hl), d 
510b			 
510b					; destroy value TOS 
510b			 
510b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
510b cd a9 1f			call macro_forth_dsp_pop 
510e				endm 
# End of macro FORTH_DSP_POP
510e				       NEXTW 
510e c3 63 20			jp macro_next 
5111				endm 
# End of macro NEXTW
5111			.V2Q: 
5111				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5111 7d				db WORD_SYS_CORE+105             
5112 22 51			dw .V3S            
5114 04				db 3 + 1 
5115 .. 00			db "V2@",0              
5119				endm 
# End of macro CWHEAD
5119			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5119 2a 0b f8				ld hl, (cli_var_array+4) 
511c cd fa 1c				call forth_push_numhl 
511f				       NEXTW 
511f c3 63 20			jp macro_next 
5122				endm 
# End of macro NEXTW
5122			.V3S: 
5122				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5122 7c				db WORD_SYS_CORE+104             
5123 3a 51			dw .V3Q            
5125 04				db 3 + 1 
5126 .. 00			db "V3!",0              
512a				endm 
# End of macro CWHEAD
512a			;| V3! ( u1 -- )  Store value to v3 | DONE 
512a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
512a cd f1 1e			call macro_dsp_valuehl 
512d				endm 
# End of macro FORTH_DSP_VALUEHL
512d			 
512d 11 0d f8				ld de, cli_var_array+6 
5130				 
5130 eb					ex de, hl 
5131 73					ld (hl), e 
5132 23					inc hl 
5133 72					ld (hl), d 
5134			 
5134					; destroy value TOS 
5134			 
5134					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5134 cd a9 1f			call macro_forth_dsp_pop 
5137				endm 
# End of macro FORTH_DSP_POP
5137				       NEXTW 
5137 c3 63 20			jp macro_next 
513a				endm 
# End of macro NEXTW
513a			.V3Q: 
513a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
513a 7d				db WORD_SYS_CORE+105             
513b 4b 51			dw .END            
513d 04				db 3 + 1 
513e .. 00			db "V3@",0              
5142				endm 
# End of macro CWHEAD
5142			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5142 2a 0d f8				ld hl, (cli_var_array+6) 
5145 cd fa 1c				call forth_push_numhl 
5148				       NEXTW 
5148 c3 63 20			jp macro_next 
514b				endm 
# End of macro NEXTW
514b			 
514b			 
514b			 
514b			 
514b			 
514b			; end of dict marker 
514b			 
514b 00			.END:    db WORD_SYS_END 
514c 00 00			dw 0 
514e 00				db 0 
514f			 
514f			; use to jp here for user dict words to save on macro expansion  
514f			 
514f			user_dict_next: 
514f				NEXTW 
514f c3 63 20			jp macro_next 
5152				endm 
# End of macro NEXTW
5152			 
5152			 
5152			user_exec: 
5152				;    ld hl, <word code> 
5152				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5152				;    call forthexec 
5152				;    jp user_dict_next   (NEXT) 
5152			        ;    <word code bytes> 
5152 eb				ex de, hl 
5153 2a 15 f1			ld hl,(os_tok_ptr) 
5156				 
5156				FORTH_RSP_NEXT 
5156 cd a1 1c			call macro_forth_rsp_next 
5159				endm 
# End of macro FORTH_RSP_NEXT
5159			 
5159			if DEBUG_FORTH_UWORD 
5159						DMARK "UEX" 
5159 f5				push af  
515a 3a 6e 51			ld a, (.dmark)  
515d 32 6e fb			ld (debug_mark),a  
5160 3a 6f 51			ld a, (.dmark+1)  
5163 32 6f fb			ld (debug_mark+1),a  
5166 3a 70 51			ld a, (.dmark+2)  
5169 32 70 fb			ld (debug_mark+2),a  
516c 18 03			jr .pastdmark  
516e ..			.dmark: db "UEX"  
5171 f1			.pastdmark: pop af  
5172			endm  
# End of macro DMARK
5172				CALLMONITOR 
5172 cd 6a 17			call break_point_state  
5175				endm  
# End of macro CALLMONITOR
5175			endif 
5175			 
5175			 
5175			 
5175 eb				ex de, hl 
5176 22 15 f1			ld (os_tok_ptr), hl 
5179				 
5179				; Don't use next - Skips the first word in uword. 
5179			 
5179 c3 f4 20			jp exec1 
517c			;	NEXT 
517c			 
517c			 
517c			; eof 
# End of file forth_wordsv4.asm
517c			endif 
517c			;;;;;;;;;;;;;; Debug code 
517c			 
517c			 
517c			;if DEBUG_FORTH_PARSE 
517c .. 00		.nowordfound: db "No match",0 
5185 .. 00		.compword:	db "Comparing word ",0 
5195 .. 00		.nextwordat:	db "Next word at",0 
51a2 .. 00		.charmatch:	db "Char match",0 
51ad			;endif 
51ad			if DEBUG_FORTH_JP 
51ad			.foundword:	db "Word match. Exec..",0 
51ad			endif 
51ad			;if DEBUG_FORTH_PUSH 
51ad .. 00		.enddict:	db "Dict end. Push.",0 
51bd .. 00		.push_str:	db "Pushing string",0 
51cc .. 00		.push_num:	db "Pushing number",0 
51db .. 00		.data_sp:	db "SP:",0 
51df .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51f1 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5203 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5215			;endif 
5215			;if DEBUG_FORTH_MALLOC 
5215 .. 00		.push_malloc:	db "Malloc address",0 
5224			;endif 
5224			 
5224			 
5224			 
5224			; display malloc address and current data stack pointer  
5224			 
5224			malloc_error: 
5224 d5				push de 
5225 f5				push af 
5226 e5				push hl 
5227 cd e7 0a			call clear_display 
522a 11 4c 52			ld de, .mallocerr 
522d 3e 00			ld a,0 
522f			;	ld de,os_word_scratch 
522f cd fa 0a			call str_at_display 
5232 3e 11			ld a, display_row_1+17 
5234 11 6e fb			ld de, debug_mark 
5237 cd fa 0a			call str_at_display 
523a cd 0a 0b			call update_display 
523d				;call break_point_state 
523d cd 46 69			call cin_wait 
5240			 
5240 3e 20			ld a, ' ' 
5242 32 05 ee			ld (os_view_disable), a 
5245 e1				pop hl 
5246 f1				pop af 
5247 d1				pop de	 
5248				CALLMONITOR 
5248 cd 6a 17			call break_point_state  
524b				endm  
# End of macro CALLMONITOR
524b c9				ret 
524c			 
524c .. 00		.mallocerr: 	db "Malloc Error",0 
5259			;if DEBUG_FORTH_PUSH 
5259			display_data_sp: 
5259 f5				push af 
525a			 
525a				; see if disabled 
525a			 
525a 3a 05 ee			ld a, (os_view_disable) 
525d fe 2a			cp '*' 
525f 28 67			jr z, .skipdsp 
5261			 
5261 e5				push hl 
5262 e5				push hl 
5263 e5			push hl 
5264 cd e7 0a			call clear_display 
5267 e1			pop hl 
5268 7c				ld a,h 
5269 21 19 f1			ld hl, os_word_scratch 
526c cd 1c 10			call hexout 
526f e1				pop hl 
5270 7d				ld a,l 
5271 21 1b f1			ld hl, os_word_scratch+2 
5274 cd 1c 10			call hexout 
5277 21 1d f1			ld hl, os_word_scratch+4 
527a 3e 00			ld a,0 
527c 77				ld (hl),a 
527d 11 19 f1			ld de,os_word_scratch 
5280 3e 28				ld a, display_row_2 
5282 cd fa 0a				call str_at_display 
5285 11 df 51			ld de, .wordinhl 
5288 3e 00			ld a, display_row_1 
528a			 
528a cd fa 0a				call str_at_display 
528d 11 6e fb			ld de, debug_mark 
5290 3e 11			ld a, display_row_1+17 
5292			 
5292 cd fa 0a				call str_at_display 
5295			 
5295				; display current data stack pointer 
5295 11 db 51			ld de,.data_sp 
5298 3e 30				ld a, display_row_2 + 8 
529a cd fa 0a				call str_at_display 
529d			 
529d 2a 01 f8			ld hl,(cli_data_sp) 
52a0 e5				push hl 
52a1 7c				ld a,h 
52a2 21 19 f1			ld hl, os_word_scratch 
52a5 cd 1c 10			call hexout 
52a8 e1				pop hl 
52a9 7d				ld a,l 
52aa 21 1b f1			ld hl, os_word_scratch+2 
52ad cd 1c 10			call hexout 
52b0 21 1d f1			ld hl, os_word_scratch+4 
52b3 3e 00			ld a,0 
52b5 77				ld (hl),a 
52b6 11 19 f1			ld de,os_word_scratch 
52b9 3e 33				ld a, display_row_2 + 11 
52bb cd fa 0a				call str_at_display 
52be			 
52be			 
52be cd 0a 0b			call update_display 
52c1 cd 64 0a			call delay1s 
52c4 cd 64 0a			call delay1s 
52c7 e1				pop hl 
52c8			.skipdsp: 
52c8 f1				pop af 
52c9 c9				ret 
52ca			 
52ca			display_data_malloc: 
52ca			 
52ca f5				push af 
52cb e5				push hl 
52cc e5				push hl 
52cd e5			push hl 
52ce cd e7 0a			call clear_display 
52d1 e1			pop hl 
52d2 7c				ld a,h 
52d3 21 19 f1			ld hl, os_word_scratch 
52d6 cd 1c 10			call hexout 
52d9 e1				pop hl 
52da 7d				ld a,l 
52db 21 1b f1			ld hl, os_word_scratch+2 
52de cd 1c 10			call hexout 
52e1 21 1d f1			ld hl, os_word_scratch+4 
52e4 3e 00			ld a,0 
52e6 77				ld (hl),a 
52e7 11 19 f1			ld de,os_word_scratch 
52ea 3e 28				ld a, display_row_2 
52ec cd fa 0a				call str_at_display 
52ef 11 15 52			ld de, .push_malloc 
52f2 3e 00			ld a, display_row_1 
52f4			 
52f4 cd fa 0a				call str_at_display 
52f7			 
52f7				; display current data stack pointer 
52f7 11 db 51			ld de,.data_sp 
52fa 3e 30				ld a, display_row_2 + 8 
52fc cd fa 0a				call str_at_display 
52ff			 
52ff 2a 01 f8			ld hl,(cli_data_sp) 
5302 e5				push hl 
5303 7c				ld a,h 
5304 21 19 f1			ld hl, os_word_scratch 
5307 cd 1c 10			call hexout 
530a e1				pop hl 
530b 7d				ld a,l 
530c 21 1b f1			ld hl, os_word_scratch+2 
530f cd 1c 10			call hexout 
5312 21 1d f1			ld hl, os_word_scratch+4 
5315 3e 00			ld a,0 
5317 77				ld (hl),a 
5318 11 19 f1			ld de,os_word_scratch 
531b 3e 33				ld a, display_row_2 + 11 
531d cd fa 0a				call str_at_display 
5320			 
5320 cd 0a 0b			call update_display 
5323 cd 64 0a			call delay1s 
5326 cd 64 0a			call delay1s 
5329 e1				pop hl 
532a f1				pop af 
532b c9				ret 
532c			;endif 
532c			 
532c			include "forth_autostart.asm" 
532c			; list of commands to perform at system start up 
532c			 
532c			startcmds: 
532c			;	dw test11 
532c			;	dw test12 
532c			;	dw test13 
532c			;	dw test14 
532c			;	dw test15 
532c			;	dw test16 
532c			;	dw test17 
532c			;	dw ifthtest1 
532c			;	dw ifthtest2 
532c			;	dw ifthtest3 
532c			;	dw mmtest1 
532c			;	dw mmtest2 
532c			;	dw mmtest3 
532c			;	dw mmtest4 
532c			;	dw mmtest5 
532c			;	dw mmtest6 
532c			;	dw iftest1 
532c			;	dw iftest2 
532c			;	dw iftest3 
532c			;	dw looptest1 
532c			;	dw looptest2 
532c			;	dw test1 
532c			;	dw test2 
532c			;	dw test3 
532c			;	dw test4 
532c			;	dw game2r 
532c			;	dw game2b1 
532c			;	dw game2b2 
532c			 
532c				; start up words that are actually useful 
532c			 
532c 8a 53			dw clrstack 
532e bd 53			dw type 
5330 7e 55			dw stest 
5332 e1 53			dw strncpy 
5334 1f 55			dw list 
5336 42 54			dw start1 
5338 54 54			dw start2 
533a			;	dw start3 
533a 67 54			dw start3b 
533c bf 54			dw start3c 
533e			 
533e				; (unit) testing words 
533e			 
533e f5 55			dw mtesta 
5340 aa 56			dw mtestb 
5342 4d 57			dw mtestc 
5344 02 58			dw mtestd 
5346 a6 58			dw mteste 
5348			 
5348				; demo/game words 
5348			 
5348 b2 5f		        dw game3w 
534a e0 5f		        dw game3p 
534c fe 5f		        dw game3sc 
534e 2f 60		        dw game3vsi 
5350 5b 60		        dw game3vs 
5352				 
5352 a5 5d			dw game2b 
5354 13 5e			dw game2bf 
5356 5d 5e			dw game2mba 
5358 f3 5e			dw game2mbas 
535a 35 5f			dw game2mb 
535c			 
535c 66 5a			dw game1 
535e 77 5a			dw game1a 
5360 d9 5a			dw game1b 
5362 0e 5b			dw game1c 
5364 44 5b			dw game1d 
5366 75 5b			dw game1s 
5368 89 5b			dw game1t 
536a 9e 5b			dw game1f 
536c d2 5b			dw game1z 
536e 16 5c			dw game1zz 
5370			 
5370 5c 59			dw test5 
5372 94 59			dw test6 
5374 cc 59			dw test7 
5376 e0 59			dw test8 
5378 0c 5a			dw test9 
537a 22 5a			dw test10 
537c				 
537c ed 5c		        dw ssv5 
537e d1 5c		        dw ssv4 
5380 b5 5c		        dw ssv3 
5382 7f 5c		        dw ssv2 
5384 06 5d		        dw ssv1 
5386 4e 5d		        dw ssv1cpm 
5388			;	dw keyup 
5388			;	dw keydown 
5388			;	dw keyleft 
5388			;	dw keyright 
5388			;	dw 	keyf1 
5388			;	dw keyf2 
5388			;	dw keyf3 
5388			;	dw keyf4 
5388			;	dw keyf5 
5388			;	dw keyf6 
5388			;	dw keyf7 
5388			;	dw keyf8 
5388			;	dw keyf9 
5388			;	dw keyf10 
5388			;	dw keyf11 
5388			;	dw keyf12 
5388			;	dw keytab 
5388			;	dw keycr 
5388			;	dw keyhome 
5388			;	dw keyend 
5388			;	dw keybs 
5388 00 00			db 0, 0	 
538a			 
538a			 
538a			; clear stack  
538a			 
538a .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
53bd			 
53bd			; type ( addr count - ) 
53bd .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
53e1			 
53e1			; some direct memory words 
53e1			; strncpy ( len t f -- t ) 
53e1			 
53e1 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5442			 
5442 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5454 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5467			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5467 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
54bf .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
551f			 
551f			 
551f			; a handy word to list items on the stack 
551f			 
551f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
557e			 
557e			 
557e			; test stack  
557e			; rnd8 stest 
557e			 
557e .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55f5			 
55f5			; random malloc and free cycles 
55f5			 
55f5 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56aa			 
56aa			; fixed malloc and free cycles 
56aa			 
56aa .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
574d			 
574d			; fixed double string push and drop cycle  
574d			 
574d .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5802			 
5802			; consistent fixed string push and drop cycle  
5802			 
5802 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58a6			 
58a6 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
595c			 
595c			;test1:		db ": aa 1 2 3 ;", 0 
595c			;test2:     	db "111 aa 888 999",0 
595c			;test3:     	db ": bb 77 ;",0 
595c			;test4:     	db "$02 $01 do i . loop bb",0 
595c			 
595c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5994 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
59cc .. 00		test7:     	db ": box hline vline ;",0 
59e0 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5a0c .. 00		test9:     	db ": sw $01 adsp world ;",0 
5a22 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a47 .. 00		test11:     	db "hello create .",0 
5a56 .. 00		test12:     	db "hello2 create .",0 
5a66			 
5a66			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a66			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a66			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a66			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a66			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a66			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a66			 
5a66			;iftest1:     	db "$0001 IF cls .",0 
5a66			;iftest2:     	db "$0000 IF cls .",0 
5a66			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a66			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a66			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a66			 
5a66			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a66			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a66			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a66			 
5a66			 
5a66			 
5a66			; a small guess the number game 
5a66			 
5a66 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a77 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5ad9			 
5ad9 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b0e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b44 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b75 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b89 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b9e .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5bd2 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c16			 
5c16			; Using 'ga' save a high score across multiple runs using external storage 
5c16			 
5c16 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c7f			 
5c7f			 
5c7f			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c7f			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c7f			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c7f			 
5c7f			; simple screen saver to test code memory reuse to destruction 
5c7f			 
5c7f .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5cb5 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5cd1 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ced .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d06 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d4e .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5da5			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5da5			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5da5			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5da5			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5da5			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5da5			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5da5			 
5da5			 
5da5			 
5da5			; minesweeper/battleship finding game 
5da5			; draws a game board of random ship/mine positions 
5da5			; user enters coords to see if it hits on 
5da5			; game ends when all are hit 
5da5			; when hit or miss says how many may be in the area 
5da5			 
5da5			; setup the game board and then hide it 
5da5 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e13 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e5d			; prompt for where to target 
5e5d .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ef3 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f18			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f18 .. 00		game2mbht:      db ": mbckht nop ;",0 
5f27 .. 00		game2mbms:      db ": mbcms nop ;",0 
5f35			; TODO how many might be near by 
5f35 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5fb2			 
5fb2			; Game 3 
5fb2			 
5fb2			; Vert scroller ski game - avoid the trees! 
5fb2			 
5fb2			; v0 score (ie turns) 
5fb2			; v1 player pos 
5fb2			; v2 left wall 
5fb2			; v3 right wall 
5fb2			 
5fb2			; Draw side walls randomly 
5fb2			 
5fb2 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fe0			 
5fe0			; Draw player 
5fe0 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5ffe			 
5ffe			; TODO Get Key 
5ffe			 
5ffe			; TODO Move left right 
5ffe			 
5ffe			; scroll and move walls a bit 
5ffe			 
5ffe .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
602f			 
602f			; main game loop 
602f			 
602f .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
605b .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
609a			 
609a			; key board defs 
609a			 
609a .. 00		keyup:       db ": keyup $05 ;",0 
60a8 .. 00		keydown:       db ": keydown $0a ;",0 
60b8 .. 00		keyleft:       db ": keyleft $0b ;",0 
60c8 .. 00		keyright:       db ": keyright $0c ;",0 
60d9 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60e7 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60f5 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6103 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6111 .. 00		keyf5:       db ": keyf5 $14 ;",0 
611f .. 00		keyf6:       db ": keyf6 $15 ;",0 
612d .. 00		keyf7:       db ": keyf7 $16 ;",0 
613b .. 00		keyf8:       db ": keyf8 $17 ;",0 
6149 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6157 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6166 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6175 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6184			 
6184 .. 00		keytab:       db ": keytab $09 ;",0 
6193 .. 00		keycr:       db ": keycr $0d ;",0 
61a1 .. 00		keyhome:       db ": keyhome $0e ;",0 
61b1 .. 00		keyend:       db ": keyend $0f ;",0 
61c0 .. 00		keybs:       db ": keybs $08 ;",0 
61ce			 
61ce			   
61ce			 
61ce			 
61ce			 
61ce			; eof 
# End of file forth_autostart.asm
61ce			 
61ce .. 00		sprompt1: db "Startup load...",0 
61de .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61f4			 
61f4			 
61f4			 
61f4			 
61f4			forth_startup: 
61f4 21 2c 53			ld hl, startcmds 
61f7 3e 00			ld a, 0 
61f9 32 3a f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61fc			 
61fc e5			.start1:	push hl 
61fd cd e7 0a			call clear_display 
6200 11 ce 61			ld de, sprompt1 
6203 3e 00		        ld a, display_row_1 
6205 cd fa 0a			call str_at_display 
6208 11 de 61			ld de, sprompt2 
620b 3e 28		        ld a, display_row_2 
620d cd fa 0a			call str_at_display 
6210 e1				pop hl 
6211 e5				push hl 
6212 5e				ld e,(hl) 
6213 23				inc hl 
6214 56				ld d,(hl) 
6215 3e 50		        ld a, display_row_3 
6217 cd fa 0a			call str_at_display 
621a cd 0a 0b			call update_display 
621d			 
621d			 
621d 3a 3a f2			ld a, (os_last_cmd) 
6220 fe 00			cp 0 
6222 28 05			jr z, .startprompt 
6224 cd 58 0a			call delay250ms 
6227 18 24			jr .startdo 
6229				 
6229				 
6229			 
6229			.startprompt: 
6229			 
6229 3e 9f			ld a,display_row_4 + display_cols - 1 
622b 11 70 1c		        ld de, endprg 
622e cd fa 0a			call str_at_display 
6231 cd 0a 0b			call update_display 
6234 cd 64 0a			call delay1s 
6237 cd 46 69			call cin_wait 
623a						 
623a fe 2a			cp '*' 
623c 28 5e			jr z, .startupend1 
623e fe 23			cp '#' 
6240 20 07			jr nz, .startno 
6242 3e 01			ld a, 1 
6244 32 3a f2			ld (os_last_cmd),a 
6247 18 04			jr .startdo 
6249 fe 31		.startno:	cp '1' 
624b 28 3a			jr z,.startnxt  
624d			 
624d				; exec startup line 
624d			.startdo:	 
624d e1				pop hl 
624e e5				push hl 
624f				 
624f 5e				ld e,(hl) 
6250 23				inc hl 
6251 56				ld d,(hl) 
6252 eb				ex de,hl 
6253			 
6253 e5				push hl 
6254			 
6254 3e 00			ld a, 0 
6256				;ld a, FORTH_END_BUFFER 
6256 cd 84 11			call strlent 
6259 23				inc hl   ; include zero term to copy 
625a 06 00			ld b,0 
625c 4d				ld c,l 
625d e1				pop hl 
625e 11 14 ee			ld de, scratch 
6261 ed b0			ldir 
6263			 
6263			 
6263 21 14 ee			ld hl, scratch 
6266 cd b1 20			call forthparse 
6269 cd f1 20			call forthexec 
626c cd 08 20			call forthexec_cleanup 
626f			 
626f 3e 78			ld a, display_row_4 
6271 11 14 1a			ld de, endprog 
6274			 
6274 cd 0a 0b			call update_display		 
6277			 
6277 3a 3a f2			ld a, (os_last_cmd) 
627a fe 00			cp 0 
627c 20 09			jr nz, .startnxt 
627e cd 72 1c			call next_page_prompt 
6281 cd e7 0a		        call clear_display 
6284 cd 0a 0b			call update_display		 
6287			 
6287				; move onto next startup line? 
6287			.startnxt: 
6287			 
6287 cd 58 0a			call delay250ms 
628a e1				pop hl 
628b			 
628b 23				inc hl 
628c 23				inc hl 
628d			 
628d e5				push hl 
628e 5e				ld e, (hl) 
628f 23				inc hl 
6290 56				ld d, (hl) 
6291 e1				pop hl 
6292				; TODO replace 0 test 
6292			 
6292 eb				ex de, hl 
6293 cd 44 0d			call ishlzero 
6296			;	ld a,e 
6296			;	add d 
6296			;	cp 0    ; any left to do? 
6296 eb				ex de, hl 
6297 c2 fc 61			jp nz, .start1 
629a 18 01			jr .startupend 
629c			 
629c e1			.startupend1: pop hl 
629d			.startupend: 
629d			 
629d cd e7 0a			call clear_display 
62a0 cd 0a 0b			call update_display 
62a3 c9				ret 
62a4			 
62a4			 
62a4			; stack over and underflow checks 
62a4			 
62a4			; init the words to detect the under/overflow 
62a4			 
62a4			chk_stk_init: 
62a4				; a vague random number to check so we dont get any "lucky" hits 
62a4 3e 2d			ld a, 45 
62a6 6f				ld l, a 
62a7 00				nop 
62a8 3e 17			ld a, 23 
62aa 67				ld h, a 
62ab			 
62ab 22 fb ed			ld (chk_word), hl     ; the word we need to check against 
62ae			 
62ae			;	ld (chk_stund), hl	; stack points.... 
62ae 22 fd fb			ld (chk_stovr), hl 
62b1 22 ff f7			ld (chk_ret_und), hl 
62b4 22 7d f7			ld (chk_ret_ovr), hl 
62b7 22 7b f5			ld (chk_loop_ovr), hl 
62ba 22 79 f3			ld (chk_data_ovr), hl 
62bd c9				ret 
62be				 
62be			check_stacks: 
62be				; check all stack words 
62be			 
62be e5				push hl 
62bf d5				push de 
62c0			 
62c0			;	ld de,(chk_word) 
62c0			;	ld hl, (chk_stund)	; stack points.... 
62c0			;	if DEBUG_STK_FAULT 
62c0			;		DMARK "FAa" 
62c0			;		CALLMONITOR 
62c0			;	endif 
62c0			;	call cmp16 
62c0			;	jp z, .chk_faulta 
62c0			; 
62c0			;	ld de, sfaultsu 
62c0			;	jp .chk_fault 
62c0			 
62c0 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
62c3 ed 5b fb ed		ld de,(chk_word) 
62c7				if DEBUG_STK_FAULT 
62c7					DMARK "FAb" 
62c7					CALLMONITOR 
62c7				endif 
62c7 cd 39 0d			call cmp16 
62ca 28 06			jr z, .chk_fault1 
62cc 11 6d 63			ld de, sfaultso 
62cf c3 21 63			jp .chk_fault 
62d2			.chk_fault1:  
62d2 2a ff f7			ld hl, (chk_ret_und) 
62d5 ed 5b fb ed		ld de,(chk_word) 
62d9				if DEBUG_STK_FAULT 
62d9					DMARK "FAU" 
62d9					CALLMONITOR 
62d9				endif 
62d9 cd 39 0d			call cmp16 
62dc ca e5 62			jp z, .chk_fault2 
62df 11 7d 63			ld de, sfaultru 
62e2 c3 21 63			jp .chk_fault 
62e5			.chk_fault2:  
62e5 2a 7d f7			ld hl, (chk_ret_ovr) 
62e8 ed 5b fb ed		ld de,(chk_word) 
62ec				if DEBUG_STK_FAULT 
62ec					DMARK "FA1" 
62ec					CALLMONITOR 
62ec				endif 
62ec cd 39 0d			call cmp16 
62ef ca f8 62			jp z, .chk_fault3 
62f2 11 8b 63			ld de, sfaultro 
62f5 c3 21 63			jp .chk_fault 
62f8			.chk_fault3:  
62f8 2a 7b f5			ld hl, (chk_loop_ovr) 
62fb ed 5b fb ed		ld de,(chk_word) 
62ff				if DEBUG_STK_FAULT 
62ff					DMARK "FA2" 
62ff					CALLMONITOR 
62ff				endif 
62ff cd 39 0d			call cmp16 
6302 ca 0b 63			jp z, .chk_fault4 
6305 11 a5 63			ld de, sfaultlo 
6308 c3 21 63			jp .chk_fault 
630b			.chk_fault4:  
630b 2a 79 f3			ld hl, (chk_data_ovr) 
630e ed 5b fb ed		ld de,(chk_word) 
6312				if DEBUG_STK_FAULT 
6312					DMARK "FA3" 
6312					CALLMONITOR 
6312				endif 
6312 cd 39 0d			call cmp16 
6315 ca 1e 63			jp z, .chk_fault5 
6318 11 bf 63			ld de, sfaultdo 
631b c3 21 63			jp .chk_fault 
631e			 
631e			 
631e			.chk_fault5:  
631e d1				pop de 
631f e1				pop hl 
6320			 
6320 c9				ret 
6321			 
6321 cd e7 0a		.chk_fault: 	call clear_display 
6324 3e 28				ld a, display_row_2 
6326 cd fa 0a				call str_at_display 
6329 11 4f 63				   ld de, .stackfault 
632c 3e 00				ld a, display_row_1 
632e cd fa 0a				call str_at_display 
6331 11 6e fb				    ld de, debug_mark 
6334 3e 11				ld a, display_row_1+17 
6336 cd fa 0a				call str_at_display 
6339 cd 0a 0b				call update_display 
633c			 
633c				; prompt before entering montior for investigating issue 
633c			 
633c 3e 78			ld a, display_row_4 
633e 11 14 1a			ld de, endprog 
6341			 
6341 cd 0a 0b			call update_display		 
6344			 
6344 cd 72 1c			call next_page_prompt 
6347			 
6347 d1				pop de 
6348 e1				pop hl 
6349 cd 68 1a				call monitor 
634c c3 5f 19				jp warmstart 
634f					;jp 0 
634f					;halt 
634f			 
634f			 
634f			 
634f .. 00		.stackfault: 	db "Stack fault:",0 
635c			 
635c .. 00		sfaultsu: 	db	"Stack under flow",0 
636d .. 00		sfaultso: 	db	"Stack over flow",0 
637d .. 00		sfaultru:	db "RTS underflow",0 
638b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
63a5 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
63bf .. 00		sfaultdo:	db "DTS overflow", 0 
63cc			 
63cc			 
63cc			fault_dsp_under: 
63cc 11 de 63			ld de, .dsp_under 
63cf c3 8e 64			jp .show_fault 
63d2			 
63d2			fault_rsp_under: 
63d2 11 ec 63			ld de, .rsp_under 
63d5 c3 8e 64			jp .show_fault 
63d8			fault_loop_under: 
63d8 11 fa 63			ld de, .loop_under 
63db c3 8e 64			jp .show_fault 
63de			 
63de .. 00		.dsp_under: db "DSP Underflow",0 
63ec .. 00		.rsp_under: db "RSP Underflow",0 
63fa .. 00		.loop_under: db "LOOP Underflow",0 
6409			 
6409			 
6409 d5			type_faultn: 	push de 
640a e5					push hl 
640b cd e7 0a				call clear_display 
640e 11 35 64				   ld de, .typefaultn 
6411 3e 00				ld a, display_row_1 
6413 cd fa 0a				call str_at_display 
6416 11 6e fb				    ld de, debug_mark 
6419 3e 11				ld a, display_row_1+17 
641b cd fa 0a				call str_at_display 
641e cd 0a 0b				call update_display 
6421			 
6421				; prompt before entering montior for investigating issue 
6421			 
6421 3e 78			ld a, display_row_4 
6423 11 14 1a			ld de, endprog 
6426			 
6426 cd 0a 0b			call update_display		 
6429			 
6429 cd 72 1c			call next_page_prompt 
642c			 
642c e5					push hl 
642d d5					push de 
642e cd 68 1a				call monitor 
6431 c3 5f 19				jp warmstart 
6434 76					halt 
6435			 
6435			 
6435 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
644c			 
644c d5			type_faults: 	push de 
644d e5					push hl 
644e cd e7 0a				call clear_display 
6451 11 77 64				   ld de, .typefaults 
6454 3e 00				ld a, display_row_1 
6456 cd fa 0a				call str_at_display 
6459 11 6e fb				    ld de, debug_mark 
645c 3e 11				ld a, display_row_1+17 
645e cd fa 0a				call str_at_display 
6461 cd 0a 0b				call update_display 
6464			 
6464				; prompt before entering montior for investigating issue 
6464			 
6464 3e 78			ld a, display_row_4 
6466 11 14 1a			ld de, endprog 
6469			 
6469 cd 0a 0b			call update_display		 
646c			 
646c cd 72 1c			call next_page_prompt 
646f			 
646f e1					pop hl 
6470 d1					pop de 
6471 cd 68 1a				call monitor 
6474 c3 5f 19				jp warmstart 
6477			 
6477			 
6477 .. 00		.typefaults: db "STR Type Expected TOS!",0 
648e			 
648e			.show_fault: 	 
648e d5					push de 
648f cd e7 0a				call clear_display 
6492 d1					pop de 
6493 3e 00				ld a, display_row_1 
6495 cd fa 0a				call str_at_display 
6498 11 6e fb				    ld de, debug_mark 
649b 3e 11				ld a, display_row_1+17 
649d cd fa 0a				call str_at_display 
64a0 cd 0a 0b				call update_display 
64a3			 
64a3				; prompt before entering montior for investigating issue 
64a3			 
64a3 3e 78			ld a, display_row_4 
64a5 11 14 1a			ld de, endprog 
64a8			 
64a8 cd 0a 0b			call update_display		 
64ab			 
64ab cd 72 1c			call next_page_prompt 
64ae			 
64ae e1					pop hl 
64af d1					pop de 
64b0 cd 68 1a				call monitor 
64b3			; do a dump to cli and not warmstart so we preserve all of the uwords.  
64b3			; TODO Make optional fault restart to cli or warm boot? 
64b3					;jp warmstart 
64b3 c3 ba 19				jp cli 
64b6 76					halt 
64b7			 
64b7			; handle the auto run of code from files in storage 
64b7			 
64b7			 
64b7			if STORAGE_SE 
64b7			 
64b7 .. 00		sprompt3: db "Loading from start-up file?:",0 
64d4 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
64e5			 
64e5			 
64e5			forth_autoload: 
64e5			 
64e5				; load block 0 of store 1 
64e5				 
64e5 3e fe			ld a, $fe      ; bit 0 clear 
64e7 32 3f f8			ld (spi_device), a 
64ea			 
64ea cd b8 03			call storage_get_block_0 
64ed			 
64ed 3a 7a f8			ld a, (store_page+STORE_0_AUTOFILE) 
64f0			 
64f0 fe 00			cp 0 
64f2 c8				ret z     ; auto start not enabled 
64f3			 
64f3 cd e7 0a			call clear_display 
64f6			 
64f6				; set bank 
64f6			 
64f6 3a 7c f8				ld a, (store_page+STORE_0_BANKRUN) 
64f9 32 3f f8				ld (spi_device), a 
64fc			 
64fc				; get file id to load from and get the file name to display 
64fc			 
64fc 3a 7d f8				ld a, (store_page+STORE_0_FILERUN) 
64ff			 
64ff 2e 00				ld l, 0 
6501 67					ld h, a 
6502 11 59 f8				ld de, store_page 
6505			 
6505					if DEBUG_FORTH_WORDS 
6505						DMARK "ASp" 
6505 f5				push af  
6506 3a 1a 65			ld a, (.dmark)  
6509 32 6e fb			ld (debug_mark),a  
650c 3a 1b 65			ld a, (.dmark+1)  
650f 32 6f fb			ld (debug_mark+1),a  
6512 3a 1c 65			ld a, (.dmark+2)  
6515 32 70 fb			ld (debug_mark+2),a  
6518 18 03			jr .pastdmark  
651a ..			.dmark: db "ASp"  
651d f1			.pastdmark: pop af  
651e			endm  
# End of macro DMARK
651e						CALLMONITOR 
651e cd 6a 17			call break_point_state  
6521				endm  
# End of macro CALLMONITOR
6521					endif 
6521 cd 52 08				call storage_read 
6524			 
6524					if DEBUG_FORTH_WORDS 
6524						DMARK "ASr" 
6524 f5				push af  
6525 3a 39 65			ld a, (.dmark)  
6528 32 6e fb			ld (debug_mark),a  
652b 3a 3a 65			ld a, (.dmark+1)  
652e 32 6f fb			ld (debug_mark+1),a  
6531 3a 3b 65			ld a, (.dmark+2)  
6534 32 70 fb			ld (debug_mark+2),a  
6537 18 03			jr .pastdmark  
6539 ..			.dmark: db "ASr"  
653c f1			.pastdmark: pop af  
653d			endm  
# End of macro DMARK
653d						CALLMONITOR 
653d cd 6a 17			call break_point_state  
6540				endm  
# End of macro CALLMONITOR
6540					endif 
6540			 
6540 cd 44 0d				call ishlzero 
6543 c8					ret z             ; file not found 
6544			 
6544 3e 32				ld a, display_row_2 + 10 
6546 11 5c f8				ld de, store_page+3 
6549 cd fa 0a				call str_at_display 
654c				 
654c			; 
654c			 
654c 3e 05			ld a, display_row_1+5 
654e 11 b7 64			ld de, sprompt3 
6551 cd fa 0a			call str_at_display 
6554 3e 5f			ld a, display_row_3+15 
6556 11 d4 64			ld de, sprompt4 
6559 cd fa 0a			call str_at_display 
655c			 
655c cd 0a 0b			call update_display 
655f			 
655f cd 46 69			call cin_wait 
6562 fe 6e			cp 'n' 
6564 c8				ret z 
6565 fe 4e			cp 'N' 
6567 c8				ret z 
6568			 
6568 cd 64 0a			call delay1s 
656b			 
656b 3a 5b f8			ld a, (store_page+2) 
656e 32 4f f8			ld (store_openmaxext), a    ; save count of ext 
6571 3e 01			ld a, 1  
6573 32 50 f8			ld (store_openext), a    ; save count of ext 
6576			 
6576			.autof:  
6576 6f				ld l , a 
6577				 
6577 3a 59 f8			ld a, (store_page) 
657a 67				ld h, a	 
657b 11 59 f8			ld de, store_page 
657e					if DEBUG_FORTH_WORDS 
657e						DMARK "ASl" 
657e f5				push af  
657f 3a 93 65			ld a, (.dmark)  
6582 32 6e fb			ld (debug_mark),a  
6585 3a 94 65			ld a, (.dmark+1)  
6588 32 6f fb			ld (debug_mark+1),a  
658b 3a 95 65			ld a, (.dmark+2)  
658e 32 70 fb			ld (debug_mark+2),a  
6591 18 03			jr .pastdmark  
6593 ..			.dmark: db "ASl"  
6596 f1			.pastdmark: pop af  
6597			endm  
# End of macro DMARK
6597						CALLMONITOR 
6597 cd 6a 17			call break_point_state  
659a				endm  
# End of macro CALLMONITOR
659a					endif 
659a cd 52 08				call storage_read 
659d cd 44 0d			call ishlzero 
65a0 c8				ret z 
65a1			;	jr z, .autoend 
65a1			 
65a1					if DEBUG_FORTH_WORDS 
65a1						DMARK "ASc" 
65a1 f5				push af  
65a2 3a b6 65			ld a, (.dmark)  
65a5 32 6e fb			ld (debug_mark),a  
65a8 3a b7 65			ld a, (.dmark+1)  
65ab 32 6f fb			ld (debug_mark+1),a  
65ae 3a b8 65			ld a, (.dmark+2)  
65b1 32 70 fb			ld (debug_mark+2),a  
65b4 18 03			jr .pastdmark  
65b6 ..			.dmark: db "ASc"  
65b9 f1			.pastdmark: pop af  
65ba			endm  
# End of macro DMARK
65ba						CALLMONITOR 
65ba cd 6a 17			call break_point_state  
65bd				endm  
# End of macro CALLMONITOR
65bd					endif 
65bd 11 5b f8			ld de, store_page+2 
65c0 3e 78			ld a, display_row_4 
65c2 cd fa 0a			call str_at_display 
65c5			 
65c5 cd 0a 0b			call update_display 
65c8 cd 58 0a			call delay250ms 
65cb			 
65cb			 
65cb			 
65cb 21 5b f8			ld hl, store_page+2 
65ce cd b1 20			call forthparse 
65d1 cd f1 20			call forthexec 
65d4 cd 08 20			call forthexec_cleanup 
65d7			 
65d7				 
65d7 3a 50 f8			ld a, (store_openext) 
65da 3c				inc a 
65db 32 50 f8			ld (store_openext), a    ; save count of ext 
65de			 
65de 18 96			jr .autof 
65e0			;.autofdone: 
65e0			; 
65e0			;		if DEBUG_FORTH_WORDS 
65e0			;			DMARK "ASx" 
65e0			;			CALLMONITOR 
65e0			;		endif 
65e0			;;	call clear_display 
65e0			;	ret 
65e0			 
65e0			 
65e0			 
65e0			endif 
65e0			 
65e0			 
65e0			; eof 
# End of file forth_kernel.asm
65e0			;include "nascombasic.asm" 
65e0			 
65e0			 
65e0			; find out where the code ends if loaded into RAM (for SC114) 
65e0			;endofcode:  
65e0			;	nop 
65e0			 
65e0			 
65e0			; eof 
65e0			 
# End of file main.asm
65e0			include "firmware_lcd_4x40.asm" 
65e0			; **********************************************************************  
65e0			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
65e0			; **********************************************************************  
65e0			;  
65e0			; **  Written as a Small Computer Monitor App  
65e0			; **  www.scc.me.uk  
65e0			;  
65e0			; History  
65e0			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
65e0			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
65e0			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
65e0			;  
65e0			; **********************************************************************  
65e0			;  
65e0			; This program is an example of one of the methods of interfacing an   
65e0			; alphanumeric LCD module.   
65e0			;  
65e0			; In this example the display is connected to either a Z80 PIO or a   
65e0			; simple 8-bit output port.   
65e0			;  
65e0			; This interfacing method uses 4-bit data mode and uses time delays  
65e0			; rather than polling the display's ready status. As a result the   
65e0			; interface only requires 6 simple output lines:  
65e0			;   Output bit 0 = not used  
65e0			;   Output bit 1 = not used  
65e0			;   Output bit 2 = RS         High = data, Low = instruction  
65e0			;   Output bit 3 = E          Active high  
65e0			;   Output bit 4 = DB4  
65e0			;   Output bit 5 = DB5  
65e0			;   Output bit 6 = DB6  
65e0			;   Output bit 7 = DB7  
65e0			; Display's R/W is connected to 0v so it is always in write mode  
65e0			;  
65e0			; This set up should work with any system supporting the RC2014 bus  
65e0			  
65e0			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
65e0			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
65e0			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
65e0			;  
65e0			; **********************************************************************  
65e0			  
65e0			; Additonal for 4x40. E1 and E2 instead of just E   
65e0			; TODO swipe vidout signal on port a to activate E2  
65e0			  
65e0			; **********************************************************************  
65e0			; **  Constants  
65e0			; **********************************************************************  
65e0			; LCD constants required by LCD support module  
65e0			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
65e0			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
65e0			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
65e0			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
65e0			; TODO Decide which E is being set  
65e0			kLCDWidth:  EQU display_cols             ;Width in characters  
65e0			  
65e0			; **********************************************************************  
65e0			; **  Code library usage  
65e0			; **********************************************************************  
65e0			  
65e0			; send character to current cursor position  
65e0			; wraps and/or scrolls screen automatically  
65e0			  
65e0			  
65e0			  
65e0			lcd_init:  
65e0			  
65e0			; SCMonAPI functions used  
65e0			  
65e0			; Alphanumeric LCD functions used  
65e0			; no need to specify specific functions for this module  
65e0			  
65e0 3e cf		            LD   A, 11001111b  
65e2 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
65e4 3e 00		            LD   A, 00000000b  
65e6 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
65e8			  
65e8			; Initialise alphanumeric LCD module  
65e8 3e 00				ld a, 0  
65ea 32 ce f8				ld (display_lcde1e2), a  
65ed cd 6e 66		            CALL fLCD_Init      ;Initialise LCD module  
65f0 3e 01				ld a, 1  
65f2 32 ce f8				ld (display_lcde1e2), a  
65f5 cd 6e 66		            CALL fLCD_Init      ;Initialise LCD module  
65f8			  
65f8 c9				ret  
65f9			  
65f9			;  
65f9			;;  
65f9			; lcd functions  
65f9			;  
65f9			;  
65f9			  
65f9			; what is at cursor position   
65f9			  
65f9			;get_cursor:	ld de, (cursor_row)   ;  row + col  
65f9			;		call curptr  
65f9			;		ret  
65f9			  
65f9			  
65f9			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
65f9			  
65f9			curptr:  
65f9 c5				push bc  
65fa 21 b4 fa			ld hl, display_fb0  
65fd			cpr:	  
65fd				; loop for cursor whole row  
65fd 0e 28			ld c, display_cols  
65ff 23			cpr1:	inc hl  
6600 0d				dec c  
6601 20 fc			jr nz, cpr1  
6603 05				dec b  
6604 20 f7			jr nz, cpr  
6606			  
6606				; add col	  
6606			  
6606 23			cpr2:	inc hl  
6607 1d				dec e  
6608 20 fc			jr nz, cpr2  
660a			  
660a c1				pop bc  
660b c9				ret  
660c				  
660c			  
660c			  
660c			  
660c			  
660c			; write the frame buffer given in hl to hardware   
660c 22 cc f8		write_display: ld (display_write_tmp), hl 	   
660f 3e 00			ld a, kLCD_Line1  
6611 cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6614 06 28			ld b, display_cols  
6616 ed 5b cc f8		ld de, (display_write_tmp)  
661a cd 66 66			call write_len_string  
661d				  
661d				  
661d 2a cc f8			ld hl, (display_write_tmp)  
6620 11 28 00			ld de, display_cols  
6623 19				add hl,de  
6624 22 cc f8			ld (display_write_tmp),hl  
6627			  
6627				  
6627 3e 28			ld a, kLCD_Line2  
6629 cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
662c 06 28			ld b, display_cols  
662e ed 5b cc f8		ld de, (display_write_tmp)  
6632 cd 66 66			call write_len_string  
6635				  
6635 2a cc f8			ld hl, (display_write_tmp)  
6638 11 28 00			ld de, display_cols  
663b 19				add hl,de  
663c 22 cc f8			ld (display_write_tmp),hl  
663f			  
663f				  
663f 3e 50			ld a, kLCD_Line3  
6641 cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6644 06 28			ld b, display_cols  
6646 ed 5b cc f8		ld de, (display_write_tmp)  
664a cd 66 66			call write_len_string  
664d				  
664d 2a cc f8			ld hl, (display_write_tmp)  
6650 11 28 00			ld de, display_cols  
6653 19				add hl,de  
6654 22 cc f8			ld (display_write_tmp),hl  
6657			  
6657				  
6657 3e 78			ld a, kLCD_Line4  
6659 cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
665c 06 28			ld b, display_cols  
665e ed 5b cc f8		ld de, (display_write_tmp)  
6662 cd 66 66			call write_len_string  
6665 c9					ret  
6666				  
6666				; write out a fixed length string given in b from de  
6666			  
6666 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6667 cd d3 66		            CALL fLCD_Data      ;Write character to display  
666a 13				inc de  
666b 10 f9			djnz write_len_string  
666d c9				ret  
666e			  
666e			; Some other things to do  
666e			;            LD   A, kLCD_Clear ;Display clear  
666e			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
666e			;            LD   A, kLCD_Under ;Display on with underscore cursor  
666e			;            LD   A, kLCD_On     ;Display on with no cursor  
666e			;            ;LD   A, kLCD_Off   ;Display off  
666e			;            CALL fLCD_Inst      ;Send instruction to display  
666e			;  
666e			;  
666e			;            halt  
666e			;  
666e			;  
666e			;MsgHello:   DB  "Hello World!",0  
666e			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
666e			  
666e			; Custom characters 5 pixels wide by 8 pixels high  
666e			; Up to 8 custom characters can be defined  
666e			;BitMaps:      
666e			;; Character 0x00 = Battery icon  
666e			;            DB  01110b  
666e			;            DB  11011b  
666e			;            DB  10001b  
666e			;            DB  10001b  
666e			;            DB  11111b  
666e			;            DB  11111b  
666e			;            DB  11111b  
666e			;            DB  11111b  
666e			;; Character 0x01 = Bluetooth icon  
666e			;            DB  01100b  
666e			;            DB  01010b  
666e			;            DB  11100b  
666e			;            DB  01000b  
666e			;            DB  11100b  
666e			;            DB  01010b  
666e			;            DB  01100b  
666e			;            DB  00000b  
666e			;  
666e			  
666e			  
666e			; **********************************************************************  
666e			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
666e			; **********************************************************************  
666e			;  
666e			; **  Written as a Small Computer Monitor App   
666e			; **  Version 0.1 SCC 2018-05-16  
666e			; **  www.scc.me.uk  
666e			;  
666e			; **********************************************************************  
666e			;  
666e			; This module provides support for alphanumeric LCD modules using with  
666e			; *  HD44780 (or compatible) controller  
666e			; *  5 x 7 pixel fonts  
666e			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
666e			; *  Interface via six digital outputs to the display (see below)  
666e			;  
666e			; LCD module pinout:  
666e			;   1  Vss   0v supply  
666e			;   2  Vdd   5v supply  
666e			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
666e			;   4  RS    High = data, Low = instruction  
666e			;   5  R/W   High = Read, Low = Write  
666e			;   6  E     Enable signal (active high)  
666e			;   7  DB0   Data bit 0  
666e			;   8  DB1   Data bit 1  
666e			;   9  DB2   Data bit 2  
666e			;  10  DB3   Data bit 3  
666e			;  11  DB4   Data bit 4  
666e			;  12  DB5   Data bit 5  
666e			;  13  DB6   Data bit 6  
666e			;  14  DB7   Data bit 7  
666e			;  15  A     Backlight anode (+)  
666e			;  16  K     Backlight cathode (-)  
666e			;  
666e			; This interfacing method uses 4-bit data mode and uses time delays  
666e			; rather than polling the display's ready status. As a result the   
666e			; interface only requires 6 simple output lines:  
666e			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
666e			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
666e			;   LCD DB4 = Microcomputer output port bit 4  
666e			;   LCD DB5 = Microcomputer output port bit 5  
666e			;   LCD DB6 = Microcomputer output port bit 6  
666e			;   LCD DB7 = Microcomputer output port bit 7  
666e			; Display's R/W is connected to 0v so it is always in write mode  
666e			; All 6 connections must be on the same port address <kLCDPrt>  
666e			; This method also allows a decent length of cable from micro to LCD  
666e			;  
666e			; **********************************************************************  
666e			;  
666e			; To include the code for any given function provided by this module,   
666e			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
666e			; the parent source file.  
666e			; For example:  #REQUIRES   uHexPrefix  
666e			;  
666e			; Also #INCLUDE this file at some point after the #REQUIRES statements  
666e			; in the parent source file.  
666e			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
666e			;  
666e			; These are the function names provided by this module:  
666e			; fLCD_Init                     ;Initialise LCD  
666e			; fLCD_Inst                     ;Send instruction to LCD  
666e			; fLCD_Data                     ;Send data byte to LCD  
666e			; fLCD_Pos                      ;Position cursor  
666e			; fLCD_Str                      ;Display string  
666e			; fLCD_Def                      ;Define custom character  
666e			;  
666e			; **********************************************************************  
666e			;  
666e			; Requires SCMonAPI.asm to also be included in the project  
666e			;  
666e			  
666e			  
666e			; **********************************************************************  
666e			; **  Constants  
666e			; **********************************************************************  
666e			  
666e			; Constants that must be defined externally  
666e			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
666e			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
666e			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
666e			;kLCDWidth: EQU 20             ;Width in characters  
666e			  
666e			; general line offsets in any frame buffer  
666e			  
666e			  
666e			display_row_1: equ 0  
666e			display_row_2: equ display_row_1+display_cols  
666e			display_row_3: equ display_row_2 + display_cols  
666e			display_row_4: equ display_row_3 + display_cols  
666e			;display_row_4_eol:   
666e			  
666e			  
666e			; Cursor position values for the start of each line  
666e			  
666e			; E  
666e			kLCD_Line1: EQU 0x00   
666e			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
666e			; E1  
666e			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
666e			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
666e			  
666e			; Instructions to send as A register to fLCD_Inst  
666e			kLCD_Clear: EQU 00000001b     ;LCD clear  
666e			kLCD_Off:   EQU 00001000b     ;LCD off  
666e			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
666e			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
666e			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
666e			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
666e			  
666e			; Constants used by this code module  
666e			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
666e			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
666e			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
666e			  
666e			  
666e			  
666e			; **********************************************************************  
666e			; **  LCD support functions  
666e			; **********************************************************************  
666e			  
666e			; Initialise alphanumeric LCD module  
666e			; LCD control register codes:  
666e			;   DL   0 = 4-bit mode        1 = 8-bit mode  
666e			;   N    0 = 1-line mode       1 = 2-line mode  
666e			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
666e			;   D    0 = Display off       1 = Display on  
666e			;   C    0 = Cursor off        1 = Cursor on  
666e			;   B    0 = Blinking off      1 = Blinking on  
666e			;   ID   0 = Decrement mode    1 = Increment mode  
666e			;   SH   0 = Entire shift off  1 = Entire shift on  
666e 3e 28		fLCD_Init:  LD   A, 40  
6670 cd 95 67		            CALL LCDDelay       ;Delay 40ms after power up  
6673			; For reliable reset set 8-bit mode - 3 times  
6673 cd 65 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6676 cd 65 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6679 cd 65 67		            CALL WrFn8bit       ;Function = 8-bit mode  
667c			; Set 4-bit mode  
667c cd 61 67		            CALL WrFn4bit       ;Function = 4-bit mode  
667f cd 93 67		            CALL LCDDelay1      ;Delay 37 us or more  
6682			; Function set  
6682 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6684 cd 97 66		            CALL fLCD_Inst      ;2 line, display on  
6687			; Display On/Off control  
6687 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6689 cd 97 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
668c			; Display Clear  
668c 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
668e cd 97 66		            CALL fLCD_Inst      ;Clear display  
6691			; Entry mode  
6691 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6693 cd 97 66		            CALL fLCD_Inst      ;Increment mode, shift off  
6696			; Display module now initialised  
6696 c9			            RET  
6697			; ok to here  
6697			  
6697			; Write instruction to LCD  
6697			;   On entry: A = Instruction byte to be written  
6697			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6697 f5			fLCD_Inst:  PUSH AF  
6698 f5			            PUSH AF  
6699 cd ab 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
669c f1			            POP  AF  
669d 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
669e 17			            RLA  
669f 17			            RLA  
66a0 17			            RLA  
66a1 cd ab 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
66a4 3e 02		            LD   A, 2  
66a6 cd 95 67		            CALL LCDDelay       ;Delay 2 ms to complete   
66a9 f1			            POP  AF  
66aa c9			            RET  
66ab			Wr4bits:   
66ab f5					push af  
66ac 3a ce f8				ld a, (display_lcde1e2)  
66af fe 00				cp 0     ; e  
66b1 20 10				jr nz, .wea2	  
66b3 f1					pop af  
66b4 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66b8 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
66ba cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
66bc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66be cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
66c0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66c2 c9			            RET  
66c3 f1			.wea2:		pop af  
66c4 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66c8 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
66ca cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
66cc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66ce cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
66d0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66d2 c9			            RET  
66d3			  
66d3			  
66d3			; Write data to LCD  
66d3			;   On entry: A = Data byte to be written  
66d3			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66d3 f5			fLCD_Data:  PUSH AF  
66d4 f5			            PUSH AF  
66d5 cd e7 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
66d8 f1			            POP  AF  
66d9 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
66da 17			            RLA  
66db 17			            RLA  
66dc 17			            RLA  
66dd cd e7 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
66e0 3e 96		            LD   A, 150  
66e2 3d			Wait:      DEC  A              ;Wait a while to allow data   
66e3 20 fd		            JR   NZ, Wait      ;  write to complete  
66e5 f1			            POP  AF  
66e6 c9			            RET  
66e7			Wr4bitsa:     
66e7 f5					push af  
66e8 3a ce f8				ld a, (display_lcde1e2)  
66eb fe 00				cp 0     ; e1  
66ed 20 16				jr nz, .we2	  
66ef f1					pop af  
66f0 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66f2 cb d7		            SET  kLCDBitRS, A  
66f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
66f6 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
66f8 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
66fa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
66fc cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
66fe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6700 cb 97		            RES  kLCDBitRS, A  
6702 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6704 c9			            RET  
6705 f1			.we2:		pop af  
6706 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6708 cb d7		            SET  kLCDBitRS, A  
670a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
670c cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
670e cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6710 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6712 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6714 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6716 cb 97		            RES  kLCDBitRS, A  
6718 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
671a c9			            RET  
671b			  
671b			  
671b			; Position cursor to specified location  
671b			;   On entry: A = Cursor position  
671b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
671b f5			fLCD_Pos:   PUSH AF  
671c					; at this point set the E1 or E2 flag depending on position  
671c			  
671c c5					push bc  
671d			;		push af  
671d 06 00				ld b, 0  
671f 4f					ld c, a  
6720 3e 4f				ld a, kLCD_Line3-1  
6722 b7			 		or a      ;clear carry flag  
6723 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6724 38 04				jr c, .pe1  
6726			  
6726					; E selection  
6726 cb 80				res 0, b         ; bit 0 unset e  
6728			;		pop af    ; before line 3 so recover orig pos  
6728			;		ld c, a    ; save for poking back  
6728 18 06				jr .peset	          
672a			.pe1:          	; E2 selection  
672a cb c0				set 0, b         ; bit 0 set e1  
672c 79					ld a, c  
672d de 4f				sbc a, kLCD_Line3-1  
672f 4f					ld c, a	         ; save caculated offset  
6730			;		pop af     ; bin this original value now we have calculated form  
6730			  
6730			.peset:		; set bit  
6730 78					ld a, b  
6731 32 ce f8				ld (display_lcde1e2), a 	  
6734 79					ld a, c  
6735 c1					pop bc  
6736			  
6736 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6738 cd 97 66		            CALL fLCD_Inst      ;Write instruction to LCD  
673b f1			            POP  AF  
673c c9			            RET  
673d			  
673d			  
673d			; Output text string to LCD  
673d			;   On entry: DE = Pointer to null terminated text string  
673d			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
673d 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
673e b7			            OR   A              ;Null terminator?  
673f c8			            RET  Z              ;Yes, so finished  
6740 cd d3 66		            CALL fLCD_Data      ;Write character to display  
6743 13			            INC  DE             ;Point to next character  
6744 18 f7		            JR   fLCD_Str       ;Repeat  
6746 c9					ret  
6747			  
6747			; Define custom character  
6747			;   On entry: A = Character number (0 to 7)  
6747			;             DE = Pointer to character bitmap data  
6747			;   On exit:  A = Next character number  
6747			;             DE = Next location following bitmap  
6747			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6747			; Character is   
6747 c5			fLCD_Def:   PUSH BC  
6748 f5			            PUSH AF  
6749 07			            RLCA                ;Calculate location  
674a 07			            RLCA                ;  for bitmap data  
674b 07			            RLCA                ;  = 8 x CharacterNumber  
674c f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
674e cd 97 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6751 06 00		            LD   B, 0  
6753 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6754 cd d3 66		            CALL fLCD_Data      ;Write byte to display  
6757 13			            INC  DE             ;Point to next byte  
6758 04			            INC  B              ;Count bytes  
6759 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
675b 28 f6		            JR   Z, Loop       ;No, so repeat  
675d f1			            POP  AF  
675e 3c			            INC  A              ;Increment character number  
675f c1			            POP  BC  
6760 c9			            RET  
6761			  
6761			  
6761			; **********************************************************************  
6761			; **  Private functions  
6761			; **********************************************************************  
6761			  
6761			; Write function to LCD  
6761			;   On entry: A = Function byte to be written  
6761			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6761 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6763 18 02		            JR   WrFunc  
6765 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6767 f5			WrFunc:     PUSH AF  
6768 f5					push af  
6769 3a ce f8				ld a, (display_lcde1e2)  
676c fe 00				cp 0     ; e1  
676e 20 0f				jr nz, .wfea2	  
6770 f1					pop af  
6771 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6773 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6775 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6777 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6779 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
677b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
677d 18 0d			jr .wfskip  
677f f1			.wfea2:		pop af  
6780 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6782 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6784 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6786 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6788 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
678a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
678c 3e 05		.wfskip:            LD  A, 5  
678e cd 95 67		            CALL LCDDelay       ;Delay 5 ms to complete  
6791 f1			            POP  AF  
6792 c9			            RET  
6793			  
6793			  
6793			; Delay in milliseconds  
6793			;   On entry: A = Number of milliseconds delay  
6793			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6793 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6795 d5			LCDDelay:   PUSH DE  
6796 5f			            LD   E, A           ;Delay by 'A' ms  
6797 16 00		            LD   D, 0  
6799 cd 49 0a		            CALL aDelayInMS  
679c d1			            POP  DE  
679d c9			            RET  
679e			  
679e			  
679e			testlcd:  
679e 3e 00			ld a, kLCD_Line1  
67a0 cd 1b 67			call fLCD_Pos  
67a3 06 28			ld b, 40  
67a5 11 d3 67			ld de, .ttext1  
67a8 cd 66 66			call write_len_string  
67ab			  
67ab 3e 28			ld a, kLCD_Line2  
67ad cd 1b 67			call fLCD_Pos  
67b0 06 28			ld b, 40  
67b2 11 fc 67			ld de, .ttext2  
67b5 cd 66 66			call write_len_string  
67b8 3e 50			ld a, kLCD_Line3  
67ba cd 1b 67			call fLCD_Pos  
67bd 06 28			ld b, 40  
67bf 11 25 68			ld de, .ttext3  
67c2 cd 66 66			call write_len_string  
67c5 3e 78			ld a, kLCD_Line4  
67c7 cd 1b 67			call fLCD_Pos  
67ca 06 28			ld b, 40  
67cc 11 4e 68			ld de, .ttext4  
67cf cd 66 66			call write_len_string  
67d2			  
67d2 76				halt  
67d3			  
67d3			  
67d3 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
67fc .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6825 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
684e .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6877			   
6877			  
6877			  
6877			; eof  
6877			  
# End of file firmware_lcd_4x40.asm
6877			;include "firmware_lcd_4x20.asm" 
6877			include "firmware_key_5x10.asm" 
6877			; 5 x 10 decade counter scanner  
6877			  
6877			  
6877			; TODO do cursor shape change for shift keys  
6877			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6877			  
6877			  
6877			; bit mask for each scan column and row for teing the matrix  
6877			  
6877			  
6877			key_init:  
6877			  
6877			; SCMonAPI functions used  
6877			  
6877			; Alphanumeric LCD functions used  
6877			; no need to specify specific functions for this module  
6877			  
6877			  
6877 3e cf		            LD   A, 11001111b  
6879 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
687b			;            LD   A, 00000000b  
687b 3e 1f		            LD   A, 00011111b  
687d d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
687f			  
687f			  
687f				; TODO Configure cursor shapes  
687f			  
687f				; Load cursor shapes   
687f 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6881 11 91 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6884 06 02		            LD   B, 2           ;Number of characters to define  
6886 cd 47 67		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6889 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
688b			  
688b 3e 01				ld a, 1  
688d 32 c7 f8			ld (cursor_shape),a  
6890 c9				ret  
6891			  
6891			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6891			; Up to 8 custom characters can be defined  
6891			.cursor_shapes:      
6891			;; Character 0x00 = Normal  
6891 1f			            DB  11111b  
6892 1f			            DB  11111b  
6893 1f			            DB  11111b  
6894 1f			            DB  11111b  
6895 1f			            DB  11111b  
6896 1f			            DB  11111b  
6897 1f			            DB  11111b  
6898 1f			            DB  11111b  
6899			;; Character 0x01 = Modifier  
6899 1f			            DB  11111b  
689a 1b			            DB  11011b  
689b 1b			            DB  11011b  
689c 1b			            DB  11011b  
689d 1b			            DB  11011b  
689e 1f			            DB  11111b  
689f 1b			            DB  11011b  
68a0 1f			            DB  11111b  
68a1			  
68a1			  
68a1			  
68a1			  
68a1			; Display custom character 0  
68a1			;            LD   A, kLCD_Line1+14  
68a1			;            CALL fLCD_Pos       ;Position cursor to location in A  
68a1			;            LD   A, 0  
68a1			;            CALL fLCD_Data      ;Write character in A at cursor  
68a1			  
68a1			; Display custom character 1  
68a1			;            LD   A, kLCD_Line2+14  
68a1			;            CALL fLCD_Pos      ;Position cursor to location in A  
68a1			;            LD   A, 1  
68a1			;            CALL fLCD_Data     ;Write character in A at cursor  
68a1			  
68a1			; keyboard scanning   
68a1			  
68a1			; character in from keyboard  
68a1			  
68a1			; mapping for the pcb layout  
68a1			  
68a1			.matrix_to_char:  
68a1 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
68ac .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
68b7 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
68c2 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
68cd .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
68d8			.matrix_to_shift:  
68d8			  
68d8 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
68e3 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
68ee 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
68f9 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6904 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
690f			  
690f			.matrix_to_symbolshift:  
690f			  
690f fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
691a .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6925 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6930			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6930 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
693b .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6946			  
6946			  
6946			  
6946			; mapping for a simple straight through breadboard layout  
6946			  
6946			;.matrix_to_char:  
6946			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6946			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6946			;		db "asdfghjkl",KEY_CR,0  
6946			;		db "qwertyuiop",0  
6946			;		 db "1234567890",0  
6946			;.matrix_to_shift:  
6946			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6946			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6946			;		db "ASDFGHJKL",KEY_CR,0  
6946			;		db "QWERTYUIOP",0  
6946			;		 db "!",'"',"#$%^&*()",0  
6946			;.matrix_to_symbolshift:  
6946			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6946			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6946			;		db "_?*fghjk=",KEY_CR,0  
6946			;		db "-/+*[]{}@#",0  
6946			;		 db "1234567890",0  
6946			  
6946			;.matrix_to_char: db "D#0*C987B654A321"  
6946			  
6946			  
6946				  
6946			  
6946			; add cin and cin_wait  
6946			  
6946 cd 57 69		cin_wait: 	call cin  
6949						if DEBUG_KEYCINWAIT  
6949							push af  
6949							  
6949							ld hl,key_repeat_ct  
6949							ld (hl),a  
6949							inc hl  
6949							call hexout  
6949							ld hl,key_repeat_ct+3  
6949							ld a,0  
6949							ld (hl),a  
6949			  
6949							    LD   A, kLCD_Line1+11  
6949							    CALL fLCD_Pos       ;Position cursor to location in A  
6949							    LD   DE, key_repeat_ct  
6949							    ;LD   DE, MsgHello  
6949							    CALL fLCD_Str       ;Display string pointed to by DE  
6949			  
6949			  
6949			  
6949							pop af  
6949						endif  
6949 fe 00			cp 0  
694b 28 f9			jr z, cin_wait   ; block until key press  
694d			  
694d							if DEBUG_KEYCINWAIT  
694d								push af  
694d			  
694d								ld a, 'A'	  
694d								ld hl,key_repeat_ct  
694d								ld (hl),a  
694d								inc hl  
694d								ld a,0  
694d								ld (hl),a  
694d			  
694d								    LD   A, kLCD_Line2+11  
694d								    CALL fLCD_Pos       ;Position cursor to location in A  
694d								    LD   DE, key_repeat_ct  
694d								    ;LD   DE, MsgHello  
694d								    CALL fLCD_Str       ;Display string pointed to by DE  
694d			  
694d							call delay500ms  
694d			  
694d								pop af  
694d							endif  
694d f5				push af   ; save key pressed  
694e			  
694e			.cin_wait1:	  
694e							if DEBUG_KEYCINWAIT  
694e								push af  
694e			  
694e								ld a, 'b'	  
694e								ld hl,key_repeat_ct  
694e								ld (hl),a  
694e								inc hl  
694e								ld a,0  
694e								ld (hl),a  
694e			  
694e								    LD   A, kLCD_Line2+11  
694e								    CALL fLCD_Pos       ;Position cursor to location in A  
694e								    LD   DE, key_repeat_ct  
694e								    ;LD   DE, MsgHello  
694e								    CALL fLCD_Str       ;Display string pointed to by DE  
694e			  
694e			  
694e							call delay500ms  
694e			  
694e								pop af  
694e							endif  
694e			  
694e cd 57 69		call cin  
6951 fe 00			cp 0  
6953 20 f9			jr nz, .cin_wait1  	; wait for key release  
6955			if DEBUG_KEYCINWAIT  
6955				push af  
6955			  
6955				ld a, '3'	  
6955				ld hl,key_repeat_ct  
6955				ld (hl),a  
6955				inc hl  
6955				ld a,0  
6955				ld (hl),a  
6955			  
6955			            LD   A, kLCD_Line2+11  
6955			            CALL fLCD_Pos       ;Position cursor to location in A  
6955			            LD   DE, key_repeat_ct  
6955			            ;LD   DE, MsgHello  
6955			            CALL fLCD_Str       ;Display string pointed to by DE  
6955			  
6955			  
6955			call delay500ms  
6955			  
6955				pop af  
6955			endif  
6955			  
6955 f1				pop af   ; get key  
6956 c9				ret  
6957			  
6957			  
6957 cd 6b 69		cin: 	call .mtoc  
695a			  
695a			if DEBUG_KEYCIN  
695a				push af  
695a				  
695a				ld hl,key_repeat_ct  
695a				ld (hl),a  
695a				inc hl  
695a				call hexout  
695a				ld hl,key_repeat_ct+3  
695a				ld a,0  
695a				ld (hl),a  
695a			  
695a			            LD   A, kLCD_Line3+15  
695a			            CALL fLCD_Pos       ;Position cursor to location in A  
695a			            LD   DE, key_repeat_ct  
695a			            ;LD   DE, MsgHello  
695a			            CALL fLCD_Str       ;Display string pointed to by DE  
695a			  
695a			  
695a			call delay500ms  
695a			  
695a				pop af  
695a			endif  
695a			  
695a			  
695a				; no key held  
695a fe 00			cp 0  
695c c8				ret z  
695d			  
695d			if DEBUG_KEYCIN  
695d				push af  
695d			  
695d				ld a, '1'	  
695d				ld hl,key_repeat_ct  
695d				ld (hl),a  
695d				inc hl  
695d				ld a,0  
695d				ld (hl),a  
695d			  
695d			            LD   A, kLCD_Line4+15  
695d			            CALL fLCD_Pos       ;Position cursor to location in A  
695d			            LD   DE, key_repeat_ct  
695d			            ;LD   DE, MsgHello  
695d			            CALL fLCD_Str       ;Display string pointed to by DE  
695d			  
695d			  
695d			call delay500ms  
695d			  
695d				pop af  
695d			endif  
695d			  
695d				; stop key bounce  
695d			  
695d 32 88 fb			ld (key_held),a		 ; save it  
6960 47				ld b, a  
6961			  
6961 c5			.cina1:	push bc  
6962			if DEBUG_KEYCIN  
6962				push af  
6962			  
6962				ld hl,key_repeat_ct  
6962				inc hl  
6962				call hexout  
6962				ld hl,key_repeat_ct+3  
6962				ld a,0  
6962				ld (hl),a  
6962				ld hl,key_repeat_ct  
6962				ld a, '2'	  
6962				ld (hl),a  
6962			  
6962			            LD   A, kLCD_Line4+15  
6962			            CALL fLCD_Pos       ;Position cursor to location in A  
6962			            LD   DE, key_repeat_ct  
6962			            ;LD   DE, MsgHello  
6962			            CALL fLCD_Str       ;Display string pointed to by DE  
6962			  
6962				pop af  
6962			endif  
6962 cd 6b 69			call .mtoc  
6965 c1				pop bc  
6966 b8				cp b  
6967 28 f8			jr z, .cina1  
6969 78				ld a,b		  
696a			if DEBUG_KEYCIN  
696a				push af  
696a			  
696a				ld hl,key_repeat_ct  
696a				inc hl  
696a				call hexout  
696a				ld hl,key_repeat_ct+3  
696a				ld a,0  
696a				ld (hl),a  
696a				ld hl,key_repeat_ct  
696a				ld a, '3'	  
696a				ld (hl),a  
696a			  
696a			            LD   A, kLCD_Line4+15  
696a			            CALL fLCD_Pos       ;Position cursor to location in A  
696a			            LD   DE, key_repeat_ct  
696a			            ;LD   DE, MsgHello  
696a			            CALL fLCD_Str       ;Display string pointed to by DE  
696a			  
696a				pop af  
696a			endif  
696a c9				ret  
696b			  
696b			; detect keyboard modifier key press and apply new overlay to the face key held  
696b			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
696b			  
696b			;.cin_map_modifier:   
696b			;	ld a, (hl)  
696b			;	and 255  
696b			;	ret NZ		; modifier key not flagged  
696b			;  
696b			;	; get key face  
696b			;  
696b			;	ld b,(key_face_held)  
696b			;  
696b			;	ld b, key_cols * key_rows  
696b			;  
696b			;	push de  
696b			;	pop hl  
696b			;  
696b			;.mmod1: ld a,(hl)   ; get map test  
696b			;	cp b  
696b			;	jr z, .mmod2  
696b			;  
696b			;  
696b			;  
696b			;.mmod2: inc hl    ;   
696b			;  
696b			;	  
696b			;  
696b			;	  
696b			;  
696b			;	ld hl,key_actual_pressed  
696b			;	ld (hl),a,  
696b			;	ret  
696b			  
696b			; map matrix key held to char on face of key  
696b			  
696b			.mtoc:  
696b			  
696b			; test decade counter strobes  
696b			  
696b			;.decadetest1:  
696b			  
696b			; reset counter  
696b			;ld a, 128  
696b			;out (portbdata),a  
696b			  
696b			  
696b			;ld b, 5  
696b			;.dec1:  
696b			;ld a, 0  
696b			;out (portbdata),a  
696b			;call delay1s  
696b			  
696b			;ld a, 32  
696b			;out (portbdata),a  
696b			;call delay1s  
696b			;call delay1s  
696b			;call delay1s  
696b			;  
696b			;ld a, 64+32  
696b			;out (portbdata),a  
696b			;call delay1s  
696b			;;djnz .dec1  
696b			;  
696b			;jp .decadetest1  
696b			  
696b			  
696b			  
696b			  
696b			  
696b			  
696b			  
696b			  
696b			  
696b			  
696b				; scan keyboard matrix and generate raw scan map  
696b cd fe 69			call matrix  
696e			  
696e				; reuse c bit 0 left modifer button - ie shift  
696e			        ; reuse c bit 1 for right modifer button - ie symbol shift  
696e				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
696e			  
696e 0e 00			ld c, 0  
6970			  
6970				; TODO set flags for modifer key presses   
6970				; TODO do a search for modifer key...  
6970			  
6970				;ld hl,keyscan_table_row4  
6970 21 e7 fb			ld hl,keyscan_table_row2  
6973			  
6973 7e				ld a, (hl)  
6974 fe 23			cp '#'  
6976 20 07			jr nz, .nextmodcheck  
6978 cb c1			set 0, c  
697a 21 d8 68			ld hl, .matrix_to_shift  
697d 18 21			jr .dokeymap  
697f				; TODO for now igonre  
697f			.nextmodcheck:  
697f 21 dc fb			ld hl,keyscan_table_row3  
6982			  
6982 7e				ld a, (hl)  
6983 fe 23			cp '#'  
6985 20 07			jr nz, .nextmodcheck2  
6987 cb c9			set 1, c   
6989 21 0f 69			ld hl, .matrix_to_symbolshift  
698c 18 12			jr .dokeymap  
698e			.nextmodcheck2:  
698e 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6991			  
6991 7e				ld a, (hl)  
6992 fe 23			cp '#'  
6994 20 07			jr nz, .donemodcheck  
6996 cb c9			set 1, c   
6998 21 d8 68			ld hl, .matrix_to_shift  
699b 18 03			jr .dokeymap  
699d			  
699d				; no modifer found so just map to normal keys  
699d				; get mtoc map matrix to respective keys  
699d			;	ld hl, .matrix_to_char  
699d			;	ld hl, .matrix_to_char  
699d			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
699d			;	ld a, KEY_SHIFT  
699d			;	call findchar  
699d			;  
699d			;	; got offset to key modifer in b  
699d			;  
699d			;	ld hl,keyscan_table_row5  
699d			;  
699d			;	ld a,b  
699d			;	call addatohl  
699d			;	ld a,(hl)  
699d			;  
699d			;	cp '#'  
699d			;	jr nz, .nextmodcheck  
699d			;	set 0, c  
699d			;	ld hl, .matrix_to_char  
699d			;	jr .dokeymap  
699d			;	; TODO for now igonre  
699d			;.nextmodcheck:  
699d			;	ld hl, .matrix_to_symbolshift  
699d			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
699d			;	ld a, KEY_SYMBOLSHIFT  
699d			;	call findchar  
699d			;  
699d			;  
699d			;	; got offset to key modifer in b  
699d			;  
699d			;	ld hl,keyscan_table_row5  
699d			;  
699d			;	ld a,b  
699d			;	call addatohl  
699d			;	ld a,(hl)  
699d			;  
699d			;	cp '#'  
699d			;	jr nz, .donemodcheck  
699d			;	set 1, c   
699d			;	ld hl, .matrix_to_symbolshift  
699d			;	jr .dokeymap  
699d			  
699d			  
699d			  
699d			.donemodcheck:  
699d				; no modifer found so just map to normal keys  
699d				; get mtoc map matrix to respective keys  
699d 21 a1 68			ld hl, .matrix_to_char  
69a0			  
69a0			.dokeymap:  
69a0				;ld (key_fa), c   
69a0 cd b9 69			call .mapkeys  
69a3			  
69a3			  
69a3			if DEBUG_KEY  
69a3			  
69a3			; Display text on first line  
69a3			            LD   A, kLCD_Line1  
69a3			            CALL fLCD_Pos       ;Position cursor to location in A  
69a3			            LD   DE, keyscan_table_row1  
69a3			            ;LD   DE, MsgHello  
69a3			            CALL fLCD_Str       ;Display string pointed to by DE  
69a3			  
69a3			; Display text on second line  
69a3			            LD   A, kLCD_Line2  
69a3			            CALL fLCD_Pos       ;Position cursor to location in A  
69a3			            LD   DE, keyscan_table_row2  
69a3			            CALL fLCD_Str       ;Display string pointed to by DE  
69a3			            LD   A, kLCD_Line3  
69a3			            CALL fLCD_Pos       ;Position cursor to location in A  
69a3			            LD   DE, keyscan_table_row3  
69a3			            CALL fLCD_Str       ;Display string pointed to by DE  
69a3			            LD   A, kLCD_Line4  
69a3			            CALL fLCD_Pos       ;Position cursor to location in A  
69a3			            LD   DE, keyscan_table_row4  
69a3			            CALL fLCD_Str       ;Display string pointed to by DE  
69a3			            LD   A, kLCD_Line1+10  
69a3			            CALL fLCD_Pos       ;Position cursor to location in A  
69a3			            LD   DE, keyscan_table_row5  
69a3			            CALL fLCD_Str       ;Display string pointed to by DE  
69a3			  
69a3				;call delay250ms  
69a3			endif  
69a3			;	jp testkey  
69a3			  
69a3			; get first char reported  
69a3			  
69a3 21 c6 fb			ld hl,keyscan_table_row5  
69a6			  
69a6				;ld b, 46   ; 30 keys to remap + 8 nulls   
69a6 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
69a8			.findkey:  
69a8 7e				ld a,(hl)  
69a9 fe 00			cp 0  
69ab 28 04			jr z, .nextkey  
69ad fe 7e			cp KEY_MATRIX_NO_PRESS  
69af 20 06			jr nz, .foundkey  
69b1			.nextkey:  
69b1 23				inc hl  
69b2 10 f4			djnz .findkey  
69b4 3e 00			ld a,0  
69b6 c9				ret  
69b7			.foundkey:  
69b7 7e				ld a,(hl)  
69b8 c9				ret  
69b9				  
69b9			  
69b9			; convert the raw key map given hl for destination key  
69b9			.mapkeys:  
69b9 11 c6 fb			ld de,keyscan_table_row5  
69bc			  
69bc 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
69be			.remap:  
69be 1a				ld a,(de)  
69bf fe 23			cp '#'  
69c1 20 02			jr nz, .remapnext  
69c3				;CALLMONITOR  
69c3 7e				ld a,(hl)  
69c4 12				ld (de),a  
69c5			  
69c5			  
69c5			  
69c5			.remapnext:  
69c5 23				inc hl  
69c6 13				inc de  
69c7 10 f5			djnz .remap  
69c9				  
69c9 c9				ret  
69ca			  
69ca			  
69ca			  
69ca			.mtocold2:  
69ca			  
69ca			;	; flag if key D is held down and remove from reporting  
69ca			;	ld bc, .key_map_fd    
69ca			;	ld hl, keyscan_table  
69ca			;	ld de, key_fd  
69ca			;	call .key_shift_hold  
69ca			;	cp 255  
69ca			;	jr z, .cinmap  
69ca			;	; flag if key C is held down and remove from reporting  
69ca			;	ld bc, .key_map_fc    
69ca			;	ld hl, keyscan_table+key_cols  
69ca			;	ld de, key_fc  
69ca			;	call .key_shift_hold  
69ca			;	cp 255  
69ca			;	jr z, .cinmap  
69ca			;	; flag if key B is held down and remove from reporting  
69ca			;	ld bc, .key_map_fb    
69ca			;	ld hl, keyscan_table+(key_cols*2)  
69ca			;	ld de, key_fb  
69ca			;	call .key_shift_hold  
69ca			;	cp 255  
69ca			;	jr z, .cinmap  
69ca			;	; flag if key A is held down and remove from reporting  
69ca			;	ld bc, .key_map_fa    
69ca			;	ld hl, keyscan_table+(key_cols*3)  
69ca			;	ld de, key_fa  
69ca			;	call .key_shift_hold  
69ca			;	cp 255  
69ca			;	jr z, .cinmap  
69ca			  
69ca 11 a1 68			ld de, .matrix_to_char  
69cd			  
69cd			  
69cd			.cinmap1:   
69cd				if DEBUG_KEY  
69cd			            LD   A, kLCD_Line4  
69cd			            CALL fLCD_Pos       ;Position cursor to location in A  
69cd					push de  
69cd			            LD   DE, keyscan_table  
69cd			            CALL fLCD_Str       ;Display string pointed to by DE  
69cd					pop de  
69cd				endif  
69cd			  
69cd				; scan key matrix table for any held key  
69cd			  
69cd				; de holds either the default matrix or one selected above  
69cd			  
69cd 21 93 fb			ld hl, keyscan_table  
69d0 06 32			ld b,key_cols*key_rows  
69d2			  
69d2 7e			.cin11:	ld a,(hl)  
69d3 fe 23			cp '#'  
69d5 28 08			jr z, .cinhit1  
69d7 23				inc hl  
69d8 13				inc de  
69d9 05				dec b  
69da 20 f6			jr nz, .cin11  
69dc				; no key found held  
69dc 3e 00			ld a,0  
69de c9				ret  
69df d5			.cinhit1: push de  
69e0 e1				pop hl  
69e1 7e				ld a,(hl)  
69e2 c9				ret  
69e3			  
69e3			; flag a control key is held   
69e3			; hl is key pin, de is flag indicator  
69e3			  
69e3			.key_shift_hold1:  
69e3 c5				push bc  
69e4 3e 01			ld a, 1  
69e6 32 c7 f8			ld (cursor_shape),a  
69e9 06 00			ld b, 0  
69eb 7e				ld a, (hl)  
69ec fe 2e			cp '.'  
69ee 28 0a			jr z, .key_shift11  
69f0 06 ff			ld b, 255  
69f2 3e 2b			ld a, '+'    ; hide key from later scans  
69f4 77				ld (hl),a  
69f5 3e 02			ld a, 2  
69f7 32 c7 f8			ld (cursor_shape),a  
69fa			.key_shift11:  
69fa				; write flag indicator  
69fa 78				ld a,b  
69fb 12				ld (de),a  
69fc			  
69fc d1				pop de    ; de now holds the key map ptr  
69fd c9				ret  
69fe			  
69fe				  
69fe			  
69fe			; scans keyboard matrix and flags key press in memory array	  
69fe				  
69fe			matrix:  
69fe				;call matrix  
69fe				; TODO optimise the code....  
69fe			  
69fe			  
69fe			;ld hl, keyscan_table_row1  
69fe			;ld de, keyscan_table_row1+1  
69fe			;ld bc,46  
69fe			;ld a,KEY_MATRIX_NO_PRESS  
69fe			;ldir  
69fe			  
69fe			  
69fe			  
69fe			; reset counter  
69fe 3e 80		ld a, 128  
6a00 d3 c1		out (portbdata),a  
6a02			  
6a02 06 0a		ld b, 10  
6a04 0e 00		ld c, 0       ; current clock toggle  
6a06			  
6a06			.colscan:  
6a06			  
6a06			; set current column  
6a06			; disable clock enable and set clock low  
6a06			  
6a06			;ld a, 0  
6a06			;out (portbdata),a  
6a06			  
6a06			; For each column scan for switches  
6a06			  
6a06 c5			push bc  
6a07 21 89 fb		ld hl, keyscan_scancol  
6a0a cd 13 6b		call .rowscan  
6a0d c1			pop bc  
6a0e			  
6a0e			  
6a0e			; get back current column  
6a0e			  
6a0e			; translate the row scan  
6a0e			  
6a0e			;   
6a0e			; row 1  
6a0e			  
6a0e 78			ld a,b  
6a0f			  
6a0f 21 fc fb		LD   hl, keyscan_table_row1+10  
6a12			  
6a12 cd 2d 0d		call subafromhl  
6a15			;call addatohl  
6a15			  
6a15 11 89 fb		ld de, keyscan_scancol  
6a18			  
6a18 1a			ld a,(de)  
6a19 77			ld (hl),a  
6a1a			  
6a1a			  
6a1a			  
6a1a			  
6a1a			; row 2  
6a1a			  
6a1a 78			ld a,b  
6a1b			  
6a1b 21 f1 fb		LD   hl, keyscan_table_row2+10  
6a1e			  
6a1e			;call addatohl  
6a1e cd 2d 0d		call subafromhl  
6a21			  
6a21			  
6a21 11 8a fb		ld de, keyscan_scancol+1  
6a24			  
6a24 1a			ld a,(de)  
6a25 77			ld (hl),a  
6a26			  
6a26			  
6a26			; row 3  
6a26			  
6a26 78			ld a,b  
6a27			  
6a27 21 e6 fb		LD   hl, keyscan_table_row3+10  
6a2a			  
6a2a			;call addatohl  
6a2a cd 2d 0d		call subafromhl  
6a2d			  
6a2d 11 8b fb		ld de, keyscan_scancol+2  
6a30			  
6a30 1a			ld a,(de)  
6a31 77			ld (hl),a  
6a32			  
6a32			  
6a32			  
6a32			; row 4  
6a32			  
6a32 78			ld a,b  
6a33			  
6a33 21 db fb		LD   hl, keyscan_table_row4+10  
6a36			  
6a36			;call addatohl  
6a36 cd 2d 0d		call subafromhl  
6a39			  
6a39 11 8c fb		ld de, keyscan_scancol+3  
6a3c			  
6a3c 1a			ld a,(de)  
6a3d 77			ld (hl),a  
6a3e			  
6a3e			; row 5  
6a3e			  
6a3e 78			ld a,b  
6a3f			  
6a3f 21 d0 fb		LD   hl, keyscan_table_row5+10  
6a42			  
6a42			;call addatohl  
6a42 cd 2d 0d		call subafromhl  
6a45			  
6a45 11 8d fb		ld de, keyscan_scancol+4  
6a48			  
6a48 1a			ld a,(de)  
6a49 77			ld (hl),a  
6a4a			  
6a4a			; handshake next column  
6a4a			  
6a4a			  
6a4a 3e 40		ld a, 64  
6a4c d3 c1		out (portbdata),a  
6a4e			  
6a4e 3e 00		ld a, 0  
6a50 d3 c1		out (portbdata),a  
6a52			  
6a52			; toggle clk and move to next column  
6a52			;ld a, 64  
6a52			;cp c  
6a52			;  
6a52			;jr z, .coltoglow  
6a52			;ld c, a  
6a52			;jr .coltog  
6a52			;.coltoglow:  
6a52			;ld c, 0  
6a52			;.coltog:  
6a52			;ld a, c  
6a52			;out (portbdata),a  
6a52			  
6a52 10 b2		djnz .colscan  
6a54			  
6a54 3e 0a		ld a,10  
6a56 21 f2 fb		LD   hl, keyscan_table_row1  
6a59 cd 1b 0d		call addatohl  
6a5c 3e 00		ld a, 0  
6a5e 77			ld (hl), a  
6a5f			  
6a5f			  
6a5f 3e 0a		ld a,10  
6a61 21 e7 fb		LD   hl, keyscan_table_row2  
6a64 cd 1b 0d		call addatohl  
6a67 3e 00		ld a, 0  
6a69 77			ld (hl), a  
6a6a			  
6a6a 3e 0a		ld a,10  
6a6c 21 dc fb		LD   hl, keyscan_table_row3  
6a6f cd 1b 0d		call addatohl  
6a72 3e 00		ld a, 0  
6a74 77			ld (hl), a  
6a75			  
6a75 3e 0a		ld a,10  
6a77 21 d1 fb		LD   hl, keyscan_table_row4  
6a7a cd 1b 0d		call addatohl  
6a7d 3e 00		ld a, 0  
6a7f 77			ld (hl), a  
6a80			  
6a80 3e 0a		ld a,10  
6a82 21 c6 fb		LD   hl, keyscan_table_row5  
6a85 cd 1b 0d		call addatohl  
6a88 3e 00		ld a, 0  
6a8a 77			ld (hl), a  
6a8b			  
6a8b			if DEBUG_KEY_MATRIX  
6a8b			  
6a8b			; Display text on first line  
6a8b			            LD   A, kLCD_Line1  
6a8b			            CALL fLCD_Pos       ;Position cursor to location in A  
6a8b			            LD   DE, keyscan_table_row1  
6a8b			            ;LD   DE, MsgHello  
6a8b			            CALL fLCD_Str       ;Display string pointed to by DE  
6a8b			  
6a8b			; Display text on second line  
6a8b			            LD   A, kLCD_Line2  
6a8b			            CALL fLCD_Pos       ;Position cursor to location in A  
6a8b			            LD   DE, keyscan_table_row2  
6a8b			            CALL fLCD_Str       ;Display string pointed to by DE  
6a8b			            LD   A, kLCD_Line3  
6a8b			            CALL fLCD_Pos       ;Position cursor to location in A  
6a8b			            LD   DE, keyscan_table_row3  
6a8b			            CALL fLCD_Str       ;Display string pointed to by DE  
6a8b			            LD   A, kLCD_Line4  
6a8b			            CALL fLCD_Pos       ;Position cursor to location in A  
6a8b			            LD   DE, keyscan_table_row4  
6a8b			            CALL fLCD_Str       ;Display string pointed to by DE  
6a8b			            LD   A, kLCD_Line4+10  
6a8b			            CALL fLCD_Pos       ;Position cursor to location in A  
6a8b			            LD   DE, keyscan_table_row5  
6a8b			            CALL fLCD_Str       ;Display string pointed to by DE  
6a8b			  
6a8b			;call delay250ms  
6a8b				jp matrix  
6a8b			endif  
6a8b c9			ret  
6a8c			  
6a8c			; using decade counter....  
6a8c			  
6a8c			  
6a8c			; TODO reset decade counter to start of scan  
6a8c			  
6a8c			; reset 15  
6a8c			; clock 14  
6a8c			; ce 13  
6a8c			  
6a8c			; 1 - q5  
6a8c			; 2 - q1  
6a8c			; 3 - q0  
6a8c			; 4 - q2  
6a8c			; 5 - q6  
6a8c			; 6 - q7  
6a8c			; 7 - q3  
6a8c			; 8 - vss  
6a8c			; 9 - q8  
6a8c			; 10 - q4  
6a8c			; 11 - q9  
6a8c			; 12 - cout  
6a8c			; 16 - vdd  
6a8c			  
6a8c			; clock      ce       reset     output  
6a8c			; 0          x        0         n  
6a8c			; x          1        0         n  
6a8c			; x          x        1         q0  
6a8c			; rising     0        0         n+1  
6a8c			; falling    x        0         n  
6a8c			; x          rising   0         n  
6a8c			; 1          falling  0         x+1  
6a8c			;  
6a8c			; x = dont care, if n < 5 carry = 1 otherwise 0  
6a8c			  
6a8c			;   
6a8c			; reset   
6a8c			; 13=0, 14=0, 15=1 .. 15=0  
6a8c			;  
6a8c			; handshake line  
6a8c			; 14=1.... read line 14=0  
6a8c			  
6a8c			  
6a8c			  
6a8c			  
6a8c			  
6a8c			; TODO hand shake clock for next column scan  
6a8c			; TODO detect each row  
6a8c			  
6a8c			  
6a8c			  
6a8c			  
6a8c			; reset 128  
6a8c			; clock 64  
6a8c			; ce 32  
6a8c			  
6a8c			  
6a8c			.cyclestart:  
6a8c			  
6a8c			; reset counter  
6a8c 3e 80		ld a, 128  
6a8e d3 c1		out (portbdata),a  
6a90			  
6a90			; loop leds  
6a90 06 0a		ld b,10  
6a92			  
6a92			.cycle1:  
6a92 c5			push bc  
6a93 3e 00		ld a, 0  
6a95 d3 c1		out (portbdata),a  
6a97 cd 58 0a		call delay250ms  
6a9a			  
6a9a 3e 40		ld a, 64  
6a9c d3 c1		out (portbdata),a  
6a9e cd 58 0a		call delay250ms  
6aa1			  
6aa1 3e 00		ld a, 0  
6aa3 d3 c1		out (portbdata),a  
6aa5 cd 58 0a		call delay250ms  
6aa8			  
6aa8 c1			pop bc  
6aa9 10 e7		djnz .cycle1  
6aab			  
6aab			  
6aab 18 df		jr .cyclestart  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			; map matrix key held to char on face of key  
6aad			  
6aad			;.mtocold:  
6aad			;  
6aad			;  
6aad			;; reset counter  
6aad			;ld a, 128  
6aad			;out (portbdata),a  
6aad			;  
6aad			;  
6aad			;; scan keyboard row 1  
6aad			;ld a, 0  
6aad			;out (portbdata),a  
6aad			;;ld a, 64  
6aad			;;out (portbdata),a  
6aad			;  
6aad			;  
6aad			;	ld a, 128  
6aad			;	ld hl, keyscan_table  
6aad			;	call .rowscan  
6aad			;  
6aad			;;ld a, 0  
6aad			;;out (portbdata),a  
6aad			;ld a, 64  
6aad			;out (portbdata),a  
6aad			;  
6aad			;	ld a, 64  
6aad			;	ld hl, keyscan_table+key_cols  
6aad			;	call .rowscan  
6aad			;  
6aad			;ld a, 0  
6aad			;out (portbdata),a  
6aad			;;ld a, 64  
6aad			;;out (portbdata),a  
6aad			;	ld a, 32  
6aad			;	ld hl, keyscan_table+(key_cols*2)  
6aad			;	call .rowscan  
6aad			;  
6aad			;  
6aad			;;ld a, 0  
6aad			;;out (portbdata),a  
6aad			;ld a, 64  
6aad			;out (portbdata),a  
6aad			;  
6aad			;	ld a, 16  
6aad			;	ld hl, keyscan_table+(key_cols*3)  
6aad			;	call .rowscan  
6aad			;  
6aad			;  
6aad			;	; flag if key D is held down and remove from reporting  
6aad			;	ld bc, .key_map_fd    
6aad			;	ld hl, keyscan_table  
6aad			;	ld de, key_fd  
6aad			;	call .key_shift_hold  
6aad			;	cp 255  
6aad			;	jr z, .cinmap  
6aad			;	; flag if key C is held down and remove from reporting  
6aad			;	ld bc, .key_map_fc    
6aad			;	ld hl, keyscan_table+key_cols  
6aad			;	ld de, key_fc  
6aad			;	call .key_shift_hold  
6aad			;	cp 255  
6aad			;	jr z, .cinmap  
6aad			;	; flag if key B is held down and remove from reporting  
6aad			;	ld bc, .key_map_fb    
6aad			;	ld hl, keyscan_table+(key_cols*2)  
6aad			;	ld de, key_fb  
6aad			;	call .key_shift_hold  
6aad			;	cp 255  
6aad			;	jr z, .cinmap  
6aad			;	; flag if key A is held down and remove from reporting  
6aad			;	ld bc, .key_map_fa    
6aad			;	ld hl, keyscan_table+(key_cols*3)  
6aad			;	ld de, key_fa  
6aad			;	call .key_shift_hold  
6aad			;	cp 255  
6aad			;	jr z, .cinmap  
6aad			;  
6aad			;	ld de, .matrix_to_char  
6aad			;  
6aad			;  
6aad			;.cinmap:   
6aad			;	if DEBUG_KEY  
6aad			;            LD   A, kLCD_Line4  
6aad			;            CALL fLCD_Pos       ;Position cursor to location in A  
6aad			;		push de  
6aad			;            LD   DE, keyscan_table  
6aad			;            CALL fLCD_Str       ;Display string pointed to by DE  
6aad			;		pop de  
6aad			;	endif  
6aad			  
6aad				; scan key matrix table for any held key  
6aad			  
6aad				; de holds either the default matrix or one selected above  
6aad			  
6aad			;	ld hl, keyscan_table  
6aad			;	ld b,key_cols*key_rows  
6aad			;  
6aad			;.cin1:	ld a,(hl)  
6aad			;	cp '#'  
6aad			;	jr z, .cinhit  
6aad			;	inc hl  
6aad			;	inc de  
6aad			;	dec b  
6aad			;	jr nz, .cin1  
6aad			;	; no key found held  
6aad			;	ld a,0  
6aad			;	ret  
6aad			;.cinhit: push de  
6aad			;	pop hl  
6aad			;	ld a,(hl)  
6aad			;	ret  
6aad			  
6aad			; flag a control key is held   
6aad			; hl is key pin, de is flag indicator  
6aad			  
6aad			;.key_shift_hold:  
6aad			;	push bc  
6aad			;	ld a, 1  
6aad			;	ld (cursor_shape),a  
6aad			;	ld b, 0  
6aad			;	ld a, (hl)  
6aad			;	cp '.'  
6aad			;	jr z, .key_shift1  
6aad			;	ld b, 255  
6aad			;	ld a, '+'    ; hide key from later scans  
6aad			;	ld (hl),a  
6aad			;	ld a, 2  
6aad			;	ld (cursor_shape),a  
6aad			;.key_shift1:  
6aad			;	; write flag indicator  
6aad			;	ld a,b  
6aad			;	ld (de),a  
6aad			;  
6aad			;	pop de    ; de now holds the key map ptr  
6aad			;	ret  
6aad			  
6aad				  
6aad				  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			;	push hl  
6aad			;	push de  
6aad			;	push bc  
6aad			;	call keyscan  
6aad			;	; map key matrix to ascii value of key face  
6aad			;  
6aad			;	ld hl, key_face_map  
6aad			;	ld de, keyscan_table  
6aad			;  
6aad			;	; get how many keys to look at  
6aad			;	ld b, keyscan_table_len  
6aad			;	  
6aad			;  
6aad			;	; at this stage fall out on first key hit  
6aad			;	; TODO handle multiple key press  
6aad			;  
6aad			;map1:	ld a,(hl)  
6aad			;	cp '#'  
6aad			;	jr z, keyhit  
6aad			;	inc hl  
6aad			;	inc de  
6aad			;	dec b  
6aad			;	jr nz, map1  
6aad			;nohit:	ld a, 0  
6aad			;	jr keydone  
6aad			;keyhit: push de  
6aad			;	pop hl  
6aad			;	ld a,(hl)  
6aad			;keydone:  
6aad			;	push bc  
6aad			;	push de  
6aad			; 	push hl  
6aad			;	ret   
6aad			;  
6aad			  
6aad			  
6aad			  
6aad			  
6aad			; scan physical key matrix  
6aad			  
6aad			  
6aad			;keyscan:  
6aad			;  
6aad			;; for each key_row use keyscanr bit mask for out  
6aad			;; then read in for keyscanc bitmask  
6aad			;; save result of row scan to keyscantable  
6aad			;  
6aad			;; scan keyboard row 1  
6aad			;  
6aad			;	ld b, key_rows  
6aad			;	ld hl, key_scanr  
6aad			;	ld de, keyscan_table  
6aad			;  
6aad			;rowloop:  
6aad			;  
6aad			;	ld a,(hl)		; out bit mask to energise keyboard row  
6aad			;	call rowscan  
6aad			;	inc hl  
6aad			;	dec b  
6aad			;	jr nz, rowloop  
6aad			;  
6aad			;	ret  
6aad			;  
6aad			;  
6aad			;; pass a out bitmask, b row number  
6aad			;arowscan:   
6aad			;	push bc  
6aad			;  
6aad			;	ld d, b  
6aad			;  
6aad			;	; calculate buffer location for this row  
6aad			;  
6aad			;	ld hl, keyscan_table	  
6aad			;kbufr:  ld e, key_cols  
6aad			;kbufc:	inc hl  
6aad			;	dec e  
6aad			;	jr nz, kbufc  
6aad			;	dec d  
6aad			;	jr nz, kbufr  
6aad			;  
6aad			;	; energise row and read columns  
6aad			;  
6aad			;	out (portbdata),a  
6aad			;	in a,(portbdata)  
6aad			;	ld c,a  
6aad			;  
6aad			;  
6aad			;	; save buffer loc  
6aad			;  
6aad			;	ld (keybufptr), hl  
6aad			;  
6aad			;	ld hl, key_scanc  
6aad			;	ld d, key_cols  
6aad			;  
6aad			;	; for each column check each bit mask  
6aad			;  
6aad			;colloop:  
6aad			;	  
6aad			;  
6aad			;	; reset flags for the row   
6aad			;  
6aad			;	ld b,'.'  
6aad			;	and (hl)  
6aad			;	jr z, maskskip  
6aad			;	ld b,'#'  
6aad			;maskskip:  
6aad			;	; save  key state  
6aad			;	push hl  
6aad			;	ld hl, (keybufptr)  
6aad			;	ld (hl), b  
6aad			;	inc hl  
6aad			;	ld (keybufptr), hl  
6aad			;  
6aad			;	; move to next bit mask  
6aad			;	pop hl  
6aad			;	inc hl  
6aad			;  
6aad			;	dec d  
6aad			;	jr nz, colloop  
6aad			;  
6aad			;	ret  
6aad			;  
6aad			;  
6aad			;;  
6aad			; lcd functions  
6aad			;  
6aad			;  
6aad			  
6aad			;if DEBUG_KEY_MATRIX  
6aad			  
6aad			; test function to display hardware view of matrix state  
6aad			  
6aad			matrixold:  
6aad			  
6aad			  
6aad			  
6aad			; reset counter  
6aad 3e 80		ld a, 128  
6aaf d3 c1		out (portbdata),a  
6ab1			; scan keyboard row 1  
6ab1 3e 00		ld a, 0  
6ab3 d3 c1		out (portbdata),a  
6ab5			;ld a, 64  
6ab5			;out (portbdata),a  
6ab5 3e 80			ld a, 128  
6ab7 21 f2 fb			ld hl, keyscan_table_row1  
6aba cd 13 6b			call .rowscan  
6abd			  
6abd			;ld a, 0  
6abd			;out (portbdata),a  
6abd 3e 40		ld a, 64  
6abf d3 c1		out (portbdata),a  
6ac1 3e 40			ld a, 64  
6ac3 21 e7 fb			ld hl, keyscan_table_row2  
6ac6 cd 13 6b			call .rowscan  
6ac9			  
6ac9 3e 00		ld a, 0  
6acb d3 c1		out (portbdata),a  
6acd			;ld a, 64  
6acd			;out (portbdata),a  
6acd 3e 20			ld a, 32  
6acf 21 dc fb			ld hl, keyscan_table_row3  
6ad2 cd 13 6b			call .rowscan  
6ad5			  
6ad5			;ld a, 0  
6ad5			;out (portbdata),a  
6ad5 3e 40		ld a, 64  
6ad7 d3 c1		out (portbdata),a  
6ad9 3e 10			ld a, 16  
6adb 21 d1 fb			ld hl, keyscan_table_row4  
6ade cd 13 6b			call .rowscan  
6ae1			  
6ae1			; Display text on first line  
6ae1 3e 00		            LD   A, kLCD_Line1  
6ae3 cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6ae6 11 f2 fb		            LD   DE, keyscan_table_row1  
6ae9			            ;LD   DE, MsgHello  
6ae9 cd 3d 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6aec			  
6aec			; Display text on second line  
6aec 3e 28		            LD   A, kLCD_Line2  
6aee cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6af1 11 e7 fb		            LD   DE, keyscan_table_row2  
6af4 cd 3d 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6af7 3e 50		            LD   A, kLCD_Line3  
6af9 cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6afc 11 dc fb		            LD   DE, keyscan_table_row3  
6aff cd 3d 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b02 3e 78		            LD   A, kLCD_Line4  
6b04 cd 1b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6b07 11 d1 fb		            LD   DE, keyscan_table_row4  
6b0a cd 3d 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b0d			  
6b0d cd 58 0a			call delay250ms  
6b10 c3 fe 69			jp matrix  
6b13			  
6b13			; pass de as row display flags  
6b13			.rowscan:   
6b13			;	out (portbdata),a  
6b13 db c1			in a,(portbdata)  
6b15 4f				ld c,a  
6b16				; reset flags for the row   
6b16 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b18 e6 01			and 1  
6b1a 28 02			jr z, .p1on  
6b1c 06 23			ld b,'#'  
6b1e			.p1on:  
6b1e 70				ld (hl), b  
6b1f 23				inc hl  
6b20			  
6b20 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b22 79				ld a,c  
6b23 e6 02			and 2  
6b25			;	bit 0,a  
6b25 28 02			jr z, .p2on  
6b27 06 23			ld b,'#'  
6b29			.p2on:  
6b29 70				ld (hl), b  
6b2a 23				inc hl  
6b2b			;  
6b2b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b2d 79				ld a,c  
6b2e e6 04			and 4  
6b30			;;	bit 0,a  
6b30 28 02			jr z, .p3on  
6b32 06 23			ld b,'#'  
6b34			.p3on:  
6b34 70				ld (hl), b  
6b35 23				inc hl  
6b36			;;  
6b36 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b38			;;	bit 0,a  
6b38 79				ld a,c  
6b39 e6 08			and 8  
6b3b 28 02			jr z, .p4on  
6b3d 06 23			ld b,'#'  
6b3f			.p4on:  
6b3f 70				ld (hl), b  
6b40 23				inc hl  
6b41			  
6b41 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b43			;;	bit 0,a  
6b43 79				ld a,c  
6b44 e6 10			and 16  
6b46 28 02			jr z, .p5on  
6b48 06 23			ld b,'#'  
6b4a			.p5on:  
6b4a 70				ld (hl), b  
6b4b 23				inc hl  
6b4c			; zero term  
6b4c 06 00			ld b,0  
6b4e 70				ld (hl), b  
6b4f			  
6b4f c9			.rscandone: ret  
6b50			  
6b50			;addatohl:  
6b50			;  
6b50			 ;add   a, l    ; A = A+L  
6b50			  ;  ld    l, a    ; L = A+L  
6b50			   ; adc   a, h    ; A = A+L+H+carry  
6b50			   ; sub   l       ; A = H+carry  
6b50			   ; ld    h, a    ; H = H+carry  
6b50			  
6b50			;ret  
6b50			; eof  
# End of file firmware_key_5x10.asm
6b50			;include "firmware_key_4x10.asm" 
6b50			 
6b50			heap_size:    equ heap_end - heap_start 
6b50			;eof 
# End of file os_mega.asm
6b50
