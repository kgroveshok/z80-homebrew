# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 46 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 offsets for settings  
8003			  
8003			; if set then skip prompt for start up and accept all  
8003			  
8003			STORE_0_QUICKSTART: equ $25  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
8003			  
8003			hardware_config: equ key_face_held - 10  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_config - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003				  
8003			  
8003					;ld a, 0  
8003					;ld (hardware_diag), a  
8003			  
8003					; clear all the buffers  
8003			  
8003 21 fc ed				ld hl, display_fb1  
8006 22 58 ed				ld (display_fb_active), hl  
8009			  
8009 cd 75 88				call clear_display  
800c			  
800c 21 5a ed				ld hl, display_fb2  
800f 22 58 ed				ld (display_fb_active), hl  
8012			  
8012 cd 75 88				call clear_display  
8015			  
8015					; init primary frame buffer area  
8015 21 4d ee				ld hl, display_fb0  
8018 22 58 ed				ld (display_fb_active), hl  
801b			  
801b cd 75 88				call clear_display  
801e			  
801e			  
801e cd 2b d7				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8021			  
8021 cd cd d7			call key_init  
8024 cd 86 80			call storage_init  
8027			  
8027				; setup malloc functions  
8027			  
8027				if MALLOC_1  
8027 cd 45 8f				call  heap_init  
802a				endif  
802a				if MALLOC_4  
802a					call  heap_init  
802a				endif  
802a			  
802a				; init sound hardware if present  
802a			  
802a				if SOUND_ENABLE  
802a					call sound_init  
802a				endif  
802a			  
802a				; lcd test sequence  
802a					  
802a cd 98 88			call update_display  
802d cd f2 87			call delay1s  
8030 3e 2b			ld a,'+'  
8032 cd 7a 88			call fill_display  
8035 cd 98 88			call update_display  
8038 cd f2 87			call delay1s  
803b 3e 2a			ld a,'*'  
803d cd 7a 88			call fill_display  
8040 cd 98 88			call update_display  
8043 cd f2 87			call delay1s  
8046 3e 2d			ld a,'-'  
8048 cd 7a 88			call fill_display  
804b cd 98 88			call update_display  
804e cd f2 87			call delay1s  
8051			  
8051			; boot splash screen  
8051			if display_cols == 20	  
8051 3e 00		        ld a, display_row_1    
8053			else  
8053			        ld a, display_row_1 +10   
8053			endif  
8053 11 79 94			ld de, prom_bootmsg  
8056 cd 88 88			call str_at_display  
8059 cd 98 88			call update_display  
805c			  
805c			  
805c cd f2 87			call delay1s  
805f cd f2 87			call delay1s  
8062			if display_cols == 20	  
8062 3e 2a		            LD   A, display_row_3+2  
8064			else  
8064			            LD   A, display_row_3+12  
8064			endif  
8064 11 8e 94			ld de, prom_bootmsg1  
8067 cd 88 88			call str_at_display  
806a cd 98 88			call update_display  
806d cd f2 87			call delay1s  
8070 cd f2 87			call delay1s  
8073			  
8073			;	ld a, display_row_4+3  
8073			;	ld de, bootmsg2  
8073			;	call str_at_display  
8073			;	call update_display  
8073			;	call delay1s  
8073			;	call delay1s  
8073			  
8073			; debug mark setup  
8073			  
8073 3e 5f		ld a, '_'  
8075 32 b7 ee		ld (debug_mark),a  
8078 32 b8 ee		ld (debug_mark+1),a  
807b 32 b9 ee		ld (debug_mark+2),a  
807e 3e 00		ld a,0  
8080 32 ba ee		ld (debug_mark+3),a  
8083			  
8083 c9					ret  
8084			  
8084			  
8084			;bootmsg2:	db "Firmware v0.1",0  
8084			  
8084			; a 4x20 lcd  
8084			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
8084			  
8084			;if display_cols == 20  
8084			;	include "firmware_lcd_4x20.asm"  
8084			;endif  
8084			  
8084			;if display_cols == 40  
8084			;	include "firmware_lcd_4x40.asm"  
8084			;endif  
8084			  
8084			;  
8084			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
8084			; TODO abstract the bit bang video out interface for dual display  
8084			; TODO wire video out to tx pin on rc2014 bus  
8084			  
8084			; must supply cin, and cin_wait for low level hardware abstraction   
8084			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
8084			; test scancode  
8084			  
8084			;;;;;  
8084			;;;  
8084			; Moved out to mini and maxi versions  
8084			;  
8084			; include "firmware_key_4x4.asm"  
8084			; using existing 4 wire x 4 resistor array for input  
8084			;include "firmware_key_4x10.asm"  
8084			; need to mod the board for 5 rows due to resistor array  
8084			;include "firmware_key_5x10.asm"  
8084			  
8084			; storage hardware interface  
8084			  
8084			; use microchip serial eeprom for storage  
8084			  
8084			  
8084			if STORAGE_SE  
8084				include "firmware_spi.asm"  
8084				include "firmware_seeprom.asm"  
8084			else  
8084			   ; create some stubs for the labels  
8084 c9			se_readbyte: ret  
8085 c9			se_writebyte: ret  
8086 c9			storage_init: ret  
8087			  
8087			endif  
8087			  
8087			; use cf card for storage - throwing timeout errors. Hardware or software?????  
8087			;include "firmware_cf.asm"  
8087			  
8087			; load up high level storage hardward abstractions  
8087			include "firmware_storage.asm"  
8087			 
8087			; persisent storage hardware abstraction layer  
8087			 
8087			 
8087			 
8087			; Block 0 on storage is a config state 
8087			 
8087			 
8087			 
8087			; TODO add read phy block and write phy block functions 
8087			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
8087			 
8087			; Abstraction layer  
8087			 
8087			; Logocial block size is same size as physical size - using tape concept 
8087			 
8087			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
8087			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
8087			 
8087			 
8087			 
8087			; Filesystem layout (Logical layout) 
8087			; 
8087			; Block 0 - Bank config  
8087			; 
8087			;      Byte - 0 file id counter 
8087			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8087			;      Byte - 3-20 zero terminated bank label 
8087			; 
8087			; Block 1 > File storage 
8087			; 
8087			;      Byte 0 file id    - block 0 file details 
8087			;      Byte 1 block id - block 0 is file  
8087			;            Byte 2-15 - File name 
8087			; 
8087			;       - to end of block data 
8087			; 
8087			 
8087			 
8087			; Read Block 
8087			; ---------- 
8087			; 
8087			; With current bank 
8087			;  
8087			; Get block number to read 
8087			; Load physical blocks starting at start block into buffer 
8087			 
8087			; de points to buffer to use 
8087			; hl holds logical block number  
8087			 
8087			storage_read_block: 
8087			 
8087				; TODO bank selection 
8087			 
8087				; for each of the physical blocks read it into the buffer 
8087 06 40			ld b, STORE_BLOCK_PHY 
8089			 
8089				if DEBUG_STORESE 
8089 d5					push de 
808a				endif 
808a				 
808a			.rl1:    
808a			 
808a				; read physical block at hl into de 
808a			        ; increment hl and de to next read position on exit 
808a			 
808a e5				push hl 
808b d5				push de	 
808c c5				push bc 
808d			;	if DEBUG_STORESE 
808d			;		push af 
808d			;		ld a, 'R' 
808d			;		ld (debug_mark),a 
808d			;		pop af 
808d			;		CALLMONITOR 
808d			;	endif 
808d cd 84 80			call se_readbyte 
8090			;	if DEBUG_STORESE 
8090			;		ld a,(spi_portbyte) 
8090			;		ld l, a 
8090			;		push af 
8090			;		ld a, '1' 
8090			;		ld (debug_mark),a 
8090			;		pop af 
8090			;		CALLMONITOR 
8090			;	endif 
8090 c1				pop bc 
8091 d1				pop de 
8092 e1				pop hl 
8093 12				ld (de),a 
8094 23				inc hl 
8095 13				inc de 
8096			 
8096			;	if DEBUG_STORESE 
8096			;		push af 
8096			;		ld a, 'r' 
8096			;		ld (debug_mark),a 
8096			;		pop af 
8096			;		CALLMONITOR 
8096			;	endif 
8096			 
8096 10 f2			djnz .rl1 
8098			 
8098				if DEBUG_STORESE 
8098					DMARK "SRB" 
8098 f5				push af  
8099 3a ad 80			ld a, (.dmark)  
809c 32 b7 ee			ld (debug_mark),a  
809f 3a ae 80			ld a, (.dmark+1)  
80a2 32 b8 ee			ld (debug_mark+1),a  
80a5 3a af 80			ld a, (.dmark+2)  
80a8 32 b9 ee			ld (debug_mark+2),a  
80ab 18 03			jr .pastdmark  
80ad ..			.dmark: db "SRB"  
80b0 f1			.pastdmark: pop af  
80b1			endm  
# End of macro DMARK
80b1 d1					pop de 
80b2			; 
80b2			;		push af 
80b2			;		ld a, 'R' 
80b2			;		ld (debug_mark),a 
80b2			;		pop af 
80b2					CALLMONITOR 
80b2 cd a3 92			call break_point_state  
80b5				endm  
# End of macro CALLMONITOR
80b5				endif 
80b5 c9				ret	 
80b6				 
80b6			 
80b6			; File Size 
80b6			; --------- 
80b6			; 
80b6			;   hl file id 
80b6			; 
80b6			;  returns in hl the number of blocks 
80b6			 
80b6			storage_file_size: 
80b6 5d				ld e, l 
80b7 16 00			ld d, 0 
80b9 21 40 00			ld hl, STORE_BLOCK_PHY 
80bc					if DEBUG_FORTH_WORDS 
80bc						DMARK "SIZ" 
80bc f5				push af  
80bd 3a d1 80			ld a, (.dmark)  
80c0 32 b7 ee			ld (debug_mark),a  
80c3 3a d2 80			ld a, (.dmark+1)  
80c6 32 b8 ee			ld (debug_mark+1),a  
80c9 3a d3 80			ld a, (.dmark+2)  
80cc 32 b9 ee			ld (debug_mark+2),a  
80cf 18 03			jr .pastdmark  
80d1 ..			.dmark: db "SIZ"  
80d4 f1			.pastdmark: pop af  
80d5			endm  
# End of macro DMARK
80d5						CALLMONITOR 
80d5 cd a3 92			call break_point_state  
80d8				endm  
# End of macro CALLMONITOR
80d8					endif 
80d8 cd ba 83			call storage_findnextid 
80db			 
80db cd cb 8a			call ishlzero 
80de			;	ld a, l 
80de			;	add h 
80de			;	cp 0 
80de c8				ret z			; block not found so EOF 
80df			 
80df 11 e2 ec			ld de, store_page 
80e2 cd 87 80			call storage_read_block 
80e5			 
80e5 3a e4 ec			ld a, (store_page+2)	 ; get extent count 
80e8 6f				ld l, a 
80e9 26 00			ld h, 0 
80eb c9			 	ret 
80ec			 
80ec			 
80ec			; Write Block 
80ec			; ----------- 
80ec			; 
80ec			; With current bank 
80ec			;  
80ec			; Get block number to write 
80ec			; Write physical blocks starting at start block from buffer 
80ec			  
80ec			storage_write_block: 
80ec				; TODO bank selection 
80ec			 
80ec				; for each of the physical blocks read it into the buffer 
80ec 06 40			ld b, STORE_BLOCK_PHY 
80ee			 
80ee				if DEBUG_STORESE 
80ee					DMARK "SWB" 
80ee f5				push af  
80ef 3a 03 81			ld a, (.dmark)  
80f2 32 b7 ee			ld (debug_mark),a  
80f5 3a 04 81			ld a, (.dmark+1)  
80f8 32 b8 ee			ld (debug_mark+1),a  
80fb 3a 05 81			ld a, (.dmark+2)  
80fe 32 b9 ee			ld (debug_mark+2),a  
8101 18 03			jr .pastdmark  
8103 ..			.dmark: db "SWB"  
8106 f1			.pastdmark: pop af  
8107			endm  
# End of macro DMARK
8107			 
8107					;push af 
8107					;ld a, 'W' 
8107					;ld (debug_mark),a 
8107					;pop af 
8107					CALLMONITOR 
8107 cd a3 92			call break_point_state  
810a				endm  
# End of macro CALLMONITOR
810a				endif 
810a			 
810a			; might not be working 
810a			;	call se_writepage 
810a			 
810a			;	ret 
810a			; 
810a			 
810a			 
810a			 
810a			.wl1:    
810a			 
810a				; read physical block at hl into de 
810a			        ; increment hl and de to next read position on exit 
810a			 
810a e5				push hl 
810b d5				push de	 
810c c5				push bc 
810d 1a				ld a,(de) 
810e				;if DEBUG_STORESE 
810e			;		push af 
810e			;		ld a, 'W' 
810e			;		ld (debug_mark),a 
810e			;		pop af 
810e			;		CALLMONITOR 
810e			;	endif 
810e cd 85 80			call se_writebyte 
8111			;	call delay250ms 
8111 00				nop 
8112 00				nop 
8113 00				nop 
8114			;	if DEBUG_STORESE 
8114			;		push af 
8114			;		ld a, 'w' 
8114			;		ld (debug_mark),a 
8114			;		pop af 
8114			;		CALLMONITOR 
8114			;	endif 
8114 c1				pop bc 
8115 d1				pop de 
8116 e1				pop hl 
8117 23				inc hl 
8118 13				inc de 
8119			 
8119			 
8119 10 ef			djnz .wl1 
811b			 
811b				if DEBUG_STORESE 
811b					DMARK "SW2" 
811b f5				push af  
811c 3a 30 81			ld a, (.dmark)  
811f 32 b7 ee			ld (debug_mark),a  
8122 3a 31 81			ld a, (.dmark+1)  
8125 32 b8 ee			ld (debug_mark+1),a  
8128 3a 32 81			ld a, (.dmark+2)  
812b 32 b9 ee			ld (debug_mark+2),a  
812e 18 03			jr .pastdmark  
8130 ..			.dmark: db "SW2"  
8133 f1			.pastdmark: pop af  
8134			endm  
# End of macro DMARK
8134			 
8134					;push af 
8134					;ld a, 'W' 
8134					;ld (debug_mark),a 
8134					;pop af 
8134					CALLMONITOR 
8134 cd a3 92			call break_point_state  
8137				endm  
# End of macro CALLMONITOR
8137				endif 
8137 c9				ret	 
8138			 
8138			; Init bank 
8138			; --------- 
8138			; 
8138			; With current bank 
8138			; 
8138			; Setup block 0 config 
8138			;     Set 0 file id counter 
8138			;     Set formatted byte pattern 
8138			;     Zero out bank label 
8138			;      
8138			; For every logical block write 0-1 byte as null 
8138			 
8138			storage_get_block_0: 
8138			 
8138				; TODO check presence 
8138			 
8138				; get block 0 config 
8138			 
8138 21 00 00			ld hl, 0 
813b 11 e2 ec			ld de, store_page 
813e cd 87 80			call storage_read_block 
8141			 
8141				if DEBUG_STORESE 
8141					DMARK "SB0" 
8141 f5				push af  
8142 3a 56 81			ld a, (.dmark)  
8145 32 b7 ee			ld (debug_mark),a  
8148 3a 57 81			ld a, (.dmark+1)  
814b 32 b8 ee			ld (debug_mark+1),a  
814e 3a 58 81			ld a, (.dmark+2)  
8151 32 b9 ee			ld (debug_mark+2),a  
8154 18 03			jr .pastdmark  
8156 ..			.dmark: db "SB0"  
8159 f1			.pastdmark: pop af  
815a			endm  
# End of macro DMARK
815a 11 e2 ec				ld de, store_page 
815d			;		push af 
815d			;		ld a, 'i' 
815d			;		ld (debug_mark),a 
815d			;		pop af 
815d					CALLMONITOR 
815d cd a3 92			call break_point_state  
8160				endm  
# End of macro CALLMONITOR
8160				endif 
8160			 
8160				; is this area formatted? 
8160			 
8160			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8160 2a e3 ec			ld hl, (store_page+1) 
8163 3e 80			ld a,0x80 
8165 bd				cp l 
8166 20 22			jr nz, .ininotformatted 
8168				; do a double check 
8168 3e 27			ld a, 0x27 
816a bc				cp h 
816b 20 1d			jr nz, .ininotformatted 
816d			 
816d				; formatted then 
816d			 
816d				if DEBUG_STORESE 
816d					DMARK "SB1" 
816d f5				push af  
816e 3a 82 81			ld a, (.dmark)  
8171 32 b7 ee			ld (debug_mark),a  
8174 3a 83 81			ld a, (.dmark+1)  
8177 32 b8 ee			ld (debug_mark+1),a  
817a 3a 84 81			ld a, (.dmark+2)  
817d 32 b9 ee			ld (debug_mark+2),a  
8180 18 03			jr .pastdmark  
8182 ..			.dmark: db "SB1"  
8185 f1			.pastdmark: pop af  
8186			endm  
# End of macro DMARK
8186					;push af 
8186					;ld a, 'I' 
8186					;ld (debug_mark),a 
8186					;pop af 
8186					CALLMONITOR 
8186 cd a3 92			call break_point_state  
8189				endm  
# End of macro CALLMONITOR
8189				endif 
8189 c9				ret 
818a			 
818a			.ininotformatted: 
818a				; bank not formatted so poke various bits to make sure 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SB2" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 b7 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 b8 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 b9 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SB2"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3					;push af 
81a3					;ld a, 'f' 
81a3					;ld (debug_mark),a 
81a3					;pop af 
81a3					CALLMONITOR 
81a3 cd a3 92			call break_point_state  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6			 
81a6 cd b5 87			call storage_clear_page 
81a9			 
81a9 21 e2 ec			ld hl, store_page 
81ac 3e 00			ld a, 0 
81ae				 
81ae 77				ld (hl),a   ; reset file counter 
81af			 
81af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81b2 22 e3 ec		 	ld (store_page+1), hl	 
81b5			 
81b5				; set default label 
81b5			 
81b5 21 51 82			ld hl, .defaultbanklabl 
81b8 11 e5 ec		 	ld de, store_page+3 
81bb 01 0f 00			ld bc, 15 
81be ed b0			ldir 
81c0			 
81c0				; Append the current bank id 
81c0 21 ee ec			ld hl, store_page+3+9 
81c3 3a c7 ec			ld a, (spi_device_id) 
81c6 77				ld (hl), a 
81c7			 
81c7				; save default page 0 
81c7			 
81c7 21 00 00			ld hl, 0 
81ca 11 e2 ec			ld de, store_page 
81cd				if DEBUG_STORESE 
81cd					DMARK "SB3" 
81cd f5				push af  
81ce 3a e2 81			ld a, (.dmark)  
81d1 32 b7 ee			ld (debug_mark),a  
81d4 3a e3 81			ld a, (.dmark+1)  
81d7 32 b8 ee			ld (debug_mark+1),a  
81da 3a e4 81			ld a, (.dmark+2)  
81dd 32 b9 ee			ld (debug_mark+2),a  
81e0 18 03			jr .pastdmark  
81e2 ..			.dmark: db "SB3"  
81e5 f1			.pastdmark: pop af  
81e6			endm  
# End of macro DMARK
81e6			;		push af 
81e6			;		ld a, 'F' 
81e6			;		ld (debug_mark),a 
81e6			;		pop af 
81e6					CALLMONITOR 
81e6 cd a3 92			call break_point_state  
81e9				endm  
# End of macro CALLMONITOR
81e9				endif 
81e9 cd ec 80			call storage_write_block 
81ec				if DEBUG_STORESE 
81ec					DMARK "SB4" 
81ec f5				push af  
81ed 3a 01 82			ld a, (.dmark)  
81f0 32 b7 ee			ld (debug_mark),a  
81f3 3a 02 82			ld a, (.dmark+1)  
81f6 32 b8 ee			ld (debug_mark+1),a  
81f9 3a 03 82			ld a, (.dmark+2)  
81fc 32 b9 ee			ld (debug_mark+2),a  
81ff 18 03			jr .pastdmark  
8201 ..			.dmark: db "SB4"  
8204 f1			.pastdmark: pop af  
8205			endm  
# End of macro DMARK
8205			;		push af 
8205			;		ld a, '>' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205					CALLMONITOR 
8205 cd a3 92			call break_point_state  
8208				endm  
# End of macro CALLMONITOR
8208				endif 
8208			 
8208 00				nop 
8209 00				nop 
820a 00				nop 
820b			 
820b				; now set 0 in every page to mark as a free block 
820b			 
820b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
820d 21 40 00			ld hl, STORE_BLOCK_PHY 
8210			 
8210 3e 00		.setmark1:   	ld a,0 
8212 e5					push hl 
8213 c5					push bc 
8214 cd 85 80				call se_writebyte 
8217 3e 0a			ld a, 10 
8219 cd d7 87			call aDelayInMS 
821c 23				inc hl 
821d cd 85 80				call se_writebyte 
8220 3e 0a			ld a, 10 
8222 cd d7 87			call aDelayInMS 
8225 2b				dec hl 
8226 c1					pop bc 
8227 e1					pop hl 
8228 3e 40				ld a, STORE_BLOCK_PHY 
822a cd a2 8a				call addatohl 
822d 10 e1				djnz .setmark1 
822f			 
822f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8231 3e 00		.setmark2:   	ld a,0 
8233 e5					push hl 
8234 c5					push bc 
8235 cd 85 80				call se_writebyte 
8238 3e 0a			ld a, 10 
823a cd d7 87			call aDelayInMS 
823d 23				inc hl 
823e cd 85 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd d7 87			call aDelayInMS 
8246 2b				dec hl 
8247 c1					pop bc 
8248 e1					pop hl 
8249 3e 40				ld a, STORE_BLOCK_PHY 
824b cd a2 8a				call addatohl 
824e 10 e1				djnz .setmark2 
8250			 
8250					 
8250			 
8250			 
8250 c9				ret 
8251			 
8251			 
8251			 
8251			 
8251 .. 00		.defaultbanklabl:   db "BankLabel_",0 
825c			 
825c			 
825c			 
825c			; Label Bank 
825c			; ---------- 
825c			; 
825c			; With current bank 
825c			; Read block 0 
825c			; Set label 
825c			; Write block 0 
825c			 
825c			; label str pointer in hl 
825c			 
825c			storage_label:     
825c			 
825c				if DEBUG_STORESE 
825c					DMARK "LBL" 
825c f5				push af  
825d 3a 71 82			ld a, (.dmark)  
8260 32 b7 ee			ld (debug_mark),a  
8263 3a 72 82			ld a, (.dmark+1)  
8266 32 b8 ee			ld (debug_mark+1),a  
8269 3a 73 82			ld a, (.dmark+2)  
826c 32 b9 ee			ld (debug_mark+2),a  
826f 18 03			jr .pastdmark  
8271 ..			.dmark: db "LBL"  
8274 f1			.pastdmark: pop af  
8275			endm  
# End of macro DMARK
8275					CALLMONITOR 
8275 cd a3 92			call break_point_state  
8278				endm  
# End of macro CALLMONITOR
8278				endif 
8278			 
8278 e5				push hl 
8279			 
8279 cd 38 81			call storage_get_block_0 
827c			 
827c				; set default label 
827c			 
827c e1				pop hl 
827d			 
827d 11 e5 ec		 	ld de, store_page+3 
8280 01 0f 00			ld bc, 15 
8283				if DEBUG_STORESE 
8283					DMARK "LB3" 
8283 f5				push af  
8284 3a 98 82			ld a, (.dmark)  
8287 32 b7 ee			ld (debug_mark),a  
828a 3a 99 82			ld a, (.dmark+1)  
828d 32 b8 ee			ld (debug_mark+1),a  
8290 3a 9a 82			ld a, (.dmark+2)  
8293 32 b9 ee			ld (debug_mark+2),a  
8296 18 03			jr .pastdmark  
8298 ..			.dmark: db "LB3"  
829b f1			.pastdmark: pop af  
829c			endm  
# End of macro DMARK
829c					CALLMONITOR 
829c cd a3 92			call break_point_state  
829f				endm  
# End of macro CALLMONITOR
829f				endif 
829f ed b0			ldir 
82a1				; save default page 0 
82a1			 
82a1 21 00 00			ld hl, 0 
82a4 11 e2 ec			ld de, store_page 
82a7				if DEBUG_STORESE 
82a7					DMARK "LBW" 
82a7 f5				push af  
82a8 3a bc 82			ld a, (.dmark)  
82ab 32 b7 ee			ld (debug_mark),a  
82ae 3a bd 82			ld a, (.dmark+1)  
82b1 32 b8 ee			ld (debug_mark+1),a  
82b4 3a be 82			ld a, (.dmark+2)  
82b7 32 b9 ee			ld (debug_mark+2),a  
82ba 18 03			jr .pastdmark  
82bc ..			.dmark: db "LBW"  
82bf f1			.pastdmark: pop af  
82c0			endm  
# End of macro DMARK
82c0					CALLMONITOR 
82c0 cd a3 92			call break_point_state  
82c3				endm  
# End of macro CALLMONITOR
82c3				endif 
82c3 cd ec 80			call storage_write_block 
82c6			 
82c6 c9				ret 
82c7			 
82c7			 
82c7			 
82c7			; Read Block 0 - Config 
82c7			; --------------------- 
82c7			; 
82c7			; With current bank 
82c7			; Call presence test 
82c7			;    If not present format/init bank  
82c7			; Read block 0  
82c7			;  
82c7			 
82c7			 
82c7			; Dir 
82c7			; --- 
82c7			; 
82c7			; With current bank 
82c7			; Load Block 0 Config 
82c7			; Get max file id number 
82c7			; For each logical block 
82c7			;    Read block read byte 2 
82c7			;      if first block of file 
82c7			;         Display file name 
82c7			;         Display type flags for file 
82c7			;        
82c7			 
82c7			; moving to words as this requires stack control 
82c7			 
82c7			 
82c7			; Delete File 
82c7			; ----------- 
82c7			; 
82c7			; With current bank 
82c7			; 
82c7			; Load Block 0 Config 
82c7			; Get max file id number 
82c7			; For each logical block 
82c7			;    Read block file id 
82c7			;      If first block of file and dont have file id 
82c7			;         if file to delete 
82c7			;         Save file id 
82c7			;         Null file id 
82c7			;         Write this block back 
82c7			;      If file id is one saved 
82c7			;         Null file id 
82c7			;         Write this block back 
82c7			 
82c7			 
82c7			.se_done: 
82c7 e1				pop hl 
82c8 c9				ret 
82c9			 
82c9			storage_erase: 
82c9			 
82c9				; hl contains the file id 
82c9			 
82c9 5d				ld e, l 
82ca 16 00			ld d, 0 
82cc 21 40 00			ld hl, STORE_BLOCK_PHY 
82cf					if DEBUG_FORTH_WORDS 
82cf						DMARK "ERA" 
82cf f5				push af  
82d0 3a e4 82			ld a, (.dmark)  
82d3 32 b7 ee			ld (debug_mark),a  
82d6 3a e5 82			ld a, (.dmark+1)  
82d9 32 b8 ee			ld (debug_mark+1),a  
82dc 3a e6 82			ld a, (.dmark+2)  
82df 32 b9 ee			ld (debug_mark+2),a  
82e2 18 03			jr .pastdmark  
82e4 ..			.dmark: db "ERA"  
82e7 f1			.pastdmark: pop af  
82e8			endm  
# End of macro DMARK
82e8						CALLMONITOR 
82e8 cd a3 92			call break_point_state  
82eb				endm  
# End of macro CALLMONITOR
82eb					endif 
82eb cd ba 83			call storage_findnextid 
82ee cd cb 8a			call ishlzero 
82f1 c8				ret z 
82f2			 
82f2 e5				push hl 
82f3			 
82f3				; TODO check file not found 
82f3			 
82f3 11 e2 ec			ld de, store_page 
82f6 cd 87 80			call storage_read_block 
82f9			 
82f9 cd cb 8a			call ishlzero 
82fc ca c7 82			jp z,.se_done 
82ff			 
82ff					if DEBUG_FORTH_WORDS 
82ff						DMARK "ER1" 
82ff f5				push af  
8300 3a 14 83			ld a, (.dmark)  
8303 32 b7 ee			ld (debug_mark),a  
8306 3a 15 83			ld a, (.dmark+1)  
8309 32 b8 ee			ld (debug_mark+1),a  
830c 3a 16 83			ld a, (.dmark+2)  
830f 32 b9 ee			ld (debug_mark+2),a  
8312 18 03			jr .pastdmark  
8314 ..			.dmark: db "ER1"  
8317 f1			.pastdmark: pop af  
8318			endm  
# End of macro DMARK
8318						CALLMONITOR 
8318 cd a3 92			call break_point_state  
831b				endm  
# End of macro CALLMONITOR
831b					endif 
831b 3a e2 ec			ld a, (store_page)	; get file id 
831e 32 db ec			ld (store_tmpid), a 
8321			 
8321 3a e4 ec			ld a, (store_page+2)    ; get count of extends 
8324 32 da ec			ld (store_tmpext), a 
8327			 
8327				; wipe file header 
8327			 
8327 e1				pop hl 
8328 3e 00			ld a, 0 
832a 32 e2 ec			ld (store_page), a 
832d 32 e3 ec			ld (store_page+1),a 
8330 11 e2 ec			ld de, store_page 
8333					if DEBUG_FORTH_WORDS 
8333						DMARK "ER2" 
8333 f5				push af  
8334 3a 48 83			ld a, (.dmark)  
8337 32 b7 ee			ld (debug_mark),a  
833a 3a 49 83			ld a, (.dmark+1)  
833d 32 b8 ee			ld (debug_mark+1),a  
8340 3a 4a 83			ld a, (.dmark+2)  
8343 32 b9 ee			ld (debug_mark+2),a  
8346 18 03			jr .pastdmark  
8348 ..			.dmark: db "ER2"  
834b f1			.pastdmark: pop af  
834c			endm  
# End of macro DMARK
834c						CALLMONITOR 
834c cd a3 92			call break_point_state  
834f				endm  
# End of macro CALLMONITOR
834f					endif 
834f cd ec 80			call storage_write_block 
8352			 
8352			 
8352				; wipe file extents 
8352			 
8352 3a da ec			ld a, (store_tmpext) 
8355 47				ld b, a 
8356			 
8356			.eraext:	  
8356 c5				push bc 
8357			 
8357 21 40 00			ld hl, STORE_BLOCK_PHY 
835a 3a db ec			ld a,(store_tmpid) 
835d 5f				ld e, a 
835e 50				ld d, b	 
835f					if DEBUG_FORTH_WORDS 
835f						DMARK "ER3" 
835f f5				push af  
8360 3a 74 83			ld a, (.dmark)  
8363 32 b7 ee			ld (debug_mark),a  
8366 3a 75 83			ld a, (.dmark+1)  
8369 32 b8 ee			ld (debug_mark+1),a  
836c 3a 76 83			ld a, (.dmark+2)  
836f 32 b9 ee			ld (debug_mark+2),a  
8372 18 03			jr .pastdmark  
8374 ..			.dmark: db "ER3"  
8377 f1			.pastdmark: pop af  
8378			endm  
# End of macro DMARK
8378						CALLMONITOR 
8378 cd a3 92			call break_point_state  
837b				endm  
# End of macro CALLMONITOR
837b					endif 
837b cd ba 83			call storage_findnextid 
837e cd cb 8a			call ishlzero 
8381 ca c7 82			jp z,.se_done 
8384			 
8384 e5				push hl 
8385 11 e2 ec			ld de, store_page 
8388 cd 87 80			call storage_read_block 
838b			 
838b				; free block	 
838b			 
838b 3e 00			ld a, 0 
838d 32 e2 ec			ld (store_page), a 
8390 32 e3 ec			ld (store_page+1),a 
8393 11 e2 ec			ld de, store_page 
8396 e1				pop hl 
8397					if DEBUG_FORTH_WORDS 
8397						DMARK "ER4" 
8397 f5				push af  
8398 3a ac 83			ld a, (.dmark)  
839b 32 b7 ee			ld (debug_mark),a  
839e 3a ad 83			ld a, (.dmark+1)  
83a1 32 b8 ee			ld (debug_mark+1),a  
83a4 3a ae 83			ld a, (.dmark+2)  
83a7 32 b9 ee			ld (debug_mark+2),a  
83aa 18 03			jr .pastdmark  
83ac ..			.dmark: db "ER4"  
83af f1			.pastdmark: pop af  
83b0			endm  
# End of macro DMARK
83b0						CALLMONITOR 
83b0 cd a3 92			call break_point_state  
83b3				endm  
# End of macro CALLMONITOR
83b3					endif 
83b3 cd ec 80			call storage_write_block 
83b6			 
83b6 c1				pop bc 
83b7 10 9d			djnz .eraext 
83b9			 
83b9 c9				ret 
83ba			 
83ba			 
83ba			; Find Free Block 
83ba			; --------------- 
83ba			; 
83ba			; With current bank 
83ba			;  
83ba			; From given starting logical block 
83ba			;    Read block  
83ba			;    If no file id 
83ba			;         Return block id 
83ba			 
83ba			 
83ba			; hl starting page number 
83ba			; hl contains free page number or zero if no pages free 
83ba			; e contains the file id to locate 
83ba			; d contains the block number 
83ba			 
83ba			; TODO change to find file id and use zero for free block 
83ba			 
83ba			storage_findnextid: 
83ba			 
83ba				; now locate first 0 page to mark as a free block 
83ba			 
83ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83bc			;	ld hl, STORE_BLOCK_PHY 
83bc			 
83bc					if DEBUG_FORTH_WORDS 
83bc					DMARK "FNI" 
83bc f5				push af  
83bd 3a d1 83			ld a, (.dmark)  
83c0 32 b7 ee			ld (debug_mark),a  
83c3 3a d2 83			ld a, (.dmark+1)  
83c6 32 b8 ee			ld (debug_mark+1),a  
83c9 3a d3 83			ld a, (.dmark+2)  
83cc 32 b9 ee			ld (debug_mark+2),a  
83cf 18 03			jr .pastdmark  
83d1 ..			.dmark: db "FNI"  
83d4 f1			.pastdmark: pop af  
83d5			endm  
# End of macro DMARK
83d5						CALLMONITOR 
83d5 cd a3 92			call break_point_state  
83d8				endm  
# End of macro CALLMONITOR
83d8					endif 
83d8			.ff1:   	 
83d8 e5					push hl 
83d9 c5					push bc 
83da d5					push de 
83db cd 84 80				call se_readbyte 
83de 5f					ld e,a 
83df 23					inc hl 
83e0 cd 84 80				call se_readbyte 
83e3 57					ld d, a 
83e4 e1					pop hl 
83e5 e5					push hl 
83e6 cd c0 8a				call cmp16 
83e9 28 49				jr z, .fffound 
83eb			 
83eb d1					pop de 
83ec c1					pop bc 
83ed e1					pop hl 
83ee			 
83ee					; is found? 
83ee					;cp e 
83ee					;ret z 
83ee			 
83ee 3e 40				ld a, STORE_BLOCK_PHY 
83f0 cd a2 8a				call addatohl 
83f3 10 e3				djnz .ff1 
83f5			 
83f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83f7			.ff2:   	 
83f7			 
83f7 e5					push hl 
83f8 c5					push bc 
83f9 d5					push de 
83fa cd 84 80				call se_readbyte 
83fd 5f					ld e,a 
83fe 23					inc hl 
83ff cd 84 80				call se_readbyte 
8402 57					ld d, a 
8403			 
8403 e1					pop hl 
8404 e5					push hl 
8405 cd c0 8a				call cmp16 
8408 28 2a				jr z, .fffound 
840a			 
840a d1					pop de 
840b c1					pop bc 
840c e1					pop hl 
840d					; is found? 
840d					;cp e 
840d					;ret z 
840d			 
840d 3e 40				ld a, STORE_BLOCK_PHY 
840f cd a2 8a				call addatohl 
8412 10 e3				djnz .ff2 
8414			 
8414			 
8414					if DEBUG_FORTH_WORDS 
8414					DMARK "FN-" 
8414 f5				push af  
8415 3a 29 84			ld a, (.dmark)  
8418 32 b7 ee			ld (debug_mark),a  
841b 3a 2a 84			ld a, (.dmark+1)  
841e 32 b8 ee			ld (debug_mark+1),a  
8421 3a 2b 84			ld a, (.dmark+2)  
8424 32 b9 ee			ld (debug_mark+2),a  
8427 18 03			jr .pastdmark  
8429 ..			.dmark: db "FN-"  
842c f1			.pastdmark: pop af  
842d			endm  
# End of macro DMARK
842d					;	push af 
842d					;	ld a, 'n' 
842d					;	ld (debug_mark),a 
842d					;	pop af 
842d						CALLMONITOR 
842d cd a3 92			call break_point_state  
8430				endm  
# End of macro CALLMONITOR
8430					endif 
8430				; no free marks! 
8430 21 00 00				ld hl, 0 
8433 c9				ret 
8434			.fffound: 
8434				 
8434			 
8434 d1					pop de 
8435 c1					pop bc 
8436 e1					pop hl 
8437					if DEBUG_FORTH_WORDS 
8437					DMARK "FNF" 
8437 f5				push af  
8438 3a 4c 84			ld a, (.dmark)  
843b 32 b7 ee			ld (debug_mark),a  
843e 3a 4d 84			ld a, (.dmark+1)  
8441 32 b8 ee			ld (debug_mark+1),a  
8444 3a 4e 84			ld a, (.dmark+2)  
8447 32 b9 ee			ld (debug_mark+2),a  
844a 18 03			jr .pastdmark  
844c ..			.dmark: db "FNF"  
844f f1			.pastdmark: pop af  
8450			endm  
# End of macro DMARK
8450					;	push af 
8450					;	ld a, 'n' 
8450					;	ld (debug_mark),a 
8450					;	pop af 
8450						CALLMONITOR 
8450 cd a3 92			call break_point_state  
8453				endm  
# End of macro CALLMONITOR
8453					endif 
8453 c9				ret 
8454			 
8454			 
8454			 
8454			; Free Space 
8454			; ---------- 
8454			; 
8454			; With current bank 
8454			; 
8454			; Set block count to zero 
8454			; Starting with first logical block 
8454			;      Find free block  
8454			;      If block id given, increment block count 
8454			; 
8454			;  
8454			 
8454			 
8454			; hl contains count of free blocks 
8454			 
8454			storage_freeblocks: 
8454			 
8454				; now locate first 0 page to mark as a free block 
8454			 
8454 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8456 21 40 00			ld hl, STORE_BLOCK_PHY 
8459 11 00 00			ld de, 0 
845c			 
845c			.fb1:   	 
845c e5					push hl 
845d c5					push bc 
845e d5					push de 
845f cd 84 80				call se_readbyte 
8462 d1					pop de 
8463 c1					pop bc 
8464 e1					pop hl 
8465			 
8465					; is free? 
8465 fe 00				cp 0 
8467 20 01				jr nz, .ff1cont 
8469 13					inc de 
846a			 
846a			.ff1cont: 
846a			 
846a			 
846a 3e 40				ld a, STORE_BLOCK_PHY 
846c cd a2 8a				call addatohl 
846f 10 eb				djnz .fb1 
8471			 
8471 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8473			.fb2:   	 
8473 e5					push hl 
8474 c5					push bc 
8475 d5					push de 
8476 cd 84 80				call se_readbyte 
8479 d1					pop de 
847a c1					pop bc 
847b e1					pop hl 
847c			 
847c					; is free? 
847c fe 00				cp 0 
847e 20 01				jr nz, .ff2cont 
8480 13					inc de 
8481			 
8481			.ff2cont: 
8481			 
8481 3e 40				ld a, STORE_BLOCK_PHY 
8483 cd a2 8a				call addatohl 
8486 10 eb				djnz .fb2 
8488			 
8488 eb				ex de, hl 
8489 c9				ret 
848a			 
848a			; Get File ID 
848a			; ----------- 
848a			; 
848a			; With current bank 
848a			;  
848a			; Load Block 0 Config 
848a			; Get max file id number 
848a			; For each logical block 
848a			;    Read block file id 
848a			;      If first block of file and dont have file id 
848a			;         if file get id and exit 
848a			 
848a			 
848a			 
848a			 
848a			; Create File 
848a			; ----------- 
848a			; 
848a			; With current bank  
848a			; Load Block 0 Config 
848a			; Get max file id number 
848a			; Increment file id number 
848a			; Save Config 
848a			; Find free block 
848a			; Set buffer with file name and file id 
848a			; Write buffer to free block  
848a			 
848a			 
848a			; hl point to file name 
848a			; hl returns file id 
848a			 
848a			; file format: 
848a			; byte 0 - file id 
848a			; byte 1 - extent number 
848a			; byte 2-> data 
848a			 
848a			; format for extent number 0: 
848a			; 
848a			; byte 0 - file id 
848a			; byte 1 - extent 0 
848a			; byte 2 - extent count 
848a			; byte 3 -> file name and meta data 
848a			 
848a			 
848a			storage_create: 
848a				if DEBUG_STORESE 
848a					DMARK "SCR" 
848a f5				push af  
848b 3a 9f 84			ld a, (.dmark)  
848e 32 b7 ee			ld (debug_mark),a  
8491 3a a0 84			ld a, (.dmark+1)  
8494 32 b8 ee			ld (debug_mark+1),a  
8497 3a a1 84			ld a, (.dmark+2)  
849a 32 b9 ee			ld (debug_mark+2),a  
849d 18 03			jr .pastdmark  
849f ..			.dmark: db "SCR"  
84a2 f1			.pastdmark: pop af  
84a3			endm  
# End of macro DMARK
84a3					CALLMONITOR 
84a3 cd a3 92			call break_point_state  
84a6				endm  
# End of macro CALLMONITOR
84a6				endif 
84a6			 
84a6 e5				push hl		; save file name pointer 
84a7			 
84a7 cd 38 81			call storage_get_block_0 
84aa			 
84aa 3a e2 ec			ld a,(store_page)	; get current file id 
84ad 3c				inc a 
84ae 32 e2 ec			ld (store_page),a 
84b1				 
84b1 32 db ec			ld (store_tmpid),a			; save id 
84b4			 
84b4 21 00 00			ld hl, 0 
84b7 11 e2 ec			ld de, store_page 
84ba				if DEBUG_STORESE 
84ba					DMARK "SCw" 
84ba f5				push af  
84bb 3a cf 84			ld a, (.dmark)  
84be 32 b7 ee			ld (debug_mark),a  
84c1 3a d0 84			ld a, (.dmark+1)  
84c4 32 b8 ee			ld (debug_mark+1),a  
84c7 3a d1 84			ld a, (.dmark+2)  
84ca 32 b9 ee			ld (debug_mark+2),a  
84cd 18 03			jr .pastdmark  
84cf ..			.dmark: db "SCw"  
84d2 f1			.pastdmark: pop af  
84d3			endm  
# End of macro DMARK
84d3					CALLMONITOR 
84d3 cd a3 92			call break_point_state  
84d6				endm  
# End of macro CALLMONITOR
84d6				endif 
84d6 cd ec 80			call storage_write_block	 ; save update 
84d9			 
84d9				if DEBUG_STORESE 
84d9 11 e2 ec				ld de, store_page 
84dc					DMARK "SCC" 
84dc f5				push af  
84dd 3a f1 84			ld a, (.dmark)  
84e0 32 b7 ee			ld (debug_mark),a  
84e3 3a f2 84			ld a, (.dmark+1)  
84e6 32 b8 ee			ld (debug_mark+1),a  
84e9 3a f3 84			ld a, (.dmark+2)  
84ec 32 b9 ee			ld (debug_mark+2),a  
84ef 18 03			jr .pastdmark  
84f1 ..			.dmark: db "SCC"  
84f4 f1			.pastdmark: pop af  
84f5			endm  
# End of macro DMARK
84f5					CALLMONITOR 
84f5 cd a3 92			call break_point_state  
84f8				endm  
# End of macro CALLMONITOR
84f8				endif 
84f8				;  
84f8				 
84f8 21 40 00			ld hl, STORE_BLOCK_PHY 
84fb 11 00 00			ld de, 0 
84fe cd ba 83			call storage_findnextid 
8501			 
8501 22 cc ec			ld (store_tmppageid), hl    ; save page to use  
8504			 
8504				; TODO detect 0 = no spare blocks 
8504			 
8504				; hl now contains the free page to use for the file header page 
8504			 
8504				if DEBUG_STORESE 
8504				DMARK "SCF" 
8504 f5				push af  
8505 3a 19 85			ld a, (.dmark)  
8508 32 b7 ee			ld (debug_mark),a  
850b 3a 1a 85			ld a, (.dmark+1)  
850e 32 b8 ee			ld (debug_mark+1),a  
8511 3a 1b 85			ld a, (.dmark+2)  
8514 32 b9 ee			ld (debug_mark+2),a  
8517 18 03			jr .pastdmark  
8519 ..			.dmark: db "SCF"  
851c f1			.pastdmark: pop af  
851d			endm  
# End of macro DMARK
851d					CALLMONITOR 
851d cd a3 92			call break_point_state  
8520				endm  
# End of macro CALLMONITOR
8520				endif 
8520			 
8520 22 cc ec			ld (store_tmppageid), hl 
8523				 
8523 3a db ec			ld a,(store_tmpid)    ; get file id 
8526			;	ld a, (store_filecache)			; save to cache 
8526			 
8526 32 e2 ec			ld (store_page),a    ; set page id 
8529 3e 00			ld a, 0			 ; extent 0 is file header 
852b 32 e3 ec			ld (store_page+1), a   ; set file extent 
852e			 
852e 32 e4 ec			ld (store_page+2), a   ; extent count for the file 
8531			 
8531			;	inc hl 		; init block 0 of file 
8531			;	inc hl   		; skip file and extent id 
8531			 ;       ld a, 0 
8531			;	ld (hl),a 
8531			;	ld a, (store_filecache+1)  	; save to cache 
8531			 
8531			;	inc hl    ; file name 
8531				 
8531				 
8531 11 e5 ec			ld de, store_page+3    ; get buffer for term string to use as file name 
8534				if DEBUG_STORESE 
8534					DMARK "SCc" 
8534 f5				push af  
8535 3a 49 85			ld a, (.dmark)  
8538 32 b7 ee			ld (debug_mark),a  
853b 3a 4a 85			ld a, (.dmark+1)  
853e 32 b8 ee			ld (debug_mark+1),a  
8541 3a 4b 85			ld a, (.dmark+2)  
8544 32 b9 ee			ld (debug_mark+2),a  
8547 18 03			jr .pastdmark  
8549 ..			.dmark: db "SCc"  
854c f1			.pastdmark: pop af  
854d			endm  
# End of macro DMARK
854d					CALLMONITOR 
854d cd a3 92			call break_point_state  
8550				endm  
# End of macro CALLMONITOR
8550				endif 
8550 e1				pop hl    ; get zero term string 
8551 e5				push hl 
8552 3e 00			ld a, 0 
8554 cd 0b 8f			call strlent 
8557 23				inc hl   ; cover zero term 
8558 06 00			ld b,0 
855a 4d				ld c,l 
855b e1				pop hl 
855c				;ex de, hl 
855c				if DEBUG_STORESE 
855c					DMARK "SCa" 
855c f5				push af  
855d 3a 71 85			ld a, (.dmark)  
8560 32 b7 ee			ld (debug_mark),a  
8563 3a 72 85			ld a, (.dmark+1)  
8566 32 b8 ee			ld (debug_mark+1),a  
8569 3a 73 85			ld a, (.dmark+2)  
856c 32 b9 ee			ld (debug_mark+2),a  
856f 18 03			jr .pastdmark  
8571 ..			.dmark: db "SCa"  
8574 f1			.pastdmark: pop af  
8575			endm  
# End of macro DMARK
8575					;push af 
8575					;ld a, 'a' 
8575					;ld (debug_mark),a 
8575					;pop af 
8575					CALLMONITOR 
8575 cd a3 92			call break_point_state  
8578				endm  
# End of macro CALLMONITOR
8578				endif 
8578 ed b0			ldir    ; copy zero term string 
857a				if DEBUG_STORESE 
857a					DMARK "SCA" 
857a f5				push af  
857b 3a 8f 85			ld a, (.dmark)  
857e 32 b7 ee			ld (debug_mark),a  
8581 3a 90 85			ld a, (.dmark+1)  
8584 32 b8 ee			ld (debug_mark+1),a  
8587 3a 91 85			ld a, (.dmark+2)  
858a 32 b9 ee			ld (debug_mark+2),a  
858d 18 03			jr .pastdmark  
858f ..			.dmark: db "SCA"  
8592 f1			.pastdmark: pop af  
8593			endm  
# End of macro DMARK
8593					CALLMONITOR 
8593 cd a3 92			call break_point_state  
8596				endm  
# End of macro CALLMONITOR
8596				endif 
8596			 
8596				; write file header page 
8596			 
8596 2a cc ec			ld hl,(store_tmppageid) 
8599 11 e2 ec			ld de, store_page 
859c				if DEBUG_STORESE 
859c					DMARK "SCb" 
859c f5				push af  
859d 3a b1 85			ld a, (.dmark)  
85a0 32 b7 ee			ld (debug_mark),a  
85a3 3a b2 85			ld a, (.dmark+1)  
85a6 32 b8 ee			ld (debug_mark+1),a  
85a9 3a b3 85			ld a, (.dmark+2)  
85ac 32 b9 ee			ld (debug_mark+2),a  
85af 18 03			jr .pastdmark  
85b1 ..			.dmark: db "SCb"  
85b4 f1			.pastdmark: pop af  
85b5			endm  
# End of macro DMARK
85b5					;push af 
85b5					;ld a, 'b' 
85b5					;ld (debug_mark),a 
85b5					;pop af 
85b5					CALLMONITOR 
85b5 cd a3 92			call break_point_state  
85b8				endm  
# End of macro CALLMONITOR
85b8				endif 
85b8 cd ec 80			call storage_write_block 
85bb			 
85bb 3a db ec			ld a, (store_tmpid) 
85be 6f				ld l, a 
85bf 26 00			ld h,0 
85c1				if DEBUG_STORESE 
85c1					DMARK "SCz" 
85c1 f5				push af  
85c2 3a d6 85			ld a, (.dmark)  
85c5 32 b7 ee			ld (debug_mark),a  
85c8 3a d7 85			ld a, (.dmark+1)  
85cb 32 b8 ee			ld (debug_mark+1),a  
85ce 3a d8 85			ld a, (.dmark+2)  
85d1 32 b9 ee			ld (debug_mark+2),a  
85d4 18 03			jr .pastdmark  
85d6 ..			.dmark: db "SCz"  
85d9 f1			.pastdmark: pop af  
85da			endm  
# End of macro DMARK
85da					CALLMONITOR 
85da cd a3 92			call break_point_state  
85dd				endm  
# End of macro CALLMONITOR
85dd				endif 
85dd c9				ret 
85de				 
85de			 
85de			 
85de			; 
85de			; Read File 
85de			; 
85de			; h - file id to locate 
85de			; l - extent to locate 
85de			; de - pointer to string to read into 
85de			; 
85de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85de			 
85de			.sr_fail: 
85de d1				pop de 
85df c9				ret 
85e0			 
85e0			storage_read: 
85e0 d5				push de 
85e1			 
85e1			; TODO BUG the above push is it popped before the RET Z? 
85e1			 
85e1			; TODO how to handle multiple part blocks 
85e1			 
85e1				; locate file extent to read 
85e1			 
85e1 5c				ld e, h 
85e2 55				ld d, l 
85e3 21 40 00			ld hl, STORE_BLOCK_PHY 
85e6				if DEBUG_STORESE 
85e6					DMARK "SRE" 
85e6 f5				push af  
85e7 3a fb 85			ld a, (.dmark)  
85ea 32 b7 ee			ld (debug_mark),a  
85ed 3a fc 85			ld a, (.dmark+1)  
85f0 32 b8 ee			ld (debug_mark+1),a  
85f3 3a fd 85			ld a, (.dmark+2)  
85f6 32 b9 ee			ld (debug_mark+2),a  
85f9 18 03			jr .pastdmark  
85fb ..			.dmark: db "SRE"  
85fe f1			.pastdmark: pop af  
85ff			endm  
# End of macro DMARK
85ff					CALLMONITOR 
85ff cd a3 92			call break_point_state  
8602				endm  
# End of macro CALLMONITOR
8602				endif 
8602 cd ba 83			call storage_findnextid 
8605			 
8605				if DEBUG_STORESE 
8605					DMARK "SRf" 
8605 f5				push af  
8606 3a 1a 86			ld a, (.dmark)  
8609 32 b7 ee			ld (debug_mark),a  
860c 3a 1b 86			ld a, (.dmark+1)  
860f 32 b8 ee			ld (debug_mark+1),a  
8612 3a 1c 86			ld a, (.dmark+2)  
8615 32 b9 ee			ld (debug_mark+2),a  
8618 18 03			jr .pastdmark  
861a ..			.dmark: db "SRf"  
861d f1			.pastdmark: pop af  
861e			endm  
# End of macro DMARK
861e					CALLMONITOR 
861e cd a3 92			call break_point_state  
8621				endm  
# End of macro CALLMONITOR
8621				endif 
8621 cd cb 8a			call ishlzero 
8624			;	ld a, l 
8624			;	add h 
8624			;	cp 0 
8624 28 b8			jr z,.sr_fail			; block not found so EOF 
8626			 
8626				; hl contains page number to load 
8626 d1				pop de   ; get storage 
8627 d5				push de 
8628				if DEBUG_STORESE 
8628					DMARK "SRg" 
8628 f5				push af  
8629 3a 3d 86			ld a, (.dmark)  
862c 32 b7 ee			ld (debug_mark),a  
862f 3a 3e 86			ld a, (.dmark+1)  
8632 32 b8 ee			ld (debug_mark+1),a  
8635 3a 3f 86			ld a, (.dmark+2)  
8638 32 b9 ee			ld (debug_mark+2),a  
863b 18 03			jr .pastdmark  
863d ..			.dmark: db "SRg"  
8640 f1			.pastdmark: pop af  
8641			endm  
# End of macro DMARK
8641					CALLMONITOR 
8641 cd a3 92			call break_point_state  
8644				endm  
# End of macro CALLMONITOR
8644				endif 
8644 cd 87 80			call storage_read_block 
8647			 
8647			 
8647			; TODO if block has no zeros then need to read next block  
8647			 
8647			 
8647					 
8647 e1				pop hl 		 ; return start of data to show as not EOF 
8648 23				inc hl   ; past file id 
8649 23				inc hl   ; past ext 
864a				if DEBUG_STORESE 
864a					DMARK "SRe" 
864a f5				push af  
864b 3a 5f 86			ld a, (.dmark)  
864e 32 b7 ee			ld (debug_mark),a  
8651 3a 60 86			ld a, (.dmark+1)  
8654 32 b8 ee			ld (debug_mark+1),a  
8657 3a 61 86			ld a, (.dmark+2)  
865a 32 b9 ee			ld (debug_mark+2),a  
865d 18 03			jr .pastdmark  
865f ..			.dmark: db "SRe"  
8662 f1			.pastdmark: pop af  
8663			endm  
# End of macro DMARK
8663					CALLMONITOR 
8663 cd a3 92			call break_point_state  
8666				endm  
# End of macro CALLMONITOR
8666				endif 
8666 c9					ret 
8667			 
8667			 
8667			 
8667			; 
8667			; Append File 
8667			; 
8667			; hl - file id to locate 
8667			; de - pointer to (multi block) string to write 
8667			 
8667			.sa_notfound: 
8667 d1				pop de 
8668 c9				ret 
8669			 
8669			 
8669			storage_append: 
8669				; hl -  file id to append to 
8669				; de - string to append 
8669			 
8669 d5				push de 
866a				 
866a				if DEBUG_STORESE 
866a					DMARK "AP1" 
866a f5				push af  
866b 3a 7f 86			ld a, (.dmark)  
866e 32 b7 ee			ld (debug_mark),a  
8671 3a 80 86			ld a, (.dmark+1)  
8674 32 b8 ee			ld (debug_mark+1),a  
8677 3a 81 86			ld a, (.dmark+2)  
867a 32 b9 ee			ld (debug_mark+2),a  
867d 18 03			jr .pastdmark  
867f ..			.dmark: db "AP1"  
8682 f1			.pastdmark: pop af  
8683			endm  
# End of macro DMARK
8683					CALLMONITOR 
8683 cd a3 92			call break_point_state  
8686				endm  
# End of macro CALLMONITOR
8686				endif 
8686			 
8686 7d				ld a, l 
8687 32 db ec			ld (store_tmpid), a 
868a			 
868a				; get file header  
868a			 
868a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
868c 3a db ec			ld a, (store_tmpid) 
868f 5f				ld e, a 
8690			 
8690 21 40 00				ld hl, STORE_BLOCK_PHY 
8693 cd ba 83				call storage_findnextid 
8696			 
8696 cd cb 8a			call ishlzero 
8699 28 cc			jr z, .sa_notfound 
869b			 
869b 22 cc ec			ld (store_tmppageid), hl 
869e			 
869e				; TODO handle file id not found 
869e			 
869e				if DEBUG_STORESE 
869e					DMARK "AP2" 
869e f5				push af  
869f 3a b3 86			ld a, (.dmark)  
86a2 32 b7 ee			ld (debug_mark),a  
86a5 3a b4 86			ld a, (.dmark+1)  
86a8 32 b8 ee			ld (debug_mark+1),a  
86ab 3a b5 86			ld a, (.dmark+2)  
86ae 32 b9 ee			ld (debug_mark+2),a  
86b1 18 03			jr .pastdmark  
86b3 ..			.dmark: db "AP2"  
86b6 f1			.pastdmark: pop af  
86b7			endm  
# End of macro DMARK
86b7					CALLMONITOR 
86b7 cd a3 92			call break_point_state  
86ba				endm  
# End of macro CALLMONITOR
86ba				endif 
86ba			 
86ba				; update file extent count 
86ba			 
86ba 11 e2 ec			ld de, store_page 
86bd			 
86bd cd 87 80			call storage_read_block 
86c0			 
86c0				if DEBUG_STORESE 
86c0					DMARK "AP3" 
86c0 f5				push af  
86c1 3a d5 86			ld a, (.dmark)  
86c4 32 b7 ee			ld (debug_mark),a  
86c7 3a d6 86			ld a, (.dmark+1)  
86ca 32 b8 ee			ld (debug_mark+1),a  
86cd 3a d7 86			ld a, (.dmark+2)  
86d0 32 b9 ee			ld (debug_mark+2),a  
86d3 18 03			jr .pastdmark  
86d5 ..			.dmark: db "AP3"  
86d8 f1			.pastdmark: pop af  
86d9			endm  
# End of macro DMARK
86d9					CALLMONITOR 
86d9 cd a3 92			call break_point_state  
86dc				endm  
# End of macro CALLMONITOR
86dc				endif 
86dc			;	ld (store_tmppageid), hl 
86dc			 
86dc 3a e4 ec			ld a, (store_page+2) 
86df 3c				inc a 
86e0 32 e4 ec			ld (store_page+2), a 
86e3 32 da ec			ld (store_tmpext), a 
86e6				 
86e6				if DEBUG_STORESE 
86e6					DMARK "AP3" 
86e6 f5				push af  
86e7 3a fb 86			ld a, (.dmark)  
86ea 32 b7 ee			ld (debug_mark),a  
86ed 3a fc 86			ld a, (.dmark+1)  
86f0 32 b8 ee			ld (debug_mark+1),a  
86f3 3a fd 86			ld a, (.dmark+2)  
86f6 32 b9 ee			ld (debug_mark+2),a  
86f9 18 03			jr .pastdmark  
86fb ..			.dmark: db "AP3"  
86fe f1			.pastdmark: pop af  
86ff			endm  
# End of macro DMARK
86ff					CALLMONITOR 
86ff cd a3 92			call break_point_state  
8702				endm  
# End of macro CALLMONITOR
8702				endif 
8702 2a cc ec			ld hl, (store_tmppageid) 
8705 11 e2 ec			ld de, store_page 
8708 cd ec 80			call storage_write_block 
870b			 
870b				; find free block 
870b			 
870b 11 00 00			ld de, 0			 ; file extent to locate 
870e			 
870e 21 40 00				ld hl, STORE_BLOCK_PHY 
8711 cd ba 83				call storage_findnextid 
8714 cd cb 8a			call ishlzero 
8717 ca 67 86			jp z, .sa_notfound 
871a			 
871a					; TODO handle no space left 
871a					 
871a 22 cc ec				ld (store_tmppageid), hl 
871d			 
871d				if DEBUG_STORESE 
871d					DMARK "AP4" 
871d f5				push af  
871e 3a 32 87			ld a, (.dmark)  
8721 32 b7 ee			ld (debug_mark),a  
8724 3a 33 87			ld a, (.dmark+1)  
8727 32 b8 ee			ld (debug_mark+1),a  
872a 3a 34 87			ld a, (.dmark+2)  
872d 32 b9 ee			ld (debug_mark+2),a  
8730 18 03			jr .pastdmark  
8732 ..			.dmark: db "AP4"  
8735 f1			.pastdmark: pop af  
8736			endm  
# End of macro DMARK
8736					CALLMONITOR 
8736 cd a3 92			call break_point_state  
8739				endm  
# End of macro CALLMONITOR
8739				endif 
8739					; init the buffer with zeros so we can id if the buffer is full or not 
8739			 
8739 e5					push hl 
873a c5					push bc 
873b			 
873b 21 e2 ec				ld hl, store_page 
873e 06 40				ld b, STORE_BLOCK_PHY 
8740 3e 00				ld a, 0 
8742 77			.zeroblock:	ld (hl), a 
8743 23					inc hl 
8744 10 fc				djnz .zeroblock 
8746			 
8746 c1					pop bc 
8747 e1					pop hl 
8748			 
8748					; construct block 
8748			 
8748 3a db ec				ld a, (store_tmpid) 
874b 32 e2 ec				ld (store_page), a   ; file id 
874e 3a da ec				ld a, (store_tmpext)   ; extent for this block 
8751 32 e3 ec				ld (store_page+1), a 
8754			 
8754 e1					pop hl    ; get string to write 
8755 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8757 11 e4 ec				ld de, store_page+2 
875a			 
875a				if DEBUG_STORESE 
875a					DMARK "AP5" 
875a f5				push af  
875b 3a 6f 87			ld a, (.dmark)  
875e 32 b7 ee			ld (debug_mark),a  
8761 3a 70 87			ld a, (.dmark+1)  
8764 32 b8 ee			ld (debug_mark+1),a  
8767 3a 71 87			ld a, (.dmark+2)  
876a 32 b9 ee			ld (debug_mark+2),a  
876d 18 03			jr .pastdmark  
876f ..			.dmark: db "AP5"  
8772 f1			.pastdmark: pop af  
8773			endm  
# End of macro DMARK
8773					CALLMONITOR 
8773 cd a3 92			call break_point_state  
8776				endm  
# End of macro CALLMONITOR
8776				endif 
8776			 
8776			 
8776			 
8776					; fill buffer with data until end of string or full block 
8776			 
8776 7e			.appd:		ld a, (hl) 
8777 12					ld (de), a 
8778 fe 00				cp 0 
877a 28 04				jr z, .appdone 
877c 23					inc hl 
877d 13					inc de 
877e 10 f6				djnz .appd 
8780			 
8780 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8781 f5					push af   		; save last byte dumped 
8782			 
8782			 
8782 2a cc ec			ld hl, (store_tmppageid) 
8785 11 e2 ec			ld de, store_page 
8788				if DEBUG_STORESE 
8788					DMARK "AP6" 
8788 f5				push af  
8789 3a 9d 87			ld a, (.dmark)  
878c 32 b7 ee			ld (debug_mark),a  
878f 3a 9e 87			ld a, (.dmark+1)  
8792 32 b8 ee			ld (debug_mark+1),a  
8795 3a 9f 87			ld a, (.dmark+2)  
8798 32 b9 ee			ld (debug_mark+2),a  
879b 18 03			jr .pastdmark  
879d ..			.dmark: db "AP6"  
87a0 f1			.pastdmark: pop af  
87a1			endm  
# End of macro DMARK
87a1					CALLMONITOR 
87a1 cd a3 92			call break_point_state  
87a4				endm  
# End of macro CALLMONITOR
87a4				endif 
87a4 cd ec 80				call storage_write_block 
87a7			 
87a7			 
87a7				; was that a full block of data written? 
87a7				; any more to write out? 
87a7			 
87a7				; if yes then set vars and jump to start of function again 
87a7			 
87a7 f1					pop af 
87a8 d1					pop de 
87a9			 
87a9 fe 00				cp 0		 ; no, string was fully written 
87ab c8					ret z 
87ac			 
87ac					; setup vars for next cycle 
87ac			 
87ac 3a db ec				ld a, (store_tmpid) 
87af 6f					ld l, a 
87b0 26 00				ld h, 0 
87b2			 
87b2 c3 69 86			 	jp storage_append	 ; yes, need to write out some more 
87b5			 
87b5			 
87b5			 
87b5			 
87b5			 
87b5			 
87b5			 
87b5			if DEBUG_STORECF 
87b5			storageput:	 
87b5					ret 
87b5			storageread: 
87b5					ld hl, store_page 
87b5					ld b, 200 
87b5					ld a,0 
87b5			.src:		ld (hl),a 
87b5					inc hl 
87b5					djnz .src 
87b5					 
87b5			 
87b5					ld de, 0 
87b5					ld bc, 1 
87b5					ld hl, store_page 
87b5					call cfRead 
87b5			 
87b5				call cfGetError 
87b5				ld hl,scratch 
87b5				call hexout 
87b5				ld hl, scratch+2 
87b5				ld a, 0 
87b5				ld (hl),a 
87b5				ld de, scratch 
87b5				ld a,display_row_1 
87b5				call str_at_display 
87b5				call update_display 
87b5			 
87b5					ld hl, store_page 
87b5					ld (os_cur_ptr),hl 
87b5			 
87b5					ret 
87b5			endif 
87b5			 
87b5			 
87b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
87b5			 
87b5			storage_clear_page: 
87b5 e5				push hl 
87b6 d5				push de 
87b7 c5				push bc 
87b8 21 e2 ec			ld hl, store_page 
87bb 3e 00			ld a, 0 
87bd 77				ld (hl), a 
87be			 
87be 11 e3 ec			ld de, store_page+1 
87c1 01 40 00			ld bc, STORE_BLOCK_PHY 
87c4			 
87c4 ed b0			ldir 
87c6				 
87c6 c1				pop bc 
87c7 d1				pop de 
87c8 e1				pop hl 
87c9 c9				ret 
87ca			 
87ca			; eof 
# End of file firmware_storage.asm
87ca			  
87ca			; support routines for above hardware abstraction layer  
87ca			  
87ca			include "firmware_general.asm"        ; general support functions  
87ca			 
87ca			; word look up 
87ca			 
87ca			; in 
87ca			; a is the index 
87ca			; hl is pointer start of array 
87ca			; 
87ca			; returns 
87ca			; hl to the word 
87ca			; 
87ca			 
87ca			table_lookup:  
87ca d5					push de 
87cb eb					ex de, hl 
87cc			 
87cc 6f					ld l, a 
87cd 26 00				ld h, 0 
87cf 29					add hl, hl 
87d0 19					add hl, de 
87d1 7e					ld a, (hl) 
87d2 23					inc hl 
87d3 66					ld h,(hl) 
87d4 6f					ld l, a 
87d5			 
87d5 d1					pop de 
87d6 c9					ret 
87d7			 
87d7			; Delay loops 
87d7			 
87d7			 
87d7			 
87d7			aDelayInMS: 
87d7 c5				push bc 
87d8 47				ld b,a 
87d9			msdelay: 
87d9 c5				push bc 
87da				 
87da			 
87da 01 41 00			ld bc,041h 
87dd cd f5 87			call delayloop 
87e0 c1				pop bc 
87e1 05				dec b 
87e2 20 f5			jr nz,msdelay 
87e4			 
87e4			;if CPU_CLOCK_8MHZ 
87e4			;msdelay8: 
87e4			;	push bc 
87e4			;	 
87e4			; 
87e4			;	ld bc,041h 
87e4			;	call delayloop 
87e4			;	pop bc 
87e4			;	dec b 
87e4			;	jr nz,msdelay8 
87e4			;endif 
87e4			 
87e4			 
87e4 c1				pop bc 
87e5 c9				ret 
87e6			 
87e6			 
87e6			delay250ms: 
87e6				;push de 
87e6 01 00 40			ld bc, 04000h 
87e9 c3 f5 87			jp delayloop 
87ec			delay500ms: 
87ec				;push de 
87ec 01 00 80			ld bc, 08000h 
87ef c3 f5 87			jp delayloop 
87f2			delay1s: 
87f2				;push bc 
87f2			   ; Clobbers A, d and e 
87f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87f5			delayloop: 
87f5 c5			    push bc 
87f6			 
87f6			if BASE_CPM 
87f6				ld bc, CPM_DELAY_TUNE 
87f6			.cpmloop: 
87f6				push bc 
87f6			 
87f6			endif 
87f6			 
87f6			 
87f6			 
87f6			delayloopi: 
87f6			;	push bc 
87f6			;.dl: 
87f6 cb 47		    bit     0,a    	; 8 
87f8 cb 47		    bit     0,a    	; 8 
87fa cb 47		    bit     0,a    	; 8 
87fc e6 ff		    and     255  	; 7 
87fe 0b			    dec     bc      	; 6 
87ff 79			    ld      a,c     	; 4 
8800 b0			    or      b     	; 4 
8801 c2 f6 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8804			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8804				;pop de 
8804			;pop bc 
8804			 
8804			if BASE_CPM 
8804				pop bc 
8804				 
8804			    dec     bc      	; 6 
8804			    ld      a,c     	; 4 
8804			    or      b     	; 4 
8804			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8804				 
8804			 
8804			endif 
8804			;if CPU_CLOCK_8MHZ 
8804			;    pop bc 
8804			;    push bc 
8804			;.dl8: 
8804			;    bit     0,a    	; 8 
8804			;    bit     0,a    	; 8 
8804			;    bit     0,a    	; 8 
8804			;    and     255  	; 7 
8804			;    dec     bc      	; 6 
8804			;    ld      a,c     	; 4 
8804			;    or      b     	; 4 
8804			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8804			;endif 
8804			 
8804			;if CPU_CLOCK_10MHZ 
8804			;    pop bc 
8804			;    push bc 
8804			;.dl8: 
8804			;    bit     0,a    	; 8 
8804			;    bit     0,a    	; 8 
8804			;    bit     0,a    	; 8 
8804			;    and     255  	; 7 
8804			;    dec     bc      	; 6 
8804			;    ld      a,c     	; 4 
8804			;    or      b     	; 4 
8804			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8804			;endif 
8804 c1			    pop bc 
8805			 
8805 c9				ret 
8806			 
8806			 
8806			 
8806			; eof 
# End of file firmware_general.asm
8806			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8806			; display routines that use the physical hardware abstraction layer 
8806			 
8806			 
8806			; information window 
8806			 
8806			; pass hl with 1st string to display 
8806			; pass de with 2nd string to display 
8806			 
8806			info_panel: 
8806 e5				push hl 
8807			 
8807 2a 58 ed			ld hl, (display_fb_active) 
880a e5				push hl    ; future de destination 
880b 21 4d ee				ld hl, display_fb0 
880e 22 58 ed				ld (display_fb_active), hl 
8811			 
8811			;	call clear_display 
8811			 
8811				if BASE_CPM 
8811				ld a, '.' 
8811				else 
8811 3e a5			ld a, 165 
8813				endif 
8813 cd 7a 88			call fill_display 
8816			 
8816			 
8816 3e 2d			ld a, display_row_3 + 5 
8818 cd 88 88			call str_at_display 
881b			 
881b e1				pop hl 
881c d1				pop de 
881d			 
881d e5				push hl 
881e			 
881e			 
881e 3e 19			ld a, display_row_2 + 5 
8820 cd 88 88			call str_at_display 
8823			 
8823			 
8823 cd 98 88			call update_display 
8826 cd 75 98			call next_page_prompt 
8829 cd 75 88			call clear_display 
882c			 
882c				 
882c 21 fc ed				ld hl, display_fb1 
882f 22 58 ed				ld (display_fb_active), hl 
8832 cd 98 88			call update_display 
8835			 
8835 e1				pop hl 
8836			 
8836 c9				ret 
8837			 
8837			 
8837			 
8837			 
8837			; TODO windowing? 
8837			 
8837			; TODO scroll line up 
8837			 
8837			scroll_up: 
8837			 
8837 e5				push hl 
8838 d5				push de 
8839 c5				push bc 
883a			 
883a				; get frame buffer  
883a			 
883a 2a 58 ed			ld hl, (display_fb_active) 
883d e5				push hl    ; future de destination 
883e			 
883e 11 14 00			ld  de, display_cols 
8841 19				add hl, de 
8842			 
8842 d1				pop de 
8843			 
8843				;ex de, hl 
8843 01 4f 00			ld bc, display_fb_len -1  
8846			;if DEBUG_FORTH_WORDS 
8846			;	DMARK "SCL" 
8846			;	CALLMONITOR 
8846			;endif	 
8846 ed b0			ldir 
8848			 
8848				; wipe bottom row 
8848			 
8848			 
8848 2a 58 ed			ld hl, (display_fb_active) 
884b 11 50 00			ld de, display_cols*display_rows 
884e 19				add hl, de 
884f 06 14			ld b, display_cols 
8851 3e 20			ld a, ' ' 
8853			.scwipe: 
8853 77				ld (hl), a 
8854 2b				dec hl 
8855 10 fc			djnz .scwipe 
8857			 
8857				;pop hl 
8857			 
8857 c1				pop bc 
8858 d1				pop de 
8859 e1				pop hl 
885a			 
885a c9				ret 
885b			 
885b			 
885b			;scroll_upo: 
885b			;	ld de, display_row_1 
885b			 ;	ld hl, display_row_2 
885b			;	ld bc, display_cols 
885b			;	ldir 
885b			;	ld de, display_row_2 
885b			 ;	ld hl, display_row_3 
885b			;	ld bc, display_cols 
885b			;	ldir 
885b			;	ld de, display_row_3 
885b			 ;	ld hl, display_row_4 
885b			;	ld bc, display_cols 
885b			;	ldir 
885b			 
885b			; TODO clear row 4 
885b			 
885b			;	ret 
885b			 
885b				 
885b			scroll_down: 
885b			 
885b e5				push hl 
885c d5				push de 
885d c5				push bc 
885e			 
885e				; get frame buffer  
885e			 
885e 2a 58 ed			ld hl, (display_fb_active) 
8861			 
8861 11 4f 00			ld de, display_fb_len - 1 
8864 19				add hl, de 
8865			 
8865 e5			push hl    ; future de destination 
8866			 
8866 11 14 00			ld  de, display_cols 
8869 ed 52			sbc hl, de 
886b			 
886b			 
886b d1				pop de 
886c			 
886c			;	ex de, hl 
886c 01 4f 00			ld bc, display_fb_len -1  
886f			 
886f			 
886f				 
886f			 
886f ed b0			ldir 
8871			 
8871				; wipe bottom row 
8871			 
8871			 
8871			;	ld hl, (display_fb_active) 
8871			;;	ld de, display_cols*display_rows 
8871			;;	add hl, de 
8871			;	ld b, display_cols 
8871			;	ld a, ' ' 
8871			;.scwiped: 
8871			;	ld (hl), a 
8871			;	dec hl 
8871			;	djnz .scwiped 
8871			 
8871				;pop hl 
8871			 
8871 c1				pop bc 
8872 d1				pop de 
8873 e1				pop hl 
8874			 
8874 c9				ret 
8875			;scroll_down: 
8875			;	ld de, display_row_4 
8875			;	ld hl, display_row_3 
8875			;	ld bc, display_cols 
8875			;	ldir 
8875			;	ld de, display_row_3 
8875			; 	ld hl, display_row_2 
8875			;	ld bc, display_cols 
8875			;	ldir 
8875			;	ld de, display_row_2 
8875			;	ld hl, display_row_1 
8875			;	ld bc, display_cols 
8875			;	ldir 
8875			;;; TODO clear row 1 
8875			;	ret 
8875			 
8875			 
8875			 
8875			 
8875			 
8875			; clear active frame buffer 
8875			 
8875			clear_display: 
8875 3e 20			ld a, ' ' 
8877 c3 7a 88			jp fill_display 
887a			 
887a			; fill active frame buffer with a char in A 
887a			 
887a			fill_display: 
887a 06 50			ld b,display_fb_len 
887c 2a 58 ed			ld hl, (display_fb_active) 
887f 77			.fd1:	ld (hl),a 
8880 23				inc hl 
8881 10 fc			djnz .fd1 
8883 23				inc hl 
8884 3e 00			ld a,0 
8886 77				ld (hl),a 
8887			 
8887			 
8887 c9				ret 
8888			; Write string (DE) at pos (A) to active frame buffer 
8888			 
8888 2a 58 ed		str_at_display:    ld hl,(display_fb_active) 
888b 06 00					ld b,0 
888d 4f					ld c,a 
888e 09					add hl,bc 
888f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8890 b7			            OR   A              ;Null terminator? 
8891 c8			            RET  Z              ;Yes, so finished 
8892 77					ld (hl),a 
8893 23				inc hl 
8894 13			            INC  DE             ;Point to next character 
8895 18 f8		            JR   .sad1     ;Repeat 
8897 c9					ret 
8898			 
8898			; using current frame buffer write to physical display 
8898			 
8898			update_display: 
8898 e5				push hl 
8899 2a 58 ed			ld hl, (display_fb_active) 
889c cd 42 d7			call write_display 
889f e1				pop hl 
88a0 c9				ret 
88a1			 
88a1			; TODO scrolling 
88a1			 
88a1			 
88a1			; move cursor right one char 
88a1			cursor_right: 
88a1			 
88a1				; TODO shift right 
88a1				; TODO if beyond max col 
88a1				; TODO       cursor_next_line 
88a1			 
88a1 c9				ret 
88a2			 
88a2			 
88a2			cursor_next_line: 
88a2				; TODO first char 
88a2				; TODO line down 
88a2				; TODO if past last row 
88a2				; TODO    scroll up 
88a2			 
88a2 c9				ret 
88a3			 
88a3			cursor_left: 
88a3				; TODO shift left 
88a3				; TODO if beyond left  
88a3				; TODO     cursor prev line 
88a3				 
88a3 c9				ret 
88a4			 
88a4			cursor_prev_line: 
88a4				; TODO last char 
88a4				; TODO line up 
88a4				; TODO if past first row 
88a4				; TODO   scroll down 
88a4			 
88a4 c9				ret 
88a5			 
88a5			 
88a5			cout: 
88a5				; A - char 
88a5 c9				ret 
88a6			 
88a6			 
88a6			; Display a menu and allow item selection (optional toggle items) 
88a6			; 
88a6			; format: 
88a6			; hl pointer to word array with zero term for items 
88a6			; e.g.    db item1 
88a6			;         db .... 
88a6			;         db 0 
88a6			; 
88a6			; a = starting menu item  
88a6			; 
88a6			; de = pointer item toggle array   (todo) 
88a6			; 
88a6			; returns item selected in a 1-... 
88a6			; returns 0 if back button pressed 
88a6			; 
88a6			; NOTE: Uses system frame buffer to display 
88a6			; 
88a6			; LEFT, Q = go back 
88a6			; RIGHT, SPACE, CR = select 
88a6			; UP, A - Up 
88a6			; DOWN, Z - Down 
88a6			 
88a6			 
88a6			 
88a6			 
88a6			 
88a6			menu: 
88a6			 
88a6					; keep array pointer 
88a6			 
88a6 22 e0 ec				ld (store_tmp1), hl 
88a9 32 de ec				ld (store_tmp2), a 
88ac			 
88ac					; check for key bounce 
88ac			 
88ac			if BASE_KEV 
88ac			 
88ac			.mbounce:	call cin 
88ac					cp 0 
88ac					jr nz, .mbounce 
88ac			endif 
88ac					; for ease use ex 
88ac			 
88ac					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88ac 21 4d ee				ld hl, display_fb0 
88af 22 58 ed				ld (display_fb_active), hl 
88b2			 
88b2 cd 75 88		.mloop:		call clear_display 
88b5 cd 98 88				call update_display 
88b8			 
88b8					; draw selection id '>' at 1 
88b8			 
88b8					; init start of list display 
88b8			 
88b8 3e 05				ld a, 5 
88ba 32 dc ec				ld (store_tmp3), a   ; display row count 
88bd 3a de ec				ld a,( store_tmp2) 
88c0 32 df ec				ld (store_tmp2+1), a   ; display item count 
88c3			 
88c3					 
88c3			.mitem:	 
88c3			 
88c3			 
88c3 3a df ec				ld a,(store_tmp2+1) 
88c6 6f					ld l, a 
88c7 26 00				ld h, 0 
88c9 29					add hl, hl 
88ca ed 5b e0 ec			ld de, (store_tmp1) 
88ce 19					add hl, de 
88cf 7e					ld a, (hl) 
88d0 23					inc hl 
88d1 66					ld h,(hl) 
88d2 6f					ld l, a 
88d3			 
88d3 cd cb 8a				call ishlzero 
88d6 28 1a				jr z, .mdone 
88d8			 
88d8 eb					ex de, hl 
88d9 3a dc ec				ld a, (store_tmp3) 
88dc cd 88 88				call str_at_display 
88df					 
88df			 
88df					; next item 
88df 3a df ec				ld a, (store_tmp2+1) 
88e2 3c					inc a 
88e3 32 df ec				ld (store_tmp2+1), a   ; display item count 
88e6			 
88e6			 		; next row 
88e6			 
88e6 3a dc ec				ld a, (store_tmp3) 
88e9 c6 14				add display_cols 
88eb 32 dc ec				ld (store_tmp3), a 
88ee			 
88ee					; at end of screen? 
88ee			 
88ee fe 10				cp display_rows*4 
88f0 20 d1				jr nz, .mitem 
88f2			 
88f2			 
88f2			.mdone: 
88f2 cd cb 8a				call ishlzero 
88f5 28 08				jr z, .nodn 
88f7			 
88f7 3e 3c				ld a, display_row_4 
88f9 11 78 89				ld de, .mdown 
88fc cd 88 88				call str_at_display 
88ff			 
88ff					; draw options to fill the screens with active item on line 1 
88ff					; if current option is 2 or more then display ^ in top 
88ff			 
88ff 3a de ec		.nodn:		ld a, (store_tmp2) 
8902 fe 00				cp 0 
8904 28 08				jr z, .noup 
8906			 
8906 3e 00				ld a, 0 
8908 11 76 89				ld de, .mup 
890b cd 88 88				call str_at_display 
890e			 
890e 3e 02		.noup:		ld a, 2 
8910 11 74 89				ld de, .msel 
8913 cd 88 88				call str_at_display 
8916			 
8916					; if current option + 1 is not null then display V in bottom 
8916					; get key 
8916 cd 98 88				call update_display 
8919			 
8919			 
8919					; handle key 
8919			 
8919 cd ce d7				call cin_wait 
891c			 
891c fe 05				cp KEY_UP 
891e 28 2b				jr z, .mgoup 
8920 fe 61				cp 'a' 
8922 28 27				jr z, .mgoup 
8924 fe 0a				cp KEY_DOWN 
8926 28 32				jr z, .mgod 
8928 fe 7a				cp 'z' 
892a 28 2e				jr z, .mgod 
892c fe 20				cp ' ' 
892e 28 34				jr z, .goend 
8930 fe 0c				cp KEY_RIGHT 
8932 28 30				jr z, .goend 
8934 fe 0d				cp KEY_CR 
8936 28 2c				jr z, .goend 
8938 fe 71				cp 'q' 
893a 28 0b				jr z, .goback 
893c			 
893c fe 0b				cp KEY_LEFT 
893e 28 07				jr z, .goback 
8940 fe 08				cp KEY_BS 
8942 28 03				jr z, .goback 
8944 c3 b2 88				jp .mloop 
8947			 
8947			.goback: 
8947 3e 00			ld a, 0 
8949 18 1d			jr .goend2 
894b			 
894b				; move up one 
894b			.mgoup: 
894b 3a de ec				ld a, (store_tmp2) 
894e fe 00				cp 0 
8950 ca b2 88				jp z, .mloop 
8953 3d					dec a 
8954 32 de ec				ld (store_tmp2), a 
8957 c3 b2 88				jp .mloop 
895a			 
895a				; move down one 
895a			.mgod: 
895a 3a de ec				ld a, (store_tmp2) 
895d 3c					inc a 
895e 32 de ec				ld (store_tmp2), a 
8961 c3 b2 88				jp .mloop 
8964			 
8964			 
8964			.goend: 
8964					; get selected item number 
8964			 
8964 3a de ec				ld a, (store_tmp2) 
8967 3c					inc a 
8968			 
8968			.goend2: 
8968 f5					push af 
8969			 
8969					; restore active fb 
8969					; TODO BUG assumes fb1 
8969			 
8969 21 fc ed				ld hl, display_fb1 
896c 22 58 ed				ld (display_fb_active), hl 
896f			 
896f					; restore main regs 
896f			 
896f			 
896f cd 98 88				call update_display 
8972			 
8972 f1					pop af 
8973			 
8973 c9				ret 
8974			 
8974 .. 00		.msel:   db ">",0 
8976 .. 00		.mup:   db "^",0 
8978 .. 00		.mdown:   db "v",0 
897a			 
897a			 
897a			; eof 
897a			 
# End of file firmware_display.asm
897a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
897a			; random number generators 
897a			 
897a			 
897a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
897a			 
897a			 
897a			;-----> Generate a random number 
897a			; output a=answer 0<=a<=255 
897a			; all registers are preserved except: af 
897a			random: 
897a e5			        push    hl 
897b d5			        push    de 
897c 2a 3a ed		        ld      hl,(randData) 
897f ed 5f		        ld      a,r 
8981 57			        ld      d,a 
8982 5e			        ld      e,(hl) 
8983 19			        add     hl,de 
8984 85			        add     a,l 
8985 ac			        xor     h 
8986 22 3a ed		        ld      (randData),hl 
8989 d1			        pop     de 
898a e1			        pop     hl 
898b c9			        ret 
898c			 
898c			 
898c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
898c			 
898c			 
898c			 
898c			;------LFSR------ 
898c			;James Montelongo 
898c			;optimized by Spencer Putt 
898c			;out: 
898c			; a = 8 bit random number 
898c			RandLFSR: 
898c 21 40 ed		        ld hl,LFSRSeed+4 
898f 5e			        ld e,(hl) 
8990 23			        inc hl 
8991 56			        ld d,(hl) 
8992 23			        inc hl 
8993 4e			        ld c,(hl) 
8994 23			        inc hl 
8995 7e			        ld a,(hl) 
8996 47			        ld b,a 
8997 cb 13		        rl e  
8999 cb 12			rl d 
899b cb 11		        rl c  
899d 17				rla 
899e cb 13		        rl e  
89a0 cb 12			rl d 
89a2 cb 11		        rl c  
89a4 17				rla 
89a5 cb 13		        rl e  
89a7 cb 12			rl d 
89a9 cb 11		        rl c  
89ab 17				rla 
89ac 67			        ld h,a 
89ad cb 13		        rl e  
89af cb 12			rl d 
89b1 cb 11		        rl c  
89b3 17				rla 
89b4 a8			        xor b 
89b5 cb 13		        rl e  
89b7 cb 12			rl d 
89b9 ac			        xor h 
89ba a9			        xor c 
89bb aa			        xor d 
89bc 21 42 ed		        ld hl,LFSRSeed+6 
89bf 11 43 ed		        ld de,LFSRSeed+7 
89c2 01 07 00		        ld bc,7 
89c5 ed b8		        lddr 
89c7 12			        ld (de),a 
89c8 c9			        ret 
89c9			 
89c9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89c9			 
89c9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89c9			 
89c9			 
89c9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89c9			 
89c9			prng16: 
89c9			;Inputs: 
89c9			;   (seed1) contains a 16-bit seed value 
89c9			;   (seed2) contains a NON-ZERO 16-bit seed value 
89c9			;Outputs: 
89c9			;   HL is the result 
89c9			;   BC is the result of the LCG, so not that great of quality 
89c9			;   DE is preserved 
89c9			;Destroys: 
89c9			;   AF 
89c9			;cycle: 4,294,901,760 (almost 4.3 billion) 
89c9			;160cc 
89c9			;26 bytes 
89c9 2a 34 ed		    ld hl,(seed1) 
89cc 44			    ld b,h 
89cd 4d			    ld c,l 
89ce 29			    add hl,hl 
89cf 29			    add hl,hl 
89d0 2c			    inc l 
89d1 09			    add hl,bc 
89d2 22 34 ed		    ld (seed1),hl 
89d5 2a 32 ed		    ld hl,(seed2) 
89d8 29			    add hl,hl 
89d9 9f			    sbc a,a 
89da e6 2d		    and %00101101 
89dc ad			    xor l 
89dd 6f			    ld l,a 
89de 22 32 ed		    ld (seed2),hl 
89e1 09			    add hl,bc 
89e2 c9			    ret 
89e3			 
89e3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89e3			 
89e3			rand32: 
89e3			;Inputs: 
89e3			;   (seed1_0) holds the lower 16 bits of the first seed 
89e3			;   (seed1_1) holds the upper 16 bits of the first seed 
89e3			;   (seed2_0) holds the lower 16 bits of the second seed 
89e3			;   (seed2_1) holds the upper 16 bits of the second seed 
89e3			;   **NOTE: seed2 must be non-zero 
89e3			;Outputs: 
89e3			;   HL is the result 
89e3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89e3			;Destroys: 
89e3			;   AF 
89e3			;Tested and passes all CAcert tests 
89e3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89e3			;it has a period of 18,446,744,069,414,584,320 
89e3			;roughly 18.4 quintillion. 
89e3			;LFSR taps: 0,2,6,7  = 11000101 
89e3			;291cc 
89e3			;seed1_0=$+1 
89e3			;    ld hl,12345 
89e3			;seed1_1=$+1 
89e3			;    ld de,6789 
89e3			;    ld b,h 
89e3			;    ld c,l 
89e3			;    add hl,hl \ rl e \ rl d 
89e3			;    add hl,hl \ rl e \ rl d 
89e3			;    inc l 
89e3			;    add hl,bc 
89e3			;    ld (seed1_0),hl 
89e3			;    ld hl,(seed1_1) 
89e3			;    adc hl,de 
89e3			;    ld (seed1_1),hl 
89e3			;    ex de,hl 
89e3			;seed2_0=$+1 
89e3			;    ld hl,9876 
89e3			;seed2_1=$+1 
89e3			;    ld bc,54321 
89e3			;    add hl,hl \ rl c \ rl b 
89e3			;    ld (seed2_1),bc 
89e3			;    sbc a,a 
89e3			;    and %11000101 
89e3			;    xor l 
89e3			;    ld l,a 
89e3			;    ld (seed2_0),hl 
89e3			;    ex de,hl 
89e3			;    add hl,bc 
89e3			;    ret 
89e3			; 
89e3			 
89e3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89e3			; 20 bytes, 86 cycles (excluding ret) 
89e3			 
89e3			; returns   hl = pseudorandom number 
89e3			; corrupts   a 
89e3			 
89e3			; generates 16-bit pseudorandom numbers with a period of 65535 
89e3			; using the xorshift method: 
89e3			 
89e3			; hl ^= hl << 7 
89e3			; hl ^= hl >> 9 
89e3			; hl ^= hl << 8 
89e3			 
89e3			; some alternative shift triplets which also perform well are: 
89e3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89e3			 
89e3			;  org 32768 
89e3			 
89e3			xrnd: 
89e3 2a 38 ed		  ld hl,(xrandc)       ; seed must not be 0 
89e6 3e 00		  ld a,0 
89e8 bd			  cp l 
89e9 20 02		  jr nz, .xrnd1 
89eb 2e 01		  ld l, 1 
89ed			.xrnd1: 
89ed			 
89ed 7c			  ld a,h 
89ee 1f			  rra 
89ef 7d			  ld a,l 
89f0 1f			  rra 
89f1 ac			  xor h 
89f2 67			  ld h,a 
89f3 7d			  ld a,l 
89f4 1f			  rra 
89f5 7c			  ld a,h 
89f6 1f			  rra 
89f7 ad			  xor l 
89f8 6f			  ld l,a 
89f9 ac			  xor h 
89fa 67			  ld h,a 
89fb			 
89fb 22 38 ed		  ld (xrandc),hl 
89fe			 
89fe c9			  ret 
89ff			;  
89ff			 
89ff			 
89ff			;;;; int maths 
89ff			 
89ff			; https://map.grauw.nl/articles/mult_div_shifts.php 
89ff			; Divide 16-bit values (with 16-bit result) 
89ff			; In: Divide BC by divider DE 
89ff			; Out: BC = result, HL = rest 
89ff			; 
89ff			Div16: 
89ff 21 00 00		    ld hl,0 
8a02 78			    ld a,b 
8a03 06 08		    ld b,8 
8a05			Div16_Loop1: 
8a05 17			    rla 
8a06 ed 6a		    adc hl,hl 
8a08 ed 52		    sbc hl,de 
8a0a 30 01		    jr nc,Div16_NoAdd1 
8a0c 19			    add hl,de 
8a0d			Div16_NoAdd1: 
8a0d 10 f6		    djnz Div16_Loop1 
8a0f 17			    rla 
8a10 2f			    cpl 
8a11 47			    ld b,a 
8a12 79			    ld a,c 
8a13 48			    ld c,b 
8a14 06 08		    ld b,8 
8a16			Div16_Loop2: 
8a16 17			    rla 
8a17 ed 6a		    adc hl,hl 
8a19 ed 52		    sbc hl,de 
8a1b 30 01		    jr nc,Div16_NoAdd2 
8a1d 19			    add hl,de 
8a1e			Div16_NoAdd2: 
8a1e 10 f6		    djnz Div16_Loop2 
8a20 17			    rla 
8a21 2f			    cpl 
8a22 41			    ld b,c 
8a23 4f			    ld c,a 
8a24 c9			ret 
8a25			 
8a25			 
8a25			;http://z80-heaven.wikidot.com/math 
8a25			; 
8a25			;Inputs: 
8a25			;     DE and A are factors 
8a25			;Outputs: 
8a25			;     A is not changed 
8a25			;     B is 0 
8a25			;     C is not changed 
8a25			;     DE is not changed 
8a25			;     HL is the product 
8a25			;Time: 
8a25			;     342+6x 
8a25			; 
8a25			Mult16: 
8a25			 
8a25 06 08		     ld b,8          ;7           7 
8a27 21 00 00		     ld hl,0         ;10         10 
8a2a 29			       add hl,hl     ;11*8       88 
8a2b 07			       rlca          ;4*8        32 
8a2c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a2e 19			         add hl,de   ;--         -- 
8a2f 10 f9		       djnz $-5      ;13*7+8     99 
8a31 c9			ret 
8a32			 
8a32			; 
8a32			; Square root of 16-bit value 
8a32			; In:  HL = value 
8a32			; Out:  D = result (rounded down) 
8a32			; 
8a32			;Sqr16: 
8a32			;    ld de,#0040 
8a32			;    ld a,l 
8a32			;    ld l,h 
8a32			;    ld h,d 
8a32			;    or a 
8a32			;    ld b,8 
8a32			;Sqr16_Loop: 
8a32			;    sbc hl,de 
8a32			;    jr nc,Sqr16_Skip 
8a32			;    add hl,de 
8a32			;Sqr16_Skip: 
8a32			;    ccf 
8a32			;    rl d 
8a32			;    add a,a 
8a32			;    adc hl,hl 
8a32			;    add a,a 
8a32			;    adc hl,hl 
8a32			;    djnz Sqr16_Loop 
8a32			;    ret 
8a32			; 
8a32			; 
8a32			; Divide 8-bit values 
8a32			; In: Divide E by divider C 
8a32			; Out: A = result, B = rest 
8a32			; 
8a32			Div8: 
8a32 af			    xor a 
8a33 06 08		    ld b,8 
8a35			Div8_Loop: 
8a35 cb 13		    rl e 
8a37 17			    rla 
8a38 91			    sub c 
8a39 30 01		    jr nc,Div8_NoAdd 
8a3b 81			    add a,c 
8a3c			Div8_NoAdd: 
8a3c 10 f7		    djnz Div8_Loop 
8a3e 47			    ld b,a 
8a3f 7b			    ld a,e 
8a40 17			    rla 
8a41 2f			    cpl 
8a42 c9			    ret 
8a43			 
8a43			; 
8a43			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a43			; In: Multiply A with DE 
8a43			; Out: HL = result 
8a43			; 
8a43			Mult12U: 
8a43 2e 00		    ld l,0 
8a45 87			    add a,a 
8a46 30 01		    jr nc,Mult12U_NoAdd0 
8a48 19			    add hl,de 
8a49			Mult12U_NoAdd0: 
8a49 29			    add hl,hl 
8a4a 87			    add a,a 
8a4b 30 01		    jr nc,Mult12U_NoAdd1 
8a4d 19			    add hl,de 
8a4e			Mult12U_NoAdd1: 
8a4e 29			    add hl,hl 
8a4f 87			    add a,a 
8a50 30 01		    jr nc,Mult12U_NoAdd2 
8a52 19			    add hl,de 
8a53			Mult12U_NoAdd2: 
8a53 29			    add hl,hl 
8a54 87			    add a,a 
8a55 30 01		    jr nc,Mult12U_NoAdd3 
8a57 19			    add hl,de 
8a58			Mult12U_NoAdd3: 
8a58 29			    add hl,hl 
8a59 87			    add a,a 
8a5a 30 01		    jr nc,Mult12U_NoAdd4 
8a5c 19			    add hl,de 
8a5d			Mult12U_NoAdd4: 
8a5d 29			    add hl,hl 
8a5e 87			    add a,a 
8a5f 30 01		    jr nc,Mult12U_NoAdd5 
8a61 19			    add hl,de 
8a62			Mult12U_NoAdd5: 
8a62 29			    add hl,hl 
8a63 87			    add a,a 
8a64 30 01		    jr nc,Mult12U_NoAdd6 
8a66 19			    add hl,de 
8a67			Mult12U_NoAdd6: 
8a67 29			    add hl,hl 
8a68 87			    add a,a 
8a69 d0			    ret nc 
8a6a 19			    add hl,de 
8a6b c9			    ret 
8a6c			 
8a6c			; 
8a6c			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a6c			; In: Multiply A with DE 
8a6c			;      Put lowest value in A for most efficient calculation 
8a6c			; Out: HL = result 
8a6c			; 
8a6c			Mult12R: 
8a6c 21 00 00		    ld hl,0 
8a6f			Mult12R_Loop: 
8a6f cb 3f		    srl a 
8a71 30 01		    jr nc,Mult12R_NoAdd 
8a73 19			    add hl,de 
8a74			Mult12R_NoAdd: 
8a74 cb 23		    sla e 
8a76 cb 12		    rl d 
8a78 b7			    or a 
8a79 c2 6f 8a		    jp nz,Mult12R_Loop 
8a7c c9			    ret 
8a7d			 
8a7d			; 
8a7d			; Multiply 16-bit values (with 32-bit result) 
8a7d			; In: Multiply BC with DE 
8a7d			; Out: BCHL = result 
8a7d			; 
8a7d			Mult32: 
8a7d 79			    ld a,c 
8a7e 48			    ld c,b 
8a7f 21 00 00		    ld hl,0 
8a82 06 10		    ld b,16 
8a84			Mult32_Loop: 
8a84 29			    add hl,hl 
8a85 17			    rla 
8a86 cb 11		    rl c 
8a88 30 07		    jr nc,Mult32_NoAdd 
8a8a 19			    add hl,de 
8a8b ce 00		    adc a,0 
8a8d d2 91 8a		    jp nc,Mult32_NoAdd 
8a90 0c			    inc c 
8a91			Mult32_NoAdd: 
8a91 10 f1		    djnz Mult32_Loop 
8a93 41			    ld b,c 
8a94 4f			    ld c,a 
8a95 c9			    ret 
8a96			 
8a96			 
8a96			 
8a96			; 
8a96			; Multiply 8-bit values 
8a96			; In:  Multiply H with E 
8a96			; Out: HL = result 
8a96			; 
8a96			Mult8: 
8a96 16 00		    ld d,0 
8a98 6a			    ld l,d 
8a99 06 08		    ld b,8 
8a9b			Mult8_Loop: 
8a9b 29			    add hl,hl 
8a9c 30 01		    jr nc,Mult8_NoAdd 
8a9e 19			    add hl,de 
8a9f			Mult8_NoAdd: 
8a9f 10 fa		    djnz Mult8_Loop 
8aa1 c9			    ret 
8aa2			 
8aa2			 
8aa2			 
8aa2			 
8aa2			 
8aa2			 
8aa2			 
8aa2			 
8aa2			;;http://z80-heaven.wikidot.com/math 
8aa2			;;This divides DE by BC, storing the result in DE, remainder in HL 
8aa2			; 
8aa2			;DE_Div_BC:          ;1281-2x, x is at most 16 
8aa2			;     ld a,16        ;7 
8aa2			;     ld hl,0        ;10 
8aa2			;     jp $+5         ;10 
8aa2			;.DivLoop: 
8aa2			;       add hl,bc    ;-- 
8aa2			;       dec a        ;64 
8aa2			;       jr z,.DivLoopEnd        ;86 
8aa2			; 
8aa2			;       sla e        ;128 
8aa2			;       rl d         ;128 
8aa2			;       adc hl,hl    ;240 
8aa2			;       sbc hl,bc    ;240 
8aa2			;       jr nc,.DivLoop ;23|21 
8aa2			;       inc e        ;-- 
8aa2			;       jp .DivLoop+1 
8aa2			; 
8aa2			;.DivLoopEnd: 
8aa2			 
8aa2			;HL_Div_C: 
8aa2			;Inputs: 
8aa2			;     HL is the numerator 
8aa2			;     C is the denominator 
8aa2			;Outputs: 
8aa2			;     A is the remainder 
8aa2			;     B is 0 
8aa2			;     C is not changed 
8aa2			;     DE is not changed 
8aa2			;     HL is the quotient 
8aa2			; 
8aa2			;       ld b,16 
8aa2			;       xor a 
8aa2			;         add hl,hl 
8aa2			;         rla 
8aa2			;         cp c 
8aa2			;         jr c,$+4 
8aa2			;           inc l 
8aa2			;           sub c 
8aa2			;         djnz $-7 
8aa2			 
8aa2			; https://plutiedev.com/z80-add-8bit-to-16bit 
8aa2			 
8aa2			addatohl: 
8aa2 85			    add   a, l    ; A = A+L 
8aa3 6f			    ld    l, a    ; L = A+L 
8aa4 8c			    adc   a, h    ; A = A+L+H+carry 
8aa5 95			    sub   l       ; A = H+carry 
8aa6 67			    ld    h, a    ; H = H+carry 
8aa7 c9			ret 
8aa8			 
8aa8			addatode: 
8aa8 83			    add   a, e    ; A = A+L 
8aa9 5f			    ld    e, a    ; L = A+L 
8aaa 8a			    adc   a, d    ; A = A+L+H+carry 
8aab 93			    sub   e       ; A = H+carry 
8aac 57			    ld    d, a    ; H = H+carry 
8aad c9			ret 
8aae			 
8aae			 
8aae			addatobc: 
8aae 81			    add   a, c    ; A = A+L 
8aaf 4f			    ld    c, a    ; L = A+L 
8ab0 88			    adc   a, b    ; A = A+L+H+carry 
8ab1 91			    sub   c       ; A = H+carry 
8ab2 47			    ld    b, a    ; H = H+carry 
8ab3 c9			ret 
8ab4			 
8ab4			subafromhl: 
8ab4			   ; If A=0 do nothing 
8ab4			    ; Otherwise flip A's sign. Since 
8ab4			    ; the upper byte becomes -1, also 
8ab4			    ; substract 1 from H. 
8ab4 ed 44		    neg 
8ab6 ca bf 8a		    jp    z, Skip 
8ab9 25			    dec   h 
8aba			     
8aba			    ; Now add the low byte as usual 
8aba			    ; Two's complement takes care of 
8aba			    ; ensuring the result is correct 
8aba 85			    add   a, l 
8abb 6f			    ld    l, a 
8abc 8c			    adc   a, h 
8abd 95			    sub   l 
8abe 67			    ld    h, a 
8abf			Skip: 
8abf c9				ret 
8ac0			 
8ac0			 
8ac0			; compare hl and de 
8ac0			; returns:  
8ac0			; if hl = de, z=1, s=0, c0=0 
8ac0			; if hl > de, z=0, s=0, c=0 
8ac0			; if hl < de, z=0, s=1, c=1 
8ac0			cmp16:	 
8ac0 b7				or a 
8ac1 ed 52			sbc hl,de 
8ac3 e0				ret po 
8ac4 7c				ld a,h 
8ac5 1f				rra 
8ac6 ee 40			xor 01000000B 
8ac8 37				scf 
8ac9 8f				adc a,a 
8aca c9				ret 
8acb			 
8acb			 
8acb			; test if hl contains zero   - A is destroyed 
8acb			 
8acb			ishlzero:    
8acb b7				or a     ; reset flags 
8acc 7c				ld a, h 
8acd b5				or l        	 
8ace			 
8ace c9				ret 
8acf			 
8acf			 
8acf			 
8acf			 
8acf			if FORTH_ENABLE_FLOATMATH 
8acf			;include "float/bbcmath.z80" 
8acf			include "float/lpfpcalc.asm" 
8acf			endif 
8acf			 
8acf			 
8acf			; eof 
8acf			 
# End of file firmware_maths.asm
8acf			include "firmware_strings.asm"   ; string handling  
8acf			 
8acf			 
8acf			; TODO string len 
8acf			; input text string, end on cr with zero term 
8acf			; a offset into frame buffer to start prompt 
8acf			; d is max length 
8acf			; e is display size TODO 
8acf			; c is current cursor position 
8acf			; hl is ptr to where string will be stored 
8acf			 
8acf			 
8acf			; TODO check limit of buffer for new inserts 
8acf			; TODO check insert does not push beyond buffer 
8acf			; TODO scroll in a limited display area 
8acf			; TODO scroll whole screen on page wrap 
8acf			 
8acf			 
8acf			; TODO handle KEY_PREVWORD 
8acf			; TODO handle KEY_NEXTWORD 
8acf			; TODO handle KEY_HOME 
8acf			; TODO handle KEY_END 
8acf			; TODO use LCD cursor? 
8acf			 
8acf 32 b0 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8ad2 81					add c 
8ad3 32 ae ee				ld (input_at_cursor),a	; save draw pos of cursor 
8ad6 22 b3 ee				ld (input_start), hl     ; save ptr to buffer 
8ad9 79					ld a, c 
8ada cd a2 8a				call addatohl 
8add 22 b5 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ae0 7a					ld a,d 
8ae1 32 b2 ee			        ld (input_size), a       ; save length of input area 
8ae4 79					ld a, c 
8ae5 32 a1 ee				ld (input_cursor),a      ; init cursor start position  
8ae8 7b					ld a,e 
8ae9 32 b1 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8aec					 
8aec					 
8aec			 
8aec			;		ld a,(input_ptr) 
8aec			;		ld (input_under_cursor),a 	; save what is under the cursor 
8aec			 
8aec			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8aec					; init cursor shape if not set by the cin routines 
8aec 21 50 ed				ld hl, cursor_shape 
8aef 3e ff				ld a, 255 
8af1 77					ld (hl), a 
8af2 23					inc hl 
8af3 3e 00				ld a, 0 
8af5 77					ld (hl), a 
8af6			 
8af6 3e 0f				ld a, CUR_BLINK_RATE 
8af8 32 ac ee				ld (input_cur_flash), a 
8afb 3e 01				ld a, 1 
8afd 32 ab ee				ld (input_cur_onoff),a 
8b00			 
8b00			;	if DEBUG_INPUT 
8b00			;		push af 
8b00			;		ld a, 'I' 
8b00			;		ld (debug_mark),a 
8b00			;		pop af 
8b00			;		CALLMONITOR 
8b00			;	endif 
8b00			.is1:		; main entry loop 
8b00			 
8b00			 
8b00			 
8b00					; pause 1ms 
8b00			 
8b00 3e 01				ld a, 1 
8b02 cd d7 87				call aDelayInMS 
8b05			 
8b05					; dec flash counter 
8b05 3a ac ee				ld a, (input_cur_flash) 
8b08 3d					dec a 
8b09 32 ac ee				ld (input_cur_flash), a 
8b0c fe 00				cp 0 
8b0e 20 0d				jr nz, .nochgstate 
8b10			 
8b10			 
8b10					; change state 
8b10 3a ab ee				ld a,(input_cur_onoff) 
8b13 ed 44				neg 
8b15 32 ab ee				ld (input_cur_onoff),a 
8b18			 
8b18			 
8b18					; reset on change of state 
8b18 3e 0f				ld a, CUR_BLINK_RATE 
8b1a 32 ac ee				ld (input_cur_flash), a 
8b1d			 
8b1d			.nochgstate: 
8b1d					 
8b1d					 
8b1d			 
8b1d					; display cursor  
8b1d			 
8b1d			;		ld hl, (input_start) 
8b1d			;		ld a, (input_cursor) 
8b1d			;		call addatohl 
8b1d			 
8b1d					; get char under cursor and replace with cursor 
8b1d 2a b5 ee		ld hl, (input_ptr) 
8b20			;		ld a, (hl) 
8b20			;		ld (input_under_cursor),a 
8b20			;		ld a, '_' 
8b20			;		ld (hl), a 
8b20			 
8b20					; display string 
8b20			 
8b20 ed 5b b3 ee			ld de, (input_start) 
8b24 3a b0 ee				ld a, (input_at_pos) 
8b27 cd 88 88				call str_at_display 
8b2a			;	        call update_display 
8b2a			 
8b2a					; find place to put the cursor 
8b2a			;		add h 
8b2a			;		ld l, display_row_1 
8b2a			;		sub l 
8b2a			; (input_at_pos) 
8b2a					;ld c, a 
8b2a			;		ld a, (input_cursor) 
8b2a			;		ld l, (input_at_pos) 
8b2a			;		;ld b, h 
8b2a			;		add l 
8b2a			;		ld (input_at_cursor),a 
8b2a					;ld l,h 
8b2a			 
8b2a			;		ld h, 0 
8b2a			;		ld l,(input_at_pos) 
8b2a			;		ld a, (input_cursor) 
8b2a			;		call addatohl 
8b2a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b2a			;		call subafromhl 
8b2a			;		ld a,l 
8b2a			;		ld (input_at_cursor), a 
8b2a			 
8b2a				if DEBUG_INPUT 
8b2a					ld a, (hardware_diag) 
8b2a					cp 0 
8b2a					jr z, .skip_input_diag 
8b2a			 
8b2a					ld a,(input_at_pos) 
8b2a					ld hl, LFSRSeed 
8b2a					call hexout 
8b2a					ld a, (input_cursor) 
8b2a					ld hl, LFSRSeed+2 
8b2a					call hexout 
8b2a					ld a,(input_at_cursor) 
8b2a					ld hl, LFSRSeed+4 
8b2a					call hexout 
8b2a			 
8b2a					ld a,(input_cur_onoff) 
8b2a					ld hl, LFSRSeed+6 
8b2a					call hexout 
8b2a			 
8b2a					ld a,(input_cur_flash) 
8b2a					ld hl, LFSRSeed+8 
8b2a					call hexout 
8b2a			 
8b2a					ld a,(input_len) 
8b2a					ld hl, LFSRSeed+10 
8b2a					call hexout 
8b2a					ld hl, LFSRSeed+12 
8b2a					ld a, 0 
8b2a					ld (hl),a 
8b2a					ld a, display_row_4 
8b2a					ld de, LFSRSeed 
8b2a					call str_at_display 
8b2a					.skip_input_diag: 
8b2a				endif 
8b2a			 
8b2a					; decide on if we are showing the cursor this time round 
8b2a			 
8b2a 3a ab ee				ld a, (input_cur_onoff) 
8b2d fe ff				cp 255 
8b2f 28 13				jr z, .skipcur 
8b31			 
8b31			 
8b31 3a ae ee				ld a,(input_at_cursor) 
8b34 11 50 ed				ld de, cursor_shape 
8b37 cd 88 88				call str_at_display 
8b3a			 
8b3a					; save length of current input string 
8b3a 2a b3 ee				ld hl, (input_start) 
8b3d cd 00 8f				call strlenz 
8b40 7d					ld a,l 
8b41 32 a6 ee				ld (input_len),a 
8b44			 
8b44			.skipcur: 
8b44			 
8b44 cd 98 88			        call update_display 
8b47					 
8b47			 
8b47			 
8b47					; wait 
8b47				 
8b47					; TODO loop without wait to flash the cursor and char under cursor	 
8b47 cd d4 d7				call cin    ; _wait 
8b4a			 
8b4a fe 00				cp 0 
8b4c ca 00 8b				jp z, .is1 
8b4f			 
8b4f					; get ptr to char to input into 
8b4f			 
8b4f 4f					ld c,a 
8b50 2a b3 ee				ld hl, (input_start) 
8b53 3a a1 ee				ld a, (input_cursor) 
8b56 cd a2 8a				call addatohl 
8b59 22 b5 ee				ld (input_ptr), hl 
8b5c 79					ld a,c 
8b5d			 
8b5d					; replace char under cursor 
8b5d			 
8b5d			;		ld hl, (input_ptr) 
8b5d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b5d			;		ld (hl), a 
8b5d			 
8b5d			;	if DEBUG_INPUT 
8b5d			;		push af 
8b5d			;		ld a, 'i' 
8b5d			;		ld (debug_mark),a 
8b5d			;		pop af 
8b5d			;		CALLMONITOR 
8b5d			;	endif 
8b5d fe 0e				cp KEY_HOME 
8b5f 20 0e				jr nz, .iske 
8b61			 
8b61 3a b0 ee				ld a, (input_at_pos) 
8b64 32 ae ee				ld (input_at_cursor),a 
8b67 3e 00				ld a, 0 
8b69 32 a1 ee				ld (input_cursor), a 
8b6c c3 00 8b				jp .is1 
8b6f					 
8b6f fe 0f		.iske:		cp KEY_END 
8b71 20 03				jr nz, .isknw 
8b73 c3 00 8b				jp .is1 
8b76			 
8b76 fe 06		.isknw:		cp KEY_NEXTWORD 
8b78 20 1b				jr nz, .iskpw 
8b7a			 
8b7a 2a b5 ee		.isknwm:	ld hl, (input_ptr) 
8b7d 7e					ld a,(hl)	 
8b7e fe 00				cp 0 
8b80 ca 00 8b				jp z, .is1    ; end of string 
8b83 fe 20				cp ' ' 
8b85 ca 00 8b				jp z, .is1    ; end of word 
8b88 23					inc hl 
8b89 22 b5 ee				ld (input_ptr), hl 
8b8c 3a ae ee				ld a, (input_at_cursor) 
8b8f 3c					inc a 
8b90 32 ae ee				ld (input_at_cursor), a 
8b93 18 e5				jr .isknwm 
8b95			 
8b95 fe 07		.iskpw:		cp KEY_PREVWORD 
8b97 20 1b				jr nz, .iskl 
8b99			.iskpwm:	 
8b99 2a b5 ee				ld hl, (input_ptr) 
8b9c 7e					ld a,(hl)	 
8b9d fe 00				cp 0  
8b9f ca 00 8b				jp z, .is1    ; end of string 
8ba2 fe 20				cp ' ' 
8ba4 ca 00 8b				jp z, .is1    ; end of word 
8ba7 2b					dec hl 
8ba8 22 b5 ee				ld (input_ptr), hl 
8bab 3a ae ee				ld a, (input_at_cursor) 
8bae 3d					dec a 
8baf 32 ae ee				ld (input_at_cursor), a 
8bb2 18 e5				jr .iskpwm 
8bb4			 
8bb4			 
8bb4 fe 0b		.iskl:		cp KEY_LEFT 
8bb6 20 27				jr nz, .isk1 
8bb8			 
8bb8 3a a1 ee				ld a, (input_cursor) 
8bbb			 
8bbb fe 00				cp 0 
8bbd ca 00 8b				jp z, .is1 		; at start of line to ignore  
8bc0			 
8bc0 3d					dec  a 		; TODO check underflow 
8bc1 32 a1 ee				ld (input_cursor), a 
8bc4			 
8bc4 2a b5 ee				ld hl, (input_ptr) 
8bc7 2b					dec hl 
8bc8 22 b5 ee				ld (input_ptr), hl 
8bcb					 
8bcb 3a ae ee				ld a, (input_at_cursor) 
8bce 3d					dec a 
8bcf 32 ae ee				ld (input_at_cursor), a 
8bd2			 
8bd2 3e 01				ld a, 1		; show cursor moving 
8bd4 32 ab ee				ld (input_cur_onoff),a 
8bd7 3e 0f				ld a, CUR_BLINK_RATE 
8bd9 32 ac ee				ld (input_cur_flash), a 
8bdc			 
8bdc c3 00 8b				jp .is1 
8bdf			 
8bdf fe 0c		.isk1:		cp KEY_RIGHT 
8be1 20 2a				jr nz, .isk2 
8be3			 
8be3 3a a6 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8be6 5f					ld e,a 
8be7 3a a1 ee				ld a, (input_cursor) 
8bea bb					cp e 
8beb ca 00 8b				jp z, .is1		; at the end of string so dont go right 
8bee			 
8bee 3c					inc  a 		; TODO check overflow 
8bef 32 a1 ee				ld (input_cursor), a 
8bf2			 
8bf2 3a ae ee				ld a, (input_at_cursor) 
8bf5 3c					inc a 
8bf6 32 ae ee				ld (input_at_cursor), a 
8bf9			 
8bf9 2a b5 ee				ld hl, (input_ptr) 
8bfc 23					inc hl 
8bfd 22 b5 ee				ld (input_ptr), hl 
8c00			 
8c00 3e 01				ld a, 1		; show cursor moving 
8c02 32 ab ee				ld (input_cur_onoff),a 
8c05 3e 0f				ld a, CUR_BLINK_RATE 
8c07 32 ac ee				ld (input_cur_flash), a 
8c0a			 
8c0a c3 00 8b				jp .is1 
8c0d			 
8c0d fe 05		.isk2:		cp KEY_UP 
8c0f			 
8c0f 20 26				jr nz, .isk3 
8c11			 
8c11					; swap last command with the current on 
8c11			 
8c11					; move cursor to start of string 
8c11 2a b3 ee				ld hl, (input_start) 
8c14 22 b5 ee				ld (input_ptr), hl 
8c17			 
8c17 3a b0 ee				ld a, (input_at_pos) 
8c1a 32 ae ee				ld (input_at_cursor), a 
8c1d			 
8c1d 3e 00				ld a, 0 
8c1f 32 a1 ee				ld (input_cursor), a 
8c22					 
8c22					; swap input and last command buffers 
8c22			 
8c22 21 04 e8				ld hl, os_cli_cmd 
8c25 11 03 e9				ld de, os_last_cmd 
8c28 06 ff				ld b, 255 
8c2a 7e			.swap1:		ld a, (hl) 
8c2b 4f					ld c,a 
8c2c 1a					ld a, (de) 
8c2d 77					ld (hl), a 
8c2e 79					ld a,c 
8c2f 12					ld (de),a 
8c30 23					inc hl 
8c31 13					inc de 
8c32 10 f6				djnz .swap1 
8c34			 
8c34			 
8c34			 
8c34			 
8c34			 
8c34 c3 00 8b				jp .is1 
8c37			 
8c37 fe 08		.isk3:		cp KEY_BS 
8c39 20 3c				jr nz, .isk4 
8c3b			 
8c3b 3a a1 ee				ld a, (input_cursor) 
8c3e			 
8c3e fe 00				cp 0 
8c40 ca 00 8b				jp z, .is1 		; at start of line to ignore  
8c43			 
8c43 3d					dec  a 		; TODO check underflow 
8c44 32 a1 ee				ld (input_cursor), a 
8c47			 
8c47					; hl is source 
8c47					; de needs to be source - 1 
8c47			 
8c47			;		ld a, 0 
8c47			;		dec hl 
8c47			;		ld (hl), a 
8c47			 
8c47 2a b5 ee				ld hl, (input_ptr) 
8c4a 2b					dec hl 
8c4b 22 b5 ee				ld (input_ptr), hl 
8c4e			 
8c4e					; shift all data 
8c4e			 
8c4e e5					push hl 
8c4f 23					inc hl 
8c50 d1					pop de 
8c51 3a a6 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c54 4f					ld c,a 
8c55 06 00				ld b,0 
8c57 ed b0				ldir  
8c59			 
8c59			 
8c59			 
8c59			 
8c59 3a ae ee				ld a, (input_at_cursor) 
8c5c 3d					dec a 
8c5d 32 ae ee				ld (input_at_cursor), a 
8c60			 
8c60			 
8c60 3e 01				ld a, 1		; show cursor moving 
8c62 32 ab ee				ld (input_cur_onoff),a 
8c65 3e 0f				ld a, CUR_BLINK_RATE 
8c67 32 ac ee				ld (input_cur_flash), a 
8c6a			 
8c6a					; remove char 
8c6a 3a ae ee				ld a, (input_at_cursor) 
8c6d 3c					inc a 
8c6e 11 f8 8c				ld de,.iblank 
8c71 cd 88 88				call str_at_display 
8c74			 
8c74 c3 00 8b				jp .is1 
8c77			 
8c77 fe 0d		.isk4:		cp KEY_CR 
8c79 28 6c				jr z, .endinput 
8c7b			 
8c7b					; else add the key press to the end 
8c7b			 
8c7b 4f					ld c, a			; save key pressed 
8c7c			 
8c7c 7e					ld a,(hl)		; get what is currently under char 
8c7d			 
8c7d fe 00				cp 0			; we are at the end of the string 
8c7f 20 2f				jr nz, .onchar 
8c81					 
8c81					; add a char to the end of the string 
8c81				 
8c81 71					ld (hl),c 
8c82 23					inc hl 
8c83			;		ld a,' ' 
8c83			;		ld (hl),a 
8c83			;		inc hl 
8c83 3e 00				ld a,0 
8c85 77					ld (hl),a 
8c86 2b					dec hl 
8c87			 
8c87 3a a1 ee				ld a, (input_cursor) 
8c8a 3c					inc a				; TODO check max string length and scroll  
8c8b 32 a1 ee				ld (input_cursor), a		; inc cursor pos 
8c8e							 
8c8e 3a ae ee				ld a, (input_at_cursor) 
8c91 3c					inc a 
8c92 32 ae ee				ld (input_at_cursor), a 
8c95			 
8c95 2a b5 ee				ld hl, (input_ptr) 
8c98 23					inc hl 
8c99 22 b5 ee				ld (input_ptr), hl 
8c9c			 
8c9c 2a b5 ee				ld hl, (input_ptr) 
8c9f 23					inc hl 
8ca0 22 b5 ee				ld (input_ptr), hl 
8ca3			;	if DEBUG_INPUT 
8ca3			;		push af 
8ca3			;		ld a, '+' 
8ca3			;		ld (debug_mark),a 
8ca3			;		pop af 
8ca3			;		CALLMONITOR 
8ca3			;	endif 
8ca3 3e 01				ld a, 1		; show cursor moving 
8ca5 32 ab ee				ld (input_cur_onoff),a 
8ca8 3e 0f				ld a, CUR_BLINK_RATE 
8caa 32 ac ee				ld (input_cur_flash), a 
8cad c3 00 8b				jp .is1 
8cb0					 
8cb0			 
8cb0			 
8cb0					; if on a char then insert 
8cb0			.onchar: 
8cb0			 
8cb0					; TODO over flow check: make sure insert does not blow out buffer 
8cb0			 
8cb0					; need to do some maths to use lddr 
8cb0			 
8cb0 e5					push hl   ; save char pos 
8cb1 c5					push bc 
8cb2			 
8cb2 2a b3 ee				ld hl, (input_start) 
8cb5 3a a6 ee				ld a, (input_len) 
8cb8 cd a2 8a				call addatohl  		; end of string 
8cbb 23					inc hl 
8cbc 23					inc hl		; past zero term 
8cbd e5					push hl 
8cbe 23					inc hl 
8cbf e5					push hl  
8cc0			 
8cc0								; start and end of lddr set, now how much to move? 
8cc0			 
8cc0							 
8cc0 3a a1 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cc3 47					ld b,a 
8cc4 3a a6 ee				ld a,(input_len) 
8cc7 5f					ld e,a 
8cc8 90					sub b 
8cc9 3c					inc a		;?? 
8cca 3c					inc a		;?? 
8ccb 3c					inc a		;?? 
8ccc			 
8ccc 06 00				ld b,0 
8cce 4f					ld c,a 
8ccf			 
8ccf				if DEBUG_INPUT 
8ccf					push af 
8ccf					ld a, 'i' 
8ccf					ld (debug_mark),a 
8ccf					pop af 
8ccf			;		CALLMONITOR 
8ccf				endif 
8ccf d1					pop de 
8cd0 e1					pop hl 
8cd1				if DEBUG_INPUT 
8cd1					push af 
8cd1					ld a, 'I' 
8cd1					ld (debug_mark),a 
8cd1					pop af 
8cd1			;		CALLMONITOR 
8cd1				endif 
8cd1 ed b8				lddr 
8cd3				 
8cd3			 
8cd3			 
8cd3					; TODO have a key for insert/overwrite mode???? 
8cd3 c1					pop bc 
8cd4 e1					pop hl 
8cd5 71					ld (hl), c		; otherwise overwrite current char 
8cd6					 
8cd6			 
8cd6			 
8cd6			 
8cd6 3a a1 ee				ld a, (input_cursor) 
8cd9 3c					inc  a 		; TODO check overflow 
8cda 32 a1 ee				ld (input_cursor), a 
8cdd			 
8cdd 3a ae ee				ld a, (input_at_cursor) 
8ce0 3c					inc a 
8ce1 32 ae ee				ld (input_at_cursor), a 
8ce4			 
8ce4 c3 00 8b				jp .is1 
8ce7			 
8ce7			.endinput:	; TODO look for end of string 
8ce7			 
8ce7					; add trailing space for end of token 
8ce7			 
8ce7 2a b3 ee				ld hl, (input_start) 
8cea 3a a6 ee				ld a,(input_len) 
8ced cd a2 8a				call addatohl 
8cf0 3e 20				ld a, ' ' 
8cf2 77					ld (hl),a 
8cf3					; TODO eof of parse marker 
8cf3			 
8cf3 23					inc hl 
8cf4 3e 00				ld a, 0 
8cf6 77					ld (hl),a 
8cf7			 
8cf7			 
8cf7 c9					ret 
8cf8			 
8cf8 .. 00		.iblank: db " ",0 
8cfa			 
8cfa			 
8cfa 32 b0 ee		input_str_prev:	ld (input_at_pos), a 
8cfd 22 b3 ee				ld (input_start), hl 
8d00 3e 01				ld a,1			; add cursor 
8d02 77					ld (hl),a 
8d03 23					inc hl 
8d04 3e 00				ld a,0 
8d06 77					ld (hl),a 
8d07 22 b5 ee				ld (input_ptr), hl 
8d0a 7a					ld a,d 
8d0b 32 b2 ee				ld (input_size), a 
8d0e 3e 00				ld a,0 
8d10 32 a1 ee				ld (input_cursor),a 
8d13			.instr1:	 
8d13			 
8d13					; TODO do block cursor 
8d13					; TODO switch cursor depending on the modifer key 
8d13			 
8d13					; update cursor shape change on key hold 
8d13			 
8d13 2a b5 ee				ld hl, (input_ptr) 
8d16 2b					dec hl 
8d17 3a 50 ed				ld a,(cursor_shape) 
8d1a 77					ld (hl), a 
8d1b			 
8d1b					; display entered text 
8d1b 3a b0 ee				ld a,(input_at_pos) 
8d1e cd 32 d7		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d21 ed 5b b3 ee	            	LD   de, (input_start) 
8d25 cd 2c d7		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d28			 
8d28 cd d4 d7				call cin 
8d2b fe 00				cp 0 
8d2d 28 e4				jr z, .instr1 
8d2f			 
8d2f					; proecess keyboard controls first 
8d2f			 
8d2f 2a b5 ee				ld hl,(input_ptr) 
8d32			 
8d32 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d34 28 5a				jr z, .instrcr 
8d36			 
8d36 fe 08				cp KEY_BS 	; back space 
8d38 20 0f				jr nz, .instr2 
8d3a					; process back space 
8d3a			 
8d3a					; TODO stop back space if at start of string 
8d3a 2b					dec hl 
8d3b 2b					dec hl ; to over write cursor 
8d3c 3a 50 ed				ld a,(cursor_shape) 
8d3f					;ld a,0 
8d3f 77					ld (hl),a 
8d40 23					inc hl 
8d41 3e 20				ld a," " 
8d43 77					ld (hl),a 
8d44 22 b5 ee				ld (input_ptr),hl 
8d47					 
8d47			 
8d47 18 ca				jr .instr1 
8d49			 
8d49 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d4b 20 06				jr nz, .instr3 
8d4d 2b					dec hl 
8d4e 22 b5 ee				ld (input_ptr),hl 
8d51 18 c0				jr .instr1 
8d53				 
8d53 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d55 20 06				jr nz, .instr4 
8d57 23					inc hl 
8d58 22 b5 ee				ld (input_ptr),hl 
8d5b 18 b6				jr .instr1 
8d5d			 
8d5d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d5f 20 06				jr nz, .instr5 
8d61 2b					dec hl 
8d62 22 b5 ee				ld (input_ptr),hl 
8d65 18 ac				jr .instr1 
8d67			 
8d67 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d69 20 06				jr nz, .instr6 
8d6b 2b					dec hl 
8d6c 22 b5 ee				ld (input_ptr),hl 
8d6f 18 a2				jr .instr1 
8d71 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d73 20 0b				jr nz, .instrnew 
8d75			 
8d75 21 dd e4			ld hl, scratch 
8d78 11 03 e9			ld de, os_last_cmd 
8d7b cd 99 8d			call strcpy 
8d7e 18 93				jr .instr1 
8d80			 
8d80			 
8d80			.instrnew:	; no special key pressed to see if we have room to store it 
8d80			 
8d80					; TODO do string size test 
8d80			 
8d80 2b					dec hl ; to over write cursor 
8d81 77					ld (hl),a 
8d82 23					inc hl 
8d83 3a 50 ed				ld a,(cursor_shape) 
8d86 77					ld (hl),a 
8d87 23					inc hl 
8d88 3e 00				ld a,0 
8d8a 77					ld (hl),a 
8d8b			 
8d8b 22 b5 ee				ld (input_ptr),hl 
8d8e					 
8d8e 18 83				jr .instr1 
8d90 2b			.instrcr:	dec hl		; remove cursor 
8d91 3e 20				ld a,' '	; TODO add a trailing space for safety 
8d93 77					ld (hl),a 
8d94 23					inc hl 
8d95 3e 00				ld a,0 
8d97 77					ld (hl),a 
8d98			 
8d98			 
8d98					; if at end of line scroll up    
8d98					; TODO detecting only end of line 4 for scroll up  
8d98			 
8d98					;ld   
8d98			 
8d98 c9					ret 
8d99			 
8d99			 
8d99			; strcpy hl = dest, de source 
8d99			 
8d99 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8d9a b7			            OR   A              ;Null terminator? 
8d9b c8			            RET  Z              ;Yes, so finished 
8d9c 1a					ld a,(de) 
8d9d 77					ld (hl),a 
8d9e 13			            INC  DE             ;Point to next character 
8d9f 23					inc hl 
8da0 18 f7		            JR   strcpy       ;Repeat 
8da2 c9					ret 
8da3			 
8da3			 
8da3			; TODO string_at  
8da3			; pass string which starts with lcd offset address and then null term string 
8da3			 
8da3			; TODO string to dec 
8da3			; TODO string to hex 
8da3			; TODO byte to string hex 
8da3			; TODO byte to string dec 
8da3			 
8da3			 
8da3			 
8da3			; from z80uartmonitor 
8da3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8da3			; pass hl for where to put the text 
8da3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da3 c5			hexout:	PUSH BC 
8da4 f5					PUSH AF 
8da5 47					LD B, A 
8da6					; Upper nybble 
8da6 cb 3f				SRL A 
8da8 cb 3f				SRL A 
8daa cb 3f				SRL A 
8dac cb 3f				SRL A 
8dae cd be 8d				CALL tohex 
8db1 77					ld (hl),a 
8db2 23					inc hl	 
8db3					 
8db3					; Lower nybble 
8db3 78					LD A, B 
8db4 e6 0f				AND 0FH 
8db6 cd be 8d				CALL tohex 
8db9 77					ld (hl),a 
8dba 23					inc hl	 
8dbb					 
8dbb f1					POP AF 
8dbc c1					POP BC 
8dbd c9					RET 
8dbe					 
8dbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbe			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbe			tohex: 
8dbe e5					PUSH HL 
8dbf d5					PUSH DE 
8dc0 16 00				LD D, 0 
8dc2 5f					LD E, A 
8dc3 21 cb 8d				LD HL, .DATA 
8dc6 19					ADD HL, DE 
8dc7 7e					LD A, (HL) 
8dc8 d1					POP DE 
8dc9 e1					POP HL 
8dca c9					RET 
8dcb			 
8dcb			.DATA: 
8dcb 30					DEFB	30h	; 0 
8dcc 31					DEFB	31h	; 1 
8dcd 32					DEFB	32h	; 2 
8dce 33					DEFB	33h	; 3 
8dcf 34					DEFB	34h	; 4 
8dd0 35					DEFB	35h	; 5 
8dd1 36					DEFB	36h	; 6 
8dd2 37					DEFB	37h	; 7 
8dd3 38					DEFB	38h	; 8 
8dd4 39					DEFB	39h	; 9 
8dd5 41					DEFB	41h	; A 
8dd6 42					DEFB	42h	; B 
8dd7 43					DEFB	43h	; C 
8dd8 44					DEFB	44h	; D 
8dd9 45					DEFB	45h	; E 
8dda 46					DEFB	46h	; F 
8ddb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8ddb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8ddb			;;    subtract $30, if result > 9 then subtract $7 more 
8ddb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8ddb			atohex: 
8ddb d6 30				SUB $30 
8ddd fe 0a				CP 10 
8ddf f8					RET M		; If result negative it was 0-9 so we're done 
8de0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8de2 c9					RET		 
8de3			 
8de3			 
8de3			 
8de3			 
8de3			; Get 2 ASCII characters as hex byte from pointer in hl 
8de3			 
8de3			BYTERD: 
8de3 16 00			LD	D,00h		;Set up 
8de5 cd ed 8d			CALL	HEXCON		;Get byte and convert to hex 
8de8 87				ADD	A,A		;First nibble so 
8de9 87				ADD	A,A		;multiply by 16 
8dea 87				ADD	A,A		; 
8deb 87				ADD	A,A		; 
8dec 57				LD	D,A		;Save hi nibble in D 
8ded			HEXCON: 
8ded 7e				ld a, (hl)		;Get next chr 
8dee 23				inc hl 
8def d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8df1 fe 0a			CP	00Ah		;Is it 0-9 ? 
8df3 38 02			JR	C,NALPHA	;If so miss next bit 
8df5 d6 07			SUB	007h		;Else convert alpha 
8df7			NALPHA: 
8df7 b2				OR	D		;Add hi nibble back 
8df8 c9				RET			; 
8df9			 
8df9			 
8df9			; 
8df9			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8df9			; Since the routines get_byte and therefore get_nibble are called, only valid 
8df9			; characters (0-9a-f) are accepted. 
8df9			; 
8df9			;get_word        push    af 
8df9			;                call    get_byte        ; Get the upper byte 
8df9			;                ld      h, a 
8df9			;                call    get_byte        ; Get the lower byte 
8df9			;                ld      l, a 
8df9			;                pop     af 
8df9			;                ret 
8df9			; 
8df9			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8df9			; the routine get_nibble is used only valid characters are accepted - the  
8df9			; input routine only accepts characters 0-9a-f. 
8df9			; 
8df9 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8dfa 7e					ld a,(hl) 
8dfb 23					inc hl 
8dfc cd 21 8e		                call    nibble2val      ; Get upper nibble 
8dff cb 07		                rlc     a 
8e01 cb 07		                rlc     a 
8e03 cb 07		                rlc     a 
8e05 cb 07		                rlc     a 
8e07 47			                ld      b, a            ; Save upper four bits 
8e08 7e					ld a,(hl) 
8e09 cd 21 8e		                call    nibble2val      ; Get lower nibble 
8e0c b0			                or      b               ; Combine both nibbles 
8e0d c1			                pop     bc              ; Restore B (and C) 
8e0e c9			                ret 
8e0f			; 
8e0f			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e0f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e0f			; to the serial line interface. The lower 4 bits of A contain the value of  
8e0f			; that particular digit. 
8e0f			; 
8e0f			;get_nibble      ld a,(hl)           ; Read a character 
8e0f			;                call    to_upper        ; Convert to upper case 
8e0f			;                call    is_hex          ; Was it a hex digit? 
8e0f			;                jr      nc, get_nibble  ; No, get another character 
8e0f			 ;               call    nibble2val      ; Convert nibble to value 
8e0f			 ;               call    print_nibble 
8e0f			 ;               ret 
8e0f			; 
8e0f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e0f			; A valid hexadecimal digit is denoted by a set C flag. 
8e0f			; 
8e0f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e0f			;                ret     nc              ; Yes 
8e0f			;                cp      '0'             ; Less than '0'? 
8e0f			;                jr      nc, is_hex_1    ; No, continue 
8e0f			;                ccf                     ; Complement carry (i.e. clear it) 
8e0f			;                ret 
8e0f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e0f			;                ret     c               ; Yes 
8e0f			;                cp      'A'             ; Less than 'A'? 
8e0f			;                jr      nc, is_hex_2    ; No, continue 
8e0f			;                ccf                     ; Yes - clear carry and return 
8e0f			;                ret 
8e0f			;is_hex_2        scf                     ; Set carry 
8e0f			;                ret 
8e0f			; 
8e0f			; Convert a single character contained in A to upper case: 
8e0f			; 
8e0f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e11 d8			                ret     c 
8e12 fe 7b		                cp      'z' + 1         ; > 'z'? 
8e14 d0			                ret     nc              ; Nothing to do, either 
8e15 e6 5f		                and     $5f             ; Convert to upper case 
8e17 c9			                ret 
8e18			 
8e18			 
8e18			to_lower: 
8e18			 
8e18			   ; if char is in [A-Z] make it lower case 
8e18			 
8e18			   ; enter : a = char 
8e18			   ; exit  : a = lower case char 
8e18			   ; uses  : af 
8e18			 
8e18 fe 41		   cp 'A' 
8e1a d8			   ret c 
8e1b			    
8e1b fe 5b		   cp 'Z'+1 
8e1d d0			   ret nc 
8e1e			    
8e1e f6 20		   or $20 
8e20 c9			   ret 
8e21			 
8e21			; 
8e21			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e21			; corresponding value in A. 
8e21			; 
8e21 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e23 38 02		                jr      c, nibble2val_1 ; Yes 
8e25 d6 07		                sub     7               ; Adjust for A-F 
8e27 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e29 e6 0f		                and     $f              ; Only return lower 4 bits 
8e2b c9			                ret 
8e2c			; 
8e2c			; Print_nibble prints a single hex nibble which is contained in the lower  
8e2c			; four bits of A: 
8e2c			; 
8e2c			;print_nibble    push    af              ; We won't destroy the contents of A 
8e2c			;                and     $f              ; Just in case... 
8e2c			;                add     a, '0'             ; If we have a digit we are done here. 
8e2c			;                cp      '9' + 1         ; Is the result > 9? 
8e2c			;                jr      c, print_nibble_1 
8e2c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e2c			;print_nibble_1  call    putc            ; Print the nibble and 
8e2c			;                pop     af              ; restore the original value of A 
8e2c			;                ret 
8e2c			;; 
8e2c			;; Send a CR/LF pair: 
8e2c			; 
8e2c			;crlf            push    af 
8e2c			;                ld      a, cr 
8e2c			;                call    putc 
8e2c			;                ld      a, lf 
8e2c			;                call    putc 
8e2c			;                pop     af 
8e2c			;                ret 
8e2c			; 
8e2c			; Print_word prints the four hex digits of a word to the serial line. The  
8e2c			; word is expected to be in HL. 
8e2c			; 
8e2c			;print_word      push    hl 
8e2c			;                push    af 
8e2c			;                ld      a, h 
8e2c			;                call    print_byte 
8e2c			;                ld      a, l 
8e2c			;                call    print_byte 
8e2c			;                pop     af 
8e2c			;                pop     hl 
8e2c			;                ret 
8e2c			; 
8e2c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e2c			; The byte to be printed is expected to be in A. 
8e2c			; 
8e2c			;print_byte      push    af              ; Save the contents of the registers 
8e2c			;                push    bc 
8e2c			;                ld      b, a 
8e2c			;                rrca 
8e2c			;                rrca 
8e2c			;                rrca 
8e2c			;                rrca 
8e2c			;                call    print_nibble    ; Print high nibble 
8e2c			;                ld      a, b 
8e2c			;                call    print_nibble    ; Print low nibble 
8e2c			;                pop     bc              ; Restore original register contents 
8e2c			;                pop     af 
8e2c			;                ret 
8e2c			 
8e2c			 
8e2c			 
8e2c			 
8e2c			 
8e2c			fourehexhl:  
8e2c 7e				ld a,(hl) 
8e2d cd db 8d			call atohex 
8e30 cb 3f				SRL A 
8e32 cb 3f				SRL A 
8e34 cb 3f				SRL A 
8e36 cb 3f				SRL A 
8e38 47				ld b, a 
8e39 23				inc hl 
8e3a 7e				ld a,(hl) 
8e3b 23				inc hl 
8e3c cd db 8d			call atohex 
8e3f 80				add b 
8e40 57				ld d,a 
8e41 7e				ld a,(hl) 
8e42 cd db 8d			call atohex 
8e45 cb 3f				SRL A 
8e47 cb 3f				SRL A 
8e49 cb 3f				SRL A 
8e4b cb 3f				SRL A 
8e4d 47				ld b, a 
8e4e 23				inc hl 
8e4f 7e				ld a,(hl) 
8e50 23				inc hl 
8e51 cd db 8d			call atohex 
8e54 80				add b 
8e55 5f				ld e, a 
8e56 d5				push de 
8e57 e1				pop hl 
8e58 c9				ret 
8e59			 
8e59			; pass hl. returns z set if the byte at hl is a digit 
8e59			;isdigithl:  
8e59			;	push bc 
8e59			;	ld a,(hl) 
8e59			;	cp ':' 
8e59			;	jr nc, .isdf 		; > 
8e59			;	cp '0' 
8e59			;	jr c, .isdf		; < 
8e59			; 
8e59			;	; TODO find a better way to set z 
8e59			; 
8e59			;	ld b,a 
8e59			;	cp b 
8e59			;	pop bc 
8e59			;	ret 
8e59			; 
8e59			;.isdf:	; not digit so clear z 
8e59			; 
8e59			;	; TODO find a better way to unset z 
8e59			; 
8e59			;	ld b,a 
8e59			;	inc b 
8e59			;	cp b 
8e59			; 
8e59			;	pop bc 
8e59			;	ret 
8e59				 
8e59				 
8e59			 
8e59			 
8e59			; pass hl as the four byte address to load 
8e59			 
8e59			get_word_hl:  
8e59 e5				push hl 
8e5a cd f9 8d			call get_byte 
8e5d				 
8e5d 47				ld b, a 
8e5e			 
8e5e e1				pop hl 
8e5f 23				inc hl 
8e60 23				inc hl 
8e61			 
8e61			; TODO not able to handle a-f  
8e61 7e				ld a,(hl) 
8e62			;	;cp ':' 
8e62			;	cp 'g' 
8e62			;	jr nc, .single_byte_hl 		; > 
8e62			;	cp 'G' 
8e62			;	jr nc, .single_byte_hl 		; > 
8e62			;	cp '0' 
8e62			;	jr c, .single_byte_hl		; < 
8e62			 
8e62				;call isdigithl 
8e62 fe 00			cp 0 
8e64 28 06			jr z, .single_byte_hl 
8e66			 
8e66			.getwhln:   ; hex word so get next byte 
8e66			 
8e66 cd f9 8d			call get_byte 
8e69 6f				ld l, a 
8e6a 60				ld h,b 
8e6b c9				ret 
8e6c 68			.single_byte_hl:   ld l,b 
8e6d 26 00				ld h,0 
8e6f c9					ret 
8e70			 
8e70			 
8e70			 
8e70			 
8e70 21 14 96			ld hl,asc+1 
8e73			;	ld a, (hl) 
8e73			;	call nibble2val 
8e73 cd f9 8d			call get_byte 
8e76			 
8e76			;	call fourehexhl 
8e76 32 11 e5			ld (scratch+52),a 
8e79				 
8e79 21 0f e5			ld hl,scratch+50 
8e7c 22 00 e8			ld (os_cur_ptr),hl 
8e7f			 
8e7f c9				ret 
8e80			 
8e80			 
8e80			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e80			 
8e80			; Decimal Unsigned Version 
8e80			 
8e80			;Number in a to decimal ASCII 
8e80			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e80			;Example: display a=56 as "056" 
8e80			;input: a = number 
8e80			;Output: a=0,value of a in the screen 
8e80			;destroys af,bc (don't know about hl and de) 
8e80			DispAToASCII: 
8e80 0e 9c			ld	c,-100 
8e82 cd 8c 8e			call	.Na1 
8e85 0e f6			ld	c,-10 
8e87 cd 8c 8e			call	.Na1 
8e8a 0e ff			ld	c,-1 
8e8c 06 2f		.Na1:	ld	b,'0'-1 
8e8e 04			.Na2:	inc	b 
8e8f 81				add	a,c 
8e90 38 fc			jr	c,.Na2 
8e92 91				sub	c		;works as add 100/10/1 
8e93 f5				push af		;safer than ld c,a 
8e94 78				ld	a,b		;char is in b 
8e95			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8e95 f1				pop af		;safer than ld a,c 
8e96 c9				ret 
8e97			 
8e97			; Decimal Signed Version 
8e97			 
8e97			; DispA 
8e97			; -------------------------------------------------------------- 
8e97			; Converts a signed integer value to a zero-terminated ASCII 
8e97			; string representative of that value (using radix 10). 
8e97			; -------------------------------------------------------------- 
8e97			; INPUTS: 
8e97			;     HL     Value to convert (two's complement integer). 
8e97			;     DE     Base address of string destination. (pointer). 
8e97			; -------------------------------------------------------------- 
8e97			; OUTPUTS: 
8e97			;     None 
8e97			; -------------------------------------------------------------- 
8e97			; REGISTERS/MEMORY DESTROYED 
8e97			; AF HL 
8e97			; -------------------------------------------------------------- 
8e97			 
8e97			;DispHLToASCII: 
8e97			;   push    de 
8e97			;   push    bc 
8e97			; 
8e97			;; Detect sign of HL. 
8e97			;    bit    7, h 
8e97			;    jr     z, ._DoConvert 
8e97			; 
8e97			;; HL is negative. Output '-' to string and negate HL. 
8e97			;    ld     a, '-' 
8e97			;    ld     (de), a 
8e97			;    inc    de 
8e97			; 
8e97			;; Negate HL (using two's complement) 
8e97			;    xor    a 
8e97			;    sub    l 
8e97			;    ld     l, a 
8e97			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8e97			;    sbc    a, h 
8e97			;    ld     h, a 
8e97			; 
8e97			;; Convert HL to digit characters 
8e97			;._DoConvert: 
8e97			;    ld     b, 0     ; B will count character length of number 
8e97			;-   ld     a, 10 
8e97			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8e97			;    push   af 
8e97			;    inc    b 
8e97			;    ld     a, h 
8e97			;    or     l 
8e97			;    jr     nz, - 
8e97			; 
8e97			;; Retrieve digits from stack 
8e97			;-   pop    af 
8e97			;    or     $30 
8e97			;    ld     (de), a 
8e97			;    inc    de 
8e97			;    djnz   - 
8e97			; 
8e97			;; Terminate string with NULL 
8e97			;    xor    a 
8e97			;    ld     (de), a 
8e97			; 
8e97			;    pop    bc 
8e97			;    pop    de 
8e97			;    ret 
8e97			 
8e97			;Comments 
8e97			; 
8e97			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8e97			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8e97			;    Note that the output string will not be fixed-width. 
8e97			; 
8e97			;Example Usage 
8e97			; 
8e97			;    ld    hl, -1004 
8e97			;    ld    de, OP1 
8e97			;    call  DispA 
8e97			;    ld    hl, OP1 
8e97			;    syscall  PutS 
8e97			 
8e97			 
8e97			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e97			 
8e97			 
8e97			;Converts an ASCII string to an unsigned 16-bit integer 
8e97			;Quits when it reaches a non-decimal digit 
8e97			 
8e97			string_to_uint16: 
8e97			atoui_16: 
8e97			;Input: 
8e97			;     DE points to the string 
8e97			;Outputs: 
8e97			;     HL is the result 
8e97			;     A is the 8-bit value of the number 
8e97			;     DE points to the byte after the number 
8e97			;Destroys: 
8e97			;     BC 
8e97			;       if the string is non-empty, BC is HL/10 
8e97			;Size:  24 bytes 
8e97			;Speed: 42+d(104+{0,9}) 
8e97			;       d is the number of digits in the number 
8e97			;       max is 640 cycles for a 5 digit number 
8e97			;Assuming no leading zeros: 
8e97			;1 digit:  146cc 
8e97			;2 digit:  250cc 
8e97			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8e97			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8e97			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8e97			;avg: 544.81158447265625cc (544+13297/16384) 
8e97			;=============================================================== 
8e97 21 00 00		  ld hl,0 
8e9a			.u16a: 
8e9a 1a			  ld a,(de) 
8e9b d6 30		  sub 30h 
8e9d fe 0a		  cp 10 
8e9f d0			  ret nc 
8ea0 13			  inc de 
8ea1 44			  ld b,h 
8ea2 4d			  ld c,l 
8ea3 29			  add hl,hl 
8ea4 29			  add hl,hl 
8ea5 09			  add hl,bc 
8ea6 29			  add hl,hl 
8ea7 85			  add a,l 
8ea8 6f			  ld l,a 
8ea9 30 ef		  jr nc,.u16a 
8eab 24			  inc h 
8eac c3 9a 8e		  jp .u16a 
8eaf			 
8eaf			 
8eaf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eaf			 
8eaf			;written by Zeda 
8eaf			;Converts a 16-bit unsigned integer to an ASCII string. 
8eaf			 
8eaf			uitoa_16: 
8eaf			;Input: 
8eaf			;   DE is the number to convert 
8eaf			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8eaf			;Output: 
8eaf			;   HL points to the null-terminated ASCII string 
8eaf			;      NOTE: This isn't necessarily the same as the input HL. 
8eaf d5			  push de 
8eb0 c5			  push bc 
8eb1 f5			  push af 
8eb2 eb			  ex de,hl 
8eb3			 
8eb3 01 f0 d8		  ld bc,-10000 
8eb6 3e 2f		  ld a,'0'-1 
8eb8 3c			  inc a 
8eb9 09			  add hl,bc  
8eba 38 fc		   jr c,$-2 
8ebc 12			  ld (de),a 
8ebd 13			  inc de 
8ebe			 
8ebe 01 e8 03		  ld bc,1000 
8ec1 3e 3a		  ld a,'9'+1 
8ec3 3d			  dec a  
8ec4 09			  add hl,bc  
8ec5 30 fc		   jr nc,$-2 
8ec7 12			  ld (de),a 
8ec8 13			  inc de 
8ec9			 
8ec9 01 9c ff		  ld bc,-100 
8ecc 3e 2f		  ld a,'0'-1 
8ece 3c			  inc a  
8ecf 09			  add hl,bc  
8ed0 38 fc		   jr c,$-2 
8ed2 12			  ld (de),a 
8ed3 13			  inc de 
8ed4			 
8ed4 7d			  ld a,l 
8ed5 26 3a		  ld h,'9'+1 
8ed7 25			  dec h  
8ed8 c6 0a		  add a,10  
8eda 30 fb		   jr nc,$-3 
8edc c6 30		  add a,'0' 
8ede eb			  ex de,hl 
8edf 72			  ld (hl),d 
8ee0 23			  inc hl 
8ee1 77			  ld (hl),a 
8ee2 23			  inc hl 
8ee3 36 00		  ld (hl),0 
8ee5			 
8ee5			;Now strip the leading zeros 
8ee5 0e fa		  ld c,-6 
8ee7 09			  add hl,bc 
8ee8 3e 30		  ld a,'0' 
8eea 23			  inc hl  
8eeb be			  cp (hl)  
8eec 28 fc		  jr z,$-2 
8eee			 
8eee			;Make sure that the string is non-empty! 
8eee 7e			  ld a,(hl) 
8eef b7			  or a 
8ef0 20 01		  jr nz,.atoub 
8ef2 2b			  dec hl 
8ef3			.atoub: 
8ef3			 
8ef3 f1			  pop af 
8ef4 c1			  pop bc 
8ef5 d1			  pop de 
8ef6 c9			  ret 
8ef7			 
8ef7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8ef7			 
8ef7			toUpper: 
8ef7			;A is the char. 
8ef7			;If A is a lowercase letter, this sets it to the matching uppercase 
8ef7			;18cc or 30cc or 41cc 
8ef7			;avg: 26.75cc 
8ef7 fe 61		  cp 'a' 
8ef9 d8			  ret c 
8efa fe 7b		  cp 'z'+1 
8efc d0			  ret nc 
8efd d6 20		  sub 'a'-'A' 
8eff c9			  ret 
8f00			 
8f00			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f00			 
8f00			; String Length 
8f00			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f00			 
8f00			; Get the length of the null-terminated string starting at $8000 hl 
8f00			;    LD     HL, $8000 
8f00			 
8f00			strlenz: 
8f00			 
8f00 af			    XOR    A               ; Zero is the value we are looking for. 
8f01 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f02 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f03			                           ; 65, 536 bytes (the entire addressable memory space). 
8f03 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f05			 
8f05			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f05 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f06 6f			    LD     L, A             ; number of bytes 
8f07 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f09 2b			    DEC    HL              ; Compensate for null. 
8f0a c9				ret 
8f0b			 
8f0b			; Get the length of the A terminated string starting at $8000 hl 
8f0b			;    LD     HL, $8000 
8f0b			 
8f0b			strlent: 
8f0b			 
8f0b			                  ; A is the value we are looking for. 
8f0b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f0d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f0f			                           ; 65, 536 bytes (the entire addressable memory space). 
8f0f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f11			 
8f11			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f11 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f13 2e 00		    LD     L, 0             ; number of bytes 
8f15 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f17 2b			    DEC    HL              ; Compensate for null. 
8f18 c9				ret 
8f19			 
8f19			 
8f19			;Comparing Strings 
8f19			 
8f19			;IN    HL     Address of string1. 
8f19			;      DE     Address of string2. 
8f19			 
8f19			; doc given but wrong??? 
8f19			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f19			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f19			; tested 
8f19			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f19			 
8f19			strcmp_old: 
8f19 e5			    PUSH   HL 
8f1a d5			    PUSH   DE 
8f1b			 
8f1b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f1c be			    CP     (HL)            ; (want to minimize work). 
8f1d 38 01		    JR     C, Str1IsBigger 
8f1f 7e			    LD     A, (HL) 
8f20			 
8f20			Str1IsBigger: 
8f20 4f			    LD     C, A             ; Put length in BC 
8f21 06 00		    LD     B, 0 
8f23 13			    INC    DE              ; Increment pointers to meat of string. 
8f24 23			    INC    HL 
8f25			 
8f25			CmpLoop: 
8f25 1a			    LD     A, (DE)          ; Compare bytes. 
8f26 ed a1		    CPI 
8f28 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f2a 13			    INC    DE              ; Update pointer. 
8f2b ea 25 8f		    JP     PE, CmpLoop 
8f2e			 
8f2e d1			    POP    DE 
8f2f e1			    POP    HL 
8f30 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f31 be			    CP     (HL) 
8f32 c9			    RET 
8f33			 
8f33			NoMatch: 
8f33 2b			    DEC    HL 
8f34 be			    CP     (HL)            ; Compare again to affect carry. 
8f35 d1			    POP    DE 
8f36 e1			    POP    HL 
8f37 c9			    RET 
8f38			 
8f38			;; test strmp 
8f38			; 
8f38			;ld de, .str1 
8f38			;ld hl, .str2 
8f38			;call strcmp 
8f38			;jr z, .z1 
8f38			;;this 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "NZ1" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			;.z1: 
8f38			; 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "ZZ1" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			; 
8f38			;ld de, .str1 
8f38			;ld hl, .str1 
8f38			;call strcmp 
8f38			;jr z, .z2 
8f38			;;this 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "NZ2" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			;.z2: 
8f38			; 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "ZZ2" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			; 
8f38			;ld de, .str1 
8f38			;ld hl, .str2 
8f38			;call strcmp 
8f38			;jr c, .c1 
8f38			; 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "Nc1" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			;.c1: 
8f38			;;this 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "cc1" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			; 
8f38			;ld de, .str1 
8f38			;ld hl, .str1 
8f38			;call strcmp 
8f38			;jr c, .c2 
8f38			;;this 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "Nc2" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			;.c2: 
8f38			; 
8f38			;	if DEBUG_FORTH_WORDS 
8f38			;		DMARK "cc2" 
8f38			;		CALLMONITOR 
8f38			;	endif 
8f38			;	NEXTW 
8f38			;.str1:   db "string1",0 
8f38			;.str2:   db "string2",0 
8f38			 
8f38			; only care about direct match or not 
8f38			; hl and de strings 
8f38			; zero set if the same 
8f38			 
8f38			strcmp: 
8f38 1a				ld a, (de) 
8f39 be				cp (hl) 
8f3a 28 02			jr z, .ssame 
8f3c b7				or a 
8f3d c9				ret 
8f3e			 
8f3e			.ssame:  
8f3e fe 00			cp 0 
8f40 c8				ret z 
8f41			 
8f41 23				inc hl 
8f42 13				inc de 
8f43 18 f3			jr strcmp 
8f45				 
8f45				 
8f45			 
8f45			 
8f45			 
8f45			 
8f45			; eof 
8f45			 
8f45			 
8f45			 
8f45			 
8f45			 
8f45			 
# End of file firmware_strings.asm
8f45			include "firmware_memory.asm"   ; malloc and free  
8f45			 
8f45			if DEBUG_FORTH_MALLOC_HIGH 
8f45			.mallocsize: db "Wants malloc >256",0 
8f45			.mallocasize: db "MALLOC gives >256",0 
8f45			.malloczero: db "MALLOC gives zero",0 
8f45			 
8f45			malloc_guard_zerolen: 
8f45				push hl 
8f45				push de 
8f45				push af 
8f45			 
8f45				ld de, 0 
8f45			        call cmp16 
8f45				jr nz, .lowalloz 
8f45			 
8f45				push hl 
8f45				push de 
8f45					ld hl, display_fb0 
8f45					ld (display_fb_active), hl 
8f45				call clear_display 
8f45				ld a, 0 
8f45				ld de, .malloczero 
8f45				call str_at_display 
8f45				call update_display 
8f45				call delay1s 
8f45				call delay1s 
8f45				ld a, 0 
8f45				ld (os_view_disable), a 
8f45			 
8f45				pop de 
8f45				pop hl 
8f45			 
8f45				 
8f45			 
8f45				CALLMONITOR 
8f45			.lowalloz: 
8f45			 
8f45			 
8f45				pop af 
8f45				pop de 
8f45				pop hl 
8f45			ret 
8f45			 
8f45			malloc_guard_entry: 
8f45				push hl 
8f45				push de 
8f45				push af 
8f45			 
8f45			 	or a      ;clear carry flag 
8f45				push hl 
8f45				ld de, 255 
8f45				sbc hl, de 
8f45				jr c, .lowalloc 
8f45			 
8f45				push de 
8f45					ld hl, display_fb0 
8f45					ld (display_fb_active), hl 
8f45				call clear_display 
8f45				ld a, 0 
8f45				ld de, .mallocsize 
8f45				call str_at_display 
8f45				call update_display 
8f45				call delay1s 
8f45				call delay1s 
8f45				ld a, 0 
8f45				ld (os_view_disable), a 
8f45			 
8f45				pop de 
8f45				pop hl 
8f45			 
8f45				 
8f45			 
8f45				CALLMONITOR 
8f45				jr .lowdone 
8f45			.lowalloc: 
8f45			 
8f45			 
8f45				pop hl 
8f45			.lowdone:	pop af 
8f45				pop de 
8f45				pop hl 
8f45			ret 
8f45			 
8f45			malloc_guard_exit: 
8f45				push hl 
8f45				push de 
8f45				push af 
8f45			 
8f45			 	or a      ;clear carry flag 
8f45				push hl 
8f45				ld de, 255 
8f45				sbc hl, de 
8f45				jr c, .lowallocx 
8f45			 
8f45				push de 
8f45					ld hl, display_fb0 
8f45					ld (display_fb_active), hl 
8f45				call clear_display 
8f45				ld a, 0 
8f45				ld de, .mallocasize 
8f45				call str_at_display 
8f45				call update_display 
8f45				call delay1s 
8f45				call delay1s 
8f45				ld a, 0 
8f45				ld (os_view_disable), a 
8f45				pop de 
8f45				pop hl 
8f45			 
8f45				CALLMONITOR 
8f45				jr .lowdonex 
8f45			.lowallocx: 
8f45			 
8f45				pop hl 
8f45			.lowdonex:	pop af 
8f45				pop de 
8f45				pop hl 
8f45			ret 
8f45			endif 
8f45			 
8f45			if MALLOC_2 
8f45			; Z80 Malloc and Free Functions 
8f45			 
8f45			; Malloc Function: 
8f45			; Input: 
8f45			;   HL: Size of block to allocate 
8f45			; Output: 
8f45			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f45			 
8f45			malloc: 
8f45				 
8f45			if DEBUG_FORTH_MALLOC_HIGH 
8f45			call malloc_guard_entry 
8f45			endif 
8f45			 
8f45			 
8f45			 
8f45			 
8f45					if DEBUG_FORTH_MALLOC 
8f45						DMARK "mal" 
8f45						CALLMONITOR 
8f45					endif 
8f45			    push af            ; Save AF register 
8f45			    ld a, l            ; Load low byte of size into A 
8f45			    or h               ; Check if size is zero 
8f45			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f45			 
8f45			    ; Allocate memory 
8f45			    ld hl, (heap_start) ; Load start of heap into HL 
8f45					if DEBUG_FORTH_MALLOC 
8f45						DMARK "ma1" 
8f45						CALLMONITOR 
8f45					endif 
8f45			    call malloc_internal ; Call internal malloc function 
8f45			    pop af             ; Restore AF register 
8f45			if DEBUG_FORTH_MALLOC_HIGH 
8f45			call malloc_guard_exit 
8f45			call malloc_guard_zerolen 
8f45			endif 
8f45			    ret                ; Return 
8f45			 
8f45			; Free Function: 
8f45			; Input: 
8f45			;   HL: Pointer to memory block to free 
8f45			; Output: 
8f45			;   None 
8f45			 
8f45			free: 
8f45			    push af            ; Save AF register 
8f45			    ld a, l            ; Load low byte of pointer into A 
8f45			    or h               ; Check if pointer is NULL 
8f45			    jp z, free_exit    ; If pointer is NULL, exit 
8f45			 
8f45			    ; Free memory 
8f45			    ld hl, (heap_start) ; Load start of heap into HL 
8f45			    call free_internal  ; Call internal free function 
8f45			    pop af             ; Restore AF register 
8f45			    ret                ; Return 
8f45			 
8f45			; Internal Malloc Function: 
8f45			; Input: 
8f45			;   HL: Size of block to allocate 
8f45			; Output: 
8f45			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f45			 
8f45			malloc_internal: 
8f45			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f45			    add hl, bc         ; Add management overhead to requested size 
8f45			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f45					if DEBUG_FORTH_MALLOC 
8f45						DMARK "ma2" 
8f45						CALLMONITOR 
8f45					endif 
8f45			 
8f45			    ; Search for free memory block 
8f45			    ld de, (heap_end)  ; Load end of heap into DE 
8f45			    ld bc, 0           ; Initialize counter 
8f45			 
8f45					if DEBUG_FORTH_MALLOC 
8f45						DMARK "ma2" 
8f45						CALLMONITOR 
8f45					endif 
8f45			malloc_search_loop: 
8f45			    ; Check if current block is free 
8f45			    ld a, (hl)         ; Load current block's status (free or used) 
8f45			    cp 0               ; Compare with zero (free) 
8f45			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f45			 
8f45			    ; Check if current block is large enough 
8f45			    ld a, (hl+1)       ; Load high byte of block size 
8f45			    cp l               ; Compare with low byte of requested size 
8f45			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f45			 
8f45			    ld a, (hl+2)       ; Load low byte of block size 
8f45			    cp h               ; Compare with high byte of requested size 
8f45			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f45			 
8f45			    ; Mark block as used 
8f45			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f45			 
8f45			    ; Calculate remaining space in block 
8f45			    ld bc, 0           ; Clear BC 
8f45			    add hl, bc         ; Increment HL to point to start of data block 
8f45			    add hl, de         ; HL = HL + DE (total size) 
8f45			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f45			    add hl, bc         ; Add management overhead to start of data block 
8f45			 
8f45			    ; Save pointer to allocated block in HL 
8f45			if DEBUG_FORTH_MALLOC_HIGH 
8f45						DMARK "ma5" 
8f45			call malloc_guard_exit 
8f45			call malloc_guard_zerolen 
8f45			endif 
8f45			    ret 
8f45			 
8f45			malloc_skip_block_check: 
8f45			    ; Move to the next block 
8f45			    ld bc, 3           ; Size of management overhead 
8f45			    add hl, bc         ; Move to the next block 
8f45			    inc de             ; Increment counter 
8f45			 
8f45			    ; Check if we have reached the end of heap 
8f45			    ld a, e            ; Load low byte of heap end address 
8f45			    cp (hl)            ; Compare with low byte of current address 
8f45			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f45			    ld a, d            ; Load high byte of heap end address 
8f45			    cp 0               ; Check if it's zero (end of memory) 
8f45			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f45			 
8f45			    ; If we reached here, allocation failed 
8f45			    xor a              ; Set result to NULL 
8f45			if DEBUG_FORTH_MALLOC_HIGH 
8f45						DMARK "ma6" 
8f45			call malloc_guard_exit 
8f45			call malloc_guard_zerolen 
8f45			endif 
8f45			    ret 
8f45			malloc_exit: 
8f45			if DEBUG_FORTH_MALLOC_HIGH 
8f45						DMARK "ma7" 
8f45			call malloc_guard_exit 
8f45			call malloc_guard_zerolen 
8f45			endif 
8f45			    ret 
8f45			 
8f45			; Internal Free Function: 
8f45			; Input: 
8f45			;   HL: Pointer to memory block to free 
8f45			; Output: 
8f45			;   None 
8f45			 
8f45			free_internal: 
8f45			    ld de, (heap_start) ; Load start of heap into DE 
8f45			    ld bc, 0            ; Initialize counter 
8f45			 
8f45			free_search_loop: 
8f45			    ; Check if current block contains the pointer 
8f45			    ld a, l             ; Load low byte of pointer 
8f45			    cp (hl+1)           ; Compare with high byte of current block's address 
8f45			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f45			    ld a, h             ; Load high byte of pointer 
8f45			    cp (hl+2)           ; Compare with low byte of current block's address 
8f45			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f45			 
8f45			    ; Mark block as free 
8f45			    ld (hl), 0          ; Set status byte to indicate free block 
8f45			    ret                 ; Return 
8f45			 
8f45			free_skip_block_check: 
8f45			    ; Move to the next block 
8f45			    ld bc, 3            ; Size of management overhead 
8f45			    add hl, bc          ; Move to the next block 
8f45			    inc de              ; Increment counter 
8f45			 
8f45			    ; Check if we have reached the end of heap 
8f45			    ld a, e             ; Load low byte of heap end address 
8f45			    cp (hl)             ; Compare with low byte of current address 
8f45			    jr nz, free_search_loop  ; If not equal, continue searching 
8f45			    ld a, d             ; Load high byte of heap end address 
8f45			    cp 0                ; Check if it's zero (end of memory) 
8f45			    jr nz, free_search_loop  ; If not zero, continue searching 
8f45			 
8f45			    ; If we reached here, pointer is not found in heap 
8f45			    ret 
8f45			 
8f45			free_exit: 
8f45			    ret                 ; Return 
8f45			 
8f45			; Define heap start and end addresses 
8f45			;heap_start:    .dw 0xC000   ; Start of heap 
8f45			;heap_end:      .dw 0xE000   ; End of heap 
8f45			 
8f45			endif 
8f45			 
8f45			 
8f45			if MALLOC_1 
8f45			 
8f45			 
8f45			 
8f45			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f45			 
8f45			;moved to firmware.asm 
8f45			;heap_start        .equ  0x9000      ; Starting address of heap 
8f45			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f45			 
8f45			;      .org 0 
8f45			;      jp    main 
8f45			 
8f45			 
8f45			;      .org  0x100 
8f45			;main: 
8f45			;      ld    HL, 0x8100 
8f45			;      ld    SP, HL 
8f45			; 
8f45			;      call  heap_init 
8f45			; 
8f45			;      ; Make some allocations 
8f45			;      ld    HL, 12 
8f45			;      call  malloc            ; Allocates 0x9004 
8f45			; 
8f45			;      ld    HL, 12 
8f45			;      call  malloc            ; Allocates 0x9014 
8f45			; 
8f45			;      ld    HL, 12 
8f45			;      call  malloc            ; Allocates 0x9024 
8f45			; 
8f45			;      ; Free some allocations 
8f45			;      ld    HL, 0x9014 
8f45			;      call  free 
8f45			; 
8f45			;      ld    HL, 0x9004 
8f45			;      call  free 
8f45			; 
8f45			;      ld    HL, 0x9024 
8f45			;      call  free 
8f45			; 
8f45			; 
8f45			;      halt 
8f45			 
8f45			 
8f45			;------------------------------------------------------------------------------ 
8f45			;     heap_init                                                               : 
8f45			;                                                                             : 
8f45			; Description                                                                 : 
8f45			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f45			;                                                                             : 
8f45			;     The heap is maintained as a linked list, starting with an initial       : 
8f45			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f45			;     the first free block in the heap. Each block then points to the next    : 
8f45			;     free block within the heap, and the free list ends at the first block   : 
8f45			;     with a null pointer to the next free block.                             : 
8f45			;                                                                             : 
8f45			; Parameters                                                                  : 
8f45			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f45			;     address of the heap and its size are required, along with a memory      : 
8f45			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f45			;     principally stores a pointer to the first free block in the heap.       : 
8f45			;                                                                             : 
8f45			; Returns                                                                     : 
8f45			;     Nothing                                                                 : 
8f45			;------------------------------------------------------------------------------ 
8f45			heap_init: 
8f45 e5			      push  HL 
8f46			 
8f46			      ; Initialise free list struct 
8f46 21 f2 d7		      ld    HL, heap_start 
8f49 22 ed d7		      ld    (free_list), HL 
8f4c 21 00 00		      ld    HL, 0 
8f4f 22 ef d7		      ld    (free_list+2), HL 
8f52			 
8f52			      ; Insert first free block at bottom of heap, consumes entire heap 
8f52 21 bf e4		      ld    HL, heap_start+heap_size-4 
8f55 22 f2 d7		      ld    (heap_start), HL        ; Next block (end of free list) 
8f58 21 cd 0c		      ld    HL, heap_size-4 
8f5b 22 f4 d7		      ld    (heap_start+2), HL      ; Block size 
8f5e			 
8f5e			      ; Insert end of free list block at top of heap - two null words will 
8f5e			      ; terminate the free list 
8f5e 21 00 00		      ld    HL, 0 
8f61 22 c1 e4		      ld    (heap_start+heap_size-2), HL 
8f64 22 bf e4		      ld    (heap_start+heap_size-4), HL 
8f67			 
8f67 e1			      pop   HL 
8f68			 
8f68 c9			      ret 
8f69			 
8f69			 
8f69			;------------------------------------------------------------------------------ 
8f69			;     malloc                                                                  : 
8f69			;                                                                             : 
8f69			; Description                                                                 : 
8f69			;     Allocates the wanted space from the heap and returns the address of the : 
8f69			;     first useable byte of the allocation.                                   : 
8f69			;                                                                             : 
8f69			;     Allocations can happen in one of two ways:                              : 
8f69			;                                                                             : 
8f69			;     1. A free block may be found which is the exact size wanted. In this    : 
8f69			;        case the block is removed from the free list and retuedn to the      : 
8f69			;        caller.                                                              : 
8f69			;     2. A free block may be found which is larger than the size wanted. In   : 
8f69			;        this case, the larger block is split into two. The first portion of  : 
8f69			;        this block will become the requested space by the malloc call and    : 
8f69			;        is returned to the caller. The second portion becomes a new free     : 
8f69			;        block, and the free list is adjusted to maintain continuity via this : 
8f69			;        newly created block.                                                 : 
8f69			;                                                                             : 
8f69			;     malloc does not set any initial value in the allocated space, the       : 
8f69			;     caller is required to do this as required.                              : 
8f69			;                                                                             : 
8f69			;     This implementation of malloc uses the stack exclusively, and is        : 
8f69			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f69			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f69			;     to avoid the use of malloc inside ISRs in general.                      : 
8f69			;                                                                             : 
8f69			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f69			;                                                                             : 
8f69			; Parameters                                                                  : 
8f69			;     HL  Number of bytes wanted                                              : 
8f69			;                                                                             : 
8f69			; Returns                                                                     : 
8f69			;     HL  Address of the first useable byte of the allocation                 : 
8f69			;                                                                             : 
8f69			; Flags                                                                       : 
8f69			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f69			;                                                                             : 
8f69			; Stack frame                                                                 : 
8f69			;       |             |                                                       : 
8f69			;       +-------------+                                                       : 
8f69			;       |     BC      |                                                       : 
8f69			;       +-------------+                                                       : 
8f69			;       |     DE      |                                                       : 
8f69			;       +-------------+                                                       : 
8f69			;       |     IX      |                                                       : 
8f69			;       +-------------+                                                       : 
8f69			;       |  prev_free  |                                                       : 
8f69			;   +4  +-------------+                                                       : 
8f69			;       |  this_free  |                                                       : 
8f69			;   +2  +-------------+                                                       : 
8f69			;       |  next_free  |                                                       : 
8f69			;   +0  +-------------+                                                       : 
8f69			;       |             |                                                       : 
8f69			;                                                                             : 
8f69			;------------------------------------------------------------------------------ 
8f69			 
8f69			 
8f69			;malloc: 
8f69			; 
8f69			;	SAVESP ON 1 
8f69			; 
8f69			;	call malloc_code 
8f69			; 
8f69			;	CHECKSP ON 1 
8f69			;	ret 
8f69			 
8f69			 
8f69			malloc: 
8f69 c5			      push  BC 
8f6a d5			      push  DE 
8f6b dd e5		      push  IX 
8f6d			if DEBUG_FORTH_MALLOC_HIGH 
8f6d			call malloc_guard_entry 
8f6d			endif 
8f6d			 
8f6d					if DEBUG_FORTH_MALLOC 
8f6d						DMARK "mal" 
8f6d						CALLMONITOR 
8f6d					endif 
8f6d 7c			      ld    A, H                    ; Exit if no space requested 
8f6e b5			      or    L 
8f6f ca 2e 90		      jp    Z, malloc_early_exit 
8f72			 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			; 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			;inc hl 
8f72			 
8f72			 
8f72			 
8f72			 
8f72					if DEBUG_FORTH_MALLOC 
8f72						DMARK "maA" 
8f72						CALLMONITOR 
8f72					endif 
8f72			      ; Set up stack frame 
8f72 eb			      ex    DE, HL 
8f73 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f76 39			      add   HL, SP 
8f77 f9			      ld    SP, HL 
8f78 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f7c dd 39		      add   IX, SP 
8f7e			 
8f7e			      ; Setup initial state 
8f7e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f81 19			      add   HL, DE 
8f82			 
8f82 44			      ld    B, H                    ; Move want to BC 
8f83 4d			      ld    C, L 
8f84			 
8f84 21 ed d7		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f87 dd 75 04		      ld    (IX+4), L 
8f8a dd 74 05		      ld    (IX+5), H 
8f8d			 
8f8d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f8e 23			      inc   HL 
8f8f 56			      ld    D, (HL) 
8f90 dd 73 02		      ld    (IX+2), E 
8f93 dd 72 03		      ld    (IX+3), D 
8f96 eb			      ex    DE, HL                  ; this_free ptr into HL 
8f97			 
8f97					if DEBUG_FORTH_MALLOC 
8f97						DMARK "maB" 
8f97						CALLMONITOR 
8f97					endif 
8f97			      ; Loop through free block list to find some space 
8f97			malloc_find_space: 
8f97 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8f98 23			      inc   HL 
8f99 56			      ld    D, (HL) 
8f9a			 
8f9a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8f9b b3			      or    E 
8f9c ca 28 90		      jp    Z, malloc_no_space 
8f9f			 
8f9f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fa2 dd 72 01		      ld    (IX+1), D 
8fa5			 
8fa5			      ; Does this block have enough space to make the allocation? 
8fa5 23			      inc   HL                      ; Load free block size into DE 
8fa6 5e			      ld    E, (HL) 
8fa7 23			      inc   HL 
8fa8 56			      ld    D, (HL) 
8fa9			 
8fa9 eb			      ex    DE, HL                  ; Check size of block against want 
8faa b7			      or    A                       ; Ensure carry flag clear 
8fab ed 42		      sbc   HL, BC 
8fad e5			      push  HL                      ; Store the result for later (new block size) 
8fae			 
8fae ca fd 8f		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fb1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fb3			 
8fb3			      ; this_free block is not big enough, setup ptrs to test next free block 
8fb3 e1			      pop   HL                      ; Discard previous result 
8fb4			 
8fb4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fb7 dd 66 03		      ld    H, (IX+3) 
8fba dd 75 04		      ld    (IX+4), L 
8fbd dd 74 05		      ld    (IX+5), H 
8fc0			 
8fc0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fc3 dd 66 01		      ld    H, (IX+1) 
8fc6 dd 75 02		      ld    (IX+2), L 
8fc9 dd 74 03		      ld    (IX+3), H 
8fcc			 
8fcc					if DEBUG_FORTH_MALLOC 
8fcc						DMARK "MA>" 
8fcc						CALLMONITOR 
8fcc					endif 
8fcc 18 c9		      jr    malloc_find_space 
8fce			 
8fce			      ; split a bigger block into two - requested size and remaining size 
8fce			malloc_alloc_split: 
8fce					if DEBUG_FORTH_MALLOC 
8fce						DMARK "MAs" 
8fce						CALLMONITOR 
8fce					endif 
8fce eb			      ex    DE, HL                  ; Calculate address of new free block 
8fcf 2b			      dec   HL 
8fd0 2b			      dec   HL 
8fd1 2b			      dec   HL 
8fd2 09			      add   HL, BC 
8fd3			 
8fd3			      ; Create a new block and point it at next_free 
8fd3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fd6 dd 56 01		      ld    D, (IX+1) 
8fd9			 
8fd9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8fda 23			      inc   HL 
8fdb 72			      ld    (HL), D 
8fdc			 
8fdc d1			      pop   DE                      ; Store size of new block into new block 
8fdd 23			      inc   HL 
8fde 73			      ld    (HL), E 
8fdf 23			      inc   HL 
8fe0 72			      ld    (HL), D 
8fe1			 
8fe1			      ; Update this_free ptr to point to new block 
8fe1 2b			      dec   HL 
8fe2 2b			      dec   HL 
8fe3 2b			      dec   HL 
8fe4			 
8fe4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8fe7 dd 56 03		      ld    D, (IX+3) 
8fea			 
8fea dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8fed dd 74 03		      ld    (IX+3), H 
8ff0			 
8ff0			      ; Modify this_free block to be allocation 
8ff0 eb			      ex    DE, HL 
8ff1 af			      xor   A                       ; Null the next block ptr of allocated block 
8ff2 77			      ld    (HL), A 
8ff3 23			      inc   HL 
8ff4 77			      ld    (HL), A 
8ff5			 
8ff5 23			      inc   HL                      ; Store want size into allocated block 
8ff6 71			      ld    (HL), C 
8ff7 23			      inc   HL 
8ff8 70			      ld    (HL), B 
8ff9 23			      inc   HL 
8ffa e5			      push  HL                      ; Address of allocation to return 
8ffb			 
8ffb 18 19		      jr    malloc_update_links 
8ffd			 
8ffd			malloc_alloc_fit: 
8ffd e1			      pop   HL                      ; Dont need new block size, want is exact fit 
8ffe			 
8ffe					if DEBUG_FORTH_MALLOC 
8ffe						DMARK "MAf" 
8ffe						CALLMONITOR 
8ffe					endif 
8ffe			      ; Modify this_free block to be allocation 
8ffe eb			      ex    DE, HL 
8fff 2b			      dec   HL 
9000 2b			      dec   HL 
9001 2b			      dec   HL 
9002			 
9002 af			      xor   A                       ; Null the next block ptr of allocated block 
9003 77			      ld    (HL), A 
9004 23			      inc   HL 
9005 77			      ld    (HL), A 
9006			 
9006 23			      inc   HL                      ; Store address of allocation to return 
9007 23			      inc   HL 
9008 23			      inc   HL 
9009 e5			      push  HL 
900a			 
900a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
900a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
900d dd 66 01		      ld    H, (IX+1) 
9010			 
9010 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9013 dd 74 03		      ld    (IX+3), H 
9016			 
9016			 
9016			malloc_update_links: 
9016			      ; Update prev_free ptr to point to this_free 
9016 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9019 dd 66 05		      ld    H, (IX+5) 
901c			 
901c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
901f dd 56 03		      ld    D, (IX+3) 
9022			 
9022 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9023 23			      inc   HL 
9024 72			      ld    (HL), D 
9025			 
9025					if DEBUG_FORTH_MALLOC 
9025						DMARK "Mul" 
9025						CALLMONITOR 
9025					endif 
9025			      ; Clear the Z flag to indicate successful allocation 
9025 7a			      ld    A, D 
9026 b3			      or    E 
9027			 
9027 d1			      pop   DE                      ; Address of allocation 
9028					if DEBUG_FORTH_MALLOC 
9028						DMARK "MAu" 
9028						CALLMONITOR 
9028					endif 
9028			 
9028			malloc_no_space: 
9028 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
902b 39			      add   HL, SP 
902c f9			      ld    SP, HL 
902d			 
902d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
902e					if DEBUG_FORTH_MALLOC 
902e						DMARK "MAN" 
902e						CALLMONITOR 
902e					endif 
902e			 
902e			malloc_early_exit: 
902e					if DEBUG_FORTH_MALLOC 
902e						DMARK "MAx" 
902e						CALLMONITOR 
902e					endif 
902e dd e1		      pop   IX 
9030 d1			      pop   DE 
9031 c1			      pop   BC 
9032			 
9032			if DEBUG_FORTH_MALLOC_HIGH 
9032			call malloc_guard_exit 
9032			call malloc_guard_zerolen 
9032			endif 
9032 c9			      ret 
9033			 
9033			 
9033			;------------------------------------------------------------------------------ 
9033			;     free                                                                    : 
9033			;                                                                             : 
9033			; Description                                                                 : 
9033			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9033			;     returned by malloc, otherwise the behaviour is undefined.               : 
9033			;                                                                             : 
9033			;     Where possible, directly adjacent free blocks will be merged together   : 
9033			;     into larger blocks to help ensure that the heap does not become         : 
9033			;     excessively fragmented.                                                 : 
9033			;                                                                             : 
9033			;     free does not clear or set any other value into the freed space, and    : 
9033			;     therefore its contents may be visible through subsequent malloc's. The  : 
9033			;     caller should clear the freed space as required.                        : 
9033			;                                                                             : 
9033			;     This implementation of free uses the stack exclusively, and is          : 
9033			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9033			;     advisable to disable interrupts before calling free, and recommended    : 
9033			;     to avoid the use of free inside ISRs in general.                        : 
9033			;                                                                             : 
9033			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9033			;                                                                             : 
9033			; Parameters                                                                  : 
9033			;     HL  Pointer to address of first byte of allocation to be freed          : 
9033			;                                                                             : 
9033			; Returns                                                                     : 
9033			;     Nothing                                                                 : 
9033			;                                                                             : 
9033			; Stack frame                                                                 : 
9033			;       |             |                                                       : 
9033			;       +-------------+                                                       : 
9033			;       |     BC      |                                                       : 
9033			;       +-------------+                                                       : 
9033			;       |     DE      |                                                       : 
9033			;       +-------------+                                                       : 
9033			;       |     IX      |                                                       : 
9033			;       +-------------+                                                       : 
9033			;       |  prev_free  |                                                       : 
9033			;   +2  +-------------+                                                       : 
9033			;       |  next_free  |                                                       : 
9033			;   +0  +-------------+                                                       : 
9033			;       |             |                                                       : 
9033			;                                                                             : 
9033			;------------------------------------------------------------------------------ 
9033			free: 
9033 c5			      push  BC 
9034 d5			      push  DE 
9035 dd e5		      push  IX 
9037			 
9037 7c			      ld    A, H                    ; Exit if ptr is null 
9038 b5			      or    L 
9039 ca fd 90		      jp    Z, free_early_exit 
903c			 
903c			      ; Set up stack frame 
903c eb			      ex    DE, HL 
903d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9040 39			      add   HL, SP 
9041 f9			      ld    SP, HL 
9042 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9046 dd 39		      add   IX, SP 
9048			 
9048			      ; The address in HL points to the start of the useable allocated space, 
9048			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9048			      ; address of the block itself. 
9048 eb			      ex    DE, HL 
9049 11 fc ff		      ld    DE, -4 
904c 19			      add   HL, DE 
904d			 
904d			      ; An allocated block must have a null next block pointer in it 
904d 7e			      ld    A, (HL) 
904e 23			      inc   HL 
904f b6			      or    (HL) 
9050 c2 f8 90		      jp    NZ, free_done 
9053			 
9053 2b			      dec   HL 
9054			 
9054 44			      ld    B, H                    ; Copy HL to BC 
9055 4d			      ld    C, L 
9056			 
9056			      ; Loop through the free list to find the first block with an address 
9056			      ; higher than the block being freed 
9056 21 ed d7		      ld    HL, free_list 
9059			 
9059			free_find_higher_block: 
9059 5e			      ld    E, (HL)                 ; Load next ptr from free block 
905a 23			      inc   HL 
905b 56			      ld    D, (HL) 
905c 2b			      dec   HL 
905d			 
905d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9060 dd 72 01		      ld    (IX+1), D 
9063 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9066 dd 74 03		      ld    (IX+3), H 
9069			 
9069 78			      ld    A, B                    ; Check if DE is greater than BC 
906a ba			      cp    D                       ; Compare MSB first 
906b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
906d 30 04		      jr    NC, free_find_higher_block_skip 
906f 79			      ld    A, C 
9070 bb			      cp    E                       ; Then compare LSB 
9071 38 08		      jr    C, free_found_higher_block 
9073			 
9073			free_find_higher_block_skip: 
9073 7a			      ld    A, D                    ; Reached the end of the free list? 
9074 b3			      or    E 
9075 ca f8 90		      jp    Z, free_done 
9078			 
9078 eb			      ex    DE, HL 
9079			 
9079 18 de		      jr    free_find_higher_block 
907b			 
907b			free_found_higher_block: 
907b			      ; Insert freed block between prev and next free blocks 
907b 71			      ld    (HL), C                 ; Point prev free block to freed block 
907c 23			      inc   HL 
907d 70			      ld    (HL), B 
907e			 
907e 60			      ld    H, B                    ; Point freed block at next free block 
907f 69			      ld    L, C 
9080 73			      ld    (HL), E 
9081 23			      inc   HL 
9082 72			      ld    (HL), D 
9083			 
9083			      ; Check if the freed block is adjacent to the next free block 
9083 23			      inc   HL                      ; Load size of freed block into HL 
9084 5e			      ld    E, (HL) 
9085 23			      inc   HL 
9086 56			      ld    D, (HL) 
9087 eb			      ex    DE, HL 
9088			 
9088 09			      add   HL, BC                  ; Add addr of freed block and its size 
9089			 
9089 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
908c dd 56 01		      ld    D, (IX+1) 
908f			 
908f b7			      or    A                       ; Clear the carry flag 
9090 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9092 20 22		      jr    NZ, free_check_adjacent_to_prev 
9094			 
9094			      ; Freed block is adjacent to next, merge into one bigger block 
9094 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9095 5e			      ld    E, (HL) 
9096 23			      inc   HL 
9097 56			      ld    D, (HL) 
9098 e5			      push  HL                      ; Save ptr to next block for later 
9099			 
9099 60			      ld    H, B                    ; Store ptr from next block into freed block 
909a 69			      ld    L, C 
909b 73			      ld    (HL), E 
909c 23			      inc   HL 
909d 72			      ld    (HL), D 
909e			 
909e e1			      pop   HL                      ; Restore ptr to next block 
909f 23			      inc   HL                      ; Load size of next block into DE 
90a0 5e			      ld    E, (HL) 
90a1 23			      inc   HL 
90a2 56			      ld    D, (HL) 
90a3 d5			      push  DE                      ; Save next block size for later 
90a4			 
90a4 60			      ld    H, B                    ; Load size of freed block into HL 
90a5 69			      ld    L, C 
90a6 23			      inc   HL 
90a7 23			      inc   HL 
90a8 5e			      ld    E, (HL) 
90a9 23			      inc   HL 
90aa 56			      ld    D, (HL) 
90ab eb			      ex    DE, HL 
90ac			 
90ac d1			      pop   DE                      ; Restore size of next block 
90ad 19			      add   HL, DE                  ; Add sizes of both blocks 
90ae eb			      ex    DE, HL 
90af			 
90af 60			      ld    H, B                    ; Store new bigger size into freed block 
90b0 69			      ld    L, C 
90b1 23			      inc   HL 
90b2 23			      inc   HL 
90b3 73			      ld    (HL), E 
90b4 23			      inc   HL 
90b5 72			      ld    (HL), D 
90b6			 
90b6			free_check_adjacent_to_prev: 
90b6			      ; Check if the freed block is adjacent to the prev free block 
90b6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90b9 dd 66 03		      ld    H, (IX+3) 
90bc			 
90bc 23			      inc   HL                      ; Size of prev free block into DE 
90bd 23			      inc   HL 
90be 5e			      ld    E, (HL) 
90bf 23			      inc   HL 
90c0 56			      ld    D, (HL) 
90c1 2b			      dec   HL 
90c2 2b			      dec   HL 
90c3 2b			      dec   HL 
90c4			 
90c4 19			      add   HL, DE                  ; Add prev block addr and size 
90c5			 
90c5 b7			      or    A                       ; Clear the carry flag 
90c6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90c8 20 2e		      jr    NZ, free_done 
90ca			 
90ca			      ; Freed block is adjacent to prev, merge into one bigger block 
90ca 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90cb 69			      ld    L, C 
90cc 5e			      ld    E, (HL) 
90cd 23			      inc   HL 
90ce 56			      ld    D, (HL) 
90cf e5			      push  HL                      ; Save freed block ptr for later 
90d0			 
90d0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90d3 dd 66 03		      ld    H, (IX+3) 
90d6 73			      ld    (HL), E 
90d7 23			      inc   HL 
90d8 72			      ld    (HL), D 
90d9			 
90d9 e1			      pop   HL                      ; Restore freed block ptr 
90da 23			      inc   HL                      ; Load size of freed block into DE 
90db 5e			      ld    E, (HL) 
90dc 23			      inc   HL 
90dd 56			      ld    D, (HL) 
90de d5			      push  DE                      ; Save freed block size for later 
90df			 
90df dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90e2 dd 66 03		      ld    H, (IX+3) 
90e5 23			      inc   HL 
90e6 23			      inc   HL 
90e7 5e			      ld    E, (HL) 
90e8 23			      inc   HL 
90e9 56			      ld    D, (HL) 
90ea			 
90ea e1			      pop   HL                      ; Add sizes of both blocks 
90eb 19			      add   HL, DE 
90ec eb			      ex    DE, HL 
90ed			 
90ed dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
90f0 dd 66 03		      ld    H, (IX+3) 
90f3 23			      inc   HL 
90f4 23			      inc   HL 
90f5 73			      ld    (HL), E 
90f6 23			      inc   HL 
90f7 72			      ld    (HL), D 
90f8			 
90f8			free_done: 
90f8 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
90fb 39			      add   HL, SP 
90fc f9			      ld    SP, HL 
90fd			 
90fd			free_early_exit: 
90fd dd e1		      pop   IX 
90ff d1			      pop   DE 
9100 c1			      pop   BC 
9101			 
9101 c9			      ret 
9102			 
9102			; moved to firmware.asm 
9102			; 
9102			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9102			;                  .dw   0 
9102			 
9102			 
9102			endif 
9102			 
9102			 
9102			if MALLOC_3 
9102			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9102			;heap_start        .equ  0x9000      ; Starting address of heap 
9102			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9102			; 
9102			 ;     .org 0 
9102			  ;    jp    main 
9102			; 
9102			; 
9102			 ;     .org  0x100 
9102			;main: 
9102			 ;     ld    HL, 0x8100 
9102			  ;    ld    SP, HL 
9102			; 
9102			;      call  heap_init 
9102			 
9102			      ; Make some allocations 
9102			;      ld    HL, 12 
9102			;      call  malloc            ; Allocates 0x9004 
9102			; 
9102			 ;     ld    HL, 12 
9102			;      call  malloc            ; Allocates 0x9014 
9102			 
9102			;      ld    HL, 12 
9102			;      call  malloc            ; Allocates 0x9024 
9102			 
9102			      ; Free some allocations 
9102			;      ld    HL, 0x9014 
9102			;      call  free 
9102			 
9102			;      ld    HL, 0x9004 
9102			;      call  free 
9102			; 
9102			;      ld    HL, 0x9024 
9102			;      call  free 
9102			 
9102			 
9102			 ;     halt 
9102			 
9102			 
9102			;------------------------------------------------------------------------------ 
9102			;     heap_init                                                               : 
9102			;                                                                             : 
9102			; Description                                                                 : 
9102			;     Initialise the heap and make it ready for malloc and free operations.   : 
9102			;                                                                             : 
9102			;     The heap is maintained as a linked list, starting with an initial       : 
9102			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9102			;     the first free block in the heap. Each block then points to the next    : 
9102			;     free block within the heap, and the free list ends at the first block   : 
9102			;     with a null pointer to the next free block.                             : 
9102			;                                                                             : 
9102			; Parameters                                                                  : 
9102			;     Inputs are compile-time only. Two defines which specify the starting    : 
9102			;     address of the heap and its size are required, along with a memory      : 
9102			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9102			;     principally stores a pointer to the first free block in the heap.       : 
9102			;                                                                             : 
9102			; Returns                                                                     : 
9102			;     Nothing                                                                 : 
9102			;------------------------------------------------------------------------------ 
9102			heap_init: 
9102			      push  HL 
9102			 
9102			      ; Initialise free list struct 
9102			      ld    HL, heap_start 
9102			      ld    (free_list), HL 
9102			      ld    HL, 0 
9102			      ld    (free_list+2), HL 
9102			 
9102			      ; Insert first free block at bottom of heap, consumes entire heap 
9102			      ld    HL, heap_start+heap_size-4 
9102			      ld    (heap_start), HL        ; Next block (end of free list) 
9102			      ld    HL, heap_size-4 
9102			      ld    (heap_start+2), HL      ; Block size 
9102			 
9102			      ; Insert end of free list block at top of heap - two null words will 
9102			      ; terminate the free list 
9102			      ld    HL, 0 
9102			      ld    (heap_start+heap_size-2), HL 
9102			      ld    (heap_start+heap_size-4), HL 
9102			 
9102			      pop   HL 
9102			 
9102			      ret 
9102			 
9102			 
9102			;------------------------------------------------------------------------------ 
9102			;     malloc                                                                  : 
9102			;                                                                             : 
9102			; Description                                                                 : 
9102			;     Allocates the wanted space from the heap and returns the address of the : 
9102			;     first useable byte of the allocation.                                   : 
9102			;                                                                             : 
9102			;     Allocations can happen in one of two ways:                              : 
9102			;                                                                             : 
9102			;     1. A free block may be found which is the exact size wanted. In this    : 
9102			;        case the block is removed from the free list and retuedn to the      : 
9102			;        caller.                                                              : 
9102			;     2. A free block may be found which is larger than the size wanted. In   : 
9102			;        this case, the larger block is split into two. The first portion of  : 
9102			;        this block will become the requested space by the malloc call and    : 
9102			;        is returned to the caller. The second portion becomes a new free     : 
9102			;        block, and the free list is adjusted to maintain continuity via this : 
9102			;        newly created block.                                                 : 
9102			;                                                                             : 
9102			;     malloc does not set any initial value in the allocated space, the       : 
9102			;     caller is required to do this as required.                              : 
9102			;                                                                             : 
9102			;     This implementation of malloc uses the stack exclusively, and is        : 
9102			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9102			;     advisable to disable interrupts before calling malloc, and recommended  : 
9102			;     to avoid the use of malloc inside ISRs in general.                      : 
9102			;                                                                             : 
9102			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9102			;                                                                             : 
9102			; Parameters                                                                  : 
9102			;     HL  Number of bytes wanted                                              : 
9102			;                                                                             : 
9102			; Returns                                                                     : 
9102			;     HL  Address of the first useable byte of the allocation                 : 
9102			;                                                                             : 
9102			; Flags                                                                       : 
9102			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9102			;                                                                             : 
9102			; Stack frame                                                                 : 
9102			;       |             |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |     BC      |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |     DE      |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |     IX      |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |  prev_free  |                                                       : 
9102			;   +4  +-------------+                                                       : 
9102			;       |  this_free  |                                                       : 
9102			;   +2  +-------------+                                                       : 
9102			;       |  next_free  |                                                       : 
9102			;   +0  +-------------+                                                       : 
9102			;       |             |                                                       : 
9102			;                                                                             : 
9102			;------------------------------------------------------------------------------ 
9102			malloc: 
9102			      push  BC 
9102			      push  DE 
9102			      push  IX 
9102			 
9102			      ld    A, H                    ; Exit if no space requested 
9102			      or    L 
9102			      jp    Z, malloc_early_exit 
9102			 
9102			      ; Set up stack frame 
9102			      ex    DE, HL 
9102			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9102			      add   HL, SP 
9102			      ld    SP, HL 
9102			      ld    IX, 0                   ; Use IX as a frame pointer 
9102			      add   IX, SP 
9102			 
9102			      ; Setup initial state 
9102			      ld    HL, 4                   ; want must also include space used by block struct 
9102			      add   HL, DE 
9102			 
9102			      ld    B, H                    ; Move want to BC 
9102			      ld    C, L 
9102			 
9102			      ld    HL, free_list           ; Store prev_free ptr to stack 
9102			      ld    (IX+4), L 
9102			      ld    (IX+5), H 
9102			 
9102			      ld    E, (HL)                 ; Store this_free ptr to stack 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      ld    (IX+2), E 
9102			      ld    (IX+3), D 
9102			      ex    DE, HL                  ; this_free ptr into HL 
9102			 
9102			      ; Loop through free block list to find some space 
9102			malloc_find_space: 
9102			      ld    E, (HL)                 ; Load next_free ptr into DE 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			 
9102			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9102			      or    E 
9102			      jp    Z, malloc_no_space 
9102			 
9102			      ld    (IX+0), E               ; Store next_free ptr to stack 
9102			      ld    (IX+1), D 
9102			 
9102			      ; Does this block have enough space to make the allocation? 
9102			      inc   HL                      ; Load free block size into DE 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			 
9102			      ex    DE, HL                  ; Check size of block against want 
9102			      or    A                       ; Ensure carry flag clear 
9102			      sbc   HL, BC 
9102			      push  HL                      ; Store the result for later (new block size) 
9102			 
9102			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9102			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9102			 
9102			      ; this_free block is not big enough, setup ptrs to test next free block 
9102			      pop   HL                      ; Discard previous result 
9102			 
9102			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9102			      ld    H, (IX+3) 
9102			      ld    (IX+4), L 
9102			      ld    (IX+5), H 
9102			 
9102			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9102			      ld    H, (IX+1) 
9102			      ld    (IX+2), L 
9102			      ld    (IX+3), H 
9102			 
9102			      jr    malloc_find_space 
9102			 
9102			      ; split a bigger block into two - requested size and remaining size 
9102			malloc_alloc_split: 
9102			      ex    DE, HL                  ; Calculate address of new free block 
9102			      dec   HL 
9102			      dec   HL 
9102			      dec   HL 
9102			      add   HL, BC 
9102			 
9102			      ; Create a new block and point it at next_free 
9102			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9102			      ld    D, (IX+1) 
9102			 
9102			      ld    (HL), E                 ; Store next_free ptr into new block 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			      pop   DE                      ; Store size of new block into new block 
9102			      inc   HL 
9102			      ld    (HL), E 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			      ; Update this_free ptr to point to new block 
9102			      dec   HL 
9102			      dec   HL 
9102			      dec   HL 
9102			 
9102			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9102			      ld    D, (IX+3) 
9102			 
9102			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9102			      ld    (IX+3), H 
9102			 
9102			      ; Modify this_free block to be allocation 
9102			      ex    DE, HL 
9102			      xor   A                       ; Null the next block ptr of allocated block 
9102			      ld    (HL), A 
9102			      inc   HL 
9102			      ld    (HL), A 
9102			 
9102			      inc   HL                      ; Store want size into allocated block 
9102			      ld    (HL), C 
9102			      inc   HL 
9102			      ld    (HL), B 
9102			      inc   HL 
9102			      push  HL                      ; Address of allocation to return 
9102			 
9102			      jr    malloc_update_links 
9102			 
9102			malloc_alloc_fit: 
9102			      pop   HL                      ; Dont need new block size, want is exact fit 
9102			 
9102			      ; Modify this_free block to be allocation 
9102			      ex    DE, HL 
9102			      dec   HL 
9102			      dec   HL 
9102			      dec   HL 
9102			 
9102			      xor   A                       ; Null the next block ptr of allocated block 
9102			      ld    (HL), A 
9102			      inc   HL 
9102			      ld    (HL), A 
9102			 
9102			      inc   HL                      ; Store address of allocation to return 
9102			      inc   HL 
9102			      inc   HL 
9102			      push  HL 
9102			 
9102			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9102			      ld    L, (IX+0)               ; next_free to HL 
9102			      ld    H, (IX+1) 
9102			 
9102			      ld    (IX+2), L               ; HL to this_free 
9102			      ld    (IX+3), H 
9102			 
9102			 
9102			malloc_update_links: 
9102			      ; Update prev_free ptr to point to this_free 
9102			      ld    L, (IX+4)               ; prev_free ptr to HL 
9102			      ld    H, (IX+5) 
9102			 
9102			      ld    E, (IX+2)               ; this_free ptr to DE 
9102			      ld    D, (IX+3) 
9102			 
9102			      ld    (HL), E                 ; this_free ptr into prev_free 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			      ; Clear the Z flag to indicate successful allocation 
9102			      ld    A, D 
9102			      or    E 
9102			 
9102			      pop   DE                      ; Address of allocation 
9102			 
9102			malloc_no_space: 
9102			      ld    HL, 6                   ; Clean up stack frame 
9102			      add   HL, SP 
9102			      ld    SP, HL 
9102			 
9102			      ex    DE, HL                  ; Alloc addr into HL for return 
9102			 
9102			malloc_early_exit: 
9102			      pop   IX 
9102			      pop   DE 
9102			      pop   BC 
9102			 
9102			      ret 
9102			 
9102			 
9102			;------------------------------------------------------------------------------ 
9102			;     free                                                                    : 
9102			;                                                                             : 
9102			; Description                                                                 : 
9102			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9102			;     returned by malloc, otherwise the behaviour is undefined.               : 
9102			;                                                                             : 
9102			;     Where possible, directly adjacent free blocks will be merged together   : 
9102			;     into larger blocks to help ensure that the heap does not become         : 
9102			;     excessively fragmented.                                                 : 
9102			;                                                                             : 
9102			;     free does not clear or set any other value into the freed space, and    : 
9102			;     therefore its contents may be visible through subsequent malloc's. The  : 
9102			;     caller should clear the freed space as required.                        : 
9102			;                                                                             : 
9102			;     This implementation of free uses the stack exclusively, and is          : 
9102			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9102			;     advisable to disable interrupts before calling free, and recommended    : 
9102			;     to avoid the use of free inside ISRs in general.                        : 
9102			;                                                                             : 
9102			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9102			;                                                                             : 
9102			; Parameters                                                                  : 
9102			;     HL  Pointer to address of first byte of allocation to be freed          : 
9102			;                                                                             : 
9102			; Returns                                                                     : 
9102			;     Nothing                                                                 : 
9102			;                                                                             : 
9102			; Stack frame                                                                 : 
9102			;       |             |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |     BC      |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |     DE      |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |     IX      |                                                       : 
9102			;       +-------------+                                                       : 
9102			;       |  prev_free  |                                                       : 
9102			;   +2  +-------------+                                                       : 
9102			;       |  next_free  |                                                       : 
9102			;   +0  +-------------+                                                       : 
9102			;       |             |                                                       : 
9102			;                                                                             : 
9102			;------------------------------------------------------------------------------ 
9102			free: 
9102			      push  BC 
9102			      push  DE 
9102			      push  IX 
9102			 
9102			      ld    A, H                    ; Exit if ptr is null 
9102			      or    L 
9102			      jp    Z, free_early_exit 
9102			 
9102			      ; Set up stack frame 
9102			      ex    DE, HL 
9102			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9102			      add   HL, SP 
9102			      ld    SP, HL 
9102			      ld    IX, 0                   ; Use IX as a frame pointer 
9102			      add   IX, SP 
9102			 
9102			      ; The address in HL points to the start of the useable allocated space, 
9102			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9102			      ; address of the block itself. 
9102			      ex    DE, HL 
9102			      ld    DE, -4 
9102			      add   HL, DE 
9102			 
9102			      ; An allocated block must have a null next block pointer in it 
9102			      ld    A, (HL) 
9102			      inc   HL 
9102			      or    (HL) 
9102			      jp    NZ, free_done 
9102			 
9102			      dec   HL 
9102			 
9102			      ld    B, H                    ; Copy HL to BC 
9102			      ld    C, L 
9102			 
9102			      ; Loop through the free list to find the first block with an address 
9102			      ; higher than the block being freed 
9102			      ld    HL, free_list 
9102			 
9102			free_find_higher_block: 
9102			      ld    E, (HL)                 ; Load next ptr from free block 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      dec   HL 
9102			 
9102			      ld    (IX+0), E               ; Save ptr to next free block 
9102			      ld    (IX+1), D 
9102			      ld    (IX+2), L               ; Save ptr to prev free block 
9102			      ld    (IX+3), H 
9102			 
9102			      ld    A, B                    ; Check if DE is greater than BC 
9102			      cp    D                       ; Compare MSB first 
9102			      jr    Z, $+4                  ; MSB the same, compare LSB 
9102			      jr    NC, free_find_higher_block_skip 
9102			      ld    A, C 
9102			      cp    E                       ; Then compare LSB 
9102			      jr    C, free_found_higher_block 
9102			 
9102			free_find_higher_block_skip: 
9102			      ld    A, D                    ; Reached the end of the free list? 
9102			      or    E 
9102			      jp    Z, free_done 
9102			 
9102			      ex    DE, HL 
9102			 
9102			      jr    free_find_higher_block 
9102			 
9102			free_found_higher_block: 
9102			      ; Insert freed block between prev and next free blocks 
9102			      ld    (HL), C                 ; Point prev free block to freed block 
9102			      inc   HL 
9102			      ld    (HL), B 
9102			 
9102			      ld    H, B                    ; Point freed block at next free block 
9102			      ld    L, C 
9102			      ld    (HL), E 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			      ; Check if the freed block is adjacent to the next free block 
9102			      inc   HL                      ; Load size of freed block into HL 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      ex    DE, HL 
9102			 
9102			      add   HL, BC                  ; Add addr of freed block and its size 
9102			 
9102			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9102			      ld    D, (IX+1) 
9102			 
9102			      or    A                       ; Clear the carry flag 
9102			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9102			      jr    NZ, free_check_adjacent_to_prev 
9102			 
9102			      ; Freed block is adjacent to next, merge into one bigger block 
9102			      ex    DE, HL                  ; Load next ptr from next block into DE 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      push  HL                      ; Save ptr to next block for later 
9102			 
9102			      ld    H, B                    ; Store ptr from next block into freed block 
9102			      ld    L, C 
9102			      ld    (HL), E 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			      pop   HL                      ; Restore ptr to next block 
9102			      inc   HL                      ; Load size of next block into DE 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      push  DE                      ; Save next block size for later 
9102			 
9102			      ld    H, B                    ; Load size of freed block into HL 
9102			      ld    L, C 
9102			      inc   HL 
9102			      inc   HL 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      ex    DE, HL 
9102			 
9102			      pop   DE                      ; Restore size of next block 
9102			      add   HL, DE                  ; Add sizes of both blocks 
9102			      ex    DE, HL 
9102			 
9102			      ld    H, B                    ; Store new bigger size into freed block 
9102			      ld    L, C 
9102			      inc   HL 
9102			      inc   HL 
9102			      ld    (HL), E 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			free_check_adjacent_to_prev: 
9102			      ; Check if the freed block is adjacent to the prev free block 
9102			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9102			      ld    H, (IX+3) 
9102			 
9102			      inc   HL                      ; Size of prev free block into DE 
9102			      inc   HL 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      dec   HL 
9102			      dec   HL 
9102			      dec   HL 
9102			 
9102			      add   HL, DE                  ; Add prev block addr and size 
9102			 
9102			      or    A                       ; Clear the carry flag 
9102			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9102			      jr    NZ, free_done 
9102			 
9102			      ; Freed block is adjacent to prev, merge into one bigger block 
9102			      ld    H, B                    ; Load next ptr from freed block into DE 
9102			      ld    L, C 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      push  HL                      ; Save freed block ptr for later 
9102			 
9102			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9102			      ld    H, (IX+3) 
9102			      ld    (HL), E 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			      pop   HL                      ; Restore freed block ptr 
9102			      inc   HL                      ; Load size of freed block into DE 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			      push  DE                      ; Save freed block size for later 
9102			 
9102			      ld    L, (IX+2)               ; Load size of prev block into DE 
9102			      ld    H, (IX+3) 
9102			      inc   HL 
9102			      inc   HL 
9102			      ld    E, (HL) 
9102			      inc   HL 
9102			      ld    D, (HL) 
9102			 
9102			      pop   HL                      ; Add sizes of both blocks 
9102			      add   HL, DE 
9102			      ex    DE, HL 
9102			 
9102			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9102			      ld    H, (IX+3) 
9102			      inc   HL 
9102			      inc   HL 
9102			      ld    (HL), E 
9102			      inc   HL 
9102			      ld    (HL), D 
9102			 
9102			free_done: 
9102			      ld    HL, 4                   ; Clean up stack frame 
9102			      add   HL, SP 
9102			      ld    SP, HL 
9102			 
9102			free_early_exit: 
9102			      pop   IX 
9102			      pop   DE 
9102			      pop   BC 
9102			 
9102			      ret 
9102			 
9102			 
9102			;      .org 0x8000 
9102			; 
9102			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9102			 ;                 .dw   0 
9102			 
9102			endif 
9102			 
9102			 
9102			if MALLOC_4 
9102			 
9102			; My memory allocation code. Very very simple.... 
9102			; allocate space under 250 chars 
9102			 
9102			heap_init: 
9102				; init start of heap as zero 
9102				;  
9102			 
9102				ld hl, heap_start 
9102				ld a, 0 
9102				ld (hl), a      ; empty block 
9102				inc hl 
9102				ld a, 0 
9102				ld (hl), a      ; length of block 
9102				; write end of list 
9102				inc hl 
9102				ld a,(hl) 
9102				inc hl 
9102				ld a,(hl) 
9102				 
9102			 
9102				; init some malloc vars 
9102			 
9102				ld hl, 0 
9102				ld (free_list), hl       ; store last malloc location 
9102			 
9102				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9102				ld a, 0 
9102				ld (hl), a 
9102			 
9102			 
9102				ld hl, heap_start 
9102				;  
9102				  
9102				ret 
9102			 
9102			 
9102			;    free block marker 
9102			;    requested size  
9102			;    pointer to next block 
9102			;    .... 
9102			;    next block marker 
9102			 
9102			 
9102			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9102			; 
9102			 
9102			 
9102			malloc:  
9102				push de 
9102				push bc 
9102				push af 
9102			 
9102				; hl space required 
9102				 
9102				ld c, l    ; hold space   (TODO only a max of 255) 
9102			 
9102			;	inc c     ; TODO BUG need to fix memory leak on push str 
9102			;	inc c 
9102			;	inc c 
9102			;	inc c 
9102			;	inc c 
9102			;	inc c 
9102			;	inc c 
9102			 
9102			 
9102			 
9102				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9102			 
9102				ld a, (free_list+3) 
9102				cp 0 
9102				jr z, .contheap 
9102			 
9102				ld hl, (free_list)     ; get last alloc 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "mrs" 
9102						CALLMONITOR 
9102					endif 
9102				jr .startalloc 
9102			 
9102			.contheap: 
9102				ld hl, heap_start 
9102			 
9102			.startalloc: 
9102			 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "mym" 
9102						CALLMONITOR 
9102					endif 
9102			.findblock: 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "mmf" 
9102						CALLMONITOR 
9102					endif 
9102			 
9102				ld a,(hl)  
9102				; if byte is zero then clear to use 
9102			 
9102				cp 0 
9102				jr z, .foundemptyblock 
9102			 
9102				; if byte is not clear 
9102				;     then byte is offset to next block 
9102			 
9102				inc hl 
9102				ld a, (hl) ; get size 
9102			.nextblock:	inc hl 
9102					ld e, (hl) 
9102					inc hl 
9102					ld d, (hl) 
9102					ex de, hl 
9102			;	inc hl  ; move past the store space 
9102			;	inc hl  ; move past zero index  
9102			 
9102				; TODO detect no more space 
9102			 
9102				push hl 
9102				ld de, heap_end 
9102				call cmp16 
9102				pop hl 
9102				jr nc, .nospace 
9102			 
9102				jr .findblock 
9102			 
9102			.nospace: ld hl, 0 
9102				jp .exit 
9102			 
9102			 
9102			.foundemptyblock:	 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "mme" 
9102						CALLMONITOR 
9102					endif 
9102			 
9102			; TODO has block enough space if reusing??? 
9102			 
9102				;  
9102			 
9102			; see if this block has been previously used 
9102				inc hl 
9102				ld a, (hl) 
9102				dec hl 
9102				cp 0 
9102				jr z, .newblock 
9102			 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "meR" 
9102						CALLMONITOR 
9102					endif 
9102			 
9102			; no reusing previously allocated block 
9102			 
9102			; is it smaller than previously used? 
9102				 
9102				inc hl    ; move to size 
9102				ld a, c 
9102				sub (hl)        ; we want c < (hl) 
9102				dec hl    ; move back to marker 
9102			        jr z, .findblock 
9102			 
9102				; update with the new size which should be lower 
9102			 
9102			        ;inc  hl   ; negate next move. move back to size  
9102			 
9102			.newblock: 
9102				; need to be at marker here 
9102			 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "meN" 
9102						CALLMONITOR 
9102					endif 
9102			 
9102			 
9102				ld a, c 
9102			 
9102				ld (free_list+3), a	 ; flag resume from last malloc  
9102				ld (free_list), hl    ; save out last location 
9102			 
9102			 
9102				;inc a     ; space for length byte 
9102				ld (hl), a     ; save block in use marker 
9102			 
9102				inc hl   ; move to space marker 
9102				ld (hl), a    ; save new space 
9102			 
9102				inc hl   ; move to start of allocated area 
9102				 
9102			;	push hl     ; save where we are - 1  
9102			 
9102			;	inc hl  ; move past zero index  
9102				; skip space to set down new marker 
9102			 
9102				; provide some extra space for now 
9102			 
9102				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9102				inc a 
9102				inc a 
9102			 
9102				push hl   ; save where we are in the node block 
9102			 
9102				call addatohl 
9102			 
9102				; write linked list point 
9102			 
9102				pop de     ; get our node position 
9102				ex de, hl 
9102			 
9102				ld (hl), e 
9102				inc hl 
9102				ld (hl), d 
9102			 
9102				inc hl 
9102			 
9102				; now at start of allocated data so save pointer 
9102			 
9102				push hl 
9102			 
9102				; jump to position of next node and setup empty header in DE 
9102			 
9102				ex de, hl 
9102			 
9102			;	inc hl ; move past end of block 
9102			 
9102				ld a, 0 
9102				ld (hl), a   ; empty marker 
9102				inc hl 
9102				ld (hl), a   ; size 
9102				inc hl  
9102				ld (hl), a   ; ptr 
9102				inc hl 
9102				ld (hl), a   ; ptr 
9102			 
9102			 
9102				pop hl 
9102			 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "mmr" 
9102						CALLMONITOR 
9102					endif 
9102			 
9102			.exit: 
9102				pop af 
9102				pop bc 
9102				pop de  
9102				ret 
9102			 
9102			 
9102			 
9102			 
9102			free:  
9102				push hl 
9102				push af 
9102				; get address in hl 
9102			 
9102					if DEBUG_FORTH_MALLOC_INT 
9102						DMARK "fre" 
9102						CALLMONITOR 
9102					endif 
9102				; data is at hl - move to block count 
9102				dec hl 
9102				dec hl    ; get past pointer 
9102				dec hl 
9102			 
9102				ld a, (hl)    ; need this for a validation check 
9102			 
9102				dec hl    ; move to block marker 
9102			 
9102				; now check that the block count and block marker are the same  
9102			        ; this checks that we are on a malloc node and not random memory 
9102			        ; OK a faint chance this could be a problem but rare - famous last words! 
9102			 
9102				ld c, a 
9102				ld a, (hl)    
9102			 
9102				cp c 
9102				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9102			 
9102				; yes good chance we are on a malloc node 
9102			 
9102				ld a, 0      
9102				ld (hl), a   ; mark as free 
9102			 
9102				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9102			 
9102			.freeignore:  
9102			 
9102				pop af 
9102				pop hl 
9102			 
9102				ret 
9102			 
9102			 
9102			 
9102			endif 
9102			 
9102			; eof 
# End of file firmware_memory.asm
9102			  
9102			; device C  
9102			if SOUND_ENABLE  
9102				include "firmware_sound.asm"  
9102			endif  
9102			  
9102			include "firmware_diags.asm"  
9102			; Hardware diags menu 
9102			 
9102			 
9102			config: 
9102			 
9102 3e 00			ld a, 0 
9104 21 32 91			ld hl, .configmn 
9107 cd a6 88			call menu 
910a			 
910a fe 00			cp 0 
910c c8				ret z 
910d			 
910d fe 01			cp 1 
910f cc 60 91			call z, .savetostore 
9112			 
9112 fe 02			cp 2 
9114 cc 4c 91			call z, .selautoload 
9117 fe 03			cp 3 
9119 cc 42 91			call z, .disautoload 
911c fe 04			cp 4 
911e cc 56 91			call z, .selbank 
9121 fe 05			cp 5 
9123 cc 6a 91			call z, .debug_tog 
9126 fe 06			cp 6 
9128 cc ad 92			call z, .bpsgo 
912b fe 07			cp 7 
912d cc 90 91			call z, hardware_diags 
9130			 
9130 18 d0			jr config 
9132			 
9132			.configmn: 
9132 9e 94			dw prom_c3 
9134 b5 94			dw prom_c2 
9136 ca 94			dw prom_c2a 
9138 e0 94			dw prom_c2b 
913a			;	dw prom_c4 
913a fd 94			dw prom_m4 
913c 18 95			dw prom_m4b 
913e 20 95			dw prom_c1 
9140 00 00			dw 0 
9142				 
9142			 
9142			 
9142			 
9142			.disautoload: 
9142				if STORAGE_SE 
9142				ld a, $fe      ; bit 0 clear 
9142				ld (spi_device), a 
9142			 
9142				call storage_get_block_0 
9142			 
9142				ld a, 0 
9142				ld (store_page+STORE_0_AUTOFILE), a 
9142			 
9142					ld hl, 0 
9142					ld de, store_page 
9142				call storage_write_block	 ; save update 
9142				else 
9142			 
9142 21 2f 95			ld hl, prom_notav 
9145 11 45 95			ld de, prom_empty 
9148 cd 06 88			call info_panel 
914b				endif 
914b			 
914b			 
914b c9				ret 
914c			 
914c			 
914c			 
914c			; Select auto start 
914c			 
914c			.selautoload: 
914c			 
914c				 
914c				if STORAGE_SE 
914c			 
914c					call config_dir 
914c				        ld hl, scratch 
914c					ld a, 0 
914c					call menu 
914c			 
914c					cp 0 
914c					ret z 
914c			 
914c					dec a 
914c			 
914c			 
914c					; locate menu option 
914c			 
914c					ld hl, scratch 
914c					call table_lookup 
914c			 
914c					if DEBUG_FORTH_WORDS 
914c						DMARK "ALl" 
914c						CALLMONITOR 
914c					endif 
914c					; with the pointer to the menu it, the byte following the zero term is the file id 
914c			 
914c					ld a, 0 
914c					ld bc, 50   ; max of bytes to look at 
914c					cpir  
914c			 
914c					if DEBUG_FORTH_WORDS 
914c						DMARK "ALb" 
914c						CALLMONITOR 
914c					endif 
914c					;inc hl 
914c			 
914c					ld a, (hl)   ; file id 
914c					 
914c				        ; save bank and file ids 
914c			 
914c					push af 
914c			 
914c			; TODO need to save to block 0 on bank 1	 
914c			 
914c					call storage_get_block_0 
914c			 
914c					if DEBUG_FORTH_WORDS 
914c						DMARK "AL0" 
914c						CALLMONITOR 
914c					endif 
914c					pop af 
914c			 
914c					ld (store_page+STORE_0_FILERUN),a 
914c					 
914c					; save bank id 
914c			 
914c					ld a,(spi_device) 
914c					ld (store_page+STORE_0_BANKRUN),a 
914c			 
914c					; enable auto run of store file 
914c			 
914c					ld a, 1 
914c					ld (store_page+STORE_0_AUTOFILE),a 
914c			 
914c					; save buffer 
914c			 
914c					ld hl, 0 
914c					ld de, store_page 
914c					if DEBUG_FORTH_WORDS 
914c						DMARK "ALw" 
914c						CALLMONITOR 
914c					endif 
914c				call storage_write_block	 ; save update 
914c			  
914c			 
914c			 
914c			 
914c					ld hl, scratch 
914c					call config_fdir 
914c			 
914c				else 
914c			 
914c 21 2f 95			ld hl, prom_notav 
914f 11 45 95			ld de, prom_empty 
9152 cd 06 88			call info_panel 
9155			 
9155				endif 
9155 c9				ret 
9156			 
9156			 
9156			 
9156			; Select storage bank 
9156			 
9156			.selbank: 
9156			 
9156				if STORAGE_SE 
9156				else 
9156			 
9156 21 2f 95			ld hl, prom_notav 
9159 11 45 95			ld de, prom_empty 
915c cd 06 88			call info_panel 
915f				endif 
915f				 
915f c9				ret 
9160			 
9160			if STORAGE_SE 
9160			 
9160			.config_ldir:   
9160				; Load storage bank labels into menu array 
9160			 
9160				 
9160			 
9160			 
9160				ret 
9160			 
9160			 
9160			endif 
9160			 
9160			 
9160			; Save user words to storage 
9160			 
9160			.savetostore: 
9160			 
9160				if STORAGE_SE 
9160			 
9160					call config_dir 
9160				        ld hl, scratch 
9160					ld a, 0 
9160					call menu 
9160					 
9160					ld hl, scratch 
9160					call config_fdir 
9160			 
9160				else 
9160			 
9160 21 2f 95			ld hl, prom_notav 
9163 11 45 95			ld de, prom_empty 
9166 cd 06 88			call info_panel 
9169			 
9169				endif 
9169			 
9169 c9				ret 
916a			 
916a			 
916a			 
916a			if STORAGE_SE 
916a			 
916a			config_fdir: 
916a				; using the scratch dir go through and release the memory allocated for each string 
916a				 
916a				ld hl, scratch 
916a			.cfdir:	ld e,(hl) 
916a				inc hl 
916a				ld d,(hl) 
916a				inc hl 
916a			 
916a				ex de, hl 
916a				call ishlzero 
916a				ret z     ; return on null pointer 
916a				call free 
916a				ex de, hl 
916a				jr .cfdir 
916a			 
916a			 
916a				ret 
916a			 
916a			 
916a			config_dir: 
916a			 
916a				; for the config menus that need to build a directory of storage call this routine 
916a				; it will construct a menu in scratch to pass to menu 
916a			 
916a				; open storage device 
916a			 
916a				; execute DIR to build a list of files and their ids into scratch in menu format 
916a				; once the menu has finished then will need to call config_fdir to release the strings 
916a				 
916a				; c = number items 
916a			 
916a				 
916a				call storage_get_block_0 
916a			 
916a				ld hl, store_page     ; get current id count 
916a				ld b, (hl) 
916a				ld c, 0    ; count of files   
916a			 
916a			 
916a				ld hl, scratch 
916a				ld (store_tmp2), hl    ; location to poke strings 
916a			 
916a				; check for empty drive 
916a			 
916a				ld a, 0 
916a				cp b 
916a				jp z, .dirdone 
916a			 
916a				 
916a					if DEBUG_FORTH_WORDS 
916a						DMARK "Cdc" 
916a						CALLMONITOR 
916a					endif 
916a			 
916a			 
916a			.diritem:	 
916a				push bc 
916a				; for each of the current ids do a search for them and if found push to stack 
916a			 
916a					ld hl, STORE_BLOCK_PHY 
916a					ld d, 0		 ; look for extent 0 of block id as this contains file name 
916a					ld e,b 
916a			 
916a					call storage_findnextid 
916a			 
916a			 
916a					; if found hl will be non zero 
916a			 
916a					call ishlzero 
916a					jr z, .dirnotfound 
916a			 
916a					; increase count 
916a			 
916a					pop bc	 
916a					inc c 
916a					push bc 
916a					 
916a			 
916a					; get file header and push the file name 
916a			 
916a					ld de, store_page 
916a					call storage_read_block 
916a			 
916a					; push file id to stack 
916a				 
916a					ld a, (store_page) 
916a					ld h, 0 
916a					ld l, a 
916a			 
916a					;call forth_push_numhl 
916a					; TODO store id 
916a			 
916a					push hl 
916a			 
916a					; push extent count to stack  
916a				 
916a					ld hl, store_page+3 
916a			 
916a					; get file name length 
916a			 
916a					call strlenz   
916a			 
916a					inc hl   ; cover zero term 
916a					inc hl  ; stick the id at the end of the area 
916a			 
916a					push hl 
916a					pop bc    ; move length to bc 
916a			 
916a					call malloc 
916a			 
916a					; TODO save malloc area to scratch 
916a			 
916a					ex de, hl 
916a					ld hl, (store_tmp2) 
916a					ld (hl), e 
916a					inc hl 
916a					ld (hl), d 
916a					inc hl 
916a					ld (store_tmp2), hl 
916a			 
916a					 
916a			 
916a					;pop hl   ; get source 
916a			;		ex de, hl    ; swap aronund	 
916a			 
916a					ld hl, store_page+3 
916a					if DEBUG_FORTH_WORDS 
916a						DMARK "CFd" 
916a						CALLMONITOR 
916a					endif 
916a					ldir 
916a			 
916a					; de is past string, move back one and store id 
916a					 
916a					dec de 
916a			 
916a					; store file id 
916a			 
916a					pop hl 
916a					ex de,hl 
916a					ld (hl), e 
916a			 
916a					if DEBUG_FORTH_WORDS 
916a						DMARK "Cdi" 
916a						CALLMONITOR 
916a					endif 
916a					 
916a			.dirnotfound: 
916a					pop bc     
916a					djnz .diritem 
916a				 
916a			.dirdone:	 
916a			 
916a					ld a, 0 
916a					ld hl, (store_tmp2) 
916a					ld (hl), a 
916a					inc hl 
916a					ld (hl), a 
916a					inc hl 
916a					; push a count of the dir items found 
916a			 
916a			;		ld h, 0 
916a			;		ld l, c 
916a			 
916a				ret 
916a			 
916a			endif 
916a			 
916a			 
916a			; Settings 
916a			; Run  
916a			 
916a			 
916a			 
916a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
916a			;;hd_menu2:   db "        2: Editor",0   
916a			;hd_menu2:   db "        2: Editor       6: Menu",0   
916a			;hd_menu3:   db "        3: Storage",0 
916a			;hd_menu4:   db "0=quit  4: Debug",0 
916a			;hd_don:     db "ON",0 
916a			;hd_doff:     db "OFF",0 
916a			; 
916a			; 
916a			; 
916a			;hardware_diags_old:       
916a			; 
916a			;.diagmenu: 
916a			;	call clear_display 
916a			;	ld a, display_row_1 
916a			;	ld de, hd_menu1 
916a			;	call str_at_display 
916a			; 
916a			;	ld a, display_row_2 
916a			;	ld de, hd_menu2 
916a			;	call str_at_display 
916a			; 
916a			;	ld a, display_row_3 
916a			;	ld de, hd_menu3 
916a			;	call str_at_display 
916a			; 
916a			;	ld a,  display_row_4 
916a			;	ld de, hd_menu4 
916a			;	call str_at_display 
916a			; 
916a			;	; display debug state 
916a			; 
916a			;	ld de, hd_don 
916a			;	ld a, (os_view_disable) 
916a			;	cp 0 
916a			;	jr z, .distog 
916a			;	ld de, hd_doff 
916a			;.distog: ld a, display_row_4+17 
916a			;	call str_at_display 
916a			; 
916a			;	call update_display 
916a			; 
916a			;	call cin_wait 
916a			; 
916a			; 
916a			; 
916a			;	cp '4' 
916a			;	jr nz, .diagn1 
916a			; 
916a			;	; debug toggle 
916a			; 
916a			;	ld a, (os_view_disable) 
916a			;	ld b, '*' 
916a			;	cp 0 
916a			;	jr z, .debtog 
916a			;	ld b, 0 
916a			;.debtog:	 
916a			;	ld a,b 
916a			;	ld (os_view_disable),a 
916a			; 
916a			;.diagn1: cp '0' 
916a			;	 ret z 
916a			; 
916a			;;	cp '1' 
916a			;;       jp z, matrix	 
916a			;;   TODO keyboard matrix test 
916a			; 
916a			;	cp '2' 
916a			;	jp z, .diagedit 
916a			; 
916a			;;	cp '6' 
916a			;;	jp z, .menutest 
916a			;;if ENABLE_BASIC 
916a			;;	cp '6' 
916a			;;	jp z, basic 
916a			;;endif 
916a			 ; 
916a			;	jp .diagmenu 
916a			; 
916a			; 
916a			;	ret 
916a			 
916a			 
916a			.debug_tog: 
916a 21 b1 91			ld hl, .menudebug 
916d				 
916d 3a ce e4			ld a, (os_view_disable) 
9170 fe 2a			cp '*' 
9172 20 04			jr nz,.tdon  
9174 3e 01			ld a, 1 
9176 18 02			jr .tog1 
9178 3e 00		.tdon: ld a, 0 
917a			 
917a			.tog1: 
917a cd a6 88			call menu 
917d fe 00			cp 0 
917f c8				ret z 
9180 fe 01			cp 1    ; disable debug 
9182 28 04			jr z, .dtog0 
9184 3e 2a			ld a, '*' 
9186 18 02			jr .dtogset 
9188 3e 00		.dtog0: ld a, 0 
918a 32 ce e4		.dtogset:  ld (os_view_disable), a 
918d c3 6a 91			jp .debug_tog 
9190			 
9190			 
9190			hardware_diags:       
9190			 
9190			.diagm: 
9190 21 a3 91			ld hl, .menuitems 
9193 3e 00			ld a, 0 
9195 cd a6 88			call menu 
9198			 
9198 fe 00		         cp 0 
919a c8				 ret z 
919b			 
919b fe 02			cp 2 
919d ca fc 91			jp z, .diagedit 
91a0			 
91a0			;	cp '6' 
91a0			;	jp z, .menutest 
91a0			;if ENABLE_BASIC 
91a0			;	cp '6' 
91a0			;	jp z, basic 
91a0			;endif 
91a0			  
91a0 c3 90 91			jp .diagm 
91a3			 
91a3				 
91a3 b7 91		.menuitems:   	dw .m1 
91a5 c2 91				dw .m2 
91a7 c9 91				dw .m3 
91a9 d1 91				dw .m5 
91ab d7 91				dw .m5a 
91ad e0 91				dw .m5b 
91af 00 00				dw 0 
91b1			 
91b1			.menudebug: 
91b1 e9 91				dw .m6 
91b3 f2 91				dw .m7 
91b5 00 00				dw 0 
91b7			 
91b7 .. 00		.m1:   db "Key Matrix",0 
91c2 .. 00		.m2:   db "Editor",0 
91c9 .. 00		.m3:   db "Storage",0 
91d1 .. 00		.m5:   db "Sound",0 
91d7 .. 00		.m5a:  db "RAM Test",0 
91e0 .. 00		.m5b:  db "LCD Test",0 
91e9			 
91e9 .. 00		.m6:   db "Debug ON",0 
91f2 .. 00		.m7:   db "Debug OFF",0 
91fc			 
91fc			; debug editor 
91fc			 
91fc			.diagedit: 
91fc			 
91fc 21 dd e4			ld hl, scratch 
91ff			;	ld bc, 250 
91ff			;	ldir 
91ff				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
91ff 3e 00			ld a, 0 
9201 77				ld (hl), a 
9202 23				inc hl 
9203 77				ld (hl), a 
9204 23				inc hl 
9205 77				ld (hl), a 
9206			 
9206 cd 75 88		        call clear_display 
9209 cd 98 88			call update_display 
920c				;ld a, 1 
920c				;ld (hardware_diag), a 
920c			.diloop: 
920c 3e 00			ld a, display_row_1 
920e 0e 00			ld c, 0 
9210 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9212 1e 28			ld e, 40 
9214			 
9214 21 dd e4			ld hl, scratch	 
9217 cd cf 8a			call input_str 
921a			 
921a 3e 14			ld a, display_row_2 
921c 11 dd e4			ld de, scratch 
921f cd 88 88			call str_at_display 
9222 cd 98 88			call update_display 
9225			 
9225 c3 0c 92			jp .diloop 
9228			 
9228			 
9228			; pass word in hl 
9228			; a has display location 
9228			display_word_at: 
9228 f5				push af 
9229 e5				push hl 
922a 7c				ld a,h 
922b 21 e2 e7			ld hl, os_word_scratch 
922e cd a3 8d			call hexout 
9231 e1				pop hl 
9232 7d				ld a,l 
9233 21 e4 e7			ld hl, os_word_scratch+2 
9236 cd a3 8d			call hexout 
9239 21 e6 e7			ld hl, os_word_scratch+4 
923c 3e 00			ld a,0 
923e 77				ld (hl),a 
923f 11 e2 e7			ld de,os_word_scratch 
9242 f1				pop af 
9243 cd 88 88				call str_at_display 
9246 c9				ret 
9247			 
9247			display_ptr_state: 
9247			 
9247				; to restore afterwards 
9247			 
9247 d5				push de 
9248 c5				push bc 
9249 e5				push hl 
924a f5				push af 
924b			 
924b				; for use in here 
924b			 
924b			;	push bc 
924b			;	push de 
924b			;	push hl 
924b			;	push af 
924b			 
924b cd 75 88			call clear_display 
924e			 
924e 11 21 94			ld de, .ptrstate 
9251 3e 00			ld a, display_row_1 
9253 cd 88 88			call str_at_display 
9256			 
9256				; display debug step 
9256			 
9256			 
9256 11 b7 ee			ld de, debug_mark 
9259 3e 12			ld a, display_row_1+display_cols-2 
925b cd 88 88			call str_at_display 
925e			 
925e				; display a 
925e 11 2b 94			ld de, .ptrcliptr 
9261 3e 14			ld a, display_row_2 
9263 cd 88 88			call str_at_display 
9266			 
9266 f1				pop af 
9267 2a a8 ec			ld hl,(cli_ptr) 
926a 3e 1c			ld a, display_row_2+8 
926c cd 28 92			call display_word_at 
926f			 
926f			 
926f				; display hl 
926f			 
926f			 
926f 11 33 94			ld de, .ptrclioptr 
9272 3e 1e			ld a, display_row_2+10 
9274 cd 88 88			call str_at_display 
9277			; 
9277			;	pop hl 
9277 3e 21			ld a, display_row_2+13 
9279 2a a6 ec			ld hl,(cli_origptr) 
927c cd 28 92			call display_word_at 
927f			; 
927f			;	 
927f			;	; display de 
927f			 
927f			;	ld de, .regstatede 
927f			;	ld a, display_row_3 
927f			;	call str_at_display 
927f			 
927f			;	pop de 
927f			;	ld h,d 
927f			;	ld l, e 
927f			;	ld a, display_row_3+3 
927f			;	call display_word_at 
927f			 
927f			 
927f				; display bc 
927f			 
927f			;	ld de, .regstatebc 
927f			;	ld a, display_row_3+10 
927f			;	call str_at_display 
927f			 
927f			;	pop bc 
927f			;	ld h,b 
927f			;	ld l, c 
927f			;	ld a, display_row_3+13 
927f			;	call display_word_at 
927f			 
927f			 
927f				; display dsp 
927f			 
927f			;	ld de, .regstatedsp 
927f			;	ld a, display_row_4 
927f			;	call str_at_display 
927f			 
927f				 
927f			;	ld hl,(cli_data_sp) 
927f			;	ld a, display_row_4+4 
927f			;	call display_word_at 
927f			 
927f				; display rsp 
927f			 
927f 11 62 94			ld de, .regstatersp 
9282 3e 46			ld a, display_row_4+10 
9284 cd 88 88			call str_at_display 
9287			 
9287				 
9287 2a 8e ec			ld hl,(cli_ret_sp) 
928a 3e 4a			ld a, display_row_4+14 
928c cd 28 92			call display_word_at 
928f			 
928f cd 98 88			call update_display 
9292			 
9292 cd f2 87			call delay1s 
9295 cd f2 87			call delay1s 
9298 cd f2 87			call delay1s 
929b			 
929b			 
929b cd 75 98			call next_page_prompt 
929e			 
929e				; restore  
929e			 
929e f1				pop af 
929f e1				pop hl 
92a0 c1				pop bc 
92a1 d1				pop de 
92a2 c9				ret 
92a3			 
92a3			break_point_state: 
92a3 f5				push af 
92a4			 
92a4				; see if disabled 
92a4			 
92a4 3a ce e4			ld a, (os_view_disable) 
92a7 fe 2a			cp '*' 
92a9 20 02			jr nz, .bpsgo 
92ab f1				pop af 
92ac c9				ret 
92ad			 
92ad			.bpsgo: 
92ad f1				pop af 
92ae f5				push af 
92af 22 ca e4			ld (os_view_hl), hl 
92b2 ed 53 c8 e4		ld (os_view_de), de 
92b6 ed 43 c6 e4		ld (os_view_bc), bc 
92ba e5				push hl 
92bb 6f				ld l, a 
92bc 26 00			ld h, 0 
92be 22 cc e4			ld (os_view_af),hl 
92c1			 
92c1 21 4d ee				ld hl, display_fb0 
92c4 22 58 ed				ld (display_fb_active), hl 
92c7 e1				pop hl	 
92c8			 
92c8 3e 31			ld a, '1' 
92ca fe 2a		.bps1:  cp '*' 
92cc 20 03			jr nz, .bps1b 
92ce 32 ce e4			ld (os_view_disable),a 
92d1 fe 31		.bps1b:  cp '1' 
92d3 20 14			jr nz, .bps2 
92d5			 
92d5				; display reg 
92d5			 
92d5				 
92d5			 
92d5 3a cc e4			ld a, (os_view_af) 
92d8 2a ca e4			ld hl, (os_view_hl) 
92db ed 5b c8 e4		ld de, (os_view_de) 
92df ed 4b c6 e4		ld bc, (os_view_bc) 
92e3 cd 7d 93			call display_reg_state 
92e6 c3 69 93			jp .bpschk 
92e9			 
92e9 fe 32		.bps2:  cp '2' 
92eb 20 08			jr nz, .bps3 
92ed				 
92ed				; display hl 
92ed 2a ca e4			ld hl, (os_view_hl) 
92f0 cd 67 94			call display_dump_at_hl 
92f3			 
92f3 18 74			jr .bpschk 
92f5			 
92f5 fe 33		.bps3:  cp '3' 
92f7 20 08			jr nz, .bps4 
92f9			 
92f9			        ; display de 
92f9 2a c8 e4			ld hl, (os_view_de) 
92fc cd 67 94			call display_dump_at_hl 
92ff			 
92ff 18 68			jr .bpschk 
9301 fe 34		.bps4:  cp '4' 
9303 20 08			jr nz, .bps5 
9305			 
9305			        ; display bc 
9305 2a c6 e4			ld hl, (os_view_bc) 
9308 cd 67 94			call display_dump_at_hl 
930b			 
930b 18 5c			jr .bpschk 
930d fe 35		.bps5:  cp '5' 
930f 20 08		        jr nz, .bps7 
9311			 
9311				; display cur ptr 
9311 2a a8 ec			ld hl, (cli_ptr) 
9314 cd 67 94			call display_dump_at_hl 
9317			 
9317 18 50			jr .bpschk 
9319 fe 36		.bps7:  cp '6' 
931b 20 08			jr nz, .bps8b 
931d				 
931d				; display cur orig ptr 
931d 2a a6 ec			ld hl, (cli_origptr) 
9320 cd 67 94			call display_dump_at_hl 
9323 18 44			jr .bpschk 
9325 fe 37		.bps8b:  cp '7' 
9327 20 08			jr nz, .bps9 
9329				 
9329				; display dsp 
9329 2a 8a ec			ld hl, (cli_data_sp) 
932c cd 67 94			call display_dump_at_hl 
932f			 
932f 18 38			jr .bpschk 
9331 fe 39		.bps9:  cp '9' 
9333 20 05			jr nz, .bps8c 
9335				 
9335				; display SP 
9335			;	ld hl, sp 
9335 cd 67 94			call display_dump_at_hl 
9338			 
9338 18 2f			jr .bpschk 
933a fe 38		.bps8c:  cp '8' 
933c 20 08			jr nz, .bps8d 
933e				 
933e				; display rsp 
933e 2a 8e ec			ld hl, (cli_ret_sp) 
9341 cd 67 94			call display_dump_at_hl 
9344			 
9344 18 23			jr .bpschk 
9346 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9348 20 05			jr nz, .bps8 
934a cd 6b 96			call monitor 
934d			 
934d 18 1a			jr .bpschk 
934f fe 30		.bps8:  cp '0' 
9351 20 16			jr nz, .bpschk 
9353			 
9353 21 fc ed				ld hl, display_fb1 
9356 22 58 ed				ld (display_fb_active), hl 
9359 cd 98 88				call update_display 
935c			 
935c				;ld a, (os_view_af) 
935c 2a ca e4			ld hl, (os_view_hl) 
935f ed 5b c8 e4		ld de, (os_view_de) 
9363 ed 4b c6 e4		ld bc, (os_view_bc) 
9367 f1				pop af 
9368 c9				ret 
9369			 
9369			.bpschk:   
9369 cd f2 87			call delay1s 
936c 3e 4f		ld a,display_row_4 + display_cols - 1 
936e 11 73 98		        ld de, endprg 
9371 cd 88 88			call str_at_display 
9374 cd 98 88			call update_display 
9377 cd ce d7			call cin_wait 
937a			 
937a c3 ca 92			jp .bps1 
937d			 
937d			 
937d			display_reg_state: 
937d			 
937d				; to restore afterwards 
937d			 
937d d5				push de 
937e c5				push bc 
937f e5				push hl 
9380 f5				push af 
9381			 
9381				; for use in here 
9381			 
9381 c5				push bc 
9382 d5				push de 
9383 e5				push hl 
9384 f5				push af 
9385			 
9385 cd 75 88			call clear_display 
9388			 
9388 11 3d 94			ld de, .regstate 
938b 3e 00			ld a, display_row_1 
938d cd 88 88			call str_at_display 
9390			 
9390				; display debug step 
9390			 
9390			 
9390 11 b7 ee			ld de, debug_mark 
9393 3e 11			ld a, display_row_1+display_cols-3 
9395 cd 88 88			call str_at_display 
9398			 
9398				; display a 
9398 11 59 94			ld de, .regstatea 
939b 3e 14			ld a, display_row_2 
939d cd 88 88			call str_at_display 
93a0			 
93a0 e1				pop hl 
93a1			;	ld h,0 
93a1			;	ld l, a 
93a1 3e 17			ld a, display_row_2+3 
93a3 cd 28 92			call display_word_at 
93a6			 
93a6			 
93a6				; display hl 
93a6			 
93a6			 
93a6 11 4d 94			ld de, .regstatehl 
93a9 3e 1e			ld a, display_row_2+10 
93ab cd 88 88			call str_at_display 
93ae			 
93ae e1				pop hl 
93af 3e 21			ld a, display_row_2+13 
93b1 cd 28 92			call display_word_at 
93b4			 
93b4				 
93b4				; display de 
93b4			 
93b4 11 51 94			ld de, .regstatede 
93b7 3e 28			ld a, display_row_3 
93b9 cd 88 88			call str_at_display 
93bc			 
93bc e1				pop hl 
93bd			;	ld h,d 
93bd			;	ld l, e 
93bd 3e 2b			ld a, display_row_3+3 
93bf cd 28 92			call display_word_at 
93c2			 
93c2			 
93c2				; display bc 
93c2			 
93c2 11 55 94			ld de, .regstatebc 
93c5 3e 32			ld a, display_row_3+10 
93c7 cd 88 88			call str_at_display 
93ca			 
93ca e1				pop hl 
93cb			;	ld h,b 
93cb			;	ld l, c 
93cb 3e 35			ld a, display_row_3+13 
93cd cd 28 92			call display_word_at 
93d0			 
93d0			 
93d0				; display dsp 
93d0			 
93d0 11 5d 94			ld de, .regstatedsp 
93d3 3e 3c			ld a, display_row_4 
93d5 cd 88 88			call str_at_display 
93d8			 
93d8				 
93d8 2a 8a ec			ld hl,(cli_data_sp) 
93db 3e 40			ld a, display_row_4+4 
93dd cd 28 92			call display_word_at 
93e0			 
93e0				; display rsp 
93e0			 
93e0 11 62 94			ld de, .regstatersp 
93e3 3e 46			ld a, display_row_4+10 
93e5 cd 88 88			call str_at_display 
93e8			 
93e8				 
93e8 2a 8e ec			ld hl,(cli_ret_sp) 
93eb 3e 4a			ld a, display_row_4+14 
93ed cd 28 92			call display_word_at 
93f0			 
93f0 cd 98 88			call update_display 
93f3			 
93f3			;	call delay1s 
93f3			;	call delay1s 
93f3			;	call delay1s 
93f3			 
93f3			 
93f3			;	call next_page_prompt 
93f3			 
93f3				; restore  
93f3			 
93f3 f1				pop af 
93f4 e1				pop hl 
93f5 c1				pop bc 
93f6 d1				pop de 
93f7 c9				ret 
93f8			 
93f8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
940c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9421 .. 00		.ptrstate:	db "Ptr State",0 
942b .. 00		.ptrcliptr:     db "cli_ptr",0 
9433 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
943d .. 00		.regstate:	db "Reg State (1/0)",0 
944d .. 00		.regstatehl:	db "HL:",0 
9451 .. 00		.regstatede:	db "DE:",0 
9455 .. 00		.regstatebc:	db "BC:",0 
9459 .. 00		.regstatea:	db "A :",0 
945d .. 00		.regstatedsp:	db "DSP:",0 
9462 .. 00		.regstatersp:	db "RSP:",0 
9467			 
9467			display_dump_at_hl: 
9467 e5				push hl 
9468 d5				push de 
9469 c5				push bc 
946a f5				push af 
946b			 
946b 22 00 e8			ld (os_cur_ptr),hl	 
946e cd 75 88			call clear_display 
9471 cd 7d 97			call dumpcont 
9474			;	call delay1s 
9474			;	call next_page_prompt 
9474			 
9474			 
9474 f1				pop af 
9475 c1				pop bc 
9476 d1				pop de 
9477 e1				pop hl 
9478 c9				ret 
9479			 
9479			;if ENABLE_BASIC 
9479			;	include "nascombasic.asm" 
9479			;	basic: 
9479			;	include "forth/FORTH.ASM" 
9479			;endif 
9479			 
9479			; eof 
9479			 
9479			 
# End of file firmware_diags.asm
9479			  
9479			include "firmware_prompts.asm"  
9479			; Prompts  
9479			 
9479			; boot messages 
9479			 
9479 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.5",0 
948e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
949e			 
949e			 
949e			; config menus 
949e			 
949e .. 00		prom_c3: db "Add Dictionary To File",0 
94b5 .. 00		prom_c2: db "Select Autoload File",0 
94ca .. 00		prom_c2a: db "Disable Autoload File", 0 
94e0 .. 00		prom_c2b: db "Select Storage Bank",0 
94f4 .. 00		prom_c4: db "Settings",0 
94fd .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9518 .. 00		prom_m4b:   db "Monitor",0 
9520 .. 00		prom_c1: db "Hardware Diags",0 
952f			 
952f			 
952f .. 00		prom_notav:    db "Feature not available",0 
9545 .. 00		prom_empty:    db "",0 
9546			 
9546			; eof 
9546			 
# End of file firmware_prompts.asm
9546			  
9546			  
9546			; eof  
9546			  
# End of file firmware.asm
9546			 
9546			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9546			;if BASE_KEV  
9546			;baseram: equ 08000h 
9546			;endif 
9546			 
9546			;if BASE_SC114 
9546			;baseram:     equ    endofcode 
9546			;endif 
9546			 
9546			 
9546			; start system 
9546			 
9546			coldstart: 
9546				; set sp 
9546				; di/ei 
9546			 
9546 f3				di 
9547 31 00 f0			ld sp, tos 
954a			;	ei 
954a			 
954a			 
954a				; disable breakpoint by default 
954a			 
954a 3e 2a			ld a,'*' 
954c 32 ce e4			ld (os_view_disable),a 
954f			 
954f				; init hardware 
954f			 
954f				; init keyboard and screen hardware 
954f			 
954f cd 03 80			call hardware_init 
9552			 
9552			 
9552				; detect if any keys are held down to enable breakpoints at start up 
9552			 
9552 cd d4 d7			call cin  
9555 fe 00			cp 0 
9557 28 03			jr z, .nokeys 
9559			 
9559				;call hardware_diags 
9559 cd 02 91			call config 
955c			 
955c			;	ld de, .bpen 
955c			;	ld a, display_row_4 
955c			;	call str_at_display 
955c			;	call update_display 
955c			; 
955c			;	ld a,0 
955c			;	ld (os_view_disable),a 
955c			; 
955c			;.bpwait: 
955c			;	call cin 
955c			;	cp 0 
955c			;	jr z, .bpwait 
955c			;	jr .nokeys 
955c			; 
955c			; 
955c			;.bpen:  db "Break points enabled!",0 
955c			 
955c			 
955c			 
955c			 
955c			 
955c			 
955c			.nokeys: 
955c			 
955c			 
955c				 
955c			 
955c			;jp  testkey 
955c			 
955c			;call storage_get_block_0 
955c			; 
955c			;ld hl, 0 
955c			;ld de, store_page 
955c			;call storage_read_block 
955c			 
955c				 
955c			;ld hl, 10 
955c			;ld de, store_page 
955c			;call storage_read_block 
955c			 
955c			 
955c			 
955c			 
955c			 
955c			;stop:	nop 
955c			;	jp stop 
955c			 
955c			 
955c			 
955c			main: 
955c cd 75 88			call clear_display 
955f cd 98 88			call update_display 
9562			 
9562			 
9562			 
9562			;	call testlcd 
9562			 
9562			 
9562			 
9562 cd 3b 9c			call forth_init 
9565			 
9565			 
9565			warmstart: 
9565 cd 11 9c			call forth_warmstart 
9568			 
9568				; run startup word load 
9568			        ; TODO prevent this running at warmstart after crash  
9568			 
9568				if STARTUP_ENABLE 
9568					if STORAGE_SE 
9568						call forth_autoload 
9568					endif 
9568 cd 68 d4				call forth_startup 
956b			 
956b			 
956b				endif 
956b			 
956b				; show free memory after boot 
956b 11 05 96			ld de, freeram 
956e 3e 00			ld a, display_row_1 
9570 cd 88 88			call str_at_display 
9573			 
9573			; Or use heap_size word???? 
9573 21 c3 e4			ld hl, heap_end 
9576 11 f2 d7			ld de, heap_start 
9579 ed 52			sbc hl, de 
957b e5				push hl 
957c 7c				ld a,h	         	 
957d 21 e2 e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9580 cd a3 8d			call hexout 
9583 e1			   	pop hl 
9584			 
9584 7d				ld a,l 
9585 21 e4 e7			ld hl, os_word_scratch+2 
9588 cd a3 8d			call hexout 
958b 21 e6 e7			ld hl, os_word_scratch+4 
958e 3e 00			ld a, 0 
9590 77				ld (hl),a 
9591 11 e2 e7			ld de, os_word_scratch 
9594 3e 0d			ld a, display_row_1 + 13 
9596 cd 88 88			call str_at_display 
9599 cd 98 88			call update_display 
959c			 
959c			 
959c				;call demo 
959c			 
959c			 
959c				; init scratch input area for cli commands 
959c			 
959c 21 04 e8			ld hl, os_cli_cmd 
959f 3e 00			ld a,0 
95a1 77				ld (hl),a 
95a2 23				inc hl 
95a3 77				ld (hl),a 
95a4			 
95a4 3e 00			ld a,0 
95a6 32 03 e9			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
95a9			 
95a9 32 00 e8			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
95ac 32 01 e8			ld (os_cur_ptr+1),a	 
95af			 
95af 32 e2 e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
95b2 32 e3 e7			ld (os_word_scratch+1),a	 
95b5				 
95b5			 
95b5				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95b5 21 04 e8			ld hl, os_cli_cmd 
95b8			 
95b8 3e 00			ld a, 0		 ; init cli input 
95ba 77				ld (hl), a 
95bb 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95bd			cli: 
95bd				; show cli prompt 
95bd				;push af 
95bd				;ld a, 0 
95bd				;ld de, prompt 
95bd				;call str_at_display 
95bd			 
95bd				;call update_display 
95bd				;pop af 
95bd				;inc a 
95bd				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
95bd 0e 00			ld c, 0 
95bf 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
95c1 1e 28			ld e, 40 
95c3			 
95c3 21 04 e8			ld hl, os_cli_cmd 
95c6			 
95c6				STACKFRAME OFF $fefe $9f9f 
95c6				if DEBUG_STACK_IMB 
95c6					if OFF 
95c6						exx 
95c6						ld de, $fefe 
95c6						ld a, d 
95c6						ld hl, curframe 
95c6						call hexout 
95c6						ld a, e 
95c6						ld hl, curframe+2 
95c6						call hexout 
95c6						ld hl, $fefe 
95c6						push hl 
95c6						ld hl, $9f9f 
95c6						push hl 
95c6						exx 
95c6					endif 
95c6				endif 
95c6			endm 
# End of macro STACKFRAME
95c6			 
95c6 cd cf 8a			call input_str 
95c9			 
95c9				STACKFRAMECHK OFF $fefe $9f9f 
95c9				if DEBUG_STACK_IMB 
95c9					if OFF 
95c9						exx 
95c9						ld hl, $9f9f 
95c9						pop de   ; $9f9f 
95c9						call cmp16 
95c9						jr nz, .spnosame 
95c9						ld hl, $fefe 
95c9						pop de   ; $fefe 
95c9						call cmp16 
95c9						jr z, .spfrsame 
95c9						.spnosame: call showsperror 
95c9						.spfrsame: nop 
95c9						exx 
95c9					endif 
95c9				endif 
95c9			endm 
# End of macro STACKFRAMECHK
95c9			 
95c9				; copy input to last command 
95c9			 
95c9 21 04 e8			ld hl, os_cli_cmd 
95cc 11 03 e9			ld de, os_last_cmd 
95cf 01 ff 00			ld bc, 255 
95d2 ed b0			ldir 
95d4			 
95d4				; wipe current buffer 
95d4			 
95d4			;	ld a, 0 
95d4			;	ld hl, os_cli_cmd 
95d4			;	ld de, os_cli_cmd+1 
95d4			;	ld bc, 254 
95d4			;	ldir 
95d4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
95d4			;	call strcpy 
95d4			;	ld a, 0 
95d4			;	ld (hl), a 
95d4			;	inc hl 
95d4			;	ld (hl), a 
95d4			;	inc hl 
95d4			;	ld (hl), a 
95d4			 
95d4				; switch frame buffer to program  
95d4			 
95d4 21 fc ed				ld hl, display_fb1 
95d7 22 58 ed				ld (display_fb_active), hl 
95da			 
95da			;	nop 
95da				STACKFRAME ON $fbfe $8f9f 
95da				if DEBUG_STACK_IMB 
95da					if ON 
95da						exx 
95da						ld de, $fbfe 
95da						ld a, d 
95da						ld hl, curframe 
95da						call hexout 
95da						ld a, e 
95da						ld hl, curframe+2 
95da						call hexout 
95da						ld hl, $fbfe 
95da						push hl 
95da						ld hl, $8f9f 
95da						push hl 
95da						exx 
95da					endif 
95da				endif 
95da			endm 
# End of macro STACKFRAME
95da				; first time into the parser so pass over the current scratch pad 
95da 21 04 e8			ld hl,os_cli_cmd 
95dd				; tokenise the entered statement(s) in HL 
95dd cd b4 9c			call forthparse 
95e0			        ; exec forth statements in top of return stack 
95e0 cd f4 9c			call forthexec 
95e3				;call forthexec_cleanup 
95e3			;	call parsenext 
95e3			 
95e3				STACKFRAMECHK ON $fbfe $8f9f 
95e3				if DEBUG_STACK_IMB 
95e3					if ON 
95e3						exx 
95e3						ld hl, $8f9f 
95e3						pop de   ; $8f9f 
95e3						call cmp16 
95e3						jr nz, .spnosame 
95e3						ld hl, $fbfe 
95e3						pop de   ; $fbfe 
95e3						call cmp16 
95e3						jr z, .spfrsame 
95e3						.spnosame: call showsperror 
95e3						.spfrsame: nop 
95e3						exx 
95e3					endif 
95e3				endif 
95e3			endm 
# End of macro STACKFRAMECHK
95e3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
95e3			 
95e3 3e 3c			ld a, display_row_4 
95e5 11 17 96			ld de, endprog 
95e8			 
95e8 cd 98 88			call update_display		 
95eb			 
95eb cd 75 98			call next_page_prompt 
95ee			 
95ee				; switch frame buffer to cli 
95ee			 
95ee 21 4d ee				ld hl, display_fb0 
95f1 22 58 ed				ld (display_fb_active), hl 
95f4			 
95f4			 
95f4 cd 75 88		        call clear_display 
95f7 cd 98 88			call update_display		 
95fa			 
95fa 21 04 e8			ld hl, os_cli_cmd 
95fd			 
95fd 3e 00			ld a, 0		 ; init cli input 
95ff 77				ld (hl), a 
9600			 
9600				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9600			 
9600				; now on last line 
9600			 
9600				; TODO scroll screen up 
9600			 
9600				; TODO instead just clear screen and place at top of screen 
9600			 
9600			;	ld a, 0 
9600			;	ld (f_cursor_ptr),a 
9600			 
9600				;call clear_display 
9600				;call update_display 
9600			 
9600				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9600 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9602 c3 bd 95			jp cli 
9605			 
9605 .. 00		freeram: db "Free bytes: $",0 
9613 ..			asc: db "1A2F" 
9617 .. 00		endprog: db "End prog...",0 
9623			 
9623			testenter2:   
9623 21 0f e5			ld hl,scratch+50 
9626 22 00 e8			ld (os_cur_ptr),hl 
9629 c3 bd 95			jp cli 
962c			 
962c			testenter:  
962c			 
962c 21 13 96			ld hl,asc 
962f			;	ld a,(hl) 
962f			;	call nibble2val 
962f cd f9 8d			call get_byte 
9632			 
9632			 
9632			;	ld a,(hl) 
9632			;	call atohex 
9632			 
9632			;	call fourehexhl 
9632 32 0f e5			ld (scratch+50),a 
9635			 
9635			 
9635			 
9635 21 15 96			ld hl,asc+2 
9638			;	ld a, (hl) 
9638			;	call nibble2val 
9638 cd f9 8d			call get_byte 
963b			 
963b			;	call fourehexhl 
963b 32 11 e5			ld (scratch+52),a 
963e				 
963e 21 0f e5			ld hl,scratch+50 
9641 22 00 e8			ld (os_cur_ptr),hl 
9644 c3 bd 95			jp cli 
9647			 
9647			enter:	 
9647 3a e1 e4			ld a,(scratch+4) 
964a fe 00			cp 0 
964c 28 0c			jr z, .entercont 
964e				; no, not a null term line so has an address to work out.... 
964e			 
964e 21 df e4			ld hl,scratch+2 
9651 cd 59 8e			call get_word_hl 
9654			 
9654 22 00 e8			ld (os_cur_ptr),hl	 
9657 c3 bd 95			jp cli 
965a			 
965a			 
965a			.entercont:  
965a			 
965a 21 df e4			ld hl, scratch+2 
965d cd f9 8d			call get_byte 
9660			 
9660 2a 00 e8		   	ld hl,(os_cur_ptr) 
9663 77					ld (hl),a 
9664 23					inc hl 
9665 22 00 e8				ld (os_cur_ptr),hl 
9668				 
9668			; get byte  
9668			 
9668			 
9668 c3 bd 95			jp cli 
966b			 
966b			 
966b			; basic monitor support 
966b			 
966b			monitor: 
966b				;  
966b cd 75 88			call clear_display 
966e 3e 00			ld a, 0 
9670 11 b8 96			ld de, .monprompt 
9673 cd 88 88			call str_at_display 
9676 cd 98 88			call update_display 
9679			 
9679				; get a monitor command 
9679			 
9679 0e 00			ld c, 0     ; entry at top left 
967b 16 64			ld d, 100   ; max buffer size 
967d 1e 0f			ld e, 15    ; input scroll area 
967f 3e 00			ld a, 0     ; init string 
9681 21 db e6			ld hl, os_input 
9684 77				ld (hl), a 
9685 23				inc hl 
9686 77				ld (hl), a 
9687 21 db e6			ld hl, os_input 
968a 3e 01			ld a, 1     ; init string 
968c cd cf 8a			call input_str 
968f			 
968f cd 75 88		        call clear_display 
9692 cd 98 88			call update_display		 
9695			 
9695 3a db e6			ld a, (os_input) 
9698 cd f7 8e			call toUpper 
969b fe 48		        cp 'H' 
969d 28 6f		        jr z, .monhelp 
969f fe 44			cp 'D'		; dump 
96a1 ca 2f 97			jp z, .mondump	 
96a4 fe 43			cp 'C'		; dump 
96a6 ca 49 97			jp z, .moncdump	 
96a9 fe 4d			cp 'M'		; dump 
96ab ca ba 96			jp z, .moneditstart 
96ae fe 55			cp 'U'		; dump 
96b0 28 14			jr z, .monedit	 
96b2 fe 51			cp 'Q'		; dump 
96b4 c8				ret z	 
96b5			 
96b5			 
96b5				; TODO "S" to access symbol by name and not need the address 
96b5				; TODO "F" to find a string in memory 
96b5			 
96b5 c3 6b 96			jp monitor 
96b8			 
96b8 .. 00		.monprompt: db ">", 0 
96ba			 
96ba			.moneditstart: 
96ba				; get starting address 
96ba			 
96ba 21 dd e6			ld hl,os_input+2 
96bd cd 59 8e			call get_word_hl 
96c0			 
96c0 22 00 e8			ld (os_cur_ptr),hl	 
96c3			 
96c3 c3 6b 96			jp monitor 
96c6			 
96c6			.monedit: 
96c6				; get byte to load 
96c6			 
96c6 21 dd e6			ld hl,os_input+2 
96c9 cd f9 8d			call get_byte 
96cc			 
96cc				; get address to update 
96cc 2a 00 e8			ld hl, (os_cur_ptr) 
96cf			 
96cf				; update byte 
96cf			 
96cf 77				ld (hl), a 
96d0			 
96d0				; move to next address and save it 
96d0			 
96d0 23				inc hl 
96d1 22 00 e8			ld (os_cur_ptr),hl	 
96d4			 
96d4 c3 6b 96			jp monitor 
96d7			 
96d7			 
96d7 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
96eb .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9707 .. 00		.monhelptext3:  db "Q-Quit",0 
970e			        
970e			.monhelp: 
970e 3e 00			ld a, display_row_1 
9710 11 d7 96		        ld de, .monhelptext1 
9713			 
9713 cd 88 88			call str_at_display 
9716 3e 14			ld a, display_row_2 
9718 11 eb 96		        ld de, .monhelptext2 
971b					 
971b cd 88 88			call str_at_display 
971e 3e 28			ld a, display_row_3 
9720 11 07 97		        ld de, .monhelptext3 
9723					 
9723 cd 88 88			call str_at_display 
9726 cd 98 88			call update_display		 
9729			 
9729 cd 75 98			call next_page_prompt 
972c c3 6b 96			jp monitor 
972f			 
972f			.mondump:    
972f 21 dd e6			ld hl,os_input+2 
9732 cd 59 8e			call get_word_hl 
9735			 
9735 22 00 e8			ld (os_cur_ptr),hl	 
9738 cd 7d 97			call dumpcont 
973b 3e 3c			ld a, display_row_4 
973d 11 17 96			ld de, endprog 
9740			 
9740 cd 98 88			call update_display		 
9743			 
9743 cd 75 98			call next_page_prompt 
9746 c3 6b 96			jp monitor 
9749			.moncdump: 
9749 cd 7d 97			call dumpcont 
974c 3e 3c			ld a, display_row_4 
974e 11 17 96			ld de, endprog 
9751			 
9751 cd 98 88			call update_display		 
9754			 
9754 cd 75 98			call next_page_prompt 
9757 c3 6b 96			jp monitor 
975a			 
975a			 
975a			; TODO symbol access  
975a			 
975a			.symbols:     ;; A list of symbols that can be called up  
975a 4d ee			dw display_fb0 
975c .. 00			db "fb0",0  
9760 e2 ec		     	dw store_page 
9762 .. 00			db "store_page",0 
976d			 
976d			 
976d			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
976d			 
976d 3a de e4			ld a,(scratch+1) 
9770 fe 00			cp 0 
9772 28 09			jr z, dumpcont 
9774			 
9774				; no, not a null term line so has an address to work out.... 
9774			 
9774 21 df e4			ld hl,scratch+2 
9777 cd 59 8e			call get_word_hl 
977a			 
977a 22 00 e8			ld (os_cur_ptr),hl	 
977d			 
977d			 
977d			 
977d			dumpcont: 
977d			 
977d				; dump bytes at ptr 
977d			 
977d			 
977d 3e 00			ld a, display_row_1 
977f 2a 58 ed			ld hl, (display_fb_active) 
9782 cd a2 8a			call addatohl 
9785 cd ad 97			call .dumpbyterow 
9788			 
9788 3e 14			ld a, display_row_2 
978a 2a 58 ed			ld hl, (display_fb_active) 
978d cd a2 8a			call addatohl 
9790 cd ad 97			call .dumpbyterow 
9793			 
9793			 
9793 3e 28			ld a, display_row_3 
9795 2a 58 ed			ld hl, (display_fb_active) 
9798 cd a2 8a			call addatohl 
979b cd ad 97			call .dumpbyterow 
979e			 
979e 3e 3c			ld a, display_row_4 
97a0 2a 58 ed			ld hl, (display_fb_active) 
97a3 cd a2 8a			call addatohl 
97a6 cd ad 97			call .dumpbyterow 
97a9			 
97a9 cd 98 88			call update_display 
97ac			;		jp cli 
97ac c9				ret 
97ad			 
97ad			.dumpbyterow: 
97ad			 
97ad				;push af 
97ad			 
97ad e5				push hl 
97ae			 
97ae				; calc where to poke the ascii 
97ae			if display_cols == 20 
97ae 3e 10			ld a, 16 
97b0			else 
97b0				ld a, 31 
97b0			endif 
97b0			 
97b0 cd a2 8a			call addatohl 
97b3 22 e2 e7			ld (os_word_scratch),hl  		; save pos for later 
97b6			 
97b6			 
97b6			; display decoding address 
97b6 2a 00 e8		   	ld hl,(os_cur_ptr) 
97b9			 
97b9 7c				ld a,h 
97ba e1				pop hl 
97bb e5				push hl 
97bc			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97bc cd a3 8d			call hexout 
97bf 2a 00 e8		   	ld hl,(os_cur_ptr) 
97c2			 
97c2 7d				ld a,l 
97c3 e1				pop hl 
97c4 23				inc hl 
97c5 23				inc hl 
97c6 e5				push hl 
97c7			;	ld hl, os_word_scratch+2 
97c7 cd a3 8d			call hexout 
97ca e1				pop hl 
97cb 23				inc hl 
97cc 23				inc hl 
97cd				;ld hl, os_word_scratch+4 
97cd 3e 3a			ld a, ':' 
97cf 77				ld (hl),a 
97d0 23				inc hl 
97d1				;ld a, 0 
97d1				;ld (hl),a 
97d1				;ld de, os_word_scratch 
97d1				;pop af 
97d1				;push af 
97d1			;		ld a, display_row_2 
97d1			;		call str_at_display 
97d1			;		call update_display 
97d1			 
97d1			 
97d1			;pop af 
97d1			;	add 5 
97d1			 
97d1			if display_cols == 20 
97d1 06 04			ld b, 4 
97d3			else 
97d3				ld b, 8 
97d3			endif	 
97d3			 
97d3			.dumpbyte: 
97d3 c5				push bc 
97d4 e5				push hl 
97d5			 
97d5			 
97d5 2a 00 e8		   	ld hl,(os_cur_ptr) 
97d8 7e					ld a,(hl) 
97d9			 
97d9					; poke the ascii to display 
97d9 2a e2 e7				ld hl,(os_word_scratch) 
97dc 77					ld (hl),a 
97dd 23					inc hl 
97de 22 e2 e7				ld (os_word_scratch),hl 
97e1			 
97e1					 
97e1			 
97e1			 
97e1 e1					pop hl 
97e2 e5					push hl 
97e3			 
97e3 cd a3 8d				call hexout 
97e6			 
97e6					 
97e6 2a 00 e8		   	ld hl,(os_cur_ptr) 
97e9 23				inc hl 
97ea 22 00 e8		   	ld (os_cur_ptr),hl 
97ed			 
97ed e1					pop hl 
97ee 23					inc hl 
97ef 23					inc hl 
97f0 23					inc hl 
97f1			 
97f1			 
97f1			 
97f1					;ld a,0 
97f1					;ld (os_word_scratch+2),a 
97f1					;pop af 
97f1					;push af 
97f1			 
97f1					;ld de, os_word_scratch 
97f1					;call str_at_display 
97f1			;		call update_display 
97f1			;		pop af 
97f1 c1					pop bc 
97f2 c6 03				add 3 
97f4 10 dd			djnz .dumpbyte 
97f6			 
97f6				 
97f6			 
97f6 c9				ret 
97f7			 
97f7			jump:	 
97f7			 
97f7 21 df e4			ld hl,scratch+2 
97fa cd 59 8e			call get_word_hl 
97fd				;ld hl,(scratch+2) 
97fd				;call fourehexhl 
97fd			 
97fd 22 00 e8			ld (os_cur_ptr),hl	 
9800			 
9800 e9				jp (hl) 
9801			 
9801			 
9801			 
9801			; TODO implement a basic monitor mode to start with 
9801			 
9801			 
9801			 
9801			 
9801			 
9801			 
9801			 
9801			 
9801			 
9801			; testing and demo code during development 
9801			 
9801			 
9801 .. 00		str1: db "Enter some text...",0 
9814 .. 00		clear: db "                    ",0 
9829			 
9829			demo: 
9829			 
9829			 
9829			 
9829			;	call update_display 
9829			 
9829				; init scratch input area for testing 
9829 21 dd e4			ld hl, scratch	 
982c 3e 00			ld a,0 
982e 77				ld (hl),a 
982f			 
982f			 
982f 3e 14		            LD   A, display_row_2 
9831			;            CALL fLCD_Pos       ;Position cursor to location in A 
9831 11 01 98		            LD   DE, str1 
9834 cd 88 88			call str_at_display 
9837			 
9837			;            CALL fLCD_Str       ;Display string pointed to by DE 
9837			cloop:	 
9837 3e 28		            LD   A, display_row_3 
9839			;            CALL fLCD_Pos       ;Position cursor to location in A 
9839 11 14 98		            LD   DE, clear 
983c			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
983c cd 88 88				call str_at_display 
983f 3e 3c			ld a, display_row_4 
9841 11 71 98			ld de, prompt 
9844			 
9844 cd 88 88				call str_at_display 
9847 cd 98 88			call update_display 
984a			 
984a 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
984c 16 0a			ld d, 10 
984e 21 dd e4			ld hl, scratch	 
9851 cd cf 8a			call input_str 
9854			 
9854			;	call clear_display 
9854			;'	call update_display 
9854			 
9854 3e 00		            LD   A, display_row_1 
9856			;            CALL fLCD_Pos       ;Position cursor to location in A 
9856 11 14 98		            LD   DE, clear 
9859 cd 88 88				call str_at_display 
985c			;            CALL fLCD_Str       ;Display string pointed to by DE 
985c 3e 00		            LD   A, display_row_1 
985e			;            CALL fLCD_Pos       ;Position cursor to location in A 
985e 11 dd e4		            LD   DE, scratch 
9861			;            CALL fLCD_Str       ;Display string pointed to by DE 
9861 cd 88 88				call str_at_display 
9864 cd 98 88			call update_display 
9867			 
9867 3e 00				ld a,0 
9869 21 dd e4			ld hl, scratch 
986c 77				ld (hl),a 
986d			 
986d 00				nop 
986e c3 37 98			jp cloop 
9871			 
9871			 
9871			 
9871			; OS Prompt 
9871			 
9871 .. 00		prompt: db ">",0 
9873 .. 00		endprg: db "?",0 
9875			 
9875			 
9875			; handy next page prompt 
9875			next_page_prompt: 
9875 e5				push hl 
9876 d5				push de 
9877 f5				push af 
9878 c5				push bc 
9879			 
9879 3e 4f			ld a,display_row_4 + display_cols - 1 
987b 11 73 98		        ld de, endprg 
987e cd 88 88			call str_at_display 
9881 cd 98 88			call update_display 
9884 cd ce d7			call cin_wait 
9887 c1				pop bc 
9888 f1				pop af 
9889 d1				pop de 
988a e1				pop hl 
988b			 
988b			 
988b c9				ret 
988c			 
988c			 
988c			; forth parser 
988c			 
988c			; My forth kernel 
988c			include "forth_kernel.asm" 
988c			; 
988c			; kernel to the forth OS 
988c			 
988c			DS_TYPE_STR: equ 1     ; string type 
988c			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
988c			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
988c			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
988c			 
988c			FORTH_PARSEV1: equ 0 
988c			FORTH_PARSEV2: equ 0 
988c			FORTH_PARSEV3: equ 0 
988c			FORTH_PARSEV4: equ 0 
988c			FORTH_PARSEV5: equ 1 
988c			 
988c			;if FORTH_PARSEV5 
988c			;	FORTH_END_BUFFER: equ 0 
988c			;else 
988c			FORTH_END_BUFFER: equ 127 
988c			;endif 
988c			 
988c			FORTH_TRUE: equ 1 
988c			FORTH_FALSE: equ 0 
988c			 
988c			if FORTH_PARSEV4 
988c			include "forth_stackops.asm" 
988c			endif 
988c			 
988c			if FORTH_PARSEV5 
988c			include "forth_stackopsv5.asm" 
988c			 
988c			; Stack operations for v5 parser on wards 
988c			; * DATA stack 
988c			; * LOOP stack 
988c			; * RETURN stack 
988c			 
988c			 
988c			 
988c			FORTH_CHK_DSP_UNDER: macro 
988c				push hl 
988c				push de 
988c				ld hl,(cli_data_sp) 
988c				ld de, cli_data_stack 
988c				call cmp16 
988c				jp c, fault_dsp_under 
988c				pop de 
988c				pop hl 
988c				endm 
988c			 
988c			 
988c			FORTH_CHK_RSP_UNDER: macro 
988c				push hl 
988c				push de 
988c				ld hl,(cli_ret_sp) 
988c				ld de, cli_ret_stack 
988c				call cmp16 
988c				jp c, fault_rsp_under 
988c				pop de 
988c				pop hl 
988c				endm 
988c			 
988c			FORTH_CHK_LOOP_UNDER: macro 
988c				push hl 
988c				push de 
988c				ld hl,(cli_loop_sp) 
988c				ld de, cli_loop_stack 
988c				call cmp16 
988c				jp c, fault_loop_under 
988c				pop de 
988c				pop hl 
988c				endm 
988c			 
988c			FORTH_ERR_TOS_NOTSTR: macro 
988c				; TOSO might need more for checks when used 
988c				push af 
988c				ld a,(hl) 
988c				cp DS_TYPE_STR 
988c				jp nz, type_faultn   
988c				pop af 
988c				endm 
988c			 
988c			FORTH_ERR_TOS_NOTNUM: macro 
988c				push af 
988c				ld a,(hl) 
988c				cp DS_TYPE_INUM 
988c				jp nz, type_faultn   
988c				pop af 
988c				endm 
988c			 
988c			 
988c			; increase data stack pointer and save hl to it 
988c				 
988c			FORTH_DSP_NEXT: macro 
988c				call macro_forth_dsp_next 
988c				endm 
988c			 
988c			 
988c			macro_forth_dsp_next: 
988c				if DEBUG_FORTH_STACK_GUARD 
988c cd 32 d5				call check_stacks 
988f				endif 
988f e5				push hl 
9890 d5				push de 
9891 eb				ex de,hl 
9892 2a 8a ec			ld hl,(cli_data_sp) 
9895 23				inc hl 
9896 23				inc hl 
9897			 
9897			; PARSEV5 
9897 23				inc hl 
9898 22 8a ec			ld (cli_data_sp),hl 
989b 73				ld (hl), e 
989c 23				inc hl 
989d 72				ld (hl), d 
989e d1				pop de 
989f e1				pop hl 
98a0				if DEBUG_FORTH_STACK_GUARD 
98a0 cd 32 d5				call check_stacks 
98a3				endif 
98a3 c9				ret 
98a4			 
98a4			 
98a4			; increase ret stack pointer and save hl to it 
98a4				 
98a4			FORTH_RSP_NEXT: macro 
98a4				call macro_forth_rsp_next 
98a4				endm 
98a4			 
98a4			macro_forth_rsp_next: 
98a4				if DEBUG_FORTH_STACK_GUARD 
98a4 cd 32 d5				call check_stacks 
98a7				endif 
98a7 e5				push hl 
98a8 d5				push de 
98a9 eb				ex de,hl 
98aa 2a 8e ec			ld hl,(cli_ret_sp) 
98ad 23				inc hl 
98ae 23				inc hl 
98af 22 8e ec			ld (cli_ret_sp),hl 
98b2 73				ld (hl), e 
98b3 23				inc hl 
98b4 72				ld (hl), d 
98b5 d1				pop de 
98b6 e1				pop hl 
98b7				if DEBUG_FORTH_STACK_GUARD 
98b7 cd 32 d5				call check_stacks 
98ba				endif 
98ba c9				ret 
98bb			 
98bb			; get current ret stack pointer and save to hl  
98bb				 
98bb			FORTH_RSP_TOS: macro 
98bb				call macro_forth_rsp_tos 
98bb				endm 
98bb			 
98bb			macro_forth_rsp_tos: 
98bb				;push de 
98bb 2a 8e ec			ld hl,(cli_ret_sp) 
98be cd f6 98			call loadhlptrtohl 
98c1				;ld e, (hl) 
98c1				;inc hl 
98c1				;ld d, (hl) 
98c1				;ex de, hl 
98c1					if DEBUG_FORTH_WORDS 
98c1			;			DMARK "RST" 
98c1						CALLMONITOR 
98c1 cd a3 92			call break_point_state  
98c4				endm  
# End of macro CALLMONITOR
98c4					endif 
98c4				;pop de 
98c4 c9				ret 
98c5			 
98c5			; pop ret stack pointer 
98c5				 
98c5			FORTH_RSP_POP: macro 
98c5				call macro_forth_rsp_pop 
98c5				endm 
98c5			 
98c5			 
98c5			macro_forth_rsp_pop: 
98c5				if DEBUG_FORTH_STACK_GUARD 
98c5			;		DMARK "RPP" 
98c5 cd 32 d5				call check_stacks 
98c8					FORTH_CHK_RSP_UNDER 
98c8 e5				push hl 
98c9 d5				push de 
98ca 2a 8e ec			ld hl,(cli_ret_sp) 
98cd 11 48 ec			ld de, cli_ret_stack 
98d0 cd c0 8a			call cmp16 
98d3 da 46 d6			jp c, fault_rsp_under 
98d6 d1				pop de 
98d7 e1				pop hl 
98d8				endm 
# End of macro FORTH_CHK_RSP_UNDER
98d8				endif 
98d8 e5				push hl 
98d9 2a 8e ec			ld hl,(cli_ret_sp) 
98dc			 
98dc			 
98dc				if FORTH_ENABLE_FREE 
98dc			 
98dc					; get pointer 
98dc			 
98dc					push de 
98dc					push hl 
98dc			 
98dc					ld e, (hl) 
98dc					inc hl 
98dc					ld d, (hl) 
98dc			 
98dc					ex de, hl 
98dc					call free 
98dc			 
98dc					pop hl 
98dc					pop de 
98dc			 
98dc			 
98dc				endif 
98dc			 
98dc			 
98dc 2b				dec hl 
98dd 2b				dec hl 
98de 22 8e ec			ld (cli_ret_sp), hl 
98e1				; do stack underflow checks 
98e1 e1				pop hl 
98e2				if DEBUG_FORTH_STACK_GUARD 
98e2 cd 32 d5				call check_stacks 
98e5					FORTH_CHK_RSP_UNDER 
98e5 e5				push hl 
98e6 d5				push de 
98e7 2a 8e ec			ld hl,(cli_ret_sp) 
98ea 11 48 ec			ld de, cli_ret_stack 
98ed cd c0 8a			call cmp16 
98f0 da 46 d6			jp c, fault_rsp_under 
98f3 d1				pop de 
98f4 e1				pop hl 
98f5				endm 
# End of macro FORTH_CHK_RSP_UNDER
98f5				endif 
98f5 c9				ret 
98f6			 
98f6			 
98f6			 
98f6			; routine to load word pointed to by hl into hl 
98f6			 
98f6			loadhlptrtohl: 
98f6			 
98f6 d5				push de 
98f7 5e				ld e, (hl) 
98f8 23				inc hl 
98f9 56				ld d, (hl) 
98fa eb				ex de, hl 
98fb d1				pop de 
98fc			 
98fc c9				ret 
98fd			 
98fd			 
98fd			 
98fd			 
98fd			 
98fd			; push a number held in HL onto the data stack 
98fd			; entry point for pushing a value when already in hl used in function above 
98fd			 
98fd			forth_push_numhl: 
98fd			 
98fd e5				push hl    ; save value to push 
98fe			 
98fe			if DEBUG_FORTH_PUSH 
98fe				; see if disabled 
98fe			 
98fe			 
98fe f5				push af 
98ff 3a ce e4			ld a, (os_view_disable) 
9902 fe 2a			cp '*' 
9904 28 34			jr z, .pskip2 
9906 e5				push hl 
9907 e5			push hl 
9908 cd 75 88			call clear_display 
990b e1			pop hl 
990c 7c				ld a,h 
990d 21 e2 e7			ld hl, os_word_scratch 
9910 cd a3 8d			call hexout 
9913 e1				pop hl 
9914 7d				ld a,l 
9915 21 e4 e7			ld hl, os_word_scratch+2 
9918 cd a3 8d			call hexout 
991b			 
991b 21 e6 e7			ld hl, os_word_scratch+4 
991e 3e 00			ld a,0 
9920 77				ld (hl),a 
9921 11 e2 e7			ld de,os_word_scratch 
9924 3e 14				ld a, display_row_2 
9926 cd 88 88				call str_at_display 
9929 11 40 c4			ld de, .push_num 
992c 3e 00			ld a, display_row_1 
992e			 
992e cd 88 88				call str_at_display 
9931			 
9931			 
9931 cd 98 88			call update_display 
9934 cd f2 87			call delay1s 
9937 cd f2 87			call delay1s 
993a			.pskip2:  
993a			 
993a f1				pop af 
993b			endif	 
993b			 
993b			 
993b				FORTH_DSP_NEXT 
993b cd 8c 98			call macro_forth_dsp_next 
993e				endm 
# End of macro FORTH_DSP_NEXT
993e			 
993e 2a 8a ec			ld hl, (cli_data_sp) 
9941			 
9941				; save item type 
9941 3e 02			ld a,  DS_TYPE_INUM 
9943 77				ld (hl), a 
9944 23				inc hl 
9945			 
9945				; get word off stack 
9945 d1				pop de 
9946 7b				ld a,e 
9947 77				ld (hl), a 
9948 23				inc hl 
9949 7a				ld a,d 
994a 77				ld (hl), a 
994b			 
994b			if DEBUG_FORTH_PUSH 
994b 2b				dec hl 
994c 2b				dec hl 
994d 2b				dec hl 
994e						DMARK "PH5" 
994e f5				push af  
994f 3a 63 99			ld a, (.dmark)  
9952 32 b7 ee			ld (debug_mark),a  
9955 3a 64 99			ld a, (.dmark+1)  
9958 32 b8 ee			ld (debug_mark+1),a  
995b 3a 65 99			ld a, (.dmark+2)  
995e 32 b9 ee			ld (debug_mark+2),a  
9961 18 03			jr .pastdmark  
9963 ..			.dmark: db "PH5"  
9966 f1			.pastdmark: pop af  
9967			endm  
# End of macro DMARK
9967				CALLMONITOR 
9967 cd a3 92			call break_point_state  
996a				endm  
# End of macro CALLMONITOR
996a			endif	 
996a			 
996a c9				ret 
996b			 
996b			 
996b			; Push a string to stack pointed to by hl 
996b			 
996b			forth_push_str: 
996b			 
996b			if DEBUG_FORTH_PUSH 
996b						DMARK "PSQ" 
996b f5				push af  
996c 3a 80 99			ld a, (.dmark)  
996f 32 b7 ee			ld (debug_mark),a  
9972 3a 81 99			ld a, (.dmark+1)  
9975 32 b8 ee			ld (debug_mark+1),a  
9978 3a 82 99			ld a, (.dmark+2)  
997b 32 b9 ee			ld (debug_mark+2),a  
997e 18 03			jr .pastdmark  
9980 ..			.dmark: db "PSQ"  
9983 f1			.pastdmark: pop af  
9984			endm  
# End of macro DMARK
9984				CALLMONITOR 
9984 cd a3 92			call break_point_state  
9987				endm  
# End of macro CALLMONITOR
9987			endif	 
9987			    
9987 e5				push hl 
9988 e5				push hl 
9989			 
9989			;	ld a, 0   ; find end of string 
9989 cd 00 8f			call strlenz 
998c			if DEBUG_FORTH_PUSH 
998c						DMARK "PQ2" 
998c f5				push af  
998d 3a a1 99			ld a, (.dmark)  
9990 32 b7 ee			ld (debug_mark),a  
9993 3a a2 99			ld a, (.dmark+1)  
9996 32 b8 ee			ld (debug_mark+1),a  
9999 3a a3 99			ld a, (.dmark+2)  
999c 32 b9 ee			ld (debug_mark+2),a  
999f 18 03			jr .pastdmark  
99a1 ..			.dmark: db "PQ2"  
99a4 f1			.pastdmark: pop af  
99a5			endm  
# End of macro DMARK
99a5				CALLMONITOR 
99a5 cd a3 92			call break_point_state  
99a8				endm  
# End of macro CALLMONITOR
99a8			endif	 
99a8 eb				ex de, hl 
99a9 e1				pop hl   ; get ptr to start of string 
99aa			if DEBUG_FORTH_PUSH 
99aa						DMARK "PQ3" 
99aa f5				push af  
99ab 3a bf 99			ld a, (.dmark)  
99ae 32 b7 ee			ld (debug_mark),a  
99b1 3a c0 99			ld a, (.dmark+1)  
99b4 32 b8 ee			ld (debug_mark+1),a  
99b7 3a c1 99			ld a, (.dmark+2)  
99ba 32 b9 ee			ld (debug_mark+2),a  
99bd 18 03			jr .pastdmark  
99bf ..			.dmark: db "PQ3"  
99c2 f1			.pastdmark: pop af  
99c3			endm  
# End of macro DMARK
99c3				CALLMONITOR 
99c3 cd a3 92			call break_point_state  
99c6				endm  
# End of macro CALLMONITOR
99c6			endif	 
99c6 19				add hl,de 
99c7			if DEBUG_FORTH_PUSH 
99c7						DMARK "PQE" 
99c7 f5				push af  
99c8 3a dc 99			ld a, (.dmark)  
99cb 32 b7 ee			ld (debug_mark),a  
99ce 3a dd 99			ld a, (.dmark+1)  
99d1 32 b8 ee			ld (debug_mark+1),a  
99d4 3a de 99			ld a, (.dmark+2)  
99d7 32 b9 ee			ld (debug_mark+2),a  
99da 18 03			jr .pastdmark  
99dc ..			.dmark: db "PQE"  
99df f1			.pastdmark: pop af  
99e0			endm  
# End of macro DMARK
99e0				CALLMONITOR 
99e0 cd a3 92			call break_point_state  
99e3				endm  
# End of macro CALLMONITOR
99e3			endif	 
99e3			 
99e3 2b				dec hl    ; see if there is an optional trailing double quote 
99e4 7e				ld a,(hl) 
99e5 fe 22			cp '"' 
99e7 20 03			jr nz, .strnoq 
99e9 3e 00			ld a, 0      ; get rid of double quote 
99eb 77				ld (hl), a 
99ec 23			.strnoq: inc hl 
99ed			 
99ed 3e 00			ld a, 0 
99ef 77				ld (hl), a     ; add null term and get rid of trailing double quote 
99f0			 
99f0 13				inc de ; add one for the type string 
99f1 13				inc de ; add one for null term??? 
99f2			 
99f2				; tos is get string pointer again 
99f2				; de contains space to allocate 
99f2				 
99f2 d5				push de 
99f3			 
99f3 eb				ex de, hl 
99f4			 
99f4				;push af 
99f4			 
99f4			if DEBUG_FORTH_PUSH 
99f4						DMARK "PHm" 
99f4 f5				push af  
99f5 3a 09 9a			ld a, (.dmark)  
99f8 32 b7 ee			ld (debug_mark),a  
99fb 3a 0a 9a			ld a, (.dmark+1)  
99fe 32 b8 ee			ld (debug_mark+1),a  
9a01 3a 0b 9a			ld a, (.dmark+2)  
9a04 32 b9 ee			ld (debug_mark+2),a  
9a07 18 03			jr .pastdmark  
9a09 ..			.dmark: db "PHm"  
9a0c f1			.pastdmark: pop af  
9a0d			endm  
# End of macro DMARK
9a0d				CALLMONITOR 
9a0d cd a3 92			call break_point_state  
9a10				endm  
# End of macro CALLMONITOR
9a10			endif	 
9a10 cd 69 8f			call malloc	; on ret hl now contains allocated memory 
9a13				if DEBUG_FORTH_MALLOC_GUARD 
9a13 cc 98 c4				call z,malloc_error 
9a16				endif 
9a16			 
9a16				 
9a16 c1				pop bc    ; get length 
9a17 d1				pop de   ;  get string start    
9a18			 
9a18				; hl has destination from malloc 
9a18			 
9a18 eb				ex de, hl    ; prep for ldir 
9a19			 
9a19 d5				push de   ; save malloc area for DSP later 
9a1a				;push hl   ; save malloc area for DSP later 
9a1a			 
9a1a			if DEBUG_FORTH_PUSH 
9a1a						DMARK "PHc" 
9a1a f5				push af  
9a1b 3a 2f 9a			ld a, (.dmark)  
9a1e 32 b7 ee			ld (debug_mark),a  
9a21 3a 30 9a			ld a, (.dmark+1)  
9a24 32 b8 ee			ld (debug_mark+1),a  
9a27 3a 31 9a			ld a, (.dmark+2)  
9a2a 32 b9 ee			ld (debug_mark+2),a  
9a2d 18 03			jr .pastdmark  
9a2f ..			.dmark: db "PHc"  
9a32 f1			.pastdmark: pop af  
9a33			endm  
# End of macro DMARK
9a33				CALLMONITOR 
9a33 cd a3 92			call break_point_state  
9a36				endm  
# End of macro CALLMONITOR
9a36			endif	 
9a36			 
9a36			 
9a36 ed b0			ldir 
9a38			 
9a38			 
9a38				; push malloc to data stack     macro?????  
9a38			 
9a38				FORTH_DSP_NEXT 
9a38 cd 8c 98			call macro_forth_dsp_next 
9a3b				endm 
# End of macro FORTH_DSP_NEXT
9a3b			 
9a3b				; save value and type 
9a3b			 
9a3b 2a 8a ec			ld hl, (cli_data_sp) 
9a3e			 
9a3e				; save item type 
9a3e 3e 01			ld a,  DS_TYPE_STR 
9a40 77				ld (hl), a 
9a41 23				inc hl 
9a42			 
9a42				; get malloc word off stack 
9a42 d1				pop de 
9a43 73				ld (hl), e 
9a44 23				inc hl 
9a45 72				ld (hl), d 
9a46			 
9a46			 
9a46			 
9a46			if DEBUG_FORTH_PUSH 
9a46 2a 8a ec			ld hl, (cli_data_sp) 
9a49						DMARK "PHS" 
9a49 f5				push af  
9a4a 3a 5e 9a			ld a, (.dmark)  
9a4d 32 b7 ee			ld (debug_mark),a  
9a50 3a 5f 9a			ld a, (.dmark+1)  
9a53 32 b8 ee			ld (debug_mark+1),a  
9a56 3a 60 9a			ld a, (.dmark+2)  
9a59 32 b9 ee			ld (debug_mark+2),a  
9a5c 18 03			jr .pastdmark  
9a5e ..			.dmark: db "PHS"  
9a61 f1			.pastdmark: pop af  
9a62			endm  
# End of macro DMARK
9a62				CALLMONITOR 
9a62 cd a3 92			call break_point_state  
9a65				endm  
# End of macro CALLMONITOR
9a65			;	ex de,hl 
9a65			endif	 
9a65				; in case of spaces, skip the ptr past the copied string 
9a65				;pop af 
9a65				;ld (cli_origptr),hl 
9a65			 
9a65 c9				ret 
9a66			 
9a66			 
9a66			 
9a66			; TODO ascii push input onto stack given hl to start of input 
9a66			 
9a66			; identify type 
9a66			; if starts with a " then a string 
9a66			; otherwise it is a number 
9a66			;  
9a66			; if a string 
9a66			;     scan for ending " to get length of string to malloc for + 1 
9a66			;     malloc 
9a66			;     put pointer to string on stack first byte flags as string 
9a66			; 
9a66			; else a number 
9a66			;    look for number format identifier 
9a66			;    $xx hex 
9a66			;    %xxxxx bin 
9a66			;    xxxxx decimal 
9a66			;    convert number to 16bit word.  
9a66			;    malloc word + 1 with flag to identiy as num 
9a66			;    put pointer to number on stack 
9a66			;   
9a66			;  
9a66			  
9a66			forth_apush: 
9a66				; kernel push 
9a66			 
9a66			if DEBUG_FORTH_PUSH 
9a66						DMARK "PSH" 
9a66 f5				push af  
9a67 3a 7b 9a			ld a, (.dmark)  
9a6a 32 b7 ee			ld (debug_mark),a  
9a6d 3a 7c 9a			ld a, (.dmark+1)  
9a70 32 b8 ee			ld (debug_mark+1),a  
9a73 3a 7d 9a			ld a, (.dmark+2)  
9a76 32 b9 ee			ld (debug_mark+2),a  
9a79 18 03			jr .pastdmark  
9a7b ..			.dmark: db "PSH"  
9a7e f1			.pastdmark: pop af  
9a7f			endm  
# End of macro DMARK
9a7f				CALLMONITOR 
9a7f cd a3 92			call break_point_state  
9a82				endm  
# End of macro CALLMONITOR
9a82			endif	 
9a82				; identify input type 
9a82			 
9a82 7e				ld a,(hl) 
9a83 fe 22			cp '"' 
9a85 28 0a			jr z, .fapstr 
9a87 fe 24			cp '$' 
9a89 ca b1 9a			jp z, .faphex 
9a8c fe 25			cp '%' 
9a8e ca 99 9a			jp z, .fapbin 
9a91			;	cp 'b' 
9a91			;	jp z, .fabin 
9a91				; else decimal 
9a91			 
9a91				; TODO do decimal conversion 
9a91				; decimal is stored as a 16bit word 
9a91			 
9a91				; by default everything is a string if type is not detected 
9a91			.fapstr: ; 
9a91 fe 22			cp '"' 
9a93 20 01			jr nz, .strnoqu 
9a95 23				inc hl 
9a96			.strnoqu: 
9a96 c3 6b 99			jp forth_push_str 
9a99			 
9a99			 
9a99			 
9a99			.fapbin:    ; push a binary string.  
9a99 11 00 00			ld de, 0   ; hold a 16bit value 
9a9c			 
9a9c 23			.fapbinshift:	inc hl  
9a9d 7e				ld a,(hl) 
9a9e fe 00			cp 0     ; done scanning  
9aa0 28 0b			jr z, .fapbdone  	; got it in HL so push  
9aa2			 
9aa2				; left shift de 
9aa2 eb				ex de, hl	 
9aa3 29				add hl, hl 
9aa4			 
9aa4				; is 1 
9aa4 fe 31			cp '1' 
9aa6 20 02			jr nz, .binzero 
9aa8 cb 4d			bit 1, l 
9aaa			.binzero: 
9aaa eb				ex de, hl	 ; save current de 
9aab 18 ef			jr .fapbinshift 
9aad			 
9aad			.fapbdone: 
9aad eb				ex de, hl 
9aae c3 fd 98			jp forth_push_numhl 
9ab1			 
9ab1			 
9ab1			.faphex:   ; hex is always stored as a 16bit word 
9ab1				; skip number prefix 
9ab1 23				inc hl 
9ab2				; turn ascii into number 
9ab2 cd 59 8e			call get_word_hl	; ret 16bit word in hl 
9ab5			 
9ab5 c3 fd 98			jp forth_push_numhl 
9ab8			 
9ab8 00				 nop 
9ab9			 
9ab9			.fabin:   ; TODO bin conversion 
9ab9			 
9ab9			 
9ab9 c9				ret 
9aba			 
9aba			 
9aba			; get either a string ptr or a 16bit word from the data stack 
9aba			 
9aba			FORTH_DSP: macro 
9aba				call macro_forth_dsp 
9aba				endm 
9aba			 
9aba			macro_forth_dsp: 
9aba				; data stack pointer points to current word on tos 
9aba			 
9aba 2a 8a ec			ld hl,(cli_data_sp) 
9abd			 
9abd				if DEBUG_FORTH_PUSH 
9abd						DMARK "DSP" 
9abd f5				push af  
9abe 3a d2 9a			ld a, (.dmark)  
9ac1 32 b7 ee			ld (debug_mark),a  
9ac4 3a d3 9a			ld a, (.dmark+1)  
9ac7 32 b8 ee			ld (debug_mark+1),a  
9aca 3a d4 9a			ld a, (.dmark+2)  
9acd 32 b9 ee			ld (debug_mark+2),a  
9ad0 18 03			jr .pastdmark  
9ad2 ..			.dmark: db "DSP"  
9ad5 f1			.pastdmark: pop af  
9ad6			endm  
# End of macro DMARK
9ad6			 
9ad6 cd cd c4				call display_data_sp 
9ad9				;call break_point_state 
9ad9				;rst 030h 
9ad9				CALLMONITOR 
9ad9 cd a3 92			call break_point_state  
9adc				endm  
# End of macro CALLMONITOR
9adc				endif 
9adc			 
9adc c9				ret 
9add			 
9add			; return hl to start of value on stack 
9add			 
9add			FORTH_DSP_VALUE: macro 
9add				call macro_forth_dsp_value 
9add				endm 
9add			 
9add			macro_forth_dsp_value: 
9add			 
9add				FORTH_DSP 
9add cd ba 9a			call macro_forth_dsp 
9ae0				endm 
# End of macro FORTH_DSP
9ae0			 
9ae0 d5				push de 
9ae1			 
9ae1 23				inc hl ; skip type 
9ae2			 
9ae2 5e				ld e, (hl) 
9ae3 23				inc hl 
9ae4 56				ld d, (hl) 
9ae5 eb				ex de,hl  
9ae6			 
9ae6 d1				pop de 
9ae7			 
9ae7 c9				ret 
9ae8			 
9ae8			; return hl to start of value to second item on stack 
9ae8			 
9ae8			FORTH_DSP_VALUEM1: macro 
9ae8				call macro_forth_dsp_value_m1 
9ae8				endm 
9ae8			 
9ae8			macro_forth_dsp_value_m1: 
9ae8			 
9ae8				FORTH_DSP 
9ae8 cd ba 9a			call macro_forth_dsp 
9aeb				endm 
# End of macro FORTH_DSP
9aeb			 
9aeb 2b				dec hl 
9aec 2b				dec hl 
9aed			;	dec hl 
9aed			 
9aed d5				push de 
9aee			 
9aee 5e				ld e, (hl) 
9aef 23				inc hl 
9af0 56				ld d, (hl) 
9af1 eb				ex de,hl  
9af2			 
9af2 d1				pop de 
9af3			 
9af3 c9				ret 
9af4			 
9af4				 
9af4			 
9af4			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9af4			 
9af4			FORTH_DSP_POP: macro 
9af4				call macro_forth_dsp_pop 
9af4				endm 
9af4			 
9af4			 
9af4			; get the tos data type 
9af4			 
9af4			FORTH_DSP_TYPE:   macro 
9af4			 
9af4				;FORTH_DSP_VALUE 
9af4				FORTH_DSP 
9af4				 
9af4				; hl points to value 
9af4				; check type 
9af4			 
9af4				ld a,(hl) 
9af4			 
9af4				endm 
9af4			 
9af4			; load the tos value into hl 
9af4			 
9af4			 
9af4			FORTH_DSP_VALUEHL:  macro 
9af4				call macro_dsp_valuehl 
9af4				endm 
9af4			 
9af4			 
9af4			 
9af4			macro_dsp_valuehl: 
9af4				FORTH_DSP_VALUE 
9af4 cd dd 9a			call macro_forth_dsp_value 
9af7				endm 
# End of macro FORTH_DSP_VALUE
9af7			 
9af7				;FORTH_ERR_TOS_NOTNUM 
9af7			 
9af7				;inc hl   ; skip type id 
9af7			 
9af7			;	push de 
9af7			; 
9af7			;	ld e, (hl) 
9af7			;	inc hl 
9af7			;	ld d, (hl) 
9af7			;	ex de,hl  
9af7			 
9af7			;	pop de 
9af7			 
9af7				if DEBUG_FORTH_PUSH 
9af7						DMARK "DVL" 
9af7 f5				push af  
9af8 3a 0c 9b			ld a, (.dmark)  
9afb 32 b7 ee			ld (debug_mark),a  
9afe 3a 0d 9b			ld a, (.dmark+1)  
9b01 32 b8 ee			ld (debug_mark+1),a  
9b04 3a 0e 9b			ld a, (.dmark+2)  
9b07 32 b9 ee			ld (debug_mark+2),a  
9b0a 18 03			jr .pastdmark  
9b0c ..			.dmark: db "DVL"  
9b0f f1			.pastdmark: pop af  
9b10			endm  
# End of macro DMARK
9b10				CALLMONITOR 
9b10 cd a3 92			call break_point_state  
9b13				endm  
# End of macro CALLMONITOR
9b13				endif 
9b13 c9				ret 
9b14			 
9b14			forth_apushstrhl:      
9b14				; push of string requires use of cli_origptr 
9b14				; bodge use 
9b14			 
9b14				; get current cli_origptr, save, update with temp pointer  
9b14 ed 5b a6 ec		ld de, (cli_origptr) 
9b18 22 a6 ec			ld (cli_origptr), hl 
9b1b d5				push de 
9b1c cd 66 9a			call forth_apush 
9b1f d1				pop de 
9b20 ed 53 a6 ec		ld (cli_origptr), de 
9b24 c9			        ret	 
9b25			 
9b25			 
9b25			; increase loop stack pointer and save hl to it 
9b25				 
9b25			FORTH_LOOP_NEXT: macro 
9b25				call macro_forth_loop_next 
9b25				;nop 
9b25				endm 
9b25			 
9b25			macro_forth_loop_next: 
9b25				if DEBUG_FORTH_STACK_GUARD 
9b25 cd 32 d5				call check_stacks 
9b28				endif 
9b28 e5				push hl 
9b29 d5				push de 
9b2a eb				ex de,hl 
9b2b 2a 8c ec			ld hl,(cli_loop_sp) 
9b2e 23				inc hl 
9b2f 23				inc hl 
9b30					if DEBUG_FORTH_WORDS 
9b30						DMARK "LNX" 
9b30 f5				push af  
9b31 3a 45 9b			ld a, (.dmark)  
9b34 32 b7 ee			ld (debug_mark),a  
9b37 3a 46 9b			ld a, (.dmark+1)  
9b3a 32 b8 ee			ld (debug_mark+1),a  
9b3d 3a 47 9b			ld a, (.dmark+2)  
9b40 32 b9 ee			ld (debug_mark+2),a  
9b43 18 03			jr .pastdmark  
9b45 ..			.dmark: db "LNX"  
9b48 f1			.pastdmark: pop af  
9b49			endm  
# End of macro DMARK
9b49						CALLMONITOR 
9b49 cd a3 92			call break_point_state  
9b4c				endm  
# End of macro CALLMONITOR
9b4c					endif 
9b4c 22 8c ec			ld (cli_loop_sp),hl 
9b4f 73				ld (hl), e 
9b50 23				inc hl 
9b51 72				ld (hl), d 
9b52 d1				pop de    ; been reversed so save a swap on restore 
9b53 e1				pop hl 
9b54				if DEBUG_FORTH_STACK_GUARD 
9b54 cd 32 d5				call check_stacks 
9b57				endif 
9b57 c9				ret 
9b58			 
9b58			; get current ret stack pointer and save to hl  
9b58				 
9b58			FORTH_LOOP_TOS: macro 
9b58				call macro_forth_loop_tos 
9b58				endm 
9b58			 
9b58			macro_forth_loop_tos: 
9b58 d5				push de 
9b59 2a 8c ec			ld hl,(cli_loop_sp) 
9b5c 5e				ld e, (hl) 
9b5d 23				inc hl 
9b5e 56				ld d, (hl) 
9b5f eb				ex de, hl 
9b60 d1				pop de 
9b61 c9				ret 
9b62			 
9b62			; pop loop stack pointer 
9b62				 
9b62			FORTH_LOOP_POP: macro 
9b62				call macro_forth_loop_pop 
9b62				endm 
9b62			 
9b62			 
9b62			macro_forth_loop_pop: 
9b62				if DEBUG_FORTH_STACK_GUARD 
9b62					DMARK "LPP" 
9b62 f5				push af  
9b63 3a 77 9b			ld a, (.dmark)  
9b66 32 b7 ee			ld (debug_mark),a  
9b69 3a 78 9b			ld a, (.dmark+1)  
9b6c 32 b8 ee			ld (debug_mark+1),a  
9b6f 3a 79 9b			ld a, (.dmark+2)  
9b72 32 b9 ee			ld (debug_mark+2),a  
9b75 18 03			jr .pastdmark  
9b77 ..			.dmark: db "LPP"  
9b7a f1			.pastdmark: pop af  
9b7b			endm  
# End of macro DMARK
9b7b cd 32 d5				call check_stacks 
9b7e					FORTH_CHK_LOOP_UNDER 
9b7e e5				push hl 
9b7f d5				push de 
9b80 2a 8c ec			ld hl,(cli_loop_sp) 
9b83 11 46 eb			ld de, cli_loop_stack 
9b86 cd c0 8a			call cmp16 
9b89 da 4c d6			jp c, fault_loop_under 
9b8c d1				pop de 
9b8d e1				pop hl 
9b8e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b8e				endif 
9b8e e5				push hl 
9b8f 2a 8c ec			ld hl,(cli_loop_sp) 
9b92 2b				dec hl 
9b93 2b				dec hl 
9b94 22 8c ec			ld (cli_loop_sp), hl 
9b97				; TODO do stack underflow checks 
9b97 e1				pop hl 
9b98				if DEBUG_FORTH_STACK_GUARD 
9b98 cd 32 d5				call check_stacks 
9b9b					FORTH_CHK_LOOP_UNDER 
9b9b e5				push hl 
9b9c d5				push de 
9b9d 2a 8c ec			ld hl,(cli_loop_sp) 
9ba0 11 46 eb			ld de, cli_loop_stack 
9ba3 cd c0 8a			call cmp16 
9ba6 da 4c d6			jp c, fault_loop_under 
9ba9 d1				pop de 
9baa e1				pop hl 
9bab				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9bab				endif 
9bab c9				ret 
9bac			 
9bac			macro_forth_dsp_pop: 
9bac			 
9bac e5				push hl 
9bad			 
9bad				; release malloc data 
9bad			 
9bad				if DEBUG_FORTH_STACK_GUARD 
9bad cd 32 d5				call check_stacks 
9bb0					FORTH_CHK_DSP_UNDER 
9bb0 e5				push hl 
9bb1 d5				push de 
9bb2 2a 8a ec			ld hl,(cli_data_sp) 
9bb5 11 44 ea			ld de, cli_data_stack 
9bb8 cd c0 8a			call cmp16 
9bbb da 40 d6			jp c, fault_dsp_under 
9bbe d1				pop de 
9bbf e1				pop hl 
9bc0				endm 
# End of macro FORTH_CHK_DSP_UNDER
9bc0				endif 
9bc0				;ld hl,(cli_data_sp) 
9bc0			if DEBUG_FORTH_DOT 
9bc0				DMARK "DPP" 
9bc0				CALLMONITOR 
9bc0			endif	 
9bc0			 
9bc0			 
9bc0			if FORTH_ENABLE_DSPPOPFREE 
9bc0			 
9bc0				FORTH_DSP 
9bc0 cd ba 9a			call macro_forth_dsp 
9bc3				endm 
# End of macro FORTH_DSP
9bc3			 
9bc3 7e				ld a, (hl) 
9bc4 fe 01			cp DS_TYPE_STR 
9bc6 20 07			jr nz, .skippopfree 
9bc8			 
9bc8				FORTH_DSP_VALUEHL 
9bc8 cd f4 9a			call macro_dsp_valuehl 
9bcb				endm 
# End of macro FORTH_DSP_VALUEHL
9bcb 00				nop 
9bcc			if DEBUG_FORTH_DOT 
9bcc				DMARK "DPf" 
9bcc				CALLMONITOR 
9bcc			endif	 
9bcc cd 33 90			call free 
9bcf			.skippopfree: 
9bcf				 
9bcf			 
9bcf			endif 
9bcf			 
9bcf			if DEBUG_FORTH_DOT_KEY 
9bcf				DMARK "DP2" 
9bcf				CALLMONITOR 
9bcf			endif	 
9bcf			 
9bcf				; move pointer down 
9bcf			 
9bcf 2a 8a ec			ld hl,(cli_data_sp) 
9bd2 2b				dec hl 
9bd3 2b				dec hl 
9bd4			; PARSEV5 
9bd4 2b				dec hl 
9bd5 22 8a ec			ld (cli_data_sp), hl 
9bd8			 
9bd8				if DEBUG_FORTH_STACK_GUARD 
9bd8 cd 32 d5				call check_stacks 
9bdb					FORTH_CHK_DSP_UNDER 
9bdb e5				push hl 
9bdc d5				push de 
9bdd 2a 8a ec			ld hl,(cli_data_sp) 
9be0 11 44 ea			ld de, cli_data_stack 
9be3 cd c0 8a			call cmp16 
9be6 da 40 d6			jp c, fault_dsp_under 
9be9 d1				pop de 
9bea e1				pop hl 
9beb				endm 
# End of macro FORTH_CHK_DSP_UNDER
9beb				endif 
9beb			 
9beb e1				pop hl 
9bec			 
9bec c9				ret 
9bed			 
9bed			getwordathl: 
9bed				; hl points to an address 
9bed				; load hl with the word at that address 
9bed			 
9bed d5				push de 
9bee			 
9bee 5e				ld e, (hl) 
9bef 23				inc hl 
9bf0 56				ld d, (hl) 
9bf1 eb				ex de, hl 
9bf2			 
9bf2 d1				pop de 
9bf3 c9				ret 
9bf4			 
9bf4			 
9bf4			 
9bf4			 
9bf4			 
9bf4			; eof 
9bf4			 
# End of file forth_stackopsv5.asm
9bf4			endif 
9bf4			 
9bf4			user_word_eol:  
9bf4				; hl contains the pointer to where to create a linked list item from the end 
9bf4				; of the user dict to continue on at the system word dict 
9bf4				 
9bf4				; poke the stub of the word list linked list to repoint to rom words 
9bf4			 
9bf4				; stub format 
9bf4				; db   word id 
9bf4				; dw    link to next word 
9bf4			        ; db char length of token 
9bf4				; db string + 0 term 
9bf4				; db exec code....  
9bf4			 
9bf4 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9bf6 77				ld (hl), a		; word id 
9bf7 23				inc hl 
9bf8			 
9bf8 11 be 9d			ld de, sysdict 
9bfb 73				ld (hl), e		; next word link ie system dict 
9bfc 23				inc hl 
9bfd 72				ld (hl), d		; next word link ie system dict 
9bfe 23				inc hl	 
9bff			 
9bff			;	ld (hl), sysdict		; next word link ie system dict 
9bff			;	inc hl 
9bff			;	inc hl 
9bff			 
9bff			;	inc hl 
9bff			;	inc hl 
9bff			 
9bff 3e 02			ld a, 2			; word length is 0 
9c01 77				ld (hl), a	 
9c02 23				inc hl 
9c03			 
9c03 3e 7e			ld a, '~'			; word length is 0 
9c05 77				ld (hl), a	 
9c06 23				inc hl 
9c07 3e 00			ld a, 0			; save empty word 
9c09 77				ld (hl), a 
9c0a			 
9c0a c9				ret 
9c0b			 
9c0b				 
9c0b			 
9c0b			forthexec_cleanup: 
9c0b				FORTH_RSP_POP 
9c0b cd c5 98			call macro_forth_rsp_pop 
9c0e				endm 
# End of macro FORTH_RSP_POP
9c0e c9				ret 
9c0f			 
9c0f			forth_call_hl: 
9c0f				; taking hl 
9c0f e5				push hl 
9c10 c9				ret 
9c11			 
9c11			; this is called to reset Forth system but keep existing uwords etc 
9c11			 
9c11			forth_warmstart: 
9c11				; setup stack over/under flow checks 
9c11				if DEBUG_FORTH_STACK_GUARD 
9c11 cd 18 d5				call chk_stk_init 
9c14				endif 
9c14			 
9c14				; init stack pointers  - * these stacks go upwards *  
9c14 21 48 ec			ld hl, cli_ret_stack 
9c17 22 8e ec			ld (cli_ret_sp), hl	 
9c1a				; set bottom of stack 
9c1a 3e 00			ld a,0 
9c1c 77				ld (hl),a 
9c1d 23				inc hl 
9c1e 77				ld (hl),a 
9c1f			 
9c1f 21 44 ea			ld hl, cli_data_stack 
9c22 22 8a ec			ld (cli_data_sp), hl	 
9c25				; set bottom of stack 
9c25 3e 00			ld a,0 
9c27 77				ld (hl),a 
9c28 23				inc hl 
9c29 77				ld (hl),a 
9c2a			 
9c2a 21 46 eb			ld hl, cli_loop_stack 
9c2d 22 8c ec			ld (cli_loop_sp), hl	 
9c30				; set bottom of stack 
9c30 3e 00			ld a,0 
9c32 77				ld (hl),a 
9c33 23				inc hl 
9c34 77				ld (hl),a 
9c35			 
9c35				; init extent of current open file 
9c35			 
9c35 3e 00			ld a, 0 
9c37 32 d9 ec			ld (store_openext), a 
9c3a			 
9c3a c9				ret 
9c3b			 
9c3b			 
9c3b			; Cold Start - this is called to setup the whole Forth system 
9c3b			 
9c3b			forth_init: 
9c3b			 
9c3b				; setup stack over/under flow checks 
9c3b			 
9c3b			;	if DEBUG_FORTH_STACK_GUARD 
9c3b			;		call chk_stk_init 
9c3b			;	endif 
9c3b			 
9c3b				; enable auto display updates (slow.....) 
9c3b			 
9c3b 3e 01			ld a, 1 
9c3d 32 a4 ec			ld (cli_autodisplay), a 
9c40			 
9c40			 
9c40			 
9c40				; show start up screen 
9c40			 
9c40 cd 75 88			call clear_display 
9c43			 
9c43 3e 00			ld a,0 
9c45 32 c6 ec			ld (f_cursor_ptr), a 
9c48			 
9c48				; set start of word list in start of ram - for use when creating user words 
9c48			 
9c48 21 e3 d7			ld hl, baseram 
9c4b 22 da e7			ld (os_last_new_uword), hl 
9c4e cd f4 9b			call user_word_eol 
9c51				 
9c51			;		call display_data_sp 
9c51			;		call next_page_prompt 
9c51			 
9c51			 
9c51			 
9c51			 
9c51 c9				ret 
9c52			 
9c52 .. 00		.bootforth: db " Forth Kernel Init ",0 
9c66			 
9c66			; TODO push to stack 
9c66			 
9c66			;  
9c66			 
9c66			if FORTH_PARSEV2 
9c66			 
9c66			 
9c66				include "forth_parserv2.asm" 
9c66			 
9c66			endif 
9c66			 
9c66			 
9c66			; parse cli version 1 
9c66			 
9c66			if FORTH_PARSEV1 
9c66			 
9c66			 
9c66			 
9c66			      include "forth_parserv1.asm" 
9c66			endif 
9c66				 
9c66			if FORTH_PARSEV3 
9c66			 
9c66			 
9c66			 
9c66			      include "forth_parserv3.asm" 
9c66				include "forth_wordsv3.asm" 
9c66			endif 
9c66			 
9c66			if FORTH_PARSEV4 
9c66			 
9c66			 
9c66			 
9c66			      include "forth_parserv4.asm" 
9c66				include "forth_wordsv4.asm" 
9c66			endif 
9c66			 
9c66			if FORTH_PARSEV5 
9c66			 
9c66			 
9c66			 
9c66			      include "forth_parserv5.asm" 
9c66			 
9c66			 
9c66			; A better parser without using malloc and string copies all over the place.  
9c66			; Exec in situ should be faster 
9c66			 
9c66			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9c66			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9c66			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9c66			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9c66			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9c66			WORD_SYS_END: equ 0   ; Opcode for all user words 
9c66			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9c66			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9c66			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9c66			 
9c66			; Core word preamble macro 
9c66			 
9c66			CWHEAD:   macro nxtword opcode lit len opflags 
9c66				db WORD_SYS_CORE+opcode             
9c66				; internal op code number 
9c66				dw nxtword            
9c66				; link to next dict word block 
9c66				db len + 1 
9c66				; literal length of dict word inc zero term 
9c66				db lit,0              
9c66				; literal dict word 
9c66			        ; TODO db opflags        
9c66				endm 
9c66			 
9c66			 
9c66			NEXTW: macro  
9c66				jp macro_next 
9c66				endm 
9c66			 
9c66			macro_next: 
9c66			if DEBUG_FORTH_PARSE_KEY 
9c66				DMARK "NXT" 
9c66				CALLMONITOR 
9c66			endif	 
9c66			;	inc hl  ; skip token null term  
9c66 ed 4b a8 ec		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c6a ed 5b a6 ec		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c6e 2a de e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c71			if DEBUG_FORTH_PARSE_KEY 
9c71				DMARK "}AA" 
9c71				CALLMONITOR 
9c71			endif	 
9c71 c3 74 9d			jp execnext 
9c74				;jp exec1 
9c74			       
9c74			 
9c74			 
9c74			; Another go at the parser to compile  
9c74			 
9c74			 
9c74			; TODO rework parser to change all of the string words to byte tokens 
9c74			; TODO do a search for  
9c74			 
9c74			; TODO first run normal parser to zero term sections 
9c74			; TODO for each word do a token look up to get the op code 
9c74			; TODO need some means to flag to the exec that this is a byte code form    
9c74			 
9c74			 
9c74			forthcompile: 
9c74			 
9c74			; 
9c74			; line parse: 
9c74			;       parse raw input buffer 
9c74			;       tokenise the words 
9c74			;       malloc new copy (for looping etc) 
9c74			;       copy to malloc + current pc in line to start of string and add line term 
9c74			;       save on new rsp 
9c74			; 
9c74			 
9c74			; hl to point to the line to tokenise 
9c74			 
9c74			;	push hl 
9c74 22 de e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c77			 
9c77			;	ld a,0		; string term on input 
9c77			;	call strlent 
9c77			 
9c77			;	ld (os_tok_len), hl	 ; save string length 
9c77			 
9c77			;if DEBUG_FORTH_TOK 
9c77			;	ex de,hl		 
9c77			;endif 
9c77			 
9c77			;	pop hl 		; get back string pointer 
9c77			 
9c77			if DEBUG_FORTH_TOK 
9c77						DMARK "TOc" 
9c77				CALLMONITOR 
9c77			endif 
9c77 7e			.cptoken2:    ld a,(hl) 
9c78 23				inc hl 
9c79 fe 7f			cp FORTH_END_BUFFER 
9c7b 28 29			jr z, .cptokendone2 
9c7d fe 00			cp 0 
9c7f 28 25			jr z, .cptokendone2 
9c81 fe 22			cp '"' 
9c83 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c85 fe 20			cp ' ' 
9c87 20 ee			jr nz,  .cptoken2 
9c89			 
9c89			; TODO consume comments held between ( and ) 
9c89			 
9c89				; we have a space so change to zero term for dict match later 
9c89 2b				dec hl 
9c8a 3e 00			ld a,0 
9c8c 77				ld (hl), a 
9c8d 23				inc hl 
9c8e 18 e7			jr .cptoken2 
9c90				 
9c90			 
9c90			.cptokenstr2: 
9c90				; skip all white space until either eol (because forgot to term) or end double quote 
9c90			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c90				;inc hl ; skip current double quote 
9c90 7e				ld a,(hl) 
9c91 23				inc hl 
9c92 fe 22			cp '"' 
9c94 28 e1			jr z, .cptoken2 
9c96 fe 7f			cp FORTH_END_BUFFER 
9c98 28 0c			jr z, .cptokendone2 
9c9a fe 00			cp 0 
9c9c 28 08			jr z, .cptokendone2 
9c9e fe 20			cp ' ' 
9ca0 28 02			jr z, .cptmp2 
9ca2 18 ec			jr .cptokenstr2 
9ca4			 
9ca4			.cptmp2:	; we have a space so change to zero term for dict match later 
9ca4				;dec hl 
9ca4				;ld a,"-"	; TODO remove this when working 
9ca4				;ld (hl), a 
9ca4				;inc hl 
9ca4 18 ea			jr .cptokenstr2 
9ca6			 
9ca6			.cptokendone2: 
9ca6				;inc hl 
9ca6 3e 7f			ld a, FORTH_END_BUFFER 
9ca8 77				ld (hl),a 
9ca9 23				inc hl 
9caa 3e 21			ld a, '!' 
9cac 77				ld (hl),a 
9cad			 
9cad 2a de e7			ld hl,(os_tok_ptr) 
9cb0			         
9cb0			if DEBUG_FORTH_TOK 
9cb0						DMARK "Tc1" 
9cb0				CALLMONITOR 
9cb0			endif 
9cb0			 
9cb0				; push exec string to top of return stack 
9cb0				FORTH_RSP_NEXT 
9cb0 cd a4 98			call macro_forth_rsp_next 
9cb3				endm 
# End of macro FORTH_RSP_NEXT
9cb3 c9				ret 
9cb4			 
9cb4			; Another go at the parser need to simplify the process 
9cb4			 
9cb4			forthparse: 
9cb4			 
9cb4			; 
9cb4			; line parse: 
9cb4			;       parse raw input buffer 
9cb4			;       tokenise the words 
9cb4			;       malloc new copy (for looping etc) 
9cb4			;       copy to malloc + current pc in line to start of string and add line term 
9cb4			;       save on new rsp 
9cb4			; 
9cb4			 
9cb4			; hl to point to the line to tokenise 
9cb4			 
9cb4			;	push hl 
9cb4 22 de e7			ld (os_tok_ptr), hl  ; save ptr to string 
9cb7			 
9cb7			;	ld a,0		; string term on input 
9cb7			;	call strlent 
9cb7			 
9cb7			;	ld (os_tok_len), hl	 ; save string length 
9cb7			 
9cb7			;if DEBUG_FORTH_TOK 
9cb7			;	ex de,hl		 
9cb7			;endif 
9cb7			 
9cb7			;	pop hl 		; get back string pointer 
9cb7			 
9cb7			if DEBUG_FORTH_TOK 
9cb7						DMARK "TOK" 
9cb7				CALLMONITOR 
9cb7			endif 
9cb7 7e			.ptoken2:    ld a,(hl) 
9cb8 23				inc hl 
9cb9 fe 7f			cp FORTH_END_BUFFER 
9cbb 28 29			jr z, .ptokendone2 
9cbd fe 00			cp 0 
9cbf 28 25			jr z, .ptokendone2 
9cc1 fe 22			cp '"' 
9cc3 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9cc5 fe 20			cp ' ' 
9cc7 20 ee			jr nz,  .ptoken2 
9cc9			 
9cc9			; TODO consume comments held between ( and ) 
9cc9			 
9cc9				; we have a space so change to zero term for dict match later 
9cc9 2b				dec hl 
9cca 3e 00			ld a,0 
9ccc 77				ld (hl), a 
9ccd 23				inc hl 
9cce 18 e7			jr .ptoken2 
9cd0				 
9cd0			 
9cd0			.ptokenstr2: 
9cd0				; skip all white space until either eol (because forgot to term) or end double quote 
9cd0			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9cd0				;inc hl ; skip current double quote 
9cd0 7e				ld a,(hl) 
9cd1 23				inc hl 
9cd2 fe 22			cp '"' 
9cd4 28 e1			jr z, .ptoken2 
9cd6 fe 7f			cp FORTH_END_BUFFER 
9cd8 28 0c			jr z, .ptokendone2 
9cda fe 00			cp 0 
9cdc 28 08			jr z, .ptokendone2 
9cde fe 20			cp ' ' 
9ce0 28 02			jr z, .ptmp2 
9ce2 18 ec			jr .ptokenstr2 
9ce4			 
9ce4			.ptmp2:	; we have a space so change to zero term for dict match later 
9ce4				;dec hl 
9ce4				;ld a,"-"	; TODO remove this when working 
9ce4				;ld (hl), a 
9ce4				;inc hl 
9ce4 18 ea			jr .ptokenstr2 
9ce6			 
9ce6			.ptokendone2: 
9ce6				;inc hl 
9ce6 3e 7f			ld a, FORTH_END_BUFFER 
9ce8 77				ld (hl),a 
9ce9 23				inc hl 
9cea 3e 21			ld a, '!' 
9cec 77				ld (hl),a 
9ced			 
9ced 2a de e7			ld hl,(os_tok_ptr) 
9cf0			         
9cf0			if DEBUG_FORTH_TOK 
9cf0						DMARK "TK1" 
9cf0				CALLMONITOR 
9cf0			endif 
9cf0			 
9cf0				; push exec string to top of return stack 
9cf0				FORTH_RSP_NEXT 
9cf0 cd a4 98			call macro_forth_rsp_next 
9cf3				endm 
# End of macro FORTH_RSP_NEXT
9cf3 c9				ret 
9cf4			 
9cf4			; 
9cf4			;	; malloc size + buffer pointer + if is loop flag 
9cf4			;	ld hl,(os_tok_len) 		 ; get string length 
9cf4			; 
9cf4			;	ld a,l 
9cf4			; 
9cf4			;	cp 0			; we dont want to use a null string 
9cf4			;	ret z 
9cf4			; 
9cf4			;;	add 3    ; prefix malloc with buffer for current word ptr 
9cf4			; 
9cf4			;	add 5     ; TODO when certain not over writing memory remove 
9cf4			; 
9cf4			;		 
9cf4			; 
9cf4			;if DEBUG_FORTH_TOK 
9cf4			;			DMARK "TKE" 
9cf4			;	CALLMONITOR 
9cf4			;endif 
9cf4			; 
9cf4			;	ld l,a 
9cf4			;	ld h,0 
9cf4			;;	push hl   ; save required space for the copy later 
9cf4			;	call malloc 
9cf4			;if DEBUG_FORTH_TOK 
9cf4			;			DMARK "TKM" 
9cf4			;	CALLMONITOR 
9cf4			;endif 
9cf4			;	if DEBUG_FORTH_MALLOC_GUARD 
9cf4			;		push af 
9cf4			;		call ishlzero 
9cf4			;;		ld a, l 
9cf4			;;		add h 
9cf4			;;		cp 0 
9cf4			;		pop af 
9cf4			;		 
9cf4			;		call z,malloc_error 
9cf4			;	endif 
9cf4			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9cf4			; 
9cf4			; 
9cf4			;if DEBUG_FORTH_TOK 
9cf4			;			DMARK "TKR" 
9cf4			;	CALLMONITOR 
9cf4			;endif 
9cf4			; 
9cf4			;	FORTH_RSP_NEXT 
9cf4			; 
9cf4			;	;inc hl	 ; go past current buffer pointer 
9cf4			;	;inc hl 
9cf4			;	;inc hl   ; and past if loop flag 
9cf4			;		; TODO Need to set flag  
9cf4			; 
9cf4			;	 
9cf4			;	 
9cf4			;	ex de,hl	; malloc is dest 
9cf4			;	ld hl, (os_tok_len) 
9cf4			;;	pop bc 
9cf4			;	ld c, l                
9cf4			;	ld b,0 
9cf4			;	ld hl, (os_tok_ptr) 
9cf4			; 
9cf4			;if DEBUG_FORTH_TOK 
9cf4			;			DMARK "TKT" 
9cf4			;	CALLMONITOR 
9cf4			;endif 
9cf4			; 
9cf4			;	; do str cpy 
9cf4			; 
9cf4			;	ldir      ; copy byte in hl to de 
9cf4			; 
9cf4			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9cf4			; 
9cf4			;if DEBUG_FORTH_TOK 
9cf4			; 
9cf4			;			DMARK "TKY" 
9cf4			;	CALLMONITOR 
9cf4			;endif 
9cf4			;	;ld a,0 
9cf4			;	;ld a,FORTH_END_BUFFER 
9cf4			;	ex de, hl 
9cf4			;	;dec hl			 ; go back over the space delim at the end of word 
9cf4			;	;ld (hl),a 
9cf4			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9cf4			;	ld a,FORTH_END_BUFFER 
9cf4			;	ld (hl),a 
9cf4			;	inc hl 
9cf4			;	ld a,FORTH_END_BUFFER 
9cf4			;	ld (hl),a 
9cf4			; 
9cf4			;	; init the malloc area data 
9cf4			;	; set pc for in current area 
9cf4			;	;ld hl, (os_tok_malloc) 
9cf4			;	;inc hl 
9cf4			;	;inc hl 
9cf4			;	;inc hl 
9cf4			;	;ex de,hl 
9cf4			;	;ld hl, (os_tok_malloc) 
9cf4			;	;ld (hl),e 
9cf4			;	;inc hl 
9cf4			;	;ld (hl),d 
9cf4			; 
9cf4			; 
9cf4			;	ld hl,(os_tok_malloc) 
9cf4			;if DEBUG_FORTH_PARSE_KEY 
9cf4			;			DMARK "TKU" 
9cf4			;	CALLMONITOR 
9cf4			;endif 
9cf4			; 
9cf4			;	ret 
9cf4			 
9cf4			forthexec: 
9cf4			 
9cf4			; line exec: 
9cf4			; forth parser 
9cf4			 
9cf4			; 
9cf4			;       get current exec line on rsp 
9cf4			 
9cf4				FORTH_RSP_TOS 
9cf4 cd bb 98			call macro_forth_rsp_tos 
9cf7				endm 
# End of macro FORTH_RSP_TOS
9cf7			 
9cf7			;       restore current pc - hl points to malloc of data 
9cf7			 
9cf7				;ld e, (hl) 
9cf7				;inc hl 
9cf7				;ld d, (hl) 
9cf7				;ex de,hl 
9cf7			 
9cf7			 
9cf7			exec1: 
9cf7 22 de e7			ld (os_tok_ptr), hl 
9cfa			 
9cfa				; copy our PC to working vars  
9cfa 22 a8 ec			ld (cli_ptr), hl 
9cfd 22 a6 ec			ld (cli_origptr), hl 
9d00			 
9d00 7e				ld a,(hl) 
9d01 fe 7f			cp FORTH_END_BUFFER 
9d03 c8				ret z 
9d04			 
9d04				; skip any nulls 
9d04			 
9d04 fe 00			cp 0 
9d06 20 03			jr nz, .execword 
9d08 23				inc hl 
9d09 18 ec			jr exec1 
9d0b			 
9d0b			 
9d0b			.execword: 
9d0b			 
9d0b			 
9d0b			 
9d0b			if DEBUG_FORTH_PARSE_KEY 
9d0b						DMARK "KYQ" 
9d0b				CALLMONITOR 
9d0b			endif 
9d0b			;       while at start of word: 
9d0b			; get start of dict (in user area first) 
9d0b			 
9d0b 21 e3 d7		ld hl, baseram 
9d0e			;ld hl, sysdict 
9d0e 22 aa ec		ld (cli_nextword),hl 
9d11			;           match word at pc 
9d11			;           exec word 
9d11			;           or push to dsp 
9d11			;           forward to next token 
9d11			;           if line term pop rsp and exit 
9d11			;        
9d11			 
9d11			if DEBUG_FORTH_PARSE_KEY 
9d11						DMARK "KYq" 
9d11				CALLMONITOR 
9d11			endif 
9d11			 
9d11			; 
9d11			; word comp 
9d11			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9d11			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9d11			;    move to start of word  
9d11			;    compare word to cli_token 
9d11			 
9d11			.execpnword:	; HL at start of a word in the dictionary to check 
9d11			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9d11			;	ld (cli_ptr), hl 
9d11			 
9d11 2a aa ec			ld hl,(cli_nextword) 
9d14			 
9d14 cd b7 9d			call forth_tok_next 
9d17			; tok next start here 
9d17			;	; TODO skip compiled symbol for now 
9d17			;	inc hl 
9d17			; 
9d17			;	; save pointer to next word 
9d17			; 
9d17			;	; hl now points to the address of the next word pointer  
9d17			;	ld e, (hl) 
9d17			;	inc hl 
9d17			;	ld d, (hl) 
9d17			;	inc l 
9d17			; 
9d17			;	ex de,hl 
9d17			;if DEBUG_FORTH_PARSE_NEXTWORD 
9d17			;	push bc 
9d17			;	ld bc, (cli_nextword) 
9d17			;			DMARK "NXW" 
9d17			;	CALLMONITOR 
9d17			;	pop bc 
9d17			;endif 
9d17			; tok next end here 
9d17 22 aa ec			ld (cli_nextword), hl     ; save for next check if no match on this word 
9d1a eb				ex de, hl 
9d1b			 
9d1b			 
9d1b				; save the pointer of the current token - 1 to check against 
9d1b				 
9d1b 22 ae ec			ld (cli_token), hl   
9d1e				; TODO maybe remove below save if no debug 
9d1e				; save token string ptr for any debug later 
9d1e 23				inc hl  
9d1f 22 b0 ec			ld (cli_origtoken), hl 
9d22 2b				dec hl 
9d23				; save pointer to the start of the next dictionay word 
9d23 7e				ld a,(hl)   ; get string length 
9d24 47				ld b,a 
9d25			.execpnwordinc:  
9d25 23				inc hl 
9d26 10 fd			djnz .execpnwordinc 
9d28 22 ac ec			ld (cli_execword), hl      ; save start of this words code 
9d2b			 
9d2b				; now check the word token against the string being parsed 
9d2b			 
9d2b 2a ae ec			ld hl,(cli_token) 
9d2e 23				inc hl     ; skip string length (use zero term instead to end) 
9d2f 22 ae ec			ld (cli_token), hl 
9d32			 
9d32			if DEBUG_FORTH_PARSE_KEY 
9d32						DMARK "KY2" 
9d32			endif 
9d32			if DEBUG_FORTH_PARSE_EXEC 
9d32				; see if disabled 
9d32			 
9d32				ld a, (os_view_disable) 
9d32				cp '*' 
9d32				jr z, .skip 
9d32			 
9d32				push hl 
9d32				push hl 
9d32				call clear_display 
9d32				ld de, .compword 
9d32				ld a, display_row_1 
9d32				call str_at_display 
9d32				pop de 
9d32				ld a, display_row_2 
9d32				call str_at_display 
9d32				ld hl,(cli_ptr) 
9d32				ld a,(hl) 
9d32			        ld hl, os_word_scratch 
9d32				ld (hl),a 
9d32				ld a,0 
9d32				inc hl 
9d32				ld (hl),a 	 
9d32				ld de, os_word_scratch 
9d32				ld a, display_row_2+10 
9d32				call str_at_display 
9d32				call update_display 
9d32				ld a, 100 
9d32				call aDelayInMS 
9d32				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d32				call delay250ms 
9d32				endif 
9d32				pop hl 
9d32			.skip:  
9d32			endif	 
9d32			.execpnchar:    ; compare char between token and string to parse 
9d32			 
9d32			if DEBUG_FORTH_PARSE_KEY 
9d32						DMARK "Ky3" 
9d32			endif 
9d32			if DEBUG_FORTH_PARSE_EXEC 
9d32				; see if disabled 
9d32			 
9d32				ld a, (os_view_disable) 
9d32				cp '*' 
9d32				jr z, .skip2 
9d32			 
9d32			;	call clear_display 
9d32			ld hl,(cli_token) 
9d32			ld a,(hl) 
9d32			ld (os_word_scratch),a 
9d32				ld hl,(cli_ptr) 
9d32			ld a,(hl) 
9d32				ld (os_word_scratch+1),a 
9d32				ld a,0 
9d32				ld (os_word_scratch+2),a 
9d32				ld de,os_word_scratch 
9d32				ld a,display_row_4 
9d32				call str_at_display 
9d32				call update_display 
9d32			.skip2:  
9d32			endif 
9d32 2a ae ec			ld hl,(cli_token) 
9d35 7e				ld a, (hl)	 ; char in word token 
9d36 23				inc hl 		; move to next char 
9d37 22 ae ec			ld (cli_token), hl ; and save it 
9d3a 47				ld b,a 
9d3b			 
9d3b 2a a8 ec			ld hl,(cli_ptr) ;	get the char from the string to parse 
9d3e 7e				ld a,(hl) 
9d3f 23				inc hl 
9d40 22 a8 ec			ld (cli_ptr), hl		; move to next char 
9d43 cd f7 8e			call toUpper 		; make sure the input string matches case 
9d46			 
9d46			if DEBUG_FORTH_PARSE 
9d46			endif 
9d46			 
9d46				; input stream end of token is a space so get rid of it 
9d46			 
9d46			;	cp ' ' 
9d46			;	jr nz, .pnskipspace 
9d46			; 
9d46			;	ld a, 0		; make same term as word token term 
9d46			; 
9d46			;.pnskipspace: 
9d46			 
9d46			if DEBUG_FORTH_PARSE_KEY 
9d46						DMARK "KY7" 
9d46			endif 
9d46 b8				cp b 
9d47 c2 5d 9d			jp nz, .execpnskipword	 ; no match so move to next word 
9d4a				 
9d4a			;    if same 
9d4a			;       scan for string terms 0 for token and 32 for input 
9d4a			 
9d4a				 
9d4a			if DEBUG_FORTH_PARSE_KEY 
9d4a						DMARK "KY8" 
9d4a			endif 
9d4a			 
9d4a 80				add b			 
9d4b fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9d4d							; TODO need to make sure last word in zero term string is accounted for 
9d4d 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9d4f			 
9d4f			 
9d4f				; at end of both strings so both are exact match 
9d4f			 
9d4f			;       skip ptr for next word 
9d4f			 
9d4f 2a a8 ec			ld hl,(cli_ptr) 	; at input string term 
9d52 23				inc hl			 ; at next char 
9d53 22 a8 ec			ld (cli_ptr), hl     ; save for next round of the parser 
9d56 22 a6 ec			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9d59				 
9d59				 
9d59			if DEBUG_FORTH_PARSE_KEY 
9d59						DMARK "KY3" 
9d59			endif 
9d59			 
9d59			 
9d59			 
9d59			;       exec code block 
9d59			if DEBUG_FORTH_JP 
9d59				call clear_display 
9d59				call update_display 
9d59				call delay1s 
9d59				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d59				ld a,h 
9d59				ld hl, os_word_scratch 
9d59				call hexout 
9d59				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d59				ld a,l 
9d59				ld hl, os_word_scratch+2 
9d59				call hexout 
9d59				ld hl, os_word_scratch+4 
9d59				ld a,0 
9d59				ld (hl),a 
9d59				ld de,os_word_scratch 
9d59				call str_at_display 
9d59					ld a, display_row_2 
9d59					call str_at_display 
9d59				ld de, (cli_origtoken) 
9d59				ld a, display_row_1+10 
9d59					call str_at_display 
9d59			 
9d59				ld a,display_row_1 
9d59				ld de, .foundword 
9d59				ld a, display_row_3 
9d59				call str_at_display 
9d59				call update_display 
9d59				call delay1s 
9d59				call delay1s 
9d59				call delay1s 
9d59			endif 
9d59			 
9d59			if DEBUG_FORTH_PARSE_KEY 
9d59						DMARK "KYj" 
9d59			endif 
9d59				; TODO save the word pointer in this exec 
9d59			 
9d59 2a ac ec			ld hl,(cli_execword) 
9d5c e9				jp (hl) 
9d5d			 
9d5d			 
9d5d			;    if not same 
9d5d			;	scan for zero term 
9d5d			;	get ptr for next word 
9d5d			;	goto word comp 
9d5d			 
9d5d			.execpnskipword:	; get pointer to next word 
9d5d 2a aa ec			ld hl,(cli_nextword) 
9d60			 
9d60 7e				ld a,(hl) 
9d61 fe 00			cp WORD_SYS_END 
9d63			;	cp 0 
9d63 28 09			jr z, .execendofdict			 ; at end of words 
9d65			 
9d65			if DEBUG_FORTH_PARSE_KEY 
9d65						DMARK "KY4" 
9d65			endif 
9d65			if DEBUG_FORTH_PARSE_EXEC 
9d65			 
9d65				; see if disabled 
9d65			 
9d65				ld a, (os_view_disable) 
9d65				cp '*' 
9d65				jr z, .noskip 
9d65			 
9d65			 
9d65				ld de, .nowordfound 
9d65				ld a, display_row_3 
9d65				call str_at_display 
9d65				call update_display 
9d65				ld a, 100 
9d65				call aDelayInMS 
9d65				 
9d65				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d65					call delay250ms 
9d65				endif 
9d65			.noskip:  
9d65			 
9d65			endif	 
9d65			 
9d65 2a a6 ec			ld hl,(cli_origptr) 
9d68 22 a8 ec			ld (cli_ptr),hl 
9d6b			 
9d6b			if DEBUG_FORTH_PARSE_KEY 
9d6b						DMARK "KY5" 
9d6b			endif 
9d6b c3 11 9d			jp .execpnword			; else go to next word 
9d6e			 
9d6e			.execendofdict:  
9d6e			 
9d6e			if DEBUG_FORTH_PARSE_KEY 
9d6e						DMARK "KYe" 
9d6e			endif 
9d6e			if DEBUG_FORTH_PARSE_EXEC 
9d6e				; see if disabled 
9d6e			 
9d6e				ld a, (os_view_disable) 
9d6e				cp '*' 
9d6e				jr z, .ispskip 
9d6e			 
9d6e				call clear_display 
9d6e				call update_display 
9d6e				call delay1s 
9d6e				ld de, (cli_origptr) 
9d6e				ld a, display_row_1 
9d6e				call str_at_display 
9d6e				 
9d6e				ld de, .enddict 
9d6e				ld a, display_row_3 
9d6e				call str_at_display 
9d6e				call update_display 
9d6e				ld a, 100 
9d6e				call aDelayInMS 
9d6e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d6e				call delay1s 
9d6e				call delay1s 
9d6e				call delay1s 
9d6e				endif 
9d6e			.ispskip:  
9d6e				 
9d6e			endif	 
9d6e			 
9d6e			 
9d6e			 
9d6e				; if the word is not a keyword then must be a literal so push it to stack 
9d6e			 
9d6e			; push token to stack to end of word 
9d6e			 
9d6e				STACKFRAME ON $1efe $2f9f 
9d6e				if DEBUG_STACK_IMB 
9d6e					if ON 
9d6e						exx 
9d6e						ld de, $1efe 
9d6e						ld a, d 
9d6e						ld hl, curframe 
9d6e						call hexout 
9d6e						ld a, e 
9d6e						ld hl, curframe+2 
9d6e						call hexout 
9d6e						ld hl, $1efe 
9d6e						push hl 
9d6e						ld hl, $2f9f 
9d6e						push hl 
9d6e						exx 
9d6e					endif 
9d6e				endif 
9d6e			endm 
# End of macro STACKFRAME
9d6e			 
9d6e 2a de e7		ld hl,(os_tok_ptr) 
9d71 cd 66 9a		call forth_apush 
9d74			 
9d74				STACKFRAMECHK ON $1efe $2f9f 
9d74				if DEBUG_STACK_IMB 
9d74					if ON 
9d74						exx 
9d74						ld hl, $2f9f 
9d74						pop de   ; $2f9f 
9d74						call cmp16 
9d74						jr nz, .spnosame 
9d74						ld hl, $1efe 
9d74						pop de   ; $1efe 
9d74						call cmp16 
9d74						jr z, .spfrsame 
9d74						.spnosame: call showsperror 
9d74						.spfrsame: nop 
9d74						exx 
9d74					endif 
9d74				endif 
9d74			endm 
# End of macro STACKFRAMECHK
9d74			 
9d74			execnext: 
9d74			 
9d74			if DEBUG_FORTH_PARSE_KEY 
9d74						DMARK "KY>" 
9d74			endif 
9d74			; move past token to next word 
9d74			 
9d74 2a de e7		ld hl, (os_tok_ptr) 
9d77 3e 00		ld a, 0 
9d79 01 ff 00		ld bc, 255     ; input buffer size 
9d7c ed b1		cpir 
9d7e			 
9d7e			if DEBUG_FORTH_PARSE_KEY 
9d7e						DMARK "KY!" 
9d7e				CALLMONITOR 
9d7e			endif	 
9d7e			; TODO this might place hl on the null, so will need to forward on??? 
9d7e			;inc hl   ; see if this gets onto the next item 
9d7e			 
9d7e			 
9d7e			; TODO pass a pointer to the buffer to push 
9d7e			; TODO call function to push 
9d7e			 
9d7e			; look for end of input 
9d7e			 
9d7e			;inc hl 
9d7e			;ld a,(hl) 
9d7e			;cp FORTH_END_BUFFER 
9d7e			;ret z 
9d7e			 
9d7e			 
9d7e c3 f7 9c		jp exec1 
9d81			 
9d81			 
9d81			 
9d81			 
9d81			 
9d81			 
9d81			 
9d81			 
9d81			 
9d81			findnexttok: 
9d81			 
9d81				; hl is pointer to move 
9d81				; de is the token to locate 
9d81			 
9d81					if DEBUG_FORTH 
9d81						DMARK "NTK" 
9d81						CALLMONITOR 
9d81					endif 
9d81 d5				push de 
9d82			 
9d82			.fnt1:	 
9d82				; find first char of token to locate 
9d82			 
9d82 1a				ld a, (de) 
9d83 4f				ld c,a 
9d84 7e				ld a,(hl) 
9d85 cd f7 8e			call toUpper 
9d88					if DEBUG_FORTH 
9d88						DMARK "NT1" 
9d88						CALLMONITOR 
9d88					endif 
9d88 b9				cp c 
9d89			 
9d89 28 03			jr z, .fnt2cmpmorefirst	 
9d8b			 
9d8b				; first char not found move to next char 
9d8b			 
9d8b 23				inc hl 
9d8c 18 f4			jr .fnt1 
9d8e			 
9d8e			.fnt2cmpmorefirst:	 
9d8e				; first char of token found.  
9d8e			 
9d8e e5				push hl     ; save start of token just in case it is the right one 
9d8f d9				exx 
9d90 e1				pop hl        ; save it to hl' 
9d91 d9				exx 
9d92			 
9d92			 
9d92			.fnt2cmpmore:	 
9d92				; compare the rest 
9d92				 
9d92 23				inc hl 
9d93 13				inc de 
9d94				 
9d94 1a				ld a, (de) 
9d95 4f				ld c,a 
9d96 7e				ld a,(hl) 
9d97 cd f7 8e			call toUpper 
9d9a			 
9d9a					if DEBUG_FORTH 
9d9a						DMARK "NT2" 
9d9a						CALLMONITOR 
9d9a					endif 
9d9a				; c has the token to find char 
9d9a				; a has the mem to scan char 
9d9a			 
9d9a b9				cp c 
9d9b 28 04			jr z,.fntmatch1 
9d9d			 
9d9d				; they are not the same 
9d9d			 
9d9d					if DEBUG_FORTH 
9d9d						DMARK "NT3" 
9d9d						CALLMONITOR 
9d9d					endif 
9d9d d1				pop de	; reset de token to look for 
9d9e d5				push de 
9d9f 18 e1			jr .fnt1 
9da1				 
9da1			.fntmatch1: 
9da1			 
9da1				; is the same char a null which means we might have a full hit? 
9da1					if DEBUG_FORTH 
9da1						DMARK "NT4" 
9da1						CALLMONITOR 
9da1					endif 
9da1			 
9da1 fe 00			cp 0 
9da3 28 0b			jr z, .fntmatchyes 
9da5			 
9da5				; are we at the end of the token to find? 
9da5			 
9da5					if DEBUG_FORTH 
9da5						DMARK "NT5" 
9da5						CALLMONITOR 
9da5					endif 
9da5 3e 00			ld a, 0 
9da7 b9				cp c 
9da8			 
9da8 c2 92 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9dab			 
9dab					if DEBUG_FORTH 
9dab						DMARK "NT6" 
9dab						CALLMONITOR 
9dab					endif 
9dab				; token to find is exhusted but no match to stream 
9dab			 
9dab				; restore tok pointer and continue on 
9dab d1				pop de 
9dac d5				push de 
9dad c3 82 9d			jp .fnt1 
9db0			 
9db0			 
9db0			.fntmatchyes: 
9db0			 
9db0				; hl now contains the end of the found token 
9db0			 
9db0				; get rid of saved token pointer to find 
9db0			 
9db0 d1				pop de 
9db1			 
9db1					if DEBUG_FORTH 
9db1						DMARK "NT9" 
9db1						CALLMONITOR 
9db1					endif 
9db1			 
9db1				; hl will be on the null term so forward on 
9db1			 
9db1				; get back the saved start of the token 
9db1			 
9db1 d9				exx 
9db2 e5				push hl     ; save start of token just in case it is the right one 
9db3 d9				exx 
9db4 e1				pop hl        ; save it to hl 
9db5			 
9db5 c9				ret 
9db6			 
9db6			 
9db6			; LIST needs to find a specific token   
9db6			; FORGET needs to find a spefici token 
9db6			 
9db6			; SAVE needs to find all tokens by flag 
9db6			; WORDS just needs to scan through all  by flag 
9db6			; UWORDS needs to scan through all by flag 
9db6			 
9db6			 
9db6			; given hl as pointer to start of dict look up string 
9db6			; return hl as pointer to start of word block 
9db6			; or 0 if not found 
9db6			 
9db6			forth_find_tok: 
9db6 c9				ret 
9db7			 
9db7			; given hl as pointer to dict structure 
9db7			; move to the next dict block structure 
9db7			 
9db7			forth_tok_next: 
9db7				; hl now points to the address of the next word pointer  
9db7				; TODO skip compiled symbol for now 
9db7			;	push de 
9db7 23				inc hl 
9db8 5e				ld e, (hl) 
9db9 23				inc hl 
9dba 56				ld d, (hl) 
9dbb 23				inc hl 
9dbc			 
9dbc eb				ex de,hl 
9dbd			if DEBUG_FORTH_PARSE_NEXTWORD 
9dbd				push bc 
9dbd				ld bc, (cli_nextword) 
9dbd						DMARK "NXW" 
9dbd				CALLMONITOR 
9dbd				pop bc 
9dbd			endif 
9dbd			;	pop de	 
9dbd c9				ret 
9dbe			 
9dbe			 
9dbe			 
9dbe			; eof 
# End of file forth_parserv5.asm
9dbe				include "forth_wordsv4.asm" 
9dbe			 
9dbe			; the core word dictionary v4 
9dbe			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9dbe			 
9dbe			; this is a linked list for each of the system words used 
9dbe			; user defined words will follow the same format but will be in ram 
9dbe			 
9dbe			 
9dbe			; 
9dbe			; 
9dbe			; define linked list: 
9dbe			; 
9dbe			; 1. compiled byte op code 
9dbe			; 2. len of text word 
9dbe			; 3. text word 
9dbe			; 4. ptr to next dictionary word 
9dbe			; 5. asm, calls etc for the word 
9dbe			; 
9dbe			;  if 1 == 0 then last word in dict  
9dbe			;   
9dbe			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9dbe			;  
9dbe			;  
9dbe			; create basic standard set of words 
9dbe			; 
9dbe			;  
9dbe			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9dbe			; 2DUP 2DROP 2SWAP  
9dbe			; @ C@ - get byte  
9dbe			; ! C! - store byte 
9dbe			; 0< true if less than zero 
9dbe			; 0= true if zero 
9dbe			; < >  
9dbe			; = true if same 
9dbe			; variables 
9dbe			 
9dbe			 
9dbe			; Hardware specific words I may need 
9dbe			; 
9dbe			; IN OUT  
9dbe			; calls to key util functions 
9dbe			; calls to hardward abstraction stuff 
9dbe			; easy control of frame buffers and lcd i/o 
9dbe			; keyboard  
9dbe			 
9dbe			 
9dbe			;DICT: macro 
9dbe			; op_code, len, word, next 
9dbe			;    word: 
9dbe			;    db op_code 
9dbe			;    ds word zero term 
9dbe			;    dw next 
9dbe			;    endm 
9dbe			 
9dbe			 
9dbe			 
9dbe			 
9dbe			; op code 1 is a flag for user define words which are to be handled differently 
9dbe			 
9dbe			 
9dbe			; 
9dbe			; 
9dbe			;    TODO on entry to a word this should be the expected environment 
9dbe			;    hl - tos value if number then held, if string this is the ptr 
9dbe			;    de -  
9dbe			 
9dbe			 
9dbe			; opcode ranges 
9dbe			; 0 - end of word dict 
9dbe			; 255 - user define words 
9dbe			 
9dbe			sysdict: 
9dbe			include "forth_opcodes.asm" 
9dbe			; op codes for forth keywords 
9dbe			; free to use code 0  
9dbe				OPCODE_HEAP: equ  1 
9dbe				OPCODE_EXEC: equ 2 
9dbe				OPCODE_DUP: equ 3 
9dbe				OPCODE_SWAP: equ 4 
9dbe				OPCODE_COLN: equ 5 
9dbe				OPCODE_SCOLN: equ 6 
9dbe				OPCODE_DROP: equ 7 
9dbe				OPCODE_DUP2: equ 8 
9dbe				OPCODE_DROP2: equ 9 
9dbe				OPCODE_SWAP2: equ 10 
9dbe				OPCODE_AT: equ 11 
9dbe				OPCODE_CAT: equ 12 
9dbe				OPCODE_BANG: equ 13 
9dbe				OPCODE_CBANG: equ 14 
9dbe				OPCODE_SCALL: equ 15 
9dbe				OPCODE_DEPTH: equ 16 
9dbe				OPCODE_OVER: equ 17 
9dbe				OPCODE_PAUSE: equ 18 
9dbe				OPCODE_PAUSES: equ 19 
9dbe				OPCODE_ROT: equ 20 
9dbe			;free to reuse	OPCODE_WORDS: equ 21 
9dbe			        OPCODE_NOT: equ 21 
9dbe				OPCODE_UWORDS: equ 22 
9dbe				OPCODE_BP: equ 23 
9dbe				OPCODE_MONITOR: equ 24  
9dbe				OPCODE_MALLOC: equ 25 
9dbe				OPCODE_FREE: equ 26 
9dbe				OPCODE_LIST: equ 27 
9dbe				OPCODE_FORGET: equ 28 
9dbe				OPCODE_NOP: equ 29 
9dbe				OPCODE_COMO: equ 30 
9dbe				OPCODE_COMC: equ 31 
9dbe			;free to reuse	OPCODE_ENDCORE: equ 32 
9dbe				OPCODE_AFTERSOUND: equ 33 
9dbe				OPCODE_GP2: equ 34 
9dbe				OPCODE_GP3: equ 35 
9dbe				OPCODE_GP4: equ 36 
9dbe				OPCODE_SIN: equ 37 
9dbe				OPCODE_SOUT: equ 38 
9dbe				OPCODE_SPIO: equ 39 
9dbe				OPCODE_SPICEH: equ 40 
9dbe				OPCODE_SPIOb: equ 41 
9dbe				OPCODE_SPII: equ 42 
9dbe				OPCODE_SESEL: equ 43 
9dbe				OPCODE_CARTDEV: equ 44 
9dbe			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9dbe				OPCODE_FB: equ 46 
9dbe				OPCODE_EMIT: equ 47 
9dbe				OPCODE_DOTH: equ 48 
9dbe				OPCODE_DOTF: equ 49 
9dbe				OPCODE_DOT: equ 50 
9dbe				OPCODE_CLS: equ 51 
9dbe				OPCODE_DRAW: equ 52 
9dbe				OPCODE_DUMP: equ 53 
9dbe				OPCODE_CDUMP: equ 54 
9dbe				OPCODE_DAT: equ 55 
9dbe				OPCODE_HOME: equ 56 
9dbe				OPCODE_SPACE: equ 57 
9dbe				OPCODE_SPACES: equ 58 
9dbe				OPCODE_SCROLL: equ 59 
9dbe				OPCODE_ATQ: equ 60 
9dbe				OPCODE_AUTODSP: equ 61 
9dbe				OPCODE_MENU: equ 62 
9dbe			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9dbe				OPCODE_THEN: equ 64 
9dbe				OPCODE_ELSE: equ 65 
9dbe				OPCODE_DO: equ 66 
9dbe				OPCODE_LOOP: equ 67 
9dbe				OPCODE_I: equ 68 
9dbe				OPCODE_DLOOP: equ 69  
9dbe				OPCODE_REPEAT: equ 70  
9dbe				OPCODE_UNTIL: equ 71 
9dbe				OPCODE_ENDFLOW: equ 72 
9dbe				OPCODE_WAITK: equ 73 
9dbe				OPCODE_ACCEPT: equ 74 
9dbe				OPCODE_EDIT: equ 75 
9dbe			;free to reuse	OPCODE_ENDKEY: equ 76 
9dbe				OPCODE_LZERO: equ 77 
9dbe				OPCODE_TZERO: equ 78 
9dbe				OPCODE_LESS: equ 79 
9dbe				OPCODE_GT: equ 80 
9dbe				OPCODE_EQUAL: equ 81  
9dbe			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9dbe				OPCODE_NEG: equ 83 
9dbe				OPCODE_DIV: equ 84 
9dbe				OPCODE_MUL: equ 85 
9dbe				OPCODE_MIN: equ 86 
9dbe				OPCODE_MAX: equ 87 
9dbe				OPCODE_RND16: equ 88 
9dbe				OPCODE_RND8: equ 89 
9dbe				OPCODE_RND: equ 90 
9dbe			;free to reuse	OPCODE_ENDMATHS: equ 91  
9dbe				OPCODE_BYNAME: equ 92 
9dbe				OPCODE_DIR: equ 93 
9dbe				OPCODE_SAVE: equ 94 
9dbe				OPCODE_LOAD: equ 95 
9dbe				OPCODE_BSAVE: equ 96 
9dbe				OPCODE_BLOAD: equ 97 
9dbe				OPCODE_SEO: equ 98  
9dbe				OPCODE_SEI: equ 99 
9dbe				OPCODE_SFREE: equ 100 
9dbe				OPCODE_SIZE: equ 101 
9dbe				OPCODE_CREATE: equ 102 
9dbe				OPCODE_APPEND: equ 103 
9dbe				OPCODE_SDEL: equ 104 
9dbe				OPCODE_OPEN: equ 105 
9dbe				OPCODE_READ: equ 106 
9dbe				OPCODE_EOF: equ 106 
9dbe				OPCODE_FORMAT: equ 107 
9dbe				OPCODE_LABEL: equ 108 
9dbe				OPCODE_LABELS: equ 109 
9dbe			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9dbe				OPCODE_UPPER: equ 111 
9dbe				OPCODE_LOWER: equ 112 
9dbe				OPCODE_SUBSTR: equ 113 
9dbe				OPCODE_LEFT: equ 114 
9dbe				OPCODE_RIGHT: equ 115 
9dbe				OPCODE_STR2NUM: equ 116 
9dbe				OPCODE_NUM2STR: equ 117 
9dbe				OPCODE_CONCAT: equ 118 
9dbe				OPCODE_FIND: equ 119 
9dbe				OPCODE_LEN: equ 120 
9dbe				OPCODE_CHAR: equ 121 
9dbe			; free to reuse	OPCODE_STRLEN: equ 122 
9dbe			; free to reuse	OPCODE_ENDSTR: equ 123 
9dbe				OPCODE_V0S: equ 124 
9dbe				OPCODE_V0Q: equ 125 
9dbe				OPCODE_V1S: equ 126 
9dbe				OPCODE_V1Q: equ 127 
9dbe				OPCODE_V2S: equ 128 
9dbe				OPCODE_V2Q: equ 129 
9dbe				OPCODE_V3S: equ 130 
9dbe				OPCODE_V3Q: equ 131 
9dbe			;free to reuse	OPCODE_END: equ 132 
9dbe				OPCODE_ZDUP: equ 133 
9dbe			 
9dbe			; eof 
# End of file forth_opcodes.asm
9dbe			 
9dbe			include "forth_words_core.asm" 
9dbe			 
9dbe			; | ## Core Words 
9dbe			 
9dbe			;if MALLOC_4 
9dbe			 
9dbe			.HEAP: 
9dbe				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9dbe 15				db WORD_SYS_CORE+OPCODE_HEAP             
9dbf fd 9d			dw .EXEC            
9dc1 05				db 4 + 1 
9dc2 .. 00			db "HEAP",0              
9dc7				endm 
# End of macro CWHEAD
9dc7			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9dc7			; | | u1 - Current number of bytes in the heap 
9dc7			; | | u2 - Remaining bytes left on the heap 
9dc7			; | |  
9dc7			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9dc7			 
9dc7			 
9dc7					if DEBUG_FORTH_WORDS_KEY 
9dc7						DMARK "HEP" 
9dc7 f5				push af  
9dc8 3a dc 9d			ld a, (.dmark)  
9dcb 32 b7 ee			ld (debug_mark),a  
9dce 3a dd 9d			ld a, (.dmark+1)  
9dd1 32 b8 ee			ld (debug_mark+1),a  
9dd4 3a de 9d			ld a, (.dmark+2)  
9dd7 32 b9 ee			ld (debug_mark+2),a  
9dda 18 03			jr .pastdmark  
9ddc ..			.dmark: db "HEP"  
9ddf f1			.pastdmark: pop af  
9de0			endm  
# End of macro DMARK
9de0						CALLMONITOR 
9de0 cd a3 92			call break_point_state  
9de3				endm  
# End of macro CALLMONITOR
9de3					endif 
9de3 2a ed d7				ld hl, (free_list )      
9de6 11 f2 d7				ld de, heap_start 
9de9			 
9de9 ed 52				sbc hl, de  
9deb			 
9deb cd fd 98				call forth_push_numhl 
9dee			 
9dee			 
9dee ed 5b ed d7			ld de, (free_list )      
9df2 21 c3 e4				ld hl, heap_end 
9df5			 
9df5 ed 52				sbc hl, de 
9df7			 
9df7 cd fd 98				call forth_push_numhl 
9dfa					 
9dfa			 
9dfa					 
9dfa			 
9dfa			 
9dfa			 
9dfa					NEXTW 
9dfa c3 66 9c			jp macro_next 
9dfd				endm 
# End of macro NEXTW
9dfd			;endif 
9dfd			 
9dfd			.EXEC: 
9dfd			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9dfd			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9dfd			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9dfd			;; > > 
9dfd			;; > >   
9dfd			;	STACKFRAME OFF $5efe $5f9f 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS_KEY 
9dfd			;			DMARK "EXE" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			; 
9dfd			;	FORTH_DSP_VALUEHL 
9dfd			; 
9dfd			;	FORTH_DSP_POP 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EX1" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;;	ld e,(hl) 
9dfd			;;	inc hl 
9dfd			;;	ld d,(hl) 
9dfd			;;	ex de,hl 
9dfd			; 
9dfd			;;		if DEBUG_FORTH_WORDS 
9dfd			;;			DMARK "EX2" 
9dfd			;;			CALLMONITOR 
9dfd			;;		endif 
9dfd			;	push hl 
9dfd			; 
9dfd			;	;ld a, 0 
9dfd			;	;ld a, FORTH_END_BUFFER 
9dfd			;	call strlenz 
9dfd			;	inc hl   ; include zero term to copy 
9dfd			;	inc hl   ; include term 
9dfd			;	inc hl   ; include term 
9dfd			;	ld b,0 
9dfd			;	ld c,l 
9dfd			;	pop hl 
9dfd			;	ld de, execscratch 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EX3" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;	ldir 
9dfd			; 
9dfd			; 
9dfd			;	ld hl, execscratch 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EXe" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			; 
9dfd			;	call forthparse 
9dfd			;	call forthexec 
9dfd			;;	call forthexec_cleanup 
9dfd			;;	call forthparse 
9dfd			;;	call forthexec 
9dfd			; 
9dfd			;	STACKFRAMECHK OFF $5efe $5f9f 
9dfd			; 
9dfd			;	; an immediate word so no need to process any more words 
9dfd			;	ret 
9dfd			;	NEXTW 
9dfd			 
9dfd			; dead code - old version  
9dfd			;	FORTH_RSP_NEXT 
9dfd			 
9dfd			;  
9dfd			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9dfd			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9dfd			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9dfd			;	push hl 
9dfd			;	push de 
9dfd			;	push bc 
9dfd			; 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS_KEY 
9dfd			;			DMARK "EXR" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			; 
9dfd			; 
9dfd			; 
9dfd			;	;v5 FORTH_DSP_VALUE 
9dfd			;	FORTH_DSP_VALUEHL 
9dfd			; 
9dfd			;	; TODO do string type checks 
9dfd			; 
9dfd			;;v5	inc hl   ; skip type 
9dfd			; 
9dfd			;	push hl  ; source code  
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EX1" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;	ld a, 0 
9dfd			;	call strlent 
9dfd			; 
9dfd			;	inc hl 
9dfd			;	inc hl 
9dfd			;	inc hl 
9dfd			;	inc hl 
9dfd			; 
9dfd			;	push hl    ; size 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EX2" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;	call malloc 
9dfd			; 
9dfd			;	ex de, hl    ; de now contains malloc area 
9dfd			;	pop bc   	; get byte count 
9dfd			;	pop hl      ; get string to copy 
9dfd			; 
9dfd			;	push de     ; save malloc for free later 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EX3" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;	ldir       ; duplicate string 
9dfd			; 
9dfd			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9dfd			;	 
9dfd			;	; TODO fix the parse would be better than this...  
9dfd			;	ex de, hl 
9dfd			;	dec hl 
9dfd			;	ld a, 0 
9dfd			;	ld (hl), a 
9dfd			;	dec hl 
9dfd			;	ld a, ' ' 
9dfd			;	ld (hl), a 
9dfd			;	dec hl 
9dfd			;	ld (hl), a 
9dfd			; 
9dfd			;	dec hl 
9dfd			;	ld (hl), a 
9dfd			; 
9dfd			; 
9dfd			;	FORTH_DSP_POP  
9dfd			; 
9dfd			;	pop hl     
9dfd			;	push hl    ; save malloc area 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EX4" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			; 
9dfd			;	call forthparse 
9dfd			;	call forthexec 
9dfd			;	 
9dfd			;	pop hl 
9dfd			;	if DEBUG_FORTH_WORDS 
9dfd			;		DMARK "EX5" 
9dfd			;		CALLMONITOR 
9dfd			;	endif 
9dfd			; 
9dfd			;	if FORTH_ENABLE_FREE 
9dfd			;	call free 
9dfd			;	endif 
9dfd			; 
9dfd			;	if DEBUG_FORTH_WORDS 
9dfd			;		DMARK "EX6" 
9dfd			;		CALLMONITOR 
9dfd			;	endif 
9dfd			; 
9dfd			;	pop bc 
9dfd			;	pop de 
9dfd			;	pop hl 
9dfd			;;	FORTH_RSP_POP	  
9dfd			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9dfd			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9dfd			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9dfd			; 
9dfd			;	if DEBUG_FORTH_WORDS 
9dfd			;		DMARK "EX7" 
9dfd			;		CALLMONITOR 
9dfd			;	endif 
9dfd			;	NEXTW 
9dfd			 
9dfd			;.STKEXEC: 
9dfd			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9dfd			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9dfd			; 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS_KEY 
9dfd			;			DMARK "STX" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			; 
9dfd			;	FORTH_DSP_VALUEHL 
9dfd			; 
9dfd			;	ld (store_tmp1), hl    ; count 
9dfd			; 
9dfd			;	FORTH_DSP_POP 
9dfd			;.stkexec1: 
9dfd			;	ld hl, (store_tmp1)   ; count 
9dfd			;	ld a, 0 
9dfd			;	cp l 
9dfd			;	ret z 
9dfd			; 
9dfd			;	dec hl 
9dfd			;	ld (store_tmp1), hl    ; count 
9dfd			;	 
9dfd			;	FORTH_DSP_VALUEHL 
9dfd			;	push hl 
9dfd			;	 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EXp" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;	FORTH_DSP_POP 
9dfd			; 
9dfd			;	call strlenz 
9dfd			;	inc hl   ; include zero term to copy 
9dfd			;	inc hl   ; include zero term to copy 
9dfd			;	inc hl   ; include zero term to copy 
9dfd			;	ld b,0 
9dfd			;	ld c,l 
9dfd			;	pop hl 
9dfd			;	ld de, execscratch 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EX3" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;	ldir 
9dfd			; 
9dfd			; 
9dfd			;	ld hl, execscratch 
9dfd			; 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EXP" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			; 
9dfd			;	call forthparse 
9dfd			;	ld hl, execscratch 
9dfd			;		if DEBUG_FORTH_WORDS 
9dfd			;			DMARK "EXx" 
9dfd			;			CALLMONITOR 
9dfd			;		endif 
9dfd			;	call forthexec 
9dfd			; 
9dfd			;	jp .stkexec1 
9dfd			; 
9dfd			;	ret 
9dfd			 
9dfd			 
9dfd			.DUP: 
9dfd				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9dfd 17				db WORD_SYS_CORE+OPCODE_DUP             
9dfe 73 9e			dw .ZDUP            
9e00 04				db 3 + 1 
9e01 .. 00			db "DUP",0              
9e05				endm 
# End of macro CWHEAD
9e05			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9e05			 
9e05					if DEBUG_FORTH_WORDS_KEY 
9e05						DMARK "DUP" 
9e05 f5				push af  
9e06 3a 1a 9e			ld a, (.dmark)  
9e09 32 b7 ee			ld (debug_mark),a  
9e0c 3a 1b 9e			ld a, (.dmark+1)  
9e0f 32 b8 ee			ld (debug_mark+1),a  
9e12 3a 1c 9e			ld a, (.dmark+2)  
9e15 32 b9 ee			ld (debug_mark+2),a  
9e18 18 03			jr .pastdmark  
9e1a ..			.dmark: db "DUP"  
9e1d f1			.pastdmark: pop af  
9e1e			endm  
# End of macro DMARK
9e1e						CALLMONITOR 
9e1e cd a3 92			call break_point_state  
9e21				endm  
# End of macro CALLMONITOR
9e21					endif 
9e21			 
9e21					FORTH_DSP 
9e21 cd ba 9a			call macro_forth_dsp 
9e24				endm 
# End of macro FORTH_DSP
9e24			 
9e24 7e					ld a, (HL) 
9e25 fe 01				cp DS_TYPE_STR 
9e27 20 25				jr nz, .dupinum 
9e29			 
9e29					; push another string 
9e29			 
9e29					FORTH_DSP_VALUEHL     		 
9e29 cd f4 9a			call macro_dsp_valuehl 
9e2c				endm 
# End of macro FORTH_DSP_VALUEHL
9e2c			 
9e2c				if DEBUG_FORTH_WORDS 
9e2c					DMARK "DUs" 
9e2c f5				push af  
9e2d 3a 41 9e			ld a, (.dmark)  
9e30 32 b7 ee			ld (debug_mark),a  
9e33 3a 42 9e			ld a, (.dmark+1)  
9e36 32 b8 ee			ld (debug_mark+1),a  
9e39 3a 43 9e			ld a, (.dmark+2)  
9e3c 32 b9 ee			ld (debug_mark+2),a  
9e3f 18 03			jr .pastdmark  
9e41 ..			.dmark: db "DUs"  
9e44 f1			.pastdmark: pop af  
9e45			endm  
# End of macro DMARK
9e45					CALLMONITOR 
9e45 cd a3 92			call break_point_state  
9e48				endm  
# End of macro CALLMONITOR
9e48				endif 
9e48 cd 6b 99				call forth_push_str 
9e4b			 
9e4b					NEXTW 
9e4b c3 66 9c			jp macro_next 
9e4e				endm 
# End of macro NEXTW
9e4e			 
9e4e			 
9e4e			.dupinum: 
9e4e					 
9e4e			 
9e4e			 
9e4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e4e cd f4 9a			call macro_dsp_valuehl 
9e51				endm 
# End of macro FORTH_DSP_VALUEHL
9e51			 
9e51				; TODO add floating point number detection 
9e51			 
9e51				if DEBUG_FORTH_WORDS 
9e51					DMARK "DUi" 
9e51 f5				push af  
9e52 3a 66 9e			ld a, (.dmark)  
9e55 32 b7 ee			ld (debug_mark),a  
9e58 3a 67 9e			ld a, (.dmark+1)  
9e5b 32 b8 ee			ld (debug_mark+1),a  
9e5e 3a 68 9e			ld a, (.dmark+2)  
9e61 32 b9 ee			ld (debug_mark+2),a  
9e64 18 03			jr .pastdmark  
9e66 ..			.dmark: db "DUi"  
9e69 f1			.pastdmark: pop af  
9e6a			endm  
# End of macro DMARK
9e6a					CALLMONITOR 
9e6a cd a3 92			call break_point_state  
9e6d				endm  
# End of macro CALLMONITOR
9e6d				endif 
9e6d			 
9e6d cd fd 98				call forth_push_numhl 
9e70					NEXTW 
9e70 c3 66 9c			jp macro_next 
9e73				endm 
# End of macro NEXTW
9e73			.ZDUP: 
9e73				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9e73 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9e74 ab 9e			dw .SWAP            
9e76 05				db 4 + 1 
9e77 .. 00			db "?DUP",0              
9e7c				endm 
# End of macro CWHEAD
9e7c			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9e7c			 
9e7c					if DEBUG_FORTH_WORDS_KEY 
9e7c						DMARK "qDU" 
9e7c f5				push af  
9e7d 3a 91 9e			ld a, (.dmark)  
9e80 32 b7 ee			ld (debug_mark),a  
9e83 3a 92 9e			ld a, (.dmark+1)  
9e86 32 b8 ee			ld (debug_mark+1),a  
9e89 3a 93 9e			ld a, (.dmark+2)  
9e8c 32 b9 ee			ld (debug_mark+2),a  
9e8f 18 03			jr .pastdmark  
9e91 ..			.dmark: db "qDU"  
9e94 f1			.pastdmark: pop af  
9e95			endm  
# End of macro DMARK
9e95						CALLMONITOR 
9e95 cd a3 92			call break_point_state  
9e98				endm  
# End of macro CALLMONITOR
9e98					endif 
9e98					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e98 cd f4 9a			call macro_dsp_valuehl 
9e9b				endm 
# End of macro FORTH_DSP_VALUEHL
9e9b			 
9e9b e5					push hl 
9e9c			 
9e9c					; is it a zero? 
9e9c			 
9e9c 3e 00				ld a, 0 
9e9e 84					add h 
9e9f 85					add l 
9ea0			 
9ea0 e1					pop hl 
9ea1			 
9ea1 fe 00				cp 0 
9ea3 28 03				jr z, .dup2orig 
9ea5			 
9ea5			 
9ea5 cd fd 98				call forth_push_numhl 
9ea8			 
9ea8			 
9ea8				; TODO add floating point number detection 
9ea8			 
9ea8			.dup2orig: 
9ea8			 
9ea8					NEXTW 
9ea8 c3 66 9c			jp macro_next 
9eab				endm 
# End of macro NEXTW
9eab			.SWAP: 
9eab				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9eab 18				db WORD_SYS_CORE+OPCODE_SWAP             
9eac ea 9e			dw .COLN            
9eae 05				db 4 + 1 
9eaf .. 00			db "SWAP",0              
9eb4				endm 
# End of macro CWHEAD
9eb4			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9eb4					if DEBUG_FORTH_WORDS_KEY 
9eb4						DMARK "SWP" 
9eb4 f5				push af  
9eb5 3a c9 9e			ld a, (.dmark)  
9eb8 32 b7 ee			ld (debug_mark),a  
9ebb 3a ca 9e			ld a, (.dmark+1)  
9ebe 32 b8 ee			ld (debug_mark+1),a  
9ec1 3a cb 9e			ld a, (.dmark+2)  
9ec4 32 b9 ee			ld (debug_mark+2),a  
9ec7 18 03			jr .pastdmark  
9ec9 ..			.dmark: db "SWP"  
9ecc f1			.pastdmark: pop af  
9ecd			endm  
# End of macro DMARK
9ecd						CALLMONITOR 
9ecd cd a3 92			call break_point_state  
9ed0				endm  
# End of macro CALLMONITOR
9ed0					endif 
9ed0			 
9ed0					FORTH_DSP_VALUEHL 
9ed0 cd f4 9a			call macro_dsp_valuehl 
9ed3				endm 
# End of macro FORTH_DSP_VALUEHL
9ed3 e5					push hl     ; w2 
9ed4			 
9ed4					FORTH_DSP_POP 
9ed4 cd ac 9b			call macro_forth_dsp_pop 
9ed7				endm 
# End of macro FORTH_DSP_POP
9ed7			 
9ed7					FORTH_DSP_VALUEHL 
9ed7 cd f4 9a			call macro_dsp_valuehl 
9eda				endm 
# End of macro FORTH_DSP_VALUEHL
9eda			 
9eda					FORTH_DSP_POP 
9eda cd ac 9b			call macro_forth_dsp_pop 
9edd				endm 
# End of macro FORTH_DSP_POP
9edd			 
9edd d1					pop de     ; w2	, hl = w1 
9ede			 
9ede eb					ex de, hl 
9edf d5					push de 
9ee0			 
9ee0 cd fd 98				call forth_push_numhl 
9ee3			 
9ee3 e1					pop hl 
9ee4			 
9ee4 cd fd 98				call forth_push_numhl 
9ee7					 
9ee7			 
9ee7					NEXTW 
9ee7 c3 66 9c			jp macro_next 
9eea				endm 
# End of macro NEXTW
9eea			.COLN: 
9eea				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9eea 19				db WORD_SYS_CORE+OPCODE_COLN             
9eeb 76 a0			dw .SCOLN            
9eed 02				db 1 + 1 
9eee .. 00			db ":",0              
9ef0				endm 
# End of macro CWHEAD
9ef0			; | : ( -- )         Create new word | DONE 
9ef0			 
9ef0					if DEBUG_FORTH_WORDS_KEY 
9ef0						DMARK "CLN" 
9ef0 f5				push af  
9ef1 3a 05 9f			ld a, (.dmark)  
9ef4 32 b7 ee			ld (debug_mark),a  
9ef7 3a 06 9f			ld a, (.dmark+1)  
9efa 32 b8 ee			ld (debug_mark+1),a  
9efd 3a 07 9f			ld a, (.dmark+2)  
9f00 32 b9 ee			ld (debug_mark+2),a  
9f03 18 03			jr .pastdmark  
9f05 ..			.dmark: db "CLN"  
9f08 f1			.pastdmark: pop af  
9f09			endm  
# End of macro DMARK
9f09						CALLMONITOR 
9f09 cd a3 92			call break_point_state  
9f0c				endm  
# End of macro CALLMONITOR
9f0c					endif 
9f0c				STACKFRAME OFF $8efe $989f 
9f0c				if DEBUG_STACK_IMB 
9f0c					if OFF 
9f0c						exx 
9f0c						ld de, $8efe 
9f0c						ld a, d 
9f0c						ld hl, curframe 
9f0c						call hexout 
9f0c						ld a, e 
9f0c						ld hl, curframe+2 
9f0c						call hexout 
9f0c						ld hl, $8efe 
9f0c						push hl 
9f0c						ld hl, $989f 
9f0c						push hl 
9f0c						exx 
9f0c					endif 
9f0c				endif 
9f0c			endm 
# End of macro STACKFRAME
9f0c				; get parser buffer length  of new word 
9f0c			 
9f0c				 
9f0c			 
9f0c					; move tok past this to start of name defintition 
9f0c					; TODO get word to define 
9f0c					; TODO Move past word token 
9f0c					; TODO get length of string up to the ';' 
9f0c			 
9f0c 2a de e7			ld hl, (os_tok_ptr) 
9f0f 23				inc hl 
9f10 23				inc hl 
9f11			 
9f11 3e 3b			ld a, ';' 
9f13 cd 0b 8f			call strlent 
9f16			 
9f16 7d				ld a,l 
9f17 32 d9 e4			ld (os_new_parse_len), a 
9f1a			 
9f1a			 
9f1a			if DEBUG_FORTH_UWORD 
9f1a ed 5b de e7		ld de, (os_tok_ptr) 
9f1e						DMARK ":01" 
9f1e f5				push af  
9f1f 3a 33 9f			ld a, (.dmark)  
9f22 32 b7 ee			ld (debug_mark),a  
9f25 3a 34 9f			ld a, (.dmark+1)  
9f28 32 b8 ee			ld (debug_mark+1),a  
9f2b 3a 35 9f			ld a, (.dmark+2)  
9f2e 32 b9 ee			ld (debug_mark+2),a  
9f31 18 03			jr .pastdmark  
9f33 ..			.dmark: db ":01"  
9f36 f1			.pastdmark: pop af  
9f37			endm  
# End of macro DMARK
9f37				CALLMONITOR 
9f37 cd a3 92			call break_point_state  
9f3a				endm  
# End of macro CALLMONITOR
9f3a			endif 
9f3a			 
9f3a			; 
9f3a			;  new word memory layout: 
9f3a			;  
9f3a			;    : adg 6666 ;  
9f3a			; 
9f3a			;    db   1     ; user defined word  
9f3a 23				inc hl    
9f3b			;    dw   sysdict 
9f3b 23				inc hl 
9f3c 23				inc hl 
9f3d			;    db <word len>+1 (for null) 
9f3d 23				inc hl 
9f3e			;    db .... <word> 
9f3e			; 
9f3e			 
9f3e 23				inc hl    ; some extras for the word preamble before the above 
9f3f 23				inc hl 
9f40 23				inc hl 
9f41 23				inc hl 
9f42 23				inc hl 
9f43 23				inc hl 
9f44 23				inc hl  
9f45 23				inc hl 
9f46 23				inc hl 
9f47 23				inc hl 
9f48 23				inc hl 
9f49 23				inc hl 
9f4a 23				inc hl 
9f4b 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9f4c			;       exec word buffer 
9f4c			;	<ptr word>   
9f4c 23				inc hl 
9f4d 23				inc hl 
9f4e			;       <word list><null term> 7F final term 
9f4e			 
9f4e			 
9f4e			if DEBUG_FORTH_UWORD 
9f4e						DMARK ":02" 
9f4e f5				push af  
9f4f 3a 63 9f			ld a, (.dmark)  
9f52 32 b7 ee			ld (debug_mark),a  
9f55 3a 64 9f			ld a, (.dmark+1)  
9f58 32 b8 ee			ld (debug_mark+1),a  
9f5b 3a 65 9f			ld a, (.dmark+2)  
9f5e 32 b9 ee			ld (debug_mark+2),a  
9f61 18 03			jr .pastdmark  
9f63 ..			.dmark: db ":02"  
9f66 f1			.pastdmark: pop af  
9f67			endm  
# End of macro DMARK
9f67				CALLMONITOR 
9f67 cd a3 92			call break_point_state  
9f6a				endm  
# End of macro CALLMONITOR
9f6a			endif 
9f6a			 
9f6a				 
9f6a					; malloc the size 
9f6a			 
9f6a cd 69 8f				call malloc 
9f6d 22 db e4				ld (os_new_malloc), hl     ; save malloc start 
9f70			 
9f70			;    db   1     ; user defined word  
9f70 3e 01				ld a, WORD_SYS_UWORD  
9f72 77					ld (hl), a 
9f73				 
9f73 23				inc hl    
9f74			;    dw   sysdict 
9f74 11 be 9d			ld de, sysdict       ; continue on with the scan to the system dict 
9f77 73				ld (hl), e 
9f78 23				inc hl 
9f79 72				ld (hl), d 
9f7a 23				inc hl 
9f7b			 
9f7b			 
9f7b			;    Setup dict word 
9f7b			 
9f7b 23				inc hl 
9f7c 22 d5 e4			ld (os_new_work_ptr), hl     ; save start of dict word  
9f7f			 
9f7f				; 1. get length of dict word 
9f7f			 
9f7f			 
9f7f 2a de e7			ld hl, (os_tok_ptr) 
9f82 23				inc hl 
9f83 23				inc hl    ; position to start of dict word 
9f84 3e 00			ld a, 0 
9f86 cd 0b 8f			call strlent 
9f89			 
9f89			 
9f89 23				inc hl    ; to include null??? 
9f8a			 
9f8a				; write length of dict word 
9f8a			 
9f8a ed 5b d5 e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f8e 1b				dec de 
9f8f eb				ex de, hl 
9f90 73				ld (hl), e 
9f91 eb				ex de, hl 
9f92			 
9f92				 
9f92			 
9f92				; copy  
9f92 4d				ld c, l 
9f93 06 00			ld b, 0 
9f95 ed 5b d5 e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f99 2a de e7			ld hl, (os_tok_ptr) 
9f9c 23				inc hl 
9f9d 23				inc hl    ; position to start of dict word 
9f9e				 
9f9e			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9f9e				 
9f9e				; TODO need to convert word to upper case 
9f9e			 
9f9e			ucasetok:	 
9f9e 7e				ld a,(hl) 
9f9f cd f7 8e			call toUpper 
9fa2 77				ld (hl),a 
9fa3 ed a0			ldi 
9fa5 f2 9e 9f		 	jp p, ucasetok 
9fa8			 
9fa8			 
9fa8			 
9fa8				; de now points to start of where the word body code should be placed 
9fa8 ed 53 d5 e4		ld (os_new_work_ptr), de 
9fac				; hl now points to the words to throw at forthexec which needs to be copied 
9fac 22 d3 e4			ld (os_new_src_ptr), hl 
9faf			 
9faf				; TODO add 'call to forthexec' 
9faf			 
9faf			if DEBUG_FORTH_UWORD 
9faf c5				push bc 
9fb0 ed 4b db e4		ld bc, (os_new_malloc) 
9fb4						DMARK ":0x" 
9fb4 f5				push af  
9fb5 3a c9 9f			ld a, (.dmark)  
9fb8 32 b7 ee			ld (debug_mark),a  
9fbb 3a ca 9f			ld a, (.dmark+1)  
9fbe 32 b8 ee			ld (debug_mark+1),a  
9fc1 3a cb 9f			ld a, (.dmark+2)  
9fc4 32 b9 ee			ld (debug_mark+2),a  
9fc7 18 03			jr .pastdmark  
9fc9 ..			.dmark: db ":0x"  
9fcc f1			.pastdmark: pop af  
9fcd			endm  
# End of macro DMARK
9fcd				CALLMONITOR 
9fcd cd a3 92			call break_point_state  
9fd0				endm  
# End of macro CALLMONITOR
9fd0 c1				pop bc 
9fd1			endif 
9fd1			 
9fd1			 
9fd1				; create word preamble which should be: 
9fd1			 
9fd1			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9fd1			 
9fd1				;    ld hl, <word code> 
9fd1				;    jp user_exec 
9fd1			        ;    <word code bytes> 
9fd1			 
9fd1			 
9fd1			;	inc de     ; TODO ??? or are we already past the word's null 
9fd1 eb				ex de, hl 
9fd2			 
9fd2 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9fd4			 
9fd4 23				inc hl 
9fd5 22 cf e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9fd8 23				inc hl 
9fd9			 
9fd9 23				inc hl 
9fda 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9fdc			 
9fdc 01 c6 c3			ld bc, user_exec 
9fdf 23				inc hl 
9fe0 71				ld (hl), c     ; poke address of user_exec 
9fe1 23				inc hl 
9fe2 70				ld (hl), b     
9fe3			 ; 
9fe3			;	inc hl 
9fe3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fe3			; 
9fe3			; 
9fe3			;	ld bc, macro_forth_rsp_next 
9fe3			;	inc hl 
9fe3			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9fe3			;	inc hl 
9fe3			;	ld (hl), b     
9fe3			 ; 
9fe3			;	inc hl 
9fe3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fe3			; 
9fe3			; 
9fe3			;	inc hl 
9fe3			;	ld bc, forthexec 
9fe3			;	ld (hl), c     ; poke address of forthexec 
9fe3			;	inc hl 
9fe3			;	ld (hl), b      
9fe3			; 
9fe3			;	inc hl 
9fe3			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9fe3			; 
9fe3			;	ld bc, user_dict_next 
9fe3			;	inc hl 
9fe3			;	ld (hl), c     ; poke address of forthexec 
9fe3			;	inc hl 
9fe3			;	ld (hl), b      
9fe3			 
9fe3				; hl is now where we need to copy the word byte data to save this 
9fe3			 
9fe3 23				inc hl 
9fe4 22 d1 e4			ld (os_new_exec), hl 
9fe7				 
9fe7				; copy definition 
9fe7			 
9fe7 eb				ex de, hl 
9fe8			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9fe8			;	inc de    ; skip the PC for this parse 
9fe8 3a d9 e4			ld a, (os_new_parse_len) 
9feb 4f				ld c, a 
9fec 06 00			ld b, 0 
9fee ed b0			ldir		 ; copy defintion 
9ff0			 
9ff0			 
9ff0				; poke the address of where the new word bytes live for forthexec 
9ff0			 
9ff0 2a cf e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9ff3			 
9ff3 ed 5b d1 e4		ld de, (os_new_exec)      
9ff7				 
9ff7 73				ld (hl), e 
9ff8 23				inc hl 
9ff9 72				ld (hl), d 
9ffa			 
9ffa					; TODO copy last user dict word next link to this word 
9ffa					; TODO update last user dict word to point to this word 
9ffa			; 
9ffa			; hl f923 de 812a ; bc 811a 
9ffa			 
9ffa			if DEBUG_FORTH_UWORD 
9ffa c5				push bc 
9ffb ed 4b db e4		ld bc, (os_new_malloc) 
9fff						DMARK ":0A" 
9fff f5				push af  
a000 3a 14 a0			ld a, (.dmark)  
a003 32 b7 ee			ld (debug_mark),a  
a006 3a 15 a0			ld a, (.dmark+1)  
a009 32 b8 ee			ld (debug_mark+1),a  
a00c 3a 16 a0			ld a, (.dmark+2)  
a00f 32 b9 ee			ld (debug_mark+2),a  
a012 18 03			jr .pastdmark  
a014 ..			.dmark: db ":0A"  
a017 f1			.pastdmark: pop af  
a018			endm  
# End of macro DMARK
a018				CALLMONITOR 
a018 cd a3 92			call break_point_state  
a01b				endm  
# End of macro CALLMONITOR
a01b c1				pop bc 
a01c			endif 
a01c			if DEBUG_FORTH_UWORD 
a01c c5				push bc 
a01d ed 4b db e4		ld bc, (os_new_malloc) 
a021 03				inc bc 
a022 03				inc bc 
a023 03				inc bc 
a024 03				inc bc 
a025 03				inc bc 
a026 03				inc bc 
a027 03				inc bc 
a028 03				inc bc 
a029			 
a029						DMARK ":0B" 
a029 f5				push af  
a02a 3a 3e a0			ld a, (.dmark)  
a02d 32 b7 ee			ld (debug_mark),a  
a030 3a 3f a0			ld a, (.dmark+1)  
a033 32 b8 ee			ld (debug_mark+1),a  
a036 3a 40 a0			ld a, (.dmark+2)  
a039 32 b9 ee			ld (debug_mark+2),a  
a03c 18 03			jr .pastdmark  
a03e ..			.dmark: db ":0B"  
a041 f1			.pastdmark: pop af  
a042			endm  
# End of macro DMARK
a042				CALLMONITOR 
a042 cd a3 92			call break_point_state  
a045				endm  
# End of macro CALLMONITOR
a045 c1				pop bc 
a046			endif 
a046			 
a046			; update word dict linked list for new word 
a046			 
a046			 
a046 2a da e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a049 23			inc hl     ; move to next work linked list ptr 
a04a			 
a04a ed 5b db e4	ld de, (os_new_malloc)		 ; new next word 
a04e 73			ld (hl), e 
a04f 23			inc hl 
a050 72			ld (hl), d 
a051			 
a051			if DEBUG_FORTH_UWORD 
a051 ed 4b da e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a055			endif 
a055			 
a055 ed 53 da e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a059			 
a059			 
a059			if DEBUG_FORTH_UWORD 
a059						DMARK ":0+" 
a059 f5				push af  
a05a 3a 6e a0			ld a, (.dmark)  
a05d 32 b7 ee			ld (debug_mark),a  
a060 3a 6f a0			ld a, (.dmark+1)  
a063 32 b8 ee			ld (debug_mark+1),a  
a066 3a 70 a0			ld a, (.dmark+2)  
a069 32 b9 ee			ld (debug_mark+2),a  
a06c 18 03			jr .pastdmark  
a06e ..			.dmark: db ":0+"  
a071 f1			.pastdmark: pop af  
a072			endm  
# End of macro DMARK
a072				CALLMONITOR 
a072 cd a3 92			call break_point_state  
a075				endm  
# End of macro CALLMONITOR
a075			endif 
a075			 
a075				STACKFRAMECHK OFF $8efe $989f 
a075				if DEBUG_STACK_IMB 
a075					if OFF 
a075						exx 
a075						ld hl, $989f 
a075						pop de   ; $989f 
a075						call cmp16 
a075						jr nz, .spnosame 
a075						ld hl, $8efe 
a075						pop de   ; $8efe 
a075						call cmp16 
a075						jr z, .spfrsame 
a075						.spnosame: call showsperror 
a075						.spfrsame: nop 
a075						exx 
a075					endif 
a075				endif 
a075			endm 
# End of macro STACKFRAMECHK
a075			 
a075 c9			ret    ; dont process any remaining parser tokens as they form new word 
a076			 
a076			 
a076			 
a076			 
a076			;		NEXT 
a076			.SCOLN: 
a076			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a076 06				db OPCODE_SCOLN 
a077 c2 a0			dw .DROP 
a079 02				db 2 
a07a .. 00			db ";",0           
a07c			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a07c					if DEBUG_FORTH_WORDS_KEY 
a07c						DMARK "SCN" 
a07c f5				push af  
a07d 3a 91 a0			ld a, (.dmark)  
a080 32 b7 ee			ld (debug_mark),a  
a083 3a 92 a0			ld a, (.dmark+1)  
a086 32 b8 ee			ld (debug_mark+1),a  
a089 3a 93 a0			ld a, (.dmark+2)  
a08c 32 b9 ee			ld (debug_mark+2),a  
a08f 18 03			jr .pastdmark  
a091 ..			.dmark: db "SCN"  
a094 f1			.pastdmark: pop af  
a095			endm  
# End of macro DMARK
a095						CALLMONITOR 
a095 cd a3 92			call break_point_state  
a098				endm  
# End of macro CALLMONITOR
a098					endif 
a098					FORTH_RSP_TOS 
a098 cd bb 98			call macro_forth_rsp_tos 
a09b				endm 
# End of macro FORTH_RSP_TOS
a09b e5					push hl 
a09c					FORTH_RSP_POP 
a09c cd c5 98			call macro_forth_rsp_pop 
a09f				endm 
# End of macro FORTH_RSP_POP
a09f e1					pop hl 
a0a0			;		ex de,hl 
a0a0 22 de e7				ld (os_tok_ptr),hl 
a0a3			 
a0a3			if DEBUG_FORTH_UWORD 
a0a3						DMARK "SCL" 
a0a3 f5				push af  
a0a4 3a b8 a0			ld a, (.dmark)  
a0a7 32 b7 ee			ld (debug_mark),a  
a0aa 3a b9 a0			ld a, (.dmark+1)  
a0ad 32 b8 ee			ld (debug_mark+1),a  
a0b0 3a ba a0			ld a, (.dmark+2)  
a0b3 32 b9 ee			ld (debug_mark+2),a  
a0b6 18 03			jr .pastdmark  
a0b8 ..			.dmark: db "SCL"  
a0bb f1			.pastdmark: pop af  
a0bc			endm  
# End of macro DMARK
a0bc				CALLMONITOR 
a0bc cd a3 92			call break_point_state  
a0bf				endm  
# End of macro CALLMONITOR
a0bf			endif 
a0bf					NEXTW 
a0bf c3 66 9c			jp macro_next 
a0c2				endm 
# End of macro NEXTW
a0c2			 
a0c2			.DROP: 
a0c2				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a0c2 1b				db WORD_SYS_CORE+OPCODE_DROP             
a0c3 ed a0			dw .DUP2            
a0c5 05				db 4 + 1 
a0c6 .. 00			db "DROP",0              
a0cb				endm 
# End of macro CWHEAD
a0cb			; | DROP ( w -- )   drop the TOS item   | DONE 
a0cb					if DEBUG_FORTH_WORDS_KEY 
a0cb						DMARK "DRP" 
a0cb f5				push af  
a0cc 3a e0 a0			ld a, (.dmark)  
a0cf 32 b7 ee			ld (debug_mark),a  
a0d2 3a e1 a0			ld a, (.dmark+1)  
a0d5 32 b8 ee			ld (debug_mark+1),a  
a0d8 3a e2 a0			ld a, (.dmark+2)  
a0db 32 b9 ee			ld (debug_mark+2),a  
a0de 18 03			jr .pastdmark  
a0e0 ..			.dmark: db "DRP"  
a0e3 f1			.pastdmark: pop af  
a0e4			endm  
# End of macro DMARK
a0e4						CALLMONITOR 
a0e4 cd a3 92			call break_point_state  
a0e7				endm  
# End of macro CALLMONITOR
a0e7					endif 
a0e7					FORTH_DSP_POP 
a0e7 cd ac 9b			call macro_forth_dsp_pop 
a0ea				endm 
# End of macro FORTH_DSP_POP
a0ea					NEXTW 
a0ea c3 66 9c			jp macro_next 
a0ed				endm 
# End of macro NEXTW
a0ed			.DUP2: 
a0ed				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a0ed 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a0ee 32 a1			dw .DROP2            
a0f0 05				db 4 + 1 
a0f1 .. 00			db "2DUP",0              
a0f6				endm 
# End of macro CWHEAD
a0f6			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a0f6					if DEBUG_FORTH_WORDS_KEY 
a0f6						DMARK "2DU" 
a0f6 f5				push af  
a0f7 3a 0b a1			ld a, (.dmark)  
a0fa 32 b7 ee			ld (debug_mark),a  
a0fd 3a 0c a1			ld a, (.dmark+1)  
a100 32 b8 ee			ld (debug_mark+1),a  
a103 3a 0d a1			ld a, (.dmark+2)  
a106 32 b9 ee			ld (debug_mark+2),a  
a109 18 03			jr .pastdmark  
a10b ..			.dmark: db "2DU"  
a10e f1			.pastdmark: pop af  
a10f			endm  
# End of macro DMARK
a10f						CALLMONITOR 
a10f cd a3 92			call break_point_state  
a112				endm  
# End of macro CALLMONITOR
a112					endif 
a112					FORTH_DSP_VALUEHL 
a112 cd f4 9a			call macro_dsp_valuehl 
a115				endm 
# End of macro FORTH_DSP_VALUEHL
a115 e5					push hl      ; 2 
a116			 
a116					FORTH_DSP_POP 
a116 cd ac 9b			call macro_forth_dsp_pop 
a119				endm 
# End of macro FORTH_DSP_POP
a119					 
a119					FORTH_DSP_VALUEHL 
a119 cd f4 9a			call macro_dsp_valuehl 
a11c				endm 
# End of macro FORTH_DSP_VALUEHL
a11c			;		push hl      ; 1 
a11c			 
a11c					FORTH_DSP_POP 
a11c cd ac 9b			call macro_forth_dsp_pop 
a11f				endm 
# End of macro FORTH_DSP_POP
a11f			 
a11f			;		pop hl       ; 1 
a11f d1					pop de       ; 2 
a120			 
a120 cd fd 98				call forth_push_numhl 
a123 eb					ex de, hl 
a124 cd fd 98				call forth_push_numhl 
a127			 
a127					 
a127 eb					ex de, hl 
a128			 
a128 cd fd 98				call forth_push_numhl 
a12b eb					ex de, hl 
a12c cd fd 98				call forth_push_numhl 
a12f			 
a12f			 
a12f					NEXTW 
a12f c3 66 9c			jp macro_next 
a132				endm 
# End of macro NEXTW
a132			.DROP2: 
a132				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a132 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a133 61 a1			dw .SWAP2            
a135 06				db 5 + 1 
a136 .. 00			db "2DROP",0              
a13c				endm 
# End of macro CWHEAD
a13c			; | 2DROP ( w w -- )    Double drop | DONE 
a13c					if DEBUG_FORTH_WORDS_KEY 
a13c						DMARK "2DR" 
a13c f5				push af  
a13d 3a 51 a1			ld a, (.dmark)  
a140 32 b7 ee			ld (debug_mark),a  
a143 3a 52 a1			ld a, (.dmark+1)  
a146 32 b8 ee			ld (debug_mark+1),a  
a149 3a 53 a1			ld a, (.dmark+2)  
a14c 32 b9 ee			ld (debug_mark+2),a  
a14f 18 03			jr .pastdmark  
a151 ..			.dmark: db "2DR"  
a154 f1			.pastdmark: pop af  
a155			endm  
# End of macro DMARK
a155						CALLMONITOR 
a155 cd a3 92			call break_point_state  
a158				endm  
# End of macro CALLMONITOR
a158					endif 
a158					FORTH_DSP_POP 
a158 cd ac 9b			call macro_forth_dsp_pop 
a15b				endm 
# End of macro FORTH_DSP_POP
a15b					FORTH_DSP_POP 
a15b cd ac 9b			call macro_forth_dsp_pop 
a15e				endm 
# End of macro FORTH_DSP_POP
a15e					NEXTW 
a15e c3 66 9c			jp macro_next 
a161				endm 
# End of macro NEXTW
a161			.SWAP2: 
a161				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a161 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a162 8a a1			dw .AT            
a164 06				db 5 + 1 
a165 .. 00			db "2SWAP",0              
a16b				endm 
# End of macro CWHEAD
a16b			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a16b					if DEBUG_FORTH_WORDS_KEY 
a16b						DMARK "2SW" 
a16b f5				push af  
a16c 3a 80 a1			ld a, (.dmark)  
a16f 32 b7 ee			ld (debug_mark),a  
a172 3a 81 a1			ld a, (.dmark+1)  
a175 32 b8 ee			ld (debug_mark+1),a  
a178 3a 82 a1			ld a, (.dmark+2)  
a17b 32 b9 ee			ld (debug_mark+2),a  
a17e 18 03			jr .pastdmark  
a180 ..			.dmark: db "2SW"  
a183 f1			.pastdmark: pop af  
a184			endm  
# End of macro DMARK
a184						CALLMONITOR 
a184 cd a3 92			call break_point_state  
a187				endm  
# End of macro CALLMONITOR
a187					endif 
a187					NEXTW 
a187 c3 66 9c			jp macro_next 
a18a				endm 
# End of macro NEXTW
a18a			.AT: 
a18a				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a18a 1f				db WORD_SYS_CORE+OPCODE_AT             
a18b bc a1			dw .CAT            
a18d 02				db 1 + 1 
a18e .. 00			db "@",0              
a190				endm 
# End of macro CWHEAD
a190			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a190			 
a190					if DEBUG_FORTH_WORDS_KEY 
a190						DMARK "AT." 
a190 f5				push af  
a191 3a a5 a1			ld a, (.dmark)  
a194 32 b7 ee			ld (debug_mark),a  
a197 3a a6 a1			ld a, (.dmark+1)  
a19a 32 b8 ee			ld (debug_mark+1),a  
a19d 3a a7 a1			ld a, (.dmark+2)  
a1a0 32 b9 ee			ld (debug_mark+2),a  
a1a3 18 03			jr .pastdmark  
a1a5 ..			.dmark: db "AT."  
a1a8 f1			.pastdmark: pop af  
a1a9			endm  
# End of macro DMARK
a1a9						CALLMONITOR 
a1a9 cd a3 92			call break_point_state  
a1ac				endm  
# End of macro CALLMONITOR
a1ac					endif 
a1ac			.getbyteat:	 
a1ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1ac cd f4 9a			call macro_dsp_valuehl 
a1af				endm 
# End of macro FORTH_DSP_VALUEHL
a1af					 
a1af			;		push hl 
a1af				 
a1af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1af cd ac 9b			call macro_forth_dsp_pop 
a1b2				endm 
# End of macro FORTH_DSP_POP
a1b2			 
a1b2			;		pop hl 
a1b2			 
a1b2 7e					ld a, (hl) 
a1b3			 
a1b3 6f					ld l, a 
a1b4 26 00				ld h, 0 
a1b6 cd fd 98				call forth_push_numhl 
a1b9			 
a1b9					NEXTW 
a1b9 c3 66 9c			jp macro_next 
a1bc				endm 
# End of macro NEXTW
a1bc			.CAT: 
a1bc				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a1bc 20				db WORD_SYS_CORE+OPCODE_CAT             
a1bd e5 a1			dw .BANG            
a1bf 03				db 2 + 1 
a1c0 .. 00			db "C@",0              
a1c3				endm 
# End of macro CWHEAD
a1c3			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a1c3					if DEBUG_FORTH_WORDS_KEY 
a1c3						DMARK "CAA" 
a1c3 f5				push af  
a1c4 3a d8 a1			ld a, (.dmark)  
a1c7 32 b7 ee			ld (debug_mark),a  
a1ca 3a d9 a1			ld a, (.dmark+1)  
a1cd 32 b8 ee			ld (debug_mark+1),a  
a1d0 3a da a1			ld a, (.dmark+2)  
a1d3 32 b9 ee			ld (debug_mark+2),a  
a1d6 18 03			jr .pastdmark  
a1d8 ..			.dmark: db "CAA"  
a1db f1			.pastdmark: pop af  
a1dc			endm  
# End of macro DMARK
a1dc						CALLMONITOR 
a1dc cd a3 92			call break_point_state  
a1df				endm  
# End of macro CALLMONITOR
a1df					endif 
a1df c3 ac a1				jp .getbyteat 
a1e2					NEXTW 
a1e2 c3 66 9c			jp macro_next 
a1e5				endm 
# End of macro NEXTW
a1e5			.BANG: 
a1e5				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a1e5 21				db WORD_SYS_CORE+OPCODE_BANG             
a1e6 1b a2			dw .CBANG            
a1e8 02				db 1 + 1 
a1e9 .. 00			db "!",0              
a1eb				endm 
# End of macro CWHEAD
a1eb			; | ! ( x w -- ) Store x at address w      | DONE 
a1eb					if DEBUG_FORTH_WORDS_KEY 
a1eb						DMARK "BNG" 
a1eb f5				push af  
a1ec 3a 00 a2			ld a, (.dmark)  
a1ef 32 b7 ee			ld (debug_mark),a  
a1f2 3a 01 a2			ld a, (.dmark+1)  
a1f5 32 b8 ee			ld (debug_mark+1),a  
a1f8 3a 02 a2			ld a, (.dmark+2)  
a1fb 32 b9 ee			ld (debug_mark+2),a  
a1fe 18 03			jr .pastdmark  
a200 ..			.dmark: db "BNG"  
a203 f1			.pastdmark: pop af  
a204			endm  
# End of macro DMARK
a204						CALLMONITOR 
a204 cd a3 92			call break_point_state  
a207				endm  
# End of macro CALLMONITOR
a207					endif 
a207			 
a207			.storebyteat:		 
a207					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a207 cd f4 9a			call macro_dsp_valuehl 
a20a				endm 
# End of macro FORTH_DSP_VALUEHL
a20a					 
a20a e5					push hl 
a20b				 
a20b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a20b cd ac 9b			call macro_forth_dsp_pop 
a20e				endm 
# End of macro FORTH_DSP_POP
a20e			 
a20e					; get byte to poke 
a20e			 
a20e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a20e cd f4 9a			call macro_dsp_valuehl 
a211				endm 
# End of macro FORTH_DSP_VALUEHL
a211 e5					push hl 
a212			 
a212			 
a212					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a212 cd ac 9b			call macro_forth_dsp_pop 
a215				endm 
# End of macro FORTH_DSP_POP
a215			 
a215			 
a215 d1					pop de 
a216 e1					pop hl 
a217			 
a217 73					ld (hl),e 
a218			 
a218			 
a218					NEXTW 
a218 c3 66 9c			jp macro_next 
a21b				endm 
# End of macro NEXTW
a21b			.CBANG: 
a21b				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a21b 22				db WORD_SYS_CORE+OPCODE_CBANG             
a21c 44 a2			dw .SCALL            
a21e 03				db 2 + 1 
a21f .. 00			db "C!",0              
a222				endm 
# End of macro CWHEAD
a222			; | C!  ( x w -- ) Store x at address w  | DONE 
a222					if DEBUG_FORTH_WORDS_KEY 
a222						DMARK "CBA" 
a222 f5				push af  
a223 3a 37 a2			ld a, (.dmark)  
a226 32 b7 ee			ld (debug_mark),a  
a229 3a 38 a2			ld a, (.dmark+1)  
a22c 32 b8 ee			ld (debug_mark+1),a  
a22f 3a 39 a2			ld a, (.dmark+2)  
a232 32 b9 ee			ld (debug_mark+2),a  
a235 18 03			jr .pastdmark  
a237 ..			.dmark: db "CBA"  
a23a f1			.pastdmark: pop af  
a23b			endm  
# End of macro DMARK
a23b						CALLMONITOR 
a23b cd a3 92			call break_point_state  
a23e				endm  
# End of macro CALLMONITOR
a23e					endif 
a23e c3 07 a2				jp .storebyteat 
a241					NEXTW 
a241 c3 66 9c			jp macro_next 
a244				endm 
# End of macro NEXTW
a244			.SCALL: 
a244				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a244 23				db WORD_SYS_CORE+OPCODE_SCALL             
a245 78 a2			dw .DEPTH            
a247 05				db 4 + 1 
a248 .. 00			db "CALL",0              
a24d				endm 
# End of macro CWHEAD
a24d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a24d					if DEBUG_FORTH_WORDS_KEY 
a24d						DMARK "CLL" 
a24d f5				push af  
a24e 3a 62 a2			ld a, (.dmark)  
a251 32 b7 ee			ld (debug_mark),a  
a254 3a 63 a2			ld a, (.dmark+1)  
a257 32 b8 ee			ld (debug_mark+1),a  
a25a 3a 64 a2			ld a, (.dmark+2)  
a25d 32 b9 ee			ld (debug_mark+2),a  
a260 18 03			jr .pastdmark  
a262 ..			.dmark: db "CLL"  
a265 f1			.pastdmark: pop af  
a266			endm  
# End of macro DMARK
a266						CALLMONITOR 
a266 cd a3 92			call break_point_state  
a269				endm  
# End of macro CALLMONITOR
a269					endif 
a269			 
a269					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a269 cd f4 9a			call macro_dsp_valuehl 
a26c				endm 
# End of macro FORTH_DSP_VALUEHL
a26c			 
a26c			;		push hl 
a26c			 
a26c					; destroy value TOS 
a26c			 
a26c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a26c cd ac 9b			call macro_forth_dsp_pop 
a26f				endm 
# End of macro FORTH_DSP_POP
a26f			 
a26f						 
a26f			;		pop hl 
a26f			 
a26f					; how to do a call with hl???? save SP? 
a26f cd 0f 9c				call forth_call_hl 
a272			 
a272			 
a272					; TODO push value back onto stack for another op etc 
a272			 
a272 cd fd 98				call forth_push_numhl 
a275					NEXTW 
a275 c3 66 9c			jp macro_next 
a278				endm 
# End of macro NEXTW
a278			.DEPTH: 
a278				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a278 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a279 b5 a2			dw .OVER            
a27b 06				db 5 + 1 
a27c .. 00			db "DEPTH",0              
a282				endm 
# End of macro CWHEAD
a282			; | DEPTH ( -- u ) Push count of stack | DONE 
a282					; take current TOS and remove from base value div by two to get count 
a282					if DEBUG_FORTH_WORDS_KEY 
a282						DMARK "DEP" 
a282 f5				push af  
a283 3a 97 a2			ld a, (.dmark)  
a286 32 b7 ee			ld (debug_mark),a  
a289 3a 98 a2			ld a, (.dmark+1)  
a28c 32 b8 ee			ld (debug_mark+1),a  
a28f 3a 99 a2			ld a, (.dmark+2)  
a292 32 b9 ee			ld (debug_mark+2),a  
a295 18 03			jr .pastdmark  
a297 ..			.dmark: db "DEP"  
a29a f1			.pastdmark: pop af  
a29b			endm  
# End of macro DMARK
a29b						CALLMONITOR 
a29b cd a3 92			call break_point_state  
a29e				endm  
# End of macro CALLMONITOR
a29e					endif 
a29e			 
a29e			 
a29e 2a 8a ec			ld hl, (cli_data_sp) 
a2a1 11 44 ea			ld de, cli_data_stack 
a2a4 ed 52			sbc hl,de 
a2a6				 
a2a6				; div by size of stack item 
a2a6			 
a2a6 5d				ld e,l 
a2a7 0e 03			ld c, 3 
a2a9 cd 32 8a			call Div8 
a2ac			 
a2ac 6f				ld l,a 
a2ad 26 00			ld h,0 
a2af			 
a2af				;srl h 
a2af				;rr l 
a2af			 
a2af cd fd 98				call forth_push_numhl 
a2b2					NEXTW 
a2b2 c3 66 9c			jp macro_next 
a2b5				endm 
# End of macro NEXTW
a2b5			.OVER: 
a2b5				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a2b5 42				db WORD_SYS_CORE+46             
a2b6 fc a2			dw .PAUSE            
a2b8 05				db 4 + 1 
a2b9 .. 00			db "OVER",0              
a2be				endm 
# End of macro CWHEAD
a2be			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a2be					if DEBUG_FORTH_WORDS_KEY 
a2be						DMARK "OVR" 
a2be f5				push af  
a2bf 3a d3 a2			ld a, (.dmark)  
a2c2 32 b7 ee			ld (debug_mark),a  
a2c5 3a d4 a2			ld a, (.dmark+1)  
a2c8 32 b8 ee			ld (debug_mark+1),a  
a2cb 3a d5 a2			ld a, (.dmark+2)  
a2ce 32 b9 ee			ld (debug_mark+2),a  
a2d1 18 03			jr .pastdmark  
a2d3 ..			.dmark: db "OVR"  
a2d6 f1			.pastdmark: pop af  
a2d7			endm  
# End of macro DMARK
a2d7						CALLMONITOR 
a2d7 cd a3 92			call break_point_state  
a2da				endm  
# End of macro CALLMONITOR
a2da					endif 
a2da			 
a2da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2da cd f4 9a			call macro_dsp_valuehl 
a2dd				endm 
# End of macro FORTH_DSP_VALUEHL
a2dd e5					push hl    ; n2 
a2de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2de cd ac 9b			call macro_forth_dsp_pop 
a2e1				endm 
# End of macro FORTH_DSP_POP
a2e1			 
a2e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2e1 cd f4 9a			call macro_dsp_valuehl 
a2e4				endm 
# End of macro FORTH_DSP_VALUEHL
a2e4 e5					push hl    ; n1 
a2e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2e5 cd ac 9b			call macro_forth_dsp_pop 
a2e8				endm 
# End of macro FORTH_DSP_POP
a2e8			 
a2e8 d1					pop de     ; n1 
a2e9 e1					pop hl     ; n2 
a2ea			 
a2ea d5					push de 
a2eb e5					push hl 
a2ec d5					push de 
a2ed			 
a2ed					; push back  
a2ed			 
a2ed e1					pop hl 
a2ee cd fd 98				call forth_push_numhl 
a2f1 e1					pop hl 
a2f2 cd fd 98				call forth_push_numhl 
a2f5 e1					pop hl 
a2f6 cd fd 98				call forth_push_numhl 
a2f9					NEXTW 
a2f9 c3 66 9c			jp macro_next 
a2fc				endm 
# End of macro NEXTW
a2fc			 
a2fc			.PAUSE: 
a2fc				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a2fc 43				db WORD_SYS_CORE+47             
a2fd 31 a3			dw .PAUSES            
a2ff 08				db 7 + 1 
a300 .. 00			db "PAUSEMS",0              
a308				endm 
# End of macro CWHEAD
a308			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a308					if DEBUG_FORTH_WORDS_KEY 
a308						DMARK "PMS" 
a308 f5				push af  
a309 3a 1d a3			ld a, (.dmark)  
a30c 32 b7 ee			ld (debug_mark),a  
a30f 3a 1e a3			ld a, (.dmark+1)  
a312 32 b8 ee			ld (debug_mark+1),a  
a315 3a 1f a3			ld a, (.dmark+2)  
a318 32 b9 ee			ld (debug_mark+2),a  
a31b 18 03			jr .pastdmark  
a31d ..			.dmark: db "PMS"  
a320 f1			.pastdmark: pop af  
a321			endm  
# End of macro DMARK
a321						CALLMONITOR 
a321 cd a3 92			call break_point_state  
a324				endm  
# End of macro CALLMONITOR
a324					endif 
a324					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a324 cd f4 9a			call macro_dsp_valuehl 
a327				endm 
# End of macro FORTH_DSP_VALUEHL
a327			;		push hl    ; n2 
a327					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a327 cd ac 9b			call macro_forth_dsp_pop 
a32a				endm 
# End of macro FORTH_DSP_POP
a32a			;		pop hl 
a32a			 
a32a 7d					ld a, l 
a32b cd d7 87				call aDelayInMS 
a32e				       NEXTW 
a32e c3 66 9c			jp macro_next 
a331				endm 
# End of macro NEXTW
a331			.PAUSES:  
a331				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a331 44				db WORD_SYS_CORE+48             
a332 a0 a3			dw .ROT            
a334 06				db 5 + 1 
a335 .. 00			db "PAUSE",0              
a33b				endm 
# End of macro CWHEAD
a33b			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a33b					if DEBUG_FORTH_WORDS_KEY 
a33b						DMARK "PAU" 
a33b f5				push af  
a33c 3a 50 a3			ld a, (.dmark)  
a33f 32 b7 ee			ld (debug_mark),a  
a342 3a 51 a3			ld a, (.dmark+1)  
a345 32 b8 ee			ld (debug_mark+1),a  
a348 3a 52 a3			ld a, (.dmark+2)  
a34b 32 b9 ee			ld (debug_mark+2),a  
a34e 18 03			jr .pastdmark  
a350 ..			.dmark: db "PAU"  
a353 f1			.pastdmark: pop af  
a354			endm  
# End of macro DMARK
a354						CALLMONITOR 
a354 cd a3 92			call break_point_state  
a357				endm  
# End of macro CALLMONITOR
a357					endif 
a357					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a357 cd f4 9a			call macro_dsp_valuehl 
a35a				endm 
# End of macro FORTH_DSP_VALUEHL
a35a			;		push hl    ; n2 
a35a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a35a cd ac 9b			call macro_forth_dsp_pop 
a35d				endm 
# End of macro FORTH_DSP_POP
a35d			;		pop hl 
a35d 45					ld b, l 
a35e					if DEBUG_FORTH_WORDS 
a35e						DMARK "PAU" 
a35e f5				push af  
a35f 3a 73 a3			ld a, (.dmark)  
a362 32 b7 ee			ld (debug_mark),a  
a365 3a 74 a3			ld a, (.dmark+1)  
a368 32 b8 ee			ld (debug_mark+1),a  
a36b 3a 75 a3			ld a, (.dmark+2)  
a36e 32 b9 ee			ld (debug_mark+2),a  
a371 18 03			jr .pastdmark  
a373 ..			.dmark: db "PAU"  
a376 f1			.pastdmark: pop af  
a377			endm  
# End of macro DMARK
a377						CALLMONITOR 
a377 cd a3 92			call break_point_state  
a37a				endm  
# End of macro CALLMONITOR
a37a					endif 
a37a c5			.pauses1:	push bc 
a37b cd f2 87				call delay1s 
a37e c1					pop bc 
a37f					if DEBUG_FORTH_WORDS 
a37f						DMARK "PA1" 
a37f f5				push af  
a380 3a 94 a3			ld a, (.dmark)  
a383 32 b7 ee			ld (debug_mark),a  
a386 3a 95 a3			ld a, (.dmark+1)  
a389 32 b8 ee			ld (debug_mark+1),a  
a38c 3a 96 a3			ld a, (.dmark+2)  
a38f 32 b9 ee			ld (debug_mark+2),a  
a392 18 03			jr .pastdmark  
a394 ..			.dmark: db "PA1"  
a397 f1			.pastdmark: pop af  
a398			endm  
# End of macro DMARK
a398						CALLMONITOR 
a398 cd a3 92			call break_point_state  
a39b				endm  
# End of macro CALLMONITOR
a39b					endif 
a39b 10 dd				djnz .pauses1 
a39d			 
a39d				       NEXTW 
a39d c3 66 9c			jp macro_next 
a3a0				endm 
# End of macro NEXTW
a3a0			.ROT: 
a3a0				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a3a0 45				db WORD_SYS_CORE+49             
a3a1 ee a3			dw .UWORDS            
a3a3 04				db 3 + 1 
a3a4 .. 00			db "ROT",0              
a3a8				endm 
# End of macro CWHEAD
a3a8			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a3a8					if DEBUG_FORTH_WORDS_KEY 
a3a8						DMARK "ROT" 
a3a8 f5				push af  
a3a9 3a bd a3			ld a, (.dmark)  
a3ac 32 b7 ee			ld (debug_mark),a  
a3af 3a be a3			ld a, (.dmark+1)  
a3b2 32 b8 ee			ld (debug_mark+1),a  
a3b5 3a bf a3			ld a, (.dmark+2)  
a3b8 32 b9 ee			ld (debug_mark+2),a  
a3bb 18 03			jr .pastdmark  
a3bd ..			.dmark: db "ROT"  
a3c0 f1			.pastdmark: pop af  
a3c1			endm  
# End of macro DMARK
a3c1						CALLMONITOR 
a3c1 cd a3 92			call break_point_state  
a3c4				endm  
# End of macro CALLMONITOR
a3c4					endif 
a3c4			 
a3c4					FORTH_DSP_VALUEHL 
a3c4 cd f4 9a			call macro_dsp_valuehl 
a3c7				endm 
# End of macro FORTH_DSP_VALUEHL
a3c7 e5					push hl    ; u3  
a3c8			 
a3c8					FORTH_DSP_POP 
a3c8 cd ac 9b			call macro_forth_dsp_pop 
a3cb				endm 
# End of macro FORTH_DSP_POP
a3cb			   
a3cb					FORTH_DSP_VALUEHL 
a3cb cd f4 9a			call macro_dsp_valuehl 
a3ce				endm 
# End of macro FORTH_DSP_VALUEHL
a3ce e5					push hl     ; u2 
a3cf			 
a3cf					FORTH_DSP_POP 
a3cf cd ac 9b			call macro_forth_dsp_pop 
a3d2				endm 
# End of macro FORTH_DSP_POP
a3d2			 
a3d2					FORTH_DSP_VALUEHL 
a3d2 cd f4 9a			call macro_dsp_valuehl 
a3d5				endm 
# End of macro FORTH_DSP_VALUEHL
a3d5 e5					push hl     ; u1 
a3d6			 
a3d6					FORTH_DSP_POP 
a3d6 cd ac 9b			call macro_forth_dsp_pop 
a3d9				endm 
# End of macro FORTH_DSP_POP
a3d9			 
a3d9 c1					pop bc      ; u1 
a3da e1					pop hl      ; u2 
a3db d1					pop de      ; u3 
a3dc			 
a3dc			 
a3dc c5					push bc 
a3dd d5					push de 
a3de e5					push hl 
a3df			 
a3df			 
a3df e1					pop hl 
a3e0 cd fd 98				call forth_push_numhl 
a3e3			 
a3e3 e1					pop hl 
a3e4 cd fd 98				call forth_push_numhl 
a3e7			 
a3e7 e1					pop hl 
a3e8 cd fd 98				call forth_push_numhl 
a3eb					 
a3eb			 
a3eb			 
a3eb			 
a3eb			 
a3eb			 
a3eb				       NEXTW 
a3eb c3 66 9c			jp macro_next 
a3ee				endm 
# End of macro NEXTW
a3ee			 
a3ee			.UWORDS: 
a3ee				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a3ee 50				db WORD_SYS_CORE+60             
a3ef b0 a4			dw .BP            
a3f1 07				db 6 + 1 
a3f2 .. 00			db "UWORDS",0              
a3f9				endm 
# End of macro CWHEAD
a3f9			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a3f9			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a3f9			; | | Following the count are the individual words. 
a3f9			; | | 
a3f9			; | | e.g. UWORDS 
a3f9			; | | BOX DIRLIST 2 
a3f9			; | |  
a3f9			; | | Can be used to save the words to storage via: 
a3f9			; | | UWORDS $01 DO $01 APPEND LOOP 
a3f9				if DEBUG_FORTH_WORDS_KEY 
a3f9					DMARK "UWR" 
a3f9 f5				push af  
a3fa 3a 0e a4			ld a, (.dmark)  
a3fd 32 b7 ee			ld (debug_mark),a  
a400 3a 0f a4			ld a, (.dmark+1)  
a403 32 b8 ee			ld (debug_mark+1),a  
a406 3a 10 a4			ld a, (.dmark+2)  
a409 32 b9 ee			ld (debug_mark+2),a  
a40c 18 03			jr .pastdmark  
a40e ..			.dmark: db "UWR"  
a411 f1			.pastdmark: pop af  
a412			endm  
# End of macro DMARK
a412					CALLMONITOR 
a412 cd a3 92			call break_point_state  
a415				endm  
# End of macro CALLMONITOR
a415				endif 
a415 21 e3 d7				ld hl, baseram 
a418					;ld hl, baseusermem 
a418 01 00 00				ld bc, 0    ; start a counter 
a41b			 
a41b				; skip dict stub 
a41b			 
a41b cd b7 9d				call forth_tok_next 
a41e			 
a41e			 
a41e			; while we have words to look for 
a41e			 
a41e 7e			.douscan:	ld a, (hl)      
a41f				if DEBUG_FORTH_WORDS 
a41f					DMARK "UWs" 
a41f f5				push af  
a420 3a 34 a4			ld a, (.dmark)  
a423 32 b7 ee			ld (debug_mark),a  
a426 3a 35 a4			ld a, (.dmark+1)  
a429 32 b8 ee			ld (debug_mark+1),a  
a42c 3a 36 a4			ld a, (.dmark+2)  
a42f 32 b9 ee			ld (debug_mark+2),a  
a432 18 03			jr .pastdmark  
a434 ..			.dmark: db "UWs"  
a437 f1			.pastdmark: pop af  
a438			endm  
# End of macro DMARK
a438					CALLMONITOR 
a438 cd a3 92			call break_point_state  
a43b				endm  
# End of macro CALLMONITOR
a43b				endif 
a43b fe 00				cp WORD_SYS_END 
a43d 28 4d				jr z, .udone 
a43f fe 01				cp WORD_SYS_UWORD 
a441 20 44				jr nz, .nuword 
a443			 
a443				if DEBUG_FORTH_WORDS 
a443					DMARK "UWu" 
a443 f5				push af  
a444 3a 58 a4			ld a, (.dmark)  
a447 32 b7 ee			ld (debug_mark),a  
a44a 3a 59 a4			ld a, (.dmark+1)  
a44d 32 b8 ee			ld (debug_mark+1),a  
a450 3a 5a a4			ld a, (.dmark+2)  
a453 32 b9 ee			ld (debug_mark+2),a  
a456 18 03			jr .pastdmark  
a458 ..			.dmark: db "UWu"  
a45b f1			.pastdmark: pop af  
a45c			endm  
# End of macro DMARK
a45c					CALLMONITOR 
a45c cd a3 92			call break_point_state  
a45f				endm  
# End of macro CALLMONITOR
a45f				endif 
a45f					; we have a uword so push its name to the stack 
a45f			 
a45f e5				   	push hl  ; save so we can move to next dict block 
a460			 
a460					; skip opcode 
a460 23					inc hl  
a461					; skip next ptr 
a461 23					inc hl  
a462 23					inc hl 
a463					; skip len 
a463 23					inc hl 
a464				if DEBUG_FORTH_WORDS 
a464					DMARK "UWt" 
a464 f5				push af  
a465 3a 79 a4			ld a, (.dmark)  
a468 32 b7 ee			ld (debug_mark),a  
a46b 3a 7a a4			ld a, (.dmark+1)  
a46e 32 b8 ee			ld (debug_mark+1),a  
a471 3a 7b a4			ld a, (.dmark+2)  
a474 32 b9 ee			ld (debug_mark+2),a  
a477 18 03			jr .pastdmark  
a479 ..			.dmark: db "UWt"  
a47c f1			.pastdmark: pop af  
a47d			endm  
# End of macro DMARK
a47d					CALLMONITOR 
a47d cd a3 92			call break_point_state  
a480				endm  
# End of macro CALLMONITOR
a480				endif 
a480 03					inc bc 
a481			 
a481 c5					push bc 
a482 cd 6b 99				call forth_push_str 
a485 c1					pop bc 
a486			 
a486 e1					pop hl 	 
a487			 
a487 cd b7 9d		.nuword:	call forth_tok_next 
a48a 18 92				jr .douscan  
a48c			 
a48c			.udone:		 ; push count of uwords found 
a48c c5					push bc 
a48d e1					pop hl 
a48e			 
a48e				if DEBUG_FORTH_WORDS 
a48e					DMARK "UWc" 
a48e f5				push af  
a48f 3a a3 a4			ld a, (.dmark)  
a492 32 b7 ee			ld (debug_mark),a  
a495 3a a4 a4			ld a, (.dmark+1)  
a498 32 b8 ee			ld (debug_mark+1),a  
a49b 3a a5 a4			ld a, (.dmark+2)  
a49e 32 b9 ee			ld (debug_mark+2),a  
a4a1 18 03			jr .pastdmark  
a4a3 ..			.dmark: db "UWc"  
a4a6 f1			.pastdmark: pop af  
a4a7			endm  
# End of macro DMARK
a4a7					CALLMONITOR 
a4a7 cd a3 92			call break_point_state  
a4aa				endm  
# End of macro CALLMONITOR
a4aa				endif 
a4aa cd fd 98				call forth_push_numhl 
a4ad			 
a4ad			 
a4ad				       NEXTW 
a4ad c3 66 9c			jp macro_next 
a4b0				endm 
# End of macro NEXTW
a4b0			 
a4b0			.BP: 
a4b0				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a4b0 54				db WORD_SYS_CORE+64             
a4b1 e6 a4			dw .MONITOR            
a4b3 03				db 2 + 1 
a4b4 .. 00			db "BP",0              
a4b7				endm 
# End of macro CWHEAD
a4b7			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a4b7			; | | $00 Will enable the break points within specific code paths 
a4b7			; | | $01 Will disable break points 
a4b7			; | |  
a4b7			; | | By default break points are off. Either the above can be used to enable them 
a4b7			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a4b7			; | | and on release of the pressed key a message will be disaplayed to notify 
a4b7			; | | that break points are enabled. Pressing any key will then continue boot process. 
a4b7					; get byte count 
a4b7					if DEBUG_FORTH_WORDS_KEY 
a4b7						DMARK "BP." 
a4b7 f5				push af  
a4b8 3a cc a4			ld a, (.dmark)  
a4bb 32 b7 ee			ld (debug_mark),a  
a4be 3a cd a4			ld a, (.dmark+1)  
a4c1 32 b8 ee			ld (debug_mark+1),a  
a4c4 3a ce a4			ld a, (.dmark+2)  
a4c7 32 b9 ee			ld (debug_mark+2),a  
a4ca 18 03			jr .pastdmark  
a4cc ..			.dmark: db "BP."  
a4cf f1			.pastdmark: pop af  
a4d0			endm  
# End of macro DMARK
a4d0						CALLMONITOR 
a4d0 cd a3 92			call break_point_state  
a4d3				endm  
# End of macro CALLMONITOR
a4d3					endif 
a4d3			 
a4d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4d3 cd f4 9a			call macro_dsp_valuehl 
a4d6				endm 
# End of macro FORTH_DSP_VALUEHL
a4d6			 
a4d6			;		push hl 
a4d6			 
a4d6					; destroy value TOS 
a4d6			 
a4d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4d6 cd ac 9b			call macro_forth_dsp_pop 
a4d9				endm 
# End of macro FORTH_DSP_POP
a4d9			 
a4d9			;		pop hl 
a4d9			 
a4d9 3e 00				ld a,0 
a4db bd					cp l 
a4dc 28 02				jr z, .bpset 
a4de 3e 2a				ld a, '*' 
a4e0			 
a4e0 32 ce e4		.bpset:		ld (os_view_disable), a 
a4e3			 
a4e3			 
a4e3					NEXTW 
a4e3 c3 66 9c			jp macro_next 
a4e6				endm 
# End of macro NEXTW
a4e6			 
a4e6			 
a4e6			.MONITOR: 
a4e6				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a4e6 55				db WORD_SYS_CORE+65             
a4e7 19 a5			dw .MALLOC            
a4e9 08				db 7 + 1 
a4ea .. 00			db "MONITOR",0              
a4f2				endm 
# End of macro CWHEAD
a4f2			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a4f2			; | | At start the current various registers will be displayed with contents. 
a4f2			; | | Top right corner will show the most recent debug marker seen. 
a4f2			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a4f2			; | | and the return stack pointer (RSP). 
a4f2			; | | Pressing: 
a4f2			; | |    1 - Initial screen 
a4f2			; | |    2 - Display a data dump of HL 
a4f2			; | |    3 - Display a data dump of DE 
a4f2			; | |    4 - Display a data dump of BC 
a4f2			; | |    5 - Display a data dump of HL 
a4f2			; | |    6 - Display a data dump of DSP 
a4f2			; | |    7 - Display a data dump of RSP 
a4f2			; | |    8 - Display a data dump of what is at DSP 
a4f2			; | |    9 - Display a data dump of what is at RSP 
a4f2			; | |    0 - Exit monitor and continue running. This will also enable break points 
a4f2			; | |    * - Disable break points 
a4f2			; | |    # - Enter traditional monitor mode 
a4f2			; | | 
a4f2			; | | Monitor Mode 
a4f2			; | | ------------ 
a4f2			; | | A prompt of '>' will be shown for various commands: 
a4f2			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a4f2			; | |    C - Continue display a data dump from the last set address 
a4f2			; | |    M xxxx - Set start of memory edit at address xx 
a4f2			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a4f2			; | |    Q - Return to previous 
a4f2					if DEBUG_FORTH_WORDS_KEY 
a4f2						DMARK "MON" 
a4f2 f5				push af  
a4f3 3a 07 a5			ld a, (.dmark)  
a4f6 32 b7 ee			ld (debug_mark),a  
a4f9 3a 08 a5			ld a, (.dmark+1)  
a4fc 32 b8 ee			ld (debug_mark+1),a  
a4ff 3a 09 a5			ld a, (.dmark+2)  
a502 32 b9 ee			ld (debug_mark+2),a  
a505 18 03			jr .pastdmark  
a507 ..			.dmark: db "MON"  
a50a f1			.pastdmark: pop af  
a50b			endm  
# End of macro DMARK
a50b						CALLMONITOR 
a50b cd a3 92			call break_point_state  
a50e				endm  
# End of macro CALLMONITOR
a50e					endif 
a50e 3e 00				ld a, 0 
a510 32 ce e4				ld (os_view_disable), a 
a513			 
a513					CALLMONITOR 
a513 cd a3 92			call break_point_state  
a516				endm  
# End of macro CALLMONITOR
a516			 
a516			;	call monitor 
a516			 
a516					NEXTW 
a516 c3 66 9c			jp macro_next 
a519				endm 
# End of macro NEXTW
a519			 
a519			 
a519			.MALLOC: 
a519				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a519 56				db WORD_SYS_CORE+66             
a51a 42 a5			dw .MALLOC2            
a51c 06				db 5 + 1 
a51d .. 00			db "ALLOT",0              
a523				endm 
# End of macro CWHEAD
a523			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a523					if DEBUG_FORTH_WORDS_KEY 
a523						DMARK "ALL" 
a523 f5				push af  
a524 3a 38 a5			ld a, (.dmark)  
a527 32 b7 ee			ld (debug_mark),a  
a52a 3a 39 a5			ld a, (.dmark+1)  
a52d 32 b8 ee			ld (debug_mark+1),a  
a530 3a 3a a5			ld a, (.dmark+2)  
a533 32 b9 ee			ld (debug_mark+2),a  
a536 18 03			jr .pastdmark  
a538 ..			.dmark: db "ALL"  
a53b f1			.pastdmark: pop af  
a53c			endm  
# End of macro DMARK
a53c						CALLMONITOR 
a53c cd a3 92			call break_point_state  
a53f				endm  
# End of macro CALLMONITOR
a53f					endif 
a53f c3 69 a5				jp .mallocc 
a542			.MALLOC2: 
a542				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a542 56				db WORD_SYS_CORE+66             
a543 80 a5			dw .FREE            
a545 07				db 6 + 1 
a546 .. 00			db "MALLOC",0              
a54d				endm 
# End of macro CWHEAD
a54d			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a54d					; get byte count 
a54d					if DEBUG_FORTH_WORDS_KEY 
a54d						DMARK "MAL" 
a54d f5				push af  
a54e 3a 62 a5			ld a, (.dmark)  
a551 32 b7 ee			ld (debug_mark),a  
a554 3a 63 a5			ld a, (.dmark+1)  
a557 32 b8 ee			ld (debug_mark+1),a  
a55a 3a 64 a5			ld a, (.dmark+2)  
a55d 32 b9 ee			ld (debug_mark+2),a  
a560 18 03			jr .pastdmark  
a562 ..			.dmark: db "MAL"  
a565 f1			.pastdmark: pop af  
a566			endm  
# End of macro DMARK
a566						CALLMONITOR 
a566 cd a3 92			call break_point_state  
a569				endm  
# End of macro CALLMONITOR
a569					endif 
a569			.mallocc: 
a569					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a569 cd f4 9a			call macro_dsp_valuehl 
a56c				endm 
# End of macro FORTH_DSP_VALUEHL
a56c			 
a56c			;		push hl 
a56c			 
a56c					; destroy value TOS 
a56c			 
a56c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a56c cd ac 9b			call macro_forth_dsp_pop 
a56f				endm 
# End of macro FORTH_DSP_POP
a56f			 
a56f			;		pop hl 
a56f cd 69 8f				call malloc 
a572				if DEBUG_FORTH_MALLOC_GUARD 
a572 f5					push af 
a573 cd cb 8a				call ishlzero 
a576			;		ld a, l 
a576			;		add h 
a576			;		cp 0 
a576 f1					pop af 
a577					 
a577 cc 98 c4				call z,malloc_error 
a57a				endif 
a57a			 
a57a cd fd 98				call forth_push_numhl 
a57d					NEXTW 
a57d c3 66 9c			jp macro_next 
a580				endm 
# End of macro NEXTW
a580			 
a580			.FREE: 
a580				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a580 57				db WORD_SYS_CORE+67             
a581 b1 a5			dw .LIST            
a583 05				db 4 + 1 
a584 .. 00			db "FREE",0              
a589				endm 
# End of macro CWHEAD
a589			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a589					if DEBUG_FORTH_WORDS_KEY 
a589						DMARK "FRE" 
a589 f5				push af  
a58a 3a 9e a5			ld a, (.dmark)  
a58d 32 b7 ee			ld (debug_mark),a  
a590 3a 9f a5			ld a, (.dmark+1)  
a593 32 b8 ee			ld (debug_mark+1),a  
a596 3a a0 a5			ld a, (.dmark+2)  
a599 32 b9 ee			ld (debug_mark+2),a  
a59c 18 03			jr .pastdmark  
a59e ..			.dmark: db "FRE"  
a5a1 f1			.pastdmark: pop af  
a5a2			endm  
# End of macro DMARK
a5a2						CALLMONITOR 
a5a2 cd a3 92			call break_point_state  
a5a5				endm  
# End of macro CALLMONITOR
a5a5					endif 
a5a5					; get address 
a5a5			 
a5a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5a5 cd f4 9a			call macro_dsp_valuehl 
a5a8				endm 
# End of macro FORTH_DSP_VALUEHL
a5a8			 
a5a8			;		push hl 
a5a8			 
a5a8					; destroy value TOS 
a5a8			 
a5a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5a8 cd ac 9b			call macro_forth_dsp_pop 
a5ab				endm 
# End of macro FORTH_DSP_POP
a5ab			 
a5ab			;		pop hl 
a5ab			if FORTH_ENABLE_MALLOCFREE 
a5ab cd 33 90				call free 
a5ae			endif 
a5ae					NEXTW 
a5ae c3 66 9c			jp macro_next 
a5b1				endm 
# End of macro NEXTW
a5b1			.LIST: 
a5b1				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a5b1 5c				db WORD_SYS_CORE+72             
a5b2 9f a7			dw .FORGET            
a5b4 05				db 4 + 1 
a5b5 .. 00			db "LIST",0              
a5ba				endm 
# End of macro CWHEAD
a5ba			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a5ba			; | | The quoted word must be in upper case. 
a5ba				if DEBUG_FORTH_WORDS_KEY 
a5ba					DMARK "LST" 
a5ba f5				push af  
a5bb 3a cf a5			ld a, (.dmark)  
a5be 32 b7 ee			ld (debug_mark),a  
a5c1 3a d0 a5			ld a, (.dmark+1)  
a5c4 32 b8 ee			ld (debug_mark+1),a  
a5c7 3a d1 a5			ld a, (.dmark+2)  
a5ca 32 b9 ee			ld (debug_mark+2),a  
a5cd 18 03			jr .pastdmark  
a5cf ..			.dmark: db "LST"  
a5d2 f1			.pastdmark: pop af  
a5d3			endm  
# End of macro DMARK
a5d3					CALLMONITOR 
a5d3 cd a3 92			call break_point_state  
a5d6				endm  
# End of macro CALLMONITOR
a5d6				endif 
a5d6			 
a5d6					FORTH_DSP_VALUEHL 
a5d6 cd f4 9a			call macro_dsp_valuehl 
a5d9				endm 
# End of macro FORTH_DSP_VALUEHL
a5d9			 
a5d9 e5					push hl 
a5da					FORTH_DSP_POP 
a5da cd ac 9b			call macro_forth_dsp_pop 
a5dd				endm 
# End of macro FORTH_DSP_POP
a5dd c1					pop bc 
a5de			 
a5de			; Start format of scratch string 
a5de			 
a5de 21 dd e4				ld hl, scratch 
a5e1			 
a5e1 3e 3a				ld a, ':' 
a5e3 77					ld (hl),a 
a5e4 23					inc hl 
a5e5 3e 20				ld a, ' ' 
a5e7 77					ld (hl), a 
a5e8			 
a5e8					; Get ptr to the word we need to look up 
a5e8			 
a5e8			;		FORTH_DSP_VALUEHL 
a5e8					;v5 FORTH_DSP_VALUE 
a5e8				; TODO type check 
a5e8			;		inc hl    ; Skip type check  
a5e8			;		push hl 
a5e8			;		ex de, hl    ; put into DE 
a5e8			 
a5e8			 
a5e8 21 e3 d7				ld hl, baseram 
a5eb					;ld hl, baseusermem 
a5eb			 
a5eb e5			push hl   ; sacreifical push 
a5ec			 
a5ec			.ldouscanm: 
a5ec e1				pop hl 
a5ed			.ldouscan: 
a5ed				if DEBUG_FORTH_WORDS 
a5ed					DMARK "LSs" 
a5ed f5				push af  
a5ee 3a 02 a6			ld a, (.dmark)  
a5f1 32 b7 ee			ld (debug_mark),a  
a5f4 3a 03 a6			ld a, (.dmark+1)  
a5f7 32 b8 ee			ld (debug_mark+1),a  
a5fa 3a 04 a6			ld a, (.dmark+2)  
a5fd 32 b9 ee			ld (debug_mark+2),a  
a600 18 03			jr .pastdmark  
a602 ..			.dmark: db "LSs"  
a605 f1			.pastdmark: pop af  
a606			endm  
# End of macro DMARK
a606					CALLMONITOR 
a606 cd a3 92			call break_point_state  
a609				endm  
# End of macro CALLMONITOR
a609				endif 
a609				; skip dict stub 
a609 cd b7 9d				call forth_tok_next 
a60c			 
a60c			 
a60c			; while we have words to look for 
a60c			 
a60c 7e				ld a, (hl)      
a60d				if DEBUG_FORTH_WORDS 
a60d					DMARK "LSk" 
a60d f5				push af  
a60e 3a 22 a6			ld a, (.dmark)  
a611 32 b7 ee			ld (debug_mark),a  
a614 3a 23 a6			ld a, (.dmark+1)  
a617 32 b8 ee			ld (debug_mark+1),a  
a61a 3a 24 a6			ld a, (.dmark+2)  
a61d 32 b9 ee			ld (debug_mark+2),a  
a620 18 03			jr .pastdmark  
a622 ..			.dmark: db "LSk"  
a625 f1			.pastdmark: pop af  
a626			endm  
# End of macro DMARK
a626					CALLMONITOR 
a626 cd a3 92			call break_point_state  
a629				endm  
# End of macro CALLMONITOR
a629				endif 
a629					;cp WORD_SYS_END 
a629					;jp z, .lunotfound 
a629			 
a629					; if we hit non uwords then gone too far 
a629 fe 01				cp WORD_SYS_UWORD 
a62b c2 5b a7				jp nz, .lunotfound 
a62e			 
a62e				if DEBUG_FORTH_WORDS 
a62e					DMARK "LSu" 
a62e f5				push af  
a62f 3a 43 a6			ld a, (.dmark)  
a632 32 b7 ee			ld (debug_mark),a  
a635 3a 44 a6			ld a, (.dmark+1)  
a638 32 b8 ee			ld (debug_mark+1),a  
a63b 3a 45 a6			ld a, (.dmark+2)  
a63e 32 b9 ee			ld (debug_mark+2),a  
a641 18 03			jr .pastdmark  
a643 ..			.dmark: db "LSu"  
a646 f1			.pastdmark: pop af  
a647			endm  
# End of macro DMARK
a647					CALLMONITOR 
a647 cd a3 92			call break_point_state  
a64a				endm  
# End of macro CALLMONITOR
a64a				endif 
a64a			 
a64a					; found a uword but is it the one we want... 
a64a			 
a64a c5					push bc     ; uword to find is on bc 
a64b d1					pop de 
a64c			 
a64c e5					push hl  ; to save the ptr 
a64d			 
a64d					; skip opcode 
a64d 23					inc hl  
a64e					; skip next ptr 
a64e 23					inc hl  
a64f 23					inc hl 
a650					; skip len 
a650 23					inc hl 
a651			 
a651				if DEBUG_FORTH_WORDS 
a651					DMARK "LSc" 
a651 f5				push af  
a652 3a 66 a6			ld a, (.dmark)  
a655 32 b7 ee			ld (debug_mark),a  
a658 3a 67 a6			ld a, (.dmark+1)  
a65b 32 b8 ee			ld (debug_mark+1),a  
a65e 3a 68 a6			ld a, (.dmark+2)  
a661 32 b9 ee			ld (debug_mark+2),a  
a664 18 03			jr .pastdmark  
a666 ..			.dmark: db "LSc"  
a669 f1			.pastdmark: pop af  
a66a			endm  
# End of macro DMARK
a66a					CALLMONITOR 
a66a cd a3 92			call break_point_state  
a66d				endm  
# End of macro CALLMONITOR
a66d				endif 
a66d cd 38 8f				call strcmp 
a670 c2 ec a5				jp nz, .ldouscanm 
a673				 
a673			 
a673			 
a673					; we have a uword so push its name to the stack 
a673			 
a673			;	   	push hl  ; save so we can move to next dict block 
a673 e1			pop hl 
a674			 
a674				if DEBUG_FORTH_WORDS 
a674					DMARK "LSm" 
a674 f5				push af  
a675 3a 89 a6			ld a, (.dmark)  
a678 32 b7 ee			ld (debug_mark),a  
a67b 3a 8a a6			ld a, (.dmark+1)  
a67e 32 b8 ee			ld (debug_mark+1),a  
a681 3a 8b a6			ld a, (.dmark+2)  
a684 32 b9 ee			ld (debug_mark+2),a  
a687 18 03			jr .pastdmark  
a689 ..			.dmark: db "LSm"  
a68c f1			.pastdmark: pop af  
a68d			endm  
# End of macro DMARK
a68d					CALLMONITOR 
a68d cd a3 92			call break_point_state  
a690				endm  
# End of macro CALLMONITOR
a690				endif 
a690			 
a690					; skip opcode 
a690 23					inc hl  
a691					; skip next ptr 
a691 23					inc hl  
a692 23					inc hl 
a693					; skip len 
a693 7e					ld a, (hl)   ; save length to add 
a694				if DEBUG_FORTH_WORDS 
a694					DMARK "LS2" 
a694 f5				push af  
a695 3a a9 a6			ld a, (.dmark)  
a698 32 b7 ee			ld (debug_mark),a  
a69b 3a aa a6			ld a, (.dmark+1)  
a69e 32 b8 ee			ld (debug_mark+1),a  
a6a1 3a ab a6			ld a, (.dmark+2)  
a6a4 32 b9 ee			ld (debug_mark+2),a  
a6a7 18 03			jr .pastdmark  
a6a9 ..			.dmark: db "LS2"  
a6ac f1			.pastdmark: pop af  
a6ad			endm  
# End of macro DMARK
a6ad					CALLMONITOR 
a6ad cd a3 92			call break_point_state  
a6b0				endm  
# End of macro CALLMONITOR
a6b0				endif 
a6b0			 
a6b0					; save this location 
a6b0				 
a6b0 e5					push hl 
a6b1			 
a6b1 23					inc hl 
a6b2 11 df e4				ld de, scratch+2 
a6b5 4f					ld c, a 
a6b6 06 00				ld b, 0 
a6b8			 
a6b8				if DEBUG_FORTH_WORDS 
a6b8					DMARK "LSn" 
a6b8 f5				push af  
a6b9 3a cd a6			ld a, (.dmark)  
a6bc 32 b7 ee			ld (debug_mark),a  
a6bf 3a ce a6			ld a, (.dmark+1)  
a6c2 32 b8 ee			ld (debug_mark+1),a  
a6c5 3a cf a6			ld a, (.dmark+2)  
a6c8 32 b9 ee			ld (debug_mark+2),a  
a6cb 18 03			jr .pastdmark  
a6cd ..			.dmark: db "LSn"  
a6d0 f1			.pastdmark: pop af  
a6d1			endm  
# End of macro DMARK
a6d1					CALLMONITOR 
a6d1 cd a3 92			call break_point_state  
a6d4				endm  
# End of macro CALLMONITOR
a6d4				endif 
a6d4			 
a6d4					; copy uword name to scratch 
a6d4			 
a6d4 ed b0				ldir 
a6d6			 
a6d6 1b					dec de 
a6d7 3e 20				ld a, ' '    ; change null to space 
a6d9 12					ld (de), a 
a6da			 
a6da 13					inc de 
a6db			 
a6db d5					push de 
a6dc c1					pop bc     ; move scratch pointer to end of word name and save it 
a6dd			 
a6dd e1					pop hl 
a6de 7e					ld a, (hl) 
a6df					;inc hl 
a6df					; skip word string 
a6df cd a2 8a				call addatohl 
a6e2			 
a6e2 23					inc hl 
a6e3			 
a6e3				if DEBUG_FORTH_WORDS 
a6e3					DMARK "LS3" 
a6e3 f5				push af  
a6e4 3a f8 a6			ld a, (.dmark)  
a6e7 32 b7 ee			ld (debug_mark),a  
a6ea 3a f9 a6			ld a, (.dmark+1)  
a6ed 32 b8 ee			ld (debug_mark+1),a  
a6f0 3a fa a6			ld a, (.dmark+2)  
a6f3 32 b9 ee			ld (debug_mark+2),a  
a6f6 18 03			jr .pastdmark  
a6f8 ..			.dmark: db "LS3"  
a6fb f1			.pastdmark: pop af  
a6fc			endm  
# End of macro DMARK
a6fc					CALLMONITOR 
a6fc cd a3 92			call break_point_state  
a6ff				endm  
# End of macro CALLMONITOR
a6ff				endif 
a6ff					; should now be at the start of the machine code to setup the eval of the uword 
a6ff					; now locate the ptr to the string defintion 
a6ff			 
a6ff					; skip ld hl, 
a6ff					; then load the ptr 
a6ff			; TODO use get from hl ptr 
a6ff 23					inc hl 
a700 5e					ld e, (hl) 
a701 23					inc hl 
a702 56					ld d, (hl) 
a703 eb					ex de, hl 
a704			 
a704			 
a704				if DEBUG_FORTH_WORDS 
a704					DMARK "LSt" 
a704 f5				push af  
a705 3a 19 a7			ld a, (.dmark)  
a708 32 b7 ee			ld (debug_mark),a  
a70b 3a 1a a7			ld a, (.dmark+1)  
a70e 32 b8 ee			ld (debug_mark+1),a  
a711 3a 1b a7			ld a, (.dmark+2)  
a714 32 b9 ee			ld (debug_mark+2),a  
a717 18 03			jr .pastdmark  
a719 ..			.dmark: db "LSt"  
a71c f1			.pastdmark: pop af  
a71d			endm  
# End of macro DMARK
a71d					CALLMONITOR 
a71d cd a3 92			call break_point_state  
a720				endm  
# End of macro CALLMONITOR
a720				endif 
a720			 
a720			; cant push right now due to tokenised strings  
a720			 
a720			; get the destination of where to copy this definition to. 
a720			 
a720 c5					push bc 
a721 d1					pop de 
a722			 
a722 7e			.listl:         ld a,(hl) 
a723 fe 00				cp 0 
a725 28 09				jr z, .lreplsp     ; replace zero with space 
a727					;cp FORTH_END_BUFFER 
a727 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a729 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a72b				 
a72b					; just copy this char as is then 
a72b			 
a72b 12					ld (de), a 
a72c			 
a72c 23			.listnxt:	inc hl 
a72d 13					inc de 
a72e 18 f2				jr .listl 
a730			 
a730 3e 20		.lreplsp:	ld a,' ' 
a732 12					ld (de), a 
a733 18 f7				jr .listnxt 
a735			 
a735			; close up uword def 
a735			 
a735			.listdone: 
a735 12					ld (de), a 
a736 13					inc de 
a737 3e 00				ld a, 0 
a739 12					ld (de), a 
a73a			 
a73a			; now have def so clean up and push to stack 
a73a			 
a73a 21 dd e4				ld hl, scratch 
a73d				if DEBUG_FORTH_WORDS 
a73d					DMARK "Ltp" 
a73d f5				push af  
a73e 3a 52 a7			ld a, (.dmark)  
a741 32 b7 ee			ld (debug_mark),a  
a744 3a 53 a7			ld a, (.dmark+1)  
a747 32 b8 ee			ld (debug_mark+1),a  
a74a 3a 54 a7			ld a, (.dmark+2)  
a74d 32 b9 ee			ld (debug_mark+2),a  
a750 18 03			jr .pastdmark  
a752 ..			.dmark: db "Ltp"  
a755 f1			.pastdmark: pop af  
a756			endm  
# End of macro DMARK
a756					CALLMONITOR 
a756 cd a3 92			call break_point_state  
a759				endm  
# End of macro CALLMONITOR
a759				endif 
a759			 
a759 18 1f			jr .listpush 
a75b			 
a75b			;.lnuword:	pop hl 
a75b			;		call forth_tok_next 
a75b			;		jp .ldouscan  
a75b			 
a75b			.lunotfound:		  
a75b			 
a75b				if DEBUG_FORTH_WORDS 
a75b					DMARK "LSn" 
a75b f5				push af  
a75c 3a 70 a7			ld a, (.dmark)  
a75f 32 b7 ee			ld (debug_mark),a  
a762 3a 71 a7			ld a, (.dmark+1)  
a765 32 b8 ee			ld (debug_mark+1),a  
a768 3a 72 a7			ld a, (.dmark+2)  
a76b 32 b9 ee			ld (debug_mark+2),a  
a76e 18 03			jr .pastdmark  
a770 ..			.dmark: db "LSn"  
a773 f1			.pastdmark: pop af  
a774			endm  
# End of macro DMARK
a774					CALLMONITOR 
a774 cd a3 92			call break_point_state  
a777				endm  
# End of macro CALLMONITOR
a777				endif 
a777			 
a777					 
a777			;		FORTH_DSP_POP 
a777			;		ld hl, .luno 
a777			 
a777					NEXTW			 
a777 c3 66 9c			jp macro_next 
a77a				endm 
# End of macro NEXTW
a77a			 
a77a			.listpush: 
a77a				if DEBUG_FORTH_WORDS 
a77a					DMARK "LS>" 
a77a f5				push af  
a77b 3a 8f a7			ld a, (.dmark)  
a77e 32 b7 ee			ld (debug_mark),a  
a781 3a 90 a7			ld a, (.dmark+1)  
a784 32 b8 ee			ld (debug_mark+1),a  
a787 3a 91 a7			ld a, (.dmark+2)  
a78a 32 b9 ee			ld (debug_mark+2),a  
a78d 18 03			jr .pastdmark  
a78f ..			.dmark: db "LS>"  
a792 f1			.pastdmark: pop af  
a793			endm  
# End of macro DMARK
a793					CALLMONITOR 
a793 cd a3 92			call break_point_state  
a796				endm  
# End of macro CALLMONITOR
a796				endif 
a796 cd 6b 99				call forth_push_str 
a799			 
a799			 
a799			 
a799					NEXTW 
a799 c3 66 9c			jp macro_next 
a79c				endm 
# End of macro NEXTW
a79c			 
a79c			;.luno:    db "Word not found",0 
a79c			 
a79c			 
a79c			 
a79c			 
a79c			 
a79c			;		push hl   ; save pointer to start of uword def string 
a79c			; 
a79c			;; look for FORTH_EOL_LINE 
a79c			;		ld a, FORTH_END_BUFFER 
a79c			;		call strlent 
a79c			; 
a79c			;		inc hl		 ; space for coln def 
a79c			;		inc hl 
a79c			;		inc hl          ; space for terms 
a79c			;		inc hl 
a79c			; 
a79c			;		ld a, 20   ; TODO get actual length 
a79c			;		call addatohl    ; include a random amount of room for the uword name 
a79c			; 
a79c			;		 
a79c			;	if DEBUG_FORTH_WORDS 
a79c			;		DMARK "Lt1" 
a79c			;		CALLMONITOR 
a79c			;	endif 
a79c			;		 
a79c			; 
a79c			;; malloc space for the string because we cant change it 
a79c			; 
a79c			;		call malloc 
a79c			;	if DEBUG_FORTH_MALLOC_GUARD 
a79c			;		push af 
a79c			;		call ishlzero 
a79c			;		pop af 
a79c			;		 
a79c			;		call z,malloc_error 
a79c			;	endif 
a79c			; 
a79c			;	if DEBUG_FORTH_WORDS 
a79c			;		DMARK "Lt2" 
a79c			;		CALLMONITOR 
a79c			;	endif 
a79c			;		pop de 
a79c			;		push hl    ; push the malloc to release later 
a79c			;		push hl   ;  push back a copy for the later stack push 
a79c			;		 
a79c			;; copy the string swapping out the zero terms for spaces 
a79c			; 
a79c			;		; de has our source 
a79c			;		; hl has our dest 
a79c			; 
a79c			;; add the coln def 
a79c			; 
a79c			;		ld a, ':' 
a79c			;		ld (hl), a 
a79c			;		inc hl 
a79c			;		ld a, ' ' 
a79c			;		ld (hl), a 
a79c			;		inc hl 
a79c			; 
a79c			;; add the uname word 
a79c			;		push de   ; save our string for now 
a79c			;		ex de, hl 
a79c			; 
a79c			;		FORTH_DSP_VALUE 
a79c			;		;v5 FORTH_DSP_VALUE 
a79c			; 
a79c			;		inc hl   ; skip type but we know by now this is OK 
a79c			; 
a79c			;.luword:	ld a,(hl) 
a79c			;		cp 0 
a79c			;		jr z, .luword2 
a79c			;		ld (de), a 
a79c			;		inc de 
a79c			;		inc hl 
a79c			;		jr .luword 
a79c			; 
a79c			;.luword2:	ld a, ' ' 
a79c			;		ld (de), a 
a79c			;;		inc hl 
a79c			;;		inc de 
a79c			;;		ld (de), a 
a79c			;;		inc hl 
a79c			;		inc de 
a79c			; 
a79c			;		ex de, hl 
a79c			;		pop de 
a79c			;		 
a79c			;		 
a79c			; 
a79c			;; detoken that string and copy it 
a79c			; 
a79c			;	if DEBUG_FORTH_WORDS 
a79c			;		DMARK "Lt2" 
a79c			;		CALLMONITOR 
a79c			;	endif 
a79c			;.ldetok:	ld a, (de) 
a79c			;		cp FORTH_END_BUFFER 
a79c			;		jr z, .ldetokend 
a79c			;		; swap out any zero term for space 
a79c			;		cp 0 
a79c			;		jr nz, .ldetoknext 
a79c			;		ld a, ' ' 
a79c			; 
a79c			;	if DEBUG_FORTH_WORDS 
a79c			;		DMARK "LtS" 
a79c			;		CALLMONITOR 
a79c			;	endif 
a79c			;.ldetoknext:	ld (hl), a 
a79c			;		inc de 
a79c			;		inc hl 
a79c			;		jr .ldetok 
a79c			; 
a79c			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a79c			;		ld (hl), a  
a79c			; 
a79c			;; free that temp malloc 
a79c			; 
a79c			;		pop hl    
a79c			; 
a79c			;	if DEBUG_FORTH_WORDS 
a79c			;		DMARK "Lt4" 
a79c			;		CALLMONITOR 
a79c			;	endif 
a79c			;		call forth_apushstrhl 
a79c			; 
a79c			;		; get rid of temp malloc area 
a79c			; 
a79c			;		pop hl 
a79c			;		call free 
a79c			; 
a79c			;		jr .ludone 
a79c			; 
a79c			;.lnuword:	pop hl 
a79c			;		call forth_tok_next 
a79c			;		jp .ldouscan  
a79c			; 
a79c			;.ludone:		 pop hl 
a79c			; 
a79c					NEXTW 
a79c c3 66 9c			jp macro_next 
a79f				endm 
# End of macro NEXTW
a79f			 
a79f			.FORGET: 
a79f				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a79f 5d				db WORD_SYS_CORE+73             
a7a0 18 a8			dw .NOP            
a7a2 07				db 6 + 1 
a7a3 .. 00			db "FORGET",0              
a7aa				endm 
# End of macro CWHEAD
a7aa			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a7aa			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a7aa			; | |  
a7aa			; | | e.g. "MORE" forget 
a7aa					if DEBUG_FORTH_WORDS_KEY 
a7aa						DMARK "FRG" 
a7aa f5				push af  
a7ab 3a bf a7			ld a, (.dmark)  
a7ae 32 b7 ee			ld (debug_mark),a  
a7b1 3a c0 a7			ld a, (.dmark+1)  
a7b4 32 b8 ee			ld (debug_mark+1),a  
a7b7 3a c1 a7			ld a, (.dmark+2)  
a7ba 32 b9 ee			ld (debug_mark+2),a  
a7bd 18 03			jr .pastdmark  
a7bf ..			.dmark: db "FRG"  
a7c2 f1			.pastdmark: pop af  
a7c3			endm  
# End of macro DMARK
a7c3						CALLMONITOR 
a7c3 cd a3 92			call break_point_state  
a7c6				endm  
# End of macro CALLMONITOR
a7c6					endif 
a7c6			 
a7c6				; find uword 
a7c6			        ; update start of word with "_" 
a7c6				; replace uword with deleted flag 
a7c6			 
a7c6			 
a7c6			;	if DEBUG_FORTH_WORDS 
a7c6			;		DMARK "FOG" 
a7c6			;		CALLMONITOR 
a7c6			;	endif 
a7c6			 
a7c6			 
a7c6					; Get ptr to the word we need to look up 
a7c6			 
a7c6					FORTH_DSP_VALUEHL 
a7c6 cd f4 9a			call macro_dsp_valuehl 
a7c9				endm 
# End of macro FORTH_DSP_VALUEHL
a7c9					;v5 FORTH_DSP_VALUE 
a7c9				; TODO type check 
a7c9			;		inc hl    ; Skip type check  
a7c9 e5					push hl 
a7ca c1					pop bc 
a7cb			;		ex de, hl    ; put into DE 
a7cb			 
a7cb			 
a7cb 21 e3 d7				ld hl, baseram 
a7ce					;ld hl, baseusermem 
a7ce			 
a7ce				; skip dict stub 
a7ce			;	call forth_tok_next 
a7ce e5			push hl   ; sacreifical push 
a7cf			 
a7cf			.fldouscanm: 
a7cf e1				pop hl 
a7d0			.fldouscan: 
a7d0			;	if DEBUG_FORTH_WORDS 
a7d0			;		DMARK "LSs" 
a7d0			;		CALLMONITOR 
a7d0			;	endif 
a7d0				; skip dict stub 
a7d0 cd b7 9d				call forth_tok_next 
a7d3			 
a7d3			 
a7d3			; while we have words to look for 
a7d3			 
a7d3 7e				ld a, (hl)      
a7d4			;	if DEBUG_FORTH_WORDS 
a7d4			;		DMARK "LSk" 
a7d4			;		CALLMONITOR 
a7d4			;	endif 
a7d4 fe 00				cp WORD_SYS_END 
a7d6 ca 12 a8				jp z, .flunotfound 
a7d9 fe 01				cp WORD_SYS_UWORD 
a7db c2 d0 a7				jp nz, .fldouscan 
a7de			 
a7de			;	if DEBUG_FORTH_WORDS 
a7de			;		DMARK "LSu" 
a7de			;		CALLMONITOR 
a7de			;	endif 
a7de			 
a7de					; found a uword but is it the one we want... 
a7de			 
a7de c5					push bc     ; uword to find is on bc 
a7df d1					pop de 
a7e0			 
a7e0 e5					push hl  ; to save the ptr 
a7e1			 
a7e1					; skip opcode 
a7e1 23					inc hl  
a7e2					; skip next ptr 
a7e2 23					inc hl  
a7e3 23					inc hl 
a7e4					; skip len 
a7e4 23					inc hl 
a7e5			 
a7e5			;	if DEBUG_FORTH_WORDS 
a7e5			;		DMARK "LSc" 
a7e5			;		CALLMONITOR 
a7e5			;	endif 
a7e5 cd 38 8f				call strcmp 
a7e8 c2 cf a7				jp nz, .fldouscanm 
a7eb			; 
a7eb			; 
a7eb			;; while we have words to look for 
a7eb			; 
a7eb			;.fdouscan:	ld a, (hl)      
a7eb			;	if DEBUG_FORTH_WORDS 
a7eb			;		DMARK "LSs" 
a7eb			;		CALLMONITOR 
a7eb			;	endif 
a7eb			;		cp WORD_SYS_END 
a7eb			;		jp z, .fudone 
a7eb			;		cp WORD_SYS_UWORD 
a7eb			;		jp nz, .fnuword 
a7eb			; 
a7eb			;	if DEBUG_FORTH_WORDS 
a7eb			;		DMARK "FGu" 
a7eb			;		CALLMONITOR 
a7eb			;	endif 
a7eb			; 
a7eb			;		; found a uword but is it the one we want... 
a7eb			; 
a7eb			; 
a7eb			;	        pop de   ; get back the dsp name 
a7eb			;		push de 
a7eb			; 
a7eb			;		push hl  ; to save the ptr 
a7eb			; 
a7eb			;		; skip opcode 
a7eb			;		inc hl  
a7eb			;		; skip next ptr 
a7eb			;		inc hl  
a7eb			;		inc hl 
a7eb			;		; skip len 
a7eb			;		inc hl 
a7eb			; 
a7eb			;	if DEBUG_FORTH_WORDS 
a7eb			;		DMARK "FGc" 
a7eb			;		CALLMONITOR 
a7eb			;	endif 
a7eb			;		call strcmp 
a7eb			;		jp nz, .fnuword 
a7eb			 
a7eb			 
a7eb e1			pop hl 
a7ec			 
a7ec				 
a7ec				if DEBUG_FORTH_WORDS 
a7ec					DMARK "FGm" 
a7ec f5				push af  
a7ed 3a 01 a8			ld a, (.dmark)  
a7f0 32 b7 ee			ld (debug_mark),a  
a7f3 3a 02 a8			ld a, (.dmark+1)  
a7f6 32 b8 ee			ld (debug_mark+1),a  
a7f9 3a 03 a8			ld a, (.dmark+2)  
a7fc 32 b9 ee			ld (debug_mark+2),a  
a7ff 18 03			jr .pastdmark  
a801 ..			.dmark: db "FGm"  
a804 f1			.pastdmark: pop af  
a805			endm  
# End of macro DMARK
a805					CALLMONITOR 
a805 cd a3 92			call break_point_state  
a808				endm  
# End of macro CALLMONITOR
a808				endif 
a808			 
a808			 
a808			 
a808					; we have a uword so push its name to the stack 
a808			 
a808			;	   	push hl  ; save so we can move to next dict block 
a808			;pop hl 
a808			 
a808					; update opcode to deleted 
a808 3e 03				ld a, WORD_SYS_DELETED 
a80a 77					ld (hl), a 
a80b			 
a80b 23					inc hl  
a80c					; skip next ptr 
a80c 23					inc hl  
a80d 23					inc hl 
a80e					; skip len 
a80e 23					inc hl 
a80f			 
a80f					; TODO change parser to skip deleted words but for now mark it out 
a80f 3e 5f				ld a, "_" 
a811 77					ld  (hl),a 
a812			 
a812			;		jr .fudone 
a812			; 
a812			;.fnuword:	pop hl 
a812			;		call forth_tok_next 
a812			;		jp .fdouscan  
a812			 
a812			.flunotfound:		  
a812			 
a812			 
a812					 
a812					FORTH_DSP_POP 
a812 cd ac 9b			call macro_forth_dsp_pop 
a815				endm 
# End of macro FORTH_DSP_POP
a815			;		ld hl, .luno 
a815			;.fudone:		 pop hl 
a815					NEXTW 
a815 c3 66 9c			jp macro_next 
a818				endm 
# End of macro NEXTW
a818			.NOP: 
a818				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a818 61				db WORD_SYS_CORE+77             
a819 3f a8			dw .COMO            
a81b 04				db 3 + 1 
a81c .. 00			db "NOP",0              
a820				endm 
# End of macro CWHEAD
a820			; | NOP (  --  ) Do nothing | DONE 
a820					if DEBUG_FORTH_WORDS_KEY 
a820						DMARK "NOP" 
a820 f5				push af  
a821 3a 35 a8			ld a, (.dmark)  
a824 32 b7 ee			ld (debug_mark),a  
a827 3a 36 a8			ld a, (.dmark+1)  
a82a 32 b8 ee			ld (debug_mark+1),a  
a82d 3a 37 a8			ld a, (.dmark+2)  
a830 32 b9 ee			ld (debug_mark+2),a  
a833 18 03			jr .pastdmark  
a835 ..			.dmark: db "NOP"  
a838 f1			.pastdmark: pop af  
a839			endm  
# End of macro DMARK
a839						CALLMONITOR 
a839 cd a3 92			call break_point_state  
a83c				endm  
# End of macro CALLMONITOR
a83c					endif 
a83c				       NEXTW 
a83c c3 66 9c			jp macro_next 
a83f				endm 
# End of macro NEXTW
a83f			.COMO: 
a83f				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a83f 6e				db WORD_SYS_CORE+90             
a840 91 a8			dw .COMC            
a842 02				db 1 + 1 
a843 .. 00			db "(",0              
a845				endm 
# End of macro CWHEAD
a845			; | ( ( -- )  Start of comment | DONE 
a845			 
a845			 
a845 2a de e7				ld hl, ( os_tok_ptr) 
a848 11 8c a8			ld de, .closepar 
a84b					 
a84b					if DEBUG_FORTH_WORDS 
a84b						DMARK ").." 
a84b f5				push af  
a84c 3a 60 a8			ld a, (.dmark)  
a84f 32 b7 ee			ld (debug_mark),a  
a852 3a 61 a8			ld a, (.dmark+1)  
a855 32 b8 ee			ld (debug_mark+1),a  
a858 3a 62 a8			ld a, (.dmark+2)  
a85b 32 b9 ee			ld (debug_mark+2),a  
a85e 18 03			jr .pastdmark  
a860 ..			.dmark: db ").."  
a863 f1			.pastdmark: pop af  
a864			endm  
# End of macro DMARK
a864						CALLMONITOR 
a864 cd a3 92			call break_point_state  
a867				endm  
# End of macro CALLMONITOR
a867					endif 
a867 cd 81 9d			call findnexttok  
a86a			 
a86a					if DEBUG_FORTH_WORDS 
a86a						DMARK "IF5" 
a86a f5				push af  
a86b 3a 7f a8			ld a, (.dmark)  
a86e 32 b7 ee			ld (debug_mark),a  
a871 3a 80 a8			ld a, (.dmark+1)  
a874 32 b8 ee			ld (debug_mark+1),a  
a877 3a 81 a8			ld a, (.dmark+2)  
a87a 32 b9 ee			ld (debug_mark+2),a  
a87d 18 03			jr .pastdmark  
a87f ..			.dmark: db "IF5"  
a882 f1			.pastdmark: pop af  
a883			endm  
# End of macro DMARK
a883						CALLMONITOR 
a883 cd a3 92			call break_point_state  
a886				endm  
# End of macro CALLMONITOR
a886					endif 
a886				; replace below with ) exec using tok_ptr 
a886 22 de e7			ld (os_tok_ptr), hl 
a889 c3 f7 9c			jp exec1 
a88c			 
a88c .. 00			.closepar:   db ")",0 
a88e			 
a88e				       NEXTW 
a88e c3 66 9c			jp macro_next 
a891				endm 
# End of macro NEXTW
a891			.COMC: 
a891				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a891 6f				db WORD_SYS_CORE+91             
a892 9a a8			dw .SCRATCH            
a894 02				db 1 + 1 
a895 .. 00			db ")",0              
a897				endm 
# End of macro CWHEAD
a897			; | ) ( -- )  End of comment |  DONE  
a897				       NEXTW 
a897 c3 66 9c			jp macro_next 
a89a				endm 
# End of macro NEXTW
a89a			 
a89a			.SCRATCH: 
a89a				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a89a 6f				db WORD_SYS_CORE+91             
a89b d5 a8			dw .INC            
a89d 08				db 7 + 1 
a89e .. 00			db "SCRATCH",0              
a8a6				endm 
# End of macro CWHEAD
a8a6			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a8a6			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a8a6			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a8a6			; | |  
a8a6			; | | e.g.    : score $00 scratch ; 
a8a6			; | |  
a8a6			; | | $00 score ! 
a8a6			; | | $01 score +! 
a8a6			; | |  
a8a6			; | | e.g.   : varword $0a scratch ;  
a8a6			; | | 
a8a6			; | | $8000 varword ! 
a8a6					if DEBUG_FORTH_WORDS_KEY 
a8a6						DMARK "SCR" 
a8a6 f5				push af  
a8a7 3a bb a8			ld a, (.dmark)  
a8aa 32 b7 ee			ld (debug_mark),a  
a8ad 3a bc a8			ld a, (.dmark+1)  
a8b0 32 b8 ee			ld (debug_mark+1),a  
a8b3 3a bd a8			ld a, (.dmark+2)  
a8b6 32 b9 ee			ld (debug_mark+2),a  
a8b9 18 03			jr .pastdmark  
a8bb ..			.dmark: db "SCR"  
a8be f1			.pastdmark: pop af  
a8bf			endm  
# End of macro DMARK
a8bf						CALLMONITOR 
a8bf cd a3 92			call break_point_state  
a8c2				endm  
# End of macro CALLMONITOR
a8c2					endif 
a8c2			 
a8c2					FORTH_DSP_VALUEHL 
a8c2 cd f4 9a			call macro_dsp_valuehl 
a8c5				endm 
# End of macro FORTH_DSP_VALUEHL
a8c5				 
a8c5					FORTH_DSP_POP 
a8c5 cd ac 9b			call macro_forth_dsp_pop 
a8c8				endm 
# End of macro FORTH_DSP_POP
a8c8			 
a8c8 7d					ld a, l 
a8c9 21 02 ea				ld hl, os_var_array 
a8cc cd a2 8a				call addatohl 
a8cf			 
a8cf cd fd 98				call forth_push_numhl 
a8d2			 
a8d2				       NEXTW 
a8d2 c3 66 9c			jp macro_next 
a8d5				endm 
# End of macro NEXTW
a8d5			 
a8d5			.INC: 
a8d5				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a8d5 6f				db WORD_SYS_CORE+91             
a8d6 29 a9			dw .DEC            
a8d8 03				db 2 + 1 
a8d9 .. 00			db "+!",0              
a8dc				endm 
# End of macro CWHEAD
a8dc			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a8dc					if DEBUG_FORTH_WORDS_KEY 
a8dc						DMARK "+s_" 
a8dc f5				push af  
a8dd 3a f1 a8			ld a, (.dmark)  
a8e0 32 b7 ee			ld (debug_mark),a  
a8e3 3a f2 a8			ld a, (.dmark+1)  
a8e6 32 b8 ee			ld (debug_mark+1),a  
a8e9 3a f3 a8			ld a, (.dmark+2)  
a8ec 32 b9 ee			ld (debug_mark+2),a  
a8ef 18 03			jr .pastdmark  
a8f1 ..			.dmark: db "+s_"  
a8f4 f1			.pastdmark: pop af  
a8f5			endm  
# End of macro DMARK
a8f5						CALLMONITOR 
a8f5 cd a3 92			call break_point_state  
a8f8				endm  
# End of macro CALLMONITOR
a8f8					endif 
a8f8			 
a8f8					FORTH_DSP_VALUEHL 
a8f8 cd f4 9a			call macro_dsp_valuehl 
a8fb				endm 
# End of macro FORTH_DSP_VALUEHL
a8fb			 
a8fb e5					push hl   ; save address 
a8fc			 
a8fc					FORTH_DSP_POP 
a8fc cd ac 9b			call macro_forth_dsp_pop 
a8ff				endm 
# End of macro FORTH_DSP_POP
a8ff			 
a8ff					FORTH_DSP_VALUEHL 
a8ff cd f4 9a			call macro_dsp_valuehl 
a902				endm 
# End of macro FORTH_DSP_VALUEHL
a902			 
a902					FORTH_DSP_POP 
a902 cd ac 9b			call macro_forth_dsp_pop 
a905				endm 
# End of macro FORTH_DSP_POP
a905			 
a905					; hl contains value to add to byte at a 
a905				 
a905 eb					ex de, hl 
a906			 
a906 e1					pop hl 
a907			 
a907					if DEBUG_FORTH_WORDS 
a907						DMARK "INC" 
a907 f5				push af  
a908 3a 1c a9			ld a, (.dmark)  
a90b 32 b7 ee			ld (debug_mark),a  
a90e 3a 1d a9			ld a, (.dmark+1)  
a911 32 b8 ee			ld (debug_mark+1),a  
a914 3a 1e a9			ld a, (.dmark+2)  
a917 32 b9 ee			ld (debug_mark+2),a  
a91a 18 03			jr .pastdmark  
a91c ..			.dmark: db "INC"  
a91f f1			.pastdmark: pop af  
a920			endm  
# End of macro DMARK
a920						CALLMONITOR 
a920 cd a3 92			call break_point_state  
a923				endm  
# End of macro CALLMONITOR
a923					endif 
a923			 
a923 7e					ld a,(hl) 
a924 83					add e 
a925 77					ld (hl),a 
a926			 
a926			 
a926			 
a926				       NEXTW 
a926 c3 66 9c			jp macro_next 
a929				endm 
# End of macro NEXTW
a929			 
a929			.DEC: 
a929				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a929 6f				db WORD_SYS_CORE+91             
a92a 7a a9			dw .INC2            
a92c 03				db 2 + 1 
a92d .. 00			db "-!",0              
a930				endm 
# End of macro CWHEAD
a930			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a930					if DEBUG_FORTH_WORDS_KEY 
a930						DMARK "-s_" 
a930 f5				push af  
a931 3a 45 a9			ld a, (.dmark)  
a934 32 b7 ee			ld (debug_mark),a  
a937 3a 46 a9			ld a, (.dmark+1)  
a93a 32 b8 ee			ld (debug_mark+1),a  
a93d 3a 47 a9			ld a, (.dmark+2)  
a940 32 b9 ee			ld (debug_mark+2),a  
a943 18 03			jr .pastdmark  
a945 ..			.dmark: db "-s_"  
a948 f1			.pastdmark: pop af  
a949			endm  
# End of macro DMARK
a949						CALLMONITOR 
a949 cd a3 92			call break_point_state  
a94c				endm  
# End of macro CALLMONITOR
a94c					endif 
a94c			 
a94c					FORTH_DSP_VALUEHL 
a94c cd f4 9a			call macro_dsp_valuehl 
a94f				endm 
# End of macro FORTH_DSP_VALUEHL
a94f			 
a94f e5					push hl   ; save address 
a950			 
a950					FORTH_DSP_POP 
a950 cd ac 9b			call macro_forth_dsp_pop 
a953				endm 
# End of macro FORTH_DSP_POP
a953			 
a953					FORTH_DSP_VALUEHL 
a953 cd f4 9a			call macro_dsp_valuehl 
a956				endm 
# End of macro FORTH_DSP_VALUEHL
a956			 
a956					; hl contains value to add to byte at a 
a956				 
a956 eb					ex de, hl 
a957			 
a957 e1					pop hl 
a958			 
a958					if DEBUG_FORTH_WORDS 
a958						DMARK "DEC" 
a958 f5				push af  
a959 3a 6d a9			ld a, (.dmark)  
a95c 32 b7 ee			ld (debug_mark),a  
a95f 3a 6e a9			ld a, (.dmark+1)  
a962 32 b8 ee			ld (debug_mark+1),a  
a965 3a 6f a9			ld a, (.dmark+2)  
a968 32 b9 ee			ld (debug_mark+2),a  
a96b 18 03			jr .pastdmark  
a96d ..			.dmark: db "DEC"  
a970 f1			.pastdmark: pop af  
a971			endm  
# End of macro DMARK
a971						CALLMONITOR 
a971 cd a3 92			call break_point_state  
a974				endm  
# End of macro CALLMONITOR
a974					endif 
a974			 
a974 7e					ld a,(hl) 
a975 93					sub e 
a976 77					ld (hl),a 
a977			 
a977			 
a977			 
a977				       NEXTW 
a977 c3 66 9c			jp macro_next 
a97a				endm 
# End of macro NEXTW
a97a			 
a97a			.INC2: 
a97a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a97a 6f				db WORD_SYS_CORE+91             
a97b 24 aa			dw .DEC2            
a97d 04				db 3 + 1 
a97e .. 00			db "+2!",0              
a982				endm 
# End of macro CWHEAD
a982			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a982			 
a982					if DEBUG_FORTH_WORDS_KEY 
a982						DMARK "+2s" 
a982 f5				push af  
a983 3a 97 a9			ld a, (.dmark)  
a986 32 b7 ee			ld (debug_mark),a  
a989 3a 98 a9			ld a, (.dmark+1)  
a98c 32 b8 ee			ld (debug_mark+1),a  
a98f 3a 99 a9			ld a, (.dmark+2)  
a992 32 b9 ee			ld (debug_mark+2),a  
a995 18 03			jr .pastdmark  
a997 ..			.dmark: db "+2s"  
a99a f1			.pastdmark: pop af  
a99b			endm  
# End of macro DMARK
a99b						CALLMONITOR 
a99b cd a3 92			call break_point_state  
a99e				endm  
# End of macro CALLMONITOR
a99e					endif 
a99e			 
a99e					; Address 
a99e			 
a99e					FORTH_DSP_VALUEHL 
a99e cd f4 9a			call macro_dsp_valuehl 
a9a1				endm 
# End of macro FORTH_DSP_VALUEHL
a9a1			 
a9a1 e5					push hl    ; save address 
a9a2			 
a9a2					; load content into de 
a9a2			 
a9a2 5e					ld e,(hl) 
a9a3 23					inc hl 
a9a4 56					ld d, (hl) 
a9a5			 
a9a5					if DEBUG_FORTH_WORDS 
a9a5						DMARK "+2a" 
a9a5 f5				push af  
a9a6 3a ba a9			ld a, (.dmark)  
a9a9 32 b7 ee			ld (debug_mark),a  
a9ac 3a bb a9			ld a, (.dmark+1)  
a9af 32 b8 ee			ld (debug_mark+1),a  
a9b2 3a bc a9			ld a, (.dmark+2)  
a9b5 32 b9 ee			ld (debug_mark+2),a  
a9b8 18 03			jr .pastdmark  
a9ba ..			.dmark: db "+2a"  
a9bd f1			.pastdmark: pop af  
a9be			endm  
# End of macro DMARK
a9be						CALLMONITOR 
a9be cd a3 92			call break_point_state  
a9c1				endm  
# End of macro CALLMONITOR
a9c1					endif 
a9c1			 
a9c1					FORTH_DSP_POP 
a9c1 cd ac 9b			call macro_forth_dsp_pop 
a9c4				endm 
# End of macro FORTH_DSP_POP
a9c4			 
a9c4					; Get value to add 
a9c4			 
a9c4					FORTH_DSP_VALUE 
a9c4 cd dd 9a			call macro_forth_dsp_value 
a9c7				endm 
# End of macro FORTH_DSP_VALUE
a9c7			 
a9c7					if DEBUG_FORTH_WORDS 
a9c7						DMARK "+2v" 
a9c7 f5				push af  
a9c8 3a dc a9			ld a, (.dmark)  
a9cb 32 b7 ee			ld (debug_mark),a  
a9ce 3a dd a9			ld a, (.dmark+1)  
a9d1 32 b8 ee			ld (debug_mark+1),a  
a9d4 3a de a9			ld a, (.dmark+2)  
a9d7 32 b9 ee			ld (debug_mark+2),a  
a9da 18 03			jr .pastdmark  
a9dc ..			.dmark: db "+2v"  
a9df f1			.pastdmark: pop af  
a9e0			endm  
# End of macro DMARK
a9e0						CALLMONITOR 
a9e0 cd a3 92			call break_point_state  
a9e3				endm  
# End of macro CALLMONITOR
a9e3					endif 
a9e3			 
a9e3 19					add hl, de 
a9e4			 
a9e4					if DEBUG_FORTH_WORDS 
a9e4						DMARK "+2+" 
a9e4 f5				push af  
a9e5 3a f9 a9			ld a, (.dmark)  
a9e8 32 b7 ee			ld (debug_mark),a  
a9eb 3a fa a9			ld a, (.dmark+1)  
a9ee 32 b8 ee			ld (debug_mark+1),a  
a9f1 3a fb a9			ld a, (.dmark+2)  
a9f4 32 b9 ee			ld (debug_mark+2),a  
a9f7 18 03			jr .pastdmark  
a9f9 ..			.dmark: db "+2+"  
a9fc f1			.pastdmark: pop af  
a9fd			endm  
# End of macro DMARK
a9fd						CALLMONITOR 
a9fd cd a3 92			call break_point_state  
aa00				endm  
# End of macro CALLMONITOR
aa00					endif 
aa00			 
aa00					; move result to de 
aa00			 
aa00 eb					ex de, hl 
aa01			 
aa01					; Address 
aa01			 
aa01 e1					pop hl 
aa02			 
aa02					; save it back 
aa02			 
aa02 73					ld (hl), e 
aa03 23					inc hl 
aa04 72					ld (hl), d 
aa05			 
aa05					if DEBUG_FORTH_WORDS 
aa05						DMARK "+2e" 
aa05 f5				push af  
aa06 3a 1a aa			ld a, (.dmark)  
aa09 32 b7 ee			ld (debug_mark),a  
aa0c 3a 1b aa			ld a, (.dmark+1)  
aa0f 32 b8 ee			ld (debug_mark+1),a  
aa12 3a 1c aa			ld a, (.dmark+2)  
aa15 32 b9 ee			ld (debug_mark+2),a  
aa18 18 03			jr .pastdmark  
aa1a ..			.dmark: db "+2e"  
aa1d f1			.pastdmark: pop af  
aa1e			endm  
# End of macro DMARK
aa1e						CALLMONITOR 
aa1e cd a3 92			call break_point_state  
aa21				endm  
# End of macro CALLMONITOR
aa21					endif 
aa21			 
aa21			 
aa21			 
aa21			 
aa21			 
aa21				       NEXTW 
aa21 c3 66 9c			jp macro_next 
aa24				endm 
# End of macro NEXTW
aa24			 
aa24			.DEC2: 
aa24				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aa24 6f				db WORD_SYS_CORE+91             
aa25 d0 aa			dw .GET2            
aa27 04				db 3 + 1 
aa28 .. 00			db "-2!",0              
aa2c				endm 
# End of macro CWHEAD
aa2c			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aa2c			 
aa2c			 
aa2c					if DEBUG_FORTH_WORDS_KEY 
aa2c						DMARK "-2s" 
aa2c f5				push af  
aa2d 3a 41 aa			ld a, (.dmark)  
aa30 32 b7 ee			ld (debug_mark),a  
aa33 3a 42 aa			ld a, (.dmark+1)  
aa36 32 b8 ee			ld (debug_mark+1),a  
aa39 3a 43 aa			ld a, (.dmark+2)  
aa3c 32 b9 ee			ld (debug_mark+2),a  
aa3f 18 03			jr .pastdmark  
aa41 ..			.dmark: db "-2s"  
aa44 f1			.pastdmark: pop af  
aa45			endm  
# End of macro DMARK
aa45						CALLMONITOR 
aa45 cd a3 92			call break_point_state  
aa48				endm  
# End of macro CALLMONITOR
aa48					endif 
aa48			 
aa48					; Address 
aa48			 
aa48					FORTH_DSP_VALUEHL 
aa48 cd f4 9a			call macro_dsp_valuehl 
aa4b				endm 
# End of macro FORTH_DSP_VALUEHL
aa4b			 
aa4b e5					push hl    ; save address 
aa4c			 
aa4c					; load content into de 
aa4c			 
aa4c 5e					ld e,(hl) 
aa4d 23					inc hl 
aa4e 56					ld d, (hl) 
aa4f			 
aa4f					if DEBUG_FORTH_WORDS 
aa4f						DMARK "-2a" 
aa4f f5				push af  
aa50 3a 64 aa			ld a, (.dmark)  
aa53 32 b7 ee			ld (debug_mark),a  
aa56 3a 65 aa			ld a, (.dmark+1)  
aa59 32 b8 ee			ld (debug_mark+1),a  
aa5c 3a 66 aa			ld a, (.dmark+2)  
aa5f 32 b9 ee			ld (debug_mark+2),a  
aa62 18 03			jr .pastdmark  
aa64 ..			.dmark: db "-2a"  
aa67 f1			.pastdmark: pop af  
aa68			endm  
# End of macro DMARK
aa68						CALLMONITOR 
aa68 cd a3 92			call break_point_state  
aa6b				endm  
# End of macro CALLMONITOR
aa6b					endif 
aa6b			 
aa6b					FORTH_DSP_POP 
aa6b cd ac 9b			call macro_forth_dsp_pop 
aa6e				endm 
# End of macro FORTH_DSP_POP
aa6e			 
aa6e					; Get value to remove 
aa6e			 
aa6e					FORTH_DSP_VALUE 
aa6e cd dd 9a			call macro_forth_dsp_value 
aa71				endm 
# End of macro FORTH_DSP_VALUE
aa71			 
aa71					if DEBUG_FORTH_WORDS 
aa71						DMARK "-2v" 
aa71 f5				push af  
aa72 3a 86 aa			ld a, (.dmark)  
aa75 32 b7 ee			ld (debug_mark),a  
aa78 3a 87 aa			ld a, (.dmark+1)  
aa7b 32 b8 ee			ld (debug_mark+1),a  
aa7e 3a 88 aa			ld a, (.dmark+2)  
aa81 32 b9 ee			ld (debug_mark+2),a  
aa84 18 03			jr .pastdmark  
aa86 ..			.dmark: db "-2v"  
aa89 f1			.pastdmark: pop af  
aa8a			endm  
# End of macro DMARK
aa8a						CALLMONITOR 
aa8a cd a3 92			call break_point_state  
aa8d				endm  
# End of macro CALLMONITOR
aa8d					endif 
aa8d			 
aa8d eb					ex de, hl 
aa8e ed 52				sbc hl, de 
aa90			 
aa90					if DEBUG_FORTH_WORDS 
aa90						DMARK "-2d" 
aa90 f5				push af  
aa91 3a a5 aa			ld a, (.dmark)  
aa94 32 b7 ee			ld (debug_mark),a  
aa97 3a a6 aa			ld a, (.dmark+1)  
aa9a 32 b8 ee			ld (debug_mark+1),a  
aa9d 3a a7 aa			ld a, (.dmark+2)  
aaa0 32 b9 ee			ld (debug_mark+2),a  
aaa3 18 03			jr .pastdmark  
aaa5 ..			.dmark: db "-2d"  
aaa8 f1			.pastdmark: pop af  
aaa9			endm  
# End of macro DMARK
aaa9						CALLMONITOR 
aaa9 cd a3 92			call break_point_state  
aaac				endm  
# End of macro CALLMONITOR
aaac					endif 
aaac			 
aaac					; move result to de 
aaac			 
aaac eb					ex de, hl 
aaad			 
aaad					; Address 
aaad			 
aaad e1					pop hl 
aaae			 
aaae					; save it back 
aaae			 
aaae 73					ld (hl), e 
aaaf 23					inc hl 
aab0 72					ld (hl), d 
aab1			 
aab1					if DEBUG_FORTH_WORDS 
aab1						DMARK "-2e" 
aab1 f5				push af  
aab2 3a c6 aa			ld a, (.dmark)  
aab5 32 b7 ee			ld (debug_mark),a  
aab8 3a c7 aa			ld a, (.dmark+1)  
aabb 32 b8 ee			ld (debug_mark+1),a  
aabe 3a c8 aa			ld a, (.dmark+2)  
aac1 32 b9 ee			ld (debug_mark+2),a  
aac4 18 03			jr .pastdmark  
aac6 ..			.dmark: db "-2e"  
aac9 f1			.pastdmark: pop af  
aaca			endm  
# End of macro DMARK
aaca						CALLMONITOR 
aaca cd a3 92			call break_point_state  
aacd				endm  
# End of macro CALLMONITOR
aacd					endif 
aacd			 
aacd			 
aacd			 
aacd			 
aacd			 
aacd				       NEXTW 
aacd c3 66 9c			jp macro_next 
aad0				endm 
# End of macro NEXTW
aad0			.GET2: 
aad0				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aad0 6f				db WORD_SYS_CORE+91             
aad1 00 ab			dw .BANG2            
aad3 03				db 2 + 1 
aad4 .. 00			db "2@",0              
aad7				endm 
# End of macro CWHEAD
aad7			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aad7					if DEBUG_FORTH_WORDS_KEY 
aad7						DMARK "2A_" 
aad7 f5				push af  
aad8 3a ec aa			ld a, (.dmark)  
aadb 32 b7 ee			ld (debug_mark),a  
aade 3a ed aa			ld a, (.dmark+1)  
aae1 32 b8 ee			ld (debug_mark+1),a  
aae4 3a ee aa			ld a, (.dmark+2)  
aae7 32 b9 ee			ld (debug_mark+2),a  
aaea 18 03			jr .pastdmark  
aaec ..			.dmark: db "2A_"  
aaef f1			.pastdmark: pop af  
aaf0			endm  
# End of macro DMARK
aaf0						CALLMONITOR 
aaf0 cd a3 92			call break_point_state  
aaf3				endm  
# End of macro CALLMONITOR
aaf3					endif 
aaf3			 
aaf3					FORTH_DSP_VALUEHL 
aaf3 cd f4 9a			call macro_dsp_valuehl 
aaf6				endm 
# End of macro FORTH_DSP_VALUEHL
aaf6			 
aaf6 5e					ld e, (hl) 
aaf7 23					inc hl 
aaf8 56					ld d, (hl) 
aaf9			 
aaf9 eb					ex de, hl 
aafa			 
aafa cd fd 98				call forth_push_numhl 
aafd			 
aafd				       NEXTW 
aafd c3 66 9c			jp macro_next 
ab00				endm 
# End of macro NEXTW
ab00			.BANG2: 
ab00				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ab00 6f				db WORD_SYS_CORE+91             
ab01 38 ab			dw .CONFIG            
ab03 03				db 2 + 1 
ab04 .. 00			db "2!",0              
ab07				endm 
# End of macro CWHEAD
ab07			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ab07					if DEBUG_FORTH_WORDS_KEY 
ab07						DMARK "2S_" 
ab07 f5				push af  
ab08 3a 1c ab			ld a, (.dmark)  
ab0b 32 b7 ee			ld (debug_mark),a  
ab0e 3a 1d ab			ld a, (.dmark+1)  
ab11 32 b8 ee			ld (debug_mark+1),a  
ab14 3a 1e ab			ld a, (.dmark+2)  
ab17 32 b9 ee			ld (debug_mark+2),a  
ab1a 18 03			jr .pastdmark  
ab1c ..			.dmark: db "2S_"  
ab1f f1			.pastdmark: pop af  
ab20			endm  
# End of macro DMARK
ab20						CALLMONITOR 
ab20 cd a3 92			call break_point_state  
ab23				endm  
# End of macro CALLMONITOR
ab23					endif 
ab23			 
ab23					FORTH_DSP_VALUEHL 
ab23 cd f4 9a			call macro_dsp_valuehl 
ab26				endm 
# End of macro FORTH_DSP_VALUEHL
ab26			 
ab26 e5					push hl   ; save address 
ab27			 
ab27			 
ab27					FORTH_DSP_POP 
ab27 cd ac 9b			call macro_forth_dsp_pop 
ab2a				endm 
# End of macro FORTH_DSP_POP
ab2a			 
ab2a					 
ab2a					FORTH_DSP_VALUEHL 
ab2a cd f4 9a			call macro_dsp_valuehl 
ab2d				endm 
# End of macro FORTH_DSP_VALUEHL
ab2d			 
ab2d					FORTH_DSP_POP 
ab2d cd ac 9b			call macro_forth_dsp_pop 
ab30				endm 
# End of macro FORTH_DSP_POP
ab30			 
ab30 eb					ex de, hl    ; value now in de 
ab31			 
ab31 e1					pop hl 
ab32			 
ab32 73					ld (hl), e 
ab33			 
ab33 23					inc hl 
ab34			 
ab34 72					ld (hl), d 
ab35			 
ab35			 
ab35				       NEXTW 
ab35 c3 66 9c			jp macro_next 
ab38				endm 
# End of macro NEXTW
ab38			.CONFIG: 
ab38				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ab38 6f				db WORD_SYS_CORE+91             
ab39 49 ab			dw .ENDCORE            
ab3b 07				db 6 + 1 
ab3c .. 00			db "CONFIG",0              
ab43				endm 
# End of macro CWHEAD
ab43			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ab43			 
ab43 cd 02 91				call config 
ab46					NEXTW 
ab46 c3 66 9c			jp macro_next 
ab49				endm 
# End of macro NEXTW
ab49			.ENDCORE: 
ab49			 
ab49			; eof 
ab49			 
ab49			 
# End of file forth_words_core.asm
ab49			include "forth_words_flow.asm" 
ab49			 
ab49			; | ## Program Flow Words 
ab49			 
ab49			.IF: 
ab49				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ab49 1e				db WORD_SYS_CORE+10             
ab4a 3e ac			dw .THEN            
ab4c 03				db 2 + 1 
ab4d .. 00			db "IF",0              
ab50				endm 
# End of macro CWHEAD
ab50			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ab50			; 
ab50					if DEBUG_FORTH_WORDS_KEY 
ab50						DMARK "IF." 
ab50 f5				push af  
ab51 3a 65 ab			ld a, (.dmark)  
ab54 32 b7 ee			ld (debug_mark),a  
ab57 3a 66 ab			ld a, (.dmark+1)  
ab5a 32 b8 ee			ld (debug_mark+1),a  
ab5d 3a 67 ab			ld a, (.dmark+2)  
ab60 32 b9 ee			ld (debug_mark+2),a  
ab63 18 03			jr .pastdmark  
ab65 ..			.dmark: db "IF."  
ab68 f1			.pastdmark: pop af  
ab69			endm  
# End of macro DMARK
ab69						CALLMONITOR 
ab69 cd a3 92			call break_point_state  
ab6c				endm  
# End of macro CALLMONITOR
ab6c					endif 
ab6c			; eval TOS 
ab6c			 
ab6c				FORTH_DSP_VALUEHL 
ab6c cd f4 9a			call macro_dsp_valuehl 
ab6f				endm 
# End of macro FORTH_DSP_VALUEHL
ab6f			 
ab6f			;	push hl 
ab6f				FORTH_DSP_POP 
ab6f cd ac 9b			call macro_forth_dsp_pop 
ab72				endm 
# End of macro FORTH_DSP_POP
ab72			;	pop hl 
ab72			 
ab72					if DEBUG_FORTH_WORDS 
ab72						DMARK "IF1" 
ab72 f5				push af  
ab73 3a 87 ab			ld a, (.dmark)  
ab76 32 b7 ee			ld (debug_mark),a  
ab79 3a 88 ab			ld a, (.dmark+1)  
ab7c 32 b8 ee			ld (debug_mark+1),a  
ab7f 3a 89 ab			ld a, (.dmark+2)  
ab82 32 b9 ee			ld (debug_mark+2),a  
ab85 18 03			jr .pastdmark  
ab87 ..			.dmark: db "IF1"  
ab8a f1			.pastdmark: pop af  
ab8b			endm  
# End of macro DMARK
ab8b						CALLMONITOR 
ab8b cd a3 92			call break_point_state  
ab8e				endm  
# End of macro CALLMONITOR
ab8e					endif 
ab8e b7				or a        ; clear carry flag 
ab8f 11 00 00			ld de, 0 
ab92 eb				ex de,hl 
ab93 ed 52			sbc hl, de 
ab95 c2 1f ac			jp nz, .iftrue 
ab98			 
ab98					if DEBUG_FORTH_WORDS 
ab98						DMARK "IF2" 
ab98 f5				push af  
ab99 3a ad ab			ld a, (.dmark)  
ab9c 32 b7 ee			ld (debug_mark),a  
ab9f 3a ae ab			ld a, (.dmark+1)  
aba2 32 b8 ee			ld (debug_mark+1),a  
aba5 3a af ab			ld a, (.dmark+2)  
aba8 32 b9 ee			ld (debug_mark+2),a  
abab 18 03			jr .pastdmark  
abad ..			.dmark: db "IF2"  
abb0 f1			.pastdmark: pop af  
abb1			endm  
# End of macro DMARK
abb1						CALLMONITOR 
abb1 cd a3 92			call break_point_state  
abb4				endm  
# End of macro CALLMONITOR
abb4					endif 
abb4			 
abb4			; if not true then skip to THEN 
abb4			 
abb4				; TODO get tok_ptr 
abb4				; TODO consume toks until we get to THEN 
abb4			 
abb4 2a de e7			ld hl, (os_tok_ptr) 
abb7					if DEBUG_FORTH_WORDS 
abb7						DMARK "IF3" 
abb7 f5				push af  
abb8 3a cc ab			ld a, (.dmark)  
abbb 32 b7 ee			ld (debug_mark),a  
abbe 3a cd ab			ld a, (.dmark+1)  
abc1 32 b8 ee			ld (debug_mark+1),a  
abc4 3a ce ab			ld a, (.dmark+2)  
abc7 32 b9 ee			ld (debug_mark+2),a  
abca 18 03			jr .pastdmark  
abcc ..			.dmark: db "IF3"  
abcf f1			.pastdmark: pop af  
abd0			endm  
# End of macro DMARK
abd0						CALLMONITOR 
abd0 cd a3 92			call break_point_state  
abd3				endm  
# End of macro CALLMONITOR
abd3						 
abd3					endif 
abd3 11 1a ac			ld de, .ifthen 
abd6					if DEBUG_FORTH_WORDS 
abd6						DMARK "IF4" 
abd6 f5				push af  
abd7 3a eb ab			ld a, (.dmark)  
abda 32 b7 ee			ld (debug_mark),a  
abdd 3a ec ab			ld a, (.dmark+1)  
abe0 32 b8 ee			ld (debug_mark+1),a  
abe3 3a ed ab			ld a, (.dmark+2)  
abe6 32 b9 ee			ld (debug_mark+2),a  
abe9 18 03			jr .pastdmark  
abeb ..			.dmark: db "IF4"  
abee f1			.pastdmark: pop af  
abef			endm  
# End of macro DMARK
abef						CALLMONITOR 
abef cd a3 92			call break_point_state  
abf2				endm  
# End of macro CALLMONITOR
abf2					endif 
abf2 cd 81 9d			call findnexttok  
abf5			 
abf5					if DEBUG_FORTH_WORDS 
abf5						DMARK "IF5" 
abf5 f5				push af  
abf6 3a 0a ac			ld a, (.dmark)  
abf9 32 b7 ee			ld (debug_mark),a  
abfc 3a 0b ac			ld a, (.dmark+1)  
abff 32 b8 ee			ld (debug_mark+1),a  
ac02 3a 0c ac			ld a, (.dmark+2)  
ac05 32 b9 ee			ld (debug_mark+2),a  
ac08 18 03			jr .pastdmark  
ac0a ..			.dmark: db "IF5"  
ac0d f1			.pastdmark: pop af  
ac0e			endm  
# End of macro DMARK
ac0e						CALLMONITOR 
ac0e cd a3 92			call break_point_state  
ac11				endm  
# End of macro CALLMONITOR
ac11					endif 
ac11				; TODO replace below with ; exec using tok_ptr 
ac11 22 de e7			ld (os_tok_ptr), hl 
ac14 c3 f7 9c			jp exec1 
ac17				NEXTW 
ac17 c3 66 9c			jp macro_next 
ac1a				endm 
# End of macro NEXTW
ac1a			 
ac1a .. 00		.ifthen:  db "THEN",0 
ac1f			 
ac1f			.iftrue:		 
ac1f				; Exec next words normally 
ac1f			 
ac1f				; if true then exec following IF as normal 
ac1f					if DEBUG_FORTH_WORDS 
ac1f						DMARK "IFT" 
ac1f f5				push af  
ac20 3a 34 ac			ld a, (.dmark)  
ac23 32 b7 ee			ld (debug_mark),a  
ac26 3a 35 ac			ld a, (.dmark+1)  
ac29 32 b8 ee			ld (debug_mark+1),a  
ac2c 3a 36 ac			ld a, (.dmark+2)  
ac2f 32 b9 ee			ld (debug_mark+2),a  
ac32 18 03			jr .pastdmark  
ac34 ..			.dmark: db "IFT"  
ac37 f1			.pastdmark: pop af  
ac38			endm  
# End of macro DMARK
ac38						CALLMONITOR 
ac38 cd a3 92			call break_point_state  
ac3b				endm  
# End of macro CALLMONITOR
ac3b					endif 
ac3b			 
ac3b					NEXTW 
ac3b c3 66 9c			jp macro_next 
ac3e				endm 
# End of macro NEXTW
ac3e			.THEN: 
ac3e				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ac3e 1f				db WORD_SYS_CORE+11             
ac3f 66 ac			dw .ELSE            
ac41 05				db 4 + 1 
ac42 .. 00			db "THEN",0              
ac47				endm 
# End of macro CWHEAD
ac47			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ac47					if DEBUG_FORTH_WORDS_KEY 
ac47						DMARK "THN" 
ac47 f5				push af  
ac48 3a 5c ac			ld a, (.dmark)  
ac4b 32 b7 ee			ld (debug_mark),a  
ac4e 3a 5d ac			ld a, (.dmark+1)  
ac51 32 b8 ee			ld (debug_mark+1),a  
ac54 3a 5e ac			ld a, (.dmark+2)  
ac57 32 b9 ee			ld (debug_mark+2),a  
ac5a 18 03			jr .pastdmark  
ac5c ..			.dmark: db "THN"  
ac5f f1			.pastdmark: pop af  
ac60			endm  
# End of macro DMARK
ac60						CALLMONITOR 
ac60 cd a3 92			call break_point_state  
ac63				endm  
# End of macro CALLMONITOR
ac63					endif 
ac63					NEXTW 
ac63 c3 66 9c			jp macro_next 
ac66				endm 
# End of macro NEXTW
ac66			.ELSE: 
ac66				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ac66 20				db WORD_SYS_CORE+12             
ac67 8e ac			dw .DO            
ac69 03				db 2 + 1 
ac6a .. 00			db "ELSE",0              
ac6f				endm 
# End of macro CWHEAD
ac6f			; | ELSE ( -- ) Not supported - does nothing | TODO 
ac6f			 
ac6f					if DEBUG_FORTH_WORDS_KEY 
ac6f						DMARK "ELS" 
ac6f f5				push af  
ac70 3a 84 ac			ld a, (.dmark)  
ac73 32 b7 ee			ld (debug_mark),a  
ac76 3a 85 ac			ld a, (.dmark+1)  
ac79 32 b8 ee			ld (debug_mark+1),a  
ac7c 3a 86 ac			ld a, (.dmark+2)  
ac7f 32 b9 ee			ld (debug_mark+2),a  
ac82 18 03			jr .pastdmark  
ac84 ..			.dmark: db "ELS"  
ac87 f1			.pastdmark: pop af  
ac88			endm  
# End of macro DMARK
ac88						CALLMONITOR 
ac88 cd a3 92			call break_point_state  
ac8b				endm  
# End of macro CALLMONITOR
ac8b					endif 
ac8b			 
ac8b			 
ac8b					NEXTW 
ac8b c3 66 9c			jp macro_next 
ac8e				endm 
# End of macro NEXTW
ac8e			.DO: 
ac8e				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ac8e 21				db WORD_SYS_CORE+13             
ac8f b5 ad			dw .LOOP            
ac91 03				db 2 + 1 
ac92 .. 00			db "DO",0              
ac95				endm 
# End of macro CWHEAD
ac95			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ac95			 
ac95					if DEBUG_FORTH_WORDS_KEY 
ac95						DMARK "DO." 
ac95 f5				push af  
ac96 3a aa ac			ld a, (.dmark)  
ac99 32 b7 ee			ld (debug_mark),a  
ac9c 3a ab ac			ld a, (.dmark+1)  
ac9f 32 b8 ee			ld (debug_mark+1),a  
aca2 3a ac ac			ld a, (.dmark+2)  
aca5 32 b9 ee			ld (debug_mark+2),a  
aca8 18 03			jr .pastdmark  
acaa ..			.dmark: db "DO."  
acad f1			.pastdmark: pop af  
acae			endm  
# End of macro DMARK
acae						CALLMONITOR 
acae cd a3 92			call break_point_state  
acb1				endm  
# End of macro CALLMONITOR
acb1					endif 
acb1			;  push pc to rsp stack past the DO 
acb1			 
acb1 2a de e7				ld hl, (os_tok_ptr) 
acb4 23					inc hl   ; D 
acb5 23					inc hl  ; O 
acb6 23					inc hl   ; null 
acb7					if DEBUG_FORTH_WORDS 
acb7						DMARK "DO2" 
acb7 f5				push af  
acb8 3a cc ac			ld a, (.dmark)  
acbb 32 b7 ee			ld (debug_mark),a  
acbe 3a cd ac			ld a, (.dmark+1)  
acc1 32 b8 ee			ld (debug_mark+1),a  
acc4 3a ce ac			ld a, (.dmark+2)  
acc7 32 b9 ee			ld (debug_mark+2),a  
acca 18 03			jr .pastdmark  
accc ..			.dmark: db "DO2"  
accf f1			.pastdmark: pop af  
acd0			endm  
# End of macro DMARK
acd0						CALLMONITOR 
acd0 cd a3 92			call break_point_state  
acd3				endm  
# End of macro CALLMONITOR
acd3					endif 
acd3					FORTH_RSP_NEXT 
acd3 cd a4 98			call macro_forth_rsp_next 
acd6				endm 
# End of macro FORTH_RSP_NEXT
acd6					if DEBUG_FORTH_WORDS 
acd6						DMARK "DO3" 
acd6 f5				push af  
acd7 3a eb ac			ld a, (.dmark)  
acda 32 b7 ee			ld (debug_mark),a  
acdd 3a ec ac			ld a, (.dmark+1)  
ace0 32 b8 ee			ld (debug_mark+1),a  
ace3 3a ed ac			ld a, (.dmark+2)  
ace6 32 b9 ee			ld (debug_mark+2),a  
ace9 18 03			jr .pastdmark  
aceb ..			.dmark: db "DO3"  
acee f1			.pastdmark: pop af  
acef			endm  
# End of macro DMARK
acef						CALLMONITOR 
acef cd a3 92			call break_point_state  
acf2				endm  
# End of macro CALLMONITOR
acf2					endif 
acf2			 
acf2					;if DEBUG_FORTH_WORDS 
acf2				;		push hl 
acf2			;		endif  
acf2			 
acf2			; get counters from data stack 
acf2			 
acf2			 
acf2					FORTH_DSP_VALUEHL 
acf2 cd f4 9a			call macro_dsp_valuehl 
acf5				endm 
# End of macro FORTH_DSP_VALUEHL
acf5 e5					push hl		 ; hl now has starting counter which needs to be tos 
acf6			 
acf6					if DEBUG_FORTH_WORDS 
acf6						DMARK "DO4" 
acf6 f5				push af  
acf7 3a 0b ad			ld a, (.dmark)  
acfa 32 b7 ee			ld (debug_mark),a  
acfd 3a 0c ad			ld a, (.dmark+1)  
ad00 32 b8 ee			ld (debug_mark+1),a  
ad03 3a 0d ad			ld a, (.dmark+2)  
ad06 32 b9 ee			ld (debug_mark+2),a  
ad09 18 03			jr .pastdmark  
ad0b ..			.dmark: db "DO4"  
ad0e f1			.pastdmark: pop af  
ad0f			endm  
# End of macro DMARK
ad0f						CALLMONITOR 
ad0f cd a3 92			call break_point_state  
ad12				endm  
# End of macro CALLMONITOR
ad12					endif 
ad12					FORTH_DSP_POP 
ad12 cd ac 9b			call macro_forth_dsp_pop 
ad15				endm 
# End of macro FORTH_DSP_POP
ad15			 
ad15					if DEBUG_FORTH_WORDS 
ad15						DMARK "DO5" 
ad15 f5				push af  
ad16 3a 2a ad			ld a, (.dmark)  
ad19 32 b7 ee			ld (debug_mark),a  
ad1c 3a 2b ad			ld a, (.dmark+1)  
ad1f 32 b8 ee			ld (debug_mark+1),a  
ad22 3a 2c ad			ld a, (.dmark+2)  
ad25 32 b9 ee			ld (debug_mark+2),a  
ad28 18 03			jr .pastdmark  
ad2a ..			.dmark: db "DO5"  
ad2d f1			.pastdmark: pop af  
ad2e			endm  
# End of macro DMARK
ad2e						CALLMONITOR 
ad2e cd a3 92			call break_point_state  
ad31				endm  
# End of macro CALLMONITOR
ad31					endif 
ad31			 
ad31					FORTH_DSP_VALUEHL 
ad31 cd f4 9a			call macro_dsp_valuehl 
ad34				endm 
# End of macro FORTH_DSP_VALUEHL
ad34			;		push hl		 ; hl now has starting limit counter 
ad34			 
ad34					if DEBUG_FORTH_WORDS 
ad34						DMARK "DO6" 
ad34 f5				push af  
ad35 3a 49 ad			ld a, (.dmark)  
ad38 32 b7 ee			ld (debug_mark),a  
ad3b 3a 4a ad			ld a, (.dmark+1)  
ad3e 32 b8 ee			ld (debug_mark+1),a  
ad41 3a 4b ad			ld a, (.dmark+2)  
ad44 32 b9 ee			ld (debug_mark+2),a  
ad47 18 03			jr .pastdmark  
ad49 ..			.dmark: db "DO6"  
ad4c f1			.pastdmark: pop af  
ad4d			endm  
# End of macro DMARK
ad4d						CALLMONITOR 
ad4d cd a3 92			call break_point_state  
ad50				endm  
# End of macro CALLMONITOR
ad50					endif 
ad50					FORTH_DSP_POP 
ad50 cd ac 9b			call macro_forth_dsp_pop 
ad53				endm 
# End of macro FORTH_DSP_POP
ad53			 
ad53			; put counters on the loop stack 
ad53			 
ad53			;		pop hl			 ; limit counter 
ad53 d1					pop de			; start counter 
ad54			 
ad54					; push limit counter 
ad54			 
ad54					if DEBUG_FORTH_WORDS 
ad54						DMARK "DO7" 
ad54 f5				push af  
ad55 3a 69 ad			ld a, (.dmark)  
ad58 32 b7 ee			ld (debug_mark),a  
ad5b 3a 6a ad			ld a, (.dmark+1)  
ad5e 32 b8 ee			ld (debug_mark+1),a  
ad61 3a 6b ad			ld a, (.dmark+2)  
ad64 32 b9 ee			ld (debug_mark+2),a  
ad67 18 03			jr .pastdmark  
ad69 ..			.dmark: db "DO7"  
ad6c f1			.pastdmark: pop af  
ad6d			endm  
# End of macro DMARK
ad6d						CALLMONITOR 
ad6d cd a3 92			call break_point_state  
ad70				endm  
# End of macro CALLMONITOR
ad70					endif 
ad70					FORTH_LOOP_NEXT 
ad70 cd 25 9b			call macro_forth_loop_next 
ad73				endm 
# End of macro FORTH_LOOP_NEXT
ad73			 
ad73					; push start counter 
ad73			 
ad73 eb					ex de, hl 
ad74					if DEBUG_FORTH_WORDS 
ad74						DMARK "DO7" 
ad74 f5				push af  
ad75 3a 89 ad			ld a, (.dmark)  
ad78 32 b7 ee			ld (debug_mark),a  
ad7b 3a 8a ad			ld a, (.dmark+1)  
ad7e 32 b8 ee			ld (debug_mark+1),a  
ad81 3a 8b ad			ld a, (.dmark+2)  
ad84 32 b9 ee			ld (debug_mark+2),a  
ad87 18 03			jr .pastdmark  
ad89 ..			.dmark: db "DO7"  
ad8c f1			.pastdmark: pop af  
ad8d			endm  
# End of macro DMARK
ad8d						CALLMONITOR 
ad8d cd a3 92			call break_point_state  
ad90				endm  
# End of macro CALLMONITOR
ad90					endif 
ad90					FORTH_LOOP_NEXT 
ad90 cd 25 9b			call macro_forth_loop_next 
ad93				endm 
# End of macro FORTH_LOOP_NEXT
ad93			 
ad93			 
ad93					; init first round of I counter 
ad93			 
ad93 22 02 e8				ld (os_current_i), hl 
ad96			 
ad96					if DEBUG_FORTH_WORDS 
ad96						DMARK "DO8" 
ad96 f5				push af  
ad97 3a ab ad			ld a, (.dmark)  
ad9a 32 b7 ee			ld (debug_mark),a  
ad9d 3a ac ad			ld a, (.dmark+1)  
ada0 32 b8 ee			ld (debug_mark+1),a  
ada3 3a ad ad			ld a, (.dmark+2)  
ada6 32 b9 ee			ld (debug_mark+2),a  
ada9 18 03			jr .pastdmark  
adab ..			.dmark: db "DO8"  
adae f1			.pastdmark: pop af  
adaf			endm  
# End of macro DMARK
adaf						CALLMONITOR 
adaf cd a3 92			call break_point_state  
adb2				endm  
# End of macro CALLMONITOR
adb2					endif 
adb2			 
adb2					NEXTW 
adb2 c3 66 9c			jp macro_next 
adb5				endm 
# End of macro NEXTW
adb5			.LOOP: 
adb5				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
adb5 22				db WORD_SYS_CORE+14             
adb6 cd ae			dw .I            
adb8 05				db 4 + 1 
adb9 .. 00			db "LOOP",0              
adbe				endm 
# End of macro CWHEAD
adbe			; | LOOP ( -- ) Increment and test loop counter  | DONE 
adbe			 
adbe				; pop tos as current loop count to hl 
adbe			 
adbe				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
adbe			 
adbe				FORTH_LOOP_TOS 
adbe cd 58 9b			call macro_forth_loop_tos 
adc1				endm 
# End of macro FORTH_LOOP_TOS
adc1 e5				push hl 
adc2			 
adc2					if DEBUG_FORTH_WORDS_KEY 
adc2						DMARK "LOP" 
adc2 f5				push af  
adc3 3a d7 ad			ld a, (.dmark)  
adc6 32 b7 ee			ld (debug_mark),a  
adc9 3a d8 ad			ld a, (.dmark+1)  
adcc 32 b8 ee			ld (debug_mark+1),a  
adcf 3a d9 ad			ld a, (.dmark+2)  
add2 32 b9 ee			ld (debug_mark+2),a  
add5 18 03			jr .pastdmark  
add7 ..			.dmark: db "LOP"  
adda f1			.pastdmark: pop af  
addb			endm  
# End of macro DMARK
addb						CALLMONITOR 
addb cd a3 92			call break_point_state  
adde				endm  
# End of macro CALLMONITOR
adde					endif 
adde				; next item on the stack is the limit. get it 
adde			 
adde			 
adde				FORTH_LOOP_POP 
adde cd 62 9b			call macro_forth_loop_pop 
ade1				endm 
# End of macro FORTH_LOOP_POP
ade1			 
ade1				FORTH_LOOP_TOS 
ade1 cd 58 9b			call macro_forth_loop_tos 
ade4				endm 
# End of macro FORTH_LOOP_TOS
ade4			 
ade4 d1				pop de		 ; de = i, hl = limit 
ade5			 
ade5					if DEBUG_FORTH_WORDS 
ade5						DMARK "LP1" 
ade5 f5				push af  
ade6 3a fa ad			ld a, (.dmark)  
ade9 32 b7 ee			ld (debug_mark),a  
adec 3a fb ad			ld a, (.dmark+1)  
adef 32 b8 ee			ld (debug_mark+1),a  
adf2 3a fc ad			ld a, (.dmark+2)  
adf5 32 b9 ee			ld (debug_mark+2),a  
adf8 18 03			jr .pastdmark  
adfa ..			.dmark: db "LP1"  
adfd f1			.pastdmark: pop af  
adfe			endm  
# End of macro DMARK
adfe						CALLMONITOR 
adfe cd a3 92			call break_point_state  
ae01				endm  
# End of macro CALLMONITOR
ae01					endif 
ae01			 
ae01				; go back to previous word 
ae01			 
ae01 d5				push de    ; save I for inc later 
ae02			 
ae02			 
ae02				; get limit 
ae02				;  is I at limit? 
ae02			 
ae02			 
ae02					if DEBUG_FORTH_WORDS 
ae02						DMARK "LP1" 
ae02 f5				push af  
ae03 3a 17 ae			ld a, (.dmark)  
ae06 32 b7 ee			ld (debug_mark),a  
ae09 3a 18 ae			ld a, (.dmark+1)  
ae0c 32 b8 ee			ld (debug_mark+1),a  
ae0f 3a 19 ae			ld a, (.dmark+2)  
ae12 32 b9 ee			ld (debug_mark+2),a  
ae15 18 03			jr .pastdmark  
ae17 ..			.dmark: db "LP1"  
ae1a f1			.pastdmark: pop af  
ae1b			endm  
# End of macro DMARK
ae1b						CALLMONITOR 
ae1b cd a3 92			call break_point_state  
ae1e				endm  
# End of macro CALLMONITOR
ae1e					endif 
ae1e			 
ae1e ed 52			sbc hl, de 
ae20			 
ae20			 
ae20				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ae20			 
ae20 20 26				jr nz, .loopnotdone 
ae22			 
ae22 e1				pop hl   ; get rid of saved I 
ae23				FORTH_LOOP_POP     ; get rid of limit 
ae23 cd 62 9b			call macro_forth_loop_pop 
ae26				endm 
# End of macro FORTH_LOOP_POP
ae26			 
ae26				FORTH_RSP_POP     ; get rid of DO ptr 
ae26 cd c5 98			call macro_forth_rsp_pop 
ae29				endm 
# End of macro FORTH_RSP_POP
ae29			 
ae29			if DEBUG_FORTH_WORDS 
ae29						DMARK "LP>" 
ae29 f5				push af  
ae2a 3a 3e ae			ld a, (.dmark)  
ae2d 32 b7 ee			ld (debug_mark),a  
ae30 3a 3f ae			ld a, (.dmark+1)  
ae33 32 b8 ee			ld (debug_mark+1),a  
ae36 3a 40 ae			ld a, (.dmark+2)  
ae39 32 b9 ee			ld (debug_mark+2),a  
ae3c 18 03			jr .pastdmark  
ae3e ..			.dmark: db "LP>"  
ae41 f1			.pastdmark: pop af  
ae42			endm  
# End of macro DMARK
ae42				CALLMONITOR 
ae42 cd a3 92			call break_point_state  
ae45				endm  
# End of macro CALLMONITOR
ae45			endif 
ae45			 
ae45					NEXTW 
ae45 c3 66 9c			jp macro_next 
ae48				endm 
# End of macro NEXTW
ae48				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ae48			 
ae48			.loopnotdone: 
ae48			 
ae48 e1				pop hl    ; get I 
ae49 23				inc hl 
ae4a			 
ae4a			   	; save new I 
ae4a			 
ae4a			 
ae4a					; set I counter 
ae4a			 
ae4a 22 02 e8				ld (os_current_i), hl 
ae4d			 
ae4d					if DEBUG_FORTH_WORDS 
ae4d						DMARK "LPN" 
ae4d f5				push af  
ae4e 3a 62 ae			ld a, (.dmark)  
ae51 32 b7 ee			ld (debug_mark),a  
ae54 3a 63 ae			ld a, (.dmark+1)  
ae57 32 b8 ee			ld (debug_mark+1),a  
ae5a 3a 64 ae			ld a, (.dmark+2)  
ae5d 32 b9 ee			ld (debug_mark+2),a  
ae60 18 03			jr .pastdmark  
ae62 ..			.dmark: db "LPN"  
ae65 f1			.pastdmark: pop af  
ae66			endm  
# End of macro DMARK
ae66					CALLMONITOR 
ae66 cd a3 92			call break_point_state  
ae69				endm  
# End of macro CALLMONITOR
ae69					endif 
ae69					 
ae69				FORTH_LOOP_NEXT 
ae69 cd 25 9b			call macro_forth_loop_next 
ae6c				endm 
# End of macro FORTH_LOOP_NEXT
ae6c			 
ae6c			 
ae6c					if DEBUG_FORTH_WORDS 
ae6c eb						ex de,hl 
ae6d					endif 
ae6d			 
ae6d			;	; get DO ptr 
ae6d			; 
ae6d					if DEBUG_FORTH_WORDS 
ae6d						DMARK "LP7" 
ae6d f5				push af  
ae6e 3a 82 ae			ld a, (.dmark)  
ae71 32 b7 ee			ld (debug_mark),a  
ae74 3a 83 ae			ld a, (.dmark+1)  
ae77 32 b8 ee			ld (debug_mark+1),a  
ae7a 3a 84 ae			ld a, (.dmark+2)  
ae7d 32 b9 ee			ld (debug_mark+2),a  
ae80 18 03			jr .pastdmark  
ae82 ..			.dmark: db "LP7"  
ae85 f1			.pastdmark: pop af  
ae86			endm  
# End of macro DMARK
ae86					CALLMONITOR 
ae86 cd a3 92			call break_point_state  
ae89				endm  
# End of macro CALLMONITOR
ae89					endif 
ae89				FORTH_RSP_TOS 
ae89 cd bb 98			call macro_forth_rsp_tos 
ae8c				endm 
# End of macro FORTH_RSP_TOS
ae8c			 
ae8c					if DEBUG_FORTH_WORDS 
ae8c						DMARK "LP8" 
ae8c f5				push af  
ae8d 3a a1 ae			ld a, (.dmark)  
ae90 32 b7 ee			ld (debug_mark),a  
ae93 3a a2 ae			ld a, (.dmark+1)  
ae96 32 b8 ee			ld (debug_mark+1),a  
ae99 3a a3 ae			ld a, (.dmark+2)  
ae9c 32 b9 ee			ld (debug_mark+2),a  
ae9f 18 03			jr .pastdmark  
aea1 ..			.dmark: db "LP8"  
aea4 f1			.pastdmark: pop af  
aea5			endm  
# End of macro DMARK
aea5					CALLMONITOR 
aea5 cd a3 92			call break_point_state  
aea8				endm  
# End of macro CALLMONITOR
aea8					endif 
aea8				;push hl 
aea8			 
aea8				; not going to DO any more 
aea8				; get rid of the RSP pointer as DO will add it back in 
aea8				;FORTH_RSP_POP 
aea8				;pop hl 
aea8			 
aea8				;ld hl,(cli_ret_sp) 
aea8				;ld e, (hl) 
aea8				;inc hl 
aea8				;ld d, (hl) 
aea8				;ex de,hl 
aea8 22 de e7			ld (os_tok_ptr), hl 
aeab					if DEBUG_FORTH_WORDS 
aeab						DMARK "LP<" 
aeab f5				push af  
aeac 3a c0 ae			ld a, (.dmark)  
aeaf 32 b7 ee			ld (debug_mark),a  
aeb2 3a c1 ae			ld a, (.dmark+1)  
aeb5 32 b8 ee			ld (debug_mark+1),a  
aeb8 3a c2 ae			ld a, (.dmark+2)  
aebb 32 b9 ee			ld (debug_mark+2),a  
aebe 18 03			jr .pastdmark  
aec0 ..			.dmark: db "LP<"  
aec3 f1			.pastdmark: pop af  
aec4			endm  
# End of macro DMARK
aec4					CALLMONITOR 
aec4 cd a3 92			call break_point_state  
aec7				endm  
# End of macro CALLMONITOR
aec7				endif 
aec7 c3 f7 9c			jp exec1 
aeca			 
aeca					 
aeca			 
aeca			 
aeca					NEXTW 
aeca c3 66 9c			jp macro_next 
aecd				endm 
# End of macro NEXTW
aecd			.I:  
aecd			 
aecd				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
aecd 5e				db WORD_SYS_CORE+74             
aece f8 ae			dw .DLOOP            
aed0 02				db 1 + 1 
aed1 .. 00			db "I",0              
aed3				endm 
# End of macro CWHEAD
aed3			; | I ( -- ) Current loop counter | DONE 
aed3					if DEBUG_FORTH_WORDS_KEY 
aed3						DMARK "I.." 
aed3 f5				push af  
aed4 3a e8 ae			ld a, (.dmark)  
aed7 32 b7 ee			ld (debug_mark),a  
aeda 3a e9 ae			ld a, (.dmark+1)  
aedd 32 b8 ee			ld (debug_mark+1),a  
aee0 3a ea ae			ld a, (.dmark+2)  
aee3 32 b9 ee			ld (debug_mark+2),a  
aee6 18 03			jr .pastdmark  
aee8 ..			.dmark: db "I.."  
aeeb f1			.pastdmark: pop af  
aeec			endm  
# End of macro DMARK
aeec						CALLMONITOR 
aeec cd a3 92			call break_point_state  
aeef				endm  
# End of macro CALLMONITOR
aeef					endif 
aeef			 
aeef 2a 02 e8				ld hl,(os_current_i) 
aef2 cd fd 98				call forth_push_numhl 
aef5			 
aef5					NEXTW 
aef5 c3 66 9c			jp macro_next 
aef8				endm 
# End of macro NEXTW
aef8			.DLOOP: 
aef8				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
aef8 5f				db WORD_SYS_CORE+75             
aef9 d9 af			dw .REPEAT            
aefb 06				db 5 + 1 
aefc .. 00			db "-LOOP",0              
af02				endm 
# End of macro CWHEAD
af02			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
af02				; pop tos as current loop count to hl 
af02					if DEBUG_FORTH_WORDS_KEY 
af02						DMARK "-LP" 
af02 f5				push af  
af03 3a 17 af			ld a, (.dmark)  
af06 32 b7 ee			ld (debug_mark),a  
af09 3a 18 af			ld a, (.dmark+1)  
af0c 32 b8 ee			ld (debug_mark+1),a  
af0f 3a 19 af			ld a, (.dmark+2)  
af12 32 b9 ee			ld (debug_mark+2),a  
af15 18 03			jr .pastdmark  
af17 ..			.dmark: db "-LP"  
af1a f1			.pastdmark: pop af  
af1b			endm  
# End of macro DMARK
af1b						CALLMONITOR 
af1b cd a3 92			call break_point_state  
af1e				endm  
# End of macro CALLMONITOR
af1e					endif 
af1e			 
af1e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
af1e			 
af1e				FORTH_LOOP_TOS 
af1e cd 58 9b			call macro_forth_loop_tos 
af21				endm 
# End of macro FORTH_LOOP_TOS
af21 e5				push hl 
af22			 
af22					if DEBUG_FORTH_WORDS 
af22						DMARK "-LP" 
af22 f5				push af  
af23 3a 37 af			ld a, (.dmark)  
af26 32 b7 ee			ld (debug_mark),a  
af29 3a 38 af			ld a, (.dmark+1)  
af2c 32 b8 ee			ld (debug_mark+1),a  
af2f 3a 39 af			ld a, (.dmark+2)  
af32 32 b9 ee			ld (debug_mark+2),a  
af35 18 03			jr .pastdmark  
af37 ..			.dmark: db "-LP"  
af3a f1			.pastdmark: pop af  
af3b			endm  
# End of macro DMARK
af3b						CALLMONITOR 
af3b cd a3 92			call break_point_state  
af3e				endm  
# End of macro CALLMONITOR
af3e					endif 
af3e				; next item on the stack is the limit. get it 
af3e			 
af3e			 
af3e				FORTH_LOOP_POP 
af3e cd 62 9b			call macro_forth_loop_pop 
af41				endm 
# End of macro FORTH_LOOP_POP
af41			 
af41				FORTH_LOOP_TOS 
af41 cd 58 9b			call macro_forth_loop_tos 
af44				endm 
# End of macro FORTH_LOOP_TOS
af44			 
af44 d1				pop de		 ; de = i, hl = limit 
af45			 
af45					if DEBUG_FORTH_WORDS 
af45						DMARK "-L1" 
af45 f5				push af  
af46 3a 5a af			ld a, (.dmark)  
af49 32 b7 ee			ld (debug_mark),a  
af4c 3a 5b af			ld a, (.dmark+1)  
af4f 32 b8 ee			ld (debug_mark+1),a  
af52 3a 5c af			ld a, (.dmark+2)  
af55 32 b9 ee			ld (debug_mark+2),a  
af58 18 03			jr .pastdmark  
af5a ..			.dmark: db "-L1"  
af5d f1			.pastdmark: pop af  
af5e			endm  
# End of macro DMARK
af5e						CALLMONITOR 
af5e cd a3 92			call break_point_state  
af61				endm  
# End of macro CALLMONITOR
af61					endif 
af61			 
af61				; go back to previous word 
af61			 
af61 d5				push de    ; save I for inc later 
af62			 
af62			 
af62				; get limit 
af62				;  is I at limit? 
af62			 
af62			 
af62					if DEBUG_FORTH_WORDS 
af62						DMARK "-L1" 
af62 f5				push af  
af63 3a 77 af			ld a, (.dmark)  
af66 32 b7 ee			ld (debug_mark),a  
af69 3a 78 af			ld a, (.dmark+1)  
af6c 32 b8 ee			ld (debug_mark+1),a  
af6f 3a 79 af			ld a, (.dmark+2)  
af72 32 b9 ee			ld (debug_mark+2),a  
af75 18 03			jr .pastdmark  
af77 ..			.dmark: db "-L1"  
af7a f1			.pastdmark: pop af  
af7b			endm  
# End of macro DMARK
af7b						CALLMONITOR 
af7b cd a3 92			call break_point_state  
af7e				endm  
# End of macro CALLMONITOR
af7e					endif 
af7e			 
af7e ed 52			sbc hl, de 
af80			 
af80			 
af80				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af80			 
af80 20 26				jr nz, .mloopnotdone 
af82			 
af82 e1				pop hl   ; get rid of saved I 
af83				FORTH_LOOP_POP     ; get rid of limit 
af83 cd 62 9b			call macro_forth_loop_pop 
af86				endm 
# End of macro FORTH_LOOP_POP
af86			 
af86				FORTH_RSP_POP     ; get rid of DO ptr 
af86 cd c5 98			call macro_forth_rsp_pop 
af89				endm 
# End of macro FORTH_RSP_POP
af89			 
af89			if DEBUG_FORTH_WORDS 
af89						DMARK "-L>" 
af89 f5				push af  
af8a 3a 9e af			ld a, (.dmark)  
af8d 32 b7 ee			ld (debug_mark),a  
af90 3a 9f af			ld a, (.dmark+1)  
af93 32 b8 ee			ld (debug_mark+1),a  
af96 3a a0 af			ld a, (.dmark+2)  
af99 32 b9 ee			ld (debug_mark+2),a  
af9c 18 03			jr .pastdmark  
af9e ..			.dmark: db "-L>"  
afa1 f1			.pastdmark: pop af  
afa2			endm  
# End of macro DMARK
afa2				CALLMONITOR 
afa2 cd a3 92			call break_point_state  
afa5				endm  
# End of macro CALLMONITOR
afa5			endif 
afa5			 
afa5					NEXTW 
afa5 c3 66 9c			jp macro_next 
afa8				endm 
# End of macro NEXTW
afa8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
afa8			 
afa8			.mloopnotdone: 
afa8			 
afa8 e1				pop hl    ; get I 
afa9 2b				dec hl 
afaa			 
afaa			   	; save new I 
afaa			 
afaa			 
afaa					; set I counter 
afaa			 
afaa 22 02 e8				ld (os_current_i), hl 
afad			 
afad					 
afad				FORTH_LOOP_NEXT 
afad cd 25 9b			call macro_forth_loop_next 
afb0				endm 
# End of macro FORTH_LOOP_NEXT
afb0			 
afb0			 
afb0					if DEBUG_FORTH_WORDS 
afb0 eb						ex de,hl 
afb1					endif 
afb1			 
afb1			;	; get DO ptr 
afb1			; 
afb1				FORTH_RSP_TOS 
afb1 cd bb 98			call macro_forth_rsp_tos 
afb4				endm 
# End of macro FORTH_RSP_TOS
afb4			 
afb4				;push hl 
afb4			 
afb4				; not going to DO any more 
afb4				; get rid of the RSP pointer as DO will add it back in 
afb4				;FORTH_RSP_POP 
afb4				;pop hl 
afb4			 
afb4			 
afb4 22 de e7			ld (os_tok_ptr), hl 
afb7					if DEBUG_FORTH_WORDS 
afb7						DMARK "-L<" 
afb7 f5				push af  
afb8 3a cc af			ld a, (.dmark)  
afbb 32 b7 ee			ld (debug_mark),a  
afbe 3a cd af			ld a, (.dmark+1)  
afc1 32 b8 ee			ld (debug_mark+1),a  
afc4 3a ce af			ld a, (.dmark+2)  
afc7 32 b9 ee			ld (debug_mark+2),a  
afca 18 03			jr .pastdmark  
afcc ..			.dmark: db "-L<"  
afcf f1			.pastdmark: pop af  
afd0			endm  
# End of macro DMARK
afd0					CALLMONITOR 
afd0 cd a3 92			call break_point_state  
afd3				endm  
# End of macro CALLMONITOR
afd3				endif 
afd3 c3 f7 9c			jp exec1 
afd6			 
afd6					 
afd6			 
afd6			 
afd6			 
afd6				NEXTW 
afd6 c3 66 9c			jp macro_next 
afd9				endm 
# End of macro NEXTW
afd9			 
afd9			 
afd9			 
afd9			 
afd9			.REPEAT: 
afd9				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
afd9 71				db WORD_SYS_CORE+93             
afda 2c b0			dw .UNTIL            
afdc 06				db 5 + 1 
afdd .. 00			db "REPEAT",0              
afe4				endm 
# End of macro CWHEAD
afe4			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
afe4			;  push pc to rsp stack past the REPEAT 
afe4					if DEBUG_FORTH_WORDS_KEY 
afe4						DMARK "REP" 
afe4 f5				push af  
afe5 3a f9 af			ld a, (.dmark)  
afe8 32 b7 ee			ld (debug_mark),a  
afeb 3a fa af			ld a, (.dmark+1)  
afee 32 b8 ee			ld (debug_mark+1),a  
aff1 3a fb af			ld a, (.dmark+2)  
aff4 32 b9 ee			ld (debug_mark+2),a  
aff7 18 03			jr .pastdmark  
aff9 ..			.dmark: db "REP"  
affc f1			.pastdmark: pop af  
affd			endm  
# End of macro DMARK
affd						CALLMONITOR 
affd cd a3 92			call break_point_state  
b000				endm  
# End of macro CALLMONITOR
b000					endif 
b000			 
b000 2a de e7				ld hl, (os_tok_ptr) 
b003 23					inc hl   ; R 
b004 23					inc hl  ; E 
b005 23					inc hl   ; P 
b006 23					inc hl   ; E 
b007 23					inc hl   ; A 
b008 23					inc hl   ; T 
b009 23					inc hl   ; zero 
b00a					FORTH_RSP_NEXT 
b00a cd a4 98			call macro_forth_rsp_next 
b00d				endm 
# End of macro FORTH_RSP_NEXT
b00d			 
b00d			 
b00d					if DEBUG_FORTH_WORDS 
b00d						DMARK "REP" 
b00d f5				push af  
b00e 3a 22 b0			ld a, (.dmark)  
b011 32 b7 ee			ld (debug_mark),a  
b014 3a 23 b0			ld a, (.dmark+1)  
b017 32 b8 ee			ld (debug_mark+1),a  
b01a 3a 24 b0			ld a, (.dmark+2)  
b01d 32 b9 ee			ld (debug_mark+2),a  
b020 18 03			jr .pastdmark  
b022 ..			.dmark: db "REP"  
b025 f1			.pastdmark: pop af  
b026			endm  
# End of macro DMARK
b026						;pop bc    ; TODO BUG ?????? what is this for???? 
b026						CALLMONITOR 
b026 cd a3 92			call break_point_state  
b029				endm  
# End of macro CALLMONITOR
b029					endif 
b029			 
b029					NEXTW 
b029 c3 66 9c			jp macro_next 
b02c				endm 
# End of macro NEXTW
b02c			;	       NEXTW 
b02c			 
b02c			.UNTIL: 
b02c				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b02c 72				db WORD_SYS_CORE+94             
b02d c3 b0			dw .ENDFLOW            
b02f 06				db 5 + 1 
b030 .. 00			db "UNTIL",0              
b036				endm 
# End of macro CWHEAD
b036			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b036			 
b036				; pop tos as check 
b036			 
b036				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b036			 
b036				FORTH_DSP_VALUEHL 
b036 cd f4 9a			call macro_dsp_valuehl 
b039				endm 
# End of macro FORTH_DSP_VALUEHL
b039			 
b039					if DEBUG_FORTH_WORDS_KEY 
b039						DMARK "UNT" 
b039 f5				push af  
b03a 3a 4e b0			ld a, (.dmark)  
b03d 32 b7 ee			ld (debug_mark),a  
b040 3a 4f b0			ld a, (.dmark+1)  
b043 32 b8 ee			ld (debug_mark+1),a  
b046 3a 50 b0			ld a, (.dmark+2)  
b049 32 b9 ee			ld (debug_mark+2),a  
b04c 18 03			jr .pastdmark  
b04e ..			.dmark: db "UNT"  
b051 f1			.pastdmark: pop af  
b052			endm  
# End of macro DMARK
b052						CALLMONITOR 
b052 cd a3 92			call break_point_state  
b055				endm  
# End of macro CALLMONITOR
b055					endif 
b055			 
b055			;	push hl 
b055				FORTH_DSP_POP 
b055 cd ac 9b			call macro_forth_dsp_pop 
b058				endm 
# End of macro FORTH_DSP_POP
b058			 
b058			;	pop hl 
b058			 
b058				; test if true 
b058			 
b058 cd cb 8a			call ishlzero 
b05b			;	ld a,l 
b05b			;	add h 
b05b			; 
b05b			;	cp 0 
b05b			 
b05b 20 3e			jr nz, .untilnotdone 
b05d			 
b05d					if DEBUG_FORTH_WORDS 
b05d						DMARK "UNf" 
b05d f5				push af  
b05e 3a 72 b0			ld a, (.dmark)  
b061 32 b7 ee			ld (debug_mark),a  
b064 3a 73 b0			ld a, (.dmark+1)  
b067 32 b8 ee			ld (debug_mark+1),a  
b06a 3a 74 b0			ld a, (.dmark+2)  
b06d 32 b9 ee			ld (debug_mark+2),a  
b070 18 03			jr .pastdmark  
b072 ..			.dmark: db "UNf"  
b075 f1			.pastdmark: pop af  
b076			endm  
# End of macro DMARK
b076						CALLMONITOR 
b076 cd a3 92			call break_point_state  
b079				endm  
# End of macro CALLMONITOR
b079					endif 
b079			 
b079			 
b079			 
b079				FORTH_RSP_POP     ; get rid of DO ptr 
b079 cd c5 98			call macro_forth_rsp_pop 
b07c				endm 
# End of macro FORTH_RSP_POP
b07c			 
b07c			if DEBUG_FORTH_WORDS 
b07c						DMARK "UN>" 
b07c f5				push af  
b07d 3a 91 b0			ld a, (.dmark)  
b080 32 b7 ee			ld (debug_mark),a  
b083 3a 92 b0			ld a, (.dmark+1)  
b086 32 b8 ee			ld (debug_mark+1),a  
b089 3a 93 b0			ld a, (.dmark+2)  
b08c 32 b9 ee			ld (debug_mark+2),a  
b08f 18 03			jr .pastdmark  
b091 ..			.dmark: db "UN>"  
b094 f1			.pastdmark: pop af  
b095			endm  
# End of macro DMARK
b095				CALLMONITOR 
b095 cd a3 92			call break_point_state  
b098				endm  
# End of macro CALLMONITOR
b098			endif 
b098			 
b098					NEXTW 
b098 c3 66 9c			jp macro_next 
b09b				endm 
# End of macro NEXTW
b09b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b09b			 
b09b			.untilnotdone: 
b09b			 
b09b			 
b09b			;	; get DO ptr 
b09b			; 
b09b				FORTH_RSP_TOS 
b09b cd bb 98			call macro_forth_rsp_tos 
b09e				endm 
# End of macro FORTH_RSP_TOS
b09e			 
b09e				;push hl 
b09e			 
b09e				; not going to DO any more 
b09e				; get rid of the RSP pointer as DO will add it back in 
b09e				;FORTH_RSP_POP 
b09e				;pop hl 
b09e			 
b09e			 
b09e 22 de e7			ld (os_tok_ptr), hl 
b0a1					if DEBUG_FORTH_WORDS 
b0a1						DMARK "UN<" 
b0a1 f5				push af  
b0a2 3a b6 b0			ld a, (.dmark)  
b0a5 32 b7 ee			ld (debug_mark),a  
b0a8 3a b7 b0			ld a, (.dmark+1)  
b0ab 32 b8 ee			ld (debug_mark+1),a  
b0ae 3a b8 b0			ld a, (.dmark+2)  
b0b1 32 b9 ee			ld (debug_mark+2),a  
b0b4 18 03			jr .pastdmark  
b0b6 ..			.dmark: db "UN<"  
b0b9 f1			.pastdmark: pop af  
b0ba			endm  
# End of macro DMARK
b0ba					CALLMONITOR 
b0ba cd a3 92			call break_point_state  
b0bd				endm  
# End of macro CALLMONITOR
b0bd				endif 
b0bd c3 f7 9c			jp exec1 
b0c0			 
b0c0					 
b0c0			 
b0c0			 
b0c0					NEXTW 
b0c0 c3 66 9c			jp macro_next 
b0c3				endm 
# End of macro NEXTW
b0c3			 
b0c3			 
b0c3			.ENDFLOW: 
b0c3			 
b0c3			; eof 
b0c3			 
# End of file forth_words_flow.asm
b0c3			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b0c3			include "forth_words_logic.asm" 
b0c3			 
b0c3			; | ## Logic Words 
b0c3			 
b0c3			.NOT: 
b0c3				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b0c3 2d				db WORD_SYS_CORE+25             
b0c4 0b b1			dw .IS            
b0c6 04				db 3 + 1 
b0c7 .. 00			db "NOT",0              
b0cb				endm 
# End of macro CWHEAD
b0cb			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b0cb					if DEBUG_FORTH_WORDS_KEY 
b0cb						DMARK "NOT" 
b0cb f5				push af  
b0cc 3a e0 b0			ld a, (.dmark)  
b0cf 32 b7 ee			ld (debug_mark),a  
b0d2 3a e1 b0			ld a, (.dmark+1)  
b0d5 32 b8 ee			ld (debug_mark+1),a  
b0d8 3a e2 b0			ld a, (.dmark+2)  
b0db 32 b9 ee			ld (debug_mark+2),a  
b0de 18 03			jr .pastdmark  
b0e0 ..			.dmark: db "NOT"  
b0e3 f1			.pastdmark: pop af  
b0e4			endm  
# End of macro DMARK
b0e4						CALLMONITOR 
b0e4 cd a3 92			call break_point_state  
b0e7				endm  
# End of macro CALLMONITOR
b0e7					endif 
b0e7					FORTH_DSP 
b0e7 cd ba 9a			call macro_forth_dsp 
b0ea				endm 
# End of macro FORTH_DSP
b0ea 7e					ld a,(hl)	; get type of value on TOS 
b0eb fe 02				cp DS_TYPE_INUM  
b0ed 28 03				jr z, .noti 
b0ef					NEXTW 
b0ef c3 66 9c			jp macro_next 
b0f2				endm 
# End of macro NEXTW
b0f2			.noti:          FORTH_DSP_VALUEHL 
b0f2 cd f4 9a			call macro_dsp_valuehl 
b0f5				endm 
# End of macro FORTH_DSP_VALUEHL
b0f5			;		push hl 
b0f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0f5 cd ac 9b			call macro_forth_dsp_pop 
b0f8				endm 
# End of macro FORTH_DSP_POP
b0f8			;		pop hl 
b0f8 3e 00				ld a,0 
b0fa bd					cp l 
b0fb 28 04				jr z, .not2t 
b0fd 2e 00				ld l, 0 
b0ff 18 02				jr .notip 
b101			 
b101 2e ff		.not2t:		ld l, 255 
b103			 
b103 26 00		.notip:		ld h, 0	 
b105			 
b105 cd fd 98				call forth_push_numhl 
b108					NEXTW 
b108 c3 66 9c			jp macro_next 
b10b				endm 
# End of macro NEXTW
b10b			 
b10b			.IS: 
b10b				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b10b 2d				db WORD_SYS_CORE+25             
b10c 31 b1			dw .LZERO            
b10e 03				db 2 + 1 
b10f .. 00			db "IS",0              
b112				endm 
# End of macro CWHEAD
b112			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b112					if DEBUG_FORTH_WORDS_KEY 
b112						DMARK "IS." 
b112 f5				push af  
b113 3a 27 b1			ld a, (.dmark)  
b116 32 b7 ee			ld (debug_mark),a  
b119 3a 28 b1			ld a, (.dmark+1)  
b11c 32 b8 ee			ld (debug_mark+1),a  
b11f 3a 29 b1			ld a, (.dmark+2)  
b122 32 b9 ee			ld (debug_mark+2),a  
b125 18 03			jr .pastdmark  
b127 ..			.dmark: db "IS."  
b12a f1			.pastdmark: pop af  
b12b			endm  
# End of macro DMARK
b12b						CALLMONITOR 
b12b cd a3 92			call break_point_state  
b12e				endm  
# End of macro CALLMONITOR
b12e					endif 
b12e					NEXTW 
b12e c3 66 9c			jp macro_next 
b131				endm 
# End of macro NEXTW
b131			.LZERO: 
b131				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b131 2d				db WORD_SYS_CORE+25             
b132 3b b1			dw .TZERO            
b134 03				db 2 + 1 
b135 .. 00			db "0<",0              
b138				endm 
# End of macro CWHEAD
b138			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b138					NEXTW 
b138 c3 66 9c			jp macro_next 
b13b				endm 
# End of macro NEXTW
b13b			.TZERO: 
b13b				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b13b 2e				db WORD_SYS_CORE+26             
b13c 82 b1			dw .LESS            
b13e 03				db 2 + 1 
b13f .. 00			db "0=",0              
b142				endm 
# End of macro CWHEAD
b142			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b142				; TODO add floating point number detection 
b142					;v5 FORTH_DSP_VALUE 
b142					if DEBUG_FORTH_WORDS_KEY 
b142						DMARK "0=." 
b142 f5				push af  
b143 3a 57 b1			ld a, (.dmark)  
b146 32 b7 ee			ld (debug_mark),a  
b149 3a 58 b1			ld a, (.dmark+1)  
b14c 32 b8 ee			ld (debug_mark+1),a  
b14f 3a 59 b1			ld a, (.dmark+2)  
b152 32 b9 ee			ld (debug_mark+2),a  
b155 18 03			jr .pastdmark  
b157 ..			.dmark: db "0=."  
b15a f1			.pastdmark: pop af  
b15b			endm  
# End of macro DMARK
b15b						CALLMONITOR 
b15b cd a3 92			call break_point_state  
b15e				endm  
# End of macro CALLMONITOR
b15e					endif 
b15e					FORTH_DSP 
b15e cd ba 9a			call macro_forth_dsp 
b161				endm 
# End of macro FORTH_DSP
b161 7e					ld a,(hl)	; get type of value on TOS 
b162 fe 02				cp DS_TYPE_INUM  
b164 28 00				jr z, .tz_inum 
b166			 
b166				if FORTH_ENABLE_FLOATMATH 
b166					jr .tz_done 
b166			 
b166				endif 
b166					 
b166			 
b166			.tz_inum: 
b166					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b166 cd f4 9a			call macro_dsp_valuehl 
b169				endm 
# End of macro FORTH_DSP_VALUEHL
b169			 
b169			;		push hl 
b169			 
b169					; destroy value TOS 
b169			 
b169					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b169 cd ac 9b			call macro_forth_dsp_pop 
b16c				endm 
# End of macro FORTH_DSP_POP
b16c			 
b16c			;		pop hl 
b16c			 
b16c 3e 00				ld a,0 
b16e			 
b16e bd					cp l 
b16f 20 08				jr nz, .tz_notzero 
b171			 
b171 bc					cp h 
b172			 
b172 20 05				jr nz, .tz_notzero 
b174			 
b174			 
b174 21 01 00				ld hl, FORTH_TRUE 
b177 18 03				jr .tz_done 
b179			 
b179 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b17c			 
b17c					; push value back onto stack for another op etc 
b17c			 
b17c			.tz_done: 
b17c cd fd 98				call forth_push_numhl 
b17f			 
b17f					NEXTW 
b17f c3 66 9c			jp macro_next 
b182				endm 
# End of macro NEXTW
b182			.LESS: 
b182				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b182 2f				db WORD_SYS_CORE+27             
b183 eb b1			dw .GT            
b185 02				db 1 + 1 
b186 .. 00			db "<",0              
b188				endm 
# End of macro CWHEAD
b188			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b188				; TODO add floating point number detection 
b188					if DEBUG_FORTH_WORDS_KEY 
b188						DMARK "LES" 
b188 f5				push af  
b189 3a 9d b1			ld a, (.dmark)  
b18c 32 b7 ee			ld (debug_mark),a  
b18f 3a 9e b1			ld a, (.dmark+1)  
b192 32 b8 ee			ld (debug_mark+1),a  
b195 3a 9f b1			ld a, (.dmark+2)  
b198 32 b9 ee			ld (debug_mark+2),a  
b19b 18 03			jr .pastdmark  
b19d ..			.dmark: db "LES"  
b1a0 f1			.pastdmark: pop af  
b1a1			endm  
# End of macro DMARK
b1a1						CALLMONITOR 
b1a1 cd a3 92			call break_point_state  
b1a4				endm  
# End of macro CALLMONITOR
b1a4					endif 
b1a4					FORTH_DSP 
b1a4 cd ba 9a			call macro_forth_dsp 
b1a7				endm 
# End of macro FORTH_DSP
b1a7					;v5 FORTH_DSP_VALUE 
b1a7 7e					ld a,(hl)	; get type of value on TOS 
b1a8 fe 02				cp DS_TYPE_INUM  
b1aa 28 00				jr z, .less_inum 
b1ac			 
b1ac				if FORTH_ENABLE_FLOATMATH 
b1ac					jr .less_done 
b1ac			 
b1ac				endif 
b1ac					 
b1ac			 
b1ac			.less_inum: 
b1ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1ac cd f4 9a			call macro_dsp_valuehl 
b1af				endm 
# End of macro FORTH_DSP_VALUEHL
b1af			 
b1af e5					push hl  ; u2 
b1b0			 
b1b0					; destroy value TOS 
b1b0			 
b1b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1b0 cd ac 9b			call macro_forth_dsp_pop 
b1b3				endm 
# End of macro FORTH_DSP_POP
b1b3			 
b1b3			 
b1b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1b3 cd f4 9a			call macro_dsp_valuehl 
b1b6				endm 
# End of macro FORTH_DSP_VALUEHL
b1b6			 
b1b6 e5					push hl    ; u1 
b1b7			 
b1b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1b7 cd ac 9b			call macro_forth_dsp_pop 
b1ba				endm 
# End of macro FORTH_DSP_POP
b1ba			 
b1ba			 
b1ba b7			 or a      ;clear carry flag 
b1bb 01 00 00		 ld bc, FORTH_FALSE 
b1be e1			  pop hl    ; u1 
b1bf d1			  pop de    ; u2 
b1c0 ed 52		  sbc hl,de 
b1c2 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b1c4			 
b1c4 01 01 00		 ld bc, FORTH_TRUE 
b1c7			.lscont:  
b1c7 c5					push bc 
b1c8 e1					pop hl 
b1c9			 
b1c9					if DEBUG_FORTH_WORDS 
b1c9						DMARK "LT1" 
b1c9 f5				push af  
b1ca 3a de b1			ld a, (.dmark)  
b1cd 32 b7 ee			ld (debug_mark),a  
b1d0 3a df b1			ld a, (.dmark+1)  
b1d3 32 b8 ee			ld (debug_mark+1),a  
b1d6 3a e0 b1			ld a, (.dmark+2)  
b1d9 32 b9 ee			ld (debug_mark+2),a  
b1dc 18 03			jr .pastdmark  
b1de ..			.dmark: db "LT1"  
b1e1 f1			.pastdmark: pop af  
b1e2			endm  
# End of macro DMARK
b1e2						CALLMONITOR 
b1e2 cd a3 92			call break_point_state  
b1e5				endm  
# End of macro CALLMONITOR
b1e5					endif 
b1e5 cd fd 98				call forth_push_numhl 
b1e8			 
b1e8					NEXTW 
b1e8 c3 66 9c			jp macro_next 
b1eb				endm 
# End of macro NEXTW
b1eb			.GT: 
b1eb				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b1eb 30				db WORD_SYS_CORE+28             
b1ec 54 b2			dw .EQUAL            
b1ee 02				db 1 + 1 
b1ef .. 00			db ">",0              
b1f1				endm 
# End of macro CWHEAD
b1f1			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b1f1				; TODO add floating point number detection 
b1f1					if DEBUG_FORTH_WORDS_KEY 
b1f1						DMARK "GRT" 
b1f1 f5				push af  
b1f2 3a 06 b2			ld a, (.dmark)  
b1f5 32 b7 ee			ld (debug_mark),a  
b1f8 3a 07 b2			ld a, (.dmark+1)  
b1fb 32 b8 ee			ld (debug_mark+1),a  
b1fe 3a 08 b2			ld a, (.dmark+2)  
b201 32 b9 ee			ld (debug_mark+2),a  
b204 18 03			jr .pastdmark  
b206 ..			.dmark: db "GRT"  
b209 f1			.pastdmark: pop af  
b20a			endm  
# End of macro DMARK
b20a						CALLMONITOR 
b20a cd a3 92			call break_point_state  
b20d				endm  
# End of macro CALLMONITOR
b20d					endif 
b20d					FORTH_DSP 
b20d cd ba 9a			call macro_forth_dsp 
b210				endm 
# End of macro FORTH_DSP
b210					;FORTH_DSP_VALUE 
b210 7e					ld a,(hl)	; get type of value on TOS 
b211 fe 02				cp DS_TYPE_INUM  
b213 28 00				jr z, .gt_inum 
b215			 
b215				if FORTH_ENABLE_FLOATMATH 
b215					jr .gt_done 
b215			 
b215				endif 
b215					 
b215			 
b215			.gt_inum: 
b215					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b215 cd f4 9a			call macro_dsp_valuehl 
b218				endm 
# End of macro FORTH_DSP_VALUEHL
b218			 
b218 e5					push hl  ; u2 
b219			 
b219					; destroy value TOS 
b219			 
b219					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b219 cd ac 9b			call macro_forth_dsp_pop 
b21c				endm 
# End of macro FORTH_DSP_POP
b21c			 
b21c			 
b21c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b21c cd f4 9a			call macro_dsp_valuehl 
b21f				endm 
# End of macro FORTH_DSP_VALUEHL
b21f			 
b21f e5					push hl    ; u1 
b220			 
b220					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b220 cd ac 9b			call macro_forth_dsp_pop 
b223				endm 
# End of macro FORTH_DSP_POP
b223			 
b223			 
b223 b7			 or a      ;clear carry flag 
b224 01 00 00		 ld bc, FORTH_FALSE 
b227 e1			  pop hl    ; u1 
b228 d1			  pop de    ; u2 
b229 ed 52		  sbc hl,de 
b22b 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b22d			 
b22d 01 01 00		 ld bc, FORTH_TRUE 
b230			.gtcont:  
b230 c5					push bc 
b231 e1					pop hl 
b232			 
b232					if DEBUG_FORTH_WORDS 
b232						DMARK "GT1" 
b232 f5				push af  
b233 3a 47 b2			ld a, (.dmark)  
b236 32 b7 ee			ld (debug_mark),a  
b239 3a 48 b2			ld a, (.dmark+1)  
b23c 32 b8 ee			ld (debug_mark+1),a  
b23f 3a 49 b2			ld a, (.dmark+2)  
b242 32 b9 ee			ld (debug_mark+2),a  
b245 18 03			jr .pastdmark  
b247 ..			.dmark: db "GT1"  
b24a f1			.pastdmark: pop af  
b24b			endm  
# End of macro DMARK
b24b						CALLMONITOR 
b24b cd a3 92			call break_point_state  
b24e				endm  
# End of macro CALLMONITOR
b24e					endif 
b24e cd fd 98				call forth_push_numhl 
b251			 
b251					NEXTW 
b251 c3 66 9c			jp macro_next 
b254				endm 
# End of macro NEXTW
b254			.EQUAL: 
b254				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b254 31				db WORD_SYS_CORE+29             
b255 bf b2			dw .ENDLOGIC            
b257 02				db 1 + 1 
b258 .. 00			db "=",0              
b25a				endm 
# End of macro CWHEAD
b25a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b25a				; TODO add floating point number detection 
b25a					if DEBUG_FORTH_WORDS_KEY 
b25a						DMARK "EQ." 
b25a f5				push af  
b25b 3a 6f b2			ld a, (.dmark)  
b25e 32 b7 ee			ld (debug_mark),a  
b261 3a 70 b2			ld a, (.dmark+1)  
b264 32 b8 ee			ld (debug_mark+1),a  
b267 3a 71 b2			ld a, (.dmark+2)  
b26a 32 b9 ee			ld (debug_mark+2),a  
b26d 18 03			jr .pastdmark  
b26f ..			.dmark: db "EQ."  
b272 f1			.pastdmark: pop af  
b273			endm  
# End of macro DMARK
b273						CALLMONITOR 
b273 cd a3 92			call break_point_state  
b276				endm  
# End of macro CALLMONITOR
b276					endif 
b276					FORTH_DSP 
b276 cd ba 9a			call macro_forth_dsp 
b279				endm 
# End of macro FORTH_DSP
b279					;v5 FORTH_DSP_VALUE 
b279 7e					ld a,(hl)	; get type of value on TOS 
b27a fe 02				cp DS_TYPE_INUM  
b27c 28 00				jr z, .eq_inum 
b27e			 
b27e				if FORTH_ENABLE_FLOATMATH 
b27e					jr .eq_done 
b27e			 
b27e				endif 
b27e					 
b27e			 
b27e			.eq_inum: 
b27e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b27e cd f4 9a			call macro_dsp_valuehl 
b281				endm 
# End of macro FORTH_DSP_VALUEHL
b281			 
b281 e5					push hl 
b282			 
b282					; destroy value TOS 
b282			 
b282					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b282 cd ac 9b			call macro_forth_dsp_pop 
b285				endm 
# End of macro FORTH_DSP_POP
b285			 
b285			 
b285					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b285 cd f4 9a			call macro_dsp_valuehl 
b288				endm 
# End of macro FORTH_DSP_VALUEHL
b288			 
b288					; one value on hl get other one back 
b288			 
b288 e5					push hl 
b289			 
b289					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b289 cd ac 9b			call macro_forth_dsp_pop 
b28c				endm 
# End of macro FORTH_DSP_POP
b28c			 
b28c 0e 00				ld c, FORTH_FALSE 
b28e			 
b28e e1					pop hl 
b28f d1					pop de 
b290			 
b290 7b					ld a, e 
b291 bd					cp l 
b292			 
b292 20 06				jr nz, .eq_done 
b294			 
b294 7a					ld a, d 
b295 bc					cp h 
b296			 
b296 20 02				jr nz, .eq_done 
b298			 
b298 0e 01				ld c, FORTH_TRUE 
b29a					 
b29a			 
b29a			 
b29a			.eq_done: 
b29a			 
b29a					; TODO push value back onto stack for another op etc 
b29a			 
b29a 26 00				ld h, 0 
b29c 69					ld l, c 
b29d					if DEBUG_FORTH_WORDS 
b29d						DMARK "EQ1" 
b29d f5				push af  
b29e 3a b2 b2			ld a, (.dmark)  
b2a1 32 b7 ee			ld (debug_mark),a  
b2a4 3a b3 b2			ld a, (.dmark+1)  
b2a7 32 b8 ee			ld (debug_mark+1),a  
b2aa 3a b4 b2			ld a, (.dmark+2)  
b2ad 32 b9 ee			ld (debug_mark+2),a  
b2b0 18 03			jr .pastdmark  
b2b2 ..			.dmark: db "EQ1"  
b2b5 f1			.pastdmark: pop af  
b2b6			endm  
# End of macro DMARK
b2b6						CALLMONITOR 
b2b6 cd a3 92			call break_point_state  
b2b9				endm  
# End of macro CALLMONITOR
b2b9					endif 
b2b9 cd fd 98				call forth_push_numhl 
b2bc			 
b2bc					NEXTW 
b2bc c3 66 9c			jp macro_next 
b2bf				endm 
# End of macro NEXTW
b2bf			 
b2bf			 
b2bf			.ENDLOGIC: 
b2bf			; eof 
b2bf			 
b2bf			 
# End of file forth_words_logic.asm
b2bf			include "forth_words_maths.asm" 
b2bf			 
b2bf			; | ## Maths Words 
b2bf			 
b2bf			.PLUS:	 
b2bf				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b2bf 15				db WORD_SYS_CORE+1             
b2c0 01 b3			dw .NEG            
b2c2 02				db 1 + 1 
b2c3 .. 00			db "+",0              
b2c5				endm 
# End of macro CWHEAD
b2c5			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b2c5					if DEBUG_FORTH_WORDS_KEY 
b2c5						DMARK "PLU" 
b2c5 f5				push af  
b2c6 3a da b2			ld a, (.dmark)  
b2c9 32 b7 ee			ld (debug_mark),a  
b2cc 3a db b2			ld a, (.dmark+1)  
b2cf 32 b8 ee			ld (debug_mark+1),a  
b2d2 3a dc b2			ld a, (.dmark+2)  
b2d5 32 b9 ee			ld (debug_mark+2),a  
b2d8 18 03			jr .pastdmark  
b2da ..			.dmark: db "PLU"  
b2dd f1			.pastdmark: pop af  
b2de			endm  
# End of macro DMARK
b2de						CALLMONITOR 
b2de cd a3 92			call break_point_state  
b2e1				endm  
# End of macro CALLMONITOR
b2e1					endif 
b2e1					; add top two values and push back result 
b2e1			 
b2e1					;for v5 FORTH_DSP_VALUE 
b2e1					FORTH_DSP 
b2e1 cd ba 9a			call macro_forth_dsp 
b2e4				endm 
# End of macro FORTH_DSP
b2e4 7e					ld a,(hl)	; get type of value on TOS 
b2e5 fe 02				cp DS_TYPE_INUM  
b2e7 28 03				jr z, .dot_inum 
b2e9			 
b2e9					NEXTW 
b2e9 c3 66 9c			jp macro_next 
b2ec				endm 
# End of macro NEXTW
b2ec			 
b2ec			; float maths 
b2ec			 
b2ec				if FORTH_ENABLE_FLOATMATH 
b2ec						inc hl      ; now at start of numeric as string 
b2ec			 
b2ec					if DEBUG_FORTH_MATHS 
b2ec						DMARK "ADD" 
b2ec				CALLMONITOR 
b2ec					endif 
b2ec			 
b2ec					;ld ix, hl 
b2ec					call CON 
b2ec			 
b2ec			 
b2ec					push hl 
b2ec					 
b2ec					 
b2ec			 
b2ec						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b2ec			 
b2ec					; get next number 
b2ec			 
b2ec						FORTH_DSP_VALUE 
b2ec			 
b2ec						inc hl      ; now at start of numeric as string 
b2ec			 
b2ec					;ld ix, hl 
b2ec					call CON 
b2ec			 
b2ec					push hl 
b2ec			 
b2ec			 
b2ec						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ec			 
b2ec						; TODO do add 
b2ec			 
b2ec						call IADD 
b2ec			 
b2ec						; TODO get result back as ascii 
b2ec			 
b2ec						; TODO push result  
b2ec			 
b2ec			 
b2ec			 
b2ec						jr .dot_done 
b2ec				endif 
b2ec			 
b2ec			.dot_inum: 
b2ec			 
b2ec			 
b2ec					if DEBUG_FORTH_DOT 
b2ec						DMARK "+IT" 
b2ec				CALLMONITOR 
b2ec					endif 
b2ec			 
b2ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2ec cd f4 9a			call macro_dsp_valuehl 
b2ef				endm 
# End of macro FORTH_DSP_VALUEHL
b2ef			 
b2ef				; TODO add floating point number detection 
b2ef			 
b2ef e5					push hl 
b2f0			 
b2f0					; destroy value TOS 
b2f0			 
b2f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f0 cd ac 9b			call macro_forth_dsp_pop 
b2f3				endm 
# End of macro FORTH_DSP_POP
b2f3			 
b2f3			 
b2f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2f3 cd f4 9a			call macro_dsp_valuehl 
b2f6				endm 
# End of macro FORTH_DSP_VALUEHL
b2f6			 
b2f6					; one value on hl get other one back 
b2f6			 
b2f6 d1					pop de 
b2f7			 
b2f7					; do the add 
b2f7			 
b2f7 19					add hl,de 
b2f8			 
b2f8					; save it 
b2f8			 
b2f8			;		push hl	 
b2f8			 
b2f8					; 
b2f8			 
b2f8					; destroy value TOS 
b2f8			 
b2f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f8 cd ac 9b			call macro_forth_dsp_pop 
b2fb				endm 
# End of macro FORTH_DSP_POP
b2fb			 
b2fb					; TODO push value back onto stack for another op etc 
b2fb			 
b2fb			;		pop hl 
b2fb			 
b2fb			.dot_done: 
b2fb cd fd 98				call forth_push_numhl 
b2fe			 
b2fe					NEXTW 
b2fe c3 66 9c			jp macro_next 
b301				endm 
# End of macro NEXTW
b301			.NEG: 
b301			 
b301				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b301 17				db WORD_SYS_CORE+3             
b302 44 b3			dw .DIV            
b304 02				db 1 + 1 
b305 .. 00			db "-",0              
b307				endm 
# End of macro CWHEAD
b307			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b307					if DEBUG_FORTH_WORDS_KEY 
b307						DMARK "SUB" 
b307 f5				push af  
b308 3a 1c b3			ld a, (.dmark)  
b30b 32 b7 ee			ld (debug_mark),a  
b30e 3a 1d b3			ld a, (.dmark+1)  
b311 32 b8 ee			ld (debug_mark+1),a  
b314 3a 1e b3			ld a, (.dmark+2)  
b317 32 b9 ee			ld (debug_mark+2),a  
b31a 18 03			jr .pastdmark  
b31c ..			.dmark: db "SUB"  
b31f f1			.pastdmark: pop af  
b320			endm  
# End of macro DMARK
b320						CALLMONITOR 
b320 cd a3 92			call break_point_state  
b323				endm  
# End of macro CALLMONITOR
b323					endif 
b323			 
b323			 
b323				; TODO add floating point number detection 
b323					; v5 FORTH_DSP_VALUE 
b323					FORTH_DSP 
b323 cd ba 9a			call macro_forth_dsp 
b326				endm 
# End of macro FORTH_DSP
b326 7e					ld a,(hl)	; get type of value on TOS 
b327 fe 02				cp DS_TYPE_INUM  
b329 28 03				jr z, .neg_inum 
b32b			 
b32b					NEXTW 
b32b c3 66 9c			jp macro_next 
b32e				endm 
# End of macro NEXTW
b32e			 
b32e			; float maths 
b32e			 
b32e				if FORTH_ENABLE_FLOATMATH 
b32e					jr .neg_done 
b32e			 
b32e				endif 
b32e					 
b32e			 
b32e			.neg_inum: 
b32e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b32e cd f4 9a			call macro_dsp_valuehl 
b331				endm 
# End of macro FORTH_DSP_VALUEHL
b331			 
b331 e5					push hl 
b332			 
b332					; destroy value TOS 
b332			 
b332					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b332 cd ac 9b			call macro_forth_dsp_pop 
b335				endm 
# End of macro FORTH_DSP_POP
b335			 
b335			 
b335					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b335 cd f4 9a			call macro_dsp_valuehl 
b338				endm 
# End of macro FORTH_DSP_VALUEHL
b338			 
b338					; one value on hl get other one back 
b338			 
b338 d1					pop de 
b339			 
b339					; do the sub 
b339			;		ex de, hl 
b339			 
b339 ed 52				sbc hl,de 
b33b			 
b33b					; save it 
b33b			 
b33b			;		push hl	 
b33b			 
b33b					; 
b33b			 
b33b					; destroy value TOS 
b33b			 
b33b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b33b cd ac 9b			call macro_forth_dsp_pop 
b33e				endm 
# End of macro FORTH_DSP_POP
b33e			 
b33e					; TODO push value back onto stack for another op etc 
b33e			 
b33e			;		pop hl 
b33e			 
b33e cd fd 98				call forth_push_numhl 
b341			.neg_done: 
b341			 
b341					NEXTW 
b341 c3 66 9c			jp macro_next 
b344				endm 
# End of macro NEXTW
b344			.DIV: 
b344				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b344 18				db WORD_SYS_CORE+4             
b345 91 b3			dw .MUL            
b347 02				db 1 + 1 
b348 .. 00			db "/",0              
b34a				endm 
# End of macro CWHEAD
b34a			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b34a					if DEBUG_FORTH_WORDS_KEY 
b34a						DMARK "DIV" 
b34a f5				push af  
b34b 3a 5f b3			ld a, (.dmark)  
b34e 32 b7 ee			ld (debug_mark),a  
b351 3a 60 b3			ld a, (.dmark+1)  
b354 32 b8 ee			ld (debug_mark+1),a  
b357 3a 61 b3			ld a, (.dmark+2)  
b35a 32 b9 ee			ld (debug_mark+2),a  
b35d 18 03			jr .pastdmark  
b35f ..			.dmark: db "DIV"  
b362 f1			.pastdmark: pop af  
b363			endm  
# End of macro DMARK
b363						CALLMONITOR 
b363 cd a3 92			call break_point_state  
b366				endm  
# End of macro CALLMONITOR
b366					endif 
b366				; TODO add floating point number detection 
b366					; v5 FORTH_DSP_VALUE 
b366					FORTH_DSP 
b366 cd ba 9a			call macro_forth_dsp 
b369				endm 
# End of macro FORTH_DSP
b369 7e					ld a,(hl)	; get type of value on TOS 
b36a fe 02				cp DS_TYPE_INUM  
b36c 28 03				jr z, .div_inum 
b36e			 
b36e				if FORTH_ENABLE_FLOATMATH 
b36e					jr .div_done 
b36e			 
b36e				endif 
b36e					NEXTW 
b36e c3 66 9c			jp macro_next 
b371				endm 
# End of macro NEXTW
b371			.div_inum: 
b371			 
b371					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b371 cd f4 9a			call macro_dsp_valuehl 
b374				endm 
# End of macro FORTH_DSP_VALUEHL
b374			 
b374 e5					push hl    ; to go to bc 
b375			 
b375					; destroy value TOS 
b375			 
b375					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b375 cd ac 9b			call macro_forth_dsp_pop 
b378				endm 
# End of macro FORTH_DSP_POP
b378			 
b378			 
b378					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b378 cd f4 9a			call macro_dsp_valuehl 
b37b				endm 
# End of macro FORTH_DSP_VALUEHL
b37b			 
b37b					; hl to go to de 
b37b			 
b37b e5					push hl 
b37c			 
b37c c1					pop bc 
b37d d1					pop de		 
b37e			 
b37e			 
b37e					if DEBUG_FORTH_MATHS 
b37e						DMARK "DIV" 
b37e				CALLMONITOR 
b37e					endif 
b37e					; one value on hl but move to a get other one back 
b37e			 
b37e			        
b37e cd ff 89			call Div16 
b381			 
b381			;	push af	 
b381 e5				push hl 
b382 c5				push bc 
b383			 
b383					if DEBUG_FORTH_MATHS 
b383						DMARK "DI1" 
b383				CALLMONITOR 
b383					endif 
b383			 
b383					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b383 cd ac 9b			call macro_forth_dsp_pop 
b386				endm 
# End of macro FORTH_DSP_POP
b386			 
b386			 
b386			 
b386 e1					pop hl    ; result 
b387			 
b387 cd fd 98				call forth_push_numhl 
b38a			 
b38a e1					pop hl    ; reminder 
b38b			;		ld h,0 
b38b			;		ld l,d 
b38b			 
b38b cd fd 98				call forth_push_numhl 
b38e			.div_done: 
b38e					NEXTW 
b38e c3 66 9c			jp macro_next 
b391				endm 
# End of macro NEXTW
b391			.MUL: 
b391				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b391 19				db WORD_SYS_CORE+5             
b392 d6 b3			dw .MIN            
b394 02				db 1 + 1 
b395 .. 00			db "*",0              
b397				endm 
# End of macro CWHEAD
b397			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b397				; TODO add floating point number detection 
b397					if DEBUG_FORTH_WORDS_KEY 
b397						DMARK "MUL" 
b397 f5				push af  
b398 3a ac b3			ld a, (.dmark)  
b39b 32 b7 ee			ld (debug_mark),a  
b39e 3a ad b3			ld a, (.dmark+1)  
b3a1 32 b8 ee			ld (debug_mark+1),a  
b3a4 3a ae b3			ld a, (.dmark+2)  
b3a7 32 b9 ee			ld (debug_mark+2),a  
b3aa 18 03			jr .pastdmark  
b3ac ..			.dmark: db "MUL"  
b3af f1			.pastdmark: pop af  
b3b0			endm  
# End of macro DMARK
b3b0						CALLMONITOR 
b3b0 cd a3 92			call break_point_state  
b3b3				endm  
# End of macro CALLMONITOR
b3b3					endif 
b3b3					FORTH_DSP 
b3b3 cd ba 9a			call macro_forth_dsp 
b3b6				endm 
# End of macro FORTH_DSP
b3b6					; v5 FORTH_DSP_VALUE 
b3b6 7e					ld a,(hl)	; get type of value on TOS 
b3b7 fe 02				cp DS_TYPE_INUM  
b3b9 28 03				jr z, .mul_inum 
b3bb			 
b3bb				if FORTH_ENABLE_FLOATMATH 
b3bb					jr .mul_done 
b3bb			 
b3bb				endif 
b3bb			 
b3bb					NEXTW 
b3bb c3 66 9c			jp macro_next 
b3be				endm 
# End of macro NEXTW
b3be			.mul_inum:	 
b3be			 
b3be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3be cd f4 9a			call macro_dsp_valuehl 
b3c1				endm 
# End of macro FORTH_DSP_VALUEHL
b3c1			 
b3c1 e5					push hl 
b3c2			 
b3c2					; destroy value TOS 
b3c2			 
b3c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c2 cd ac 9b			call macro_forth_dsp_pop 
b3c5				endm 
# End of macro FORTH_DSP_POP
b3c5			 
b3c5			 
b3c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c5 cd f4 9a			call macro_dsp_valuehl 
b3c8				endm 
# End of macro FORTH_DSP_VALUEHL
b3c8			 
b3c8					; one value on hl but move to a get other one back 
b3c8			 
b3c8 7d					ld a, l 
b3c9			 
b3c9 d1					pop de 
b3ca			 
b3ca					; do the mull 
b3ca			;		ex de, hl 
b3ca			 
b3ca cd 25 8a				call Mult16 
b3cd					; save it 
b3cd			 
b3cd			;		push hl	 
b3cd			 
b3cd					; 
b3cd			 
b3cd					; destroy value TOS 
b3cd			 
b3cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3cd cd ac 9b			call macro_forth_dsp_pop 
b3d0				endm 
# End of macro FORTH_DSP_POP
b3d0			 
b3d0					; TODO push value back onto stack for another op etc 
b3d0			 
b3d0			;		pop hl 
b3d0			 
b3d0 cd fd 98				call forth_push_numhl 
b3d3			 
b3d3			.mul_done: 
b3d3					NEXTW 
b3d3 c3 66 9c			jp macro_next 
b3d6				endm 
# End of macro NEXTW
b3d6			 
b3d6			 
b3d6			 
b3d6			 
b3d6			.MIN: 
b3d6				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b3d6 49				db WORD_SYS_CORE+53             
b3d7 57 b4			dw .MAX            
b3d9 04				db 3 + 1 
b3da .. 00			db "MIN",0              
b3de				endm 
# End of macro CWHEAD
b3de			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b3de					if DEBUG_FORTH_WORDS_KEY 
b3de						DMARK "MIN" 
b3de f5				push af  
b3df 3a f3 b3			ld a, (.dmark)  
b3e2 32 b7 ee			ld (debug_mark),a  
b3e5 3a f4 b3			ld a, (.dmark+1)  
b3e8 32 b8 ee			ld (debug_mark+1),a  
b3eb 3a f5 b3			ld a, (.dmark+2)  
b3ee 32 b9 ee			ld (debug_mark+2),a  
b3f1 18 03			jr .pastdmark  
b3f3 ..			.dmark: db "MIN"  
b3f6 f1			.pastdmark: pop af  
b3f7			endm  
# End of macro DMARK
b3f7						CALLMONITOR 
b3f7 cd a3 92			call break_point_state  
b3fa				endm  
# End of macro CALLMONITOR
b3fa					endif 
b3fa					; get u2 
b3fa			 
b3fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3fa cd f4 9a			call macro_dsp_valuehl 
b3fd				endm 
# End of macro FORTH_DSP_VALUEHL
b3fd			 
b3fd e5					push hl   ; u2 
b3fe			 
b3fe					; destroy value TOS 
b3fe			 
b3fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3fe cd ac 9b			call macro_forth_dsp_pop 
b401				endm 
# End of macro FORTH_DSP_POP
b401			 
b401					; get u1 
b401			 
b401					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b401 cd f4 9a			call macro_dsp_valuehl 
b404				endm 
# End of macro FORTH_DSP_VALUEHL
b404			 
b404 e5					push hl  ; u1 
b405			 
b405					; destroy value TOS 
b405			 
b405					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b405 cd ac 9b			call macro_forth_dsp_pop 
b408				endm 
# End of macro FORTH_DSP_POP
b408			 
b408 b7			 or a      ;clear carry flag 
b409 e1			  pop hl    ; u1 
b40a d1			  pop de    ; u2 
b40b e5				push hl   ; saved in case hl is lowest 
b40c ed 52		  sbc hl,de 
b40e 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b410			 
b410 e1				pop hl 
b411					if DEBUG_FORTH_WORDS 
b411						DMARK "MIN" 
b411 f5				push af  
b412 3a 26 b4			ld a, (.dmark)  
b415 32 b7 ee			ld (debug_mark),a  
b418 3a 27 b4			ld a, (.dmark+1)  
b41b 32 b8 ee			ld (debug_mark+1),a  
b41e 3a 28 b4			ld a, (.dmark+2)  
b421 32 b9 ee			ld (debug_mark+2),a  
b424 18 03			jr .pastdmark  
b426 ..			.dmark: db "MIN"  
b429 f1			.pastdmark: pop af  
b42a			endm  
# End of macro DMARK
b42a						CALLMONITOR 
b42a cd a3 92			call break_point_state  
b42d				endm  
# End of macro CALLMONITOR
b42d					endif 
b42d cd fd 98				call forth_push_numhl 
b430			 
b430				       NEXTW 
b430 c3 66 9c			jp macro_next 
b433				endm 
# End of macro NEXTW
b433			 
b433			.mincont:  
b433 c1				pop bc   ; tidy up 
b434 eb				ex de , hl  
b435					if DEBUG_FORTH_WORDS 
b435						DMARK "MI1" 
b435 f5				push af  
b436 3a 4a b4			ld a, (.dmark)  
b439 32 b7 ee			ld (debug_mark),a  
b43c 3a 4b b4			ld a, (.dmark+1)  
b43f 32 b8 ee			ld (debug_mark+1),a  
b442 3a 4c b4			ld a, (.dmark+2)  
b445 32 b9 ee			ld (debug_mark+2),a  
b448 18 03			jr .pastdmark  
b44a ..			.dmark: db "MI1"  
b44d f1			.pastdmark: pop af  
b44e			endm  
# End of macro DMARK
b44e						CALLMONITOR 
b44e cd a3 92			call break_point_state  
b451				endm  
# End of macro CALLMONITOR
b451					endif 
b451 cd fd 98				call forth_push_numhl 
b454			 
b454				       NEXTW 
b454 c3 66 9c			jp macro_next 
b457				endm 
# End of macro NEXTW
b457			.MAX: 
b457				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b457 4a				db WORD_SYS_CORE+54             
b458 d8 b4			dw .RND16            
b45a 04				db 3 + 1 
b45b .. 00			db "MAX",0              
b45f				endm 
# End of macro CWHEAD
b45f			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b45f					if DEBUG_FORTH_WORDS_KEY 
b45f						DMARK "MAX" 
b45f f5				push af  
b460 3a 74 b4			ld a, (.dmark)  
b463 32 b7 ee			ld (debug_mark),a  
b466 3a 75 b4			ld a, (.dmark+1)  
b469 32 b8 ee			ld (debug_mark+1),a  
b46c 3a 76 b4			ld a, (.dmark+2)  
b46f 32 b9 ee			ld (debug_mark+2),a  
b472 18 03			jr .pastdmark  
b474 ..			.dmark: db "MAX"  
b477 f1			.pastdmark: pop af  
b478			endm  
# End of macro DMARK
b478						CALLMONITOR 
b478 cd a3 92			call break_point_state  
b47b				endm  
# End of macro CALLMONITOR
b47b					endif 
b47b					; get u2 
b47b			 
b47b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b47b cd f4 9a			call macro_dsp_valuehl 
b47e				endm 
# End of macro FORTH_DSP_VALUEHL
b47e			 
b47e e5					push hl   ; u2 
b47f			 
b47f					; destroy value TOS 
b47f			 
b47f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b47f cd ac 9b			call macro_forth_dsp_pop 
b482				endm 
# End of macro FORTH_DSP_POP
b482			 
b482					; get u1 
b482			 
b482					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b482 cd f4 9a			call macro_dsp_valuehl 
b485				endm 
# End of macro FORTH_DSP_VALUEHL
b485			 
b485 e5					push hl  ; u1 
b486			 
b486					; destroy value TOS 
b486			 
b486					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b486 cd ac 9b			call macro_forth_dsp_pop 
b489				endm 
# End of macro FORTH_DSP_POP
b489			 
b489 b7			 or a      ;clear carry flag 
b48a e1			  pop hl    ; u1 
b48b d1			  pop de    ; u2 
b48c e5				push hl   ; saved in case hl is lowest 
b48d ed 52		  sbc hl,de 
b48f 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b491			 
b491 e1				pop hl 
b492					if DEBUG_FORTH_WORDS 
b492						DMARK "MAX" 
b492 f5				push af  
b493 3a a7 b4			ld a, (.dmark)  
b496 32 b7 ee			ld (debug_mark),a  
b499 3a a8 b4			ld a, (.dmark+1)  
b49c 32 b8 ee			ld (debug_mark+1),a  
b49f 3a a9 b4			ld a, (.dmark+2)  
b4a2 32 b9 ee			ld (debug_mark+2),a  
b4a5 18 03			jr .pastdmark  
b4a7 ..			.dmark: db "MAX"  
b4aa f1			.pastdmark: pop af  
b4ab			endm  
# End of macro DMARK
b4ab						CALLMONITOR 
b4ab cd a3 92			call break_point_state  
b4ae				endm  
# End of macro CALLMONITOR
b4ae					endif 
b4ae cd fd 98				call forth_push_numhl 
b4b1			 
b4b1				       NEXTW 
b4b1 c3 66 9c			jp macro_next 
b4b4				endm 
# End of macro NEXTW
b4b4			 
b4b4			.maxcont:  
b4b4 c1				pop bc   ; tidy up 
b4b5 eb				ex de , hl  
b4b6					if DEBUG_FORTH_WORDS 
b4b6						DMARK "MA1" 
b4b6 f5				push af  
b4b7 3a cb b4			ld a, (.dmark)  
b4ba 32 b7 ee			ld (debug_mark),a  
b4bd 3a cc b4			ld a, (.dmark+1)  
b4c0 32 b8 ee			ld (debug_mark+1),a  
b4c3 3a cd b4			ld a, (.dmark+2)  
b4c6 32 b9 ee			ld (debug_mark+2),a  
b4c9 18 03			jr .pastdmark  
b4cb ..			.dmark: db "MA1"  
b4ce f1			.pastdmark: pop af  
b4cf			endm  
# End of macro DMARK
b4cf						CALLMONITOR 
b4cf cd a3 92			call break_point_state  
b4d2				endm  
# End of macro CALLMONITOR
b4d2					endif 
b4d2 cd fd 98				call forth_push_numhl 
b4d5				       NEXTW 
b4d5 c3 66 9c			jp macro_next 
b4d8				endm 
# End of macro NEXTW
b4d8			 
b4d8			.RND16: 
b4d8				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b4d8 4e				db WORD_SYS_CORE+58             
b4d9 07 b5			dw .RND8            
b4db 06				db 5 + 1 
b4dc .. 00			db "RND16",0              
b4e2				endm 
# End of macro CWHEAD
b4e2			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b4e2					if DEBUG_FORTH_WORDS_KEY 
b4e2						DMARK "R16" 
b4e2 f5				push af  
b4e3 3a f7 b4			ld a, (.dmark)  
b4e6 32 b7 ee			ld (debug_mark),a  
b4e9 3a f8 b4			ld a, (.dmark+1)  
b4ec 32 b8 ee			ld (debug_mark+1),a  
b4ef 3a f9 b4			ld a, (.dmark+2)  
b4f2 32 b9 ee			ld (debug_mark+2),a  
b4f5 18 03			jr .pastdmark  
b4f7 ..			.dmark: db "R16"  
b4fa f1			.pastdmark: pop af  
b4fb			endm  
# End of macro DMARK
b4fb						CALLMONITOR 
b4fb cd a3 92			call break_point_state  
b4fe				endm  
# End of macro CALLMONITOR
b4fe					endif 
b4fe cd c9 89				call prng16  
b501 cd fd 98				call forth_push_numhl 
b504				       NEXTW 
b504 c3 66 9c			jp macro_next 
b507				endm 
# End of macro NEXTW
b507			.RND8: 
b507				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b507 60				db WORD_SYS_CORE+76             
b508 3c b5			dw .RND            
b50a 05				db 4 + 1 
b50b .. 00			db "RND8",0              
b510				endm 
# End of macro CWHEAD
b510			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b510					if DEBUG_FORTH_WORDS_KEY 
b510						DMARK "RN8" 
b510 f5				push af  
b511 3a 25 b5			ld a, (.dmark)  
b514 32 b7 ee			ld (debug_mark),a  
b517 3a 26 b5			ld a, (.dmark+1)  
b51a 32 b8 ee			ld (debug_mark+1),a  
b51d 3a 27 b5			ld a, (.dmark+2)  
b520 32 b9 ee			ld (debug_mark+2),a  
b523 18 03			jr .pastdmark  
b525 ..			.dmark: db "RN8"  
b528 f1			.pastdmark: pop af  
b529			endm  
# End of macro DMARK
b529						CALLMONITOR 
b529 cd a3 92			call break_point_state  
b52c				endm  
# End of macro CALLMONITOR
b52c					endif 
b52c 2a 38 ed				ld hl,(xrandc) 
b52f 23					inc hl 
b530 cd e3 89				call xrnd 
b533 6f					ld l,a	 
b534 26 00				ld h,0 
b536 cd fd 98				call forth_push_numhl 
b539				       NEXTW 
b539 c3 66 9c			jp macro_next 
b53c				endm 
# End of macro NEXTW
b53c			.RND: 
b53c				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b53c 60				db WORD_SYS_CORE+76             
b53d 42 b6			dw .ENDMATHS            
b53f 04				db 3 + 1 
b540 .. 00			db "RND",0              
b544				endm 
# End of macro CWHEAD
b544			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b544			 
b544					if DEBUG_FORTH_WORDS_KEY 
b544						DMARK "RND" 
b544 f5				push af  
b545 3a 59 b5			ld a, (.dmark)  
b548 32 b7 ee			ld (debug_mark),a  
b54b 3a 5a b5			ld a, (.dmark+1)  
b54e 32 b8 ee			ld (debug_mark+1),a  
b551 3a 5b b5			ld a, (.dmark+2)  
b554 32 b9 ee			ld (debug_mark+2),a  
b557 18 03			jr .pastdmark  
b559 ..			.dmark: db "RND"  
b55c f1			.pastdmark: pop af  
b55d			endm  
# End of macro DMARK
b55d						CALLMONITOR 
b55d cd a3 92			call break_point_state  
b560				endm  
# End of macro CALLMONITOR
b560					endif 
b560					 
b560					FORTH_DSP_VALUEHL    ; upper range 
b560 cd f4 9a			call macro_dsp_valuehl 
b563				endm 
# End of macro FORTH_DSP_VALUEHL
b563			 
b563 22 3c ed				ld (LFSRSeed), hl	 
b566			 
b566					if DEBUG_FORTH_WORDS 
b566						DMARK "RN1" 
b566 f5				push af  
b567 3a 7b b5			ld a, (.dmark)  
b56a 32 b7 ee			ld (debug_mark),a  
b56d 3a 7c b5			ld a, (.dmark+1)  
b570 32 b8 ee			ld (debug_mark+1),a  
b573 3a 7d b5			ld a, (.dmark+2)  
b576 32 b9 ee			ld (debug_mark+2),a  
b579 18 03			jr .pastdmark  
b57b ..			.dmark: db "RN1"  
b57e f1			.pastdmark: pop af  
b57f			endm  
# End of macro DMARK
b57f						CALLMONITOR 
b57f cd a3 92			call break_point_state  
b582				endm  
# End of macro CALLMONITOR
b582					endif 
b582					FORTH_DSP_POP 
b582 cd ac 9b			call macro_forth_dsp_pop 
b585				endm 
# End of macro FORTH_DSP_POP
b585			 
b585					FORTH_DSP_VALUEHL    ; low range 
b585 cd f4 9a			call macro_dsp_valuehl 
b588				endm 
# End of macro FORTH_DSP_VALUEHL
b588			 
b588					if DEBUG_FORTH_WORDS 
b588						DMARK "RN2" 
b588 f5				push af  
b589 3a 9d b5			ld a, (.dmark)  
b58c 32 b7 ee			ld (debug_mark),a  
b58f 3a 9e b5			ld a, (.dmark+1)  
b592 32 b8 ee			ld (debug_mark+1),a  
b595 3a 9f b5			ld a, (.dmark+2)  
b598 32 b9 ee			ld (debug_mark+2),a  
b59b 18 03			jr .pastdmark  
b59d ..			.dmark: db "RN2"  
b5a0 f1			.pastdmark: pop af  
b5a1			endm  
# End of macro DMARK
b5a1						CALLMONITOR 
b5a1 cd a3 92			call break_point_state  
b5a4				endm  
# End of macro CALLMONITOR
b5a4					endif 
b5a4 22 3e ed				ld (LFSRSeed+2), hl 
b5a7			 
b5a7					FORTH_DSP_POP 
b5a7 cd ac 9b			call macro_forth_dsp_pop 
b5aa				endm 
# End of macro FORTH_DSP_POP
b5aa			 
b5aa e5					push hl 
b5ab			 
b5ab e1			.inrange:	pop hl 
b5ac cd c9 89				call prng16  
b5af					if DEBUG_FORTH_WORDS 
b5af						DMARK "RN3" 
b5af f5				push af  
b5b0 3a c4 b5			ld a, (.dmark)  
b5b3 32 b7 ee			ld (debug_mark),a  
b5b6 3a c5 b5			ld a, (.dmark+1)  
b5b9 32 b8 ee			ld (debug_mark+1),a  
b5bc 3a c6 b5			ld a, (.dmark+2)  
b5bf 32 b9 ee			ld (debug_mark+2),a  
b5c2 18 03			jr .pastdmark  
b5c4 ..			.dmark: db "RN3"  
b5c7 f1			.pastdmark: pop af  
b5c8			endm  
# End of macro DMARK
b5c8						CALLMONITOR 
b5c8 cd a3 92			call break_point_state  
b5cb				endm  
# End of macro CALLMONITOR
b5cb					endif 
b5cb					 
b5cb					; if the range is 8bit knock out the high byte 
b5cb			 
b5cb ed 5b 3c ed			ld de, (LFSRSeed)     ; check high level 
b5cf			 
b5cf 3e 00				ld a, 0 
b5d1 ba					cp d  
b5d2 20 1e				jr nz, .hirange 
b5d4 26 00				ld h, 0   ; knock it down to 8bit 
b5d6			 
b5d6					if DEBUG_FORTH_WORDS 
b5d6						DMARK "RNk" 
b5d6 f5				push af  
b5d7 3a eb b5			ld a, (.dmark)  
b5da 32 b7 ee			ld (debug_mark),a  
b5dd 3a ec b5			ld a, (.dmark+1)  
b5e0 32 b8 ee			ld (debug_mark+1),a  
b5e3 3a ed b5			ld a, (.dmark+2)  
b5e6 32 b9 ee			ld (debug_mark+2),a  
b5e9 18 03			jr .pastdmark  
b5eb ..			.dmark: db "RNk"  
b5ee f1			.pastdmark: pop af  
b5ef			endm  
# End of macro DMARK
b5ef						CALLMONITOR 
b5ef cd a3 92			call break_point_state  
b5f2				endm  
# End of macro CALLMONITOR
b5f2					endif 
b5f2			.hirange:   
b5f2 e5					push hl  
b5f3 b7					or a  
b5f4 ed 52		                sbc hl, de 
b5f6			 
b5f6					;call cmp16 
b5f6			 
b5f6 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b5f8 e1					pop hl 
b5f9 e5					push hl 
b5fa			 
b5fa					if DEBUG_FORTH_WORDS 
b5fa						DMARK "RN4" 
b5fa f5				push af  
b5fb 3a 0f b6			ld a, (.dmark)  
b5fe 32 b7 ee			ld (debug_mark),a  
b601 3a 10 b6			ld a, (.dmark+1)  
b604 32 b8 ee			ld (debug_mark+1),a  
b607 3a 11 b6			ld a, (.dmark+2)  
b60a 32 b9 ee			ld (debug_mark+2),a  
b60d 18 03			jr .pastdmark  
b60f ..			.dmark: db "RN4"  
b612 f1			.pastdmark: pop af  
b613			endm  
# End of macro DMARK
b613						CALLMONITOR 
b613 cd a3 92			call break_point_state  
b616				endm  
# End of macro CALLMONITOR
b616					endif 
b616 ed 5b 3e ed			ld de, (LFSRSeed+2)   ; check low range 
b61a					;call cmp16 
b61a				 
b61a b7					or a  
b61b ed 52		                sbc hl, de 
b61d 38 8c				jr c, .inrange 
b61f			 
b61f e1					pop hl 
b620					 
b620					if DEBUG_FORTH_WORDS 
b620						DMARK "RNd" 
b620 f5				push af  
b621 3a 35 b6			ld a, (.dmark)  
b624 32 b7 ee			ld (debug_mark),a  
b627 3a 36 b6			ld a, (.dmark+1)  
b62a 32 b8 ee			ld (debug_mark+1),a  
b62d 3a 37 b6			ld a, (.dmark+2)  
b630 32 b9 ee			ld (debug_mark+2),a  
b633 18 03			jr .pastdmark  
b635 ..			.dmark: db "RNd"  
b638 f1			.pastdmark: pop af  
b639			endm  
# End of macro DMARK
b639						CALLMONITOR 
b639 cd a3 92			call break_point_state  
b63c				endm  
# End of macro CALLMONITOR
b63c					endif 
b63c			 
b63c			 
b63c cd fd 98				call forth_push_numhl 
b63f				       NEXTW 
b63f c3 66 9c			jp macro_next 
b642				endm 
# End of macro NEXTW
b642			 
b642			.ENDMATHS: 
b642			 
b642			; eof 
b642			 
# End of file forth_words_maths.asm
b642			include "forth_words_display.asm" 
b642			 
b642			; | ## Display Words 
b642			 
b642			.INFO: 
b642			 
b642				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b642 62				db WORD_SYS_CORE+78             
b643 5f b6			dw .ATP            
b645 05				db 4 + 1 
b646 .. 00			db "INFO",0              
b64b				endm 
# End of macro CWHEAD
b64b			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b64b					FORTH_DSP_VALUEHL 
b64b cd f4 9a			call macro_dsp_valuehl 
b64e				endm 
# End of macro FORTH_DSP_VALUEHL
b64e			 
b64e					FORTH_DSP_POP 
b64e cd ac 9b			call macro_forth_dsp_pop 
b651				endm 
# End of macro FORTH_DSP_POP
b651			 
b651 e5					push hl 
b652			 
b652					FORTH_DSP_VALUEHL 
b652 cd f4 9a			call macro_dsp_valuehl 
b655				endm 
# End of macro FORTH_DSP_VALUEHL
b655			 
b655					FORTH_DSP_POP 
b655 cd ac 9b			call macro_forth_dsp_pop 
b658				endm 
# End of macro FORTH_DSP_POP
b658			 
b658 d1					pop de 
b659			 
b659 cd 06 88				call info_panel 
b65c			 
b65c			 
b65c					NEXTW 
b65c c3 66 9c			jp macro_next 
b65f				endm 
# End of macro NEXTW
b65f			.ATP: 
b65f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b65f 62				db WORD_SYS_CORE+78             
b660 d6 b6			dw .FB            
b662 04				db 3 + 1 
b663 .. 00			db "AT?",0              
b667				endm 
# End of macro CWHEAD
b667			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b667					if DEBUG_FORTH_WORDS_KEY 
b667						DMARK "AT?" 
b667 f5				push af  
b668 3a 7c b6			ld a, (.dmark)  
b66b 32 b7 ee			ld (debug_mark),a  
b66e 3a 7d b6			ld a, (.dmark+1)  
b671 32 b8 ee			ld (debug_mark+1),a  
b674 3a 7e b6			ld a, (.dmark+2)  
b677 32 b9 ee			ld (debug_mark+2),a  
b67a 18 03			jr .pastdmark  
b67c ..			.dmark: db "AT?"  
b67f f1			.pastdmark: pop af  
b680			endm  
# End of macro DMARK
b680						CALLMONITOR 
b680 cd a3 92			call break_point_state  
b683				endm  
# End of macro CALLMONITOR
b683					endif 
b683 3a c6 ec				ld a, (f_cursor_ptr) 
b686			 
b686			if DEBUG_FORTH_WORDS 
b686				DMARK "AT?" 
b686 f5				push af  
b687 3a 9b b6			ld a, (.dmark)  
b68a 32 b7 ee			ld (debug_mark),a  
b68d 3a 9c b6			ld a, (.dmark+1)  
b690 32 b8 ee			ld (debug_mark+1),a  
b693 3a 9d b6			ld a, (.dmark+2)  
b696 32 b9 ee			ld (debug_mark+2),a  
b699 18 03			jr .pastdmark  
b69b ..			.dmark: db "AT?"  
b69e f1			.pastdmark: pop af  
b69f			endm  
# End of macro DMARK
b69f				CALLMONITOR 
b69f cd a3 92			call break_point_state  
b6a2				endm  
# End of macro CALLMONITOR
b6a2			endif	 
b6a2					; count the number of rows 
b6a2			 
b6a2 06 00				ld b, 0 
b6a4 4f			.atpr:		ld c, a    ; save in case we go below zero 
b6a5 d6 14				sub display_cols 
b6a7 f2 ad b6				jp p, .atprunder 
b6aa 04					inc b 
b6ab 18 f7				jr .atpr 
b6ad			.atprunder:	 
b6ad			if DEBUG_FORTH_WORDS 
b6ad				DMARK "A?2" 
b6ad f5				push af  
b6ae 3a c2 b6			ld a, (.dmark)  
b6b1 32 b7 ee			ld (debug_mark),a  
b6b4 3a c3 b6			ld a, (.dmark+1)  
b6b7 32 b8 ee			ld (debug_mark+1),a  
b6ba 3a c4 b6			ld a, (.dmark+2)  
b6bd 32 b9 ee			ld (debug_mark+2),a  
b6c0 18 03			jr .pastdmark  
b6c2 ..			.dmark: db "A?2"  
b6c5 f1			.pastdmark: pop af  
b6c6			endm  
# End of macro DMARK
b6c6				CALLMONITOR 
b6c6 cd a3 92			call break_point_state  
b6c9				endm  
# End of macro CALLMONITOR
b6c9			endif	 
b6c9 26 00				ld h, 0 
b6cb 69					ld l, c 
b6cc cd fd 98				call forth_push_numhl 
b6cf 68					ld l, b  
b6d0 cd fd 98				call forth_push_numhl 
b6d3			 
b6d3			 
b6d3				NEXTW 
b6d3 c3 66 9c			jp macro_next 
b6d6				endm 
# End of macro NEXTW
b6d6			 
b6d6			.FB: 
b6d6				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b6d6 1b				db WORD_SYS_CORE+7             
b6d7 24 b7			dw .EMIT            
b6d9 03				db 2 + 1 
b6da .. 00			db "FB",0              
b6dd				endm 
# End of macro CWHEAD
b6dd			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b6dd			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b6dd			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b6dd			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b6dd					if DEBUG_FORTH_WORDS_KEY 
b6dd						DMARK "FB." 
b6dd f5				push af  
b6de 3a f2 b6			ld a, (.dmark)  
b6e1 32 b7 ee			ld (debug_mark),a  
b6e4 3a f3 b6			ld a, (.dmark+1)  
b6e7 32 b8 ee			ld (debug_mark+1),a  
b6ea 3a f4 b6			ld a, (.dmark+2)  
b6ed 32 b9 ee			ld (debug_mark+2),a  
b6f0 18 03			jr .pastdmark  
b6f2 ..			.dmark: db "FB."  
b6f5 f1			.pastdmark: pop af  
b6f6			endm  
# End of macro DMARK
b6f6						CALLMONITOR 
b6f6 cd a3 92			call break_point_state  
b6f9				endm  
# End of macro CALLMONITOR
b6f9					endif 
b6f9			 
b6f9					FORTH_DSP_VALUEHL 
b6f9 cd f4 9a			call macro_dsp_valuehl 
b6fc				endm 
# End of macro FORTH_DSP_VALUEHL
b6fc			 
b6fc 7d					ld a, l 
b6fd fe 01				cp 1 
b6ff 20 05				jr nz, .fbn1 
b701 21 fc ed				ld hl, display_fb1 
b704 18 15				jr .fbset 
b706 fe 02		.fbn1:		cp 2 
b708 20 05				jr nz, .fbn2 
b70a 21 5a ed				ld hl, display_fb2 
b70d 18 0c				jr .fbset 
b70f fe 03		.fbn2:		cp 3 
b711 20 05				jr nz, .fbn3 
b713 21 ab ed				ld hl, display_fb3 
b716 18 03				jr .fbset 
b718			.fbn3:		 ; if invalid number select first 
b718 21 fc ed				ld hl, display_fb1 
b71b 22 58 ed		.fbset:		ld (display_fb_active), hl 
b71e			 
b71e					FORTH_DSP_POP 
b71e cd ac 9b			call macro_forth_dsp_pop 
b721				endm 
# End of macro FORTH_DSP_POP
b721			 
b721					NEXTW 
b721 c3 66 9c			jp macro_next 
b724				endm 
# End of macro NEXTW
b724			 
b724			 
b724			.EMIT: 
b724				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b724 1b				db WORD_SYS_CORE+7             
b725 75 b7			dw .DOTH            
b727 05				db 4 + 1 
b728 .. 00			db "EMIT",0              
b72d				endm 
# End of macro CWHEAD
b72d			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b72d					; get value off TOS and display it 
b72d			 
b72d					if DEBUG_FORTH_WORDS_KEY 
b72d						DMARK "EMT" 
b72d f5				push af  
b72e 3a 42 b7			ld a, (.dmark)  
b731 32 b7 ee			ld (debug_mark),a  
b734 3a 43 b7			ld a, (.dmark+1)  
b737 32 b8 ee			ld (debug_mark+1),a  
b73a 3a 44 b7			ld a, (.dmark+2)  
b73d 32 b9 ee			ld (debug_mark+2),a  
b740 18 03			jr .pastdmark  
b742 ..			.dmark: db "EMT"  
b745 f1			.pastdmark: pop af  
b746			endm  
# End of macro DMARK
b746						CALLMONITOR 
b746 cd a3 92			call break_point_state  
b749				endm  
# End of macro CALLMONITOR
b749					endif 
b749			 
b749					FORTH_DSP_VALUEHL 
b749 cd f4 9a			call macro_dsp_valuehl 
b74c				endm 
# End of macro FORTH_DSP_VALUEHL
b74c			 
b74c 7d					ld a,l 
b74d			 
b74d					; TODO write to display 
b74d			 
b74d 32 db e6				ld (os_input), a 
b750 3e 00				ld a, 0 
b752 32 dc e6				ld (os_input+1), a 
b755					 
b755 3a c6 ec				ld a, (f_cursor_ptr) 
b758 11 db e6				ld de, os_input 
b75b cd 88 88				call str_at_display 
b75e			 
b75e			 
b75e 3a a4 ec				ld a,(cli_autodisplay) 
b761 fe 00				cp 0 
b763 28 03				jr z, .enoupdate 
b765 cd 98 88						call update_display 
b768					.enoupdate: 
b768			 
b768 3a c6 ec				ld a, (f_cursor_ptr) 
b76b 3c					inc a 
b76c 32 c6 ec				ld (f_cursor_ptr), a   ; save new pos 
b76f			 
b76f			 
b76f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b76f cd ac 9b			call macro_forth_dsp_pop 
b772				endm 
# End of macro FORTH_DSP_POP
b772			  
b772			 
b772					NEXTW 
b772 c3 66 9c			jp macro_next 
b775				endm 
# End of macro NEXTW
b775			.DOTH: 
b775				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b775 1c				db WORD_SYS_CORE+8             
b776 a5 b7			dw .DOTF            
b778 03				db 2 + 1 
b779 .. 00			db ".-",0              
b77c				endm 
# End of macro CWHEAD
b77c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b77c					; get value off TOS and display it 
b77c					if DEBUG_FORTH_WORDS_KEY 
b77c						DMARK "DTD" 
b77c f5				push af  
b77d 3a 91 b7			ld a, (.dmark)  
b780 32 b7 ee			ld (debug_mark),a  
b783 3a 92 b7			ld a, (.dmark+1)  
b786 32 b8 ee			ld (debug_mark+1),a  
b789 3a 93 b7			ld a, (.dmark+2)  
b78c 32 b9 ee			ld (debug_mark+2),a  
b78f 18 03			jr .pastdmark  
b791 ..			.dmark: db "DTD"  
b794 f1			.pastdmark: pop af  
b795			endm  
# End of macro DMARK
b795						CALLMONITOR 
b795 cd a3 92			call break_point_state  
b798				endm  
# End of macro CALLMONITOR
b798					endif 
b798 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b79a 3e 00			ld a, 0 
b79c 32 a5 ec			ld (cli_mvdot), a 
b79f c3 fc b7			jp .dotgo 
b7a2				NEXTW 
b7a2 c3 66 9c			jp macro_next 
b7a5				endm 
# End of macro NEXTW
b7a5			.DOTF: 
b7a5				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b7a5 1c				db WORD_SYS_CORE+8             
b7a6 d3 b7			dw .DOT            
b7a8 03				db 2 + 1 
b7a9 .. 00			db ".>",0              
b7ac				endm 
# End of macro CWHEAD
b7ac			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b7ac					; get value off TOS and display it 
b7ac			        ; TODO BUG adds extra spaces 
b7ac			        ; TODO BUG handle numerics? 
b7ac					if DEBUG_FORTH_WORDS_KEY 
b7ac						DMARK "DTC" 
b7ac f5				push af  
b7ad 3a c1 b7			ld a, (.dmark)  
b7b0 32 b7 ee			ld (debug_mark),a  
b7b3 3a c2 b7			ld a, (.dmark+1)  
b7b6 32 b8 ee			ld (debug_mark+1),a  
b7b9 3a c3 b7			ld a, (.dmark+2)  
b7bc 32 b9 ee			ld (debug_mark+2),a  
b7bf 18 03			jr .pastdmark  
b7c1 ..			.dmark: db "DTC"  
b7c4 f1			.pastdmark: pop af  
b7c5			endm  
# End of macro DMARK
b7c5						CALLMONITOR 
b7c5 cd a3 92			call break_point_state  
b7c8				endm  
# End of macro CALLMONITOR
b7c8					endif 
b7c8 3e 01			ld a, 1 
b7ca 32 a5 ec			ld (cli_mvdot), a 
b7cd c3 fc b7			jp .dotgo 
b7d0				NEXTW 
b7d0 c3 66 9c			jp macro_next 
b7d3				endm 
# End of macro NEXTW
b7d3			 
b7d3			.DOT: 
b7d3				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b7d3 1c				db WORD_SYS_CORE+8             
b7d4 5f b8			dw .CLS            
b7d6 02				db 1 + 1 
b7d7 .. 00			db ".",0              
b7d9				endm 
# End of macro CWHEAD
b7d9			        ; | . ( u -- ) Display TOS | DONE 
b7d9					; get value off TOS and display it 
b7d9			 
b7d9					if DEBUG_FORTH_WORDS_KEY 
b7d9						DMARK "DOT" 
b7d9 f5				push af  
b7da 3a ee b7			ld a, (.dmark)  
b7dd 32 b7 ee			ld (debug_mark),a  
b7e0 3a ef b7			ld a, (.dmark+1)  
b7e3 32 b8 ee			ld (debug_mark+1),a  
b7e6 3a f0 b7			ld a, (.dmark+2)  
b7e9 32 b9 ee			ld (debug_mark+2),a  
b7ec 18 03			jr .pastdmark  
b7ee ..			.dmark: db "DOT"  
b7f1 f1			.pastdmark: pop af  
b7f2			endm  
# End of macro DMARK
b7f2						CALLMONITOR 
b7f2 cd a3 92			call break_point_state  
b7f5				endm  
# End of macro CALLMONITOR
b7f5					endif 
b7f5 3e 00			ld a, 0 
b7f7 32 a5 ec			ld (cli_mvdot), a 
b7fa 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b7fc				 
b7fc			 
b7fc			.dotgo: 
b7fc			 
b7fc			; move up type to on stack for parserv5 
b7fc					FORTH_DSP 
b7fc cd ba 9a			call macro_forth_dsp 
b7ff				endm 
# End of macro FORTH_DSP
b7ff				;FORTH_DSP_VALUE  
b7ff			 
b7ff			if DEBUG_FORTH_DOT 
b7ff				DMARK "DOT" 
b7ff				CALLMONITOR 
b7ff			endif	 
b7ff			;		.print: 
b7ff			 
b7ff 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b800 23				inc hl   ; position to the actual value 
b801 fe 01			cp DS_TYPE_STR 
b803 20 06			jr nz, .dotnum1  
b805			 
b805			; display string 
b805				FORTH_DSP_VALUE  
b805 cd dd 9a			call macro_forth_dsp_value 
b808				endm 
# End of macro FORTH_DSP_VALUE
b808 eb				ex de,hl 
b809 18 11			jr .dotwrite 
b80b			 
b80b			.dotnum1: 
b80b fe 02			cp DS_TYPE_INUM 
b80d 20 0c			jr nz, .dotflot 
b80f			 
b80f			 
b80f			; display number 
b80f			 
b80f			;	push hl 
b80f			;	call clear_display 
b80f			;	pop hl 
b80f			 
b80f 5e				ld e, (hl) 
b810 23				inc hl 
b811 56				ld d, (hl) 
b812 21 dd e4			ld hl, scratch 
b815			if DEBUG_FORTH_DOT 
b815				DMARK "DT1" 
b815				CALLMONITOR 
b815			endif	 
b815			 
b815 cd af 8e			call uitoa_16 
b818 eb				ex de,hl 
b819			 
b819			if DEBUG_FORTH_DOT 
b819				DMARK "DT2" 
b819				CALLMONITOR 
b819			endif	 
b819			 
b819			;	ld de, os_word_scratch 
b819 18 01			jr .dotwrite 
b81b			 
b81b 00			.dotflot:   nop 
b81c			; TODO print floating point number 
b81c			 
b81c			.dotwrite:		 
b81c			 
b81c					; if c is set then set all '-' to spaces 
b81c					; need to also take into account .>  
b81c			 
b81c 3e 01				ld a, 1 
b81e b9					cp c 
b81f 20 13				jr nz, .nodashswap 
b821			 
b821					; DE has the string to write, working with HL 
b821			 
b821 06 ff				ld b, 255 
b823 d5					push de 
b824 e1					pop hl 
b825			 
b825			if DEBUG_FORTH_DOT 
b825				DMARK "DT-" 
b825				CALLMONITOR 
b825			endif	 
b825 7e			.dashscan:	ld a, (hl) 
b826 fe 00				cp 0 
b828 28 0a				jr z, .nodashswap 
b82a fe 2d				cp '-' 
b82c 20 03				jr nz, .dashskip 
b82e 3e 20				ld a, ' ' 
b830 77					ld (hl), a 
b831 23			.dashskip:	inc hl 
b832			if DEBUG_FORTH_DOT 
b832				DMARK "D-2" 
b832				CALLMONITOR 
b832			endif	 
b832 10 f1				djnz .dashscan 
b834			 
b834			if DEBUG_FORTH_DOT 
b834				DMARK "D-1" 
b834				CALLMONITOR 
b834			endif	 
b834			 
b834			.nodashswap: 
b834			 
b834 e5					push hl   ; save string start in case we need to advance print 
b835			 
b835 3a c6 ec				ld a, (f_cursor_ptr) 
b838 cd 88 88				call str_at_display 
b83b 3a a4 ec				ld a,(cli_autodisplay) 
b83e fe 00				cp 0 
b840 28 03				jr z, .noupdate 
b842 cd 98 88						call update_display 
b845					.noupdate: 
b845			 
b845			 
b845					; see if we need to advance the print position 
b845			 
b845 e1					pop hl   ; get back string 
b846			 
b846 3a a5 ec				ld a, (cli_mvdot) 
b849			if DEBUG_FORTH_DOT 
b849					ld e,a 
b849				DMARK "D>1" 
b849				CALLMONITOR 
b849			endif	 
b849 fe 00				cp 0 
b84b 28 0c				jr z, .noadv 
b84d					; yes, lets advance the print position 
b84d 3e 00				ld a, 0 
b84f cd 0b 8f				call strlent 
b852 3a c6 ec				ld a, (f_cursor_ptr) 
b855 85					add a,l 
b856					;call addatohl 
b856					;ld a, l 
b856 32 c6 ec				ld (f_cursor_ptr), a   ; save new pos 
b859			 
b859			if DEBUG_FORTH_DOT 
b859				DMARK "D->" 
b859				CALLMONITOR 
b859			endif	 
b859			 
b859			.noadv:	 
b859			 
b859					if DEBUG_FORTH_DOT_WAIT 
b859							call next_page_prompt 
b859					endif	 
b859			; TODO this pop off the stack causes a crash. i dont know why 
b859			 
b859			 
b859			if DEBUG_FORTH_DOT 
b859				DMARK "DTh" 
b859				CALLMONITOR 
b859			endif	 
b859			 
b859					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b859 cd ac 9b			call macro_forth_dsp_pop 
b85c				endm 
# End of macro FORTH_DSP_POP
b85c			 
b85c			if DEBUG_FORTH_DOT 
b85c				DMARK "DTi" 
b85c				CALLMONITOR 
b85c			endif	 
b85c			 
b85c			 
b85c					NEXTW 
b85c c3 66 9c			jp macro_next 
b85f				endm 
# End of macro NEXTW
b85f			 
b85f			.CLS: 
b85f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b85f 35				db WORD_SYS_CORE+33             
b860 8c b8			dw .DRAW            
b862 04				db 3 + 1 
b863 .. 00			db "CLS",0              
b867				endm 
# End of macro CWHEAD
b867			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b867					if DEBUG_FORTH_WORDS_KEY 
b867						DMARK "CLS" 
b867 f5				push af  
b868 3a 7c b8			ld a, (.dmark)  
b86b 32 b7 ee			ld (debug_mark),a  
b86e 3a 7d b8			ld a, (.dmark+1)  
b871 32 b8 ee			ld (debug_mark+1),a  
b874 3a 7e b8			ld a, (.dmark+2)  
b877 32 b9 ee			ld (debug_mark+2),a  
b87a 18 03			jr .pastdmark  
b87c ..			.dmark: db "CLS"  
b87f f1			.pastdmark: pop af  
b880			endm  
# End of macro DMARK
b880						CALLMONITOR 
b880 cd a3 92			call break_point_state  
b883				endm  
# End of macro CALLMONITOR
b883					endif 
b883 cd 75 88				call clear_display 
b886 c3 9a b9				jp .home		; and home cursor 
b889					NEXTW 
b889 c3 66 9c			jp macro_next 
b88c				endm 
# End of macro NEXTW
b88c			 
b88c			.DRAW: 
b88c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b88c 36				db WORD_SYS_CORE+34             
b88d b7 b8			dw .DUMP            
b88f 05				db 4 + 1 
b890 .. 00			db "DRAW",0              
b895				endm 
# End of macro CWHEAD
b895			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b895					if DEBUG_FORTH_WORDS_KEY 
b895						DMARK "DRW" 
b895 f5				push af  
b896 3a aa b8			ld a, (.dmark)  
b899 32 b7 ee			ld (debug_mark),a  
b89c 3a ab b8			ld a, (.dmark+1)  
b89f 32 b8 ee			ld (debug_mark+1),a  
b8a2 3a ac b8			ld a, (.dmark+2)  
b8a5 32 b9 ee			ld (debug_mark+2),a  
b8a8 18 03			jr .pastdmark  
b8aa ..			.dmark: db "DRW"  
b8ad f1			.pastdmark: pop af  
b8ae			endm  
# End of macro DMARK
b8ae						CALLMONITOR 
b8ae cd a3 92			call break_point_state  
b8b1				endm  
# End of macro CALLMONITOR
b8b1					endif 
b8b1 cd 98 88				call update_display 
b8b4					NEXTW 
b8b4 c3 66 9c			jp macro_next 
b8b7				endm 
# End of macro NEXTW
b8b7			 
b8b7			.DUMP: 
b8b7				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b8b7 37				db WORD_SYS_CORE+35             
b8b8 ef b8			dw .CDUMP            
b8ba 05				db 4 + 1 
b8bb .. 00			db "DUMP",0              
b8c0				endm 
# End of macro CWHEAD
b8c0			; | DUMP ( x -- ) With address x display dump   | DONE 
b8c0			; TODO pop address to use off of the stack 
b8c0					if DEBUG_FORTH_WORDS_KEY 
b8c0						DMARK "DUM" 
b8c0 f5				push af  
b8c1 3a d5 b8			ld a, (.dmark)  
b8c4 32 b7 ee			ld (debug_mark),a  
b8c7 3a d6 b8			ld a, (.dmark+1)  
b8ca 32 b8 ee			ld (debug_mark+1),a  
b8cd 3a d7 b8			ld a, (.dmark+2)  
b8d0 32 b9 ee			ld (debug_mark+2),a  
b8d3 18 03			jr .pastdmark  
b8d5 ..			.dmark: db "DUM"  
b8d8 f1			.pastdmark: pop af  
b8d9			endm  
# End of macro DMARK
b8d9						CALLMONITOR 
b8d9 cd a3 92			call break_point_state  
b8dc				endm  
# End of macro CALLMONITOR
b8dc					endif 
b8dc cd 75 88				call clear_display 
b8df			 
b8df					; get address 
b8df			 
b8df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8df cd f4 9a			call macro_dsp_valuehl 
b8e2				endm 
# End of macro FORTH_DSP_VALUEHL
b8e2				 
b8e2					; save it for cdump 
b8e2			 
b8e2 22 00 e8				ld (os_cur_ptr),hl 
b8e5			 
b8e5					; destroy value TOS 
b8e5			 
b8e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8e5 cd ac 9b			call macro_forth_dsp_pop 
b8e8				endm 
# End of macro FORTH_DSP_POP
b8e8			 
b8e8 cd 7d 97				call dumpcont	; skip old style of param parsing	 
b8eb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b8ec					NEXTW 
b8ec c3 66 9c			jp macro_next 
b8ef				endm 
# End of macro NEXTW
b8ef			.CDUMP: 
b8ef				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b8ef 38				db WORD_SYS_CORE+36             
b8f0 1f b9			dw .DAT            
b8f2 06				db 5 + 1 
b8f3 .. 00			db "CDUMP",0              
b8f9				endm 
# End of macro CWHEAD
b8f9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b8f9					if DEBUG_FORTH_WORDS_KEY 
b8f9						DMARK "CDP" 
b8f9 f5				push af  
b8fa 3a 0e b9			ld a, (.dmark)  
b8fd 32 b7 ee			ld (debug_mark),a  
b900 3a 0f b9			ld a, (.dmark+1)  
b903 32 b8 ee			ld (debug_mark+1),a  
b906 3a 10 b9			ld a, (.dmark+2)  
b909 32 b9 ee			ld (debug_mark+2),a  
b90c 18 03			jr .pastdmark  
b90e ..			.dmark: db "CDP"  
b911 f1			.pastdmark: pop af  
b912			endm  
# End of macro DMARK
b912						CALLMONITOR 
b912 cd a3 92			call break_point_state  
b915				endm  
# End of macro CALLMONITOR
b915					endif 
b915 cd 75 88				call clear_display 
b918 cd 7d 97				call dumpcont	 
b91b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b91c					NEXTW 
b91c c3 66 9c			jp macro_next 
b91f				endm 
# End of macro NEXTW
b91f			 
b91f			 
b91f			 
b91f			 
b91f			.DAT: 
b91f				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b91f 3d				db WORD_SYS_CORE+41             
b920 75 b9			dw .HOME            
b922 03				db 2 + 1 
b923 .. 00			db "AT",0              
b926				endm 
# End of macro CWHEAD
b926			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b926					if DEBUG_FORTH_WORDS_KEY 
b926						DMARK "AT." 
b926 f5				push af  
b927 3a 3b b9			ld a, (.dmark)  
b92a 32 b7 ee			ld (debug_mark),a  
b92d 3a 3c b9			ld a, (.dmark+1)  
b930 32 b8 ee			ld (debug_mark+1),a  
b933 3a 3d b9			ld a, (.dmark+2)  
b936 32 b9 ee			ld (debug_mark+2),a  
b939 18 03			jr .pastdmark  
b93b ..			.dmark: db "AT."  
b93e f1			.pastdmark: pop af  
b93f			endm  
# End of macro DMARK
b93f						CALLMONITOR 
b93f cd a3 92			call break_point_state  
b942				endm  
# End of macro CALLMONITOR
b942					endif 
b942					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b942 cd f4 9a			call macro_dsp_valuehl 
b945				endm 
# End of macro FORTH_DSP_VALUEHL
b945			 
b945			 
b945					; TODO save cursor row 
b945 7d					ld a,l 
b946 fe 02				cp 2 
b948 20 04				jr nz, .crow3 
b94a 3e 14				ld a, display_row_2 
b94c 18 12				jr .ccol1 
b94e fe 03		.crow3:		cp 3 
b950 20 04				jr nz, .crow4 
b952 3e 28				ld a, display_row_3 
b954 18 0a				jr .ccol1 
b956 fe 04		.crow4:		cp 4 
b958 20 04				jr nz, .crow1 
b95a 3e 3c				ld a, display_row_4 
b95c 18 02				jr .ccol1 
b95e 3e 00		.crow1:		ld a,display_row_1 
b960 f5			.ccol1:		push af			; got row offset 
b961 6f					ld l,a 
b962 26 00				ld h,0 
b964					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b964 cd ac 9b			call macro_forth_dsp_pop 
b967				endm 
# End of macro FORTH_DSP_POP
b967					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b967 cd f4 9a			call macro_dsp_valuehl 
b96a				endm 
# End of macro FORTH_DSP_VALUEHL
b96a					; TODO save cursor col 
b96a f1					pop af 
b96b 85					add l		; add col offset 
b96c 32 c6 ec				ld (f_cursor_ptr), a 
b96f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b96f cd ac 9b			call macro_forth_dsp_pop 
b972				endm 
# End of macro FORTH_DSP_POP
b972			 
b972					; calculate  
b972			 
b972					NEXTW 
b972 c3 66 9c			jp macro_next 
b975				endm 
# End of macro NEXTW
b975			 
b975			 
b975			.HOME: 
b975				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b975 41				db WORD_SYS_CORE+45             
b976 a2 b9			dw .SPACE            
b978 05				db 4 + 1 
b979 .. 00			db "HOME",0              
b97e				endm 
# End of macro CWHEAD
b97e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b97e					if DEBUG_FORTH_WORDS_KEY 
b97e						DMARK "HOM" 
b97e f5				push af  
b97f 3a 93 b9			ld a, (.dmark)  
b982 32 b7 ee			ld (debug_mark),a  
b985 3a 94 b9			ld a, (.dmark+1)  
b988 32 b8 ee			ld (debug_mark+1),a  
b98b 3a 95 b9			ld a, (.dmark+2)  
b98e 32 b9 ee			ld (debug_mark+2),a  
b991 18 03			jr .pastdmark  
b993 ..			.dmark: db "HOM"  
b996 f1			.pastdmark: pop af  
b997			endm  
# End of macro DMARK
b997						CALLMONITOR 
b997 cd a3 92			call break_point_state  
b99a				endm  
# End of macro CALLMONITOR
b99a					endif 
b99a 3e 00		.home:		ld a, 0		; and home cursor 
b99c 32 c6 ec				ld (f_cursor_ptr), a 
b99f					NEXTW 
b99f c3 66 9c			jp macro_next 
b9a2				endm 
# End of macro NEXTW
b9a2			 
b9a2			 
b9a2			.SPACE: 
b9a2				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b9a2 46				db WORD_SYS_CORE+50             
b9a3 d0 b9			dw .SPACES            
b9a5 03				db 2 + 1 
b9a6 .. 00			db "BL",0              
b9a9				endm 
# End of macro CWHEAD
b9a9			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b9a9					if DEBUG_FORTH_WORDS_KEY 
b9a9						DMARK "BL." 
b9a9 f5				push af  
b9aa 3a be b9			ld a, (.dmark)  
b9ad 32 b7 ee			ld (debug_mark),a  
b9b0 3a bf b9			ld a, (.dmark+1)  
b9b3 32 b8 ee			ld (debug_mark+1),a  
b9b6 3a c0 b9			ld a, (.dmark+2)  
b9b9 32 b9 ee			ld (debug_mark+2),a  
b9bc 18 03			jr .pastdmark  
b9be ..			.dmark: db "BL."  
b9c1 f1			.pastdmark: pop af  
b9c2			endm  
# End of macro DMARK
b9c2						CALLMONITOR 
b9c2 cd a3 92			call break_point_state  
b9c5				endm  
# End of macro CALLMONITOR
b9c5					endif 
b9c5 21 ce b9				ld hl, .blstr 
b9c8 cd 6b 99				call forth_push_str 
b9cb					 
b9cb				       NEXTW 
b9cb c3 66 9c			jp macro_next 
b9ce				endm 
# End of macro NEXTW
b9ce			 
b9ce .. 00		.blstr: db " ", 0 
b9d0			 
b9d0			.SPACES: 
b9d0				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b9d0 47				db WORD_SYS_CORE+51             
b9d1 6b ba			dw .SCROLL            
b9d3 07				db 6 + 1 
b9d4 .. 00			db "SPACES",0              
b9db				endm 
# End of macro CWHEAD
b9db			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b9db					if DEBUG_FORTH_WORDS_KEY 
b9db						DMARK "SPS" 
b9db f5				push af  
b9dc 3a f0 b9			ld a, (.dmark)  
b9df 32 b7 ee			ld (debug_mark),a  
b9e2 3a f1 b9			ld a, (.dmark+1)  
b9e5 32 b8 ee			ld (debug_mark+1),a  
b9e8 3a f2 b9			ld a, (.dmark+2)  
b9eb 32 b9 ee			ld (debug_mark+2),a  
b9ee 18 03			jr .pastdmark  
b9f0 ..			.dmark: db "SPS"  
b9f3 f1			.pastdmark: pop af  
b9f4			endm  
# End of macro DMARK
b9f4						CALLMONITOR 
b9f4 cd a3 92			call break_point_state  
b9f7				endm  
# End of macro CALLMONITOR
b9f7					endif 
b9f7			 
b9f7			 
b9f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9f7 cd f4 9a			call macro_dsp_valuehl 
b9fa				endm 
# End of macro FORTH_DSP_VALUEHL
b9fa			 
b9fa			;		push hl    ; u 
b9fa					if DEBUG_FORTH_WORDS 
b9fa						DMARK "SPA" 
b9fa f5				push af  
b9fb 3a 0f ba			ld a, (.dmark)  
b9fe 32 b7 ee			ld (debug_mark),a  
ba01 3a 10 ba			ld a, (.dmark+1)  
ba04 32 b8 ee			ld (debug_mark+1),a  
ba07 3a 11 ba			ld a, (.dmark+2)  
ba0a 32 b9 ee			ld (debug_mark+2),a  
ba0d 18 03			jr .pastdmark  
ba0f ..			.dmark: db "SPA"  
ba12 f1			.pastdmark: pop af  
ba13			endm  
# End of macro DMARK
ba13						CALLMONITOR 
ba13 cd a3 92			call break_point_state  
ba16				endm  
# End of macro CALLMONITOR
ba16					endif 
ba16			 
ba16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba16 cd ac 9b			call macro_forth_dsp_pop 
ba19				endm 
# End of macro FORTH_DSP_POP
ba19			;		pop hl 
ba19 4d					ld c, l 
ba1a 06 00				ld b, 0 
ba1c 21 dd e4				ld hl, scratch  
ba1f			 
ba1f					if DEBUG_FORTH_WORDS 
ba1f						DMARK "SP2" 
ba1f f5				push af  
ba20 3a 34 ba			ld a, (.dmark)  
ba23 32 b7 ee			ld (debug_mark),a  
ba26 3a 35 ba			ld a, (.dmark+1)  
ba29 32 b8 ee			ld (debug_mark+1),a  
ba2c 3a 36 ba			ld a, (.dmark+2)  
ba2f 32 b9 ee			ld (debug_mark+2),a  
ba32 18 03			jr .pastdmark  
ba34 ..			.dmark: db "SP2"  
ba37 f1			.pastdmark: pop af  
ba38			endm  
# End of macro DMARK
ba38						CALLMONITOR 
ba38 cd a3 92			call break_point_state  
ba3b				endm  
# End of macro CALLMONITOR
ba3b					endif 
ba3b 3e 20				ld a, ' ' 
ba3d c5			.spaces1:	push bc 
ba3e 77					ld (hl),a 
ba3f 23					inc hl 
ba40 c1					pop bc 
ba41 10 fa				djnz .spaces1 
ba43 3e 00				ld a,0 
ba45 77					ld (hl),a 
ba46 21 dd e4				ld hl, scratch 
ba49					if DEBUG_FORTH_WORDS 
ba49						DMARK "SP3" 
ba49 f5				push af  
ba4a 3a 5e ba			ld a, (.dmark)  
ba4d 32 b7 ee			ld (debug_mark),a  
ba50 3a 5f ba			ld a, (.dmark+1)  
ba53 32 b8 ee			ld (debug_mark+1),a  
ba56 3a 60 ba			ld a, (.dmark+2)  
ba59 32 b9 ee			ld (debug_mark+2),a  
ba5c 18 03			jr .pastdmark  
ba5e ..			.dmark: db "SP3"  
ba61 f1			.pastdmark: pop af  
ba62			endm  
# End of macro DMARK
ba62						CALLMONITOR 
ba62 cd a3 92			call break_point_state  
ba65				endm  
# End of macro CALLMONITOR
ba65					endif 
ba65 cd 66 9a				call forth_apush 
ba68			 
ba68				       NEXTW 
ba68 c3 66 9c			jp macro_next 
ba6b				endm 
# End of macro NEXTW
ba6b			 
ba6b			 
ba6b			 
ba6b			.SCROLL: 
ba6b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
ba6b 53				db WORD_SYS_CORE+63             
ba6c 98 ba			dw .SCROLLD            
ba6e 07				db 6 + 1 
ba6f .. 00			db "SCROLL",0              
ba76				endm 
# End of macro CWHEAD
ba76			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
ba76					if DEBUG_FORTH_WORDS_KEY 
ba76						DMARK "SCR" 
ba76 f5				push af  
ba77 3a 8b ba			ld a, (.dmark)  
ba7a 32 b7 ee			ld (debug_mark),a  
ba7d 3a 8c ba			ld a, (.dmark+1)  
ba80 32 b8 ee			ld (debug_mark+1),a  
ba83 3a 8d ba			ld a, (.dmark+2)  
ba86 32 b9 ee			ld (debug_mark+2),a  
ba89 18 03			jr .pastdmark  
ba8b ..			.dmark: db "SCR"  
ba8e f1			.pastdmark: pop af  
ba8f			endm  
# End of macro DMARK
ba8f						CALLMONITOR 
ba8f cd a3 92			call break_point_state  
ba92				endm  
# End of macro CALLMONITOR
ba92					endif 
ba92			 
ba92 cd 37 88			call scroll_up 
ba95			;	call update_display 
ba95			 
ba95					NEXTW 
ba95 c3 66 9c			jp macro_next 
ba98				endm 
# End of macro NEXTW
ba98			 
ba98			 
ba98			 
ba98			;		; get dir 
ba98			; 
ba98			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba98			; 
ba98			;		push hl 
ba98			; 
ba98			;		; destroy value TOS 
ba98			; 
ba98			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba98			; 
ba98			;		; get count 
ba98			; 
ba98			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba98			; 
ba98			;		push hl 
ba98			; 
ba98			;		; destroy value TOS 
ba98			; 
ba98			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba98			; 
ba98			;		; one value on hl get other one back 
ba98			; 
ba98			;		pop bc    ; count 
ba98			; 
ba98			;		pop de   ; dir 
ba98			; 
ba98			; 
ba98			;		ld b, c 
ba98			; 
ba98			;.scrolldir:     push bc 
ba98			;		push de 
ba98			; 
ba98			;		ld a, 0 
ba98			;		cp e 
ba98			;		jr z, .scrollup  
ba98			;		call scroll_down 
ba98			;		jr .scrollnext 
ba98			;.scrollup:	call scroll_up 
ba98			; 
ba98			;		 
ba98			;.scrollnext: 
ba98			;		pop de 
ba98			;		pop bc 
ba98			;		djnz .scrolldir 
ba98			; 
ba98			; 
ba98			; 
ba98			; 
ba98			; 
ba98			;		NEXTW 
ba98			 
ba98			.SCROLLD: 
ba98				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
ba98 53				db WORD_SYS_CORE+63             
ba99 c6 ba			dw .ATQ            
ba9b 08				db 7 + 1 
ba9c .. 00			db "SCROLLD",0              
baa4				endm 
# End of macro CWHEAD
baa4			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
baa4					if DEBUG_FORTH_WORDS_KEY 
baa4						DMARK "SCD" 
baa4 f5				push af  
baa5 3a b9 ba			ld a, (.dmark)  
baa8 32 b7 ee			ld (debug_mark),a  
baab 3a ba ba			ld a, (.dmark+1)  
baae 32 b8 ee			ld (debug_mark+1),a  
bab1 3a bb ba			ld a, (.dmark+2)  
bab4 32 b9 ee			ld (debug_mark+2),a  
bab7 18 03			jr .pastdmark  
bab9 ..			.dmark: db "SCD"  
babc f1			.pastdmark: pop af  
babd			endm  
# End of macro DMARK
babd						CALLMONITOR 
babd cd a3 92			call break_point_state  
bac0				endm  
# End of macro CALLMONITOR
bac0					endif 
bac0			 
bac0 cd 5b 88			call scroll_down 
bac3			;	call update_display 
bac3			 
bac3					NEXTW 
bac3 c3 66 9c			jp macro_next 
bac6				endm 
# End of macro NEXTW
bac6			 
bac6			 
bac6			.ATQ: 
bac6				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bac6 62				db WORD_SYS_CORE+78             
bac7 24 bb			dw .AUTODSP            
bac9 04				db 3 + 1 
baca .. 00			db "AT@",0              
bace				endm 
# End of macro CWHEAD
bace			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bace					if DEBUG_FORTH_WORDS_KEY 
bace						DMARK "ATA" 
bace f5				push af  
bacf 3a e3 ba			ld a, (.dmark)  
bad2 32 b7 ee			ld (debug_mark),a  
bad5 3a e4 ba			ld a, (.dmark+1)  
bad8 32 b8 ee			ld (debug_mark+1),a  
badb 3a e5 ba			ld a, (.dmark+2)  
bade 32 b9 ee			ld (debug_mark+2),a  
bae1 18 03			jr .pastdmark  
bae3 ..			.dmark: db "ATA"  
bae6 f1			.pastdmark: pop af  
bae7			endm  
# End of macro DMARK
bae7						CALLMONITOR 
bae7 cd a3 92			call break_point_state  
baea				endm  
# End of macro CALLMONITOR
baea					endif 
baea			 
baea			 
baea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
baea cd f4 9a			call macro_dsp_valuehl 
baed				endm 
# End of macro FORTH_DSP_VALUEHL
baed			 
baed					; TODO save cursor row 
baed 7d					ld a,l 
baee fe 02				cp 2 
baf0 20 04				jr nz, .crow3aq 
baf2 3e 14				ld a, display_row_2 
baf4 18 12				jr .ccol1aq 
baf6 fe 03		.crow3aq:		cp 3 
baf8 20 04				jr nz, .crow4aq 
bafa 3e 28				ld a, display_row_3 
bafc 18 0a				jr .ccol1aq 
bafe fe 04		.crow4aq:		cp 4 
bb00 20 04				jr nz, .crow1aq 
bb02 3e 3c				ld a, display_row_4 
bb04 18 02				jr .ccol1aq 
bb06 3e 00		.crow1aq:		ld a,display_row_1 
bb08 f5			.ccol1aq:		push af			; got row offset 
bb09 6f					ld l,a 
bb0a 26 00				ld h,0 
bb0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb0c cd ac 9b			call macro_forth_dsp_pop 
bb0f				endm 
# End of macro FORTH_DSP_POP
bb0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb0f cd f4 9a			call macro_dsp_valuehl 
bb12				endm 
# End of macro FORTH_DSP_VALUEHL
bb12					; TODO save cursor col 
bb12 f1					pop af 
bb13 85					add l		; add col offset 
bb14			 
bb14					; add current frame buffer address 
bb14 2a 58 ed				ld hl, (display_fb_active) 
bb17 cd a2 8a				call addatohl 
bb1a			 
bb1a			 
bb1a			 
bb1a			 
bb1a					; get char frame buffer location offset in hl 
bb1a			 
bb1a 7e					ld a,(hl) 
bb1b 26 00				ld h, 0 
bb1d 6f					ld l, a 
bb1e			 
bb1e cd fd 98				call forth_push_numhl 
bb21			 
bb21			 
bb21					NEXTW 
bb21 c3 66 9c			jp macro_next 
bb24				endm 
# End of macro NEXTW
bb24			 
bb24			.AUTODSP: 
bb24				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bb24 63				db WORD_SYS_CORE+79             
bb25 3a bb			dw .MENU            
bb27 05				db 4 + 1 
bb28 .. 00			db "ADSP",0              
bb2d				endm 
# End of macro CWHEAD
bb2d			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bb2d			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bb2d			 
bb2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb2d cd f4 9a			call macro_dsp_valuehl 
bb30				endm 
# End of macro FORTH_DSP_VALUEHL
bb30			 
bb30			;		push hl 
bb30			 
bb30					; destroy value TOS 
bb30			 
bb30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb30 cd ac 9b			call macro_forth_dsp_pop 
bb33				endm 
# End of macro FORTH_DSP_POP
bb33			 
bb33			;		pop hl 
bb33			 
bb33 7d					ld a,l 
bb34 32 a4 ec				ld (cli_autodisplay), a 
bb37				       NEXTW 
bb37 c3 66 9c			jp macro_next 
bb3a				endm 
# End of macro NEXTW
bb3a			 
bb3a			.MENU: 
bb3a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bb3a 70				db WORD_SYS_CORE+92             
bb3b e3 bb			dw .ENDDISPLAY            
bb3d 05				db 4 + 1 
bb3e .. 00			db "MENU",0              
bb43				endm 
# End of macro CWHEAD
bb43			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bb43			 
bb43			;		; get number of items on the stack 
bb43			; 
bb43				 
bb43					FORTH_DSP_VALUEHL 
bb43 cd f4 9a			call macro_dsp_valuehl 
bb46				endm 
# End of macro FORTH_DSP_VALUEHL
bb46				 
bb46					if DEBUG_FORTH_WORDS_KEY 
bb46						DMARK "MNU" 
bb46 f5				push af  
bb47 3a 5b bb			ld a, (.dmark)  
bb4a 32 b7 ee			ld (debug_mark),a  
bb4d 3a 5c bb			ld a, (.dmark+1)  
bb50 32 b8 ee			ld (debug_mark+1),a  
bb53 3a 5d bb			ld a, (.dmark+2)  
bb56 32 b9 ee			ld (debug_mark+2),a  
bb59 18 03			jr .pastdmark  
bb5b ..			.dmark: db "MNU"  
bb5e f1			.pastdmark: pop af  
bb5f			endm  
# End of macro DMARK
bb5f						CALLMONITOR 
bb5f cd a3 92			call break_point_state  
bb62				endm  
# End of macro CALLMONITOR
bb62					endif 
bb62			 
bb62 45					ld b, l	 
bb63 05					dec b 
bb64			 
bb64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb64 cd ac 9b			call macro_forth_dsp_pop 
bb67				endm 
# End of macro FORTH_DSP_POP
bb67			 
bb67			 
bb67					; go directly through the stack to pluck out the string pointers and build an array 
bb67			 
bb67			;		FORTH_DSP 
bb67			 
bb67					; hl contains top most stack item 
bb67				 
bb67 11 dd e4				ld de, scratch 
bb6a			 
bb6a			.mbuild: 
bb6a			 
bb6a					FORTH_DSP_VALUEHL 
bb6a cd f4 9a			call macro_dsp_valuehl 
bb6d				endm 
# End of macro FORTH_DSP_VALUEHL
bb6d			 
bb6d					if DEBUG_FORTH_WORDS 
bb6d						DMARK "MN3" 
bb6d f5				push af  
bb6e 3a 82 bb			ld a, (.dmark)  
bb71 32 b7 ee			ld (debug_mark),a  
bb74 3a 83 bb			ld a, (.dmark+1)  
bb77 32 b8 ee			ld (debug_mark+1),a  
bb7a 3a 84 bb			ld a, (.dmark+2)  
bb7d 32 b9 ee			ld (debug_mark+2),a  
bb80 18 03			jr .pastdmark  
bb82 ..			.dmark: db "MN3"  
bb85 f1			.pastdmark: pop af  
bb86			endm  
# End of macro DMARK
bb86						CALLMONITOR 
bb86 cd a3 92			call break_point_state  
bb89				endm  
# End of macro CALLMONITOR
bb89					endif 
bb89 eb					ex de, hl 
bb8a 73					ld (hl), e 
bb8b 23					inc hl 
bb8c 72					ld (hl), d 
bb8d 23					inc hl 
bb8e eb					ex de, hl 
bb8f			 
bb8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb8f cd ac 9b			call macro_forth_dsp_pop 
bb92				endm 
# End of macro FORTH_DSP_POP
bb92			 
bb92 10 d6				djnz .mbuild 
bb94			 
bb94					; done add term 
bb94			 
bb94 eb					ex de, hl 
bb95 36 00				ld (hl), 0 
bb97 23					inc hl 
bb98 36 00				ld (hl), 0 
bb9a			 
bb9a				 
bb9a					 
bb9a 21 dd e4				ld hl, scratch 
bb9d			 
bb9d					if DEBUG_FORTH_WORDS 
bb9d						DMARK "MNx" 
bb9d f5				push af  
bb9e 3a b2 bb			ld a, (.dmark)  
bba1 32 b7 ee			ld (debug_mark),a  
bba4 3a b3 bb			ld a, (.dmark+1)  
bba7 32 b8 ee			ld (debug_mark+1),a  
bbaa 3a b4 bb			ld a, (.dmark+2)  
bbad 32 b9 ee			ld (debug_mark+2),a  
bbb0 18 03			jr .pastdmark  
bbb2 ..			.dmark: db "MNx"  
bbb5 f1			.pastdmark: pop af  
bbb6			endm  
# End of macro DMARK
bbb6						CALLMONITOR 
bbb6 cd a3 92			call break_point_state  
bbb9				endm  
# End of macro CALLMONITOR
bbb9					endif 
bbb9			 
bbb9			 
bbb9			 
bbb9 3e 00				ld a, 0 
bbbb cd a6 88				call menu 
bbbe			 
bbbe			 
bbbe 6f					ld l, a 
bbbf 26 00				ld h, 0 
bbc1			 
bbc1					if DEBUG_FORTH_WORDS 
bbc1						DMARK "MNr" 
bbc1 f5				push af  
bbc2 3a d6 bb			ld a, (.dmark)  
bbc5 32 b7 ee			ld (debug_mark),a  
bbc8 3a d7 bb			ld a, (.dmark+1)  
bbcb 32 b8 ee			ld (debug_mark+1),a  
bbce 3a d8 bb			ld a, (.dmark+2)  
bbd1 32 b9 ee			ld (debug_mark+2),a  
bbd4 18 03			jr .pastdmark  
bbd6 ..			.dmark: db "MNr"  
bbd9 f1			.pastdmark: pop af  
bbda			endm  
# End of macro DMARK
bbda						CALLMONITOR 
bbda cd a3 92			call break_point_state  
bbdd				endm  
# End of macro CALLMONITOR
bbdd					endif 
bbdd			 
bbdd cd fd 98				call forth_push_numhl 
bbe0			 
bbe0			 
bbe0			 
bbe0			 
bbe0				       NEXTW 
bbe0 c3 66 9c			jp macro_next 
bbe3				endm 
# End of macro NEXTW
bbe3			 
bbe3			 
bbe3			.ENDDISPLAY: 
bbe3			 
bbe3			; eof 
# End of file forth_words_display.asm
bbe3			include "forth_words_str.asm" 
bbe3			 
bbe3			; | ## String Words 
bbe3			 
bbe3			.PTR:   
bbe3			 
bbe3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bbe3 48				db WORD_SYS_CORE+52             
bbe4 10 bc			dw .STYPE            
bbe6 04				db 3 + 1 
bbe7 .. 00			db "PTR",0              
bbeb				endm 
# End of macro CWHEAD
bbeb			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bbeb			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bbeb			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bbeb			 
bbeb					if DEBUG_FORTH_WORDS_KEY 
bbeb						DMARK "PTR" 
bbeb f5				push af  
bbec 3a 00 bc			ld a, (.dmark)  
bbef 32 b7 ee			ld (debug_mark),a  
bbf2 3a 01 bc			ld a, (.dmark+1)  
bbf5 32 b8 ee			ld (debug_mark+1),a  
bbf8 3a 02 bc			ld a, (.dmark+2)  
bbfb 32 b9 ee			ld (debug_mark+2),a  
bbfe 18 03			jr .pastdmark  
bc00 ..			.dmark: db "PTR"  
bc03 f1			.pastdmark: pop af  
bc04			endm  
# End of macro DMARK
bc04						CALLMONITOR 
bc04 cd a3 92			call break_point_state  
bc07				endm  
# End of macro CALLMONITOR
bc07					endif 
bc07					FORTH_DSP_VALUEHL 
bc07 cd f4 9a			call macro_dsp_valuehl 
bc0a				endm 
# End of macro FORTH_DSP_VALUEHL
bc0a cd fd 98				call forth_push_numhl 
bc0d			 
bc0d			 
bc0d					NEXTW 
bc0d c3 66 9c			jp macro_next 
bc10				endm 
# End of macro NEXTW
bc10			.STYPE: 
bc10				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bc10 48				db WORD_SYS_CORE+52             
bc11 5f bc			dw .UPPER            
bc13 06				db 5 + 1 
bc14 .. 00			db "STYPE",0              
bc1a				endm 
# End of macro CWHEAD
bc1a			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bc1a					if DEBUG_FORTH_WORDS_KEY 
bc1a						DMARK "STY" 
bc1a f5				push af  
bc1b 3a 2f bc			ld a, (.dmark)  
bc1e 32 b7 ee			ld (debug_mark),a  
bc21 3a 30 bc			ld a, (.dmark+1)  
bc24 32 b8 ee			ld (debug_mark+1),a  
bc27 3a 31 bc			ld a, (.dmark+2)  
bc2a 32 b9 ee			ld (debug_mark+2),a  
bc2d 18 03			jr .pastdmark  
bc2f ..			.dmark: db "STY"  
bc32 f1			.pastdmark: pop af  
bc33			endm  
# End of macro DMARK
bc33						CALLMONITOR 
bc33 cd a3 92			call break_point_state  
bc36				endm  
# End of macro CALLMONITOR
bc36					endif 
bc36					FORTH_DSP 
bc36 cd ba 9a			call macro_forth_dsp 
bc39				endm 
# End of macro FORTH_DSP
bc39					;v5 FORTH_DSP_VALUE 
bc39			 
bc39 7e					ld a, (hl) 
bc3a			 
bc3a f5					push af 
bc3b			 
bc3b			; Dont destroy TOS		FORTH_DSP_POP 
bc3b			 
bc3b f1					pop af 
bc3c			 
bc3c fe 01				cp DS_TYPE_STR 
bc3e 28 09				jr z, .typestr 
bc40			 
bc40 fe 02				cp DS_TYPE_INUM 
bc42 28 0a				jr z, .typeinum 
bc44			 
bc44 21 5d bc				ld hl, .tna 
bc47 18 0a				jr .tpush 
bc49			 
bc49 21 59 bc		.typestr:	ld hl, .tstr 
bc4c 18 05				jr .tpush 
bc4e 21 5b bc		.typeinum:	ld hl, .tinum 
bc51 18 00				jr .tpush 
bc53			 
bc53			.tpush: 
bc53			 
bc53 cd 6b 99				call forth_push_str 
bc56			 
bc56					NEXTW 
bc56 c3 66 9c			jp macro_next 
bc59				endm 
# End of macro NEXTW
bc59 .. 00		.tstr:	db "s",0 
bc5b .. 00		.tinum:  db "i",0 
bc5d .. 00		.tna:   db "?", 0 
bc5f			 
bc5f			 
bc5f			.UPPER: 
bc5f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bc5f 48				db WORD_SYS_CORE+52             
bc60 9a bc			dw .LOWER            
bc62 06				db 5 + 1 
bc63 .. 00			db "UPPER",0              
bc69				endm 
# End of macro CWHEAD
bc69			; | UPPER ( s -- s ) Upper case string s  | DONE 
bc69					if DEBUG_FORTH_WORDS_KEY 
bc69						DMARK "UPR" 
bc69 f5				push af  
bc6a 3a 7e bc			ld a, (.dmark)  
bc6d 32 b7 ee			ld (debug_mark),a  
bc70 3a 7f bc			ld a, (.dmark+1)  
bc73 32 b8 ee			ld (debug_mark+1),a  
bc76 3a 80 bc			ld a, (.dmark+2)  
bc79 32 b9 ee			ld (debug_mark+2),a  
bc7c 18 03			jr .pastdmark  
bc7e ..			.dmark: db "UPR"  
bc81 f1			.pastdmark: pop af  
bc82			endm  
# End of macro DMARK
bc82						CALLMONITOR 
bc82 cd a3 92			call break_point_state  
bc85				endm  
# End of macro CALLMONITOR
bc85					endif 
bc85			 
bc85					FORTH_DSP 
bc85 cd ba 9a			call macro_forth_dsp 
bc88				endm 
# End of macro FORTH_DSP
bc88					 
bc88			; TODO check is string type 
bc88			 
bc88					FORTH_DSP_VALUEHL 
bc88 cd f4 9a			call macro_dsp_valuehl 
bc8b				endm 
# End of macro FORTH_DSP_VALUEHL
bc8b			; get pointer to string in hl 
bc8b			 
bc8b 7e			.toup:		ld a, (hl) 
bc8c fe 00				cp 0 
bc8e 28 07				jr z, .toupdone 
bc90			 
bc90 cd 0f 8e				call to_upper 
bc93			 
bc93 77					ld (hl), a 
bc94 23					inc hl 
bc95 18 f4				jr .toup 
bc97			 
bc97					 
bc97			 
bc97			 
bc97			; for each char convert to upper 
bc97					 
bc97			.toupdone: 
bc97			 
bc97			 
bc97					NEXTW 
bc97 c3 66 9c			jp macro_next 
bc9a				endm 
# End of macro NEXTW
bc9a			.LOWER: 
bc9a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bc9a 48				db WORD_SYS_CORE+52             
bc9b d5 bc			dw .TCASE            
bc9d 06				db 5 + 1 
bc9e .. 00			db "LOWER",0              
bca4				endm 
# End of macro CWHEAD
bca4			; | LOWER ( s -- s ) Lower case string s  | DONE 
bca4					if DEBUG_FORTH_WORDS_KEY 
bca4						DMARK "LWR" 
bca4 f5				push af  
bca5 3a b9 bc			ld a, (.dmark)  
bca8 32 b7 ee			ld (debug_mark),a  
bcab 3a ba bc			ld a, (.dmark+1)  
bcae 32 b8 ee			ld (debug_mark+1),a  
bcb1 3a bb bc			ld a, (.dmark+2)  
bcb4 32 b9 ee			ld (debug_mark+2),a  
bcb7 18 03			jr .pastdmark  
bcb9 ..			.dmark: db "LWR"  
bcbc f1			.pastdmark: pop af  
bcbd			endm  
# End of macro DMARK
bcbd						CALLMONITOR 
bcbd cd a3 92			call break_point_state  
bcc0				endm  
# End of macro CALLMONITOR
bcc0					endif 
bcc0			 
bcc0					FORTH_DSP 
bcc0 cd ba 9a			call macro_forth_dsp 
bcc3				endm 
# End of macro FORTH_DSP
bcc3					 
bcc3			; TODO check is string type 
bcc3			 
bcc3					FORTH_DSP_VALUEHL 
bcc3 cd f4 9a			call macro_dsp_valuehl 
bcc6				endm 
# End of macro FORTH_DSP_VALUEHL
bcc6			; get pointer to string in hl 
bcc6			 
bcc6 7e			.tolow:		ld a, (hl) 
bcc7 fe 00				cp 0 
bcc9 28 07				jr z, .tolowdone 
bccb			 
bccb cd 18 8e				call to_lower 
bcce			 
bcce 77					ld (hl), a 
bccf 23					inc hl 
bcd0 18 f4				jr .tolow 
bcd2			 
bcd2					 
bcd2			 
bcd2			 
bcd2			; for each char convert to low 
bcd2					 
bcd2			.tolowdone: 
bcd2					NEXTW 
bcd2 c3 66 9c			jp macro_next 
bcd5				endm 
# End of macro NEXTW
bcd5			.TCASE: 
bcd5				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bcd5 48				db WORD_SYS_CORE+52             
bcd6 0b be			dw .SUBSTR            
bcd8 06				db 5 + 1 
bcd9 .. 00			db "TCASE",0              
bcdf				endm 
# End of macro CWHEAD
bcdf			; | TCASE ( s -- s ) Title case string s  | DONE 
bcdf					if DEBUG_FORTH_WORDS_KEY 
bcdf						DMARK "TCS" 
bcdf f5				push af  
bce0 3a f4 bc			ld a, (.dmark)  
bce3 32 b7 ee			ld (debug_mark),a  
bce6 3a f5 bc			ld a, (.dmark+1)  
bce9 32 b8 ee			ld (debug_mark+1),a  
bcec 3a f6 bc			ld a, (.dmark+2)  
bcef 32 b9 ee			ld (debug_mark+2),a  
bcf2 18 03			jr .pastdmark  
bcf4 ..			.dmark: db "TCS"  
bcf7 f1			.pastdmark: pop af  
bcf8			endm  
# End of macro DMARK
bcf8						CALLMONITOR 
bcf8 cd a3 92			call break_point_state  
bcfb				endm  
# End of macro CALLMONITOR
bcfb					endif 
bcfb			 
bcfb					FORTH_DSP 
bcfb cd ba 9a			call macro_forth_dsp 
bcfe				endm 
# End of macro FORTH_DSP
bcfe					 
bcfe			; TODO check is string type 
bcfe			 
bcfe					FORTH_DSP_VALUEHL 
bcfe cd f4 9a			call macro_dsp_valuehl 
bd01				endm 
# End of macro FORTH_DSP_VALUEHL
bd01			; get pointer to string in hl 
bd01			 
bd01					if DEBUG_FORTH_WORDS 
bd01						DMARK "TC1" 
bd01 f5				push af  
bd02 3a 16 bd			ld a, (.dmark)  
bd05 32 b7 ee			ld (debug_mark),a  
bd08 3a 17 bd			ld a, (.dmark+1)  
bd0b 32 b8 ee			ld (debug_mark+1),a  
bd0e 3a 18 bd			ld a, (.dmark+2)  
bd11 32 b9 ee			ld (debug_mark+2),a  
bd14 18 03			jr .pastdmark  
bd16 ..			.dmark: db "TC1"  
bd19 f1			.pastdmark: pop af  
bd1a			endm  
# End of macro DMARK
bd1a						CALLMONITOR 
bd1a cd a3 92			call break_point_state  
bd1d				endm  
# End of macro CALLMONITOR
bd1d					endif 
bd1d			 
bd1d					; first time in turn to upper case first char 
bd1d			 
bd1d 7e					ld a, (hl) 
bd1e c3 a8 bd				jp .totsiptou 
bd21			 
bd21			 
bd21 7e			.tot:		ld a, (hl) 
bd22 fe 00				cp 0 
bd24 ca ec bd				jp z, .totdone 
bd27			 
bd27					if DEBUG_FORTH_WORDS 
bd27						DMARK "TC2" 
bd27 f5				push af  
bd28 3a 3c bd			ld a, (.dmark)  
bd2b 32 b7 ee			ld (debug_mark),a  
bd2e 3a 3d bd			ld a, (.dmark+1)  
bd31 32 b8 ee			ld (debug_mark+1),a  
bd34 3a 3e bd			ld a, (.dmark+2)  
bd37 32 b9 ee			ld (debug_mark+2),a  
bd3a 18 03			jr .pastdmark  
bd3c ..			.dmark: db "TC2"  
bd3f f1			.pastdmark: pop af  
bd40			endm  
# End of macro DMARK
bd40						CALLMONITOR 
bd40 cd a3 92			call break_point_state  
bd43				endm  
# End of macro CALLMONITOR
bd43					endif 
bd43					; check to see if current char is a space 
bd43			 
bd43 fe 20				cp ' ' 
bd45 28 21				jr z, .totsp 
bd47 cd 18 8e				call to_lower 
bd4a					if DEBUG_FORTH_WORDS 
bd4a						DMARK "TC3" 
bd4a f5				push af  
bd4b 3a 5f bd			ld a, (.dmark)  
bd4e 32 b7 ee			ld (debug_mark),a  
bd51 3a 60 bd			ld a, (.dmark+1)  
bd54 32 b8 ee			ld (debug_mark+1),a  
bd57 3a 61 bd			ld a, (.dmark+2)  
bd5a 32 b9 ee			ld (debug_mark+2),a  
bd5d 18 03			jr .pastdmark  
bd5f ..			.dmark: db "TC3"  
bd62 f1			.pastdmark: pop af  
bd63			endm  
# End of macro DMARK
bd63						CALLMONITOR 
bd63 cd a3 92			call break_point_state  
bd66				endm  
# End of macro CALLMONITOR
bd66					endif 
bd66 18 63				jr .totnxt 
bd68			 
bd68			.totsp:         ; on a space, find next char which should be upper 
bd68			 
bd68					if DEBUG_FORTH_WORDS 
bd68						DMARK "TC4" 
bd68 f5				push af  
bd69 3a 7d bd			ld a, (.dmark)  
bd6c 32 b7 ee			ld (debug_mark),a  
bd6f 3a 7e bd			ld a, (.dmark+1)  
bd72 32 b8 ee			ld (debug_mark+1),a  
bd75 3a 7f bd			ld a, (.dmark+2)  
bd78 32 b9 ee			ld (debug_mark+2),a  
bd7b 18 03			jr .pastdmark  
bd7d ..			.dmark: db "TC4"  
bd80 f1			.pastdmark: pop af  
bd81			endm  
# End of macro DMARK
bd81						CALLMONITOR 
bd81 cd a3 92			call break_point_state  
bd84				endm  
# End of macro CALLMONITOR
bd84					endif 
bd84					;; 
bd84			 
bd84 fe 20				cp ' ' 
bd86 20 20				jr nz, .totsiptou 
bd88 23					inc hl 
bd89 7e					ld a, (hl) 
bd8a					if DEBUG_FORTH_WORDS 
bd8a						DMARK "TC5" 
bd8a f5				push af  
bd8b 3a 9f bd			ld a, (.dmark)  
bd8e 32 b7 ee			ld (debug_mark),a  
bd91 3a a0 bd			ld a, (.dmark+1)  
bd94 32 b8 ee			ld (debug_mark+1),a  
bd97 3a a1 bd			ld a, (.dmark+2)  
bd9a 32 b9 ee			ld (debug_mark+2),a  
bd9d 18 03			jr .pastdmark  
bd9f ..			.dmark: db "TC5"  
bda2 f1			.pastdmark: pop af  
bda3			endm  
# End of macro DMARK
bda3						CALLMONITOR 
bda3 cd a3 92			call break_point_state  
bda6				endm  
# End of macro CALLMONITOR
bda6					endif 
bda6 18 c0				jr .totsp 
bda8 fe 00		.totsiptou:    cp 0 
bdaa 28 40				jr z, .totdone 
bdac					; not space and not zero term so upper case it 
bdac cd 0f 8e				call to_upper 
bdaf			 
bdaf					if DEBUG_FORTH_WORDS 
bdaf						DMARK "TC6" 
bdaf f5				push af  
bdb0 3a c4 bd			ld a, (.dmark)  
bdb3 32 b7 ee			ld (debug_mark),a  
bdb6 3a c5 bd			ld a, (.dmark+1)  
bdb9 32 b8 ee			ld (debug_mark+1),a  
bdbc 3a c6 bd			ld a, (.dmark+2)  
bdbf 32 b9 ee			ld (debug_mark+2),a  
bdc2 18 03			jr .pastdmark  
bdc4 ..			.dmark: db "TC6"  
bdc7 f1			.pastdmark: pop af  
bdc8			endm  
# End of macro DMARK
bdc8						CALLMONITOR 
bdc8 cd a3 92			call break_point_state  
bdcb				endm  
# End of macro CALLMONITOR
bdcb					endif 
bdcb			 
bdcb			 
bdcb			.totnxt: 
bdcb			 
bdcb 77					ld (hl), a 
bdcc 23					inc hl 
bdcd					if DEBUG_FORTH_WORDS 
bdcd						DMARK "TC7" 
bdcd f5				push af  
bdce 3a e2 bd			ld a, (.dmark)  
bdd1 32 b7 ee			ld (debug_mark),a  
bdd4 3a e3 bd			ld a, (.dmark+1)  
bdd7 32 b8 ee			ld (debug_mark+1),a  
bdda 3a e4 bd			ld a, (.dmark+2)  
bddd 32 b9 ee			ld (debug_mark+2),a  
bde0 18 03			jr .pastdmark  
bde2 ..			.dmark: db "TC7"  
bde5 f1			.pastdmark: pop af  
bde6			endm  
# End of macro DMARK
bde6						CALLMONITOR 
bde6 cd a3 92			call break_point_state  
bde9				endm  
# End of macro CALLMONITOR
bde9					endif 
bde9 c3 21 bd				jp .tot 
bdec			 
bdec					 
bdec			 
bdec			 
bdec			; for each char convert to low 
bdec					 
bdec			.totdone: 
bdec					if DEBUG_FORTH_WORDS 
bdec						DMARK "TCd" 
bdec f5				push af  
bded 3a 01 be			ld a, (.dmark)  
bdf0 32 b7 ee			ld (debug_mark),a  
bdf3 3a 02 be			ld a, (.dmark+1)  
bdf6 32 b8 ee			ld (debug_mark+1),a  
bdf9 3a 03 be			ld a, (.dmark+2)  
bdfc 32 b9 ee			ld (debug_mark+2),a  
bdff 18 03			jr .pastdmark  
be01 ..			.dmark: db "TCd"  
be04 f1			.pastdmark: pop af  
be05			endm  
# End of macro DMARK
be05						CALLMONITOR 
be05 cd a3 92			call break_point_state  
be08				endm  
# End of macro CALLMONITOR
be08					endif 
be08					NEXTW 
be08 c3 66 9c			jp macro_next 
be0b				endm 
# End of macro NEXTW
be0b			 
be0b			.SUBSTR: 
be0b				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
be0b 48				db WORD_SYS_CORE+52             
be0c 69 be			dw .LEFT            
be0e 07				db 6 + 1 
be0f .. 00			db "SUBSTR",0              
be16				endm 
# End of macro CWHEAD
be16			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
be16			 
be16					if DEBUG_FORTH_WORDS_KEY 
be16						DMARK "SST" 
be16 f5				push af  
be17 3a 2b be			ld a, (.dmark)  
be1a 32 b7 ee			ld (debug_mark),a  
be1d 3a 2c be			ld a, (.dmark+1)  
be20 32 b8 ee			ld (debug_mark+1),a  
be23 3a 2d be			ld a, (.dmark+2)  
be26 32 b9 ee			ld (debug_mark+2),a  
be29 18 03			jr .pastdmark  
be2b ..			.dmark: db "SST"  
be2e f1			.pastdmark: pop af  
be2f			endm  
# End of macro DMARK
be2f						CALLMONITOR 
be2f cd a3 92			call break_point_state  
be32				endm  
# End of macro CALLMONITOR
be32					endif 
be32			; TODO check string type 
be32					FORTH_DSP_VALUEHL 
be32 cd f4 9a			call macro_dsp_valuehl 
be35				endm 
# End of macro FORTH_DSP_VALUEHL
be35			 
be35 e5					push hl      ; string length 
be36			 
be36					FORTH_DSP_POP 
be36 cd ac 9b			call macro_forth_dsp_pop 
be39				endm 
# End of macro FORTH_DSP_POP
be39			 
be39					FORTH_DSP_VALUEHL 
be39 cd f4 9a			call macro_dsp_valuehl 
be3c				endm 
# End of macro FORTH_DSP_VALUEHL
be3c			 
be3c e5					push hl     ; start char 
be3d			 
be3d					FORTH_DSP_POP 
be3d cd ac 9b			call macro_forth_dsp_pop 
be40				endm 
# End of macro FORTH_DSP_POP
be40			 
be40			 
be40					FORTH_DSP_VALUE 
be40 cd dd 9a			call macro_forth_dsp_value 
be43				endm 
# End of macro FORTH_DSP_VALUE
be43			 
be43 d1					pop de    ; get start post offset 
be44			 
be44 19					add hl, de    ; starting offset 
be45			 
be45 c1					pop bc 
be46 c5					push bc      ; grab size of string 
be47			 
be47 e5					push hl    ; save string start  
be48			 
be48 26 00				ld h, 0 
be4a 69					ld l, c 
be4b 23					inc hl 
be4c 23					inc hl 
be4d			 
be4d cd 69 8f				call malloc 
be50				if DEBUG_FORTH_MALLOC_GUARD 
be50 cc 98 c4				call z,malloc_error 
be53				endif 
be53			 
be53 eb					ex de, hl      ; save malloc area for string copy 
be54 e1					pop hl    ; get back source 
be55 c1					pop bc    ; get length of string back 
be56			 
be56 d5					push de    ; save malloc area for after we push 
be57 ed b0				ldir     ; copy substr 
be59			 
be59			 
be59 eb					ex de, hl 
be5a 3e 00				ld a, 0 
be5c 77					ld (hl), a   ; term substr 
be5d			 
be5d					 
be5d e1					pop hl    ; get malloc so we can push it 
be5e e5					push hl   ; save so we can free it afterwards 
be5f			 
be5f cd 6b 99				call forth_push_str 
be62			 
be62 e1					pop hl 
be63 cd 33 90				call free 
be66			 
be66					 
be66					 
be66			 
be66			 
be66					NEXTW 
be66 c3 66 9c			jp macro_next 
be69				endm 
# End of macro NEXTW
be69			 
be69			.LEFT: 
be69				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
be69 48				db WORD_SYS_CORE+52             
be6a 91 be			dw .RIGHT            
be6c 05				db 4 + 1 
be6d .. 00			db "LEFT",0              
be72				endm 
# End of macro CWHEAD
be72			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
be72					if DEBUG_FORTH_WORDS_KEY 
be72						DMARK "LEF" 
be72 f5				push af  
be73 3a 87 be			ld a, (.dmark)  
be76 32 b7 ee			ld (debug_mark),a  
be79 3a 88 be			ld a, (.dmark+1)  
be7c 32 b8 ee			ld (debug_mark+1),a  
be7f 3a 89 be			ld a, (.dmark+2)  
be82 32 b9 ee			ld (debug_mark+2),a  
be85 18 03			jr .pastdmark  
be87 ..			.dmark: db "LEF"  
be8a f1			.pastdmark: pop af  
be8b			endm  
# End of macro DMARK
be8b						CALLMONITOR 
be8b cd a3 92			call break_point_state  
be8e				endm  
# End of macro CALLMONITOR
be8e					endif 
be8e			 
be8e					NEXTW 
be8e c3 66 9c			jp macro_next 
be91				endm 
# End of macro NEXTW
be91			.RIGHT: 
be91				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
be91 48				db WORD_SYS_CORE+52             
be92 ba be			dw .STR2NUM            
be94 06				db 5 + 1 
be95 .. 00			db "RIGHT",0              
be9b				endm 
# End of macro CWHEAD
be9b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
be9b					if DEBUG_FORTH_WORDS_KEY 
be9b						DMARK "RIG" 
be9b f5				push af  
be9c 3a b0 be			ld a, (.dmark)  
be9f 32 b7 ee			ld (debug_mark),a  
bea2 3a b1 be			ld a, (.dmark+1)  
bea5 32 b8 ee			ld (debug_mark+1),a  
bea8 3a b2 be			ld a, (.dmark+2)  
beab 32 b9 ee			ld (debug_mark+2),a  
beae 18 03			jr .pastdmark  
beb0 ..			.dmark: db "RIG"  
beb3 f1			.pastdmark: pop af  
beb4			endm  
# End of macro DMARK
beb4						CALLMONITOR 
beb4 cd a3 92			call break_point_state  
beb7				endm  
# End of macro CALLMONITOR
beb7					endif 
beb7			 
beb7					NEXTW 
beb7 c3 66 9c			jp macro_next 
beba				endm 
# End of macro NEXTW
beba			 
beba			 
beba			.STR2NUM: 
beba				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
beba 48				db WORD_SYS_CORE+52             
bebb 46 bf			dw .NUM2STR            
bebd 08				db 7 + 1 
bebe .. 00			db "STR2NUM",0              
bec6				endm 
# End of macro CWHEAD
bec6			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bec6			 
bec6			 
bec6			; TODO STR type check to do 
bec6					if DEBUG_FORTH_WORDS_KEY 
bec6						DMARK "S2N" 
bec6 f5				push af  
bec7 3a db be			ld a, (.dmark)  
beca 32 b7 ee			ld (debug_mark),a  
becd 3a dc be			ld a, (.dmark+1)  
bed0 32 b8 ee			ld (debug_mark+1),a  
bed3 3a dd be			ld a, (.dmark+2)  
bed6 32 b9 ee			ld (debug_mark+2),a  
bed9 18 03			jr .pastdmark  
bedb ..			.dmark: db "S2N"  
bede f1			.pastdmark: pop af  
bedf			endm  
# End of macro DMARK
bedf						CALLMONITOR 
bedf cd a3 92			call break_point_state  
bee2				endm  
# End of macro CALLMONITOR
bee2					endif 
bee2			 
bee2					;FORTH_DSP 
bee2					FORTH_DSP_VALUE 
bee2 cd dd 9a			call macro_forth_dsp_value 
bee5				endm 
# End of macro FORTH_DSP_VALUE
bee5					;inc hl 
bee5			 
bee5 eb					ex de, hl 
bee6					if DEBUG_FORTH_WORDS 
bee6						DMARK "S2a" 
bee6 f5				push af  
bee7 3a fb be			ld a, (.dmark)  
beea 32 b7 ee			ld (debug_mark),a  
beed 3a fc be			ld a, (.dmark+1)  
bef0 32 b8 ee			ld (debug_mark+1),a  
bef3 3a fd be			ld a, (.dmark+2)  
bef6 32 b9 ee			ld (debug_mark+2),a  
bef9 18 03			jr .pastdmark  
befb ..			.dmark: db "S2a"  
befe f1			.pastdmark: pop af  
beff			endm  
# End of macro DMARK
beff						CALLMONITOR 
beff cd a3 92			call break_point_state  
bf02				endm  
# End of macro CALLMONITOR
bf02					endif 
bf02 cd 97 8e				call string_to_uint16 
bf05			 
bf05					if DEBUG_FORTH_WORDS 
bf05						DMARK "S2b" 
bf05 f5				push af  
bf06 3a 1a bf			ld a, (.dmark)  
bf09 32 b7 ee			ld (debug_mark),a  
bf0c 3a 1b bf			ld a, (.dmark+1)  
bf0f 32 b8 ee			ld (debug_mark+1),a  
bf12 3a 1c bf			ld a, (.dmark+2)  
bf15 32 b9 ee			ld (debug_mark+2),a  
bf18 18 03			jr .pastdmark  
bf1a ..			.dmark: db "S2b"  
bf1d f1			.pastdmark: pop af  
bf1e			endm  
# End of macro DMARK
bf1e						CALLMONITOR 
bf1e cd a3 92			call break_point_state  
bf21				endm  
# End of macro CALLMONITOR
bf21					endif 
bf21			;		push hl 
bf21					FORTH_DSP_POP 
bf21 cd ac 9b			call macro_forth_dsp_pop 
bf24				endm 
# End of macro FORTH_DSP_POP
bf24			;		pop hl 
bf24					 
bf24					if DEBUG_FORTH_WORDS 
bf24						DMARK "S2b" 
bf24 f5				push af  
bf25 3a 39 bf			ld a, (.dmark)  
bf28 32 b7 ee			ld (debug_mark),a  
bf2b 3a 3a bf			ld a, (.dmark+1)  
bf2e 32 b8 ee			ld (debug_mark+1),a  
bf31 3a 3b bf			ld a, (.dmark+2)  
bf34 32 b9 ee			ld (debug_mark+2),a  
bf37 18 03			jr .pastdmark  
bf39 ..			.dmark: db "S2b"  
bf3c f1			.pastdmark: pop af  
bf3d			endm  
# End of macro DMARK
bf3d						CALLMONITOR 
bf3d cd a3 92			call break_point_state  
bf40				endm  
# End of macro CALLMONITOR
bf40					endif 
bf40 cd fd 98				call forth_push_numhl	 
bf43			 
bf43				 
bf43				       NEXTW 
bf43 c3 66 9c			jp macro_next 
bf46				endm 
# End of macro NEXTW
bf46			.NUM2STR: 
bf46				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bf46 48				db WORD_SYS_CORE+52             
bf47 55 bf			dw .CONCAT            
bf49 08				db 7 + 1 
bf4a .. 00			db "NUM2STR",0              
bf52				endm 
# End of macro CWHEAD
bf52			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bf52			 
bf52			;		; malloc a string to target 
bf52			;		ld hl, 10     ; TODO max string size should be fine 
bf52			;		call malloc 
bf52			;		push hl    ; save malloc location 
bf52			; 
bf52			; 
bf52			;; TODO check int type 
bf52			;		FORTH_DSP_VALUEHL 
bf52			;		ld a, l 
bf52			;		call DispAToASCII   
bf52			;;TODO need to chage above call to dump into string 
bf52			; 
bf52			; 
bf52			 
bf52				       NEXTW 
bf52 c3 66 9c			jp macro_next 
bf55				endm 
# End of macro NEXTW
bf55			 
bf55			.CONCAT: 
bf55				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bf55 48				db WORD_SYS_CORE+52             
bf56 08 c0			dw .FIND            
bf58 07				db 6 + 1 
bf59 .. 00			db "CONCAT",0              
bf60				endm 
# End of macro CWHEAD
bf60			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bf60			 
bf60			; TODO check string type 
bf60			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bf60			 
bf60					if DEBUG_FORTH_WORDS_KEY 
bf60						DMARK "CON" 
bf60 f5				push af  
bf61 3a 75 bf			ld a, (.dmark)  
bf64 32 b7 ee			ld (debug_mark),a  
bf67 3a 76 bf			ld a, (.dmark+1)  
bf6a 32 b8 ee			ld (debug_mark+1),a  
bf6d 3a 77 bf			ld a, (.dmark+2)  
bf70 32 b9 ee			ld (debug_mark+2),a  
bf73 18 03			jr .pastdmark  
bf75 ..			.dmark: db "CON"  
bf78 f1			.pastdmark: pop af  
bf79			endm  
# End of macro DMARK
bf79						CALLMONITOR 
bf79 cd a3 92			call break_point_state  
bf7c				endm  
# End of macro CALLMONITOR
bf7c					endif 
bf7c			 
bf7c			 
bf7c					FORTH_DSP_VALUE 
bf7c cd dd 9a			call macro_forth_dsp_value 
bf7f				endm 
# End of macro FORTH_DSP_VALUE
bf7f e5					push hl   ; s2 
bf80			 
bf80					FORTH_DSP_POP 
bf80 cd ac 9b			call macro_forth_dsp_pop 
bf83				endm 
# End of macro FORTH_DSP_POP
bf83			 
bf83					FORTH_DSP_VALUE 
bf83 cd dd 9a			call macro_forth_dsp_value 
bf86				endm 
# End of macro FORTH_DSP_VALUE
bf86			 
bf86 e5					push hl   ; s1 
bf87			 
bf87					FORTH_DSP_POP 
bf87 cd ac 9b			call macro_forth_dsp_pop 
bf8a				endm 
# End of macro FORTH_DSP_POP
bf8a					 
bf8a			 
bf8a					; copy s1 
bf8a			 
bf8a				 
bf8a					; save ptr 
bf8a e1					pop hl  
bf8b e5					push hl 
bf8c 3e 00				ld a, 0 
bf8e cd 0b 8f				call strlent 
bf91					;inc hl    ; zer0 
bf91 06 00				ld b, 0 
bf93 4d					ld c, l 
bf94 e1					pop hl		 
bf95 11 dd e4				ld de, scratch	 
bf98					if DEBUG_FORTH_WORDS 
bf98						DMARK "CO1" 
bf98 f5				push af  
bf99 3a ad bf			ld a, (.dmark)  
bf9c 32 b7 ee			ld (debug_mark),a  
bf9f 3a ae bf			ld a, (.dmark+1)  
bfa2 32 b8 ee			ld (debug_mark+1),a  
bfa5 3a af bf			ld a, (.dmark+2)  
bfa8 32 b9 ee			ld (debug_mark+2),a  
bfab 18 03			jr .pastdmark  
bfad ..			.dmark: db "CO1"  
bfb0 f1			.pastdmark: pop af  
bfb1			endm  
# End of macro DMARK
bfb1						CALLMONITOR 
bfb1 cd a3 92			call break_point_state  
bfb4				endm  
# End of macro CALLMONITOR
bfb4					endif 
bfb4 ed b0				ldir 
bfb6			 
bfb6 e1					pop hl 
bfb7 e5					push hl 
bfb8 d5					push de 
bfb9			 
bfb9			 
bfb9 3e 00				ld a, 0 
bfbb cd 0b 8f				call strlent 
bfbe 23					inc hl    ; zer0 
bfbf 23					inc hl 
bfc0 06 00				ld b, 0 
bfc2 4d					ld c, l 
bfc3 d1					pop de 
bfc4 e1					pop hl		 
bfc5					if DEBUG_FORTH_WORDS 
bfc5						DMARK "CO2" 
bfc5 f5				push af  
bfc6 3a da bf			ld a, (.dmark)  
bfc9 32 b7 ee			ld (debug_mark),a  
bfcc 3a db bf			ld a, (.dmark+1)  
bfcf 32 b8 ee			ld (debug_mark+1),a  
bfd2 3a dc bf			ld a, (.dmark+2)  
bfd5 32 b9 ee			ld (debug_mark+2),a  
bfd8 18 03			jr .pastdmark  
bfda ..			.dmark: db "CO2"  
bfdd f1			.pastdmark: pop af  
bfde			endm  
# End of macro DMARK
bfde						CALLMONITOR 
bfde cd a3 92			call break_point_state  
bfe1				endm  
# End of macro CALLMONITOR
bfe1					endif 
bfe1 ed b0				ldir 
bfe3			 
bfe3			 
bfe3			 
bfe3 21 dd e4				ld hl, scratch 
bfe6					if DEBUG_FORTH_WORDS 
bfe6						DMARK "CO5" 
bfe6 f5				push af  
bfe7 3a fb bf			ld a, (.dmark)  
bfea 32 b7 ee			ld (debug_mark),a  
bfed 3a fc bf			ld a, (.dmark+1)  
bff0 32 b8 ee			ld (debug_mark+1),a  
bff3 3a fd bf			ld a, (.dmark+2)  
bff6 32 b9 ee			ld (debug_mark+2),a  
bff9 18 03			jr .pastdmark  
bffb ..			.dmark: db "CO5"  
bffe f1			.pastdmark: pop af  
bfff			endm  
# End of macro DMARK
bfff						CALLMONITOR 
bfff cd a3 92			call break_point_state  
c002				endm  
# End of macro CALLMONITOR
c002					endif 
c002			 
c002 cd 6b 99				call forth_push_str 
c005			 
c005			 
c005			 
c005			 
c005				       NEXTW 
c005 c3 66 9c			jp macro_next 
c008				endm 
# End of macro NEXTW
c008			 
c008			 
c008			.FIND: 
c008				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c008 4b				db WORD_SYS_CORE+55             
c009 c6 c0			dw .LEN            
c00b 05				db 4 + 1 
c00c .. 00			db "FIND",0              
c011				endm 
# End of macro CWHEAD
c011			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c011			 
c011					if DEBUG_FORTH_WORDS_KEY 
c011						DMARK "FND" 
c011 f5				push af  
c012 3a 26 c0			ld a, (.dmark)  
c015 32 b7 ee			ld (debug_mark),a  
c018 3a 27 c0			ld a, (.dmark+1)  
c01b 32 b8 ee			ld (debug_mark+1),a  
c01e 3a 28 c0			ld a, (.dmark+2)  
c021 32 b9 ee			ld (debug_mark+2),a  
c024 18 03			jr .pastdmark  
c026 ..			.dmark: db "FND"  
c029 f1			.pastdmark: pop af  
c02a			endm  
# End of macro DMARK
c02a						CALLMONITOR 
c02a cd a3 92			call break_point_state  
c02d				endm  
# End of macro CALLMONITOR
c02d					endif 
c02d			 
c02d			; TODO check string type 
c02d					FORTH_DSP_VALUE 
c02d cd dd 9a			call macro_forth_dsp_value 
c030				endm 
# End of macro FORTH_DSP_VALUE
c030			 
c030 e5					push hl    
c031 7e					ld a,(hl)    ; char to find   
c032			; TODO change char to substr 
c032			 
c032 f5					push af 
c033					 
c033			 
c033			 
c033					if DEBUG_FORTH_WORDS 
c033						DMARK "FN1" 
c033 f5				push af  
c034 3a 48 c0			ld a, (.dmark)  
c037 32 b7 ee			ld (debug_mark),a  
c03a 3a 49 c0			ld a, (.dmark+1)  
c03d 32 b8 ee			ld (debug_mark+1),a  
c040 3a 4a c0			ld a, (.dmark+2)  
c043 32 b9 ee			ld (debug_mark+2),a  
c046 18 03			jr .pastdmark  
c048 ..			.dmark: db "FN1"  
c04b f1			.pastdmark: pop af  
c04c			endm  
# End of macro DMARK
c04c						CALLMONITOR 
c04c cd a3 92			call break_point_state  
c04f				endm  
# End of macro CALLMONITOR
c04f					endif 
c04f			 
c04f					FORTH_DSP_POP 
c04f cd ac 9b			call macro_forth_dsp_pop 
c052				endm 
# End of macro FORTH_DSP_POP
c052			 
c052					; string to search 
c052			 
c052					FORTH_DSP_VALUE 
c052 cd dd 9a			call macro_forth_dsp_value 
c055				endm 
# End of macro FORTH_DSP_VALUE
c055			 
c055 d1					pop de  ; d is char to find  
c056			 
c056					if DEBUG_FORTH_WORDS 
c056						DMARK "FN2" 
c056 f5				push af  
c057 3a 6b c0			ld a, (.dmark)  
c05a 32 b7 ee			ld (debug_mark),a  
c05d 3a 6c c0			ld a, (.dmark+1)  
c060 32 b8 ee			ld (debug_mark+1),a  
c063 3a 6d c0			ld a, (.dmark+2)  
c066 32 b9 ee			ld (debug_mark+2),a  
c069 18 03			jr .pastdmark  
c06b ..			.dmark: db "FN2"  
c06e f1			.pastdmark: pop af  
c06f			endm  
# End of macro DMARK
c06f						CALLMONITOR 
c06f cd a3 92			call break_point_state  
c072				endm  
# End of macro CALLMONITOR
c072					endif 
c072					 
c072 01 00 00				ld bc, 0 
c075 7e			.findchar:      ld a,(hl) 
c076 fe 00				cp 0   		 
c078 28 27				jr z, .finddone     
c07a ba					cp d 
c07b 28 20				jr z, .foundchar 
c07d 03					inc bc 
c07e 23					inc hl 
c07f					if DEBUG_FORTH_WORDS 
c07f						DMARK "FN3" 
c07f f5				push af  
c080 3a 94 c0			ld a, (.dmark)  
c083 32 b7 ee			ld (debug_mark),a  
c086 3a 95 c0			ld a, (.dmark+1)  
c089 32 b8 ee			ld (debug_mark+1),a  
c08c 3a 96 c0			ld a, (.dmark+2)  
c08f 32 b9 ee			ld (debug_mark+2),a  
c092 18 03			jr .pastdmark  
c094 ..			.dmark: db "FN3"  
c097 f1			.pastdmark: pop af  
c098			endm  
# End of macro DMARK
c098						CALLMONITOR 
c098 cd a3 92			call break_point_state  
c09b				endm  
# End of macro CALLMONITOR
c09b					endif 
c09b 18 d8				jr .findchar 
c09d			 
c09d			 
c09d c5			.foundchar:	push bc 
c09e e1					pop hl 
c09f 18 03				jr .findexit 
c0a1			 
c0a1			 
c0a1							 
c0a1			 
c0a1			.finddone:     ; got to end of string with no find 
c0a1 21 00 00				ld hl, 0 
c0a4			.findexit: 
c0a4			 
c0a4					if DEBUG_FORTH_WORDS 
c0a4						DMARK "FNd" 
c0a4 f5				push af  
c0a5 3a b9 c0			ld a, (.dmark)  
c0a8 32 b7 ee			ld (debug_mark),a  
c0ab 3a ba c0			ld a, (.dmark+1)  
c0ae 32 b8 ee			ld (debug_mark+1),a  
c0b1 3a bb c0			ld a, (.dmark+2)  
c0b4 32 b9 ee			ld (debug_mark+2),a  
c0b7 18 03			jr .pastdmark  
c0b9 ..			.dmark: db "FNd"  
c0bc f1			.pastdmark: pop af  
c0bd			endm  
# End of macro DMARK
c0bd						CALLMONITOR 
c0bd cd a3 92			call break_point_state  
c0c0				endm  
# End of macro CALLMONITOR
c0c0					endif 
c0c0 cd fd 98			call forth_push_numhl 
c0c3			 
c0c3				       NEXTW 
c0c3 c3 66 9c			jp macro_next 
c0c6				endm 
# End of macro NEXTW
c0c6			 
c0c6			.LEN: 
c0c6				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c0c6 4c				db WORD_SYS_CORE+56             
c0c7 fb c0			dw .CHAR            
c0c9 06				db 5 + 1 
c0ca .. 00			db "COUNT",0              
c0d0				endm 
# End of macro CWHEAD
c0d0			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c0d0			 
c0d0					if DEBUG_FORTH_WORDS_KEY 
c0d0						DMARK "CNT" 
c0d0 f5				push af  
c0d1 3a e5 c0			ld a, (.dmark)  
c0d4 32 b7 ee			ld (debug_mark),a  
c0d7 3a e6 c0			ld a, (.dmark+1)  
c0da 32 b8 ee			ld (debug_mark+1),a  
c0dd 3a e7 c0			ld a, (.dmark+2)  
c0e0 32 b9 ee			ld (debug_mark+2),a  
c0e3 18 03			jr .pastdmark  
c0e5 ..			.dmark: db "CNT"  
c0e8 f1			.pastdmark: pop af  
c0e9			endm  
# End of macro DMARK
c0e9						CALLMONITOR 
c0e9 cd a3 92			call break_point_state  
c0ec				endm  
# End of macro CALLMONITOR
c0ec					endif 
c0ec			; TODO check string type 
c0ec					FORTH_DSP 
c0ec cd ba 9a			call macro_forth_dsp 
c0ef				endm 
# End of macro FORTH_DSP
c0ef					;v5FORTH_DSP_VALUE 
c0ef			 
c0ef 23					inc hl 
c0f0			 
c0f0 3e 00				ld a, 0 
c0f2 cd 0b 8f				call strlent 
c0f5			 
c0f5 cd fd 98				call forth_push_numhl 
c0f8			 
c0f8			 
c0f8			 
c0f8				       NEXTW 
c0f8 c3 66 9c			jp macro_next 
c0fb				endm 
# End of macro NEXTW
c0fb			.CHAR: 
c0fb				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c0fb 4d				db WORD_SYS_CORE+57             
c0fc 31 c1			dw .ENDSTR            
c0fe 05				db 4 + 1 
c0ff .. 00			db "CHAR",0              
c104				endm 
# End of macro CWHEAD
c104			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c104					if DEBUG_FORTH_WORDS_KEY 
c104						DMARK "CHR" 
c104 f5				push af  
c105 3a 19 c1			ld a, (.dmark)  
c108 32 b7 ee			ld (debug_mark),a  
c10b 3a 1a c1			ld a, (.dmark+1)  
c10e 32 b8 ee			ld (debug_mark+1),a  
c111 3a 1b c1			ld a, (.dmark+2)  
c114 32 b9 ee			ld (debug_mark+2),a  
c117 18 03			jr .pastdmark  
c119 ..			.dmark: db "CHR"  
c11c f1			.pastdmark: pop af  
c11d			endm  
# End of macro DMARK
c11d						CALLMONITOR 
c11d cd a3 92			call break_point_state  
c120				endm  
# End of macro CALLMONITOR
c120					endif 
c120					FORTH_DSP 
c120 cd ba 9a			call macro_forth_dsp 
c123				endm 
# End of macro FORTH_DSP
c123					;v5 FORTH_DSP_VALUE 
c123 23					inc hl      ; now at start of numeric as string 
c124			 
c124			;		push hl 
c124			 
c124					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c124 cd ac 9b			call macro_forth_dsp_pop 
c127				endm 
# End of macro FORTH_DSP_POP
c127			 
c127			;		pop hl 
c127			 
c127					; push the content of a onto the stack as a value 
c127			 
c127 7e					ld a,(hl)   ; get char 
c128 26 00				ld h,0 
c12a 6f					ld l,a 
c12b cd fd 98				call forth_push_numhl 
c12e			 
c12e				       NEXTW 
c12e c3 66 9c			jp macro_next 
c131				endm 
# End of macro NEXTW
c131			 
c131			 
c131			 
c131			 
c131			.ENDSTR: 
c131			; eof 
c131			 
# End of file forth_words_str.asm
c131			include "forth_words_key.asm" 
c131			 
c131			; | ## Keyboard Words 
c131			 
c131			.KEY: 
c131				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c131 3e				db WORD_SYS_CORE+42             
c132 61 c1			dw .WAITK            
c134 04				db 3 + 1 
c135 .. 00			db "KEY",0              
c139				endm 
# End of macro CWHEAD
c139			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c139			 
c139					if DEBUG_FORTH_WORDS_KEY 
c139						DMARK "KEY" 
c139 f5				push af  
c13a 3a 4e c1			ld a, (.dmark)  
c13d 32 b7 ee			ld (debug_mark),a  
c140 3a 4f c1			ld a, (.dmark+1)  
c143 32 b8 ee			ld (debug_mark+1),a  
c146 3a 50 c1			ld a, (.dmark+2)  
c149 32 b9 ee			ld (debug_mark+2),a  
c14c 18 03			jr .pastdmark  
c14e ..			.dmark: db "KEY"  
c151 f1			.pastdmark: pop af  
c152			endm  
# End of macro DMARK
c152						CALLMONITOR 
c152 cd a3 92			call break_point_state  
c155				endm  
# End of macro CALLMONITOR
c155					endif 
c155			; TODO currently waits 
c155 cd d4 d7				call cin 
c158					;call cin_wait 
c158 6f					ld l, a 
c159 26 00				ld h, 0 
c15b cd fd 98				call forth_push_numhl 
c15e					NEXTW 
c15e c3 66 9c			jp macro_next 
c161				endm 
# End of macro NEXTW
c161			.WAITK: 
c161				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c161 3f				db WORD_SYS_CORE+43             
c162 93 c1			dw .ACCEPT            
c164 06				db 5 + 1 
c165 .. 00			db "WAITK",0              
c16b				endm 
# End of macro CWHEAD
c16b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c16b					if DEBUG_FORTH_WORDS_KEY 
c16b						DMARK "WAI" 
c16b f5				push af  
c16c 3a 80 c1			ld a, (.dmark)  
c16f 32 b7 ee			ld (debug_mark),a  
c172 3a 81 c1			ld a, (.dmark+1)  
c175 32 b8 ee			ld (debug_mark+1),a  
c178 3a 82 c1			ld a, (.dmark+2)  
c17b 32 b9 ee			ld (debug_mark+2),a  
c17e 18 03			jr .pastdmark  
c180 ..			.dmark: db "WAI"  
c183 f1			.pastdmark: pop af  
c184			endm  
# End of macro DMARK
c184						CALLMONITOR 
c184 cd a3 92			call break_point_state  
c187				endm  
# End of macro CALLMONITOR
c187					endif 
c187 cd ce d7				call cin_wait 
c18a 6f					ld l, a 
c18b 26 00				ld h, 0 
c18d cd fd 98				call forth_push_numhl 
c190					NEXTW 
c190 c3 66 9c			jp macro_next 
c193				endm 
# End of macro NEXTW
c193			.ACCEPT: 
c193				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c193 40				db WORD_SYS_CORE+44             
c194 f1 c1			dw .EDIT            
c196 07				db 6 + 1 
c197 .. 00			db "ACCEPT",0              
c19e				endm 
# End of macro CWHEAD
c19e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c19e					; TODO crashes on push 
c19e					if DEBUG_FORTH_WORDS_KEY 
c19e						DMARK "ACC" 
c19e f5				push af  
c19f 3a b3 c1			ld a, (.dmark)  
c1a2 32 b7 ee			ld (debug_mark),a  
c1a5 3a b4 c1			ld a, (.dmark+1)  
c1a8 32 b8 ee			ld (debug_mark+1),a  
c1ab 3a b5 c1			ld a, (.dmark+2)  
c1ae 32 b9 ee			ld (debug_mark+2),a  
c1b1 18 03			jr .pastdmark  
c1b3 ..			.dmark: db "ACC"  
c1b6 f1			.pastdmark: pop af  
c1b7			endm  
# End of macro DMARK
c1b7						CALLMONITOR 
c1b7 cd a3 92			call break_point_state  
c1ba				endm  
# End of macro CALLMONITOR
c1ba					endif 
c1ba 21 db e6				ld hl, os_input 
c1bd 3e 00				ld a, 0 
c1bf 77					ld (hl),a 
c1c0 3a c6 ec				ld a,(f_cursor_ptr) 
c1c3 16 64				ld d, 100 
c1c5 0e 00				ld c, 0 
c1c7 1e 28				ld e, 40 
c1c9 cd cf 8a				call input_str 
c1cc					; TODO perhaps do a type check and wrap in quotes if not a number 
c1cc 21 db e6				ld hl, os_input 
c1cf					if DEBUG_FORTH_WORDS 
c1cf						DMARK "AC1" 
c1cf f5				push af  
c1d0 3a e4 c1			ld a, (.dmark)  
c1d3 32 b7 ee			ld (debug_mark),a  
c1d6 3a e5 c1			ld a, (.dmark+1)  
c1d9 32 b8 ee			ld (debug_mark+1),a  
c1dc 3a e6 c1			ld a, (.dmark+2)  
c1df 32 b9 ee			ld (debug_mark+2),a  
c1e2 18 03			jr .pastdmark  
c1e4 ..			.dmark: db "AC1"  
c1e7 f1			.pastdmark: pop af  
c1e8			endm  
# End of macro DMARK
c1e8						CALLMONITOR 
c1e8 cd a3 92			call break_point_state  
c1eb				endm  
# End of macro CALLMONITOR
c1eb					endif 
c1eb cd 6b 99				call forth_push_str 
c1ee					NEXTW 
c1ee c3 66 9c			jp macro_next 
c1f1				endm 
# End of macro NEXTW
c1f1			 
c1f1			.EDIT: 
c1f1				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c1f1 40				db WORD_SYS_CORE+44             
c1f2 93 c2			dw .ENDKEY            
c1f4 05				db 4 + 1 
c1f5 .. 00			db "EDIT",0              
c1fa				endm 
# End of macro CWHEAD
c1fa			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c1fa			 
c1fa					; TODO does not copy from stack 
c1fa					if DEBUG_FORTH_WORDS_KEY 
c1fa						DMARK "EDT" 
c1fa f5				push af  
c1fb 3a 0f c2			ld a, (.dmark)  
c1fe 32 b7 ee			ld (debug_mark),a  
c201 3a 10 c2			ld a, (.dmark+1)  
c204 32 b8 ee			ld (debug_mark+1),a  
c207 3a 11 c2			ld a, (.dmark+2)  
c20a 32 b9 ee			ld (debug_mark+2),a  
c20d 18 03			jr .pastdmark  
c20f ..			.dmark: db "EDT"  
c212 f1			.pastdmark: pop af  
c213			endm  
# End of macro DMARK
c213						CALLMONITOR 
c213 cd a3 92			call break_point_state  
c216				endm  
# End of macro CALLMONITOR
c216					endif 
c216			 
c216					;FORTH_DSP 
c216					FORTH_DSP_VALUEHL 
c216 cd f4 9a			call macro_dsp_valuehl 
c219				endm 
# End of macro FORTH_DSP_VALUEHL
c219			;		inc hl    ; TODO do type check 
c219			 
c219			;		call get_word_hl 
c219 e5					push hl 
c21a					if DEBUG_FORTH_WORDS 
c21a						DMARK "EDp" 
c21a f5				push af  
c21b 3a 2f c2			ld a, (.dmark)  
c21e 32 b7 ee			ld (debug_mark),a  
c221 3a 30 c2			ld a, (.dmark+1)  
c224 32 b8 ee			ld (debug_mark+1),a  
c227 3a 31 c2			ld a, (.dmark+2)  
c22a 32 b9 ee			ld (debug_mark+2),a  
c22d 18 03			jr .pastdmark  
c22f ..			.dmark: db "EDp"  
c232 f1			.pastdmark: pop af  
c233			endm  
# End of macro DMARK
c233						CALLMONITOR 
c233 cd a3 92			call break_point_state  
c236				endm  
# End of macro CALLMONITOR
c236					endif 
c236				;	ld a, 0 
c236 cd 00 8f				call strlenz 
c239 23					inc hl 
c23a			 
c23a 06 00				ld b, 0 
c23c 4d					ld c, l 
c23d			 
c23d e1					pop hl 
c23e 11 db e6				ld de, os_input 
c241					if DEBUG_FORTH_WORDS_KEY 
c241						DMARK "EDc" 
c241 f5				push af  
c242 3a 56 c2			ld a, (.dmark)  
c245 32 b7 ee			ld (debug_mark),a  
c248 3a 57 c2			ld a, (.dmark+1)  
c24b 32 b8 ee			ld (debug_mark+1),a  
c24e 3a 58 c2			ld a, (.dmark+2)  
c251 32 b9 ee			ld (debug_mark+2),a  
c254 18 03			jr .pastdmark  
c256 ..			.dmark: db "EDc"  
c259 f1			.pastdmark: pop af  
c25a			endm  
# End of macro DMARK
c25a						CALLMONITOR 
c25a cd a3 92			call break_point_state  
c25d				endm  
# End of macro CALLMONITOR
c25d					endif 
c25d ed b0				ldir 
c25f			 
c25f			 
c25f 21 db e6				ld hl, os_input 
c262					;ld a, 0 
c262					;ld (hl),a 
c262 3a c6 ec				ld a,(f_cursor_ptr) 
c265 16 64				ld d, 100 
c267 0e 00				ld c, 0 
c269 1e 28				ld e, 40 
c26b cd cf 8a				call input_str 
c26e					; TODO perhaps do a type check and wrap in quotes if not a number 
c26e 21 db e6				ld hl, os_input 
c271					if DEBUG_FORTH_WORDS 
c271						DMARK "ED1" 
c271 f5				push af  
c272 3a 86 c2			ld a, (.dmark)  
c275 32 b7 ee			ld (debug_mark),a  
c278 3a 87 c2			ld a, (.dmark+1)  
c27b 32 b8 ee			ld (debug_mark+1),a  
c27e 3a 88 c2			ld a, (.dmark+2)  
c281 32 b9 ee			ld (debug_mark+2),a  
c284 18 03			jr .pastdmark  
c286 ..			.dmark: db "ED1"  
c289 f1			.pastdmark: pop af  
c28a			endm  
# End of macro DMARK
c28a						CALLMONITOR 
c28a cd a3 92			call break_point_state  
c28d				endm  
# End of macro CALLMONITOR
c28d					endif 
c28d cd 6b 99				call forth_push_str 
c290					NEXTW 
c290 c3 66 9c			jp macro_next 
c293				endm 
# End of macro NEXTW
c293			 
c293			 
c293			 
c293			.ENDKEY: 
c293			; eof 
c293			 
# End of file forth_words_key.asm
c293			 
c293			if STORAGE_SE 
c293			   	include "forth_words_storage.asm" 
c293			endif 
c293				include "forth_words_device.asm" 
c293			; Device related words 
c293			 
c293			; | ## Device Words 
c293			 
c293			if SOUND_ENABLE 
c293			.NOTE: 
c293				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c293			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c293					if DEBUG_FORTH_WORDS_KEY 
c293						DMARK "NTE" 
c293						CALLMONITOR 
c293					endif 
c293			 
c293				 
c293			 
c293					NEXTW 
c293			.AFTERSOUND: 
c293			endif 
c293			 
c293			 
c293			USE_GPIO: equ 0 
c293			 
c293			if USE_GPIO 
c293			.GP1: 
c293				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c293			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c293					NEXTW 
c293			.GP2: 
c293				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c293			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c293			 
c293					NEXTW 
c293			 
c293			.GP3: 
c293				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c293			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c293			 
c293					NEXTW 
c293			 
c293			.GP4: 
c293				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c293			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c293			 
c293					NEXTW 
c293			.SIN: 
c293			 
c293			 
c293			endif 
c293			 
c293			 
c293				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c293 33				db WORD_SYS_CORE+31             
c294 c8 c2			dw .SOUT            
c296 03				db 2 + 1 
c297 .. 00			db "IN",0              
c29a				endm 
# End of macro CWHEAD
c29a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c29a					if DEBUG_FORTH_WORDS_KEY 
c29a						DMARK "IN." 
c29a f5				push af  
c29b 3a af c2			ld a, (.dmark)  
c29e 32 b7 ee			ld (debug_mark),a  
c2a1 3a b0 c2			ld a, (.dmark+1)  
c2a4 32 b8 ee			ld (debug_mark+1),a  
c2a7 3a b1 c2			ld a, (.dmark+2)  
c2aa 32 b9 ee			ld (debug_mark+2),a  
c2ad 18 03			jr .pastdmark  
c2af ..			.dmark: db "IN."  
c2b2 f1			.pastdmark: pop af  
c2b3			endm  
# End of macro DMARK
c2b3						CALLMONITOR 
c2b3 cd a3 92			call break_point_state  
c2b6				endm  
# End of macro CALLMONITOR
c2b6					endif 
c2b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2b6 cd f4 9a			call macro_dsp_valuehl 
c2b9				endm 
# End of macro FORTH_DSP_VALUEHL
c2b9			 
c2b9 e5					push hl 
c2ba			 
c2ba					; destroy value TOS 
c2ba			 
c2ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ba cd ac 9b			call macro_forth_dsp_pop 
c2bd				endm 
# End of macro FORTH_DSP_POP
c2bd			 
c2bd					; one value on hl get other one back 
c2bd			 
c2bd c1					pop bc 
c2be			 
c2be					; do the sub 
c2be			;		ex de, hl 
c2be			 
c2be ed 68				in l,(c) 
c2c0			 
c2c0					; save it 
c2c0			 
c2c0 26 00				ld h,0 
c2c2			 
c2c2					; TODO push value back onto stack for another op etc 
c2c2			 
c2c2 cd fd 98				call forth_push_numhl 
c2c5					NEXTW 
c2c5 c3 66 9c			jp macro_next 
c2c8				endm 
# End of macro NEXTW
c2c8			.SOUT: 
c2c8				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c2c8 34				db WORD_SYS_CORE+32             
c2c9 1b c3			dw .SPIO            
c2cb 04				db 3 + 1 
c2cc .. 00			db "OUT",0              
c2d0				endm 
# End of macro CWHEAD
c2d0			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c2d0					if DEBUG_FORTH_WORDS_KEY 
c2d0						DMARK "OUT" 
c2d0 f5				push af  
c2d1 3a e5 c2			ld a, (.dmark)  
c2d4 32 b7 ee			ld (debug_mark),a  
c2d7 3a e6 c2			ld a, (.dmark+1)  
c2da 32 b8 ee			ld (debug_mark+1),a  
c2dd 3a e7 c2			ld a, (.dmark+2)  
c2e0 32 b9 ee			ld (debug_mark+2),a  
c2e3 18 03			jr .pastdmark  
c2e5 ..			.dmark: db "OUT"  
c2e8 f1			.pastdmark: pop af  
c2e9			endm  
# End of macro DMARK
c2e9						CALLMONITOR 
c2e9 cd a3 92			call break_point_state  
c2ec				endm  
# End of macro CALLMONITOR
c2ec					endif 
c2ec			 
c2ec					; get port 
c2ec			 
c2ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2ec cd f4 9a			call macro_dsp_valuehl 
c2ef				endm 
# End of macro FORTH_DSP_VALUEHL
c2ef			 
c2ef e5					push hl 
c2f0			 
c2f0					; destroy value TOS 
c2f0			 
c2f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2f0 cd ac 9b			call macro_forth_dsp_pop 
c2f3				endm 
# End of macro FORTH_DSP_POP
c2f3			 
c2f3					; get byte to send 
c2f3			 
c2f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2f3 cd f4 9a			call macro_dsp_valuehl 
c2f6				endm 
# End of macro FORTH_DSP_VALUEHL
c2f6			 
c2f6			;		push hl 
c2f6			 
c2f6					; destroy value TOS 
c2f6			 
c2f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2f6 cd ac 9b			call macro_forth_dsp_pop 
c2f9				endm 
# End of macro FORTH_DSP_POP
c2f9			 
c2f9					; one value on hl get other one back 
c2f9			 
c2f9			;		pop hl 
c2f9			 
c2f9 c1					pop bc 
c2fa			 
c2fa					if DEBUG_FORTH_WORDS 
c2fa						DMARK "OUT" 
c2fa f5				push af  
c2fb 3a 0f c3			ld a, (.dmark)  
c2fe 32 b7 ee			ld (debug_mark),a  
c301 3a 10 c3			ld a, (.dmark+1)  
c304 32 b8 ee			ld (debug_mark+1),a  
c307 3a 11 c3			ld a, (.dmark+2)  
c30a 32 b9 ee			ld (debug_mark+2),a  
c30d 18 03			jr .pastdmark  
c30f ..			.dmark: db "OUT"  
c312 f1			.pastdmark: pop af  
c313			endm  
# End of macro DMARK
c313						CALLMONITOR 
c313 cd a3 92			call break_point_state  
c316				endm  
# End of macro CALLMONITOR
c316					endif 
c316			 
c316 ed 69				out (c), l 
c318			 
c318					NEXTW 
c318 c3 66 9c			jp macro_next 
c31b				endm 
# End of macro NEXTW
c31b			 
c31b			 
c31b			.SPIO: 
c31b			 
c31b			if STORAGE_SE 
c31b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c31b			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c31b			 
c31b					call spi_ce_low 
c31b			    NEXTW 
c31b			 
c31b			.SPICEH: 
c31b				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c31b			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c31b			 
c31b					call spi_ce_high 
c31b			    NEXTW 
c31b			 
c31b			 
c31b			.SPIOb: 
c31b			 
c31b				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c31b			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c31b			 
c31b					; get port 
c31b			 
c31b			 
c31b					; get byte to send 
c31b			 
c31b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c31b			 
c31b			;		push hl    ; u1  
c31b			 
c31b					; destroy value TOS 
c31b			 
c31b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c31b			 
c31b					; one value on hl get other one back 
c31b			 
c31b			;		pop hl   ; u2 - addr 
c31b			 
c31b					; TODO Send SPI byte 
c31b			 
c31b					ld a, l 
c31b					call spi_send_byte 
c31b			 
c31b					NEXTW 
c31b			 
c31b			.SPII: 
c31b				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c31b			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c31b			 
c31b					; TODO Get SPI byte 
c31b			 
c31b					call spi_read_byte 
c31b			 
c31b					ld h, 0 
c31b					ld l, a 
c31b					call forth_push_numhl 
c31b			 
c31b					NEXTW 
c31b			 
c31b			 
c31b			 
c31b			.SESEL: 
c31b				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c31b			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c31b					if DEBUG_FORTH_WORDS_KEY 
c31b						DMARK "BNK" 
c31b						CALLMONITOR 
c31b					endif 
c31b			 
c31b					ld a, 255 
c31b					ld (spi_cartdev), a 
c31b			 
c31b					; get bank 
c31b			 
c31b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c31b			 
c31b			;		push hl 
c31b			 
c31b					; destroy value TOS 
c31b			 
c31b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c31b			 
c31b					; one value on hl get other one back 
c31b			 
c31b			;		pop hl 
c31b			 
c31b			 
c31b					ld c, SPI_CE_HIGH 
c31b					ld b, '0'    ; human readable bank number 
c31b			 
c31b					ld a, l 
c31b			 
c31b					if DEBUG_FORTH_WORDS 
c31b						DMARK "BNK" 
c31b						CALLMONITOR 
c31b					endif 
c31b			 
c31b					; active low 
c31b			 
c31b					cp 0 
c31b					jr z, .bset 
c31b					cp 1 
c31b					jr nz, .b2 
c31b					res 0, c 
c31b					ld b, '1'    ; human readable bank number 
c31b			.b2:		cp 2 
c31b					jr nz, .b3 
c31b					res 1, c 
c31b					ld b, '2'    ; human readable bank number 
c31b			.b3:		cp 3 
c31b					jr nz, .b4 
c31b					res 2, c 
c31b					ld b, '3'    ; human readable bank number 
c31b			.b4:		cp 4 
c31b					jr nz, .b5 
c31b					res 3, c 
c31b					ld b, '4'    ; human readable bank number 
c31b			.b5:		cp 5 
c31b					jr nz, .bset 
c31b					res 4, c 
c31b					ld b, '5'    ; human readable bank number 
c31b			 
c31b			.bset: 
c31b					ld a, c 
c31b					ld (spi_device),a 
c31b					ld a, b 
c31b					ld (spi_device_id),a 
c31b					if DEBUG_FORTH_WORDS 
c31b						DMARK "BN2" 
c31b						CALLMONITOR 
c31b					endif 
c31b			 
c31b					NEXTW 
c31b			 
c31b			.CARTDEV: 
c31b				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c31b			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c31b					if DEBUG_FORTH_WORDS_KEY 
c31b						DMARK "CDV" 
c31b						CALLMONITOR 
c31b					endif 
c31b			 
c31b					; disable se storage bank selection 
c31b			 
c31b					ld a, SPI_CE_HIGH		; ce high 
c31b					ld (spi_device), a 
c31b			 
c31b					; get bank 
c31b			 
c31b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c31b			 
c31b			;		push hl 
c31b			 
c31b					; destroy value TOS 
c31b			 
c31b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c31b			 
c31b					; one value on hl get other one back 
c31b			 
c31b			;		pop hl 
c31b			 
c31b					; active low 
c31b			 
c31b					ld c, 255 
c31b			 
c31b					ld a, l 
c31b					if DEBUG_FORTH_WORDS 
c31b						DMARK "CDV" 
c31b						CALLMONITOR 
c31b					endif 
c31b					cp 0 
c31b					jr z, .cset 
c31b					cp 1 
c31b					jr nz, .c2 
c31b					res 0, c 
c31b			.c2:		cp 2 
c31b					jr nz, .c3 
c31b					res 1, c 
c31b			.c3:		cp 3 
c31b					jr nz, .c4 
c31b					res 2, c 
c31b			.c4:		cp 4 
c31b					jr nz, .c5 
c31b					res 3, c 
c31b			.c5:		cp 5 
c31b					jr nz, .c6 
c31b					res 4, c 
c31b			.c6:		cp 6 
c31b					jr nz, .c7 
c31b					res 5, c 
c31b			.c7:		cp 7 
c31b					jr nz, .c8 
c31b					res 6, c 
c31b			.c8:		cp 8 
c31b					jr nz, .cset 
c31b					res 7, c 
c31b			.cset:		ld a, c 
c31b					ld (spi_cartdev),a 
c31b			 
c31b					if DEBUG_FORTH_WORDS 
c31b						DMARK "CD2" 
c31b						CALLMONITOR 
c31b					endif 
c31b					NEXTW 
c31b			endif 
c31b			 
c31b			.ENDDEVICE: 
c31b			; eof 
c31b			 
# End of file forth_words_device.asm
c31b			 
c31b			; var handler 
c31b			 
c31b			 
c31b			.VARS: 
c31b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c31b 78				db WORD_SYS_CORE+100             
c31c 33 c3			dw .V0Q            
c31e 04				db 3 + 1 
c31f .. 00			db "V0!",0              
c323				endm 
# End of macro CWHEAD
c323			;| V0! ( u1 -- )  Store value to v0  | DONE 
c323			 
c323					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c323 cd f4 9a			call macro_dsp_valuehl 
c326				endm 
# End of macro FORTH_DSP_VALUEHL
c326			 
c326 11 90 ec				ld de, cli_var_array 
c329			 
c329 eb					ex de, hl 
c32a 73					ld (hl), e 
c32b 23					inc hl 
c32c 72					ld (hl), d 
c32d			 
c32d					; destroy value TOS 
c32d			 
c32d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c32d cd ac 9b			call macro_forth_dsp_pop 
c330				endm 
# End of macro FORTH_DSP_POP
c330			 
c330				       NEXTW 
c330 c3 66 9c			jp macro_next 
c333				endm 
# End of macro NEXTW
c333			.V0Q: 
c333				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c333 79				db WORD_SYS_CORE+101             
c334 44 c3			dw .V1S            
c336 04				db 3 + 1 
c337 .. 00			db "V0@",0              
c33b				endm 
# End of macro CWHEAD
c33b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c33b 2a 90 ec				ld hl, (cli_var_array) 
c33e cd fd 98				call forth_push_numhl 
c341			 
c341				       NEXTW 
c341 c3 66 9c			jp macro_next 
c344				endm 
# End of macro NEXTW
c344			.V1S: 
c344				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c344 7a				db WORD_SYS_CORE+102             
c345 5c c3			dw .V1Q            
c347 04				db 3 + 1 
c348 .. 00			db "V1!",0              
c34c				endm 
# End of macro CWHEAD
c34c			;| V1! ( u1 -- )  Store value to v1 | DONE 
c34c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c34c cd f4 9a			call macro_dsp_valuehl 
c34f				endm 
# End of macro FORTH_DSP_VALUEHL
c34f			 
c34f 11 92 ec				ld de, cli_var_array+2 
c352				 
c352 eb					ex de, hl 
c353 73					ld (hl), e 
c354 23					inc hl 
c355 72					ld (hl), d 
c356			 
c356					; destroy value TOS 
c356			 
c356					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c356 cd ac 9b			call macro_forth_dsp_pop 
c359				endm 
# End of macro FORTH_DSP_POP
c359				       NEXTW 
c359 c3 66 9c			jp macro_next 
c35c				endm 
# End of macro NEXTW
c35c			.V1Q: 
c35c				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c35c 7b				db WORD_SYS_CORE+103             
c35d 6d c3			dw .V2S            
c35f 04				db 3 + 1 
c360 .. 00			db "V1@",0              
c364				endm 
# End of macro CWHEAD
c364			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c364 2a 92 ec				ld hl, (cli_var_array+2) 
c367 cd fd 98				call forth_push_numhl 
c36a				       NEXTW 
c36a c3 66 9c			jp macro_next 
c36d				endm 
# End of macro NEXTW
c36d			.V2S: 
c36d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c36d 7c				db WORD_SYS_CORE+104             
c36e 85 c3			dw .V2Q            
c370 04				db 3 + 1 
c371 .. 00			db "V2!",0              
c375				endm 
# End of macro CWHEAD
c375			;| V2! ( u1 -- )  Store value to v2 | DONE 
c375					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c375 cd f4 9a			call macro_dsp_valuehl 
c378				endm 
# End of macro FORTH_DSP_VALUEHL
c378			 
c378 11 94 ec				ld de, cli_var_array+4 
c37b				 
c37b eb					ex de, hl 
c37c 73					ld (hl), e 
c37d 23					inc hl 
c37e 72					ld (hl), d 
c37f			 
c37f					; destroy value TOS 
c37f			 
c37f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c37f cd ac 9b			call macro_forth_dsp_pop 
c382				endm 
# End of macro FORTH_DSP_POP
c382				       NEXTW 
c382 c3 66 9c			jp macro_next 
c385				endm 
# End of macro NEXTW
c385			.V2Q: 
c385				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c385 7d				db WORD_SYS_CORE+105             
c386 96 c3			dw .V3S            
c388 04				db 3 + 1 
c389 .. 00			db "V2@",0              
c38d				endm 
# End of macro CWHEAD
c38d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c38d 2a 94 ec				ld hl, (cli_var_array+4) 
c390 cd fd 98				call forth_push_numhl 
c393				       NEXTW 
c393 c3 66 9c			jp macro_next 
c396				endm 
# End of macro NEXTW
c396			.V3S: 
c396				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c396 7c				db WORD_SYS_CORE+104             
c397 ae c3			dw .V3Q            
c399 04				db 3 + 1 
c39a .. 00			db "V3!",0              
c39e				endm 
# End of macro CWHEAD
c39e			;| V3! ( u1 -- )  Store value to v3 | DONE 
c39e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c39e cd f4 9a			call macro_dsp_valuehl 
c3a1				endm 
# End of macro FORTH_DSP_VALUEHL
c3a1			 
c3a1 11 96 ec				ld de, cli_var_array+6 
c3a4				 
c3a4 eb					ex de, hl 
c3a5 73					ld (hl), e 
c3a6 23					inc hl 
c3a7 72					ld (hl), d 
c3a8			 
c3a8					; destroy value TOS 
c3a8			 
c3a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3a8 cd ac 9b			call macro_forth_dsp_pop 
c3ab				endm 
# End of macro FORTH_DSP_POP
c3ab				       NEXTW 
c3ab c3 66 9c			jp macro_next 
c3ae				endm 
# End of macro NEXTW
c3ae			.V3Q: 
c3ae				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c3ae 7d				db WORD_SYS_CORE+105             
c3af bf c3			dw .END            
c3b1 04				db 3 + 1 
c3b2 .. 00			db "V3@",0              
c3b6				endm 
# End of macro CWHEAD
c3b6			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c3b6 2a 96 ec				ld hl, (cli_var_array+6) 
c3b9 cd fd 98				call forth_push_numhl 
c3bc				       NEXTW 
c3bc c3 66 9c			jp macro_next 
c3bf				endm 
# End of macro NEXTW
c3bf			 
c3bf			 
c3bf			 
c3bf			 
c3bf			 
c3bf			; end of dict marker 
c3bf			 
c3bf 00			.END:    db WORD_SYS_END 
c3c0 00 00			dw 0 
c3c2 00				db 0 
c3c3			 
c3c3			; use to jp here for user dict words to save on macro expansion  
c3c3			 
c3c3			user_dict_next: 
c3c3				NEXTW 
c3c3 c3 66 9c			jp macro_next 
c3c6				endm 
# End of macro NEXTW
c3c6			 
c3c6			 
c3c6			user_exec: 
c3c6				;    ld hl, <word code> 
c3c6				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c3c6				;    call forthexec 
c3c6				;    jp user_dict_next   (NEXT) 
c3c6			        ;    <word code bytes> 
c3c6 eb				ex de, hl 
c3c7 2a de e7			ld hl,(os_tok_ptr) 
c3ca				 
c3ca				FORTH_RSP_NEXT 
c3ca cd a4 98			call macro_forth_rsp_next 
c3cd				endm 
# End of macro FORTH_RSP_NEXT
c3cd			 
c3cd			if DEBUG_FORTH_UWORD 
c3cd						DMARK "UEX" 
c3cd f5				push af  
c3ce 3a e2 c3			ld a, (.dmark)  
c3d1 32 b7 ee			ld (debug_mark),a  
c3d4 3a e3 c3			ld a, (.dmark+1)  
c3d7 32 b8 ee			ld (debug_mark+1),a  
c3da 3a e4 c3			ld a, (.dmark+2)  
c3dd 32 b9 ee			ld (debug_mark+2),a  
c3e0 18 03			jr .pastdmark  
c3e2 ..			.dmark: db "UEX"  
c3e5 f1			.pastdmark: pop af  
c3e6			endm  
# End of macro DMARK
c3e6				CALLMONITOR 
c3e6 cd a3 92			call break_point_state  
c3e9				endm  
# End of macro CALLMONITOR
c3e9			endif 
c3e9			 
c3e9			 
c3e9			 
c3e9 eb				ex de, hl 
c3ea 22 de e7			ld (os_tok_ptr), hl 
c3ed				 
c3ed				; Don't use next - Skips the first word in uword. 
c3ed			 
c3ed c3 f7 9c			jp exec1 
c3f0			;	NEXT 
c3f0			 
c3f0			 
c3f0			; eof 
# End of file forth_wordsv4.asm
c3f0			endif 
c3f0			;;;;;;;;;;;;;; Debug code 
c3f0			 
c3f0			 
c3f0			;if DEBUG_FORTH_PARSE 
c3f0 .. 00		.nowordfound: db "No match",0 
c3f9 .. 00		.compword:	db "Comparing word ",0 
c409 .. 00		.nextwordat:	db "Next word at",0 
c416 .. 00		.charmatch:	db "Char match",0 
c421			;endif 
c421			if DEBUG_FORTH_JP 
c421			.foundword:	db "Word match. Exec..",0 
c421			endif 
c421			;if DEBUG_FORTH_PUSH 
c421 .. 00		.enddict:	db "Dict end. Push.",0 
c431 .. 00		.push_str:	db "Pushing string",0 
c440 .. 00		.push_num:	db "Pushing number",0 
c44f .. 00		.data_sp:	db "SP:",0 
c453 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c465 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c477 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c489			;endif 
c489			;if DEBUG_FORTH_MALLOC 
c489 .. 00		.push_malloc:	db "Malloc address",0 
c498			;endif 
c498			 
c498			 
c498			 
c498			; display malloc address and current data stack pointer  
c498			 
c498			malloc_error: 
c498 d5				push de 
c499 f5				push af 
c49a e5				push hl 
c49b cd 75 88			call clear_display 
c49e 11 c0 c4			ld de, .mallocerr 
c4a1 3e 00			ld a,0 
c4a3			;	ld de,os_word_scratch 
c4a3 cd 88 88			call str_at_display 
c4a6 3e 11			ld a, display_row_1+17 
c4a8 11 b7 ee			ld de, debug_mark 
c4ab cd 88 88			call str_at_display 
c4ae cd 98 88			call update_display 
c4b1				;call break_point_state 
c4b1 cd ce d7			call cin_wait 
c4b4			 
c4b4 3e 20			ld a, ' ' 
c4b6 32 ce e4			ld (os_view_disable), a 
c4b9 e1				pop hl 
c4ba f1				pop af 
c4bb d1				pop de	 
c4bc				CALLMONITOR 
c4bc cd a3 92			call break_point_state  
c4bf				endm  
# End of macro CALLMONITOR
c4bf c9				ret 
c4c0			 
c4c0 .. 00		.mallocerr: 	db "Malloc Error",0 
c4cd			;if DEBUG_FORTH_PUSH 
c4cd			display_data_sp: 
c4cd f5				push af 
c4ce			 
c4ce				; see if disabled 
c4ce			 
c4ce 3a ce e4			ld a, (os_view_disable) 
c4d1 fe 2a			cp '*' 
c4d3 28 67			jr z, .skipdsp 
c4d5			 
c4d5 e5				push hl 
c4d6 e5				push hl 
c4d7 e5			push hl 
c4d8 cd 75 88			call clear_display 
c4db e1			pop hl 
c4dc 7c				ld a,h 
c4dd 21 e2 e7			ld hl, os_word_scratch 
c4e0 cd a3 8d			call hexout 
c4e3 e1				pop hl 
c4e4 7d				ld a,l 
c4e5 21 e4 e7			ld hl, os_word_scratch+2 
c4e8 cd a3 8d			call hexout 
c4eb 21 e6 e7			ld hl, os_word_scratch+4 
c4ee 3e 00			ld a,0 
c4f0 77				ld (hl),a 
c4f1 11 e2 e7			ld de,os_word_scratch 
c4f4 3e 14				ld a, display_row_2 
c4f6 cd 88 88				call str_at_display 
c4f9 11 53 c4			ld de, .wordinhl 
c4fc 3e 00			ld a, display_row_1 
c4fe			 
c4fe cd 88 88				call str_at_display 
c501 11 b7 ee			ld de, debug_mark 
c504 3e 11			ld a, display_row_1+17 
c506			 
c506 cd 88 88				call str_at_display 
c509			 
c509				; display current data stack pointer 
c509 11 4f c4			ld de,.data_sp 
c50c 3e 1c				ld a, display_row_2 + 8 
c50e cd 88 88				call str_at_display 
c511			 
c511 2a 8a ec			ld hl,(cli_data_sp) 
c514 e5				push hl 
c515 7c				ld a,h 
c516 21 e2 e7			ld hl, os_word_scratch 
c519 cd a3 8d			call hexout 
c51c e1				pop hl 
c51d 7d				ld a,l 
c51e 21 e4 e7			ld hl, os_word_scratch+2 
c521 cd a3 8d			call hexout 
c524 21 e6 e7			ld hl, os_word_scratch+4 
c527 3e 00			ld a,0 
c529 77				ld (hl),a 
c52a 11 e2 e7			ld de,os_word_scratch 
c52d 3e 1f				ld a, display_row_2 + 11 
c52f cd 88 88				call str_at_display 
c532			 
c532			 
c532 cd 98 88			call update_display 
c535 cd f2 87			call delay1s 
c538 cd f2 87			call delay1s 
c53b e1				pop hl 
c53c			.skipdsp: 
c53c f1				pop af 
c53d c9				ret 
c53e			 
c53e			display_data_malloc: 
c53e			 
c53e f5				push af 
c53f e5				push hl 
c540 e5				push hl 
c541 e5			push hl 
c542 cd 75 88			call clear_display 
c545 e1			pop hl 
c546 7c				ld a,h 
c547 21 e2 e7			ld hl, os_word_scratch 
c54a cd a3 8d			call hexout 
c54d e1				pop hl 
c54e 7d				ld a,l 
c54f 21 e4 e7			ld hl, os_word_scratch+2 
c552 cd a3 8d			call hexout 
c555 21 e6 e7			ld hl, os_word_scratch+4 
c558 3e 00			ld a,0 
c55a 77				ld (hl),a 
c55b 11 e2 e7			ld de,os_word_scratch 
c55e 3e 14				ld a, display_row_2 
c560 cd 88 88				call str_at_display 
c563 11 89 c4			ld de, .push_malloc 
c566 3e 00			ld a, display_row_1 
c568			 
c568 cd 88 88				call str_at_display 
c56b			 
c56b				; display current data stack pointer 
c56b 11 4f c4			ld de,.data_sp 
c56e 3e 1c				ld a, display_row_2 + 8 
c570 cd 88 88				call str_at_display 
c573			 
c573 2a 8a ec			ld hl,(cli_data_sp) 
c576 e5				push hl 
c577 7c				ld a,h 
c578 21 e2 e7			ld hl, os_word_scratch 
c57b cd a3 8d			call hexout 
c57e e1				pop hl 
c57f 7d				ld a,l 
c580 21 e4 e7			ld hl, os_word_scratch+2 
c583 cd a3 8d			call hexout 
c586 21 e6 e7			ld hl, os_word_scratch+4 
c589 3e 00			ld a,0 
c58b 77				ld (hl),a 
c58c 11 e2 e7			ld de,os_word_scratch 
c58f 3e 1f				ld a, display_row_2 + 11 
c591 cd 88 88				call str_at_display 
c594			 
c594 cd 98 88			call update_display 
c597 cd f2 87			call delay1s 
c59a cd f2 87			call delay1s 
c59d e1				pop hl 
c59e f1				pop af 
c59f c9				ret 
c5a0			;endif 
c5a0			 
c5a0			include "forth_autostart.asm" 
c5a0			; list of commands to perform at system start up 
c5a0			 
c5a0			startcmds: 
c5a0			;	dw test11 
c5a0			;	dw test12 
c5a0			;	dw test13 
c5a0			;	dw test14 
c5a0			;	dw test15 
c5a0			;	dw test16 
c5a0			;	dw test17 
c5a0			;	dw ifthtest1 
c5a0			;	dw ifthtest2 
c5a0			;	dw ifthtest3 
c5a0			;	dw mmtest1 
c5a0			;	dw mmtest2 
c5a0			;	dw mmtest3 
c5a0			;	dw mmtest4 
c5a0			;	dw mmtest5 
c5a0			;	dw mmtest6 
c5a0			;	dw iftest1 
c5a0			;	dw iftest2 
c5a0			;	dw iftest3 
c5a0			;	dw looptest1 
c5a0			;	dw looptest2 
c5a0			;	dw test1 
c5a0			;	dw test2 
c5a0			;	dw test3 
c5a0			;	dw test4 
c5a0			;	dw game2r 
c5a0			;	dw game2b1 
c5a0			;	dw game2b2 
c5a0			 
c5a0				; start up words that are actually useful 
c5a0			 
c5a0 fe c5			dw clrstack 
c5a2 31 c6			dw type 
c5a4 f2 c7			dw stest 
c5a6 55 c6			dw strncpy 
c5a8 93 c7			dw list 
c5aa b6 c6			dw start1 
c5ac c8 c6			dw start2 
c5ae			;	dw start3 
c5ae db c6			dw start3b 
c5b0 33 c7			dw start3c 
c5b2			 
c5b2				; (unit) testing words 
c5b2			 
c5b2 69 c8			dw mtesta 
c5b4 1e c9			dw mtestb 
c5b6 c1 c9			dw mtestc 
c5b8 76 ca			dw mtestd 
c5ba 1a cb			dw mteste 
c5bc			 
c5bc				; demo/game words 
c5bc			 
c5bc 26 d2		        dw game3w 
c5be 54 d2		        dw game3p 
c5c0 72 d2		        dw game3sc 
c5c2 a3 d2		        dw game3vsi 
c5c4 cf d2		        dw game3vs 
c5c6				 
c5c6 19 d0			dw game2b 
c5c8 87 d0			dw game2bf 
c5ca d1 d0			dw game2mba 
c5cc 67 d1			dw game2mbas 
c5ce a9 d1			dw game2mb 
c5d0			 
c5d0 da cc			dw game1 
c5d2 eb cc			dw game1a 
c5d4 4d cd			dw game1b 
c5d6 82 cd			dw game1c 
c5d8 b8 cd			dw game1d 
c5da e9 cd			dw game1s 
c5dc fd cd			dw game1t 
c5de 12 ce			dw game1f 
c5e0 46 ce			dw game1z 
c5e2 8a ce			dw game1zz 
c5e4			 
c5e4 d0 cb			dw test5 
c5e6 08 cc			dw test6 
c5e8 40 cc			dw test7 
c5ea 54 cc			dw test8 
c5ec 80 cc			dw test9 
c5ee 96 cc			dw test10 
c5f0				 
c5f0 61 cf		        dw ssv5 
c5f2 45 cf		        dw ssv4 
c5f4 29 cf		        dw ssv3 
c5f6 f3 ce		        dw ssv2 
c5f8 7a cf		        dw ssv1 
c5fa c2 cf		        dw ssv1cpm 
c5fc			;	dw keyup 
c5fc			;	dw keydown 
c5fc			;	dw keyleft 
c5fc			;	dw keyright 
c5fc			;	dw 	keyf1 
c5fc			;	dw keyf2 
c5fc			;	dw keyf3 
c5fc			;	dw keyf4 
c5fc			;	dw keyf5 
c5fc			;	dw keyf6 
c5fc			;	dw keyf7 
c5fc			;	dw keyf8 
c5fc			;	dw keyf9 
c5fc			;	dw keyf10 
c5fc			;	dw keyf11 
c5fc			;	dw keyf12 
c5fc			;	dw keytab 
c5fc			;	dw keycr 
c5fc			;	dw keyhome 
c5fc			;	dw keyend 
c5fc			;	dw keybs 
c5fc 00 00			db 0, 0	 
c5fe			 
c5fe			 
c5fe			; clear stack  
c5fe			 
c5fe .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c631			 
c631			; type ( addr count - ) 
c631 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c655			 
c655			; some direct memory words 
c655			; strncpy ( len t f -- t ) 
c655			 
c655 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c6b6			 
c6b6 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c6c8 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c6db			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c6db .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c733 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c793			 
c793			 
c793			; a handy word to list items on the stack 
c793			 
c793 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c7f2			 
c7f2			 
c7f2			; test stack  
c7f2			; rnd8 stest 
c7f2			 
c7f2 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c869			 
c869			; random malloc and free cycles 
c869			 
c869 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c91e			 
c91e			; fixed malloc and free cycles 
c91e			 
c91e .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c9c1			 
c9c1			; fixed double string push and drop cycle  
c9c1			 
c9c1 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
ca76			 
ca76			; consistent fixed string push and drop cycle  
ca76			 
ca76 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb1a			 
cb1a .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cbd0			 
cbd0			;test1:		db ": aa 1 2 3 ;", 0 
cbd0			;test2:     	db "111 aa 888 999",0 
cbd0			;test3:     	db ": bb 77 ;",0 
cbd0			;test4:     	db "$02 $01 do i . loop bb",0 
cbd0			 
cbd0 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cc08 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cc40 .. 00		test7:     	db ": box hline vline ;",0 
cc54 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cc80 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cc96 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
ccbb .. 00		test11:     	db "hello create .",0 
ccca .. 00		test12:     	db "hello2 create .",0 
ccda			 
ccda			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
ccda			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
ccda			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
ccda			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
ccda			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
ccda			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
ccda			 
ccda			;iftest1:     	db "$0001 IF cls .",0 
ccda			;iftest2:     	db "$0000 IF cls .",0 
ccda			;iftest3:     	db "$0002 $0003 - IF cls .",0 
ccda			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
ccda			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
ccda			 
ccda			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ccda			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ccda			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ccda			 
ccda			 
ccda			 
ccda			; a small guess the number game 
ccda			 
ccda .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cceb .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cd4d			 
cd4d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cd82 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cdb8 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cde9 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cdfd .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
ce12 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
ce46 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
ce8a			 
ce8a			; Using 'ga' save a high score across multiple runs using external storage 
ce8a			 
ce8a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cef3			 
cef3			 
cef3			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cef3			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cef3			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cef3			 
cef3			; simple screen saver to test code memory reuse to destruction 
cef3			 
cef3 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cf29 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cf45 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cf61 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cf7a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cfc2 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d019			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d019			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d019			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d019			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d019			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d019			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d019			 
d019			 
d019			 
d019			; minesweeper/battleship finding game 
d019			; draws a game board of random ship/mine positions 
d019			; user enters coords to see if it hits on 
d019			; game ends when all are hit 
d019			; when hit or miss says how many may be in the area 
d019			 
d019			; setup the game board and then hide it 
d019 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d087 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d0d1			; prompt for where to target 
d0d1 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d167 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d18c			; TODO see if the entered coords hits or misses pushes char hit of miss 
d18c .. 00		game2mbht:      db ": mbckht nop ;",0 
d19b .. 00		game2mbms:      db ": mbcms nop ;",0 
d1a9			; TODO how many might be near by 
d1a9 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d226			 
d226			; Game 3 
d226			 
d226			; Vert scroller ski game - avoid the trees! 
d226			 
d226			; v0 score (ie turns) 
d226			; v1 player pos 
d226			; v2 left wall 
d226			; v3 right wall 
d226			 
d226			; Draw side walls randomly 
d226			 
d226 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d254			 
d254			; Draw player 
d254 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d272			 
d272			; TODO Get Key 
d272			 
d272			; TODO Move left right 
d272			 
d272			; scroll and move walls a bit 
d272			 
d272 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d2a3			 
d2a3			; main game loop 
d2a3			 
d2a3 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d2cf .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d30e			 
d30e			; key board defs 
d30e			 
d30e .. 00		keyup:       db ": keyup $05 ;",0 
d31c .. 00		keydown:       db ": keydown $0a ;",0 
d32c .. 00		keyleft:       db ": keyleft $0b ;",0 
d33c .. 00		keyright:       db ": keyright $0c ;",0 
d34d .. 00		keyf1:       db ": keyf1 $10 ;",0 
d35b .. 00		keyf2:       db ": keyf2 $11 ;",0 
d369 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d377 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d385 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d393 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d3a1 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d3af .. 00		keyf8:       db ": keyf8 $17 ;",0 
d3bd .. 00		keyf9:       db ": keyf9 $18 ;",0 
d3cb .. 00		keyf10:       db ": keyf10 $19 ;",0 
d3da .. 00		keyf11:       db ": keyf11 $1a ;",0 
d3e9 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d3f8			 
d3f8 .. 00		keytab:       db ": keytab $09 ;",0 
d407 .. 00		keycr:       db ": keycr $0d ;",0 
d415 .. 00		keyhome:       db ": keyhome $0e ;",0 
d425 .. 00		keyend:       db ": keyend $0f ;",0 
d434 .. 00		keybs:       db ": keybs $08 ;",0 
d442			 
d442			   
d442			 
d442			 
d442			 
d442			; eof 
# End of file forth_autostart.asm
d442			 
d442 .. 00		sprompt1: db "Startup load...",0 
d452 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d468			 
d468			 
d468			 
d468			 
d468			forth_startup: 
d468 21 a0 c5			ld hl, startcmds 
d46b 3e 00			ld a, 0 
d46d 32 03 e9			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d470			 
d470 e5			.start1:	push hl 
d471 cd 75 88			call clear_display 
d474 11 42 d4			ld de, sprompt1 
d477 3e 00		        ld a, display_row_1 
d479 cd 88 88			call str_at_display 
d47c 11 52 d4			ld de, sprompt2 
d47f 3e 14		        ld a, display_row_2 
d481 cd 88 88			call str_at_display 
d484 e1				pop hl 
d485 e5				push hl 
d486 5e				ld e,(hl) 
d487 23				inc hl 
d488 56				ld d,(hl) 
d489 3e 28		        ld a, display_row_3 
d48b cd 88 88			call str_at_display 
d48e cd 98 88			call update_display 
d491			 
d491			 
d491 3a 03 e9			ld a, (os_last_cmd) 
d494 fe 00			cp 0 
d496 28 05			jr z, .startprompt 
d498 cd e6 87			call delay250ms 
d49b 18 24			jr .startdo 
d49d				 
d49d				 
d49d			 
d49d			.startprompt: 
d49d			 
d49d 3e 4f			ld a,display_row_4 + display_cols - 1 
d49f 11 73 98		        ld de, endprg 
d4a2 cd 88 88			call str_at_display 
d4a5 cd 98 88			call update_display 
d4a8 cd f2 87			call delay1s 
d4ab cd ce d7			call cin_wait 
d4ae						 
d4ae fe 2a			cp '*' 
d4b0 28 5e			jr z, .startupend1 
d4b2 fe 23			cp '#' 
d4b4 20 07			jr nz, .startno 
d4b6 3e 01			ld a, 1 
d4b8 32 03 e9			ld (os_last_cmd),a 
d4bb 18 04			jr .startdo 
d4bd fe 31		.startno:	cp '1' 
d4bf 28 3a			jr z,.startnxt  
d4c1			 
d4c1				; exec startup line 
d4c1			.startdo:	 
d4c1 e1				pop hl 
d4c2 e5				push hl 
d4c3				 
d4c3 5e				ld e,(hl) 
d4c4 23				inc hl 
d4c5 56				ld d,(hl) 
d4c6 eb				ex de,hl 
d4c7			 
d4c7 e5				push hl 
d4c8			 
d4c8 3e 00			ld a, 0 
d4ca				;ld a, FORTH_END_BUFFER 
d4ca cd 0b 8f			call strlent 
d4cd 23				inc hl   ; include zero term to copy 
d4ce 06 00			ld b,0 
d4d0 4d				ld c,l 
d4d1 e1				pop hl 
d4d2 11 dd e4			ld de, scratch 
d4d5 ed b0			ldir 
d4d7			 
d4d7			 
d4d7 21 dd e4			ld hl, scratch 
d4da cd b4 9c			call forthparse 
d4dd cd f4 9c			call forthexec 
d4e0 cd 0b 9c			call forthexec_cleanup 
d4e3			 
d4e3 3e 3c			ld a, display_row_4 
d4e5 11 17 96			ld de, endprog 
d4e8			 
d4e8 cd 98 88			call update_display		 
d4eb			 
d4eb 3a 03 e9			ld a, (os_last_cmd) 
d4ee fe 00			cp 0 
d4f0 20 09			jr nz, .startnxt 
d4f2 cd 75 98			call next_page_prompt 
d4f5 cd 75 88		        call clear_display 
d4f8 cd 98 88			call update_display		 
d4fb			 
d4fb				; move onto next startup line? 
d4fb			.startnxt: 
d4fb			 
d4fb cd e6 87			call delay250ms 
d4fe e1				pop hl 
d4ff			 
d4ff 23				inc hl 
d500 23				inc hl 
d501			 
d501 e5				push hl 
d502 5e				ld e, (hl) 
d503 23				inc hl 
d504 56				ld d, (hl) 
d505 e1				pop hl 
d506				; TODO replace 0 test 
d506			 
d506 eb				ex de, hl 
d507 cd cb 8a			call ishlzero 
d50a			;	ld a,e 
d50a			;	add d 
d50a			;	cp 0    ; any left to do? 
d50a eb				ex de, hl 
d50b c2 70 d4			jp nz, .start1 
d50e 18 01			jr .startupend 
d510			 
d510 e1			.startupend1: pop hl 
d511			.startupend: 
d511			 
d511 cd 75 88			call clear_display 
d514 cd 98 88			call update_display 
d517 c9				ret 
d518			 
d518			 
d518			; stack over and underflow checks 
d518			 
d518			; init the words to detect the under/overflow 
d518			 
d518			chk_stk_init: 
d518				; a vague random number to check so we dont get any "lucky" hits 
d518 3e 2d			ld a, 45 
d51a 6f				ld l, a 
d51b 00				nop 
d51c 3e 17			ld a, 23 
d51e 67				ld h, a 
d51f			 
d51f 22 c4 e4			ld (chk_word), hl     ; the word we need to check against 
d522			 
d522			;	ld (chk_stund), hl	; stack points.... 
d522 22 00 ef			ld (chk_stovr), hl 
d525 22 88 ec			ld (chk_ret_und), hl 
d528 22 46 ec			ld (chk_ret_ovr), hl 
d52b 22 44 eb			ld (chk_loop_ovr), hl 
d52e 22 42 ea			ld (chk_data_ovr), hl 
d531 c9				ret 
d532				 
d532			check_stacks: 
d532				; check all stack words 
d532			 
d532 e5				push hl 
d533 d5				push de 
d534			 
d534			;	ld de,(chk_word) 
d534			;	ld hl, (chk_stund)	; stack points.... 
d534			;	if DEBUG_STK_FAULT 
d534			;		DMARK "FAa" 
d534			;		CALLMONITOR 
d534			;	endif 
d534			;	call cmp16 
d534			;	jp z, .chk_faulta 
d534			; 
d534			;	ld de, sfaultsu 
d534			;	jp .chk_fault 
d534			 
d534 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d537 ed 5b c4 e4		ld de,(chk_word) 
d53b				if DEBUG_STK_FAULT 
d53b					DMARK "FAb" 
d53b					CALLMONITOR 
d53b				endif 
d53b cd c0 8a			call cmp16 
d53e 28 06			jr z, .chk_fault1 
d540 11 e1 d5			ld de, sfaultso 
d543 c3 95 d5			jp .chk_fault 
d546			.chk_fault1:  
d546 2a 88 ec			ld hl, (chk_ret_und) 
d549 ed 5b c4 e4		ld de,(chk_word) 
d54d				if DEBUG_STK_FAULT 
d54d					DMARK "FAU" 
d54d					CALLMONITOR 
d54d				endif 
d54d cd c0 8a			call cmp16 
d550 ca 59 d5			jp z, .chk_fault2 
d553 11 f1 d5			ld de, sfaultru 
d556 c3 95 d5			jp .chk_fault 
d559			.chk_fault2:  
d559 2a 46 ec			ld hl, (chk_ret_ovr) 
d55c ed 5b c4 e4		ld de,(chk_word) 
d560				if DEBUG_STK_FAULT 
d560					DMARK "FA1" 
d560					CALLMONITOR 
d560				endif 
d560 cd c0 8a			call cmp16 
d563 ca 6c d5			jp z, .chk_fault3 
d566 11 ff d5			ld de, sfaultro 
d569 c3 95 d5			jp .chk_fault 
d56c			.chk_fault3:  
d56c 2a 44 eb			ld hl, (chk_loop_ovr) 
d56f ed 5b c4 e4		ld de,(chk_word) 
d573				if DEBUG_STK_FAULT 
d573					DMARK "FA2" 
d573					CALLMONITOR 
d573				endif 
d573 cd c0 8a			call cmp16 
d576 ca 7f d5			jp z, .chk_fault4 
d579 11 19 d6			ld de, sfaultlo 
d57c c3 95 d5			jp .chk_fault 
d57f			.chk_fault4:  
d57f 2a 42 ea			ld hl, (chk_data_ovr) 
d582 ed 5b c4 e4		ld de,(chk_word) 
d586				if DEBUG_STK_FAULT 
d586					DMARK "FA3" 
d586					CALLMONITOR 
d586				endif 
d586 cd c0 8a			call cmp16 
d589 ca 92 d5			jp z, .chk_fault5 
d58c 11 33 d6			ld de, sfaultdo 
d58f c3 95 d5			jp .chk_fault 
d592			 
d592			 
d592			.chk_fault5:  
d592 d1				pop de 
d593 e1				pop hl 
d594			 
d594 c9				ret 
d595			 
d595 cd 75 88		.chk_fault: 	call clear_display 
d598 3e 14				ld a, display_row_2 
d59a cd 88 88				call str_at_display 
d59d 11 c3 d5				   ld de, .stackfault 
d5a0 3e 00				ld a, display_row_1 
d5a2 cd 88 88				call str_at_display 
d5a5 11 b7 ee				    ld de, debug_mark 
d5a8 3e 11				ld a, display_row_1+17 
d5aa cd 88 88				call str_at_display 
d5ad cd 98 88				call update_display 
d5b0			 
d5b0				; prompt before entering montior for investigating issue 
d5b0			 
d5b0 3e 3c			ld a, display_row_4 
d5b2 11 17 96			ld de, endprog 
d5b5			 
d5b5 cd 98 88			call update_display		 
d5b8			 
d5b8 cd 75 98			call next_page_prompt 
d5bb			 
d5bb d1				pop de 
d5bc e1				pop hl 
d5bd cd 6b 96				call monitor 
d5c0 c3 65 95				jp warmstart 
d5c3					;jp 0 
d5c3					;halt 
d5c3			 
d5c3			 
d5c3			 
d5c3 .. 00		.stackfault: 	db "Stack fault:",0 
d5d0			 
d5d0 .. 00		sfaultsu: 	db	"Stack under flow",0 
d5e1 .. 00		sfaultso: 	db	"Stack over flow",0 
d5f1 .. 00		sfaultru:	db "RTS underflow",0 
d5ff .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d619 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d633 .. 00		sfaultdo:	db "DTS overflow", 0 
d640			 
d640			 
d640			fault_dsp_under: 
d640 11 52 d6			ld de, .dsp_under 
d643 c3 02 d7			jp .show_fault 
d646			 
d646			fault_rsp_under: 
d646 11 60 d6			ld de, .rsp_under 
d649 c3 02 d7			jp .show_fault 
d64c			fault_loop_under: 
d64c 11 6e d6			ld de, .loop_under 
d64f c3 02 d7			jp .show_fault 
d652			 
d652 .. 00		.dsp_under: db "DSP Underflow",0 
d660 .. 00		.rsp_under: db "RSP Underflow",0 
d66e .. 00		.loop_under: db "LOOP Underflow",0 
d67d			 
d67d			 
d67d d5			type_faultn: 	push de 
d67e e5					push hl 
d67f cd 75 88				call clear_display 
d682 11 a9 d6				   ld de, .typefaultn 
d685 3e 00				ld a, display_row_1 
d687 cd 88 88				call str_at_display 
d68a 11 b7 ee				    ld de, debug_mark 
d68d 3e 11				ld a, display_row_1+17 
d68f cd 88 88				call str_at_display 
d692 cd 98 88				call update_display 
d695			 
d695				; prompt before entering montior for investigating issue 
d695			 
d695 3e 3c			ld a, display_row_4 
d697 11 17 96			ld de, endprog 
d69a			 
d69a cd 98 88			call update_display		 
d69d			 
d69d cd 75 98			call next_page_prompt 
d6a0			 
d6a0 e5					push hl 
d6a1 d5					push de 
d6a2 cd 6b 96				call monitor 
d6a5 c3 65 95				jp warmstart 
d6a8 76					halt 
d6a9			 
d6a9			 
d6a9 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d6c0			 
d6c0 d5			type_faults: 	push de 
d6c1 e5					push hl 
d6c2 cd 75 88				call clear_display 
d6c5 11 eb d6				   ld de, .typefaults 
d6c8 3e 00				ld a, display_row_1 
d6ca cd 88 88				call str_at_display 
d6cd 11 b7 ee				    ld de, debug_mark 
d6d0 3e 11				ld a, display_row_1+17 
d6d2 cd 88 88				call str_at_display 
d6d5 cd 98 88				call update_display 
d6d8			 
d6d8				; prompt before entering montior for investigating issue 
d6d8			 
d6d8 3e 3c			ld a, display_row_4 
d6da 11 17 96			ld de, endprog 
d6dd			 
d6dd cd 98 88			call update_display		 
d6e0			 
d6e0 cd 75 98			call next_page_prompt 
d6e3			 
d6e3 e1					pop hl 
d6e4 d1					pop de 
d6e5 cd 6b 96				call monitor 
d6e8 c3 65 95				jp warmstart 
d6eb			 
d6eb			 
d6eb .. 00		.typefaults: db "STR Type Expected TOS!",0 
d702			 
d702			.show_fault: 	 
d702 d5					push de 
d703 cd 75 88				call clear_display 
d706 d1					pop de 
d707 3e 00				ld a, display_row_1 
d709 cd 88 88				call str_at_display 
d70c 11 b7 ee				    ld de, debug_mark 
d70f 3e 11				ld a, display_row_1+17 
d711 cd 88 88				call str_at_display 
d714 cd 98 88				call update_display 
d717			 
d717				; prompt before entering montior for investigating issue 
d717			 
d717 3e 3c			ld a, display_row_4 
d719 11 17 96			ld de, endprog 
d71c			 
d71c cd 98 88			call update_display		 
d71f			 
d71f cd 75 98			call next_page_prompt 
d722			 
d722 e1					pop hl 
d723 d1					pop de 
d724 cd 6b 96				call monitor 
d727			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d727			; TODO Make optional fault restart to cli or warm boot? 
d727					;jp warmstart 
d727 c3 bd 95				jp cli 
d72a 76					halt 
d72b			 
d72b			; handle the auto run of code from files in storage 
d72b			 
d72b			 
d72b			if STORAGE_SE 
d72b			 
d72b			sprompt3: db "Loading from start-up file?:",0 
d72b			sprompt4: db "(Y=Any key/N=No)",0 
d72b			 
d72b			 
d72b			forth_autoload: 
d72b			 
d72b				; load block 0 of store 1 
d72b				 
d72b				ld a, $fe      ; bit 0 clear 
d72b				ld (spi_device), a 
d72b			 
d72b				call storage_get_block_0 
d72b			 
d72b				ld a, (store_page+STORE_0_AUTOFILE) 
d72b			 
d72b				cp 0 
d72b				ret z     ; auto start not enabled 
d72b			 
d72b				call clear_display 
d72b			 
d72b				; set bank 
d72b			 
d72b					ld a, (store_page+STORE_0_BANKRUN) 
d72b					ld (spi_device), a 
d72b			 
d72b				; get file id to load from and get the file name to display 
d72b			 
d72b					ld a, (store_page+STORE_0_FILERUN) 
d72b			 
d72b					ld l, 0 
d72b					ld h, a 
d72b					ld de, store_page 
d72b			 
d72b					if DEBUG_FORTH_WORDS 
d72b						DMARK "ASp" 
d72b						CALLMONITOR 
d72b					endif 
d72b					call storage_read 
d72b			 
d72b					if DEBUG_FORTH_WORDS 
d72b						DMARK "ASr" 
d72b						CALLMONITOR 
d72b					endif 
d72b			 
d72b					call ishlzero 
d72b					ret z             ; file not found 
d72b			 
d72b					ld a, display_row_2 + 10 
d72b					ld de, store_page+3 
d72b					call str_at_display 
d72b				 
d72b			; 
d72b			 
d72b				ld a, display_row_1+5 
d72b				ld de, sprompt3 
d72b				call str_at_display 
d72b				ld a, display_row_3+15 
d72b				ld de, sprompt4 
d72b				call str_at_display 
d72b			 
d72b				call update_display 
d72b			 
d72b				call cin_wait 
d72b				cp 'n' 
d72b				ret z 
d72b				cp 'N' 
d72b				ret z 
d72b			 
d72b				call delay1s 
d72b			 
d72b				ld a, (store_page+2) 
d72b				ld (store_openmaxext), a    ; save count of ext 
d72b				ld a, 1  
d72b				ld (store_openext), a    ; save count of ext 
d72b			 
d72b			.autof:  
d72b				ld l , a 
d72b				 
d72b				ld a, (store_page) 
d72b				ld h, a	 
d72b				ld de, store_page 
d72b					if DEBUG_FORTH_WORDS 
d72b						DMARK "ASl" 
d72b						CALLMONITOR 
d72b					endif 
d72b					call storage_read 
d72b				call ishlzero 
d72b				ret z 
d72b			;	jr z, .autoend 
d72b			 
d72b					if DEBUG_FORTH_WORDS 
d72b						DMARK "ASc" 
d72b						CALLMONITOR 
d72b					endif 
d72b				ld de, store_page+2 
d72b				ld a, display_row_4 
d72b				call str_at_display 
d72b			 
d72b				call update_display 
d72b				call delay250ms 
d72b			 
d72b			 
d72b			 
d72b				ld hl, store_page+2 
d72b				call forthparse 
d72b				call forthexec 
d72b				call forthexec_cleanup 
d72b			 
d72b				 
d72b				ld a, (store_openext) 
d72b				inc a 
d72b				ld (store_openext), a    ; save count of ext 
d72b			 
d72b				jr .autof 
d72b			;.autofdone: 
d72b			; 
d72b			;		if DEBUG_FORTH_WORDS 
d72b			;			DMARK "ASx" 
d72b			;			CALLMONITOR 
d72b			;		endif 
d72b			;;	call clear_display 
d72b			;	ret 
d72b			 
d72b			 
d72b			 
d72b			endif 
d72b			 
d72b			 
d72b			; eof 
# End of file forth_kernel.asm
d72b			;include "nascombasic.asm" 
d72b			 
d72b			 
d72b			; find out where the code ends if loaded into RAM (for SC114) 
d72b			;endofcode:  
d72b			;	nop 
d72b			 
d72b			 
d72b			; eof 
d72b			 
# End of file main.asm
d72b			;include "firmware_lcd_4x20.asm" 
d72b			;include "firmware_key_4x4.asm" 
d72b			include "firmware_serial_display.asm" 
d72b			 
d72b			; Serial display interface for SC114 
d72b			 
d72b			 
d72b			display_row_1: equ 0 
d72b			display_row_2: equ display_row_1+display_cols 
d72b			display_row_3: equ display_row_2 + display_cols 
d72b			display_row_4: equ display_row_3 + display_cols 
d72b			 
d72b			kLCDWidth:  EQU display_cols             ;Width in characters 
d72b			kLCD_Line1: EQU 0x00  
d72b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d72b			; E1 
d72b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d72b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d72b			 
d72b			lcd_init: 
d72b				; no init as handled by the SCM bios 
d72b c9				ret 
d72c			 
d72c			 
d72c			; low level functions for direct screen writes 
d72c			 
d72c			; output char at pos? 
d72c			fLCD_Str: 
d72c			        ;out (SC114_SIO_1_OUT),a 
d72c c5				push bc 
d72d 0e 02			ld c, $02 
d72f f7				rst $30 
d730 c1				pop bc 
d731 c9				ret 
d732			 
d732			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d732			fLCD_Pos: 
d732				; use ASCII escape to position 
d732			        ;out (SC114_SIO_1_OUT),a 
d732 c5				push bc 
d733 0e 02			ld c, $02 
d735 f7				rst $30 
d736 c1				pop bc 
d737			 
d737 c9				ret 
d738			 
d738			; output char at pos 
d738			fLCD_Data: 
d738			      ;  out (SC114_SIO_1_OUT),a 
d738 c5				push bc 
d739 0e 02			ld c, $02 
d73b f7				rst $30 
d73c c1				pop bc 
d73d			 
d73d c9				ret 
d73e			 
d73e			; ascii cls  
d73e			 
d73e 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d742			 
d742			; write the frame buffer given in hl to hardware  
d742			write_display: 
d742			 
d742			API: equ 0 
d742			 
d742			if API 
d742				push bc 
d742				ld b, 4 
d742			 
d742			        ld (display_write_tmp), hl 	  
d742			 
d742				; clear and home cursor 
d742			 
d742				ld c, 6 
d742				ld de, .cls 
d742				rst $30 
d742			 
d742			 
d742			.writeln: 
d742			 
d742				ld de, (display_write_tmp) 
d742				ld c, 6 
d742				rst $30 
d742				ld c, 7 
d742				rst $30 
d742			 
d742				ld hl, (display_write_tmp) 
d742				ld de, display_cols 
d742				add hl,de 
d742				ld (display_write_tmp),hl 
d742			 
d742				djnz  .writeln 
d742			 
d742				pop bc 
d742			 
d742			 
d742				ret 
d742			endif 
d742 e5				push hl 
d743 c5				push bc 
d744 d5				push de 
d745			 
d745			;	ld c, 2 
d745			;	;ld de, .cls 
d745			;	ld a, 27 
d745			;	rst $30 
d745			;	ld c, 2 
d745			;	;ld de, .cls 
d745			;	ld a, '[' 
d745			;	rst $30 
d745			; 
d745			;	ld c, 2 
d745			;	;ld de, .cls 
d745			;	ld a, 'H' 
d745			;	rst $30 
d745			; 
d745			 
d745 0e 02			ld c, 2 
d747				;ld de, .cls 
d747 3e 1b			ld a, 27 
d749 f7				rst $30 
d74a			 
d74a			 
d74a 0e 02			ld c, 2 
d74c				;ld de, .cls 
d74c 3e 5b			ld a, '[' 
d74e f7				rst $30 
d74f 0e 02			ld c, 2 
d751				;ld de, .cls 
d751 3e 32			ld a, '2' 
d753 f7				rst $30 
d754 0e 02			ld c, 2 
d756				;ld de, .cls 
d756 3e 4a			ld a, 'J' 
d758 f7				rst $30 
d759 d1				pop de 
d75a c1				pop bc 
d75b e1				pop hl 
d75c			 
d75c			 
d75c 22 55 ed		        ld (display_write_tmp), hl 	  
d75f 3e 00			ld a, kLCD_Line1 
d761			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d761 06 14			ld b, display_cols 
d763 ed 5b 55 ed		ld de, (display_write_tmp) 
d767 cd c5 d7			call write_len_string 
d76a				 
d76a			 
d76a e5			push hl 
d76b d5			push de 
d76c c5			push bc 
d76d 0e 07			ld c, 7 
d76f f7				rst $30 
d770 c1			pop bc 
d771 d1			pop de 
d772 e1			pop hl 
d773			 
d773				 
d773 2a 55 ed			ld hl, (display_write_tmp) 
d776 11 14 00			ld de, display_cols 
d779 19				add hl,de 
d77a 22 55 ed			ld (display_write_tmp),hl 
d77d			 
d77d				 
d77d 3e 14			ld a, kLCD_Line2 
d77f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d77f 06 14			ld b, display_cols 
d781 ed 5b 55 ed		ld de, (display_write_tmp) 
d785 cd c5 d7			call write_len_string 
d788				 
d788 2a 55 ed			ld hl, (display_write_tmp) 
d78b 11 14 00			ld de, display_cols 
d78e 19				add hl,de 
d78f 22 55 ed			ld (display_write_tmp),hl 
d792			 
d792 e5			push hl 
d793 d5			push de 
d794 c5			push bc 
d795 0e 07			ld c, 7 
d797 f7				rst $30 
d798 c1			pop bc 
d799 d1			pop de 
d79a e1			pop hl 
d79b			 
d79b				 
d79b 3e 28			ld a, kLCD_Line3 
d79d			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d79d 06 14			ld b, display_cols 
d79f ed 5b 55 ed		ld de, (display_write_tmp) 
d7a3 cd c5 d7			call write_len_string 
d7a6				 
d7a6 2a 55 ed			ld hl, (display_write_tmp) 
d7a9 11 14 00			ld de, display_cols 
d7ac 19				add hl,de 
d7ad 22 55 ed			ld (display_write_tmp),hl 
d7b0			 
d7b0 e5			push hl 
d7b1 d5			push de 
d7b2 c5			push bc 
d7b3 0e 07			ld c, 7 
d7b5 f7				rst $30 
d7b6 c1			pop bc 
d7b7 d1			pop de 
d7b8 e1			pop hl 
d7b9			 
d7b9				 
d7b9 3e 3c			ld a, kLCD_Line4 
d7bb			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d7bb 06 14			ld b, display_cols 
d7bd ed 5b 55 ed		ld de, (display_write_tmp) 
d7c1 cd c5 d7			call write_len_string 
d7c4 c9					ret 
d7c5			 
d7c5			 
d7c5				; write out a fixed length string given in b from de 
d7c5			 
d7c5 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d7c6 cd 38 d7		            CALL fLCD_Data      ;Write character to display 
d7c9 13				inc de 
d7ca 10 f9			djnz write_len_string 
d7cc c9				ret 
d7cd			 
d7cd			 
d7cd			; eof 
# End of file firmware_serial_display.asm
d7cd			include "firmware_key_serial.asm" 
d7cd			; Serial keyboard interface for SC114 
d7cd			 
d7cd			key_init: 
d7cd				; no init as handled by the SCM bios 
d7cd c9				ret 
d7ce			 
d7ce			 
d7ce			cin_wait: 
d7ce			;	ld a, 0 
d7ce			;	ret 
d7ce			 
d7ce				;in a,(SC114_SIO_1_IN) 
d7ce			        ; Use SCM API to get from whatever console device we are using 
d7ce c5				push bc 
d7cf 0e 01			ld c, $01 
d7d1 f7				rst $30 
d7d2 c1				pop bc 
d7d3 c9				ret 
d7d4			 
d7d4			cin: 
d7d4			 
d7d4			 
d7d4 c5				push bc 
d7d5			 
d7d5				; any key waiting to process? 
d7d5 0e 03			ld c, $03 
d7d7 f7				rst $30 
d7d8 28 05			jr z, .cin_skip 
d7da			 
d7da				; yep, get it 
d7da			 
d7da 0e 01			ld c, $01 
d7dc f7				rst $30 
d7dd c1				pop bc 
d7de c9				ret 
d7df			.cin_skip: 
d7df 3e 00			ld a, 0 
d7e1 c1				pop bc 
d7e2 c9				ret 
d7e3			 
d7e3			 
d7e3			 
d7e3			 
# End of file firmware_key_serial.asm
d7e3			 
d7e3			baseram:  
d7e3			endofcode: 
d7e3 00				nop 
d7e4			 
d7e4			heap_start: equ baseram+15  ; Starting address of heap 
d7e4			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d7e4			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d7e4			; 
d7e4			 
# End of file os_mini_sc114.asm
d7e4
