# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 46 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd 75 8a				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd 75 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd 75 8a				call clear_display  
8037			  
8037			  
8037 cd a3 df				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 45 e0			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 45 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 98 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 7a 8a			call fill_display  
804e cd 98 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 7a 8a			call fill_display  
8059 cd 98 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 7a 8a			call fill_display  
8064 cd 98 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 79 96			ld de, prom_bootmsg  
806f cd 88 8a			call str_at_display  
8072 cd 98 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 8e 96			ld de, prom_bootmsg1  
8080 cd 88 8a			call str_at_display  
8083 cd 98 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 7d ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd a3 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 84 ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd a3 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 84 ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd a3 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd cb 8c				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 7d ea				ld hl, (store_tmp1) 
8110 11 87 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd a3 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 38 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd a3 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd a3 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd a3 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd a3 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd cb 8c			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 84 ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd a3 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd a3 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 84 ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 84 ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd a3 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 85 ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd a3 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd a3 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 84 ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 85 ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 87 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 90 ea			ld hl, store_page+3+9 
82b5 3a 69 ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 84 ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd a3 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd a3 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd a2 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd a2 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd a3 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 87 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd a3 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 84 ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd a3 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd a3 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd cb 8c			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 84 ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd cb 8c			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd a3 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 84 ea			ld a, (store_page)	; get file id 
8410 32 78 ea			ld (store_tmpid), a 
8413			 
8413 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
8416 32 77 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 84 ea			ld (store_page), a 
841f 32 85 ea			ld (store_page+1),a 
8422 11 84 ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd a3 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 77 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 78 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd a3 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd cb 8c			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 84 ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 84 ea			ld (store_page), a 
8482 32 85 ea			ld (store_page+1),a 
8485 11 84 ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd a3 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd a3 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd c0 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd a2 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd c0 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd a2 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd a3 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd a3 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd a2 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd a2 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd a3 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 84 ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 84 ea			ld (store_page),a 
85a3				 
85a3 32 78 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 84 ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd a3 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 84 ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd a3 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 6f ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd a3 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 6f ea			ld (store_tmppageid), hl 
8615				 
8615 3a 78 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 84 ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 85 ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 86 ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd a3 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 0b 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd a3 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd a3 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 6f ea			ld hl,(store_tmppageid) 
868b 11 84 ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd a3 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 78 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd a3 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 71 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 72 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 73 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd a3 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 71 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 72 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 73 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd a3 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd cb 8c			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 75 ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 71 ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 72 ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 73 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd a3 94			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd a2 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 77 ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 71 ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 72 ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 73 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd a3 94			call break_point_state  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 7f ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd a2 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 71 ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 72 ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 73 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd a3 94			call break_point_state  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 71 ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 72 ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 73 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd a3 94			call break_point_state  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 71 ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 72 ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 73 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd a3 94			call break_point_state  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd cb 8c			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 75 ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 71 ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 72 ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 73 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd a3 94			call break_point_state  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 71 ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 72 ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 73 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd a3 94			call break_point_state  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 71 ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 72 ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 73 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd a3 94			call break_point_state  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 71 ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 72 ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 73 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd a3 94			call break_point_state  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 78 ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 78 ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd cb 8c			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 6f ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 71 ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 72 ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 73 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd a3 94			call break_point_state  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 84 ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 71 ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 72 ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 73 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd a3 94			call break_point_state  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 86 ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 86 ea			ld (store_page+2), a 
88e3 32 77 ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 71 ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 72 ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 73 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd a3 94			call break_point_state  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 6f ea			ld hl, (store_tmppageid) 
8905 11 84 ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd cb 8c			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 6f ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 71 ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 72 ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 73 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd a3 94			call break_point_state  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 84 ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 78 ea				ld a, (store_tmpid) 
894b 32 84 ea				ld (store_page), a   ; file id 
894e 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 85 ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 86 ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 71 ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 72 ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 73 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd a3 94			call break_point_state  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 6f ea			ld hl, (store_tmppageid) 
8985 11 84 ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 71 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 72 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 73 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd a3 94			call break_point_state  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 78 ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 84 ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 85 ea			ld de, store_page+1 
89c1 01 18 01			ld bc, STORE_BLOCK_LOG 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; information window 
8a06			 
8a06			; pass hl with 1st string to display 
8a06			; pass de with 2nd string to display 
8a06			 
8a06			info_panel: 
8a06 e5				push hl 
8a07			 
8a07 2a d2 eb			ld hl, (display_fb_active) 
8a0a e5				push hl    ; future de destination 
8a0b 21 b7 ed				ld hl, display_fb0 
8a0e 22 d2 eb				ld (display_fb_active), hl 
8a11			 
8a11			;	call clear_display 
8a11			 
8a11				if BASE_CPM 
8a11				ld a, '.' 
8a11				else 
8a11 3e a5			ld a, 165 
8a13				endif 
8a13 cd 7a 8a			call fill_display 
8a16			 
8a16			 
8a16 3e 55			ld a, display_row_3 + 5 
8a18 cd 88 8a			call str_at_display 
8a1b			 
8a1b e1				pop hl 
8a1c d1				pop de 
8a1d			 
8a1d e5				push hl 
8a1e			 
8a1e			 
8a1e 3e 2d			ld a, display_row_2 + 5 
8a20 cd 88 8a			call str_at_display 
8a23			 
8a23			 
8a23 cd 98 8a			call update_display 
8a26 cd 8c 9a			call next_page_prompt 
8a29 cd 75 8a			call clear_display 
8a2c			 
8a2c				 
8a2c 21 16 ed				ld hl, display_fb1 
8a2f 22 d2 eb				ld (display_fb_active), hl 
8a32 cd 98 8a			call update_display 
8a35			 
8a35 e1				pop hl 
8a36			 
8a36 c9				ret 
8a37			 
8a37			 
8a37			 
8a37			 
8a37			; TODO windowing? 
8a37			 
8a37			; TODO scroll line up 
8a37			 
8a37			scroll_up: 
8a37			 
8a37 e5				push hl 
8a38 d5				push de 
8a39 c5				push bc 
8a3a			 
8a3a				; get frame buffer  
8a3a			 
8a3a 2a d2 eb			ld hl, (display_fb_active) 
8a3d e5				push hl    ; future de destination 
8a3e			 
8a3e 11 28 00			ld  de, display_cols 
8a41 19				add hl, de 
8a42			 
8a42 d1				pop de 
8a43			 
8a43				;ex de, hl 
8a43 01 9f 00			ld bc, display_fb_len -1  
8a46			;if DEBUG_FORTH_WORDS 
8a46			;	DMARK "SCL" 
8a46			;	CALLMONITOR 
8a46			;endif	 
8a46 ed b0			ldir 
8a48			 
8a48				; wipe bottom row 
8a48			 
8a48			 
8a48 2a d2 eb			ld hl, (display_fb_active) 
8a4b 11 a0 00			ld de, display_cols*display_rows 
8a4e 19				add hl, de 
8a4f 06 28			ld b, display_cols 
8a51 3e 20			ld a, ' ' 
8a53			.scwipe: 
8a53 77				ld (hl), a 
8a54 2b				dec hl 
8a55 10 fc			djnz .scwipe 
8a57			 
8a57				;pop hl 
8a57			 
8a57 c1				pop bc 
8a58 d1				pop de 
8a59 e1				pop hl 
8a5a			 
8a5a c9				ret 
8a5b			 
8a5b			 
8a5b			;scroll_upo: 
8a5b			;	ld de, display_row_1 
8a5b			 ;	ld hl, display_row_2 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_2 
8a5b			 ;	ld hl, display_row_3 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_3 
8a5b			 ;	ld hl, display_row_4 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			 
8a5b			; TODO clear row 4 
8a5b			 
8a5b			;	ret 
8a5b			 
8a5b				 
8a5b			scroll_down: 
8a5b			 
8a5b e5				push hl 
8a5c d5				push de 
8a5d c5				push bc 
8a5e			 
8a5e				; get frame buffer  
8a5e			 
8a5e 2a d2 eb			ld hl, (display_fb_active) 
8a61			 
8a61 11 9f 00			ld de, display_fb_len - 1 
8a64 19				add hl, de 
8a65			 
8a65 e5			push hl    ; future de destination 
8a66			 
8a66 11 28 00			ld  de, display_cols 
8a69 ed 52			sbc hl, de 
8a6b			 
8a6b			 
8a6b d1				pop de 
8a6c			 
8a6c			;	ex de, hl 
8a6c 01 9f 00			ld bc, display_fb_len -1  
8a6f			 
8a6f			 
8a6f				 
8a6f			 
8a6f ed b0			ldir 
8a71			 
8a71				; wipe bottom row 
8a71			 
8a71			 
8a71			;	ld hl, (display_fb_active) 
8a71			;;	ld de, display_cols*display_rows 
8a71			;;	add hl, de 
8a71			;	ld b, display_cols 
8a71			;	ld a, ' ' 
8a71			;.scwiped: 
8a71			;	ld (hl), a 
8a71			;	dec hl 
8a71			;	djnz .scwiped 
8a71			 
8a71				;pop hl 
8a71			 
8a71 c1				pop bc 
8a72 d1				pop de 
8a73 e1				pop hl 
8a74			 
8a74 c9				ret 
8a75			;scroll_down: 
8a75			;	ld de, display_row_4 
8a75			;	ld hl, display_row_3 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_3 
8a75			; 	ld hl, display_row_2 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_2 
8a75			;	ld hl, display_row_1 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;;; TODO clear row 1 
8a75			;	ret 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			; clear active frame buffer 
8a75			 
8a75			clear_display: 
8a75 3e 20			ld a, ' ' 
8a77 c3 7a 8a			jp fill_display 
8a7a			 
8a7a			; fill active frame buffer with a char in A 
8a7a			 
8a7a			fill_display: 
8a7a 06 a0			ld b,display_fb_len 
8a7c 2a d2 eb			ld hl, (display_fb_active) 
8a7f 77			.fd1:	ld (hl),a 
8a80 23				inc hl 
8a81 10 fc			djnz .fd1 
8a83 23				inc hl 
8a84 3e 00			ld a,0 
8a86 77				ld (hl),a 
8a87			 
8a87			 
8a87 c9				ret 
8a88			; Write string (DE) at pos (A) to active frame buffer 
8a88			 
8a88 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8a8b 06 00					ld b,0 
8a8d 4f					ld c,a 
8a8e 09					add hl,bc 
8a8f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8a90 b7			            OR   A              ;Null terminator? 
8a91 c8			            RET  Z              ;Yes, so finished 
8a92 77					ld (hl),a 
8a93 23				inc hl 
8a94 13			            INC  DE             ;Point to next character 
8a95 18 f8		            JR   .sad1     ;Repeat 
8a97 c9					ret 
8a98			 
8a98			; using current frame buffer write to physical display 
8a98			 
8a98			update_display: 
8a98 e5				push hl 
8a99 2a d2 eb			ld hl, (display_fb_active) 
8a9c cd ba df			call write_display 
8a9f e1				pop hl 
8aa0 c9				ret 
8aa1			 
8aa1			; TODO scrolling 
8aa1			 
8aa1			 
8aa1			; move cursor right one char 
8aa1			cursor_right: 
8aa1			 
8aa1				; TODO shift right 
8aa1				; TODO if beyond max col 
8aa1				; TODO       cursor_next_line 
8aa1			 
8aa1 c9				ret 
8aa2			 
8aa2			 
8aa2			cursor_next_line: 
8aa2				; TODO first char 
8aa2				; TODO line down 
8aa2				; TODO if past last row 
8aa2				; TODO    scroll up 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			cursor_left: 
8aa3				; TODO shift left 
8aa3				; TODO if beyond left  
8aa3				; TODO     cursor prev line 
8aa3				 
8aa3 c9				ret 
8aa4			 
8aa4			cursor_prev_line: 
8aa4				; TODO last char 
8aa4				; TODO line up 
8aa4				; TODO if past first row 
8aa4				; TODO   scroll down 
8aa4			 
8aa4 c9				ret 
8aa5			 
8aa5			 
8aa5			cout: 
8aa5				; A - char 
8aa5 c9				ret 
8aa6			 
8aa6			 
8aa6			; Display a menu and allow item selection (optional toggle items) 
8aa6			; 
8aa6			; format: 
8aa6			; hl pointer to word array with zero term for items 
8aa6			; e.g.    db item1 
8aa6			;         db .... 
8aa6			;         db 0 
8aa6			; 
8aa6			; a = starting menu item  
8aa6			; 
8aa6			; de = pointer item toggle array   (todo) 
8aa6			; 
8aa6			; returns item selected in a 1-... 
8aa6			; returns 0 if back button pressed 
8aa6			; 
8aa6			; NOTE: Uses system frame buffer to display 
8aa6			; 
8aa6			; LEFT, Q = go back 
8aa6			; RIGHT, SPACE, CR = select 
8aa6			; UP, A - Up 
8aa6			; DOWN, Z - Down 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			menu: 
8aa6			 
8aa6					; keep array pointer 
8aa6			 
8aa6 22 7d ea				ld (store_tmp1), hl 
8aa9 32 7b ea				ld (store_tmp2), a 
8aac			 
8aac					; check for key bounce 
8aac			 
8aac			if BASE_KEV 
8aac			 
8aac			.mbounce:	call cin 
8aac					cp 0 
8aac					jr nz, .mbounce 
8aac			endif 
8aac					; for ease use ex 
8aac			 
8aac					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8aac 21 b7 ed				ld hl, display_fb0 
8aaf 22 d2 eb				ld (display_fb_active), hl 
8ab2			 
8ab2 cd 75 8a		.mloop:		call clear_display 
8ab5 cd 98 8a				call update_display 
8ab8			 
8ab8					; draw selection id '>' at 1 
8ab8			 
8ab8					; init start of list display 
8ab8			 
8ab8 3e 05				ld a, 5 
8aba 32 79 ea				ld (store_tmp3), a   ; display row count 
8abd 3a 7b ea				ld a,( store_tmp2) 
8ac0 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8ac3			 
8ac3					 
8ac3			.mitem:	 
8ac3			 
8ac3			 
8ac3 3a 7c ea				ld a,(store_tmp2+1) 
8ac6 6f					ld l, a 
8ac7 26 00				ld h, 0 
8ac9 29					add hl, hl 
8aca ed 5b 7d ea			ld de, (store_tmp1) 
8ace 19					add hl, de 
8acf 7e					ld a, (hl) 
8ad0 23					inc hl 
8ad1 66					ld h,(hl) 
8ad2 6f					ld l, a 
8ad3			 
8ad3 cd cb 8c				call ishlzero 
8ad6 28 1a				jr z, .mdone 
8ad8			 
8ad8 eb					ex de, hl 
8ad9 3a 79 ea				ld a, (store_tmp3) 
8adc cd 88 8a				call str_at_display 
8adf					 
8adf			 
8adf					; next item 
8adf 3a 7c ea				ld a, (store_tmp2+1) 
8ae2 3c					inc a 
8ae3 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8ae6			 
8ae6			 		; next row 
8ae6			 
8ae6 3a 79 ea				ld a, (store_tmp3) 
8ae9 c6 28				add display_cols 
8aeb 32 79 ea				ld (store_tmp3), a 
8aee			 
8aee					; at end of screen? 
8aee			 
8aee fe 10				cp display_rows*4 
8af0 20 d1				jr nz, .mitem 
8af2			 
8af2			 
8af2			.mdone: 
8af2 cd cb 8c				call ishlzero 
8af5 28 08				jr z, .nodn 
8af7			 
8af7 3e 78				ld a, display_row_4 
8af9 11 78 8b				ld de, .mdown 
8afc cd 88 8a				call str_at_display 
8aff			 
8aff					; draw options to fill the screens with active item on line 1 
8aff					; if current option is 2 or more then display ^ in top 
8aff			 
8aff 3a 7b ea		.nodn:		ld a, (store_tmp2) 
8b02 fe 00				cp 0 
8b04 28 08				jr z, .noup 
8b06			 
8b06 3e 00				ld a, 0 
8b08 11 76 8b				ld de, .mup 
8b0b cd 88 8a				call str_at_display 
8b0e			 
8b0e 3e 02		.noup:		ld a, 2 
8b10 11 74 8b				ld de, .msel 
8b13 cd 88 8a				call str_at_display 
8b16			 
8b16					; if current option + 1 is not null then display V in bottom 
8b16					; get key 
8b16 cd 98 8a				call update_display 
8b19			 
8b19			 
8b19					; handle key 
8b19			 
8b19 cd 46 e0				call cin_wait 
8b1c			 
8b1c fe 05				cp KEY_UP 
8b1e 28 2b				jr z, .mgoup 
8b20 fe 61				cp 'a' 
8b22 28 27				jr z, .mgoup 
8b24 fe 0a				cp KEY_DOWN 
8b26 28 32				jr z, .mgod 
8b28 fe 7a				cp 'z' 
8b2a 28 2e				jr z, .mgod 
8b2c fe 20				cp ' ' 
8b2e 28 34				jr z, .goend 
8b30 fe 0c				cp KEY_RIGHT 
8b32 28 30				jr z, .goend 
8b34 fe 0d				cp KEY_CR 
8b36 28 2c				jr z, .goend 
8b38 fe 71				cp 'q' 
8b3a 28 0b				jr z, .goback 
8b3c			 
8b3c fe 0b				cp KEY_LEFT 
8b3e 28 07				jr z, .goback 
8b40 fe 08				cp KEY_BS 
8b42 28 03				jr z, .goback 
8b44 c3 b2 8a				jp .mloop 
8b47			 
8b47			.goback: 
8b47 3e 00			ld a, 0 
8b49 18 1d			jr .goend2 
8b4b			 
8b4b				; move up one 
8b4b			.mgoup: 
8b4b 3a 7b ea				ld a, (store_tmp2) 
8b4e fe 00				cp 0 
8b50 ca b2 8a				jp z, .mloop 
8b53 3d					dec a 
8b54 32 7b ea				ld (store_tmp2), a 
8b57 c3 b2 8a				jp .mloop 
8b5a			 
8b5a				; move down one 
8b5a			.mgod: 
8b5a 3a 7b ea				ld a, (store_tmp2) 
8b5d 3c					inc a 
8b5e 32 7b ea				ld (store_tmp2), a 
8b61 c3 b2 8a				jp .mloop 
8b64			 
8b64			 
8b64			.goend: 
8b64					; get selected item number 
8b64			 
8b64 3a 7b ea				ld a, (store_tmp2) 
8b67 3c					inc a 
8b68			 
8b68			.goend2: 
8b68 f5					push af 
8b69			 
8b69					; restore active fb 
8b69					; TODO BUG assumes fb1 
8b69			 
8b69 21 16 ed				ld hl, display_fb1 
8b6c 22 d2 eb				ld (display_fb_active), hl 
8b6f			 
8b6f					; restore main regs 
8b6f			 
8b6f			 
8b6f cd 98 8a				call update_display 
8b72			 
8b72 f1					pop af 
8b73			 
8b73 c9				ret 
8b74			 
8b74 .. 00		.msel:   db ">",0 
8b76 .. 00		.mup:   db "^",0 
8b78 .. 00		.mdown:   db "v",0 
8b7a			 
8b7a			 
8b7a			; eof 
8b7a			 
# End of file firmware_display.asm
8b7a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8b7a			; random number generators 
8b7a			 
8b7a			 
8b7a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8b7a			 
8b7a			 
8b7a			;-----> Generate a random number 
8b7a			; output a=answer 0<=a<=255 
8b7a			; all registers are preserved except: af 
8b7a			random: 
8b7a e5			        push    hl 
8b7b d5			        push    de 
8b7c 2a b4 eb		        ld      hl,(randData) 
8b7f ed 5f		        ld      a,r 
8b81 57			        ld      d,a 
8b82 5e			        ld      e,(hl) 
8b83 19			        add     hl,de 
8b84 85			        add     a,l 
8b85 ac			        xor     h 
8b86 22 b4 eb		        ld      (randData),hl 
8b89 d1			        pop     de 
8b8a e1			        pop     hl 
8b8b c9			        ret 
8b8c			 
8b8c			 
8b8c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8b8c			 
8b8c			 
8b8c			 
8b8c			;------LFSR------ 
8b8c			;James Montelongo 
8b8c			;optimized by Spencer Putt 
8b8c			;out: 
8b8c			; a = 8 bit random number 
8b8c			RandLFSR: 
8b8c 21 ba eb		        ld hl,LFSRSeed+4 
8b8f 5e			        ld e,(hl) 
8b90 23			        inc hl 
8b91 56			        ld d,(hl) 
8b92 23			        inc hl 
8b93 4e			        ld c,(hl) 
8b94 23			        inc hl 
8b95 7e			        ld a,(hl) 
8b96 47			        ld b,a 
8b97 cb 13		        rl e  
8b99 cb 12			rl d 
8b9b cb 11		        rl c  
8b9d 17				rla 
8b9e cb 13		        rl e  
8ba0 cb 12			rl d 
8ba2 cb 11		        rl c  
8ba4 17				rla 
8ba5 cb 13		        rl e  
8ba7 cb 12			rl d 
8ba9 cb 11		        rl c  
8bab 17				rla 
8bac 67			        ld h,a 
8bad cb 13		        rl e  
8baf cb 12			rl d 
8bb1 cb 11		        rl c  
8bb3 17				rla 
8bb4 a8			        xor b 
8bb5 cb 13		        rl e  
8bb7 cb 12			rl d 
8bb9 ac			        xor h 
8bba a9			        xor c 
8bbb aa			        xor d 
8bbc 21 bc eb		        ld hl,LFSRSeed+6 
8bbf 11 bd eb		        ld de,LFSRSeed+7 
8bc2 01 07 00		        ld bc,7 
8bc5 ed b8		        lddr 
8bc7 12			        ld (de),a 
8bc8 c9			        ret 
8bc9			 
8bc9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bc9			 
8bc9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bc9			 
8bc9			 
8bc9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bc9			 
8bc9			prng16: 
8bc9			;Inputs: 
8bc9			;   (seed1) contains a 16-bit seed value 
8bc9			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bc9			;Outputs: 
8bc9			;   HL is the result 
8bc9			;   BC is the result of the LCG, so not that great of quality 
8bc9			;   DE is preserved 
8bc9			;Destroys: 
8bc9			;   AF 
8bc9			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bc9			;160cc 
8bc9			;26 bytes 
8bc9 2a ae eb		    ld hl,(seed1) 
8bcc 44			    ld b,h 
8bcd 4d			    ld c,l 
8bce 29			    add hl,hl 
8bcf 29			    add hl,hl 
8bd0 2c			    inc l 
8bd1 09			    add hl,bc 
8bd2 22 ae eb		    ld (seed1),hl 
8bd5 2a ac eb		    ld hl,(seed2) 
8bd8 29			    add hl,hl 
8bd9 9f			    sbc a,a 
8bda e6 2d		    and %00101101 
8bdc ad			    xor l 
8bdd 6f			    ld l,a 
8bde 22 ac eb		    ld (seed2),hl 
8be1 09			    add hl,bc 
8be2 c9			    ret 
8be3			 
8be3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8be3			 
8be3			rand32: 
8be3			;Inputs: 
8be3			;   (seed1_0) holds the lower 16 bits of the first seed 
8be3			;   (seed1_1) holds the upper 16 bits of the first seed 
8be3			;   (seed2_0) holds the lower 16 bits of the second seed 
8be3			;   (seed2_1) holds the upper 16 bits of the second seed 
8be3			;   **NOTE: seed2 must be non-zero 
8be3			;Outputs: 
8be3			;   HL is the result 
8be3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8be3			;Destroys: 
8be3			;   AF 
8be3			;Tested and passes all CAcert tests 
8be3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8be3			;it has a period of 18,446,744,069,414,584,320 
8be3			;roughly 18.4 quintillion. 
8be3			;LFSR taps: 0,2,6,7  = 11000101 
8be3			;291cc 
8be3			;seed1_0=$+1 
8be3			;    ld hl,12345 
8be3			;seed1_1=$+1 
8be3			;    ld de,6789 
8be3			;    ld b,h 
8be3			;    ld c,l 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    inc l 
8be3			;    add hl,bc 
8be3			;    ld (seed1_0),hl 
8be3			;    ld hl,(seed1_1) 
8be3			;    adc hl,de 
8be3			;    ld (seed1_1),hl 
8be3			;    ex de,hl 
8be3			;seed2_0=$+1 
8be3			;    ld hl,9876 
8be3			;seed2_1=$+1 
8be3			;    ld bc,54321 
8be3			;    add hl,hl \ rl c \ rl b 
8be3			;    ld (seed2_1),bc 
8be3			;    sbc a,a 
8be3			;    and %11000101 
8be3			;    xor l 
8be3			;    ld l,a 
8be3			;    ld (seed2_0),hl 
8be3			;    ex de,hl 
8be3			;    add hl,bc 
8be3			;    ret 
8be3			; 
8be3			 
8be3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8be3			; 20 bytes, 86 cycles (excluding ret) 
8be3			 
8be3			; returns   hl = pseudorandom number 
8be3			; corrupts   a 
8be3			 
8be3			; generates 16-bit pseudorandom numbers with a period of 65535 
8be3			; using the xorshift method: 
8be3			 
8be3			; hl ^= hl << 7 
8be3			; hl ^= hl >> 9 
8be3			; hl ^= hl << 8 
8be3			 
8be3			; some alternative shift triplets which also perform well are: 
8be3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8be3			 
8be3			;  org 32768 
8be3			 
8be3			xrnd: 
8be3 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
8be6 3e 00		  ld a,0 
8be8 bd			  cp l 
8be9 20 02		  jr nz, .xrnd1 
8beb 2e 01		  ld l, 1 
8bed			.xrnd1: 
8bed			 
8bed 7c			  ld a,h 
8bee 1f			  rra 
8bef 7d			  ld a,l 
8bf0 1f			  rra 
8bf1 ac			  xor h 
8bf2 67			  ld h,a 
8bf3 7d			  ld a,l 
8bf4 1f			  rra 
8bf5 7c			  ld a,h 
8bf6 1f			  rra 
8bf7 ad			  xor l 
8bf8 6f			  ld l,a 
8bf9 ac			  xor h 
8bfa 67			  ld h,a 
8bfb			 
8bfb 22 b2 eb		  ld (xrandc),hl 
8bfe			 
8bfe c9			  ret 
8bff			;  
8bff			 
8bff			 
8bff			;;;; int maths 
8bff			 
8bff			; https://map.grauw.nl/articles/mult_div_shifts.php 
8bff			; Divide 16-bit values (with 16-bit result) 
8bff			; In: Divide BC by divider DE 
8bff			; Out: BC = result, HL = rest 
8bff			; 
8bff			Div16: 
8bff 21 00 00		    ld hl,0 
8c02 78			    ld a,b 
8c03 06 08		    ld b,8 
8c05			Div16_Loop1: 
8c05 17			    rla 
8c06 ed 6a		    adc hl,hl 
8c08 ed 52		    sbc hl,de 
8c0a 30 01		    jr nc,Div16_NoAdd1 
8c0c 19			    add hl,de 
8c0d			Div16_NoAdd1: 
8c0d 10 f6		    djnz Div16_Loop1 
8c0f 17			    rla 
8c10 2f			    cpl 
8c11 47			    ld b,a 
8c12 79			    ld a,c 
8c13 48			    ld c,b 
8c14 06 08		    ld b,8 
8c16			Div16_Loop2: 
8c16 17			    rla 
8c17 ed 6a		    adc hl,hl 
8c19 ed 52		    sbc hl,de 
8c1b 30 01		    jr nc,Div16_NoAdd2 
8c1d 19			    add hl,de 
8c1e			Div16_NoAdd2: 
8c1e 10 f6		    djnz Div16_Loop2 
8c20 17			    rla 
8c21 2f			    cpl 
8c22 41			    ld b,c 
8c23 4f			    ld c,a 
8c24 c9			ret 
8c25			 
8c25			 
8c25			;http://z80-heaven.wikidot.com/math 
8c25			; 
8c25			;Inputs: 
8c25			;     DE and A are factors 
8c25			;Outputs: 
8c25			;     A is not changed 
8c25			;     B is 0 
8c25			;     C is not changed 
8c25			;     DE is not changed 
8c25			;     HL is the product 
8c25			;Time: 
8c25			;     342+6x 
8c25			; 
8c25			Mult16: 
8c25			 
8c25 06 08		     ld b,8          ;7           7 
8c27 21 00 00		     ld hl,0         ;10         10 
8c2a 29			       add hl,hl     ;11*8       88 
8c2b 07			       rlca          ;4*8        32 
8c2c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c2e 19			         add hl,de   ;--         -- 
8c2f 10 f9		       djnz $-5      ;13*7+8     99 
8c31 c9			ret 
8c32			 
8c32			; 
8c32			; Square root of 16-bit value 
8c32			; In:  HL = value 
8c32			; Out:  D = result (rounded down) 
8c32			; 
8c32			;Sqr16: 
8c32			;    ld de,#0040 
8c32			;    ld a,l 
8c32			;    ld l,h 
8c32			;    ld h,d 
8c32			;    or a 
8c32			;    ld b,8 
8c32			;Sqr16_Loop: 
8c32			;    sbc hl,de 
8c32			;    jr nc,Sqr16_Skip 
8c32			;    add hl,de 
8c32			;Sqr16_Skip: 
8c32			;    ccf 
8c32			;    rl d 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    djnz Sqr16_Loop 
8c32			;    ret 
8c32			; 
8c32			; 
8c32			; Divide 8-bit values 
8c32			; In: Divide E by divider C 
8c32			; Out: A = result, B = rest 
8c32			; 
8c32			Div8: 
8c32 af			    xor a 
8c33 06 08		    ld b,8 
8c35			Div8_Loop: 
8c35 cb 13		    rl e 
8c37 17			    rla 
8c38 91			    sub c 
8c39 30 01		    jr nc,Div8_NoAdd 
8c3b 81			    add a,c 
8c3c			Div8_NoAdd: 
8c3c 10 f7		    djnz Div8_Loop 
8c3e 47			    ld b,a 
8c3f 7b			    ld a,e 
8c40 17			    rla 
8c41 2f			    cpl 
8c42 c9			    ret 
8c43			 
8c43			; 
8c43			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c43			; In: Multiply A with DE 
8c43			; Out: HL = result 
8c43			; 
8c43			Mult12U: 
8c43 2e 00		    ld l,0 
8c45 87			    add a,a 
8c46 30 01		    jr nc,Mult12U_NoAdd0 
8c48 19			    add hl,de 
8c49			Mult12U_NoAdd0: 
8c49 29			    add hl,hl 
8c4a 87			    add a,a 
8c4b 30 01		    jr nc,Mult12U_NoAdd1 
8c4d 19			    add hl,de 
8c4e			Mult12U_NoAdd1: 
8c4e 29			    add hl,hl 
8c4f 87			    add a,a 
8c50 30 01		    jr nc,Mult12U_NoAdd2 
8c52 19			    add hl,de 
8c53			Mult12U_NoAdd2: 
8c53 29			    add hl,hl 
8c54 87			    add a,a 
8c55 30 01		    jr nc,Mult12U_NoAdd3 
8c57 19			    add hl,de 
8c58			Mult12U_NoAdd3: 
8c58 29			    add hl,hl 
8c59 87			    add a,a 
8c5a 30 01		    jr nc,Mult12U_NoAdd4 
8c5c 19			    add hl,de 
8c5d			Mult12U_NoAdd4: 
8c5d 29			    add hl,hl 
8c5e 87			    add a,a 
8c5f 30 01		    jr nc,Mult12U_NoAdd5 
8c61 19			    add hl,de 
8c62			Mult12U_NoAdd5: 
8c62 29			    add hl,hl 
8c63 87			    add a,a 
8c64 30 01		    jr nc,Mult12U_NoAdd6 
8c66 19			    add hl,de 
8c67			Mult12U_NoAdd6: 
8c67 29			    add hl,hl 
8c68 87			    add a,a 
8c69 d0			    ret nc 
8c6a 19			    add hl,de 
8c6b c9			    ret 
8c6c			 
8c6c			; 
8c6c			; Multiply 8-bit value with a 16-bit value (right rotating) 
8c6c			; In: Multiply A with DE 
8c6c			;      Put lowest value in A for most efficient calculation 
8c6c			; Out: HL = result 
8c6c			; 
8c6c			Mult12R: 
8c6c 21 00 00		    ld hl,0 
8c6f			Mult12R_Loop: 
8c6f cb 3f		    srl a 
8c71 30 01		    jr nc,Mult12R_NoAdd 
8c73 19			    add hl,de 
8c74			Mult12R_NoAdd: 
8c74 cb 23		    sla e 
8c76 cb 12		    rl d 
8c78 b7			    or a 
8c79 c2 6f 8c		    jp nz,Mult12R_Loop 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 16-bit values (with 32-bit result) 
8c7d			; In: Multiply BC with DE 
8c7d			; Out: BCHL = result 
8c7d			; 
8c7d			Mult32: 
8c7d 79			    ld a,c 
8c7e 48			    ld c,b 
8c7f 21 00 00		    ld hl,0 
8c82 06 10		    ld b,16 
8c84			Mult32_Loop: 
8c84 29			    add hl,hl 
8c85 17			    rla 
8c86 cb 11		    rl c 
8c88 30 07		    jr nc,Mult32_NoAdd 
8c8a 19			    add hl,de 
8c8b ce 00		    adc a,0 
8c8d d2 91 8c		    jp nc,Mult32_NoAdd 
8c90 0c			    inc c 
8c91			Mult32_NoAdd: 
8c91 10 f1		    djnz Mult32_Loop 
8c93 41			    ld b,c 
8c94 4f			    ld c,a 
8c95 c9			    ret 
8c96			 
8c96			 
8c96			 
8c96			; 
8c96			; Multiply 8-bit values 
8c96			; In:  Multiply H with E 
8c96			; Out: HL = result 
8c96			; 
8c96			Mult8: 
8c96 16 00		    ld d,0 
8c98 6a			    ld l,d 
8c99 06 08		    ld b,8 
8c9b			Mult8_Loop: 
8c9b 29			    add hl,hl 
8c9c 30 01		    jr nc,Mult8_NoAdd 
8c9e 19			    add hl,de 
8c9f			Mult8_NoAdd: 
8c9f 10 fa		    djnz Mult8_Loop 
8ca1 c9			    ret 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			;;http://z80-heaven.wikidot.com/math 
8ca2			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ca2			; 
8ca2			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ca2			;     ld a,16        ;7 
8ca2			;     ld hl,0        ;10 
8ca2			;     jp $+5         ;10 
8ca2			;.DivLoop: 
8ca2			;       add hl,bc    ;-- 
8ca2			;       dec a        ;64 
8ca2			;       jr z,.DivLoopEnd        ;86 
8ca2			; 
8ca2			;       sla e        ;128 
8ca2			;       rl d         ;128 
8ca2			;       adc hl,hl    ;240 
8ca2			;       sbc hl,bc    ;240 
8ca2			;       jr nc,.DivLoop ;23|21 
8ca2			;       inc e        ;-- 
8ca2			;       jp .DivLoop+1 
8ca2			; 
8ca2			;.DivLoopEnd: 
8ca2			 
8ca2			;HL_Div_C: 
8ca2			;Inputs: 
8ca2			;     HL is the numerator 
8ca2			;     C is the denominator 
8ca2			;Outputs: 
8ca2			;     A is the remainder 
8ca2			;     B is 0 
8ca2			;     C is not changed 
8ca2			;     DE is not changed 
8ca2			;     HL is the quotient 
8ca2			; 
8ca2			;       ld b,16 
8ca2			;       xor a 
8ca2			;         add hl,hl 
8ca2			;         rla 
8ca2			;         cp c 
8ca2			;         jr c,$+4 
8ca2			;           inc l 
8ca2			;           sub c 
8ca2			;         djnz $-7 
8ca2			 
8ca2			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ca2			 
8ca2			addatohl: 
8ca2 85			    add   a, l    ; A = A+L 
8ca3 6f			    ld    l, a    ; L = A+L 
8ca4 8c			    adc   a, h    ; A = A+L+H+carry 
8ca5 95			    sub   l       ; A = H+carry 
8ca6 67			    ld    h, a    ; H = H+carry 
8ca7 c9			ret 
8ca8			 
8ca8			addatode: 
8ca8 83			    add   a, e    ; A = A+L 
8ca9 5f			    ld    e, a    ; L = A+L 
8caa 8a			    adc   a, d    ; A = A+L+H+carry 
8cab 93			    sub   e       ; A = H+carry 
8cac 57			    ld    d, a    ; H = H+carry 
8cad c9			ret 
8cae			 
8cae			 
8cae			addatobc: 
8cae 81			    add   a, c    ; A = A+L 
8caf 4f			    ld    c, a    ; L = A+L 
8cb0 88			    adc   a, b    ; A = A+L+H+carry 
8cb1 91			    sub   c       ; A = H+carry 
8cb2 47			    ld    b, a    ; H = H+carry 
8cb3 c9			ret 
8cb4			 
8cb4			subafromhl: 
8cb4			   ; If A=0 do nothing 
8cb4			    ; Otherwise flip A's sign. Since 
8cb4			    ; the upper byte becomes -1, also 
8cb4			    ; substract 1 from H. 
8cb4 ed 44		    neg 
8cb6 ca bf 8c		    jp    z, Skip 
8cb9 25			    dec   h 
8cba			     
8cba			    ; Now add the low byte as usual 
8cba			    ; Two's complement takes care of 
8cba			    ; ensuring the result is correct 
8cba 85			    add   a, l 
8cbb 6f			    ld    l, a 
8cbc 8c			    adc   a, h 
8cbd 95			    sub   l 
8cbe 67			    ld    h, a 
8cbf			Skip: 
8cbf c9				ret 
8cc0			 
8cc0			 
8cc0			; compare hl and de 
8cc0			; returns:  
8cc0			; if hl = de, z=1, s=0, c0=0 
8cc0			; if hl > de, z=0, s=0, c=0 
8cc0			; if hl < de, z=0, s=1, c=1 
8cc0			cmp16:	 
8cc0 b7				or a 
8cc1 ed 52			sbc hl,de 
8cc3 e0				ret po 
8cc4 7c				ld a,h 
8cc5 1f				rra 
8cc6 ee 40			xor 01000000B 
8cc8 37				scf 
8cc9 8f				adc a,a 
8cca c9				ret 
8ccb			 
8ccb			 
8ccb			; test if hl contains zero   - A is destroyed 
8ccb			 
8ccb			ishlzero:    
8ccb b7				or a     ; reset flags 
8ccc 7c				ld a, h 
8ccd b5				or l        	 
8cce			 
8cce c9				ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			 
8ccf			if FORTH_ENABLE_FLOATMATH 
8ccf			;include "float/bbcmath.z80" 
8ccf			include "float/lpfpcalc.asm" 
8ccf			endif 
8ccf			 
8ccf			 
8ccf			; eof 
8ccf			 
# End of file firmware_maths.asm
8ccf			include "firmware_strings.asm"   ; string handling  
8ccf			 
8ccf			 
8ccf			; TODO string len 
8ccf			; input text string, end on cr with zero term 
8ccf			; a offset into frame buffer to start prompt 
8ccf			; d is max length 
8ccf			; e is display size TODO 
8ccf			; c is current cursor position 
8ccf			; hl is ptr to where string will be stored 
8ccf			 
8ccf			 
8ccf			; TODO check limit of buffer for new inserts 
8ccf			; TODO check insert does not push beyond buffer 
8ccf			; TODO scroll in a limited display area 
8ccf			; TODO scroll whole screen on page wrap 
8ccf			 
8ccf			 
8ccf			; TODO handle KEY_PREVWORD 
8ccf			; TODO handle KEY_NEXTWORD 
8ccf			; TODO handle KEY_HOME 
8ccf			; TODO handle KEY_END 
8ccf			; TODO use LCD cursor? 
8ccf			 
8ccf 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8cd2 81					add c 
8cd3 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8cd6 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8cd9 79					ld a, c 
8cda cd a2 8c				call addatohl 
8cdd 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ce0 7a					ld a,d 
8ce1 32 6c ee			        ld (input_size), a       ; save length of input area 
8ce4 79					ld a, c 
8ce5 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8ce8 7b					ld a,e 
8ce9 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8cec					 
8cec					 
8cec			 
8cec			;		ld a,(input_ptr) 
8cec			;		ld (input_under_cursor),a 	; save what is under the cursor 
8cec			 
8cec			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8cec					; init cursor shape if not set by the cin routines 
8cec 21 ca eb				ld hl, cursor_shape 
8cef 3e ff				ld a, 255 
8cf1 77					ld (hl), a 
8cf2 23					inc hl 
8cf3 3e 00				ld a, 0 
8cf5 77					ld (hl), a 
8cf6			 
8cf6 3e 0f				ld a, CUR_BLINK_RATE 
8cf8 32 66 ee				ld (input_cur_flash), a 
8cfb 3e 01				ld a, 1 
8cfd 32 65 ee				ld (input_cur_onoff),a 
8d00			 
8d00			;	if DEBUG_INPUT 
8d00			;		push af 
8d00			;		ld a, 'I' 
8d00			;		ld (debug_mark),a 
8d00			;		pop af 
8d00			;		CALLMONITOR 
8d00			;	endif 
8d00			.is1:		; main entry loop 
8d00			 
8d00			 
8d00			 
8d00					; pause 1ms 
8d00			 
8d00 3e 01				ld a, 1 
8d02 cd d7 89				call aDelayInMS 
8d05			 
8d05					; dec flash counter 
8d05 3a 66 ee				ld a, (input_cur_flash) 
8d08 3d					dec a 
8d09 32 66 ee				ld (input_cur_flash), a 
8d0c fe 00				cp 0 
8d0e 20 0d				jr nz, .nochgstate 
8d10			 
8d10			 
8d10					; change state 
8d10 3a 65 ee				ld a,(input_cur_onoff) 
8d13 ed 44				neg 
8d15 32 65 ee				ld (input_cur_onoff),a 
8d18			 
8d18			 
8d18					; reset on change of state 
8d18 3e 0f				ld a, CUR_BLINK_RATE 
8d1a 32 66 ee				ld (input_cur_flash), a 
8d1d			 
8d1d			.nochgstate: 
8d1d					 
8d1d					 
8d1d			 
8d1d					; display cursor  
8d1d			 
8d1d			;		ld hl, (input_start) 
8d1d			;		ld a, (input_cursor) 
8d1d			;		call addatohl 
8d1d			 
8d1d					; get char under cursor and replace with cursor 
8d1d 2a 6f ee		ld hl, (input_ptr) 
8d20			;		ld a, (hl) 
8d20			;		ld (input_under_cursor),a 
8d20			;		ld a, '_' 
8d20			;		ld (hl), a 
8d20			 
8d20					; display string 
8d20			 
8d20 ed 5b 6d ee			ld de, (input_start) 
8d24 3a 6a ee				ld a, (input_at_pos) 
8d27 cd 88 8a				call str_at_display 
8d2a			;	        call update_display 
8d2a			 
8d2a					; find place to put the cursor 
8d2a			;		add h 
8d2a			;		ld l, display_row_1 
8d2a			;		sub l 
8d2a			; (input_at_pos) 
8d2a					;ld c, a 
8d2a			;		ld a, (input_cursor) 
8d2a			;		ld l, (input_at_pos) 
8d2a			;		;ld b, h 
8d2a			;		add l 
8d2a			;		ld (input_at_cursor),a 
8d2a					;ld l,h 
8d2a			 
8d2a			;		ld h, 0 
8d2a			;		ld l,(input_at_pos) 
8d2a			;		ld a, (input_cursor) 
8d2a			;		call addatohl 
8d2a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d2a			;		call subafromhl 
8d2a			;		ld a,l 
8d2a			;		ld (input_at_cursor), a 
8d2a			 
8d2a				if DEBUG_INPUT 
8d2a					ld a, (hardware_diag) 
8d2a					cp 0 
8d2a					jr z, .skip_input_diag 
8d2a			 
8d2a					ld a,(input_at_pos) 
8d2a					ld hl, LFSRSeed 
8d2a					call hexout 
8d2a					ld a, (input_cursor) 
8d2a					ld hl, LFSRSeed+2 
8d2a					call hexout 
8d2a					ld a,(input_at_cursor) 
8d2a					ld hl, LFSRSeed+4 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_onoff) 
8d2a					ld hl, LFSRSeed+6 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_flash) 
8d2a					ld hl, LFSRSeed+8 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_len) 
8d2a					ld hl, LFSRSeed+10 
8d2a					call hexout 
8d2a					ld hl, LFSRSeed+12 
8d2a					ld a, 0 
8d2a					ld (hl),a 
8d2a					ld a, display_row_4 
8d2a					ld de, LFSRSeed 
8d2a					call str_at_display 
8d2a					.skip_input_diag: 
8d2a				endif 
8d2a			 
8d2a					; decide on if we are showing the cursor this time round 
8d2a			 
8d2a 3a 65 ee				ld a, (input_cur_onoff) 
8d2d fe ff				cp 255 
8d2f 28 13				jr z, .skipcur 
8d31			 
8d31			 
8d31 3a 68 ee				ld a,(input_at_cursor) 
8d34 11 ca eb				ld de, cursor_shape 
8d37 cd 88 8a				call str_at_display 
8d3a			 
8d3a					; save length of current input string 
8d3a 2a 6d ee				ld hl, (input_start) 
8d3d cd 00 91				call strlenz 
8d40 7d					ld a,l 
8d41 32 60 ee				ld (input_len),a 
8d44			 
8d44			.skipcur: 
8d44			 
8d44 cd 98 8a			        call update_display 
8d47					 
8d47			 
8d47			 
8d47					; wait 
8d47				 
8d47					; TODO loop without wait to flash the cursor and char under cursor	 
8d47 cd 4c e0				call cin    ; _wait 
8d4a			 
8d4a fe 00				cp 0 
8d4c ca 00 8d				jp z, .is1 
8d4f			 
8d4f					; get ptr to char to input into 
8d4f			 
8d4f 4f					ld c,a 
8d50 2a 6d ee				ld hl, (input_start) 
8d53 3a 5b ee				ld a, (input_cursor) 
8d56 cd a2 8c				call addatohl 
8d59 22 6f ee				ld (input_ptr), hl 
8d5c 79					ld a,c 
8d5d			 
8d5d					; replace char under cursor 
8d5d			 
8d5d			;		ld hl, (input_ptr) 
8d5d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d5d			;		ld (hl), a 
8d5d			 
8d5d			;	if DEBUG_INPUT 
8d5d			;		push af 
8d5d			;		ld a, 'i' 
8d5d			;		ld (debug_mark),a 
8d5d			;		pop af 
8d5d			;		CALLMONITOR 
8d5d			;	endif 
8d5d fe 0e				cp KEY_HOME 
8d5f 20 0e				jr nz, .iske 
8d61			 
8d61 3a 6a ee				ld a, (input_at_pos) 
8d64 32 68 ee				ld (input_at_cursor),a 
8d67 3e 00				ld a, 0 
8d69 32 5b ee				ld (input_cursor), a 
8d6c c3 00 8d				jp .is1 
8d6f					 
8d6f fe 0f		.iske:		cp KEY_END 
8d71 20 03				jr nz, .isknw 
8d73 c3 00 8d				jp .is1 
8d76			 
8d76 fe 06		.isknw:		cp KEY_NEXTWORD 
8d78 20 1b				jr nz, .iskpw 
8d7a			 
8d7a 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8d7d 7e					ld a,(hl)	 
8d7e fe 00				cp 0 
8d80 ca 00 8d				jp z, .is1    ; end of string 
8d83 fe 20				cp ' ' 
8d85 ca 00 8d				jp z, .is1    ; end of word 
8d88 23					inc hl 
8d89 22 6f ee				ld (input_ptr), hl 
8d8c 3a 68 ee				ld a, (input_at_cursor) 
8d8f 3c					inc a 
8d90 32 68 ee				ld (input_at_cursor), a 
8d93 18 e5				jr .isknwm 
8d95			 
8d95 fe 07		.iskpw:		cp KEY_PREVWORD 
8d97 20 1b				jr nz, .iskl 
8d99			.iskpwm:	 
8d99 2a 6f ee				ld hl, (input_ptr) 
8d9c 7e					ld a,(hl)	 
8d9d fe 00				cp 0  
8d9f ca 00 8d				jp z, .is1    ; end of string 
8da2 fe 20				cp ' ' 
8da4 ca 00 8d				jp z, .is1    ; end of word 
8da7 2b					dec hl 
8da8 22 6f ee				ld (input_ptr), hl 
8dab 3a 68 ee				ld a, (input_at_cursor) 
8dae 3d					dec a 
8daf 32 68 ee				ld (input_at_cursor), a 
8db2 18 e5				jr .iskpwm 
8db4			 
8db4			 
8db4 fe 0b		.iskl:		cp KEY_LEFT 
8db6 20 27				jr nz, .isk1 
8db8			 
8db8 3a 5b ee				ld a, (input_cursor) 
8dbb			 
8dbb fe 00				cp 0 
8dbd ca 00 8d				jp z, .is1 		; at start of line to ignore  
8dc0			 
8dc0 3d					dec  a 		; TODO check underflow 
8dc1 32 5b ee				ld (input_cursor), a 
8dc4			 
8dc4 2a 6f ee				ld hl, (input_ptr) 
8dc7 2b					dec hl 
8dc8 22 6f ee				ld (input_ptr), hl 
8dcb					 
8dcb 3a 68 ee				ld a, (input_at_cursor) 
8dce 3d					dec a 
8dcf 32 68 ee				ld (input_at_cursor), a 
8dd2			 
8dd2 3e 01				ld a, 1		; show cursor moving 
8dd4 32 65 ee				ld (input_cur_onoff),a 
8dd7 3e 0f				ld a, CUR_BLINK_RATE 
8dd9 32 66 ee				ld (input_cur_flash), a 
8ddc			 
8ddc c3 00 8d				jp .is1 
8ddf			 
8ddf fe 0c		.isk1:		cp KEY_RIGHT 
8de1 20 2a				jr nz, .isk2 
8de3			 
8de3 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8de6 5f					ld e,a 
8de7 3a 5b ee				ld a, (input_cursor) 
8dea bb					cp e 
8deb ca 00 8d				jp z, .is1		; at the end of string so dont go right 
8dee			 
8dee 3c					inc  a 		; TODO check overflow 
8def 32 5b ee				ld (input_cursor), a 
8df2			 
8df2 3a 68 ee				ld a, (input_at_cursor) 
8df5 3c					inc a 
8df6 32 68 ee				ld (input_at_cursor), a 
8df9			 
8df9 2a 6f ee				ld hl, (input_ptr) 
8dfc 23					inc hl 
8dfd 22 6f ee				ld (input_ptr), hl 
8e00			 
8e00 3e 01				ld a, 1		; show cursor moving 
8e02 32 65 ee				ld (input_cur_onoff),a 
8e05 3e 0f				ld a, CUR_BLINK_RATE 
8e07 32 66 ee				ld (input_cur_flash), a 
8e0a			 
8e0a c3 00 8d				jp .is1 
8e0d			 
8e0d fe 05		.isk2:		cp KEY_UP 
8e0f			 
8e0f 20 26				jr nz, .isk3 
8e11			 
8e11					; swap last command with the current on 
8e11			 
8e11					; move cursor to start of string 
8e11 2a 6d ee				ld hl, (input_start) 
8e14 22 6f ee				ld (input_ptr), hl 
8e17			 
8e17 3a 6a ee				ld a, (input_at_pos) 
8e1a 32 68 ee				ld (input_at_cursor), a 
8e1d			 
8e1d 3e 00				ld a, 0 
8e1f 32 5b ee				ld (input_cursor), a 
8e22					 
8e22					; swap input and last command buffers 
8e22			 
8e22 21 f2 e5				ld hl, os_cli_cmd 
8e25 11 f1 e6				ld de, os_last_cmd 
8e28 06 ff				ld b, 255 
8e2a 7e			.swap1:		ld a, (hl) 
8e2b 4f					ld c,a 
8e2c 1a					ld a, (de) 
8e2d 77					ld (hl), a 
8e2e 79					ld a,c 
8e2f 12					ld (de),a 
8e30 23					inc hl 
8e31 13					inc de 
8e32 10 f6				djnz .swap1 
8e34			 
8e34			 
8e34			 
8e34			 
8e34			 
8e34 c3 00 8d				jp .is1 
8e37			 
8e37 fe 08		.isk3:		cp KEY_BS 
8e39 20 3c				jr nz, .isk4 
8e3b			 
8e3b 3a 5b ee				ld a, (input_cursor) 
8e3e			 
8e3e fe 00				cp 0 
8e40 ca 00 8d				jp z, .is1 		; at start of line to ignore  
8e43			 
8e43 3d					dec  a 		; TODO check underflow 
8e44 32 5b ee				ld (input_cursor), a 
8e47			 
8e47					; hl is source 
8e47					; de needs to be source - 1 
8e47			 
8e47			;		ld a, 0 
8e47			;		dec hl 
8e47			;		ld (hl), a 
8e47			 
8e47 2a 6f ee				ld hl, (input_ptr) 
8e4a 2b					dec hl 
8e4b 22 6f ee				ld (input_ptr), hl 
8e4e			 
8e4e					; shift all data 
8e4e			 
8e4e e5					push hl 
8e4f 23					inc hl 
8e50 d1					pop de 
8e51 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e54 4f					ld c,a 
8e55 06 00				ld b,0 
8e57 ed b0				ldir  
8e59			 
8e59			 
8e59			 
8e59			 
8e59 3a 68 ee				ld a, (input_at_cursor) 
8e5c 3d					dec a 
8e5d 32 68 ee				ld (input_at_cursor), a 
8e60			 
8e60			 
8e60 3e 01				ld a, 1		; show cursor moving 
8e62 32 65 ee				ld (input_cur_onoff),a 
8e65 3e 0f				ld a, CUR_BLINK_RATE 
8e67 32 66 ee				ld (input_cur_flash), a 
8e6a			 
8e6a					; remove char 
8e6a 3a 68 ee				ld a, (input_at_cursor) 
8e6d 3c					inc a 
8e6e 11 f8 8e				ld de,.iblank 
8e71 cd 88 8a				call str_at_display 
8e74			 
8e74 c3 00 8d				jp .is1 
8e77			 
8e77 fe 0d		.isk4:		cp KEY_CR 
8e79 28 6c				jr z, .endinput 
8e7b			 
8e7b					; else add the key press to the end 
8e7b			 
8e7b 4f					ld c, a			; save key pressed 
8e7c			 
8e7c 7e					ld a,(hl)		; get what is currently under char 
8e7d			 
8e7d fe 00				cp 0			; we are at the end of the string 
8e7f 20 2f				jr nz, .onchar 
8e81					 
8e81					; add a char to the end of the string 
8e81				 
8e81 71					ld (hl),c 
8e82 23					inc hl 
8e83			;		ld a,' ' 
8e83			;		ld (hl),a 
8e83			;		inc hl 
8e83 3e 00				ld a,0 
8e85 77					ld (hl),a 
8e86 2b					dec hl 
8e87			 
8e87 3a 5b ee				ld a, (input_cursor) 
8e8a 3c					inc a				; TODO check max string length and scroll  
8e8b 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8e8e							 
8e8e 3a 68 ee				ld a, (input_at_cursor) 
8e91 3c					inc a 
8e92 32 68 ee				ld (input_at_cursor), a 
8e95			 
8e95 2a 6f ee				ld hl, (input_ptr) 
8e98 23					inc hl 
8e99 22 6f ee				ld (input_ptr), hl 
8e9c			 
8e9c 2a 6f ee				ld hl, (input_ptr) 
8e9f 23					inc hl 
8ea0 22 6f ee				ld (input_ptr), hl 
8ea3			;	if DEBUG_INPUT 
8ea3			;		push af 
8ea3			;		ld a, '+' 
8ea3			;		ld (debug_mark),a 
8ea3			;		pop af 
8ea3			;		CALLMONITOR 
8ea3			;	endif 
8ea3 3e 01				ld a, 1		; show cursor moving 
8ea5 32 65 ee				ld (input_cur_onoff),a 
8ea8 3e 0f				ld a, CUR_BLINK_RATE 
8eaa 32 66 ee				ld (input_cur_flash), a 
8ead c3 00 8d				jp .is1 
8eb0					 
8eb0			 
8eb0			 
8eb0					; if on a char then insert 
8eb0			.onchar: 
8eb0			 
8eb0					; TODO over flow check: make sure insert does not blow out buffer 
8eb0			 
8eb0					; need to do some maths to use lddr 
8eb0			 
8eb0 e5					push hl   ; save char pos 
8eb1 c5					push bc 
8eb2			 
8eb2 2a 6d ee				ld hl, (input_start) 
8eb5 3a 60 ee				ld a, (input_len) 
8eb8 cd a2 8c				call addatohl  		; end of string 
8ebb 23					inc hl 
8ebc 23					inc hl		; past zero term 
8ebd e5					push hl 
8ebe 23					inc hl 
8ebf e5					push hl  
8ec0			 
8ec0								; start and end of lddr set, now how much to move? 
8ec0			 
8ec0							 
8ec0 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ec3 47					ld b,a 
8ec4 3a 60 ee				ld a,(input_len) 
8ec7 5f					ld e,a 
8ec8 90					sub b 
8ec9 3c					inc a		;?? 
8eca 3c					inc a		;?? 
8ecb 3c					inc a		;?? 
8ecc			 
8ecc 06 00				ld b,0 
8ece 4f					ld c,a 
8ecf			 
8ecf				if DEBUG_INPUT 
8ecf					push af 
8ecf					ld a, 'i' 
8ecf					ld (debug_mark),a 
8ecf					pop af 
8ecf			;		CALLMONITOR 
8ecf				endif 
8ecf d1					pop de 
8ed0 e1					pop hl 
8ed1				if DEBUG_INPUT 
8ed1					push af 
8ed1					ld a, 'I' 
8ed1					ld (debug_mark),a 
8ed1					pop af 
8ed1			;		CALLMONITOR 
8ed1				endif 
8ed1 ed b8				lddr 
8ed3				 
8ed3			 
8ed3			 
8ed3					; TODO have a key for insert/overwrite mode???? 
8ed3 c1					pop bc 
8ed4 e1					pop hl 
8ed5 71					ld (hl), c		; otherwise overwrite current char 
8ed6					 
8ed6			 
8ed6			 
8ed6			 
8ed6 3a 5b ee				ld a, (input_cursor) 
8ed9 3c					inc  a 		; TODO check overflow 
8eda 32 5b ee				ld (input_cursor), a 
8edd			 
8edd 3a 68 ee				ld a, (input_at_cursor) 
8ee0 3c					inc a 
8ee1 32 68 ee				ld (input_at_cursor), a 
8ee4			 
8ee4 c3 00 8d				jp .is1 
8ee7			 
8ee7			.endinput:	; TODO look for end of string 
8ee7			 
8ee7					; add trailing space for end of token 
8ee7			 
8ee7 2a 6d ee				ld hl, (input_start) 
8eea 3a 60 ee				ld a,(input_len) 
8eed cd a2 8c				call addatohl 
8ef0 3e 20				ld a, ' ' 
8ef2 77					ld (hl),a 
8ef3					; TODO eof of parse marker 
8ef3			 
8ef3 23					inc hl 
8ef4 3e 00				ld a, 0 
8ef6 77					ld (hl),a 
8ef7			 
8ef7			 
8ef7 c9					ret 
8ef8			 
8ef8 .. 00		.iblank: db " ",0 
8efa			 
8efa			 
8efa 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8efd 22 6d ee				ld (input_start), hl 
8f00 3e 01				ld a,1			; add cursor 
8f02 77					ld (hl),a 
8f03 23					inc hl 
8f04 3e 00				ld a,0 
8f06 77					ld (hl),a 
8f07 22 6f ee				ld (input_ptr), hl 
8f0a 7a					ld a,d 
8f0b 32 6c ee				ld (input_size), a 
8f0e 3e 00				ld a,0 
8f10 32 5b ee				ld (input_cursor),a 
8f13			.instr1:	 
8f13			 
8f13					; TODO do block cursor 
8f13					; TODO switch cursor depending on the modifer key 
8f13			 
8f13					; update cursor shape change on key hold 
8f13			 
8f13 2a 6f ee				ld hl, (input_ptr) 
8f16 2b					dec hl 
8f17 3a ca eb				ld a,(cursor_shape) 
8f1a 77					ld (hl), a 
8f1b			 
8f1b					; display entered text 
8f1b 3a 6a ee				ld a,(input_at_pos) 
8f1e cd aa df		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f21 ed 5b 6d ee	            	LD   de, (input_start) 
8f25 cd a4 df		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f28			 
8f28 cd 4c e0				call cin 
8f2b fe 00				cp 0 
8f2d 28 e4				jr z, .instr1 
8f2f			 
8f2f					; proecess keyboard controls first 
8f2f			 
8f2f 2a 6f ee				ld hl,(input_ptr) 
8f32			 
8f32 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f34 28 5a				jr z, .instrcr 
8f36			 
8f36 fe 08				cp KEY_BS 	; back space 
8f38 20 0f				jr nz, .instr2 
8f3a					; process back space 
8f3a			 
8f3a					; TODO stop back space if at start of string 
8f3a 2b					dec hl 
8f3b 2b					dec hl ; to over write cursor 
8f3c 3a ca eb				ld a,(cursor_shape) 
8f3f					;ld a,0 
8f3f 77					ld (hl),a 
8f40 23					inc hl 
8f41 3e 20				ld a," " 
8f43 77					ld (hl),a 
8f44 22 6f ee				ld (input_ptr),hl 
8f47					 
8f47			 
8f47 18 ca				jr .instr1 
8f49			 
8f49 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f4b 20 06				jr nz, .instr3 
8f4d 2b					dec hl 
8f4e 22 6f ee				ld (input_ptr),hl 
8f51 18 c0				jr .instr1 
8f53				 
8f53 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f55 20 06				jr nz, .instr4 
8f57 23					inc hl 
8f58 22 6f ee				ld (input_ptr),hl 
8f5b 18 b6				jr .instr1 
8f5d			 
8f5d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f5f 20 06				jr nz, .instr5 
8f61 2b					dec hl 
8f62 22 6f ee				ld (input_ptr),hl 
8f65 18 ac				jr .instr1 
8f67			 
8f67 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8f69 20 06				jr nz, .instr6 
8f6b 2b					dec hl 
8f6c 22 6f ee				ld (input_ptr),hl 
8f6f 18 a2				jr .instr1 
8f71 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8f73 20 0b				jr nz, .instrnew 
8f75			 
8f75 21 cb e2			ld hl, scratch 
8f78 11 f1 e6			ld de, os_last_cmd 
8f7b cd 99 8f			call strcpy 
8f7e 18 93				jr .instr1 
8f80			 
8f80			 
8f80			.instrnew:	; no special key pressed to see if we have room to store it 
8f80			 
8f80					; TODO do string size test 
8f80			 
8f80 2b					dec hl ; to over write cursor 
8f81 77					ld (hl),a 
8f82 23					inc hl 
8f83 3a ca eb				ld a,(cursor_shape) 
8f86 77					ld (hl),a 
8f87 23					inc hl 
8f88 3e 00				ld a,0 
8f8a 77					ld (hl),a 
8f8b			 
8f8b 22 6f ee				ld (input_ptr),hl 
8f8e					 
8f8e 18 83				jr .instr1 
8f90 2b			.instrcr:	dec hl		; remove cursor 
8f91 3e 20				ld a,' '	; TODO add a trailing space for safety 
8f93 77					ld (hl),a 
8f94 23					inc hl 
8f95 3e 00				ld a,0 
8f97 77					ld (hl),a 
8f98			 
8f98			 
8f98					; if at end of line scroll up    
8f98					; TODO detecting only end of line 4 for scroll up  
8f98			 
8f98					;ld   
8f98			 
8f98 c9					ret 
8f99			 
8f99			 
8f99			; strcpy hl = dest, de source 
8f99			 
8f99 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8f9a b7			            OR   A              ;Null terminator? 
8f9b c8			            RET  Z              ;Yes, so finished 
8f9c 1a					ld a,(de) 
8f9d 77					ld (hl),a 
8f9e 13			            INC  DE             ;Point to next character 
8f9f 23					inc hl 
8fa0 18 f7		            JR   strcpy       ;Repeat 
8fa2 c9					ret 
8fa3			 
8fa3			 
8fa3			; TODO string_at  
8fa3			; pass string which starts with lcd offset address and then null term string 
8fa3			 
8fa3			; TODO string to dec 
8fa3			; TODO string to hex 
8fa3			; TODO byte to string hex 
8fa3			; TODO byte to string dec 
8fa3			 
8fa3			 
8fa3			 
8fa3			; from z80uartmonitor 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fa3			; pass hl for where to put the text 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3 c5			hexout:	PUSH BC 
8fa4 f5					PUSH AF 
8fa5 47					LD B, A 
8fa6					; Upper nybble 
8fa6 cb 3f				SRL A 
8fa8 cb 3f				SRL A 
8faa cb 3f				SRL A 
8fac cb 3f				SRL A 
8fae cd be 8f				CALL tohex 
8fb1 77					ld (hl),a 
8fb2 23					inc hl	 
8fb3					 
8fb3					; Lower nybble 
8fb3 78					LD A, B 
8fb4 e6 0f				AND 0FH 
8fb6 cd be 8f				CALL tohex 
8fb9 77					ld (hl),a 
8fba 23					inc hl	 
8fbb					 
8fbb f1					POP AF 
8fbc c1					POP BC 
8fbd c9					RET 
8fbe					 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			tohex: 
8fbe e5					PUSH HL 
8fbf d5					PUSH DE 
8fc0 16 00				LD D, 0 
8fc2 5f					LD E, A 
8fc3 21 cb 8f				LD HL, .DATA 
8fc6 19					ADD HL, DE 
8fc7 7e					LD A, (HL) 
8fc8 d1					POP DE 
8fc9 e1					POP HL 
8fca c9					RET 
8fcb			 
8fcb			.DATA: 
8fcb 30					DEFB	30h	; 0 
8fcc 31					DEFB	31h	; 1 
8fcd 32					DEFB	32h	; 2 
8fce 33					DEFB	33h	; 3 
8fcf 34					DEFB	34h	; 4 
8fd0 35					DEFB	35h	; 5 
8fd1 36					DEFB	36h	; 6 
8fd2 37					DEFB	37h	; 7 
8fd3 38					DEFB	38h	; 8 
8fd4 39					DEFB	39h	; 9 
8fd5 41					DEFB	41h	; A 
8fd6 42					DEFB	42h	; B 
8fd7 43					DEFB	43h	; C 
8fd8 44					DEFB	44h	; D 
8fd9 45					DEFB	45h	; E 
8fda 46					DEFB	46h	; F 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8fdb			;;    subtract $30, if result > 9 then subtract $7 more 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			atohex: 
8fdb d6 30				SUB $30 
8fdd fe 0a				CP 10 
8fdf f8					RET M		; If result negative it was 0-9 so we're done 
8fe0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8fe2 c9					RET		 
8fe3			 
8fe3			 
8fe3			 
8fe3			 
8fe3			; Get 2 ASCII characters as hex byte from pointer in hl 
8fe3			 
8fe3			BYTERD: 
8fe3 16 00			LD	D,00h		;Set up 
8fe5 cd ed 8f			CALL	HEXCON		;Get byte and convert to hex 
8fe8 87				ADD	A,A		;First nibble so 
8fe9 87				ADD	A,A		;multiply by 16 
8fea 87				ADD	A,A		; 
8feb 87				ADD	A,A		; 
8fec 57				LD	D,A		;Save hi nibble in D 
8fed			HEXCON: 
8fed 7e				ld a, (hl)		;Get next chr 
8fee 23				inc hl 
8fef d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8ff1 fe 0a			CP	00Ah		;Is it 0-9 ? 
8ff3 38 02			JR	C,NALPHA	;If so miss next bit 
8ff5 d6 07			SUB	007h		;Else convert alpha 
8ff7			NALPHA: 
8ff7 b2				OR	D		;Add hi nibble back 
8ff8 c9				RET			; 
8ff9			 
8ff9			 
8ff9			; 
8ff9			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8ff9			; Since the routines get_byte and therefore get_nibble are called, only valid 
8ff9			; characters (0-9a-f) are accepted. 
8ff9			; 
8ff9			;get_word        push    af 
8ff9			;                call    get_byte        ; Get the upper byte 
8ff9			;                ld      h, a 
8ff9			;                call    get_byte        ; Get the lower byte 
8ff9			;                ld      l, a 
8ff9			;                pop     af 
8ff9			;                ret 
8ff9			; 
8ff9			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8ff9			; the routine get_nibble is used only valid characters are accepted - the  
8ff9			; input routine only accepts characters 0-9a-f. 
8ff9			; 
8ff9 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8ffa 7e					ld a,(hl) 
8ffb 23					inc hl 
8ffc cd 21 90		                call    nibble2val      ; Get upper nibble 
8fff cb 07		                rlc     a 
9001 cb 07		                rlc     a 
9003 cb 07		                rlc     a 
9005 cb 07		                rlc     a 
9007 47			                ld      b, a            ; Save upper four bits 
9008 7e					ld a,(hl) 
9009 cd 21 90		                call    nibble2val      ; Get lower nibble 
900c b0			                or      b               ; Combine both nibbles 
900d c1			                pop     bc              ; Restore B (and C) 
900e c9			                ret 
900f			; 
900f			; Get a hexadecimal digit from the serial line. This routine blocks until 
900f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
900f			; to the serial line interface. The lower 4 bits of A contain the value of  
900f			; that particular digit. 
900f			; 
900f			;get_nibble      ld a,(hl)           ; Read a character 
900f			;                call    to_upper        ; Convert to upper case 
900f			;                call    is_hex          ; Was it a hex digit? 
900f			;                jr      nc, get_nibble  ; No, get another character 
900f			 ;               call    nibble2val      ; Convert nibble to value 
900f			 ;               call    print_nibble 
900f			 ;               ret 
900f			; 
900f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
900f			; A valid hexadecimal digit is denoted by a set C flag. 
900f			; 
900f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
900f			;                ret     nc              ; Yes 
900f			;                cp      '0'             ; Less than '0'? 
900f			;                jr      nc, is_hex_1    ; No, continue 
900f			;                ccf                     ; Complement carry (i.e. clear it) 
900f			;                ret 
900f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
900f			;                ret     c               ; Yes 
900f			;                cp      'A'             ; Less than 'A'? 
900f			;                jr      nc, is_hex_2    ; No, continue 
900f			;                ccf                     ; Yes - clear carry and return 
900f			;                ret 
900f			;is_hex_2        scf                     ; Set carry 
900f			;                ret 
900f			; 
900f			; Convert a single character contained in A to upper case: 
900f			; 
900f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
9011 d8			                ret     c 
9012 fe 7b		                cp      'z' + 1         ; > 'z'? 
9014 d0			                ret     nc              ; Nothing to do, either 
9015 e6 5f		                and     $5f             ; Convert to upper case 
9017 c9			                ret 
9018			 
9018			 
9018			to_lower: 
9018			 
9018			   ; if char is in [A-Z] make it lower case 
9018			 
9018			   ; enter : a = char 
9018			   ; exit  : a = lower case char 
9018			   ; uses  : af 
9018			 
9018 fe 41		   cp 'A' 
901a d8			   ret c 
901b			    
901b fe 5b		   cp 'Z'+1 
901d d0			   ret nc 
901e			    
901e f6 20		   or $20 
9020 c9			   ret 
9021			 
9021			; 
9021			; Expects a hexadecimal digit (upper case!) in A and returns the 
9021			; corresponding value in A. 
9021			; 
9021 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
9023 38 02		                jr      c, nibble2val_1 ; Yes 
9025 d6 07		                sub     7               ; Adjust for A-F 
9027 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9029 e6 0f		                and     $f              ; Only return lower 4 bits 
902b c9			                ret 
902c			; 
902c			; Print_nibble prints a single hex nibble which is contained in the lower  
902c			; four bits of A: 
902c			; 
902c			;print_nibble    push    af              ; We won't destroy the contents of A 
902c			;                and     $f              ; Just in case... 
902c			;                add     a, '0'             ; If we have a digit we are done here. 
902c			;                cp      '9' + 1         ; Is the result > 9? 
902c			;                jr      c, print_nibble_1 
902c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
902c			;print_nibble_1  call    putc            ; Print the nibble and 
902c			;                pop     af              ; restore the original value of A 
902c			;                ret 
902c			;; 
902c			;; Send a CR/LF pair: 
902c			; 
902c			;crlf            push    af 
902c			;                ld      a, cr 
902c			;                call    putc 
902c			;                ld      a, lf 
902c			;                call    putc 
902c			;                pop     af 
902c			;                ret 
902c			; 
902c			; Print_word prints the four hex digits of a word to the serial line. The  
902c			; word is expected to be in HL. 
902c			; 
902c			;print_word      push    hl 
902c			;                push    af 
902c			;                ld      a, h 
902c			;                call    print_byte 
902c			;                ld      a, l 
902c			;                call    print_byte 
902c			;                pop     af 
902c			;                pop     hl 
902c			;                ret 
902c			; 
902c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
902c			; The byte to be printed is expected to be in A. 
902c			; 
902c			;print_byte      push    af              ; Save the contents of the registers 
902c			;                push    bc 
902c			;                ld      b, a 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                call    print_nibble    ; Print high nibble 
902c			;                ld      a, b 
902c			;                call    print_nibble    ; Print low nibble 
902c			;                pop     bc              ; Restore original register contents 
902c			;                pop     af 
902c			;                ret 
902c			 
902c			 
902c			 
902c			 
902c			 
902c			fourehexhl:  
902c 7e				ld a,(hl) 
902d cd db 8f			call atohex 
9030 cb 3f				SRL A 
9032 cb 3f				SRL A 
9034 cb 3f				SRL A 
9036 cb 3f				SRL A 
9038 47				ld b, a 
9039 23				inc hl 
903a 7e				ld a,(hl) 
903b 23				inc hl 
903c cd db 8f			call atohex 
903f 80				add b 
9040 57				ld d,a 
9041 7e				ld a,(hl) 
9042 cd db 8f			call atohex 
9045 cb 3f				SRL A 
9047 cb 3f				SRL A 
9049 cb 3f				SRL A 
904b cb 3f				SRL A 
904d 47				ld b, a 
904e 23				inc hl 
904f 7e				ld a,(hl) 
9050 23				inc hl 
9051 cd db 8f			call atohex 
9054 80				add b 
9055 5f				ld e, a 
9056 d5				push de 
9057 e1				pop hl 
9058 c9				ret 
9059			 
9059			; pass hl. returns z set if the byte at hl is a digit 
9059			;isdigithl:  
9059			;	push bc 
9059			;	ld a,(hl) 
9059			;	cp ':' 
9059			;	jr nc, .isdf 		; > 
9059			;	cp '0' 
9059			;	jr c, .isdf		; < 
9059			; 
9059			;	; TODO find a better way to set z 
9059			; 
9059			;	ld b,a 
9059			;	cp b 
9059			;	pop bc 
9059			;	ret 
9059			; 
9059			;.isdf:	; not digit so clear z 
9059			; 
9059			;	; TODO find a better way to unset z 
9059			; 
9059			;	ld b,a 
9059			;	inc b 
9059			;	cp b 
9059			; 
9059			;	pop bc 
9059			;	ret 
9059				 
9059				 
9059			 
9059			 
9059			; pass hl as the four byte address to load 
9059			 
9059			get_word_hl:  
9059 e5				push hl 
905a cd f9 8f			call get_byte 
905d				 
905d 47				ld b, a 
905e			 
905e e1				pop hl 
905f 23				inc hl 
9060 23				inc hl 
9061			 
9061			; TODO not able to handle a-f  
9061 7e				ld a,(hl) 
9062			;	;cp ':' 
9062			;	cp 'g' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp 'G' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp '0' 
9062			;	jr c, .single_byte_hl		; < 
9062			 
9062				;call isdigithl 
9062 fe 00			cp 0 
9064 28 06			jr z, .single_byte_hl 
9066			 
9066			.getwhln:   ; hex word so get next byte 
9066			 
9066 cd f9 8f			call get_byte 
9069 6f				ld l, a 
906a 60				ld h,b 
906b c9				ret 
906c 68			.single_byte_hl:   ld l,b 
906d 26 00				ld h,0 
906f c9					ret 
9070			 
9070			 
9070			 
9070			 
9070 21 2b 98			ld hl,asc+1 
9073			;	ld a, (hl) 
9073			;	call nibble2val 
9073 cd f9 8f			call get_byte 
9076			 
9076			;	call fourehexhl 
9076 32 ff e2			ld (scratch+52),a 
9079				 
9079 21 fd e2			ld hl,scratch+50 
907c 22 ee e5			ld (os_cur_ptr),hl 
907f			 
907f c9				ret 
9080			 
9080			 
9080			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
9080			 
9080			; Decimal Unsigned Version 
9080			 
9080			;Number in a to decimal ASCII 
9080			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
9080			;Example: display a=56 as "056" 
9080			;input: a = number 
9080			;Output: a=0,value of a in the screen 
9080			;destroys af,bc (don't know about hl and de) 
9080			DispAToASCII: 
9080 0e 9c			ld	c,-100 
9082 cd 8c 90			call	.Na1 
9085 0e f6			ld	c,-10 
9087 cd 8c 90			call	.Na1 
908a 0e ff			ld	c,-1 
908c 06 2f		.Na1:	ld	b,'0'-1 
908e 04			.Na2:	inc	b 
908f 81				add	a,c 
9090 38 fc			jr	c,.Na2 
9092 91				sub	c		;works as add 100/10/1 
9093 f5				push af		;safer than ld c,a 
9094 78				ld	a,b		;char is in b 
9095			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
9095 f1				pop af		;safer than ld a,c 
9096 c9				ret 
9097			 
9097			; Decimal Signed Version 
9097			 
9097			; DispA 
9097			; -------------------------------------------------------------- 
9097			; Converts a signed integer value to a zero-terminated ASCII 
9097			; string representative of that value (using radix 10). 
9097			; -------------------------------------------------------------- 
9097			; INPUTS: 
9097			;     HL     Value to convert (two's complement integer). 
9097			;     DE     Base address of string destination. (pointer). 
9097			; -------------------------------------------------------------- 
9097			; OUTPUTS: 
9097			;     None 
9097			; -------------------------------------------------------------- 
9097			; REGISTERS/MEMORY DESTROYED 
9097			; AF HL 
9097			; -------------------------------------------------------------- 
9097			 
9097			;DispHLToASCII: 
9097			;   push    de 
9097			;   push    bc 
9097			; 
9097			;; Detect sign of HL. 
9097			;    bit    7, h 
9097			;    jr     z, ._DoConvert 
9097			; 
9097			;; HL is negative. Output '-' to string and negate HL. 
9097			;    ld     a, '-' 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			; 
9097			;; Negate HL (using two's complement) 
9097			;    xor    a 
9097			;    sub    l 
9097			;    ld     l, a 
9097			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
9097			;    sbc    a, h 
9097			;    ld     h, a 
9097			; 
9097			;; Convert HL to digit characters 
9097			;._DoConvert: 
9097			;    ld     b, 0     ; B will count character length of number 
9097			;-   ld     a, 10 
9097			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
9097			;    push   af 
9097			;    inc    b 
9097			;    ld     a, h 
9097			;    or     l 
9097			;    jr     nz, - 
9097			; 
9097			;; Retrieve digits from stack 
9097			;-   pop    af 
9097			;    or     $30 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			;    djnz   - 
9097			; 
9097			;; Terminate string with NULL 
9097			;    xor    a 
9097			;    ld     (de), a 
9097			; 
9097			;    pop    bc 
9097			;    pop    de 
9097			;    ret 
9097			 
9097			;Comments 
9097			; 
9097			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
9097			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
9097			;    Note that the output string will not be fixed-width. 
9097			; 
9097			;Example Usage 
9097			; 
9097			;    ld    hl, -1004 
9097			;    ld    de, OP1 
9097			;    call  DispA 
9097			;    ld    hl, OP1 
9097			;    syscall  PutS 
9097			 
9097			 
9097			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9097			 
9097			 
9097			;Converts an ASCII string to an unsigned 16-bit integer 
9097			;Quits when it reaches a non-decimal digit 
9097			 
9097			string_to_uint16: 
9097			atoui_16: 
9097			;Input: 
9097			;     DE points to the string 
9097			;Outputs: 
9097			;     HL is the result 
9097			;     A is the 8-bit value of the number 
9097			;     DE points to the byte after the number 
9097			;Destroys: 
9097			;     BC 
9097			;       if the string is non-empty, BC is HL/10 
9097			;Size:  24 bytes 
9097			;Speed: 42+d(104+{0,9}) 
9097			;       d is the number of digits in the number 
9097			;       max is 640 cycles for a 5 digit number 
9097			;Assuming no leading zeros: 
9097			;1 digit:  146cc 
9097			;2 digit:  250cc 
9097			;3 digit:  354cc or 363cc (avg: 354.126cc) 
9097			;4 digit:  458cc or 467cc (avg: 458.27cc) 
9097			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
9097			;avg: 544.81158447265625cc (544+13297/16384) 
9097			;=============================================================== 
9097 21 00 00		  ld hl,0 
909a			.u16a: 
909a 1a			  ld a,(de) 
909b d6 30		  sub 30h 
909d fe 0a		  cp 10 
909f d0			  ret nc 
90a0 13			  inc de 
90a1 44			  ld b,h 
90a2 4d			  ld c,l 
90a3 29			  add hl,hl 
90a4 29			  add hl,hl 
90a5 09			  add hl,bc 
90a6 29			  add hl,hl 
90a7 85			  add a,l 
90a8 6f			  ld l,a 
90a9 30 ef		  jr nc,.u16a 
90ab 24			  inc h 
90ac c3 9a 90		  jp .u16a 
90af			 
90af			 
90af			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90af			 
90af			;written by Zeda 
90af			;Converts a 16-bit unsigned integer to an ASCII string. 
90af			 
90af			uitoa_16: 
90af			;Input: 
90af			;   DE is the number to convert 
90af			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90af			;Output: 
90af			;   HL points to the null-terminated ASCII string 
90af			;      NOTE: This isn't necessarily the same as the input HL. 
90af d5			  push de 
90b0 c5			  push bc 
90b1 f5			  push af 
90b2 eb			  ex de,hl 
90b3			 
90b3 01 f0 d8		  ld bc,-10000 
90b6 3e 2f		  ld a,'0'-1 
90b8 3c			  inc a 
90b9 09			  add hl,bc  
90ba 38 fc		   jr c,$-2 
90bc 12			  ld (de),a 
90bd 13			  inc de 
90be			 
90be 01 e8 03		  ld bc,1000 
90c1 3e 3a		  ld a,'9'+1 
90c3 3d			  dec a  
90c4 09			  add hl,bc  
90c5 30 fc		   jr nc,$-2 
90c7 12			  ld (de),a 
90c8 13			  inc de 
90c9			 
90c9 01 9c ff		  ld bc,-100 
90cc 3e 2f		  ld a,'0'-1 
90ce 3c			  inc a  
90cf 09			  add hl,bc  
90d0 38 fc		   jr c,$-2 
90d2 12			  ld (de),a 
90d3 13			  inc de 
90d4			 
90d4 7d			  ld a,l 
90d5 26 3a		  ld h,'9'+1 
90d7 25			  dec h  
90d8 c6 0a		  add a,10  
90da 30 fb		   jr nc,$-3 
90dc c6 30		  add a,'0' 
90de eb			  ex de,hl 
90df 72			  ld (hl),d 
90e0 23			  inc hl 
90e1 77			  ld (hl),a 
90e2 23			  inc hl 
90e3 36 00		  ld (hl),0 
90e5			 
90e5			;Now strip the leading zeros 
90e5 0e fa		  ld c,-6 
90e7 09			  add hl,bc 
90e8 3e 30		  ld a,'0' 
90ea 23			  inc hl  
90eb be			  cp (hl)  
90ec 28 fc		  jr z,$-2 
90ee			 
90ee			;Make sure that the string is non-empty! 
90ee 7e			  ld a,(hl) 
90ef b7			  or a 
90f0 20 01		  jr nz,.atoub 
90f2 2b			  dec hl 
90f3			.atoub: 
90f3			 
90f3 f1			  pop af 
90f4 c1			  pop bc 
90f5 d1			  pop de 
90f6 c9			  ret 
90f7			 
90f7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
90f7			 
90f7			toUpper: 
90f7			;A is the char. 
90f7			;If A is a lowercase letter, this sets it to the matching uppercase 
90f7			;18cc or 30cc or 41cc 
90f7			;avg: 26.75cc 
90f7 fe 61		  cp 'a' 
90f9 d8			  ret c 
90fa fe 7b		  cp 'z'+1 
90fc d0			  ret nc 
90fd d6 20		  sub 'a'-'A' 
90ff c9			  ret 
9100			 
9100			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9100			 
9100			; String Length 
9100			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9100			 
9100			; Get the length of the null-terminated string starting at $8000 hl 
9100			;    LD     HL, $8000 
9100			 
9100			strlenz: 
9100			 
9100 af			    XOR    A               ; Zero is the value we are looking for. 
9101 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9102 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9103			                           ; 65, 536 bytes (the entire addressable memory space). 
9103 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9105			 
9105			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9105 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9106 6f			    LD     L, A             ; number of bytes 
9107 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9109 2b			    DEC    HL              ; Compensate for null. 
910a c9				ret 
910b			 
910b			; Get the length of the A terminated string starting at $8000 hl 
910b			;    LD     HL, $8000 
910b			 
910b			strlent: 
910b			 
910b			                  ; A is the value we are looking for. 
910b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
910d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
910f			                           ; 65, 536 bytes (the entire addressable memory space). 
910f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9111			 
9111			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9111 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9113 2e 00		    LD     L, 0             ; number of bytes 
9115 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9117 2b			    DEC    HL              ; Compensate for null. 
9118 c9				ret 
9119			 
9119			 
9119			;Comparing Strings 
9119			 
9119			;IN    HL     Address of string1. 
9119			;      DE     Address of string2. 
9119			 
9119			; doc given but wrong??? 
9119			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9119			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9119			; tested 
9119			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9119			 
9119			strcmp_old: 
9119 e5			    PUSH   HL 
911a d5			    PUSH   DE 
911b			 
911b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
911c be			    CP     (HL)            ; (want to minimize work). 
911d 38 01		    JR     C, Str1IsBigger 
911f 7e			    LD     A, (HL) 
9120			 
9120			Str1IsBigger: 
9120 4f			    LD     C, A             ; Put length in BC 
9121 06 00		    LD     B, 0 
9123 13			    INC    DE              ; Increment pointers to meat of string. 
9124 23			    INC    HL 
9125			 
9125			CmpLoop: 
9125 1a			    LD     A, (DE)          ; Compare bytes. 
9126 ed a1		    CPI 
9128 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
912a 13			    INC    DE              ; Update pointer. 
912b ea 25 91		    JP     PE, CmpLoop 
912e			 
912e d1			    POP    DE 
912f e1			    POP    HL 
9130 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9131 be			    CP     (HL) 
9132 c9			    RET 
9133			 
9133			NoMatch: 
9133 2b			    DEC    HL 
9134 be			    CP     (HL)            ; Compare again to affect carry. 
9135 d1			    POP    DE 
9136 e1			    POP    HL 
9137 c9			    RET 
9138			 
9138			;; test strmp 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr z, .z1 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z1: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr z, .z2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr c, .c1 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c1: 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr c, .c2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;	NEXTW 
9138			;.str1:   db "string1",0 
9138			;.str2:   db "string2",0 
9138			 
9138			; only care about direct match or not 
9138			; hl and de strings 
9138			; zero set if the same 
9138			 
9138			strcmp: 
9138 1a				ld a, (de) 
9139 be				cp (hl) 
913a 28 02			jr z, .ssame 
913c b7				or a 
913d c9				ret 
913e			 
913e			.ssame:  
913e fe 00			cp 0 
9140 c8				ret z 
9141			 
9141 23				inc hl 
9142 13				inc de 
9143 18 f3			jr strcmp 
9145				 
9145				 
9145			 
9145			 
9145			 
9145			 
9145			; eof 
9145			 
9145			 
9145			 
9145			 
9145			 
9145			 
# End of file firmware_strings.asm
9145			include "firmware_memory.asm"   ; malloc and free  
9145			 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			.mallocsize: db "Wants malloc >256",0 
9145			.mallocasize: db "MALLOC gives >256",0 
9145			.malloczero: db "MALLOC gives zero",0 
9145			 
9145			malloc_guard_zerolen: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145				ld de, 0 
9145			        call cmp16 
9145				jr nz, .lowalloz 
9145			 
9145				push hl 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .malloczero 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145			.lowalloz: 
9145			 
9145			 
9145				pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_entry: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowalloc 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocsize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145				jr .lowdone 
9145			.lowalloc: 
9145			 
9145			 
9145				pop hl 
9145			.lowdone:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_exit: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowallocx 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocasize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145				pop de 
9145				pop hl 
9145			 
9145				CALLMONITOR 
9145				jr .lowdonex 
9145			.lowallocx: 
9145			 
9145				pop hl 
9145			.lowdonex:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			endif 
9145			 
9145			if MALLOC_2 
9145			; Z80 Malloc and Free Functions 
9145			 
9145			; Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc: 
9145				 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_entry 
9145			endif 
9145			 
9145			 
9145			 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "mal" 
9145						CALLMONITOR 
9145					endif 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of size into A 
9145			    or h               ; Check if size is zero 
9145			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
9145			 
9145			    ; Allocate memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma1" 
9145						CALLMONITOR 
9145					endif 
9145			    call malloc_internal ; Call internal malloc function 
9145			    pop af             ; Restore AF register 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret                ; Return 
9145			 
9145			; Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free: 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of pointer into A 
9145			    or h               ; Check if pointer is NULL 
9145			    jp z, free_exit    ; If pointer is NULL, exit 
9145			 
9145			    ; Free memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145			    call free_internal  ; Call internal free function 
9145			    pop af             ; Restore AF register 
9145			    ret                ; Return 
9145			 
9145			; Internal Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc_internal: 
9145			    ld bc, 2           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to requested size 
9145			    ex de, hl          ; Save total size in DE, and keep it in HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			 
9145			    ; Search for free memory block 
9145			    ld de, (heap_end)  ; Load end of heap into DE 
9145			    ld bc, 0           ; Initialize counter 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			malloc_search_loop: 
9145			    ; Check if current block is free 
9145			    ld a, (hl)         ; Load current block's status (free or used) 
9145			    cp 0               ; Compare with zero (free) 
9145			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
9145			 
9145			    ; Check if current block is large enough 
9145			    ld a, (hl+1)       ; Load high byte of block size 
9145			    cp l               ; Compare with low byte of requested size 
9145			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
9145			 
9145			    ld a, (hl+2)       ; Load low byte of block size 
9145			    cp h               ; Compare with high byte of requested size 
9145			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
9145			 
9145			    ; Mark block as used 
9145			    ld (hl), 0xFF      ; Set status byte to indicate used block 
9145			 
9145			    ; Calculate remaining space in block 
9145			    ld bc, 0           ; Clear BC 
9145			    add hl, bc         ; Increment HL to point to start of data block 
9145			    add hl, de         ; HL = HL + DE (total size) 
9145			    ld bc, 1           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to start of data block 
9145			 
9145			    ; Save pointer to allocated block in HL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma5" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			malloc_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3           ; Size of management overhead 
9145			    add hl, bc         ; Move to the next block 
9145			    inc de             ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e            ; Load low byte of heap end address 
9145			    cp (hl)            ; Compare with low byte of current address 
9145			    jr nz, malloc_search_loop  ; If not equal, continue searching 
9145			    ld a, d            ; Load high byte of heap end address 
9145			    cp 0               ; Check if it's zero (end of memory) 
9145			    jr nz, malloc_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, allocation failed 
9145			    xor a              ; Set result to NULL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma6" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			malloc_exit: 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma7" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			; Internal Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free_internal: 
9145			    ld de, (heap_start) ; Load start of heap into DE 
9145			    ld bc, 0            ; Initialize counter 
9145			 
9145			free_search_loop: 
9145			    ; Check if current block contains the pointer 
9145			    ld a, l             ; Load low byte of pointer 
9145			    cp (hl+1)           ; Compare with high byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			    ld a, h             ; Load high byte of pointer 
9145			    cp (hl+2)           ; Compare with low byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			 
9145			    ; Mark block as free 
9145			    ld (hl), 0          ; Set status byte to indicate free block 
9145			    ret                 ; Return 
9145			 
9145			free_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3            ; Size of management overhead 
9145			    add hl, bc          ; Move to the next block 
9145			    inc de              ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e             ; Load low byte of heap end address 
9145			    cp (hl)             ; Compare with low byte of current address 
9145			    jr nz, free_search_loop  ; If not equal, continue searching 
9145			    ld a, d             ; Load high byte of heap end address 
9145			    cp 0                ; Check if it's zero (end of memory) 
9145			    jr nz, free_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, pointer is not found in heap 
9145			    ret 
9145			 
9145			free_exit: 
9145			    ret                 ; Return 
9145			 
9145			; Define heap start and end addresses 
9145			;heap_start:    .dw 0xC000   ; Start of heap 
9145			;heap_end:      .dw 0xE000   ; End of heap 
9145			 
9145			endif 
9145			 
9145			 
9145			if MALLOC_1 
9145			 
9145			 
9145			 
9145			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
9145			 
9145			;moved to firmware.asm 
9145			;heap_start        .equ  0x9000      ; Starting address of heap 
9145			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9145			 
9145			;      .org 0 
9145			;      jp    main 
9145			 
9145			 
9145			;      .org  0x100 
9145			;main: 
9145			;      ld    HL, 0x8100 
9145			;      ld    SP, HL 
9145			; 
9145			;      call  heap_init 
9145			; 
9145			;      ; Make some allocations 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9004 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9014 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9024 
9145			; 
9145			;      ; Free some allocations 
9145			;      ld    HL, 0x9014 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9004 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9024 
9145			;      call  free 
9145			; 
9145			; 
9145			;      halt 
9145			 
9145			 
9145			;------------------------------------------------------------------------------ 
9145			;     heap_init                                                               : 
9145			;                                                                             : 
9145			; Description                                                                 : 
9145			;     Initialise the heap and make it ready for malloc and free operations.   : 
9145			;                                                                             : 
9145			;     The heap is maintained as a linked list, starting with an initial       : 
9145			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9145			;     the first free block in the heap. Each block then points to the next    : 
9145			;     free block within the heap, and the free list ends at the first block   : 
9145			;     with a null pointer to the next free block.                             : 
9145			;                                                                             : 
9145			; Parameters                                                                  : 
9145			;     Inputs are compile-time only. Two defines which specify the starting    : 
9145			;     address of the heap and its size are required, along with a memory      : 
9145			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9145			;     principally stores a pointer to the first free block in the heap.       : 
9145			;                                                                             : 
9145			; Returns                                                                     : 
9145			;     Nothing                                                                 : 
9145			;------------------------------------------------------------------------------ 
9145			heap_init: 
9145 e5			      push  HL 
9146			 
9146			      ; Initialise free list struct 
9146 21 6a e0		      ld    HL, heap_start 
9149 22 65 e0		      ld    (free_list), HL 
914c 21 00 00		      ld    HL, 0 
914f 22 67 e0		      ld    (free_list+2), HL 
9152			 
9152			      ; Insert first free block at bottom of heap, consumes entire heap 
9152 21 ad e2		      ld    HL, heap_start+heap_size-4 
9155 22 6a e0		      ld    (heap_start), HL        ; Next block (end of free list) 
9158 21 43 02		      ld    HL, heap_size-4 
915b 22 6c e0		      ld    (heap_start+2), HL      ; Block size 
915e			 
915e			      ; Insert end of free list block at top of heap - two null words will 
915e			      ; terminate the free list 
915e 21 00 00		      ld    HL, 0 
9161 22 af e2		      ld    (heap_start+heap_size-2), HL 
9164 22 ad e2		      ld    (heap_start+heap_size-4), HL 
9167			 
9167 e1			      pop   HL 
9168			 
9168 c9			      ret 
9169			 
9169			 
9169			;------------------------------------------------------------------------------ 
9169			;     malloc                                                                  : 
9169			;                                                                             : 
9169			; Description                                                                 : 
9169			;     Allocates the wanted space from the heap and returns the address of the : 
9169			;     first useable byte of the allocation.                                   : 
9169			;                                                                             : 
9169			;     Allocations can happen in one of two ways:                              : 
9169			;                                                                             : 
9169			;     1. A free block may be found which is the exact size wanted. In this    : 
9169			;        case the block is removed from the free list and retuedn to the      : 
9169			;        caller.                                                              : 
9169			;     2. A free block may be found which is larger than the size wanted. In   : 
9169			;        this case, the larger block is split into two. The first portion of  : 
9169			;        this block will become the requested space by the malloc call and    : 
9169			;        is returned to the caller. The second portion becomes a new free     : 
9169			;        block, and the free list is adjusted to maintain continuity via this : 
9169			;        newly created block.                                                 : 
9169			;                                                                             : 
9169			;     malloc does not set any initial value in the allocated space, the       : 
9169			;     caller is required to do this as required.                              : 
9169			;                                                                             : 
9169			;     This implementation of malloc uses the stack exclusively, and is        : 
9169			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9169			;     advisable to disable interrupts before calling malloc, and recommended  : 
9169			;     to avoid the use of malloc inside ISRs in general.                      : 
9169			;                                                                             : 
9169			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9169			;                                                                             : 
9169			; Parameters                                                                  : 
9169			;     HL  Number of bytes wanted                                              : 
9169			;                                                                             : 
9169			; Returns                                                                     : 
9169			;     HL  Address of the first useable byte of the allocation                 : 
9169			;                                                                             : 
9169			; Flags                                                                       : 
9169			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9169			;                                                                             : 
9169			; Stack frame                                                                 : 
9169			;       |             |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     BC      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     DE      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     IX      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |  prev_free  |                                                       : 
9169			;   +4  +-------------+                                                       : 
9169			;       |  this_free  |                                                       : 
9169			;   +2  +-------------+                                                       : 
9169			;       |  next_free  |                                                       : 
9169			;   +0  +-------------+                                                       : 
9169			;       |             |                                                       : 
9169			;                                                                             : 
9169			;------------------------------------------------------------------------------ 
9169			 
9169			 
9169			;malloc: 
9169			; 
9169			;	SAVESP ON 1 
9169			; 
9169			;	call malloc_code 
9169			; 
9169			;	CHECKSP ON 1 
9169			;	ret 
9169			 
9169			 
9169			malloc: 
9169 c5			      push  BC 
916a d5			      push  DE 
916b dd e5		      push  IX 
916d			if DEBUG_FORTH_MALLOC_HIGH 
916d			call malloc_guard_entry 
916d			endif 
916d			 
916d					if DEBUG_FORTH_MALLOC 
916d						DMARK "mal" 
916d						CALLMONITOR 
916d					endif 
916d 7c			      ld    A, H                    ; Exit if no space requested 
916e b5			      or    L 
916f ca 2e 92		      jp    Z, malloc_early_exit 
9172			 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			; 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			 
9172			 
9172			 
9172			 
9172					if DEBUG_FORTH_MALLOC 
9172						DMARK "maA" 
9172						CALLMONITOR 
9172					endif 
9172			      ; Set up stack frame 
9172 eb			      ex    DE, HL 
9173 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9176 39			      add   HL, SP 
9177 f9			      ld    SP, HL 
9178 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
917c dd 39		      add   IX, SP 
917e			 
917e			      ; Setup initial state 
917e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
9181 19			      add   HL, DE 
9182			 
9182 44			      ld    B, H                    ; Move want to BC 
9183 4d			      ld    C, L 
9184			 
9184 21 65 e0		      ld    HL, free_list           ; Store prev_free ptr to stack 
9187 dd 75 04		      ld    (IX+4), L 
918a dd 74 05		      ld    (IX+5), H 
918d			 
918d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
918e 23			      inc   HL 
918f 56			      ld    D, (HL) 
9190 dd 73 02		      ld    (IX+2), E 
9193 dd 72 03		      ld    (IX+3), D 
9196 eb			      ex    DE, HL                  ; this_free ptr into HL 
9197			 
9197					if DEBUG_FORTH_MALLOC 
9197						DMARK "maB" 
9197						CALLMONITOR 
9197					endif 
9197			      ; Loop through free block list to find some space 
9197			malloc_find_space: 
9197 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9198 23			      inc   HL 
9199 56			      ld    D, (HL) 
919a			 
919a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
919b b3			      or    E 
919c ca 28 92		      jp    Z, malloc_no_space 
919f			 
919f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91a2 dd 72 01		      ld    (IX+1), D 
91a5			 
91a5			      ; Does this block have enough space to make the allocation? 
91a5 23			      inc   HL                      ; Load free block size into DE 
91a6 5e			      ld    E, (HL) 
91a7 23			      inc   HL 
91a8 56			      ld    D, (HL) 
91a9			 
91a9 eb			      ex    DE, HL                  ; Check size of block against want 
91aa b7			      or    A                       ; Ensure carry flag clear 
91ab ed 42		      sbc   HL, BC 
91ad e5			      push  HL                      ; Store the result for later (new block size) 
91ae			 
91ae ca fd 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91b1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91b3			 
91b3			      ; this_free block is not big enough, setup ptrs to test next free block 
91b3 e1			      pop   HL                      ; Discard previous result 
91b4			 
91b4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91b7 dd 66 03		      ld    H, (IX+3) 
91ba dd 75 04		      ld    (IX+4), L 
91bd dd 74 05		      ld    (IX+5), H 
91c0			 
91c0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91c3 dd 66 01		      ld    H, (IX+1) 
91c6 dd 75 02		      ld    (IX+2), L 
91c9 dd 74 03		      ld    (IX+3), H 
91cc			 
91cc					if DEBUG_FORTH_MALLOC 
91cc						DMARK "MA>" 
91cc						CALLMONITOR 
91cc					endif 
91cc 18 c9		      jr    malloc_find_space 
91ce			 
91ce			      ; split a bigger block into two - requested size and remaining size 
91ce			malloc_alloc_split: 
91ce					if DEBUG_FORTH_MALLOC 
91ce						DMARK "MAs" 
91ce						CALLMONITOR 
91ce					endif 
91ce eb			      ex    DE, HL                  ; Calculate address of new free block 
91cf 2b			      dec   HL 
91d0 2b			      dec   HL 
91d1 2b			      dec   HL 
91d2 09			      add   HL, BC 
91d3			 
91d3			      ; Create a new block and point it at next_free 
91d3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
91d6 dd 56 01		      ld    D, (IX+1) 
91d9			 
91d9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
91da 23			      inc   HL 
91db 72			      ld    (HL), D 
91dc			 
91dc d1			      pop   DE                      ; Store size of new block into new block 
91dd 23			      inc   HL 
91de 73			      ld    (HL), E 
91df 23			      inc   HL 
91e0 72			      ld    (HL), D 
91e1			 
91e1			      ; Update this_free ptr to point to new block 
91e1 2b			      dec   HL 
91e2 2b			      dec   HL 
91e3 2b			      dec   HL 
91e4			 
91e4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91e7 dd 56 03		      ld    D, (IX+3) 
91ea			 
91ea dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91ed dd 74 03		      ld    (IX+3), H 
91f0			 
91f0			      ; Modify this_free block to be allocation 
91f0 eb			      ex    DE, HL 
91f1 af			      xor   A                       ; Null the next block ptr of allocated block 
91f2 77			      ld    (HL), A 
91f3 23			      inc   HL 
91f4 77			      ld    (HL), A 
91f5			 
91f5 23			      inc   HL                      ; Store want size into allocated block 
91f6 71			      ld    (HL), C 
91f7 23			      inc   HL 
91f8 70			      ld    (HL), B 
91f9 23			      inc   HL 
91fa e5			      push  HL                      ; Address of allocation to return 
91fb			 
91fb 18 19		      jr    malloc_update_links 
91fd			 
91fd			malloc_alloc_fit: 
91fd e1			      pop   HL                      ; Dont need new block size, want is exact fit 
91fe			 
91fe					if DEBUG_FORTH_MALLOC 
91fe						DMARK "MAf" 
91fe						CALLMONITOR 
91fe					endif 
91fe			      ; Modify this_free block to be allocation 
91fe eb			      ex    DE, HL 
91ff 2b			      dec   HL 
9200 2b			      dec   HL 
9201 2b			      dec   HL 
9202			 
9202 af			      xor   A                       ; Null the next block ptr of allocated block 
9203 77			      ld    (HL), A 
9204 23			      inc   HL 
9205 77			      ld    (HL), A 
9206			 
9206 23			      inc   HL                      ; Store address of allocation to return 
9207 23			      inc   HL 
9208 23			      inc   HL 
9209 e5			      push  HL 
920a			 
920a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
920a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
920d dd 66 01		      ld    H, (IX+1) 
9210			 
9210 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9213 dd 74 03		      ld    (IX+3), H 
9216			 
9216			 
9216			malloc_update_links: 
9216			      ; Update prev_free ptr to point to this_free 
9216 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9219 dd 66 05		      ld    H, (IX+5) 
921c			 
921c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
921f dd 56 03		      ld    D, (IX+3) 
9222			 
9222 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9223 23			      inc   HL 
9224 72			      ld    (HL), D 
9225			 
9225					if DEBUG_FORTH_MALLOC 
9225						DMARK "Mul" 
9225						CALLMONITOR 
9225					endif 
9225			      ; Clear the Z flag to indicate successful allocation 
9225 7a			      ld    A, D 
9226 b3			      or    E 
9227			 
9227 d1			      pop   DE                      ; Address of allocation 
9228					if DEBUG_FORTH_MALLOC 
9228						DMARK "MAu" 
9228						CALLMONITOR 
9228					endif 
9228			 
9228			malloc_no_space: 
9228 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
922b 39			      add   HL, SP 
922c f9			      ld    SP, HL 
922d			 
922d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAN" 
922e						CALLMONITOR 
922e					endif 
922e			 
922e			malloc_early_exit: 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAx" 
922e						CALLMONITOR 
922e					endif 
922e dd e1		      pop   IX 
9230 d1			      pop   DE 
9231 c1			      pop   BC 
9232			 
9232			if DEBUG_FORTH_MALLOC_HIGH 
9232			call malloc_guard_exit 
9232			call malloc_guard_zerolen 
9232			endif 
9232 c9			      ret 
9233			 
9233			 
9233			;------------------------------------------------------------------------------ 
9233			;     free                                                                    : 
9233			;                                                                             : 
9233			; Description                                                                 : 
9233			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9233			;     returned by malloc, otherwise the behaviour is undefined.               : 
9233			;                                                                             : 
9233			;     Where possible, directly adjacent free blocks will be merged together   : 
9233			;     into larger blocks to help ensure that the heap does not become         : 
9233			;     excessively fragmented.                                                 : 
9233			;                                                                             : 
9233			;     free does not clear or set any other value into the freed space, and    : 
9233			;     therefore its contents may be visible through subsequent malloc's. The  : 
9233			;     caller should clear the freed space as required.                        : 
9233			;                                                                             : 
9233			;     This implementation of free uses the stack exclusively, and is          : 
9233			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9233			;     advisable to disable interrupts before calling free, and recommended    : 
9233			;     to avoid the use of free inside ISRs in general.                        : 
9233			;                                                                             : 
9233			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9233			;                                                                             : 
9233			; Parameters                                                                  : 
9233			;     HL  Pointer to address of first byte of allocation to be freed          : 
9233			;                                                                             : 
9233			; Returns                                                                     : 
9233			;     Nothing                                                                 : 
9233			;                                                                             : 
9233			; Stack frame                                                                 : 
9233			;       |             |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     BC      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     DE      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     IX      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |  prev_free  |                                                       : 
9233			;   +2  +-------------+                                                       : 
9233			;       |  next_free  |                                                       : 
9233			;   +0  +-------------+                                                       : 
9233			;       |             |                                                       : 
9233			;                                                                             : 
9233			;------------------------------------------------------------------------------ 
9233			free: 
9233 c5			      push  BC 
9234 d5			      push  DE 
9235 dd e5		      push  IX 
9237			 
9237 7c			      ld    A, H                    ; Exit if ptr is null 
9238 b5			      or    L 
9239 ca fd 92		      jp    Z, free_early_exit 
923c			 
923c			      ; Set up stack frame 
923c eb			      ex    DE, HL 
923d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9240 39			      add   HL, SP 
9241 f9			      ld    SP, HL 
9242 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9246 dd 39		      add   IX, SP 
9248			 
9248			      ; The address in HL points to the start of the useable allocated space, 
9248			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9248			      ; address of the block itself. 
9248 eb			      ex    DE, HL 
9249 11 fc ff		      ld    DE, -4 
924c 19			      add   HL, DE 
924d			 
924d			      ; An allocated block must have a null next block pointer in it 
924d 7e			      ld    A, (HL) 
924e 23			      inc   HL 
924f b6			      or    (HL) 
9250 c2 f8 92		      jp    NZ, free_done 
9253			 
9253 2b			      dec   HL 
9254			 
9254 44			      ld    B, H                    ; Copy HL to BC 
9255 4d			      ld    C, L 
9256			 
9256			      ; Loop through the free list to find the first block with an address 
9256			      ; higher than the block being freed 
9256 21 65 e0		      ld    HL, free_list 
9259			 
9259			free_find_higher_block: 
9259 5e			      ld    E, (HL)                 ; Load next ptr from free block 
925a 23			      inc   HL 
925b 56			      ld    D, (HL) 
925c 2b			      dec   HL 
925d			 
925d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9260 dd 72 01		      ld    (IX+1), D 
9263 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9266 dd 74 03		      ld    (IX+3), H 
9269			 
9269 78			      ld    A, B                    ; Check if DE is greater than BC 
926a ba			      cp    D                       ; Compare MSB first 
926b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
926d 30 04		      jr    NC, free_find_higher_block_skip 
926f 79			      ld    A, C 
9270 bb			      cp    E                       ; Then compare LSB 
9271 38 08		      jr    C, free_found_higher_block 
9273			 
9273			free_find_higher_block_skip: 
9273 7a			      ld    A, D                    ; Reached the end of the free list? 
9274 b3			      or    E 
9275 ca f8 92		      jp    Z, free_done 
9278			 
9278 eb			      ex    DE, HL 
9279			 
9279 18 de		      jr    free_find_higher_block 
927b			 
927b			free_found_higher_block: 
927b			      ; Insert freed block between prev and next free blocks 
927b 71			      ld    (HL), C                 ; Point prev free block to freed block 
927c 23			      inc   HL 
927d 70			      ld    (HL), B 
927e			 
927e 60			      ld    H, B                    ; Point freed block at next free block 
927f 69			      ld    L, C 
9280 73			      ld    (HL), E 
9281 23			      inc   HL 
9282 72			      ld    (HL), D 
9283			 
9283			      ; Check if the freed block is adjacent to the next free block 
9283 23			      inc   HL                      ; Load size of freed block into HL 
9284 5e			      ld    E, (HL) 
9285 23			      inc   HL 
9286 56			      ld    D, (HL) 
9287 eb			      ex    DE, HL 
9288			 
9288 09			      add   HL, BC                  ; Add addr of freed block and its size 
9289			 
9289 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
928c dd 56 01		      ld    D, (IX+1) 
928f			 
928f b7			      or    A                       ; Clear the carry flag 
9290 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9292 20 22		      jr    NZ, free_check_adjacent_to_prev 
9294			 
9294			      ; Freed block is adjacent to next, merge into one bigger block 
9294 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9295 5e			      ld    E, (HL) 
9296 23			      inc   HL 
9297 56			      ld    D, (HL) 
9298 e5			      push  HL                      ; Save ptr to next block for later 
9299			 
9299 60			      ld    H, B                    ; Store ptr from next block into freed block 
929a 69			      ld    L, C 
929b 73			      ld    (HL), E 
929c 23			      inc   HL 
929d 72			      ld    (HL), D 
929e			 
929e e1			      pop   HL                      ; Restore ptr to next block 
929f 23			      inc   HL                      ; Load size of next block into DE 
92a0 5e			      ld    E, (HL) 
92a1 23			      inc   HL 
92a2 56			      ld    D, (HL) 
92a3 d5			      push  DE                      ; Save next block size for later 
92a4			 
92a4 60			      ld    H, B                    ; Load size of freed block into HL 
92a5 69			      ld    L, C 
92a6 23			      inc   HL 
92a7 23			      inc   HL 
92a8 5e			      ld    E, (HL) 
92a9 23			      inc   HL 
92aa 56			      ld    D, (HL) 
92ab eb			      ex    DE, HL 
92ac			 
92ac d1			      pop   DE                      ; Restore size of next block 
92ad 19			      add   HL, DE                  ; Add sizes of both blocks 
92ae eb			      ex    DE, HL 
92af			 
92af 60			      ld    H, B                    ; Store new bigger size into freed block 
92b0 69			      ld    L, C 
92b1 23			      inc   HL 
92b2 23			      inc   HL 
92b3 73			      ld    (HL), E 
92b4 23			      inc   HL 
92b5 72			      ld    (HL), D 
92b6			 
92b6			free_check_adjacent_to_prev: 
92b6			      ; Check if the freed block is adjacent to the prev free block 
92b6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92b9 dd 66 03		      ld    H, (IX+3) 
92bc			 
92bc 23			      inc   HL                      ; Size of prev free block into DE 
92bd 23			      inc   HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 2b			      dec   HL 
92c2 2b			      dec   HL 
92c3 2b			      dec   HL 
92c4			 
92c4 19			      add   HL, DE                  ; Add prev block addr and size 
92c5			 
92c5 b7			      or    A                       ; Clear the carry flag 
92c6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92c8 20 2e		      jr    NZ, free_done 
92ca			 
92ca			      ; Freed block is adjacent to prev, merge into one bigger block 
92ca 60			      ld    H, B                    ; Load next ptr from freed block into DE 
92cb 69			      ld    L, C 
92cc 5e			      ld    E, (HL) 
92cd 23			      inc   HL 
92ce 56			      ld    D, (HL) 
92cf e5			      push  HL                      ; Save freed block ptr for later 
92d0			 
92d0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92d3 dd 66 03		      ld    H, (IX+3) 
92d6 73			      ld    (HL), E 
92d7 23			      inc   HL 
92d8 72			      ld    (HL), D 
92d9			 
92d9 e1			      pop   HL                      ; Restore freed block ptr 
92da 23			      inc   HL                      ; Load size of freed block into DE 
92db 5e			      ld    E, (HL) 
92dc 23			      inc   HL 
92dd 56			      ld    D, (HL) 
92de d5			      push  DE                      ; Save freed block size for later 
92df			 
92df dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
92e2 dd 66 03		      ld    H, (IX+3) 
92e5 23			      inc   HL 
92e6 23			      inc   HL 
92e7 5e			      ld    E, (HL) 
92e8 23			      inc   HL 
92e9 56			      ld    D, (HL) 
92ea			 
92ea e1			      pop   HL                      ; Add sizes of both blocks 
92eb 19			      add   HL, DE 
92ec eb			      ex    DE, HL 
92ed			 
92ed dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
92f0 dd 66 03		      ld    H, (IX+3) 
92f3 23			      inc   HL 
92f4 23			      inc   HL 
92f5 73			      ld    (HL), E 
92f6 23			      inc   HL 
92f7 72			      ld    (HL), D 
92f8			 
92f8			free_done: 
92f8 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
92fb 39			      add   HL, SP 
92fc f9			      ld    SP, HL 
92fd			 
92fd			free_early_exit: 
92fd dd e1		      pop   IX 
92ff d1			      pop   DE 
9300 c1			      pop   BC 
9301			 
9301 c9			      ret 
9302			 
9302			; moved to firmware.asm 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			;                  .dw   0 
9302			 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_3 
9302			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9302			;heap_start        .equ  0x9000      ; Starting address of heap 
9302			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9302			; 
9302			 ;     .org 0 
9302			  ;    jp    main 
9302			; 
9302			; 
9302			 ;     .org  0x100 
9302			;main: 
9302			 ;     ld    HL, 0x8100 
9302			  ;    ld    SP, HL 
9302			; 
9302			;      call  heap_init 
9302			 
9302			      ; Make some allocations 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9004 
9302			; 
9302			 ;     ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9014 
9302			 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9024 
9302			 
9302			      ; Free some allocations 
9302			;      ld    HL, 0x9014 
9302			;      call  free 
9302			 
9302			;      ld    HL, 0x9004 
9302			;      call  free 
9302			; 
9302			;      ld    HL, 0x9024 
9302			;      call  free 
9302			 
9302			 
9302			 ;     halt 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     heap_init                                                               : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Initialise the heap and make it ready for malloc and free operations.   : 
9302			;                                                                             : 
9302			;     The heap is maintained as a linked list, starting with an initial       : 
9302			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9302			;     the first free block in the heap. Each block then points to the next    : 
9302			;     free block within the heap, and the free list ends at the first block   : 
9302			;     with a null pointer to the next free block.                             : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     Inputs are compile-time only. Two defines which specify the starting    : 
9302			;     address of the heap and its size are required, along with a memory      : 
9302			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9302			;     principally stores a pointer to the first free block in the heap.       : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;------------------------------------------------------------------------------ 
9302			heap_init: 
9302			      push  HL 
9302			 
9302			      ; Initialise free list struct 
9302			      ld    HL, heap_start 
9302			      ld    (free_list), HL 
9302			      ld    HL, 0 
9302			      ld    (free_list+2), HL 
9302			 
9302			      ; Insert first free block at bottom of heap, consumes entire heap 
9302			      ld    HL, heap_start+heap_size-4 
9302			      ld    (heap_start), HL        ; Next block (end of free list) 
9302			      ld    HL, heap_size-4 
9302			      ld    (heap_start+2), HL      ; Block size 
9302			 
9302			      ; Insert end of free list block at top of heap - two null words will 
9302			      ; terminate the free list 
9302			      ld    HL, 0 
9302			      ld    (heap_start+heap_size-2), HL 
9302			      ld    (heap_start+heap_size-4), HL 
9302			 
9302			      pop   HL 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     malloc                                                                  : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Allocates the wanted space from the heap and returns the address of the : 
9302			;     first useable byte of the allocation.                                   : 
9302			;                                                                             : 
9302			;     Allocations can happen in one of two ways:                              : 
9302			;                                                                             : 
9302			;     1. A free block may be found which is the exact size wanted. In this    : 
9302			;        case the block is removed from the free list and retuedn to the      : 
9302			;        caller.                                                              : 
9302			;     2. A free block may be found which is larger than the size wanted. In   : 
9302			;        this case, the larger block is split into two. The first portion of  : 
9302			;        this block will become the requested space by the malloc call and    : 
9302			;        is returned to the caller. The second portion becomes a new free     : 
9302			;        block, and the free list is adjusted to maintain continuity via this : 
9302			;        newly created block.                                                 : 
9302			;                                                                             : 
9302			;     malloc does not set any initial value in the allocated space, the       : 
9302			;     caller is required to do this as required.                              : 
9302			;                                                                             : 
9302			;     This implementation of malloc uses the stack exclusively, and is        : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling malloc, and recommended  : 
9302			;     to avoid the use of malloc inside ISRs in general.                      : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Number of bytes wanted                                              : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     HL  Address of the first useable byte of the allocation                 : 
9302			;                                                                             : 
9302			; Flags                                                                       : 
9302			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +4  +-------------+                                                       : 
9302			;       |  this_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			malloc: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if no space requested 
9302			      or    L 
9302			      jp    Z, malloc_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; Setup initial state 
9302			      ld    HL, 4                   ; want must also include space used by block struct 
9302			      add   HL, DE 
9302			 
9302			      ld    B, H                    ; Move want to BC 
9302			      ld    C, L 
9302			 
9302			      ld    HL, free_list           ; Store prev_free ptr to stack 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    E, (HL)                 ; Store this_free ptr to stack 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ld    (IX+2), E 
9302			      ld    (IX+3), D 
9302			      ex    DE, HL                  ; this_free ptr into HL 
9302			 
9302			      ; Loop through free block list to find some space 
9302			malloc_find_space: 
9302			      ld    E, (HL)                 ; Load next_free ptr into DE 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9302			      or    E 
9302			      jp    Z, malloc_no_space 
9302			 
9302			      ld    (IX+0), E               ; Store next_free ptr to stack 
9302			      ld    (IX+1), D 
9302			 
9302			      ; Does this block have enough space to make the allocation? 
9302			      inc   HL                      ; Load free block size into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ex    DE, HL                  ; Check size of block against want 
9302			      or    A                       ; Ensure carry flag clear 
9302			      sbc   HL, BC 
9302			      push  HL                      ; Store the result for later (new block size) 
9302			 
9302			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9302			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9302			 
9302			      ; this_free block is not big enough, setup ptrs to test next free block 
9302			      pop   HL                      ; Discard previous result 
9302			 
9302			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9302			      ld    H, (IX+3) 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9302			      ld    H, (IX+1) 
9302			      ld    (IX+2), L 
9302			      ld    (IX+3), H 
9302			 
9302			      jr    malloc_find_space 
9302			 
9302			      ; split a bigger block into two - requested size and remaining size 
9302			malloc_alloc_split: 
9302			      ex    DE, HL                  ; Calculate address of new free block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      add   HL, BC 
9302			 
9302			      ; Create a new block and point it at next_free 
9302			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      ld    (HL), E                 ; Store next_free ptr into new block 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   DE                      ; Store size of new block into new block 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Update this_free ptr to point to new block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9302			      ld    (IX+3), H 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store want size into allocated block 
9302			      ld    (HL), C 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			      inc   HL 
9302			      push  HL                      ; Address of allocation to return 
9302			 
9302			      jr    malloc_update_links 
9302			 
9302			malloc_alloc_fit: 
9302			      pop   HL                      ; Dont need new block size, want is exact fit 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store address of allocation to return 
9302			      inc   HL 
9302			      inc   HL 
9302			      push  HL 
9302			 
9302			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9302			      ld    L, (IX+0)               ; next_free to HL 
9302			      ld    H, (IX+1) 
9302			 
9302			      ld    (IX+2), L               ; HL to this_free 
9302			      ld    (IX+3), H 
9302			 
9302			 
9302			malloc_update_links: 
9302			      ; Update prev_free ptr to point to this_free 
9302			      ld    L, (IX+4)               ; prev_free ptr to HL 
9302			      ld    H, (IX+5) 
9302			 
9302			      ld    E, (IX+2)               ; this_free ptr to DE 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (HL), E                 ; this_free ptr into prev_free 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Clear the Z flag to indicate successful allocation 
9302			      ld    A, D 
9302			      or    E 
9302			 
9302			      pop   DE                      ; Address of allocation 
9302			 
9302			malloc_no_space: 
9302			      ld    HL, 6                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			      ex    DE, HL                  ; Alloc addr into HL for return 
9302			 
9302			malloc_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     free                                                                    : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9302			;     returned by malloc, otherwise the behaviour is undefined.               : 
9302			;                                                                             : 
9302			;     Where possible, directly adjacent free blocks will be merged together   : 
9302			;     into larger blocks to help ensure that the heap does not become         : 
9302			;     excessively fragmented.                                                 : 
9302			;                                                                             : 
9302			;     free does not clear or set any other value into the freed space, and    : 
9302			;     therefore its contents may be visible through subsequent malloc's. The  : 
9302			;     caller should clear the freed space as required.                        : 
9302			;                                                                             : 
9302			;     This implementation of free uses the stack exclusively, and is          : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling free, and recommended    : 
9302			;     to avoid the use of free inside ISRs in general.                        : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Pointer to address of first byte of allocation to be freed          : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			free: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if ptr is null 
9302			      or    L 
9302			      jp    Z, free_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; The address in HL points to the start of the useable allocated space, 
9302			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9302			      ; address of the block itself. 
9302			      ex    DE, HL 
9302			      ld    DE, -4 
9302			      add   HL, DE 
9302			 
9302			      ; An allocated block must have a null next block pointer in it 
9302			      ld    A, (HL) 
9302			      inc   HL 
9302			      or    (HL) 
9302			      jp    NZ, free_done 
9302			 
9302			      dec   HL 
9302			 
9302			      ld    B, H                    ; Copy HL to BC 
9302			      ld    C, L 
9302			 
9302			      ; Loop through the free list to find the first block with an address 
9302			      ; higher than the block being freed 
9302			      ld    HL, free_list 
9302			 
9302			free_find_higher_block: 
9302			      ld    E, (HL)                 ; Load next ptr from free block 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			 
9302			      ld    (IX+0), E               ; Save ptr to next free block 
9302			      ld    (IX+1), D 
9302			      ld    (IX+2), L               ; Save ptr to prev free block 
9302			      ld    (IX+3), H 
9302			 
9302			      ld    A, B                    ; Check if DE is greater than BC 
9302			      cp    D                       ; Compare MSB first 
9302			      jr    Z, $+4                  ; MSB the same, compare LSB 
9302			      jr    NC, free_find_higher_block_skip 
9302			      ld    A, C 
9302			      cp    E                       ; Then compare LSB 
9302			      jr    C, free_found_higher_block 
9302			 
9302			free_find_higher_block_skip: 
9302			      ld    A, D                    ; Reached the end of the free list? 
9302			      or    E 
9302			      jp    Z, free_done 
9302			 
9302			      ex    DE, HL 
9302			 
9302			      jr    free_find_higher_block 
9302			 
9302			free_found_higher_block: 
9302			      ; Insert freed block between prev and next free blocks 
9302			      ld    (HL), C                 ; Point prev free block to freed block 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			 
9302			      ld    H, B                    ; Point freed block at next free block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Check if the freed block is adjacent to the next free block 
9302			      inc   HL                      ; Load size of freed block into HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      add   HL, BC                  ; Add addr of freed block and its size 
9302			 
9302			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_check_adjacent_to_prev 
9302			 
9302			      ; Freed block is adjacent to next, merge into one bigger block 
9302			      ex    DE, HL                  ; Load next ptr from next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save ptr to next block for later 
9302			 
9302			      ld    H, B                    ; Store ptr from next block into freed block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore ptr to next block 
9302			      inc   HL                      ; Load size of next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save next block size for later 
9302			 
9302			      ld    H, B                    ; Load size of freed block into HL 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      pop   DE                      ; Restore size of next block 
9302			      add   HL, DE                  ; Add sizes of both blocks 
9302			      ex    DE, HL 
9302			 
9302			      ld    H, B                    ; Store new bigger size into freed block 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_check_adjacent_to_prev: 
9302			      ; Check if the freed block is adjacent to the prev free block 
9302			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9302			      ld    H, (IX+3) 
9302			 
9302			      inc   HL                      ; Size of prev free block into DE 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      add   HL, DE                  ; Add prev block addr and size 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_done 
9302			 
9302			      ; Freed block is adjacent to prev, merge into one bigger block 
9302			      ld    H, B                    ; Load next ptr from freed block into DE 
9302			      ld    L, C 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save freed block ptr for later 
9302			 
9302			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9302			      ld    H, (IX+3) 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore freed block ptr 
9302			      inc   HL                      ; Load size of freed block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save freed block size for later 
9302			 
9302			      ld    L, (IX+2)               ; Load size of prev block into DE 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      pop   HL                      ; Add sizes of both blocks 
9302			      add   HL, DE 
9302			      ex    DE, HL 
9302			 
9302			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_done: 
9302			      ld    HL, 4                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			free_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;      .org 0x8000 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			 ;                 .dw   0 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_4 
9302			 
9302			; My memory allocation code. Very very simple.... 
9302			; allocate space under 250 chars 
9302			 
9302			heap_init: 
9302				; init start of heap as zero 
9302				;  
9302			 
9302				ld hl, heap_start 
9302				ld a, 0 
9302				ld (hl), a      ; empty block 
9302				inc hl 
9302				ld a, 0 
9302				ld (hl), a      ; length of block 
9302				; write end of list 
9302				inc hl 
9302				ld a,(hl) 
9302				inc hl 
9302				ld a,(hl) 
9302				 
9302			 
9302				; init some malloc vars 
9302			 
9302				ld hl, 0 
9302				ld (free_list), hl       ; store last malloc location 
9302			 
9302				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9302				ld a, 0 
9302				ld (hl), a 
9302			 
9302			 
9302				ld hl, heap_start 
9302				;  
9302				  
9302				ret 
9302			 
9302			 
9302			;    free block marker 
9302			;    requested size  
9302			;    pointer to next block 
9302			;    .... 
9302			;    next block marker 
9302			 
9302			 
9302			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9302			; 
9302			 
9302			 
9302			malloc:  
9302				push de 
9302				push bc 
9302				push af 
9302			 
9302				; hl space required 
9302				 
9302				ld c, l    ; hold space   (TODO only a max of 255) 
9302			 
9302			;	inc c     ; TODO BUG need to fix memory leak on push str 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			 
9302			 
9302			 
9302				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9302			 
9302				ld a, (free_list+3) 
9302				cp 0 
9302				jr z, .contheap 
9302			 
9302				ld hl, (free_list)     ; get last alloc 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mrs" 
9302						CALLMONITOR 
9302					endif 
9302				jr .startalloc 
9302			 
9302			.contheap: 
9302				ld hl, heap_start 
9302			 
9302			.startalloc: 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mym" 
9302						CALLMONITOR 
9302					endif 
9302			.findblock: 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmf" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302				ld a,(hl)  
9302				; if byte is zero then clear to use 
9302			 
9302				cp 0 
9302				jr z, .foundemptyblock 
9302			 
9302				; if byte is not clear 
9302				;     then byte is offset to next block 
9302			 
9302				inc hl 
9302				ld a, (hl) ; get size 
9302			.nextblock:	inc hl 
9302					ld e, (hl) 
9302					inc hl 
9302					ld d, (hl) 
9302					ex de, hl 
9302			;	inc hl  ; move past the store space 
9302			;	inc hl  ; move past zero index  
9302			 
9302				; TODO detect no more space 
9302			 
9302				push hl 
9302				ld de, heap_end 
9302				call cmp16 
9302				pop hl 
9302				jr nc, .nospace 
9302			 
9302				jr .findblock 
9302			 
9302			.nospace: ld hl, 0 
9302				jp .exit 
9302			 
9302			 
9302			.foundemptyblock:	 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mme" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; TODO has block enough space if reusing??? 
9302			 
9302				;  
9302			 
9302			; see if this block has been previously used 
9302				inc hl 
9302				ld a, (hl) 
9302				dec hl 
9302				cp 0 
9302				jr z, .newblock 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meR" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; no reusing previously allocated block 
9302			 
9302			; is it smaller than previously used? 
9302				 
9302				inc hl    ; move to size 
9302				ld a, c 
9302				sub (hl)        ; we want c < (hl) 
9302				dec hl    ; move back to marker 
9302			        jr z, .findblock 
9302			 
9302				; update with the new size which should be lower 
9302			 
9302			        ;inc  hl   ; negate next move. move back to size  
9302			 
9302			.newblock: 
9302				; need to be at marker here 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meN" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			 
9302				ld a, c 
9302			 
9302				ld (free_list+3), a	 ; flag resume from last malloc  
9302				ld (free_list), hl    ; save out last location 
9302			 
9302			 
9302				;inc a     ; space for length byte 
9302				ld (hl), a     ; save block in use marker 
9302			 
9302				inc hl   ; move to space marker 
9302				ld (hl), a    ; save new space 
9302			 
9302				inc hl   ; move to start of allocated area 
9302				 
9302			;	push hl     ; save where we are - 1  
9302			 
9302			;	inc hl  ; move past zero index  
9302				; skip space to set down new marker 
9302			 
9302				; provide some extra space for now 
9302			 
9302				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9302				inc a 
9302				inc a 
9302			 
9302				push hl   ; save where we are in the node block 
9302			 
9302				call addatohl 
9302			 
9302				; write linked list point 
9302			 
9302				pop de     ; get our node position 
9302				ex de, hl 
9302			 
9302				ld (hl), e 
9302				inc hl 
9302				ld (hl), d 
9302			 
9302				inc hl 
9302			 
9302				; now at start of allocated data so save pointer 
9302			 
9302				push hl 
9302			 
9302				; jump to position of next node and setup empty header in DE 
9302			 
9302				ex de, hl 
9302			 
9302			;	inc hl ; move past end of block 
9302			 
9302				ld a, 0 
9302				ld (hl), a   ; empty marker 
9302				inc hl 
9302				ld (hl), a   ; size 
9302				inc hl  
9302				ld (hl), a   ; ptr 
9302				inc hl 
9302				ld (hl), a   ; ptr 
9302			 
9302			 
9302				pop hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmr" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			.exit: 
9302				pop af 
9302				pop bc 
9302				pop de  
9302				ret 
9302			 
9302			 
9302			 
9302			 
9302			free:  
9302				push hl 
9302				push af 
9302				; get address in hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "fre" 
9302						CALLMONITOR 
9302					endif 
9302				; data is at hl - move to block count 
9302				dec hl 
9302				dec hl    ; get past pointer 
9302				dec hl 
9302			 
9302				ld a, (hl)    ; need this for a validation check 
9302			 
9302				dec hl    ; move to block marker 
9302			 
9302				; now check that the block count and block marker are the same  
9302			        ; this checks that we are on a malloc node and not random memory 
9302			        ; OK a faint chance this could be a problem but rare - famous last words! 
9302			 
9302				ld c, a 
9302				ld a, (hl)    
9302			 
9302				cp c 
9302				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9302			 
9302				; yes good chance we are on a malloc node 
9302			 
9302				ld a, 0      
9302				ld (hl), a   ; mark as free 
9302			 
9302				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9302			 
9302			.freeignore:  
9302			 
9302				pop af 
9302				pop hl 
9302			 
9302				ret 
9302			 
9302			 
9302			 
9302			endif 
9302			 
9302			; eof 
# End of file firmware_memory.asm
9302			  
9302			; device C  
9302			if SOUND_ENABLE  
9302				include "firmware_sound.asm"  
9302			endif  
9302			  
9302			include "firmware_diags.asm"  
9302			; Hardware diags menu 
9302			 
9302			 
9302			config: 
9302			 
9302 3e 00			ld a, 0 
9304 21 32 93			ld hl, .configmn 
9307 cd a6 8a			call menu 
930a			 
930a fe 00			cp 0 
930c c8				ret z 
930d			 
930d fe 01			cp 1 
930f cc 60 93			call z, .savetostore 
9312			 
9312 fe 02			cp 2 
9314 cc 4c 93			call z, .selautoload 
9317 fe 03			cp 3 
9319 cc 42 93			call z, .disautoload 
931c fe 04			cp 4 
931e cc 56 93			call z, .selbank 
9321 fe 05			cp 5 
9323 cc 6a 93			call z, .debug_tog 
9326 fe 06			cp 6 
9328 cc ad 94			call z, .bpsgo 
932b fe 07			cp 7 
932d cc 90 93			call z, hardware_diags 
9330			 
9330 18 d0			jr config 
9332			 
9332			.configmn: 
9332 9e 96			dw prom_c3 
9334 b5 96			dw prom_c2 
9336 ca 96			dw prom_c2a 
9338 e0 96			dw prom_c2b 
933a			;	dw prom_c4 
933a fd 96			dw prom_m4 
933c 18 97			dw prom_m4b 
933e 20 97			dw prom_c1 
9340 00 00			dw 0 
9342				 
9342			 
9342			 
9342			 
9342			.disautoload: 
9342				if STORAGE_SE 
9342				ld a, $fe      ; bit 0 clear 
9342				ld (spi_device), a 
9342			 
9342				call storage_get_block_0 
9342			 
9342				ld a, 0 
9342				ld (store_page+STORE_0_AUTOFILE), a 
9342			 
9342					ld hl, 0 
9342					ld de, store_page 
9342				call storage_write_block	 ; save update 
9342				else 
9342			 
9342 21 2f 97			ld hl, prom_notav 
9345 11 45 97			ld de, prom_empty 
9348 cd 06 8a			call info_panel 
934b				endif 
934b			 
934b			 
934b c9				ret 
934c			 
934c			 
934c			 
934c			; Select auto start 
934c			 
934c			.selautoload: 
934c			 
934c				 
934c				if STORAGE_SE 
934c			 
934c					call config_dir 
934c				        ld hl, scratch 
934c					ld a, 0 
934c					call menu 
934c			 
934c					cp 0 
934c					ret z 
934c			 
934c					dec a 
934c			 
934c			 
934c					; locate menu option 
934c			 
934c					ld hl, scratch 
934c					call table_lookup 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALl" 
934c						CALLMONITOR 
934c					endif 
934c					; with the pointer to the menu it, the byte following the zero term is the file id 
934c			 
934c					ld a, 0 
934c					ld bc, 50   ; max of bytes to look at 
934c					cpir  
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALb" 
934c						CALLMONITOR 
934c					endif 
934c					;inc hl 
934c			 
934c					ld a, (hl)   ; file id 
934c					 
934c				        ; save bank and file ids 
934c			 
934c					push af 
934c			 
934c			; TODO need to save to block 0 on bank 1	 
934c			 
934c					call storage_get_block_0 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "AL0" 
934c						CALLMONITOR 
934c					endif 
934c					pop af 
934c			 
934c					ld (store_page+STORE_0_FILERUN),a 
934c					 
934c					; save bank id 
934c			 
934c					ld a,(spi_device) 
934c					ld (store_page+STORE_0_BANKRUN),a 
934c			 
934c					; enable auto run of store file 
934c			 
934c					ld a, 1 
934c					ld (store_page+STORE_0_AUTOFILE),a 
934c			 
934c					; save buffer 
934c			 
934c					ld hl, 0 
934c					ld de, store_page 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALw" 
934c						CALLMONITOR 
934c					endif 
934c				call storage_write_block	 ; save update 
934c			  
934c			 
934c			 
934c			 
934c					ld hl, scratch 
934c					call config_fdir 
934c			 
934c				else 
934c			 
934c 21 2f 97			ld hl, prom_notav 
934f 11 45 97			ld de, prom_empty 
9352 cd 06 8a			call info_panel 
9355			 
9355				endif 
9355 c9				ret 
9356			 
9356			 
9356			 
9356			; Select storage bank 
9356			 
9356			.selbank: 
9356			 
9356				if STORAGE_SE 
9356				else 
9356			 
9356 21 2f 97			ld hl, prom_notav 
9359 11 45 97			ld de, prom_empty 
935c cd 06 8a			call info_panel 
935f				endif 
935f				 
935f c9				ret 
9360			 
9360			if STORAGE_SE 
9360			 
9360			.config_ldir:   
9360				; Load storage bank labels into menu array 
9360			 
9360				 
9360			 
9360			 
9360				ret 
9360			 
9360			 
9360			endif 
9360			 
9360			 
9360			; Save user words to storage 
9360			 
9360			.savetostore: 
9360			 
9360				if STORAGE_SE 
9360			 
9360					call config_dir 
9360				        ld hl, scratch 
9360					ld a, 0 
9360					call menu 
9360					 
9360					ld hl, scratch 
9360					call config_fdir 
9360			 
9360				else 
9360			 
9360 21 2f 97			ld hl, prom_notav 
9363 11 45 97			ld de, prom_empty 
9366 cd 06 8a			call info_panel 
9369			 
9369				endif 
9369			 
9369 c9				ret 
936a			 
936a			 
936a			 
936a			if STORAGE_SE 
936a			 
936a			config_fdir: 
936a				; using the scratch dir go through and release the memory allocated for each string 
936a				 
936a				ld hl, scratch 
936a			.cfdir:	ld e,(hl) 
936a				inc hl 
936a				ld d,(hl) 
936a				inc hl 
936a			 
936a				ex de, hl 
936a				call ishlzero 
936a				ret z     ; return on null pointer 
936a				call free 
936a				ex de, hl 
936a				jr .cfdir 
936a			 
936a			 
936a				ret 
936a			 
936a			 
936a			config_dir: 
936a			 
936a				; for the config menus that need to build a directory of storage call this routine 
936a				; it will construct a menu in scratch to pass to menu 
936a			 
936a				; open storage device 
936a			 
936a				; execute DIR to build a list of files and their ids into scratch in menu format 
936a				; once the menu has finished then will need to call config_fdir to release the strings 
936a				 
936a				; c = number items 
936a			 
936a				 
936a				call storage_get_block_0 
936a			 
936a				ld hl, store_page     ; get current id count 
936a				ld b, (hl) 
936a				ld c, 0    ; count of files   
936a			 
936a			 
936a				ld hl, scratch 
936a				ld (store_tmp2), hl    ; location to poke strings 
936a			 
936a				; check for empty drive 
936a			 
936a				ld a, 0 
936a				cp b 
936a				jp z, .dirdone 
936a			 
936a				 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdc" 
936a						CALLMONITOR 
936a					endif 
936a			 
936a			 
936a			.diritem:	 
936a				push bc 
936a				; for each of the current ids do a search for them and if found push to stack 
936a			 
936a					ld hl, STORE_BLOCK_PHY 
936a					ld d, 0		 ; look for extent 0 of block id as this contains file name 
936a					ld e,b 
936a			 
936a					call storage_findnextid 
936a			 
936a			 
936a					; if found hl will be non zero 
936a			 
936a					call ishlzero 
936a					jr z, .dirnotfound 
936a			 
936a					; increase count 
936a			 
936a					pop bc	 
936a					inc c 
936a					push bc 
936a					 
936a			 
936a					; get file header and push the file name 
936a			 
936a					ld de, store_page 
936a					call storage_read_block 
936a			 
936a					; push file id to stack 
936a				 
936a					ld a, (store_page) 
936a					ld h, 0 
936a					ld l, a 
936a			 
936a					;call forth_push_numhl 
936a					; TODO store id 
936a			 
936a					push hl 
936a			 
936a					; push extent count to stack  
936a				 
936a					ld hl, store_page+3 
936a			 
936a					; get file name length 
936a			 
936a					call strlenz   
936a			 
936a					inc hl   ; cover zero term 
936a					inc hl  ; stick the id at the end of the area 
936a			 
936a					push hl 
936a					pop bc    ; move length to bc 
936a			 
936a					call malloc 
936a			 
936a					; TODO save malloc area to scratch 
936a			 
936a					ex de, hl 
936a					ld hl, (store_tmp2) 
936a					ld (hl), e 
936a					inc hl 
936a					ld (hl), d 
936a					inc hl 
936a					ld (store_tmp2), hl 
936a			 
936a					 
936a			 
936a					;pop hl   ; get source 
936a			;		ex de, hl    ; swap aronund	 
936a			 
936a					ld hl, store_page+3 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "CFd" 
936a						CALLMONITOR 
936a					endif 
936a					ldir 
936a			 
936a					; de is past string, move back one and store id 
936a					 
936a					dec de 
936a			 
936a					; store file id 
936a			 
936a					pop hl 
936a					ex de,hl 
936a					ld (hl), e 
936a			 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdi" 
936a						CALLMONITOR 
936a					endif 
936a					 
936a			.dirnotfound: 
936a					pop bc     
936a					djnz .diritem 
936a				 
936a			.dirdone:	 
936a			 
936a					ld a, 0 
936a					ld hl, (store_tmp2) 
936a					ld (hl), a 
936a					inc hl 
936a					ld (hl), a 
936a					inc hl 
936a					; push a count of the dir items found 
936a			 
936a			;		ld h, 0 
936a			;		ld l, c 
936a			 
936a				ret 
936a			 
936a			endif 
936a			 
936a			 
936a			; Settings 
936a			; Run  
936a			 
936a			 
936a			 
936a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
936a			;;hd_menu2:   db "        2: Editor",0   
936a			;hd_menu2:   db "        2: Editor       6: Menu",0   
936a			;hd_menu3:   db "        3: Storage",0 
936a			;hd_menu4:   db "0=quit  4: Debug",0 
936a			;hd_don:     db "ON",0 
936a			;hd_doff:     db "OFF",0 
936a			; 
936a			; 
936a			; 
936a			;hardware_diags_old:       
936a			; 
936a			;.diagmenu: 
936a			;	call clear_display 
936a			;	ld a, display_row_1 
936a			;	ld de, hd_menu1 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_2 
936a			;	ld de, hd_menu2 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_3 
936a			;	ld de, hd_menu3 
936a			;	call str_at_display 
936a			; 
936a			;	ld a,  display_row_4 
936a			;	ld de, hd_menu4 
936a			;	call str_at_display 
936a			; 
936a			;	; display debug state 
936a			; 
936a			;	ld de, hd_don 
936a			;	ld a, (os_view_disable) 
936a			;	cp 0 
936a			;	jr z, .distog 
936a			;	ld de, hd_doff 
936a			;.distog: ld a, display_row_4+17 
936a			;	call str_at_display 
936a			; 
936a			;	call update_display 
936a			; 
936a			;	call cin_wait 
936a			; 
936a			; 
936a			; 
936a			;	cp '4' 
936a			;	jr nz, .diagn1 
936a			; 
936a			;	; debug toggle 
936a			; 
936a			;	ld a, (os_view_disable) 
936a			;	ld b, '*' 
936a			;	cp 0 
936a			;	jr z, .debtog 
936a			;	ld b, 0 
936a			;.debtog:	 
936a			;	ld a,b 
936a			;	ld (os_view_disable),a 
936a			; 
936a			;.diagn1: cp '0' 
936a			;	 ret z 
936a			; 
936a			;;	cp '1' 
936a			;;       jp z, matrix	 
936a			;;   TODO keyboard matrix test 
936a			; 
936a			;	cp '2' 
936a			;	jp z, .diagedit 
936a			; 
936a			;;	cp '6' 
936a			;;	jp z, .menutest 
936a			;;if ENABLE_BASIC 
936a			;;	cp '6' 
936a			;;	jp z, basic 
936a			;;endif 
936a			 ; 
936a			;	jp .diagmenu 
936a			; 
936a			; 
936a			;	ret 
936a			 
936a			 
936a			.debug_tog: 
936a 21 b1 93			ld hl, .menudebug 
936d				 
936d 3a bc e2			ld a, (os_view_disable) 
9370 fe 2a			cp '*' 
9372 20 04			jr nz,.tdon  
9374 3e 01			ld a, 1 
9376 18 02			jr .tog1 
9378 3e 00		.tdon: ld a, 0 
937a			 
937a			.tog1: 
937a cd a6 8a			call menu 
937d fe 00			cp 0 
937f c8				ret z 
9380 fe 01			cp 1    ; disable debug 
9382 28 04			jr z, .dtog0 
9384 3e 2a			ld a, '*' 
9386 18 02			jr .dtogset 
9388 3e 00		.dtog0: ld a, 0 
938a 32 bc e2		.dtogset:  ld (os_view_disable), a 
938d c3 6a 93			jp .debug_tog 
9390			 
9390			 
9390			hardware_diags:       
9390			 
9390			.diagm: 
9390 21 a3 93			ld hl, .menuitems 
9393 3e 00			ld a, 0 
9395 cd a6 8a			call menu 
9398			 
9398 fe 00		         cp 0 
939a c8				 ret z 
939b			 
939b fe 02			cp 2 
939d ca fc 93			jp z, .diagedit 
93a0			 
93a0			;	cp '6' 
93a0			;	jp z, .menutest 
93a0			;if ENABLE_BASIC 
93a0			;	cp '6' 
93a0			;	jp z, basic 
93a0			;endif 
93a0			  
93a0 c3 90 93			jp .diagm 
93a3			 
93a3				 
93a3 b7 93		.menuitems:   	dw .m1 
93a5 c2 93				dw .m2 
93a7 c9 93				dw .m3 
93a9 d1 93				dw .m5 
93ab d7 93				dw .m5a 
93ad e0 93				dw .m5b 
93af 00 00				dw 0 
93b1			 
93b1			.menudebug: 
93b1 e9 93				dw .m6 
93b3 f2 93				dw .m7 
93b5 00 00				dw 0 
93b7			 
93b7 .. 00		.m1:   db "Key Matrix",0 
93c2 .. 00		.m2:   db "Editor",0 
93c9 .. 00		.m3:   db "Storage",0 
93d1 .. 00		.m5:   db "Sound",0 
93d7 .. 00		.m5a:  db "RAM Test",0 
93e0 .. 00		.m5b:  db "LCD Test",0 
93e9			 
93e9 .. 00		.m6:   db "Debug ON",0 
93f2 .. 00		.m7:   db "Debug OFF",0 
93fc			 
93fc			; debug editor 
93fc			 
93fc			.diagedit: 
93fc			 
93fc 21 cb e2			ld hl, scratch 
93ff			;	ld bc, 250 
93ff			;	ldir 
93ff				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93ff 3e 00			ld a, 0 
9401 77				ld (hl), a 
9402 23				inc hl 
9403 77				ld (hl), a 
9404 23				inc hl 
9405 77				ld (hl), a 
9406			 
9406 cd 75 8a		        call clear_display 
9409 cd 98 8a			call update_display 
940c				;ld a, 1 
940c				;ld (hardware_diag), a 
940c			.diloop: 
940c 3e 00			ld a, display_row_1 
940e 0e 00			ld c, 0 
9410 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9412 1e 28			ld e, 40 
9414			 
9414 21 cb e2			ld hl, scratch	 
9417 cd cf 8c			call input_str 
941a			 
941a 3e 28			ld a, display_row_2 
941c 11 cb e2			ld de, scratch 
941f cd 88 8a			call str_at_display 
9422 cd 98 8a			call update_display 
9425			 
9425 c3 0c 94			jp .diloop 
9428			 
9428			 
9428			; pass word in hl 
9428			; a has display location 
9428			display_word_at: 
9428 f5				push af 
9429 e5				push hl 
942a 7c				ld a,h 
942b 21 d0 e5			ld hl, os_word_scratch 
942e cd a3 8f			call hexout 
9431 e1				pop hl 
9432 7d				ld a,l 
9433 21 d2 e5			ld hl, os_word_scratch+2 
9436 cd a3 8f			call hexout 
9439 21 d4 e5			ld hl, os_word_scratch+4 
943c 3e 00			ld a,0 
943e 77				ld (hl),a 
943f 11 d0 e5			ld de,os_word_scratch 
9442 f1				pop af 
9443 cd 88 8a				call str_at_display 
9446 c9				ret 
9447			 
9447			display_ptr_state: 
9447			 
9447				; to restore afterwards 
9447			 
9447 d5				push de 
9448 c5				push bc 
9449 e5				push hl 
944a f5				push af 
944b			 
944b				; for use in here 
944b			 
944b			;	push bc 
944b			;	push de 
944b			;	push hl 
944b			;	push af 
944b			 
944b cd 75 8a			call clear_display 
944e			 
944e 11 21 96			ld de, .ptrstate 
9451 3e 00			ld a, display_row_1 
9453 cd 88 8a			call str_at_display 
9456			 
9456				; display debug step 
9456			 
9456			 
9456 11 71 ee			ld de, debug_mark 
9459 3e 26			ld a, display_row_1+display_cols-2 
945b cd 88 8a			call str_at_display 
945e			 
945e				; display a 
945e 11 2b 96			ld de, .ptrcliptr 
9461 3e 28			ld a, display_row_2 
9463 cd 88 8a			call str_at_display 
9466			 
9466 f1				pop af 
9467 2a 4a ea			ld hl,(cli_ptr) 
946a 3e 30			ld a, display_row_2+8 
946c cd 28 94			call display_word_at 
946f			 
946f			 
946f				; display hl 
946f			 
946f			 
946f 11 33 96			ld de, .ptrclioptr 
9472 3e 32			ld a, display_row_2+10 
9474 cd 88 8a			call str_at_display 
9477			; 
9477			;	pop hl 
9477 3e 35			ld a, display_row_2+13 
9479 2a 48 ea			ld hl,(cli_origptr) 
947c cd 28 94			call display_word_at 
947f			; 
947f			;	 
947f			;	; display de 
947f			 
947f			;	ld de, .regstatede 
947f			;	ld a, display_row_3 
947f			;	call str_at_display 
947f			 
947f			;	pop de 
947f			;	ld h,d 
947f			;	ld l, e 
947f			;	ld a, display_row_3+3 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display bc 
947f			 
947f			;	ld de, .regstatebc 
947f			;	ld a, display_row_3+10 
947f			;	call str_at_display 
947f			 
947f			;	pop bc 
947f			;	ld h,b 
947f			;	ld l, c 
947f			;	ld a, display_row_3+13 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display dsp 
947f			 
947f			;	ld de, .regstatedsp 
947f			;	ld a, display_row_4 
947f			;	call str_at_display 
947f			 
947f				 
947f			;	ld hl,(cli_data_sp) 
947f			;	ld a, display_row_4+4 
947f			;	call display_word_at 
947f			 
947f				; display rsp 
947f			 
947f 11 62 96			ld de, .regstatersp 
9482 3e 82			ld a, display_row_4+10 
9484 cd 88 8a			call str_at_display 
9487			 
9487				 
9487 2a fc e9			ld hl,(cli_ret_sp) 
948a 3e 86			ld a, display_row_4+14 
948c cd 28 94			call display_word_at 
948f			 
948f cd 98 8a			call update_display 
9492			 
9492 cd f2 89			call delay1s 
9495 cd f2 89			call delay1s 
9498 cd f2 89			call delay1s 
949b			 
949b			 
949b cd 8c 9a			call next_page_prompt 
949e			 
949e				; restore  
949e			 
949e f1				pop af 
949f e1				pop hl 
94a0 c1				pop bc 
94a1 d1				pop de 
94a2 c9				ret 
94a3			 
94a3			break_point_state: 
94a3 f5				push af 
94a4			 
94a4				; see if disabled 
94a4			 
94a4 3a bc e2			ld a, (os_view_disable) 
94a7 fe 2a			cp '*' 
94a9 20 02			jr nz, .bpsgo 
94ab f1				pop af 
94ac c9				ret 
94ad			 
94ad			.bpsgo: 
94ad f1				pop af 
94ae f5				push af 
94af 22 b8 e2			ld (os_view_hl), hl 
94b2 ed 53 b6 e2		ld (os_view_de), de 
94b6 ed 43 b4 e2		ld (os_view_bc), bc 
94ba e5				push hl 
94bb 6f				ld l, a 
94bc 26 00			ld h, 0 
94be 22 ba e2			ld (os_view_af),hl 
94c1			 
94c1 21 b7 ed				ld hl, display_fb0 
94c4 22 d2 eb				ld (display_fb_active), hl 
94c7 e1				pop hl	 
94c8			 
94c8 3e 31			ld a, '1' 
94ca fe 2a		.bps1:  cp '*' 
94cc 20 03			jr nz, .bps1b 
94ce 32 bc e2			ld (os_view_disable),a 
94d1 fe 31		.bps1b:  cp '1' 
94d3 20 14			jr nz, .bps2 
94d5			 
94d5				; display reg 
94d5			 
94d5				 
94d5			 
94d5 3a ba e2			ld a, (os_view_af) 
94d8 2a b8 e2			ld hl, (os_view_hl) 
94db ed 5b b6 e2		ld de, (os_view_de) 
94df ed 4b b4 e2		ld bc, (os_view_bc) 
94e3 cd 7d 95			call display_reg_state 
94e6 c3 69 95			jp .bpschk 
94e9			 
94e9 fe 32		.bps2:  cp '2' 
94eb 20 08			jr nz, .bps3 
94ed				 
94ed				; display hl 
94ed 2a b8 e2			ld hl, (os_view_hl) 
94f0 cd 67 96			call display_dump_at_hl 
94f3			 
94f3 18 74			jr .bpschk 
94f5			 
94f5 fe 33		.bps3:  cp '3' 
94f7 20 08			jr nz, .bps4 
94f9			 
94f9			        ; display de 
94f9 2a b6 e2			ld hl, (os_view_de) 
94fc cd 67 96			call display_dump_at_hl 
94ff			 
94ff 18 68			jr .bpschk 
9501 fe 34		.bps4:  cp '4' 
9503 20 08			jr nz, .bps5 
9505			 
9505			        ; display bc 
9505 2a b4 e2			ld hl, (os_view_bc) 
9508 cd 67 96			call display_dump_at_hl 
950b			 
950b 18 5c			jr .bpschk 
950d fe 35		.bps5:  cp '5' 
950f 20 08		        jr nz, .bps7 
9511			 
9511				; display cur ptr 
9511 2a 4a ea			ld hl, (cli_ptr) 
9514 cd 67 96			call display_dump_at_hl 
9517			 
9517 18 50			jr .bpschk 
9519 fe 36		.bps7:  cp '6' 
951b 20 08			jr nz, .bps8b 
951d				 
951d				; display cur orig ptr 
951d 2a 48 ea			ld hl, (cli_origptr) 
9520 cd 67 96			call display_dump_at_hl 
9523 18 44			jr .bpschk 
9525 fe 37		.bps8b:  cp '7' 
9527 20 08			jr nz, .bps9 
9529				 
9529				; display dsp 
9529 2a f8 e9			ld hl, (cli_data_sp) 
952c cd 67 96			call display_dump_at_hl 
952f			 
952f 18 38			jr .bpschk 
9531 fe 39		.bps9:  cp '9' 
9533 20 05			jr nz, .bps8c 
9535				 
9535				; display SP 
9535			;	ld hl, sp 
9535 cd 67 96			call display_dump_at_hl 
9538			 
9538 18 2f			jr .bpschk 
953a fe 38		.bps8c:  cp '8' 
953c 20 08			jr nz, .bps8d 
953e				 
953e				; display rsp 
953e 2a fc e9			ld hl, (cli_ret_sp) 
9541 cd 67 96			call display_dump_at_hl 
9544			 
9544 18 23			jr .bpschk 
9546 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9548 20 05			jr nz, .bps8 
954a cd 82 98			call monitor 
954d			 
954d 18 1a			jr .bpschk 
954f fe 30		.bps8:  cp '0' 
9551 20 16			jr nz, .bpschk 
9553			 
9553 21 16 ed				ld hl, display_fb1 
9556 22 d2 eb				ld (display_fb_active), hl 
9559 cd 98 8a				call update_display 
955c			 
955c				;ld a, (os_view_af) 
955c 2a b8 e2			ld hl, (os_view_hl) 
955f ed 5b b6 e2		ld de, (os_view_de) 
9563 ed 4b b4 e2		ld bc, (os_view_bc) 
9567 f1				pop af 
9568 c9				ret 
9569			 
9569			.bpschk:   
9569 cd f2 89			call delay1s 
956c 3e 9f		ld a,display_row_4 + display_cols - 1 
956e 11 8a 9a		        ld de, endprg 
9571 cd 88 8a			call str_at_display 
9574 cd 98 8a			call update_display 
9577 cd 46 e0			call cin_wait 
957a			 
957a c3 ca 94			jp .bps1 
957d			 
957d			 
957d			display_reg_state: 
957d			 
957d				; to restore afterwards 
957d			 
957d d5				push de 
957e c5				push bc 
957f e5				push hl 
9580 f5				push af 
9581			 
9581				; for use in here 
9581			 
9581 c5				push bc 
9582 d5				push de 
9583 e5				push hl 
9584 f5				push af 
9585			 
9585 cd 75 8a			call clear_display 
9588			 
9588 11 3d 96			ld de, .regstate 
958b 3e 00			ld a, display_row_1 
958d cd 88 8a			call str_at_display 
9590			 
9590				; display debug step 
9590			 
9590			 
9590 11 71 ee			ld de, debug_mark 
9593 3e 25			ld a, display_row_1+display_cols-3 
9595 cd 88 8a			call str_at_display 
9598			 
9598				; display a 
9598 11 59 96			ld de, .regstatea 
959b 3e 28			ld a, display_row_2 
959d cd 88 8a			call str_at_display 
95a0			 
95a0 e1				pop hl 
95a1			;	ld h,0 
95a1			;	ld l, a 
95a1 3e 2b			ld a, display_row_2+3 
95a3 cd 28 94			call display_word_at 
95a6			 
95a6			 
95a6				; display hl 
95a6			 
95a6			 
95a6 11 4d 96			ld de, .regstatehl 
95a9 3e 32			ld a, display_row_2+10 
95ab cd 88 8a			call str_at_display 
95ae			 
95ae e1				pop hl 
95af 3e 35			ld a, display_row_2+13 
95b1 cd 28 94			call display_word_at 
95b4			 
95b4				 
95b4				; display de 
95b4			 
95b4 11 51 96			ld de, .regstatede 
95b7 3e 50			ld a, display_row_3 
95b9 cd 88 8a			call str_at_display 
95bc			 
95bc e1				pop hl 
95bd			;	ld h,d 
95bd			;	ld l, e 
95bd 3e 53			ld a, display_row_3+3 
95bf cd 28 94			call display_word_at 
95c2			 
95c2			 
95c2				; display bc 
95c2			 
95c2 11 55 96			ld de, .regstatebc 
95c5 3e 5a			ld a, display_row_3+10 
95c7 cd 88 8a			call str_at_display 
95ca			 
95ca e1				pop hl 
95cb			;	ld h,b 
95cb			;	ld l, c 
95cb 3e 5d			ld a, display_row_3+13 
95cd cd 28 94			call display_word_at 
95d0			 
95d0			 
95d0				; display dsp 
95d0			 
95d0 11 5d 96			ld de, .regstatedsp 
95d3 3e 78			ld a, display_row_4 
95d5 cd 88 8a			call str_at_display 
95d8			 
95d8				 
95d8 2a f8 e9			ld hl,(cli_data_sp) 
95db 3e 7c			ld a, display_row_4+4 
95dd cd 28 94			call display_word_at 
95e0			 
95e0				; display rsp 
95e0			 
95e0 11 62 96			ld de, .regstatersp 
95e3 3e 82			ld a, display_row_4+10 
95e5 cd 88 8a			call str_at_display 
95e8			 
95e8				 
95e8 2a fc e9			ld hl,(cli_ret_sp) 
95eb 3e 86			ld a, display_row_4+14 
95ed cd 28 94			call display_word_at 
95f0			 
95f0 cd 98 8a			call update_display 
95f3			 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			 
95f3			 
95f3			;	call next_page_prompt 
95f3			 
95f3				; restore  
95f3			 
95f3 f1				pop af 
95f4 e1				pop hl 
95f5 c1				pop bc 
95f6 d1				pop de 
95f7 c9				ret 
95f8			 
95f8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
960c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9621 .. 00		.ptrstate:	db "Ptr State",0 
962b .. 00		.ptrcliptr:     db "cli_ptr",0 
9633 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
963d .. 00		.regstate:	db "Reg State (1/0)",0 
964d .. 00		.regstatehl:	db "HL:",0 
9651 .. 00		.regstatede:	db "DE:",0 
9655 .. 00		.regstatebc:	db "BC:",0 
9659 .. 00		.regstatea:	db "A :",0 
965d .. 00		.regstatedsp:	db "DSP:",0 
9662 .. 00		.regstatersp:	db "RSP:",0 
9667			 
9667			display_dump_at_hl: 
9667 e5				push hl 
9668 d5				push de 
9669 c5				push bc 
966a f5				push af 
966b			 
966b 22 ee e5			ld (os_cur_ptr),hl	 
966e cd 75 8a			call clear_display 
9671 cd 94 99			call dumpcont 
9674			;	call delay1s 
9674			;	call next_page_prompt 
9674			 
9674			 
9674 f1				pop af 
9675 c1				pop bc 
9676 d1				pop de 
9677 e1				pop hl 
9678 c9				ret 
9679			 
9679			;if ENABLE_BASIC 
9679			;	include "nascombasic.asm" 
9679			;	basic: 
9679			;	include "forth/FORTH.ASM" 
9679			;endif 
9679			 
9679			; eof 
9679			 
9679			 
# End of file firmware_diags.asm
9679			  
9679			include "firmware_prompts.asm"  
9679			; Prompts  
9679			 
9679			; boot messages 
9679			 
9679 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
968e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
969e			 
969e			 
969e			; config menus 
969e			 
969e .. 00		prom_c3: db "Add Dictionary To File",0 
96b5 .. 00		prom_c2: db "Select Autoload File",0 
96ca .. 00		prom_c2a: db "Disable Autoload File", 0 
96e0 .. 00		prom_c2b: db "Select Storage Bank",0 
96f4 .. 00		prom_c4: db "Settings",0 
96fd .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9718 .. 00		prom_m4b:   db "Monitor",0 
9720 .. 00		prom_c1: db "Hardware Diags",0 
972f			 
972f			 
972f .. 00		prom_notav:    db "Feature not available",0 
9745 .. 00		prom_empty:    db "",0 
9746			 
9746			; eof 
9746			 
# End of file firmware_prompts.asm
9746			  
9746			  
9746			; eof  
9746			  
# End of file firmware.asm
9746			 
9746			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9746			;if BASE_KEV  
9746			;baseram: equ 08000h 
9746			;endif 
9746			 
9746			;if BASE_SC114 
9746			;baseram:     equ    endofcode 
9746			;endif 
9746			 
9746			 
9746			; start system 
9746			 
9746			coldstart: 
9746				; set sp 
9746				; di/ei 
9746			 
9746 f3				di 
9747 31 00 f0			ld sp, tos 
974a			;	ei 
974a			 
974a			 
974a				; disable breakpoint by default 
974a			 
974a 3e 2a			ld a,'*' 
974c 32 bc e2			ld (os_view_disable),a 
974f			 
974f				; init hardware 
974f			 
974f				; init keyboard and screen hardware 
974f			 
974f cd 1c 80			call hardware_init 
9752			 
9752			 
9752 cd f2 89			call delay1s 
9755 3e 58			ld a, display_row_3+8 
9757 11 03 80			ld de, buildtime 
975a cd 88 8a			call str_at_display 
975d cd 98 8a			call update_display 
9760			 
9760 cd f2 89			call delay1s 
9763 cd f2 89			call delay1s 
9766 cd f2 89			call delay1s 
9769			 
9769				; detect if any keys are held down to enable breakpoints at start up 
9769			 
9769 cd 4c e0			call cin  
976c fe 00			cp 0 
976e 28 03			jr z, .nokeys 
9770			 
9770				;call hardware_diags 
9770 cd 02 93			call config 
9773			 
9773			;	ld de, .bpen 
9773			;	ld a, display_row_4 
9773			;	call str_at_display 
9773			;	call update_display 
9773			; 
9773			;	ld a,0 
9773			;	ld (os_view_disable),a 
9773			; 
9773			;.bpwait: 
9773			;	call cin 
9773			;	cp 0 
9773			;	jr z, .bpwait 
9773			;	jr .nokeys 
9773			; 
9773			; 
9773			;.bpen:  db "Break points enabled!",0 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			.nokeys: 
9773			 
9773			 
9773				 
9773			 
9773			;jp  testkey 
9773			 
9773			;call storage_get_block_0 
9773			; 
9773			;ld hl, 0 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773				 
9773			;ld hl, 10 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			;stop:	nop 
9773			;	jp stop 
9773			 
9773			 
9773			 
9773			main: 
9773 cd 75 8a			call clear_display 
9776 cd 98 8a			call update_display 
9779			 
9779			 
9779			 
9779			;	call testlcd 
9779			 
9779			 
9779			 
9779 cd 8a 9e			call forth_init 
977c			 
977c			 
977c			warmstart: 
977c cd 60 9e			call forth_warmstart 
977f			 
977f				; run startup word load 
977f			        ; TODO prevent this running at warmstart after crash  
977f			 
977f				if STARTUP_ENABLE 
977f					if STORAGE_SE 
977f						call forth_autoload 
977f					endif 
977f cd e0 dc				call forth_startup 
9782			 
9782			 
9782				endif 
9782			 
9782				; show free memory after boot 
9782 11 1c 98			ld de, freeram 
9785 3e 00			ld a, display_row_1 
9787 cd 88 8a			call str_at_display 
978a			 
978a			; Or use heap_size word???? 
978a 21 b1 e2			ld hl, heap_end 
978d 11 6a e0			ld de, heap_start 
9790 ed 52			sbc hl, de 
9792 e5				push hl 
9793 7c				ld a,h	         	 
9794 21 d0 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9797 cd a3 8f			call hexout 
979a e1			   	pop hl 
979b			 
979b 7d				ld a,l 
979c 21 d2 e5			ld hl, os_word_scratch+2 
979f cd a3 8f			call hexout 
97a2 21 d4 e5			ld hl, os_word_scratch+4 
97a5 3e 00			ld a, 0 
97a7 77				ld (hl),a 
97a8 11 d0 e5			ld de, os_word_scratch 
97ab 3e 0d			ld a, display_row_1 + 13 
97ad cd 88 8a			call str_at_display 
97b0 cd 98 8a			call update_display 
97b3			 
97b3			 
97b3				;call demo 
97b3			 
97b3			 
97b3				; init scratch input area for cli commands 
97b3			 
97b3 21 f2 e5			ld hl, os_cli_cmd 
97b6 3e 00			ld a,0 
97b8 77				ld (hl),a 
97b9 23				inc hl 
97ba 77				ld (hl),a 
97bb			 
97bb 3e 00			ld a,0 
97bd 32 f1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97c0			 
97c0 32 ee e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97c3 32 ef e5			ld (os_cur_ptr+1),a	 
97c6			 
97c6 32 d0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97c9 32 d1 e5			ld (os_word_scratch+1),a	 
97cc				 
97cc			 
97cc				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97cc 21 f2 e5			ld hl, os_cli_cmd 
97cf			 
97cf 3e 00			ld a, 0		 ; init cli input 
97d1 77				ld (hl), a 
97d2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d4			cli: 
97d4				; show cli prompt 
97d4				;push af 
97d4				;ld a, 0 
97d4				;ld de, prompt 
97d4				;call str_at_display 
97d4			 
97d4				;call update_display 
97d4				;pop af 
97d4				;inc a 
97d4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d4 0e 00			ld c, 0 
97d6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d8 1e 28			ld e, 40 
97da			 
97da 21 f2 e5			ld hl, os_cli_cmd 
97dd			 
97dd				STACKFRAME OFF $fefe $9f9f 
97dd				if DEBUG_STACK_IMB 
97dd					if OFF 
97dd						exx 
97dd						ld de, $fefe 
97dd						ld a, d 
97dd						ld hl, curframe 
97dd						call hexout 
97dd						ld a, e 
97dd						ld hl, curframe+2 
97dd						call hexout 
97dd						ld hl, $fefe 
97dd						push hl 
97dd						ld hl, $9f9f 
97dd						push hl 
97dd						exx 
97dd					endif 
97dd				endif 
97dd			endm 
# End of macro STACKFRAME
97dd			 
97dd cd cf 8c			call input_str 
97e0			 
97e0				STACKFRAMECHK OFF $fefe $9f9f 
97e0				if DEBUG_STACK_IMB 
97e0					if OFF 
97e0						exx 
97e0						ld hl, $9f9f 
97e0						pop de   ; $9f9f 
97e0						call cmp16 
97e0						jr nz, .spnosame 
97e0						ld hl, $fefe 
97e0						pop de   ; $fefe 
97e0						call cmp16 
97e0						jr z, .spfrsame 
97e0						.spnosame: call showsperror 
97e0						.spfrsame: nop 
97e0						exx 
97e0					endif 
97e0				endif 
97e0			endm 
# End of macro STACKFRAMECHK
97e0			 
97e0				; copy input to last command 
97e0			 
97e0 21 f2 e5			ld hl, os_cli_cmd 
97e3 11 f1 e6			ld de, os_last_cmd 
97e6 01 ff 00			ld bc, 255 
97e9 ed b0			ldir 
97eb			 
97eb				; wipe current buffer 
97eb			 
97eb			;	ld a, 0 
97eb			;	ld hl, os_cli_cmd 
97eb			;	ld de, os_cli_cmd+1 
97eb			;	ld bc, 254 
97eb			;	ldir 
97eb				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97eb			;	call strcpy 
97eb			;	ld a, 0 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			 
97eb				; switch frame buffer to program  
97eb			 
97eb 21 16 ed				ld hl, display_fb1 
97ee 22 d2 eb				ld (display_fb_active), hl 
97f1			 
97f1			;	nop 
97f1				STACKFRAME ON $fbfe $8f9f 
97f1				if DEBUG_STACK_IMB 
97f1					if ON 
97f1						exx 
97f1						ld de, $fbfe 
97f1						ld a, d 
97f1						ld hl, curframe 
97f1						call hexout 
97f1						ld a, e 
97f1						ld hl, curframe+2 
97f1						call hexout 
97f1						ld hl, $fbfe 
97f1						push hl 
97f1						ld hl, $8f9f 
97f1						push hl 
97f1						exx 
97f1					endif 
97f1				endif 
97f1			endm 
# End of macro STACKFRAME
97f1				; first time into the parser so pass over the current scratch pad 
97f1 21 f2 e5			ld hl,os_cli_cmd 
97f4				; tokenise the entered statement(s) in HL 
97f4 cd 08 9f			call forthparse 
97f7			        ; exec forth statements in top of return stack 
97f7 cd 48 9f			call forthexec 
97fa				;call forthexec_cleanup 
97fa			;	call parsenext 
97fa			 
97fa				STACKFRAMECHK ON $fbfe $8f9f 
97fa				if DEBUG_STACK_IMB 
97fa					if ON 
97fa						exx 
97fa						ld hl, $8f9f 
97fa						pop de   ; $8f9f 
97fa						call cmp16 
97fa						jr nz, .spnosame 
97fa						ld hl, $fbfe 
97fa						pop de   ; $fbfe 
97fa						call cmp16 
97fa						jr z, .spfrsame 
97fa						.spnosame: call showsperror 
97fa						.spfrsame: nop 
97fa						exx 
97fa					endif 
97fa				endif 
97fa			endm 
# End of macro STACKFRAMECHK
97fa				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97fa			 
97fa 3e 78			ld a, display_row_4 
97fc 11 2e 98			ld de, endprog 
97ff			 
97ff cd 98 8a			call update_display		 
9802			 
9802 cd 8c 9a			call next_page_prompt 
9805			 
9805				; switch frame buffer to cli 
9805			 
9805 21 b7 ed				ld hl, display_fb0 
9808 22 d2 eb				ld (display_fb_active), hl 
980b			 
980b			 
980b cd 75 8a		        call clear_display 
980e cd 98 8a			call update_display		 
9811			 
9811 21 f2 e5			ld hl, os_cli_cmd 
9814			 
9814 3e 00			ld a, 0		 ; init cli input 
9816 77				ld (hl), a 
9817			 
9817				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9817			 
9817				; now on last line 
9817			 
9817				; TODO scroll screen up 
9817			 
9817				; TODO instead just clear screen and place at top of screen 
9817			 
9817			;	ld a, 0 
9817			;	ld (f_cursor_ptr),a 
9817			 
9817				;call clear_display 
9817				;call update_display 
9817			 
9817				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9817 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9819 c3 d4 97			jp cli 
981c			 
981c .. 00		freeram: db "Free bytes: $",0 
982a ..			asc: db "1A2F" 
982e .. 00		endprog: db "End prog...",0 
983a			 
983a			testenter2:   
983a 21 fd e2			ld hl,scratch+50 
983d 22 ee e5			ld (os_cur_ptr),hl 
9840 c3 d4 97			jp cli 
9843			 
9843			testenter:  
9843			 
9843 21 2a 98			ld hl,asc 
9846			;	ld a,(hl) 
9846			;	call nibble2val 
9846 cd f9 8f			call get_byte 
9849			 
9849			 
9849			;	ld a,(hl) 
9849			;	call atohex 
9849			 
9849			;	call fourehexhl 
9849 32 fd e2			ld (scratch+50),a 
984c			 
984c			 
984c			 
984c 21 2c 98			ld hl,asc+2 
984f			;	ld a, (hl) 
984f			;	call nibble2val 
984f cd f9 8f			call get_byte 
9852			 
9852			;	call fourehexhl 
9852 32 ff e2			ld (scratch+52),a 
9855				 
9855 21 fd e2			ld hl,scratch+50 
9858 22 ee e5			ld (os_cur_ptr),hl 
985b c3 d4 97			jp cli 
985e			 
985e			enter:	 
985e 3a cf e2			ld a,(scratch+4) 
9861 fe 00			cp 0 
9863 28 0c			jr z, .entercont 
9865				; no, not a null term line so has an address to work out.... 
9865			 
9865 21 cd e2			ld hl,scratch+2 
9868 cd 59 90			call get_word_hl 
986b			 
986b 22 ee e5			ld (os_cur_ptr),hl	 
986e c3 d4 97			jp cli 
9871			 
9871			 
9871			.entercont:  
9871			 
9871 21 cd e2			ld hl, scratch+2 
9874 cd f9 8f			call get_byte 
9877			 
9877 2a ee e5		   	ld hl,(os_cur_ptr) 
987a 77					ld (hl),a 
987b 23					inc hl 
987c 22 ee e5				ld (os_cur_ptr),hl 
987f				 
987f			; get byte  
987f			 
987f			 
987f c3 d4 97			jp cli 
9882			 
9882			 
9882			; basic monitor support 
9882			 
9882			monitor: 
9882				;  
9882 cd 75 8a			call clear_display 
9885 3e 00			ld a, 0 
9887 11 cf 98			ld de, .monprompt 
988a cd 88 8a			call str_at_display 
988d cd 98 8a			call update_display 
9890			 
9890				; get a monitor command 
9890			 
9890 0e 00			ld c, 0     ; entry at top left 
9892 16 64			ld d, 100   ; max buffer size 
9894 1e 0f			ld e, 15    ; input scroll area 
9896 3e 00			ld a, 0     ; init string 
9898 21 c9 e4			ld hl, os_input 
989b 77				ld (hl), a 
989c 23				inc hl 
989d 77				ld (hl), a 
989e 21 c9 e4			ld hl, os_input 
98a1 3e 01			ld a, 1     ; init string 
98a3 cd cf 8c			call input_str 
98a6			 
98a6 cd 75 8a		        call clear_display 
98a9 cd 98 8a			call update_display		 
98ac			 
98ac 3a c9 e4			ld a, (os_input) 
98af cd f7 90			call toUpper 
98b2 fe 48		        cp 'H' 
98b4 28 6f		        jr z, .monhelp 
98b6 fe 44			cp 'D'		; dump 
98b8 ca 46 99			jp z, .mondump	 
98bb fe 43			cp 'C'		; dump 
98bd ca 60 99			jp z, .moncdump	 
98c0 fe 4d			cp 'M'		; dump 
98c2 ca d1 98			jp z, .moneditstart 
98c5 fe 55			cp 'U'		; dump 
98c7 28 14			jr z, .monedit	 
98c9 fe 51			cp 'Q'		; dump 
98cb c8				ret z	 
98cc			 
98cc			 
98cc				; TODO "S" to access symbol by name and not need the address 
98cc				; TODO "F" to find a string in memory 
98cc			 
98cc c3 82 98			jp monitor 
98cf			 
98cf .. 00		.monprompt: db ">", 0 
98d1			 
98d1			.moneditstart: 
98d1				; get starting address 
98d1			 
98d1 21 cb e4			ld hl,os_input+2 
98d4 cd 59 90			call get_word_hl 
98d7			 
98d7 22 ee e5			ld (os_cur_ptr),hl	 
98da			 
98da c3 82 98			jp monitor 
98dd			 
98dd			.monedit: 
98dd				; get byte to load 
98dd			 
98dd 21 cb e4			ld hl,os_input+2 
98e0 cd f9 8f			call get_byte 
98e3			 
98e3				; get address to update 
98e3 2a ee e5			ld hl, (os_cur_ptr) 
98e6			 
98e6				; update byte 
98e6			 
98e6 77				ld (hl), a 
98e7			 
98e7				; move to next address and save it 
98e7			 
98e7 23				inc hl 
98e8 22 ee e5			ld (os_cur_ptr),hl	 
98eb			 
98eb c3 82 98			jp monitor 
98ee			 
98ee			 
98ee .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9902 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
991e .. 00		.monhelptext3:  db "Q-Quit",0 
9925			        
9925			.monhelp: 
9925 3e 00			ld a, display_row_1 
9927 11 ee 98		        ld de, .monhelptext1 
992a			 
992a cd 88 8a			call str_at_display 
992d 3e 28			ld a, display_row_2 
992f 11 02 99		        ld de, .monhelptext2 
9932					 
9932 cd 88 8a			call str_at_display 
9935 3e 50			ld a, display_row_3 
9937 11 1e 99		        ld de, .monhelptext3 
993a					 
993a cd 88 8a			call str_at_display 
993d cd 98 8a			call update_display		 
9940			 
9940 cd 8c 9a			call next_page_prompt 
9943 c3 82 98			jp monitor 
9946			 
9946			.mondump:    
9946 21 cb e4			ld hl,os_input+2 
9949 cd 59 90			call get_word_hl 
994c			 
994c 22 ee e5			ld (os_cur_ptr),hl	 
994f cd 94 99			call dumpcont 
9952 3e 78			ld a, display_row_4 
9954 11 2e 98			ld de, endprog 
9957			 
9957 cd 98 8a			call update_display		 
995a			 
995a cd 8c 9a			call next_page_prompt 
995d c3 82 98			jp monitor 
9960			.moncdump: 
9960 cd 94 99			call dumpcont 
9963 3e 78			ld a, display_row_4 
9965 11 2e 98			ld de, endprog 
9968			 
9968 cd 98 8a			call update_display		 
996b			 
996b cd 8c 9a			call next_page_prompt 
996e c3 82 98			jp monitor 
9971			 
9971			 
9971			; TODO symbol access  
9971			 
9971			.symbols:     ;; A list of symbols that can be called up  
9971 b7 ed			dw display_fb0 
9973 .. 00			db "fb0",0  
9977 84 ea		     	dw store_page 
9979 .. 00			db "store_page",0 
9984			 
9984			 
9984			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9984			 
9984 3a cc e2			ld a,(scratch+1) 
9987 fe 00			cp 0 
9989 28 09			jr z, dumpcont 
998b			 
998b				; no, not a null term line so has an address to work out.... 
998b			 
998b 21 cd e2			ld hl,scratch+2 
998e cd 59 90			call get_word_hl 
9991			 
9991 22 ee e5			ld (os_cur_ptr),hl	 
9994			 
9994			 
9994			 
9994			dumpcont: 
9994			 
9994				; dump bytes at ptr 
9994			 
9994			 
9994 3e 00			ld a, display_row_1 
9996 2a d2 eb			ld hl, (display_fb_active) 
9999 cd a2 8c			call addatohl 
999c cd c4 99			call .dumpbyterow 
999f			 
999f 3e 28			ld a, display_row_2 
99a1 2a d2 eb			ld hl, (display_fb_active) 
99a4 cd a2 8c			call addatohl 
99a7 cd c4 99			call .dumpbyterow 
99aa			 
99aa			 
99aa 3e 50			ld a, display_row_3 
99ac 2a d2 eb			ld hl, (display_fb_active) 
99af cd a2 8c			call addatohl 
99b2 cd c4 99			call .dumpbyterow 
99b5			 
99b5 3e 78			ld a, display_row_4 
99b7 2a d2 eb			ld hl, (display_fb_active) 
99ba cd a2 8c			call addatohl 
99bd cd c4 99			call .dumpbyterow 
99c0			 
99c0 cd 98 8a			call update_display 
99c3			;		jp cli 
99c3 c9				ret 
99c4			 
99c4			.dumpbyterow: 
99c4			 
99c4				;push af 
99c4			 
99c4 e5				push hl 
99c5			 
99c5				; calc where to poke the ascii 
99c5			if display_cols == 20 
99c5				ld a, 16 
99c5			else 
99c5 3e 1f			ld a, 31 
99c7			endif 
99c7			 
99c7 cd a2 8c			call addatohl 
99ca 22 d0 e5			ld (os_word_scratch),hl  		; save pos for later 
99cd			 
99cd			 
99cd			; display decoding address 
99cd 2a ee e5		   	ld hl,(os_cur_ptr) 
99d0			 
99d0 7c				ld a,h 
99d1 e1				pop hl 
99d2 e5				push hl 
99d3			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99d3 cd a3 8f			call hexout 
99d6 2a ee e5		   	ld hl,(os_cur_ptr) 
99d9			 
99d9 7d				ld a,l 
99da e1				pop hl 
99db 23				inc hl 
99dc 23				inc hl 
99dd e5				push hl 
99de			;	ld hl, os_word_scratch+2 
99de cd a3 8f			call hexout 
99e1 e1				pop hl 
99e2 23				inc hl 
99e3 23				inc hl 
99e4				;ld hl, os_word_scratch+4 
99e4 3e 3a			ld a, ':' 
99e6 77				ld (hl),a 
99e7 23				inc hl 
99e8				;ld a, 0 
99e8				;ld (hl),a 
99e8				;ld de, os_word_scratch 
99e8				;pop af 
99e8				;push af 
99e8			;		ld a, display_row_2 
99e8			;		call str_at_display 
99e8			;		call update_display 
99e8			 
99e8			 
99e8			;pop af 
99e8			;	add 5 
99e8			 
99e8			if display_cols == 20 
99e8				ld b, 4 
99e8			else 
99e8 06 08			ld b, 8 
99ea			endif	 
99ea			 
99ea			.dumpbyte: 
99ea c5				push bc 
99eb e5				push hl 
99ec			 
99ec			 
99ec 2a ee e5		   	ld hl,(os_cur_ptr) 
99ef 7e					ld a,(hl) 
99f0			 
99f0					; poke the ascii to display 
99f0 2a d0 e5				ld hl,(os_word_scratch) 
99f3 77					ld (hl),a 
99f4 23					inc hl 
99f5 22 d0 e5				ld (os_word_scratch),hl 
99f8			 
99f8					 
99f8			 
99f8			 
99f8 e1					pop hl 
99f9 e5					push hl 
99fa			 
99fa cd a3 8f				call hexout 
99fd			 
99fd					 
99fd 2a ee e5		   	ld hl,(os_cur_ptr) 
9a00 23				inc hl 
9a01 22 ee e5		   	ld (os_cur_ptr),hl 
9a04			 
9a04 e1					pop hl 
9a05 23					inc hl 
9a06 23					inc hl 
9a07 23					inc hl 
9a08			 
9a08			 
9a08			 
9a08					;ld a,0 
9a08					;ld (os_word_scratch+2),a 
9a08					;pop af 
9a08					;push af 
9a08			 
9a08					;ld de, os_word_scratch 
9a08					;call str_at_display 
9a08			;		call update_display 
9a08			;		pop af 
9a08 c1					pop bc 
9a09 c6 03				add 3 
9a0b 10 dd			djnz .dumpbyte 
9a0d			 
9a0d				 
9a0d			 
9a0d c9				ret 
9a0e			 
9a0e			jump:	 
9a0e			 
9a0e 21 cd e2			ld hl,scratch+2 
9a11 cd 59 90			call get_word_hl 
9a14				;ld hl,(scratch+2) 
9a14				;call fourehexhl 
9a14			 
9a14 22 ee e5			ld (os_cur_ptr),hl	 
9a17			 
9a17 e9				jp (hl) 
9a18			 
9a18			 
9a18			 
9a18			; TODO implement a basic monitor mode to start with 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			; testing and demo code during development 
9a18			 
9a18			 
9a18 .. 00		str1: db "Enter some text...",0 
9a2b .. 00		clear: db "                    ",0 
9a40			 
9a40			demo: 
9a40			 
9a40			 
9a40			 
9a40			;	call update_display 
9a40			 
9a40				; init scratch input area for testing 
9a40 21 cb e2			ld hl, scratch	 
9a43 3e 00			ld a,0 
9a45 77				ld (hl),a 
9a46			 
9a46			 
9a46 3e 28		            LD   A, display_row_2 
9a48			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a48 11 18 9a		            LD   DE, str1 
9a4b cd 88 8a			call str_at_display 
9a4e			 
9a4e			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a4e			cloop:	 
9a4e 3e 50		            LD   A, display_row_3 
9a50			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a50 11 2b 9a		            LD   DE, clear 
9a53			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a53 cd 88 8a				call str_at_display 
9a56 3e 78			ld a, display_row_4 
9a58 11 88 9a			ld de, prompt 
9a5b			 
9a5b cd 88 8a				call str_at_display 
9a5e cd 98 8a			call update_display 
9a61			 
9a61 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a63 16 0a			ld d, 10 
9a65 21 cb e2			ld hl, scratch	 
9a68 cd cf 8c			call input_str 
9a6b			 
9a6b			;	call clear_display 
9a6b			;'	call update_display 
9a6b			 
9a6b 3e 00		            LD   A, display_row_1 
9a6d			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a6d 11 2b 9a		            LD   DE, clear 
9a70 cd 88 8a				call str_at_display 
9a73			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a73 3e 00		            LD   A, display_row_1 
9a75			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a75 11 cb e2		            LD   DE, scratch 
9a78			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a78 cd 88 8a				call str_at_display 
9a7b cd 98 8a			call update_display 
9a7e			 
9a7e 3e 00				ld a,0 
9a80 21 cb e2			ld hl, scratch 
9a83 77				ld (hl),a 
9a84			 
9a84 00				nop 
9a85 c3 4e 9a			jp cloop 
9a88			 
9a88			 
9a88			 
9a88			; OS Prompt 
9a88			 
9a88 .. 00		prompt: db ">",0 
9a8a .. 00		endprg: db "?",0 
9a8c			 
9a8c			 
9a8c			; handy next page prompt 
9a8c			next_page_prompt: 
9a8c e5				push hl 
9a8d d5				push de 
9a8e f5				push af 
9a8f c5				push bc 
9a90			 
9a90 3e 9f			ld a,display_row_4 + display_cols - 1 
9a92 11 8a 9a		        ld de, endprg 
9a95 cd 88 8a			call str_at_display 
9a98 cd 98 8a			call update_display 
9a9b cd 46 e0			call cin_wait 
9a9e c1				pop bc 
9a9f f1				pop af 
9aa0 d1				pop de 
9aa1 e1				pop hl 
9aa2			 
9aa2			 
9aa2 c9				ret 
9aa3			 
9aa3			 
9aa3			; forth parser 
9aa3			 
9aa3			; My forth kernel 
9aa3			include "forth_kernel.asm" 
9aa3			; 
9aa3			; kernel to the forth OS 
9aa3			 
9aa3			DS_TYPE_STR: equ 1     ; string type 
9aa3			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9aa3			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9aa3			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9aa3			 
9aa3			FORTH_PARSEV1: equ 0 
9aa3			FORTH_PARSEV2: equ 0 
9aa3			FORTH_PARSEV3: equ 0 
9aa3			FORTH_PARSEV4: equ 0 
9aa3			FORTH_PARSEV5: equ 1 
9aa3			 
9aa3			;if FORTH_PARSEV5 
9aa3			;	FORTH_END_BUFFER: equ 0 
9aa3			;else 
9aa3			FORTH_END_BUFFER: equ 127 
9aa3			;endif 
9aa3			 
9aa3			FORTH_TRUE: equ 1 
9aa3			FORTH_FALSE: equ 0 
9aa3			 
9aa3			if FORTH_PARSEV4 
9aa3			include "forth_stackops.asm" 
9aa3			endif 
9aa3			 
9aa3			if FORTH_PARSEV5 
9aa3			include "forth_stackopsv5.asm" 
9aa3			 
9aa3			; Stack operations for v5 parser on wards 
9aa3			; * DATA stack 
9aa3			; * LOOP stack 
9aa3			; * RETURN stack 
9aa3			 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_DSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_data_sp) 
9aa3				ld de, cli_data_stack 
9aa3				call cmp16 
9aa3				jp c, fault_dsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_RSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_ret_sp) 
9aa3				ld de, cli_ret_stack 
9aa3				call cmp16 
9aa3				jp c, fault_rsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_CHK_LOOP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_loop_sp) 
9aa3				ld de, cli_loop_stack 
9aa3				call cmp16 
9aa3				jp c, fault_loop_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTSTR: macro 
9aa3				; TOSO might need more for checks when used 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_STR 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTNUM: macro 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_INUM 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			; increase data stack pointer and save hl to it 
9aa3				 
9aa3			FORTH_DSP_NEXT: macro 
9aa3				call macro_forth_dsp_next 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			macro_forth_dsp_next: 
9aa3				if DEBUG_FORTH_STACK_GUARD 
9aa3 cd aa dd				call check_stacks 
9aa6				endif 
9aa6 e5				push hl 
9aa7 d5				push de 
9aa8 eb				ex de,hl 
9aa9 2a f8 e9			ld hl,(cli_data_sp) 
9aac 23				inc hl 
9aad 23				inc hl 
9aae			 
9aae			; PARSEV5 
9aae 23				inc hl 
9aaf 22 f8 e9			ld (cli_data_sp),hl 
9ab2 73				ld (hl), e 
9ab3 23				inc hl 
9ab4 72				ld (hl), d 
9ab5 d1				pop de 
9ab6 e1				pop hl 
9ab7				if DEBUG_FORTH_STACK_GUARD 
9ab7 cd aa dd				call check_stacks 
9aba				endif 
9aba c9				ret 
9abb			 
9abb			 
9abb			; increase ret stack pointer and save hl to it 
9abb				 
9abb			FORTH_RSP_NEXT: macro 
9abb				call macro_forth_rsp_next 
9abb				endm 
9abb			 
9abb			macro_forth_rsp_next: 
9abb				if DEBUG_FORTH_STACK_GUARD 
9abb cd aa dd				call check_stacks 
9abe				endif 
9abe e5				push hl 
9abf d5				push de 
9ac0 eb				ex de,hl 
9ac1 2a fc e9			ld hl,(cli_ret_sp) 
9ac4 23				inc hl 
9ac5 23				inc hl 
9ac6 22 fc e9			ld (cli_ret_sp),hl 
9ac9 73				ld (hl), e 
9aca 23				inc hl 
9acb 72				ld (hl), d 
9acc d1				pop de 
9acd e1				pop hl 
9ace				if DEBUG_FORTH_STACK_GUARD 
9ace cd aa dd				call check_stacks 
9ad1				endif 
9ad1 c9				ret 
9ad2			 
9ad2			; get current ret stack pointer and save to hl  
9ad2				 
9ad2			FORTH_RSP_TOS: macro 
9ad2				call macro_forth_rsp_tos 
9ad2				endm 
9ad2			 
9ad2			macro_forth_rsp_tos: 
9ad2				;push de 
9ad2 2a fc e9			ld hl,(cli_ret_sp) 
9ad5 cd 0d 9b			call loadhlptrtohl 
9ad8				;ld e, (hl) 
9ad8				;inc hl 
9ad8				;ld d, (hl) 
9ad8				;ex de, hl 
9ad8					if DEBUG_FORTH_WORDS 
9ad8			;			DMARK "RST" 
9ad8						CALLMONITOR 
9ad8 cd a3 94			call break_point_state  
9adb				endm  
# End of macro CALLMONITOR
9adb					endif 
9adb				;pop de 
9adb c9				ret 
9adc			 
9adc			; pop ret stack pointer 
9adc				 
9adc			FORTH_RSP_POP: macro 
9adc				call macro_forth_rsp_pop 
9adc				endm 
9adc			 
9adc			 
9adc			macro_forth_rsp_pop: 
9adc				if DEBUG_FORTH_STACK_GUARD 
9adc			;		DMARK "RPP" 
9adc cd aa dd				call check_stacks 
9adf					FORTH_CHK_RSP_UNDER 
9adf e5				push hl 
9ae0 d5				push de 
9ae1 2a fc e9			ld hl,(cli_ret_sp) 
9ae4 11 b6 e9			ld de, cli_ret_stack 
9ae7 cd c0 8c			call cmp16 
9aea da be de			jp c, fault_rsp_under 
9aed d1				pop de 
9aee e1				pop hl 
9aef				endm 
# End of macro FORTH_CHK_RSP_UNDER
9aef				endif 
9aef e5				push hl 
9af0 2a fc e9			ld hl,(cli_ret_sp) 
9af3			 
9af3			 
9af3				if FORTH_ENABLE_FREE 
9af3			 
9af3					; get pointer 
9af3			 
9af3					push de 
9af3					push hl 
9af3			 
9af3					ld e, (hl) 
9af3					inc hl 
9af3					ld d, (hl) 
9af3			 
9af3					ex de, hl 
9af3					call free 
9af3			 
9af3					pop hl 
9af3					pop de 
9af3			 
9af3			 
9af3				endif 
9af3			 
9af3			 
9af3 2b				dec hl 
9af4 2b				dec hl 
9af5 22 fc e9			ld (cli_ret_sp), hl 
9af8				; do stack underflow checks 
9af8 e1				pop hl 
9af9				if DEBUG_FORTH_STACK_GUARD 
9af9 cd aa dd				call check_stacks 
9afc					FORTH_CHK_RSP_UNDER 
9afc e5				push hl 
9afd d5				push de 
9afe 2a fc e9			ld hl,(cli_ret_sp) 
9b01 11 b6 e9			ld de, cli_ret_stack 
9b04 cd c0 8c			call cmp16 
9b07 da be de			jp c, fault_rsp_under 
9b0a d1				pop de 
9b0b e1				pop hl 
9b0c				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b0c				endif 
9b0c c9				ret 
9b0d			 
9b0d			 
9b0d			 
9b0d			; routine to load word pointed to by hl into hl 
9b0d			 
9b0d			loadhlptrtohl: 
9b0d			 
9b0d d5				push de 
9b0e 5e				ld e, (hl) 
9b0f 23				inc hl 
9b10 56				ld d, (hl) 
9b11 eb				ex de, hl 
9b12 d1				pop de 
9b13			 
9b13 c9				ret 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			; push a number held in HL onto the data stack 
9b14			; entry point for pushing a value when already in hl used in function above 
9b14			 
9b14			forth_push_numhl: 
9b14			 
9b14 e5				push hl    ; save value to push 
9b15			 
9b15			if DEBUG_FORTH_PUSH 
9b15				; see if disabled 
9b15			 
9b15			 
9b15 f5				push af 
9b16 3a bc e2			ld a, (os_view_disable) 
9b19 fe 2a			cp '*' 
9b1b 28 34			jr z, .pskip2 
9b1d e5				push hl 
9b1e e5			push hl 
9b1f cd 75 8a			call clear_display 
9b22 e1			pop hl 
9b23 7c				ld a,h 
9b24 21 d0 e5			ld hl, os_word_scratch 
9b27 cd a3 8f			call hexout 
9b2a e1				pop hl 
9b2b 7d				ld a,l 
9b2c 21 d2 e5			ld hl, os_word_scratch+2 
9b2f cd a3 8f			call hexout 
9b32			 
9b32 21 d4 e5			ld hl, os_word_scratch+4 
9b35 3e 00			ld a,0 
9b37 77				ld (hl),a 
9b38 11 d0 e5			ld de,os_word_scratch 
9b3b 3e 28				ld a, display_row_2 
9b3d cd 88 8a				call str_at_display 
9b40 11 46 c9			ld de, .push_num 
9b43 3e 00			ld a, display_row_1 
9b45			 
9b45 cd 88 8a				call str_at_display 
9b48			 
9b48			 
9b48 cd 98 8a			call update_display 
9b4b cd f2 89			call delay1s 
9b4e cd f2 89			call delay1s 
9b51			.pskip2:  
9b51			 
9b51 f1				pop af 
9b52			endif	 
9b52			 
9b52			 
9b52				FORTH_DSP_NEXT 
9b52 cd a3 9a			call macro_forth_dsp_next 
9b55				endm 
# End of macro FORTH_DSP_NEXT
9b55			 
9b55 2a f8 e9			ld hl, (cli_data_sp) 
9b58			 
9b58				; save item type 
9b58 3e 02			ld a,  DS_TYPE_INUM 
9b5a 77				ld (hl), a 
9b5b 23				inc hl 
9b5c			 
9b5c				; get word off stack 
9b5c d1				pop de 
9b5d 7b				ld a,e 
9b5e 77				ld (hl), a 
9b5f 23				inc hl 
9b60 7a				ld a,d 
9b61 77				ld (hl), a 
9b62			 
9b62			if DEBUG_FORTH_PUSH 
9b62 2b				dec hl 
9b63 2b				dec hl 
9b64 2b				dec hl 
9b65						DMARK "PH5" 
9b65 f5				push af  
9b66 3a 7a 9b			ld a, (.dmark)  
9b69 32 71 ee			ld (debug_mark),a  
9b6c 3a 7b 9b			ld a, (.dmark+1)  
9b6f 32 72 ee			ld (debug_mark+1),a  
9b72 3a 7c 9b			ld a, (.dmark+2)  
9b75 32 73 ee			ld (debug_mark+2),a  
9b78 18 03			jr .pastdmark  
9b7a ..			.dmark: db "PH5"  
9b7d f1			.pastdmark: pop af  
9b7e			endm  
# End of macro DMARK
9b7e				CALLMONITOR 
9b7e cd a3 94			call break_point_state  
9b81				endm  
# End of macro CALLMONITOR
9b81			endif	 
9b81			 
9b81 c9				ret 
9b82			 
9b82			 
9b82			; Push a string to stack pointed to by hl 
9b82			 
9b82			forth_push_str: 
9b82			 
9b82			if DEBUG_FORTH_PUSH 
9b82						DMARK "PSQ" 
9b82 f5				push af  
9b83 3a 97 9b			ld a, (.dmark)  
9b86 32 71 ee			ld (debug_mark),a  
9b89 3a 98 9b			ld a, (.dmark+1)  
9b8c 32 72 ee			ld (debug_mark+1),a  
9b8f 3a 99 9b			ld a, (.dmark+2)  
9b92 32 73 ee			ld (debug_mark+2),a  
9b95 18 03			jr .pastdmark  
9b97 ..			.dmark: db "PSQ"  
9b9a f1			.pastdmark: pop af  
9b9b			endm  
# End of macro DMARK
9b9b				CALLMONITOR 
9b9b cd a3 94			call break_point_state  
9b9e				endm  
# End of macro CALLMONITOR
9b9e			endif	 
9b9e			    
9b9e e5				push hl 
9b9f e5				push hl 
9ba0			 
9ba0			;	ld a, 0   ; find end of string 
9ba0 cd 00 91			call strlenz 
9ba3			if DEBUG_FORTH_PUSH 
9ba3						DMARK "PQ2" 
9ba3 f5				push af  
9ba4 3a b8 9b			ld a, (.dmark)  
9ba7 32 71 ee			ld (debug_mark),a  
9baa 3a b9 9b			ld a, (.dmark+1)  
9bad 32 72 ee			ld (debug_mark+1),a  
9bb0 3a ba 9b			ld a, (.dmark+2)  
9bb3 32 73 ee			ld (debug_mark+2),a  
9bb6 18 03			jr .pastdmark  
9bb8 ..			.dmark: db "PQ2"  
9bbb f1			.pastdmark: pop af  
9bbc			endm  
# End of macro DMARK
9bbc				CALLMONITOR 
9bbc cd a3 94			call break_point_state  
9bbf				endm  
# End of macro CALLMONITOR
9bbf			endif	 
9bbf eb				ex de, hl 
9bc0 e1				pop hl   ; get ptr to start of string 
9bc1			if DEBUG_FORTH_PUSH 
9bc1						DMARK "PQ3" 
9bc1 f5				push af  
9bc2 3a d6 9b			ld a, (.dmark)  
9bc5 32 71 ee			ld (debug_mark),a  
9bc8 3a d7 9b			ld a, (.dmark+1)  
9bcb 32 72 ee			ld (debug_mark+1),a  
9bce 3a d8 9b			ld a, (.dmark+2)  
9bd1 32 73 ee			ld (debug_mark+2),a  
9bd4 18 03			jr .pastdmark  
9bd6 ..			.dmark: db "PQ3"  
9bd9 f1			.pastdmark: pop af  
9bda			endm  
# End of macro DMARK
9bda				CALLMONITOR 
9bda cd a3 94			call break_point_state  
9bdd				endm  
# End of macro CALLMONITOR
9bdd			endif	 
9bdd 19				add hl,de 
9bde			if DEBUG_FORTH_PUSH 
9bde						DMARK "PQE" 
9bde f5				push af  
9bdf 3a f3 9b			ld a, (.dmark)  
9be2 32 71 ee			ld (debug_mark),a  
9be5 3a f4 9b			ld a, (.dmark+1)  
9be8 32 72 ee			ld (debug_mark+1),a  
9beb 3a f5 9b			ld a, (.dmark+2)  
9bee 32 73 ee			ld (debug_mark+2),a  
9bf1 18 03			jr .pastdmark  
9bf3 ..			.dmark: db "PQE"  
9bf6 f1			.pastdmark: pop af  
9bf7			endm  
# End of macro DMARK
9bf7				CALLMONITOR 
9bf7 cd a3 94			call break_point_state  
9bfa				endm  
# End of macro CALLMONITOR
9bfa			endif	 
9bfa			 
9bfa 2b				dec hl    ; see if there is an optional trailing double quote 
9bfb 7e				ld a,(hl) 
9bfc fe 22			cp '"' 
9bfe 20 03			jr nz, .strnoq 
9c00 3e 00			ld a, 0      ; get rid of double quote 
9c02 77				ld (hl), a 
9c03 23			.strnoq: inc hl 
9c04			 
9c04 3e 00			ld a, 0 
9c06 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c07			 
9c07 13				inc de ; add one for the type string 
9c08 13				inc de ; add one for null term??? 
9c09			 
9c09				; tos is get string pointer again 
9c09				; de contains space to allocate 
9c09				 
9c09 d5				push de 
9c0a			 
9c0a eb				ex de, hl 
9c0b			 
9c0b				;push af 
9c0b			 
9c0b			if DEBUG_FORTH_PUSH 
9c0b						DMARK "PHm" 
9c0b f5				push af  
9c0c 3a 20 9c			ld a, (.dmark)  
9c0f 32 71 ee			ld (debug_mark),a  
9c12 3a 21 9c			ld a, (.dmark+1)  
9c15 32 72 ee			ld (debug_mark+1),a  
9c18 3a 22 9c			ld a, (.dmark+2)  
9c1b 32 73 ee			ld (debug_mark+2),a  
9c1e 18 03			jr .pastdmark  
9c20 ..			.dmark: db "PHm"  
9c23 f1			.pastdmark: pop af  
9c24			endm  
# End of macro DMARK
9c24				CALLMONITOR 
9c24 cd a3 94			call break_point_state  
9c27				endm  
# End of macro CALLMONITOR
9c27			endif	 
9c27 cd 69 91			call malloc	; on ret hl now contains allocated memory 
9c2a				if DEBUG_FORTH_MALLOC_GUARD 
9c2a cc 9e c9				call z,malloc_error 
9c2d				endif 
9c2d			 
9c2d				 
9c2d c1				pop bc    ; get length 
9c2e d1				pop de   ;  get string start    
9c2f			 
9c2f				; hl has destination from malloc 
9c2f			 
9c2f eb				ex de, hl    ; prep for ldir 
9c30			 
9c30 d5				push de   ; save malloc area for DSP later 
9c31				;push hl   ; save malloc area for DSP later 
9c31			 
9c31			if DEBUG_FORTH_PUSH 
9c31						DMARK "PHc" 
9c31 f5				push af  
9c32 3a 46 9c			ld a, (.dmark)  
9c35 32 71 ee			ld (debug_mark),a  
9c38 3a 47 9c			ld a, (.dmark+1)  
9c3b 32 72 ee			ld (debug_mark+1),a  
9c3e 3a 48 9c			ld a, (.dmark+2)  
9c41 32 73 ee			ld (debug_mark+2),a  
9c44 18 03			jr .pastdmark  
9c46 ..			.dmark: db "PHc"  
9c49 f1			.pastdmark: pop af  
9c4a			endm  
# End of macro DMARK
9c4a				CALLMONITOR 
9c4a cd a3 94			call break_point_state  
9c4d				endm  
# End of macro CALLMONITOR
9c4d			endif	 
9c4d			 
9c4d			 
9c4d ed b0			ldir 
9c4f			 
9c4f			 
9c4f				; push malloc to data stack     macro?????  
9c4f			 
9c4f				FORTH_DSP_NEXT 
9c4f cd a3 9a			call macro_forth_dsp_next 
9c52				endm 
# End of macro FORTH_DSP_NEXT
9c52			 
9c52				; save value and type 
9c52			 
9c52 2a f8 e9			ld hl, (cli_data_sp) 
9c55			 
9c55				; save item type 
9c55 3e 01			ld a,  DS_TYPE_STR 
9c57 77				ld (hl), a 
9c58 23				inc hl 
9c59			 
9c59				; get malloc word off stack 
9c59 d1				pop de 
9c5a 73				ld (hl), e 
9c5b 23				inc hl 
9c5c 72				ld (hl), d 
9c5d			 
9c5d			 
9c5d			 
9c5d			if DEBUG_FORTH_PUSH 
9c5d 2a f8 e9			ld hl, (cli_data_sp) 
9c60						DMARK "PHS" 
9c60 f5				push af  
9c61 3a 75 9c			ld a, (.dmark)  
9c64 32 71 ee			ld (debug_mark),a  
9c67 3a 76 9c			ld a, (.dmark+1)  
9c6a 32 72 ee			ld (debug_mark+1),a  
9c6d 3a 77 9c			ld a, (.dmark+2)  
9c70 32 73 ee			ld (debug_mark+2),a  
9c73 18 03			jr .pastdmark  
9c75 ..			.dmark: db "PHS"  
9c78 f1			.pastdmark: pop af  
9c79			endm  
# End of macro DMARK
9c79				CALLMONITOR 
9c79 cd a3 94			call break_point_state  
9c7c				endm  
# End of macro CALLMONITOR
9c7c			;	ex de,hl 
9c7c			endif	 
9c7c				; in case of spaces, skip the ptr past the copied string 
9c7c				;pop af 
9c7c				;ld (cli_origptr),hl 
9c7c			 
9c7c c9				ret 
9c7d			 
9c7d			 
9c7d			 
9c7d			; TODO ascii push input onto stack given hl to start of input 
9c7d			 
9c7d			; identify type 
9c7d			; if starts with a " then a string 
9c7d			; otherwise it is a number 
9c7d			;  
9c7d			; if a string 
9c7d			;     scan for ending " to get length of string to malloc for + 1 
9c7d			;     malloc 
9c7d			;     put pointer to string on stack first byte flags as string 
9c7d			; 
9c7d			; else a number 
9c7d			;    look for number format identifier 
9c7d			;    $xx hex 
9c7d			;    %xxxxx bin 
9c7d			;    xxxxx decimal 
9c7d			;    convert number to 16bit word.  
9c7d			;    malloc word + 1 with flag to identiy as num 
9c7d			;    put pointer to number on stack 
9c7d			;   
9c7d			;  
9c7d			  
9c7d			forth_apush: 
9c7d				; kernel push 
9c7d			 
9c7d			if DEBUG_FORTH_PUSH 
9c7d						DMARK "PSH" 
9c7d f5				push af  
9c7e 3a 92 9c			ld a, (.dmark)  
9c81 32 71 ee			ld (debug_mark),a  
9c84 3a 93 9c			ld a, (.dmark+1)  
9c87 32 72 ee			ld (debug_mark+1),a  
9c8a 3a 94 9c			ld a, (.dmark+2)  
9c8d 32 73 ee			ld (debug_mark+2),a  
9c90 18 03			jr .pastdmark  
9c92 ..			.dmark: db "PSH"  
9c95 f1			.pastdmark: pop af  
9c96			endm  
# End of macro DMARK
9c96				CALLMONITOR 
9c96 cd a3 94			call break_point_state  
9c99				endm  
# End of macro CALLMONITOR
9c99			endif	 
9c99				; identify input type 
9c99			 
9c99 7e				ld a,(hl) 
9c9a fe 22			cp '"' 
9c9c 28 0a			jr z, .fapstr 
9c9e fe 24			cp '$' 
9ca0 ca c8 9c			jp z, .faphex 
9ca3 fe 25			cp '%' 
9ca5 ca b0 9c			jp z, .fapbin 
9ca8			;	cp 'b' 
9ca8			;	jp z, .fabin 
9ca8				; else decimal 
9ca8			 
9ca8				; TODO do decimal conversion 
9ca8				; decimal is stored as a 16bit word 
9ca8			 
9ca8				; by default everything is a string if type is not detected 
9ca8			.fapstr: ; 
9ca8 fe 22			cp '"' 
9caa 20 01			jr nz, .strnoqu 
9cac 23				inc hl 
9cad			.strnoqu: 
9cad c3 82 9b			jp forth_push_str 
9cb0			 
9cb0			 
9cb0			 
9cb0			.fapbin:    ; push a binary string.  
9cb0 11 00 00			ld de, 0   ; hold a 16bit value 
9cb3			 
9cb3 23			.fapbinshift:	inc hl  
9cb4 7e				ld a,(hl) 
9cb5 fe 00			cp 0     ; done scanning  
9cb7 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cb9			 
9cb9				; left shift de 
9cb9 eb				ex de, hl	 
9cba 29				add hl, hl 
9cbb			 
9cbb				; is 1 
9cbb fe 31			cp '1' 
9cbd 20 02			jr nz, .binzero 
9cbf cb 4d			bit 1, l 
9cc1			.binzero: 
9cc1 eb				ex de, hl	 ; save current de 
9cc2 18 ef			jr .fapbinshift 
9cc4			 
9cc4			.fapbdone: 
9cc4 eb				ex de, hl 
9cc5 c3 14 9b			jp forth_push_numhl 
9cc8			 
9cc8			 
9cc8			.faphex:   ; hex is always stored as a 16bit word 
9cc8				; skip number prefix 
9cc8 23				inc hl 
9cc9				; turn ascii into number 
9cc9 cd 59 90			call get_word_hl	; ret 16bit word in hl 
9ccc			 
9ccc c3 14 9b			jp forth_push_numhl 
9ccf			 
9ccf 00				 nop 
9cd0			 
9cd0			.fabin:   ; TODO bin conversion 
9cd0			 
9cd0			 
9cd0 c9				ret 
9cd1			 
9cd1			 
9cd1			; get either a string ptr or a 16bit word from the data stack 
9cd1			 
9cd1			FORTH_DSP: macro 
9cd1				call macro_forth_dsp 
9cd1				endm 
9cd1			 
9cd1			macro_forth_dsp: 
9cd1				; data stack pointer points to current word on tos 
9cd1			 
9cd1 2a f8 e9			ld hl,(cli_data_sp) 
9cd4			 
9cd4				if DEBUG_FORTH_PUSH 
9cd4						DMARK "DSP" 
9cd4 f5				push af  
9cd5 3a e9 9c			ld a, (.dmark)  
9cd8 32 71 ee			ld (debug_mark),a  
9cdb 3a ea 9c			ld a, (.dmark+1)  
9cde 32 72 ee			ld (debug_mark+1),a  
9ce1 3a eb 9c			ld a, (.dmark+2)  
9ce4 32 73 ee			ld (debug_mark+2),a  
9ce7 18 03			jr .pastdmark  
9ce9 ..			.dmark: db "DSP"  
9cec f1			.pastdmark: pop af  
9ced			endm  
# End of macro DMARK
9ced			 
9ced cd d3 c9				call display_data_sp 
9cf0				;call break_point_state 
9cf0				;rst 030h 
9cf0				CALLMONITOR 
9cf0 cd a3 94			call break_point_state  
9cf3				endm  
# End of macro CALLMONITOR
9cf3				endif 
9cf3			 
9cf3 c9				ret 
9cf4			 
9cf4			; return hl to start of value on stack 
9cf4			 
9cf4			FORTH_DSP_VALUE: macro 
9cf4				call macro_forth_dsp_value 
9cf4				endm 
9cf4			 
9cf4			macro_forth_dsp_value: 
9cf4			 
9cf4				FORTH_DSP 
9cf4 cd d1 9c			call macro_forth_dsp 
9cf7				endm 
# End of macro FORTH_DSP
9cf7			 
9cf7 d5				push de 
9cf8			 
9cf8 23				inc hl ; skip type 
9cf9			 
9cf9 5e				ld e, (hl) 
9cfa 23				inc hl 
9cfb 56				ld d, (hl) 
9cfc eb				ex de,hl  
9cfd			 
9cfd d1				pop de 
9cfe			 
9cfe c9				ret 
9cff			 
9cff			; return hl to start of value to second item on stack 
9cff			 
9cff			FORTH_DSP_VALUEM1: macro 
9cff				call macro_forth_dsp_value_m1 
9cff				endm 
9cff			 
9cff			macro_forth_dsp_value_m1: 
9cff			 
9cff				FORTH_DSP 
9cff cd d1 9c			call macro_forth_dsp 
9d02				endm 
# End of macro FORTH_DSP
9d02			 
9d02 2b				dec hl 
9d03 2b				dec hl 
9d04			;	dec hl 
9d04			 
9d04 d5				push de 
9d05			 
9d05 5e				ld e, (hl) 
9d06 23				inc hl 
9d07 56				ld d, (hl) 
9d08 eb				ex de,hl  
9d09			 
9d09 d1				pop de 
9d0a			 
9d0a c9				ret 
9d0b			 
9d0b				 
9d0b			 
9d0b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d0b			 
9d0b			FORTH_DSP_POP: macro 
9d0b				call macro_forth_dsp_pop 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			; get the tos data type 
9d0b			 
9d0b			FORTH_DSP_TYPE:   macro 
9d0b			 
9d0b				;FORTH_DSP_VALUE 
9d0b				FORTH_DSP 
9d0b				 
9d0b				; hl points to value 
9d0b				; check type 
9d0b			 
9d0b				ld a,(hl) 
9d0b			 
9d0b				endm 
9d0b			 
9d0b			; load the tos value into hl 
9d0b			 
9d0b			 
9d0b			FORTH_DSP_VALUEHL:  macro 
9d0b				call macro_dsp_valuehl 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			 
9d0b			macro_dsp_valuehl: 
9d0b				FORTH_DSP_VALUE 
9d0b cd f4 9c			call macro_forth_dsp_value 
9d0e				endm 
# End of macro FORTH_DSP_VALUE
9d0e			 
9d0e				;FORTH_ERR_TOS_NOTNUM 
9d0e			 
9d0e				;inc hl   ; skip type id 
9d0e			 
9d0e			;	push de 
9d0e			; 
9d0e			;	ld e, (hl) 
9d0e			;	inc hl 
9d0e			;	ld d, (hl) 
9d0e			;	ex de,hl  
9d0e			 
9d0e			;	pop de 
9d0e			 
9d0e				if DEBUG_FORTH_PUSH 
9d0e						DMARK "DVL" 
9d0e f5				push af  
9d0f 3a 23 9d			ld a, (.dmark)  
9d12 32 71 ee			ld (debug_mark),a  
9d15 3a 24 9d			ld a, (.dmark+1)  
9d18 32 72 ee			ld (debug_mark+1),a  
9d1b 3a 25 9d			ld a, (.dmark+2)  
9d1e 32 73 ee			ld (debug_mark+2),a  
9d21 18 03			jr .pastdmark  
9d23 ..			.dmark: db "DVL"  
9d26 f1			.pastdmark: pop af  
9d27			endm  
# End of macro DMARK
9d27				CALLMONITOR 
9d27 cd a3 94			call break_point_state  
9d2a				endm  
# End of macro CALLMONITOR
9d2a				endif 
9d2a c9				ret 
9d2b			 
9d2b			forth_apushstrhl:      
9d2b				; push of string requires use of cli_origptr 
9d2b				; bodge use 
9d2b			 
9d2b				; get current cli_origptr, save, update with temp pointer  
9d2b ed 5b 48 ea		ld de, (cli_origptr) 
9d2f 22 48 ea			ld (cli_origptr), hl 
9d32 d5				push de 
9d33 cd 7d 9c			call forth_apush 
9d36 d1				pop de 
9d37 ed 53 48 ea		ld (cli_origptr), de 
9d3b c9			        ret	 
9d3c			 
9d3c			 
9d3c			; increase loop stack pointer and save hl to it 
9d3c				 
9d3c			FORTH_LOOP_NEXT: macro 
9d3c				call macro_forth_loop_next 
9d3c				;nop 
9d3c				endm 
9d3c			 
9d3c			macro_forth_loop_next: 
9d3c				if DEBUG_FORTH_STACK_GUARD 
9d3c cd aa dd				call check_stacks 
9d3f				endif 
9d3f e5				push hl 
9d40 d5				push de 
9d41 eb				ex de,hl 
9d42 2a fa e9			ld hl,(cli_loop_sp) 
9d45 23				inc hl 
9d46 23				inc hl 
9d47					if DEBUG_FORTH_WORDS 
9d47						DMARK "LNX" 
9d47 f5				push af  
9d48 3a 5c 9d			ld a, (.dmark)  
9d4b 32 71 ee			ld (debug_mark),a  
9d4e 3a 5d 9d			ld a, (.dmark+1)  
9d51 32 72 ee			ld (debug_mark+1),a  
9d54 3a 5e 9d			ld a, (.dmark+2)  
9d57 32 73 ee			ld (debug_mark+2),a  
9d5a 18 03			jr .pastdmark  
9d5c ..			.dmark: db "LNX"  
9d5f f1			.pastdmark: pop af  
9d60			endm  
# End of macro DMARK
9d60						CALLMONITOR 
9d60 cd a3 94			call break_point_state  
9d63				endm  
# End of macro CALLMONITOR
9d63					endif 
9d63 22 fa e9			ld (cli_loop_sp),hl 
9d66 73				ld (hl), e 
9d67 23				inc hl 
9d68 72				ld (hl), d 
9d69 d1				pop de    ; been reversed so save a swap on restore 
9d6a e1				pop hl 
9d6b				if DEBUG_FORTH_STACK_GUARD 
9d6b cd aa dd				call check_stacks 
9d6e				endif 
9d6e c9				ret 
9d6f			 
9d6f			; get current ret stack pointer and save to hl  
9d6f				 
9d6f			FORTH_LOOP_TOS: macro 
9d6f				call macro_forth_loop_tos 
9d6f				endm 
9d6f			 
9d6f			macro_forth_loop_tos: 
9d6f d5				push de 
9d70 2a fa e9			ld hl,(cli_loop_sp) 
9d73 5e				ld e, (hl) 
9d74 23				inc hl 
9d75 56				ld d, (hl) 
9d76 eb				ex de, hl 
9d77 d1				pop de 
9d78 c9				ret 
9d79			 
9d79			; pop loop stack pointer 
9d79				 
9d79			FORTH_LOOP_POP: macro 
9d79				call macro_forth_loop_pop 
9d79				endm 
9d79			 
9d79			 
9d79			macro_forth_loop_pop: 
9d79				if DEBUG_FORTH_STACK_GUARD 
9d79					DMARK "LPP" 
9d79 f5				push af  
9d7a 3a 8e 9d			ld a, (.dmark)  
9d7d 32 71 ee			ld (debug_mark),a  
9d80 3a 8f 9d			ld a, (.dmark+1)  
9d83 32 72 ee			ld (debug_mark+1),a  
9d86 3a 90 9d			ld a, (.dmark+2)  
9d89 32 73 ee			ld (debug_mark+2),a  
9d8c 18 03			jr .pastdmark  
9d8e ..			.dmark: db "LPP"  
9d91 f1			.pastdmark: pop af  
9d92			endm  
# End of macro DMARK
9d92 cd aa dd				call check_stacks 
9d95					FORTH_CHK_LOOP_UNDER 
9d95 e5				push hl 
9d96 d5				push de 
9d97 2a fa e9			ld hl,(cli_loop_sp) 
9d9a 11 34 e9			ld de, cli_loop_stack 
9d9d cd c0 8c			call cmp16 
9da0 da c4 de			jp c, fault_loop_under 
9da3 d1				pop de 
9da4 e1				pop hl 
9da5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9da5				endif 
9da5 e5				push hl 
9da6 2a fa e9			ld hl,(cli_loop_sp) 
9da9 2b				dec hl 
9daa 2b				dec hl 
9dab 22 fa e9			ld (cli_loop_sp), hl 
9dae				; TODO do stack underflow checks 
9dae e1				pop hl 
9daf				if DEBUG_FORTH_STACK_GUARD 
9daf cd aa dd				call check_stacks 
9db2					FORTH_CHK_LOOP_UNDER 
9db2 e5				push hl 
9db3 d5				push de 
9db4 2a fa e9			ld hl,(cli_loop_sp) 
9db7 11 34 e9			ld de, cli_loop_stack 
9dba cd c0 8c			call cmp16 
9dbd da c4 de			jp c, fault_loop_under 
9dc0 d1				pop de 
9dc1 e1				pop hl 
9dc2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dc2				endif 
9dc2 c9				ret 
9dc3			 
9dc3			macro_forth_dsp_pop: 
9dc3			 
9dc3 e5				push hl 
9dc4			 
9dc4				; release malloc data 
9dc4			 
9dc4				if DEBUG_FORTH_STACK_GUARD 
9dc4 cd aa dd				call check_stacks 
9dc7					FORTH_CHK_DSP_UNDER 
9dc7 e5				push hl 
9dc8 d5				push de 
9dc9 2a f8 e9			ld hl,(cli_data_sp) 
9dcc 11 32 e8			ld de, cli_data_stack 
9dcf cd c0 8c			call cmp16 
9dd2 da b8 de			jp c, fault_dsp_under 
9dd5 d1				pop de 
9dd6 e1				pop hl 
9dd7				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dd7				endif 
9dd7				;ld hl,(cli_data_sp) 
9dd7			if DEBUG_FORTH_DOT 
9dd7				DMARK "DPP" 
9dd7 f5				push af  
9dd8 3a ec 9d			ld a, (.dmark)  
9ddb 32 71 ee			ld (debug_mark),a  
9dde 3a ed 9d			ld a, (.dmark+1)  
9de1 32 72 ee			ld (debug_mark+1),a  
9de4 3a ee 9d			ld a, (.dmark+2)  
9de7 32 73 ee			ld (debug_mark+2),a  
9dea 18 03			jr .pastdmark  
9dec ..			.dmark: db "DPP"  
9def f1			.pastdmark: pop af  
9df0			endm  
# End of macro DMARK
9df0				CALLMONITOR 
9df0 cd a3 94			call break_point_state  
9df3				endm  
# End of macro CALLMONITOR
9df3			endif	 
9df3			 
9df3			 
9df3			if FORTH_ENABLE_DSPPOPFREE 
9df3			 
9df3				FORTH_DSP 
9df3 cd d1 9c			call macro_forth_dsp 
9df6				endm 
# End of macro FORTH_DSP
9df6			 
9df6 7e				ld a, (hl) 
9df7 fe 01			cp DS_TYPE_STR 
9df9 20 23			jr nz, .skippopfree 
9dfb			 
9dfb				FORTH_DSP_VALUEHL 
9dfb cd 0b 9d			call macro_dsp_valuehl 
9dfe				endm 
# End of macro FORTH_DSP_VALUEHL
9dfe 00				nop 
9dff			if DEBUG_FORTH_DOT 
9dff				DMARK "DPf" 
9dff f5				push af  
9e00 3a 14 9e			ld a, (.dmark)  
9e03 32 71 ee			ld (debug_mark),a  
9e06 3a 15 9e			ld a, (.dmark+1)  
9e09 32 72 ee			ld (debug_mark+1),a  
9e0c 3a 16 9e			ld a, (.dmark+2)  
9e0f 32 73 ee			ld (debug_mark+2),a  
9e12 18 03			jr .pastdmark  
9e14 ..			.dmark: db "DPf"  
9e17 f1			.pastdmark: pop af  
9e18			endm  
# End of macro DMARK
9e18				CALLMONITOR 
9e18 cd a3 94			call break_point_state  
9e1b				endm  
# End of macro CALLMONITOR
9e1b			endif	 
9e1b cd 33 92			call free 
9e1e			.skippopfree: 
9e1e				 
9e1e			 
9e1e			endif 
9e1e			 
9e1e			if DEBUG_FORTH_DOT_KEY 
9e1e				DMARK "DP2" 
9e1e				CALLMONITOR 
9e1e			endif	 
9e1e			 
9e1e				; move pointer down 
9e1e			 
9e1e 2a f8 e9			ld hl,(cli_data_sp) 
9e21 2b				dec hl 
9e22 2b				dec hl 
9e23			; PARSEV5 
9e23 2b				dec hl 
9e24 22 f8 e9			ld (cli_data_sp), hl 
9e27			 
9e27				if DEBUG_FORTH_STACK_GUARD 
9e27 cd aa dd				call check_stacks 
9e2a					FORTH_CHK_DSP_UNDER 
9e2a e5				push hl 
9e2b d5				push de 
9e2c 2a f8 e9			ld hl,(cli_data_sp) 
9e2f 11 32 e8			ld de, cli_data_stack 
9e32 cd c0 8c			call cmp16 
9e35 da b8 de			jp c, fault_dsp_under 
9e38 d1				pop de 
9e39 e1				pop hl 
9e3a				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e3a				endif 
9e3a			 
9e3a e1				pop hl 
9e3b			 
9e3b c9				ret 
9e3c			 
9e3c			getwordathl: 
9e3c				; hl points to an address 
9e3c				; load hl with the word at that address 
9e3c			 
9e3c d5				push de 
9e3d			 
9e3d 5e				ld e, (hl) 
9e3e 23				inc hl 
9e3f 56				ld d, (hl) 
9e40 eb				ex de, hl 
9e41			 
9e41 d1				pop de 
9e42 c9				ret 
9e43			 
9e43			 
9e43			 
9e43			 
9e43			 
9e43			; eof 
9e43			 
# End of file forth_stackopsv5.asm
9e43			endif 
9e43			 
9e43			user_word_eol:  
9e43				; hl contains the pointer to where to create a linked list item from the end 
9e43				; of the user dict to continue on at the system word dict 
9e43				 
9e43				; poke the stub of the word list linked list to repoint to rom words 
9e43			 
9e43				; stub format 
9e43				; db   word id 
9e43				; dw    link to next word 
9e43			        ; db char length of token 
9e43				; db string + 0 term 
9e43				; db exec code....  
9e43			 
9e43 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e45 77				ld (hl), a		; word id 
9e46 23				inc hl 
9e47			 
9e47 11 12 a0			ld de, sysdict 
9e4a 73				ld (hl), e		; next word link ie system dict 
9e4b 23				inc hl 
9e4c 72				ld (hl), d		; next word link ie system dict 
9e4d 23				inc hl	 
9e4e			 
9e4e			;	ld (hl), sysdict		; next word link ie system dict 
9e4e			;	inc hl 
9e4e			;	inc hl 
9e4e			 
9e4e			;	inc hl 
9e4e			;	inc hl 
9e4e			 
9e4e 3e 02			ld a, 2			; word length is 0 
9e50 77				ld (hl), a	 
9e51 23				inc hl 
9e52			 
9e52 3e 7e			ld a, '~'			; word length is 0 
9e54 77				ld (hl), a	 
9e55 23				inc hl 
9e56 3e 00			ld a, 0			; save empty word 
9e58 77				ld (hl), a 
9e59			 
9e59 c9				ret 
9e5a			 
9e5a				 
9e5a			 
9e5a			forthexec_cleanup: 
9e5a				FORTH_RSP_POP 
9e5a cd dc 9a			call macro_forth_rsp_pop 
9e5d				endm 
# End of macro FORTH_RSP_POP
9e5d c9				ret 
9e5e			 
9e5e			forth_call_hl: 
9e5e				; taking hl 
9e5e e5				push hl 
9e5f c9				ret 
9e60			 
9e60			; this is called to reset Forth system but keep existing uwords etc 
9e60			 
9e60			forth_warmstart: 
9e60				; setup stack over/under flow checks 
9e60				if DEBUG_FORTH_STACK_GUARD 
9e60 cd 90 dd				call chk_stk_init 
9e63				endif 
9e63			 
9e63				; init stack pointers  - * these stacks go upwards *  
9e63 21 b6 e9			ld hl, cli_ret_stack 
9e66 22 fc e9			ld (cli_ret_sp), hl	 
9e69				; set bottom of stack 
9e69 3e 00			ld a,0 
9e6b 77				ld (hl),a 
9e6c 23				inc hl 
9e6d 77				ld (hl),a 
9e6e			 
9e6e 21 32 e8			ld hl, cli_data_stack 
9e71 22 f8 e9			ld (cli_data_sp), hl	 
9e74				; set bottom of stack 
9e74 3e 00			ld a,0 
9e76 77				ld (hl),a 
9e77 23				inc hl 
9e78 77				ld (hl),a 
9e79			 
9e79 21 34 e9			ld hl, cli_loop_stack 
9e7c 22 fa e9			ld (cli_loop_sp), hl	 
9e7f				; set bottom of stack 
9e7f 3e 00			ld a,0 
9e81 77				ld (hl),a 
9e82 23				inc hl 
9e83 77				ld (hl),a 
9e84			 
9e84				; init extent of current open file 
9e84			 
9e84 3e 00			ld a, 0 
9e86 32 74 ea			ld (store_openext), a 
9e89			 
9e89 c9				ret 
9e8a			 
9e8a			 
9e8a			; Cold Start - this is called to setup the whole Forth system 
9e8a			 
9e8a			forth_init: 
9e8a			 
9e8a				; setup stack over/under flow checks 
9e8a			 
9e8a			;	if DEBUG_FORTH_STACK_GUARD 
9e8a			;		call chk_stk_init 
9e8a			;	endif 
9e8a			 
9e8a				; enable auto display updates (slow.....) 
9e8a			 
9e8a 3e 01			ld a, 1 
9e8c 32 46 ea			ld (cli_autodisplay), a 
9e8f			 
9e8f				; if storage is in use disable long reads for now 
9e8f 3e 00			ld a, 0 
9e91 32 7f ea			ld (store_longread), a 
9e94			 
9e94			 
9e94				; show start up screen 
9e94			 
9e94 cd 75 8a			call clear_display 
9e97			 
9e97 3e 00			ld a,0 
9e99 32 68 ea			ld (f_cursor_ptr), a 
9e9c			 
9e9c				; set start of word list in start of ram - for use when creating user words 
9e9c			 
9e9c 21 5b e0			ld hl, baseram 
9e9f 22 c8 e5			ld (os_last_new_uword), hl 
9ea2 cd 43 9e			call user_word_eol 
9ea5				 
9ea5			;		call display_data_sp 
9ea5			;		call next_page_prompt 
9ea5			 
9ea5			 
9ea5			 
9ea5			 
9ea5 c9				ret 
9ea6			 
9ea6 .. 00		.bootforth: db " Forth Kernel Init ",0 
9eba			 
9eba			; TODO push to stack 
9eba			 
9eba			;  
9eba			 
9eba			if FORTH_PARSEV2 
9eba			 
9eba			 
9eba				include "forth_parserv2.asm" 
9eba			 
9eba			endif 
9eba			 
9eba			 
9eba			; parse cli version 1 
9eba			 
9eba			if FORTH_PARSEV1 
9eba			 
9eba			 
9eba			 
9eba			      include "forth_parserv1.asm" 
9eba			endif 
9eba				 
9eba			if FORTH_PARSEV3 
9eba			 
9eba			 
9eba			 
9eba			      include "forth_parserv3.asm" 
9eba				include "forth_wordsv3.asm" 
9eba			endif 
9eba			 
9eba			if FORTH_PARSEV4 
9eba			 
9eba			 
9eba			 
9eba			      include "forth_parserv4.asm" 
9eba				include "forth_wordsv4.asm" 
9eba			endif 
9eba			 
9eba			if FORTH_PARSEV5 
9eba			 
9eba			 
9eba			 
9eba			      include "forth_parserv5.asm" 
9eba			 
9eba			 
9eba			; A better parser without using malloc and string copies all over the place.  
9eba			; Exec in situ should be faster 
9eba			 
9eba			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9eba			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9eba			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9eba			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9eba			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9eba			WORD_SYS_END: equ 0   ; Opcode for all user words 
9eba			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9eba			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9eba			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9eba			 
9eba			; Core word preamble macro 
9eba			 
9eba			CWHEAD:   macro nxtword opcode lit len opflags 
9eba				db WORD_SYS_CORE+opcode             
9eba				; internal op code number 
9eba				dw nxtword            
9eba				; link to next dict word block 
9eba				db len + 1 
9eba				; literal length of dict word inc zero term 
9eba				db lit,0              
9eba				; literal dict word 
9eba			        ; TODO db opflags        
9eba				endm 
9eba			 
9eba			 
9eba			NEXTW: macro  
9eba				jp macro_next 
9eba				endm 
9eba			 
9eba			macro_next: 
9eba			if DEBUG_FORTH_PARSE_KEY 
9eba				DMARK "NXT" 
9eba				CALLMONITOR 
9eba			endif	 
9eba			;	inc hl  ; skip token null term  
9eba ed 4b 4a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9ebe ed 5b 48 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ec2 2a cc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ec5			if DEBUG_FORTH_PARSE_KEY 
9ec5				DMARK "}AA" 
9ec5				CALLMONITOR 
9ec5			endif	 
9ec5 c3 c8 9f			jp execnext 
9ec8				;jp exec1 
9ec8			       
9ec8			 
9ec8			 
9ec8			; Another go at the parser to compile  
9ec8			 
9ec8			 
9ec8			; TODO rework parser to change all of the string words to byte tokens 
9ec8			; TODO do a search for  
9ec8			 
9ec8			; TODO first run normal parser to zero term sections 
9ec8			; TODO for each word do a token look up to get the op code 
9ec8			; TODO need some means to flag to the exec that this is a byte code form    
9ec8			 
9ec8			 
9ec8			forthcompile: 
9ec8			 
9ec8			; 
9ec8			; line parse: 
9ec8			;       parse raw input buffer 
9ec8			;       tokenise the words 
9ec8			;       malloc new copy (for looping etc) 
9ec8			;       copy to malloc + current pc in line to start of string and add line term 
9ec8			;       save on new rsp 
9ec8			; 
9ec8			 
9ec8			; hl to point to the line to tokenise 
9ec8			 
9ec8			;	push hl 
9ec8 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9ecb			 
9ecb			;	ld a,0		; string term on input 
9ecb			;	call strlent 
9ecb			 
9ecb			;	ld (os_tok_len), hl	 ; save string length 
9ecb			 
9ecb			;if DEBUG_FORTH_TOK 
9ecb			;	ex de,hl		 
9ecb			;endif 
9ecb			 
9ecb			;	pop hl 		; get back string pointer 
9ecb			 
9ecb			if DEBUG_FORTH_TOK 
9ecb						DMARK "TOc" 
9ecb				CALLMONITOR 
9ecb			endif 
9ecb 7e			.cptoken2:    ld a,(hl) 
9ecc 23				inc hl 
9ecd fe 7f			cp FORTH_END_BUFFER 
9ecf 28 29			jr z, .cptokendone2 
9ed1 fe 00			cp 0 
9ed3 28 25			jr z, .cptokendone2 
9ed5 fe 22			cp '"' 
9ed7 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9ed9 fe 20			cp ' ' 
9edb 20 ee			jr nz,  .cptoken2 
9edd			 
9edd			; TODO consume comments held between ( and ) 
9edd			 
9edd				; we have a space so change to zero term for dict match later 
9edd 2b				dec hl 
9ede 3e 00			ld a,0 
9ee0 77				ld (hl), a 
9ee1 23				inc hl 
9ee2 18 e7			jr .cptoken2 
9ee4				 
9ee4			 
9ee4			.cptokenstr2: 
9ee4				; skip all white space until either eol (because forgot to term) or end double quote 
9ee4			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9ee4				;inc hl ; skip current double quote 
9ee4 7e				ld a,(hl) 
9ee5 23				inc hl 
9ee6 fe 22			cp '"' 
9ee8 28 e1			jr z, .cptoken2 
9eea fe 7f			cp FORTH_END_BUFFER 
9eec 28 0c			jr z, .cptokendone2 
9eee fe 00			cp 0 
9ef0 28 08			jr z, .cptokendone2 
9ef2 fe 20			cp ' ' 
9ef4 28 02			jr z, .cptmp2 
9ef6 18 ec			jr .cptokenstr2 
9ef8			 
9ef8			.cptmp2:	; we have a space so change to zero term for dict match later 
9ef8				;dec hl 
9ef8				;ld a,"-"	; TODO remove this when working 
9ef8				;ld (hl), a 
9ef8				;inc hl 
9ef8 18 ea			jr .cptokenstr2 
9efa			 
9efa			.cptokendone2: 
9efa				;inc hl 
9efa 3e 7f			ld a, FORTH_END_BUFFER 
9efc 77				ld (hl),a 
9efd 23				inc hl 
9efe 3e 21			ld a, '!' 
9f00 77				ld (hl),a 
9f01			 
9f01 2a cc e5			ld hl,(os_tok_ptr) 
9f04			         
9f04			if DEBUG_FORTH_TOK 
9f04						DMARK "Tc1" 
9f04				CALLMONITOR 
9f04			endif 
9f04			 
9f04				; push exec string to top of return stack 
9f04				FORTH_RSP_NEXT 
9f04 cd bb 9a			call macro_forth_rsp_next 
9f07				endm 
# End of macro FORTH_RSP_NEXT
9f07 c9				ret 
9f08			 
9f08			; Another go at the parser need to simplify the process 
9f08			 
9f08			forthparse: 
9f08			 
9f08			; 
9f08			; line parse: 
9f08			;       parse raw input buffer 
9f08			;       tokenise the words 
9f08			;       malloc new copy (for looping etc) 
9f08			;       copy to malloc + current pc in line to start of string and add line term 
9f08			;       save on new rsp 
9f08			; 
9f08			 
9f08			; hl to point to the line to tokenise 
9f08			 
9f08			;	push hl 
9f08 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f0b			 
9f0b			;	ld a,0		; string term on input 
9f0b			;	call strlent 
9f0b			 
9f0b			;	ld (os_tok_len), hl	 ; save string length 
9f0b			 
9f0b			;if DEBUG_FORTH_TOK 
9f0b			;	ex de,hl		 
9f0b			;endif 
9f0b			 
9f0b			;	pop hl 		; get back string pointer 
9f0b			 
9f0b			if DEBUG_FORTH_TOK 
9f0b						DMARK "TOK" 
9f0b				CALLMONITOR 
9f0b			endif 
9f0b 7e			.ptoken2:    ld a,(hl) 
9f0c 23				inc hl 
9f0d fe 7f			cp FORTH_END_BUFFER 
9f0f 28 29			jr z, .ptokendone2 
9f11 fe 00			cp 0 
9f13 28 25			jr z, .ptokendone2 
9f15 fe 22			cp '"' 
9f17 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f19 fe 20			cp ' ' 
9f1b 20 ee			jr nz,  .ptoken2 
9f1d			 
9f1d			; TODO consume comments held between ( and ) 
9f1d			 
9f1d				; we have a space so change to zero term for dict match later 
9f1d 2b				dec hl 
9f1e 3e 00			ld a,0 
9f20 77				ld (hl), a 
9f21 23				inc hl 
9f22 18 e7			jr .ptoken2 
9f24				 
9f24			 
9f24			.ptokenstr2: 
9f24				; skip all white space until either eol (because forgot to term) or end double quote 
9f24			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f24				;inc hl ; skip current double quote 
9f24 7e				ld a,(hl) 
9f25 23				inc hl 
9f26 fe 22			cp '"' 
9f28 28 e1			jr z, .ptoken2 
9f2a fe 7f			cp FORTH_END_BUFFER 
9f2c 28 0c			jr z, .ptokendone2 
9f2e fe 00			cp 0 
9f30 28 08			jr z, .ptokendone2 
9f32 fe 20			cp ' ' 
9f34 28 02			jr z, .ptmp2 
9f36 18 ec			jr .ptokenstr2 
9f38			 
9f38			.ptmp2:	; we have a space so change to zero term for dict match later 
9f38				;dec hl 
9f38				;ld a,"-"	; TODO remove this when working 
9f38				;ld (hl), a 
9f38				;inc hl 
9f38 18 ea			jr .ptokenstr2 
9f3a			 
9f3a			.ptokendone2: 
9f3a				;inc hl 
9f3a 3e 7f			ld a, FORTH_END_BUFFER 
9f3c 77				ld (hl),a 
9f3d 23				inc hl 
9f3e 3e 21			ld a, '!' 
9f40 77				ld (hl),a 
9f41			 
9f41 2a cc e5			ld hl,(os_tok_ptr) 
9f44			         
9f44			if DEBUG_FORTH_TOK 
9f44						DMARK "TK1" 
9f44				CALLMONITOR 
9f44			endif 
9f44			 
9f44				; push exec string to top of return stack 
9f44				FORTH_RSP_NEXT 
9f44 cd bb 9a			call macro_forth_rsp_next 
9f47				endm 
# End of macro FORTH_RSP_NEXT
9f47 c9				ret 
9f48			 
9f48			; 
9f48			;	; malloc size + buffer pointer + if is loop flag 
9f48			;	ld hl,(os_tok_len) 		 ; get string length 
9f48			; 
9f48			;	ld a,l 
9f48			; 
9f48			;	cp 0			; we dont want to use a null string 
9f48			;	ret z 
9f48			; 
9f48			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f48			; 
9f48			;	add 5     ; TODO when certain not over writing memory remove 
9f48			; 
9f48			;		 
9f48			; 
9f48			;if DEBUG_FORTH_TOK 
9f48			;			DMARK "TKE" 
9f48			;	CALLMONITOR 
9f48			;endif 
9f48			; 
9f48			;	ld l,a 
9f48			;	ld h,0 
9f48			;;	push hl   ; save required space for the copy later 
9f48			;	call malloc 
9f48			;if DEBUG_FORTH_TOK 
9f48			;			DMARK "TKM" 
9f48			;	CALLMONITOR 
9f48			;endif 
9f48			;	if DEBUG_FORTH_MALLOC_GUARD 
9f48			;		push af 
9f48			;		call ishlzero 
9f48			;;		ld a, l 
9f48			;;		add h 
9f48			;;		cp 0 
9f48			;		pop af 
9f48			;		 
9f48			;		call z,malloc_error 
9f48			;	endif 
9f48			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f48			; 
9f48			; 
9f48			;if DEBUG_FORTH_TOK 
9f48			;			DMARK "TKR" 
9f48			;	CALLMONITOR 
9f48			;endif 
9f48			; 
9f48			;	FORTH_RSP_NEXT 
9f48			; 
9f48			;	;inc hl	 ; go past current buffer pointer 
9f48			;	;inc hl 
9f48			;	;inc hl   ; and past if loop flag 
9f48			;		; TODO Need to set flag  
9f48			; 
9f48			;	 
9f48			;	 
9f48			;	ex de,hl	; malloc is dest 
9f48			;	ld hl, (os_tok_len) 
9f48			;;	pop bc 
9f48			;	ld c, l                
9f48			;	ld b,0 
9f48			;	ld hl, (os_tok_ptr) 
9f48			; 
9f48			;if DEBUG_FORTH_TOK 
9f48			;			DMARK "TKT" 
9f48			;	CALLMONITOR 
9f48			;endif 
9f48			; 
9f48			;	; do str cpy 
9f48			; 
9f48			;	ldir      ; copy byte in hl to de 
9f48			; 
9f48			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f48			; 
9f48			;if DEBUG_FORTH_TOK 
9f48			; 
9f48			;			DMARK "TKY" 
9f48			;	CALLMONITOR 
9f48			;endif 
9f48			;	;ld a,0 
9f48			;	;ld a,FORTH_END_BUFFER 
9f48			;	ex de, hl 
9f48			;	;dec hl			 ; go back over the space delim at the end of word 
9f48			;	;ld (hl),a 
9f48			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f48			;	ld a,FORTH_END_BUFFER 
9f48			;	ld (hl),a 
9f48			;	inc hl 
9f48			;	ld a,FORTH_END_BUFFER 
9f48			;	ld (hl),a 
9f48			; 
9f48			;	; init the malloc area data 
9f48			;	; set pc for in current area 
9f48			;	;ld hl, (os_tok_malloc) 
9f48			;	;inc hl 
9f48			;	;inc hl 
9f48			;	;inc hl 
9f48			;	;ex de,hl 
9f48			;	;ld hl, (os_tok_malloc) 
9f48			;	;ld (hl),e 
9f48			;	;inc hl 
9f48			;	;ld (hl),d 
9f48			; 
9f48			; 
9f48			;	ld hl,(os_tok_malloc) 
9f48			;if DEBUG_FORTH_PARSE_KEY 
9f48			;			DMARK "TKU" 
9f48			;	CALLMONITOR 
9f48			;endif 
9f48			; 
9f48			;	ret 
9f48			 
9f48			forthexec: 
9f48			 
9f48			; line exec: 
9f48			; forth parser 
9f48			 
9f48			; 
9f48			;       get current exec line on rsp 
9f48			 
9f48				FORTH_RSP_TOS 
9f48 cd d2 9a			call macro_forth_rsp_tos 
9f4b				endm 
# End of macro FORTH_RSP_TOS
9f4b			 
9f4b			;       restore current pc - hl points to malloc of data 
9f4b			 
9f4b				;ld e, (hl) 
9f4b				;inc hl 
9f4b				;ld d, (hl) 
9f4b				;ex de,hl 
9f4b			 
9f4b			 
9f4b			exec1: 
9f4b 22 cc e5			ld (os_tok_ptr), hl 
9f4e			 
9f4e				; copy our PC to working vars  
9f4e 22 4a ea			ld (cli_ptr), hl 
9f51 22 48 ea			ld (cli_origptr), hl 
9f54			 
9f54 7e				ld a,(hl) 
9f55 fe 7f			cp FORTH_END_BUFFER 
9f57 c8				ret z 
9f58			 
9f58				; skip any nulls 
9f58			 
9f58 fe 00			cp 0 
9f5a 20 03			jr nz, .execword 
9f5c 23				inc hl 
9f5d 18 ec			jr exec1 
9f5f			 
9f5f			 
9f5f			.execword: 
9f5f			 
9f5f			 
9f5f			 
9f5f			if DEBUG_FORTH_PARSE_KEY 
9f5f						DMARK "KYQ" 
9f5f				CALLMONITOR 
9f5f			endif 
9f5f			;       while at start of word: 
9f5f			; get start of dict (in user area first) 
9f5f			 
9f5f 21 5b e0		ld hl, baseram 
9f62			;ld hl, sysdict 
9f62 22 4c ea		ld (cli_nextword),hl 
9f65			;           match word at pc 
9f65			;           exec word 
9f65			;           or push to dsp 
9f65			;           forward to next token 
9f65			;           if line term pop rsp and exit 
9f65			;        
9f65			 
9f65			if DEBUG_FORTH_PARSE_KEY 
9f65						DMARK "KYq" 
9f65				CALLMONITOR 
9f65			endif 
9f65			 
9f65			; 
9f65			; word comp 
9f65			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f65			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f65			;    move to start of word  
9f65			;    compare word to cli_token 
9f65			 
9f65			.execpnword:	; HL at start of a word in the dictionary to check 
9f65			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f65			;	ld (cli_ptr), hl 
9f65			 
9f65 2a 4c ea			ld hl,(cli_nextword) 
9f68			 
9f68 cd 0b a0			call forth_tok_next 
9f6b			; tok next start here 
9f6b			;	; TODO skip compiled symbol for now 
9f6b			;	inc hl 
9f6b			; 
9f6b			;	; save pointer to next word 
9f6b			; 
9f6b			;	; hl now points to the address of the next word pointer  
9f6b			;	ld e, (hl) 
9f6b			;	inc hl 
9f6b			;	ld d, (hl) 
9f6b			;	inc l 
9f6b			; 
9f6b			;	ex de,hl 
9f6b			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f6b			;	push bc 
9f6b			;	ld bc, (cli_nextword) 
9f6b			;			DMARK "NXW" 
9f6b			;	CALLMONITOR 
9f6b			;	pop bc 
9f6b			;endif 
9f6b			; tok next end here 
9f6b 22 4c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f6e eb				ex de, hl 
9f6f			 
9f6f			 
9f6f				; save the pointer of the current token - 1 to check against 
9f6f				 
9f6f 22 50 ea			ld (cli_token), hl   
9f72				; TODO maybe remove below save if no debug 
9f72				; save token string ptr for any debug later 
9f72 23				inc hl  
9f73 22 52 ea			ld (cli_origtoken), hl 
9f76 2b				dec hl 
9f77				; save pointer to the start of the next dictionay word 
9f77 7e				ld a,(hl)   ; get string length 
9f78 47				ld b,a 
9f79			.execpnwordinc:  
9f79 23				inc hl 
9f7a 10 fd			djnz .execpnwordinc 
9f7c 22 4e ea			ld (cli_execword), hl      ; save start of this words code 
9f7f			 
9f7f				; now check the word token against the string being parsed 
9f7f			 
9f7f 2a 50 ea			ld hl,(cli_token) 
9f82 23				inc hl     ; skip string length (use zero term instead to end) 
9f83 22 50 ea			ld (cli_token), hl 
9f86			 
9f86			if DEBUG_FORTH_PARSE_KEY 
9f86						DMARK "KY2" 
9f86			endif 
9f86			if DEBUG_FORTH_PARSE_EXEC 
9f86				; see if disabled 
9f86			 
9f86				ld a, (os_view_disable) 
9f86				cp '*' 
9f86				jr z, .skip 
9f86			 
9f86				push hl 
9f86				push hl 
9f86				call clear_display 
9f86				ld de, .compword 
9f86				ld a, display_row_1 
9f86				call str_at_display 
9f86				pop de 
9f86				ld a, display_row_2 
9f86				call str_at_display 
9f86				ld hl,(cli_ptr) 
9f86				ld a,(hl) 
9f86			        ld hl, os_word_scratch 
9f86				ld (hl),a 
9f86				ld a,0 
9f86				inc hl 
9f86				ld (hl),a 	 
9f86				ld de, os_word_scratch 
9f86				ld a, display_row_2+10 
9f86				call str_at_display 
9f86				call update_display 
9f86				ld a, 100 
9f86				call aDelayInMS 
9f86				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f86				call delay250ms 
9f86				endif 
9f86				pop hl 
9f86			.skip:  
9f86			endif	 
9f86			.execpnchar:    ; compare char between token and string to parse 
9f86			 
9f86			if DEBUG_FORTH_PARSE_KEY 
9f86						DMARK "Ky3" 
9f86			endif 
9f86			if DEBUG_FORTH_PARSE_EXEC 
9f86				; see if disabled 
9f86			 
9f86				ld a, (os_view_disable) 
9f86				cp '*' 
9f86				jr z, .skip2 
9f86			 
9f86			;	call clear_display 
9f86			ld hl,(cli_token) 
9f86			ld a,(hl) 
9f86			ld (os_word_scratch),a 
9f86				ld hl,(cli_ptr) 
9f86			ld a,(hl) 
9f86				ld (os_word_scratch+1),a 
9f86				ld a,0 
9f86				ld (os_word_scratch+2),a 
9f86				ld de,os_word_scratch 
9f86				ld a,display_row_4 
9f86				call str_at_display 
9f86				call update_display 
9f86			.skip2:  
9f86			endif 
9f86 2a 50 ea			ld hl,(cli_token) 
9f89 7e				ld a, (hl)	 ; char in word token 
9f8a 23				inc hl 		; move to next char 
9f8b 22 50 ea			ld (cli_token), hl ; and save it 
9f8e 47				ld b,a 
9f8f			 
9f8f 2a 4a ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f92 7e				ld a,(hl) 
9f93 23				inc hl 
9f94 22 4a ea			ld (cli_ptr), hl		; move to next char 
9f97 cd f7 90			call toUpper 		; make sure the input string matches case 
9f9a			 
9f9a			if DEBUG_FORTH_PARSE 
9f9a			endif 
9f9a			 
9f9a				; input stream end of token is a space so get rid of it 
9f9a			 
9f9a			;	cp ' ' 
9f9a			;	jr nz, .pnskipspace 
9f9a			; 
9f9a			;	ld a, 0		; make same term as word token term 
9f9a			; 
9f9a			;.pnskipspace: 
9f9a			 
9f9a			if DEBUG_FORTH_PARSE_KEY 
9f9a						DMARK "KY7" 
9f9a			endif 
9f9a b8				cp b 
9f9b c2 b1 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f9e				 
9f9e			;    if same 
9f9e			;       scan for string terms 0 for token and 32 for input 
9f9e			 
9f9e				 
9f9e			if DEBUG_FORTH_PARSE_KEY 
9f9e						DMARK "KY8" 
9f9e			endif 
9f9e			 
9f9e 80				add b			 
9f9f fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fa1							; TODO need to make sure last word in zero term string is accounted for 
9fa1 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fa3			 
9fa3			 
9fa3				; at end of both strings so both are exact match 
9fa3			 
9fa3			;       skip ptr for next word 
9fa3			 
9fa3 2a 4a ea			ld hl,(cli_ptr) 	; at input string term 
9fa6 23				inc hl			 ; at next char 
9fa7 22 4a ea			ld (cli_ptr), hl     ; save for next round of the parser 
9faa 22 48 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fad				 
9fad				 
9fad			if DEBUG_FORTH_PARSE_KEY 
9fad						DMARK "KY3" 
9fad			endif 
9fad			 
9fad			 
9fad			 
9fad			;       exec code block 
9fad			if DEBUG_FORTH_JP 
9fad				call clear_display 
9fad				call update_display 
9fad				call delay1s 
9fad				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fad				ld a,h 
9fad				ld hl, os_word_scratch 
9fad				call hexout 
9fad				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fad				ld a,l 
9fad				ld hl, os_word_scratch+2 
9fad				call hexout 
9fad				ld hl, os_word_scratch+4 
9fad				ld a,0 
9fad				ld (hl),a 
9fad				ld de,os_word_scratch 
9fad				call str_at_display 
9fad					ld a, display_row_2 
9fad					call str_at_display 
9fad				ld de, (cli_origtoken) 
9fad				ld a, display_row_1+10 
9fad					call str_at_display 
9fad			 
9fad				ld a,display_row_1 
9fad				ld de, .foundword 
9fad				ld a, display_row_3 
9fad				call str_at_display 
9fad				call update_display 
9fad				call delay1s 
9fad				call delay1s 
9fad				call delay1s 
9fad			endif 
9fad			 
9fad			if DEBUG_FORTH_PARSE_KEY 
9fad						DMARK "KYj" 
9fad			endif 
9fad				; TODO save the word pointer in this exec 
9fad			 
9fad 2a 4e ea			ld hl,(cli_execword) 
9fb0 e9				jp (hl) 
9fb1			 
9fb1			 
9fb1			;    if not same 
9fb1			;	scan for zero term 
9fb1			;	get ptr for next word 
9fb1			;	goto word comp 
9fb1			 
9fb1			.execpnskipword:	; get pointer to next word 
9fb1 2a 4c ea			ld hl,(cli_nextword) 
9fb4			 
9fb4 7e				ld a,(hl) 
9fb5 fe 00			cp WORD_SYS_END 
9fb7			;	cp 0 
9fb7 28 09			jr z, .execendofdict			 ; at end of words 
9fb9			 
9fb9			if DEBUG_FORTH_PARSE_KEY 
9fb9						DMARK "KY4" 
9fb9			endif 
9fb9			if DEBUG_FORTH_PARSE_EXEC 
9fb9			 
9fb9				; see if disabled 
9fb9			 
9fb9				ld a, (os_view_disable) 
9fb9				cp '*' 
9fb9				jr z, .noskip 
9fb9			 
9fb9			 
9fb9				ld de, .nowordfound 
9fb9				ld a, display_row_3 
9fb9				call str_at_display 
9fb9				call update_display 
9fb9				ld a, 100 
9fb9				call aDelayInMS 
9fb9				 
9fb9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fb9					call delay250ms 
9fb9				endif 
9fb9			.noskip:  
9fb9			 
9fb9			endif	 
9fb9			 
9fb9 2a 48 ea			ld hl,(cli_origptr) 
9fbc 22 4a ea			ld (cli_ptr),hl 
9fbf			 
9fbf			if DEBUG_FORTH_PARSE_KEY 
9fbf						DMARK "KY5" 
9fbf			endif 
9fbf c3 65 9f			jp .execpnword			; else go to next word 
9fc2			 
9fc2			.execendofdict:  
9fc2			 
9fc2			if DEBUG_FORTH_PARSE_KEY 
9fc2						DMARK "KYe" 
9fc2			endif 
9fc2			if DEBUG_FORTH_PARSE_EXEC 
9fc2				; see if disabled 
9fc2			 
9fc2				ld a, (os_view_disable) 
9fc2				cp '*' 
9fc2				jr z, .ispskip 
9fc2			 
9fc2				call clear_display 
9fc2				call update_display 
9fc2				call delay1s 
9fc2				ld de, (cli_origptr) 
9fc2				ld a, display_row_1 
9fc2				call str_at_display 
9fc2				 
9fc2				ld de, .enddict 
9fc2				ld a, display_row_3 
9fc2				call str_at_display 
9fc2				call update_display 
9fc2				ld a, 100 
9fc2				call aDelayInMS 
9fc2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc2				call delay1s 
9fc2				call delay1s 
9fc2				call delay1s 
9fc2				endif 
9fc2			.ispskip:  
9fc2				 
9fc2			endif	 
9fc2			 
9fc2			 
9fc2			 
9fc2				; if the word is not a keyword then must be a literal so push it to stack 
9fc2			 
9fc2			; push token to stack to end of word 
9fc2			 
9fc2				STACKFRAME ON $1efe $2f9f 
9fc2				if DEBUG_STACK_IMB 
9fc2					if ON 
9fc2						exx 
9fc2						ld de, $1efe 
9fc2						ld a, d 
9fc2						ld hl, curframe 
9fc2						call hexout 
9fc2						ld a, e 
9fc2						ld hl, curframe+2 
9fc2						call hexout 
9fc2						ld hl, $1efe 
9fc2						push hl 
9fc2						ld hl, $2f9f 
9fc2						push hl 
9fc2						exx 
9fc2					endif 
9fc2				endif 
9fc2			endm 
# End of macro STACKFRAME
9fc2			 
9fc2 2a cc e5		ld hl,(os_tok_ptr) 
9fc5 cd 7d 9c		call forth_apush 
9fc8			 
9fc8				STACKFRAMECHK ON $1efe $2f9f 
9fc8				if DEBUG_STACK_IMB 
9fc8					if ON 
9fc8						exx 
9fc8						ld hl, $2f9f 
9fc8						pop de   ; $2f9f 
9fc8						call cmp16 
9fc8						jr nz, .spnosame 
9fc8						ld hl, $1efe 
9fc8						pop de   ; $1efe 
9fc8						call cmp16 
9fc8						jr z, .spfrsame 
9fc8						.spnosame: call showsperror 
9fc8						.spfrsame: nop 
9fc8						exx 
9fc8					endif 
9fc8				endif 
9fc8			endm 
# End of macro STACKFRAMECHK
9fc8			 
9fc8			execnext: 
9fc8			 
9fc8			if DEBUG_FORTH_PARSE_KEY 
9fc8						DMARK "KY>" 
9fc8			endif 
9fc8			; move past token to next word 
9fc8			 
9fc8 2a cc e5		ld hl, (os_tok_ptr) 
9fcb 3e 00		ld a, 0 
9fcd 01 ff 00		ld bc, 255     ; input buffer size 
9fd0 ed b1		cpir 
9fd2			 
9fd2			if DEBUG_FORTH_PARSE_KEY 
9fd2						DMARK "KY!" 
9fd2				CALLMONITOR 
9fd2			endif	 
9fd2			; TODO this might place hl on the null, so will need to forward on??? 
9fd2			;inc hl   ; see if this gets onto the next item 
9fd2			 
9fd2			 
9fd2			; TODO pass a pointer to the buffer to push 
9fd2			; TODO call function to push 
9fd2			 
9fd2			; look for end of input 
9fd2			 
9fd2			;inc hl 
9fd2			;ld a,(hl) 
9fd2			;cp FORTH_END_BUFFER 
9fd2			;ret z 
9fd2			 
9fd2			 
9fd2 c3 4b 9f		jp exec1 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			findnexttok: 
9fd5			 
9fd5				; hl is pointer to move 
9fd5				; de is the token to locate 
9fd5			 
9fd5					if DEBUG_FORTH 
9fd5						DMARK "NTK" 
9fd5						CALLMONITOR 
9fd5					endif 
9fd5 d5				push de 
9fd6			 
9fd6			.fnt1:	 
9fd6				; find first char of token to locate 
9fd6			 
9fd6 1a				ld a, (de) 
9fd7 4f				ld c,a 
9fd8 7e				ld a,(hl) 
9fd9 cd f7 90			call toUpper 
9fdc					if DEBUG_FORTH 
9fdc						DMARK "NT1" 
9fdc						CALLMONITOR 
9fdc					endif 
9fdc b9				cp c 
9fdd			 
9fdd 28 03			jr z, .fnt2cmpmorefirst	 
9fdf			 
9fdf				; first char not found move to next char 
9fdf			 
9fdf 23				inc hl 
9fe0 18 f4			jr .fnt1 
9fe2			 
9fe2			.fnt2cmpmorefirst:	 
9fe2				; first char of token found.  
9fe2			 
9fe2 e5				push hl     ; save start of token just in case it is the right one 
9fe3 d9				exx 
9fe4 e1				pop hl        ; save it to hl' 
9fe5 d9				exx 
9fe6			 
9fe6			 
9fe6			.fnt2cmpmore:	 
9fe6				; compare the rest 
9fe6				 
9fe6 23				inc hl 
9fe7 13				inc de 
9fe8				 
9fe8 1a				ld a, (de) 
9fe9 4f				ld c,a 
9fea 7e				ld a,(hl) 
9feb cd f7 90			call toUpper 
9fee			 
9fee					if DEBUG_FORTH 
9fee						DMARK "NT2" 
9fee						CALLMONITOR 
9fee					endif 
9fee				; c has the token to find char 
9fee				; a has the mem to scan char 
9fee			 
9fee b9				cp c 
9fef 28 04			jr z,.fntmatch1 
9ff1			 
9ff1				; they are not the same 
9ff1			 
9ff1					if DEBUG_FORTH 
9ff1						DMARK "NT3" 
9ff1						CALLMONITOR 
9ff1					endif 
9ff1 d1				pop de	; reset de token to look for 
9ff2 d5				push de 
9ff3 18 e1			jr .fnt1 
9ff5				 
9ff5			.fntmatch1: 
9ff5			 
9ff5				; is the same char a null which means we might have a full hit? 
9ff5					if DEBUG_FORTH 
9ff5						DMARK "NT4" 
9ff5						CALLMONITOR 
9ff5					endif 
9ff5			 
9ff5 fe 00			cp 0 
9ff7 28 0b			jr z, .fntmatchyes 
9ff9			 
9ff9				; are we at the end of the token to find? 
9ff9			 
9ff9					if DEBUG_FORTH 
9ff9						DMARK "NT5" 
9ff9						CALLMONITOR 
9ff9					endif 
9ff9 3e 00			ld a, 0 
9ffb b9				cp c 
9ffc			 
9ffc c2 e6 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9fff			 
9fff					if DEBUG_FORTH 
9fff						DMARK "NT6" 
9fff						CALLMONITOR 
9fff					endif 
9fff				; token to find is exhusted but no match to stream 
9fff			 
9fff				; restore tok pointer and continue on 
9fff d1				pop de 
a000 d5				push de 
a001 c3 d6 9f			jp .fnt1 
a004			 
a004			 
a004			.fntmatchyes: 
a004			 
a004				; hl now contains the end of the found token 
a004			 
a004				; get rid of saved token pointer to find 
a004			 
a004 d1				pop de 
a005			 
a005					if DEBUG_FORTH 
a005						DMARK "NT9" 
a005						CALLMONITOR 
a005					endif 
a005			 
a005				; hl will be on the null term so forward on 
a005			 
a005				; get back the saved start of the token 
a005			 
a005 d9				exx 
a006 e5				push hl     ; save start of token just in case it is the right one 
a007 d9				exx 
a008 e1				pop hl        ; save it to hl 
a009			 
a009 c9				ret 
a00a			 
a00a			 
a00a			; LIST needs to find a specific token   
a00a			; FORGET needs to find a spefici token 
a00a			 
a00a			; SAVE needs to find all tokens by flag 
a00a			; WORDS just needs to scan through all  by flag 
a00a			; UWORDS needs to scan through all by flag 
a00a			 
a00a			 
a00a			; given hl as pointer to start of dict look up string 
a00a			; return hl as pointer to start of word block 
a00a			; or 0 if not found 
a00a			 
a00a			forth_find_tok: 
a00a c9				ret 
a00b			 
a00b			; given hl as pointer to dict structure 
a00b			; move to the next dict block structure 
a00b			 
a00b			forth_tok_next: 
a00b				; hl now points to the address of the next word pointer  
a00b				; TODO skip compiled symbol for now 
a00b			;	push de 
a00b 23				inc hl 
a00c 5e				ld e, (hl) 
a00d 23				inc hl 
a00e 56				ld d, (hl) 
a00f 23				inc hl 
a010			 
a010 eb				ex de,hl 
a011			if DEBUG_FORTH_PARSE_NEXTWORD 
a011				push bc 
a011				ld bc, (cli_nextword) 
a011						DMARK "NXW" 
a011				CALLMONITOR 
a011				pop bc 
a011			endif 
a011			;	pop de	 
a011 c9				ret 
a012			 
a012			 
a012			 
a012			; eof 
# End of file forth_parserv5.asm
a012				include "forth_wordsv4.asm" 
a012			 
a012			; the core word dictionary v4 
a012			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a012			 
a012			; this is a linked list for each of the system words used 
a012			; user defined words will follow the same format but will be in ram 
a012			 
a012			 
a012			; 
a012			; 
a012			; define linked list: 
a012			; 
a012			; 1. compiled byte op code 
a012			; 2. len of text word 
a012			; 3. text word 
a012			; 4. ptr to next dictionary word 
a012			; 5. asm, calls etc for the word 
a012			; 
a012			;  if 1 == 0 then last word in dict  
a012			;   
a012			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a012			;  
a012			;  
a012			; create basic standard set of words 
a012			; 
a012			;  
a012			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a012			; 2DUP 2DROP 2SWAP  
a012			; @ C@ - get byte  
a012			; ! C! - store byte 
a012			; 0< true if less than zero 
a012			; 0= true if zero 
a012			; < >  
a012			; = true if same 
a012			; variables 
a012			 
a012			 
a012			; Hardware specific words I may need 
a012			; 
a012			; IN OUT  
a012			; calls to key util functions 
a012			; calls to hardward abstraction stuff 
a012			; easy control of frame buffers and lcd i/o 
a012			; keyboard  
a012			 
a012			 
a012			;DICT: macro 
a012			; op_code, len, word, next 
a012			;    word: 
a012			;    db op_code 
a012			;    ds word zero term 
a012			;    dw next 
a012			;    endm 
a012			 
a012			 
a012			 
a012			 
a012			; op code 1 is a flag for user define words which are to be handled differently 
a012			 
a012			 
a012			; 
a012			; 
a012			;    TODO on entry to a word this should be the expected environment 
a012			;    hl - tos value if number then held, if string this is the ptr 
a012			;    de -  
a012			 
a012			 
a012			; opcode ranges 
a012			; 0 - end of word dict 
a012			; 255 - user define words 
a012			 
a012			sysdict: 
a012			include "forth_opcodes.asm" 
a012			; op codes for forth keywords 
a012			; free to use code 0  
a012				OPCODE_HEAP: equ  1 
a012				OPCODE_EXEC: equ 2 
a012				OPCODE_DUP: equ 3 
a012				OPCODE_SWAP: equ 4 
a012				OPCODE_COLN: equ 5 
a012				OPCODE_SCOLN: equ 6 
a012				OPCODE_DROP: equ 7 
a012				OPCODE_DUP2: equ 8 
a012				OPCODE_DROP2: equ 9 
a012				OPCODE_SWAP2: equ 10 
a012				OPCODE_AT: equ 11 
a012				OPCODE_CAT: equ 12 
a012				OPCODE_BANG: equ 13 
a012				OPCODE_CBANG: equ 14 
a012				OPCODE_SCALL: equ 15 
a012				OPCODE_DEPTH: equ 16 
a012				OPCODE_OVER: equ 17 
a012				OPCODE_PAUSE: equ 18 
a012				OPCODE_PAUSES: equ 19 
a012				OPCODE_ROT: equ 20 
a012			;free to reuse	OPCODE_WORDS: equ 21 
a012			        OPCODE_NOT: equ 21 
a012				OPCODE_UWORDS: equ 22 
a012				OPCODE_BP: equ 23 
a012				OPCODE_MONITOR: equ 24  
a012				OPCODE_MALLOC: equ 25 
a012				OPCODE_FREE: equ 26 
a012				OPCODE_LIST: equ 27 
a012				OPCODE_FORGET: equ 28 
a012				OPCODE_NOP: equ 29 
a012				OPCODE_COMO: equ 30 
a012				OPCODE_COMC: equ 31 
a012			;free to reuse	OPCODE_ENDCORE: equ 32 
a012				OPCODE_AFTERSOUND: equ 33 
a012				OPCODE_GP2: equ 34 
a012				OPCODE_GP3: equ 35 
a012				OPCODE_GP4: equ 36 
a012				OPCODE_SIN: equ 37 
a012				OPCODE_SOUT: equ 38 
a012				OPCODE_SPIO: equ 39 
a012				OPCODE_SPICEH: equ 40 
a012				OPCODE_SPIOb: equ 41 
a012				OPCODE_SPII: equ 42 
a012				OPCODE_SESEL: equ 43 
a012				OPCODE_CARTDEV: equ 44 
a012			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a012				OPCODE_FB: equ 46 
a012				OPCODE_EMIT: equ 47 
a012				OPCODE_DOTH: equ 48 
a012				OPCODE_DOTF: equ 49 
a012				OPCODE_DOT: equ 50 
a012				OPCODE_CLS: equ 51 
a012				OPCODE_DRAW: equ 52 
a012				OPCODE_DUMP: equ 53 
a012				OPCODE_CDUMP: equ 54 
a012				OPCODE_DAT: equ 55 
a012				OPCODE_HOME: equ 56 
a012				OPCODE_SPACE: equ 57 
a012				OPCODE_SPACES: equ 58 
a012				OPCODE_SCROLL: equ 59 
a012				OPCODE_ATQ: equ 60 
a012				OPCODE_AUTODSP: equ 61 
a012				OPCODE_MENU: equ 62 
a012			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a012				OPCODE_THEN: equ 64 
a012				OPCODE_ELSE: equ 65 
a012				OPCODE_DO: equ 66 
a012				OPCODE_LOOP: equ 67 
a012				OPCODE_I: equ 68 
a012				OPCODE_DLOOP: equ 69  
a012				OPCODE_REPEAT: equ 70  
a012				OPCODE_UNTIL: equ 71 
a012				OPCODE_ENDFLOW: equ 72 
a012				OPCODE_WAITK: equ 73 
a012				OPCODE_ACCEPT: equ 74 
a012				OPCODE_EDIT: equ 75 
a012			;free to reuse	OPCODE_ENDKEY: equ 76 
a012				OPCODE_LZERO: equ 77 
a012				OPCODE_TZERO: equ 78 
a012				OPCODE_LESS: equ 79 
a012				OPCODE_GT: equ 80 
a012				OPCODE_EQUAL: equ 81  
a012			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a012				OPCODE_NEG: equ 83 
a012				OPCODE_DIV: equ 84 
a012				OPCODE_MUL: equ 85 
a012				OPCODE_MIN: equ 86 
a012				OPCODE_MAX: equ 87 
a012				OPCODE_RND16: equ 88 
a012				OPCODE_RND8: equ 89 
a012				OPCODE_RND: equ 90 
a012			;free to reuse	OPCODE_ENDMATHS: equ 91  
a012				OPCODE_BYNAME: equ 92 
a012				OPCODE_DIR: equ 93 
a012				OPCODE_SAVE: equ 94 
a012				OPCODE_LOAD: equ 95 
a012				OPCODE_BSAVE: equ 96 
a012				OPCODE_BLOAD: equ 97 
a012				OPCODE_SEO: equ 98  
a012				OPCODE_SEI: equ 99 
a012				OPCODE_SFREE: equ 100 
a012				OPCODE_SIZE: equ 101 
a012				OPCODE_CREATE: equ 102 
a012				OPCODE_APPEND: equ 103 
a012				OPCODE_SDEL: equ 104 
a012				OPCODE_OPEN: equ 105 
a012				OPCODE_READ: equ 106 
a012				OPCODE_EOF: equ 106 
a012				OPCODE_FORMAT: equ 107 
a012				OPCODE_LABEL: equ 108 
a012				OPCODE_LABELS: equ 109 
a012			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a012				OPCODE_UPPER: equ 111 
a012				OPCODE_LOWER: equ 112 
a012				OPCODE_SUBSTR: equ 113 
a012				OPCODE_LEFT: equ 114 
a012				OPCODE_RIGHT: equ 115 
a012				OPCODE_STR2NUM: equ 116 
a012				OPCODE_NUM2STR: equ 117 
a012				OPCODE_CONCAT: equ 118 
a012				OPCODE_FIND: equ 119 
a012				OPCODE_LEN: equ 120 
a012				OPCODE_CHAR: equ 121 
a012			; free to reuse	OPCODE_STRLEN: equ 122 
a012			; free to reuse	OPCODE_ENDSTR: equ 123 
a012				OPCODE_V0S: equ 124 
a012				OPCODE_V0Q: equ 125 
a012				OPCODE_V1S: equ 126 
a012				OPCODE_V1Q: equ 127 
a012				OPCODE_V2S: equ 128 
a012				OPCODE_V2Q: equ 129 
a012				OPCODE_V3S: equ 130 
a012				OPCODE_V3Q: equ 131 
a012			;free to reuse	OPCODE_END: equ 132 
a012				OPCODE_ZDUP: equ 133 
a012			 
a012			; eof 
# End of file forth_opcodes.asm
a012			 
a012			include "forth_words_core.asm" 
a012			 
a012			; | ## Core Words 
a012			 
a012			;if MALLOC_4 
a012			 
a012			.HEAP: 
a012				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a012 15				db WORD_SYS_CORE+OPCODE_HEAP             
a013 51 a0			dw .EXEC            
a015 05				db 4 + 1 
a016 .. 00			db "HEAP",0              
a01b				endm 
# End of macro CWHEAD
a01b			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a01b			; | | u1 - Current number of bytes in the heap 
a01b			; | | u2 - Remaining bytes left on the heap 
a01b			; | |  
a01b			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a01b			 
a01b			 
a01b					if DEBUG_FORTH_WORDS_KEY 
a01b						DMARK "HEP" 
a01b f5				push af  
a01c 3a 30 a0			ld a, (.dmark)  
a01f 32 71 ee			ld (debug_mark),a  
a022 3a 31 a0			ld a, (.dmark+1)  
a025 32 72 ee			ld (debug_mark+1),a  
a028 3a 32 a0			ld a, (.dmark+2)  
a02b 32 73 ee			ld (debug_mark+2),a  
a02e 18 03			jr .pastdmark  
a030 ..			.dmark: db "HEP"  
a033 f1			.pastdmark: pop af  
a034			endm  
# End of macro DMARK
a034						CALLMONITOR 
a034 cd a3 94			call break_point_state  
a037				endm  
# End of macro CALLMONITOR
a037					endif 
a037 2a 65 e0				ld hl, (free_list )      
a03a 11 6a e0				ld de, heap_start 
a03d			 
a03d ed 52				sbc hl, de  
a03f			 
a03f cd 14 9b				call forth_push_numhl 
a042			 
a042			 
a042 ed 5b 65 e0			ld de, (free_list )      
a046 21 b1 e2				ld hl, heap_end 
a049			 
a049 ed 52				sbc hl, de 
a04b			 
a04b cd 14 9b				call forth_push_numhl 
a04e					 
a04e			 
a04e					 
a04e			 
a04e			 
a04e			 
a04e					NEXTW 
a04e c3 ba 9e			jp macro_next 
a051				endm 
# End of macro NEXTW
a051			;endif 
a051			 
a051			.EXEC: 
a051			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a051			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a051			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a051			;; > > 
a051			;; > >   
a051			;	STACKFRAME OFF $5efe $5f9f 
a051			; 
a051			;		if DEBUG_FORTH_WORDS_KEY 
a051			;			DMARK "EXE" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			; 
a051			;	FORTH_DSP_VALUEHL 
a051			; 
a051			;	FORTH_DSP_POP 
a051			; 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EX1" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;;	ld e,(hl) 
a051			;;	inc hl 
a051			;;	ld d,(hl) 
a051			;;	ex de,hl 
a051			; 
a051			;;		if DEBUG_FORTH_WORDS 
a051			;;			DMARK "EX2" 
a051			;;			CALLMONITOR 
a051			;;		endif 
a051			;	push hl 
a051			; 
a051			;	;ld a, 0 
a051			;	;ld a, FORTH_END_BUFFER 
a051			;	call strlenz 
a051			;	inc hl   ; include zero term to copy 
a051			;	inc hl   ; include term 
a051			;	inc hl   ; include term 
a051			;	ld b,0 
a051			;	ld c,l 
a051			;	pop hl 
a051			;	ld de, execscratch 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EX3" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;	ldir 
a051			; 
a051			; 
a051			;	ld hl, execscratch 
a051			; 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EXe" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			; 
a051			;	call forthparse 
a051			;	call forthexec 
a051			;;	call forthexec_cleanup 
a051			;;	call forthparse 
a051			;;	call forthexec 
a051			; 
a051			;	STACKFRAMECHK OFF $5efe $5f9f 
a051			; 
a051			;	; an immediate word so no need to process any more words 
a051			;	ret 
a051			;	NEXTW 
a051			 
a051			; dead code - old version  
a051			;	FORTH_RSP_NEXT 
a051			 
a051			;  
a051			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a051			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a051			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a051			;	push hl 
a051			;	push de 
a051			;	push bc 
a051			; 
a051			; 
a051			;		if DEBUG_FORTH_WORDS_KEY 
a051			;			DMARK "EXR" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			; 
a051			; 
a051			; 
a051			;	;v5 FORTH_DSP_VALUE 
a051			;	FORTH_DSP_VALUEHL 
a051			; 
a051			;	; TODO do string type checks 
a051			; 
a051			;;v5	inc hl   ; skip type 
a051			; 
a051			;	push hl  ; source code  
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EX1" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;	ld a, 0 
a051			;	call strlent 
a051			; 
a051			;	inc hl 
a051			;	inc hl 
a051			;	inc hl 
a051			;	inc hl 
a051			; 
a051			;	push hl    ; size 
a051			; 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EX2" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;	call malloc 
a051			; 
a051			;	ex de, hl    ; de now contains malloc area 
a051			;	pop bc   	; get byte count 
a051			;	pop hl      ; get string to copy 
a051			; 
a051			;	push de     ; save malloc for free later 
a051			; 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EX3" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;	ldir       ; duplicate string 
a051			; 
a051			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a051			;	 
a051			;	; TODO fix the parse would be better than this...  
a051			;	ex de, hl 
a051			;	dec hl 
a051			;	ld a, 0 
a051			;	ld (hl), a 
a051			;	dec hl 
a051			;	ld a, ' ' 
a051			;	ld (hl), a 
a051			;	dec hl 
a051			;	ld (hl), a 
a051			; 
a051			;	dec hl 
a051			;	ld (hl), a 
a051			; 
a051			; 
a051			;	FORTH_DSP_POP  
a051			; 
a051			;	pop hl     
a051			;	push hl    ; save malloc area 
a051			; 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EX4" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			; 
a051			;	call forthparse 
a051			;	call forthexec 
a051			;	 
a051			;	pop hl 
a051			;	if DEBUG_FORTH_WORDS 
a051			;		DMARK "EX5" 
a051			;		CALLMONITOR 
a051			;	endif 
a051			; 
a051			;	if FORTH_ENABLE_FREE 
a051			;	call free 
a051			;	endif 
a051			; 
a051			;	if DEBUG_FORTH_WORDS 
a051			;		DMARK "EX6" 
a051			;		CALLMONITOR 
a051			;	endif 
a051			; 
a051			;	pop bc 
a051			;	pop de 
a051			;	pop hl 
a051			;;	FORTH_RSP_POP	  
a051			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a051			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a051			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a051			; 
a051			;	if DEBUG_FORTH_WORDS 
a051			;		DMARK "EX7" 
a051			;		CALLMONITOR 
a051			;	endif 
a051			;	NEXTW 
a051			 
a051			;.STKEXEC: 
a051			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a051			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a051			; 
a051			; 
a051			;		if DEBUG_FORTH_WORDS_KEY 
a051			;			DMARK "STX" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			; 
a051			;	FORTH_DSP_VALUEHL 
a051			; 
a051			;	ld (store_tmp1), hl    ; count 
a051			; 
a051			;	FORTH_DSP_POP 
a051			;.stkexec1: 
a051			;	ld hl, (store_tmp1)   ; count 
a051			;	ld a, 0 
a051			;	cp l 
a051			;	ret z 
a051			; 
a051			;	dec hl 
a051			;	ld (store_tmp1), hl    ; count 
a051			;	 
a051			;	FORTH_DSP_VALUEHL 
a051			;	push hl 
a051			;	 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EXp" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;	FORTH_DSP_POP 
a051			; 
a051			;	call strlenz 
a051			;	inc hl   ; include zero term to copy 
a051			;	inc hl   ; include zero term to copy 
a051			;	inc hl   ; include zero term to copy 
a051			;	ld b,0 
a051			;	ld c,l 
a051			;	pop hl 
a051			;	ld de, execscratch 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EX3" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;	ldir 
a051			; 
a051			; 
a051			;	ld hl, execscratch 
a051			; 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EXP" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			; 
a051			;	call forthparse 
a051			;	ld hl, execscratch 
a051			;		if DEBUG_FORTH_WORDS 
a051			;			DMARK "EXx" 
a051			;			CALLMONITOR 
a051			;		endif 
a051			;	call forthexec 
a051			; 
a051			;	jp .stkexec1 
a051			; 
a051			;	ret 
a051			 
a051			 
a051			.DUP: 
a051				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a051 17				db WORD_SYS_CORE+OPCODE_DUP             
a052 c7 a0			dw .ZDUP            
a054 04				db 3 + 1 
a055 .. 00			db "DUP",0              
a059				endm 
# End of macro CWHEAD
a059			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a059			 
a059					if DEBUG_FORTH_WORDS_KEY 
a059						DMARK "DUP" 
a059 f5				push af  
a05a 3a 6e a0			ld a, (.dmark)  
a05d 32 71 ee			ld (debug_mark),a  
a060 3a 6f a0			ld a, (.dmark+1)  
a063 32 72 ee			ld (debug_mark+1),a  
a066 3a 70 a0			ld a, (.dmark+2)  
a069 32 73 ee			ld (debug_mark+2),a  
a06c 18 03			jr .pastdmark  
a06e ..			.dmark: db "DUP"  
a071 f1			.pastdmark: pop af  
a072			endm  
# End of macro DMARK
a072						CALLMONITOR 
a072 cd a3 94			call break_point_state  
a075				endm  
# End of macro CALLMONITOR
a075					endif 
a075			 
a075					FORTH_DSP 
a075 cd d1 9c			call macro_forth_dsp 
a078				endm 
# End of macro FORTH_DSP
a078			 
a078 7e					ld a, (HL) 
a079 fe 01				cp DS_TYPE_STR 
a07b 20 25				jr nz, .dupinum 
a07d			 
a07d					; push another string 
a07d			 
a07d					FORTH_DSP_VALUEHL     		 
a07d cd 0b 9d			call macro_dsp_valuehl 
a080				endm 
# End of macro FORTH_DSP_VALUEHL
a080			 
a080				if DEBUG_FORTH_WORDS 
a080					DMARK "DUs" 
a080 f5				push af  
a081 3a 95 a0			ld a, (.dmark)  
a084 32 71 ee			ld (debug_mark),a  
a087 3a 96 a0			ld a, (.dmark+1)  
a08a 32 72 ee			ld (debug_mark+1),a  
a08d 3a 97 a0			ld a, (.dmark+2)  
a090 32 73 ee			ld (debug_mark+2),a  
a093 18 03			jr .pastdmark  
a095 ..			.dmark: db "DUs"  
a098 f1			.pastdmark: pop af  
a099			endm  
# End of macro DMARK
a099					CALLMONITOR 
a099 cd a3 94			call break_point_state  
a09c				endm  
# End of macro CALLMONITOR
a09c				endif 
a09c cd 82 9b				call forth_push_str 
a09f			 
a09f					NEXTW 
a09f c3 ba 9e			jp macro_next 
a0a2				endm 
# End of macro NEXTW
a0a2			 
a0a2			 
a0a2			.dupinum: 
a0a2					 
a0a2			 
a0a2			 
a0a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0a2 cd 0b 9d			call macro_dsp_valuehl 
a0a5				endm 
# End of macro FORTH_DSP_VALUEHL
a0a5			 
a0a5				; TODO add floating point number detection 
a0a5			 
a0a5				if DEBUG_FORTH_WORDS 
a0a5					DMARK "DUi" 
a0a5 f5				push af  
a0a6 3a ba a0			ld a, (.dmark)  
a0a9 32 71 ee			ld (debug_mark),a  
a0ac 3a bb a0			ld a, (.dmark+1)  
a0af 32 72 ee			ld (debug_mark+1),a  
a0b2 3a bc a0			ld a, (.dmark+2)  
a0b5 32 73 ee			ld (debug_mark+2),a  
a0b8 18 03			jr .pastdmark  
a0ba ..			.dmark: db "DUi"  
a0bd f1			.pastdmark: pop af  
a0be			endm  
# End of macro DMARK
a0be					CALLMONITOR 
a0be cd a3 94			call break_point_state  
a0c1				endm  
# End of macro CALLMONITOR
a0c1				endif 
a0c1			 
a0c1 cd 14 9b				call forth_push_numhl 
a0c4					NEXTW 
a0c4 c3 ba 9e			jp macro_next 
a0c7				endm 
# End of macro NEXTW
a0c7			.ZDUP: 
a0c7				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a0c7 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0c8 ff a0			dw .SWAP            
a0ca 05				db 4 + 1 
a0cb .. 00			db "?DUP",0              
a0d0				endm 
# End of macro CWHEAD
a0d0			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a0d0			 
a0d0					if DEBUG_FORTH_WORDS_KEY 
a0d0						DMARK "qDU" 
a0d0 f5				push af  
a0d1 3a e5 a0			ld a, (.dmark)  
a0d4 32 71 ee			ld (debug_mark),a  
a0d7 3a e6 a0			ld a, (.dmark+1)  
a0da 32 72 ee			ld (debug_mark+1),a  
a0dd 3a e7 a0			ld a, (.dmark+2)  
a0e0 32 73 ee			ld (debug_mark+2),a  
a0e3 18 03			jr .pastdmark  
a0e5 ..			.dmark: db "qDU"  
a0e8 f1			.pastdmark: pop af  
a0e9			endm  
# End of macro DMARK
a0e9						CALLMONITOR 
a0e9 cd a3 94			call break_point_state  
a0ec				endm  
# End of macro CALLMONITOR
a0ec					endif 
a0ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0ec cd 0b 9d			call macro_dsp_valuehl 
a0ef				endm 
# End of macro FORTH_DSP_VALUEHL
a0ef			 
a0ef e5					push hl 
a0f0			 
a0f0					; is it a zero? 
a0f0			 
a0f0 3e 00				ld a, 0 
a0f2 84					add h 
a0f3 85					add l 
a0f4			 
a0f4 e1					pop hl 
a0f5			 
a0f5 fe 00				cp 0 
a0f7 28 03				jr z, .dup2orig 
a0f9			 
a0f9			 
a0f9 cd 14 9b				call forth_push_numhl 
a0fc			 
a0fc			 
a0fc				; TODO add floating point number detection 
a0fc			 
a0fc			.dup2orig: 
a0fc			 
a0fc					NEXTW 
a0fc c3 ba 9e			jp macro_next 
a0ff				endm 
# End of macro NEXTW
a0ff			.SWAP: 
a0ff				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a0ff 18				db WORD_SYS_CORE+OPCODE_SWAP             
a100 3e a1			dw .COLN            
a102 05				db 4 + 1 
a103 .. 00			db "SWAP",0              
a108				endm 
# End of macro CWHEAD
a108			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a108					if DEBUG_FORTH_WORDS_KEY 
a108						DMARK "SWP" 
a108 f5				push af  
a109 3a 1d a1			ld a, (.dmark)  
a10c 32 71 ee			ld (debug_mark),a  
a10f 3a 1e a1			ld a, (.dmark+1)  
a112 32 72 ee			ld (debug_mark+1),a  
a115 3a 1f a1			ld a, (.dmark+2)  
a118 32 73 ee			ld (debug_mark+2),a  
a11b 18 03			jr .pastdmark  
a11d ..			.dmark: db "SWP"  
a120 f1			.pastdmark: pop af  
a121			endm  
# End of macro DMARK
a121						CALLMONITOR 
a121 cd a3 94			call break_point_state  
a124				endm  
# End of macro CALLMONITOR
a124					endif 
a124			 
a124					FORTH_DSP_VALUEHL 
a124 cd 0b 9d			call macro_dsp_valuehl 
a127				endm 
# End of macro FORTH_DSP_VALUEHL
a127 e5					push hl     ; w2 
a128			 
a128					FORTH_DSP_POP 
a128 cd c3 9d			call macro_forth_dsp_pop 
a12b				endm 
# End of macro FORTH_DSP_POP
a12b			 
a12b					FORTH_DSP_VALUEHL 
a12b cd 0b 9d			call macro_dsp_valuehl 
a12e				endm 
# End of macro FORTH_DSP_VALUEHL
a12e			 
a12e					FORTH_DSP_POP 
a12e cd c3 9d			call macro_forth_dsp_pop 
a131				endm 
# End of macro FORTH_DSP_POP
a131			 
a131 d1					pop de     ; w2	, hl = w1 
a132			 
a132 eb					ex de, hl 
a133 d5					push de 
a134			 
a134 cd 14 9b				call forth_push_numhl 
a137			 
a137 e1					pop hl 
a138			 
a138 cd 14 9b				call forth_push_numhl 
a13b					 
a13b			 
a13b					NEXTW 
a13b c3 ba 9e			jp macro_next 
a13e				endm 
# End of macro NEXTW
a13e			.COLN: 
a13e				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a13e 19				db WORD_SYS_CORE+OPCODE_COLN             
a13f ca a2			dw .SCOLN            
a141 02				db 1 + 1 
a142 .. 00			db ":",0              
a144				endm 
# End of macro CWHEAD
a144			; | : ( -- )         Create new word | DONE 
a144			 
a144					if DEBUG_FORTH_WORDS_KEY 
a144						DMARK "CLN" 
a144 f5				push af  
a145 3a 59 a1			ld a, (.dmark)  
a148 32 71 ee			ld (debug_mark),a  
a14b 3a 5a a1			ld a, (.dmark+1)  
a14e 32 72 ee			ld (debug_mark+1),a  
a151 3a 5b a1			ld a, (.dmark+2)  
a154 32 73 ee			ld (debug_mark+2),a  
a157 18 03			jr .pastdmark  
a159 ..			.dmark: db "CLN"  
a15c f1			.pastdmark: pop af  
a15d			endm  
# End of macro DMARK
a15d						CALLMONITOR 
a15d cd a3 94			call break_point_state  
a160				endm  
# End of macro CALLMONITOR
a160					endif 
a160				STACKFRAME OFF $8efe $989f 
a160				if DEBUG_STACK_IMB 
a160					if OFF 
a160						exx 
a160						ld de, $8efe 
a160						ld a, d 
a160						ld hl, curframe 
a160						call hexout 
a160						ld a, e 
a160						ld hl, curframe+2 
a160						call hexout 
a160						ld hl, $8efe 
a160						push hl 
a160						ld hl, $989f 
a160						push hl 
a160						exx 
a160					endif 
a160				endif 
a160			endm 
# End of macro STACKFRAME
a160				; get parser buffer length  of new word 
a160			 
a160				 
a160			 
a160					; move tok past this to start of name defintition 
a160					; TODO get word to define 
a160					; TODO Move past word token 
a160					; TODO get length of string up to the ';' 
a160			 
a160 2a cc e5			ld hl, (os_tok_ptr) 
a163 23				inc hl 
a164 23				inc hl 
a165			 
a165 3e 3b			ld a, ';' 
a167 cd 0b 91			call strlent 
a16a			 
a16a 7d				ld a,l 
a16b 32 c7 e2			ld (os_new_parse_len), a 
a16e			 
a16e			 
a16e			if DEBUG_FORTH_UWORD 
a16e ed 5b cc e5		ld de, (os_tok_ptr) 
a172						DMARK ":01" 
a172 f5				push af  
a173 3a 87 a1			ld a, (.dmark)  
a176 32 71 ee			ld (debug_mark),a  
a179 3a 88 a1			ld a, (.dmark+1)  
a17c 32 72 ee			ld (debug_mark+1),a  
a17f 3a 89 a1			ld a, (.dmark+2)  
a182 32 73 ee			ld (debug_mark+2),a  
a185 18 03			jr .pastdmark  
a187 ..			.dmark: db ":01"  
a18a f1			.pastdmark: pop af  
a18b			endm  
# End of macro DMARK
a18b				CALLMONITOR 
a18b cd a3 94			call break_point_state  
a18e				endm  
# End of macro CALLMONITOR
a18e			endif 
a18e			 
a18e			; 
a18e			;  new word memory layout: 
a18e			;  
a18e			;    : adg 6666 ;  
a18e			; 
a18e			;    db   1     ; user defined word  
a18e 23				inc hl    
a18f			;    dw   sysdict 
a18f 23				inc hl 
a190 23				inc hl 
a191			;    db <word len>+1 (for null) 
a191 23				inc hl 
a192			;    db .... <word> 
a192			; 
a192			 
a192 23				inc hl    ; some extras for the word preamble before the above 
a193 23				inc hl 
a194 23				inc hl 
a195 23				inc hl 
a196 23				inc hl 
a197 23				inc hl 
a198 23				inc hl  
a199 23				inc hl 
a19a 23				inc hl 
a19b 23				inc hl 
a19c 23				inc hl 
a19d 23				inc hl 
a19e 23				inc hl 
a19f 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1a0			;       exec word buffer 
a1a0			;	<ptr word>   
a1a0 23				inc hl 
a1a1 23				inc hl 
a1a2			;       <word list><null term> 7F final term 
a1a2			 
a1a2			 
a1a2			if DEBUG_FORTH_UWORD 
a1a2						DMARK ":02" 
a1a2 f5				push af  
a1a3 3a b7 a1			ld a, (.dmark)  
a1a6 32 71 ee			ld (debug_mark),a  
a1a9 3a b8 a1			ld a, (.dmark+1)  
a1ac 32 72 ee			ld (debug_mark+1),a  
a1af 3a b9 a1			ld a, (.dmark+2)  
a1b2 32 73 ee			ld (debug_mark+2),a  
a1b5 18 03			jr .pastdmark  
a1b7 ..			.dmark: db ":02"  
a1ba f1			.pastdmark: pop af  
a1bb			endm  
# End of macro DMARK
a1bb				CALLMONITOR 
a1bb cd a3 94			call break_point_state  
a1be				endm  
# End of macro CALLMONITOR
a1be			endif 
a1be			 
a1be				 
a1be					; malloc the size 
a1be			 
a1be cd 69 91				call malloc 
a1c1 22 c9 e2				ld (os_new_malloc), hl     ; save malloc start 
a1c4			 
a1c4			;    db   1     ; user defined word  
a1c4 3e 01				ld a, WORD_SYS_UWORD  
a1c6 77					ld (hl), a 
a1c7				 
a1c7 23				inc hl    
a1c8			;    dw   sysdict 
a1c8 11 12 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a1cb 73				ld (hl), e 
a1cc 23				inc hl 
a1cd 72				ld (hl), d 
a1ce 23				inc hl 
a1cf			 
a1cf			 
a1cf			;    Setup dict word 
a1cf			 
a1cf 23				inc hl 
a1d0 22 c3 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a1d3			 
a1d3				; 1. get length of dict word 
a1d3			 
a1d3			 
a1d3 2a cc e5			ld hl, (os_tok_ptr) 
a1d6 23				inc hl 
a1d7 23				inc hl    ; position to start of dict word 
a1d8 3e 00			ld a, 0 
a1da cd 0b 91			call strlent 
a1dd			 
a1dd			 
a1dd 23				inc hl    ; to include null??? 
a1de			 
a1de				; write length of dict word 
a1de			 
a1de ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1e2 1b				dec de 
a1e3 eb				ex de, hl 
a1e4 73				ld (hl), e 
a1e5 eb				ex de, hl 
a1e6			 
a1e6				 
a1e6			 
a1e6				; copy  
a1e6 4d				ld c, l 
a1e7 06 00			ld b, 0 
a1e9 ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1ed 2a cc e5			ld hl, (os_tok_ptr) 
a1f0 23				inc hl 
a1f1 23				inc hl    ; position to start of dict word 
a1f2				 
a1f2			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a1f2				 
a1f2				; TODO need to convert word to upper case 
a1f2			 
a1f2			ucasetok:	 
a1f2 7e				ld a,(hl) 
a1f3 cd f7 90			call toUpper 
a1f6 77				ld (hl),a 
a1f7 ed a0			ldi 
a1f9 f2 f2 a1		 	jp p, ucasetok 
a1fc			 
a1fc			 
a1fc			 
a1fc				; de now points to start of where the word body code should be placed 
a1fc ed 53 c3 e2		ld (os_new_work_ptr), de 
a200				; hl now points to the words to throw at forthexec which needs to be copied 
a200 22 c1 e2			ld (os_new_src_ptr), hl 
a203			 
a203				; TODO add 'call to forthexec' 
a203			 
a203			if DEBUG_FORTH_UWORD 
a203 c5				push bc 
a204 ed 4b c9 e2		ld bc, (os_new_malloc) 
a208						DMARK ":0x" 
a208 f5				push af  
a209 3a 1d a2			ld a, (.dmark)  
a20c 32 71 ee			ld (debug_mark),a  
a20f 3a 1e a2			ld a, (.dmark+1)  
a212 32 72 ee			ld (debug_mark+1),a  
a215 3a 1f a2			ld a, (.dmark+2)  
a218 32 73 ee			ld (debug_mark+2),a  
a21b 18 03			jr .pastdmark  
a21d ..			.dmark: db ":0x"  
a220 f1			.pastdmark: pop af  
a221			endm  
# End of macro DMARK
a221				CALLMONITOR 
a221 cd a3 94			call break_point_state  
a224				endm  
# End of macro CALLMONITOR
a224 c1				pop bc 
a225			endif 
a225			 
a225			 
a225				; create word preamble which should be: 
a225			 
a225			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a225			 
a225				;    ld hl, <word code> 
a225				;    jp user_exec 
a225			        ;    <word code bytes> 
a225			 
a225			 
a225			;	inc de     ; TODO ??? or are we already past the word's null 
a225 eb				ex de, hl 
a226			 
a226 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a228			 
a228 23				inc hl 
a229 22 bd e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a22c 23				inc hl 
a22d			 
a22d 23				inc hl 
a22e 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a230			 
a230 01 cc c8			ld bc, user_exec 
a233 23				inc hl 
a234 71				ld (hl), c     ; poke address of user_exec 
a235 23				inc hl 
a236 70				ld (hl), b     
a237			 ; 
a237			;	inc hl 
a237			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a237			; 
a237			; 
a237			;	ld bc, macro_forth_rsp_next 
a237			;	inc hl 
a237			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a237			;	inc hl 
a237			;	ld (hl), b     
a237			 ; 
a237			;	inc hl 
a237			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a237			; 
a237			; 
a237			;	inc hl 
a237			;	ld bc, forthexec 
a237			;	ld (hl), c     ; poke address of forthexec 
a237			;	inc hl 
a237			;	ld (hl), b      
a237			; 
a237			;	inc hl 
a237			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a237			; 
a237			;	ld bc, user_dict_next 
a237			;	inc hl 
a237			;	ld (hl), c     ; poke address of forthexec 
a237			;	inc hl 
a237			;	ld (hl), b      
a237			 
a237				; hl is now where we need to copy the word byte data to save this 
a237			 
a237 23				inc hl 
a238 22 bf e2			ld (os_new_exec), hl 
a23b				 
a23b				; copy definition 
a23b			 
a23b eb				ex de, hl 
a23c			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a23c			;	inc de    ; skip the PC for this parse 
a23c 3a c7 e2			ld a, (os_new_parse_len) 
a23f 4f				ld c, a 
a240 06 00			ld b, 0 
a242 ed b0			ldir		 ; copy defintion 
a244			 
a244			 
a244				; poke the address of where the new word bytes live for forthexec 
a244			 
a244 2a bd e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a247			 
a247 ed 5b bf e2		ld de, (os_new_exec)      
a24b				 
a24b 73				ld (hl), e 
a24c 23				inc hl 
a24d 72				ld (hl), d 
a24e			 
a24e					; TODO copy last user dict word next link to this word 
a24e					; TODO update last user dict word to point to this word 
a24e			; 
a24e			; hl f923 de 812a ; bc 811a 
a24e			 
a24e			if DEBUG_FORTH_UWORD 
a24e c5				push bc 
a24f ed 4b c9 e2		ld bc, (os_new_malloc) 
a253						DMARK ":0A" 
a253 f5				push af  
a254 3a 68 a2			ld a, (.dmark)  
a257 32 71 ee			ld (debug_mark),a  
a25a 3a 69 a2			ld a, (.dmark+1)  
a25d 32 72 ee			ld (debug_mark+1),a  
a260 3a 6a a2			ld a, (.dmark+2)  
a263 32 73 ee			ld (debug_mark+2),a  
a266 18 03			jr .pastdmark  
a268 ..			.dmark: db ":0A"  
a26b f1			.pastdmark: pop af  
a26c			endm  
# End of macro DMARK
a26c				CALLMONITOR 
a26c cd a3 94			call break_point_state  
a26f				endm  
# End of macro CALLMONITOR
a26f c1				pop bc 
a270			endif 
a270			if DEBUG_FORTH_UWORD 
a270 c5				push bc 
a271 ed 4b c9 e2		ld bc, (os_new_malloc) 
a275 03				inc bc 
a276 03				inc bc 
a277 03				inc bc 
a278 03				inc bc 
a279 03				inc bc 
a27a 03				inc bc 
a27b 03				inc bc 
a27c 03				inc bc 
a27d			 
a27d						DMARK ":0B" 
a27d f5				push af  
a27e 3a 92 a2			ld a, (.dmark)  
a281 32 71 ee			ld (debug_mark),a  
a284 3a 93 a2			ld a, (.dmark+1)  
a287 32 72 ee			ld (debug_mark+1),a  
a28a 3a 94 a2			ld a, (.dmark+2)  
a28d 32 73 ee			ld (debug_mark+2),a  
a290 18 03			jr .pastdmark  
a292 ..			.dmark: db ":0B"  
a295 f1			.pastdmark: pop af  
a296			endm  
# End of macro DMARK
a296				CALLMONITOR 
a296 cd a3 94			call break_point_state  
a299				endm  
# End of macro CALLMONITOR
a299 c1				pop bc 
a29a			endif 
a29a			 
a29a			; update word dict linked list for new word 
a29a			 
a29a			 
a29a 2a c8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a29d 23			inc hl     ; move to next work linked list ptr 
a29e			 
a29e ed 5b c9 e2	ld de, (os_new_malloc)		 ; new next word 
a2a2 73			ld (hl), e 
a2a3 23			inc hl 
a2a4 72			ld (hl), d 
a2a5			 
a2a5			if DEBUG_FORTH_UWORD 
a2a5 ed 4b c8 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2a9			endif 
a2a9			 
a2a9 ed 53 c8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2ad			 
a2ad			 
a2ad			if DEBUG_FORTH_UWORD 
a2ad						DMARK ":0+" 
a2ad f5				push af  
a2ae 3a c2 a2			ld a, (.dmark)  
a2b1 32 71 ee			ld (debug_mark),a  
a2b4 3a c3 a2			ld a, (.dmark+1)  
a2b7 32 72 ee			ld (debug_mark+1),a  
a2ba 3a c4 a2			ld a, (.dmark+2)  
a2bd 32 73 ee			ld (debug_mark+2),a  
a2c0 18 03			jr .pastdmark  
a2c2 ..			.dmark: db ":0+"  
a2c5 f1			.pastdmark: pop af  
a2c6			endm  
# End of macro DMARK
a2c6				CALLMONITOR 
a2c6 cd a3 94			call break_point_state  
a2c9				endm  
# End of macro CALLMONITOR
a2c9			endif 
a2c9			 
a2c9				STACKFRAMECHK OFF $8efe $989f 
a2c9				if DEBUG_STACK_IMB 
a2c9					if OFF 
a2c9						exx 
a2c9						ld hl, $989f 
a2c9						pop de   ; $989f 
a2c9						call cmp16 
a2c9						jr nz, .spnosame 
a2c9						ld hl, $8efe 
a2c9						pop de   ; $8efe 
a2c9						call cmp16 
a2c9						jr z, .spfrsame 
a2c9						.spnosame: call showsperror 
a2c9						.spfrsame: nop 
a2c9						exx 
a2c9					endif 
a2c9				endif 
a2c9			endm 
# End of macro STACKFRAMECHK
a2c9			 
a2c9 c9			ret    ; dont process any remaining parser tokens as they form new word 
a2ca			 
a2ca			 
a2ca			 
a2ca			 
a2ca			;		NEXT 
a2ca			.SCOLN: 
a2ca			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a2ca 06				db OPCODE_SCOLN 
a2cb 16 a3			dw .DROP 
a2cd 02				db 2 
a2ce .. 00			db ";",0           
a2d0			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a2d0					if DEBUG_FORTH_WORDS_KEY 
a2d0						DMARK "SCN" 
a2d0 f5				push af  
a2d1 3a e5 a2			ld a, (.dmark)  
a2d4 32 71 ee			ld (debug_mark),a  
a2d7 3a e6 a2			ld a, (.dmark+1)  
a2da 32 72 ee			ld (debug_mark+1),a  
a2dd 3a e7 a2			ld a, (.dmark+2)  
a2e0 32 73 ee			ld (debug_mark+2),a  
a2e3 18 03			jr .pastdmark  
a2e5 ..			.dmark: db "SCN"  
a2e8 f1			.pastdmark: pop af  
a2e9			endm  
# End of macro DMARK
a2e9						CALLMONITOR 
a2e9 cd a3 94			call break_point_state  
a2ec				endm  
# End of macro CALLMONITOR
a2ec					endif 
a2ec					FORTH_RSP_TOS 
a2ec cd d2 9a			call macro_forth_rsp_tos 
a2ef				endm 
# End of macro FORTH_RSP_TOS
a2ef e5					push hl 
a2f0					FORTH_RSP_POP 
a2f0 cd dc 9a			call macro_forth_rsp_pop 
a2f3				endm 
# End of macro FORTH_RSP_POP
a2f3 e1					pop hl 
a2f4			;		ex de,hl 
a2f4 22 cc e5				ld (os_tok_ptr),hl 
a2f7			 
a2f7			if DEBUG_FORTH_UWORD 
a2f7						DMARK "SCL" 
a2f7 f5				push af  
a2f8 3a 0c a3			ld a, (.dmark)  
a2fb 32 71 ee			ld (debug_mark),a  
a2fe 3a 0d a3			ld a, (.dmark+1)  
a301 32 72 ee			ld (debug_mark+1),a  
a304 3a 0e a3			ld a, (.dmark+2)  
a307 32 73 ee			ld (debug_mark+2),a  
a30a 18 03			jr .pastdmark  
a30c ..			.dmark: db "SCL"  
a30f f1			.pastdmark: pop af  
a310			endm  
# End of macro DMARK
a310				CALLMONITOR 
a310 cd a3 94			call break_point_state  
a313				endm  
# End of macro CALLMONITOR
a313			endif 
a313					NEXTW 
a313 c3 ba 9e			jp macro_next 
a316				endm 
# End of macro NEXTW
a316			 
a316			.DROP: 
a316				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a316 1b				db WORD_SYS_CORE+OPCODE_DROP             
a317 41 a3			dw .DUP2            
a319 05				db 4 + 1 
a31a .. 00			db "DROP",0              
a31f				endm 
# End of macro CWHEAD
a31f			; | DROP ( w -- )   drop the TOS item   | DONE 
a31f					if DEBUG_FORTH_WORDS_KEY 
a31f						DMARK "DRP" 
a31f f5				push af  
a320 3a 34 a3			ld a, (.dmark)  
a323 32 71 ee			ld (debug_mark),a  
a326 3a 35 a3			ld a, (.dmark+1)  
a329 32 72 ee			ld (debug_mark+1),a  
a32c 3a 36 a3			ld a, (.dmark+2)  
a32f 32 73 ee			ld (debug_mark+2),a  
a332 18 03			jr .pastdmark  
a334 ..			.dmark: db "DRP"  
a337 f1			.pastdmark: pop af  
a338			endm  
# End of macro DMARK
a338						CALLMONITOR 
a338 cd a3 94			call break_point_state  
a33b				endm  
# End of macro CALLMONITOR
a33b					endif 
a33b					FORTH_DSP_POP 
a33b cd c3 9d			call macro_forth_dsp_pop 
a33e				endm 
# End of macro FORTH_DSP_POP
a33e					NEXTW 
a33e c3 ba 9e			jp macro_next 
a341				endm 
# End of macro NEXTW
a341			.DUP2: 
a341				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a341 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a342 86 a3			dw .DROP2            
a344 05				db 4 + 1 
a345 .. 00			db "2DUP",0              
a34a				endm 
# End of macro CWHEAD
a34a			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a34a					if DEBUG_FORTH_WORDS_KEY 
a34a						DMARK "2DU" 
a34a f5				push af  
a34b 3a 5f a3			ld a, (.dmark)  
a34e 32 71 ee			ld (debug_mark),a  
a351 3a 60 a3			ld a, (.dmark+1)  
a354 32 72 ee			ld (debug_mark+1),a  
a357 3a 61 a3			ld a, (.dmark+2)  
a35a 32 73 ee			ld (debug_mark+2),a  
a35d 18 03			jr .pastdmark  
a35f ..			.dmark: db "2DU"  
a362 f1			.pastdmark: pop af  
a363			endm  
# End of macro DMARK
a363						CALLMONITOR 
a363 cd a3 94			call break_point_state  
a366				endm  
# End of macro CALLMONITOR
a366					endif 
a366					FORTH_DSP_VALUEHL 
a366 cd 0b 9d			call macro_dsp_valuehl 
a369				endm 
# End of macro FORTH_DSP_VALUEHL
a369 e5					push hl      ; 2 
a36a			 
a36a					FORTH_DSP_POP 
a36a cd c3 9d			call macro_forth_dsp_pop 
a36d				endm 
# End of macro FORTH_DSP_POP
a36d					 
a36d					FORTH_DSP_VALUEHL 
a36d cd 0b 9d			call macro_dsp_valuehl 
a370				endm 
# End of macro FORTH_DSP_VALUEHL
a370			;		push hl      ; 1 
a370			 
a370					FORTH_DSP_POP 
a370 cd c3 9d			call macro_forth_dsp_pop 
a373				endm 
# End of macro FORTH_DSP_POP
a373			 
a373			;		pop hl       ; 1 
a373 d1					pop de       ; 2 
a374			 
a374 cd 14 9b				call forth_push_numhl 
a377 eb					ex de, hl 
a378 cd 14 9b				call forth_push_numhl 
a37b			 
a37b					 
a37b eb					ex de, hl 
a37c			 
a37c cd 14 9b				call forth_push_numhl 
a37f eb					ex de, hl 
a380 cd 14 9b				call forth_push_numhl 
a383			 
a383			 
a383					NEXTW 
a383 c3 ba 9e			jp macro_next 
a386				endm 
# End of macro NEXTW
a386			.DROP2: 
a386				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a386 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a387 b5 a3			dw .SWAP2            
a389 06				db 5 + 1 
a38a .. 00			db "2DROP",0              
a390				endm 
# End of macro CWHEAD
a390			; | 2DROP ( w w -- )    Double drop | DONE 
a390					if DEBUG_FORTH_WORDS_KEY 
a390						DMARK "2DR" 
a390 f5				push af  
a391 3a a5 a3			ld a, (.dmark)  
a394 32 71 ee			ld (debug_mark),a  
a397 3a a6 a3			ld a, (.dmark+1)  
a39a 32 72 ee			ld (debug_mark+1),a  
a39d 3a a7 a3			ld a, (.dmark+2)  
a3a0 32 73 ee			ld (debug_mark+2),a  
a3a3 18 03			jr .pastdmark  
a3a5 ..			.dmark: db "2DR"  
a3a8 f1			.pastdmark: pop af  
a3a9			endm  
# End of macro DMARK
a3a9						CALLMONITOR 
a3a9 cd a3 94			call break_point_state  
a3ac				endm  
# End of macro CALLMONITOR
a3ac					endif 
a3ac					FORTH_DSP_POP 
a3ac cd c3 9d			call macro_forth_dsp_pop 
a3af				endm 
# End of macro FORTH_DSP_POP
a3af					FORTH_DSP_POP 
a3af cd c3 9d			call macro_forth_dsp_pop 
a3b2				endm 
# End of macro FORTH_DSP_POP
a3b2					NEXTW 
a3b2 c3 ba 9e			jp macro_next 
a3b5				endm 
# End of macro NEXTW
a3b5			.SWAP2: 
a3b5				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3b5 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3b6 de a3			dw .AT            
a3b8 06				db 5 + 1 
a3b9 .. 00			db "2SWAP",0              
a3bf				endm 
# End of macro CWHEAD
a3bf			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3bf					if DEBUG_FORTH_WORDS_KEY 
a3bf						DMARK "2SW" 
a3bf f5				push af  
a3c0 3a d4 a3			ld a, (.dmark)  
a3c3 32 71 ee			ld (debug_mark),a  
a3c6 3a d5 a3			ld a, (.dmark+1)  
a3c9 32 72 ee			ld (debug_mark+1),a  
a3cc 3a d6 a3			ld a, (.dmark+2)  
a3cf 32 73 ee			ld (debug_mark+2),a  
a3d2 18 03			jr .pastdmark  
a3d4 ..			.dmark: db "2SW"  
a3d7 f1			.pastdmark: pop af  
a3d8			endm  
# End of macro DMARK
a3d8						CALLMONITOR 
a3d8 cd a3 94			call break_point_state  
a3db				endm  
# End of macro CALLMONITOR
a3db					endif 
a3db					NEXTW 
a3db c3 ba 9e			jp macro_next 
a3de				endm 
# End of macro NEXTW
a3de			.AT: 
a3de				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a3de 1f				db WORD_SYS_CORE+OPCODE_AT             
a3df 10 a4			dw .CAT            
a3e1 02				db 1 + 1 
a3e2 .. 00			db "@",0              
a3e4				endm 
# End of macro CWHEAD
a3e4			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a3e4			 
a3e4					if DEBUG_FORTH_WORDS_KEY 
a3e4						DMARK "AT." 
a3e4 f5				push af  
a3e5 3a f9 a3			ld a, (.dmark)  
a3e8 32 71 ee			ld (debug_mark),a  
a3eb 3a fa a3			ld a, (.dmark+1)  
a3ee 32 72 ee			ld (debug_mark+1),a  
a3f1 3a fb a3			ld a, (.dmark+2)  
a3f4 32 73 ee			ld (debug_mark+2),a  
a3f7 18 03			jr .pastdmark  
a3f9 ..			.dmark: db "AT."  
a3fc f1			.pastdmark: pop af  
a3fd			endm  
# End of macro DMARK
a3fd						CALLMONITOR 
a3fd cd a3 94			call break_point_state  
a400				endm  
# End of macro CALLMONITOR
a400					endif 
a400			.getbyteat:	 
a400					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a400 cd 0b 9d			call macro_dsp_valuehl 
a403				endm 
# End of macro FORTH_DSP_VALUEHL
a403					 
a403			;		push hl 
a403				 
a403					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a403 cd c3 9d			call macro_forth_dsp_pop 
a406				endm 
# End of macro FORTH_DSP_POP
a406			 
a406			;		pop hl 
a406			 
a406 7e					ld a, (hl) 
a407			 
a407 6f					ld l, a 
a408 26 00				ld h, 0 
a40a cd 14 9b				call forth_push_numhl 
a40d			 
a40d					NEXTW 
a40d c3 ba 9e			jp macro_next 
a410				endm 
# End of macro NEXTW
a410			.CAT: 
a410				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a410 20				db WORD_SYS_CORE+OPCODE_CAT             
a411 39 a4			dw .BANG            
a413 03				db 2 + 1 
a414 .. 00			db "C@",0              
a417				endm 
# End of macro CWHEAD
a417			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a417					if DEBUG_FORTH_WORDS_KEY 
a417						DMARK "CAA" 
a417 f5				push af  
a418 3a 2c a4			ld a, (.dmark)  
a41b 32 71 ee			ld (debug_mark),a  
a41e 3a 2d a4			ld a, (.dmark+1)  
a421 32 72 ee			ld (debug_mark+1),a  
a424 3a 2e a4			ld a, (.dmark+2)  
a427 32 73 ee			ld (debug_mark+2),a  
a42a 18 03			jr .pastdmark  
a42c ..			.dmark: db "CAA"  
a42f f1			.pastdmark: pop af  
a430			endm  
# End of macro DMARK
a430						CALLMONITOR 
a430 cd a3 94			call break_point_state  
a433				endm  
# End of macro CALLMONITOR
a433					endif 
a433 c3 00 a4				jp .getbyteat 
a436					NEXTW 
a436 c3 ba 9e			jp macro_next 
a439				endm 
# End of macro NEXTW
a439			.BANG: 
a439				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a439 21				db WORD_SYS_CORE+OPCODE_BANG             
a43a 6f a4			dw .CBANG            
a43c 02				db 1 + 1 
a43d .. 00			db "!",0              
a43f				endm 
# End of macro CWHEAD
a43f			; | ! ( x w -- ) Store x at address w      | DONE 
a43f					if DEBUG_FORTH_WORDS_KEY 
a43f						DMARK "BNG" 
a43f f5				push af  
a440 3a 54 a4			ld a, (.dmark)  
a443 32 71 ee			ld (debug_mark),a  
a446 3a 55 a4			ld a, (.dmark+1)  
a449 32 72 ee			ld (debug_mark+1),a  
a44c 3a 56 a4			ld a, (.dmark+2)  
a44f 32 73 ee			ld (debug_mark+2),a  
a452 18 03			jr .pastdmark  
a454 ..			.dmark: db "BNG"  
a457 f1			.pastdmark: pop af  
a458			endm  
# End of macro DMARK
a458						CALLMONITOR 
a458 cd a3 94			call break_point_state  
a45b				endm  
# End of macro CALLMONITOR
a45b					endif 
a45b			 
a45b			.storebyteat:		 
a45b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a45b cd 0b 9d			call macro_dsp_valuehl 
a45e				endm 
# End of macro FORTH_DSP_VALUEHL
a45e					 
a45e e5					push hl 
a45f				 
a45f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a45f cd c3 9d			call macro_forth_dsp_pop 
a462				endm 
# End of macro FORTH_DSP_POP
a462			 
a462					; get byte to poke 
a462			 
a462					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a462 cd 0b 9d			call macro_dsp_valuehl 
a465				endm 
# End of macro FORTH_DSP_VALUEHL
a465 e5					push hl 
a466			 
a466			 
a466					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a466 cd c3 9d			call macro_forth_dsp_pop 
a469				endm 
# End of macro FORTH_DSP_POP
a469			 
a469			 
a469 d1					pop de 
a46a e1					pop hl 
a46b			 
a46b 73					ld (hl),e 
a46c			 
a46c			 
a46c					NEXTW 
a46c c3 ba 9e			jp macro_next 
a46f				endm 
# End of macro NEXTW
a46f			.CBANG: 
a46f				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a46f 22				db WORD_SYS_CORE+OPCODE_CBANG             
a470 98 a4			dw .SCALL            
a472 03				db 2 + 1 
a473 .. 00			db "C!",0              
a476				endm 
# End of macro CWHEAD
a476			; | C!  ( x w -- ) Store x at address w  | DONE 
a476					if DEBUG_FORTH_WORDS_KEY 
a476						DMARK "CBA" 
a476 f5				push af  
a477 3a 8b a4			ld a, (.dmark)  
a47a 32 71 ee			ld (debug_mark),a  
a47d 3a 8c a4			ld a, (.dmark+1)  
a480 32 72 ee			ld (debug_mark+1),a  
a483 3a 8d a4			ld a, (.dmark+2)  
a486 32 73 ee			ld (debug_mark+2),a  
a489 18 03			jr .pastdmark  
a48b ..			.dmark: db "CBA"  
a48e f1			.pastdmark: pop af  
a48f			endm  
# End of macro DMARK
a48f						CALLMONITOR 
a48f cd a3 94			call break_point_state  
a492				endm  
# End of macro CALLMONITOR
a492					endif 
a492 c3 5b a4				jp .storebyteat 
a495					NEXTW 
a495 c3 ba 9e			jp macro_next 
a498				endm 
# End of macro NEXTW
a498			.SCALL: 
a498				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a498 23				db WORD_SYS_CORE+OPCODE_SCALL             
a499 cc a4			dw .DEPTH            
a49b 05				db 4 + 1 
a49c .. 00			db "CALL",0              
a4a1				endm 
# End of macro CWHEAD
a4a1			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4a1					if DEBUG_FORTH_WORDS_KEY 
a4a1						DMARK "CLL" 
a4a1 f5				push af  
a4a2 3a b6 a4			ld a, (.dmark)  
a4a5 32 71 ee			ld (debug_mark),a  
a4a8 3a b7 a4			ld a, (.dmark+1)  
a4ab 32 72 ee			ld (debug_mark+1),a  
a4ae 3a b8 a4			ld a, (.dmark+2)  
a4b1 32 73 ee			ld (debug_mark+2),a  
a4b4 18 03			jr .pastdmark  
a4b6 ..			.dmark: db "CLL"  
a4b9 f1			.pastdmark: pop af  
a4ba			endm  
# End of macro DMARK
a4ba						CALLMONITOR 
a4ba cd a3 94			call break_point_state  
a4bd				endm  
# End of macro CALLMONITOR
a4bd					endif 
a4bd			 
a4bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4bd cd 0b 9d			call macro_dsp_valuehl 
a4c0				endm 
# End of macro FORTH_DSP_VALUEHL
a4c0			 
a4c0			;		push hl 
a4c0			 
a4c0					; destroy value TOS 
a4c0			 
a4c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4c0 cd c3 9d			call macro_forth_dsp_pop 
a4c3				endm 
# End of macro FORTH_DSP_POP
a4c3			 
a4c3						 
a4c3			;		pop hl 
a4c3			 
a4c3					; how to do a call with hl???? save SP? 
a4c3 cd 5e 9e				call forth_call_hl 
a4c6			 
a4c6			 
a4c6					; TODO push value back onto stack for another op etc 
a4c6			 
a4c6 cd 14 9b				call forth_push_numhl 
a4c9					NEXTW 
a4c9 c3 ba 9e			jp macro_next 
a4cc				endm 
# End of macro NEXTW
a4cc			.DEPTH: 
a4cc				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a4cc 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a4cd 09 a5			dw .OVER            
a4cf 06				db 5 + 1 
a4d0 .. 00			db "DEPTH",0              
a4d6				endm 
# End of macro CWHEAD
a4d6			; | DEPTH ( -- u ) Push count of stack | DONE 
a4d6					; take current TOS and remove from base value div by two to get count 
a4d6					if DEBUG_FORTH_WORDS_KEY 
a4d6						DMARK "DEP" 
a4d6 f5				push af  
a4d7 3a eb a4			ld a, (.dmark)  
a4da 32 71 ee			ld (debug_mark),a  
a4dd 3a ec a4			ld a, (.dmark+1)  
a4e0 32 72 ee			ld (debug_mark+1),a  
a4e3 3a ed a4			ld a, (.dmark+2)  
a4e6 32 73 ee			ld (debug_mark+2),a  
a4e9 18 03			jr .pastdmark  
a4eb ..			.dmark: db "DEP"  
a4ee f1			.pastdmark: pop af  
a4ef			endm  
# End of macro DMARK
a4ef						CALLMONITOR 
a4ef cd a3 94			call break_point_state  
a4f2				endm  
# End of macro CALLMONITOR
a4f2					endif 
a4f2			 
a4f2			 
a4f2 2a f8 e9			ld hl, (cli_data_sp) 
a4f5 11 32 e8			ld de, cli_data_stack 
a4f8 ed 52			sbc hl,de 
a4fa				 
a4fa				; div by size of stack item 
a4fa			 
a4fa 5d				ld e,l 
a4fb 0e 03			ld c, 3 
a4fd cd 32 8c			call Div8 
a500			 
a500 6f				ld l,a 
a501 26 00			ld h,0 
a503			 
a503				;srl h 
a503				;rr l 
a503			 
a503 cd 14 9b				call forth_push_numhl 
a506					NEXTW 
a506 c3 ba 9e			jp macro_next 
a509				endm 
# End of macro NEXTW
a509			.OVER: 
a509				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a509 42				db WORD_SYS_CORE+46             
a50a 50 a5			dw .PAUSE            
a50c 05				db 4 + 1 
a50d .. 00			db "OVER",0              
a512				endm 
# End of macro CWHEAD
a512			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a512					if DEBUG_FORTH_WORDS_KEY 
a512						DMARK "OVR" 
a512 f5				push af  
a513 3a 27 a5			ld a, (.dmark)  
a516 32 71 ee			ld (debug_mark),a  
a519 3a 28 a5			ld a, (.dmark+1)  
a51c 32 72 ee			ld (debug_mark+1),a  
a51f 3a 29 a5			ld a, (.dmark+2)  
a522 32 73 ee			ld (debug_mark+2),a  
a525 18 03			jr .pastdmark  
a527 ..			.dmark: db "OVR"  
a52a f1			.pastdmark: pop af  
a52b			endm  
# End of macro DMARK
a52b						CALLMONITOR 
a52b cd a3 94			call break_point_state  
a52e				endm  
# End of macro CALLMONITOR
a52e					endif 
a52e			 
a52e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a52e cd 0b 9d			call macro_dsp_valuehl 
a531				endm 
# End of macro FORTH_DSP_VALUEHL
a531 e5					push hl    ; n2 
a532					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a532 cd c3 9d			call macro_forth_dsp_pop 
a535				endm 
# End of macro FORTH_DSP_POP
a535			 
a535					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a535 cd 0b 9d			call macro_dsp_valuehl 
a538				endm 
# End of macro FORTH_DSP_VALUEHL
a538 e5					push hl    ; n1 
a539					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a539 cd c3 9d			call macro_forth_dsp_pop 
a53c				endm 
# End of macro FORTH_DSP_POP
a53c			 
a53c d1					pop de     ; n1 
a53d e1					pop hl     ; n2 
a53e			 
a53e d5					push de 
a53f e5					push hl 
a540 d5					push de 
a541			 
a541					; push back  
a541			 
a541 e1					pop hl 
a542 cd 14 9b				call forth_push_numhl 
a545 e1					pop hl 
a546 cd 14 9b				call forth_push_numhl 
a549 e1					pop hl 
a54a cd 14 9b				call forth_push_numhl 
a54d					NEXTW 
a54d c3 ba 9e			jp macro_next 
a550				endm 
# End of macro NEXTW
a550			 
a550			.PAUSE: 
a550				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a550 43				db WORD_SYS_CORE+47             
a551 85 a5			dw .PAUSES            
a553 08				db 7 + 1 
a554 .. 00			db "PAUSEMS",0              
a55c				endm 
# End of macro CWHEAD
a55c			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a55c					if DEBUG_FORTH_WORDS_KEY 
a55c						DMARK "PMS" 
a55c f5				push af  
a55d 3a 71 a5			ld a, (.dmark)  
a560 32 71 ee			ld (debug_mark),a  
a563 3a 72 a5			ld a, (.dmark+1)  
a566 32 72 ee			ld (debug_mark+1),a  
a569 3a 73 a5			ld a, (.dmark+2)  
a56c 32 73 ee			ld (debug_mark+2),a  
a56f 18 03			jr .pastdmark  
a571 ..			.dmark: db "PMS"  
a574 f1			.pastdmark: pop af  
a575			endm  
# End of macro DMARK
a575						CALLMONITOR 
a575 cd a3 94			call break_point_state  
a578				endm  
# End of macro CALLMONITOR
a578					endif 
a578					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a578 cd 0b 9d			call macro_dsp_valuehl 
a57b				endm 
# End of macro FORTH_DSP_VALUEHL
a57b			;		push hl    ; n2 
a57b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a57b cd c3 9d			call macro_forth_dsp_pop 
a57e				endm 
# End of macro FORTH_DSP_POP
a57e			;		pop hl 
a57e			 
a57e 7d					ld a, l 
a57f cd d7 89				call aDelayInMS 
a582				       NEXTW 
a582 c3 ba 9e			jp macro_next 
a585				endm 
# End of macro NEXTW
a585			.PAUSES:  
a585				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a585 44				db WORD_SYS_CORE+48             
a586 f4 a5			dw .ROT            
a588 06				db 5 + 1 
a589 .. 00			db "PAUSE",0              
a58f				endm 
# End of macro CWHEAD
a58f			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a58f					if DEBUG_FORTH_WORDS_KEY 
a58f						DMARK "PAU" 
a58f f5				push af  
a590 3a a4 a5			ld a, (.dmark)  
a593 32 71 ee			ld (debug_mark),a  
a596 3a a5 a5			ld a, (.dmark+1)  
a599 32 72 ee			ld (debug_mark+1),a  
a59c 3a a6 a5			ld a, (.dmark+2)  
a59f 32 73 ee			ld (debug_mark+2),a  
a5a2 18 03			jr .pastdmark  
a5a4 ..			.dmark: db "PAU"  
a5a7 f1			.pastdmark: pop af  
a5a8			endm  
# End of macro DMARK
a5a8						CALLMONITOR 
a5a8 cd a3 94			call break_point_state  
a5ab				endm  
# End of macro CALLMONITOR
a5ab					endif 
a5ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5ab cd 0b 9d			call macro_dsp_valuehl 
a5ae				endm 
# End of macro FORTH_DSP_VALUEHL
a5ae			;		push hl    ; n2 
a5ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5ae cd c3 9d			call macro_forth_dsp_pop 
a5b1				endm 
# End of macro FORTH_DSP_POP
a5b1			;		pop hl 
a5b1 45					ld b, l 
a5b2					if DEBUG_FORTH_WORDS 
a5b2						DMARK "PAU" 
a5b2 f5				push af  
a5b3 3a c7 a5			ld a, (.dmark)  
a5b6 32 71 ee			ld (debug_mark),a  
a5b9 3a c8 a5			ld a, (.dmark+1)  
a5bc 32 72 ee			ld (debug_mark+1),a  
a5bf 3a c9 a5			ld a, (.dmark+2)  
a5c2 32 73 ee			ld (debug_mark+2),a  
a5c5 18 03			jr .pastdmark  
a5c7 ..			.dmark: db "PAU"  
a5ca f1			.pastdmark: pop af  
a5cb			endm  
# End of macro DMARK
a5cb						CALLMONITOR 
a5cb cd a3 94			call break_point_state  
a5ce				endm  
# End of macro CALLMONITOR
a5ce					endif 
a5ce c5			.pauses1:	push bc 
a5cf cd f2 89				call delay1s 
a5d2 c1					pop bc 
a5d3					if DEBUG_FORTH_WORDS 
a5d3						DMARK "PA1" 
a5d3 f5				push af  
a5d4 3a e8 a5			ld a, (.dmark)  
a5d7 32 71 ee			ld (debug_mark),a  
a5da 3a e9 a5			ld a, (.dmark+1)  
a5dd 32 72 ee			ld (debug_mark+1),a  
a5e0 3a ea a5			ld a, (.dmark+2)  
a5e3 32 73 ee			ld (debug_mark+2),a  
a5e6 18 03			jr .pastdmark  
a5e8 ..			.dmark: db "PA1"  
a5eb f1			.pastdmark: pop af  
a5ec			endm  
# End of macro DMARK
a5ec						CALLMONITOR 
a5ec cd a3 94			call break_point_state  
a5ef				endm  
# End of macro CALLMONITOR
a5ef					endif 
a5ef 10 dd				djnz .pauses1 
a5f1			 
a5f1				       NEXTW 
a5f1 c3 ba 9e			jp macro_next 
a5f4				endm 
# End of macro NEXTW
a5f4			.ROT: 
a5f4				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a5f4 45				db WORD_SYS_CORE+49             
a5f5 42 a6			dw .UWORDS            
a5f7 04				db 3 + 1 
a5f8 .. 00			db "ROT",0              
a5fc				endm 
# End of macro CWHEAD
a5fc			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a5fc					if DEBUG_FORTH_WORDS_KEY 
a5fc						DMARK "ROT" 
a5fc f5				push af  
a5fd 3a 11 a6			ld a, (.dmark)  
a600 32 71 ee			ld (debug_mark),a  
a603 3a 12 a6			ld a, (.dmark+1)  
a606 32 72 ee			ld (debug_mark+1),a  
a609 3a 13 a6			ld a, (.dmark+2)  
a60c 32 73 ee			ld (debug_mark+2),a  
a60f 18 03			jr .pastdmark  
a611 ..			.dmark: db "ROT"  
a614 f1			.pastdmark: pop af  
a615			endm  
# End of macro DMARK
a615						CALLMONITOR 
a615 cd a3 94			call break_point_state  
a618				endm  
# End of macro CALLMONITOR
a618					endif 
a618			 
a618					FORTH_DSP_VALUEHL 
a618 cd 0b 9d			call macro_dsp_valuehl 
a61b				endm 
# End of macro FORTH_DSP_VALUEHL
a61b e5					push hl    ; u3  
a61c			 
a61c					FORTH_DSP_POP 
a61c cd c3 9d			call macro_forth_dsp_pop 
a61f				endm 
# End of macro FORTH_DSP_POP
a61f			   
a61f					FORTH_DSP_VALUEHL 
a61f cd 0b 9d			call macro_dsp_valuehl 
a622				endm 
# End of macro FORTH_DSP_VALUEHL
a622 e5					push hl     ; u2 
a623			 
a623					FORTH_DSP_POP 
a623 cd c3 9d			call macro_forth_dsp_pop 
a626				endm 
# End of macro FORTH_DSP_POP
a626			 
a626					FORTH_DSP_VALUEHL 
a626 cd 0b 9d			call macro_dsp_valuehl 
a629				endm 
# End of macro FORTH_DSP_VALUEHL
a629 e5					push hl     ; u1 
a62a			 
a62a					FORTH_DSP_POP 
a62a cd c3 9d			call macro_forth_dsp_pop 
a62d				endm 
# End of macro FORTH_DSP_POP
a62d			 
a62d c1					pop bc      ; u1 
a62e e1					pop hl      ; u2 
a62f d1					pop de      ; u3 
a630			 
a630			 
a630 c5					push bc 
a631 d5					push de 
a632 e5					push hl 
a633			 
a633			 
a633 e1					pop hl 
a634 cd 14 9b				call forth_push_numhl 
a637			 
a637 e1					pop hl 
a638 cd 14 9b				call forth_push_numhl 
a63b			 
a63b e1					pop hl 
a63c cd 14 9b				call forth_push_numhl 
a63f					 
a63f			 
a63f			 
a63f			 
a63f			 
a63f			 
a63f				       NEXTW 
a63f c3 ba 9e			jp macro_next 
a642				endm 
# End of macro NEXTW
a642			 
a642			.UWORDS: 
a642				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a642 50				db WORD_SYS_CORE+60             
a643 04 a7			dw .BP            
a645 07				db 6 + 1 
a646 .. 00			db "UWORDS",0              
a64d				endm 
# End of macro CWHEAD
a64d			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a64d			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a64d			; | | Following the count are the individual words. 
a64d			; | | 
a64d			; | | e.g. UWORDS 
a64d			; | | BOX DIRLIST 2 
a64d			; | |  
a64d			; | | Can be used to save the words to storage via: 
a64d			; | | UWORDS $01 DO $01 APPEND LOOP 
a64d				if DEBUG_FORTH_WORDS_KEY 
a64d					DMARK "UWR" 
a64d f5				push af  
a64e 3a 62 a6			ld a, (.dmark)  
a651 32 71 ee			ld (debug_mark),a  
a654 3a 63 a6			ld a, (.dmark+1)  
a657 32 72 ee			ld (debug_mark+1),a  
a65a 3a 64 a6			ld a, (.dmark+2)  
a65d 32 73 ee			ld (debug_mark+2),a  
a660 18 03			jr .pastdmark  
a662 ..			.dmark: db "UWR"  
a665 f1			.pastdmark: pop af  
a666			endm  
# End of macro DMARK
a666					CALLMONITOR 
a666 cd a3 94			call break_point_state  
a669				endm  
# End of macro CALLMONITOR
a669				endif 
a669 21 5b e0				ld hl, baseram 
a66c					;ld hl, baseusermem 
a66c 01 00 00				ld bc, 0    ; start a counter 
a66f			 
a66f				; skip dict stub 
a66f			 
a66f cd 0b a0				call forth_tok_next 
a672			 
a672			 
a672			; while we have words to look for 
a672			 
a672 7e			.douscan:	ld a, (hl)      
a673				if DEBUG_FORTH_WORDS 
a673					DMARK "UWs" 
a673 f5				push af  
a674 3a 88 a6			ld a, (.dmark)  
a677 32 71 ee			ld (debug_mark),a  
a67a 3a 89 a6			ld a, (.dmark+1)  
a67d 32 72 ee			ld (debug_mark+1),a  
a680 3a 8a a6			ld a, (.dmark+2)  
a683 32 73 ee			ld (debug_mark+2),a  
a686 18 03			jr .pastdmark  
a688 ..			.dmark: db "UWs"  
a68b f1			.pastdmark: pop af  
a68c			endm  
# End of macro DMARK
a68c					CALLMONITOR 
a68c cd a3 94			call break_point_state  
a68f				endm  
# End of macro CALLMONITOR
a68f				endif 
a68f fe 00				cp WORD_SYS_END 
a691 28 4d				jr z, .udone 
a693 fe 01				cp WORD_SYS_UWORD 
a695 20 44				jr nz, .nuword 
a697			 
a697				if DEBUG_FORTH_WORDS 
a697					DMARK "UWu" 
a697 f5				push af  
a698 3a ac a6			ld a, (.dmark)  
a69b 32 71 ee			ld (debug_mark),a  
a69e 3a ad a6			ld a, (.dmark+1)  
a6a1 32 72 ee			ld (debug_mark+1),a  
a6a4 3a ae a6			ld a, (.dmark+2)  
a6a7 32 73 ee			ld (debug_mark+2),a  
a6aa 18 03			jr .pastdmark  
a6ac ..			.dmark: db "UWu"  
a6af f1			.pastdmark: pop af  
a6b0			endm  
# End of macro DMARK
a6b0					CALLMONITOR 
a6b0 cd a3 94			call break_point_state  
a6b3				endm  
# End of macro CALLMONITOR
a6b3				endif 
a6b3					; we have a uword so push its name to the stack 
a6b3			 
a6b3 e5				   	push hl  ; save so we can move to next dict block 
a6b4			 
a6b4					; skip opcode 
a6b4 23					inc hl  
a6b5					; skip next ptr 
a6b5 23					inc hl  
a6b6 23					inc hl 
a6b7					; skip len 
a6b7 23					inc hl 
a6b8				if DEBUG_FORTH_WORDS 
a6b8					DMARK "UWt" 
a6b8 f5				push af  
a6b9 3a cd a6			ld a, (.dmark)  
a6bc 32 71 ee			ld (debug_mark),a  
a6bf 3a ce a6			ld a, (.dmark+1)  
a6c2 32 72 ee			ld (debug_mark+1),a  
a6c5 3a cf a6			ld a, (.dmark+2)  
a6c8 32 73 ee			ld (debug_mark+2),a  
a6cb 18 03			jr .pastdmark  
a6cd ..			.dmark: db "UWt"  
a6d0 f1			.pastdmark: pop af  
a6d1			endm  
# End of macro DMARK
a6d1					CALLMONITOR 
a6d1 cd a3 94			call break_point_state  
a6d4				endm  
# End of macro CALLMONITOR
a6d4				endif 
a6d4 03					inc bc 
a6d5			 
a6d5 c5					push bc 
a6d6 cd 82 9b				call forth_push_str 
a6d9 c1					pop bc 
a6da			 
a6da e1					pop hl 	 
a6db			 
a6db cd 0b a0		.nuword:	call forth_tok_next 
a6de 18 92				jr .douscan  
a6e0			 
a6e0			.udone:		 ; push count of uwords found 
a6e0 c5					push bc 
a6e1 e1					pop hl 
a6e2			 
a6e2				if DEBUG_FORTH_WORDS 
a6e2					DMARK "UWc" 
a6e2 f5				push af  
a6e3 3a f7 a6			ld a, (.dmark)  
a6e6 32 71 ee			ld (debug_mark),a  
a6e9 3a f8 a6			ld a, (.dmark+1)  
a6ec 32 72 ee			ld (debug_mark+1),a  
a6ef 3a f9 a6			ld a, (.dmark+2)  
a6f2 32 73 ee			ld (debug_mark+2),a  
a6f5 18 03			jr .pastdmark  
a6f7 ..			.dmark: db "UWc"  
a6fa f1			.pastdmark: pop af  
a6fb			endm  
# End of macro DMARK
a6fb					CALLMONITOR 
a6fb cd a3 94			call break_point_state  
a6fe				endm  
# End of macro CALLMONITOR
a6fe				endif 
a6fe cd 14 9b				call forth_push_numhl 
a701			 
a701			 
a701				       NEXTW 
a701 c3 ba 9e			jp macro_next 
a704				endm 
# End of macro NEXTW
a704			 
a704			.BP: 
a704				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a704 54				db WORD_SYS_CORE+64             
a705 3a a7			dw .MONITOR            
a707 03				db 2 + 1 
a708 .. 00			db "BP",0              
a70b				endm 
# End of macro CWHEAD
a70b			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a70b			; | | $00 Will enable the break points within specific code paths 
a70b			; | | $01 Will disable break points 
a70b			; | |  
a70b			; | | By default break points are off. Either the above can be used to enable them 
a70b			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a70b			; | | and on release of the pressed key a message will be disaplayed to notify 
a70b			; | | that break points are enabled. Pressing any key will then continue boot process. 
a70b					; get byte count 
a70b					if DEBUG_FORTH_WORDS_KEY 
a70b						DMARK "BP." 
a70b f5				push af  
a70c 3a 20 a7			ld a, (.dmark)  
a70f 32 71 ee			ld (debug_mark),a  
a712 3a 21 a7			ld a, (.dmark+1)  
a715 32 72 ee			ld (debug_mark+1),a  
a718 3a 22 a7			ld a, (.dmark+2)  
a71b 32 73 ee			ld (debug_mark+2),a  
a71e 18 03			jr .pastdmark  
a720 ..			.dmark: db "BP."  
a723 f1			.pastdmark: pop af  
a724			endm  
# End of macro DMARK
a724						CALLMONITOR 
a724 cd a3 94			call break_point_state  
a727				endm  
# End of macro CALLMONITOR
a727					endif 
a727			 
a727					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a727 cd 0b 9d			call macro_dsp_valuehl 
a72a				endm 
# End of macro FORTH_DSP_VALUEHL
a72a			 
a72a			;		push hl 
a72a			 
a72a					; destroy value TOS 
a72a			 
a72a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a72a cd c3 9d			call macro_forth_dsp_pop 
a72d				endm 
# End of macro FORTH_DSP_POP
a72d			 
a72d			;		pop hl 
a72d			 
a72d 3e 00				ld a,0 
a72f bd					cp l 
a730 28 02				jr z, .bpset 
a732 3e 2a				ld a, '*' 
a734			 
a734 32 bc e2		.bpset:		ld (os_view_disable), a 
a737			 
a737			 
a737					NEXTW 
a737 c3 ba 9e			jp macro_next 
a73a				endm 
# End of macro NEXTW
a73a			 
a73a			 
a73a			.MONITOR: 
a73a				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a73a 55				db WORD_SYS_CORE+65             
a73b 6d a7			dw .MALLOC            
a73d 08				db 7 + 1 
a73e .. 00			db "MONITOR",0              
a746				endm 
# End of macro CWHEAD
a746			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a746			; | | At start the current various registers will be displayed with contents. 
a746			; | | Top right corner will show the most recent debug marker seen. 
a746			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a746			; | | and the return stack pointer (RSP). 
a746			; | | Pressing: 
a746			; | |    1 - Initial screen 
a746			; | |    2 - Display a data dump of HL 
a746			; | |    3 - Display a data dump of DE 
a746			; | |    4 - Display a data dump of BC 
a746			; | |    5 - Display a data dump of HL 
a746			; | |    6 - Display a data dump of DSP 
a746			; | |    7 - Display a data dump of RSP 
a746			; | |    8 - Display a data dump of what is at DSP 
a746			; | |    9 - Display a data dump of what is at RSP 
a746			; | |    0 - Exit monitor and continue running. This will also enable break points 
a746			; | |    * - Disable break points 
a746			; | |    # - Enter traditional monitor mode 
a746			; | | 
a746			; | | Monitor Mode 
a746			; | | ------------ 
a746			; | | A prompt of '>' will be shown for various commands: 
a746			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a746			; | |    C - Continue display a data dump from the last set address 
a746			; | |    M xxxx - Set start of memory edit at address xx 
a746			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a746			; | |    Q - Return to previous 
a746					if DEBUG_FORTH_WORDS_KEY 
a746						DMARK "MON" 
a746 f5				push af  
a747 3a 5b a7			ld a, (.dmark)  
a74a 32 71 ee			ld (debug_mark),a  
a74d 3a 5c a7			ld a, (.dmark+1)  
a750 32 72 ee			ld (debug_mark+1),a  
a753 3a 5d a7			ld a, (.dmark+2)  
a756 32 73 ee			ld (debug_mark+2),a  
a759 18 03			jr .pastdmark  
a75b ..			.dmark: db "MON"  
a75e f1			.pastdmark: pop af  
a75f			endm  
# End of macro DMARK
a75f						CALLMONITOR 
a75f cd a3 94			call break_point_state  
a762				endm  
# End of macro CALLMONITOR
a762					endif 
a762 3e 00				ld a, 0 
a764 32 bc e2				ld (os_view_disable), a 
a767			 
a767					CALLMONITOR 
a767 cd a3 94			call break_point_state  
a76a				endm  
# End of macro CALLMONITOR
a76a			 
a76a			;	call monitor 
a76a			 
a76a					NEXTW 
a76a c3 ba 9e			jp macro_next 
a76d				endm 
# End of macro NEXTW
a76d			 
a76d			 
a76d			.MALLOC: 
a76d				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a76d 56				db WORD_SYS_CORE+66             
a76e 96 a7			dw .MALLOC2            
a770 06				db 5 + 1 
a771 .. 00			db "ALLOT",0              
a777				endm 
# End of macro CWHEAD
a777			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a777					if DEBUG_FORTH_WORDS_KEY 
a777						DMARK "ALL" 
a777 f5				push af  
a778 3a 8c a7			ld a, (.dmark)  
a77b 32 71 ee			ld (debug_mark),a  
a77e 3a 8d a7			ld a, (.dmark+1)  
a781 32 72 ee			ld (debug_mark+1),a  
a784 3a 8e a7			ld a, (.dmark+2)  
a787 32 73 ee			ld (debug_mark+2),a  
a78a 18 03			jr .pastdmark  
a78c ..			.dmark: db "ALL"  
a78f f1			.pastdmark: pop af  
a790			endm  
# End of macro DMARK
a790						CALLMONITOR 
a790 cd a3 94			call break_point_state  
a793				endm  
# End of macro CALLMONITOR
a793					endif 
a793 c3 bd a7				jp .mallocc 
a796			.MALLOC2: 
a796				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a796 56				db WORD_SYS_CORE+66             
a797 d4 a7			dw .FREE            
a799 07				db 6 + 1 
a79a .. 00			db "MALLOC",0              
a7a1				endm 
# End of macro CWHEAD
a7a1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7a1					; get byte count 
a7a1					if DEBUG_FORTH_WORDS_KEY 
a7a1						DMARK "MAL" 
a7a1 f5				push af  
a7a2 3a b6 a7			ld a, (.dmark)  
a7a5 32 71 ee			ld (debug_mark),a  
a7a8 3a b7 a7			ld a, (.dmark+1)  
a7ab 32 72 ee			ld (debug_mark+1),a  
a7ae 3a b8 a7			ld a, (.dmark+2)  
a7b1 32 73 ee			ld (debug_mark+2),a  
a7b4 18 03			jr .pastdmark  
a7b6 ..			.dmark: db "MAL"  
a7b9 f1			.pastdmark: pop af  
a7ba			endm  
# End of macro DMARK
a7ba						CALLMONITOR 
a7ba cd a3 94			call break_point_state  
a7bd				endm  
# End of macro CALLMONITOR
a7bd					endif 
a7bd			.mallocc: 
a7bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7bd cd 0b 9d			call macro_dsp_valuehl 
a7c0				endm 
# End of macro FORTH_DSP_VALUEHL
a7c0			 
a7c0			;		push hl 
a7c0			 
a7c0					; destroy value TOS 
a7c0			 
a7c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7c0 cd c3 9d			call macro_forth_dsp_pop 
a7c3				endm 
# End of macro FORTH_DSP_POP
a7c3			 
a7c3			;		pop hl 
a7c3 cd 69 91				call malloc 
a7c6				if DEBUG_FORTH_MALLOC_GUARD 
a7c6 f5					push af 
a7c7 cd cb 8c				call ishlzero 
a7ca			;		ld a, l 
a7ca			;		add h 
a7ca			;		cp 0 
a7ca f1					pop af 
a7cb					 
a7cb cc 9e c9				call z,malloc_error 
a7ce				endif 
a7ce			 
a7ce cd 14 9b				call forth_push_numhl 
a7d1					NEXTW 
a7d1 c3 ba 9e			jp macro_next 
a7d4				endm 
# End of macro NEXTW
a7d4			 
a7d4			.FREE: 
a7d4				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a7d4 57				db WORD_SYS_CORE+67             
a7d5 05 a8			dw .LIST            
a7d7 05				db 4 + 1 
a7d8 .. 00			db "FREE",0              
a7dd				endm 
# End of macro CWHEAD
a7dd			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a7dd					if DEBUG_FORTH_WORDS_KEY 
a7dd						DMARK "FRE" 
a7dd f5				push af  
a7de 3a f2 a7			ld a, (.dmark)  
a7e1 32 71 ee			ld (debug_mark),a  
a7e4 3a f3 a7			ld a, (.dmark+1)  
a7e7 32 72 ee			ld (debug_mark+1),a  
a7ea 3a f4 a7			ld a, (.dmark+2)  
a7ed 32 73 ee			ld (debug_mark+2),a  
a7f0 18 03			jr .pastdmark  
a7f2 ..			.dmark: db "FRE"  
a7f5 f1			.pastdmark: pop af  
a7f6			endm  
# End of macro DMARK
a7f6						CALLMONITOR 
a7f6 cd a3 94			call break_point_state  
a7f9				endm  
# End of macro CALLMONITOR
a7f9					endif 
a7f9					; get address 
a7f9			 
a7f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7f9 cd 0b 9d			call macro_dsp_valuehl 
a7fc				endm 
# End of macro FORTH_DSP_VALUEHL
a7fc			 
a7fc			;		push hl 
a7fc			 
a7fc					; destroy value TOS 
a7fc			 
a7fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7fc cd c3 9d			call macro_forth_dsp_pop 
a7ff				endm 
# End of macro FORTH_DSP_POP
a7ff			 
a7ff			;		pop hl 
a7ff			if FORTH_ENABLE_MALLOCFREE 
a7ff cd 33 92				call free 
a802			endif 
a802					NEXTW 
a802 c3 ba 9e			jp macro_next 
a805				endm 
# End of macro NEXTW
a805			.LIST: 
a805				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a805 5c				db WORD_SYS_CORE+72             
a806 f3 a9			dw .FORGET            
a808 05				db 4 + 1 
a809 .. 00			db "LIST",0              
a80e				endm 
# End of macro CWHEAD
a80e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a80e			; | | The quoted word must be in upper case. 
a80e				if DEBUG_FORTH_WORDS_KEY 
a80e					DMARK "LST" 
a80e f5				push af  
a80f 3a 23 a8			ld a, (.dmark)  
a812 32 71 ee			ld (debug_mark),a  
a815 3a 24 a8			ld a, (.dmark+1)  
a818 32 72 ee			ld (debug_mark+1),a  
a81b 3a 25 a8			ld a, (.dmark+2)  
a81e 32 73 ee			ld (debug_mark+2),a  
a821 18 03			jr .pastdmark  
a823 ..			.dmark: db "LST"  
a826 f1			.pastdmark: pop af  
a827			endm  
# End of macro DMARK
a827					CALLMONITOR 
a827 cd a3 94			call break_point_state  
a82a				endm  
# End of macro CALLMONITOR
a82a				endif 
a82a			 
a82a					FORTH_DSP_VALUEHL 
a82a cd 0b 9d			call macro_dsp_valuehl 
a82d				endm 
# End of macro FORTH_DSP_VALUEHL
a82d			 
a82d e5					push hl 
a82e					FORTH_DSP_POP 
a82e cd c3 9d			call macro_forth_dsp_pop 
a831				endm 
# End of macro FORTH_DSP_POP
a831 c1					pop bc 
a832			 
a832			; Start format of scratch string 
a832			 
a832 21 cb e2				ld hl, scratch 
a835			 
a835 3e 3a				ld a, ':' 
a837 77					ld (hl),a 
a838 23					inc hl 
a839 3e 20				ld a, ' ' 
a83b 77					ld (hl), a 
a83c			 
a83c					; Get ptr to the word we need to look up 
a83c			 
a83c			;		FORTH_DSP_VALUEHL 
a83c					;v5 FORTH_DSP_VALUE 
a83c				; TODO type check 
a83c			;		inc hl    ; Skip type check  
a83c			;		push hl 
a83c			;		ex de, hl    ; put into DE 
a83c			 
a83c			 
a83c 21 5b e0				ld hl, baseram 
a83f					;ld hl, baseusermem 
a83f			 
a83f e5			push hl   ; sacreifical push 
a840			 
a840			.ldouscanm: 
a840 e1				pop hl 
a841			.ldouscan: 
a841				if DEBUG_FORTH_WORDS 
a841					DMARK "LSs" 
a841 f5				push af  
a842 3a 56 a8			ld a, (.dmark)  
a845 32 71 ee			ld (debug_mark),a  
a848 3a 57 a8			ld a, (.dmark+1)  
a84b 32 72 ee			ld (debug_mark+1),a  
a84e 3a 58 a8			ld a, (.dmark+2)  
a851 32 73 ee			ld (debug_mark+2),a  
a854 18 03			jr .pastdmark  
a856 ..			.dmark: db "LSs"  
a859 f1			.pastdmark: pop af  
a85a			endm  
# End of macro DMARK
a85a					CALLMONITOR 
a85a cd a3 94			call break_point_state  
a85d				endm  
# End of macro CALLMONITOR
a85d				endif 
a85d				; skip dict stub 
a85d cd 0b a0				call forth_tok_next 
a860			 
a860			 
a860			; while we have words to look for 
a860			 
a860 7e				ld a, (hl)      
a861				if DEBUG_FORTH_WORDS 
a861					DMARK "LSk" 
a861 f5				push af  
a862 3a 76 a8			ld a, (.dmark)  
a865 32 71 ee			ld (debug_mark),a  
a868 3a 77 a8			ld a, (.dmark+1)  
a86b 32 72 ee			ld (debug_mark+1),a  
a86e 3a 78 a8			ld a, (.dmark+2)  
a871 32 73 ee			ld (debug_mark+2),a  
a874 18 03			jr .pastdmark  
a876 ..			.dmark: db "LSk"  
a879 f1			.pastdmark: pop af  
a87a			endm  
# End of macro DMARK
a87a					CALLMONITOR 
a87a cd a3 94			call break_point_state  
a87d				endm  
# End of macro CALLMONITOR
a87d				endif 
a87d					;cp WORD_SYS_END 
a87d					;jp z, .lunotfound 
a87d			 
a87d					; if we hit non uwords then gone too far 
a87d fe 01				cp WORD_SYS_UWORD 
a87f c2 af a9				jp nz, .lunotfound 
a882			 
a882				if DEBUG_FORTH_WORDS 
a882					DMARK "LSu" 
a882 f5				push af  
a883 3a 97 a8			ld a, (.dmark)  
a886 32 71 ee			ld (debug_mark),a  
a889 3a 98 a8			ld a, (.dmark+1)  
a88c 32 72 ee			ld (debug_mark+1),a  
a88f 3a 99 a8			ld a, (.dmark+2)  
a892 32 73 ee			ld (debug_mark+2),a  
a895 18 03			jr .pastdmark  
a897 ..			.dmark: db "LSu"  
a89a f1			.pastdmark: pop af  
a89b			endm  
# End of macro DMARK
a89b					CALLMONITOR 
a89b cd a3 94			call break_point_state  
a89e				endm  
# End of macro CALLMONITOR
a89e				endif 
a89e			 
a89e					; found a uword but is it the one we want... 
a89e			 
a89e c5					push bc     ; uword to find is on bc 
a89f d1					pop de 
a8a0			 
a8a0 e5					push hl  ; to save the ptr 
a8a1			 
a8a1					; skip opcode 
a8a1 23					inc hl  
a8a2					; skip next ptr 
a8a2 23					inc hl  
a8a3 23					inc hl 
a8a4					; skip len 
a8a4 23					inc hl 
a8a5			 
a8a5				if DEBUG_FORTH_WORDS 
a8a5					DMARK "LSc" 
a8a5 f5				push af  
a8a6 3a ba a8			ld a, (.dmark)  
a8a9 32 71 ee			ld (debug_mark),a  
a8ac 3a bb a8			ld a, (.dmark+1)  
a8af 32 72 ee			ld (debug_mark+1),a  
a8b2 3a bc a8			ld a, (.dmark+2)  
a8b5 32 73 ee			ld (debug_mark+2),a  
a8b8 18 03			jr .pastdmark  
a8ba ..			.dmark: db "LSc"  
a8bd f1			.pastdmark: pop af  
a8be			endm  
# End of macro DMARK
a8be					CALLMONITOR 
a8be cd a3 94			call break_point_state  
a8c1				endm  
# End of macro CALLMONITOR
a8c1				endif 
a8c1 cd 38 91				call strcmp 
a8c4 c2 40 a8				jp nz, .ldouscanm 
a8c7				 
a8c7			 
a8c7			 
a8c7					; we have a uword so push its name to the stack 
a8c7			 
a8c7			;	   	push hl  ; save so we can move to next dict block 
a8c7 e1			pop hl 
a8c8			 
a8c8				if DEBUG_FORTH_WORDS 
a8c8					DMARK "LSm" 
a8c8 f5				push af  
a8c9 3a dd a8			ld a, (.dmark)  
a8cc 32 71 ee			ld (debug_mark),a  
a8cf 3a de a8			ld a, (.dmark+1)  
a8d2 32 72 ee			ld (debug_mark+1),a  
a8d5 3a df a8			ld a, (.dmark+2)  
a8d8 32 73 ee			ld (debug_mark+2),a  
a8db 18 03			jr .pastdmark  
a8dd ..			.dmark: db "LSm"  
a8e0 f1			.pastdmark: pop af  
a8e1			endm  
# End of macro DMARK
a8e1					CALLMONITOR 
a8e1 cd a3 94			call break_point_state  
a8e4				endm  
# End of macro CALLMONITOR
a8e4				endif 
a8e4			 
a8e4					; skip opcode 
a8e4 23					inc hl  
a8e5					; skip next ptr 
a8e5 23					inc hl  
a8e6 23					inc hl 
a8e7					; skip len 
a8e7 7e					ld a, (hl)   ; save length to add 
a8e8				if DEBUG_FORTH_WORDS 
a8e8					DMARK "LS2" 
a8e8 f5				push af  
a8e9 3a fd a8			ld a, (.dmark)  
a8ec 32 71 ee			ld (debug_mark),a  
a8ef 3a fe a8			ld a, (.dmark+1)  
a8f2 32 72 ee			ld (debug_mark+1),a  
a8f5 3a ff a8			ld a, (.dmark+2)  
a8f8 32 73 ee			ld (debug_mark+2),a  
a8fb 18 03			jr .pastdmark  
a8fd ..			.dmark: db "LS2"  
a900 f1			.pastdmark: pop af  
a901			endm  
# End of macro DMARK
a901					CALLMONITOR 
a901 cd a3 94			call break_point_state  
a904				endm  
# End of macro CALLMONITOR
a904				endif 
a904			 
a904					; save this location 
a904				 
a904 e5					push hl 
a905			 
a905 23					inc hl 
a906 11 cd e2				ld de, scratch+2 
a909 4f					ld c, a 
a90a 06 00				ld b, 0 
a90c			 
a90c				if DEBUG_FORTH_WORDS 
a90c					DMARK "LSn" 
a90c f5				push af  
a90d 3a 21 a9			ld a, (.dmark)  
a910 32 71 ee			ld (debug_mark),a  
a913 3a 22 a9			ld a, (.dmark+1)  
a916 32 72 ee			ld (debug_mark+1),a  
a919 3a 23 a9			ld a, (.dmark+2)  
a91c 32 73 ee			ld (debug_mark+2),a  
a91f 18 03			jr .pastdmark  
a921 ..			.dmark: db "LSn"  
a924 f1			.pastdmark: pop af  
a925			endm  
# End of macro DMARK
a925					CALLMONITOR 
a925 cd a3 94			call break_point_state  
a928				endm  
# End of macro CALLMONITOR
a928				endif 
a928			 
a928					; copy uword name to scratch 
a928			 
a928 ed b0				ldir 
a92a			 
a92a 1b					dec de 
a92b 3e 20				ld a, ' '    ; change null to space 
a92d 12					ld (de), a 
a92e			 
a92e 13					inc de 
a92f			 
a92f d5					push de 
a930 c1					pop bc     ; move scratch pointer to end of word name and save it 
a931			 
a931 e1					pop hl 
a932 7e					ld a, (hl) 
a933					;inc hl 
a933					; skip word string 
a933 cd a2 8c				call addatohl 
a936			 
a936 23					inc hl 
a937			 
a937				if DEBUG_FORTH_WORDS 
a937					DMARK "LS3" 
a937 f5				push af  
a938 3a 4c a9			ld a, (.dmark)  
a93b 32 71 ee			ld (debug_mark),a  
a93e 3a 4d a9			ld a, (.dmark+1)  
a941 32 72 ee			ld (debug_mark+1),a  
a944 3a 4e a9			ld a, (.dmark+2)  
a947 32 73 ee			ld (debug_mark+2),a  
a94a 18 03			jr .pastdmark  
a94c ..			.dmark: db "LS3"  
a94f f1			.pastdmark: pop af  
a950			endm  
# End of macro DMARK
a950					CALLMONITOR 
a950 cd a3 94			call break_point_state  
a953				endm  
# End of macro CALLMONITOR
a953				endif 
a953					; should now be at the start of the machine code to setup the eval of the uword 
a953					; now locate the ptr to the string defintion 
a953			 
a953					; skip ld hl, 
a953					; then load the ptr 
a953			; TODO use get from hl ptr 
a953 23					inc hl 
a954 5e					ld e, (hl) 
a955 23					inc hl 
a956 56					ld d, (hl) 
a957 eb					ex de, hl 
a958			 
a958			 
a958				if DEBUG_FORTH_WORDS 
a958					DMARK "LSt" 
a958 f5				push af  
a959 3a 6d a9			ld a, (.dmark)  
a95c 32 71 ee			ld (debug_mark),a  
a95f 3a 6e a9			ld a, (.dmark+1)  
a962 32 72 ee			ld (debug_mark+1),a  
a965 3a 6f a9			ld a, (.dmark+2)  
a968 32 73 ee			ld (debug_mark+2),a  
a96b 18 03			jr .pastdmark  
a96d ..			.dmark: db "LSt"  
a970 f1			.pastdmark: pop af  
a971			endm  
# End of macro DMARK
a971					CALLMONITOR 
a971 cd a3 94			call break_point_state  
a974				endm  
# End of macro CALLMONITOR
a974				endif 
a974			 
a974			; cant push right now due to tokenised strings  
a974			 
a974			; get the destination of where to copy this definition to. 
a974			 
a974 c5					push bc 
a975 d1					pop de 
a976			 
a976 7e			.listl:         ld a,(hl) 
a977 fe 00				cp 0 
a979 28 09				jr z, .lreplsp     ; replace zero with space 
a97b					;cp FORTH_END_BUFFER 
a97b fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a97d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a97f				 
a97f					; just copy this char as is then 
a97f			 
a97f 12					ld (de), a 
a980			 
a980 23			.listnxt:	inc hl 
a981 13					inc de 
a982 18 f2				jr .listl 
a984			 
a984 3e 20		.lreplsp:	ld a,' ' 
a986 12					ld (de), a 
a987 18 f7				jr .listnxt 
a989			 
a989			; close up uword def 
a989			 
a989			.listdone: 
a989 12					ld (de), a 
a98a 13					inc de 
a98b 3e 00				ld a, 0 
a98d 12					ld (de), a 
a98e			 
a98e			; now have def so clean up and push to stack 
a98e			 
a98e 21 cb e2				ld hl, scratch 
a991				if DEBUG_FORTH_WORDS 
a991					DMARK "Ltp" 
a991 f5				push af  
a992 3a a6 a9			ld a, (.dmark)  
a995 32 71 ee			ld (debug_mark),a  
a998 3a a7 a9			ld a, (.dmark+1)  
a99b 32 72 ee			ld (debug_mark+1),a  
a99e 3a a8 a9			ld a, (.dmark+2)  
a9a1 32 73 ee			ld (debug_mark+2),a  
a9a4 18 03			jr .pastdmark  
a9a6 ..			.dmark: db "Ltp"  
a9a9 f1			.pastdmark: pop af  
a9aa			endm  
# End of macro DMARK
a9aa					CALLMONITOR 
a9aa cd a3 94			call break_point_state  
a9ad				endm  
# End of macro CALLMONITOR
a9ad				endif 
a9ad			 
a9ad 18 1f			jr .listpush 
a9af			 
a9af			;.lnuword:	pop hl 
a9af			;		call forth_tok_next 
a9af			;		jp .ldouscan  
a9af			 
a9af			.lunotfound:		  
a9af			 
a9af				if DEBUG_FORTH_WORDS 
a9af					DMARK "LSn" 
a9af f5				push af  
a9b0 3a c4 a9			ld a, (.dmark)  
a9b3 32 71 ee			ld (debug_mark),a  
a9b6 3a c5 a9			ld a, (.dmark+1)  
a9b9 32 72 ee			ld (debug_mark+1),a  
a9bc 3a c6 a9			ld a, (.dmark+2)  
a9bf 32 73 ee			ld (debug_mark+2),a  
a9c2 18 03			jr .pastdmark  
a9c4 ..			.dmark: db "LSn"  
a9c7 f1			.pastdmark: pop af  
a9c8			endm  
# End of macro DMARK
a9c8					CALLMONITOR 
a9c8 cd a3 94			call break_point_state  
a9cb				endm  
# End of macro CALLMONITOR
a9cb				endif 
a9cb			 
a9cb					 
a9cb			;		FORTH_DSP_POP 
a9cb			;		ld hl, .luno 
a9cb			 
a9cb					NEXTW			 
a9cb c3 ba 9e			jp macro_next 
a9ce				endm 
# End of macro NEXTW
a9ce			 
a9ce			.listpush: 
a9ce				if DEBUG_FORTH_WORDS 
a9ce					DMARK "LS>" 
a9ce f5				push af  
a9cf 3a e3 a9			ld a, (.dmark)  
a9d2 32 71 ee			ld (debug_mark),a  
a9d5 3a e4 a9			ld a, (.dmark+1)  
a9d8 32 72 ee			ld (debug_mark+1),a  
a9db 3a e5 a9			ld a, (.dmark+2)  
a9de 32 73 ee			ld (debug_mark+2),a  
a9e1 18 03			jr .pastdmark  
a9e3 ..			.dmark: db "LS>"  
a9e6 f1			.pastdmark: pop af  
a9e7			endm  
# End of macro DMARK
a9e7					CALLMONITOR 
a9e7 cd a3 94			call break_point_state  
a9ea				endm  
# End of macro CALLMONITOR
a9ea				endif 
a9ea cd 82 9b				call forth_push_str 
a9ed			 
a9ed			 
a9ed			 
a9ed					NEXTW 
a9ed c3 ba 9e			jp macro_next 
a9f0				endm 
# End of macro NEXTW
a9f0			 
a9f0			;.luno:    db "Word not found",0 
a9f0			 
a9f0			 
a9f0			 
a9f0			 
a9f0			 
a9f0			;		push hl   ; save pointer to start of uword def string 
a9f0			; 
a9f0			;; look for FORTH_EOL_LINE 
a9f0			;		ld a, FORTH_END_BUFFER 
a9f0			;		call strlent 
a9f0			; 
a9f0			;		inc hl		 ; space for coln def 
a9f0			;		inc hl 
a9f0			;		inc hl          ; space for terms 
a9f0			;		inc hl 
a9f0			; 
a9f0			;		ld a, 20   ; TODO get actual length 
a9f0			;		call addatohl    ; include a random amount of room for the uword name 
a9f0			; 
a9f0			;		 
a9f0			;	if DEBUG_FORTH_WORDS 
a9f0			;		DMARK "Lt1" 
a9f0			;		CALLMONITOR 
a9f0			;	endif 
a9f0			;		 
a9f0			; 
a9f0			;; malloc space for the string because we cant change it 
a9f0			; 
a9f0			;		call malloc 
a9f0			;	if DEBUG_FORTH_MALLOC_GUARD 
a9f0			;		push af 
a9f0			;		call ishlzero 
a9f0			;		pop af 
a9f0			;		 
a9f0			;		call z,malloc_error 
a9f0			;	endif 
a9f0			; 
a9f0			;	if DEBUG_FORTH_WORDS 
a9f0			;		DMARK "Lt2" 
a9f0			;		CALLMONITOR 
a9f0			;	endif 
a9f0			;		pop de 
a9f0			;		push hl    ; push the malloc to release later 
a9f0			;		push hl   ;  push back a copy for the later stack push 
a9f0			;		 
a9f0			;; copy the string swapping out the zero terms for spaces 
a9f0			; 
a9f0			;		; de has our source 
a9f0			;		; hl has our dest 
a9f0			; 
a9f0			;; add the coln def 
a9f0			; 
a9f0			;		ld a, ':' 
a9f0			;		ld (hl), a 
a9f0			;		inc hl 
a9f0			;		ld a, ' ' 
a9f0			;		ld (hl), a 
a9f0			;		inc hl 
a9f0			; 
a9f0			;; add the uname word 
a9f0			;		push de   ; save our string for now 
a9f0			;		ex de, hl 
a9f0			; 
a9f0			;		FORTH_DSP_VALUE 
a9f0			;		;v5 FORTH_DSP_VALUE 
a9f0			; 
a9f0			;		inc hl   ; skip type but we know by now this is OK 
a9f0			; 
a9f0			;.luword:	ld a,(hl) 
a9f0			;		cp 0 
a9f0			;		jr z, .luword2 
a9f0			;		ld (de), a 
a9f0			;		inc de 
a9f0			;		inc hl 
a9f0			;		jr .luword 
a9f0			; 
a9f0			;.luword2:	ld a, ' ' 
a9f0			;		ld (de), a 
a9f0			;;		inc hl 
a9f0			;;		inc de 
a9f0			;;		ld (de), a 
a9f0			;;		inc hl 
a9f0			;		inc de 
a9f0			; 
a9f0			;		ex de, hl 
a9f0			;		pop de 
a9f0			;		 
a9f0			;		 
a9f0			; 
a9f0			;; detoken that string and copy it 
a9f0			; 
a9f0			;	if DEBUG_FORTH_WORDS 
a9f0			;		DMARK "Lt2" 
a9f0			;		CALLMONITOR 
a9f0			;	endif 
a9f0			;.ldetok:	ld a, (de) 
a9f0			;		cp FORTH_END_BUFFER 
a9f0			;		jr z, .ldetokend 
a9f0			;		; swap out any zero term for space 
a9f0			;		cp 0 
a9f0			;		jr nz, .ldetoknext 
a9f0			;		ld a, ' ' 
a9f0			; 
a9f0			;	if DEBUG_FORTH_WORDS 
a9f0			;		DMARK "LtS" 
a9f0			;		CALLMONITOR 
a9f0			;	endif 
a9f0			;.ldetoknext:	ld (hl), a 
a9f0			;		inc de 
a9f0			;		inc hl 
a9f0			;		jr .ldetok 
a9f0			; 
a9f0			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a9f0			;		ld (hl), a  
a9f0			; 
a9f0			;; free that temp malloc 
a9f0			; 
a9f0			;		pop hl    
a9f0			; 
a9f0			;	if DEBUG_FORTH_WORDS 
a9f0			;		DMARK "Lt4" 
a9f0			;		CALLMONITOR 
a9f0			;	endif 
a9f0			;		call forth_apushstrhl 
a9f0			; 
a9f0			;		; get rid of temp malloc area 
a9f0			; 
a9f0			;		pop hl 
a9f0			;		call free 
a9f0			; 
a9f0			;		jr .ludone 
a9f0			; 
a9f0			;.lnuword:	pop hl 
a9f0			;		call forth_tok_next 
a9f0			;		jp .ldouscan  
a9f0			; 
a9f0			;.ludone:		 pop hl 
a9f0			; 
a9f0					NEXTW 
a9f0 c3 ba 9e			jp macro_next 
a9f3				endm 
# End of macro NEXTW
a9f3			 
a9f3			.FORGET: 
a9f3				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a9f3 5d				db WORD_SYS_CORE+73             
a9f4 6c aa			dw .NOP            
a9f6 07				db 6 + 1 
a9f7 .. 00			db "FORGET",0              
a9fe				endm 
# End of macro CWHEAD
a9fe			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a9fe			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a9fe			; | |  
a9fe			; | | e.g. "MORE" forget 
a9fe					if DEBUG_FORTH_WORDS_KEY 
a9fe						DMARK "FRG" 
a9fe f5				push af  
a9ff 3a 13 aa			ld a, (.dmark)  
aa02 32 71 ee			ld (debug_mark),a  
aa05 3a 14 aa			ld a, (.dmark+1)  
aa08 32 72 ee			ld (debug_mark+1),a  
aa0b 3a 15 aa			ld a, (.dmark+2)  
aa0e 32 73 ee			ld (debug_mark+2),a  
aa11 18 03			jr .pastdmark  
aa13 ..			.dmark: db "FRG"  
aa16 f1			.pastdmark: pop af  
aa17			endm  
# End of macro DMARK
aa17						CALLMONITOR 
aa17 cd a3 94			call break_point_state  
aa1a				endm  
# End of macro CALLMONITOR
aa1a					endif 
aa1a			 
aa1a				; find uword 
aa1a			        ; update start of word with "_" 
aa1a				; replace uword with deleted flag 
aa1a			 
aa1a			 
aa1a			;	if DEBUG_FORTH_WORDS 
aa1a			;		DMARK "FOG" 
aa1a			;		CALLMONITOR 
aa1a			;	endif 
aa1a			 
aa1a			 
aa1a					; Get ptr to the word we need to look up 
aa1a			 
aa1a					FORTH_DSP_VALUEHL 
aa1a cd 0b 9d			call macro_dsp_valuehl 
aa1d				endm 
# End of macro FORTH_DSP_VALUEHL
aa1d					;v5 FORTH_DSP_VALUE 
aa1d				; TODO type check 
aa1d			;		inc hl    ; Skip type check  
aa1d e5					push hl 
aa1e c1					pop bc 
aa1f			;		ex de, hl    ; put into DE 
aa1f			 
aa1f			 
aa1f 21 5b e0				ld hl, baseram 
aa22					;ld hl, baseusermem 
aa22			 
aa22				; skip dict stub 
aa22			;	call forth_tok_next 
aa22 e5			push hl   ; sacreifical push 
aa23			 
aa23			.fldouscanm: 
aa23 e1				pop hl 
aa24			.fldouscan: 
aa24			;	if DEBUG_FORTH_WORDS 
aa24			;		DMARK "LSs" 
aa24			;		CALLMONITOR 
aa24			;	endif 
aa24				; skip dict stub 
aa24 cd 0b a0				call forth_tok_next 
aa27			 
aa27			 
aa27			; while we have words to look for 
aa27			 
aa27 7e				ld a, (hl)      
aa28			;	if DEBUG_FORTH_WORDS 
aa28			;		DMARK "LSk" 
aa28			;		CALLMONITOR 
aa28			;	endif 
aa28 fe 00				cp WORD_SYS_END 
aa2a ca 66 aa				jp z, .flunotfound 
aa2d fe 01				cp WORD_SYS_UWORD 
aa2f c2 24 aa				jp nz, .fldouscan 
aa32			 
aa32			;	if DEBUG_FORTH_WORDS 
aa32			;		DMARK "LSu" 
aa32			;		CALLMONITOR 
aa32			;	endif 
aa32			 
aa32					; found a uword but is it the one we want... 
aa32			 
aa32 c5					push bc     ; uword to find is on bc 
aa33 d1					pop de 
aa34			 
aa34 e5					push hl  ; to save the ptr 
aa35			 
aa35					; skip opcode 
aa35 23					inc hl  
aa36					; skip next ptr 
aa36 23					inc hl  
aa37 23					inc hl 
aa38					; skip len 
aa38 23					inc hl 
aa39			 
aa39			;	if DEBUG_FORTH_WORDS 
aa39			;		DMARK "LSc" 
aa39			;		CALLMONITOR 
aa39			;	endif 
aa39 cd 38 91				call strcmp 
aa3c c2 23 aa				jp nz, .fldouscanm 
aa3f			; 
aa3f			; 
aa3f			;; while we have words to look for 
aa3f			; 
aa3f			;.fdouscan:	ld a, (hl)      
aa3f			;	if DEBUG_FORTH_WORDS 
aa3f			;		DMARK "LSs" 
aa3f			;		CALLMONITOR 
aa3f			;	endif 
aa3f			;		cp WORD_SYS_END 
aa3f			;		jp z, .fudone 
aa3f			;		cp WORD_SYS_UWORD 
aa3f			;		jp nz, .fnuword 
aa3f			; 
aa3f			;	if DEBUG_FORTH_WORDS 
aa3f			;		DMARK "FGu" 
aa3f			;		CALLMONITOR 
aa3f			;	endif 
aa3f			; 
aa3f			;		; found a uword but is it the one we want... 
aa3f			; 
aa3f			; 
aa3f			;	        pop de   ; get back the dsp name 
aa3f			;		push de 
aa3f			; 
aa3f			;		push hl  ; to save the ptr 
aa3f			; 
aa3f			;		; skip opcode 
aa3f			;		inc hl  
aa3f			;		; skip next ptr 
aa3f			;		inc hl  
aa3f			;		inc hl 
aa3f			;		; skip len 
aa3f			;		inc hl 
aa3f			; 
aa3f			;	if DEBUG_FORTH_WORDS 
aa3f			;		DMARK "FGc" 
aa3f			;		CALLMONITOR 
aa3f			;	endif 
aa3f			;		call strcmp 
aa3f			;		jp nz, .fnuword 
aa3f			 
aa3f			 
aa3f e1			pop hl 
aa40			 
aa40				 
aa40				if DEBUG_FORTH_WORDS 
aa40					DMARK "FGm" 
aa40 f5				push af  
aa41 3a 55 aa			ld a, (.dmark)  
aa44 32 71 ee			ld (debug_mark),a  
aa47 3a 56 aa			ld a, (.dmark+1)  
aa4a 32 72 ee			ld (debug_mark+1),a  
aa4d 3a 57 aa			ld a, (.dmark+2)  
aa50 32 73 ee			ld (debug_mark+2),a  
aa53 18 03			jr .pastdmark  
aa55 ..			.dmark: db "FGm"  
aa58 f1			.pastdmark: pop af  
aa59			endm  
# End of macro DMARK
aa59					CALLMONITOR 
aa59 cd a3 94			call break_point_state  
aa5c				endm  
# End of macro CALLMONITOR
aa5c				endif 
aa5c			 
aa5c			 
aa5c			 
aa5c					; we have a uword so push its name to the stack 
aa5c			 
aa5c			;	   	push hl  ; save so we can move to next dict block 
aa5c			;pop hl 
aa5c			 
aa5c					; update opcode to deleted 
aa5c 3e 03				ld a, WORD_SYS_DELETED 
aa5e 77					ld (hl), a 
aa5f			 
aa5f 23					inc hl  
aa60					; skip next ptr 
aa60 23					inc hl  
aa61 23					inc hl 
aa62					; skip len 
aa62 23					inc hl 
aa63			 
aa63					; TODO change parser to skip deleted words but for now mark it out 
aa63 3e 5f				ld a, "_" 
aa65 77					ld  (hl),a 
aa66			 
aa66			;		jr .fudone 
aa66			; 
aa66			;.fnuword:	pop hl 
aa66			;		call forth_tok_next 
aa66			;		jp .fdouscan  
aa66			 
aa66			.flunotfound:		  
aa66			 
aa66			 
aa66					 
aa66					FORTH_DSP_POP 
aa66 cd c3 9d			call macro_forth_dsp_pop 
aa69				endm 
# End of macro FORTH_DSP_POP
aa69			;		ld hl, .luno 
aa69			;.fudone:		 pop hl 
aa69					NEXTW 
aa69 c3 ba 9e			jp macro_next 
aa6c				endm 
# End of macro NEXTW
aa6c			.NOP: 
aa6c				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa6c 61				db WORD_SYS_CORE+77             
aa6d 93 aa			dw .COMO            
aa6f 04				db 3 + 1 
aa70 .. 00			db "NOP",0              
aa74				endm 
# End of macro CWHEAD
aa74			; | NOP (  --  ) Do nothing | DONE 
aa74					if DEBUG_FORTH_WORDS_KEY 
aa74						DMARK "NOP" 
aa74 f5				push af  
aa75 3a 89 aa			ld a, (.dmark)  
aa78 32 71 ee			ld (debug_mark),a  
aa7b 3a 8a aa			ld a, (.dmark+1)  
aa7e 32 72 ee			ld (debug_mark+1),a  
aa81 3a 8b aa			ld a, (.dmark+2)  
aa84 32 73 ee			ld (debug_mark+2),a  
aa87 18 03			jr .pastdmark  
aa89 ..			.dmark: db "NOP"  
aa8c f1			.pastdmark: pop af  
aa8d			endm  
# End of macro DMARK
aa8d						CALLMONITOR 
aa8d cd a3 94			call break_point_state  
aa90				endm  
# End of macro CALLMONITOR
aa90					endif 
aa90				       NEXTW 
aa90 c3 ba 9e			jp macro_next 
aa93				endm 
# End of macro NEXTW
aa93			.COMO: 
aa93				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa93 6e				db WORD_SYS_CORE+90             
aa94 e5 aa			dw .COMC            
aa96 02				db 1 + 1 
aa97 .. 00			db "(",0              
aa99				endm 
# End of macro CWHEAD
aa99			; | ( ( -- )  Start of comment | DONE 
aa99			 
aa99			 
aa99 2a cc e5				ld hl, ( os_tok_ptr) 
aa9c 11 e0 aa			ld de, .closepar 
aa9f					 
aa9f					if DEBUG_FORTH_WORDS 
aa9f						DMARK ").." 
aa9f f5				push af  
aaa0 3a b4 aa			ld a, (.dmark)  
aaa3 32 71 ee			ld (debug_mark),a  
aaa6 3a b5 aa			ld a, (.dmark+1)  
aaa9 32 72 ee			ld (debug_mark+1),a  
aaac 3a b6 aa			ld a, (.dmark+2)  
aaaf 32 73 ee			ld (debug_mark+2),a  
aab2 18 03			jr .pastdmark  
aab4 ..			.dmark: db ").."  
aab7 f1			.pastdmark: pop af  
aab8			endm  
# End of macro DMARK
aab8						CALLMONITOR 
aab8 cd a3 94			call break_point_state  
aabb				endm  
# End of macro CALLMONITOR
aabb					endif 
aabb cd d5 9f			call findnexttok  
aabe			 
aabe					if DEBUG_FORTH_WORDS 
aabe						DMARK "IF5" 
aabe f5				push af  
aabf 3a d3 aa			ld a, (.dmark)  
aac2 32 71 ee			ld (debug_mark),a  
aac5 3a d4 aa			ld a, (.dmark+1)  
aac8 32 72 ee			ld (debug_mark+1),a  
aacb 3a d5 aa			ld a, (.dmark+2)  
aace 32 73 ee			ld (debug_mark+2),a  
aad1 18 03			jr .pastdmark  
aad3 ..			.dmark: db "IF5"  
aad6 f1			.pastdmark: pop af  
aad7			endm  
# End of macro DMARK
aad7						CALLMONITOR 
aad7 cd a3 94			call break_point_state  
aada				endm  
# End of macro CALLMONITOR
aada					endif 
aada				; replace below with ) exec using tok_ptr 
aada 22 cc e5			ld (os_tok_ptr), hl 
aadd c3 4b 9f			jp exec1 
aae0			 
aae0 .. 00			.closepar:   db ")",0 
aae2			 
aae2				       NEXTW 
aae2 c3 ba 9e			jp macro_next 
aae5				endm 
# End of macro NEXTW
aae5			.COMC: 
aae5				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aae5 6f				db WORD_SYS_CORE+91             
aae6 ee aa			dw .SCRATCH            
aae8 02				db 1 + 1 
aae9 .. 00			db ")",0              
aaeb				endm 
# End of macro CWHEAD
aaeb			; | ) ( -- )  End of comment |  DONE  
aaeb				       NEXTW 
aaeb c3 ba 9e			jp macro_next 
aaee				endm 
# End of macro NEXTW
aaee			 
aaee			.SCRATCH: 
aaee				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aaee 6f				db WORD_SYS_CORE+91             
aaef 29 ab			dw .INC            
aaf1 08				db 7 + 1 
aaf2 .. 00			db "SCRATCH",0              
aafa				endm 
# End of macro CWHEAD
aafa			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aafa			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aafa			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aafa			; | |  
aafa			; | | e.g.    : score $00 scratch ; 
aafa			; | |  
aafa			; | | $00 score ! 
aafa			; | | $01 score +! 
aafa			; | |  
aafa			; | | e.g.   : varword $0a scratch ;  
aafa			; | | 
aafa			; | | $8000 varword ! 
aafa					if DEBUG_FORTH_WORDS_KEY 
aafa						DMARK "SCR" 
aafa f5				push af  
aafb 3a 0f ab			ld a, (.dmark)  
aafe 32 71 ee			ld (debug_mark),a  
ab01 3a 10 ab			ld a, (.dmark+1)  
ab04 32 72 ee			ld (debug_mark+1),a  
ab07 3a 11 ab			ld a, (.dmark+2)  
ab0a 32 73 ee			ld (debug_mark+2),a  
ab0d 18 03			jr .pastdmark  
ab0f ..			.dmark: db "SCR"  
ab12 f1			.pastdmark: pop af  
ab13			endm  
# End of macro DMARK
ab13						CALLMONITOR 
ab13 cd a3 94			call break_point_state  
ab16				endm  
# End of macro CALLMONITOR
ab16					endif 
ab16			 
ab16					FORTH_DSP_VALUEHL 
ab16 cd 0b 9d			call macro_dsp_valuehl 
ab19				endm 
# End of macro FORTH_DSP_VALUEHL
ab19				 
ab19					FORTH_DSP_POP 
ab19 cd c3 9d			call macro_forth_dsp_pop 
ab1c				endm 
# End of macro FORTH_DSP_POP
ab1c			 
ab1c 7d					ld a, l 
ab1d 21 f0 e7				ld hl, os_var_array 
ab20 cd a2 8c				call addatohl 
ab23			 
ab23 cd 14 9b				call forth_push_numhl 
ab26			 
ab26				       NEXTW 
ab26 c3 ba 9e			jp macro_next 
ab29				endm 
# End of macro NEXTW
ab29			 
ab29			.INC: 
ab29				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab29 6f				db WORD_SYS_CORE+91             
ab2a 7d ab			dw .DEC            
ab2c 03				db 2 + 1 
ab2d .. 00			db "+!",0              
ab30				endm 
# End of macro CWHEAD
ab30			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab30					if DEBUG_FORTH_WORDS_KEY 
ab30						DMARK "+s_" 
ab30 f5				push af  
ab31 3a 45 ab			ld a, (.dmark)  
ab34 32 71 ee			ld (debug_mark),a  
ab37 3a 46 ab			ld a, (.dmark+1)  
ab3a 32 72 ee			ld (debug_mark+1),a  
ab3d 3a 47 ab			ld a, (.dmark+2)  
ab40 32 73 ee			ld (debug_mark+2),a  
ab43 18 03			jr .pastdmark  
ab45 ..			.dmark: db "+s_"  
ab48 f1			.pastdmark: pop af  
ab49			endm  
# End of macro DMARK
ab49						CALLMONITOR 
ab49 cd a3 94			call break_point_state  
ab4c				endm  
# End of macro CALLMONITOR
ab4c					endif 
ab4c			 
ab4c					FORTH_DSP_VALUEHL 
ab4c cd 0b 9d			call macro_dsp_valuehl 
ab4f				endm 
# End of macro FORTH_DSP_VALUEHL
ab4f			 
ab4f e5					push hl   ; save address 
ab50			 
ab50					FORTH_DSP_POP 
ab50 cd c3 9d			call macro_forth_dsp_pop 
ab53				endm 
# End of macro FORTH_DSP_POP
ab53			 
ab53					FORTH_DSP_VALUEHL 
ab53 cd 0b 9d			call macro_dsp_valuehl 
ab56				endm 
# End of macro FORTH_DSP_VALUEHL
ab56			 
ab56					FORTH_DSP_POP 
ab56 cd c3 9d			call macro_forth_dsp_pop 
ab59				endm 
# End of macro FORTH_DSP_POP
ab59			 
ab59					; hl contains value to add to byte at a 
ab59				 
ab59 eb					ex de, hl 
ab5a			 
ab5a e1					pop hl 
ab5b			 
ab5b					if DEBUG_FORTH_WORDS 
ab5b						DMARK "INC" 
ab5b f5				push af  
ab5c 3a 70 ab			ld a, (.dmark)  
ab5f 32 71 ee			ld (debug_mark),a  
ab62 3a 71 ab			ld a, (.dmark+1)  
ab65 32 72 ee			ld (debug_mark+1),a  
ab68 3a 72 ab			ld a, (.dmark+2)  
ab6b 32 73 ee			ld (debug_mark+2),a  
ab6e 18 03			jr .pastdmark  
ab70 ..			.dmark: db "INC"  
ab73 f1			.pastdmark: pop af  
ab74			endm  
# End of macro DMARK
ab74						CALLMONITOR 
ab74 cd a3 94			call break_point_state  
ab77				endm  
# End of macro CALLMONITOR
ab77					endif 
ab77			 
ab77 7e					ld a,(hl) 
ab78 83					add e 
ab79 77					ld (hl),a 
ab7a			 
ab7a			 
ab7a			 
ab7a				       NEXTW 
ab7a c3 ba 9e			jp macro_next 
ab7d				endm 
# End of macro NEXTW
ab7d			 
ab7d			.DEC: 
ab7d				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ab7d 6f				db WORD_SYS_CORE+91             
ab7e ce ab			dw .INC2            
ab80 03				db 2 + 1 
ab81 .. 00			db "-!",0              
ab84				endm 
# End of macro CWHEAD
ab84			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab84					if DEBUG_FORTH_WORDS_KEY 
ab84						DMARK "-s_" 
ab84 f5				push af  
ab85 3a 99 ab			ld a, (.dmark)  
ab88 32 71 ee			ld (debug_mark),a  
ab8b 3a 9a ab			ld a, (.dmark+1)  
ab8e 32 72 ee			ld (debug_mark+1),a  
ab91 3a 9b ab			ld a, (.dmark+2)  
ab94 32 73 ee			ld (debug_mark+2),a  
ab97 18 03			jr .pastdmark  
ab99 ..			.dmark: db "-s_"  
ab9c f1			.pastdmark: pop af  
ab9d			endm  
# End of macro DMARK
ab9d						CALLMONITOR 
ab9d cd a3 94			call break_point_state  
aba0				endm  
# End of macro CALLMONITOR
aba0					endif 
aba0			 
aba0					FORTH_DSP_VALUEHL 
aba0 cd 0b 9d			call macro_dsp_valuehl 
aba3				endm 
# End of macro FORTH_DSP_VALUEHL
aba3			 
aba3 e5					push hl   ; save address 
aba4			 
aba4					FORTH_DSP_POP 
aba4 cd c3 9d			call macro_forth_dsp_pop 
aba7				endm 
# End of macro FORTH_DSP_POP
aba7			 
aba7					FORTH_DSP_VALUEHL 
aba7 cd 0b 9d			call macro_dsp_valuehl 
abaa				endm 
# End of macro FORTH_DSP_VALUEHL
abaa			 
abaa					; hl contains value to add to byte at a 
abaa				 
abaa eb					ex de, hl 
abab			 
abab e1					pop hl 
abac			 
abac					if DEBUG_FORTH_WORDS 
abac						DMARK "DEC" 
abac f5				push af  
abad 3a c1 ab			ld a, (.dmark)  
abb0 32 71 ee			ld (debug_mark),a  
abb3 3a c2 ab			ld a, (.dmark+1)  
abb6 32 72 ee			ld (debug_mark+1),a  
abb9 3a c3 ab			ld a, (.dmark+2)  
abbc 32 73 ee			ld (debug_mark+2),a  
abbf 18 03			jr .pastdmark  
abc1 ..			.dmark: db "DEC"  
abc4 f1			.pastdmark: pop af  
abc5			endm  
# End of macro DMARK
abc5						CALLMONITOR 
abc5 cd a3 94			call break_point_state  
abc8				endm  
# End of macro CALLMONITOR
abc8					endif 
abc8			 
abc8 7e					ld a,(hl) 
abc9 93					sub e 
abca 77					ld (hl),a 
abcb			 
abcb			 
abcb			 
abcb				       NEXTW 
abcb c3 ba 9e			jp macro_next 
abce				endm 
# End of macro NEXTW
abce			 
abce			.INC2: 
abce				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
abce 6f				db WORD_SYS_CORE+91             
abcf 78 ac			dw .DEC2            
abd1 04				db 3 + 1 
abd2 .. 00			db "+2!",0              
abd6				endm 
# End of macro CWHEAD
abd6			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
abd6			 
abd6					if DEBUG_FORTH_WORDS_KEY 
abd6						DMARK "+2s" 
abd6 f5				push af  
abd7 3a eb ab			ld a, (.dmark)  
abda 32 71 ee			ld (debug_mark),a  
abdd 3a ec ab			ld a, (.dmark+1)  
abe0 32 72 ee			ld (debug_mark+1),a  
abe3 3a ed ab			ld a, (.dmark+2)  
abe6 32 73 ee			ld (debug_mark+2),a  
abe9 18 03			jr .pastdmark  
abeb ..			.dmark: db "+2s"  
abee f1			.pastdmark: pop af  
abef			endm  
# End of macro DMARK
abef						CALLMONITOR 
abef cd a3 94			call break_point_state  
abf2				endm  
# End of macro CALLMONITOR
abf2					endif 
abf2			 
abf2					; Address 
abf2			 
abf2					FORTH_DSP_VALUEHL 
abf2 cd 0b 9d			call macro_dsp_valuehl 
abf5				endm 
# End of macro FORTH_DSP_VALUEHL
abf5			 
abf5 e5					push hl    ; save address 
abf6			 
abf6					; load content into de 
abf6			 
abf6 5e					ld e,(hl) 
abf7 23					inc hl 
abf8 56					ld d, (hl) 
abf9			 
abf9					if DEBUG_FORTH_WORDS 
abf9						DMARK "+2a" 
abf9 f5				push af  
abfa 3a 0e ac			ld a, (.dmark)  
abfd 32 71 ee			ld (debug_mark),a  
ac00 3a 0f ac			ld a, (.dmark+1)  
ac03 32 72 ee			ld (debug_mark+1),a  
ac06 3a 10 ac			ld a, (.dmark+2)  
ac09 32 73 ee			ld (debug_mark+2),a  
ac0c 18 03			jr .pastdmark  
ac0e ..			.dmark: db "+2a"  
ac11 f1			.pastdmark: pop af  
ac12			endm  
# End of macro DMARK
ac12						CALLMONITOR 
ac12 cd a3 94			call break_point_state  
ac15				endm  
# End of macro CALLMONITOR
ac15					endif 
ac15			 
ac15					FORTH_DSP_POP 
ac15 cd c3 9d			call macro_forth_dsp_pop 
ac18				endm 
# End of macro FORTH_DSP_POP
ac18			 
ac18					; Get value to add 
ac18			 
ac18					FORTH_DSP_VALUE 
ac18 cd f4 9c			call macro_forth_dsp_value 
ac1b				endm 
# End of macro FORTH_DSP_VALUE
ac1b			 
ac1b					if DEBUG_FORTH_WORDS 
ac1b						DMARK "+2v" 
ac1b f5				push af  
ac1c 3a 30 ac			ld a, (.dmark)  
ac1f 32 71 ee			ld (debug_mark),a  
ac22 3a 31 ac			ld a, (.dmark+1)  
ac25 32 72 ee			ld (debug_mark+1),a  
ac28 3a 32 ac			ld a, (.dmark+2)  
ac2b 32 73 ee			ld (debug_mark+2),a  
ac2e 18 03			jr .pastdmark  
ac30 ..			.dmark: db "+2v"  
ac33 f1			.pastdmark: pop af  
ac34			endm  
# End of macro DMARK
ac34						CALLMONITOR 
ac34 cd a3 94			call break_point_state  
ac37				endm  
# End of macro CALLMONITOR
ac37					endif 
ac37			 
ac37 19					add hl, de 
ac38			 
ac38					if DEBUG_FORTH_WORDS 
ac38						DMARK "+2+" 
ac38 f5				push af  
ac39 3a 4d ac			ld a, (.dmark)  
ac3c 32 71 ee			ld (debug_mark),a  
ac3f 3a 4e ac			ld a, (.dmark+1)  
ac42 32 72 ee			ld (debug_mark+1),a  
ac45 3a 4f ac			ld a, (.dmark+2)  
ac48 32 73 ee			ld (debug_mark+2),a  
ac4b 18 03			jr .pastdmark  
ac4d ..			.dmark: db "+2+"  
ac50 f1			.pastdmark: pop af  
ac51			endm  
# End of macro DMARK
ac51						CALLMONITOR 
ac51 cd a3 94			call break_point_state  
ac54				endm  
# End of macro CALLMONITOR
ac54					endif 
ac54			 
ac54					; move result to de 
ac54			 
ac54 eb					ex de, hl 
ac55			 
ac55					; Address 
ac55			 
ac55 e1					pop hl 
ac56			 
ac56					; save it back 
ac56			 
ac56 73					ld (hl), e 
ac57 23					inc hl 
ac58 72					ld (hl), d 
ac59			 
ac59					if DEBUG_FORTH_WORDS 
ac59						DMARK "+2e" 
ac59 f5				push af  
ac5a 3a 6e ac			ld a, (.dmark)  
ac5d 32 71 ee			ld (debug_mark),a  
ac60 3a 6f ac			ld a, (.dmark+1)  
ac63 32 72 ee			ld (debug_mark+1),a  
ac66 3a 70 ac			ld a, (.dmark+2)  
ac69 32 73 ee			ld (debug_mark+2),a  
ac6c 18 03			jr .pastdmark  
ac6e ..			.dmark: db "+2e"  
ac71 f1			.pastdmark: pop af  
ac72			endm  
# End of macro DMARK
ac72						CALLMONITOR 
ac72 cd a3 94			call break_point_state  
ac75				endm  
# End of macro CALLMONITOR
ac75					endif 
ac75			 
ac75			 
ac75			 
ac75			 
ac75			 
ac75				       NEXTW 
ac75 c3 ba 9e			jp macro_next 
ac78				endm 
# End of macro NEXTW
ac78			 
ac78			.DEC2: 
ac78				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ac78 6f				db WORD_SYS_CORE+91             
ac79 24 ad			dw .GET2            
ac7b 04				db 3 + 1 
ac7c .. 00			db "-2!",0              
ac80				endm 
# End of macro CWHEAD
ac80			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac80			 
ac80			 
ac80					if DEBUG_FORTH_WORDS_KEY 
ac80						DMARK "-2s" 
ac80 f5				push af  
ac81 3a 95 ac			ld a, (.dmark)  
ac84 32 71 ee			ld (debug_mark),a  
ac87 3a 96 ac			ld a, (.dmark+1)  
ac8a 32 72 ee			ld (debug_mark+1),a  
ac8d 3a 97 ac			ld a, (.dmark+2)  
ac90 32 73 ee			ld (debug_mark+2),a  
ac93 18 03			jr .pastdmark  
ac95 ..			.dmark: db "-2s"  
ac98 f1			.pastdmark: pop af  
ac99			endm  
# End of macro DMARK
ac99						CALLMONITOR 
ac99 cd a3 94			call break_point_state  
ac9c				endm  
# End of macro CALLMONITOR
ac9c					endif 
ac9c			 
ac9c					; Address 
ac9c			 
ac9c					FORTH_DSP_VALUEHL 
ac9c cd 0b 9d			call macro_dsp_valuehl 
ac9f				endm 
# End of macro FORTH_DSP_VALUEHL
ac9f			 
ac9f e5					push hl    ; save address 
aca0			 
aca0					; load content into de 
aca0			 
aca0 5e					ld e,(hl) 
aca1 23					inc hl 
aca2 56					ld d, (hl) 
aca3			 
aca3					if DEBUG_FORTH_WORDS 
aca3						DMARK "-2a" 
aca3 f5				push af  
aca4 3a b8 ac			ld a, (.dmark)  
aca7 32 71 ee			ld (debug_mark),a  
acaa 3a b9 ac			ld a, (.dmark+1)  
acad 32 72 ee			ld (debug_mark+1),a  
acb0 3a ba ac			ld a, (.dmark+2)  
acb3 32 73 ee			ld (debug_mark+2),a  
acb6 18 03			jr .pastdmark  
acb8 ..			.dmark: db "-2a"  
acbb f1			.pastdmark: pop af  
acbc			endm  
# End of macro DMARK
acbc						CALLMONITOR 
acbc cd a3 94			call break_point_state  
acbf				endm  
# End of macro CALLMONITOR
acbf					endif 
acbf			 
acbf					FORTH_DSP_POP 
acbf cd c3 9d			call macro_forth_dsp_pop 
acc2				endm 
# End of macro FORTH_DSP_POP
acc2			 
acc2					; Get value to remove 
acc2			 
acc2					FORTH_DSP_VALUE 
acc2 cd f4 9c			call macro_forth_dsp_value 
acc5				endm 
# End of macro FORTH_DSP_VALUE
acc5			 
acc5					if DEBUG_FORTH_WORDS 
acc5						DMARK "-2v" 
acc5 f5				push af  
acc6 3a da ac			ld a, (.dmark)  
acc9 32 71 ee			ld (debug_mark),a  
accc 3a db ac			ld a, (.dmark+1)  
accf 32 72 ee			ld (debug_mark+1),a  
acd2 3a dc ac			ld a, (.dmark+2)  
acd5 32 73 ee			ld (debug_mark+2),a  
acd8 18 03			jr .pastdmark  
acda ..			.dmark: db "-2v"  
acdd f1			.pastdmark: pop af  
acde			endm  
# End of macro DMARK
acde						CALLMONITOR 
acde cd a3 94			call break_point_state  
ace1				endm  
# End of macro CALLMONITOR
ace1					endif 
ace1			 
ace1 eb					ex de, hl 
ace2 ed 52				sbc hl, de 
ace4			 
ace4					if DEBUG_FORTH_WORDS 
ace4						DMARK "-2d" 
ace4 f5				push af  
ace5 3a f9 ac			ld a, (.dmark)  
ace8 32 71 ee			ld (debug_mark),a  
aceb 3a fa ac			ld a, (.dmark+1)  
acee 32 72 ee			ld (debug_mark+1),a  
acf1 3a fb ac			ld a, (.dmark+2)  
acf4 32 73 ee			ld (debug_mark+2),a  
acf7 18 03			jr .pastdmark  
acf9 ..			.dmark: db "-2d"  
acfc f1			.pastdmark: pop af  
acfd			endm  
# End of macro DMARK
acfd						CALLMONITOR 
acfd cd a3 94			call break_point_state  
ad00				endm  
# End of macro CALLMONITOR
ad00					endif 
ad00			 
ad00					; move result to de 
ad00			 
ad00 eb					ex de, hl 
ad01			 
ad01					; Address 
ad01			 
ad01 e1					pop hl 
ad02			 
ad02					; save it back 
ad02			 
ad02 73					ld (hl), e 
ad03 23					inc hl 
ad04 72					ld (hl), d 
ad05			 
ad05					if DEBUG_FORTH_WORDS 
ad05						DMARK "-2e" 
ad05 f5				push af  
ad06 3a 1a ad			ld a, (.dmark)  
ad09 32 71 ee			ld (debug_mark),a  
ad0c 3a 1b ad			ld a, (.dmark+1)  
ad0f 32 72 ee			ld (debug_mark+1),a  
ad12 3a 1c ad			ld a, (.dmark+2)  
ad15 32 73 ee			ld (debug_mark+2),a  
ad18 18 03			jr .pastdmark  
ad1a ..			.dmark: db "-2e"  
ad1d f1			.pastdmark: pop af  
ad1e			endm  
# End of macro DMARK
ad1e						CALLMONITOR 
ad1e cd a3 94			call break_point_state  
ad21				endm  
# End of macro CALLMONITOR
ad21					endif 
ad21			 
ad21			 
ad21			 
ad21			 
ad21			 
ad21				       NEXTW 
ad21 c3 ba 9e			jp macro_next 
ad24				endm 
# End of macro NEXTW
ad24			.GET2: 
ad24				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad24 6f				db WORD_SYS_CORE+91             
ad25 54 ad			dw .BANG2            
ad27 03				db 2 + 1 
ad28 .. 00			db "2@",0              
ad2b				endm 
# End of macro CWHEAD
ad2b			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad2b					if DEBUG_FORTH_WORDS_KEY 
ad2b						DMARK "2A_" 
ad2b f5				push af  
ad2c 3a 40 ad			ld a, (.dmark)  
ad2f 32 71 ee			ld (debug_mark),a  
ad32 3a 41 ad			ld a, (.dmark+1)  
ad35 32 72 ee			ld (debug_mark+1),a  
ad38 3a 42 ad			ld a, (.dmark+2)  
ad3b 32 73 ee			ld (debug_mark+2),a  
ad3e 18 03			jr .pastdmark  
ad40 ..			.dmark: db "2A_"  
ad43 f1			.pastdmark: pop af  
ad44			endm  
# End of macro DMARK
ad44						CALLMONITOR 
ad44 cd a3 94			call break_point_state  
ad47				endm  
# End of macro CALLMONITOR
ad47					endif 
ad47			 
ad47					FORTH_DSP_VALUEHL 
ad47 cd 0b 9d			call macro_dsp_valuehl 
ad4a				endm 
# End of macro FORTH_DSP_VALUEHL
ad4a			 
ad4a 5e					ld e, (hl) 
ad4b 23					inc hl 
ad4c 56					ld d, (hl) 
ad4d			 
ad4d eb					ex de, hl 
ad4e			 
ad4e cd 14 9b				call forth_push_numhl 
ad51			 
ad51				       NEXTW 
ad51 c3 ba 9e			jp macro_next 
ad54				endm 
# End of macro NEXTW
ad54			.BANG2: 
ad54				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad54 6f				db WORD_SYS_CORE+91             
ad55 8c ad			dw .CONFIG            
ad57 03				db 2 + 1 
ad58 .. 00			db "2!",0              
ad5b				endm 
# End of macro CWHEAD
ad5b			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad5b					if DEBUG_FORTH_WORDS_KEY 
ad5b						DMARK "2S_" 
ad5b f5				push af  
ad5c 3a 70 ad			ld a, (.dmark)  
ad5f 32 71 ee			ld (debug_mark),a  
ad62 3a 71 ad			ld a, (.dmark+1)  
ad65 32 72 ee			ld (debug_mark+1),a  
ad68 3a 72 ad			ld a, (.dmark+2)  
ad6b 32 73 ee			ld (debug_mark+2),a  
ad6e 18 03			jr .pastdmark  
ad70 ..			.dmark: db "2S_"  
ad73 f1			.pastdmark: pop af  
ad74			endm  
# End of macro DMARK
ad74						CALLMONITOR 
ad74 cd a3 94			call break_point_state  
ad77				endm  
# End of macro CALLMONITOR
ad77					endif 
ad77			 
ad77					FORTH_DSP_VALUEHL 
ad77 cd 0b 9d			call macro_dsp_valuehl 
ad7a				endm 
# End of macro FORTH_DSP_VALUEHL
ad7a			 
ad7a e5					push hl   ; save address 
ad7b			 
ad7b			 
ad7b					FORTH_DSP_POP 
ad7b cd c3 9d			call macro_forth_dsp_pop 
ad7e				endm 
# End of macro FORTH_DSP_POP
ad7e			 
ad7e					 
ad7e					FORTH_DSP_VALUEHL 
ad7e cd 0b 9d			call macro_dsp_valuehl 
ad81				endm 
# End of macro FORTH_DSP_VALUEHL
ad81			 
ad81					FORTH_DSP_POP 
ad81 cd c3 9d			call macro_forth_dsp_pop 
ad84				endm 
# End of macro FORTH_DSP_POP
ad84			 
ad84 eb					ex de, hl    ; value now in de 
ad85			 
ad85 e1					pop hl 
ad86			 
ad86 73					ld (hl), e 
ad87			 
ad87 23					inc hl 
ad88			 
ad88 72					ld (hl), d 
ad89			 
ad89			 
ad89				       NEXTW 
ad89 c3 ba 9e			jp macro_next 
ad8c				endm 
# End of macro NEXTW
ad8c			.CONFIG: 
ad8c				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ad8c 6f				db WORD_SYS_CORE+91             
ad8d 9d ad			dw .ENDCORE            
ad8f 07				db 6 + 1 
ad90 .. 00			db "CONFIG",0              
ad97				endm 
# End of macro CWHEAD
ad97			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad97			 
ad97 cd 02 93				call config 
ad9a					NEXTW 
ad9a c3 ba 9e			jp macro_next 
ad9d				endm 
# End of macro NEXTW
ad9d			.ENDCORE: 
ad9d			 
ad9d			; eof 
ad9d			 
ad9d			 
# End of file forth_words_core.asm
ad9d			include "forth_words_flow.asm" 
ad9d			 
ad9d			; | ## Program Flow Words 
ad9d			 
ad9d			.IF: 
ad9d				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ad9d 1e				db WORD_SYS_CORE+10             
ad9e 92 ae			dw .THEN            
ada0 03				db 2 + 1 
ada1 .. 00			db "IF",0              
ada4				endm 
# End of macro CWHEAD
ada4			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ada4			; 
ada4					if DEBUG_FORTH_WORDS_KEY 
ada4						DMARK "IF." 
ada4 f5				push af  
ada5 3a b9 ad			ld a, (.dmark)  
ada8 32 71 ee			ld (debug_mark),a  
adab 3a ba ad			ld a, (.dmark+1)  
adae 32 72 ee			ld (debug_mark+1),a  
adb1 3a bb ad			ld a, (.dmark+2)  
adb4 32 73 ee			ld (debug_mark+2),a  
adb7 18 03			jr .pastdmark  
adb9 ..			.dmark: db "IF."  
adbc f1			.pastdmark: pop af  
adbd			endm  
# End of macro DMARK
adbd						CALLMONITOR 
adbd cd a3 94			call break_point_state  
adc0				endm  
# End of macro CALLMONITOR
adc0					endif 
adc0			; eval TOS 
adc0			 
adc0				FORTH_DSP_VALUEHL 
adc0 cd 0b 9d			call macro_dsp_valuehl 
adc3				endm 
# End of macro FORTH_DSP_VALUEHL
adc3			 
adc3			;	push hl 
adc3				FORTH_DSP_POP 
adc3 cd c3 9d			call macro_forth_dsp_pop 
adc6				endm 
# End of macro FORTH_DSP_POP
adc6			;	pop hl 
adc6			 
adc6					if DEBUG_FORTH_WORDS 
adc6						DMARK "IF1" 
adc6 f5				push af  
adc7 3a db ad			ld a, (.dmark)  
adca 32 71 ee			ld (debug_mark),a  
adcd 3a dc ad			ld a, (.dmark+1)  
add0 32 72 ee			ld (debug_mark+1),a  
add3 3a dd ad			ld a, (.dmark+2)  
add6 32 73 ee			ld (debug_mark+2),a  
add9 18 03			jr .pastdmark  
addb ..			.dmark: db "IF1"  
adde f1			.pastdmark: pop af  
addf			endm  
# End of macro DMARK
addf						CALLMONITOR 
addf cd a3 94			call break_point_state  
ade2				endm  
# End of macro CALLMONITOR
ade2					endif 
ade2 b7				or a        ; clear carry flag 
ade3 11 00 00			ld de, 0 
ade6 eb				ex de,hl 
ade7 ed 52			sbc hl, de 
ade9 c2 73 ae			jp nz, .iftrue 
adec			 
adec					if DEBUG_FORTH_WORDS 
adec						DMARK "IF2" 
adec f5				push af  
aded 3a 01 ae			ld a, (.dmark)  
adf0 32 71 ee			ld (debug_mark),a  
adf3 3a 02 ae			ld a, (.dmark+1)  
adf6 32 72 ee			ld (debug_mark+1),a  
adf9 3a 03 ae			ld a, (.dmark+2)  
adfc 32 73 ee			ld (debug_mark+2),a  
adff 18 03			jr .pastdmark  
ae01 ..			.dmark: db "IF2"  
ae04 f1			.pastdmark: pop af  
ae05			endm  
# End of macro DMARK
ae05						CALLMONITOR 
ae05 cd a3 94			call break_point_state  
ae08				endm  
# End of macro CALLMONITOR
ae08					endif 
ae08			 
ae08			; if not true then skip to THEN 
ae08			 
ae08				; TODO get tok_ptr 
ae08				; TODO consume toks until we get to THEN 
ae08			 
ae08 2a cc e5			ld hl, (os_tok_ptr) 
ae0b					if DEBUG_FORTH_WORDS 
ae0b						DMARK "IF3" 
ae0b f5				push af  
ae0c 3a 20 ae			ld a, (.dmark)  
ae0f 32 71 ee			ld (debug_mark),a  
ae12 3a 21 ae			ld a, (.dmark+1)  
ae15 32 72 ee			ld (debug_mark+1),a  
ae18 3a 22 ae			ld a, (.dmark+2)  
ae1b 32 73 ee			ld (debug_mark+2),a  
ae1e 18 03			jr .pastdmark  
ae20 ..			.dmark: db "IF3"  
ae23 f1			.pastdmark: pop af  
ae24			endm  
# End of macro DMARK
ae24						CALLMONITOR 
ae24 cd a3 94			call break_point_state  
ae27				endm  
# End of macro CALLMONITOR
ae27						 
ae27					endif 
ae27 11 6e ae			ld de, .ifthen 
ae2a					if DEBUG_FORTH_WORDS 
ae2a						DMARK "IF4" 
ae2a f5				push af  
ae2b 3a 3f ae			ld a, (.dmark)  
ae2e 32 71 ee			ld (debug_mark),a  
ae31 3a 40 ae			ld a, (.dmark+1)  
ae34 32 72 ee			ld (debug_mark+1),a  
ae37 3a 41 ae			ld a, (.dmark+2)  
ae3a 32 73 ee			ld (debug_mark+2),a  
ae3d 18 03			jr .pastdmark  
ae3f ..			.dmark: db "IF4"  
ae42 f1			.pastdmark: pop af  
ae43			endm  
# End of macro DMARK
ae43						CALLMONITOR 
ae43 cd a3 94			call break_point_state  
ae46				endm  
# End of macro CALLMONITOR
ae46					endif 
ae46 cd d5 9f			call findnexttok  
ae49			 
ae49					if DEBUG_FORTH_WORDS 
ae49						DMARK "IF5" 
ae49 f5				push af  
ae4a 3a 5e ae			ld a, (.dmark)  
ae4d 32 71 ee			ld (debug_mark),a  
ae50 3a 5f ae			ld a, (.dmark+1)  
ae53 32 72 ee			ld (debug_mark+1),a  
ae56 3a 60 ae			ld a, (.dmark+2)  
ae59 32 73 ee			ld (debug_mark+2),a  
ae5c 18 03			jr .pastdmark  
ae5e ..			.dmark: db "IF5"  
ae61 f1			.pastdmark: pop af  
ae62			endm  
# End of macro DMARK
ae62						CALLMONITOR 
ae62 cd a3 94			call break_point_state  
ae65				endm  
# End of macro CALLMONITOR
ae65					endif 
ae65				; TODO replace below with ; exec using tok_ptr 
ae65 22 cc e5			ld (os_tok_ptr), hl 
ae68 c3 4b 9f			jp exec1 
ae6b				NEXTW 
ae6b c3 ba 9e			jp macro_next 
ae6e				endm 
# End of macro NEXTW
ae6e			 
ae6e .. 00		.ifthen:  db "THEN",0 
ae73			 
ae73			.iftrue:		 
ae73				; Exec next words normally 
ae73			 
ae73				; if true then exec following IF as normal 
ae73					if DEBUG_FORTH_WORDS 
ae73						DMARK "IFT" 
ae73 f5				push af  
ae74 3a 88 ae			ld a, (.dmark)  
ae77 32 71 ee			ld (debug_mark),a  
ae7a 3a 89 ae			ld a, (.dmark+1)  
ae7d 32 72 ee			ld (debug_mark+1),a  
ae80 3a 8a ae			ld a, (.dmark+2)  
ae83 32 73 ee			ld (debug_mark+2),a  
ae86 18 03			jr .pastdmark  
ae88 ..			.dmark: db "IFT"  
ae8b f1			.pastdmark: pop af  
ae8c			endm  
# End of macro DMARK
ae8c						CALLMONITOR 
ae8c cd a3 94			call break_point_state  
ae8f				endm  
# End of macro CALLMONITOR
ae8f					endif 
ae8f			 
ae8f					NEXTW 
ae8f c3 ba 9e			jp macro_next 
ae92				endm 
# End of macro NEXTW
ae92			.THEN: 
ae92				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae92 1f				db WORD_SYS_CORE+11             
ae93 ba ae			dw .ELSE            
ae95 05				db 4 + 1 
ae96 .. 00			db "THEN",0              
ae9b				endm 
# End of macro CWHEAD
ae9b			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ae9b					if DEBUG_FORTH_WORDS_KEY 
ae9b						DMARK "THN" 
ae9b f5				push af  
ae9c 3a b0 ae			ld a, (.dmark)  
ae9f 32 71 ee			ld (debug_mark),a  
aea2 3a b1 ae			ld a, (.dmark+1)  
aea5 32 72 ee			ld (debug_mark+1),a  
aea8 3a b2 ae			ld a, (.dmark+2)  
aeab 32 73 ee			ld (debug_mark+2),a  
aeae 18 03			jr .pastdmark  
aeb0 ..			.dmark: db "THN"  
aeb3 f1			.pastdmark: pop af  
aeb4			endm  
# End of macro DMARK
aeb4						CALLMONITOR 
aeb4 cd a3 94			call break_point_state  
aeb7				endm  
# End of macro CALLMONITOR
aeb7					endif 
aeb7					NEXTW 
aeb7 c3 ba 9e			jp macro_next 
aeba				endm 
# End of macro NEXTW
aeba			.ELSE: 
aeba				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aeba 20				db WORD_SYS_CORE+12             
aebb e2 ae			dw .DO            
aebd 03				db 2 + 1 
aebe .. 00			db "ELSE",0              
aec3				endm 
# End of macro CWHEAD
aec3			; | ELSE ( -- ) Not supported - does nothing | TODO 
aec3			 
aec3					if DEBUG_FORTH_WORDS_KEY 
aec3						DMARK "ELS" 
aec3 f5				push af  
aec4 3a d8 ae			ld a, (.dmark)  
aec7 32 71 ee			ld (debug_mark),a  
aeca 3a d9 ae			ld a, (.dmark+1)  
aecd 32 72 ee			ld (debug_mark+1),a  
aed0 3a da ae			ld a, (.dmark+2)  
aed3 32 73 ee			ld (debug_mark+2),a  
aed6 18 03			jr .pastdmark  
aed8 ..			.dmark: db "ELS"  
aedb f1			.pastdmark: pop af  
aedc			endm  
# End of macro DMARK
aedc						CALLMONITOR 
aedc cd a3 94			call break_point_state  
aedf				endm  
# End of macro CALLMONITOR
aedf					endif 
aedf			 
aedf			 
aedf					NEXTW 
aedf c3 ba 9e			jp macro_next 
aee2				endm 
# End of macro NEXTW
aee2			.DO: 
aee2				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aee2 21				db WORD_SYS_CORE+13             
aee3 09 b0			dw .LOOP            
aee5 03				db 2 + 1 
aee6 .. 00			db "DO",0              
aee9				endm 
# End of macro CWHEAD
aee9			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aee9			 
aee9					if DEBUG_FORTH_WORDS_KEY 
aee9						DMARK "DO." 
aee9 f5				push af  
aeea 3a fe ae			ld a, (.dmark)  
aeed 32 71 ee			ld (debug_mark),a  
aef0 3a ff ae			ld a, (.dmark+1)  
aef3 32 72 ee			ld (debug_mark+1),a  
aef6 3a 00 af			ld a, (.dmark+2)  
aef9 32 73 ee			ld (debug_mark+2),a  
aefc 18 03			jr .pastdmark  
aefe ..			.dmark: db "DO."  
af01 f1			.pastdmark: pop af  
af02			endm  
# End of macro DMARK
af02						CALLMONITOR 
af02 cd a3 94			call break_point_state  
af05				endm  
# End of macro CALLMONITOR
af05					endif 
af05			;  push pc to rsp stack past the DO 
af05			 
af05 2a cc e5				ld hl, (os_tok_ptr) 
af08 23					inc hl   ; D 
af09 23					inc hl  ; O 
af0a 23					inc hl   ; null 
af0b					if DEBUG_FORTH_WORDS 
af0b						DMARK "DO2" 
af0b f5				push af  
af0c 3a 20 af			ld a, (.dmark)  
af0f 32 71 ee			ld (debug_mark),a  
af12 3a 21 af			ld a, (.dmark+1)  
af15 32 72 ee			ld (debug_mark+1),a  
af18 3a 22 af			ld a, (.dmark+2)  
af1b 32 73 ee			ld (debug_mark+2),a  
af1e 18 03			jr .pastdmark  
af20 ..			.dmark: db "DO2"  
af23 f1			.pastdmark: pop af  
af24			endm  
# End of macro DMARK
af24						CALLMONITOR 
af24 cd a3 94			call break_point_state  
af27				endm  
# End of macro CALLMONITOR
af27					endif 
af27					FORTH_RSP_NEXT 
af27 cd bb 9a			call macro_forth_rsp_next 
af2a				endm 
# End of macro FORTH_RSP_NEXT
af2a					if DEBUG_FORTH_WORDS 
af2a						DMARK "DO3" 
af2a f5				push af  
af2b 3a 3f af			ld a, (.dmark)  
af2e 32 71 ee			ld (debug_mark),a  
af31 3a 40 af			ld a, (.dmark+1)  
af34 32 72 ee			ld (debug_mark+1),a  
af37 3a 41 af			ld a, (.dmark+2)  
af3a 32 73 ee			ld (debug_mark+2),a  
af3d 18 03			jr .pastdmark  
af3f ..			.dmark: db "DO3"  
af42 f1			.pastdmark: pop af  
af43			endm  
# End of macro DMARK
af43						CALLMONITOR 
af43 cd a3 94			call break_point_state  
af46				endm  
# End of macro CALLMONITOR
af46					endif 
af46			 
af46					;if DEBUG_FORTH_WORDS 
af46				;		push hl 
af46			;		endif  
af46			 
af46			; get counters from data stack 
af46			 
af46			 
af46					FORTH_DSP_VALUEHL 
af46 cd 0b 9d			call macro_dsp_valuehl 
af49				endm 
# End of macro FORTH_DSP_VALUEHL
af49 e5					push hl		 ; hl now has starting counter which needs to be tos 
af4a			 
af4a					if DEBUG_FORTH_WORDS 
af4a						DMARK "DO4" 
af4a f5				push af  
af4b 3a 5f af			ld a, (.dmark)  
af4e 32 71 ee			ld (debug_mark),a  
af51 3a 60 af			ld a, (.dmark+1)  
af54 32 72 ee			ld (debug_mark+1),a  
af57 3a 61 af			ld a, (.dmark+2)  
af5a 32 73 ee			ld (debug_mark+2),a  
af5d 18 03			jr .pastdmark  
af5f ..			.dmark: db "DO4"  
af62 f1			.pastdmark: pop af  
af63			endm  
# End of macro DMARK
af63						CALLMONITOR 
af63 cd a3 94			call break_point_state  
af66				endm  
# End of macro CALLMONITOR
af66					endif 
af66					FORTH_DSP_POP 
af66 cd c3 9d			call macro_forth_dsp_pop 
af69				endm 
# End of macro FORTH_DSP_POP
af69			 
af69					if DEBUG_FORTH_WORDS 
af69						DMARK "DO5" 
af69 f5				push af  
af6a 3a 7e af			ld a, (.dmark)  
af6d 32 71 ee			ld (debug_mark),a  
af70 3a 7f af			ld a, (.dmark+1)  
af73 32 72 ee			ld (debug_mark+1),a  
af76 3a 80 af			ld a, (.dmark+2)  
af79 32 73 ee			ld (debug_mark+2),a  
af7c 18 03			jr .pastdmark  
af7e ..			.dmark: db "DO5"  
af81 f1			.pastdmark: pop af  
af82			endm  
# End of macro DMARK
af82						CALLMONITOR 
af82 cd a3 94			call break_point_state  
af85				endm  
# End of macro CALLMONITOR
af85					endif 
af85			 
af85					FORTH_DSP_VALUEHL 
af85 cd 0b 9d			call macro_dsp_valuehl 
af88				endm 
# End of macro FORTH_DSP_VALUEHL
af88			;		push hl		 ; hl now has starting limit counter 
af88			 
af88					if DEBUG_FORTH_WORDS 
af88						DMARK "DO6" 
af88 f5				push af  
af89 3a 9d af			ld a, (.dmark)  
af8c 32 71 ee			ld (debug_mark),a  
af8f 3a 9e af			ld a, (.dmark+1)  
af92 32 72 ee			ld (debug_mark+1),a  
af95 3a 9f af			ld a, (.dmark+2)  
af98 32 73 ee			ld (debug_mark+2),a  
af9b 18 03			jr .pastdmark  
af9d ..			.dmark: db "DO6"  
afa0 f1			.pastdmark: pop af  
afa1			endm  
# End of macro DMARK
afa1						CALLMONITOR 
afa1 cd a3 94			call break_point_state  
afa4				endm  
# End of macro CALLMONITOR
afa4					endif 
afa4					FORTH_DSP_POP 
afa4 cd c3 9d			call macro_forth_dsp_pop 
afa7				endm 
# End of macro FORTH_DSP_POP
afa7			 
afa7			; put counters on the loop stack 
afa7			 
afa7			;		pop hl			 ; limit counter 
afa7 d1					pop de			; start counter 
afa8			 
afa8					; push limit counter 
afa8			 
afa8					if DEBUG_FORTH_WORDS 
afa8						DMARK "DO7" 
afa8 f5				push af  
afa9 3a bd af			ld a, (.dmark)  
afac 32 71 ee			ld (debug_mark),a  
afaf 3a be af			ld a, (.dmark+1)  
afb2 32 72 ee			ld (debug_mark+1),a  
afb5 3a bf af			ld a, (.dmark+2)  
afb8 32 73 ee			ld (debug_mark+2),a  
afbb 18 03			jr .pastdmark  
afbd ..			.dmark: db "DO7"  
afc0 f1			.pastdmark: pop af  
afc1			endm  
# End of macro DMARK
afc1						CALLMONITOR 
afc1 cd a3 94			call break_point_state  
afc4				endm  
# End of macro CALLMONITOR
afc4					endif 
afc4					FORTH_LOOP_NEXT 
afc4 cd 3c 9d			call macro_forth_loop_next 
afc7				endm 
# End of macro FORTH_LOOP_NEXT
afc7			 
afc7					; push start counter 
afc7			 
afc7 eb					ex de, hl 
afc8					if DEBUG_FORTH_WORDS 
afc8						DMARK "DO7" 
afc8 f5				push af  
afc9 3a dd af			ld a, (.dmark)  
afcc 32 71 ee			ld (debug_mark),a  
afcf 3a de af			ld a, (.dmark+1)  
afd2 32 72 ee			ld (debug_mark+1),a  
afd5 3a df af			ld a, (.dmark+2)  
afd8 32 73 ee			ld (debug_mark+2),a  
afdb 18 03			jr .pastdmark  
afdd ..			.dmark: db "DO7"  
afe0 f1			.pastdmark: pop af  
afe1			endm  
# End of macro DMARK
afe1						CALLMONITOR 
afe1 cd a3 94			call break_point_state  
afe4				endm  
# End of macro CALLMONITOR
afe4					endif 
afe4					FORTH_LOOP_NEXT 
afe4 cd 3c 9d			call macro_forth_loop_next 
afe7				endm 
# End of macro FORTH_LOOP_NEXT
afe7			 
afe7			 
afe7					; init first round of I counter 
afe7			 
afe7 22 f0 e5				ld (os_current_i), hl 
afea			 
afea					if DEBUG_FORTH_WORDS 
afea						DMARK "DO8" 
afea f5				push af  
afeb 3a ff af			ld a, (.dmark)  
afee 32 71 ee			ld (debug_mark),a  
aff1 3a 00 b0			ld a, (.dmark+1)  
aff4 32 72 ee			ld (debug_mark+1),a  
aff7 3a 01 b0			ld a, (.dmark+2)  
affa 32 73 ee			ld (debug_mark+2),a  
affd 18 03			jr .pastdmark  
afff ..			.dmark: db "DO8"  
b002 f1			.pastdmark: pop af  
b003			endm  
# End of macro DMARK
b003						CALLMONITOR 
b003 cd a3 94			call break_point_state  
b006				endm  
# End of macro CALLMONITOR
b006					endif 
b006			 
b006					NEXTW 
b006 c3 ba 9e			jp macro_next 
b009				endm 
# End of macro NEXTW
b009			.LOOP: 
b009				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b009 22				db WORD_SYS_CORE+14             
b00a 21 b1			dw .I            
b00c 05				db 4 + 1 
b00d .. 00			db "LOOP",0              
b012				endm 
# End of macro CWHEAD
b012			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b012			 
b012				; pop tos as current loop count to hl 
b012			 
b012				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b012			 
b012				FORTH_LOOP_TOS 
b012 cd 6f 9d			call macro_forth_loop_tos 
b015				endm 
# End of macro FORTH_LOOP_TOS
b015 e5				push hl 
b016			 
b016					if DEBUG_FORTH_WORDS_KEY 
b016						DMARK "LOP" 
b016 f5				push af  
b017 3a 2b b0			ld a, (.dmark)  
b01a 32 71 ee			ld (debug_mark),a  
b01d 3a 2c b0			ld a, (.dmark+1)  
b020 32 72 ee			ld (debug_mark+1),a  
b023 3a 2d b0			ld a, (.dmark+2)  
b026 32 73 ee			ld (debug_mark+2),a  
b029 18 03			jr .pastdmark  
b02b ..			.dmark: db "LOP"  
b02e f1			.pastdmark: pop af  
b02f			endm  
# End of macro DMARK
b02f						CALLMONITOR 
b02f cd a3 94			call break_point_state  
b032				endm  
# End of macro CALLMONITOR
b032					endif 
b032				; next item on the stack is the limit. get it 
b032			 
b032			 
b032				FORTH_LOOP_POP 
b032 cd 79 9d			call macro_forth_loop_pop 
b035				endm 
# End of macro FORTH_LOOP_POP
b035			 
b035				FORTH_LOOP_TOS 
b035 cd 6f 9d			call macro_forth_loop_tos 
b038				endm 
# End of macro FORTH_LOOP_TOS
b038			 
b038 d1				pop de		 ; de = i, hl = limit 
b039			 
b039					if DEBUG_FORTH_WORDS 
b039						DMARK "LP1" 
b039 f5				push af  
b03a 3a 4e b0			ld a, (.dmark)  
b03d 32 71 ee			ld (debug_mark),a  
b040 3a 4f b0			ld a, (.dmark+1)  
b043 32 72 ee			ld (debug_mark+1),a  
b046 3a 50 b0			ld a, (.dmark+2)  
b049 32 73 ee			ld (debug_mark+2),a  
b04c 18 03			jr .pastdmark  
b04e ..			.dmark: db "LP1"  
b051 f1			.pastdmark: pop af  
b052			endm  
# End of macro DMARK
b052						CALLMONITOR 
b052 cd a3 94			call break_point_state  
b055				endm  
# End of macro CALLMONITOR
b055					endif 
b055			 
b055				; go back to previous word 
b055			 
b055 d5				push de    ; save I for inc later 
b056			 
b056			 
b056				; get limit 
b056				;  is I at limit? 
b056			 
b056			 
b056					if DEBUG_FORTH_WORDS 
b056						DMARK "LP1" 
b056 f5				push af  
b057 3a 6b b0			ld a, (.dmark)  
b05a 32 71 ee			ld (debug_mark),a  
b05d 3a 6c b0			ld a, (.dmark+1)  
b060 32 72 ee			ld (debug_mark+1),a  
b063 3a 6d b0			ld a, (.dmark+2)  
b066 32 73 ee			ld (debug_mark+2),a  
b069 18 03			jr .pastdmark  
b06b ..			.dmark: db "LP1"  
b06e f1			.pastdmark: pop af  
b06f			endm  
# End of macro DMARK
b06f						CALLMONITOR 
b06f cd a3 94			call break_point_state  
b072				endm  
# End of macro CALLMONITOR
b072					endif 
b072			 
b072 ed 52			sbc hl, de 
b074			 
b074			 
b074				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b074			 
b074 20 26				jr nz, .loopnotdone 
b076			 
b076 e1				pop hl   ; get rid of saved I 
b077				FORTH_LOOP_POP     ; get rid of limit 
b077 cd 79 9d			call macro_forth_loop_pop 
b07a				endm 
# End of macro FORTH_LOOP_POP
b07a			 
b07a				FORTH_RSP_POP     ; get rid of DO ptr 
b07a cd dc 9a			call macro_forth_rsp_pop 
b07d				endm 
# End of macro FORTH_RSP_POP
b07d			 
b07d			if DEBUG_FORTH_WORDS 
b07d						DMARK "LP>" 
b07d f5				push af  
b07e 3a 92 b0			ld a, (.dmark)  
b081 32 71 ee			ld (debug_mark),a  
b084 3a 93 b0			ld a, (.dmark+1)  
b087 32 72 ee			ld (debug_mark+1),a  
b08a 3a 94 b0			ld a, (.dmark+2)  
b08d 32 73 ee			ld (debug_mark+2),a  
b090 18 03			jr .pastdmark  
b092 ..			.dmark: db "LP>"  
b095 f1			.pastdmark: pop af  
b096			endm  
# End of macro DMARK
b096				CALLMONITOR 
b096 cd a3 94			call break_point_state  
b099				endm  
# End of macro CALLMONITOR
b099			endif 
b099			 
b099					NEXTW 
b099 c3 ba 9e			jp macro_next 
b09c				endm 
# End of macro NEXTW
b09c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b09c			 
b09c			.loopnotdone: 
b09c			 
b09c e1				pop hl    ; get I 
b09d 23				inc hl 
b09e			 
b09e			   	; save new I 
b09e			 
b09e			 
b09e					; set I counter 
b09e			 
b09e 22 f0 e5				ld (os_current_i), hl 
b0a1			 
b0a1					if DEBUG_FORTH_WORDS 
b0a1						DMARK "LPN" 
b0a1 f5				push af  
b0a2 3a b6 b0			ld a, (.dmark)  
b0a5 32 71 ee			ld (debug_mark),a  
b0a8 3a b7 b0			ld a, (.dmark+1)  
b0ab 32 72 ee			ld (debug_mark+1),a  
b0ae 3a b8 b0			ld a, (.dmark+2)  
b0b1 32 73 ee			ld (debug_mark+2),a  
b0b4 18 03			jr .pastdmark  
b0b6 ..			.dmark: db "LPN"  
b0b9 f1			.pastdmark: pop af  
b0ba			endm  
# End of macro DMARK
b0ba					CALLMONITOR 
b0ba cd a3 94			call break_point_state  
b0bd				endm  
# End of macro CALLMONITOR
b0bd					endif 
b0bd					 
b0bd				FORTH_LOOP_NEXT 
b0bd cd 3c 9d			call macro_forth_loop_next 
b0c0				endm 
# End of macro FORTH_LOOP_NEXT
b0c0			 
b0c0			 
b0c0					if DEBUG_FORTH_WORDS 
b0c0 eb						ex de,hl 
b0c1					endif 
b0c1			 
b0c1			;	; get DO ptr 
b0c1			; 
b0c1					if DEBUG_FORTH_WORDS 
b0c1						DMARK "LP7" 
b0c1 f5				push af  
b0c2 3a d6 b0			ld a, (.dmark)  
b0c5 32 71 ee			ld (debug_mark),a  
b0c8 3a d7 b0			ld a, (.dmark+1)  
b0cb 32 72 ee			ld (debug_mark+1),a  
b0ce 3a d8 b0			ld a, (.dmark+2)  
b0d1 32 73 ee			ld (debug_mark+2),a  
b0d4 18 03			jr .pastdmark  
b0d6 ..			.dmark: db "LP7"  
b0d9 f1			.pastdmark: pop af  
b0da			endm  
# End of macro DMARK
b0da					CALLMONITOR 
b0da cd a3 94			call break_point_state  
b0dd				endm  
# End of macro CALLMONITOR
b0dd					endif 
b0dd				FORTH_RSP_TOS 
b0dd cd d2 9a			call macro_forth_rsp_tos 
b0e0				endm 
# End of macro FORTH_RSP_TOS
b0e0			 
b0e0					if DEBUG_FORTH_WORDS 
b0e0						DMARK "LP8" 
b0e0 f5				push af  
b0e1 3a f5 b0			ld a, (.dmark)  
b0e4 32 71 ee			ld (debug_mark),a  
b0e7 3a f6 b0			ld a, (.dmark+1)  
b0ea 32 72 ee			ld (debug_mark+1),a  
b0ed 3a f7 b0			ld a, (.dmark+2)  
b0f0 32 73 ee			ld (debug_mark+2),a  
b0f3 18 03			jr .pastdmark  
b0f5 ..			.dmark: db "LP8"  
b0f8 f1			.pastdmark: pop af  
b0f9			endm  
# End of macro DMARK
b0f9					CALLMONITOR 
b0f9 cd a3 94			call break_point_state  
b0fc				endm  
# End of macro CALLMONITOR
b0fc					endif 
b0fc				;push hl 
b0fc			 
b0fc				; not going to DO any more 
b0fc				; get rid of the RSP pointer as DO will add it back in 
b0fc				;FORTH_RSP_POP 
b0fc				;pop hl 
b0fc			 
b0fc				;ld hl,(cli_ret_sp) 
b0fc				;ld e, (hl) 
b0fc				;inc hl 
b0fc				;ld d, (hl) 
b0fc				;ex de,hl 
b0fc 22 cc e5			ld (os_tok_ptr), hl 
b0ff					if DEBUG_FORTH_WORDS 
b0ff						DMARK "LP<" 
b0ff f5				push af  
b100 3a 14 b1			ld a, (.dmark)  
b103 32 71 ee			ld (debug_mark),a  
b106 3a 15 b1			ld a, (.dmark+1)  
b109 32 72 ee			ld (debug_mark+1),a  
b10c 3a 16 b1			ld a, (.dmark+2)  
b10f 32 73 ee			ld (debug_mark+2),a  
b112 18 03			jr .pastdmark  
b114 ..			.dmark: db "LP<"  
b117 f1			.pastdmark: pop af  
b118			endm  
# End of macro DMARK
b118					CALLMONITOR 
b118 cd a3 94			call break_point_state  
b11b				endm  
# End of macro CALLMONITOR
b11b				endif 
b11b c3 4b 9f			jp exec1 
b11e			 
b11e					 
b11e			 
b11e			 
b11e					NEXTW 
b11e c3 ba 9e			jp macro_next 
b121				endm 
# End of macro NEXTW
b121			.I:  
b121			 
b121				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b121 5e				db WORD_SYS_CORE+74             
b122 4c b1			dw .DLOOP            
b124 02				db 1 + 1 
b125 .. 00			db "I",0              
b127				endm 
# End of macro CWHEAD
b127			; | I ( -- ) Current loop counter | DONE 
b127					if DEBUG_FORTH_WORDS_KEY 
b127						DMARK "I.." 
b127 f5				push af  
b128 3a 3c b1			ld a, (.dmark)  
b12b 32 71 ee			ld (debug_mark),a  
b12e 3a 3d b1			ld a, (.dmark+1)  
b131 32 72 ee			ld (debug_mark+1),a  
b134 3a 3e b1			ld a, (.dmark+2)  
b137 32 73 ee			ld (debug_mark+2),a  
b13a 18 03			jr .pastdmark  
b13c ..			.dmark: db "I.."  
b13f f1			.pastdmark: pop af  
b140			endm  
# End of macro DMARK
b140						CALLMONITOR 
b140 cd a3 94			call break_point_state  
b143				endm  
# End of macro CALLMONITOR
b143					endif 
b143			 
b143 2a f0 e5				ld hl,(os_current_i) 
b146 cd 14 9b				call forth_push_numhl 
b149			 
b149					NEXTW 
b149 c3 ba 9e			jp macro_next 
b14c				endm 
# End of macro NEXTW
b14c			.DLOOP: 
b14c				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b14c 5f				db WORD_SYS_CORE+75             
b14d 2d b2			dw .REPEAT            
b14f 06				db 5 + 1 
b150 .. 00			db "-LOOP",0              
b156				endm 
# End of macro CWHEAD
b156			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b156				; pop tos as current loop count to hl 
b156					if DEBUG_FORTH_WORDS_KEY 
b156						DMARK "-LP" 
b156 f5				push af  
b157 3a 6b b1			ld a, (.dmark)  
b15a 32 71 ee			ld (debug_mark),a  
b15d 3a 6c b1			ld a, (.dmark+1)  
b160 32 72 ee			ld (debug_mark+1),a  
b163 3a 6d b1			ld a, (.dmark+2)  
b166 32 73 ee			ld (debug_mark+2),a  
b169 18 03			jr .pastdmark  
b16b ..			.dmark: db "-LP"  
b16e f1			.pastdmark: pop af  
b16f			endm  
# End of macro DMARK
b16f						CALLMONITOR 
b16f cd a3 94			call break_point_state  
b172				endm  
# End of macro CALLMONITOR
b172					endif 
b172			 
b172				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b172			 
b172				FORTH_LOOP_TOS 
b172 cd 6f 9d			call macro_forth_loop_tos 
b175				endm 
# End of macro FORTH_LOOP_TOS
b175 e5				push hl 
b176			 
b176					if DEBUG_FORTH_WORDS 
b176						DMARK "-LP" 
b176 f5				push af  
b177 3a 8b b1			ld a, (.dmark)  
b17a 32 71 ee			ld (debug_mark),a  
b17d 3a 8c b1			ld a, (.dmark+1)  
b180 32 72 ee			ld (debug_mark+1),a  
b183 3a 8d b1			ld a, (.dmark+2)  
b186 32 73 ee			ld (debug_mark+2),a  
b189 18 03			jr .pastdmark  
b18b ..			.dmark: db "-LP"  
b18e f1			.pastdmark: pop af  
b18f			endm  
# End of macro DMARK
b18f						CALLMONITOR 
b18f cd a3 94			call break_point_state  
b192				endm  
# End of macro CALLMONITOR
b192					endif 
b192				; next item on the stack is the limit. get it 
b192			 
b192			 
b192				FORTH_LOOP_POP 
b192 cd 79 9d			call macro_forth_loop_pop 
b195				endm 
# End of macro FORTH_LOOP_POP
b195			 
b195				FORTH_LOOP_TOS 
b195 cd 6f 9d			call macro_forth_loop_tos 
b198				endm 
# End of macro FORTH_LOOP_TOS
b198			 
b198 d1				pop de		 ; de = i, hl = limit 
b199			 
b199					if DEBUG_FORTH_WORDS 
b199						DMARK "-L1" 
b199 f5				push af  
b19a 3a ae b1			ld a, (.dmark)  
b19d 32 71 ee			ld (debug_mark),a  
b1a0 3a af b1			ld a, (.dmark+1)  
b1a3 32 72 ee			ld (debug_mark+1),a  
b1a6 3a b0 b1			ld a, (.dmark+2)  
b1a9 32 73 ee			ld (debug_mark+2),a  
b1ac 18 03			jr .pastdmark  
b1ae ..			.dmark: db "-L1"  
b1b1 f1			.pastdmark: pop af  
b1b2			endm  
# End of macro DMARK
b1b2						CALLMONITOR 
b1b2 cd a3 94			call break_point_state  
b1b5				endm  
# End of macro CALLMONITOR
b1b5					endif 
b1b5			 
b1b5				; go back to previous word 
b1b5			 
b1b5 d5				push de    ; save I for inc later 
b1b6			 
b1b6			 
b1b6				; get limit 
b1b6				;  is I at limit? 
b1b6			 
b1b6			 
b1b6					if DEBUG_FORTH_WORDS 
b1b6						DMARK "-L1" 
b1b6 f5				push af  
b1b7 3a cb b1			ld a, (.dmark)  
b1ba 32 71 ee			ld (debug_mark),a  
b1bd 3a cc b1			ld a, (.dmark+1)  
b1c0 32 72 ee			ld (debug_mark+1),a  
b1c3 3a cd b1			ld a, (.dmark+2)  
b1c6 32 73 ee			ld (debug_mark+2),a  
b1c9 18 03			jr .pastdmark  
b1cb ..			.dmark: db "-L1"  
b1ce f1			.pastdmark: pop af  
b1cf			endm  
# End of macro DMARK
b1cf						CALLMONITOR 
b1cf cd a3 94			call break_point_state  
b1d2				endm  
# End of macro CALLMONITOR
b1d2					endif 
b1d2			 
b1d2 ed 52			sbc hl, de 
b1d4			 
b1d4			 
b1d4				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b1d4			 
b1d4 20 26				jr nz, .mloopnotdone 
b1d6			 
b1d6 e1				pop hl   ; get rid of saved I 
b1d7				FORTH_LOOP_POP     ; get rid of limit 
b1d7 cd 79 9d			call macro_forth_loop_pop 
b1da				endm 
# End of macro FORTH_LOOP_POP
b1da			 
b1da				FORTH_RSP_POP     ; get rid of DO ptr 
b1da cd dc 9a			call macro_forth_rsp_pop 
b1dd				endm 
# End of macro FORTH_RSP_POP
b1dd			 
b1dd			if DEBUG_FORTH_WORDS 
b1dd						DMARK "-L>" 
b1dd f5				push af  
b1de 3a f2 b1			ld a, (.dmark)  
b1e1 32 71 ee			ld (debug_mark),a  
b1e4 3a f3 b1			ld a, (.dmark+1)  
b1e7 32 72 ee			ld (debug_mark+1),a  
b1ea 3a f4 b1			ld a, (.dmark+2)  
b1ed 32 73 ee			ld (debug_mark+2),a  
b1f0 18 03			jr .pastdmark  
b1f2 ..			.dmark: db "-L>"  
b1f5 f1			.pastdmark: pop af  
b1f6			endm  
# End of macro DMARK
b1f6				CALLMONITOR 
b1f6 cd a3 94			call break_point_state  
b1f9				endm  
# End of macro CALLMONITOR
b1f9			endif 
b1f9			 
b1f9					NEXTW 
b1f9 c3 ba 9e			jp macro_next 
b1fc				endm 
# End of macro NEXTW
b1fc				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b1fc			 
b1fc			.mloopnotdone: 
b1fc			 
b1fc e1				pop hl    ; get I 
b1fd 2b				dec hl 
b1fe			 
b1fe			   	; save new I 
b1fe			 
b1fe			 
b1fe					; set I counter 
b1fe			 
b1fe 22 f0 e5				ld (os_current_i), hl 
b201			 
b201					 
b201				FORTH_LOOP_NEXT 
b201 cd 3c 9d			call macro_forth_loop_next 
b204				endm 
# End of macro FORTH_LOOP_NEXT
b204			 
b204			 
b204					if DEBUG_FORTH_WORDS 
b204 eb						ex de,hl 
b205					endif 
b205			 
b205			;	; get DO ptr 
b205			; 
b205				FORTH_RSP_TOS 
b205 cd d2 9a			call macro_forth_rsp_tos 
b208				endm 
# End of macro FORTH_RSP_TOS
b208			 
b208				;push hl 
b208			 
b208				; not going to DO any more 
b208				; get rid of the RSP pointer as DO will add it back in 
b208				;FORTH_RSP_POP 
b208				;pop hl 
b208			 
b208			 
b208 22 cc e5			ld (os_tok_ptr), hl 
b20b					if DEBUG_FORTH_WORDS 
b20b						DMARK "-L<" 
b20b f5				push af  
b20c 3a 20 b2			ld a, (.dmark)  
b20f 32 71 ee			ld (debug_mark),a  
b212 3a 21 b2			ld a, (.dmark+1)  
b215 32 72 ee			ld (debug_mark+1),a  
b218 3a 22 b2			ld a, (.dmark+2)  
b21b 32 73 ee			ld (debug_mark+2),a  
b21e 18 03			jr .pastdmark  
b220 ..			.dmark: db "-L<"  
b223 f1			.pastdmark: pop af  
b224			endm  
# End of macro DMARK
b224					CALLMONITOR 
b224 cd a3 94			call break_point_state  
b227				endm  
# End of macro CALLMONITOR
b227				endif 
b227 c3 4b 9f			jp exec1 
b22a			 
b22a					 
b22a			 
b22a			 
b22a			 
b22a				NEXTW 
b22a c3 ba 9e			jp macro_next 
b22d				endm 
# End of macro NEXTW
b22d			 
b22d			 
b22d			 
b22d			 
b22d			.REPEAT: 
b22d				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b22d 71				db WORD_SYS_CORE+93             
b22e 80 b2			dw .UNTIL            
b230 06				db 5 + 1 
b231 .. 00			db "REPEAT",0              
b238				endm 
# End of macro CWHEAD
b238			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b238			;  push pc to rsp stack past the REPEAT 
b238					if DEBUG_FORTH_WORDS_KEY 
b238						DMARK "REP" 
b238 f5				push af  
b239 3a 4d b2			ld a, (.dmark)  
b23c 32 71 ee			ld (debug_mark),a  
b23f 3a 4e b2			ld a, (.dmark+1)  
b242 32 72 ee			ld (debug_mark+1),a  
b245 3a 4f b2			ld a, (.dmark+2)  
b248 32 73 ee			ld (debug_mark+2),a  
b24b 18 03			jr .pastdmark  
b24d ..			.dmark: db "REP"  
b250 f1			.pastdmark: pop af  
b251			endm  
# End of macro DMARK
b251						CALLMONITOR 
b251 cd a3 94			call break_point_state  
b254				endm  
# End of macro CALLMONITOR
b254					endif 
b254			 
b254 2a cc e5				ld hl, (os_tok_ptr) 
b257 23					inc hl   ; R 
b258 23					inc hl  ; E 
b259 23					inc hl   ; P 
b25a 23					inc hl   ; E 
b25b 23					inc hl   ; A 
b25c 23					inc hl   ; T 
b25d 23					inc hl   ; zero 
b25e					FORTH_RSP_NEXT 
b25e cd bb 9a			call macro_forth_rsp_next 
b261				endm 
# End of macro FORTH_RSP_NEXT
b261			 
b261			 
b261					if DEBUG_FORTH_WORDS 
b261						DMARK "REP" 
b261 f5				push af  
b262 3a 76 b2			ld a, (.dmark)  
b265 32 71 ee			ld (debug_mark),a  
b268 3a 77 b2			ld a, (.dmark+1)  
b26b 32 72 ee			ld (debug_mark+1),a  
b26e 3a 78 b2			ld a, (.dmark+2)  
b271 32 73 ee			ld (debug_mark+2),a  
b274 18 03			jr .pastdmark  
b276 ..			.dmark: db "REP"  
b279 f1			.pastdmark: pop af  
b27a			endm  
# End of macro DMARK
b27a						;pop bc    ; TODO BUG ?????? what is this for???? 
b27a						CALLMONITOR 
b27a cd a3 94			call break_point_state  
b27d				endm  
# End of macro CALLMONITOR
b27d					endif 
b27d			 
b27d					NEXTW 
b27d c3 ba 9e			jp macro_next 
b280				endm 
# End of macro NEXTW
b280			;	       NEXTW 
b280			 
b280			.UNTIL: 
b280				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b280 72				db WORD_SYS_CORE+94             
b281 17 b3			dw .ENDFLOW            
b283 06				db 5 + 1 
b284 .. 00			db "UNTIL",0              
b28a				endm 
# End of macro CWHEAD
b28a			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b28a			 
b28a				; pop tos as check 
b28a			 
b28a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b28a			 
b28a				FORTH_DSP_VALUEHL 
b28a cd 0b 9d			call macro_dsp_valuehl 
b28d				endm 
# End of macro FORTH_DSP_VALUEHL
b28d			 
b28d					if DEBUG_FORTH_WORDS_KEY 
b28d						DMARK "UNT" 
b28d f5				push af  
b28e 3a a2 b2			ld a, (.dmark)  
b291 32 71 ee			ld (debug_mark),a  
b294 3a a3 b2			ld a, (.dmark+1)  
b297 32 72 ee			ld (debug_mark+1),a  
b29a 3a a4 b2			ld a, (.dmark+2)  
b29d 32 73 ee			ld (debug_mark+2),a  
b2a0 18 03			jr .pastdmark  
b2a2 ..			.dmark: db "UNT"  
b2a5 f1			.pastdmark: pop af  
b2a6			endm  
# End of macro DMARK
b2a6						CALLMONITOR 
b2a6 cd a3 94			call break_point_state  
b2a9				endm  
# End of macro CALLMONITOR
b2a9					endif 
b2a9			 
b2a9			;	push hl 
b2a9				FORTH_DSP_POP 
b2a9 cd c3 9d			call macro_forth_dsp_pop 
b2ac				endm 
# End of macro FORTH_DSP_POP
b2ac			 
b2ac			;	pop hl 
b2ac			 
b2ac				; test if true 
b2ac			 
b2ac cd cb 8c			call ishlzero 
b2af			;	ld a,l 
b2af			;	add h 
b2af			; 
b2af			;	cp 0 
b2af			 
b2af 20 3e			jr nz, .untilnotdone 
b2b1			 
b2b1					if DEBUG_FORTH_WORDS 
b2b1						DMARK "UNf" 
b2b1 f5				push af  
b2b2 3a c6 b2			ld a, (.dmark)  
b2b5 32 71 ee			ld (debug_mark),a  
b2b8 3a c7 b2			ld a, (.dmark+1)  
b2bb 32 72 ee			ld (debug_mark+1),a  
b2be 3a c8 b2			ld a, (.dmark+2)  
b2c1 32 73 ee			ld (debug_mark+2),a  
b2c4 18 03			jr .pastdmark  
b2c6 ..			.dmark: db "UNf"  
b2c9 f1			.pastdmark: pop af  
b2ca			endm  
# End of macro DMARK
b2ca						CALLMONITOR 
b2ca cd a3 94			call break_point_state  
b2cd				endm  
# End of macro CALLMONITOR
b2cd					endif 
b2cd			 
b2cd			 
b2cd			 
b2cd				FORTH_RSP_POP     ; get rid of DO ptr 
b2cd cd dc 9a			call macro_forth_rsp_pop 
b2d0				endm 
# End of macro FORTH_RSP_POP
b2d0			 
b2d0			if DEBUG_FORTH_WORDS 
b2d0						DMARK "UN>" 
b2d0 f5				push af  
b2d1 3a e5 b2			ld a, (.dmark)  
b2d4 32 71 ee			ld (debug_mark),a  
b2d7 3a e6 b2			ld a, (.dmark+1)  
b2da 32 72 ee			ld (debug_mark+1),a  
b2dd 3a e7 b2			ld a, (.dmark+2)  
b2e0 32 73 ee			ld (debug_mark+2),a  
b2e3 18 03			jr .pastdmark  
b2e5 ..			.dmark: db "UN>"  
b2e8 f1			.pastdmark: pop af  
b2e9			endm  
# End of macro DMARK
b2e9				CALLMONITOR 
b2e9 cd a3 94			call break_point_state  
b2ec				endm  
# End of macro CALLMONITOR
b2ec			endif 
b2ec			 
b2ec					NEXTW 
b2ec c3 ba 9e			jp macro_next 
b2ef				endm 
# End of macro NEXTW
b2ef				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2ef			 
b2ef			.untilnotdone: 
b2ef			 
b2ef			 
b2ef			;	; get DO ptr 
b2ef			; 
b2ef				FORTH_RSP_TOS 
b2ef cd d2 9a			call macro_forth_rsp_tos 
b2f2				endm 
# End of macro FORTH_RSP_TOS
b2f2			 
b2f2				;push hl 
b2f2			 
b2f2				; not going to DO any more 
b2f2				; get rid of the RSP pointer as DO will add it back in 
b2f2				;FORTH_RSP_POP 
b2f2				;pop hl 
b2f2			 
b2f2			 
b2f2 22 cc e5			ld (os_tok_ptr), hl 
b2f5					if DEBUG_FORTH_WORDS 
b2f5						DMARK "UN<" 
b2f5 f5				push af  
b2f6 3a 0a b3			ld a, (.dmark)  
b2f9 32 71 ee			ld (debug_mark),a  
b2fc 3a 0b b3			ld a, (.dmark+1)  
b2ff 32 72 ee			ld (debug_mark+1),a  
b302 3a 0c b3			ld a, (.dmark+2)  
b305 32 73 ee			ld (debug_mark+2),a  
b308 18 03			jr .pastdmark  
b30a ..			.dmark: db "UN<"  
b30d f1			.pastdmark: pop af  
b30e			endm  
# End of macro DMARK
b30e					CALLMONITOR 
b30e cd a3 94			call break_point_state  
b311				endm  
# End of macro CALLMONITOR
b311				endif 
b311 c3 4b 9f			jp exec1 
b314			 
b314					 
b314			 
b314			 
b314					NEXTW 
b314 c3 ba 9e			jp macro_next 
b317				endm 
# End of macro NEXTW
b317			 
b317			 
b317			.ENDFLOW: 
b317			 
b317			; eof 
b317			 
# End of file forth_words_flow.asm
b317			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b317			include "forth_words_logic.asm" 
b317			 
b317			; | ## Logic Words 
b317			 
b317			.NOT: 
b317				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b317 2d				db WORD_SYS_CORE+25             
b318 5f b3			dw .IS            
b31a 04				db 3 + 1 
b31b .. 00			db "NOT",0              
b31f				endm 
# End of macro CWHEAD
b31f			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b31f					if DEBUG_FORTH_WORDS_KEY 
b31f						DMARK "NOT" 
b31f f5				push af  
b320 3a 34 b3			ld a, (.dmark)  
b323 32 71 ee			ld (debug_mark),a  
b326 3a 35 b3			ld a, (.dmark+1)  
b329 32 72 ee			ld (debug_mark+1),a  
b32c 3a 36 b3			ld a, (.dmark+2)  
b32f 32 73 ee			ld (debug_mark+2),a  
b332 18 03			jr .pastdmark  
b334 ..			.dmark: db "NOT"  
b337 f1			.pastdmark: pop af  
b338			endm  
# End of macro DMARK
b338						CALLMONITOR 
b338 cd a3 94			call break_point_state  
b33b				endm  
# End of macro CALLMONITOR
b33b					endif 
b33b					FORTH_DSP 
b33b cd d1 9c			call macro_forth_dsp 
b33e				endm 
# End of macro FORTH_DSP
b33e 7e					ld a,(hl)	; get type of value on TOS 
b33f fe 02				cp DS_TYPE_INUM  
b341 28 03				jr z, .noti 
b343					NEXTW 
b343 c3 ba 9e			jp macro_next 
b346				endm 
# End of macro NEXTW
b346			.noti:          FORTH_DSP_VALUEHL 
b346 cd 0b 9d			call macro_dsp_valuehl 
b349				endm 
# End of macro FORTH_DSP_VALUEHL
b349			;		push hl 
b349					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b349 cd c3 9d			call macro_forth_dsp_pop 
b34c				endm 
# End of macro FORTH_DSP_POP
b34c			;		pop hl 
b34c 3e 00				ld a,0 
b34e bd					cp l 
b34f 28 04				jr z, .not2t 
b351 2e 00				ld l, 0 
b353 18 02				jr .notip 
b355			 
b355 2e ff		.not2t:		ld l, 255 
b357			 
b357 26 00		.notip:		ld h, 0	 
b359			 
b359 cd 14 9b				call forth_push_numhl 
b35c					NEXTW 
b35c c3 ba 9e			jp macro_next 
b35f				endm 
# End of macro NEXTW
b35f			 
b35f			.IS: 
b35f				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b35f 2d				db WORD_SYS_CORE+25             
b360 85 b3			dw .LZERO            
b362 03				db 2 + 1 
b363 .. 00			db "IS",0              
b366				endm 
# End of macro CWHEAD
b366			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b366					if DEBUG_FORTH_WORDS_KEY 
b366						DMARK "IS." 
b366 f5				push af  
b367 3a 7b b3			ld a, (.dmark)  
b36a 32 71 ee			ld (debug_mark),a  
b36d 3a 7c b3			ld a, (.dmark+1)  
b370 32 72 ee			ld (debug_mark+1),a  
b373 3a 7d b3			ld a, (.dmark+2)  
b376 32 73 ee			ld (debug_mark+2),a  
b379 18 03			jr .pastdmark  
b37b ..			.dmark: db "IS."  
b37e f1			.pastdmark: pop af  
b37f			endm  
# End of macro DMARK
b37f						CALLMONITOR 
b37f cd a3 94			call break_point_state  
b382				endm  
# End of macro CALLMONITOR
b382					endif 
b382					NEXTW 
b382 c3 ba 9e			jp macro_next 
b385				endm 
# End of macro NEXTW
b385			.LZERO: 
b385				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b385 2d				db WORD_SYS_CORE+25             
b386 8f b3			dw .TZERO            
b388 03				db 2 + 1 
b389 .. 00			db "0<",0              
b38c				endm 
# End of macro CWHEAD
b38c			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b38c					NEXTW 
b38c c3 ba 9e			jp macro_next 
b38f				endm 
# End of macro NEXTW
b38f			.TZERO: 
b38f				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b38f 2e				db WORD_SYS_CORE+26             
b390 d6 b3			dw .LESS            
b392 03				db 2 + 1 
b393 .. 00			db "0=",0              
b396				endm 
# End of macro CWHEAD
b396			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b396				; TODO add floating point number detection 
b396					;v5 FORTH_DSP_VALUE 
b396					if DEBUG_FORTH_WORDS_KEY 
b396						DMARK "0=." 
b396 f5				push af  
b397 3a ab b3			ld a, (.dmark)  
b39a 32 71 ee			ld (debug_mark),a  
b39d 3a ac b3			ld a, (.dmark+1)  
b3a0 32 72 ee			ld (debug_mark+1),a  
b3a3 3a ad b3			ld a, (.dmark+2)  
b3a6 32 73 ee			ld (debug_mark+2),a  
b3a9 18 03			jr .pastdmark  
b3ab ..			.dmark: db "0=."  
b3ae f1			.pastdmark: pop af  
b3af			endm  
# End of macro DMARK
b3af						CALLMONITOR 
b3af cd a3 94			call break_point_state  
b3b2				endm  
# End of macro CALLMONITOR
b3b2					endif 
b3b2					FORTH_DSP 
b3b2 cd d1 9c			call macro_forth_dsp 
b3b5				endm 
# End of macro FORTH_DSP
b3b5 7e					ld a,(hl)	; get type of value on TOS 
b3b6 fe 02				cp DS_TYPE_INUM  
b3b8 28 00				jr z, .tz_inum 
b3ba			 
b3ba				if FORTH_ENABLE_FLOATMATH 
b3ba					jr .tz_done 
b3ba			 
b3ba				endif 
b3ba					 
b3ba			 
b3ba			.tz_inum: 
b3ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3ba cd 0b 9d			call macro_dsp_valuehl 
b3bd				endm 
# End of macro FORTH_DSP_VALUEHL
b3bd			 
b3bd			;		push hl 
b3bd			 
b3bd					; destroy value TOS 
b3bd			 
b3bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3bd cd c3 9d			call macro_forth_dsp_pop 
b3c0				endm 
# End of macro FORTH_DSP_POP
b3c0			 
b3c0			;		pop hl 
b3c0			 
b3c0 3e 00				ld a,0 
b3c2			 
b3c2 bd					cp l 
b3c3 20 08				jr nz, .tz_notzero 
b3c5			 
b3c5 bc					cp h 
b3c6			 
b3c6 20 05				jr nz, .tz_notzero 
b3c8			 
b3c8			 
b3c8 21 01 00				ld hl, FORTH_TRUE 
b3cb 18 03				jr .tz_done 
b3cd			 
b3cd 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b3d0			 
b3d0					; push value back onto stack for another op etc 
b3d0			 
b3d0			.tz_done: 
b3d0 cd 14 9b				call forth_push_numhl 
b3d3			 
b3d3					NEXTW 
b3d3 c3 ba 9e			jp macro_next 
b3d6				endm 
# End of macro NEXTW
b3d6			.LESS: 
b3d6				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b3d6 2f				db WORD_SYS_CORE+27             
b3d7 3f b4			dw .GT            
b3d9 02				db 1 + 1 
b3da .. 00			db "<",0              
b3dc				endm 
# End of macro CWHEAD
b3dc			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3dc				; TODO add floating point number detection 
b3dc					if DEBUG_FORTH_WORDS_KEY 
b3dc						DMARK "LES" 
b3dc f5				push af  
b3dd 3a f1 b3			ld a, (.dmark)  
b3e0 32 71 ee			ld (debug_mark),a  
b3e3 3a f2 b3			ld a, (.dmark+1)  
b3e6 32 72 ee			ld (debug_mark+1),a  
b3e9 3a f3 b3			ld a, (.dmark+2)  
b3ec 32 73 ee			ld (debug_mark+2),a  
b3ef 18 03			jr .pastdmark  
b3f1 ..			.dmark: db "LES"  
b3f4 f1			.pastdmark: pop af  
b3f5			endm  
# End of macro DMARK
b3f5						CALLMONITOR 
b3f5 cd a3 94			call break_point_state  
b3f8				endm  
# End of macro CALLMONITOR
b3f8					endif 
b3f8					FORTH_DSP 
b3f8 cd d1 9c			call macro_forth_dsp 
b3fb				endm 
# End of macro FORTH_DSP
b3fb					;v5 FORTH_DSP_VALUE 
b3fb 7e					ld a,(hl)	; get type of value on TOS 
b3fc fe 02				cp DS_TYPE_INUM  
b3fe 28 00				jr z, .less_inum 
b400			 
b400				if FORTH_ENABLE_FLOATMATH 
b400					jr .less_done 
b400			 
b400				endif 
b400					 
b400			 
b400			.less_inum: 
b400					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b400 cd 0b 9d			call macro_dsp_valuehl 
b403				endm 
# End of macro FORTH_DSP_VALUEHL
b403			 
b403 e5					push hl  ; u2 
b404			 
b404					; destroy value TOS 
b404			 
b404					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b404 cd c3 9d			call macro_forth_dsp_pop 
b407				endm 
# End of macro FORTH_DSP_POP
b407			 
b407			 
b407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b407 cd 0b 9d			call macro_dsp_valuehl 
b40a				endm 
# End of macro FORTH_DSP_VALUEHL
b40a			 
b40a e5					push hl    ; u1 
b40b			 
b40b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b40b cd c3 9d			call macro_forth_dsp_pop 
b40e				endm 
# End of macro FORTH_DSP_POP
b40e			 
b40e			 
b40e b7			 or a      ;clear carry flag 
b40f 01 00 00		 ld bc, FORTH_FALSE 
b412 e1			  pop hl    ; u1 
b413 d1			  pop de    ; u2 
b414 ed 52		  sbc hl,de 
b416 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b418			 
b418 01 01 00		 ld bc, FORTH_TRUE 
b41b			.lscont:  
b41b c5					push bc 
b41c e1					pop hl 
b41d			 
b41d					if DEBUG_FORTH_WORDS 
b41d						DMARK "LT1" 
b41d f5				push af  
b41e 3a 32 b4			ld a, (.dmark)  
b421 32 71 ee			ld (debug_mark),a  
b424 3a 33 b4			ld a, (.dmark+1)  
b427 32 72 ee			ld (debug_mark+1),a  
b42a 3a 34 b4			ld a, (.dmark+2)  
b42d 32 73 ee			ld (debug_mark+2),a  
b430 18 03			jr .pastdmark  
b432 ..			.dmark: db "LT1"  
b435 f1			.pastdmark: pop af  
b436			endm  
# End of macro DMARK
b436						CALLMONITOR 
b436 cd a3 94			call break_point_state  
b439				endm  
# End of macro CALLMONITOR
b439					endif 
b439 cd 14 9b				call forth_push_numhl 
b43c			 
b43c					NEXTW 
b43c c3 ba 9e			jp macro_next 
b43f				endm 
# End of macro NEXTW
b43f			.GT: 
b43f				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b43f 30				db WORD_SYS_CORE+28             
b440 a8 b4			dw .EQUAL            
b442 02				db 1 + 1 
b443 .. 00			db ">",0              
b445				endm 
# End of macro CWHEAD
b445			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b445				; TODO add floating point number detection 
b445					if DEBUG_FORTH_WORDS_KEY 
b445						DMARK "GRT" 
b445 f5				push af  
b446 3a 5a b4			ld a, (.dmark)  
b449 32 71 ee			ld (debug_mark),a  
b44c 3a 5b b4			ld a, (.dmark+1)  
b44f 32 72 ee			ld (debug_mark+1),a  
b452 3a 5c b4			ld a, (.dmark+2)  
b455 32 73 ee			ld (debug_mark+2),a  
b458 18 03			jr .pastdmark  
b45a ..			.dmark: db "GRT"  
b45d f1			.pastdmark: pop af  
b45e			endm  
# End of macro DMARK
b45e						CALLMONITOR 
b45e cd a3 94			call break_point_state  
b461				endm  
# End of macro CALLMONITOR
b461					endif 
b461					FORTH_DSP 
b461 cd d1 9c			call macro_forth_dsp 
b464				endm 
# End of macro FORTH_DSP
b464					;FORTH_DSP_VALUE 
b464 7e					ld a,(hl)	; get type of value on TOS 
b465 fe 02				cp DS_TYPE_INUM  
b467 28 00				jr z, .gt_inum 
b469			 
b469				if FORTH_ENABLE_FLOATMATH 
b469					jr .gt_done 
b469			 
b469				endif 
b469					 
b469			 
b469			.gt_inum: 
b469					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b469 cd 0b 9d			call macro_dsp_valuehl 
b46c				endm 
# End of macro FORTH_DSP_VALUEHL
b46c			 
b46c e5					push hl  ; u2 
b46d			 
b46d					; destroy value TOS 
b46d			 
b46d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b46d cd c3 9d			call macro_forth_dsp_pop 
b470				endm 
# End of macro FORTH_DSP_POP
b470			 
b470			 
b470					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b470 cd 0b 9d			call macro_dsp_valuehl 
b473				endm 
# End of macro FORTH_DSP_VALUEHL
b473			 
b473 e5					push hl    ; u1 
b474			 
b474					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b474 cd c3 9d			call macro_forth_dsp_pop 
b477				endm 
# End of macro FORTH_DSP_POP
b477			 
b477			 
b477 b7			 or a      ;clear carry flag 
b478 01 00 00		 ld bc, FORTH_FALSE 
b47b e1			  pop hl    ; u1 
b47c d1			  pop de    ; u2 
b47d ed 52		  sbc hl,de 
b47f 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b481			 
b481 01 01 00		 ld bc, FORTH_TRUE 
b484			.gtcont:  
b484 c5					push bc 
b485 e1					pop hl 
b486			 
b486					if DEBUG_FORTH_WORDS 
b486						DMARK "GT1" 
b486 f5				push af  
b487 3a 9b b4			ld a, (.dmark)  
b48a 32 71 ee			ld (debug_mark),a  
b48d 3a 9c b4			ld a, (.dmark+1)  
b490 32 72 ee			ld (debug_mark+1),a  
b493 3a 9d b4			ld a, (.dmark+2)  
b496 32 73 ee			ld (debug_mark+2),a  
b499 18 03			jr .pastdmark  
b49b ..			.dmark: db "GT1"  
b49e f1			.pastdmark: pop af  
b49f			endm  
# End of macro DMARK
b49f						CALLMONITOR 
b49f cd a3 94			call break_point_state  
b4a2				endm  
# End of macro CALLMONITOR
b4a2					endif 
b4a2 cd 14 9b				call forth_push_numhl 
b4a5			 
b4a5					NEXTW 
b4a5 c3 ba 9e			jp macro_next 
b4a8				endm 
# End of macro NEXTW
b4a8			.EQUAL: 
b4a8				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4a8 31				db WORD_SYS_CORE+29             
b4a9 13 b5			dw .ENDLOGIC            
b4ab 02				db 1 + 1 
b4ac .. 00			db "=",0              
b4ae				endm 
# End of macro CWHEAD
b4ae			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4ae				; TODO add floating point number detection 
b4ae					if DEBUG_FORTH_WORDS_KEY 
b4ae						DMARK "EQ." 
b4ae f5				push af  
b4af 3a c3 b4			ld a, (.dmark)  
b4b2 32 71 ee			ld (debug_mark),a  
b4b5 3a c4 b4			ld a, (.dmark+1)  
b4b8 32 72 ee			ld (debug_mark+1),a  
b4bb 3a c5 b4			ld a, (.dmark+2)  
b4be 32 73 ee			ld (debug_mark+2),a  
b4c1 18 03			jr .pastdmark  
b4c3 ..			.dmark: db "EQ."  
b4c6 f1			.pastdmark: pop af  
b4c7			endm  
# End of macro DMARK
b4c7						CALLMONITOR 
b4c7 cd a3 94			call break_point_state  
b4ca				endm  
# End of macro CALLMONITOR
b4ca					endif 
b4ca					FORTH_DSP 
b4ca cd d1 9c			call macro_forth_dsp 
b4cd				endm 
# End of macro FORTH_DSP
b4cd					;v5 FORTH_DSP_VALUE 
b4cd 7e					ld a,(hl)	; get type of value on TOS 
b4ce fe 02				cp DS_TYPE_INUM  
b4d0 28 00				jr z, .eq_inum 
b4d2			 
b4d2				if FORTH_ENABLE_FLOATMATH 
b4d2					jr .eq_done 
b4d2			 
b4d2				endif 
b4d2					 
b4d2			 
b4d2			.eq_inum: 
b4d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d2 cd 0b 9d			call macro_dsp_valuehl 
b4d5				endm 
# End of macro FORTH_DSP_VALUEHL
b4d5			 
b4d5 e5					push hl 
b4d6			 
b4d6					; destroy value TOS 
b4d6			 
b4d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d6 cd c3 9d			call macro_forth_dsp_pop 
b4d9				endm 
# End of macro FORTH_DSP_POP
b4d9			 
b4d9			 
b4d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d9 cd 0b 9d			call macro_dsp_valuehl 
b4dc				endm 
# End of macro FORTH_DSP_VALUEHL
b4dc			 
b4dc					; one value on hl get other one back 
b4dc			 
b4dc e5					push hl 
b4dd			 
b4dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4dd cd c3 9d			call macro_forth_dsp_pop 
b4e0				endm 
# End of macro FORTH_DSP_POP
b4e0			 
b4e0 0e 00				ld c, FORTH_FALSE 
b4e2			 
b4e2 e1					pop hl 
b4e3 d1					pop de 
b4e4			 
b4e4 7b					ld a, e 
b4e5 bd					cp l 
b4e6			 
b4e6 20 06				jr nz, .eq_done 
b4e8			 
b4e8 7a					ld a, d 
b4e9 bc					cp h 
b4ea			 
b4ea 20 02				jr nz, .eq_done 
b4ec			 
b4ec 0e 01				ld c, FORTH_TRUE 
b4ee					 
b4ee			 
b4ee			 
b4ee			.eq_done: 
b4ee			 
b4ee					; TODO push value back onto stack for another op etc 
b4ee			 
b4ee 26 00				ld h, 0 
b4f0 69					ld l, c 
b4f1					if DEBUG_FORTH_WORDS 
b4f1						DMARK "EQ1" 
b4f1 f5				push af  
b4f2 3a 06 b5			ld a, (.dmark)  
b4f5 32 71 ee			ld (debug_mark),a  
b4f8 3a 07 b5			ld a, (.dmark+1)  
b4fb 32 72 ee			ld (debug_mark+1),a  
b4fe 3a 08 b5			ld a, (.dmark+2)  
b501 32 73 ee			ld (debug_mark+2),a  
b504 18 03			jr .pastdmark  
b506 ..			.dmark: db "EQ1"  
b509 f1			.pastdmark: pop af  
b50a			endm  
# End of macro DMARK
b50a						CALLMONITOR 
b50a cd a3 94			call break_point_state  
b50d				endm  
# End of macro CALLMONITOR
b50d					endif 
b50d cd 14 9b				call forth_push_numhl 
b510			 
b510					NEXTW 
b510 c3 ba 9e			jp macro_next 
b513				endm 
# End of macro NEXTW
b513			 
b513			 
b513			.ENDLOGIC: 
b513			; eof 
b513			 
b513			 
# End of file forth_words_logic.asm
b513			include "forth_words_maths.asm" 
b513			 
b513			; | ## Maths Words 
b513			 
b513			.PLUS:	 
b513				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b513 15				db WORD_SYS_CORE+1             
b514 71 b5			dw .NEG            
b516 02				db 1 + 1 
b517 .. 00			db "+",0              
b519				endm 
# End of macro CWHEAD
b519			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b519					if DEBUG_FORTH_WORDS_KEY 
b519						DMARK "PLU" 
b519 f5				push af  
b51a 3a 2e b5			ld a, (.dmark)  
b51d 32 71 ee			ld (debug_mark),a  
b520 3a 2f b5			ld a, (.dmark+1)  
b523 32 72 ee			ld (debug_mark+1),a  
b526 3a 30 b5			ld a, (.dmark+2)  
b529 32 73 ee			ld (debug_mark+2),a  
b52c 18 03			jr .pastdmark  
b52e ..			.dmark: db "PLU"  
b531 f1			.pastdmark: pop af  
b532			endm  
# End of macro DMARK
b532						CALLMONITOR 
b532 cd a3 94			call break_point_state  
b535				endm  
# End of macro CALLMONITOR
b535					endif 
b535					; add top two values and push back result 
b535			 
b535					;for v5 FORTH_DSP_VALUE 
b535					FORTH_DSP 
b535 cd d1 9c			call macro_forth_dsp 
b538				endm 
# End of macro FORTH_DSP
b538 7e					ld a,(hl)	; get type of value on TOS 
b539 fe 02				cp DS_TYPE_INUM  
b53b 28 03				jr z, .dot_inum 
b53d			 
b53d					NEXTW 
b53d c3 ba 9e			jp macro_next 
b540				endm 
# End of macro NEXTW
b540			 
b540			; float maths 
b540			 
b540				if FORTH_ENABLE_FLOATMATH 
b540						inc hl      ; now at start of numeric as string 
b540			 
b540					if DEBUG_FORTH_MATHS 
b540						DMARK "ADD" 
b540				CALLMONITOR 
b540					endif 
b540			 
b540					;ld ix, hl 
b540					call CON 
b540			 
b540			 
b540					push hl 
b540					 
b540					 
b540			 
b540						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b540			 
b540					; get next number 
b540			 
b540						FORTH_DSP_VALUE 
b540			 
b540						inc hl      ; now at start of numeric as string 
b540			 
b540					;ld ix, hl 
b540					call CON 
b540			 
b540					push hl 
b540			 
b540			 
b540						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b540			 
b540						; TODO do add 
b540			 
b540						call IADD 
b540			 
b540						; TODO get result back as ascii 
b540			 
b540						; TODO push result  
b540			 
b540			 
b540			 
b540						jr .dot_done 
b540				endif 
b540			 
b540			.dot_inum: 
b540			 
b540			 
b540					if DEBUG_FORTH_DOT 
b540						DMARK "+IT" 
b540 f5				push af  
b541 3a 55 b5			ld a, (.dmark)  
b544 32 71 ee			ld (debug_mark),a  
b547 3a 56 b5			ld a, (.dmark+1)  
b54a 32 72 ee			ld (debug_mark+1),a  
b54d 3a 57 b5			ld a, (.dmark+2)  
b550 32 73 ee			ld (debug_mark+2),a  
b553 18 03			jr .pastdmark  
b555 ..			.dmark: db "+IT"  
b558 f1			.pastdmark: pop af  
b559			endm  
# End of macro DMARK
b559				CALLMONITOR 
b559 cd a3 94			call break_point_state  
b55c				endm  
# End of macro CALLMONITOR
b55c					endif 
b55c			 
b55c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b55c cd 0b 9d			call macro_dsp_valuehl 
b55f				endm 
# End of macro FORTH_DSP_VALUEHL
b55f			 
b55f				; TODO add floating point number detection 
b55f			 
b55f e5					push hl 
b560			 
b560					; destroy value TOS 
b560			 
b560					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b560 cd c3 9d			call macro_forth_dsp_pop 
b563				endm 
# End of macro FORTH_DSP_POP
b563			 
b563			 
b563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b563 cd 0b 9d			call macro_dsp_valuehl 
b566				endm 
# End of macro FORTH_DSP_VALUEHL
b566			 
b566					; one value on hl get other one back 
b566			 
b566 d1					pop de 
b567			 
b567					; do the add 
b567			 
b567 19					add hl,de 
b568			 
b568					; save it 
b568			 
b568			;		push hl	 
b568			 
b568					; 
b568			 
b568					; destroy value TOS 
b568			 
b568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b568 cd c3 9d			call macro_forth_dsp_pop 
b56b				endm 
# End of macro FORTH_DSP_POP
b56b			 
b56b					; TODO push value back onto stack for another op etc 
b56b			 
b56b			;		pop hl 
b56b			 
b56b			.dot_done: 
b56b cd 14 9b				call forth_push_numhl 
b56e			 
b56e					NEXTW 
b56e c3 ba 9e			jp macro_next 
b571				endm 
# End of macro NEXTW
b571			.NEG: 
b571			 
b571				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b571 17				db WORD_SYS_CORE+3             
b572 b4 b5			dw .DIV            
b574 02				db 1 + 1 
b575 .. 00			db "-",0              
b577				endm 
# End of macro CWHEAD
b577			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b577					if DEBUG_FORTH_WORDS_KEY 
b577						DMARK "SUB" 
b577 f5				push af  
b578 3a 8c b5			ld a, (.dmark)  
b57b 32 71 ee			ld (debug_mark),a  
b57e 3a 8d b5			ld a, (.dmark+1)  
b581 32 72 ee			ld (debug_mark+1),a  
b584 3a 8e b5			ld a, (.dmark+2)  
b587 32 73 ee			ld (debug_mark+2),a  
b58a 18 03			jr .pastdmark  
b58c ..			.dmark: db "SUB"  
b58f f1			.pastdmark: pop af  
b590			endm  
# End of macro DMARK
b590						CALLMONITOR 
b590 cd a3 94			call break_point_state  
b593				endm  
# End of macro CALLMONITOR
b593					endif 
b593			 
b593			 
b593				; TODO add floating point number detection 
b593					; v5 FORTH_DSP_VALUE 
b593					FORTH_DSP 
b593 cd d1 9c			call macro_forth_dsp 
b596				endm 
# End of macro FORTH_DSP
b596 7e					ld a,(hl)	; get type of value on TOS 
b597 fe 02				cp DS_TYPE_INUM  
b599 28 03				jr z, .neg_inum 
b59b			 
b59b					NEXTW 
b59b c3 ba 9e			jp macro_next 
b59e				endm 
# End of macro NEXTW
b59e			 
b59e			; float maths 
b59e			 
b59e				if FORTH_ENABLE_FLOATMATH 
b59e					jr .neg_done 
b59e			 
b59e				endif 
b59e					 
b59e			 
b59e			.neg_inum: 
b59e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b59e cd 0b 9d			call macro_dsp_valuehl 
b5a1				endm 
# End of macro FORTH_DSP_VALUEHL
b5a1			 
b5a1 e5					push hl 
b5a2			 
b5a2					; destroy value TOS 
b5a2			 
b5a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a2 cd c3 9d			call macro_forth_dsp_pop 
b5a5				endm 
# End of macro FORTH_DSP_POP
b5a5			 
b5a5			 
b5a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a5 cd 0b 9d			call macro_dsp_valuehl 
b5a8				endm 
# End of macro FORTH_DSP_VALUEHL
b5a8			 
b5a8					; one value on hl get other one back 
b5a8			 
b5a8 d1					pop de 
b5a9			 
b5a9					; do the sub 
b5a9			;		ex de, hl 
b5a9			 
b5a9 ed 52				sbc hl,de 
b5ab			 
b5ab					; save it 
b5ab			 
b5ab			;		push hl	 
b5ab			 
b5ab					; 
b5ab			 
b5ab					; destroy value TOS 
b5ab			 
b5ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ab cd c3 9d			call macro_forth_dsp_pop 
b5ae				endm 
# End of macro FORTH_DSP_POP
b5ae			 
b5ae					; TODO push value back onto stack for another op etc 
b5ae			 
b5ae			;		pop hl 
b5ae			 
b5ae cd 14 9b				call forth_push_numhl 
b5b1			.neg_done: 
b5b1			 
b5b1					NEXTW 
b5b1 c3 ba 9e			jp macro_next 
b5b4				endm 
# End of macro NEXTW
b5b4			.DIV: 
b5b4				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5b4 18				db WORD_SYS_CORE+4             
b5b5 01 b6			dw .MUL            
b5b7 02				db 1 + 1 
b5b8 .. 00			db "/",0              
b5ba				endm 
# End of macro CWHEAD
b5ba			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5ba					if DEBUG_FORTH_WORDS_KEY 
b5ba						DMARK "DIV" 
b5ba f5				push af  
b5bb 3a cf b5			ld a, (.dmark)  
b5be 32 71 ee			ld (debug_mark),a  
b5c1 3a d0 b5			ld a, (.dmark+1)  
b5c4 32 72 ee			ld (debug_mark+1),a  
b5c7 3a d1 b5			ld a, (.dmark+2)  
b5ca 32 73 ee			ld (debug_mark+2),a  
b5cd 18 03			jr .pastdmark  
b5cf ..			.dmark: db "DIV"  
b5d2 f1			.pastdmark: pop af  
b5d3			endm  
# End of macro DMARK
b5d3						CALLMONITOR 
b5d3 cd a3 94			call break_point_state  
b5d6				endm  
# End of macro CALLMONITOR
b5d6					endif 
b5d6				; TODO add floating point number detection 
b5d6					; v5 FORTH_DSP_VALUE 
b5d6					FORTH_DSP 
b5d6 cd d1 9c			call macro_forth_dsp 
b5d9				endm 
# End of macro FORTH_DSP
b5d9 7e					ld a,(hl)	; get type of value on TOS 
b5da fe 02				cp DS_TYPE_INUM  
b5dc 28 03				jr z, .div_inum 
b5de			 
b5de				if FORTH_ENABLE_FLOATMATH 
b5de					jr .div_done 
b5de			 
b5de				endif 
b5de					NEXTW 
b5de c3 ba 9e			jp macro_next 
b5e1				endm 
# End of macro NEXTW
b5e1			.div_inum: 
b5e1			 
b5e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e1 cd 0b 9d			call macro_dsp_valuehl 
b5e4				endm 
# End of macro FORTH_DSP_VALUEHL
b5e4			 
b5e4 e5					push hl    ; to go to bc 
b5e5			 
b5e5					; destroy value TOS 
b5e5			 
b5e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e5 cd c3 9d			call macro_forth_dsp_pop 
b5e8				endm 
# End of macro FORTH_DSP_POP
b5e8			 
b5e8			 
b5e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e8 cd 0b 9d			call macro_dsp_valuehl 
b5eb				endm 
# End of macro FORTH_DSP_VALUEHL
b5eb			 
b5eb					; hl to go to de 
b5eb			 
b5eb e5					push hl 
b5ec			 
b5ec c1					pop bc 
b5ed d1					pop de		 
b5ee			 
b5ee			 
b5ee					if DEBUG_FORTH_MATHS 
b5ee						DMARK "DIV" 
b5ee				CALLMONITOR 
b5ee					endif 
b5ee					; one value on hl but move to a get other one back 
b5ee			 
b5ee			        
b5ee cd ff 8b			call Div16 
b5f1			 
b5f1			;	push af	 
b5f1 e5				push hl 
b5f2 c5				push bc 
b5f3			 
b5f3					if DEBUG_FORTH_MATHS 
b5f3						DMARK "DI1" 
b5f3				CALLMONITOR 
b5f3					endif 
b5f3			 
b5f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5f3 cd c3 9d			call macro_forth_dsp_pop 
b5f6				endm 
# End of macro FORTH_DSP_POP
b5f6			 
b5f6			 
b5f6			 
b5f6 e1					pop hl    ; result 
b5f7			 
b5f7 cd 14 9b				call forth_push_numhl 
b5fa			 
b5fa e1					pop hl    ; reminder 
b5fb			;		ld h,0 
b5fb			;		ld l,d 
b5fb			 
b5fb cd 14 9b				call forth_push_numhl 
b5fe			.div_done: 
b5fe					NEXTW 
b5fe c3 ba 9e			jp macro_next 
b601				endm 
# End of macro NEXTW
b601			.MUL: 
b601				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b601 19				db WORD_SYS_CORE+5             
b602 46 b6			dw .MIN            
b604 02				db 1 + 1 
b605 .. 00			db "*",0              
b607				endm 
# End of macro CWHEAD
b607			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b607				; TODO add floating point number detection 
b607					if DEBUG_FORTH_WORDS_KEY 
b607						DMARK "MUL" 
b607 f5				push af  
b608 3a 1c b6			ld a, (.dmark)  
b60b 32 71 ee			ld (debug_mark),a  
b60e 3a 1d b6			ld a, (.dmark+1)  
b611 32 72 ee			ld (debug_mark+1),a  
b614 3a 1e b6			ld a, (.dmark+2)  
b617 32 73 ee			ld (debug_mark+2),a  
b61a 18 03			jr .pastdmark  
b61c ..			.dmark: db "MUL"  
b61f f1			.pastdmark: pop af  
b620			endm  
# End of macro DMARK
b620						CALLMONITOR 
b620 cd a3 94			call break_point_state  
b623				endm  
# End of macro CALLMONITOR
b623					endif 
b623					FORTH_DSP 
b623 cd d1 9c			call macro_forth_dsp 
b626				endm 
# End of macro FORTH_DSP
b626					; v5 FORTH_DSP_VALUE 
b626 7e					ld a,(hl)	; get type of value on TOS 
b627 fe 02				cp DS_TYPE_INUM  
b629 28 03				jr z, .mul_inum 
b62b			 
b62b				if FORTH_ENABLE_FLOATMATH 
b62b					jr .mul_done 
b62b			 
b62b				endif 
b62b			 
b62b					NEXTW 
b62b c3 ba 9e			jp macro_next 
b62e				endm 
# End of macro NEXTW
b62e			.mul_inum:	 
b62e			 
b62e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b62e cd 0b 9d			call macro_dsp_valuehl 
b631				endm 
# End of macro FORTH_DSP_VALUEHL
b631			 
b631 e5					push hl 
b632			 
b632					; destroy value TOS 
b632			 
b632					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b632 cd c3 9d			call macro_forth_dsp_pop 
b635				endm 
# End of macro FORTH_DSP_POP
b635			 
b635			 
b635					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b635 cd 0b 9d			call macro_dsp_valuehl 
b638				endm 
# End of macro FORTH_DSP_VALUEHL
b638			 
b638					; one value on hl but move to a get other one back 
b638			 
b638 7d					ld a, l 
b639			 
b639 d1					pop de 
b63a			 
b63a					; do the mull 
b63a			;		ex de, hl 
b63a			 
b63a cd 25 8c				call Mult16 
b63d					; save it 
b63d			 
b63d			;		push hl	 
b63d			 
b63d					; 
b63d			 
b63d					; destroy value TOS 
b63d			 
b63d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b63d cd c3 9d			call macro_forth_dsp_pop 
b640				endm 
# End of macro FORTH_DSP_POP
b640			 
b640					; TODO push value back onto stack for another op etc 
b640			 
b640			;		pop hl 
b640			 
b640 cd 14 9b				call forth_push_numhl 
b643			 
b643			.mul_done: 
b643					NEXTW 
b643 c3 ba 9e			jp macro_next 
b646				endm 
# End of macro NEXTW
b646			 
b646			 
b646			 
b646			 
b646			.MIN: 
b646				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b646 49				db WORD_SYS_CORE+53             
b647 c7 b6			dw .MAX            
b649 04				db 3 + 1 
b64a .. 00			db "MIN",0              
b64e				endm 
# End of macro CWHEAD
b64e			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b64e					if DEBUG_FORTH_WORDS_KEY 
b64e						DMARK "MIN" 
b64e f5				push af  
b64f 3a 63 b6			ld a, (.dmark)  
b652 32 71 ee			ld (debug_mark),a  
b655 3a 64 b6			ld a, (.dmark+1)  
b658 32 72 ee			ld (debug_mark+1),a  
b65b 3a 65 b6			ld a, (.dmark+2)  
b65e 32 73 ee			ld (debug_mark+2),a  
b661 18 03			jr .pastdmark  
b663 ..			.dmark: db "MIN"  
b666 f1			.pastdmark: pop af  
b667			endm  
# End of macro DMARK
b667						CALLMONITOR 
b667 cd a3 94			call break_point_state  
b66a				endm  
# End of macro CALLMONITOR
b66a					endif 
b66a					; get u2 
b66a			 
b66a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b66a cd 0b 9d			call macro_dsp_valuehl 
b66d				endm 
# End of macro FORTH_DSP_VALUEHL
b66d			 
b66d e5					push hl   ; u2 
b66e			 
b66e					; destroy value TOS 
b66e			 
b66e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b66e cd c3 9d			call macro_forth_dsp_pop 
b671				endm 
# End of macro FORTH_DSP_POP
b671			 
b671					; get u1 
b671			 
b671					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b671 cd 0b 9d			call macro_dsp_valuehl 
b674				endm 
# End of macro FORTH_DSP_VALUEHL
b674			 
b674 e5					push hl  ; u1 
b675			 
b675					; destroy value TOS 
b675			 
b675					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b675 cd c3 9d			call macro_forth_dsp_pop 
b678				endm 
# End of macro FORTH_DSP_POP
b678			 
b678 b7			 or a      ;clear carry flag 
b679 e1			  pop hl    ; u1 
b67a d1			  pop de    ; u2 
b67b e5				push hl   ; saved in case hl is lowest 
b67c ed 52		  sbc hl,de 
b67e 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b680			 
b680 e1				pop hl 
b681					if DEBUG_FORTH_WORDS 
b681						DMARK "MIN" 
b681 f5				push af  
b682 3a 96 b6			ld a, (.dmark)  
b685 32 71 ee			ld (debug_mark),a  
b688 3a 97 b6			ld a, (.dmark+1)  
b68b 32 72 ee			ld (debug_mark+1),a  
b68e 3a 98 b6			ld a, (.dmark+2)  
b691 32 73 ee			ld (debug_mark+2),a  
b694 18 03			jr .pastdmark  
b696 ..			.dmark: db "MIN"  
b699 f1			.pastdmark: pop af  
b69a			endm  
# End of macro DMARK
b69a						CALLMONITOR 
b69a cd a3 94			call break_point_state  
b69d				endm  
# End of macro CALLMONITOR
b69d					endif 
b69d cd 14 9b				call forth_push_numhl 
b6a0			 
b6a0				       NEXTW 
b6a0 c3 ba 9e			jp macro_next 
b6a3				endm 
# End of macro NEXTW
b6a3			 
b6a3			.mincont:  
b6a3 c1				pop bc   ; tidy up 
b6a4 eb				ex de , hl  
b6a5					if DEBUG_FORTH_WORDS 
b6a5						DMARK "MI1" 
b6a5 f5				push af  
b6a6 3a ba b6			ld a, (.dmark)  
b6a9 32 71 ee			ld (debug_mark),a  
b6ac 3a bb b6			ld a, (.dmark+1)  
b6af 32 72 ee			ld (debug_mark+1),a  
b6b2 3a bc b6			ld a, (.dmark+2)  
b6b5 32 73 ee			ld (debug_mark+2),a  
b6b8 18 03			jr .pastdmark  
b6ba ..			.dmark: db "MI1"  
b6bd f1			.pastdmark: pop af  
b6be			endm  
# End of macro DMARK
b6be						CALLMONITOR 
b6be cd a3 94			call break_point_state  
b6c1				endm  
# End of macro CALLMONITOR
b6c1					endif 
b6c1 cd 14 9b				call forth_push_numhl 
b6c4			 
b6c4				       NEXTW 
b6c4 c3 ba 9e			jp macro_next 
b6c7				endm 
# End of macro NEXTW
b6c7			.MAX: 
b6c7				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b6c7 4a				db WORD_SYS_CORE+54             
b6c8 48 b7			dw .RND16            
b6ca 04				db 3 + 1 
b6cb .. 00			db "MAX",0              
b6cf				endm 
# End of macro CWHEAD
b6cf			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b6cf					if DEBUG_FORTH_WORDS_KEY 
b6cf						DMARK "MAX" 
b6cf f5				push af  
b6d0 3a e4 b6			ld a, (.dmark)  
b6d3 32 71 ee			ld (debug_mark),a  
b6d6 3a e5 b6			ld a, (.dmark+1)  
b6d9 32 72 ee			ld (debug_mark+1),a  
b6dc 3a e6 b6			ld a, (.dmark+2)  
b6df 32 73 ee			ld (debug_mark+2),a  
b6e2 18 03			jr .pastdmark  
b6e4 ..			.dmark: db "MAX"  
b6e7 f1			.pastdmark: pop af  
b6e8			endm  
# End of macro DMARK
b6e8						CALLMONITOR 
b6e8 cd a3 94			call break_point_state  
b6eb				endm  
# End of macro CALLMONITOR
b6eb					endif 
b6eb					; get u2 
b6eb			 
b6eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6eb cd 0b 9d			call macro_dsp_valuehl 
b6ee				endm 
# End of macro FORTH_DSP_VALUEHL
b6ee			 
b6ee e5					push hl   ; u2 
b6ef			 
b6ef					; destroy value TOS 
b6ef			 
b6ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ef cd c3 9d			call macro_forth_dsp_pop 
b6f2				endm 
# End of macro FORTH_DSP_POP
b6f2			 
b6f2					; get u1 
b6f2			 
b6f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f2 cd 0b 9d			call macro_dsp_valuehl 
b6f5				endm 
# End of macro FORTH_DSP_VALUEHL
b6f5			 
b6f5 e5					push hl  ; u1 
b6f6			 
b6f6					; destroy value TOS 
b6f6			 
b6f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6f6 cd c3 9d			call macro_forth_dsp_pop 
b6f9				endm 
# End of macro FORTH_DSP_POP
b6f9			 
b6f9 b7			 or a      ;clear carry flag 
b6fa e1			  pop hl    ; u1 
b6fb d1			  pop de    ; u2 
b6fc e5				push hl   ; saved in case hl is lowest 
b6fd ed 52		  sbc hl,de 
b6ff 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b701			 
b701 e1				pop hl 
b702					if DEBUG_FORTH_WORDS 
b702						DMARK "MAX" 
b702 f5				push af  
b703 3a 17 b7			ld a, (.dmark)  
b706 32 71 ee			ld (debug_mark),a  
b709 3a 18 b7			ld a, (.dmark+1)  
b70c 32 72 ee			ld (debug_mark+1),a  
b70f 3a 19 b7			ld a, (.dmark+2)  
b712 32 73 ee			ld (debug_mark+2),a  
b715 18 03			jr .pastdmark  
b717 ..			.dmark: db "MAX"  
b71a f1			.pastdmark: pop af  
b71b			endm  
# End of macro DMARK
b71b						CALLMONITOR 
b71b cd a3 94			call break_point_state  
b71e				endm  
# End of macro CALLMONITOR
b71e					endif 
b71e cd 14 9b				call forth_push_numhl 
b721			 
b721				       NEXTW 
b721 c3 ba 9e			jp macro_next 
b724				endm 
# End of macro NEXTW
b724			 
b724			.maxcont:  
b724 c1				pop bc   ; tidy up 
b725 eb				ex de , hl  
b726					if DEBUG_FORTH_WORDS 
b726						DMARK "MA1" 
b726 f5				push af  
b727 3a 3b b7			ld a, (.dmark)  
b72a 32 71 ee			ld (debug_mark),a  
b72d 3a 3c b7			ld a, (.dmark+1)  
b730 32 72 ee			ld (debug_mark+1),a  
b733 3a 3d b7			ld a, (.dmark+2)  
b736 32 73 ee			ld (debug_mark+2),a  
b739 18 03			jr .pastdmark  
b73b ..			.dmark: db "MA1"  
b73e f1			.pastdmark: pop af  
b73f			endm  
# End of macro DMARK
b73f						CALLMONITOR 
b73f cd a3 94			call break_point_state  
b742				endm  
# End of macro CALLMONITOR
b742					endif 
b742 cd 14 9b				call forth_push_numhl 
b745				       NEXTW 
b745 c3 ba 9e			jp macro_next 
b748				endm 
# End of macro NEXTW
b748			 
b748			.RND16: 
b748				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b748 4e				db WORD_SYS_CORE+58             
b749 77 b7			dw .RND8            
b74b 06				db 5 + 1 
b74c .. 00			db "RND16",0              
b752				endm 
# End of macro CWHEAD
b752			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b752					if DEBUG_FORTH_WORDS_KEY 
b752						DMARK "R16" 
b752 f5				push af  
b753 3a 67 b7			ld a, (.dmark)  
b756 32 71 ee			ld (debug_mark),a  
b759 3a 68 b7			ld a, (.dmark+1)  
b75c 32 72 ee			ld (debug_mark+1),a  
b75f 3a 69 b7			ld a, (.dmark+2)  
b762 32 73 ee			ld (debug_mark+2),a  
b765 18 03			jr .pastdmark  
b767 ..			.dmark: db "R16"  
b76a f1			.pastdmark: pop af  
b76b			endm  
# End of macro DMARK
b76b						CALLMONITOR 
b76b cd a3 94			call break_point_state  
b76e				endm  
# End of macro CALLMONITOR
b76e					endif 
b76e cd c9 8b				call prng16  
b771 cd 14 9b				call forth_push_numhl 
b774				       NEXTW 
b774 c3 ba 9e			jp macro_next 
b777				endm 
# End of macro NEXTW
b777			.RND8: 
b777				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b777 60				db WORD_SYS_CORE+76             
b778 ac b7			dw .RND            
b77a 05				db 4 + 1 
b77b .. 00			db "RND8",0              
b780				endm 
# End of macro CWHEAD
b780			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b780					if DEBUG_FORTH_WORDS_KEY 
b780						DMARK "RN8" 
b780 f5				push af  
b781 3a 95 b7			ld a, (.dmark)  
b784 32 71 ee			ld (debug_mark),a  
b787 3a 96 b7			ld a, (.dmark+1)  
b78a 32 72 ee			ld (debug_mark+1),a  
b78d 3a 97 b7			ld a, (.dmark+2)  
b790 32 73 ee			ld (debug_mark+2),a  
b793 18 03			jr .pastdmark  
b795 ..			.dmark: db "RN8"  
b798 f1			.pastdmark: pop af  
b799			endm  
# End of macro DMARK
b799						CALLMONITOR 
b799 cd a3 94			call break_point_state  
b79c				endm  
# End of macro CALLMONITOR
b79c					endif 
b79c 2a b2 eb				ld hl,(xrandc) 
b79f 23					inc hl 
b7a0 cd e3 8b				call xrnd 
b7a3 6f					ld l,a	 
b7a4 26 00				ld h,0 
b7a6 cd 14 9b				call forth_push_numhl 
b7a9				       NEXTW 
b7a9 c3 ba 9e			jp macro_next 
b7ac				endm 
# End of macro NEXTW
b7ac			.RND: 
b7ac				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7ac 60				db WORD_SYS_CORE+76             
b7ad b2 b8			dw .ENDMATHS            
b7af 04				db 3 + 1 
b7b0 .. 00			db "RND",0              
b7b4				endm 
# End of macro CWHEAD
b7b4			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7b4			 
b7b4					if DEBUG_FORTH_WORDS_KEY 
b7b4						DMARK "RND" 
b7b4 f5				push af  
b7b5 3a c9 b7			ld a, (.dmark)  
b7b8 32 71 ee			ld (debug_mark),a  
b7bb 3a ca b7			ld a, (.dmark+1)  
b7be 32 72 ee			ld (debug_mark+1),a  
b7c1 3a cb b7			ld a, (.dmark+2)  
b7c4 32 73 ee			ld (debug_mark+2),a  
b7c7 18 03			jr .pastdmark  
b7c9 ..			.dmark: db "RND"  
b7cc f1			.pastdmark: pop af  
b7cd			endm  
# End of macro DMARK
b7cd						CALLMONITOR 
b7cd cd a3 94			call break_point_state  
b7d0				endm  
# End of macro CALLMONITOR
b7d0					endif 
b7d0					 
b7d0					FORTH_DSP_VALUEHL    ; upper range 
b7d0 cd 0b 9d			call macro_dsp_valuehl 
b7d3				endm 
# End of macro FORTH_DSP_VALUEHL
b7d3			 
b7d3 22 b6 eb				ld (LFSRSeed), hl	 
b7d6			 
b7d6					if DEBUG_FORTH_WORDS 
b7d6						DMARK "RN1" 
b7d6 f5				push af  
b7d7 3a eb b7			ld a, (.dmark)  
b7da 32 71 ee			ld (debug_mark),a  
b7dd 3a ec b7			ld a, (.dmark+1)  
b7e0 32 72 ee			ld (debug_mark+1),a  
b7e3 3a ed b7			ld a, (.dmark+2)  
b7e6 32 73 ee			ld (debug_mark+2),a  
b7e9 18 03			jr .pastdmark  
b7eb ..			.dmark: db "RN1"  
b7ee f1			.pastdmark: pop af  
b7ef			endm  
# End of macro DMARK
b7ef						CALLMONITOR 
b7ef cd a3 94			call break_point_state  
b7f2				endm  
# End of macro CALLMONITOR
b7f2					endif 
b7f2					FORTH_DSP_POP 
b7f2 cd c3 9d			call macro_forth_dsp_pop 
b7f5				endm 
# End of macro FORTH_DSP_POP
b7f5			 
b7f5					FORTH_DSP_VALUEHL    ; low range 
b7f5 cd 0b 9d			call macro_dsp_valuehl 
b7f8				endm 
# End of macro FORTH_DSP_VALUEHL
b7f8			 
b7f8					if DEBUG_FORTH_WORDS 
b7f8						DMARK "RN2" 
b7f8 f5				push af  
b7f9 3a 0d b8			ld a, (.dmark)  
b7fc 32 71 ee			ld (debug_mark),a  
b7ff 3a 0e b8			ld a, (.dmark+1)  
b802 32 72 ee			ld (debug_mark+1),a  
b805 3a 0f b8			ld a, (.dmark+2)  
b808 32 73 ee			ld (debug_mark+2),a  
b80b 18 03			jr .pastdmark  
b80d ..			.dmark: db "RN2"  
b810 f1			.pastdmark: pop af  
b811			endm  
# End of macro DMARK
b811						CALLMONITOR 
b811 cd a3 94			call break_point_state  
b814				endm  
# End of macro CALLMONITOR
b814					endif 
b814 22 b8 eb				ld (LFSRSeed+2), hl 
b817			 
b817					FORTH_DSP_POP 
b817 cd c3 9d			call macro_forth_dsp_pop 
b81a				endm 
# End of macro FORTH_DSP_POP
b81a			 
b81a e5					push hl 
b81b			 
b81b e1			.inrange:	pop hl 
b81c cd c9 8b				call prng16  
b81f					if DEBUG_FORTH_WORDS 
b81f						DMARK "RN3" 
b81f f5				push af  
b820 3a 34 b8			ld a, (.dmark)  
b823 32 71 ee			ld (debug_mark),a  
b826 3a 35 b8			ld a, (.dmark+1)  
b829 32 72 ee			ld (debug_mark+1),a  
b82c 3a 36 b8			ld a, (.dmark+2)  
b82f 32 73 ee			ld (debug_mark+2),a  
b832 18 03			jr .pastdmark  
b834 ..			.dmark: db "RN3"  
b837 f1			.pastdmark: pop af  
b838			endm  
# End of macro DMARK
b838						CALLMONITOR 
b838 cd a3 94			call break_point_state  
b83b				endm  
# End of macro CALLMONITOR
b83b					endif 
b83b					 
b83b					; if the range is 8bit knock out the high byte 
b83b			 
b83b ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
b83f			 
b83f 3e 00				ld a, 0 
b841 ba					cp d  
b842 20 1e				jr nz, .hirange 
b844 26 00				ld h, 0   ; knock it down to 8bit 
b846			 
b846					if DEBUG_FORTH_WORDS 
b846						DMARK "RNk" 
b846 f5				push af  
b847 3a 5b b8			ld a, (.dmark)  
b84a 32 71 ee			ld (debug_mark),a  
b84d 3a 5c b8			ld a, (.dmark+1)  
b850 32 72 ee			ld (debug_mark+1),a  
b853 3a 5d b8			ld a, (.dmark+2)  
b856 32 73 ee			ld (debug_mark+2),a  
b859 18 03			jr .pastdmark  
b85b ..			.dmark: db "RNk"  
b85e f1			.pastdmark: pop af  
b85f			endm  
# End of macro DMARK
b85f						CALLMONITOR 
b85f cd a3 94			call break_point_state  
b862				endm  
# End of macro CALLMONITOR
b862					endif 
b862			.hirange:   
b862 e5					push hl  
b863 b7					or a  
b864 ed 52		                sbc hl, de 
b866			 
b866					;call cmp16 
b866			 
b866 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b868 e1					pop hl 
b869 e5					push hl 
b86a			 
b86a					if DEBUG_FORTH_WORDS 
b86a						DMARK "RN4" 
b86a f5				push af  
b86b 3a 7f b8			ld a, (.dmark)  
b86e 32 71 ee			ld (debug_mark),a  
b871 3a 80 b8			ld a, (.dmark+1)  
b874 32 72 ee			ld (debug_mark+1),a  
b877 3a 81 b8			ld a, (.dmark+2)  
b87a 32 73 ee			ld (debug_mark+2),a  
b87d 18 03			jr .pastdmark  
b87f ..			.dmark: db "RN4"  
b882 f1			.pastdmark: pop af  
b883			endm  
# End of macro DMARK
b883						CALLMONITOR 
b883 cd a3 94			call break_point_state  
b886				endm  
# End of macro CALLMONITOR
b886					endif 
b886 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
b88a					;call cmp16 
b88a				 
b88a b7					or a  
b88b ed 52		                sbc hl, de 
b88d 38 8c				jr c, .inrange 
b88f			 
b88f e1					pop hl 
b890					 
b890					if DEBUG_FORTH_WORDS 
b890						DMARK "RNd" 
b890 f5				push af  
b891 3a a5 b8			ld a, (.dmark)  
b894 32 71 ee			ld (debug_mark),a  
b897 3a a6 b8			ld a, (.dmark+1)  
b89a 32 72 ee			ld (debug_mark+1),a  
b89d 3a a7 b8			ld a, (.dmark+2)  
b8a0 32 73 ee			ld (debug_mark+2),a  
b8a3 18 03			jr .pastdmark  
b8a5 ..			.dmark: db "RNd"  
b8a8 f1			.pastdmark: pop af  
b8a9			endm  
# End of macro DMARK
b8a9						CALLMONITOR 
b8a9 cd a3 94			call break_point_state  
b8ac				endm  
# End of macro CALLMONITOR
b8ac					endif 
b8ac			 
b8ac			 
b8ac cd 14 9b				call forth_push_numhl 
b8af				       NEXTW 
b8af c3 ba 9e			jp macro_next 
b8b2				endm 
# End of macro NEXTW
b8b2			 
b8b2			.ENDMATHS: 
b8b2			 
b8b2			; eof 
b8b2			 
# End of file forth_words_maths.asm
b8b2			include "forth_words_display.asm" 
b8b2			 
b8b2			; | ## Display Words 
b8b2			 
b8b2			.INFO: 
b8b2			 
b8b2				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b8b2 62				db WORD_SYS_CORE+78             
b8b3 cf b8			dw .ATP            
b8b5 05				db 4 + 1 
b8b6 .. 00			db "INFO",0              
b8bb				endm 
# End of macro CWHEAD
b8bb			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b8bb					FORTH_DSP_VALUEHL 
b8bb cd 0b 9d			call macro_dsp_valuehl 
b8be				endm 
# End of macro FORTH_DSP_VALUEHL
b8be			 
b8be					FORTH_DSP_POP 
b8be cd c3 9d			call macro_forth_dsp_pop 
b8c1				endm 
# End of macro FORTH_DSP_POP
b8c1			 
b8c1 e5					push hl 
b8c2			 
b8c2					FORTH_DSP_VALUEHL 
b8c2 cd 0b 9d			call macro_dsp_valuehl 
b8c5				endm 
# End of macro FORTH_DSP_VALUEHL
b8c5			 
b8c5					FORTH_DSP_POP 
b8c5 cd c3 9d			call macro_forth_dsp_pop 
b8c8				endm 
# End of macro FORTH_DSP_POP
b8c8			 
b8c8 d1					pop de 
b8c9			 
b8c9 cd 06 8a				call info_panel 
b8cc			 
b8cc			 
b8cc					NEXTW 
b8cc c3 ba 9e			jp macro_next 
b8cf				endm 
# End of macro NEXTW
b8cf			.ATP: 
b8cf				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b8cf 62				db WORD_SYS_CORE+78             
b8d0 46 b9			dw .FB            
b8d2 04				db 3 + 1 
b8d3 .. 00			db "AT?",0              
b8d7				endm 
# End of macro CWHEAD
b8d7			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b8d7					if DEBUG_FORTH_WORDS_KEY 
b8d7						DMARK "AT?" 
b8d7 f5				push af  
b8d8 3a ec b8			ld a, (.dmark)  
b8db 32 71 ee			ld (debug_mark),a  
b8de 3a ed b8			ld a, (.dmark+1)  
b8e1 32 72 ee			ld (debug_mark+1),a  
b8e4 3a ee b8			ld a, (.dmark+2)  
b8e7 32 73 ee			ld (debug_mark+2),a  
b8ea 18 03			jr .pastdmark  
b8ec ..			.dmark: db "AT?"  
b8ef f1			.pastdmark: pop af  
b8f0			endm  
# End of macro DMARK
b8f0						CALLMONITOR 
b8f0 cd a3 94			call break_point_state  
b8f3				endm  
# End of macro CALLMONITOR
b8f3					endif 
b8f3 3a 68 ea				ld a, (f_cursor_ptr) 
b8f6			 
b8f6			if DEBUG_FORTH_WORDS 
b8f6				DMARK "AT?" 
b8f6 f5				push af  
b8f7 3a 0b b9			ld a, (.dmark)  
b8fa 32 71 ee			ld (debug_mark),a  
b8fd 3a 0c b9			ld a, (.dmark+1)  
b900 32 72 ee			ld (debug_mark+1),a  
b903 3a 0d b9			ld a, (.dmark+2)  
b906 32 73 ee			ld (debug_mark+2),a  
b909 18 03			jr .pastdmark  
b90b ..			.dmark: db "AT?"  
b90e f1			.pastdmark: pop af  
b90f			endm  
# End of macro DMARK
b90f				CALLMONITOR 
b90f cd a3 94			call break_point_state  
b912				endm  
# End of macro CALLMONITOR
b912			endif	 
b912					; count the number of rows 
b912			 
b912 06 00				ld b, 0 
b914 4f			.atpr:		ld c, a    ; save in case we go below zero 
b915 d6 28				sub display_cols 
b917 f2 1d b9				jp p, .atprunder 
b91a 04					inc b 
b91b 18 f7				jr .atpr 
b91d			.atprunder:	 
b91d			if DEBUG_FORTH_WORDS 
b91d				DMARK "A?2" 
b91d f5				push af  
b91e 3a 32 b9			ld a, (.dmark)  
b921 32 71 ee			ld (debug_mark),a  
b924 3a 33 b9			ld a, (.dmark+1)  
b927 32 72 ee			ld (debug_mark+1),a  
b92a 3a 34 b9			ld a, (.dmark+2)  
b92d 32 73 ee			ld (debug_mark+2),a  
b930 18 03			jr .pastdmark  
b932 ..			.dmark: db "A?2"  
b935 f1			.pastdmark: pop af  
b936			endm  
# End of macro DMARK
b936				CALLMONITOR 
b936 cd a3 94			call break_point_state  
b939				endm  
# End of macro CALLMONITOR
b939			endif	 
b939 26 00				ld h, 0 
b93b 69					ld l, c 
b93c cd 14 9b				call forth_push_numhl 
b93f 68					ld l, b  
b940 cd 14 9b				call forth_push_numhl 
b943			 
b943			 
b943				NEXTW 
b943 c3 ba 9e			jp macro_next 
b946				endm 
# End of macro NEXTW
b946			 
b946			.FB: 
b946				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b946 1b				db WORD_SYS_CORE+7             
b947 94 b9			dw .EMIT            
b949 03				db 2 + 1 
b94a .. 00			db "FB",0              
b94d				endm 
# End of macro CWHEAD
b94d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b94d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b94d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b94d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b94d					if DEBUG_FORTH_WORDS_KEY 
b94d						DMARK "FB." 
b94d f5				push af  
b94e 3a 62 b9			ld a, (.dmark)  
b951 32 71 ee			ld (debug_mark),a  
b954 3a 63 b9			ld a, (.dmark+1)  
b957 32 72 ee			ld (debug_mark+1),a  
b95a 3a 64 b9			ld a, (.dmark+2)  
b95d 32 73 ee			ld (debug_mark+2),a  
b960 18 03			jr .pastdmark  
b962 ..			.dmark: db "FB."  
b965 f1			.pastdmark: pop af  
b966			endm  
# End of macro DMARK
b966						CALLMONITOR 
b966 cd a3 94			call break_point_state  
b969				endm  
# End of macro CALLMONITOR
b969					endif 
b969			 
b969					FORTH_DSP_VALUEHL 
b969 cd 0b 9d			call macro_dsp_valuehl 
b96c				endm 
# End of macro FORTH_DSP_VALUEHL
b96c			 
b96c 7d					ld a, l 
b96d fe 01				cp 1 
b96f 20 05				jr nz, .fbn1 
b971 21 16 ed				ld hl, display_fb1 
b974 18 15				jr .fbset 
b976 fe 02		.fbn1:		cp 2 
b978 20 05				jr nz, .fbn2 
b97a 21 d4 eb				ld hl, display_fb2 
b97d 18 0c				jr .fbset 
b97f fe 03		.fbn2:		cp 3 
b981 20 05				jr nz, .fbn3 
b983 21 75 ec				ld hl, display_fb3 
b986 18 03				jr .fbset 
b988			.fbn3:		 ; if invalid number select first 
b988 21 16 ed				ld hl, display_fb1 
b98b 22 d2 eb		.fbset:		ld (display_fb_active), hl 
b98e			 
b98e					FORTH_DSP_POP 
b98e cd c3 9d			call macro_forth_dsp_pop 
b991				endm 
# End of macro FORTH_DSP_POP
b991			 
b991					NEXTW 
b991 c3 ba 9e			jp macro_next 
b994				endm 
# End of macro NEXTW
b994			 
b994			 
b994			.EMIT: 
b994				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b994 1b				db WORD_SYS_CORE+7             
b995 e5 b9			dw .DOTH            
b997 05				db 4 + 1 
b998 .. 00			db "EMIT",0              
b99d				endm 
# End of macro CWHEAD
b99d			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b99d					; get value off TOS and display it 
b99d			 
b99d					if DEBUG_FORTH_WORDS_KEY 
b99d						DMARK "EMT" 
b99d f5				push af  
b99e 3a b2 b9			ld a, (.dmark)  
b9a1 32 71 ee			ld (debug_mark),a  
b9a4 3a b3 b9			ld a, (.dmark+1)  
b9a7 32 72 ee			ld (debug_mark+1),a  
b9aa 3a b4 b9			ld a, (.dmark+2)  
b9ad 32 73 ee			ld (debug_mark+2),a  
b9b0 18 03			jr .pastdmark  
b9b2 ..			.dmark: db "EMT"  
b9b5 f1			.pastdmark: pop af  
b9b6			endm  
# End of macro DMARK
b9b6						CALLMONITOR 
b9b6 cd a3 94			call break_point_state  
b9b9				endm  
# End of macro CALLMONITOR
b9b9					endif 
b9b9			 
b9b9					FORTH_DSP_VALUEHL 
b9b9 cd 0b 9d			call macro_dsp_valuehl 
b9bc				endm 
# End of macro FORTH_DSP_VALUEHL
b9bc			 
b9bc 7d					ld a,l 
b9bd			 
b9bd					; TODO write to display 
b9bd			 
b9bd 32 c9 e4				ld (os_input), a 
b9c0 3e 00				ld a, 0 
b9c2 32 ca e4				ld (os_input+1), a 
b9c5					 
b9c5 3a 68 ea				ld a, (f_cursor_ptr) 
b9c8 11 c9 e4				ld de, os_input 
b9cb cd 88 8a				call str_at_display 
b9ce			 
b9ce			 
b9ce 3a 46 ea				ld a,(cli_autodisplay) 
b9d1 fe 00				cp 0 
b9d3 28 03				jr z, .enoupdate 
b9d5 cd 98 8a						call update_display 
b9d8					.enoupdate: 
b9d8			 
b9d8 3a 68 ea				ld a, (f_cursor_ptr) 
b9db 3c					inc a 
b9dc 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
b9df			 
b9df			 
b9df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9df cd c3 9d			call macro_forth_dsp_pop 
b9e2				endm 
# End of macro FORTH_DSP_POP
b9e2			  
b9e2			 
b9e2					NEXTW 
b9e2 c3 ba 9e			jp macro_next 
b9e5				endm 
# End of macro NEXTW
b9e5			.DOTH: 
b9e5				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b9e5 1c				db WORD_SYS_CORE+8             
b9e6 15 ba			dw .DOTF            
b9e8 03				db 2 + 1 
b9e9 .. 00			db ".-",0              
b9ec				endm 
# End of macro CWHEAD
b9ec			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b9ec					; get value off TOS and display it 
b9ec					if DEBUG_FORTH_WORDS_KEY 
b9ec						DMARK "DTD" 
b9ec f5				push af  
b9ed 3a 01 ba			ld a, (.dmark)  
b9f0 32 71 ee			ld (debug_mark),a  
b9f3 3a 02 ba			ld a, (.dmark+1)  
b9f6 32 72 ee			ld (debug_mark+1),a  
b9f9 3a 03 ba			ld a, (.dmark+2)  
b9fc 32 73 ee			ld (debug_mark+2),a  
b9ff 18 03			jr .pastdmark  
ba01 ..			.dmark: db "DTD"  
ba04 f1			.pastdmark: pop af  
ba05			endm  
# End of macro DMARK
ba05						CALLMONITOR 
ba05 cd a3 94			call break_point_state  
ba08				endm  
# End of macro CALLMONITOR
ba08					endif 
ba08 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba0a 3e 00			ld a, 0 
ba0c 32 47 ea			ld (cli_mvdot), a 
ba0f c3 6c ba			jp .dotgo 
ba12				NEXTW 
ba12 c3 ba 9e			jp macro_next 
ba15				endm 
# End of macro NEXTW
ba15			.DOTF: 
ba15				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba15 1c				db WORD_SYS_CORE+8             
ba16 43 ba			dw .DOT            
ba18 03				db 2 + 1 
ba19 .. 00			db ".>",0              
ba1c				endm 
# End of macro CWHEAD
ba1c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
ba1c					; get value off TOS and display it 
ba1c			        ; TODO BUG adds extra spaces 
ba1c			        ; TODO BUG handle numerics? 
ba1c					if DEBUG_FORTH_WORDS_KEY 
ba1c						DMARK "DTC" 
ba1c f5				push af  
ba1d 3a 31 ba			ld a, (.dmark)  
ba20 32 71 ee			ld (debug_mark),a  
ba23 3a 32 ba			ld a, (.dmark+1)  
ba26 32 72 ee			ld (debug_mark+1),a  
ba29 3a 33 ba			ld a, (.dmark+2)  
ba2c 32 73 ee			ld (debug_mark+2),a  
ba2f 18 03			jr .pastdmark  
ba31 ..			.dmark: db "DTC"  
ba34 f1			.pastdmark: pop af  
ba35			endm  
# End of macro DMARK
ba35						CALLMONITOR 
ba35 cd a3 94			call break_point_state  
ba38				endm  
# End of macro CALLMONITOR
ba38					endif 
ba38 3e 01			ld a, 1 
ba3a 32 47 ea			ld (cli_mvdot), a 
ba3d c3 6c ba			jp .dotgo 
ba40				NEXTW 
ba40 c3 ba 9e			jp macro_next 
ba43				endm 
# End of macro NEXTW
ba43			 
ba43			.DOT: 
ba43				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
ba43 1c				db WORD_SYS_CORE+8             
ba44 1f bc			dw .CLS            
ba46 02				db 1 + 1 
ba47 .. 00			db ".",0              
ba49				endm 
# End of macro CWHEAD
ba49			        ; | . ( u -- ) Display TOS | DONE 
ba49					; get value off TOS and display it 
ba49			 
ba49					if DEBUG_FORTH_WORDS_KEY 
ba49						DMARK "DOT" 
ba49 f5				push af  
ba4a 3a 5e ba			ld a, (.dmark)  
ba4d 32 71 ee			ld (debug_mark),a  
ba50 3a 5f ba			ld a, (.dmark+1)  
ba53 32 72 ee			ld (debug_mark+1),a  
ba56 3a 60 ba			ld a, (.dmark+2)  
ba59 32 73 ee			ld (debug_mark+2),a  
ba5c 18 03			jr .pastdmark  
ba5e ..			.dmark: db "DOT"  
ba61 f1			.pastdmark: pop af  
ba62			endm  
# End of macro DMARK
ba62						CALLMONITOR 
ba62 cd a3 94			call break_point_state  
ba65				endm  
# End of macro CALLMONITOR
ba65					endif 
ba65 3e 00			ld a, 0 
ba67 32 47 ea			ld (cli_mvdot), a 
ba6a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
ba6c				 
ba6c			 
ba6c			.dotgo: 
ba6c			 
ba6c			; move up type to on stack for parserv5 
ba6c					FORTH_DSP 
ba6c cd d1 9c			call macro_forth_dsp 
ba6f				endm 
# End of macro FORTH_DSP
ba6f				;FORTH_DSP_VALUE  
ba6f			 
ba6f			if DEBUG_FORTH_DOT 
ba6f				DMARK "DOT" 
ba6f f5				push af  
ba70 3a 84 ba			ld a, (.dmark)  
ba73 32 71 ee			ld (debug_mark),a  
ba76 3a 85 ba			ld a, (.dmark+1)  
ba79 32 72 ee			ld (debug_mark+1),a  
ba7c 3a 86 ba			ld a, (.dmark+2)  
ba7f 32 73 ee			ld (debug_mark+2),a  
ba82 18 03			jr .pastdmark  
ba84 ..			.dmark: db "DOT"  
ba87 f1			.pastdmark: pop af  
ba88			endm  
# End of macro DMARK
ba88				CALLMONITOR 
ba88 cd a3 94			call break_point_state  
ba8b				endm  
# End of macro CALLMONITOR
ba8b			endif	 
ba8b			;		.print: 
ba8b			 
ba8b 7e				ld a,(hl)  ; work out what type of value is on the TOS 
ba8c 23				inc hl   ; position to the actual value 
ba8d fe 01			cp DS_TYPE_STR 
ba8f 20 06			jr nz, .dotnum1  
ba91			 
ba91			; display string 
ba91				FORTH_DSP_VALUE  
ba91 cd f4 9c			call macro_forth_dsp_value 
ba94				endm 
# End of macro FORTH_DSP_VALUE
ba94 eb				ex de,hl 
ba95 18 49			jr .dotwrite 
ba97			 
ba97			.dotnum1: 
ba97 fe 02			cp DS_TYPE_INUM 
ba99 20 44			jr nz, .dotflot 
ba9b			 
ba9b			 
ba9b			; display number 
ba9b			 
ba9b			;	push hl 
ba9b			;	call clear_display 
ba9b			;	pop hl 
ba9b			 
ba9b 5e				ld e, (hl) 
ba9c 23				inc hl 
ba9d 56				ld d, (hl) 
ba9e 21 cb e2			ld hl, scratch 
baa1			if DEBUG_FORTH_DOT 
baa1				DMARK "DT1" 
baa1 f5				push af  
baa2 3a b6 ba			ld a, (.dmark)  
baa5 32 71 ee			ld (debug_mark),a  
baa8 3a b7 ba			ld a, (.dmark+1)  
baab 32 72 ee			ld (debug_mark+1),a  
baae 3a b8 ba			ld a, (.dmark+2)  
bab1 32 73 ee			ld (debug_mark+2),a  
bab4 18 03			jr .pastdmark  
bab6 ..			.dmark: db "DT1"  
bab9 f1			.pastdmark: pop af  
baba			endm  
# End of macro DMARK
baba				CALLMONITOR 
baba cd a3 94			call break_point_state  
babd				endm  
# End of macro CALLMONITOR
babd			endif	 
babd			 
babd cd af 90			call uitoa_16 
bac0 eb				ex de,hl 
bac1			 
bac1			if DEBUG_FORTH_DOT 
bac1				DMARK "DT2" 
bac1 f5				push af  
bac2 3a d6 ba			ld a, (.dmark)  
bac5 32 71 ee			ld (debug_mark),a  
bac8 3a d7 ba			ld a, (.dmark+1)  
bacb 32 72 ee			ld (debug_mark+1),a  
bace 3a d8 ba			ld a, (.dmark+2)  
bad1 32 73 ee			ld (debug_mark+2),a  
bad4 18 03			jr .pastdmark  
bad6 ..			.dmark: db "DT2"  
bad9 f1			.pastdmark: pop af  
bada			endm  
# End of macro DMARK
bada				CALLMONITOR 
bada cd a3 94			call break_point_state  
badd				endm  
# End of macro CALLMONITOR
badd			endif	 
badd			 
badd			;	ld de, os_word_scratch 
badd 18 01			jr .dotwrite 
badf			 
badf 00			.dotflot:   nop 
bae0			; TODO print floating point number 
bae0			 
bae0			.dotwrite:		 
bae0			 
bae0					; if c is set then set all '-' to spaces 
bae0					; need to also take into account .>  
bae0			 
bae0 3e 01				ld a, 1 
bae2 b9					cp c 
bae3 20 67				jr nz, .nodashswap 
bae5			 
bae5					; DE has the string to write, working with HL 
bae5			 
bae5 06 ff				ld b, 255 
bae7 d5					push de 
bae8 e1					pop hl 
bae9			 
bae9			if DEBUG_FORTH_DOT 
bae9				DMARK "DT-" 
bae9 f5				push af  
baea 3a fe ba			ld a, (.dmark)  
baed 32 71 ee			ld (debug_mark),a  
baf0 3a ff ba			ld a, (.dmark+1)  
baf3 32 72 ee			ld (debug_mark+1),a  
baf6 3a 00 bb			ld a, (.dmark+2)  
baf9 32 73 ee			ld (debug_mark+2),a  
bafc 18 03			jr .pastdmark  
bafe ..			.dmark: db "DT-"  
bb01 f1			.pastdmark: pop af  
bb02			endm  
# End of macro DMARK
bb02				CALLMONITOR 
bb02 cd a3 94			call break_point_state  
bb05				endm  
# End of macro CALLMONITOR
bb05			endif	 
bb05 7e			.dashscan:	ld a, (hl) 
bb06 fe 00				cp 0 
bb08 28 42				jr z, .nodashswap 
bb0a fe 2d				cp '-' 
bb0c 20 03				jr nz, .dashskip 
bb0e 3e 20				ld a, ' ' 
bb10 77					ld (hl), a 
bb11 23			.dashskip:	inc hl 
bb12			if DEBUG_FORTH_DOT 
bb12				DMARK "D-2" 
bb12 f5				push af  
bb13 3a 27 bb			ld a, (.dmark)  
bb16 32 71 ee			ld (debug_mark),a  
bb19 3a 28 bb			ld a, (.dmark+1)  
bb1c 32 72 ee			ld (debug_mark+1),a  
bb1f 3a 29 bb			ld a, (.dmark+2)  
bb22 32 73 ee			ld (debug_mark+2),a  
bb25 18 03			jr .pastdmark  
bb27 ..			.dmark: db "D-2"  
bb2a f1			.pastdmark: pop af  
bb2b			endm  
# End of macro DMARK
bb2b				CALLMONITOR 
bb2b cd a3 94			call break_point_state  
bb2e				endm  
# End of macro CALLMONITOR
bb2e			endif	 
bb2e 10 d5				djnz .dashscan 
bb30			 
bb30			if DEBUG_FORTH_DOT 
bb30				DMARK "D-1" 
bb30 f5				push af  
bb31 3a 45 bb			ld a, (.dmark)  
bb34 32 71 ee			ld (debug_mark),a  
bb37 3a 46 bb			ld a, (.dmark+1)  
bb3a 32 72 ee			ld (debug_mark+1),a  
bb3d 3a 47 bb			ld a, (.dmark+2)  
bb40 32 73 ee			ld (debug_mark+2),a  
bb43 18 03			jr .pastdmark  
bb45 ..			.dmark: db "D-1"  
bb48 f1			.pastdmark: pop af  
bb49			endm  
# End of macro DMARK
bb49				CALLMONITOR 
bb49 cd a3 94			call break_point_state  
bb4c				endm  
# End of macro CALLMONITOR
bb4c			endif	 
bb4c			 
bb4c			.nodashswap: 
bb4c			 
bb4c			if DEBUG_FORTH_DOT 
bb4c				DMARK "D-o" 
bb4c f5				push af  
bb4d 3a 61 bb			ld a, (.dmark)  
bb50 32 71 ee			ld (debug_mark),a  
bb53 3a 62 bb			ld a, (.dmark+1)  
bb56 32 72 ee			ld (debug_mark+1),a  
bb59 3a 63 bb			ld a, (.dmark+2)  
bb5c 32 73 ee			ld (debug_mark+2),a  
bb5f 18 03			jr .pastdmark  
bb61 ..			.dmark: db "D-o"  
bb64 f1			.pastdmark: pop af  
bb65			endm  
# End of macro DMARK
bb65				CALLMONITOR 
bb65 cd a3 94			call break_point_state  
bb68				endm  
# End of macro CALLMONITOR
bb68			endif	 
bb68			 
bb68 d5					push de   ; save string start in case we need to advance print 
bb69			 
bb69 3a 68 ea				ld a, (f_cursor_ptr) 
bb6c cd 88 8a				call str_at_display 
bb6f 3a 46 ea				ld a,(cli_autodisplay) 
bb72 fe 00				cp 0 
bb74 28 03				jr z, .noupdate 
bb76 cd 98 8a						call update_display 
bb79					.noupdate: 
bb79			 
bb79			 
bb79					; see if we need to advance the print position 
bb79			 
bb79 e1					pop hl   ; get back string 
bb7a			;		ex de,hl 
bb7a			 
bb7a 3a 47 ea				ld a, (cli_mvdot) 
bb7d			if DEBUG_FORTH_DOT 
bb7d			;		ld e,a 
bb7d				DMARK "D>1" 
bb7d f5				push af  
bb7e 3a 92 bb			ld a, (.dmark)  
bb81 32 71 ee			ld (debug_mark),a  
bb84 3a 93 bb			ld a, (.dmark+1)  
bb87 32 72 ee			ld (debug_mark+1),a  
bb8a 3a 94 bb			ld a, (.dmark+2)  
bb8d 32 73 ee			ld (debug_mark+2),a  
bb90 18 03			jr .pastdmark  
bb92 ..			.dmark: db "D>1"  
bb95 f1			.pastdmark: pop af  
bb96			endm  
# End of macro DMARK
bb96				CALLMONITOR 
bb96 cd a3 94			call break_point_state  
bb99				endm  
# End of macro CALLMONITOR
bb99			endif	 
bb99 fe 00				cp 0 
bb9b 28 44				jr z, .noadv 
bb9d					; yes, lets advance the print position 
bb9d 3e 00				ld a, 0 
bb9f cd 0b 91				call strlent 
bba2			if DEBUG_FORTH_DOT 
bba2				DMARK "D-?" 
bba2 f5				push af  
bba3 3a b7 bb			ld a, (.dmark)  
bba6 32 71 ee			ld (debug_mark),a  
bba9 3a b8 bb			ld a, (.dmark+1)  
bbac 32 72 ee			ld (debug_mark+1),a  
bbaf 3a b9 bb			ld a, (.dmark+2)  
bbb2 32 73 ee			ld (debug_mark+2),a  
bbb5 18 03			jr .pastdmark  
bbb7 ..			.dmark: db "D-?"  
bbba f1			.pastdmark: pop af  
bbbb			endm  
# End of macro DMARK
bbbb				CALLMONITOR 
bbbb cd a3 94			call break_point_state  
bbbe				endm  
# End of macro CALLMONITOR
bbbe			endif	 
bbbe 3a 68 ea				ld a, (f_cursor_ptr) 
bbc1 85					add a,l 
bbc2					;call addatohl 
bbc2					;ld a, l 
bbc2 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
bbc5			 
bbc5			if DEBUG_FORTH_DOT 
bbc5				DMARK "D->" 
bbc5 f5				push af  
bbc6 3a da bb			ld a, (.dmark)  
bbc9 32 71 ee			ld (debug_mark),a  
bbcc 3a db bb			ld a, (.dmark+1)  
bbcf 32 72 ee			ld (debug_mark+1),a  
bbd2 3a dc bb			ld a, (.dmark+2)  
bbd5 32 73 ee			ld (debug_mark+2),a  
bbd8 18 03			jr .pastdmark  
bbda ..			.dmark: db "D->"  
bbdd f1			.pastdmark: pop af  
bbde			endm  
# End of macro DMARK
bbde				CALLMONITOR 
bbde cd a3 94			call break_point_state  
bbe1				endm  
# End of macro CALLMONITOR
bbe1			endif	 
bbe1			 
bbe1			.noadv:	 
bbe1			 
bbe1					if DEBUG_FORTH_DOT_WAIT 
bbe1							call next_page_prompt 
bbe1					endif	 
bbe1			; TODO this pop off the stack causes a crash. i dont know why 
bbe1			 
bbe1			 
bbe1			if DEBUG_FORTH_DOT 
bbe1				DMARK "DTh" 
bbe1 f5				push af  
bbe2 3a f6 bb			ld a, (.dmark)  
bbe5 32 71 ee			ld (debug_mark),a  
bbe8 3a f7 bb			ld a, (.dmark+1)  
bbeb 32 72 ee			ld (debug_mark+1),a  
bbee 3a f8 bb			ld a, (.dmark+2)  
bbf1 32 73 ee			ld (debug_mark+2),a  
bbf4 18 03			jr .pastdmark  
bbf6 ..			.dmark: db "DTh"  
bbf9 f1			.pastdmark: pop af  
bbfa			endm  
# End of macro DMARK
bbfa				CALLMONITOR 
bbfa cd a3 94			call break_point_state  
bbfd				endm  
# End of macro CALLMONITOR
bbfd			endif	 
bbfd			 
bbfd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbfd cd c3 9d			call macro_forth_dsp_pop 
bc00				endm 
# End of macro FORTH_DSP_POP
bc00			 
bc00			if DEBUG_FORTH_DOT 
bc00				DMARK "DTi" 
bc00 f5				push af  
bc01 3a 15 bc			ld a, (.dmark)  
bc04 32 71 ee			ld (debug_mark),a  
bc07 3a 16 bc			ld a, (.dmark+1)  
bc0a 32 72 ee			ld (debug_mark+1),a  
bc0d 3a 17 bc			ld a, (.dmark+2)  
bc10 32 73 ee			ld (debug_mark+2),a  
bc13 18 03			jr .pastdmark  
bc15 ..			.dmark: db "DTi"  
bc18 f1			.pastdmark: pop af  
bc19			endm  
# End of macro DMARK
bc19				CALLMONITOR 
bc19 cd a3 94			call break_point_state  
bc1c				endm  
# End of macro CALLMONITOR
bc1c			endif	 
bc1c			 
bc1c			 
bc1c					NEXTW 
bc1c c3 ba 9e			jp macro_next 
bc1f				endm 
# End of macro NEXTW
bc1f			 
bc1f			.CLS: 
bc1f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bc1f 35				db WORD_SYS_CORE+33             
bc20 4c bc			dw .DRAW            
bc22 04				db 3 + 1 
bc23 .. 00			db "CLS",0              
bc27				endm 
# End of macro CWHEAD
bc27			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bc27					if DEBUG_FORTH_WORDS_KEY 
bc27						DMARK "CLS" 
bc27 f5				push af  
bc28 3a 3c bc			ld a, (.dmark)  
bc2b 32 71 ee			ld (debug_mark),a  
bc2e 3a 3d bc			ld a, (.dmark+1)  
bc31 32 72 ee			ld (debug_mark+1),a  
bc34 3a 3e bc			ld a, (.dmark+2)  
bc37 32 73 ee			ld (debug_mark+2),a  
bc3a 18 03			jr .pastdmark  
bc3c ..			.dmark: db "CLS"  
bc3f f1			.pastdmark: pop af  
bc40			endm  
# End of macro DMARK
bc40						CALLMONITOR 
bc40 cd a3 94			call break_point_state  
bc43				endm  
# End of macro CALLMONITOR
bc43					endif 
bc43 cd 75 8a				call clear_display 
bc46 c3 5a bd				jp .home		; and home cursor 
bc49					NEXTW 
bc49 c3 ba 9e			jp macro_next 
bc4c				endm 
# End of macro NEXTW
bc4c			 
bc4c			.DRAW: 
bc4c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bc4c 36				db WORD_SYS_CORE+34             
bc4d 77 bc			dw .DUMP            
bc4f 05				db 4 + 1 
bc50 .. 00			db "DRAW",0              
bc55				endm 
# End of macro CWHEAD
bc55			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bc55					if DEBUG_FORTH_WORDS_KEY 
bc55						DMARK "DRW" 
bc55 f5				push af  
bc56 3a 6a bc			ld a, (.dmark)  
bc59 32 71 ee			ld (debug_mark),a  
bc5c 3a 6b bc			ld a, (.dmark+1)  
bc5f 32 72 ee			ld (debug_mark+1),a  
bc62 3a 6c bc			ld a, (.dmark+2)  
bc65 32 73 ee			ld (debug_mark+2),a  
bc68 18 03			jr .pastdmark  
bc6a ..			.dmark: db "DRW"  
bc6d f1			.pastdmark: pop af  
bc6e			endm  
# End of macro DMARK
bc6e						CALLMONITOR 
bc6e cd a3 94			call break_point_state  
bc71				endm  
# End of macro CALLMONITOR
bc71					endif 
bc71 cd 98 8a				call update_display 
bc74					NEXTW 
bc74 c3 ba 9e			jp macro_next 
bc77				endm 
# End of macro NEXTW
bc77			 
bc77			.DUMP: 
bc77				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bc77 37				db WORD_SYS_CORE+35             
bc78 af bc			dw .CDUMP            
bc7a 05				db 4 + 1 
bc7b .. 00			db "DUMP",0              
bc80				endm 
# End of macro CWHEAD
bc80			; | DUMP ( x -- ) With address x display dump   | DONE 
bc80			; TODO pop address to use off of the stack 
bc80					if DEBUG_FORTH_WORDS_KEY 
bc80						DMARK "DUM" 
bc80 f5				push af  
bc81 3a 95 bc			ld a, (.dmark)  
bc84 32 71 ee			ld (debug_mark),a  
bc87 3a 96 bc			ld a, (.dmark+1)  
bc8a 32 72 ee			ld (debug_mark+1),a  
bc8d 3a 97 bc			ld a, (.dmark+2)  
bc90 32 73 ee			ld (debug_mark+2),a  
bc93 18 03			jr .pastdmark  
bc95 ..			.dmark: db "DUM"  
bc98 f1			.pastdmark: pop af  
bc99			endm  
# End of macro DMARK
bc99						CALLMONITOR 
bc99 cd a3 94			call break_point_state  
bc9c				endm  
# End of macro CALLMONITOR
bc9c					endif 
bc9c cd 75 8a				call clear_display 
bc9f			 
bc9f					; get address 
bc9f			 
bc9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc9f cd 0b 9d			call macro_dsp_valuehl 
bca2				endm 
# End of macro FORTH_DSP_VALUEHL
bca2				 
bca2					; save it for cdump 
bca2			 
bca2 22 ee e5				ld (os_cur_ptr),hl 
bca5			 
bca5					; destroy value TOS 
bca5			 
bca5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bca5 cd c3 9d			call macro_forth_dsp_pop 
bca8				endm 
# End of macro FORTH_DSP_POP
bca8			 
bca8 cd 94 99				call dumpcont	; skip old style of param parsing	 
bcab c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bcac					NEXTW 
bcac c3 ba 9e			jp macro_next 
bcaf				endm 
# End of macro NEXTW
bcaf			.CDUMP: 
bcaf				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bcaf 38				db WORD_SYS_CORE+36             
bcb0 df bc			dw .DAT            
bcb2 06				db 5 + 1 
bcb3 .. 00			db "CDUMP",0              
bcb9				endm 
# End of macro CWHEAD
bcb9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bcb9					if DEBUG_FORTH_WORDS_KEY 
bcb9						DMARK "CDP" 
bcb9 f5				push af  
bcba 3a ce bc			ld a, (.dmark)  
bcbd 32 71 ee			ld (debug_mark),a  
bcc0 3a cf bc			ld a, (.dmark+1)  
bcc3 32 72 ee			ld (debug_mark+1),a  
bcc6 3a d0 bc			ld a, (.dmark+2)  
bcc9 32 73 ee			ld (debug_mark+2),a  
bccc 18 03			jr .pastdmark  
bcce ..			.dmark: db "CDP"  
bcd1 f1			.pastdmark: pop af  
bcd2			endm  
# End of macro DMARK
bcd2						CALLMONITOR 
bcd2 cd a3 94			call break_point_state  
bcd5				endm  
# End of macro CALLMONITOR
bcd5					endif 
bcd5 cd 75 8a				call clear_display 
bcd8 cd 94 99				call dumpcont	 
bcdb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bcdc					NEXTW 
bcdc c3 ba 9e			jp macro_next 
bcdf				endm 
# End of macro NEXTW
bcdf			 
bcdf			 
bcdf			 
bcdf			 
bcdf			.DAT: 
bcdf				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bcdf 3d				db WORD_SYS_CORE+41             
bce0 35 bd			dw .HOME            
bce2 03				db 2 + 1 
bce3 .. 00			db "AT",0              
bce6				endm 
# End of macro CWHEAD
bce6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bce6					if DEBUG_FORTH_WORDS_KEY 
bce6						DMARK "AT." 
bce6 f5				push af  
bce7 3a fb bc			ld a, (.dmark)  
bcea 32 71 ee			ld (debug_mark),a  
bced 3a fc bc			ld a, (.dmark+1)  
bcf0 32 72 ee			ld (debug_mark+1),a  
bcf3 3a fd bc			ld a, (.dmark+2)  
bcf6 32 73 ee			ld (debug_mark+2),a  
bcf9 18 03			jr .pastdmark  
bcfb ..			.dmark: db "AT."  
bcfe f1			.pastdmark: pop af  
bcff			endm  
# End of macro DMARK
bcff						CALLMONITOR 
bcff cd a3 94			call break_point_state  
bd02				endm  
# End of macro CALLMONITOR
bd02					endif 
bd02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd02 cd 0b 9d			call macro_dsp_valuehl 
bd05				endm 
# End of macro FORTH_DSP_VALUEHL
bd05			 
bd05			 
bd05					; TODO save cursor row 
bd05 7d					ld a,l 
bd06 fe 02				cp 2 
bd08 20 04				jr nz, .crow3 
bd0a 3e 28				ld a, display_row_2 
bd0c 18 12				jr .ccol1 
bd0e fe 03		.crow3:		cp 3 
bd10 20 04				jr nz, .crow4 
bd12 3e 50				ld a, display_row_3 
bd14 18 0a				jr .ccol1 
bd16 fe 04		.crow4:		cp 4 
bd18 20 04				jr nz, .crow1 
bd1a 3e 78				ld a, display_row_4 
bd1c 18 02				jr .ccol1 
bd1e 3e 00		.crow1:		ld a,display_row_1 
bd20 f5			.ccol1:		push af			; got row offset 
bd21 6f					ld l,a 
bd22 26 00				ld h,0 
bd24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd24 cd c3 9d			call macro_forth_dsp_pop 
bd27				endm 
# End of macro FORTH_DSP_POP
bd27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd27 cd 0b 9d			call macro_dsp_valuehl 
bd2a				endm 
# End of macro FORTH_DSP_VALUEHL
bd2a					; TODO save cursor col 
bd2a f1					pop af 
bd2b 85					add l		; add col offset 
bd2c 32 68 ea				ld (f_cursor_ptr), a 
bd2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd2f cd c3 9d			call macro_forth_dsp_pop 
bd32				endm 
# End of macro FORTH_DSP_POP
bd32			 
bd32					; calculate  
bd32			 
bd32					NEXTW 
bd32 c3 ba 9e			jp macro_next 
bd35				endm 
# End of macro NEXTW
bd35			 
bd35			 
bd35			.HOME: 
bd35				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bd35 41				db WORD_SYS_CORE+45             
bd36 62 bd			dw .SPACE            
bd38 05				db 4 + 1 
bd39 .. 00			db "HOME",0              
bd3e				endm 
# End of macro CWHEAD
bd3e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bd3e					if DEBUG_FORTH_WORDS_KEY 
bd3e						DMARK "HOM" 
bd3e f5				push af  
bd3f 3a 53 bd			ld a, (.dmark)  
bd42 32 71 ee			ld (debug_mark),a  
bd45 3a 54 bd			ld a, (.dmark+1)  
bd48 32 72 ee			ld (debug_mark+1),a  
bd4b 3a 55 bd			ld a, (.dmark+2)  
bd4e 32 73 ee			ld (debug_mark+2),a  
bd51 18 03			jr .pastdmark  
bd53 ..			.dmark: db "HOM"  
bd56 f1			.pastdmark: pop af  
bd57			endm  
# End of macro DMARK
bd57						CALLMONITOR 
bd57 cd a3 94			call break_point_state  
bd5a				endm  
# End of macro CALLMONITOR
bd5a					endif 
bd5a 3e 00		.home:		ld a, 0		; and home cursor 
bd5c 32 68 ea				ld (f_cursor_ptr), a 
bd5f					NEXTW 
bd5f c3 ba 9e			jp macro_next 
bd62				endm 
# End of macro NEXTW
bd62			 
bd62			 
bd62			.SPACE: 
bd62				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bd62 46				db WORD_SYS_CORE+50             
bd63 90 bd			dw .SPACES            
bd65 03				db 2 + 1 
bd66 .. 00			db "BL",0              
bd69				endm 
# End of macro CWHEAD
bd69			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bd69					if DEBUG_FORTH_WORDS_KEY 
bd69						DMARK "BL." 
bd69 f5				push af  
bd6a 3a 7e bd			ld a, (.dmark)  
bd6d 32 71 ee			ld (debug_mark),a  
bd70 3a 7f bd			ld a, (.dmark+1)  
bd73 32 72 ee			ld (debug_mark+1),a  
bd76 3a 80 bd			ld a, (.dmark+2)  
bd79 32 73 ee			ld (debug_mark+2),a  
bd7c 18 03			jr .pastdmark  
bd7e ..			.dmark: db "BL."  
bd81 f1			.pastdmark: pop af  
bd82			endm  
# End of macro DMARK
bd82						CALLMONITOR 
bd82 cd a3 94			call break_point_state  
bd85				endm  
# End of macro CALLMONITOR
bd85					endif 
bd85 21 8e bd				ld hl, .blstr 
bd88 cd 82 9b				call forth_push_str 
bd8b					 
bd8b				       NEXTW 
bd8b c3 ba 9e			jp macro_next 
bd8e				endm 
# End of macro NEXTW
bd8e			 
bd8e .. 00		.blstr: db " ", 0 
bd90			 
bd90			.SPACES: 
bd90				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bd90 47				db WORD_SYS_CORE+51             
bd91 2b be			dw .SCROLL            
bd93 07				db 6 + 1 
bd94 .. 00			db "SPACES",0              
bd9b				endm 
# End of macro CWHEAD
bd9b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
bd9b					if DEBUG_FORTH_WORDS_KEY 
bd9b						DMARK "SPS" 
bd9b f5				push af  
bd9c 3a b0 bd			ld a, (.dmark)  
bd9f 32 71 ee			ld (debug_mark),a  
bda2 3a b1 bd			ld a, (.dmark+1)  
bda5 32 72 ee			ld (debug_mark+1),a  
bda8 3a b2 bd			ld a, (.dmark+2)  
bdab 32 73 ee			ld (debug_mark+2),a  
bdae 18 03			jr .pastdmark  
bdb0 ..			.dmark: db "SPS"  
bdb3 f1			.pastdmark: pop af  
bdb4			endm  
# End of macro DMARK
bdb4						CALLMONITOR 
bdb4 cd a3 94			call break_point_state  
bdb7				endm  
# End of macro CALLMONITOR
bdb7					endif 
bdb7			 
bdb7			 
bdb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdb7 cd 0b 9d			call macro_dsp_valuehl 
bdba				endm 
# End of macro FORTH_DSP_VALUEHL
bdba			 
bdba			;		push hl    ; u 
bdba					if DEBUG_FORTH_WORDS 
bdba						DMARK "SPA" 
bdba f5				push af  
bdbb 3a cf bd			ld a, (.dmark)  
bdbe 32 71 ee			ld (debug_mark),a  
bdc1 3a d0 bd			ld a, (.dmark+1)  
bdc4 32 72 ee			ld (debug_mark+1),a  
bdc7 3a d1 bd			ld a, (.dmark+2)  
bdca 32 73 ee			ld (debug_mark+2),a  
bdcd 18 03			jr .pastdmark  
bdcf ..			.dmark: db "SPA"  
bdd2 f1			.pastdmark: pop af  
bdd3			endm  
# End of macro DMARK
bdd3						CALLMONITOR 
bdd3 cd a3 94			call break_point_state  
bdd6				endm  
# End of macro CALLMONITOR
bdd6					endif 
bdd6			 
bdd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdd6 cd c3 9d			call macro_forth_dsp_pop 
bdd9				endm 
# End of macro FORTH_DSP_POP
bdd9			;		pop hl 
bdd9 4d					ld c, l 
bdda 06 00				ld b, 0 
bddc 21 cb e2				ld hl, scratch  
bddf			 
bddf					if DEBUG_FORTH_WORDS 
bddf						DMARK "SP2" 
bddf f5				push af  
bde0 3a f4 bd			ld a, (.dmark)  
bde3 32 71 ee			ld (debug_mark),a  
bde6 3a f5 bd			ld a, (.dmark+1)  
bde9 32 72 ee			ld (debug_mark+1),a  
bdec 3a f6 bd			ld a, (.dmark+2)  
bdef 32 73 ee			ld (debug_mark+2),a  
bdf2 18 03			jr .pastdmark  
bdf4 ..			.dmark: db "SP2"  
bdf7 f1			.pastdmark: pop af  
bdf8			endm  
# End of macro DMARK
bdf8						CALLMONITOR 
bdf8 cd a3 94			call break_point_state  
bdfb				endm  
# End of macro CALLMONITOR
bdfb					endif 
bdfb 3e 20				ld a, ' ' 
bdfd c5			.spaces1:	push bc 
bdfe 77					ld (hl),a 
bdff 23					inc hl 
be00 c1					pop bc 
be01 10 fa				djnz .spaces1 
be03 3e 00				ld a,0 
be05 77					ld (hl),a 
be06 21 cb e2				ld hl, scratch 
be09					if DEBUG_FORTH_WORDS 
be09						DMARK "SP3" 
be09 f5				push af  
be0a 3a 1e be			ld a, (.dmark)  
be0d 32 71 ee			ld (debug_mark),a  
be10 3a 1f be			ld a, (.dmark+1)  
be13 32 72 ee			ld (debug_mark+1),a  
be16 3a 20 be			ld a, (.dmark+2)  
be19 32 73 ee			ld (debug_mark+2),a  
be1c 18 03			jr .pastdmark  
be1e ..			.dmark: db "SP3"  
be21 f1			.pastdmark: pop af  
be22			endm  
# End of macro DMARK
be22						CALLMONITOR 
be22 cd a3 94			call break_point_state  
be25				endm  
# End of macro CALLMONITOR
be25					endif 
be25 cd 7d 9c				call forth_apush 
be28			 
be28				       NEXTW 
be28 c3 ba 9e			jp macro_next 
be2b				endm 
# End of macro NEXTW
be2b			 
be2b			 
be2b			 
be2b			.SCROLL: 
be2b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
be2b 53				db WORD_SYS_CORE+63             
be2c 58 be			dw .SCROLLD            
be2e 07				db 6 + 1 
be2f .. 00			db "SCROLL",0              
be36				endm 
# End of macro CWHEAD
be36			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
be36					if DEBUG_FORTH_WORDS_KEY 
be36						DMARK "SCR" 
be36 f5				push af  
be37 3a 4b be			ld a, (.dmark)  
be3a 32 71 ee			ld (debug_mark),a  
be3d 3a 4c be			ld a, (.dmark+1)  
be40 32 72 ee			ld (debug_mark+1),a  
be43 3a 4d be			ld a, (.dmark+2)  
be46 32 73 ee			ld (debug_mark+2),a  
be49 18 03			jr .pastdmark  
be4b ..			.dmark: db "SCR"  
be4e f1			.pastdmark: pop af  
be4f			endm  
# End of macro DMARK
be4f						CALLMONITOR 
be4f cd a3 94			call break_point_state  
be52				endm  
# End of macro CALLMONITOR
be52					endif 
be52			 
be52 cd 37 8a			call scroll_up 
be55			;	call update_display 
be55			 
be55					NEXTW 
be55 c3 ba 9e			jp macro_next 
be58				endm 
# End of macro NEXTW
be58			 
be58			 
be58			 
be58			;		; get dir 
be58			; 
be58			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be58			; 
be58			;		push hl 
be58			; 
be58			;		; destroy value TOS 
be58			; 
be58			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be58			; 
be58			;		; get count 
be58			; 
be58			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be58			; 
be58			;		push hl 
be58			; 
be58			;		; destroy value TOS 
be58			; 
be58			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be58			; 
be58			;		; one value on hl get other one back 
be58			; 
be58			;		pop bc    ; count 
be58			; 
be58			;		pop de   ; dir 
be58			; 
be58			; 
be58			;		ld b, c 
be58			; 
be58			;.scrolldir:     push bc 
be58			;		push de 
be58			; 
be58			;		ld a, 0 
be58			;		cp e 
be58			;		jr z, .scrollup  
be58			;		call scroll_down 
be58			;		jr .scrollnext 
be58			;.scrollup:	call scroll_up 
be58			; 
be58			;		 
be58			;.scrollnext: 
be58			;		pop de 
be58			;		pop bc 
be58			;		djnz .scrolldir 
be58			; 
be58			; 
be58			; 
be58			; 
be58			; 
be58			;		NEXTW 
be58			 
be58			.SCROLLD: 
be58				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
be58 53				db WORD_SYS_CORE+63             
be59 86 be			dw .ATQ            
be5b 08				db 7 + 1 
be5c .. 00			db "SCROLLD",0              
be64				endm 
# End of macro CWHEAD
be64			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
be64					if DEBUG_FORTH_WORDS_KEY 
be64						DMARK "SCD" 
be64 f5				push af  
be65 3a 79 be			ld a, (.dmark)  
be68 32 71 ee			ld (debug_mark),a  
be6b 3a 7a be			ld a, (.dmark+1)  
be6e 32 72 ee			ld (debug_mark+1),a  
be71 3a 7b be			ld a, (.dmark+2)  
be74 32 73 ee			ld (debug_mark+2),a  
be77 18 03			jr .pastdmark  
be79 ..			.dmark: db "SCD"  
be7c f1			.pastdmark: pop af  
be7d			endm  
# End of macro DMARK
be7d						CALLMONITOR 
be7d cd a3 94			call break_point_state  
be80				endm  
# End of macro CALLMONITOR
be80					endif 
be80			 
be80 cd 5b 8a			call scroll_down 
be83			;	call update_display 
be83			 
be83					NEXTW 
be83 c3 ba 9e			jp macro_next 
be86				endm 
# End of macro NEXTW
be86			 
be86			 
be86			.ATQ: 
be86				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
be86 62				db WORD_SYS_CORE+78             
be87 e4 be			dw .AUTODSP            
be89 04				db 3 + 1 
be8a .. 00			db "AT@",0              
be8e				endm 
# End of macro CWHEAD
be8e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
be8e					if DEBUG_FORTH_WORDS_KEY 
be8e						DMARK "ATA" 
be8e f5				push af  
be8f 3a a3 be			ld a, (.dmark)  
be92 32 71 ee			ld (debug_mark),a  
be95 3a a4 be			ld a, (.dmark+1)  
be98 32 72 ee			ld (debug_mark+1),a  
be9b 3a a5 be			ld a, (.dmark+2)  
be9e 32 73 ee			ld (debug_mark+2),a  
bea1 18 03			jr .pastdmark  
bea3 ..			.dmark: db "ATA"  
bea6 f1			.pastdmark: pop af  
bea7			endm  
# End of macro DMARK
bea7						CALLMONITOR 
bea7 cd a3 94			call break_point_state  
beaa				endm  
# End of macro CALLMONITOR
beaa					endif 
beaa			 
beaa			 
beaa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beaa cd 0b 9d			call macro_dsp_valuehl 
bead				endm 
# End of macro FORTH_DSP_VALUEHL
bead			 
bead					; TODO save cursor row 
bead 7d					ld a,l 
beae fe 02				cp 2 
beb0 20 04				jr nz, .crow3aq 
beb2 3e 28				ld a, display_row_2 
beb4 18 12				jr .ccol1aq 
beb6 fe 03		.crow3aq:		cp 3 
beb8 20 04				jr nz, .crow4aq 
beba 3e 50				ld a, display_row_3 
bebc 18 0a				jr .ccol1aq 
bebe fe 04		.crow4aq:		cp 4 
bec0 20 04				jr nz, .crow1aq 
bec2 3e 78				ld a, display_row_4 
bec4 18 02				jr .ccol1aq 
bec6 3e 00		.crow1aq:		ld a,display_row_1 
bec8 f5			.ccol1aq:		push af			; got row offset 
bec9 6f					ld l,a 
beca 26 00				ld h,0 
becc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
becc cd c3 9d			call macro_forth_dsp_pop 
becf				endm 
# End of macro FORTH_DSP_POP
becf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
becf cd 0b 9d			call macro_dsp_valuehl 
bed2				endm 
# End of macro FORTH_DSP_VALUEHL
bed2					; TODO save cursor col 
bed2 f1					pop af 
bed3 85					add l		; add col offset 
bed4			 
bed4					; add current frame buffer address 
bed4 2a d2 eb				ld hl, (display_fb_active) 
bed7 cd a2 8c				call addatohl 
beda			 
beda			 
beda			 
beda			 
beda					; get char frame buffer location offset in hl 
beda			 
beda 7e					ld a,(hl) 
bedb 26 00				ld h, 0 
bedd 6f					ld l, a 
bede			 
bede cd 14 9b				call forth_push_numhl 
bee1			 
bee1			 
bee1					NEXTW 
bee1 c3 ba 9e			jp macro_next 
bee4				endm 
# End of macro NEXTW
bee4			 
bee4			.AUTODSP: 
bee4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bee4 63				db WORD_SYS_CORE+79             
bee5 fa be			dw .MENU            
bee7 05				db 4 + 1 
bee8 .. 00			db "ADSP",0              
beed				endm 
# End of macro CWHEAD
beed			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
beed			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
beed			 
beed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beed cd 0b 9d			call macro_dsp_valuehl 
bef0				endm 
# End of macro FORTH_DSP_VALUEHL
bef0			 
bef0			;		push hl 
bef0			 
bef0					; destroy value TOS 
bef0			 
bef0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bef0 cd c3 9d			call macro_forth_dsp_pop 
bef3				endm 
# End of macro FORTH_DSP_POP
bef3			 
bef3			;		pop hl 
bef3			 
bef3 7d					ld a,l 
bef4 32 46 ea				ld (cli_autodisplay), a 
bef7				       NEXTW 
bef7 c3 ba 9e			jp macro_next 
befa				endm 
# End of macro NEXTW
befa			 
befa			.MENU: 
befa				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
befa 70				db WORD_SYS_CORE+92             
befb a3 bf			dw .ENDDISPLAY            
befd 05				db 4 + 1 
befe .. 00			db "MENU",0              
bf03				endm 
# End of macro CWHEAD
bf03			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bf03			 
bf03			;		; get number of items on the stack 
bf03			; 
bf03				 
bf03					FORTH_DSP_VALUEHL 
bf03 cd 0b 9d			call macro_dsp_valuehl 
bf06				endm 
# End of macro FORTH_DSP_VALUEHL
bf06				 
bf06					if DEBUG_FORTH_WORDS_KEY 
bf06						DMARK "MNU" 
bf06 f5				push af  
bf07 3a 1b bf			ld a, (.dmark)  
bf0a 32 71 ee			ld (debug_mark),a  
bf0d 3a 1c bf			ld a, (.dmark+1)  
bf10 32 72 ee			ld (debug_mark+1),a  
bf13 3a 1d bf			ld a, (.dmark+2)  
bf16 32 73 ee			ld (debug_mark+2),a  
bf19 18 03			jr .pastdmark  
bf1b ..			.dmark: db "MNU"  
bf1e f1			.pastdmark: pop af  
bf1f			endm  
# End of macro DMARK
bf1f						CALLMONITOR 
bf1f cd a3 94			call break_point_state  
bf22				endm  
# End of macro CALLMONITOR
bf22					endif 
bf22			 
bf22 45					ld b, l	 
bf23 05					dec b 
bf24			 
bf24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf24 cd c3 9d			call macro_forth_dsp_pop 
bf27				endm 
# End of macro FORTH_DSP_POP
bf27			 
bf27			 
bf27					; go directly through the stack to pluck out the string pointers and build an array 
bf27			 
bf27			;		FORTH_DSP 
bf27			 
bf27					; hl contains top most stack item 
bf27				 
bf27 11 cb e2				ld de, scratch 
bf2a			 
bf2a			.mbuild: 
bf2a			 
bf2a					FORTH_DSP_VALUEHL 
bf2a cd 0b 9d			call macro_dsp_valuehl 
bf2d				endm 
# End of macro FORTH_DSP_VALUEHL
bf2d			 
bf2d					if DEBUG_FORTH_WORDS 
bf2d						DMARK "MN3" 
bf2d f5				push af  
bf2e 3a 42 bf			ld a, (.dmark)  
bf31 32 71 ee			ld (debug_mark),a  
bf34 3a 43 bf			ld a, (.dmark+1)  
bf37 32 72 ee			ld (debug_mark+1),a  
bf3a 3a 44 bf			ld a, (.dmark+2)  
bf3d 32 73 ee			ld (debug_mark+2),a  
bf40 18 03			jr .pastdmark  
bf42 ..			.dmark: db "MN3"  
bf45 f1			.pastdmark: pop af  
bf46			endm  
# End of macro DMARK
bf46						CALLMONITOR 
bf46 cd a3 94			call break_point_state  
bf49				endm  
# End of macro CALLMONITOR
bf49					endif 
bf49 eb					ex de, hl 
bf4a 73					ld (hl), e 
bf4b 23					inc hl 
bf4c 72					ld (hl), d 
bf4d 23					inc hl 
bf4e eb					ex de, hl 
bf4f			 
bf4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf4f cd c3 9d			call macro_forth_dsp_pop 
bf52				endm 
# End of macro FORTH_DSP_POP
bf52			 
bf52 10 d6				djnz .mbuild 
bf54			 
bf54					; done add term 
bf54			 
bf54 eb					ex de, hl 
bf55 36 00				ld (hl), 0 
bf57 23					inc hl 
bf58 36 00				ld (hl), 0 
bf5a			 
bf5a				 
bf5a					 
bf5a 21 cb e2				ld hl, scratch 
bf5d			 
bf5d					if DEBUG_FORTH_WORDS 
bf5d						DMARK "MNx" 
bf5d f5				push af  
bf5e 3a 72 bf			ld a, (.dmark)  
bf61 32 71 ee			ld (debug_mark),a  
bf64 3a 73 bf			ld a, (.dmark+1)  
bf67 32 72 ee			ld (debug_mark+1),a  
bf6a 3a 74 bf			ld a, (.dmark+2)  
bf6d 32 73 ee			ld (debug_mark+2),a  
bf70 18 03			jr .pastdmark  
bf72 ..			.dmark: db "MNx"  
bf75 f1			.pastdmark: pop af  
bf76			endm  
# End of macro DMARK
bf76						CALLMONITOR 
bf76 cd a3 94			call break_point_state  
bf79				endm  
# End of macro CALLMONITOR
bf79					endif 
bf79			 
bf79			 
bf79			 
bf79 3e 00				ld a, 0 
bf7b cd a6 8a				call menu 
bf7e			 
bf7e			 
bf7e 6f					ld l, a 
bf7f 26 00				ld h, 0 
bf81			 
bf81					if DEBUG_FORTH_WORDS 
bf81						DMARK "MNr" 
bf81 f5				push af  
bf82 3a 96 bf			ld a, (.dmark)  
bf85 32 71 ee			ld (debug_mark),a  
bf88 3a 97 bf			ld a, (.dmark+1)  
bf8b 32 72 ee			ld (debug_mark+1),a  
bf8e 3a 98 bf			ld a, (.dmark+2)  
bf91 32 73 ee			ld (debug_mark+2),a  
bf94 18 03			jr .pastdmark  
bf96 ..			.dmark: db "MNr"  
bf99 f1			.pastdmark: pop af  
bf9a			endm  
# End of macro DMARK
bf9a						CALLMONITOR 
bf9a cd a3 94			call break_point_state  
bf9d				endm  
# End of macro CALLMONITOR
bf9d					endif 
bf9d			 
bf9d cd 14 9b				call forth_push_numhl 
bfa0			 
bfa0			 
bfa0			 
bfa0			 
bfa0				       NEXTW 
bfa0 c3 ba 9e			jp macro_next 
bfa3				endm 
# End of macro NEXTW
bfa3			 
bfa3			 
bfa3			.ENDDISPLAY: 
bfa3			 
bfa3			; eof 
# End of file forth_words_display.asm
bfa3			include "forth_words_str.asm" 
bfa3			 
bfa3			; | ## String Words 
bfa3			 
bfa3			.PTR:   
bfa3			 
bfa3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bfa3 48				db WORD_SYS_CORE+52             
bfa4 d0 bf			dw .STYPE            
bfa6 04				db 3 + 1 
bfa7 .. 00			db "PTR",0              
bfab				endm 
# End of macro CWHEAD
bfab			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bfab			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bfab			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bfab			 
bfab					if DEBUG_FORTH_WORDS_KEY 
bfab						DMARK "PTR" 
bfab f5				push af  
bfac 3a c0 bf			ld a, (.dmark)  
bfaf 32 71 ee			ld (debug_mark),a  
bfb2 3a c1 bf			ld a, (.dmark+1)  
bfb5 32 72 ee			ld (debug_mark+1),a  
bfb8 3a c2 bf			ld a, (.dmark+2)  
bfbb 32 73 ee			ld (debug_mark+2),a  
bfbe 18 03			jr .pastdmark  
bfc0 ..			.dmark: db "PTR"  
bfc3 f1			.pastdmark: pop af  
bfc4			endm  
# End of macro DMARK
bfc4						CALLMONITOR 
bfc4 cd a3 94			call break_point_state  
bfc7				endm  
# End of macro CALLMONITOR
bfc7					endif 
bfc7					FORTH_DSP_VALUEHL 
bfc7 cd 0b 9d			call macro_dsp_valuehl 
bfca				endm 
# End of macro FORTH_DSP_VALUEHL
bfca cd 14 9b				call forth_push_numhl 
bfcd			 
bfcd			 
bfcd					NEXTW 
bfcd c3 ba 9e			jp macro_next 
bfd0				endm 
# End of macro NEXTW
bfd0			.STYPE: 
bfd0				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bfd0 48				db WORD_SYS_CORE+52             
bfd1 1f c0			dw .UPPER            
bfd3 06				db 5 + 1 
bfd4 .. 00			db "STYPE",0              
bfda				endm 
# End of macro CWHEAD
bfda			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bfda					if DEBUG_FORTH_WORDS_KEY 
bfda						DMARK "STY" 
bfda f5				push af  
bfdb 3a ef bf			ld a, (.dmark)  
bfde 32 71 ee			ld (debug_mark),a  
bfe1 3a f0 bf			ld a, (.dmark+1)  
bfe4 32 72 ee			ld (debug_mark+1),a  
bfe7 3a f1 bf			ld a, (.dmark+2)  
bfea 32 73 ee			ld (debug_mark+2),a  
bfed 18 03			jr .pastdmark  
bfef ..			.dmark: db "STY"  
bff2 f1			.pastdmark: pop af  
bff3			endm  
# End of macro DMARK
bff3						CALLMONITOR 
bff3 cd a3 94			call break_point_state  
bff6				endm  
# End of macro CALLMONITOR
bff6					endif 
bff6					FORTH_DSP 
bff6 cd d1 9c			call macro_forth_dsp 
bff9				endm 
# End of macro FORTH_DSP
bff9					;v5 FORTH_DSP_VALUE 
bff9			 
bff9 7e					ld a, (hl) 
bffa			 
bffa f5					push af 
bffb			 
bffb			; Dont destroy TOS		FORTH_DSP_POP 
bffb			 
bffb f1					pop af 
bffc			 
bffc fe 01				cp DS_TYPE_STR 
bffe 28 09				jr z, .typestr 
c000			 
c000 fe 02				cp DS_TYPE_INUM 
c002 28 0a				jr z, .typeinum 
c004			 
c004 21 1d c0				ld hl, .tna 
c007 18 0a				jr .tpush 
c009			 
c009 21 19 c0		.typestr:	ld hl, .tstr 
c00c 18 05				jr .tpush 
c00e 21 1b c0		.typeinum:	ld hl, .tinum 
c011 18 00				jr .tpush 
c013			 
c013			.tpush: 
c013			 
c013 cd 82 9b				call forth_push_str 
c016			 
c016					NEXTW 
c016 c3 ba 9e			jp macro_next 
c019				endm 
# End of macro NEXTW
c019 .. 00		.tstr:	db "s",0 
c01b .. 00		.tinum:  db "i",0 
c01d .. 00		.tna:   db "?", 0 
c01f			 
c01f			 
c01f			.UPPER: 
c01f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c01f 48				db WORD_SYS_CORE+52             
c020 5a c0			dw .LOWER            
c022 06				db 5 + 1 
c023 .. 00			db "UPPER",0              
c029				endm 
# End of macro CWHEAD
c029			; | UPPER ( s -- s ) Upper case string s  | DONE 
c029					if DEBUG_FORTH_WORDS_KEY 
c029						DMARK "UPR" 
c029 f5				push af  
c02a 3a 3e c0			ld a, (.dmark)  
c02d 32 71 ee			ld (debug_mark),a  
c030 3a 3f c0			ld a, (.dmark+1)  
c033 32 72 ee			ld (debug_mark+1),a  
c036 3a 40 c0			ld a, (.dmark+2)  
c039 32 73 ee			ld (debug_mark+2),a  
c03c 18 03			jr .pastdmark  
c03e ..			.dmark: db "UPR"  
c041 f1			.pastdmark: pop af  
c042			endm  
# End of macro DMARK
c042						CALLMONITOR 
c042 cd a3 94			call break_point_state  
c045				endm  
# End of macro CALLMONITOR
c045					endif 
c045			 
c045					FORTH_DSP 
c045 cd d1 9c			call macro_forth_dsp 
c048				endm 
# End of macro FORTH_DSP
c048					 
c048			; TODO check is string type 
c048			 
c048					FORTH_DSP_VALUEHL 
c048 cd 0b 9d			call macro_dsp_valuehl 
c04b				endm 
# End of macro FORTH_DSP_VALUEHL
c04b			; get pointer to string in hl 
c04b			 
c04b 7e			.toup:		ld a, (hl) 
c04c fe 00				cp 0 
c04e 28 07				jr z, .toupdone 
c050			 
c050 cd 0f 90				call to_upper 
c053			 
c053 77					ld (hl), a 
c054 23					inc hl 
c055 18 f4				jr .toup 
c057			 
c057					 
c057			 
c057			 
c057			; for each char convert to upper 
c057					 
c057			.toupdone: 
c057			 
c057			 
c057					NEXTW 
c057 c3 ba 9e			jp macro_next 
c05a				endm 
# End of macro NEXTW
c05a			.LOWER: 
c05a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c05a 48				db WORD_SYS_CORE+52             
c05b 95 c0			dw .TCASE            
c05d 06				db 5 + 1 
c05e .. 00			db "LOWER",0              
c064				endm 
# End of macro CWHEAD
c064			; | LOWER ( s -- s ) Lower case string s  | DONE 
c064					if DEBUG_FORTH_WORDS_KEY 
c064						DMARK "LWR" 
c064 f5				push af  
c065 3a 79 c0			ld a, (.dmark)  
c068 32 71 ee			ld (debug_mark),a  
c06b 3a 7a c0			ld a, (.dmark+1)  
c06e 32 72 ee			ld (debug_mark+1),a  
c071 3a 7b c0			ld a, (.dmark+2)  
c074 32 73 ee			ld (debug_mark+2),a  
c077 18 03			jr .pastdmark  
c079 ..			.dmark: db "LWR"  
c07c f1			.pastdmark: pop af  
c07d			endm  
# End of macro DMARK
c07d						CALLMONITOR 
c07d cd a3 94			call break_point_state  
c080				endm  
# End of macro CALLMONITOR
c080					endif 
c080			 
c080					FORTH_DSP 
c080 cd d1 9c			call macro_forth_dsp 
c083				endm 
# End of macro FORTH_DSP
c083					 
c083			; TODO check is string type 
c083			 
c083					FORTH_DSP_VALUEHL 
c083 cd 0b 9d			call macro_dsp_valuehl 
c086				endm 
# End of macro FORTH_DSP_VALUEHL
c086			; get pointer to string in hl 
c086			 
c086 7e			.tolow:		ld a, (hl) 
c087 fe 00				cp 0 
c089 28 07				jr z, .tolowdone 
c08b			 
c08b cd 18 90				call to_lower 
c08e			 
c08e 77					ld (hl), a 
c08f 23					inc hl 
c090 18 f4				jr .tolow 
c092			 
c092					 
c092			 
c092			 
c092			; for each char convert to low 
c092					 
c092			.tolowdone: 
c092					NEXTW 
c092 c3 ba 9e			jp macro_next 
c095				endm 
# End of macro NEXTW
c095			.TCASE: 
c095				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c095 48				db WORD_SYS_CORE+52             
c096 cb c1			dw .SUBSTR            
c098 06				db 5 + 1 
c099 .. 00			db "TCASE",0              
c09f				endm 
# End of macro CWHEAD
c09f			; | TCASE ( s -- s ) Title case string s  | DONE 
c09f					if DEBUG_FORTH_WORDS_KEY 
c09f						DMARK "TCS" 
c09f f5				push af  
c0a0 3a b4 c0			ld a, (.dmark)  
c0a3 32 71 ee			ld (debug_mark),a  
c0a6 3a b5 c0			ld a, (.dmark+1)  
c0a9 32 72 ee			ld (debug_mark+1),a  
c0ac 3a b6 c0			ld a, (.dmark+2)  
c0af 32 73 ee			ld (debug_mark+2),a  
c0b2 18 03			jr .pastdmark  
c0b4 ..			.dmark: db "TCS"  
c0b7 f1			.pastdmark: pop af  
c0b8			endm  
# End of macro DMARK
c0b8						CALLMONITOR 
c0b8 cd a3 94			call break_point_state  
c0bb				endm  
# End of macro CALLMONITOR
c0bb					endif 
c0bb			 
c0bb					FORTH_DSP 
c0bb cd d1 9c			call macro_forth_dsp 
c0be				endm 
# End of macro FORTH_DSP
c0be					 
c0be			; TODO check is string type 
c0be			 
c0be					FORTH_DSP_VALUEHL 
c0be cd 0b 9d			call macro_dsp_valuehl 
c0c1				endm 
# End of macro FORTH_DSP_VALUEHL
c0c1			; get pointer to string in hl 
c0c1			 
c0c1					if DEBUG_FORTH_WORDS 
c0c1						DMARK "TC1" 
c0c1 f5				push af  
c0c2 3a d6 c0			ld a, (.dmark)  
c0c5 32 71 ee			ld (debug_mark),a  
c0c8 3a d7 c0			ld a, (.dmark+1)  
c0cb 32 72 ee			ld (debug_mark+1),a  
c0ce 3a d8 c0			ld a, (.dmark+2)  
c0d1 32 73 ee			ld (debug_mark+2),a  
c0d4 18 03			jr .pastdmark  
c0d6 ..			.dmark: db "TC1"  
c0d9 f1			.pastdmark: pop af  
c0da			endm  
# End of macro DMARK
c0da						CALLMONITOR 
c0da cd a3 94			call break_point_state  
c0dd				endm  
# End of macro CALLMONITOR
c0dd					endif 
c0dd			 
c0dd					; first time in turn to upper case first char 
c0dd			 
c0dd 7e					ld a, (hl) 
c0de c3 68 c1				jp .totsiptou 
c0e1			 
c0e1			 
c0e1 7e			.tot:		ld a, (hl) 
c0e2 fe 00				cp 0 
c0e4 ca ac c1				jp z, .totdone 
c0e7			 
c0e7					if DEBUG_FORTH_WORDS 
c0e7						DMARK "TC2" 
c0e7 f5				push af  
c0e8 3a fc c0			ld a, (.dmark)  
c0eb 32 71 ee			ld (debug_mark),a  
c0ee 3a fd c0			ld a, (.dmark+1)  
c0f1 32 72 ee			ld (debug_mark+1),a  
c0f4 3a fe c0			ld a, (.dmark+2)  
c0f7 32 73 ee			ld (debug_mark+2),a  
c0fa 18 03			jr .pastdmark  
c0fc ..			.dmark: db "TC2"  
c0ff f1			.pastdmark: pop af  
c100			endm  
# End of macro DMARK
c100						CALLMONITOR 
c100 cd a3 94			call break_point_state  
c103				endm  
# End of macro CALLMONITOR
c103					endif 
c103					; check to see if current char is a space 
c103			 
c103 fe 20				cp ' ' 
c105 28 21				jr z, .totsp 
c107 cd 18 90				call to_lower 
c10a					if DEBUG_FORTH_WORDS 
c10a						DMARK "TC3" 
c10a f5				push af  
c10b 3a 1f c1			ld a, (.dmark)  
c10e 32 71 ee			ld (debug_mark),a  
c111 3a 20 c1			ld a, (.dmark+1)  
c114 32 72 ee			ld (debug_mark+1),a  
c117 3a 21 c1			ld a, (.dmark+2)  
c11a 32 73 ee			ld (debug_mark+2),a  
c11d 18 03			jr .pastdmark  
c11f ..			.dmark: db "TC3"  
c122 f1			.pastdmark: pop af  
c123			endm  
# End of macro DMARK
c123						CALLMONITOR 
c123 cd a3 94			call break_point_state  
c126				endm  
# End of macro CALLMONITOR
c126					endif 
c126 18 63				jr .totnxt 
c128			 
c128			.totsp:         ; on a space, find next char which should be upper 
c128			 
c128					if DEBUG_FORTH_WORDS 
c128						DMARK "TC4" 
c128 f5				push af  
c129 3a 3d c1			ld a, (.dmark)  
c12c 32 71 ee			ld (debug_mark),a  
c12f 3a 3e c1			ld a, (.dmark+1)  
c132 32 72 ee			ld (debug_mark+1),a  
c135 3a 3f c1			ld a, (.dmark+2)  
c138 32 73 ee			ld (debug_mark+2),a  
c13b 18 03			jr .pastdmark  
c13d ..			.dmark: db "TC4"  
c140 f1			.pastdmark: pop af  
c141			endm  
# End of macro DMARK
c141						CALLMONITOR 
c141 cd a3 94			call break_point_state  
c144				endm  
# End of macro CALLMONITOR
c144					endif 
c144					;; 
c144			 
c144 fe 20				cp ' ' 
c146 20 20				jr nz, .totsiptou 
c148 23					inc hl 
c149 7e					ld a, (hl) 
c14a					if DEBUG_FORTH_WORDS 
c14a						DMARK "TC5" 
c14a f5				push af  
c14b 3a 5f c1			ld a, (.dmark)  
c14e 32 71 ee			ld (debug_mark),a  
c151 3a 60 c1			ld a, (.dmark+1)  
c154 32 72 ee			ld (debug_mark+1),a  
c157 3a 61 c1			ld a, (.dmark+2)  
c15a 32 73 ee			ld (debug_mark+2),a  
c15d 18 03			jr .pastdmark  
c15f ..			.dmark: db "TC5"  
c162 f1			.pastdmark: pop af  
c163			endm  
# End of macro DMARK
c163						CALLMONITOR 
c163 cd a3 94			call break_point_state  
c166				endm  
# End of macro CALLMONITOR
c166					endif 
c166 18 c0				jr .totsp 
c168 fe 00		.totsiptou:    cp 0 
c16a 28 40				jr z, .totdone 
c16c					; not space and not zero term so upper case it 
c16c cd 0f 90				call to_upper 
c16f			 
c16f					if DEBUG_FORTH_WORDS 
c16f						DMARK "TC6" 
c16f f5				push af  
c170 3a 84 c1			ld a, (.dmark)  
c173 32 71 ee			ld (debug_mark),a  
c176 3a 85 c1			ld a, (.dmark+1)  
c179 32 72 ee			ld (debug_mark+1),a  
c17c 3a 86 c1			ld a, (.dmark+2)  
c17f 32 73 ee			ld (debug_mark+2),a  
c182 18 03			jr .pastdmark  
c184 ..			.dmark: db "TC6"  
c187 f1			.pastdmark: pop af  
c188			endm  
# End of macro DMARK
c188						CALLMONITOR 
c188 cd a3 94			call break_point_state  
c18b				endm  
# End of macro CALLMONITOR
c18b					endif 
c18b			 
c18b			 
c18b			.totnxt: 
c18b			 
c18b 77					ld (hl), a 
c18c 23					inc hl 
c18d					if DEBUG_FORTH_WORDS 
c18d						DMARK "TC7" 
c18d f5				push af  
c18e 3a a2 c1			ld a, (.dmark)  
c191 32 71 ee			ld (debug_mark),a  
c194 3a a3 c1			ld a, (.dmark+1)  
c197 32 72 ee			ld (debug_mark+1),a  
c19a 3a a4 c1			ld a, (.dmark+2)  
c19d 32 73 ee			ld (debug_mark+2),a  
c1a0 18 03			jr .pastdmark  
c1a2 ..			.dmark: db "TC7"  
c1a5 f1			.pastdmark: pop af  
c1a6			endm  
# End of macro DMARK
c1a6						CALLMONITOR 
c1a6 cd a3 94			call break_point_state  
c1a9				endm  
# End of macro CALLMONITOR
c1a9					endif 
c1a9 c3 e1 c0				jp .tot 
c1ac			 
c1ac					 
c1ac			 
c1ac			 
c1ac			; for each char convert to low 
c1ac					 
c1ac			.totdone: 
c1ac					if DEBUG_FORTH_WORDS 
c1ac						DMARK "TCd" 
c1ac f5				push af  
c1ad 3a c1 c1			ld a, (.dmark)  
c1b0 32 71 ee			ld (debug_mark),a  
c1b3 3a c2 c1			ld a, (.dmark+1)  
c1b6 32 72 ee			ld (debug_mark+1),a  
c1b9 3a c3 c1			ld a, (.dmark+2)  
c1bc 32 73 ee			ld (debug_mark+2),a  
c1bf 18 03			jr .pastdmark  
c1c1 ..			.dmark: db "TCd"  
c1c4 f1			.pastdmark: pop af  
c1c5			endm  
# End of macro DMARK
c1c5						CALLMONITOR 
c1c5 cd a3 94			call break_point_state  
c1c8				endm  
# End of macro CALLMONITOR
c1c8					endif 
c1c8					NEXTW 
c1c8 c3 ba 9e			jp macro_next 
c1cb				endm 
# End of macro NEXTW
c1cb			 
c1cb			.SUBSTR: 
c1cb				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c1cb 48				db WORD_SYS_CORE+52             
c1cc 29 c2			dw .LEFT            
c1ce 07				db 6 + 1 
c1cf .. 00			db "SUBSTR",0              
c1d6				endm 
# End of macro CWHEAD
c1d6			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c1d6			 
c1d6					if DEBUG_FORTH_WORDS_KEY 
c1d6						DMARK "SST" 
c1d6 f5				push af  
c1d7 3a eb c1			ld a, (.dmark)  
c1da 32 71 ee			ld (debug_mark),a  
c1dd 3a ec c1			ld a, (.dmark+1)  
c1e0 32 72 ee			ld (debug_mark+1),a  
c1e3 3a ed c1			ld a, (.dmark+2)  
c1e6 32 73 ee			ld (debug_mark+2),a  
c1e9 18 03			jr .pastdmark  
c1eb ..			.dmark: db "SST"  
c1ee f1			.pastdmark: pop af  
c1ef			endm  
# End of macro DMARK
c1ef						CALLMONITOR 
c1ef cd a3 94			call break_point_state  
c1f2				endm  
# End of macro CALLMONITOR
c1f2					endif 
c1f2			; TODO check string type 
c1f2					FORTH_DSP_VALUEHL 
c1f2 cd 0b 9d			call macro_dsp_valuehl 
c1f5				endm 
# End of macro FORTH_DSP_VALUEHL
c1f5			 
c1f5 e5					push hl      ; string length 
c1f6			 
c1f6					FORTH_DSP_POP 
c1f6 cd c3 9d			call macro_forth_dsp_pop 
c1f9				endm 
# End of macro FORTH_DSP_POP
c1f9			 
c1f9					FORTH_DSP_VALUEHL 
c1f9 cd 0b 9d			call macro_dsp_valuehl 
c1fc				endm 
# End of macro FORTH_DSP_VALUEHL
c1fc			 
c1fc e5					push hl     ; start char 
c1fd			 
c1fd					FORTH_DSP_POP 
c1fd cd c3 9d			call macro_forth_dsp_pop 
c200				endm 
# End of macro FORTH_DSP_POP
c200			 
c200			 
c200					FORTH_DSP_VALUE 
c200 cd f4 9c			call macro_forth_dsp_value 
c203				endm 
# End of macro FORTH_DSP_VALUE
c203			 
c203 d1					pop de    ; get start post offset 
c204			 
c204 19					add hl, de    ; starting offset 
c205			 
c205 c1					pop bc 
c206 c5					push bc      ; grab size of string 
c207			 
c207 e5					push hl    ; save string start  
c208			 
c208 26 00				ld h, 0 
c20a 69					ld l, c 
c20b 23					inc hl 
c20c 23					inc hl 
c20d			 
c20d cd 69 91				call malloc 
c210				if DEBUG_FORTH_MALLOC_GUARD 
c210 cc 9e c9				call z,malloc_error 
c213				endif 
c213			 
c213 eb					ex de, hl      ; save malloc area for string copy 
c214 e1					pop hl    ; get back source 
c215 c1					pop bc    ; get length of string back 
c216			 
c216 d5					push de    ; save malloc area for after we push 
c217 ed b0				ldir     ; copy substr 
c219			 
c219			 
c219 eb					ex de, hl 
c21a 3e 00				ld a, 0 
c21c 77					ld (hl), a   ; term substr 
c21d			 
c21d					 
c21d e1					pop hl    ; get malloc so we can push it 
c21e e5					push hl   ; save so we can free it afterwards 
c21f			 
c21f cd 82 9b				call forth_push_str 
c222			 
c222 e1					pop hl 
c223 cd 33 92				call free 
c226			 
c226					 
c226					 
c226			 
c226			 
c226					NEXTW 
c226 c3 ba 9e			jp macro_next 
c229				endm 
# End of macro NEXTW
c229			 
c229			.LEFT: 
c229				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c229 48				db WORD_SYS_CORE+52             
c22a 51 c2			dw .RIGHT            
c22c 05				db 4 + 1 
c22d .. 00			db "LEFT",0              
c232				endm 
# End of macro CWHEAD
c232			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c232					if DEBUG_FORTH_WORDS_KEY 
c232						DMARK "LEF" 
c232 f5				push af  
c233 3a 47 c2			ld a, (.dmark)  
c236 32 71 ee			ld (debug_mark),a  
c239 3a 48 c2			ld a, (.dmark+1)  
c23c 32 72 ee			ld (debug_mark+1),a  
c23f 3a 49 c2			ld a, (.dmark+2)  
c242 32 73 ee			ld (debug_mark+2),a  
c245 18 03			jr .pastdmark  
c247 ..			.dmark: db "LEF"  
c24a f1			.pastdmark: pop af  
c24b			endm  
# End of macro DMARK
c24b						CALLMONITOR 
c24b cd a3 94			call break_point_state  
c24e				endm  
# End of macro CALLMONITOR
c24e					endif 
c24e			 
c24e					NEXTW 
c24e c3 ba 9e			jp macro_next 
c251				endm 
# End of macro NEXTW
c251			.RIGHT: 
c251				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c251 48				db WORD_SYS_CORE+52             
c252 7a c2			dw .STR2NUM            
c254 06				db 5 + 1 
c255 .. 00			db "RIGHT",0              
c25b				endm 
# End of macro CWHEAD
c25b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c25b					if DEBUG_FORTH_WORDS_KEY 
c25b						DMARK "RIG" 
c25b f5				push af  
c25c 3a 70 c2			ld a, (.dmark)  
c25f 32 71 ee			ld (debug_mark),a  
c262 3a 71 c2			ld a, (.dmark+1)  
c265 32 72 ee			ld (debug_mark+1),a  
c268 3a 72 c2			ld a, (.dmark+2)  
c26b 32 73 ee			ld (debug_mark+2),a  
c26e 18 03			jr .pastdmark  
c270 ..			.dmark: db "RIG"  
c273 f1			.pastdmark: pop af  
c274			endm  
# End of macro DMARK
c274						CALLMONITOR 
c274 cd a3 94			call break_point_state  
c277				endm  
# End of macro CALLMONITOR
c277					endif 
c277			 
c277					NEXTW 
c277 c3 ba 9e			jp macro_next 
c27a				endm 
# End of macro NEXTW
c27a			 
c27a			 
c27a			.STR2NUM: 
c27a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c27a 48				db WORD_SYS_CORE+52             
c27b 06 c3			dw .NUM2STR            
c27d 08				db 7 + 1 
c27e .. 00			db "STR2NUM",0              
c286				endm 
# End of macro CWHEAD
c286			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c286			 
c286			 
c286			; TODO STR type check to do 
c286					if DEBUG_FORTH_WORDS_KEY 
c286						DMARK "S2N" 
c286 f5				push af  
c287 3a 9b c2			ld a, (.dmark)  
c28a 32 71 ee			ld (debug_mark),a  
c28d 3a 9c c2			ld a, (.dmark+1)  
c290 32 72 ee			ld (debug_mark+1),a  
c293 3a 9d c2			ld a, (.dmark+2)  
c296 32 73 ee			ld (debug_mark+2),a  
c299 18 03			jr .pastdmark  
c29b ..			.dmark: db "S2N"  
c29e f1			.pastdmark: pop af  
c29f			endm  
# End of macro DMARK
c29f						CALLMONITOR 
c29f cd a3 94			call break_point_state  
c2a2				endm  
# End of macro CALLMONITOR
c2a2					endif 
c2a2			 
c2a2					;FORTH_DSP 
c2a2					FORTH_DSP_VALUE 
c2a2 cd f4 9c			call macro_forth_dsp_value 
c2a5				endm 
# End of macro FORTH_DSP_VALUE
c2a5					;inc hl 
c2a5			 
c2a5 eb					ex de, hl 
c2a6					if DEBUG_FORTH_WORDS 
c2a6						DMARK "S2a" 
c2a6 f5				push af  
c2a7 3a bb c2			ld a, (.dmark)  
c2aa 32 71 ee			ld (debug_mark),a  
c2ad 3a bc c2			ld a, (.dmark+1)  
c2b0 32 72 ee			ld (debug_mark+1),a  
c2b3 3a bd c2			ld a, (.dmark+2)  
c2b6 32 73 ee			ld (debug_mark+2),a  
c2b9 18 03			jr .pastdmark  
c2bb ..			.dmark: db "S2a"  
c2be f1			.pastdmark: pop af  
c2bf			endm  
# End of macro DMARK
c2bf						CALLMONITOR 
c2bf cd a3 94			call break_point_state  
c2c2				endm  
# End of macro CALLMONITOR
c2c2					endif 
c2c2 cd 97 90				call string_to_uint16 
c2c5			 
c2c5					if DEBUG_FORTH_WORDS 
c2c5						DMARK "S2b" 
c2c5 f5				push af  
c2c6 3a da c2			ld a, (.dmark)  
c2c9 32 71 ee			ld (debug_mark),a  
c2cc 3a db c2			ld a, (.dmark+1)  
c2cf 32 72 ee			ld (debug_mark+1),a  
c2d2 3a dc c2			ld a, (.dmark+2)  
c2d5 32 73 ee			ld (debug_mark+2),a  
c2d8 18 03			jr .pastdmark  
c2da ..			.dmark: db "S2b"  
c2dd f1			.pastdmark: pop af  
c2de			endm  
# End of macro DMARK
c2de						CALLMONITOR 
c2de cd a3 94			call break_point_state  
c2e1				endm  
# End of macro CALLMONITOR
c2e1					endif 
c2e1			;		push hl 
c2e1					FORTH_DSP_POP 
c2e1 cd c3 9d			call macro_forth_dsp_pop 
c2e4				endm 
# End of macro FORTH_DSP_POP
c2e4			;		pop hl 
c2e4					 
c2e4					if DEBUG_FORTH_WORDS 
c2e4						DMARK "S2b" 
c2e4 f5				push af  
c2e5 3a f9 c2			ld a, (.dmark)  
c2e8 32 71 ee			ld (debug_mark),a  
c2eb 3a fa c2			ld a, (.dmark+1)  
c2ee 32 72 ee			ld (debug_mark+1),a  
c2f1 3a fb c2			ld a, (.dmark+2)  
c2f4 32 73 ee			ld (debug_mark+2),a  
c2f7 18 03			jr .pastdmark  
c2f9 ..			.dmark: db "S2b"  
c2fc f1			.pastdmark: pop af  
c2fd			endm  
# End of macro DMARK
c2fd						CALLMONITOR 
c2fd cd a3 94			call break_point_state  
c300				endm  
# End of macro CALLMONITOR
c300					endif 
c300 cd 14 9b				call forth_push_numhl	 
c303			 
c303				 
c303				       NEXTW 
c303 c3 ba 9e			jp macro_next 
c306				endm 
# End of macro NEXTW
c306			.NUM2STR: 
c306				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c306 48				db WORD_SYS_CORE+52             
c307 15 c3			dw .CONCAT            
c309 08				db 7 + 1 
c30a .. 00			db "NUM2STR",0              
c312				endm 
# End of macro CWHEAD
c312			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c312			 
c312			;		; malloc a string to target 
c312			;		ld hl, 10     ; TODO max string size should be fine 
c312			;		call malloc 
c312			;		push hl    ; save malloc location 
c312			; 
c312			; 
c312			;; TODO check int type 
c312			;		FORTH_DSP_VALUEHL 
c312			;		ld a, l 
c312			;		call DispAToASCII   
c312			;;TODO need to chage above call to dump into string 
c312			; 
c312			; 
c312			 
c312				       NEXTW 
c312 c3 ba 9e			jp macro_next 
c315				endm 
# End of macro NEXTW
c315			 
c315			.CONCAT: 
c315				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c315 48				db WORD_SYS_CORE+52             
c316 c8 c3			dw .FIND            
c318 07				db 6 + 1 
c319 .. 00			db "CONCAT",0              
c320				endm 
# End of macro CWHEAD
c320			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c320			 
c320			; TODO check string type 
c320			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c320			 
c320					if DEBUG_FORTH_WORDS_KEY 
c320						DMARK "CON" 
c320 f5				push af  
c321 3a 35 c3			ld a, (.dmark)  
c324 32 71 ee			ld (debug_mark),a  
c327 3a 36 c3			ld a, (.dmark+1)  
c32a 32 72 ee			ld (debug_mark+1),a  
c32d 3a 37 c3			ld a, (.dmark+2)  
c330 32 73 ee			ld (debug_mark+2),a  
c333 18 03			jr .pastdmark  
c335 ..			.dmark: db "CON"  
c338 f1			.pastdmark: pop af  
c339			endm  
# End of macro DMARK
c339						CALLMONITOR 
c339 cd a3 94			call break_point_state  
c33c				endm  
# End of macro CALLMONITOR
c33c					endif 
c33c			 
c33c			 
c33c					FORTH_DSP_VALUE 
c33c cd f4 9c			call macro_forth_dsp_value 
c33f				endm 
# End of macro FORTH_DSP_VALUE
c33f e5					push hl   ; s2 
c340			 
c340					FORTH_DSP_POP 
c340 cd c3 9d			call macro_forth_dsp_pop 
c343				endm 
# End of macro FORTH_DSP_POP
c343			 
c343					FORTH_DSP_VALUE 
c343 cd f4 9c			call macro_forth_dsp_value 
c346				endm 
# End of macro FORTH_DSP_VALUE
c346			 
c346 e5					push hl   ; s1 
c347			 
c347					FORTH_DSP_POP 
c347 cd c3 9d			call macro_forth_dsp_pop 
c34a				endm 
# End of macro FORTH_DSP_POP
c34a					 
c34a			 
c34a					; copy s1 
c34a			 
c34a				 
c34a					; save ptr 
c34a e1					pop hl  
c34b e5					push hl 
c34c 3e 00				ld a, 0 
c34e cd 0b 91				call strlent 
c351					;inc hl    ; zer0 
c351 06 00				ld b, 0 
c353 4d					ld c, l 
c354 e1					pop hl		 
c355 11 cb e2				ld de, scratch	 
c358					if DEBUG_FORTH_WORDS 
c358						DMARK "CO1" 
c358 f5				push af  
c359 3a 6d c3			ld a, (.dmark)  
c35c 32 71 ee			ld (debug_mark),a  
c35f 3a 6e c3			ld a, (.dmark+1)  
c362 32 72 ee			ld (debug_mark+1),a  
c365 3a 6f c3			ld a, (.dmark+2)  
c368 32 73 ee			ld (debug_mark+2),a  
c36b 18 03			jr .pastdmark  
c36d ..			.dmark: db "CO1"  
c370 f1			.pastdmark: pop af  
c371			endm  
# End of macro DMARK
c371						CALLMONITOR 
c371 cd a3 94			call break_point_state  
c374				endm  
# End of macro CALLMONITOR
c374					endif 
c374 ed b0				ldir 
c376			 
c376 e1					pop hl 
c377 e5					push hl 
c378 d5					push de 
c379			 
c379			 
c379 3e 00				ld a, 0 
c37b cd 0b 91				call strlent 
c37e 23					inc hl    ; zer0 
c37f 23					inc hl 
c380 06 00				ld b, 0 
c382 4d					ld c, l 
c383 d1					pop de 
c384 e1					pop hl		 
c385					if DEBUG_FORTH_WORDS 
c385						DMARK "CO2" 
c385 f5				push af  
c386 3a 9a c3			ld a, (.dmark)  
c389 32 71 ee			ld (debug_mark),a  
c38c 3a 9b c3			ld a, (.dmark+1)  
c38f 32 72 ee			ld (debug_mark+1),a  
c392 3a 9c c3			ld a, (.dmark+2)  
c395 32 73 ee			ld (debug_mark+2),a  
c398 18 03			jr .pastdmark  
c39a ..			.dmark: db "CO2"  
c39d f1			.pastdmark: pop af  
c39e			endm  
# End of macro DMARK
c39e						CALLMONITOR 
c39e cd a3 94			call break_point_state  
c3a1				endm  
# End of macro CALLMONITOR
c3a1					endif 
c3a1 ed b0				ldir 
c3a3			 
c3a3			 
c3a3			 
c3a3 21 cb e2				ld hl, scratch 
c3a6					if DEBUG_FORTH_WORDS 
c3a6						DMARK "CO5" 
c3a6 f5				push af  
c3a7 3a bb c3			ld a, (.dmark)  
c3aa 32 71 ee			ld (debug_mark),a  
c3ad 3a bc c3			ld a, (.dmark+1)  
c3b0 32 72 ee			ld (debug_mark+1),a  
c3b3 3a bd c3			ld a, (.dmark+2)  
c3b6 32 73 ee			ld (debug_mark+2),a  
c3b9 18 03			jr .pastdmark  
c3bb ..			.dmark: db "CO5"  
c3be f1			.pastdmark: pop af  
c3bf			endm  
# End of macro DMARK
c3bf						CALLMONITOR 
c3bf cd a3 94			call break_point_state  
c3c2				endm  
# End of macro CALLMONITOR
c3c2					endif 
c3c2			 
c3c2 cd 82 9b				call forth_push_str 
c3c5			 
c3c5			 
c3c5			 
c3c5			 
c3c5				       NEXTW 
c3c5 c3 ba 9e			jp macro_next 
c3c8				endm 
# End of macro NEXTW
c3c8			 
c3c8			 
c3c8			.FIND: 
c3c8				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c3c8 4b				db WORD_SYS_CORE+55             
c3c9 86 c4			dw .LEN            
c3cb 05				db 4 + 1 
c3cc .. 00			db "FIND",0              
c3d1				endm 
# End of macro CWHEAD
c3d1			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c3d1			 
c3d1					if DEBUG_FORTH_WORDS_KEY 
c3d1						DMARK "FND" 
c3d1 f5				push af  
c3d2 3a e6 c3			ld a, (.dmark)  
c3d5 32 71 ee			ld (debug_mark),a  
c3d8 3a e7 c3			ld a, (.dmark+1)  
c3db 32 72 ee			ld (debug_mark+1),a  
c3de 3a e8 c3			ld a, (.dmark+2)  
c3e1 32 73 ee			ld (debug_mark+2),a  
c3e4 18 03			jr .pastdmark  
c3e6 ..			.dmark: db "FND"  
c3e9 f1			.pastdmark: pop af  
c3ea			endm  
# End of macro DMARK
c3ea						CALLMONITOR 
c3ea cd a3 94			call break_point_state  
c3ed				endm  
# End of macro CALLMONITOR
c3ed					endif 
c3ed			 
c3ed			; TODO check string type 
c3ed					FORTH_DSP_VALUE 
c3ed cd f4 9c			call macro_forth_dsp_value 
c3f0				endm 
# End of macro FORTH_DSP_VALUE
c3f0			 
c3f0 e5					push hl    
c3f1 7e					ld a,(hl)    ; char to find   
c3f2			; TODO change char to substr 
c3f2			 
c3f2 f5					push af 
c3f3					 
c3f3			 
c3f3			 
c3f3					if DEBUG_FORTH_WORDS 
c3f3						DMARK "FN1" 
c3f3 f5				push af  
c3f4 3a 08 c4			ld a, (.dmark)  
c3f7 32 71 ee			ld (debug_mark),a  
c3fa 3a 09 c4			ld a, (.dmark+1)  
c3fd 32 72 ee			ld (debug_mark+1),a  
c400 3a 0a c4			ld a, (.dmark+2)  
c403 32 73 ee			ld (debug_mark+2),a  
c406 18 03			jr .pastdmark  
c408 ..			.dmark: db "FN1"  
c40b f1			.pastdmark: pop af  
c40c			endm  
# End of macro DMARK
c40c						CALLMONITOR 
c40c cd a3 94			call break_point_state  
c40f				endm  
# End of macro CALLMONITOR
c40f					endif 
c40f			 
c40f					FORTH_DSP_POP 
c40f cd c3 9d			call macro_forth_dsp_pop 
c412				endm 
# End of macro FORTH_DSP_POP
c412			 
c412					; string to search 
c412			 
c412					FORTH_DSP_VALUE 
c412 cd f4 9c			call macro_forth_dsp_value 
c415				endm 
# End of macro FORTH_DSP_VALUE
c415			 
c415 d1					pop de  ; d is char to find  
c416			 
c416					if DEBUG_FORTH_WORDS 
c416						DMARK "FN2" 
c416 f5				push af  
c417 3a 2b c4			ld a, (.dmark)  
c41a 32 71 ee			ld (debug_mark),a  
c41d 3a 2c c4			ld a, (.dmark+1)  
c420 32 72 ee			ld (debug_mark+1),a  
c423 3a 2d c4			ld a, (.dmark+2)  
c426 32 73 ee			ld (debug_mark+2),a  
c429 18 03			jr .pastdmark  
c42b ..			.dmark: db "FN2"  
c42e f1			.pastdmark: pop af  
c42f			endm  
# End of macro DMARK
c42f						CALLMONITOR 
c42f cd a3 94			call break_point_state  
c432				endm  
# End of macro CALLMONITOR
c432					endif 
c432					 
c432 01 00 00				ld bc, 0 
c435 7e			.findchar:      ld a,(hl) 
c436 fe 00				cp 0   		 
c438 28 27				jr z, .finddone     
c43a ba					cp d 
c43b 28 20				jr z, .foundchar 
c43d 03					inc bc 
c43e 23					inc hl 
c43f					if DEBUG_FORTH_WORDS 
c43f						DMARK "FN3" 
c43f f5				push af  
c440 3a 54 c4			ld a, (.dmark)  
c443 32 71 ee			ld (debug_mark),a  
c446 3a 55 c4			ld a, (.dmark+1)  
c449 32 72 ee			ld (debug_mark+1),a  
c44c 3a 56 c4			ld a, (.dmark+2)  
c44f 32 73 ee			ld (debug_mark+2),a  
c452 18 03			jr .pastdmark  
c454 ..			.dmark: db "FN3"  
c457 f1			.pastdmark: pop af  
c458			endm  
# End of macro DMARK
c458						CALLMONITOR 
c458 cd a3 94			call break_point_state  
c45b				endm  
# End of macro CALLMONITOR
c45b					endif 
c45b 18 d8				jr .findchar 
c45d			 
c45d			 
c45d c5			.foundchar:	push bc 
c45e e1					pop hl 
c45f 18 03				jr .findexit 
c461			 
c461			 
c461							 
c461			 
c461			.finddone:     ; got to end of string with no find 
c461 21 00 00				ld hl, 0 
c464			.findexit: 
c464			 
c464					if DEBUG_FORTH_WORDS 
c464						DMARK "FNd" 
c464 f5				push af  
c465 3a 79 c4			ld a, (.dmark)  
c468 32 71 ee			ld (debug_mark),a  
c46b 3a 7a c4			ld a, (.dmark+1)  
c46e 32 72 ee			ld (debug_mark+1),a  
c471 3a 7b c4			ld a, (.dmark+2)  
c474 32 73 ee			ld (debug_mark+2),a  
c477 18 03			jr .pastdmark  
c479 ..			.dmark: db "FNd"  
c47c f1			.pastdmark: pop af  
c47d			endm  
# End of macro DMARK
c47d						CALLMONITOR 
c47d cd a3 94			call break_point_state  
c480				endm  
# End of macro CALLMONITOR
c480					endif 
c480 cd 14 9b			call forth_push_numhl 
c483			 
c483				       NEXTW 
c483 c3 ba 9e			jp macro_next 
c486				endm 
# End of macro NEXTW
c486			 
c486			.LEN: 
c486				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c486 4c				db WORD_SYS_CORE+56             
c487 f0 c4			dw .ASC            
c489 06				db 5 + 1 
c48a .. 00			db "COUNT",0              
c490				endm 
# End of macro CWHEAD
c490			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c490			 
c490					if DEBUG_FORTH_WORDS_KEY 
c490						DMARK "CNT" 
c490 f5				push af  
c491 3a a5 c4			ld a, (.dmark)  
c494 32 71 ee			ld (debug_mark),a  
c497 3a a6 c4			ld a, (.dmark+1)  
c49a 32 72 ee			ld (debug_mark+1),a  
c49d 3a a7 c4			ld a, (.dmark+2)  
c4a0 32 73 ee			ld (debug_mark+2),a  
c4a3 18 03			jr .pastdmark  
c4a5 ..			.dmark: db "CNT"  
c4a8 f1			.pastdmark: pop af  
c4a9			endm  
# End of macro DMARK
c4a9						CALLMONITOR 
c4a9 cd a3 94			call break_point_state  
c4ac				endm  
# End of macro CALLMONITOR
c4ac					endif 
c4ac			; TODO check string type 
c4ac					FORTH_DSP_VALUE 
c4ac cd f4 9c			call macro_forth_dsp_value 
c4af				endm 
# End of macro FORTH_DSP_VALUE
c4af			 
c4af			 
c4af					if DEBUG_FORTH_WORDS 
c4af						DMARK "CN?" 
c4af f5				push af  
c4b0 3a c4 c4			ld a, (.dmark)  
c4b3 32 71 ee			ld (debug_mark),a  
c4b6 3a c5 c4			ld a, (.dmark+1)  
c4b9 32 72 ee			ld (debug_mark+1),a  
c4bc 3a c6 c4			ld a, (.dmark+2)  
c4bf 32 73 ee			ld (debug_mark+2),a  
c4c2 18 03			jr .pastdmark  
c4c4 ..			.dmark: db "CN?"  
c4c7 f1			.pastdmark: pop af  
c4c8			endm  
# End of macro DMARK
c4c8						CALLMONITOR 
c4c8 cd a3 94			call break_point_state  
c4cb				endm  
# End of macro CALLMONITOR
c4cb					endif 
c4cb cd 00 91				call strlenz 
c4ce					if DEBUG_FORTH_WORDS 
c4ce						DMARK "CNl" 
c4ce f5				push af  
c4cf 3a e3 c4			ld a, (.dmark)  
c4d2 32 71 ee			ld (debug_mark),a  
c4d5 3a e4 c4			ld a, (.dmark+1)  
c4d8 32 72 ee			ld (debug_mark+1),a  
c4db 3a e5 c4			ld a, (.dmark+2)  
c4de 32 73 ee			ld (debug_mark+2),a  
c4e1 18 03			jr .pastdmark  
c4e3 ..			.dmark: db "CNl"  
c4e6 f1			.pastdmark: pop af  
c4e7			endm  
# End of macro DMARK
c4e7						CALLMONITOR 
c4e7 cd a3 94			call break_point_state  
c4ea				endm  
# End of macro CALLMONITOR
c4ea					endif 
c4ea			 
c4ea cd 14 9b				call forth_push_numhl 
c4ed			 
c4ed			 
c4ed			 
c4ed				       NEXTW 
c4ed c3 ba 9e			jp macro_next 
c4f0				endm 
# End of macro NEXTW
c4f0			.ASC: 
c4f0				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c4f0 4d				db WORD_SYS_CORE+57             
c4f1 25 c5			dw .CHR            
c4f3 04				db 3 + 1 
c4f4 .. 00			db "ASC",0              
c4f8				endm 
# End of macro CWHEAD
c4f8			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c4f8					if DEBUG_FORTH_WORDS_KEY 
c4f8						DMARK "ASC" 
c4f8 f5				push af  
c4f9 3a 0d c5			ld a, (.dmark)  
c4fc 32 71 ee			ld (debug_mark),a  
c4ff 3a 0e c5			ld a, (.dmark+1)  
c502 32 72 ee			ld (debug_mark+1),a  
c505 3a 0f c5			ld a, (.dmark+2)  
c508 32 73 ee			ld (debug_mark+2),a  
c50b 18 03			jr .pastdmark  
c50d ..			.dmark: db "ASC"  
c510 f1			.pastdmark: pop af  
c511			endm  
# End of macro DMARK
c511						CALLMONITOR 
c511 cd a3 94			call break_point_state  
c514				endm  
# End of macro CALLMONITOR
c514					endif 
c514					FORTH_DSP 
c514 cd d1 9c			call macro_forth_dsp 
c517				endm 
# End of macro FORTH_DSP
c517					;v5 FORTH_DSP_VALUE 
c517 23					inc hl      ; now at start of numeric as string 
c518			 
c518			;		push hl 
c518			 
c518					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c518 cd c3 9d			call macro_forth_dsp_pop 
c51b				endm 
# End of macro FORTH_DSP_POP
c51b			 
c51b			;		pop hl 
c51b			 
c51b					; push the content of a onto the stack as a value 
c51b			 
c51b 7e					ld a,(hl)   ; get char 
c51c 26 00				ld h,0 
c51e 6f					ld l,a 
c51f cd 14 9b				call forth_push_numhl 
c522			 
c522				       NEXTW 
c522 c3 ba 9e			jp macro_next 
c525				endm 
# End of macro NEXTW
c525			 
c525			.CHR: 
c525				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c525 4d				db WORD_SYS_CORE+57             
c526 61 c5			dw .ENDSTR            
c528 04				db 3 + 1 
c529 .. 00			db "CHR",0              
c52d				endm 
# End of macro CWHEAD
c52d			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c52d					if DEBUG_FORTH_WORDS_KEY 
c52d						DMARK "CHR" 
c52d f5				push af  
c52e 3a 42 c5			ld a, (.dmark)  
c531 32 71 ee			ld (debug_mark),a  
c534 3a 43 c5			ld a, (.dmark+1)  
c537 32 72 ee			ld (debug_mark+1),a  
c53a 3a 44 c5			ld a, (.dmark+2)  
c53d 32 73 ee			ld (debug_mark+2),a  
c540 18 03			jr .pastdmark  
c542 ..			.dmark: db "CHR"  
c545 f1			.pastdmark: pop af  
c546			endm  
# End of macro DMARK
c546						CALLMONITOR 
c546 cd a3 94			call break_point_state  
c549				endm  
# End of macro CALLMONITOR
c549					endif 
c549					FORTH_DSP_VALUEHL 
c549 cd 0b 9d			call macro_dsp_valuehl 
c54c				endm 
# End of macro FORTH_DSP_VALUEHL
c54c			 
c54c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c54c cd c3 9d			call macro_forth_dsp_pop 
c54f				endm 
# End of macro FORTH_DSP_POP
c54f			 
c54f					; save asci byte as a zero term string and push string 
c54f			 
c54f 7d					ld a,l 
c550 32 cb e2				ld (scratch), a 
c553			 
c553 3e 00				ld a, 0 
c555 32 cc e2				ld (scratch+1), a 
c558			 
c558 21 cb e2				ld hl, scratch 
c55b cd 82 9b				call forth_push_str 
c55e			 
c55e			 
c55e				       NEXTW 
c55e c3 ba 9e			jp macro_next 
c561				endm 
# End of macro NEXTW
c561			 
c561			 
c561			 
c561			 
c561			.ENDSTR: 
c561			; eof 
c561			 
# End of file forth_words_str.asm
c561			include "forth_words_key.asm" 
c561			 
c561			; | ## Keyboard Words 
c561			 
c561			.KEY: 
c561				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c561 3e				db WORD_SYS_CORE+42             
c562 91 c5			dw .WAITK            
c564 04				db 3 + 1 
c565 .. 00			db "KEY",0              
c569				endm 
# End of macro CWHEAD
c569			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c569			 
c569					if DEBUG_FORTH_WORDS_KEY 
c569						DMARK "KEY" 
c569 f5				push af  
c56a 3a 7e c5			ld a, (.dmark)  
c56d 32 71 ee			ld (debug_mark),a  
c570 3a 7f c5			ld a, (.dmark+1)  
c573 32 72 ee			ld (debug_mark+1),a  
c576 3a 80 c5			ld a, (.dmark+2)  
c579 32 73 ee			ld (debug_mark+2),a  
c57c 18 03			jr .pastdmark  
c57e ..			.dmark: db "KEY"  
c581 f1			.pastdmark: pop af  
c582			endm  
# End of macro DMARK
c582						CALLMONITOR 
c582 cd a3 94			call break_point_state  
c585				endm  
# End of macro CALLMONITOR
c585					endif 
c585			; TODO currently waits 
c585 cd 4c e0				call cin 
c588					;call cin_wait 
c588 6f					ld l, a 
c589 26 00				ld h, 0 
c58b cd 14 9b				call forth_push_numhl 
c58e					NEXTW 
c58e c3 ba 9e			jp macro_next 
c591				endm 
# End of macro NEXTW
c591			.WAITK: 
c591				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c591 3f				db WORD_SYS_CORE+43             
c592 c3 c5			dw .ACCEPT            
c594 06				db 5 + 1 
c595 .. 00			db "WAITK",0              
c59b				endm 
# End of macro CWHEAD
c59b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c59b					if DEBUG_FORTH_WORDS_KEY 
c59b						DMARK "WAI" 
c59b f5				push af  
c59c 3a b0 c5			ld a, (.dmark)  
c59f 32 71 ee			ld (debug_mark),a  
c5a2 3a b1 c5			ld a, (.dmark+1)  
c5a5 32 72 ee			ld (debug_mark+1),a  
c5a8 3a b2 c5			ld a, (.dmark+2)  
c5ab 32 73 ee			ld (debug_mark+2),a  
c5ae 18 03			jr .pastdmark  
c5b0 ..			.dmark: db "WAI"  
c5b3 f1			.pastdmark: pop af  
c5b4			endm  
# End of macro DMARK
c5b4						CALLMONITOR 
c5b4 cd a3 94			call break_point_state  
c5b7				endm  
# End of macro CALLMONITOR
c5b7					endif 
c5b7 cd 46 e0				call cin_wait 
c5ba 6f					ld l, a 
c5bb 26 00				ld h, 0 
c5bd cd 14 9b				call forth_push_numhl 
c5c0					NEXTW 
c5c0 c3 ba 9e			jp macro_next 
c5c3				endm 
# End of macro NEXTW
c5c3			.ACCEPT: 
c5c3				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c5c3 40				db WORD_SYS_CORE+44             
c5c4 21 c6			dw .EDIT            
c5c6 07				db 6 + 1 
c5c7 .. 00			db "ACCEPT",0              
c5ce				endm 
# End of macro CWHEAD
c5ce			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c5ce					; TODO crashes on push 
c5ce					if DEBUG_FORTH_WORDS_KEY 
c5ce						DMARK "ACC" 
c5ce f5				push af  
c5cf 3a e3 c5			ld a, (.dmark)  
c5d2 32 71 ee			ld (debug_mark),a  
c5d5 3a e4 c5			ld a, (.dmark+1)  
c5d8 32 72 ee			ld (debug_mark+1),a  
c5db 3a e5 c5			ld a, (.dmark+2)  
c5de 32 73 ee			ld (debug_mark+2),a  
c5e1 18 03			jr .pastdmark  
c5e3 ..			.dmark: db "ACC"  
c5e6 f1			.pastdmark: pop af  
c5e7			endm  
# End of macro DMARK
c5e7						CALLMONITOR 
c5e7 cd a3 94			call break_point_state  
c5ea				endm  
# End of macro CALLMONITOR
c5ea					endif 
c5ea 21 c9 e4				ld hl, os_input 
c5ed 3e 00				ld a, 0 
c5ef 77					ld (hl),a 
c5f0 3a 68 ea				ld a,(f_cursor_ptr) 
c5f3 16 64				ld d, 100 
c5f5 0e 00				ld c, 0 
c5f7 1e 28				ld e, 40 
c5f9 cd cf 8c				call input_str 
c5fc					; TODO perhaps do a type check and wrap in quotes if not a number 
c5fc 21 c9 e4				ld hl, os_input 
c5ff					if DEBUG_FORTH_WORDS 
c5ff						DMARK "AC1" 
c5ff f5				push af  
c600 3a 14 c6			ld a, (.dmark)  
c603 32 71 ee			ld (debug_mark),a  
c606 3a 15 c6			ld a, (.dmark+1)  
c609 32 72 ee			ld (debug_mark+1),a  
c60c 3a 16 c6			ld a, (.dmark+2)  
c60f 32 73 ee			ld (debug_mark+2),a  
c612 18 03			jr .pastdmark  
c614 ..			.dmark: db "AC1"  
c617 f1			.pastdmark: pop af  
c618			endm  
# End of macro DMARK
c618						CALLMONITOR 
c618 cd a3 94			call break_point_state  
c61b				endm  
# End of macro CALLMONITOR
c61b					endif 
c61b cd 82 9b				call forth_push_str 
c61e					NEXTW 
c61e c3 ba 9e			jp macro_next 
c621				endm 
# End of macro NEXTW
c621			 
c621			.EDIT: 
c621				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c621 40				db WORD_SYS_CORE+44             
c622 c3 c6			dw .ENDKEY            
c624 05				db 4 + 1 
c625 .. 00			db "EDIT",0              
c62a				endm 
# End of macro CWHEAD
c62a			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c62a			 
c62a					; TODO does not copy from stack 
c62a					if DEBUG_FORTH_WORDS_KEY 
c62a						DMARK "EDT" 
c62a f5				push af  
c62b 3a 3f c6			ld a, (.dmark)  
c62e 32 71 ee			ld (debug_mark),a  
c631 3a 40 c6			ld a, (.dmark+1)  
c634 32 72 ee			ld (debug_mark+1),a  
c637 3a 41 c6			ld a, (.dmark+2)  
c63a 32 73 ee			ld (debug_mark+2),a  
c63d 18 03			jr .pastdmark  
c63f ..			.dmark: db "EDT"  
c642 f1			.pastdmark: pop af  
c643			endm  
# End of macro DMARK
c643						CALLMONITOR 
c643 cd a3 94			call break_point_state  
c646				endm  
# End of macro CALLMONITOR
c646					endif 
c646			 
c646					;FORTH_DSP 
c646					FORTH_DSP_VALUEHL 
c646 cd 0b 9d			call macro_dsp_valuehl 
c649				endm 
# End of macro FORTH_DSP_VALUEHL
c649			;		inc hl    ; TODO do type check 
c649			 
c649			;		call get_word_hl 
c649 e5					push hl 
c64a					if DEBUG_FORTH_WORDS 
c64a						DMARK "EDp" 
c64a f5				push af  
c64b 3a 5f c6			ld a, (.dmark)  
c64e 32 71 ee			ld (debug_mark),a  
c651 3a 60 c6			ld a, (.dmark+1)  
c654 32 72 ee			ld (debug_mark+1),a  
c657 3a 61 c6			ld a, (.dmark+2)  
c65a 32 73 ee			ld (debug_mark+2),a  
c65d 18 03			jr .pastdmark  
c65f ..			.dmark: db "EDp"  
c662 f1			.pastdmark: pop af  
c663			endm  
# End of macro DMARK
c663						CALLMONITOR 
c663 cd a3 94			call break_point_state  
c666				endm  
# End of macro CALLMONITOR
c666					endif 
c666				;	ld a, 0 
c666 cd 00 91				call strlenz 
c669 23					inc hl 
c66a			 
c66a 06 00				ld b, 0 
c66c 4d					ld c, l 
c66d			 
c66d e1					pop hl 
c66e 11 c9 e4				ld de, os_input 
c671					if DEBUG_FORTH_WORDS_KEY 
c671						DMARK "EDc" 
c671 f5				push af  
c672 3a 86 c6			ld a, (.dmark)  
c675 32 71 ee			ld (debug_mark),a  
c678 3a 87 c6			ld a, (.dmark+1)  
c67b 32 72 ee			ld (debug_mark+1),a  
c67e 3a 88 c6			ld a, (.dmark+2)  
c681 32 73 ee			ld (debug_mark+2),a  
c684 18 03			jr .pastdmark  
c686 ..			.dmark: db "EDc"  
c689 f1			.pastdmark: pop af  
c68a			endm  
# End of macro DMARK
c68a						CALLMONITOR 
c68a cd a3 94			call break_point_state  
c68d				endm  
# End of macro CALLMONITOR
c68d					endif 
c68d ed b0				ldir 
c68f			 
c68f			 
c68f 21 c9 e4				ld hl, os_input 
c692					;ld a, 0 
c692					;ld (hl),a 
c692 3a 68 ea				ld a,(f_cursor_ptr) 
c695 16 64				ld d, 100 
c697 0e 00				ld c, 0 
c699 1e 28				ld e, 40 
c69b cd cf 8c				call input_str 
c69e					; TODO perhaps do a type check and wrap in quotes if not a number 
c69e 21 c9 e4				ld hl, os_input 
c6a1					if DEBUG_FORTH_WORDS 
c6a1						DMARK "ED1" 
c6a1 f5				push af  
c6a2 3a b6 c6			ld a, (.dmark)  
c6a5 32 71 ee			ld (debug_mark),a  
c6a8 3a b7 c6			ld a, (.dmark+1)  
c6ab 32 72 ee			ld (debug_mark+1),a  
c6ae 3a b8 c6			ld a, (.dmark+2)  
c6b1 32 73 ee			ld (debug_mark+2),a  
c6b4 18 03			jr .pastdmark  
c6b6 ..			.dmark: db "ED1"  
c6b9 f1			.pastdmark: pop af  
c6ba			endm  
# End of macro DMARK
c6ba						CALLMONITOR 
c6ba cd a3 94			call break_point_state  
c6bd				endm  
# End of macro CALLMONITOR
c6bd					endif 
c6bd cd 82 9b				call forth_push_str 
c6c0					NEXTW 
c6c0 c3 ba 9e			jp macro_next 
c6c3				endm 
# End of macro NEXTW
c6c3			 
c6c3			 
c6c3			 
c6c3			.ENDKEY: 
c6c3			; eof 
c6c3			 
# End of file forth_words_key.asm
c6c3			include "forth_words_const.asm" 
c6c3			 
c6c3			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c6c3			 
c6c3			 
c6c3			.SPITIME: 
c6c3				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c6c3 77				db WORD_SYS_CORE+99             
c6c4 d8 c6			dw .VA            
c6c6 08				db 7 + 1 
c6c7 .. 00			db "SPITIME",0              
c6cf				endm 
# End of macro CWHEAD
c6cf			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c6cf			; 
c6cf			; | If using BANK devices then leave as is. 
c6cf			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c6cf			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c6cf			 
c6cf 21 6e ea				ld hl, spi_clktime  
c6d2 cd 14 9b				call forth_push_numhl 
c6d5			 
c6d5					NEXTW 
c6d5 c3 ba 9e			jp macro_next 
c6d8				endm 
# End of macro NEXTW
c6d8			 
c6d8			 
c6d8			.VA: 
c6d8				CWHEAD .ENDCONST 99 "VA" 2 WORD_FLAG_CODE 
c6d8 77				db WORD_SYS_CORE+99             
c6d9 e8 c6			dw .ENDCONST            
c6db 03				db 2 + 1 
c6dc .. 00			db "VA",0              
c6df				endm 
# End of macro CWHEAD
c6df			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c6df 21 32 ea				ld hl, cli_var_array 
c6e2 cd 14 9b				call forth_push_numhl 
c6e5			 
c6e5					NEXTW 
c6e5 c3 ba 9e			jp macro_next 
c6e8				endm 
# End of macro NEXTW
c6e8			 
c6e8			 
c6e8			;endif 
c6e8			 
c6e8			;LFSRSeed:	equ $fbb3 
c6e8			;chk_data_ovr:	equ $f761 
c6e8			;chk_loop_ovr:	equ $f963 
c6e8			;chk_ret_ovr:	equ $f9e5 
c6e8			;chk_ret_und:	equ $fa27 
c6e8			;chk_stovr:	equ $fefd 
c6e8			;chk_stund:	equ $ffff 
c6e8			;cli_autodisplay:	equ $fa43 
c6e8			;cli_buffer:	equ $fa51 
c6e8			;cli_data_sp:	equ $fa29 
c6e8			;cli_data_stack:	equ $f763 
c6e8			;cli_execword:	equ $fa4b 
c6e8			;cli_loop_sp:	equ $fa2b 
c6e8			;cli_loop_stack:	equ $f965 
c6e8			;cli_mvdot:	equ $fa44 
c6e8			;cli_nextword:	equ $fa49 
c6e8			;cli_origptr:	equ $fa45 
c6e8			;cli_origtoken:	equ $fa4f 
c6e8			;cli_ptr:	equ $fa47 
c6e8			;cli_ret_sp:	equ $fa2d 
c6e8			;cli_ret_stack:	equ $f9e7 
c6e8			;cli_token:	equ $fa4d 
c6e8			;cli_var_array:	equ $fa2f 
c6e8			;cursor_col:	equ $fbcb 
c6e8			;cursor_ptr:	equ $fbc9 
c6e8			;cursor_row:	equ $fbca 
c6e8			;cursor_shape:	equ $fbc7 
c6e8			;debug_mark:	equ $fe6e 
c6e8			;display_fb0:	equ $fdb4 
c6e8			;display_fb1:	equ $fd13 
c6e8			;display_fb2:	equ $fbd1 
c6e8			;display_fb3:	equ $fc72 
c6e8			;display_fb_active:	equ $fbcf 
c6e8			;display_lcde1e2:	equ $fbce 
c6e8			;execscratch:	equ $f2fb 
c6e8			;f_cursor_ptr:	equ $fa65 
c6e8			;hardware_word:	equ $fe72 
c6e8			;heap_start:	equ $800e 
c6e8			;iErrorNum:	equ $fba8 
c6e8			;iErrorReg:	equ $fba7 
c6e8			;iErrorVer:	equ $fba6 
c6e8			;input_at_cursor:	equ $fe65 
c6e8			;input_at_pos:	equ $fe67 
c6e8			;input_cur_flash:	equ $fe63 
c6e8			;input_cur_onoff:	equ $fe62 
c6e8			;input_cursor:	equ $fe58 
c6e8			;input_display_size:	equ $fe68 
c6e8			;input_len:	equ $fe5d 
c6e8			;input_ptr:	equ $fe6c 
c6e8			;input_size:	equ $fe69 
c6e8			;input_start:	equ $fe6a 
c6e8			;input_str:	equ $0f79 
c6e8			;input_under_cursor:	equ $fe66 
c6e8			;key_actual_pressed:	equ $fe57 
c6e8			;key_fa:	equ $fe82 
c6e8			;key_face_held:	equ $fe7e 
c6e8			;key_fb:	equ $fe81 
c6e8			;key_fc:	equ $fe80 
c6e8			;key_fd:	equ $fe7f 
c6e8			;key_held:	equ $fe88 
c6e8			;key_held_prev:	equ $fe87 
c6e8			;key_init:	equ $7060 
c6e8			;key_repeat_ct:	equ $fe83 
c6e8			;key_rows:	equ $0005 
c6e8			;key_shift:	equ $fe55 
c6e8			;key_symbol:	equ $fe56 
c6e8			;keyscan_scancol:	equ $fe89 
c6e8			;keyscan_table:	equ $fe93 
c6e8			;keyscan_table_row1:	equ $fef2 
c6e8			;keyscan_table_row2:	equ $fee7 
c6e8			;keyscan_table_row3:	equ $fedc 
c6e8			;keyscan_table_row4:	equ $fed1 
c6e8			;keyscan_table_row5:	equ $fec6 
c6e8			;os_cli_cmd:	equ $f523 
c6e8			;os_cur_ptr:	equ $f51f 
c6e8			;os_current_i:	equ $f521 
c6e8			;os_input:	equ $f3fa 
c6e8			;os_last_cmd:	equ $f622 
c6e8			;os_last_new_uword:	equ $f4f9 
c6e8			;os_new_exec:	equ $f1f0 
c6e8			;os_new_exec_ptr:	equ $f1ee 
c6e8			;os_new_malloc:	equ $f1fa 
c6e8			;os_new_parse_len:	equ $f1f8 
c6e8			;os_new_src_ptr:	equ $f1f2 
c6e8			;os_new_word_len:	equ $f1f6 
c6e8			;os_new_work_ptr:	equ $f1f4 
c6e8			;os_tok_len:	equ $f4ff 
c6e8			;os_tok_malloc:	equ $f4fb 
c6e8			;os_tok_ptr:	equ $f4fd 
c6e8			;os_var_array:	equ $f721 
c6e8			;os_view_af:	equ $f1eb 
c6e8			;os_view_bc:	equ $f1e5 
c6e8			;os_view_de:	equ $f1e7 
c6e8			;os_view_disable:	equ $f1ed 
c6e8			;os_view_hl:	equ $f1e9 
c6e8			;os_word_scratch:	equ $f501 
c6e8			;portbctl:	equ $00c3 
c6e8			;portbdata:	equ $00c1 
c6e8			;prng16:	equ $0e73 
c6e8			;prom_bootmsg:	equ $1ac9 
c6e8			;prom_bootmsg1:	equ $1ade 
c6e8			;randData:	equ $fbb1 
c6e8			;scratch:	equ $f1fc 
c6e8			;seed1:	equ $fbab 
c6e8			;seed2:	equ $fba9 
c6e8			;spi_cartdev:	equ $fa6a 
c6e8			;spi_cartdev2:	equ $fa69 
c6e8			;spi_clktime:	equ $fa6b 
c6e8			;spi_device:	equ $fa67 
c6e8			;spi_device_id:	equ $fa66 
c6e8			;spi_portbyte:	equ $fa68 
c6e8			;stackstore:	equ $fbad 
c6e8			;;start1:	equ $5bfc 
c6e8			;;start2:	equ $5c0e 
c6e8			;;start3b:	equ $5c21 
c6e8			;;start3c:	equ $5c9d 
c6e8			;;startcmds:	equ $57a3 
c6e8			;;stest:	equ $5d67 
c6e8			;;storage_actl:	equ $0082 
c6e8			;;storage_adata:	equ $0080 
c6e8			;;storage_append:	equ $0b0c 
c6e8			;;storage_bctl:	equ $0083 
c6e8			;store_bank_active:	equ $fb99 
c6e8			;store_filecache:	equ $fa6e 
c6e8			;store_longread:	equ $fa7c 
c6e8			;store_openaddr:	equ $fa72 
c6e8			;store_openext:	equ $fa71 
c6e8			;store_openmaxext:	equ $fa70 
c6e8			;store_page:	equ $fa81 
c6e8			;store_readbuf:	equ $fa7d 
c6e8			;store_readcont:	equ $fa74 
c6e8			;store_readptr:	equ $fa7f 
c6e8			;store_tmp1:	equ $fa7a 
c6e8			;store_tmp2:	equ $fa78 
c6e8			;store_tmp3:	equ $fa76 
c6e8			;store_tmpext:	equ $fa74 
c6e8			;store_tmpid:	equ $fa75 
c6e8			;store_tmppageid:	equ $fa6c 
c6e8			;tos:	equ $fffd 
c6e8			;type:	equ $5b77 
c6e8			;xrandc:	equ $fbaf 
c6e8			 
c6e8			 
c6e8			.ENDCONST: 
c6e8			 
c6e8			; eof 
c6e8			 
c6e8			 
# End of file forth_words_const.asm
c6e8			 
c6e8			if STORAGE_SE 
c6e8			   	include "forth_words_storage.asm" 
c6e8			endif 
c6e8				include "forth_words_device.asm" 
c6e8			; Device related words 
c6e8			 
c6e8			; | ## Device Words 
c6e8			 
c6e8			if SOUND_ENABLE 
c6e8			.NOTE: 
c6e8				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c6e8			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c6e8					if DEBUG_FORTH_WORDS_KEY 
c6e8						DMARK "NTE" 
c6e8						CALLMONITOR 
c6e8					endif 
c6e8			 
c6e8				 
c6e8			 
c6e8					NEXTW 
c6e8			.AFTERSOUND: 
c6e8			endif 
c6e8			 
c6e8			 
c6e8			USE_GPIO: equ 0 
c6e8			 
c6e8			if USE_GPIO 
c6e8			.GP1: 
c6e8				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c6e8			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c6e8					NEXTW 
c6e8			.GP2: 
c6e8				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c6e8			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c6e8			 
c6e8					NEXTW 
c6e8			 
c6e8			.GP3: 
c6e8				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c6e8			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c6e8			 
c6e8					NEXTW 
c6e8			 
c6e8			.GP4: 
c6e8				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c6e8			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c6e8			 
c6e8					NEXTW 
c6e8			.SIN: 
c6e8			 
c6e8			 
c6e8			endif 
c6e8			 
c6e8			 
c6e8				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c6e8 33				db WORD_SYS_CORE+31             
c6e9 1d c7			dw .SOUT            
c6eb 03				db 2 + 1 
c6ec .. 00			db "IN",0              
c6ef				endm 
# End of macro CWHEAD
c6ef			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c6ef					if DEBUG_FORTH_WORDS_KEY 
c6ef						DMARK "IN." 
c6ef f5				push af  
c6f0 3a 04 c7			ld a, (.dmark)  
c6f3 32 71 ee			ld (debug_mark),a  
c6f6 3a 05 c7			ld a, (.dmark+1)  
c6f9 32 72 ee			ld (debug_mark+1),a  
c6fc 3a 06 c7			ld a, (.dmark+2)  
c6ff 32 73 ee			ld (debug_mark+2),a  
c702 18 03			jr .pastdmark  
c704 ..			.dmark: db "IN."  
c707 f1			.pastdmark: pop af  
c708			endm  
# End of macro DMARK
c708						CALLMONITOR 
c708 cd a3 94			call break_point_state  
c70b				endm  
# End of macro CALLMONITOR
c70b					endif 
c70b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c70b cd 0b 9d			call macro_dsp_valuehl 
c70e				endm 
# End of macro FORTH_DSP_VALUEHL
c70e			 
c70e e5					push hl 
c70f			 
c70f					; destroy value TOS 
c70f			 
c70f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c70f cd c3 9d			call macro_forth_dsp_pop 
c712				endm 
# End of macro FORTH_DSP_POP
c712			 
c712					; one value on hl get other one back 
c712			 
c712 c1					pop bc 
c713			 
c713					; do the sub 
c713			;		ex de, hl 
c713			 
c713 ed 68				in l,(c) 
c715			 
c715					; save it 
c715			 
c715 26 00				ld h,0 
c717			 
c717					; TODO push value back onto stack for another op etc 
c717			 
c717 cd 14 9b				call forth_push_numhl 
c71a					NEXTW 
c71a c3 ba 9e			jp macro_next 
c71d				endm 
# End of macro NEXTW
c71d			.SOUT: 
c71d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c71d 34				db WORD_SYS_CORE+32             
c71e 70 c7			dw .SPIO            
c720 04				db 3 + 1 
c721 .. 00			db "OUT",0              
c725				endm 
# End of macro CWHEAD
c725			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c725					if DEBUG_FORTH_WORDS_KEY 
c725						DMARK "OUT" 
c725 f5				push af  
c726 3a 3a c7			ld a, (.dmark)  
c729 32 71 ee			ld (debug_mark),a  
c72c 3a 3b c7			ld a, (.dmark+1)  
c72f 32 72 ee			ld (debug_mark+1),a  
c732 3a 3c c7			ld a, (.dmark+2)  
c735 32 73 ee			ld (debug_mark+2),a  
c738 18 03			jr .pastdmark  
c73a ..			.dmark: db "OUT"  
c73d f1			.pastdmark: pop af  
c73e			endm  
# End of macro DMARK
c73e						CALLMONITOR 
c73e cd a3 94			call break_point_state  
c741				endm  
# End of macro CALLMONITOR
c741					endif 
c741			 
c741					; get port 
c741			 
c741					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c741 cd 0b 9d			call macro_dsp_valuehl 
c744				endm 
# End of macro FORTH_DSP_VALUEHL
c744			 
c744 e5					push hl 
c745			 
c745					; destroy value TOS 
c745			 
c745					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c745 cd c3 9d			call macro_forth_dsp_pop 
c748				endm 
# End of macro FORTH_DSP_POP
c748			 
c748					; get byte to send 
c748			 
c748					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c748 cd 0b 9d			call macro_dsp_valuehl 
c74b				endm 
# End of macro FORTH_DSP_VALUEHL
c74b			 
c74b			;		push hl 
c74b			 
c74b					; destroy value TOS 
c74b			 
c74b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c74b cd c3 9d			call macro_forth_dsp_pop 
c74e				endm 
# End of macro FORTH_DSP_POP
c74e			 
c74e					; one value on hl get other one back 
c74e			 
c74e			;		pop hl 
c74e			 
c74e c1					pop bc 
c74f			 
c74f					if DEBUG_FORTH_WORDS 
c74f						DMARK "OUT" 
c74f f5				push af  
c750 3a 64 c7			ld a, (.dmark)  
c753 32 71 ee			ld (debug_mark),a  
c756 3a 65 c7			ld a, (.dmark+1)  
c759 32 72 ee			ld (debug_mark+1),a  
c75c 3a 66 c7			ld a, (.dmark+2)  
c75f 32 73 ee			ld (debug_mark+2),a  
c762 18 03			jr .pastdmark  
c764 ..			.dmark: db "OUT"  
c767 f1			.pastdmark: pop af  
c768			endm  
# End of macro DMARK
c768						CALLMONITOR 
c768 cd a3 94			call break_point_state  
c76b				endm  
# End of macro CALLMONITOR
c76b					endif 
c76b			 
c76b ed 69				out (c), l 
c76d			 
c76d					NEXTW 
c76d c3 ba 9e			jp macro_next 
c770				endm 
# End of macro NEXTW
c770			 
c770			 
c770			.SPIO: 
c770			 
c770			if STORAGE_SE 
c770				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c770			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c770			 
c770					call spi_ce_low 
c770			    NEXTW 
c770			 
c770			.SPICEH: 
c770				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c770			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c770			 
c770					call spi_ce_high 
c770			    NEXTW 
c770			 
c770			 
c770			.SPIOb: 
c770			 
c770				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c770			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c770			 
c770					if DEBUG_FORTH_WORDS_KEY 
c770						DMARK "SPo" 
c770						CALLMONITOR 
c770					endif 
c770					; get port 
c770			 
c770			 
c770					; get byte to send 
c770			 
c770					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c770			 
c770			;		push hl    ; u1  
c770			 
c770					; destroy value TOS 
c770			 
c770					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c770			 
c770					; one value on hl get other one back 
c770			 
c770			;		pop hl   ; u2 - addr 
c770			 
c770					; TODO Send SPI byte 
c770			 
c770			;		push hl 
c770			;		call spi_ce_low 
c770			;		pop hl 
c770					ld a, l 
c770					call spi_send_byte 
c770			;		call spi_ce_high 
c770			 
c770					NEXTW 
c770			 
c770			.SPII: 
c770				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c770			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c770					if DEBUG_FORTH_WORDS_KEY 
c770						DMARK "SPi" 
c770						CALLMONITOR 
c770					endif 
c770			 
c770					; TODO Get SPI byte 
c770			 
c770					call spi_read_byte 
c770			 
c770					if DEBUG_FORTH_WORDS 
c770						DMARK "Si2" 
c770						CALLMONITOR 
c770					endif 
c770					ld h, 0 
c770					ld l, a 
c770					if DEBUG_FORTH_WORDS 
c770						DMARK "Si3" 
c770						CALLMONITOR 
c770					endif 
c770					call forth_push_numhl 
c770			 
c770					NEXTW 
c770			 
c770			 
c770			 
c770			.SESEL: 
c770				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c770			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c770					if DEBUG_FORTH_WORDS_KEY 
c770						DMARK "BNK" 
c770						CALLMONITOR 
c770					endif 
c770			 
c770					ld a, 255 
c770					ld (spi_cartdev), a 
c770			 
c770					; get bank 
c770			 
c770					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c770			 
c770			;		push hl 
c770			 
c770					; destroy value TOS 
c770			 
c770					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c770			 
c770					; one value on hl get other one back 
c770			 
c770			;		pop hl 
c770			 
c770			 
c770					ld c, SPI_CE_HIGH 
c770					ld b, '0'    ; human readable bank number 
c770			 
c770					ld a, l 
c770			 
c770					if DEBUG_FORTH_WORDS 
c770						DMARK "BNK" 
c770						CALLMONITOR 
c770					endif 
c770			 
c770					; active low 
c770			 
c770					cp 0 
c770					jr z, .bset 
c770					cp 1 
c770					jr nz, .b2 
c770					res 0, c 
c770					ld b, '1'    ; human readable bank number 
c770			.b2:		cp 2 
c770					jr nz, .b3 
c770					res 1, c 
c770					ld b, '2'    ; human readable bank number 
c770			.b3:		cp 3 
c770					jr nz, .b4 
c770					res 2, c 
c770					ld b, '3'    ; human readable bank number 
c770			.b4:		cp 4 
c770					jr nz, .b5 
c770					res 3, c 
c770					ld b, '4'    ; human readable bank number 
c770			.b5:		cp 5 
c770					jr nz, .bset 
c770					res 4, c 
c770					ld b, '5'    ; human readable bank number 
c770			 
c770			.bset: 
c770					ld a, c 
c770					ld (spi_device),a 
c770					ld a, b 
c770					ld (spi_device_id),a 
c770					if DEBUG_FORTH_WORDS 
c770						DMARK "BN2" 
c770						CALLMONITOR 
c770					endif 
c770			 
c770					; set default SPI clk pulse time as disabled for BANK use 
c770			 
c770					ld a, 0 
c770					ld (spi_clktime), a 
c770			 
c770					NEXTW 
c770			 
c770			.CARTDEV: 
c770				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c770			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c770					if DEBUG_FORTH_WORDS_KEY 
c770						DMARK "CDV" 
c770						CALLMONITOR 
c770					endif 
c770			 
c770					; disable se storage bank selection 
c770			 
c770					ld a, SPI_CE_HIGH		; ce high 
c770					ld (spi_device), a 
c770			 
c770					; get bank 
c770			 
c770					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c770			 
c770			;		push hl 
c770			 
c770					; destroy value TOS 
c770			 
c770					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c770			 
c770					; one value on hl get other one back 
c770			 
c770			;		pop hl 
c770			 
c770					; active low 
c770			 
c770					ld c, 255 
c770			 
c770					ld a, l 
c770					if DEBUG_FORTH_WORDS 
c770						DMARK "CDV" 
c770						CALLMONITOR 
c770					endif 
c770					cp 0 
c770					jr z, .cset 
c770					cp 1 
c770					jr nz, .c2 
c770					res 0, c 
c770			.c2:		cp 2 
c770					jr nz, .c3 
c770					res 1, c 
c770			.c3:		cp 3 
c770					jr nz, .c4 
c770					res 2, c 
c770			.c4:		cp 4 
c770					jr nz, .c5 
c770					res 3, c 
c770			.c5:		cp 5 
c770					jr nz, .c6 
c770					res 4, c 
c770			.c6:		cp 6 
c770					jr nz, .c7 
c770					res 5, c 
c770			.c7:		cp 7 
c770					jr nz, .c8 
c770					res 6, c 
c770			.c8:		cp 8 
c770					jr nz, .cset 
c770					res 7, c 
c770			.cset:		ld a, c 
c770					ld (spi_cartdev),a 
c770			 
c770					if DEBUG_FORTH_WORDS 
c770						DMARK "CD2" 
c770						CALLMONITOR 
c770					endif 
c770			 
c770					; set default SPI clk pulse time as 10ms for CARTDEV use 
c770			 
c770					ld a, $0a 
c770					ld (spi_clktime), a 
c770					NEXTW 
c770			endif 
c770			 
c770			.ENDDEVICE: 
c770			; eof 
c770			 
# End of file forth_words_device.asm
c770			 
c770			; var handler 
c770			 
c770			 
c770			.VARS: 
c770				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c770 77				db WORD_SYS_CORE+99             
c771 21 c8			dw .V0            
c773 04				db 3 + 1 
c774 .. 00			db "VAR",0              
c778				endm 
# End of macro CWHEAD
c778			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c778			;| 
c778			;| The variable name should consist of a single letter. e.g. "a" 
c778			;! If a full string is passed then only the first char is looked at 
c778			;| Any other char could exceed bounds checks!  
c778			 
c778					if DEBUG_FORTH_WORDS_KEY 
c778						DMARK "VAR" 
c778 f5				push af  
c779 3a 8d c7			ld a, (.dmark)  
c77c 32 71 ee			ld (debug_mark),a  
c77f 3a 8e c7			ld a, (.dmark+1)  
c782 32 72 ee			ld (debug_mark+1),a  
c785 3a 8f c7			ld a, (.dmark+2)  
c788 32 73 ee			ld (debug_mark+2),a  
c78b 18 03			jr .pastdmark  
c78d ..			.dmark: db "VAR"  
c790 f1			.pastdmark: pop af  
c791			endm  
# End of macro DMARK
c791						CALLMONITOR 
c791 cd a3 94			call break_point_state  
c794				endm  
# End of macro CALLMONITOR
c794					endif 
c794			 
c794					FORTH_DSP_VALUEHL 
c794 cd 0b 9d			call macro_dsp_valuehl 
c797				endm 
# End of macro FORTH_DSP_VALUEHL
c797			 
c797 7e					ld a, (hl)    ; get first char on of the string 
c798			 
c798			 
c798					if DEBUG_FORTH_WORDS 
c798						DMARK "VR1" 
c798 f5				push af  
c799 3a ad c7			ld a, (.dmark)  
c79c 32 71 ee			ld (debug_mark),a  
c79f 3a ae c7			ld a, (.dmark+1)  
c7a2 32 72 ee			ld (debug_mark+1),a  
c7a5 3a af c7			ld a, (.dmark+2)  
c7a8 32 73 ee			ld (debug_mark+2),a  
c7ab 18 03			jr .pastdmark  
c7ad ..			.dmark: db "VR1"  
c7b0 f1			.pastdmark: pop af  
c7b1			endm  
# End of macro DMARK
c7b1						CALLMONITOR 
c7b1 cd a3 94			call break_point_state  
c7b4				endm  
# End of macro CALLMONITOR
c7b4					endif 
c7b4					 
c7b4 f5					push af	 
c7b5					FORTH_DSP_POP 
c7b5 cd c3 9d			call macro_forth_dsp_pop 
c7b8				endm 
# End of macro FORTH_DSP_POP
c7b8 f1					pop af 
c7b9			 
c7b9					; convert to upper 
c7b9			 
c7b9 cd 0f 90				call to_upper 
c7bc					if DEBUG_FORTH_WORDS 
c7bc						DMARK "Vaa" 
c7bc f5				push af  
c7bd 3a d1 c7			ld a, (.dmark)  
c7c0 32 71 ee			ld (debug_mark),a  
c7c3 3a d2 c7			ld a, (.dmark+1)  
c7c6 32 72 ee			ld (debug_mark+1),a  
c7c9 3a d3 c7			ld a, (.dmark+2)  
c7cc 32 73 ee			ld (debug_mark+2),a  
c7cf 18 03			jr .pastdmark  
c7d1 ..			.dmark: db "Vaa"  
c7d4 f1			.pastdmark: pop af  
c7d5			endm  
# End of macro DMARK
c7d5						CALLMONITOR 
c7d5 cd a3 94			call break_point_state  
c7d8				endm  
# End of macro CALLMONITOR
c7d8					endif 
c7d8 06 41				ld b, 'A' 
c7da 90					sub b			; set offset 
c7db					if DEBUG_FORTH_WORDS 
c7db						DMARK "Vbb" 
c7db f5				push af  
c7dc 3a f0 c7			ld a, (.dmark)  
c7df 32 71 ee			ld (debug_mark),a  
c7e2 3a f1 c7			ld a, (.dmark+1)  
c7e5 32 72 ee			ld (debug_mark+1),a  
c7e8 3a f2 c7			ld a, (.dmark+2)  
c7eb 32 73 ee			ld (debug_mark+2),a  
c7ee 18 03			jr .pastdmark  
c7f0 ..			.dmark: db "Vbb"  
c7f3 f1			.pastdmark: pop af  
c7f4			endm  
# End of macro DMARK
c7f4						CALLMONITOR 
c7f4 cd a3 94			call break_point_state  
c7f7				endm  
# End of macro CALLMONITOR
c7f7					endif 
c7f7 cb 27				sla a  
c7f9				 
c7f9					 
c7f9					if DEBUG_FORTH_WORDS 
c7f9						DMARK "VR2" 
c7f9 f5				push af  
c7fa 3a 0e c8			ld a, (.dmark)  
c7fd 32 71 ee			ld (debug_mark),a  
c800 3a 0f c8			ld a, (.dmark+1)  
c803 32 72 ee			ld (debug_mark+1),a  
c806 3a 10 c8			ld a, (.dmark+2)  
c809 32 73 ee			ld (debug_mark+2),a  
c80c 18 03			jr .pastdmark  
c80e ..			.dmark: db "VR2"  
c811 f1			.pastdmark: pop af  
c812			endm  
# End of macro DMARK
c812						CALLMONITOR 
c812 cd a3 94			call break_point_state  
c815				endm  
# End of macro CALLMONITOR
c815					endif 
c815			 
c815 21 fe e9				ld hl, cli_var_array2 
c818 cd a2 8c				call addatohl 
c81b cd 14 9b				call forth_push_numhl 
c81e			 
c81e			 
c81e				       NEXTW 
c81e c3 ba 9e			jp macro_next 
c821				endm 
# End of macro NEXTW
c821			.V0: 
c821				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c821 78				db WORD_SYS_CORE+100             
c822 39 c8			dw .V0Q            
c824 04				db 3 + 1 
c825 .. 00			db "V0!",0              
c829				endm 
# End of macro CWHEAD
c829			;| V0! ( u1 -- )  Store value to v0  | DONE 
c829			 
c829					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c829 cd 0b 9d			call macro_dsp_valuehl 
c82c				endm 
# End of macro FORTH_DSP_VALUEHL
c82c			 
c82c 11 32 ea				ld de, cli_var_array 
c82f			 
c82f eb					ex de, hl 
c830 73					ld (hl), e 
c831 23					inc hl 
c832 72					ld (hl), d 
c833			 
c833					; destroy value TOS 
c833			 
c833					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c833 cd c3 9d			call macro_forth_dsp_pop 
c836				endm 
# End of macro FORTH_DSP_POP
c836			 
c836				       NEXTW 
c836 c3 ba 9e			jp macro_next 
c839				endm 
# End of macro NEXTW
c839			.V0Q: 
c839				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c839 79				db WORD_SYS_CORE+101             
c83a 4a c8			dw .V1S            
c83c 04				db 3 + 1 
c83d .. 00			db "V0@",0              
c841				endm 
# End of macro CWHEAD
c841			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c841 2a 32 ea				ld hl, (cli_var_array) 
c844 cd 14 9b				call forth_push_numhl 
c847			 
c847				       NEXTW 
c847 c3 ba 9e			jp macro_next 
c84a				endm 
# End of macro NEXTW
c84a			.V1S: 
c84a				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c84a 7a				db WORD_SYS_CORE+102             
c84b 62 c8			dw .V1Q            
c84d 04				db 3 + 1 
c84e .. 00			db "V1!",0              
c852				endm 
# End of macro CWHEAD
c852			;| V1! ( u1 -- )  Store value to v1 | DONE 
c852					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c852 cd 0b 9d			call macro_dsp_valuehl 
c855				endm 
# End of macro FORTH_DSP_VALUEHL
c855			 
c855 11 34 ea				ld de, cli_var_array+2 
c858				 
c858 eb					ex de, hl 
c859 73					ld (hl), e 
c85a 23					inc hl 
c85b 72					ld (hl), d 
c85c			 
c85c					; destroy value TOS 
c85c			 
c85c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c85c cd c3 9d			call macro_forth_dsp_pop 
c85f				endm 
# End of macro FORTH_DSP_POP
c85f				       NEXTW 
c85f c3 ba 9e			jp macro_next 
c862				endm 
# End of macro NEXTW
c862			.V1Q: 
c862				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c862 7b				db WORD_SYS_CORE+103             
c863 73 c8			dw .V2S            
c865 04				db 3 + 1 
c866 .. 00			db "V1@",0              
c86a				endm 
# End of macro CWHEAD
c86a			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c86a 2a 34 ea				ld hl, (cli_var_array+2) 
c86d cd 14 9b				call forth_push_numhl 
c870				       NEXTW 
c870 c3 ba 9e			jp macro_next 
c873				endm 
# End of macro NEXTW
c873			.V2S: 
c873				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c873 7c				db WORD_SYS_CORE+104             
c874 8b c8			dw .V2Q            
c876 04				db 3 + 1 
c877 .. 00			db "V2!",0              
c87b				endm 
# End of macro CWHEAD
c87b			;| V2! ( u1 -- )  Store value to v2 | DONE 
c87b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c87b cd 0b 9d			call macro_dsp_valuehl 
c87e				endm 
# End of macro FORTH_DSP_VALUEHL
c87e			 
c87e 11 36 ea				ld de, cli_var_array+4 
c881				 
c881 eb					ex de, hl 
c882 73					ld (hl), e 
c883 23					inc hl 
c884 72					ld (hl), d 
c885			 
c885					; destroy value TOS 
c885			 
c885					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c885 cd c3 9d			call macro_forth_dsp_pop 
c888				endm 
# End of macro FORTH_DSP_POP
c888				       NEXTW 
c888 c3 ba 9e			jp macro_next 
c88b				endm 
# End of macro NEXTW
c88b			.V2Q: 
c88b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c88b 7d				db WORD_SYS_CORE+105             
c88c 9c c8			dw .V3S            
c88e 04				db 3 + 1 
c88f .. 00			db "V2@",0              
c893				endm 
# End of macro CWHEAD
c893			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c893 2a 36 ea				ld hl, (cli_var_array+4) 
c896 cd 14 9b				call forth_push_numhl 
c899				       NEXTW 
c899 c3 ba 9e			jp macro_next 
c89c				endm 
# End of macro NEXTW
c89c			.V3S: 
c89c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c89c 7c				db WORD_SYS_CORE+104             
c89d b4 c8			dw .V3Q            
c89f 04				db 3 + 1 
c8a0 .. 00			db "V3!",0              
c8a4				endm 
# End of macro CWHEAD
c8a4			;| V3! ( u1 -- )  Store value to v3 | DONE 
c8a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c8a4 cd 0b 9d			call macro_dsp_valuehl 
c8a7				endm 
# End of macro FORTH_DSP_VALUEHL
c8a7			 
c8a7 11 38 ea				ld de, cli_var_array+6 
c8aa				 
c8aa eb					ex de, hl 
c8ab 73					ld (hl), e 
c8ac 23					inc hl 
c8ad 72					ld (hl), d 
c8ae			 
c8ae					; destroy value TOS 
c8ae			 
c8ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8ae cd c3 9d			call macro_forth_dsp_pop 
c8b1				endm 
# End of macro FORTH_DSP_POP
c8b1				       NEXTW 
c8b1 c3 ba 9e			jp macro_next 
c8b4				endm 
# End of macro NEXTW
c8b4			.V3Q: 
c8b4				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c8b4 7d				db WORD_SYS_CORE+105             
c8b5 c5 c8			dw .END            
c8b7 04				db 3 + 1 
c8b8 .. 00			db "V3@",0              
c8bc				endm 
# End of macro CWHEAD
c8bc			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c8bc 2a 38 ea				ld hl, (cli_var_array+6) 
c8bf cd 14 9b				call forth_push_numhl 
c8c2				       NEXTW 
c8c2 c3 ba 9e			jp macro_next 
c8c5				endm 
# End of macro NEXTW
c8c5			 
c8c5			 
c8c5			 
c8c5			 
c8c5			 
c8c5			; end of dict marker 
c8c5			 
c8c5 00			.END:    db WORD_SYS_END 
c8c6 00 00			dw 0 
c8c8 00				db 0 
c8c9			 
c8c9			; use to jp here for user dict words to save on macro expansion  
c8c9			 
c8c9			user_dict_next: 
c8c9				NEXTW 
c8c9 c3 ba 9e			jp macro_next 
c8cc				endm 
# End of macro NEXTW
c8cc			 
c8cc			 
c8cc			user_exec: 
c8cc				;    ld hl, <word code> 
c8cc				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c8cc				;    call forthexec 
c8cc				;    jp user_dict_next   (NEXT) 
c8cc			        ;    <word code bytes> 
c8cc eb				ex de, hl 
c8cd 2a cc e5			ld hl,(os_tok_ptr) 
c8d0				 
c8d0				FORTH_RSP_NEXT 
c8d0 cd bb 9a			call macro_forth_rsp_next 
c8d3				endm 
# End of macro FORTH_RSP_NEXT
c8d3			 
c8d3			if DEBUG_FORTH_UWORD 
c8d3						DMARK "UEX" 
c8d3 f5				push af  
c8d4 3a e8 c8			ld a, (.dmark)  
c8d7 32 71 ee			ld (debug_mark),a  
c8da 3a e9 c8			ld a, (.dmark+1)  
c8dd 32 72 ee			ld (debug_mark+1),a  
c8e0 3a ea c8			ld a, (.dmark+2)  
c8e3 32 73 ee			ld (debug_mark+2),a  
c8e6 18 03			jr .pastdmark  
c8e8 ..			.dmark: db "UEX"  
c8eb f1			.pastdmark: pop af  
c8ec			endm  
# End of macro DMARK
c8ec				CALLMONITOR 
c8ec cd a3 94			call break_point_state  
c8ef				endm  
# End of macro CALLMONITOR
c8ef			endif 
c8ef			 
c8ef			 
c8ef			 
c8ef eb				ex de, hl 
c8f0 22 cc e5			ld (os_tok_ptr), hl 
c8f3				 
c8f3				; Don't use next - Skips the first word in uword. 
c8f3			 
c8f3 c3 4b 9f			jp exec1 
c8f6			;	NEXT 
c8f6			 
c8f6			 
c8f6			; eof 
# End of file forth_wordsv4.asm
c8f6			endif 
c8f6			;;;;;;;;;;;;;; Debug code 
c8f6			 
c8f6			 
c8f6			;if DEBUG_FORTH_PARSE 
c8f6 .. 00		.nowordfound: db "No match",0 
c8ff .. 00		.compword:	db "Comparing word ",0 
c90f .. 00		.nextwordat:	db "Next word at",0 
c91c .. 00		.charmatch:	db "Char match",0 
c927			;endif 
c927			if DEBUG_FORTH_JP 
c927			.foundword:	db "Word match. Exec..",0 
c927			endif 
c927			;if DEBUG_FORTH_PUSH 
c927 .. 00		.enddict:	db "Dict end. Push.",0 
c937 .. 00		.push_str:	db "Pushing string",0 
c946 .. 00		.push_num:	db "Pushing number",0 
c955 .. 00		.data_sp:	db "SP:",0 
c959 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c96b .. 00		.wordinde:	db "Word in DE (3/0):",0 
c97d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c98f			;endif 
c98f			;if DEBUG_FORTH_MALLOC 
c98f .. 00		.push_malloc:	db "Malloc address",0 
c99e			;endif 
c99e			 
c99e			 
c99e			 
c99e			; display malloc address and current data stack pointer  
c99e			 
c99e			malloc_error: 
c99e d5				push de 
c99f f5				push af 
c9a0 e5				push hl 
c9a1 cd 75 8a			call clear_display 
c9a4 11 c6 c9			ld de, .mallocerr 
c9a7 3e 00			ld a,0 
c9a9			;	ld de,os_word_scratch 
c9a9 cd 88 8a			call str_at_display 
c9ac 3e 11			ld a, display_row_1+17 
c9ae 11 71 ee			ld de, debug_mark 
c9b1 cd 88 8a			call str_at_display 
c9b4 cd 98 8a			call update_display 
c9b7				;call break_point_state 
c9b7 cd 46 e0			call cin_wait 
c9ba			 
c9ba 3e 20			ld a, ' ' 
c9bc 32 bc e2			ld (os_view_disable), a 
c9bf e1				pop hl 
c9c0 f1				pop af 
c9c1 d1				pop de	 
c9c2				CALLMONITOR 
c9c2 cd a3 94			call break_point_state  
c9c5				endm  
# End of macro CALLMONITOR
c9c5 c9				ret 
c9c6			 
c9c6 .. 00		.mallocerr: 	db "Malloc Error",0 
c9d3			;if DEBUG_FORTH_PUSH 
c9d3			display_data_sp: 
c9d3 f5				push af 
c9d4			 
c9d4				; see if disabled 
c9d4			 
c9d4 3a bc e2			ld a, (os_view_disable) 
c9d7 fe 2a			cp '*' 
c9d9 28 67			jr z, .skipdsp 
c9db			 
c9db e5				push hl 
c9dc e5				push hl 
c9dd e5			push hl 
c9de cd 75 8a			call clear_display 
c9e1 e1			pop hl 
c9e2 7c				ld a,h 
c9e3 21 d0 e5			ld hl, os_word_scratch 
c9e6 cd a3 8f			call hexout 
c9e9 e1				pop hl 
c9ea 7d				ld a,l 
c9eb 21 d2 e5			ld hl, os_word_scratch+2 
c9ee cd a3 8f			call hexout 
c9f1 21 d4 e5			ld hl, os_word_scratch+4 
c9f4 3e 00			ld a,0 
c9f6 77				ld (hl),a 
c9f7 11 d0 e5			ld de,os_word_scratch 
c9fa 3e 28				ld a, display_row_2 
c9fc cd 88 8a				call str_at_display 
c9ff 11 59 c9			ld de, .wordinhl 
ca02 3e 00			ld a, display_row_1 
ca04			 
ca04 cd 88 8a				call str_at_display 
ca07 11 71 ee			ld de, debug_mark 
ca0a 3e 11			ld a, display_row_1+17 
ca0c			 
ca0c cd 88 8a				call str_at_display 
ca0f			 
ca0f				; display current data stack pointer 
ca0f 11 55 c9			ld de,.data_sp 
ca12 3e 30				ld a, display_row_2 + 8 
ca14 cd 88 8a				call str_at_display 
ca17			 
ca17 2a f8 e9			ld hl,(cli_data_sp) 
ca1a e5				push hl 
ca1b 7c				ld a,h 
ca1c 21 d0 e5			ld hl, os_word_scratch 
ca1f cd a3 8f			call hexout 
ca22 e1				pop hl 
ca23 7d				ld a,l 
ca24 21 d2 e5			ld hl, os_word_scratch+2 
ca27 cd a3 8f			call hexout 
ca2a 21 d4 e5			ld hl, os_word_scratch+4 
ca2d 3e 00			ld a,0 
ca2f 77				ld (hl),a 
ca30 11 d0 e5			ld de,os_word_scratch 
ca33 3e 33				ld a, display_row_2 + 11 
ca35 cd 88 8a				call str_at_display 
ca38			 
ca38			 
ca38 cd 98 8a			call update_display 
ca3b cd f2 89			call delay1s 
ca3e cd f2 89			call delay1s 
ca41 e1				pop hl 
ca42			.skipdsp: 
ca42 f1				pop af 
ca43 c9				ret 
ca44			 
ca44			display_data_malloc: 
ca44			 
ca44 f5				push af 
ca45 e5				push hl 
ca46 e5				push hl 
ca47 e5			push hl 
ca48 cd 75 8a			call clear_display 
ca4b e1			pop hl 
ca4c 7c				ld a,h 
ca4d 21 d0 e5			ld hl, os_word_scratch 
ca50 cd a3 8f			call hexout 
ca53 e1				pop hl 
ca54 7d				ld a,l 
ca55 21 d2 e5			ld hl, os_word_scratch+2 
ca58 cd a3 8f			call hexout 
ca5b 21 d4 e5			ld hl, os_word_scratch+4 
ca5e 3e 00			ld a,0 
ca60 77				ld (hl),a 
ca61 11 d0 e5			ld de,os_word_scratch 
ca64 3e 28				ld a, display_row_2 
ca66 cd 88 8a				call str_at_display 
ca69 11 8f c9			ld de, .push_malloc 
ca6c 3e 00			ld a, display_row_1 
ca6e			 
ca6e cd 88 8a				call str_at_display 
ca71			 
ca71				; display current data stack pointer 
ca71 11 55 c9			ld de,.data_sp 
ca74 3e 30				ld a, display_row_2 + 8 
ca76 cd 88 8a				call str_at_display 
ca79			 
ca79 2a f8 e9			ld hl,(cli_data_sp) 
ca7c e5				push hl 
ca7d 7c				ld a,h 
ca7e 21 d0 e5			ld hl, os_word_scratch 
ca81 cd a3 8f			call hexout 
ca84 e1				pop hl 
ca85 7d				ld a,l 
ca86 21 d2 e5			ld hl, os_word_scratch+2 
ca89 cd a3 8f			call hexout 
ca8c 21 d4 e5			ld hl, os_word_scratch+4 
ca8f 3e 00			ld a,0 
ca91 77				ld (hl),a 
ca92 11 d0 e5			ld de,os_word_scratch 
ca95 3e 33				ld a, display_row_2 + 11 
ca97 cd 88 8a				call str_at_display 
ca9a			 
ca9a cd 98 8a			call update_display 
ca9d cd f2 89			call delay1s 
caa0 cd f2 89			call delay1s 
caa3 e1				pop hl 
caa4 f1				pop af 
caa5 c9				ret 
caa6			;endif 
caa6			 
caa6			include "forth_autostart.asm" 
caa6			; list of commands to perform at system start up 
caa6			 
caa6			startcmds: 
caa6			;	dw test11 
caa6			;	dw test12 
caa6			;	dw test13 
caa6			;	dw test14 
caa6			;	dw test15 
caa6			;	dw test16 
caa6			;	dw test17 
caa6			;	dw ifthtest1 
caa6			;	dw ifthtest2 
caa6			;	dw ifthtest3 
caa6			;	dw mmtest1 
caa6			;	dw mmtest2 
caa6			;	dw mmtest3 
caa6			;	dw mmtest4 
caa6			;	dw mmtest5 
caa6			;	dw mmtest6 
caa6			;	dw iftest1 
caa6			;	dw iftest2 
caa6			;	dw iftest3 
caa6			;	dw looptest1 
caa6			;	dw looptest2 
caa6			;	dw test1 
caa6			;	dw test2 
caa6			;	dw test3 
caa6			;	dw test4 
caa6			;	dw game2r 
caa6			;	dw game2b1 
caa6			;	dw game2b2 
caa6			 
caa6				; start up words that are actually useful 
caa6			 
caa6 1a cb		    dw spi1 
caa8 75 cb		    dw spi2 
caaa 03 cc		    dw spi3 
caac ab cb		    dw spi4 
caae d6 cb		    dw spi5 
cab0 69 cc		    dw spi6 
cab2 be cc		    dw spi7 
cab4			 
cab4 16 cd		    dw spi8 
cab6 35 cd		    dw spi9 
cab8 8d cd		    dw spi10 
caba			 
caba 00 ce			dw longread 
cabc 47 ce			dw clrstack 
cabe 7a ce			dw type 
cac0 6a d0			dw stest 
cac2 9e ce			dw strncpy 
cac4 00 d0			dw list 
cac6 ff ce			dw start1 
cac8 11 cf			dw start2 
caca			;	dw start3 
caca 24 cf			dw start3b 
cacc a0 cf			dw start3c 
cace			 
cace				; (unit) testing words 
cace			 
cace e1 d0			dw mtesta 
cad0 96 d1			dw mtestb 
cad2 39 d2			dw mtestc 
cad4 ee d2			dw mtestd 
cad6 92 d3			dw mteste 
cad8			 
cad8				; demo/game words 
cad8			 
cad8 9e da		        dw game3w 
cada cc da		        dw game3p 
cadc ea da		        dw game3sc 
cade 1b db		        dw game3vsi 
cae0 47 db		        dw game3vs 
cae2				 
cae2 91 d8			dw game2b 
cae4 ff d8			dw game2bf 
cae6 49 d9			dw game2mba 
cae8 df d9			dw game2mbas 
caea 21 da			dw game2mb 
caec			 
caec 52 d5			dw game1 
caee 63 d5			dw game1a 
caf0 c5 d5			dw game1b 
caf2 fa d5			dw game1c 
caf4 30 d6			dw game1d 
caf6 61 d6			dw game1s 
caf8 75 d6			dw game1t 
cafa 8a d6			dw game1f 
cafc be d6			dw game1z 
cafe 02 d7			dw game1zz 
cb00			 
cb00 48 d4			dw test5 
cb02 80 d4			dw test6 
cb04 b8 d4			dw test7 
cb06 cc d4			dw test8 
cb08 f8 d4			dw test9 
cb0a 0e d5			dw test10 
cb0c				 
cb0c d9 d7		        dw ssv5 
cb0e bd d7		        dw ssv4 
cb10 a1 d7		        dw ssv3 
cb12 6b d7		        dw ssv2 
cb14 f2 d7		        dw ssv1 
cb16 3a d8		        dw ssv1cpm 
cb18			;	dw keyup 
cb18			;	dw keydown 
cb18			;	dw keyleft 
cb18			;	dw keyright 
cb18			;	dw 	keyf1 
cb18			;	dw keyf2 
cb18			;	dw keyf3 
cb18			;	dw keyf4 
cb18			;	dw keyf5 
cb18			;	dw keyf6 
cb18			;	dw keyf7 
cb18			;	dw keyf8 
cb18			;	dw keyf9 
cb18			;	dw keyf10 
cb18			;	dw keyf11 
cb18			;	dw keyf12 
cb18			;	dw keytab 
cb18			;	dw keycr 
cb18			;	dw keyhome 
cb18			;	dw keyend 
cb18			;	dw keybs 
cb18 00 00			db 0, 0	 
cb1a			 
cb1a			; SPI Net support words 
cb1a			 
cb1a			; v0! = node to send to 
cb1a			; ( str count - ) 
cb1a .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cb75			 
cb75			; spiputchr ( char node - ) 
cb75 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
cbab			 
cbab			; spigetchr ( - n ) 
cbab .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
cbd6			 
cbd6			; getnode ( - n ) 
cbd6 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cc03			 
cc03			; ( str node - )  
cc03 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cc69			; store string ( str i - ) 
cc69			 
cc69			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cc69 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
ccbe			 
ccbe			; get string ( addr i -  )    TO FIX 
ccbe			 
ccbe .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cd16			 
cd16			 
cd16			; NETCHAT (TODO) 
cd16			; Program to allow two nodes to chat with eachother 
cd16			; 
cd16			; v0 - target node 
cd16			;  
cd16			; accept input at 0,0 
cd16			; if input is string send spitype to target node 
cd16			; starting at row 2,0 , while spigetchr is not zero ->  
cd16			; 
cd16			; 
cd16			; TODO add paging of get request 
cd16			 
cd16			; ( node - ) 
cd16 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
cd35 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
cd8d .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
ce00			 
ce00			 
ce00			; Long read of currently open file 
ce00 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
ce47			 
ce47			; clear stack  
ce47			 
ce47 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
ce7a			 
ce7a			; type ( addr count - ) 
ce7a .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
ce9e			 
ce9e			; some direct memory words 
ce9e			; strncpy ( len t f -- t ) 
ce9e			 
ce9e .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
ceff			 
ceff .. 00		start1:     	db ": bpon $0000 bp ;",0 
cf11 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
cf24 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
cfa0 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d000			 
d000			 
d000			; a handy word to list items on the stack 
d000			 
d000 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d06a			 
d06a			 
d06a			; test stack  
d06a			; rnd8 stest 
d06a			 
d06a .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d0e1			 
d0e1			; random malloc and free cycles 
d0e1			 
d0e1 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d196			 
d196			; fixed malloc and free cycles 
d196			 
d196 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d239			 
d239			; fixed double string push and drop cycle  
d239			 
d239 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d2ee			 
d2ee			; consistent fixed string push and drop cycle  
d2ee			 
d2ee .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d392			 
d392 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d448			 
d448			;test1:		db ": aa 1 2 3 ;", 0 
d448			;test2:     	db "111 aa 888 999",0 
d448			;test3:     	db ": bb 77 ;",0 
d448			;test4:     	db "$02 $01 do i . loop bb",0 
d448			 
d448 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d480 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d4b8 .. 00		test7:     	db ": box hline vline ;",0 
d4cc .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d4f8 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d50e .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d533 .. 00		test11:     	db "hello create .",0 
d542 .. 00		test12:     	db "hello2 create .",0 
d552			 
d552			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d552			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d552			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d552			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d552			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d552			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d552			 
d552			;iftest1:     	db "$0001 IF cls .",0 
d552			;iftest2:     	db "$0000 IF cls .",0 
d552			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d552			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d552			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d552			 
d552			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d552			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d552			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d552			 
d552			 
d552			 
d552			; a small guess the number game 
d552			 
d552 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d563 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d5c5			 
d5c5 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d5fa .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d630 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d661 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d675 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d68a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d6be .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d702			 
d702			; Using 'ga' save a high score across multiple runs using external storage 
d702			 
d702 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d76b			 
d76b			 
d76b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d76b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d76b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d76b			 
d76b			; simple screen saver to test code memory reuse to destruction 
d76b			 
d76b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d7a1 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d7bd .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d7d9 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d7f2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d83a .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d891			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d891			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d891			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d891			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d891			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d891			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d891			 
d891			 
d891			 
d891			; minesweeper/battleship finding game 
d891			; draws a game board of random ship/mine positions 
d891			; user enters coords to see if it hits on 
d891			; game ends when all are hit 
d891			; when hit or miss says how many may be in the area 
d891			 
d891			; setup the game board and then hide it 
d891 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d8ff .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d949			; prompt for where to target 
d949 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d9df .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
da04			; TODO see if the entered coords hits or misses pushes char hit of miss 
da04 .. 00		game2mbht:      db ": mbckht nop ;",0 
da13 .. 00		game2mbms:      db ": mbcms nop ;",0 
da21			; TODO how many might be near by 
da21 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
da9e			 
da9e			; Game 3 
da9e			 
da9e			; Vert scroller ski game - avoid the trees! 
da9e			 
da9e			; v0 score (ie turns) 
da9e			; v1 player pos 
da9e			; v2 left wall 
da9e			; v3 right wall 
da9e			 
da9e			; Draw side walls randomly 
da9e			 
da9e .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
dacc			 
dacc			; Draw player 
dacc .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
daea			 
daea			; TODO Get Key 
daea			 
daea			; TODO Move left right 
daea			 
daea			; scroll and move walls a bit 
daea			 
daea .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
db1b			 
db1b			; main game loop 
db1b			 
db1b .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
db47 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
db86			 
db86			; key board defs 
db86			 
db86 .. 00		keyup:       db ": keyup $05 ;",0 
db94 .. 00		keydown:       db ": keydown $0a ;",0 
dba4 .. 00		keyleft:       db ": keyleft $0b ;",0 
dbb4 .. 00		keyright:       db ": keyright $0c ;",0 
dbc5 .. 00		keyf1:       db ": keyf1 $10 ;",0 
dbd3 .. 00		keyf2:       db ": keyf2 $11 ;",0 
dbe1 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dbef .. 00		keyf4:       db ": keyf4 $13 ;",0 
dbfd .. 00		keyf5:       db ": keyf5 $14 ;",0 
dc0b .. 00		keyf6:       db ": keyf6 $15 ;",0 
dc19 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dc27 .. 00		keyf8:       db ": keyf8 $17 ;",0 
dc35 .. 00		keyf9:       db ": keyf9 $18 ;",0 
dc43 .. 00		keyf10:       db ": keyf10 $19 ;",0 
dc52 .. 00		keyf11:       db ": keyf11 $1a ;",0 
dc61 .. 00		keyf12:       db ": keyf12 $1b ;",0 
dc70			 
dc70 .. 00		keytab:       db ": keytab $09 ;",0 
dc7f .. 00		keycr:       db ": keycr $0d ;",0 
dc8d .. 00		keyhome:       db ": keyhome $0e ;",0 
dc9d .. 00		keyend:       db ": keyend $0f ;",0 
dcac .. 00		keybs:       db ": keybs $08 ;",0 
dcba			 
dcba			   
dcba			 
dcba			 
dcba			 
dcba			; eof 
# End of file forth_autostart.asm
dcba			 
dcba .. 00		sprompt1: db "Startup load...",0 
dcca .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
dce0			 
dce0			 
dce0			 
dce0			 
dce0			forth_startup: 
dce0 21 a6 ca			ld hl, startcmds 
dce3 3e 00			ld a, 0 
dce5 32 f1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
dce8			 
dce8 e5			.start1:	push hl 
dce9 cd 75 8a			call clear_display 
dcec 11 ba dc			ld de, sprompt1 
dcef 3e 00		        ld a, display_row_1 
dcf1 cd 88 8a			call str_at_display 
dcf4 11 ca dc			ld de, sprompt2 
dcf7 3e 28		        ld a, display_row_2 
dcf9 cd 88 8a			call str_at_display 
dcfc e1				pop hl 
dcfd e5				push hl 
dcfe 5e				ld e,(hl) 
dcff 23				inc hl 
dd00 56				ld d,(hl) 
dd01 3e 50		        ld a, display_row_3 
dd03 cd 88 8a			call str_at_display 
dd06 cd 98 8a			call update_display 
dd09			 
dd09			 
dd09 3a f1 e6			ld a, (os_last_cmd) 
dd0c fe 00			cp 0 
dd0e 28 05			jr z, .startprompt 
dd10 cd e6 89			call delay250ms 
dd13 18 24			jr .startdo 
dd15				 
dd15				 
dd15			 
dd15			.startprompt: 
dd15			 
dd15 3e 9f			ld a,display_row_4 + display_cols - 1 
dd17 11 8a 9a		        ld de, endprg 
dd1a cd 88 8a			call str_at_display 
dd1d cd 98 8a			call update_display 
dd20 cd f2 89			call delay1s 
dd23 cd 46 e0			call cin_wait 
dd26						 
dd26 fe 2a			cp '*' 
dd28 28 5e			jr z, .startupend1 
dd2a fe 23			cp '#' 
dd2c 20 07			jr nz, .startno 
dd2e 3e 01			ld a, 1 
dd30 32 f1 e6			ld (os_last_cmd),a 
dd33 18 04			jr .startdo 
dd35 fe 31		.startno:	cp '1' 
dd37 28 3a			jr z,.startnxt  
dd39			 
dd39				; exec startup line 
dd39			.startdo:	 
dd39 e1				pop hl 
dd3a e5				push hl 
dd3b				 
dd3b 5e				ld e,(hl) 
dd3c 23				inc hl 
dd3d 56				ld d,(hl) 
dd3e eb				ex de,hl 
dd3f			 
dd3f e5				push hl 
dd40			 
dd40 3e 00			ld a, 0 
dd42				;ld a, FORTH_END_BUFFER 
dd42 cd 0b 91			call strlent 
dd45 23				inc hl   ; include zero term to copy 
dd46 06 00			ld b,0 
dd48 4d				ld c,l 
dd49 e1				pop hl 
dd4a 11 cb e2			ld de, scratch 
dd4d ed b0			ldir 
dd4f			 
dd4f			 
dd4f 21 cb e2			ld hl, scratch 
dd52 cd 08 9f			call forthparse 
dd55 cd 48 9f			call forthexec 
dd58 cd 5a 9e			call forthexec_cleanup 
dd5b			 
dd5b 3e 78			ld a, display_row_4 
dd5d 11 2e 98			ld de, endprog 
dd60			 
dd60 cd 98 8a			call update_display		 
dd63			 
dd63 3a f1 e6			ld a, (os_last_cmd) 
dd66 fe 00			cp 0 
dd68 20 09			jr nz, .startnxt 
dd6a cd 8c 9a			call next_page_prompt 
dd6d cd 75 8a		        call clear_display 
dd70 cd 98 8a			call update_display		 
dd73			 
dd73				; move onto next startup line? 
dd73			.startnxt: 
dd73			 
dd73 cd e6 89			call delay250ms 
dd76 e1				pop hl 
dd77			 
dd77 23				inc hl 
dd78 23				inc hl 
dd79			 
dd79 e5				push hl 
dd7a 5e				ld e, (hl) 
dd7b 23				inc hl 
dd7c 56				ld d, (hl) 
dd7d e1				pop hl 
dd7e				; TODO replace 0 test 
dd7e			 
dd7e eb				ex de, hl 
dd7f cd cb 8c			call ishlzero 
dd82			;	ld a,e 
dd82			;	add d 
dd82			;	cp 0    ; any left to do? 
dd82 eb				ex de, hl 
dd83 c2 e8 dc			jp nz, .start1 
dd86 18 01			jr .startupend 
dd88			 
dd88 e1			.startupend1: pop hl 
dd89			.startupend: 
dd89			 
dd89 cd 75 8a			call clear_display 
dd8c cd 98 8a			call update_display 
dd8f c9				ret 
dd90			 
dd90			 
dd90			; stack over and underflow checks 
dd90			 
dd90			; init the words to detect the under/overflow 
dd90			 
dd90			chk_stk_init: 
dd90				; a vague random number to check so we dont get any "lucky" hits 
dd90 3e 2d			ld a, 45 
dd92 6f				ld l, a 
dd93 00				nop 
dd94 3e 17			ld a, 23 
dd96 67				ld h, a 
dd97			 
dd97 22 b2 e2			ld (chk_word), hl     ; the word we need to check against 
dd9a			 
dd9a			;	ld (chk_stund), hl	; stack points.... 
dd9a 22 00 ef			ld (chk_stovr), hl 
dd9d 22 f6 e9			ld (chk_ret_und), hl 
dda0 22 b4 e9			ld (chk_ret_ovr), hl 
dda3 22 32 e9			ld (chk_loop_ovr), hl 
dda6 22 30 e8			ld (chk_data_ovr), hl 
dda9 c9				ret 
ddaa				 
ddaa			check_stacks: 
ddaa				; check all stack words 
ddaa			 
ddaa e5				push hl 
ddab d5				push de 
ddac			 
ddac			;	ld de,(chk_word) 
ddac			;	ld hl, (chk_stund)	; stack points.... 
ddac			;	if DEBUG_STK_FAULT 
ddac			;		DMARK "FAa" 
ddac			;		CALLMONITOR 
ddac			;	endif 
ddac			;	call cmp16 
ddac			;	jp z, .chk_faulta 
ddac			; 
ddac			;	ld de, sfaultsu 
ddac			;	jp .chk_fault 
ddac			 
ddac 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
ddaf ed 5b b2 e2		ld de,(chk_word) 
ddb3				if DEBUG_STK_FAULT 
ddb3					DMARK "FAb" 
ddb3					CALLMONITOR 
ddb3				endif 
ddb3 cd c0 8c			call cmp16 
ddb6 28 06			jr z, .chk_fault1 
ddb8 11 59 de			ld de, sfaultso 
ddbb c3 0d de			jp .chk_fault 
ddbe			.chk_fault1:  
ddbe 2a f6 e9			ld hl, (chk_ret_und) 
ddc1 ed 5b b2 e2		ld de,(chk_word) 
ddc5				if DEBUG_STK_FAULT 
ddc5					DMARK "FAU" 
ddc5					CALLMONITOR 
ddc5				endif 
ddc5 cd c0 8c			call cmp16 
ddc8 ca d1 dd			jp z, .chk_fault2 
ddcb 11 69 de			ld de, sfaultru 
ddce c3 0d de			jp .chk_fault 
ddd1			.chk_fault2:  
ddd1 2a b4 e9			ld hl, (chk_ret_ovr) 
ddd4 ed 5b b2 e2		ld de,(chk_word) 
ddd8				if DEBUG_STK_FAULT 
ddd8					DMARK "FA1" 
ddd8					CALLMONITOR 
ddd8				endif 
ddd8 cd c0 8c			call cmp16 
dddb ca e4 dd			jp z, .chk_fault3 
ddde 11 77 de			ld de, sfaultro 
dde1 c3 0d de			jp .chk_fault 
dde4			.chk_fault3:  
dde4 2a 32 e9			ld hl, (chk_loop_ovr) 
dde7 ed 5b b2 e2		ld de,(chk_word) 
ddeb				if DEBUG_STK_FAULT 
ddeb					DMARK "FA2" 
ddeb					CALLMONITOR 
ddeb				endif 
ddeb cd c0 8c			call cmp16 
ddee ca f7 dd			jp z, .chk_fault4 
ddf1 11 91 de			ld de, sfaultlo 
ddf4 c3 0d de			jp .chk_fault 
ddf7			.chk_fault4:  
ddf7 2a 30 e8			ld hl, (chk_data_ovr) 
ddfa ed 5b b2 e2		ld de,(chk_word) 
ddfe				if DEBUG_STK_FAULT 
ddfe					DMARK "FA3" 
ddfe					CALLMONITOR 
ddfe				endif 
ddfe cd c0 8c			call cmp16 
de01 ca 0a de			jp z, .chk_fault5 
de04 11 ab de			ld de, sfaultdo 
de07 c3 0d de			jp .chk_fault 
de0a			 
de0a			 
de0a			.chk_fault5:  
de0a d1				pop de 
de0b e1				pop hl 
de0c			 
de0c c9				ret 
de0d			 
de0d cd 75 8a		.chk_fault: 	call clear_display 
de10 3e 28				ld a, display_row_2 
de12 cd 88 8a				call str_at_display 
de15 11 3b de				   ld de, .stackfault 
de18 3e 00				ld a, display_row_1 
de1a cd 88 8a				call str_at_display 
de1d 11 71 ee				    ld de, debug_mark 
de20 3e 11				ld a, display_row_1+17 
de22 cd 88 8a				call str_at_display 
de25 cd 98 8a				call update_display 
de28			 
de28				; prompt before entering montior for investigating issue 
de28			 
de28 3e 78			ld a, display_row_4 
de2a 11 2e 98			ld de, endprog 
de2d			 
de2d cd 98 8a			call update_display		 
de30			 
de30 cd 8c 9a			call next_page_prompt 
de33			 
de33 d1				pop de 
de34 e1				pop hl 
de35 cd 82 98				call monitor 
de38 c3 7c 97				jp warmstart 
de3b					;jp 0 
de3b					;halt 
de3b			 
de3b			 
de3b			 
de3b .. 00		.stackfault: 	db "Stack fault:",0 
de48			 
de48 .. 00		sfaultsu: 	db	"Stack under flow",0 
de59 .. 00		sfaultso: 	db	"Stack over flow",0 
de69 .. 00		sfaultru:	db "RTS underflow",0 
de77 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
de91 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
deab .. 00		sfaultdo:	db "DTS overflow", 0 
deb8			 
deb8			 
deb8			fault_dsp_under: 
deb8 11 ca de			ld de, .dsp_under 
debb c3 7a df			jp .show_fault 
debe			 
debe			fault_rsp_under: 
debe 11 d8 de			ld de, .rsp_under 
dec1 c3 7a df			jp .show_fault 
dec4			fault_loop_under: 
dec4 11 e6 de			ld de, .loop_under 
dec7 c3 7a df			jp .show_fault 
deca			 
deca .. 00		.dsp_under: db "DSP Underflow",0 
ded8 .. 00		.rsp_under: db "RSP Underflow",0 
dee6 .. 00		.loop_under: db "LOOP Underflow",0 
def5			 
def5			 
def5 d5			type_faultn: 	push de 
def6 e5					push hl 
def7 cd 75 8a				call clear_display 
defa 11 21 df				   ld de, .typefaultn 
defd 3e 00				ld a, display_row_1 
deff cd 88 8a				call str_at_display 
df02 11 71 ee				    ld de, debug_mark 
df05 3e 11				ld a, display_row_1+17 
df07 cd 88 8a				call str_at_display 
df0a cd 98 8a				call update_display 
df0d			 
df0d				; prompt before entering montior for investigating issue 
df0d			 
df0d 3e 78			ld a, display_row_4 
df0f 11 2e 98			ld de, endprog 
df12			 
df12 cd 98 8a			call update_display		 
df15			 
df15 cd 8c 9a			call next_page_prompt 
df18			 
df18 e5					push hl 
df19 d5					push de 
df1a cd 82 98				call monitor 
df1d c3 7c 97				jp warmstart 
df20 76					halt 
df21			 
df21			 
df21 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
df38			 
df38 d5			type_faults: 	push de 
df39 e5					push hl 
df3a cd 75 8a				call clear_display 
df3d 11 63 df				   ld de, .typefaults 
df40 3e 00				ld a, display_row_1 
df42 cd 88 8a				call str_at_display 
df45 11 71 ee				    ld de, debug_mark 
df48 3e 11				ld a, display_row_1+17 
df4a cd 88 8a				call str_at_display 
df4d cd 98 8a				call update_display 
df50			 
df50				; prompt before entering montior for investigating issue 
df50			 
df50 3e 78			ld a, display_row_4 
df52 11 2e 98			ld de, endprog 
df55			 
df55 cd 98 8a			call update_display		 
df58			 
df58 cd 8c 9a			call next_page_prompt 
df5b			 
df5b e1					pop hl 
df5c d1					pop de 
df5d cd 82 98				call monitor 
df60 c3 7c 97				jp warmstart 
df63			 
df63			 
df63 .. 00		.typefaults: db "STR Type Expected TOS!",0 
df7a			 
df7a			.show_fault: 	 
df7a d5					push de 
df7b cd 75 8a				call clear_display 
df7e d1					pop de 
df7f 3e 00				ld a, display_row_1 
df81 cd 88 8a				call str_at_display 
df84 11 71 ee				    ld de, debug_mark 
df87 3e 11				ld a, display_row_1+17 
df89 cd 88 8a				call str_at_display 
df8c cd 98 8a				call update_display 
df8f			 
df8f				; prompt before entering montior for investigating issue 
df8f			 
df8f 3e 78			ld a, display_row_4 
df91 11 2e 98			ld de, endprog 
df94			 
df94 cd 98 8a			call update_display		 
df97			 
df97 cd 8c 9a			call next_page_prompt 
df9a			 
df9a e1					pop hl 
df9b d1					pop de 
df9c cd 82 98				call monitor 
df9f			; do a dump to cli and not warmstart so we preserve all of the uwords.  
df9f			; TODO Make optional fault restart to cli or warm boot? 
df9f					;jp warmstart 
df9f c3 d4 97				jp cli 
dfa2 76					halt 
dfa3			 
dfa3			; handle the auto run of code from files in storage 
dfa3			 
dfa3			 
dfa3			if STORAGE_SE 
dfa3			 
dfa3			sprompt3: db "Loading from start-up file?:",0 
dfa3			sprompt4: db "(Y=Any key/N=No)",0 
dfa3			 
dfa3			 
dfa3			forth_autoload: 
dfa3			 
dfa3				; load block 0 of store 1 
dfa3				 
dfa3				ld a, $fe      ; bit 0 clear 
dfa3				ld (spi_device), a 
dfa3			 
dfa3				call storage_get_block_0 
dfa3			 
dfa3				ld a, (store_page+STORE_0_AUTOFILE) 
dfa3			 
dfa3				cp 0 
dfa3				ret z     ; auto start not enabled 
dfa3			 
dfa3				call clear_display 
dfa3			 
dfa3				; set bank 
dfa3			 
dfa3					ld a, (store_page+STORE_0_BANKRUN) 
dfa3					ld (spi_device), a 
dfa3			 
dfa3				; get file id to load from and get the file name to display 
dfa3			 
dfa3					ld a, (store_page+STORE_0_FILERUN) 
dfa3			 
dfa3					ld l, 0 
dfa3					ld h, a 
dfa3					ld de, store_page 
dfa3			 
dfa3					if DEBUG_FORTH_WORDS 
dfa3						DMARK "ASp" 
dfa3						CALLMONITOR 
dfa3					endif 
dfa3					call storage_read 
dfa3			 
dfa3					if DEBUG_FORTH_WORDS 
dfa3						DMARK "ASr" 
dfa3						CALLMONITOR 
dfa3					endif 
dfa3			 
dfa3					call ishlzero 
dfa3					ret z             ; file not found 
dfa3			 
dfa3					ld a, display_row_2 + 10 
dfa3					ld de, store_page+3 
dfa3					call str_at_display 
dfa3				 
dfa3			; 
dfa3			 
dfa3				ld a, display_row_1+5 
dfa3				ld de, sprompt3 
dfa3				call str_at_display 
dfa3				ld a, display_row_3+15 
dfa3				ld de, sprompt4 
dfa3				call str_at_display 
dfa3			 
dfa3				call update_display 
dfa3			 
dfa3				call cin_wait 
dfa3				cp 'n' 
dfa3				ret z 
dfa3				cp 'N' 
dfa3				ret z 
dfa3			 
dfa3				call delay1s 
dfa3			 
dfa3				ld a, (store_page+2) 
dfa3				ld (store_openmaxext), a    ; save count of ext 
dfa3				ld a, 1  
dfa3				ld (store_openext), a    ; save count of ext 
dfa3			 
dfa3			.autof:  
dfa3				ld l , a 
dfa3				 
dfa3				ld a, (store_page) 
dfa3				ld h, a	 
dfa3				ld de, store_page 
dfa3					if DEBUG_FORTH_WORDS 
dfa3						DMARK "ASl" 
dfa3						CALLMONITOR 
dfa3					endif 
dfa3					call storage_read 
dfa3				call ishlzero 
dfa3				ret z 
dfa3			;	jr z, .autoend 
dfa3			 
dfa3					if DEBUG_FORTH_WORDS 
dfa3						DMARK "ASc" 
dfa3						CALLMONITOR 
dfa3					endif 
dfa3				ld de, store_page+2 
dfa3				ld a, display_row_4 
dfa3				call str_at_display 
dfa3			 
dfa3				call update_display 
dfa3				call delay250ms 
dfa3			 
dfa3			 
dfa3			 
dfa3				ld hl, store_page+2 
dfa3				call forthparse 
dfa3				call forthexec 
dfa3				call forthexec_cleanup 
dfa3			 
dfa3				 
dfa3				ld a, (store_openext) 
dfa3				inc a 
dfa3				ld (store_openext), a    ; save count of ext 
dfa3			 
dfa3				jr .autof 
dfa3			;.autofdone: 
dfa3			; 
dfa3			;		if DEBUG_FORTH_WORDS 
dfa3			;			DMARK "ASx" 
dfa3			;			CALLMONITOR 
dfa3			;		endif 
dfa3			;;	call clear_display 
dfa3			;	ret 
dfa3			 
dfa3			 
dfa3			 
dfa3			endif 
dfa3			 
dfa3			 
dfa3			; eof 
# End of file forth_kernel.asm
dfa3			;include "nascombasic.asm" 
dfa3			 
dfa3			 
dfa3			; find out where the code ends if loaded into RAM (for SC114) 
dfa3			;endofcode:  
dfa3			;	nop 
dfa3			 
dfa3			 
dfa3			; eof 
dfa3			 
# End of file main.asm
dfa3			;include "firmware_lcd_4x40.asm" 
dfa3			;;include "firmware_lcd_4x20.asm" 
dfa3			include "firmware_serial_display.asm" 
dfa3			 
dfa3			; Serial display interface for SC114 
dfa3			 
dfa3			 
dfa3			display_row_1: equ 0 
dfa3			display_row_2: equ display_row_1+display_cols 
dfa3			display_row_3: equ display_row_2 + display_cols 
dfa3			display_row_4: equ display_row_3 + display_cols 
dfa3			 
dfa3			kLCDWidth:  EQU display_cols             ;Width in characters 
dfa3			kLCD_Line1: EQU 0x00  
dfa3			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
dfa3			; E1 
dfa3			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
dfa3			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
dfa3			 
dfa3			lcd_init: 
dfa3				; no init as handled by the SCM bios 
dfa3 c9				ret 
dfa4			 
dfa4			 
dfa4			; low level functions for direct screen writes 
dfa4			 
dfa4			; output char at pos? 
dfa4			fLCD_Str: 
dfa4			        ;out (SC114_SIO_1_OUT),a 
dfa4 c5				push bc 
dfa5 0e 02			ld c, $02 
dfa7 f7				rst $30 
dfa8 c1				pop bc 
dfa9 c9				ret 
dfaa			 
dfaa			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
dfaa			fLCD_Pos: 
dfaa				; use ASCII escape to position 
dfaa			        ;out (SC114_SIO_1_OUT),a 
dfaa c5				push bc 
dfab 0e 02			ld c, $02 
dfad f7				rst $30 
dfae c1				pop bc 
dfaf			 
dfaf c9				ret 
dfb0			 
dfb0			; output char at pos 
dfb0			fLCD_Data: 
dfb0			      ;  out (SC114_SIO_1_OUT),a 
dfb0 c5				push bc 
dfb1 0e 02			ld c, $02 
dfb3 f7				rst $30 
dfb4 c1				pop bc 
dfb5			 
dfb5 c9				ret 
dfb6			 
dfb6			; ascii cls  
dfb6			 
dfb6 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
dfba			 
dfba			; write the frame buffer given in hl to hardware  
dfba			write_display: 
dfba			 
dfba			API: equ 0 
dfba			 
dfba			if API 
dfba				push bc 
dfba				ld b, 4 
dfba			 
dfba			        ld (display_write_tmp), hl 	  
dfba			 
dfba				; clear and home cursor 
dfba			 
dfba				ld c, 6 
dfba				ld de, .cls 
dfba				rst $30 
dfba			 
dfba			 
dfba			.writeln: 
dfba			 
dfba				ld de, (display_write_tmp) 
dfba				ld c, 6 
dfba				rst $30 
dfba				ld c, 7 
dfba				rst $30 
dfba			 
dfba				ld hl, (display_write_tmp) 
dfba				ld de, display_cols 
dfba				add hl,de 
dfba				ld (display_write_tmp),hl 
dfba			 
dfba				djnz  .writeln 
dfba			 
dfba				pop bc 
dfba			 
dfba			 
dfba				ret 
dfba			endif 
dfba e5				push hl 
dfbb c5				push bc 
dfbc d5				push de 
dfbd			 
dfbd			;	ld c, 2 
dfbd			;	;ld de, .cls 
dfbd			;	ld a, 27 
dfbd			;	rst $30 
dfbd			;	ld c, 2 
dfbd			;	;ld de, .cls 
dfbd			;	ld a, '[' 
dfbd			;	rst $30 
dfbd			; 
dfbd			;	ld c, 2 
dfbd			;	;ld de, .cls 
dfbd			;	ld a, 'H' 
dfbd			;	rst $30 
dfbd			; 
dfbd			 
dfbd 0e 02			ld c, 2 
dfbf				;ld de, .cls 
dfbf 3e 1b			ld a, 27 
dfc1 f7				rst $30 
dfc2			 
dfc2			 
dfc2 0e 02			ld c, 2 
dfc4				;ld de, .cls 
dfc4 3e 5b			ld a, '[' 
dfc6 f7				rst $30 
dfc7 0e 02			ld c, 2 
dfc9				;ld de, .cls 
dfc9 3e 32			ld a, '2' 
dfcb f7				rst $30 
dfcc 0e 02			ld c, 2 
dfce				;ld de, .cls 
dfce 3e 4a			ld a, 'J' 
dfd0 f7				rst $30 
dfd1 d1				pop de 
dfd2 c1				pop bc 
dfd3 e1				pop hl 
dfd4			 
dfd4			 
dfd4 22 cf eb		        ld (display_write_tmp), hl 	  
dfd7 3e 00			ld a, kLCD_Line1 
dfd9			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dfd9 06 28			ld b, display_cols 
dfdb ed 5b cf eb		ld de, (display_write_tmp) 
dfdf cd 3d e0			call write_len_string 
dfe2				 
dfe2			 
dfe2 e5			push hl 
dfe3 d5			push de 
dfe4 c5			push bc 
dfe5 0e 07			ld c, 7 
dfe7 f7				rst $30 
dfe8 c1			pop bc 
dfe9 d1			pop de 
dfea e1			pop hl 
dfeb			 
dfeb				 
dfeb 2a cf eb			ld hl, (display_write_tmp) 
dfee 11 28 00			ld de, display_cols 
dff1 19				add hl,de 
dff2 22 cf eb			ld (display_write_tmp),hl 
dff5			 
dff5				 
dff5 3e 28			ld a, kLCD_Line2 
dff7			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dff7 06 28			ld b, display_cols 
dff9 ed 5b cf eb		ld de, (display_write_tmp) 
dffd cd 3d e0			call write_len_string 
e000				 
e000 2a cf eb			ld hl, (display_write_tmp) 
e003 11 28 00			ld de, display_cols 
e006 19				add hl,de 
e007 22 cf eb			ld (display_write_tmp),hl 
e00a			 
e00a e5			push hl 
e00b d5			push de 
e00c c5			push bc 
e00d 0e 07			ld c, 7 
e00f f7				rst $30 
e010 c1			pop bc 
e011 d1			pop de 
e012 e1			pop hl 
e013			 
e013				 
e013 3e 50			ld a, kLCD_Line3 
e015			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e015 06 28			ld b, display_cols 
e017 ed 5b cf eb		ld de, (display_write_tmp) 
e01b cd 3d e0			call write_len_string 
e01e				 
e01e 2a cf eb			ld hl, (display_write_tmp) 
e021 11 28 00			ld de, display_cols 
e024 19				add hl,de 
e025 22 cf eb			ld (display_write_tmp),hl 
e028			 
e028 e5			push hl 
e029 d5			push de 
e02a c5			push bc 
e02b 0e 07			ld c, 7 
e02d f7				rst $30 
e02e c1			pop bc 
e02f d1			pop de 
e030 e1			pop hl 
e031			 
e031				 
e031 3e 78			ld a, kLCD_Line4 
e033			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e033 06 28			ld b, display_cols 
e035 ed 5b cf eb		ld de, (display_write_tmp) 
e039 cd 3d e0			call write_len_string 
e03c c9					ret 
e03d			 
e03d			 
e03d				; write out a fixed length string given in b from de 
e03d			 
e03d 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e03e cd b0 df		            CALL fLCD_Data      ;Write character to display 
e041 13				inc de 
e042 10 f9			djnz write_len_string 
e044 c9				ret 
e045			 
e045			 
e045			; eof 
# End of file firmware_serial_display.asm
e045			;include "firmware_key_5x10.asm" 
e045			;;include "firmware_key_4x10.asm" 
e045			include "firmware_key_serial.asm" 
e045			; Serial keyboard interface for SC114 
e045			 
e045			key_init: 
e045				; no init as handled by the SCM bios 
e045 c9				ret 
e046			 
e046			 
e046			cin_wait: 
e046			;	ld a, 0 
e046			;	ret 
e046			 
e046				;in a,(SC114_SIO_1_IN) 
e046			        ; Use SCM API to get from whatever console device we are using 
e046 c5				push bc 
e047 0e 01			ld c, $01 
e049 f7				rst $30 
e04a c1				pop bc 
e04b c9				ret 
e04c			 
e04c			cin: 
e04c			 
e04c			 
e04c c5				push bc 
e04d			 
e04d				; any key waiting to process? 
e04d 0e 03			ld c, $03 
e04f f7				rst $30 
e050 28 05			jr z, .cin_skip 
e052			 
e052				; yep, get it 
e052			 
e052 0e 01			ld c, $01 
e054 f7				rst $30 
e055 c1				pop bc 
e056 c9				ret 
e057			.cin_skip: 
e057 3e 00			ld a, 0 
e059 c1				pop bc 
e05a c9				ret 
e05b			 
e05b			 
e05b			 
e05b			 
# End of file firmware_key_serial.asm
e05b			endofcode:  
e05b			baseram:  
e05b 00				nop 
e05c			 
e05c			heap_start: equ baseram+15  ; Starting address of heap 
e05c			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e05c			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e05c			;VDU:  EQU     endofcode           ; BASIC Work space 
e05c			; eof 
e05c			 
# End of file os_mega_sc114.asm
e05c
