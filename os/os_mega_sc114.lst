# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 71 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-09-04 17:03' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			  
801f			debug_umark: equ debug_vector - 6  ; current user mark  
801f			debug_mark: equ debug_umark - 4    ; internal word debug points  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 0a ed				ld hl, display_fb1  
8022 22 c6 eb				ld (display_fb_active), hl  
8025			  
8025 cd bd 8a				call clear_display  
8028			  
8028 21 c8 eb				ld hl, display_fb2  
802b 22 c6 eb				ld (display_fb_active), hl  
802e			  
802e cd bd 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 ab ed				ld hl, display_fb0  
8034 22 c6 eb				ld (display_fb_active), hl  
8037			  
8037 cd bd 8a				call clear_display  
803a			  
803a			  
803a cd df de				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd 81 df			call key_init  
8040 cd ad 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd a1 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd e0 8a			call update_display  
8049 cd 00 8a			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd c2 8a			call fill_display  
8051 cd e0 8a			call update_display  
8054 cd 00 8a			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd c2 8a			call fill_display  
805c cd e0 8a			call update_display  
805f cd 00 8a			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd c2 8a			call fill_display  
8067 cd e0 8a			call update_display  
806a cd 00 8a			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 cf 95			ld de, prom_bootmsg  
8072 cd d0 8a			call str_at_display  
8075 cd e0 8a			call update_display  
8078			  
8078			  
8078 cd 00 8a			call delay1s  
807b cd 00 8a			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 e4 95			ld de, prom_bootmsg1  
8083 cd d0 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd d0 8a			call str_at_display  
808e			  
808e cd e0 8a			call update_display  
8091 cd 00 8a			call delay1s  
8094 cd 00 8a			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 65 ee		ld (debug_mark),a  
809c 32 66 ee		ld (debug_mark+1),a  
809f 32 67 ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 68 ee		ld (debug_mark+3),a  
80a7 32 69 ee		ld (debug_umark),a  
80aa			  
80aa c9					ret  
80ab			  
80ab			  
80ab			;bootmsg2:	db "Firmware v0.1",0  
80ab			  
80ab			; a 4x20 lcd  
80ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ab			  
80ab			;if display_cols == 20  
80ab			;	include "firmware_lcd_4x20.asm"  
80ab			;endif  
80ab			  
80ab			;if display_cols == 40  
80ab			;	include "firmware_lcd_4x40.asm"  
80ab			;endif  
80ab			  
80ab			;  
80ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ab			; TODO abstract the bit bang video out interface for dual display  
80ab			; TODO wire video out to tx pin on rc2014 bus  
80ab			  
80ab			; must supply cin, and cin_wait for low level hardware abstraction   
80ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ab			; test scancode  
80ab			  
80ab			;;;;;  
80ab			;;;  
80ab			; Moved out to mini and maxi versions  
80ab			;  
80ab			; include "firmware_key_4x4.asm"  
80ab			; using existing 4 wire x 4 resistor array for input  
80ab			;include "firmware_key_4x10.asm"  
80ab			; need to mod the board for 5 rows due to resistor array  
80ab			;include "firmware_key_5x10.asm"  
80ab			  
80ab			; storage hardware interface  
80ab			  
80ab			; use microchip serial eeprom for storage  
80ab			  
80ab			  
80ab			if STORAGE_SE  
80ab				include "firmware_spi.asm"  
80ab				include "firmware_seeprom.asm"  
80ab			else  
80ab			   ; create some stubs for the labels  
80ab c9			se_readbyte: ret  
80ac c9			se_writebyte: ret  
80ad c9			storage_init: ret  
80ae			  
80ae			endif  
80ae			  
80ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ae			;include "firmware_cf.asm"  
80ae			  
80ae			; load up high level storage hardward abstractions  
80ae			include "firmware_storage.asm"  
80ae			 
80ae			; persisent storage hardware abstraction layer  
80ae			 
80ae			 
80ae			 
80ae			; Block 0 on storage is a config state 
80ae			 
80ae			 
80ae			 
80ae			; TODO add read phy block and write phy block functions 
80ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ae			 
80ae			; Abstraction layer  
80ae			 
80ae			; Logocial block size is same size as physical size - using tape concept 
80ae			 
80ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ae			 
80ae			 
80ae			 
80ae			; Filesystem layout (Logical layout) 
80ae			; 
80ae			; Block 0 - Bank config  
80ae			; 
80ae			;      Byte - 0 file id counter 
80ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ae			;      Byte - 3-20 zero terminated bank label 
80ae			; 
80ae			; Block 1 > File storage 
80ae			; 
80ae			;      Byte 0 file id    - block 0 file details 
80ae			;      Byte 1 block id - block 0 is file  
80ae			;            Byte 2-15 - File name 
80ae			; 
80ae			;       - to end of block data 
80ae			; 
80ae			 
80ae			; Get ID for the file named in pointer held HL 
80ae			; Returns ID in HL = 255 if no file found 
80ae			 
80ae			storage_getid: 
80ae			 
80ae 22 6d ea			ld (store_tmp1), hl 
80b1			 
80b1				if DEBUG_STORESE 
80b1					DMARK "SGI" 
80b1 f5				push af  
80b2 3a c6 80			ld a, (.dmark)  
80b5 32 65 ee			ld (debug_mark),a  
80b8 3a c7 80			ld a, (.dmark+1)  
80bb 32 66 ee			ld (debug_mark+1),a  
80be 3a c8 80			ld a, (.dmark+2)  
80c1 32 67 ee			ld (debug_mark+2),a  
80c4 18 03			jr .pastdmark  
80c6 ..			.dmark: db "SGI"  
80c9 f1			.pastdmark: pop af  
80ca			endm  
# End of macro DMARK
80ca					CALLMONITOR 
80ca cd 6f ee			call debug_vector  
80cd				endm  
# End of macro CALLMONITOR
80cd				endif 
80cd				; get block 0 and set counter for number of files to scan 
80cd			 
80cd cd 38 82			call storage_get_block_0 
80d0			 
80d0 3a 74 ea			ld a, (store_page) 
80d3 47				ld b, a 
80d4			 
80d4				; get extent 0 of each file id 
80d4			 
80d4				if DEBUG_STORESE 
80d4					DMARK "SGc" 
80d4 f5				push af  
80d5 3a e9 80			ld a, (.dmark)  
80d8 32 65 ee			ld (debug_mark),a  
80db 3a ea 80			ld a, (.dmark+1)  
80de 32 66 ee			ld (debug_mark+1),a  
80e1 3a eb 80			ld a, (.dmark+2)  
80e4 32 67 ee			ld (debug_mark+2),a  
80e7 18 03			jr .pastdmark  
80e9 ..			.dmark: db "SGc"  
80ec f1			.pastdmark: pop af  
80ed			endm  
# End of macro DMARK
80ed					CALLMONITOR 
80ed cd 6f ee			call debug_vector  
80f0				endm  
# End of macro CALLMONITOR
80f0				endif 
80f0 60			.getloop:	ld h, b 
80f1 2e 00				ld l, 0 
80f3 c5					push bc 
80f4			 
80f4 11 74 ea				ld de, store_page 
80f7				if DEBUG_STORESE 
80f7					DMARK "SGr" 
80f7 f5				push af  
80f8 3a 0c 81			ld a, (.dmark)  
80fb 32 65 ee			ld (debug_mark),a  
80fe 3a 0d 81			ld a, (.dmark+1)  
8101 32 66 ee			ld (debug_mark+1),a  
8104 3a 0e 81			ld a, (.dmark+2)  
8107 32 67 ee			ld (debug_mark+2),a  
810a 18 03			jr .pastdmark  
810c ..			.dmark: db "SGr"  
810f f1			.pastdmark: pop af  
8110			endm  
# End of macro DMARK
8110					CALLMONITOR 
8110 cd 6f ee			call debug_vector  
8113				endm  
# End of macro CALLMONITOR
8113				endif 
8113 cd e0 86				call storage_read 
8116 cd 13 8d				call ishlzero 
8119 28 2d				jr z, .gap 
811b					 
811b					; have a file name read. Is it one we want. 
811b			 
811b 2a 6d ea				ld hl, (store_tmp1) 
811e 11 77 ea				ld de, store_page+3   ; file name 
8121			 
8121				if DEBUG_STORESE 
8121					DMARK "SGc" 
8121 f5				push af  
8122 3a 36 81			ld a, (.dmark)  
8125 32 65 ee			ld (debug_mark),a  
8128 3a 37 81			ld a, (.dmark+1)  
812b 32 66 ee			ld (debug_mark+1),a  
812e 3a 38 81			ld a, (.dmark+2)  
8131 32 67 ee			ld (debug_mark+2),a  
8134 18 03			jr .pastdmark  
8136 ..			.dmark: db "SGc"  
8139 f1			.pastdmark: pop af  
813a			endm  
# End of macro DMARK
813a					CALLMONITOR 
813a cd 6f ee			call debug_vector  
813d				endm  
# End of macro CALLMONITOR
813d				endif 
813d cd 88 90				call strcmp 
8140 20 06				jr nz, .gap   ; not this one 
8142			 
8142 c1				        pop bc 
8143			 
8143 26 00				ld h, 0 
8145 68					ld l, b 
8146 18 22				jr .getdone 
8148						 
8148			 
8148			 
8148			 
8148			.gap: 
8148				if DEBUG_STORESE 
8148					DMARK "SGg" 
8148 f5				push af  
8149 3a 5d 81			ld a, (.dmark)  
814c 32 65 ee			ld (debug_mark),a  
814f 3a 5e 81			ld a, (.dmark+1)  
8152 32 66 ee			ld (debug_mark+1),a  
8155 3a 5f 81			ld a, (.dmark+2)  
8158 32 67 ee			ld (debug_mark+2),a  
815b 18 03			jr .pastdmark  
815d ..			.dmark: db "SGg"  
8160 f1			.pastdmark: pop af  
8161			endm  
# End of macro DMARK
8161					CALLMONITOR 
8161 cd 6f ee			call debug_vector  
8164				endm  
# End of macro CALLMONITOR
8164				endif 
8164			 
8164 c1					pop bc 
8165 10 89				djnz .getloop 
8167 21 ff 00				ld hl, 255 
816a			.getdone: 
816a			 
816a				if DEBUG_STORESE 
816a					DMARK "SGe" 
816a f5				push af  
816b 3a 7f 81			ld a, (.dmark)  
816e 32 65 ee			ld (debug_mark),a  
8171 3a 80 81			ld a, (.dmark+1)  
8174 32 66 ee			ld (debug_mark+1),a  
8177 3a 81 81			ld a, (.dmark+2)  
817a 32 67 ee			ld (debug_mark+2),a  
817d 18 03			jr .pastdmark  
817f ..			.dmark: db "SGe"  
8182 f1			.pastdmark: pop af  
8183			endm  
# End of macro DMARK
8183					CALLMONITOR 
8183 cd 6f ee			call debug_vector  
8186				endm  
# End of macro CALLMONITOR
8186				endif 
8186			 
8186 c9				ret 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			; Read Block 
8187			; ---------- 
8187			; 
8187			; With current bank 
8187			;  
8187			; Get block number to read 
8187			; Load physical blocks starting at start block into buffer 
8187			 
8187			; de points to buffer to use 
8187			; hl holds logical block number  
8187			 
8187			storage_read_block: 
8187			 
8187				; TODO bank selection 
8187			 
8187				; for each of the physical blocks read it into the buffer 
8187 06 40			ld b, STORE_BLOCK_PHY 
8189			 
8189				if DEBUG_STORESE 
8189 d5					push de 
818a				endif 
818a				 
818a			.rl1:    
818a			 
818a				; read physical block at hl into de 
818a			        ; increment hl and de to next read position on exit 
818a			 
818a e5				push hl 
818b d5				push de	 
818c c5				push bc 
818d			;	if DEBUG_STORESE 
818d			;		push af 
818d			;		ld a, 'R' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d cd ab 80			call se_readbyte 
8190			;	if DEBUG_STORESE 
8190			;		ld a,(spi_portbyte) 
8190			;		ld l, a 
8190			;		push af 
8190			;		ld a, '1' 
8190			;		ld (debug_mark),a 
8190			;		pop af 
8190			;		CALLMONITOR 
8190			;	endif 
8190 c1				pop bc 
8191 d1				pop de 
8192 e1				pop hl 
8193 12				ld (de),a 
8194 23				inc hl 
8195 13				inc de 
8196			 
8196			;	if DEBUG_STORESE 
8196			;		push af 
8196			;		ld a, 'r' 
8196			;		ld (debug_mark),a 
8196			;		pop af 
8196			;		CALLMONITOR 
8196			;	endif 
8196			 
8196 10 f2			djnz .rl1 
8198			 
8198				if DEBUG_STORESE 
8198					DMARK "SRB" 
8198 f5				push af  
8199 3a ad 81			ld a, (.dmark)  
819c 32 65 ee			ld (debug_mark),a  
819f 3a ae 81			ld a, (.dmark+1)  
81a2 32 66 ee			ld (debug_mark+1),a  
81a5 3a af 81			ld a, (.dmark+2)  
81a8 32 67 ee			ld (debug_mark+2),a  
81ab 18 03			jr .pastdmark  
81ad ..			.dmark: db "SRB"  
81b0 f1			.pastdmark: pop af  
81b1			endm  
# End of macro DMARK
81b1 d1					pop de 
81b2			; 
81b2			;		push af 
81b2			;		ld a, 'R' 
81b2			;		ld (debug_mark),a 
81b2			;		pop af 
81b2					CALLMONITOR 
81b2 cd 6f ee			call debug_vector  
81b5				endm  
# End of macro CALLMONITOR
81b5				endif 
81b5 c9				ret	 
81b6				 
81b6			 
81b6			; File Size 
81b6			; --------- 
81b6			; 
81b6			;   hl file id 
81b6			; 
81b6			;  returns in hl the number of blocks 
81b6			 
81b6			storage_file_size: 
81b6 5d				ld e, l 
81b7 16 00			ld d, 0 
81b9 21 40 00			ld hl, STORE_BLOCK_PHY 
81bc					if DEBUG_FORTH_WORDS 
81bc						DMARK "SIZ" 
81bc f5				push af  
81bd 3a d1 81			ld a, (.dmark)  
81c0 32 65 ee			ld (debug_mark),a  
81c3 3a d2 81			ld a, (.dmark+1)  
81c6 32 66 ee			ld (debug_mark+1),a  
81c9 3a d3 81			ld a, (.dmark+2)  
81cc 32 67 ee			ld (debug_mark+2),a  
81cf 18 03			jr .pastdmark  
81d1 ..			.dmark: db "SIZ"  
81d4 f1			.pastdmark: pop af  
81d5			endm  
# End of macro DMARK
81d5						CALLMONITOR 
81d5 cd 6f ee			call debug_vector  
81d8				endm  
# End of macro CALLMONITOR
81d8					endif 
81d8 cd ba 84			call storage_findnextid 
81db			 
81db cd 13 8d			call ishlzero 
81de			;	ld a, l 
81de			;	add h 
81de			;	cp 0 
81de c8				ret z			; block not found so EOF 
81df			 
81df 11 74 ea			ld de, store_page 
81e2 cd 87 81			call storage_read_block 
81e5			 
81e5 3a 76 ea			ld a, (store_page+2)	 ; get extent count 
81e8 6f				ld l, a 
81e9 26 00			ld h, 0 
81eb c9			 	ret 
81ec			 
81ec			 
81ec			; Write Block 
81ec			; ----------- 
81ec			; 
81ec			; With current bank 
81ec			;  
81ec			; Get block number to write 
81ec			; Write physical blocks starting at start block from buffer 
81ec			  
81ec			storage_write_block: 
81ec				; TODO bank selection 
81ec			 
81ec				; for each of the physical blocks read it into the buffer 
81ec 06 40			ld b, STORE_BLOCK_PHY 
81ee			 
81ee				if DEBUG_STORESE 
81ee					DMARK "SWB" 
81ee f5				push af  
81ef 3a 03 82			ld a, (.dmark)  
81f2 32 65 ee			ld (debug_mark),a  
81f5 3a 04 82			ld a, (.dmark+1)  
81f8 32 66 ee			ld (debug_mark+1),a  
81fb 3a 05 82			ld a, (.dmark+2)  
81fe 32 67 ee			ld (debug_mark+2),a  
8201 18 03			jr .pastdmark  
8203 ..			.dmark: db "SWB"  
8206 f1			.pastdmark: pop af  
8207			endm  
# End of macro DMARK
8207			 
8207					;push af 
8207					;ld a, 'W' 
8207					;ld (debug_mark),a 
8207					;pop af 
8207					CALLMONITOR 
8207 cd 6f ee			call debug_vector  
820a				endm  
# End of macro CALLMONITOR
820a				endif 
820a			 
820a			; might not be working 
820a			;	call se_writepage 
820a			 
820a			;	ret 
820a			; 
820a			 
820a			 
820a			 
820a			.wl1:    
820a			 
820a				; read physical block at hl into de 
820a			        ; increment hl and de to next read position on exit 
820a			 
820a e5				push hl 
820b d5				push de	 
820c c5				push bc 
820d 1a				ld a,(de) 
820e				;if DEBUG_STORESE 
820e			;		push af 
820e			;		ld a, 'W' 
820e			;		ld (debug_mark),a 
820e			;		pop af 
820e			;		CALLMONITOR 
820e			;	endif 
820e cd ac 80			call se_writebyte 
8211			;	call delay250ms 
8211 00				nop 
8212 00				nop 
8213 00				nop 
8214			;	if DEBUG_STORESE 
8214			;		push af 
8214			;		ld a, 'w' 
8214			;		ld (debug_mark),a 
8214			;		pop af 
8214			;		CALLMONITOR 
8214			;	endif 
8214 c1				pop bc 
8215 d1				pop de 
8216 e1				pop hl 
8217 23				inc hl 
8218 13				inc de 
8219			 
8219			 
8219 10 ef			djnz .wl1 
821b			 
821b				if DEBUG_STORESE 
821b					DMARK "SW2" 
821b f5				push af  
821c 3a 30 82			ld a, (.dmark)  
821f 32 65 ee			ld (debug_mark),a  
8222 3a 31 82			ld a, (.dmark+1)  
8225 32 66 ee			ld (debug_mark+1),a  
8228 3a 32 82			ld a, (.dmark+2)  
822b 32 67 ee			ld (debug_mark+2),a  
822e 18 03			jr .pastdmark  
8230 ..			.dmark: db "SW2"  
8233 f1			.pastdmark: pop af  
8234			endm  
# End of macro DMARK
8234			 
8234					;push af 
8234					;ld a, 'W' 
8234					;ld (debug_mark),a 
8234					;pop af 
8234					CALLMONITOR 
8234 cd 6f ee			call debug_vector  
8237				endm  
# End of macro CALLMONITOR
8237				endif 
8237 c9				ret	 
8238			 
8238			; Init bank 
8238			; --------- 
8238			; 
8238			; With current bank 
8238			; 
8238			; Setup block 0 config 
8238			;     Set 0 file id counter 
8238			;     Set formatted byte pattern 
8238			;     Zero out bank label 
8238			;      
8238			; For every logical block write 0-1 byte as null 
8238			 
8238			storage_get_block_0: 
8238			 
8238				; TODO check presence 
8238			 
8238				; get block 0 config 
8238			 
8238 21 00 00			ld hl, 0 
823b 11 74 ea			ld de, store_page 
823e cd 87 81			call storage_read_block 
8241			 
8241				if DEBUG_STORESE 
8241					DMARK "SB0" 
8241 f5				push af  
8242 3a 56 82			ld a, (.dmark)  
8245 32 65 ee			ld (debug_mark),a  
8248 3a 57 82			ld a, (.dmark+1)  
824b 32 66 ee			ld (debug_mark+1),a  
824e 3a 58 82			ld a, (.dmark+2)  
8251 32 67 ee			ld (debug_mark+2),a  
8254 18 03			jr .pastdmark  
8256 ..			.dmark: db "SB0"  
8259 f1			.pastdmark: pop af  
825a			endm  
# End of macro DMARK
825a 11 74 ea				ld de, store_page 
825d			;		push af 
825d			;		ld a, 'i' 
825d			;		ld (debug_mark),a 
825d			;		pop af 
825d					CALLMONITOR 
825d cd 6f ee			call debug_vector  
8260				endm  
# End of macro CALLMONITOR
8260				endif 
8260			 
8260				; is this area formatted? 
8260			 
8260			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8260 2a 75 ea			ld hl, (store_page+1) 
8263 3e 80			ld a,0x80 
8265 bd				cp l 
8266 20 22			jr nz, .ininotformatted 
8268				; do a double check 
8268 3e 27			ld a, 0x27 
826a bc				cp h 
826b 20 1d			jr nz, .ininotformatted 
826d			 
826d				; formatted then 
826d			 
826d				if DEBUG_STORESE 
826d					DMARK "SB1" 
826d f5				push af  
826e 3a 82 82			ld a, (.dmark)  
8271 32 65 ee			ld (debug_mark),a  
8274 3a 83 82			ld a, (.dmark+1)  
8277 32 66 ee			ld (debug_mark+1),a  
827a 3a 84 82			ld a, (.dmark+2)  
827d 32 67 ee			ld (debug_mark+2),a  
8280 18 03			jr .pastdmark  
8282 ..			.dmark: db "SB1"  
8285 f1			.pastdmark: pop af  
8286			endm  
# End of macro DMARK
8286					;push af 
8286					;ld a, 'I' 
8286					;ld (debug_mark),a 
8286					;pop af 
8286					CALLMONITOR 
8286 cd 6f ee			call debug_vector  
8289				endm  
# End of macro CALLMONITOR
8289				endif 
8289 c9				ret 
828a			 
828a			.ininotformatted: 
828a				; bank not formatted so poke various bits to make sure 
828a			 
828a				if DEBUG_STORESE 
828a					DMARK "SB2" 
828a f5				push af  
828b 3a 9f 82			ld a, (.dmark)  
828e 32 65 ee			ld (debug_mark),a  
8291 3a a0 82			ld a, (.dmark+1)  
8294 32 66 ee			ld (debug_mark+1),a  
8297 3a a1 82			ld a, (.dmark+2)  
829a 32 67 ee			ld (debug_mark+2),a  
829d 18 03			jr .pastdmark  
829f ..			.dmark: db "SB2"  
82a2 f1			.pastdmark: pop af  
82a3			endm  
# End of macro DMARK
82a3					;push af 
82a3					;ld a, 'f' 
82a3					;ld (debug_mark),a 
82a3					;pop af 
82a3					CALLMONITOR 
82a3 cd 6f ee			call debug_vector  
82a6				endm  
# End of macro CALLMONITOR
82a6				endif 
82a6			 
82a6 cd c3 89			call storage_clear_page 
82a9			 
82a9 21 74 ea			ld hl, store_page 
82ac 3e 00			ld a, 0 
82ae				 
82ae 77				ld (hl),a   ; reset file counter 
82af			 
82af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82b2 22 75 ea		 	ld (store_page+1), hl	 
82b5			 
82b5				; set default label 
82b5			 
82b5 21 51 83			ld hl, .defaultbanklabl 
82b8 11 77 ea		 	ld de, store_page+3 
82bb 01 0f 00			ld bc, 15 
82be ed b0			ldir 
82c0			 
82c0				; Append the current bank id 
82c0 21 80 ea			ld hl, store_page+3+9 
82c3 3a 59 ea			ld a, (spi_device_id) 
82c6 77				ld (hl), a 
82c7			 
82c7				; save default page 0 
82c7			 
82c7 21 00 00			ld hl, 0 
82ca 11 74 ea			ld de, store_page 
82cd				if DEBUG_STORESE 
82cd					DMARK "SB3" 
82cd f5				push af  
82ce 3a e2 82			ld a, (.dmark)  
82d1 32 65 ee			ld (debug_mark),a  
82d4 3a e3 82			ld a, (.dmark+1)  
82d7 32 66 ee			ld (debug_mark+1),a  
82da 3a e4 82			ld a, (.dmark+2)  
82dd 32 67 ee			ld (debug_mark+2),a  
82e0 18 03			jr .pastdmark  
82e2 ..			.dmark: db "SB3"  
82e5 f1			.pastdmark: pop af  
82e6			endm  
# End of macro DMARK
82e6			;		push af 
82e6			;		ld a, 'F' 
82e6			;		ld (debug_mark),a 
82e6			;		pop af 
82e6					CALLMONITOR 
82e6 cd 6f ee			call debug_vector  
82e9				endm  
# End of macro CALLMONITOR
82e9				endif 
82e9 cd ec 81			call storage_write_block 
82ec				if DEBUG_STORESE 
82ec					DMARK "SB4" 
82ec f5				push af  
82ed 3a 01 83			ld a, (.dmark)  
82f0 32 65 ee			ld (debug_mark),a  
82f3 3a 02 83			ld a, (.dmark+1)  
82f6 32 66 ee			ld (debug_mark+1),a  
82f9 3a 03 83			ld a, (.dmark+2)  
82fc 32 67 ee			ld (debug_mark+2),a  
82ff 18 03			jr .pastdmark  
8301 ..			.dmark: db "SB4"  
8304 f1			.pastdmark: pop af  
8305			endm  
# End of macro DMARK
8305			;		push af 
8305			;		ld a, '>' 
8305			;		ld (debug_mark),a 
8305			;		pop af 
8305					CALLMONITOR 
8305 cd 6f ee			call debug_vector  
8308				endm  
# End of macro CALLMONITOR
8308				endif 
8308			 
8308 00				nop 
8309 00				nop 
830a 00				nop 
830b			 
830b				; now set 0 in every page to mark as a free block 
830b			 
830b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
830d 21 40 00			ld hl, STORE_BLOCK_PHY 
8310			 
8310 3e 00		.setmark1:   	ld a,0 
8312 e5					push hl 
8313 c5					push bc 
8314 cd ac 80				call se_writebyte 
8317 3e 0a			ld a, 10 
8319 cd e5 89			call aDelayInMS 
831c 23				inc hl 
831d cd ac 80				call se_writebyte 
8320 3e 0a			ld a, 10 
8322 cd e5 89			call aDelayInMS 
8325 2b				dec hl 
8326 c1					pop bc 
8327 e1					pop hl 
8328 3e 40				ld a, STORE_BLOCK_PHY 
832a cd ea 8c				call addatohl 
832d 10 e1				djnz .setmark1 
832f			 
832f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8331 3e 00		.setmark2:   	ld a,0 
8333 e5					push hl 
8334 c5					push bc 
8335 cd ac 80				call se_writebyte 
8338 3e 0a			ld a, 10 
833a cd e5 89			call aDelayInMS 
833d 23				inc hl 
833e cd ac 80				call se_writebyte 
8341 3e 0a			ld a, 10 
8343 cd e5 89			call aDelayInMS 
8346 2b				dec hl 
8347 c1					pop bc 
8348 e1					pop hl 
8349 3e 40				ld a, STORE_BLOCK_PHY 
834b cd ea 8c				call addatohl 
834e 10 e1				djnz .setmark2 
8350			 
8350					 
8350			 
8350			 
8350 c9				ret 
8351			 
8351			 
8351			 
8351			 
8351 .. 00		.defaultbanklabl:   db "BankLabel_",0 
835c			 
835c			 
835c			 
835c			; Label Bank 
835c			; ---------- 
835c			; 
835c			; With current bank 
835c			; Read block 0 
835c			; Set label 
835c			; Write block 0 
835c			 
835c			; label str pointer in hl 
835c			 
835c			storage_label:     
835c			 
835c				if DEBUG_STORESE 
835c					DMARK "LBL" 
835c f5				push af  
835d 3a 71 83			ld a, (.dmark)  
8360 32 65 ee			ld (debug_mark),a  
8363 3a 72 83			ld a, (.dmark+1)  
8366 32 66 ee			ld (debug_mark+1),a  
8369 3a 73 83			ld a, (.dmark+2)  
836c 32 67 ee			ld (debug_mark+2),a  
836f 18 03			jr .pastdmark  
8371 ..			.dmark: db "LBL"  
8374 f1			.pastdmark: pop af  
8375			endm  
# End of macro DMARK
8375					CALLMONITOR 
8375 cd 6f ee			call debug_vector  
8378				endm  
# End of macro CALLMONITOR
8378				endif 
8378			 
8378 e5				push hl 
8379			 
8379 cd 38 82			call storage_get_block_0 
837c			 
837c				; set default label 
837c			 
837c e1				pop hl 
837d			 
837d 11 77 ea		 	ld de, store_page+3 
8380 01 0f 00			ld bc, 15 
8383				if DEBUG_STORESE 
8383					DMARK "LB3" 
8383 f5				push af  
8384 3a 98 83			ld a, (.dmark)  
8387 32 65 ee			ld (debug_mark),a  
838a 3a 99 83			ld a, (.dmark+1)  
838d 32 66 ee			ld (debug_mark+1),a  
8390 3a 9a 83			ld a, (.dmark+2)  
8393 32 67 ee			ld (debug_mark+2),a  
8396 18 03			jr .pastdmark  
8398 ..			.dmark: db "LB3"  
839b f1			.pastdmark: pop af  
839c			endm  
# End of macro DMARK
839c					CALLMONITOR 
839c cd 6f ee			call debug_vector  
839f				endm  
# End of macro CALLMONITOR
839f				endif 
839f ed b0			ldir 
83a1				; save default page 0 
83a1			 
83a1 21 00 00			ld hl, 0 
83a4 11 74 ea			ld de, store_page 
83a7				if DEBUG_STORESE 
83a7					DMARK "LBW" 
83a7 f5				push af  
83a8 3a bc 83			ld a, (.dmark)  
83ab 32 65 ee			ld (debug_mark),a  
83ae 3a bd 83			ld a, (.dmark+1)  
83b1 32 66 ee			ld (debug_mark+1),a  
83b4 3a be 83			ld a, (.dmark+2)  
83b7 32 67 ee			ld (debug_mark+2),a  
83ba 18 03			jr .pastdmark  
83bc ..			.dmark: db "LBW"  
83bf f1			.pastdmark: pop af  
83c0			endm  
# End of macro DMARK
83c0					CALLMONITOR 
83c0 cd 6f ee			call debug_vector  
83c3				endm  
# End of macro CALLMONITOR
83c3				endif 
83c3 cd ec 81			call storage_write_block 
83c6			 
83c6 c9				ret 
83c7			 
83c7			 
83c7			 
83c7			; Read Block 0 - Config 
83c7			; --------------------- 
83c7			; 
83c7			; With current bank 
83c7			; Call presence test 
83c7			;    If not present format/init bank  
83c7			; Read block 0  
83c7			;  
83c7			 
83c7			 
83c7			; Dir 
83c7			; --- 
83c7			; 
83c7			; With current bank 
83c7			; Load Block 0 Config 
83c7			; Get max file id number 
83c7			; For each logical block 
83c7			;    Read block read byte 2 
83c7			;      if first block of file 
83c7			;         Display file name 
83c7			;         Display type flags for file 
83c7			;        
83c7			 
83c7			; moving to words as this requires stack control 
83c7			 
83c7			 
83c7			; Delete File 
83c7			; ----------- 
83c7			; 
83c7			; With current bank 
83c7			; 
83c7			; Load Block 0 Config 
83c7			; Get max file id number 
83c7			; For each logical block 
83c7			;    Read block file id 
83c7			;      If first block of file and dont have file id 
83c7			;         if file to delete 
83c7			;         Save file id 
83c7			;         Null file id 
83c7			;         Write this block back 
83c7			;      If file id is one saved 
83c7			;         Null file id 
83c7			;         Write this block back 
83c7			 
83c7			 
83c7			.se_done: 
83c7 e1				pop hl 
83c8 c9				ret 
83c9			 
83c9			storage_erase: 
83c9			 
83c9				; hl contains the file id 
83c9			 
83c9 5d				ld e, l 
83ca 16 00			ld d, 0 
83cc 21 40 00			ld hl, STORE_BLOCK_PHY 
83cf					if DEBUG_FORTH_WORDS 
83cf						DMARK "ERA" 
83cf f5				push af  
83d0 3a e4 83			ld a, (.dmark)  
83d3 32 65 ee			ld (debug_mark),a  
83d6 3a e5 83			ld a, (.dmark+1)  
83d9 32 66 ee			ld (debug_mark+1),a  
83dc 3a e6 83			ld a, (.dmark+2)  
83df 32 67 ee			ld (debug_mark+2),a  
83e2 18 03			jr .pastdmark  
83e4 ..			.dmark: db "ERA"  
83e7 f1			.pastdmark: pop af  
83e8			endm  
# End of macro DMARK
83e8						CALLMONITOR 
83e8 cd 6f ee			call debug_vector  
83eb				endm  
# End of macro CALLMONITOR
83eb					endif 
83eb cd ba 84			call storage_findnextid 
83ee cd 13 8d			call ishlzero 
83f1 c8				ret z 
83f2			 
83f2 e5				push hl 
83f3			 
83f3				; TODO check file not found 
83f3			 
83f3 11 74 ea			ld de, store_page 
83f6 cd 87 81			call storage_read_block 
83f9			 
83f9 cd 13 8d			call ishlzero 
83fc ca c7 83			jp z,.se_done 
83ff			 
83ff					if DEBUG_FORTH_WORDS 
83ff						DMARK "ER1" 
83ff f5				push af  
8400 3a 14 84			ld a, (.dmark)  
8403 32 65 ee			ld (debug_mark),a  
8406 3a 15 84			ld a, (.dmark+1)  
8409 32 66 ee			ld (debug_mark+1),a  
840c 3a 16 84			ld a, (.dmark+2)  
840f 32 67 ee			ld (debug_mark+2),a  
8412 18 03			jr .pastdmark  
8414 ..			.dmark: db "ER1"  
8417 f1			.pastdmark: pop af  
8418			endm  
# End of macro DMARK
8418						CALLMONITOR 
8418 cd 6f ee			call debug_vector  
841b				endm  
# End of macro CALLMONITOR
841b					endif 
841b 3a 74 ea			ld a, (store_page)	; get file id 
841e 32 68 ea			ld (store_tmpid), a 
8421			 
8421 3a 76 ea			ld a, (store_page+2)    ; get count of extends 
8424 32 67 ea			ld (store_tmpext), a 
8427			 
8427				; wipe file header 
8427			 
8427 e1				pop hl 
8428 3e 00			ld a, 0 
842a 32 74 ea			ld (store_page), a 
842d 32 75 ea			ld (store_page+1),a 
8430 11 74 ea			ld de, store_page 
8433					if DEBUG_FORTH_WORDS 
8433						DMARK "ER2" 
8433 f5				push af  
8434 3a 48 84			ld a, (.dmark)  
8437 32 65 ee			ld (debug_mark),a  
843a 3a 49 84			ld a, (.dmark+1)  
843d 32 66 ee			ld (debug_mark+1),a  
8440 3a 4a 84			ld a, (.dmark+2)  
8443 32 67 ee			ld (debug_mark+2),a  
8446 18 03			jr .pastdmark  
8448 ..			.dmark: db "ER2"  
844b f1			.pastdmark: pop af  
844c			endm  
# End of macro DMARK
844c						CALLMONITOR 
844c cd 6f ee			call debug_vector  
844f				endm  
# End of macro CALLMONITOR
844f					endif 
844f cd ec 81			call storage_write_block 
8452			 
8452			 
8452				; wipe file extents 
8452			 
8452 3a 67 ea			ld a, (store_tmpext) 
8455 47				ld b, a 
8456			 
8456			.eraext:	  
8456 c5				push bc 
8457			 
8457 21 40 00			ld hl, STORE_BLOCK_PHY 
845a 3a 68 ea			ld a,(store_tmpid) 
845d 5f				ld e, a 
845e 50				ld d, b	 
845f					if DEBUG_FORTH_WORDS 
845f						DMARK "ER3" 
845f f5				push af  
8460 3a 74 84			ld a, (.dmark)  
8463 32 65 ee			ld (debug_mark),a  
8466 3a 75 84			ld a, (.dmark+1)  
8469 32 66 ee			ld (debug_mark+1),a  
846c 3a 76 84			ld a, (.dmark+2)  
846f 32 67 ee			ld (debug_mark+2),a  
8472 18 03			jr .pastdmark  
8474 ..			.dmark: db "ER3"  
8477 f1			.pastdmark: pop af  
8478			endm  
# End of macro DMARK
8478						CALLMONITOR 
8478 cd 6f ee			call debug_vector  
847b				endm  
# End of macro CALLMONITOR
847b					endif 
847b cd ba 84			call storage_findnextid 
847e cd 13 8d			call ishlzero 
8481 ca c7 83			jp z,.se_done 
8484			 
8484 e5				push hl 
8485 11 74 ea			ld de, store_page 
8488 cd 87 81			call storage_read_block 
848b			 
848b				; free block	 
848b			 
848b 3e 00			ld a, 0 
848d 32 74 ea			ld (store_page), a 
8490 32 75 ea			ld (store_page+1),a 
8493 11 74 ea			ld de, store_page 
8496 e1				pop hl 
8497					if DEBUG_FORTH_WORDS 
8497						DMARK "ER4" 
8497 f5				push af  
8498 3a ac 84			ld a, (.dmark)  
849b 32 65 ee			ld (debug_mark),a  
849e 3a ad 84			ld a, (.dmark+1)  
84a1 32 66 ee			ld (debug_mark+1),a  
84a4 3a ae 84			ld a, (.dmark+2)  
84a7 32 67 ee			ld (debug_mark+2),a  
84aa 18 03			jr .pastdmark  
84ac ..			.dmark: db "ER4"  
84af f1			.pastdmark: pop af  
84b0			endm  
# End of macro DMARK
84b0						CALLMONITOR 
84b0 cd 6f ee			call debug_vector  
84b3				endm  
# End of macro CALLMONITOR
84b3					endif 
84b3 cd ec 81			call storage_write_block 
84b6			 
84b6 c1				pop bc 
84b7 10 9d			djnz .eraext 
84b9			 
84b9 c9				ret 
84ba			 
84ba			 
84ba			; Find Free Block 
84ba			; --------------- 
84ba			; 
84ba			; With current bank 
84ba			;  
84ba			; From given starting logical block 
84ba			;    Read block  
84ba			;    If no file id 
84ba			;         Return block id 
84ba			 
84ba			 
84ba			; hl starting page number 
84ba			; hl contains free page number or zero if no pages free 
84ba			; e contains the file id to locate 
84ba			; d contains the block number 
84ba			 
84ba			; TODO change to find file id and use zero for free block 
84ba			 
84ba			storage_findnextid: 
84ba			 
84ba				; now locate first 0 page to mark as a free block 
84ba			 
84ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84bc			;	ld hl, STORE_BLOCK_PHY 
84bc			 
84bc					if DEBUG_FORTH_WORDS 
84bc					DMARK "FNI" 
84bc f5				push af  
84bd 3a d1 84			ld a, (.dmark)  
84c0 32 65 ee			ld (debug_mark),a  
84c3 3a d2 84			ld a, (.dmark+1)  
84c6 32 66 ee			ld (debug_mark+1),a  
84c9 3a d3 84			ld a, (.dmark+2)  
84cc 32 67 ee			ld (debug_mark+2),a  
84cf 18 03			jr .pastdmark  
84d1 ..			.dmark: db "FNI"  
84d4 f1			.pastdmark: pop af  
84d5			endm  
# End of macro DMARK
84d5						CALLMONITOR 
84d5 cd 6f ee			call debug_vector  
84d8				endm  
# End of macro CALLMONITOR
84d8					endif 
84d8			.ff1:   	 
84d8 e5					push hl 
84d9 c5					push bc 
84da d5					push de 
84db cd ab 80				call se_readbyte 
84de 5f					ld e,a 
84df 23					inc hl 
84e0 cd ab 80				call se_readbyte 
84e3 57					ld d, a 
84e4 e1					pop hl 
84e5 e5					push hl 
84e6 cd 08 8d				call cmp16 
84e9 28 49				jr z, .fffound 
84eb			 
84eb d1					pop de 
84ec c1					pop bc 
84ed e1					pop hl 
84ee			 
84ee					; is found? 
84ee					;cp e 
84ee					;ret z 
84ee			 
84ee 3e 40				ld a, STORE_BLOCK_PHY 
84f0 cd ea 8c				call addatohl 
84f3 10 e3				djnz .ff1 
84f5			 
84f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f7			.ff2:   	 
84f7			 
84f7 e5					push hl 
84f8 c5					push bc 
84f9 d5					push de 
84fa cd ab 80				call se_readbyte 
84fd 5f					ld e,a 
84fe 23					inc hl 
84ff cd ab 80				call se_readbyte 
8502 57					ld d, a 
8503			 
8503 e1					pop hl 
8504 e5					push hl 
8505 cd 08 8d				call cmp16 
8508 28 2a				jr z, .fffound 
850a			 
850a d1					pop de 
850b c1					pop bc 
850c e1					pop hl 
850d					; is found? 
850d					;cp e 
850d					;ret z 
850d			 
850d 3e 40				ld a, STORE_BLOCK_PHY 
850f cd ea 8c				call addatohl 
8512 10 e3				djnz .ff2 
8514			 
8514			 
8514					if DEBUG_FORTH_WORDS 
8514					DMARK "FN-" 
8514 f5				push af  
8515 3a 29 85			ld a, (.dmark)  
8518 32 65 ee			ld (debug_mark),a  
851b 3a 2a 85			ld a, (.dmark+1)  
851e 32 66 ee			ld (debug_mark+1),a  
8521 3a 2b 85			ld a, (.dmark+2)  
8524 32 67 ee			ld (debug_mark+2),a  
8527 18 03			jr .pastdmark  
8529 ..			.dmark: db "FN-"  
852c f1			.pastdmark: pop af  
852d			endm  
# End of macro DMARK
852d					;	push af 
852d					;	ld a, 'n' 
852d					;	ld (debug_mark),a 
852d					;	pop af 
852d						CALLMONITOR 
852d cd 6f ee			call debug_vector  
8530				endm  
# End of macro CALLMONITOR
8530					endif 
8530				; no free marks! 
8530 21 00 00				ld hl, 0 
8533 c9				ret 
8534			.fffound: 
8534				 
8534			 
8534 d1					pop de 
8535 c1					pop bc 
8536 e1					pop hl 
8537					if DEBUG_FORTH_WORDS 
8537					DMARK "FNF" 
8537 f5				push af  
8538 3a 4c 85			ld a, (.dmark)  
853b 32 65 ee			ld (debug_mark),a  
853e 3a 4d 85			ld a, (.dmark+1)  
8541 32 66 ee			ld (debug_mark+1),a  
8544 3a 4e 85			ld a, (.dmark+2)  
8547 32 67 ee			ld (debug_mark+2),a  
854a 18 03			jr .pastdmark  
854c ..			.dmark: db "FNF"  
854f f1			.pastdmark: pop af  
8550			endm  
# End of macro DMARK
8550					;	push af 
8550					;	ld a, 'n' 
8550					;	ld (debug_mark),a 
8550					;	pop af 
8550						CALLMONITOR 
8550 cd 6f ee			call debug_vector  
8553				endm  
# End of macro CALLMONITOR
8553					endif 
8553 c9				ret 
8554			 
8554			 
8554			 
8554			; Free Space 
8554			; ---------- 
8554			; 
8554			; With current bank 
8554			; 
8554			; Set block count to zero 
8554			; Starting with first logical block 
8554			;      Find free block  
8554			;      If block id given, increment block count 
8554			; 
8554			;  
8554			 
8554			 
8554			; hl contains count of free blocks 
8554			 
8554			storage_freeblocks: 
8554			 
8554				; now locate first 0 page to mark as a free block 
8554			 
8554 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8556 21 40 00			ld hl, STORE_BLOCK_PHY 
8559 11 00 00			ld de, 0 
855c			 
855c			.fb1:   	 
855c e5					push hl 
855d c5					push bc 
855e d5					push de 
855f cd ab 80				call se_readbyte 
8562 d1					pop de 
8563 c1					pop bc 
8564 e1					pop hl 
8565			 
8565					; is free? 
8565 fe 00				cp 0 
8567 20 01				jr nz, .ff1cont 
8569 13					inc de 
856a			 
856a			.ff1cont: 
856a			 
856a			 
856a 3e 40				ld a, STORE_BLOCK_PHY 
856c cd ea 8c				call addatohl 
856f 10 eb				djnz .fb1 
8571			 
8571 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8573			.fb2:   	 
8573 e5					push hl 
8574 c5					push bc 
8575 d5					push de 
8576 cd ab 80				call se_readbyte 
8579 d1					pop de 
857a c1					pop bc 
857b e1					pop hl 
857c			 
857c					; is free? 
857c fe 00				cp 0 
857e 20 01				jr nz, .ff2cont 
8580 13					inc de 
8581			 
8581			.ff2cont: 
8581			 
8581 3e 40				ld a, STORE_BLOCK_PHY 
8583 cd ea 8c				call addatohl 
8586 10 eb				djnz .fb2 
8588			 
8588 eb				ex de, hl 
8589 c9				ret 
858a			 
858a			; Get File ID 
858a			; ----------- 
858a			; 
858a			; With current bank 
858a			;  
858a			; Load Block 0 Config 
858a			; Get max file id number 
858a			; For each logical block 
858a			;    Read block file id 
858a			;      If first block of file and dont have file id 
858a			;         if file get id and exit 
858a			 
858a			 
858a			 
858a			 
858a			; Create File 
858a			; ----------- 
858a			; 
858a			; With current bank  
858a			; Load Block 0 Config 
858a			; Get max file id number 
858a			; Increment file id number 
858a			; Save Config 
858a			; Find free block 
858a			; Set buffer with file name and file id 
858a			; Write buffer to free block  
858a			 
858a			 
858a			; hl point to file name 
858a			; hl returns file id 
858a			 
858a			; file format: 
858a			; byte 0 - file id 
858a			; byte 1 - extent number 
858a			; byte 2-> data 
858a			 
858a			; format for extent number 0: 
858a			; 
858a			; byte 0 - file id 
858a			; byte 1 - extent 0 
858a			; byte 2 - extent count 
858a			; byte 3 -> file name and meta data 
858a			 
858a			 
858a			storage_create: 
858a				if DEBUG_STORESE 
858a					DMARK "SCR" 
858a f5				push af  
858b 3a 9f 85			ld a, (.dmark)  
858e 32 65 ee			ld (debug_mark),a  
8591 3a a0 85			ld a, (.dmark+1)  
8594 32 66 ee			ld (debug_mark+1),a  
8597 3a a1 85			ld a, (.dmark+2)  
859a 32 67 ee			ld (debug_mark+2),a  
859d 18 03			jr .pastdmark  
859f ..			.dmark: db "SCR"  
85a2 f1			.pastdmark: pop af  
85a3			endm  
# End of macro DMARK
85a3					CALLMONITOR 
85a3 cd 6f ee			call debug_vector  
85a6				endm  
# End of macro CALLMONITOR
85a6				endif 
85a6			 
85a6 e5				push hl		; save file name pointer 
85a7			 
85a7 cd 38 82			call storage_get_block_0 
85aa			 
85aa 3a 74 ea			ld a,(store_page)	; get current file id 
85ad 3c				inc a 
85ae 32 74 ea			ld (store_page),a 
85b1				 
85b1 32 68 ea			ld (store_tmpid),a			; save id 
85b4			 
85b4 21 00 00			ld hl, 0 
85b7 11 74 ea			ld de, store_page 
85ba				if DEBUG_STORESE 
85ba					DMARK "SCw" 
85ba f5				push af  
85bb 3a cf 85			ld a, (.dmark)  
85be 32 65 ee			ld (debug_mark),a  
85c1 3a d0 85			ld a, (.dmark+1)  
85c4 32 66 ee			ld (debug_mark+1),a  
85c7 3a d1 85			ld a, (.dmark+2)  
85ca 32 67 ee			ld (debug_mark+2),a  
85cd 18 03			jr .pastdmark  
85cf ..			.dmark: db "SCw"  
85d2 f1			.pastdmark: pop af  
85d3			endm  
# End of macro DMARK
85d3					CALLMONITOR 
85d3 cd 6f ee			call debug_vector  
85d6				endm  
# End of macro CALLMONITOR
85d6				endif 
85d6 cd ec 81			call storage_write_block	 ; save update 
85d9			 
85d9				if DEBUG_STORESE 
85d9 11 74 ea				ld de, store_page 
85dc					DMARK "SCC" 
85dc f5				push af  
85dd 3a f1 85			ld a, (.dmark)  
85e0 32 65 ee			ld (debug_mark),a  
85e3 3a f2 85			ld a, (.dmark+1)  
85e6 32 66 ee			ld (debug_mark+1),a  
85e9 3a f3 85			ld a, (.dmark+2)  
85ec 32 67 ee			ld (debug_mark+2),a  
85ef 18 03			jr .pastdmark  
85f1 ..			.dmark: db "SCC"  
85f4 f1			.pastdmark: pop af  
85f5			endm  
# End of macro DMARK
85f5					CALLMONITOR 
85f5 cd 6f ee			call debug_vector  
85f8				endm  
# End of macro CALLMONITOR
85f8				endif 
85f8				;  
85f8				 
85f8 21 40 00			ld hl, STORE_BLOCK_PHY 
85fb 11 00 00			ld de, 0 
85fe cd ba 84			call storage_findnextid 
8601			 
8601 22 5f ea			ld (store_tmppageid), hl    ; save page to use  
8604			 
8604				; TODO detect 0 = no spare blocks 
8604			 
8604				; hl now contains the free page to use for the file header page 
8604			 
8604				if DEBUG_STORESE 
8604				DMARK "SCF" 
8604 f5				push af  
8605 3a 19 86			ld a, (.dmark)  
8608 32 65 ee			ld (debug_mark),a  
860b 3a 1a 86			ld a, (.dmark+1)  
860e 32 66 ee			ld (debug_mark+1),a  
8611 3a 1b 86			ld a, (.dmark+2)  
8614 32 67 ee			ld (debug_mark+2),a  
8617 18 03			jr .pastdmark  
8619 ..			.dmark: db "SCF"  
861c f1			.pastdmark: pop af  
861d			endm  
# End of macro DMARK
861d					CALLMONITOR 
861d cd 6f ee			call debug_vector  
8620				endm  
# End of macro CALLMONITOR
8620				endif 
8620			 
8620 22 5f ea			ld (store_tmppageid), hl 
8623				 
8623 3a 68 ea			ld a,(store_tmpid)    ; get file id 
8626			;	ld a, (store_filecache)			; save to cache 
8626			 
8626 32 74 ea			ld (store_page),a    ; set page id 
8629 3e 00			ld a, 0			 ; extent 0 is file header 
862b 32 75 ea			ld (store_page+1), a   ; set file extent 
862e			 
862e 32 76 ea			ld (store_page+2), a   ; extent count for the file 
8631			 
8631			;	inc hl 		; init block 0 of file 
8631			;	inc hl   		; skip file and extent id 
8631			 ;       ld a, 0 
8631			;	ld (hl),a 
8631			;	ld a, (store_filecache+1)  	; save to cache 
8631			 
8631			;	inc hl    ; file name 
8631				 
8631				 
8631 11 77 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8634				if DEBUG_STORESE 
8634					DMARK "SCc" 
8634 f5				push af  
8635 3a 49 86			ld a, (.dmark)  
8638 32 65 ee			ld (debug_mark),a  
863b 3a 4a 86			ld a, (.dmark+1)  
863e 32 66 ee			ld (debug_mark+1),a  
8641 3a 4b 86			ld a, (.dmark+2)  
8644 32 67 ee			ld (debug_mark+2),a  
8647 18 03			jr .pastdmark  
8649 ..			.dmark: db "SCc"  
864c f1			.pastdmark: pop af  
864d			endm  
# End of macro DMARK
864d					CALLMONITOR 
864d cd 6f ee			call debug_vector  
8650				endm  
# End of macro CALLMONITOR
8650				endif 
8650 e1				pop hl    ; get zero term string 
8651 e5				push hl 
8652 3e 00			ld a, 0 
8654 cd 5b 90			call strlent 
8657 23				inc hl   ; cover zero term 
8658 06 00			ld b,0 
865a 4d				ld c,l 
865b e1				pop hl 
865c				;ex de, hl 
865c				if DEBUG_STORESE 
865c					DMARK "SCa" 
865c f5				push af  
865d 3a 71 86			ld a, (.dmark)  
8660 32 65 ee			ld (debug_mark),a  
8663 3a 72 86			ld a, (.dmark+1)  
8666 32 66 ee			ld (debug_mark+1),a  
8669 3a 73 86			ld a, (.dmark+2)  
866c 32 67 ee			ld (debug_mark+2),a  
866f 18 03			jr .pastdmark  
8671 ..			.dmark: db "SCa"  
8674 f1			.pastdmark: pop af  
8675			endm  
# End of macro DMARK
8675					;push af 
8675					;ld a, 'a' 
8675					;ld (debug_mark),a 
8675					;pop af 
8675					CALLMONITOR 
8675 cd 6f ee			call debug_vector  
8678				endm  
# End of macro CALLMONITOR
8678				endif 
8678 ed b0			ldir    ; copy zero term string 
867a				if DEBUG_STORESE 
867a					DMARK "SCA" 
867a f5				push af  
867b 3a 8f 86			ld a, (.dmark)  
867e 32 65 ee			ld (debug_mark),a  
8681 3a 90 86			ld a, (.dmark+1)  
8684 32 66 ee			ld (debug_mark+1),a  
8687 3a 91 86			ld a, (.dmark+2)  
868a 32 67 ee			ld (debug_mark+2),a  
868d 18 03			jr .pastdmark  
868f ..			.dmark: db "SCA"  
8692 f1			.pastdmark: pop af  
8693			endm  
# End of macro DMARK
8693					CALLMONITOR 
8693 cd 6f ee			call debug_vector  
8696				endm  
# End of macro CALLMONITOR
8696				endif 
8696			 
8696				; write file header page 
8696			 
8696 2a 5f ea			ld hl,(store_tmppageid) 
8699 11 74 ea			ld de, store_page 
869c				if DEBUG_STORESE 
869c					DMARK "SCb" 
869c f5				push af  
869d 3a b1 86			ld a, (.dmark)  
86a0 32 65 ee			ld (debug_mark),a  
86a3 3a b2 86			ld a, (.dmark+1)  
86a6 32 66 ee			ld (debug_mark+1),a  
86a9 3a b3 86			ld a, (.dmark+2)  
86ac 32 67 ee			ld (debug_mark+2),a  
86af 18 03			jr .pastdmark  
86b1 ..			.dmark: db "SCb"  
86b4 f1			.pastdmark: pop af  
86b5			endm  
# End of macro DMARK
86b5					;push af 
86b5					;ld a, 'b' 
86b5					;ld (debug_mark),a 
86b5					;pop af 
86b5					CALLMONITOR 
86b5 cd 6f ee			call debug_vector  
86b8				endm  
# End of macro CALLMONITOR
86b8				endif 
86b8 cd ec 81			call storage_write_block 
86bb			 
86bb 3a 68 ea			ld a, (store_tmpid) 
86be 6f				ld l, a 
86bf 26 00			ld h,0 
86c1				if DEBUG_STORESE 
86c1					DMARK "SCz" 
86c1 f5				push af  
86c2 3a d6 86			ld a, (.dmark)  
86c5 32 65 ee			ld (debug_mark),a  
86c8 3a d7 86			ld a, (.dmark+1)  
86cb 32 66 ee			ld (debug_mark+1),a  
86ce 3a d8 86			ld a, (.dmark+2)  
86d1 32 67 ee			ld (debug_mark+2),a  
86d4 18 03			jr .pastdmark  
86d6 ..			.dmark: db "SCz"  
86d9 f1			.pastdmark: pop af  
86da			endm  
# End of macro DMARK
86da					CALLMONITOR 
86da cd 6f ee			call debug_vector  
86dd				endm  
# End of macro CALLMONITOR
86dd				endif 
86dd c9				ret 
86de				 
86de			 
86de			 
86de			; 
86de			; Read File 
86de			; 
86de			; h - file id to locate 
86de			; l - extent to locate 
86de			; de - pointer to string to read into 
86de			; 
86de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86de			 
86de			.sr_fail: 
86de d1				pop de 
86df c9				ret 
86e0			 
86e0			storage_read: 
86e0			 
86e0			 
86e0 d5				push de 
86e1			 
86e1			; TODO BUG the above push is it popped before the RET Z? 
86e1			 
86e1			; TODO how to handle multiple part blocks 
86e1			 
86e1				; locate file extent to read 
86e1			 
86e1 5c				ld e, h 
86e2 55				ld d, l 
86e3			 
86e3			.srext: 
86e3 22 72 ea			ld (store_readptr), hl     ; save the current extent to load 
86e6 ed 53 70 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86ea			 
86ea 21 40 00			ld hl, STORE_BLOCK_PHY 
86ed				if DEBUG_STORESE 
86ed					DMARK "sre" 
86ed f5				push af  
86ee 3a 02 87			ld a, (.dmark)  
86f1 32 65 ee			ld (debug_mark),a  
86f4 3a 03 87			ld a, (.dmark+1)  
86f7 32 66 ee			ld (debug_mark+1),a  
86fa 3a 04 87			ld a, (.dmark+2)  
86fd 32 67 ee			ld (debug_mark+2),a  
8700 18 03			jr .pastdmark  
8702 ..			.dmark: db "sre"  
8705 f1			.pastdmark: pop af  
8706			endm  
# End of macro DMARK
8706					CALLMONITOR 
8706 cd 6f ee			call debug_vector  
8709				endm  
# End of macro CALLMONITOR
8709				endif 
8709 cd ba 84			call storage_findnextid 
870c			 
870c				if DEBUG_STORESE 
870c					DMARK "srf" 
870c f5				push af  
870d 3a 21 87			ld a, (.dmark)  
8710 32 65 ee			ld (debug_mark),a  
8713 3a 22 87			ld a, (.dmark+1)  
8716 32 66 ee			ld (debug_mark+1),a  
8719 3a 23 87			ld a, (.dmark+2)  
871c 32 67 ee			ld (debug_mark+2),a  
871f 18 03			jr .pastdmark  
8721 ..			.dmark: db "srf"  
8724 f1			.pastdmark: pop af  
8725			endm  
# End of macro DMARK
8725					CALLMONITOR 
8725 cd 6f ee			call debug_vector  
8728				endm  
# End of macro CALLMONITOR
8728				endif 
8728 cd 13 8d			call ishlzero 
872b			;	ld a, l 
872b			;	add h 
872b			;	cp 0 
872b 28 b1			jr z,.sr_fail			; block not found so EOF 
872d			 
872d				; save current address for use by higher level words etc 
872d			 
872d 22 65 ea			ld (store_openaddr),hl 
8730			 
8730			 
8730				; hl contains page number to load 
8730 d1				pop de   ; get storage 
8731 ed 53 70 ea		ld (store_readbuf), de     ; current buffer to load in to 
8735 d5				push de 
8736				if DEBUG_STORESE 
8736					DMARK "srg" 
8736 f5				push af  
8737 3a 4b 87			ld a, (.dmark)  
873a 32 65 ee			ld (debug_mark),a  
873d 3a 4c 87			ld a, (.dmark+1)  
8740 32 66 ee			ld (debug_mark+1),a  
8743 3a 4d 87			ld a, (.dmark+2)  
8746 32 67 ee			ld (debug_mark+2),a  
8749 18 03			jr .pastdmark  
874b ..			.dmark: db "srg"  
874e f1			.pastdmark: pop af  
874f			endm  
# End of macro DMARK
874f					CALLMONITOR 
874f cd 6f ee			call debug_vector  
8752				endm  
# End of macro CALLMONITOR
8752				endif 
8752 cd 87 81			call storage_read_block 
8755			 
8755				; if this a continuation read??? 
8755			 
8755 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8758			 
8758 3e 3f			ld a, STORE_BLOCK_PHY-1 
875a cd ea 8c			call addatohl 
875d 7e				ld a,(hl) 
875e fe 00			cp 0 
8760 28 02			jr z, .markiscont 
8762 3e ff			ld a, 255 
8764			 
8764			.markiscont: 
8764 32 67 ea			ld (store_readcont), a 
8767			 
8767				if DEBUG_STORESE 
8767					DMARK "srC" 
8767 f5				push af  
8768 3a 7c 87			ld a, (.dmark)  
876b 32 65 ee			ld (debug_mark),a  
876e 3a 7d 87			ld a, (.dmark+1)  
8771 32 66 ee			ld (debug_mark+1),a  
8774 3a 7e 87			ld a, (.dmark+2)  
8777 32 67 ee			ld (debug_mark+2),a  
877a 18 03			jr .pastdmark  
877c ..			.dmark: db "srC"  
877f f1			.pastdmark: pop af  
8780			endm  
# End of macro DMARK
8780					CALLMONITOR 
8780 cd 6f ee			call debug_vector  
8783				endm  
# End of macro CALLMONITOR
8783				endif 
8783				; only short reads enabled 
8783			 
8783 3a 6f ea			ld a, (store_longread) 
8786 fe 00			cp 0 
8788 ca 55 88			jp z, .readdone 
878b			 
878b			; TODO if block has no zeros then need to read next block  
878b			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
878b			; check last byte of physical block. 
878b			; if not zero then the next block needs to be loaded 
878b			 
878b			 
878b 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
878e			 
878e 3e 3f			ld a, STORE_BLOCK_PHY-1 
8790 cd ea 8c			call addatohl 
8793				;dec hl 
8793 7e				ld a,(hl) 
8794				if DEBUG_STORESE 
8794					DMARK "sr?" 
8794 f5				push af  
8795 3a a9 87			ld a, (.dmark)  
8798 32 65 ee			ld (debug_mark),a  
879b 3a aa 87			ld a, (.dmark+1)  
879e 32 66 ee			ld (debug_mark+1),a  
87a1 3a ab 87			ld a, (.dmark+2)  
87a4 32 67 ee			ld (debug_mark+2),a  
87a7 18 03			jr .pastdmark  
87a9 ..			.dmark: db "sr?"  
87ac f1			.pastdmark: pop af  
87ad			endm  
# End of macro DMARK
87ad					CALLMONITOR 
87ad cd 6f ee			call debug_vector  
87b0				endm  
# End of macro CALLMONITOR
87b0				endif 
87b0 fe 00			cp 0 
87b2 ca 55 88			jp z, .readdone 
87b5			 
87b5				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87b5			 
87b5 23				inc hl 
87b6			 
87b6 22 70 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87b9			 
87b9 ed 5b 72 ea		ld de, (store_readptr)     ; save the current extent to load 
87bd			 
87bd eb				ex de, hl 
87be			 
87be				; next ext 
87be			 
87be 23				inc hl 
87bf 22 72 ea			ld  (store_readptr), hl     ; save the current extent to load 
87c2			 
87c2				if DEBUG_STORESE 
87c2					DMARK "sF2" 
87c2 f5				push af  
87c3 3a d7 87			ld a, (.dmark)  
87c6 32 65 ee			ld (debug_mark),a  
87c9 3a d8 87			ld a, (.dmark+1)  
87cc 32 66 ee			ld (debug_mark+1),a  
87cf 3a d9 87			ld a, (.dmark+2)  
87d2 32 67 ee			ld (debug_mark+2),a  
87d5 18 03			jr .pastdmark  
87d7 ..			.dmark: db "sF2"  
87da f1			.pastdmark: pop af  
87db			endm  
# End of macro DMARK
87db					CALLMONITOR 
87db cd 6f ee			call debug_vector  
87de				endm  
# End of macro CALLMONITOR
87de				endif 
87de			 
87de				; get and load block 
87de			 
87de cd ba 84			call storage_findnextid 
87e1			 
87e1				if DEBUG_STORESE 
87e1					DMARK "sf2" 
87e1 f5				push af  
87e2 3a f6 87			ld a, (.dmark)  
87e5 32 65 ee			ld (debug_mark),a  
87e8 3a f7 87			ld a, (.dmark+1)  
87eb 32 66 ee			ld (debug_mark+1),a  
87ee 3a f8 87			ld a, (.dmark+2)  
87f1 32 67 ee			ld (debug_mark+2),a  
87f4 18 03			jr .pastdmark  
87f6 ..			.dmark: db "sf2"  
87f9 f1			.pastdmark: pop af  
87fa			endm  
# End of macro DMARK
87fa					CALLMONITOR 
87fa cd 6f ee			call debug_vector  
87fd				endm  
# End of macro CALLMONITOR
87fd				endif 
87fd cd 13 8d			call ishlzero 
8800			;	ld a, l 
8800			;	add h 
8800			;	cp 0 
8800 ca de 86			jp z,.sr_fail			; block not found so EOF 
8803				 
8803				; save current address for use by higher level words etc 
8803			 
8803 22 65 ea			ld (store_openaddr),hl 
8806			 
8806 cd 87 81			call storage_read_block 
8809			 
8809				; on a continuation block, we now have the file id and ext in the middle of the block 
8809				; we need to pull everything back  
8809			 
8809 ed 5b 70 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
880d 2a 70 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8810 23				inc hl 
8811 23				inc hl     ; skip id and ext 
8812 01 40 00			ld bc, STORE_BLOCK_PHY 
8815				if DEBUG_STORESE 
8815					DMARK "SR<" 
8815 f5				push af  
8816 3a 2a 88			ld a, (.dmark)  
8819 32 65 ee			ld (debug_mark),a  
881c 3a 2b 88			ld a, (.dmark+1)  
881f 32 66 ee			ld (debug_mark+1),a  
8822 3a 2c 88			ld a, (.dmark+2)  
8825 32 67 ee			ld (debug_mark+2),a  
8828 18 03			jr .pastdmark  
882a ..			.dmark: db "SR<"  
882d f1			.pastdmark: pop af  
882e			endm  
# End of macro DMARK
882e					CALLMONITOR 
882e cd 6f ee			call debug_vector  
8831				endm  
# End of macro CALLMONITOR
8831				endif 
8831 ed b0			ldir     ; copy data 
8833			 
8833				; move the pointer back and pretend we have a full buffer for next recheck 
8833			 
8833 1b				dec de 
8834 1b				dec de 
8835			 
8835			; TODO do pop below now short circuit loop????? 
8835 c1				pop bc     ; get rid of spare de on stack 
8836				if DEBUG_STORESE 
8836					DMARK "SR>" 
8836 f5				push af  
8837 3a 4b 88			ld a, (.dmark)  
883a 32 65 ee			ld (debug_mark),a  
883d 3a 4c 88			ld a, (.dmark+1)  
8840 32 66 ee			ld (debug_mark+1),a  
8843 3a 4d 88			ld a, (.dmark+2)  
8846 32 67 ee			ld (debug_mark+2),a  
8849 18 03			jr .pastdmark  
884b ..			.dmark: db "SR>"  
884e f1			.pastdmark: pop af  
884f			endm  
# End of macro DMARK
884f					CALLMONITOR 
884f cd 6f ee			call debug_vector  
8852				endm  
# End of macro CALLMONITOR
8852				endif 
8852 c3 e3 86			jp .srext 
8855			 
8855			 
8855			 
8855			 
8855			 
8855			.readdone:		 
8855 e1				pop hl 		 ; return start of data to show as not EOF 
8856 23				inc hl   ; past file id 
8857 23				inc hl   ; past ext 
8858				if DEBUG_STORESE 
8858					DMARK "SRe" 
8858 f5				push af  
8859 3a 6d 88			ld a, (.dmark)  
885c 32 65 ee			ld (debug_mark),a  
885f 3a 6e 88			ld a, (.dmark+1)  
8862 32 66 ee			ld (debug_mark+1),a  
8865 3a 6f 88			ld a, (.dmark+2)  
8868 32 67 ee			ld (debug_mark+2),a  
886b 18 03			jr .pastdmark  
886d ..			.dmark: db "SRe"  
8870 f1			.pastdmark: pop af  
8871			endm  
# End of macro DMARK
8871					CALLMONITOR 
8871 cd 6f ee			call debug_vector  
8874				endm  
# End of macro CALLMONITOR
8874				endif 
8874 c9					ret 
8875			 
8875			 
8875			 
8875			; 
8875			; Append File 
8875			; 
8875			; hl - file id to locate 
8875			; de - pointer to (multi block) string to write 
8875			 
8875			.sa_notfound: 
8875 d1				pop de 
8876 c9				ret 
8877			 
8877			 
8877			storage_append: 
8877				; hl -  file id to append to 
8877				; de - string to append 
8877			 
8877 d5				push de 
8878				 
8878				if DEBUG_STORESE 
8878					DMARK "AP1" 
8878 f5				push af  
8879 3a 8d 88			ld a, (.dmark)  
887c 32 65 ee			ld (debug_mark),a  
887f 3a 8e 88			ld a, (.dmark+1)  
8882 32 66 ee			ld (debug_mark+1),a  
8885 3a 8f 88			ld a, (.dmark+2)  
8888 32 67 ee			ld (debug_mark+2),a  
888b 18 03			jr .pastdmark  
888d ..			.dmark: db "AP1"  
8890 f1			.pastdmark: pop af  
8891			endm  
# End of macro DMARK
8891					CALLMONITOR 
8891 cd 6f ee			call debug_vector  
8894				endm  
# End of macro CALLMONITOR
8894				endif 
8894			 
8894 7d				ld a, l 
8895 32 68 ea			ld (store_tmpid), a 
8898			 
8898				; get file header  
8898			 
8898 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
889a 3a 68 ea			ld a, (store_tmpid) 
889d 5f				ld e, a 
889e			 
889e 21 40 00				ld hl, STORE_BLOCK_PHY 
88a1 cd ba 84				call storage_findnextid 
88a4			 
88a4 cd 13 8d			call ishlzero 
88a7 28 cc			jr z, .sa_notfound 
88a9			 
88a9 22 5f ea			ld (store_tmppageid), hl 
88ac			 
88ac				; TODO handle file id not found 
88ac			 
88ac				if DEBUG_STORESE 
88ac					DMARK "AP2" 
88ac f5				push af  
88ad 3a c1 88			ld a, (.dmark)  
88b0 32 65 ee			ld (debug_mark),a  
88b3 3a c2 88			ld a, (.dmark+1)  
88b6 32 66 ee			ld (debug_mark+1),a  
88b9 3a c3 88			ld a, (.dmark+2)  
88bc 32 67 ee			ld (debug_mark+2),a  
88bf 18 03			jr .pastdmark  
88c1 ..			.dmark: db "AP2"  
88c4 f1			.pastdmark: pop af  
88c5			endm  
# End of macro DMARK
88c5					CALLMONITOR 
88c5 cd 6f ee			call debug_vector  
88c8				endm  
# End of macro CALLMONITOR
88c8				endif 
88c8			 
88c8				; update file extent count 
88c8			 
88c8 11 74 ea			ld de, store_page 
88cb			 
88cb cd 87 81			call storage_read_block 
88ce			 
88ce				if DEBUG_STORESE 
88ce					DMARK "AP3" 
88ce f5				push af  
88cf 3a e3 88			ld a, (.dmark)  
88d2 32 65 ee			ld (debug_mark),a  
88d5 3a e4 88			ld a, (.dmark+1)  
88d8 32 66 ee			ld (debug_mark+1),a  
88db 3a e5 88			ld a, (.dmark+2)  
88de 32 67 ee			ld (debug_mark+2),a  
88e1 18 03			jr .pastdmark  
88e3 ..			.dmark: db "AP3"  
88e6 f1			.pastdmark: pop af  
88e7			endm  
# End of macro DMARK
88e7					CALLMONITOR 
88e7 cd 6f ee			call debug_vector  
88ea				endm  
# End of macro CALLMONITOR
88ea				endif 
88ea			;	ld (store_tmppageid), hl 
88ea			 
88ea 3a 76 ea			ld a, (store_page+2) 
88ed 3c				inc a 
88ee 32 76 ea			ld (store_page+2), a 
88f1 32 67 ea			ld (store_tmpext), a 
88f4				 
88f4				if DEBUG_STORESE 
88f4					DMARK "AP3" 
88f4 f5				push af  
88f5 3a 09 89			ld a, (.dmark)  
88f8 32 65 ee			ld (debug_mark),a  
88fb 3a 0a 89			ld a, (.dmark+1)  
88fe 32 66 ee			ld (debug_mark+1),a  
8901 3a 0b 89			ld a, (.dmark+2)  
8904 32 67 ee			ld (debug_mark+2),a  
8907 18 03			jr .pastdmark  
8909 ..			.dmark: db "AP3"  
890c f1			.pastdmark: pop af  
890d			endm  
# End of macro DMARK
890d					CALLMONITOR 
890d cd 6f ee			call debug_vector  
8910				endm  
# End of macro CALLMONITOR
8910				endif 
8910 2a 5f ea			ld hl, (store_tmppageid) 
8913 11 74 ea			ld de, store_page 
8916 cd ec 81			call storage_write_block 
8919			 
8919				; find free block 
8919			 
8919 11 00 00			ld de, 0			 ; file extent to locate 
891c			 
891c 21 40 00				ld hl, STORE_BLOCK_PHY 
891f cd ba 84				call storage_findnextid 
8922 cd 13 8d			call ishlzero 
8925 ca 75 88			jp z, .sa_notfound 
8928			 
8928					; TODO handle no space left 
8928					 
8928 22 5f ea				ld (store_tmppageid), hl 
892b			 
892b				if DEBUG_STORESE 
892b					DMARK "AP4" 
892b f5				push af  
892c 3a 40 89			ld a, (.dmark)  
892f 32 65 ee			ld (debug_mark),a  
8932 3a 41 89			ld a, (.dmark+1)  
8935 32 66 ee			ld (debug_mark+1),a  
8938 3a 42 89			ld a, (.dmark+2)  
893b 32 67 ee			ld (debug_mark+2),a  
893e 18 03			jr .pastdmark  
8940 ..			.dmark: db "AP4"  
8943 f1			.pastdmark: pop af  
8944			endm  
# End of macro DMARK
8944					CALLMONITOR 
8944 cd 6f ee			call debug_vector  
8947				endm  
# End of macro CALLMONITOR
8947				endif 
8947					; init the buffer with zeros so we can id if the buffer is full or not 
8947			 
8947 e5					push hl 
8948 c5					push bc 
8949			 
8949 21 74 ea				ld hl, store_page 
894c 06 40				ld b, STORE_BLOCK_PHY 
894e 3e 00				ld a, 0 
8950 77			.zeroblock:	ld (hl), a 
8951 23					inc hl 
8952 10 fc				djnz .zeroblock 
8954			 
8954 c1					pop bc 
8955 e1					pop hl 
8956			 
8956					; construct block 
8956			 
8956 3a 68 ea				ld a, (store_tmpid) 
8959 32 74 ea				ld (store_page), a   ; file id 
895c 3a 67 ea				ld a, (store_tmpext)   ; extent for this block 
895f 32 75 ea				ld (store_page+1), a 
8962			 
8962 e1					pop hl    ; get string to write 
8963 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8965 11 76 ea				ld de, store_page+2 
8968			 
8968				if DEBUG_STORESE 
8968					DMARK "AP5" 
8968 f5				push af  
8969 3a 7d 89			ld a, (.dmark)  
896c 32 65 ee			ld (debug_mark),a  
896f 3a 7e 89			ld a, (.dmark+1)  
8972 32 66 ee			ld (debug_mark+1),a  
8975 3a 7f 89			ld a, (.dmark+2)  
8978 32 67 ee			ld (debug_mark+2),a  
897b 18 03			jr .pastdmark  
897d ..			.dmark: db "AP5"  
8980 f1			.pastdmark: pop af  
8981			endm  
# End of macro DMARK
8981					CALLMONITOR 
8981 cd 6f ee			call debug_vector  
8984				endm  
# End of macro CALLMONITOR
8984				endif 
8984			 
8984			 
8984			 
8984					; fill buffer with data until end of string or full block 
8984			 
8984 7e			.appd:		ld a, (hl) 
8985 12					ld (de), a 
8986 fe 00				cp 0 
8988 28 04				jr z, .appdone 
898a 23					inc hl 
898b 13					inc de 
898c 10 f6				djnz .appd 
898e			 
898e e5			.appdone:	push hl		 	; save current source in case we need to go around again 
898f f5					push af   		; save last byte dumped 
8990			 
8990			 
8990 2a 5f ea			ld hl, (store_tmppageid) 
8993 11 74 ea			ld de, store_page 
8996				if DEBUG_STORESE 
8996					DMARK "AP6" 
8996 f5				push af  
8997 3a ab 89			ld a, (.dmark)  
899a 32 65 ee			ld (debug_mark),a  
899d 3a ac 89			ld a, (.dmark+1)  
89a0 32 66 ee			ld (debug_mark+1),a  
89a3 3a ad 89			ld a, (.dmark+2)  
89a6 32 67 ee			ld (debug_mark+2),a  
89a9 18 03			jr .pastdmark  
89ab ..			.dmark: db "AP6"  
89ae f1			.pastdmark: pop af  
89af			endm  
# End of macro DMARK
89af					CALLMONITOR 
89af cd 6f ee			call debug_vector  
89b2				endm  
# End of macro CALLMONITOR
89b2				endif 
89b2 cd ec 81				call storage_write_block 
89b5			 
89b5			 
89b5				; was that a full block of data written? 
89b5				; any more to write out? 
89b5			 
89b5				; if yes then set vars and jump to start of function again 
89b5			 
89b5 f1					pop af 
89b6 d1					pop de 
89b7			 
89b7 fe 00				cp 0		 ; no, string was fully written 
89b9 c8					ret z 
89ba			 
89ba					; setup vars for next cycle 
89ba			 
89ba 3a 68 ea				ld a, (store_tmpid) 
89bd 6f					ld l, a 
89be 26 00				ld h, 0 
89c0			 
89c0 c3 77 88			 	jp storage_append	 ; yes, need to write out some more 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			if DEBUG_STORECF 
89c3			storageput:	 
89c3					ret 
89c3			storageread: 
89c3					ld hl, store_page 
89c3					ld b, 200 
89c3					ld a,0 
89c3			.src:		ld (hl),a 
89c3					inc hl 
89c3					djnz .src 
89c3					 
89c3			 
89c3					ld de, 0 
89c3					ld bc, 1 
89c3					ld hl, store_page 
89c3					call cfRead 
89c3			 
89c3				call cfGetError 
89c3				ld hl,scratch 
89c3				call hexout 
89c3				ld hl, scratch+2 
89c3				ld a, 0 
89c3				ld (hl),a 
89c3				ld de, scratch 
89c3				ld a,display_row_1 
89c3				call str_at_display 
89c3				call update_display 
89c3			 
89c3					ld hl, store_page 
89c3					ld (os_cur_ptr),hl 
89c3			 
89c3					ret 
89c3			endif 
89c3			 
89c3			 
89c3			; Clear out the main buffer store (used to remove junk before writing a new block) 
89c3			 
89c3			storage_clear_page: 
89c3 e5				push hl 
89c4 d5				push de 
89c5 c5				push bc 
89c6 21 74 ea			ld hl, store_page 
89c9 3e 00			ld a, 0 
89cb 77				ld (hl), a 
89cc			 
89cc 11 75 ea			ld de, store_page+1 
89cf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89d2			 
89d2 ed b0			ldir 
89d4				 
89d4 c1				pop bc 
89d5 d1				pop de 
89d6 e1				pop hl 
89d7 c9				ret 
89d8			 
89d8			; eof 
# End of file firmware_storage.asm
89d8			  
89d8			; support routines for above hardware abstraction layer  
89d8			  
89d8			include "firmware_general.asm"        ; general support functions  
89d8			 
89d8			; word look up 
89d8			 
89d8			; in 
89d8			; a is the index 
89d8			; hl is pointer start of array 
89d8			; 
89d8			; returns 
89d8			; hl to the word 
89d8			; 
89d8			 
89d8			table_lookup:  
89d8 d5					push de 
89d9 eb					ex de, hl 
89da			 
89da 6f					ld l, a 
89db 26 00				ld h, 0 
89dd 29					add hl, hl 
89de 19					add hl, de 
89df 7e					ld a, (hl) 
89e0 23					inc hl 
89e1 66					ld h,(hl) 
89e2 6f					ld l, a 
89e3			 
89e3 d1					pop de 
89e4 c9					ret 
89e5			 
89e5			; Delay loops 
89e5			 
89e5			 
89e5			 
89e5			aDelayInMS: 
89e5 c5				push bc 
89e6 47				ld b,a 
89e7			msdelay: 
89e7 c5				push bc 
89e8				 
89e8			 
89e8 01 41 00			ld bc,041h 
89eb cd 03 8a			call delayloop 
89ee c1				pop bc 
89ef 05				dec b 
89f0 20 f5			jr nz,msdelay 
89f2			 
89f2			;if CPU_CLOCK_8MHZ 
89f2			;msdelay8: 
89f2			;	push bc 
89f2			;	 
89f2			; 
89f2			;	ld bc,041h 
89f2			;	call delayloop 
89f2			;	pop bc 
89f2			;	dec b 
89f2			;	jr nz,msdelay8 
89f2			;endif 
89f2			 
89f2			 
89f2 c1				pop bc 
89f3 c9				ret 
89f4			 
89f4			 
89f4			delay250ms: 
89f4				;push de 
89f4 01 00 40			ld bc, 04000h 
89f7 c3 03 8a			jp delayloop 
89fa			delay500ms: 
89fa				;push de 
89fa 01 00 80			ld bc, 08000h 
89fd c3 03 8a			jp delayloop 
8a00			delay1s: 
8a00				;push bc 
8a00			   ; Clobbers A, d and e 
8a00 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8a03			delayloop: 
8a03 c5			    push bc 
8a04			 
8a04			if BASE_CPM 
8a04				ld bc, CPM_DELAY_TUNE 
8a04			.cpmloop: 
8a04				push bc 
8a04			 
8a04			endif 
8a04			 
8a04			 
8a04			 
8a04			delayloopi: 
8a04			;	push bc 
8a04			;.dl: 
8a04 cb 47		    bit     0,a    	; 8 
8a06 cb 47		    bit     0,a    	; 8 
8a08 cb 47		    bit     0,a    	; 8 
8a0a e6 ff		    and     255  	; 7 
8a0c 0b			    dec     bc      	; 6 
8a0d 79			    ld      a,c     	; 4 
8a0e b0			    or      b     	; 4 
8a0f c2 04 8a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a12			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a12				;pop de 
8a12			;pop bc 
8a12			 
8a12			if BASE_CPM 
8a12				pop bc 
8a12				 
8a12			    dec     bc      	; 6 
8a12			    ld      a,c     	; 4 
8a12			    or      b     	; 4 
8a12			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a12				 
8a12			 
8a12			endif 
8a12			;if CPU_CLOCK_8MHZ 
8a12			;    pop bc 
8a12			;    push bc 
8a12			;.dl8: 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    and     255  	; 7 
8a12			;    dec     bc      	; 6 
8a12			;    ld      a,c     	; 4 
8a12			;    or      b     	; 4 
8a12			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a12			;endif 
8a12			 
8a12			;if CPU_CLOCK_10MHZ 
8a12			;    pop bc 
8a12			;    push bc 
8a12			;.dl8: 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    and     255  	; 7 
8a12			;    dec     bc      	; 6 
8a12			;    ld      a,c     	; 4 
8a12			;    or      b     	; 4 
8a12			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a12			;endif 
8a12 c1			    pop bc 
8a13			 
8a13 c9				ret 
8a14			 
8a14			 
8a14			 
8a14			; eof 
# End of file firmware_general.asm
8a14			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a14			; display routines that use the physical hardware abstraction layer 
8a14			 
8a14			 
8a14			; Display an activity indicator 
8a14			; Each call returns the new char pointed to in hl 
8a14			 
8a14			active: 
8a14 3a c0 eb			ld a, (display_active) 
8a17 fe 06			cp 6 
8a19			 
8a19 20 02			jr nz, .sne 
8a1b				; gone past the last one reset sequence 
8a1b 3e ff			ld a, 255 
8a1d			 
8a1d			.sne:   
8a1d				; get the next char in seq 
8a1d 3c				inc a 
8a1e 32 c0 eb			ld (display_active), a 
8a21			 
8a21				; look up the string in the table 
8a21 21 38 8a			ld hl, actseq 
8a24 cb 27			sla a 
8a26 cd ea 8c			call addatohl 
8a29 cd f8 9d			call loadwordinhl 
8a2c			 
8a2c				; forth will write the to string when pushing so move from rom to ram 
8a2c			 
8a2c 11 c1 eb			ld de, display_active+1 
8a2f 01 02 00			ld bc, 2 
8a32 ed b0			ldir 
8a34			 
8a34 21 c1 eb			ld hl, display_active+1 
8a37 c9				ret 
8a38				 
8a38				 
8a38			 
8a38			 
8a38			;db "|/-\|-\" 
8a38			 
8a38			actseq: 
8a38			 
8a38 46 8a		dw spin0 
8a3a 48 8a		dw spin1 
8a3c 4a 8a		dw spin2 
8a3e 4c 8a		dw spin3 
8a40 4a 8a		dw spin2 
8a42 48 8a		dw spin1 
8a44 46 8a		dw spin0 
8a46			 
8a46 .. 00		spin0: db " ", 0 
8a48 .. 00		spin1: db "-", 0 
8a4a .. 00		spin2: db "+", 0 
8a4c .. 00		spin3: db "#", 0 
8a4e			 
8a4e			 
8a4e			; information window 
8a4e			 
8a4e			; pass hl with 1st string to display 
8a4e			; pass de with 2nd string to display 
8a4e			 
8a4e			info_panel: 
8a4e e5				push hl 
8a4f			 
8a4f 2a c6 eb			ld hl, (display_fb_active) 
8a52 e5				push hl    ; future de destination 
8a53 21 ab ed				ld hl, display_fb0 
8a56 22 c6 eb				ld (display_fb_active), hl 
8a59			 
8a59			;	call clear_display 
8a59			 
8a59				if BASE_CPM 
8a59				ld a, '.' 
8a59				else 
8a59 3e a5			ld a, 165 
8a5b				endif 
8a5b cd c2 8a			call fill_display 
8a5e			 
8a5e			 
8a5e 3e 55			ld a, display_row_3 + 5 
8a60 cd d0 8a			call str_at_display 
8a63			 
8a63 e1				pop hl 
8a64 d1				pop de 
8a65			 
8a65 e5				push hl 
8a66			 
8a66			 
8a66 3e 2d			ld a, display_row_2 + 5 
8a68 cd d0 8a			call str_at_display 
8a6b			 
8a6b			 
8a6b cd e0 8a			call update_display 
8a6e cd fd 99			call next_page_prompt 
8a71 cd bd 8a			call clear_display 
8a74			 
8a74				 
8a74 21 0a ed				ld hl, display_fb1 
8a77 22 c6 eb				ld (display_fb_active), hl 
8a7a cd e0 8a			call update_display 
8a7d			 
8a7d e1				pop hl 
8a7e			 
8a7e c9				ret 
8a7f			 
8a7f			 
8a7f			 
8a7f			 
8a7f			; TODO windowing? 
8a7f			 
8a7f			; TODO scroll line up 
8a7f			 
8a7f			scroll_up: 
8a7f			 
8a7f e5				push hl 
8a80 d5				push de 
8a81 c5				push bc 
8a82			 
8a82				; get frame buffer  
8a82			 
8a82 2a c6 eb			ld hl, (display_fb_active) 
8a85 e5				push hl    ; future de destination 
8a86			 
8a86 11 28 00			ld  de, display_cols 
8a89 19				add hl, de 
8a8a			 
8a8a d1				pop de 
8a8b			 
8a8b				;ex de, hl 
8a8b 01 9f 00			ld bc, display_fb_len -1  
8a8e			;if DEBUG_FORTH_WORDS 
8a8e			;	DMARK "SCL" 
8a8e			;	CALLMONITOR 
8a8e			;endif	 
8a8e ed b0			ldir 
8a90			 
8a90				; wipe bottom row 
8a90			 
8a90			 
8a90 2a c6 eb			ld hl, (display_fb_active) 
8a93 11 a0 00			ld de, display_cols*display_rows 
8a96 19				add hl, de 
8a97 06 28			ld b, display_cols 
8a99 3e 20			ld a, ' ' 
8a9b			.scwipe: 
8a9b 77				ld (hl), a 
8a9c 2b				dec hl 
8a9d 10 fc			djnz .scwipe 
8a9f			 
8a9f				;pop hl 
8a9f			 
8a9f c1				pop bc 
8aa0 d1				pop de 
8aa1 e1				pop hl 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			 
8aa3			;scroll_upo: 
8aa3			;	ld de, display_row_1 
8aa3			 ;	ld hl, display_row_2 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			;	ld de, display_row_2 
8aa3			 ;	ld hl, display_row_3 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			;	ld de, display_row_3 
8aa3			 ;	ld hl, display_row_4 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			 
8aa3			; TODO clear row 4 
8aa3			 
8aa3			;	ret 
8aa3			 
8aa3				 
8aa3			scroll_down: 
8aa3			 
8aa3 e5				push hl 
8aa4 d5				push de 
8aa5 c5				push bc 
8aa6			 
8aa6				; get frame buffer  
8aa6			 
8aa6 2a c6 eb			ld hl, (display_fb_active) 
8aa9			 
8aa9 11 9f 00			ld de, display_fb_len - 1 
8aac 19				add hl, de 
8aad			 
8aad e5			push hl    ; future de destination 
8aae			 
8aae 11 28 00			ld  de, display_cols 
8ab1 ed 52			sbc hl, de 
8ab3			 
8ab3			 
8ab3 d1				pop de 
8ab4			 
8ab4			;	ex de, hl 
8ab4 01 9f 00			ld bc, display_fb_len -1  
8ab7			 
8ab7			 
8ab7				 
8ab7			 
8ab7 ed b0			ldir 
8ab9			 
8ab9				; wipe bottom row 
8ab9			 
8ab9			 
8ab9			;	ld hl, (display_fb_active) 
8ab9			;;	ld de, display_cols*display_rows 
8ab9			;;	add hl, de 
8ab9			;	ld b, display_cols 
8ab9			;	ld a, ' ' 
8ab9			;.scwiped: 
8ab9			;	ld (hl), a 
8ab9			;	dec hl 
8ab9			;	djnz .scwiped 
8ab9			 
8ab9				;pop hl 
8ab9			 
8ab9 c1				pop bc 
8aba d1				pop de 
8abb e1				pop hl 
8abc			 
8abc c9				ret 
8abd			;scroll_down: 
8abd			;	ld de, display_row_4 
8abd			;	ld hl, display_row_3 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;	ld de, display_row_3 
8abd			; 	ld hl, display_row_2 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;	ld de, display_row_2 
8abd			;	ld hl, display_row_1 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;;; TODO clear row 1 
8abd			;	ret 
8abd			 
8abd			 
8abd			 
8abd			 
8abd			 
8abd			; clear active frame buffer 
8abd			 
8abd			clear_display: 
8abd 3e 20			ld a, ' ' 
8abf c3 c2 8a			jp fill_display 
8ac2			 
8ac2			; fill active frame buffer with a char in A 
8ac2			 
8ac2			fill_display: 
8ac2 06 a0			ld b,display_fb_len 
8ac4 2a c6 eb			ld hl, (display_fb_active) 
8ac7 77			.fd1:	ld (hl),a 
8ac8 23				inc hl 
8ac9 10 fc			djnz .fd1 
8acb 23				inc hl 
8acc 3e 00			ld a,0 
8ace 77				ld (hl),a 
8acf			 
8acf			 
8acf c9				ret 
8ad0			; Write string (DE) at pos (A) to active frame buffer 
8ad0			 
8ad0 2a c6 eb		str_at_display:    ld hl,(display_fb_active) 
8ad3 06 00					ld b,0 
8ad5 4f					ld c,a 
8ad6 09					add hl,bc 
8ad7 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ad8 b7			            OR   A              ;Null terminator? 
8ad9 c8			            RET  Z              ;Yes, so finished 
8ada 77					ld (hl),a 
8adb 23				inc hl 
8adc 13			            INC  DE             ;Point to next character 
8add 18 f8		            JR   .sad1     ;Repeat 
8adf c9					ret 
8ae0			 
8ae0			; using current frame buffer write to physical display 
8ae0			 
8ae0			update_display: 
8ae0 e5				push hl 
8ae1 2a c6 eb			ld hl, (display_fb_active) 
8ae4 cd f6 de			call write_display 
8ae7 e1				pop hl 
8ae8 c9				ret 
8ae9			 
8ae9			; TODO scrolling 
8ae9			 
8ae9			 
8ae9			; move cursor right one char 
8ae9			cursor_right: 
8ae9			 
8ae9				; TODO shift right 
8ae9				; TODO if beyond max col 
8ae9				; TODO       cursor_next_line 
8ae9			 
8ae9 c9				ret 
8aea			 
8aea			 
8aea			cursor_next_line: 
8aea				; TODO first char 
8aea				; TODO line down 
8aea				; TODO if past last row 
8aea				; TODO    scroll up 
8aea			 
8aea c9				ret 
8aeb			 
8aeb			cursor_left: 
8aeb				; TODO shift left 
8aeb				; TODO if beyond left  
8aeb				; TODO     cursor prev line 
8aeb				 
8aeb c9				ret 
8aec			 
8aec			cursor_prev_line: 
8aec				; TODO last char 
8aec				; TODO line up 
8aec				; TODO if past first row 
8aec				; TODO   scroll down 
8aec			 
8aec c9				ret 
8aed			 
8aed			 
8aed			cout: 
8aed				; A - char 
8aed c9				ret 
8aee			 
8aee			 
8aee			; Display a menu and allow item selection (optional toggle items) 
8aee			; 
8aee			; format: 
8aee			; hl pointer to word array with zero term for items 
8aee			; e.g.    db item1 
8aee			;         db .... 
8aee			;         db 0 
8aee			; 
8aee			; a = starting menu item  
8aee			; 
8aee			; de = pointer item toggle array   (todo) 
8aee			; 
8aee			; returns item selected in a 1-... 
8aee			; returns 0 if back button pressed 
8aee			; 
8aee			; NOTE: Uses system frame buffer to display 
8aee			; 
8aee			; LEFT, Q = go back 
8aee			; RIGHT, SPACE, CR = select 
8aee			; UP, A - Up 
8aee			; DOWN, Z - Down 
8aee			 
8aee			 
8aee			 
8aee			 
8aee			 
8aee			menu: 
8aee			 
8aee					; keep array pointer 
8aee			 
8aee 22 6d ea				ld (store_tmp1), hl 
8af1 32 6b ea				ld (store_tmp2), a 
8af4			 
8af4					; check for key bounce 
8af4			 
8af4			if BASE_KEV 
8af4			 
8af4			.mbounce:	call cin 
8af4					cp 0 
8af4					jr nz, .mbounce 
8af4			endif 
8af4					; for ease use ex 
8af4			 
8af4					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8af4 21 ab ed				ld hl, display_fb0 
8af7 22 c6 eb				ld (display_fb_active), hl 
8afa			 
8afa cd bd 8a		.mloop:		call clear_display 
8afd cd e0 8a				call update_display 
8b00			 
8b00					; draw selection id '>' at 1 
8b00			 
8b00					; init start of list display 
8b00			 
8b00 3e 05				ld a, 5 
8b02 32 69 ea				ld (store_tmp3), a   ; display row count 
8b05 3a 6b ea				ld a,( store_tmp2) 
8b08 32 6c ea				ld (store_tmp2+1), a   ; display item count 
8b0b			 
8b0b					 
8b0b			.mitem:	 
8b0b			 
8b0b			 
8b0b 3a 6c ea				ld a,(store_tmp2+1) 
8b0e 6f					ld l, a 
8b0f 26 00				ld h, 0 
8b11 29					add hl, hl 
8b12 ed 5b 6d ea			ld de, (store_tmp1) 
8b16 19					add hl, de 
8b17 7e					ld a, (hl) 
8b18 23					inc hl 
8b19 66					ld h,(hl) 
8b1a 6f					ld l, a 
8b1b			 
8b1b cd 13 8d				call ishlzero 
8b1e 28 1a				jr z, .mdone 
8b20			 
8b20 eb					ex de, hl 
8b21 3a 69 ea				ld a, (store_tmp3) 
8b24 cd d0 8a				call str_at_display 
8b27					 
8b27			 
8b27					; next item 
8b27 3a 6c ea				ld a, (store_tmp2+1) 
8b2a 3c					inc a 
8b2b 32 6c ea				ld (store_tmp2+1), a   ; display item count 
8b2e			 
8b2e			 		; next row 
8b2e			 
8b2e 3a 69 ea				ld a, (store_tmp3) 
8b31 c6 28				add display_cols 
8b33 32 69 ea				ld (store_tmp3), a 
8b36			 
8b36					; at end of screen? 
8b36			 
8b36 fe 10				cp display_rows*4 
8b38 20 d1				jr nz, .mitem 
8b3a			 
8b3a			 
8b3a			.mdone: 
8b3a cd 13 8d				call ishlzero 
8b3d 28 08				jr z, .nodn 
8b3f			 
8b3f 3e 78				ld a, display_row_4 
8b41 11 c0 8b				ld de, .mdown 
8b44 cd d0 8a				call str_at_display 
8b47			 
8b47					; draw options to fill the screens with active item on line 1 
8b47					; if current option is 2 or more then display ^ in top 
8b47			 
8b47 3a 6b ea		.nodn:		ld a, (store_tmp2) 
8b4a fe 00				cp 0 
8b4c 28 08				jr z, .noup 
8b4e			 
8b4e 3e 00				ld a, 0 
8b50 11 be 8b				ld de, .mup 
8b53 cd d0 8a				call str_at_display 
8b56			 
8b56 3e 02		.noup:		ld a, 2 
8b58 11 bc 8b				ld de, .msel 
8b5b cd d0 8a				call str_at_display 
8b5e			 
8b5e					; if current option + 1 is not null then display V in bottom 
8b5e					; get key 
8b5e cd e0 8a				call update_display 
8b61			 
8b61			 
8b61					; handle key 
8b61			 
8b61 cd 82 df				call cin_wait 
8b64			 
8b64 fe 05				cp KEY_UP 
8b66 28 2b				jr z, .mgoup 
8b68 fe 61				cp 'a' 
8b6a 28 27				jr z, .mgoup 
8b6c fe 0a				cp KEY_DOWN 
8b6e 28 32				jr z, .mgod 
8b70 fe 7a				cp 'z' 
8b72 28 2e				jr z, .mgod 
8b74 fe 20				cp ' ' 
8b76 28 34				jr z, .goend 
8b78 fe 0c				cp KEY_RIGHT 
8b7a 28 30				jr z, .goend 
8b7c fe 0d				cp KEY_CR 
8b7e 28 2c				jr z, .goend 
8b80 fe 71				cp 'q' 
8b82 28 0b				jr z, .goback 
8b84			 
8b84 fe 0b				cp KEY_LEFT 
8b86 28 07				jr z, .goback 
8b88 fe 08				cp KEY_BS 
8b8a 28 03				jr z, .goback 
8b8c c3 fa 8a				jp .mloop 
8b8f			 
8b8f			.goback: 
8b8f 3e 00			ld a, 0 
8b91 18 1d			jr .goend2 
8b93			 
8b93				; move up one 
8b93			.mgoup: 
8b93 3a 6b ea				ld a, (store_tmp2) 
8b96 fe 00				cp 0 
8b98 ca fa 8a				jp z, .mloop 
8b9b 3d					dec a 
8b9c 32 6b ea				ld (store_tmp2), a 
8b9f c3 fa 8a				jp .mloop 
8ba2			 
8ba2				; move down one 
8ba2			.mgod: 
8ba2 3a 6b ea				ld a, (store_tmp2) 
8ba5 3c					inc a 
8ba6 32 6b ea				ld (store_tmp2), a 
8ba9 c3 fa 8a				jp .mloop 
8bac			 
8bac			 
8bac			.goend: 
8bac					; get selected item number 
8bac			 
8bac 3a 6b ea				ld a, (store_tmp2) 
8baf 3c					inc a 
8bb0			 
8bb0			.goend2: 
8bb0 f5					push af 
8bb1			 
8bb1					; restore active fb 
8bb1					; TODO BUG assumes fb1 
8bb1			 
8bb1 21 0a ed				ld hl, display_fb1 
8bb4 22 c6 eb				ld (display_fb_active), hl 
8bb7			 
8bb7					; restore main regs 
8bb7			 
8bb7			 
8bb7 cd e0 8a				call update_display 
8bba			 
8bba f1					pop af 
8bbb			 
8bbb c9				ret 
8bbc			 
8bbc .. 00		.msel:   db ">",0 
8bbe .. 00		.mup:   db "^",0 
8bc0 .. 00		.mdown:   db "v",0 
8bc2			 
8bc2			 
8bc2			; eof 
8bc2			 
# End of file firmware_display.asm
8bc2			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bc2			; random number generators 
8bc2			 
8bc2			 
8bc2			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bc2			 
8bc2			 
8bc2			;-----> Generate a random number 
8bc2			; output a=answer 0<=a<=255 
8bc2			; all registers are preserved except: af 
8bc2			random: 
8bc2 e5			        push    hl 
8bc3 d5			        push    de 
8bc4 2a a5 eb		        ld      hl,(randData) 
8bc7 ed 5f		        ld      a,r 
8bc9 57			        ld      d,a 
8bca 5e			        ld      e,(hl) 
8bcb 19			        add     hl,de 
8bcc 85			        add     a,l 
8bcd ac			        xor     h 
8bce 22 a5 eb		        ld      (randData),hl 
8bd1 d1			        pop     de 
8bd2 e1			        pop     hl 
8bd3 c9			        ret 
8bd4			 
8bd4			 
8bd4			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bd4			 
8bd4			 
8bd4			 
8bd4			;------LFSR------ 
8bd4			;James Montelongo 
8bd4			;optimized by Spencer Putt 
8bd4			;out: 
8bd4			; a = 8 bit random number 
8bd4			RandLFSR: 
8bd4 21 ab eb		        ld hl,LFSRSeed+4 
8bd7 5e			        ld e,(hl) 
8bd8 23			        inc hl 
8bd9 56			        ld d,(hl) 
8bda 23			        inc hl 
8bdb 4e			        ld c,(hl) 
8bdc 23			        inc hl 
8bdd 7e			        ld a,(hl) 
8bde 47			        ld b,a 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed cb 13		        rl e  
8bef cb 12			rl d 
8bf1 cb 11		        rl c  
8bf3 17				rla 
8bf4 67			        ld h,a 
8bf5 cb 13		        rl e  
8bf7 cb 12			rl d 
8bf9 cb 11		        rl c  
8bfb 17				rla 
8bfc a8			        xor b 
8bfd cb 13		        rl e  
8bff cb 12			rl d 
8c01 ac			        xor h 
8c02 a9			        xor c 
8c03 aa			        xor d 
8c04 21 ad eb		        ld hl,LFSRSeed+6 
8c07 11 ae eb		        ld de,LFSRSeed+7 
8c0a 01 07 00		        ld bc,7 
8c0d ed b8		        lddr 
8c0f 12			        ld (de),a 
8c10 c9			        ret 
8c11			 
8c11			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c11			 
8c11			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c11			 
8c11			 
8c11			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c11			 
8c11			prng16: 
8c11			;Inputs: 
8c11			;   (seed1) contains a 16-bit seed value 
8c11			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c11			;Outputs: 
8c11			;   HL is the result 
8c11			;   BC is the result of the LCG, so not that great of quality 
8c11			;   DE is preserved 
8c11			;Destroys: 
8c11			;   AF 
8c11			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c11			;160cc 
8c11			;26 bytes 
8c11 2a 9f eb		    ld hl,(seed1) 
8c14 44			    ld b,h 
8c15 4d			    ld c,l 
8c16 29			    add hl,hl 
8c17 29			    add hl,hl 
8c18 2c			    inc l 
8c19 09			    add hl,bc 
8c1a 22 9f eb		    ld (seed1),hl 
8c1d 2a 9d eb		    ld hl,(seed2) 
8c20 29			    add hl,hl 
8c21 9f			    sbc a,a 
8c22 e6 2d		    and %00101101 
8c24 ad			    xor l 
8c25 6f			    ld l,a 
8c26 22 9d eb		    ld (seed2),hl 
8c29 09			    add hl,bc 
8c2a c9			    ret 
8c2b			 
8c2b			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c2b			 
8c2b			rand32: 
8c2b			;Inputs: 
8c2b			;   (seed1_0) holds the lower 16 bits of the first seed 
8c2b			;   (seed1_1) holds the upper 16 bits of the first seed 
8c2b			;   (seed2_0) holds the lower 16 bits of the second seed 
8c2b			;   (seed2_1) holds the upper 16 bits of the second seed 
8c2b			;   **NOTE: seed2 must be non-zero 
8c2b			;Outputs: 
8c2b			;   HL is the result 
8c2b			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c2b			;Destroys: 
8c2b			;   AF 
8c2b			;Tested and passes all CAcert tests 
8c2b			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c2b			;it has a period of 18,446,744,069,414,584,320 
8c2b			;roughly 18.4 quintillion. 
8c2b			;LFSR taps: 0,2,6,7  = 11000101 
8c2b			;291cc 
8c2b			;seed1_0=$+1 
8c2b			;    ld hl,12345 
8c2b			;seed1_1=$+1 
8c2b			;    ld de,6789 
8c2b			;    ld b,h 
8c2b			;    ld c,l 
8c2b			;    add hl,hl \ rl e \ rl d 
8c2b			;    add hl,hl \ rl e \ rl d 
8c2b			;    inc l 
8c2b			;    add hl,bc 
8c2b			;    ld (seed1_0),hl 
8c2b			;    ld hl,(seed1_1) 
8c2b			;    adc hl,de 
8c2b			;    ld (seed1_1),hl 
8c2b			;    ex de,hl 
8c2b			;seed2_0=$+1 
8c2b			;    ld hl,9876 
8c2b			;seed2_1=$+1 
8c2b			;    ld bc,54321 
8c2b			;    add hl,hl \ rl c \ rl b 
8c2b			;    ld (seed2_1),bc 
8c2b			;    sbc a,a 
8c2b			;    and %11000101 
8c2b			;    xor l 
8c2b			;    ld l,a 
8c2b			;    ld (seed2_0),hl 
8c2b			;    ex de,hl 
8c2b			;    add hl,bc 
8c2b			;    ret 
8c2b			; 
8c2b			 
8c2b			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c2b			; 20 bytes, 86 cycles (excluding ret) 
8c2b			 
8c2b			; returns   hl = pseudorandom number 
8c2b			; corrupts   a 
8c2b			 
8c2b			; generates 16-bit pseudorandom numbers with a period of 65535 
8c2b			; using the xorshift method: 
8c2b			 
8c2b			; hl ^= hl << 7 
8c2b			; hl ^= hl >> 9 
8c2b			; hl ^= hl << 8 
8c2b			 
8c2b			; some alternative shift triplets which also perform well are: 
8c2b			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c2b			 
8c2b			;  org 32768 
8c2b			 
8c2b			xrnd: 
8c2b 2a a3 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c2e 3e 00		  ld a,0 
8c30 bd			  cp l 
8c31 20 02		  jr nz, .xrnd1 
8c33 2e 01		  ld l, 1 
8c35			.xrnd1: 
8c35			 
8c35 7c			  ld a,h 
8c36 1f			  rra 
8c37 7d			  ld a,l 
8c38 1f			  rra 
8c39 ac			  xor h 
8c3a 67			  ld h,a 
8c3b 7d			  ld a,l 
8c3c 1f			  rra 
8c3d 7c			  ld a,h 
8c3e 1f			  rra 
8c3f ad			  xor l 
8c40 6f			  ld l,a 
8c41 ac			  xor h 
8c42 67			  ld h,a 
8c43			 
8c43 22 a3 eb		  ld (xrandc),hl 
8c46			 
8c46 c9			  ret 
8c47			;  
8c47			 
8c47			 
8c47			;;;; int maths 
8c47			 
8c47			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c47			; Divide 16-bit values (with 16-bit result) 
8c47			; In: Divide BC by divider DE 
8c47			; Out: BC = result, HL = rest 
8c47			; 
8c47			Div16: 
8c47 21 00 00		    ld hl,0 
8c4a 78			    ld a,b 
8c4b 06 08		    ld b,8 
8c4d			Div16_Loop1: 
8c4d 17			    rla 
8c4e ed 6a		    adc hl,hl 
8c50 ed 52		    sbc hl,de 
8c52 30 01		    jr nc,Div16_NoAdd1 
8c54 19			    add hl,de 
8c55			Div16_NoAdd1: 
8c55 10 f6		    djnz Div16_Loop1 
8c57 17			    rla 
8c58 2f			    cpl 
8c59 47			    ld b,a 
8c5a 79			    ld a,c 
8c5b 48			    ld c,b 
8c5c 06 08		    ld b,8 
8c5e			Div16_Loop2: 
8c5e 17			    rla 
8c5f ed 6a		    adc hl,hl 
8c61 ed 52		    sbc hl,de 
8c63 30 01		    jr nc,Div16_NoAdd2 
8c65 19			    add hl,de 
8c66			Div16_NoAdd2: 
8c66 10 f6		    djnz Div16_Loop2 
8c68 17			    rla 
8c69 2f			    cpl 
8c6a 41			    ld b,c 
8c6b 4f			    ld c,a 
8c6c c9			ret 
8c6d			 
8c6d			 
8c6d			;http://z80-heaven.wikidot.com/math 
8c6d			; 
8c6d			;Inputs: 
8c6d			;     DE and A are factors 
8c6d			;Outputs: 
8c6d			;     A is not changed 
8c6d			;     B is 0 
8c6d			;     C is not changed 
8c6d			;     DE is not changed 
8c6d			;     HL is the product 
8c6d			;Time: 
8c6d			;     342+6x 
8c6d			; 
8c6d			Mult16: 
8c6d			 
8c6d 06 08		     ld b,8          ;7           7 
8c6f 21 00 00		     ld hl,0         ;10         10 
8c72 29			       add hl,hl     ;11*8       88 
8c73 07			       rlca          ;4*8        32 
8c74 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c76 19			         add hl,de   ;--         -- 
8c77 10 f9		       djnz $-5      ;13*7+8     99 
8c79 c9			ret 
8c7a			 
8c7a			; 
8c7a			; Square root of 16-bit value 
8c7a			; In:  HL = value 
8c7a			; Out:  D = result (rounded down) 
8c7a			; 
8c7a			;Sqr16: 
8c7a			;    ld de,#0040 
8c7a			;    ld a,l 
8c7a			;    ld l,h 
8c7a			;    ld h,d 
8c7a			;    or a 
8c7a			;    ld b,8 
8c7a			;Sqr16_Loop: 
8c7a			;    sbc hl,de 
8c7a			;    jr nc,Sqr16_Skip 
8c7a			;    add hl,de 
8c7a			;Sqr16_Skip: 
8c7a			;    ccf 
8c7a			;    rl d 
8c7a			;    add a,a 
8c7a			;    adc hl,hl 
8c7a			;    add a,a 
8c7a			;    adc hl,hl 
8c7a			;    djnz Sqr16_Loop 
8c7a			;    ret 
8c7a			; 
8c7a			; 
8c7a			; Divide 8-bit values 
8c7a			; In: Divide E by divider C 
8c7a			; Out: A = result, B = rest 
8c7a			; 
8c7a			Div8: 
8c7a af			    xor a 
8c7b 06 08		    ld b,8 
8c7d			Div8_Loop: 
8c7d cb 13		    rl e 
8c7f 17			    rla 
8c80 91			    sub c 
8c81 30 01		    jr nc,Div8_NoAdd 
8c83 81			    add a,c 
8c84			Div8_NoAdd: 
8c84 10 f7		    djnz Div8_Loop 
8c86 47			    ld b,a 
8c87 7b			    ld a,e 
8c88 17			    rla 
8c89 2f			    cpl 
8c8a c9			    ret 
8c8b			 
8c8b			; 
8c8b			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c8b			; In: Multiply A with DE 
8c8b			; Out: HL = result 
8c8b			; 
8c8b			Mult12U: 
8c8b 2e 00		    ld l,0 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd0 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd0: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd1 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd1: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd2 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd2: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd3 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd3: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 30 01		    jr nc,Mult12U_NoAdd4 
8ca4 19			    add hl,de 
8ca5			Mult12U_NoAdd4: 
8ca5 29			    add hl,hl 
8ca6 87			    add a,a 
8ca7 30 01		    jr nc,Mult12U_NoAdd5 
8ca9 19			    add hl,de 
8caa			Mult12U_NoAdd5: 
8caa 29			    add hl,hl 
8cab 87			    add a,a 
8cac 30 01		    jr nc,Mult12U_NoAdd6 
8cae 19			    add hl,de 
8caf			Mult12U_NoAdd6: 
8caf 29			    add hl,hl 
8cb0 87			    add a,a 
8cb1 d0			    ret nc 
8cb2 19			    add hl,de 
8cb3 c9			    ret 
8cb4			 
8cb4			; 
8cb4			; Multiply 8-bit value with a 16-bit value (right rotating) 
8cb4			; In: Multiply A with DE 
8cb4			;      Put lowest value in A for most efficient calculation 
8cb4			; Out: HL = result 
8cb4			; 
8cb4			Mult12R: 
8cb4 21 00 00		    ld hl,0 
8cb7			Mult12R_Loop: 
8cb7 cb 3f		    srl a 
8cb9 30 01		    jr nc,Mult12R_NoAdd 
8cbb 19			    add hl,de 
8cbc			Mult12R_NoAdd: 
8cbc cb 23		    sla e 
8cbe cb 12		    rl d 
8cc0 b7			    or a 
8cc1 c2 b7 8c		    jp nz,Mult12R_Loop 
8cc4 c9			    ret 
8cc5			 
8cc5			; 
8cc5			; Multiply 16-bit values (with 32-bit result) 
8cc5			; In: Multiply BC with DE 
8cc5			; Out: BCHL = result 
8cc5			; 
8cc5			Mult32: 
8cc5 79			    ld a,c 
8cc6 48			    ld c,b 
8cc7 21 00 00		    ld hl,0 
8cca 06 10		    ld b,16 
8ccc			Mult32_Loop: 
8ccc 29			    add hl,hl 
8ccd 17			    rla 
8cce cb 11		    rl c 
8cd0 30 07		    jr nc,Mult32_NoAdd 
8cd2 19			    add hl,de 
8cd3 ce 00		    adc a,0 
8cd5 d2 d9 8c		    jp nc,Mult32_NoAdd 
8cd8 0c			    inc c 
8cd9			Mult32_NoAdd: 
8cd9 10 f1		    djnz Mult32_Loop 
8cdb 41			    ld b,c 
8cdc 4f			    ld c,a 
8cdd c9			    ret 
8cde			 
8cde			 
8cde			 
8cde			; 
8cde			; Multiply 8-bit values 
8cde			; In:  Multiply H with E 
8cde			; Out: HL = result 
8cde			; 
8cde			Mult8: 
8cde 16 00		    ld d,0 
8ce0 6a			    ld l,d 
8ce1 06 08		    ld b,8 
8ce3			Mult8_Loop: 
8ce3 29			    add hl,hl 
8ce4 30 01		    jr nc,Mult8_NoAdd 
8ce6 19			    add hl,de 
8ce7			Mult8_NoAdd: 
8ce7 10 fa		    djnz Mult8_Loop 
8ce9 c9			    ret 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			;;http://z80-heaven.wikidot.com/math 
8cea			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cea			; 
8cea			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cea			;     ld a,16        ;7 
8cea			;     ld hl,0        ;10 
8cea			;     jp $+5         ;10 
8cea			;.DivLoop: 
8cea			;       add hl,bc    ;-- 
8cea			;       dec a        ;64 
8cea			;       jr z,.DivLoopEnd        ;86 
8cea			; 
8cea			;       sla e        ;128 
8cea			;       rl d         ;128 
8cea			;       adc hl,hl    ;240 
8cea			;       sbc hl,bc    ;240 
8cea			;       jr nc,.DivLoop ;23|21 
8cea			;       inc e        ;-- 
8cea			;       jp .DivLoop+1 
8cea			; 
8cea			;.DivLoopEnd: 
8cea			 
8cea			;HL_Div_C: 
8cea			;Inputs: 
8cea			;     HL is the numerator 
8cea			;     C is the denominator 
8cea			;Outputs: 
8cea			;     A is the remainder 
8cea			;     B is 0 
8cea			;     C is not changed 
8cea			;     DE is not changed 
8cea			;     HL is the quotient 
8cea			; 
8cea			;       ld b,16 
8cea			;       xor a 
8cea			;         add hl,hl 
8cea			;         rla 
8cea			;         cp c 
8cea			;         jr c,$+4 
8cea			;           inc l 
8cea			;           sub c 
8cea			;         djnz $-7 
8cea			 
8cea			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cea			 
8cea			addatohl: 
8cea 85			    add   a, l    ; A = A+L 
8ceb 6f			    ld    l, a    ; L = A+L 
8cec 8c			    adc   a, h    ; A = A+L+H+carry 
8ced 95			    sub   l       ; A = H+carry 
8cee 67			    ld    h, a    ; H = H+carry 
8cef c9			ret 
8cf0			 
8cf0			addatode: 
8cf0 83			    add   a, e    ; A = A+L 
8cf1 5f			    ld    e, a    ; L = A+L 
8cf2 8a			    adc   a, d    ; A = A+L+H+carry 
8cf3 93			    sub   e       ; A = H+carry 
8cf4 57			    ld    d, a    ; H = H+carry 
8cf5 c9			ret 
8cf6			 
8cf6			 
8cf6			addatobc: 
8cf6 81			    add   a, c    ; A = A+L 
8cf7 4f			    ld    c, a    ; L = A+L 
8cf8 88			    adc   a, b    ; A = A+L+H+carry 
8cf9 91			    sub   c       ; A = H+carry 
8cfa 47			    ld    b, a    ; H = H+carry 
8cfb c9			ret 
8cfc			 
8cfc			subafromhl: 
8cfc			   ; If A=0 do nothing 
8cfc			    ; Otherwise flip A's sign. Since 
8cfc			    ; the upper byte becomes -1, also 
8cfc			    ; substract 1 from H. 
8cfc ed 44		    neg 
8cfe ca 07 8d		    jp    z, Skip 
8d01 25			    dec   h 
8d02			     
8d02			    ; Now add the low byte as usual 
8d02			    ; Two's complement takes care of 
8d02			    ; ensuring the result is correct 
8d02 85			    add   a, l 
8d03 6f			    ld    l, a 
8d04 8c			    adc   a, h 
8d05 95			    sub   l 
8d06 67			    ld    h, a 
8d07			Skip: 
8d07 c9				ret 
8d08			 
8d08			 
8d08			; compare hl and de 
8d08			; returns:  
8d08			; if hl = de, z=1, s=0, c0=0 
8d08			; if hl > de, z=0, s=0, c=0 
8d08			; if hl < de, z=0, s=1, c=1 
8d08			cmp16:	 
8d08 b7				or a 
8d09 ed 52			sbc hl,de 
8d0b e0				ret po 
8d0c 7c				ld a,h 
8d0d 1f				rra 
8d0e ee 40			xor 01000000B 
8d10 37				scf 
8d11 8f				adc a,a 
8d12 c9				ret 
8d13			 
8d13			 
8d13			; test if hl contains zero   - A is destroyed 
8d13			 
8d13			ishlzero:    
8d13 b7				or a     ; reset flags 
8d14 7c				ld a, h 
8d15 b5				or l        	 
8d16			 
8d16 c9				ret 
8d17			 
8d17			 
8d17			 
8d17			 
8d17			if FORTH_ENABLE_FLOATMATH 
8d17			;include "float/bbcmath.z80" 
8d17			include "float/lpfpcalc.asm" 
8d17			endif 
8d17			 
8d17			 
8d17			; eof 
8d17			 
# End of file firmware_maths.asm
8d17			include "firmware_strings.asm"   ; string handling  
8d17			 
8d17			 
8d17			; TODO string len 
8d17			; input text string, end on cr with zero term 
8d17			; a offset into frame buffer to start prompt 
8d17			; d is max length 
8d17			; e is display size TODO 
8d17			; c is current cursor position 
8d17			; hl is ptr to where string will be stored and edited directly 
8d17			 
8d17			 
8d17			; TODO check limit of buffer for new inserts 
8d17			; TODO check insert does not push beyond buffer 
8d17			; TODO scroll in a limited display area 
8d17			; TODO scroll whole screen on page wrap 
8d17			 
8d17			 
8d17			; TODO use LCD cursor? 
8d17			 
8d17			EDIT_V1: equ 0 
8d17			EDIT_V2: equ 1 
8d17			 
8d17			 
8d17			 
8d17			if EDIT_V2 
8d17			input_str: 
8d17			 
8d17 32 5e ee			    	ld (input_at_pos),a      ; save display position to start 
8d1a			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d1a 22 61 ee				ld (input_start), hl     ; save ptr to buffer 
8d1d			;		ld a, c 
8d1d			;		call addatohl 
8d1d			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1d 7a					ld a,d 
8d1e 32 60 ee			        ld (input_size), a       ; save length of input area 
8d21 79					ld a, c 
8d22 32 4f ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d25 7b					ld a,e 
8d26 32 5f ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d29			 
8d29			 
8d29					; add a trailing space to make screen refresh nicer 
8d29			 
8d29					;ld hl, (input_start) 
8d29					;push hl 
8d29					;ld a, 0 
8d29					;call strlent 
8d29					;ld a, l 
8d29					;pop hl 
8d29					;call addatohl 
8d29					;dec hl 
8d29					;ld a, ' ' 
8d29					;ld (hl), a 
8d29					;inc hl 
8d29					;ld (hl), a 
8d29					;inc hl 
8d29					;ld a, 0 
8d29					;ld (hl), a 
8d29			 
8d29			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d29					; init cursor shape if not set by the cin routines 
8d29 21 bb eb				ld hl, cursor_shape 
8d2c			if BASE_KEV 
8d2c					ld a, 255 
8d2c			else 
8d2c 3e 23				ld a, '#' 
8d2e			endif 
8d2e 77					ld (hl), a 
8d2f 23					inc hl 
8d30 3e 00				ld a, 0 
8d32 77					ld (hl), a 
8d33			 
8d33 3e 09				ld a, CUR_BLINK_RATE 
8d35 32 5a ee				ld (input_cur_flash), a 
8d38 3e 01				ld a, 1 
8d3a 32 59 ee				ld (input_cur_onoff),a 
8d3d			.inmain:	 
8d3d			 
8d3d cd 65 8e				call input_disp_ref 
8d40			 
8d40					; save current length of string 
8d40			 
8d40 2a 61 ee				ld hl, (input_start) 
8d43 3e 00				ld a, 0 
8d45 cd 5b 90				call strlent 
8d48 7d					ld a,l 
8d49 32 54 ee				ld (input_len), a 
8d4c			 
8d4c					;call input_disp_oncur 
8d4c			 
8d4c					; display current state of input buffer 
8d4c			 
8d4c					; clean any backspace chars 
8d4c			 
8d4c 3e 20				ld a, " " 
8d4e 32 bb e2				ld (scratch),a 
8d51 3e 00				ld a, 0 
8d53 32 bc e2				ld (scratch+1),a 
8d56 3a 5e ee				ld a,(input_at_pos) 
8d59 85					add l 
8d5a 11 bb e2				ld de, scratch 
8d5d cd d0 8a				call str_at_display 
8d60			 
8d60					; pause 1ms 
8d60			 
8d60 3e 01				ld a, 1 
8d62 cd e5 89				call aDelayInMS 
8d65			 
8d65			; display cursor if visible on this cycle 
8d65			 
8d65					; dec flash counter 
8d65 3a 5a ee				ld a, (input_cur_flash) 
8d68 3d					dec a 
8d69 32 5a ee				ld (input_cur_flash), a 
8d6c fe 00				cp 0 
8d6e 20 0d				jr nz, .inochgstate 
8d70			 
8d70			 
8d70					; reset on change of state 
8d70 3e 09				ld a, CUR_BLINK_RATE 
8d72 32 5a ee				ld (input_cur_flash), a 
8d75			 
8d75					; change state 
8d75 3a 59 ee				ld a,(input_cur_onoff) 
8d78 ed 44				neg 
8d7a 32 59 ee				ld (input_cur_onoff),a 
8d7d			 
8d7d			 
8d7d			 
8d7d			 
8d7d					; TODO is cursor visible? 
8d7d					; TODO if so then over write the char at curspos pos with the cursor shape 
8d7d			 
8d7d								 
8d7d			 
8d7d			.inochgstate: 
8d7d 3a 59 ee				ld a,(input_cur_onoff) 
8d80 fe ff				cp 255 
8d82 28 0e				jr z, .skipcursor 
8d84 3a 5e ee				ld a, (input_at_pos) 
8d87 47					ld b, a 
8d88 3a 4f ee				ld a, (input_cursor) 
8d8b 80					add b 
8d8c 11 bb eb				ld de, cursor_shape 
8d8f					 
8d8f cd d0 8a				call str_at_display 
8d92			 
8d92			.skipcursor: 
8d92				if DEBUG_INPUTV2 
8d92			 
8d92					ld a,(input_at_pos) 
8d92					ld hl, LFSRSeed 
8d92					call hexout 
8d92					ld a, (input_cursor) 
8d92					ld hl, LFSRSeed+2 
8d92					call hexout 
8d92					ld a,(input_size) 
8d92					ld hl, LFSRSeed+4 
8d92					call hexout 
8d92			 
8d92					ld a,(input_cur_onoff) 
8d92					ld hl, LFSRSeed+6 
8d92					call hexout 
8d92			 
8d92					ld a,(input_cur_flash) 
8d92					ld hl, LFSRSeed+8 
8d92					call hexout 
8d92			 
8d92					ld a,(input_len) 
8d92					ld hl, LFSRSeed+10 
8d92					call hexout 
8d92					ld hl, LFSRSeed+12 
8d92					ld a, 0 
8d92					ld (hl),a 
8d92					ld a, display_row_4 
8d92					ld de, LFSRSeed 
8d92					call str_at_display 
8d92				endif 
8d92 cd e0 8a				call update_display 
8d95			 
8d95					; TODO keyboard processing 
8d95			 
8d95			if BASE_CPM 
8d95					call cin_wait 
8d95			else 
8d95 cd 88 df				call cin    ; _wait 
8d98			endif 
8d98 fe 00				cp 0 
8d9a ca 3d 8d				jp z, .inmain 
8d9d			 
8d9d fe 0b				cp KEY_LEFT    ; cursor left 
8d9f ca 57 8e				jp z, input_left 
8da2				 
8da2 fe 0c				cp KEY_RIGHT      ; cursor right 
8da4 ca 5e 8e				jp z, input_right 
8da7			 
8da7 fe 0d				cp KEY_CR 
8da9 c8					ret z 
8daa			 
8daa fe 08				cp KEY_BS 
8dac ca cc 8e				jp z, input_delchar 
8daf			 
8daf fe 06				cp KEY_NEXTWORD 
8db1 ca d8 8d				jp z, input_nxtword 
8db4			 
8db4 fe 07				cp KEY_PREVWORD 
8db6 ca ff 8d				jp z, input_prvword 
8db9			 
8db9 fe 0e				cp KEY_HOME    ; jump to start of line 
8dbb 20 08				jr nz, .ikh 
8dbd 3e 00				ld a, 0 
8dbf 32 4f ee				ld (input_cursor), a 
8dc2 ca 3d 8d				jp z, .inmain 
8dc5			.ikh: 
8dc5			 
8dc5 fe 0f				cp KEY_END     ; jump to end of line 
8dc7 20 09				jr nz, .ike 
8dc9 3a 54 ee				ld a, (input_len) 
8dcc 32 4f ee				ld (input_cursor),a 
8dcf ca 3d 8d				jp z, .inmain 
8dd2			.ike: 
8dd2 fe 05			        cp KEY_UP      ; recall last command 
8dd4 c8					ret z 
8dd5			;jr nz, .irec 
8dd5			; TODO next word 
8dd5			; TODO prev word 
8dd5			;  
8dd5			; 
8dd5			;	ld hl, scratch 
8dd5			;	ld de, os_last_cmd 
8dd5			;	call strcpy 
8dd5			;		jp  .inmain 
8dd5			.irec: 
8dd5			;		jr .instr1 
8dd5			 
8dd5			 
8dd5			 
8dd5					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dd5			 
8dd5			; TODO return if any special keys are given 
8dd5			;		ld l, a 
8dd5			;		ld a, 28 ; KEY_F12   ; 27 
8dd5			;		sub l 
8dd5			;		ret m 
8dd5			;		ld a, l 
8dd5					; if no special key then insert as a char 
8dd5			 
8dd5 c3 9e 8e				jp input_inschr 
8dd8			 
8dd8				 
8dd8			input_nxtword: 
8dd8				; jump to start next word after the cursor 
8dd8			 
8dd8			.insknwn:	 
8dd8 cd 94 8e				call input_curptr	 
8ddb 7e					ld a,(hl)	 
8ddc fe 00				cp 0 
8dde ca 3d 8d				jp z, .inmain    ; end of string 
8de1			 
8de1			; if we are on a word, then move off of it 
8de1			 
8de1 fe 20				cp ' ' 
8de3 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8de5 21 4f ee				ld hl, input_cursor 
8de8 34					inc (hl) 
8de9 18 ed				jr .insknwn 
8deb			 
8deb			.inspace: 
8deb			 
8deb cd 94 8e				call input_curptr	 
8dee 7e					ld a,(hl)	 
8def fe 00				cp 0 
8df1 ca 3d 8d				jp z, .inmain    ; end of string 
8df4			 
8df4			; if we are on a word, then move off of it 
8df4			 
8df4 fe 20				cp ' ' 
8df6 c2 3d 8d				jp nz, .inmain     ; we are on non space so at next word 
8df9 21 4f ee				ld hl, input_cursor 
8dfc 34					inc (hl) 
8dfd 18 ec				jr .inspace 
8dff			 
8dff			 
8dff			 
8dff			 
8dff			input_prvword: 
8dff				; jump to the start of previous word before the cursor 
8dff			 
8dff			; where are we to start with currently? 
8dff			 
8dff cd 94 8e				call input_curptr	 
8e02 7e					ld a, (hl) 
8e03 fe 20				cp ' ' 
8e05 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e07			 
8e07			 
8e07			 
8e07			.inskpwn:	 
8e07 3a 4f ee				ld a,(input_cursor) 
8e0a fe 00				cp 0 
8e0c ca 3d 8d				jp z, .inmain    ; start of string 
8e0f			 
8e0f			;if we are on a word, then move off of it 
8e0f			 
8e0f cd 94 8e				call input_curptr	 
8e12 7e					ld a, (hl) 
8e13 fe 20				cp ' ' 
8e15 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e17					;jp z, .inmain    ; start of string 
8e17 21 4f ee				ld hl, input_cursor 
8e1a 35					dec (hl) 
8e1b 18 ea				jr .inskpwn 
8e1d			.iwstart: 
8e1d 21 4f ee				ld hl, input_cursor 
8e20 34					inc (hl) 
8e21 c3 3d 8d				jp .inmain 
8e24					 
8e24			 
8e24			.inspacep: 
8e24			 
8e24					;jp .inmain    ; start of string 
8e24			 
8e24			 
8e24			 
8e24 3a 4f ee				ld a,(input_cursor) 
8e27 fe 00				cp 0 
8e29 ca 3d 8d				jp z, .inmain    ; start of string 
8e2c			 
8e2c			; if we are on a word, then move off of it 
8e2c			 
8e2c cd 94 8e				call input_curptr	 
8e2f 7e					ld a, (hl) 
8e30 fe 20				cp ' ' 
8e32 c2 3b 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e35 21 4f ee				ld hl, input_cursor 
8e38 35					dec (hl) 
8e39 18 e9				jr .inspacep 
8e3b			 
8e3b			 
8e3b			.incharp:	 
8e3b					; eat the word to get to the start 
8e3b 3a 4f ee				ld a,(input_cursor) 
8e3e fe 00				cp 0 
8e40 ca 3d 8d				jp z, .inmain    ; start of string 
8e43			 
8e43			; if we are on a word, then move off of it 
8e43			 
8e43 cd 94 8e				call input_curptr	 
8e46 7e					ld a, (hl) 
8e47 fe 20				cp ' ' 
8e49 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e4b 21 4f ee				ld hl, input_cursor 
8e4e 35					dec (hl) 
8e4f 18 ea				jr .incharp 
8e51			.ipwordst: 
8e51					; at space before the prev word so reposition over it 
8e51 21 4f ee				ld hl, input_cursor 
8e54 34					inc (hl) 
8e55 18 b0				jr .inskpwn 
8e57					 
8e57			 
8e57			 
8e57			input_left: 
8e57				; move cursor left 
8e57 21 4f ee			ld hl, input_cursor 
8e5a 35				dec (hl) 
8e5b			;	cp 0 
8e5b			;	jp z, .inmain    ; ignore left as at the start of the string 
8e5b c3 3d 8d			jp .inmain 
8e5e			 
8e5e			input_right: 
8e5e				; move cursor right 
8e5e				 
8e5e				;ld a, (input_size) 
8e5e				;ld b, a 
8e5e 21 4f ee			ld hl, input_cursor 
8e61 34				inc (hl) 
8e62				;dec b 
8e62				;cp 0 
8e62				;jp z, .inmain   ; ignore as at end of the string buffer 
8e62				;ld a, b 
8e62				;inc a 
8e62				;ld (input_cursor), a 
8e62 c3 3d 8d			jp .inmain 
8e65			 
8e65			 
8e65			 
8e65			input_disp_ref: 
8e65				; display the text from start of buffer (ie full refresh) 
8e65 3a 5e ee			ld a, (input_at_pos) 
8e68 2a 61 ee			ld hl,(input_start) 
8e6b eb				ex de, hl 
8e6c cd d0 8a			call str_at_display  
8e6f c9				ret 
8e70			input_disp_oncur: 
8e70				; display the text from cursor position to end of buffer 
8e70				; TODO position start of string at cursor position on screen 
8e70				; TODO draw from that point on 
8e70 3a 4f ee			ld a, (input_cursor) 
8e73 47				ld b, a 
8e74 3a 5e ee			ld a, (input_at_pos) 
8e77 80				add b 
8e78 48				ld c, b     ; save a 
8e79 78				ld a, b     ; inc string start for cursor 
8e7a 2a 61 ee			ld hl,(input_start) 
8e7d cd ea 8c			call addatohl 
8e80 eb				ex de, hl 
8e81 79				ld a, c 
8e82 cd d0 8a			call str_at_display  
8e85 c9				ret 
8e86			 
8e86			input_nxtw: 
8e86				; Find next word 
8e86 c9				ret 
8e87			 
8e87			input_prvw: 
8e87				; Find previous word 
8e87 c9				ret 
8e88			 
8e88			input_lenrem:   
8e88				; Calculate the length of string remaining from current cursor 
8e88				; position to end of buffer (exc null term) 
8e88				 
8e88 3a 4f ee			ld a, (input_cursor) 
8e8b 4f				ld c, a 
8e8c 3a 60 ee			ld a, (input_size) 
8e8f 91				sub c 
8e90 06 00			ld b, 0 
8e92 0d				dec c 
8e93 c9				ret	 
8e94			 
8e94			input_curptr: 
8e94				; calc address of the character under the cursor 
8e94				 
8e94 2a 61 ee			ld hl, (input_start) 
8e97 3a 4f ee			ld a, (input_cursor) 
8e9a cd ea 8c			call addatohl 
8e9d c9				ret 
8e9e			 
8e9e			input_inschr: 
8e9e				; Insert char at cursor position 
8e9e f5				push af   ; save char 
8e9f				;call input_lenrem    ; get bc length of remaining string 
8e9f			 
8e9f				 
8e9f cd 94 8e			call input_curptr 
8ea2			;	ld hl, (input_start) 
8ea2			;	ld a, (input_cursor) 
8ea2			;	call addatohl 
8ea2				;push hl   ; save to come back to 
8ea2			 
8ea2				; shift everything up one to end of buffer 
8ea2			 
8ea2				;push hl 
8ea2				;dec de 
8ea2				;inc de 
8ea2			;	ldir 
8ea2				 
8ea2				;pop hl 
8ea2			 
8ea2				; are we adding to the end of line? 
8ea2			 
8ea2 3a 4f ee			ld a, (input_cursor) 
8ea5 47				ld b, a 
8ea6 3a 54 ee			ld a, (input_len) 
8ea9 b8				cp b 
8eaa 20 09			jr nz, .insmid   ; no, insert in middle of text 
8eac			 
8eac				; tack on the end of the line 
8eac f1				pop af 
8ead 77				ld (hl), a   ; save new char 
8eae 23				inc hl 
8eaf 3e 00			ld a, 0 
8eb1 77				ld (hl), a 
8eb2 c3 5e 8e			jp input_right 
8eb5				 
8eb5			.insmid: 
8eb5				; hl has insertion point so move everything up one to allow for insertion 
8eb5				;call input_shiftright 
8eb5 f1				pop af 
8eb6			 
8eb6			.shufinsmid: 
8eb6 47				ld b, a     ; b contains new char, c prev char at this position  
8eb7 7e				ld a, (hl) 
8eb8			 
8eb8 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eba 28 07			jr z, .endinsmid 
8ebc 4f				ld c, a 
8ebd 78				ld a, b 
8ebe 77				ld (hl), a 
8ebf 23				inc hl 
8ec0 79				ld a, c 
8ec1 18 f3			jr .shufinsmid 
8ec3				 
8ec3			 
8ec3			 
8ec3			 
8ec3			.endinsmid: 
8ec3 78				ld a, b 
8ec4 77				ld (hl), a 
8ec5 23				inc hl 
8ec6 3e 00			ld a, 0 
8ec8 77				ld (hl), a 
8ec9			 
8ec9			 
8ec9			;	ld (hl), a   ; save new char 
8ec9			 
8ec9 c3 5e 8e			jp input_right 
8ecc			 
8ecc			;input_shiftright: 
8ecc			;	; shift text right at cursor, hl has shift start 
8ecc			;	push hl 
8ecc			;	push de 
8ecc			;	push bc 
8ecc			; 
8ecc			; 
8ecc			;	; move to end of string past zero term 
8ecc			;	ld hl,(input_start) 
8ecc			;	ld a, (input_len) 
8ecc			;	call addatohl 
8ecc			;	inc hl 
8ecc			;;	inc hl 
8ecc			;;	inc hl 
8ecc			;	ld a, 0 
8ecc			;	ld (hl), a 
8ecc			;;	dec hl 
8ecc			;	 
8ecc			;;	ld (hl), a 
8ecc			;;	dec hl 
8ecc			; 
8ecc			;	push hl 
8ecc			;	pop de 
8ecc			;	inc de 
8ecc			;	 
8ecc			; 
8ecc			;;	ld hl,(input_start) 
8ecc			;;	ld a, (input_cursor) 
8ecc			;;	call addatohl 
8ecc			; 
8ecc			; 
8ecc			;	; calc how many bytes from cursor pos to end of string we need to shift 
8ecc			;	call input_lenrem    ; get bc length of remaining string 
8ecc			;	;ld a, (input_cursor) 
8ecc			;	;ld c, a 
8ecc			;	ld a, (input_len) 
8ecc			;	cp 2 
8ecc			;	jr z, .iskipzero	 
8ecc			;	;sub c 
8ecc			;	;inc a 
8ecc			;	;ld c, a 
8ecc			;	;ld b, 0 
8ecc			;	inc c 
8ecc			;	inc c 
8ecc			;	; move data 
8ecc			;	lddr 
8ecc			;.iskipzero: 
8ecc			; 
8ecc			;	pop bc 
8ecc			;	pop de 
8ecc			;	pop hl 
8ecc			;	ret	 
8ecc			 
8ecc			input_delchar: 
8ecc				; Delete char at cursor position 
8ecc cd 88 8e			call input_lenrem    ; get bc length of remaining string 
8ecf 2a 61 ee			ld hl, (input_start) 
8ed2 3a 4f ee			ld a, (input_cursor) 
8ed5 cd ea 8c			call addatohl 
8ed8			 
8ed8 e5				push hl 
8ed9 d1				pop de 
8eda 1b				dec de 
8edb			 
8edb			.dl:	 
8edb ed a0			ldi  
8edd 7e				ld a, (hl) 
8ede fe 00			cp 0 
8ee0 28 02			jr z, .dldone 
8ee2 18 f7			jr .dl 
8ee4			.dldone: 
8ee4 ed a0			ldi 
8ee6			 
8ee6 c3 57 8e			jp input_left 
8ee9			 
8ee9			 
8ee9			endif 
8ee9			 
8ee9			 
8ee9			 
8ee9			if EDIT_V1 
8ee9			input_str: 
8ee9			 
8ee9				    	ld (input_at_pos),a      ; save display position to start 
8ee9					add c 
8ee9					ld (input_at_cursor),a	; save draw pos of cursor 
8ee9					ld (input_start), hl     ; save ptr to buffer 
8ee9					ld a, c 
8ee9					call addatohl 
8ee9					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ee9					ld a,d 
8ee9				        ld (input_size), a       ; save length of input area 
8ee9					ld a, c 
8ee9					ld (input_cursor),a      ; init cursor start position  
8ee9					ld a,e 
8ee9				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ee9					 
8ee9					 
8ee9			 
8ee9			;		ld a,(input_ptr) 
8ee9			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ee9			 
8ee9			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ee9					; init cursor shape if not set by the cin routines 
8ee9					ld hl, cursor_shape 
8ee9			if BASE_KEV 
8ee9					ld a, 255 
8ee9			else 
8ee9					ld a, '#' 
8ee9			endif 
8ee9					ld (hl), a 
8ee9					inc hl 
8ee9					ld a, 0 
8ee9					ld (hl), a 
8ee9			 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9					ld a, 1 
8ee9					ld (input_cur_onoff),a 
8ee9			 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, 'I' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9			.is1:		; main entry loop 
8ee9			 
8ee9			 
8ee9			 
8ee9					; pause 1ms 
8ee9			 
8ee9					ld a, 1 
8ee9					call aDelayInMS 
8ee9			 
8ee9					; dec flash counter 
8ee9					ld a, (input_cur_flash) 
8ee9					dec a 
8ee9					ld (input_cur_flash), a 
8ee9					cp 0 
8ee9					jr nz, .nochgstate 
8ee9			 
8ee9			 
8ee9					; change state 
8ee9					ld a,(input_cur_onoff) 
8ee9					neg 
8ee9					ld (input_cur_onoff),a 
8ee9			 
8ee9			 
8ee9					; reset on change of state 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9			.nochgstate: 
8ee9					 
8ee9					 
8ee9			 
8ee9					; display cursor  
8ee9			 
8ee9			;		ld hl, (input_start) 
8ee9			;		ld a, (input_cursor) 
8ee9			;		call addatohl 
8ee9			 
8ee9					; get char under cursor and replace with cursor 
8ee9			ld hl, (input_ptr) 
8ee9			;		ld a, (hl) 
8ee9			;		ld (input_under_cursor),a 
8ee9			;		ld a, '_' 
8ee9			;		ld (hl), a 
8ee9			 
8ee9					; display string 
8ee9			 
8ee9					ld de, (input_start) 
8ee9					ld a, (input_at_pos) 
8ee9					call str_at_display 
8ee9			;	        call update_display 
8ee9			 
8ee9					; find place to put the cursor 
8ee9			;		add h 
8ee9			;		ld l, display_row_1 
8ee9			;		sub l 
8ee9			; (input_at_pos) 
8ee9					;ld c, a 
8ee9			;		ld a, (input_cursor) 
8ee9			;		ld l, (input_at_pos) 
8ee9			;		;ld b, h 
8ee9			;		add l 
8ee9			;		ld (input_at_cursor),a 
8ee9					;ld l,h 
8ee9			 
8ee9			;		ld h, 0 
8ee9			;		ld l,(input_at_pos) 
8ee9			;		ld a, (input_cursor) 
8ee9			;		call addatohl 
8ee9			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ee9			;		call subafromhl 
8ee9			;		ld a,l 
8ee9			;		ld (input_at_cursor), a 
8ee9			 
8ee9				if DEBUG_INPUT 
8ee9					ld a, (hardware_diag) 
8ee9					cp 0 
8ee9					jr z, .skip_input_diag 
8ee9			 
8ee9					ld a,(input_at_pos) 
8ee9					ld hl, LFSRSeed 
8ee9					call hexout 
8ee9					ld a, (input_cursor) 
8ee9					ld hl, LFSRSeed+2 
8ee9					call hexout 
8ee9					ld a,(input_at_cursor) 
8ee9					ld hl, LFSRSeed+4 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_cur_onoff) 
8ee9					ld hl, LFSRSeed+6 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_cur_flash) 
8ee9					ld hl, LFSRSeed+8 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_len) 
8ee9					ld hl, LFSRSeed+10 
8ee9					call hexout 
8ee9					ld hl, LFSRSeed+12 
8ee9					ld a, 0 
8ee9					ld (hl),a 
8ee9					ld a, display_row_4 
8ee9					ld de, LFSRSeed 
8ee9					call str_at_display 
8ee9					.skip_input_diag: 
8ee9				endif 
8ee9			 
8ee9					; decide on if we are showing the cursor this time round 
8ee9			 
8ee9					ld a, (input_cur_onoff) 
8ee9					cp 255 
8ee9					jr z, .skipcur 
8ee9			 
8ee9			 
8ee9					ld a,(input_at_cursor) 
8ee9					ld de, cursor_shape 
8ee9					call str_at_display 
8ee9			 
8ee9					; save length of current input string 
8ee9					ld hl, (input_start) 
8ee9					ld a, 0 
8ee9					call strlent 
8ee9					ld a,l 
8ee9					ld (input_len),a 
8ee9			 
8ee9			.skipcur: 
8ee9			 
8ee9				        call update_display 
8ee9					 
8ee9			 
8ee9			 
8ee9					; wait 
8ee9				 
8ee9					; TODO loop without wait to flash the cursor and char under cursor	 
8ee9					call cin    ; _wait 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 
8ee9			 
8ee9					; get ptr to char to input into 
8ee9			 
8ee9					ld c,a 
8ee9					ld hl, (input_start) 
8ee9					ld a, (input_cursor) 
8ee9					call addatohl 
8ee9					ld (input_ptr), hl 
8ee9					ld a,c 
8ee9			 
8ee9					; replace char under cursor 
8ee9			 
8ee9			;		ld hl, (input_ptr) 
8ee9			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ee9			;		ld (hl), a 
8ee9			 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, 'i' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9					cp KEY_HOME 
8ee9					jr nz, .iske 
8ee9			 
8ee9					ld a, (input_at_pos) 
8ee9					ld (input_at_cursor),a 
8ee9					ld a, 0 
8ee9					ld (input_cursor), a 
8ee9					jp .is1 
8ee9					 
8ee9			.iske:		cp KEY_END 
8ee9					jr nz, .isknw 
8ee9					jp .is1 
8ee9			 
8ee9			.isknw:		cp KEY_NEXTWORD 
8ee9					jr nz, .iskpw 
8ee9			 
8ee9			.isknwm:	ld hl, (input_ptr) 
8ee9					ld a,(hl)	 
8ee9					cp 0 
8ee9					jp z, .is1    ; end of string 
8ee9					cp ' ' 
8ee9					jp z, .is1    ; end of word 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9					jr .isknwm 
8ee9			 
8ee9			.iskpw:		cp KEY_PREVWORD 
8ee9					jr nz, .iskl 
8ee9			.iskpwm:	 
8ee9					ld hl, (input_ptr) 
8ee9					ld a,(hl)	 
8ee9					cp 0  
8ee9					jp z, .is1    ; end of string 
8ee9					cp ' ' 
8ee9					jp z, .is1    ; end of word 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9					jr .iskpwm 
8ee9			 
8ee9			 
8ee9			.iskl:		cp KEY_LEFT 
8ee9					jr nz, .isk1 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 		; at start of line to ignore  
8ee9			 
8ee9					dec  a 		; TODO check underflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9					 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk1:		cp KEY_RIGHT 
8ee9					jr nz, .isk2 
8ee9			 
8ee9					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ee9					ld e,a 
8ee9					ld a, (input_cursor) 
8ee9					cp e 
8ee9					jp z, .is1		; at the end of string so dont go right 
8ee9			 
8ee9					inc  a 		; TODO check overflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk2:		cp KEY_UP 
8ee9			 
8ee9					jr nz, .isk3 
8ee9			 
8ee9					; swap last command with the current on 
8ee9			 
8ee9					; move cursor to start of string 
8ee9					ld hl, (input_start) 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld a, (input_at_pos) 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld a, 0 
8ee9					ld (input_cursor), a 
8ee9					 
8ee9					; swap input and last command buffers 
8ee9			 
8ee9					ld hl, os_cli_cmd 
8ee9					ld de, os_last_cmd 
8ee9					ld b, 255 
8ee9			.swap1:		ld a, (hl) 
8ee9					ld c,a 
8ee9					ld a, (de) 
8ee9					ld (hl), a 
8ee9					ld a,c 
8ee9					ld (de),a 
8ee9					inc hl 
8ee9					inc de 
8ee9					djnz .swap1 
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk3:		cp KEY_BS 
8ee9					jr nz, .isk4 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 		; at start of line to ignore  
8ee9			 
8ee9					dec  a 		; TODO check underflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					; hl is source 
8ee9					; de needs to be source - 1 
8ee9			 
8ee9			;		ld a, 0 
8ee9			;		dec hl 
8ee9			;		ld (hl), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					; shift all data 
8ee9			 
8ee9					push hl 
8ee9					inc hl 
8ee9					pop de 
8ee9					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ee9					ld c,a 
8ee9					ld b,0 
8ee9					ldir  
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					; remove char 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld de,.iblank 
8ee9					call str_at_display 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk4:		cp KEY_CR 
8ee9					jr z, .endinput 
8ee9			 
8ee9					; else add the key press to the end 
8ee9			 
8ee9					ld c, a			; save key pressed 
8ee9			 
8ee9					ld a,(hl)		; get what is currently under char 
8ee9			 
8ee9					cp 0			; we are at the end of the string 
8ee9					jr nz, .onchar 
8ee9					 
8ee9					; add a char to the end of the string 
8ee9				 
8ee9					ld (hl),c 
8ee9					inc hl 
8ee9			;		ld a,' ' 
8ee9			;		ld (hl),a 
8ee9			;		inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9					dec hl 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9					inc a				; TODO check max string length and scroll  
8ee9					ld (input_cursor), a		; inc cursor pos 
8ee9							 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, '+' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9					jp .is1 
8ee9					 
8ee9			 
8ee9			 
8ee9					; if on a char then insert 
8ee9			.onchar: 
8ee9			 
8ee9					; TODO over flow check: make sure insert does not blow out buffer 
8ee9			 
8ee9					; need to do some maths to use lddr 
8ee9			 
8ee9					push hl   ; save char pos 
8ee9					push bc 
8ee9			 
8ee9					ld hl, (input_start) 
8ee9					ld a, (input_len) 
8ee9					call addatohl  		; end of string 
8ee9					inc hl 
8ee9					inc hl		; past zero term 
8ee9					push hl 
8ee9					inc hl 
8ee9					push hl  
8ee9			 
8ee9								; start and end of lddr set, now how much to move? 
8ee9			 
8ee9							 
8ee9					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ee9					ld b,a 
8ee9					ld a,(input_len) 
8ee9					ld e,a 
8ee9					sub b 
8ee9					inc a		;?? 
8ee9					inc a		;?? 
8ee9					inc a		;?? 
8ee9			 
8ee9					ld b,0 
8ee9					ld c,a 
8ee9			 
8ee9				if DEBUG_INPUT 
8ee9					push af 
8ee9					ld a, 'i' 
8ee9					ld (debug_mark),a 
8ee9					pop af 
8ee9			;		CALLMONITOR 
8ee9				endif 
8ee9					pop de 
8ee9					pop hl 
8ee9				if DEBUG_INPUT 
8ee9					push af 
8ee9					ld a, 'I' 
8ee9					ld (debug_mark),a 
8ee9					pop af 
8ee9			;		CALLMONITOR 
8ee9				endif 
8ee9					lddr 
8ee9				 
8ee9			 
8ee9			 
8ee9					; TODO have a key for insert/overwrite mode???? 
8ee9					pop bc 
8ee9					pop hl 
8ee9					ld (hl), c		; otherwise overwrite current char 
8ee9					 
8ee9			 
8ee9			 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9					inc  a 		; TODO check overflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.endinput:	; TODO look for end of string 
8ee9			 
8ee9					; add trailing space for end of token 
8ee9			 
8ee9					ld hl, (input_start) 
8ee9					ld a,(input_len) 
8ee9					call addatohl 
8ee9					ld a, ' ' 
8ee9					ld (hl),a 
8ee9					; TODO eof of parse marker 
8ee9			 
8ee9					inc hl 
8ee9					ld a, 0 
8ee9					ld (hl),a 
8ee9			 
8ee9			 
8ee9					ret 
8ee9			 
8ee9			.iblank: db " ",0 
8ee9			 
8ee9			 
8ee9			input_str_prev:	ld (input_at_pos), a 
8ee9					ld (input_start), hl 
8ee9					ld a,1			; add cursor 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9					ld (input_ptr), hl 
8ee9					ld a,d 
8ee9					ld (input_size), a 
8ee9					ld a,0 
8ee9					ld (input_cursor),a 
8ee9			.instr1:	 
8ee9			 
8ee9					; TODO do block cursor 
8ee9					; TODO switch cursor depending on the modifer key 
8ee9			 
8ee9					; update cursor shape change on key hold 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld a,(cursor_shape) 
8ee9					ld (hl), a 
8ee9			 
8ee9					; display entered text 
8ee9					ld a,(input_at_pos) 
8ee9			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ee9			            	LD   de, (input_start) 
8ee9			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ee9			 
8ee9					call cin 
8ee9					cp 0 
8ee9					jr z, .instr1 
8ee9			 
8ee9					; proecess keyboard controls first 
8ee9			 
8ee9					ld hl,(input_ptr) 
8ee9			 
8ee9					cp KEY_CR	 ; pressing enter ends input 
8ee9					jr z, .instrcr 
8ee9			 
8ee9					cp KEY_BS 	; back space 
8ee9					jr nz, .instr2 
8ee9					; process back space 
8ee9			 
8ee9					; TODO stop back space if at start of string 
8ee9					dec hl 
8ee9					dec hl ; to over write cursor 
8ee9					ld a,(cursor_shape) 
8ee9					;ld a,0 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a," " 
8ee9					ld (hl),a 
8ee9					ld (input_ptr),hl 
8ee9					 
8ee9			 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr2:	cp KEY_LEFT    ; cursor left 
8ee9					jr nz, .instr3 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9				 
8ee9			.instr3:	cp KEY_RIGHT      ; cursor right 
8ee9					jr nz, .instr4 
8ee9					inc hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr4:	cp KEY_HOME    ; jump to start of line 
8ee9					jr nz, .instr5 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr5:	cp KEY_END     ; jump to end of line 
8ee9					jr nz, .instr6 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			.instr6:        cp KEY_UP      ; recall last command 
8ee9					jr nz, .instrnew 
8ee9			 
8ee9				ld hl, scratch 
8ee9				ld de, os_last_cmd 
8ee9				call strcpy 
8ee9					jr .instr1 
8ee9			 
8ee9			 
8ee9			.instrnew:	; no special key pressed to see if we have room to store it 
8ee9			 
8ee9					; TODO do string size test 
8ee9			 
8ee9					dec hl ; to over write cursor 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,(cursor_shape) 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9			 
8ee9					ld (input_ptr),hl 
8ee9					 
8ee9					jr .instr1 
8ee9			.instrcr:	dec hl		; remove cursor 
8ee9					ld a,' '	; TODO add a trailing space for safety 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9			 
8ee9			 
8ee9					; if at end of line scroll up    
8ee9					; TODO detecting only end of line 4 for scroll up  
8ee9			 
8ee9					;ld   
8ee9			 
8ee9					ret 
8ee9			 
8ee9			 
8ee9			endif 
8ee9			; strcpy hl = dest, de source 
8ee9			 
8ee9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8eea b7			            OR   A              ;Null terminator? 
8eeb c8			            RET  Z              ;Yes, so finished 
8eec 1a					ld a,(de) 
8eed 77					ld (hl),a 
8eee 13			            INC  DE             ;Point to next character 
8eef 23					inc hl 
8ef0 18 f7		            JR   strcpy       ;Repeat 
8ef2 c9					ret 
8ef3			 
8ef3			 
8ef3			; TODO string_at  
8ef3			; pass string which starts with lcd offset address and then null term string 
8ef3			 
8ef3			; TODO string to dec 
8ef3			; TODO string to hex 
8ef3			; TODO byte to string hex 
8ef3			; TODO byte to string dec 
8ef3			 
8ef3			 
8ef3			 
8ef3			; from z80uartmonitor 
8ef3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ef3			; pass hl for where to put the text 
8ef3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef3 c5			hexout:	PUSH BC 
8ef4 f5					PUSH AF 
8ef5 47					LD B, A 
8ef6					; Upper nybble 
8ef6 cb 3f				SRL A 
8ef8 cb 3f				SRL A 
8efa cb 3f				SRL A 
8efc cb 3f				SRL A 
8efe cd 0e 8f				CALL tohex 
8f01 77					ld (hl),a 
8f02 23					inc hl	 
8f03					 
8f03					; Lower nybble 
8f03 78					LD A, B 
8f04 e6 0f				AND 0FH 
8f06 cd 0e 8f				CALL tohex 
8f09 77					ld (hl),a 
8f0a 23					inc hl	 
8f0b					 
8f0b f1					POP AF 
8f0c c1					POP BC 
8f0d c9					RET 
8f0e					 
8f0e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0e			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f0e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0e			tohex: 
8f0e e5					PUSH HL 
8f0f d5					PUSH DE 
8f10 16 00				LD D, 0 
8f12 5f					LD E, A 
8f13 21 1b 8f				LD HL, .DATA 
8f16 19					ADD HL, DE 
8f17 7e					LD A, (HL) 
8f18 d1					POP DE 
8f19 e1					POP HL 
8f1a c9					RET 
8f1b			 
8f1b			.DATA: 
8f1b 30					DEFB	30h	; 0 
8f1c 31					DEFB	31h	; 1 
8f1d 32					DEFB	32h	; 2 
8f1e 33					DEFB	33h	; 3 
8f1f 34					DEFB	34h	; 4 
8f20 35					DEFB	35h	; 5 
8f21 36					DEFB	36h	; 6 
8f22 37					DEFB	37h	; 7 
8f23 38					DEFB	38h	; 8 
8f24 39					DEFB	39h	; 9 
8f25 41					DEFB	41h	; A 
8f26 42					DEFB	42h	; B 
8f27 43					DEFB	43h	; C 
8f28 44					DEFB	44h	; D 
8f29 45					DEFB	45h	; E 
8f2a 46					DEFB	46h	; F 
8f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f2b			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f2b			;;    subtract $30, if result > 9 then subtract $7 more 
8f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f2b			atohex: 
8f2b d6 30				SUB $30 
8f2d fe 0a				CP 10 
8f2f f8					RET M		; If result negative it was 0-9 so we're done 
8f30 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f32 c9					RET		 
8f33			 
8f33			 
8f33			 
8f33			 
8f33			; Get 2 ASCII characters as hex byte from pointer in hl 
8f33			 
8f33			BYTERD: 
8f33 16 00			LD	D,00h		;Set up 
8f35 cd 3d 8f			CALL	HEXCON		;Get byte and convert to hex 
8f38 87				ADD	A,A		;First nibble so 
8f39 87				ADD	A,A		;multiply by 16 
8f3a 87				ADD	A,A		; 
8f3b 87				ADD	A,A		; 
8f3c 57				LD	D,A		;Save hi nibble in D 
8f3d			HEXCON: 
8f3d 7e				ld a, (hl)		;Get next chr 
8f3e 23				inc hl 
8f3f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f41 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f43 38 02			JR	C,NALPHA	;If so miss next bit 
8f45 d6 07			SUB	007h		;Else convert alpha 
8f47			NALPHA: 
8f47 b2				OR	D		;Add hi nibble back 
8f48 c9				RET			; 
8f49			 
8f49			 
8f49			; 
8f49			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f49			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f49			; characters (0-9a-f) are accepted. 
8f49			; 
8f49			;get_word        push    af 
8f49			;                call    get_byte        ; Get the upper byte 
8f49			;                ld      h, a 
8f49			;                call    get_byte        ; Get the lower byte 
8f49			;                ld      l, a 
8f49			;                pop     af 
8f49			;                ret 
8f49			; 
8f49			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f49			; the routine get_nibble is used only valid characters are accepted - the  
8f49			; input routine only accepts characters 0-9a-f. 
8f49			; 
8f49 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f4a 7e					ld a,(hl) 
8f4b 23					inc hl 
8f4c cd 71 8f		                call    nibble2val      ; Get upper nibble 
8f4f cb 07		                rlc     a 
8f51 cb 07		                rlc     a 
8f53 cb 07		                rlc     a 
8f55 cb 07		                rlc     a 
8f57 47			                ld      b, a            ; Save upper four bits 
8f58 7e					ld a,(hl) 
8f59 cd 71 8f		                call    nibble2val      ; Get lower nibble 
8f5c b0			                or      b               ; Combine both nibbles 
8f5d c1			                pop     bc              ; Restore B (and C) 
8f5e c9			                ret 
8f5f			; 
8f5f			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f5f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f5f			; to the serial line interface. The lower 4 bits of A contain the value of  
8f5f			; that particular digit. 
8f5f			; 
8f5f			;get_nibble      ld a,(hl)           ; Read a character 
8f5f			;                call    to_upper        ; Convert to upper case 
8f5f			;                call    is_hex          ; Was it a hex digit? 
8f5f			;                jr      nc, get_nibble  ; No, get another character 
8f5f			 ;               call    nibble2val      ; Convert nibble to value 
8f5f			 ;               call    print_nibble 
8f5f			 ;               ret 
8f5f			; 
8f5f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f5f			; A valid hexadecimal digit is denoted by a set C flag. 
8f5f			; 
8f5f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f5f			;                ret     nc              ; Yes 
8f5f			;                cp      '0'             ; Less than '0'? 
8f5f			;                jr      nc, is_hex_1    ; No, continue 
8f5f			;                ccf                     ; Complement carry (i.e. clear it) 
8f5f			;                ret 
8f5f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f5f			;                ret     c               ; Yes 
8f5f			;                cp      'A'             ; Less than 'A'? 
8f5f			;                jr      nc, is_hex_2    ; No, continue 
8f5f			;                ccf                     ; Yes - clear carry and return 
8f5f			;                ret 
8f5f			;is_hex_2        scf                     ; Set carry 
8f5f			;                ret 
8f5f			; 
8f5f			; Convert a single character contained in A to upper case: 
8f5f			; 
8f5f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f61 d8			                ret     c 
8f62 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f64 d0			                ret     nc              ; Nothing to do, either 
8f65 e6 5f		                and     $5f             ; Convert to upper case 
8f67 c9			                ret 
8f68			 
8f68			 
8f68			to_lower: 
8f68			 
8f68			   ; if char is in [A-Z] make it lower case 
8f68			 
8f68			   ; enter : a = char 
8f68			   ; exit  : a = lower case char 
8f68			   ; uses  : af 
8f68			 
8f68 fe 41		   cp 'A' 
8f6a d8			   ret c 
8f6b			    
8f6b fe 5b		   cp 'Z'+1 
8f6d d0			   ret nc 
8f6e			    
8f6e f6 20		   or $20 
8f70 c9			   ret 
8f71			 
8f71			; 
8f71			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f71			; corresponding value in A. 
8f71			; 
8f71 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f73 38 02		                jr      c, nibble2val_1 ; Yes 
8f75 d6 07		                sub     7               ; Adjust for A-F 
8f77 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f79 e6 0f		                and     $f              ; Only return lower 4 bits 
8f7b c9			                ret 
8f7c			; 
8f7c			; Print_nibble prints a single hex nibble which is contained in the lower  
8f7c			; four bits of A: 
8f7c			; 
8f7c			;print_nibble    push    af              ; We won't destroy the contents of A 
8f7c			;                and     $f              ; Just in case... 
8f7c			;                add     a, '0'             ; If we have a digit we are done here. 
8f7c			;                cp      '9' + 1         ; Is the result > 9? 
8f7c			;                jr      c, print_nibble_1 
8f7c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f7c			;print_nibble_1  call    putc            ; Print the nibble and 
8f7c			;                pop     af              ; restore the original value of A 
8f7c			;                ret 
8f7c			;; 
8f7c			;; Send a CR/LF pair: 
8f7c			; 
8f7c			;crlf            push    af 
8f7c			;                ld      a, cr 
8f7c			;                call    putc 
8f7c			;                ld      a, lf 
8f7c			;                call    putc 
8f7c			;                pop     af 
8f7c			;                ret 
8f7c			; 
8f7c			; Print_word prints the four hex digits of a word to the serial line. The  
8f7c			; word is expected to be in HL. 
8f7c			; 
8f7c			;print_word      push    hl 
8f7c			;                push    af 
8f7c			;                ld      a, h 
8f7c			;                call    print_byte 
8f7c			;                ld      a, l 
8f7c			;                call    print_byte 
8f7c			;                pop     af 
8f7c			;                pop     hl 
8f7c			;                ret 
8f7c			; 
8f7c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f7c			; The byte to be printed is expected to be in A. 
8f7c			; 
8f7c			;print_byte      push    af              ; Save the contents of the registers 
8f7c			;                push    bc 
8f7c			;                ld      b, a 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                call    print_nibble    ; Print high nibble 
8f7c			;                ld      a, b 
8f7c			;                call    print_nibble    ; Print low nibble 
8f7c			;                pop     bc              ; Restore original register contents 
8f7c			;                pop     af 
8f7c			;                ret 
8f7c			 
8f7c			 
8f7c			 
8f7c			 
8f7c			 
8f7c			fourehexhl:  
8f7c 7e				ld a,(hl) 
8f7d cd 2b 8f			call atohex 
8f80 cb 3f				SRL A 
8f82 cb 3f				SRL A 
8f84 cb 3f				SRL A 
8f86 cb 3f				SRL A 
8f88 47				ld b, a 
8f89 23				inc hl 
8f8a 7e				ld a,(hl) 
8f8b 23				inc hl 
8f8c cd 2b 8f			call atohex 
8f8f 80				add b 
8f90 57				ld d,a 
8f91 7e				ld a,(hl) 
8f92 cd 2b 8f			call atohex 
8f95 cb 3f				SRL A 
8f97 cb 3f				SRL A 
8f99 cb 3f				SRL A 
8f9b cb 3f				SRL A 
8f9d 47				ld b, a 
8f9e 23				inc hl 
8f9f 7e				ld a,(hl) 
8fa0 23				inc hl 
8fa1 cd 2b 8f			call atohex 
8fa4 80				add b 
8fa5 5f				ld e, a 
8fa6 d5				push de 
8fa7 e1				pop hl 
8fa8 c9				ret 
8fa9			 
8fa9			; pass hl. returns z set if the byte at hl is a digit 
8fa9			;isdigithl:  
8fa9			;	push bc 
8fa9			;	ld a,(hl) 
8fa9			;	cp ':' 
8fa9			;	jr nc, .isdf 		; > 
8fa9			;	cp '0' 
8fa9			;	jr c, .isdf		; < 
8fa9			; 
8fa9			;	; TODO find a better way to set z 
8fa9			; 
8fa9			;	ld b,a 
8fa9			;	cp b 
8fa9			;	pop bc 
8fa9			;	ret 
8fa9			; 
8fa9			;.isdf:	; not digit so clear z 
8fa9			; 
8fa9			;	; TODO find a better way to unset z 
8fa9			; 
8fa9			;	ld b,a 
8fa9			;	inc b 
8fa9			;	cp b 
8fa9			; 
8fa9			;	pop bc 
8fa9			;	ret 
8fa9				 
8fa9				 
8fa9			 
8fa9			 
8fa9			; pass hl as the four byte address to load 
8fa9			 
8fa9			get_word_hl:  
8fa9 e5				push hl 
8faa cd 49 8f			call get_byte 
8fad				 
8fad 47				ld b, a 
8fae			 
8fae e1				pop hl 
8faf 23				inc hl 
8fb0 23				inc hl 
8fb1			 
8fb1			; TODO not able to handle a-f  
8fb1 7e				ld a,(hl) 
8fb2			;	;cp ':' 
8fb2			;	cp 'g' 
8fb2			;	jr nc, .single_byte_hl 		; > 
8fb2			;	cp 'G' 
8fb2			;	jr nc, .single_byte_hl 		; > 
8fb2			;	cp '0' 
8fb2			;	jr c, .single_byte_hl		; < 
8fb2			 
8fb2				;call isdigithl 
8fb2 fe 00			cp 0 
8fb4 28 06			jr z, .single_byte_hl 
8fb6			 
8fb6			.getwhln:   ; hex word so get next byte 
8fb6			 
8fb6 cd 49 8f			call get_byte 
8fb9 6f				ld l, a 
8fba 60				ld h,b 
8fbb c9				ret 
8fbc 68			.single_byte_hl:   ld l,b 
8fbd 26 00				ld h,0 
8fbf c9					ret 
8fc0			 
8fc0			 
8fc0			 
8fc0			 
8fc0 21 60 97			ld hl,asc+1 
8fc3			;	ld a, (hl) 
8fc3			;	call nibble2val 
8fc3 cd 49 8f			call get_byte 
8fc6			 
8fc6			;	call fourehexhl 
8fc6 32 ef e2			ld (scratch+52),a 
8fc9				 
8fc9 21 ed e2			ld hl,scratch+50 
8fcc 22 de e5			ld (os_cur_ptr),hl 
8fcf			 
8fcf c9				ret 
8fd0			 
8fd0			 
8fd0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fd0			 
8fd0			; Decimal Unsigned Version 
8fd0			 
8fd0			;Number in a to decimal ASCII 
8fd0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fd0			;Example: display a=56 as "056" 
8fd0			;input: a = number 
8fd0			;Output: a=0,value of a in the screen 
8fd0			;destroys af,bc (don't know about hl and de) 
8fd0			DispAToASCII: 
8fd0 0e 9c			ld	c,-100 
8fd2 cd dc 8f			call	.Na1 
8fd5 0e f6			ld	c,-10 
8fd7 cd dc 8f			call	.Na1 
8fda 0e ff			ld	c,-1 
8fdc 06 2f		.Na1:	ld	b,'0'-1 
8fde 04			.Na2:	inc	b 
8fdf 81				add	a,c 
8fe0 38 fc			jr	c,.Na2 
8fe2 91				sub	c		;works as add 100/10/1 
8fe3 f5				push af		;safer than ld c,a 
8fe4 78				ld	a,b		;char is in b 
8fe5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fe5 f1				pop af		;safer than ld a,c 
8fe6 c9				ret 
8fe7			 
8fe7			; Decimal Signed Version 
8fe7			 
8fe7			; DispA 
8fe7			; -------------------------------------------------------------- 
8fe7			; Converts a signed integer value to a zero-terminated ASCII 
8fe7			; string representative of that value (using radix 10). 
8fe7			; -------------------------------------------------------------- 
8fe7			; INPUTS: 
8fe7			;     HL     Value to convert (two's complement integer). 
8fe7			;     DE     Base address of string destination. (pointer). 
8fe7			; -------------------------------------------------------------- 
8fe7			; OUTPUTS: 
8fe7			;     None 
8fe7			; -------------------------------------------------------------- 
8fe7			; REGISTERS/MEMORY DESTROYED 
8fe7			; AF HL 
8fe7			; -------------------------------------------------------------- 
8fe7			 
8fe7			;DispHLToASCII: 
8fe7			;   push    de 
8fe7			;   push    bc 
8fe7			; 
8fe7			;; Detect sign of HL. 
8fe7			;    bit    7, h 
8fe7			;    jr     z, ._DoConvert 
8fe7			; 
8fe7			;; HL is negative. Output '-' to string and negate HL. 
8fe7			;    ld     a, '-' 
8fe7			;    ld     (de), a 
8fe7			;    inc    de 
8fe7			; 
8fe7			;; Negate HL (using two's complement) 
8fe7			;    xor    a 
8fe7			;    sub    l 
8fe7			;    ld     l, a 
8fe7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fe7			;    sbc    a, h 
8fe7			;    ld     h, a 
8fe7			; 
8fe7			;; Convert HL to digit characters 
8fe7			;._DoConvert: 
8fe7			;    ld     b, 0     ; B will count character length of number 
8fe7			;-   ld     a, 10 
8fe7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fe7			;    push   af 
8fe7			;    inc    b 
8fe7			;    ld     a, h 
8fe7			;    or     l 
8fe7			;    jr     nz, - 
8fe7			; 
8fe7			;; Retrieve digits from stack 
8fe7			;-   pop    af 
8fe7			;    or     $30 
8fe7			;    ld     (de), a 
8fe7			;    inc    de 
8fe7			;    djnz   - 
8fe7			; 
8fe7			;; Terminate string with NULL 
8fe7			;    xor    a 
8fe7			;    ld     (de), a 
8fe7			; 
8fe7			;    pop    bc 
8fe7			;    pop    de 
8fe7			;    ret 
8fe7			 
8fe7			;Comments 
8fe7			; 
8fe7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fe7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fe7			;    Note that the output string will not be fixed-width. 
8fe7			; 
8fe7			;Example Usage 
8fe7			; 
8fe7			;    ld    hl, -1004 
8fe7			;    ld    de, OP1 
8fe7			;    call  DispA 
8fe7			;    ld    hl, OP1 
8fe7			;    syscall  PutS 
8fe7			 
8fe7			 
8fe7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fe7			 
8fe7			 
8fe7			;Converts an ASCII string to an unsigned 16-bit integer 
8fe7			;Quits when it reaches a non-decimal digit 
8fe7			 
8fe7			string_to_uint16: 
8fe7			atoui_16: 
8fe7			;Input: 
8fe7			;     DE points to the string 
8fe7			;Outputs: 
8fe7			;     HL is the result 
8fe7			;     A is the 8-bit value of the number 
8fe7			;     DE points to the byte after the number 
8fe7			;Destroys: 
8fe7			;     BC 
8fe7			;       if the string is non-empty, BC is HL/10 
8fe7			;Size:  24 bytes 
8fe7			;Speed: 42+d(104+{0,9}) 
8fe7			;       d is the number of digits in the number 
8fe7			;       max is 640 cycles for a 5 digit number 
8fe7			;Assuming no leading zeros: 
8fe7			;1 digit:  146cc 
8fe7			;2 digit:  250cc 
8fe7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fe7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fe7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fe7			;avg: 544.81158447265625cc (544+13297/16384) 
8fe7			;=============================================================== 
8fe7 21 00 00		  ld hl,0 
8fea			.u16a: 
8fea 1a			  ld a,(de) 
8feb d6 30		  sub 30h 
8fed fe 0a		  cp 10 
8fef d0			  ret nc 
8ff0 13			  inc de 
8ff1 44			  ld b,h 
8ff2 4d			  ld c,l 
8ff3 29			  add hl,hl 
8ff4 29			  add hl,hl 
8ff5 09			  add hl,bc 
8ff6 29			  add hl,hl 
8ff7 85			  add a,l 
8ff8 6f			  ld l,a 
8ff9 30 ef		  jr nc,.u16a 
8ffb 24			  inc h 
8ffc c3 ea 8f		  jp .u16a 
8fff			 
8fff			 
8fff			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fff			 
8fff			;written by Zeda 
8fff			;Converts a 16-bit unsigned integer to an ASCII string. 
8fff			 
8fff			uitoa_16: 
8fff			;Input: 
8fff			;   DE is the number to convert 
8fff			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8fff			;Output: 
8fff			;   HL points to the null-terminated ASCII string 
8fff			;      NOTE: This isn't necessarily the same as the input HL. 
8fff d5			  push de 
9000 c5			  push bc 
9001 f5			  push af 
9002 eb			  ex de,hl 
9003			 
9003 01 f0 d8		  ld bc,-10000 
9006 3e 2f		  ld a,'0'-1 
9008 3c			  inc a 
9009 09			  add hl,bc  
900a 38 fc		   jr c,$-2 
900c 12			  ld (de),a 
900d 13			  inc de 
900e			 
900e 01 e8 03		  ld bc,1000 
9011 3e 3a		  ld a,'9'+1 
9013 3d			  dec a  
9014 09			  add hl,bc  
9015 30 fc		   jr nc,$-2 
9017 12			  ld (de),a 
9018 13			  inc de 
9019			 
9019 01 9c ff		  ld bc,-100 
901c 3e 2f		  ld a,'0'-1 
901e 3c			  inc a  
901f 09			  add hl,bc  
9020 38 fc		   jr c,$-2 
9022 12			  ld (de),a 
9023 13			  inc de 
9024			 
9024 7d			  ld a,l 
9025 26 3a		  ld h,'9'+1 
9027 25			  dec h  
9028 c6 0a		  add a,10  
902a 30 fb		   jr nc,$-3 
902c c6 30		  add a,'0' 
902e eb			  ex de,hl 
902f 72			  ld (hl),d 
9030 23			  inc hl 
9031 77			  ld (hl),a 
9032 23			  inc hl 
9033 36 00		  ld (hl),0 
9035			 
9035			;Now strip the leading zeros 
9035 0e fa		  ld c,-6 
9037 09			  add hl,bc 
9038 3e 30		  ld a,'0' 
903a 23			  inc hl  
903b be			  cp (hl)  
903c 28 fc		  jr z,$-2 
903e			 
903e			;Make sure that the string is non-empty! 
903e 7e			  ld a,(hl) 
903f b7			  or a 
9040 20 01		  jr nz,.atoub 
9042 2b			  dec hl 
9043			.atoub: 
9043			 
9043 f1			  pop af 
9044 c1			  pop bc 
9045 d1			  pop de 
9046 c9			  ret 
9047			 
9047			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9047			 
9047			toUpper: 
9047			;A is the char. 
9047			;If A is a lowercase letter, this sets it to the matching uppercase 
9047			;18cc or 30cc or 41cc 
9047			;avg: 26.75cc 
9047 fe 61		  cp 'a' 
9049 d8			  ret c 
904a fe 7b		  cp 'z'+1 
904c d0			  ret nc 
904d d6 20		  sub 'a'-'A' 
904f c9			  ret 
9050			 
9050			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9050			 
9050			; String Length 
9050			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9050			 
9050			; Get the length of the null-terminated string starting at $8000 hl 
9050			;    LD     HL, $8000 
9050			 
9050			strlenz: 
9050			 
9050 af			    XOR    A               ; Zero is the value we are looking for. 
9051 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9052 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9053			                           ; 65, 536 bytes (the entire addressable memory space). 
9053 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9055			 
9055			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9055 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9056 6f			    LD     L, A             ; number of bytes 
9057 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9059 2b			    DEC    HL              ; Compensate for null. 
905a c9				ret 
905b			 
905b			; Get the length of the A terminated string starting at $8000 hl 
905b			;    LD     HL, $8000 
905b			 
905b			strlent: 
905b			 
905b			                  ; A is the value we are looking for. 
905b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
905d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
905f			                           ; 65, 536 bytes (the entire addressable memory space). 
905f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9061			 
9061			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9061 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9063 2e 00		    LD     L, 0             ; number of bytes 
9065 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9067 2b			    DEC    HL              ; Compensate for null. 
9068 c9				ret 
9069			 
9069			 
9069			;Comparing Strings 
9069			 
9069			;IN    HL     Address of string1. 
9069			;      DE     Address of string2. 
9069			 
9069			; doc given but wrong??? 
9069			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9069			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9069			; tested 
9069			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9069			 
9069			strcmp_old: 
9069 e5			    PUSH   HL 
906a d5			    PUSH   DE 
906b			 
906b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
906c be			    CP     (HL)            ; (want to minimize work). 
906d 38 01		    JR     C, Str1IsBigger 
906f 7e			    LD     A, (HL) 
9070			 
9070			Str1IsBigger: 
9070 4f			    LD     C, A             ; Put length in BC 
9071 06 00		    LD     B, 0 
9073 13			    INC    DE              ; Increment pointers to meat of string. 
9074 23			    INC    HL 
9075			 
9075			CmpLoop: 
9075 1a			    LD     A, (DE)          ; Compare bytes. 
9076 ed a1		    CPI 
9078 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
907a 13			    INC    DE              ; Update pointer. 
907b ea 75 90		    JP     PE, CmpLoop 
907e			 
907e d1			    POP    DE 
907f e1			    POP    HL 
9080 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9081 be			    CP     (HL) 
9082 c9			    RET 
9083			 
9083			NoMatch: 
9083 2b			    DEC    HL 
9084 be			    CP     (HL)            ; Compare again to affect carry. 
9085 d1			    POP    DE 
9086 e1			    POP    HL 
9087 c9			    RET 
9088			 
9088			;; test strmp 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str2 
9088			;call strcmp 
9088			;jr z, .z1 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "NZ1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.z1: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "ZZ1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str1 
9088			;call strcmp 
9088			;jr z, .z2 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "NZ2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.z2: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "ZZ2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str2 
9088			;call strcmp 
9088			;jr c, .c1 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "Nc1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.c1: 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "cc1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str1 
9088			;call strcmp 
9088			;jr c, .c2 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "Nc2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.c2: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "cc2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;	NEXTW 
9088			;.str1:   db "string1",0 
9088			;.str2:   db "string2",0 
9088			 
9088			; only care about direct match or not 
9088			; hl and de strings 
9088			; zero set if the same 
9088			 
9088			strcmp: 
9088 1a				ld a, (de) 
9089 be				cp (hl) 
908a 28 02			jr z, .ssame 
908c b7				or a 
908d c9				ret 
908e			 
908e			.ssame:  
908e fe 00			cp 0 
9090 c8				ret z 
9091			 
9091 23				inc hl 
9092 13				inc de 
9093 18 f3			jr strcmp 
9095				 
9095				 
9095			 
9095			;Copyright (c) 2014, Luke Maurits 
9095			;All rights reserved. 
9095			; 
9095			;Redistribution and use in source and binary forms, with or without 
9095			;modification, are permitted provided that the following conditions are met: 
9095			; 
9095			;* Redistributions of source code must retain the above copyright notice, this 
9095			;  list of conditions and the following disclaimer. 
9095			; 
9095			;* Redistributions in binary form must reproduce the above copyright notice, 
9095			;  this list of conditions and the following disclaimer in the documentation 
9095			;  and/or other materials provided with the distribution. 
9095			; 
9095			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9095			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9095			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9095			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9095			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9095			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9095			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9095			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9095			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9095			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9095			 
9095			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9095			 
9095			StrictStrCmp: 
9095				; Load next chars of each string 
9095 1a				ld a, (de) 
9096 47				ld b, a 
9097 7e				ld a, (hl) 
9098				; Compare 
9098 b8				cp b 
9099				; Return non-zero if chars don't match 
9099 c0				ret nz 
909a				; Check for end of both strings 
909a fe 00			cp "\0" 
909c				; Return if strings have ended 
909c c8				ret z 
909d				; Otherwise, advance to next chars 
909d 23				inc hl 
909e 13				inc de 
909f 18 f4			jr StrictStrCmp 
90a1			 
90a1			;end 
90a1			; eof 
90a1			 
90a1			 
90a1			 
90a1			 
90a1			 
90a1			 
# End of file firmware_strings.asm
90a1			include "firmware_memory.asm"   ; malloc and free  
90a1			 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			.mallocsize: db "Wants malloc >256",0 
90a1			.mallocasize: db "MALLOC gives >256",0 
90a1			.malloczero: db "MALLOC gives zero",0 
90a1			 
90a1			malloc_guard_zerolen: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1				ld de, 0 
90a1			        call cmp16 
90a1				jr nz, .lowalloz 
90a1			 
90a1				push hl 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .malloczero 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1				call bp_on 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1			 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				 
90a1			 
90a1				CALLMONITOR 
90a1			.lowalloz: 
90a1			 
90a1			 
90a1				pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			 
90a1			malloc_guard_entry: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1			 	or a      ;clear carry flag 
90a1				push hl 
90a1				ld de, 255 
90a1				sbc hl, de 
90a1				jr c, .lowalloc 
90a1			 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .mallocsize 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1				call bp_on 
90a1			 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				 
90a1			 
90a1				CALLMONITOR 
90a1				jr .lowdone 
90a1			.lowalloc: 
90a1			 
90a1			 
90a1				pop hl 
90a1			.lowdone:	pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			 
90a1			malloc_guard_exit: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1			 	or a      ;clear carry flag 
90a1				push hl 
90a1				ld de, 255 
90a1				sbc hl, de 
90a1				jr c, .lowallocx 
90a1			 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .mallocasize 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1				call bp_on 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				CALLMONITOR 
90a1				jr .lowdonex 
90a1			.lowallocx: 
90a1			 
90a1				pop hl 
90a1			.lowdonex:	pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			endif 
90a1			 
90a1			if MALLOC_2 
90a1			; Z80 Malloc and Free Functions 
90a1			 
90a1			; Malloc Function: 
90a1			; Input: 
90a1			;   HL: Size of block to allocate 
90a1			; Output: 
90a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90a1			 
90a1			malloc: 
90a1				 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			call malloc_guard_entry 
90a1			endif 
90a1			 
90a1			 
90a1			 
90a1			 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "mal" 
90a1						CALLMONITOR 
90a1					endif 
90a1			    push af            ; Save AF register 
90a1			    ld a, l            ; Load low byte of size into A 
90a1			    or h               ; Check if size is zero 
90a1			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
90a1			 
90a1			    ; Allocate memory 
90a1			    ld hl, (heap_start) ; Load start of heap into HL 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma1" 
90a1						CALLMONITOR 
90a1					endif 
90a1			    call malloc_internal ; Call internal malloc function 
90a1			    pop af             ; Restore AF register 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret                ; Return 
90a1			 
90a1			; Free Function: 
90a1			; Input: 
90a1			;   HL: Pointer to memory block to free 
90a1			; Output: 
90a1			;   None 
90a1			 
90a1			free: 
90a1			    push af            ; Save AF register 
90a1			    ld a, l            ; Load low byte of pointer into A 
90a1			    or h               ; Check if pointer is NULL 
90a1			    jp z, free_exit    ; If pointer is NULL, exit 
90a1			 
90a1			    ; Free memory 
90a1			    ld hl, (heap_start) ; Load start of heap into HL 
90a1			    call free_internal  ; Call internal free function 
90a1			    pop af             ; Restore AF register 
90a1			    ret                ; Return 
90a1			 
90a1			; Internal Malloc Function: 
90a1			; Input: 
90a1			;   HL: Size of block to allocate 
90a1			; Output: 
90a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90a1			 
90a1			malloc_internal: 
90a1			    ld bc, 2           ; Number of bytes to allocate for management overhead 
90a1			    add hl, bc         ; Add management overhead to requested size 
90a1			    ex de, hl          ; Save total size in DE, and keep it in HL 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma2" 
90a1						CALLMONITOR 
90a1					endif 
90a1			 
90a1			    ; Search for free memory block 
90a1			    ld de, (heap_end)  ; Load end of heap into DE 
90a1			    ld bc, 0           ; Initialize counter 
90a1			 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma2" 
90a1						CALLMONITOR 
90a1					endif 
90a1			malloc_search_loop: 
90a1			    ; Check if current block is free 
90a1			    ld a, (hl)         ; Load current block's status (free or used) 
90a1			    cp 0               ; Compare with zero (free) 
90a1			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
90a1			 
90a1			    ; Check if current block is large enough 
90a1			    ld a, (hl+1)       ; Load high byte of block size 
90a1			    cp l               ; Compare with low byte of requested size 
90a1			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
90a1			 
90a1			    ld a, (hl+2)       ; Load low byte of block size 
90a1			    cp h               ; Compare with high byte of requested size 
90a1			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
90a1			 
90a1			    ; Mark block as used 
90a1			    ld (hl), 0xFF      ; Set status byte to indicate used block 
90a1			 
90a1			    ; Calculate remaining space in block 
90a1			    ld bc, 0           ; Clear BC 
90a1			    add hl, bc         ; Increment HL to point to start of data block 
90a1			    add hl, de         ; HL = HL + DE (total size) 
90a1			    ld bc, 1           ; Number of bytes to allocate for management overhead 
90a1			    add hl, bc         ; Add management overhead to start of data block 
90a1			 
90a1			    ; Save pointer to allocated block in HL 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma5" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			 
90a1			malloc_skip_block_check: 
90a1			    ; Move to the next block 
90a1			    ld bc, 3           ; Size of management overhead 
90a1			    add hl, bc         ; Move to the next block 
90a1			    inc de             ; Increment counter 
90a1			 
90a1			    ; Check if we have reached the end of heap 
90a1			    ld a, e            ; Load low byte of heap end address 
90a1			    cp (hl)            ; Compare with low byte of current address 
90a1			    jr nz, malloc_search_loop  ; If not equal, continue searching 
90a1			    ld a, d            ; Load high byte of heap end address 
90a1			    cp 0               ; Check if it's zero (end of memory) 
90a1			    jr nz, malloc_search_loop  ; If not zero, continue searching 
90a1			 
90a1			    ; If we reached here, allocation failed 
90a1			    xor a              ; Set result to NULL 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma6" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			malloc_exit: 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma7" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			 
90a1			; Internal Free Function: 
90a1			; Input: 
90a1			;   HL: Pointer to memory block to free 
90a1			; Output: 
90a1			;   None 
90a1			 
90a1			free_internal: 
90a1			    ld de, (heap_start) ; Load start of heap into DE 
90a1			    ld bc, 0            ; Initialize counter 
90a1			 
90a1			free_search_loop: 
90a1			    ; Check if current block contains the pointer 
90a1			    ld a, l             ; Load low byte of pointer 
90a1			    cp (hl+1)           ; Compare with high byte of current block's address 
90a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90a1			    ld a, h             ; Load high byte of pointer 
90a1			    cp (hl+2)           ; Compare with low byte of current block's address 
90a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90a1			 
90a1			    ; Mark block as free 
90a1			    ld (hl), 0          ; Set status byte to indicate free block 
90a1			    ret                 ; Return 
90a1			 
90a1			free_skip_block_check: 
90a1			    ; Move to the next block 
90a1			    ld bc, 3            ; Size of management overhead 
90a1			    add hl, bc          ; Move to the next block 
90a1			    inc de              ; Increment counter 
90a1			 
90a1			    ; Check if we have reached the end of heap 
90a1			    ld a, e             ; Load low byte of heap end address 
90a1			    cp (hl)             ; Compare with low byte of current address 
90a1			    jr nz, free_search_loop  ; If not equal, continue searching 
90a1			    ld a, d             ; Load high byte of heap end address 
90a1			    cp 0                ; Check if it's zero (end of memory) 
90a1			    jr nz, free_search_loop  ; If not zero, continue searching 
90a1			 
90a1			    ; If we reached here, pointer is not found in heap 
90a1			    ret 
90a1			 
90a1			free_exit: 
90a1			    ret                 ; Return 
90a1			 
90a1			; Define heap start and end addresses 
90a1			;heap_start:    .dw 0xC000   ; Start of heap 
90a1			;heap_end:      .dw 0xE000   ; End of heap 
90a1			 
90a1			endif 
90a1			 
90a1			 
90a1			if MALLOC_1 
90a1			 
90a1			 
90a1			 
90a1			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
90a1			 
90a1			;moved to firmware.asm 
90a1			;heap_start        .equ  0x9000      ; Starting address of heap 
90a1			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
90a1			 
90a1			;      .org 0 
90a1			;      jp    main 
90a1			 
90a1			 
90a1			;      .org  0x100 
90a1			;main: 
90a1			;      ld    HL, 0x8100 
90a1			;      ld    SP, HL 
90a1			; 
90a1			;      call  heap_init 
90a1			; 
90a1			;      ; Make some allocations 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9004 
90a1			; 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9014 
90a1			; 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9024 
90a1			; 
90a1			;      ; Free some allocations 
90a1			;      ld    HL, 0x9014 
90a1			;      call  free 
90a1			; 
90a1			;      ld    HL, 0x9004 
90a1			;      call  free 
90a1			; 
90a1			;      ld    HL, 0x9024 
90a1			;      call  free 
90a1			; 
90a1			; 
90a1			;      halt 
90a1			 
90a1			 
90a1			;------------------------------------------------------------------------------ 
90a1			;     heap_init                                                               : 
90a1			;                                                                             : 
90a1			; Description                                                                 : 
90a1			;     Initialise the heap and make it ready for malloc and free operations.   : 
90a1			;                                                                             : 
90a1			;     The heap is maintained as a linked list, starting with an initial       : 
90a1			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
90a1			;     the first free block in the heap. Each block then points to the next    : 
90a1			;     free block within the heap, and the free list ends at the first block   : 
90a1			;     with a null pointer to the next free block.                             : 
90a1			;                                                                             : 
90a1			; Parameters                                                                  : 
90a1			;     Inputs are compile-time only. Two defines which specify the starting    : 
90a1			;     address of the heap and its size are required, along with a memory      : 
90a1			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
90a1			;     principally stores a pointer to the first free block in the heap.       : 
90a1			;                                                                             : 
90a1			; Returns                                                                     : 
90a1			;     Nothing                                                                 : 
90a1			;------------------------------------------------------------------------------ 
90a1			heap_init: 
90a1 e5			      push  HL 
90a2			 
90a2			      ; Initialise free list struct 
90a2 21 a6 df		      ld    HL, heap_start 
90a5 22 a1 df		      ld    (free_list), HL 
90a8 21 00 00		      ld    HL, 0 
90ab 22 a3 df		      ld    (free_list+2), HL 
90ae			 
90ae			      ; Insert first free block at bottom of heap, consumes entire heap 
90ae 21 92 e2		      ld    HL, heap_start+heap_size-4 
90b1 22 a6 df		      ld    (heap_start), HL        ; Next block (end of free list) 
90b4 21 ec 02		      ld    HL, heap_size-4 
90b7 22 a8 df		      ld    (heap_start+2), HL      ; Block size 
90ba			 
90ba			      ; Insert end of free list block at top of heap - two null words will 
90ba			      ; terminate the free list 
90ba 21 00 00		      ld    HL, 0 
90bd 22 94 e2		      ld    (heap_start+heap_size-2), HL 
90c0 22 92 e2		      ld    (heap_start+heap_size-4), HL 
90c3			 
90c3 e1			      pop   HL 
90c4			 
90c4 c9			      ret 
90c5			 
90c5			 
90c5			;------------------------------------------------------------------------------ 
90c5			;     malloc                                                                  : 
90c5			;                                                                             : 
90c5			; Description                                                                 : 
90c5			;     Allocates the wanted space from the heap and returns the address of the : 
90c5			;     first useable byte of the allocation.                                   : 
90c5			;                                                                             : 
90c5			;     Allocations can happen in one of two ways:                              : 
90c5			;                                                                             : 
90c5			;     1. A free block may be found which is the exact size wanted. In this    : 
90c5			;        case the block is removed from the free list and retuedn to the      : 
90c5			;        caller.                                                              : 
90c5			;     2. A free block may be found which is larger than the size wanted. In   : 
90c5			;        this case, the larger block is split into two. The first portion of  : 
90c5			;        this block will become the requested space by the malloc call and    : 
90c5			;        is returned to the caller. The second portion becomes a new free     : 
90c5			;        block, and the free list is adjusted to maintain continuity via this : 
90c5			;        newly created block.                                                 : 
90c5			;                                                                             : 
90c5			;     malloc does not set any initial value in the allocated space, the       : 
90c5			;     caller is required to do this as required.                              : 
90c5			;                                                                             : 
90c5			;     This implementation of malloc uses the stack exclusively, and is        : 
90c5			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c5			;     advisable to disable interrupts before calling malloc, and recommended  : 
90c5			;     to avoid the use of malloc inside ISRs in general.                      : 
90c5			;                                                                             : 
90c5			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c5			;                                                                             : 
90c5			; Parameters                                                                  : 
90c5			;     HL  Number of bytes wanted                                              : 
90c5			;                                                                             : 
90c5			; Returns                                                                     : 
90c5			;     HL  Address of the first useable byte of the allocation                 : 
90c5			;                                                                             : 
90c5			; Flags                                                                       : 
90c5			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90c5			;                                                                             : 
90c5			; Stack frame                                                                 : 
90c5			;       |             |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     BC      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     DE      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     IX      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |  prev_free  |                                                       : 
90c5			;   +4  +-------------+                                                       : 
90c5			;       |  this_free  |                                                       : 
90c5			;   +2  +-------------+                                                       : 
90c5			;       |  next_free  |                                                       : 
90c5			;   +0  +-------------+                                                       : 
90c5			;       |             |                                                       : 
90c5			;                                                                             : 
90c5			;------------------------------------------------------------------------------ 
90c5			 
90c5			 
90c5			;malloc: 
90c5			; 
90c5			;	SAVESP ON 1 
90c5			; 
90c5			;	call malloc_code 
90c5			; 
90c5			;	CHECKSP ON 1 
90c5			;	ret 
90c5			 
90c5			 
90c5			malloc: 
90c5 c5			      push  BC 
90c6 d5			      push  DE 
90c7 dd e5		      push  IX 
90c9			if DEBUG_FORTH_MALLOC_HIGH 
90c9			call malloc_guard_entry 
90c9			endif 
90c9			 
90c9					if DEBUG_FORTH_MALLOC 
90c9						DMARK "mal" 
90c9						CALLMONITOR 
90c9					endif 
90c9 7c			      ld    A, H                    ; Exit if no space requested 
90ca b5			      or    L 
90cb ca 8a 91		      jp    Z, malloc_early_exit 
90ce			 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			; 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			 
90ce			 
90ce			 
90ce			 
90ce					if DEBUG_FORTH_MALLOC 
90ce						DMARK "maA" 
90ce						CALLMONITOR 
90ce					endif 
90ce			      ; Set up stack frame 
90ce eb			      ex    DE, HL 
90cf 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90d2 39			      add   HL, SP 
90d3 f9			      ld    SP, HL 
90d4 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90d8 dd 39		      add   IX, SP 
90da			 
90da			      ; Setup initial state 
90da 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90dd 19			      add   HL, DE 
90de			 
90de 44			      ld    B, H                    ; Move want to BC 
90df 4d			      ld    C, L 
90e0			 
90e0 21 a1 df		      ld    HL, free_list           ; Store prev_free ptr to stack 
90e3 dd 75 04		      ld    (IX+4), L 
90e6 dd 74 05		      ld    (IX+5), H 
90e9			 
90e9 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90ea 23			      inc   HL 
90eb 56			      ld    D, (HL) 
90ec dd 73 02		      ld    (IX+2), E 
90ef dd 72 03		      ld    (IX+3), D 
90f2 eb			      ex    DE, HL                  ; this_free ptr into HL 
90f3			 
90f3					if DEBUG_FORTH_MALLOC 
90f3						DMARK "maB" 
90f3						CALLMONITOR 
90f3					endif 
90f3			      ; Loop through free block list to find some space 
90f3			malloc_find_space: 
90f3 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90f4 23			      inc   HL 
90f5 56			      ld    D, (HL) 
90f6			 
90f6 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90f7 b3			      or    E 
90f8 ca 84 91		      jp    Z, malloc_no_space 
90fb			 
90fb dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90fe dd 72 01		      ld    (IX+1), D 
9101			 
9101			      ; Does this block have enough space to make the allocation? 
9101 23			      inc   HL                      ; Load free block size into DE 
9102 5e			      ld    E, (HL) 
9103 23			      inc   HL 
9104 56			      ld    D, (HL) 
9105			 
9105 eb			      ex    DE, HL                  ; Check size of block against want 
9106 b7			      or    A                       ; Ensure carry flag clear 
9107 ed 42		      sbc   HL, BC 
9109 e5			      push  HL                      ; Store the result for later (new block size) 
910a			 
910a ca 59 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
910d 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
910f			 
910f			      ; this_free block is not big enough, setup ptrs to test next free block 
910f e1			      pop   HL                      ; Discard previous result 
9110			 
9110 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9113 dd 66 03		      ld    H, (IX+3) 
9116 dd 75 04		      ld    (IX+4), L 
9119 dd 74 05		      ld    (IX+5), H 
911c			 
911c dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911f dd 66 01		      ld    H, (IX+1) 
9122 dd 75 02		      ld    (IX+2), L 
9125 dd 74 03		      ld    (IX+3), H 
9128			 
9128					if DEBUG_FORTH_MALLOC 
9128						DMARK "MA>" 
9128						CALLMONITOR 
9128					endif 
9128 18 c9		      jr    malloc_find_space 
912a			 
912a			      ; split a bigger block into two - requested size and remaining size 
912a			malloc_alloc_split: 
912a					if DEBUG_FORTH_MALLOC 
912a						DMARK "MAs" 
912a						CALLMONITOR 
912a					endif 
912a eb			      ex    DE, HL                  ; Calculate address of new free block 
912b 2b			      dec   HL 
912c 2b			      dec   HL 
912d 2b			      dec   HL 
912e 09			      add   HL, BC 
912f			 
912f			      ; Create a new block and point it at next_free 
912f dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9132 dd 56 01		      ld    D, (IX+1) 
9135			 
9135 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9136 23			      inc   HL 
9137 72			      ld    (HL), D 
9138			 
9138 d1			      pop   DE                      ; Store size of new block into new block 
9139 23			      inc   HL 
913a 73			      ld    (HL), E 
913b 23			      inc   HL 
913c 72			      ld    (HL), D 
913d			 
913d			      ; Update this_free ptr to point to new block 
913d 2b			      dec   HL 
913e 2b			      dec   HL 
913f 2b			      dec   HL 
9140			 
9140 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9143 dd 56 03		      ld    D, (IX+3) 
9146			 
9146 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9149 dd 74 03		      ld    (IX+3), H 
914c			 
914c			      ; Modify this_free block to be allocation 
914c eb			      ex    DE, HL 
914d af			      xor   A                       ; Null the next block ptr of allocated block 
914e 77			      ld    (HL), A 
914f 23			      inc   HL 
9150 77			      ld    (HL), A 
9151			 
9151 23			      inc   HL                      ; Store want size into allocated block 
9152 71			      ld    (HL), C 
9153 23			      inc   HL 
9154 70			      ld    (HL), B 
9155 23			      inc   HL 
9156 e5			      push  HL                      ; Address of allocation to return 
9157			 
9157 18 19		      jr    malloc_update_links 
9159			 
9159			malloc_alloc_fit: 
9159 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
915a			 
915a					if DEBUG_FORTH_MALLOC 
915a						DMARK "MAf" 
915a						CALLMONITOR 
915a					endif 
915a			      ; Modify this_free block to be allocation 
915a eb			      ex    DE, HL 
915b 2b			      dec   HL 
915c 2b			      dec   HL 
915d 2b			      dec   HL 
915e			 
915e af			      xor   A                       ; Null the next block ptr of allocated block 
915f 77			      ld    (HL), A 
9160 23			      inc   HL 
9161 77			      ld    (HL), A 
9162			 
9162 23			      inc   HL                      ; Store address of allocation to return 
9163 23			      inc   HL 
9164 23			      inc   HL 
9165 e5			      push  HL 
9166			 
9166			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9166 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9169 dd 66 01		      ld    H, (IX+1) 
916c			 
916c dd 75 02		      ld    (IX+2), L               ; HL to this_free 
916f dd 74 03		      ld    (IX+3), H 
9172			 
9172			 
9172			malloc_update_links: 
9172			      ; Update prev_free ptr to point to this_free 
9172 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9175 dd 66 05		      ld    H, (IX+5) 
9178			 
9178 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
917b dd 56 03		      ld    D, (IX+3) 
917e			 
917e 73			      ld    (HL), E                 ; this_free ptr into prev_free 
917f 23			      inc   HL 
9180 72			      ld    (HL), D 
9181			 
9181					if DEBUG_FORTH_MALLOC 
9181						DMARK "Mul" 
9181						CALLMONITOR 
9181					endif 
9181			      ; Clear the Z flag to indicate successful allocation 
9181 7a			      ld    A, D 
9182 b3			      or    E 
9183			 
9183 d1			      pop   DE                      ; Address of allocation 
9184					if DEBUG_FORTH_MALLOC 
9184						DMARK "MAu" 
9184						CALLMONITOR 
9184					endif 
9184			 
9184			malloc_no_space: 
9184 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9187 39			      add   HL, SP 
9188 f9			      ld    SP, HL 
9189			 
9189 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "MAN" 
918a						CALLMONITOR 
918a					endif 
918a			 
918a			malloc_early_exit: 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "MAx" 
918a						CALLMONITOR 
918a					endif 
918a dd e1		      pop   IX 
918c d1			      pop   DE 
918d c1			      pop   BC 
918e			 
918e			if DEBUG_FORTH_MALLOC_HIGH 
918e			call malloc_guard_exit 
918e			call malloc_guard_zerolen 
918e			endif 
918e c9			      ret 
918f			 
918f			 
918f			;------------------------------------------------------------------------------ 
918f			;     free                                                                    : 
918f			;                                                                             : 
918f			; Description                                                                 : 
918f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
918f			;     returned by malloc, otherwise the behaviour is undefined.               : 
918f			;                                                                             : 
918f			;     Where possible, directly adjacent free blocks will be merged together   : 
918f			;     into larger blocks to help ensure that the heap does not become         : 
918f			;     excessively fragmented.                                                 : 
918f			;                                                                             : 
918f			;     free does not clear or set any other value into the freed space, and    : 
918f			;     therefore its contents may be visible through subsequent malloc's. The  : 
918f			;     caller should clear the freed space as required.                        : 
918f			;                                                                             : 
918f			;     This implementation of free uses the stack exclusively, and is          : 
918f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
918f			;     advisable to disable interrupts before calling free, and recommended    : 
918f			;     to avoid the use of free inside ISRs in general.                        : 
918f			;                                                                             : 
918f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
918f			;                                                                             : 
918f			; Parameters                                                                  : 
918f			;     HL  Pointer to address of first byte of allocation to be freed          : 
918f			;                                                                             : 
918f			; Returns                                                                     : 
918f			;     Nothing                                                                 : 
918f			;                                                                             : 
918f			; Stack frame                                                                 : 
918f			;       |             |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     BC      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     DE      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     IX      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |  prev_free  |                                                       : 
918f			;   +2  +-------------+                                                       : 
918f			;       |  next_free  |                                                       : 
918f			;   +0  +-------------+                                                       : 
918f			;       |             |                                                       : 
918f			;                                                                             : 
918f			;------------------------------------------------------------------------------ 
918f			free: 
918f c5			      push  BC 
9190 d5			      push  DE 
9191 dd e5		      push  IX 
9193			 
9193 7c			      ld    A, H                    ; Exit if ptr is null 
9194 b5			      or    L 
9195 ca 59 92		      jp    Z, free_early_exit 
9198			 
9198			      ; Set up stack frame 
9198 eb			      ex    DE, HL 
9199 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
919c 39			      add   HL, SP 
919d f9			      ld    SP, HL 
919e dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91a2 dd 39		      add   IX, SP 
91a4			 
91a4			      ; The address in HL points to the start of the useable allocated space, 
91a4			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91a4			      ; address of the block itself. 
91a4 eb			      ex    DE, HL 
91a5 11 fc ff		      ld    DE, -4 
91a8 19			      add   HL, DE 
91a9			 
91a9			      ; An allocated block must have a null next block pointer in it 
91a9 7e			      ld    A, (HL) 
91aa 23			      inc   HL 
91ab b6			      or    (HL) 
91ac c2 54 92		      jp    NZ, free_done 
91af			 
91af 2b			      dec   HL 
91b0			 
91b0 44			      ld    B, H                    ; Copy HL to BC 
91b1 4d			      ld    C, L 
91b2			 
91b2			      ; Loop through the free list to find the first block with an address 
91b2			      ; higher than the block being freed 
91b2 21 a1 df		      ld    HL, free_list 
91b5			 
91b5			free_find_higher_block: 
91b5 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91b6 23			      inc   HL 
91b7 56			      ld    D, (HL) 
91b8 2b			      dec   HL 
91b9			 
91b9 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91bc dd 72 01		      ld    (IX+1), D 
91bf dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91c2 dd 74 03		      ld    (IX+3), H 
91c5			 
91c5 78			      ld    A, B                    ; Check if DE is greater than BC 
91c6 ba			      cp    D                       ; Compare MSB first 
91c7 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91c9 30 04		      jr    NC, free_find_higher_block_skip 
91cb 79			      ld    A, C 
91cc bb			      cp    E                       ; Then compare LSB 
91cd 38 08		      jr    C, free_found_higher_block 
91cf			 
91cf			free_find_higher_block_skip: 
91cf 7a			      ld    A, D                    ; Reached the end of the free list? 
91d0 b3			      or    E 
91d1 ca 54 92		      jp    Z, free_done 
91d4			 
91d4 eb			      ex    DE, HL 
91d5			 
91d5 18 de		      jr    free_find_higher_block 
91d7			 
91d7			free_found_higher_block: 
91d7			      ; Insert freed block between prev and next free blocks 
91d7 71			      ld    (HL), C                 ; Point prev free block to freed block 
91d8 23			      inc   HL 
91d9 70			      ld    (HL), B 
91da			 
91da 60			      ld    H, B                    ; Point freed block at next free block 
91db 69			      ld    L, C 
91dc 73			      ld    (HL), E 
91dd 23			      inc   HL 
91de 72			      ld    (HL), D 
91df			 
91df			      ; Check if the freed block is adjacent to the next free block 
91df 23			      inc   HL                      ; Load size of freed block into HL 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3 eb			      ex    DE, HL 
91e4			 
91e4 09			      add   HL, BC                  ; Add addr of freed block and its size 
91e5			 
91e5 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91e8 dd 56 01		      ld    D, (IX+1) 
91eb			 
91eb b7			      or    A                       ; Clear the carry flag 
91ec ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91ee 20 22		      jr    NZ, free_check_adjacent_to_prev 
91f0			 
91f0			      ; Freed block is adjacent to next, merge into one bigger block 
91f0 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91f1 5e			      ld    E, (HL) 
91f2 23			      inc   HL 
91f3 56			      ld    D, (HL) 
91f4 e5			      push  HL                      ; Save ptr to next block for later 
91f5			 
91f5 60			      ld    H, B                    ; Store ptr from next block into freed block 
91f6 69			      ld    L, C 
91f7 73			      ld    (HL), E 
91f8 23			      inc   HL 
91f9 72			      ld    (HL), D 
91fa			 
91fa e1			      pop   HL                      ; Restore ptr to next block 
91fb 23			      inc   HL                      ; Load size of next block into DE 
91fc 5e			      ld    E, (HL) 
91fd 23			      inc   HL 
91fe 56			      ld    D, (HL) 
91ff d5			      push  DE                      ; Save next block size for later 
9200			 
9200 60			      ld    H, B                    ; Load size of freed block into HL 
9201 69			      ld    L, C 
9202 23			      inc   HL 
9203 23			      inc   HL 
9204 5e			      ld    E, (HL) 
9205 23			      inc   HL 
9206 56			      ld    D, (HL) 
9207 eb			      ex    DE, HL 
9208			 
9208 d1			      pop   DE                      ; Restore size of next block 
9209 19			      add   HL, DE                  ; Add sizes of both blocks 
920a eb			      ex    DE, HL 
920b			 
920b 60			      ld    H, B                    ; Store new bigger size into freed block 
920c 69			      ld    L, C 
920d 23			      inc   HL 
920e 23			      inc   HL 
920f 73			      ld    (HL), E 
9210 23			      inc   HL 
9211 72			      ld    (HL), D 
9212			 
9212			free_check_adjacent_to_prev: 
9212			      ; Check if the freed block is adjacent to the prev free block 
9212 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9215 dd 66 03		      ld    H, (IX+3) 
9218			 
9218 23			      inc   HL                      ; Size of prev free block into DE 
9219 23			      inc   HL 
921a 5e			      ld    E, (HL) 
921b 23			      inc   HL 
921c 56			      ld    D, (HL) 
921d 2b			      dec   HL 
921e 2b			      dec   HL 
921f 2b			      dec   HL 
9220			 
9220 19			      add   HL, DE                  ; Add prev block addr and size 
9221			 
9221 b7			      or    A                       ; Clear the carry flag 
9222 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9224 20 2e		      jr    NZ, free_done 
9226			 
9226			      ; Freed block is adjacent to prev, merge into one bigger block 
9226 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9227 69			      ld    L, C 
9228 5e			      ld    E, (HL) 
9229 23			      inc   HL 
922a 56			      ld    D, (HL) 
922b e5			      push  HL                      ; Save freed block ptr for later 
922c			 
922c dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
922f dd 66 03		      ld    H, (IX+3) 
9232 73			      ld    (HL), E 
9233 23			      inc   HL 
9234 72			      ld    (HL), D 
9235			 
9235 e1			      pop   HL                      ; Restore freed block ptr 
9236 23			      inc   HL                      ; Load size of freed block into DE 
9237 5e			      ld    E, (HL) 
9238 23			      inc   HL 
9239 56			      ld    D, (HL) 
923a d5			      push  DE                      ; Save freed block size for later 
923b			 
923b dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
923e dd 66 03		      ld    H, (IX+3) 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 5e			      ld    E, (HL) 
9244 23			      inc   HL 
9245 56			      ld    D, (HL) 
9246			 
9246 e1			      pop   HL                      ; Add sizes of both blocks 
9247 19			      add   HL, DE 
9248 eb			      ex    DE, HL 
9249			 
9249 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
924c dd 66 03		      ld    H, (IX+3) 
924f 23			      inc   HL 
9250 23			      inc   HL 
9251 73			      ld    (HL), E 
9252 23			      inc   HL 
9253 72			      ld    (HL), D 
9254			 
9254			free_done: 
9254 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9257 39			      add   HL, SP 
9258 f9			      ld    SP, HL 
9259			 
9259			free_early_exit: 
9259 dd e1		      pop   IX 
925b d1			      pop   DE 
925c c1			      pop   BC 
925d			 
925d c9			      ret 
925e			 
925e			; moved to firmware.asm 
925e			; 
925e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925e			;                  .dw   0 
925e			 
925e			 
925e			endif 
925e			 
925e			 
925e			if MALLOC_3 
925e			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
925e			;heap_start        .equ  0x9000      ; Starting address of heap 
925e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
925e			; 
925e			 ;     .org 0 
925e			  ;    jp    main 
925e			; 
925e			; 
925e			 ;     .org  0x100 
925e			;main: 
925e			 ;     ld    HL, 0x8100 
925e			  ;    ld    SP, HL 
925e			; 
925e			;      call  heap_init 
925e			 
925e			      ; Make some allocations 
925e			;      ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9004 
925e			; 
925e			 ;     ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9014 
925e			 
925e			;      ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9024 
925e			 
925e			      ; Free some allocations 
925e			;      ld    HL, 0x9014 
925e			;      call  free 
925e			 
925e			;      ld    HL, 0x9004 
925e			;      call  free 
925e			; 
925e			;      ld    HL, 0x9024 
925e			;      call  free 
925e			 
925e			 
925e			 ;     halt 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     heap_init                                                               : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Initialise the heap and make it ready for malloc and free operations.   : 
925e			;                                                                             : 
925e			;     The heap is maintained as a linked list, starting with an initial       : 
925e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
925e			;     the first free block in the heap. Each block then points to the next    : 
925e			;     free block within the heap, and the free list ends at the first block   : 
925e			;     with a null pointer to the next free block.                             : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     Inputs are compile-time only. Two defines which specify the starting    : 
925e			;     address of the heap and its size are required, along with a memory      : 
925e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
925e			;     principally stores a pointer to the first free block in the heap.       : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     Nothing                                                                 : 
925e			;------------------------------------------------------------------------------ 
925e			heap_init: 
925e			      push  HL 
925e			 
925e			      ; Initialise free list struct 
925e			      ld    HL, heap_start 
925e			      ld    (free_list), HL 
925e			      ld    HL, 0 
925e			      ld    (free_list+2), HL 
925e			 
925e			      ; Insert first free block at bottom of heap, consumes entire heap 
925e			      ld    HL, heap_start+heap_size-4 
925e			      ld    (heap_start), HL        ; Next block (end of free list) 
925e			      ld    HL, heap_size-4 
925e			      ld    (heap_start+2), HL      ; Block size 
925e			 
925e			      ; Insert end of free list block at top of heap - two null words will 
925e			      ; terminate the free list 
925e			      ld    HL, 0 
925e			      ld    (heap_start+heap_size-2), HL 
925e			      ld    (heap_start+heap_size-4), HL 
925e			 
925e			      pop   HL 
925e			 
925e			      ret 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     malloc                                                                  : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Allocates the wanted space from the heap and returns the address of the : 
925e			;     first useable byte of the allocation.                                   : 
925e			;                                                                             : 
925e			;     Allocations can happen in one of two ways:                              : 
925e			;                                                                             : 
925e			;     1. A free block may be found which is the exact size wanted. In this    : 
925e			;        case the block is removed from the free list and retuedn to the      : 
925e			;        caller.                                                              : 
925e			;     2. A free block may be found which is larger than the size wanted. In   : 
925e			;        this case, the larger block is split into two. The first portion of  : 
925e			;        this block will become the requested space by the malloc call and    : 
925e			;        is returned to the caller. The second portion becomes a new free     : 
925e			;        block, and the free list is adjusted to maintain continuity via this : 
925e			;        newly created block.                                                 : 
925e			;                                                                             : 
925e			;     malloc does not set any initial value in the allocated space, the       : 
925e			;     caller is required to do this as required.                              : 
925e			;                                                                             : 
925e			;     This implementation of malloc uses the stack exclusively, and is        : 
925e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925e			;     advisable to disable interrupts before calling malloc, and recommended  : 
925e			;     to avoid the use of malloc inside ISRs in general.                      : 
925e			;                                                                             : 
925e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     HL  Number of bytes wanted                                              : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     HL  Address of the first useable byte of the allocation                 : 
925e			;                                                                             : 
925e			; Flags                                                                       : 
925e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
925e			;                                                                             : 
925e			; Stack frame                                                                 : 
925e			;       |             |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     BC      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     DE      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     IX      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |  prev_free  |                                                       : 
925e			;   +4  +-------------+                                                       : 
925e			;       |  this_free  |                                                       : 
925e			;   +2  +-------------+                                                       : 
925e			;       |  next_free  |                                                       : 
925e			;   +0  +-------------+                                                       : 
925e			;       |             |                                                       : 
925e			;                                                                             : 
925e			;------------------------------------------------------------------------------ 
925e			malloc: 
925e			      push  BC 
925e			      push  DE 
925e			      push  IX 
925e			 
925e			      ld    A, H                    ; Exit if no space requested 
925e			      or    L 
925e			      jp    Z, malloc_early_exit 
925e			 
925e			      ; Set up stack frame 
925e			      ex    DE, HL 
925e			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			      ld    IX, 0                   ; Use IX as a frame pointer 
925e			      add   IX, SP 
925e			 
925e			      ; Setup initial state 
925e			      ld    HL, 4                   ; want must also include space used by block struct 
925e			      add   HL, DE 
925e			 
925e			      ld    B, H                    ; Move want to BC 
925e			      ld    C, L 
925e			 
925e			      ld    HL, free_list           ; Store prev_free ptr to stack 
925e			      ld    (IX+4), L 
925e			      ld    (IX+5), H 
925e			 
925e			      ld    E, (HL)                 ; Store this_free ptr to stack 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ld    (IX+2), E 
925e			      ld    (IX+3), D 
925e			      ex    DE, HL                  ; this_free ptr into HL 
925e			 
925e			      ; Loop through free block list to find some space 
925e			malloc_find_space: 
925e			      ld    E, (HL)                 ; Load next_free ptr into DE 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      ld    A, D                    ; Check for null next_free ptr - end of free list 
925e			      or    E 
925e			      jp    Z, malloc_no_space 
925e			 
925e			      ld    (IX+0), E               ; Store next_free ptr to stack 
925e			      ld    (IX+1), D 
925e			 
925e			      ; Does this block have enough space to make the allocation? 
925e			      inc   HL                      ; Load free block size into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      ex    DE, HL                  ; Check size of block against want 
925e			      or    A                       ; Ensure carry flag clear 
925e			      sbc   HL, BC 
925e			      push  HL                      ; Store the result for later (new block size) 
925e			 
925e			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
925e			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
925e			 
925e			      ; this_free block is not big enough, setup ptrs to test next free block 
925e			      pop   HL                      ; Discard previous result 
925e			 
925e			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
925e			      ld    H, (IX+3) 
925e			      ld    (IX+4), L 
925e			      ld    (IX+5), H 
925e			 
925e			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
925e			      ld    H, (IX+1) 
925e			      ld    (IX+2), L 
925e			      ld    (IX+3), H 
925e			 
925e			      jr    malloc_find_space 
925e			 
925e			      ; split a bigger block into two - requested size and remaining size 
925e			malloc_alloc_split: 
925e			      ex    DE, HL                  ; Calculate address of new free block 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			      add   HL, BC 
925e			 
925e			      ; Create a new block and point it at next_free 
925e			      ld    E, (IX+0)               ; Load next_free ptr into DE 
925e			      ld    D, (IX+1) 
925e			 
925e			      ld    (HL), E                 ; Store next_free ptr into new block 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   DE                      ; Store size of new block into new block 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Update this_free ptr to point to new block 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
925e			      ld    D, (IX+3) 
925e			 
925e			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
925e			      ld    (IX+3), H 
925e			 
925e			      ; Modify this_free block to be allocation 
925e			      ex    DE, HL 
925e			      xor   A                       ; Null the next block ptr of allocated block 
925e			      ld    (HL), A 
925e			      inc   HL 
925e			      ld    (HL), A 
925e			 
925e			      inc   HL                      ; Store want size into allocated block 
925e			      ld    (HL), C 
925e			      inc   HL 
925e			      ld    (HL), B 
925e			      inc   HL 
925e			      push  HL                      ; Address of allocation to return 
925e			 
925e			      jr    malloc_update_links 
925e			 
925e			malloc_alloc_fit: 
925e			      pop   HL                      ; Dont need new block size, want is exact fit 
925e			 
925e			      ; Modify this_free block to be allocation 
925e			      ex    DE, HL 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      xor   A                       ; Null the next block ptr of allocated block 
925e			      ld    (HL), A 
925e			      inc   HL 
925e			      ld    (HL), A 
925e			 
925e			      inc   HL                      ; Store address of allocation to return 
925e			      inc   HL 
925e			      inc   HL 
925e			      push  HL 
925e			 
925e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
925e			      ld    L, (IX+0)               ; next_free to HL 
925e			      ld    H, (IX+1) 
925e			 
925e			      ld    (IX+2), L               ; HL to this_free 
925e			      ld    (IX+3), H 
925e			 
925e			 
925e			malloc_update_links: 
925e			      ; Update prev_free ptr to point to this_free 
925e			      ld    L, (IX+4)               ; prev_free ptr to HL 
925e			      ld    H, (IX+5) 
925e			 
925e			      ld    E, (IX+2)               ; this_free ptr to DE 
925e			      ld    D, (IX+3) 
925e			 
925e			      ld    (HL), E                 ; this_free ptr into prev_free 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Clear the Z flag to indicate successful allocation 
925e			      ld    A, D 
925e			      or    E 
925e			 
925e			      pop   DE                      ; Address of allocation 
925e			 
925e			malloc_no_space: 
925e			      ld    HL, 6                   ; Clean up stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			 
925e			      ex    DE, HL                  ; Alloc addr into HL for return 
925e			 
925e			malloc_early_exit: 
925e			      pop   IX 
925e			      pop   DE 
925e			      pop   BC 
925e			 
925e			      ret 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     free                                                                    : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
925e			;     returned by malloc, otherwise the behaviour is undefined.               : 
925e			;                                                                             : 
925e			;     Where possible, directly adjacent free blocks will be merged together   : 
925e			;     into larger blocks to help ensure that the heap does not become         : 
925e			;     excessively fragmented.                                                 : 
925e			;                                                                             : 
925e			;     free does not clear or set any other value into the freed space, and    : 
925e			;     therefore its contents may be visible through subsequent malloc's. The  : 
925e			;     caller should clear the freed space as required.                        : 
925e			;                                                                             : 
925e			;     This implementation of free uses the stack exclusively, and is          : 
925e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925e			;     advisable to disable interrupts before calling free, and recommended    : 
925e			;     to avoid the use of free inside ISRs in general.                        : 
925e			;                                                                             : 
925e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     HL  Pointer to address of first byte of allocation to be freed          : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     Nothing                                                                 : 
925e			;                                                                             : 
925e			; Stack frame                                                                 : 
925e			;       |             |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     BC      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     DE      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     IX      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |  prev_free  |                                                       : 
925e			;   +2  +-------------+                                                       : 
925e			;       |  next_free  |                                                       : 
925e			;   +0  +-------------+                                                       : 
925e			;       |             |                                                       : 
925e			;                                                                             : 
925e			;------------------------------------------------------------------------------ 
925e			free: 
925e			      push  BC 
925e			      push  DE 
925e			      push  IX 
925e			 
925e			      ld    A, H                    ; Exit if ptr is null 
925e			      or    L 
925e			      jp    Z, free_early_exit 
925e			 
925e			      ; Set up stack frame 
925e			      ex    DE, HL 
925e			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			      ld    IX, 0                   ; Use IX as a frame pointer 
925e			      add   IX, SP 
925e			 
925e			      ; The address in HL points to the start of the useable allocated space, 
925e			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
925e			      ; address of the block itself. 
925e			      ex    DE, HL 
925e			      ld    DE, -4 
925e			      add   HL, DE 
925e			 
925e			      ; An allocated block must have a null next block pointer in it 
925e			      ld    A, (HL) 
925e			      inc   HL 
925e			      or    (HL) 
925e			      jp    NZ, free_done 
925e			 
925e			      dec   HL 
925e			 
925e			      ld    B, H                    ; Copy HL to BC 
925e			      ld    C, L 
925e			 
925e			      ; Loop through the free list to find the first block with an address 
925e			      ; higher than the block being freed 
925e			      ld    HL, free_list 
925e			 
925e			free_find_higher_block: 
925e			      ld    E, (HL)                 ; Load next ptr from free block 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      dec   HL 
925e			 
925e			      ld    (IX+0), E               ; Save ptr to next free block 
925e			      ld    (IX+1), D 
925e			      ld    (IX+2), L               ; Save ptr to prev free block 
925e			      ld    (IX+3), H 
925e			 
925e			      ld    A, B                    ; Check if DE is greater than BC 
925e			      cp    D                       ; Compare MSB first 
925e			      jr    Z, $+4                  ; MSB the same, compare LSB 
925e			      jr    NC, free_find_higher_block_skip 
925e			      ld    A, C 
925e			      cp    E                       ; Then compare LSB 
925e			      jr    C, free_found_higher_block 
925e			 
925e			free_find_higher_block_skip: 
925e			      ld    A, D                    ; Reached the end of the free list? 
925e			      or    E 
925e			      jp    Z, free_done 
925e			 
925e			      ex    DE, HL 
925e			 
925e			      jr    free_find_higher_block 
925e			 
925e			free_found_higher_block: 
925e			      ; Insert freed block between prev and next free blocks 
925e			      ld    (HL), C                 ; Point prev free block to freed block 
925e			      inc   HL 
925e			      ld    (HL), B 
925e			 
925e			      ld    H, B                    ; Point freed block at next free block 
925e			      ld    L, C 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Check if the freed block is adjacent to the next free block 
925e			      inc   HL                      ; Load size of freed block into HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ex    DE, HL 
925e			 
925e			      add   HL, BC                  ; Add addr of freed block and its size 
925e			 
925e			      ld    E, (IX+0)               ; Load addr of next free block into DE 
925e			      ld    D, (IX+1) 
925e			 
925e			      or    A                       ; Clear the carry flag 
925e			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
925e			      jr    NZ, free_check_adjacent_to_prev 
925e			 
925e			      ; Freed block is adjacent to next, merge into one bigger block 
925e			      ex    DE, HL                  ; Load next ptr from next block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  HL                      ; Save ptr to next block for later 
925e			 
925e			      ld    H, B                    ; Store ptr from next block into freed block 
925e			      ld    L, C 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   HL                      ; Restore ptr to next block 
925e			      inc   HL                      ; Load size of next block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  DE                      ; Save next block size for later 
925e			 
925e			      ld    H, B                    ; Load size of freed block into HL 
925e			      ld    L, C 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ex    DE, HL 
925e			 
925e			      pop   DE                      ; Restore size of next block 
925e			      add   HL, DE                  ; Add sizes of both blocks 
925e			      ex    DE, HL 
925e			 
925e			      ld    H, B                    ; Store new bigger size into freed block 
925e			      ld    L, C 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			free_check_adjacent_to_prev: 
925e			      ; Check if the freed block is adjacent to the prev free block 
925e			      ld    L, (IX+2)               ; Prev free block ptr into HL 
925e			      ld    H, (IX+3) 
925e			 
925e			      inc   HL                      ; Size of prev free block into DE 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      add   HL, DE                  ; Add prev block addr and size 
925e			 
925e			      or    A                       ; Clear the carry flag 
925e			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
925e			      jr    NZ, free_done 
925e			 
925e			      ; Freed block is adjacent to prev, merge into one bigger block 
925e			      ld    H, B                    ; Load next ptr from freed block into DE 
925e			      ld    L, C 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  HL                      ; Save freed block ptr for later 
925e			 
925e			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
925e			      ld    H, (IX+3) 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   HL                      ; Restore freed block ptr 
925e			      inc   HL                      ; Load size of freed block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  DE                      ; Save freed block size for later 
925e			 
925e			      ld    L, (IX+2)               ; Load size of prev block into DE 
925e			      ld    H, (IX+3) 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      pop   HL                      ; Add sizes of both blocks 
925e			      add   HL, DE 
925e			      ex    DE, HL 
925e			 
925e			      ld    L, (IX+2)               ; Store new bigger size into prev block 
925e			      ld    H, (IX+3) 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			free_done: 
925e			      ld    HL, 4                   ; Clean up stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			 
925e			free_early_exit: 
925e			      pop   IX 
925e			      pop   DE 
925e			      pop   BC 
925e			 
925e			      ret 
925e			 
925e			 
925e			;      .org 0x8000 
925e			; 
925e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925e			 ;                 .dw   0 
925e			 
925e			endif 
925e			 
925e			 
925e			if MALLOC_4 
925e			 
925e			; My memory allocation code. Very very simple.... 
925e			; allocate space under 250 chars 
925e			 
925e			heap_init: 
925e				; init start of heap as zero 
925e				;  
925e			 
925e				ld hl, heap_start 
925e				ld a, 0 
925e				ld (hl), a      ; empty block 
925e				inc hl 
925e				ld a, 0 
925e				ld (hl), a      ; length of block 
925e				; write end of list 
925e				inc hl 
925e				ld a,(hl) 
925e				inc hl 
925e				ld a,(hl) 
925e				 
925e			 
925e				; init some malloc vars 
925e			 
925e				ld hl, 0 
925e				ld (free_list), hl       ; store last malloc location 
925e			 
925e				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
925e				ld a, 0 
925e				ld (hl), a 
925e			 
925e			 
925e				ld hl, heap_start 
925e				;  
925e				  
925e				ret 
925e			 
925e			 
925e			;    free block marker 
925e			;    requested size  
925e			;    pointer to next block 
925e			;    .... 
925e			;    next block marker 
925e			 
925e			 
925e			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
925e			; 
925e			 
925e			 
925e			malloc:  
925e				push de 
925e				push bc 
925e				push af 
925e			 
925e				; hl space required 
925e				 
925e				ld c, l    ; hold space   (TODO only a max of 255) 
925e			 
925e			;	inc c     ; TODO BUG need to fix memory leak on push str 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			 
925e			 
925e			 
925e				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
925e			 
925e				ld a, (free_list+3) 
925e				cp 0 
925e				jr z, .contheap 
925e			 
925e				ld hl, (free_list)     ; get last alloc 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mrs" 
925e						CALLMONITOR 
925e					endif 
925e				jr .startalloc 
925e			 
925e			.contheap: 
925e				ld hl, heap_start 
925e			 
925e			.startalloc: 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mym" 
925e						CALLMONITOR 
925e					endif 
925e			.findblock: 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mmf" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e				ld a,(hl)  
925e				; if byte is zero then clear to use 
925e			 
925e				cp 0 
925e				jr z, .foundemptyblock 
925e			 
925e				; if byte is not clear 
925e				;     then byte is offset to next block 
925e			 
925e				inc hl 
925e				ld a, (hl) ; get size 
925e			.nextblock:	inc hl 
925e					ld e, (hl) 
925e					inc hl 
925e					ld d, (hl) 
925e					ex de, hl 
925e			;	inc hl  ; move past the store space 
925e			;	inc hl  ; move past zero index  
925e			 
925e				; TODO detect no more space 
925e			 
925e				push hl 
925e				ld de, heap_end 
925e				call cmp16 
925e				pop hl 
925e				jr nc, .nospace 
925e			 
925e				jr .findblock 
925e			 
925e			.nospace: ld hl, 0 
925e				jp .exit 
925e			 
925e			 
925e			.foundemptyblock:	 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mme" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			; TODO has block enough space if reusing??? 
925e			 
925e				;  
925e			 
925e			; see if this block has been previously used 
925e				inc hl 
925e				ld a, (hl) 
925e				dec hl 
925e				cp 0 
925e				jr z, .newblock 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "meR" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			; no reusing previously allocated block 
925e			 
925e			; is it smaller than previously used? 
925e				 
925e				inc hl    ; move to size 
925e				ld a, c 
925e				sub (hl)        ; we want c < (hl) 
925e				dec hl    ; move back to marker 
925e			        jr z, .findblock 
925e			 
925e				; update with the new size which should be lower 
925e			 
925e			        ;inc  hl   ; negate next move. move back to size  
925e			 
925e			.newblock: 
925e				; need to be at marker here 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "meN" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			 
925e				ld a, c 
925e			 
925e				ld (free_list+3), a	 ; flag resume from last malloc  
925e				ld (free_list), hl    ; save out last location 
925e			 
925e			 
925e				;inc a     ; space for length byte 
925e				ld (hl), a     ; save block in use marker 
925e			 
925e				inc hl   ; move to space marker 
925e				ld (hl), a    ; save new space 
925e			 
925e				inc hl   ; move to start of allocated area 
925e				 
925e			;	push hl     ; save where we are - 1  
925e			 
925e			;	inc hl  ; move past zero index  
925e				; skip space to set down new marker 
925e			 
925e				; provide some extra space for now 
925e			 
925e				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
925e				inc a 
925e				inc a 
925e			 
925e				push hl   ; save where we are in the node block 
925e			 
925e				call addatohl 
925e			 
925e				; write linked list point 
925e			 
925e				pop de     ; get our node position 
925e				ex de, hl 
925e			 
925e				ld (hl), e 
925e				inc hl 
925e				ld (hl), d 
925e			 
925e				inc hl 
925e			 
925e				; now at start of allocated data so save pointer 
925e			 
925e				push hl 
925e			 
925e				; jump to position of next node and setup empty header in DE 
925e			 
925e				ex de, hl 
925e			 
925e			;	inc hl ; move past end of block 
925e			 
925e				ld a, 0 
925e				ld (hl), a   ; empty marker 
925e				inc hl 
925e				ld (hl), a   ; size 
925e				inc hl  
925e				ld (hl), a   ; ptr 
925e				inc hl 
925e				ld (hl), a   ; ptr 
925e			 
925e			 
925e				pop hl 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mmr" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			.exit: 
925e				pop af 
925e				pop bc 
925e				pop de  
925e				ret 
925e			 
925e			 
925e			 
925e			 
925e			free:  
925e				push hl 
925e				push af 
925e				; get address in hl 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "fre" 
925e						CALLMONITOR 
925e					endif 
925e				; data is at hl - move to block count 
925e				dec hl 
925e				dec hl    ; get past pointer 
925e				dec hl 
925e			 
925e				ld a, (hl)    ; need this for a validation check 
925e			 
925e				dec hl    ; move to block marker 
925e			 
925e				; now check that the block count and block marker are the same  
925e			        ; this checks that we are on a malloc node and not random memory 
925e			        ; OK a faint chance this could be a problem but rare - famous last words! 
925e			 
925e				ld c, a 
925e				ld a, (hl)    
925e			 
925e				cp c 
925e				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
925e			 
925e				; yes good chance we are on a malloc node 
925e			 
925e				ld a, 0      
925e				ld (hl), a   ; mark as free 
925e			 
925e				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
925e			 
925e			.freeignore:  
925e			 
925e				pop af 
925e				pop hl 
925e			 
925e				ret 
925e			 
925e			 
925e			 
925e			endif 
925e			 
925e			; eof 
# End of file firmware_memory.asm
925e			  
925e			; device C  
925e			; Now handled by SPI  
925e			;if SOUND_ENABLE  
925e			;	include "firmware_sound.asm"  
925e			;endif  
925e			  
925e			include "firmware_diags.asm"  
925e			; Hardware diags menu 
925e			 
925e			 
925e			config: 
925e			 
925e 3e 00			ld a, 0 
9260 21 84 92			ld hl, .configmn 
9263 cd ee 8a			call menu 
9266			 
9266 fe 00			cp 0 
9268 c8				ret z 
9269			 
9269			;	cp 1 
9269			;	call z, .savetostore 
9269			 
9269 fe 01			cp 1 
926b			if STARTUP_V1 
926b cc 9a 92			call z, .selautoload 
926e			endif 
926e			 
926e			if STARTUP_V2 
926e				call z, .enautoload 
926e			endif 
926e fe 02			cp 2 
9270 cc 90 92			call z, .disautoload 
9273			;	cp 3 
9273			;	call z, .selbank 
9273 fe 03			cp 3 
9275 cc b8 92			call z, .debug_tog 
9278 fe 04			cp 4 
927a cc 06 94			call z, .bpsgo 
927d fe 05			cp 5 
927f cc e1 92			call z, hardware_diags 
9282			if STARTUP_V2 
9282				cp 6 
9282				call z, create_startup 
9282			endif 
9282 18 da			jr config 
9284			 
9284			.configmn: 
9284			;	dw prom_c3 
9284 f4 95			dw prom_c2 
9286 09 96			dw prom_c2a 
9288			;	dw prom_c2b 
9288			;	dw prom_c4 
9288 28 96			dw prom_m4 
928a 43 96			dw prom_m4b 
928c 4b 96			dw prom_c1 
928e			if STARTUP_V2 
928e				dw prom_c9 
928e			endif 
928e 00 00			dw 0 
9290				 
9290			 
9290			if STARTUP_V2 
9290			.enautoload: 
9290				if STORAGE_SE 
9290				ld a, $fe      ; bit 0 clear 
9290				ld (spi_device), a 
9290			 
9290				call storage_get_block_0 
9290			 
9290				ld a, 1 
9290				ld (store_page+STORE_0_AUTOFILE), a 
9290			 
9290					ld hl, 0 
9290					ld de, store_page 
9290				call storage_write_block	 ; save update 
9290				else 
9290			 
9290				ld hl, prom_notav 
9290				ld de, prom_empty 
9290				call info_panel 
9290				endif 
9290			 
9290			 
9290				ret 
9290			endif 
9290			 
9290			.disautoload: 
9290				if STORAGE_SE 
9290				ld a, $fe      ; bit 0 clear 
9290				ld (spi_device), a 
9290			 
9290				call storage_get_block_0 
9290			 
9290				ld a, 0 
9290				ld (store_page+STORE_0_AUTOFILE), a 
9290			 
9290					ld hl, 0 
9290					ld de, store_page 
9290				call storage_write_block	 ; save update 
9290				else 
9290			 
9290 21 5a 96			ld hl, prom_notav 
9293 11 70 96			ld de, prom_empty 
9296 cd 4e 8a			call info_panel 
9299				endif 
9299			 
9299			 
9299 c9				ret 
929a			 
929a			if STARTUP_V1 
929a			 
929a			; Select auto start 
929a			 
929a			.selautoload: 
929a			 
929a				 
929a				if STORAGE_SE 
929a			 
929a					call config_dir 
929a				        ld hl, scratch 
929a					ld a, 0 
929a					call menu 
929a			 
929a					cp 0 
929a					ret z 
929a			 
929a					dec a 
929a			 
929a			 
929a					; locate menu option 
929a			 
929a					ld hl, scratch 
929a					call table_lookup 
929a			 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "ALl" 
929a						CALLMONITOR 
929a					endif 
929a					; with the pointer to the menu it, the byte following the zero term is the file id 
929a			 
929a					ld a, 0 
929a					ld bc, 50   ; max of bytes to look at 
929a					cpir  
929a			 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "ALb" 
929a						CALLMONITOR 
929a					endif 
929a					;inc hl 
929a			 
929a					ld a, (hl)   ; file id 
929a					 
929a				        ; save bank and file ids 
929a			 
929a					push af 
929a			 
929a			; TODO need to save to block 0 on bank 1	 
929a			 
929a					call storage_get_block_0 
929a			 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "AL0" 
929a						CALLMONITOR 
929a					endif 
929a					pop af 
929a			 
929a					ld (store_page+STORE_0_FILERUN),a 
929a					 
929a					; save bank id 
929a			 
929a					ld a,(spi_device) 
929a					ld (store_page+STORE_0_BANKRUN),a 
929a			 
929a					; enable auto run of store file 
929a			 
929a					ld a, 1 
929a					ld (store_page+STORE_0_AUTOFILE),a 
929a			 
929a					; save buffer 
929a			 
929a					ld hl, 0 
929a					ld de, store_page 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "ALw" 
929a						CALLMONITOR 
929a					endif 
929a				call storage_write_block	 ; save update 
929a			  
929a			 
929a			 
929a			 
929a					ld hl, scratch 
929a					call config_fdir 
929a			 
929a				else 
929a			 
929a 21 5a 96			ld hl, prom_notav 
929d 11 70 96			ld de, prom_empty 
92a0 cd 4e 8a			call info_panel 
92a3			 
92a3				endif 
92a3 c9				ret 
92a4			endif 
92a4			 
92a4			 
92a4			; Select storage bank 
92a4			 
92a4			.selbank: 
92a4			 
92a4			;	if STORAGE_SE 
92a4			;	else 
92a4			 
92a4 21 5a 96			ld hl, prom_notav 
92a7 11 70 96			ld de, prom_empty 
92aa cd 4e 8a			call info_panel 
92ad			;	endif 
92ad				 
92ad c9				ret 
92ae			 
92ae			if STORAGE_SE 
92ae			 
92ae			.config_ldir:   
92ae				; Load storage bank labels into menu array 
92ae			 
92ae				 
92ae			 
92ae			 
92ae				ret 
92ae			 
92ae			 
92ae			endif 
92ae			 
92ae			 
92ae			; Save user words to storage 
92ae			 
92ae			.savetostore: 
92ae			 
92ae			;	if STORAGE_SE 
92ae			; 
92ae			;		call config_dir 
92ae			;	        ld hl, scratch 
92ae			;		ld a, 0 
92ae			;		call menu 
92ae			;		 
92ae			;		ld hl, scratch 
92ae			;		call config_fdir 
92ae			; 
92ae			;	else 
92ae			 
92ae 21 5a 96			ld hl, prom_notav 
92b1 11 70 96			ld de, prom_empty 
92b4 cd 4e 8a			call info_panel 
92b7			 
92b7			;	endif 
92b7			 
92b7 c9				ret 
92b8			 
92b8			if STARTUP_V2 
92b8			 
92b8			create_startup: 
92b8			 
92b8				ld a, 0 
92b8				ld hl, .crstart 
92b8				call menu 
92b8			 
92b8				cp 0 
92b8				ret z 
92b8			 
92b8				cp 1 
92b8				call z, .genlsword 
92b8				cp 2 
92b8				call z, .genedword 
92b8			 
92b8				cp 3 
92b8				call z, .gendemword 
92b8			 
92b8				cp 4 
92b8				call z, .genutlword 
92b8				cp 5 
92b8				call z, .genspiword 
92b8				cp 6 
92b8				call z, .genkeyword 
92b8				cp 7 
92b8				call z, .gensoundword 
92b8				cp 7 
92b8				call z, .genhwword 
92b8				jr create_startup 
92b8			 
92b8			.genhwword: 
92b8				ld hl, crs_hw 
92b8				ld de, .hwworddef 
92b8				call .genfile 
92b8				ret 
92b8			.gensoundword: 
92b8				ld hl, crs_sound 
92b8				ld de, .soundworddef 
92b8				call .genfile 
92b8				ret 
92b8			.genlsword: 
92b8				ld hl, crs_s1 
92b8				ld de, .lsworddef 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			.genedword: 
92b8				ld de, .edworddef 
92b8				ld hl, crs_s2 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			.gendemword: 
92b8				ld de, .demoworddef 
92b8				ld hl, crs_s3 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			.genutlword: 
92b8				ld hl, crs_s4 
92b8				ld de, .utilwordef 
92b8				call .genfile 
92b8				ret 
92b8			.genspiword: 
92b8				ld hl, crs_s5 
92b8				ld de, .spiworddef 
92b8				call .genfile 
92b8				ret 
92b8			.genkeyword: 
92b8				ld hl, crs_s6 
92b8				ld de, .keyworddef 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			; hl - points to file name 
92b8			; de - points to strings to add to file 
92b8			 
92b8			.genfile: 
92b8				push hl 
92b8				push de 
92b8			 
92b8				call clear_display 
92b8				ld a, display_row_1 
92b8				ld de, .genfiletxt 
92b8				call str_at_display 
92b8				call update_display 
92b8			 
92b8				pop de 
92b8				pop hl 
92b8			 
92b8			 
92b8				push de 
92b8				call storage_create 
92b8				; id in hl 
92b8				pop de   ; table of strings to add 
92b8			 
92b8			.genloop: 
92b8			 
92b8				push hl ; save id for next time around 
92b8				push de ; save de for next time around 
92b8			 
92b8				ex de, hl 
92b8				call loadwordinhl 
92b8				ex de, hl 
92b8			 
92b8				; need hl to be the id 
92b8				; need de to be the string ptr 
92b8				 
92b8				call storage_append 
92b8			 
92b8				pop de 
92b8				pop hl 
92b8			 
92b8				inc de 
92b8				inc de 
92b8			 
92b8				ld a,(de) 
92b8				cp 0 
92b8				jr nz, .genloop 
92b8				inc de 
92b8				ld a, (de) 
92b8				dec de 
92b8				cp 0 
92b8				jr nz, .genloop	 
92b8			 
92b8				ret 
92b8			 
92b8			.genfiletxt:  db "Creating file...",0 
92b8			 
92b8			.hwworddef: 
92b8				dw test5 
92b8				dw test6 
92b8				dw test7 
92b8				dw test8 
92b8				dw test9 
92b8				dw test10 
92b8				dw 0 
92b8			 
92b8			.soundworddef: 
92b8				dw sound1 
92b8				dw sound2 
92b8				dw sound3 
92b8				dw sound4 
92b8				dw sound5 
92b8				dw sound6 
92b8				dw sound7 
92b8				dw sound8 
92b8				dw sound9 
92b8				dw 0 
92b8			 
92b8			.utilwordef: 
92b8				dw strncpy 
92b8				dw type 
92b8				dw tuck 
92b8				dw clrstack 
92b8				dw longread 
92b8				dw start1 
92b8				dw start2 
92b8			; duplicated 
92b8			;	dw start3b 
92b8			;	dw start3c 
92b8				dw list 
92b8				dw 0 
92b8			 
92b8			.lsworddef: 
92b8				dw start3b 
92b8				dw 0 
92b8			 
92b8			.edworddef: 
92b8				dw edit1 
92b8				dw edit2 
92b8				dw edit3 
92b8				dw 0 
92b8			 
92b8			.demoworddef: 
92b8				dw game1 
92b8				dw game1a 
92b8				dw game1b 
92b8				dw game1c 
92b8				dw game1d 
92b8				dw game1s 
92b8				dw game1t 
92b8				dw game1f 
92b8				dw game1z 
92b8				dw game1zz 
92b8				dw ssv2 
92b8				dw ssv3 
92b8				dw ssv4 
92b8				dw ssv5 
92b8				dw ssv1 
92b8				dw ssv1cpm	 
92b8			;	dw game2b 
92b8			;	dw game2bf 
92b8			;	dw game2mba 
92b8			;	dw game2mbas	 
92b8			;	dw game2mbht 
92b8			;	dw game2mbms 
92b8			;	dw game2mb 
92b8			;	dw game3w 
92b8			;	dw game3p 
92b8			;	dw game3sc 
92b8			;	dw game3vsi 
92b8			;	dw game3vs 
92b8				dw 0 
92b8			 
92b8			 
92b8			.spiworddef: 
92b8			 
92b8			    dw spi1 
92b8			    dw spi2 
92b8			    dw spi2b 
92b8			    dw spi3 
92b8			    dw spi4 
92b8			    dw spi5 
92b8			;    dw spi6 
92b8			;    dw spi7 
92b8			 
92b8			;    dw spi8 
92b8			;    dw spi9 
92b8			;    dw spi10 
92b8			    dw 0 
92b8			 
92b8			.keyworddef: 
92b8			 
92b8				dw keyup 
92b8				dw keydown 
92b8				dw keyleft 
92b8				dw keyright 
92b8				dw 	keyf1 
92b8				dw keyf2 
92b8				dw keyf3 
92b8				dw keyf4 
92b8				dw keyf5 
92b8				dw keyf6 
92b8				dw keyf7 
92b8				dw keyf8 
92b8				dw keyf9 
92b8				dw keyf10 
92b8				dw keyf11 
92b8				dw keyf12 
92b8				dw keytab 
92b8				dw keycr 
92b8				dw keyhome 
92b8				dw keyend 
92b8				dw keybs 
92b8				dw 0 
92b8			 
92b8			.crstart: 
92b8				dw crs_s1 
92b8				dw crs_s2 
92b8				dw crs_s3 
92b8				dw crs_s4 
92b8				dw crs_s5 
92b8				dw crs_s6 
92b8				dw crs_sound 
92b8				dw crs_hw 
92b8				dw 0 
92b8			 
92b8			endif 
92b8			 
92b8			 
92b8			if STORAGE_SE 
92b8			 
92b8			config_fdir: 
92b8				; using the scratch dir go through and release the memory allocated for each string 
92b8				 
92b8				ld hl, scratch 
92b8			.cfdir:	ld e,(hl) 
92b8				inc hl 
92b8				ld d,(hl) 
92b8				inc hl 
92b8			 
92b8				ex de, hl 
92b8				call ishlzero 
92b8				ret z     ; return on null pointer 
92b8				call free 
92b8				ex de, hl 
92b8				jr .cfdir 
92b8			 
92b8			 
92b8				ret 
92b8			 
92b8			 
92b8			config_dir: 
92b8			 
92b8				; for the config menus that need to build a directory of storage call this routine 
92b8				; it will construct a menu in scratch to pass to menu 
92b8			 
92b8				; open storage device 
92b8			 
92b8				; execute DIR to build a list of files and their ids into scratch in menu format 
92b8				; once the menu has finished then will need to call config_fdir to release the strings 
92b8				 
92b8				; c = number items 
92b8			 
92b8				 
92b8				call storage_get_block_0 
92b8			 
92b8				ld hl, store_page     ; get current id count 
92b8				ld b, (hl) 
92b8				ld c, 0    ; count of files   
92b8			 
92b8			 
92b8				ld hl, scratch 
92b8				ld (store_tmp2), hl    ; location to poke strings 
92b8			 
92b8				; check for empty drive 
92b8			 
92b8				ld a, 0 
92b8				cp b 
92b8				jp z, .dirdone 
92b8			 
92b8				 
92b8					if DEBUG_FORTH_WORDS 
92b8						DMARK "Cdc" 
92b8						CALLMONITOR 
92b8					endif 
92b8			 
92b8			 
92b8			.diritem:	 
92b8				push bc 
92b8				; for each of the current ids do a search for them and if found push to stack 
92b8			 
92b8					ld hl, STORE_BLOCK_PHY 
92b8					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92b8					ld e,b 
92b8			 
92b8					call storage_findnextid 
92b8			 
92b8			 
92b8					; if found hl will be non zero 
92b8			 
92b8					call ishlzero 
92b8					jr z, .dirnotfound 
92b8			 
92b8					; increase count 
92b8			 
92b8					pop bc	 
92b8					inc c 
92b8					push bc 
92b8					 
92b8			 
92b8					; get file header and push the file name 
92b8			 
92b8					ld de, store_page 
92b8					call storage_read_block 
92b8			 
92b8					; push file id to stack 
92b8				 
92b8					ld a, (store_page) 
92b8					ld h, 0 
92b8					ld l, a 
92b8			 
92b8					;call forth_push_numhl 
92b8					; TODO store id 
92b8			 
92b8					push hl 
92b8			 
92b8					; push extent count to stack  
92b8				 
92b8					ld hl, store_page+3 
92b8			 
92b8					; get file name length 
92b8			 
92b8					call strlenz   
92b8			 
92b8					inc hl   ; cover zero term 
92b8					inc hl  ; stick the id at the end of the area 
92b8			 
92b8					push hl 
92b8					pop bc    ; move length to bc 
92b8			 
92b8					call malloc 
92b8			 
92b8					; TODO save malloc area to scratch 
92b8			 
92b8					ex de, hl 
92b8					ld hl, (store_tmp2) 
92b8					ld (hl), e 
92b8					inc hl 
92b8					ld (hl), d 
92b8					inc hl 
92b8					ld (store_tmp2), hl 
92b8			 
92b8					 
92b8			 
92b8					;pop hl   ; get source 
92b8			;		ex de, hl    ; swap aronund	 
92b8			 
92b8					ld hl, store_page+3 
92b8					if DEBUG_FORTH_WORDS 
92b8						DMARK "CFd" 
92b8						CALLMONITOR 
92b8					endif 
92b8					ldir 
92b8			 
92b8					; de is past string, move back one and store id 
92b8					 
92b8					dec de 
92b8			 
92b8					; store file id 
92b8			 
92b8					pop hl 
92b8					ex de,hl 
92b8					ld (hl), e 
92b8			 
92b8					if DEBUG_FORTH_WORDS 
92b8						DMARK "Cdi" 
92b8						CALLMONITOR 
92b8					endif 
92b8					 
92b8			.dirnotfound: 
92b8					pop bc     
92b8					djnz .diritem 
92b8				 
92b8			.dirdone:	 
92b8			 
92b8					ld a, 0 
92b8					ld hl, (store_tmp2) 
92b8					ld (hl), a 
92b8					inc hl 
92b8					ld (hl), a 
92b8					inc hl 
92b8					; push a count of the dir items found 
92b8			 
92b8			;		ld h, 0 
92b8			;		ld l, c 
92b8			 
92b8				ret 
92b8			 
92b8			endif 
92b8			 
92b8			 
92b8			; Settings 
92b8			; Run  
92b8			 
92b8			 
92b8			 
92b8			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92b8			;;hd_menu2:   db "        2: Editor",0   
92b8			;hd_menu2:   db "        2: Editor       6: Menu",0   
92b8			;hd_menu3:   db "        3: Storage",0 
92b8			;hd_menu4:   db "0=quit  4: Debug",0 
92b8			;hd_don:     db "ON",0 
92b8			;hd_doff:     db "OFF",0 
92b8			; 
92b8			; 
92b8			; 
92b8			;hardware_diags_old:       
92b8			; 
92b8			;.diagmenu: 
92b8			;	call clear_display 
92b8			;	ld a, display_row_1 
92b8			;	ld de, hd_menu1 
92b8			;	call str_at_display 
92b8			; 
92b8			;	ld a, display_row_2 
92b8			;	ld de, hd_menu2 
92b8			;	call str_at_display 
92b8			; 
92b8			;	ld a, display_row_3 
92b8			;	ld de, hd_menu3 
92b8			;	call str_at_display 
92b8			; 
92b8			;	ld a,  display_row_4 
92b8			;	ld de, hd_menu4 
92b8			;	call str_at_display 
92b8			; 
92b8			;	; display debug state 
92b8			; 
92b8			;	ld de, hd_don 
92b8			;	ld a, (os_view_disable) 
92b8			;	cp 0 
92b8			;	jr z, .distog 
92b8			;	ld de, hd_doff 
92b8			;.distog: ld a, display_row_4+17 
92b8			;	call str_at_display 
92b8			; 
92b8			;	call update_display 
92b8			; 
92b8			;	call cin_wait 
92b8			; 
92b8			; 
92b8			; 
92b8			;	cp '4' 
92b8			;	jr nz, .diagn1 
92b8			; 
92b8			;	; debug toggle 
92b8			; 
92b8			;	ld a, (os_view_disable) 
92b8			;	ld b, '*' 
92b8			;	cp 0 
92b8			;	jr z, .debtog 
92b8			;	ld b, 0 
92b8			;.debtog:	 
92b8			;	ld a,b 
92b8			;	ld (os_view_disable),a 
92b8			; 
92b8			;.diagn1: cp '0' 
92b8			;	 ret z 
92b8			; 
92b8			;;	cp '1' 
92b8			;;       jp z, matrix	 
92b8			;;   TODO keyboard matrix test 
92b8			; 
92b8			;	cp '2' 
92b8			;	jp z, .diagedit 
92b8			; 
92b8			;;	cp '6' 
92b8			;;	jp z, .menutest 
92b8			;;if ENABLE_BASIC 
92b8			;;	cp '6' 
92b8			;;	jp z, basic 
92b8			;;endif 
92b8			 ; 
92b8			;	jp .diagmenu 
92b8			; 
92b8			; 
92b8			;	ret 
92b8			 
92b8			 
92b8			.debug_tog: 
92b8 21 02 93			ld hl, .menudebug 
92bb				 
92bb			;	ld a, (os_view_disable) 
92bb			;	cp '*' 
92bb 3a 6f ee			ld a,(debug_vector) 
92be fe c9			cp $C9   ; RET 
92c0 20 04			jr nz,.tdon  
92c2 3e 01			ld a, 1 
92c4 18 02			jr .tog1 
92c6 3e 00		.tdon: ld a, 0 
92c8			 
92c8			.tog1: 
92c8 cd ee 8a			call menu 
92cb fe 00			cp 0 
92cd c8				ret z 
92ce fe 01			cp 1    ; disable debug 
92d0 28 04			jr z, .dtog0 
92d2 3e 2a			ld a, '*' 
92d4 18 05			jr .dtogset 
92d6			.dtog0:  
92d6				;ld a, 0 
92d6 cd f4 93			call bp_on 
92d9 18 dd			jr .debug_tog 
92db			.dtogset:  
92db				; ld (os_view_disable), a 
92db cd 00 94			call bp_off 
92de c3 b8 92			jp .debug_tog 
92e1			 
92e1			 
92e1			hardware_diags:       
92e1			 
92e1			.diagm: 
92e1 21 f4 92			ld hl, .menuitems 
92e4 3e 00			ld a, 0 
92e6 cd ee 8a			call menu 
92e9			 
92e9 fe 00		         cp 0 
92eb c8				 ret z 
92ec			 
92ec fe 02			cp 2 
92ee ca 4d 93			jp z, .diagedit 
92f1			 
92f1			;	cp '6' 
92f1			;	jp z, .menutest 
92f1			;if ENABLE_BASIC 
92f1			;	cp '6' 
92f1			;	jp z, basic 
92f1			;endif 
92f1			  
92f1 c3 e1 92			jp .diagm 
92f4			 
92f4				 
92f4 08 93		.menuitems:   	dw .m1 
92f6 13 93				dw .m2 
92f8 1a 93				dw .m3 
92fa 22 93				dw .m5 
92fc 28 93				dw .m5a 
92fe 31 93				dw .m5b 
9300 00 00				dw 0 
9302			 
9302			.menudebug: 
9302 3a 93				dw .m6 
9304 43 93				dw .m7 
9306 00 00				dw 0 
9308			 
9308 .. 00		.m1:   db "Key Matrix",0 
9313 .. 00		.m2:   db "Editor",0 
931a .. 00		.m3:   db "Storage",0 
9322 .. 00		.m5:   db "Sound",0 
9328 .. 00		.m5a:  db "RAM Test",0 
9331 .. 00		.m5b:  db "LCD Test",0 
933a			 
933a .. 00		.m6:   db "Debug ON",0 
9343 .. 00		.m7:   db "Debug OFF",0 
934d			 
934d			; debug editor 
934d			 
934d			.diagedit: 
934d			 
934d 21 bb e2			ld hl, scratch 
9350			;	ld bc, 250 
9350			;	ldir 
9350				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9350 3e 00			ld a, 0 
9352 77				ld (hl), a 
9353 23				inc hl 
9354 77				ld (hl), a 
9355 23				inc hl 
9356 77				ld (hl), a 
9357			 
9357 cd bd 8a		        call clear_display 
935a cd e0 8a			call update_display 
935d				;ld a, 1 
935d				;ld (hardware_diag), a 
935d			.diloop: 
935d 3e 00			ld a, display_row_1 
935f 0e 00			ld c, 0 
9361 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9363 1e 28			ld e, 40 
9365			 
9365 21 bb e2			ld hl, scratch	 
9368 cd 17 8d			call input_str 
936b			 
936b 3e 28			ld a, display_row_2 
936d 11 bb e2			ld de, scratch 
9370 cd d0 8a			call str_at_display 
9373 cd e0 8a			call update_display 
9376			 
9376 c3 5d 93			jp .diloop 
9379			 
9379			 
9379			; pass word in hl 
9379			; a has display location 
9379			display_word_at: 
9379 f5				push af 
937a e5				push hl 
937b 7c				ld a,h 
937c 21 c0 e5			ld hl, os_word_scratch 
937f cd f3 8e			call hexout 
9382 e1				pop hl 
9383 7d				ld a,l 
9384 21 c2 e5			ld hl, os_word_scratch+2 
9387 cd f3 8e			call hexout 
938a 21 c4 e5			ld hl, os_word_scratch+4 
938d 3e 00			ld a,0 
938f 77				ld (hl),a 
9390 11 c0 e5			ld de,os_word_scratch 
9393 f1				pop af 
9394 cd d0 8a				call str_at_display 
9397 c9				ret 
9398			 
9398			display_ptr_state: 
9398			 
9398				; to restore afterwards 
9398			 
9398 d5				push de 
9399 c5				push bc 
939a e5				push hl 
939b f5				push af 
939c			 
939c				; for use in here 
939c			 
939c			;	push bc 
939c			;	push de 
939c			;	push hl 
939c			;	push af 
939c			 
939c cd bd 8a			call clear_display 
939f			 
939f 11 77 95			ld de, .ptrstate 
93a2 3e 00			ld a, display_row_1 
93a4 cd d0 8a			call str_at_display 
93a7			 
93a7				; display debug step 
93a7			 
93a7			 
93a7 11 65 ee			ld de, debug_mark 
93aa 3e 26			ld a, display_row_1+display_cols-2 
93ac cd d0 8a			call str_at_display 
93af			 
93af				; display a 
93af 11 81 95			ld de, .ptrcliptr 
93b2 3e 28			ld a, display_row_2 
93b4 cd d0 8a			call str_at_display 
93b7			 
93b7 f1				pop af 
93b8 2a 3a ea			ld hl,(cli_ptr) 
93bb 3e 30			ld a, display_row_2+8 
93bd cd 79 93			call display_word_at 
93c0			 
93c0			 
93c0				; display hl 
93c0			 
93c0			 
93c0 11 89 95			ld de, .ptrclioptr 
93c3 3e 32			ld a, display_row_2+10 
93c5 cd d0 8a			call str_at_display 
93c8			; 
93c8			;	pop hl 
93c8 3e 35			ld a, display_row_2+13 
93ca 2a 38 ea			ld hl,(cli_origptr) 
93cd cd 79 93			call display_word_at 
93d0			; 
93d0			;	 
93d0			;	; display de 
93d0			 
93d0			;	ld de, .regstatede 
93d0			;	ld a, display_row_3 
93d0			;	call str_at_display 
93d0			 
93d0			;	pop de 
93d0			;	ld h,d 
93d0			;	ld l, e 
93d0			;	ld a, display_row_3+3 
93d0			;	call display_word_at 
93d0			 
93d0			 
93d0				; display bc 
93d0			 
93d0			;	ld de, .regstatebc 
93d0			;	ld a, display_row_3+10 
93d0			;	call str_at_display 
93d0			 
93d0			;	pop bc 
93d0			;	ld h,b 
93d0			;	ld l, c 
93d0			;	ld a, display_row_3+13 
93d0			;	call display_word_at 
93d0			 
93d0			 
93d0				; display dsp 
93d0			 
93d0			;	ld de, .regstatedsp 
93d0			;	ld a, display_row_4 
93d0			;	call str_at_display 
93d0			 
93d0				 
93d0			;	ld hl,(cli_data_sp) 
93d0			;	ld a, display_row_4+4 
93d0			;	call display_word_at 
93d0			 
93d0				; display rsp 
93d0			 
93d0 11 b8 95			ld de, .regstatersp 
93d3 3e 82			ld a, display_row_4+10 
93d5 cd d0 8a			call str_at_display 
93d8			 
93d8				 
93d8 2a ec e9			ld hl,(cli_ret_sp) 
93db 3e 86			ld a, display_row_4+14 
93dd cd 79 93			call display_word_at 
93e0			 
93e0 cd e0 8a			call update_display 
93e3			 
93e3 cd 00 8a			call delay1s 
93e6 cd 00 8a			call delay1s 
93e9 cd 00 8a			call delay1s 
93ec			 
93ec			 
93ec cd fd 99			call next_page_prompt 
93ef			 
93ef				; restore  
93ef			 
93ef f1				pop af 
93f0 e1				pop hl 
93f1 c1				pop bc 
93f2 d1				pop de 
93f3 c9				ret 
93f4			 
93f4			; Update the break point vector so that the user can hook a new routine 
93f4			 
93f4			bp_on: 
93f4 3e c3			ld a, $c3    ; JP 
93f6 32 6f ee			ld (debug_vector), a 
93f9 21 06 94			ld hl, break_point_state 
93fc 22 70 ee			ld (debug_vector+1), hl 
93ff c9				ret 
9400			 
9400			bp_off: 
9400 3e c9			ld a, $c9    ; RET 
9402 32 6f ee			ld (debug_vector), a 
9405 c9				ret 
9406			 
9406			 
9406			break_point_state: 
9406			;	push af 
9406			; 
9406			;	; see if disabled 
9406			; 
9406			;	ld a, (os_view_disable) 
9406			;	cp '*' 
9406			;	jr nz, .bpsgo 
9406			;	pop af 
9406			;	ret 
9406			 
9406			.bpsgo: 
9406			;	pop af 
9406 f5				push af 
9407 22 9d e2			ld (os_view_hl), hl 
940a ed 53 9b e2		ld (os_view_de), de 
940e ed 43 99 e2		ld (os_view_bc), bc 
9412 e5				push hl 
9413 6f				ld l, a 
9414 26 00			ld h, 0 
9416 22 9f e2			ld (os_view_af),hl 
9419			 
9419 21 ab ed				ld hl, display_fb0 
941c 22 c6 eb				ld (display_fb_active), hl 
941f e1				pop hl	 
9420			 
9420 3e 31			ld a, '1' 
9422 fe 2a		.bps1:  cp '*' 
9424 cc 00 94			call z, bp_off 
9427			;	jr nz, .bps1b 
9427			;	ld (os_view_disable),a 
9427 fe 31		.bps1b:  cp '1' 
9429 20 14			jr nz, .bps2 
942b			 
942b				; display reg 
942b			 
942b				 
942b			 
942b 3a 9f e2			ld a, (os_view_af) 
942e 2a 9d e2			ld hl, (os_view_hl) 
9431 ed 5b 9b e2		ld de, (os_view_de) 
9435 ed 4b 99 e2		ld bc, (os_view_bc) 
9439 cd d3 94			call display_reg_state 
943c c3 bf 94			jp .bpschk 
943f			 
943f fe 32		.bps2:  cp '2' 
9441 20 08			jr nz, .bps3 
9443				 
9443				; display hl 
9443 2a 9d e2			ld hl, (os_view_hl) 
9446 cd bd 95			call display_dump_at_hl 
9449			 
9449 18 74			jr .bpschk 
944b			 
944b fe 33		.bps3:  cp '3' 
944d 20 08			jr nz, .bps4 
944f			 
944f			        ; display de 
944f 2a 9b e2			ld hl, (os_view_de) 
9452 cd bd 95			call display_dump_at_hl 
9455			 
9455 18 68			jr .bpschk 
9457 fe 34		.bps4:  cp '4' 
9459 20 08			jr nz, .bps5 
945b			 
945b			        ; display bc 
945b 2a 99 e2			ld hl, (os_view_bc) 
945e cd bd 95			call display_dump_at_hl 
9461			 
9461 18 5c			jr .bpschk 
9463 fe 35		.bps5:  cp '5' 
9465 20 08		        jr nz, .bps7 
9467			 
9467				; display cur ptr 
9467 2a 3a ea			ld hl, (cli_ptr) 
946a cd bd 95			call display_dump_at_hl 
946d			 
946d 18 50			jr .bpschk 
946f fe 36		.bps7:  cp '6' 
9471 20 08			jr nz, .bps8b 
9473				 
9473				; display cur orig ptr 
9473 2a 38 ea			ld hl, (cli_origptr) 
9476 cd bd 95			call display_dump_at_hl 
9479 18 44			jr .bpschk 
947b fe 37		.bps8b:  cp '7' 
947d 20 08			jr nz, .bps9 
947f				 
947f				; display dsp 
947f 2a e8 e9			ld hl, (cli_data_sp) 
9482 cd bd 95			call display_dump_at_hl 
9485			 
9485 18 38			jr .bpschk 
9487 fe 39		.bps9:  cp '9' 
9489 20 05			jr nz, .bps8c 
948b				 
948b				; display SP 
948b			;	ld hl, sp 
948b cd bd 95			call display_dump_at_hl 
948e			 
948e 18 2f			jr .bpschk 
9490 fe 38		.bps8c:  cp '8' 
9492 20 08			jr nz, .bps8d 
9494				 
9494				; display rsp 
9494 2a ec e9			ld hl, (cli_ret_sp) 
9497 cd bd 95			call display_dump_at_hl 
949a			 
949a 18 23			jr .bpschk 
949c fe 23		.bps8d:  cp '#'     ; access monitor sub system 
949e 20 05			jr nz, .bps8 
94a0 cd b7 97			call monitor 
94a3			 
94a3 18 1a			jr .bpschk 
94a5 fe 30		.bps8:  cp '0' 
94a7 20 16			jr nz, .bpschk 
94a9			 
94a9 21 0a ed				ld hl, display_fb1 
94ac 22 c6 eb				ld (display_fb_active), hl 
94af cd e0 8a				call update_display 
94b2			 
94b2				;ld a, (os_view_af) 
94b2 2a 9d e2			ld hl, (os_view_hl) 
94b5 ed 5b 9b e2		ld de, (os_view_de) 
94b9 ed 4b 99 e2		ld bc, (os_view_bc) 
94bd f1				pop af 
94be c9				ret 
94bf			 
94bf			.bpschk:   
94bf cd 00 8a			call delay1s 
94c2 3e 9f		ld a,display_row_4 + display_cols - 1 
94c4 11 fb 99		        ld de, endprg 
94c7 cd d0 8a			call str_at_display 
94ca cd e0 8a			call update_display 
94cd cd 82 df			call cin_wait 
94d0			 
94d0 c3 22 94			jp .bps1 
94d3			 
94d3			 
94d3			display_reg_state: 
94d3			 
94d3				; to restore afterwards 
94d3			 
94d3 d5				push de 
94d4 c5				push bc 
94d5 e5				push hl 
94d6 f5				push af 
94d7			 
94d7				; for use in here 
94d7			 
94d7 c5				push bc 
94d8 d5				push de 
94d9 e5				push hl 
94da f5				push af 
94db			 
94db cd bd 8a			call clear_display 
94de			 
94de 11 93 95			ld de, .regstate 
94e1 3e 00			ld a, display_row_1 
94e3 cd d0 8a			call str_at_display 
94e6			 
94e6				; display debug step 
94e6			 
94e6			 
94e6 11 65 ee			ld de, debug_mark 
94e9 3e 25			ld a, display_row_1+display_cols-3 
94eb cd d0 8a			call str_at_display 
94ee			 
94ee				; display a 
94ee 11 af 95			ld de, .regstatea 
94f1 3e 28			ld a, display_row_2 
94f3 cd d0 8a			call str_at_display 
94f6			 
94f6 e1				pop hl 
94f7			;	ld h,0 
94f7			;	ld l, a 
94f7 3e 2b			ld a, display_row_2+3 
94f9 cd 79 93			call display_word_at 
94fc			 
94fc			 
94fc				; display hl 
94fc			 
94fc			 
94fc 11 a3 95			ld de, .regstatehl 
94ff 3e 32			ld a, display_row_2+10 
9501 cd d0 8a			call str_at_display 
9504			 
9504 e1				pop hl 
9505 3e 35			ld a, display_row_2+13 
9507 cd 79 93			call display_word_at 
950a			 
950a				 
950a				; display de 
950a			 
950a 11 a7 95			ld de, .regstatede 
950d 3e 50			ld a, display_row_3 
950f cd d0 8a			call str_at_display 
9512			 
9512 e1				pop hl 
9513			;	ld h,d 
9513			;	ld l, e 
9513 3e 53			ld a, display_row_3+3 
9515 cd 79 93			call display_word_at 
9518			 
9518			 
9518				; display bc 
9518			 
9518 11 ab 95			ld de, .regstatebc 
951b 3e 5a			ld a, display_row_3+10 
951d cd d0 8a			call str_at_display 
9520			 
9520 e1				pop hl 
9521			;	ld h,b 
9521			;	ld l, c 
9521 3e 5d			ld a, display_row_3+13 
9523 cd 79 93			call display_word_at 
9526			 
9526			 
9526				; display dsp 
9526			 
9526 11 b3 95			ld de, .regstatedsp 
9529 3e 78			ld a, display_row_4 
952b cd d0 8a			call str_at_display 
952e			 
952e				 
952e 2a e8 e9			ld hl,(cli_data_sp) 
9531 3e 7c			ld a, display_row_4+4 
9533 cd 79 93			call display_word_at 
9536			 
9536				; display rsp 
9536			 
9536 11 b8 95			ld de, .regstatersp 
9539 3e 82			ld a, display_row_4+10 
953b cd d0 8a			call str_at_display 
953e			 
953e				 
953e 2a ec e9			ld hl,(cli_ret_sp) 
9541 3e 86			ld a, display_row_4+14 
9543 cd 79 93			call display_word_at 
9546			 
9546 cd e0 8a			call update_display 
9549			 
9549			;	call delay1s 
9549			;	call delay1s 
9549			;	call delay1s 
9549			 
9549			 
9549			;	call next_page_prompt 
9549			 
9549				; restore  
9549			 
9549 f1				pop af 
954a e1				pop hl 
954b c1				pop bc 
954c d1				pop de 
954d c9				ret 
954e			 
954e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9562 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9577 .. 00		.ptrstate:	db "Ptr State",0 
9581 .. 00		.ptrcliptr:     db "cli_ptr",0 
9589 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9593 .. 00		.regstate:	db "Reg State (1/0)",0 
95a3 .. 00		.regstatehl:	db "HL:",0 
95a7 .. 00		.regstatede:	db "DE:",0 
95ab .. 00		.regstatebc:	db "BC:",0 
95af .. 00		.regstatea:	db "A :",0 
95b3 .. 00		.regstatedsp:	db "DSP:",0 
95b8 .. 00		.regstatersp:	db "RSP:",0 
95bd			 
95bd			display_dump_at_hl: 
95bd e5				push hl 
95be d5				push de 
95bf c5				push bc 
95c0 f5				push af 
95c1			 
95c1 22 de e5			ld (os_cur_ptr),hl	 
95c4 cd bd 8a			call clear_display 
95c7 cd 05 99			call dumpcont 
95ca			;	call delay1s 
95ca			;	call next_page_prompt 
95ca			 
95ca			 
95ca f1				pop af 
95cb c1				pop bc 
95cc d1				pop de 
95cd e1				pop hl 
95ce c9				ret 
95cf			 
95cf			;if ENABLE_BASIC 
95cf			;	include "nascombasic.asm" 
95cf			;	basic: 
95cf			;	include "forth/FORTH.ASM" 
95cf			;endif 
95cf			 
95cf			; eof 
95cf			 
95cf			 
# End of file firmware_diags.asm
95cf			  
95cf			include "firmware_prompts.asm"  
95cf			; Prompts  
95cf			 
95cf			; boot messages 
95cf			 
95cf .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
95e4 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
95f4			 
95f4			 
95f4			; config menus 
95f4			 
95f4			;prom_c3: db "Add Dictionary To File",0 
95f4			 
95f4			if STARTUP_V1 
95f4 .. 00		prom_c2: db "Select Autoload File",0 
9609 .. 00		prom_c2a: db "Disable Autoload File", 0 
961f			endif 
961f			 
961f			if STARTUP_V2 
961f			prom_c2: db "Enable Autoload Files",0 
961f			prom_c2a: db "Disable Autoload Files", 0 
961f			 
961f			crs_s1: db "*ls-word", 0 
961f			crs_s2: db "*ed-word", 0 
961f			crs_s3: db "*Demo-Games", 0 
961f			crs_s4: db "*Utils", 0 
961f			crs_s5: db "*SPI-Util", 0 
961f			crs_s6: db "*Key-Constants", 0 
961f			crs_sound: db "*Sound-Util", 0 
961f			crs_hw: db "*Hello-World",0 
961f			 
961f			 
961f			 
961f			endif 
961f			;prom_c2b: db "Select Storage Bank",0 
961f .. 00		prom_c4: db "Settings",0 
9628 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9643 .. 00		prom_m4b:   db "Monitor",0 
964b .. 00		prom_c1: db "Hardware Diags",0 
965a			 
965a			 
965a			if STARTUP_V2 
965a			prom_c9: db "Create Startup Files",0 
965a			endif 
965a			 
965a .. 00		prom_notav:    db "Feature not available",0 
9670 .. 00		prom_empty:    db "",0 
9671			 
9671			; eof 
9671			 
# End of file firmware_prompts.asm
9671			  
9671			  
9671			; eof  
9671			  
# End of file firmware.asm
9671			 
9671			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9671			;if BASE_KEV  
9671			;baseram: equ 08000h 
9671			;endif 
9671			 
9671			;if BASE_SC114 
9671			;baseram:     equ    endofcode 
9671			;endif 
9671			 
9671			 
9671			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9671			 
9671			; start system 
9671			 
9671			coldstart: 
9671				; set sp 
9671				; di/ei 
9671			 
9671 f3				di 
9672 31 00 f0			ld sp, tos 
9675 cd cc de			call init_nmi 
9678			;	ei 
9678			 
9678				; init spinner 
9678 3e 00			ld a,0 
967a 32 c0 eb			ld (display_active), a 
967d			 
967d				; disable breakpoint by default 
967d			 
967d				;ld a,'*' 
967d			;	ld a,' ' 
967d			;	ld (os_view_disable),a 
967d			 
967d				; set break point vector as new break point on or off 
967d cd 00 94			call bp_off 
9680			 
9680				; init hardware 
9680			 
9680				; init keyboard and screen hardware 
9680			 
9680 cd 1f 80			call hardware_init 
9683			 
9683			 
9683 cd 00 8a			call delay1s 
9686 3e 58			ld a, display_row_3+8 
9688 11 03 80			ld de, buildtime 
968b cd d0 8a			call str_at_display 
968e cd e0 8a			call update_display 
9691			 
9691 cd 00 8a			call delay1s 
9694 cd 00 8a			call delay1s 
9697 cd 00 8a			call delay1s 
969a			 
969a				; detect if any keys are held down to enable breakpoints at start up 
969a			 
969a cd 88 df			call cin  
969d fe 00			cp 0 
969f 28 03			jr z, .nokeys 
96a1			 
96a1				;call hardware_diags 
96a1 cd 5e 92			call config 
96a4			 
96a4			;	ld de, .bpen 
96a4			;	ld a, display_row_4 
96a4			;	call str_at_display 
96a4			;	call update_display 
96a4			; 
96a4			;	ld a,0 
96a4			;	ld (os_view_disable),a 
96a4			; 
96a4			;.bpwait: 
96a4			;	call cin 
96a4			;	cp 0 
96a4			;	jr z, .bpwait 
96a4			;	jr .nokeys 
96a4			; 
96a4			; 
96a4			;.bpen:  db "Break points enabled!",0 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			.nokeys: 
96a4			 
96a4			 
96a4				 
96a4			 
96a4			;jp  testkey 
96a4			 
96a4			;call storage_get_block_0 
96a4			; 
96a4			;ld hl, 0 
96a4			;ld de, store_page 
96a4			;call storage_read_block 
96a4			 
96a4				 
96a4			;ld hl, 10 
96a4			;ld de, store_page 
96a4			;call storage_read_block 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			;stop:	nop 
96a4			;	jp stop 
96a4			 
96a4			 
96a4			 
96a4			main: 
96a4 cd bd 8a			call clear_display 
96a7 cd e0 8a			call update_display 
96aa			 
96aa			 
96aa			 
96aa			;	call testlcd 
96aa			 
96aa			 
96aa			 
96aa cd 46 9e			call forth_init 
96ad			 
96ad			 
96ad			warmstart: 
96ad cd 1c 9e			call forth_warmstart 
96b0			 
96b0				; run startup word load 
96b0			        ; TODO prevent this running at warmstart after crash  
96b0			 
96b0				if STARTUP_ENABLE 
96b0			 
96b0					if STARTUP_V1 
96b0			 
96b0						if STORAGE_SE 
96b0							call forth_autoload 
96b0						endif 
96b0 cd 1c de					call forth_startup 
96b3					endif 
96b3			 
96b3					if STARTUP_V2 
96b3			 
96b3						if STORAGE_SE 
96b3							call forth_autoload 
96b3						else 
96b3							call forth_startup 
96b3						endif 
96b3			 
96b3			 
96b3					endif 
96b3			 
96b3				endif 
96b3			 
96b3			warmstart_afterauto: 
96b3			 
96b3				; show free memory after boot 
96b3 11 52 97			ld de, freeram 
96b6 3e 00			ld a, display_row_1 
96b8 cd d0 8a			call str_at_display 
96bb			 
96bb				; get current heap start after loading any uwords 
96bb			 
96bb				;ld de, (os_last_new_uword) 
96bb				;ex de, hl 
96bb			 
96bb			; Or use heap_size word???? 
96bb				;ld hl, heap_end 
96bb				;ld hl, heap_size 
96bb				;ld de, topusermem 
96bb				;ld de, heap_start 
96bb ed 5b a1 df			ld de, (free_list )      
96bf 21 96 e2				ld hl, heap_end 
96c2 ed 52			sbc hl, de 
96c4				;push hl 
96c4				;ld a,h	         	 
96c4				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96c4				;call hexout 
96c4			   	;pop hl 
96c4			; 
96c4			;	ld a,l 
96c4			;	ld hl, os_word_scratch+2 
96c4			;	call hexout 
96c4			;	ld hl, os_word_scratch+4 
96c4			;	ld a, 0 
96c4			;	ld (hl),a 
96c4 eb				ex de, hl 
96c5 21 c0 e5			ld hl, os_word_scratch 
96c8 cd ff 8f			call uitoa_16 
96cb			 
96cb			 
96cb 11 c0 e5			ld de, os_word_scratch 
96ce 3e 0d			ld a, display_row_1 + 13 
96d0 cd d0 8a			call str_at_display 
96d3 cd e0 8a			call update_display 
96d6			 
96d6			 
96d6				;call demo 
96d6			 
96d6			 
96d6				; init scratch input area for cli commands 
96d6			 
96d6 21 e2 e5			ld hl, os_cli_cmd 
96d9 3e 00			ld a,0 
96db 77				ld (hl),a 
96dc 23				inc hl 
96dd 77				ld (hl),a 
96de			 
96de 3e 00			ld a,0 
96e0 32 e1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
96e3			 
96e3 32 de e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
96e6 32 df e5			ld (os_cur_ptr+1),a	 
96e9			 
96e9 32 c0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
96ec 32 c1 e5			ld (os_word_scratch+1),a	 
96ef				 
96ef			 
96ef				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96ef 21 e2 e5			ld hl, os_cli_cmd 
96f2			 
96f2 3e 00			ld a, 0		 ; init cli input 
96f4 77				ld (hl), a 
96f5 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96f7			cli: 
96f7				; show cli prompt 
96f7				;push af 
96f7				;ld a, 0 
96f7				;ld de, prompt 
96f7				;call str_at_display 
96f7			 
96f7				;call update_display 
96f7				;pop af 
96f7				;inc a 
96f7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
96f7			 
96f7			.lastrecall: 
96f7			 
96f7 0e 00			ld c, 0 
96f9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
96fb 1e 28			ld e, 40 
96fd			 
96fd 21 e2 e5			ld hl, os_cli_cmd 
9700			 
9700				STACKFRAME OFF $fefe $9f9f 
9700				if DEBUG_STACK_IMB 
9700					if OFF 
9700						exx 
9700						ld de, $fefe 
9700						ld a, d 
9700						ld hl, curframe 
9700						call hexout 
9700						ld a, e 
9700						ld hl, curframe+2 
9700						call hexout 
9700						ld hl, $fefe 
9700						push hl 
9700						ld hl, $9f9f 
9700						push hl 
9700						exx 
9700					endif 
9700				endif 
9700			endm 
# End of macro STACKFRAME
9700			 
9700 cd 17 8d			call input_str 
9703			 
9703				STACKFRAMECHK OFF $fefe $9f9f 
9703				if DEBUG_STACK_IMB 
9703					if OFF 
9703						exx 
9703						ld hl, $9f9f 
9703						pop de   ; $9f9f 
9703						call cmp16 
9703						jr nz, .spnosame 
9703						ld hl, $fefe 
9703						pop de   ; $fefe 
9703						call cmp16 
9703						jr z, .spfrsame 
9703						.spnosame: call showsperror 
9703						.spfrsame: nop 
9703						exx 
9703					endif 
9703				endif 
9703			endm 
# End of macro STACKFRAMECHK
9703			 
9703			 
9703				; check to see if last line recall has been requested 
9703			 
9703			if EDIT_V2 
9703 fe 05			cp KEY_UP 
9705 20 0f			jr nz, .noexecline 
9707			 
9707 11 e2 e5			ld de, os_cli_cmd 
970a 21 e1 e6			ld hl, os_last_cmd 
970d 01 ff 00			ld bc, 255 
9710 ed b0			ldir 
9712 3e 00			ld a, 0 
9714 18 e1			jr .lastrecall 
9716			endif 
9716			 
9716			.noexecline: 
9716				; no so exec the line		 
9716			 
9716				; copy input to last command 
9716			 
9716 21 e2 e5			ld hl, os_cli_cmd 
9719 11 e1 e6			ld de, os_last_cmd 
971c 01 ff 00			ld bc, 255 
971f ed b0			ldir 
9721			 
9721				; wipe current buffer 
9721			 
9721			;	ld a, 0 
9721			;	ld hl, os_cli_cmd 
9721			;	ld de, os_cli_cmd+1 
9721			;	ld bc, 254 
9721			;	ldir 
9721				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9721			;	call strcpy 
9721			;	ld a, 0 
9721			;	ld (hl), a 
9721			;	inc hl 
9721			;	ld (hl), a 
9721			;	inc hl 
9721			;	ld (hl), a 
9721			 
9721				; switch frame buffer to program  
9721			 
9721 21 0a ed				ld hl, display_fb1 
9724 22 c6 eb				ld (display_fb_active), hl 
9727			 
9727			;	nop 
9727				STACKFRAME ON $fbfe $8f9f 
9727				if DEBUG_STACK_IMB 
9727					if ON 
9727						exx 
9727						ld de, $fbfe 
9727						ld a, d 
9727						ld hl, curframe 
9727						call hexout 
9727						ld a, e 
9727						ld hl, curframe+2 
9727						call hexout 
9727						ld hl, $fbfe 
9727						push hl 
9727						ld hl, $8f9f 
9727						push hl 
9727						exx 
9727					endif 
9727				endif 
9727			endm 
# End of macro STACKFRAME
9727				; first time into the parser so pass over the current scratch pad 
9727 21 e2 e5			ld hl,os_cli_cmd 
972a				; tokenise the entered statement(s) in HL 
972a cd c0 9e			call forthparse 
972d			        ; exec forth statements in top of return stack 
972d cd fc 9e			call forthexec 
9730				;call forthexec_cleanup 
9730			;	call parsenext 
9730			 
9730				STACKFRAMECHK ON $fbfe $8f9f 
9730				if DEBUG_STACK_IMB 
9730					if ON 
9730						exx 
9730						ld hl, $8f9f 
9730						pop de   ; $8f9f 
9730						call cmp16 
9730						jr nz, .spnosame 
9730						ld hl, $fbfe 
9730						pop de   ; $fbfe 
9730						call cmp16 
9730						jr z, .spfrsame 
9730						.spnosame: call showsperror 
9730						.spfrsame: nop 
9730						exx 
9730					endif 
9730				endif 
9730			endm 
# End of macro STACKFRAMECHK
9730				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9730			 
9730 3e 78			ld a, display_row_4 
9732 11 63 97			ld de, endprog 
9735			 
9735 cd e0 8a			call update_display		 
9738			 
9738 cd fd 99			call next_page_prompt 
973b			 
973b				; switch frame buffer to cli 
973b			 
973b 21 ab ed				ld hl, display_fb0 
973e 22 c6 eb				ld (display_fb_active), hl 
9741			 
9741			 
9741 cd bd 8a		        call clear_display 
9744 cd e0 8a			call update_display		 
9747			 
9747 21 e2 e5			ld hl, os_cli_cmd 
974a			 
974a 3e 00			ld a, 0		 ; init cli input 
974c 77				ld (hl), a 
974d			 
974d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
974d			 
974d				; now on last line 
974d			 
974d				; TODO scroll screen up 
974d			 
974d				; TODO instead just clear screen and place at top of screen 
974d			 
974d			;	ld a, 0 
974d			;	ld (f_cursor_ptr),a 
974d			 
974d				;call clear_display 
974d				;call update_display 
974d			 
974d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974f c3 f7 96			jp cli 
9752			 
9752 .. 00		freeram: db "Free bytes: ",0 
975f ..			asc: db "1A2F" 
9763 .. 00		endprog: db "End prog...",0 
976f			 
976f			testenter2:   
976f 21 ed e2			ld hl,scratch+50 
9772 22 de e5			ld (os_cur_ptr),hl 
9775 c3 f7 96			jp cli 
9778			 
9778			testenter:  
9778			 
9778 21 5f 97			ld hl,asc 
977b			;	ld a,(hl) 
977b			;	call nibble2val 
977b cd 49 8f			call get_byte 
977e			 
977e			 
977e			;	ld a,(hl) 
977e			;	call atohex 
977e			 
977e			;	call fourehexhl 
977e 32 ed e2			ld (scratch+50),a 
9781			 
9781			 
9781			 
9781 21 61 97			ld hl,asc+2 
9784			;	ld a, (hl) 
9784			;	call nibble2val 
9784 cd 49 8f			call get_byte 
9787			 
9787			;	call fourehexhl 
9787 32 ef e2			ld (scratch+52),a 
978a				 
978a 21 ed e2			ld hl,scratch+50 
978d 22 de e5			ld (os_cur_ptr),hl 
9790 c3 f7 96			jp cli 
9793			 
9793			enter:	 
9793 3a bf e2			ld a,(scratch+4) 
9796 fe 00			cp 0 
9798 28 0c			jr z, .entercont 
979a				; no, not a null term line so has an address to work out.... 
979a			 
979a 21 bd e2			ld hl,scratch+2 
979d cd a9 8f			call get_word_hl 
97a0			 
97a0 22 de e5			ld (os_cur_ptr),hl	 
97a3 c3 f7 96			jp cli 
97a6			 
97a6			 
97a6			.entercont:  
97a6			 
97a6 21 bd e2			ld hl, scratch+2 
97a9 cd 49 8f			call get_byte 
97ac			 
97ac 2a de e5		   	ld hl,(os_cur_ptr) 
97af 77					ld (hl),a 
97b0 23					inc hl 
97b1 22 de e5				ld (os_cur_ptr),hl 
97b4				 
97b4			; get byte  
97b4			 
97b4			 
97b4 c3 f7 96			jp cli 
97b7			 
97b7			 
97b7			; basic monitor support 
97b7			 
97b7			monitor: 
97b7				;  
97b7 cd bd 8a			call clear_display 
97ba 3e 00			ld a, 0 
97bc 11 10 98			ld de, .monprompt 
97bf cd d0 8a			call str_at_display 
97c2 cd e0 8a			call update_display 
97c5			 
97c5				; get a monitor command 
97c5			 
97c5 0e 00			ld c, 0     ; entry at top left 
97c7 16 64			ld d, 100   ; max buffer size 
97c9 1e 0f			ld e, 15    ; input scroll area 
97cb 3e 00			ld a, 0     ; init string 
97cd 21 b9 e4			ld hl, os_input 
97d0 77				ld (hl), a 
97d1 23				inc hl 
97d2 77				ld (hl), a 
97d3 21 b9 e4			ld hl, os_input 
97d6 3e 01			ld a, 1     ; init string 
97d8 cd 17 8d			call input_str 
97db			 
97db cd bd 8a		        call clear_display 
97de cd e0 8a			call update_display		 
97e1			 
97e1 3a b9 e4			ld a, (os_input) 
97e4 cd 47 90			call toUpper 
97e7 fe 48		        cp 'H' 
97e9 ca 84 98		        jp z, .monhelp 
97ec fe 44			cp 'D'		; dump 
97ee ca b7 98			jp z, .mondump	 
97f1 fe 43			cp 'C'		; dump 
97f3 ca d1 98			jp z, .moncdump	 
97f6 fe 4d			cp 'M'		; dump 
97f8 ca 12 98			jp z, .moneditstart 
97fb fe 55			cp 'U'		; dump 
97fd ca 1e 98			jp z, .monedit	 
9800 fe 47			cp 'G'		; dump 
9802 ca ad 98			jp z, .monjump 
9805 fe 42			cp 'B'		; forth breakpoint 
9807 cc 06 94			call z, break_point_state 
980a fe 51			cp 'Q'		; dump 
980c c8				ret z	 
980d			 
980d			 
980d				; TODO "S" to access symbol by name and not need the address 
980d				; TODO "F" to find a string in memory 
980d			 
980d c3 b7 97			jp monitor 
9810			 
9810 .. 00		.monprompt: db ">", 0 
9812			 
9812			.moneditstart: 
9812				; get starting address 
9812			 
9812 21 bb e4			ld hl,os_input+2 
9815 cd a9 8f			call get_word_hl 
9818			 
9818 22 de e5			ld (os_cur_ptr),hl	 
981b			 
981b c3 b7 97			jp monitor 
981e			 
981e			.monedit: 
981e				; get byte to load 
981e			 
981e 21 bb e4			ld hl,os_input+2 
9821 cd 49 8f			call get_byte 
9824			 
9824				; get address to update 
9824 2a de e5			ld hl, (os_cur_ptr) 
9827			 
9827				; update byte 
9827			 
9827 77				ld (hl), a 
9828			 
9828				; move to next address and save it 
9828			 
9828 23				inc hl 
9829 22 de e5			ld (os_cur_ptr),hl	 
982c			 
982c c3 b7 97			jp monitor 
982f			 
982f			 
982f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9843 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
985f .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
987d .. 00		.monhelptext4:  db "Q-Quit",0 
9884			        
9884			.monhelp: 
9884 3e 00			ld a, display_row_1 
9886 11 2f 98		        ld de, .monhelptext1 
9889			 
9889 cd d0 8a			call str_at_display 
988c 3e 28			ld a, display_row_2 
988e 11 43 98		        ld de, .monhelptext2 
9891					 
9891 cd d0 8a			call str_at_display 
9894 3e 50			ld a, display_row_3 
9896 11 5f 98		        ld de, .monhelptext3 
9899					 
9899 cd d0 8a			call str_at_display 
989c 3e 78			ld a, display_row_4 
989e 11 7d 98		        ld de, .monhelptext4 
98a1 cd d0 8a			call str_at_display 
98a4			 
98a4 cd e0 8a			call update_display		 
98a7			 
98a7 cd fd 99			call next_page_prompt 
98aa c3 b7 97			jp monitor 
98ad			 
98ad			.monjump:    
98ad 21 bb e4			ld hl,os_input+2 
98b0 cd a9 8f			call get_word_hl 
98b3			 
98b3 e9				jp (hl) 
98b4 c3 b7 97			jp monitor 
98b7			 
98b7			.mondump:    
98b7 21 bb e4			ld hl,os_input+2 
98ba cd a9 8f			call get_word_hl 
98bd			 
98bd 22 de e5			ld (os_cur_ptr),hl	 
98c0 cd 05 99			call dumpcont 
98c3 3e 78			ld a, display_row_4 
98c5 11 63 97			ld de, endprog 
98c8			 
98c8 cd e0 8a			call update_display		 
98cb			 
98cb cd fd 99			call next_page_prompt 
98ce c3 b7 97			jp monitor 
98d1			.moncdump: 
98d1 cd 05 99			call dumpcont 
98d4 3e 78			ld a, display_row_4 
98d6 11 63 97			ld de, endprog 
98d9			 
98d9 cd e0 8a			call update_display		 
98dc			 
98dc cd fd 99			call next_page_prompt 
98df c3 b7 97			jp monitor 
98e2			 
98e2			 
98e2			; TODO symbol access  
98e2			 
98e2			.symbols:     ;; A list of symbols that can be called up  
98e2 ab ed			dw display_fb0 
98e4 .. 00			db "fb0",0  
98e8 74 ea		     	dw store_page 
98ea .. 00			db "store_page",0 
98f5			 
98f5			 
98f5			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
98f5			 
98f5 3a bc e2			ld a,(scratch+1) 
98f8 fe 00			cp 0 
98fa 28 09			jr z, dumpcont 
98fc			 
98fc				; no, not a null term line so has an address to work out.... 
98fc			 
98fc 21 bd e2			ld hl,scratch+2 
98ff cd a9 8f			call get_word_hl 
9902			 
9902 22 de e5			ld (os_cur_ptr),hl	 
9905			 
9905			 
9905			 
9905			dumpcont: 
9905			 
9905				; dump bytes at ptr 
9905			 
9905			 
9905 3e 00			ld a, display_row_1 
9907 2a c6 eb			ld hl, (display_fb_active) 
990a cd ea 8c			call addatohl 
990d cd 35 99			call .dumpbyterow 
9910			 
9910 3e 28			ld a, display_row_2 
9912 2a c6 eb			ld hl, (display_fb_active) 
9915 cd ea 8c			call addatohl 
9918 cd 35 99			call .dumpbyterow 
991b			 
991b			 
991b 3e 50			ld a, display_row_3 
991d 2a c6 eb			ld hl, (display_fb_active) 
9920 cd ea 8c			call addatohl 
9923 cd 35 99			call .dumpbyterow 
9926			 
9926 3e 78			ld a, display_row_4 
9928 2a c6 eb			ld hl, (display_fb_active) 
992b cd ea 8c			call addatohl 
992e cd 35 99			call .dumpbyterow 
9931			 
9931 cd e0 8a			call update_display 
9934			;		jp cli 
9934 c9				ret 
9935			 
9935			.dumpbyterow: 
9935			 
9935				;push af 
9935			 
9935 e5				push hl 
9936			 
9936				; calc where to poke the ascii 
9936			if display_cols == 20 
9936				ld a, 16 
9936			else 
9936 3e 1f			ld a, 31 
9938			endif 
9938			 
9938 cd ea 8c			call addatohl 
993b 22 c0 e5			ld (os_word_scratch),hl  		; save pos for later 
993e			 
993e			 
993e			; display decoding address 
993e 2a de e5		   	ld hl,(os_cur_ptr) 
9941			 
9941 7c				ld a,h 
9942 e1				pop hl 
9943 e5				push hl 
9944			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9944 cd f3 8e			call hexout 
9947 2a de e5		   	ld hl,(os_cur_ptr) 
994a			 
994a 7d				ld a,l 
994b e1				pop hl 
994c 23				inc hl 
994d 23				inc hl 
994e e5				push hl 
994f			;	ld hl, os_word_scratch+2 
994f cd f3 8e			call hexout 
9952 e1				pop hl 
9953 23				inc hl 
9954 23				inc hl 
9955				;ld hl, os_word_scratch+4 
9955 3e 3a			ld a, ':' 
9957 77				ld (hl),a 
9958 23				inc hl 
9959				;ld a, 0 
9959				;ld (hl),a 
9959				;ld de, os_word_scratch 
9959				;pop af 
9959				;push af 
9959			;		ld a, display_row_2 
9959			;		call str_at_display 
9959			;		call update_display 
9959			 
9959			 
9959			;pop af 
9959			;	add 5 
9959			 
9959			if display_cols == 20 
9959				ld b, 4 
9959			else 
9959 06 08			ld b, 8 
995b			endif	 
995b			 
995b			.dumpbyte: 
995b c5				push bc 
995c e5				push hl 
995d			 
995d			 
995d 2a de e5		   	ld hl,(os_cur_ptr) 
9960 7e					ld a,(hl) 
9961			 
9961					; poke the ascii to display 
9961 2a c0 e5				ld hl,(os_word_scratch) 
9964 77					ld (hl),a 
9965 23					inc hl 
9966 22 c0 e5				ld (os_word_scratch),hl 
9969			 
9969					 
9969			 
9969			 
9969 e1					pop hl 
996a e5					push hl 
996b			 
996b cd f3 8e				call hexout 
996e			 
996e					 
996e 2a de e5		   	ld hl,(os_cur_ptr) 
9971 23				inc hl 
9972 22 de e5		   	ld (os_cur_ptr),hl 
9975			 
9975 e1					pop hl 
9976 23					inc hl 
9977 23					inc hl 
9978 23					inc hl 
9979			 
9979			 
9979			 
9979					;ld a,0 
9979					;ld (os_word_scratch+2),a 
9979					;pop af 
9979					;push af 
9979			 
9979					;ld de, os_word_scratch 
9979					;call str_at_display 
9979			;		call update_display 
9979			;		pop af 
9979 c1					pop bc 
997a c6 03				add 3 
997c 10 dd			djnz .dumpbyte 
997e			 
997e				 
997e			 
997e c9				ret 
997f			 
997f			jump:	 
997f			 
997f 21 bd e2			ld hl,scratch+2 
9982 cd a9 8f			call get_word_hl 
9985				;ld hl,(scratch+2) 
9985				;call fourehexhl 
9985			 
9985 22 de e5			ld (os_cur_ptr),hl	 
9988			 
9988 e9				jp (hl) 
9989			 
9989			 
9989			 
9989			; TODO implement a basic monitor mode to start with 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			; testing and demo code during development 
9989			 
9989			 
9989 .. 00		str1: db "Enter some text...",0 
999c .. 00		clear: db "                    ",0 
99b1			 
99b1			demo: 
99b1			 
99b1			 
99b1			 
99b1			;	call update_display 
99b1			 
99b1				; init scratch input area for testing 
99b1 21 bb e2			ld hl, scratch	 
99b4 3e 00			ld a,0 
99b6 77				ld (hl),a 
99b7			 
99b7			 
99b7 3e 28		            LD   A, display_row_2 
99b9			;            CALL fLCD_Pos       ;Position cursor to location in A 
99b9 11 89 99		            LD   DE, str1 
99bc cd d0 8a			call str_at_display 
99bf			 
99bf			;            CALL fLCD_Str       ;Display string pointed to by DE 
99bf			cloop:	 
99bf 3e 50		            LD   A, display_row_3 
99c1			;            CALL fLCD_Pos       ;Position cursor to location in A 
99c1 11 9c 99		            LD   DE, clear 
99c4			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
99c4 cd d0 8a				call str_at_display 
99c7 3e 78			ld a, display_row_4 
99c9 11 f9 99			ld de, prompt 
99cc			 
99cc cd d0 8a				call str_at_display 
99cf cd e0 8a			call update_display 
99d2			 
99d2 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99d4 16 0a			ld d, 10 
99d6 21 bb e2			ld hl, scratch	 
99d9 cd 17 8d			call input_str 
99dc			 
99dc			;	call clear_display 
99dc			;'	call update_display 
99dc			 
99dc 3e 00		            LD   A, display_row_1 
99de			;            CALL fLCD_Pos       ;Position cursor to location in A 
99de 11 9c 99		            LD   DE, clear 
99e1 cd d0 8a				call str_at_display 
99e4			;            CALL fLCD_Str       ;Display string pointed to by DE 
99e4 3e 00		            LD   A, display_row_1 
99e6			;            CALL fLCD_Pos       ;Position cursor to location in A 
99e6 11 bb e2		            LD   DE, scratch 
99e9			;            CALL fLCD_Str       ;Display string pointed to by DE 
99e9 cd d0 8a				call str_at_display 
99ec cd e0 8a			call update_display 
99ef			 
99ef 3e 00				ld a,0 
99f1 21 bb e2			ld hl, scratch 
99f4 77				ld (hl),a 
99f5			 
99f5 00				nop 
99f6 c3 bf 99			jp cloop 
99f9			 
99f9			 
99f9			 
99f9			; OS Prompt 
99f9			 
99f9 .. 00		prompt: db ">",0 
99fb .. 00		endprg: db "?",0 
99fd			 
99fd			 
99fd			; handy next page prompt 
99fd			next_page_prompt: 
99fd e5				push hl 
99fe d5				push de 
99ff f5				push af 
9a00 c5				push bc 
9a01			 
9a01 3e 9f			ld a,display_row_4 + display_cols - 1 
9a03 11 fb 99		        ld de, endprg 
9a06 cd d0 8a			call str_at_display 
9a09 cd e0 8a			call update_display 
9a0c cd 82 df			call cin_wait 
9a0f c1				pop bc 
9a10 f1				pop af 
9a11 d1				pop de 
9a12 e1				pop hl 
9a13			 
9a13			 
9a13 c9				ret 
9a14			 
9a14			 
9a14			; forth parser 
9a14			 
9a14			; My forth kernel 
9a14			include "forth_kernel.asm" 
9a14			; 
9a14			; kernel to the forth OS 
9a14			 
9a14			DS_TYPE_STR: equ 1     ; string type 
9a14			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9a14			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9a14			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9a14			 
9a14			FORTH_PARSEV1: equ 0 
9a14			FORTH_PARSEV2: equ 0 
9a14			FORTH_PARSEV3: equ 0 
9a14			FORTH_PARSEV4: equ 0 
9a14			FORTH_PARSEV5: equ 0 
9a14			FORTH_PARSEV6: equ 1 
9a14			 
9a14			;if FORTH_PARSEV5 
9a14			;	FORTH_END_BUFFER: equ 0 
9a14			;else 
9a14			FORTH_END_BUFFER: equ 127 
9a14			;endif 
9a14			 
9a14			FORTH_TRUE: equ 1 
9a14			FORTH_FALSE: equ 0 
9a14			 
9a14			if FORTH_PARSEV4 
9a14			include "forth_stackops.asm" 
9a14			endif 
9a14			 
9a14			if FORTH_PARSEV5 
9a14			include "forth_stackopsv5.asm" 
9a14			endif 
9a14			 
9a14			if FORTH_PARSEV6 
9a14			include "forth_stackopsv5.asm" 
9a14			 
9a14			; Stack operations for v5 parser on wards 
9a14			; * DATA stack 
9a14			; * LOOP stack 
9a14			; * RETURN stack 
9a14			 
9a14			 
9a14			 
9a14			FORTH_CHK_DSP_UNDER: macro 
9a14				push hl 
9a14				push de 
9a14				ld hl,(cli_data_sp) 
9a14				ld de, cli_data_stack 
9a14				call cmp16 
9a14				jp c, fault_dsp_under 
9a14				pop de 
9a14				pop hl 
9a14				endm 
9a14			 
9a14			 
9a14			FORTH_CHK_RSP_UNDER: macro 
9a14				push hl 
9a14				push de 
9a14				ld hl,(cli_ret_sp) 
9a14				ld de, cli_ret_stack 
9a14				call cmp16 
9a14				jp c, fault_rsp_under 
9a14				pop de 
9a14				pop hl 
9a14				endm 
9a14			 
9a14			FORTH_CHK_LOOP_UNDER: macro 
9a14				push hl 
9a14				push de 
9a14				ld hl,(cli_loop_sp) 
9a14				ld de, cli_loop_stack 
9a14				call cmp16 
9a14				jp c, fault_loop_under 
9a14				pop de 
9a14				pop hl 
9a14				endm 
9a14			 
9a14			FORTH_ERR_TOS_NOTSTR: macro 
9a14				; TOSO might need more for checks when used 
9a14				push af 
9a14				ld a,(hl) 
9a14				cp DS_TYPE_STR 
9a14				jp nz, type_faultn   
9a14				pop af 
9a14				endm 
9a14			 
9a14			FORTH_ERR_TOS_NOTNUM: macro 
9a14				push af 
9a14				ld a,(hl) 
9a14				cp DS_TYPE_INUM 
9a14				jp nz, type_faultn   
9a14				pop af 
9a14				endm 
9a14			 
9a14			 
9a14			; increase data stack pointer and save hl to it 
9a14				 
9a14			FORTH_DSP_NEXT: macro 
9a14				call macro_forth_dsp_next 
9a14				endm 
9a14			 
9a14			 
9a14			macro_forth_dsp_next: 
9a14				if DEBUG_FORTH_STACK_GUARD 
9a14 cd f4 db				call check_stacks 
9a17				endif 
9a17 e5				push hl 
9a18 d5				push de 
9a19 eb				ex de,hl 
9a1a 2a e8 e9			ld hl,(cli_data_sp) 
9a1d 23				inc hl 
9a1e 23				inc hl 
9a1f			 
9a1f			; PARSEV5 
9a1f 23				inc hl 
9a20 22 e8 e9			ld (cli_data_sp),hl 
9a23 73				ld (hl), e 
9a24 23				inc hl 
9a25 72				ld (hl), d 
9a26 d1				pop de 
9a27 e1				pop hl 
9a28				if DEBUG_FORTH_STACK_GUARD 
9a28 cd f4 db				call check_stacks 
9a2b				endif 
9a2b c9				ret 
9a2c			 
9a2c			 
9a2c			; increase ret stack pointer and save hl to it 
9a2c				 
9a2c			FORTH_RSP_NEXT: macro 
9a2c				call macro_forth_rsp_next 
9a2c				endm 
9a2c			 
9a2c			macro_forth_rsp_next: 
9a2c				if DEBUG_FORTH_STACK_GUARD 
9a2c cd f4 db				call check_stacks 
9a2f				endif 
9a2f e5				push hl 
9a30 d5				push de 
9a31 eb				ex de,hl 
9a32 2a ec e9			ld hl,(cli_ret_sp) 
9a35 23				inc hl 
9a36 23				inc hl 
9a37 22 ec e9			ld (cli_ret_sp),hl 
9a3a 73				ld (hl), e 
9a3b 23				inc hl 
9a3c 72				ld (hl), d 
9a3d d1				pop de 
9a3e e1				pop hl 
9a3f				if DEBUG_FORTH_STACK_GUARD 
9a3f cd f4 db				call check_stacks 
9a42				endif 
9a42 c9				ret 
9a43			 
9a43			; get current ret stack pointer and save to hl  
9a43				 
9a43			FORTH_RSP_TOS: macro 
9a43				call macro_forth_rsp_tos 
9a43				endm 
9a43			 
9a43			macro_forth_rsp_tos: 
9a43				;push de 
9a43 2a ec e9			ld hl,(cli_ret_sp) 
9a46 cd 7e 9a			call loadhlptrtohl 
9a49				;ld e, (hl) 
9a49				;inc hl 
9a49				;ld d, (hl) 
9a49				;ex de, hl 
9a49					if DEBUG_FORTH_WORDS 
9a49			;			DMARK "RST" 
9a49						CALLMONITOR 
9a49 cd 6f ee			call debug_vector  
9a4c				endm  
# End of macro CALLMONITOR
9a4c					endif 
9a4c				;pop de 
9a4c c9				ret 
9a4d			 
9a4d			; pop ret stack pointer 
9a4d				 
9a4d			FORTH_RSP_POP: macro 
9a4d				call macro_forth_rsp_pop 
9a4d				endm 
9a4d			 
9a4d			 
9a4d			macro_forth_rsp_pop: 
9a4d				if DEBUG_FORTH_STACK_GUARD 
9a4d			;		DMARK "RPP" 
9a4d cd f4 db				call check_stacks 
9a50					FORTH_CHK_RSP_UNDER 
9a50 e5				push hl 
9a51 d5				push de 
9a52 2a ec e9			ld hl,(cli_ret_sp) 
9a55 11 a6 e9			ld de, cli_ret_stack 
9a58 cd 08 8d			call cmp16 
9a5b da 0b dd			jp c, fault_rsp_under 
9a5e d1				pop de 
9a5f e1				pop hl 
9a60				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a60				endif 
9a60 e5				push hl 
9a61 2a ec e9			ld hl,(cli_ret_sp) 
9a64			 
9a64			 
9a64				if FORTH_ENABLE_FREE 
9a64			 
9a64					; get pointer 
9a64			 
9a64					push de 
9a64					push hl 
9a64			 
9a64					ld e, (hl) 
9a64					inc hl 
9a64					ld d, (hl) 
9a64			 
9a64					ex de, hl 
9a64					call free 
9a64			 
9a64					pop hl 
9a64					pop de 
9a64			 
9a64			 
9a64				endif 
9a64			 
9a64			 
9a64 2b				dec hl 
9a65 2b				dec hl 
9a66 22 ec e9			ld (cli_ret_sp), hl 
9a69				; do stack underflow checks 
9a69 e1				pop hl 
9a6a				if DEBUG_FORTH_STACK_GUARD 
9a6a cd f4 db				call check_stacks 
9a6d					FORTH_CHK_RSP_UNDER 
9a6d e5				push hl 
9a6e d5				push de 
9a6f 2a ec e9			ld hl,(cli_ret_sp) 
9a72 11 a6 e9			ld de, cli_ret_stack 
9a75 cd 08 8d			call cmp16 
9a78 da 0b dd			jp c, fault_rsp_under 
9a7b d1				pop de 
9a7c e1				pop hl 
9a7d				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a7d				endif 
9a7d c9				ret 
9a7e			 
9a7e			 
9a7e			 
9a7e			; routine to load word pointed to by hl into hl 
9a7e			 
9a7e			loadhlptrtohl: 
9a7e			 
9a7e d5				push de 
9a7f 5e				ld e, (hl) 
9a80 23				inc hl 
9a81 56				ld d, (hl) 
9a82 eb				ex de, hl 
9a83 d1				pop de 
9a84			 
9a84 c9				ret 
9a85			 
9a85			 
9a85			 
9a85			 
9a85			 
9a85			; push a number held in HL onto the data stack 
9a85			; entry point for pushing a value when already in hl used in function above 
9a85			 
9a85			forth_push_numhl: 
9a85			 
9a85 e5				push hl    ; save value to push 
9a86			 
9a86			if DEBUG_FORTH_PUSH 
9a86				; see if disabled 
9a86			 
9a86			 
9a86 f5				push af 
9a87 3a 6f ee			ld a,(debug_vector) 
9a8a fe c9			cp $c9   ; ret 
9a8c			;	ld a, (os_view_disable) 
9a8c			;	cp '*' 
9a8c 28 34			jr z, .pskip2 
9a8e e5				push hl 
9a8f e5			push hl 
9a90 cd bd 8a			call clear_display 
9a93 e1			pop hl 
9a94 7c				ld a,h 
9a95 21 c0 e5			ld hl, os_word_scratch 
9a98 cd f3 8e			call hexout 
9a9b e1				pop hl 
9a9c 7d				ld a,l 
9a9d 21 c2 e5			ld hl, os_word_scratch+2 
9aa0 cd f3 8e			call hexout 
9aa3			 
9aa3 21 c4 e5			ld hl, os_word_scratch+4 
9aa6 3e 00			ld a,0 
9aa8 77				ld (hl),a 
9aa9 11 c0 e5			ld de,os_word_scratch 
9aac 3e 28				ld a, display_row_2 
9aae cd d0 8a				call str_at_display 
9ab1 11 ef cd			ld de, .push_num 
9ab4 3e 00			ld a, display_row_1 
9ab6			 
9ab6 cd d0 8a				call str_at_display 
9ab9			 
9ab9			 
9ab9 cd e0 8a			call update_display 
9abc cd 00 8a			call delay1s 
9abf cd 00 8a			call delay1s 
9ac2			.pskip2:  
9ac2			 
9ac2 f1				pop af 
9ac3			endif	 
9ac3			 
9ac3			 
9ac3				FORTH_DSP_NEXT 
9ac3 cd 14 9a			call macro_forth_dsp_next 
9ac6				endm 
# End of macro FORTH_DSP_NEXT
9ac6			 
9ac6 2a e8 e9			ld hl, (cli_data_sp) 
9ac9			 
9ac9				; save item type 
9ac9 3e 02			ld a,  DS_TYPE_INUM 
9acb 77				ld (hl), a 
9acc 23				inc hl 
9acd			 
9acd				; get word off stack 
9acd d1				pop de 
9ace 7b				ld a,e 
9acf 77				ld (hl), a 
9ad0 23				inc hl 
9ad1 7a				ld a,d 
9ad2 77				ld (hl), a 
9ad3			 
9ad3			if DEBUG_FORTH_PUSH 
9ad3 2b				dec hl 
9ad4 2b				dec hl 
9ad5 2b				dec hl 
9ad6						DMARK "PH5" 
9ad6 f5				push af  
9ad7 3a eb 9a			ld a, (.dmark)  
9ada 32 65 ee			ld (debug_mark),a  
9add 3a ec 9a			ld a, (.dmark+1)  
9ae0 32 66 ee			ld (debug_mark+1),a  
9ae3 3a ed 9a			ld a, (.dmark+2)  
9ae6 32 67 ee			ld (debug_mark+2),a  
9ae9 18 03			jr .pastdmark  
9aeb ..			.dmark: db "PH5"  
9aee f1			.pastdmark: pop af  
9aef			endm  
# End of macro DMARK
9aef				CALLMONITOR 
9aef cd 6f ee			call debug_vector  
9af2				endm  
# End of macro CALLMONITOR
9af2			endif	 
9af2			 
9af2 c9				ret 
9af3			 
9af3			 
9af3			; Push a string to stack pointed to by hl 
9af3			 
9af3			forth_push_str: 
9af3			 
9af3			if DEBUG_FORTH_PUSH 
9af3						DMARK "PSQ" 
9af3 f5				push af  
9af4 3a 08 9b			ld a, (.dmark)  
9af7 32 65 ee			ld (debug_mark),a  
9afa 3a 09 9b			ld a, (.dmark+1)  
9afd 32 66 ee			ld (debug_mark+1),a  
9b00 3a 0a 9b			ld a, (.dmark+2)  
9b03 32 67 ee			ld (debug_mark+2),a  
9b06 18 03			jr .pastdmark  
9b08 ..			.dmark: db "PSQ"  
9b0b f1			.pastdmark: pop af  
9b0c			endm  
# End of macro DMARK
9b0c				CALLMONITOR 
9b0c cd 6f ee			call debug_vector  
9b0f				endm  
# End of macro CALLMONITOR
9b0f			endif	 
9b0f			 
9b0f			 
9b0f			    
9b0f e5				push hl 
9b10 e5				push hl 
9b11			 
9b11			;	ld a, 0   ; find end of string 
9b11 cd 50 90			call strlenz 
9b14			if DEBUG_FORTH_PUSH 
9b14						DMARK "PQ2" 
9b14 f5				push af  
9b15 3a 29 9b			ld a, (.dmark)  
9b18 32 65 ee			ld (debug_mark),a  
9b1b 3a 2a 9b			ld a, (.dmark+1)  
9b1e 32 66 ee			ld (debug_mark+1),a  
9b21 3a 2b 9b			ld a, (.dmark+2)  
9b24 32 67 ee			ld (debug_mark+2),a  
9b27 18 03			jr .pastdmark  
9b29 ..			.dmark: db "PQ2"  
9b2c f1			.pastdmark: pop af  
9b2d			endm  
# End of macro DMARK
9b2d				CALLMONITOR 
9b2d cd 6f ee			call debug_vector  
9b30				endm  
# End of macro CALLMONITOR
9b30			endif	 
9b30 eb				ex de, hl 
9b31 e1				pop hl   ; get ptr to start of string 
9b32			if DEBUG_FORTH_PUSH 
9b32						DMARK "PQ3" 
9b32 f5				push af  
9b33 3a 47 9b			ld a, (.dmark)  
9b36 32 65 ee			ld (debug_mark),a  
9b39 3a 48 9b			ld a, (.dmark+1)  
9b3c 32 66 ee			ld (debug_mark+1),a  
9b3f 3a 49 9b			ld a, (.dmark+2)  
9b42 32 67 ee			ld (debug_mark+2),a  
9b45 18 03			jr .pastdmark  
9b47 ..			.dmark: db "PQ3"  
9b4a f1			.pastdmark: pop af  
9b4b			endm  
# End of macro DMARK
9b4b				CALLMONITOR 
9b4b cd 6f ee			call debug_vector  
9b4e				endm  
# End of macro CALLMONITOR
9b4e			endif	 
9b4e 19				add hl,de 
9b4f			if DEBUG_FORTH_PUSH 
9b4f						DMARK "PQE" 
9b4f f5				push af  
9b50 3a 64 9b			ld a, (.dmark)  
9b53 32 65 ee			ld (debug_mark),a  
9b56 3a 65 9b			ld a, (.dmark+1)  
9b59 32 66 ee			ld (debug_mark+1),a  
9b5c 3a 66 9b			ld a, (.dmark+2)  
9b5f 32 67 ee			ld (debug_mark+2),a  
9b62 18 03			jr .pastdmark  
9b64 ..			.dmark: db "PQE"  
9b67 f1			.pastdmark: pop af  
9b68			endm  
# End of macro DMARK
9b68				CALLMONITOR 
9b68 cd 6f ee			call debug_vector  
9b6b				endm  
# End of macro CALLMONITOR
9b6b			endif	 
9b6b			 
9b6b 2b				dec hl    ; see if there is an optional trailing double quote 
9b6c 7e				ld a,(hl) 
9b6d fe 22			cp '"' 
9b6f 20 03			jr nz, .strnoq 
9b71 3e 00			ld a, 0      ; get rid of double quote 
9b73 77				ld (hl), a 
9b74 23			.strnoq: inc hl 
9b75			 
9b75 3e 00			ld a, 0 
9b77 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9b78			 
9b78 13				inc de ; add one for the type string 
9b79 13				inc de ; add one for null term??? 
9b7a			 
9b7a				; tos is get string pointer again 
9b7a				; de contains space to allocate 
9b7a				 
9b7a d5				push de 
9b7b			 
9b7b eb				ex de, hl 
9b7c			 
9b7c				;push af 
9b7c			 
9b7c			if DEBUG_FORTH_PUSH 
9b7c						DMARK "PHm" 
9b7c f5				push af  
9b7d 3a 91 9b			ld a, (.dmark)  
9b80 32 65 ee			ld (debug_mark),a  
9b83 3a 92 9b			ld a, (.dmark+1)  
9b86 32 66 ee			ld (debug_mark+1),a  
9b89 3a 93 9b			ld a, (.dmark+2)  
9b8c 32 67 ee			ld (debug_mark+2),a  
9b8f 18 03			jr .pastdmark  
9b91 ..			.dmark: db "PHm"  
9b94 f1			.pastdmark: pop af  
9b95			endm  
# End of macro DMARK
9b95				CALLMONITOR 
9b95 cd 6f ee			call debug_vector  
9b98				endm  
# End of macro CALLMONITOR
9b98			endif	 
9b98 cd c5 90			call malloc	; on ret hl now contains allocated memory 
9b9b				if DEBUG_FORTH_MALLOC_GUARD 
9b9b cc 47 ce				call z,malloc_error 
9b9e				endif 
9b9e			 
9b9e				 
9b9e c1				pop bc    ; get length 
9b9f d1				pop de   ;  get string start    
9ba0			 
9ba0				; hl has destination from malloc 
9ba0			 
9ba0 eb				ex de, hl    ; prep for ldir 
9ba1			 
9ba1 d5				push de   ; save malloc area for DSP later 
9ba2				;push hl   ; save malloc area for DSP later 
9ba2			 
9ba2			if DEBUG_FORTH_PUSH 
9ba2						DMARK "PHc" 
9ba2 f5				push af  
9ba3 3a b7 9b			ld a, (.dmark)  
9ba6 32 65 ee			ld (debug_mark),a  
9ba9 3a b8 9b			ld a, (.dmark+1)  
9bac 32 66 ee			ld (debug_mark+1),a  
9baf 3a b9 9b			ld a, (.dmark+2)  
9bb2 32 67 ee			ld (debug_mark+2),a  
9bb5 18 03			jr .pastdmark  
9bb7 ..			.dmark: db "PHc"  
9bba f1			.pastdmark: pop af  
9bbb			endm  
# End of macro DMARK
9bbb				CALLMONITOR 
9bbb cd 6f ee			call debug_vector  
9bbe				endm  
# End of macro CALLMONITOR
9bbe			endif	 
9bbe			 
9bbe			 
9bbe ed b0			ldir 
9bc0			 
9bc0			 
9bc0				; push malloc to data stack     macro?????  
9bc0			 
9bc0				FORTH_DSP_NEXT 
9bc0 cd 14 9a			call macro_forth_dsp_next 
9bc3				endm 
# End of macro FORTH_DSP_NEXT
9bc3			 
9bc3				; save value and type 
9bc3			 
9bc3 2a e8 e9			ld hl, (cli_data_sp) 
9bc6			 
9bc6				; save item type 
9bc6 3e 01			ld a,  DS_TYPE_STR 
9bc8 77				ld (hl), a 
9bc9 23				inc hl 
9bca			 
9bca				; get malloc word off stack 
9bca d1				pop de 
9bcb 73				ld (hl), e 
9bcc 23				inc hl 
9bcd 72				ld (hl), d 
9bce			 
9bce			 
9bce			 
9bce			if DEBUG_FORTH_PUSH 
9bce 2a e8 e9			ld hl, (cli_data_sp) 
9bd1						DMARK "PHS" 
9bd1 f5				push af  
9bd2 3a e6 9b			ld a, (.dmark)  
9bd5 32 65 ee			ld (debug_mark),a  
9bd8 3a e7 9b			ld a, (.dmark+1)  
9bdb 32 66 ee			ld (debug_mark+1),a  
9bde 3a e8 9b			ld a, (.dmark+2)  
9be1 32 67 ee			ld (debug_mark+2),a  
9be4 18 03			jr .pastdmark  
9be6 ..			.dmark: db "PHS"  
9be9 f1			.pastdmark: pop af  
9bea			endm  
# End of macro DMARK
9bea				CALLMONITOR 
9bea cd 6f ee			call debug_vector  
9bed				endm  
# End of macro CALLMONITOR
9bed			;	ex de,hl 
9bed			endif	 
9bed				; in case of spaces, skip the ptr past the copied string 
9bed				;pop af 
9bed				;ld (cli_origptr),hl 
9bed			 
9bed c9				ret 
9bee			 
9bee			 
9bee			 
9bee			; TODO ascii push input onto stack given hl to start of input 
9bee			 
9bee			; identify type 
9bee			; if starts with a " then a string 
9bee			; otherwise it is a number 
9bee			;  
9bee			; if a string 
9bee			;     scan for ending " to get length of string to malloc for + 1 
9bee			;     malloc 
9bee			;     put pointer to string on stack first byte flags as string 
9bee			; 
9bee			; else a number 
9bee			;    look for number format identifier 
9bee			;    $xx hex 
9bee			;    %xxxxx bin 
9bee			;    xxxxx decimal 
9bee			;    convert number to 16bit word.  
9bee			;    malloc word + 1 with flag to identiy as num 
9bee			;    put pointer to number on stack 
9bee			;   
9bee			;  
9bee			  
9bee			forth_apush: 
9bee				; kernel push 
9bee			 
9bee			if DEBUG_FORTH_PUSH 
9bee						DMARK "PSH" 
9bee f5				push af  
9bef 3a 03 9c			ld a, (.dmark)  
9bf2 32 65 ee			ld (debug_mark),a  
9bf5 3a 04 9c			ld a, (.dmark+1)  
9bf8 32 66 ee			ld (debug_mark+1),a  
9bfb 3a 05 9c			ld a, (.dmark+2)  
9bfe 32 67 ee			ld (debug_mark+2),a  
9c01 18 03			jr .pastdmark  
9c03 ..			.dmark: db "PSH"  
9c06 f1			.pastdmark: pop af  
9c07			endm  
# End of macro DMARK
9c07				CALLMONITOR 
9c07 cd 6f ee			call debug_vector  
9c0a				endm  
# End of macro CALLMONITOR
9c0a			endif	 
9c0a				; identify input type 
9c0a			 
9c0a 7e				ld a,(hl) 
9c0b			 
9c0b fe 23			cp '#' 
9c0d ca 47 9c			jp z, .fapdec 
9c10			 
9c10			 
9c10 fe 22			cp '"' 
9c12 28 0a			jr z, .fapstr 
9c14 fe 24			cp '$' 
9c16 ca 3e 9c			jp z, .faphex 
9c19 fe 25			cp '%' 
9c1b ca 26 9c			jp z, .fapbin 
9c1e			;	cp 'b' 
9c1e			;	jp z, .fabin 
9c1e				; else decimal 
9c1e			 
9c1e				; TODO do decimal conversion 
9c1e				; decimal is stored as a 16bit word 
9c1e			 
9c1e				; by default everything is a string if type is not detected 
9c1e			.fapstr: ; 
9c1e fe 22			cp '"' 
9c20 20 01			jr nz, .strnoqu 
9c22 23				inc hl 
9c23			.strnoqu: 
9c23 c3 f3 9a			jp forth_push_str 
9c26			 
9c26			 
9c26			 
9c26			.fapbin:    ; push a binary string.  
9c26 11 00 00			ld de, 0   ; hold a 16bit value 
9c29			 
9c29 23			.fapbinshift:	inc hl  
9c2a 7e				ld a,(hl) 
9c2b fe 00			cp 0     ; done scanning  
9c2d 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c2f			 
9c2f				; left shift de 
9c2f eb				ex de, hl	 
9c30 29				add hl, hl 
9c31			 
9c31				; is 1 
9c31 fe 31			cp '1' 
9c33 20 02			jr nz, .binzero 
9c35 cb 4d			bit 1, l 
9c37			.binzero: 
9c37 eb				ex de, hl	 ; save current de 
9c38 18 ef			jr .fapbinshift 
9c3a			 
9c3a			.fapbdone: 
9c3a eb				ex de, hl 
9c3b c3 85 9a			jp forth_push_numhl 
9c3e			 
9c3e			 
9c3e			.faphex:   ; hex is always stored as a 16bit word 
9c3e				; skip number prefix 
9c3e 23				inc hl 
9c3f				; turn ascii into number 
9c3f cd a9 8f			call get_word_hl	; ret 16bit word in hl 
9c42			 
9c42 c3 85 9a			jp forth_push_numhl 
9c45			 
9c45 00				 nop 
9c46			 
9c46			.fabin:   ; TODO bin conversion 
9c46			 
9c46			 
9c46 c9				ret 
9c47			.fapdec:	 
9c47				; string to dec conversion 
9c47 23				inc hl 
9c48 eb				ex de, hl 
9c49 cd e7 8f			call string_to_uint16 
9c4c c3 85 9a			jp forth_push_numhl 
9c4f c9				ret 
9c50				 
9c50			;atoui_16: 
9c50			 
9c50			; get either a string ptr or a 16bit word from the data stack 
9c50			 
9c50			FORTH_DSP: macro 
9c50				call macro_forth_dsp 
9c50				endm 
9c50			 
9c50			macro_forth_dsp: 
9c50				; data stack pointer points to current word on tos 
9c50			 
9c50 2a e8 e9			ld hl,(cli_data_sp) 
9c53			 
9c53				if DEBUG_FORTH_PUSH 
9c53						DMARK "DSP" 
9c53 f5				push af  
9c54 3a 68 9c			ld a, (.dmark)  
9c57 32 65 ee			ld (debug_mark),a  
9c5a 3a 69 9c			ld a, (.dmark+1)  
9c5d 32 66 ee			ld (debug_mark+1),a  
9c60 3a 6a 9c			ld a, (.dmark+2)  
9c63 32 67 ee			ld (debug_mark+2),a  
9c66 18 03			jr .pastdmark  
9c68 ..			.dmark: db "DSP"  
9c6b f1			.pastdmark: pop af  
9c6c			endm  
# End of macro DMARK
9c6c			 
9c6c cd 7a ce				call display_data_sp 
9c6f				;call break_point_state 
9c6f				;rst 030h 
9c6f				CALLMONITOR 
9c6f cd 6f ee			call debug_vector  
9c72				endm  
# End of macro CALLMONITOR
9c72				endif 
9c72			 
9c72 c9				ret 
9c73			 
9c73			; return hl to start of value on stack 
9c73			 
9c73			FORTH_DSP_VALUE: macro 
9c73				call macro_forth_dsp_value 
9c73				endm 
9c73			 
9c73			macro_forth_dsp_value: 
9c73			 
9c73				FORTH_DSP 
9c73 cd 50 9c			call macro_forth_dsp 
9c76				endm 
# End of macro FORTH_DSP
9c76			 
9c76 d5				push de 
9c77			 
9c77 23				inc hl ; skip type 
9c78			 
9c78 5e				ld e, (hl) 
9c79 23				inc hl 
9c7a 56				ld d, (hl) 
9c7b eb				ex de,hl  
9c7c			 
9c7c d1				pop de 
9c7d			 
9c7d c9				ret 
9c7e			 
9c7e			; return hl to start of value to second item on stack 
9c7e			 
9c7e			FORTH_DSP_VALUEM1: macro 
9c7e				call macro_forth_dsp_value_m1 
9c7e				endm 
9c7e			 
9c7e			macro_forth_dsp_value_m1: 
9c7e			 
9c7e				FORTH_DSP 
9c7e cd 50 9c			call macro_forth_dsp 
9c81				endm 
# End of macro FORTH_DSP
9c81			 
9c81 2b				dec hl 
9c82 2b				dec hl 
9c83			;	dec hl 
9c83			 
9c83 d5				push de 
9c84			 
9c84 5e				ld e, (hl) 
9c85 23				inc hl 
9c86 56				ld d, (hl) 
9c87 eb				ex de,hl  
9c88			 
9c88 d1				pop de 
9c89			 
9c89 c9				ret 
9c8a			 
9c8a				 
9c8a			 
9c8a			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9c8a			 
9c8a			FORTH_DSP_POP: macro 
9c8a				call macro_forth_dsp_pop 
9c8a				endm 
9c8a			 
9c8a			 
9c8a			; get the tos data type 
9c8a			 
9c8a			FORTH_DSP_TYPE:   macro 
9c8a			 
9c8a				;FORTH_DSP_VALUE 
9c8a				FORTH_DSP 
9c8a				 
9c8a				; hl points to value 
9c8a				; check type 
9c8a			 
9c8a				ld a,(hl) 
9c8a			 
9c8a				endm 
9c8a			 
9c8a			; load the tos value into hl 
9c8a			 
9c8a			 
9c8a			FORTH_DSP_VALUEHL:  macro 
9c8a				call macro_dsp_valuehl 
9c8a				endm 
9c8a			 
9c8a			 
9c8a			 
9c8a			macro_dsp_valuehl: 
9c8a				FORTH_DSP_VALUE 
9c8a cd 73 9c			call macro_forth_dsp_value 
9c8d				endm 
# End of macro FORTH_DSP_VALUE
9c8d			 
9c8d				;FORTH_ERR_TOS_NOTNUM 
9c8d			 
9c8d				;inc hl   ; skip type id 
9c8d			 
9c8d			;	push de 
9c8d			; 
9c8d			;	ld e, (hl) 
9c8d			;	inc hl 
9c8d			;	ld d, (hl) 
9c8d			;	ex de,hl  
9c8d			 
9c8d			;	pop de 
9c8d			 
9c8d				if DEBUG_FORTH_PUSH 
9c8d						DMARK "DVL" 
9c8d f5				push af  
9c8e 3a a2 9c			ld a, (.dmark)  
9c91 32 65 ee			ld (debug_mark),a  
9c94 3a a3 9c			ld a, (.dmark+1)  
9c97 32 66 ee			ld (debug_mark+1),a  
9c9a 3a a4 9c			ld a, (.dmark+2)  
9c9d 32 67 ee			ld (debug_mark+2),a  
9ca0 18 03			jr .pastdmark  
9ca2 ..			.dmark: db "DVL"  
9ca5 f1			.pastdmark: pop af  
9ca6			endm  
# End of macro DMARK
9ca6				CALLMONITOR 
9ca6 cd 6f ee			call debug_vector  
9ca9				endm  
# End of macro CALLMONITOR
9ca9				endif 
9ca9 c9				ret 
9caa			 
9caa			forth_apushstrhl:      
9caa				; push of string requires use of cli_origptr 
9caa				; bodge use 
9caa			 
9caa				; get current cli_origptr, save, update with temp pointer  
9caa ed 5b 38 ea		ld de, (cli_origptr) 
9cae 22 38 ea			ld (cli_origptr), hl 
9cb1 d5				push de 
9cb2 cd ee 9b			call forth_apush 
9cb5 d1				pop de 
9cb6 ed 53 38 ea		ld (cli_origptr), de 
9cba c9			        ret	 
9cbb			 
9cbb			 
9cbb			; increase loop stack pointer and save hl to it 
9cbb				 
9cbb			FORTH_LOOP_NEXT: macro 
9cbb				call macro_forth_loop_next 
9cbb				;nop 
9cbb				endm 
9cbb			 
9cbb			macro_forth_loop_next: 
9cbb				if DEBUG_FORTH_STACK_GUARD 
9cbb cd f4 db				call check_stacks 
9cbe				endif 
9cbe e5				push hl 
9cbf d5				push de 
9cc0 eb				ex de,hl 
9cc1 2a ea e9			ld hl,(cli_loop_sp) 
9cc4 23				inc hl 
9cc5 23				inc hl 
9cc6					if DEBUG_FORTH_WORDS 
9cc6						DMARK "LNX" 
9cc6 f5				push af  
9cc7 3a db 9c			ld a, (.dmark)  
9cca 32 65 ee			ld (debug_mark),a  
9ccd 3a dc 9c			ld a, (.dmark+1)  
9cd0 32 66 ee			ld (debug_mark+1),a  
9cd3 3a dd 9c			ld a, (.dmark+2)  
9cd6 32 67 ee			ld (debug_mark+2),a  
9cd9 18 03			jr .pastdmark  
9cdb ..			.dmark: db "LNX"  
9cde f1			.pastdmark: pop af  
9cdf			endm  
# End of macro DMARK
9cdf						CALLMONITOR 
9cdf cd 6f ee			call debug_vector  
9ce2				endm  
# End of macro CALLMONITOR
9ce2					endif 
9ce2 22 ea e9			ld (cli_loop_sp),hl 
9ce5 73				ld (hl), e 
9ce6 23				inc hl 
9ce7 72				ld (hl), d 
9ce8 d1				pop de    ; been reversed so save a swap on restore 
9ce9 e1				pop hl 
9cea				if DEBUG_FORTH_STACK_GUARD 
9cea cd f4 db				call check_stacks 
9ced				endif 
9ced c9				ret 
9cee			 
9cee			; get current ret stack pointer and save to hl  
9cee				 
9cee			FORTH_LOOP_TOS: macro 
9cee				call macro_forth_loop_tos 
9cee				endm 
9cee			 
9cee			macro_forth_loop_tos: 
9cee d5				push de 
9cef 2a ea e9			ld hl,(cli_loop_sp) 
9cf2 5e				ld e, (hl) 
9cf3 23				inc hl 
9cf4 56				ld d, (hl) 
9cf5 eb				ex de, hl 
9cf6 d1				pop de 
9cf7 c9				ret 
9cf8			 
9cf8			; pop loop stack pointer 
9cf8				 
9cf8			FORTH_LOOP_POP: macro 
9cf8				call macro_forth_loop_pop 
9cf8				endm 
9cf8			 
9cf8			 
9cf8			macro_forth_loop_pop: 
9cf8				if DEBUG_FORTH_STACK_GUARD 
9cf8					DMARK "LPP" 
9cf8 f5				push af  
9cf9 3a 0d 9d			ld a, (.dmark)  
9cfc 32 65 ee			ld (debug_mark),a  
9cff 3a 0e 9d			ld a, (.dmark+1)  
9d02 32 66 ee			ld (debug_mark+1),a  
9d05 3a 0f 9d			ld a, (.dmark+2)  
9d08 32 67 ee			ld (debug_mark+2),a  
9d0b 18 03			jr .pastdmark  
9d0d ..			.dmark: db "LPP"  
9d10 f1			.pastdmark: pop af  
9d11			endm  
# End of macro DMARK
9d11 cd f4 db				call check_stacks 
9d14					FORTH_CHK_LOOP_UNDER 
9d14 e5				push hl 
9d15 d5				push de 
9d16 2a ea e9			ld hl,(cli_loop_sp) 
9d19 11 24 e9			ld de, cli_loop_stack 
9d1c cd 08 8d			call cmp16 
9d1f da 11 dd			jp c, fault_loop_under 
9d22 d1				pop de 
9d23 e1				pop hl 
9d24				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d24				endif 
9d24 e5				push hl 
9d25 2a ea e9			ld hl,(cli_loop_sp) 
9d28 2b				dec hl 
9d29 2b				dec hl 
9d2a 22 ea e9			ld (cli_loop_sp), hl 
9d2d				; TODO do stack underflow checks 
9d2d e1				pop hl 
9d2e				if DEBUG_FORTH_STACK_GUARD 
9d2e cd f4 db				call check_stacks 
9d31					FORTH_CHK_LOOP_UNDER 
9d31 e5				push hl 
9d32 d5				push de 
9d33 2a ea e9			ld hl,(cli_loop_sp) 
9d36 11 24 e9			ld de, cli_loop_stack 
9d39 cd 08 8d			call cmp16 
9d3c da 11 dd			jp c, fault_loop_under 
9d3f d1				pop de 
9d40 e1				pop hl 
9d41				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d41				endif 
9d41 c9				ret 
9d42			 
9d42			macro_forth_dsp_pop: 
9d42			 
9d42 e5				push hl 
9d43			 
9d43				; release malloc data 
9d43			 
9d43				if DEBUG_FORTH_STACK_GUARD 
9d43 cd f4 db				call check_stacks 
9d46					FORTH_CHK_DSP_UNDER 
9d46 e5				push hl 
9d47 d5				push de 
9d48 2a e8 e9			ld hl,(cli_data_sp) 
9d4b 11 22 e8			ld de, cli_data_stack 
9d4e cd 08 8d			call cmp16 
9d51 da 05 dd			jp c, fault_dsp_under 
9d54 d1				pop de 
9d55 e1				pop hl 
9d56				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d56				endif 
9d56				;ld hl,(cli_data_sp) 
9d56			if DEBUG_FORTH_DOT 
9d56				DMARK "DPP" 
9d56 f5				push af  
9d57 3a 6b 9d			ld a, (.dmark)  
9d5a 32 65 ee			ld (debug_mark),a  
9d5d 3a 6c 9d			ld a, (.dmark+1)  
9d60 32 66 ee			ld (debug_mark+1),a  
9d63 3a 6d 9d			ld a, (.dmark+2)  
9d66 32 67 ee			ld (debug_mark+2),a  
9d69 18 03			jr .pastdmark  
9d6b ..			.dmark: db "DPP"  
9d6e f1			.pastdmark: pop af  
9d6f			endm  
# End of macro DMARK
9d6f				CALLMONITOR 
9d6f cd 6f ee			call debug_vector  
9d72				endm  
# End of macro CALLMONITOR
9d72			endif	 
9d72			 
9d72			 
9d72			if FORTH_ENABLE_DSPPOPFREE 
9d72			 
9d72				FORTH_DSP 
9d72 cd 50 9c			call macro_forth_dsp 
9d75				endm 
# End of macro FORTH_DSP
9d75			 
9d75 7e				ld a, (hl) 
9d76 fe 01			cp DS_TYPE_STR 
9d78 20 23			jr nz, .skippopfree 
9d7a			 
9d7a				FORTH_DSP_VALUEHL 
9d7a cd 8a 9c			call macro_dsp_valuehl 
9d7d				endm 
# End of macro FORTH_DSP_VALUEHL
9d7d 00				nop 
9d7e			if DEBUG_FORTH_DOT 
9d7e				DMARK "DPf" 
9d7e f5				push af  
9d7f 3a 93 9d			ld a, (.dmark)  
9d82 32 65 ee			ld (debug_mark),a  
9d85 3a 94 9d			ld a, (.dmark+1)  
9d88 32 66 ee			ld (debug_mark+1),a  
9d8b 3a 95 9d			ld a, (.dmark+2)  
9d8e 32 67 ee			ld (debug_mark+2),a  
9d91 18 03			jr .pastdmark  
9d93 ..			.dmark: db "DPf"  
9d96 f1			.pastdmark: pop af  
9d97			endm  
# End of macro DMARK
9d97				CALLMONITOR 
9d97 cd 6f ee			call debug_vector  
9d9a				endm  
# End of macro CALLMONITOR
9d9a			endif	 
9d9a cd 8f 91			call free 
9d9d			.skippopfree: 
9d9d				 
9d9d			 
9d9d			endif 
9d9d			 
9d9d			if DEBUG_FORTH_DOT_KEY 
9d9d				DMARK "DP2" 
9d9d				CALLMONITOR 
9d9d			endif	 
9d9d			 
9d9d				; move pointer down 
9d9d			 
9d9d 2a e8 e9			ld hl,(cli_data_sp) 
9da0 2b				dec hl 
9da1 2b				dec hl 
9da2			; PARSEV5 
9da2 2b				dec hl 
9da3 22 e8 e9			ld (cli_data_sp), hl 
9da6			 
9da6				if DEBUG_FORTH_STACK_GUARD 
9da6 cd f4 db				call check_stacks 
9da9					FORTH_CHK_DSP_UNDER 
9da9 e5				push hl 
9daa d5				push de 
9dab 2a e8 e9			ld hl,(cli_data_sp) 
9dae 11 22 e8			ld de, cli_data_stack 
9db1 cd 08 8d			call cmp16 
9db4 da 05 dd			jp c, fault_dsp_under 
9db7 d1				pop de 
9db8 e1				pop hl 
9db9				endm 
# End of macro FORTH_CHK_DSP_UNDER
9db9				endif 
9db9			 
9db9 e1				pop hl 
9dba			 
9dba c9				ret 
9dbb			 
9dbb			getwordathl: 
9dbb				; hl points to an address 
9dbb				; load hl with the word at that address 
9dbb			 
9dbb d5				push de 
9dbc			 
9dbc 5e				ld e, (hl) 
9dbd 23				inc hl 
9dbe 56				ld d, (hl) 
9dbf eb				ex de, hl 
9dc0			 
9dc0 d1				pop de 
9dc1 c9				ret 
9dc2			 
9dc2			 
9dc2			; functions to manuplite stack pointers 
9dc2			 
9dc2			; generate fragment to set hl to be pointer to a stack item 
9dc2			 
9dc2			FORTH_DSP_PTR: macro  x 
9dc2				ld hl,(cli_data_sp) 
9dc2				ld de, x * 3 
9dc2				sbc hl, de 
9dc2				endm 
9dc2			 
9dc2			 
9dc2			 
9dc2			; copy point in hl to stack tmp storage slots 1-4 
9dc2			hltostack1: 
9dc2 11 b8 e2			ld de, os_stack_1  
9dc5 c3 f0 9d			jp hltostackmv 
9dc8			 
9dc8			hltostack2:  
9dc8 11 b5 e2			ld de, os_stack_2 
9dcb c3 f0 9d			jp hltostackmv 
9dce			 
9dce			hltostack3:  
9dce 11 b2 e2			ld de, os_stack_3 
9dd1 c3 f0 9d			jp hltostackmv 
9dd4			 
9dd4			hltostack4:  
9dd4 11 af e2			ld de, os_stack_4  
9dd7 c3 f0 9d			jp hltostackmv 
9dda			 
9dda			; copy to point in hl from stack tmp storage slots 1-4 
9dda			hlfromstack1: 
9dda 11 b8 e2			ld de, os_stack_1 
9ddd c3 ef 9d			jp hlfromsttackmv 
9de0			 
9de0			hlfromstack2:  
9de0 11 b5 e2			ld de, os_stack_2 
9de3 c3 ef 9d			jp hlfromsttackmv 
9de6			 
9de6			hlfromstack3:  
9de6 11 b2 e2			ld de, os_stack_3 
9de9 c3 ef 9d			jp hlfromsttackmv 
9dec			 
9dec			hlfromstack4:  
9dec 11 af e2			ld de, os_stack_4 
9def			 
9def			hlfromsttackmv: 
9def eb				ex de, hl 
9df0			 
9df0			hltostackmv: 
9df0			 
9df0				; do stack move 
9df0 c5				push bc 
9df1 01 03 00			ld bc, 3 
9df4 ed b0			ldir  
9df6 c1				pop bc	 
9df7 c9				ret 
9df8			 
9df8			; eof 
9df8			 
# End of file forth_stackopsv5.asm
9df8			endif 
9df8			loadwordinhl:	 
9df8			 
9df8 d5				push de 
9df9			 
9df9 5e				ld e, (hl) 
9dfa 23				inc hl 
9dfb 56				ld d, (hl) 
9dfc eb				ex de,hl  
9dfd			 
9dfd d1				pop de 
9dfe			 
9dfe c9				ret 
9dff			 
9dff			user_word_eol:  
9dff				; hl contains the pointer to where to create a linked list item from the end 
9dff				; of the user dict to continue on at the system word dict 
9dff				 
9dff				; poke the stub of the word list linked list to repoint to rom words 
9dff			 
9dff				; stub format 
9dff				; db   word id 
9dff				; dw    link to next word 
9dff			        ; db char length of token 
9dff				; db string + 0 term 
9dff				; db exec code....  
9dff			 
9dff 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e01 77				ld (hl), a		; word id 
9e02 23				inc hl 
9e03			 
9e03 11 ba 9f			ld de, sysdict 
9e06 73				ld (hl), e		; next word link ie system dict 
9e07 23				inc hl 
9e08 72				ld (hl), d		; next word link ie system dict 
9e09 23				inc hl	 
9e0a			 
9e0a			;	ld (hl), sysdict		; next word link ie system dict 
9e0a			;	inc hl 
9e0a			;	inc hl 
9e0a			 
9e0a			;	inc hl 
9e0a			;	inc hl 
9e0a			 
9e0a 3e 02			ld a, 2			; word length is 0 
9e0c 77				ld (hl), a	 
9e0d 23				inc hl 
9e0e			 
9e0e 3e 7e			ld a, '~'			; word length is 0 
9e10 77				ld (hl), a	 
9e11 23				inc hl 
9e12 3e 00			ld a, 0			; save empty word 
9e14 77				ld (hl), a 
9e15			 
9e15 c9				ret 
9e16			 
9e16				 
9e16			 
9e16			forthexec_cleanup: 
9e16				FORTH_RSP_POP 
9e16 cd 4d 9a			call macro_forth_rsp_pop 
9e19				endm 
# End of macro FORTH_RSP_POP
9e19 c9				ret 
9e1a			 
9e1a			forth_call_hl: 
9e1a				; taking hl 
9e1a e5				push hl 
9e1b c9				ret 
9e1c			 
9e1c			; this is called to reset Forth system but keep existing uwords etc 
9e1c			 
9e1c			forth_warmstart: 
9e1c				; setup stack over/under flow checks 
9e1c				if DEBUG_FORTH_STACK_GUARD 
9e1c cd da db				call chk_stk_init 
9e1f				endif 
9e1f			 
9e1f				; init stack pointers  - * these stacks go upwards *  
9e1f 21 a6 e9			ld hl, cli_ret_stack 
9e22 22 ec e9			ld (cli_ret_sp), hl	 
9e25				; set bottom of stack 
9e25 3e 00			ld a,0 
9e27 77				ld (hl),a 
9e28 23				inc hl 
9e29 77				ld (hl),a 
9e2a			 
9e2a 21 22 e8			ld hl, cli_data_stack 
9e2d 22 e8 e9			ld (cli_data_sp), hl	 
9e30				; set bottom of stack 
9e30 3e 00			ld a,0 
9e32 77				ld (hl),a 
9e33 23				inc hl 
9e34 77				ld (hl),a 
9e35			 
9e35 21 24 e9			ld hl, cli_loop_stack 
9e38 22 ea e9			ld (cli_loop_sp), hl	 
9e3b				; set bottom of stack 
9e3b 3e 00			ld a,0 
9e3d 77				ld (hl),a 
9e3e 23				inc hl 
9e3f 77				ld (hl),a 
9e40			 
9e40				; init extent of current open file 
9e40			 
9e40 3e 00			ld a, 0 
9e42 32 64 ea			ld (store_openext), a 
9e45			 
9e45 c9				ret 
9e46			 
9e46			 
9e46			 
9e46			; Cold Start - this is called to setup the whole Forth system 
9e46			 
9e46			forth_init: 
9e46			 
9e46				; setup stack over/under flow checks 
9e46			 
9e46			;	if DEBUG_FORTH_STACK_GUARD 
9e46			;		call chk_stk_init 
9e46			;	endif 
9e46			 
9e46				; enable auto display updates (slow.....) 
9e46			 
9e46 3e 01			ld a, 1 
9e48 32 36 ea			ld (cli_autodisplay), a 
9e4b			 
9e4b				; if storage is in use disable long reads for now 
9e4b 3e 00			ld a, 0 
9e4d 32 6f ea			ld (store_longread), a 
9e50			 
9e50			 
9e50				; show start up screen 
9e50			 
9e50 cd bd 8a			call clear_display 
9e53			 
9e53 3e 00			ld a,0 
9e55 32 58 ea			ld (f_cursor_ptr), a 
9e58			 
9e58				; set start of word list in start of ram - for use when creating user words 
9e58			 
9e58 21 97 df			ld hl, baseram 
9e5b 22 b8 e5			ld (os_last_new_uword), hl 
9e5e cd ff 9d			call user_word_eol 
9e61				 
9e61			;		call display_data_sp 
9e61			;		call next_page_prompt 
9e61			 
9e61			 
9e61			 
9e61			 
9e61 c9				ret 
9e62			 
9e62 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e76			 
9e76			; TODO push to stack 
9e76			 
9e76			;  
9e76			 
9e76			if FORTH_PARSEV2 
9e76			 
9e76			 
9e76				include "forth_parserv2.asm" 
9e76			 
9e76			endif 
9e76			 
9e76			 
9e76			; parse cli version 1 
9e76			 
9e76			if FORTH_PARSEV1 
9e76			 
9e76			 
9e76			 
9e76			      include "forth_parserv1.asm" 
9e76			endif 
9e76				 
9e76			if FORTH_PARSEV3 
9e76			      include "forth_parserv3.asm" 
9e76				include "forth_wordsv3.asm" 
9e76			endif 
9e76			 
9e76			if FORTH_PARSEV4 
9e76			      include "forth_parserv4.asm" 
9e76				include "forth_wordsv4.asm" 
9e76			endif 
9e76			 
9e76			if FORTH_PARSEV5 
9e76			      include "forth_parserv5.asm" 
9e76				include "forth_wordsv4.asm" 
9e76			endif 
9e76			 
9e76			if FORTH_PARSEV6 
9e76			      include "forth_parserv6.asm" 
9e76			 
9e76			 
9e76			; A better parser without using malloc and string copies all over the place.  
9e76			; Exec in situ should be faster 
9e76			 
9e76			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e76			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e76			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e76			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e76			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e76			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e76			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e76			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e76			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e76			 
9e76			; Core word preamble macro 
9e76			 
9e76			CWHEAD:   macro nxtword opcode lit len opflags 
9e76				db WORD_SYS_CORE+opcode             
9e76				; internal op code number 
9e76				dw nxtword            
9e76				; link to next dict word block 
9e76				db len + 1 
9e76				; literal length of dict word inc zero term 
9e76				db lit,0              
9e76				; literal dict word 
9e76			        ; TODO db opflags        
9e76				endm 
9e76			 
9e76			 
9e76			NEXTW: macro  
9e76				jp macro_next 
9e76				endm 
9e76			 
9e76			macro_next: 
9e76			if DEBUG_FORTH_PARSE_EXEC 
9e76				DMARK "NXT" 
9e76				CALLMONITOR 
9e76			endif	 
9e76			;	inc hl  ; skip token null term  
9e76 ed 4b 3a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e7a ed 5b 38 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e7e 2a bc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e81			if DEBUG_FORTH_PARSE_EXEC 
9e81				DMARK "}AA" 
9e81				CALLMONITOR 
9e81			endif	 
9e81 c3 70 9f			jp execnext 
9e84				;jp exec1 
9e84			       
9e84			 
9e84			 
9e84			; Another go at the parser to compile  
9e84			 
9e84			 
9e84			; TODO rework parser to change all of the string words to byte tokens 
9e84			; TODO do a search for  
9e84			 
9e84			; TODO first run normal parser to zero term sections 
9e84			; TODO for each word do a token look up to get the op code 
9e84			; TODO need some means to flag to the exec that this is a byte code form    
9e84			 
9e84			 
9e84			forthcompile: 
9e84			 
9e84			; 
9e84			; line parse: 
9e84			;       parse raw input buffer 
9e84			;       tokenise the words 
9e84			;       malloc new copy (for looping etc) 
9e84			;       copy to malloc + current pc in line to start of string and add line term 
9e84			;       save on new rsp 
9e84			; 
9e84			 
9e84			; hl to point to the line to tokenise 
9e84			 
9e84			;	push hl 
9e84 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e87			 
9e87			;	ld a,0		; string term on input 
9e87			;	call strlent 
9e87			 
9e87			;	ld (os_tok_len), hl	 ; save string length 
9e87			 
9e87			;if DEBUG_FORTH_TOK 
9e87			;	ex de,hl		 
9e87			;endif 
9e87			 
9e87			;	pop hl 		; get back string pointer 
9e87			 
9e87			if DEBUG_FORTH_TOK 
9e87						DMARK "TOc" 
9e87				CALLMONITOR 
9e87			endif 
9e87 7e			.cptoken2:    ld a,(hl) 
9e88 23				inc hl 
9e89 fe 7f			cp FORTH_END_BUFFER 
9e8b 28 29			jr z, .cptokendone2 
9e8d fe 00			cp 0 
9e8f 28 25			jr z, .cptokendone2 
9e91 fe 22			cp '"' 
9e93 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e95 fe 20			cp ' ' 
9e97 20 ee			jr nz,  .cptoken2 
9e99			 
9e99			; TODO consume comments held between ( and ) 
9e99			 
9e99				; we have a space so change to zero term for dict match later 
9e99 2b				dec hl 
9e9a 3e 00			ld a,0 
9e9c 77				ld (hl), a 
9e9d 23				inc hl 
9e9e 18 e7			jr .cptoken2 
9ea0				 
9ea0			 
9ea0			.cptokenstr2: 
9ea0				; skip all white space until either eol (because forgot to term) or end double quote 
9ea0			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9ea0				;inc hl ; skip current double quote 
9ea0 7e				ld a,(hl) 
9ea1 23				inc hl 
9ea2 fe 22			cp '"' 
9ea4 28 e1			jr z, .cptoken2 
9ea6 fe 7f			cp FORTH_END_BUFFER 
9ea8 28 0c			jr z, .cptokendone2 
9eaa fe 00			cp 0 
9eac 28 08			jr z, .cptokendone2 
9eae fe 20			cp ' ' 
9eb0 28 02			jr z, .cptmp2 
9eb2 18 ec			jr .cptokenstr2 
9eb4			 
9eb4			.cptmp2:	; we have a space so change to zero term for dict match later 
9eb4				;dec hl 
9eb4				;ld a,"-"	; TODO remove this when working 
9eb4				;ld (hl), a 
9eb4				;inc hl 
9eb4 18 ea			jr .cptokenstr2 
9eb6			 
9eb6			.cptokendone2: 
9eb6				;inc hl 
9eb6 3e 7f			ld a, FORTH_END_BUFFER 
9eb8 77				ld (hl),a 
9eb9			;	inc hl 
9eb9			;	ld a, '!' 
9eb9			;	ld (hl),a 
9eb9			 
9eb9 2a bc e5			ld hl,(os_tok_ptr) 
9ebc			         
9ebc			if DEBUG_FORTH_TOK 
9ebc						DMARK "Tc1" 
9ebc				CALLMONITOR 
9ebc			endif 
9ebc			 
9ebc				; push exec string to top of return stack 
9ebc				FORTH_RSP_NEXT 
9ebc cd 2c 9a			call macro_forth_rsp_next 
9ebf				endm 
# End of macro FORTH_RSP_NEXT
9ebf c9				ret 
9ec0			 
9ec0			; Another go at the parser need to simplify the process 
9ec0			 
9ec0			forthparse: 
9ec0			 
9ec0			; 
9ec0			; line parse: 
9ec0			;       parse raw input buffer 
9ec0			;       tokenise the words 
9ec0			;       malloc new copy (for looping etc) 
9ec0			;       copy to malloc + current pc in line to start of string and add line term 
9ec0			;       save on new rsp 
9ec0			; 
9ec0			 
9ec0			; hl to point to the line to tokenise 
9ec0			 
9ec0			;	push hl 
9ec0 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9ec3			 
9ec3			;	ld a,0		; string term on input 
9ec3			;	call strlent 
9ec3			 
9ec3			;	ld (os_tok_len), hl	 ; save string length 
9ec3			 
9ec3			;if DEBUG_FORTH_TOK 
9ec3			;	ex de,hl		 
9ec3			;endif 
9ec3			 
9ec3			;	pop hl 		; get back string pointer 
9ec3			 
9ec3			if DEBUG_FORTH_TOK 
9ec3						DMARK "TOK" 
9ec3				CALLMONITOR 
9ec3			endif 
9ec3 7e			.ptoken2:    ld a,(hl) 
9ec4 23				inc hl 
9ec5 fe 7f			cp FORTH_END_BUFFER 
9ec7 28 29			jr z, .ptokendone2 
9ec9 fe 00			cp 0 
9ecb 28 25			jr z, .ptokendone2 
9ecd fe 22			cp '"' 
9ecf 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9ed1 fe 20			cp ' ' 
9ed3 20 ee			jr nz,  .ptoken2 
9ed5			 
9ed5			; TODO consume comments held between ( and ) 
9ed5			 
9ed5				; we have a space so change to zero term for dict match later 
9ed5 2b				dec hl 
9ed6 3e 00			ld a,0 
9ed8 77				ld (hl), a 
9ed9 23				inc hl 
9eda 18 e7			jr .ptoken2 
9edc				 
9edc			 
9edc			.ptokenstr2: 
9edc				; skip all white space until either eol (because forgot to term) or end double quote 
9edc			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9edc				;inc hl ; skip current double quote 
9edc 7e				ld a,(hl) 
9edd 23				inc hl 
9ede fe 22			cp '"' 
9ee0 28 e1			jr z, .ptoken2 
9ee2 fe 7f			cp FORTH_END_BUFFER 
9ee4 28 0c			jr z, .ptokendone2 
9ee6 fe 00			cp 0 
9ee8 28 08			jr z, .ptokendone2 
9eea fe 20			cp ' ' 
9eec 28 02			jr z, .ptmp2 
9eee 18 ec			jr .ptokenstr2 
9ef0			 
9ef0			.ptmp2:	; we have a space so change to zero term for dict match later 
9ef0				;dec hl 
9ef0				;ld a,"-"	; TODO remove this when working 
9ef0				;ld (hl), a 
9ef0				;inc hl 
9ef0 18 ea			jr .ptokenstr2 
9ef2			 
9ef2			.ptokendone2: 
9ef2				;inc hl 
9ef2 3e 7f			ld a, FORTH_END_BUFFER 
9ef4 77				ld (hl),a 
9ef5			;	inc hl 
9ef5			;	ld a, '!' 
9ef5			;	ld (hl),a 
9ef5			 
9ef5 2a bc e5			ld hl,(os_tok_ptr) 
9ef8			         
9ef8			if DEBUG_FORTH_TOK 
9ef8						DMARK "TK1" 
9ef8				CALLMONITOR 
9ef8			endif 
9ef8			 
9ef8				; push exec string to top of return stack 
9ef8				FORTH_RSP_NEXT 
9ef8 cd 2c 9a			call macro_forth_rsp_next 
9efb				endm 
# End of macro FORTH_RSP_NEXT
9efb c9				ret 
9efc			 
9efc			; 
9efc			;	; malloc size + buffer pointer + if is loop flag 
9efc			;	ld hl,(os_tok_len) 		 ; get string length 
9efc			; 
9efc			;	ld a,l 
9efc			; 
9efc			;	cp 0			; we dont want to use a null string 
9efc			;	ret z 
9efc			; 
9efc			;;	add 3    ; prefix malloc with buffer for current word ptr 
9efc			; 
9efc			;	add 5     ; TODO when certain not over writing memory remove 
9efc			; 
9efc			;		 
9efc			; 
9efc			;if DEBUG_FORTH_TOK 
9efc			;			DMARK "TKE" 
9efc			;	CALLMONITOR 
9efc			;endif 
9efc			; 
9efc			;	ld l,a 
9efc			;	ld h,0 
9efc			;;	push hl   ; save required space for the copy later 
9efc			;	call malloc 
9efc			;if DEBUG_FORTH_TOK 
9efc			;			DMARK "TKM" 
9efc			;	CALLMONITOR 
9efc			;endif 
9efc			;	if DEBUG_FORTH_MALLOC_GUARD 
9efc			;		push af 
9efc			;		call ishlzero 
9efc			;;		ld a, l 
9efc			;;		add h 
9efc			;;		cp 0 
9efc			;		pop af 
9efc			;		 
9efc			;		call z,malloc_error 
9efc			;	endif 
9efc			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9efc			; 
9efc			; 
9efc			;if DEBUG_FORTH_TOK 
9efc			;			DMARK "TKR" 
9efc			;	CALLMONITOR 
9efc			;endif 
9efc			; 
9efc			;	FORTH_RSP_NEXT 
9efc			; 
9efc			;	;inc hl	 ; go past current buffer pointer 
9efc			;	;inc hl 
9efc			;	;inc hl   ; and past if loop flag 
9efc			;		; TODO Need to set flag  
9efc			; 
9efc			;	 
9efc			;	 
9efc			;	ex de,hl	; malloc is dest 
9efc			;	ld hl, (os_tok_len) 
9efc			;;	pop bc 
9efc			;	ld c, l                
9efc			;	ld b,0 
9efc			;	ld hl, (os_tok_ptr) 
9efc			; 
9efc			;if DEBUG_FORTH_TOK 
9efc			;			DMARK "TKT" 
9efc			;	CALLMONITOR 
9efc			;endif 
9efc			; 
9efc			;	; do str cpy 
9efc			; 
9efc			;	ldir      ; copy byte in hl to de 
9efc			; 
9efc			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9efc			; 
9efc			;if DEBUG_FORTH_TOK 
9efc			; 
9efc			;			DMARK "TKY" 
9efc			;	CALLMONITOR 
9efc			;endif 
9efc			;	;ld a,0 
9efc			;	;ld a,FORTH_END_BUFFER 
9efc			;	ex de, hl 
9efc			;	;dec hl			 ; go back over the space delim at the end of word 
9efc			;	;ld (hl),a 
9efc			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9efc			;	ld a,FORTH_END_BUFFER 
9efc			;	ld (hl),a 
9efc			;	inc hl 
9efc			;	ld a,FORTH_END_BUFFER 
9efc			;	ld (hl),a 
9efc			; 
9efc			;	; init the malloc area data 
9efc			;	; set pc for in current area 
9efc			;	;ld hl, (os_tok_malloc) 
9efc			;	;inc hl 
9efc			;	;inc hl 
9efc			;	;inc hl 
9efc			;	;ex de,hl 
9efc			;	;ld hl, (os_tok_malloc) 
9efc			;	;ld (hl),e 
9efc			;	;inc hl 
9efc			;	;ld (hl),d 
9efc			; 
9efc			; 
9efc			;	ld hl,(os_tok_malloc) 
9efc			;if DEBUG_FORTH_PARSE_KEY 
9efc			;			DMARK "TKU" 
9efc			;	CALLMONITOR 
9efc			;endif 
9efc			; 
9efc			;	ret 
9efc			 
9efc			forthexec: 
9efc			 
9efc			; line exec: 
9efc			; forth parser 
9efc			 
9efc			; 
9efc			;       get current exec line on rsp 
9efc			 
9efc				FORTH_RSP_TOS 
9efc cd 43 9a			call macro_forth_rsp_tos 
9eff				endm 
# End of macro FORTH_RSP_TOS
9eff			 
9eff			;       restore current pc - hl points to malloc of data 
9eff			 
9eff				;ld e, (hl) 
9eff				;inc hl 
9eff				;ld d, (hl) 
9eff				;ex de,hl 
9eff			 
9eff			 
9eff			exec1: 
9eff 22 bc e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
9f02			 
9f02				; copy our PC to working vars  
9f02 22 3a ea			ld (cli_ptr), hl                    ; here 
9f05 22 38 ea			ld (cli_origptr), hl                ; here 
9f08			 
9f08 7e				ld a,(hl)                           ; here make hl be the ram ptr 
9f09 fe 7f			cp FORTH_END_BUFFER 
9f0b c8				ret z 
9f0c			 
9f0c				; skip any nulls 
9f0c			 
9f0c fe 00			cp 0 
9f0e 20 03			jr nz, .execword 
9f10 23				inc hl 
9f11 18 ec			jr exec1 
9f13			 
9f13			 
9f13			.execword: 
9f13			 
9f13			 
9f13			 
9f13			if DEBUG_FORTH_PARSE_EXEC 
9f13						DMARK "KYQ" 
9f13				CALLMONITOR 
9f13			endif 
9f13			;       while at start of word: 
9f13			; get start of dict (in user area first) 
9f13			 
9f13 21 97 df		ld hl, baseram 
9f16			;ld hl, sysdict 
9f16 22 3c ea		ld (cli_nextword),hl                            ; here do we need to do this? 
9f19			;           match word at pc 
9f19			;           exec word 
9f19			;           or push to dsp 
9f19			;           forward to next token 
9f19			;           if line term pop rsp and exit 
9f19			;        
9f19			 
9f19			if DEBUG_FORTH_PARSE_EXEC 
9f19						DMARK "KYq" 
9f19				CALLMONITOR 
9f19			endif 
9f19			 
9f19			; 
9f19			; word comp 
9f19			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f19			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f19			;    move to start of word  
9f19			;    compare word to cli_token 
9f19			 
9f19			.execpnword:	; HL at start of a word in the dictionary to check 
9f19			 
9f19 2a 3c ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
9f1c			 
9f1c cd b3 9f			call forth_tok_next 
9f1f			; tok next end here 
9f1f 22 3c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f22 eb				ex de, hl 
9f23			 
9f23			 
9f23				; save the pointer of the current token - 1 to check against 
9f23				 
9f23 22 40 ea			ld (cli_token), hl   
9f26				; TODO maybe remove below save if no debug 
9f26				; save token string ptr for any debug later 
9f26 23				inc hl  
9f27 22 42 ea			ld (cli_origtoken), hl 
9f2a 2b				dec hl 
9f2b				; save pointer to the start of the next dictionay word 
9f2b 7e				ld a,(hl)   ; get string length 
9f2c 47				ld b,a 
9f2d			.execpnwordinc:  
9f2d 23				inc hl 
9f2e 10 fd			djnz .execpnwordinc 
9f30 22 3e ea			ld (cli_execword), hl      ; save start of this words code 
9f33			 
9f33				; now check the word token against the string being parsed 
9f33			 
9f33 2a 40 ea			ld hl,(cli_token) 
9f36 23				inc hl     ; skip string length (use zero term instead to end) 
9f37				;ld (cli_token), hl 
9f37			 
9f37			.execpnchar:    ; compare char between token and string to parse 
9f37			 
9f37			 
9f37				;ld hl, (cli_token)     ; the dict word  
9f37 ed 5b 3a ea		ld de, (cli_ptr)     ; cli to parse 
9f3b			 
9f3b			 
9f3b			.execpncharl:    ; compare char between token and string to parse (loop) 
9f3b			 
9f3b 1a				ld a,(de) 
9f3c cd 47 90			call toUpper 		; make sure the input string matches case 
9f3f be				cp (hl) 
9f40			 
9f40 c2 59 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f43				 
9f43			;    if same 
9f43			;       scan for string terms 0 for token and 32 for input 
9f43 46				ld b,(hl) 
9f44 80				add b			 
9f45 23				inc hl 
9f46 13				inc de 
9f47 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f49							; TODO need to make sure last word in zero term string is accounted for 
9f49 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
9f4b			 
9f4b			 
9f4b				; at end of both strings so both are exact match 
9f4b			 
9f4b			;       skip ptr for next word 
9f4b			 
9f4b 2a 3a ea			ld hl,(cli_ptr) 	; at input string term 
9f4e 23				inc hl			 ; at next char 
9f4f 22 3a ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f52 22 38 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f55				 
9f55				 
9f55			 
9f55			 
9f55			 
9f55			;       exec code block 
9f55			if DEBUG_FORTH_JP 
9f55				call clear_display 
9f55				call update_display 
9f55				call delay1s 
9f55				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f55				ld a,h 
9f55				ld hl, os_word_scratch 
9f55				call hexout 
9f55				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f55				ld a,l 
9f55				ld hl, os_word_scratch+2 
9f55				call hexout 
9f55				ld hl, os_word_scratch+4 
9f55				ld a,0 
9f55				ld (hl),a 
9f55				ld de,os_word_scratch 
9f55				call str_at_display 
9f55					ld a, display_row_2 
9f55					call str_at_display 
9f55				ld de, (cli_origtoken) 
9f55				ld a, display_row_1+10 
9f55					call str_at_display 
9f55			 
9f55				ld a,display_row_1 
9f55				ld de, .foundword 
9f55				ld a, display_row_3 
9f55				call str_at_display 
9f55				call update_display 
9f55				call delay1s 
9f55				call delay1s 
9f55				call delay1s 
9f55			endif 
9f55			 
9f55			if DEBUG_FORTH_PARSE_EXEC 
9f55						DMARK "KYj" 
9f55			endif 
9f55				; TODO save the word pointer in this exec 
9f55			 
9f55 2a 3e ea			ld hl,(cli_execword) 
9f58 e9				jp (hl) 
9f59			 
9f59			 
9f59			;    if not same 
9f59			;	scan for zero term 
9f59			;	get ptr for next word 
9f59			;	goto word comp 
9f59			 
9f59			.execpnskipword:	; get pointer to next word 
9f59 2a 3c ea			ld hl,(cli_nextword) 
9f5c			 
9f5c 7e				ld a,(hl) 
9f5d fe 00			cp WORD_SYS_END 
9f5f			;	cp 0 
9f5f 28 09			jr z, .execendofdict			 ; at end of words 
9f61			 
9f61			if DEBUG_FORTH_PARSE_EXEC 
9f61						DMARK "KY4" 
9f61			endif 
9f61			if DEBUG_FORTH_PARSE_EXEC 
9f61			 
9f61				; see if disabled 
9f61			 
9f61			;	ld a, (os_view_disable) 
9f61			;	cp '*' 
9f61				ld a,(debug_vector) 
9f61				cp $c9   ; RET 
9f61				jr z, .noskip 
9f61			 
9f61			 
9f61				ld de, .nowordfound 
9f61				ld a, display_row_3 
9f61				call str_at_display 
9f61				call update_display 
9f61				ld a, 100 
9f61				call aDelayInMS 
9f61				 
9f61				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f61					call delay250ms 
9f61				endif 
9f61			.noskip:  
9f61			 
9f61			endif	 
9f61			 
9f61 2a 38 ea			ld hl,(cli_origptr) 
9f64 22 3a ea			ld (cli_ptr),hl 
9f67			 
9f67			if DEBUG_FORTH_PARSE_EXEC 
9f67						DMARK "KY5" 
9f67			endif 
9f67 c3 19 9f			jp .execpnword			; else go to next word 
9f6a			 
9f6a			.execendofdict:  
9f6a			 
9f6a			if DEBUG_FORTH_PARSE_EXEC 
9f6a						DMARK "KYe" 
9f6a			endif 
9f6a			if DEBUG_FORTH_PARSE_EXEC 
9f6a				; see if disabled 
9f6a			 
9f6a			;	ld a, (os_view_disable) 
9f6a			;	cp '*' 
9f6a				ld a,(debug_vector) 
9f6a				cp $c9   ; ret 
9f6a				jr z, .ispskip 
9f6a			 
9f6a				call clear_display 
9f6a				call update_display 
9f6a				call delay1s 
9f6a				ld de, (cli_origptr) 
9f6a				ld a, display_row_1 
9f6a				call str_at_display 
9f6a				 
9f6a				ld de, .enddict 
9f6a				ld a, display_row_3 
9f6a				call str_at_display 
9f6a				call update_display 
9f6a				ld a, 100 
9f6a				call aDelayInMS 
9f6a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f6a				call delay1s 
9f6a				call delay1s 
9f6a				call delay1s 
9f6a				endif 
9f6a			.ispskip:  
9f6a				 
9f6a			endif	 
9f6a			 
9f6a			 
9f6a			 
9f6a				; if the word is not a keyword then must be a literal so push it to stack 
9f6a			 
9f6a			; push token to stack to end of word 
9f6a			 
9f6a				STACKFRAME ON $1efe $2f9f 
9f6a				if DEBUG_STACK_IMB 
9f6a					if ON 
9f6a						exx 
9f6a						ld de, $1efe 
9f6a						ld a, d 
9f6a						ld hl, curframe 
9f6a						call hexout 
9f6a						ld a, e 
9f6a						ld hl, curframe+2 
9f6a						call hexout 
9f6a						ld hl, $1efe 
9f6a						push hl 
9f6a						ld hl, $2f9f 
9f6a						push hl 
9f6a						exx 
9f6a					endif 
9f6a				endif 
9f6a			endm 
# End of macro STACKFRAME
9f6a			 
9f6a 2a bc e5		ld hl,(os_tok_ptr) 
9f6d cd ee 9b		call forth_apush 
9f70			 
9f70				STACKFRAMECHK ON $1efe $2f9f 
9f70				if DEBUG_STACK_IMB 
9f70					if ON 
9f70						exx 
9f70						ld hl, $2f9f 
9f70						pop de   ; $2f9f 
9f70						call cmp16 
9f70						jr nz, .spnosame 
9f70						ld hl, $1efe 
9f70						pop de   ; $1efe 
9f70						call cmp16 
9f70						jr z, .spfrsame 
9f70						.spnosame: call showsperror 
9f70						.spfrsame: nop 
9f70						exx 
9f70					endif 
9f70				endif 
9f70			endm 
# End of macro STACKFRAMECHK
9f70			 
9f70			execnext: 
9f70			 
9f70			if DEBUG_FORTH_PARSE_EXEC 
9f70						DMARK "KY>" 
9f70			endif 
9f70			; move past token to next word 
9f70			 
9f70 2a bc e5		ld hl, (os_tok_ptr) 
9f73 3e 00		ld a, 0 
9f75 01 ff 00		ld bc, 255     ; input buffer size 
9f78 ed b1		cpir 
9f7a			 
9f7a			if DEBUG_FORTH_PARSE_EXEC 
9f7a						DMARK "KY!" 
9f7a				CALLMONITOR 
9f7a			endif	 
9f7a			; TODO this might place hl on the null, so will need to forward on??? 
9f7a			;inc hl   ; see if this gets onto the next item 
9f7a			 
9f7a			 
9f7a			; TODO pass a pointer to the buffer to push 
9f7a			; TODO call function to push 
9f7a			 
9f7a			; look for end of input 
9f7a			 
9f7a			;inc hl 
9f7a			;ld a,(hl) 
9f7a			;cp FORTH_END_BUFFER 
9f7a			;ret z 
9f7a			 
9f7a			 
9f7a c3 ff 9e		jp exec1 
9f7d			 
9f7d			 
9f7d			 
9f7d			 
9f7d			 
9f7d			 
9f7d			 
9f7d			 
9f7d			 
9f7d			findnexttok: 
9f7d			 
9f7d				; hl is pointer to move 
9f7d				; de is the token to locate 
9f7d			 
9f7d					if DEBUG_FORTH 
9f7d						DMARK "NTK" 
9f7d						CALLMONITOR 
9f7d					endif 
9f7d d5				push de 
9f7e			 
9f7e			.fnt1:	 
9f7e				; find first char of token to locate 
9f7e			 
9f7e 1a				ld a, (de) 
9f7f 4f				ld c,a 
9f80 7e				ld a,(hl) 
9f81 cd 47 90			call toUpper 
9f84					if DEBUG_FORTH 
9f84						DMARK "NT1" 
9f84						CALLMONITOR 
9f84					endif 
9f84 b9				cp c 
9f85			 
9f85 28 03			jr z, .fnt2cmpmorefirst	 
9f87			 
9f87				; first char not found move to next char 
9f87			 
9f87 23				inc hl 
9f88 18 f4			jr .fnt1 
9f8a			 
9f8a			.fnt2cmpmorefirst:	 
9f8a				; first char of token found.  
9f8a			 
9f8a e5				push hl     ; save start of token just in case it is the right one 
9f8b d9				exx 
9f8c e1				pop hl        ; save it to hl' 
9f8d d9				exx 
9f8e			 
9f8e			 
9f8e			.fnt2cmpmore:	 
9f8e				; compare the rest 
9f8e				 
9f8e 23				inc hl 
9f8f 13				inc de 
9f90				 
9f90 1a				ld a, (de) 
9f91 4f				ld c,a 
9f92 7e				ld a,(hl) 
9f93 cd 47 90			call toUpper 
9f96			 
9f96					if DEBUG_FORTH 
9f96						DMARK "NT2" 
9f96						CALLMONITOR 
9f96					endif 
9f96				; c has the token to find char 
9f96				; a has the mem to scan char 
9f96			 
9f96 b9				cp c 
9f97 28 04			jr z,.fntmatch1 
9f99			 
9f99				; they are not the same 
9f99			 
9f99					if DEBUG_FORTH 
9f99						DMARK "NT3" 
9f99						CALLMONITOR 
9f99					endif 
9f99 d1				pop de	; reset de token to look for 
9f9a d5				push de 
9f9b 18 e1			jr .fnt1 
9f9d				 
9f9d			.fntmatch1: 
9f9d			 
9f9d				; is the same char a null which means we might have a full hit? 
9f9d					if DEBUG_FORTH 
9f9d						DMARK "NT4" 
9f9d						CALLMONITOR 
9f9d					endif 
9f9d			 
9f9d fe 00			cp 0 
9f9f 28 0b			jr z, .fntmatchyes 
9fa1			 
9fa1				; are we at the end of the token to find? 
9fa1			 
9fa1					if DEBUG_FORTH 
9fa1						DMARK "NT5" 
9fa1						CALLMONITOR 
9fa1					endif 
9fa1 3e 00			ld a, 0 
9fa3 b9				cp c 
9fa4			 
9fa4 c2 8e 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9fa7			 
9fa7					if DEBUG_FORTH 
9fa7						DMARK "NT6" 
9fa7						CALLMONITOR 
9fa7					endif 
9fa7				; token to find is exhusted but no match to stream 
9fa7			 
9fa7				; restore tok pointer and continue on 
9fa7 d1				pop de 
9fa8 d5				push de 
9fa9 c3 7e 9f			jp .fnt1 
9fac			 
9fac			 
9fac			.fntmatchyes: 
9fac			 
9fac				; hl now contains the end of the found token 
9fac			 
9fac				; get rid of saved token pointer to find 
9fac			 
9fac d1				pop de 
9fad			 
9fad					if DEBUG_FORTH 
9fad						DMARK "NT9" 
9fad						CALLMONITOR 
9fad					endif 
9fad			 
9fad				; hl will be on the null term so forward on 
9fad			 
9fad				; get back the saved start of the token 
9fad			 
9fad d9				exx 
9fae e5				push hl     ; save start of token just in case it is the right one 
9faf d9				exx 
9fb0 e1				pop hl        ; save it to hl 
9fb1			 
9fb1 c9				ret 
9fb2			 
9fb2			 
9fb2			; LIST needs to find a specific token   
9fb2			; FORGET needs to find a spefici token 
9fb2			 
9fb2			; SAVE needs to find all tokens by flag 
9fb2			; WORDS just needs to scan through all  by flag 
9fb2			; UWORDS needs to scan through all by flag 
9fb2			 
9fb2			 
9fb2			; given hl as pointer to start of dict look up string 
9fb2			; return hl as pointer to start of word block 
9fb2			; or 0 if not found 
9fb2			 
9fb2			forth_find_tok: 
9fb2 c9				ret 
9fb3			 
9fb3			; given hl as pointer to dict structure 
9fb3			; move to the next dict block structure 
9fb3			 
9fb3			forth_tok_next: 
9fb3				; hl now points to the address of the next word pointer  
9fb3				; TODO skip compiled symbol for now 
9fb3			;	push de 
9fb3 23				inc hl 
9fb4 5e				ld e, (hl) 
9fb5 23				inc hl 
9fb6 56				ld d, (hl) 
9fb7 23				inc hl 
9fb8			 
9fb8 eb				ex de,hl 
9fb9			if DEBUG_FORTH_PARSE_NEXTWORD 
9fb9				push bc 
9fb9				ld bc, (cli_nextword) 
9fb9						DMARK "NXW" 
9fb9				CALLMONITOR 
9fb9				pop bc 
9fb9			endif 
9fb9			;	pop de	 
9fb9 c9				ret 
9fba			 
9fba			 
9fba			 
9fba			; eof 
# End of file forth_parserv6.asm
9fba				include "forth_wordsv4.asm" 
9fba			 
9fba			; the core word dictionary v4 
9fba			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9fba			 
9fba			; this is a linked list for each of the system words used 
9fba			; user defined words will follow the same format but will be in ram 
9fba			 
9fba			 
9fba			; 
9fba			; 
9fba			; define linked list: 
9fba			; 
9fba			; 1. compiled byte op code 
9fba			; 2. len of text word 
9fba			; 3. text word 
9fba			; 4. ptr to next dictionary word 
9fba			; 5. asm, calls etc for the word 
9fba			; 
9fba			;  if 1 == 0 then last word in dict  
9fba			;   
9fba			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9fba			;  
9fba			;  
9fba			; create basic standard set of words 
9fba			; 
9fba			;  
9fba			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9fba			; 2DUP 2DROP 2SWAP  
9fba			; @ C@ - get byte  
9fba			; ! C! - store byte 
9fba			; 0< true if less than zero 
9fba			; 0= true if zero 
9fba			; < >  
9fba			; = true if same 
9fba			; variables 
9fba			 
9fba			 
9fba			; Hardware specific words I may need 
9fba			; 
9fba			; IN OUT  
9fba			; calls to key util functions 
9fba			; calls to hardward abstraction stuff 
9fba			; easy control of frame buffers and lcd i/o 
9fba			; keyboard  
9fba			 
9fba			 
9fba			;DICT: macro 
9fba			; op_code, len, word, next 
9fba			;    word: 
9fba			;    db op_code 
9fba			;    ds word zero term 
9fba			;    dw next 
9fba			;    endm 
9fba			 
9fba			 
9fba			 
9fba			 
9fba			; op code 1 is a flag for user define words which are to be handled differently 
9fba			 
9fba			 
9fba			; 
9fba			; 
9fba			;    TODO on entry to a word this should be the expected environment 
9fba			;    hl - tos value if number then held, if string this is the ptr 
9fba			;    de -  
9fba			 
9fba			 
9fba			; opcode ranges 
9fba			; 0 - end of word dict 
9fba			; 255 - user define words 
9fba			 
9fba			sysdict: 
9fba			include "forth_opcodes.asm" 
9fba			; op codes for forth keywords 
9fba			 
9fba			; Changing use of opcodes to flag is the word exists in compiled form or not.  
9fba			; This provides a means to compile uwords if required for higher performance 
9fba			; by avoiding the use of the keyword parser and just jumping directly to the code 
9fba			; Actually there is already a flag for if the code exists as binary thinking about it... 
9fba			 
9fba			 
9fba			 
9fba			 
9fba			 
9fba			; free to use code 0  
9fba				OPCODE_HEAP: equ  1 
9fba				OPCODE_EXEC: equ 2 
9fba				OPCODE_DUP: equ 3 
9fba				OPCODE_SWAP: equ 4 
9fba				OPCODE_COLN: equ 5 
9fba				OPCODE_SCOLN: equ 6 
9fba				OPCODE_DROP: equ 7 
9fba				OPCODE_DUP2: equ 8 
9fba				OPCODE_DROP2: equ 9 
9fba				OPCODE_SWAP2: equ 10 
9fba				OPCODE_AT: equ 11 
9fba				OPCODE_CAT: equ 12 
9fba				OPCODE_BANG: equ 13 
9fba				OPCODE_CBANG: equ 14 
9fba				OPCODE_SCALL: equ 15 
9fba				OPCODE_DEPTH: equ 16 
9fba				OPCODE_OVER: equ 17 
9fba				OPCODE_PAUSE: equ 18 
9fba				OPCODE_PAUSES: equ 19 
9fba				OPCODE_ROT: equ 20 
9fba			;free to reuse	OPCODE_WORDS: equ 21 
9fba			        OPCODE_NOT: equ 21 
9fba				OPCODE_UWORDS: equ 22 
9fba				OPCODE_BP: equ 23 
9fba				OPCODE_MONITOR: equ 24  
9fba				OPCODE_MALLOC: equ 25 
9fba				OPCODE_FREE: equ 26 
9fba				OPCODE_LIST: equ 27 
9fba				OPCODE_FORGET: equ 28 
9fba				OPCODE_NOP: equ 29 
9fba				OPCODE_COMO: equ 30 
9fba				OPCODE_COMC: equ 31 
9fba			;free to reuse	OPCODE_ENDCORE: equ 32 
9fba				OPCODE_AFTERSOUND: equ 33 
9fba				OPCODE_GP2: equ 34 
9fba				OPCODE_GP3: equ 35 
9fba				OPCODE_GP4: equ 36 
9fba				OPCODE_SIN: equ 37 
9fba				OPCODE_SOUT: equ 38 
9fba				OPCODE_SPIO: equ 39 
9fba				OPCODE_SPICEH: equ 40 
9fba				OPCODE_SPIOb: equ 41 
9fba				OPCODE_SPII: equ 42 
9fba				OPCODE_SESEL: equ 43 
9fba				OPCODE_CARTDEV: equ 44 
9fba			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9fba				OPCODE_FB: equ 46 
9fba				OPCODE_EMIT: equ 47 
9fba				OPCODE_DOTH: equ 48 
9fba				OPCODE_DOTF: equ 49 
9fba				OPCODE_DOT: equ 50 
9fba				OPCODE_CLS: equ 51 
9fba				OPCODE_DRAW: equ 52 
9fba				OPCODE_DUMP: equ 53 
9fba				OPCODE_CDUMP: equ 54 
9fba				OPCODE_DAT: equ 55 
9fba				OPCODE_HOME: equ 56 
9fba				OPCODE_SPACE: equ 57 
9fba				OPCODE_SPACES: equ 58 
9fba				OPCODE_SCROLL: equ 59 
9fba				OPCODE_ATQ: equ 60 
9fba				OPCODE_AUTODSP: equ 61 
9fba				OPCODE_MENU: equ 62 
9fba			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9fba				OPCODE_THEN: equ 64 
9fba				OPCODE_ELSE: equ 65 
9fba				OPCODE_DO: equ 66 
9fba				OPCODE_LOOP: equ 67 
9fba				OPCODE_I: equ 68 
9fba				OPCODE_DLOOP: equ 69  
9fba				OPCODE_REPEAT: equ 70  
9fba				OPCODE_UNTIL: equ 71 
9fba				OPCODE_ENDFLOW: equ 72 
9fba				OPCODE_WAITK: equ 73 
9fba				OPCODE_ACCEPT: equ 74 
9fba				OPCODE_EDIT: equ 75 
9fba			;free to reuse	OPCODE_ENDKEY: equ 76 
9fba				OPCODE_LZERO: equ 77 
9fba				OPCODE_TZERO: equ 78 
9fba				OPCODE_LESS: equ 79 
9fba				OPCODE_GT: equ 80 
9fba				OPCODE_EQUAL: equ 81  
9fba			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9fba				OPCODE_NEG: equ 83 
9fba				OPCODE_DIV: equ 84 
9fba				OPCODE_MUL: equ 85 
9fba				OPCODE_MIN: equ 86 
9fba				OPCODE_MAX: equ 87 
9fba				OPCODE_RND16: equ 88 
9fba				OPCODE_RND8: equ 89 
9fba				OPCODE_RND: equ 90 
9fba			;free to reuse	OPCODE_ENDMATHS: equ 91  
9fba				OPCODE_BYNAME: equ 92 
9fba				OPCODE_DIR: equ 93 
9fba				OPCODE_SAVE: equ 94 
9fba				OPCODE_LOAD: equ 95 
9fba				OPCODE_BSAVE: equ 96 
9fba				OPCODE_BLOAD: equ 97 
9fba				OPCODE_SEO: equ 98  
9fba				OPCODE_SEI: equ 99 
9fba				OPCODE_SFREE: equ 100 
9fba				OPCODE_SIZE: equ 101 
9fba				OPCODE_CREATE: equ 102 
9fba				OPCODE_APPEND: equ 103 
9fba				OPCODE_SDEL: equ 104 
9fba				OPCODE_OPEN: equ 105 
9fba				OPCODE_READ: equ 106 
9fba				OPCODE_EOF: equ 106 
9fba				OPCODE_FORMAT: equ 107 
9fba				OPCODE_LABEL: equ 108 
9fba				OPCODE_LABELS: equ 109 
9fba			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9fba				OPCODE_UPPER: equ 111 
9fba				OPCODE_LOWER: equ 112 
9fba				OPCODE_SUBSTR: equ 113 
9fba				OPCODE_LEFT: equ 114 
9fba				OPCODE_RIGHT: equ 115 
9fba				OPCODE_STR2NUM: equ 116 
9fba				OPCODE_NUM2STR: equ 117 
9fba				OPCODE_CONCAT: equ 118 
9fba				OPCODE_FIND: equ 119 
9fba				OPCODE_LEN: equ 120 
9fba				OPCODE_CHAR: equ 121 
9fba			; free to reuse	OPCODE_STRLEN: equ 122 
9fba			; free to reuse	OPCODE_ENDSTR: equ 123 
9fba				OPCODE_V0S: equ 124 
9fba				OPCODE_V0Q: equ 125 
9fba				OPCODE_V1S: equ 126 
9fba				OPCODE_V1Q: equ 127 
9fba				OPCODE_V2S: equ 128 
9fba				OPCODE_V2Q: equ 129 
9fba				OPCODE_V3S: equ 130 
9fba				OPCODE_V3Q: equ 131 
9fba			;free to reuse	OPCODE_END: equ 132 
9fba				OPCODE_ZDUP: equ 133 
9fba			 
9fba			; eof 
# End of file forth_opcodes.asm
9fba			 
9fba			include "forth_words_core.asm" 
9fba			 
9fba			; | ## Core Words 
9fba			 
9fba			;if MALLOC_4 
9fba			 
9fba			.HEAP: 
9fba			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9fba 15				db WORD_SYS_CORE+OPCODE_HEAP             
9fbb f9 9f			dw .EXEC            
9fbd 05				db 4 + 1 
9fbe .. 00			db "HEAP",0              
9fc3				endm 
# End of macro CWHEAD
9fc3			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9fc3			; | | u1 - Current number of bytes in the heap 
9fc3			; | | u2 - Remaining bytes left on the heap 
9fc3			; | |  
9fc3			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9fc3			 
9fc3			 
9fc3				if DEBUG_FORTH_WORDS_KEY 
9fc3					DMARK "HEP" 
9fc3 f5				push af  
9fc4 3a d8 9f			ld a, (.dmark)  
9fc7 32 65 ee			ld (debug_mark),a  
9fca 3a d9 9f			ld a, (.dmark+1)  
9fcd 32 66 ee			ld (debug_mark+1),a  
9fd0 3a da 9f			ld a, (.dmark+2)  
9fd3 32 67 ee			ld (debug_mark+2),a  
9fd6 18 03			jr .pastdmark  
9fd8 ..			.dmark: db "HEP"  
9fdb f1			.pastdmark: pop af  
9fdc			endm  
# End of macro DMARK
9fdc					CALLMONITOR 
9fdc cd 6f ee			call debug_vector  
9fdf				endm  
# End of macro CALLMONITOR
9fdf				endif 
9fdf 2a a1 df			ld hl, (free_list )      
9fe2 11 a6 df			ld de, heap_start 
9fe5			 
9fe5 ed 52			sbc hl, de  
9fe7			 
9fe7 cd 85 9a			call forth_push_numhl 
9fea			 
9fea			 
9fea ed 5b a1 df		ld de, (free_list )      
9fee 21 96 e2			ld hl, heap_end 
9ff1			 
9ff1 ed 52			sbc hl, de 
9ff3			 
9ff3 cd 85 9a			call forth_push_numhl 
9ff6				 
9ff6			 
9ff6				 
9ff6			 
9ff6			 
9ff6			 
9ff6				NEXTW 
9ff6 c3 76 9e			jp macro_next 
9ff9				endm 
# End of macro NEXTW
9ff9			;endif 
9ff9			 
9ff9			.EXEC: 
9ff9			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9ff9			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9ff9			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9ff9			;; > > 
9ff9			;; > >   
9ff9			;	STACKFRAME OFF $5efe $5f9f 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS_KEY 
9ff9			;			DMARK "EXE" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			; 
9ff9			;	FORTH_DSP_VALUEHL 
9ff9			; 
9ff9			;	FORTH_DSP_POP 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EX1" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;;	ld e,(hl) 
9ff9			;;	inc hl 
9ff9			;;	ld d,(hl) 
9ff9			;;	ex de,hl 
9ff9			; 
9ff9			;;		if DEBUG_FORTH_WORDS 
9ff9			;;			DMARK "EX2" 
9ff9			;;			CALLMONITOR 
9ff9			;;		endif 
9ff9			;	push hl 
9ff9			; 
9ff9			;	;ld a, 0 
9ff9			;	;ld a, FORTH_END_BUFFER 
9ff9			;	call strlenz 
9ff9			;	inc hl   ; include zero term to copy 
9ff9			;	inc hl   ; include term 
9ff9			;	inc hl   ; include term 
9ff9			;	ld b,0 
9ff9			;	ld c,l 
9ff9			;	pop hl 
9ff9			;	ld de, execscratch 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EX3" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;	ldir 
9ff9			; 
9ff9			; 
9ff9			;	ld hl, execscratch 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EXe" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			; 
9ff9			;	call forthparse 
9ff9			;	call forthexec 
9ff9			;;	call forthexec_cleanup 
9ff9			;;	call forthparse 
9ff9			;;	call forthexec 
9ff9			; 
9ff9			;	STACKFRAMECHK OFF $5efe $5f9f 
9ff9			; 
9ff9			;	; an immediate word so no need to process any more words 
9ff9			;	ret 
9ff9			;	NEXTW 
9ff9			 
9ff9			; dead code - old version  
9ff9			;	FORTH_RSP_NEXT 
9ff9			 
9ff9			;  
9ff9			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9ff9			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ff9			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ff9			;	push hl 
9ff9			;	push de 
9ff9			;	push bc 
9ff9			; 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS_KEY 
9ff9			;			DMARK "EXR" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			; 
9ff9			; 
9ff9			; 
9ff9			;	;v5 FORTH_DSP_VALUE 
9ff9			;	FORTH_DSP_VALUEHL 
9ff9			; 
9ff9			;	; TODO do string type checks 
9ff9			; 
9ff9			;;v5	inc hl   ; skip type 
9ff9			; 
9ff9			;	push hl  ; source code  
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EX1" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;	ld a, 0 
9ff9			;	call strlent 
9ff9			; 
9ff9			;	inc hl 
9ff9			;	inc hl 
9ff9			;	inc hl 
9ff9			;	inc hl 
9ff9			; 
9ff9			;	push hl    ; size 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EX2" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;	call malloc 
9ff9			; 
9ff9			;	ex de, hl    ; de now contains malloc area 
9ff9			;	pop bc   	; get byte count 
9ff9			;	pop hl      ; get string to copy 
9ff9			; 
9ff9			;	push de     ; save malloc for free later 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EX3" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;	ldir       ; duplicate string 
9ff9			; 
9ff9			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9ff9			;	 
9ff9			;	; TODO fix the parse would be better than this...  
9ff9			;	ex de, hl 
9ff9			;	dec hl 
9ff9			;	ld a, 0 
9ff9			;	ld (hl), a 
9ff9			;	dec hl 
9ff9			;	ld a, ' ' 
9ff9			;	ld (hl), a 
9ff9			;	dec hl 
9ff9			;	ld (hl), a 
9ff9			; 
9ff9			;	dec hl 
9ff9			;	ld (hl), a 
9ff9			; 
9ff9			; 
9ff9			;	FORTH_DSP_POP  
9ff9			; 
9ff9			;	pop hl     
9ff9			;	push hl    ; save malloc area 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EX4" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			; 
9ff9			;	call forthparse 
9ff9			;	call forthexec 
9ff9			;	 
9ff9			;	pop hl 
9ff9			;	if DEBUG_FORTH_WORDS 
9ff9			;		DMARK "EX5" 
9ff9			;		CALLMONITOR 
9ff9			;	endif 
9ff9			; 
9ff9			;	if FORTH_ENABLE_FREE 
9ff9			;	call free 
9ff9			;	endif 
9ff9			; 
9ff9			;	if DEBUG_FORTH_WORDS 
9ff9			;		DMARK "EX6" 
9ff9			;		CALLMONITOR 
9ff9			;	endif 
9ff9			; 
9ff9			;	pop bc 
9ff9			;	pop de 
9ff9			;	pop hl 
9ff9			;;	FORTH_RSP_POP	  
9ff9			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9ff9			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9ff9			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9ff9			; 
9ff9			;	if DEBUG_FORTH_WORDS 
9ff9			;		DMARK "EX7" 
9ff9			;		CALLMONITOR 
9ff9			;	endif 
9ff9			;	NEXTW 
9ff9			 
9ff9			;.STKEXEC: 
9ff9			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9ff9			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9ff9			; 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS_KEY 
9ff9			;			DMARK "STX" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			; 
9ff9			;	FORTH_DSP_VALUEHL 
9ff9			; 
9ff9			;	ld (store_tmp1), hl    ; count 
9ff9			; 
9ff9			;	FORTH_DSP_POP 
9ff9			;.stkexec1: 
9ff9			;	ld hl, (store_tmp1)   ; count 
9ff9			;	ld a, 0 
9ff9			;	cp l 
9ff9			;	ret z 
9ff9			; 
9ff9			;	dec hl 
9ff9			;	ld (store_tmp1), hl    ; count 
9ff9			;	 
9ff9			;	FORTH_DSP_VALUEHL 
9ff9			;	push hl 
9ff9			;	 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EXp" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;	FORTH_DSP_POP 
9ff9			; 
9ff9			;	call strlenz 
9ff9			;	inc hl   ; include zero term to copy 
9ff9			;	inc hl   ; include zero term to copy 
9ff9			;	inc hl   ; include zero term to copy 
9ff9			;	ld b,0 
9ff9			;	ld c,l 
9ff9			;	pop hl 
9ff9			;	ld de, execscratch 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EX3" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;	ldir 
9ff9			; 
9ff9			; 
9ff9			;	ld hl, execscratch 
9ff9			; 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EXP" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			; 
9ff9			;	call forthparse 
9ff9			;	ld hl, execscratch 
9ff9			;		if DEBUG_FORTH_WORDS 
9ff9			;			DMARK "EXx" 
9ff9			;			CALLMONITOR 
9ff9			;		endif 
9ff9			;	call forthexec 
9ff9			; 
9ff9			;	jp .stkexec1 
9ff9			; 
9ff9			;	ret 
9ff9			 
9ff9			 
9ff9			.DUP: 
9ff9			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9ff9 17				db WORD_SYS_CORE+OPCODE_DUP             
9ffa 6f a0			dw .ZDUP            
9ffc 04				db 3 + 1 
9ffd .. 00			db "DUP",0              
a001				endm 
# End of macro CWHEAD
a001			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a001			 
a001				if DEBUG_FORTH_WORDS_KEY 
a001					DMARK "DUP" 
a001 f5				push af  
a002 3a 16 a0			ld a, (.dmark)  
a005 32 65 ee			ld (debug_mark),a  
a008 3a 17 a0			ld a, (.dmark+1)  
a00b 32 66 ee			ld (debug_mark+1),a  
a00e 3a 18 a0			ld a, (.dmark+2)  
a011 32 67 ee			ld (debug_mark+2),a  
a014 18 03			jr .pastdmark  
a016 ..			.dmark: db "DUP"  
a019 f1			.pastdmark: pop af  
a01a			endm  
# End of macro DMARK
a01a					CALLMONITOR 
a01a cd 6f ee			call debug_vector  
a01d				endm  
# End of macro CALLMONITOR
a01d				endif 
a01d			 
a01d				FORTH_DSP 
a01d cd 50 9c			call macro_forth_dsp 
a020				endm 
# End of macro FORTH_DSP
a020			 
a020 7e				ld a, (HL) 
a021 fe 01			cp DS_TYPE_STR 
a023 20 25			jr nz, .dupinum 
a025			 
a025				; push another string 
a025			 
a025				FORTH_DSP_VALUEHL     		 
a025 cd 8a 9c			call macro_dsp_valuehl 
a028				endm 
# End of macro FORTH_DSP_VALUEHL
a028			 
a028			if DEBUG_FORTH_WORDS 
a028				DMARK "DUs" 
a028 f5				push af  
a029 3a 3d a0			ld a, (.dmark)  
a02c 32 65 ee			ld (debug_mark),a  
a02f 3a 3e a0			ld a, (.dmark+1)  
a032 32 66 ee			ld (debug_mark+1),a  
a035 3a 3f a0			ld a, (.dmark+2)  
a038 32 67 ee			ld (debug_mark+2),a  
a03b 18 03			jr .pastdmark  
a03d ..			.dmark: db "DUs"  
a040 f1			.pastdmark: pop af  
a041			endm  
# End of macro DMARK
a041				CALLMONITOR 
a041 cd 6f ee			call debug_vector  
a044				endm  
# End of macro CALLMONITOR
a044			endif 
a044 cd f3 9a			call forth_push_str 
a047			 
a047				NEXTW 
a047 c3 76 9e			jp macro_next 
a04a				endm 
# End of macro NEXTW
a04a			 
a04a			 
a04a			.dupinum: 
a04a				 
a04a			 
a04a			 
a04a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a04a cd 8a 9c			call macro_dsp_valuehl 
a04d				endm 
# End of macro FORTH_DSP_VALUEHL
a04d			 
a04d			; TODO add floating point number detection 
a04d			 
a04d			if DEBUG_FORTH_WORDS 
a04d				DMARK "DUi" 
a04d f5				push af  
a04e 3a 62 a0			ld a, (.dmark)  
a051 32 65 ee			ld (debug_mark),a  
a054 3a 63 a0			ld a, (.dmark+1)  
a057 32 66 ee			ld (debug_mark+1),a  
a05a 3a 64 a0			ld a, (.dmark+2)  
a05d 32 67 ee			ld (debug_mark+2),a  
a060 18 03			jr .pastdmark  
a062 ..			.dmark: db "DUi"  
a065 f1			.pastdmark: pop af  
a066			endm  
# End of macro DMARK
a066				CALLMONITOR 
a066 cd 6f ee			call debug_vector  
a069				endm  
# End of macro CALLMONITOR
a069			endif 
a069			 
a069 cd 85 9a			call forth_push_numhl 
a06c				NEXTW 
a06c c3 76 9e			jp macro_next 
a06f				endm 
# End of macro NEXTW
a06f			.ZDUP: 
a06f			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a06f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a070 a7 a0			dw .SWAP            
a072 05				db 4 + 1 
a073 .. 00			db "?DUP",0              
a078				endm 
# End of macro CWHEAD
a078			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
a078			 
a078				if DEBUG_FORTH_WORDS_KEY 
a078					DMARK "qDU" 
a078 f5				push af  
a079 3a 8d a0			ld a, (.dmark)  
a07c 32 65 ee			ld (debug_mark),a  
a07f 3a 8e a0			ld a, (.dmark+1)  
a082 32 66 ee			ld (debug_mark+1),a  
a085 3a 8f a0			ld a, (.dmark+2)  
a088 32 67 ee			ld (debug_mark+2),a  
a08b 18 03			jr .pastdmark  
a08d ..			.dmark: db "qDU"  
a090 f1			.pastdmark: pop af  
a091			endm  
# End of macro DMARK
a091					CALLMONITOR 
a091 cd 6f ee			call debug_vector  
a094				endm  
# End of macro CALLMONITOR
a094				endif 
a094				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a094 cd 8a 9c			call macro_dsp_valuehl 
a097				endm 
# End of macro FORTH_DSP_VALUEHL
a097			 
a097 e5				push hl 
a098			 
a098				; is it a zero? 
a098			 
a098 3e 00			ld a, 0 
a09a 84				add h 
a09b 85				add l 
a09c			 
a09c e1				pop hl 
a09d			 
a09d fe 00			cp 0 
a09f 28 03			jr z, .dup2orig 
a0a1			 
a0a1			 
a0a1 cd 85 9a			call forth_push_numhl 
a0a4			 
a0a4			 
a0a4			; TODO add floating point number detection 
a0a4			 
a0a4			.dup2orig: 
a0a4			 
a0a4				NEXTW 
a0a4 c3 76 9e			jp macro_next 
a0a7				endm 
# End of macro NEXTW
a0a7			.SWAP: 
a0a7			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a0a7 18				db WORD_SYS_CORE+OPCODE_SWAP             
a0a8 fb a0			dw .COLN            
a0aa 05				db 4 + 1 
a0ab .. 00			db "SWAP",0              
a0b0				endm 
# End of macro CWHEAD
a0b0			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a0b0				if DEBUG_FORTH_WORDS_KEY 
a0b0					DMARK "SWP" 
a0b0 f5				push af  
a0b1 3a c5 a0			ld a, (.dmark)  
a0b4 32 65 ee			ld (debug_mark),a  
a0b7 3a c6 a0			ld a, (.dmark+1)  
a0ba 32 66 ee			ld (debug_mark+1),a  
a0bd 3a c7 a0			ld a, (.dmark+2)  
a0c0 32 67 ee			ld (debug_mark+2),a  
a0c3 18 03			jr .pastdmark  
a0c5 ..			.dmark: db "SWP"  
a0c8 f1			.pastdmark: pop af  
a0c9			endm  
# End of macro DMARK
a0c9					CALLMONITOR 
a0c9 cd 6f ee			call debug_vector  
a0cc				endm  
# End of macro CALLMONITOR
a0cc				endif 
a0cc			 
a0cc			; DONE Use os stack swap memory 
a0cc			 
a0cc				FORTH_DSP_PTR 0     ; TOS 
a0cc 2a e8 e9			ld hl,(cli_data_sp) 
a0cf 11 00 00			ld de, 0 * 3 
a0d2 ed 52			sbc hl, de 
a0d4				endm 
# End of macro FORTH_DSP_PTR
a0d4 cd c2 9d			call hltostack1 
a0d7			  
a0d7				FORTH_DSP_PTR 1     ; TOS 
a0d7 2a e8 e9			ld hl,(cli_data_sp) 
a0da 11 03 00			ld de, 1 * 3 
a0dd ed 52			sbc hl, de 
a0df				endm 
# End of macro FORTH_DSP_PTR
a0df cd c8 9d			call hltostack2 
a0e2			 
a0e2				FORTH_DSP_PTR 0     ; TOS 
a0e2 2a e8 e9			ld hl,(cli_data_sp) 
a0e5 11 00 00			ld de, 0 * 3 
a0e8 ed 52			sbc hl, de 
a0ea				endm 
# End of macro FORTH_DSP_PTR
a0ea cd e0 9d			call hlfromstack2 
a0ed			 
a0ed				FORTH_DSP_PTR 1     ; TOS 
a0ed 2a e8 e9			ld hl,(cli_data_sp) 
a0f0 11 03 00			ld de, 1 * 3 
a0f3 ed 52			sbc hl, de 
a0f5				endm 
# End of macro FORTH_DSP_PTR
a0f5 cd da 9d			call hlfromstack1 
a0f8			;	FORTH_DSP_VALUEHL 
a0f8			;	push hl     ; w2 
a0f8			; 
a0f8			;	FORTH_DSP_POP 
a0f8			; 
a0f8			;	FORTH_DSP_VALUEHL 
a0f8			; 
a0f8			;	FORTH_DSP_POP 
a0f8			; 
a0f8			;	pop de     ; w2	, hl = w1 
a0f8			; 
a0f8			;	ex de, hl 
a0f8			;	push de 
a0f8			; 
a0f8			;	call forth_push_numhl 
a0f8			; 
a0f8			;	pop hl 
a0f8			; 
a0f8			;	call forth_push_numhl 
a0f8				 
a0f8			 
a0f8				NEXTW 
a0f8 c3 76 9e			jp macro_next 
a0fb				endm 
# End of macro NEXTW
a0fb			.COLN: 
a0fb			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0fb 19				db WORD_SYS_CORE+OPCODE_COLN             
a0fc 87 a2			dw .SCOLN            
a0fe 02				db 1 + 1 
a0ff .. 00			db ":",0              
a101				endm 
# End of macro CWHEAD
a101			; | : ( -- )         Create new word | DONE 
a101			 
a101				if DEBUG_FORTH_WORDS_KEY 
a101					DMARK "CLN" 
a101 f5				push af  
a102 3a 16 a1			ld a, (.dmark)  
a105 32 65 ee			ld (debug_mark),a  
a108 3a 17 a1			ld a, (.dmark+1)  
a10b 32 66 ee			ld (debug_mark+1),a  
a10e 3a 18 a1			ld a, (.dmark+2)  
a111 32 67 ee			ld (debug_mark+2),a  
a114 18 03			jr .pastdmark  
a116 ..			.dmark: db "CLN"  
a119 f1			.pastdmark: pop af  
a11a			endm  
# End of macro DMARK
a11a					CALLMONITOR 
a11a cd 6f ee			call debug_vector  
a11d				endm  
# End of macro CALLMONITOR
a11d				endif 
a11d			STACKFRAME OFF $8efe $989f 
a11d				if DEBUG_STACK_IMB 
a11d					if OFF 
a11d						exx 
a11d						ld de, $8efe 
a11d						ld a, d 
a11d						ld hl, curframe 
a11d						call hexout 
a11d						ld a, e 
a11d						ld hl, curframe+2 
a11d						call hexout 
a11d						ld hl, $8efe 
a11d						push hl 
a11d						ld hl, $989f 
a11d						push hl 
a11d						exx 
a11d					endif 
a11d				endif 
a11d			endm 
# End of macro STACKFRAME
a11d			; get parser buffer length  of new word 
a11d			 
a11d			 
a11d			 
a11d				; move tok past this to start of name defintition 
a11d				; TODO get word to define 
a11d				; TODO Move past word token 
a11d				; TODO get length of string up to the ';' 
a11d			 
a11d 2a bc e5		ld hl, (os_tok_ptr) 
a120 23			inc hl 
a121 23			inc hl 
a122			 
a122 3e 3b		ld a, ';' 
a124 cd 5b 90		call strlent 
a127			 
a127 7d			ld a,l 
a128 32 ab e2		ld (os_new_parse_len), a 
a12b			 
a12b			 
a12b			if DEBUG_FORTH_UWORD 
a12b ed 5b bc e5	ld de, (os_tok_ptr) 
a12f					DMARK ":01" 
a12f f5				push af  
a130 3a 44 a1			ld a, (.dmark)  
a133 32 65 ee			ld (debug_mark),a  
a136 3a 45 a1			ld a, (.dmark+1)  
a139 32 66 ee			ld (debug_mark+1),a  
a13c 3a 46 a1			ld a, (.dmark+2)  
a13f 32 67 ee			ld (debug_mark+2),a  
a142 18 03			jr .pastdmark  
a144 ..			.dmark: db ":01"  
a147 f1			.pastdmark: pop af  
a148			endm  
# End of macro DMARK
a148			CALLMONITOR 
a148 cd 6f ee			call debug_vector  
a14b				endm  
# End of macro CALLMONITOR
a14b			endif 
a14b			 
a14b			; 
a14b			;  new word memory layout: 
a14b			;  
a14b			;    : adg 6666 ;  
a14b			; 
a14b			;    db   1     ; user defined word  
a14b 23			inc hl    
a14c			;    dw   sysdict 
a14c 23			inc hl 
a14d 23			inc hl 
a14e			;    db <word len>+1 (for null) 
a14e 23			inc hl 
a14f			;    db .... <word> 
a14f			; 
a14f			 
a14f 23			inc hl    ; some extras for the word preamble before the above 
a150 23			inc hl 
a151 23			inc hl 
a152 23			inc hl 
a153 23			inc hl 
a154 23			inc hl 
a155 23			inc hl  
a156 23			inc hl 
a157 23			inc hl 
a158 23			inc hl 
a159 23			inc hl 
a15a 23			inc hl 
a15b 23			inc hl 
a15c 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a15d			;       exec word buffer 
a15d			;	<ptr word>   
a15d 23			inc hl 
a15e 23			inc hl 
a15f			;       <word list><null term> 7F final term 
a15f			 
a15f			 
a15f			if DEBUG_FORTH_UWORD 
a15f					DMARK ":02" 
a15f f5				push af  
a160 3a 74 a1			ld a, (.dmark)  
a163 32 65 ee			ld (debug_mark),a  
a166 3a 75 a1			ld a, (.dmark+1)  
a169 32 66 ee			ld (debug_mark+1),a  
a16c 3a 76 a1			ld a, (.dmark+2)  
a16f 32 67 ee			ld (debug_mark+2),a  
a172 18 03			jr .pastdmark  
a174 ..			.dmark: db ":02"  
a177 f1			.pastdmark: pop af  
a178			endm  
# End of macro DMARK
a178			CALLMONITOR 
a178 cd 6f ee			call debug_vector  
a17b				endm  
# End of macro CALLMONITOR
a17b			endif 
a17b			 
a17b			 
a17b				; malloc the size 
a17b			 
a17b cd c5 90			call malloc 
a17e 22 ad e2			ld (os_new_malloc), hl     ; save malloc start 
a181			 
a181			;    db   1     ; user defined word  
a181 3e 01			ld a, WORD_SYS_UWORD  
a183 77				ld (hl), a 
a184			 
a184 23			inc hl    
a185			;    dw   sysdict 
a185 11 ba 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a188 73			ld (hl), e 
a189 23			inc hl 
a18a 72			ld (hl), d 
a18b 23			inc hl 
a18c			 
a18c			 
a18c			;    Setup dict word 
a18c			 
a18c 23			inc hl 
a18d 22 a7 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a190			 
a190			; 1. get length of dict word 
a190			 
a190			 
a190 2a bc e5		ld hl, (os_tok_ptr) 
a193 23			inc hl 
a194 23			inc hl    ; position to start of dict word 
a195 3e 00		ld a, 0 
a197 cd 5b 90		call strlent 
a19a			 
a19a			 
a19a 23			inc hl    ; to include null??? 
a19b			 
a19b			; write length of dict word 
a19b			 
a19b ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a19f 1b			dec de 
a1a0 eb			ex de, hl 
a1a1 73			ld (hl), e 
a1a2 eb			ex de, hl 
a1a3			 
a1a3			 
a1a3			 
a1a3			; copy  
a1a3 4d			ld c, l 
a1a4 06 00		ld b, 0 
a1a6 ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1aa 2a bc e5		ld hl, (os_tok_ptr) 
a1ad 23			inc hl 
a1ae 23			inc hl    ; position to start of dict word 
a1af			 
a1af			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a1af			 
a1af			; TODO need to convert word to upper case 
a1af			 
a1af			ucasetok:	 
a1af 7e			ld a,(hl) 
a1b0 cd 47 90		call toUpper 
a1b3 77			ld (hl),a 
a1b4 ed a0		ldi 
a1b6 f2 af a1		jp p, ucasetok 
a1b9			 
a1b9			 
a1b9			 
a1b9			; de now points to start of where the word body code should be placed 
a1b9 ed 53 a7 e2	ld (os_new_work_ptr), de 
a1bd			; hl now points to the words to throw at forthexec which needs to be copied 
a1bd 22 a5 e2		ld (os_new_src_ptr), hl 
a1c0			 
a1c0			; TODO add 'call to forthexec' 
a1c0			 
a1c0			if DEBUG_FORTH_UWORD 
a1c0 c5			push bc 
a1c1 ed 4b ad e2	ld bc, (os_new_malloc) 
a1c5					DMARK ":0x" 
a1c5 f5				push af  
a1c6 3a da a1			ld a, (.dmark)  
a1c9 32 65 ee			ld (debug_mark),a  
a1cc 3a db a1			ld a, (.dmark+1)  
a1cf 32 66 ee			ld (debug_mark+1),a  
a1d2 3a dc a1			ld a, (.dmark+2)  
a1d5 32 67 ee			ld (debug_mark+2),a  
a1d8 18 03			jr .pastdmark  
a1da ..			.dmark: db ":0x"  
a1dd f1			.pastdmark: pop af  
a1de			endm  
# End of macro DMARK
a1de			CALLMONITOR 
a1de cd 6f ee			call debug_vector  
a1e1				endm  
# End of macro CALLMONITOR
a1e1 c1			pop bc 
a1e2			endif 
a1e2			 
a1e2			 
a1e2			; create word preamble which should be: 
a1e2			 
a1e2			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1e2			 
a1e2			;    ld hl, <word code> 
a1e2			;    jp user_exec 
a1e2			;    <word code bytes> 
a1e2			 
a1e2			 
a1e2			;	inc de     ; TODO ??? or are we already past the word's null 
a1e2 eb			ex de, hl 
a1e3			 
a1e3 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1e5			 
a1e5 23			inc hl 
a1e6 22 a1 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1e9 23			inc hl 
a1ea			 
a1ea 23			inc hl 
a1eb 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1ed			 
a1ed 01 75 cd		ld bc, user_exec 
a1f0 23			inc hl 
a1f1 71			ld (hl), c     ; poke address of user_exec 
a1f2 23			inc hl 
a1f3 70			ld (hl), b     
a1f4			; 
a1f4			;	inc hl 
a1f4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1f4			; 
a1f4			; 
a1f4			;	ld bc, macro_forth_rsp_next 
a1f4			;	inc hl 
a1f4			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1f4			;	inc hl 
a1f4			;	ld (hl), b     
a1f4			; 
a1f4			;	inc hl 
a1f4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1f4			; 
a1f4			; 
a1f4			;	inc hl 
a1f4			;	ld bc, forthexec 
a1f4			;	ld (hl), c     ; poke address of forthexec 
a1f4			;	inc hl 
a1f4			;	ld (hl), b      
a1f4			; 
a1f4			;	inc hl 
a1f4			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1f4			; 
a1f4			;	ld bc, user_dict_next 
a1f4			;	inc hl 
a1f4			;	ld (hl), c     ; poke address of forthexec 
a1f4			;	inc hl 
a1f4			;	ld (hl), b      
a1f4			 
a1f4			; hl is now where we need to copy the word byte data to save this 
a1f4			 
a1f4 23			inc hl 
a1f5 22 a3 e2		ld (os_new_exec), hl 
a1f8			 
a1f8			; copy definition 
a1f8			 
a1f8 eb			ex de, hl 
a1f9			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1f9			;	inc de    ; skip the PC for this parse 
a1f9 3a ab e2		ld a, (os_new_parse_len) 
a1fc 4f			ld c, a 
a1fd 06 00		ld b, 0 
a1ff ed b0		ldir		 ; copy defintion 
a201			 
a201			 
a201			; poke the address of where the new word bytes live for forthexec 
a201			 
a201 2a a1 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a204			 
a204 ed 5b a3 e2	ld de, (os_new_exec)      
a208			 
a208 73			ld (hl), e 
a209 23			inc hl 
a20a 72			ld (hl), d 
a20b			 
a20b				; TODO copy last user dict word next link to this word 
a20b				; TODO update last user dict word to point to this word 
a20b			; 
a20b			; hl f923 de 812a ; bc 811a 
a20b			 
a20b			if DEBUG_FORTH_UWORD 
a20b c5			push bc 
a20c ed 4b ad e2	ld bc, (os_new_malloc) 
a210					DMARK ":0A" 
a210 f5				push af  
a211 3a 25 a2			ld a, (.dmark)  
a214 32 65 ee			ld (debug_mark),a  
a217 3a 26 a2			ld a, (.dmark+1)  
a21a 32 66 ee			ld (debug_mark+1),a  
a21d 3a 27 a2			ld a, (.dmark+2)  
a220 32 67 ee			ld (debug_mark+2),a  
a223 18 03			jr .pastdmark  
a225 ..			.dmark: db ":0A"  
a228 f1			.pastdmark: pop af  
a229			endm  
# End of macro DMARK
a229			CALLMONITOR 
a229 cd 6f ee			call debug_vector  
a22c				endm  
# End of macro CALLMONITOR
a22c c1			pop bc 
a22d			endif 
a22d			if DEBUG_FORTH_UWORD 
a22d c5			push bc 
a22e ed 4b ad e2	ld bc, (os_new_malloc) 
a232 03			inc bc 
a233 03			inc bc 
a234 03			inc bc 
a235 03			inc bc 
a236 03			inc bc 
a237 03			inc bc 
a238 03			inc bc 
a239 03			inc bc 
a23a			 
a23a					DMARK ":0B" 
a23a f5				push af  
a23b 3a 4f a2			ld a, (.dmark)  
a23e 32 65 ee			ld (debug_mark),a  
a241 3a 50 a2			ld a, (.dmark+1)  
a244 32 66 ee			ld (debug_mark+1),a  
a247 3a 51 a2			ld a, (.dmark+2)  
a24a 32 67 ee			ld (debug_mark+2),a  
a24d 18 03			jr .pastdmark  
a24f ..			.dmark: db ":0B"  
a252 f1			.pastdmark: pop af  
a253			endm  
# End of macro DMARK
a253			CALLMONITOR 
a253 cd 6f ee			call debug_vector  
a256				endm  
# End of macro CALLMONITOR
a256 c1			pop bc 
a257			endif 
a257			 
a257			; update word dict linked list for new word 
a257			 
a257			 
a257 2a b8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a25a 23			inc hl     ; move to next work linked list ptr 
a25b			 
a25b ed 5b ad e2	ld de, (os_new_malloc)		 ; new next word 
a25f 73			ld (hl), e 
a260 23			inc hl 
a261 72			ld (hl), d 
a262			 
a262			if DEBUG_FORTH_UWORD 
a262 ed 4b b8 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a266			endif 
a266			 
a266 ed 53 b8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a26a			 
a26a			 
a26a			if DEBUG_FORTH_UWORD 
a26a					DMARK ":0+" 
a26a f5				push af  
a26b 3a 7f a2			ld a, (.dmark)  
a26e 32 65 ee			ld (debug_mark),a  
a271 3a 80 a2			ld a, (.dmark+1)  
a274 32 66 ee			ld (debug_mark+1),a  
a277 3a 81 a2			ld a, (.dmark+2)  
a27a 32 67 ee			ld (debug_mark+2),a  
a27d 18 03			jr .pastdmark  
a27f ..			.dmark: db ":0+"  
a282 f1			.pastdmark: pop af  
a283			endm  
# End of macro DMARK
a283			CALLMONITOR 
a283 cd 6f ee			call debug_vector  
a286				endm  
# End of macro CALLMONITOR
a286			endif 
a286			 
a286			STACKFRAMECHK OFF $8efe $989f 
a286				if DEBUG_STACK_IMB 
a286					if OFF 
a286						exx 
a286						ld hl, $989f 
a286						pop de   ; $989f 
a286						call cmp16 
a286						jr nz, .spnosame 
a286						ld hl, $8efe 
a286						pop de   ; $8efe 
a286						call cmp16 
a286						jr z, .spfrsame 
a286						.spnosame: call showsperror 
a286						.spfrsame: nop 
a286						exx 
a286					endif 
a286				endif 
a286			endm 
# End of macro STACKFRAMECHK
a286			 
a286 c9			ret    ; dont process any remaining parser tokens as they form new word 
a287			 
a287			 
a287			 
a287			 
a287			;		NEXT 
a287			.SCOLN: 
a287			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a287 06			db OPCODE_SCOLN 
a288 d3 a2		dw .DROP 
a28a 02			db 2 
a28b .. 00		db ";",0           
a28d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a28d				if DEBUG_FORTH_WORDS_KEY 
a28d					DMARK "SCN" 
a28d f5				push af  
a28e 3a a2 a2			ld a, (.dmark)  
a291 32 65 ee			ld (debug_mark),a  
a294 3a a3 a2			ld a, (.dmark+1)  
a297 32 66 ee			ld (debug_mark+1),a  
a29a 3a a4 a2			ld a, (.dmark+2)  
a29d 32 67 ee			ld (debug_mark+2),a  
a2a0 18 03			jr .pastdmark  
a2a2 ..			.dmark: db "SCN"  
a2a5 f1			.pastdmark: pop af  
a2a6			endm  
# End of macro DMARK
a2a6					CALLMONITOR 
a2a6 cd 6f ee			call debug_vector  
a2a9				endm  
# End of macro CALLMONITOR
a2a9				endif 
a2a9				FORTH_RSP_TOS 
a2a9 cd 43 9a			call macro_forth_rsp_tos 
a2ac				endm 
# End of macro FORTH_RSP_TOS
a2ac e5				push hl 
a2ad				FORTH_RSP_POP 
a2ad cd 4d 9a			call macro_forth_rsp_pop 
a2b0				endm 
# End of macro FORTH_RSP_POP
a2b0 e1				pop hl 
a2b1			;		ex de,hl 
a2b1 22 bc e5			ld (os_tok_ptr),hl 
a2b4			 
a2b4			if DEBUG_FORTH_UWORD 
a2b4					DMARK "SCL" 
a2b4 f5				push af  
a2b5 3a c9 a2			ld a, (.dmark)  
a2b8 32 65 ee			ld (debug_mark),a  
a2bb 3a ca a2			ld a, (.dmark+1)  
a2be 32 66 ee			ld (debug_mark+1),a  
a2c1 3a cb a2			ld a, (.dmark+2)  
a2c4 32 67 ee			ld (debug_mark+2),a  
a2c7 18 03			jr .pastdmark  
a2c9 ..			.dmark: db "SCL"  
a2cc f1			.pastdmark: pop af  
a2cd			endm  
# End of macro DMARK
a2cd			CALLMONITOR 
a2cd cd 6f ee			call debug_vector  
a2d0				endm  
# End of macro CALLMONITOR
a2d0			endif 
a2d0				NEXTW 
a2d0 c3 76 9e			jp macro_next 
a2d3				endm 
# End of macro NEXTW
a2d3			 
a2d3			.DROP: 
a2d3			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2d3 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2d4 fe a2			dw .DUP2            
a2d6 05				db 4 + 1 
a2d7 .. 00			db "DROP",0              
a2dc				endm 
# End of macro CWHEAD
a2dc			; | DROP ( w -- )   drop the TOS item   | DONE 
a2dc				if DEBUG_FORTH_WORDS_KEY 
a2dc					DMARK "DRP" 
a2dc f5				push af  
a2dd 3a f1 a2			ld a, (.dmark)  
a2e0 32 65 ee			ld (debug_mark),a  
a2e3 3a f2 a2			ld a, (.dmark+1)  
a2e6 32 66 ee			ld (debug_mark+1),a  
a2e9 3a f3 a2			ld a, (.dmark+2)  
a2ec 32 67 ee			ld (debug_mark+2),a  
a2ef 18 03			jr .pastdmark  
a2f1 ..			.dmark: db "DRP"  
a2f4 f1			.pastdmark: pop af  
a2f5			endm  
# End of macro DMARK
a2f5					CALLMONITOR 
a2f5 cd 6f ee			call debug_vector  
a2f8				endm  
# End of macro CALLMONITOR
a2f8				endif 
a2f8				FORTH_DSP_POP 
a2f8 cd 42 9d			call macro_forth_dsp_pop 
a2fb				endm 
# End of macro FORTH_DSP_POP
a2fb				NEXTW 
a2fb c3 76 9e			jp macro_next 
a2fe				endm 
# End of macro NEXTW
a2fe			.DUP2: 
a2fe			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2fe 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2ff 43 a3			dw .DROP2            
a301 05				db 4 + 1 
a302 .. 00			db "2DUP",0              
a307				endm 
# End of macro CWHEAD
a307			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
a307				if DEBUG_FORTH_WORDS_KEY 
a307					DMARK "2DU" 
a307 f5				push af  
a308 3a 1c a3			ld a, (.dmark)  
a30b 32 65 ee			ld (debug_mark),a  
a30e 3a 1d a3			ld a, (.dmark+1)  
a311 32 66 ee			ld (debug_mark+1),a  
a314 3a 1e a3			ld a, (.dmark+2)  
a317 32 67 ee			ld (debug_mark+2),a  
a31a 18 03			jr .pastdmark  
a31c ..			.dmark: db "2DU"  
a31f f1			.pastdmark: pop af  
a320			endm  
# End of macro DMARK
a320					CALLMONITOR 
a320 cd 6f ee			call debug_vector  
a323				endm  
# End of macro CALLMONITOR
a323				endif 
a323				FORTH_DSP_VALUEHL 
a323 cd 8a 9c			call macro_dsp_valuehl 
a326				endm 
# End of macro FORTH_DSP_VALUEHL
a326 e5				push hl      ; 2 
a327			 
a327				FORTH_DSP_POP 
a327 cd 42 9d			call macro_forth_dsp_pop 
a32a				endm 
# End of macro FORTH_DSP_POP
a32a				 
a32a				FORTH_DSP_VALUEHL 
a32a cd 8a 9c			call macro_dsp_valuehl 
a32d				endm 
# End of macro FORTH_DSP_VALUEHL
a32d			;		push hl      ; 1 
a32d			 
a32d				FORTH_DSP_POP 
a32d cd 42 9d			call macro_forth_dsp_pop 
a330				endm 
# End of macro FORTH_DSP_POP
a330			 
a330			;		pop hl       ; 1 
a330 d1				pop de       ; 2 
a331			 
a331 cd 85 9a			call forth_push_numhl 
a334 eb				ex de, hl 
a335 cd 85 9a			call forth_push_numhl 
a338			 
a338				 
a338 eb				ex de, hl 
a339			 
a339 cd 85 9a			call forth_push_numhl 
a33c eb				ex de, hl 
a33d cd 85 9a			call forth_push_numhl 
a340			 
a340			 
a340				NEXTW 
a340 c3 76 9e			jp macro_next 
a343				endm 
# End of macro NEXTW
a343			.DROP2: 
a343			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a343 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a344 72 a3			dw .PICK            
a346 06				db 5 + 1 
a347 .. 00			db "2DROP",0              
a34d				endm 
# End of macro CWHEAD
a34d			; | 2DROP ( w w -- )    Double drop | DONE 
a34d				if DEBUG_FORTH_WORDS_KEY 
a34d					DMARK "2DR" 
a34d f5				push af  
a34e 3a 62 a3			ld a, (.dmark)  
a351 32 65 ee			ld (debug_mark),a  
a354 3a 63 a3			ld a, (.dmark+1)  
a357 32 66 ee			ld (debug_mark+1),a  
a35a 3a 64 a3			ld a, (.dmark+2)  
a35d 32 67 ee			ld (debug_mark+2),a  
a360 18 03			jr .pastdmark  
a362 ..			.dmark: db "2DR"  
a365 f1			.pastdmark: pop af  
a366			endm  
# End of macro DMARK
a366					CALLMONITOR 
a366 cd 6f ee			call debug_vector  
a369				endm  
# End of macro CALLMONITOR
a369				endif 
a369				FORTH_DSP_POP 
a369 cd 42 9d			call macro_forth_dsp_pop 
a36c				endm 
# End of macro FORTH_DSP_POP
a36c				FORTH_DSP_POP 
a36c cd 42 9d			call macro_forth_dsp_pop 
a36f				endm 
# End of macro FORTH_DSP_POP
a36f				NEXTW 
a36f c3 76 9e			jp macro_next 
a372				endm 
# End of macro NEXTW
a372			.PICK: 
a372			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
a372 77				db WORD_SYS_CORE+99             
a373 b1 a3			dw .SWAP2            
a375 05				db 4 + 1 
a376 .. 00			db "PICK",0              
a37b				endm 
# End of macro CWHEAD
a37b			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | TODO 
a37b				if DEBUG_FORTH_WORDS_KEY 
a37b					DMARK "PIK" 
a37b f5				push af  
a37c 3a 90 a3			ld a, (.dmark)  
a37f 32 65 ee			ld (debug_mark),a  
a382 3a 91 a3			ld a, (.dmark+1)  
a385 32 66 ee			ld (debug_mark+1),a  
a388 3a 92 a3			ld a, (.dmark+2)  
a38b 32 67 ee			ld (debug_mark+2),a  
a38e 18 03			jr .pastdmark  
a390 ..			.dmark: db "PIK"  
a393 f1			.pastdmark: pop af  
a394			endm  
# End of macro DMARK
a394					CALLMONITOR 
a394 cd 6f ee			call debug_vector  
a397				endm  
# End of macro CALLMONITOR
a397				endif 
a397			 
a397				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a397 cd 8a 9c			call macro_dsp_valuehl 
a39a				endm 
# End of macro FORTH_DSP_VALUEHL
a39a				 
a39a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a39a cd 42 9d			call macro_forth_dsp_pop 
a39d				endm 
# End of macro FORTH_DSP_POP
a39d			 
a39d				; init from TOS 
a39d 45				ld b, l 
a39e 21 e8 e9			ld hl, cli_data_sp 
a3a1			.pkl: 
a3a1 2b				dec hl 
a3a2 2b				dec hl 
a3a3 2b				dec hl 
a3a4			 
a3a4 10 fb			djnz .pkl 
a3a6			 
a3a6				 
a3a6				; TODO do type check with correct push 
a3a6			 
a3a6 23				inc hl 
a3a7				;call loadwordinhl 
a3a7 5e				ld e, (hl) 
a3a8 23				inc hl 
a3a9 56				ld d, (hl) 
a3aa eb				ex de,hl 
a3ab cd 85 9a			call forth_push_numhl 
a3ae			 
a3ae				NEXTW 
a3ae c3 76 9e			jp macro_next 
a3b1				endm 
# End of macro NEXTW
a3b1			.SWAP2: 
a3b1			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3b1 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3b2 da a3			dw .AT            
a3b4 06				db 5 + 1 
a3b5 .. 00			db "2SWAP",0              
a3bb				endm 
# End of macro CWHEAD
a3bb			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3bb				if DEBUG_FORTH_WORDS_KEY 
a3bb					DMARK "2SW" 
a3bb f5				push af  
a3bc 3a d0 a3			ld a, (.dmark)  
a3bf 32 65 ee			ld (debug_mark),a  
a3c2 3a d1 a3			ld a, (.dmark+1)  
a3c5 32 66 ee			ld (debug_mark+1),a  
a3c8 3a d2 a3			ld a, (.dmark+2)  
a3cb 32 67 ee			ld (debug_mark+2),a  
a3ce 18 03			jr .pastdmark  
a3d0 ..			.dmark: db "2SW"  
a3d3 f1			.pastdmark: pop af  
a3d4			endm  
# End of macro DMARK
a3d4					CALLMONITOR 
a3d4 cd 6f ee			call debug_vector  
a3d7				endm  
# End of macro CALLMONITOR
a3d7				endif 
a3d7			; TODO Use os stack swap memory 
a3d7				NEXTW 
a3d7 c3 76 9e			jp macro_next 
a3da				endm 
# End of macro NEXTW
a3da			.AT: 
a3da			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a3da 1f				db WORD_SYS_CORE+OPCODE_AT             
a3db 0c a4			dw .CAT            
a3dd 02				db 1 + 1 
a3de .. 00			db "@",0              
a3e0				endm 
# End of macro CWHEAD
a3e0			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a3e0			 
a3e0				if DEBUG_FORTH_WORDS_KEY 
a3e0					DMARK "AT." 
a3e0 f5				push af  
a3e1 3a f5 a3			ld a, (.dmark)  
a3e4 32 65 ee			ld (debug_mark),a  
a3e7 3a f6 a3			ld a, (.dmark+1)  
a3ea 32 66 ee			ld (debug_mark+1),a  
a3ed 3a f7 a3			ld a, (.dmark+2)  
a3f0 32 67 ee			ld (debug_mark+2),a  
a3f3 18 03			jr .pastdmark  
a3f5 ..			.dmark: db "AT."  
a3f8 f1			.pastdmark: pop af  
a3f9			endm  
# End of macro DMARK
a3f9					CALLMONITOR 
a3f9 cd 6f ee			call debug_vector  
a3fc				endm  
# End of macro CALLMONITOR
a3fc				endif 
a3fc			.getbyteat:	 
a3fc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3fc cd 8a 9c			call macro_dsp_valuehl 
a3ff				endm 
# End of macro FORTH_DSP_VALUEHL
a3ff				 
a3ff			;		push hl 
a3ff			 
a3ff				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3ff cd 42 9d			call macro_forth_dsp_pop 
a402				endm 
# End of macro FORTH_DSP_POP
a402			 
a402			;		pop hl 
a402			 
a402 7e				ld a, (hl) 
a403			 
a403 6f				ld l, a 
a404 26 00			ld h, 0 
a406 cd 85 9a			call forth_push_numhl 
a409			 
a409				NEXTW 
a409 c3 76 9e			jp macro_next 
a40c				endm 
# End of macro NEXTW
a40c			.CAT: 
a40c			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a40c 20				db WORD_SYS_CORE+OPCODE_CAT             
a40d 35 a4			dw .BANG            
a40f 03				db 2 + 1 
a410 .. 00			db "C@",0              
a413				endm 
# End of macro CWHEAD
a413			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a413				if DEBUG_FORTH_WORDS_KEY 
a413					DMARK "CAA" 
a413 f5				push af  
a414 3a 28 a4			ld a, (.dmark)  
a417 32 65 ee			ld (debug_mark),a  
a41a 3a 29 a4			ld a, (.dmark+1)  
a41d 32 66 ee			ld (debug_mark+1),a  
a420 3a 2a a4			ld a, (.dmark+2)  
a423 32 67 ee			ld (debug_mark+2),a  
a426 18 03			jr .pastdmark  
a428 ..			.dmark: db "CAA"  
a42b f1			.pastdmark: pop af  
a42c			endm  
# End of macro DMARK
a42c					CALLMONITOR 
a42c cd 6f ee			call debug_vector  
a42f				endm  
# End of macro CALLMONITOR
a42f				endif 
a42f c3 fc a3			jp .getbyteat 
a432				NEXTW 
a432 c3 76 9e			jp macro_next 
a435				endm 
# End of macro NEXTW
a435			.BANG: 
a435			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a435 21				db WORD_SYS_CORE+OPCODE_BANG             
a436 6b a4			dw .CBANG            
a438 02				db 1 + 1 
a439 .. 00			db "!",0              
a43b				endm 
# End of macro CWHEAD
a43b			; | ! ( x w -- ) Store x at address w      | DONE 
a43b				if DEBUG_FORTH_WORDS_KEY 
a43b					DMARK "BNG" 
a43b f5				push af  
a43c 3a 50 a4			ld a, (.dmark)  
a43f 32 65 ee			ld (debug_mark),a  
a442 3a 51 a4			ld a, (.dmark+1)  
a445 32 66 ee			ld (debug_mark+1),a  
a448 3a 52 a4			ld a, (.dmark+2)  
a44b 32 67 ee			ld (debug_mark+2),a  
a44e 18 03			jr .pastdmark  
a450 ..			.dmark: db "BNG"  
a453 f1			.pastdmark: pop af  
a454			endm  
# End of macro DMARK
a454					CALLMONITOR 
a454 cd 6f ee			call debug_vector  
a457				endm  
# End of macro CALLMONITOR
a457				endif 
a457			 
a457			.storebyteat:		 
a457				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a457 cd 8a 9c			call macro_dsp_valuehl 
a45a				endm 
# End of macro FORTH_DSP_VALUEHL
a45a				 
a45a e5				push hl 
a45b			 
a45b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a45b cd 42 9d			call macro_forth_dsp_pop 
a45e				endm 
# End of macro FORTH_DSP_POP
a45e			 
a45e				; get byte to poke 
a45e			 
a45e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a45e cd 8a 9c			call macro_dsp_valuehl 
a461				endm 
# End of macro FORTH_DSP_VALUEHL
a461 e5				push hl 
a462			 
a462			 
a462				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a462 cd 42 9d			call macro_forth_dsp_pop 
a465				endm 
# End of macro FORTH_DSP_POP
a465			 
a465			 
a465 d1				pop de 
a466 e1				pop hl 
a467			 
a467 73				ld (hl),e 
a468			 
a468			 
a468				NEXTW 
a468 c3 76 9e			jp macro_next 
a46b				endm 
# End of macro NEXTW
a46b			.CBANG: 
a46b			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a46b 22				db WORD_SYS_CORE+OPCODE_CBANG             
a46c 94 a4			dw .SCALL            
a46e 03				db 2 + 1 
a46f .. 00			db "C!",0              
a472				endm 
# End of macro CWHEAD
a472			; | C!  ( x w -- ) Store x at address w  | DONE 
a472				if DEBUG_FORTH_WORDS_KEY 
a472					DMARK "CBA" 
a472 f5				push af  
a473 3a 87 a4			ld a, (.dmark)  
a476 32 65 ee			ld (debug_mark),a  
a479 3a 88 a4			ld a, (.dmark+1)  
a47c 32 66 ee			ld (debug_mark+1),a  
a47f 3a 89 a4			ld a, (.dmark+2)  
a482 32 67 ee			ld (debug_mark+2),a  
a485 18 03			jr .pastdmark  
a487 ..			.dmark: db "CBA"  
a48a f1			.pastdmark: pop af  
a48b			endm  
# End of macro DMARK
a48b					CALLMONITOR 
a48b cd 6f ee			call debug_vector  
a48e				endm  
# End of macro CALLMONITOR
a48e				endif 
a48e c3 57 a4			jp .storebyteat 
a491				NEXTW 
a491 c3 76 9e			jp macro_next 
a494				endm 
# End of macro NEXTW
a494			.SCALL: 
a494			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a494 23				db WORD_SYS_CORE+OPCODE_SCALL             
a495 c8 a4			dw .DEPTH            
a497 05				db 4 + 1 
a498 .. 00			db "CALL",0              
a49d				endm 
# End of macro CWHEAD
a49d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a49d				if DEBUG_FORTH_WORDS_KEY 
a49d					DMARK "CLL" 
a49d f5				push af  
a49e 3a b2 a4			ld a, (.dmark)  
a4a1 32 65 ee			ld (debug_mark),a  
a4a4 3a b3 a4			ld a, (.dmark+1)  
a4a7 32 66 ee			ld (debug_mark+1),a  
a4aa 3a b4 a4			ld a, (.dmark+2)  
a4ad 32 67 ee			ld (debug_mark+2),a  
a4b0 18 03			jr .pastdmark  
a4b2 ..			.dmark: db "CLL"  
a4b5 f1			.pastdmark: pop af  
a4b6			endm  
# End of macro DMARK
a4b6					CALLMONITOR 
a4b6 cd 6f ee			call debug_vector  
a4b9				endm  
# End of macro CALLMONITOR
a4b9				endif 
a4b9			 
a4b9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4b9 cd 8a 9c			call macro_dsp_valuehl 
a4bc				endm 
# End of macro FORTH_DSP_VALUEHL
a4bc			 
a4bc			;		push hl 
a4bc			 
a4bc				; destroy value TOS 
a4bc			 
a4bc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4bc cd 42 9d			call macro_forth_dsp_pop 
a4bf				endm 
# End of macro FORTH_DSP_POP
a4bf			 
a4bf					 
a4bf			;		pop hl 
a4bf			 
a4bf				; how to do a call with hl???? save SP? 
a4bf cd 1a 9e			call forth_call_hl 
a4c2			 
a4c2			 
a4c2				; TODO push value back onto stack for another op etc 
a4c2			 
a4c2 cd 85 9a			call forth_push_numhl 
a4c5				NEXTW 
a4c5 c3 76 9e			jp macro_next 
a4c8				endm 
# End of macro NEXTW
a4c8			.DEPTH: 
a4c8			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a4c8 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a4c9 05 a5			dw .OVER            
a4cb 06				db 5 + 1 
a4cc .. 00			db "DEPTH",0              
a4d2				endm 
# End of macro CWHEAD
a4d2			; | DEPTH ( -- u ) Push count of stack | DONE 
a4d2				; take current TOS and remove from base value div by two to get count 
a4d2				if DEBUG_FORTH_WORDS_KEY 
a4d2					DMARK "DEP" 
a4d2 f5				push af  
a4d3 3a e7 a4			ld a, (.dmark)  
a4d6 32 65 ee			ld (debug_mark),a  
a4d9 3a e8 a4			ld a, (.dmark+1)  
a4dc 32 66 ee			ld (debug_mark+1),a  
a4df 3a e9 a4			ld a, (.dmark+2)  
a4e2 32 67 ee			ld (debug_mark+2),a  
a4e5 18 03			jr .pastdmark  
a4e7 ..			.dmark: db "DEP"  
a4ea f1			.pastdmark: pop af  
a4eb			endm  
# End of macro DMARK
a4eb					CALLMONITOR 
a4eb cd 6f ee			call debug_vector  
a4ee				endm  
# End of macro CALLMONITOR
a4ee				endif 
a4ee			 
a4ee			 
a4ee 2a e8 e9		ld hl, (cli_data_sp) 
a4f1 11 22 e8		ld de, cli_data_stack 
a4f4 ed 52		sbc hl,de 
a4f6			 
a4f6			; div by size of stack item 
a4f6			 
a4f6 5d			ld e,l 
a4f7 0e 03		ld c, 3 
a4f9 cd 7a 8c		call Div8 
a4fc			 
a4fc 6f			ld l,a 
a4fd 26 00		ld h,0 
a4ff			 
a4ff			;srl h 
a4ff			;rr l 
a4ff			 
a4ff cd 85 9a			call forth_push_numhl 
a502				NEXTW 
a502 c3 76 9e			jp macro_next 
a505				endm 
# End of macro NEXTW
a505			.OVER: 
a505			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a505 42				db WORD_SYS_CORE+46             
a506 4c a5			dw .PAUSE            
a508 05				db 4 + 1 
a509 .. 00			db "OVER",0              
a50e				endm 
# End of macro CWHEAD
a50e			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | TOFIX 
a50e				if DEBUG_FORTH_WORDS_KEY 
a50e					DMARK "OVR" 
a50e f5				push af  
a50f 3a 23 a5			ld a, (.dmark)  
a512 32 65 ee			ld (debug_mark),a  
a515 3a 24 a5			ld a, (.dmark+1)  
a518 32 66 ee			ld (debug_mark+1),a  
a51b 3a 25 a5			ld a, (.dmark+2)  
a51e 32 67 ee			ld (debug_mark+2),a  
a521 18 03			jr .pastdmark  
a523 ..			.dmark: db "OVR"  
a526 f1			.pastdmark: pop af  
a527			endm  
# End of macro DMARK
a527					CALLMONITOR 
a527 cd 6f ee			call debug_vector  
a52a				endm  
# End of macro CALLMONITOR
a52a				endif 
a52a			 
a52a			; TODO Use os stack swap memory 
a52a			 
a52a				; work out what type we are looking at 
a52a			 
a52a				FORTH_DSP_PTR 1 
a52a 2a e8 e9			ld hl,(cli_data_sp) 
a52d 11 03 00			ld de, 1 * 3 
a530 ed 52			sbc hl, de 
a532				endm 
# End of macro FORTH_DSP_PTR
a532			 
a532 7e				ld a, (hl) 
a533				 
a533 f5				push af 
a534				; whatever the type lets get the pointer or word 
a534 23				inc hl 
a535			;; 
a535			 
a535				; type check now to decide on how to push  
a535			 
a535 cd f8 9d			call loadwordinhl 
a538 f1				pop af 
a539 fe 01			cp DS_TYPE_STR 
a53b 28 06			jr z, .ovstr 
a53d			 
a53d				; we have a numeric so load the word and push 
a53d			;	ld e, (hl) 
a53d			;	inc hl 
a53d			;	ld d, (hl) 
a53d			;	ex de, hl 
a53d cd 85 9a			call forth_push_numhl 
a540				NEXTW 
a540 c3 76 9e			jp macro_next 
a543				endm 
# End of macro NEXTW
a543			 
a543			.ovstr: 
a543				; ok, a string so get the pointer and push as a string 
a543			 
a543			;	call loadwordinhl 
a543 cd f3 9a			call forth_push_str 
a546				NEXTW 
a546 c3 76 9e			jp macro_next 
a549				endm 
# End of macro NEXTW
a549			 
a549			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a549			;	push hl    ; n2 
a549			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a549			; 
a549			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a549			;	push hl    ; n1 
a549			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a549			; 
a549			;	pop de     ; n1 
a549			;	pop hl     ; n2 
a549			; 
a549			;	push de 
a549			;	push hl 
a549			;	push de 
a549			 
a549				; push back  
a549			 
a549			;	pop hl 
a549			;	call forth_push_numhl 
a549			;	pop hl 
a549			;	call forth_push_numhl 
a549			;	pop hl 
a549			;	call forth_push_numhl 
a549				NEXTW 
a549 c3 76 9e			jp macro_next 
a54c				endm 
# End of macro NEXTW
a54c			 
a54c			.PAUSE: 
a54c			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a54c 43				db WORD_SYS_CORE+47             
a54d 81 a5			dw .PAUSES            
a54f 08				db 7 + 1 
a550 .. 00			db "PAUSEMS",0              
a558				endm 
# End of macro CWHEAD
a558			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a558				if DEBUG_FORTH_WORDS_KEY 
a558					DMARK "PMS" 
a558 f5				push af  
a559 3a 6d a5			ld a, (.dmark)  
a55c 32 65 ee			ld (debug_mark),a  
a55f 3a 6e a5			ld a, (.dmark+1)  
a562 32 66 ee			ld (debug_mark+1),a  
a565 3a 6f a5			ld a, (.dmark+2)  
a568 32 67 ee			ld (debug_mark+2),a  
a56b 18 03			jr .pastdmark  
a56d ..			.dmark: db "PMS"  
a570 f1			.pastdmark: pop af  
a571			endm  
# End of macro DMARK
a571					CALLMONITOR 
a571 cd 6f ee			call debug_vector  
a574				endm  
# End of macro CALLMONITOR
a574				endif 
a574				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a574 cd 8a 9c			call macro_dsp_valuehl 
a577				endm 
# End of macro FORTH_DSP_VALUEHL
a577			;		push hl    ; n2 
a577				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a577 cd 42 9d			call macro_forth_dsp_pop 
a57a				endm 
# End of macro FORTH_DSP_POP
a57a			;		pop hl 
a57a			 
a57a 7d				ld a, l 
a57b cd e5 89			call aDelayInMS 
a57e			       NEXTW 
a57e c3 76 9e			jp macro_next 
a581				endm 
# End of macro NEXTW
a581			.PAUSES:  
a581			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a581 44				db WORD_SYS_CORE+48             
a582 f0 a5			dw .ROT            
a584 06				db 5 + 1 
a585 .. 00			db "PAUSE",0              
a58b				endm 
# End of macro CWHEAD
a58b			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a58b				if DEBUG_FORTH_WORDS_KEY 
a58b					DMARK "PAU" 
a58b f5				push af  
a58c 3a a0 a5			ld a, (.dmark)  
a58f 32 65 ee			ld (debug_mark),a  
a592 3a a1 a5			ld a, (.dmark+1)  
a595 32 66 ee			ld (debug_mark+1),a  
a598 3a a2 a5			ld a, (.dmark+2)  
a59b 32 67 ee			ld (debug_mark+2),a  
a59e 18 03			jr .pastdmark  
a5a0 ..			.dmark: db "PAU"  
a5a3 f1			.pastdmark: pop af  
a5a4			endm  
# End of macro DMARK
a5a4					CALLMONITOR 
a5a4 cd 6f ee			call debug_vector  
a5a7				endm  
# End of macro CALLMONITOR
a5a7				endif 
a5a7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5a7 cd 8a 9c			call macro_dsp_valuehl 
a5aa				endm 
# End of macro FORTH_DSP_VALUEHL
a5aa			;		push hl    ; n2 
a5aa				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5aa cd 42 9d			call macro_forth_dsp_pop 
a5ad				endm 
# End of macro FORTH_DSP_POP
a5ad			;		pop hl 
a5ad 45				ld b, l 
a5ae				if DEBUG_FORTH_WORDS 
a5ae					DMARK "PAU" 
a5ae f5				push af  
a5af 3a c3 a5			ld a, (.dmark)  
a5b2 32 65 ee			ld (debug_mark),a  
a5b5 3a c4 a5			ld a, (.dmark+1)  
a5b8 32 66 ee			ld (debug_mark+1),a  
a5bb 3a c5 a5			ld a, (.dmark+2)  
a5be 32 67 ee			ld (debug_mark+2),a  
a5c1 18 03			jr .pastdmark  
a5c3 ..			.dmark: db "PAU"  
a5c6 f1			.pastdmark: pop af  
a5c7			endm  
# End of macro DMARK
a5c7					CALLMONITOR 
a5c7 cd 6f ee			call debug_vector  
a5ca				endm  
# End of macro CALLMONITOR
a5ca				endif 
a5ca c5			.pauses1:	push bc 
a5cb cd 00 8a			call delay1s 
a5ce c1				pop bc 
a5cf				if DEBUG_FORTH_WORDS 
a5cf					DMARK "PA1" 
a5cf f5				push af  
a5d0 3a e4 a5			ld a, (.dmark)  
a5d3 32 65 ee			ld (debug_mark),a  
a5d6 3a e5 a5			ld a, (.dmark+1)  
a5d9 32 66 ee			ld (debug_mark+1),a  
a5dc 3a e6 a5			ld a, (.dmark+2)  
a5df 32 67 ee			ld (debug_mark+2),a  
a5e2 18 03			jr .pastdmark  
a5e4 ..			.dmark: db "PA1"  
a5e7 f1			.pastdmark: pop af  
a5e8			endm  
# End of macro DMARK
a5e8					CALLMONITOR 
a5e8 cd 6f ee			call debug_vector  
a5eb				endm  
# End of macro CALLMONITOR
a5eb				endif 
a5eb 10 dd			djnz .pauses1 
a5ed			 
a5ed			       NEXTW 
a5ed c3 76 9e			jp macro_next 
a5f0				endm 
# End of macro NEXTW
a5f0			.ROT: 
a5f0			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a5f0 45				db WORD_SYS_CORE+49             
a5f1 59 a6			dw .UWORDS            
a5f3 04				db 3 + 1 
a5f4 .. 00			db "ROT",0              
a5f8				endm 
# End of macro CWHEAD
a5f8			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | TOFIX 
a5f8				if DEBUG_FORTH_WORDS_KEY 
a5f8					DMARK "ROT" 
a5f8 f5				push af  
a5f9 3a 0d a6			ld a, (.dmark)  
a5fc 32 65 ee			ld (debug_mark),a  
a5ff 3a 0e a6			ld a, (.dmark+1)  
a602 32 66 ee			ld (debug_mark+1),a  
a605 3a 0f a6			ld a, (.dmark+2)  
a608 32 67 ee			ld (debug_mark+2),a  
a60b 18 03			jr .pastdmark  
a60d ..			.dmark: db "ROT"  
a610 f1			.pastdmark: pop af  
a611			endm  
# End of macro DMARK
a611					CALLMONITOR 
a611 cd 6f ee			call debug_vector  
a614				endm  
# End of macro CALLMONITOR
a614				endif 
a614			 
a614			; DONE Use os stack swap memory 
a614			 
a614				FORTH_DSP_PTR 0     ; u3 
a614 2a e8 e9			ld hl,(cli_data_sp) 
a617 11 00 00			ld de, 0 * 3 
a61a ed 52			sbc hl, de 
a61c				endm 
# End of macro FORTH_DSP_PTR
a61c cd c2 9d			call hltostack1     
a61f			  
a61f				FORTH_DSP_PTR 1     ; u2 
a61f 2a e8 e9			ld hl,(cli_data_sp) 
a622 11 03 00			ld de, 1 * 3 
a625 ed 52			sbc hl, de 
a627				endm 
# End of macro FORTH_DSP_PTR
a627 cd c8 9d			call hltostack2      
a62a			 
a62a				FORTH_DSP_PTR 2     ; u1 
a62a 2a e8 e9			ld hl,(cli_data_sp) 
a62d 11 06 00			ld de, 2 * 3 
a630 ed 52			sbc hl, de 
a632				endm 
# End of macro FORTH_DSP_PTR
a632 cd ce 9d			call hltostack3 
a635			 
a635			 
a635				FORTH_DSP_PTR 0     ;  
a635 2a e8 e9			ld hl,(cli_data_sp) 
a638 11 00 00			ld de, 0 * 3 
a63b ed 52			sbc hl, de 
a63d				endm 
# End of macro FORTH_DSP_PTR
a63d cd e6 9d			call hlfromstack3 
a640			 
a640				FORTH_DSP_PTR 1     ; TOS 
a640 2a e8 e9			ld hl,(cli_data_sp) 
a643 11 03 00			ld de, 1 * 3 
a646 ed 52			sbc hl, de 
a648				endm 
# End of macro FORTH_DSP_PTR
a648 cd da 9d			call hlfromstack1 
a64b			 
a64b				FORTH_DSP_PTR 2     ; TOS 
a64b 2a e8 e9			ld hl,(cli_data_sp) 
a64e 11 06 00			ld de, 2 * 3 
a651 ed 52			sbc hl, de 
a653				endm 
# End of macro FORTH_DSP_PTR
a653 cd e0 9d			call hlfromstack2 
a656			 
a656			 
a656			;	FORTH_DSP_VALUEHL 
a656			;	push hl    ; u3  
a656			; 
a656			;	FORTH_DSP_POP 
a656			; 
a656			;	FORTH_DSP_VALUEHL 
a656			;	push hl     ; u2 
a656			; 
a656			;	FORTH_DSP_POP 
a656			; 
a656			;	FORTH_DSP_VALUEHL 
a656			;	push hl     ; u1 
a656			; 
a656			;	FORTH_DSP_POP 
a656			; 
a656			;	pop bc      ; u1 
a656			;	pop hl      ; u2 
a656			;	pop de      ; u3 
a656			; 
a656			; 
a656			;	push bc 
a656			;	push de 
a656			;	push hl 
a656			; 
a656			; 
a656			;	pop hl 
a656			;	call forth_push_numhl 
a656			; 
a656			;	pop hl 
a656			;	call forth_push_numhl 
a656			; 
a656			;	pop hl 
a656			;	call forth_push_numhl 
a656				 
a656			 
a656			 
a656			 
a656			 
a656			 
a656			       NEXTW 
a656 c3 76 9e			jp macro_next 
a659				endm 
# End of macro NEXTW
a659			 
a659			.UWORDS: 
a659			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a659 50				db WORD_SYS_CORE+60             
a65a 1b a7			dw .BP            
a65c 07				db 6 + 1 
a65d .. 00			db "UWORDS",0              
a664				endm 
# End of macro CWHEAD
a664			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a664			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a664			; | | Following the count are the individual words. 
a664			; | | 
a664			; | | e.g. UWORDS 
a664			; | | BOX DIRLIST 2 
a664			; | |  
a664			; | | Can be used to save the words to storage via: 
a664			; | | UWORDS $01 DO $01 APPEND LOOP 
a664			if DEBUG_FORTH_WORDS_KEY 
a664				DMARK "UWR" 
a664 f5				push af  
a665 3a 79 a6			ld a, (.dmark)  
a668 32 65 ee			ld (debug_mark),a  
a66b 3a 7a a6			ld a, (.dmark+1)  
a66e 32 66 ee			ld (debug_mark+1),a  
a671 3a 7b a6			ld a, (.dmark+2)  
a674 32 67 ee			ld (debug_mark+2),a  
a677 18 03			jr .pastdmark  
a679 ..			.dmark: db "UWR"  
a67c f1			.pastdmark: pop af  
a67d			endm  
# End of macro DMARK
a67d				CALLMONITOR 
a67d cd 6f ee			call debug_vector  
a680				endm  
# End of macro CALLMONITOR
a680			endif 
a680 21 97 df			ld hl, baseram 
a683				;ld hl, baseusermem 
a683 01 00 00			ld bc, 0    ; start a counter 
a686			 
a686			; skip dict stub 
a686			 
a686 cd b3 9f			call forth_tok_next 
a689			 
a689			 
a689			; while we have words to look for 
a689			 
a689 7e			.douscan:	ld a, (hl)      
a68a			if DEBUG_FORTH_WORDS 
a68a				DMARK "UWs" 
a68a f5				push af  
a68b 3a 9f a6			ld a, (.dmark)  
a68e 32 65 ee			ld (debug_mark),a  
a691 3a a0 a6			ld a, (.dmark+1)  
a694 32 66 ee			ld (debug_mark+1),a  
a697 3a a1 a6			ld a, (.dmark+2)  
a69a 32 67 ee			ld (debug_mark+2),a  
a69d 18 03			jr .pastdmark  
a69f ..			.dmark: db "UWs"  
a6a2 f1			.pastdmark: pop af  
a6a3			endm  
# End of macro DMARK
a6a3				CALLMONITOR 
a6a3 cd 6f ee			call debug_vector  
a6a6				endm  
# End of macro CALLMONITOR
a6a6			endif 
a6a6 fe 00			cp WORD_SYS_END 
a6a8 28 4d			jr z, .udone 
a6aa fe 01			cp WORD_SYS_UWORD 
a6ac 20 44			jr nz, .nuword 
a6ae			 
a6ae			if DEBUG_FORTH_WORDS 
a6ae				DMARK "UWu" 
a6ae f5				push af  
a6af 3a c3 a6			ld a, (.dmark)  
a6b2 32 65 ee			ld (debug_mark),a  
a6b5 3a c4 a6			ld a, (.dmark+1)  
a6b8 32 66 ee			ld (debug_mark+1),a  
a6bb 3a c5 a6			ld a, (.dmark+2)  
a6be 32 67 ee			ld (debug_mark+2),a  
a6c1 18 03			jr .pastdmark  
a6c3 ..			.dmark: db "UWu"  
a6c6 f1			.pastdmark: pop af  
a6c7			endm  
# End of macro DMARK
a6c7				CALLMONITOR 
a6c7 cd 6f ee			call debug_vector  
a6ca				endm  
# End of macro CALLMONITOR
a6ca			endif 
a6ca				; we have a uword so push its name to the stack 
a6ca			 
a6ca e5				push hl  ; save so we can move to next dict block 
a6cb			 
a6cb				; skip opcode 
a6cb 23				inc hl  
a6cc				; skip next ptr 
a6cc 23				inc hl  
a6cd 23				inc hl 
a6ce				; skip len 
a6ce 23				inc hl 
a6cf			if DEBUG_FORTH_WORDS 
a6cf				DMARK "UWt" 
a6cf f5				push af  
a6d0 3a e4 a6			ld a, (.dmark)  
a6d3 32 65 ee			ld (debug_mark),a  
a6d6 3a e5 a6			ld a, (.dmark+1)  
a6d9 32 66 ee			ld (debug_mark+1),a  
a6dc 3a e6 a6			ld a, (.dmark+2)  
a6df 32 67 ee			ld (debug_mark+2),a  
a6e2 18 03			jr .pastdmark  
a6e4 ..			.dmark: db "UWt"  
a6e7 f1			.pastdmark: pop af  
a6e8			endm  
# End of macro DMARK
a6e8				CALLMONITOR 
a6e8 cd 6f ee			call debug_vector  
a6eb				endm  
# End of macro CALLMONITOR
a6eb			endif 
a6eb 03				inc bc 
a6ec			 
a6ec c5				push bc 
a6ed cd f3 9a			call forth_push_str 
a6f0 c1				pop bc 
a6f1			 
a6f1 e1				pop hl 	 
a6f2			 
a6f2 cd b3 9f		.nuword:	call forth_tok_next 
a6f5 18 92			jr .douscan  
a6f7			 
a6f7			.udone:		 ; push count of uwords found 
a6f7 c5				push bc 
a6f8 e1				pop hl 
a6f9			 
a6f9			if DEBUG_FORTH_WORDS 
a6f9				DMARK "UWc" 
a6f9 f5				push af  
a6fa 3a 0e a7			ld a, (.dmark)  
a6fd 32 65 ee			ld (debug_mark),a  
a700 3a 0f a7			ld a, (.dmark+1)  
a703 32 66 ee			ld (debug_mark+1),a  
a706 3a 10 a7			ld a, (.dmark+2)  
a709 32 67 ee			ld (debug_mark+2),a  
a70c 18 03			jr .pastdmark  
a70e ..			.dmark: db "UWc"  
a711 f1			.pastdmark: pop af  
a712			endm  
# End of macro DMARK
a712				CALLMONITOR 
a712 cd 6f ee			call debug_vector  
a715				endm  
# End of macro CALLMONITOR
a715			endif 
a715 cd 85 9a			call forth_push_numhl 
a718			 
a718			 
a718			       NEXTW 
a718 c3 76 9e			jp macro_next 
a71b				endm 
# End of macro NEXTW
a71b			 
a71b			.BP: 
a71b			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a71b 54				db WORD_SYS_CORE+64             
a71c 55 a7			dw .MONITOR            
a71e 03				db 2 + 1 
a71f .. 00			db "BP",0              
a722				endm 
# End of macro CWHEAD
a722			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a722			; | | $00 Will enable the break points within specific code paths 
a722			; | | $01 Will disable break points 
a722			; | |  
a722			; | | By default break points are off. Either the above can be used to enable them 
a722			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a722			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a722			; | | can disable break points. Exiting will then continue boot process. 
a722				; get byte count 
a722				if DEBUG_FORTH_WORDS_KEY 
a722					DMARK "BP." 
a722 f5				push af  
a723 3a 37 a7			ld a, (.dmark)  
a726 32 65 ee			ld (debug_mark),a  
a729 3a 38 a7			ld a, (.dmark+1)  
a72c 32 66 ee			ld (debug_mark+1),a  
a72f 3a 39 a7			ld a, (.dmark+2)  
a732 32 67 ee			ld (debug_mark+2),a  
a735 18 03			jr .pastdmark  
a737 ..			.dmark: db "BP."  
a73a f1			.pastdmark: pop af  
a73b			endm  
# End of macro DMARK
a73b					CALLMONITOR 
a73b cd 6f ee			call debug_vector  
a73e				endm  
# End of macro CALLMONITOR
a73e				endif 
a73e			 
a73e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a73e cd 8a 9c			call macro_dsp_valuehl 
a741				endm 
# End of macro FORTH_DSP_VALUEHL
a741			 
a741			;		push hl 
a741			 
a741				; destroy value TOS 
a741			 
a741				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a741 cd 42 9d			call macro_forth_dsp_pop 
a744				endm 
# End of macro FORTH_DSP_POP
a744			 
a744			;		pop hl 
a744			 
a744 3e 00			ld a,0 
a746 bd				cp l 
a747 28 06			jr z, .bpset 
a749			;		ld a, '*' 
a749 cd 00 94			call bp_off 
a74c				NEXTW 
a74c c3 76 9e			jp macro_next 
a74f				endm 
# End of macro NEXTW
a74f			 
a74f			.bpset:	 
a74f				;	ld (os_view_disable), a 
a74f cd f4 93			call bp_on 
a752			 
a752			 
a752				NEXTW 
a752 c3 76 9e			jp macro_next 
a755				endm 
# End of macro NEXTW
a755			 
a755			 
a755			.MONITOR: 
a755			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a755 55				db WORD_SYS_CORE+65             
a756 86 a7			dw .MALLOC            
a758 08				db 7 + 1 
a759 .. 00			db "MONITOR",0              
a761				endm 
# End of macro CWHEAD
a761			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a761			; | | At start the current various registers will be displayed with contents. 
a761			; | | Top right corner will show the most recent debug marker seen. 
a761			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a761			; | | and the return stack pointer (RSP). 
a761			; | | Pressing: 
a761			; | |    1 - Initial screen 
a761			; | |    2 - Display a data dump of HL 
a761			; | |    3 - Display a data dump of DE 
a761			; | |    4 - Display a data dump of BC 
a761			; | |    5 - Display a data dump of HL 
a761			; | |    6 - Display a data dump of DSP 
a761			; | |    7 - Display a data dump of RSP 
a761			; | |    8 - Display a data dump of what is at DSP 
a761			; | |    9 - Display a data dump of what is at RSP 
a761			; | |    0 - Exit monitor and continue running. This will also enable break points 
a761			; | |    * - Disable break points 
a761			; | |    # - Enter traditional monitor mode 
a761			; | | 
a761			; | | Monitor Mode 
a761			; | | ------------ 
a761			; | | A prompt of '>' will be shown for various commands: 
a761			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a761			; | |    C - Continue display a data dump from the last set address 
a761			; | |    M xxxx - Set start of memory edit at address xx 
a761			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a761			; | |    G xxxx - Exec code at specific address 
a761			; | |    Q - Return to previous 
a761				if DEBUG_FORTH_WORDS_KEY 
a761					DMARK "MON" 
a761 f5				push af  
a762 3a 76 a7			ld a, (.dmark)  
a765 32 65 ee			ld (debug_mark),a  
a768 3a 77 a7			ld a, (.dmark+1)  
a76b 32 66 ee			ld (debug_mark+1),a  
a76e 3a 78 a7			ld a, (.dmark+2)  
a771 32 67 ee			ld (debug_mark+2),a  
a774 18 03			jr .pastdmark  
a776 ..			.dmark: db "MON"  
a779 f1			.pastdmark: pop af  
a77a			endm  
# End of macro DMARK
a77a					CALLMONITOR 
a77a cd 6f ee			call debug_vector  
a77d				endm  
# End of macro CALLMONITOR
a77d				endif 
a77d			;		ld a, 0 
a77d			;		ld (os_view_disable), a 
a77d cd f4 93			call bp_on 
a780			 
a780				CALLMONITOR 
a780 cd 6f ee			call debug_vector  
a783				endm  
# End of macro CALLMONITOR
a783			 
a783			;	call monitor 
a783			 
a783				NEXTW 
a783 c3 76 9e			jp macro_next 
a786				endm 
# End of macro NEXTW
a786			 
a786			 
a786			.MALLOC: 
a786			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a786 56				db WORD_SYS_CORE+66             
a787 af a7			dw .MALLOC2            
a789 06				db 5 + 1 
a78a .. 00			db "ALLOT",0              
a790				endm 
# End of macro CWHEAD
a790			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a790				if DEBUG_FORTH_WORDS_KEY 
a790					DMARK "ALL" 
a790 f5				push af  
a791 3a a5 a7			ld a, (.dmark)  
a794 32 65 ee			ld (debug_mark),a  
a797 3a a6 a7			ld a, (.dmark+1)  
a79a 32 66 ee			ld (debug_mark+1),a  
a79d 3a a7 a7			ld a, (.dmark+2)  
a7a0 32 67 ee			ld (debug_mark+2),a  
a7a3 18 03			jr .pastdmark  
a7a5 ..			.dmark: db "ALL"  
a7a8 f1			.pastdmark: pop af  
a7a9			endm  
# End of macro DMARK
a7a9					CALLMONITOR 
a7a9 cd 6f ee			call debug_vector  
a7ac				endm  
# End of macro CALLMONITOR
a7ac				endif 
a7ac c3 d6 a7			jp .mallocc 
a7af			.MALLOC2: 
a7af			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7af 56				db WORD_SYS_CORE+66             
a7b0 ed a7			dw .FREE            
a7b2 07				db 6 + 1 
a7b3 .. 00			db "MALLOC",0              
a7ba				endm 
# End of macro CWHEAD
a7ba			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7ba				; get byte count 
a7ba				if DEBUG_FORTH_WORDS_KEY 
a7ba					DMARK "MAL" 
a7ba f5				push af  
a7bb 3a cf a7			ld a, (.dmark)  
a7be 32 65 ee			ld (debug_mark),a  
a7c1 3a d0 a7			ld a, (.dmark+1)  
a7c4 32 66 ee			ld (debug_mark+1),a  
a7c7 3a d1 a7			ld a, (.dmark+2)  
a7ca 32 67 ee			ld (debug_mark+2),a  
a7cd 18 03			jr .pastdmark  
a7cf ..			.dmark: db "MAL"  
a7d2 f1			.pastdmark: pop af  
a7d3			endm  
# End of macro DMARK
a7d3					CALLMONITOR 
a7d3 cd 6f ee			call debug_vector  
a7d6				endm  
# End of macro CALLMONITOR
a7d6				endif 
a7d6			.mallocc: 
a7d6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7d6 cd 8a 9c			call macro_dsp_valuehl 
a7d9				endm 
# End of macro FORTH_DSP_VALUEHL
a7d9			 
a7d9			;		push hl 
a7d9			 
a7d9				; destroy value TOS 
a7d9			 
a7d9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7d9 cd 42 9d			call macro_forth_dsp_pop 
a7dc				endm 
# End of macro FORTH_DSP_POP
a7dc			 
a7dc			;		pop hl 
a7dc cd c5 90			call malloc 
a7df			if DEBUG_FORTH_MALLOC_GUARD 
a7df f5				push af 
a7e0 cd 13 8d			call ishlzero 
a7e3			;		ld a, l 
a7e3			;		add h 
a7e3			;		cp 0 
a7e3 f1				pop af 
a7e4				 
a7e4 cc 47 ce			call z,malloc_error 
a7e7			endif 
a7e7			 
a7e7 cd 85 9a			call forth_push_numhl 
a7ea				NEXTW 
a7ea c3 76 9e			jp macro_next 
a7ed				endm 
# End of macro NEXTW
a7ed			 
a7ed			.FREE: 
a7ed			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a7ed 57				db WORD_SYS_CORE+67             
a7ee 1e a8			dw .LIST            
a7f0 05				db 4 + 1 
a7f1 .. 00			db "FREE",0              
a7f6				endm 
# End of macro CWHEAD
a7f6			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a7f6				if DEBUG_FORTH_WORDS_KEY 
a7f6					DMARK "FRE" 
a7f6 f5				push af  
a7f7 3a 0b a8			ld a, (.dmark)  
a7fa 32 65 ee			ld (debug_mark),a  
a7fd 3a 0c a8			ld a, (.dmark+1)  
a800 32 66 ee			ld (debug_mark+1),a  
a803 3a 0d a8			ld a, (.dmark+2)  
a806 32 67 ee			ld (debug_mark+2),a  
a809 18 03			jr .pastdmark  
a80b ..			.dmark: db "FRE"  
a80e f1			.pastdmark: pop af  
a80f			endm  
# End of macro DMARK
a80f					CALLMONITOR 
a80f cd 6f ee			call debug_vector  
a812				endm  
# End of macro CALLMONITOR
a812				endif 
a812				; get address 
a812			 
a812				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a812 cd 8a 9c			call macro_dsp_valuehl 
a815				endm 
# End of macro FORTH_DSP_VALUEHL
a815			 
a815			;		push hl 
a815			 
a815				; destroy value TOS 
a815			 
a815				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a815 cd 42 9d			call macro_forth_dsp_pop 
a818				endm 
# End of macro FORTH_DSP_POP
a818			 
a818			;		pop hl 
a818			if FORTH_ENABLE_MALLOCFREE 
a818 cd 8f 91			call free 
a81b			endif 
a81b				NEXTW 
a81b c3 76 9e			jp macro_next 
a81e				endm 
# End of macro NEXTW
a81e			.LIST: 
a81e			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a81e 5c				db WORD_SYS_CORE+72             
a81f 1a aa			dw .FORGET            
a821 05				db 4 + 1 
a822 .. 00			db "LIST",0              
a827				endm 
# End of macro CWHEAD
a827			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a827			; | | The quoted word must be in upper case. 
a827			if DEBUG_FORTH_WORDS_KEY 
a827				DMARK "LST" 
a827 f5				push af  
a828 3a 3c a8			ld a, (.dmark)  
a82b 32 65 ee			ld (debug_mark),a  
a82e 3a 3d a8			ld a, (.dmark+1)  
a831 32 66 ee			ld (debug_mark+1),a  
a834 3a 3e a8			ld a, (.dmark+2)  
a837 32 67 ee			ld (debug_mark+2),a  
a83a 18 03			jr .pastdmark  
a83c ..			.dmark: db "LST"  
a83f f1			.pastdmark: pop af  
a840			endm  
# End of macro DMARK
a840				CALLMONITOR 
a840 cd 6f ee			call debug_vector  
a843				endm  
# End of macro CALLMONITOR
a843			endif 
a843			 
a843				FORTH_DSP_VALUEHL 
a843 cd 8a 9c			call macro_dsp_valuehl 
a846				endm 
# End of macro FORTH_DSP_VALUEHL
a846			 
a846 e5				push hl 
a847				FORTH_DSP_POP 
a847 cd 42 9d			call macro_forth_dsp_pop 
a84a				endm 
# End of macro FORTH_DSP_POP
a84a c1				pop bc 
a84b			 
a84b			; Start format of scratch string 
a84b			 
a84b 21 bb e2			ld hl, scratch 
a84e			 
a84e 3e 3a			ld a, ':' 
a850 77				ld (hl),a 
a851 23				inc hl 
a852 3e 20			ld a, ' ' 
a854 77				ld (hl), a 
a855			 
a855				; Get ptr to the word we need to look up 
a855			 
a855			;		FORTH_DSP_VALUEHL 
a855				;v5 FORTH_DSP_VALUE 
a855			; TODO type check 
a855			;		inc hl    ; Skip type check  
a855			;		push hl 
a855			;		ex de, hl    ; put into DE 
a855			 
a855			 
a855 21 97 df			ld hl, baseram 
a858				;ld hl, baseusermem 
a858			 
a858 e5			push hl   ; sacreifical push 
a859			 
a859			.ldouscanm: 
a859 e1			pop hl 
a85a			.ldouscan: 
a85a			if DEBUG_FORTH_WORDS 
a85a				DMARK "LSs" 
a85a f5				push af  
a85b 3a 6f a8			ld a, (.dmark)  
a85e 32 65 ee			ld (debug_mark),a  
a861 3a 70 a8			ld a, (.dmark+1)  
a864 32 66 ee			ld (debug_mark+1),a  
a867 3a 71 a8			ld a, (.dmark+2)  
a86a 32 67 ee			ld (debug_mark+2),a  
a86d 18 03			jr .pastdmark  
a86f ..			.dmark: db "LSs"  
a872 f1			.pastdmark: pop af  
a873			endm  
# End of macro DMARK
a873				CALLMONITOR 
a873 cd 6f ee			call debug_vector  
a876				endm  
# End of macro CALLMONITOR
a876			endif 
a876			; skip dict stub 
a876 cd b3 9f			call forth_tok_next 
a879			 
a879			 
a879			; while we have words to look for 
a879			 
a879 7e			ld a, (hl)      
a87a			if DEBUG_FORTH_WORDS 
a87a				DMARK "LSk" 
a87a f5				push af  
a87b 3a 8f a8			ld a, (.dmark)  
a87e 32 65 ee			ld (debug_mark),a  
a881 3a 90 a8			ld a, (.dmark+1)  
a884 32 66 ee			ld (debug_mark+1),a  
a887 3a 91 a8			ld a, (.dmark+2)  
a88a 32 67 ee			ld (debug_mark+2),a  
a88d 18 03			jr .pastdmark  
a88f ..			.dmark: db "LSk"  
a892 f1			.pastdmark: pop af  
a893			endm  
# End of macro DMARK
a893				CALLMONITOR 
a893 cd 6f ee			call debug_vector  
a896				endm  
# End of macro CALLMONITOR
a896			endif 
a896				;cp WORD_SYS_END 
a896				;jp z, .lunotfound 
a896			 
a896					; if we hit non uwords then gone too far 
a896 fe 01				cp WORD_SYS_UWORD 
a898 c2 d6 a9				jp nz, .lunotfound 
a89b			 
a89b				if DEBUG_FORTH_WORDS 
a89b					DMARK "LSu" 
a89b f5				push af  
a89c 3a b0 a8			ld a, (.dmark)  
a89f 32 65 ee			ld (debug_mark),a  
a8a2 3a b1 a8			ld a, (.dmark+1)  
a8a5 32 66 ee			ld (debug_mark+1),a  
a8a8 3a b2 a8			ld a, (.dmark+2)  
a8ab 32 67 ee			ld (debug_mark+2),a  
a8ae 18 03			jr .pastdmark  
a8b0 ..			.dmark: db "LSu"  
a8b3 f1			.pastdmark: pop af  
a8b4			endm  
# End of macro DMARK
a8b4					CALLMONITOR 
a8b4 cd 6f ee			call debug_vector  
a8b7				endm  
# End of macro CALLMONITOR
a8b7				endif 
a8b7			 
a8b7					; found a uword but is it the one we want... 
a8b7			 
a8b7 c5					push bc     ; uword to find is on bc 
a8b8 d1					pop de 
a8b9			 
a8b9 e5					push hl  ; to save the ptr 
a8ba			 
a8ba					; skip opcode 
a8ba 23					inc hl  
a8bb					; skip next ptr 
a8bb 23					inc hl  
a8bc 23					inc hl 
a8bd					; skip len 
a8bd 23					inc hl 
a8be			 
a8be				if DEBUG_FORTH_WORDS 
a8be					DMARK "LSc" 
a8be f5				push af  
a8bf 3a d3 a8			ld a, (.dmark)  
a8c2 32 65 ee			ld (debug_mark),a  
a8c5 3a d4 a8			ld a, (.dmark+1)  
a8c8 32 66 ee			ld (debug_mark+1),a  
a8cb 3a d5 a8			ld a, (.dmark+2)  
a8ce 32 67 ee			ld (debug_mark+2),a  
a8d1 18 03			jr .pastdmark  
a8d3 ..			.dmark: db "LSc"  
a8d6 f1			.pastdmark: pop af  
a8d7			endm  
# End of macro DMARK
a8d7					CALLMONITOR 
a8d7 cd 6f ee			call debug_vector  
a8da				endm  
# End of macro CALLMONITOR
a8da				endif 
a8da			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a8da			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a8da			; Nope that has gone the other way. It needs to be exact not on first zero 
a8da			;		call strcmp 
a8da c5					push bc 
a8db cd 95 90				call StrictStrCmp 
a8de c1					pop bc 
a8df c2 59 a8				jp nz, .ldouscanm 
a8e2				 
a8e2			 
a8e2			 
a8e2					; we have a uword so push its name to the stack 
a8e2			 
a8e2			;	   	push hl  ; save so we can move to next dict block 
a8e2 e1			pop hl 
a8e3			 
a8e3				if DEBUG_FORTH_WORDS 
a8e3					DMARK "LSm" 
a8e3 f5				push af  
a8e4 3a f8 a8			ld a, (.dmark)  
a8e7 32 65 ee			ld (debug_mark),a  
a8ea 3a f9 a8			ld a, (.dmark+1)  
a8ed 32 66 ee			ld (debug_mark+1),a  
a8f0 3a fa a8			ld a, (.dmark+2)  
a8f3 32 67 ee			ld (debug_mark+2),a  
a8f6 18 03			jr .pastdmark  
a8f8 ..			.dmark: db "LSm"  
a8fb f1			.pastdmark: pop af  
a8fc			endm  
# End of macro DMARK
a8fc					CALLMONITOR 
a8fc cd 6f ee			call debug_vector  
a8ff				endm  
# End of macro CALLMONITOR
a8ff				endif 
a8ff			 
a8ff					; skip opcode 
a8ff 23					inc hl  
a900					; skip next ptr 
a900 23					inc hl  
a901 23					inc hl 
a902					; skip len 
a902 7e					ld a, (hl)   ; save length to add 
a903				if DEBUG_FORTH_WORDS 
a903					DMARK "LS2" 
a903 f5				push af  
a904 3a 18 a9			ld a, (.dmark)  
a907 32 65 ee			ld (debug_mark),a  
a90a 3a 19 a9			ld a, (.dmark+1)  
a90d 32 66 ee			ld (debug_mark+1),a  
a910 3a 1a a9			ld a, (.dmark+2)  
a913 32 67 ee			ld (debug_mark+2),a  
a916 18 03			jr .pastdmark  
a918 ..			.dmark: db "LS2"  
a91b f1			.pastdmark: pop af  
a91c			endm  
# End of macro DMARK
a91c					CALLMONITOR 
a91c cd 6f ee			call debug_vector  
a91f				endm  
# End of macro CALLMONITOR
a91f				endif 
a91f			 
a91f					; save this location 
a91f				 
a91f e5					push hl 
a920			 
a920 23					inc hl 
a921 11 bd e2				ld de, scratch+2 
a924 4f					ld c, a 
a925 06 00				ld b, 0 
a927			 
a927				if DEBUG_FORTH_WORDS 
a927					DMARK "LSn" 
a927 f5				push af  
a928 3a 3c a9			ld a, (.dmark)  
a92b 32 65 ee			ld (debug_mark),a  
a92e 3a 3d a9			ld a, (.dmark+1)  
a931 32 66 ee			ld (debug_mark+1),a  
a934 3a 3e a9			ld a, (.dmark+2)  
a937 32 67 ee			ld (debug_mark+2),a  
a93a 18 03			jr .pastdmark  
a93c ..			.dmark: db "LSn"  
a93f f1			.pastdmark: pop af  
a940			endm  
# End of macro DMARK
a940					CALLMONITOR 
a940 cd 6f ee			call debug_vector  
a943				endm  
# End of macro CALLMONITOR
a943				endif 
a943			 
a943					; copy uword name to scratch 
a943			 
a943			;		ldir 
a943			.licplw:	; copy uword name to scratch converting to lower case as we go 
a943 ed a0				ldi 
a945 1b					dec de 
a946 1a					ld a, (de) 
a947 cd 68 8f				call to_lower 
a94a 12					ld (de),a 
a94b 13					inc de 
a94c 3e 00				ld a, 0 
a94e b9					cp c 
a94f 20 f2				jr nz, .licplw 
a951			 
a951			 
a951			 
a951 1b					dec de 
a952 3e 20				ld a, ' '    ; change null to space 
a954 12					ld (de), a 
a955			 
a955 13					inc de 
a956			 
a956 d5					push de 
a957 c1					pop bc     ; move scratch pointer to end of word name and save it 
a958			 
a958 e1					pop hl 
a959 7e					ld a, (hl) 
a95a					;inc hl 
a95a					; skip word string 
a95a cd ea 8c				call addatohl 
a95d			 
a95d 23					inc hl 
a95e			 
a95e				if DEBUG_FORTH_WORDS 
a95e					DMARK "LS3" 
a95e f5				push af  
a95f 3a 73 a9			ld a, (.dmark)  
a962 32 65 ee			ld (debug_mark),a  
a965 3a 74 a9			ld a, (.dmark+1)  
a968 32 66 ee			ld (debug_mark+1),a  
a96b 3a 75 a9			ld a, (.dmark+2)  
a96e 32 67 ee			ld (debug_mark+2),a  
a971 18 03			jr .pastdmark  
a973 ..			.dmark: db "LS3"  
a976 f1			.pastdmark: pop af  
a977			endm  
# End of macro DMARK
a977					CALLMONITOR 
a977 cd 6f ee			call debug_vector  
a97a				endm  
# End of macro CALLMONITOR
a97a				endif 
a97a					; should now be at the start of the machine code to setup the eval of the uword 
a97a					; now locate the ptr to the string defintion 
a97a			 
a97a					; skip ld hl, 
a97a					; then load the ptr 
a97a			; TODO use get from hl ptr 
a97a 23					inc hl 
a97b 5e					ld e, (hl) 
a97c 23					inc hl 
a97d 56					ld d, (hl) 
a97e eb					ex de, hl 
a97f			 
a97f			 
a97f				if DEBUG_FORTH_WORDS 
a97f					DMARK "LSt" 
a97f f5				push af  
a980 3a 94 a9			ld a, (.dmark)  
a983 32 65 ee			ld (debug_mark),a  
a986 3a 95 a9			ld a, (.dmark+1)  
a989 32 66 ee			ld (debug_mark+1),a  
a98c 3a 96 a9			ld a, (.dmark+2)  
a98f 32 67 ee			ld (debug_mark+2),a  
a992 18 03			jr .pastdmark  
a994 ..			.dmark: db "LSt"  
a997 f1			.pastdmark: pop af  
a998			endm  
# End of macro DMARK
a998					CALLMONITOR 
a998 cd 6f ee			call debug_vector  
a99b				endm  
# End of macro CALLMONITOR
a99b				endif 
a99b			 
a99b			; cant push right now due to tokenised strings  
a99b			 
a99b			; get the destination of where to copy this definition to. 
a99b			 
a99b c5					push bc 
a99c d1					pop de 
a99d			 
a99d 7e			.listl:         ld a,(hl) 
a99e fe 00				cp 0 
a9a0 28 09				jr z, .lreplsp     ; replace zero with space 
a9a2					;cp FORTH_END_BUFFER 
a9a2 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9a4 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9a6				 
a9a6					; just copy this char as is then 
a9a6			 
a9a6 12					ld (de), a 
a9a7			 
a9a7 23			.listnxt:	inc hl 
a9a8 13					inc de 
a9a9 18 f2				jr .listl 
a9ab			 
a9ab 3e 20		.lreplsp:	ld a,' ' 
a9ad 12					ld (de), a 
a9ae 18 f7				jr .listnxt 
a9b0			 
a9b0			; close up uword def 
a9b0			 
a9b0			.listdone: 
a9b0 12					ld (de), a 
a9b1 13					inc de 
a9b2 3e 00				ld a, 0 
a9b4 12					ld (de), a 
a9b5			 
a9b5			; now have def so clean up and push to stack 
a9b5			 
a9b5 21 bb e2				ld hl, scratch 
a9b8				if DEBUG_FORTH_WORDS 
a9b8					DMARK "Ltp" 
a9b8 f5				push af  
a9b9 3a cd a9			ld a, (.dmark)  
a9bc 32 65 ee			ld (debug_mark),a  
a9bf 3a ce a9			ld a, (.dmark+1)  
a9c2 32 66 ee			ld (debug_mark+1),a  
a9c5 3a cf a9			ld a, (.dmark+2)  
a9c8 32 67 ee			ld (debug_mark+2),a  
a9cb 18 03			jr .pastdmark  
a9cd ..			.dmark: db "Ltp"  
a9d0 f1			.pastdmark: pop af  
a9d1			endm  
# End of macro DMARK
a9d1					CALLMONITOR 
a9d1 cd 6f ee			call debug_vector  
a9d4				endm  
# End of macro CALLMONITOR
a9d4				endif 
a9d4			 
a9d4 18 1f			jr .listpush 
a9d6			 
a9d6			;.lnuword:	pop hl 
a9d6			;		call forth_tok_next 
a9d6			;		jp .ldouscan  
a9d6			 
a9d6			.lunotfound:		  
a9d6			 
a9d6				if DEBUG_FORTH_WORDS 
a9d6					DMARK "LSn" 
a9d6 f5				push af  
a9d7 3a eb a9			ld a, (.dmark)  
a9da 32 65 ee			ld (debug_mark),a  
a9dd 3a ec a9			ld a, (.dmark+1)  
a9e0 32 66 ee			ld (debug_mark+1),a  
a9e3 3a ed a9			ld a, (.dmark+2)  
a9e6 32 67 ee			ld (debug_mark+2),a  
a9e9 18 03			jr .pastdmark  
a9eb ..			.dmark: db "LSn"  
a9ee f1			.pastdmark: pop af  
a9ef			endm  
# End of macro DMARK
a9ef					CALLMONITOR 
a9ef cd 6f ee			call debug_vector  
a9f2				endm  
# End of macro CALLMONITOR
a9f2				endif 
a9f2			 
a9f2					 
a9f2			;		FORTH_DSP_POP 
a9f2			;		ld hl, .luno 
a9f2			 
a9f2					NEXTW			 
a9f2 c3 76 9e			jp macro_next 
a9f5				endm 
# End of macro NEXTW
a9f5			 
a9f5			.listpush: 
a9f5				if DEBUG_FORTH_WORDS 
a9f5					DMARK "LS>" 
a9f5 f5				push af  
a9f6 3a 0a aa			ld a, (.dmark)  
a9f9 32 65 ee			ld (debug_mark),a  
a9fc 3a 0b aa			ld a, (.dmark+1)  
a9ff 32 66 ee			ld (debug_mark+1),a  
aa02 3a 0c aa			ld a, (.dmark+2)  
aa05 32 67 ee			ld (debug_mark+2),a  
aa08 18 03			jr .pastdmark  
aa0a ..			.dmark: db "LS>"  
aa0d f1			.pastdmark: pop af  
aa0e			endm  
# End of macro DMARK
aa0e					CALLMONITOR 
aa0e cd 6f ee			call debug_vector  
aa11				endm  
# End of macro CALLMONITOR
aa11				endif 
aa11 cd f3 9a				call forth_push_str 
aa14			 
aa14			 
aa14			 
aa14					NEXTW 
aa14 c3 76 9e			jp macro_next 
aa17				endm 
# End of macro NEXTW
aa17			 
aa17			;.luno:    db "Word not found",0 
aa17			 
aa17			 
aa17			 
aa17			 
aa17			 
aa17			;		push hl   ; save pointer to start of uword def string 
aa17			; 
aa17			;; look for FORTH_EOL_LINE 
aa17			;		ld a, FORTH_END_BUFFER 
aa17			;		call strlent 
aa17			; 
aa17			;		inc hl		 ; space for coln def 
aa17			;		inc hl 
aa17			;		inc hl          ; space for terms 
aa17			;		inc hl 
aa17			; 
aa17			;		ld a, 20   ; TODO get actual length 
aa17			;		call addatohl    ; include a random amount of room for the uword name 
aa17			; 
aa17			;		 
aa17			;	if DEBUG_FORTH_WORDS 
aa17			;		DMARK "Lt1" 
aa17			;		CALLMONITOR 
aa17			;	endif 
aa17			;		 
aa17			; 
aa17			;; malloc space for the string because we cant change it 
aa17			; 
aa17			;		call malloc 
aa17			;	if DEBUG_FORTH_MALLOC_GUARD 
aa17			;		push af 
aa17			;		call ishlzero 
aa17			;		pop af 
aa17			;		 
aa17			;		call z,malloc_error 
aa17			;	endif 
aa17			; 
aa17			;	if DEBUG_FORTH_WORDS 
aa17			;		DMARK "Lt2" 
aa17			;		CALLMONITOR 
aa17			;	endif 
aa17			;		pop de 
aa17			;		push hl    ; push the malloc to release later 
aa17			;		push hl   ;  push back a copy for the later stack push 
aa17			;		 
aa17			;; copy the string swapping out the zero terms for spaces 
aa17			; 
aa17			;		; de has our source 
aa17			;		; hl has our dest 
aa17			; 
aa17			;; add the coln def 
aa17			; 
aa17			;		ld a, ':' 
aa17			;		ld (hl), a 
aa17			;		inc hl 
aa17			;		ld a, ' ' 
aa17			;		ld (hl), a 
aa17			;		inc hl 
aa17			; 
aa17			;; add the uname word 
aa17			;		push de   ; save our string for now 
aa17			;		ex de, hl 
aa17			; 
aa17			;		FORTH_DSP_VALUE 
aa17			;		;v5 FORTH_DSP_VALUE 
aa17			; 
aa17			;		inc hl   ; skip type but we know by now this is OK 
aa17			; 
aa17			;.luword:	ld a,(hl) 
aa17			;		cp 0 
aa17			;		jr z, .luword2 
aa17			;		ld (de), a 
aa17			;		inc de 
aa17			;		inc hl 
aa17			;		jr .luword 
aa17			; 
aa17			;.luword2:	ld a, ' ' 
aa17			;		ld (de), a 
aa17			;;		inc hl 
aa17			;;		inc de 
aa17			;;		ld (de), a 
aa17			;;		inc hl 
aa17			;		inc de 
aa17			; 
aa17			;		ex de, hl 
aa17			;		pop de 
aa17			;		 
aa17			;		 
aa17			; 
aa17			;; detoken that string and copy it 
aa17			; 
aa17			;	if DEBUG_FORTH_WORDS 
aa17			;		DMARK "Lt2" 
aa17			;		CALLMONITOR 
aa17			;	endif 
aa17			;.ldetok:	ld a, (de) 
aa17			;		cp FORTH_END_BUFFER 
aa17			;		jr z, .ldetokend 
aa17			;		; swap out any zero term for space 
aa17			;		cp 0 
aa17			;		jr nz, .ldetoknext 
aa17			;		ld a, ' ' 
aa17			; 
aa17			;	if DEBUG_FORTH_WORDS 
aa17			;		DMARK "LtS" 
aa17			;		CALLMONITOR 
aa17			;	endif 
aa17			;.ldetoknext:	ld (hl), a 
aa17			;		inc de 
aa17			;		inc hl 
aa17			;		jr .ldetok 
aa17			; 
aa17			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa17			;		ld (hl), a  
aa17			; 
aa17			;; free that temp malloc 
aa17			; 
aa17			;		pop hl    
aa17			; 
aa17			;	if DEBUG_FORTH_WORDS 
aa17			;		DMARK "Lt4" 
aa17			;		CALLMONITOR 
aa17			;	endif 
aa17			;		call forth_apushstrhl 
aa17			; 
aa17			;		; get rid of temp malloc area 
aa17			; 
aa17			;		pop hl 
aa17			;		call free 
aa17			; 
aa17			;		jr .ludone 
aa17			; 
aa17			;.lnuword:	pop hl 
aa17			;		call forth_tok_next 
aa17			;		jp .ldouscan  
aa17			; 
aa17			;.ludone:		 pop hl 
aa17			; 
aa17					NEXTW 
aa17 c3 76 9e			jp macro_next 
aa1a				endm 
# End of macro NEXTW
aa1a			 
aa1a			.FORGET: 
aa1a				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa1a 5d				db WORD_SYS_CORE+73             
aa1b 93 aa			dw .NOP            
aa1d 07				db 6 + 1 
aa1e .. 00			db "FORGET",0              
aa25				endm 
# End of macro CWHEAD
aa25			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa25			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
aa25			; | |  
aa25			; | | e.g. "MORE" forget 
aa25					if DEBUG_FORTH_WORDS_KEY 
aa25						DMARK "FRG" 
aa25 f5				push af  
aa26 3a 3a aa			ld a, (.dmark)  
aa29 32 65 ee			ld (debug_mark),a  
aa2c 3a 3b aa			ld a, (.dmark+1)  
aa2f 32 66 ee			ld (debug_mark+1),a  
aa32 3a 3c aa			ld a, (.dmark+2)  
aa35 32 67 ee			ld (debug_mark+2),a  
aa38 18 03			jr .pastdmark  
aa3a ..			.dmark: db "FRG"  
aa3d f1			.pastdmark: pop af  
aa3e			endm  
# End of macro DMARK
aa3e						CALLMONITOR 
aa3e cd 6f ee			call debug_vector  
aa41				endm  
# End of macro CALLMONITOR
aa41					endif 
aa41			 
aa41				; find uword 
aa41			        ; update start of word with "_" 
aa41				; replace uword with deleted flag 
aa41			 
aa41			 
aa41			;	if DEBUG_FORTH_WORDS 
aa41			;		DMARK "FOG" 
aa41			;		CALLMONITOR 
aa41			;	endif 
aa41			 
aa41			 
aa41					; Get ptr to the word we need to look up 
aa41			 
aa41					FORTH_DSP_VALUEHL 
aa41 cd 8a 9c			call macro_dsp_valuehl 
aa44				endm 
# End of macro FORTH_DSP_VALUEHL
aa44					;v5 FORTH_DSP_VALUE 
aa44				; TODO type check 
aa44			;		inc hl    ; Skip type check  
aa44 e5					push hl 
aa45 c1					pop bc 
aa46			;		ex de, hl    ; put into DE 
aa46			 
aa46			 
aa46 21 97 df				ld hl, baseram 
aa49					;ld hl, baseusermem 
aa49			 
aa49				; skip dict stub 
aa49			;	call forth_tok_next 
aa49 e5			push hl   ; sacreifical push 
aa4a			 
aa4a			.fldouscanm: 
aa4a e1				pop hl 
aa4b			.fldouscan: 
aa4b			;	if DEBUG_FORTH_WORDS 
aa4b			;		DMARK "LSs" 
aa4b			;		CALLMONITOR 
aa4b			;	endif 
aa4b				; skip dict stub 
aa4b cd b3 9f				call forth_tok_next 
aa4e			 
aa4e			 
aa4e			; while we have words to look for 
aa4e			 
aa4e 7e				ld a, (hl)      
aa4f			;	if DEBUG_FORTH_WORDS 
aa4f			;		DMARK "LSk" 
aa4f			;		CALLMONITOR 
aa4f			;	endif 
aa4f fe 00				cp WORD_SYS_END 
aa51 ca 8d aa				jp z, .flunotfound 
aa54 fe 01				cp WORD_SYS_UWORD 
aa56 c2 4b aa				jp nz, .fldouscan 
aa59			 
aa59			;	if DEBUG_FORTH_WORDS 
aa59			;		DMARK "LSu" 
aa59			;		CALLMONITOR 
aa59			;	endif 
aa59			 
aa59					; found a uword but is it the one we want... 
aa59			 
aa59 c5					push bc     ; uword to find is on bc 
aa5a d1					pop de 
aa5b			 
aa5b e5					push hl  ; to save the ptr 
aa5c			 
aa5c					; skip opcode 
aa5c 23					inc hl  
aa5d					; skip next ptr 
aa5d 23					inc hl  
aa5e 23					inc hl 
aa5f					; skip len 
aa5f 23					inc hl 
aa60			 
aa60			;	if DEBUG_FORTH_WORDS 
aa60			;		DMARK "LSc" 
aa60			;		CALLMONITOR 
aa60			;	endif 
aa60 cd 88 90				call strcmp 
aa63 c2 4a aa				jp nz, .fldouscanm 
aa66			; 
aa66			; 
aa66			;; while we have words to look for 
aa66			; 
aa66			;.fdouscan:	ld a, (hl)      
aa66			;	if DEBUG_FORTH_WORDS 
aa66			;		DMARK "LSs" 
aa66			;		CALLMONITOR 
aa66			;	endif 
aa66			;		cp WORD_SYS_END 
aa66			;		jp z, .fudone 
aa66			;		cp WORD_SYS_UWORD 
aa66			;		jp nz, .fnuword 
aa66			; 
aa66			;	if DEBUG_FORTH_WORDS 
aa66			;		DMARK "FGu" 
aa66			;		CALLMONITOR 
aa66			;	endif 
aa66			; 
aa66			;		; found a uword but is it the one we want... 
aa66			; 
aa66			; 
aa66			;	        pop de   ; get back the dsp name 
aa66			;		push de 
aa66			; 
aa66			;		push hl  ; to save the ptr 
aa66			; 
aa66			;		; skip opcode 
aa66			;		inc hl  
aa66			;		; skip next ptr 
aa66			;		inc hl  
aa66			;		inc hl 
aa66			;		; skip len 
aa66			;		inc hl 
aa66			; 
aa66			;	if DEBUG_FORTH_WORDS 
aa66			;		DMARK "FGc" 
aa66			;		CALLMONITOR 
aa66			;	endif 
aa66			;		call strcmp 
aa66			;		jp nz, .fnuword 
aa66			 
aa66			 
aa66 e1			pop hl 
aa67			 
aa67				 
aa67				if DEBUG_FORTH_WORDS 
aa67					DMARK "FGm" 
aa67 f5				push af  
aa68 3a 7c aa			ld a, (.dmark)  
aa6b 32 65 ee			ld (debug_mark),a  
aa6e 3a 7d aa			ld a, (.dmark+1)  
aa71 32 66 ee			ld (debug_mark+1),a  
aa74 3a 7e aa			ld a, (.dmark+2)  
aa77 32 67 ee			ld (debug_mark+2),a  
aa7a 18 03			jr .pastdmark  
aa7c ..			.dmark: db "FGm"  
aa7f f1			.pastdmark: pop af  
aa80			endm  
# End of macro DMARK
aa80					CALLMONITOR 
aa80 cd 6f ee			call debug_vector  
aa83				endm  
# End of macro CALLMONITOR
aa83				endif 
aa83			 
aa83			 
aa83			 
aa83					; we have a uword so push its name to the stack 
aa83			 
aa83			;	   	push hl  ; save so we can move to next dict block 
aa83			;pop hl 
aa83			 
aa83					; update opcode to deleted 
aa83 3e 03				ld a, WORD_SYS_DELETED 
aa85 77					ld (hl), a 
aa86			 
aa86 23					inc hl  
aa87					; skip next ptr 
aa87 23					inc hl  
aa88 23					inc hl 
aa89					; skip len 
aa89 23					inc hl 
aa8a			 
aa8a					; TODO change parser to skip deleted words but for now mark it out 
aa8a 3e 5f				ld a, "_" 
aa8c 77					ld  (hl),a 
aa8d			 
aa8d			;		jr .fudone 
aa8d			; 
aa8d			;.fnuword:	pop hl 
aa8d			;		call forth_tok_next 
aa8d			;		jp .fdouscan  
aa8d			 
aa8d			.flunotfound:		  
aa8d			 
aa8d			 
aa8d					 
aa8d					FORTH_DSP_POP 
aa8d cd 42 9d			call macro_forth_dsp_pop 
aa90				endm 
# End of macro FORTH_DSP_POP
aa90			;		ld hl, .luno 
aa90			;.fudone:		 pop hl 
aa90					NEXTW 
aa90 c3 76 9e			jp macro_next 
aa93				endm 
# End of macro NEXTW
aa93			.NOP: 
aa93				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa93 61				db WORD_SYS_CORE+77             
aa94 ba aa			dw .COMO            
aa96 04				db 3 + 1 
aa97 .. 00			db "NOP",0              
aa9b				endm 
# End of macro CWHEAD
aa9b			; | NOP (  --  ) Do nothing | DONE 
aa9b					if DEBUG_FORTH_WORDS_KEY 
aa9b						DMARK "NOP" 
aa9b f5				push af  
aa9c 3a b0 aa			ld a, (.dmark)  
aa9f 32 65 ee			ld (debug_mark),a  
aaa2 3a b1 aa			ld a, (.dmark+1)  
aaa5 32 66 ee			ld (debug_mark+1),a  
aaa8 3a b2 aa			ld a, (.dmark+2)  
aaab 32 67 ee			ld (debug_mark+2),a  
aaae 18 03			jr .pastdmark  
aab0 ..			.dmark: db "NOP"  
aab3 f1			.pastdmark: pop af  
aab4			endm  
# End of macro DMARK
aab4						CALLMONITOR 
aab4 cd 6f ee			call debug_vector  
aab7				endm  
# End of macro CALLMONITOR
aab7					endif 
aab7				       NEXTW 
aab7 c3 76 9e			jp macro_next 
aaba				endm 
# End of macro NEXTW
aaba			.COMO: 
aaba				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aaba 6e				db WORD_SYS_CORE+90             
aabb 0c ab			dw .COMC            
aabd 02				db 1 + 1 
aabe .. 00			db "(",0              
aac0				endm 
# End of macro CWHEAD
aac0			; | ( ( -- )  Start of comment | DONE 
aac0			 
aac0			 
aac0 2a bc e5				ld hl, ( os_tok_ptr) 
aac3 11 07 ab			ld de, .closepar 
aac6					 
aac6					if DEBUG_FORTH_WORDS 
aac6						DMARK ").." 
aac6 f5				push af  
aac7 3a db aa			ld a, (.dmark)  
aaca 32 65 ee			ld (debug_mark),a  
aacd 3a dc aa			ld a, (.dmark+1)  
aad0 32 66 ee			ld (debug_mark+1),a  
aad3 3a dd aa			ld a, (.dmark+2)  
aad6 32 67 ee			ld (debug_mark+2),a  
aad9 18 03			jr .pastdmark  
aadb ..			.dmark: db ").."  
aade f1			.pastdmark: pop af  
aadf			endm  
# End of macro DMARK
aadf						CALLMONITOR 
aadf cd 6f ee			call debug_vector  
aae2				endm  
# End of macro CALLMONITOR
aae2					endif 
aae2 cd 7d 9f			call findnexttok  
aae5			 
aae5					if DEBUG_FORTH_WORDS 
aae5						DMARK "IF5" 
aae5 f5				push af  
aae6 3a fa aa			ld a, (.dmark)  
aae9 32 65 ee			ld (debug_mark),a  
aaec 3a fb aa			ld a, (.dmark+1)  
aaef 32 66 ee			ld (debug_mark+1),a  
aaf2 3a fc aa			ld a, (.dmark+2)  
aaf5 32 67 ee			ld (debug_mark+2),a  
aaf8 18 03			jr .pastdmark  
aafa ..			.dmark: db "IF5"  
aafd f1			.pastdmark: pop af  
aafe			endm  
# End of macro DMARK
aafe						CALLMONITOR 
aafe cd 6f ee			call debug_vector  
ab01				endm  
# End of macro CALLMONITOR
ab01					endif 
ab01				; replace below with ) exec using tok_ptr 
ab01 22 bc e5			ld (os_tok_ptr), hl 
ab04 c3 ff 9e			jp exec1 
ab07			 
ab07 .. 00			.closepar:   db ")",0 
ab09			 
ab09				       NEXTW 
ab09 c3 76 9e			jp macro_next 
ab0c				endm 
# End of macro NEXTW
ab0c			.COMC: 
ab0c				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab0c 6f				db WORD_SYS_CORE+91             
ab0d 15 ab			dw .SCRATCH            
ab0f 02				db 1 + 1 
ab10 .. 00			db ")",0              
ab12				endm 
# End of macro CWHEAD
ab12			; | ) ( -- )  End of comment |  DONE  
ab12				       NEXTW 
ab12 c3 76 9e			jp macro_next 
ab15				endm 
# End of macro NEXTW
ab15			 
ab15			.SCRATCH: 
ab15				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab15 6f				db WORD_SYS_CORE+91             
ab16 50 ab			dw .INC            
ab18 08				db 7 + 1 
ab19 .. 00			db "SCRATCH",0              
ab21				endm 
# End of macro CWHEAD
ab21			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab21			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab21			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab21			; | |  
ab21			; | | e.g.    : score $00 scratch ; 
ab21			; | |  
ab21			; | | $00 score ! 
ab21			; | | $01 score +! 
ab21			; | |  
ab21			; | | e.g.   : varword $0a scratch ;  
ab21			; | | 
ab21			; | | $8000 varword ! 
ab21					if DEBUG_FORTH_WORDS_KEY 
ab21						DMARK "SCR" 
ab21 f5				push af  
ab22 3a 36 ab			ld a, (.dmark)  
ab25 32 65 ee			ld (debug_mark),a  
ab28 3a 37 ab			ld a, (.dmark+1)  
ab2b 32 66 ee			ld (debug_mark+1),a  
ab2e 3a 38 ab			ld a, (.dmark+2)  
ab31 32 67 ee			ld (debug_mark+2),a  
ab34 18 03			jr .pastdmark  
ab36 ..			.dmark: db "SCR"  
ab39 f1			.pastdmark: pop af  
ab3a			endm  
# End of macro DMARK
ab3a						CALLMONITOR 
ab3a cd 6f ee			call debug_vector  
ab3d				endm  
# End of macro CALLMONITOR
ab3d					endif 
ab3d			 
ab3d					FORTH_DSP_VALUEHL 
ab3d cd 8a 9c			call macro_dsp_valuehl 
ab40				endm 
# End of macro FORTH_DSP_VALUEHL
ab40				 
ab40					FORTH_DSP_POP 
ab40 cd 42 9d			call macro_forth_dsp_pop 
ab43				endm 
# End of macro FORTH_DSP_POP
ab43			 
ab43 7d					ld a, l 
ab44 21 e0 e7				ld hl, os_var_array 
ab47 cd ea 8c				call addatohl 
ab4a			 
ab4a cd 85 9a				call forth_push_numhl 
ab4d			 
ab4d				       NEXTW 
ab4d c3 76 9e			jp macro_next 
ab50				endm 
# End of macro NEXTW
ab50			 
ab50			.INC: 
ab50				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab50 6f				db WORD_SYS_CORE+91             
ab51 a6 ab			dw .DEC            
ab53 03				db 2 + 1 
ab54 .. 00			db "+!",0              
ab57				endm 
# End of macro CWHEAD
ab57			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab57					if DEBUG_FORTH_WORDS_KEY 
ab57						DMARK "+s_" 
ab57 f5				push af  
ab58 3a 6c ab			ld a, (.dmark)  
ab5b 32 65 ee			ld (debug_mark),a  
ab5e 3a 6d ab			ld a, (.dmark+1)  
ab61 32 66 ee			ld (debug_mark+1),a  
ab64 3a 6e ab			ld a, (.dmark+2)  
ab67 32 67 ee			ld (debug_mark+2),a  
ab6a 18 03			jr .pastdmark  
ab6c ..			.dmark: db "+s_"  
ab6f f1			.pastdmark: pop af  
ab70			endm  
# End of macro DMARK
ab70						CALLMONITOR 
ab70 cd 6f ee			call debug_vector  
ab73				endm  
# End of macro CALLMONITOR
ab73					endif 
ab73			 
ab73					FORTH_DSP_VALUEHL 
ab73 cd 8a 9c			call macro_dsp_valuehl 
ab76				endm 
# End of macro FORTH_DSP_VALUEHL
ab76			 
ab76 e5					push hl   ; save address 
ab77			 
ab77					FORTH_DSP_POP 
ab77 cd 42 9d			call macro_forth_dsp_pop 
ab7a				endm 
# End of macro FORTH_DSP_POP
ab7a			 
ab7a					FORTH_DSP_VALUEHL 
ab7a cd 8a 9c			call macro_dsp_valuehl 
ab7d				endm 
# End of macro FORTH_DSP_VALUEHL
ab7d			 
ab7d e5					push hl 
ab7e					FORTH_DSP_POP 
ab7e cd 42 9d			call macro_forth_dsp_pop 
ab81				endm 
# End of macro FORTH_DSP_POP
ab81 e1					pop hl 
ab82			 
ab82					; hl contains value to add to byte at a 
ab82				 
ab82 eb					ex de, hl 
ab83			 
ab83 e1					pop hl 
ab84			 
ab84					if DEBUG_FORTH_WORDS 
ab84						DMARK "INC" 
ab84 f5				push af  
ab85 3a 99 ab			ld a, (.dmark)  
ab88 32 65 ee			ld (debug_mark),a  
ab8b 3a 9a ab			ld a, (.dmark+1)  
ab8e 32 66 ee			ld (debug_mark+1),a  
ab91 3a 9b ab			ld a, (.dmark+2)  
ab94 32 67 ee			ld (debug_mark+2),a  
ab97 18 03			jr .pastdmark  
ab99 ..			.dmark: db "INC"  
ab9c f1			.pastdmark: pop af  
ab9d			endm  
# End of macro DMARK
ab9d						CALLMONITOR 
ab9d cd 6f ee			call debug_vector  
aba0				endm  
# End of macro CALLMONITOR
aba0					endif 
aba0			 
aba0 7e					ld a,(hl) 
aba1 83					add e 
aba2 77					ld (hl),a 
aba3			 
aba3			 
aba3			 
aba3				       NEXTW 
aba3 c3 76 9e			jp macro_next 
aba6				endm 
# End of macro NEXTW
aba6			 
aba6			.DEC: 
aba6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
aba6 6f				db WORD_SYS_CORE+91             
aba7 fa ab			dw .INC2            
aba9 03				db 2 + 1 
abaa .. 00			db "-!",0              
abad				endm 
# End of macro CWHEAD
abad			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abad					if DEBUG_FORTH_WORDS_KEY 
abad						DMARK "-s_" 
abad f5				push af  
abae 3a c2 ab			ld a, (.dmark)  
abb1 32 65 ee			ld (debug_mark),a  
abb4 3a c3 ab			ld a, (.dmark+1)  
abb7 32 66 ee			ld (debug_mark+1),a  
abba 3a c4 ab			ld a, (.dmark+2)  
abbd 32 67 ee			ld (debug_mark+2),a  
abc0 18 03			jr .pastdmark  
abc2 ..			.dmark: db "-s_"  
abc5 f1			.pastdmark: pop af  
abc6			endm  
# End of macro DMARK
abc6						CALLMONITOR 
abc6 cd 6f ee			call debug_vector  
abc9				endm  
# End of macro CALLMONITOR
abc9					endif 
abc9			 
abc9					FORTH_DSP_VALUEHL 
abc9 cd 8a 9c			call macro_dsp_valuehl 
abcc				endm 
# End of macro FORTH_DSP_VALUEHL
abcc			 
abcc e5					push hl   ; save address 
abcd			 
abcd					FORTH_DSP_POP 
abcd cd 42 9d			call macro_forth_dsp_pop 
abd0				endm 
# End of macro FORTH_DSP_POP
abd0			 
abd0					FORTH_DSP_VALUEHL 
abd0 cd 8a 9c			call macro_dsp_valuehl 
abd3				endm 
# End of macro FORTH_DSP_VALUEHL
abd3			 
abd3					; hl contains value to add to byte at a 
abd3				 
abd3 eb					ex de, hl 
abd4			 
abd4 e1					pop hl 
abd5			 
abd5					if DEBUG_FORTH_WORDS 
abd5						DMARK "DEC" 
abd5 f5				push af  
abd6 3a ea ab			ld a, (.dmark)  
abd9 32 65 ee			ld (debug_mark),a  
abdc 3a eb ab			ld a, (.dmark+1)  
abdf 32 66 ee			ld (debug_mark+1),a  
abe2 3a ec ab			ld a, (.dmark+2)  
abe5 32 67 ee			ld (debug_mark+2),a  
abe8 18 03			jr .pastdmark  
abea ..			.dmark: db "DEC"  
abed f1			.pastdmark: pop af  
abee			endm  
# End of macro DMARK
abee						CALLMONITOR 
abee cd 6f ee			call debug_vector  
abf1				endm  
# End of macro CALLMONITOR
abf1					endif 
abf1			 
abf1 7e					ld a,(hl) 
abf2 93					sub e 
abf3 77					ld (hl),a 
abf4			 
abf4			 
abf4					FORTH_DSP_POP 
abf4 cd 42 9d			call macro_forth_dsp_pop 
abf7				endm 
# End of macro FORTH_DSP_POP
abf7			 
abf7				       NEXTW 
abf7 c3 76 9e			jp macro_next 
abfa				endm 
# End of macro NEXTW
abfa			 
abfa			.INC2: 
abfa				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
abfa 6f				db WORD_SYS_CORE+91             
abfb a7 ac			dw .DEC2            
abfd 04				db 3 + 1 
abfe .. 00			db "+2!",0              
ac02				endm 
# End of macro CWHEAD
ac02			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac02			 
ac02					if DEBUG_FORTH_WORDS_KEY 
ac02						DMARK "+2s" 
ac02 f5				push af  
ac03 3a 17 ac			ld a, (.dmark)  
ac06 32 65 ee			ld (debug_mark),a  
ac09 3a 18 ac			ld a, (.dmark+1)  
ac0c 32 66 ee			ld (debug_mark+1),a  
ac0f 3a 19 ac			ld a, (.dmark+2)  
ac12 32 67 ee			ld (debug_mark+2),a  
ac15 18 03			jr .pastdmark  
ac17 ..			.dmark: db "+2s"  
ac1a f1			.pastdmark: pop af  
ac1b			endm  
# End of macro DMARK
ac1b						CALLMONITOR 
ac1b cd 6f ee			call debug_vector  
ac1e				endm  
# End of macro CALLMONITOR
ac1e					endif 
ac1e			 
ac1e					; Address 
ac1e			 
ac1e					FORTH_DSP_VALUEHL 
ac1e cd 8a 9c			call macro_dsp_valuehl 
ac21				endm 
# End of macro FORTH_DSP_VALUEHL
ac21			 
ac21 e5					push hl    ; save address 
ac22			 
ac22					; load content into de 
ac22			 
ac22 5e					ld e,(hl) 
ac23 23					inc hl 
ac24 56					ld d, (hl) 
ac25			 
ac25					if DEBUG_FORTH_WORDS 
ac25						DMARK "+2a" 
ac25 f5				push af  
ac26 3a 3a ac			ld a, (.dmark)  
ac29 32 65 ee			ld (debug_mark),a  
ac2c 3a 3b ac			ld a, (.dmark+1)  
ac2f 32 66 ee			ld (debug_mark+1),a  
ac32 3a 3c ac			ld a, (.dmark+2)  
ac35 32 67 ee			ld (debug_mark+2),a  
ac38 18 03			jr .pastdmark  
ac3a ..			.dmark: db "+2a"  
ac3d f1			.pastdmark: pop af  
ac3e			endm  
# End of macro DMARK
ac3e						CALLMONITOR 
ac3e cd 6f ee			call debug_vector  
ac41				endm  
# End of macro CALLMONITOR
ac41					endif 
ac41			 
ac41					FORTH_DSP_POP 
ac41 cd 42 9d			call macro_forth_dsp_pop 
ac44				endm 
# End of macro FORTH_DSP_POP
ac44			 
ac44					; Get value to add 
ac44			 
ac44					FORTH_DSP_VALUE 
ac44 cd 73 9c			call macro_forth_dsp_value 
ac47				endm 
# End of macro FORTH_DSP_VALUE
ac47			 
ac47					if DEBUG_FORTH_WORDS 
ac47						DMARK "+2v" 
ac47 f5				push af  
ac48 3a 5c ac			ld a, (.dmark)  
ac4b 32 65 ee			ld (debug_mark),a  
ac4e 3a 5d ac			ld a, (.dmark+1)  
ac51 32 66 ee			ld (debug_mark+1),a  
ac54 3a 5e ac			ld a, (.dmark+2)  
ac57 32 67 ee			ld (debug_mark+2),a  
ac5a 18 03			jr .pastdmark  
ac5c ..			.dmark: db "+2v"  
ac5f f1			.pastdmark: pop af  
ac60			endm  
# End of macro DMARK
ac60						CALLMONITOR 
ac60 cd 6f ee			call debug_vector  
ac63				endm  
# End of macro CALLMONITOR
ac63					endif 
ac63			 
ac63 19					add hl, de 
ac64			 
ac64					if DEBUG_FORTH_WORDS 
ac64						DMARK "+2+" 
ac64 f5				push af  
ac65 3a 79 ac			ld a, (.dmark)  
ac68 32 65 ee			ld (debug_mark),a  
ac6b 3a 7a ac			ld a, (.dmark+1)  
ac6e 32 66 ee			ld (debug_mark+1),a  
ac71 3a 7b ac			ld a, (.dmark+2)  
ac74 32 67 ee			ld (debug_mark+2),a  
ac77 18 03			jr .pastdmark  
ac79 ..			.dmark: db "+2+"  
ac7c f1			.pastdmark: pop af  
ac7d			endm  
# End of macro DMARK
ac7d						CALLMONITOR 
ac7d cd 6f ee			call debug_vector  
ac80				endm  
# End of macro CALLMONITOR
ac80					endif 
ac80			 
ac80					; move result to de 
ac80			 
ac80 eb					ex de, hl 
ac81			 
ac81					; Address 
ac81			 
ac81 e1					pop hl 
ac82			 
ac82					; save it back 
ac82			 
ac82 73					ld (hl), e 
ac83 23					inc hl 
ac84 72					ld (hl), d 
ac85			 
ac85					if DEBUG_FORTH_WORDS 
ac85						DMARK "+2e" 
ac85 f5				push af  
ac86 3a 9a ac			ld a, (.dmark)  
ac89 32 65 ee			ld (debug_mark),a  
ac8c 3a 9b ac			ld a, (.dmark+1)  
ac8f 32 66 ee			ld (debug_mark+1),a  
ac92 3a 9c ac			ld a, (.dmark+2)  
ac95 32 67 ee			ld (debug_mark+2),a  
ac98 18 03			jr .pastdmark  
ac9a ..			.dmark: db "+2e"  
ac9d f1			.pastdmark: pop af  
ac9e			endm  
# End of macro DMARK
ac9e						CALLMONITOR 
ac9e cd 6f ee			call debug_vector  
aca1				endm  
# End of macro CALLMONITOR
aca1					endif 
aca1			 
aca1			 
aca1			 
aca1					FORTH_DSP_POP 
aca1 cd 42 9d			call macro_forth_dsp_pop 
aca4				endm 
# End of macro FORTH_DSP_POP
aca4			 
aca4			 
aca4				       NEXTW 
aca4 c3 76 9e			jp macro_next 
aca7				endm 
# End of macro NEXTW
aca7			 
aca7			.DEC2: 
aca7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aca7 6f				db WORD_SYS_CORE+91             
aca8 56 ad			dw .GET2            
acaa 04				db 3 + 1 
acab .. 00			db "-2!",0              
acaf				endm 
# End of macro CWHEAD
acaf			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acaf			 
acaf			 
acaf					if DEBUG_FORTH_WORDS_KEY 
acaf						DMARK "-2s" 
acaf f5				push af  
acb0 3a c4 ac			ld a, (.dmark)  
acb3 32 65 ee			ld (debug_mark),a  
acb6 3a c5 ac			ld a, (.dmark+1)  
acb9 32 66 ee			ld (debug_mark+1),a  
acbc 3a c6 ac			ld a, (.dmark+2)  
acbf 32 67 ee			ld (debug_mark+2),a  
acc2 18 03			jr .pastdmark  
acc4 ..			.dmark: db "-2s"  
acc7 f1			.pastdmark: pop af  
acc8			endm  
# End of macro DMARK
acc8						CALLMONITOR 
acc8 cd 6f ee			call debug_vector  
accb				endm  
# End of macro CALLMONITOR
accb					endif 
accb			 
accb					; Address 
accb			 
accb					FORTH_DSP_VALUEHL 
accb cd 8a 9c			call macro_dsp_valuehl 
acce				endm 
# End of macro FORTH_DSP_VALUEHL
acce			 
acce e5					push hl    ; save address 
accf			 
accf					; load content into de 
accf			 
accf 5e					ld e,(hl) 
acd0 23					inc hl 
acd1 56					ld d, (hl) 
acd2			 
acd2					if DEBUG_FORTH_WORDS 
acd2						DMARK "-2a" 
acd2 f5				push af  
acd3 3a e7 ac			ld a, (.dmark)  
acd6 32 65 ee			ld (debug_mark),a  
acd9 3a e8 ac			ld a, (.dmark+1)  
acdc 32 66 ee			ld (debug_mark+1),a  
acdf 3a e9 ac			ld a, (.dmark+2)  
ace2 32 67 ee			ld (debug_mark+2),a  
ace5 18 03			jr .pastdmark  
ace7 ..			.dmark: db "-2a"  
acea f1			.pastdmark: pop af  
aceb			endm  
# End of macro DMARK
aceb						CALLMONITOR 
aceb cd 6f ee			call debug_vector  
acee				endm  
# End of macro CALLMONITOR
acee					endif 
acee			 
acee					FORTH_DSP_POP 
acee cd 42 9d			call macro_forth_dsp_pop 
acf1				endm 
# End of macro FORTH_DSP_POP
acf1			 
acf1					; Get value to remove 
acf1			 
acf1					FORTH_DSP_VALUE 
acf1 cd 73 9c			call macro_forth_dsp_value 
acf4				endm 
# End of macro FORTH_DSP_VALUE
acf4			 
acf4					if DEBUG_FORTH_WORDS 
acf4						DMARK "-2v" 
acf4 f5				push af  
acf5 3a 09 ad			ld a, (.dmark)  
acf8 32 65 ee			ld (debug_mark),a  
acfb 3a 0a ad			ld a, (.dmark+1)  
acfe 32 66 ee			ld (debug_mark+1),a  
ad01 3a 0b ad			ld a, (.dmark+2)  
ad04 32 67 ee			ld (debug_mark+2),a  
ad07 18 03			jr .pastdmark  
ad09 ..			.dmark: db "-2v"  
ad0c f1			.pastdmark: pop af  
ad0d			endm  
# End of macro DMARK
ad0d						CALLMONITOR 
ad0d cd 6f ee			call debug_vector  
ad10				endm  
# End of macro CALLMONITOR
ad10					endif 
ad10			 
ad10 eb					ex de, hl 
ad11 ed 52				sbc hl, de 
ad13			 
ad13					if DEBUG_FORTH_WORDS 
ad13						DMARK "-2d" 
ad13 f5				push af  
ad14 3a 28 ad			ld a, (.dmark)  
ad17 32 65 ee			ld (debug_mark),a  
ad1a 3a 29 ad			ld a, (.dmark+1)  
ad1d 32 66 ee			ld (debug_mark+1),a  
ad20 3a 2a ad			ld a, (.dmark+2)  
ad23 32 67 ee			ld (debug_mark+2),a  
ad26 18 03			jr .pastdmark  
ad28 ..			.dmark: db "-2d"  
ad2b f1			.pastdmark: pop af  
ad2c			endm  
# End of macro DMARK
ad2c						CALLMONITOR 
ad2c cd 6f ee			call debug_vector  
ad2f				endm  
# End of macro CALLMONITOR
ad2f					endif 
ad2f			 
ad2f					; move result to de 
ad2f			 
ad2f eb					ex de, hl 
ad30			 
ad30					; Address 
ad30			 
ad30 e1					pop hl 
ad31			 
ad31					; save it back 
ad31			 
ad31 73					ld (hl), e 
ad32 23					inc hl 
ad33 72					ld (hl), d 
ad34			 
ad34					if DEBUG_FORTH_WORDS 
ad34						DMARK "-2e" 
ad34 f5				push af  
ad35 3a 49 ad			ld a, (.dmark)  
ad38 32 65 ee			ld (debug_mark),a  
ad3b 3a 4a ad			ld a, (.dmark+1)  
ad3e 32 66 ee			ld (debug_mark+1),a  
ad41 3a 4b ad			ld a, (.dmark+2)  
ad44 32 67 ee			ld (debug_mark+2),a  
ad47 18 03			jr .pastdmark  
ad49 ..			.dmark: db "-2e"  
ad4c f1			.pastdmark: pop af  
ad4d			endm  
# End of macro DMARK
ad4d						CALLMONITOR 
ad4d cd 6f ee			call debug_vector  
ad50				endm  
# End of macro CALLMONITOR
ad50					endif 
ad50			 
ad50			 
ad50					FORTH_DSP_POP 
ad50 cd 42 9d			call macro_forth_dsp_pop 
ad53				endm 
# End of macro FORTH_DSP_POP
ad53			 
ad53			 
ad53			 
ad53				       NEXTW 
ad53 c3 76 9e			jp macro_next 
ad56				endm 
# End of macro NEXTW
ad56			.GET2: 
ad56				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad56 6f				db WORD_SYS_CORE+91             
ad57 8b ad			dw .BANG2            
ad59 03				db 2 + 1 
ad5a .. 00			db "2@",0              
ad5d				endm 
# End of macro CWHEAD
ad5d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad5d					if DEBUG_FORTH_WORDS_KEY 
ad5d						DMARK "2A_" 
ad5d f5				push af  
ad5e 3a 72 ad			ld a, (.dmark)  
ad61 32 65 ee			ld (debug_mark),a  
ad64 3a 73 ad			ld a, (.dmark+1)  
ad67 32 66 ee			ld (debug_mark+1),a  
ad6a 3a 74 ad			ld a, (.dmark+2)  
ad6d 32 67 ee			ld (debug_mark+2),a  
ad70 18 03			jr .pastdmark  
ad72 ..			.dmark: db "2A_"  
ad75 f1			.pastdmark: pop af  
ad76			endm  
# End of macro DMARK
ad76						CALLMONITOR 
ad76 cd 6f ee			call debug_vector  
ad79				endm  
# End of macro CALLMONITOR
ad79					endif 
ad79			 
ad79					FORTH_DSP_VALUEHL 
ad79 cd 8a 9c			call macro_dsp_valuehl 
ad7c				endm 
# End of macro FORTH_DSP_VALUEHL
ad7c			 
ad7c e5					push hl   ; save address 
ad7d			 
ad7d					FORTH_DSP_POP 
ad7d cd 42 9d			call macro_forth_dsp_pop 
ad80				endm 
# End of macro FORTH_DSP_POP
ad80			 
ad80 e1					pop hl 
ad81			 
ad81 5e					ld e, (hl) 
ad82 23					inc hl 
ad83 56					ld d, (hl) 
ad84			 
ad84 eb					ex de, hl 
ad85			 
ad85 cd 85 9a				call forth_push_numhl 
ad88			 
ad88				       NEXTW 
ad88 c3 76 9e			jp macro_next 
ad8b				endm 
# End of macro NEXTW
ad8b			.BANG2: 
ad8b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad8b 6f				db WORD_SYS_CORE+91             
ad8c c3 ad			dw .CONFIG            
ad8e 03				db 2 + 1 
ad8f .. 00			db "2!",0              
ad92				endm 
# End of macro CWHEAD
ad92			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad92					if DEBUG_FORTH_WORDS_KEY 
ad92						DMARK "2S_" 
ad92 f5				push af  
ad93 3a a7 ad			ld a, (.dmark)  
ad96 32 65 ee			ld (debug_mark),a  
ad99 3a a8 ad			ld a, (.dmark+1)  
ad9c 32 66 ee			ld (debug_mark+1),a  
ad9f 3a a9 ad			ld a, (.dmark+2)  
ada2 32 67 ee			ld (debug_mark+2),a  
ada5 18 03			jr .pastdmark  
ada7 ..			.dmark: db "2S_"  
adaa f1			.pastdmark: pop af  
adab			endm  
# End of macro DMARK
adab						CALLMONITOR 
adab cd 6f ee			call debug_vector  
adae				endm  
# End of macro CALLMONITOR
adae					endif 
adae			 
adae					FORTH_DSP_VALUEHL 
adae cd 8a 9c			call macro_dsp_valuehl 
adb1				endm 
# End of macro FORTH_DSP_VALUEHL
adb1			 
adb1 e5					push hl   ; save address 
adb2			 
adb2			 
adb2					FORTH_DSP_POP 
adb2 cd 42 9d			call macro_forth_dsp_pop 
adb5				endm 
# End of macro FORTH_DSP_POP
adb5			 
adb5					 
adb5					FORTH_DSP_VALUEHL 
adb5 cd 8a 9c			call macro_dsp_valuehl 
adb8				endm 
# End of macro FORTH_DSP_VALUEHL
adb8			 
adb8					FORTH_DSP_POP 
adb8 cd 42 9d			call macro_forth_dsp_pop 
adbb				endm 
# End of macro FORTH_DSP_POP
adbb			 
adbb eb					ex de, hl    ; value now in de 
adbc			 
adbc e1					pop hl 
adbd			 
adbd 73					ld (hl), e 
adbe			 
adbe 23					inc hl 
adbf			 
adbf 72					ld (hl), d 
adc0			 
adc0			 
adc0				       NEXTW 
adc0 c3 76 9e			jp macro_next 
adc3				endm 
# End of macro NEXTW
adc3			.CONFIG: 
adc3				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
adc3 6f				db WORD_SYS_CORE+91             
adc4 d4 ad			dw .ADTOS            
adc6 07				db 6 + 1 
adc7 .. 00			db "CONFIG",0              
adce				endm 
# End of macro CWHEAD
adce			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
adce			 
adce cd 5e 92				call config 
add1					NEXTW 
add1 c3 76 9e			jp macro_next 
add4				endm 
# End of macro NEXTW
add4			 
add4			.ADTOS: 
add4				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
add4 6f				db WORD_SYS_CORE+91             
add5 ea ad			dw .SBTOS            
add7 03				db 2 + 1 
add8 .. 00			db "1+",0              
addb				endm 
# End of macro CWHEAD
addb			; | 1+ ( u -- u )  Increment value on TOS | DONE 
addb			 
addb					FORTH_DSP_VALUEHL 
addb cd 8a 9c			call macro_dsp_valuehl 
adde				endm 
# End of macro FORTH_DSP_VALUEHL
adde e5					push hl 
addf			 
addf					FORTH_DSP_POP 
addf cd 42 9d			call macro_forth_dsp_pop 
ade2				endm 
# End of macro FORTH_DSP_POP
ade2 e1					pop hl 
ade3			 
ade3 23					inc hl 
ade4 cd 85 9a				call forth_push_numhl 
ade7					 
ade7					NEXTW 
ade7 c3 76 9e			jp macro_next 
adea				endm 
# End of macro NEXTW
adea			.SBTOS: 
adea				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
adea 6f				db WORD_SYS_CORE+91             
adeb 00 ae			dw .ADSTORE            
aded 03				db 2 + 1 
adee .. 00			db "1-",0              
adf1				endm 
# End of macro CWHEAD
adf1			; | 1- ( u -- u )  Decrement value on TOS | DONE 
adf1			 
adf1					FORTH_DSP_VALUEHL 
adf1 cd 8a 9c			call macro_dsp_valuehl 
adf4				endm 
# End of macro FORTH_DSP_VALUEHL
adf4 e5					push hl 
adf5			 
adf5					FORTH_DSP_POP 
adf5 cd 42 9d			call macro_forth_dsp_pop 
adf8				endm 
# End of macro FORTH_DSP_POP
adf8 e1					pop hl 
adf9			 
adf9 2b					dec hl 
adfa cd 85 9a				call forth_push_numhl 
adfd					 
adfd					NEXTW 
adfd c3 76 9e			jp macro_next 
ae00				endm 
# End of macro NEXTW
ae00			.ADSTORE: 
ae00				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ae00 6f				db WORD_SYS_CORE+91             
ae01 16 ae			dw .ADWSTORE            
ae03 04				db 3 + 1 
ae04 .. 00			db "1+!",0              
ae08				endm 
# End of macro CWHEAD
ae08			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ae08			 
ae08					FORTH_DSP_VALUEHL 
ae08 cd 8a 9c			call macro_dsp_valuehl 
ae0b				endm 
# End of macro FORTH_DSP_VALUEHL
ae0b e5					push hl 
ae0c			 
ae0c					FORTH_DSP_POP 
ae0c cd 42 9d			call macro_forth_dsp_pop 
ae0f				endm 
# End of macro FORTH_DSP_POP
ae0f e1					pop hl 
ae10			 
ae10 7e					ld a, (hl) 
ae11 3c					inc a 
ae12 77					ld (hl), a 
ae13					 
ae13					NEXTW 
ae13 c3 76 9e			jp macro_next 
ae16				endm 
# End of macro NEXTW
ae16			.ADWSTORE: 
ae16				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ae16 6f				db WORD_SYS_CORE+91             
ae17 34 ae			dw .SBSTORE            
ae19 05				db 4 + 1 
ae1a .. 00			db "1+2!",0              
ae1f				endm 
# End of macro CWHEAD
ae1f			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ae1f			 
ae1f					FORTH_DSP_VALUEHL 
ae1f cd 8a 9c			call macro_dsp_valuehl 
ae22				endm 
# End of macro FORTH_DSP_VALUEHL
ae22 e5					push hl 
ae23			 
ae23					FORTH_DSP_POP 
ae23 cd 42 9d			call macro_forth_dsp_pop 
ae26				endm 
# End of macro FORTH_DSP_POP
ae26 e1					pop hl 
ae27			 
ae27 e5					push hl 
ae28			 
ae28 cd f8 9d				call loadwordinhl 
ae2b 23					inc hl 
ae2c			 
ae2c d1					pop de 
ae2d eb					ex de, hl 
ae2e 73					ld (hl), e 
ae2f 23					inc hl 
ae30 72					ld (hl), d 
ae31					 
ae31					NEXTW 
ae31 c3 76 9e			jp macro_next 
ae34				endm 
# End of macro NEXTW
ae34			.SBSTORE: 
ae34				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ae34 6f				db WORD_SYS_CORE+91             
ae35 4a ae			dw .SBWSTORE            
ae37 04				db 3 + 1 
ae38 .. 00			db "1-!",0              
ae3c				endm 
# End of macro CWHEAD
ae3c			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
ae3c			 
ae3c					FORTH_DSP_VALUEHL 
ae3c cd 8a 9c			call macro_dsp_valuehl 
ae3f				endm 
# End of macro FORTH_DSP_VALUEHL
ae3f e5					push hl 
ae40			 
ae40					FORTH_DSP_POP 
ae40 cd 42 9d			call macro_forth_dsp_pop 
ae43				endm 
# End of macro FORTH_DSP_POP
ae43 e1					pop hl 
ae44			 
ae44 7e					ld a, (hl) 
ae45 3d					dec a 
ae46 77					ld (hl), a 
ae47					 
ae47					NEXTW 
ae47 c3 76 9e			jp macro_next 
ae4a				endm 
# End of macro NEXTW
ae4a			.SBWSTORE: 
ae4a				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
ae4a 6f				db WORD_SYS_CORE+91             
ae4b 68 ae			dw .ENDCORE            
ae4d 05				db 4 + 1 
ae4e .. 00			db "1-2!",0              
ae53				endm 
# End of macro CWHEAD
ae53			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
ae53			 
ae53					FORTH_DSP_VALUEHL 
ae53 cd 8a 9c			call macro_dsp_valuehl 
ae56				endm 
# End of macro FORTH_DSP_VALUEHL
ae56 e5					push hl 
ae57			 
ae57					FORTH_DSP_POP 
ae57 cd 42 9d			call macro_forth_dsp_pop 
ae5a				endm 
# End of macro FORTH_DSP_POP
ae5a e1					pop hl 
ae5b			 
ae5b e5					push hl 
ae5c			 
ae5c cd f8 9d				call loadwordinhl 
ae5f 2b					dec hl 
ae60			 
ae60 d1					pop de 
ae61 eb					ex de, hl 
ae62 73					ld (hl), e 
ae63 23					inc hl 
ae64 72					ld (hl), d 
ae65					 
ae65					NEXTW 
ae65 c3 76 9e			jp macro_next 
ae68				endm 
# End of macro NEXTW
ae68			.ENDCORE: 
ae68			 
ae68			; eof 
ae68			 
ae68			 
# End of file forth_words_core.asm
ae68			include "forth_words_flow.asm" 
ae68			 
ae68			; | ## Program Flow Words 
ae68			 
ae68			.IF: 
ae68				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ae68 1e				db WORD_SYS_CORE+10             
ae69 5d af			dw .THEN            
ae6b 03				db 2 + 1 
ae6c .. 00			db "IF",0              
ae6f				endm 
# End of macro CWHEAD
ae6f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ae6f			; 
ae6f					if DEBUG_FORTH_WORDS_KEY 
ae6f						DMARK "IF." 
ae6f f5				push af  
ae70 3a 84 ae			ld a, (.dmark)  
ae73 32 65 ee			ld (debug_mark),a  
ae76 3a 85 ae			ld a, (.dmark+1)  
ae79 32 66 ee			ld (debug_mark+1),a  
ae7c 3a 86 ae			ld a, (.dmark+2)  
ae7f 32 67 ee			ld (debug_mark+2),a  
ae82 18 03			jr .pastdmark  
ae84 ..			.dmark: db "IF."  
ae87 f1			.pastdmark: pop af  
ae88			endm  
# End of macro DMARK
ae88						CALLMONITOR 
ae88 cd 6f ee			call debug_vector  
ae8b				endm  
# End of macro CALLMONITOR
ae8b					endif 
ae8b			; eval TOS 
ae8b			 
ae8b				FORTH_DSP_VALUEHL 
ae8b cd 8a 9c			call macro_dsp_valuehl 
ae8e				endm 
# End of macro FORTH_DSP_VALUEHL
ae8e			 
ae8e			;	push hl 
ae8e				FORTH_DSP_POP 
ae8e cd 42 9d			call macro_forth_dsp_pop 
ae91				endm 
# End of macro FORTH_DSP_POP
ae91			;	pop hl 
ae91			 
ae91					if DEBUG_FORTH_WORDS 
ae91						DMARK "IF1" 
ae91 f5				push af  
ae92 3a a6 ae			ld a, (.dmark)  
ae95 32 65 ee			ld (debug_mark),a  
ae98 3a a7 ae			ld a, (.dmark+1)  
ae9b 32 66 ee			ld (debug_mark+1),a  
ae9e 3a a8 ae			ld a, (.dmark+2)  
aea1 32 67 ee			ld (debug_mark+2),a  
aea4 18 03			jr .pastdmark  
aea6 ..			.dmark: db "IF1"  
aea9 f1			.pastdmark: pop af  
aeaa			endm  
# End of macro DMARK
aeaa						CALLMONITOR 
aeaa cd 6f ee			call debug_vector  
aead				endm  
# End of macro CALLMONITOR
aead					endif 
aead b7				or a        ; clear carry flag 
aeae 11 00 00			ld de, 0 
aeb1 eb				ex de,hl 
aeb2 ed 52			sbc hl, de 
aeb4 c2 3e af			jp nz, .iftrue 
aeb7			 
aeb7					if DEBUG_FORTH_WORDS 
aeb7						DMARK "IF2" 
aeb7 f5				push af  
aeb8 3a cc ae			ld a, (.dmark)  
aebb 32 65 ee			ld (debug_mark),a  
aebe 3a cd ae			ld a, (.dmark+1)  
aec1 32 66 ee			ld (debug_mark+1),a  
aec4 3a ce ae			ld a, (.dmark+2)  
aec7 32 67 ee			ld (debug_mark+2),a  
aeca 18 03			jr .pastdmark  
aecc ..			.dmark: db "IF2"  
aecf f1			.pastdmark: pop af  
aed0			endm  
# End of macro DMARK
aed0						CALLMONITOR 
aed0 cd 6f ee			call debug_vector  
aed3				endm  
# End of macro CALLMONITOR
aed3					endif 
aed3			 
aed3			; if not true then skip to THEN 
aed3			 
aed3				; TODO get tok_ptr 
aed3				; TODO consume toks until we get to THEN 
aed3			 
aed3 2a bc e5			ld hl, (os_tok_ptr) 
aed6					if DEBUG_FORTH_WORDS 
aed6						DMARK "IF3" 
aed6 f5				push af  
aed7 3a eb ae			ld a, (.dmark)  
aeda 32 65 ee			ld (debug_mark),a  
aedd 3a ec ae			ld a, (.dmark+1)  
aee0 32 66 ee			ld (debug_mark+1),a  
aee3 3a ed ae			ld a, (.dmark+2)  
aee6 32 67 ee			ld (debug_mark+2),a  
aee9 18 03			jr .pastdmark  
aeeb ..			.dmark: db "IF3"  
aeee f1			.pastdmark: pop af  
aeef			endm  
# End of macro DMARK
aeef						CALLMONITOR 
aeef cd 6f ee			call debug_vector  
aef2				endm  
# End of macro CALLMONITOR
aef2						 
aef2					endif 
aef2 11 39 af			ld de, .ifthen 
aef5					if DEBUG_FORTH_WORDS 
aef5						DMARK "IF4" 
aef5 f5				push af  
aef6 3a 0a af			ld a, (.dmark)  
aef9 32 65 ee			ld (debug_mark),a  
aefc 3a 0b af			ld a, (.dmark+1)  
aeff 32 66 ee			ld (debug_mark+1),a  
af02 3a 0c af			ld a, (.dmark+2)  
af05 32 67 ee			ld (debug_mark+2),a  
af08 18 03			jr .pastdmark  
af0a ..			.dmark: db "IF4"  
af0d f1			.pastdmark: pop af  
af0e			endm  
# End of macro DMARK
af0e						CALLMONITOR 
af0e cd 6f ee			call debug_vector  
af11				endm  
# End of macro CALLMONITOR
af11					endif 
af11 cd 7d 9f			call findnexttok  
af14			 
af14					if DEBUG_FORTH_WORDS 
af14						DMARK "IF5" 
af14 f5				push af  
af15 3a 29 af			ld a, (.dmark)  
af18 32 65 ee			ld (debug_mark),a  
af1b 3a 2a af			ld a, (.dmark+1)  
af1e 32 66 ee			ld (debug_mark+1),a  
af21 3a 2b af			ld a, (.dmark+2)  
af24 32 67 ee			ld (debug_mark+2),a  
af27 18 03			jr .pastdmark  
af29 ..			.dmark: db "IF5"  
af2c f1			.pastdmark: pop af  
af2d			endm  
# End of macro DMARK
af2d						CALLMONITOR 
af2d cd 6f ee			call debug_vector  
af30				endm  
# End of macro CALLMONITOR
af30					endif 
af30				; TODO replace below with ; exec using tok_ptr 
af30 22 bc e5			ld (os_tok_ptr), hl 
af33 c3 ff 9e			jp exec1 
af36				NEXTW 
af36 c3 76 9e			jp macro_next 
af39				endm 
# End of macro NEXTW
af39			 
af39 .. 00		.ifthen:  db "THEN",0 
af3e			 
af3e			.iftrue:		 
af3e				; Exec next words normally 
af3e			 
af3e				; if true then exec following IF as normal 
af3e					if DEBUG_FORTH_WORDS 
af3e						DMARK "IFT" 
af3e f5				push af  
af3f 3a 53 af			ld a, (.dmark)  
af42 32 65 ee			ld (debug_mark),a  
af45 3a 54 af			ld a, (.dmark+1)  
af48 32 66 ee			ld (debug_mark+1),a  
af4b 3a 55 af			ld a, (.dmark+2)  
af4e 32 67 ee			ld (debug_mark+2),a  
af51 18 03			jr .pastdmark  
af53 ..			.dmark: db "IFT"  
af56 f1			.pastdmark: pop af  
af57			endm  
# End of macro DMARK
af57						CALLMONITOR 
af57 cd 6f ee			call debug_vector  
af5a				endm  
# End of macro CALLMONITOR
af5a					endif 
af5a			 
af5a					NEXTW 
af5a c3 76 9e			jp macro_next 
af5d				endm 
# End of macro NEXTW
af5d			.THEN: 
af5d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
af5d 1f				db WORD_SYS_CORE+11             
af5e 85 af			dw .ELSE            
af60 05				db 4 + 1 
af61 .. 00			db "THEN",0              
af66				endm 
# End of macro CWHEAD
af66			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
af66					if DEBUG_FORTH_WORDS_KEY 
af66						DMARK "THN" 
af66 f5				push af  
af67 3a 7b af			ld a, (.dmark)  
af6a 32 65 ee			ld (debug_mark),a  
af6d 3a 7c af			ld a, (.dmark+1)  
af70 32 66 ee			ld (debug_mark+1),a  
af73 3a 7d af			ld a, (.dmark+2)  
af76 32 67 ee			ld (debug_mark+2),a  
af79 18 03			jr .pastdmark  
af7b ..			.dmark: db "THN"  
af7e f1			.pastdmark: pop af  
af7f			endm  
# End of macro DMARK
af7f						CALLMONITOR 
af7f cd 6f ee			call debug_vector  
af82				endm  
# End of macro CALLMONITOR
af82					endif 
af82					NEXTW 
af82 c3 76 9e			jp macro_next 
af85				endm 
# End of macro NEXTW
af85			.ELSE: 
af85				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af85 20				db WORD_SYS_CORE+12             
af86 ad af			dw .DO            
af88 03				db 2 + 1 
af89 .. 00			db "ELSE",0              
af8e				endm 
# End of macro CWHEAD
af8e			; | ELSE ( -- ) Not supported - does nothing | TODO 
af8e			 
af8e					if DEBUG_FORTH_WORDS_KEY 
af8e						DMARK "ELS" 
af8e f5				push af  
af8f 3a a3 af			ld a, (.dmark)  
af92 32 65 ee			ld (debug_mark),a  
af95 3a a4 af			ld a, (.dmark+1)  
af98 32 66 ee			ld (debug_mark+1),a  
af9b 3a a5 af			ld a, (.dmark+2)  
af9e 32 67 ee			ld (debug_mark+2),a  
afa1 18 03			jr .pastdmark  
afa3 ..			.dmark: db "ELS"  
afa6 f1			.pastdmark: pop af  
afa7			endm  
# End of macro DMARK
afa7						CALLMONITOR 
afa7 cd 6f ee			call debug_vector  
afaa				endm  
# End of macro CALLMONITOR
afaa					endif 
afaa			 
afaa			 
afaa					NEXTW 
afaa c3 76 9e			jp macro_next 
afad				endm 
# End of macro NEXTW
afad			.DO: 
afad				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
afad 21				db WORD_SYS_CORE+13             
afae d4 b0			dw .LOOP            
afb0 03				db 2 + 1 
afb1 .. 00			db "DO",0              
afb4				endm 
# End of macro CWHEAD
afb4			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
afb4			 
afb4					if DEBUG_FORTH_WORDS_KEY 
afb4						DMARK "DO." 
afb4 f5				push af  
afb5 3a c9 af			ld a, (.dmark)  
afb8 32 65 ee			ld (debug_mark),a  
afbb 3a ca af			ld a, (.dmark+1)  
afbe 32 66 ee			ld (debug_mark+1),a  
afc1 3a cb af			ld a, (.dmark+2)  
afc4 32 67 ee			ld (debug_mark+2),a  
afc7 18 03			jr .pastdmark  
afc9 ..			.dmark: db "DO."  
afcc f1			.pastdmark: pop af  
afcd			endm  
# End of macro DMARK
afcd						CALLMONITOR 
afcd cd 6f ee			call debug_vector  
afd0				endm  
# End of macro CALLMONITOR
afd0					endif 
afd0			;  push pc to rsp stack past the DO 
afd0			 
afd0 2a bc e5				ld hl, (os_tok_ptr) 
afd3 23					inc hl   ; D 
afd4 23					inc hl  ; O 
afd5 23					inc hl   ; null 
afd6					if DEBUG_FORTH_WORDS 
afd6						DMARK "DO2" 
afd6 f5				push af  
afd7 3a eb af			ld a, (.dmark)  
afda 32 65 ee			ld (debug_mark),a  
afdd 3a ec af			ld a, (.dmark+1)  
afe0 32 66 ee			ld (debug_mark+1),a  
afe3 3a ed af			ld a, (.dmark+2)  
afe6 32 67 ee			ld (debug_mark+2),a  
afe9 18 03			jr .pastdmark  
afeb ..			.dmark: db "DO2"  
afee f1			.pastdmark: pop af  
afef			endm  
# End of macro DMARK
afef						CALLMONITOR 
afef cd 6f ee			call debug_vector  
aff2				endm  
# End of macro CALLMONITOR
aff2					endif 
aff2					FORTH_RSP_NEXT 
aff2 cd 2c 9a			call macro_forth_rsp_next 
aff5				endm 
# End of macro FORTH_RSP_NEXT
aff5					if DEBUG_FORTH_WORDS 
aff5						DMARK "DO3" 
aff5 f5				push af  
aff6 3a 0a b0			ld a, (.dmark)  
aff9 32 65 ee			ld (debug_mark),a  
affc 3a 0b b0			ld a, (.dmark+1)  
afff 32 66 ee			ld (debug_mark+1),a  
b002 3a 0c b0			ld a, (.dmark+2)  
b005 32 67 ee			ld (debug_mark+2),a  
b008 18 03			jr .pastdmark  
b00a ..			.dmark: db "DO3"  
b00d f1			.pastdmark: pop af  
b00e			endm  
# End of macro DMARK
b00e						CALLMONITOR 
b00e cd 6f ee			call debug_vector  
b011				endm  
# End of macro CALLMONITOR
b011					endif 
b011			 
b011					;if DEBUG_FORTH_WORDS 
b011				;		push hl 
b011			;		endif  
b011			 
b011			; get counters from data stack 
b011			 
b011			 
b011					FORTH_DSP_VALUEHL 
b011 cd 8a 9c			call macro_dsp_valuehl 
b014				endm 
# End of macro FORTH_DSP_VALUEHL
b014 e5					push hl		 ; hl now has starting counter which needs to be tos 
b015			 
b015					if DEBUG_FORTH_WORDS 
b015						DMARK "DO4" 
b015 f5				push af  
b016 3a 2a b0			ld a, (.dmark)  
b019 32 65 ee			ld (debug_mark),a  
b01c 3a 2b b0			ld a, (.dmark+1)  
b01f 32 66 ee			ld (debug_mark+1),a  
b022 3a 2c b0			ld a, (.dmark+2)  
b025 32 67 ee			ld (debug_mark+2),a  
b028 18 03			jr .pastdmark  
b02a ..			.dmark: db "DO4"  
b02d f1			.pastdmark: pop af  
b02e			endm  
# End of macro DMARK
b02e						CALLMONITOR 
b02e cd 6f ee			call debug_vector  
b031				endm  
# End of macro CALLMONITOR
b031					endif 
b031					FORTH_DSP_POP 
b031 cd 42 9d			call macro_forth_dsp_pop 
b034				endm 
# End of macro FORTH_DSP_POP
b034			 
b034					if DEBUG_FORTH_WORDS 
b034						DMARK "DO5" 
b034 f5				push af  
b035 3a 49 b0			ld a, (.dmark)  
b038 32 65 ee			ld (debug_mark),a  
b03b 3a 4a b0			ld a, (.dmark+1)  
b03e 32 66 ee			ld (debug_mark+1),a  
b041 3a 4b b0			ld a, (.dmark+2)  
b044 32 67 ee			ld (debug_mark+2),a  
b047 18 03			jr .pastdmark  
b049 ..			.dmark: db "DO5"  
b04c f1			.pastdmark: pop af  
b04d			endm  
# End of macro DMARK
b04d						CALLMONITOR 
b04d cd 6f ee			call debug_vector  
b050				endm  
# End of macro CALLMONITOR
b050					endif 
b050			 
b050					FORTH_DSP_VALUEHL 
b050 cd 8a 9c			call macro_dsp_valuehl 
b053				endm 
# End of macro FORTH_DSP_VALUEHL
b053			;		push hl		 ; hl now has starting limit counter 
b053			 
b053					if DEBUG_FORTH_WORDS 
b053						DMARK "DO6" 
b053 f5				push af  
b054 3a 68 b0			ld a, (.dmark)  
b057 32 65 ee			ld (debug_mark),a  
b05a 3a 69 b0			ld a, (.dmark+1)  
b05d 32 66 ee			ld (debug_mark+1),a  
b060 3a 6a b0			ld a, (.dmark+2)  
b063 32 67 ee			ld (debug_mark+2),a  
b066 18 03			jr .pastdmark  
b068 ..			.dmark: db "DO6"  
b06b f1			.pastdmark: pop af  
b06c			endm  
# End of macro DMARK
b06c						CALLMONITOR 
b06c cd 6f ee			call debug_vector  
b06f				endm  
# End of macro CALLMONITOR
b06f					endif 
b06f					FORTH_DSP_POP 
b06f cd 42 9d			call macro_forth_dsp_pop 
b072				endm 
# End of macro FORTH_DSP_POP
b072			 
b072			; put counters on the loop stack 
b072			 
b072			;		pop hl			 ; limit counter 
b072 d1					pop de			; start counter 
b073			 
b073					; push limit counter 
b073			 
b073					if DEBUG_FORTH_WORDS 
b073						DMARK "DO7" 
b073 f5				push af  
b074 3a 88 b0			ld a, (.dmark)  
b077 32 65 ee			ld (debug_mark),a  
b07a 3a 89 b0			ld a, (.dmark+1)  
b07d 32 66 ee			ld (debug_mark+1),a  
b080 3a 8a b0			ld a, (.dmark+2)  
b083 32 67 ee			ld (debug_mark+2),a  
b086 18 03			jr .pastdmark  
b088 ..			.dmark: db "DO7"  
b08b f1			.pastdmark: pop af  
b08c			endm  
# End of macro DMARK
b08c						CALLMONITOR 
b08c cd 6f ee			call debug_vector  
b08f				endm  
# End of macro CALLMONITOR
b08f					endif 
b08f					FORTH_LOOP_NEXT 
b08f cd bb 9c			call macro_forth_loop_next 
b092				endm 
# End of macro FORTH_LOOP_NEXT
b092			 
b092					; push start counter 
b092			 
b092 eb					ex de, hl 
b093					if DEBUG_FORTH_WORDS 
b093						DMARK "DO7" 
b093 f5				push af  
b094 3a a8 b0			ld a, (.dmark)  
b097 32 65 ee			ld (debug_mark),a  
b09a 3a a9 b0			ld a, (.dmark+1)  
b09d 32 66 ee			ld (debug_mark+1),a  
b0a0 3a aa b0			ld a, (.dmark+2)  
b0a3 32 67 ee			ld (debug_mark+2),a  
b0a6 18 03			jr .pastdmark  
b0a8 ..			.dmark: db "DO7"  
b0ab f1			.pastdmark: pop af  
b0ac			endm  
# End of macro DMARK
b0ac						CALLMONITOR 
b0ac cd 6f ee			call debug_vector  
b0af				endm  
# End of macro CALLMONITOR
b0af					endif 
b0af					FORTH_LOOP_NEXT 
b0af cd bb 9c			call macro_forth_loop_next 
b0b2				endm 
# End of macro FORTH_LOOP_NEXT
b0b2			 
b0b2			 
b0b2					; init first round of I counter 
b0b2			 
b0b2 22 e0 e5				ld (os_current_i), hl 
b0b5			 
b0b5					if DEBUG_FORTH_WORDS 
b0b5						DMARK "DO8" 
b0b5 f5				push af  
b0b6 3a ca b0			ld a, (.dmark)  
b0b9 32 65 ee			ld (debug_mark),a  
b0bc 3a cb b0			ld a, (.dmark+1)  
b0bf 32 66 ee			ld (debug_mark+1),a  
b0c2 3a cc b0			ld a, (.dmark+2)  
b0c5 32 67 ee			ld (debug_mark+2),a  
b0c8 18 03			jr .pastdmark  
b0ca ..			.dmark: db "DO8"  
b0cd f1			.pastdmark: pop af  
b0ce			endm  
# End of macro DMARK
b0ce						CALLMONITOR 
b0ce cd 6f ee			call debug_vector  
b0d1				endm  
# End of macro CALLMONITOR
b0d1					endif 
b0d1			 
b0d1					NEXTW 
b0d1 c3 76 9e			jp macro_next 
b0d4				endm 
# End of macro NEXTW
b0d4			.LOOP: 
b0d4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b0d4 22				db WORD_SYS_CORE+14             
b0d5 ec b1			dw .I            
b0d7 05				db 4 + 1 
b0d8 .. 00			db "LOOP",0              
b0dd				endm 
# End of macro CWHEAD
b0dd			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b0dd			 
b0dd				; pop tos as current loop count to hl 
b0dd			 
b0dd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0dd			 
b0dd				FORTH_LOOP_TOS 
b0dd cd ee 9c			call macro_forth_loop_tos 
b0e0				endm 
# End of macro FORTH_LOOP_TOS
b0e0 e5				push hl 
b0e1			 
b0e1					if DEBUG_FORTH_WORDS_KEY 
b0e1						DMARK "LOP" 
b0e1 f5				push af  
b0e2 3a f6 b0			ld a, (.dmark)  
b0e5 32 65 ee			ld (debug_mark),a  
b0e8 3a f7 b0			ld a, (.dmark+1)  
b0eb 32 66 ee			ld (debug_mark+1),a  
b0ee 3a f8 b0			ld a, (.dmark+2)  
b0f1 32 67 ee			ld (debug_mark+2),a  
b0f4 18 03			jr .pastdmark  
b0f6 ..			.dmark: db "LOP"  
b0f9 f1			.pastdmark: pop af  
b0fa			endm  
# End of macro DMARK
b0fa						CALLMONITOR 
b0fa cd 6f ee			call debug_vector  
b0fd				endm  
# End of macro CALLMONITOR
b0fd					endif 
b0fd				; next item on the stack is the limit. get it 
b0fd			 
b0fd			 
b0fd				FORTH_LOOP_POP 
b0fd cd f8 9c			call macro_forth_loop_pop 
b100				endm 
# End of macro FORTH_LOOP_POP
b100			 
b100				FORTH_LOOP_TOS 
b100 cd ee 9c			call macro_forth_loop_tos 
b103				endm 
# End of macro FORTH_LOOP_TOS
b103			 
b103 d1				pop de		 ; de = i, hl = limit 
b104			 
b104					if DEBUG_FORTH_WORDS 
b104						DMARK "LP1" 
b104 f5				push af  
b105 3a 19 b1			ld a, (.dmark)  
b108 32 65 ee			ld (debug_mark),a  
b10b 3a 1a b1			ld a, (.dmark+1)  
b10e 32 66 ee			ld (debug_mark+1),a  
b111 3a 1b b1			ld a, (.dmark+2)  
b114 32 67 ee			ld (debug_mark+2),a  
b117 18 03			jr .pastdmark  
b119 ..			.dmark: db "LP1"  
b11c f1			.pastdmark: pop af  
b11d			endm  
# End of macro DMARK
b11d						CALLMONITOR 
b11d cd 6f ee			call debug_vector  
b120				endm  
# End of macro CALLMONITOR
b120					endif 
b120			 
b120				; go back to previous word 
b120			 
b120 d5				push de    ; save I for inc later 
b121			 
b121			 
b121				; get limit 
b121				;  is I at limit? 
b121			 
b121			 
b121					if DEBUG_FORTH_WORDS 
b121						DMARK "LP1" 
b121 f5				push af  
b122 3a 36 b1			ld a, (.dmark)  
b125 32 65 ee			ld (debug_mark),a  
b128 3a 37 b1			ld a, (.dmark+1)  
b12b 32 66 ee			ld (debug_mark+1),a  
b12e 3a 38 b1			ld a, (.dmark+2)  
b131 32 67 ee			ld (debug_mark+2),a  
b134 18 03			jr .pastdmark  
b136 ..			.dmark: db "LP1"  
b139 f1			.pastdmark: pop af  
b13a			endm  
# End of macro DMARK
b13a						CALLMONITOR 
b13a cd 6f ee			call debug_vector  
b13d				endm  
# End of macro CALLMONITOR
b13d					endif 
b13d			 
b13d ed 52			sbc hl, de 
b13f			 
b13f			 
b13f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b13f			 
b13f 20 26				jr nz, .loopnotdone 
b141			 
b141 e1				pop hl   ; get rid of saved I 
b142				FORTH_LOOP_POP     ; get rid of limit 
b142 cd f8 9c			call macro_forth_loop_pop 
b145				endm 
# End of macro FORTH_LOOP_POP
b145			 
b145				FORTH_RSP_POP     ; get rid of DO ptr 
b145 cd 4d 9a			call macro_forth_rsp_pop 
b148				endm 
# End of macro FORTH_RSP_POP
b148			 
b148			if DEBUG_FORTH_WORDS 
b148						DMARK "LP>" 
b148 f5				push af  
b149 3a 5d b1			ld a, (.dmark)  
b14c 32 65 ee			ld (debug_mark),a  
b14f 3a 5e b1			ld a, (.dmark+1)  
b152 32 66 ee			ld (debug_mark+1),a  
b155 3a 5f b1			ld a, (.dmark+2)  
b158 32 67 ee			ld (debug_mark+2),a  
b15b 18 03			jr .pastdmark  
b15d ..			.dmark: db "LP>"  
b160 f1			.pastdmark: pop af  
b161			endm  
# End of macro DMARK
b161				CALLMONITOR 
b161 cd 6f ee			call debug_vector  
b164				endm  
# End of macro CALLMONITOR
b164			endif 
b164			 
b164					NEXTW 
b164 c3 76 9e			jp macro_next 
b167				endm 
# End of macro NEXTW
b167				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b167			 
b167			.loopnotdone: 
b167			 
b167 e1				pop hl    ; get I 
b168 23				inc hl 
b169			 
b169			   	; save new I 
b169			 
b169			 
b169					; set I counter 
b169			 
b169 22 e0 e5				ld (os_current_i), hl 
b16c			 
b16c					if DEBUG_FORTH_WORDS 
b16c						DMARK "LPN" 
b16c f5				push af  
b16d 3a 81 b1			ld a, (.dmark)  
b170 32 65 ee			ld (debug_mark),a  
b173 3a 82 b1			ld a, (.dmark+1)  
b176 32 66 ee			ld (debug_mark+1),a  
b179 3a 83 b1			ld a, (.dmark+2)  
b17c 32 67 ee			ld (debug_mark+2),a  
b17f 18 03			jr .pastdmark  
b181 ..			.dmark: db "LPN"  
b184 f1			.pastdmark: pop af  
b185			endm  
# End of macro DMARK
b185					CALLMONITOR 
b185 cd 6f ee			call debug_vector  
b188				endm  
# End of macro CALLMONITOR
b188					endif 
b188					 
b188				FORTH_LOOP_NEXT 
b188 cd bb 9c			call macro_forth_loop_next 
b18b				endm 
# End of macro FORTH_LOOP_NEXT
b18b			 
b18b			 
b18b					if DEBUG_FORTH_WORDS 
b18b eb						ex de,hl 
b18c					endif 
b18c			 
b18c			;	; get DO ptr 
b18c			; 
b18c					if DEBUG_FORTH_WORDS 
b18c						DMARK "LP7" 
b18c f5				push af  
b18d 3a a1 b1			ld a, (.dmark)  
b190 32 65 ee			ld (debug_mark),a  
b193 3a a2 b1			ld a, (.dmark+1)  
b196 32 66 ee			ld (debug_mark+1),a  
b199 3a a3 b1			ld a, (.dmark+2)  
b19c 32 67 ee			ld (debug_mark+2),a  
b19f 18 03			jr .pastdmark  
b1a1 ..			.dmark: db "LP7"  
b1a4 f1			.pastdmark: pop af  
b1a5			endm  
# End of macro DMARK
b1a5					CALLMONITOR 
b1a5 cd 6f ee			call debug_vector  
b1a8				endm  
# End of macro CALLMONITOR
b1a8					endif 
b1a8				FORTH_RSP_TOS 
b1a8 cd 43 9a			call macro_forth_rsp_tos 
b1ab				endm 
# End of macro FORTH_RSP_TOS
b1ab			 
b1ab					if DEBUG_FORTH_WORDS 
b1ab						DMARK "LP8" 
b1ab f5				push af  
b1ac 3a c0 b1			ld a, (.dmark)  
b1af 32 65 ee			ld (debug_mark),a  
b1b2 3a c1 b1			ld a, (.dmark+1)  
b1b5 32 66 ee			ld (debug_mark+1),a  
b1b8 3a c2 b1			ld a, (.dmark+2)  
b1bb 32 67 ee			ld (debug_mark+2),a  
b1be 18 03			jr .pastdmark  
b1c0 ..			.dmark: db "LP8"  
b1c3 f1			.pastdmark: pop af  
b1c4			endm  
# End of macro DMARK
b1c4					CALLMONITOR 
b1c4 cd 6f ee			call debug_vector  
b1c7				endm  
# End of macro CALLMONITOR
b1c7					endif 
b1c7				;push hl 
b1c7			 
b1c7				; not going to DO any more 
b1c7				; get rid of the RSP pointer as DO will add it back in 
b1c7				;FORTH_RSP_POP 
b1c7				;pop hl 
b1c7			 
b1c7				;ld hl,(cli_ret_sp) 
b1c7				;ld e, (hl) 
b1c7				;inc hl 
b1c7				;ld d, (hl) 
b1c7				;ex de,hl 
b1c7 22 bc e5			ld (os_tok_ptr), hl 
b1ca					if DEBUG_FORTH_WORDS 
b1ca						DMARK "LP<" 
b1ca f5				push af  
b1cb 3a df b1			ld a, (.dmark)  
b1ce 32 65 ee			ld (debug_mark),a  
b1d1 3a e0 b1			ld a, (.dmark+1)  
b1d4 32 66 ee			ld (debug_mark+1),a  
b1d7 3a e1 b1			ld a, (.dmark+2)  
b1da 32 67 ee			ld (debug_mark+2),a  
b1dd 18 03			jr .pastdmark  
b1df ..			.dmark: db "LP<"  
b1e2 f1			.pastdmark: pop af  
b1e3			endm  
# End of macro DMARK
b1e3					CALLMONITOR 
b1e3 cd 6f ee			call debug_vector  
b1e6				endm  
# End of macro CALLMONITOR
b1e6				endif 
b1e6 c3 ff 9e			jp exec1 
b1e9			 
b1e9					 
b1e9			 
b1e9			 
b1e9					NEXTW 
b1e9 c3 76 9e			jp macro_next 
b1ec				endm 
# End of macro NEXTW
b1ec			.I:  
b1ec			 
b1ec				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b1ec 5e				db WORD_SYS_CORE+74             
b1ed 17 b2			dw .DLOOP            
b1ef 02				db 1 + 1 
b1f0 .. 00			db "I",0              
b1f2				endm 
# End of macro CWHEAD
b1f2			; | I ( -- ) Current loop counter | DONE 
b1f2					if DEBUG_FORTH_WORDS_KEY 
b1f2						DMARK "I.." 
b1f2 f5				push af  
b1f3 3a 07 b2			ld a, (.dmark)  
b1f6 32 65 ee			ld (debug_mark),a  
b1f9 3a 08 b2			ld a, (.dmark+1)  
b1fc 32 66 ee			ld (debug_mark+1),a  
b1ff 3a 09 b2			ld a, (.dmark+2)  
b202 32 67 ee			ld (debug_mark+2),a  
b205 18 03			jr .pastdmark  
b207 ..			.dmark: db "I.."  
b20a f1			.pastdmark: pop af  
b20b			endm  
# End of macro DMARK
b20b						CALLMONITOR 
b20b cd 6f ee			call debug_vector  
b20e				endm  
# End of macro CALLMONITOR
b20e					endif 
b20e			 
b20e 2a e0 e5				ld hl,(os_current_i) 
b211 cd 85 9a				call forth_push_numhl 
b214			 
b214					NEXTW 
b214 c3 76 9e			jp macro_next 
b217				endm 
# End of macro NEXTW
b217			.DLOOP: 
b217				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b217 5f				db WORD_SYS_CORE+75             
b218 f8 b2			dw .REPEAT            
b21a 06				db 5 + 1 
b21b .. 00			db "-LOOP",0              
b221				endm 
# End of macro CWHEAD
b221			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b221				; pop tos as current loop count to hl 
b221					if DEBUG_FORTH_WORDS_KEY 
b221						DMARK "-LP" 
b221 f5				push af  
b222 3a 36 b2			ld a, (.dmark)  
b225 32 65 ee			ld (debug_mark),a  
b228 3a 37 b2			ld a, (.dmark+1)  
b22b 32 66 ee			ld (debug_mark+1),a  
b22e 3a 38 b2			ld a, (.dmark+2)  
b231 32 67 ee			ld (debug_mark+2),a  
b234 18 03			jr .pastdmark  
b236 ..			.dmark: db "-LP"  
b239 f1			.pastdmark: pop af  
b23a			endm  
# End of macro DMARK
b23a						CALLMONITOR 
b23a cd 6f ee			call debug_vector  
b23d				endm  
# End of macro CALLMONITOR
b23d					endif 
b23d			 
b23d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b23d			 
b23d				FORTH_LOOP_TOS 
b23d cd ee 9c			call macro_forth_loop_tos 
b240				endm 
# End of macro FORTH_LOOP_TOS
b240 e5				push hl 
b241			 
b241					if DEBUG_FORTH_WORDS 
b241						DMARK "-LP" 
b241 f5				push af  
b242 3a 56 b2			ld a, (.dmark)  
b245 32 65 ee			ld (debug_mark),a  
b248 3a 57 b2			ld a, (.dmark+1)  
b24b 32 66 ee			ld (debug_mark+1),a  
b24e 3a 58 b2			ld a, (.dmark+2)  
b251 32 67 ee			ld (debug_mark+2),a  
b254 18 03			jr .pastdmark  
b256 ..			.dmark: db "-LP"  
b259 f1			.pastdmark: pop af  
b25a			endm  
# End of macro DMARK
b25a						CALLMONITOR 
b25a cd 6f ee			call debug_vector  
b25d				endm  
# End of macro CALLMONITOR
b25d					endif 
b25d				; next item on the stack is the limit. get it 
b25d			 
b25d			 
b25d				FORTH_LOOP_POP 
b25d cd f8 9c			call macro_forth_loop_pop 
b260				endm 
# End of macro FORTH_LOOP_POP
b260			 
b260				FORTH_LOOP_TOS 
b260 cd ee 9c			call macro_forth_loop_tos 
b263				endm 
# End of macro FORTH_LOOP_TOS
b263			 
b263 d1				pop de		 ; de = i, hl = limit 
b264			 
b264					if DEBUG_FORTH_WORDS 
b264						DMARK "-L1" 
b264 f5				push af  
b265 3a 79 b2			ld a, (.dmark)  
b268 32 65 ee			ld (debug_mark),a  
b26b 3a 7a b2			ld a, (.dmark+1)  
b26e 32 66 ee			ld (debug_mark+1),a  
b271 3a 7b b2			ld a, (.dmark+2)  
b274 32 67 ee			ld (debug_mark+2),a  
b277 18 03			jr .pastdmark  
b279 ..			.dmark: db "-L1"  
b27c f1			.pastdmark: pop af  
b27d			endm  
# End of macro DMARK
b27d						CALLMONITOR 
b27d cd 6f ee			call debug_vector  
b280				endm  
# End of macro CALLMONITOR
b280					endif 
b280			 
b280				; go back to previous word 
b280			 
b280 d5				push de    ; save I for inc later 
b281			 
b281			 
b281				; get limit 
b281				;  is I at limit? 
b281			 
b281			 
b281					if DEBUG_FORTH_WORDS 
b281						DMARK "-L1" 
b281 f5				push af  
b282 3a 96 b2			ld a, (.dmark)  
b285 32 65 ee			ld (debug_mark),a  
b288 3a 97 b2			ld a, (.dmark+1)  
b28b 32 66 ee			ld (debug_mark+1),a  
b28e 3a 98 b2			ld a, (.dmark+2)  
b291 32 67 ee			ld (debug_mark+2),a  
b294 18 03			jr .pastdmark  
b296 ..			.dmark: db "-L1"  
b299 f1			.pastdmark: pop af  
b29a			endm  
# End of macro DMARK
b29a						CALLMONITOR 
b29a cd 6f ee			call debug_vector  
b29d				endm  
# End of macro CALLMONITOR
b29d					endif 
b29d			 
b29d ed 52			sbc hl, de 
b29f			 
b29f			 
b29f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b29f			 
b29f 20 26				jr nz, .mloopnotdone 
b2a1			 
b2a1 e1				pop hl   ; get rid of saved I 
b2a2				FORTH_LOOP_POP     ; get rid of limit 
b2a2 cd f8 9c			call macro_forth_loop_pop 
b2a5				endm 
# End of macro FORTH_LOOP_POP
b2a5			 
b2a5				FORTH_RSP_POP     ; get rid of DO ptr 
b2a5 cd 4d 9a			call macro_forth_rsp_pop 
b2a8				endm 
# End of macro FORTH_RSP_POP
b2a8			 
b2a8			if DEBUG_FORTH_WORDS 
b2a8						DMARK "-L>" 
b2a8 f5				push af  
b2a9 3a bd b2			ld a, (.dmark)  
b2ac 32 65 ee			ld (debug_mark),a  
b2af 3a be b2			ld a, (.dmark+1)  
b2b2 32 66 ee			ld (debug_mark+1),a  
b2b5 3a bf b2			ld a, (.dmark+2)  
b2b8 32 67 ee			ld (debug_mark+2),a  
b2bb 18 03			jr .pastdmark  
b2bd ..			.dmark: db "-L>"  
b2c0 f1			.pastdmark: pop af  
b2c1			endm  
# End of macro DMARK
b2c1				CALLMONITOR 
b2c1 cd 6f ee			call debug_vector  
b2c4				endm  
# End of macro CALLMONITOR
b2c4			endif 
b2c4			 
b2c4					NEXTW 
b2c4 c3 76 9e			jp macro_next 
b2c7				endm 
# End of macro NEXTW
b2c7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2c7			 
b2c7			.mloopnotdone: 
b2c7			 
b2c7 e1				pop hl    ; get I 
b2c8 2b				dec hl 
b2c9			 
b2c9			   	; save new I 
b2c9			 
b2c9			 
b2c9					; set I counter 
b2c9			 
b2c9 22 e0 e5				ld (os_current_i), hl 
b2cc			 
b2cc					 
b2cc				FORTH_LOOP_NEXT 
b2cc cd bb 9c			call macro_forth_loop_next 
b2cf				endm 
# End of macro FORTH_LOOP_NEXT
b2cf			 
b2cf			 
b2cf					if DEBUG_FORTH_WORDS 
b2cf eb						ex de,hl 
b2d0					endif 
b2d0			 
b2d0			;	; get DO ptr 
b2d0			; 
b2d0				FORTH_RSP_TOS 
b2d0 cd 43 9a			call macro_forth_rsp_tos 
b2d3				endm 
# End of macro FORTH_RSP_TOS
b2d3			 
b2d3				;push hl 
b2d3			 
b2d3				; not going to DO any more 
b2d3				; get rid of the RSP pointer as DO will add it back in 
b2d3				;FORTH_RSP_POP 
b2d3				;pop hl 
b2d3			 
b2d3			 
b2d3 22 bc e5			ld (os_tok_ptr), hl 
b2d6					if DEBUG_FORTH_WORDS 
b2d6						DMARK "-L<" 
b2d6 f5				push af  
b2d7 3a eb b2			ld a, (.dmark)  
b2da 32 65 ee			ld (debug_mark),a  
b2dd 3a ec b2			ld a, (.dmark+1)  
b2e0 32 66 ee			ld (debug_mark+1),a  
b2e3 3a ed b2			ld a, (.dmark+2)  
b2e6 32 67 ee			ld (debug_mark+2),a  
b2e9 18 03			jr .pastdmark  
b2eb ..			.dmark: db "-L<"  
b2ee f1			.pastdmark: pop af  
b2ef			endm  
# End of macro DMARK
b2ef					CALLMONITOR 
b2ef cd 6f ee			call debug_vector  
b2f2				endm  
# End of macro CALLMONITOR
b2f2				endif 
b2f2 c3 ff 9e			jp exec1 
b2f5			 
b2f5					 
b2f5			 
b2f5			 
b2f5			 
b2f5				NEXTW 
b2f5 c3 76 9e			jp macro_next 
b2f8				endm 
# End of macro NEXTW
b2f8			 
b2f8			 
b2f8			 
b2f8			 
b2f8			.REPEAT: 
b2f8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b2f8 71				db WORD_SYS_CORE+93             
b2f9 4b b3			dw .UNTIL            
b2fb 06				db 5 + 1 
b2fc .. 00			db "REPEAT",0              
b303				endm 
# End of macro CWHEAD
b303			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b303			;  push pc to rsp stack past the REPEAT 
b303					if DEBUG_FORTH_WORDS_KEY 
b303						DMARK "REP" 
b303 f5				push af  
b304 3a 18 b3			ld a, (.dmark)  
b307 32 65 ee			ld (debug_mark),a  
b30a 3a 19 b3			ld a, (.dmark+1)  
b30d 32 66 ee			ld (debug_mark+1),a  
b310 3a 1a b3			ld a, (.dmark+2)  
b313 32 67 ee			ld (debug_mark+2),a  
b316 18 03			jr .pastdmark  
b318 ..			.dmark: db "REP"  
b31b f1			.pastdmark: pop af  
b31c			endm  
# End of macro DMARK
b31c						CALLMONITOR 
b31c cd 6f ee			call debug_vector  
b31f				endm  
# End of macro CALLMONITOR
b31f					endif 
b31f			 
b31f 2a bc e5				ld hl, (os_tok_ptr) 
b322 23					inc hl   ; R 
b323 23					inc hl  ; E 
b324 23					inc hl   ; P 
b325 23					inc hl   ; E 
b326 23					inc hl   ; A 
b327 23					inc hl   ; T 
b328 23					inc hl   ; zero 
b329					FORTH_RSP_NEXT 
b329 cd 2c 9a			call macro_forth_rsp_next 
b32c				endm 
# End of macro FORTH_RSP_NEXT
b32c			 
b32c			 
b32c					if DEBUG_FORTH_WORDS 
b32c						DMARK "REP" 
b32c f5				push af  
b32d 3a 41 b3			ld a, (.dmark)  
b330 32 65 ee			ld (debug_mark),a  
b333 3a 42 b3			ld a, (.dmark+1)  
b336 32 66 ee			ld (debug_mark+1),a  
b339 3a 43 b3			ld a, (.dmark+2)  
b33c 32 67 ee			ld (debug_mark+2),a  
b33f 18 03			jr .pastdmark  
b341 ..			.dmark: db "REP"  
b344 f1			.pastdmark: pop af  
b345			endm  
# End of macro DMARK
b345						;pop bc    ; TODO BUG ?????? what is this for???? 
b345						CALLMONITOR 
b345 cd 6f ee			call debug_vector  
b348				endm  
# End of macro CALLMONITOR
b348					endif 
b348			 
b348					NEXTW 
b348 c3 76 9e			jp macro_next 
b34b				endm 
# End of macro NEXTW
b34b			;	       NEXTW 
b34b			 
b34b			.UNTIL: 
b34b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b34b 72				db WORD_SYS_CORE+94             
b34c e2 b3			dw .ENDFLOW            
b34e 06				db 5 + 1 
b34f .. 00			db "UNTIL",0              
b355				endm 
# End of macro CWHEAD
b355			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b355			 
b355				; pop tos as check 
b355			 
b355				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b355			 
b355				FORTH_DSP_VALUEHL 
b355 cd 8a 9c			call macro_dsp_valuehl 
b358				endm 
# End of macro FORTH_DSP_VALUEHL
b358			 
b358					if DEBUG_FORTH_WORDS_KEY 
b358						DMARK "UNT" 
b358 f5				push af  
b359 3a 6d b3			ld a, (.dmark)  
b35c 32 65 ee			ld (debug_mark),a  
b35f 3a 6e b3			ld a, (.dmark+1)  
b362 32 66 ee			ld (debug_mark+1),a  
b365 3a 6f b3			ld a, (.dmark+2)  
b368 32 67 ee			ld (debug_mark+2),a  
b36b 18 03			jr .pastdmark  
b36d ..			.dmark: db "UNT"  
b370 f1			.pastdmark: pop af  
b371			endm  
# End of macro DMARK
b371						CALLMONITOR 
b371 cd 6f ee			call debug_vector  
b374				endm  
# End of macro CALLMONITOR
b374					endif 
b374			 
b374			;	push hl 
b374				FORTH_DSP_POP 
b374 cd 42 9d			call macro_forth_dsp_pop 
b377				endm 
# End of macro FORTH_DSP_POP
b377			 
b377			;	pop hl 
b377			 
b377				; test if true 
b377			 
b377 cd 13 8d			call ishlzero 
b37a			;	ld a,l 
b37a			;	add h 
b37a			; 
b37a			;	cp 0 
b37a			 
b37a 20 3e			jr nz, .untilnotdone 
b37c			 
b37c					if DEBUG_FORTH_WORDS 
b37c						DMARK "UNf" 
b37c f5				push af  
b37d 3a 91 b3			ld a, (.dmark)  
b380 32 65 ee			ld (debug_mark),a  
b383 3a 92 b3			ld a, (.dmark+1)  
b386 32 66 ee			ld (debug_mark+1),a  
b389 3a 93 b3			ld a, (.dmark+2)  
b38c 32 67 ee			ld (debug_mark+2),a  
b38f 18 03			jr .pastdmark  
b391 ..			.dmark: db "UNf"  
b394 f1			.pastdmark: pop af  
b395			endm  
# End of macro DMARK
b395						CALLMONITOR 
b395 cd 6f ee			call debug_vector  
b398				endm  
# End of macro CALLMONITOR
b398					endif 
b398			 
b398			 
b398			 
b398				FORTH_RSP_POP     ; get rid of DO ptr 
b398 cd 4d 9a			call macro_forth_rsp_pop 
b39b				endm 
# End of macro FORTH_RSP_POP
b39b			 
b39b			if DEBUG_FORTH_WORDS 
b39b						DMARK "UN>" 
b39b f5				push af  
b39c 3a b0 b3			ld a, (.dmark)  
b39f 32 65 ee			ld (debug_mark),a  
b3a2 3a b1 b3			ld a, (.dmark+1)  
b3a5 32 66 ee			ld (debug_mark+1),a  
b3a8 3a b2 b3			ld a, (.dmark+2)  
b3ab 32 67 ee			ld (debug_mark+2),a  
b3ae 18 03			jr .pastdmark  
b3b0 ..			.dmark: db "UN>"  
b3b3 f1			.pastdmark: pop af  
b3b4			endm  
# End of macro DMARK
b3b4				CALLMONITOR 
b3b4 cd 6f ee			call debug_vector  
b3b7				endm  
# End of macro CALLMONITOR
b3b7			endif 
b3b7			 
b3b7					NEXTW 
b3b7 c3 76 9e			jp macro_next 
b3ba				endm 
# End of macro NEXTW
b3ba				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b3ba			 
b3ba			.untilnotdone: 
b3ba			 
b3ba			 
b3ba			;	; get DO ptr 
b3ba			; 
b3ba				FORTH_RSP_TOS 
b3ba cd 43 9a			call macro_forth_rsp_tos 
b3bd				endm 
# End of macro FORTH_RSP_TOS
b3bd			 
b3bd				;push hl 
b3bd			 
b3bd				; not going to DO any more 
b3bd				; get rid of the RSP pointer as DO will add it back in 
b3bd				;FORTH_RSP_POP 
b3bd				;pop hl 
b3bd			 
b3bd			 
b3bd 22 bc e5			ld (os_tok_ptr), hl 
b3c0					if DEBUG_FORTH_WORDS 
b3c0						DMARK "UN<" 
b3c0 f5				push af  
b3c1 3a d5 b3			ld a, (.dmark)  
b3c4 32 65 ee			ld (debug_mark),a  
b3c7 3a d6 b3			ld a, (.dmark+1)  
b3ca 32 66 ee			ld (debug_mark+1),a  
b3cd 3a d7 b3			ld a, (.dmark+2)  
b3d0 32 67 ee			ld (debug_mark+2),a  
b3d3 18 03			jr .pastdmark  
b3d5 ..			.dmark: db "UN<"  
b3d8 f1			.pastdmark: pop af  
b3d9			endm  
# End of macro DMARK
b3d9					CALLMONITOR 
b3d9 cd 6f ee			call debug_vector  
b3dc				endm  
# End of macro CALLMONITOR
b3dc				endif 
b3dc c3 ff 9e			jp exec1 
b3df			 
b3df					 
b3df			 
b3df			 
b3df					NEXTW 
b3df c3 76 9e			jp macro_next 
b3e2				endm 
# End of macro NEXTW
b3e2			 
b3e2			 
b3e2			.ENDFLOW: 
b3e2			 
b3e2			; eof 
b3e2			 
# End of file forth_words_flow.asm
b3e2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b3e2			include "forth_words_logic.asm" 
b3e2			 
b3e2			; | ## Logic Words 
b3e2			 
b3e2			.NOT: 
b3e2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b3e2 2d				db WORD_SYS_CORE+25             
b3e3 2a b4			dw .IS            
b3e5 04				db 3 + 1 
b3e6 .. 00			db "NOT",0              
b3ea				endm 
# End of macro CWHEAD
b3ea			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b3ea					if DEBUG_FORTH_WORDS_KEY 
b3ea						DMARK "NOT" 
b3ea f5				push af  
b3eb 3a ff b3			ld a, (.dmark)  
b3ee 32 65 ee			ld (debug_mark),a  
b3f1 3a 00 b4			ld a, (.dmark+1)  
b3f4 32 66 ee			ld (debug_mark+1),a  
b3f7 3a 01 b4			ld a, (.dmark+2)  
b3fa 32 67 ee			ld (debug_mark+2),a  
b3fd 18 03			jr .pastdmark  
b3ff ..			.dmark: db "NOT"  
b402 f1			.pastdmark: pop af  
b403			endm  
# End of macro DMARK
b403						CALLMONITOR 
b403 cd 6f ee			call debug_vector  
b406				endm  
# End of macro CALLMONITOR
b406					endif 
b406					FORTH_DSP 
b406 cd 50 9c			call macro_forth_dsp 
b409				endm 
# End of macro FORTH_DSP
b409 7e					ld a,(hl)	; get type of value on TOS 
b40a fe 02				cp DS_TYPE_INUM  
b40c 28 03				jr z, .noti 
b40e					NEXTW 
b40e c3 76 9e			jp macro_next 
b411				endm 
# End of macro NEXTW
b411			.noti:          FORTH_DSP_VALUEHL 
b411 cd 8a 9c			call macro_dsp_valuehl 
b414				endm 
# End of macro FORTH_DSP_VALUEHL
b414			;		push hl 
b414					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b414 cd 42 9d			call macro_forth_dsp_pop 
b417				endm 
# End of macro FORTH_DSP_POP
b417			;		pop hl 
b417 3e 00				ld a,0 
b419 bd					cp l 
b41a 28 04				jr z, .not2t 
b41c 2e 00				ld l, 0 
b41e 18 02				jr .notip 
b420			 
b420 2e ff		.not2t:		ld l, 255 
b422			 
b422 26 00		.notip:		ld h, 0	 
b424			 
b424 cd 85 9a				call forth_push_numhl 
b427					NEXTW 
b427 c3 76 9e			jp macro_next 
b42a				endm 
# End of macro NEXTW
b42a			 
b42a			.IS: 
b42a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b42a 2d				db WORD_SYS_CORE+25             
b42b 50 b4			dw .LZERO            
b42d 03				db 2 + 1 
b42e .. 00			db "IS",0              
b431				endm 
# End of macro CWHEAD
b431			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b431					if DEBUG_FORTH_WORDS_KEY 
b431						DMARK "IS." 
b431 f5				push af  
b432 3a 46 b4			ld a, (.dmark)  
b435 32 65 ee			ld (debug_mark),a  
b438 3a 47 b4			ld a, (.dmark+1)  
b43b 32 66 ee			ld (debug_mark+1),a  
b43e 3a 48 b4			ld a, (.dmark+2)  
b441 32 67 ee			ld (debug_mark+2),a  
b444 18 03			jr .pastdmark  
b446 ..			.dmark: db "IS."  
b449 f1			.pastdmark: pop af  
b44a			endm  
# End of macro DMARK
b44a						CALLMONITOR 
b44a cd 6f ee			call debug_vector  
b44d				endm  
# End of macro CALLMONITOR
b44d					endif 
b44d					NEXTW 
b44d c3 76 9e			jp macro_next 
b450				endm 
# End of macro NEXTW
b450			.LZERO: 
b450				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b450 2d				db WORD_SYS_CORE+25             
b451 5a b4			dw .TZERO            
b453 03				db 2 + 1 
b454 .. 00			db "0<",0              
b457				endm 
# End of macro CWHEAD
b457			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b457					NEXTW 
b457 c3 76 9e			jp macro_next 
b45a				endm 
# End of macro NEXTW
b45a			.TZERO: 
b45a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b45a 2e				db WORD_SYS_CORE+26             
b45b a1 b4			dw .LESS            
b45d 03				db 2 + 1 
b45e .. 00			db "0=",0              
b461				endm 
# End of macro CWHEAD
b461			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b461				; TODO add floating point number detection 
b461					;v5 FORTH_DSP_VALUE 
b461					if DEBUG_FORTH_WORDS_KEY 
b461						DMARK "0=." 
b461 f5				push af  
b462 3a 76 b4			ld a, (.dmark)  
b465 32 65 ee			ld (debug_mark),a  
b468 3a 77 b4			ld a, (.dmark+1)  
b46b 32 66 ee			ld (debug_mark+1),a  
b46e 3a 78 b4			ld a, (.dmark+2)  
b471 32 67 ee			ld (debug_mark+2),a  
b474 18 03			jr .pastdmark  
b476 ..			.dmark: db "0=."  
b479 f1			.pastdmark: pop af  
b47a			endm  
# End of macro DMARK
b47a						CALLMONITOR 
b47a cd 6f ee			call debug_vector  
b47d				endm  
# End of macro CALLMONITOR
b47d					endif 
b47d					FORTH_DSP 
b47d cd 50 9c			call macro_forth_dsp 
b480				endm 
# End of macro FORTH_DSP
b480 7e					ld a,(hl)	; get type of value on TOS 
b481 fe 02				cp DS_TYPE_INUM  
b483 28 00				jr z, .tz_inum 
b485			 
b485				if FORTH_ENABLE_FLOATMATH 
b485					jr .tz_done 
b485			 
b485				endif 
b485					 
b485			 
b485			.tz_inum: 
b485					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b485 cd 8a 9c			call macro_dsp_valuehl 
b488				endm 
# End of macro FORTH_DSP_VALUEHL
b488			 
b488			;		push hl 
b488			 
b488					; destroy value TOS 
b488			 
b488					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b488 cd 42 9d			call macro_forth_dsp_pop 
b48b				endm 
# End of macro FORTH_DSP_POP
b48b			 
b48b			;		pop hl 
b48b			 
b48b 3e 00				ld a,0 
b48d			 
b48d bd					cp l 
b48e 20 08				jr nz, .tz_notzero 
b490			 
b490 bc					cp h 
b491			 
b491 20 05				jr nz, .tz_notzero 
b493			 
b493			 
b493 21 01 00				ld hl, FORTH_TRUE 
b496 18 03				jr .tz_done 
b498			 
b498 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b49b			 
b49b					; push value back onto stack for another op etc 
b49b			 
b49b			.tz_done: 
b49b cd 85 9a				call forth_push_numhl 
b49e			 
b49e					NEXTW 
b49e c3 76 9e			jp macro_next 
b4a1				endm 
# End of macro NEXTW
b4a1			.LESS: 
b4a1				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b4a1 2f				db WORD_SYS_CORE+27             
b4a2 0a b5			dw .GT            
b4a4 02				db 1 + 1 
b4a5 .. 00			db "<",0              
b4a7				endm 
# End of macro CWHEAD
b4a7			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b4a7				; TODO add floating point number detection 
b4a7					if DEBUG_FORTH_WORDS_KEY 
b4a7						DMARK "LES" 
b4a7 f5				push af  
b4a8 3a bc b4			ld a, (.dmark)  
b4ab 32 65 ee			ld (debug_mark),a  
b4ae 3a bd b4			ld a, (.dmark+1)  
b4b1 32 66 ee			ld (debug_mark+1),a  
b4b4 3a be b4			ld a, (.dmark+2)  
b4b7 32 67 ee			ld (debug_mark+2),a  
b4ba 18 03			jr .pastdmark  
b4bc ..			.dmark: db "LES"  
b4bf f1			.pastdmark: pop af  
b4c0			endm  
# End of macro DMARK
b4c0						CALLMONITOR 
b4c0 cd 6f ee			call debug_vector  
b4c3				endm  
# End of macro CALLMONITOR
b4c3					endif 
b4c3					FORTH_DSP 
b4c3 cd 50 9c			call macro_forth_dsp 
b4c6				endm 
# End of macro FORTH_DSP
b4c6					;v5 FORTH_DSP_VALUE 
b4c6 7e					ld a,(hl)	; get type of value on TOS 
b4c7 fe 02				cp DS_TYPE_INUM  
b4c9 28 00				jr z, .less_inum 
b4cb			 
b4cb				if FORTH_ENABLE_FLOATMATH 
b4cb					jr .less_done 
b4cb			 
b4cb				endif 
b4cb					 
b4cb			 
b4cb			.less_inum: 
b4cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4cb cd 8a 9c			call macro_dsp_valuehl 
b4ce				endm 
# End of macro FORTH_DSP_VALUEHL
b4ce			 
b4ce e5					push hl  ; u2 
b4cf			 
b4cf					; destroy value TOS 
b4cf			 
b4cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4cf cd 42 9d			call macro_forth_dsp_pop 
b4d2				endm 
# End of macro FORTH_DSP_POP
b4d2			 
b4d2			 
b4d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d2 cd 8a 9c			call macro_dsp_valuehl 
b4d5				endm 
# End of macro FORTH_DSP_VALUEHL
b4d5			 
b4d5 e5					push hl    ; u1 
b4d6			 
b4d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d6 cd 42 9d			call macro_forth_dsp_pop 
b4d9				endm 
# End of macro FORTH_DSP_POP
b4d9			 
b4d9			 
b4d9 b7			 or a      ;clear carry flag 
b4da 01 00 00		 ld bc, FORTH_FALSE 
b4dd e1			  pop hl    ; u1 
b4de d1			  pop de    ; u2 
b4df ed 52		  sbc hl,de 
b4e1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b4e3			 
b4e3 01 01 00		 ld bc, FORTH_TRUE 
b4e6			.lscont:  
b4e6 c5					push bc 
b4e7 e1					pop hl 
b4e8			 
b4e8					if DEBUG_FORTH_WORDS 
b4e8						DMARK "LT1" 
b4e8 f5				push af  
b4e9 3a fd b4			ld a, (.dmark)  
b4ec 32 65 ee			ld (debug_mark),a  
b4ef 3a fe b4			ld a, (.dmark+1)  
b4f2 32 66 ee			ld (debug_mark+1),a  
b4f5 3a ff b4			ld a, (.dmark+2)  
b4f8 32 67 ee			ld (debug_mark+2),a  
b4fb 18 03			jr .pastdmark  
b4fd ..			.dmark: db "LT1"  
b500 f1			.pastdmark: pop af  
b501			endm  
# End of macro DMARK
b501						CALLMONITOR 
b501 cd 6f ee			call debug_vector  
b504				endm  
# End of macro CALLMONITOR
b504					endif 
b504 cd 85 9a				call forth_push_numhl 
b507			 
b507					NEXTW 
b507 c3 76 9e			jp macro_next 
b50a				endm 
# End of macro NEXTW
b50a			.GT: 
b50a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b50a 30				db WORD_SYS_CORE+28             
b50b 73 b5			dw .EQUAL            
b50d 02				db 1 + 1 
b50e .. 00			db ">",0              
b510				endm 
# End of macro CWHEAD
b510			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b510				; TODO add floating point number detection 
b510					if DEBUG_FORTH_WORDS_KEY 
b510						DMARK "GRT" 
b510 f5				push af  
b511 3a 25 b5			ld a, (.dmark)  
b514 32 65 ee			ld (debug_mark),a  
b517 3a 26 b5			ld a, (.dmark+1)  
b51a 32 66 ee			ld (debug_mark+1),a  
b51d 3a 27 b5			ld a, (.dmark+2)  
b520 32 67 ee			ld (debug_mark+2),a  
b523 18 03			jr .pastdmark  
b525 ..			.dmark: db "GRT"  
b528 f1			.pastdmark: pop af  
b529			endm  
# End of macro DMARK
b529						CALLMONITOR 
b529 cd 6f ee			call debug_vector  
b52c				endm  
# End of macro CALLMONITOR
b52c					endif 
b52c					FORTH_DSP 
b52c cd 50 9c			call macro_forth_dsp 
b52f				endm 
# End of macro FORTH_DSP
b52f					;FORTH_DSP_VALUE 
b52f 7e					ld a,(hl)	; get type of value on TOS 
b530 fe 02				cp DS_TYPE_INUM  
b532 28 00				jr z, .gt_inum 
b534			 
b534				if FORTH_ENABLE_FLOATMATH 
b534					jr .gt_done 
b534			 
b534				endif 
b534					 
b534			 
b534			.gt_inum: 
b534					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b534 cd 8a 9c			call macro_dsp_valuehl 
b537				endm 
# End of macro FORTH_DSP_VALUEHL
b537			 
b537 e5					push hl  ; u2 
b538			 
b538					; destroy value TOS 
b538			 
b538					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b538 cd 42 9d			call macro_forth_dsp_pop 
b53b				endm 
# End of macro FORTH_DSP_POP
b53b			 
b53b			 
b53b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b53b cd 8a 9c			call macro_dsp_valuehl 
b53e				endm 
# End of macro FORTH_DSP_VALUEHL
b53e			 
b53e e5					push hl    ; u1 
b53f			 
b53f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b53f cd 42 9d			call macro_forth_dsp_pop 
b542				endm 
# End of macro FORTH_DSP_POP
b542			 
b542			 
b542 b7			 or a      ;clear carry flag 
b543 01 00 00		 ld bc, FORTH_FALSE 
b546 e1			  pop hl    ; u1 
b547 d1			  pop de    ; u2 
b548 ed 52		  sbc hl,de 
b54a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b54c			 
b54c 01 01 00		 ld bc, FORTH_TRUE 
b54f			.gtcont:  
b54f c5					push bc 
b550 e1					pop hl 
b551			 
b551					if DEBUG_FORTH_WORDS 
b551						DMARK "GT1" 
b551 f5				push af  
b552 3a 66 b5			ld a, (.dmark)  
b555 32 65 ee			ld (debug_mark),a  
b558 3a 67 b5			ld a, (.dmark+1)  
b55b 32 66 ee			ld (debug_mark+1),a  
b55e 3a 68 b5			ld a, (.dmark+2)  
b561 32 67 ee			ld (debug_mark+2),a  
b564 18 03			jr .pastdmark  
b566 ..			.dmark: db "GT1"  
b569 f1			.pastdmark: pop af  
b56a			endm  
# End of macro DMARK
b56a						CALLMONITOR 
b56a cd 6f ee			call debug_vector  
b56d				endm  
# End of macro CALLMONITOR
b56d					endif 
b56d cd 85 9a				call forth_push_numhl 
b570			 
b570					NEXTW 
b570 c3 76 9e			jp macro_next 
b573				endm 
# End of macro NEXTW
b573			.EQUAL: 
b573				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b573 31				db WORD_SYS_CORE+29             
b574 de b5			dw .ENDLOGIC            
b576 02				db 1 + 1 
b577 .. 00			db "=",0              
b579				endm 
# End of macro CWHEAD
b579			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b579				; TODO add floating point number detection 
b579					if DEBUG_FORTH_WORDS_KEY 
b579						DMARK "EQ." 
b579 f5				push af  
b57a 3a 8e b5			ld a, (.dmark)  
b57d 32 65 ee			ld (debug_mark),a  
b580 3a 8f b5			ld a, (.dmark+1)  
b583 32 66 ee			ld (debug_mark+1),a  
b586 3a 90 b5			ld a, (.dmark+2)  
b589 32 67 ee			ld (debug_mark+2),a  
b58c 18 03			jr .pastdmark  
b58e ..			.dmark: db "EQ."  
b591 f1			.pastdmark: pop af  
b592			endm  
# End of macro DMARK
b592						CALLMONITOR 
b592 cd 6f ee			call debug_vector  
b595				endm  
# End of macro CALLMONITOR
b595					endif 
b595					FORTH_DSP 
b595 cd 50 9c			call macro_forth_dsp 
b598				endm 
# End of macro FORTH_DSP
b598					;v5 FORTH_DSP_VALUE 
b598 7e					ld a,(hl)	; get type of value on TOS 
b599 fe 02				cp DS_TYPE_INUM  
b59b 28 00				jr z, .eq_inum 
b59d			 
b59d				if FORTH_ENABLE_FLOATMATH 
b59d					jr .eq_done 
b59d			 
b59d				endif 
b59d					 
b59d			 
b59d			.eq_inum: 
b59d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b59d cd 8a 9c			call macro_dsp_valuehl 
b5a0				endm 
# End of macro FORTH_DSP_VALUEHL
b5a0			 
b5a0 e5					push hl 
b5a1			 
b5a1					; destroy value TOS 
b5a1			 
b5a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a1 cd 42 9d			call macro_forth_dsp_pop 
b5a4				endm 
# End of macro FORTH_DSP_POP
b5a4			 
b5a4			 
b5a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a4 cd 8a 9c			call macro_dsp_valuehl 
b5a7				endm 
# End of macro FORTH_DSP_VALUEHL
b5a7			 
b5a7					; one value on hl get other one back 
b5a7			 
b5a7 e5					push hl 
b5a8			 
b5a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a8 cd 42 9d			call macro_forth_dsp_pop 
b5ab				endm 
# End of macro FORTH_DSP_POP
b5ab			 
b5ab 0e 00				ld c, FORTH_FALSE 
b5ad			 
b5ad e1					pop hl 
b5ae d1					pop de 
b5af			 
b5af 7b					ld a, e 
b5b0 bd					cp l 
b5b1			 
b5b1 20 06				jr nz, .eq_done 
b5b3			 
b5b3 7a					ld a, d 
b5b4 bc					cp h 
b5b5			 
b5b5 20 02				jr nz, .eq_done 
b5b7			 
b5b7 0e 01				ld c, FORTH_TRUE 
b5b9					 
b5b9			 
b5b9			 
b5b9			.eq_done: 
b5b9			 
b5b9					; TODO push value back onto stack for another op etc 
b5b9			 
b5b9 26 00				ld h, 0 
b5bb 69					ld l, c 
b5bc					if DEBUG_FORTH_WORDS 
b5bc						DMARK "EQ1" 
b5bc f5				push af  
b5bd 3a d1 b5			ld a, (.dmark)  
b5c0 32 65 ee			ld (debug_mark),a  
b5c3 3a d2 b5			ld a, (.dmark+1)  
b5c6 32 66 ee			ld (debug_mark+1),a  
b5c9 3a d3 b5			ld a, (.dmark+2)  
b5cc 32 67 ee			ld (debug_mark+2),a  
b5cf 18 03			jr .pastdmark  
b5d1 ..			.dmark: db "EQ1"  
b5d4 f1			.pastdmark: pop af  
b5d5			endm  
# End of macro DMARK
b5d5						CALLMONITOR 
b5d5 cd 6f ee			call debug_vector  
b5d8				endm  
# End of macro CALLMONITOR
b5d8					endif 
b5d8 cd 85 9a				call forth_push_numhl 
b5db			 
b5db					NEXTW 
b5db c3 76 9e			jp macro_next 
b5de				endm 
# End of macro NEXTW
b5de			 
b5de			 
b5de			.ENDLOGIC: 
b5de			; eof 
b5de			 
b5de			 
# End of file forth_words_logic.asm
b5de			include "forth_words_maths.asm" 
b5de			 
b5de			; | ## Maths Words 
b5de			 
b5de			.PLUS:	 
b5de				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b5de 15				db WORD_SYS_CORE+1             
b5df 3c b6			dw .NEG            
b5e1 02				db 1 + 1 
b5e2 .. 00			db "+",0              
b5e4				endm 
# End of macro CWHEAD
b5e4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b5e4					if DEBUG_FORTH_WORDS_KEY 
b5e4						DMARK "PLU" 
b5e4 f5				push af  
b5e5 3a f9 b5			ld a, (.dmark)  
b5e8 32 65 ee			ld (debug_mark),a  
b5eb 3a fa b5			ld a, (.dmark+1)  
b5ee 32 66 ee			ld (debug_mark+1),a  
b5f1 3a fb b5			ld a, (.dmark+2)  
b5f4 32 67 ee			ld (debug_mark+2),a  
b5f7 18 03			jr .pastdmark  
b5f9 ..			.dmark: db "PLU"  
b5fc f1			.pastdmark: pop af  
b5fd			endm  
# End of macro DMARK
b5fd						CALLMONITOR 
b5fd cd 6f ee			call debug_vector  
b600				endm  
# End of macro CALLMONITOR
b600					endif 
b600					; add top two values and push back result 
b600			 
b600					;for v5 FORTH_DSP_VALUE 
b600					FORTH_DSP 
b600 cd 50 9c			call macro_forth_dsp 
b603				endm 
# End of macro FORTH_DSP
b603 7e					ld a,(hl)	; get type of value on TOS 
b604 fe 02				cp DS_TYPE_INUM  
b606 28 03				jr z, .dot_inum 
b608			 
b608					NEXTW 
b608 c3 76 9e			jp macro_next 
b60b				endm 
# End of macro NEXTW
b60b			 
b60b			; float maths 
b60b			 
b60b				if FORTH_ENABLE_FLOATMATH 
b60b						inc hl      ; now at start of numeric as string 
b60b			 
b60b					if DEBUG_FORTH_MATHS 
b60b						DMARK "ADD" 
b60b				CALLMONITOR 
b60b					endif 
b60b			 
b60b					;ld ix, hl 
b60b					call CON 
b60b			 
b60b			 
b60b					push hl 
b60b					 
b60b					 
b60b			 
b60b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b60b			 
b60b					; get next number 
b60b			 
b60b						FORTH_DSP_VALUE 
b60b			 
b60b						inc hl      ; now at start of numeric as string 
b60b			 
b60b					;ld ix, hl 
b60b					call CON 
b60b			 
b60b					push hl 
b60b			 
b60b			 
b60b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b60b			 
b60b						; TODO do add 
b60b			 
b60b						call IADD 
b60b			 
b60b						; TODO get result back as ascii 
b60b			 
b60b						; TODO push result  
b60b			 
b60b			 
b60b			 
b60b						jr .dot_done 
b60b				endif 
b60b			 
b60b			.dot_inum: 
b60b			 
b60b			 
b60b					if DEBUG_FORTH_DOT 
b60b						DMARK "+IT" 
b60b f5				push af  
b60c 3a 20 b6			ld a, (.dmark)  
b60f 32 65 ee			ld (debug_mark),a  
b612 3a 21 b6			ld a, (.dmark+1)  
b615 32 66 ee			ld (debug_mark+1),a  
b618 3a 22 b6			ld a, (.dmark+2)  
b61b 32 67 ee			ld (debug_mark+2),a  
b61e 18 03			jr .pastdmark  
b620 ..			.dmark: db "+IT"  
b623 f1			.pastdmark: pop af  
b624			endm  
# End of macro DMARK
b624				CALLMONITOR 
b624 cd 6f ee			call debug_vector  
b627				endm  
# End of macro CALLMONITOR
b627					endif 
b627			 
b627					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b627 cd 8a 9c			call macro_dsp_valuehl 
b62a				endm 
# End of macro FORTH_DSP_VALUEHL
b62a			 
b62a				; TODO add floating point number detection 
b62a			 
b62a e5					push hl 
b62b			 
b62b					; destroy value TOS 
b62b			 
b62b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b62b cd 42 9d			call macro_forth_dsp_pop 
b62e				endm 
# End of macro FORTH_DSP_POP
b62e			 
b62e			 
b62e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b62e cd 8a 9c			call macro_dsp_valuehl 
b631				endm 
# End of macro FORTH_DSP_VALUEHL
b631			 
b631					; one value on hl get other one back 
b631			 
b631 d1					pop de 
b632			 
b632					; do the add 
b632			 
b632 19					add hl,de 
b633			 
b633					; save it 
b633			 
b633			;		push hl	 
b633			 
b633					; 
b633			 
b633					; destroy value TOS 
b633			 
b633					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b633 cd 42 9d			call macro_forth_dsp_pop 
b636				endm 
# End of macro FORTH_DSP_POP
b636			 
b636					; TODO push value back onto stack for another op etc 
b636			 
b636			;		pop hl 
b636			 
b636			.dot_done: 
b636 cd 85 9a				call forth_push_numhl 
b639			 
b639					NEXTW 
b639 c3 76 9e			jp macro_next 
b63c				endm 
# End of macro NEXTW
b63c			.NEG: 
b63c			 
b63c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b63c 17				db WORD_SYS_CORE+3             
b63d 7f b6			dw .DIV            
b63f 02				db 1 + 1 
b640 .. 00			db "-",0              
b642				endm 
# End of macro CWHEAD
b642			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b642					if DEBUG_FORTH_WORDS_KEY 
b642						DMARK "SUB" 
b642 f5				push af  
b643 3a 57 b6			ld a, (.dmark)  
b646 32 65 ee			ld (debug_mark),a  
b649 3a 58 b6			ld a, (.dmark+1)  
b64c 32 66 ee			ld (debug_mark+1),a  
b64f 3a 59 b6			ld a, (.dmark+2)  
b652 32 67 ee			ld (debug_mark+2),a  
b655 18 03			jr .pastdmark  
b657 ..			.dmark: db "SUB"  
b65a f1			.pastdmark: pop af  
b65b			endm  
# End of macro DMARK
b65b						CALLMONITOR 
b65b cd 6f ee			call debug_vector  
b65e				endm  
# End of macro CALLMONITOR
b65e					endif 
b65e			 
b65e			 
b65e				; TODO add floating point number detection 
b65e					; v5 FORTH_DSP_VALUE 
b65e					FORTH_DSP 
b65e cd 50 9c			call macro_forth_dsp 
b661				endm 
# End of macro FORTH_DSP
b661 7e					ld a,(hl)	; get type of value on TOS 
b662 fe 02				cp DS_TYPE_INUM  
b664 28 03				jr z, .neg_inum 
b666			 
b666					NEXTW 
b666 c3 76 9e			jp macro_next 
b669				endm 
# End of macro NEXTW
b669			 
b669			; float maths 
b669			 
b669				if FORTH_ENABLE_FLOATMATH 
b669					jr .neg_done 
b669			 
b669				endif 
b669					 
b669			 
b669			.neg_inum: 
b669					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b669 cd 8a 9c			call macro_dsp_valuehl 
b66c				endm 
# End of macro FORTH_DSP_VALUEHL
b66c			 
b66c e5					push hl 
b66d			 
b66d					; destroy value TOS 
b66d			 
b66d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b66d cd 42 9d			call macro_forth_dsp_pop 
b670				endm 
# End of macro FORTH_DSP_POP
b670			 
b670			 
b670					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b670 cd 8a 9c			call macro_dsp_valuehl 
b673				endm 
# End of macro FORTH_DSP_VALUEHL
b673			 
b673					; one value on hl get other one back 
b673			 
b673 d1					pop de 
b674			 
b674					; do the sub 
b674			;		ex de, hl 
b674			 
b674 ed 52				sbc hl,de 
b676			 
b676					; save it 
b676			 
b676			;		push hl	 
b676			 
b676					; 
b676			 
b676					; destroy value TOS 
b676			 
b676					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b676 cd 42 9d			call macro_forth_dsp_pop 
b679				endm 
# End of macro FORTH_DSP_POP
b679			 
b679					; TODO push value back onto stack for another op etc 
b679			 
b679			;		pop hl 
b679			 
b679 cd 85 9a				call forth_push_numhl 
b67c			.neg_done: 
b67c			 
b67c					NEXTW 
b67c c3 76 9e			jp macro_next 
b67f				endm 
# End of macro NEXTW
b67f			.DIV: 
b67f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b67f 18				db WORD_SYS_CORE+4             
b680 cc b6			dw .MUL            
b682 02				db 1 + 1 
b683 .. 00			db "/",0              
b685				endm 
# End of macro CWHEAD
b685			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b685					if DEBUG_FORTH_WORDS_KEY 
b685						DMARK "DIV" 
b685 f5				push af  
b686 3a 9a b6			ld a, (.dmark)  
b689 32 65 ee			ld (debug_mark),a  
b68c 3a 9b b6			ld a, (.dmark+1)  
b68f 32 66 ee			ld (debug_mark+1),a  
b692 3a 9c b6			ld a, (.dmark+2)  
b695 32 67 ee			ld (debug_mark+2),a  
b698 18 03			jr .pastdmark  
b69a ..			.dmark: db "DIV"  
b69d f1			.pastdmark: pop af  
b69e			endm  
# End of macro DMARK
b69e						CALLMONITOR 
b69e cd 6f ee			call debug_vector  
b6a1				endm  
# End of macro CALLMONITOR
b6a1					endif 
b6a1				; TODO add floating point number detection 
b6a1					; v5 FORTH_DSP_VALUE 
b6a1					FORTH_DSP 
b6a1 cd 50 9c			call macro_forth_dsp 
b6a4				endm 
# End of macro FORTH_DSP
b6a4 7e					ld a,(hl)	; get type of value on TOS 
b6a5 fe 02				cp DS_TYPE_INUM  
b6a7 28 03				jr z, .div_inum 
b6a9			 
b6a9				if FORTH_ENABLE_FLOATMATH 
b6a9					jr .div_done 
b6a9			 
b6a9				endif 
b6a9					NEXTW 
b6a9 c3 76 9e			jp macro_next 
b6ac				endm 
# End of macro NEXTW
b6ac			.div_inum: 
b6ac			 
b6ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6ac cd 8a 9c			call macro_dsp_valuehl 
b6af				endm 
# End of macro FORTH_DSP_VALUEHL
b6af			 
b6af e5					push hl    ; to go to bc 
b6b0			 
b6b0					; destroy value TOS 
b6b0			 
b6b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b0 cd 42 9d			call macro_forth_dsp_pop 
b6b3				endm 
# End of macro FORTH_DSP_POP
b6b3			 
b6b3			 
b6b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6b3 cd 8a 9c			call macro_dsp_valuehl 
b6b6				endm 
# End of macro FORTH_DSP_VALUEHL
b6b6			 
b6b6					; hl to go to de 
b6b6			 
b6b6 e5					push hl 
b6b7			 
b6b7 c1					pop bc 
b6b8 d1					pop de		 
b6b9			 
b6b9			 
b6b9					if DEBUG_FORTH_MATHS 
b6b9						DMARK "DIV" 
b6b9				CALLMONITOR 
b6b9					endif 
b6b9					; one value on hl but move to a get other one back 
b6b9			 
b6b9			        
b6b9 cd 47 8c			call Div16 
b6bc			 
b6bc			;	push af	 
b6bc e5				push hl 
b6bd c5				push bc 
b6be			 
b6be					if DEBUG_FORTH_MATHS 
b6be						DMARK "DI1" 
b6be				CALLMONITOR 
b6be					endif 
b6be			 
b6be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6be cd 42 9d			call macro_forth_dsp_pop 
b6c1				endm 
# End of macro FORTH_DSP_POP
b6c1			 
b6c1			 
b6c1			 
b6c1 e1					pop hl    ; result 
b6c2			 
b6c2 cd 85 9a				call forth_push_numhl 
b6c5			 
b6c5 e1					pop hl    ; reminder 
b6c6			;		ld h,0 
b6c6			;		ld l,d 
b6c6			 
b6c6 cd 85 9a				call forth_push_numhl 
b6c9			.div_done: 
b6c9					NEXTW 
b6c9 c3 76 9e			jp macro_next 
b6cc				endm 
# End of macro NEXTW
b6cc			.MUL: 
b6cc				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b6cc 19				db WORD_SYS_CORE+5             
b6cd 11 b7			dw .MIN            
b6cf 02				db 1 + 1 
b6d0 .. 00			db "*",0              
b6d2				endm 
# End of macro CWHEAD
b6d2			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b6d2				; TODO add floating point number detection 
b6d2					if DEBUG_FORTH_WORDS_KEY 
b6d2						DMARK "MUL" 
b6d2 f5				push af  
b6d3 3a e7 b6			ld a, (.dmark)  
b6d6 32 65 ee			ld (debug_mark),a  
b6d9 3a e8 b6			ld a, (.dmark+1)  
b6dc 32 66 ee			ld (debug_mark+1),a  
b6df 3a e9 b6			ld a, (.dmark+2)  
b6e2 32 67 ee			ld (debug_mark+2),a  
b6e5 18 03			jr .pastdmark  
b6e7 ..			.dmark: db "MUL"  
b6ea f1			.pastdmark: pop af  
b6eb			endm  
# End of macro DMARK
b6eb						CALLMONITOR 
b6eb cd 6f ee			call debug_vector  
b6ee				endm  
# End of macro CALLMONITOR
b6ee					endif 
b6ee					FORTH_DSP 
b6ee cd 50 9c			call macro_forth_dsp 
b6f1				endm 
# End of macro FORTH_DSP
b6f1					; v5 FORTH_DSP_VALUE 
b6f1 7e					ld a,(hl)	; get type of value on TOS 
b6f2 fe 02				cp DS_TYPE_INUM  
b6f4 28 03				jr z, .mul_inum 
b6f6			 
b6f6				if FORTH_ENABLE_FLOATMATH 
b6f6					jr .mul_done 
b6f6			 
b6f6				endif 
b6f6			 
b6f6					NEXTW 
b6f6 c3 76 9e			jp macro_next 
b6f9				endm 
# End of macro NEXTW
b6f9			.mul_inum:	 
b6f9			 
b6f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f9 cd 8a 9c			call macro_dsp_valuehl 
b6fc				endm 
# End of macro FORTH_DSP_VALUEHL
b6fc			 
b6fc e5					push hl 
b6fd			 
b6fd					; destroy value TOS 
b6fd			 
b6fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fd cd 42 9d			call macro_forth_dsp_pop 
b700				endm 
# End of macro FORTH_DSP_POP
b700			 
b700			 
b700					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b700 cd 8a 9c			call macro_dsp_valuehl 
b703				endm 
# End of macro FORTH_DSP_VALUEHL
b703			 
b703					; one value on hl but move to a get other one back 
b703			 
b703 7d					ld a, l 
b704			 
b704 d1					pop de 
b705			 
b705					; do the mull 
b705			;		ex de, hl 
b705			 
b705 cd 6d 8c				call Mult16 
b708					; save it 
b708			 
b708			;		push hl	 
b708			 
b708					; 
b708			 
b708					; destroy value TOS 
b708			 
b708					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b708 cd 42 9d			call macro_forth_dsp_pop 
b70b				endm 
# End of macro FORTH_DSP_POP
b70b			 
b70b					; TODO push value back onto stack for another op etc 
b70b			 
b70b			;		pop hl 
b70b			 
b70b cd 85 9a				call forth_push_numhl 
b70e			 
b70e			.mul_done: 
b70e					NEXTW 
b70e c3 76 9e			jp macro_next 
b711				endm 
# End of macro NEXTW
b711			 
b711			 
b711			 
b711			 
b711			.MIN: 
b711				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b711 49				db WORD_SYS_CORE+53             
b712 92 b7			dw .MAX            
b714 04				db 3 + 1 
b715 .. 00			db "MIN",0              
b719				endm 
# End of macro CWHEAD
b719			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b719					if DEBUG_FORTH_WORDS_KEY 
b719						DMARK "MIN" 
b719 f5				push af  
b71a 3a 2e b7			ld a, (.dmark)  
b71d 32 65 ee			ld (debug_mark),a  
b720 3a 2f b7			ld a, (.dmark+1)  
b723 32 66 ee			ld (debug_mark+1),a  
b726 3a 30 b7			ld a, (.dmark+2)  
b729 32 67 ee			ld (debug_mark+2),a  
b72c 18 03			jr .pastdmark  
b72e ..			.dmark: db "MIN"  
b731 f1			.pastdmark: pop af  
b732			endm  
# End of macro DMARK
b732						CALLMONITOR 
b732 cd 6f ee			call debug_vector  
b735				endm  
# End of macro CALLMONITOR
b735					endif 
b735					; get u2 
b735			 
b735					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b735 cd 8a 9c			call macro_dsp_valuehl 
b738				endm 
# End of macro FORTH_DSP_VALUEHL
b738			 
b738 e5					push hl   ; u2 
b739			 
b739					; destroy value TOS 
b739			 
b739					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b739 cd 42 9d			call macro_forth_dsp_pop 
b73c				endm 
# End of macro FORTH_DSP_POP
b73c			 
b73c					; get u1 
b73c			 
b73c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b73c cd 8a 9c			call macro_dsp_valuehl 
b73f				endm 
# End of macro FORTH_DSP_VALUEHL
b73f			 
b73f e5					push hl  ; u1 
b740			 
b740					; destroy value TOS 
b740			 
b740					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b740 cd 42 9d			call macro_forth_dsp_pop 
b743				endm 
# End of macro FORTH_DSP_POP
b743			 
b743 b7			 or a      ;clear carry flag 
b744 e1			  pop hl    ; u1 
b745 d1			  pop de    ; u2 
b746 e5				push hl   ; saved in case hl is lowest 
b747 ed 52		  sbc hl,de 
b749 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b74b			 
b74b e1				pop hl 
b74c					if DEBUG_FORTH_WORDS 
b74c						DMARK "MIN" 
b74c f5				push af  
b74d 3a 61 b7			ld a, (.dmark)  
b750 32 65 ee			ld (debug_mark),a  
b753 3a 62 b7			ld a, (.dmark+1)  
b756 32 66 ee			ld (debug_mark+1),a  
b759 3a 63 b7			ld a, (.dmark+2)  
b75c 32 67 ee			ld (debug_mark+2),a  
b75f 18 03			jr .pastdmark  
b761 ..			.dmark: db "MIN"  
b764 f1			.pastdmark: pop af  
b765			endm  
# End of macro DMARK
b765						CALLMONITOR 
b765 cd 6f ee			call debug_vector  
b768				endm  
# End of macro CALLMONITOR
b768					endif 
b768 cd 85 9a				call forth_push_numhl 
b76b			 
b76b				       NEXTW 
b76b c3 76 9e			jp macro_next 
b76e				endm 
# End of macro NEXTW
b76e			 
b76e			.mincont:  
b76e c1				pop bc   ; tidy up 
b76f eb				ex de , hl  
b770					if DEBUG_FORTH_WORDS 
b770						DMARK "MI1" 
b770 f5				push af  
b771 3a 85 b7			ld a, (.dmark)  
b774 32 65 ee			ld (debug_mark),a  
b777 3a 86 b7			ld a, (.dmark+1)  
b77a 32 66 ee			ld (debug_mark+1),a  
b77d 3a 87 b7			ld a, (.dmark+2)  
b780 32 67 ee			ld (debug_mark+2),a  
b783 18 03			jr .pastdmark  
b785 ..			.dmark: db "MI1"  
b788 f1			.pastdmark: pop af  
b789			endm  
# End of macro DMARK
b789						CALLMONITOR 
b789 cd 6f ee			call debug_vector  
b78c				endm  
# End of macro CALLMONITOR
b78c					endif 
b78c cd 85 9a				call forth_push_numhl 
b78f			 
b78f				       NEXTW 
b78f c3 76 9e			jp macro_next 
b792				endm 
# End of macro NEXTW
b792			.MAX: 
b792				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b792 4a				db WORD_SYS_CORE+54             
b793 13 b8			dw .RND16            
b795 04				db 3 + 1 
b796 .. 00			db "MAX",0              
b79a				endm 
# End of macro CWHEAD
b79a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b79a					if DEBUG_FORTH_WORDS_KEY 
b79a						DMARK "MAX" 
b79a f5				push af  
b79b 3a af b7			ld a, (.dmark)  
b79e 32 65 ee			ld (debug_mark),a  
b7a1 3a b0 b7			ld a, (.dmark+1)  
b7a4 32 66 ee			ld (debug_mark+1),a  
b7a7 3a b1 b7			ld a, (.dmark+2)  
b7aa 32 67 ee			ld (debug_mark+2),a  
b7ad 18 03			jr .pastdmark  
b7af ..			.dmark: db "MAX"  
b7b2 f1			.pastdmark: pop af  
b7b3			endm  
# End of macro DMARK
b7b3						CALLMONITOR 
b7b3 cd 6f ee			call debug_vector  
b7b6				endm  
# End of macro CALLMONITOR
b7b6					endif 
b7b6					; get u2 
b7b6			 
b7b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7b6 cd 8a 9c			call macro_dsp_valuehl 
b7b9				endm 
# End of macro FORTH_DSP_VALUEHL
b7b9			 
b7b9 e5					push hl   ; u2 
b7ba			 
b7ba					; destroy value TOS 
b7ba			 
b7ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7ba cd 42 9d			call macro_forth_dsp_pop 
b7bd				endm 
# End of macro FORTH_DSP_POP
b7bd			 
b7bd					; get u1 
b7bd			 
b7bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7bd cd 8a 9c			call macro_dsp_valuehl 
b7c0				endm 
# End of macro FORTH_DSP_VALUEHL
b7c0			 
b7c0 e5					push hl  ; u1 
b7c1			 
b7c1					; destroy value TOS 
b7c1			 
b7c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7c1 cd 42 9d			call macro_forth_dsp_pop 
b7c4				endm 
# End of macro FORTH_DSP_POP
b7c4			 
b7c4 b7			 or a      ;clear carry flag 
b7c5 e1			  pop hl    ; u1 
b7c6 d1			  pop de    ; u2 
b7c7 e5				push hl   ; saved in case hl is lowest 
b7c8 ed 52		  sbc hl,de 
b7ca 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b7cc			 
b7cc e1				pop hl 
b7cd					if DEBUG_FORTH_WORDS 
b7cd						DMARK "MAX" 
b7cd f5				push af  
b7ce 3a e2 b7			ld a, (.dmark)  
b7d1 32 65 ee			ld (debug_mark),a  
b7d4 3a e3 b7			ld a, (.dmark+1)  
b7d7 32 66 ee			ld (debug_mark+1),a  
b7da 3a e4 b7			ld a, (.dmark+2)  
b7dd 32 67 ee			ld (debug_mark+2),a  
b7e0 18 03			jr .pastdmark  
b7e2 ..			.dmark: db "MAX"  
b7e5 f1			.pastdmark: pop af  
b7e6			endm  
# End of macro DMARK
b7e6						CALLMONITOR 
b7e6 cd 6f ee			call debug_vector  
b7e9				endm  
# End of macro CALLMONITOR
b7e9					endif 
b7e9 cd 85 9a				call forth_push_numhl 
b7ec			 
b7ec				       NEXTW 
b7ec c3 76 9e			jp macro_next 
b7ef				endm 
# End of macro NEXTW
b7ef			 
b7ef			.maxcont:  
b7ef c1				pop bc   ; tidy up 
b7f0 eb				ex de , hl  
b7f1					if DEBUG_FORTH_WORDS 
b7f1						DMARK "MA1" 
b7f1 f5				push af  
b7f2 3a 06 b8			ld a, (.dmark)  
b7f5 32 65 ee			ld (debug_mark),a  
b7f8 3a 07 b8			ld a, (.dmark+1)  
b7fb 32 66 ee			ld (debug_mark+1),a  
b7fe 3a 08 b8			ld a, (.dmark+2)  
b801 32 67 ee			ld (debug_mark+2),a  
b804 18 03			jr .pastdmark  
b806 ..			.dmark: db "MA1"  
b809 f1			.pastdmark: pop af  
b80a			endm  
# End of macro DMARK
b80a						CALLMONITOR 
b80a cd 6f ee			call debug_vector  
b80d				endm  
# End of macro CALLMONITOR
b80d					endif 
b80d cd 85 9a				call forth_push_numhl 
b810				       NEXTW 
b810 c3 76 9e			jp macro_next 
b813				endm 
# End of macro NEXTW
b813			 
b813			.RND16: 
b813				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b813 4e				db WORD_SYS_CORE+58             
b814 42 b8			dw .RND8            
b816 06				db 5 + 1 
b817 .. 00			db "RND16",0              
b81d				endm 
# End of macro CWHEAD
b81d			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b81d					if DEBUG_FORTH_WORDS_KEY 
b81d						DMARK "R16" 
b81d f5				push af  
b81e 3a 32 b8			ld a, (.dmark)  
b821 32 65 ee			ld (debug_mark),a  
b824 3a 33 b8			ld a, (.dmark+1)  
b827 32 66 ee			ld (debug_mark+1),a  
b82a 3a 34 b8			ld a, (.dmark+2)  
b82d 32 67 ee			ld (debug_mark+2),a  
b830 18 03			jr .pastdmark  
b832 ..			.dmark: db "R16"  
b835 f1			.pastdmark: pop af  
b836			endm  
# End of macro DMARK
b836						CALLMONITOR 
b836 cd 6f ee			call debug_vector  
b839				endm  
# End of macro CALLMONITOR
b839					endif 
b839 cd 11 8c				call prng16  
b83c cd 85 9a				call forth_push_numhl 
b83f				       NEXTW 
b83f c3 76 9e			jp macro_next 
b842				endm 
# End of macro NEXTW
b842			.RND8: 
b842				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b842 60				db WORD_SYS_CORE+76             
b843 77 b8			dw .RND            
b845 05				db 4 + 1 
b846 .. 00			db "RND8",0              
b84b				endm 
# End of macro CWHEAD
b84b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b84b					if DEBUG_FORTH_WORDS_KEY 
b84b						DMARK "RN8" 
b84b f5				push af  
b84c 3a 60 b8			ld a, (.dmark)  
b84f 32 65 ee			ld (debug_mark),a  
b852 3a 61 b8			ld a, (.dmark+1)  
b855 32 66 ee			ld (debug_mark+1),a  
b858 3a 62 b8			ld a, (.dmark+2)  
b85b 32 67 ee			ld (debug_mark+2),a  
b85e 18 03			jr .pastdmark  
b860 ..			.dmark: db "RN8"  
b863 f1			.pastdmark: pop af  
b864			endm  
# End of macro DMARK
b864						CALLMONITOR 
b864 cd 6f ee			call debug_vector  
b867				endm  
# End of macro CALLMONITOR
b867					endif 
b867 2a a3 eb				ld hl,(xrandc) 
b86a 23					inc hl 
b86b cd 2b 8c				call xrnd 
b86e 6f					ld l,a	 
b86f 26 00				ld h,0 
b871 cd 85 9a				call forth_push_numhl 
b874				       NEXTW 
b874 c3 76 9e			jp macro_next 
b877				endm 
# End of macro NEXTW
b877			.RND: 
b877				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b877 60				db WORD_SYS_CORE+76             
b878 7d b9			dw .ENDMATHS            
b87a 04				db 3 + 1 
b87b .. 00			db "RND",0              
b87f				endm 
# End of macro CWHEAD
b87f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b87f			 
b87f					if DEBUG_FORTH_WORDS_KEY 
b87f						DMARK "RND" 
b87f f5				push af  
b880 3a 94 b8			ld a, (.dmark)  
b883 32 65 ee			ld (debug_mark),a  
b886 3a 95 b8			ld a, (.dmark+1)  
b889 32 66 ee			ld (debug_mark+1),a  
b88c 3a 96 b8			ld a, (.dmark+2)  
b88f 32 67 ee			ld (debug_mark+2),a  
b892 18 03			jr .pastdmark  
b894 ..			.dmark: db "RND"  
b897 f1			.pastdmark: pop af  
b898			endm  
# End of macro DMARK
b898						CALLMONITOR 
b898 cd 6f ee			call debug_vector  
b89b				endm  
# End of macro CALLMONITOR
b89b					endif 
b89b					 
b89b					FORTH_DSP_VALUEHL    ; upper range 
b89b cd 8a 9c			call macro_dsp_valuehl 
b89e				endm 
# End of macro FORTH_DSP_VALUEHL
b89e			 
b89e 22 a7 eb				ld (LFSRSeed), hl	 
b8a1			 
b8a1					if DEBUG_FORTH_WORDS 
b8a1						DMARK "RN1" 
b8a1 f5				push af  
b8a2 3a b6 b8			ld a, (.dmark)  
b8a5 32 65 ee			ld (debug_mark),a  
b8a8 3a b7 b8			ld a, (.dmark+1)  
b8ab 32 66 ee			ld (debug_mark+1),a  
b8ae 3a b8 b8			ld a, (.dmark+2)  
b8b1 32 67 ee			ld (debug_mark+2),a  
b8b4 18 03			jr .pastdmark  
b8b6 ..			.dmark: db "RN1"  
b8b9 f1			.pastdmark: pop af  
b8ba			endm  
# End of macro DMARK
b8ba						CALLMONITOR 
b8ba cd 6f ee			call debug_vector  
b8bd				endm  
# End of macro CALLMONITOR
b8bd					endif 
b8bd					FORTH_DSP_POP 
b8bd cd 42 9d			call macro_forth_dsp_pop 
b8c0				endm 
# End of macro FORTH_DSP_POP
b8c0			 
b8c0					FORTH_DSP_VALUEHL    ; low range 
b8c0 cd 8a 9c			call macro_dsp_valuehl 
b8c3				endm 
# End of macro FORTH_DSP_VALUEHL
b8c3			 
b8c3					if DEBUG_FORTH_WORDS 
b8c3						DMARK "RN2" 
b8c3 f5				push af  
b8c4 3a d8 b8			ld a, (.dmark)  
b8c7 32 65 ee			ld (debug_mark),a  
b8ca 3a d9 b8			ld a, (.dmark+1)  
b8cd 32 66 ee			ld (debug_mark+1),a  
b8d0 3a da b8			ld a, (.dmark+2)  
b8d3 32 67 ee			ld (debug_mark+2),a  
b8d6 18 03			jr .pastdmark  
b8d8 ..			.dmark: db "RN2"  
b8db f1			.pastdmark: pop af  
b8dc			endm  
# End of macro DMARK
b8dc						CALLMONITOR 
b8dc cd 6f ee			call debug_vector  
b8df				endm  
# End of macro CALLMONITOR
b8df					endif 
b8df 22 a9 eb				ld (LFSRSeed+2), hl 
b8e2			 
b8e2					FORTH_DSP_POP 
b8e2 cd 42 9d			call macro_forth_dsp_pop 
b8e5				endm 
# End of macro FORTH_DSP_POP
b8e5			 
b8e5 e5					push hl 
b8e6			 
b8e6 e1			.inrange:	pop hl 
b8e7 cd 11 8c				call prng16  
b8ea					if DEBUG_FORTH_WORDS 
b8ea						DMARK "RN3" 
b8ea f5				push af  
b8eb 3a ff b8			ld a, (.dmark)  
b8ee 32 65 ee			ld (debug_mark),a  
b8f1 3a 00 b9			ld a, (.dmark+1)  
b8f4 32 66 ee			ld (debug_mark+1),a  
b8f7 3a 01 b9			ld a, (.dmark+2)  
b8fa 32 67 ee			ld (debug_mark+2),a  
b8fd 18 03			jr .pastdmark  
b8ff ..			.dmark: db "RN3"  
b902 f1			.pastdmark: pop af  
b903			endm  
# End of macro DMARK
b903						CALLMONITOR 
b903 cd 6f ee			call debug_vector  
b906				endm  
# End of macro CALLMONITOR
b906					endif 
b906					 
b906					; if the range is 8bit knock out the high byte 
b906			 
b906 ed 5b a7 eb			ld de, (LFSRSeed)     ; check high level 
b90a			 
b90a 3e 00				ld a, 0 
b90c ba					cp d  
b90d 20 1e				jr nz, .hirange 
b90f 26 00				ld h, 0   ; knock it down to 8bit 
b911			 
b911					if DEBUG_FORTH_WORDS 
b911						DMARK "RNk" 
b911 f5				push af  
b912 3a 26 b9			ld a, (.dmark)  
b915 32 65 ee			ld (debug_mark),a  
b918 3a 27 b9			ld a, (.dmark+1)  
b91b 32 66 ee			ld (debug_mark+1),a  
b91e 3a 28 b9			ld a, (.dmark+2)  
b921 32 67 ee			ld (debug_mark+2),a  
b924 18 03			jr .pastdmark  
b926 ..			.dmark: db "RNk"  
b929 f1			.pastdmark: pop af  
b92a			endm  
# End of macro DMARK
b92a						CALLMONITOR 
b92a cd 6f ee			call debug_vector  
b92d				endm  
# End of macro CALLMONITOR
b92d					endif 
b92d			.hirange:   
b92d e5					push hl  
b92e b7					or a  
b92f ed 52		                sbc hl, de 
b931			 
b931					;call cmp16 
b931			 
b931 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b933 e1					pop hl 
b934 e5					push hl 
b935			 
b935					if DEBUG_FORTH_WORDS 
b935						DMARK "RN4" 
b935 f5				push af  
b936 3a 4a b9			ld a, (.dmark)  
b939 32 65 ee			ld (debug_mark),a  
b93c 3a 4b b9			ld a, (.dmark+1)  
b93f 32 66 ee			ld (debug_mark+1),a  
b942 3a 4c b9			ld a, (.dmark+2)  
b945 32 67 ee			ld (debug_mark+2),a  
b948 18 03			jr .pastdmark  
b94a ..			.dmark: db "RN4"  
b94d f1			.pastdmark: pop af  
b94e			endm  
# End of macro DMARK
b94e						CALLMONITOR 
b94e cd 6f ee			call debug_vector  
b951				endm  
# End of macro CALLMONITOR
b951					endif 
b951 ed 5b a9 eb			ld de, (LFSRSeed+2)   ; check low range 
b955					;call cmp16 
b955				 
b955 b7					or a  
b956 ed 52		                sbc hl, de 
b958 38 8c				jr c, .inrange 
b95a			 
b95a e1					pop hl 
b95b					 
b95b					if DEBUG_FORTH_WORDS 
b95b						DMARK "RNd" 
b95b f5				push af  
b95c 3a 70 b9			ld a, (.dmark)  
b95f 32 65 ee			ld (debug_mark),a  
b962 3a 71 b9			ld a, (.dmark+1)  
b965 32 66 ee			ld (debug_mark+1),a  
b968 3a 72 b9			ld a, (.dmark+2)  
b96b 32 67 ee			ld (debug_mark+2),a  
b96e 18 03			jr .pastdmark  
b970 ..			.dmark: db "RNd"  
b973 f1			.pastdmark: pop af  
b974			endm  
# End of macro DMARK
b974						CALLMONITOR 
b974 cd 6f ee			call debug_vector  
b977				endm  
# End of macro CALLMONITOR
b977					endif 
b977			 
b977			 
b977 cd 85 9a				call forth_push_numhl 
b97a				       NEXTW 
b97a c3 76 9e			jp macro_next 
b97d				endm 
# End of macro NEXTW
b97d			 
b97d			.ENDMATHS: 
b97d			 
b97d			; eof 
b97d			 
# End of file forth_words_maths.asm
b97d			include "forth_words_display.asm" 
b97d			 
b97d			; | ## Display Words 
b97d			 
b97d			.ACT: 
b97d			 
b97d				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b97d 62				db WORD_SYS_CORE+78             
b97e c9 b9			dw .INFO            
b980 07				db 6 + 1 
b981 .. 00			db "ACTIVE",0              
b988				endm 
# End of macro CWHEAD
b988			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b988			;  
b988			; | | To display a pulsing activity indicator in a processing loop do this... 
b988			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
b988			 
b988					if DEBUG_FORTH_WORDS_KEY 
b988						DMARK "ACT" 
b988 f5				push af  
b989 3a 9d b9			ld a, (.dmark)  
b98c 32 65 ee			ld (debug_mark),a  
b98f 3a 9e b9			ld a, (.dmark+1)  
b992 32 66 ee			ld (debug_mark+1),a  
b995 3a 9f b9			ld a, (.dmark+2)  
b998 32 67 ee			ld (debug_mark+2),a  
b99b 18 03			jr .pastdmark  
b99d ..			.dmark: db "ACT"  
b9a0 f1			.pastdmark: pop af  
b9a1			endm  
# End of macro DMARK
b9a1						CALLMONITOR 
b9a1 cd 6f ee			call debug_vector  
b9a4				endm  
# End of macro CALLMONITOR
b9a4					endif 
b9a4 cd 14 8a				call active 
b9a7					if DEBUG_FORTH_WORDS 
b9a7						DMARK "ACp" 
b9a7 f5				push af  
b9a8 3a bc b9			ld a, (.dmark)  
b9ab 32 65 ee			ld (debug_mark),a  
b9ae 3a bd b9			ld a, (.dmark+1)  
b9b1 32 66 ee			ld (debug_mark+1),a  
b9b4 3a be b9			ld a, (.dmark+2)  
b9b7 32 67 ee			ld (debug_mark+2),a  
b9ba 18 03			jr .pastdmark  
b9bc ..			.dmark: db "ACp"  
b9bf f1			.pastdmark: pop af  
b9c0			endm  
# End of macro DMARK
b9c0						CALLMONITOR 
b9c0 cd 6f ee			call debug_vector  
b9c3				endm  
# End of macro CALLMONITOR
b9c3					endif 
b9c3 cd f3 9a				call forth_push_str 
b9c6			 
b9c6					NEXTW 
b9c6 c3 76 9e			jp macro_next 
b9c9				endm 
# End of macro NEXTW
b9c9			.INFO: 
b9c9			 
b9c9				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b9c9 62				db WORD_SYS_CORE+78             
b9ca e6 b9			dw .ATP            
b9cc 05				db 4 + 1 
b9cd .. 00			db "INFO",0              
b9d2				endm 
# End of macro CWHEAD
b9d2			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b9d2					FORTH_DSP_VALUEHL 
b9d2 cd 8a 9c			call macro_dsp_valuehl 
b9d5				endm 
# End of macro FORTH_DSP_VALUEHL
b9d5			 
b9d5					FORTH_DSP_POP 
b9d5 cd 42 9d			call macro_forth_dsp_pop 
b9d8				endm 
# End of macro FORTH_DSP_POP
b9d8			 
b9d8 e5					push hl 
b9d9			 
b9d9					FORTH_DSP_VALUEHL 
b9d9 cd 8a 9c			call macro_dsp_valuehl 
b9dc				endm 
# End of macro FORTH_DSP_VALUEHL
b9dc			 
b9dc					FORTH_DSP_POP 
b9dc cd 42 9d			call macro_forth_dsp_pop 
b9df				endm 
# End of macro FORTH_DSP_POP
b9df			 
b9df d1					pop de 
b9e0			 
b9e0 cd 4e 8a				call info_panel 
b9e3			 
b9e3			 
b9e3					NEXTW 
b9e3 c3 76 9e			jp macro_next 
b9e6				endm 
# End of macro NEXTW
b9e6			.ATP: 
b9e6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b9e6 62				db WORD_SYS_CORE+78             
b9e7 5d ba			dw .FB            
b9e9 04				db 3 + 1 
b9ea .. 00			db "AT?",0              
b9ee				endm 
# End of macro CWHEAD
b9ee			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b9ee					if DEBUG_FORTH_WORDS_KEY 
b9ee						DMARK "AT?" 
b9ee f5				push af  
b9ef 3a 03 ba			ld a, (.dmark)  
b9f2 32 65 ee			ld (debug_mark),a  
b9f5 3a 04 ba			ld a, (.dmark+1)  
b9f8 32 66 ee			ld (debug_mark+1),a  
b9fb 3a 05 ba			ld a, (.dmark+2)  
b9fe 32 67 ee			ld (debug_mark+2),a  
ba01 18 03			jr .pastdmark  
ba03 ..			.dmark: db "AT?"  
ba06 f1			.pastdmark: pop af  
ba07			endm  
# End of macro DMARK
ba07						CALLMONITOR 
ba07 cd 6f ee			call debug_vector  
ba0a				endm  
# End of macro CALLMONITOR
ba0a					endif 
ba0a 3a 58 ea				ld a, (f_cursor_ptr) 
ba0d			 
ba0d			if DEBUG_FORTH_WORDS 
ba0d				DMARK "AT?" 
ba0d f5				push af  
ba0e 3a 22 ba			ld a, (.dmark)  
ba11 32 65 ee			ld (debug_mark),a  
ba14 3a 23 ba			ld a, (.dmark+1)  
ba17 32 66 ee			ld (debug_mark+1),a  
ba1a 3a 24 ba			ld a, (.dmark+2)  
ba1d 32 67 ee			ld (debug_mark+2),a  
ba20 18 03			jr .pastdmark  
ba22 ..			.dmark: db "AT?"  
ba25 f1			.pastdmark: pop af  
ba26			endm  
# End of macro DMARK
ba26				CALLMONITOR 
ba26 cd 6f ee			call debug_vector  
ba29				endm  
# End of macro CALLMONITOR
ba29			endif	 
ba29					; count the number of rows 
ba29			 
ba29 06 00				ld b, 0 
ba2b 4f			.atpr:		ld c, a    ; save in case we go below zero 
ba2c d6 28				sub display_cols 
ba2e f2 34 ba				jp p, .atprunder 
ba31 04					inc b 
ba32 18 f7				jr .atpr 
ba34			.atprunder:	 
ba34			if DEBUG_FORTH_WORDS 
ba34				DMARK "A?2" 
ba34 f5				push af  
ba35 3a 49 ba			ld a, (.dmark)  
ba38 32 65 ee			ld (debug_mark),a  
ba3b 3a 4a ba			ld a, (.dmark+1)  
ba3e 32 66 ee			ld (debug_mark+1),a  
ba41 3a 4b ba			ld a, (.dmark+2)  
ba44 32 67 ee			ld (debug_mark+2),a  
ba47 18 03			jr .pastdmark  
ba49 ..			.dmark: db "A?2"  
ba4c f1			.pastdmark: pop af  
ba4d			endm  
# End of macro DMARK
ba4d				CALLMONITOR 
ba4d cd 6f ee			call debug_vector  
ba50				endm  
# End of macro CALLMONITOR
ba50			endif	 
ba50 26 00				ld h, 0 
ba52 69					ld l, c 
ba53 cd 85 9a				call forth_push_numhl 
ba56 68					ld l, b  
ba57 cd 85 9a				call forth_push_numhl 
ba5a			 
ba5a			 
ba5a				NEXTW 
ba5a c3 76 9e			jp macro_next 
ba5d				endm 
# End of macro NEXTW
ba5d			 
ba5d			.FB: 
ba5d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
ba5d 1b				db WORD_SYS_CORE+7             
ba5e ab ba			dw .EMIT            
ba60 03				db 2 + 1 
ba61 .. 00			db "FB",0              
ba64				endm 
# End of macro CWHEAD
ba64			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
ba64			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
ba64			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
ba64			; | | If automatic display is off then updates will not be shown until DRAW is used. 
ba64					if DEBUG_FORTH_WORDS_KEY 
ba64						DMARK "FB." 
ba64 f5				push af  
ba65 3a 79 ba			ld a, (.dmark)  
ba68 32 65 ee			ld (debug_mark),a  
ba6b 3a 7a ba			ld a, (.dmark+1)  
ba6e 32 66 ee			ld (debug_mark+1),a  
ba71 3a 7b ba			ld a, (.dmark+2)  
ba74 32 67 ee			ld (debug_mark+2),a  
ba77 18 03			jr .pastdmark  
ba79 ..			.dmark: db "FB."  
ba7c f1			.pastdmark: pop af  
ba7d			endm  
# End of macro DMARK
ba7d						CALLMONITOR 
ba7d cd 6f ee			call debug_vector  
ba80				endm  
# End of macro CALLMONITOR
ba80					endif 
ba80			 
ba80					FORTH_DSP_VALUEHL 
ba80 cd 8a 9c			call macro_dsp_valuehl 
ba83				endm 
# End of macro FORTH_DSP_VALUEHL
ba83			 
ba83 7d					ld a, l 
ba84 fe 01				cp 1 
ba86 20 05				jr nz, .fbn1 
ba88 21 0a ed				ld hl, display_fb1 
ba8b 18 15				jr .fbset 
ba8d fe 02		.fbn1:		cp 2 
ba8f 20 05				jr nz, .fbn2 
ba91 21 c8 eb				ld hl, display_fb2 
ba94 18 0c				jr .fbset 
ba96 fe 03		.fbn2:		cp 3 
ba98 20 05				jr nz, .fbn3 
ba9a 21 69 ec				ld hl, display_fb3 
ba9d 18 03				jr .fbset 
ba9f			.fbn3:		 ; if invalid number select first 
ba9f 21 0a ed				ld hl, display_fb1 
baa2 22 c6 eb		.fbset:		ld (display_fb_active), hl 
baa5			 
baa5					FORTH_DSP_POP 
baa5 cd 42 9d			call macro_forth_dsp_pop 
baa8				endm 
# End of macro FORTH_DSP_POP
baa8			 
baa8					NEXTW 
baa8 c3 76 9e			jp macro_next 
baab				endm 
# End of macro NEXTW
baab			 
baab			 
baab			.EMIT: 
baab				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
baab 1b				db WORD_SYS_CORE+7             
baac fc ba			dw .DOTH            
baae 05				db 4 + 1 
baaf .. 00			db "EMIT",0              
bab4				endm 
# End of macro CWHEAD
bab4			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bab4					; get value off TOS and display it 
bab4			 
bab4					if DEBUG_FORTH_WORDS_KEY 
bab4						DMARK "EMT" 
bab4 f5				push af  
bab5 3a c9 ba			ld a, (.dmark)  
bab8 32 65 ee			ld (debug_mark),a  
babb 3a ca ba			ld a, (.dmark+1)  
babe 32 66 ee			ld (debug_mark+1),a  
bac1 3a cb ba			ld a, (.dmark+2)  
bac4 32 67 ee			ld (debug_mark+2),a  
bac7 18 03			jr .pastdmark  
bac9 ..			.dmark: db "EMT"  
bacc f1			.pastdmark: pop af  
bacd			endm  
# End of macro DMARK
bacd						CALLMONITOR 
bacd cd 6f ee			call debug_vector  
bad0				endm  
# End of macro CALLMONITOR
bad0					endif 
bad0			 
bad0					FORTH_DSP_VALUEHL 
bad0 cd 8a 9c			call macro_dsp_valuehl 
bad3				endm 
# End of macro FORTH_DSP_VALUEHL
bad3			 
bad3 7d					ld a,l 
bad4			 
bad4					; TODO write to display 
bad4			 
bad4 32 b9 e4				ld (os_input), a 
bad7 3e 00				ld a, 0 
bad9 32 ba e4				ld (os_input+1), a 
badc					 
badc 3a 58 ea				ld a, (f_cursor_ptr) 
badf 11 b9 e4				ld de, os_input 
bae2 cd d0 8a				call str_at_display 
bae5			 
bae5			 
bae5 3a 36 ea				ld a,(cli_autodisplay) 
bae8 fe 00				cp 0 
baea 28 03				jr z, .enoupdate 
baec cd e0 8a						call update_display 
baef					.enoupdate: 
baef			 
baef 3a 58 ea				ld a, (f_cursor_ptr) 
baf2 3c					inc a 
baf3 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
baf6			 
baf6			 
baf6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baf6 cd 42 9d			call macro_forth_dsp_pop 
baf9				endm 
# End of macro FORTH_DSP_POP
baf9			  
baf9			 
baf9					NEXTW 
baf9 c3 76 9e			jp macro_next 
bafc				endm 
# End of macro NEXTW
bafc			.DOTH: 
bafc				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bafc 1c				db WORD_SYS_CORE+8             
bafd 2c bb			dw .DOTF            
baff 03				db 2 + 1 
bb00 .. 00			db ".-",0              
bb03				endm 
# End of macro CWHEAD
bb03			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bb03					; get value off TOS and display it 
bb03					if DEBUG_FORTH_WORDS_KEY 
bb03						DMARK "DTD" 
bb03 f5				push af  
bb04 3a 18 bb			ld a, (.dmark)  
bb07 32 65 ee			ld (debug_mark),a  
bb0a 3a 19 bb			ld a, (.dmark+1)  
bb0d 32 66 ee			ld (debug_mark+1),a  
bb10 3a 1a bb			ld a, (.dmark+2)  
bb13 32 67 ee			ld (debug_mark+2),a  
bb16 18 03			jr .pastdmark  
bb18 ..			.dmark: db "DTD"  
bb1b f1			.pastdmark: pop af  
bb1c			endm  
# End of macro DMARK
bb1c						CALLMONITOR 
bb1c cd 6f ee			call debug_vector  
bb1f				endm  
# End of macro CALLMONITOR
bb1f					endif 
bb1f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bb21 3e 00			ld a, 0 
bb23 32 37 ea			ld (cli_mvdot), a 
bb26 c3 83 bb			jp .dotgo 
bb29				NEXTW 
bb29 c3 76 9e			jp macro_next 
bb2c				endm 
# End of macro NEXTW
bb2c			.DOTF: 
bb2c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bb2c 1c				db WORD_SYS_CORE+8             
bb2d 5a bb			dw .DOT            
bb2f 03				db 2 + 1 
bb30 .. 00			db ".>",0              
bb33				endm 
# End of macro CWHEAD
bb33			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bb33					; get value off TOS and display it 
bb33			        ; TODO BUG adds extra spaces 
bb33			        ; TODO BUG handle numerics? 
bb33					if DEBUG_FORTH_WORDS_KEY 
bb33						DMARK "DTC" 
bb33 f5				push af  
bb34 3a 48 bb			ld a, (.dmark)  
bb37 32 65 ee			ld (debug_mark),a  
bb3a 3a 49 bb			ld a, (.dmark+1)  
bb3d 32 66 ee			ld (debug_mark+1),a  
bb40 3a 4a bb			ld a, (.dmark+2)  
bb43 32 67 ee			ld (debug_mark+2),a  
bb46 18 03			jr .pastdmark  
bb48 ..			.dmark: db "DTC"  
bb4b f1			.pastdmark: pop af  
bb4c			endm  
# End of macro DMARK
bb4c						CALLMONITOR 
bb4c cd 6f ee			call debug_vector  
bb4f				endm  
# End of macro CALLMONITOR
bb4f					endif 
bb4f 3e 01			ld a, 1 
bb51 32 37 ea			ld (cli_mvdot), a 
bb54 c3 83 bb			jp .dotgo 
bb57				NEXTW 
bb57 c3 76 9e			jp macro_next 
bb5a				endm 
# End of macro NEXTW
bb5a			 
bb5a			.DOT: 
bb5a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bb5a 1c				db WORD_SYS_CORE+8             
bb5b 36 bd			dw .CLS            
bb5d 02				db 1 + 1 
bb5e .. 00			db ".",0              
bb60				endm 
# End of macro CWHEAD
bb60			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
bb60					; get value off TOS and display it 
bb60			 
bb60					if DEBUG_FORTH_WORDS_KEY 
bb60						DMARK "DOT" 
bb60 f5				push af  
bb61 3a 75 bb			ld a, (.dmark)  
bb64 32 65 ee			ld (debug_mark),a  
bb67 3a 76 bb			ld a, (.dmark+1)  
bb6a 32 66 ee			ld (debug_mark+1),a  
bb6d 3a 77 bb			ld a, (.dmark+2)  
bb70 32 67 ee			ld (debug_mark+2),a  
bb73 18 03			jr .pastdmark  
bb75 ..			.dmark: db "DOT"  
bb78 f1			.pastdmark: pop af  
bb79			endm  
# End of macro DMARK
bb79						CALLMONITOR 
bb79 cd 6f ee			call debug_vector  
bb7c				endm  
# End of macro CALLMONITOR
bb7c					endif 
bb7c 3e 00			ld a, 0 
bb7e 32 37 ea			ld (cli_mvdot), a 
bb81 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bb83				 
bb83			 
bb83			.dotgo: 
bb83			 
bb83			; move up type to on stack for parserv5 
bb83					FORTH_DSP 
bb83 cd 50 9c			call macro_forth_dsp 
bb86				endm 
# End of macro FORTH_DSP
bb86				;FORTH_DSP_VALUE  
bb86			 
bb86			if DEBUG_FORTH_DOT 
bb86				DMARK "DOT" 
bb86 f5				push af  
bb87 3a 9b bb			ld a, (.dmark)  
bb8a 32 65 ee			ld (debug_mark),a  
bb8d 3a 9c bb			ld a, (.dmark+1)  
bb90 32 66 ee			ld (debug_mark+1),a  
bb93 3a 9d bb			ld a, (.dmark+2)  
bb96 32 67 ee			ld (debug_mark+2),a  
bb99 18 03			jr .pastdmark  
bb9b ..			.dmark: db "DOT"  
bb9e f1			.pastdmark: pop af  
bb9f			endm  
# End of macro DMARK
bb9f				CALLMONITOR 
bb9f cd 6f ee			call debug_vector  
bba2				endm  
# End of macro CALLMONITOR
bba2			endif	 
bba2			;		.print: 
bba2			 
bba2 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bba3 23				inc hl   ; position to the actual value 
bba4 fe 01			cp DS_TYPE_STR 
bba6 20 06			jr nz, .dotnum1  
bba8			 
bba8			; display string 
bba8				FORTH_DSP_VALUE  
bba8 cd 73 9c			call macro_forth_dsp_value 
bbab				endm 
# End of macro FORTH_DSP_VALUE
bbab eb				ex de,hl 
bbac 18 49			jr .dotwrite 
bbae			 
bbae			.dotnum1: 
bbae fe 02			cp DS_TYPE_INUM 
bbb0 20 44			jr nz, .dotflot 
bbb2			 
bbb2			 
bbb2			; display number 
bbb2			 
bbb2			;	push hl 
bbb2			;	call clear_display 
bbb2			;	pop hl 
bbb2			 
bbb2 5e				ld e, (hl) 
bbb3 23				inc hl 
bbb4 56				ld d, (hl) 
bbb5 21 bb e2			ld hl, scratch 
bbb8			if DEBUG_FORTH_DOT 
bbb8				DMARK "DT1" 
bbb8 f5				push af  
bbb9 3a cd bb			ld a, (.dmark)  
bbbc 32 65 ee			ld (debug_mark),a  
bbbf 3a ce bb			ld a, (.dmark+1)  
bbc2 32 66 ee			ld (debug_mark+1),a  
bbc5 3a cf bb			ld a, (.dmark+2)  
bbc8 32 67 ee			ld (debug_mark+2),a  
bbcb 18 03			jr .pastdmark  
bbcd ..			.dmark: db "DT1"  
bbd0 f1			.pastdmark: pop af  
bbd1			endm  
# End of macro DMARK
bbd1				CALLMONITOR 
bbd1 cd 6f ee			call debug_vector  
bbd4				endm  
# End of macro CALLMONITOR
bbd4			endif	 
bbd4			 
bbd4 cd ff 8f			call uitoa_16 
bbd7 eb				ex de,hl 
bbd8			 
bbd8			if DEBUG_FORTH_DOT 
bbd8				DMARK "DT2" 
bbd8 f5				push af  
bbd9 3a ed bb			ld a, (.dmark)  
bbdc 32 65 ee			ld (debug_mark),a  
bbdf 3a ee bb			ld a, (.dmark+1)  
bbe2 32 66 ee			ld (debug_mark+1),a  
bbe5 3a ef bb			ld a, (.dmark+2)  
bbe8 32 67 ee			ld (debug_mark+2),a  
bbeb 18 03			jr .pastdmark  
bbed ..			.dmark: db "DT2"  
bbf0 f1			.pastdmark: pop af  
bbf1			endm  
# End of macro DMARK
bbf1				CALLMONITOR 
bbf1 cd 6f ee			call debug_vector  
bbf4				endm  
# End of macro CALLMONITOR
bbf4			endif	 
bbf4			 
bbf4			;	ld de, os_word_scratch 
bbf4 18 01			jr .dotwrite 
bbf6			 
bbf6 00			.dotflot:   nop 
bbf7			; TODO print floating point number 
bbf7			 
bbf7			.dotwrite:		 
bbf7			 
bbf7					; if c is set then set all '-' to spaces 
bbf7					; need to also take into account .>  
bbf7			 
bbf7 3e 01				ld a, 1 
bbf9 b9					cp c 
bbfa 20 67				jr nz, .nodashswap 
bbfc			 
bbfc					; DE has the string to write, working with HL 
bbfc			 
bbfc 06 ff				ld b, 255 
bbfe d5					push de 
bbff e1					pop hl 
bc00			 
bc00			if DEBUG_FORTH_DOT 
bc00				DMARK "DT-" 
bc00 f5				push af  
bc01 3a 15 bc			ld a, (.dmark)  
bc04 32 65 ee			ld (debug_mark),a  
bc07 3a 16 bc			ld a, (.dmark+1)  
bc0a 32 66 ee			ld (debug_mark+1),a  
bc0d 3a 17 bc			ld a, (.dmark+2)  
bc10 32 67 ee			ld (debug_mark+2),a  
bc13 18 03			jr .pastdmark  
bc15 ..			.dmark: db "DT-"  
bc18 f1			.pastdmark: pop af  
bc19			endm  
# End of macro DMARK
bc19				CALLMONITOR 
bc19 cd 6f ee			call debug_vector  
bc1c				endm  
# End of macro CALLMONITOR
bc1c			endif	 
bc1c 7e			.dashscan:	ld a, (hl) 
bc1d fe 00				cp 0 
bc1f 28 42				jr z, .nodashswap 
bc21 fe 2d				cp '-' 
bc23 20 03				jr nz, .dashskip 
bc25 3e 20				ld a, ' ' 
bc27 77					ld (hl), a 
bc28 23			.dashskip:	inc hl 
bc29			if DEBUG_FORTH_DOT 
bc29				DMARK "D-2" 
bc29 f5				push af  
bc2a 3a 3e bc			ld a, (.dmark)  
bc2d 32 65 ee			ld (debug_mark),a  
bc30 3a 3f bc			ld a, (.dmark+1)  
bc33 32 66 ee			ld (debug_mark+1),a  
bc36 3a 40 bc			ld a, (.dmark+2)  
bc39 32 67 ee			ld (debug_mark+2),a  
bc3c 18 03			jr .pastdmark  
bc3e ..			.dmark: db "D-2"  
bc41 f1			.pastdmark: pop af  
bc42			endm  
# End of macro DMARK
bc42				CALLMONITOR 
bc42 cd 6f ee			call debug_vector  
bc45				endm  
# End of macro CALLMONITOR
bc45			endif	 
bc45 10 d5				djnz .dashscan 
bc47			 
bc47			if DEBUG_FORTH_DOT 
bc47				DMARK "D-1" 
bc47 f5				push af  
bc48 3a 5c bc			ld a, (.dmark)  
bc4b 32 65 ee			ld (debug_mark),a  
bc4e 3a 5d bc			ld a, (.dmark+1)  
bc51 32 66 ee			ld (debug_mark+1),a  
bc54 3a 5e bc			ld a, (.dmark+2)  
bc57 32 67 ee			ld (debug_mark+2),a  
bc5a 18 03			jr .pastdmark  
bc5c ..			.dmark: db "D-1"  
bc5f f1			.pastdmark: pop af  
bc60			endm  
# End of macro DMARK
bc60				CALLMONITOR 
bc60 cd 6f ee			call debug_vector  
bc63				endm  
# End of macro CALLMONITOR
bc63			endif	 
bc63			 
bc63			.nodashswap: 
bc63			 
bc63			if DEBUG_FORTH_DOT 
bc63				DMARK "D-o" 
bc63 f5				push af  
bc64 3a 78 bc			ld a, (.dmark)  
bc67 32 65 ee			ld (debug_mark),a  
bc6a 3a 79 bc			ld a, (.dmark+1)  
bc6d 32 66 ee			ld (debug_mark+1),a  
bc70 3a 7a bc			ld a, (.dmark+2)  
bc73 32 67 ee			ld (debug_mark+2),a  
bc76 18 03			jr .pastdmark  
bc78 ..			.dmark: db "D-o"  
bc7b f1			.pastdmark: pop af  
bc7c			endm  
# End of macro DMARK
bc7c				CALLMONITOR 
bc7c cd 6f ee			call debug_vector  
bc7f				endm  
# End of macro CALLMONITOR
bc7f			endif	 
bc7f			 
bc7f d5					push de   ; save string start in case we need to advance print 
bc80			 
bc80 3a 58 ea				ld a, (f_cursor_ptr) 
bc83 cd d0 8a				call str_at_display 
bc86 3a 36 ea				ld a,(cli_autodisplay) 
bc89 fe 00				cp 0 
bc8b 28 03				jr z, .noupdate 
bc8d cd e0 8a						call update_display 
bc90					.noupdate: 
bc90			 
bc90			 
bc90					; see if we need to advance the print position 
bc90			 
bc90 e1					pop hl   ; get back string 
bc91			;		ex de,hl 
bc91			 
bc91 3a 37 ea				ld a, (cli_mvdot) 
bc94			if DEBUG_FORTH_DOT 
bc94			;		ld e,a 
bc94				DMARK "D>1" 
bc94 f5				push af  
bc95 3a a9 bc			ld a, (.dmark)  
bc98 32 65 ee			ld (debug_mark),a  
bc9b 3a aa bc			ld a, (.dmark+1)  
bc9e 32 66 ee			ld (debug_mark+1),a  
bca1 3a ab bc			ld a, (.dmark+2)  
bca4 32 67 ee			ld (debug_mark+2),a  
bca7 18 03			jr .pastdmark  
bca9 ..			.dmark: db "D>1"  
bcac f1			.pastdmark: pop af  
bcad			endm  
# End of macro DMARK
bcad				CALLMONITOR 
bcad cd 6f ee			call debug_vector  
bcb0				endm  
# End of macro CALLMONITOR
bcb0			endif	 
bcb0 fe 00				cp 0 
bcb2 28 44				jr z, .noadv 
bcb4					; yes, lets advance the print position 
bcb4 3e 00				ld a, 0 
bcb6 cd 5b 90				call strlent 
bcb9			if DEBUG_FORTH_DOT 
bcb9				DMARK "D-?" 
bcb9 f5				push af  
bcba 3a ce bc			ld a, (.dmark)  
bcbd 32 65 ee			ld (debug_mark),a  
bcc0 3a cf bc			ld a, (.dmark+1)  
bcc3 32 66 ee			ld (debug_mark+1),a  
bcc6 3a d0 bc			ld a, (.dmark+2)  
bcc9 32 67 ee			ld (debug_mark+2),a  
bccc 18 03			jr .pastdmark  
bcce ..			.dmark: db "D-?"  
bcd1 f1			.pastdmark: pop af  
bcd2			endm  
# End of macro DMARK
bcd2				CALLMONITOR 
bcd2 cd 6f ee			call debug_vector  
bcd5				endm  
# End of macro CALLMONITOR
bcd5			endif	 
bcd5 3a 58 ea				ld a, (f_cursor_ptr) 
bcd8 85					add a,l 
bcd9					;call addatohl 
bcd9					;ld a, l 
bcd9 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
bcdc			 
bcdc			if DEBUG_FORTH_DOT 
bcdc				DMARK "D->" 
bcdc f5				push af  
bcdd 3a f1 bc			ld a, (.dmark)  
bce0 32 65 ee			ld (debug_mark),a  
bce3 3a f2 bc			ld a, (.dmark+1)  
bce6 32 66 ee			ld (debug_mark+1),a  
bce9 3a f3 bc			ld a, (.dmark+2)  
bcec 32 67 ee			ld (debug_mark+2),a  
bcef 18 03			jr .pastdmark  
bcf1 ..			.dmark: db "D->"  
bcf4 f1			.pastdmark: pop af  
bcf5			endm  
# End of macro DMARK
bcf5				CALLMONITOR 
bcf5 cd 6f ee			call debug_vector  
bcf8				endm  
# End of macro CALLMONITOR
bcf8			endif	 
bcf8			 
bcf8			.noadv:	 
bcf8			 
bcf8					if DEBUG_FORTH_DOT_WAIT 
bcf8							call next_page_prompt 
bcf8					endif	 
bcf8			; TODO this pop off the stack causes a crash. i dont know why 
bcf8			 
bcf8			 
bcf8			if DEBUG_FORTH_DOT 
bcf8				DMARK "DTh" 
bcf8 f5				push af  
bcf9 3a 0d bd			ld a, (.dmark)  
bcfc 32 65 ee			ld (debug_mark),a  
bcff 3a 0e bd			ld a, (.dmark+1)  
bd02 32 66 ee			ld (debug_mark+1),a  
bd05 3a 0f bd			ld a, (.dmark+2)  
bd08 32 67 ee			ld (debug_mark+2),a  
bd0b 18 03			jr .pastdmark  
bd0d ..			.dmark: db "DTh"  
bd10 f1			.pastdmark: pop af  
bd11			endm  
# End of macro DMARK
bd11				CALLMONITOR 
bd11 cd 6f ee			call debug_vector  
bd14				endm  
# End of macro CALLMONITOR
bd14			endif	 
bd14			 
bd14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd14 cd 42 9d			call macro_forth_dsp_pop 
bd17				endm 
# End of macro FORTH_DSP_POP
bd17			 
bd17			if DEBUG_FORTH_DOT 
bd17				DMARK "DTi" 
bd17 f5				push af  
bd18 3a 2c bd			ld a, (.dmark)  
bd1b 32 65 ee			ld (debug_mark),a  
bd1e 3a 2d bd			ld a, (.dmark+1)  
bd21 32 66 ee			ld (debug_mark+1),a  
bd24 3a 2e bd			ld a, (.dmark+2)  
bd27 32 67 ee			ld (debug_mark+2),a  
bd2a 18 03			jr .pastdmark  
bd2c ..			.dmark: db "DTi"  
bd2f f1			.pastdmark: pop af  
bd30			endm  
# End of macro DMARK
bd30				CALLMONITOR 
bd30 cd 6f ee			call debug_vector  
bd33				endm  
# End of macro CALLMONITOR
bd33			endif	 
bd33			 
bd33			 
bd33					NEXTW 
bd33 c3 76 9e			jp macro_next 
bd36				endm 
# End of macro NEXTW
bd36			 
bd36			.CLS: 
bd36				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bd36 35				db WORD_SYS_CORE+33             
bd37 63 bd			dw .DRAW            
bd39 04				db 3 + 1 
bd3a .. 00			db "CLS",0              
bd3e				endm 
# End of macro CWHEAD
bd3e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bd3e					if DEBUG_FORTH_WORDS_KEY 
bd3e						DMARK "CLS" 
bd3e f5				push af  
bd3f 3a 53 bd			ld a, (.dmark)  
bd42 32 65 ee			ld (debug_mark),a  
bd45 3a 54 bd			ld a, (.dmark+1)  
bd48 32 66 ee			ld (debug_mark+1),a  
bd4b 3a 55 bd			ld a, (.dmark+2)  
bd4e 32 67 ee			ld (debug_mark+2),a  
bd51 18 03			jr .pastdmark  
bd53 ..			.dmark: db "CLS"  
bd56 f1			.pastdmark: pop af  
bd57			endm  
# End of macro DMARK
bd57						CALLMONITOR 
bd57 cd 6f ee			call debug_vector  
bd5a				endm  
# End of macro CALLMONITOR
bd5a					endif 
bd5a cd bd 8a				call clear_display 
bd5d c3 71 be				jp .home		; and home cursor 
bd60					NEXTW 
bd60 c3 76 9e			jp macro_next 
bd63				endm 
# End of macro NEXTW
bd63			 
bd63			.DRAW: 
bd63				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bd63 36				db WORD_SYS_CORE+34             
bd64 8e bd			dw .DUMP            
bd66 05				db 4 + 1 
bd67 .. 00			db "DRAW",0              
bd6c				endm 
# End of macro CWHEAD
bd6c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bd6c					if DEBUG_FORTH_WORDS_KEY 
bd6c						DMARK "DRW" 
bd6c f5				push af  
bd6d 3a 81 bd			ld a, (.dmark)  
bd70 32 65 ee			ld (debug_mark),a  
bd73 3a 82 bd			ld a, (.dmark+1)  
bd76 32 66 ee			ld (debug_mark+1),a  
bd79 3a 83 bd			ld a, (.dmark+2)  
bd7c 32 67 ee			ld (debug_mark+2),a  
bd7f 18 03			jr .pastdmark  
bd81 ..			.dmark: db "DRW"  
bd84 f1			.pastdmark: pop af  
bd85			endm  
# End of macro DMARK
bd85						CALLMONITOR 
bd85 cd 6f ee			call debug_vector  
bd88				endm  
# End of macro CALLMONITOR
bd88					endif 
bd88 cd e0 8a				call update_display 
bd8b					NEXTW 
bd8b c3 76 9e			jp macro_next 
bd8e				endm 
# End of macro NEXTW
bd8e			 
bd8e			.DUMP: 
bd8e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd8e 37				db WORD_SYS_CORE+35             
bd8f c6 bd			dw .CDUMP            
bd91 05				db 4 + 1 
bd92 .. 00			db "DUMP",0              
bd97				endm 
# End of macro CWHEAD
bd97			; | DUMP ( x -- ) With address x display dump   | DONE 
bd97			; TODO pop address to use off of the stack 
bd97					if DEBUG_FORTH_WORDS_KEY 
bd97						DMARK "DUM" 
bd97 f5				push af  
bd98 3a ac bd			ld a, (.dmark)  
bd9b 32 65 ee			ld (debug_mark),a  
bd9e 3a ad bd			ld a, (.dmark+1)  
bda1 32 66 ee			ld (debug_mark+1),a  
bda4 3a ae bd			ld a, (.dmark+2)  
bda7 32 67 ee			ld (debug_mark+2),a  
bdaa 18 03			jr .pastdmark  
bdac ..			.dmark: db "DUM"  
bdaf f1			.pastdmark: pop af  
bdb0			endm  
# End of macro DMARK
bdb0						CALLMONITOR 
bdb0 cd 6f ee			call debug_vector  
bdb3				endm  
# End of macro CALLMONITOR
bdb3					endif 
bdb3 cd bd 8a				call clear_display 
bdb6			 
bdb6					; get address 
bdb6			 
bdb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdb6 cd 8a 9c			call macro_dsp_valuehl 
bdb9				endm 
# End of macro FORTH_DSP_VALUEHL
bdb9				 
bdb9					; save it for cdump 
bdb9			 
bdb9 22 de e5				ld (os_cur_ptr),hl 
bdbc			 
bdbc					; destroy value TOS 
bdbc			 
bdbc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdbc cd 42 9d			call macro_forth_dsp_pop 
bdbf				endm 
# End of macro FORTH_DSP_POP
bdbf			 
bdbf cd 05 99				call dumpcont	; skip old style of param parsing	 
bdc2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bdc3					NEXTW 
bdc3 c3 76 9e			jp macro_next 
bdc6				endm 
# End of macro NEXTW
bdc6			.CDUMP: 
bdc6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bdc6 38				db WORD_SYS_CORE+36             
bdc7 f6 bd			dw .DAT            
bdc9 06				db 5 + 1 
bdca .. 00			db "CDUMP",0              
bdd0				endm 
# End of macro CWHEAD
bdd0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bdd0					if DEBUG_FORTH_WORDS_KEY 
bdd0						DMARK "CDP" 
bdd0 f5				push af  
bdd1 3a e5 bd			ld a, (.dmark)  
bdd4 32 65 ee			ld (debug_mark),a  
bdd7 3a e6 bd			ld a, (.dmark+1)  
bdda 32 66 ee			ld (debug_mark+1),a  
bddd 3a e7 bd			ld a, (.dmark+2)  
bde0 32 67 ee			ld (debug_mark+2),a  
bde3 18 03			jr .pastdmark  
bde5 ..			.dmark: db "CDP"  
bde8 f1			.pastdmark: pop af  
bde9			endm  
# End of macro DMARK
bde9						CALLMONITOR 
bde9 cd 6f ee			call debug_vector  
bdec				endm  
# End of macro CALLMONITOR
bdec					endif 
bdec cd bd 8a				call clear_display 
bdef cd 05 99				call dumpcont	 
bdf2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bdf3					NEXTW 
bdf3 c3 76 9e			jp macro_next 
bdf6				endm 
# End of macro NEXTW
bdf6			 
bdf6			 
bdf6			 
bdf6			 
bdf6			.DAT: 
bdf6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bdf6 3d				db WORD_SYS_CORE+41             
bdf7 4c be			dw .HOME            
bdf9 03				db 2 + 1 
bdfa .. 00			db "AT",0              
bdfd				endm 
# End of macro CWHEAD
bdfd			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bdfd					if DEBUG_FORTH_WORDS_KEY 
bdfd						DMARK "AT." 
bdfd f5				push af  
bdfe 3a 12 be			ld a, (.dmark)  
be01 32 65 ee			ld (debug_mark),a  
be04 3a 13 be			ld a, (.dmark+1)  
be07 32 66 ee			ld (debug_mark+1),a  
be0a 3a 14 be			ld a, (.dmark+2)  
be0d 32 67 ee			ld (debug_mark+2),a  
be10 18 03			jr .pastdmark  
be12 ..			.dmark: db "AT."  
be15 f1			.pastdmark: pop af  
be16			endm  
# End of macro DMARK
be16						CALLMONITOR 
be16 cd 6f ee			call debug_vector  
be19				endm  
# End of macro CALLMONITOR
be19					endif 
be19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be19 cd 8a 9c			call macro_dsp_valuehl 
be1c				endm 
# End of macro FORTH_DSP_VALUEHL
be1c			 
be1c			 
be1c					; TODO save cursor row 
be1c 7d					ld a,l 
be1d fe 02				cp 2 
be1f 20 04				jr nz, .crow3 
be21 3e 28				ld a, display_row_2 
be23 18 12				jr .ccol1 
be25 fe 03		.crow3:		cp 3 
be27 20 04				jr nz, .crow4 
be29 3e 50				ld a, display_row_3 
be2b 18 0a				jr .ccol1 
be2d fe 04		.crow4:		cp 4 
be2f 20 04				jr nz, .crow1 
be31 3e 78				ld a, display_row_4 
be33 18 02				jr .ccol1 
be35 3e 00		.crow1:		ld a,display_row_1 
be37 f5			.ccol1:		push af			; got row offset 
be38 6f					ld l,a 
be39 26 00				ld h,0 
be3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be3b cd 42 9d			call macro_forth_dsp_pop 
be3e				endm 
# End of macro FORTH_DSP_POP
be3e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be3e cd 8a 9c			call macro_dsp_valuehl 
be41				endm 
# End of macro FORTH_DSP_VALUEHL
be41					; TODO save cursor col 
be41 f1					pop af 
be42 85					add l		; add col offset 
be43 32 58 ea				ld (f_cursor_ptr), a 
be46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be46 cd 42 9d			call macro_forth_dsp_pop 
be49				endm 
# End of macro FORTH_DSP_POP
be49			 
be49					; calculate  
be49			 
be49					NEXTW 
be49 c3 76 9e			jp macro_next 
be4c				endm 
# End of macro NEXTW
be4c			 
be4c			 
be4c			.HOME: 
be4c				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
be4c 41				db WORD_SYS_CORE+45             
be4d 79 be			dw .CR            
be4f 05				db 4 + 1 
be50 .. 00			db "HOME",0              
be55				endm 
# End of macro CWHEAD
be55			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
be55					if DEBUG_FORTH_WORDS_KEY 
be55						DMARK "HOM" 
be55 f5				push af  
be56 3a 6a be			ld a, (.dmark)  
be59 32 65 ee			ld (debug_mark),a  
be5c 3a 6b be			ld a, (.dmark+1)  
be5f 32 66 ee			ld (debug_mark+1),a  
be62 3a 6c be			ld a, (.dmark+2)  
be65 32 67 ee			ld (debug_mark+2),a  
be68 18 03			jr .pastdmark  
be6a ..			.dmark: db "HOM"  
be6d f1			.pastdmark: pop af  
be6e			endm  
# End of macro DMARK
be6e						CALLMONITOR 
be6e cd 6f ee			call debug_vector  
be71				endm  
# End of macro CALLMONITOR
be71					endif 
be71 3e 00		.home:		ld a, 0		; and home cursor 
be73 32 58 ea				ld (f_cursor_ptr), a 
be76					NEXTW 
be76 c3 76 9e			jp macro_next 
be79				endm 
# End of macro NEXTW
be79			 
be79			 
be79			.CR: 
be79				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
be79 46				db WORD_SYS_CORE+50             
be7a b4 be			dw .SPACE            
be7c 03				db 2 + 1 
be7d .. 00			db "CR",0              
be80				endm 
# End of macro CWHEAD
be80			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
be80					if DEBUG_FORTH_WORDS_KEY 
be80						DMARK "CR." 
be80 f5				push af  
be81 3a 95 be			ld a, (.dmark)  
be84 32 65 ee			ld (debug_mark),a  
be87 3a 96 be			ld a, (.dmark+1)  
be8a 32 66 ee			ld (debug_mark+1),a  
be8d 3a 97 be			ld a, (.dmark+2)  
be90 32 67 ee			ld (debug_mark+2),a  
be93 18 03			jr .pastdmark  
be95 ..			.dmark: db "CR."  
be98 f1			.pastdmark: pop af  
be99			endm  
# End of macro DMARK
be99						CALLMONITOR 
be99 cd 6f ee			call debug_vector  
be9c				endm  
# End of macro CALLMONITOR
be9c					endif 
be9c 3e 0d				ld a, 13 
be9e 32 bb e2				ld (scratch),a 
bea1 3e 0a				ld a, 10 
bea3 32 bc e2				ld (scratch+1),a 
bea6 3e 00				ld a, 0 
bea8 32 bd e2				ld (scratch+2),a 
beab 21 bb e2				ld hl, scratch 
beae cd f3 9a				call forth_push_str 
beb1					 
beb1				       NEXTW 
beb1 c3 76 9e			jp macro_next 
beb4				endm 
# End of macro NEXTW
beb4			.SPACE: 
beb4				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
beb4 46				db WORD_SYS_CORE+50             
beb5 ea be			dw .SPACES            
beb7 03				db 2 + 1 
beb8 .. 00			db "BL",0              
bebb				endm 
# End of macro CWHEAD
bebb			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bebb					if DEBUG_FORTH_WORDS_KEY 
bebb						DMARK "BL." 
bebb f5				push af  
bebc 3a d0 be			ld a, (.dmark)  
bebf 32 65 ee			ld (debug_mark),a  
bec2 3a d1 be			ld a, (.dmark+1)  
bec5 32 66 ee			ld (debug_mark+1),a  
bec8 3a d2 be			ld a, (.dmark+2)  
becb 32 67 ee			ld (debug_mark+2),a  
bece 18 03			jr .pastdmark  
bed0 ..			.dmark: db "BL."  
bed3 f1			.pastdmark: pop af  
bed4			endm  
# End of macro DMARK
bed4						CALLMONITOR 
bed4 cd 6f ee			call debug_vector  
bed7				endm  
# End of macro CALLMONITOR
bed7					endif 
bed7 3e 20				ld a, " " 
bed9 32 bb e2				ld (scratch),a 
bedc 3e 00				ld a, 0 
bede 32 bc e2				ld (scratch+1),a 
bee1 21 bb e2				ld hl, scratch 
bee4 cd f3 9a				call forth_push_str 
bee7					 
bee7				       NEXTW 
bee7 c3 76 9e			jp macro_next 
beea				endm 
# End of macro NEXTW
beea			 
beea			;.blstr: db " ", 0 
beea			 
beea			.SPACES: 
beea				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
beea 47				db WORD_SYS_CORE+51             
beeb 85 bf			dw .SCROLL            
beed 07				db 6 + 1 
beee .. 00			db "SPACES",0              
bef5				endm 
# End of macro CWHEAD
bef5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
bef5					if DEBUG_FORTH_WORDS_KEY 
bef5						DMARK "SPS" 
bef5 f5				push af  
bef6 3a 0a bf			ld a, (.dmark)  
bef9 32 65 ee			ld (debug_mark),a  
befc 3a 0b bf			ld a, (.dmark+1)  
beff 32 66 ee			ld (debug_mark+1),a  
bf02 3a 0c bf			ld a, (.dmark+2)  
bf05 32 67 ee			ld (debug_mark+2),a  
bf08 18 03			jr .pastdmark  
bf0a ..			.dmark: db "SPS"  
bf0d f1			.pastdmark: pop af  
bf0e			endm  
# End of macro DMARK
bf0e						CALLMONITOR 
bf0e cd 6f ee			call debug_vector  
bf11				endm  
# End of macro CALLMONITOR
bf11					endif 
bf11			 
bf11			 
bf11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf11 cd 8a 9c			call macro_dsp_valuehl 
bf14				endm 
# End of macro FORTH_DSP_VALUEHL
bf14			 
bf14 e5					push hl    ; u 
bf15					if DEBUG_FORTH_WORDS 
bf15						DMARK "SPA" 
bf15 f5				push af  
bf16 3a 2a bf			ld a, (.dmark)  
bf19 32 65 ee			ld (debug_mark),a  
bf1c 3a 2b bf			ld a, (.dmark+1)  
bf1f 32 66 ee			ld (debug_mark+1),a  
bf22 3a 2c bf			ld a, (.dmark+2)  
bf25 32 67 ee			ld (debug_mark+2),a  
bf28 18 03			jr .pastdmark  
bf2a ..			.dmark: db "SPA"  
bf2d f1			.pastdmark: pop af  
bf2e			endm  
# End of macro DMARK
bf2e						CALLMONITOR 
bf2e cd 6f ee			call debug_vector  
bf31				endm  
# End of macro CALLMONITOR
bf31					endif 
bf31			 
bf31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf31 cd 42 9d			call macro_forth_dsp_pop 
bf34				endm 
# End of macro FORTH_DSP_POP
bf34 e1					pop hl 
bf35 0e 00				ld c, 0 
bf37 45					ld b, l 
bf38 21 bb e2				ld hl, scratch  
bf3b			 
bf3b					if DEBUG_FORTH_WORDS 
bf3b						DMARK "SP2" 
bf3b f5				push af  
bf3c 3a 50 bf			ld a, (.dmark)  
bf3f 32 65 ee			ld (debug_mark),a  
bf42 3a 51 bf			ld a, (.dmark+1)  
bf45 32 66 ee			ld (debug_mark+1),a  
bf48 3a 52 bf			ld a, (.dmark+2)  
bf4b 32 67 ee			ld (debug_mark+2),a  
bf4e 18 03			jr .pastdmark  
bf50 ..			.dmark: db "SP2"  
bf53 f1			.pastdmark: pop af  
bf54			endm  
# End of macro DMARK
bf54						CALLMONITOR 
bf54 cd 6f ee			call debug_vector  
bf57				endm  
# End of macro CALLMONITOR
bf57					endif 
bf57 3e 20				ld a, ' ' 
bf59			.spaces1:	 
bf59 77					ld (hl),a 
bf5a 23					inc hl 
bf5b					 
bf5b 10 fc				djnz .spaces1 
bf5d 3e 00				ld a,0 
bf5f 77					ld (hl),a 
bf60 21 bb e2				ld hl, scratch 
bf63					if DEBUG_FORTH_WORDS 
bf63						DMARK "SP3" 
bf63 f5				push af  
bf64 3a 78 bf			ld a, (.dmark)  
bf67 32 65 ee			ld (debug_mark),a  
bf6a 3a 79 bf			ld a, (.dmark+1)  
bf6d 32 66 ee			ld (debug_mark+1),a  
bf70 3a 7a bf			ld a, (.dmark+2)  
bf73 32 67 ee			ld (debug_mark+2),a  
bf76 18 03			jr .pastdmark  
bf78 ..			.dmark: db "SP3"  
bf7b f1			.pastdmark: pop af  
bf7c			endm  
# End of macro DMARK
bf7c						CALLMONITOR 
bf7c cd 6f ee			call debug_vector  
bf7f				endm  
# End of macro CALLMONITOR
bf7f					endif 
bf7f cd f3 9a				call forth_push_str 
bf82			 
bf82				       NEXTW 
bf82 c3 76 9e			jp macro_next 
bf85				endm 
# End of macro NEXTW
bf85			 
bf85			 
bf85			 
bf85			.SCROLL: 
bf85				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bf85 53				db WORD_SYS_CORE+63             
bf86 b2 bf			dw .SCROLLD            
bf88 07				db 6 + 1 
bf89 .. 00			db "SCROLL",0              
bf90				endm 
# End of macro CWHEAD
bf90			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bf90					if DEBUG_FORTH_WORDS_KEY 
bf90						DMARK "SCR" 
bf90 f5				push af  
bf91 3a a5 bf			ld a, (.dmark)  
bf94 32 65 ee			ld (debug_mark),a  
bf97 3a a6 bf			ld a, (.dmark+1)  
bf9a 32 66 ee			ld (debug_mark+1),a  
bf9d 3a a7 bf			ld a, (.dmark+2)  
bfa0 32 67 ee			ld (debug_mark+2),a  
bfa3 18 03			jr .pastdmark  
bfa5 ..			.dmark: db "SCR"  
bfa8 f1			.pastdmark: pop af  
bfa9			endm  
# End of macro DMARK
bfa9						CALLMONITOR 
bfa9 cd 6f ee			call debug_vector  
bfac				endm  
# End of macro CALLMONITOR
bfac					endif 
bfac			 
bfac cd 7f 8a			call scroll_up 
bfaf			;	call update_display 
bfaf			 
bfaf					NEXTW 
bfaf c3 76 9e			jp macro_next 
bfb2				endm 
# End of macro NEXTW
bfb2			 
bfb2			 
bfb2			 
bfb2			;		; get dir 
bfb2			; 
bfb2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb2			; 
bfb2			;		push hl 
bfb2			; 
bfb2			;		; destroy value TOS 
bfb2			; 
bfb2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb2			; 
bfb2			;		; get count 
bfb2			; 
bfb2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb2			; 
bfb2			;		push hl 
bfb2			; 
bfb2			;		; destroy value TOS 
bfb2			; 
bfb2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb2			; 
bfb2			;		; one value on hl get other one back 
bfb2			; 
bfb2			;		pop bc    ; count 
bfb2			; 
bfb2			;		pop de   ; dir 
bfb2			; 
bfb2			; 
bfb2			;		ld b, c 
bfb2			; 
bfb2			;.scrolldir:     push bc 
bfb2			;		push de 
bfb2			; 
bfb2			;		ld a, 0 
bfb2			;		cp e 
bfb2			;		jr z, .scrollup  
bfb2			;		call scroll_down 
bfb2			;		jr .scrollnext 
bfb2			;.scrollup:	call scroll_up 
bfb2			; 
bfb2			;		 
bfb2			;.scrollnext: 
bfb2			;		pop de 
bfb2			;		pop bc 
bfb2			;		djnz .scrolldir 
bfb2			; 
bfb2			; 
bfb2			; 
bfb2			; 
bfb2			; 
bfb2			;		NEXTW 
bfb2			 
bfb2			.SCROLLD: 
bfb2				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bfb2 53				db WORD_SYS_CORE+63             
bfb3 e0 bf			dw .ATQ            
bfb5 08				db 7 + 1 
bfb6 .. 00			db "SCROLLD",0              
bfbe				endm 
# End of macro CWHEAD
bfbe			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bfbe					if DEBUG_FORTH_WORDS_KEY 
bfbe						DMARK "SCD" 
bfbe f5				push af  
bfbf 3a d3 bf			ld a, (.dmark)  
bfc2 32 65 ee			ld (debug_mark),a  
bfc5 3a d4 bf			ld a, (.dmark+1)  
bfc8 32 66 ee			ld (debug_mark+1),a  
bfcb 3a d5 bf			ld a, (.dmark+2)  
bfce 32 67 ee			ld (debug_mark+2),a  
bfd1 18 03			jr .pastdmark  
bfd3 ..			.dmark: db "SCD"  
bfd6 f1			.pastdmark: pop af  
bfd7			endm  
# End of macro DMARK
bfd7						CALLMONITOR 
bfd7 cd 6f ee			call debug_vector  
bfda				endm  
# End of macro CALLMONITOR
bfda					endif 
bfda			 
bfda cd a3 8a			call scroll_down 
bfdd			;	call update_display 
bfdd			 
bfdd					NEXTW 
bfdd c3 76 9e			jp macro_next 
bfe0				endm 
# End of macro NEXTW
bfe0			 
bfe0			 
bfe0			.ATQ: 
bfe0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bfe0 62				db WORD_SYS_CORE+78             
bfe1 3e c0			dw .AUTODSP            
bfe3 04				db 3 + 1 
bfe4 .. 00			db "AT@",0              
bfe8				endm 
# End of macro CWHEAD
bfe8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bfe8					if DEBUG_FORTH_WORDS_KEY 
bfe8						DMARK "ATA" 
bfe8 f5				push af  
bfe9 3a fd bf			ld a, (.dmark)  
bfec 32 65 ee			ld (debug_mark),a  
bfef 3a fe bf			ld a, (.dmark+1)  
bff2 32 66 ee			ld (debug_mark+1),a  
bff5 3a ff bf			ld a, (.dmark+2)  
bff8 32 67 ee			ld (debug_mark+2),a  
bffb 18 03			jr .pastdmark  
bffd ..			.dmark: db "ATA"  
c000 f1			.pastdmark: pop af  
c001			endm  
# End of macro DMARK
c001						CALLMONITOR 
c001 cd 6f ee			call debug_vector  
c004				endm  
# End of macro CALLMONITOR
c004					endif 
c004			 
c004			 
c004					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c004 cd 8a 9c			call macro_dsp_valuehl 
c007				endm 
# End of macro FORTH_DSP_VALUEHL
c007			 
c007					; TODO save cursor row 
c007 7d					ld a,l 
c008 fe 02				cp 2 
c00a 20 04				jr nz, .crow3aq 
c00c 3e 28				ld a, display_row_2 
c00e 18 12				jr .ccol1aq 
c010 fe 03		.crow3aq:		cp 3 
c012 20 04				jr nz, .crow4aq 
c014 3e 50				ld a, display_row_3 
c016 18 0a				jr .ccol1aq 
c018 fe 04		.crow4aq:		cp 4 
c01a 20 04				jr nz, .crow1aq 
c01c 3e 78				ld a, display_row_4 
c01e 18 02				jr .ccol1aq 
c020 3e 00		.crow1aq:		ld a,display_row_1 
c022 f5			.ccol1aq:		push af			; got row offset 
c023 6f					ld l,a 
c024 26 00				ld h,0 
c026					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c026 cd 42 9d			call macro_forth_dsp_pop 
c029				endm 
# End of macro FORTH_DSP_POP
c029					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c029 cd 8a 9c			call macro_dsp_valuehl 
c02c				endm 
# End of macro FORTH_DSP_VALUEHL
c02c					; TODO save cursor col 
c02c f1					pop af 
c02d 85					add l		; add col offset 
c02e			 
c02e					; add current frame buffer address 
c02e 2a c6 eb				ld hl, (display_fb_active) 
c031 cd ea 8c				call addatohl 
c034			 
c034			 
c034			 
c034			 
c034					; get char frame buffer location offset in hl 
c034			 
c034 7e					ld a,(hl) 
c035 26 00				ld h, 0 
c037 6f					ld l, a 
c038			 
c038 cd 85 9a				call forth_push_numhl 
c03b			 
c03b			 
c03b					NEXTW 
c03b c3 76 9e			jp macro_next 
c03e				endm 
# End of macro NEXTW
c03e			 
c03e			.AUTODSP: 
c03e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c03e 63				db WORD_SYS_CORE+79             
c03f 54 c0			dw .MENU            
c041 05				db 4 + 1 
c042 .. 00			db "ADSP",0              
c047				endm 
# End of macro CWHEAD
c047			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c047			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c047			 
c047					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c047 cd 8a 9c			call macro_dsp_valuehl 
c04a				endm 
# End of macro FORTH_DSP_VALUEHL
c04a			 
c04a			;		push hl 
c04a			 
c04a					; destroy value TOS 
c04a			 
c04a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c04a cd 42 9d			call macro_forth_dsp_pop 
c04d				endm 
# End of macro FORTH_DSP_POP
c04d			 
c04d			;		pop hl 
c04d			 
c04d 7d					ld a,l 
c04e 32 36 ea				ld (cli_autodisplay), a 
c051				       NEXTW 
c051 c3 76 9e			jp macro_next 
c054				endm 
# End of macro NEXTW
c054			 
c054			.MENU: 
c054				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c054 70				db WORD_SYS_CORE+92             
c055 fd c0			dw .ENDDISPLAY            
c057 05				db 4 + 1 
c058 .. 00			db "MENU",0              
c05d				endm 
# End of macro CWHEAD
c05d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c05d			 
c05d			;		; get number of items on the stack 
c05d			; 
c05d				 
c05d					FORTH_DSP_VALUEHL 
c05d cd 8a 9c			call macro_dsp_valuehl 
c060				endm 
# End of macro FORTH_DSP_VALUEHL
c060				 
c060					if DEBUG_FORTH_WORDS_KEY 
c060						DMARK "MNU" 
c060 f5				push af  
c061 3a 75 c0			ld a, (.dmark)  
c064 32 65 ee			ld (debug_mark),a  
c067 3a 76 c0			ld a, (.dmark+1)  
c06a 32 66 ee			ld (debug_mark+1),a  
c06d 3a 77 c0			ld a, (.dmark+2)  
c070 32 67 ee			ld (debug_mark+2),a  
c073 18 03			jr .pastdmark  
c075 ..			.dmark: db "MNU"  
c078 f1			.pastdmark: pop af  
c079			endm  
# End of macro DMARK
c079						CALLMONITOR 
c079 cd 6f ee			call debug_vector  
c07c				endm  
# End of macro CALLMONITOR
c07c					endif 
c07c			 
c07c 45					ld b, l	 
c07d 05					dec b 
c07e			 
c07e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c07e cd 42 9d			call macro_forth_dsp_pop 
c081				endm 
# End of macro FORTH_DSP_POP
c081			 
c081			 
c081					; go directly through the stack to pluck out the string pointers and build an array 
c081			 
c081			;		FORTH_DSP 
c081			 
c081					; hl contains top most stack item 
c081				 
c081 11 bb e2				ld de, scratch 
c084			 
c084			.mbuild: 
c084			 
c084					FORTH_DSP_VALUEHL 
c084 cd 8a 9c			call macro_dsp_valuehl 
c087				endm 
# End of macro FORTH_DSP_VALUEHL
c087			 
c087					if DEBUG_FORTH_WORDS 
c087						DMARK "MN3" 
c087 f5				push af  
c088 3a 9c c0			ld a, (.dmark)  
c08b 32 65 ee			ld (debug_mark),a  
c08e 3a 9d c0			ld a, (.dmark+1)  
c091 32 66 ee			ld (debug_mark+1),a  
c094 3a 9e c0			ld a, (.dmark+2)  
c097 32 67 ee			ld (debug_mark+2),a  
c09a 18 03			jr .pastdmark  
c09c ..			.dmark: db "MN3"  
c09f f1			.pastdmark: pop af  
c0a0			endm  
# End of macro DMARK
c0a0						CALLMONITOR 
c0a0 cd 6f ee			call debug_vector  
c0a3				endm  
# End of macro CALLMONITOR
c0a3					endif 
c0a3 eb					ex de, hl 
c0a4 73					ld (hl), e 
c0a5 23					inc hl 
c0a6 72					ld (hl), d 
c0a7 23					inc hl 
c0a8 eb					ex de, hl 
c0a9			 
c0a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0a9 cd 42 9d			call macro_forth_dsp_pop 
c0ac				endm 
# End of macro FORTH_DSP_POP
c0ac			 
c0ac 10 d6				djnz .mbuild 
c0ae			 
c0ae					; done add term 
c0ae			 
c0ae eb					ex de, hl 
c0af 36 00				ld (hl), 0 
c0b1 23					inc hl 
c0b2 36 00				ld (hl), 0 
c0b4			 
c0b4				 
c0b4					 
c0b4 21 bb e2				ld hl, scratch 
c0b7			 
c0b7					if DEBUG_FORTH_WORDS 
c0b7						DMARK "MNx" 
c0b7 f5				push af  
c0b8 3a cc c0			ld a, (.dmark)  
c0bb 32 65 ee			ld (debug_mark),a  
c0be 3a cd c0			ld a, (.dmark+1)  
c0c1 32 66 ee			ld (debug_mark+1),a  
c0c4 3a ce c0			ld a, (.dmark+2)  
c0c7 32 67 ee			ld (debug_mark+2),a  
c0ca 18 03			jr .pastdmark  
c0cc ..			.dmark: db "MNx"  
c0cf f1			.pastdmark: pop af  
c0d0			endm  
# End of macro DMARK
c0d0						CALLMONITOR 
c0d0 cd 6f ee			call debug_vector  
c0d3				endm  
# End of macro CALLMONITOR
c0d3					endif 
c0d3			 
c0d3			 
c0d3			 
c0d3 3e 00				ld a, 0 
c0d5 cd ee 8a				call menu 
c0d8			 
c0d8			 
c0d8 6f					ld l, a 
c0d9 26 00				ld h, 0 
c0db			 
c0db					if DEBUG_FORTH_WORDS 
c0db						DMARK "MNr" 
c0db f5				push af  
c0dc 3a f0 c0			ld a, (.dmark)  
c0df 32 65 ee			ld (debug_mark),a  
c0e2 3a f1 c0			ld a, (.dmark+1)  
c0e5 32 66 ee			ld (debug_mark+1),a  
c0e8 3a f2 c0			ld a, (.dmark+2)  
c0eb 32 67 ee			ld (debug_mark+2),a  
c0ee 18 03			jr .pastdmark  
c0f0 ..			.dmark: db "MNr"  
c0f3 f1			.pastdmark: pop af  
c0f4			endm  
# End of macro DMARK
c0f4						CALLMONITOR 
c0f4 cd 6f ee			call debug_vector  
c0f7				endm  
# End of macro CALLMONITOR
c0f7					endif 
c0f7			 
c0f7 cd 85 9a				call forth_push_numhl 
c0fa			 
c0fa			 
c0fa			 
c0fa			 
c0fa				       NEXTW 
c0fa c3 76 9e			jp macro_next 
c0fd				endm 
# End of macro NEXTW
c0fd			 
c0fd			 
c0fd			.ENDDISPLAY: 
c0fd			 
c0fd			; eof 
# End of file forth_words_display.asm
c0fd			include "forth_words_str.asm" 
c0fd			 
c0fd			; | ## String Words 
c0fd			 
c0fd			.SPLIT:   
c0fd			 
c0fd				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
c0fd 48				db WORD_SYS_CORE+52             
c0fe f2 c1			dw .PTR            
c100 06				db 5 + 1 
c101 .. 00			db "SPLIT",0              
c107				endm 
# End of macro CWHEAD
c107			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
c107					if DEBUG_FORTH_WORDS_KEY 
c107						DMARK "SPT" 
c107 f5				push af  
c108 3a 1c c1			ld a, (.dmark)  
c10b 32 65 ee			ld (debug_mark),a  
c10e 3a 1d c1			ld a, (.dmark+1)  
c111 32 66 ee			ld (debug_mark+1),a  
c114 3a 1e c1			ld a, (.dmark+2)  
c117 32 67 ee			ld (debug_mark+2),a  
c11a 18 03			jr .pastdmark  
c11c ..			.dmark: db "SPT"  
c11f f1			.pastdmark: pop af  
c120			endm  
# End of macro DMARK
c120						CALLMONITOR 
c120 cd 6f ee			call debug_vector  
c123				endm  
# End of macro CALLMONITOR
c123					endif 
c123			 
c123					; get delim 
c123					FORTH_DSP_VALUEHL 
c123 cd 8a 9c			call macro_dsp_valuehl 
c126				endm 
# End of macro FORTH_DSP_VALUEHL
c126			 
c126					FORTH_DSP_POP 
c126 cd 42 9d			call macro_forth_dsp_pop 
c129				endm 
# End of macro FORTH_DSP_POP
c129					 
c129			 
c129 45					ld b, l    ; move delim to b 
c12a 0e 01				ld c, 1   ; count of poritions 
c12c			 
c12c c5					push bc 
c12d			 
c12d					if DEBUG_FORTH_WORDS 
c12d						DMARK "SPa" 
c12d f5				push af  
c12e 3a 42 c1			ld a, (.dmark)  
c131 32 65 ee			ld (debug_mark),a  
c134 3a 43 c1			ld a, (.dmark+1)  
c137 32 66 ee			ld (debug_mark+1),a  
c13a 3a 44 c1			ld a, (.dmark+2)  
c13d 32 67 ee			ld (debug_mark+2),a  
c140 18 03			jr .pastdmark  
c142 ..			.dmark: db "SPa"  
c145 f1			.pastdmark: pop af  
c146			endm  
# End of macro DMARK
c146						CALLMONITOR 
c146 cd 6f ee			call debug_vector  
c149				endm  
# End of macro CALLMONITOR
c149					endif 
c149					; get pointer to string to chop up 
c149					FORTH_DSP_VALUEHL 
c149 cd 8a 9c			call macro_dsp_valuehl 
c14c				endm 
# End of macro FORTH_DSP_VALUEHL
c14c			 
c14c			;		push hl 
c14c 11 bb e2				ld de, scratch 
c14f			.spllop: 
c14f c1					pop bc 
c150 c5					push bc 
c151			;		pop hl 
c151					if DEBUG_FORTH_WORDS 
c151						DMARK "SPl" 
c151 f5				push af  
c152 3a 66 c1			ld a, (.dmark)  
c155 32 65 ee			ld (debug_mark),a  
c158 3a 67 c1			ld a, (.dmark+1)  
c15b 32 66 ee			ld (debug_mark+1),a  
c15e 3a 68 c1			ld a, (.dmark+2)  
c161 32 67 ee			ld (debug_mark+2),a  
c164 18 03			jr .pastdmark  
c166 ..			.dmark: db "SPl"  
c169 f1			.pastdmark: pop af  
c16a			endm  
# End of macro DMARK
c16a						CALLMONITOR 
c16a cd 6f ee			call debug_vector  
c16d				endm  
# End of macro CALLMONITOR
c16d					endif 
c16d 7e					ld a, (hl) 
c16e b8					cp b 
c16f 28 08				jr z, .splnxt 
c171 fe 00				cp 0 
c173 28 34				jr z, .splend 
c175 ed a0				ldi 
c177 18 d6				jr .spllop 
c179			 
c179					; hit dlim 
c179			 
c179			.splnxt: 
c179					if DEBUG_FORTH_WORDS 
c179						DMARK "SPx" 
c179 f5				push af  
c17a 3a 8e c1			ld a, (.dmark)  
c17d 32 65 ee			ld (debug_mark),a  
c180 3a 8f c1			ld a, (.dmark+1)  
c183 32 66 ee			ld (debug_mark+1),a  
c186 3a 90 c1			ld a, (.dmark+2)  
c189 32 67 ee			ld (debug_mark+2),a  
c18c 18 03			jr .pastdmark  
c18e ..			.dmark: db "SPx"  
c191 f1			.pastdmark: pop af  
c192			endm  
# End of macro DMARK
c192						CALLMONITOR 
c192 cd 6f ee			call debug_vector  
c195				endm  
# End of macro CALLMONITOR
c195					endif 
c195 3e 00				ld a, 0 
c197 12					ld (de), a 
c198					;ex de, hl 
c198 e5					push hl 
c199 21 bb e2				ld hl, scratch 
c19c cd f3 9a				call forth_push_str 
c19f e1					pop hl 
c1a0					;ex de, hl 
c1a0 23					inc hl 
c1a1 c1					pop bc 
c1a2 0c					inc c 
c1a3 c5					push bc 
c1a4 11 bb e2				ld de, scratch 
c1a7 18 a6				jr .spllop 
c1a9			 
c1a9			.splend:		 
c1a9					if DEBUG_FORTH_WORDS 
c1a9						DMARK "SPe" 
c1a9 f5				push af  
c1aa 3a be c1			ld a, (.dmark)  
c1ad 32 65 ee			ld (debug_mark),a  
c1b0 3a bf c1			ld a, (.dmark+1)  
c1b3 32 66 ee			ld (debug_mark+1),a  
c1b6 3a c0 c1			ld a, (.dmark+2)  
c1b9 32 67 ee			ld (debug_mark+2),a  
c1bc 18 03			jr .pastdmark  
c1be ..			.dmark: db "SPe"  
c1c1 f1			.pastdmark: pop af  
c1c2			endm  
# End of macro DMARK
c1c2						CALLMONITOR 
c1c2 cd 6f ee			call debug_vector  
c1c5				endm  
# End of macro CALLMONITOR
c1c5					endif 
c1c5 12					ld (de), a 
c1c6 eb					ex de, hl 
c1c7			;		push hl 
c1c7 21 bb e2				ld hl, scratch 
c1ca cd f3 9a				call forth_push_str 
c1cd					 
c1cd					if DEBUG_FORTH_WORDS 
c1cd						DMARK "SPc" 
c1cd f5				push af  
c1ce 3a e2 c1			ld a, (.dmark)  
c1d1 32 65 ee			ld (debug_mark),a  
c1d4 3a e3 c1			ld a, (.dmark+1)  
c1d7 32 66 ee			ld (debug_mark+1),a  
c1da 3a e4 c1			ld a, (.dmark+2)  
c1dd 32 67 ee			ld (debug_mark+2),a  
c1e0 18 03			jr .pastdmark  
c1e2 ..			.dmark: db "SPc"  
c1e5 f1			.pastdmark: pop af  
c1e6			endm  
# End of macro DMARK
c1e6						CALLMONITOR 
c1e6 cd 6f ee			call debug_vector  
c1e9				endm  
# End of macro CALLMONITOR
c1e9					endif 
c1e9			 
c1e9 e1					pop hl    ; get counter from bc which has been push 
c1ea 26 00				ld h, 0 
c1ec			;		ld l, c 
c1ec cd 85 9a				call forth_push_numhl 
c1ef			 
c1ef			 
c1ef				NEXTW 
c1ef c3 76 9e			jp macro_next 
c1f2				endm 
# End of macro NEXTW
c1f2			.PTR:   
c1f2			 
c1f2				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c1f2 48				db WORD_SYS_CORE+52             
c1f3 1f c2			dw .STYPE            
c1f5 04				db 3 + 1 
c1f6 .. 00			db "PTR",0              
c1fa				endm 
# End of macro CWHEAD
c1fa			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c1fa			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c1fa			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c1fa			 
c1fa					if DEBUG_FORTH_WORDS_KEY 
c1fa						DMARK "PTR" 
c1fa f5				push af  
c1fb 3a 0f c2			ld a, (.dmark)  
c1fe 32 65 ee			ld (debug_mark),a  
c201 3a 10 c2			ld a, (.dmark+1)  
c204 32 66 ee			ld (debug_mark+1),a  
c207 3a 11 c2			ld a, (.dmark+2)  
c20a 32 67 ee			ld (debug_mark+2),a  
c20d 18 03			jr .pastdmark  
c20f ..			.dmark: db "PTR"  
c212 f1			.pastdmark: pop af  
c213			endm  
# End of macro DMARK
c213						CALLMONITOR 
c213 cd 6f ee			call debug_vector  
c216				endm  
# End of macro CALLMONITOR
c216					endif 
c216					FORTH_DSP_VALUEHL 
c216 cd 8a 9c			call macro_dsp_valuehl 
c219				endm 
# End of macro FORTH_DSP_VALUEHL
c219 cd 85 9a				call forth_push_numhl 
c21c			 
c21c			 
c21c					NEXTW 
c21c c3 76 9e			jp macro_next 
c21f				endm 
# End of macro NEXTW
c21f			.STYPE: 
c21f				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c21f 48				db WORD_SYS_CORE+52             
c220 6e c2			dw .UPPER            
c222 06				db 5 + 1 
c223 .. 00			db "STYPE",0              
c229				endm 
# End of macro CWHEAD
c229			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c229					if DEBUG_FORTH_WORDS_KEY 
c229						DMARK "STY" 
c229 f5				push af  
c22a 3a 3e c2			ld a, (.dmark)  
c22d 32 65 ee			ld (debug_mark),a  
c230 3a 3f c2			ld a, (.dmark+1)  
c233 32 66 ee			ld (debug_mark+1),a  
c236 3a 40 c2			ld a, (.dmark+2)  
c239 32 67 ee			ld (debug_mark+2),a  
c23c 18 03			jr .pastdmark  
c23e ..			.dmark: db "STY"  
c241 f1			.pastdmark: pop af  
c242			endm  
# End of macro DMARK
c242						CALLMONITOR 
c242 cd 6f ee			call debug_vector  
c245				endm  
# End of macro CALLMONITOR
c245					endif 
c245					FORTH_DSP 
c245 cd 50 9c			call macro_forth_dsp 
c248				endm 
# End of macro FORTH_DSP
c248					;v5 FORTH_DSP_VALUE 
c248			 
c248 7e					ld a, (hl) 
c249			 
c249 f5					push af 
c24a			 
c24a			; Dont destroy TOS		FORTH_DSP_POP 
c24a			 
c24a f1					pop af 
c24b			 
c24b fe 01				cp DS_TYPE_STR 
c24d 28 09				jr z, .typestr 
c24f			 
c24f fe 02				cp DS_TYPE_INUM 
c251 28 0a				jr z, .typeinum 
c253			 
c253 21 6c c2				ld hl, .tna 
c256 18 0a				jr .tpush 
c258			 
c258 21 68 c2		.typestr:	ld hl, .tstr 
c25b 18 05				jr .tpush 
c25d 21 6a c2		.typeinum:	ld hl, .tinum 
c260 18 00				jr .tpush 
c262			 
c262			.tpush: 
c262			 
c262 cd f3 9a				call forth_push_str 
c265			 
c265					NEXTW 
c265 c3 76 9e			jp macro_next 
c268				endm 
# End of macro NEXTW
c268 .. 00		.tstr:	db "s",0 
c26a .. 00		.tinum:  db "i",0 
c26c .. 00		.tna:   db "?", 0 
c26e			 
c26e			 
c26e			.UPPER: 
c26e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c26e 48				db WORD_SYS_CORE+52             
c26f a9 c2			dw .LOWER            
c271 06				db 5 + 1 
c272 .. 00			db "UPPER",0              
c278				endm 
# End of macro CWHEAD
c278			; | UPPER ( s -- s ) Upper case string s  | DONE 
c278					if DEBUG_FORTH_WORDS_KEY 
c278						DMARK "UPR" 
c278 f5				push af  
c279 3a 8d c2			ld a, (.dmark)  
c27c 32 65 ee			ld (debug_mark),a  
c27f 3a 8e c2			ld a, (.dmark+1)  
c282 32 66 ee			ld (debug_mark+1),a  
c285 3a 8f c2			ld a, (.dmark+2)  
c288 32 67 ee			ld (debug_mark+2),a  
c28b 18 03			jr .pastdmark  
c28d ..			.dmark: db "UPR"  
c290 f1			.pastdmark: pop af  
c291			endm  
# End of macro DMARK
c291						CALLMONITOR 
c291 cd 6f ee			call debug_vector  
c294				endm  
# End of macro CALLMONITOR
c294					endif 
c294			 
c294					FORTH_DSP 
c294 cd 50 9c			call macro_forth_dsp 
c297				endm 
# End of macro FORTH_DSP
c297					 
c297			; TODO check is string type 
c297			 
c297					FORTH_DSP_VALUEHL 
c297 cd 8a 9c			call macro_dsp_valuehl 
c29a				endm 
# End of macro FORTH_DSP_VALUEHL
c29a			; get pointer to string in hl 
c29a			 
c29a 7e			.toup:		ld a, (hl) 
c29b fe 00				cp 0 
c29d 28 07				jr z, .toupdone 
c29f			 
c29f cd 5f 8f				call to_upper 
c2a2			 
c2a2 77					ld (hl), a 
c2a3 23					inc hl 
c2a4 18 f4				jr .toup 
c2a6			 
c2a6					 
c2a6			 
c2a6			 
c2a6			; for each char convert to upper 
c2a6					 
c2a6			.toupdone: 
c2a6			 
c2a6			 
c2a6					NEXTW 
c2a6 c3 76 9e			jp macro_next 
c2a9				endm 
# End of macro NEXTW
c2a9			.LOWER: 
c2a9				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c2a9 48				db WORD_SYS_CORE+52             
c2aa e4 c2			dw .TCASE            
c2ac 06				db 5 + 1 
c2ad .. 00			db "LOWER",0              
c2b3				endm 
# End of macro CWHEAD
c2b3			; | LOWER ( s -- s ) Lower case string s  | DONE 
c2b3					if DEBUG_FORTH_WORDS_KEY 
c2b3						DMARK "LWR" 
c2b3 f5				push af  
c2b4 3a c8 c2			ld a, (.dmark)  
c2b7 32 65 ee			ld (debug_mark),a  
c2ba 3a c9 c2			ld a, (.dmark+1)  
c2bd 32 66 ee			ld (debug_mark+1),a  
c2c0 3a ca c2			ld a, (.dmark+2)  
c2c3 32 67 ee			ld (debug_mark+2),a  
c2c6 18 03			jr .pastdmark  
c2c8 ..			.dmark: db "LWR"  
c2cb f1			.pastdmark: pop af  
c2cc			endm  
# End of macro DMARK
c2cc						CALLMONITOR 
c2cc cd 6f ee			call debug_vector  
c2cf				endm  
# End of macro CALLMONITOR
c2cf					endif 
c2cf			 
c2cf					FORTH_DSP 
c2cf cd 50 9c			call macro_forth_dsp 
c2d2				endm 
# End of macro FORTH_DSP
c2d2					 
c2d2			; TODO check is string type 
c2d2			 
c2d2					FORTH_DSP_VALUEHL 
c2d2 cd 8a 9c			call macro_dsp_valuehl 
c2d5				endm 
# End of macro FORTH_DSP_VALUEHL
c2d5			; get pointer to string in hl 
c2d5			 
c2d5 7e			.tolow:		ld a, (hl) 
c2d6 fe 00				cp 0 
c2d8 28 07				jr z, .tolowdone 
c2da			 
c2da cd 68 8f				call to_lower 
c2dd			 
c2dd 77					ld (hl), a 
c2de 23					inc hl 
c2df 18 f4				jr .tolow 
c2e1			 
c2e1					 
c2e1			 
c2e1			 
c2e1			; for each char convert to low 
c2e1					 
c2e1			.tolowdone: 
c2e1					NEXTW 
c2e1 c3 76 9e			jp macro_next 
c2e4				endm 
# End of macro NEXTW
c2e4			.TCASE: 
c2e4				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c2e4 48				db WORD_SYS_CORE+52             
c2e5 1a c4			dw .SUBSTR            
c2e7 06				db 5 + 1 
c2e8 .. 00			db "TCASE",0              
c2ee				endm 
# End of macro CWHEAD
c2ee			; | TCASE ( s -- s ) Title case string s  | DONE 
c2ee					if DEBUG_FORTH_WORDS_KEY 
c2ee						DMARK "TCS" 
c2ee f5				push af  
c2ef 3a 03 c3			ld a, (.dmark)  
c2f2 32 65 ee			ld (debug_mark),a  
c2f5 3a 04 c3			ld a, (.dmark+1)  
c2f8 32 66 ee			ld (debug_mark+1),a  
c2fb 3a 05 c3			ld a, (.dmark+2)  
c2fe 32 67 ee			ld (debug_mark+2),a  
c301 18 03			jr .pastdmark  
c303 ..			.dmark: db "TCS"  
c306 f1			.pastdmark: pop af  
c307			endm  
# End of macro DMARK
c307						CALLMONITOR 
c307 cd 6f ee			call debug_vector  
c30a				endm  
# End of macro CALLMONITOR
c30a					endif 
c30a			 
c30a					FORTH_DSP 
c30a cd 50 9c			call macro_forth_dsp 
c30d				endm 
# End of macro FORTH_DSP
c30d					 
c30d			; TODO check is string type 
c30d			 
c30d					FORTH_DSP_VALUEHL 
c30d cd 8a 9c			call macro_dsp_valuehl 
c310				endm 
# End of macro FORTH_DSP_VALUEHL
c310			; get pointer to string in hl 
c310			 
c310					if DEBUG_FORTH_WORDS 
c310						DMARK "TC1" 
c310 f5				push af  
c311 3a 25 c3			ld a, (.dmark)  
c314 32 65 ee			ld (debug_mark),a  
c317 3a 26 c3			ld a, (.dmark+1)  
c31a 32 66 ee			ld (debug_mark+1),a  
c31d 3a 27 c3			ld a, (.dmark+2)  
c320 32 67 ee			ld (debug_mark+2),a  
c323 18 03			jr .pastdmark  
c325 ..			.dmark: db "TC1"  
c328 f1			.pastdmark: pop af  
c329			endm  
# End of macro DMARK
c329						CALLMONITOR 
c329 cd 6f ee			call debug_vector  
c32c				endm  
# End of macro CALLMONITOR
c32c					endif 
c32c			 
c32c					; first time in turn to upper case first char 
c32c			 
c32c 7e					ld a, (hl) 
c32d c3 b7 c3				jp .totsiptou 
c330			 
c330			 
c330 7e			.tot:		ld a, (hl) 
c331 fe 00				cp 0 
c333 ca fb c3				jp z, .totdone 
c336			 
c336					if DEBUG_FORTH_WORDS 
c336						DMARK "TC2" 
c336 f5				push af  
c337 3a 4b c3			ld a, (.dmark)  
c33a 32 65 ee			ld (debug_mark),a  
c33d 3a 4c c3			ld a, (.dmark+1)  
c340 32 66 ee			ld (debug_mark+1),a  
c343 3a 4d c3			ld a, (.dmark+2)  
c346 32 67 ee			ld (debug_mark+2),a  
c349 18 03			jr .pastdmark  
c34b ..			.dmark: db "TC2"  
c34e f1			.pastdmark: pop af  
c34f			endm  
# End of macro DMARK
c34f						CALLMONITOR 
c34f cd 6f ee			call debug_vector  
c352				endm  
# End of macro CALLMONITOR
c352					endif 
c352					; check to see if current char is a space 
c352			 
c352 fe 20				cp ' ' 
c354 28 21				jr z, .totsp 
c356 cd 68 8f				call to_lower 
c359					if DEBUG_FORTH_WORDS 
c359						DMARK "TC3" 
c359 f5				push af  
c35a 3a 6e c3			ld a, (.dmark)  
c35d 32 65 ee			ld (debug_mark),a  
c360 3a 6f c3			ld a, (.dmark+1)  
c363 32 66 ee			ld (debug_mark+1),a  
c366 3a 70 c3			ld a, (.dmark+2)  
c369 32 67 ee			ld (debug_mark+2),a  
c36c 18 03			jr .pastdmark  
c36e ..			.dmark: db "TC3"  
c371 f1			.pastdmark: pop af  
c372			endm  
# End of macro DMARK
c372						CALLMONITOR 
c372 cd 6f ee			call debug_vector  
c375				endm  
# End of macro CALLMONITOR
c375					endif 
c375 18 63				jr .totnxt 
c377			 
c377			.totsp:         ; on a space, find next char which should be upper 
c377			 
c377					if DEBUG_FORTH_WORDS 
c377						DMARK "TC4" 
c377 f5				push af  
c378 3a 8c c3			ld a, (.dmark)  
c37b 32 65 ee			ld (debug_mark),a  
c37e 3a 8d c3			ld a, (.dmark+1)  
c381 32 66 ee			ld (debug_mark+1),a  
c384 3a 8e c3			ld a, (.dmark+2)  
c387 32 67 ee			ld (debug_mark+2),a  
c38a 18 03			jr .pastdmark  
c38c ..			.dmark: db "TC4"  
c38f f1			.pastdmark: pop af  
c390			endm  
# End of macro DMARK
c390						CALLMONITOR 
c390 cd 6f ee			call debug_vector  
c393				endm  
# End of macro CALLMONITOR
c393					endif 
c393					;; 
c393			 
c393 fe 20				cp ' ' 
c395 20 20				jr nz, .totsiptou 
c397 23					inc hl 
c398 7e					ld a, (hl) 
c399					if DEBUG_FORTH_WORDS 
c399						DMARK "TC5" 
c399 f5				push af  
c39a 3a ae c3			ld a, (.dmark)  
c39d 32 65 ee			ld (debug_mark),a  
c3a0 3a af c3			ld a, (.dmark+1)  
c3a3 32 66 ee			ld (debug_mark+1),a  
c3a6 3a b0 c3			ld a, (.dmark+2)  
c3a9 32 67 ee			ld (debug_mark+2),a  
c3ac 18 03			jr .pastdmark  
c3ae ..			.dmark: db "TC5"  
c3b1 f1			.pastdmark: pop af  
c3b2			endm  
# End of macro DMARK
c3b2						CALLMONITOR 
c3b2 cd 6f ee			call debug_vector  
c3b5				endm  
# End of macro CALLMONITOR
c3b5					endif 
c3b5 18 c0				jr .totsp 
c3b7 fe 00		.totsiptou:    cp 0 
c3b9 28 40				jr z, .totdone 
c3bb					; not space and not zero term so upper case it 
c3bb cd 5f 8f				call to_upper 
c3be			 
c3be					if DEBUG_FORTH_WORDS 
c3be						DMARK "TC6" 
c3be f5				push af  
c3bf 3a d3 c3			ld a, (.dmark)  
c3c2 32 65 ee			ld (debug_mark),a  
c3c5 3a d4 c3			ld a, (.dmark+1)  
c3c8 32 66 ee			ld (debug_mark+1),a  
c3cb 3a d5 c3			ld a, (.dmark+2)  
c3ce 32 67 ee			ld (debug_mark+2),a  
c3d1 18 03			jr .pastdmark  
c3d3 ..			.dmark: db "TC6"  
c3d6 f1			.pastdmark: pop af  
c3d7			endm  
# End of macro DMARK
c3d7						CALLMONITOR 
c3d7 cd 6f ee			call debug_vector  
c3da				endm  
# End of macro CALLMONITOR
c3da					endif 
c3da			 
c3da			 
c3da			.totnxt: 
c3da			 
c3da 77					ld (hl), a 
c3db 23					inc hl 
c3dc					if DEBUG_FORTH_WORDS 
c3dc						DMARK "TC7" 
c3dc f5				push af  
c3dd 3a f1 c3			ld a, (.dmark)  
c3e0 32 65 ee			ld (debug_mark),a  
c3e3 3a f2 c3			ld a, (.dmark+1)  
c3e6 32 66 ee			ld (debug_mark+1),a  
c3e9 3a f3 c3			ld a, (.dmark+2)  
c3ec 32 67 ee			ld (debug_mark+2),a  
c3ef 18 03			jr .pastdmark  
c3f1 ..			.dmark: db "TC7"  
c3f4 f1			.pastdmark: pop af  
c3f5			endm  
# End of macro DMARK
c3f5						CALLMONITOR 
c3f5 cd 6f ee			call debug_vector  
c3f8				endm  
# End of macro CALLMONITOR
c3f8					endif 
c3f8 c3 30 c3				jp .tot 
c3fb			 
c3fb					 
c3fb			 
c3fb			 
c3fb			; for each char convert to low 
c3fb					 
c3fb			.totdone: 
c3fb					if DEBUG_FORTH_WORDS 
c3fb						DMARK "TCd" 
c3fb f5				push af  
c3fc 3a 10 c4			ld a, (.dmark)  
c3ff 32 65 ee			ld (debug_mark),a  
c402 3a 11 c4			ld a, (.dmark+1)  
c405 32 66 ee			ld (debug_mark+1),a  
c408 3a 12 c4			ld a, (.dmark+2)  
c40b 32 67 ee			ld (debug_mark+2),a  
c40e 18 03			jr .pastdmark  
c410 ..			.dmark: db "TCd"  
c413 f1			.pastdmark: pop af  
c414			endm  
# End of macro DMARK
c414						CALLMONITOR 
c414 cd 6f ee			call debug_vector  
c417				endm  
# End of macro CALLMONITOR
c417					endif 
c417					NEXTW 
c417 c3 76 9e			jp macro_next 
c41a				endm 
# End of macro NEXTW
c41a			 
c41a			.SUBSTR: 
c41a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c41a 48				db WORD_SYS_CORE+52             
c41b 78 c4			dw .LEFT            
c41d 07				db 6 + 1 
c41e .. 00			db "SUBSTR",0              
c425				endm 
# End of macro CWHEAD
c425			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c425			 
c425					if DEBUG_FORTH_WORDS_KEY 
c425						DMARK "SST" 
c425 f5				push af  
c426 3a 3a c4			ld a, (.dmark)  
c429 32 65 ee			ld (debug_mark),a  
c42c 3a 3b c4			ld a, (.dmark+1)  
c42f 32 66 ee			ld (debug_mark+1),a  
c432 3a 3c c4			ld a, (.dmark+2)  
c435 32 67 ee			ld (debug_mark+2),a  
c438 18 03			jr .pastdmark  
c43a ..			.dmark: db "SST"  
c43d f1			.pastdmark: pop af  
c43e			endm  
# End of macro DMARK
c43e						CALLMONITOR 
c43e cd 6f ee			call debug_vector  
c441				endm  
# End of macro CALLMONITOR
c441					endif 
c441			; TODO check string type 
c441					FORTH_DSP_VALUEHL 
c441 cd 8a 9c			call macro_dsp_valuehl 
c444				endm 
# End of macro FORTH_DSP_VALUEHL
c444			 
c444 e5					push hl      ; string length 
c445			 
c445					FORTH_DSP_POP 
c445 cd 42 9d			call macro_forth_dsp_pop 
c448				endm 
# End of macro FORTH_DSP_POP
c448			 
c448					FORTH_DSP_VALUEHL 
c448 cd 8a 9c			call macro_dsp_valuehl 
c44b				endm 
# End of macro FORTH_DSP_VALUEHL
c44b			 
c44b e5					push hl     ; start char 
c44c			 
c44c					FORTH_DSP_POP 
c44c cd 42 9d			call macro_forth_dsp_pop 
c44f				endm 
# End of macro FORTH_DSP_POP
c44f			 
c44f			 
c44f					FORTH_DSP_VALUE 
c44f cd 73 9c			call macro_forth_dsp_value 
c452				endm 
# End of macro FORTH_DSP_VALUE
c452			 
c452 d1					pop de    ; get start post offset 
c453			 
c453 19					add hl, de    ; starting offset 
c454			 
c454 c1					pop bc 
c455 c5					push bc      ; grab size of string 
c456			 
c456 e5					push hl    ; save string start  
c457			 
c457 26 00				ld h, 0 
c459 69					ld l, c 
c45a 23					inc hl 
c45b 23					inc hl 
c45c			 
c45c cd c5 90				call malloc 
c45f				if DEBUG_FORTH_MALLOC_GUARD 
c45f cc 47 ce				call z,malloc_error 
c462				endif 
c462			 
c462 eb					ex de, hl      ; save malloc area for string copy 
c463 e1					pop hl    ; get back source 
c464 c1					pop bc    ; get length of string back 
c465			 
c465 d5					push de    ; save malloc area for after we push 
c466 ed b0				ldir     ; copy substr 
c468			 
c468			 
c468 eb					ex de, hl 
c469 3e 00				ld a, 0 
c46b 77					ld (hl), a   ; term substr 
c46c			 
c46c					 
c46c e1					pop hl    ; get malloc so we can push it 
c46d e5					push hl   ; save so we can free it afterwards 
c46e			 
c46e cd f3 9a				call forth_push_str 
c471			 
c471 e1					pop hl 
c472 cd 8f 91				call free 
c475			 
c475					 
c475					 
c475			 
c475			 
c475					NEXTW 
c475 c3 76 9e			jp macro_next 
c478				endm 
# End of macro NEXTW
c478			 
c478			.LEFT: 
c478				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c478 48				db WORD_SYS_CORE+52             
c479 a0 c4			dw .RIGHT            
c47b 05				db 4 + 1 
c47c .. 00			db "LEFT",0              
c481				endm 
# End of macro CWHEAD
c481			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c481					if DEBUG_FORTH_WORDS_KEY 
c481						DMARK "LEF" 
c481 f5				push af  
c482 3a 96 c4			ld a, (.dmark)  
c485 32 65 ee			ld (debug_mark),a  
c488 3a 97 c4			ld a, (.dmark+1)  
c48b 32 66 ee			ld (debug_mark+1),a  
c48e 3a 98 c4			ld a, (.dmark+2)  
c491 32 67 ee			ld (debug_mark+2),a  
c494 18 03			jr .pastdmark  
c496 ..			.dmark: db "LEF"  
c499 f1			.pastdmark: pop af  
c49a			endm  
# End of macro DMARK
c49a						CALLMONITOR 
c49a cd 6f ee			call debug_vector  
c49d				endm  
# End of macro CALLMONITOR
c49d					endif 
c49d			 
c49d					NEXTW 
c49d c3 76 9e			jp macro_next 
c4a0				endm 
# End of macro NEXTW
c4a0			.RIGHT: 
c4a0				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c4a0 48				db WORD_SYS_CORE+52             
c4a1 c9 c4			dw .STR2NUM            
c4a3 06				db 5 + 1 
c4a4 .. 00			db "RIGHT",0              
c4aa				endm 
# End of macro CWHEAD
c4aa			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c4aa					if DEBUG_FORTH_WORDS_KEY 
c4aa						DMARK "RIG" 
c4aa f5				push af  
c4ab 3a bf c4			ld a, (.dmark)  
c4ae 32 65 ee			ld (debug_mark),a  
c4b1 3a c0 c4			ld a, (.dmark+1)  
c4b4 32 66 ee			ld (debug_mark+1),a  
c4b7 3a c1 c4			ld a, (.dmark+2)  
c4ba 32 67 ee			ld (debug_mark+2),a  
c4bd 18 03			jr .pastdmark  
c4bf ..			.dmark: db "RIG"  
c4c2 f1			.pastdmark: pop af  
c4c3			endm  
# End of macro DMARK
c4c3						CALLMONITOR 
c4c3 cd 6f ee			call debug_vector  
c4c6				endm  
# End of macro CALLMONITOR
c4c6					endif 
c4c6			 
c4c6					NEXTW 
c4c6 c3 76 9e			jp macro_next 
c4c9				endm 
# End of macro NEXTW
c4c9			 
c4c9			 
c4c9			.STR2NUM: 
c4c9				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c4c9 48				db WORD_SYS_CORE+52             
c4ca 55 c5			dw .NUM2STR            
c4cc 08				db 7 + 1 
c4cd .. 00			db "STR2NUM",0              
c4d5				endm 
# End of macro CWHEAD
c4d5			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c4d5			 
c4d5			 
c4d5			; TODO STR type check to do 
c4d5					if DEBUG_FORTH_WORDS_KEY 
c4d5						DMARK "S2N" 
c4d5 f5				push af  
c4d6 3a ea c4			ld a, (.dmark)  
c4d9 32 65 ee			ld (debug_mark),a  
c4dc 3a eb c4			ld a, (.dmark+1)  
c4df 32 66 ee			ld (debug_mark+1),a  
c4e2 3a ec c4			ld a, (.dmark+2)  
c4e5 32 67 ee			ld (debug_mark+2),a  
c4e8 18 03			jr .pastdmark  
c4ea ..			.dmark: db "S2N"  
c4ed f1			.pastdmark: pop af  
c4ee			endm  
# End of macro DMARK
c4ee						CALLMONITOR 
c4ee cd 6f ee			call debug_vector  
c4f1				endm  
# End of macro CALLMONITOR
c4f1					endif 
c4f1			 
c4f1					;FORTH_DSP 
c4f1					FORTH_DSP_VALUE 
c4f1 cd 73 9c			call macro_forth_dsp_value 
c4f4				endm 
# End of macro FORTH_DSP_VALUE
c4f4					;inc hl 
c4f4			 
c4f4 eb					ex de, hl 
c4f5					if DEBUG_FORTH_WORDS 
c4f5						DMARK "S2a" 
c4f5 f5				push af  
c4f6 3a 0a c5			ld a, (.dmark)  
c4f9 32 65 ee			ld (debug_mark),a  
c4fc 3a 0b c5			ld a, (.dmark+1)  
c4ff 32 66 ee			ld (debug_mark+1),a  
c502 3a 0c c5			ld a, (.dmark+2)  
c505 32 67 ee			ld (debug_mark+2),a  
c508 18 03			jr .pastdmark  
c50a ..			.dmark: db "S2a"  
c50d f1			.pastdmark: pop af  
c50e			endm  
# End of macro DMARK
c50e						CALLMONITOR 
c50e cd 6f ee			call debug_vector  
c511				endm  
# End of macro CALLMONITOR
c511					endif 
c511 cd e7 8f				call string_to_uint16 
c514			 
c514					if DEBUG_FORTH_WORDS 
c514						DMARK "S2b" 
c514 f5				push af  
c515 3a 29 c5			ld a, (.dmark)  
c518 32 65 ee			ld (debug_mark),a  
c51b 3a 2a c5			ld a, (.dmark+1)  
c51e 32 66 ee			ld (debug_mark+1),a  
c521 3a 2b c5			ld a, (.dmark+2)  
c524 32 67 ee			ld (debug_mark+2),a  
c527 18 03			jr .pastdmark  
c529 ..			.dmark: db "S2b"  
c52c f1			.pastdmark: pop af  
c52d			endm  
# End of macro DMARK
c52d						CALLMONITOR 
c52d cd 6f ee			call debug_vector  
c530				endm  
# End of macro CALLMONITOR
c530					endif 
c530			;		push hl 
c530					FORTH_DSP_POP 
c530 cd 42 9d			call macro_forth_dsp_pop 
c533				endm 
# End of macro FORTH_DSP_POP
c533			;		pop hl 
c533					 
c533					if DEBUG_FORTH_WORDS 
c533						DMARK "S2b" 
c533 f5				push af  
c534 3a 48 c5			ld a, (.dmark)  
c537 32 65 ee			ld (debug_mark),a  
c53a 3a 49 c5			ld a, (.dmark+1)  
c53d 32 66 ee			ld (debug_mark+1),a  
c540 3a 4a c5			ld a, (.dmark+2)  
c543 32 67 ee			ld (debug_mark+2),a  
c546 18 03			jr .pastdmark  
c548 ..			.dmark: db "S2b"  
c54b f1			.pastdmark: pop af  
c54c			endm  
# End of macro DMARK
c54c						CALLMONITOR 
c54c cd 6f ee			call debug_vector  
c54f				endm  
# End of macro CALLMONITOR
c54f					endif 
c54f cd 85 9a				call forth_push_numhl	 
c552			 
c552				 
c552				       NEXTW 
c552 c3 76 9e			jp macro_next 
c555				endm 
# End of macro NEXTW
c555			.NUM2STR: 
c555				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c555 48				db WORD_SYS_CORE+52             
c556 e7 c5			dw .CONCAT            
c558 08				db 7 + 1 
c559 .. 00			db "NUM2STR",0              
c561				endm 
# End of macro CWHEAD
c561			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
c561			 
c561			;		; malloc a string to target 
c561			;		ld hl, 10     ; TODO max string size should be fine 
c561			;		call malloc 
c561			;		push hl    ; save malloc location 
c561			; 
c561			; 
c561			;; TODO check int type 
c561					if DEBUG_FORTH_WORDS_KEY 
c561						DMARK "N2S" 
c561 f5				push af  
c562 3a 76 c5			ld a, (.dmark)  
c565 32 65 ee			ld (debug_mark),a  
c568 3a 77 c5			ld a, (.dmark+1)  
c56b 32 66 ee			ld (debug_mark+1),a  
c56e 3a 78 c5			ld a, (.dmark+2)  
c571 32 67 ee			ld (debug_mark+2),a  
c574 18 03			jr .pastdmark  
c576 ..			.dmark: db "N2S"  
c579 f1			.pastdmark: pop af  
c57a			endm  
# End of macro DMARK
c57a						CALLMONITOR 
c57a cd 6f ee			call debug_vector  
c57d				endm  
# End of macro CALLMONITOR
c57d					endif 
c57d			 
c57d					FORTH_DSP_VALUEHL 
c57d cd 8a 9c			call macro_dsp_valuehl 
c580				endm 
# End of macro FORTH_DSP_VALUEHL
c580			 
c580					if DEBUG_FORTH_WORDS 
c580						DMARK "NS1" 
c580 f5				push af  
c581 3a 95 c5			ld a, (.dmark)  
c584 32 65 ee			ld (debug_mark),a  
c587 3a 96 c5			ld a, (.dmark+1)  
c58a 32 66 ee			ld (debug_mark+1),a  
c58d 3a 97 c5			ld a, (.dmark+2)  
c590 32 67 ee			ld (debug_mark+2),a  
c593 18 03			jr .pastdmark  
c595 ..			.dmark: db "NS1"  
c598 f1			.pastdmark: pop af  
c599			endm  
# End of macro DMARK
c599						CALLMONITOR 
c599 cd 6f ee			call debug_vector  
c59c				endm  
# End of macro CALLMONITOR
c59c					endif 
c59c					FORTH_DSP_POP 
c59c cd 42 9d			call macro_forth_dsp_pop 
c59f				endm 
# End of macro FORTH_DSP_POP
c59f			 
c59f eb					ex de, hl 
c5a0 21 bb e2				ld hl, scratch 
c5a3					if DEBUG_FORTH_WORDS 
c5a3						DMARK "NS2" 
c5a3 f5				push af  
c5a4 3a b8 c5			ld a, (.dmark)  
c5a7 32 65 ee			ld (debug_mark),a  
c5aa 3a b9 c5			ld a, (.dmark+1)  
c5ad 32 66 ee			ld (debug_mark+1),a  
c5b0 3a ba c5			ld a, (.dmark+2)  
c5b3 32 67 ee			ld (debug_mark+2),a  
c5b6 18 03			jr .pastdmark  
c5b8 ..			.dmark: db "NS2"  
c5bb f1			.pastdmark: pop af  
c5bc			endm  
# End of macro DMARK
c5bc						CALLMONITOR 
c5bc cd 6f ee			call debug_vector  
c5bf				endm  
# End of macro CALLMONITOR
c5bf					endif 
c5bf cd ff 8f				call uitoa_16 
c5c2 21 bb e2				ld hl, scratch 
c5c5					if DEBUG_FORTH_WORDS 
c5c5						DMARK "NS3" 
c5c5 f5				push af  
c5c6 3a da c5			ld a, (.dmark)  
c5c9 32 65 ee			ld (debug_mark),a  
c5cc 3a db c5			ld a, (.dmark+1)  
c5cf 32 66 ee			ld (debug_mark+1),a  
c5d2 3a dc c5			ld a, (.dmark+2)  
c5d5 32 67 ee			ld (debug_mark+2),a  
c5d8 18 03			jr .pastdmark  
c5da ..			.dmark: db "NS3"  
c5dd f1			.pastdmark: pop af  
c5de			endm  
# End of macro DMARK
c5de						CALLMONITOR 
c5de cd 6f ee			call debug_vector  
c5e1				endm  
# End of macro CALLMONITOR
c5e1					endif 
c5e1 cd f3 9a				call forth_push_str 
c5e4			;		ld a, l 
c5e4			;		call DispAToASCII   
c5e4			;;TODO need to chage above call to dump into string 
c5e4			; 
c5e4			; 
c5e4			 
c5e4				       NEXTW 
c5e4 c3 76 9e			jp macro_next 
c5e7				endm 
# End of macro NEXTW
c5e7			 
c5e7			.CONCAT: 
c5e7				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c5e7 48				db WORD_SYS_CORE+52             
c5e8 9a c6			dw .FIND            
c5ea 07				db 6 + 1 
c5eb .. 00			db "CONCAT",0              
c5f2				endm 
# End of macro CWHEAD
c5f2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c5f2			 
c5f2			; TODO check string type 
c5f2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c5f2			 
c5f2					if DEBUG_FORTH_WORDS_KEY 
c5f2						DMARK "CON" 
c5f2 f5				push af  
c5f3 3a 07 c6			ld a, (.dmark)  
c5f6 32 65 ee			ld (debug_mark),a  
c5f9 3a 08 c6			ld a, (.dmark+1)  
c5fc 32 66 ee			ld (debug_mark+1),a  
c5ff 3a 09 c6			ld a, (.dmark+2)  
c602 32 67 ee			ld (debug_mark+2),a  
c605 18 03			jr .pastdmark  
c607 ..			.dmark: db "CON"  
c60a f1			.pastdmark: pop af  
c60b			endm  
# End of macro DMARK
c60b						CALLMONITOR 
c60b cd 6f ee			call debug_vector  
c60e				endm  
# End of macro CALLMONITOR
c60e					endif 
c60e			 
c60e			 
c60e					FORTH_DSP_VALUE 
c60e cd 73 9c			call macro_forth_dsp_value 
c611				endm 
# End of macro FORTH_DSP_VALUE
c611 e5					push hl   ; s2 
c612			 
c612					FORTH_DSP_POP 
c612 cd 42 9d			call macro_forth_dsp_pop 
c615				endm 
# End of macro FORTH_DSP_POP
c615			 
c615					FORTH_DSP_VALUE 
c615 cd 73 9c			call macro_forth_dsp_value 
c618				endm 
# End of macro FORTH_DSP_VALUE
c618			 
c618 e5					push hl   ; s1 
c619			 
c619					FORTH_DSP_POP 
c619 cd 42 9d			call macro_forth_dsp_pop 
c61c				endm 
# End of macro FORTH_DSP_POP
c61c					 
c61c			 
c61c					; copy s1 
c61c			 
c61c				 
c61c					; save ptr 
c61c e1					pop hl  
c61d e5					push hl 
c61e 3e 00				ld a, 0 
c620 cd 5b 90				call strlent 
c623					;inc hl    ; zer0 
c623 06 00				ld b, 0 
c625 4d					ld c, l 
c626 e1					pop hl		 
c627 11 bb e2				ld de, scratch	 
c62a					if DEBUG_FORTH_WORDS 
c62a						DMARK "CO1" 
c62a f5				push af  
c62b 3a 3f c6			ld a, (.dmark)  
c62e 32 65 ee			ld (debug_mark),a  
c631 3a 40 c6			ld a, (.dmark+1)  
c634 32 66 ee			ld (debug_mark+1),a  
c637 3a 41 c6			ld a, (.dmark+2)  
c63a 32 67 ee			ld (debug_mark+2),a  
c63d 18 03			jr .pastdmark  
c63f ..			.dmark: db "CO1"  
c642 f1			.pastdmark: pop af  
c643			endm  
# End of macro DMARK
c643						CALLMONITOR 
c643 cd 6f ee			call debug_vector  
c646				endm  
# End of macro CALLMONITOR
c646					endif 
c646 ed b0				ldir 
c648			 
c648 e1					pop hl 
c649 e5					push hl 
c64a d5					push de 
c64b			 
c64b			 
c64b 3e 00				ld a, 0 
c64d cd 5b 90				call strlent 
c650 23					inc hl    ; zer0 
c651 23					inc hl 
c652 06 00				ld b, 0 
c654 4d					ld c, l 
c655 d1					pop de 
c656 e1					pop hl		 
c657					if DEBUG_FORTH_WORDS 
c657						DMARK "CO2" 
c657 f5				push af  
c658 3a 6c c6			ld a, (.dmark)  
c65b 32 65 ee			ld (debug_mark),a  
c65e 3a 6d c6			ld a, (.dmark+1)  
c661 32 66 ee			ld (debug_mark+1),a  
c664 3a 6e c6			ld a, (.dmark+2)  
c667 32 67 ee			ld (debug_mark+2),a  
c66a 18 03			jr .pastdmark  
c66c ..			.dmark: db "CO2"  
c66f f1			.pastdmark: pop af  
c670			endm  
# End of macro DMARK
c670						CALLMONITOR 
c670 cd 6f ee			call debug_vector  
c673				endm  
# End of macro CALLMONITOR
c673					endif 
c673 ed b0				ldir 
c675			 
c675			 
c675			 
c675 21 bb e2				ld hl, scratch 
c678					if DEBUG_FORTH_WORDS 
c678						DMARK "CO5" 
c678 f5				push af  
c679 3a 8d c6			ld a, (.dmark)  
c67c 32 65 ee			ld (debug_mark),a  
c67f 3a 8e c6			ld a, (.dmark+1)  
c682 32 66 ee			ld (debug_mark+1),a  
c685 3a 8f c6			ld a, (.dmark+2)  
c688 32 67 ee			ld (debug_mark+2),a  
c68b 18 03			jr .pastdmark  
c68d ..			.dmark: db "CO5"  
c690 f1			.pastdmark: pop af  
c691			endm  
# End of macro DMARK
c691						CALLMONITOR 
c691 cd 6f ee			call debug_vector  
c694				endm  
# End of macro CALLMONITOR
c694					endif 
c694			 
c694 cd f3 9a				call forth_push_str 
c697			 
c697			 
c697			 
c697			 
c697				       NEXTW 
c697 c3 76 9e			jp macro_next 
c69a				endm 
# End of macro NEXTW
c69a			 
c69a			 
c69a			.FIND: 
c69a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c69a 4b				db WORD_SYS_CORE+55             
c69b 58 c7			dw .LEN            
c69d 05				db 4 + 1 
c69e .. 00			db "FIND",0              
c6a3				endm 
# End of macro CWHEAD
c6a3			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c6a3			 
c6a3					if DEBUG_FORTH_WORDS_KEY 
c6a3						DMARK "FND" 
c6a3 f5				push af  
c6a4 3a b8 c6			ld a, (.dmark)  
c6a7 32 65 ee			ld (debug_mark),a  
c6aa 3a b9 c6			ld a, (.dmark+1)  
c6ad 32 66 ee			ld (debug_mark+1),a  
c6b0 3a ba c6			ld a, (.dmark+2)  
c6b3 32 67 ee			ld (debug_mark+2),a  
c6b6 18 03			jr .pastdmark  
c6b8 ..			.dmark: db "FND"  
c6bb f1			.pastdmark: pop af  
c6bc			endm  
# End of macro DMARK
c6bc						CALLMONITOR 
c6bc cd 6f ee			call debug_vector  
c6bf				endm  
# End of macro CALLMONITOR
c6bf					endif 
c6bf			 
c6bf			; TODO check string type 
c6bf					FORTH_DSP_VALUE 
c6bf cd 73 9c			call macro_forth_dsp_value 
c6c2				endm 
# End of macro FORTH_DSP_VALUE
c6c2			 
c6c2 e5					push hl    
c6c3 7e					ld a,(hl)    ; char to find   
c6c4			; TODO change char to substr 
c6c4			 
c6c4 f5					push af 
c6c5					 
c6c5			 
c6c5			 
c6c5					if DEBUG_FORTH_WORDS 
c6c5						DMARK "FN1" 
c6c5 f5				push af  
c6c6 3a da c6			ld a, (.dmark)  
c6c9 32 65 ee			ld (debug_mark),a  
c6cc 3a db c6			ld a, (.dmark+1)  
c6cf 32 66 ee			ld (debug_mark+1),a  
c6d2 3a dc c6			ld a, (.dmark+2)  
c6d5 32 67 ee			ld (debug_mark+2),a  
c6d8 18 03			jr .pastdmark  
c6da ..			.dmark: db "FN1"  
c6dd f1			.pastdmark: pop af  
c6de			endm  
# End of macro DMARK
c6de						CALLMONITOR 
c6de cd 6f ee			call debug_vector  
c6e1				endm  
# End of macro CALLMONITOR
c6e1					endif 
c6e1			 
c6e1					FORTH_DSP_POP 
c6e1 cd 42 9d			call macro_forth_dsp_pop 
c6e4				endm 
# End of macro FORTH_DSP_POP
c6e4			 
c6e4					; string to search 
c6e4			 
c6e4					FORTH_DSP_VALUE 
c6e4 cd 73 9c			call macro_forth_dsp_value 
c6e7				endm 
# End of macro FORTH_DSP_VALUE
c6e7			 
c6e7 d1					pop de  ; d is char to find  
c6e8			 
c6e8					if DEBUG_FORTH_WORDS 
c6e8						DMARK "FN2" 
c6e8 f5				push af  
c6e9 3a fd c6			ld a, (.dmark)  
c6ec 32 65 ee			ld (debug_mark),a  
c6ef 3a fe c6			ld a, (.dmark+1)  
c6f2 32 66 ee			ld (debug_mark+1),a  
c6f5 3a ff c6			ld a, (.dmark+2)  
c6f8 32 67 ee			ld (debug_mark+2),a  
c6fb 18 03			jr .pastdmark  
c6fd ..			.dmark: db "FN2"  
c700 f1			.pastdmark: pop af  
c701			endm  
# End of macro DMARK
c701						CALLMONITOR 
c701 cd 6f ee			call debug_vector  
c704				endm  
# End of macro CALLMONITOR
c704					endif 
c704					 
c704 01 00 00				ld bc, 0 
c707 7e			.findchar:      ld a,(hl) 
c708 fe 00				cp 0   		 
c70a 28 27				jr z, .finddone     
c70c ba					cp d 
c70d 28 20				jr z, .foundchar 
c70f 03					inc bc 
c710 23					inc hl 
c711					if DEBUG_FORTH_WORDS 
c711						DMARK "FN3" 
c711 f5				push af  
c712 3a 26 c7			ld a, (.dmark)  
c715 32 65 ee			ld (debug_mark),a  
c718 3a 27 c7			ld a, (.dmark+1)  
c71b 32 66 ee			ld (debug_mark+1),a  
c71e 3a 28 c7			ld a, (.dmark+2)  
c721 32 67 ee			ld (debug_mark+2),a  
c724 18 03			jr .pastdmark  
c726 ..			.dmark: db "FN3"  
c729 f1			.pastdmark: pop af  
c72a			endm  
# End of macro DMARK
c72a						CALLMONITOR 
c72a cd 6f ee			call debug_vector  
c72d				endm  
# End of macro CALLMONITOR
c72d					endif 
c72d 18 d8				jr .findchar 
c72f			 
c72f			 
c72f c5			.foundchar:	push bc 
c730 e1					pop hl 
c731 18 03				jr .findexit 
c733			 
c733			 
c733							 
c733			 
c733			.finddone:     ; got to end of string with no find 
c733 21 00 00				ld hl, 0 
c736			.findexit: 
c736			 
c736					if DEBUG_FORTH_WORDS 
c736						DMARK "FNd" 
c736 f5				push af  
c737 3a 4b c7			ld a, (.dmark)  
c73a 32 65 ee			ld (debug_mark),a  
c73d 3a 4c c7			ld a, (.dmark+1)  
c740 32 66 ee			ld (debug_mark+1),a  
c743 3a 4d c7			ld a, (.dmark+2)  
c746 32 67 ee			ld (debug_mark+2),a  
c749 18 03			jr .pastdmark  
c74b ..			.dmark: db "FNd"  
c74e f1			.pastdmark: pop af  
c74f			endm  
# End of macro DMARK
c74f						CALLMONITOR 
c74f cd 6f ee			call debug_vector  
c752				endm  
# End of macro CALLMONITOR
c752					endif 
c752 cd 85 9a			call forth_push_numhl 
c755			 
c755				       NEXTW 
c755 c3 76 9e			jp macro_next 
c758				endm 
# End of macro NEXTW
c758			 
c758			.LEN: 
c758				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c758 4c				db WORD_SYS_CORE+56             
c759 c2 c7			dw .ASC            
c75b 06				db 5 + 1 
c75c .. 00			db "COUNT",0              
c762				endm 
# End of macro CWHEAD
c762			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c762			 
c762					if DEBUG_FORTH_WORDS_KEY 
c762						DMARK "CNT" 
c762 f5				push af  
c763 3a 77 c7			ld a, (.dmark)  
c766 32 65 ee			ld (debug_mark),a  
c769 3a 78 c7			ld a, (.dmark+1)  
c76c 32 66 ee			ld (debug_mark+1),a  
c76f 3a 79 c7			ld a, (.dmark+2)  
c772 32 67 ee			ld (debug_mark+2),a  
c775 18 03			jr .pastdmark  
c777 ..			.dmark: db "CNT"  
c77a f1			.pastdmark: pop af  
c77b			endm  
# End of macro DMARK
c77b						CALLMONITOR 
c77b cd 6f ee			call debug_vector  
c77e				endm  
# End of macro CALLMONITOR
c77e					endif 
c77e			; TODO check string type 
c77e					FORTH_DSP_VALUE 
c77e cd 73 9c			call macro_forth_dsp_value 
c781				endm 
# End of macro FORTH_DSP_VALUE
c781			 
c781			 
c781					if DEBUG_FORTH_WORDS 
c781						DMARK "CN?" 
c781 f5				push af  
c782 3a 96 c7			ld a, (.dmark)  
c785 32 65 ee			ld (debug_mark),a  
c788 3a 97 c7			ld a, (.dmark+1)  
c78b 32 66 ee			ld (debug_mark+1),a  
c78e 3a 98 c7			ld a, (.dmark+2)  
c791 32 67 ee			ld (debug_mark+2),a  
c794 18 03			jr .pastdmark  
c796 ..			.dmark: db "CN?"  
c799 f1			.pastdmark: pop af  
c79a			endm  
# End of macro DMARK
c79a						CALLMONITOR 
c79a cd 6f ee			call debug_vector  
c79d				endm  
# End of macro CALLMONITOR
c79d					endif 
c79d cd 50 90				call strlenz 
c7a0					if DEBUG_FORTH_WORDS 
c7a0						DMARK "CNl" 
c7a0 f5				push af  
c7a1 3a b5 c7			ld a, (.dmark)  
c7a4 32 65 ee			ld (debug_mark),a  
c7a7 3a b6 c7			ld a, (.dmark+1)  
c7aa 32 66 ee			ld (debug_mark+1),a  
c7ad 3a b7 c7			ld a, (.dmark+2)  
c7b0 32 67 ee			ld (debug_mark+2),a  
c7b3 18 03			jr .pastdmark  
c7b5 ..			.dmark: db "CNl"  
c7b8 f1			.pastdmark: pop af  
c7b9			endm  
# End of macro DMARK
c7b9						CALLMONITOR 
c7b9 cd 6f ee			call debug_vector  
c7bc				endm  
# End of macro CALLMONITOR
c7bc					endif 
c7bc			 
c7bc cd 85 9a				call forth_push_numhl 
c7bf			 
c7bf			 
c7bf			 
c7bf				       NEXTW 
c7bf c3 76 9e			jp macro_next 
c7c2				endm 
# End of macro NEXTW
c7c2			.ASC: 
c7c2				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c7c2 4d				db WORD_SYS_CORE+57             
c7c3 30 c8			dw .CHR            
c7c5 04				db 3 + 1 
c7c6 .. 00			db "ASC",0              
c7ca				endm 
# End of macro CWHEAD
c7ca			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c7ca					if DEBUG_FORTH_WORDS_KEY 
c7ca						DMARK "ASC" 
c7ca f5				push af  
c7cb 3a df c7			ld a, (.dmark)  
c7ce 32 65 ee			ld (debug_mark),a  
c7d1 3a e0 c7			ld a, (.dmark+1)  
c7d4 32 66 ee			ld (debug_mark+1),a  
c7d7 3a e1 c7			ld a, (.dmark+2)  
c7da 32 67 ee			ld (debug_mark+2),a  
c7dd 18 03			jr .pastdmark  
c7df ..			.dmark: db "ASC"  
c7e2 f1			.pastdmark: pop af  
c7e3			endm  
# End of macro DMARK
c7e3						CALLMONITOR 
c7e3 cd 6f ee			call debug_vector  
c7e6				endm  
# End of macro CALLMONITOR
c7e6					endif 
c7e6					FORTH_DSP_VALUE 
c7e6 cd 73 9c			call macro_forth_dsp_value 
c7e9				endm 
# End of macro FORTH_DSP_VALUE
c7e9					;v5 FORTH_DSP_VALUE 
c7e9			;		inc hl      ; now at start of numeric as string 
c7e9			 
c7e9 e5					push hl 
c7ea			 
c7ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c7ea cd 42 9d			call macro_forth_dsp_pop 
c7ed				endm 
# End of macro FORTH_DSP_POP
c7ed			 
c7ed e1					pop hl 
c7ee			 
c7ee					if DEBUG_FORTH_WORDS 
c7ee						DMARK "AS1" 
c7ee f5				push af  
c7ef 3a 03 c8			ld a, (.dmark)  
c7f2 32 65 ee			ld (debug_mark),a  
c7f5 3a 04 c8			ld a, (.dmark+1)  
c7f8 32 66 ee			ld (debug_mark+1),a  
c7fb 3a 05 c8			ld a, (.dmark+2)  
c7fe 32 67 ee			ld (debug_mark+2),a  
c801 18 03			jr .pastdmark  
c803 ..			.dmark: db "AS1"  
c806 f1			.pastdmark: pop af  
c807			endm  
# End of macro DMARK
c807						CALLMONITOR 
c807 cd 6f ee			call debug_vector  
c80a				endm  
# End of macro CALLMONITOR
c80a					endif 
c80a					; push the content of a onto the stack as a value 
c80a			 
c80a 7e					ld a,(hl)   ; get char 
c80b 26 00				ld h,0 
c80d 6f					ld l,a 
c80e					if DEBUG_FORTH_WORDS 
c80e						DMARK "AS2" 
c80e f5				push af  
c80f 3a 23 c8			ld a, (.dmark)  
c812 32 65 ee			ld (debug_mark),a  
c815 3a 24 c8			ld a, (.dmark+1)  
c818 32 66 ee			ld (debug_mark+1),a  
c81b 3a 25 c8			ld a, (.dmark+2)  
c81e 32 67 ee			ld (debug_mark+2),a  
c821 18 03			jr .pastdmark  
c823 ..			.dmark: db "AS2"  
c826 f1			.pastdmark: pop af  
c827			endm  
# End of macro DMARK
c827						CALLMONITOR 
c827 cd 6f ee			call debug_vector  
c82a				endm  
# End of macro CALLMONITOR
c82a					endif 
c82a cd 85 9a				call forth_push_numhl 
c82d			 
c82d				       NEXTW 
c82d c3 76 9e			jp macro_next 
c830				endm 
# End of macro NEXTW
c830			 
c830			.CHR: 
c830				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c830 4d				db WORD_SYS_CORE+57             
c831 6c c8			dw .ENDSTR            
c833 04				db 3 + 1 
c834 .. 00			db "CHR",0              
c838				endm 
# End of macro CWHEAD
c838			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c838					if DEBUG_FORTH_WORDS_KEY 
c838						DMARK "CHR" 
c838 f5				push af  
c839 3a 4d c8			ld a, (.dmark)  
c83c 32 65 ee			ld (debug_mark),a  
c83f 3a 4e c8			ld a, (.dmark+1)  
c842 32 66 ee			ld (debug_mark+1),a  
c845 3a 4f c8			ld a, (.dmark+2)  
c848 32 67 ee			ld (debug_mark+2),a  
c84b 18 03			jr .pastdmark  
c84d ..			.dmark: db "CHR"  
c850 f1			.pastdmark: pop af  
c851			endm  
# End of macro DMARK
c851						CALLMONITOR 
c851 cd 6f ee			call debug_vector  
c854				endm  
# End of macro CALLMONITOR
c854					endif 
c854					FORTH_DSP_VALUEHL 
c854 cd 8a 9c			call macro_dsp_valuehl 
c857				endm 
# End of macro FORTH_DSP_VALUEHL
c857			 
c857					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c857 cd 42 9d			call macro_forth_dsp_pop 
c85a				endm 
# End of macro FORTH_DSP_POP
c85a			 
c85a					; save asci byte as a zero term string and push string 
c85a			 
c85a 7d					ld a,l 
c85b 32 bb e2				ld (scratch), a 
c85e			 
c85e 3e 00				ld a, 0 
c860 32 bc e2				ld (scratch+1), a 
c863			 
c863 21 bb e2				ld hl, scratch 
c866 cd f3 9a				call forth_push_str 
c869			 
c869			 
c869				       NEXTW 
c869 c3 76 9e			jp macro_next 
c86c				endm 
# End of macro NEXTW
c86c			 
c86c			 
c86c			 
c86c			 
c86c			.ENDSTR: 
c86c			; eof 
c86c			 
# End of file forth_words_str.asm
c86c			include "forth_words_key.asm" 
c86c			 
c86c			; | ## Keyboard Words 
c86c			 
c86c			.KEY: 
c86c				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
c86c 3e				db WORD_SYS_CORE+42             
c86d 9c c8			dw .KEYDB            
c86f 04				db 3 + 1 
c870 .. 00			db "KEY",0              
c874				endm 
# End of macro CWHEAD
c874			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
c874			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
c874			; | | Can use something like this to process: 
c874			; | | > repeat active . key ?dup if emit then #1 until  
c874			 
c874					if DEBUG_FORTH_WORDS_KEY 
c874						DMARK "KEY" 
c874 f5				push af  
c875 3a 89 c8			ld a, (.dmark)  
c878 32 65 ee			ld (debug_mark),a  
c87b 3a 8a c8			ld a, (.dmark+1)  
c87e 32 66 ee			ld (debug_mark+1),a  
c881 3a 8b c8			ld a, (.dmark+2)  
c884 32 67 ee			ld (debug_mark+2),a  
c887 18 03			jr .pastdmark  
c889 ..			.dmark: db "KEY"  
c88c f1			.pastdmark: pop af  
c88d			endm  
# End of macro DMARK
c88d						CALLMONITOR 
c88d cd 6f ee			call debug_vector  
c890				endm  
# End of macro CALLMONITOR
c890					endif 
c890			; TODO currently waits 
c890 cd 88 df				call cinndb 
c893					;call cin_wait 
c893 6f					ld l, a 
c894 26 00				ld h, 0 
c896 cd 85 9a				call forth_push_numhl 
c899					NEXTW 
c899 c3 76 9e			jp macro_next 
c89c				endm 
# End of macro NEXTW
c89c			.KEYDB: 
c89c				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
c89c 3e				db WORD_SYS_CORE+42             
c89d ce c8			dw .WAITK            
c89f 06				db 5 + 1 
c8a0 .. 00			db "KEYDB",0              
c8a6				endm 
# End of macro CWHEAD
c8a6			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
c8a6			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
c8a6			; | | Can use something like this to process: 
c8a6			; | | > repeat active . key ?dup if emit then #1 until  
c8a6			 
c8a6					if DEBUG_FORTH_WORDS_KEY 
c8a6						DMARK "KEB" 
c8a6 f5				push af  
c8a7 3a bb c8			ld a, (.dmark)  
c8aa 32 65 ee			ld (debug_mark),a  
c8ad 3a bc c8			ld a, (.dmark+1)  
c8b0 32 66 ee			ld (debug_mark+1),a  
c8b3 3a bd c8			ld a, (.dmark+2)  
c8b6 32 67 ee			ld (debug_mark+2),a  
c8b9 18 03			jr .pastdmark  
c8bb ..			.dmark: db "KEB"  
c8be f1			.pastdmark: pop af  
c8bf			endm  
# End of macro DMARK
c8bf						CALLMONITOR 
c8bf cd 6f ee			call debug_vector  
c8c2				endm  
# End of macro CALLMONITOR
c8c2					endif 
c8c2			; TODO currently waits 
c8c2 cd 88 df				call cin 
c8c5					;call cin_wait 
c8c5 6f					ld l, a 
c8c6 26 00				ld h, 0 
c8c8 cd 85 9a				call forth_push_numhl 
c8cb					NEXTW 
c8cb c3 76 9e			jp macro_next 
c8ce				endm 
# End of macro NEXTW
c8ce			.WAITK: 
c8ce				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c8ce 3f				db WORD_SYS_CORE+43             
c8cf 00 c9			dw .ACCEPT            
c8d1 06				db 5 + 1 
c8d2 .. 00			db "WAITK",0              
c8d8				endm 
# End of macro CWHEAD
c8d8			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c8d8					if DEBUG_FORTH_WORDS_KEY 
c8d8						DMARK "WAI" 
c8d8 f5				push af  
c8d9 3a ed c8			ld a, (.dmark)  
c8dc 32 65 ee			ld (debug_mark),a  
c8df 3a ee c8			ld a, (.dmark+1)  
c8e2 32 66 ee			ld (debug_mark+1),a  
c8e5 3a ef c8			ld a, (.dmark+2)  
c8e8 32 67 ee			ld (debug_mark+2),a  
c8eb 18 03			jr .pastdmark  
c8ed ..			.dmark: db "WAI"  
c8f0 f1			.pastdmark: pop af  
c8f1			endm  
# End of macro DMARK
c8f1						CALLMONITOR 
c8f1 cd 6f ee			call debug_vector  
c8f4				endm  
# End of macro CALLMONITOR
c8f4					endif 
c8f4 cd 82 df				call cin_wait 
c8f7 6f					ld l, a 
c8f8 26 00				ld h, 0 
c8fa cd 85 9a				call forth_push_numhl 
c8fd					NEXTW 
c8fd c3 76 9e			jp macro_next 
c900				endm 
# End of macro NEXTW
c900			.ACCEPT: 
c900				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c900 40				db WORD_SYS_CORE+44             
c901 5e c9			dw .EDIT            
c903 07				db 6 + 1 
c904 .. 00			db "ACCEPT",0              
c90b				endm 
# End of macro CWHEAD
c90b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c90b					; TODO crashes on push 
c90b					if DEBUG_FORTH_WORDS_KEY 
c90b						DMARK "ACC" 
c90b f5				push af  
c90c 3a 20 c9			ld a, (.dmark)  
c90f 32 65 ee			ld (debug_mark),a  
c912 3a 21 c9			ld a, (.dmark+1)  
c915 32 66 ee			ld (debug_mark+1),a  
c918 3a 22 c9			ld a, (.dmark+2)  
c91b 32 67 ee			ld (debug_mark+2),a  
c91e 18 03			jr .pastdmark  
c920 ..			.dmark: db "ACC"  
c923 f1			.pastdmark: pop af  
c924			endm  
# End of macro DMARK
c924						CALLMONITOR 
c924 cd 6f ee			call debug_vector  
c927				endm  
# End of macro CALLMONITOR
c927					endif 
c927 21 b9 e4				ld hl, os_input 
c92a 3e 00				ld a, 0 
c92c 77					ld (hl),a 
c92d 3a 58 ea				ld a,(f_cursor_ptr) 
c930 16 64				ld d, 100 
c932 0e 00				ld c, 0 
c934 1e 28				ld e, 40 
c936 cd 17 8d				call input_str 
c939					; TODO perhaps do a type check and wrap in quotes if not a number 
c939 21 b9 e4				ld hl, os_input 
c93c					if DEBUG_FORTH_WORDS 
c93c						DMARK "AC1" 
c93c f5				push af  
c93d 3a 51 c9			ld a, (.dmark)  
c940 32 65 ee			ld (debug_mark),a  
c943 3a 52 c9			ld a, (.dmark+1)  
c946 32 66 ee			ld (debug_mark+1),a  
c949 3a 53 c9			ld a, (.dmark+2)  
c94c 32 67 ee			ld (debug_mark+2),a  
c94f 18 03			jr .pastdmark  
c951 ..			.dmark: db "AC1"  
c954 f1			.pastdmark: pop af  
c955			endm  
# End of macro DMARK
c955						CALLMONITOR 
c955 cd 6f ee			call debug_vector  
c958				endm  
# End of macro CALLMONITOR
c958					endif 
c958 cd f3 9a				call forth_push_str 
c95b					NEXTW 
c95b c3 76 9e			jp macro_next 
c95e				endm 
# End of macro NEXTW
c95e			 
c95e			.EDIT: 
c95e				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c95e 40				db WORD_SYS_CORE+44             
c95f 00 ca			dw .DEDIT            
c961 05				db 4 + 1 
c962 .. 00			db "EDIT",0              
c967				endm 
# End of macro CWHEAD
c967			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c967			 
c967					; TODO does not copy from stack 
c967					if DEBUG_FORTH_WORDS_KEY 
c967						DMARK "EDT" 
c967 f5				push af  
c968 3a 7c c9			ld a, (.dmark)  
c96b 32 65 ee			ld (debug_mark),a  
c96e 3a 7d c9			ld a, (.dmark+1)  
c971 32 66 ee			ld (debug_mark+1),a  
c974 3a 7e c9			ld a, (.dmark+2)  
c977 32 67 ee			ld (debug_mark+2),a  
c97a 18 03			jr .pastdmark  
c97c ..			.dmark: db "EDT"  
c97f f1			.pastdmark: pop af  
c980			endm  
# End of macro DMARK
c980						CALLMONITOR 
c980 cd 6f ee			call debug_vector  
c983				endm  
# End of macro CALLMONITOR
c983					endif 
c983			 
c983					;FORTH_DSP 
c983					FORTH_DSP_VALUEHL 
c983 cd 8a 9c			call macro_dsp_valuehl 
c986				endm 
# End of macro FORTH_DSP_VALUEHL
c986			;		inc hl    ; TODO do type check 
c986			 
c986			;		call get_word_hl 
c986 e5					push hl 
c987					if DEBUG_FORTH_WORDS 
c987						DMARK "EDp" 
c987 f5				push af  
c988 3a 9c c9			ld a, (.dmark)  
c98b 32 65 ee			ld (debug_mark),a  
c98e 3a 9d c9			ld a, (.dmark+1)  
c991 32 66 ee			ld (debug_mark+1),a  
c994 3a 9e c9			ld a, (.dmark+2)  
c997 32 67 ee			ld (debug_mark+2),a  
c99a 18 03			jr .pastdmark  
c99c ..			.dmark: db "EDp"  
c99f f1			.pastdmark: pop af  
c9a0			endm  
# End of macro DMARK
c9a0						CALLMONITOR 
c9a0 cd 6f ee			call debug_vector  
c9a3				endm  
# End of macro CALLMONITOR
c9a3					endif 
c9a3				;	ld a, 0 
c9a3 cd 50 90				call strlenz 
c9a6 23					inc hl 
c9a7			 
c9a7 06 00				ld b, 0 
c9a9 4d					ld c, l 
c9aa			 
c9aa e1					pop hl 
c9ab 11 b9 e4				ld de, os_input 
c9ae					if DEBUG_FORTH_WORDS_KEY 
c9ae						DMARK "EDc" 
c9ae f5				push af  
c9af 3a c3 c9			ld a, (.dmark)  
c9b2 32 65 ee			ld (debug_mark),a  
c9b5 3a c4 c9			ld a, (.dmark+1)  
c9b8 32 66 ee			ld (debug_mark+1),a  
c9bb 3a c5 c9			ld a, (.dmark+2)  
c9be 32 67 ee			ld (debug_mark+2),a  
c9c1 18 03			jr .pastdmark  
c9c3 ..			.dmark: db "EDc"  
c9c6 f1			.pastdmark: pop af  
c9c7			endm  
# End of macro DMARK
c9c7						CALLMONITOR 
c9c7 cd 6f ee			call debug_vector  
c9ca				endm  
# End of macro CALLMONITOR
c9ca					endif 
c9ca ed b0				ldir 
c9cc			 
c9cc			 
c9cc 21 b9 e4				ld hl, os_input 
c9cf					;ld a, 0 
c9cf					;ld (hl),a 
c9cf 3a 58 ea				ld a,(f_cursor_ptr) 
c9d2 16 64				ld d, 100 
c9d4 0e 00				ld c, 0 
c9d6 1e 28				ld e, 40 
c9d8 cd 17 8d				call input_str 
c9db					; TODO perhaps do a type check and wrap in quotes if not a number 
c9db 21 b9 e4				ld hl, os_input 
c9de					if DEBUG_FORTH_WORDS 
c9de						DMARK "ED1" 
c9de f5				push af  
c9df 3a f3 c9			ld a, (.dmark)  
c9e2 32 65 ee			ld (debug_mark),a  
c9e5 3a f4 c9			ld a, (.dmark+1)  
c9e8 32 66 ee			ld (debug_mark+1),a  
c9eb 3a f5 c9			ld a, (.dmark+2)  
c9ee 32 67 ee			ld (debug_mark+2),a  
c9f1 18 03			jr .pastdmark  
c9f3 ..			.dmark: db "ED1"  
c9f6 f1			.pastdmark: pop af  
c9f7			endm  
# End of macro DMARK
c9f7						CALLMONITOR 
c9f7 cd 6f ee			call debug_vector  
c9fa				endm  
# End of macro CALLMONITOR
c9fa					endif 
c9fa cd f3 9a				call forth_push_str 
c9fd					NEXTW 
c9fd c3 76 9e			jp macro_next 
ca00				endm 
# End of macro NEXTW
ca00			 
ca00			.DEDIT: 
ca00				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
ca00 40				db WORD_SYS_CORE+44             
ca01 62 ca			dw .ENDKEY            
ca03 06				db 5 + 1 
ca04 .. 00			db "DEDIT",0              
ca0a				endm 
# End of macro CWHEAD
ca0a			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
ca0a			 
ca0a					; TODO does not copy from stack 
ca0a					if DEBUG_FORTH_WORDS_KEY 
ca0a						DMARK "DED" 
ca0a f5				push af  
ca0b 3a 1f ca			ld a, (.dmark)  
ca0e 32 65 ee			ld (debug_mark),a  
ca11 3a 20 ca			ld a, (.dmark+1)  
ca14 32 66 ee			ld (debug_mark+1),a  
ca17 3a 21 ca			ld a, (.dmark+2)  
ca1a 32 67 ee			ld (debug_mark+2),a  
ca1d 18 03			jr .pastdmark  
ca1f ..			.dmark: db "DED"  
ca22 f1			.pastdmark: pop af  
ca23			endm  
# End of macro DMARK
ca23						CALLMONITOR 
ca23 cd 6f ee			call debug_vector  
ca26				endm  
# End of macro CALLMONITOR
ca26					endif 
ca26			 
ca26					;FORTH_DSP 
ca26					FORTH_DSP_VALUEHL 
ca26 cd 8a 9c			call macro_dsp_valuehl 
ca29				endm 
# End of macro FORTH_DSP_VALUEHL
ca29			;		inc hl    ; TODO do type check 
ca29			 
ca29			;		call get_word_hl 
ca29 e5					push hl 
ca2a e5					push hl 
ca2b					FORTH_DSP_POP 
ca2b cd 42 9d			call macro_forth_dsp_pop 
ca2e				endm 
# End of macro FORTH_DSP_POP
ca2e e1					pop hl 
ca2f					if DEBUG_FORTH_WORDS 
ca2f						DMARK "EDp" 
ca2f f5				push af  
ca30 3a 44 ca			ld a, (.dmark)  
ca33 32 65 ee			ld (debug_mark),a  
ca36 3a 45 ca			ld a, (.dmark+1)  
ca39 32 66 ee			ld (debug_mark+1),a  
ca3c 3a 46 ca			ld a, (.dmark+2)  
ca3f 32 67 ee			ld (debug_mark+2),a  
ca42 18 03			jr .pastdmark  
ca44 ..			.dmark: db "EDp"  
ca47 f1			.pastdmark: pop af  
ca48			endm  
# End of macro DMARK
ca48						CALLMONITOR 
ca48 cd 6f ee			call debug_vector  
ca4b				endm  
# End of macro CALLMONITOR
ca4b					endif 
ca4b				;	ld a, 0 
ca4b cd 50 90				call strlenz 
ca4e 23					inc hl 
ca4f			 
ca4f 06 00				ld b, 0 
ca51 4d					ld c, l 
ca52			 
ca52 e1					pop hl 
ca53			 
ca53					;ld a, 0 
ca53					;ld (hl),a 
ca53 3a 58 ea				ld a,(f_cursor_ptr) 
ca56 16 64				ld d, 100 
ca58 0e 00				ld c, 0 
ca5a 1e 28				ld e, 40 
ca5c cd 17 8d				call input_str 
ca5f					; TODO perhaps do a type check and wrap in quotes if not a number 
ca5f					NEXTW 
ca5f c3 76 9e			jp macro_next 
ca62				endm 
# End of macro NEXTW
ca62			 
ca62			 
ca62			.ENDKEY: 
ca62			; eof 
ca62			 
# End of file forth_words_key.asm
ca62			include "forth_words_const.asm" 
ca62			 
ca62			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
ca62			 
ca62			 
ca62			.SPITIME: 
ca62				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
ca62 77				db WORD_SYS_CORE+99             
ca63 77 ca			dw .VA            
ca65 08				db 7 + 1 
ca66 .. 00			db "SPITIME",0              
ca6e				endm 
# End of macro CWHEAD
ca6e			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
ca6e			; 
ca6e			; | | If using BANK devices then leave as is. 
ca6e			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
ca6e			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
ca6e			 
ca6e 21 5e ea				ld hl, spi_clktime  
ca71 cd 85 9a				call forth_push_numhl 
ca74			 
ca74					NEXTW 
ca74 c3 76 9e			jp macro_next 
ca77				endm 
# End of macro NEXTW
ca77			 
ca77			 
ca77			.VA: 
ca77				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
ca77 77				db WORD_SYS_CORE+99             
ca78 87 ca			dw .SYMBOL            
ca7a 03				db 2 + 1 
ca7b .. 00			db "VA",0              
ca7e				endm 
# End of macro CWHEAD
ca7e			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
ca7e 21 22 ea				ld hl, cli_var_array 
ca81 cd 85 9a				call forth_push_numhl 
ca84			 
ca84					NEXTW 
ca84 c3 76 9e			jp macro_next 
ca87				endm 
# End of macro NEXTW
ca87			 
ca87			.SYMBOL: 
ca87				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
ca87 77				db WORD_SYS_CORE+99             
ca88 91 cb			dw .ENDCONST            
ca8a 07				db 6 + 1 
ca8b .. 00			db "SYMBOL",0              
ca92				endm 
# End of macro CWHEAD
ca92			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
ca92			; | 
ca92			; | | The value is the number reference and the final address is pushed to stack 
ca92			 
ca92			; | | ``` 
ca92			; | | dw sym_table 
ca92			; | | dw nmi_vector 
ca92			; | | dw cli_autodisplay 
ca92			; | | dw cli_data_sp 
ca92			; | | dw cli_data_stack 
ca92			; | | dw cli_loop_sp 
ca92			; | | dw cli_loop_stack 
ca92			; | | dw cli_var_array 
ca92			; | | dw cursor_col 
ca92			; | | dw cursor_ptr 
ca92			; | | ; 10 
ca92			; | | dw cursor_row 
ca92			; | | dw debug_mark 
ca92			; | | dw display_fb0 
ca92			; | | dw display_fb1 
ca92			; | | dw display_fb2 
ca92			; | | dw display_fb3 
ca92			; | | dw display_fb_active 
ca92			; | | dw execscratch 
ca92			; | | dw f_cursor_ptr 
ca92			; | | dw hardware_word 
ca92			; | | ;20 
ca92			; | | dw input_at_cursor 
ca92			; | | dw input_at_pos 
ca92			; | | dw input_cur_flash 
ca92			; | | dw input_cur_onoff 
ca92			; | | dw input_cursor 
ca92			; | | dw input_display_size 
ca92			; | | dw input_len 
ca92			; | | dw input_ptr 
ca92			; | | dw input_size 
ca92			; | | dw input_start 
ca92			; | | ; 30 
ca92			; | | dw input_str 
ca92			; | | dw input_under_cursor 
ca92			; | | dw os_cli_cmd 
ca92			; | | dw os_cur_ptr 
ca92			; | | dw os_current_i 
ca92			; | | dw os_input 
ca92			; | | dw os_last_cmd 
ca92			; | | dw os_last_new_uword 
ca92			; | | dw debug_vector 
ca92			; | | dw os_view_hl 
ca92			; | | ;40 
ca92			; | | dw os_word_scratch 
ca92			; | | dw portbctl 
ca92			; | | dw portbdata 
ca92			; | | dw spi_cartdev 
ca92			; | | dw spi_cartdev2 
ca92			; | | dw spi_clktime 
ca92			; | | dw spi_device 
ca92			; | | dw spi_device_id 
ca92			; | | dw spi_portbyte 
ca92			; | | dw stackstore 
ca92			; | | ; 50 
ca92			; | | if STORAGE_SE 
ca92			; | | dw storage_actl 
ca92			; | | dw storage_adata 
ca92			; | | else 
ca92			; | | dw 0 
ca92			; | | dw 0 
ca92			; | | endif 
ca92			; | | dw storage_append 
ca92			; | | if STORAGE_SE 
ca92			; | | dw storage_bctl 
ca92			; | | else 
ca92			; | | dw 0 
ca92			; | | endif 
ca92			; | | dw store_bank_active 
ca92			; | | dw store_filecache 
ca92			; | | dw store_longread 
ca92			; | | dw store_openaddr 
ca92			; | | dw store_openext 
ca92			; | | dw store_openmaxext 
ca92			; | | ; 60 
ca92			; | | dw store_page 
ca92			; | | dw store_readbuf 
ca92			; | | dw store_readcont 
ca92			; | | dw store_readptr 
ca92			; | | dw store_tmpext 
ca92			; | | dw store_tmpid 
ca92			; | | dw store_tmppageid 
ca92			; | | dw malloc 
ca92			; | | dw free 
ca92			; | | dw cin 
ca92			; | | ; 70 
ca92			; | | dw cin_wait 
ca92			; | | dw forth_push_numhl 
ca92			; | | dw forth_push_str 
ca92			; | | ``` 
ca92			 
ca92					if DEBUG_FORTH_WORDS_KEY 
ca92						DMARK "SYM" 
ca92 f5				push af  
ca93 3a a7 ca			ld a, (.dmark)  
ca96 32 65 ee			ld (debug_mark),a  
ca99 3a a8 ca			ld a, (.dmark+1)  
ca9c 32 66 ee			ld (debug_mark+1),a  
ca9f 3a a9 ca			ld a, (.dmark+2)  
caa2 32 67 ee			ld (debug_mark+2),a  
caa5 18 03			jr .pastdmark  
caa7 ..			.dmark: db "SYM"  
caaa f1			.pastdmark: pop af  
caab			endm  
# End of macro DMARK
caab						CALLMONITOR 
caab cd 6f ee			call debug_vector  
caae				endm  
# End of macro CALLMONITOR
caae					endif 
caae			 
caae					FORTH_DSP_VALUEHL 
caae cd 8a 9c			call macro_dsp_valuehl 
cab1				endm 
# End of macro FORTH_DSP_VALUEHL
cab1			 
cab1 7d					ld a, l     
cab2			 
cab2			 
cab2					if DEBUG_FORTH_WORDS 
cab2						DMARK "SY1" 
cab2 f5				push af  
cab3 3a c7 ca			ld a, (.dmark)  
cab6 32 65 ee			ld (debug_mark),a  
cab9 3a c8 ca			ld a, (.dmark+1)  
cabc 32 66 ee			ld (debug_mark+1),a  
cabf 3a c9 ca			ld a, (.dmark+2)  
cac2 32 67 ee			ld (debug_mark+2),a  
cac5 18 03			jr .pastdmark  
cac7 ..			.dmark: db "SY1"  
caca f1			.pastdmark: pop af  
cacb			endm  
# End of macro DMARK
cacb						CALLMONITOR 
cacb cd 6f ee			call debug_vector  
cace				endm  
# End of macro CALLMONITOR
cace					endif 
cace					 
cace f5					push af	 
cacf					FORTH_DSP_POP 
cacf cd 42 9d			call macro_forth_dsp_pop 
cad2				endm 
# End of macro FORTH_DSP_POP
cad2 f1					pop af 
cad3			 
cad3 cb 27				sla a  
cad5				 
cad5					 
cad5					if DEBUG_FORTH_WORDS 
cad5						DMARK "SY" 
cad5 f5				push af  
cad6 3a ea ca			ld a, (.dmark)  
cad9 32 65 ee			ld (debug_mark),a  
cadc 3a eb ca			ld a, (.dmark+1)  
cadf 32 66 ee			ld (debug_mark+1),a  
cae2 3a ec ca			ld a, (.dmark+2)  
cae5 32 67 ee			ld (debug_mark+2),a  
cae8 18 02			jr .pastdmark  
caea ..			.dmark: db "SY"  
caec f1			.pastdmark: pop af  
caed			endm  
# End of macro DMARK
caed						CALLMONITOR 
caed cd 6f ee			call debug_vector  
caf0				endm  
# End of macro CALLMONITOR
caf0					endif 
caf0			 
caf0 21 ff ca				ld hl, sym_table 
caf3 cd ea 8c				call addatohl 
caf6 cd f8 9d				call loadwordinhl 
caf9 cd 85 9a				call forth_push_numhl 
cafc			 
cafc			 
cafc				       NEXTW 
cafc c3 76 9e			jp macro_next 
caff				endm 
# End of macro NEXTW
caff			 
caff			sym_table: 
caff			 
caff			; 0 
caff ff ca		dw sym_table 
cb01 72 ee		dw nmi_vector 
cb03 36 ea		dw cli_autodisplay 
cb05 e8 e9		dw cli_data_sp 
cb07 22 e8		dw cli_data_stack 
cb09 ea e9		dw cli_loop_sp 
cb0b 24 e9		dw cli_loop_stack 
cb0d 22 ea		dw cli_var_array 
cb0f bf eb		dw cursor_col 
cb11 bd eb		dw cursor_ptr 
cb13			; 10 
cb13 be eb		dw cursor_row 
cb15 65 ee		dw debug_mark 
cb17 ab ed		dw display_fb0 
cb19 0a ed		dw display_fb1 
cb1b c8 eb		dw display_fb2 
cb1d 69 ec		dw display_fb3 
cb1f c6 eb		dw display_fb_active 
cb21 ba e3		dw execscratch 
cb23 58 ea		dw f_cursor_ptr 
cb25 75 ee		dw hardware_word 
cb27			;20 
cb27 5c ee		dw input_at_cursor 
cb29 5e ee		dw input_at_pos 
cb2b 5a ee		dw input_cur_flash 
cb2d 59 ee		dw input_cur_onoff 
cb2f 4f ee		dw input_cursor 
cb31 5f ee		dw input_display_size 
cb33 54 ee		dw input_len 
cb35 63 ee		dw input_ptr 
cb37 60 ee		dw input_size 
cb39 61 ee		dw input_start 
cb3b			; 30 
cb3b 17 8d		dw input_str 
cb3d 5d ee		dw input_under_cursor 
cb3f e2 e5		dw os_cli_cmd 
cb41 de e5		dw os_cur_ptr 
cb43 e0 e5		dw os_current_i 
cb45 b9 e4		dw os_input 
cb47 e1 e6		dw os_last_cmd 
cb49 b8 e5		dw os_last_new_uword 
cb4b 6f ee		dw debug_vector 
cb4d 9d e2		dw os_view_hl 
cb4f			;40 
cb4f c0 e5		dw os_word_scratch 
cb51 c3 00		dw portbctl 
cb53 c1 00		dw portbdata 
cb55 5d ea		dw spi_cartdev 
cb57 5c ea		dw spi_cartdev2 
cb59 5e ea		dw spi_clktime 
cb5b 5a ea		dw spi_device 
cb5d 59 ea		dw spi_device_id 
cb5f 5b ea		dw spi_portbyte 
cb61 a1 eb		dw stackstore 
cb63			; 50 
cb63			if STORAGE_SE 
cb63			dw storage_actl 
cb63			dw storage_adata 
cb63			else 
cb63 00 00		dw 0 
cb65 00 00		dw 0 
cb67			endif 
cb67 77 88		dw storage_append 
cb69			if STORAGE_SE 
cb69			dw storage_bctl 
cb69			else 
cb69 00 00		dw 0 
cb6b			endif 
cb6b 8d eb		dw store_bank_active 
cb6d 61 ea		dw store_filecache 
cb6f 6f ea		dw store_longread 
cb71 65 ea		dw store_openaddr 
cb73 64 ea		dw store_openext 
cb75 63 ea		dw store_openmaxext 
cb77			; 60 
cb77 74 ea		dw store_page 
cb79 70 ea		dw store_readbuf 
cb7b 67 ea		dw store_readcont 
cb7d 72 ea		dw store_readptr 
cb7f 67 ea		dw store_tmpext 
cb81 68 ea		dw store_tmpid 
cb83 5f ea		dw store_tmppageid 
cb85 c5 90		dw malloc 
cb87 8f 91		dw free 
cb89 88 df		dw cin 
cb8b			; 70 
cb8b 82 df		dw cin_wait 
cb8d 85 9a		dw forth_push_numhl 
cb8f f3 9a		dw forth_push_str 
cb91			 
cb91			 
cb91			.ENDCONST: 
cb91			 
cb91			; eof 
cb91			 
cb91			 
# End of file forth_words_const.asm
cb91			 
cb91			if STORAGE_SE 
cb91			   	include "forth_words_storage.asm" 
cb91			endif 
cb91				include "forth_words_device.asm" 
cb91			; Device related words 
cb91			 
cb91			; | ## Device Words 
cb91			 
cb91			;if SOUND_ENABLE 
cb91			;.NOTE: 
cb91			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
cb91			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
cb91			;		if DEBUG_FORTH_WORDS_KEY 
cb91			;			DMARK "NTE" 
cb91			;			CALLMONITOR 
cb91			;		endif 
cb91			; 
cb91			;	 
cb91			; 
cb91			;		NEXTW 
cb91			;.AFTERSOUND: 
cb91			;endif 
cb91			 
cb91			 
cb91			USE_GPIO: equ 0 
cb91			 
cb91			if USE_GPIO 
cb91			.GP1: 
cb91				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
cb91			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
cb91					NEXTW 
cb91			.GP2: 
cb91				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
cb91			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
cb91			 
cb91					NEXTW 
cb91			 
cb91			.GP3: 
cb91				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
cb91			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
cb91			 
cb91					NEXTW 
cb91			 
cb91			.GP4: 
cb91				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
cb91			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
cb91			 
cb91					NEXTW 
cb91			.SIN: 
cb91			 
cb91			 
cb91			endif 
cb91			 
cb91			 
cb91				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
cb91 33				db WORD_SYS_CORE+31             
cb92 c6 cb			dw .SOUT            
cb94 03				db 2 + 1 
cb95 .. 00			db "IN",0              
cb98				endm 
# End of macro CWHEAD
cb98			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
cb98					if DEBUG_FORTH_WORDS_KEY 
cb98						DMARK "IN." 
cb98 f5				push af  
cb99 3a ad cb			ld a, (.dmark)  
cb9c 32 65 ee			ld (debug_mark),a  
cb9f 3a ae cb			ld a, (.dmark+1)  
cba2 32 66 ee			ld (debug_mark+1),a  
cba5 3a af cb			ld a, (.dmark+2)  
cba8 32 67 ee			ld (debug_mark+2),a  
cbab 18 03			jr .pastdmark  
cbad ..			.dmark: db "IN."  
cbb0 f1			.pastdmark: pop af  
cbb1			endm  
# End of macro DMARK
cbb1						CALLMONITOR 
cbb1 cd 6f ee			call debug_vector  
cbb4				endm  
# End of macro CALLMONITOR
cbb4					endif 
cbb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbb4 cd 8a 9c			call macro_dsp_valuehl 
cbb7				endm 
# End of macro FORTH_DSP_VALUEHL
cbb7			 
cbb7 e5					push hl 
cbb8			 
cbb8					; destroy value TOS 
cbb8			 
cbb8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbb8 cd 42 9d			call macro_forth_dsp_pop 
cbbb				endm 
# End of macro FORTH_DSP_POP
cbbb			 
cbbb					; one value on hl get other one back 
cbbb			 
cbbb c1					pop bc 
cbbc			 
cbbc					; do the sub 
cbbc			;		ex de, hl 
cbbc			 
cbbc ed 68				in l,(c) 
cbbe			 
cbbe					; save it 
cbbe			 
cbbe 26 00				ld h,0 
cbc0			 
cbc0					; TODO push value back onto stack for another op etc 
cbc0			 
cbc0 cd 85 9a				call forth_push_numhl 
cbc3					NEXTW 
cbc3 c3 76 9e			jp macro_next 
cbc6				endm 
# End of macro NEXTW
cbc6			.SOUT: 
cbc6				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
cbc6 34				db WORD_SYS_CORE+32             
cbc7 19 cc			dw .SPIO            
cbc9 04				db 3 + 1 
cbca .. 00			db "OUT",0              
cbce				endm 
# End of macro CWHEAD
cbce			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
cbce					if DEBUG_FORTH_WORDS_KEY 
cbce						DMARK "OUT" 
cbce f5				push af  
cbcf 3a e3 cb			ld a, (.dmark)  
cbd2 32 65 ee			ld (debug_mark),a  
cbd5 3a e4 cb			ld a, (.dmark+1)  
cbd8 32 66 ee			ld (debug_mark+1),a  
cbdb 3a e5 cb			ld a, (.dmark+2)  
cbde 32 67 ee			ld (debug_mark+2),a  
cbe1 18 03			jr .pastdmark  
cbe3 ..			.dmark: db "OUT"  
cbe6 f1			.pastdmark: pop af  
cbe7			endm  
# End of macro DMARK
cbe7						CALLMONITOR 
cbe7 cd 6f ee			call debug_vector  
cbea				endm  
# End of macro CALLMONITOR
cbea					endif 
cbea			 
cbea					; get port 
cbea			 
cbea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbea cd 8a 9c			call macro_dsp_valuehl 
cbed				endm 
# End of macro FORTH_DSP_VALUEHL
cbed			 
cbed e5					push hl 
cbee			 
cbee					; destroy value TOS 
cbee			 
cbee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbee cd 42 9d			call macro_forth_dsp_pop 
cbf1				endm 
# End of macro FORTH_DSP_POP
cbf1			 
cbf1					; get byte to send 
cbf1			 
cbf1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbf1 cd 8a 9c			call macro_dsp_valuehl 
cbf4				endm 
# End of macro FORTH_DSP_VALUEHL
cbf4			 
cbf4			;		push hl 
cbf4			 
cbf4					; destroy value TOS 
cbf4			 
cbf4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbf4 cd 42 9d			call macro_forth_dsp_pop 
cbf7				endm 
# End of macro FORTH_DSP_POP
cbf7			 
cbf7					; one value on hl get other one back 
cbf7			 
cbf7			;		pop hl 
cbf7			 
cbf7 c1					pop bc 
cbf8			 
cbf8					if DEBUG_FORTH_WORDS 
cbf8						DMARK "OUT" 
cbf8 f5				push af  
cbf9 3a 0d cc			ld a, (.dmark)  
cbfc 32 65 ee			ld (debug_mark),a  
cbff 3a 0e cc			ld a, (.dmark+1)  
cc02 32 66 ee			ld (debug_mark+1),a  
cc05 3a 0f cc			ld a, (.dmark+2)  
cc08 32 67 ee			ld (debug_mark+2),a  
cc0b 18 03			jr .pastdmark  
cc0d ..			.dmark: db "OUT"  
cc10 f1			.pastdmark: pop af  
cc11			endm  
# End of macro DMARK
cc11						CALLMONITOR 
cc11 cd 6f ee			call debug_vector  
cc14				endm  
# End of macro CALLMONITOR
cc14					endif 
cc14			 
cc14 ed 69				out (c), l 
cc16			 
cc16					NEXTW 
cc16 c3 76 9e			jp macro_next 
cc19				endm 
# End of macro NEXTW
cc19			 
cc19			 
cc19			.SPIO: 
cc19			 
cc19			if STORAGE_SE 
cc19				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
cc19			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
cc19			 
cc19					call spi_ce_low 
cc19			    NEXTW 
cc19			 
cc19			.SPICEH: 
cc19				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
cc19			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
cc19			 
cc19					call spi_ce_high 
cc19			    NEXTW 
cc19			 
cc19			 
cc19			.SPIOb: 
cc19			 
cc19				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
cc19			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
cc19			 
cc19					if DEBUG_FORTH_WORDS_KEY 
cc19						DMARK "SPo" 
cc19						CALLMONITOR 
cc19					endif 
cc19					; get port 
cc19			 
cc19			 
cc19					; get byte to send 
cc19			 
cc19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc19			 
cc19			;		push hl    ; u1  
cc19			 
cc19					; destroy value TOS 
cc19			 
cc19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc19			 
cc19					; one value on hl get other one back 
cc19			 
cc19			;		pop hl   ; u2 - addr 
cc19			 
cc19					; TODO Send SPI byte 
cc19			 
cc19			;		push hl 
cc19			;		call spi_ce_low 
cc19			;		pop hl 
cc19					ld a, l 
cc19					call spi_send_byte 
cc19			;		call spi_ce_high 
cc19			 
cc19					NEXTW 
cc19			 
cc19			.SPII: 
cc19				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
cc19			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
cc19					if DEBUG_FORTH_WORDS_KEY 
cc19						DMARK "SPi" 
cc19						CALLMONITOR 
cc19					endif 
cc19			 
cc19					; TODO Get SPI byte 
cc19			 
cc19					call spi_read_byte 
cc19			 
cc19					if DEBUG_FORTH_WORDS 
cc19						DMARK "Si2" 
cc19						CALLMONITOR 
cc19					endif 
cc19					ld h, 0 
cc19					ld l, a 
cc19					if DEBUG_FORTH_WORDS 
cc19						DMARK "Si3" 
cc19						CALLMONITOR 
cc19					endif 
cc19					call forth_push_numhl 
cc19			 
cc19					NEXTW 
cc19			 
cc19			 
cc19			 
cc19			.SESEL: 
cc19				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
cc19			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
cc19					if DEBUG_FORTH_WORDS_KEY 
cc19						DMARK "BNK" 
cc19						CALLMONITOR 
cc19					endif 
cc19			 
cc19					ld a, 255 
cc19					ld (spi_cartdev), a 
cc19			 
cc19					; get bank 
cc19			 
cc19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc19			 
cc19			;		push hl 
cc19			 
cc19					; destroy value TOS 
cc19			 
cc19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc19			 
cc19					; one value on hl get other one back 
cc19			 
cc19			;		pop hl 
cc19			 
cc19			 
cc19					ld c, SPI_CE_HIGH 
cc19					ld b, '0'    ; human readable bank number 
cc19			 
cc19					ld a, l 
cc19			 
cc19					if DEBUG_FORTH_WORDS 
cc19						DMARK "BNK" 
cc19						CALLMONITOR 
cc19					endif 
cc19			 
cc19					; active low 
cc19			 
cc19					cp 0 
cc19					jr z, .bset 
cc19					cp 1 
cc19					jr nz, .b2 
cc19					res 0, c 
cc19					ld b, '1'    ; human readable bank number 
cc19			.b2:		cp 2 
cc19					jr nz, .b3 
cc19					res 1, c 
cc19					ld b, '2'    ; human readable bank number 
cc19			.b3:		cp 3 
cc19					jr nz, .b4 
cc19					res 2, c 
cc19					ld b, '3'    ; human readable bank number 
cc19			.b4:		cp 4 
cc19					jr nz, .b5 
cc19					res 3, c 
cc19					ld b, '4'    ; human readable bank number 
cc19			.b5:		cp 5 
cc19					jr nz, .bset 
cc19					res 4, c 
cc19					ld b, '5'    ; human readable bank number 
cc19			 
cc19			.bset: 
cc19					ld a, c 
cc19					ld (spi_device),a 
cc19					ld a, b 
cc19					ld (spi_device_id),a 
cc19					if DEBUG_FORTH_WORDS 
cc19						DMARK "BN2" 
cc19						CALLMONITOR 
cc19					endif 
cc19			 
cc19					; set default SPI clk pulse time as disabled for BANK use 
cc19			 
cc19					ld a, 0 
cc19					ld (spi_clktime), a 
cc19			 
cc19					NEXTW 
cc19			 
cc19			.CARTDEV: 
cc19				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
cc19			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
cc19					if DEBUG_FORTH_WORDS_KEY 
cc19						DMARK "CDV" 
cc19						CALLMONITOR 
cc19					endif 
cc19			 
cc19					; disable se storage bank selection 
cc19			 
cc19					ld a, SPI_CE_HIGH		; ce high 
cc19					ld (spi_device), a 
cc19			 
cc19					; get bank 
cc19			 
cc19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc19			 
cc19			;		push hl 
cc19			 
cc19					; destroy value TOS 
cc19			 
cc19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc19			 
cc19					; one value on hl get other one back 
cc19			 
cc19			;		pop hl 
cc19			 
cc19					; active low 
cc19			 
cc19					ld c, 255 
cc19			 
cc19					ld a, l 
cc19					if DEBUG_FORTH_WORDS 
cc19						DMARK "CDV" 
cc19						CALLMONITOR 
cc19					endif 
cc19					cp 0 
cc19					jr z, .cset 
cc19					cp 1 
cc19					jr nz, .c2 
cc19					res 0, c 
cc19			.c2:		cp 2 
cc19					jr nz, .c3 
cc19					res 1, c 
cc19			.c3:		cp 3 
cc19					jr nz, .c4 
cc19					res 2, c 
cc19			.c4:		cp 4 
cc19					jr nz, .c5 
cc19					res 3, c 
cc19			.c5:		cp 5 
cc19					jr nz, .c6 
cc19					res 4, c 
cc19			.c6:		cp 6 
cc19					jr nz, .c7 
cc19					res 5, c 
cc19			.c7:		cp 7 
cc19					jr nz, .c8 
cc19					res 6, c 
cc19			.c8:		cp 8 
cc19					jr nz, .cset 
cc19					res 7, c 
cc19			.cset:		ld a, c 
cc19					ld (spi_cartdev),a 
cc19			 
cc19					if DEBUG_FORTH_WORDS 
cc19						DMARK "CD2" 
cc19						CALLMONITOR 
cc19					endif 
cc19			 
cc19					; set default SPI clk pulse time as 10ms for CARTDEV use 
cc19			 
cc19					ld a, $0a 
cc19					ld (spi_clktime), a 
cc19					NEXTW 
cc19			endif 
cc19			 
cc19			.ENDDEVICE: 
cc19			; eof 
cc19			 
# End of file forth_words_device.asm
cc19			 
cc19			; var handler 
cc19			 
cc19			 
cc19			.VARS: 
cc19				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
cc19 77				db WORD_SYS_CORE+99             
cc1a ca cc			dw .V0            
cc1c 04				db 3 + 1 
cc1d .. 00			db "VAR",0              
cc21				endm 
# End of macro CWHEAD
cc21			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
cc21			;| 
cc21			;| The variable name should consist of a single letter. e.g. "a" 
cc21			;! If a full string is passed then only the first char is looked at 
cc21			;| Any other char could exceed bounds checks!  
cc21			 
cc21					if DEBUG_FORTH_WORDS_KEY 
cc21						DMARK "VAR" 
cc21 f5				push af  
cc22 3a 36 cc			ld a, (.dmark)  
cc25 32 65 ee			ld (debug_mark),a  
cc28 3a 37 cc			ld a, (.dmark+1)  
cc2b 32 66 ee			ld (debug_mark+1),a  
cc2e 3a 38 cc			ld a, (.dmark+2)  
cc31 32 67 ee			ld (debug_mark+2),a  
cc34 18 03			jr .pastdmark  
cc36 ..			.dmark: db "VAR"  
cc39 f1			.pastdmark: pop af  
cc3a			endm  
# End of macro DMARK
cc3a						CALLMONITOR 
cc3a cd 6f ee			call debug_vector  
cc3d				endm  
# End of macro CALLMONITOR
cc3d					endif 
cc3d			 
cc3d					FORTH_DSP_VALUEHL 
cc3d cd 8a 9c			call macro_dsp_valuehl 
cc40				endm 
# End of macro FORTH_DSP_VALUEHL
cc40			 
cc40 7e					ld a, (hl)    ; get first char on of the string 
cc41			 
cc41			 
cc41					if DEBUG_FORTH_WORDS 
cc41						DMARK "VR1" 
cc41 f5				push af  
cc42 3a 56 cc			ld a, (.dmark)  
cc45 32 65 ee			ld (debug_mark),a  
cc48 3a 57 cc			ld a, (.dmark+1)  
cc4b 32 66 ee			ld (debug_mark+1),a  
cc4e 3a 58 cc			ld a, (.dmark+2)  
cc51 32 67 ee			ld (debug_mark+2),a  
cc54 18 03			jr .pastdmark  
cc56 ..			.dmark: db "VR1"  
cc59 f1			.pastdmark: pop af  
cc5a			endm  
# End of macro DMARK
cc5a						CALLMONITOR 
cc5a cd 6f ee			call debug_vector  
cc5d				endm  
# End of macro CALLMONITOR
cc5d					endif 
cc5d					 
cc5d f5					push af	 
cc5e					FORTH_DSP_POP 
cc5e cd 42 9d			call macro_forth_dsp_pop 
cc61				endm 
# End of macro FORTH_DSP_POP
cc61 f1					pop af 
cc62			 
cc62					; convert to upper 
cc62			 
cc62 cd 5f 8f				call to_upper 
cc65					if DEBUG_FORTH_WORDS 
cc65						DMARK "Vaa" 
cc65 f5				push af  
cc66 3a 7a cc			ld a, (.dmark)  
cc69 32 65 ee			ld (debug_mark),a  
cc6c 3a 7b cc			ld a, (.dmark+1)  
cc6f 32 66 ee			ld (debug_mark+1),a  
cc72 3a 7c cc			ld a, (.dmark+2)  
cc75 32 67 ee			ld (debug_mark+2),a  
cc78 18 03			jr .pastdmark  
cc7a ..			.dmark: db "Vaa"  
cc7d f1			.pastdmark: pop af  
cc7e			endm  
# End of macro DMARK
cc7e						CALLMONITOR 
cc7e cd 6f ee			call debug_vector  
cc81				endm  
# End of macro CALLMONITOR
cc81					endif 
cc81 06 41				ld b, 'A' 
cc83 90					sub b			; set offset 
cc84					if DEBUG_FORTH_WORDS 
cc84						DMARK "Vbb" 
cc84 f5				push af  
cc85 3a 99 cc			ld a, (.dmark)  
cc88 32 65 ee			ld (debug_mark),a  
cc8b 3a 9a cc			ld a, (.dmark+1)  
cc8e 32 66 ee			ld (debug_mark+1),a  
cc91 3a 9b cc			ld a, (.dmark+2)  
cc94 32 67 ee			ld (debug_mark+2),a  
cc97 18 03			jr .pastdmark  
cc99 ..			.dmark: db "Vbb"  
cc9c f1			.pastdmark: pop af  
cc9d			endm  
# End of macro DMARK
cc9d						CALLMONITOR 
cc9d cd 6f ee			call debug_vector  
cca0				endm  
# End of macro CALLMONITOR
cca0					endif 
cca0 cb 27				sla a  
cca2				 
cca2					 
cca2					if DEBUG_FORTH_WORDS 
cca2						DMARK "VR2" 
cca2 f5				push af  
cca3 3a b7 cc			ld a, (.dmark)  
cca6 32 65 ee			ld (debug_mark),a  
cca9 3a b8 cc			ld a, (.dmark+1)  
ccac 32 66 ee			ld (debug_mark+1),a  
ccaf 3a b9 cc			ld a, (.dmark+2)  
ccb2 32 67 ee			ld (debug_mark+2),a  
ccb5 18 03			jr .pastdmark  
ccb7 ..			.dmark: db "VR2"  
ccba f1			.pastdmark: pop af  
ccbb			endm  
# End of macro DMARK
ccbb						CALLMONITOR 
ccbb cd 6f ee			call debug_vector  
ccbe				endm  
# End of macro CALLMONITOR
ccbe					endif 
ccbe			 
ccbe 21 ee e9				ld hl, cli_var_array2 
ccc1 cd ea 8c				call addatohl 
ccc4 cd 85 9a				call forth_push_numhl 
ccc7			 
ccc7			 
ccc7				       NEXTW 
ccc7 c3 76 9e			jp macro_next 
ccca				endm 
# End of macro NEXTW
ccca			.V0: 
ccca				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ccca 78				db WORD_SYS_CORE+100             
cccb e2 cc			dw .V0Q            
cccd 04				db 3 + 1 
ccce .. 00			db "V0!",0              
ccd2				endm 
# End of macro CWHEAD
ccd2			;| V0! ( u1 -- )  Store value to v0  | DONE 
ccd2			 
ccd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ccd2 cd 8a 9c			call macro_dsp_valuehl 
ccd5				endm 
# End of macro FORTH_DSP_VALUEHL
ccd5			 
ccd5 11 22 ea				ld de, cli_var_array 
ccd8			 
ccd8 eb					ex de, hl 
ccd9 73					ld (hl), e 
ccda 23					inc hl 
ccdb 72					ld (hl), d 
ccdc			 
ccdc					; destroy value TOS 
ccdc			 
ccdc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ccdc cd 42 9d			call macro_forth_dsp_pop 
ccdf				endm 
# End of macro FORTH_DSP_POP
ccdf			 
ccdf				       NEXTW 
ccdf c3 76 9e			jp macro_next 
cce2				endm 
# End of macro NEXTW
cce2			.V0Q: 
cce2				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cce2 79				db WORD_SYS_CORE+101             
cce3 f3 cc			dw .V1S            
cce5 04				db 3 + 1 
cce6 .. 00			db "V0@",0              
ccea				endm 
# End of macro CWHEAD
ccea			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ccea 2a 22 ea				ld hl, (cli_var_array) 
cced cd 85 9a				call forth_push_numhl 
ccf0			 
ccf0				       NEXTW 
ccf0 c3 76 9e			jp macro_next 
ccf3				endm 
# End of macro NEXTW
ccf3			.V1S: 
ccf3				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
ccf3 7a				db WORD_SYS_CORE+102             
ccf4 0b cd			dw .V1Q            
ccf6 04				db 3 + 1 
ccf7 .. 00			db "V1!",0              
ccfb				endm 
# End of macro CWHEAD
ccfb			;| V1! ( u1 -- )  Store value to v1 | DONE 
ccfb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ccfb cd 8a 9c			call macro_dsp_valuehl 
ccfe				endm 
# End of macro FORTH_DSP_VALUEHL
ccfe			 
ccfe 11 24 ea				ld de, cli_var_array+2 
cd01				 
cd01 eb					ex de, hl 
cd02 73					ld (hl), e 
cd03 23					inc hl 
cd04 72					ld (hl), d 
cd05			 
cd05					; destroy value TOS 
cd05			 
cd05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cd05 cd 42 9d			call macro_forth_dsp_pop 
cd08				endm 
# End of macro FORTH_DSP_POP
cd08				       NEXTW 
cd08 c3 76 9e			jp macro_next 
cd0b				endm 
# End of macro NEXTW
cd0b			.V1Q: 
cd0b				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cd0b 7b				db WORD_SYS_CORE+103             
cd0c 1c cd			dw .V2S            
cd0e 04				db 3 + 1 
cd0f .. 00			db "V1@",0              
cd13				endm 
# End of macro CWHEAD
cd13			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cd13 2a 24 ea				ld hl, (cli_var_array+2) 
cd16 cd 85 9a				call forth_push_numhl 
cd19				       NEXTW 
cd19 c3 76 9e			jp macro_next 
cd1c				endm 
# End of macro NEXTW
cd1c			.V2S: 
cd1c				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cd1c 7c				db WORD_SYS_CORE+104             
cd1d 34 cd			dw .V2Q            
cd1f 04				db 3 + 1 
cd20 .. 00			db "V2!",0              
cd24				endm 
# End of macro CWHEAD
cd24			;| V2! ( u1 -- )  Store value to v2 | DONE 
cd24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cd24 cd 8a 9c			call macro_dsp_valuehl 
cd27				endm 
# End of macro FORTH_DSP_VALUEHL
cd27			 
cd27 11 26 ea				ld de, cli_var_array+4 
cd2a				 
cd2a eb					ex de, hl 
cd2b 73					ld (hl), e 
cd2c 23					inc hl 
cd2d 72					ld (hl), d 
cd2e			 
cd2e					; destroy value TOS 
cd2e			 
cd2e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cd2e cd 42 9d			call macro_forth_dsp_pop 
cd31				endm 
# End of macro FORTH_DSP_POP
cd31				       NEXTW 
cd31 c3 76 9e			jp macro_next 
cd34				endm 
# End of macro NEXTW
cd34			.V2Q: 
cd34				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cd34 7d				db WORD_SYS_CORE+105             
cd35 45 cd			dw .V3S            
cd37 04				db 3 + 1 
cd38 .. 00			db "V2@",0              
cd3c				endm 
# End of macro CWHEAD
cd3c			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cd3c 2a 26 ea				ld hl, (cli_var_array+4) 
cd3f cd 85 9a				call forth_push_numhl 
cd42				       NEXTW 
cd42 c3 76 9e			jp macro_next 
cd45				endm 
# End of macro NEXTW
cd45			.V3S: 
cd45				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cd45 7c				db WORD_SYS_CORE+104             
cd46 5d cd			dw .V3Q            
cd48 04				db 3 + 1 
cd49 .. 00			db "V3!",0              
cd4d				endm 
# End of macro CWHEAD
cd4d			;| V3! ( u1 -- )  Store value to v3 | DONE 
cd4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cd4d cd 8a 9c			call macro_dsp_valuehl 
cd50				endm 
# End of macro FORTH_DSP_VALUEHL
cd50			 
cd50 11 28 ea				ld de, cli_var_array+6 
cd53				 
cd53 eb					ex de, hl 
cd54 73					ld (hl), e 
cd55 23					inc hl 
cd56 72					ld (hl), d 
cd57			 
cd57					; destroy value TOS 
cd57			 
cd57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cd57 cd 42 9d			call macro_forth_dsp_pop 
cd5a				endm 
# End of macro FORTH_DSP_POP
cd5a				       NEXTW 
cd5a c3 76 9e			jp macro_next 
cd5d				endm 
# End of macro NEXTW
cd5d			.V3Q: 
cd5d				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cd5d 7d				db WORD_SYS_CORE+105             
cd5e 6e cd			dw .END            
cd60 04				db 3 + 1 
cd61 .. 00			db "V3@",0              
cd65				endm 
# End of macro CWHEAD
cd65			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cd65 2a 28 ea				ld hl, (cli_var_array+6) 
cd68 cd 85 9a				call forth_push_numhl 
cd6b				       NEXTW 
cd6b c3 76 9e			jp macro_next 
cd6e				endm 
# End of macro NEXTW
cd6e			 
cd6e			 
cd6e			 
cd6e			 
cd6e			 
cd6e			; end of dict marker 
cd6e			 
cd6e 00			.END:    db WORD_SYS_END 
cd6f 00 00			dw 0 
cd71 00				db 0 
cd72			 
cd72			; use to jp here for user dict words to save on macro expansion  
cd72			 
cd72			user_dict_next: 
cd72				NEXTW 
cd72 c3 76 9e			jp macro_next 
cd75				endm 
# End of macro NEXTW
cd75			 
cd75			 
cd75			user_exec: 
cd75				;    ld hl, <word code> 
cd75				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cd75				;    call forthexec 
cd75				;    jp user_dict_next   (NEXT) 
cd75			        ;    <word code bytes> 
cd75 eb				ex de, hl 
cd76 2a bc e5			ld hl,(os_tok_ptr) 
cd79				 
cd79				FORTH_RSP_NEXT 
cd79 cd 2c 9a			call macro_forth_rsp_next 
cd7c				endm 
# End of macro FORTH_RSP_NEXT
cd7c			 
cd7c			if DEBUG_FORTH_UWORD 
cd7c						DMARK "UEX" 
cd7c f5				push af  
cd7d 3a 91 cd			ld a, (.dmark)  
cd80 32 65 ee			ld (debug_mark),a  
cd83 3a 92 cd			ld a, (.dmark+1)  
cd86 32 66 ee			ld (debug_mark+1),a  
cd89 3a 93 cd			ld a, (.dmark+2)  
cd8c 32 67 ee			ld (debug_mark+2),a  
cd8f 18 03			jr .pastdmark  
cd91 ..			.dmark: db "UEX"  
cd94 f1			.pastdmark: pop af  
cd95			endm  
# End of macro DMARK
cd95				CALLMONITOR 
cd95 cd 6f ee			call debug_vector  
cd98				endm  
# End of macro CALLMONITOR
cd98			endif 
cd98			 
cd98			 
cd98			 
cd98 eb				ex de, hl 
cd99 22 bc e5			ld (os_tok_ptr), hl 
cd9c				 
cd9c				; Don't use next - Skips the first word in uword. 
cd9c			 
cd9c c3 ff 9e			jp exec1 
cd9f			;	NEXT 
cd9f			 
cd9f			 
cd9f			; eof 
# End of file forth_wordsv4.asm
cd9f			endif 
cd9f			;;;;;;;;;;;;;; Debug code 
cd9f			 
cd9f			 
cd9f			;if DEBUG_FORTH_PARSE 
cd9f .. 00		.nowordfound: db "No match",0 
cda8 .. 00		.compword:	db "Comparing word ",0 
cdb8 .. 00		.nextwordat:	db "Next word at",0 
cdc5 .. 00		.charmatch:	db "Char match",0 
cdd0			;endif 
cdd0			if DEBUG_FORTH_JP 
cdd0			.foundword:	db "Word match. Exec..",0 
cdd0			endif 
cdd0			;if DEBUG_FORTH_PUSH 
cdd0 .. 00		.enddict:	db "Dict end. Push.",0 
cde0 .. 00		.push_str:	db "Pushing string",0 
cdef .. 00		.push_num:	db "Pushing number",0 
cdfe .. 00		.data_sp:	db "SP:",0 
ce02 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
ce14 .. 00		.wordinde:	db "Word in DE (3/0):",0 
ce26 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
ce38			;endif 
ce38			;if DEBUG_FORTH_MALLOC 
ce38 .. 00		.push_malloc:	db "Malloc address",0 
ce47			;endif 
ce47			 
ce47			 
ce47			 
ce47			; display malloc address and current data stack pointer  
ce47			 
ce47			malloc_error: 
ce47 d5				push de 
ce48 f5				push af 
ce49 e5				push hl 
ce4a cd bd 8a			call clear_display 
ce4d 11 6d ce			ld de, .mallocerr 
ce50 3e 00			ld a,0 
ce52			;	ld de,os_word_scratch 
ce52 cd d0 8a			call str_at_display 
ce55 3e 11			ld a, display_row_1+17 
ce57 11 65 ee			ld de, debug_mark 
ce5a cd d0 8a			call str_at_display 
ce5d cd e0 8a			call update_display 
ce60				;call break_point_state 
ce60 cd 82 df			call cin_wait 
ce63			 
ce63			;	ld a, ' ' 
ce63			;	ld (os_view_disable), a 
ce63 cd f4 93			call bp_on 
ce66 e1				pop hl 
ce67 f1				pop af 
ce68 d1				pop de	 
ce69				CALLMONITOR 
ce69 cd 6f ee			call debug_vector  
ce6c				endm  
# End of macro CALLMONITOR
ce6c c9				ret 
ce6d			 
ce6d .. 00		.mallocerr: 	db "Malloc Error",0 
ce7a			;if DEBUG_FORTH_PUSH 
ce7a			display_data_sp: 
ce7a f5				push af 
ce7b			 
ce7b				; see if disabled 
ce7b			 
ce7b			 
ce7b 3a 6f ee			ld a, (debug_vector) 
ce7e fe c9			cp $C9  ; RET 
ce80				;ld a, (os_view_disable) 
ce80				;cp '*' 
ce80 28 67			jr z, .skipdsp 
ce82			 
ce82 e5				push hl 
ce83 e5				push hl 
ce84 e5			push hl 
ce85 cd bd 8a			call clear_display 
ce88 e1			pop hl 
ce89 7c				ld a,h 
ce8a 21 c0 e5			ld hl, os_word_scratch 
ce8d cd f3 8e			call hexout 
ce90 e1				pop hl 
ce91 7d				ld a,l 
ce92 21 c2 e5			ld hl, os_word_scratch+2 
ce95 cd f3 8e			call hexout 
ce98 21 c4 e5			ld hl, os_word_scratch+4 
ce9b 3e 00			ld a,0 
ce9d 77				ld (hl),a 
ce9e 11 c0 e5			ld de,os_word_scratch 
cea1 3e 28				ld a, display_row_2 
cea3 cd d0 8a				call str_at_display 
cea6 11 02 ce			ld de, .wordinhl 
cea9 3e 00			ld a, display_row_1 
ceab			 
ceab cd d0 8a				call str_at_display 
ceae 11 65 ee			ld de, debug_mark 
ceb1 3e 11			ld a, display_row_1+17 
ceb3			 
ceb3 cd d0 8a				call str_at_display 
ceb6			 
ceb6				; display current data stack pointer 
ceb6 11 fe cd			ld de,.data_sp 
ceb9 3e 30				ld a, display_row_2 + 8 
cebb cd d0 8a				call str_at_display 
cebe			 
cebe 2a e8 e9			ld hl,(cli_data_sp) 
cec1 e5				push hl 
cec2 7c				ld a,h 
cec3 21 c0 e5			ld hl, os_word_scratch 
cec6 cd f3 8e			call hexout 
cec9 e1				pop hl 
ceca 7d				ld a,l 
cecb 21 c2 e5			ld hl, os_word_scratch+2 
cece cd f3 8e			call hexout 
ced1 21 c4 e5			ld hl, os_word_scratch+4 
ced4 3e 00			ld a,0 
ced6 77				ld (hl),a 
ced7 11 c0 e5			ld de,os_word_scratch 
ceda 3e 33				ld a, display_row_2 + 11 
cedc cd d0 8a				call str_at_display 
cedf			 
cedf			 
cedf cd e0 8a			call update_display 
cee2 cd 00 8a			call delay1s 
cee5 cd 00 8a			call delay1s 
cee8 e1				pop hl 
cee9			.skipdsp: 
cee9 f1				pop af 
ceea c9				ret 
ceeb			 
ceeb			display_data_malloc: 
ceeb			 
ceeb f5				push af 
ceec e5				push hl 
ceed e5				push hl 
ceee e5			push hl 
ceef cd bd 8a			call clear_display 
cef2 e1			pop hl 
cef3 7c				ld a,h 
cef4 21 c0 e5			ld hl, os_word_scratch 
cef7 cd f3 8e			call hexout 
cefa e1				pop hl 
cefb 7d				ld a,l 
cefc 21 c2 e5			ld hl, os_word_scratch+2 
ceff cd f3 8e			call hexout 
cf02 21 c4 e5			ld hl, os_word_scratch+4 
cf05 3e 00			ld a,0 
cf07 77				ld (hl),a 
cf08 11 c0 e5			ld de,os_word_scratch 
cf0b 3e 28				ld a, display_row_2 
cf0d cd d0 8a				call str_at_display 
cf10 11 38 ce			ld de, .push_malloc 
cf13 3e 00			ld a, display_row_1 
cf15			 
cf15 cd d0 8a				call str_at_display 
cf18			 
cf18				; display current data stack pointer 
cf18 11 fe cd			ld de,.data_sp 
cf1b 3e 30				ld a, display_row_2 + 8 
cf1d cd d0 8a				call str_at_display 
cf20			 
cf20 2a e8 e9			ld hl,(cli_data_sp) 
cf23 e5				push hl 
cf24 7c				ld a,h 
cf25 21 c0 e5			ld hl, os_word_scratch 
cf28 cd f3 8e			call hexout 
cf2b e1				pop hl 
cf2c 7d				ld a,l 
cf2d 21 c2 e5			ld hl, os_word_scratch+2 
cf30 cd f3 8e			call hexout 
cf33 21 c4 e5			ld hl, os_word_scratch+4 
cf36 3e 00			ld a,0 
cf38 77				ld (hl),a 
cf39 11 c0 e5			ld de,os_word_scratch 
cf3c 3e 33				ld a, display_row_2 + 11 
cf3e cd d0 8a				call str_at_display 
cf41			 
cf41 cd e0 8a			call update_display 
cf44 cd 00 8a			call delay1s 
cf47 cd 00 8a			call delay1s 
cf4a e1				pop hl 
cf4b f1				pop af 
cf4c c9				ret 
cf4d			;endif 
cf4d			 
cf4d			include "forth_autostart.asm" 
cf4d			; list of commands to perform at system start up 
cf4d			 
cf4d			startcmds: 
cf4d			;	dw test11 
cf4d			;	dw test12 
cf4d			;	dw test13 
cf4d			;	dw test14 
cf4d			;	dw test15 
cf4d			;	dw test16 
cf4d			;	dw test17 
cf4d			;	dw ifthtest1 
cf4d			;	dw ifthtest2 
cf4d			;	dw ifthtest3 
cf4d			;	dw mmtest1 
cf4d			;	dw mmtest2 
cf4d			;	dw mmtest3 
cf4d			;	dw mmtest4 
cf4d			;	dw mmtest5 
cf4d			;	dw mmtest6 
cf4d			;	dw iftest1 
cf4d			;	dw iftest2 
cf4d			;	dw iftest3 
cf4d			;	dw looptest1 
cf4d			;	dw looptest2 
cf4d			;	dw test1 
cf4d			;	dw test2 
cf4d			;	dw test3 
cf4d			;	dw test4 
cf4d			;	dw game2r 
cf4d			;	dw game2b1 
cf4d			;	dw game2b2 
cf4d			 
cf4d				; start up words that are actually useful 
cf4d			 
cf4d			;    dw spi1 
cf4d			;    dw spi2 
cf4d			;    dw spi3 
cf4d			;    dw spi4 
cf4d			;    dw spi5 
cf4d			;    dw spi6 
cf4d			;    dw spi7 
cf4d			; 
cf4d			;    dw spi8 
cf4d			;    dw spi9 
cf4d			;    dw spi10 
cf4d			 
cf4d			; file editor 
cf4d			;	dw edit1 
cf4d			;	dw edit2 
cf4d			;	dw edit3 
cf4d			 
cf4d			;	dw longread 
cf4d 6d d3			dw clrstack 
cf4f a1 d3			dw type 
cf51			;	dw stest 
cf51 c6 d3			dw strncpy 
cf53			;	dw list 
cf53 27 d4			dw start1 
cf55 37 d4			dw start2 
cf57			;	dw start3 
cf57			;	dw start3b 
cf57			;	dw start3c 
cf57			 
cf57				; (unit) testing words 
cf57			 
cf57			;	dw mtesta 
cf57			;	dw mtestb 
cf57			;	dw mtestc 
cf57			;	dw mtestd 
cf57			;	dw mteste 
cf57			 
cf57				; demo/game words 
cf57			 
cf57			;        dw game3w 
cf57			;        dw game3p 
cf57			;        dw game3sc 
cf57			;        dw game3vsi 
cf57			;        dw game3vs 
cf57				 
cf57			;	dw game2b 
cf57			;	dw game2bf 
cf57			;	dw game2mba 
cf57			;	dw game2mbas 
cf57			;	dw game2mb 
cf57			 
cf57 67 d7			dw game1 
cf59 78 d7			dw game1a 
cf5b da d7			dw game1b 
cf5d 0f d8			dw game1c 
cf5f 45 d8			dw game1d 
cf61 76 d8			dw game1s 
cf63 8a d8			dw game1t 
cf65 9f d8			dw game1f 
cf67 d3 d8			dw game1z 
cf69 17 d9			dw game1zz 
cf6b			 
cf6b a0 d5			dw test5 
cf6d d8 d5			dw test6 
cf6f 10 d6			dw test7 
cf71 24 d6			dw test8 
cf73 50 d6			dw test9 
cf75 66 d6			dw test10 
cf77				 
cf77 ee d9		        dw ssv5 
cf79 d2 d9		        dw ssv4 
cf7b b6 d9		        dw ssv3 
cf7d 80 d9		        dw ssv2 
cf7f 07 da		        dw ssv1 
cf81 4f da		        dw ssv1cpm 
cf83			;	dw keyup 
cf83			;	dw keydown 
cf83			;	dw keyleft 
cf83			;	dw keyright 
cf83			;	dw 	keyf1 
cf83			;	dw keyf2 
cf83			;	dw keyf3 
cf83			;	dw keyf4 
cf83			;	dw keyf5 
cf83			;	dw keyf6 
cf83			;	dw keyf7 
cf83			;	dw keyf8 
cf83			;	dw keyf9 
cf83			;	dw keyf10 
cf83			;	dw keyf11 
cf83			;	dw keyf12 
cf83			;	dw keytab 
cf83			;	dw keycr 
cf83			;	dw keyhome 
cf83			;	dw keyend 
cf83			;	dw keybs 
cf83 00 00			db 0, 0	 
cf85			 
cf85			 
cf85			; File Editor 
cf85			 
cf85			; ( id - ) use 'e' to edit the displayed line 
cf85 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cfa6 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cfdb			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cfdb .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
d013			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
d013			 
d013			; SPI Net support words 
d013			 
d013			; v0! = node to send to 
d013			; ( str count - ) 
d013 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d06c			 
d06c			; spiputc ( char node - ) 
d06c .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d0a0			; spiputc ( u node - ) 
d0a0 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d0ce			 
d0ce			; spigetc ( - n ) 
d0ce .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d0f7			 
d0f7			; getnode ( - n ) 
d0f7 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d124			 
d124			; ( str node - )  
d124 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d18a			; store string ( str i - ) 
d18a			 
d18a			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d18a .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d1df			 
d1df			; get string ( addr i -  )    TO FIX 
d1df			 
d1df .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d237			 
d237			 
d237			; NETCHAT (TODO) 
d237			; Program to allow two nodes to chat with eachother 
d237			; 
d237			; v0 - target node 
d237			;  
d237			; accept input at 0,0 
d237			; if input is string send spitype to target node 
d237			; starting at row 2,0 , while spigetchr is not zero ->  
d237			; 
d237			; 
d237			; TODO add paging of get request 
d237			 
d237			; ( node - ) 
d237 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d256 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d2ae .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d326			 
d326			 
d326			; Long read of currently open file 
d326 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d36d			 
d36d			; clear stack  
d36d			 
d36d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d3a1			 
d3a1			; type ( addr count - ) 
d3a1 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d3c6			 
d3c6			; some direct memory words 
d3c6			; strncpy ( len t f -- t ) 
d3c6			 
d3c6 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d427			 
d427 .. 00		start1:     	db ": bpon $00 bp ;",0 
d437 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d448 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d4c3 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d523			 
d523 .. 00		tuck:         db ": tuck swap over ;", 0 
d536			 
d536			; a handy word to list items on the stack 
d536			 
d536 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d5a0			 
d5a0			 
d5a0			; test stack  
d5a0			; rnd8 stest 
d5a0			 
d5a0			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d5a0			 
d5a0			; random malloc and free cycles 
d5a0			 
d5a0			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d5a0			 
d5a0			; fixed malloc and free cycles 
d5a0			 
d5a0			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d5a0			 
d5a0			; fixed double string push and drop cycle  
d5a0			 
d5a0			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d5a0			 
d5a0			; consistent fixed string push and drop cycle  
d5a0			 
d5a0			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d5a0			 
d5a0			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d5a0			 
d5a0			;test1:		db ": aa 1 2 3 ;", 0 
d5a0			;test2:     	db "111 aa 888 999",0 
d5a0			;test3:     	db ": bb 77 ;",0 
d5a0			;test4:     	db "$02 $01 do i . loop bb",0 
d5a0			 
d5a0 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d5d8 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d610 .. 00		test7:     	db ": box hline vline ;",0 
d624 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d650 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d666 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d68b			;test11:     	db "hello create .",0 
d68b			;test12:     	db "hello2 create .",0 
d68b			 
d68b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d68b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d68b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d68b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d68b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d68b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d68b			 
d68b			;iftest1:     	db "$0001 IF cls .",0 
d68b			;iftest2:     	db "$0000 IF cls .",0 
d68b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d68b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d68b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d68b			 
d68b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d68b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d68b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d68b			 
d68b			 
d68b .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d6af .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d6df .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d704 .. 00		sound4: db ": cha $00 ; ",0 
d711 .. 00		sound5: db ": chb $20 ; ",0 
d71e .. 00		sound6: db ": chc $40 ; ",0 
d72b .. 00		sound7: db ": chd $60 ; ",0 
d738 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d750 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d767			 
d767			 
d767			 
d767			 
d767			; a small guess the number game 
d767			 
d767 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d778 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d7da			 
d7da .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d80f .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d845 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d876 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d88a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d89f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d8d3 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d917			 
d917			; Using 'ga' save a high score across multiple runs using external storage 
d917			 
d917 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d980			 
d980			 
d980			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d980			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d980			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d980			 
d980			; simple screen saver to test code memory reuse to destruction 
d980			 
d980 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d9b6 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d9d2 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d9ee .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
da07 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
da4f .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
daa6			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
daa6			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
daa6			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
daa6			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
daa6			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
daa6			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
daa6			 
daa6			 
daa6			 
daa6			; minesweeper/battleship finding game 
daa6			; draws a game board of random ship/mine positions 
daa6			; user enters coords to see if it hits on 
daa6			; game ends when all are hit 
daa6			; when hit or miss says how many may be in the area 
daa6			 
daa6			; setup the game board and then hide it 
daa6			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
daa6			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
daa6			;; prompt for where to target 
daa6			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
daa6			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
daa6			;; TODO see if the entered coords hits or misses pushes char hit of miss 
daa6			;game2mbht:      db ": mbckht nop ;",0 
daa6			;game2mbms:      db ": mbcms nop ;",0 
daa6			; TODO how many might be near by 
daa6			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
daa6			 
daa6			; Game 3 
daa6			 
daa6			; Vert scroller ski game - avoid the trees! 
daa6			 
daa6			; v0 score (ie turns) 
daa6			; v1 player pos 
daa6			; v2 left wall 
daa6			; v3 right wall 
daa6			 
daa6			; Draw side walls randomly 
daa6			 
daa6			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
daa6			 
daa6			; Draw player 
daa6			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
daa6			 
daa6			; TODO Get Key 
daa6			 
daa6			; TODO Move left right 
daa6			 
daa6			; scroll and move walls a bit 
daa6			 
daa6			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
daa6			 
daa6			; main game loop 
daa6			 
daa6			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
daa6			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
daa6			 
daa6			; key board defs 
daa6			 
daa6 .. 00		keyup:       db ": keyup $05 ;",0 
dab4 .. 00		keydown:       db ": keydown $0a ;",0 
dac4 .. 00		keyleft:       db ": keyleft $0b ;",0 
dad4 .. 00		keyright:       db ": keyright $0c ;",0 
dae5 .. 00		keyf1:       db ": keyf1 $10 ;",0 
daf3 .. 00		keyf2:       db ": keyf2 $11 ;",0 
db01 .. 00		keyf3:       db ": keyf3 $12 ;",0 
db0f .. 00		keyf4:       db ": keyf4 $13 ;",0 
db1d .. 00		keyf5:       db ": keyf5 $14 ;",0 
db2b .. 00		keyf6:       db ": keyf6 $15 ;",0 
db39 .. 00		keyf7:       db ": keyf7 $16 ;",0 
db47 .. 00		keyf8:       db ": keyf8 $17 ;",0 
db55 .. 00		keyf9:       db ": keyf9 $18 ;",0 
db63 .. 00		keyf10:       db ": keyf10 $19 ;",0 
db72 .. 00		keyf11:       db ": keyf11 $1a ;",0 
db81 .. 00		keyf12:       db ": keyf12 $1b ;",0 
db90			 
db90 .. 00		keytab:       db ": keytab $09 ;",0 
db9f .. 00		keycr:       db ": keycr $0d ;",0 
dbad .. 00		keyhome:       db ": keyhome $0e ;",0 
dbbd .. 00		keyend:       db ": keyend $0f ;",0 
dbcc .. 00		keybs:       db ": keybs $08 ;",0 
dbda			 
dbda			   
dbda			 
dbda			 
dbda			 
dbda			; eof 
# End of file forth_autostart.asm
dbda			 
dbda			 
dbda			 
dbda			; stack over and underflow checks 
dbda			 
dbda			; init the words to detect the under/overflow 
dbda			 
dbda			chk_stk_init: 
dbda				; a vague random number to check so we dont get any "lucky" hits 
dbda 3e 2d			ld a, 45 
dbdc 6f				ld l, a 
dbdd 00				nop 
dbde 3e 17			ld a, 23 
dbe0 67				ld h, a 
dbe1			 
dbe1 22 97 e2			ld (chk_word), hl     ; the word we need to check against 
dbe4			 
dbe4			;	ld (chk_stund), hl	; stack points.... 
dbe4 22 00 ef			ld (chk_stovr), hl 
dbe7 22 e6 e9			ld (chk_ret_und), hl 
dbea 22 a4 e9			ld (chk_ret_ovr), hl 
dbed 22 22 e9			ld (chk_loop_ovr), hl 
dbf0 22 20 e8			ld (chk_data_ovr), hl 
dbf3 c9				ret 
dbf4				 
dbf4			check_stacks: 
dbf4				; check all stack words 
dbf4			 
dbf4 e5				push hl 
dbf5 d5				push de 
dbf6			 
dbf6			;	ld de,(chk_word) 
dbf6			;	ld hl, (chk_stund)	; stack points.... 
dbf6			;	if DEBUG_STK_FAULT 
dbf6			;		DMARK "FAa" 
dbf6			;		CALLMONITOR 
dbf6			;	endif 
dbf6			;	call cmp16 
dbf6			;	jp z, .chk_faulta 
dbf6			; 
dbf6			;	ld de, sfaultsu 
dbf6			;	jp .chk_fault 
dbf6			 
dbf6 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
dbf9 ed 5b 97 e2		ld de,(chk_word) 
dbfd				if DEBUG_STK_FAULT 
dbfd					DMARK "FAb" 
dbfd					CALLMONITOR 
dbfd				endif 
dbfd cd 08 8d			call cmp16 
dc00 28 06			jr z, .chk_fault1 
dc02 11 a6 dc			ld de, sfaultso 
dc05 c3 57 dc			jp .chk_fault 
dc08			.chk_fault1:  
dc08 2a e6 e9			ld hl, (chk_ret_und) 
dc0b ed 5b 97 e2		ld de,(chk_word) 
dc0f				if DEBUG_STK_FAULT 
dc0f					DMARK "FAU" 
dc0f					CALLMONITOR 
dc0f				endif 
dc0f cd 08 8d			call cmp16 
dc12 ca 1b dc			jp z, .chk_fault2 
dc15 11 b6 dc			ld de, sfaultru 
dc18 c3 57 dc			jp .chk_fault 
dc1b			.chk_fault2:  
dc1b 2a a4 e9			ld hl, (chk_ret_ovr) 
dc1e ed 5b 97 e2		ld de,(chk_word) 
dc22				if DEBUG_STK_FAULT 
dc22					DMARK "FA1" 
dc22					CALLMONITOR 
dc22				endif 
dc22 cd 08 8d			call cmp16 
dc25 ca 2e dc			jp z, .chk_fault3 
dc28 11 c4 dc			ld de, sfaultro 
dc2b c3 57 dc			jp .chk_fault 
dc2e			.chk_fault3:  
dc2e 2a 22 e9			ld hl, (chk_loop_ovr) 
dc31 ed 5b 97 e2		ld de,(chk_word) 
dc35				if DEBUG_STK_FAULT 
dc35					DMARK "FA2" 
dc35					CALLMONITOR 
dc35				endif 
dc35 cd 08 8d			call cmp16 
dc38 ca 41 dc			jp z, .chk_fault4 
dc3b 11 de dc			ld de, sfaultlo 
dc3e c3 57 dc			jp .chk_fault 
dc41			.chk_fault4:  
dc41 2a 20 e8			ld hl, (chk_data_ovr) 
dc44 ed 5b 97 e2		ld de,(chk_word) 
dc48				if DEBUG_STK_FAULT 
dc48					DMARK "FA3" 
dc48					CALLMONITOR 
dc48				endif 
dc48 cd 08 8d			call cmp16 
dc4b ca 54 dc			jp z, .chk_fault5 
dc4e 11 f8 dc			ld de, sfaultdo 
dc51 c3 57 dc			jp .chk_fault 
dc54			 
dc54			 
dc54			.chk_fault5:  
dc54 d1				pop de 
dc55 e1				pop hl 
dc56			 
dc56 c9				ret 
dc57			 
dc57 cd bd 8a		.chk_fault: 	call clear_display 
dc5a 3e 28				ld a, display_row_2 
dc5c cd d0 8a				call str_at_display 
dc5f 11 88 dc				   ld de, .stackfault 
dc62 3e 00				ld a, display_row_1 
dc64 cd d0 8a				call str_at_display 
dc67 11 65 ee				    ld de, debug_mark 
dc6a 3e 11				ld a, display_row_1+17 
dc6c cd d0 8a				call str_at_display 
dc6f cd e0 8a				call update_display 
dc72			 
dc72				; prompt before entering montior for investigating issue 
dc72			 
dc72 3e 78			ld a, display_row_4 
dc74 11 63 97			ld de, endprog 
dc77			 
dc77 cd e0 8a			call update_display		 
dc7a			 
dc7a cd fd 99			call next_page_prompt 
dc7d			 
dc7d d1				pop de 
dc7e e1				pop hl 
dc7f cd b7 97				call monitor 
dc82 cd 1c 9e				call forth_warmstart 
dc85 c3 b3 96				jp warmstart_afterauto 
dc88					;jp 0 
dc88					;halt 
dc88			 
dc88			 
dc88			 
dc88 .. 00		.stackfault: 	db "Stack fault:",0 
dc95			 
dc95 .. 00		sfaultsu: 	db	"Stack under flow",0 
dca6 .. 00		sfaultso: 	db	"Stack over flow",0 
dcb6 .. 00		sfaultru:	db "RTS underflow",0 
dcc4 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
dcde .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
dcf8 .. 00		sfaultdo:	db "DTS overflow", 0 
dd05			 
dd05			 
dd05			fault_dsp_under: 
dd05 11 17 dd			ld de, .dsp_under 
dd08 c3 cd dd			jp .show_fault 
dd0b			 
dd0b			fault_rsp_under: 
dd0b 11 25 dd			ld de, .rsp_under 
dd0e c3 cd dd			jp .show_fault 
dd11			fault_loop_under: 
dd11 11 33 dd			ld de, .loop_under 
dd14 c3 cd dd			jp .show_fault 
dd17			 
dd17 .. 00		.dsp_under: db "DSP Underflow",0 
dd25 .. 00		.rsp_under: db "RSP Underflow",0 
dd33 .. 00		.loop_under: db "LOOP Underflow",0 
dd42			 
dd42			 
dd42 d5			type_faultn: 	push de 
dd43 e5					push hl 
dd44 cd bd 8a				call clear_display 
dd47 11 71 dd				   ld de, .typefaultn 
dd4a 3e 00				ld a, display_row_1 
dd4c cd d0 8a				call str_at_display 
dd4f 11 65 ee				    ld de, debug_mark 
dd52 3e 11				ld a, display_row_1+17 
dd54 cd d0 8a				call str_at_display 
dd57 cd e0 8a				call update_display 
dd5a			 
dd5a				; prompt before entering montior for investigating issue 
dd5a			 
dd5a 3e 78			ld a, display_row_4 
dd5c 11 63 97			ld de, endprog 
dd5f			 
dd5f cd e0 8a			call update_display		 
dd62			 
dd62 cd fd 99			call next_page_prompt 
dd65			 
dd65 e5					push hl 
dd66 d5					push de 
dd67 cd b7 97				call monitor 
dd6a cd 1c 9e				call forth_warmstart 
dd6d c3 b3 96				jp warmstart_afterauto 
dd70 76					halt 
dd71			 
dd71			 
dd71 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
dd88			 
dd88 d5			type_faults: 	push de 
dd89 e5					push hl 
dd8a cd bd 8a				call clear_display 
dd8d 11 b6 dd				   ld de, .typefaults 
dd90 3e 00				ld a, display_row_1 
dd92 cd d0 8a				call str_at_display 
dd95 11 65 ee				    ld de, debug_mark 
dd98 3e 11				ld a, display_row_1+17 
dd9a cd d0 8a				call str_at_display 
dd9d cd e0 8a				call update_display 
dda0			 
dda0				; prompt before entering montior for investigating issue 
dda0			 
dda0 3e 78			ld a, display_row_4 
dda2 11 63 97			ld de, endprog 
dda5			 
dda5 cd e0 8a			call update_display		 
dda8			 
dda8 cd fd 99			call next_page_prompt 
ddab			 
ddab e1					pop hl 
ddac d1					pop de 
ddad cd b7 97				call monitor 
ddb0 cd 1c 9e				call forth_warmstart 
ddb3 c3 b3 96				jp warmstart_afterauto 
ddb6			 
ddb6			 
ddb6 .. 00		.typefaults: db "STR Type Expected TOS!",0 
ddcd			 
ddcd			.show_fault: 	 
ddcd d5					push de 
ddce cd bd 8a				call clear_display 
ddd1 d1					pop de 
ddd2 3e 00				ld a, display_row_1 
ddd4 cd d0 8a				call str_at_display 
ddd7 11 65 ee				    ld de, debug_mark 
ddda 3e 11				ld a, display_row_1+17 
dddc cd d0 8a				call str_at_display 
dddf cd e0 8a				call update_display 
dde2			 
dde2				; prompt before entering montior for investigating issue 
dde2			 
dde2 3e 78			ld a, display_row_4 
dde4 11 63 97			ld de, endprog 
dde7			 
dde7 cd e0 8a			call update_display		 
ddea			 
ddea cd fd 99			call next_page_prompt 
dded			 
dded e1					pop hl 
ddee d1					pop de 
ddef cd b7 97				call monitor 
ddf2			; do a dump to cli and not warmstart so we preserve all of the uwords.  
ddf2			; TODO Make optional fault restart to cli or warm boot? 
ddf2					;jp warmstart 
ddf2 c3 f7 96				jp cli 
ddf5 76					halt 
ddf6			 
ddf6			 
ddf6			; handle the auto run of code from files in storage 
ddf6			 
ddf6			 
ddf6			include "forth_startup.asm" 
ddf6			; Which startup method to use? 
ddf6			; 
ddf6			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
ddf6			; followed by loading of a list of scripts in eeprom 
ddf6			 
ddf6			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
ddf6			; from eeprom 
ddf6			 
ddf6			; Select with define in main stubs 
ddf6			 
ddf6			if STARTUP_V1 
ddf6				include "forth_startupv1.asm" 
ddf6			; Startup script loading version 1 
ddf6			 
ddf6			; If SE storage is available first stage is to use the selected file 
ddf6			; then go through the eeprom list 
ddf6			 
ddf6 .. 00		sprompt1: db "Startup load...",0 
de06 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
de1c			 
de1c			 
de1c			 
de1c			 
de1c			forth_startup: 
de1c 21 4d cf			ld hl, startcmds 
de1f 3e 00			ld a, 0 
de21 32 e1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
de24			 
de24 e5			.start1:	push hl 
de25 cd bd 8a			call clear_display 
de28 11 f6 dd			ld de, sprompt1 
de2b 3e 00		        ld a, display_row_1 
de2d cd d0 8a			call str_at_display 
de30 11 06 de			ld de, sprompt2 
de33 3e 28		        ld a, display_row_2 
de35 cd d0 8a			call str_at_display 
de38 e1				pop hl 
de39 e5				push hl 
de3a 5e				ld e,(hl) 
de3b 23				inc hl 
de3c 56				ld d,(hl) 
de3d 3e 50		        ld a, display_row_3 
de3f cd d0 8a			call str_at_display 
de42 cd e0 8a			call update_display 
de45			 
de45			 
de45 3a e1 e6			ld a, (os_last_cmd) 
de48 fe 00			cp 0 
de4a 28 05			jr z, .startprompt 
de4c cd f4 89			call delay250ms 
de4f 18 24			jr .startdo 
de51				 
de51				 
de51			 
de51			.startprompt: 
de51			 
de51 3e 9f			ld a,display_row_4 + display_cols - 1 
de53 11 fb 99		        ld de, endprg 
de56 cd d0 8a			call str_at_display 
de59 cd e0 8a			call update_display 
de5c cd 00 8a			call delay1s 
de5f cd 82 df			call cin_wait 
de62						 
de62 fe 2a			cp '*' 
de64 28 5e			jr z, .startupend1 
de66 fe 23			cp '#' 
de68 20 07			jr nz, .startno 
de6a 3e 01			ld a, 1 
de6c 32 e1 e6			ld (os_last_cmd),a 
de6f 18 04			jr .startdo 
de71 fe 31		.startno:	cp '1' 
de73 28 3a			jr z,.startnxt  
de75			 
de75				; exec startup line 
de75			.startdo:	 
de75 e1				pop hl 
de76 e5				push hl 
de77				 
de77 5e				ld e,(hl) 
de78 23				inc hl 
de79 56				ld d,(hl) 
de7a eb				ex de,hl 
de7b			 
de7b e5				push hl 
de7c			 
de7c 3e 00			ld a, 0 
de7e				;ld a, FORTH_END_BUFFER 
de7e cd 5b 90			call strlent 
de81 23				inc hl   ; include zero term to copy 
de82 06 00			ld b,0 
de84 4d				ld c,l 
de85 e1				pop hl 
de86 11 bb e2			ld de, scratch 
de89 ed b0			ldir 
de8b			 
de8b			 
de8b 21 bb e2			ld hl, scratch 
de8e cd c0 9e			call forthparse 
de91 cd fc 9e			call forthexec 
de94 cd 16 9e			call forthexec_cleanup 
de97			 
de97 3e 78			ld a, display_row_4 
de99 11 63 97			ld de, endprog 
de9c			 
de9c cd e0 8a			call update_display		 
de9f			 
de9f 3a e1 e6			ld a, (os_last_cmd) 
dea2 fe 00			cp 0 
dea4 20 09			jr nz, .startnxt 
dea6 cd fd 99			call next_page_prompt 
dea9 cd bd 8a		        call clear_display 
deac cd e0 8a			call update_display		 
deaf			 
deaf				; move onto next startup line? 
deaf			.startnxt: 
deaf			 
deaf cd f4 89			call delay250ms 
deb2 e1				pop hl 
deb3			 
deb3 23				inc hl 
deb4 23				inc hl 
deb5			 
deb5 e5				push hl 
deb6 5e				ld e, (hl) 
deb7 23				inc hl 
deb8 56				ld d, (hl) 
deb9 e1				pop hl 
deba				; TODO replace 0 test 
deba			 
deba eb				ex de, hl 
debb cd 13 8d			call ishlzero 
debe			;	ld a,e 
debe			;	add d 
debe			;	cp 0    ; any left to do? 
debe eb				ex de, hl 
debf c2 24 de			jp nz, .start1 
dec2 18 01			jr .startupend 
dec4			 
dec4 e1			.startupend1: pop hl 
dec5			.startupend: 
dec5			 
dec5 cd bd 8a			call clear_display 
dec8 cd e0 8a			call update_display 
decb c9				ret 
decc			if STORAGE_SE 
decc			 
decc			sprompt3: db "Loading from start-up file?:",0 
decc			sprompt4: db "(Y=Any key/N=No)",0 
decc			 
decc			 
decc			forth_autoload: 
decc			 
decc				; load block 0 of store 1 
decc				 
decc				ld a, $fe      ; bit 0 clear 
decc				ld (spi_device), a 
decc			 
decc				call storage_get_block_0 
decc			 
decc				ld a, (store_page+STORE_0_AUTOFILE) 
decc			 
decc				cp 0 
decc				ret z     ; auto start not enabled 
decc			 
decc				call clear_display 
decc			 
decc				; set bank 
decc			 
decc					ld a, (store_page+STORE_0_BANKRUN) 
decc					ld (spi_device), a 
decc			 
decc				; get file id to load from and get the file name to display 
decc			 
decc					ld a, (store_page+STORE_0_FILERUN) 
decc			 
decc					ld l, 0 
decc					ld h, a 
decc					ld de, store_page 
decc			 
decc					if DEBUG_FORTH_WORDS 
decc						DMARK "ASp" 
decc						CALLMONITOR 
decc					endif 
decc					call storage_read 
decc			 
decc					if DEBUG_FORTH_WORDS 
decc						DMARK "ASr" 
decc						CALLMONITOR 
decc					endif 
decc			 
decc					call ishlzero 
decc					ret z             ; file not found 
decc			 
decc					ld a, display_row_2 + 10 
decc					ld de, store_page+3 
decc					call str_at_display 
decc				 
decc			; 
decc			 
decc				ld a, display_row_1+5 
decc				ld de, sprompt3 
decc				call str_at_display 
decc				ld a, display_row_3+15 
decc				ld de, sprompt4 
decc				call str_at_display 
decc			 
decc				call update_display 
decc			 
decc				call cin_wait 
decc				cp 'n' 
decc				ret z 
decc				cp 'N' 
decc				ret z 
decc			 
decc				call delay1s 
decc			 
decc				ld a, (store_page+2) 
decc				ld (store_openmaxext), a    ; save count of ext 
decc				ld a, 1  
decc				ld (store_openext), a    ; save count of ext 
decc			 
decc			.autof:  
decc				ld l , a 
decc				 
decc				ld a, (store_page) 
decc				ld h, a	 
decc				ld de, store_page 
decc					if DEBUG_FORTH_WORDS 
decc						DMARK "ASl" 
decc						CALLMONITOR 
decc					endif 
decc					call storage_read 
decc				call ishlzero 
decc				ret z 
decc			;	jr z, .autoend 
decc			 
decc					if DEBUG_FORTH_WORDS 
decc						DMARK "ASc" 
decc						CALLMONITOR 
decc					endif 
decc				ld de, store_page+2 
decc				ld a, display_row_4 
decc				call str_at_display 
decc			 
decc				call update_display 
decc				call delay250ms 
decc			 
decc			 
decc			 
decc				ld hl, store_page+2 
decc				call forthparse 
decc				call forthexec 
decc				call forthexec_cleanup 
decc			 
decc				 
decc				ld a, (store_openext) 
decc				inc a 
decc				ld (store_openext), a    ; save count of ext 
decc			 
decc				jr .autof 
decc			;.autofdone: 
decc			; 
decc			;		if DEBUG_FORTH_WORDS 
decc			;			DMARK "ASx" 
decc			;			CALLMONITOR 
decc			;		endif 
decc			;;	call clear_display 
decc			;	ret 
decc			 
decc			 
decc			 
decc			endif 
# End of file forth_startupv1.asm
decc			endif 
decc			if STARTUP_V2 
decc				include "forth_startupv2.asm" 
decc			endif 
decc			 
# End of file forth_startup.asm
decc			 
decc			; eof 
# End of file forth_kernel.asm
decc			;include "nascombasic.asm" 
decc			 
decc			 
decc			; find out where the code ends if loaded into RAM (for SC114) 
decc			;endofcode:  
decc			;	nop 
decc			 
decc			 
decc			; jump to nmi vector 
decc			 
decc			init_nmi: 
decc 3e c9			ld a, $c9   ; RET 
dece 32 72 ee			ld (nmi_vector), a 
ded1 c9				ret 
ded2			nmi: 
ded2 e5				push hl 
ded3 d5				push de 
ded4 c5				push bc 
ded5 f5				push af 
ded6 cd 72 ee			call nmi_vector 
ded9 f5				push af 
deda c5				push bc 
dedb d5				push de 
dedc e5				push hl 
dedd ed 4d			reti 
dedf			 
dedf			 
dedf			; eof 
dedf			 
# End of file main.asm
dedf			;include "firmware_lcd_4x40.asm" 
dedf			;;include "firmware_lcd_4x20.asm" 
dedf			include "firmware_serial_display.asm" 
dedf			 
dedf			; Serial display interface for SC114 
dedf			 
dedf			 
dedf			display_row_1: equ 0 
dedf			display_row_2: equ display_row_1+display_cols 
dedf			display_row_3: equ display_row_2 + display_cols 
dedf			display_row_4: equ display_row_3 + display_cols 
dedf			 
dedf			kLCDWidth:  EQU display_cols             ;Width in characters 
dedf			kLCD_Line1: EQU 0x00  
dedf			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
dedf			; E1 
dedf			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
dedf			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
dedf			 
dedf			lcd_init: 
dedf				; no init as handled by the SCM bios 
dedf c9				ret 
dee0			 
dee0			 
dee0			; low level functions for direct screen writes 
dee0			 
dee0			; output char at pos? 
dee0			fLCD_Str: 
dee0			        ;out (SC114_SIO_1_OUT),a 
dee0 c5				push bc 
dee1 0e 02			ld c, $02 
dee3 f7				rst $30 
dee4 c1				pop bc 
dee5 c9				ret 
dee6			 
dee6			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
dee6			fLCD_Pos: 
dee6				; use ASCII escape to position 
dee6			        ;out (SC114_SIO_1_OUT),a 
dee6 c5				push bc 
dee7 0e 02			ld c, $02 
dee9 f7				rst $30 
deea c1				pop bc 
deeb			 
deeb c9				ret 
deec			 
deec			; output char at pos 
deec			fLCD_Data: 
deec			      ;  out (SC114_SIO_1_OUT),a 
deec c5				push bc 
deed 0e 02			ld c, $02 
deef f7				rst $30 
def0 c1				pop bc 
def1			 
def1 c9				ret 
def2			 
def2			; ascii cls  
def2			 
def2 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
def6			 
def6			; write the frame buffer given in hl to hardware  
def6			write_display: 
def6			 
def6			API: equ 0 
def6			 
def6			if API 
def6				push bc 
def6				ld b, 4 
def6			 
def6			        ld (display_write_tmp), hl 	  
def6			 
def6				; clear and home cursor 
def6			 
def6				ld c, 6 
def6				ld de, .cls 
def6				rst $30 
def6			 
def6			 
def6			.writeln: 
def6			 
def6				ld de, (display_write_tmp) 
def6				ld c, 6 
def6				rst $30 
def6				ld c, 7 
def6				rst $30 
def6			 
def6				ld hl, (display_write_tmp) 
def6				ld de, display_cols 
def6				add hl,de 
def6				ld (display_write_tmp),hl 
def6			 
def6				djnz  .writeln 
def6			 
def6				pop bc 
def6			 
def6			 
def6				ret 
def6			endif 
def6 e5				push hl 
def7 c5				push bc 
def8 d5				push de 
def9			 
def9			;	ld c, 2 
def9			;	;ld de, .cls 
def9			;	ld a, 27 
def9			;	rst $30 
def9			;	ld c, 2 
def9			;	;ld de, .cls 
def9			;	ld a, '[' 
def9			;	rst $30 
def9			; 
def9			;	ld c, 2 
def9			;	;ld de, .cls 
def9			;	ld a, 'H' 
def9			;	rst $30 
def9			; 
def9			 
def9 0e 02			ld c, 2 
defb				;ld de, .cls 
defb 3e 1b			ld a, 27 
defd f7				rst $30 
defe			 
defe			 
defe 0e 02			ld c, 2 
df00				;ld de, .cls 
df00 3e 5b			ld a, '[' 
df02 f7				rst $30 
df03 0e 02			ld c, 2 
df05				;ld de, .cls 
df05 3e 32			ld a, '2' 
df07 f7				rst $30 
df08 0e 02			ld c, 2 
df0a				;ld de, .cls 
df0a 3e 4a			ld a, 'J' 
df0c f7				rst $30 
df0d d1				pop de 
df0e c1				pop bc 
df0f e1				pop hl 
df10			 
df10			 
df10 22 c3 eb		        ld (display_write_tmp), hl 	  
df13 3e 00			ld a, kLCD_Line1 
df15			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
df15 06 28			ld b, display_cols 
df17 ed 5b c3 eb		ld de, (display_write_tmp) 
df1b cd 79 df			call write_len_string 
df1e				 
df1e			 
df1e e5			push hl 
df1f d5			push de 
df20 c5			push bc 
df21 0e 07			ld c, 7 
df23 f7				rst $30 
df24 c1			pop bc 
df25 d1			pop de 
df26 e1			pop hl 
df27			 
df27				 
df27 2a c3 eb			ld hl, (display_write_tmp) 
df2a 11 28 00			ld de, display_cols 
df2d 19				add hl,de 
df2e 22 c3 eb			ld (display_write_tmp),hl 
df31			 
df31				 
df31 3e 28			ld a, kLCD_Line2 
df33			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
df33 06 28			ld b, display_cols 
df35 ed 5b c3 eb		ld de, (display_write_tmp) 
df39 cd 79 df			call write_len_string 
df3c				 
df3c 2a c3 eb			ld hl, (display_write_tmp) 
df3f 11 28 00			ld de, display_cols 
df42 19				add hl,de 
df43 22 c3 eb			ld (display_write_tmp),hl 
df46			 
df46 e5			push hl 
df47 d5			push de 
df48 c5			push bc 
df49 0e 07			ld c, 7 
df4b f7				rst $30 
df4c c1			pop bc 
df4d d1			pop de 
df4e e1			pop hl 
df4f			 
df4f				 
df4f 3e 50			ld a, kLCD_Line3 
df51			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
df51 06 28			ld b, display_cols 
df53 ed 5b c3 eb		ld de, (display_write_tmp) 
df57 cd 79 df			call write_len_string 
df5a				 
df5a 2a c3 eb			ld hl, (display_write_tmp) 
df5d 11 28 00			ld de, display_cols 
df60 19				add hl,de 
df61 22 c3 eb			ld (display_write_tmp),hl 
df64			 
df64 e5			push hl 
df65 d5			push de 
df66 c5			push bc 
df67 0e 07			ld c, 7 
df69 f7				rst $30 
df6a c1			pop bc 
df6b d1			pop de 
df6c e1			pop hl 
df6d			 
df6d				 
df6d 3e 78			ld a, kLCD_Line4 
df6f			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
df6f 06 28			ld b, display_cols 
df71 ed 5b c3 eb		ld de, (display_write_tmp) 
df75 cd 79 df			call write_len_string 
df78 c9					ret 
df79			 
df79			 
df79				; write out a fixed length string given in b from de 
df79			 
df79 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
df7a cd ec de		            CALL fLCD_Data      ;Write character to display 
df7d 13				inc de 
df7e 10 f9			djnz write_len_string 
df80 c9				ret 
df81			 
df81			 
df81			; eof 
# End of file firmware_serial_display.asm
df81			;include "firmware_key_5x10.asm" 
df81			;;include "firmware_key_4x10.asm" 
df81			include "firmware_key_serial.asm" 
df81			; Serial keyboard interface for SC114 
df81			 
df81			key_init: 
df81				; no init as handled by the SCM bios 
df81 c9				ret 
df82			 
df82			 
df82			cin_wait: 
df82			;	ld a, 0 
df82			;	ret 
df82			 
df82				;in a,(SC114_SIO_1_IN) 
df82			        ; Use SCM API to get from whatever console device we are using 
df82 c5				push bc 
df83 0e 01			ld c, $01 
df85 f7				rst $30 
df86 c1				pop bc 
df87 c9				ret 
df88			 
df88			cinndb: 	 
df88			cin: 
df88			 
df88			 
df88 c5				push bc 
df89			 
df89				; any key waiting to process? 
df89 0e 03			ld c, $03 
df8b f7				rst $30 
df8c 28 05			jr z, .cin_skip 
df8e			 
df8e				; yep, get it 
df8e			 
df8e 0e 01			ld c, $01 
df90 f7				rst $30 
df91 c1				pop bc 
df92 c9				ret 
df93			.cin_skip: 
df93 3e 00			ld a, 0 
df95 c1				pop bc 
df96 c9				ret 
df97			 
df97			 
df97			 
df97			 
# End of file firmware_key_serial.asm
df97			endofcode:  
df97			baseram:  
df97 00				nop 
df98			 
df98			heap_start: equ baseram+15  ; Starting address of heap 
df98			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
df98			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
df98			;VDU:  EQU     endofcode           ; BASIC Work space 
df98			; eof 
df98			 
# End of file os_mega_sc114.asm
df98
