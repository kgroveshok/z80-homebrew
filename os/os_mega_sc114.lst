# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 50 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c			;	call break_point_state  
801c			; now use the break point debug vector  
801c				call debug_vector  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_vector:  equ hardware_word - 3   ; vector to the debug handler  
801c			  
801c			debug_mark: equ debug_vector - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_active-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			;os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_new_exec_ptr - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c			;	ld a, ' ' 
801c			;	ld (os_view_disable), a 
801c				call bp_on 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 13 ed				ld hl, display_fb1  
801f 22 cf eb				ld (display_fb_active), hl  
8022			  
8022 cd af 8a				call clear_display  
8025			  
8025 21 d1 eb				ld hl, display_fb2  
8028 22 cf eb				ld (display_fb_active), hl  
802b			  
802b cd af 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b4 ed				ld hl, display_fb0  
8031 22 cf eb				ld (display_fb_active), hl  
8034			  
8034 cd af 8a				call clear_display  
8037			  
8037			  
8037 cd 93 e2				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 35 e3			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 7f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd d2 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd b4 8a			call fill_display  
804e cd d2 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd b4 8a			call fill_display  
8059 cd d2 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd b4 8a			call fill_display  
8064 cd d2 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 ae 96			ld de, prom_bootmsg  
806f cd c2 8a			call str_at_display  
8072 cd d2 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 c3 96			ld de, prom_bootmsg1  
8080 cd c2 8a			call str_at_display  
8083 cd d2 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 6e ee		ld (debug_mark),a  
8091 32 6f ee		ld (debug_mark+1),a  
8094 32 70 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 71 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 76 ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 6e ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 6f ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 70 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 72 ee			call debug_vector  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 7d ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 6e ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 6f ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 70 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 72 ee			call debug_vector  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 7d ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 6e ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 6f ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 70 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 72 ee			call debug_vector  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 05 8d				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 76 ea				ld hl, (store_tmp1) 
8110 11 80 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 6e ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 6f ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 70 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 72 ee			call debug_vector  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 72 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 6e ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 6f ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 70 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 72 ee			call debug_vector  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 6e ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 6f ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 70 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 72 ee			call debug_vector  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 6e ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 6f ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 70 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 72 ee			call debug_vector  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 6e ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 6f ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 70 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 72 ee			call debug_vector  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 05 8d			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 7d ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 7f ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 6e ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 6f ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 70 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 72 ee			call debug_vector  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 6e ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 6f ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 70 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 72 ee			call debug_vector  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 7d ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 6e ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 6f ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 70 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 7d ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 72 ee			call debug_vector  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 7e ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 6e ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 6f ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 70 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 72 ee			call debug_vector  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 6e ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 6f ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 70 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 72 ee			call debug_vector  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 7d ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 7e ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 80 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 89 ea			ld hl, store_page+3+9 
82b5 3a 62 ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 7d ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 6e ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 6f ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 70 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 72 ee			call debug_vector  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 6e ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 6f ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 70 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 72 ee			call debug_vector  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd dc 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd dc 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 6e ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 6f ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 70 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 72 ee			call debug_vector  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 80 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 6e ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 6f ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 70 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 72 ee			call debug_vector  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 7d ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 6e ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 6f ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 70 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 72 ee			call debug_vector  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 6e ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 6f ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 70 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 72 ee			call debug_vector  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 05 8d			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 7d ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 05 8d			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 6e ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 6f ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 70 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 72 ee			call debug_vector  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 7d ea			ld a, (store_page)	; get file id 
8410 32 71 ea			ld (store_tmpid), a 
8413			 
8413 3a 7f ea			ld a, (store_page+2)    ; get count of extends 
8416 32 70 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 7d ea			ld (store_page), a 
841f 32 7e ea			ld (store_page+1),a 
8422 11 7d ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 6e ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 6f ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 70 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 72 ee			call debug_vector  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 70 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 71 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 6e ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 6f ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 70 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 72 ee			call debug_vector  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 05 8d			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 7d ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 7d ea			ld (store_page), a 
8482 32 7e ea			ld (store_page+1),a 
8485 11 7d ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 6e ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 6f ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 70 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 72 ee			call debug_vector  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 6e ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 6f ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 70 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 72 ee			call debug_vector  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd fa 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd dc 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd fa 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd dc 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 6e ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 6f ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 70 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 72 ee			call debug_vector  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 6e ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 6f ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 70 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 72 ee			call debug_vector  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd dc 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd dc 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 6e ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 6f ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 70 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 72 ee			call debug_vector  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 7d ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 7d ea			ld (store_page),a 
85a3				 
85a3 32 71 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 7d ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 6e ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 6f ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 70 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 72 ee			call debug_vector  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 7d ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 6e ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 6f ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 70 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 72 ee			call debug_vector  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 68 ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 6e ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 6f ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 70 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 72 ee			call debug_vector  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 68 ea			ld (store_tmppageid), hl 
8615				 
8615 3a 71 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 7d ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 7e ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 7f ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 80 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 6e ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 6f ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 70 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 72 ee			call debug_vector  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 45 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 6e ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 6f ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 70 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 72 ee			call debug_vector  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 6e ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 6f ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 70 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 72 ee			call debug_vector  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 68 ea			ld hl,(store_tmppageid) 
868b 11 7d ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 6e ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 6f ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 70 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 72 ee			call debug_vector  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 71 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 6e ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 6f ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 70 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 72 ee			call debug_vector  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 7b ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 79 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 6e ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 6f ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 70 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd 72 ee			call debug_vector  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 6e ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 6f ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 70 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd 72 ee			call debug_vector  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 05 8d			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 6e ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 79 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 6e ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 6f ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 70 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd 72 ee			call debug_vector  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 79 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd dc 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 70 ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 6e ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 6f ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 70 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd 72 ee			call debug_vector  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 78 ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 79 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd dc 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 6e ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 6f ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 70 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd 72 ee			call debug_vector  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 79 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 7b ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 7b ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 6e ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 6f ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 70 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd 72 ee			call debug_vector  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 6e ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 6f ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 70 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd 72 ee			call debug_vector  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd 05 8d			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 6e ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 79 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 79 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 6e ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 6f ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 70 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd 72 ee			call debug_vector  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 6e ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 6f ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 70 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd 72 ee			call debug_vector  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 6e ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 6f ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 70 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd 72 ee			call debug_vector  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 6e ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 6f ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 70 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd 72 ee			call debug_vector  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 71 ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 71 ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd 05 8d			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 68 ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 6e ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 6f ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 70 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd 72 ee			call debug_vector  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 7d ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 6e ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 6f ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 70 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd 72 ee			call debug_vector  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 7f ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 7f ea			ld (store_page+2), a 
88e3 32 70 ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 6e ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 6f ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 70 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd 72 ee			call debug_vector  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 68 ea			ld hl, (store_tmppageid) 
8905 11 7d ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd 05 8d			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 68 ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 6e ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 6f ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 70 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd 72 ee			call debug_vector  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 7d ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 71 ea				ld a, (store_tmpid) 
894b 32 7d ea				ld (store_page), a   ; file id 
894e 3a 70 ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 7e ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 7f ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 6e ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 6f ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 70 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd 72 ee			call debug_vector  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 68 ea			ld hl, (store_tmppageid) 
8985 11 7d ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 6e ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 6f ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 70 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 72 ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 71 ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 7d ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 7e ea			ld de, store_page+1 
89c1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; Display an activity indicator 
8a06			; Each call returns the new char pointed to in hl 
8a06			 
8a06			active: 
8a06 3a c9 eb			ld a, (display_active) 
8a09 fe 06			cp 6 
8a0b			 
8a0b 20 02			jr nz, .sne 
8a0d				; gone past the last one reset sequence 
8a0d 3e ff			ld a, 255 
8a0f			 
8a0f			.sne:   
8a0f				; get the next char in seq 
8a0f 3c				inc a 
8a10 32 c9 eb			ld (display_active), a 
8a13			 
8a13				; look up the string in the table 
8a13 21 2a 8a			ld hl, actseq 
8a16 cb 27			sla a 
8a18 cd dc 8c			call addatohl 
8a1b cd 78 9e			call loadwordinhl 
8a1e			 
8a1e				; forth will write the to string when pushing so move from rom to ram 
8a1e			 
8a1e 11 ca eb			ld de, display_active+1 
8a21 01 02 00			ld bc, 2 
8a24 ed b0			ldir 
8a26			 
8a26 21 ca eb			ld hl, display_active+1 
8a29 c9				ret 
8a2a				 
8a2a				 
8a2a			 
8a2a			 
8a2a			;db "|/-\|-\" 
8a2a			 
8a2a			actseq: 
8a2a			 
8a2a 38 8a		dw spin0 
8a2c 3a 8a		dw spin1 
8a2e 3c 8a		dw spin2 
8a30 3e 8a		dw spin3 
8a32 3c 8a		dw spin2 
8a34 3a 8a		dw spin1 
8a36 38 8a		dw spin0 
8a38			 
8a38 .. 00		spin0: db " ", 0 
8a3a .. 00		spin1: db "-", 0 
8a3c .. 00		spin2: db "+", 0 
8a3e .. 00		spin3: db "#", 0 
8a40			 
8a40			 
8a40			; information window 
8a40			 
8a40			; pass hl with 1st string to display 
8a40			; pass de with 2nd string to display 
8a40			 
8a40			info_panel: 
8a40 e5				push hl 
8a41			 
8a41 2a cf eb			ld hl, (display_fb_active) 
8a44 e5				push hl    ; future de destination 
8a45 21 b4 ed				ld hl, display_fb0 
8a48 22 cf eb				ld (display_fb_active), hl 
8a4b			 
8a4b			;	call clear_display 
8a4b			 
8a4b				if BASE_CPM 
8a4b				ld a, '.' 
8a4b				else 
8a4b 3e a5			ld a, 165 
8a4d				endif 
8a4d cd b4 8a			call fill_display 
8a50			 
8a50			 
8a50 3e 55			ld a, display_row_3 + 5 
8a52 cd c2 8a			call str_at_display 
8a55			 
8a55 e1				pop hl 
8a56 d1				pop de 
8a57			 
8a57 e5				push hl 
8a58			 
8a58			 
8a58 3e 2d			ld a, display_row_2 + 5 
8a5a cd c2 8a			call str_at_display 
8a5d			 
8a5d			 
8a5d cd d2 8a			call update_display 
8a60 cd c1 9a			call next_page_prompt 
8a63 cd af 8a			call clear_display 
8a66			 
8a66				 
8a66 21 13 ed				ld hl, display_fb1 
8a69 22 cf eb				ld (display_fb_active), hl 
8a6c cd d2 8a			call update_display 
8a6f			 
8a6f e1				pop hl 
8a70			 
8a70 c9				ret 
8a71			 
8a71			 
8a71			 
8a71			 
8a71			; TODO windowing? 
8a71			 
8a71			; TODO scroll line up 
8a71			 
8a71			scroll_up: 
8a71			 
8a71 e5				push hl 
8a72 d5				push de 
8a73 c5				push bc 
8a74			 
8a74				; get frame buffer  
8a74			 
8a74 2a cf eb			ld hl, (display_fb_active) 
8a77 e5				push hl    ; future de destination 
8a78			 
8a78 11 28 00			ld  de, display_cols 
8a7b 19				add hl, de 
8a7c			 
8a7c d1				pop de 
8a7d			 
8a7d				;ex de, hl 
8a7d 01 9f 00			ld bc, display_fb_len -1  
8a80			;if DEBUG_FORTH_WORDS 
8a80			;	DMARK "SCL" 
8a80			;	CALLMONITOR 
8a80			;endif	 
8a80 ed b0			ldir 
8a82			 
8a82				; wipe bottom row 
8a82			 
8a82			 
8a82 2a cf eb			ld hl, (display_fb_active) 
8a85 11 a0 00			ld de, display_cols*display_rows 
8a88 19				add hl, de 
8a89 06 28			ld b, display_cols 
8a8b 3e 20			ld a, ' ' 
8a8d			.scwipe: 
8a8d 77				ld (hl), a 
8a8e 2b				dec hl 
8a8f 10 fc			djnz .scwipe 
8a91			 
8a91				;pop hl 
8a91			 
8a91 c1				pop bc 
8a92 d1				pop de 
8a93 e1				pop hl 
8a94			 
8a94 c9				ret 
8a95			 
8a95			 
8a95			;scroll_upo: 
8a95			;	ld de, display_row_1 
8a95			 ;	ld hl, display_row_2 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_2 
8a95			 ;	ld hl, display_row_3 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_3 
8a95			 ;	ld hl, display_row_4 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			 
8a95			; TODO clear row 4 
8a95			 
8a95			;	ret 
8a95			 
8a95				 
8a95			scroll_down: 
8a95			 
8a95 e5				push hl 
8a96 d5				push de 
8a97 c5				push bc 
8a98			 
8a98				; get frame buffer  
8a98			 
8a98 2a cf eb			ld hl, (display_fb_active) 
8a9b			 
8a9b 11 9f 00			ld de, display_fb_len - 1 
8a9e 19				add hl, de 
8a9f			 
8a9f e5			push hl    ; future de destination 
8aa0			 
8aa0 11 28 00			ld  de, display_cols 
8aa3 ed 52			sbc hl, de 
8aa5			 
8aa5			 
8aa5 d1				pop de 
8aa6			 
8aa6			;	ex de, hl 
8aa6 01 9f 00			ld bc, display_fb_len -1  
8aa9			 
8aa9			 
8aa9				 
8aa9			 
8aa9 ed b0			ldir 
8aab			 
8aab				; wipe bottom row 
8aab			 
8aab			 
8aab			;	ld hl, (display_fb_active) 
8aab			;;	ld de, display_cols*display_rows 
8aab			;;	add hl, de 
8aab			;	ld b, display_cols 
8aab			;	ld a, ' ' 
8aab			;.scwiped: 
8aab			;	ld (hl), a 
8aab			;	dec hl 
8aab			;	djnz .scwiped 
8aab			 
8aab				;pop hl 
8aab			 
8aab c1				pop bc 
8aac d1				pop de 
8aad e1				pop hl 
8aae			 
8aae c9				ret 
8aaf			;scroll_down: 
8aaf			;	ld de, display_row_4 
8aaf			;	ld hl, display_row_3 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_3 
8aaf			; 	ld hl, display_row_2 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_2 
8aaf			;	ld hl, display_row_1 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;;; TODO clear row 1 
8aaf			;	ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			; clear active frame buffer 
8aaf			 
8aaf			clear_display: 
8aaf 3e 20			ld a, ' ' 
8ab1 c3 b4 8a			jp fill_display 
8ab4			 
8ab4			; fill active frame buffer with a char in A 
8ab4			 
8ab4			fill_display: 
8ab4 06 a0			ld b,display_fb_len 
8ab6 2a cf eb			ld hl, (display_fb_active) 
8ab9 77			.fd1:	ld (hl),a 
8aba 23				inc hl 
8abb 10 fc			djnz .fd1 
8abd 23				inc hl 
8abe 3e 00			ld a,0 
8ac0 77				ld (hl),a 
8ac1			 
8ac1			 
8ac1 c9				ret 
8ac2			; Write string (DE) at pos (A) to active frame buffer 
8ac2			 
8ac2 2a cf eb		str_at_display:    ld hl,(display_fb_active) 
8ac5 06 00					ld b,0 
8ac7 4f					ld c,a 
8ac8 09					add hl,bc 
8ac9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8aca b7			            OR   A              ;Null terminator? 
8acb c8			            RET  Z              ;Yes, so finished 
8acc 77					ld (hl),a 
8acd 23				inc hl 
8ace 13			            INC  DE             ;Point to next character 
8acf 18 f8		            JR   .sad1     ;Repeat 
8ad1 c9					ret 
8ad2			 
8ad2			; using current frame buffer write to physical display 
8ad2			 
8ad2			update_display: 
8ad2 e5				push hl 
8ad3 2a cf eb			ld hl, (display_fb_active) 
8ad6 cd aa e2			call write_display 
8ad9 e1				pop hl 
8ada c9				ret 
8adb			 
8adb			; TODO scrolling 
8adb			 
8adb			 
8adb			; move cursor right one char 
8adb			cursor_right: 
8adb			 
8adb				; TODO shift right 
8adb				; TODO if beyond max col 
8adb				; TODO       cursor_next_line 
8adb			 
8adb c9				ret 
8adc			 
8adc			 
8adc			cursor_next_line: 
8adc				; TODO first char 
8adc				; TODO line down 
8adc				; TODO if past last row 
8adc				; TODO    scroll up 
8adc			 
8adc c9				ret 
8add			 
8add			cursor_left: 
8add				; TODO shift left 
8add				; TODO if beyond left  
8add				; TODO     cursor prev line 
8add				 
8add c9				ret 
8ade			 
8ade			cursor_prev_line: 
8ade				; TODO last char 
8ade				; TODO line up 
8ade				; TODO if past first row 
8ade				; TODO   scroll down 
8ade			 
8ade c9				ret 
8adf			 
8adf			 
8adf			cout: 
8adf				; A - char 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			; Display a menu and allow item selection (optional toggle items) 
8ae0			; 
8ae0			; format: 
8ae0			; hl pointer to word array with zero term for items 
8ae0			; e.g.    db item1 
8ae0			;         db .... 
8ae0			;         db 0 
8ae0			; 
8ae0			; a = starting menu item  
8ae0			; 
8ae0			; de = pointer item toggle array   (todo) 
8ae0			; 
8ae0			; returns item selected in a 1-... 
8ae0			; returns 0 if back button pressed 
8ae0			; 
8ae0			; NOTE: Uses system frame buffer to display 
8ae0			; 
8ae0			; LEFT, Q = go back 
8ae0			; RIGHT, SPACE, CR = select 
8ae0			; UP, A - Up 
8ae0			; DOWN, Z - Down 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			menu: 
8ae0			 
8ae0					; keep array pointer 
8ae0			 
8ae0 22 76 ea				ld (store_tmp1), hl 
8ae3 32 74 ea				ld (store_tmp2), a 
8ae6			 
8ae6					; check for key bounce 
8ae6			 
8ae6			if BASE_KEV 
8ae6			 
8ae6			.mbounce:	call cin 
8ae6					cp 0 
8ae6					jr nz, .mbounce 
8ae6			endif 
8ae6					; for ease use ex 
8ae6			 
8ae6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae6 21 b4 ed				ld hl, display_fb0 
8ae9 22 cf eb				ld (display_fb_active), hl 
8aec			 
8aec cd af 8a		.mloop:		call clear_display 
8aef cd d2 8a				call update_display 
8af2			 
8af2					; draw selection id '>' at 1 
8af2			 
8af2					; init start of list display 
8af2			 
8af2 3e 05				ld a, 5 
8af4 32 72 ea				ld (store_tmp3), a   ; display row count 
8af7 3a 74 ea				ld a,( store_tmp2) 
8afa 32 75 ea				ld (store_tmp2+1), a   ; display item count 
8afd			 
8afd					 
8afd			.mitem:	 
8afd			 
8afd			 
8afd 3a 75 ea				ld a,(store_tmp2+1) 
8b00 6f					ld l, a 
8b01 26 00				ld h, 0 
8b03 29					add hl, hl 
8b04 ed 5b 76 ea			ld de, (store_tmp1) 
8b08 19					add hl, de 
8b09 7e					ld a, (hl) 
8b0a 23					inc hl 
8b0b 66					ld h,(hl) 
8b0c 6f					ld l, a 
8b0d			 
8b0d cd 05 8d				call ishlzero 
8b10 28 1a				jr z, .mdone 
8b12			 
8b12 eb					ex de, hl 
8b13 3a 72 ea				ld a, (store_tmp3) 
8b16 cd c2 8a				call str_at_display 
8b19					 
8b19			 
8b19					; next item 
8b19 3a 75 ea				ld a, (store_tmp2+1) 
8b1c 3c					inc a 
8b1d 32 75 ea				ld (store_tmp2+1), a   ; display item count 
8b20			 
8b20			 		; next row 
8b20			 
8b20 3a 72 ea				ld a, (store_tmp3) 
8b23 c6 28				add display_cols 
8b25 32 72 ea				ld (store_tmp3), a 
8b28			 
8b28					; at end of screen? 
8b28			 
8b28 fe 10				cp display_rows*4 
8b2a 20 d1				jr nz, .mitem 
8b2c			 
8b2c			 
8b2c			.mdone: 
8b2c cd 05 8d				call ishlzero 
8b2f 28 08				jr z, .nodn 
8b31			 
8b31 3e 78				ld a, display_row_4 
8b33 11 b2 8b				ld de, .mdown 
8b36 cd c2 8a				call str_at_display 
8b39			 
8b39					; draw options to fill the screens with active item on line 1 
8b39					; if current option is 2 or more then display ^ in top 
8b39			 
8b39 3a 74 ea		.nodn:		ld a, (store_tmp2) 
8b3c fe 00				cp 0 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 b0 8b				ld de, .mup 
8b45 cd c2 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ae 8b				ld de, .msel 
8b4d cd c2 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d2 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd 36 e3				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 32				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2e				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 34				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 30				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2c				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ec 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1d			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 74 ea				ld a, (store_tmp2) 
8b88 fe 00				cp 0 
8b8a ca ec 8a				jp z, .mloop 
8b8d 3d					dec a 
8b8e 32 74 ea				ld (store_tmp2), a 
8b91 c3 ec 8a				jp .mloop 
8b94			 
8b94				; move down one 
8b94			.mgod: 
8b94 3a 74 ea				ld a, (store_tmp2) 
8b97 3c					inc a 
8b98 32 74 ea				ld (store_tmp2), a 
8b9b c3 ec 8a				jp .mloop 
8b9e			 
8b9e			 
8b9e			.goend: 
8b9e					; get selected item number 
8b9e			 
8b9e 3a 74 ea				ld a, (store_tmp2) 
8ba1 3c					inc a 
8ba2			 
8ba2			.goend2: 
8ba2 f5					push af 
8ba3			 
8ba3					; restore active fb 
8ba3					; TODO BUG assumes fb1 
8ba3			 
8ba3 21 13 ed				ld hl, display_fb1 
8ba6 22 cf eb				ld (display_fb_active), hl 
8ba9			 
8ba9					; restore main regs 
8ba9			 
8ba9			 
8ba9 cd d2 8a				call update_display 
8bac			 
8bac f1					pop af 
8bad			 
8bad c9				ret 
8bae			 
8bae .. 00		.msel:   db ">",0 
8bb0 .. 00		.mup:   db "^",0 
8bb2 .. 00		.mdown:   db "v",0 
8bb4			 
8bb4			 
8bb4			; eof 
8bb4			 
# End of file firmware_display.asm
8bb4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb4			; random number generators 
8bb4			 
8bb4			 
8bb4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb4			 
8bb4			 
8bb4			;-----> Generate a random number 
8bb4			; output a=answer 0<=a<=255 
8bb4			; all registers are preserved except: af 
8bb4			random: 
8bb4 e5			        push    hl 
8bb5 d5			        push    de 
8bb6 2a ae eb		        ld      hl,(randData) 
8bb9 ed 5f		        ld      a,r 
8bbb 57			        ld      d,a 
8bbc 5e			        ld      e,(hl) 
8bbd 19			        add     hl,de 
8bbe 85			        add     a,l 
8bbf ac			        xor     h 
8bc0 22 ae eb		        ld      (randData),hl 
8bc3 d1			        pop     de 
8bc4 e1			        pop     hl 
8bc5 c9			        ret 
8bc6			 
8bc6			 
8bc6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc6			 
8bc6			 
8bc6			 
8bc6			;------LFSR------ 
8bc6			;James Montelongo 
8bc6			;optimized by Spencer Putt 
8bc6			;out: 
8bc6			; a = 8 bit random number 
8bc6			RandLFSR: 
8bc6 21 b4 eb		        ld hl,LFSRSeed+4 
8bc9 5e			        ld e,(hl) 
8bca 23			        inc hl 
8bcb 56			        ld d,(hl) 
8bcc 23			        inc hl 
8bcd 4e			        ld c,(hl) 
8bce 23			        inc hl 
8bcf 7e			        ld a,(hl) 
8bd0 47			        ld b,a 
8bd1 cb 13		        rl e  
8bd3 cb 12			rl d 
8bd5 cb 11		        rl c  
8bd7 17				rla 
8bd8 cb 13		        rl e  
8bda cb 12			rl d 
8bdc cb 11		        rl c  
8bde 17				rla 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 67			        ld h,a 
8be7 cb 13		        rl e  
8be9 cb 12			rl d 
8beb cb 11		        rl c  
8bed 17				rla 
8bee a8			        xor b 
8bef cb 13		        rl e  
8bf1 cb 12			rl d 
8bf3 ac			        xor h 
8bf4 a9			        xor c 
8bf5 aa			        xor d 
8bf6 21 b6 eb		        ld hl,LFSRSeed+6 
8bf9 11 b7 eb		        ld de,LFSRSeed+7 
8bfc 01 07 00		        ld bc,7 
8bff ed b8		        lddr 
8c01 12			        ld (de),a 
8c02 c9			        ret 
8c03			 
8c03			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c03			 
8c03			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c03			 
8c03			 
8c03			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c03			 
8c03			prng16: 
8c03			;Inputs: 
8c03			;   (seed1) contains a 16-bit seed value 
8c03			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c03			;Outputs: 
8c03			;   HL is the result 
8c03			;   BC is the result of the LCG, so not that great of quality 
8c03			;   DE is preserved 
8c03			;Destroys: 
8c03			;   AF 
8c03			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c03			;160cc 
8c03			;26 bytes 
8c03 2a a8 eb		    ld hl,(seed1) 
8c06 44			    ld b,h 
8c07 4d			    ld c,l 
8c08 29			    add hl,hl 
8c09 29			    add hl,hl 
8c0a 2c			    inc l 
8c0b 09			    add hl,bc 
8c0c 22 a8 eb		    ld (seed1),hl 
8c0f 2a a6 eb		    ld hl,(seed2) 
8c12 29			    add hl,hl 
8c13 9f			    sbc a,a 
8c14 e6 2d		    and %00101101 
8c16 ad			    xor l 
8c17 6f			    ld l,a 
8c18 22 a6 eb		    ld (seed2),hl 
8c1b 09			    add hl,bc 
8c1c c9			    ret 
8c1d			 
8c1d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1d			 
8c1d			rand32: 
8c1d			;Inputs: 
8c1d			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1d			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1d			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1d			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1d			;   **NOTE: seed2 must be non-zero 
8c1d			;Outputs: 
8c1d			;   HL is the result 
8c1d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1d			;Destroys: 
8c1d			;   AF 
8c1d			;Tested and passes all CAcert tests 
8c1d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1d			;it has a period of 18,446,744,069,414,584,320 
8c1d			;roughly 18.4 quintillion. 
8c1d			;LFSR taps: 0,2,6,7  = 11000101 
8c1d			;291cc 
8c1d			;seed1_0=$+1 
8c1d			;    ld hl,12345 
8c1d			;seed1_1=$+1 
8c1d			;    ld de,6789 
8c1d			;    ld b,h 
8c1d			;    ld c,l 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    inc l 
8c1d			;    add hl,bc 
8c1d			;    ld (seed1_0),hl 
8c1d			;    ld hl,(seed1_1) 
8c1d			;    adc hl,de 
8c1d			;    ld (seed1_1),hl 
8c1d			;    ex de,hl 
8c1d			;seed2_0=$+1 
8c1d			;    ld hl,9876 
8c1d			;seed2_1=$+1 
8c1d			;    ld bc,54321 
8c1d			;    add hl,hl \ rl c \ rl b 
8c1d			;    ld (seed2_1),bc 
8c1d			;    sbc a,a 
8c1d			;    and %11000101 
8c1d			;    xor l 
8c1d			;    ld l,a 
8c1d			;    ld (seed2_0),hl 
8c1d			;    ex de,hl 
8c1d			;    add hl,bc 
8c1d			;    ret 
8c1d			; 
8c1d			 
8c1d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1d			; 20 bytes, 86 cycles (excluding ret) 
8c1d			 
8c1d			; returns   hl = pseudorandom number 
8c1d			; corrupts   a 
8c1d			 
8c1d			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1d			; using the xorshift method: 
8c1d			 
8c1d			; hl ^= hl << 7 
8c1d			; hl ^= hl >> 9 
8c1d			; hl ^= hl << 8 
8c1d			 
8c1d			; some alternative shift triplets which also perform well are: 
8c1d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1d			 
8c1d			;  org 32768 
8c1d			 
8c1d			xrnd: 
8c1d 2a ac eb		  ld hl,(xrandc)       ; seed must not be 0 
8c20 3e 00		  ld a,0 
8c22 bd			  cp l 
8c23 20 02		  jr nz, .xrnd1 
8c25 2e 01		  ld l, 1 
8c27			.xrnd1: 
8c27			 
8c27 7c			  ld a,h 
8c28 1f			  rra 
8c29 7d			  ld a,l 
8c2a 1f			  rra 
8c2b ac			  xor h 
8c2c 67			  ld h,a 
8c2d 7d			  ld a,l 
8c2e 1f			  rra 
8c2f 7c			  ld a,h 
8c30 1f			  rra 
8c31 ad			  xor l 
8c32 6f			  ld l,a 
8c33 ac			  xor h 
8c34 67			  ld h,a 
8c35			 
8c35 22 ac eb		  ld (xrandc),hl 
8c38			 
8c38 c9			  ret 
8c39			;  
8c39			 
8c39			 
8c39			;;;; int maths 
8c39			 
8c39			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c39			; Divide 16-bit values (with 16-bit result) 
8c39			; In: Divide BC by divider DE 
8c39			; Out: BC = result, HL = rest 
8c39			; 
8c39			Div16: 
8c39 21 00 00		    ld hl,0 
8c3c 78			    ld a,b 
8c3d 06 08		    ld b,8 
8c3f			Div16_Loop1: 
8c3f 17			    rla 
8c40 ed 6a		    adc hl,hl 
8c42 ed 52		    sbc hl,de 
8c44 30 01		    jr nc,Div16_NoAdd1 
8c46 19			    add hl,de 
8c47			Div16_NoAdd1: 
8c47 10 f6		    djnz Div16_Loop1 
8c49 17			    rla 
8c4a 2f			    cpl 
8c4b 47			    ld b,a 
8c4c 79			    ld a,c 
8c4d 48			    ld c,b 
8c4e 06 08		    ld b,8 
8c50			Div16_Loop2: 
8c50 17			    rla 
8c51 ed 6a		    adc hl,hl 
8c53 ed 52		    sbc hl,de 
8c55 30 01		    jr nc,Div16_NoAdd2 
8c57 19			    add hl,de 
8c58			Div16_NoAdd2: 
8c58 10 f6		    djnz Div16_Loop2 
8c5a 17			    rla 
8c5b 2f			    cpl 
8c5c 41			    ld b,c 
8c5d 4f			    ld c,a 
8c5e c9			ret 
8c5f			 
8c5f			 
8c5f			;http://z80-heaven.wikidot.com/math 
8c5f			; 
8c5f			;Inputs: 
8c5f			;     DE and A are factors 
8c5f			;Outputs: 
8c5f			;     A is not changed 
8c5f			;     B is 0 
8c5f			;     C is not changed 
8c5f			;     DE is not changed 
8c5f			;     HL is the product 
8c5f			;Time: 
8c5f			;     342+6x 
8c5f			; 
8c5f			Mult16: 
8c5f			 
8c5f 06 08		     ld b,8          ;7           7 
8c61 21 00 00		     ld hl,0         ;10         10 
8c64 29			       add hl,hl     ;11*8       88 
8c65 07			       rlca          ;4*8        32 
8c66 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c68 19			         add hl,de   ;--         -- 
8c69 10 f9		       djnz $-5      ;13*7+8     99 
8c6b c9			ret 
8c6c			 
8c6c			; 
8c6c			; Square root of 16-bit value 
8c6c			; In:  HL = value 
8c6c			; Out:  D = result (rounded down) 
8c6c			; 
8c6c			;Sqr16: 
8c6c			;    ld de,#0040 
8c6c			;    ld a,l 
8c6c			;    ld l,h 
8c6c			;    ld h,d 
8c6c			;    or a 
8c6c			;    ld b,8 
8c6c			;Sqr16_Loop: 
8c6c			;    sbc hl,de 
8c6c			;    jr nc,Sqr16_Skip 
8c6c			;    add hl,de 
8c6c			;Sqr16_Skip: 
8c6c			;    ccf 
8c6c			;    rl d 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    djnz Sqr16_Loop 
8c6c			;    ret 
8c6c			; 
8c6c			; 
8c6c			; Divide 8-bit values 
8c6c			; In: Divide E by divider C 
8c6c			; Out: A = result, B = rest 
8c6c			; 
8c6c			Div8: 
8c6c af			    xor a 
8c6d 06 08		    ld b,8 
8c6f			Div8_Loop: 
8c6f cb 13		    rl e 
8c71 17			    rla 
8c72 91			    sub c 
8c73 30 01		    jr nc,Div8_NoAdd 
8c75 81			    add a,c 
8c76			Div8_NoAdd: 
8c76 10 f7		    djnz Div8_Loop 
8c78 47			    ld b,a 
8c79 7b			    ld a,e 
8c7a 17			    rla 
8c7b 2f			    cpl 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7d			; In: Multiply A with DE 
8c7d			; Out: HL = result 
8c7d			; 
8c7d			Mult12U: 
8c7d 2e 00		    ld l,0 
8c7f 87			    add a,a 
8c80 30 01		    jr nc,Mult12U_NoAdd0 
8c82 19			    add hl,de 
8c83			Mult12U_NoAdd0: 
8c83 29			    add hl,hl 
8c84 87			    add a,a 
8c85 30 01		    jr nc,Mult12U_NoAdd1 
8c87 19			    add hl,de 
8c88			Mult12U_NoAdd1: 
8c88 29			    add hl,hl 
8c89 87			    add a,a 
8c8a 30 01		    jr nc,Mult12U_NoAdd2 
8c8c 19			    add hl,de 
8c8d			Mult12U_NoAdd2: 
8c8d 29			    add hl,hl 
8c8e 87			    add a,a 
8c8f 30 01		    jr nc,Mult12U_NoAdd3 
8c91 19			    add hl,de 
8c92			Mult12U_NoAdd3: 
8c92 29			    add hl,hl 
8c93 87			    add a,a 
8c94 30 01		    jr nc,Mult12U_NoAdd4 
8c96 19			    add hl,de 
8c97			Mult12U_NoAdd4: 
8c97 29			    add hl,hl 
8c98 87			    add a,a 
8c99 30 01		    jr nc,Mult12U_NoAdd5 
8c9b 19			    add hl,de 
8c9c			Mult12U_NoAdd5: 
8c9c 29			    add hl,hl 
8c9d 87			    add a,a 
8c9e 30 01		    jr nc,Mult12U_NoAdd6 
8ca0 19			    add hl,de 
8ca1			Mult12U_NoAdd6: 
8ca1 29			    add hl,hl 
8ca2 87			    add a,a 
8ca3 d0			    ret nc 
8ca4 19			    add hl,de 
8ca5 c9			    ret 
8ca6			 
8ca6			; 
8ca6			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca6			; In: Multiply A with DE 
8ca6			;      Put lowest value in A for most efficient calculation 
8ca6			; Out: HL = result 
8ca6			; 
8ca6			Mult12R: 
8ca6 21 00 00		    ld hl,0 
8ca9			Mult12R_Loop: 
8ca9 cb 3f		    srl a 
8cab 30 01		    jr nc,Mult12R_NoAdd 
8cad 19			    add hl,de 
8cae			Mult12R_NoAdd: 
8cae cb 23		    sla e 
8cb0 cb 12		    rl d 
8cb2 b7			    or a 
8cb3 c2 a9 8c		    jp nz,Mult12R_Loop 
8cb6 c9			    ret 
8cb7			 
8cb7			; 
8cb7			; Multiply 16-bit values (with 32-bit result) 
8cb7			; In: Multiply BC with DE 
8cb7			; Out: BCHL = result 
8cb7			; 
8cb7			Mult32: 
8cb7 79			    ld a,c 
8cb8 48			    ld c,b 
8cb9 21 00 00		    ld hl,0 
8cbc 06 10		    ld b,16 
8cbe			Mult32_Loop: 
8cbe 29			    add hl,hl 
8cbf 17			    rla 
8cc0 cb 11		    rl c 
8cc2 30 07		    jr nc,Mult32_NoAdd 
8cc4 19			    add hl,de 
8cc5 ce 00		    adc a,0 
8cc7 d2 cb 8c		    jp nc,Mult32_NoAdd 
8cca 0c			    inc c 
8ccb			Mult32_NoAdd: 
8ccb 10 f1		    djnz Mult32_Loop 
8ccd 41			    ld b,c 
8cce 4f			    ld c,a 
8ccf c9			    ret 
8cd0			 
8cd0			 
8cd0			 
8cd0			; 
8cd0			; Multiply 8-bit values 
8cd0			; In:  Multiply H with E 
8cd0			; Out: HL = result 
8cd0			; 
8cd0			Mult8: 
8cd0 16 00		    ld d,0 
8cd2 6a			    ld l,d 
8cd3 06 08		    ld b,8 
8cd5			Mult8_Loop: 
8cd5 29			    add hl,hl 
8cd6 30 01		    jr nc,Mult8_NoAdd 
8cd8 19			    add hl,de 
8cd9			Mult8_NoAdd: 
8cd9 10 fa		    djnz Mult8_Loop 
8cdb c9			    ret 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			;;http://z80-heaven.wikidot.com/math 
8cdc			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdc			; 
8cdc			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdc			;     ld a,16        ;7 
8cdc			;     ld hl,0        ;10 
8cdc			;     jp $+5         ;10 
8cdc			;.DivLoop: 
8cdc			;       add hl,bc    ;-- 
8cdc			;       dec a        ;64 
8cdc			;       jr z,.DivLoopEnd        ;86 
8cdc			; 
8cdc			;       sla e        ;128 
8cdc			;       rl d         ;128 
8cdc			;       adc hl,hl    ;240 
8cdc			;       sbc hl,bc    ;240 
8cdc			;       jr nc,.DivLoop ;23|21 
8cdc			;       inc e        ;-- 
8cdc			;       jp .DivLoop+1 
8cdc			; 
8cdc			;.DivLoopEnd: 
8cdc			 
8cdc			;HL_Div_C: 
8cdc			;Inputs: 
8cdc			;     HL is the numerator 
8cdc			;     C is the denominator 
8cdc			;Outputs: 
8cdc			;     A is the remainder 
8cdc			;     B is 0 
8cdc			;     C is not changed 
8cdc			;     DE is not changed 
8cdc			;     HL is the quotient 
8cdc			; 
8cdc			;       ld b,16 
8cdc			;       xor a 
8cdc			;         add hl,hl 
8cdc			;         rla 
8cdc			;         cp c 
8cdc			;         jr c,$+4 
8cdc			;           inc l 
8cdc			;           sub c 
8cdc			;         djnz $-7 
8cdc			 
8cdc			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdc			 
8cdc			addatohl: 
8cdc 85			    add   a, l    ; A = A+L 
8cdd 6f			    ld    l, a    ; L = A+L 
8cde 8c			    adc   a, h    ; A = A+L+H+carry 
8cdf 95			    sub   l       ; A = H+carry 
8ce0 67			    ld    h, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			addatode: 
8ce2 83			    add   a, e    ; A = A+L 
8ce3 5f			    ld    e, a    ; L = A+L 
8ce4 8a			    adc   a, d    ; A = A+L+H+carry 
8ce5 93			    sub   e       ; A = H+carry 
8ce6 57			    ld    d, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			 
8ce8			addatobc: 
8ce8 81			    add   a, c    ; A = A+L 
8ce9 4f			    ld    c, a    ; L = A+L 
8cea 88			    adc   a, b    ; A = A+L+H+carry 
8ceb 91			    sub   c       ; A = H+carry 
8cec 47			    ld    b, a    ; H = H+carry 
8ced c9			ret 
8cee			 
8cee			subafromhl: 
8cee			   ; If A=0 do nothing 
8cee			    ; Otherwise flip A's sign. Since 
8cee			    ; the upper byte becomes -1, also 
8cee			    ; substract 1 from H. 
8cee ed 44		    neg 
8cf0 ca f9 8c		    jp    z, Skip 
8cf3 25			    dec   h 
8cf4			     
8cf4			    ; Now add the low byte as usual 
8cf4			    ; Two's complement takes care of 
8cf4			    ; ensuring the result is correct 
8cf4 85			    add   a, l 
8cf5 6f			    ld    l, a 
8cf6 8c			    adc   a, h 
8cf7 95			    sub   l 
8cf8 67			    ld    h, a 
8cf9			Skip: 
8cf9 c9				ret 
8cfa			 
8cfa			 
8cfa			; compare hl and de 
8cfa			; returns:  
8cfa			; if hl = de, z=1, s=0, c0=0 
8cfa			; if hl > de, z=0, s=0, c=0 
8cfa			; if hl < de, z=0, s=1, c=1 
8cfa			cmp16:	 
8cfa b7				or a 
8cfb ed 52			sbc hl,de 
8cfd e0				ret po 
8cfe 7c				ld a,h 
8cff 1f				rra 
8d00 ee 40			xor 01000000B 
8d02 37				scf 
8d03 8f				adc a,a 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; test if hl contains zero   - A is destroyed 
8d05			 
8d05			ishlzero:    
8d05 b7				or a     ; reset flags 
8d06 7c				ld a, h 
8d07 b5				or l        	 
8d08			 
8d08 c9				ret 
8d09			 
8d09			 
8d09			 
8d09			 
8d09			if FORTH_ENABLE_FLOATMATH 
8d09			;include "float/bbcmath.z80" 
8d09			include "float/lpfpcalc.asm" 
8d09			endif 
8d09			 
8d09			 
8d09			; eof 
8d09			 
# End of file firmware_maths.asm
8d09			include "firmware_strings.asm"   ; string handling  
8d09			 
8d09			 
8d09			; TODO string len 
8d09			; input text string, end on cr with zero term 
8d09			; a offset into frame buffer to start prompt 
8d09			; d is max length 
8d09			; e is display size TODO 
8d09			; c is current cursor position 
8d09			; hl is ptr to where string will be stored 
8d09			 
8d09			 
8d09			; TODO check limit of buffer for new inserts 
8d09			; TODO check insert does not push beyond buffer 
8d09			; TODO scroll in a limited display area 
8d09			; TODO scroll whole screen on page wrap 
8d09			 
8d09			 
8d09			; TODO handle KEY_PREVWORD 
8d09			; TODO handle KEY_NEXTWORD 
8d09			; TODO handle KEY_HOME 
8d09			; TODO handle KEY_END 
8d09			; TODO use LCD cursor? 
8d09			 
8d09 32 67 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0c 81					add c 
8d0d 32 65 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d10 22 6a ee				ld (input_start), hl     ; save ptr to buffer 
8d13 79					ld a, c 
8d14 cd dc 8c				call addatohl 
8d17 22 6c ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 69 ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 58 ee				ld (input_cursor),a      ; init cursor start position  
8d22 7b					ld a,e 
8d23 32 68 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26					 
8d26					 
8d26			 
8d26			;		ld a,(input_ptr) 
8d26			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c4 eb				ld hl, cursor_shape 
8d29 3e ff				ld a, 255 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 0f				ld a, CUR_BLINK_RATE 
8d32 32 63 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 62 ee				ld (input_cur_onoff),a 
8d3a			 
8d3a			;	if DEBUG_INPUT 
8d3a			;		push af 
8d3a			;		ld a, 'I' 
8d3a			;		ld (debug_mark),a 
8d3a			;		pop af 
8d3a			;		CALLMONITOR 
8d3a			;	endif 
8d3a			.is1:		; main entry loop 
8d3a			 
8d3a			 
8d3a			 
8d3a					; pause 1ms 
8d3a			 
8d3a 3e 01				ld a, 1 
8d3c cd d7 89				call aDelayInMS 
8d3f			 
8d3f					; dec flash counter 
8d3f 3a 63 ee				ld a, (input_cur_flash) 
8d42 3d					dec a 
8d43 32 63 ee				ld (input_cur_flash), a 
8d46 fe 00				cp 0 
8d48 20 0d				jr nz, .nochgstate 
8d4a			 
8d4a			 
8d4a					; change state 
8d4a 3a 62 ee				ld a,(input_cur_onoff) 
8d4d ed 44				neg 
8d4f 32 62 ee				ld (input_cur_onoff),a 
8d52			 
8d52			 
8d52					; reset on change of state 
8d52 3e 0f				ld a, CUR_BLINK_RATE 
8d54 32 63 ee				ld (input_cur_flash), a 
8d57			 
8d57			.nochgstate: 
8d57					 
8d57					 
8d57			 
8d57					; display cursor  
8d57			 
8d57			;		ld hl, (input_start) 
8d57			;		ld a, (input_cursor) 
8d57			;		call addatohl 
8d57			 
8d57					; get char under cursor and replace with cursor 
8d57 2a 6c ee		ld hl, (input_ptr) 
8d5a			;		ld a, (hl) 
8d5a			;		ld (input_under_cursor),a 
8d5a			;		ld a, '_' 
8d5a			;		ld (hl), a 
8d5a			 
8d5a					; display string 
8d5a			 
8d5a ed 5b 6a ee			ld de, (input_start) 
8d5e 3a 67 ee				ld a, (input_at_pos) 
8d61 cd c2 8a				call str_at_display 
8d64			;	        call update_display 
8d64			 
8d64					; find place to put the cursor 
8d64			;		add h 
8d64			;		ld l, display_row_1 
8d64			;		sub l 
8d64			; (input_at_pos) 
8d64					;ld c, a 
8d64			;		ld a, (input_cursor) 
8d64			;		ld l, (input_at_pos) 
8d64			;		;ld b, h 
8d64			;		add l 
8d64			;		ld (input_at_cursor),a 
8d64					;ld l,h 
8d64			 
8d64			;		ld h, 0 
8d64			;		ld l,(input_at_pos) 
8d64			;		ld a, (input_cursor) 
8d64			;		call addatohl 
8d64			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d64			;		call subafromhl 
8d64			;		ld a,l 
8d64			;		ld (input_at_cursor), a 
8d64			 
8d64				if DEBUG_INPUT 
8d64					ld a, (hardware_diag) 
8d64					cp 0 
8d64					jr z, .skip_input_diag 
8d64			 
8d64					ld a,(input_at_pos) 
8d64					ld hl, LFSRSeed 
8d64					call hexout 
8d64					ld a, (input_cursor) 
8d64					ld hl, LFSRSeed+2 
8d64					call hexout 
8d64					ld a,(input_at_cursor) 
8d64					ld hl, LFSRSeed+4 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_onoff) 
8d64					ld hl, LFSRSeed+6 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_flash) 
8d64					ld hl, LFSRSeed+8 
8d64					call hexout 
8d64			 
8d64					ld a,(input_len) 
8d64					ld hl, LFSRSeed+10 
8d64					call hexout 
8d64					ld hl, LFSRSeed+12 
8d64					ld a, 0 
8d64					ld (hl),a 
8d64					ld a, display_row_4 
8d64					ld de, LFSRSeed 
8d64					call str_at_display 
8d64					.skip_input_diag: 
8d64				endif 
8d64			 
8d64					; decide on if we are showing the cursor this time round 
8d64			 
8d64 3a 62 ee				ld a, (input_cur_onoff) 
8d67 fe ff				cp 255 
8d69 28 13				jr z, .skipcur 
8d6b			 
8d6b			 
8d6b 3a 65 ee				ld a,(input_at_cursor) 
8d6e 11 c4 eb				ld de, cursor_shape 
8d71 cd c2 8a				call str_at_display 
8d74			 
8d74					; save length of current input string 
8d74 2a 6a ee				ld hl, (input_start) 
8d77 cd 3a 91				call strlenz 
8d7a 7d					ld a,l 
8d7b 32 5d ee				ld (input_len),a 
8d7e			 
8d7e			.skipcur: 
8d7e			 
8d7e cd d2 8a			        call update_display 
8d81					 
8d81			 
8d81			 
8d81					; wait 
8d81				 
8d81					; TODO loop without wait to flash the cursor and char under cursor	 
8d81 cd 3c e3				call cin    ; _wait 
8d84			 
8d84 fe 00				cp 0 
8d86 ca 3a 8d				jp z, .is1 
8d89			 
8d89					; get ptr to char to input into 
8d89			 
8d89 4f					ld c,a 
8d8a 2a 6a ee				ld hl, (input_start) 
8d8d 3a 58 ee				ld a, (input_cursor) 
8d90 cd dc 8c				call addatohl 
8d93 22 6c ee				ld (input_ptr), hl 
8d96 79					ld a,c 
8d97			 
8d97					; replace char under cursor 
8d97			 
8d97			;		ld hl, (input_ptr) 
8d97			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d97			;		ld (hl), a 
8d97			 
8d97			;	if DEBUG_INPUT 
8d97			;		push af 
8d97			;		ld a, 'i' 
8d97			;		ld (debug_mark),a 
8d97			;		pop af 
8d97			;		CALLMONITOR 
8d97			;	endif 
8d97 fe 0e				cp KEY_HOME 
8d99 20 0e				jr nz, .iske 
8d9b			 
8d9b 3a 67 ee				ld a, (input_at_pos) 
8d9e 32 65 ee				ld (input_at_cursor),a 
8da1 3e 00				ld a, 0 
8da3 32 58 ee				ld (input_cursor), a 
8da6 c3 3a 8d				jp .is1 
8da9					 
8da9 fe 0f		.iske:		cp KEY_END 
8dab 20 03				jr nz, .isknw 
8dad c3 3a 8d				jp .is1 
8db0			 
8db0 fe 06		.isknw:		cp KEY_NEXTWORD 
8db2 20 1b				jr nz, .iskpw 
8db4			 
8db4 2a 6c ee		.isknwm:	ld hl, (input_ptr) 
8db7 7e					ld a,(hl)	 
8db8 fe 00				cp 0 
8dba ca 3a 8d				jp z, .is1    ; end of string 
8dbd fe 20				cp ' ' 
8dbf ca 3a 8d				jp z, .is1    ; end of word 
8dc2 23					inc hl 
8dc3 22 6c ee				ld (input_ptr), hl 
8dc6 3a 65 ee				ld a, (input_at_cursor) 
8dc9 3c					inc a 
8dca 32 65 ee				ld (input_at_cursor), a 
8dcd 18 e5				jr .isknwm 
8dcf			 
8dcf fe 07		.iskpw:		cp KEY_PREVWORD 
8dd1 20 1b				jr nz, .iskl 
8dd3			.iskpwm:	 
8dd3 2a 6c ee				ld hl, (input_ptr) 
8dd6 7e					ld a,(hl)	 
8dd7 fe 00				cp 0  
8dd9 ca 3a 8d				jp z, .is1    ; end of string 
8ddc fe 20				cp ' ' 
8dde ca 3a 8d				jp z, .is1    ; end of word 
8de1 2b					dec hl 
8de2 22 6c ee				ld (input_ptr), hl 
8de5 3a 65 ee				ld a, (input_at_cursor) 
8de8 3d					dec a 
8de9 32 65 ee				ld (input_at_cursor), a 
8dec 18 e5				jr .iskpwm 
8dee			 
8dee			 
8dee fe 0b		.iskl:		cp KEY_LEFT 
8df0 20 27				jr nz, .isk1 
8df2			 
8df2 3a 58 ee				ld a, (input_cursor) 
8df5			 
8df5 fe 00				cp 0 
8df7 ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8dfa			 
8dfa 3d					dec  a 		; TODO check underflow 
8dfb 32 58 ee				ld (input_cursor), a 
8dfe			 
8dfe 2a 6c ee				ld hl, (input_ptr) 
8e01 2b					dec hl 
8e02 22 6c ee				ld (input_ptr), hl 
8e05					 
8e05 3a 65 ee				ld a, (input_at_cursor) 
8e08 3d					dec a 
8e09 32 65 ee				ld (input_at_cursor), a 
8e0c			 
8e0c 3e 01				ld a, 1		; show cursor moving 
8e0e 32 62 ee				ld (input_cur_onoff),a 
8e11 3e 0f				ld a, CUR_BLINK_RATE 
8e13 32 63 ee				ld (input_cur_flash), a 
8e16			 
8e16 c3 3a 8d				jp .is1 
8e19			 
8e19 fe 0c		.isk1:		cp KEY_RIGHT 
8e1b 20 2a				jr nz, .isk2 
8e1d			 
8e1d 3a 5d ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e20 5f					ld e,a 
8e21 3a 58 ee				ld a, (input_cursor) 
8e24 bb					cp e 
8e25 ca 3a 8d				jp z, .is1		; at the end of string so dont go right 
8e28			 
8e28 3c					inc  a 		; TODO check overflow 
8e29 32 58 ee				ld (input_cursor), a 
8e2c			 
8e2c 3a 65 ee				ld a, (input_at_cursor) 
8e2f 3c					inc a 
8e30 32 65 ee				ld (input_at_cursor), a 
8e33			 
8e33 2a 6c ee				ld hl, (input_ptr) 
8e36 23					inc hl 
8e37 22 6c ee				ld (input_ptr), hl 
8e3a			 
8e3a 3e 01				ld a, 1		; show cursor moving 
8e3c 32 62 ee				ld (input_cur_onoff),a 
8e3f 3e 0f				ld a, CUR_BLINK_RATE 
8e41 32 63 ee				ld (input_cur_flash), a 
8e44			 
8e44 c3 3a 8d				jp .is1 
8e47			 
8e47 fe 05		.isk2:		cp KEY_UP 
8e49			 
8e49 20 26				jr nz, .isk3 
8e4b			 
8e4b					; swap last command with the current on 
8e4b			 
8e4b					; move cursor to start of string 
8e4b 2a 6a ee				ld hl, (input_start) 
8e4e 22 6c ee				ld (input_ptr), hl 
8e51			 
8e51 3a 67 ee				ld a, (input_at_pos) 
8e54 32 65 ee				ld (input_at_cursor), a 
8e57			 
8e57 3e 00				ld a, 0 
8e59 32 58 ee				ld (input_cursor), a 
8e5c					 
8e5c					; swap input and last command buffers 
8e5c			 
8e5c 21 eb e5				ld hl, os_cli_cmd 
8e5f 11 ea e6				ld de, os_last_cmd 
8e62 06 ff				ld b, 255 
8e64 7e			.swap1:		ld a, (hl) 
8e65 4f					ld c,a 
8e66 1a					ld a, (de) 
8e67 77					ld (hl), a 
8e68 79					ld a,c 
8e69 12					ld (de),a 
8e6a 23					inc hl 
8e6b 13					inc de 
8e6c 10 f6				djnz .swap1 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e c3 3a 8d				jp .is1 
8e71			 
8e71 fe 08		.isk3:		cp KEY_BS 
8e73 20 3c				jr nz, .isk4 
8e75			 
8e75 3a 58 ee				ld a, (input_cursor) 
8e78			 
8e78 fe 00				cp 0 
8e7a ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8e7d			 
8e7d 3d					dec  a 		; TODO check underflow 
8e7e 32 58 ee				ld (input_cursor), a 
8e81			 
8e81					; hl is source 
8e81					; de needs to be source - 1 
8e81			 
8e81			;		ld a, 0 
8e81			;		dec hl 
8e81			;		ld (hl), a 
8e81			 
8e81 2a 6c ee				ld hl, (input_ptr) 
8e84 2b					dec hl 
8e85 22 6c ee				ld (input_ptr), hl 
8e88			 
8e88					; shift all data 
8e88			 
8e88 e5					push hl 
8e89 23					inc hl 
8e8a d1					pop de 
8e8b 3a 5d ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8e 4f					ld c,a 
8e8f 06 00				ld b,0 
8e91 ed b0				ldir  
8e93			 
8e93			 
8e93			 
8e93			 
8e93 3a 65 ee				ld a, (input_at_cursor) 
8e96 3d					dec a 
8e97 32 65 ee				ld (input_at_cursor), a 
8e9a			 
8e9a			 
8e9a 3e 01				ld a, 1		; show cursor moving 
8e9c 32 62 ee				ld (input_cur_onoff),a 
8e9f 3e 0f				ld a, CUR_BLINK_RATE 
8ea1 32 63 ee				ld (input_cur_flash), a 
8ea4			 
8ea4					; remove char 
8ea4 3a 65 ee				ld a, (input_at_cursor) 
8ea7 3c					inc a 
8ea8 11 32 8f				ld de,.iblank 
8eab cd c2 8a				call str_at_display 
8eae			 
8eae c3 3a 8d				jp .is1 
8eb1			 
8eb1 fe 0d		.isk4:		cp KEY_CR 
8eb3 28 6c				jr z, .endinput 
8eb5			 
8eb5					; else add the key press to the end 
8eb5			 
8eb5 4f					ld c, a			; save key pressed 
8eb6			 
8eb6 7e					ld a,(hl)		; get what is currently under char 
8eb7			 
8eb7 fe 00				cp 0			; we are at the end of the string 
8eb9 20 2f				jr nz, .onchar 
8ebb					 
8ebb					; add a char to the end of the string 
8ebb				 
8ebb 71					ld (hl),c 
8ebc 23					inc hl 
8ebd			;		ld a,' ' 
8ebd			;		ld (hl),a 
8ebd			;		inc hl 
8ebd 3e 00				ld a,0 
8ebf 77					ld (hl),a 
8ec0 2b					dec hl 
8ec1			 
8ec1 3a 58 ee				ld a, (input_cursor) 
8ec4 3c					inc a				; TODO check max string length and scroll  
8ec5 32 58 ee				ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8 3a 65 ee				ld a, (input_at_cursor) 
8ecb 3c					inc a 
8ecc 32 65 ee				ld (input_at_cursor), a 
8ecf			 
8ecf 2a 6c ee				ld hl, (input_ptr) 
8ed2 23					inc hl 
8ed3 22 6c ee				ld (input_ptr), hl 
8ed6			 
8ed6 2a 6c ee				ld hl, (input_ptr) 
8ed9 23					inc hl 
8eda 22 6c ee				ld (input_ptr), hl 
8edd			;	if DEBUG_INPUT 
8edd			;		push af 
8edd			;		ld a, '+' 
8edd			;		ld (debug_mark),a 
8edd			;		pop af 
8edd			;		CALLMONITOR 
8edd			;	endif 
8edd 3e 01				ld a, 1		; show cursor moving 
8edf 32 62 ee				ld (input_cur_onoff),a 
8ee2 3e 0f				ld a, CUR_BLINK_RATE 
8ee4 32 63 ee				ld (input_cur_flash), a 
8ee7 c3 3a 8d				jp .is1 
8eea					 
8eea			 
8eea			 
8eea					; if on a char then insert 
8eea			.onchar: 
8eea			 
8eea					; TODO over flow check: make sure insert does not blow out buffer 
8eea			 
8eea					; need to do some maths to use lddr 
8eea			 
8eea e5					push hl   ; save char pos 
8eeb c5					push bc 
8eec			 
8eec 2a 6a ee				ld hl, (input_start) 
8eef 3a 5d ee				ld a, (input_len) 
8ef2 cd dc 8c				call addatohl  		; end of string 
8ef5 23					inc hl 
8ef6 23					inc hl		; past zero term 
8ef7 e5					push hl 
8ef8 23					inc hl 
8ef9 e5					push hl  
8efa			 
8efa								; start and end of lddr set, now how much to move? 
8efa			 
8efa							 
8efa 3a 58 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efd 47					ld b,a 
8efe 3a 5d ee				ld a,(input_len) 
8f01 5f					ld e,a 
8f02 90					sub b 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05 3c					inc a		;?? 
8f06			 
8f06 06 00				ld b,0 
8f08 4f					ld c,a 
8f09			 
8f09				if DEBUG_INPUT 
8f09					push af 
8f09					ld a, 'i' 
8f09					ld (debug_mark),a 
8f09					pop af 
8f09			;		CALLMONITOR 
8f09				endif 
8f09 d1					pop de 
8f0a e1					pop hl 
8f0b				if DEBUG_INPUT 
8f0b					push af 
8f0b					ld a, 'I' 
8f0b					ld (debug_mark),a 
8f0b					pop af 
8f0b			;		CALLMONITOR 
8f0b				endif 
8f0b ed b8				lddr 
8f0d				 
8f0d			 
8f0d			 
8f0d					; TODO have a key for insert/overwrite mode???? 
8f0d c1					pop bc 
8f0e e1					pop hl 
8f0f 71					ld (hl), c		; otherwise overwrite current char 
8f10					 
8f10			 
8f10			 
8f10			 
8f10 3a 58 ee				ld a, (input_cursor) 
8f13 3c					inc  a 		; TODO check overflow 
8f14 32 58 ee				ld (input_cursor), a 
8f17			 
8f17 3a 65 ee				ld a, (input_at_cursor) 
8f1a 3c					inc a 
8f1b 32 65 ee				ld (input_at_cursor), a 
8f1e			 
8f1e c3 3a 8d				jp .is1 
8f21			 
8f21			.endinput:	; TODO look for end of string 
8f21			 
8f21					; add trailing space for end of token 
8f21			 
8f21 2a 6a ee				ld hl, (input_start) 
8f24 3a 5d ee				ld a,(input_len) 
8f27 cd dc 8c				call addatohl 
8f2a 3e 20				ld a, ' ' 
8f2c 77					ld (hl),a 
8f2d					; TODO eof of parse marker 
8f2d			 
8f2d 23					inc hl 
8f2e 3e 00				ld a, 0 
8f30 77					ld (hl),a 
8f31			 
8f31			 
8f31 c9					ret 
8f32			 
8f32 .. 00		.iblank: db " ",0 
8f34			 
8f34			 
8f34 32 67 ee		input_str_prev:	ld (input_at_pos), a 
8f37 22 6a ee				ld (input_start), hl 
8f3a 3e 01				ld a,1			; add cursor 
8f3c 77					ld (hl),a 
8f3d 23					inc hl 
8f3e 3e 00				ld a,0 
8f40 77					ld (hl),a 
8f41 22 6c ee				ld (input_ptr), hl 
8f44 7a					ld a,d 
8f45 32 69 ee				ld (input_size), a 
8f48 3e 00				ld a,0 
8f4a 32 58 ee				ld (input_cursor),a 
8f4d			.instr1:	 
8f4d			 
8f4d					; TODO do block cursor 
8f4d					; TODO switch cursor depending on the modifer key 
8f4d			 
8f4d					; update cursor shape change on key hold 
8f4d			 
8f4d 2a 6c ee				ld hl, (input_ptr) 
8f50 2b					dec hl 
8f51 3a c4 eb				ld a,(cursor_shape) 
8f54 77					ld (hl), a 
8f55			 
8f55					; display entered text 
8f55 3a 67 ee				ld a,(input_at_pos) 
8f58 cd 9a e2		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5b ed 5b 6a ee	            	LD   de, (input_start) 
8f5f cd 94 e2		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f62			 
8f62 cd 3c e3				call cin 
8f65 fe 00				cp 0 
8f67 28 e4				jr z, .instr1 
8f69			 
8f69					; proecess keyboard controls first 
8f69			 
8f69 2a 6c ee				ld hl,(input_ptr) 
8f6c			 
8f6c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6e 28 5a				jr z, .instrcr 
8f70			 
8f70 fe 08				cp KEY_BS 	; back space 
8f72 20 0f				jr nz, .instr2 
8f74					; process back space 
8f74			 
8f74					; TODO stop back space if at start of string 
8f74 2b					dec hl 
8f75 2b					dec hl ; to over write cursor 
8f76 3a c4 eb				ld a,(cursor_shape) 
8f79					;ld a,0 
8f79 77					ld (hl),a 
8f7a 23					inc hl 
8f7b 3e 20				ld a," " 
8f7d 77					ld (hl),a 
8f7e 22 6c ee				ld (input_ptr),hl 
8f81					 
8f81			 
8f81 18 ca				jr .instr1 
8f83			 
8f83 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f85 20 06				jr nz, .instr3 
8f87 2b					dec hl 
8f88 22 6c ee				ld (input_ptr),hl 
8f8b 18 c0				jr .instr1 
8f8d				 
8f8d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8f 20 06				jr nz, .instr4 
8f91 23					inc hl 
8f92 22 6c ee				ld (input_ptr),hl 
8f95 18 b6				jr .instr1 
8f97			 
8f97 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f99 20 06				jr nz, .instr5 
8f9b 2b					dec hl 
8f9c 22 6c ee				ld (input_ptr),hl 
8f9f 18 ac				jr .instr1 
8fa1			 
8fa1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa3 20 06				jr nz, .instr6 
8fa5 2b					dec hl 
8fa6 22 6c ee				ld (input_ptr),hl 
8fa9 18 a2				jr .instr1 
8fab fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fad 20 0b				jr nz, .instrnew 
8faf			 
8faf 21 c4 e2			ld hl, scratch 
8fb2 11 ea e6			ld de, os_last_cmd 
8fb5 cd d3 8f			call strcpy 
8fb8 18 93				jr .instr1 
8fba			 
8fba			 
8fba			.instrnew:	; no special key pressed to see if we have room to store it 
8fba			 
8fba					; TODO do string size test 
8fba			 
8fba 2b					dec hl ; to over write cursor 
8fbb 77					ld (hl),a 
8fbc 23					inc hl 
8fbd 3a c4 eb				ld a,(cursor_shape) 
8fc0 77					ld (hl),a 
8fc1 23					inc hl 
8fc2 3e 00				ld a,0 
8fc4 77					ld (hl),a 
8fc5			 
8fc5 22 6c ee				ld (input_ptr),hl 
8fc8					 
8fc8 18 83				jr .instr1 
8fca 2b			.instrcr:	dec hl		; remove cursor 
8fcb 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcd 77					ld (hl),a 
8fce 23					inc hl 
8fcf 3e 00				ld a,0 
8fd1 77					ld (hl),a 
8fd2			 
8fd2			 
8fd2					; if at end of line scroll up    
8fd2					; TODO detecting only end of line 4 for scroll up  
8fd2			 
8fd2					;ld   
8fd2			 
8fd2 c9					ret 
8fd3			 
8fd3			 
8fd3			; strcpy hl = dest, de source 
8fd3			 
8fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd4 b7			            OR   A              ;Null terminator? 
8fd5 c8			            RET  Z              ;Yes, so finished 
8fd6 1a					ld a,(de) 
8fd7 77					ld (hl),a 
8fd8 13			            INC  DE             ;Point to next character 
8fd9 23					inc hl 
8fda 18 f7		            JR   strcpy       ;Repeat 
8fdc c9					ret 
8fdd			 
8fdd			 
8fdd			; TODO string_at  
8fdd			; pass string which starts with lcd offset address and then null term string 
8fdd			 
8fdd			; TODO string to dec 
8fdd			; TODO string to hex 
8fdd			; TODO byte to string hex 
8fdd			; TODO byte to string dec 
8fdd			 
8fdd			 
8fdd			 
8fdd			; from z80uartmonitor 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdd			; pass hl for where to put the text 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd c5			hexout:	PUSH BC 
8fde f5					PUSH AF 
8fdf 47					LD B, A 
8fe0					; Upper nybble 
8fe0 cb 3f				SRL A 
8fe2 cb 3f				SRL A 
8fe4 cb 3f				SRL A 
8fe6 cb 3f				SRL A 
8fe8 cd f8 8f				CALL tohex 
8feb 77					ld (hl),a 
8fec 23					inc hl	 
8fed					 
8fed					; Lower nybble 
8fed 78					LD A, B 
8fee e6 0f				AND 0FH 
8ff0 cd f8 8f				CALL tohex 
8ff3 77					ld (hl),a 
8ff4 23					inc hl	 
8ff5					 
8ff5 f1					POP AF 
8ff6 c1					POP BC 
8ff7 c9					RET 
8ff8					 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			tohex: 
8ff8 e5					PUSH HL 
8ff9 d5					PUSH DE 
8ffa 16 00				LD D, 0 
8ffc 5f					LD E, A 
8ffd 21 05 90				LD HL, .DATA 
9000 19					ADD HL, DE 
9001 7e					LD A, (HL) 
9002 d1					POP DE 
9003 e1					POP HL 
9004 c9					RET 
9005			 
9005			.DATA: 
9005 30					DEFB	30h	; 0 
9006 31					DEFB	31h	; 1 
9007 32					DEFB	32h	; 2 
9008 33					DEFB	33h	; 3 
9009 34					DEFB	34h	; 4 
900a 35					DEFB	35h	; 5 
900b 36					DEFB	36h	; 6 
900c 37					DEFB	37h	; 7 
900d 38					DEFB	38h	; 8 
900e 39					DEFB	39h	; 9 
900f 41					DEFB	41h	; A 
9010 42					DEFB	42h	; B 
9011 43					DEFB	43h	; C 
9012 44					DEFB	44h	; D 
9013 45					DEFB	45h	; E 
9014 46					DEFB	46h	; F 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9015			;;    subtract $30, if result > 9 then subtract $7 more 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			atohex: 
9015 d6 30				SUB $30 
9017 fe 0a				CP 10 
9019 f8					RET M		; If result negative it was 0-9 so we're done 
901a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901c c9					RET		 
901d			 
901d			 
901d			 
901d			 
901d			; Get 2 ASCII characters as hex byte from pointer in hl 
901d			 
901d			BYTERD: 
901d 16 00			LD	D,00h		;Set up 
901f cd 27 90			CALL	HEXCON		;Get byte and convert to hex 
9022 87				ADD	A,A		;First nibble so 
9023 87				ADD	A,A		;multiply by 16 
9024 87				ADD	A,A		; 
9025 87				ADD	A,A		; 
9026 57				LD	D,A		;Save hi nibble in D 
9027			HEXCON: 
9027 7e				ld a, (hl)		;Get next chr 
9028 23				inc hl 
9029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902b fe 0a			CP	00Ah		;Is it 0-9 ? 
902d 38 02			JR	C,NALPHA	;If so miss next bit 
902f d6 07			SUB	007h		;Else convert alpha 
9031			NALPHA: 
9031 b2				OR	D		;Add hi nibble back 
9032 c9				RET			; 
9033			 
9033			 
9033			; 
9033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9033			; Since the routines get_byte and therefore get_nibble are called, only valid 
9033			; characters (0-9a-f) are accepted. 
9033			; 
9033			;get_word        push    af 
9033			;                call    get_byte        ; Get the upper byte 
9033			;                ld      h, a 
9033			;                call    get_byte        ; Get the lower byte 
9033			;                ld      l, a 
9033			;                pop     af 
9033			;                ret 
9033			; 
9033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9033			; the routine get_nibble is used only valid characters are accepted - the  
9033			; input routine only accepts characters 0-9a-f. 
9033			; 
9033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9034 7e					ld a,(hl) 
9035 23					inc hl 
9036 cd 5b 90		                call    nibble2val      ; Get upper nibble 
9039 cb 07		                rlc     a 
903b cb 07		                rlc     a 
903d cb 07		                rlc     a 
903f cb 07		                rlc     a 
9041 47			                ld      b, a            ; Save upper four bits 
9042 7e					ld a,(hl) 
9043 cd 5b 90		                call    nibble2val      ; Get lower nibble 
9046 b0			                or      b               ; Combine both nibbles 
9047 c1			                pop     bc              ; Restore B (and C) 
9048 c9			                ret 
9049			; 
9049			; Get a hexadecimal digit from the serial line. This routine blocks until 
9049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9049			; to the serial line interface. The lower 4 bits of A contain the value of  
9049			; that particular digit. 
9049			; 
9049			;get_nibble      ld a,(hl)           ; Read a character 
9049			;                call    to_upper        ; Convert to upper case 
9049			;                call    is_hex          ; Was it a hex digit? 
9049			;                jr      nc, get_nibble  ; No, get another character 
9049			 ;               call    nibble2val      ; Convert nibble to value 
9049			 ;               call    print_nibble 
9049			 ;               ret 
9049			; 
9049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9049			; A valid hexadecimal digit is denoted by a set C flag. 
9049			; 
9049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9049			;                ret     nc              ; Yes 
9049			;                cp      '0'             ; Less than '0'? 
9049			;                jr      nc, is_hex_1    ; No, continue 
9049			;                ccf                     ; Complement carry (i.e. clear it) 
9049			;                ret 
9049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9049			;                ret     c               ; Yes 
9049			;                cp      'A'             ; Less than 'A'? 
9049			;                jr      nc, is_hex_2    ; No, continue 
9049			;                ccf                     ; Yes - clear carry and return 
9049			;                ret 
9049			;is_hex_2        scf                     ; Set carry 
9049			;                ret 
9049			; 
9049			; Convert a single character contained in A to upper case: 
9049			; 
9049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904b d8			                ret     c 
904c fe 7b		                cp      'z' + 1         ; > 'z'? 
904e d0			                ret     nc              ; Nothing to do, either 
904f e6 5f		                and     $5f             ; Convert to upper case 
9051 c9			                ret 
9052			 
9052			 
9052			to_lower: 
9052			 
9052			   ; if char is in [A-Z] make it lower case 
9052			 
9052			   ; enter : a = char 
9052			   ; exit  : a = lower case char 
9052			   ; uses  : af 
9052			 
9052 fe 41		   cp 'A' 
9054 d8			   ret c 
9055			    
9055 fe 5b		   cp 'Z'+1 
9057 d0			   ret nc 
9058			    
9058 f6 20		   or $20 
905a c9			   ret 
905b			 
905b			; 
905b			; Expects a hexadecimal digit (upper case!) in A and returns the 
905b			; corresponding value in A. 
905b			; 
905b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905d 38 02		                jr      c, nibble2val_1 ; Yes 
905f d6 07		                sub     7               ; Adjust for A-F 
9061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9063 e6 0f		                and     $f              ; Only return lower 4 bits 
9065 c9			                ret 
9066			; 
9066			; Print_nibble prints a single hex nibble which is contained in the lower  
9066			; four bits of A: 
9066			; 
9066			;print_nibble    push    af              ; We won't destroy the contents of A 
9066			;                and     $f              ; Just in case... 
9066			;                add     a, '0'             ; If we have a digit we are done here. 
9066			;                cp      '9' + 1         ; Is the result > 9? 
9066			;                jr      c, print_nibble_1 
9066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9066			;print_nibble_1  call    putc            ; Print the nibble and 
9066			;                pop     af              ; restore the original value of A 
9066			;                ret 
9066			;; 
9066			;; Send a CR/LF pair: 
9066			; 
9066			;crlf            push    af 
9066			;                ld      a, cr 
9066			;                call    putc 
9066			;                ld      a, lf 
9066			;                call    putc 
9066			;                pop     af 
9066			;                ret 
9066			; 
9066			; Print_word prints the four hex digits of a word to the serial line. The  
9066			; word is expected to be in HL. 
9066			; 
9066			;print_word      push    hl 
9066			;                push    af 
9066			;                ld      a, h 
9066			;                call    print_byte 
9066			;                ld      a, l 
9066			;                call    print_byte 
9066			;                pop     af 
9066			;                pop     hl 
9066			;                ret 
9066			; 
9066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9066			; The byte to be printed is expected to be in A. 
9066			; 
9066			;print_byte      push    af              ; Save the contents of the registers 
9066			;                push    bc 
9066			;                ld      b, a 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                call    print_nibble    ; Print high nibble 
9066			;                ld      a, b 
9066			;                call    print_nibble    ; Print low nibble 
9066			;                pop     bc              ; Restore original register contents 
9066			;                pop     af 
9066			;                ret 
9066			 
9066			 
9066			 
9066			 
9066			 
9066			fourehexhl:  
9066 7e				ld a,(hl) 
9067 cd 15 90			call atohex 
906a cb 3f				SRL A 
906c cb 3f				SRL A 
906e cb 3f				SRL A 
9070 cb 3f				SRL A 
9072 47				ld b, a 
9073 23				inc hl 
9074 7e				ld a,(hl) 
9075 23				inc hl 
9076 cd 15 90			call atohex 
9079 80				add b 
907a 57				ld d,a 
907b 7e				ld a,(hl) 
907c cd 15 90			call atohex 
907f cb 3f				SRL A 
9081 cb 3f				SRL A 
9083 cb 3f				SRL A 
9085 cb 3f				SRL A 
9087 47				ld b, a 
9088 23				inc hl 
9089 7e				ld a,(hl) 
908a 23				inc hl 
908b cd 15 90			call atohex 
908e 80				add b 
908f 5f				ld e, a 
9090 d5				push de 
9091 e1				pop hl 
9092 c9				ret 
9093			 
9093			; pass hl. returns z set if the byte at hl is a digit 
9093			;isdigithl:  
9093			;	push bc 
9093			;	ld a,(hl) 
9093			;	cp ':' 
9093			;	jr nc, .isdf 		; > 
9093			;	cp '0' 
9093			;	jr c, .isdf		; < 
9093			; 
9093			;	; TODO find a better way to set z 
9093			; 
9093			;	ld b,a 
9093			;	cp b 
9093			;	pop bc 
9093			;	ret 
9093			; 
9093			;.isdf:	; not digit so clear z 
9093			; 
9093			;	; TODO find a better way to unset z 
9093			; 
9093			;	ld b,a 
9093			;	inc b 
9093			;	cp b 
9093			; 
9093			;	pop bc 
9093			;	ret 
9093				 
9093				 
9093			 
9093			 
9093			; pass hl as the four byte address to load 
9093			 
9093			get_word_hl:  
9093 e5				push hl 
9094 cd 33 90			call get_byte 
9097				 
9097 47				ld b, a 
9098			 
9098 e1				pop hl 
9099 23				inc hl 
909a 23				inc hl 
909b			 
909b			; TODO not able to handle a-f  
909b 7e				ld a,(hl) 
909c			;	;cp ':' 
909c			;	cp 'g' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp 'G' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp '0' 
909c			;	jr c, .single_byte_hl		; < 
909c			 
909c				;call isdigithl 
909c fe 00			cp 0 
909e 28 06			jr z, .single_byte_hl 
90a0			 
90a0			.getwhln:   ; hex word so get next byte 
90a0			 
90a0 cd 33 90			call get_byte 
90a3 6f				ld l, a 
90a4 60				ld h,b 
90a5 c9				ret 
90a6 68			.single_byte_hl:   ld l,b 
90a7 26 00				ld h,0 
90a9 c9					ret 
90aa			 
90aa			 
90aa			 
90aa			 
90aa 21 38 98			ld hl,asc+1 
90ad			;	ld a, (hl) 
90ad			;	call nibble2val 
90ad cd 33 90			call get_byte 
90b0			 
90b0			;	call fourehexhl 
90b0 32 f8 e2			ld (scratch+52),a 
90b3				 
90b3 21 f6 e2			ld hl,scratch+50 
90b6 22 e7 e5			ld (os_cur_ptr),hl 
90b9			 
90b9 c9				ret 
90ba			 
90ba			 
90ba			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90ba			 
90ba			; Decimal Unsigned Version 
90ba			 
90ba			;Number in a to decimal ASCII 
90ba			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90ba			;Example: display a=56 as "056" 
90ba			;input: a = number 
90ba			;Output: a=0,value of a in the screen 
90ba			;destroys af,bc (don't know about hl and de) 
90ba			DispAToASCII: 
90ba 0e 9c			ld	c,-100 
90bc cd c6 90			call	.Na1 
90bf 0e f6			ld	c,-10 
90c1 cd c6 90			call	.Na1 
90c4 0e ff			ld	c,-1 
90c6 06 2f		.Na1:	ld	b,'0'-1 
90c8 04			.Na2:	inc	b 
90c9 81				add	a,c 
90ca 38 fc			jr	c,.Na2 
90cc 91				sub	c		;works as add 100/10/1 
90cd f5				push af		;safer than ld c,a 
90ce 78				ld	a,b		;char is in b 
90cf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90cf f1				pop af		;safer than ld a,c 
90d0 c9				ret 
90d1			 
90d1			; Decimal Signed Version 
90d1			 
90d1			; DispA 
90d1			; -------------------------------------------------------------- 
90d1			; Converts a signed integer value to a zero-terminated ASCII 
90d1			; string representative of that value (using radix 10). 
90d1			; -------------------------------------------------------------- 
90d1			; INPUTS: 
90d1			;     HL     Value to convert (two's complement integer). 
90d1			;     DE     Base address of string destination. (pointer). 
90d1			; -------------------------------------------------------------- 
90d1			; OUTPUTS: 
90d1			;     None 
90d1			; -------------------------------------------------------------- 
90d1			; REGISTERS/MEMORY DESTROYED 
90d1			; AF HL 
90d1			; -------------------------------------------------------------- 
90d1			 
90d1			;DispHLToASCII: 
90d1			;   push    de 
90d1			;   push    bc 
90d1			; 
90d1			;; Detect sign of HL. 
90d1			;    bit    7, h 
90d1			;    jr     z, ._DoConvert 
90d1			; 
90d1			;; HL is negative. Output '-' to string and negate HL. 
90d1			;    ld     a, '-' 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			; 
90d1			;; Negate HL (using two's complement) 
90d1			;    xor    a 
90d1			;    sub    l 
90d1			;    ld     l, a 
90d1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d1			;    sbc    a, h 
90d1			;    ld     h, a 
90d1			; 
90d1			;; Convert HL to digit characters 
90d1			;._DoConvert: 
90d1			;    ld     b, 0     ; B will count character length of number 
90d1			;-   ld     a, 10 
90d1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d1			;    push   af 
90d1			;    inc    b 
90d1			;    ld     a, h 
90d1			;    or     l 
90d1			;    jr     nz, - 
90d1			; 
90d1			;; Retrieve digits from stack 
90d1			;-   pop    af 
90d1			;    or     $30 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			;    djnz   - 
90d1			; 
90d1			;; Terminate string with NULL 
90d1			;    xor    a 
90d1			;    ld     (de), a 
90d1			; 
90d1			;    pop    bc 
90d1			;    pop    de 
90d1			;    ret 
90d1			 
90d1			;Comments 
90d1			; 
90d1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d1			;    Note that the output string will not be fixed-width. 
90d1			; 
90d1			;Example Usage 
90d1			; 
90d1			;    ld    hl, -1004 
90d1			;    ld    de, OP1 
90d1			;    call  DispA 
90d1			;    ld    hl, OP1 
90d1			;    syscall  PutS 
90d1			 
90d1			 
90d1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d1			 
90d1			 
90d1			;Converts an ASCII string to an unsigned 16-bit integer 
90d1			;Quits when it reaches a non-decimal digit 
90d1			 
90d1			string_to_uint16: 
90d1			atoui_16: 
90d1			;Input: 
90d1			;     DE points to the string 
90d1			;Outputs: 
90d1			;     HL is the result 
90d1			;     A is the 8-bit value of the number 
90d1			;     DE points to the byte after the number 
90d1			;Destroys: 
90d1			;     BC 
90d1			;       if the string is non-empty, BC is HL/10 
90d1			;Size:  24 bytes 
90d1			;Speed: 42+d(104+{0,9}) 
90d1			;       d is the number of digits in the number 
90d1			;       max is 640 cycles for a 5 digit number 
90d1			;Assuming no leading zeros: 
90d1			;1 digit:  146cc 
90d1			;2 digit:  250cc 
90d1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d1			;avg: 544.81158447265625cc (544+13297/16384) 
90d1			;=============================================================== 
90d1 21 00 00		  ld hl,0 
90d4			.u16a: 
90d4 1a			  ld a,(de) 
90d5 d6 30		  sub 30h 
90d7 fe 0a		  cp 10 
90d9 d0			  ret nc 
90da 13			  inc de 
90db 44			  ld b,h 
90dc 4d			  ld c,l 
90dd 29			  add hl,hl 
90de 29			  add hl,hl 
90df 09			  add hl,bc 
90e0 29			  add hl,hl 
90e1 85			  add a,l 
90e2 6f			  ld l,a 
90e3 30 ef		  jr nc,.u16a 
90e5 24			  inc h 
90e6 c3 d4 90		  jp .u16a 
90e9			 
90e9			 
90e9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e9			 
90e9			;written by Zeda 
90e9			;Converts a 16-bit unsigned integer to an ASCII string. 
90e9			 
90e9			uitoa_16: 
90e9			;Input: 
90e9			;   DE is the number to convert 
90e9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e9			;Output: 
90e9			;   HL points to the null-terminated ASCII string 
90e9			;      NOTE: This isn't necessarily the same as the input HL. 
90e9 d5			  push de 
90ea c5			  push bc 
90eb f5			  push af 
90ec eb			  ex de,hl 
90ed			 
90ed 01 f0 d8		  ld bc,-10000 
90f0 3e 2f		  ld a,'0'-1 
90f2 3c			  inc a 
90f3 09			  add hl,bc  
90f4 38 fc		   jr c,$-2 
90f6 12			  ld (de),a 
90f7 13			  inc de 
90f8			 
90f8 01 e8 03		  ld bc,1000 
90fb 3e 3a		  ld a,'9'+1 
90fd 3d			  dec a  
90fe 09			  add hl,bc  
90ff 30 fc		   jr nc,$-2 
9101 12			  ld (de),a 
9102 13			  inc de 
9103			 
9103 01 9c ff		  ld bc,-100 
9106 3e 2f		  ld a,'0'-1 
9108 3c			  inc a  
9109 09			  add hl,bc  
910a 38 fc		   jr c,$-2 
910c 12			  ld (de),a 
910d 13			  inc de 
910e			 
910e 7d			  ld a,l 
910f 26 3a		  ld h,'9'+1 
9111 25			  dec h  
9112 c6 0a		  add a,10  
9114 30 fb		   jr nc,$-3 
9116 c6 30		  add a,'0' 
9118 eb			  ex de,hl 
9119 72			  ld (hl),d 
911a 23			  inc hl 
911b 77			  ld (hl),a 
911c 23			  inc hl 
911d 36 00		  ld (hl),0 
911f			 
911f			;Now strip the leading zeros 
911f 0e fa		  ld c,-6 
9121 09			  add hl,bc 
9122 3e 30		  ld a,'0' 
9124 23			  inc hl  
9125 be			  cp (hl)  
9126 28 fc		  jr z,$-2 
9128			 
9128			;Make sure that the string is non-empty! 
9128 7e			  ld a,(hl) 
9129 b7			  or a 
912a 20 01		  jr nz,.atoub 
912c 2b			  dec hl 
912d			.atoub: 
912d			 
912d f1			  pop af 
912e c1			  pop bc 
912f d1			  pop de 
9130 c9			  ret 
9131			 
9131			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9131			 
9131			toUpper: 
9131			;A is the char. 
9131			;If A is a lowercase letter, this sets it to the matching uppercase 
9131			;18cc or 30cc or 41cc 
9131			;avg: 26.75cc 
9131 fe 61		  cp 'a' 
9133 d8			  ret c 
9134 fe 7b		  cp 'z'+1 
9136 d0			  ret nc 
9137 d6 20		  sub 'a'-'A' 
9139 c9			  ret 
913a			 
913a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
913a			 
913a			; String Length 
913a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
913a			 
913a			; Get the length of the null-terminated string starting at $8000 hl 
913a			;    LD     HL, $8000 
913a			 
913a			strlenz: 
913a			 
913a af			    XOR    A               ; Zero is the value we are looking for. 
913b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913d			                           ; 65, 536 bytes (the entire addressable memory space). 
913d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913f			 
913f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9140 6f			    LD     L, A             ; number of bytes 
9141 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9143 2b			    DEC    HL              ; Compensate for null. 
9144 c9				ret 
9145			 
9145			; Get the length of the A terminated string starting at $8000 hl 
9145			;    LD     HL, $8000 
9145			 
9145			strlent: 
9145			 
9145			                  ; A is the value we are looking for. 
9145 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9147 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9149			                           ; 65, 536 bytes (the entire addressable memory space). 
9149 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914b			 
914b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914d 2e 00		    LD     L, 0             ; number of bytes 
914f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9151 2b			    DEC    HL              ; Compensate for null. 
9152 c9				ret 
9153			 
9153			 
9153			;Comparing Strings 
9153			 
9153			;IN    HL     Address of string1. 
9153			;      DE     Address of string2. 
9153			 
9153			; doc given but wrong??? 
9153			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9153			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9153			; tested 
9153			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9153			 
9153			strcmp_old: 
9153 e5			    PUSH   HL 
9154 d5			    PUSH   DE 
9155			 
9155 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9156 be			    CP     (HL)            ; (want to minimize work). 
9157 38 01		    JR     C, Str1IsBigger 
9159 7e			    LD     A, (HL) 
915a			 
915a			Str1IsBigger: 
915a 4f			    LD     C, A             ; Put length in BC 
915b 06 00		    LD     B, 0 
915d 13			    INC    DE              ; Increment pointers to meat of string. 
915e 23			    INC    HL 
915f			 
915f			CmpLoop: 
915f 1a			    LD     A, (DE)          ; Compare bytes. 
9160 ed a1		    CPI 
9162 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9164 13			    INC    DE              ; Update pointer. 
9165 ea 5f 91		    JP     PE, CmpLoop 
9168			 
9168 d1			    POP    DE 
9169 e1			    POP    HL 
916a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916b be			    CP     (HL) 
916c c9			    RET 
916d			 
916d			NoMatch: 
916d 2b			    DEC    HL 
916e be			    CP     (HL)            ; Compare again to affect carry. 
916f d1			    POP    DE 
9170 e1			    POP    HL 
9171 c9			    RET 
9172			 
9172			;; test strmp 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr z, .z1 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z1: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr z, .z2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr c, .c1 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c1: 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr c, .c2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;	NEXTW 
9172			;.str1:   db "string1",0 
9172			;.str2:   db "string2",0 
9172			 
9172			; only care about direct match or not 
9172			; hl and de strings 
9172			; zero set if the same 
9172			 
9172			strcmp: 
9172 1a				ld a, (de) 
9173 be				cp (hl) 
9174 28 02			jr z, .ssame 
9176 b7				or a 
9177 c9				ret 
9178			 
9178			.ssame:  
9178 fe 00			cp 0 
917a c8				ret z 
917b			 
917b 23				inc hl 
917c 13				inc de 
917d 18 f3			jr strcmp 
917f				 
917f				 
917f			 
917f			 
917f			 
917f			 
917f			; eof 
917f			 
917f			 
917f			 
917f			 
917f			 
917f			 
# End of file firmware_strings.asm
917f			include "firmware_memory.asm"   ; malloc and free  
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			.mallocsize: db "Wants malloc >256",0 
917f			.mallocasize: db "MALLOC gives >256",0 
917f			.malloczero: db "MALLOC gives zero",0 
917f			 
917f			malloc_guard_zerolen: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f				ld de, 0 
917f			        call cmp16 
917f				jr nz, .lowalloz 
917f			 
917f				push hl 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .malloczero 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				call bp_on 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f			.lowalloz: 
917f			 
917f			 
917f				pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_entry: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowalloc 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocsize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f				jr .lowdone 
917f			.lowalloc: 
917f			 
917f			 
917f				pop hl 
917f			.lowdone:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_exit: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowallocx 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocasize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f				pop de 
917f				pop hl 
917f			 
917f				CALLMONITOR 
917f				jr .lowdonex 
917f			.lowallocx: 
917f			 
917f				pop hl 
917f			.lowdonex:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			endif 
917f			 
917f			if MALLOC_2 
917f			; Z80 Malloc and Free Functions 
917f			 
917f			; Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc: 
917f				 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_entry 
917f			endif 
917f			 
917f			 
917f			 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "mal" 
917f						CALLMONITOR 
917f					endif 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of size into A 
917f			    or h               ; Check if size is zero 
917f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917f			 
917f			    ; Allocate memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma1" 
917f						CALLMONITOR 
917f					endif 
917f			    call malloc_internal ; Call internal malloc function 
917f			    pop af             ; Restore AF register 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret                ; Return 
917f			 
917f			; Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free: 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of pointer into A 
917f			    or h               ; Check if pointer is NULL 
917f			    jp z, free_exit    ; If pointer is NULL, exit 
917f			 
917f			    ; Free memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f			    call free_internal  ; Call internal free function 
917f			    pop af             ; Restore AF register 
917f			    ret                ; Return 
917f			 
917f			; Internal Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc_internal: 
917f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to requested size 
917f			    ex de, hl          ; Save total size in DE, and keep it in HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			 
917f			    ; Search for free memory block 
917f			    ld de, (heap_end)  ; Load end of heap into DE 
917f			    ld bc, 0           ; Initialize counter 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			malloc_search_loop: 
917f			    ; Check if current block is free 
917f			    ld a, (hl)         ; Load current block's status (free or used) 
917f			    cp 0               ; Compare with zero (free) 
917f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917f			 
917f			    ; Check if current block is large enough 
917f			    ld a, (hl+1)       ; Load high byte of block size 
917f			    cp l               ; Compare with low byte of requested size 
917f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917f			 
917f			    ld a, (hl+2)       ; Load low byte of block size 
917f			    cp h               ; Compare with high byte of requested size 
917f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917f			 
917f			    ; Mark block as used 
917f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917f			 
917f			    ; Calculate remaining space in block 
917f			    ld bc, 0           ; Clear BC 
917f			    add hl, bc         ; Increment HL to point to start of data block 
917f			    add hl, de         ; HL = HL + DE (total size) 
917f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to start of data block 
917f			 
917f			    ; Save pointer to allocated block in HL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma5" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			malloc_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3           ; Size of management overhead 
917f			    add hl, bc         ; Move to the next block 
917f			    inc de             ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e            ; Load low byte of heap end address 
917f			    cp (hl)            ; Compare with low byte of current address 
917f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917f			    ld a, d            ; Load high byte of heap end address 
917f			    cp 0               ; Check if it's zero (end of memory) 
917f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, allocation failed 
917f			    xor a              ; Set result to NULL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma6" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			malloc_exit: 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma7" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			; Internal Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free_internal: 
917f			    ld de, (heap_start) ; Load start of heap into DE 
917f			    ld bc, 0            ; Initialize counter 
917f			 
917f			free_search_loop: 
917f			    ; Check if current block contains the pointer 
917f			    ld a, l             ; Load low byte of pointer 
917f			    cp (hl+1)           ; Compare with high byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			    ld a, h             ; Load high byte of pointer 
917f			    cp (hl+2)           ; Compare with low byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			 
917f			    ; Mark block as free 
917f			    ld (hl), 0          ; Set status byte to indicate free block 
917f			    ret                 ; Return 
917f			 
917f			free_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3            ; Size of management overhead 
917f			    add hl, bc          ; Move to the next block 
917f			    inc de              ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e             ; Load low byte of heap end address 
917f			    cp (hl)             ; Compare with low byte of current address 
917f			    jr nz, free_search_loop  ; If not equal, continue searching 
917f			    ld a, d             ; Load high byte of heap end address 
917f			    cp 0                ; Check if it's zero (end of memory) 
917f			    jr nz, free_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, pointer is not found in heap 
917f			    ret 
917f			 
917f			free_exit: 
917f			    ret                 ; Return 
917f			 
917f			; Define heap start and end addresses 
917f			;heap_start:    .dw 0xC000   ; Start of heap 
917f			;heap_end:      .dw 0xE000   ; End of heap 
917f			 
917f			endif 
917f			 
917f			 
917f			if MALLOC_1 
917f			 
917f			 
917f			 
917f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917f			 
917f			;moved to firmware.asm 
917f			;heap_start        .equ  0x9000      ; Starting address of heap 
917f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917f			 
917f			;      .org 0 
917f			;      jp    main 
917f			 
917f			 
917f			;      .org  0x100 
917f			;main: 
917f			;      ld    HL, 0x8100 
917f			;      ld    SP, HL 
917f			; 
917f			;      call  heap_init 
917f			; 
917f			;      ; Make some allocations 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9004 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9014 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9024 
917f			; 
917f			;      ; Free some allocations 
917f			;      ld    HL, 0x9014 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9004 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9024 
917f			;      call  free 
917f			; 
917f			; 
917f			;      halt 
917f			 
917f			 
917f			;------------------------------------------------------------------------------ 
917f			;     heap_init                                                               : 
917f			;                                                                             : 
917f			; Description                                                                 : 
917f			;     Initialise the heap and make it ready for malloc and free operations.   : 
917f			;                                                                             : 
917f			;     The heap is maintained as a linked list, starting with an initial       : 
917f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917f			;     the first free block in the heap. Each block then points to the next    : 
917f			;     free block within the heap, and the free list ends at the first block   : 
917f			;     with a null pointer to the next free block.                             : 
917f			;                                                                             : 
917f			; Parameters                                                                  : 
917f			;     Inputs are compile-time only. Two defines which specify the starting    : 
917f			;     address of the heap and its size are required, along with a memory      : 
917f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917f			;     principally stores a pointer to the first free block in the heap.       : 
917f			;                                                                             : 
917f			; Returns                                                                     : 
917f			;     Nothing                                                                 : 
917f			;------------------------------------------------------------------------------ 
917f			heap_init: 
917f e5			      push  HL 
9180			 
9180			      ; Initialise free list struct 
9180 21 5a e3		      ld    HL, heap_start 
9183 22 55 e3		      ld    (free_list), HL 
9186 21 00 00		      ld    HL, 0 
9189 22 57 e3		      ld    (free_list+2), HL 
918c			 
918c			      ; Insert first free block at bottom of heap, consumes entire heap 
918c 21 a7 e2		      ld    HL, heap_start+heap_size-4 
918f 22 5a e3		      ld    (heap_start), HL        ; Next block (end of free list) 
9192 21 4d ff		      ld    HL, heap_size-4 
9195 22 5c e3		      ld    (heap_start+2), HL      ; Block size 
9198			 
9198			      ; Insert end of free list block at top of heap - two null words will 
9198			      ; terminate the free list 
9198 21 00 00		      ld    HL, 0 
919b 22 a9 e2		      ld    (heap_start+heap_size-2), HL 
919e 22 a7 e2		      ld    (heap_start+heap_size-4), HL 
91a1			 
91a1 e1			      pop   HL 
91a2			 
91a2 c9			      ret 
91a3			 
91a3			 
91a3			;------------------------------------------------------------------------------ 
91a3			;     malloc                                                                  : 
91a3			;                                                                             : 
91a3			; Description                                                                 : 
91a3			;     Allocates the wanted space from the heap and returns the address of the : 
91a3			;     first useable byte of the allocation.                                   : 
91a3			;                                                                             : 
91a3			;     Allocations can happen in one of two ways:                              : 
91a3			;                                                                             : 
91a3			;     1. A free block may be found which is the exact size wanted. In this    : 
91a3			;        case the block is removed from the free list and retuedn to the      : 
91a3			;        caller.                                                              : 
91a3			;     2. A free block may be found which is larger than the size wanted. In   : 
91a3			;        this case, the larger block is split into two. The first portion of  : 
91a3			;        this block will become the requested space by the malloc call and    : 
91a3			;        is returned to the caller. The second portion becomes a new free     : 
91a3			;        block, and the free list is adjusted to maintain continuity via this : 
91a3			;        newly created block.                                                 : 
91a3			;                                                                             : 
91a3			;     malloc does not set any initial value in the allocated space, the       : 
91a3			;     caller is required to do this as required.                              : 
91a3			;                                                                             : 
91a3			;     This implementation of malloc uses the stack exclusively, and is        : 
91a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a3			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a3			;     to avoid the use of malloc inside ISRs in general.                      : 
91a3			;                                                                             : 
91a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a3			;                                                                             : 
91a3			; Parameters                                                                  : 
91a3			;     HL  Number of bytes wanted                                              : 
91a3			;                                                                             : 
91a3			; Returns                                                                     : 
91a3			;     HL  Address of the first useable byte of the allocation                 : 
91a3			;                                                                             : 
91a3			; Flags                                                                       : 
91a3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a3			;                                                                             : 
91a3			; Stack frame                                                                 : 
91a3			;       |             |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     BC      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     DE      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     IX      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |  prev_free  |                                                       : 
91a3			;   +4  +-------------+                                                       : 
91a3			;       |  this_free  |                                                       : 
91a3			;   +2  +-------------+                                                       : 
91a3			;       |  next_free  |                                                       : 
91a3			;   +0  +-------------+                                                       : 
91a3			;       |             |                                                       : 
91a3			;                                                                             : 
91a3			;------------------------------------------------------------------------------ 
91a3			 
91a3			 
91a3			;malloc: 
91a3			; 
91a3			;	SAVESP ON 1 
91a3			; 
91a3			;	call malloc_code 
91a3			; 
91a3			;	CHECKSP ON 1 
91a3			;	ret 
91a3			 
91a3			 
91a3			malloc: 
91a3 c5			      push  BC 
91a4 d5			      push  DE 
91a5 dd e5		      push  IX 
91a7			if DEBUG_FORTH_MALLOC_HIGH 
91a7			call malloc_guard_entry 
91a7			endif 
91a7			 
91a7					if DEBUG_FORTH_MALLOC 
91a7						DMARK "mal" 
91a7						CALLMONITOR 
91a7					endif 
91a7 7c			      ld    A, H                    ; Exit if no space requested 
91a8 b5			      or    L 
91a9 ca 68 92		      jp    Z, malloc_early_exit 
91ac			 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			; 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			 
91ac			 
91ac			 
91ac			 
91ac					if DEBUG_FORTH_MALLOC 
91ac						DMARK "maA" 
91ac						CALLMONITOR 
91ac					endif 
91ac			      ; Set up stack frame 
91ac eb			      ex    DE, HL 
91ad 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91b0 39			      add   HL, SP 
91b1 f9			      ld    SP, HL 
91b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b6 dd 39		      add   IX, SP 
91b8			 
91b8			      ; Setup initial state 
91b8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91bb 19			      add   HL, DE 
91bc			 
91bc 44			      ld    B, H                    ; Move want to BC 
91bd 4d			      ld    C, L 
91be			 
91be 21 55 e3		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c1 dd 75 04		      ld    (IX+4), L 
91c4 dd 74 05		      ld    (IX+5), H 
91c7			 
91c7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c8 23			      inc   HL 
91c9 56			      ld    D, (HL) 
91ca dd 73 02		      ld    (IX+2), E 
91cd dd 72 03		      ld    (IX+3), D 
91d0 eb			      ex    DE, HL                  ; this_free ptr into HL 
91d1			 
91d1					if DEBUG_FORTH_MALLOC 
91d1						DMARK "maB" 
91d1						CALLMONITOR 
91d1					endif 
91d1			      ; Loop through free block list to find some space 
91d1			malloc_find_space: 
91d1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4			 
91d4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d5 b3			      or    E 
91d6 ca 62 92		      jp    Z, malloc_no_space 
91d9			 
91d9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91dc dd 72 01		      ld    (IX+1), D 
91df			 
91df			      ; Does this block have enough space to make the allocation? 
91df 23			      inc   HL                      ; Load free block size into DE 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3			 
91e3 eb			      ex    DE, HL                  ; Check size of block against want 
91e4 b7			      or    A                       ; Ensure carry flag clear 
91e5 ed 42		      sbc   HL, BC 
91e7 e5			      push  HL                      ; Store the result for later (new block size) 
91e8			 
91e8 ca 37 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91eb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ed			 
91ed			      ; this_free block is not big enough, setup ptrs to test next free block 
91ed e1			      pop   HL                      ; Discard previous result 
91ee			 
91ee dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f1 dd 66 03		      ld    H, (IX+3) 
91f4 dd 75 04		      ld    (IX+4), L 
91f7 dd 74 05		      ld    (IX+5), H 
91fa			 
91fa dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fd dd 66 01		      ld    H, (IX+1) 
9200 dd 75 02		      ld    (IX+2), L 
9203 dd 74 03		      ld    (IX+3), H 
9206			 
9206					if DEBUG_FORTH_MALLOC 
9206						DMARK "MA>" 
9206						CALLMONITOR 
9206					endif 
9206 18 c9		      jr    malloc_find_space 
9208			 
9208			      ; split a bigger block into two - requested size and remaining size 
9208			malloc_alloc_split: 
9208					if DEBUG_FORTH_MALLOC 
9208						DMARK "MAs" 
9208						CALLMONITOR 
9208					endif 
9208 eb			      ex    DE, HL                  ; Calculate address of new free block 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 2b			      dec   HL 
920c 09			      add   HL, BC 
920d			 
920d			      ; Create a new block and point it at next_free 
920d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9210 dd 56 01		      ld    D, (IX+1) 
9213			 
9213 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9214 23			      inc   HL 
9215 72			      ld    (HL), D 
9216			 
9216 d1			      pop   DE                      ; Store size of new block into new block 
9217 23			      inc   HL 
9218 73			      ld    (HL), E 
9219 23			      inc   HL 
921a 72			      ld    (HL), D 
921b			 
921b			      ; Update this_free ptr to point to new block 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9221 dd 56 03		      ld    D, (IX+3) 
9224			 
9224 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9227 dd 74 03		      ld    (IX+3), H 
922a			 
922a			      ; Modify this_free block to be allocation 
922a eb			      ex    DE, HL 
922b af			      xor   A                       ; Null the next block ptr of allocated block 
922c 77			      ld    (HL), A 
922d 23			      inc   HL 
922e 77			      ld    (HL), A 
922f			 
922f 23			      inc   HL                      ; Store want size into allocated block 
9230 71			      ld    (HL), C 
9231 23			      inc   HL 
9232 70			      ld    (HL), B 
9233 23			      inc   HL 
9234 e5			      push  HL                      ; Address of allocation to return 
9235			 
9235 18 19		      jr    malloc_update_links 
9237			 
9237			malloc_alloc_fit: 
9237 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9238			 
9238					if DEBUG_FORTH_MALLOC 
9238						DMARK "MAf" 
9238						CALLMONITOR 
9238					endif 
9238			      ; Modify this_free block to be allocation 
9238 eb			      ex    DE, HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b 2b			      dec   HL 
923c			 
923c af			      xor   A                       ; Null the next block ptr of allocated block 
923d 77			      ld    (HL), A 
923e 23			      inc   HL 
923f 77			      ld    (HL), A 
9240			 
9240 23			      inc   HL                      ; Store address of allocation to return 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 e5			      push  HL 
9244			 
9244			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9244 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9247 dd 66 01		      ld    H, (IX+1) 
924a			 
924a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924d dd 74 03		      ld    (IX+3), H 
9250			 
9250			 
9250			malloc_update_links: 
9250			      ; Update prev_free ptr to point to this_free 
9250 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9253 dd 66 05		      ld    H, (IX+5) 
9256			 
9256 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9259 dd 56 03		      ld    D, (IX+3) 
925c			 
925c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925d 23			      inc   HL 
925e 72			      ld    (HL), D 
925f			 
925f					if DEBUG_FORTH_MALLOC 
925f						DMARK "Mul" 
925f						CALLMONITOR 
925f					endif 
925f			      ; Clear the Z flag to indicate successful allocation 
925f 7a			      ld    A, D 
9260 b3			      or    E 
9261			 
9261 d1			      pop   DE                      ; Address of allocation 
9262					if DEBUG_FORTH_MALLOC 
9262						DMARK "MAu" 
9262						CALLMONITOR 
9262					endif 
9262			 
9262			malloc_no_space: 
9262 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9265 39			      add   HL, SP 
9266 f9			      ld    SP, HL 
9267			 
9267 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAN" 
9268						CALLMONITOR 
9268					endif 
9268			 
9268			malloc_early_exit: 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAx" 
9268						CALLMONITOR 
9268					endif 
9268 dd e1		      pop   IX 
926a d1			      pop   DE 
926b c1			      pop   BC 
926c			 
926c			if DEBUG_FORTH_MALLOC_HIGH 
926c			call malloc_guard_exit 
926c			call malloc_guard_zerolen 
926c			endif 
926c c9			      ret 
926d			 
926d			 
926d			;------------------------------------------------------------------------------ 
926d			;     free                                                                    : 
926d			;                                                                             : 
926d			; Description                                                                 : 
926d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926d			;     returned by malloc, otherwise the behaviour is undefined.               : 
926d			;                                                                             : 
926d			;     Where possible, directly adjacent free blocks will be merged together   : 
926d			;     into larger blocks to help ensure that the heap does not become         : 
926d			;     excessively fragmented.                                                 : 
926d			;                                                                             : 
926d			;     free does not clear or set any other value into the freed space, and    : 
926d			;     therefore its contents may be visible through subsequent malloc's. The  : 
926d			;     caller should clear the freed space as required.                        : 
926d			;                                                                             : 
926d			;     This implementation of free uses the stack exclusively, and is          : 
926d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926d			;     advisable to disable interrupts before calling free, and recommended    : 
926d			;     to avoid the use of free inside ISRs in general.                        : 
926d			;                                                                             : 
926d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926d			;                                                                             : 
926d			; Parameters                                                                  : 
926d			;     HL  Pointer to address of first byte of allocation to be freed          : 
926d			;                                                                             : 
926d			; Returns                                                                     : 
926d			;     Nothing                                                                 : 
926d			;                                                                             : 
926d			; Stack frame                                                                 : 
926d			;       |             |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     BC      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     DE      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     IX      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |  prev_free  |                                                       : 
926d			;   +2  +-------------+                                                       : 
926d			;       |  next_free  |                                                       : 
926d			;   +0  +-------------+                                                       : 
926d			;       |             |                                                       : 
926d			;                                                                             : 
926d			;------------------------------------------------------------------------------ 
926d			free: 
926d c5			      push  BC 
926e d5			      push  DE 
926f dd e5		      push  IX 
9271			 
9271 7c			      ld    A, H                    ; Exit if ptr is null 
9272 b5			      or    L 
9273 ca 37 93		      jp    Z, free_early_exit 
9276			 
9276			      ; Set up stack frame 
9276 eb			      ex    DE, HL 
9277 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
927a 39			      add   HL, SP 
927b f9			      ld    SP, HL 
927c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9280 dd 39		      add   IX, SP 
9282			 
9282			      ; The address in HL points to the start of the useable allocated space, 
9282			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9282			      ; address of the block itself. 
9282 eb			      ex    DE, HL 
9283 11 fc ff		      ld    DE, -4 
9286 19			      add   HL, DE 
9287			 
9287			      ; An allocated block must have a null next block pointer in it 
9287 7e			      ld    A, (HL) 
9288 23			      inc   HL 
9289 b6			      or    (HL) 
928a c2 32 93		      jp    NZ, free_done 
928d			 
928d 2b			      dec   HL 
928e			 
928e 44			      ld    B, H                    ; Copy HL to BC 
928f 4d			      ld    C, L 
9290			 
9290			      ; Loop through the free list to find the first block with an address 
9290			      ; higher than the block being freed 
9290 21 55 e3		      ld    HL, free_list 
9293			 
9293			free_find_higher_block: 
9293 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9294 23			      inc   HL 
9295 56			      ld    D, (HL) 
9296 2b			      dec   HL 
9297			 
9297 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
929a dd 72 01		      ld    (IX+1), D 
929d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92a0 dd 74 03		      ld    (IX+3), H 
92a3			 
92a3 78			      ld    A, B                    ; Check if DE is greater than BC 
92a4 ba			      cp    D                       ; Compare MSB first 
92a5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a7 30 04		      jr    NC, free_find_higher_block_skip 
92a9 79			      ld    A, C 
92aa bb			      cp    E                       ; Then compare LSB 
92ab 38 08		      jr    C, free_found_higher_block 
92ad			 
92ad			free_find_higher_block_skip: 
92ad 7a			      ld    A, D                    ; Reached the end of the free list? 
92ae b3			      or    E 
92af ca 32 93		      jp    Z, free_done 
92b2			 
92b2 eb			      ex    DE, HL 
92b3			 
92b3 18 de		      jr    free_find_higher_block 
92b5			 
92b5			free_found_higher_block: 
92b5			      ; Insert freed block between prev and next free blocks 
92b5 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b6 23			      inc   HL 
92b7 70			      ld    (HL), B 
92b8			 
92b8 60			      ld    H, B                    ; Point freed block at next free block 
92b9 69			      ld    L, C 
92ba 73			      ld    (HL), E 
92bb 23			      inc   HL 
92bc 72			      ld    (HL), D 
92bd			 
92bd			      ; Check if the freed block is adjacent to the next free block 
92bd 23			      inc   HL                      ; Load size of freed block into HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 eb			      ex    DE, HL 
92c2			 
92c2 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c3			 
92c3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c6 dd 56 01		      ld    D, (IX+1) 
92c9			 
92c9 b7			      or    A                       ; Clear the carry flag 
92ca ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cc 20 22		      jr    NZ, free_check_adjacent_to_prev 
92ce			 
92ce			      ; Freed block is adjacent to next, merge into one bigger block 
92ce eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92cf 5e			      ld    E, (HL) 
92d0 23			      inc   HL 
92d1 56			      ld    D, (HL) 
92d2 e5			      push  HL                      ; Save ptr to next block for later 
92d3			 
92d3 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d4 69			      ld    L, C 
92d5 73			      ld    (HL), E 
92d6 23			      inc   HL 
92d7 72			      ld    (HL), D 
92d8			 
92d8 e1			      pop   HL                      ; Restore ptr to next block 
92d9 23			      inc   HL                      ; Load size of next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd d5			      push  DE                      ; Save next block size for later 
92de			 
92de 60			      ld    H, B                    ; Load size of freed block into HL 
92df 69			      ld    L, C 
92e0 23			      inc   HL 
92e1 23			      inc   HL 
92e2 5e			      ld    E, (HL) 
92e3 23			      inc   HL 
92e4 56			      ld    D, (HL) 
92e5 eb			      ex    DE, HL 
92e6			 
92e6 d1			      pop   DE                      ; Restore size of next block 
92e7 19			      add   HL, DE                  ; Add sizes of both blocks 
92e8 eb			      ex    DE, HL 
92e9			 
92e9 60			      ld    H, B                    ; Store new bigger size into freed block 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 73			      ld    (HL), E 
92ee 23			      inc   HL 
92ef 72			      ld    (HL), D 
92f0			 
92f0			free_check_adjacent_to_prev: 
92f0			      ; Check if the freed block is adjacent to the prev free block 
92f0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f3 dd 66 03		      ld    H, (IX+3) 
92f6			 
92f6 23			      inc   HL                      ; Size of prev free block into DE 
92f7 23			      inc   HL 
92f8 5e			      ld    E, (HL) 
92f9 23			      inc   HL 
92fa 56			      ld    D, (HL) 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd 2b			      dec   HL 
92fe			 
92fe 19			      add   HL, DE                  ; Add prev block addr and size 
92ff			 
92ff b7			      or    A                       ; Clear the carry flag 
9300 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302 20 2e		      jr    NZ, free_done 
9304			 
9304			      ; Freed block is adjacent to prev, merge into one bigger block 
9304 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9305 69			      ld    L, C 
9306 5e			      ld    E, (HL) 
9307 23			      inc   HL 
9308 56			      ld    D, (HL) 
9309 e5			      push  HL                      ; Save freed block ptr for later 
930a			 
930a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930d dd 66 03		      ld    H, (IX+3) 
9310 73			      ld    (HL), E 
9311 23			      inc   HL 
9312 72			      ld    (HL), D 
9313			 
9313 e1			      pop   HL                      ; Restore freed block ptr 
9314 23			      inc   HL                      ; Load size of freed block into DE 
9315 5e			      ld    E, (HL) 
9316 23			      inc   HL 
9317 56			      ld    D, (HL) 
9318 d5			      push  DE                      ; Save freed block size for later 
9319			 
9319 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931c dd 66 03		      ld    H, (IX+3) 
931f 23			      inc   HL 
9320 23			      inc   HL 
9321 5e			      ld    E, (HL) 
9322 23			      inc   HL 
9323 56			      ld    D, (HL) 
9324			 
9324 e1			      pop   HL                      ; Add sizes of both blocks 
9325 19			      add   HL, DE 
9326 eb			      ex    DE, HL 
9327			 
9327 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
932a dd 66 03		      ld    H, (IX+3) 
932d 23			      inc   HL 
932e 23			      inc   HL 
932f 73			      ld    (HL), E 
9330 23			      inc   HL 
9331 72			      ld    (HL), D 
9332			 
9332			free_done: 
9332 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9335 39			      add   HL, SP 
9336 f9			      ld    SP, HL 
9337			 
9337			free_early_exit: 
9337 dd e1		      pop   IX 
9339 d1			      pop   DE 
933a c1			      pop   BC 
933b			 
933b c9			      ret 
933c			 
933c			; moved to firmware.asm 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			;                  .dw   0 
933c			 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_3 
933c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933c			;heap_start        .equ  0x9000      ; Starting address of heap 
933c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933c			; 
933c			 ;     .org 0 
933c			  ;    jp    main 
933c			; 
933c			; 
933c			 ;     .org  0x100 
933c			;main: 
933c			 ;     ld    HL, 0x8100 
933c			  ;    ld    SP, HL 
933c			; 
933c			;      call  heap_init 
933c			 
933c			      ; Make some allocations 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9004 
933c			; 
933c			 ;     ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9014 
933c			 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9024 
933c			 
933c			      ; Free some allocations 
933c			;      ld    HL, 0x9014 
933c			;      call  free 
933c			 
933c			;      ld    HL, 0x9004 
933c			;      call  free 
933c			; 
933c			;      ld    HL, 0x9024 
933c			;      call  free 
933c			 
933c			 
933c			 ;     halt 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     heap_init                                                               : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Initialise the heap and make it ready for malloc and free operations.   : 
933c			;                                                                             : 
933c			;     The heap is maintained as a linked list, starting with an initial       : 
933c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933c			;     the first free block in the heap. Each block then points to the next    : 
933c			;     free block within the heap, and the free list ends at the first block   : 
933c			;     with a null pointer to the next free block.                             : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     Inputs are compile-time only. Two defines which specify the starting    : 
933c			;     address of the heap and its size are required, along with a memory      : 
933c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933c			;     principally stores a pointer to the first free block in the heap.       : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;------------------------------------------------------------------------------ 
933c			heap_init: 
933c			      push  HL 
933c			 
933c			      ; Initialise free list struct 
933c			      ld    HL, heap_start 
933c			      ld    (free_list), HL 
933c			      ld    HL, 0 
933c			      ld    (free_list+2), HL 
933c			 
933c			      ; Insert first free block at bottom of heap, consumes entire heap 
933c			      ld    HL, heap_start+heap_size-4 
933c			      ld    (heap_start), HL        ; Next block (end of free list) 
933c			      ld    HL, heap_size-4 
933c			      ld    (heap_start+2), HL      ; Block size 
933c			 
933c			      ; Insert end of free list block at top of heap - two null words will 
933c			      ; terminate the free list 
933c			      ld    HL, 0 
933c			      ld    (heap_start+heap_size-2), HL 
933c			      ld    (heap_start+heap_size-4), HL 
933c			 
933c			      pop   HL 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     malloc                                                                  : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Allocates the wanted space from the heap and returns the address of the : 
933c			;     first useable byte of the allocation.                                   : 
933c			;                                                                             : 
933c			;     Allocations can happen in one of two ways:                              : 
933c			;                                                                             : 
933c			;     1. A free block may be found which is the exact size wanted. In this    : 
933c			;        case the block is removed from the free list and retuedn to the      : 
933c			;        caller.                                                              : 
933c			;     2. A free block may be found which is larger than the size wanted. In   : 
933c			;        this case, the larger block is split into two. The first portion of  : 
933c			;        this block will become the requested space by the malloc call and    : 
933c			;        is returned to the caller. The second portion becomes a new free     : 
933c			;        block, and the free list is adjusted to maintain continuity via this : 
933c			;        newly created block.                                                 : 
933c			;                                                                             : 
933c			;     malloc does not set any initial value in the allocated space, the       : 
933c			;     caller is required to do this as required.                              : 
933c			;                                                                             : 
933c			;     This implementation of malloc uses the stack exclusively, and is        : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling malloc, and recommended  : 
933c			;     to avoid the use of malloc inside ISRs in general.                      : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Number of bytes wanted                                              : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     HL  Address of the first useable byte of the allocation                 : 
933c			;                                                                             : 
933c			; Flags                                                                       : 
933c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +4  +-------------+                                                       : 
933c			;       |  this_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			malloc: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if no space requested 
933c			      or    L 
933c			      jp    Z, malloc_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; Setup initial state 
933c			      ld    HL, 4                   ; want must also include space used by block struct 
933c			      add   HL, DE 
933c			 
933c			      ld    B, H                    ; Move want to BC 
933c			      ld    C, L 
933c			 
933c			      ld    HL, free_list           ; Store prev_free ptr to stack 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    E, (HL)                 ; Store this_free ptr to stack 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ld    (IX+2), E 
933c			      ld    (IX+3), D 
933c			      ex    DE, HL                  ; this_free ptr into HL 
933c			 
933c			      ; Loop through free block list to find some space 
933c			malloc_find_space: 
933c			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933c			      or    E 
933c			      jp    Z, malloc_no_space 
933c			 
933c			      ld    (IX+0), E               ; Store next_free ptr to stack 
933c			      ld    (IX+1), D 
933c			 
933c			      ; Does this block have enough space to make the allocation? 
933c			      inc   HL                      ; Load free block size into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ex    DE, HL                  ; Check size of block against want 
933c			      or    A                       ; Ensure carry flag clear 
933c			      sbc   HL, BC 
933c			      push  HL                      ; Store the result for later (new block size) 
933c			 
933c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933c			 
933c			      ; this_free block is not big enough, setup ptrs to test next free block 
933c			      pop   HL                      ; Discard previous result 
933c			 
933c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933c			      ld    H, (IX+3) 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933c			      ld    H, (IX+1) 
933c			      ld    (IX+2), L 
933c			      ld    (IX+3), H 
933c			 
933c			      jr    malloc_find_space 
933c			 
933c			      ; split a bigger block into two - requested size and remaining size 
933c			malloc_alloc_split: 
933c			      ex    DE, HL                  ; Calculate address of new free block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      add   HL, BC 
933c			 
933c			      ; Create a new block and point it at next_free 
933c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      ld    (HL), E                 ; Store next_free ptr into new block 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   DE                      ; Store size of new block into new block 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Update this_free ptr to point to new block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933c			      ld    (IX+3), H 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store want size into allocated block 
933c			      ld    (HL), C 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			      inc   HL 
933c			      push  HL                      ; Address of allocation to return 
933c			 
933c			      jr    malloc_update_links 
933c			 
933c			malloc_alloc_fit: 
933c			      pop   HL                      ; Dont need new block size, want is exact fit 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store address of allocation to return 
933c			      inc   HL 
933c			      inc   HL 
933c			      push  HL 
933c			 
933c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933c			      ld    L, (IX+0)               ; next_free to HL 
933c			      ld    H, (IX+1) 
933c			 
933c			      ld    (IX+2), L               ; HL to this_free 
933c			      ld    (IX+3), H 
933c			 
933c			 
933c			malloc_update_links: 
933c			      ; Update prev_free ptr to point to this_free 
933c			      ld    L, (IX+4)               ; prev_free ptr to HL 
933c			      ld    H, (IX+5) 
933c			 
933c			      ld    E, (IX+2)               ; this_free ptr to DE 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (HL), E                 ; this_free ptr into prev_free 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Clear the Z flag to indicate successful allocation 
933c			      ld    A, D 
933c			      or    E 
933c			 
933c			      pop   DE                      ; Address of allocation 
933c			 
933c			malloc_no_space: 
933c			      ld    HL, 6                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			      ex    DE, HL                  ; Alloc addr into HL for return 
933c			 
933c			malloc_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     free                                                                    : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933c			;     returned by malloc, otherwise the behaviour is undefined.               : 
933c			;                                                                             : 
933c			;     Where possible, directly adjacent free blocks will be merged together   : 
933c			;     into larger blocks to help ensure that the heap does not become         : 
933c			;     excessively fragmented.                                                 : 
933c			;                                                                             : 
933c			;     free does not clear or set any other value into the freed space, and    : 
933c			;     therefore its contents may be visible through subsequent malloc's. The  : 
933c			;     caller should clear the freed space as required.                        : 
933c			;                                                                             : 
933c			;     This implementation of free uses the stack exclusively, and is          : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling free, and recommended    : 
933c			;     to avoid the use of free inside ISRs in general.                        : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Pointer to address of first byte of allocation to be freed          : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			free: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if ptr is null 
933c			      or    L 
933c			      jp    Z, free_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; The address in HL points to the start of the useable allocated space, 
933c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933c			      ; address of the block itself. 
933c			      ex    DE, HL 
933c			      ld    DE, -4 
933c			      add   HL, DE 
933c			 
933c			      ; An allocated block must have a null next block pointer in it 
933c			      ld    A, (HL) 
933c			      inc   HL 
933c			      or    (HL) 
933c			      jp    NZ, free_done 
933c			 
933c			      dec   HL 
933c			 
933c			      ld    B, H                    ; Copy HL to BC 
933c			      ld    C, L 
933c			 
933c			      ; Loop through the free list to find the first block with an address 
933c			      ; higher than the block being freed 
933c			      ld    HL, free_list 
933c			 
933c			free_find_higher_block: 
933c			      ld    E, (HL)                 ; Load next ptr from free block 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			 
933c			      ld    (IX+0), E               ; Save ptr to next free block 
933c			      ld    (IX+1), D 
933c			      ld    (IX+2), L               ; Save ptr to prev free block 
933c			      ld    (IX+3), H 
933c			 
933c			      ld    A, B                    ; Check if DE is greater than BC 
933c			      cp    D                       ; Compare MSB first 
933c			      jr    Z, $+4                  ; MSB the same, compare LSB 
933c			      jr    NC, free_find_higher_block_skip 
933c			      ld    A, C 
933c			      cp    E                       ; Then compare LSB 
933c			      jr    C, free_found_higher_block 
933c			 
933c			free_find_higher_block_skip: 
933c			      ld    A, D                    ; Reached the end of the free list? 
933c			      or    E 
933c			      jp    Z, free_done 
933c			 
933c			      ex    DE, HL 
933c			 
933c			      jr    free_find_higher_block 
933c			 
933c			free_found_higher_block: 
933c			      ; Insert freed block between prev and next free blocks 
933c			      ld    (HL), C                 ; Point prev free block to freed block 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			 
933c			      ld    H, B                    ; Point freed block at next free block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Check if the freed block is adjacent to the next free block 
933c			      inc   HL                      ; Load size of freed block into HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      add   HL, BC                  ; Add addr of freed block and its size 
933c			 
933c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_check_adjacent_to_prev 
933c			 
933c			      ; Freed block is adjacent to next, merge into one bigger block 
933c			      ex    DE, HL                  ; Load next ptr from next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save ptr to next block for later 
933c			 
933c			      ld    H, B                    ; Store ptr from next block into freed block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore ptr to next block 
933c			      inc   HL                      ; Load size of next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save next block size for later 
933c			 
933c			      ld    H, B                    ; Load size of freed block into HL 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      pop   DE                      ; Restore size of next block 
933c			      add   HL, DE                  ; Add sizes of both blocks 
933c			      ex    DE, HL 
933c			 
933c			      ld    H, B                    ; Store new bigger size into freed block 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_check_adjacent_to_prev: 
933c			      ; Check if the freed block is adjacent to the prev free block 
933c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933c			      ld    H, (IX+3) 
933c			 
933c			      inc   HL                      ; Size of prev free block into DE 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      add   HL, DE                  ; Add prev block addr and size 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_done 
933c			 
933c			      ; Freed block is adjacent to prev, merge into one bigger block 
933c			      ld    H, B                    ; Load next ptr from freed block into DE 
933c			      ld    L, C 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save freed block ptr for later 
933c			 
933c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933c			      ld    H, (IX+3) 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore freed block ptr 
933c			      inc   HL                      ; Load size of freed block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save freed block size for later 
933c			 
933c			      ld    L, (IX+2)               ; Load size of prev block into DE 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      pop   HL                      ; Add sizes of both blocks 
933c			      add   HL, DE 
933c			      ex    DE, HL 
933c			 
933c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_done: 
933c			      ld    HL, 4                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			free_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;      .org 0x8000 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			 ;                 .dw   0 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_4 
933c			 
933c			; My memory allocation code. Very very simple.... 
933c			; allocate space under 250 chars 
933c			 
933c			heap_init: 
933c				; init start of heap as zero 
933c				;  
933c			 
933c				ld hl, heap_start 
933c				ld a, 0 
933c				ld (hl), a      ; empty block 
933c				inc hl 
933c				ld a, 0 
933c				ld (hl), a      ; length of block 
933c				; write end of list 
933c				inc hl 
933c				ld a,(hl) 
933c				inc hl 
933c				ld a,(hl) 
933c				 
933c			 
933c				; init some malloc vars 
933c			 
933c				ld hl, 0 
933c				ld (free_list), hl       ; store last malloc location 
933c			 
933c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933c				ld a, 0 
933c				ld (hl), a 
933c			 
933c			 
933c				ld hl, heap_start 
933c				;  
933c				  
933c				ret 
933c			 
933c			 
933c			;    free block marker 
933c			;    requested size  
933c			;    pointer to next block 
933c			;    .... 
933c			;    next block marker 
933c			 
933c			 
933c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933c			; 
933c			 
933c			 
933c			malloc:  
933c				push de 
933c				push bc 
933c				push af 
933c			 
933c				; hl space required 
933c				 
933c				ld c, l    ; hold space   (TODO only a max of 255) 
933c			 
933c			;	inc c     ; TODO BUG need to fix memory leak on push str 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			 
933c			 
933c			 
933c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933c			 
933c				ld a, (free_list+3) 
933c				cp 0 
933c				jr z, .contheap 
933c			 
933c				ld hl, (free_list)     ; get last alloc 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mrs" 
933c						CALLMONITOR 
933c					endif 
933c				jr .startalloc 
933c			 
933c			.contheap: 
933c				ld hl, heap_start 
933c			 
933c			.startalloc: 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mym" 
933c						CALLMONITOR 
933c					endif 
933c			.findblock: 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmf" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c				ld a,(hl)  
933c				; if byte is zero then clear to use 
933c			 
933c				cp 0 
933c				jr z, .foundemptyblock 
933c			 
933c				; if byte is not clear 
933c				;     then byte is offset to next block 
933c			 
933c				inc hl 
933c				ld a, (hl) ; get size 
933c			.nextblock:	inc hl 
933c					ld e, (hl) 
933c					inc hl 
933c					ld d, (hl) 
933c					ex de, hl 
933c			;	inc hl  ; move past the store space 
933c			;	inc hl  ; move past zero index  
933c			 
933c				; TODO detect no more space 
933c			 
933c				push hl 
933c				ld de, heap_end 
933c				call cmp16 
933c				pop hl 
933c				jr nc, .nospace 
933c			 
933c				jr .findblock 
933c			 
933c			.nospace: ld hl, 0 
933c				jp .exit 
933c			 
933c			 
933c			.foundemptyblock:	 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mme" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; TODO has block enough space if reusing??? 
933c			 
933c				;  
933c			 
933c			; see if this block has been previously used 
933c				inc hl 
933c				ld a, (hl) 
933c				dec hl 
933c				cp 0 
933c				jr z, .newblock 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meR" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; no reusing previously allocated block 
933c			 
933c			; is it smaller than previously used? 
933c				 
933c				inc hl    ; move to size 
933c				ld a, c 
933c				sub (hl)        ; we want c < (hl) 
933c				dec hl    ; move back to marker 
933c			        jr z, .findblock 
933c			 
933c				; update with the new size which should be lower 
933c			 
933c			        ;inc  hl   ; negate next move. move back to size  
933c			 
933c			.newblock: 
933c				; need to be at marker here 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meN" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			 
933c				ld a, c 
933c			 
933c				ld (free_list+3), a	 ; flag resume from last malloc  
933c				ld (free_list), hl    ; save out last location 
933c			 
933c			 
933c				;inc a     ; space for length byte 
933c				ld (hl), a     ; save block in use marker 
933c			 
933c				inc hl   ; move to space marker 
933c				ld (hl), a    ; save new space 
933c			 
933c				inc hl   ; move to start of allocated area 
933c				 
933c			;	push hl     ; save where we are - 1  
933c			 
933c			;	inc hl  ; move past zero index  
933c				; skip space to set down new marker 
933c			 
933c				; provide some extra space for now 
933c			 
933c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933c				inc a 
933c				inc a 
933c			 
933c				push hl   ; save where we are in the node block 
933c			 
933c				call addatohl 
933c			 
933c				; write linked list point 
933c			 
933c				pop de     ; get our node position 
933c				ex de, hl 
933c			 
933c				ld (hl), e 
933c				inc hl 
933c				ld (hl), d 
933c			 
933c				inc hl 
933c			 
933c				; now at start of allocated data so save pointer 
933c			 
933c				push hl 
933c			 
933c				; jump to position of next node and setup empty header in DE 
933c			 
933c				ex de, hl 
933c			 
933c			;	inc hl ; move past end of block 
933c			 
933c				ld a, 0 
933c				ld (hl), a   ; empty marker 
933c				inc hl 
933c				ld (hl), a   ; size 
933c				inc hl  
933c				ld (hl), a   ; ptr 
933c				inc hl 
933c				ld (hl), a   ; ptr 
933c			 
933c			 
933c				pop hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmr" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			.exit: 
933c				pop af 
933c				pop bc 
933c				pop de  
933c				ret 
933c			 
933c			 
933c			 
933c			 
933c			free:  
933c				push hl 
933c				push af 
933c				; get address in hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "fre" 
933c						CALLMONITOR 
933c					endif 
933c				; data is at hl - move to block count 
933c				dec hl 
933c				dec hl    ; get past pointer 
933c				dec hl 
933c			 
933c				ld a, (hl)    ; need this for a validation check 
933c			 
933c				dec hl    ; move to block marker 
933c			 
933c				; now check that the block count and block marker are the same  
933c			        ; this checks that we are on a malloc node and not random memory 
933c			        ; OK a faint chance this could be a problem but rare - famous last words! 
933c			 
933c				ld c, a 
933c				ld a, (hl)    
933c			 
933c				cp c 
933c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933c			 
933c				; yes good chance we are on a malloc node 
933c			 
933c				ld a, 0      
933c				ld (hl), a   ; mark as free 
933c			 
933c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933c			 
933c			.freeignore:  
933c			 
933c				pop af 
933c				pop hl 
933c			 
933c				ret 
933c			 
933c			 
933c			 
933c			endif 
933c			 
933c			; eof 
# End of file firmware_memory.asm
933c			  
933c			; device C  
933c			if SOUND_ENABLE  
933c				include "firmware_sound.asm"  
933c			endif  
933c			  
933c			include "firmware_diags.asm"  
933c			; Hardware diags menu 
933c			 
933c			 
933c			config: 
933c			 
933c 3e 00			ld a, 0 
933e 21 62 93			ld hl, .configmn 
9341 cd e0 8a			call menu 
9344			 
9344 fe 00			cp 0 
9346 c8				ret z 
9347			 
9347			;	cp 1 
9347			;	call z, .savetostore 
9347			 
9347 fe 01			cp 1 
9349			if STARTUP_V1 
9349 cc 78 93			call z, .selautoload 
934c			endif 
934c			 
934c			if STARTUP_V2 
934c				call z, .enautoload 
934c			endif 
934c fe 02			cp 2 
934e cc 6e 93			call z, .disautoload 
9351			;	cp 3 
9351			;	call z, .selbank 
9351 fe 03			cp 3 
9353 cc 96 93			call z, .debug_tog 
9356 fe 04			cp 4 
9358 cc e4 94			call z, .bpsgo 
935b fe 05			cp 5 
935d cc bf 93			call z, hardware_diags 
9360			if STARTUP_V2 
9360				cp 6 
9360				call z, create_startup 
9360			endif 
9360 18 da			jr config 
9362			 
9362			.configmn: 
9362			;	dw prom_c3 
9362 d3 96			dw prom_c2 
9364 e8 96			dw prom_c2a 
9366			;	dw prom_c2b 
9366			;	dw prom_c4 
9366 07 97			dw prom_m4 
9368 22 97			dw prom_m4b 
936a 2a 97			dw prom_c1 
936c			if STARTUP_V2 
936c				dw prom_c9 
936c			endif 
936c 00 00			dw 0 
936e				 
936e			 
936e			if STARTUP_V2 
936e			.enautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 1 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e				ld hl, prom_notav 
936e				ld de, prom_empty 
936e				call info_panel 
936e				endif 
936e			 
936e			 
936e				ret 
936e			endif 
936e			 
936e			.disautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 0 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e 21 39 97			ld hl, prom_notav 
9371 11 4f 97			ld de, prom_empty 
9374 cd 40 8a			call info_panel 
9377				endif 
9377			 
9377			 
9377 c9				ret 
9378			 
9378			if STARTUP_V1 
9378			 
9378			; Select auto start 
9378			 
9378			.selautoload: 
9378			 
9378				 
9378				if STORAGE_SE 
9378			 
9378					call config_dir 
9378				        ld hl, scratch 
9378					ld a, 0 
9378					call menu 
9378			 
9378					cp 0 
9378					ret z 
9378			 
9378					dec a 
9378			 
9378			 
9378					; locate menu option 
9378			 
9378					ld hl, scratch 
9378					call table_lookup 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALl" 
9378						CALLMONITOR 
9378					endif 
9378					; with the pointer to the menu it, the byte following the zero term is the file id 
9378			 
9378					ld a, 0 
9378					ld bc, 50   ; max of bytes to look at 
9378					cpir  
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALb" 
9378						CALLMONITOR 
9378					endif 
9378					;inc hl 
9378			 
9378					ld a, (hl)   ; file id 
9378					 
9378				        ; save bank and file ids 
9378			 
9378					push af 
9378			 
9378			; TODO need to save to block 0 on bank 1	 
9378			 
9378					call storage_get_block_0 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "AL0" 
9378						CALLMONITOR 
9378					endif 
9378					pop af 
9378			 
9378					ld (store_page+STORE_0_FILERUN),a 
9378					 
9378					; save bank id 
9378			 
9378					ld a,(spi_device) 
9378					ld (store_page+STORE_0_BANKRUN),a 
9378			 
9378					; enable auto run of store file 
9378			 
9378					ld a, 1 
9378					ld (store_page+STORE_0_AUTOFILE),a 
9378			 
9378					; save buffer 
9378			 
9378					ld hl, 0 
9378					ld de, store_page 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALw" 
9378						CALLMONITOR 
9378					endif 
9378				call storage_write_block	 ; save update 
9378			  
9378			 
9378			 
9378			 
9378					ld hl, scratch 
9378					call config_fdir 
9378			 
9378				else 
9378			 
9378 21 39 97			ld hl, prom_notav 
937b 11 4f 97			ld de, prom_empty 
937e cd 40 8a			call info_panel 
9381			 
9381				endif 
9381 c9				ret 
9382			endif 
9382			 
9382			 
9382			; Select storage bank 
9382			 
9382			.selbank: 
9382			 
9382			;	if STORAGE_SE 
9382			;	else 
9382			 
9382 21 39 97			ld hl, prom_notav 
9385 11 4f 97			ld de, prom_empty 
9388 cd 40 8a			call info_panel 
938b			;	endif 
938b				 
938b c9				ret 
938c			 
938c			if STORAGE_SE 
938c			 
938c			.config_ldir:   
938c				; Load storage bank labels into menu array 
938c			 
938c				 
938c			 
938c			 
938c				ret 
938c			 
938c			 
938c			endif 
938c			 
938c			 
938c			; Save user words to storage 
938c			 
938c			.savetostore: 
938c			 
938c			;	if STORAGE_SE 
938c			; 
938c			;		call config_dir 
938c			;	        ld hl, scratch 
938c			;		ld a, 0 
938c			;		call menu 
938c			;		 
938c			;		ld hl, scratch 
938c			;		call config_fdir 
938c			; 
938c			;	else 
938c			 
938c 21 39 97			ld hl, prom_notav 
938f 11 4f 97			ld de, prom_empty 
9392 cd 40 8a			call info_panel 
9395			 
9395			;	endif 
9395			 
9395 c9				ret 
9396			 
9396			if STARTUP_V2 
9396			 
9396			create_startup: 
9396			 
9396				ld a, 0 
9396				ld hl, .crstart 
9396				call menu 
9396			 
9396				cp 0 
9396				ret z 
9396			 
9396				cp 1 
9396				call z, .genlsword 
9396				cp 2 
9396				call z, .genedword 
9396			 
9396				cp 3 
9396				call z, .gendemword 
9396			 
9396				cp 4 
9396				call z, .genutlword 
9396				cp 5 
9396				call z, .genspiword 
9396				cp 6 
9396				call z, .genkeyword 
9396				jr create_startup 
9396			 
9396			.genlsword: 
9396				ld hl, crs_s1 
9396				ld de, .lsworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			.genedword: 
9396				ld de, .edworddef 
9396				ld hl, crs_s2 
9396				call .genfile 
9396				ret 
9396			 
9396			.gendemword: 
9396				ld de, .demoworddef 
9396				ld hl, crs_s3 
9396				call .genfile 
9396				ret 
9396			 
9396			.genutlword: 
9396				ld hl, crs_s4 
9396				ld de, .utilwordef 
9396				call .genfile 
9396				ret 
9396			.genspiword: 
9396				ld hl, crs_s5 
9396				ld de, .spiworddef 
9396				call .genfile 
9396				ret 
9396			.genkeyword: 
9396				ld hl, crs_s6 
9396				ld de, .keyworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			; hl - points to file name 
9396			; de - points to strings to add to file 
9396			 
9396			.genfile: 
9396				push hl 
9396				push de 
9396			 
9396				call clear_display 
9396				ld a, display_row_1 
9396				ld de, .genfiletxt 
9396				call str_at_display 
9396				call update_display 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396			 
9396				push de 
9396				call storage_create 
9396				; id in hl 
9396				pop de   ; table of strings to add 
9396			 
9396			.genloop: 
9396			 
9396				push hl ; save id for next time around 
9396				push de ; save de for next time around 
9396			 
9396				ex de, hl 
9396				call loadwordinhl 
9396				ex de, hl 
9396			 
9396				; need hl to be the id 
9396				; need de to be the string ptr 
9396				 
9396				call storage_append 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396				inc de 
9396				inc de 
9396			 
9396				ld a,(de) 
9396				cp 0 
9396				jr nz, .genloop 
9396				inc de 
9396				ld a, (de) 
9396				dec de 
9396				cp 0 
9396				jr nz, .genloop	 
9396			 
9396				ret 
9396			 
9396			.genfiletxt:  db "Creating file...",0 
9396			 
9396			.utilwordef: 
9396				dw strncpy 
9396				dw type 
9396				dw clrstack 
9396				dw longread 
9396				dw start1 
9396				dw start2 
9396				dw start3b 
9396				dw start3c 
9396				dw list 
9396				dw 0 
9396			 
9396			.lsworddef: 
9396				dw start3b 
9396				dw 0 
9396			 
9396			.edworddef: 
9396				dw edit1 
9396				dw edit2 
9396				dw edit3 
9396				dw 0 
9396			 
9396			.demoworddef: 
9396				dw test5 
9396				dw test6 
9396				dw test7 
9396				dw test8 
9396				dw test9 
9396				dw test10 
9396				dw game1 
9396				dw game1a 
9396				dw game1b 
9396				dw game1c 
9396				dw game1d 
9396				dw game1s 
9396				dw game1t 
9396				dw game1f 
9396				dw game1z 
9396				dw game1zz 
9396				dw ssv2 
9396				dw ssv3 
9396				dw ssv4 
9396				dw ssv5 
9396				dw ssv1 
9396				dw ssv1cpm	 
9396				dw game2b 
9396				dw game2bf 
9396				dw game2mba 
9396				dw game2mbas	 
9396				dw game2mbht 
9396				dw game2mbms 
9396				dw game2mb 
9396				dw game3w 
9396				dw game3p 
9396				dw game3sc 
9396				dw game3vsi 
9396				dw game3vs 
9396				dw 0 
9396			 
9396			 
9396			.spiworddef: 
9396			 
9396			    dw spi1 
9396			    dw spi2 
9396			    dw spi3 
9396			    dw spi4 
9396			    dw spi5 
9396			    dw spi6 
9396			    dw spi7 
9396			 
9396			    dw spi8 
9396			    dw spi9 
9396			    dw spi10 
9396			    dw 0 
9396			 
9396			.keyworddef: 
9396			 
9396				dw keyup 
9396				dw keydown 
9396				dw keyleft 
9396				dw keyright 
9396				dw 	keyf1 
9396				dw keyf2 
9396				dw keyf3 
9396				dw keyf4 
9396				dw keyf5 
9396				dw keyf6 
9396				dw keyf7 
9396				dw keyf8 
9396				dw keyf9 
9396				dw keyf10 
9396				dw keyf11 
9396				dw keyf12 
9396				dw keytab 
9396				dw keycr 
9396				dw keyhome 
9396				dw keyend 
9396				dw keybs 
9396				dw 0 
9396			 
9396			.crstart: 
9396				dw crs_s1 
9396				dw crs_s2 
9396				dw crs_s3 
9396				dw crs_s4 
9396				dw crs_s5 
9396				dw crs_s6 
9396				dw 0 
9396			 
9396			endif 
9396			 
9396			 
9396			if STORAGE_SE 
9396			 
9396			config_fdir: 
9396				; using the scratch dir go through and release the memory allocated for each string 
9396				 
9396				ld hl, scratch 
9396			.cfdir:	ld e,(hl) 
9396				inc hl 
9396				ld d,(hl) 
9396				inc hl 
9396			 
9396				ex de, hl 
9396				call ishlzero 
9396				ret z     ; return on null pointer 
9396				call free 
9396				ex de, hl 
9396				jr .cfdir 
9396			 
9396			 
9396				ret 
9396			 
9396			 
9396			config_dir: 
9396			 
9396				; for the config menus that need to build a directory of storage call this routine 
9396				; it will construct a menu in scratch to pass to menu 
9396			 
9396				; open storage device 
9396			 
9396				; execute DIR to build a list of files and their ids into scratch in menu format 
9396				; once the menu has finished then will need to call config_fdir to release the strings 
9396				 
9396				; c = number items 
9396			 
9396				 
9396				call storage_get_block_0 
9396			 
9396				ld hl, store_page     ; get current id count 
9396				ld b, (hl) 
9396				ld c, 0    ; count of files   
9396			 
9396			 
9396				ld hl, scratch 
9396				ld (store_tmp2), hl    ; location to poke strings 
9396			 
9396				; check for empty drive 
9396			 
9396				ld a, 0 
9396				cp b 
9396				jp z, .dirdone 
9396			 
9396				 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdc" 
9396						CALLMONITOR 
9396					endif 
9396			 
9396			 
9396			.diritem:	 
9396				push bc 
9396				; for each of the current ids do a search for them and if found push to stack 
9396			 
9396					ld hl, STORE_BLOCK_PHY 
9396					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9396					ld e,b 
9396			 
9396					call storage_findnextid 
9396			 
9396			 
9396					; if found hl will be non zero 
9396			 
9396					call ishlzero 
9396					jr z, .dirnotfound 
9396			 
9396					; increase count 
9396			 
9396					pop bc	 
9396					inc c 
9396					push bc 
9396					 
9396			 
9396					; get file header and push the file name 
9396			 
9396					ld de, store_page 
9396					call storage_read_block 
9396			 
9396					; push file id to stack 
9396				 
9396					ld a, (store_page) 
9396					ld h, 0 
9396					ld l, a 
9396			 
9396					;call forth_push_numhl 
9396					; TODO store id 
9396			 
9396					push hl 
9396			 
9396					; push extent count to stack  
9396				 
9396					ld hl, store_page+3 
9396			 
9396					; get file name length 
9396			 
9396					call strlenz   
9396			 
9396					inc hl   ; cover zero term 
9396					inc hl  ; stick the id at the end of the area 
9396			 
9396					push hl 
9396					pop bc    ; move length to bc 
9396			 
9396					call malloc 
9396			 
9396					; TODO save malloc area to scratch 
9396			 
9396					ex de, hl 
9396					ld hl, (store_tmp2) 
9396					ld (hl), e 
9396					inc hl 
9396					ld (hl), d 
9396					inc hl 
9396					ld (store_tmp2), hl 
9396			 
9396					 
9396			 
9396					;pop hl   ; get source 
9396			;		ex de, hl    ; swap aronund	 
9396			 
9396					ld hl, store_page+3 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "CFd" 
9396						CALLMONITOR 
9396					endif 
9396					ldir 
9396			 
9396					; de is past string, move back one and store id 
9396					 
9396					dec de 
9396			 
9396					; store file id 
9396			 
9396					pop hl 
9396					ex de,hl 
9396					ld (hl), e 
9396			 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdi" 
9396						CALLMONITOR 
9396					endif 
9396					 
9396			.dirnotfound: 
9396					pop bc     
9396					djnz .diritem 
9396				 
9396			.dirdone:	 
9396			 
9396					ld a, 0 
9396					ld hl, (store_tmp2) 
9396					ld (hl), a 
9396					inc hl 
9396					ld (hl), a 
9396					inc hl 
9396					; push a count of the dir items found 
9396			 
9396			;		ld h, 0 
9396			;		ld l, c 
9396			 
9396				ret 
9396			 
9396			endif 
9396			 
9396			 
9396			; Settings 
9396			; Run  
9396			 
9396			 
9396			 
9396			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9396			;;hd_menu2:   db "        2: Editor",0   
9396			;hd_menu2:   db "        2: Editor       6: Menu",0   
9396			;hd_menu3:   db "        3: Storage",0 
9396			;hd_menu4:   db "0=quit  4: Debug",0 
9396			;hd_don:     db "ON",0 
9396			;hd_doff:     db "OFF",0 
9396			; 
9396			; 
9396			; 
9396			;hardware_diags_old:       
9396			; 
9396			;.diagmenu: 
9396			;	call clear_display 
9396			;	ld a, display_row_1 
9396			;	ld de, hd_menu1 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_2 
9396			;	ld de, hd_menu2 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_3 
9396			;	ld de, hd_menu3 
9396			;	call str_at_display 
9396			; 
9396			;	ld a,  display_row_4 
9396			;	ld de, hd_menu4 
9396			;	call str_at_display 
9396			; 
9396			;	; display debug state 
9396			; 
9396			;	ld de, hd_don 
9396			;	ld a, (os_view_disable) 
9396			;	cp 0 
9396			;	jr z, .distog 
9396			;	ld de, hd_doff 
9396			;.distog: ld a, display_row_4+17 
9396			;	call str_at_display 
9396			; 
9396			;	call update_display 
9396			; 
9396			;	call cin_wait 
9396			; 
9396			; 
9396			; 
9396			;	cp '4' 
9396			;	jr nz, .diagn1 
9396			; 
9396			;	; debug toggle 
9396			; 
9396			;	ld a, (os_view_disable) 
9396			;	ld b, '*' 
9396			;	cp 0 
9396			;	jr z, .debtog 
9396			;	ld b, 0 
9396			;.debtog:	 
9396			;	ld a,b 
9396			;	ld (os_view_disable),a 
9396			; 
9396			;.diagn1: cp '0' 
9396			;	 ret z 
9396			; 
9396			;;	cp '1' 
9396			;;       jp z, matrix	 
9396			;;   TODO keyboard matrix test 
9396			; 
9396			;	cp '2' 
9396			;	jp z, .diagedit 
9396			; 
9396			;;	cp '6' 
9396			;;	jp z, .menutest 
9396			;;if ENABLE_BASIC 
9396			;;	cp '6' 
9396			;;	jp z, basic 
9396			;;endif 
9396			 ; 
9396			;	jp .diagmenu 
9396			; 
9396			; 
9396			;	ret 
9396			 
9396			 
9396			.debug_tog: 
9396 21 e0 93			ld hl, .menudebug 
9399				 
9399			;	ld a, (os_view_disable) 
9399			;	cp '*' 
9399 3a 72 ee			ld a,(debug_vector) 
939c fe c9			cp $C9   ; RET 
939e 20 04			jr nz,.tdon  
93a0 3e 01			ld a, 1 
93a2 18 02			jr .tog1 
93a4 3e 00		.tdon: ld a, 0 
93a6			 
93a6			.tog1: 
93a6 cd e0 8a			call menu 
93a9 fe 00			cp 0 
93ab c8				ret z 
93ac fe 01			cp 1    ; disable debug 
93ae 28 04			jr z, .dtog0 
93b0 3e 2a			ld a, '*' 
93b2 18 05			jr .dtogset 
93b4			.dtog0:  
93b4				;ld a, 0 
93b4 cd d2 94			call bp_on 
93b7 18 dd			jr .debug_tog 
93b9			.dtogset:  
93b9				; ld (os_view_disable), a 
93b9 cd de 94			call bp_off 
93bc c3 96 93			jp .debug_tog 
93bf			 
93bf			 
93bf			hardware_diags:       
93bf			 
93bf			.diagm: 
93bf 21 d2 93			ld hl, .menuitems 
93c2 3e 00			ld a, 0 
93c4 cd e0 8a			call menu 
93c7			 
93c7 fe 00		         cp 0 
93c9 c8				 ret z 
93ca			 
93ca fe 02			cp 2 
93cc ca 2b 94			jp z, .diagedit 
93cf			 
93cf			;	cp '6' 
93cf			;	jp z, .menutest 
93cf			;if ENABLE_BASIC 
93cf			;	cp '6' 
93cf			;	jp z, basic 
93cf			;endif 
93cf			  
93cf c3 bf 93			jp .diagm 
93d2			 
93d2				 
93d2 e6 93		.menuitems:   	dw .m1 
93d4 f1 93				dw .m2 
93d6 f8 93				dw .m3 
93d8 00 94				dw .m5 
93da 06 94				dw .m5a 
93dc 0f 94				dw .m5b 
93de 00 00				dw 0 
93e0			 
93e0			.menudebug: 
93e0 18 94				dw .m6 
93e2 21 94				dw .m7 
93e4 00 00				dw 0 
93e6			 
93e6 .. 00		.m1:   db "Key Matrix",0 
93f1 .. 00		.m2:   db "Editor",0 
93f8 .. 00		.m3:   db "Storage",0 
9400 .. 00		.m5:   db "Sound",0 
9406 .. 00		.m5a:  db "RAM Test",0 
940f .. 00		.m5b:  db "LCD Test",0 
9418			 
9418 .. 00		.m6:   db "Debug ON",0 
9421 .. 00		.m7:   db "Debug OFF",0 
942b			 
942b			; debug editor 
942b			 
942b			.diagedit: 
942b			 
942b 21 c4 e2			ld hl, scratch 
942e			;	ld bc, 250 
942e			;	ldir 
942e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
942e 3e 00			ld a, 0 
9430 77				ld (hl), a 
9431 23				inc hl 
9432 77				ld (hl), a 
9433 23				inc hl 
9434 77				ld (hl), a 
9435			 
9435 cd af 8a		        call clear_display 
9438 cd d2 8a			call update_display 
943b				;ld a, 1 
943b				;ld (hardware_diag), a 
943b			.diloop: 
943b 3e 00			ld a, display_row_1 
943d 0e 00			ld c, 0 
943f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9441 1e 28			ld e, 40 
9443			 
9443 21 c4 e2			ld hl, scratch	 
9446 cd 09 8d			call input_str 
9449			 
9449 3e 28			ld a, display_row_2 
944b 11 c4 e2			ld de, scratch 
944e cd c2 8a			call str_at_display 
9451 cd d2 8a			call update_display 
9454			 
9454 c3 3b 94			jp .diloop 
9457			 
9457			 
9457			; pass word in hl 
9457			; a has display location 
9457			display_word_at: 
9457 f5				push af 
9458 e5				push hl 
9459 7c				ld a,h 
945a 21 c9 e5			ld hl, os_word_scratch 
945d cd dd 8f			call hexout 
9460 e1				pop hl 
9461 7d				ld a,l 
9462 21 cb e5			ld hl, os_word_scratch+2 
9465 cd dd 8f			call hexout 
9468 21 cd e5			ld hl, os_word_scratch+4 
946b 3e 00			ld a,0 
946d 77				ld (hl),a 
946e 11 c9 e5			ld de,os_word_scratch 
9471 f1				pop af 
9472 cd c2 8a				call str_at_display 
9475 c9				ret 
9476			 
9476			display_ptr_state: 
9476			 
9476				; to restore afterwards 
9476			 
9476 d5				push de 
9477 c5				push bc 
9478 e5				push hl 
9479 f5				push af 
947a			 
947a				; for use in here 
947a			 
947a			;	push bc 
947a			;	push de 
947a			;	push hl 
947a			;	push af 
947a			 
947a cd af 8a			call clear_display 
947d			 
947d 11 56 96			ld de, .ptrstate 
9480 3e 00			ld a, display_row_1 
9482 cd c2 8a			call str_at_display 
9485			 
9485				; display debug step 
9485			 
9485			 
9485 11 6e ee			ld de, debug_mark 
9488 3e 26			ld a, display_row_1+display_cols-2 
948a cd c2 8a			call str_at_display 
948d			 
948d				; display a 
948d 11 60 96			ld de, .ptrcliptr 
9490 3e 28			ld a, display_row_2 
9492 cd c2 8a			call str_at_display 
9495			 
9495 f1				pop af 
9496 2a 43 ea			ld hl,(cli_ptr) 
9499 3e 30			ld a, display_row_2+8 
949b cd 57 94			call display_word_at 
949e			 
949e			 
949e				; display hl 
949e			 
949e			 
949e 11 68 96			ld de, .ptrclioptr 
94a1 3e 32			ld a, display_row_2+10 
94a3 cd c2 8a			call str_at_display 
94a6			; 
94a6			;	pop hl 
94a6 3e 35			ld a, display_row_2+13 
94a8 2a 41 ea			ld hl,(cli_origptr) 
94ab cd 57 94			call display_word_at 
94ae			; 
94ae			;	 
94ae			;	; display de 
94ae			 
94ae			;	ld de, .regstatede 
94ae			;	ld a, display_row_3 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop de 
94ae			;	ld h,d 
94ae			;	ld l, e 
94ae			;	ld a, display_row_3+3 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display bc 
94ae			 
94ae			;	ld de, .regstatebc 
94ae			;	ld a, display_row_3+10 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop bc 
94ae			;	ld h,b 
94ae			;	ld l, c 
94ae			;	ld a, display_row_3+13 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display dsp 
94ae			 
94ae			;	ld de, .regstatedsp 
94ae			;	ld a, display_row_4 
94ae			;	call str_at_display 
94ae			 
94ae				 
94ae			;	ld hl,(cli_data_sp) 
94ae			;	ld a, display_row_4+4 
94ae			;	call display_word_at 
94ae			 
94ae				; display rsp 
94ae			 
94ae 11 97 96			ld de, .regstatersp 
94b1 3e 82			ld a, display_row_4+10 
94b3 cd c2 8a			call str_at_display 
94b6			 
94b6				 
94b6 2a f5 e9			ld hl,(cli_ret_sp) 
94b9 3e 86			ld a, display_row_4+14 
94bb cd 57 94			call display_word_at 
94be			 
94be cd d2 8a			call update_display 
94c1			 
94c1 cd f2 89			call delay1s 
94c4 cd f2 89			call delay1s 
94c7 cd f2 89			call delay1s 
94ca			 
94ca			 
94ca cd c1 9a			call next_page_prompt 
94cd			 
94cd				; restore  
94cd			 
94cd f1				pop af 
94ce e1				pop hl 
94cf c1				pop bc 
94d0 d1				pop de 
94d1 c9				ret 
94d2			 
94d2			; Update the break point vector so that the user can hook a new routine 
94d2			 
94d2			bp_on: 
94d2 3e c3			ld a, $c3    ; JP 
94d4 32 72 ee			ld (debug_vector), a 
94d7 21 e4 94			ld hl, break_point_state 
94da 22 73 ee			ld (debug_vector+1), hl 
94dd c9				ret 
94de			 
94de			bp_off: 
94de 3e c9			ld a, $c9    ; RET 
94e0 32 72 ee			ld (debug_vector), a 
94e3 c9				ret 
94e4			 
94e4			 
94e4			break_point_state: 
94e4			;	push af 
94e4			; 
94e4			;	; see if disabled 
94e4			; 
94e4			;	ld a, (os_view_disable) 
94e4			;	cp '*' 
94e4			;	jr nz, .bpsgo 
94e4			;	pop af 
94e4			;	ret 
94e4			 
94e4			.bpsgo: 
94e4 f1				pop af 
94e5 f5				push af 
94e6 22 b2 e2			ld (os_view_hl), hl 
94e9 ed 53 b0 e2		ld (os_view_de), de 
94ed ed 43 ae e2		ld (os_view_bc), bc 
94f1 e5				push hl 
94f2 6f				ld l, a 
94f3 26 00			ld h, 0 
94f5 22 b4 e2			ld (os_view_af),hl 
94f8			 
94f8 21 b4 ed				ld hl, display_fb0 
94fb 22 cf eb				ld (display_fb_active), hl 
94fe e1				pop hl	 
94ff			 
94ff 3e 31			ld a, '1' 
9501 fe 2a		.bps1:  cp '*' 
9503 cc de 94			call z, bp_off 
9506			;	jr nz, .bps1b 
9506			;	ld (os_view_disable),a 
9506 fe 31		.bps1b:  cp '1' 
9508 20 14			jr nz, .bps2 
950a			 
950a				; display reg 
950a			 
950a				 
950a			 
950a 3a b4 e2			ld a, (os_view_af) 
950d 2a b2 e2			ld hl, (os_view_hl) 
9510 ed 5b b0 e2		ld de, (os_view_de) 
9514 ed 4b ae e2		ld bc, (os_view_bc) 
9518 cd b2 95			call display_reg_state 
951b c3 9e 95			jp .bpschk 
951e			 
951e fe 32		.bps2:  cp '2' 
9520 20 08			jr nz, .bps3 
9522				 
9522				; display hl 
9522 2a b2 e2			ld hl, (os_view_hl) 
9525 cd 9c 96			call display_dump_at_hl 
9528			 
9528 18 74			jr .bpschk 
952a			 
952a fe 33		.bps3:  cp '3' 
952c 20 08			jr nz, .bps4 
952e			 
952e			        ; display de 
952e 2a b0 e2			ld hl, (os_view_de) 
9531 cd 9c 96			call display_dump_at_hl 
9534			 
9534 18 68			jr .bpschk 
9536 fe 34		.bps4:  cp '4' 
9538 20 08			jr nz, .bps5 
953a			 
953a			        ; display bc 
953a 2a ae e2			ld hl, (os_view_bc) 
953d cd 9c 96			call display_dump_at_hl 
9540			 
9540 18 5c			jr .bpschk 
9542 fe 35		.bps5:  cp '5' 
9544 20 08		        jr nz, .bps7 
9546			 
9546				; display cur ptr 
9546 2a 43 ea			ld hl, (cli_ptr) 
9549 cd 9c 96			call display_dump_at_hl 
954c			 
954c 18 50			jr .bpschk 
954e fe 36		.bps7:  cp '6' 
9550 20 08			jr nz, .bps8b 
9552				 
9552				; display cur orig ptr 
9552 2a 41 ea			ld hl, (cli_origptr) 
9555 cd 9c 96			call display_dump_at_hl 
9558 18 44			jr .bpschk 
955a fe 37		.bps8b:  cp '7' 
955c 20 08			jr nz, .bps9 
955e				 
955e				; display dsp 
955e 2a f1 e9			ld hl, (cli_data_sp) 
9561 cd 9c 96			call display_dump_at_hl 
9564			 
9564 18 38			jr .bpschk 
9566 fe 39		.bps9:  cp '9' 
9568 20 05			jr nz, .bps8c 
956a				 
956a				; display SP 
956a			;	ld hl, sp 
956a cd 9c 96			call display_dump_at_hl 
956d			 
956d 18 2f			jr .bpschk 
956f fe 38		.bps8c:  cp '8' 
9571 20 08			jr nz, .bps8d 
9573				 
9573				; display rsp 
9573 2a f5 e9			ld hl, (cli_ret_sp) 
9576 cd 9c 96			call display_dump_at_hl 
9579			 
9579 18 23			jr .bpschk 
957b fe 23		.bps8d:  cp '#'     ; access monitor sub system 
957d 20 05			jr nz, .bps8 
957f cd 8f 98			call monitor 
9582			 
9582 18 1a			jr .bpschk 
9584 fe 30		.bps8:  cp '0' 
9586 20 16			jr nz, .bpschk 
9588			 
9588 21 13 ed				ld hl, display_fb1 
958b 22 cf eb				ld (display_fb_active), hl 
958e cd d2 8a				call update_display 
9591			 
9591				;ld a, (os_view_af) 
9591 2a b2 e2			ld hl, (os_view_hl) 
9594 ed 5b b0 e2		ld de, (os_view_de) 
9598 ed 4b ae e2		ld bc, (os_view_bc) 
959c f1				pop af 
959d c9				ret 
959e			 
959e			.bpschk:   
959e cd f2 89			call delay1s 
95a1 3e 9f		ld a,display_row_4 + display_cols - 1 
95a3 11 bf 9a		        ld de, endprg 
95a6 cd c2 8a			call str_at_display 
95a9 cd d2 8a			call update_display 
95ac cd 36 e3			call cin_wait 
95af			 
95af c3 01 95			jp .bps1 
95b2			 
95b2			 
95b2			display_reg_state: 
95b2			 
95b2				; to restore afterwards 
95b2			 
95b2 d5				push de 
95b3 c5				push bc 
95b4 e5				push hl 
95b5 f5				push af 
95b6			 
95b6				; for use in here 
95b6			 
95b6 c5				push bc 
95b7 d5				push de 
95b8 e5				push hl 
95b9 f5				push af 
95ba			 
95ba cd af 8a			call clear_display 
95bd			 
95bd 11 72 96			ld de, .regstate 
95c0 3e 00			ld a, display_row_1 
95c2 cd c2 8a			call str_at_display 
95c5			 
95c5				; display debug step 
95c5			 
95c5			 
95c5 11 6e ee			ld de, debug_mark 
95c8 3e 25			ld a, display_row_1+display_cols-3 
95ca cd c2 8a			call str_at_display 
95cd			 
95cd				; display a 
95cd 11 8e 96			ld de, .regstatea 
95d0 3e 28			ld a, display_row_2 
95d2 cd c2 8a			call str_at_display 
95d5			 
95d5 e1				pop hl 
95d6			;	ld h,0 
95d6			;	ld l, a 
95d6 3e 2b			ld a, display_row_2+3 
95d8 cd 57 94			call display_word_at 
95db			 
95db			 
95db				; display hl 
95db			 
95db			 
95db 11 82 96			ld de, .regstatehl 
95de 3e 32			ld a, display_row_2+10 
95e0 cd c2 8a			call str_at_display 
95e3			 
95e3 e1				pop hl 
95e4 3e 35			ld a, display_row_2+13 
95e6 cd 57 94			call display_word_at 
95e9			 
95e9				 
95e9				; display de 
95e9			 
95e9 11 86 96			ld de, .regstatede 
95ec 3e 50			ld a, display_row_3 
95ee cd c2 8a			call str_at_display 
95f1			 
95f1 e1				pop hl 
95f2			;	ld h,d 
95f2			;	ld l, e 
95f2 3e 53			ld a, display_row_3+3 
95f4 cd 57 94			call display_word_at 
95f7			 
95f7			 
95f7				; display bc 
95f7			 
95f7 11 8a 96			ld de, .regstatebc 
95fa 3e 5a			ld a, display_row_3+10 
95fc cd c2 8a			call str_at_display 
95ff			 
95ff e1				pop hl 
9600			;	ld h,b 
9600			;	ld l, c 
9600 3e 5d			ld a, display_row_3+13 
9602 cd 57 94			call display_word_at 
9605			 
9605			 
9605				; display dsp 
9605			 
9605 11 92 96			ld de, .regstatedsp 
9608 3e 78			ld a, display_row_4 
960a cd c2 8a			call str_at_display 
960d			 
960d				 
960d 2a f1 e9			ld hl,(cli_data_sp) 
9610 3e 7c			ld a, display_row_4+4 
9612 cd 57 94			call display_word_at 
9615			 
9615				; display rsp 
9615			 
9615 11 97 96			ld de, .regstatersp 
9618 3e 82			ld a, display_row_4+10 
961a cd c2 8a			call str_at_display 
961d			 
961d				 
961d 2a f5 e9			ld hl,(cli_ret_sp) 
9620 3e 86			ld a, display_row_4+14 
9622 cd 57 94			call display_word_at 
9625			 
9625 cd d2 8a			call update_display 
9628			 
9628			;	call delay1s 
9628			;	call delay1s 
9628			;	call delay1s 
9628			 
9628			 
9628			;	call next_page_prompt 
9628			 
9628				; restore  
9628			 
9628 f1				pop af 
9629 e1				pop hl 
962a c1				pop bc 
962b d1				pop de 
962c c9				ret 
962d			 
962d .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9641 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9656 .. 00		.ptrstate:	db "Ptr State",0 
9660 .. 00		.ptrcliptr:     db "cli_ptr",0 
9668 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9672 .. 00		.regstate:	db "Reg State (1/0)",0 
9682 .. 00		.regstatehl:	db "HL:",0 
9686 .. 00		.regstatede:	db "DE:",0 
968a .. 00		.regstatebc:	db "BC:",0 
968e .. 00		.regstatea:	db "A :",0 
9692 .. 00		.regstatedsp:	db "DSP:",0 
9697 .. 00		.regstatersp:	db "RSP:",0 
969c			 
969c			display_dump_at_hl: 
969c e5				push hl 
969d d5				push de 
969e c5				push bc 
969f f5				push af 
96a0			 
96a0 22 e7 e5			ld (os_cur_ptr),hl	 
96a3 cd af 8a			call clear_display 
96a6 cd c9 99			call dumpcont 
96a9			;	call delay1s 
96a9			;	call next_page_prompt 
96a9			 
96a9			 
96a9 f1				pop af 
96aa c1				pop bc 
96ab d1				pop de 
96ac e1				pop hl 
96ad c9				ret 
96ae			 
96ae			;if ENABLE_BASIC 
96ae			;	include "nascombasic.asm" 
96ae			;	basic: 
96ae			;	include "forth/FORTH.ASM" 
96ae			;endif 
96ae			 
96ae			; eof 
96ae			 
96ae			 
# End of file firmware_diags.asm
96ae			  
96ae			include "firmware_prompts.asm"  
96ae			; Prompts  
96ae			 
96ae			; boot messages 
96ae			 
96ae .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c3 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d3			 
96d3			 
96d3			; config menus 
96d3			 
96d3			;prom_c3: db "Add Dictionary To File",0 
96d3			 
96d3			if STARTUP_V1 
96d3 .. 00		prom_c2: db "Select Autoload File",0 
96e8 .. 00		prom_c2a: db "Disable Autoload File", 0 
96fe			endif 
96fe			 
96fe			if STARTUP_V2 
96fe			prom_c2: db "Enable Autoload Files",0 
96fe			prom_c2a: db "Disable Autoload Files", 0 
96fe			 
96fe			crs_s1: db "*ls-word", 0 
96fe			crs_s2: db "*ed-word", 0 
96fe			crs_s3: db "*Demo-Programs", 0 
96fe			crs_s4: db "*Utils", 0 
96fe			crs_s5: db "*SPI-Addons", 0 
96fe			crs_s6: db "*Key-constants", 0 
96fe			 
96fe			 
96fe			 
96fe			endif 
96fe			;prom_c2b: db "Select Storage Bank",0 
96fe .. 00		prom_c4: db "Settings",0 
9707 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9722 .. 00		prom_m4b:   db "Monitor",0 
972a .. 00		prom_c1: db "Hardware Diags",0 
9739			 
9739			 
9739			if STARTUP_V2 
9739			prom_c9: db "Create Startup Files",0 
9739			endif 
9739			 
9739 .. 00		prom_notav:    db "Feature not available",0 
974f .. 00		prom_empty:    db "",0 
9750			 
9750			; eof 
9750			 
# End of file firmware_prompts.asm
9750			  
9750			  
9750			; eof  
9750			  
# End of file firmware.asm
9750			 
9750			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9750			;if BASE_KEV  
9750			;baseram: equ 08000h 
9750			;endif 
9750			 
9750			;if BASE_SC114 
9750			;baseram:     equ    endofcode 
9750			;endif 
9750			 
9750			 
9750			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9750			 
9750			; start system 
9750			 
9750			coldstart: 
9750				; set sp 
9750				; di/ei 
9750			 
9750 f3				di 
9751 31 00 f0			ld sp, tos 
9754			;	ei 
9754			 
9754				; init spinner 
9754 3e 00			ld a,0 
9756 32 c9 eb			ld (display_active), a 
9759			 
9759				; disable breakpoint by default 
9759			 
9759				;ld a,'*' 
9759			;	ld a,' ' 
9759			;	ld (os_view_disable),a 
9759			 
9759				; set break point vector as new break point on or off 
9759 cd de 94			call bp_off 
975c			 
975c				; init hardware 
975c			 
975c				; init keyboard and screen hardware 
975c			 
975c cd 1c 80			call hardware_init 
975f			 
975f			 
975f cd f2 89			call delay1s 
9762 3e 58			ld a, display_row_3+8 
9764 11 03 80			ld de, buildtime 
9767 cd c2 8a			call str_at_display 
976a cd d2 8a			call update_display 
976d			 
976d cd f2 89			call delay1s 
9770 cd f2 89			call delay1s 
9773 cd f2 89			call delay1s 
9776			 
9776				; detect if any keys are held down to enable breakpoints at start up 
9776			 
9776 cd 3c e3			call cin  
9779 fe 00			cp 0 
977b 28 03			jr z, .nokeys 
977d			 
977d				;call hardware_diags 
977d cd 3c 93			call config 
9780			 
9780			;	ld de, .bpen 
9780			;	ld a, display_row_4 
9780			;	call str_at_display 
9780			;	call update_display 
9780			; 
9780			;	ld a,0 
9780			;	ld (os_view_disable),a 
9780			; 
9780			;.bpwait: 
9780			;	call cin 
9780			;	cp 0 
9780			;	jr z, .bpwait 
9780			;	jr .nokeys 
9780			; 
9780			; 
9780			;.bpen:  db "Break points enabled!",0 
9780			 
9780			 
9780			 
9780			 
9780			 
9780			 
9780			.nokeys: 
9780			 
9780			 
9780				 
9780			 
9780			;jp  testkey 
9780			 
9780			;call storage_get_block_0 
9780			; 
9780			;ld hl, 0 
9780			;ld de, store_page 
9780			;call storage_read_block 
9780			 
9780				 
9780			;ld hl, 10 
9780			;ld de, store_page 
9780			;call storage_read_block 
9780			 
9780			 
9780			 
9780			 
9780			 
9780			;stop:	nop 
9780			;	jp stop 
9780			 
9780			 
9780			 
9780			main: 
9780 cd af 8a			call clear_display 
9783 cd d2 8a			call update_display 
9786			 
9786			 
9786			 
9786			;	call testlcd 
9786			 
9786			 
9786			 
9786 cd c6 9e			call forth_init 
9789			 
9789			 
9789			warmstart: 
9789 cd 9c 9e			call forth_warmstart 
978c			 
978c				; run startup word load 
978c			        ; TODO prevent this running at warmstart after crash  
978c			 
978c				if STARTUP_ENABLE 
978c			 
978c					if STARTUP_V1 
978c			 
978c						if STORAGE_SE 
978c							call forth_autoload 
978c						endif 
978c cd e3 e1					call forth_startup 
978f					endif 
978f			 
978f					if STARTUP_V2 
978f			 
978f						if STORAGE_SE 
978f							call forth_autoload 
978f						else 
978f							call forth_startup 
978f						endif 
978f			 
978f			 
978f					endif 
978f			 
978f				endif 
978f			 
978f				; show free memory after boot 
978f 11 29 98			ld de, freeram 
9792 3e 00			ld a, display_row_1 
9794 cd c2 8a			call str_at_display 
9797			 
9797			; Or use heap_size word???? 
9797 21 ab e2			ld hl, heap_end 
979a 11 5a e3			ld de, heap_start 
979d ed 52			sbc hl, de 
979f e5				push hl 
97a0 7c				ld a,h	         	 
97a1 21 c9 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97a4 cd dd 8f			call hexout 
97a7 e1			   	pop hl 
97a8			 
97a8 7d				ld a,l 
97a9 21 cb e5			ld hl, os_word_scratch+2 
97ac cd dd 8f			call hexout 
97af 21 cd e5			ld hl, os_word_scratch+4 
97b2 3e 00			ld a, 0 
97b4 77				ld (hl),a 
97b5 11 c9 e5			ld de, os_word_scratch 
97b8 3e 0d			ld a, display_row_1 + 13 
97ba cd c2 8a			call str_at_display 
97bd cd d2 8a			call update_display 
97c0			 
97c0			 
97c0				;call demo 
97c0			 
97c0			 
97c0				; init scratch input area for cli commands 
97c0			 
97c0 21 eb e5			ld hl, os_cli_cmd 
97c3 3e 00			ld a,0 
97c5 77				ld (hl),a 
97c6 23				inc hl 
97c7 77				ld (hl),a 
97c8			 
97c8 3e 00			ld a,0 
97ca 32 ea e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97cd			 
97cd 32 e7 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97d0 32 e8 e5			ld (os_cur_ptr+1),a	 
97d3			 
97d3 32 c9 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97d6 32 ca e5			ld (os_word_scratch+1),a	 
97d9				 
97d9			 
97d9				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d9 21 eb e5			ld hl, os_cli_cmd 
97dc			 
97dc 3e 00			ld a, 0		 ; init cli input 
97de 77				ld (hl), a 
97df 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97e1			cli: 
97e1				; show cli prompt 
97e1				;push af 
97e1				;ld a, 0 
97e1				;ld de, prompt 
97e1				;call str_at_display 
97e1			 
97e1				;call update_display 
97e1				;pop af 
97e1				;inc a 
97e1				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97e1 0e 00			ld c, 0 
97e3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97e5 1e 28			ld e, 40 
97e7			 
97e7 21 eb e5			ld hl, os_cli_cmd 
97ea			 
97ea				STACKFRAME OFF $fefe $9f9f 
97ea				if DEBUG_STACK_IMB 
97ea					if OFF 
97ea						exx 
97ea						ld de, $fefe 
97ea						ld a, d 
97ea						ld hl, curframe 
97ea						call hexout 
97ea						ld a, e 
97ea						ld hl, curframe+2 
97ea						call hexout 
97ea						ld hl, $fefe 
97ea						push hl 
97ea						ld hl, $9f9f 
97ea						push hl 
97ea						exx 
97ea					endif 
97ea				endif 
97ea			endm 
# End of macro STACKFRAME
97ea			 
97ea cd 09 8d			call input_str 
97ed			 
97ed				STACKFRAMECHK OFF $fefe $9f9f 
97ed				if DEBUG_STACK_IMB 
97ed					if OFF 
97ed						exx 
97ed						ld hl, $9f9f 
97ed						pop de   ; $9f9f 
97ed						call cmp16 
97ed						jr nz, .spnosame 
97ed						ld hl, $fefe 
97ed						pop de   ; $fefe 
97ed						call cmp16 
97ed						jr z, .spfrsame 
97ed						.spnosame: call showsperror 
97ed						.spfrsame: nop 
97ed						exx 
97ed					endif 
97ed				endif 
97ed			endm 
# End of macro STACKFRAMECHK
97ed			 
97ed				; copy input to last command 
97ed			 
97ed 21 eb e5			ld hl, os_cli_cmd 
97f0 11 ea e6			ld de, os_last_cmd 
97f3 01 ff 00			ld bc, 255 
97f6 ed b0			ldir 
97f8			 
97f8				; wipe current buffer 
97f8			 
97f8			;	ld a, 0 
97f8			;	ld hl, os_cli_cmd 
97f8			;	ld de, os_cli_cmd+1 
97f8			;	ld bc, 254 
97f8			;	ldir 
97f8				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97f8			;	call strcpy 
97f8			;	ld a, 0 
97f8			;	ld (hl), a 
97f8			;	inc hl 
97f8			;	ld (hl), a 
97f8			;	inc hl 
97f8			;	ld (hl), a 
97f8			 
97f8				; switch frame buffer to program  
97f8			 
97f8 21 13 ed				ld hl, display_fb1 
97fb 22 cf eb				ld (display_fb_active), hl 
97fe			 
97fe			;	nop 
97fe				STACKFRAME ON $fbfe $8f9f 
97fe				if DEBUG_STACK_IMB 
97fe					if ON 
97fe						exx 
97fe						ld de, $fbfe 
97fe						ld a, d 
97fe						ld hl, curframe 
97fe						call hexout 
97fe						ld a, e 
97fe						ld hl, curframe+2 
97fe						call hexout 
97fe						ld hl, $fbfe 
97fe						push hl 
97fe						ld hl, $8f9f 
97fe						push hl 
97fe						exx 
97fe					endif 
97fe				endif 
97fe			endm 
# End of macro STACKFRAME
97fe				; first time into the parser so pass over the current scratch pad 
97fe 21 eb e5			ld hl,os_cli_cmd 
9801				; tokenise the entered statement(s) in HL 
9801 cd 44 9f			call forthparse 
9804			        ; exec forth statements in top of return stack 
9804 cd 84 9f			call forthexec 
9807				;call forthexec_cleanup 
9807			;	call parsenext 
9807			 
9807				STACKFRAMECHK ON $fbfe $8f9f 
9807				if DEBUG_STACK_IMB 
9807					if ON 
9807						exx 
9807						ld hl, $8f9f 
9807						pop de   ; $8f9f 
9807						call cmp16 
9807						jr nz, .spnosame 
9807						ld hl, $fbfe 
9807						pop de   ; $fbfe 
9807						call cmp16 
9807						jr z, .spfrsame 
9807						.spnosame: call showsperror 
9807						.spfrsame: nop 
9807						exx 
9807					endif 
9807				endif 
9807			endm 
# End of macro STACKFRAMECHK
9807				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9807			 
9807 3e 78			ld a, display_row_4 
9809 11 3b 98			ld de, endprog 
980c			 
980c cd d2 8a			call update_display		 
980f			 
980f cd c1 9a			call next_page_prompt 
9812			 
9812				; switch frame buffer to cli 
9812			 
9812 21 b4 ed				ld hl, display_fb0 
9815 22 cf eb				ld (display_fb_active), hl 
9818			 
9818			 
9818 cd af 8a		        call clear_display 
981b cd d2 8a			call update_display		 
981e			 
981e 21 eb e5			ld hl, os_cli_cmd 
9821			 
9821 3e 00			ld a, 0		 ; init cli input 
9823 77				ld (hl), a 
9824			 
9824				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9824			 
9824				; now on last line 
9824			 
9824				; TODO scroll screen up 
9824			 
9824				; TODO instead just clear screen and place at top of screen 
9824			 
9824			;	ld a, 0 
9824			;	ld (f_cursor_ptr),a 
9824			 
9824				;call clear_display 
9824				;call update_display 
9824			 
9824				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9824 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9826 c3 e1 97			jp cli 
9829			 
9829 .. 00		freeram: db "Free bytes: $",0 
9837 ..			asc: db "1A2F" 
983b .. 00		endprog: db "End prog...",0 
9847			 
9847			testenter2:   
9847 21 f6 e2			ld hl,scratch+50 
984a 22 e7 e5			ld (os_cur_ptr),hl 
984d c3 e1 97			jp cli 
9850			 
9850			testenter:  
9850			 
9850 21 37 98			ld hl,asc 
9853			;	ld a,(hl) 
9853			;	call nibble2val 
9853 cd 33 90			call get_byte 
9856			 
9856			 
9856			;	ld a,(hl) 
9856			;	call atohex 
9856			 
9856			;	call fourehexhl 
9856 32 f6 e2			ld (scratch+50),a 
9859			 
9859			 
9859			 
9859 21 39 98			ld hl,asc+2 
985c			;	ld a, (hl) 
985c			;	call nibble2val 
985c cd 33 90			call get_byte 
985f			 
985f			;	call fourehexhl 
985f 32 f8 e2			ld (scratch+52),a 
9862				 
9862 21 f6 e2			ld hl,scratch+50 
9865 22 e7 e5			ld (os_cur_ptr),hl 
9868 c3 e1 97			jp cli 
986b			 
986b			enter:	 
986b 3a c8 e2			ld a,(scratch+4) 
986e fe 00			cp 0 
9870 28 0c			jr z, .entercont 
9872				; no, not a null term line so has an address to work out.... 
9872			 
9872 21 c6 e2			ld hl,scratch+2 
9875 cd 93 90			call get_word_hl 
9878			 
9878 22 e7 e5			ld (os_cur_ptr),hl	 
987b c3 e1 97			jp cli 
987e			 
987e			 
987e			.entercont:  
987e			 
987e 21 c6 e2			ld hl, scratch+2 
9881 cd 33 90			call get_byte 
9884			 
9884 2a e7 e5		   	ld hl,(os_cur_ptr) 
9887 77					ld (hl),a 
9888 23					inc hl 
9889 22 e7 e5				ld (os_cur_ptr),hl 
988c				 
988c			; get byte  
988c			 
988c			 
988c c3 e1 97			jp cli 
988f			 
988f			 
988f			; basic monitor support 
988f			 
988f			monitor: 
988f				;  
988f cd af 8a			call clear_display 
9892 3e 00			ld a, 0 
9894 11 e3 98			ld de, .monprompt 
9897 cd c2 8a			call str_at_display 
989a cd d2 8a			call update_display 
989d			 
989d				; get a monitor command 
989d			 
989d 0e 00			ld c, 0     ; entry at top left 
989f 16 64			ld d, 100   ; max buffer size 
98a1 1e 0f			ld e, 15    ; input scroll area 
98a3 3e 00			ld a, 0     ; init string 
98a5 21 c2 e4			ld hl, os_input 
98a8 77				ld (hl), a 
98a9 23				inc hl 
98aa 77				ld (hl), a 
98ab 21 c2 e4			ld hl, os_input 
98ae 3e 01			ld a, 1     ; init string 
98b0 cd 09 8d			call input_str 
98b3			 
98b3 cd af 8a		        call clear_display 
98b6 cd d2 8a			call update_display		 
98b9			 
98b9 3a c2 e4			ld a, (os_input) 
98bc cd 31 91			call toUpper 
98bf fe 48		        cp 'H' 
98c1 ca 48 99		        jp z, .monhelp 
98c4 fe 44			cp 'D'		; dump 
98c6 ca 7b 99			jp z, .mondump	 
98c9 fe 43			cp 'C'		; dump 
98cb ca 95 99			jp z, .moncdump	 
98ce fe 4d			cp 'M'		; dump 
98d0 ca e5 98			jp z, .moneditstart 
98d3 fe 55			cp 'U'		; dump 
98d5 ca f1 98			jp z, .monedit	 
98d8 fe 47			cp 'G'		; dump 
98da ca 71 99			jp z, .monjump 
98dd fe 51			cp 'Q'		; dump 
98df c8				ret z	 
98e0			 
98e0			 
98e0				; TODO "S" to access symbol by name and not need the address 
98e0				; TODO "F" to find a string in memory 
98e0			 
98e0 c3 8f 98			jp monitor 
98e3			 
98e3 .. 00		.monprompt: db ">", 0 
98e5			 
98e5			.moneditstart: 
98e5				; get starting address 
98e5			 
98e5 21 c4 e4			ld hl,os_input+2 
98e8 cd 93 90			call get_word_hl 
98eb			 
98eb 22 e7 e5			ld (os_cur_ptr),hl	 
98ee			 
98ee c3 8f 98			jp monitor 
98f1			 
98f1			.monedit: 
98f1				; get byte to load 
98f1			 
98f1 21 c4 e4			ld hl,os_input+2 
98f4 cd 33 90			call get_byte 
98f7			 
98f7				; get address to update 
98f7 2a e7 e5			ld hl, (os_cur_ptr) 
98fa			 
98fa				; update byte 
98fa			 
98fa 77				ld (hl), a 
98fb			 
98fb				; move to next address and save it 
98fb			 
98fb 23				inc hl 
98fc 22 e7 e5			ld (os_cur_ptr),hl	 
98ff			 
98ff c3 8f 98			jp monitor 
9902			 
9902			 
9902 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9916 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9932 .. 00		.monhelptext3:  db "G-Call address",0 
9941 .. 00		.monhelptext4:  db "Q-Quit",0 
9948			        
9948			.monhelp: 
9948 3e 00			ld a, display_row_1 
994a 11 02 99		        ld de, .monhelptext1 
994d			 
994d cd c2 8a			call str_at_display 
9950 3e 28			ld a, display_row_2 
9952 11 16 99		        ld de, .monhelptext2 
9955					 
9955 cd c2 8a			call str_at_display 
9958 3e 50			ld a, display_row_3 
995a 11 32 99		        ld de, .monhelptext3 
995d					 
995d cd c2 8a			call str_at_display 
9960 3e 78			ld a, display_row_4 
9962 11 41 99		        ld de, .monhelptext4 
9965 cd c2 8a			call str_at_display 
9968			 
9968 cd d2 8a			call update_display		 
996b			 
996b cd c1 9a			call next_page_prompt 
996e c3 8f 98			jp monitor 
9971			 
9971			.monjump:    
9971 21 c4 e4			ld hl,os_input+2 
9974 cd 93 90			call get_word_hl 
9977			 
9977 e9				jp (hl) 
9978 c3 8f 98			jp monitor 
997b			 
997b			.mondump:    
997b 21 c4 e4			ld hl,os_input+2 
997e cd 93 90			call get_word_hl 
9981			 
9981 22 e7 e5			ld (os_cur_ptr),hl	 
9984 cd c9 99			call dumpcont 
9987 3e 78			ld a, display_row_4 
9989 11 3b 98			ld de, endprog 
998c			 
998c cd d2 8a			call update_display		 
998f			 
998f cd c1 9a			call next_page_prompt 
9992 c3 8f 98			jp monitor 
9995			.moncdump: 
9995 cd c9 99			call dumpcont 
9998 3e 78			ld a, display_row_4 
999a 11 3b 98			ld de, endprog 
999d			 
999d cd d2 8a			call update_display		 
99a0			 
99a0 cd c1 9a			call next_page_prompt 
99a3 c3 8f 98			jp monitor 
99a6			 
99a6			 
99a6			; TODO symbol access  
99a6			 
99a6			.symbols:     ;; A list of symbols that can be called up  
99a6 b4 ed			dw display_fb0 
99a8 .. 00			db "fb0",0  
99ac 7d ea		     	dw store_page 
99ae .. 00			db "store_page",0 
99b9			 
99b9			 
99b9			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99b9			 
99b9 3a c5 e2			ld a,(scratch+1) 
99bc fe 00			cp 0 
99be 28 09			jr z, dumpcont 
99c0			 
99c0				; no, not a null term line so has an address to work out.... 
99c0			 
99c0 21 c6 e2			ld hl,scratch+2 
99c3 cd 93 90			call get_word_hl 
99c6			 
99c6 22 e7 e5			ld (os_cur_ptr),hl	 
99c9			 
99c9			 
99c9			 
99c9			dumpcont: 
99c9			 
99c9				; dump bytes at ptr 
99c9			 
99c9			 
99c9 3e 00			ld a, display_row_1 
99cb 2a cf eb			ld hl, (display_fb_active) 
99ce cd dc 8c			call addatohl 
99d1 cd f9 99			call .dumpbyterow 
99d4			 
99d4 3e 28			ld a, display_row_2 
99d6 2a cf eb			ld hl, (display_fb_active) 
99d9 cd dc 8c			call addatohl 
99dc cd f9 99			call .dumpbyterow 
99df			 
99df			 
99df 3e 50			ld a, display_row_3 
99e1 2a cf eb			ld hl, (display_fb_active) 
99e4 cd dc 8c			call addatohl 
99e7 cd f9 99			call .dumpbyterow 
99ea			 
99ea 3e 78			ld a, display_row_4 
99ec 2a cf eb			ld hl, (display_fb_active) 
99ef cd dc 8c			call addatohl 
99f2 cd f9 99			call .dumpbyterow 
99f5			 
99f5 cd d2 8a			call update_display 
99f8			;		jp cli 
99f8 c9				ret 
99f9			 
99f9			.dumpbyterow: 
99f9			 
99f9				;push af 
99f9			 
99f9 e5				push hl 
99fa			 
99fa				; calc where to poke the ascii 
99fa			if display_cols == 20 
99fa				ld a, 16 
99fa			else 
99fa 3e 1f			ld a, 31 
99fc			endif 
99fc			 
99fc cd dc 8c			call addatohl 
99ff 22 c9 e5			ld (os_word_scratch),hl  		; save pos for later 
9a02			 
9a02			 
9a02			; display decoding address 
9a02 2a e7 e5		   	ld hl,(os_cur_ptr) 
9a05			 
9a05 7c				ld a,h 
9a06 e1				pop hl 
9a07 e5				push hl 
9a08			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9a08 cd dd 8f			call hexout 
9a0b 2a e7 e5		   	ld hl,(os_cur_ptr) 
9a0e			 
9a0e 7d				ld a,l 
9a0f e1				pop hl 
9a10 23				inc hl 
9a11 23				inc hl 
9a12 e5				push hl 
9a13			;	ld hl, os_word_scratch+2 
9a13 cd dd 8f			call hexout 
9a16 e1				pop hl 
9a17 23				inc hl 
9a18 23				inc hl 
9a19				;ld hl, os_word_scratch+4 
9a19 3e 3a			ld a, ':' 
9a1b 77				ld (hl),a 
9a1c 23				inc hl 
9a1d				;ld a, 0 
9a1d				;ld (hl),a 
9a1d				;ld de, os_word_scratch 
9a1d				;pop af 
9a1d				;push af 
9a1d			;		ld a, display_row_2 
9a1d			;		call str_at_display 
9a1d			;		call update_display 
9a1d			 
9a1d			 
9a1d			;pop af 
9a1d			;	add 5 
9a1d			 
9a1d			if display_cols == 20 
9a1d				ld b, 4 
9a1d			else 
9a1d 06 08			ld b, 8 
9a1f			endif	 
9a1f			 
9a1f			.dumpbyte: 
9a1f c5				push bc 
9a20 e5				push hl 
9a21			 
9a21			 
9a21 2a e7 e5		   	ld hl,(os_cur_ptr) 
9a24 7e					ld a,(hl) 
9a25			 
9a25					; poke the ascii to display 
9a25 2a c9 e5				ld hl,(os_word_scratch) 
9a28 77					ld (hl),a 
9a29 23					inc hl 
9a2a 22 c9 e5				ld (os_word_scratch),hl 
9a2d			 
9a2d					 
9a2d			 
9a2d			 
9a2d e1					pop hl 
9a2e e5					push hl 
9a2f			 
9a2f cd dd 8f				call hexout 
9a32			 
9a32					 
9a32 2a e7 e5		   	ld hl,(os_cur_ptr) 
9a35 23				inc hl 
9a36 22 e7 e5		   	ld (os_cur_ptr),hl 
9a39			 
9a39 e1					pop hl 
9a3a 23					inc hl 
9a3b 23					inc hl 
9a3c 23					inc hl 
9a3d			 
9a3d			 
9a3d			 
9a3d					;ld a,0 
9a3d					;ld (os_word_scratch+2),a 
9a3d					;pop af 
9a3d					;push af 
9a3d			 
9a3d					;ld de, os_word_scratch 
9a3d					;call str_at_display 
9a3d			;		call update_display 
9a3d			;		pop af 
9a3d c1					pop bc 
9a3e c6 03				add 3 
9a40 10 dd			djnz .dumpbyte 
9a42			 
9a42				 
9a42			 
9a42 c9				ret 
9a43			 
9a43			jump:	 
9a43			 
9a43 21 c6 e2			ld hl,scratch+2 
9a46 cd 93 90			call get_word_hl 
9a49				;ld hl,(scratch+2) 
9a49				;call fourehexhl 
9a49			 
9a49 22 e7 e5			ld (os_cur_ptr),hl	 
9a4c			 
9a4c e9				jp (hl) 
9a4d			 
9a4d			 
9a4d			 
9a4d			; TODO implement a basic monitor mode to start with 
9a4d			 
9a4d			 
9a4d			 
9a4d			 
9a4d			 
9a4d			 
9a4d			 
9a4d			 
9a4d			 
9a4d			; testing and demo code during development 
9a4d			 
9a4d			 
9a4d .. 00		str1: db "Enter some text...",0 
9a60 .. 00		clear: db "                    ",0 
9a75			 
9a75			demo: 
9a75			 
9a75			 
9a75			 
9a75			;	call update_display 
9a75			 
9a75				; init scratch input area for testing 
9a75 21 c4 e2			ld hl, scratch	 
9a78 3e 00			ld a,0 
9a7a 77				ld (hl),a 
9a7b			 
9a7b			 
9a7b 3e 28		            LD   A, display_row_2 
9a7d			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a7d 11 4d 9a		            LD   DE, str1 
9a80 cd c2 8a			call str_at_display 
9a83			 
9a83			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a83			cloop:	 
9a83 3e 50		            LD   A, display_row_3 
9a85			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a85 11 60 9a		            LD   DE, clear 
9a88			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a88 cd c2 8a				call str_at_display 
9a8b 3e 78			ld a, display_row_4 
9a8d 11 bd 9a			ld de, prompt 
9a90			 
9a90 cd c2 8a				call str_at_display 
9a93 cd d2 8a			call update_display 
9a96			 
9a96 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a98 16 0a			ld d, 10 
9a9a 21 c4 e2			ld hl, scratch	 
9a9d cd 09 8d			call input_str 
9aa0			 
9aa0			;	call clear_display 
9aa0			;'	call update_display 
9aa0			 
9aa0 3e 00		            LD   A, display_row_1 
9aa2			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aa2 11 60 9a		            LD   DE, clear 
9aa5 cd c2 8a				call str_at_display 
9aa8			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aa8 3e 00		            LD   A, display_row_1 
9aaa			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aaa 11 c4 e2		            LD   DE, scratch 
9aad			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aad cd c2 8a				call str_at_display 
9ab0 cd d2 8a			call update_display 
9ab3			 
9ab3 3e 00				ld a,0 
9ab5 21 c4 e2			ld hl, scratch 
9ab8 77				ld (hl),a 
9ab9			 
9ab9 00				nop 
9aba c3 83 9a			jp cloop 
9abd			 
9abd			 
9abd			 
9abd			; OS Prompt 
9abd			 
9abd .. 00		prompt: db ">",0 
9abf .. 00		endprg: db "?",0 
9ac1			 
9ac1			 
9ac1			; handy next page prompt 
9ac1			next_page_prompt: 
9ac1 e5				push hl 
9ac2 d5				push de 
9ac3 f5				push af 
9ac4 c5				push bc 
9ac5			 
9ac5 3e 9f			ld a,display_row_4 + display_cols - 1 
9ac7 11 bf 9a		        ld de, endprg 
9aca cd c2 8a			call str_at_display 
9acd cd d2 8a			call update_display 
9ad0 cd 36 e3			call cin_wait 
9ad3 c1				pop bc 
9ad4 f1				pop af 
9ad5 d1				pop de 
9ad6 e1				pop hl 
9ad7			 
9ad7			 
9ad7 c9				ret 
9ad8			 
9ad8			 
9ad8			; forth parser 
9ad8			 
9ad8			; My forth kernel 
9ad8			include "forth_kernel.asm" 
9ad8			; 
9ad8			; kernel to the forth OS 
9ad8			 
9ad8			DS_TYPE_STR: equ 1     ; string type 
9ad8			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9ad8			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9ad8			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9ad8			 
9ad8			FORTH_PARSEV1: equ 0 
9ad8			FORTH_PARSEV2: equ 0 
9ad8			FORTH_PARSEV3: equ 0 
9ad8			FORTH_PARSEV4: equ 0 
9ad8			FORTH_PARSEV5: equ 1 
9ad8			 
9ad8			;if FORTH_PARSEV5 
9ad8			;	FORTH_END_BUFFER: equ 0 
9ad8			;else 
9ad8			FORTH_END_BUFFER: equ 127 
9ad8			;endif 
9ad8			 
9ad8			FORTH_TRUE: equ 1 
9ad8			FORTH_FALSE: equ 0 
9ad8			 
9ad8			if FORTH_PARSEV4 
9ad8			include "forth_stackops.asm" 
9ad8			endif 
9ad8			 
9ad8			if FORTH_PARSEV5 
9ad8			include "forth_stackopsv5.asm" 
9ad8			 
9ad8			; Stack operations for v5 parser on wards 
9ad8			; * DATA stack 
9ad8			; * LOOP stack 
9ad8			; * RETURN stack 
9ad8			 
9ad8			 
9ad8			 
9ad8			FORTH_CHK_DSP_UNDER: macro 
9ad8				push hl 
9ad8				push de 
9ad8				ld hl,(cli_data_sp) 
9ad8				ld de, cli_data_stack 
9ad8				call cmp16 
9ad8				jp c, fault_dsp_under 
9ad8				pop de 
9ad8				pop hl 
9ad8				endm 
9ad8			 
9ad8			 
9ad8			FORTH_CHK_RSP_UNDER: macro 
9ad8				push hl 
9ad8				push de 
9ad8				ld hl,(cli_ret_sp) 
9ad8				ld de, cli_ret_stack 
9ad8				call cmp16 
9ad8				jp c, fault_rsp_under 
9ad8				pop de 
9ad8				pop hl 
9ad8				endm 
9ad8			 
9ad8			FORTH_CHK_LOOP_UNDER: macro 
9ad8				push hl 
9ad8				push de 
9ad8				ld hl,(cli_loop_sp) 
9ad8				ld de, cli_loop_stack 
9ad8				call cmp16 
9ad8				jp c, fault_loop_under 
9ad8				pop de 
9ad8				pop hl 
9ad8				endm 
9ad8			 
9ad8			FORTH_ERR_TOS_NOTSTR: macro 
9ad8				; TOSO might need more for checks when used 
9ad8				push af 
9ad8				ld a,(hl) 
9ad8				cp DS_TYPE_STR 
9ad8				jp nz, type_faultn   
9ad8				pop af 
9ad8				endm 
9ad8			 
9ad8			FORTH_ERR_TOS_NOTNUM: macro 
9ad8				push af 
9ad8				ld a,(hl) 
9ad8				cp DS_TYPE_INUM 
9ad8				jp nz, type_faultn   
9ad8				pop af 
9ad8				endm 
9ad8			 
9ad8			 
9ad8			; increase data stack pointer and save hl to it 
9ad8				 
9ad8			FORTH_DSP_NEXT: macro 
9ad8				call macro_forth_dsp_next 
9ad8				endm 
9ad8			 
9ad8			 
9ad8			macro_forth_dsp_next: 
9ad8				if DEBUG_FORTH_STACK_GUARD 
9ad8 cd c4 df				call check_stacks 
9adb				endif 
9adb e5				push hl 
9adc d5				push de 
9add eb				ex de,hl 
9ade 2a f1 e9			ld hl,(cli_data_sp) 
9ae1 23				inc hl 
9ae2 23				inc hl 
9ae3			 
9ae3			; PARSEV5 
9ae3 23				inc hl 
9ae4 22 f1 e9			ld (cli_data_sp),hl 
9ae7 73				ld (hl), e 
9ae8 23				inc hl 
9ae9 72				ld (hl), d 
9aea d1				pop de 
9aeb e1				pop hl 
9aec				if DEBUG_FORTH_STACK_GUARD 
9aec cd c4 df				call check_stacks 
9aef				endif 
9aef c9				ret 
9af0			 
9af0			 
9af0			; increase ret stack pointer and save hl to it 
9af0				 
9af0			FORTH_RSP_NEXT: macro 
9af0				call macro_forth_rsp_next 
9af0				endm 
9af0			 
9af0			macro_forth_rsp_next: 
9af0				if DEBUG_FORTH_STACK_GUARD 
9af0 cd c4 df				call check_stacks 
9af3				endif 
9af3 e5				push hl 
9af4 d5				push de 
9af5 eb				ex de,hl 
9af6 2a f5 e9			ld hl,(cli_ret_sp) 
9af9 23				inc hl 
9afa 23				inc hl 
9afb 22 f5 e9			ld (cli_ret_sp),hl 
9afe 73				ld (hl), e 
9aff 23				inc hl 
9b00 72				ld (hl), d 
9b01 d1				pop de 
9b02 e1				pop hl 
9b03				if DEBUG_FORTH_STACK_GUARD 
9b03 cd c4 df				call check_stacks 
9b06				endif 
9b06 c9				ret 
9b07			 
9b07			; get current ret stack pointer and save to hl  
9b07				 
9b07			FORTH_RSP_TOS: macro 
9b07				call macro_forth_rsp_tos 
9b07				endm 
9b07			 
9b07			macro_forth_rsp_tos: 
9b07				;push de 
9b07 2a f5 e9			ld hl,(cli_ret_sp) 
9b0a cd 42 9b			call loadhlptrtohl 
9b0d				;ld e, (hl) 
9b0d				;inc hl 
9b0d				;ld d, (hl) 
9b0d				;ex de, hl 
9b0d					if DEBUG_FORTH_WORDS 
9b0d			;			DMARK "RST" 
9b0d						CALLMONITOR 
9b0d cd 72 ee			call debug_vector  
9b10				endm  
# End of macro CALLMONITOR
9b10					endif 
9b10				;pop de 
9b10 c9				ret 
9b11			 
9b11			; pop ret stack pointer 
9b11				 
9b11			FORTH_RSP_POP: macro 
9b11				call macro_forth_rsp_pop 
9b11				endm 
9b11			 
9b11			 
9b11			macro_forth_rsp_pop: 
9b11				if DEBUG_FORTH_STACK_GUARD 
9b11			;		DMARK "RPP" 
9b11 cd c4 df				call check_stacks 
9b14					FORTH_CHK_RSP_UNDER 
9b14 e5				push hl 
9b15 d5				push de 
9b16 2a f5 e9			ld hl,(cli_ret_sp) 
9b19 11 af e9			ld de, cli_ret_stack 
9b1c cd fa 8c			call cmp16 
9b1f da d8 e0			jp c, fault_rsp_under 
9b22 d1				pop de 
9b23 e1				pop hl 
9b24				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b24				endif 
9b24 e5				push hl 
9b25 2a f5 e9			ld hl,(cli_ret_sp) 
9b28			 
9b28			 
9b28				if FORTH_ENABLE_FREE 
9b28			 
9b28					; get pointer 
9b28			 
9b28					push de 
9b28					push hl 
9b28			 
9b28					ld e, (hl) 
9b28					inc hl 
9b28					ld d, (hl) 
9b28			 
9b28					ex de, hl 
9b28					call free 
9b28			 
9b28					pop hl 
9b28					pop de 
9b28			 
9b28			 
9b28				endif 
9b28			 
9b28			 
9b28 2b				dec hl 
9b29 2b				dec hl 
9b2a 22 f5 e9			ld (cli_ret_sp), hl 
9b2d				; do stack underflow checks 
9b2d e1				pop hl 
9b2e				if DEBUG_FORTH_STACK_GUARD 
9b2e cd c4 df				call check_stacks 
9b31					FORTH_CHK_RSP_UNDER 
9b31 e5				push hl 
9b32 d5				push de 
9b33 2a f5 e9			ld hl,(cli_ret_sp) 
9b36 11 af e9			ld de, cli_ret_stack 
9b39 cd fa 8c			call cmp16 
9b3c da d8 e0			jp c, fault_rsp_under 
9b3f d1				pop de 
9b40 e1				pop hl 
9b41				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b41				endif 
9b41 c9				ret 
9b42			 
9b42			 
9b42			 
9b42			; routine to load word pointed to by hl into hl 
9b42			 
9b42			loadhlptrtohl: 
9b42			 
9b42 d5				push de 
9b43 5e				ld e, (hl) 
9b44 23				inc hl 
9b45 56				ld d, (hl) 
9b46 eb				ex de, hl 
9b47 d1				pop de 
9b48			 
9b48 c9				ret 
9b49			 
9b49			 
9b49			 
9b49			 
9b49			 
9b49			; push a number held in HL onto the data stack 
9b49			; entry point for pushing a value when already in hl used in function above 
9b49			 
9b49			forth_push_numhl: 
9b49			 
9b49 e5				push hl    ; save value to push 
9b4a			 
9b4a			if DEBUG_FORTH_PUSH 
9b4a				; see if disabled 
9b4a			 
9b4a			 
9b4a f5				push af 
9b4b 3a 72 ee			ld a,(debug_vector) 
9b4e fe c9			cp $c9   ; ret 
9b50			;	ld a, (os_view_disable) 
9b50			;	cp '*' 
9b50 28 34			jr z, .pskip2 
9b52 e5				push hl 
9b53 e5			push hl 
9b54 cd af 8a			call clear_display 
9b57 e1			pop hl 
9b58 7c				ld a,h 
9b59 21 c9 e5			ld hl, os_word_scratch 
9b5c cd dd 8f			call hexout 
9b5f e1				pop hl 
9b60 7d				ld a,l 
9b61 21 cb e5			ld hl, os_word_scratch+2 
9b64 cd dd 8f			call hexout 
9b67			 
9b67 21 cd e5			ld hl, os_word_scratch+4 
9b6a 3e 00			ld a,0 
9b6c 77				ld (hl),a 
9b6d 11 c9 e5			ld de,os_word_scratch 
9b70 3e 28				ld a, display_row_2 
9b72 cd c2 8a				call str_at_display 
9b75 11 ab cb			ld de, .push_num 
9b78 3e 00			ld a, display_row_1 
9b7a			 
9b7a cd c2 8a				call str_at_display 
9b7d			 
9b7d			 
9b7d cd d2 8a			call update_display 
9b80 cd f2 89			call delay1s 
9b83 cd f2 89			call delay1s 
9b86			.pskip2:  
9b86			 
9b86 f1				pop af 
9b87			endif	 
9b87			 
9b87			 
9b87				FORTH_DSP_NEXT 
9b87 cd d8 9a			call macro_forth_dsp_next 
9b8a				endm 
# End of macro FORTH_DSP_NEXT
9b8a			 
9b8a 2a f1 e9			ld hl, (cli_data_sp) 
9b8d			 
9b8d				; save item type 
9b8d 3e 02			ld a,  DS_TYPE_INUM 
9b8f 77				ld (hl), a 
9b90 23				inc hl 
9b91			 
9b91				; get word off stack 
9b91 d1				pop de 
9b92 7b				ld a,e 
9b93 77				ld (hl), a 
9b94 23				inc hl 
9b95 7a				ld a,d 
9b96 77				ld (hl), a 
9b97			 
9b97			if DEBUG_FORTH_PUSH 
9b97 2b				dec hl 
9b98 2b				dec hl 
9b99 2b				dec hl 
9b9a						DMARK "PH5" 
9b9a f5				push af  
9b9b 3a af 9b			ld a, (.dmark)  
9b9e 32 6e ee			ld (debug_mark),a  
9ba1 3a b0 9b			ld a, (.dmark+1)  
9ba4 32 6f ee			ld (debug_mark+1),a  
9ba7 3a b1 9b			ld a, (.dmark+2)  
9baa 32 70 ee			ld (debug_mark+2),a  
9bad 18 03			jr .pastdmark  
9baf ..			.dmark: db "PH5"  
9bb2 f1			.pastdmark: pop af  
9bb3			endm  
# End of macro DMARK
9bb3				CALLMONITOR 
9bb3 cd 72 ee			call debug_vector  
9bb6				endm  
# End of macro CALLMONITOR
9bb6			endif	 
9bb6			 
9bb6 c9				ret 
9bb7			 
9bb7			 
9bb7			; Push a string to stack pointed to by hl 
9bb7			 
9bb7			forth_push_str: 
9bb7			 
9bb7			if DEBUG_FORTH_PUSH 
9bb7						DMARK "PSQ" 
9bb7 f5				push af  
9bb8 3a cc 9b			ld a, (.dmark)  
9bbb 32 6e ee			ld (debug_mark),a  
9bbe 3a cd 9b			ld a, (.dmark+1)  
9bc1 32 6f ee			ld (debug_mark+1),a  
9bc4 3a ce 9b			ld a, (.dmark+2)  
9bc7 32 70 ee			ld (debug_mark+2),a  
9bca 18 03			jr .pastdmark  
9bcc ..			.dmark: db "PSQ"  
9bcf f1			.pastdmark: pop af  
9bd0			endm  
# End of macro DMARK
9bd0				CALLMONITOR 
9bd0 cd 72 ee			call debug_vector  
9bd3				endm  
# End of macro CALLMONITOR
9bd3			endif	 
9bd3			    
9bd3 e5				push hl 
9bd4 e5				push hl 
9bd5			 
9bd5			;	ld a, 0   ; find end of string 
9bd5 cd 3a 91			call strlenz 
9bd8			if DEBUG_FORTH_PUSH 
9bd8						DMARK "PQ2" 
9bd8 f5				push af  
9bd9 3a ed 9b			ld a, (.dmark)  
9bdc 32 6e ee			ld (debug_mark),a  
9bdf 3a ee 9b			ld a, (.dmark+1)  
9be2 32 6f ee			ld (debug_mark+1),a  
9be5 3a ef 9b			ld a, (.dmark+2)  
9be8 32 70 ee			ld (debug_mark+2),a  
9beb 18 03			jr .pastdmark  
9bed ..			.dmark: db "PQ2"  
9bf0 f1			.pastdmark: pop af  
9bf1			endm  
# End of macro DMARK
9bf1				CALLMONITOR 
9bf1 cd 72 ee			call debug_vector  
9bf4				endm  
# End of macro CALLMONITOR
9bf4			endif	 
9bf4 eb				ex de, hl 
9bf5 e1				pop hl   ; get ptr to start of string 
9bf6			if DEBUG_FORTH_PUSH 
9bf6						DMARK "PQ3" 
9bf6 f5				push af  
9bf7 3a 0b 9c			ld a, (.dmark)  
9bfa 32 6e ee			ld (debug_mark),a  
9bfd 3a 0c 9c			ld a, (.dmark+1)  
9c00 32 6f ee			ld (debug_mark+1),a  
9c03 3a 0d 9c			ld a, (.dmark+2)  
9c06 32 70 ee			ld (debug_mark+2),a  
9c09 18 03			jr .pastdmark  
9c0b ..			.dmark: db "PQ3"  
9c0e f1			.pastdmark: pop af  
9c0f			endm  
# End of macro DMARK
9c0f				CALLMONITOR 
9c0f cd 72 ee			call debug_vector  
9c12				endm  
# End of macro CALLMONITOR
9c12			endif	 
9c12 19				add hl,de 
9c13			if DEBUG_FORTH_PUSH 
9c13						DMARK "PQE" 
9c13 f5				push af  
9c14 3a 28 9c			ld a, (.dmark)  
9c17 32 6e ee			ld (debug_mark),a  
9c1a 3a 29 9c			ld a, (.dmark+1)  
9c1d 32 6f ee			ld (debug_mark+1),a  
9c20 3a 2a 9c			ld a, (.dmark+2)  
9c23 32 70 ee			ld (debug_mark+2),a  
9c26 18 03			jr .pastdmark  
9c28 ..			.dmark: db "PQE"  
9c2b f1			.pastdmark: pop af  
9c2c			endm  
# End of macro DMARK
9c2c				CALLMONITOR 
9c2c cd 72 ee			call debug_vector  
9c2f				endm  
# End of macro CALLMONITOR
9c2f			endif	 
9c2f			 
9c2f 2b				dec hl    ; see if there is an optional trailing double quote 
9c30 7e				ld a,(hl) 
9c31 fe 22			cp '"' 
9c33 20 03			jr nz, .strnoq 
9c35 3e 00			ld a, 0      ; get rid of double quote 
9c37 77				ld (hl), a 
9c38 23			.strnoq: inc hl 
9c39			 
9c39 3e 00			ld a, 0 
9c3b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c3c			 
9c3c 13				inc de ; add one for the type string 
9c3d 13				inc de ; add one for null term??? 
9c3e			 
9c3e				; tos is get string pointer again 
9c3e				; de contains space to allocate 
9c3e				 
9c3e d5				push de 
9c3f			 
9c3f eb				ex de, hl 
9c40			 
9c40				;push af 
9c40			 
9c40			if DEBUG_FORTH_PUSH 
9c40						DMARK "PHm" 
9c40 f5				push af  
9c41 3a 55 9c			ld a, (.dmark)  
9c44 32 6e ee			ld (debug_mark),a  
9c47 3a 56 9c			ld a, (.dmark+1)  
9c4a 32 6f ee			ld (debug_mark+1),a  
9c4d 3a 57 9c			ld a, (.dmark+2)  
9c50 32 70 ee			ld (debug_mark+2),a  
9c53 18 03			jr .pastdmark  
9c55 ..			.dmark: db "PHm"  
9c58 f1			.pastdmark: pop af  
9c59			endm  
# End of macro DMARK
9c59				CALLMONITOR 
9c59 cd 72 ee			call debug_vector  
9c5c				endm  
# End of macro CALLMONITOR
9c5c			endif	 
9c5c cd a3 91			call malloc	; on ret hl now contains allocated memory 
9c5f				if DEBUG_FORTH_MALLOC_GUARD 
9c5f cc 03 cc				call z,malloc_error 
9c62				endif 
9c62			 
9c62				 
9c62 c1				pop bc    ; get length 
9c63 d1				pop de   ;  get string start    
9c64			 
9c64				; hl has destination from malloc 
9c64			 
9c64 eb				ex de, hl    ; prep for ldir 
9c65			 
9c65 d5				push de   ; save malloc area for DSP later 
9c66				;push hl   ; save malloc area for DSP later 
9c66			 
9c66			if DEBUG_FORTH_PUSH 
9c66						DMARK "PHc" 
9c66 f5				push af  
9c67 3a 7b 9c			ld a, (.dmark)  
9c6a 32 6e ee			ld (debug_mark),a  
9c6d 3a 7c 9c			ld a, (.dmark+1)  
9c70 32 6f ee			ld (debug_mark+1),a  
9c73 3a 7d 9c			ld a, (.dmark+2)  
9c76 32 70 ee			ld (debug_mark+2),a  
9c79 18 03			jr .pastdmark  
9c7b ..			.dmark: db "PHc"  
9c7e f1			.pastdmark: pop af  
9c7f			endm  
# End of macro DMARK
9c7f				CALLMONITOR 
9c7f cd 72 ee			call debug_vector  
9c82				endm  
# End of macro CALLMONITOR
9c82			endif	 
9c82			 
9c82			 
9c82 ed b0			ldir 
9c84			 
9c84			 
9c84				; push malloc to data stack     macro?????  
9c84			 
9c84				FORTH_DSP_NEXT 
9c84 cd d8 9a			call macro_forth_dsp_next 
9c87				endm 
# End of macro FORTH_DSP_NEXT
9c87			 
9c87				; save value and type 
9c87			 
9c87 2a f1 e9			ld hl, (cli_data_sp) 
9c8a			 
9c8a				; save item type 
9c8a 3e 01			ld a,  DS_TYPE_STR 
9c8c 77				ld (hl), a 
9c8d 23				inc hl 
9c8e			 
9c8e				; get malloc word off stack 
9c8e d1				pop de 
9c8f 73				ld (hl), e 
9c90 23				inc hl 
9c91 72				ld (hl), d 
9c92			 
9c92			 
9c92			 
9c92			if DEBUG_FORTH_PUSH 
9c92 2a f1 e9			ld hl, (cli_data_sp) 
9c95						DMARK "PHS" 
9c95 f5				push af  
9c96 3a aa 9c			ld a, (.dmark)  
9c99 32 6e ee			ld (debug_mark),a  
9c9c 3a ab 9c			ld a, (.dmark+1)  
9c9f 32 6f ee			ld (debug_mark+1),a  
9ca2 3a ac 9c			ld a, (.dmark+2)  
9ca5 32 70 ee			ld (debug_mark+2),a  
9ca8 18 03			jr .pastdmark  
9caa ..			.dmark: db "PHS"  
9cad f1			.pastdmark: pop af  
9cae			endm  
# End of macro DMARK
9cae				CALLMONITOR 
9cae cd 72 ee			call debug_vector  
9cb1				endm  
# End of macro CALLMONITOR
9cb1			;	ex de,hl 
9cb1			endif	 
9cb1				; in case of spaces, skip the ptr past the copied string 
9cb1				;pop af 
9cb1				;ld (cli_origptr),hl 
9cb1			 
9cb1 c9				ret 
9cb2			 
9cb2			 
9cb2			 
9cb2			; TODO ascii push input onto stack given hl to start of input 
9cb2			 
9cb2			; identify type 
9cb2			; if starts with a " then a string 
9cb2			; otherwise it is a number 
9cb2			;  
9cb2			; if a string 
9cb2			;     scan for ending " to get length of string to malloc for + 1 
9cb2			;     malloc 
9cb2			;     put pointer to string on stack first byte flags as string 
9cb2			; 
9cb2			; else a number 
9cb2			;    look for number format identifier 
9cb2			;    $xx hex 
9cb2			;    %xxxxx bin 
9cb2			;    xxxxx decimal 
9cb2			;    convert number to 16bit word.  
9cb2			;    malloc word + 1 with flag to identiy as num 
9cb2			;    put pointer to number on stack 
9cb2			;   
9cb2			;  
9cb2			  
9cb2			forth_apush: 
9cb2				; kernel push 
9cb2			 
9cb2			if DEBUG_FORTH_PUSH 
9cb2						DMARK "PSH" 
9cb2 f5				push af  
9cb3 3a c7 9c			ld a, (.dmark)  
9cb6 32 6e ee			ld (debug_mark),a  
9cb9 3a c8 9c			ld a, (.dmark+1)  
9cbc 32 6f ee			ld (debug_mark+1),a  
9cbf 3a c9 9c			ld a, (.dmark+2)  
9cc2 32 70 ee			ld (debug_mark+2),a  
9cc5 18 03			jr .pastdmark  
9cc7 ..			.dmark: db "PSH"  
9cca f1			.pastdmark: pop af  
9ccb			endm  
# End of macro DMARK
9ccb				CALLMONITOR 
9ccb cd 72 ee			call debug_vector  
9cce				endm  
# End of macro CALLMONITOR
9cce			endif	 
9cce				; identify input type 
9cce			 
9cce 7e				ld a,(hl) 
9ccf fe 22			cp '"' 
9cd1 28 0a			jr z, .fapstr 
9cd3 fe 24			cp '$' 
9cd5 ca fd 9c			jp z, .faphex 
9cd8 fe 25			cp '%' 
9cda ca e5 9c			jp z, .fapbin 
9cdd			;	cp 'b' 
9cdd			;	jp z, .fabin 
9cdd				; else decimal 
9cdd			 
9cdd				; TODO do decimal conversion 
9cdd				; decimal is stored as a 16bit word 
9cdd			 
9cdd				; by default everything is a string if type is not detected 
9cdd			.fapstr: ; 
9cdd fe 22			cp '"' 
9cdf 20 01			jr nz, .strnoqu 
9ce1 23				inc hl 
9ce2			.strnoqu: 
9ce2 c3 b7 9b			jp forth_push_str 
9ce5			 
9ce5			 
9ce5			 
9ce5			.fapbin:    ; push a binary string.  
9ce5 11 00 00			ld de, 0   ; hold a 16bit value 
9ce8			 
9ce8 23			.fapbinshift:	inc hl  
9ce9 7e				ld a,(hl) 
9cea fe 00			cp 0     ; done scanning  
9cec 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cee			 
9cee				; left shift de 
9cee eb				ex de, hl	 
9cef 29				add hl, hl 
9cf0			 
9cf0				; is 1 
9cf0 fe 31			cp '1' 
9cf2 20 02			jr nz, .binzero 
9cf4 cb 4d			bit 1, l 
9cf6			.binzero: 
9cf6 eb				ex de, hl	 ; save current de 
9cf7 18 ef			jr .fapbinshift 
9cf9			 
9cf9			.fapbdone: 
9cf9 eb				ex de, hl 
9cfa c3 49 9b			jp forth_push_numhl 
9cfd			 
9cfd			 
9cfd			.faphex:   ; hex is always stored as a 16bit word 
9cfd				; skip number prefix 
9cfd 23				inc hl 
9cfe				; turn ascii into number 
9cfe cd 93 90			call get_word_hl	; ret 16bit word in hl 
9d01			 
9d01 c3 49 9b			jp forth_push_numhl 
9d04			 
9d04 00				 nop 
9d05			 
9d05			.fabin:   ; TODO bin conversion 
9d05			 
9d05			 
9d05 c9				ret 
9d06			 
9d06			 
9d06			; get either a string ptr or a 16bit word from the data stack 
9d06			 
9d06			FORTH_DSP: macro 
9d06				call macro_forth_dsp 
9d06				endm 
9d06			 
9d06			macro_forth_dsp: 
9d06				; data stack pointer points to current word on tos 
9d06			 
9d06 2a f1 e9			ld hl,(cli_data_sp) 
9d09			 
9d09				if DEBUG_FORTH_PUSH 
9d09						DMARK "DSP" 
9d09 f5				push af  
9d0a 3a 1e 9d			ld a, (.dmark)  
9d0d 32 6e ee			ld (debug_mark),a  
9d10 3a 1f 9d			ld a, (.dmark+1)  
9d13 32 6f ee			ld (debug_mark+1),a  
9d16 3a 20 9d			ld a, (.dmark+2)  
9d19 32 70 ee			ld (debug_mark+2),a  
9d1c 18 03			jr .pastdmark  
9d1e ..			.dmark: db "DSP"  
9d21 f1			.pastdmark: pop af  
9d22			endm  
# End of macro DMARK
9d22			 
9d22 cd 36 cc				call display_data_sp 
9d25				;call break_point_state 
9d25				;rst 030h 
9d25				CALLMONITOR 
9d25 cd 72 ee			call debug_vector  
9d28				endm  
# End of macro CALLMONITOR
9d28				endif 
9d28			 
9d28 c9				ret 
9d29			 
9d29			; return hl to start of value on stack 
9d29			 
9d29			FORTH_DSP_VALUE: macro 
9d29				call macro_forth_dsp_value 
9d29				endm 
9d29			 
9d29			macro_forth_dsp_value: 
9d29			 
9d29				FORTH_DSP 
9d29 cd 06 9d			call macro_forth_dsp 
9d2c				endm 
# End of macro FORTH_DSP
9d2c			 
9d2c d5				push de 
9d2d			 
9d2d 23				inc hl ; skip type 
9d2e			 
9d2e 5e				ld e, (hl) 
9d2f 23				inc hl 
9d30 56				ld d, (hl) 
9d31 eb				ex de,hl  
9d32			 
9d32 d1				pop de 
9d33			 
9d33 c9				ret 
9d34			 
9d34			; return hl to start of value to second item on stack 
9d34			 
9d34			FORTH_DSP_VALUEM1: macro 
9d34				call macro_forth_dsp_value_m1 
9d34				endm 
9d34			 
9d34			macro_forth_dsp_value_m1: 
9d34			 
9d34				FORTH_DSP 
9d34 cd 06 9d			call macro_forth_dsp 
9d37				endm 
# End of macro FORTH_DSP
9d37			 
9d37 2b				dec hl 
9d38 2b				dec hl 
9d39			;	dec hl 
9d39			 
9d39 d5				push de 
9d3a			 
9d3a 5e				ld e, (hl) 
9d3b 23				inc hl 
9d3c 56				ld d, (hl) 
9d3d eb				ex de,hl  
9d3e			 
9d3e d1				pop de 
9d3f			 
9d3f c9				ret 
9d40			 
9d40				 
9d40			 
9d40			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d40			 
9d40			FORTH_DSP_POP: macro 
9d40				call macro_forth_dsp_pop 
9d40				endm 
9d40			 
9d40			 
9d40			; get the tos data type 
9d40			 
9d40			FORTH_DSP_TYPE:   macro 
9d40			 
9d40				;FORTH_DSP_VALUE 
9d40				FORTH_DSP 
9d40				 
9d40				; hl points to value 
9d40				; check type 
9d40			 
9d40				ld a,(hl) 
9d40			 
9d40				endm 
9d40			 
9d40			; load the tos value into hl 
9d40			 
9d40			 
9d40			FORTH_DSP_VALUEHL:  macro 
9d40				call macro_dsp_valuehl 
9d40				endm 
9d40			 
9d40			 
9d40			 
9d40			macro_dsp_valuehl: 
9d40				FORTH_DSP_VALUE 
9d40 cd 29 9d			call macro_forth_dsp_value 
9d43				endm 
# End of macro FORTH_DSP_VALUE
9d43			 
9d43				;FORTH_ERR_TOS_NOTNUM 
9d43			 
9d43				;inc hl   ; skip type id 
9d43			 
9d43			;	push de 
9d43			; 
9d43			;	ld e, (hl) 
9d43			;	inc hl 
9d43			;	ld d, (hl) 
9d43			;	ex de,hl  
9d43			 
9d43			;	pop de 
9d43			 
9d43				if DEBUG_FORTH_PUSH 
9d43						DMARK "DVL" 
9d43 f5				push af  
9d44 3a 58 9d			ld a, (.dmark)  
9d47 32 6e ee			ld (debug_mark),a  
9d4a 3a 59 9d			ld a, (.dmark+1)  
9d4d 32 6f ee			ld (debug_mark+1),a  
9d50 3a 5a 9d			ld a, (.dmark+2)  
9d53 32 70 ee			ld (debug_mark+2),a  
9d56 18 03			jr .pastdmark  
9d58 ..			.dmark: db "DVL"  
9d5b f1			.pastdmark: pop af  
9d5c			endm  
# End of macro DMARK
9d5c				CALLMONITOR 
9d5c cd 72 ee			call debug_vector  
9d5f				endm  
# End of macro CALLMONITOR
9d5f				endif 
9d5f c9				ret 
9d60			 
9d60			forth_apushstrhl:      
9d60				; push of string requires use of cli_origptr 
9d60				; bodge use 
9d60			 
9d60				; get current cli_origptr, save, update with temp pointer  
9d60 ed 5b 41 ea		ld de, (cli_origptr) 
9d64 22 41 ea			ld (cli_origptr), hl 
9d67 d5				push de 
9d68 cd b2 9c			call forth_apush 
9d6b d1				pop de 
9d6c ed 53 41 ea		ld (cli_origptr), de 
9d70 c9			        ret	 
9d71			 
9d71			 
9d71			; increase loop stack pointer and save hl to it 
9d71				 
9d71			FORTH_LOOP_NEXT: macro 
9d71				call macro_forth_loop_next 
9d71				;nop 
9d71				endm 
9d71			 
9d71			macro_forth_loop_next: 
9d71				if DEBUG_FORTH_STACK_GUARD 
9d71 cd c4 df				call check_stacks 
9d74				endif 
9d74 e5				push hl 
9d75 d5				push de 
9d76 eb				ex de,hl 
9d77 2a f3 e9			ld hl,(cli_loop_sp) 
9d7a 23				inc hl 
9d7b 23				inc hl 
9d7c					if DEBUG_FORTH_WORDS 
9d7c						DMARK "LNX" 
9d7c f5				push af  
9d7d 3a 91 9d			ld a, (.dmark)  
9d80 32 6e ee			ld (debug_mark),a  
9d83 3a 92 9d			ld a, (.dmark+1)  
9d86 32 6f ee			ld (debug_mark+1),a  
9d89 3a 93 9d			ld a, (.dmark+2)  
9d8c 32 70 ee			ld (debug_mark+2),a  
9d8f 18 03			jr .pastdmark  
9d91 ..			.dmark: db "LNX"  
9d94 f1			.pastdmark: pop af  
9d95			endm  
# End of macro DMARK
9d95						CALLMONITOR 
9d95 cd 72 ee			call debug_vector  
9d98				endm  
# End of macro CALLMONITOR
9d98					endif 
9d98 22 f3 e9			ld (cli_loop_sp),hl 
9d9b 73				ld (hl), e 
9d9c 23				inc hl 
9d9d 72				ld (hl), d 
9d9e d1				pop de    ; been reversed so save a swap on restore 
9d9f e1				pop hl 
9da0				if DEBUG_FORTH_STACK_GUARD 
9da0 cd c4 df				call check_stacks 
9da3				endif 
9da3 c9				ret 
9da4			 
9da4			; get current ret stack pointer and save to hl  
9da4				 
9da4			FORTH_LOOP_TOS: macro 
9da4				call macro_forth_loop_tos 
9da4				endm 
9da4			 
9da4			macro_forth_loop_tos: 
9da4 d5				push de 
9da5 2a f3 e9			ld hl,(cli_loop_sp) 
9da8 5e				ld e, (hl) 
9da9 23				inc hl 
9daa 56				ld d, (hl) 
9dab eb				ex de, hl 
9dac d1				pop de 
9dad c9				ret 
9dae			 
9dae			; pop loop stack pointer 
9dae				 
9dae			FORTH_LOOP_POP: macro 
9dae				call macro_forth_loop_pop 
9dae				endm 
9dae			 
9dae			 
9dae			macro_forth_loop_pop: 
9dae				if DEBUG_FORTH_STACK_GUARD 
9dae					DMARK "LPP" 
9dae f5				push af  
9daf 3a c3 9d			ld a, (.dmark)  
9db2 32 6e ee			ld (debug_mark),a  
9db5 3a c4 9d			ld a, (.dmark+1)  
9db8 32 6f ee			ld (debug_mark+1),a  
9dbb 3a c5 9d			ld a, (.dmark+2)  
9dbe 32 70 ee			ld (debug_mark+2),a  
9dc1 18 03			jr .pastdmark  
9dc3 ..			.dmark: db "LPP"  
9dc6 f1			.pastdmark: pop af  
9dc7			endm  
# End of macro DMARK
9dc7 cd c4 df				call check_stacks 
9dca					FORTH_CHK_LOOP_UNDER 
9dca e5				push hl 
9dcb d5				push de 
9dcc 2a f3 e9			ld hl,(cli_loop_sp) 
9dcf 11 2d e9			ld de, cli_loop_stack 
9dd2 cd fa 8c			call cmp16 
9dd5 da de e0			jp c, fault_loop_under 
9dd8 d1				pop de 
9dd9 e1				pop hl 
9dda				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dda				endif 
9dda e5				push hl 
9ddb 2a f3 e9			ld hl,(cli_loop_sp) 
9dde 2b				dec hl 
9ddf 2b				dec hl 
9de0 22 f3 e9			ld (cli_loop_sp), hl 
9de3				; TODO do stack underflow checks 
9de3 e1				pop hl 
9de4				if DEBUG_FORTH_STACK_GUARD 
9de4 cd c4 df				call check_stacks 
9de7					FORTH_CHK_LOOP_UNDER 
9de7 e5				push hl 
9de8 d5				push de 
9de9 2a f3 e9			ld hl,(cli_loop_sp) 
9dec 11 2d e9			ld de, cli_loop_stack 
9def cd fa 8c			call cmp16 
9df2 da de e0			jp c, fault_loop_under 
9df5 d1				pop de 
9df6 e1				pop hl 
9df7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9df7				endif 
9df7 c9				ret 
9df8			 
9df8			macro_forth_dsp_pop: 
9df8			 
9df8 e5				push hl 
9df9			 
9df9				; release malloc data 
9df9			 
9df9				if DEBUG_FORTH_STACK_GUARD 
9df9 cd c4 df				call check_stacks 
9dfc					FORTH_CHK_DSP_UNDER 
9dfc e5				push hl 
9dfd d5				push de 
9dfe 2a f1 e9			ld hl,(cli_data_sp) 
9e01 11 2b e8			ld de, cli_data_stack 
9e04 cd fa 8c			call cmp16 
9e07 da d2 e0			jp c, fault_dsp_under 
9e0a d1				pop de 
9e0b e1				pop hl 
9e0c				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e0c				endif 
9e0c				;ld hl,(cli_data_sp) 
9e0c			if DEBUG_FORTH_DOT 
9e0c				DMARK "DPP" 
9e0c f5				push af  
9e0d 3a 21 9e			ld a, (.dmark)  
9e10 32 6e ee			ld (debug_mark),a  
9e13 3a 22 9e			ld a, (.dmark+1)  
9e16 32 6f ee			ld (debug_mark+1),a  
9e19 3a 23 9e			ld a, (.dmark+2)  
9e1c 32 70 ee			ld (debug_mark+2),a  
9e1f 18 03			jr .pastdmark  
9e21 ..			.dmark: db "DPP"  
9e24 f1			.pastdmark: pop af  
9e25			endm  
# End of macro DMARK
9e25				CALLMONITOR 
9e25 cd 72 ee			call debug_vector  
9e28				endm  
# End of macro CALLMONITOR
9e28			endif	 
9e28			 
9e28			 
9e28			if FORTH_ENABLE_DSPPOPFREE 
9e28			 
9e28				FORTH_DSP 
9e28 cd 06 9d			call macro_forth_dsp 
9e2b				endm 
# End of macro FORTH_DSP
9e2b			 
9e2b 7e				ld a, (hl) 
9e2c fe 01			cp DS_TYPE_STR 
9e2e 20 23			jr nz, .skippopfree 
9e30			 
9e30				FORTH_DSP_VALUEHL 
9e30 cd 40 9d			call macro_dsp_valuehl 
9e33				endm 
# End of macro FORTH_DSP_VALUEHL
9e33 00				nop 
9e34			if DEBUG_FORTH_DOT 
9e34				DMARK "DPf" 
9e34 f5				push af  
9e35 3a 49 9e			ld a, (.dmark)  
9e38 32 6e ee			ld (debug_mark),a  
9e3b 3a 4a 9e			ld a, (.dmark+1)  
9e3e 32 6f ee			ld (debug_mark+1),a  
9e41 3a 4b 9e			ld a, (.dmark+2)  
9e44 32 70 ee			ld (debug_mark+2),a  
9e47 18 03			jr .pastdmark  
9e49 ..			.dmark: db "DPf"  
9e4c f1			.pastdmark: pop af  
9e4d			endm  
# End of macro DMARK
9e4d				CALLMONITOR 
9e4d cd 72 ee			call debug_vector  
9e50				endm  
# End of macro CALLMONITOR
9e50			endif	 
9e50 cd 6d 92			call free 
9e53			.skippopfree: 
9e53				 
9e53			 
9e53			endif 
9e53			 
9e53			if DEBUG_FORTH_DOT_KEY 
9e53				DMARK "DP2" 
9e53				CALLMONITOR 
9e53			endif	 
9e53			 
9e53				; move pointer down 
9e53			 
9e53 2a f1 e9			ld hl,(cli_data_sp) 
9e56 2b				dec hl 
9e57 2b				dec hl 
9e58			; PARSEV5 
9e58 2b				dec hl 
9e59 22 f1 e9			ld (cli_data_sp), hl 
9e5c			 
9e5c				if DEBUG_FORTH_STACK_GUARD 
9e5c cd c4 df				call check_stacks 
9e5f					FORTH_CHK_DSP_UNDER 
9e5f e5				push hl 
9e60 d5				push de 
9e61 2a f1 e9			ld hl,(cli_data_sp) 
9e64 11 2b e8			ld de, cli_data_stack 
9e67 cd fa 8c			call cmp16 
9e6a da d2 e0			jp c, fault_dsp_under 
9e6d d1				pop de 
9e6e e1				pop hl 
9e6f				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e6f				endif 
9e6f			 
9e6f e1				pop hl 
9e70			 
9e70 c9				ret 
9e71			 
9e71			getwordathl: 
9e71				; hl points to an address 
9e71				; load hl with the word at that address 
9e71			 
9e71 d5				push de 
9e72			 
9e72 5e				ld e, (hl) 
9e73 23				inc hl 
9e74 56				ld d, (hl) 
9e75 eb				ex de, hl 
9e76			 
9e76 d1				pop de 
9e77 c9				ret 
9e78			 
9e78			 
9e78			 
9e78			 
9e78			 
9e78			; eof 
9e78			 
# End of file forth_stackopsv5.asm
9e78			endif 
9e78			 
9e78			loadwordinhl:	 
9e78			 
9e78 d5				push de 
9e79			 
9e79 5e				ld e, (hl) 
9e7a 23				inc hl 
9e7b 56				ld d, (hl) 
9e7c eb				ex de,hl  
9e7d			 
9e7d d1				pop de 
9e7e			 
9e7e c9				ret 
9e7f			 
9e7f			user_word_eol:  
9e7f				; hl contains the pointer to where to create a linked list item from the end 
9e7f				; of the user dict to continue on at the system word dict 
9e7f				 
9e7f				; poke the stub of the word list linked list to repoint to rom words 
9e7f			 
9e7f				; stub format 
9e7f				; db   word id 
9e7f				; dw    link to next word 
9e7f			        ; db char length of token 
9e7f				; db string + 0 term 
9e7f				; db exec code....  
9e7f			 
9e7f 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e81 77				ld (hl), a		; word id 
9e82 23				inc hl 
9e83			 
9e83 11 4e a0			ld de, sysdict 
9e86 73				ld (hl), e		; next word link ie system dict 
9e87 23				inc hl 
9e88 72				ld (hl), d		; next word link ie system dict 
9e89 23				inc hl	 
9e8a			 
9e8a			;	ld (hl), sysdict		; next word link ie system dict 
9e8a			;	inc hl 
9e8a			;	inc hl 
9e8a			 
9e8a			;	inc hl 
9e8a			;	inc hl 
9e8a			 
9e8a 3e 02			ld a, 2			; word length is 0 
9e8c 77				ld (hl), a	 
9e8d 23				inc hl 
9e8e			 
9e8e 3e 7e			ld a, '~'			; word length is 0 
9e90 77				ld (hl), a	 
9e91 23				inc hl 
9e92 3e 00			ld a, 0			; save empty word 
9e94 77				ld (hl), a 
9e95			 
9e95 c9				ret 
9e96			 
9e96				 
9e96			 
9e96			forthexec_cleanup: 
9e96				FORTH_RSP_POP 
9e96 cd 11 9b			call macro_forth_rsp_pop 
9e99				endm 
# End of macro FORTH_RSP_POP
9e99 c9				ret 
9e9a			 
9e9a			forth_call_hl: 
9e9a				; taking hl 
9e9a e5				push hl 
9e9b c9				ret 
9e9c			 
9e9c			; this is called to reset Forth system but keep existing uwords etc 
9e9c			 
9e9c			forth_warmstart: 
9e9c				; setup stack over/under flow checks 
9e9c				if DEBUG_FORTH_STACK_GUARD 
9e9c cd aa df				call chk_stk_init 
9e9f				endif 
9e9f			 
9e9f				; init stack pointers  - * these stacks go upwards *  
9e9f 21 af e9			ld hl, cli_ret_stack 
9ea2 22 f5 e9			ld (cli_ret_sp), hl	 
9ea5				; set bottom of stack 
9ea5 3e 00			ld a,0 
9ea7 77				ld (hl),a 
9ea8 23				inc hl 
9ea9 77				ld (hl),a 
9eaa			 
9eaa 21 2b e8			ld hl, cli_data_stack 
9ead 22 f1 e9			ld (cli_data_sp), hl	 
9eb0				; set bottom of stack 
9eb0 3e 00			ld a,0 
9eb2 77				ld (hl),a 
9eb3 23				inc hl 
9eb4 77				ld (hl),a 
9eb5			 
9eb5 21 2d e9			ld hl, cli_loop_stack 
9eb8 22 f3 e9			ld (cli_loop_sp), hl	 
9ebb				; set bottom of stack 
9ebb 3e 00			ld a,0 
9ebd 77				ld (hl),a 
9ebe 23				inc hl 
9ebf 77				ld (hl),a 
9ec0			 
9ec0				; init extent of current open file 
9ec0			 
9ec0 3e 00			ld a, 0 
9ec2 32 6d ea			ld (store_openext), a 
9ec5			 
9ec5 c9				ret 
9ec6			 
9ec6			 
9ec6			 
9ec6			; Cold Start - this is called to setup the whole Forth system 
9ec6			 
9ec6			forth_init: 
9ec6			 
9ec6				; setup stack over/under flow checks 
9ec6			 
9ec6			;	if DEBUG_FORTH_STACK_GUARD 
9ec6			;		call chk_stk_init 
9ec6			;	endif 
9ec6			 
9ec6				; enable auto display updates (slow.....) 
9ec6			 
9ec6 3e 01			ld a, 1 
9ec8 32 3f ea			ld (cli_autodisplay), a 
9ecb			 
9ecb				; if storage is in use disable long reads for now 
9ecb 3e 00			ld a, 0 
9ecd 32 78 ea			ld (store_longread), a 
9ed0			 
9ed0			 
9ed0				; show start up screen 
9ed0			 
9ed0 cd af 8a			call clear_display 
9ed3			 
9ed3 3e 00			ld a,0 
9ed5 32 61 ea			ld (f_cursor_ptr), a 
9ed8			 
9ed8				; set start of word list in start of ram - for use when creating user words 
9ed8			 
9ed8 21 4b e3			ld hl, baseram 
9edb 22 c1 e5			ld (os_last_new_uword), hl 
9ede cd 7f 9e			call user_word_eol 
9ee1				 
9ee1			;		call display_data_sp 
9ee1			;		call next_page_prompt 
9ee1			 
9ee1			 
9ee1			 
9ee1			 
9ee1 c9				ret 
9ee2			 
9ee2 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ef6			 
9ef6			; TODO push to stack 
9ef6			 
9ef6			;  
9ef6			 
9ef6			if FORTH_PARSEV2 
9ef6			 
9ef6			 
9ef6				include "forth_parserv2.asm" 
9ef6			 
9ef6			endif 
9ef6			 
9ef6			 
9ef6			; parse cli version 1 
9ef6			 
9ef6			if FORTH_PARSEV1 
9ef6			 
9ef6			 
9ef6			 
9ef6			      include "forth_parserv1.asm" 
9ef6			endif 
9ef6				 
9ef6			if FORTH_PARSEV3 
9ef6			 
9ef6			 
9ef6			 
9ef6			      include "forth_parserv3.asm" 
9ef6				include "forth_wordsv3.asm" 
9ef6			endif 
9ef6			 
9ef6			if FORTH_PARSEV4 
9ef6			 
9ef6			 
9ef6			 
9ef6			      include "forth_parserv4.asm" 
9ef6				include "forth_wordsv4.asm" 
9ef6			endif 
9ef6			 
9ef6			if FORTH_PARSEV5 
9ef6			 
9ef6			 
9ef6			 
9ef6			      include "forth_parserv5.asm" 
9ef6			 
9ef6			 
9ef6			; A better parser without using malloc and string copies all over the place.  
9ef6			; Exec in situ should be faster 
9ef6			 
9ef6			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ef6			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ef6			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ef6			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ef6			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ef6			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ef6			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ef6			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ef6			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ef6			 
9ef6			; Core word preamble macro 
9ef6			 
9ef6			CWHEAD:   macro nxtword opcode lit len opflags 
9ef6				db WORD_SYS_CORE+opcode             
9ef6				; internal op code number 
9ef6				dw nxtword            
9ef6				; link to next dict word block 
9ef6				db len + 1 
9ef6				; literal length of dict word inc zero term 
9ef6				db lit,0              
9ef6				; literal dict word 
9ef6			        ; TODO db opflags        
9ef6				endm 
9ef6			 
9ef6			 
9ef6			NEXTW: macro  
9ef6				jp macro_next 
9ef6				endm 
9ef6			 
9ef6			macro_next: 
9ef6			if DEBUG_FORTH_PARSE_KEY 
9ef6				DMARK "NXT" 
9ef6				CALLMONITOR 
9ef6			endif	 
9ef6			;	inc hl  ; skip token null term  
9ef6 ed 4b 43 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9efa ed 5b 41 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9efe 2a c5 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f01			if DEBUG_FORTH_PARSE_KEY 
9f01				DMARK "}AA" 
9f01				CALLMONITOR 
9f01			endif	 
9f01 c3 04 a0			jp execnext 
9f04				;jp exec1 
9f04			       
9f04			 
9f04			 
9f04			; Another go at the parser to compile  
9f04			 
9f04			 
9f04			; TODO rework parser to change all of the string words to byte tokens 
9f04			; TODO do a search for  
9f04			 
9f04			; TODO first run normal parser to zero term sections 
9f04			; TODO for each word do a token look up to get the op code 
9f04			; TODO need some means to flag to the exec that this is a byte code form    
9f04			 
9f04			 
9f04			forthcompile: 
9f04			 
9f04			; 
9f04			; line parse: 
9f04			;       parse raw input buffer 
9f04			;       tokenise the words 
9f04			;       malloc new copy (for looping etc) 
9f04			;       copy to malloc + current pc in line to start of string and add line term 
9f04			;       save on new rsp 
9f04			; 
9f04			 
9f04			; hl to point to the line to tokenise 
9f04			 
9f04			;	push hl 
9f04 22 c5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f07			 
9f07			;	ld a,0		; string term on input 
9f07			;	call strlent 
9f07			 
9f07			;	ld (os_tok_len), hl	 ; save string length 
9f07			 
9f07			;if DEBUG_FORTH_TOK 
9f07			;	ex de,hl		 
9f07			;endif 
9f07			 
9f07			;	pop hl 		; get back string pointer 
9f07			 
9f07			if DEBUG_FORTH_TOK 
9f07						DMARK "TOc" 
9f07				CALLMONITOR 
9f07			endif 
9f07 7e			.cptoken2:    ld a,(hl) 
9f08 23				inc hl 
9f09 fe 7f			cp FORTH_END_BUFFER 
9f0b 28 29			jr z, .cptokendone2 
9f0d fe 00			cp 0 
9f0f 28 25			jr z, .cptokendone2 
9f11 fe 22			cp '"' 
9f13 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f15 fe 20			cp ' ' 
9f17 20 ee			jr nz,  .cptoken2 
9f19			 
9f19			; TODO consume comments held between ( and ) 
9f19			 
9f19				; we have a space so change to zero term for dict match later 
9f19 2b				dec hl 
9f1a 3e 00			ld a,0 
9f1c 77				ld (hl), a 
9f1d 23				inc hl 
9f1e 18 e7			jr .cptoken2 
9f20				 
9f20			 
9f20			.cptokenstr2: 
9f20				; skip all white space until either eol (because forgot to term) or end double quote 
9f20			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f20				;inc hl ; skip current double quote 
9f20 7e				ld a,(hl) 
9f21 23				inc hl 
9f22 fe 22			cp '"' 
9f24 28 e1			jr z, .cptoken2 
9f26 fe 7f			cp FORTH_END_BUFFER 
9f28 28 0c			jr z, .cptokendone2 
9f2a fe 00			cp 0 
9f2c 28 08			jr z, .cptokendone2 
9f2e fe 20			cp ' ' 
9f30 28 02			jr z, .cptmp2 
9f32 18 ec			jr .cptokenstr2 
9f34			 
9f34			.cptmp2:	; we have a space so change to zero term for dict match later 
9f34				;dec hl 
9f34				;ld a,"-"	; TODO remove this when working 
9f34				;ld (hl), a 
9f34				;inc hl 
9f34 18 ea			jr .cptokenstr2 
9f36			 
9f36			.cptokendone2: 
9f36				;inc hl 
9f36 3e 7f			ld a, FORTH_END_BUFFER 
9f38 77				ld (hl),a 
9f39 23				inc hl 
9f3a 3e 21			ld a, '!' 
9f3c 77				ld (hl),a 
9f3d			 
9f3d 2a c5 e5			ld hl,(os_tok_ptr) 
9f40			         
9f40			if DEBUG_FORTH_TOK 
9f40						DMARK "Tc1" 
9f40				CALLMONITOR 
9f40			endif 
9f40			 
9f40				; push exec string to top of return stack 
9f40				FORTH_RSP_NEXT 
9f40 cd f0 9a			call macro_forth_rsp_next 
9f43				endm 
# End of macro FORTH_RSP_NEXT
9f43 c9				ret 
9f44			 
9f44			; Another go at the parser need to simplify the process 
9f44			 
9f44			forthparse: 
9f44			 
9f44			; 
9f44			; line parse: 
9f44			;       parse raw input buffer 
9f44			;       tokenise the words 
9f44			;       malloc new copy (for looping etc) 
9f44			;       copy to malloc + current pc in line to start of string and add line term 
9f44			;       save on new rsp 
9f44			; 
9f44			 
9f44			; hl to point to the line to tokenise 
9f44			 
9f44			;	push hl 
9f44 22 c5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f47			 
9f47			;	ld a,0		; string term on input 
9f47			;	call strlent 
9f47			 
9f47			;	ld (os_tok_len), hl	 ; save string length 
9f47			 
9f47			;if DEBUG_FORTH_TOK 
9f47			;	ex de,hl		 
9f47			;endif 
9f47			 
9f47			;	pop hl 		; get back string pointer 
9f47			 
9f47			if DEBUG_FORTH_TOK 
9f47						DMARK "TOK" 
9f47				CALLMONITOR 
9f47			endif 
9f47 7e			.ptoken2:    ld a,(hl) 
9f48 23				inc hl 
9f49 fe 7f			cp FORTH_END_BUFFER 
9f4b 28 29			jr z, .ptokendone2 
9f4d fe 00			cp 0 
9f4f 28 25			jr z, .ptokendone2 
9f51 fe 22			cp '"' 
9f53 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f55 fe 20			cp ' ' 
9f57 20 ee			jr nz,  .ptoken2 
9f59			 
9f59			; TODO consume comments held between ( and ) 
9f59			 
9f59				; we have a space so change to zero term for dict match later 
9f59 2b				dec hl 
9f5a 3e 00			ld a,0 
9f5c 77				ld (hl), a 
9f5d 23				inc hl 
9f5e 18 e7			jr .ptoken2 
9f60				 
9f60			 
9f60			.ptokenstr2: 
9f60				; skip all white space until either eol (because forgot to term) or end double quote 
9f60			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f60				;inc hl ; skip current double quote 
9f60 7e				ld a,(hl) 
9f61 23				inc hl 
9f62 fe 22			cp '"' 
9f64 28 e1			jr z, .ptoken2 
9f66 fe 7f			cp FORTH_END_BUFFER 
9f68 28 0c			jr z, .ptokendone2 
9f6a fe 00			cp 0 
9f6c 28 08			jr z, .ptokendone2 
9f6e fe 20			cp ' ' 
9f70 28 02			jr z, .ptmp2 
9f72 18 ec			jr .ptokenstr2 
9f74			 
9f74			.ptmp2:	; we have a space so change to zero term for dict match later 
9f74				;dec hl 
9f74				;ld a,"-"	; TODO remove this when working 
9f74				;ld (hl), a 
9f74				;inc hl 
9f74 18 ea			jr .ptokenstr2 
9f76			 
9f76			.ptokendone2: 
9f76				;inc hl 
9f76 3e 7f			ld a, FORTH_END_BUFFER 
9f78 77				ld (hl),a 
9f79 23				inc hl 
9f7a 3e 21			ld a, '!' 
9f7c 77				ld (hl),a 
9f7d			 
9f7d 2a c5 e5			ld hl,(os_tok_ptr) 
9f80			         
9f80			if DEBUG_FORTH_TOK 
9f80						DMARK "TK1" 
9f80				CALLMONITOR 
9f80			endif 
9f80			 
9f80				; push exec string to top of return stack 
9f80				FORTH_RSP_NEXT 
9f80 cd f0 9a			call macro_forth_rsp_next 
9f83				endm 
# End of macro FORTH_RSP_NEXT
9f83 c9				ret 
9f84			 
9f84			; 
9f84			;	; malloc size + buffer pointer + if is loop flag 
9f84			;	ld hl,(os_tok_len) 		 ; get string length 
9f84			; 
9f84			;	ld a,l 
9f84			; 
9f84			;	cp 0			; we dont want to use a null string 
9f84			;	ret z 
9f84			; 
9f84			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f84			; 
9f84			;	add 5     ; TODO when certain not over writing memory remove 
9f84			; 
9f84			;		 
9f84			; 
9f84			;if DEBUG_FORTH_TOK 
9f84			;			DMARK "TKE" 
9f84			;	CALLMONITOR 
9f84			;endif 
9f84			; 
9f84			;	ld l,a 
9f84			;	ld h,0 
9f84			;;	push hl   ; save required space for the copy later 
9f84			;	call malloc 
9f84			;if DEBUG_FORTH_TOK 
9f84			;			DMARK "TKM" 
9f84			;	CALLMONITOR 
9f84			;endif 
9f84			;	if DEBUG_FORTH_MALLOC_GUARD 
9f84			;		push af 
9f84			;		call ishlzero 
9f84			;;		ld a, l 
9f84			;;		add h 
9f84			;;		cp 0 
9f84			;		pop af 
9f84			;		 
9f84			;		call z,malloc_error 
9f84			;	endif 
9f84			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f84			; 
9f84			; 
9f84			;if DEBUG_FORTH_TOK 
9f84			;			DMARK "TKR" 
9f84			;	CALLMONITOR 
9f84			;endif 
9f84			; 
9f84			;	FORTH_RSP_NEXT 
9f84			; 
9f84			;	;inc hl	 ; go past current buffer pointer 
9f84			;	;inc hl 
9f84			;	;inc hl   ; and past if loop flag 
9f84			;		; TODO Need to set flag  
9f84			; 
9f84			;	 
9f84			;	 
9f84			;	ex de,hl	; malloc is dest 
9f84			;	ld hl, (os_tok_len) 
9f84			;;	pop bc 
9f84			;	ld c, l                
9f84			;	ld b,0 
9f84			;	ld hl, (os_tok_ptr) 
9f84			; 
9f84			;if DEBUG_FORTH_TOK 
9f84			;			DMARK "TKT" 
9f84			;	CALLMONITOR 
9f84			;endif 
9f84			; 
9f84			;	; do str cpy 
9f84			; 
9f84			;	ldir      ; copy byte in hl to de 
9f84			; 
9f84			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f84			; 
9f84			;if DEBUG_FORTH_TOK 
9f84			; 
9f84			;			DMARK "TKY" 
9f84			;	CALLMONITOR 
9f84			;endif 
9f84			;	;ld a,0 
9f84			;	;ld a,FORTH_END_BUFFER 
9f84			;	ex de, hl 
9f84			;	;dec hl			 ; go back over the space delim at the end of word 
9f84			;	;ld (hl),a 
9f84			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f84			;	ld a,FORTH_END_BUFFER 
9f84			;	ld (hl),a 
9f84			;	inc hl 
9f84			;	ld a,FORTH_END_BUFFER 
9f84			;	ld (hl),a 
9f84			; 
9f84			;	; init the malloc area data 
9f84			;	; set pc for in current area 
9f84			;	;ld hl, (os_tok_malloc) 
9f84			;	;inc hl 
9f84			;	;inc hl 
9f84			;	;inc hl 
9f84			;	;ex de,hl 
9f84			;	;ld hl, (os_tok_malloc) 
9f84			;	;ld (hl),e 
9f84			;	;inc hl 
9f84			;	;ld (hl),d 
9f84			; 
9f84			; 
9f84			;	ld hl,(os_tok_malloc) 
9f84			;if DEBUG_FORTH_PARSE_KEY 
9f84			;			DMARK "TKU" 
9f84			;	CALLMONITOR 
9f84			;endif 
9f84			; 
9f84			;	ret 
9f84			 
9f84			forthexec: 
9f84			 
9f84			; line exec: 
9f84			; forth parser 
9f84			 
9f84			; 
9f84			;       get current exec line on rsp 
9f84			 
9f84				FORTH_RSP_TOS 
9f84 cd 07 9b			call macro_forth_rsp_tos 
9f87				endm 
# End of macro FORTH_RSP_TOS
9f87			 
9f87			;       restore current pc - hl points to malloc of data 
9f87			 
9f87				;ld e, (hl) 
9f87				;inc hl 
9f87				;ld d, (hl) 
9f87				;ex de,hl 
9f87			 
9f87			 
9f87			exec1: 
9f87 22 c5 e5			ld (os_tok_ptr), hl 
9f8a			 
9f8a				; copy our PC to working vars  
9f8a 22 43 ea			ld (cli_ptr), hl 
9f8d 22 41 ea			ld (cli_origptr), hl 
9f90			 
9f90 7e				ld a,(hl) 
9f91 fe 7f			cp FORTH_END_BUFFER 
9f93 c8				ret z 
9f94			 
9f94				; skip any nulls 
9f94			 
9f94 fe 00			cp 0 
9f96 20 03			jr nz, .execword 
9f98 23				inc hl 
9f99 18 ec			jr exec1 
9f9b			 
9f9b			 
9f9b			.execword: 
9f9b			 
9f9b			 
9f9b			 
9f9b			if DEBUG_FORTH_PARSE_KEY 
9f9b						DMARK "KYQ" 
9f9b				CALLMONITOR 
9f9b			endif 
9f9b			;       while at start of word: 
9f9b			; get start of dict (in user area first) 
9f9b			 
9f9b 21 4b e3		ld hl, baseram 
9f9e			;ld hl, sysdict 
9f9e 22 45 ea		ld (cli_nextword),hl 
9fa1			;           match word at pc 
9fa1			;           exec word 
9fa1			;           or push to dsp 
9fa1			;           forward to next token 
9fa1			;           if line term pop rsp and exit 
9fa1			;        
9fa1			 
9fa1			if DEBUG_FORTH_PARSE_KEY 
9fa1						DMARK "KYq" 
9fa1				CALLMONITOR 
9fa1			endif 
9fa1			 
9fa1			; 
9fa1			; word comp 
9fa1			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9fa1			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9fa1			;    move to start of word  
9fa1			;    compare word to cli_token 
9fa1			 
9fa1			.execpnword:	; HL at start of a word in the dictionary to check 
9fa1			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9fa1			;	ld (cli_ptr), hl 
9fa1			 
9fa1 2a 45 ea			ld hl,(cli_nextword) 
9fa4			 
9fa4 cd 47 a0			call forth_tok_next 
9fa7			; tok next start here 
9fa7			;	; TODO skip compiled symbol for now 
9fa7			;	inc hl 
9fa7			; 
9fa7			;	; save pointer to next word 
9fa7			; 
9fa7			;	; hl now points to the address of the next word pointer  
9fa7			;	ld e, (hl) 
9fa7			;	inc hl 
9fa7			;	ld d, (hl) 
9fa7			;	inc l 
9fa7			; 
9fa7			;	ex de,hl 
9fa7			;if DEBUG_FORTH_PARSE_NEXTWORD 
9fa7			;	push bc 
9fa7			;	ld bc, (cli_nextword) 
9fa7			;			DMARK "NXW" 
9fa7			;	CALLMONITOR 
9fa7			;	pop bc 
9fa7			;endif 
9fa7			; tok next end here 
9fa7 22 45 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9faa eb				ex de, hl 
9fab			 
9fab			 
9fab				; save the pointer of the current token - 1 to check against 
9fab				 
9fab 22 49 ea			ld (cli_token), hl   
9fae				; TODO maybe remove below save if no debug 
9fae				; save token string ptr for any debug later 
9fae 23				inc hl  
9faf 22 4b ea			ld (cli_origtoken), hl 
9fb2 2b				dec hl 
9fb3				; save pointer to the start of the next dictionay word 
9fb3 7e				ld a,(hl)   ; get string length 
9fb4 47				ld b,a 
9fb5			.execpnwordinc:  
9fb5 23				inc hl 
9fb6 10 fd			djnz .execpnwordinc 
9fb8 22 47 ea			ld (cli_execword), hl      ; save start of this words code 
9fbb			 
9fbb				; now check the word token against the string being parsed 
9fbb			 
9fbb 2a 49 ea			ld hl,(cli_token) 
9fbe 23				inc hl     ; skip string length (use zero term instead to end) 
9fbf 22 49 ea			ld (cli_token), hl 
9fc2			 
9fc2			if DEBUG_FORTH_PARSE_KEY 
9fc2						DMARK "KY2" 
9fc2			endif 
9fc2			if DEBUG_FORTH_PARSE_EXEC 
9fc2				; see if disabled 
9fc2			 
9fc2			;	ld a, (os_view_disable) 
9fc2			;	cp '*' 
9fc2				ld a, (debug_vector) 
9fc2				cp $c9   ; RET  
9fc2				jr z, .skip 
9fc2			 
9fc2				push hl 
9fc2				push hl 
9fc2				call clear_display 
9fc2				ld de, .compword 
9fc2				ld a, display_row_1 
9fc2				call str_at_display 
9fc2				pop de 
9fc2				ld a, display_row_2 
9fc2				call str_at_display 
9fc2				ld hl,(cli_ptr) 
9fc2				ld a,(hl) 
9fc2			        ld hl, os_word_scratch 
9fc2				ld (hl),a 
9fc2				ld a,0 
9fc2				inc hl 
9fc2				ld (hl),a 	 
9fc2				ld de, os_word_scratch 
9fc2				ld a, display_row_2+10 
9fc2				call str_at_display 
9fc2				call update_display 
9fc2				ld a, 100 
9fc2				call aDelayInMS 
9fc2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc2				call delay250ms 
9fc2				endif 
9fc2				pop hl 
9fc2			.skip:  
9fc2			endif	 
9fc2			.execpnchar:    ; compare char between token and string to parse 
9fc2			 
9fc2			if DEBUG_FORTH_PARSE_KEY 
9fc2						DMARK "Ky3" 
9fc2			endif 
9fc2			if DEBUG_FORTH_PARSE_EXEC 
9fc2				; see if disabled 
9fc2			 
9fc2			;	ld a, (os_view_disable) 
9fc2			;	cp '*' 
9fc2				ld a, (debug_vector) 
9fc2				cp $C9  ; RET 
9fc2				jr z, .skip2 
9fc2			 
9fc2			;	call clear_display 
9fc2			ld hl,(cli_token) 
9fc2			ld a,(hl) 
9fc2			ld (os_word_scratch),a 
9fc2				ld hl,(cli_ptr) 
9fc2			ld a,(hl) 
9fc2				ld (os_word_scratch+1),a 
9fc2				ld a,0 
9fc2				ld (os_word_scratch+2),a 
9fc2				ld de,os_word_scratch 
9fc2				ld a,display_row_4 
9fc2				call str_at_display 
9fc2				call update_display 
9fc2			.skip2:  
9fc2			endif 
9fc2 2a 49 ea			ld hl,(cli_token) 
9fc5 7e				ld a, (hl)	 ; char in word token 
9fc6 23				inc hl 		; move to next char 
9fc7 22 49 ea			ld (cli_token), hl ; and save it 
9fca 47				ld b,a 
9fcb			 
9fcb 2a 43 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fce 7e				ld a,(hl) 
9fcf 23				inc hl 
9fd0 22 43 ea			ld (cli_ptr), hl		; move to next char 
9fd3 cd 31 91			call toUpper 		; make sure the input string matches case 
9fd6			 
9fd6			if DEBUG_FORTH_PARSE 
9fd6			endif 
9fd6			 
9fd6				; input stream end of token is a space so get rid of it 
9fd6			 
9fd6			;	cp ' ' 
9fd6			;	jr nz, .pnskipspace 
9fd6			; 
9fd6			;	ld a, 0		; make same term as word token term 
9fd6			; 
9fd6			;.pnskipspace: 
9fd6			 
9fd6			if DEBUG_FORTH_PARSE_KEY 
9fd6						DMARK "KY7" 
9fd6			endif 
9fd6 b8				cp b 
9fd7 c2 ed 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fda				 
9fda			;    if same 
9fda			;       scan for string terms 0 for token and 32 for input 
9fda			 
9fda				 
9fda			if DEBUG_FORTH_PARSE_KEY 
9fda						DMARK "KY8" 
9fda			endif 
9fda			 
9fda 80				add b			 
9fdb fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fdd							; TODO need to make sure last word in zero term string is accounted for 
9fdd 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fdf			 
9fdf			 
9fdf				; at end of both strings so both are exact match 
9fdf			 
9fdf			;       skip ptr for next word 
9fdf			 
9fdf 2a 43 ea			ld hl,(cli_ptr) 	; at input string term 
9fe2 23				inc hl			 ; at next char 
9fe3 22 43 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fe6 22 41 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fe9				 
9fe9				 
9fe9			if DEBUG_FORTH_PARSE_KEY 
9fe9						DMARK "KY3" 
9fe9			endif 
9fe9			 
9fe9			 
9fe9			 
9fe9			;       exec code block 
9fe9			if DEBUG_FORTH_JP 
9fe9				call clear_display 
9fe9				call update_display 
9fe9				call delay1s 
9fe9				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fe9				ld a,h 
9fe9				ld hl, os_word_scratch 
9fe9				call hexout 
9fe9				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fe9				ld a,l 
9fe9				ld hl, os_word_scratch+2 
9fe9				call hexout 
9fe9				ld hl, os_word_scratch+4 
9fe9				ld a,0 
9fe9				ld (hl),a 
9fe9				ld de,os_word_scratch 
9fe9				call str_at_display 
9fe9					ld a, display_row_2 
9fe9					call str_at_display 
9fe9				ld de, (cli_origtoken) 
9fe9				ld a, display_row_1+10 
9fe9					call str_at_display 
9fe9			 
9fe9				ld a,display_row_1 
9fe9				ld de, .foundword 
9fe9				ld a, display_row_3 
9fe9				call str_at_display 
9fe9				call update_display 
9fe9				call delay1s 
9fe9				call delay1s 
9fe9				call delay1s 
9fe9			endif 
9fe9			 
9fe9			if DEBUG_FORTH_PARSE_KEY 
9fe9						DMARK "KYj" 
9fe9			endif 
9fe9				; TODO save the word pointer in this exec 
9fe9			 
9fe9 2a 47 ea			ld hl,(cli_execword) 
9fec e9				jp (hl) 
9fed			 
9fed			 
9fed			;    if not same 
9fed			;	scan for zero term 
9fed			;	get ptr for next word 
9fed			;	goto word comp 
9fed			 
9fed			.execpnskipword:	; get pointer to next word 
9fed 2a 45 ea			ld hl,(cli_nextword) 
9ff0			 
9ff0 7e				ld a,(hl) 
9ff1 fe 00			cp WORD_SYS_END 
9ff3			;	cp 0 
9ff3 28 09			jr z, .execendofdict			 ; at end of words 
9ff5			 
9ff5			if DEBUG_FORTH_PARSE_KEY 
9ff5						DMARK "KY4" 
9ff5			endif 
9ff5			if DEBUG_FORTH_PARSE_EXEC 
9ff5			 
9ff5				; see if disabled 
9ff5			 
9ff5			;	ld a, (os_view_disable) 
9ff5			;	cp '*' 
9ff5				ld a,(debug_vector) 
9ff5				cp $c9   ; RET 
9ff5				jr z, .noskip 
9ff5			 
9ff5			 
9ff5				ld de, .nowordfound 
9ff5				ld a, display_row_3 
9ff5				call str_at_display 
9ff5				call update_display 
9ff5				ld a, 100 
9ff5				call aDelayInMS 
9ff5				 
9ff5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ff5					call delay250ms 
9ff5				endif 
9ff5			.noskip:  
9ff5			 
9ff5			endif	 
9ff5			 
9ff5 2a 41 ea			ld hl,(cli_origptr) 
9ff8 22 43 ea			ld (cli_ptr),hl 
9ffb			 
9ffb			if DEBUG_FORTH_PARSE_KEY 
9ffb						DMARK "KY5" 
9ffb			endif 
9ffb c3 a1 9f			jp .execpnword			; else go to next word 
9ffe			 
9ffe			.execendofdict:  
9ffe			 
9ffe			if DEBUG_FORTH_PARSE_KEY 
9ffe						DMARK "KYe" 
9ffe			endif 
9ffe			if DEBUG_FORTH_PARSE_EXEC 
9ffe				; see if disabled 
9ffe			 
9ffe			;	ld a, (os_view_disable) 
9ffe			;	cp '*' 
9ffe				ld a,(debug_vector) 
9ffe				cp $c9   ; ret 
9ffe				jr z, .ispskip 
9ffe			 
9ffe				call clear_display 
9ffe				call update_display 
9ffe				call delay1s 
9ffe				ld de, (cli_origptr) 
9ffe				ld a, display_row_1 
9ffe				call str_at_display 
9ffe				 
9ffe				ld de, .enddict 
9ffe				ld a, display_row_3 
9ffe				call str_at_display 
9ffe				call update_display 
9ffe				ld a, 100 
9ffe				call aDelayInMS 
9ffe				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ffe				call delay1s 
9ffe				call delay1s 
9ffe				call delay1s 
9ffe				endif 
9ffe			.ispskip:  
9ffe				 
9ffe			endif	 
9ffe			 
9ffe			 
9ffe			 
9ffe				; if the word is not a keyword then must be a literal so push it to stack 
9ffe			 
9ffe			; push token to stack to end of word 
9ffe			 
9ffe				STACKFRAME ON $1efe $2f9f 
9ffe				if DEBUG_STACK_IMB 
9ffe					if ON 
9ffe						exx 
9ffe						ld de, $1efe 
9ffe						ld a, d 
9ffe						ld hl, curframe 
9ffe						call hexout 
9ffe						ld a, e 
9ffe						ld hl, curframe+2 
9ffe						call hexout 
9ffe						ld hl, $1efe 
9ffe						push hl 
9ffe						ld hl, $2f9f 
9ffe						push hl 
9ffe						exx 
9ffe					endif 
9ffe				endif 
9ffe			endm 
# End of macro STACKFRAME
9ffe			 
9ffe 2a c5 e5		ld hl,(os_tok_ptr) 
a001 cd b2 9c		call forth_apush 
a004			 
a004				STACKFRAMECHK ON $1efe $2f9f 
a004				if DEBUG_STACK_IMB 
a004					if ON 
a004						exx 
a004						ld hl, $2f9f 
a004						pop de   ; $2f9f 
a004						call cmp16 
a004						jr nz, .spnosame 
a004						ld hl, $1efe 
a004						pop de   ; $1efe 
a004						call cmp16 
a004						jr z, .spfrsame 
a004						.spnosame: call showsperror 
a004						.spfrsame: nop 
a004						exx 
a004					endif 
a004				endif 
a004			endm 
# End of macro STACKFRAMECHK
a004			 
a004			execnext: 
a004			 
a004			if DEBUG_FORTH_PARSE_KEY 
a004						DMARK "KY>" 
a004			endif 
a004			; move past token to next word 
a004			 
a004 2a c5 e5		ld hl, (os_tok_ptr) 
a007 3e 00		ld a, 0 
a009 01 ff 00		ld bc, 255     ; input buffer size 
a00c ed b1		cpir 
a00e			 
a00e			if DEBUG_FORTH_PARSE_KEY 
a00e						DMARK "KY!" 
a00e				CALLMONITOR 
a00e			endif	 
a00e			; TODO this might place hl on the null, so will need to forward on??? 
a00e			;inc hl   ; see if this gets onto the next item 
a00e			 
a00e			 
a00e			; TODO pass a pointer to the buffer to push 
a00e			; TODO call function to push 
a00e			 
a00e			; look for end of input 
a00e			 
a00e			;inc hl 
a00e			;ld a,(hl) 
a00e			;cp FORTH_END_BUFFER 
a00e			;ret z 
a00e			 
a00e			 
a00e c3 87 9f		jp exec1 
a011			 
a011			 
a011			 
a011			 
a011			 
a011			 
a011			 
a011			 
a011			 
a011			findnexttok: 
a011			 
a011				; hl is pointer to move 
a011				; de is the token to locate 
a011			 
a011					if DEBUG_FORTH 
a011						DMARK "NTK" 
a011						CALLMONITOR 
a011					endif 
a011 d5				push de 
a012			 
a012			.fnt1:	 
a012				; find first char of token to locate 
a012			 
a012 1a				ld a, (de) 
a013 4f				ld c,a 
a014 7e				ld a,(hl) 
a015 cd 31 91			call toUpper 
a018					if DEBUG_FORTH 
a018						DMARK "NT1" 
a018						CALLMONITOR 
a018					endif 
a018 b9				cp c 
a019			 
a019 28 03			jr z, .fnt2cmpmorefirst	 
a01b			 
a01b				; first char not found move to next char 
a01b			 
a01b 23				inc hl 
a01c 18 f4			jr .fnt1 
a01e			 
a01e			.fnt2cmpmorefirst:	 
a01e				; first char of token found.  
a01e			 
a01e e5				push hl     ; save start of token just in case it is the right one 
a01f d9				exx 
a020 e1				pop hl        ; save it to hl' 
a021 d9				exx 
a022			 
a022			 
a022			.fnt2cmpmore:	 
a022				; compare the rest 
a022				 
a022 23				inc hl 
a023 13				inc de 
a024				 
a024 1a				ld a, (de) 
a025 4f				ld c,a 
a026 7e				ld a,(hl) 
a027 cd 31 91			call toUpper 
a02a			 
a02a					if DEBUG_FORTH 
a02a						DMARK "NT2" 
a02a						CALLMONITOR 
a02a					endif 
a02a				; c has the token to find char 
a02a				; a has the mem to scan char 
a02a			 
a02a b9				cp c 
a02b 28 04			jr z,.fntmatch1 
a02d			 
a02d				; they are not the same 
a02d			 
a02d					if DEBUG_FORTH 
a02d						DMARK "NT3" 
a02d						CALLMONITOR 
a02d					endif 
a02d d1				pop de	; reset de token to look for 
a02e d5				push de 
a02f 18 e1			jr .fnt1 
a031				 
a031			.fntmatch1: 
a031			 
a031				; is the same char a null which means we might have a full hit? 
a031					if DEBUG_FORTH 
a031						DMARK "NT4" 
a031						CALLMONITOR 
a031					endif 
a031			 
a031 fe 00			cp 0 
a033 28 0b			jr z, .fntmatchyes 
a035			 
a035				; are we at the end of the token to find? 
a035			 
a035					if DEBUG_FORTH 
a035						DMARK "NT5" 
a035						CALLMONITOR 
a035					endif 
a035 3e 00			ld a, 0 
a037 b9				cp c 
a038			 
a038 c2 22 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a03b			 
a03b					if DEBUG_FORTH 
a03b						DMARK "NT6" 
a03b						CALLMONITOR 
a03b					endif 
a03b				; token to find is exhusted but no match to stream 
a03b			 
a03b				; restore tok pointer and continue on 
a03b d1				pop de 
a03c d5				push de 
a03d c3 12 a0			jp .fnt1 
a040			 
a040			 
a040			.fntmatchyes: 
a040			 
a040				; hl now contains the end of the found token 
a040			 
a040				; get rid of saved token pointer to find 
a040			 
a040 d1				pop de 
a041			 
a041					if DEBUG_FORTH 
a041						DMARK "NT9" 
a041						CALLMONITOR 
a041					endif 
a041			 
a041				; hl will be on the null term so forward on 
a041			 
a041				; get back the saved start of the token 
a041			 
a041 d9				exx 
a042 e5				push hl     ; save start of token just in case it is the right one 
a043 d9				exx 
a044 e1				pop hl        ; save it to hl 
a045			 
a045 c9				ret 
a046			 
a046			 
a046			; LIST needs to find a specific token   
a046			; FORGET needs to find a spefici token 
a046			 
a046			; SAVE needs to find all tokens by flag 
a046			; WORDS just needs to scan through all  by flag 
a046			; UWORDS needs to scan through all by flag 
a046			 
a046			 
a046			; given hl as pointer to start of dict look up string 
a046			; return hl as pointer to start of word block 
a046			; or 0 if not found 
a046			 
a046			forth_find_tok: 
a046 c9				ret 
a047			 
a047			; given hl as pointer to dict structure 
a047			; move to the next dict block structure 
a047			 
a047			forth_tok_next: 
a047				; hl now points to the address of the next word pointer  
a047				; TODO skip compiled symbol for now 
a047			;	push de 
a047 23				inc hl 
a048 5e				ld e, (hl) 
a049 23				inc hl 
a04a 56				ld d, (hl) 
a04b 23				inc hl 
a04c			 
a04c eb				ex de,hl 
a04d			if DEBUG_FORTH_PARSE_NEXTWORD 
a04d				push bc 
a04d				ld bc, (cli_nextword) 
a04d						DMARK "NXW" 
a04d				CALLMONITOR 
a04d				pop bc 
a04d			endif 
a04d			;	pop de	 
a04d c9				ret 
a04e			 
a04e			 
a04e			 
a04e			; eof 
# End of file forth_parserv5.asm
a04e				include "forth_wordsv4.asm" 
a04e			 
a04e			; the core word dictionary v4 
a04e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a04e			 
a04e			; this is a linked list for each of the system words used 
a04e			; user defined words will follow the same format but will be in ram 
a04e			 
a04e			 
a04e			; 
a04e			; 
a04e			; define linked list: 
a04e			; 
a04e			; 1. compiled byte op code 
a04e			; 2. len of text word 
a04e			; 3. text word 
a04e			; 4. ptr to next dictionary word 
a04e			; 5. asm, calls etc for the word 
a04e			; 
a04e			;  if 1 == 0 then last word in dict  
a04e			;   
a04e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a04e			;  
a04e			;  
a04e			; create basic standard set of words 
a04e			; 
a04e			;  
a04e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a04e			; 2DUP 2DROP 2SWAP  
a04e			; @ C@ - get byte  
a04e			; ! C! - store byte 
a04e			; 0< true if less than zero 
a04e			; 0= true if zero 
a04e			; < >  
a04e			; = true if same 
a04e			; variables 
a04e			 
a04e			 
a04e			; Hardware specific words I may need 
a04e			; 
a04e			; IN OUT  
a04e			; calls to key util functions 
a04e			; calls to hardward abstraction stuff 
a04e			; easy control of frame buffers and lcd i/o 
a04e			; keyboard  
a04e			 
a04e			 
a04e			;DICT: macro 
a04e			; op_code, len, word, next 
a04e			;    word: 
a04e			;    db op_code 
a04e			;    ds word zero term 
a04e			;    dw next 
a04e			;    endm 
a04e			 
a04e			 
a04e			 
a04e			 
a04e			; op code 1 is a flag for user define words which are to be handled differently 
a04e			 
a04e			 
a04e			; 
a04e			; 
a04e			;    TODO on entry to a word this should be the expected environment 
a04e			;    hl - tos value if number then held, if string this is the ptr 
a04e			;    de -  
a04e			 
a04e			 
a04e			; opcode ranges 
a04e			; 0 - end of word dict 
a04e			; 255 - user define words 
a04e			 
a04e			sysdict: 
a04e			include "forth_opcodes.asm" 
a04e			; op codes for forth keywords 
a04e			; free to use code 0  
a04e				OPCODE_HEAP: equ  1 
a04e				OPCODE_EXEC: equ 2 
a04e				OPCODE_DUP: equ 3 
a04e				OPCODE_SWAP: equ 4 
a04e				OPCODE_COLN: equ 5 
a04e				OPCODE_SCOLN: equ 6 
a04e				OPCODE_DROP: equ 7 
a04e				OPCODE_DUP2: equ 8 
a04e				OPCODE_DROP2: equ 9 
a04e				OPCODE_SWAP2: equ 10 
a04e				OPCODE_AT: equ 11 
a04e				OPCODE_CAT: equ 12 
a04e				OPCODE_BANG: equ 13 
a04e				OPCODE_CBANG: equ 14 
a04e				OPCODE_SCALL: equ 15 
a04e				OPCODE_DEPTH: equ 16 
a04e				OPCODE_OVER: equ 17 
a04e				OPCODE_PAUSE: equ 18 
a04e				OPCODE_PAUSES: equ 19 
a04e				OPCODE_ROT: equ 20 
a04e			;free to reuse	OPCODE_WORDS: equ 21 
a04e			        OPCODE_NOT: equ 21 
a04e				OPCODE_UWORDS: equ 22 
a04e				OPCODE_BP: equ 23 
a04e				OPCODE_MONITOR: equ 24  
a04e				OPCODE_MALLOC: equ 25 
a04e				OPCODE_FREE: equ 26 
a04e				OPCODE_LIST: equ 27 
a04e				OPCODE_FORGET: equ 28 
a04e				OPCODE_NOP: equ 29 
a04e				OPCODE_COMO: equ 30 
a04e				OPCODE_COMC: equ 31 
a04e			;free to reuse	OPCODE_ENDCORE: equ 32 
a04e				OPCODE_AFTERSOUND: equ 33 
a04e				OPCODE_GP2: equ 34 
a04e				OPCODE_GP3: equ 35 
a04e				OPCODE_GP4: equ 36 
a04e				OPCODE_SIN: equ 37 
a04e				OPCODE_SOUT: equ 38 
a04e				OPCODE_SPIO: equ 39 
a04e				OPCODE_SPICEH: equ 40 
a04e				OPCODE_SPIOb: equ 41 
a04e				OPCODE_SPII: equ 42 
a04e				OPCODE_SESEL: equ 43 
a04e				OPCODE_CARTDEV: equ 44 
a04e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a04e				OPCODE_FB: equ 46 
a04e				OPCODE_EMIT: equ 47 
a04e				OPCODE_DOTH: equ 48 
a04e				OPCODE_DOTF: equ 49 
a04e				OPCODE_DOT: equ 50 
a04e				OPCODE_CLS: equ 51 
a04e				OPCODE_DRAW: equ 52 
a04e				OPCODE_DUMP: equ 53 
a04e				OPCODE_CDUMP: equ 54 
a04e				OPCODE_DAT: equ 55 
a04e				OPCODE_HOME: equ 56 
a04e				OPCODE_SPACE: equ 57 
a04e				OPCODE_SPACES: equ 58 
a04e				OPCODE_SCROLL: equ 59 
a04e				OPCODE_ATQ: equ 60 
a04e				OPCODE_AUTODSP: equ 61 
a04e				OPCODE_MENU: equ 62 
a04e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a04e				OPCODE_THEN: equ 64 
a04e				OPCODE_ELSE: equ 65 
a04e				OPCODE_DO: equ 66 
a04e				OPCODE_LOOP: equ 67 
a04e				OPCODE_I: equ 68 
a04e				OPCODE_DLOOP: equ 69  
a04e				OPCODE_REPEAT: equ 70  
a04e				OPCODE_UNTIL: equ 71 
a04e				OPCODE_ENDFLOW: equ 72 
a04e				OPCODE_WAITK: equ 73 
a04e				OPCODE_ACCEPT: equ 74 
a04e				OPCODE_EDIT: equ 75 
a04e			;free to reuse	OPCODE_ENDKEY: equ 76 
a04e				OPCODE_LZERO: equ 77 
a04e				OPCODE_TZERO: equ 78 
a04e				OPCODE_LESS: equ 79 
a04e				OPCODE_GT: equ 80 
a04e				OPCODE_EQUAL: equ 81  
a04e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a04e				OPCODE_NEG: equ 83 
a04e				OPCODE_DIV: equ 84 
a04e				OPCODE_MUL: equ 85 
a04e				OPCODE_MIN: equ 86 
a04e				OPCODE_MAX: equ 87 
a04e				OPCODE_RND16: equ 88 
a04e				OPCODE_RND8: equ 89 
a04e				OPCODE_RND: equ 90 
a04e			;free to reuse	OPCODE_ENDMATHS: equ 91  
a04e				OPCODE_BYNAME: equ 92 
a04e				OPCODE_DIR: equ 93 
a04e				OPCODE_SAVE: equ 94 
a04e				OPCODE_LOAD: equ 95 
a04e				OPCODE_BSAVE: equ 96 
a04e				OPCODE_BLOAD: equ 97 
a04e				OPCODE_SEO: equ 98  
a04e				OPCODE_SEI: equ 99 
a04e				OPCODE_SFREE: equ 100 
a04e				OPCODE_SIZE: equ 101 
a04e				OPCODE_CREATE: equ 102 
a04e				OPCODE_APPEND: equ 103 
a04e				OPCODE_SDEL: equ 104 
a04e				OPCODE_OPEN: equ 105 
a04e				OPCODE_READ: equ 106 
a04e				OPCODE_EOF: equ 106 
a04e				OPCODE_FORMAT: equ 107 
a04e				OPCODE_LABEL: equ 108 
a04e				OPCODE_LABELS: equ 109 
a04e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a04e				OPCODE_UPPER: equ 111 
a04e				OPCODE_LOWER: equ 112 
a04e				OPCODE_SUBSTR: equ 113 
a04e				OPCODE_LEFT: equ 114 
a04e				OPCODE_RIGHT: equ 115 
a04e				OPCODE_STR2NUM: equ 116 
a04e				OPCODE_NUM2STR: equ 117 
a04e				OPCODE_CONCAT: equ 118 
a04e				OPCODE_FIND: equ 119 
a04e				OPCODE_LEN: equ 120 
a04e				OPCODE_CHAR: equ 121 
a04e			; free to reuse	OPCODE_STRLEN: equ 122 
a04e			; free to reuse	OPCODE_ENDSTR: equ 123 
a04e				OPCODE_V0S: equ 124 
a04e				OPCODE_V0Q: equ 125 
a04e				OPCODE_V1S: equ 126 
a04e				OPCODE_V1Q: equ 127 
a04e				OPCODE_V2S: equ 128 
a04e				OPCODE_V2Q: equ 129 
a04e				OPCODE_V3S: equ 130 
a04e				OPCODE_V3Q: equ 131 
a04e			;free to reuse	OPCODE_END: equ 132 
a04e				OPCODE_ZDUP: equ 133 
a04e			 
a04e			; eof 
# End of file forth_opcodes.asm
a04e			 
a04e			include "forth_words_core.asm" 
a04e			 
a04e			; | ## Core Words 
a04e			 
a04e			;if MALLOC_4 
a04e			 
a04e			.HEAP: 
a04e				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a04e 15				db WORD_SYS_CORE+OPCODE_HEAP             
a04f 8d a0			dw .EXEC            
a051 05				db 4 + 1 
a052 .. 00			db "HEAP",0              
a057				endm 
# End of macro CWHEAD
a057			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a057			; | | u1 - Current number of bytes in the heap 
a057			; | | u2 - Remaining bytes left on the heap 
a057			; | |  
a057			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a057			 
a057			 
a057					if DEBUG_FORTH_WORDS_KEY 
a057						DMARK "HEP" 
a057 f5				push af  
a058 3a 6c a0			ld a, (.dmark)  
a05b 32 6e ee			ld (debug_mark),a  
a05e 3a 6d a0			ld a, (.dmark+1)  
a061 32 6f ee			ld (debug_mark+1),a  
a064 3a 6e a0			ld a, (.dmark+2)  
a067 32 70 ee			ld (debug_mark+2),a  
a06a 18 03			jr .pastdmark  
a06c ..			.dmark: db "HEP"  
a06f f1			.pastdmark: pop af  
a070			endm  
# End of macro DMARK
a070						CALLMONITOR 
a070 cd 72 ee			call debug_vector  
a073				endm  
# End of macro CALLMONITOR
a073					endif 
a073 2a 55 e3				ld hl, (free_list )      
a076 11 5a e3				ld de, heap_start 
a079			 
a079 ed 52				sbc hl, de  
a07b			 
a07b cd 49 9b				call forth_push_numhl 
a07e			 
a07e			 
a07e ed 5b 55 e3			ld de, (free_list )      
a082 21 ab e2				ld hl, heap_end 
a085			 
a085 ed 52				sbc hl, de 
a087			 
a087 cd 49 9b				call forth_push_numhl 
a08a					 
a08a			 
a08a					 
a08a			 
a08a			 
a08a			 
a08a					NEXTW 
a08a c3 f6 9e			jp macro_next 
a08d				endm 
# End of macro NEXTW
a08d			;endif 
a08d			 
a08d			.EXEC: 
a08d			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a08d			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a08d			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a08d			;; > > 
a08d			;; > >   
a08d			;	STACKFRAME OFF $5efe $5f9f 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS_KEY 
a08d			;			DMARK "EXE" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			; 
a08d			;	FORTH_DSP_VALUEHL 
a08d			; 
a08d			;	FORTH_DSP_POP 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EX1" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;;	ld e,(hl) 
a08d			;;	inc hl 
a08d			;;	ld d,(hl) 
a08d			;;	ex de,hl 
a08d			; 
a08d			;;		if DEBUG_FORTH_WORDS 
a08d			;;			DMARK "EX2" 
a08d			;;			CALLMONITOR 
a08d			;;		endif 
a08d			;	push hl 
a08d			; 
a08d			;	;ld a, 0 
a08d			;	;ld a, FORTH_END_BUFFER 
a08d			;	call strlenz 
a08d			;	inc hl   ; include zero term to copy 
a08d			;	inc hl   ; include term 
a08d			;	inc hl   ; include term 
a08d			;	ld b,0 
a08d			;	ld c,l 
a08d			;	pop hl 
a08d			;	ld de, execscratch 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EX3" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;	ldir 
a08d			; 
a08d			; 
a08d			;	ld hl, execscratch 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EXe" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			; 
a08d			;	call forthparse 
a08d			;	call forthexec 
a08d			;;	call forthexec_cleanup 
a08d			;;	call forthparse 
a08d			;;	call forthexec 
a08d			; 
a08d			;	STACKFRAMECHK OFF $5efe $5f9f 
a08d			; 
a08d			;	; an immediate word so no need to process any more words 
a08d			;	ret 
a08d			;	NEXTW 
a08d			 
a08d			; dead code - old version  
a08d			;	FORTH_RSP_NEXT 
a08d			 
a08d			;  
a08d			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a08d			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a08d			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a08d			;	push hl 
a08d			;	push de 
a08d			;	push bc 
a08d			; 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS_KEY 
a08d			;			DMARK "EXR" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			; 
a08d			; 
a08d			; 
a08d			;	;v5 FORTH_DSP_VALUE 
a08d			;	FORTH_DSP_VALUEHL 
a08d			; 
a08d			;	; TODO do string type checks 
a08d			; 
a08d			;;v5	inc hl   ; skip type 
a08d			; 
a08d			;	push hl  ; source code  
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EX1" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;	ld a, 0 
a08d			;	call strlent 
a08d			; 
a08d			;	inc hl 
a08d			;	inc hl 
a08d			;	inc hl 
a08d			;	inc hl 
a08d			; 
a08d			;	push hl    ; size 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EX2" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;	call malloc 
a08d			; 
a08d			;	ex de, hl    ; de now contains malloc area 
a08d			;	pop bc   	; get byte count 
a08d			;	pop hl      ; get string to copy 
a08d			; 
a08d			;	push de     ; save malloc for free later 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EX3" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;	ldir       ; duplicate string 
a08d			; 
a08d			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a08d			;	 
a08d			;	; TODO fix the parse would be better than this...  
a08d			;	ex de, hl 
a08d			;	dec hl 
a08d			;	ld a, 0 
a08d			;	ld (hl), a 
a08d			;	dec hl 
a08d			;	ld a, ' ' 
a08d			;	ld (hl), a 
a08d			;	dec hl 
a08d			;	ld (hl), a 
a08d			; 
a08d			;	dec hl 
a08d			;	ld (hl), a 
a08d			; 
a08d			; 
a08d			;	FORTH_DSP_POP  
a08d			; 
a08d			;	pop hl     
a08d			;	push hl    ; save malloc area 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EX4" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			; 
a08d			;	call forthparse 
a08d			;	call forthexec 
a08d			;	 
a08d			;	pop hl 
a08d			;	if DEBUG_FORTH_WORDS 
a08d			;		DMARK "EX5" 
a08d			;		CALLMONITOR 
a08d			;	endif 
a08d			; 
a08d			;	if FORTH_ENABLE_FREE 
a08d			;	call free 
a08d			;	endif 
a08d			; 
a08d			;	if DEBUG_FORTH_WORDS 
a08d			;		DMARK "EX6" 
a08d			;		CALLMONITOR 
a08d			;	endif 
a08d			; 
a08d			;	pop bc 
a08d			;	pop de 
a08d			;	pop hl 
a08d			;;	FORTH_RSP_POP	  
a08d			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a08d			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a08d			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a08d			; 
a08d			;	if DEBUG_FORTH_WORDS 
a08d			;		DMARK "EX7" 
a08d			;		CALLMONITOR 
a08d			;	endif 
a08d			;	NEXTW 
a08d			 
a08d			;.STKEXEC: 
a08d			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a08d			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a08d			; 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS_KEY 
a08d			;			DMARK "STX" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			; 
a08d			;	FORTH_DSP_VALUEHL 
a08d			; 
a08d			;	ld (store_tmp1), hl    ; count 
a08d			; 
a08d			;	FORTH_DSP_POP 
a08d			;.stkexec1: 
a08d			;	ld hl, (store_tmp1)   ; count 
a08d			;	ld a, 0 
a08d			;	cp l 
a08d			;	ret z 
a08d			; 
a08d			;	dec hl 
a08d			;	ld (store_tmp1), hl    ; count 
a08d			;	 
a08d			;	FORTH_DSP_VALUEHL 
a08d			;	push hl 
a08d			;	 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EXp" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;	FORTH_DSP_POP 
a08d			; 
a08d			;	call strlenz 
a08d			;	inc hl   ; include zero term to copy 
a08d			;	inc hl   ; include zero term to copy 
a08d			;	inc hl   ; include zero term to copy 
a08d			;	ld b,0 
a08d			;	ld c,l 
a08d			;	pop hl 
a08d			;	ld de, execscratch 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EX3" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;	ldir 
a08d			; 
a08d			; 
a08d			;	ld hl, execscratch 
a08d			; 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EXP" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			; 
a08d			;	call forthparse 
a08d			;	ld hl, execscratch 
a08d			;		if DEBUG_FORTH_WORDS 
a08d			;			DMARK "EXx" 
a08d			;			CALLMONITOR 
a08d			;		endif 
a08d			;	call forthexec 
a08d			; 
a08d			;	jp .stkexec1 
a08d			; 
a08d			;	ret 
a08d			 
a08d			 
a08d			.DUP: 
a08d				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a08d 17				db WORD_SYS_CORE+OPCODE_DUP             
a08e 03 a1			dw .ZDUP            
a090 04				db 3 + 1 
a091 .. 00			db "DUP",0              
a095				endm 
# End of macro CWHEAD
a095			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a095			 
a095					if DEBUG_FORTH_WORDS_KEY 
a095						DMARK "DUP" 
a095 f5				push af  
a096 3a aa a0			ld a, (.dmark)  
a099 32 6e ee			ld (debug_mark),a  
a09c 3a ab a0			ld a, (.dmark+1)  
a09f 32 6f ee			ld (debug_mark+1),a  
a0a2 3a ac a0			ld a, (.dmark+2)  
a0a5 32 70 ee			ld (debug_mark+2),a  
a0a8 18 03			jr .pastdmark  
a0aa ..			.dmark: db "DUP"  
a0ad f1			.pastdmark: pop af  
a0ae			endm  
# End of macro DMARK
a0ae						CALLMONITOR 
a0ae cd 72 ee			call debug_vector  
a0b1				endm  
# End of macro CALLMONITOR
a0b1					endif 
a0b1			 
a0b1					FORTH_DSP 
a0b1 cd 06 9d			call macro_forth_dsp 
a0b4				endm 
# End of macro FORTH_DSP
a0b4			 
a0b4 7e					ld a, (HL) 
a0b5 fe 01				cp DS_TYPE_STR 
a0b7 20 25				jr nz, .dupinum 
a0b9			 
a0b9					; push another string 
a0b9			 
a0b9					FORTH_DSP_VALUEHL     		 
a0b9 cd 40 9d			call macro_dsp_valuehl 
a0bc				endm 
# End of macro FORTH_DSP_VALUEHL
a0bc			 
a0bc				if DEBUG_FORTH_WORDS 
a0bc					DMARK "DUs" 
a0bc f5				push af  
a0bd 3a d1 a0			ld a, (.dmark)  
a0c0 32 6e ee			ld (debug_mark),a  
a0c3 3a d2 a0			ld a, (.dmark+1)  
a0c6 32 6f ee			ld (debug_mark+1),a  
a0c9 3a d3 a0			ld a, (.dmark+2)  
a0cc 32 70 ee			ld (debug_mark+2),a  
a0cf 18 03			jr .pastdmark  
a0d1 ..			.dmark: db "DUs"  
a0d4 f1			.pastdmark: pop af  
a0d5			endm  
# End of macro DMARK
a0d5					CALLMONITOR 
a0d5 cd 72 ee			call debug_vector  
a0d8				endm  
# End of macro CALLMONITOR
a0d8				endif 
a0d8 cd b7 9b				call forth_push_str 
a0db			 
a0db					NEXTW 
a0db c3 f6 9e			jp macro_next 
a0de				endm 
# End of macro NEXTW
a0de			 
a0de			 
a0de			.dupinum: 
a0de					 
a0de			 
a0de			 
a0de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0de cd 40 9d			call macro_dsp_valuehl 
a0e1				endm 
# End of macro FORTH_DSP_VALUEHL
a0e1			 
a0e1				; TODO add floating point number detection 
a0e1			 
a0e1				if DEBUG_FORTH_WORDS 
a0e1					DMARK "DUi" 
a0e1 f5				push af  
a0e2 3a f6 a0			ld a, (.dmark)  
a0e5 32 6e ee			ld (debug_mark),a  
a0e8 3a f7 a0			ld a, (.dmark+1)  
a0eb 32 6f ee			ld (debug_mark+1),a  
a0ee 3a f8 a0			ld a, (.dmark+2)  
a0f1 32 70 ee			ld (debug_mark+2),a  
a0f4 18 03			jr .pastdmark  
a0f6 ..			.dmark: db "DUi"  
a0f9 f1			.pastdmark: pop af  
a0fa			endm  
# End of macro DMARK
a0fa					CALLMONITOR 
a0fa cd 72 ee			call debug_vector  
a0fd				endm  
# End of macro CALLMONITOR
a0fd				endif 
a0fd			 
a0fd cd 49 9b				call forth_push_numhl 
a100					NEXTW 
a100 c3 f6 9e			jp macro_next 
a103				endm 
# End of macro NEXTW
a103			.ZDUP: 
a103				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a103 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a104 3b a1			dw .SWAP            
a106 05				db 4 + 1 
a107 .. 00			db "?DUP",0              
a10c				endm 
# End of macro CWHEAD
a10c			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a10c			 
a10c					if DEBUG_FORTH_WORDS_KEY 
a10c						DMARK "qDU" 
a10c f5				push af  
a10d 3a 21 a1			ld a, (.dmark)  
a110 32 6e ee			ld (debug_mark),a  
a113 3a 22 a1			ld a, (.dmark+1)  
a116 32 6f ee			ld (debug_mark+1),a  
a119 3a 23 a1			ld a, (.dmark+2)  
a11c 32 70 ee			ld (debug_mark+2),a  
a11f 18 03			jr .pastdmark  
a121 ..			.dmark: db "qDU"  
a124 f1			.pastdmark: pop af  
a125			endm  
# End of macro DMARK
a125						CALLMONITOR 
a125 cd 72 ee			call debug_vector  
a128				endm  
# End of macro CALLMONITOR
a128					endif 
a128					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a128 cd 40 9d			call macro_dsp_valuehl 
a12b				endm 
# End of macro FORTH_DSP_VALUEHL
a12b			 
a12b e5					push hl 
a12c			 
a12c					; is it a zero? 
a12c			 
a12c 3e 00				ld a, 0 
a12e 84					add h 
a12f 85					add l 
a130			 
a130 e1					pop hl 
a131			 
a131 fe 00				cp 0 
a133 28 03				jr z, .dup2orig 
a135			 
a135			 
a135 cd 49 9b				call forth_push_numhl 
a138			 
a138			 
a138				; TODO add floating point number detection 
a138			 
a138			.dup2orig: 
a138			 
a138					NEXTW 
a138 c3 f6 9e			jp macro_next 
a13b				endm 
# End of macro NEXTW
a13b			.SWAP: 
a13b				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a13b 18				db WORD_SYS_CORE+OPCODE_SWAP             
a13c 7a a1			dw .COLN            
a13e 05				db 4 + 1 
a13f .. 00			db "SWAP",0              
a144				endm 
# End of macro CWHEAD
a144			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a144					if DEBUG_FORTH_WORDS_KEY 
a144						DMARK "SWP" 
a144 f5				push af  
a145 3a 59 a1			ld a, (.dmark)  
a148 32 6e ee			ld (debug_mark),a  
a14b 3a 5a a1			ld a, (.dmark+1)  
a14e 32 6f ee			ld (debug_mark+1),a  
a151 3a 5b a1			ld a, (.dmark+2)  
a154 32 70 ee			ld (debug_mark+2),a  
a157 18 03			jr .pastdmark  
a159 ..			.dmark: db "SWP"  
a15c f1			.pastdmark: pop af  
a15d			endm  
# End of macro DMARK
a15d						CALLMONITOR 
a15d cd 72 ee			call debug_vector  
a160				endm  
# End of macro CALLMONITOR
a160					endif 
a160			 
a160					FORTH_DSP_VALUEHL 
a160 cd 40 9d			call macro_dsp_valuehl 
a163				endm 
# End of macro FORTH_DSP_VALUEHL
a163 e5					push hl     ; w2 
a164			 
a164					FORTH_DSP_POP 
a164 cd f8 9d			call macro_forth_dsp_pop 
a167				endm 
# End of macro FORTH_DSP_POP
a167			 
a167					FORTH_DSP_VALUEHL 
a167 cd 40 9d			call macro_dsp_valuehl 
a16a				endm 
# End of macro FORTH_DSP_VALUEHL
a16a			 
a16a					FORTH_DSP_POP 
a16a cd f8 9d			call macro_forth_dsp_pop 
a16d				endm 
# End of macro FORTH_DSP_POP
a16d			 
a16d d1					pop de     ; w2	, hl = w1 
a16e			 
a16e eb					ex de, hl 
a16f d5					push de 
a170			 
a170 cd 49 9b				call forth_push_numhl 
a173			 
a173 e1					pop hl 
a174			 
a174 cd 49 9b				call forth_push_numhl 
a177					 
a177			 
a177					NEXTW 
a177 c3 f6 9e			jp macro_next 
a17a				endm 
# End of macro NEXTW
a17a			.COLN: 
a17a				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a17a 19				db WORD_SYS_CORE+OPCODE_COLN             
a17b 06 a3			dw .SCOLN            
a17d 02				db 1 + 1 
a17e .. 00			db ":",0              
a180				endm 
# End of macro CWHEAD
a180			; | : ( -- )         Create new word | DONE 
a180			 
a180					if DEBUG_FORTH_WORDS_KEY 
a180						DMARK "CLN" 
a180 f5				push af  
a181 3a 95 a1			ld a, (.dmark)  
a184 32 6e ee			ld (debug_mark),a  
a187 3a 96 a1			ld a, (.dmark+1)  
a18a 32 6f ee			ld (debug_mark+1),a  
a18d 3a 97 a1			ld a, (.dmark+2)  
a190 32 70 ee			ld (debug_mark+2),a  
a193 18 03			jr .pastdmark  
a195 ..			.dmark: db "CLN"  
a198 f1			.pastdmark: pop af  
a199			endm  
# End of macro DMARK
a199						CALLMONITOR 
a199 cd 72 ee			call debug_vector  
a19c				endm  
# End of macro CALLMONITOR
a19c					endif 
a19c				STACKFRAME OFF $8efe $989f 
a19c				if DEBUG_STACK_IMB 
a19c					if OFF 
a19c						exx 
a19c						ld de, $8efe 
a19c						ld a, d 
a19c						ld hl, curframe 
a19c						call hexout 
a19c						ld a, e 
a19c						ld hl, curframe+2 
a19c						call hexout 
a19c						ld hl, $8efe 
a19c						push hl 
a19c						ld hl, $989f 
a19c						push hl 
a19c						exx 
a19c					endif 
a19c				endif 
a19c			endm 
# End of macro STACKFRAME
a19c				; get parser buffer length  of new word 
a19c			 
a19c				 
a19c			 
a19c					; move tok past this to start of name defintition 
a19c					; TODO get word to define 
a19c					; TODO Move past word token 
a19c					; TODO get length of string up to the ';' 
a19c			 
a19c 2a c5 e5			ld hl, (os_tok_ptr) 
a19f 23				inc hl 
a1a0 23				inc hl 
a1a1			 
a1a1 3e 3b			ld a, ';' 
a1a3 cd 45 91			call strlent 
a1a6			 
a1a6 7d				ld a,l 
a1a7 32 c0 e2			ld (os_new_parse_len), a 
a1aa			 
a1aa			 
a1aa			if DEBUG_FORTH_UWORD 
a1aa ed 5b c5 e5		ld de, (os_tok_ptr) 
a1ae						DMARK ":01" 
a1ae f5				push af  
a1af 3a c3 a1			ld a, (.dmark)  
a1b2 32 6e ee			ld (debug_mark),a  
a1b5 3a c4 a1			ld a, (.dmark+1)  
a1b8 32 6f ee			ld (debug_mark+1),a  
a1bb 3a c5 a1			ld a, (.dmark+2)  
a1be 32 70 ee			ld (debug_mark+2),a  
a1c1 18 03			jr .pastdmark  
a1c3 ..			.dmark: db ":01"  
a1c6 f1			.pastdmark: pop af  
a1c7			endm  
# End of macro DMARK
a1c7				CALLMONITOR 
a1c7 cd 72 ee			call debug_vector  
a1ca				endm  
# End of macro CALLMONITOR
a1ca			endif 
a1ca			 
a1ca			; 
a1ca			;  new word memory layout: 
a1ca			;  
a1ca			;    : adg 6666 ;  
a1ca			; 
a1ca			;    db   1     ; user defined word  
a1ca 23				inc hl    
a1cb			;    dw   sysdict 
a1cb 23				inc hl 
a1cc 23				inc hl 
a1cd			;    db <word len>+1 (for null) 
a1cd 23				inc hl 
a1ce			;    db .... <word> 
a1ce			; 
a1ce			 
a1ce 23				inc hl    ; some extras for the word preamble before the above 
a1cf 23				inc hl 
a1d0 23				inc hl 
a1d1 23				inc hl 
a1d2 23				inc hl 
a1d3 23				inc hl 
a1d4 23				inc hl  
a1d5 23				inc hl 
a1d6 23				inc hl 
a1d7 23				inc hl 
a1d8 23				inc hl 
a1d9 23				inc hl 
a1da 23				inc hl 
a1db 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1dc			;       exec word buffer 
a1dc			;	<ptr word>   
a1dc 23				inc hl 
a1dd 23				inc hl 
a1de			;       <word list><null term> 7F final term 
a1de			 
a1de			 
a1de			if DEBUG_FORTH_UWORD 
a1de						DMARK ":02" 
a1de f5				push af  
a1df 3a f3 a1			ld a, (.dmark)  
a1e2 32 6e ee			ld (debug_mark),a  
a1e5 3a f4 a1			ld a, (.dmark+1)  
a1e8 32 6f ee			ld (debug_mark+1),a  
a1eb 3a f5 a1			ld a, (.dmark+2)  
a1ee 32 70 ee			ld (debug_mark+2),a  
a1f1 18 03			jr .pastdmark  
a1f3 ..			.dmark: db ":02"  
a1f6 f1			.pastdmark: pop af  
a1f7			endm  
# End of macro DMARK
a1f7				CALLMONITOR 
a1f7 cd 72 ee			call debug_vector  
a1fa				endm  
# End of macro CALLMONITOR
a1fa			endif 
a1fa			 
a1fa				 
a1fa					; malloc the size 
a1fa			 
a1fa cd a3 91				call malloc 
a1fd 22 c2 e2				ld (os_new_malloc), hl     ; save malloc start 
a200			 
a200			;    db   1     ; user defined word  
a200 3e 01				ld a, WORD_SYS_UWORD  
a202 77					ld (hl), a 
a203				 
a203 23				inc hl    
a204			;    dw   sysdict 
a204 11 4e a0			ld de, sysdict       ; continue on with the scan to the system dict 
a207 73				ld (hl), e 
a208 23				inc hl 
a209 72				ld (hl), d 
a20a 23				inc hl 
a20b			 
a20b			 
a20b			;    Setup dict word 
a20b			 
a20b 23				inc hl 
a20c 22 bc e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a20f			 
a20f				; 1. get length of dict word 
a20f			 
a20f			 
a20f 2a c5 e5			ld hl, (os_tok_ptr) 
a212 23				inc hl 
a213 23				inc hl    ; position to start of dict word 
a214 3e 00			ld a, 0 
a216 cd 45 91			call strlent 
a219			 
a219			 
a219 23				inc hl    ; to include null??? 
a21a			 
a21a				; write length of dict word 
a21a			 
a21a ed 5b bc e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a21e 1b				dec de 
a21f eb				ex de, hl 
a220 73				ld (hl), e 
a221 eb				ex de, hl 
a222			 
a222				 
a222			 
a222				; copy  
a222 4d				ld c, l 
a223 06 00			ld b, 0 
a225 ed 5b bc e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a229 2a c5 e5			ld hl, (os_tok_ptr) 
a22c 23				inc hl 
a22d 23				inc hl    ; position to start of dict word 
a22e				 
a22e			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a22e				 
a22e				; TODO need to convert word to upper case 
a22e			 
a22e			ucasetok:	 
a22e 7e				ld a,(hl) 
a22f cd 31 91			call toUpper 
a232 77				ld (hl),a 
a233 ed a0			ldi 
a235 f2 2e a2		 	jp p, ucasetok 
a238			 
a238			 
a238			 
a238				; de now points to start of where the word body code should be placed 
a238 ed 53 bc e2		ld (os_new_work_ptr), de 
a23c				; hl now points to the words to throw at forthexec which needs to be copied 
a23c 22 ba e2			ld (os_new_src_ptr), hl 
a23f			 
a23f				; TODO add 'call to forthexec' 
a23f			 
a23f			if DEBUG_FORTH_UWORD 
a23f c5				push bc 
a240 ed 4b c2 e2		ld bc, (os_new_malloc) 
a244						DMARK ":0x" 
a244 f5				push af  
a245 3a 59 a2			ld a, (.dmark)  
a248 32 6e ee			ld (debug_mark),a  
a24b 3a 5a a2			ld a, (.dmark+1)  
a24e 32 6f ee			ld (debug_mark+1),a  
a251 3a 5b a2			ld a, (.dmark+2)  
a254 32 70 ee			ld (debug_mark+2),a  
a257 18 03			jr .pastdmark  
a259 ..			.dmark: db ":0x"  
a25c f1			.pastdmark: pop af  
a25d			endm  
# End of macro DMARK
a25d				CALLMONITOR 
a25d cd 72 ee			call debug_vector  
a260				endm  
# End of macro CALLMONITOR
a260 c1				pop bc 
a261			endif 
a261			 
a261			 
a261				; create word preamble which should be: 
a261			 
a261			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a261			 
a261				;    ld hl, <word code> 
a261				;    jp user_exec 
a261			        ;    <word code bytes> 
a261			 
a261			 
a261			;	inc de     ; TODO ??? or are we already past the word's null 
a261 eb				ex de, hl 
a262			 
a262 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a264			 
a264 23				inc hl 
a265 22 b6 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a268 23				inc hl 
a269			 
a269 23				inc hl 
a26a 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a26c			 
a26c 01 31 cb			ld bc, user_exec 
a26f 23				inc hl 
a270 71				ld (hl), c     ; poke address of user_exec 
a271 23				inc hl 
a272 70				ld (hl), b     
a273			 ; 
a273			;	inc hl 
a273			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a273			; 
a273			; 
a273			;	ld bc, macro_forth_rsp_next 
a273			;	inc hl 
a273			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a273			;	inc hl 
a273			;	ld (hl), b     
a273			 ; 
a273			;	inc hl 
a273			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a273			; 
a273			; 
a273			;	inc hl 
a273			;	ld bc, forthexec 
a273			;	ld (hl), c     ; poke address of forthexec 
a273			;	inc hl 
a273			;	ld (hl), b      
a273			; 
a273			;	inc hl 
a273			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a273			; 
a273			;	ld bc, user_dict_next 
a273			;	inc hl 
a273			;	ld (hl), c     ; poke address of forthexec 
a273			;	inc hl 
a273			;	ld (hl), b      
a273			 
a273				; hl is now where we need to copy the word byte data to save this 
a273			 
a273 23				inc hl 
a274 22 b8 e2			ld (os_new_exec), hl 
a277				 
a277				; copy definition 
a277			 
a277 eb				ex de, hl 
a278			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a278			;	inc de    ; skip the PC for this parse 
a278 3a c0 e2			ld a, (os_new_parse_len) 
a27b 4f				ld c, a 
a27c 06 00			ld b, 0 
a27e ed b0			ldir		 ; copy defintion 
a280			 
a280			 
a280				; poke the address of where the new word bytes live for forthexec 
a280			 
a280 2a b6 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a283			 
a283 ed 5b b8 e2		ld de, (os_new_exec)      
a287				 
a287 73				ld (hl), e 
a288 23				inc hl 
a289 72				ld (hl), d 
a28a			 
a28a					; TODO copy last user dict word next link to this word 
a28a					; TODO update last user dict word to point to this word 
a28a			; 
a28a			; hl f923 de 812a ; bc 811a 
a28a			 
a28a			if DEBUG_FORTH_UWORD 
a28a c5				push bc 
a28b ed 4b c2 e2		ld bc, (os_new_malloc) 
a28f						DMARK ":0A" 
a28f f5				push af  
a290 3a a4 a2			ld a, (.dmark)  
a293 32 6e ee			ld (debug_mark),a  
a296 3a a5 a2			ld a, (.dmark+1)  
a299 32 6f ee			ld (debug_mark+1),a  
a29c 3a a6 a2			ld a, (.dmark+2)  
a29f 32 70 ee			ld (debug_mark+2),a  
a2a2 18 03			jr .pastdmark  
a2a4 ..			.dmark: db ":0A"  
a2a7 f1			.pastdmark: pop af  
a2a8			endm  
# End of macro DMARK
a2a8				CALLMONITOR 
a2a8 cd 72 ee			call debug_vector  
a2ab				endm  
# End of macro CALLMONITOR
a2ab c1				pop bc 
a2ac			endif 
a2ac			if DEBUG_FORTH_UWORD 
a2ac c5				push bc 
a2ad ed 4b c2 e2		ld bc, (os_new_malloc) 
a2b1 03				inc bc 
a2b2 03				inc bc 
a2b3 03				inc bc 
a2b4 03				inc bc 
a2b5 03				inc bc 
a2b6 03				inc bc 
a2b7 03				inc bc 
a2b8 03				inc bc 
a2b9			 
a2b9						DMARK ":0B" 
a2b9 f5				push af  
a2ba 3a ce a2			ld a, (.dmark)  
a2bd 32 6e ee			ld (debug_mark),a  
a2c0 3a cf a2			ld a, (.dmark+1)  
a2c3 32 6f ee			ld (debug_mark+1),a  
a2c6 3a d0 a2			ld a, (.dmark+2)  
a2c9 32 70 ee			ld (debug_mark+2),a  
a2cc 18 03			jr .pastdmark  
a2ce ..			.dmark: db ":0B"  
a2d1 f1			.pastdmark: pop af  
a2d2			endm  
# End of macro DMARK
a2d2				CALLMONITOR 
a2d2 cd 72 ee			call debug_vector  
a2d5				endm  
# End of macro CALLMONITOR
a2d5 c1				pop bc 
a2d6			endif 
a2d6			 
a2d6			; update word dict linked list for new word 
a2d6			 
a2d6			 
a2d6 2a c1 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2d9 23			inc hl     ; move to next work linked list ptr 
a2da			 
a2da ed 5b c2 e2	ld de, (os_new_malloc)		 ; new next word 
a2de 73			ld (hl), e 
a2df 23			inc hl 
a2e0 72			ld (hl), d 
a2e1			 
a2e1			if DEBUG_FORTH_UWORD 
a2e1 ed 4b c1 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2e5			endif 
a2e5			 
a2e5 ed 53 c1 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2e9			 
a2e9			 
a2e9			if DEBUG_FORTH_UWORD 
a2e9						DMARK ":0+" 
a2e9 f5				push af  
a2ea 3a fe a2			ld a, (.dmark)  
a2ed 32 6e ee			ld (debug_mark),a  
a2f0 3a ff a2			ld a, (.dmark+1)  
a2f3 32 6f ee			ld (debug_mark+1),a  
a2f6 3a 00 a3			ld a, (.dmark+2)  
a2f9 32 70 ee			ld (debug_mark+2),a  
a2fc 18 03			jr .pastdmark  
a2fe ..			.dmark: db ":0+"  
a301 f1			.pastdmark: pop af  
a302			endm  
# End of macro DMARK
a302				CALLMONITOR 
a302 cd 72 ee			call debug_vector  
a305				endm  
# End of macro CALLMONITOR
a305			endif 
a305			 
a305				STACKFRAMECHK OFF $8efe $989f 
a305				if DEBUG_STACK_IMB 
a305					if OFF 
a305						exx 
a305						ld hl, $989f 
a305						pop de   ; $989f 
a305						call cmp16 
a305						jr nz, .spnosame 
a305						ld hl, $8efe 
a305						pop de   ; $8efe 
a305						call cmp16 
a305						jr z, .spfrsame 
a305						.spnosame: call showsperror 
a305						.spfrsame: nop 
a305						exx 
a305					endif 
a305				endif 
a305			endm 
# End of macro STACKFRAMECHK
a305			 
a305 c9			ret    ; dont process any remaining parser tokens as they form new word 
a306			 
a306			 
a306			 
a306			 
a306			;		NEXT 
a306			.SCOLN: 
a306			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a306 06				db OPCODE_SCOLN 
a307 52 a3			dw .DROP 
a309 02				db 2 
a30a .. 00			db ";",0           
a30c			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a30c					if DEBUG_FORTH_WORDS_KEY 
a30c						DMARK "SCN" 
a30c f5				push af  
a30d 3a 21 a3			ld a, (.dmark)  
a310 32 6e ee			ld (debug_mark),a  
a313 3a 22 a3			ld a, (.dmark+1)  
a316 32 6f ee			ld (debug_mark+1),a  
a319 3a 23 a3			ld a, (.dmark+2)  
a31c 32 70 ee			ld (debug_mark+2),a  
a31f 18 03			jr .pastdmark  
a321 ..			.dmark: db "SCN"  
a324 f1			.pastdmark: pop af  
a325			endm  
# End of macro DMARK
a325						CALLMONITOR 
a325 cd 72 ee			call debug_vector  
a328				endm  
# End of macro CALLMONITOR
a328					endif 
a328					FORTH_RSP_TOS 
a328 cd 07 9b			call macro_forth_rsp_tos 
a32b				endm 
# End of macro FORTH_RSP_TOS
a32b e5					push hl 
a32c					FORTH_RSP_POP 
a32c cd 11 9b			call macro_forth_rsp_pop 
a32f				endm 
# End of macro FORTH_RSP_POP
a32f e1					pop hl 
a330			;		ex de,hl 
a330 22 c5 e5				ld (os_tok_ptr),hl 
a333			 
a333			if DEBUG_FORTH_UWORD 
a333						DMARK "SCL" 
a333 f5				push af  
a334 3a 48 a3			ld a, (.dmark)  
a337 32 6e ee			ld (debug_mark),a  
a33a 3a 49 a3			ld a, (.dmark+1)  
a33d 32 6f ee			ld (debug_mark+1),a  
a340 3a 4a a3			ld a, (.dmark+2)  
a343 32 70 ee			ld (debug_mark+2),a  
a346 18 03			jr .pastdmark  
a348 ..			.dmark: db "SCL"  
a34b f1			.pastdmark: pop af  
a34c			endm  
# End of macro DMARK
a34c				CALLMONITOR 
a34c cd 72 ee			call debug_vector  
a34f				endm  
# End of macro CALLMONITOR
a34f			endif 
a34f					NEXTW 
a34f c3 f6 9e			jp macro_next 
a352				endm 
# End of macro NEXTW
a352			 
a352			.DROP: 
a352				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a352 1b				db WORD_SYS_CORE+OPCODE_DROP             
a353 7d a3			dw .DUP2            
a355 05				db 4 + 1 
a356 .. 00			db "DROP",0              
a35b				endm 
# End of macro CWHEAD
a35b			; | DROP ( w -- )   drop the TOS item   | DONE 
a35b					if DEBUG_FORTH_WORDS_KEY 
a35b						DMARK "DRP" 
a35b f5				push af  
a35c 3a 70 a3			ld a, (.dmark)  
a35f 32 6e ee			ld (debug_mark),a  
a362 3a 71 a3			ld a, (.dmark+1)  
a365 32 6f ee			ld (debug_mark+1),a  
a368 3a 72 a3			ld a, (.dmark+2)  
a36b 32 70 ee			ld (debug_mark+2),a  
a36e 18 03			jr .pastdmark  
a370 ..			.dmark: db "DRP"  
a373 f1			.pastdmark: pop af  
a374			endm  
# End of macro DMARK
a374						CALLMONITOR 
a374 cd 72 ee			call debug_vector  
a377				endm  
# End of macro CALLMONITOR
a377					endif 
a377					FORTH_DSP_POP 
a377 cd f8 9d			call macro_forth_dsp_pop 
a37a				endm 
# End of macro FORTH_DSP_POP
a37a					NEXTW 
a37a c3 f6 9e			jp macro_next 
a37d				endm 
# End of macro NEXTW
a37d			.DUP2: 
a37d				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a37d 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a37e c2 a3			dw .DROP2            
a380 05				db 4 + 1 
a381 .. 00			db "2DUP",0              
a386				endm 
# End of macro CWHEAD
a386			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a386					if DEBUG_FORTH_WORDS_KEY 
a386						DMARK "2DU" 
a386 f5				push af  
a387 3a 9b a3			ld a, (.dmark)  
a38a 32 6e ee			ld (debug_mark),a  
a38d 3a 9c a3			ld a, (.dmark+1)  
a390 32 6f ee			ld (debug_mark+1),a  
a393 3a 9d a3			ld a, (.dmark+2)  
a396 32 70 ee			ld (debug_mark+2),a  
a399 18 03			jr .pastdmark  
a39b ..			.dmark: db "2DU"  
a39e f1			.pastdmark: pop af  
a39f			endm  
# End of macro DMARK
a39f						CALLMONITOR 
a39f cd 72 ee			call debug_vector  
a3a2				endm  
# End of macro CALLMONITOR
a3a2					endif 
a3a2					FORTH_DSP_VALUEHL 
a3a2 cd 40 9d			call macro_dsp_valuehl 
a3a5				endm 
# End of macro FORTH_DSP_VALUEHL
a3a5 e5					push hl      ; 2 
a3a6			 
a3a6					FORTH_DSP_POP 
a3a6 cd f8 9d			call macro_forth_dsp_pop 
a3a9				endm 
# End of macro FORTH_DSP_POP
a3a9					 
a3a9					FORTH_DSP_VALUEHL 
a3a9 cd 40 9d			call macro_dsp_valuehl 
a3ac				endm 
# End of macro FORTH_DSP_VALUEHL
a3ac			;		push hl      ; 1 
a3ac			 
a3ac					FORTH_DSP_POP 
a3ac cd f8 9d			call macro_forth_dsp_pop 
a3af				endm 
# End of macro FORTH_DSP_POP
a3af			 
a3af			;		pop hl       ; 1 
a3af d1					pop de       ; 2 
a3b0			 
a3b0 cd 49 9b				call forth_push_numhl 
a3b3 eb					ex de, hl 
a3b4 cd 49 9b				call forth_push_numhl 
a3b7			 
a3b7					 
a3b7 eb					ex de, hl 
a3b8			 
a3b8 cd 49 9b				call forth_push_numhl 
a3bb eb					ex de, hl 
a3bc cd 49 9b				call forth_push_numhl 
a3bf			 
a3bf			 
a3bf					NEXTW 
a3bf c3 f6 9e			jp macro_next 
a3c2				endm 
# End of macro NEXTW
a3c2			.DROP2: 
a3c2				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3c2 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3c3 f1 a3			dw .SWAP2            
a3c5 06				db 5 + 1 
a3c6 .. 00			db "2DROP",0              
a3cc				endm 
# End of macro CWHEAD
a3cc			; | 2DROP ( w w -- )    Double drop | DONE 
a3cc					if DEBUG_FORTH_WORDS_KEY 
a3cc						DMARK "2DR" 
a3cc f5				push af  
a3cd 3a e1 a3			ld a, (.dmark)  
a3d0 32 6e ee			ld (debug_mark),a  
a3d3 3a e2 a3			ld a, (.dmark+1)  
a3d6 32 6f ee			ld (debug_mark+1),a  
a3d9 3a e3 a3			ld a, (.dmark+2)  
a3dc 32 70 ee			ld (debug_mark+2),a  
a3df 18 03			jr .pastdmark  
a3e1 ..			.dmark: db "2DR"  
a3e4 f1			.pastdmark: pop af  
a3e5			endm  
# End of macro DMARK
a3e5						CALLMONITOR 
a3e5 cd 72 ee			call debug_vector  
a3e8				endm  
# End of macro CALLMONITOR
a3e8					endif 
a3e8					FORTH_DSP_POP 
a3e8 cd f8 9d			call macro_forth_dsp_pop 
a3eb				endm 
# End of macro FORTH_DSP_POP
a3eb					FORTH_DSP_POP 
a3eb cd f8 9d			call macro_forth_dsp_pop 
a3ee				endm 
# End of macro FORTH_DSP_POP
a3ee					NEXTW 
a3ee c3 f6 9e			jp macro_next 
a3f1				endm 
# End of macro NEXTW
a3f1			.SWAP2: 
a3f1				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3f1 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3f2 1a a4			dw .AT            
a3f4 06				db 5 + 1 
a3f5 .. 00			db "2SWAP",0              
a3fb				endm 
# End of macro CWHEAD
a3fb			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3fb					if DEBUG_FORTH_WORDS_KEY 
a3fb						DMARK "2SW" 
a3fb f5				push af  
a3fc 3a 10 a4			ld a, (.dmark)  
a3ff 32 6e ee			ld (debug_mark),a  
a402 3a 11 a4			ld a, (.dmark+1)  
a405 32 6f ee			ld (debug_mark+1),a  
a408 3a 12 a4			ld a, (.dmark+2)  
a40b 32 70 ee			ld (debug_mark+2),a  
a40e 18 03			jr .pastdmark  
a410 ..			.dmark: db "2SW"  
a413 f1			.pastdmark: pop af  
a414			endm  
# End of macro DMARK
a414						CALLMONITOR 
a414 cd 72 ee			call debug_vector  
a417				endm  
# End of macro CALLMONITOR
a417					endif 
a417					NEXTW 
a417 c3 f6 9e			jp macro_next 
a41a				endm 
# End of macro NEXTW
a41a			.AT: 
a41a				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a41a 1f				db WORD_SYS_CORE+OPCODE_AT             
a41b 4c a4			dw .CAT            
a41d 02				db 1 + 1 
a41e .. 00			db "@",0              
a420				endm 
# End of macro CWHEAD
a420			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a420			 
a420					if DEBUG_FORTH_WORDS_KEY 
a420						DMARK "AT." 
a420 f5				push af  
a421 3a 35 a4			ld a, (.dmark)  
a424 32 6e ee			ld (debug_mark),a  
a427 3a 36 a4			ld a, (.dmark+1)  
a42a 32 6f ee			ld (debug_mark+1),a  
a42d 3a 37 a4			ld a, (.dmark+2)  
a430 32 70 ee			ld (debug_mark+2),a  
a433 18 03			jr .pastdmark  
a435 ..			.dmark: db "AT."  
a438 f1			.pastdmark: pop af  
a439			endm  
# End of macro DMARK
a439						CALLMONITOR 
a439 cd 72 ee			call debug_vector  
a43c				endm  
# End of macro CALLMONITOR
a43c					endif 
a43c			.getbyteat:	 
a43c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a43c cd 40 9d			call macro_dsp_valuehl 
a43f				endm 
# End of macro FORTH_DSP_VALUEHL
a43f					 
a43f			;		push hl 
a43f				 
a43f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a43f cd f8 9d			call macro_forth_dsp_pop 
a442				endm 
# End of macro FORTH_DSP_POP
a442			 
a442			;		pop hl 
a442			 
a442 7e					ld a, (hl) 
a443			 
a443 6f					ld l, a 
a444 26 00				ld h, 0 
a446 cd 49 9b				call forth_push_numhl 
a449			 
a449					NEXTW 
a449 c3 f6 9e			jp macro_next 
a44c				endm 
# End of macro NEXTW
a44c			.CAT: 
a44c				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a44c 20				db WORD_SYS_CORE+OPCODE_CAT             
a44d 75 a4			dw .BANG            
a44f 03				db 2 + 1 
a450 .. 00			db "C@",0              
a453				endm 
# End of macro CWHEAD
a453			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a453					if DEBUG_FORTH_WORDS_KEY 
a453						DMARK "CAA" 
a453 f5				push af  
a454 3a 68 a4			ld a, (.dmark)  
a457 32 6e ee			ld (debug_mark),a  
a45a 3a 69 a4			ld a, (.dmark+1)  
a45d 32 6f ee			ld (debug_mark+1),a  
a460 3a 6a a4			ld a, (.dmark+2)  
a463 32 70 ee			ld (debug_mark+2),a  
a466 18 03			jr .pastdmark  
a468 ..			.dmark: db "CAA"  
a46b f1			.pastdmark: pop af  
a46c			endm  
# End of macro DMARK
a46c						CALLMONITOR 
a46c cd 72 ee			call debug_vector  
a46f				endm  
# End of macro CALLMONITOR
a46f					endif 
a46f c3 3c a4				jp .getbyteat 
a472					NEXTW 
a472 c3 f6 9e			jp macro_next 
a475				endm 
# End of macro NEXTW
a475			.BANG: 
a475				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a475 21				db WORD_SYS_CORE+OPCODE_BANG             
a476 ab a4			dw .CBANG            
a478 02				db 1 + 1 
a479 .. 00			db "!",0              
a47b				endm 
# End of macro CWHEAD
a47b			; | ! ( x w -- ) Store x at address w      | DONE 
a47b					if DEBUG_FORTH_WORDS_KEY 
a47b						DMARK "BNG" 
a47b f5				push af  
a47c 3a 90 a4			ld a, (.dmark)  
a47f 32 6e ee			ld (debug_mark),a  
a482 3a 91 a4			ld a, (.dmark+1)  
a485 32 6f ee			ld (debug_mark+1),a  
a488 3a 92 a4			ld a, (.dmark+2)  
a48b 32 70 ee			ld (debug_mark+2),a  
a48e 18 03			jr .pastdmark  
a490 ..			.dmark: db "BNG"  
a493 f1			.pastdmark: pop af  
a494			endm  
# End of macro DMARK
a494						CALLMONITOR 
a494 cd 72 ee			call debug_vector  
a497				endm  
# End of macro CALLMONITOR
a497					endif 
a497			 
a497			.storebyteat:		 
a497					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a497 cd 40 9d			call macro_dsp_valuehl 
a49a				endm 
# End of macro FORTH_DSP_VALUEHL
a49a					 
a49a e5					push hl 
a49b				 
a49b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a49b cd f8 9d			call macro_forth_dsp_pop 
a49e				endm 
# End of macro FORTH_DSP_POP
a49e			 
a49e					; get byte to poke 
a49e			 
a49e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a49e cd 40 9d			call macro_dsp_valuehl 
a4a1				endm 
# End of macro FORTH_DSP_VALUEHL
a4a1 e5					push hl 
a4a2			 
a4a2			 
a4a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a2 cd f8 9d			call macro_forth_dsp_pop 
a4a5				endm 
# End of macro FORTH_DSP_POP
a4a5			 
a4a5			 
a4a5 d1					pop de 
a4a6 e1					pop hl 
a4a7			 
a4a7 73					ld (hl),e 
a4a8			 
a4a8			 
a4a8					NEXTW 
a4a8 c3 f6 9e			jp macro_next 
a4ab				endm 
# End of macro NEXTW
a4ab			.CBANG: 
a4ab				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a4ab 22				db WORD_SYS_CORE+OPCODE_CBANG             
a4ac d4 a4			dw .SCALL            
a4ae 03				db 2 + 1 
a4af .. 00			db "C!",0              
a4b2				endm 
# End of macro CWHEAD
a4b2			; | C!  ( x w -- ) Store x at address w  | DONE 
a4b2					if DEBUG_FORTH_WORDS_KEY 
a4b2						DMARK "CBA" 
a4b2 f5				push af  
a4b3 3a c7 a4			ld a, (.dmark)  
a4b6 32 6e ee			ld (debug_mark),a  
a4b9 3a c8 a4			ld a, (.dmark+1)  
a4bc 32 6f ee			ld (debug_mark+1),a  
a4bf 3a c9 a4			ld a, (.dmark+2)  
a4c2 32 70 ee			ld (debug_mark+2),a  
a4c5 18 03			jr .pastdmark  
a4c7 ..			.dmark: db "CBA"  
a4ca f1			.pastdmark: pop af  
a4cb			endm  
# End of macro DMARK
a4cb						CALLMONITOR 
a4cb cd 72 ee			call debug_vector  
a4ce				endm  
# End of macro CALLMONITOR
a4ce					endif 
a4ce c3 97 a4				jp .storebyteat 
a4d1					NEXTW 
a4d1 c3 f6 9e			jp macro_next 
a4d4				endm 
# End of macro NEXTW
a4d4			.SCALL: 
a4d4				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4d4 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4d5 08 a5			dw .DEPTH            
a4d7 05				db 4 + 1 
a4d8 .. 00			db "CALL",0              
a4dd				endm 
# End of macro CWHEAD
a4dd			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4dd					if DEBUG_FORTH_WORDS_KEY 
a4dd						DMARK "CLL" 
a4dd f5				push af  
a4de 3a f2 a4			ld a, (.dmark)  
a4e1 32 6e ee			ld (debug_mark),a  
a4e4 3a f3 a4			ld a, (.dmark+1)  
a4e7 32 6f ee			ld (debug_mark+1),a  
a4ea 3a f4 a4			ld a, (.dmark+2)  
a4ed 32 70 ee			ld (debug_mark+2),a  
a4f0 18 03			jr .pastdmark  
a4f2 ..			.dmark: db "CLL"  
a4f5 f1			.pastdmark: pop af  
a4f6			endm  
# End of macro DMARK
a4f6						CALLMONITOR 
a4f6 cd 72 ee			call debug_vector  
a4f9				endm  
# End of macro CALLMONITOR
a4f9					endif 
a4f9			 
a4f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4f9 cd 40 9d			call macro_dsp_valuehl 
a4fc				endm 
# End of macro FORTH_DSP_VALUEHL
a4fc			 
a4fc			;		push hl 
a4fc			 
a4fc					; destroy value TOS 
a4fc			 
a4fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4fc cd f8 9d			call macro_forth_dsp_pop 
a4ff				endm 
# End of macro FORTH_DSP_POP
a4ff			 
a4ff						 
a4ff			;		pop hl 
a4ff			 
a4ff					; how to do a call with hl???? save SP? 
a4ff cd 9a 9e				call forth_call_hl 
a502			 
a502			 
a502					; TODO push value back onto stack for another op etc 
a502			 
a502 cd 49 9b				call forth_push_numhl 
a505					NEXTW 
a505 c3 f6 9e			jp macro_next 
a508				endm 
# End of macro NEXTW
a508			.DEPTH: 
a508				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a508 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a509 45 a5			dw .OVER            
a50b 06				db 5 + 1 
a50c .. 00			db "DEPTH",0              
a512				endm 
# End of macro CWHEAD
a512			; | DEPTH ( -- u ) Push count of stack | DONE 
a512					; take current TOS and remove from base value div by two to get count 
a512					if DEBUG_FORTH_WORDS_KEY 
a512						DMARK "DEP" 
a512 f5				push af  
a513 3a 27 a5			ld a, (.dmark)  
a516 32 6e ee			ld (debug_mark),a  
a519 3a 28 a5			ld a, (.dmark+1)  
a51c 32 6f ee			ld (debug_mark+1),a  
a51f 3a 29 a5			ld a, (.dmark+2)  
a522 32 70 ee			ld (debug_mark+2),a  
a525 18 03			jr .pastdmark  
a527 ..			.dmark: db "DEP"  
a52a f1			.pastdmark: pop af  
a52b			endm  
# End of macro DMARK
a52b						CALLMONITOR 
a52b cd 72 ee			call debug_vector  
a52e				endm  
# End of macro CALLMONITOR
a52e					endif 
a52e			 
a52e			 
a52e 2a f1 e9			ld hl, (cli_data_sp) 
a531 11 2b e8			ld de, cli_data_stack 
a534 ed 52			sbc hl,de 
a536				 
a536				; div by size of stack item 
a536			 
a536 5d				ld e,l 
a537 0e 03			ld c, 3 
a539 cd 6c 8c			call Div8 
a53c			 
a53c 6f				ld l,a 
a53d 26 00			ld h,0 
a53f			 
a53f				;srl h 
a53f				;rr l 
a53f			 
a53f cd 49 9b				call forth_push_numhl 
a542					NEXTW 
a542 c3 f6 9e			jp macro_next 
a545				endm 
# End of macro NEXTW
a545			.OVER: 
a545				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a545 42				db WORD_SYS_CORE+46             
a546 8c a5			dw .PAUSE            
a548 05				db 4 + 1 
a549 .. 00			db "OVER",0              
a54e				endm 
# End of macro CWHEAD
a54e			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a54e					if DEBUG_FORTH_WORDS_KEY 
a54e						DMARK "OVR" 
a54e f5				push af  
a54f 3a 63 a5			ld a, (.dmark)  
a552 32 6e ee			ld (debug_mark),a  
a555 3a 64 a5			ld a, (.dmark+1)  
a558 32 6f ee			ld (debug_mark+1),a  
a55b 3a 65 a5			ld a, (.dmark+2)  
a55e 32 70 ee			ld (debug_mark+2),a  
a561 18 03			jr .pastdmark  
a563 ..			.dmark: db "OVR"  
a566 f1			.pastdmark: pop af  
a567			endm  
# End of macro DMARK
a567						CALLMONITOR 
a567 cd 72 ee			call debug_vector  
a56a				endm  
# End of macro CALLMONITOR
a56a					endif 
a56a			 
a56a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a56a cd 40 9d			call macro_dsp_valuehl 
a56d				endm 
# End of macro FORTH_DSP_VALUEHL
a56d e5					push hl    ; n2 
a56e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a56e cd f8 9d			call macro_forth_dsp_pop 
a571				endm 
# End of macro FORTH_DSP_POP
a571			 
a571					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a571 cd 40 9d			call macro_dsp_valuehl 
a574				endm 
# End of macro FORTH_DSP_VALUEHL
a574 e5					push hl    ; n1 
a575					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a575 cd f8 9d			call macro_forth_dsp_pop 
a578				endm 
# End of macro FORTH_DSP_POP
a578			 
a578 d1					pop de     ; n1 
a579 e1					pop hl     ; n2 
a57a			 
a57a d5					push de 
a57b e5					push hl 
a57c d5					push de 
a57d			 
a57d					; push back  
a57d			 
a57d e1					pop hl 
a57e cd 49 9b				call forth_push_numhl 
a581 e1					pop hl 
a582 cd 49 9b				call forth_push_numhl 
a585 e1					pop hl 
a586 cd 49 9b				call forth_push_numhl 
a589					NEXTW 
a589 c3 f6 9e			jp macro_next 
a58c				endm 
# End of macro NEXTW
a58c			 
a58c			.PAUSE: 
a58c				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a58c 43				db WORD_SYS_CORE+47             
a58d c1 a5			dw .PAUSES            
a58f 08				db 7 + 1 
a590 .. 00			db "PAUSEMS",0              
a598				endm 
# End of macro CWHEAD
a598			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a598					if DEBUG_FORTH_WORDS_KEY 
a598						DMARK "PMS" 
a598 f5				push af  
a599 3a ad a5			ld a, (.dmark)  
a59c 32 6e ee			ld (debug_mark),a  
a59f 3a ae a5			ld a, (.dmark+1)  
a5a2 32 6f ee			ld (debug_mark+1),a  
a5a5 3a af a5			ld a, (.dmark+2)  
a5a8 32 70 ee			ld (debug_mark+2),a  
a5ab 18 03			jr .pastdmark  
a5ad ..			.dmark: db "PMS"  
a5b0 f1			.pastdmark: pop af  
a5b1			endm  
# End of macro DMARK
a5b1						CALLMONITOR 
a5b1 cd 72 ee			call debug_vector  
a5b4				endm  
# End of macro CALLMONITOR
a5b4					endif 
a5b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b4 cd 40 9d			call macro_dsp_valuehl 
a5b7				endm 
# End of macro FORTH_DSP_VALUEHL
a5b7			;		push hl    ; n2 
a5b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b7 cd f8 9d			call macro_forth_dsp_pop 
a5ba				endm 
# End of macro FORTH_DSP_POP
a5ba			;		pop hl 
a5ba			 
a5ba 7d					ld a, l 
a5bb cd d7 89				call aDelayInMS 
a5be				       NEXTW 
a5be c3 f6 9e			jp macro_next 
a5c1				endm 
# End of macro NEXTW
a5c1			.PAUSES:  
a5c1				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5c1 44				db WORD_SYS_CORE+48             
a5c2 30 a6			dw .ROT            
a5c4 06				db 5 + 1 
a5c5 .. 00			db "PAUSE",0              
a5cb				endm 
# End of macro CWHEAD
a5cb			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5cb					if DEBUG_FORTH_WORDS_KEY 
a5cb						DMARK "PAU" 
a5cb f5				push af  
a5cc 3a e0 a5			ld a, (.dmark)  
a5cf 32 6e ee			ld (debug_mark),a  
a5d2 3a e1 a5			ld a, (.dmark+1)  
a5d5 32 6f ee			ld (debug_mark+1),a  
a5d8 3a e2 a5			ld a, (.dmark+2)  
a5db 32 70 ee			ld (debug_mark+2),a  
a5de 18 03			jr .pastdmark  
a5e0 ..			.dmark: db "PAU"  
a5e3 f1			.pastdmark: pop af  
a5e4			endm  
# End of macro DMARK
a5e4						CALLMONITOR 
a5e4 cd 72 ee			call debug_vector  
a5e7				endm  
# End of macro CALLMONITOR
a5e7					endif 
a5e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5e7 cd 40 9d			call macro_dsp_valuehl 
a5ea				endm 
# End of macro FORTH_DSP_VALUEHL
a5ea			;		push hl    ; n2 
a5ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5ea cd f8 9d			call macro_forth_dsp_pop 
a5ed				endm 
# End of macro FORTH_DSP_POP
a5ed			;		pop hl 
a5ed 45					ld b, l 
a5ee					if DEBUG_FORTH_WORDS 
a5ee						DMARK "PAU" 
a5ee f5				push af  
a5ef 3a 03 a6			ld a, (.dmark)  
a5f2 32 6e ee			ld (debug_mark),a  
a5f5 3a 04 a6			ld a, (.dmark+1)  
a5f8 32 6f ee			ld (debug_mark+1),a  
a5fb 3a 05 a6			ld a, (.dmark+2)  
a5fe 32 70 ee			ld (debug_mark+2),a  
a601 18 03			jr .pastdmark  
a603 ..			.dmark: db "PAU"  
a606 f1			.pastdmark: pop af  
a607			endm  
# End of macro DMARK
a607						CALLMONITOR 
a607 cd 72 ee			call debug_vector  
a60a				endm  
# End of macro CALLMONITOR
a60a					endif 
a60a c5			.pauses1:	push bc 
a60b cd f2 89				call delay1s 
a60e c1					pop bc 
a60f					if DEBUG_FORTH_WORDS 
a60f						DMARK "PA1" 
a60f f5				push af  
a610 3a 24 a6			ld a, (.dmark)  
a613 32 6e ee			ld (debug_mark),a  
a616 3a 25 a6			ld a, (.dmark+1)  
a619 32 6f ee			ld (debug_mark+1),a  
a61c 3a 26 a6			ld a, (.dmark+2)  
a61f 32 70 ee			ld (debug_mark+2),a  
a622 18 03			jr .pastdmark  
a624 ..			.dmark: db "PA1"  
a627 f1			.pastdmark: pop af  
a628			endm  
# End of macro DMARK
a628						CALLMONITOR 
a628 cd 72 ee			call debug_vector  
a62b				endm  
# End of macro CALLMONITOR
a62b					endif 
a62b 10 dd				djnz .pauses1 
a62d			 
a62d				       NEXTW 
a62d c3 f6 9e			jp macro_next 
a630				endm 
# End of macro NEXTW
a630			.ROT: 
a630				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a630 45				db WORD_SYS_CORE+49             
a631 7e a6			dw .UWORDS            
a633 04				db 3 + 1 
a634 .. 00			db "ROT",0              
a638				endm 
# End of macro CWHEAD
a638			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a638					if DEBUG_FORTH_WORDS_KEY 
a638						DMARK "ROT" 
a638 f5				push af  
a639 3a 4d a6			ld a, (.dmark)  
a63c 32 6e ee			ld (debug_mark),a  
a63f 3a 4e a6			ld a, (.dmark+1)  
a642 32 6f ee			ld (debug_mark+1),a  
a645 3a 4f a6			ld a, (.dmark+2)  
a648 32 70 ee			ld (debug_mark+2),a  
a64b 18 03			jr .pastdmark  
a64d ..			.dmark: db "ROT"  
a650 f1			.pastdmark: pop af  
a651			endm  
# End of macro DMARK
a651						CALLMONITOR 
a651 cd 72 ee			call debug_vector  
a654				endm  
# End of macro CALLMONITOR
a654					endif 
a654			 
a654					FORTH_DSP_VALUEHL 
a654 cd 40 9d			call macro_dsp_valuehl 
a657				endm 
# End of macro FORTH_DSP_VALUEHL
a657 e5					push hl    ; u3  
a658			 
a658					FORTH_DSP_POP 
a658 cd f8 9d			call macro_forth_dsp_pop 
a65b				endm 
# End of macro FORTH_DSP_POP
a65b			   
a65b					FORTH_DSP_VALUEHL 
a65b cd 40 9d			call macro_dsp_valuehl 
a65e				endm 
# End of macro FORTH_DSP_VALUEHL
a65e e5					push hl     ; u2 
a65f			 
a65f					FORTH_DSP_POP 
a65f cd f8 9d			call macro_forth_dsp_pop 
a662				endm 
# End of macro FORTH_DSP_POP
a662			 
a662					FORTH_DSP_VALUEHL 
a662 cd 40 9d			call macro_dsp_valuehl 
a665				endm 
# End of macro FORTH_DSP_VALUEHL
a665 e5					push hl     ; u1 
a666			 
a666					FORTH_DSP_POP 
a666 cd f8 9d			call macro_forth_dsp_pop 
a669				endm 
# End of macro FORTH_DSP_POP
a669			 
a669 c1					pop bc      ; u1 
a66a e1					pop hl      ; u2 
a66b d1					pop de      ; u3 
a66c			 
a66c			 
a66c c5					push bc 
a66d d5					push de 
a66e e5					push hl 
a66f			 
a66f			 
a66f e1					pop hl 
a670 cd 49 9b				call forth_push_numhl 
a673			 
a673 e1					pop hl 
a674 cd 49 9b				call forth_push_numhl 
a677			 
a677 e1					pop hl 
a678 cd 49 9b				call forth_push_numhl 
a67b					 
a67b			 
a67b			 
a67b			 
a67b			 
a67b			 
a67b				       NEXTW 
a67b c3 f6 9e			jp macro_next 
a67e				endm 
# End of macro NEXTW
a67e			 
a67e			.UWORDS: 
a67e				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a67e 50				db WORD_SYS_CORE+60             
a67f 40 a7			dw .BP            
a681 07				db 6 + 1 
a682 .. 00			db "UWORDS",0              
a689				endm 
# End of macro CWHEAD
a689			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a689			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a689			; | | Following the count are the individual words. 
a689			; | | 
a689			; | | e.g. UWORDS 
a689			; | | BOX DIRLIST 2 
a689			; | |  
a689			; | | Can be used to save the words to storage via: 
a689			; | | UWORDS $01 DO $01 APPEND LOOP 
a689				if DEBUG_FORTH_WORDS_KEY 
a689					DMARK "UWR" 
a689 f5				push af  
a68a 3a 9e a6			ld a, (.dmark)  
a68d 32 6e ee			ld (debug_mark),a  
a690 3a 9f a6			ld a, (.dmark+1)  
a693 32 6f ee			ld (debug_mark+1),a  
a696 3a a0 a6			ld a, (.dmark+2)  
a699 32 70 ee			ld (debug_mark+2),a  
a69c 18 03			jr .pastdmark  
a69e ..			.dmark: db "UWR"  
a6a1 f1			.pastdmark: pop af  
a6a2			endm  
# End of macro DMARK
a6a2					CALLMONITOR 
a6a2 cd 72 ee			call debug_vector  
a6a5				endm  
# End of macro CALLMONITOR
a6a5				endif 
a6a5 21 4b e3				ld hl, baseram 
a6a8					;ld hl, baseusermem 
a6a8 01 00 00				ld bc, 0    ; start a counter 
a6ab			 
a6ab				; skip dict stub 
a6ab			 
a6ab cd 47 a0				call forth_tok_next 
a6ae			 
a6ae			 
a6ae			; while we have words to look for 
a6ae			 
a6ae 7e			.douscan:	ld a, (hl)      
a6af				if DEBUG_FORTH_WORDS 
a6af					DMARK "UWs" 
a6af f5				push af  
a6b0 3a c4 a6			ld a, (.dmark)  
a6b3 32 6e ee			ld (debug_mark),a  
a6b6 3a c5 a6			ld a, (.dmark+1)  
a6b9 32 6f ee			ld (debug_mark+1),a  
a6bc 3a c6 a6			ld a, (.dmark+2)  
a6bf 32 70 ee			ld (debug_mark+2),a  
a6c2 18 03			jr .pastdmark  
a6c4 ..			.dmark: db "UWs"  
a6c7 f1			.pastdmark: pop af  
a6c8			endm  
# End of macro DMARK
a6c8					CALLMONITOR 
a6c8 cd 72 ee			call debug_vector  
a6cb				endm  
# End of macro CALLMONITOR
a6cb				endif 
a6cb fe 00				cp WORD_SYS_END 
a6cd 28 4d				jr z, .udone 
a6cf fe 01				cp WORD_SYS_UWORD 
a6d1 20 44				jr nz, .nuword 
a6d3			 
a6d3				if DEBUG_FORTH_WORDS 
a6d3					DMARK "UWu" 
a6d3 f5				push af  
a6d4 3a e8 a6			ld a, (.dmark)  
a6d7 32 6e ee			ld (debug_mark),a  
a6da 3a e9 a6			ld a, (.dmark+1)  
a6dd 32 6f ee			ld (debug_mark+1),a  
a6e0 3a ea a6			ld a, (.dmark+2)  
a6e3 32 70 ee			ld (debug_mark+2),a  
a6e6 18 03			jr .pastdmark  
a6e8 ..			.dmark: db "UWu"  
a6eb f1			.pastdmark: pop af  
a6ec			endm  
# End of macro DMARK
a6ec					CALLMONITOR 
a6ec cd 72 ee			call debug_vector  
a6ef				endm  
# End of macro CALLMONITOR
a6ef				endif 
a6ef					; we have a uword so push its name to the stack 
a6ef			 
a6ef e5				   	push hl  ; save so we can move to next dict block 
a6f0			 
a6f0					; skip opcode 
a6f0 23					inc hl  
a6f1					; skip next ptr 
a6f1 23					inc hl  
a6f2 23					inc hl 
a6f3					; skip len 
a6f3 23					inc hl 
a6f4				if DEBUG_FORTH_WORDS 
a6f4					DMARK "UWt" 
a6f4 f5				push af  
a6f5 3a 09 a7			ld a, (.dmark)  
a6f8 32 6e ee			ld (debug_mark),a  
a6fb 3a 0a a7			ld a, (.dmark+1)  
a6fe 32 6f ee			ld (debug_mark+1),a  
a701 3a 0b a7			ld a, (.dmark+2)  
a704 32 70 ee			ld (debug_mark+2),a  
a707 18 03			jr .pastdmark  
a709 ..			.dmark: db "UWt"  
a70c f1			.pastdmark: pop af  
a70d			endm  
# End of macro DMARK
a70d					CALLMONITOR 
a70d cd 72 ee			call debug_vector  
a710				endm  
# End of macro CALLMONITOR
a710				endif 
a710 03					inc bc 
a711			 
a711 c5					push bc 
a712 cd b7 9b				call forth_push_str 
a715 c1					pop bc 
a716			 
a716 e1					pop hl 	 
a717			 
a717 cd 47 a0		.nuword:	call forth_tok_next 
a71a 18 92				jr .douscan  
a71c			 
a71c			.udone:		 ; push count of uwords found 
a71c c5					push bc 
a71d e1					pop hl 
a71e			 
a71e				if DEBUG_FORTH_WORDS 
a71e					DMARK "UWc" 
a71e f5				push af  
a71f 3a 33 a7			ld a, (.dmark)  
a722 32 6e ee			ld (debug_mark),a  
a725 3a 34 a7			ld a, (.dmark+1)  
a728 32 6f ee			ld (debug_mark+1),a  
a72b 3a 35 a7			ld a, (.dmark+2)  
a72e 32 70 ee			ld (debug_mark+2),a  
a731 18 03			jr .pastdmark  
a733 ..			.dmark: db "UWc"  
a736 f1			.pastdmark: pop af  
a737			endm  
# End of macro DMARK
a737					CALLMONITOR 
a737 cd 72 ee			call debug_vector  
a73a				endm  
# End of macro CALLMONITOR
a73a				endif 
a73a cd 49 9b				call forth_push_numhl 
a73d			 
a73d			 
a73d				       NEXTW 
a73d c3 f6 9e			jp macro_next 
a740				endm 
# End of macro NEXTW
a740			 
a740			.BP: 
a740				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a740 54				db WORD_SYS_CORE+64             
a741 7a a7			dw .MONITOR            
a743 03				db 2 + 1 
a744 .. 00			db "BP",0              
a747				endm 
# End of macro CWHEAD
a747			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a747			; | | $00 Will enable the break points within specific code paths 
a747			; | | $01 Will disable break points 
a747			; | |  
a747			; | | By default break points are off. Either the above can be used to enable them 
a747			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a747			; | | and on release of the pressed key a message will be disaplayed to notify 
a747			; | | that break points are enabled. Pressing any key will then continue boot process. 
a747					; get byte count 
a747					if DEBUG_FORTH_WORDS_KEY 
a747						DMARK "BP." 
a747 f5				push af  
a748 3a 5c a7			ld a, (.dmark)  
a74b 32 6e ee			ld (debug_mark),a  
a74e 3a 5d a7			ld a, (.dmark+1)  
a751 32 6f ee			ld (debug_mark+1),a  
a754 3a 5e a7			ld a, (.dmark+2)  
a757 32 70 ee			ld (debug_mark+2),a  
a75a 18 03			jr .pastdmark  
a75c ..			.dmark: db "BP."  
a75f f1			.pastdmark: pop af  
a760			endm  
# End of macro DMARK
a760						CALLMONITOR 
a760 cd 72 ee			call debug_vector  
a763				endm  
# End of macro CALLMONITOR
a763					endif 
a763			 
a763					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a763 cd 40 9d			call macro_dsp_valuehl 
a766				endm 
# End of macro FORTH_DSP_VALUEHL
a766			 
a766			;		push hl 
a766			 
a766					; destroy value TOS 
a766			 
a766					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a766 cd f8 9d			call macro_forth_dsp_pop 
a769				endm 
# End of macro FORTH_DSP_POP
a769			 
a769			;		pop hl 
a769			 
a769 3e 00				ld a,0 
a76b bd					cp l 
a76c 28 06				jr z, .bpset 
a76e			;		ld a, '*' 
a76e cd de 94				call bp_off 
a771					NEXTW 
a771 c3 f6 9e			jp macro_next 
a774				endm 
# End of macro NEXTW
a774			 
a774			.bpset:	 
a774					;	ld (os_view_disable), a 
a774 cd d2 94				call bp_on 
a777			 
a777			 
a777					NEXTW 
a777 c3 f6 9e			jp macro_next 
a77a				endm 
# End of macro NEXTW
a77a			 
a77a			 
a77a			.MONITOR: 
a77a				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a77a 55				db WORD_SYS_CORE+65             
a77b ab a7			dw .MALLOC            
a77d 08				db 7 + 1 
a77e .. 00			db "MONITOR",0              
a786				endm 
# End of macro CWHEAD
a786			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a786			; | | At start the current various registers will be displayed with contents. 
a786			; | | Top right corner will show the most recent debug marker seen. 
a786			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a786			; | | and the return stack pointer (RSP). 
a786			; | | Pressing: 
a786			; | |    1 - Initial screen 
a786			; | |    2 - Display a data dump of HL 
a786			; | |    3 - Display a data dump of DE 
a786			; | |    4 - Display a data dump of BC 
a786			; | |    5 - Display a data dump of HL 
a786			; | |    6 - Display a data dump of DSP 
a786			; | |    7 - Display a data dump of RSP 
a786			; | |    8 - Display a data dump of what is at DSP 
a786			; | |    9 - Display a data dump of what is at RSP 
a786			; | |    0 - Exit monitor and continue running. This will also enable break points 
a786			; | |    * - Disable break points 
a786			; | |    # - Enter traditional monitor mode 
a786			; | | 
a786			; | | Monitor Mode 
a786			; | | ------------ 
a786			; | | A prompt of '>' will be shown for various commands: 
a786			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a786			; | |    C - Continue display a data dump from the last set address 
a786			; | |    M xxxx - Set start of memory edit at address xx 
a786			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a786			; | |    Q - Return to previous 
a786					if DEBUG_FORTH_WORDS_KEY 
a786						DMARK "MON" 
a786 f5				push af  
a787 3a 9b a7			ld a, (.dmark)  
a78a 32 6e ee			ld (debug_mark),a  
a78d 3a 9c a7			ld a, (.dmark+1)  
a790 32 6f ee			ld (debug_mark+1),a  
a793 3a 9d a7			ld a, (.dmark+2)  
a796 32 70 ee			ld (debug_mark+2),a  
a799 18 03			jr .pastdmark  
a79b ..			.dmark: db "MON"  
a79e f1			.pastdmark: pop af  
a79f			endm  
# End of macro DMARK
a79f						CALLMONITOR 
a79f cd 72 ee			call debug_vector  
a7a2				endm  
# End of macro CALLMONITOR
a7a2					endif 
a7a2			;		ld a, 0 
a7a2			;		ld (os_view_disable), a 
a7a2 cd d2 94				call bp_on 
a7a5			 
a7a5					CALLMONITOR 
a7a5 cd 72 ee			call debug_vector  
a7a8				endm  
# End of macro CALLMONITOR
a7a8			 
a7a8			;	call monitor 
a7a8			 
a7a8					NEXTW 
a7a8 c3 f6 9e			jp macro_next 
a7ab				endm 
# End of macro NEXTW
a7ab			 
a7ab			 
a7ab			.MALLOC: 
a7ab				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a7ab 56				db WORD_SYS_CORE+66             
a7ac d4 a7			dw .MALLOC2            
a7ae 06				db 5 + 1 
a7af .. 00			db "ALLOT",0              
a7b5				endm 
# End of macro CWHEAD
a7b5			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7b5					if DEBUG_FORTH_WORDS_KEY 
a7b5						DMARK "ALL" 
a7b5 f5				push af  
a7b6 3a ca a7			ld a, (.dmark)  
a7b9 32 6e ee			ld (debug_mark),a  
a7bc 3a cb a7			ld a, (.dmark+1)  
a7bf 32 6f ee			ld (debug_mark+1),a  
a7c2 3a cc a7			ld a, (.dmark+2)  
a7c5 32 70 ee			ld (debug_mark+2),a  
a7c8 18 03			jr .pastdmark  
a7ca ..			.dmark: db "ALL"  
a7cd f1			.pastdmark: pop af  
a7ce			endm  
# End of macro DMARK
a7ce						CALLMONITOR 
a7ce cd 72 ee			call debug_vector  
a7d1				endm  
# End of macro CALLMONITOR
a7d1					endif 
a7d1 c3 fb a7				jp .mallocc 
a7d4			.MALLOC2: 
a7d4				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7d4 56				db WORD_SYS_CORE+66             
a7d5 12 a8			dw .FREE            
a7d7 07				db 6 + 1 
a7d8 .. 00			db "MALLOC",0              
a7df				endm 
# End of macro CWHEAD
a7df			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7df					; get byte count 
a7df					if DEBUG_FORTH_WORDS_KEY 
a7df						DMARK "MAL" 
a7df f5				push af  
a7e0 3a f4 a7			ld a, (.dmark)  
a7e3 32 6e ee			ld (debug_mark),a  
a7e6 3a f5 a7			ld a, (.dmark+1)  
a7e9 32 6f ee			ld (debug_mark+1),a  
a7ec 3a f6 a7			ld a, (.dmark+2)  
a7ef 32 70 ee			ld (debug_mark+2),a  
a7f2 18 03			jr .pastdmark  
a7f4 ..			.dmark: db "MAL"  
a7f7 f1			.pastdmark: pop af  
a7f8			endm  
# End of macro DMARK
a7f8						CALLMONITOR 
a7f8 cd 72 ee			call debug_vector  
a7fb				endm  
# End of macro CALLMONITOR
a7fb					endif 
a7fb			.mallocc: 
a7fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7fb cd 40 9d			call macro_dsp_valuehl 
a7fe				endm 
# End of macro FORTH_DSP_VALUEHL
a7fe			 
a7fe			;		push hl 
a7fe			 
a7fe					; destroy value TOS 
a7fe			 
a7fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7fe cd f8 9d			call macro_forth_dsp_pop 
a801				endm 
# End of macro FORTH_DSP_POP
a801			 
a801			;		pop hl 
a801 cd a3 91				call malloc 
a804				if DEBUG_FORTH_MALLOC_GUARD 
a804 f5					push af 
a805 cd 05 8d				call ishlzero 
a808			;		ld a, l 
a808			;		add h 
a808			;		cp 0 
a808 f1					pop af 
a809					 
a809 cc 03 cc				call z,malloc_error 
a80c				endif 
a80c			 
a80c cd 49 9b				call forth_push_numhl 
a80f					NEXTW 
a80f c3 f6 9e			jp macro_next 
a812				endm 
# End of macro NEXTW
a812			 
a812			.FREE: 
a812				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a812 57				db WORD_SYS_CORE+67             
a813 43 a8			dw .LIST            
a815 05				db 4 + 1 
a816 .. 00			db "FREE",0              
a81b				endm 
# End of macro CWHEAD
a81b			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a81b					if DEBUG_FORTH_WORDS_KEY 
a81b						DMARK "FRE" 
a81b f5				push af  
a81c 3a 30 a8			ld a, (.dmark)  
a81f 32 6e ee			ld (debug_mark),a  
a822 3a 31 a8			ld a, (.dmark+1)  
a825 32 6f ee			ld (debug_mark+1),a  
a828 3a 32 a8			ld a, (.dmark+2)  
a82b 32 70 ee			ld (debug_mark+2),a  
a82e 18 03			jr .pastdmark  
a830 ..			.dmark: db "FRE"  
a833 f1			.pastdmark: pop af  
a834			endm  
# End of macro DMARK
a834						CALLMONITOR 
a834 cd 72 ee			call debug_vector  
a837				endm  
# End of macro CALLMONITOR
a837					endif 
a837					; get address 
a837			 
a837					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a837 cd 40 9d			call macro_dsp_valuehl 
a83a				endm 
# End of macro FORTH_DSP_VALUEHL
a83a			 
a83a			;		push hl 
a83a			 
a83a					; destroy value TOS 
a83a			 
a83a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a83a cd f8 9d			call macro_forth_dsp_pop 
a83d				endm 
# End of macro FORTH_DSP_POP
a83d			 
a83d			;		pop hl 
a83d			if FORTH_ENABLE_MALLOCFREE 
a83d cd 6d 92				call free 
a840			endif 
a840					NEXTW 
a840 c3 f6 9e			jp macro_next 
a843				endm 
# End of macro NEXTW
a843			.LIST: 
a843				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a843 5c				db WORD_SYS_CORE+72             
a844 31 aa			dw .FORGET            
a846 05				db 4 + 1 
a847 .. 00			db "LIST",0              
a84c				endm 
# End of macro CWHEAD
a84c			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a84c			; | | The quoted word must be in upper case. 
a84c				if DEBUG_FORTH_WORDS_KEY 
a84c					DMARK "LST" 
a84c f5				push af  
a84d 3a 61 a8			ld a, (.dmark)  
a850 32 6e ee			ld (debug_mark),a  
a853 3a 62 a8			ld a, (.dmark+1)  
a856 32 6f ee			ld (debug_mark+1),a  
a859 3a 63 a8			ld a, (.dmark+2)  
a85c 32 70 ee			ld (debug_mark+2),a  
a85f 18 03			jr .pastdmark  
a861 ..			.dmark: db "LST"  
a864 f1			.pastdmark: pop af  
a865			endm  
# End of macro DMARK
a865					CALLMONITOR 
a865 cd 72 ee			call debug_vector  
a868				endm  
# End of macro CALLMONITOR
a868				endif 
a868			 
a868					FORTH_DSP_VALUEHL 
a868 cd 40 9d			call macro_dsp_valuehl 
a86b				endm 
# End of macro FORTH_DSP_VALUEHL
a86b			 
a86b e5					push hl 
a86c					FORTH_DSP_POP 
a86c cd f8 9d			call macro_forth_dsp_pop 
a86f				endm 
# End of macro FORTH_DSP_POP
a86f c1					pop bc 
a870			 
a870			; Start format of scratch string 
a870			 
a870 21 c4 e2				ld hl, scratch 
a873			 
a873 3e 3a				ld a, ':' 
a875 77					ld (hl),a 
a876 23					inc hl 
a877 3e 20				ld a, ' ' 
a879 77					ld (hl), a 
a87a			 
a87a					; Get ptr to the word we need to look up 
a87a			 
a87a			;		FORTH_DSP_VALUEHL 
a87a					;v5 FORTH_DSP_VALUE 
a87a				; TODO type check 
a87a			;		inc hl    ; Skip type check  
a87a			;		push hl 
a87a			;		ex de, hl    ; put into DE 
a87a			 
a87a			 
a87a 21 4b e3				ld hl, baseram 
a87d					;ld hl, baseusermem 
a87d			 
a87d e5			push hl   ; sacreifical push 
a87e			 
a87e			.ldouscanm: 
a87e e1				pop hl 
a87f			.ldouscan: 
a87f				if DEBUG_FORTH_WORDS 
a87f					DMARK "LSs" 
a87f f5				push af  
a880 3a 94 a8			ld a, (.dmark)  
a883 32 6e ee			ld (debug_mark),a  
a886 3a 95 a8			ld a, (.dmark+1)  
a889 32 6f ee			ld (debug_mark+1),a  
a88c 3a 96 a8			ld a, (.dmark+2)  
a88f 32 70 ee			ld (debug_mark+2),a  
a892 18 03			jr .pastdmark  
a894 ..			.dmark: db "LSs"  
a897 f1			.pastdmark: pop af  
a898			endm  
# End of macro DMARK
a898					CALLMONITOR 
a898 cd 72 ee			call debug_vector  
a89b				endm  
# End of macro CALLMONITOR
a89b				endif 
a89b				; skip dict stub 
a89b cd 47 a0				call forth_tok_next 
a89e			 
a89e			 
a89e			; while we have words to look for 
a89e			 
a89e 7e				ld a, (hl)      
a89f				if DEBUG_FORTH_WORDS 
a89f					DMARK "LSk" 
a89f f5				push af  
a8a0 3a b4 a8			ld a, (.dmark)  
a8a3 32 6e ee			ld (debug_mark),a  
a8a6 3a b5 a8			ld a, (.dmark+1)  
a8a9 32 6f ee			ld (debug_mark+1),a  
a8ac 3a b6 a8			ld a, (.dmark+2)  
a8af 32 70 ee			ld (debug_mark+2),a  
a8b2 18 03			jr .pastdmark  
a8b4 ..			.dmark: db "LSk"  
a8b7 f1			.pastdmark: pop af  
a8b8			endm  
# End of macro DMARK
a8b8					CALLMONITOR 
a8b8 cd 72 ee			call debug_vector  
a8bb				endm  
# End of macro CALLMONITOR
a8bb				endif 
a8bb					;cp WORD_SYS_END 
a8bb					;jp z, .lunotfound 
a8bb			 
a8bb					; if we hit non uwords then gone too far 
a8bb fe 01				cp WORD_SYS_UWORD 
a8bd c2 ed a9				jp nz, .lunotfound 
a8c0			 
a8c0				if DEBUG_FORTH_WORDS 
a8c0					DMARK "LSu" 
a8c0 f5				push af  
a8c1 3a d5 a8			ld a, (.dmark)  
a8c4 32 6e ee			ld (debug_mark),a  
a8c7 3a d6 a8			ld a, (.dmark+1)  
a8ca 32 6f ee			ld (debug_mark+1),a  
a8cd 3a d7 a8			ld a, (.dmark+2)  
a8d0 32 70 ee			ld (debug_mark+2),a  
a8d3 18 03			jr .pastdmark  
a8d5 ..			.dmark: db "LSu"  
a8d8 f1			.pastdmark: pop af  
a8d9			endm  
# End of macro DMARK
a8d9					CALLMONITOR 
a8d9 cd 72 ee			call debug_vector  
a8dc				endm  
# End of macro CALLMONITOR
a8dc				endif 
a8dc			 
a8dc					; found a uword but is it the one we want... 
a8dc			 
a8dc c5					push bc     ; uword to find is on bc 
a8dd d1					pop de 
a8de			 
a8de e5					push hl  ; to save the ptr 
a8df			 
a8df					; skip opcode 
a8df 23					inc hl  
a8e0					; skip next ptr 
a8e0 23					inc hl  
a8e1 23					inc hl 
a8e2					; skip len 
a8e2 23					inc hl 
a8e3			 
a8e3				if DEBUG_FORTH_WORDS 
a8e3					DMARK "LSc" 
a8e3 f5				push af  
a8e4 3a f8 a8			ld a, (.dmark)  
a8e7 32 6e ee			ld (debug_mark),a  
a8ea 3a f9 a8			ld a, (.dmark+1)  
a8ed 32 6f ee			ld (debug_mark+1),a  
a8f0 3a fa a8			ld a, (.dmark+2)  
a8f3 32 70 ee			ld (debug_mark+2),a  
a8f6 18 03			jr .pastdmark  
a8f8 ..			.dmark: db "LSc"  
a8fb f1			.pastdmark: pop af  
a8fc			endm  
# End of macro DMARK
a8fc					CALLMONITOR 
a8fc cd 72 ee			call debug_vector  
a8ff				endm  
# End of macro CALLMONITOR
a8ff				endif 
a8ff cd 72 91				call strcmp 
a902 c2 7e a8				jp nz, .ldouscanm 
a905				 
a905			 
a905			 
a905					; we have a uword so push its name to the stack 
a905			 
a905			;	   	push hl  ; save so we can move to next dict block 
a905 e1			pop hl 
a906			 
a906				if DEBUG_FORTH_WORDS 
a906					DMARK "LSm" 
a906 f5				push af  
a907 3a 1b a9			ld a, (.dmark)  
a90a 32 6e ee			ld (debug_mark),a  
a90d 3a 1c a9			ld a, (.dmark+1)  
a910 32 6f ee			ld (debug_mark+1),a  
a913 3a 1d a9			ld a, (.dmark+2)  
a916 32 70 ee			ld (debug_mark+2),a  
a919 18 03			jr .pastdmark  
a91b ..			.dmark: db "LSm"  
a91e f1			.pastdmark: pop af  
a91f			endm  
# End of macro DMARK
a91f					CALLMONITOR 
a91f cd 72 ee			call debug_vector  
a922				endm  
# End of macro CALLMONITOR
a922				endif 
a922			 
a922					; skip opcode 
a922 23					inc hl  
a923					; skip next ptr 
a923 23					inc hl  
a924 23					inc hl 
a925					; skip len 
a925 7e					ld a, (hl)   ; save length to add 
a926				if DEBUG_FORTH_WORDS 
a926					DMARK "LS2" 
a926 f5				push af  
a927 3a 3b a9			ld a, (.dmark)  
a92a 32 6e ee			ld (debug_mark),a  
a92d 3a 3c a9			ld a, (.dmark+1)  
a930 32 6f ee			ld (debug_mark+1),a  
a933 3a 3d a9			ld a, (.dmark+2)  
a936 32 70 ee			ld (debug_mark+2),a  
a939 18 03			jr .pastdmark  
a93b ..			.dmark: db "LS2"  
a93e f1			.pastdmark: pop af  
a93f			endm  
# End of macro DMARK
a93f					CALLMONITOR 
a93f cd 72 ee			call debug_vector  
a942				endm  
# End of macro CALLMONITOR
a942				endif 
a942			 
a942					; save this location 
a942				 
a942 e5					push hl 
a943			 
a943 23					inc hl 
a944 11 c6 e2				ld de, scratch+2 
a947 4f					ld c, a 
a948 06 00				ld b, 0 
a94a			 
a94a				if DEBUG_FORTH_WORDS 
a94a					DMARK "LSn" 
a94a f5				push af  
a94b 3a 5f a9			ld a, (.dmark)  
a94e 32 6e ee			ld (debug_mark),a  
a951 3a 60 a9			ld a, (.dmark+1)  
a954 32 6f ee			ld (debug_mark+1),a  
a957 3a 61 a9			ld a, (.dmark+2)  
a95a 32 70 ee			ld (debug_mark+2),a  
a95d 18 03			jr .pastdmark  
a95f ..			.dmark: db "LSn"  
a962 f1			.pastdmark: pop af  
a963			endm  
# End of macro DMARK
a963					CALLMONITOR 
a963 cd 72 ee			call debug_vector  
a966				endm  
# End of macro CALLMONITOR
a966				endif 
a966			 
a966					; copy uword name to scratch 
a966			 
a966 ed b0				ldir 
a968			 
a968 1b					dec de 
a969 3e 20				ld a, ' '    ; change null to space 
a96b 12					ld (de), a 
a96c			 
a96c 13					inc de 
a96d			 
a96d d5					push de 
a96e c1					pop bc     ; move scratch pointer to end of word name and save it 
a96f			 
a96f e1					pop hl 
a970 7e					ld a, (hl) 
a971					;inc hl 
a971					; skip word string 
a971 cd dc 8c				call addatohl 
a974			 
a974 23					inc hl 
a975			 
a975				if DEBUG_FORTH_WORDS 
a975					DMARK "LS3" 
a975 f5				push af  
a976 3a 8a a9			ld a, (.dmark)  
a979 32 6e ee			ld (debug_mark),a  
a97c 3a 8b a9			ld a, (.dmark+1)  
a97f 32 6f ee			ld (debug_mark+1),a  
a982 3a 8c a9			ld a, (.dmark+2)  
a985 32 70 ee			ld (debug_mark+2),a  
a988 18 03			jr .pastdmark  
a98a ..			.dmark: db "LS3"  
a98d f1			.pastdmark: pop af  
a98e			endm  
# End of macro DMARK
a98e					CALLMONITOR 
a98e cd 72 ee			call debug_vector  
a991				endm  
# End of macro CALLMONITOR
a991				endif 
a991					; should now be at the start of the machine code to setup the eval of the uword 
a991					; now locate the ptr to the string defintion 
a991			 
a991					; skip ld hl, 
a991					; then load the ptr 
a991			; TODO use get from hl ptr 
a991 23					inc hl 
a992 5e					ld e, (hl) 
a993 23					inc hl 
a994 56					ld d, (hl) 
a995 eb					ex de, hl 
a996			 
a996			 
a996				if DEBUG_FORTH_WORDS 
a996					DMARK "LSt" 
a996 f5				push af  
a997 3a ab a9			ld a, (.dmark)  
a99a 32 6e ee			ld (debug_mark),a  
a99d 3a ac a9			ld a, (.dmark+1)  
a9a0 32 6f ee			ld (debug_mark+1),a  
a9a3 3a ad a9			ld a, (.dmark+2)  
a9a6 32 70 ee			ld (debug_mark+2),a  
a9a9 18 03			jr .pastdmark  
a9ab ..			.dmark: db "LSt"  
a9ae f1			.pastdmark: pop af  
a9af			endm  
# End of macro DMARK
a9af					CALLMONITOR 
a9af cd 72 ee			call debug_vector  
a9b2				endm  
# End of macro CALLMONITOR
a9b2				endif 
a9b2			 
a9b2			; cant push right now due to tokenised strings  
a9b2			 
a9b2			; get the destination of where to copy this definition to. 
a9b2			 
a9b2 c5					push bc 
a9b3 d1					pop de 
a9b4			 
a9b4 7e			.listl:         ld a,(hl) 
a9b5 fe 00				cp 0 
a9b7 28 09				jr z, .lreplsp     ; replace zero with space 
a9b9					;cp FORTH_END_BUFFER 
a9b9 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9bb 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9bd				 
a9bd					; just copy this char as is then 
a9bd			 
a9bd 12					ld (de), a 
a9be			 
a9be 23			.listnxt:	inc hl 
a9bf 13					inc de 
a9c0 18 f2				jr .listl 
a9c2			 
a9c2 3e 20		.lreplsp:	ld a,' ' 
a9c4 12					ld (de), a 
a9c5 18 f7				jr .listnxt 
a9c7			 
a9c7			; close up uword def 
a9c7			 
a9c7			.listdone: 
a9c7 12					ld (de), a 
a9c8 13					inc de 
a9c9 3e 00				ld a, 0 
a9cb 12					ld (de), a 
a9cc			 
a9cc			; now have def so clean up and push to stack 
a9cc			 
a9cc 21 c4 e2				ld hl, scratch 
a9cf				if DEBUG_FORTH_WORDS 
a9cf					DMARK "Ltp" 
a9cf f5				push af  
a9d0 3a e4 a9			ld a, (.dmark)  
a9d3 32 6e ee			ld (debug_mark),a  
a9d6 3a e5 a9			ld a, (.dmark+1)  
a9d9 32 6f ee			ld (debug_mark+1),a  
a9dc 3a e6 a9			ld a, (.dmark+2)  
a9df 32 70 ee			ld (debug_mark+2),a  
a9e2 18 03			jr .pastdmark  
a9e4 ..			.dmark: db "Ltp"  
a9e7 f1			.pastdmark: pop af  
a9e8			endm  
# End of macro DMARK
a9e8					CALLMONITOR 
a9e8 cd 72 ee			call debug_vector  
a9eb				endm  
# End of macro CALLMONITOR
a9eb				endif 
a9eb			 
a9eb 18 1f			jr .listpush 
a9ed			 
a9ed			;.lnuword:	pop hl 
a9ed			;		call forth_tok_next 
a9ed			;		jp .ldouscan  
a9ed			 
a9ed			.lunotfound:		  
a9ed			 
a9ed				if DEBUG_FORTH_WORDS 
a9ed					DMARK "LSn" 
a9ed f5				push af  
a9ee 3a 02 aa			ld a, (.dmark)  
a9f1 32 6e ee			ld (debug_mark),a  
a9f4 3a 03 aa			ld a, (.dmark+1)  
a9f7 32 6f ee			ld (debug_mark+1),a  
a9fa 3a 04 aa			ld a, (.dmark+2)  
a9fd 32 70 ee			ld (debug_mark+2),a  
aa00 18 03			jr .pastdmark  
aa02 ..			.dmark: db "LSn"  
aa05 f1			.pastdmark: pop af  
aa06			endm  
# End of macro DMARK
aa06					CALLMONITOR 
aa06 cd 72 ee			call debug_vector  
aa09				endm  
# End of macro CALLMONITOR
aa09				endif 
aa09			 
aa09					 
aa09			;		FORTH_DSP_POP 
aa09			;		ld hl, .luno 
aa09			 
aa09					NEXTW			 
aa09 c3 f6 9e			jp macro_next 
aa0c				endm 
# End of macro NEXTW
aa0c			 
aa0c			.listpush: 
aa0c				if DEBUG_FORTH_WORDS 
aa0c					DMARK "LS>" 
aa0c f5				push af  
aa0d 3a 21 aa			ld a, (.dmark)  
aa10 32 6e ee			ld (debug_mark),a  
aa13 3a 22 aa			ld a, (.dmark+1)  
aa16 32 6f ee			ld (debug_mark+1),a  
aa19 3a 23 aa			ld a, (.dmark+2)  
aa1c 32 70 ee			ld (debug_mark+2),a  
aa1f 18 03			jr .pastdmark  
aa21 ..			.dmark: db "LS>"  
aa24 f1			.pastdmark: pop af  
aa25			endm  
# End of macro DMARK
aa25					CALLMONITOR 
aa25 cd 72 ee			call debug_vector  
aa28				endm  
# End of macro CALLMONITOR
aa28				endif 
aa28 cd b7 9b				call forth_push_str 
aa2b			 
aa2b			 
aa2b			 
aa2b					NEXTW 
aa2b c3 f6 9e			jp macro_next 
aa2e				endm 
# End of macro NEXTW
aa2e			 
aa2e			;.luno:    db "Word not found",0 
aa2e			 
aa2e			 
aa2e			 
aa2e			 
aa2e			 
aa2e			;		push hl   ; save pointer to start of uword def string 
aa2e			; 
aa2e			;; look for FORTH_EOL_LINE 
aa2e			;		ld a, FORTH_END_BUFFER 
aa2e			;		call strlent 
aa2e			; 
aa2e			;		inc hl		 ; space for coln def 
aa2e			;		inc hl 
aa2e			;		inc hl          ; space for terms 
aa2e			;		inc hl 
aa2e			; 
aa2e			;		ld a, 20   ; TODO get actual length 
aa2e			;		call addatohl    ; include a random amount of room for the uword name 
aa2e			; 
aa2e			;		 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt1" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;		 
aa2e			; 
aa2e			;; malloc space for the string because we cant change it 
aa2e			; 
aa2e			;		call malloc 
aa2e			;	if DEBUG_FORTH_MALLOC_GUARD 
aa2e			;		push af 
aa2e			;		call ishlzero 
aa2e			;		pop af 
aa2e			;		 
aa2e			;		call z,malloc_error 
aa2e			;	endif 
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt2" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;		pop de 
aa2e			;		push hl    ; push the malloc to release later 
aa2e			;		push hl   ;  push back a copy for the later stack push 
aa2e			;		 
aa2e			;; copy the string swapping out the zero terms for spaces 
aa2e			; 
aa2e			;		; de has our source 
aa2e			;		; hl has our dest 
aa2e			; 
aa2e			;; add the coln def 
aa2e			; 
aa2e			;		ld a, ':' 
aa2e			;		ld (hl), a 
aa2e			;		inc hl 
aa2e			;		ld a, ' ' 
aa2e			;		ld (hl), a 
aa2e			;		inc hl 
aa2e			; 
aa2e			;; add the uname word 
aa2e			;		push de   ; save our string for now 
aa2e			;		ex de, hl 
aa2e			; 
aa2e			;		FORTH_DSP_VALUE 
aa2e			;		;v5 FORTH_DSP_VALUE 
aa2e			; 
aa2e			;		inc hl   ; skip type but we know by now this is OK 
aa2e			; 
aa2e			;.luword:	ld a,(hl) 
aa2e			;		cp 0 
aa2e			;		jr z, .luword2 
aa2e			;		ld (de), a 
aa2e			;		inc de 
aa2e			;		inc hl 
aa2e			;		jr .luword 
aa2e			; 
aa2e			;.luword2:	ld a, ' ' 
aa2e			;		ld (de), a 
aa2e			;;		inc hl 
aa2e			;;		inc de 
aa2e			;;		ld (de), a 
aa2e			;;		inc hl 
aa2e			;		inc de 
aa2e			; 
aa2e			;		ex de, hl 
aa2e			;		pop de 
aa2e			;		 
aa2e			;		 
aa2e			; 
aa2e			;; detoken that string and copy it 
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt2" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;.ldetok:	ld a, (de) 
aa2e			;		cp FORTH_END_BUFFER 
aa2e			;		jr z, .ldetokend 
aa2e			;		; swap out any zero term for space 
aa2e			;		cp 0 
aa2e			;		jr nz, .ldetoknext 
aa2e			;		ld a, ' ' 
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "LtS" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;.ldetoknext:	ld (hl), a 
aa2e			;		inc de 
aa2e			;		inc hl 
aa2e			;		jr .ldetok 
aa2e			; 
aa2e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa2e			;		ld (hl), a  
aa2e			; 
aa2e			;; free that temp malloc 
aa2e			; 
aa2e			;		pop hl    
aa2e			; 
aa2e			;	if DEBUG_FORTH_WORDS 
aa2e			;		DMARK "Lt4" 
aa2e			;		CALLMONITOR 
aa2e			;	endif 
aa2e			;		call forth_apushstrhl 
aa2e			; 
aa2e			;		; get rid of temp malloc area 
aa2e			; 
aa2e			;		pop hl 
aa2e			;		call free 
aa2e			; 
aa2e			;		jr .ludone 
aa2e			; 
aa2e			;.lnuword:	pop hl 
aa2e			;		call forth_tok_next 
aa2e			;		jp .ldouscan  
aa2e			; 
aa2e			;.ludone:		 pop hl 
aa2e			; 
aa2e					NEXTW 
aa2e c3 f6 9e			jp macro_next 
aa31				endm 
# End of macro NEXTW
aa31			 
aa31			.FORGET: 
aa31				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa31 5d				db WORD_SYS_CORE+73             
aa32 aa aa			dw .NOP            
aa34 07				db 6 + 1 
aa35 .. 00			db "FORGET",0              
aa3c				endm 
# End of macro CWHEAD
aa3c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa3c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa3c			; | |  
aa3c			; | | e.g. "MORE" forget 
aa3c					if DEBUG_FORTH_WORDS_KEY 
aa3c						DMARK "FRG" 
aa3c f5				push af  
aa3d 3a 51 aa			ld a, (.dmark)  
aa40 32 6e ee			ld (debug_mark),a  
aa43 3a 52 aa			ld a, (.dmark+1)  
aa46 32 6f ee			ld (debug_mark+1),a  
aa49 3a 53 aa			ld a, (.dmark+2)  
aa4c 32 70 ee			ld (debug_mark+2),a  
aa4f 18 03			jr .pastdmark  
aa51 ..			.dmark: db "FRG"  
aa54 f1			.pastdmark: pop af  
aa55			endm  
# End of macro DMARK
aa55						CALLMONITOR 
aa55 cd 72 ee			call debug_vector  
aa58				endm  
# End of macro CALLMONITOR
aa58					endif 
aa58			 
aa58				; find uword 
aa58			        ; update start of word with "_" 
aa58				; replace uword with deleted flag 
aa58			 
aa58			 
aa58			;	if DEBUG_FORTH_WORDS 
aa58			;		DMARK "FOG" 
aa58			;		CALLMONITOR 
aa58			;	endif 
aa58			 
aa58			 
aa58					; Get ptr to the word we need to look up 
aa58			 
aa58					FORTH_DSP_VALUEHL 
aa58 cd 40 9d			call macro_dsp_valuehl 
aa5b				endm 
# End of macro FORTH_DSP_VALUEHL
aa5b					;v5 FORTH_DSP_VALUE 
aa5b				; TODO type check 
aa5b			;		inc hl    ; Skip type check  
aa5b e5					push hl 
aa5c c1					pop bc 
aa5d			;		ex de, hl    ; put into DE 
aa5d			 
aa5d			 
aa5d 21 4b e3				ld hl, baseram 
aa60					;ld hl, baseusermem 
aa60			 
aa60				; skip dict stub 
aa60			;	call forth_tok_next 
aa60 e5			push hl   ; sacreifical push 
aa61			 
aa61			.fldouscanm: 
aa61 e1				pop hl 
aa62			.fldouscan: 
aa62			;	if DEBUG_FORTH_WORDS 
aa62			;		DMARK "LSs" 
aa62			;		CALLMONITOR 
aa62			;	endif 
aa62				; skip dict stub 
aa62 cd 47 a0				call forth_tok_next 
aa65			 
aa65			 
aa65			; while we have words to look for 
aa65			 
aa65 7e				ld a, (hl)      
aa66			;	if DEBUG_FORTH_WORDS 
aa66			;		DMARK "LSk" 
aa66			;		CALLMONITOR 
aa66			;	endif 
aa66 fe 00				cp WORD_SYS_END 
aa68 ca a4 aa				jp z, .flunotfound 
aa6b fe 01				cp WORD_SYS_UWORD 
aa6d c2 62 aa				jp nz, .fldouscan 
aa70			 
aa70			;	if DEBUG_FORTH_WORDS 
aa70			;		DMARK "LSu" 
aa70			;		CALLMONITOR 
aa70			;	endif 
aa70			 
aa70					; found a uword but is it the one we want... 
aa70			 
aa70 c5					push bc     ; uword to find is on bc 
aa71 d1					pop de 
aa72			 
aa72 e5					push hl  ; to save the ptr 
aa73			 
aa73					; skip opcode 
aa73 23					inc hl  
aa74					; skip next ptr 
aa74 23					inc hl  
aa75 23					inc hl 
aa76					; skip len 
aa76 23					inc hl 
aa77			 
aa77			;	if DEBUG_FORTH_WORDS 
aa77			;		DMARK "LSc" 
aa77			;		CALLMONITOR 
aa77			;	endif 
aa77 cd 72 91				call strcmp 
aa7a c2 61 aa				jp nz, .fldouscanm 
aa7d			; 
aa7d			; 
aa7d			;; while we have words to look for 
aa7d			; 
aa7d			;.fdouscan:	ld a, (hl)      
aa7d			;	if DEBUG_FORTH_WORDS 
aa7d			;		DMARK "LSs" 
aa7d			;		CALLMONITOR 
aa7d			;	endif 
aa7d			;		cp WORD_SYS_END 
aa7d			;		jp z, .fudone 
aa7d			;		cp WORD_SYS_UWORD 
aa7d			;		jp nz, .fnuword 
aa7d			; 
aa7d			;	if DEBUG_FORTH_WORDS 
aa7d			;		DMARK "FGu" 
aa7d			;		CALLMONITOR 
aa7d			;	endif 
aa7d			; 
aa7d			;		; found a uword but is it the one we want... 
aa7d			; 
aa7d			; 
aa7d			;	        pop de   ; get back the dsp name 
aa7d			;		push de 
aa7d			; 
aa7d			;		push hl  ; to save the ptr 
aa7d			; 
aa7d			;		; skip opcode 
aa7d			;		inc hl  
aa7d			;		; skip next ptr 
aa7d			;		inc hl  
aa7d			;		inc hl 
aa7d			;		; skip len 
aa7d			;		inc hl 
aa7d			; 
aa7d			;	if DEBUG_FORTH_WORDS 
aa7d			;		DMARK "FGc" 
aa7d			;		CALLMONITOR 
aa7d			;	endif 
aa7d			;		call strcmp 
aa7d			;		jp nz, .fnuword 
aa7d			 
aa7d			 
aa7d e1			pop hl 
aa7e			 
aa7e				 
aa7e				if DEBUG_FORTH_WORDS 
aa7e					DMARK "FGm" 
aa7e f5				push af  
aa7f 3a 93 aa			ld a, (.dmark)  
aa82 32 6e ee			ld (debug_mark),a  
aa85 3a 94 aa			ld a, (.dmark+1)  
aa88 32 6f ee			ld (debug_mark+1),a  
aa8b 3a 95 aa			ld a, (.dmark+2)  
aa8e 32 70 ee			ld (debug_mark+2),a  
aa91 18 03			jr .pastdmark  
aa93 ..			.dmark: db "FGm"  
aa96 f1			.pastdmark: pop af  
aa97			endm  
# End of macro DMARK
aa97					CALLMONITOR 
aa97 cd 72 ee			call debug_vector  
aa9a				endm  
# End of macro CALLMONITOR
aa9a				endif 
aa9a			 
aa9a			 
aa9a			 
aa9a					; we have a uword so push its name to the stack 
aa9a			 
aa9a			;	   	push hl  ; save so we can move to next dict block 
aa9a			;pop hl 
aa9a			 
aa9a					; update opcode to deleted 
aa9a 3e 03				ld a, WORD_SYS_DELETED 
aa9c 77					ld (hl), a 
aa9d			 
aa9d 23					inc hl  
aa9e					; skip next ptr 
aa9e 23					inc hl  
aa9f 23					inc hl 
aaa0					; skip len 
aaa0 23					inc hl 
aaa1			 
aaa1					; TODO change parser to skip deleted words but for now mark it out 
aaa1 3e 5f				ld a, "_" 
aaa3 77					ld  (hl),a 
aaa4			 
aaa4			;		jr .fudone 
aaa4			; 
aaa4			;.fnuword:	pop hl 
aaa4			;		call forth_tok_next 
aaa4			;		jp .fdouscan  
aaa4			 
aaa4			.flunotfound:		  
aaa4			 
aaa4			 
aaa4					 
aaa4					FORTH_DSP_POP 
aaa4 cd f8 9d			call macro_forth_dsp_pop 
aaa7				endm 
# End of macro FORTH_DSP_POP
aaa7			;		ld hl, .luno 
aaa7			;.fudone:		 pop hl 
aaa7					NEXTW 
aaa7 c3 f6 9e			jp macro_next 
aaaa				endm 
# End of macro NEXTW
aaaa			.NOP: 
aaaa				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aaaa 61				db WORD_SYS_CORE+77             
aaab d1 aa			dw .COMO            
aaad 04				db 3 + 1 
aaae .. 00			db "NOP",0              
aab2				endm 
# End of macro CWHEAD
aab2			; | NOP (  --  ) Do nothing | DONE 
aab2					if DEBUG_FORTH_WORDS_KEY 
aab2						DMARK "NOP" 
aab2 f5				push af  
aab3 3a c7 aa			ld a, (.dmark)  
aab6 32 6e ee			ld (debug_mark),a  
aab9 3a c8 aa			ld a, (.dmark+1)  
aabc 32 6f ee			ld (debug_mark+1),a  
aabf 3a c9 aa			ld a, (.dmark+2)  
aac2 32 70 ee			ld (debug_mark+2),a  
aac5 18 03			jr .pastdmark  
aac7 ..			.dmark: db "NOP"  
aaca f1			.pastdmark: pop af  
aacb			endm  
# End of macro DMARK
aacb						CALLMONITOR 
aacb cd 72 ee			call debug_vector  
aace				endm  
# End of macro CALLMONITOR
aace					endif 
aace				       NEXTW 
aace c3 f6 9e			jp macro_next 
aad1				endm 
# End of macro NEXTW
aad1			.COMO: 
aad1				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aad1 6e				db WORD_SYS_CORE+90             
aad2 23 ab			dw .COMC            
aad4 02				db 1 + 1 
aad5 .. 00			db "(",0              
aad7				endm 
# End of macro CWHEAD
aad7			; | ( ( -- )  Start of comment | DONE 
aad7			 
aad7			 
aad7 2a c5 e5				ld hl, ( os_tok_ptr) 
aada 11 1e ab			ld de, .closepar 
aadd					 
aadd					if DEBUG_FORTH_WORDS 
aadd						DMARK ").." 
aadd f5				push af  
aade 3a f2 aa			ld a, (.dmark)  
aae1 32 6e ee			ld (debug_mark),a  
aae4 3a f3 aa			ld a, (.dmark+1)  
aae7 32 6f ee			ld (debug_mark+1),a  
aaea 3a f4 aa			ld a, (.dmark+2)  
aaed 32 70 ee			ld (debug_mark+2),a  
aaf0 18 03			jr .pastdmark  
aaf2 ..			.dmark: db ").."  
aaf5 f1			.pastdmark: pop af  
aaf6			endm  
# End of macro DMARK
aaf6						CALLMONITOR 
aaf6 cd 72 ee			call debug_vector  
aaf9				endm  
# End of macro CALLMONITOR
aaf9					endif 
aaf9 cd 11 a0			call findnexttok  
aafc			 
aafc					if DEBUG_FORTH_WORDS 
aafc						DMARK "IF5" 
aafc f5				push af  
aafd 3a 11 ab			ld a, (.dmark)  
ab00 32 6e ee			ld (debug_mark),a  
ab03 3a 12 ab			ld a, (.dmark+1)  
ab06 32 6f ee			ld (debug_mark+1),a  
ab09 3a 13 ab			ld a, (.dmark+2)  
ab0c 32 70 ee			ld (debug_mark+2),a  
ab0f 18 03			jr .pastdmark  
ab11 ..			.dmark: db "IF5"  
ab14 f1			.pastdmark: pop af  
ab15			endm  
# End of macro DMARK
ab15						CALLMONITOR 
ab15 cd 72 ee			call debug_vector  
ab18				endm  
# End of macro CALLMONITOR
ab18					endif 
ab18				; replace below with ) exec using tok_ptr 
ab18 22 c5 e5			ld (os_tok_ptr), hl 
ab1b c3 87 9f			jp exec1 
ab1e			 
ab1e .. 00			.closepar:   db ")",0 
ab20			 
ab20				       NEXTW 
ab20 c3 f6 9e			jp macro_next 
ab23				endm 
# End of macro NEXTW
ab23			.COMC: 
ab23				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab23 6f				db WORD_SYS_CORE+91             
ab24 2c ab			dw .SCRATCH            
ab26 02				db 1 + 1 
ab27 .. 00			db ")",0              
ab29				endm 
# End of macro CWHEAD
ab29			; | ) ( -- )  End of comment |  DONE  
ab29				       NEXTW 
ab29 c3 f6 9e			jp macro_next 
ab2c				endm 
# End of macro NEXTW
ab2c			 
ab2c			.SCRATCH: 
ab2c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab2c 6f				db WORD_SYS_CORE+91             
ab2d 67 ab			dw .INC            
ab2f 08				db 7 + 1 
ab30 .. 00			db "SCRATCH",0              
ab38				endm 
# End of macro CWHEAD
ab38			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab38			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab38			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab38			; | |  
ab38			; | | e.g.    : score $00 scratch ; 
ab38			; | |  
ab38			; | | $00 score ! 
ab38			; | | $01 score +! 
ab38			; | |  
ab38			; | | e.g.   : varword $0a scratch ;  
ab38			; | | 
ab38			; | | $8000 varword ! 
ab38					if DEBUG_FORTH_WORDS_KEY 
ab38						DMARK "SCR" 
ab38 f5				push af  
ab39 3a 4d ab			ld a, (.dmark)  
ab3c 32 6e ee			ld (debug_mark),a  
ab3f 3a 4e ab			ld a, (.dmark+1)  
ab42 32 6f ee			ld (debug_mark+1),a  
ab45 3a 4f ab			ld a, (.dmark+2)  
ab48 32 70 ee			ld (debug_mark+2),a  
ab4b 18 03			jr .pastdmark  
ab4d ..			.dmark: db "SCR"  
ab50 f1			.pastdmark: pop af  
ab51			endm  
# End of macro DMARK
ab51						CALLMONITOR 
ab51 cd 72 ee			call debug_vector  
ab54				endm  
# End of macro CALLMONITOR
ab54					endif 
ab54			 
ab54					FORTH_DSP_VALUEHL 
ab54 cd 40 9d			call macro_dsp_valuehl 
ab57				endm 
# End of macro FORTH_DSP_VALUEHL
ab57				 
ab57					FORTH_DSP_POP 
ab57 cd f8 9d			call macro_forth_dsp_pop 
ab5a				endm 
# End of macro FORTH_DSP_POP
ab5a			 
ab5a 7d					ld a, l 
ab5b 21 e9 e7				ld hl, os_var_array 
ab5e cd dc 8c				call addatohl 
ab61			 
ab61 cd 49 9b				call forth_push_numhl 
ab64			 
ab64				       NEXTW 
ab64 c3 f6 9e			jp macro_next 
ab67				endm 
# End of macro NEXTW
ab67			 
ab67			.INC: 
ab67				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab67 6f				db WORD_SYS_CORE+91             
ab68 bb ab			dw .DEC            
ab6a 03				db 2 + 1 
ab6b .. 00			db "+!",0              
ab6e				endm 
# End of macro CWHEAD
ab6e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab6e					if DEBUG_FORTH_WORDS_KEY 
ab6e						DMARK "+s_" 
ab6e f5				push af  
ab6f 3a 83 ab			ld a, (.dmark)  
ab72 32 6e ee			ld (debug_mark),a  
ab75 3a 84 ab			ld a, (.dmark+1)  
ab78 32 6f ee			ld (debug_mark+1),a  
ab7b 3a 85 ab			ld a, (.dmark+2)  
ab7e 32 70 ee			ld (debug_mark+2),a  
ab81 18 03			jr .pastdmark  
ab83 ..			.dmark: db "+s_"  
ab86 f1			.pastdmark: pop af  
ab87			endm  
# End of macro DMARK
ab87						CALLMONITOR 
ab87 cd 72 ee			call debug_vector  
ab8a				endm  
# End of macro CALLMONITOR
ab8a					endif 
ab8a			 
ab8a					FORTH_DSP_VALUEHL 
ab8a cd 40 9d			call macro_dsp_valuehl 
ab8d				endm 
# End of macro FORTH_DSP_VALUEHL
ab8d			 
ab8d e5					push hl   ; save address 
ab8e			 
ab8e					FORTH_DSP_POP 
ab8e cd f8 9d			call macro_forth_dsp_pop 
ab91				endm 
# End of macro FORTH_DSP_POP
ab91			 
ab91					FORTH_DSP_VALUEHL 
ab91 cd 40 9d			call macro_dsp_valuehl 
ab94				endm 
# End of macro FORTH_DSP_VALUEHL
ab94			 
ab94					FORTH_DSP_POP 
ab94 cd f8 9d			call macro_forth_dsp_pop 
ab97				endm 
# End of macro FORTH_DSP_POP
ab97			 
ab97					; hl contains value to add to byte at a 
ab97				 
ab97 eb					ex de, hl 
ab98			 
ab98 e1					pop hl 
ab99			 
ab99					if DEBUG_FORTH_WORDS 
ab99						DMARK "INC" 
ab99 f5				push af  
ab9a 3a ae ab			ld a, (.dmark)  
ab9d 32 6e ee			ld (debug_mark),a  
aba0 3a af ab			ld a, (.dmark+1)  
aba3 32 6f ee			ld (debug_mark+1),a  
aba6 3a b0 ab			ld a, (.dmark+2)  
aba9 32 70 ee			ld (debug_mark+2),a  
abac 18 03			jr .pastdmark  
abae ..			.dmark: db "INC"  
abb1 f1			.pastdmark: pop af  
abb2			endm  
# End of macro DMARK
abb2						CALLMONITOR 
abb2 cd 72 ee			call debug_vector  
abb5				endm  
# End of macro CALLMONITOR
abb5					endif 
abb5			 
abb5 7e					ld a,(hl) 
abb6 83					add e 
abb7 77					ld (hl),a 
abb8			 
abb8			 
abb8			 
abb8				       NEXTW 
abb8 c3 f6 9e			jp macro_next 
abbb				endm 
# End of macro NEXTW
abbb			 
abbb			.DEC: 
abbb				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abbb 6f				db WORD_SYS_CORE+91             
abbc 0c ac			dw .INC2            
abbe 03				db 2 + 1 
abbf .. 00			db "-!",0              
abc2				endm 
# End of macro CWHEAD
abc2			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abc2					if DEBUG_FORTH_WORDS_KEY 
abc2						DMARK "-s_" 
abc2 f5				push af  
abc3 3a d7 ab			ld a, (.dmark)  
abc6 32 6e ee			ld (debug_mark),a  
abc9 3a d8 ab			ld a, (.dmark+1)  
abcc 32 6f ee			ld (debug_mark+1),a  
abcf 3a d9 ab			ld a, (.dmark+2)  
abd2 32 70 ee			ld (debug_mark+2),a  
abd5 18 03			jr .pastdmark  
abd7 ..			.dmark: db "-s_"  
abda f1			.pastdmark: pop af  
abdb			endm  
# End of macro DMARK
abdb						CALLMONITOR 
abdb cd 72 ee			call debug_vector  
abde				endm  
# End of macro CALLMONITOR
abde					endif 
abde			 
abde					FORTH_DSP_VALUEHL 
abde cd 40 9d			call macro_dsp_valuehl 
abe1				endm 
# End of macro FORTH_DSP_VALUEHL
abe1			 
abe1 e5					push hl   ; save address 
abe2			 
abe2					FORTH_DSP_POP 
abe2 cd f8 9d			call macro_forth_dsp_pop 
abe5				endm 
# End of macro FORTH_DSP_POP
abe5			 
abe5					FORTH_DSP_VALUEHL 
abe5 cd 40 9d			call macro_dsp_valuehl 
abe8				endm 
# End of macro FORTH_DSP_VALUEHL
abe8			 
abe8					; hl contains value to add to byte at a 
abe8				 
abe8 eb					ex de, hl 
abe9			 
abe9 e1					pop hl 
abea			 
abea					if DEBUG_FORTH_WORDS 
abea						DMARK "DEC" 
abea f5				push af  
abeb 3a ff ab			ld a, (.dmark)  
abee 32 6e ee			ld (debug_mark),a  
abf1 3a 00 ac			ld a, (.dmark+1)  
abf4 32 6f ee			ld (debug_mark+1),a  
abf7 3a 01 ac			ld a, (.dmark+2)  
abfa 32 70 ee			ld (debug_mark+2),a  
abfd 18 03			jr .pastdmark  
abff ..			.dmark: db "DEC"  
ac02 f1			.pastdmark: pop af  
ac03			endm  
# End of macro DMARK
ac03						CALLMONITOR 
ac03 cd 72 ee			call debug_vector  
ac06				endm  
# End of macro CALLMONITOR
ac06					endif 
ac06			 
ac06 7e					ld a,(hl) 
ac07 93					sub e 
ac08 77					ld (hl),a 
ac09			 
ac09			 
ac09			 
ac09				       NEXTW 
ac09 c3 f6 9e			jp macro_next 
ac0c				endm 
# End of macro NEXTW
ac0c			 
ac0c			.INC2: 
ac0c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ac0c 6f				db WORD_SYS_CORE+91             
ac0d b6 ac			dw .DEC2            
ac0f 04				db 3 + 1 
ac10 .. 00			db "+2!",0              
ac14				endm 
# End of macro CWHEAD
ac14			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac14			 
ac14					if DEBUG_FORTH_WORDS_KEY 
ac14						DMARK "+2s" 
ac14 f5				push af  
ac15 3a 29 ac			ld a, (.dmark)  
ac18 32 6e ee			ld (debug_mark),a  
ac1b 3a 2a ac			ld a, (.dmark+1)  
ac1e 32 6f ee			ld (debug_mark+1),a  
ac21 3a 2b ac			ld a, (.dmark+2)  
ac24 32 70 ee			ld (debug_mark+2),a  
ac27 18 03			jr .pastdmark  
ac29 ..			.dmark: db "+2s"  
ac2c f1			.pastdmark: pop af  
ac2d			endm  
# End of macro DMARK
ac2d						CALLMONITOR 
ac2d cd 72 ee			call debug_vector  
ac30				endm  
# End of macro CALLMONITOR
ac30					endif 
ac30			 
ac30					; Address 
ac30			 
ac30					FORTH_DSP_VALUEHL 
ac30 cd 40 9d			call macro_dsp_valuehl 
ac33				endm 
# End of macro FORTH_DSP_VALUEHL
ac33			 
ac33 e5					push hl    ; save address 
ac34			 
ac34					; load content into de 
ac34			 
ac34 5e					ld e,(hl) 
ac35 23					inc hl 
ac36 56					ld d, (hl) 
ac37			 
ac37					if DEBUG_FORTH_WORDS 
ac37						DMARK "+2a" 
ac37 f5				push af  
ac38 3a 4c ac			ld a, (.dmark)  
ac3b 32 6e ee			ld (debug_mark),a  
ac3e 3a 4d ac			ld a, (.dmark+1)  
ac41 32 6f ee			ld (debug_mark+1),a  
ac44 3a 4e ac			ld a, (.dmark+2)  
ac47 32 70 ee			ld (debug_mark+2),a  
ac4a 18 03			jr .pastdmark  
ac4c ..			.dmark: db "+2a"  
ac4f f1			.pastdmark: pop af  
ac50			endm  
# End of macro DMARK
ac50						CALLMONITOR 
ac50 cd 72 ee			call debug_vector  
ac53				endm  
# End of macro CALLMONITOR
ac53					endif 
ac53			 
ac53					FORTH_DSP_POP 
ac53 cd f8 9d			call macro_forth_dsp_pop 
ac56				endm 
# End of macro FORTH_DSP_POP
ac56			 
ac56					; Get value to add 
ac56			 
ac56					FORTH_DSP_VALUE 
ac56 cd 29 9d			call macro_forth_dsp_value 
ac59				endm 
# End of macro FORTH_DSP_VALUE
ac59			 
ac59					if DEBUG_FORTH_WORDS 
ac59						DMARK "+2v" 
ac59 f5				push af  
ac5a 3a 6e ac			ld a, (.dmark)  
ac5d 32 6e ee			ld (debug_mark),a  
ac60 3a 6f ac			ld a, (.dmark+1)  
ac63 32 6f ee			ld (debug_mark+1),a  
ac66 3a 70 ac			ld a, (.dmark+2)  
ac69 32 70 ee			ld (debug_mark+2),a  
ac6c 18 03			jr .pastdmark  
ac6e ..			.dmark: db "+2v"  
ac71 f1			.pastdmark: pop af  
ac72			endm  
# End of macro DMARK
ac72						CALLMONITOR 
ac72 cd 72 ee			call debug_vector  
ac75				endm  
# End of macro CALLMONITOR
ac75					endif 
ac75			 
ac75 19					add hl, de 
ac76			 
ac76					if DEBUG_FORTH_WORDS 
ac76						DMARK "+2+" 
ac76 f5				push af  
ac77 3a 8b ac			ld a, (.dmark)  
ac7a 32 6e ee			ld (debug_mark),a  
ac7d 3a 8c ac			ld a, (.dmark+1)  
ac80 32 6f ee			ld (debug_mark+1),a  
ac83 3a 8d ac			ld a, (.dmark+2)  
ac86 32 70 ee			ld (debug_mark+2),a  
ac89 18 03			jr .pastdmark  
ac8b ..			.dmark: db "+2+"  
ac8e f1			.pastdmark: pop af  
ac8f			endm  
# End of macro DMARK
ac8f						CALLMONITOR 
ac8f cd 72 ee			call debug_vector  
ac92				endm  
# End of macro CALLMONITOR
ac92					endif 
ac92			 
ac92					; move result to de 
ac92			 
ac92 eb					ex de, hl 
ac93			 
ac93					; Address 
ac93			 
ac93 e1					pop hl 
ac94			 
ac94					; save it back 
ac94			 
ac94 73					ld (hl), e 
ac95 23					inc hl 
ac96 72					ld (hl), d 
ac97			 
ac97					if DEBUG_FORTH_WORDS 
ac97						DMARK "+2e" 
ac97 f5				push af  
ac98 3a ac ac			ld a, (.dmark)  
ac9b 32 6e ee			ld (debug_mark),a  
ac9e 3a ad ac			ld a, (.dmark+1)  
aca1 32 6f ee			ld (debug_mark+1),a  
aca4 3a ae ac			ld a, (.dmark+2)  
aca7 32 70 ee			ld (debug_mark+2),a  
acaa 18 03			jr .pastdmark  
acac ..			.dmark: db "+2e"  
acaf f1			.pastdmark: pop af  
acb0			endm  
# End of macro DMARK
acb0						CALLMONITOR 
acb0 cd 72 ee			call debug_vector  
acb3				endm  
# End of macro CALLMONITOR
acb3					endif 
acb3			 
acb3			 
acb3			 
acb3			 
acb3			 
acb3				       NEXTW 
acb3 c3 f6 9e			jp macro_next 
acb6				endm 
# End of macro NEXTW
acb6			 
acb6			.DEC2: 
acb6				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
acb6 6f				db WORD_SYS_CORE+91             
acb7 62 ad			dw .GET2            
acb9 04				db 3 + 1 
acba .. 00			db "-2!",0              
acbe				endm 
# End of macro CWHEAD
acbe			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acbe			 
acbe			 
acbe					if DEBUG_FORTH_WORDS_KEY 
acbe						DMARK "-2s" 
acbe f5				push af  
acbf 3a d3 ac			ld a, (.dmark)  
acc2 32 6e ee			ld (debug_mark),a  
acc5 3a d4 ac			ld a, (.dmark+1)  
acc8 32 6f ee			ld (debug_mark+1),a  
accb 3a d5 ac			ld a, (.dmark+2)  
acce 32 70 ee			ld (debug_mark+2),a  
acd1 18 03			jr .pastdmark  
acd3 ..			.dmark: db "-2s"  
acd6 f1			.pastdmark: pop af  
acd7			endm  
# End of macro DMARK
acd7						CALLMONITOR 
acd7 cd 72 ee			call debug_vector  
acda				endm  
# End of macro CALLMONITOR
acda					endif 
acda			 
acda					; Address 
acda			 
acda					FORTH_DSP_VALUEHL 
acda cd 40 9d			call macro_dsp_valuehl 
acdd				endm 
# End of macro FORTH_DSP_VALUEHL
acdd			 
acdd e5					push hl    ; save address 
acde			 
acde					; load content into de 
acde			 
acde 5e					ld e,(hl) 
acdf 23					inc hl 
ace0 56					ld d, (hl) 
ace1			 
ace1					if DEBUG_FORTH_WORDS 
ace1						DMARK "-2a" 
ace1 f5				push af  
ace2 3a f6 ac			ld a, (.dmark)  
ace5 32 6e ee			ld (debug_mark),a  
ace8 3a f7 ac			ld a, (.dmark+1)  
aceb 32 6f ee			ld (debug_mark+1),a  
acee 3a f8 ac			ld a, (.dmark+2)  
acf1 32 70 ee			ld (debug_mark+2),a  
acf4 18 03			jr .pastdmark  
acf6 ..			.dmark: db "-2a"  
acf9 f1			.pastdmark: pop af  
acfa			endm  
# End of macro DMARK
acfa						CALLMONITOR 
acfa cd 72 ee			call debug_vector  
acfd				endm  
# End of macro CALLMONITOR
acfd					endif 
acfd			 
acfd					FORTH_DSP_POP 
acfd cd f8 9d			call macro_forth_dsp_pop 
ad00				endm 
# End of macro FORTH_DSP_POP
ad00			 
ad00					; Get value to remove 
ad00			 
ad00					FORTH_DSP_VALUE 
ad00 cd 29 9d			call macro_forth_dsp_value 
ad03				endm 
# End of macro FORTH_DSP_VALUE
ad03			 
ad03					if DEBUG_FORTH_WORDS 
ad03						DMARK "-2v" 
ad03 f5				push af  
ad04 3a 18 ad			ld a, (.dmark)  
ad07 32 6e ee			ld (debug_mark),a  
ad0a 3a 19 ad			ld a, (.dmark+1)  
ad0d 32 6f ee			ld (debug_mark+1),a  
ad10 3a 1a ad			ld a, (.dmark+2)  
ad13 32 70 ee			ld (debug_mark+2),a  
ad16 18 03			jr .pastdmark  
ad18 ..			.dmark: db "-2v"  
ad1b f1			.pastdmark: pop af  
ad1c			endm  
# End of macro DMARK
ad1c						CALLMONITOR 
ad1c cd 72 ee			call debug_vector  
ad1f				endm  
# End of macro CALLMONITOR
ad1f					endif 
ad1f			 
ad1f eb					ex de, hl 
ad20 ed 52				sbc hl, de 
ad22			 
ad22					if DEBUG_FORTH_WORDS 
ad22						DMARK "-2d" 
ad22 f5				push af  
ad23 3a 37 ad			ld a, (.dmark)  
ad26 32 6e ee			ld (debug_mark),a  
ad29 3a 38 ad			ld a, (.dmark+1)  
ad2c 32 6f ee			ld (debug_mark+1),a  
ad2f 3a 39 ad			ld a, (.dmark+2)  
ad32 32 70 ee			ld (debug_mark+2),a  
ad35 18 03			jr .pastdmark  
ad37 ..			.dmark: db "-2d"  
ad3a f1			.pastdmark: pop af  
ad3b			endm  
# End of macro DMARK
ad3b						CALLMONITOR 
ad3b cd 72 ee			call debug_vector  
ad3e				endm  
# End of macro CALLMONITOR
ad3e					endif 
ad3e			 
ad3e					; move result to de 
ad3e			 
ad3e eb					ex de, hl 
ad3f			 
ad3f					; Address 
ad3f			 
ad3f e1					pop hl 
ad40			 
ad40					; save it back 
ad40			 
ad40 73					ld (hl), e 
ad41 23					inc hl 
ad42 72					ld (hl), d 
ad43			 
ad43					if DEBUG_FORTH_WORDS 
ad43						DMARK "-2e" 
ad43 f5				push af  
ad44 3a 58 ad			ld a, (.dmark)  
ad47 32 6e ee			ld (debug_mark),a  
ad4a 3a 59 ad			ld a, (.dmark+1)  
ad4d 32 6f ee			ld (debug_mark+1),a  
ad50 3a 5a ad			ld a, (.dmark+2)  
ad53 32 70 ee			ld (debug_mark+2),a  
ad56 18 03			jr .pastdmark  
ad58 ..			.dmark: db "-2e"  
ad5b f1			.pastdmark: pop af  
ad5c			endm  
# End of macro DMARK
ad5c						CALLMONITOR 
ad5c cd 72 ee			call debug_vector  
ad5f				endm  
# End of macro CALLMONITOR
ad5f					endif 
ad5f			 
ad5f			 
ad5f			 
ad5f			 
ad5f			 
ad5f				       NEXTW 
ad5f c3 f6 9e			jp macro_next 
ad62				endm 
# End of macro NEXTW
ad62			.GET2: 
ad62				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad62 6f				db WORD_SYS_CORE+91             
ad63 92 ad			dw .BANG2            
ad65 03				db 2 + 1 
ad66 .. 00			db "2@",0              
ad69				endm 
# End of macro CWHEAD
ad69			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad69					if DEBUG_FORTH_WORDS_KEY 
ad69						DMARK "2A_" 
ad69 f5				push af  
ad6a 3a 7e ad			ld a, (.dmark)  
ad6d 32 6e ee			ld (debug_mark),a  
ad70 3a 7f ad			ld a, (.dmark+1)  
ad73 32 6f ee			ld (debug_mark+1),a  
ad76 3a 80 ad			ld a, (.dmark+2)  
ad79 32 70 ee			ld (debug_mark+2),a  
ad7c 18 03			jr .pastdmark  
ad7e ..			.dmark: db "2A_"  
ad81 f1			.pastdmark: pop af  
ad82			endm  
# End of macro DMARK
ad82						CALLMONITOR 
ad82 cd 72 ee			call debug_vector  
ad85				endm  
# End of macro CALLMONITOR
ad85					endif 
ad85			 
ad85					FORTH_DSP_VALUEHL 
ad85 cd 40 9d			call macro_dsp_valuehl 
ad88				endm 
# End of macro FORTH_DSP_VALUEHL
ad88			 
ad88 5e					ld e, (hl) 
ad89 23					inc hl 
ad8a 56					ld d, (hl) 
ad8b			 
ad8b eb					ex de, hl 
ad8c			 
ad8c cd 49 9b				call forth_push_numhl 
ad8f			 
ad8f				       NEXTW 
ad8f c3 f6 9e			jp macro_next 
ad92				endm 
# End of macro NEXTW
ad92			.BANG2: 
ad92				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad92 6f				db WORD_SYS_CORE+91             
ad93 ca ad			dw .CONFIG            
ad95 03				db 2 + 1 
ad96 .. 00			db "2!",0              
ad99				endm 
# End of macro CWHEAD
ad99			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad99					if DEBUG_FORTH_WORDS_KEY 
ad99						DMARK "2S_" 
ad99 f5				push af  
ad9a 3a ae ad			ld a, (.dmark)  
ad9d 32 6e ee			ld (debug_mark),a  
ada0 3a af ad			ld a, (.dmark+1)  
ada3 32 6f ee			ld (debug_mark+1),a  
ada6 3a b0 ad			ld a, (.dmark+2)  
ada9 32 70 ee			ld (debug_mark+2),a  
adac 18 03			jr .pastdmark  
adae ..			.dmark: db "2S_"  
adb1 f1			.pastdmark: pop af  
adb2			endm  
# End of macro DMARK
adb2						CALLMONITOR 
adb2 cd 72 ee			call debug_vector  
adb5				endm  
# End of macro CALLMONITOR
adb5					endif 
adb5			 
adb5					FORTH_DSP_VALUEHL 
adb5 cd 40 9d			call macro_dsp_valuehl 
adb8				endm 
# End of macro FORTH_DSP_VALUEHL
adb8			 
adb8 e5					push hl   ; save address 
adb9			 
adb9			 
adb9					FORTH_DSP_POP 
adb9 cd f8 9d			call macro_forth_dsp_pop 
adbc				endm 
# End of macro FORTH_DSP_POP
adbc			 
adbc					 
adbc					FORTH_DSP_VALUEHL 
adbc cd 40 9d			call macro_dsp_valuehl 
adbf				endm 
# End of macro FORTH_DSP_VALUEHL
adbf			 
adbf					FORTH_DSP_POP 
adbf cd f8 9d			call macro_forth_dsp_pop 
adc2				endm 
# End of macro FORTH_DSP_POP
adc2			 
adc2 eb					ex de, hl    ; value now in de 
adc3			 
adc3 e1					pop hl 
adc4			 
adc4 73					ld (hl), e 
adc5			 
adc5 23					inc hl 
adc6			 
adc6 72					ld (hl), d 
adc7			 
adc7			 
adc7				       NEXTW 
adc7 c3 f6 9e			jp macro_next 
adca				endm 
# End of macro NEXTW
adca			.CONFIG: 
adca				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
adca 6f				db WORD_SYS_CORE+91             
adcb db ad			dw .ENDCORE            
adcd 07				db 6 + 1 
adce .. 00			db "CONFIG",0              
add5				endm 
# End of macro CWHEAD
add5			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
add5			 
add5 cd 3c 93				call config 
add8					NEXTW 
add8 c3 f6 9e			jp macro_next 
addb				endm 
# End of macro NEXTW
addb			.ENDCORE: 
addb			 
addb			; eof 
addb			 
addb			 
# End of file forth_words_core.asm
addb			include "forth_words_flow.asm" 
addb			 
addb			; | ## Program Flow Words 
addb			 
addb			.IF: 
addb				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
addb 1e				db WORD_SYS_CORE+10             
addc d0 ae			dw .THEN            
adde 03				db 2 + 1 
addf .. 00			db "IF",0              
ade2				endm 
# End of macro CWHEAD
ade2			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ade2			; 
ade2					if DEBUG_FORTH_WORDS_KEY 
ade2						DMARK "IF." 
ade2 f5				push af  
ade3 3a f7 ad			ld a, (.dmark)  
ade6 32 6e ee			ld (debug_mark),a  
ade9 3a f8 ad			ld a, (.dmark+1)  
adec 32 6f ee			ld (debug_mark+1),a  
adef 3a f9 ad			ld a, (.dmark+2)  
adf2 32 70 ee			ld (debug_mark+2),a  
adf5 18 03			jr .pastdmark  
adf7 ..			.dmark: db "IF."  
adfa f1			.pastdmark: pop af  
adfb			endm  
# End of macro DMARK
adfb						CALLMONITOR 
adfb cd 72 ee			call debug_vector  
adfe				endm  
# End of macro CALLMONITOR
adfe					endif 
adfe			; eval TOS 
adfe			 
adfe				FORTH_DSP_VALUEHL 
adfe cd 40 9d			call macro_dsp_valuehl 
ae01				endm 
# End of macro FORTH_DSP_VALUEHL
ae01			 
ae01			;	push hl 
ae01				FORTH_DSP_POP 
ae01 cd f8 9d			call macro_forth_dsp_pop 
ae04				endm 
# End of macro FORTH_DSP_POP
ae04			;	pop hl 
ae04			 
ae04					if DEBUG_FORTH_WORDS 
ae04						DMARK "IF1" 
ae04 f5				push af  
ae05 3a 19 ae			ld a, (.dmark)  
ae08 32 6e ee			ld (debug_mark),a  
ae0b 3a 1a ae			ld a, (.dmark+1)  
ae0e 32 6f ee			ld (debug_mark+1),a  
ae11 3a 1b ae			ld a, (.dmark+2)  
ae14 32 70 ee			ld (debug_mark+2),a  
ae17 18 03			jr .pastdmark  
ae19 ..			.dmark: db "IF1"  
ae1c f1			.pastdmark: pop af  
ae1d			endm  
# End of macro DMARK
ae1d						CALLMONITOR 
ae1d cd 72 ee			call debug_vector  
ae20				endm  
# End of macro CALLMONITOR
ae20					endif 
ae20 b7				or a        ; clear carry flag 
ae21 11 00 00			ld de, 0 
ae24 eb				ex de,hl 
ae25 ed 52			sbc hl, de 
ae27 c2 b1 ae			jp nz, .iftrue 
ae2a			 
ae2a					if DEBUG_FORTH_WORDS 
ae2a						DMARK "IF2" 
ae2a f5				push af  
ae2b 3a 3f ae			ld a, (.dmark)  
ae2e 32 6e ee			ld (debug_mark),a  
ae31 3a 40 ae			ld a, (.dmark+1)  
ae34 32 6f ee			ld (debug_mark+1),a  
ae37 3a 41 ae			ld a, (.dmark+2)  
ae3a 32 70 ee			ld (debug_mark+2),a  
ae3d 18 03			jr .pastdmark  
ae3f ..			.dmark: db "IF2"  
ae42 f1			.pastdmark: pop af  
ae43			endm  
# End of macro DMARK
ae43						CALLMONITOR 
ae43 cd 72 ee			call debug_vector  
ae46				endm  
# End of macro CALLMONITOR
ae46					endif 
ae46			 
ae46			; if not true then skip to THEN 
ae46			 
ae46				; TODO get tok_ptr 
ae46				; TODO consume toks until we get to THEN 
ae46			 
ae46 2a c5 e5			ld hl, (os_tok_ptr) 
ae49					if DEBUG_FORTH_WORDS 
ae49						DMARK "IF3" 
ae49 f5				push af  
ae4a 3a 5e ae			ld a, (.dmark)  
ae4d 32 6e ee			ld (debug_mark),a  
ae50 3a 5f ae			ld a, (.dmark+1)  
ae53 32 6f ee			ld (debug_mark+1),a  
ae56 3a 60 ae			ld a, (.dmark+2)  
ae59 32 70 ee			ld (debug_mark+2),a  
ae5c 18 03			jr .pastdmark  
ae5e ..			.dmark: db "IF3"  
ae61 f1			.pastdmark: pop af  
ae62			endm  
# End of macro DMARK
ae62						CALLMONITOR 
ae62 cd 72 ee			call debug_vector  
ae65				endm  
# End of macro CALLMONITOR
ae65						 
ae65					endif 
ae65 11 ac ae			ld de, .ifthen 
ae68					if DEBUG_FORTH_WORDS 
ae68						DMARK "IF4" 
ae68 f5				push af  
ae69 3a 7d ae			ld a, (.dmark)  
ae6c 32 6e ee			ld (debug_mark),a  
ae6f 3a 7e ae			ld a, (.dmark+1)  
ae72 32 6f ee			ld (debug_mark+1),a  
ae75 3a 7f ae			ld a, (.dmark+2)  
ae78 32 70 ee			ld (debug_mark+2),a  
ae7b 18 03			jr .pastdmark  
ae7d ..			.dmark: db "IF4"  
ae80 f1			.pastdmark: pop af  
ae81			endm  
# End of macro DMARK
ae81						CALLMONITOR 
ae81 cd 72 ee			call debug_vector  
ae84				endm  
# End of macro CALLMONITOR
ae84					endif 
ae84 cd 11 a0			call findnexttok  
ae87			 
ae87					if DEBUG_FORTH_WORDS 
ae87						DMARK "IF5" 
ae87 f5				push af  
ae88 3a 9c ae			ld a, (.dmark)  
ae8b 32 6e ee			ld (debug_mark),a  
ae8e 3a 9d ae			ld a, (.dmark+1)  
ae91 32 6f ee			ld (debug_mark+1),a  
ae94 3a 9e ae			ld a, (.dmark+2)  
ae97 32 70 ee			ld (debug_mark+2),a  
ae9a 18 03			jr .pastdmark  
ae9c ..			.dmark: db "IF5"  
ae9f f1			.pastdmark: pop af  
aea0			endm  
# End of macro DMARK
aea0						CALLMONITOR 
aea0 cd 72 ee			call debug_vector  
aea3				endm  
# End of macro CALLMONITOR
aea3					endif 
aea3				; TODO replace below with ; exec using tok_ptr 
aea3 22 c5 e5			ld (os_tok_ptr), hl 
aea6 c3 87 9f			jp exec1 
aea9				NEXTW 
aea9 c3 f6 9e			jp macro_next 
aeac				endm 
# End of macro NEXTW
aeac			 
aeac .. 00		.ifthen:  db "THEN",0 
aeb1			 
aeb1			.iftrue:		 
aeb1				; Exec next words normally 
aeb1			 
aeb1				; if true then exec following IF as normal 
aeb1					if DEBUG_FORTH_WORDS 
aeb1						DMARK "IFT" 
aeb1 f5				push af  
aeb2 3a c6 ae			ld a, (.dmark)  
aeb5 32 6e ee			ld (debug_mark),a  
aeb8 3a c7 ae			ld a, (.dmark+1)  
aebb 32 6f ee			ld (debug_mark+1),a  
aebe 3a c8 ae			ld a, (.dmark+2)  
aec1 32 70 ee			ld (debug_mark+2),a  
aec4 18 03			jr .pastdmark  
aec6 ..			.dmark: db "IFT"  
aec9 f1			.pastdmark: pop af  
aeca			endm  
# End of macro DMARK
aeca						CALLMONITOR 
aeca cd 72 ee			call debug_vector  
aecd				endm  
# End of macro CALLMONITOR
aecd					endif 
aecd			 
aecd					NEXTW 
aecd c3 f6 9e			jp macro_next 
aed0				endm 
# End of macro NEXTW
aed0			.THEN: 
aed0				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aed0 1f				db WORD_SYS_CORE+11             
aed1 f8 ae			dw .ELSE            
aed3 05				db 4 + 1 
aed4 .. 00			db "THEN",0              
aed9				endm 
# End of macro CWHEAD
aed9			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aed9					if DEBUG_FORTH_WORDS_KEY 
aed9						DMARK "THN" 
aed9 f5				push af  
aeda 3a ee ae			ld a, (.dmark)  
aedd 32 6e ee			ld (debug_mark),a  
aee0 3a ef ae			ld a, (.dmark+1)  
aee3 32 6f ee			ld (debug_mark+1),a  
aee6 3a f0 ae			ld a, (.dmark+2)  
aee9 32 70 ee			ld (debug_mark+2),a  
aeec 18 03			jr .pastdmark  
aeee ..			.dmark: db "THN"  
aef1 f1			.pastdmark: pop af  
aef2			endm  
# End of macro DMARK
aef2						CALLMONITOR 
aef2 cd 72 ee			call debug_vector  
aef5				endm  
# End of macro CALLMONITOR
aef5					endif 
aef5					NEXTW 
aef5 c3 f6 9e			jp macro_next 
aef8				endm 
# End of macro NEXTW
aef8			.ELSE: 
aef8				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aef8 20				db WORD_SYS_CORE+12             
aef9 20 af			dw .DO            
aefb 03				db 2 + 1 
aefc .. 00			db "ELSE",0              
af01				endm 
# End of macro CWHEAD
af01			; | ELSE ( -- ) Not supported - does nothing | TODO 
af01			 
af01					if DEBUG_FORTH_WORDS_KEY 
af01						DMARK "ELS" 
af01 f5				push af  
af02 3a 16 af			ld a, (.dmark)  
af05 32 6e ee			ld (debug_mark),a  
af08 3a 17 af			ld a, (.dmark+1)  
af0b 32 6f ee			ld (debug_mark+1),a  
af0e 3a 18 af			ld a, (.dmark+2)  
af11 32 70 ee			ld (debug_mark+2),a  
af14 18 03			jr .pastdmark  
af16 ..			.dmark: db "ELS"  
af19 f1			.pastdmark: pop af  
af1a			endm  
# End of macro DMARK
af1a						CALLMONITOR 
af1a cd 72 ee			call debug_vector  
af1d				endm  
# End of macro CALLMONITOR
af1d					endif 
af1d			 
af1d			 
af1d					NEXTW 
af1d c3 f6 9e			jp macro_next 
af20				endm 
# End of macro NEXTW
af20			.DO: 
af20				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af20 21				db WORD_SYS_CORE+13             
af21 47 b0			dw .LOOP            
af23 03				db 2 + 1 
af24 .. 00			db "DO",0              
af27				endm 
# End of macro CWHEAD
af27			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af27			 
af27					if DEBUG_FORTH_WORDS_KEY 
af27						DMARK "DO." 
af27 f5				push af  
af28 3a 3c af			ld a, (.dmark)  
af2b 32 6e ee			ld (debug_mark),a  
af2e 3a 3d af			ld a, (.dmark+1)  
af31 32 6f ee			ld (debug_mark+1),a  
af34 3a 3e af			ld a, (.dmark+2)  
af37 32 70 ee			ld (debug_mark+2),a  
af3a 18 03			jr .pastdmark  
af3c ..			.dmark: db "DO."  
af3f f1			.pastdmark: pop af  
af40			endm  
# End of macro DMARK
af40						CALLMONITOR 
af40 cd 72 ee			call debug_vector  
af43				endm  
# End of macro CALLMONITOR
af43					endif 
af43			;  push pc to rsp stack past the DO 
af43			 
af43 2a c5 e5				ld hl, (os_tok_ptr) 
af46 23					inc hl   ; D 
af47 23					inc hl  ; O 
af48 23					inc hl   ; null 
af49					if DEBUG_FORTH_WORDS 
af49						DMARK "DO2" 
af49 f5				push af  
af4a 3a 5e af			ld a, (.dmark)  
af4d 32 6e ee			ld (debug_mark),a  
af50 3a 5f af			ld a, (.dmark+1)  
af53 32 6f ee			ld (debug_mark+1),a  
af56 3a 60 af			ld a, (.dmark+2)  
af59 32 70 ee			ld (debug_mark+2),a  
af5c 18 03			jr .pastdmark  
af5e ..			.dmark: db "DO2"  
af61 f1			.pastdmark: pop af  
af62			endm  
# End of macro DMARK
af62						CALLMONITOR 
af62 cd 72 ee			call debug_vector  
af65				endm  
# End of macro CALLMONITOR
af65					endif 
af65					FORTH_RSP_NEXT 
af65 cd f0 9a			call macro_forth_rsp_next 
af68				endm 
# End of macro FORTH_RSP_NEXT
af68					if DEBUG_FORTH_WORDS 
af68						DMARK "DO3" 
af68 f5				push af  
af69 3a 7d af			ld a, (.dmark)  
af6c 32 6e ee			ld (debug_mark),a  
af6f 3a 7e af			ld a, (.dmark+1)  
af72 32 6f ee			ld (debug_mark+1),a  
af75 3a 7f af			ld a, (.dmark+2)  
af78 32 70 ee			ld (debug_mark+2),a  
af7b 18 03			jr .pastdmark  
af7d ..			.dmark: db "DO3"  
af80 f1			.pastdmark: pop af  
af81			endm  
# End of macro DMARK
af81						CALLMONITOR 
af81 cd 72 ee			call debug_vector  
af84				endm  
# End of macro CALLMONITOR
af84					endif 
af84			 
af84					;if DEBUG_FORTH_WORDS 
af84				;		push hl 
af84			;		endif  
af84			 
af84			; get counters from data stack 
af84			 
af84			 
af84					FORTH_DSP_VALUEHL 
af84 cd 40 9d			call macro_dsp_valuehl 
af87				endm 
# End of macro FORTH_DSP_VALUEHL
af87 e5					push hl		 ; hl now has starting counter which needs to be tos 
af88			 
af88					if DEBUG_FORTH_WORDS 
af88						DMARK "DO4" 
af88 f5				push af  
af89 3a 9d af			ld a, (.dmark)  
af8c 32 6e ee			ld (debug_mark),a  
af8f 3a 9e af			ld a, (.dmark+1)  
af92 32 6f ee			ld (debug_mark+1),a  
af95 3a 9f af			ld a, (.dmark+2)  
af98 32 70 ee			ld (debug_mark+2),a  
af9b 18 03			jr .pastdmark  
af9d ..			.dmark: db "DO4"  
afa0 f1			.pastdmark: pop af  
afa1			endm  
# End of macro DMARK
afa1						CALLMONITOR 
afa1 cd 72 ee			call debug_vector  
afa4				endm  
# End of macro CALLMONITOR
afa4					endif 
afa4					FORTH_DSP_POP 
afa4 cd f8 9d			call macro_forth_dsp_pop 
afa7				endm 
# End of macro FORTH_DSP_POP
afa7			 
afa7					if DEBUG_FORTH_WORDS 
afa7						DMARK "DO5" 
afa7 f5				push af  
afa8 3a bc af			ld a, (.dmark)  
afab 32 6e ee			ld (debug_mark),a  
afae 3a bd af			ld a, (.dmark+1)  
afb1 32 6f ee			ld (debug_mark+1),a  
afb4 3a be af			ld a, (.dmark+2)  
afb7 32 70 ee			ld (debug_mark+2),a  
afba 18 03			jr .pastdmark  
afbc ..			.dmark: db "DO5"  
afbf f1			.pastdmark: pop af  
afc0			endm  
# End of macro DMARK
afc0						CALLMONITOR 
afc0 cd 72 ee			call debug_vector  
afc3				endm  
# End of macro CALLMONITOR
afc3					endif 
afc3			 
afc3					FORTH_DSP_VALUEHL 
afc3 cd 40 9d			call macro_dsp_valuehl 
afc6				endm 
# End of macro FORTH_DSP_VALUEHL
afc6			;		push hl		 ; hl now has starting limit counter 
afc6			 
afc6					if DEBUG_FORTH_WORDS 
afc6						DMARK "DO6" 
afc6 f5				push af  
afc7 3a db af			ld a, (.dmark)  
afca 32 6e ee			ld (debug_mark),a  
afcd 3a dc af			ld a, (.dmark+1)  
afd0 32 6f ee			ld (debug_mark+1),a  
afd3 3a dd af			ld a, (.dmark+2)  
afd6 32 70 ee			ld (debug_mark+2),a  
afd9 18 03			jr .pastdmark  
afdb ..			.dmark: db "DO6"  
afde f1			.pastdmark: pop af  
afdf			endm  
# End of macro DMARK
afdf						CALLMONITOR 
afdf cd 72 ee			call debug_vector  
afe2				endm  
# End of macro CALLMONITOR
afe2					endif 
afe2					FORTH_DSP_POP 
afe2 cd f8 9d			call macro_forth_dsp_pop 
afe5				endm 
# End of macro FORTH_DSP_POP
afe5			 
afe5			; put counters on the loop stack 
afe5			 
afe5			;		pop hl			 ; limit counter 
afe5 d1					pop de			; start counter 
afe6			 
afe6					; push limit counter 
afe6			 
afe6					if DEBUG_FORTH_WORDS 
afe6						DMARK "DO7" 
afe6 f5				push af  
afe7 3a fb af			ld a, (.dmark)  
afea 32 6e ee			ld (debug_mark),a  
afed 3a fc af			ld a, (.dmark+1)  
aff0 32 6f ee			ld (debug_mark+1),a  
aff3 3a fd af			ld a, (.dmark+2)  
aff6 32 70 ee			ld (debug_mark+2),a  
aff9 18 03			jr .pastdmark  
affb ..			.dmark: db "DO7"  
affe f1			.pastdmark: pop af  
afff			endm  
# End of macro DMARK
afff						CALLMONITOR 
afff cd 72 ee			call debug_vector  
b002				endm  
# End of macro CALLMONITOR
b002					endif 
b002					FORTH_LOOP_NEXT 
b002 cd 71 9d			call macro_forth_loop_next 
b005				endm 
# End of macro FORTH_LOOP_NEXT
b005			 
b005					; push start counter 
b005			 
b005 eb					ex de, hl 
b006					if DEBUG_FORTH_WORDS 
b006						DMARK "DO7" 
b006 f5				push af  
b007 3a 1b b0			ld a, (.dmark)  
b00a 32 6e ee			ld (debug_mark),a  
b00d 3a 1c b0			ld a, (.dmark+1)  
b010 32 6f ee			ld (debug_mark+1),a  
b013 3a 1d b0			ld a, (.dmark+2)  
b016 32 70 ee			ld (debug_mark+2),a  
b019 18 03			jr .pastdmark  
b01b ..			.dmark: db "DO7"  
b01e f1			.pastdmark: pop af  
b01f			endm  
# End of macro DMARK
b01f						CALLMONITOR 
b01f cd 72 ee			call debug_vector  
b022				endm  
# End of macro CALLMONITOR
b022					endif 
b022					FORTH_LOOP_NEXT 
b022 cd 71 9d			call macro_forth_loop_next 
b025				endm 
# End of macro FORTH_LOOP_NEXT
b025			 
b025			 
b025					; init first round of I counter 
b025			 
b025 22 e9 e5				ld (os_current_i), hl 
b028			 
b028					if DEBUG_FORTH_WORDS 
b028						DMARK "DO8" 
b028 f5				push af  
b029 3a 3d b0			ld a, (.dmark)  
b02c 32 6e ee			ld (debug_mark),a  
b02f 3a 3e b0			ld a, (.dmark+1)  
b032 32 6f ee			ld (debug_mark+1),a  
b035 3a 3f b0			ld a, (.dmark+2)  
b038 32 70 ee			ld (debug_mark+2),a  
b03b 18 03			jr .pastdmark  
b03d ..			.dmark: db "DO8"  
b040 f1			.pastdmark: pop af  
b041			endm  
# End of macro DMARK
b041						CALLMONITOR 
b041 cd 72 ee			call debug_vector  
b044				endm  
# End of macro CALLMONITOR
b044					endif 
b044			 
b044					NEXTW 
b044 c3 f6 9e			jp macro_next 
b047				endm 
# End of macro NEXTW
b047			.LOOP: 
b047				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b047 22				db WORD_SYS_CORE+14             
b048 5f b1			dw .I            
b04a 05				db 4 + 1 
b04b .. 00			db "LOOP",0              
b050				endm 
# End of macro CWHEAD
b050			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b050			 
b050				; pop tos as current loop count to hl 
b050			 
b050				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b050			 
b050				FORTH_LOOP_TOS 
b050 cd a4 9d			call macro_forth_loop_tos 
b053				endm 
# End of macro FORTH_LOOP_TOS
b053 e5				push hl 
b054			 
b054					if DEBUG_FORTH_WORDS_KEY 
b054						DMARK "LOP" 
b054 f5				push af  
b055 3a 69 b0			ld a, (.dmark)  
b058 32 6e ee			ld (debug_mark),a  
b05b 3a 6a b0			ld a, (.dmark+1)  
b05e 32 6f ee			ld (debug_mark+1),a  
b061 3a 6b b0			ld a, (.dmark+2)  
b064 32 70 ee			ld (debug_mark+2),a  
b067 18 03			jr .pastdmark  
b069 ..			.dmark: db "LOP"  
b06c f1			.pastdmark: pop af  
b06d			endm  
# End of macro DMARK
b06d						CALLMONITOR 
b06d cd 72 ee			call debug_vector  
b070				endm  
# End of macro CALLMONITOR
b070					endif 
b070				; next item on the stack is the limit. get it 
b070			 
b070			 
b070				FORTH_LOOP_POP 
b070 cd ae 9d			call macro_forth_loop_pop 
b073				endm 
# End of macro FORTH_LOOP_POP
b073			 
b073				FORTH_LOOP_TOS 
b073 cd a4 9d			call macro_forth_loop_tos 
b076				endm 
# End of macro FORTH_LOOP_TOS
b076			 
b076 d1				pop de		 ; de = i, hl = limit 
b077			 
b077					if DEBUG_FORTH_WORDS 
b077						DMARK "LP1" 
b077 f5				push af  
b078 3a 8c b0			ld a, (.dmark)  
b07b 32 6e ee			ld (debug_mark),a  
b07e 3a 8d b0			ld a, (.dmark+1)  
b081 32 6f ee			ld (debug_mark+1),a  
b084 3a 8e b0			ld a, (.dmark+2)  
b087 32 70 ee			ld (debug_mark+2),a  
b08a 18 03			jr .pastdmark  
b08c ..			.dmark: db "LP1"  
b08f f1			.pastdmark: pop af  
b090			endm  
# End of macro DMARK
b090						CALLMONITOR 
b090 cd 72 ee			call debug_vector  
b093				endm  
# End of macro CALLMONITOR
b093					endif 
b093			 
b093				; go back to previous word 
b093			 
b093 d5				push de    ; save I for inc later 
b094			 
b094			 
b094				; get limit 
b094				;  is I at limit? 
b094			 
b094			 
b094					if DEBUG_FORTH_WORDS 
b094						DMARK "LP1" 
b094 f5				push af  
b095 3a a9 b0			ld a, (.dmark)  
b098 32 6e ee			ld (debug_mark),a  
b09b 3a aa b0			ld a, (.dmark+1)  
b09e 32 6f ee			ld (debug_mark+1),a  
b0a1 3a ab b0			ld a, (.dmark+2)  
b0a4 32 70 ee			ld (debug_mark+2),a  
b0a7 18 03			jr .pastdmark  
b0a9 ..			.dmark: db "LP1"  
b0ac f1			.pastdmark: pop af  
b0ad			endm  
# End of macro DMARK
b0ad						CALLMONITOR 
b0ad cd 72 ee			call debug_vector  
b0b0				endm  
# End of macro CALLMONITOR
b0b0					endif 
b0b0			 
b0b0 ed 52			sbc hl, de 
b0b2			 
b0b2			 
b0b2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b0b2			 
b0b2 20 26				jr nz, .loopnotdone 
b0b4			 
b0b4 e1				pop hl   ; get rid of saved I 
b0b5				FORTH_LOOP_POP     ; get rid of limit 
b0b5 cd ae 9d			call macro_forth_loop_pop 
b0b8				endm 
# End of macro FORTH_LOOP_POP
b0b8			 
b0b8				FORTH_RSP_POP     ; get rid of DO ptr 
b0b8 cd 11 9b			call macro_forth_rsp_pop 
b0bb				endm 
# End of macro FORTH_RSP_POP
b0bb			 
b0bb			if DEBUG_FORTH_WORDS 
b0bb						DMARK "LP>" 
b0bb f5				push af  
b0bc 3a d0 b0			ld a, (.dmark)  
b0bf 32 6e ee			ld (debug_mark),a  
b0c2 3a d1 b0			ld a, (.dmark+1)  
b0c5 32 6f ee			ld (debug_mark+1),a  
b0c8 3a d2 b0			ld a, (.dmark+2)  
b0cb 32 70 ee			ld (debug_mark+2),a  
b0ce 18 03			jr .pastdmark  
b0d0 ..			.dmark: db "LP>"  
b0d3 f1			.pastdmark: pop af  
b0d4			endm  
# End of macro DMARK
b0d4				CALLMONITOR 
b0d4 cd 72 ee			call debug_vector  
b0d7				endm  
# End of macro CALLMONITOR
b0d7			endif 
b0d7			 
b0d7					NEXTW 
b0d7 c3 f6 9e			jp macro_next 
b0da				endm 
# End of macro NEXTW
b0da				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0da			 
b0da			.loopnotdone: 
b0da			 
b0da e1				pop hl    ; get I 
b0db 23				inc hl 
b0dc			 
b0dc			   	; save new I 
b0dc			 
b0dc			 
b0dc					; set I counter 
b0dc			 
b0dc 22 e9 e5				ld (os_current_i), hl 
b0df			 
b0df					if DEBUG_FORTH_WORDS 
b0df						DMARK "LPN" 
b0df f5				push af  
b0e0 3a f4 b0			ld a, (.dmark)  
b0e3 32 6e ee			ld (debug_mark),a  
b0e6 3a f5 b0			ld a, (.dmark+1)  
b0e9 32 6f ee			ld (debug_mark+1),a  
b0ec 3a f6 b0			ld a, (.dmark+2)  
b0ef 32 70 ee			ld (debug_mark+2),a  
b0f2 18 03			jr .pastdmark  
b0f4 ..			.dmark: db "LPN"  
b0f7 f1			.pastdmark: pop af  
b0f8			endm  
# End of macro DMARK
b0f8					CALLMONITOR 
b0f8 cd 72 ee			call debug_vector  
b0fb				endm  
# End of macro CALLMONITOR
b0fb					endif 
b0fb					 
b0fb				FORTH_LOOP_NEXT 
b0fb cd 71 9d			call macro_forth_loop_next 
b0fe				endm 
# End of macro FORTH_LOOP_NEXT
b0fe			 
b0fe			 
b0fe					if DEBUG_FORTH_WORDS 
b0fe eb						ex de,hl 
b0ff					endif 
b0ff			 
b0ff			;	; get DO ptr 
b0ff			; 
b0ff					if DEBUG_FORTH_WORDS 
b0ff						DMARK "LP7" 
b0ff f5				push af  
b100 3a 14 b1			ld a, (.dmark)  
b103 32 6e ee			ld (debug_mark),a  
b106 3a 15 b1			ld a, (.dmark+1)  
b109 32 6f ee			ld (debug_mark+1),a  
b10c 3a 16 b1			ld a, (.dmark+2)  
b10f 32 70 ee			ld (debug_mark+2),a  
b112 18 03			jr .pastdmark  
b114 ..			.dmark: db "LP7"  
b117 f1			.pastdmark: pop af  
b118			endm  
# End of macro DMARK
b118					CALLMONITOR 
b118 cd 72 ee			call debug_vector  
b11b				endm  
# End of macro CALLMONITOR
b11b					endif 
b11b				FORTH_RSP_TOS 
b11b cd 07 9b			call macro_forth_rsp_tos 
b11e				endm 
# End of macro FORTH_RSP_TOS
b11e			 
b11e					if DEBUG_FORTH_WORDS 
b11e						DMARK "LP8" 
b11e f5				push af  
b11f 3a 33 b1			ld a, (.dmark)  
b122 32 6e ee			ld (debug_mark),a  
b125 3a 34 b1			ld a, (.dmark+1)  
b128 32 6f ee			ld (debug_mark+1),a  
b12b 3a 35 b1			ld a, (.dmark+2)  
b12e 32 70 ee			ld (debug_mark+2),a  
b131 18 03			jr .pastdmark  
b133 ..			.dmark: db "LP8"  
b136 f1			.pastdmark: pop af  
b137			endm  
# End of macro DMARK
b137					CALLMONITOR 
b137 cd 72 ee			call debug_vector  
b13a				endm  
# End of macro CALLMONITOR
b13a					endif 
b13a				;push hl 
b13a			 
b13a				; not going to DO any more 
b13a				; get rid of the RSP pointer as DO will add it back in 
b13a				;FORTH_RSP_POP 
b13a				;pop hl 
b13a			 
b13a				;ld hl,(cli_ret_sp) 
b13a				;ld e, (hl) 
b13a				;inc hl 
b13a				;ld d, (hl) 
b13a				;ex de,hl 
b13a 22 c5 e5			ld (os_tok_ptr), hl 
b13d					if DEBUG_FORTH_WORDS 
b13d						DMARK "LP<" 
b13d f5				push af  
b13e 3a 52 b1			ld a, (.dmark)  
b141 32 6e ee			ld (debug_mark),a  
b144 3a 53 b1			ld a, (.dmark+1)  
b147 32 6f ee			ld (debug_mark+1),a  
b14a 3a 54 b1			ld a, (.dmark+2)  
b14d 32 70 ee			ld (debug_mark+2),a  
b150 18 03			jr .pastdmark  
b152 ..			.dmark: db "LP<"  
b155 f1			.pastdmark: pop af  
b156			endm  
# End of macro DMARK
b156					CALLMONITOR 
b156 cd 72 ee			call debug_vector  
b159				endm  
# End of macro CALLMONITOR
b159				endif 
b159 c3 87 9f			jp exec1 
b15c			 
b15c					 
b15c			 
b15c			 
b15c					NEXTW 
b15c c3 f6 9e			jp macro_next 
b15f				endm 
# End of macro NEXTW
b15f			.I:  
b15f			 
b15f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b15f 5e				db WORD_SYS_CORE+74             
b160 8a b1			dw .DLOOP            
b162 02				db 1 + 1 
b163 .. 00			db "I",0              
b165				endm 
# End of macro CWHEAD
b165			; | I ( -- ) Current loop counter | DONE 
b165					if DEBUG_FORTH_WORDS_KEY 
b165						DMARK "I.." 
b165 f5				push af  
b166 3a 7a b1			ld a, (.dmark)  
b169 32 6e ee			ld (debug_mark),a  
b16c 3a 7b b1			ld a, (.dmark+1)  
b16f 32 6f ee			ld (debug_mark+1),a  
b172 3a 7c b1			ld a, (.dmark+2)  
b175 32 70 ee			ld (debug_mark+2),a  
b178 18 03			jr .pastdmark  
b17a ..			.dmark: db "I.."  
b17d f1			.pastdmark: pop af  
b17e			endm  
# End of macro DMARK
b17e						CALLMONITOR 
b17e cd 72 ee			call debug_vector  
b181				endm  
# End of macro CALLMONITOR
b181					endif 
b181			 
b181 2a e9 e5				ld hl,(os_current_i) 
b184 cd 49 9b				call forth_push_numhl 
b187			 
b187					NEXTW 
b187 c3 f6 9e			jp macro_next 
b18a				endm 
# End of macro NEXTW
b18a			.DLOOP: 
b18a				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b18a 5f				db WORD_SYS_CORE+75             
b18b 6b b2			dw .REPEAT            
b18d 06				db 5 + 1 
b18e .. 00			db "-LOOP",0              
b194				endm 
# End of macro CWHEAD
b194			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b194				; pop tos as current loop count to hl 
b194					if DEBUG_FORTH_WORDS_KEY 
b194						DMARK "-LP" 
b194 f5				push af  
b195 3a a9 b1			ld a, (.dmark)  
b198 32 6e ee			ld (debug_mark),a  
b19b 3a aa b1			ld a, (.dmark+1)  
b19e 32 6f ee			ld (debug_mark+1),a  
b1a1 3a ab b1			ld a, (.dmark+2)  
b1a4 32 70 ee			ld (debug_mark+2),a  
b1a7 18 03			jr .pastdmark  
b1a9 ..			.dmark: db "-LP"  
b1ac f1			.pastdmark: pop af  
b1ad			endm  
# End of macro DMARK
b1ad						CALLMONITOR 
b1ad cd 72 ee			call debug_vector  
b1b0				endm  
# End of macro CALLMONITOR
b1b0					endif 
b1b0			 
b1b0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b1b0			 
b1b0				FORTH_LOOP_TOS 
b1b0 cd a4 9d			call macro_forth_loop_tos 
b1b3				endm 
# End of macro FORTH_LOOP_TOS
b1b3 e5				push hl 
b1b4			 
b1b4					if DEBUG_FORTH_WORDS 
b1b4						DMARK "-LP" 
b1b4 f5				push af  
b1b5 3a c9 b1			ld a, (.dmark)  
b1b8 32 6e ee			ld (debug_mark),a  
b1bb 3a ca b1			ld a, (.dmark+1)  
b1be 32 6f ee			ld (debug_mark+1),a  
b1c1 3a cb b1			ld a, (.dmark+2)  
b1c4 32 70 ee			ld (debug_mark+2),a  
b1c7 18 03			jr .pastdmark  
b1c9 ..			.dmark: db "-LP"  
b1cc f1			.pastdmark: pop af  
b1cd			endm  
# End of macro DMARK
b1cd						CALLMONITOR 
b1cd cd 72 ee			call debug_vector  
b1d0				endm  
# End of macro CALLMONITOR
b1d0					endif 
b1d0				; next item on the stack is the limit. get it 
b1d0			 
b1d0			 
b1d0				FORTH_LOOP_POP 
b1d0 cd ae 9d			call macro_forth_loop_pop 
b1d3				endm 
# End of macro FORTH_LOOP_POP
b1d3			 
b1d3				FORTH_LOOP_TOS 
b1d3 cd a4 9d			call macro_forth_loop_tos 
b1d6				endm 
# End of macro FORTH_LOOP_TOS
b1d6			 
b1d6 d1				pop de		 ; de = i, hl = limit 
b1d7			 
b1d7					if DEBUG_FORTH_WORDS 
b1d7						DMARK "-L1" 
b1d7 f5				push af  
b1d8 3a ec b1			ld a, (.dmark)  
b1db 32 6e ee			ld (debug_mark),a  
b1de 3a ed b1			ld a, (.dmark+1)  
b1e1 32 6f ee			ld (debug_mark+1),a  
b1e4 3a ee b1			ld a, (.dmark+2)  
b1e7 32 70 ee			ld (debug_mark+2),a  
b1ea 18 03			jr .pastdmark  
b1ec ..			.dmark: db "-L1"  
b1ef f1			.pastdmark: pop af  
b1f0			endm  
# End of macro DMARK
b1f0						CALLMONITOR 
b1f0 cd 72 ee			call debug_vector  
b1f3				endm  
# End of macro CALLMONITOR
b1f3					endif 
b1f3			 
b1f3				; go back to previous word 
b1f3			 
b1f3 d5				push de    ; save I for inc later 
b1f4			 
b1f4			 
b1f4				; get limit 
b1f4				;  is I at limit? 
b1f4			 
b1f4			 
b1f4					if DEBUG_FORTH_WORDS 
b1f4						DMARK "-L1" 
b1f4 f5				push af  
b1f5 3a 09 b2			ld a, (.dmark)  
b1f8 32 6e ee			ld (debug_mark),a  
b1fb 3a 0a b2			ld a, (.dmark+1)  
b1fe 32 6f ee			ld (debug_mark+1),a  
b201 3a 0b b2			ld a, (.dmark+2)  
b204 32 70 ee			ld (debug_mark+2),a  
b207 18 03			jr .pastdmark  
b209 ..			.dmark: db "-L1"  
b20c f1			.pastdmark: pop af  
b20d			endm  
# End of macro DMARK
b20d						CALLMONITOR 
b20d cd 72 ee			call debug_vector  
b210				endm  
# End of macro CALLMONITOR
b210					endif 
b210			 
b210 ed 52			sbc hl, de 
b212			 
b212			 
b212				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b212			 
b212 20 26				jr nz, .mloopnotdone 
b214			 
b214 e1				pop hl   ; get rid of saved I 
b215				FORTH_LOOP_POP     ; get rid of limit 
b215 cd ae 9d			call macro_forth_loop_pop 
b218				endm 
# End of macro FORTH_LOOP_POP
b218			 
b218				FORTH_RSP_POP     ; get rid of DO ptr 
b218 cd 11 9b			call macro_forth_rsp_pop 
b21b				endm 
# End of macro FORTH_RSP_POP
b21b			 
b21b			if DEBUG_FORTH_WORDS 
b21b						DMARK "-L>" 
b21b f5				push af  
b21c 3a 30 b2			ld a, (.dmark)  
b21f 32 6e ee			ld (debug_mark),a  
b222 3a 31 b2			ld a, (.dmark+1)  
b225 32 6f ee			ld (debug_mark+1),a  
b228 3a 32 b2			ld a, (.dmark+2)  
b22b 32 70 ee			ld (debug_mark+2),a  
b22e 18 03			jr .pastdmark  
b230 ..			.dmark: db "-L>"  
b233 f1			.pastdmark: pop af  
b234			endm  
# End of macro DMARK
b234				CALLMONITOR 
b234 cd 72 ee			call debug_vector  
b237				endm  
# End of macro CALLMONITOR
b237			endif 
b237			 
b237					NEXTW 
b237 c3 f6 9e			jp macro_next 
b23a				endm 
# End of macro NEXTW
b23a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b23a			 
b23a			.mloopnotdone: 
b23a			 
b23a e1				pop hl    ; get I 
b23b 2b				dec hl 
b23c			 
b23c			   	; save new I 
b23c			 
b23c			 
b23c					; set I counter 
b23c			 
b23c 22 e9 e5				ld (os_current_i), hl 
b23f			 
b23f					 
b23f				FORTH_LOOP_NEXT 
b23f cd 71 9d			call macro_forth_loop_next 
b242				endm 
# End of macro FORTH_LOOP_NEXT
b242			 
b242			 
b242					if DEBUG_FORTH_WORDS 
b242 eb						ex de,hl 
b243					endif 
b243			 
b243			;	; get DO ptr 
b243			; 
b243				FORTH_RSP_TOS 
b243 cd 07 9b			call macro_forth_rsp_tos 
b246				endm 
# End of macro FORTH_RSP_TOS
b246			 
b246				;push hl 
b246			 
b246				; not going to DO any more 
b246				; get rid of the RSP pointer as DO will add it back in 
b246				;FORTH_RSP_POP 
b246				;pop hl 
b246			 
b246			 
b246 22 c5 e5			ld (os_tok_ptr), hl 
b249					if DEBUG_FORTH_WORDS 
b249						DMARK "-L<" 
b249 f5				push af  
b24a 3a 5e b2			ld a, (.dmark)  
b24d 32 6e ee			ld (debug_mark),a  
b250 3a 5f b2			ld a, (.dmark+1)  
b253 32 6f ee			ld (debug_mark+1),a  
b256 3a 60 b2			ld a, (.dmark+2)  
b259 32 70 ee			ld (debug_mark+2),a  
b25c 18 03			jr .pastdmark  
b25e ..			.dmark: db "-L<"  
b261 f1			.pastdmark: pop af  
b262			endm  
# End of macro DMARK
b262					CALLMONITOR 
b262 cd 72 ee			call debug_vector  
b265				endm  
# End of macro CALLMONITOR
b265				endif 
b265 c3 87 9f			jp exec1 
b268			 
b268					 
b268			 
b268			 
b268			 
b268				NEXTW 
b268 c3 f6 9e			jp macro_next 
b26b				endm 
# End of macro NEXTW
b26b			 
b26b			 
b26b			 
b26b			 
b26b			.REPEAT: 
b26b				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b26b 71				db WORD_SYS_CORE+93             
b26c be b2			dw .UNTIL            
b26e 06				db 5 + 1 
b26f .. 00			db "REPEAT",0              
b276				endm 
# End of macro CWHEAD
b276			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b276			;  push pc to rsp stack past the REPEAT 
b276					if DEBUG_FORTH_WORDS_KEY 
b276						DMARK "REP" 
b276 f5				push af  
b277 3a 8b b2			ld a, (.dmark)  
b27a 32 6e ee			ld (debug_mark),a  
b27d 3a 8c b2			ld a, (.dmark+1)  
b280 32 6f ee			ld (debug_mark+1),a  
b283 3a 8d b2			ld a, (.dmark+2)  
b286 32 70 ee			ld (debug_mark+2),a  
b289 18 03			jr .pastdmark  
b28b ..			.dmark: db "REP"  
b28e f1			.pastdmark: pop af  
b28f			endm  
# End of macro DMARK
b28f						CALLMONITOR 
b28f cd 72 ee			call debug_vector  
b292				endm  
# End of macro CALLMONITOR
b292					endif 
b292			 
b292 2a c5 e5				ld hl, (os_tok_ptr) 
b295 23					inc hl   ; R 
b296 23					inc hl  ; E 
b297 23					inc hl   ; P 
b298 23					inc hl   ; E 
b299 23					inc hl   ; A 
b29a 23					inc hl   ; T 
b29b 23					inc hl   ; zero 
b29c					FORTH_RSP_NEXT 
b29c cd f0 9a			call macro_forth_rsp_next 
b29f				endm 
# End of macro FORTH_RSP_NEXT
b29f			 
b29f			 
b29f					if DEBUG_FORTH_WORDS 
b29f						DMARK "REP" 
b29f f5				push af  
b2a0 3a b4 b2			ld a, (.dmark)  
b2a3 32 6e ee			ld (debug_mark),a  
b2a6 3a b5 b2			ld a, (.dmark+1)  
b2a9 32 6f ee			ld (debug_mark+1),a  
b2ac 3a b6 b2			ld a, (.dmark+2)  
b2af 32 70 ee			ld (debug_mark+2),a  
b2b2 18 03			jr .pastdmark  
b2b4 ..			.dmark: db "REP"  
b2b7 f1			.pastdmark: pop af  
b2b8			endm  
# End of macro DMARK
b2b8						;pop bc    ; TODO BUG ?????? what is this for???? 
b2b8						CALLMONITOR 
b2b8 cd 72 ee			call debug_vector  
b2bb				endm  
# End of macro CALLMONITOR
b2bb					endif 
b2bb			 
b2bb					NEXTW 
b2bb c3 f6 9e			jp macro_next 
b2be				endm 
# End of macro NEXTW
b2be			;	       NEXTW 
b2be			 
b2be			.UNTIL: 
b2be				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b2be 72				db WORD_SYS_CORE+94             
b2bf 55 b3			dw .ENDFLOW            
b2c1 06				db 5 + 1 
b2c2 .. 00			db "UNTIL",0              
b2c8				endm 
# End of macro CWHEAD
b2c8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b2c8			 
b2c8				; pop tos as check 
b2c8			 
b2c8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b2c8			 
b2c8				FORTH_DSP_VALUEHL 
b2c8 cd 40 9d			call macro_dsp_valuehl 
b2cb				endm 
# End of macro FORTH_DSP_VALUEHL
b2cb			 
b2cb					if DEBUG_FORTH_WORDS_KEY 
b2cb						DMARK "UNT" 
b2cb f5				push af  
b2cc 3a e0 b2			ld a, (.dmark)  
b2cf 32 6e ee			ld (debug_mark),a  
b2d2 3a e1 b2			ld a, (.dmark+1)  
b2d5 32 6f ee			ld (debug_mark+1),a  
b2d8 3a e2 b2			ld a, (.dmark+2)  
b2db 32 70 ee			ld (debug_mark+2),a  
b2de 18 03			jr .pastdmark  
b2e0 ..			.dmark: db "UNT"  
b2e3 f1			.pastdmark: pop af  
b2e4			endm  
# End of macro DMARK
b2e4						CALLMONITOR 
b2e4 cd 72 ee			call debug_vector  
b2e7				endm  
# End of macro CALLMONITOR
b2e7					endif 
b2e7			 
b2e7			;	push hl 
b2e7				FORTH_DSP_POP 
b2e7 cd f8 9d			call macro_forth_dsp_pop 
b2ea				endm 
# End of macro FORTH_DSP_POP
b2ea			 
b2ea			;	pop hl 
b2ea			 
b2ea				; test if true 
b2ea			 
b2ea cd 05 8d			call ishlzero 
b2ed			;	ld a,l 
b2ed			;	add h 
b2ed			; 
b2ed			;	cp 0 
b2ed			 
b2ed 20 3e			jr nz, .untilnotdone 
b2ef			 
b2ef					if DEBUG_FORTH_WORDS 
b2ef						DMARK "UNf" 
b2ef f5				push af  
b2f0 3a 04 b3			ld a, (.dmark)  
b2f3 32 6e ee			ld (debug_mark),a  
b2f6 3a 05 b3			ld a, (.dmark+1)  
b2f9 32 6f ee			ld (debug_mark+1),a  
b2fc 3a 06 b3			ld a, (.dmark+2)  
b2ff 32 70 ee			ld (debug_mark+2),a  
b302 18 03			jr .pastdmark  
b304 ..			.dmark: db "UNf"  
b307 f1			.pastdmark: pop af  
b308			endm  
# End of macro DMARK
b308						CALLMONITOR 
b308 cd 72 ee			call debug_vector  
b30b				endm  
# End of macro CALLMONITOR
b30b					endif 
b30b			 
b30b			 
b30b			 
b30b				FORTH_RSP_POP     ; get rid of DO ptr 
b30b cd 11 9b			call macro_forth_rsp_pop 
b30e				endm 
# End of macro FORTH_RSP_POP
b30e			 
b30e			if DEBUG_FORTH_WORDS 
b30e						DMARK "UN>" 
b30e f5				push af  
b30f 3a 23 b3			ld a, (.dmark)  
b312 32 6e ee			ld (debug_mark),a  
b315 3a 24 b3			ld a, (.dmark+1)  
b318 32 6f ee			ld (debug_mark+1),a  
b31b 3a 25 b3			ld a, (.dmark+2)  
b31e 32 70 ee			ld (debug_mark+2),a  
b321 18 03			jr .pastdmark  
b323 ..			.dmark: db "UN>"  
b326 f1			.pastdmark: pop af  
b327			endm  
# End of macro DMARK
b327				CALLMONITOR 
b327 cd 72 ee			call debug_vector  
b32a				endm  
# End of macro CALLMONITOR
b32a			endif 
b32a			 
b32a					NEXTW 
b32a c3 f6 9e			jp macro_next 
b32d				endm 
# End of macro NEXTW
b32d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b32d			 
b32d			.untilnotdone: 
b32d			 
b32d			 
b32d			;	; get DO ptr 
b32d			; 
b32d				FORTH_RSP_TOS 
b32d cd 07 9b			call macro_forth_rsp_tos 
b330				endm 
# End of macro FORTH_RSP_TOS
b330			 
b330				;push hl 
b330			 
b330				; not going to DO any more 
b330				; get rid of the RSP pointer as DO will add it back in 
b330				;FORTH_RSP_POP 
b330				;pop hl 
b330			 
b330			 
b330 22 c5 e5			ld (os_tok_ptr), hl 
b333					if DEBUG_FORTH_WORDS 
b333						DMARK "UN<" 
b333 f5				push af  
b334 3a 48 b3			ld a, (.dmark)  
b337 32 6e ee			ld (debug_mark),a  
b33a 3a 49 b3			ld a, (.dmark+1)  
b33d 32 6f ee			ld (debug_mark+1),a  
b340 3a 4a b3			ld a, (.dmark+2)  
b343 32 70 ee			ld (debug_mark+2),a  
b346 18 03			jr .pastdmark  
b348 ..			.dmark: db "UN<"  
b34b f1			.pastdmark: pop af  
b34c			endm  
# End of macro DMARK
b34c					CALLMONITOR 
b34c cd 72 ee			call debug_vector  
b34f				endm  
# End of macro CALLMONITOR
b34f				endif 
b34f c3 87 9f			jp exec1 
b352			 
b352					 
b352			 
b352			 
b352					NEXTW 
b352 c3 f6 9e			jp macro_next 
b355				endm 
# End of macro NEXTW
b355			 
b355			 
b355			.ENDFLOW: 
b355			 
b355			; eof 
b355			 
# End of file forth_words_flow.asm
b355			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b355			include "forth_words_logic.asm" 
b355			 
b355			; | ## Logic Words 
b355			 
b355			.NOT: 
b355				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b355 2d				db WORD_SYS_CORE+25             
b356 9d b3			dw .IS            
b358 04				db 3 + 1 
b359 .. 00			db "NOT",0              
b35d				endm 
# End of macro CWHEAD
b35d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b35d					if DEBUG_FORTH_WORDS_KEY 
b35d						DMARK "NOT" 
b35d f5				push af  
b35e 3a 72 b3			ld a, (.dmark)  
b361 32 6e ee			ld (debug_mark),a  
b364 3a 73 b3			ld a, (.dmark+1)  
b367 32 6f ee			ld (debug_mark+1),a  
b36a 3a 74 b3			ld a, (.dmark+2)  
b36d 32 70 ee			ld (debug_mark+2),a  
b370 18 03			jr .pastdmark  
b372 ..			.dmark: db "NOT"  
b375 f1			.pastdmark: pop af  
b376			endm  
# End of macro DMARK
b376						CALLMONITOR 
b376 cd 72 ee			call debug_vector  
b379				endm  
# End of macro CALLMONITOR
b379					endif 
b379					FORTH_DSP 
b379 cd 06 9d			call macro_forth_dsp 
b37c				endm 
# End of macro FORTH_DSP
b37c 7e					ld a,(hl)	; get type of value on TOS 
b37d fe 02				cp DS_TYPE_INUM  
b37f 28 03				jr z, .noti 
b381					NEXTW 
b381 c3 f6 9e			jp macro_next 
b384				endm 
# End of macro NEXTW
b384			.noti:          FORTH_DSP_VALUEHL 
b384 cd 40 9d			call macro_dsp_valuehl 
b387				endm 
# End of macro FORTH_DSP_VALUEHL
b387			;		push hl 
b387					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b387 cd f8 9d			call macro_forth_dsp_pop 
b38a				endm 
# End of macro FORTH_DSP_POP
b38a			;		pop hl 
b38a 3e 00				ld a,0 
b38c bd					cp l 
b38d 28 04				jr z, .not2t 
b38f 2e 00				ld l, 0 
b391 18 02				jr .notip 
b393			 
b393 2e ff		.not2t:		ld l, 255 
b395			 
b395 26 00		.notip:		ld h, 0	 
b397			 
b397 cd 49 9b				call forth_push_numhl 
b39a					NEXTW 
b39a c3 f6 9e			jp macro_next 
b39d				endm 
# End of macro NEXTW
b39d			 
b39d			.IS: 
b39d				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b39d 2d				db WORD_SYS_CORE+25             
b39e c3 b3			dw .LZERO            
b3a0 03				db 2 + 1 
b3a1 .. 00			db "IS",0              
b3a4				endm 
# End of macro CWHEAD
b3a4			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b3a4					if DEBUG_FORTH_WORDS_KEY 
b3a4						DMARK "IS." 
b3a4 f5				push af  
b3a5 3a b9 b3			ld a, (.dmark)  
b3a8 32 6e ee			ld (debug_mark),a  
b3ab 3a ba b3			ld a, (.dmark+1)  
b3ae 32 6f ee			ld (debug_mark+1),a  
b3b1 3a bb b3			ld a, (.dmark+2)  
b3b4 32 70 ee			ld (debug_mark+2),a  
b3b7 18 03			jr .pastdmark  
b3b9 ..			.dmark: db "IS."  
b3bc f1			.pastdmark: pop af  
b3bd			endm  
# End of macro DMARK
b3bd						CALLMONITOR 
b3bd cd 72 ee			call debug_vector  
b3c0				endm  
# End of macro CALLMONITOR
b3c0					endif 
b3c0					NEXTW 
b3c0 c3 f6 9e			jp macro_next 
b3c3				endm 
# End of macro NEXTW
b3c3			.LZERO: 
b3c3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b3c3 2d				db WORD_SYS_CORE+25             
b3c4 cd b3			dw .TZERO            
b3c6 03				db 2 + 1 
b3c7 .. 00			db "0<",0              
b3ca				endm 
# End of macro CWHEAD
b3ca			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b3ca					NEXTW 
b3ca c3 f6 9e			jp macro_next 
b3cd				endm 
# End of macro NEXTW
b3cd			.TZERO: 
b3cd				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b3cd 2e				db WORD_SYS_CORE+26             
b3ce 14 b4			dw .LESS            
b3d0 03				db 2 + 1 
b3d1 .. 00			db "0=",0              
b3d4				endm 
# End of macro CWHEAD
b3d4			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b3d4				; TODO add floating point number detection 
b3d4					;v5 FORTH_DSP_VALUE 
b3d4					if DEBUG_FORTH_WORDS_KEY 
b3d4						DMARK "0=." 
b3d4 f5				push af  
b3d5 3a e9 b3			ld a, (.dmark)  
b3d8 32 6e ee			ld (debug_mark),a  
b3db 3a ea b3			ld a, (.dmark+1)  
b3de 32 6f ee			ld (debug_mark+1),a  
b3e1 3a eb b3			ld a, (.dmark+2)  
b3e4 32 70 ee			ld (debug_mark+2),a  
b3e7 18 03			jr .pastdmark  
b3e9 ..			.dmark: db "0=."  
b3ec f1			.pastdmark: pop af  
b3ed			endm  
# End of macro DMARK
b3ed						CALLMONITOR 
b3ed cd 72 ee			call debug_vector  
b3f0				endm  
# End of macro CALLMONITOR
b3f0					endif 
b3f0					FORTH_DSP 
b3f0 cd 06 9d			call macro_forth_dsp 
b3f3				endm 
# End of macro FORTH_DSP
b3f3 7e					ld a,(hl)	; get type of value on TOS 
b3f4 fe 02				cp DS_TYPE_INUM  
b3f6 28 00				jr z, .tz_inum 
b3f8			 
b3f8				if FORTH_ENABLE_FLOATMATH 
b3f8					jr .tz_done 
b3f8			 
b3f8				endif 
b3f8					 
b3f8			 
b3f8			.tz_inum: 
b3f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f8 cd 40 9d			call macro_dsp_valuehl 
b3fb				endm 
# End of macro FORTH_DSP_VALUEHL
b3fb			 
b3fb			;		push hl 
b3fb			 
b3fb					; destroy value TOS 
b3fb			 
b3fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3fb cd f8 9d			call macro_forth_dsp_pop 
b3fe				endm 
# End of macro FORTH_DSP_POP
b3fe			 
b3fe			;		pop hl 
b3fe			 
b3fe 3e 00				ld a,0 
b400			 
b400 bd					cp l 
b401 20 08				jr nz, .tz_notzero 
b403			 
b403 bc					cp h 
b404			 
b404 20 05				jr nz, .tz_notzero 
b406			 
b406			 
b406 21 01 00				ld hl, FORTH_TRUE 
b409 18 03				jr .tz_done 
b40b			 
b40b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b40e			 
b40e					; push value back onto stack for another op etc 
b40e			 
b40e			.tz_done: 
b40e cd 49 9b				call forth_push_numhl 
b411			 
b411					NEXTW 
b411 c3 f6 9e			jp macro_next 
b414				endm 
# End of macro NEXTW
b414			.LESS: 
b414				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b414 2f				db WORD_SYS_CORE+27             
b415 7d b4			dw .GT            
b417 02				db 1 + 1 
b418 .. 00			db "<",0              
b41a				endm 
# End of macro CWHEAD
b41a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b41a				; TODO add floating point number detection 
b41a					if DEBUG_FORTH_WORDS_KEY 
b41a						DMARK "LES" 
b41a f5				push af  
b41b 3a 2f b4			ld a, (.dmark)  
b41e 32 6e ee			ld (debug_mark),a  
b421 3a 30 b4			ld a, (.dmark+1)  
b424 32 6f ee			ld (debug_mark+1),a  
b427 3a 31 b4			ld a, (.dmark+2)  
b42a 32 70 ee			ld (debug_mark+2),a  
b42d 18 03			jr .pastdmark  
b42f ..			.dmark: db "LES"  
b432 f1			.pastdmark: pop af  
b433			endm  
# End of macro DMARK
b433						CALLMONITOR 
b433 cd 72 ee			call debug_vector  
b436				endm  
# End of macro CALLMONITOR
b436					endif 
b436					FORTH_DSP 
b436 cd 06 9d			call macro_forth_dsp 
b439				endm 
# End of macro FORTH_DSP
b439					;v5 FORTH_DSP_VALUE 
b439 7e					ld a,(hl)	; get type of value on TOS 
b43a fe 02				cp DS_TYPE_INUM  
b43c 28 00				jr z, .less_inum 
b43e			 
b43e				if FORTH_ENABLE_FLOATMATH 
b43e					jr .less_done 
b43e			 
b43e				endif 
b43e					 
b43e			 
b43e			.less_inum: 
b43e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b43e cd 40 9d			call macro_dsp_valuehl 
b441				endm 
# End of macro FORTH_DSP_VALUEHL
b441			 
b441 e5					push hl  ; u2 
b442			 
b442					; destroy value TOS 
b442			 
b442					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b442 cd f8 9d			call macro_forth_dsp_pop 
b445				endm 
# End of macro FORTH_DSP_POP
b445			 
b445			 
b445					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b445 cd 40 9d			call macro_dsp_valuehl 
b448				endm 
# End of macro FORTH_DSP_VALUEHL
b448			 
b448 e5					push hl    ; u1 
b449			 
b449					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b449 cd f8 9d			call macro_forth_dsp_pop 
b44c				endm 
# End of macro FORTH_DSP_POP
b44c			 
b44c			 
b44c b7			 or a      ;clear carry flag 
b44d 01 00 00		 ld bc, FORTH_FALSE 
b450 e1			  pop hl    ; u1 
b451 d1			  pop de    ; u2 
b452 ed 52		  sbc hl,de 
b454 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b456			 
b456 01 01 00		 ld bc, FORTH_TRUE 
b459			.lscont:  
b459 c5					push bc 
b45a e1					pop hl 
b45b			 
b45b					if DEBUG_FORTH_WORDS 
b45b						DMARK "LT1" 
b45b f5				push af  
b45c 3a 70 b4			ld a, (.dmark)  
b45f 32 6e ee			ld (debug_mark),a  
b462 3a 71 b4			ld a, (.dmark+1)  
b465 32 6f ee			ld (debug_mark+1),a  
b468 3a 72 b4			ld a, (.dmark+2)  
b46b 32 70 ee			ld (debug_mark+2),a  
b46e 18 03			jr .pastdmark  
b470 ..			.dmark: db "LT1"  
b473 f1			.pastdmark: pop af  
b474			endm  
# End of macro DMARK
b474						CALLMONITOR 
b474 cd 72 ee			call debug_vector  
b477				endm  
# End of macro CALLMONITOR
b477					endif 
b477 cd 49 9b				call forth_push_numhl 
b47a			 
b47a					NEXTW 
b47a c3 f6 9e			jp macro_next 
b47d				endm 
# End of macro NEXTW
b47d			.GT: 
b47d				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b47d 30				db WORD_SYS_CORE+28             
b47e e6 b4			dw .EQUAL            
b480 02				db 1 + 1 
b481 .. 00			db ">",0              
b483				endm 
# End of macro CWHEAD
b483			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b483				; TODO add floating point number detection 
b483					if DEBUG_FORTH_WORDS_KEY 
b483						DMARK "GRT" 
b483 f5				push af  
b484 3a 98 b4			ld a, (.dmark)  
b487 32 6e ee			ld (debug_mark),a  
b48a 3a 99 b4			ld a, (.dmark+1)  
b48d 32 6f ee			ld (debug_mark+1),a  
b490 3a 9a b4			ld a, (.dmark+2)  
b493 32 70 ee			ld (debug_mark+2),a  
b496 18 03			jr .pastdmark  
b498 ..			.dmark: db "GRT"  
b49b f1			.pastdmark: pop af  
b49c			endm  
# End of macro DMARK
b49c						CALLMONITOR 
b49c cd 72 ee			call debug_vector  
b49f				endm  
# End of macro CALLMONITOR
b49f					endif 
b49f					FORTH_DSP 
b49f cd 06 9d			call macro_forth_dsp 
b4a2				endm 
# End of macro FORTH_DSP
b4a2					;FORTH_DSP_VALUE 
b4a2 7e					ld a,(hl)	; get type of value on TOS 
b4a3 fe 02				cp DS_TYPE_INUM  
b4a5 28 00				jr z, .gt_inum 
b4a7			 
b4a7				if FORTH_ENABLE_FLOATMATH 
b4a7					jr .gt_done 
b4a7			 
b4a7				endif 
b4a7					 
b4a7			 
b4a7			.gt_inum: 
b4a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4a7 cd 40 9d			call macro_dsp_valuehl 
b4aa				endm 
# End of macro FORTH_DSP_VALUEHL
b4aa			 
b4aa e5					push hl  ; u2 
b4ab			 
b4ab					; destroy value TOS 
b4ab			 
b4ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4ab cd f8 9d			call macro_forth_dsp_pop 
b4ae				endm 
# End of macro FORTH_DSP_POP
b4ae			 
b4ae			 
b4ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4ae cd 40 9d			call macro_dsp_valuehl 
b4b1				endm 
# End of macro FORTH_DSP_VALUEHL
b4b1			 
b4b1 e5					push hl    ; u1 
b4b2			 
b4b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4b2 cd f8 9d			call macro_forth_dsp_pop 
b4b5				endm 
# End of macro FORTH_DSP_POP
b4b5			 
b4b5			 
b4b5 b7			 or a      ;clear carry flag 
b4b6 01 00 00		 ld bc, FORTH_FALSE 
b4b9 e1			  pop hl    ; u1 
b4ba d1			  pop de    ; u2 
b4bb ed 52		  sbc hl,de 
b4bd 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b4bf			 
b4bf 01 01 00		 ld bc, FORTH_TRUE 
b4c2			.gtcont:  
b4c2 c5					push bc 
b4c3 e1					pop hl 
b4c4			 
b4c4					if DEBUG_FORTH_WORDS 
b4c4						DMARK "GT1" 
b4c4 f5				push af  
b4c5 3a d9 b4			ld a, (.dmark)  
b4c8 32 6e ee			ld (debug_mark),a  
b4cb 3a da b4			ld a, (.dmark+1)  
b4ce 32 6f ee			ld (debug_mark+1),a  
b4d1 3a db b4			ld a, (.dmark+2)  
b4d4 32 70 ee			ld (debug_mark+2),a  
b4d7 18 03			jr .pastdmark  
b4d9 ..			.dmark: db "GT1"  
b4dc f1			.pastdmark: pop af  
b4dd			endm  
# End of macro DMARK
b4dd						CALLMONITOR 
b4dd cd 72 ee			call debug_vector  
b4e0				endm  
# End of macro CALLMONITOR
b4e0					endif 
b4e0 cd 49 9b				call forth_push_numhl 
b4e3			 
b4e3					NEXTW 
b4e3 c3 f6 9e			jp macro_next 
b4e6				endm 
# End of macro NEXTW
b4e6			.EQUAL: 
b4e6				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4e6 31				db WORD_SYS_CORE+29             
b4e7 51 b5			dw .ENDLOGIC            
b4e9 02				db 1 + 1 
b4ea .. 00			db "=",0              
b4ec				endm 
# End of macro CWHEAD
b4ec			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4ec				; TODO add floating point number detection 
b4ec					if DEBUG_FORTH_WORDS_KEY 
b4ec						DMARK "EQ." 
b4ec f5				push af  
b4ed 3a 01 b5			ld a, (.dmark)  
b4f0 32 6e ee			ld (debug_mark),a  
b4f3 3a 02 b5			ld a, (.dmark+1)  
b4f6 32 6f ee			ld (debug_mark+1),a  
b4f9 3a 03 b5			ld a, (.dmark+2)  
b4fc 32 70 ee			ld (debug_mark+2),a  
b4ff 18 03			jr .pastdmark  
b501 ..			.dmark: db "EQ."  
b504 f1			.pastdmark: pop af  
b505			endm  
# End of macro DMARK
b505						CALLMONITOR 
b505 cd 72 ee			call debug_vector  
b508				endm  
# End of macro CALLMONITOR
b508					endif 
b508					FORTH_DSP 
b508 cd 06 9d			call macro_forth_dsp 
b50b				endm 
# End of macro FORTH_DSP
b50b					;v5 FORTH_DSP_VALUE 
b50b 7e					ld a,(hl)	; get type of value on TOS 
b50c fe 02				cp DS_TYPE_INUM  
b50e 28 00				jr z, .eq_inum 
b510			 
b510				if FORTH_ENABLE_FLOATMATH 
b510					jr .eq_done 
b510			 
b510				endif 
b510					 
b510			 
b510			.eq_inum: 
b510					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b510 cd 40 9d			call macro_dsp_valuehl 
b513				endm 
# End of macro FORTH_DSP_VALUEHL
b513			 
b513 e5					push hl 
b514			 
b514					; destroy value TOS 
b514			 
b514					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b514 cd f8 9d			call macro_forth_dsp_pop 
b517				endm 
# End of macro FORTH_DSP_POP
b517			 
b517			 
b517					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b517 cd 40 9d			call macro_dsp_valuehl 
b51a				endm 
# End of macro FORTH_DSP_VALUEHL
b51a			 
b51a					; one value on hl get other one back 
b51a			 
b51a e5					push hl 
b51b			 
b51b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b51b cd f8 9d			call macro_forth_dsp_pop 
b51e				endm 
# End of macro FORTH_DSP_POP
b51e			 
b51e 0e 00				ld c, FORTH_FALSE 
b520			 
b520 e1					pop hl 
b521 d1					pop de 
b522			 
b522 7b					ld a, e 
b523 bd					cp l 
b524			 
b524 20 06				jr nz, .eq_done 
b526			 
b526 7a					ld a, d 
b527 bc					cp h 
b528			 
b528 20 02				jr nz, .eq_done 
b52a			 
b52a 0e 01				ld c, FORTH_TRUE 
b52c					 
b52c			 
b52c			 
b52c			.eq_done: 
b52c			 
b52c					; TODO push value back onto stack for another op etc 
b52c			 
b52c 26 00				ld h, 0 
b52e 69					ld l, c 
b52f					if DEBUG_FORTH_WORDS 
b52f						DMARK "EQ1" 
b52f f5				push af  
b530 3a 44 b5			ld a, (.dmark)  
b533 32 6e ee			ld (debug_mark),a  
b536 3a 45 b5			ld a, (.dmark+1)  
b539 32 6f ee			ld (debug_mark+1),a  
b53c 3a 46 b5			ld a, (.dmark+2)  
b53f 32 70 ee			ld (debug_mark+2),a  
b542 18 03			jr .pastdmark  
b544 ..			.dmark: db "EQ1"  
b547 f1			.pastdmark: pop af  
b548			endm  
# End of macro DMARK
b548						CALLMONITOR 
b548 cd 72 ee			call debug_vector  
b54b				endm  
# End of macro CALLMONITOR
b54b					endif 
b54b cd 49 9b				call forth_push_numhl 
b54e			 
b54e					NEXTW 
b54e c3 f6 9e			jp macro_next 
b551				endm 
# End of macro NEXTW
b551			 
b551			 
b551			.ENDLOGIC: 
b551			; eof 
b551			 
b551			 
# End of file forth_words_logic.asm
b551			include "forth_words_maths.asm" 
b551			 
b551			; | ## Maths Words 
b551			 
b551			.PLUS:	 
b551				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b551 15				db WORD_SYS_CORE+1             
b552 af b5			dw .NEG            
b554 02				db 1 + 1 
b555 .. 00			db "+",0              
b557				endm 
# End of macro CWHEAD
b557			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b557					if DEBUG_FORTH_WORDS_KEY 
b557						DMARK "PLU" 
b557 f5				push af  
b558 3a 6c b5			ld a, (.dmark)  
b55b 32 6e ee			ld (debug_mark),a  
b55e 3a 6d b5			ld a, (.dmark+1)  
b561 32 6f ee			ld (debug_mark+1),a  
b564 3a 6e b5			ld a, (.dmark+2)  
b567 32 70 ee			ld (debug_mark+2),a  
b56a 18 03			jr .pastdmark  
b56c ..			.dmark: db "PLU"  
b56f f1			.pastdmark: pop af  
b570			endm  
# End of macro DMARK
b570						CALLMONITOR 
b570 cd 72 ee			call debug_vector  
b573				endm  
# End of macro CALLMONITOR
b573					endif 
b573					; add top two values and push back result 
b573			 
b573					;for v5 FORTH_DSP_VALUE 
b573					FORTH_DSP 
b573 cd 06 9d			call macro_forth_dsp 
b576				endm 
# End of macro FORTH_DSP
b576 7e					ld a,(hl)	; get type of value on TOS 
b577 fe 02				cp DS_TYPE_INUM  
b579 28 03				jr z, .dot_inum 
b57b			 
b57b					NEXTW 
b57b c3 f6 9e			jp macro_next 
b57e				endm 
# End of macro NEXTW
b57e			 
b57e			; float maths 
b57e			 
b57e				if FORTH_ENABLE_FLOATMATH 
b57e						inc hl      ; now at start of numeric as string 
b57e			 
b57e					if DEBUG_FORTH_MATHS 
b57e						DMARK "ADD" 
b57e				CALLMONITOR 
b57e					endif 
b57e			 
b57e					;ld ix, hl 
b57e					call CON 
b57e			 
b57e			 
b57e					push hl 
b57e					 
b57e					 
b57e			 
b57e						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b57e			 
b57e					; get next number 
b57e			 
b57e						FORTH_DSP_VALUE 
b57e			 
b57e						inc hl      ; now at start of numeric as string 
b57e			 
b57e					;ld ix, hl 
b57e					call CON 
b57e			 
b57e					push hl 
b57e			 
b57e			 
b57e						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b57e			 
b57e						; TODO do add 
b57e			 
b57e						call IADD 
b57e			 
b57e						; TODO get result back as ascii 
b57e			 
b57e						; TODO push result  
b57e			 
b57e			 
b57e			 
b57e						jr .dot_done 
b57e				endif 
b57e			 
b57e			.dot_inum: 
b57e			 
b57e			 
b57e					if DEBUG_FORTH_DOT 
b57e						DMARK "+IT" 
b57e f5				push af  
b57f 3a 93 b5			ld a, (.dmark)  
b582 32 6e ee			ld (debug_mark),a  
b585 3a 94 b5			ld a, (.dmark+1)  
b588 32 6f ee			ld (debug_mark+1),a  
b58b 3a 95 b5			ld a, (.dmark+2)  
b58e 32 70 ee			ld (debug_mark+2),a  
b591 18 03			jr .pastdmark  
b593 ..			.dmark: db "+IT"  
b596 f1			.pastdmark: pop af  
b597			endm  
# End of macro DMARK
b597				CALLMONITOR 
b597 cd 72 ee			call debug_vector  
b59a				endm  
# End of macro CALLMONITOR
b59a					endif 
b59a			 
b59a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b59a cd 40 9d			call macro_dsp_valuehl 
b59d				endm 
# End of macro FORTH_DSP_VALUEHL
b59d			 
b59d				; TODO add floating point number detection 
b59d			 
b59d e5					push hl 
b59e			 
b59e					; destroy value TOS 
b59e			 
b59e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b59e cd f8 9d			call macro_forth_dsp_pop 
b5a1				endm 
# End of macro FORTH_DSP_POP
b5a1			 
b5a1			 
b5a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a1 cd 40 9d			call macro_dsp_valuehl 
b5a4				endm 
# End of macro FORTH_DSP_VALUEHL
b5a4			 
b5a4					; one value on hl get other one back 
b5a4			 
b5a4 d1					pop de 
b5a5			 
b5a5					; do the add 
b5a5			 
b5a5 19					add hl,de 
b5a6			 
b5a6					; save it 
b5a6			 
b5a6			;		push hl	 
b5a6			 
b5a6					; 
b5a6			 
b5a6					; destroy value TOS 
b5a6			 
b5a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a6 cd f8 9d			call macro_forth_dsp_pop 
b5a9				endm 
# End of macro FORTH_DSP_POP
b5a9			 
b5a9					; TODO push value back onto stack for another op etc 
b5a9			 
b5a9			;		pop hl 
b5a9			 
b5a9			.dot_done: 
b5a9 cd 49 9b				call forth_push_numhl 
b5ac			 
b5ac					NEXTW 
b5ac c3 f6 9e			jp macro_next 
b5af				endm 
# End of macro NEXTW
b5af			.NEG: 
b5af			 
b5af				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b5af 17				db WORD_SYS_CORE+3             
b5b0 f2 b5			dw .DIV            
b5b2 02				db 1 + 1 
b5b3 .. 00			db "-",0              
b5b5				endm 
# End of macro CWHEAD
b5b5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b5b5					if DEBUG_FORTH_WORDS_KEY 
b5b5						DMARK "SUB" 
b5b5 f5				push af  
b5b6 3a ca b5			ld a, (.dmark)  
b5b9 32 6e ee			ld (debug_mark),a  
b5bc 3a cb b5			ld a, (.dmark+1)  
b5bf 32 6f ee			ld (debug_mark+1),a  
b5c2 3a cc b5			ld a, (.dmark+2)  
b5c5 32 70 ee			ld (debug_mark+2),a  
b5c8 18 03			jr .pastdmark  
b5ca ..			.dmark: db "SUB"  
b5cd f1			.pastdmark: pop af  
b5ce			endm  
# End of macro DMARK
b5ce						CALLMONITOR 
b5ce cd 72 ee			call debug_vector  
b5d1				endm  
# End of macro CALLMONITOR
b5d1					endif 
b5d1			 
b5d1			 
b5d1				; TODO add floating point number detection 
b5d1					; v5 FORTH_DSP_VALUE 
b5d1					FORTH_DSP 
b5d1 cd 06 9d			call macro_forth_dsp 
b5d4				endm 
# End of macro FORTH_DSP
b5d4 7e					ld a,(hl)	; get type of value on TOS 
b5d5 fe 02				cp DS_TYPE_INUM  
b5d7 28 03				jr z, .neg_inum 
b5d9			 
b5d9					NEXTW 
b5d9 c3 f6 9e			jp macro_next 
b5dc				endm 
# End of macro NEXTW
b5dc			 
b5dc			; float maths 
b5dc			 
b5dc				if FORTH_ENABLE_FLOATMATH 
b5dc					jr .neg_done 
b5dc			 
b5dc				endif 
b5dc					 
b5dc			 
b5dc			.neg_inum: 
b5dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5dc cd 40 9d			call macro_dsp_valuehl 
b5df				endm 
# End of macro FORTH_DSP_VALUEHL
b5df			 
b5df e5					push hl 
b5e0			 
b5e0					; destroy value TOS 
b5e0			 
b5e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e0 cd f8 9d			call macro_forth_dsp_pop 
b5e3				endm 
# End of macro FORTH_DSP_POP
b5e3			 
b5e3			 
b5e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e3 cd 40 9d			call macro_dsp_valuehl 
b5e6				endm 
# End of macro FORTH_DSP_VALUEHL
b5e6			 
b5e6					; one value on hl get other one back 
b5e6			 
b5e6 d1					pop de 
b5e7			 
b5e7					; do the sub 
b5e7			;		ex de, hl 
b5e7			 
b5e7 ed 52				sbc hl,de 
b5e9			 
b5e9					; save it 
b5e9			 
b5e9			;		push hl	 
b5e9			 
b5e9					; 
b5e9			 
b5e9					; destroy value TOS 
b5e9			 
b5e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e9 cd f8 9d			call macro_forth_dsp_pop 
b5ec				endm 
# End of macro FORTH_DSP_POP
b5ec			 
b5ec					; TODO push value back onto stack for another op etc 
b5ec			 
b5ec			;		pop hl 
b5ec			 
b5ec cd 49 9b				call forth_push_numhl 
b5ef			.neg_done: 
b5ef			 
b5ef					NEXTW 
b5ef c3 f6 9e			jp macro_next 
b5f2				endm 
# End of macro NEXTW
b5f2			.DIV: 
b5f2				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5f2 18				db WORD_SYS_CORE+4             
b5f3 3f b6			dw .MUL            
b5f5 02				db 1 + 1 
b5f6 .. 00			db "/",0              
b5f8				endm 
# End of macro CWHEAD
b5f8			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5f8					if DEBUG_FORTH_WORDS_KEY 
b5f8						DMARK "DIV" 
b5f8 f5				push af  
b5f9 3a 0d b6			ld a, (.dmark)  
b5fc 32 6e ee			ld (debug_mark),a  
b5ff 3a 0e b6			ld a, (.dmark+1)  
b602 32 6f ee			ld (debug_mark+1),a  
b605 3a 0f b6			ld a, (.dmark+2)  
b608 32 70 ee			ld (debug_mark+2),a  
b60b 18 03			jr .pastdmark  
b60d ..			.dmark: db "DIV"  
b610 f1			.pastdmark: pop af  
b611			endm  
# End of macro DMARK
b611						CALLMONITOR 
b611 cd 72 ee			call debug_vector  
b614				endm  
# End of macro CALLMONITOR
b614					endif 
b614				; TODO add floating point number detection 
b614					; v5 FORTH_DSP_VALUE 
b614					FORTH_DSP 
b614 cd 06 9d			call macro_forth_dsp 
b617				endm 
# End of macro FORTH_DSP
b617 7e					ld a,(hl)	; get type of value on TOS 
b618 fe 02				cp DS_TYPE_INUM  
b61a 28 03				jr z, .div_inum 
b61c			 
b61c				if FORTH_ENABLE_FLOATMATH 
b61c					jr .div_done 
b61c			 
b61c				endif 
b61c					NEXTW 
b61c c3 f6 9e			jp macro_next 
b61f				endm 
# End of macro NEXTW
b61f			.div_inum: 
b61f			 
b61f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b61f cd 40 9d			call macro_dsp_valuehl 
b622				endm 
# End of macro FORTH_DSP_VALUEHL
b622			 
b622 e5					push hl    ; to go to bc 
b623			 
b623					; destroy value TOS 
b623			 
b623					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b623 cd f8 9d			call macro_forth_dsp_pop 
b626				endm 
# End of macro FORTH_DSP_POP
b626			 
b626			 
b626					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b626 cd 40 9d			call macro_dsp_valuehl 
b629				endm 
# End of macro FORTH_DSP_VALUEHL
b629			 
b629					; hl to go to de 
b629			 
b629 e5					push hl 
b62a			 
b62a c1					pop bc 
b62b d1					pop de		 
b62c			 
b62c			 
b62c					if DEBUG_FORTH_MATHS 
b62c						DMARK "DIV" 
b62c				CALLMONITOR 
b62c					endif 
b62c					; one value on hl but move to a get other one back 
b62c			 
b62c			        
b62c cd 39 8c			call Div16 
b62f			 
b62f			;	push af	 
b62f e5				push hl 
b630 c5				push bc 
b631			 
b631					if DEBUG_FORTH_MATHS 
b631						DMARK "DI1" 
b631				CALLMONITOR 
b631					endif 
b631			 
b631					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b631 cd f8 9d			call macro_forth_dsp_pop 
b634				endm 
# End of macro FORTH_DSP_POP
b634			 
b634			 
b634			 
b634 e1					pop hl    ; result 
b635			 
b635 cd 49 9b				call forth_push_numhl 
b638			 
b638 e1					pop hl    ; reminder 
b639			;		ld h,0 
b639			;		ld l,d 
b639			 
b639 cd 49 9b				call forth_push_numhl 
b63c			.div_done: 
b63c					NEXTW 
b63c c3 f6 9e			jp macro_next 
b63f				endm 
# End of macro NEXTW
b63f			.MUL: 
b63f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b63f 19				db WORD_SYS_CORE+5             
b640 84 b6			dw .MIN            
b642 02				db 1 + 1 
b643 .. 00			db "*",0              
b645				endm 
# End of macro CWHEAD
b645			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b645				; TODO add floating point number detection 
b645					if DEBUG_FORTH_WORDS_KEY 
b645						DMARK "MUL" 
b645 f5				push af  
b646 3a 5a b6			ld a, (.dmark)  
b649 32 6e ee			ld (debug_mark),a  
b64c 3a 5b b6			ld a, (.dmark+1)  
b64f 32 6f ee			ld (debug_mark+1),a  
b652 3a 5c b6			ld a, (.dmark+2)  
b655 32 70 ee			ld (debug_mark+2),a  
b658 18 03			jr .pastdmark  
b65a ..			.dmark: db "MUL"  
b65d f1			.pastdmark: pop af  
b65e			endm  
# End of macro DMARK
b65e						CALLMONITOR 
b65e cd 72 ee			call debug_vector  
b661				endm  
# End of macro CALLMONITOR
b661					endif 
b661					FORTH_DSP 
b661 cd 06 9d			call macro_forth_dsp 
b664				endm 
# End of macro FORTH_DSP
b664					; v5 FORTH_DSP_VALUE 
b664 7e					ld a,(hl)	; get type of value on TOS 
b665 fe 02				cp DS_TYPE_INUM  
b667 28 03				jr z, .mul_inum 
b669			 
b669				if FORTH_ENABLE_FLOATMATH 
b669					jr .mul_done 
b669			 
b669				endif 
b669			 
b669					NEXTW 
b669 c3 f6 9e			jp macro_next 
b66c				endm 
# End of macro NEXTW
b66c			.mul_inum:	 
b66c			 
b66c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b66c cd 40 9d			call macro_dsp_valuehl 
b66f				endm 
# End of macro FORTH_DSP_VALUEHL
b66f			 
b66f e5					push hl 
b670			 
b670					; destroy value TOS 
b670			 
b670					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b670 cd f8 9d			call macro_forth_dsp_pop 
b673				endm 
# End of macro FORTH_DSP_POP
b673			 
b673			 
b673					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b673 cd 40 9d			call macro_dsp_valuehl 
b676				endm 
# End of macro FORTH_DSP_VALUEHL
b676			 
b676					; one value on hl but move to a get other one back 
b676			 
b676 7d					ld a, l 
b677			 
b677 d1					pop de 
b678			 
b678					; do the mull 
b678			;		ex de, hl 
b678			 
b678 cd 5f 8c				call Mult16 
b67b					; save it 
b67b			 
b67b			;		push hl	 
b67b			 
b67b					; 
b67b			 
b67b					; destroy value TOS 
b67b			 
b67b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b67b cd f8 9d			call macro_forth_dsp_pop 
b67e				endm 
# End of macro FORTH_DSP_POP
b67e			 
b67e					; TODO push value back onto stack for another op etc 
b67e			 
b67e			;		pop hl 
b67e			 
b67e cd 49 9b				call forth_push_numhl 
b681			 
b681			.mul_done: 
b681					NEXTW 
b681 c3 f6 9e			jp macro_next 
b684				endm 
# End of macro NEXTW
b684			 
b684			 
b684			 
b684			 
b684			.MIN: 
b684				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b684 49				db WORD_SYS_CORE+53             
b685 05 b7			dw .MAX            
b687 04				db 3 + 1 
b688 .. 00			db "MIN",0              
b68c				endm 
# End of macro CWHEAD
b68c			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b68c					if DEBUG_FORTH_WORDS_KEY 
b68c						DMARK "MIN" 
b68c f5				push af  
b68d 3a a1 b6			ld a, (.dmark)  
b690 32 6e ee			ld (debug_mark),a  
b693 3a a2 b6			ld a, (.dmark+1)  
b696 32 6f ee			ld (debug_mark+1),a  
b699 3a a3 b6			ld a, (.dmark+2)  
b69c 32 70 ee			ld (debug_mark+2),a  
b69f 18 03			jr .pastdmark  
b6a1 ..			.dmark: db "MIN"  
b6a4 f1			.pastdmark: pop af  
b6a5			endm  
# End of macro DMARK
b6a5						CALLMONITOR 
b6a5 cd 72 ee			call debug_vector  
b6a8				endm  
# End of macro CALLMONITOR
b6a8					endif 
b6a8					; get u2 
b6a8			 
b6a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6a8 cd 40 9d			call macro_dsp_valuehl 
b6ab				endm 
# End of macro FORTH_DSP_VALUEHL
b6ab			 
b6ab e5					push hl   ; u2 
b6ac			 
b6ac					; destroy value TOS 
b6ac			 
b6ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ac cd f8 9d			call macro_forth_dsp_pop 
b6af				endm 
# End of macro FORTH_DSP_POP
b6af			 
b6af					; get u1 
b6af			 
b6af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6af cd 40 9d			call macro_dsp_valuehl 
b6b2				endm 
# End of macro FORTH_DSP_VALUEHL
b6b2			 
b6b2 e5					push hl  ; u1 
b6b3			 
b6b3					; destroy value TOS 
b6b3			 
b6b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b3 cd f8 9d			call macro_forth_dsp_pop 
b6b6				endm 
# End of macro FORTH_DSP_POP
b6b6			 
b6b6 b7			 or a      ;clear carry flag 
b6b7 e1			  pop hl    ; u1 
b6b8 d1			  pop de    ; u2 
b6b9 e5				push hl   ; saved in case hl is lowest 
b6ba ed 52		  sbc hl,de 
b6bc 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b6be			 
b6be e1				pop hl 
b6bf					if DEBUG_FORTH_WORDS 
b6bf						DMARK "MIN" 
b6bf f5				push af  
b6c0 3a d4 b6			ld a, (.dmark)  
b6c3 32 6e ee			ld (debug_mark),a  
b6c6 3a d5 b6			ld a, (.dmark+1)  
b6c9 32 6f ee			ld (debug_mark+1),a  
b6cc 3a d6 b6			ld a, (.dmark+2)  
b6cf 32 70 ee			ld (debug_mark+2),a  
b6d2 18 03			jr .pastdmark  
b6d4 ..			.dmark: db "MIN"  
b6d7 f1			.pastdmark: pop af  
b6d8			endm  
# End of macro DMARK
b6d8						CALLMONITOR 
b6d8 cd 72 ee			call debug_vector  
b6db				endm  
# End of macro CALLMONITOR
b6db					endif 
b6db cd 49 9b				call forth_push_numhl 
b6de			 
b6de				       NEXTW 
b6de c3 f6 9e			jp macro_next 
b6e1				endm 
# End of macro NEXTW
b6e1			 
b6e1			.mincont:  
b6e1 c1				pop bc   ; tidy up 
b6e2 eb				ex de , hl  
b6e3					if DEBUG_FORTH_WORDS 
b6e3						DMARK "MI1" 
b6e3 f5				push af  
b6e4 3a f8 b6			ld a, (.dmark)  
b6e7 32 6e ee			ld (debug_mark),a  
b6ea 3a f9 b6			ld a, (.dmark+1)  
b6ed 32 6f ee			ld (debug_mark+1),a  
b6f0 3a fa b6			ld a, (.dmark+2)  
b6f3 32 70 ee			ld (debug_mark+2),a  
b6f6 18 03			jr .pastdmark  
b6f8 ..			.dmark: db "MI1"  
b6fb f1			.pastdmark: pop af  
b6fc			endm  
# End of macro DMARK
b6fc						CALLMONITOR 
b6fc cd 72 ee			call debug_vector  
b6ff				endm  
# End of macro CALLMONITOR
b6ff					endif 
b6ff cd 49 9b				call forth_push_numhl 
b702			 
b702				       NEXTW 
b702 c3 f6 9e			jp macro_next 
b705				endm 
# End of macro NEXTW
b705			.MAX: 
b705				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b705 4a				db WORD_SYS_CORE+54             
b706 86 b7			dw .RND16            
b708 04				db 3 + 1 
b709 .. 00			db "MAX",0              
b70d				endm 
# End of macro CWHEAD
b70d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b70d					if DEBUG_FORTH_WORDS_KEY 
b70d						DMARK "MAX" 
b70d f5				push af  
b70e 3a 22 b7			ld a, (.dmark)  
b711 32 6e ee			ld (debug_mark),a  
b714 3a 23 b7			ld a, (.dmark+1)  
b717 32 6f ee			ld (debug_mark+1),a  
b71a 3a 24 b7			ld a, (.dmark+2)  
b71d 32 70 ee			ld (debug_mark+2),a  
b720 18 03			jr .pastdmark  
b722 ..			.dmark: db "MAX"  
b725 f1			.pastdmark: pop af  
b726			endm  
# End of macro DMARK
b726						CALLMONITOR 
b726 cd 72 ee			call debug_vector  
b729				endm  
# End of macro CALLMONITOR
b729					endif 
b729					; get u2 
b729			 
b729					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b729 cd 40 9d			call macro_dsp_valuehl 
b72c				endm 
# End of macro FORTH_DSP_VALUEHL
b72c			 
b72c e5					push hl   ; u2 
b72d			 
b72d					; destroy value TOS 
b72d			 
b72d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b72d cd f8 9d			call macro_forth_dsp_pop 
b730				endm 
# End of macro FORTH_DSP_POP
b730			 
b730					; get u1 
b730			 
b730					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b730 cd 40 9d			call macro_dsp_valuehl 
b733				endm 
# End of macro FORTH_DSP_VALUEHL
b733			 
b733 e5					push hl  ; u1 
b734			 
b734					; destroy value TOS 
b734			 
b734					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b734 cd f8 9d			call macro_forth_dsp_pop 
b737				endm 
# End of macro FORTH_DSP_POP
b737			 
b737 b7			 or a      ;clear carry flag 
b738 e1			  pop hl    ; u1 
b739 d1			  pop de    ; u2 
b73a e5				push hl   ; saved in case hl is lowest 
b73b ed 52		  sbc hl,de 
b73d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b73f			 
b73f e1				pop hl 
b740					if DEBUG_FORTH_WORDS 
b740						DMARK "MAX" 
b740 f5				push af  
b741 3a 55 b7			ld a, (.dmark)  
b744 32 6e ee			ld (debug_mark),a  
b747 3a 56 b7			ld a, (.dmark+1)  
b74a 32 6f ee			ld (debug_mark+1),a  
b74d 3a 57 b7			ld a, (.dmark+2)  
b750 32 70 ee			ld (debug_mark+2),a  
b753 18 03			jr .pastdmark  
b755 ..			.dmark: db "MAX"  
b758 f1			.pastdmark: pop af  
b759			endm  
# End of macro DMARK
b759						CALLMONITOR 
b759 cd 72 ee			call debug_vector  
b75c				endm  
# End of macro CALLMONITOR
b75c					endif 
b75c cd 49 9b				call forth_push_numhl 
b75f			 
b75f				       NEXTW 
b75f c3 f6 9e			jp macro_next 
b762				endm 
# End of macro NEXTW
b762			 
b762			.maxcont:  
b762 c1				pop bc   ; tidy up 
b763 eb				ex de , hl  
b764					if DEBUG_FORTH_WORDS 
b764						DMARK "MA1" 
b764 f5				push af  
b765 3a 79 b7			ld a, (.dmark)  
b768 32 6e ee			ld (debug_mark),a  
b76b 3a 7a b7			ld a, (.dmark+1)  
b76e 32 6f ee			ld (debug_mark+1),a  
b771 3a 7b b7			ld a, (.dmark+2)  
b774 32 70 ee			ld (debug_mark+2),a  
b777 18 03			jr .pastdmark  
b779 ..			.dmark: db "MA1"  
b77c f1			.pastdmark: pop af  
b77d			endm  
# End of macro DMARK
b77d						CALLMONITOR 
b77d cd 72 ee			call debug_vector  
b780				endm  
# End of macro CALLMONITOR
b780					endif 
b780 cd 49 9b				call forth_push_numhl 
b783				       NEXTW 
b783 c3 f6 9e			jp macro_next 
b786				endm 
# End of macro NEXTW
b786			 
b786			.RND16: 
b786				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b786 4e				db WORD_SYS_CORE+58             
b787 b5 b7			dw .RND8            
b789 06				db 5 + 1 
b78a .. 00			db "RND16",0              
b790				endm 
# End of macro CWHEAD
b790			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b790					if DEBUG_FORTH_WORDS_KEY 
b790						DMARK "R16" 
b790 f5				push af  
b791 3a a5 b7			ld a, (.dmark)  
b794 32 6e ee			ld (debug_mark),a  
b797 3a a6 b7			ld a, (.dmark+1)  
b79a 32 6f ee			ld (debug_mark+1),a  
b79d 3a a7 b7			ld a, (.dmark+2)  
b7a0 32 70 ee			ld (debug_mark+2),a  
b7a3 18 03			jr .pastdmark  
b7a5 ..			.dmark: db "R16"  
b7a8 f1			.pastdmark: pop af  
b7a9			endm  
# End of macro DMARK
b7a9						CALLMONITOR 
b7a9 cd 72 ee			call debug_vector  
b7ac				endm  
# End of macro CALLMONITOR
b7ac					endif 
b7ac cd 03 8c				call prng16  
b7af cd 49 9b				call forth_push_numhl 
b7b2				       NEXTW 
b7b2 c3 f6 9e			jp macro_next 
b7b5				endm 
# End of macro NEXTW
b7b5			.RND8: 
b7b5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b7b5 60				db WORD_SYS_CORE+76             
b7b6 ea b7			dw .RND            
b7b8 05				db 4 + 1 
b7b9 .. 00			db "RND8",0              
b7be				endm 
# End of macro CWHEAD
b7be			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b7be					if DEBUG_FORTH_WORDS_KEY 
b7be						DMARK "RN8" 
b7be f5				push af  
b7bf 3a d3 b7			ld a, (.dmark)  
b7c2 32 6e ee			ld (debug_mark),a  
b7c5 3a d4 b7			ld a, (.dmark+1)  
b7c8 32 6f ee			ld (debug_mark+1),a  
b7cb 3a d5 b7			ld a, (.dmark+2)  
b7ce 32 70 ee			ld (debug_mark+2),a  
b7d1 18 03			jr .pastdmark  
b7d3 ..			.dmark: db "RN8"  
b7d6 f1			.pastdmark: pop af  
b7d7			endm  
# End of macro DMARK
b7d7						CALLMONITOR 
b7d7 cd 72 ee			call debug_vector  
b7da				endm  
# End of macro CALLMONITOR
b7da					endif 
b7da 2a ac eb				ld hl,(xrandc) 
b7dd 23					inc hl 
b7de cd 1d 8c				call xrnd 
b7e1 6f					ld l,a	 
b7e2 26 00				ld h,0 
b7e4 cd 49 9b				call forth_push_numhl 
b7e7				       NEXTW 
b7e7 c3 f6 9e			jp macro_next 
b7ea				endm 
# End of macro NEXTW
b7ea			.RND: 
b7ea				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7ea 60				db WORD_SYS_CORE+76             
b7eb f0 b8			dw .ENDMATHS            
b7ed 04				db 3 + 1 
b7ee .. 00			db "RND",0              
b7f2				endm 
# End of macro CWHEAD
b7f2			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7f2			 
b7f2					if DEBUG_FORTH_WORDS_KEY 
b7f2						DMARK "RND" 
b7f2 f5				push af  
b7f3 3a 07 b8			ld a, (.dmark)  
b7f6 32 6e ee			ld (debug_mark),a  
b7f9 3a 08 b8			ld a, (.dmark+1)  
b7fc 32 6f ee			ld (debug_mark+1),a  
b7ff 3a 09 b8			ld a, (.dmark+2)  
b802 32 70 ee			ld (debug_mark+2),a  
b805 18 03			jr .pastdmark  
b807 ..			.dmark: db "RND"  
b80a f1			.pastdmark: pop af  
b80b			endm  
# End of macro DMARK
b80b						CALLMONITOR 
b80b cd 72 ee			call debug_vector  
b80e				endm  
# End of macro CALLMONITOR
b80e					endif 
b80e					 
b80e					FORTH_DSP_VALUEHL    ; upper range 
b80e cd 40 9d			call macro_dsp_valuehl 
b811				endm 
# End of macro FORTH_DSP_VALUEHL
b811			 
b811 22 b0 eb				ld (LFSRSeed), hl	 
b814			 
b814					if DEBUG_FORTH_WORDS 
b814						DMARK "RN1" 
b814 f5				push af  
b815 3a 29 b8			ld a, (.dmark)  
b818 32 6e ee			ld (debug_mark),a  
b81b 3a 2a b8			ld a, (.dmark+1)  
b81e 32 6f ee			ld (debug_mark+1),a  
b821 3a 2b b8			ld a, (.dmark+2)  
b824 32 70 ee			ld (debug_mark+2),a  
b827 18 03			jr .pastdmark  
b829 ..			.dmark: db "RN1"  
b82c f1			.pastdmark: pop af  
b82d			endm  
# End of macro DMARK
b82d						CALLMONITOR 
b82d cd 72 ee			call debug_vector  
b830				endm  
# End of macro CALLMONITOR
b830					endif 
b830					FORTH_DSP_POP 
b830 cd f8 9d			call macro_forth_dsp_pop 
b833				endm 
# End of macro FORTH_DSP_POP
b833			 
b833					FORTH_DSP_VALUEHL    ; low range 
b833 cd 40 9d			call macro_dsp_valuehl 
b836				endm 
# End of macro FORTH_DSP_VALUEHL
b836			 
b836					if DEBUG_FORTH_WORDS 
b836						DMARK "RN2" 
b836 f5				push af  
b837 3a 4b b8			ld a, (.dmark)  
b83a 32 6e ee			ld (debug_mark),a  
b83d 3a 4c b8			ld a, (.dmark+1)  
b840 32 6f ee			ld (debug_mark+1),a  
b843 3a 4d b8			ld a, (.dmark+2)  
b846 32 70 ee			ld (debug_mark+2),a  
b849 18 03			jr .pastdmark  
b84b ..			.dmark: db "RN2"  
b84e f1			.pastdmark: pop af  
b84f			endm  
# End of macro DMARK
b84f						CALLMONITOR 
b84f cd 72 ee			call debug_vector  
b852				endm  
# End of macro CALLMONITOR
b852					endif 
b852 22 b2 eb				ld (LFSRSeed+2), hl 
b855			 
b855					FORTH_DSP_POP 
b855 cd f8 9d			call macro_forth_dsp_pop 
b858				endm 
# End of macro FORTH_DSP_POP
b858			 
b858 e5					push hl 
b859			 
b859 e1			.inrange:	pop hl 
b85a cd 03 8c				call prng16  
b85d					if DEBUG_FORTH_WORDS 
b85d						DMARK "RN3" 
b85d f5				push af  
b85e 3a 72 b8			ld a, (.dmark)  
b861 32 6e ee			ld (debug_mark),a  
b864 3a 73 b8			ld a, (.dmark+1)  
b867 32 6f ee			ld (debug_mark+1),a  
b86a 3a 74 b8			ld a, (.dmark+2)  
b86d 32 70 ee			ld (debug_mark+2),a  
b870 18 03			jr .pastdmark  
b872 ..			.dmark: db "RN3"  
b875 f1			.pastdmark: pop af  
b876			endm  
# End of macro DMARK
b876						CALLMONITOR 
b876 cd 72 ee			call debug_vector  
b879				endm  
# End of macro CALLMONITOR
b879					endif 
b879					 
b879					; if the range is 8bit knock out the high byte 
b879			 
b879 ed 5b b0 eb			ld de, (LFSRSeed)     ; check high level 
b87d			 
b87d 3e 00				ld a, 0 
b87f ba					cp d  
b880 20 1e				jr nz, .hirange 
b882 26 00				ld h, 0   ; knock it down to 8bit 
b884			 
b884					if DEBUG_FORTH_WORDS 
b884						DMARK "RNk" 
b884 f5				push af  
b885 3a 99 b8			ld a, (.dmark)  
b888 32 6e ee			ld (debug_mark),a  
b88b 3a 9a b8			ld a, (.dmark+1)  
b88e 32 6f ee			ld (debug_mark+1),a  
b891 3a 9b b8			ld a, (.dmark+2)  
b894 32 70 ee			ld (debug_mark+2),a  
b897 18 03			jr .pastdmark  
b899 ..			.dmark: db "RNk"  
b89c f1			.pastdmark: pop af  
b89d			endm  
# End of macro DMARK
b89d						CALLMONITOR 
b89d cd 72 ee			call debug_vector  
b8a0				endm  
# End of macro CALLMONITOR
b8a0					endif 
b8a0			.hirange:   
b8a0 e5					push hl  
b8a1 b7					or a  
b8a2 ed 52		                sbc hl, de 
b8a4			 
b8a4					;call cmp16 
b8a4			 
b8a4 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b8a6 e1					pop hl 
b8a7 e5					push hl 
b8a8			 
b8a8					if DEBUG_FORTH_WORDS 
b8a8						DMARK "RN4" 
b8a8 f5				push af  
b8a9 3a bd b8			ld a, (.dmark)  
b8ac 32 6e ee			ld (debug_mark),a  
b8af 3a be b8			ld a, (.dmark+1)  
b8b2 32 6f ee			ld (debug_mark+1),a  
b8b5 3a bf b8			ld a, (.dmark+2)  
b8b8 32 70 ee			ld (debug_mark+2),a  
b8bb 18 03			jr .pastdmark  
b8bd ..			.dmark: db "RN4"  
b8c0 f1			.pastdmark: pop af  
b8c1			endm  
# End of macro DMARK
b8c1						CALLMONITOR 
b8c1 cd 72 ee			call debug_vector  
b8c4				endm  
# End of macro CALLMONITOR
b8c4					endif 
b8c4 ed 5b b2 eb			ld de, (LFSRSeed+2)   ; check low range 
b8c8					;call cmp16 
b8c8				 
b8c8 b7					or a  
b8c9 ed 52		                sbc hl, de 
b8cb 38 8c				jr c, .inrange 
b8cd			 
b8cd e1					pop hl 
b8ce					 
b8ce					if DEBUG_FORTH_WORDS 
b8ce						DMARK "RNd" 
b8ce f5				push af  
b8cf 3a e3 b8			ld a, (.dmark)  
b8d2 32 6e ee			ld (debug_mark),a  
b8d5 3a e4 b8			ld a, (.dmark+1)  
b8d8 32 6f ee			ld (debug_mark+1),a  
b8db 3a e5 b8			ld a, (.dmark+2)  
b8de 32 70 ee			ld (debug_mark+2),a  
b8e1 18 03			jr .pastdmark  
b8e3 ..			.dmark: db "RNd"  
b8e6 f1			.pastdmark: pop af  
b8e7			endm  
# End of macro DMARK
b8e7						CALLMONITOR 
b8e7 cd 72 ee			call debug_vector  
b8ea				endm  
# End of macro CALLMONITOR
b8ea					endif 
b8ea			 
b8ea			 
b8ea cd 49 9b				call forth_push_numhl 
b8ed				       NEXTW 
b8ed c3 f6 9e			jp macro_next 
b8f0				endm 
# End of macro NEXTW
b8f0			 
b8f0			.ENDMATHS: 
b8f0			 
b8f0			; eof 
b8f0			 
# End of file forth_words_maths.asm
b8f0			include "forth_words_display.asm" 
b8f0			 
b8f0			; | ## Display Words 
b8f0			 
b8f0			.ACT: 
b8f0			 
b8f0				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8f0 62				db WORD_SYS_CORE+78             
b8f1 3c b9			dw .INFO            
b8f3 07				db 6 + 1 
b8f4 .. 00			db "ACTIVE",0              
b8fb				endm 
# End of macro CWHEAD
b8fb			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b8fb			;  
b8fb			; | | e.g. $ff $00 do active . $01 pause loop 
b8fb			 
b8fb					if DEBUG_FORTH_WORDS_KEY 
b8fb						DMARK "ACT" 
b8fb f5				push af  
b8fc 3a 10 b9			ld a, (.dmark)  
b8ff 32 6e ee			ld (debug_mark),a  
b902 3a 11 b9			ld a, (.dmark+1)  
b905 32 6f ee			ld (debug_mark+1),a  
b908 3a 12 b9			ld a, (.dmark+2)  
b90b 32 70 ee			ld (debug_mark+2),a  
b90e 18 03			jr .pastdmark  
b910 ..			.dmark: db "ACT"  
b913 f1			.pastdmark: pop af  
b914			endm  
# End of macro DMARK
b914						CALLMONITOR 
b914 cd 72 ee			call debug_vector  
b917				endm  
# End of macro CALLMONITOR
b917					endif 
b917 cd 06 8a				call active 
b91a					if DEBUG_FORTH_WORDS 
b91a						DMARK "ACp" 
b91a f5				push af  
b91b 3a 2f b9			ld a, (.dmark)  
b91e 32 6e ee			ld (debug_mark),a  
b921 3a 30 b9			ld a, (.dmark+1)  
b924 32 6f ee			ld (debug_mark+1),a  
b927 3a 31 b9			ld a, (.dmark+2)  
b92a 32 70 ee			ld (debug_mark+2),a  
b92d 18 03			jr .pastdmark  
b92f ..			.dmark: db "ACp"  
b932 f1			.pastdmark: pop af  
b933			endm  
# End of macro DMARK
b933						CALLMONITOR 
b933 cd 72 ee			call debug_vector  
b936				endm  
# End of macro CALLMONITOR
b936					endif 
b936 cd b7 9b				call forth_push_str 
b939			 
b939					NEXTW 
b939 c3 f6 9e			jp macro_next 
b93c				endm 
# End of macro NEXTW
b93c			.INFO: 
b93c			 
b93c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b93c 62				db WORD_SYS_CORE+78             
b93d 59 b9			dw .ATP            
b93f 05				db 4 + 1 
b940 .. 00			db "INFO",0              
b945				endm 
# End of macro CWHEAD
b945			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b945					FORTH_DSP_VALUEHL 
b945 cd 40 9d			call macro_dsp_valuehl 
b948				endm 
# End of macro FORTH_DSP_VALUEHL
b948			 
b948					FORTH_DSP_POP 
b948 cd f8 9d			call macro_forth_dsp_pop 
b94b				endm 
# End of macro FORTH_DSP_POP
b94b			 
b94b e5					push hl 
b94c			 
b94c					FORTH_DSP_VALUEHL 
b94c cd 40 9d			call macro_dsp_valuehl 
b94f				endm 
# End of macro FORTH_DSP_VALUEHL
b94f			 
b94f					FORTH_DSP_POP 
b94f cd f8 9d			call macro_forth_dsp_pop 
b952				endm 
# End of macro FORTH_DSP_POP
b952			 
b952 d1					pop de 
b953			 
b953 cd 40 8a				call info_panel 
b956			 
b956			 
b956					NEXTW 
b956 c3 f6 9e			jp macro_next 
b959				endm 
# End of macro NEXTW
b959			.ATP: 
b959				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b959 62				db WORD_SYS_CORE+78             
b95a d0 b9			dw .FB            
b95c 04				db 3 + 1 
b95d .. 00			db "AT?",0              
b961				endm 
# End of macro CWHEAD
b961			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b961					if DEBUG_FORTH_WORDS_KEY 
b961						DMARK "AT?" 
b961 f5				push af  
b962 3a 76 b9			ld a, (.dmark)  
b965 32 6e ee			ld (debug_mark),a  
b968 3a 77 b9			ld a, (.dmark+1)  
b96b 32 6f ee			ld (debug_mark+1),a  
b96e 3a 78 b9			ld a, (.dmark+2)  
b971 32 70 ee			ld (debug_mark+2),a  
b974 18 03			jr .pastdmark  
b976 ..			.dmark: db "AT?"  
b979 f1			.pastdmark: pop af  
b97a			endm  
# End of macro DMARK
b97a						CALLMONITOR 
b97a cd 72 ee			call debug_vector  
b97d				endm  
# End of macro CALLMONITOR
b97d					endif 
b97d 3a 61 ea				ld a, (f_cursor_ptr) 
b980			 
b980			if DEBUG_FORTH_WORDS 
b980				DMARK "AT?" 
b980 f5				push af  
b981 3a 95 b9			ld a, (.dmark)  
b984 32 6e ee			ld (debug_mark),a  
b987 3a 96 b9			ld a, (.dmark+1)  
b98a 32 6f ee			ld (debug_mark+1),a  
b98d 3a 97 b9			ld a, (.dmark+2)  
b990 32 70 ee			ld (debug_mark+2),a  
b993 18 03			jr .pastdmark  
b995 ..			.dmark: db "AT?"  
b998 f1			.pastdmark: pop af  
b999			endm  
# End of macro DMARK
b999				CALLMONITOR 
b999 cd 72 ee			call debug_vector  
b99c				endm  
# End of macro CALLMONITOR
b99c			endif	 
b99c					; count the number of rows 
b99c			 
b99c 06 00				ld b, 0 
b99e 4f			.atpr:		ld c, a    ; save in case we go below zero 
b99f d6 28				sub display_cols 
b9a1 f2 a7 b9				jp p, .atprunder 
b9a4 04					inc b 
b9a5 18 f7				jr .atpr 
b9a7			.atprunder:	 
b9a7			if DEBUG_FORTH_WORDS 
b9a7				DMARK "A?2" 
b9a7 f5				push af  
b9a8 3a bc b9			ld a, (.dmark)  
b9ab 32 6e ee			ld (debug_mark),a  
b9ae 3a bd b9			ld a, (.dmark+1)  
b9b1 32 6f ee			ld (debug_mark+1),a  
b9b4 3a be b9			ld a, (.dmark+2)  
b9b7 32 70 ee			ld (debug_mark+2),a  
b9ba 18 03			jr .pastdmark  
b9bc ..			.dmark: db "A?2"  
b9bf f1			.pastdmark: pop af  
b9c0			endm  
# End of macro DMARK
b9c0				CALLMONITOR 
b9c0 cd 72 ee			call debug_vector  
b9c3				endm  
# End of macro CALLMONITOR
b9c3			endif	 
b9c3 26 00				ld h, 0 
b9c5 69					ld l, c 
b9c6 cd 49 9b				call forth_push_numhl 
b9c9 68					ld l, b  
b9ca cd 49 9b				call forth_push_numhl 
b9cd			 
b9cd			 
b9cd				NEXTW 
b9cd c3 f6 9e			jp macro_next 
b9d0				endm 
# End of macro NEXTW
b9d0			 
b9d0			.FB: 
b9d0				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b9d0 1b				db WORD_SYS_CORE+7             
b9d1 1e ba			dw .EMIT            
b9d3 03				db 2 + 1 
b9d4 .. 00			db "FB",0              
b9d7				endm 
# End of macro CWHEAD
b9d7			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b9d7			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b9d7			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b9d7			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b9d7					if DEBUG_FORTH_WORDS_KEY 
b9d7						DMARK "FB." 
b9d7 f5				push af  
b9d8 3a ec b9			ld a, (.dmark)  
b9db 32 6e ee			ld (debug_mark),a  
b9de 3a ed b9			ld a, (.dmark+1)  
b9e1 32 6f ee			ld (debug_mark+1),a  
b9e4 3a ee b9			ld a, (.dmark+2)  
b9e7 32 70 ee			ld (debug_mark+2),a  
b9ea 18 03			jr .pastdmark  
b9ec ..			.dmark: db "FB."  
b9ef f1			.pastdmark: pop af  
b9f0			endm  
# End of macro DMARK
b9f0						CALLMONITOR 
b9f0 cd 72 ee			call debug_vector  
b9f3				endm  
# End of macro CALLMONITOR
b9f3					endif 
b9f3			 
b9f3					FORTH_DSP_VALUEHL 
b9f3 cd 40 9d			call macro_dsp_valuehl 
b9f6				endm 
# End of macro FORTH_DSP_VALUEHL
b9f6			 
b9f6 7d					ld a, l 
b9f7 fe 01				cp 1 
b9f9 20 05				jr nz, .fbn1 
b9fb 21 13 ed				ld hl, display_fb1 
b9fe 18 15				jr .fbset 
ba00 fe 02		.fbn1:		cp 2 
ba02 20 05				jr nz, .fbn2 
ba04 21 d1 eb				ld hl, display_fb2 
ba07 18 0c				jr .fbset 
ba09 fe 03		.fbn2:		cp 3 
ba0b 20 05				jr nz, .fbn3 
ba0d 21 72 ec				ld hl, display_fb3 
ba10 18 03				jr .fbset 
ba12			.fbn3:		 ; if invalid number select first 
ba12 21 13 ed				ld hl, display_fb1 
ba15 22 cf eb		.fbset:		ld (display_fb_active), hl 
ba18			 
ba18					FORTH_DSP_POP 
ba18 cd f8 9d			call macro_forth_dsp_pop 
ba1b				endm 
# End of macro FORTH_DSP_POP
ba1b			 
ba1b					NEXTW 
ba1b c3 f6 9e			jp macro_next 
ba1e				endm 
# End of macro NEXTW
ba1e			 
ba1e			 
ba1e			.EMIT: 
ba1e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba1e 1b				db WORD_SYS_CORE+7             
ba1f 6f ba			dw .DOTH            
ba21 05				db 4 + 1 
ba22 .. 00			db "EMIT",0              
ba27				endm 
# End of macro CWHEAD
ba27			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba27					; get value off TOS and display it 
ba27			 
ba27					if DEBUG_FORTH_WORDS_KEY 
ba27						DMARK "EMT" 
ba27 f5				push af  
ba28 3a 3c ba			ld a, (.dmark)  
ba2b 32 6e ee			ld (debug_mark),a  
ba2e 3a 3d ba			ld a, (.dmark+1)  
ba31 32 6f ee			ld (debug_mark+1),a  
ba34 3a 3e ba			ld a, (.dmark+2)  
ba37 32 70 ee			ld (debug_mark+2),a  
ba3a 18 03			jr .pastdmark  
ba3c ..			.dmark: db "EMT"  
ba3f f1			.pastdmark: pop af  
ba40			endm  
# End of macro DMARK
ba40						CALLMONITOR 
ba40 cd 72 ee			call debug_vector  
ba43				endm  
# End of macro CALLMONITOR
ba43					endif 
ba43			 
ba43					FORTH_DSP_VALUEHL 
ba43 cd 40 9d			call macro_dsp_valuehl 
ba46				endm 
# End of macro FORTH_DSP_VALUEHL
ba46			 
ba46 7d					ld a,l 
ba47			 
ba47					; TODO write to display 
ba47			 
ba47 32 c2 e4				ld (os_input), a 
ba4a 3e 00				ld a, 0 
ba4c 32 c3 e4				ld (os_input+1), a 
ba4f					 
ba4f 3a 61 ea				ld a, (f_cursor_ptr) 
ba52 11 c2 e4				ld de, os_input 
ba55 cd c2 8a				call str_at_display 
ba58			 
ba58			 
ba58 3a 3f ea				ld a,(cli_autodisplay) 
ba5b fe 00				cp 0 
ba5d 28 03				jr z, .enoupdate 
ba5f cd d2 8a						call update_display 
ba62					.enoupdate: 
ba62			 
ba62 3a 61 ea				ld a, (f_cursor_ptr) 
ba65 3c					inc a 
ba66 32 61 ea				ld (f_cursor_ptr), a   ; save new pos 
ba69			 
ba69			 
ba69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba69 cd f8 9d			call macro_forth_dsp_pop 
ba6c				endm 
# End of macro FORTH_DSP_POP
ba6c			  
ba6c			 
ba6c					NEXTW 
ba6c c3 f6 9e			jp macro_next 
ba6f				endm 
# End of macro NEXTW
ba6f			.DOTH: 
ba6f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba6f 1c				db WORD_SYS_CORE+8             
ba70 9f ba			dw .DOTF            
ba72 03				db 2 + 1 
ba73 .. 00			db ".-",0              
ba76				endm 
# End of macro CWHEAD
ba76			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba76					; get value off TOS and display it 
ba76					if DEBUG_FORTH_WORDS_KEY 
ba76						DMARK "DTD" 
ba76 f5				push af  
ba77 3a 8b ba			ld a, (.dmark)  
ba7a 32 6e ee			ld (debug_mark),a  
ba7d 3a 8c ba			ld a, (.dmark+1)  
ba80 32 6f ee			ld (debug_mark+1),a  
ba83 3a 8d ba			ld a, (.dmark+2)  
ba86 32 70 ee			ld (debug_mark+2),a  
ba89 18 03			jr .pastdmark  
ba8b ..			.dmark: db "DTD"  
ba8e f1			.pastdmark: pop af  
ba8f			endm  
# End of macro DMARK
ba8f						CALLMONITOR 
ba8f cd 72 ee			call debug_vector  
ba92				endm  
# End of macro CALLMONITOR
ba92					endif 
ba92 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba94 3e 00			ld a, 0 
ba96 32 40 ea			ld (cli_mvdot), a 
ba99 c3 f6 ba			jp .dotgo 
ba9c				NEXTW 
ba9c c3 f6 9e			jp macro_next 
ba9f				endm 
# End of macro NEXTW
ba9f			.DOTF: 
ba9f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba9f 1c				db WORD_SYS_CORE+8             
baa0 cd ba			dw .DOT            
baa2 03				db 2 + 1 
baa3 .. 00			db ".>",0              
baa6				endm 
# End of macro CWHEAD
baa6			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
baa6					; get value off TOS and display it 
baa6			        ; TODO BUG adds extra spaces 
baa6			        ; TODO BUG handle numerics? 
baa6					if DEBUG_FORTH_WORDS_KEY 
baa6						DMARK "DTC" 
baa6 f5				push af  
baa7 3a bb ba			ld a, (.dmark)  
baaa 32 6e ee			ld (debug_mark),a  
baad 3a bc ba			ld a, (.dmark+1)  
bab0 32 6f ee			ld (debug_mark+1),a  
bab3 3a bd ba			ld a, (.dmark+2)  
bab6 32 70 ee			ld (debug_mark+2),a  
bab9 18 03			jr .pastdmark  
babb ..			.dmark: db "DTC"  
babe f1			.pastdmark: pop af  
babf			endm  
# End of macro DMARK
babf						CALLMONITOR 
babf cd 72 ee			call debug_vector  
bac2				endm  
# End of macro CALLMONITOR
bac2					endif 
bac2 3e 01			ld a, 1 
bac4 32 40 ea			ld (cli_mvdot), a 
bac7 c3 f6 ba			jp .dotgo 
baca				NEXTW 
baca c3 f6 9e			jp macro_next 
bacd				endm 
# End of macro NEXTW
bacd			 
bacd			.DOT: 
bacd				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bacd 1c				db WORD_SYS_CORE+8             
bace a9 bc			dw .CLS            
bad0 02				db 1 + 1 
bad1 .. 00			db ".",0              
bad3				endm 
# End of macro CWHEAD
bad3			        ; | . ( u -- ) Display TOS | DONE 
bad3					; get value off TOS and display it 
bad3			 
bad3					if DEBUG_FORTH_WORDS_KEY 
bad3						DMARK "DOT" 
bad3 f5				push af  
bad4 3a e8 ba			ld a, (.dmark)  
bad7 32 6e ee			ld (debug_mark),a  
bada 3a e9 ba			ld a, (.dmark+1)  
badd 32 6f ee			ld (debug_mark+1),a  
bae0 3a ea ba			ld a, (.dmark+2)  
bae3 32 70 ee			ld (debug_mark+2),a  
bae6 18 03			jr .pastdmark  
bae8 ..			.dmark: db "DOT"  
baeb f1			.pastdmark: pop af  
baec			endm  
# End of macro DMARK
baec						CALLMONITOR 
baec cd 72 ee			call debug_vector  
baef				endm  
# End of macro CALLMONITOR
baef					endif 
baef 3e 00			ld a, 0 
baf1 32 40 ea			ld (cli_mvdot), a 
baf4 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
baf6				 
baf6			 
baf6			.dotgo: 
baf6			 
baf6			; move up type to on stack for parserv5 
baf6					FORTH_DSP 
baf6 cd 06 9d			call macro_forth_dsp 
baf9				endm 
# End of macro FORTH_DSP
baf9				;FORTH_DSP_VALUE  
baf9			 
baf9			if DEBUG_FORTH_DOT 
baf9				DMARK "DOT" 
baf9 f5				push af  
bafa 3a 0e bb			ld a, (.dmark)  
bafd 32 6e ee			ld (debug_mark),a  
bb00 3a 0f bb			ld a, (.dmark+1)  
bb03 32 6f ee			ld (debug_mark+1),a  
bb06 3a 10 bb			ld a, (.dmark+2)  
bb09 32 70 ee			ld (debug_mark+2),a  
bb0c 18 03			jr .pastdmark  
bb0e ..			.dmark: db "DOT"  
bb11 f1			.pastdmark: pop af  
bb12			endm  
# End of macro DMARK
bb12				CALLMONITOR 
bb12 cd 72 ee			call debug_vector  
bb15				endm  
# End of macro CALLMONITOR
bb15			endif	 
bb15			;		.print: 
bb15			 
bb15 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb16 23				inc hl   ; position to the actual value 
bb17 fe 01			cp DS_TYPE_STR 
bb19 20 06			jr nz, .dotnum1  
bb1b			 
bb1b			; display string 
bb1b				FORTH_DSP_VALUE  
bb1b cd 29 9d			call macro_forth_dsp_value 
bb1e				endm 
# End of macro FORTH_DSP_VALUE
bb1e eb				ex de,hl 
bb1f 18 49			jr .dotwrite 
bb21			 
bb21			.dotnum1: 
bb21 fe 02			cp DS_TYPE_INUM 
bb23 20 44			jr nz, .dotflot 
bb25			 
bb25			 
bb25			; display number 
bb25			 
bb25			;	push hl 
bb25			;	call clear_display 
bb25			;	pop hl 
bb25			 
bb25 5e				ld e, (hl) 
bb26 23				inc hl 
bb27 56				ld d, (hl) 
bb28 21 c4 e2			ld hl, scratch 
bb2b			if DEBUG_FORTH_DOT 
bb2b				DMARK "DT1" 
bb2b f5				push af  
bb2c 3a 40 bb			ld a, (.dmark)  
bb2f 32 6e ee			ld (debug_mark),a  
bb32 3a 41 bb			ld a, (.dmark+1)  
bb35 32 6f ee			ld (debug_mark+1),a  
bb38 3a 42 bb			ld a, (.dmark+2)  
bb3b 32 70 ee			ld (debug_mark+2),a  
bb3e 18 03			jr .pastdmark  
bb40 ..			.dmark: db "DT1"  
bb43 f1			.pastdmark: pop af  
bb44			endm  
# End of macro DMARK
bb44				CALLMONITOR 
bb44 cd 72 ee			call debug_vector  
bb47				endm  
# End of macro CALLMONITOR
bb47			endif	 
bb47			 
bb47 cd e9 90			call uitoa_16 
bb4a eb				ex de,hl 
bb4b			 
bb4b			if DEBUG_FORTH_DOT 
bb4b				DMARK "DT2" 
bb4b f5				push af  
bb4c 3a 60 bb			ld a, (.dmark)  
bb4f 32 6e ee			ld (debug_mark),a  
bb52 3a 61 bb			ld a, (.dmark+1)  
bb55 32 6f ee			ld (debug_mark+1),a  
bb58 3a 62 bb			ld a, (.dmark+2)  
bb5b 32 70 ee			ld (debug_mark+2),a  
bb5e 18 03			jr .pastdmark  
bb60 ..			.dmark: db "DT2"  
bb63 f1			.pastdmark: pop af  
bb64			endm  
# End of macro DMARK
bb64				CALLMONITOR 
bb64 cd 72 ee			call debug_vector  
bb67				endm  
# End of macro CALLMONITOR
bb67			endif	 
bb67			 
bb67			;	ld de, os_word_scratch 
bb67 18 01			jr .dotwrite 
bb69			 
bb69 00			.dotflot:   nop 
bb6a			; TODO print floating point number 
bb6a			 
bb6a			.dotwrite:		 
bb6a			 
bb6a					; if c is set then set all '-' to spaces 
bb6a					; need to also take into account .>  
bb6a			 
bb6a 3e 01				ld a, 1 
bb6c b9					cp c 
bb6d 20 67				jr nz, .nodashswap 
bb6f			 
bb6f					; DE has the string to write, working with HL 
bb6f			 
bb6f 06 ff				ld b, 255 
bb71 d5					push de 
bb72 e1					pop hl 
bb73			 
bb73			if DEBUG_FORTH_DOT 
bb73				DMARK "DT-" 
bb73 f5				push af  
bb74 3a 88 bb			ld a, (.dmark)  
bb77 32 6e ee			ld (debug_mark),a  
bb7a 3a 89 bb			ld a, (.dmark+1)  
bb7d 32 6f ee			ld (debug_mark+1),a  
bb80 3a 8a bb			ld a, (.dmark+2)  
bb83 32 70 ee			ld (debug_mark+2),a  
bb86 18 03			jr .pastdmark  
bb88 ..			.dmark: db "DT-"  
bb8b f1			.pastdmark: pop af  
bb8c			endm  
# End of macro DMARK
bb8c				CALLMONITOR 
bb8c cd 72 ee			call debug_vector  
bb8f				endm  
# End of macro CALLMONITOR
bb8f			endif	 
bb8f 7e			.dashscan:	ld a, (hl) 
bb90 fe 00				cp 0 
bb92 28 42				jr z, .nodashswap 
bb94 fe 2d				cp '-' 
bb96 20 03				jr nz, .dashskip 
bb98 3e 20				ld a, ' ' 
bb9a 77					ld (hl), a 
bb9b 23			.dashskip:	inc hl 
bb9c			if DEBUG_FORTH_DOT 
bb9c				DMARK "D-2" 
bb9c f5				push af  
bb9d 3a b1 bb			ld a, (.dmark)  
bba0 32 6e ee			ld (debug_mark),a  
bba3 3a b2 bb			ld a, (.dmark+1)  
bba6 32 6f ee			ld (debug_mark+1),a  
bba9 3a b3 bb			ld a, (.dmark+2)  
bbac 32 70 ee			ld (debug_mark+2),a  
bbaf 18 03			jr .pastdmark  
bbb1 ..			.dmark: db "D-2"  
bbb4 f1			.pastdmark: pop af  
bbb5			endm  
# End of macro DMARK
bbb5				CALLMONITOR 
bbb5 cd 72 ee			call debug_vector  
bbb8				endm  
# End of macro CALLMONITOR
bbb8			endif	 
bbb8 10 d5				djnz .dashscan 
bbba			 
bbba			if DEBUG_FORTH_DOT 
bbba				DMARK "D-1" 
bbba f5				push af  
bbbb 3a cf bb			ld a, (.dmark)  
bbbe 32 6e ee			ld (debug_mark),a  
bbc1 3a d0 bb			ld a, (.dmark+1)  
bbc4 32 6f ee			ld (debug_mark+1),a  
bbc7 3a d1 bb			ld a, (.dmark+2)  
bbca 32 70 ee			ld (debug_mark+2),a  
bbcd 18 03			jr .pastdmark  
bbcf ..			.dmark: db "D-1"  
bbd2 f1			.pastdmark: pop af  
bbd3			endm  
# End of macro DMARK
bbd3				CALLMONITOR 
bbd3 cd 72 ee			call debug_vector  
bbd6				endm  
# End of macro CALLMONITOR
bbd6			endif	 
bbd6			 
bbd6			.nodashswap: 
bbd6			 
bbd6			if DEBUG_FORTH_DOT 
bbd6				DMARK "D-o" 
bbd6 f5				push af  
bbd7 3a eb bb			ld a, (.dmark)  
bbda 32 6e ee			ld (debug_mark),a  
bbdd 3a ec bb			ld a, (.dmark+1)  
bbe0 32 6f ee			ld (debug_mark+1),a  
bbe3 3a ed bb			ld a, (.dmark+2)  
bbe6 32 70 ee			ld (debug_mark+2),a  
bbe9 18 03			jr .pastdmark  
bbeb ..			.dmark: db "D-o"  
bbee f1			.pastdmark: pop af  
bbef			endm  
# End of macro DMARK
bbef				CALLMONITOR 
bbef cd 72 ee			call debug_vector  
bbf2				endm  
# End of macro CALLMONITOR
bbf2			endif	 
bbf2			 
bbf2 d5					push de   ; save string start in case we need to advance print 
bbf3			 
bbf3 3a 61 ea				ld a, (f_cursor_ptr) 
bbf6 cd c2 8a				call str_at_display 
bbf9 3a 3f ea				ld a,(cli_autodisplay) 
bbfc fe 00				cp 0 
bbfe 28 03				jr z, .noupdate 
bc00 cd d2 8a						call update_display 
bc03					.noupdate: 
bc03			 
bc03			 
bc03					; see if we need to advance the print position 
bc03			 
bc03 e1					pop hl   ; get back string 
bc04			;		ex de,hl 
bc04			 
bc04 3a 40 ea				ld a, (cli_mvdot) 
bc07			if DEBUG_FORTH_DOT 
bc07			;		ld e,a 
bc07				DMARK "D>1" 
bc07 f5				push af  
bc08 3a 1c bc			ld a, (.dmark)  
bc0b 32 6e ee			ld (debug_mark),a  
bc0e 3a 1d bc			ld a, (.dmark+1)  
bc11 32 6f ee			ld (debug_mark+1),a  
bc14 3a 1e bc			ld a, (.dmark+2)  
bc17 32 70 ee			ld (debug_mark+2),a  
bc1a 18 03			jr .pastdmark  
bc1c ..			.dmark: db "D>1"  
bc1f f1			.pastdmark: pop af  
bc20			endm  
# End of macro DMARK
bc20				CALLMONITOR 
bc20 cd 72 ee			call debug_vector  
bc23				endm  
# End of macro CALLMONITOR
bc23			endif	 
bc23 fe 00				cp 0 
bc25 28 44				jr z, .noadv 
bc27					; yes, lets advance the print position 
bc27 3e 00				ld a, 0 
bc29 cd 45 91				call strlent 
bc2c			if DEBUG_FORTH_DOT 
bc2c				DMARK "D-?" 
bc2c f5				push af  
bc2d 3a 41 bc			ld a, (.dmark)  
bc30 32 6e ee			ld (debug_mark),a  
bc33 3a 42 bc			ld a, (.dmark+1)  
bc36 32 6f ee			ld (debug_mark+1),a  
bc39 3a 43 bc			ld a, (.dmark+2)  
bc3c 32 70 ee			ld (debug_mark+2),a  
bc3f 18 03			jr .pastdmark  
bc41 ..			.dmark: db "D-?"  
bc44 f1			.pastdmark: pop af  
bc45			endm  
# End of macro DMARK
bc45				CALLMONITOR 
bc45 cd 72 ee			call debug_vector  
bc48				endm  
# End of macro CALLMONITOR
bc48			endif	 
bc48 3a 61 ea				ld a, (f_cursor_ptr) 
bc4b 85					add a,l 
bc4c					;call addatohl 
bc4c					;ld a, l 
bc4c 32 61 ea				ld (f_cursor_ptr), a   ; save new pos 
bc4f			 
bc4f			if DEBUG_FORTH_DOT 
bc4f				DMARK "D->" 
bc4f f5				push af  
bc50 3a 64 bc			ld a, (.dmark)  
bc53 32 6e ee			ld (debug_mark),a  
bc56 3a 65 bc			ld a, (.dmark+1)  
bc59 32 6f ee			ld (debug_mark+1),a  
bc5c 3a 66 bc			ld a, (.dmark+2)  
bc5f 32 70 ee			ld (debug_mark+2),a  
bc62 18 03			jr .pastdmark  
bc64 ..			.dmark: db "D->"  
bc67 f1			.pastdmark: pop af  
bc68			endm  
# End of macro DMARK
bc68				CALLMONITOR 
bc68 cd 72 ee			call debug_vector  
bc6b				endm  
# End of macro CALLMONITOR
bc6b			endif	 
bc6b			 
bc6b			.noadv:	 
bc6b			 
bc6b					if DEBUG_FORTH_DOT_WAIT 
bc6b							call next_page_prompt 
bc6b					endif	 
bc6b			; TODO this pop off the stack causes a crash. i dont know why 
bc6b			 
bc6b			 
bc6b			if DEBUG_FORTH_DOT 
bc6b				DMARK "DTh" 
bc6b f5				push af  
bc6c 3a 80 bc			ld a, (.dmark)  
bc6f 32 6e ee			ld (debug_mark),a  
bc72 3a 81 bc			ld a, (.dmark+1)  
bc75 32 6f ee			ld (debug_mark+1),a  
bc78 3a 82 bc			ld a, (.dmark+2)  
bc7b 32 70 ee			ld (debug_mark+2),a  
bc7e 18 03			jr .pastdmark  
bc80 ..			.dmark: db "DTh"  
bc83 f1			.pastdmark: pop af  
bc84			endm  
# End of macro DMARK
bc84				CALLMONITOR 
bc84 cd 72 ee			call debug_vector  
bc87				endm  
# End of macro CALLMONITOR
bc87			endif	 
bc87			 
bc87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc87 cd f8 9d			call macro_forth_dsp_pop 
bc8a				endm 
# End of macro FORTH_DSP_POP
bc8a			 
bc8a			if DEBUG_FORTH_DOT 
bc8a				DMARK "DTi" 
bc8a f5				push af  
bc8b 3a 9f bc			ld a, (.dmark)  
bc8e 32 6e ee			ld (debug_mark),a  
bc91 3a a0 bc			ld a, (.dmark+1)  
bc94 32 6f ee			ld (debug_mark+1),a  
bc97 3a a1 bc			ld a, (.dmark+2)  
bc9a 32 70 ee			ld (debug_mark+2),a  
bc9d 18 03			jr .pastdmark  
bc9f ..			.dmark: db "DTi"  
bca2 f1			.pastdmark: pop af  
bca3			endm  
# End of macro DMARK
bca3				CALLMONITOR 
bca3 cd 72 ee			call debug_vector  
bca6				endm  
# End of macro CALLMONITOR
bca6			endif	 
bca6			 
bca6			 
bca6					NEXTW 
bca6 c3 f6 9e			jp macro_next 
bca9				endm 
# End of macro NEXTW
bca9			 
bca9			.CLS: 
bca9				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bca9 35				db WORD_SYS_CORE+33             
bcaa d6 bc			dw .DRAW            
bcac 04				db 3 + 1 
bcad .. 00			db "CLS",0              
bcb1				endm 
# End of macro CWHEAD
bcb1			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bcb1					if DEBUG_FORTH_WORDS_KEY 
bcb1						DMARK "CLS" 
bcb1 f5				push af  
bcb2 3a c6 bc			ld a, (.dmark)  
bcb5 32 6e ee			ld (debug_mark),a  
bcb8 3a c7 bc			ld a, (.dmark+1)  
bcbb 32 6f ee			ld (debug_mark+1),a  
bcbe 3a c8 bc			ld a, (.dmark+2)  
bcc1 32 70 ee			ld (debug_mark+2),a  
bcc4 18 03			jr .pastdmark  
bcc6 ..			.dmark: db "CLS"  
bcc9 f1			.pastdmark: pop af  
bcca			endm  
# End of macro DMARK
bcca						CALLMONITOR 
bcca cd 72 ee			call debug_vector  
bccd				endm  
# End of macro CALLMONITOR
bccd					endif 
bccd cd af 8a				call clear_display 
bcd0 c3 e4 bd				jp .home		; and home cursor 
bcd3					NEXTW 
bcd3 c3 f6 9e			jp macro_next 
bcd6				endm 
# End of macro NEXTW
bcd6			 
bcd6			.DRAW: 
bcd6				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bcd6 36				db WORD_SYS_CORE+34             
bcd7 01 bd			dw .DUMP            
bcd9 05				db 4 + 1 
bcda .. 00			db "DRAW",0              
bcdf				endm 
# End of macro CWHEAD
bcdf			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bcdf					if DEBUG_FORTH_WORDS_KEY 
bcdf						DMARK "DRW" 
bcdf f5				push af  
bce0 3a f4 bc			ld a, (.dmark)  
bce3 32 6e ee			ld (debug_mark),a  
bce6 3a f5 bc			ld a, (.dmark+1)  
bce9 32 6f ee			ld (debug_mark+1),a  
bcec 3a f6 bc			ld a, (.dmark+2)  
bcef 32 70 ee			ld (debug_mark+2),a  
bcf2 18 03			jr .pastdmark  
bcf4 ..			.dmark: db "DRW"  
bcf7 f1			.pastdmark: pop af  
bcf8			endm  
# End of macro DMARK
bcf8						CALLMONITOR 
bcf8 cd 72 ee			call debug_vector  
bcfb				endm  
# End of macro CALLMONITOR
bcfb					endif 
bcfb cd d2 8a				call update_display 
bcfe					NEXTW 
bcfe c3 f6 9e			jp macro_next 
bd01				endm 
# End of macro NEXTW
bd01			 
bd01			.DUMP: 
bd01				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd01 37				db WORD_SYS_CORE+35             
bd02 39 bd			dw .CDUMP            
bd04 05				db 4 + 1 
bd05 .. 00			db "DUMP",0              
bd0a				endm 
# End of macro CWHEAD
bd0a			; | DUMP ( x -- ) With address x display dump   | DONE 
bd0a			; TODO pop address to use off of the stack 
bd0a					if DEBUG_FORTH_WORDS_KEY 
bd0a						DMARK "DUM" 
bd0a f5				push af  
bd0b 3a 1f bd			ld a, (.dmark)  
bd0e 32 6e ee			ld (debug_mark),a  
bd11 3a 20 bd			ld a, (.dmark+1)  
bd14 32 6f ee			ld (debug_mark+1),a  
bd17 3a 21 bd			ld a, (.dmark+2)  
bd1a 32 70 ee			ld (debug_mark+2),a  
bd1d 18 03			jr .pastdmark  
bd1f ..			.dmark: db "DUM"  
bd22 f1			.pastdmark: pop af  
bd23			endm  
# End of macro DMARK
bd23						CALLMONITOR 
bd23 cd 72 ee			call debug_vector  
bd26				endm  
# End of macro CALLMONITOR
bd26					endif 
bd26 cd af 8a				call clear_display 
bd29			 
bd29					; get address 
bd29			 
bd29					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd29 cd 40 9d			call macro_dsp_valuehl 
bd2c				endm 
# End of macro FORTH_DSP_VALUEHL
bd2c				 
bd2c					; save it for cdump 
bd2c			 
bd2c 22 e7 e5				ld (os_cur_ptr),hl 
bd2f			 
bd2f					; destroy value TOS 
bd2f			 
bd2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd2f cd f8 9d			call macro_forth_dsp_pop 
bd32				endm 
# End of macro FORTH_DSP_POP
bd32			 
bd32 cd c9 99				call dumpcont	; skip old style of param parsing	 
bd35 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd36					NEXTW 
bd36 c3 f6 9e			jp macro_next 
bd39				endm 
# End of macro NEXTW
bd39			.CDUMP: 
bd39				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd39 38				db WORD_SYS_CORE+36             
bd3a 69 bd			dw .DAT            
bd3c 06				db 5 + 1 
bd3d .. 00			db "CDUMP",0              
bd43				endm 
# End of macro CWHEAD
bd43			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd43					if DEBUG_FORTH_WORDS_KEY 
bd43						DMARK "CDP" 
bd43 f5				push af  
bd44 3a 58 bd			ld a, (.dmark)  
bd47 32 6e ee			ld (debug_mark),a  
bd4a 3a 59 bd			ld a, (.dmark+1)  
bd4d 32 6f ee			ld (debug_mark+1),a  
bd50 3a 5a bd			ld a, (.dmark+2)  
bd53 32 70 ee			ld (debug_mark+2),a  
bd56 18 03			jr .pastdmark  
bd58 ..			.dmark: db "CDP"  
bd5b f1			.pastdmark: pop af  
bd5c			endm  
# End of macro DMARK
bd5c						CALLMONITOR 
bd5c cd 72 ee			call debug_vector  
bd5f				endm  
# End of macro CALLMONITOR
bd5f					endif 
bd5f cd af 8a				call clear_display 
bd62 cd c9 99				call dumpcont	 
bd65 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd66					NEXTW 
bd66 c3 f6 9e			jp macro_next 
bd69				endm 
# End of macro NEXTW
bd69			 
bd69			 
bd69			 
bd69			 
bd69			.DAT: 
bd69				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd69 3d				db WORD_SYS_CORE+41             
bd6a bf bd			dw .HOME            
bd6c 03				db 2 + 1 
bd6d .. 00			db "AT",0              
bd70				endm 
# End of macro CWHEAD
bd70			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd70					if DEBUG_FORTH_WORDS_KEY 
bd70						DMARK "AT." 
bd70 f5				push af  
bd71 3a 85 bd			ld a, (.dmark)  
bd74 32 6e ee			ld (debug_mark),a  
bd77 3a 86 bd			ld a, (.dmark+1)  
bd7a 32 6f ee			ld (debug_mark+1),a  
bd7d 3a 87 bd			ld a, (.dmark+2)  
bd80 32 70 ee			ld (debug_mark+2),a  
bd83 18 03			jr .pastdmark  
bd85 ..			.dmark: db "AT."  
bd88 f1			.pastdmark: pop af  
bd89			endm  
# End of macro DMARK
bd89						CALLMONITOR 
bd89 cd 72 ee			call debug_vector  
bd8c				endm  
# End of macro CALLMONITOR
bd8c					endif 
bd8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd8c cd 40 9d			call macro_dsp_valuehl 
bd8f				endm 
# End of macro FORTH_DSP_VALUEHL
bd8f			 
bd8f			 
bd8f					; TODO save cursor row 
bd8f 7d					ld a,l 
bd90 fe 02				cp 2 
bd92 20 04				jr nz, .crow3 
bd94 3e 28				ld a, display_row_2 
bd96 18 12				jr .ccol1 
bd98 fe 03		.crow3:		cp 3 
bd9a 20 04				jr nz, .crow4 
bd9c 3e 50				ld a, display_row_3 
bd9e 18 0a				jr .ccol1 
bda0 fe 04		.crow4:		cp 4 
bda2 20 04				jr nz, .crow1 
bda4 3e 78				ld a, display_row_4 
bda6 18 02				jr .ccol1 
bda8 3e 00		.crow1:		ld a,display_row_1 
bdaa f5			.ccol1:		push af			; got row offset 
bdab 6f					ld l,a 
bdac 26 00				ld h,0 
bdae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdae cd f8 9d			call macro_forth_dsp_pop 
bdb1				endm 
# End of macro FORTH_DSP_POP
bdb1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdb1 cd 40 9d			call macro_dsp_valuehl 
bdb4				endm 
# End of macro FORTH_DSP_VALUEHL
bdb4					; TODO save cursor col 
bdb4 f1					pop af 
bdb5 85					add l		; add col offset 
bdb6 32 61 ea				ld (f_cursor_ptr), a 
bdb9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdb9 cd f8 9d			call macro_forth_dsp_pop 
bdbc				endm 
# End of macro FORTH_DSP_POP
bdbc			 
bdbc					; calculate  
bdbc			 
bdbc					NEXTW 
bdbc c3 f6 9e			jp macro_next 
bdbf				endm 
# End of macro NEXTW
bdbf			 
bdbf			 
bdbf			.HOME: 
bdbf				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bdbf 41				db WORD_SYS_CORE+45             
bdc0 ec bd			dw .SPACE            
bdc2 05				db 4 + 1 
bdc3 .. 00			db "HOME",0              
bdc8				endm 
# End of macro CWHEAD
bdc8			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bdc8					if DEBUG_FORTH_WORDS_KEY 
bdc8						DMARK "HOM" 
bdc8 f5				push af  
bdc9 3a dd bd			ld a, (.dmark)  
bdcc 32 6e ee			ld (debug_mark),a  
bdcf 3a de bd			ld a, (.dmark+1)  
bdd2 32 6f ee			ld (debug_mark+1),a  
bdd5 3a df bd			ld a, (.dmark+2)  
bdd8 32 70 ee			ld (debug_mark+2),a  
bddb 18 03			jr .pastdmark  
bddd ..			.dmark: db "HOM"  
bde0 f1			.pastdmark: pop af  
bde1			endm  
# End of macro DMARK
bde1						CALLMONITOR 
bde1 cd 72 ee			call debug_vector  
bde4				endm  
# End of macro CALLMONITOR
bde4					endif 
bde4 3e 00		.home:		ld a, 0		; and home cursor 
bde6 32 61 ea				ld (f_cursor_ptr), a 
bde9					NEXTW 
bde9 c3 f6 9e			jp macro_next 
bdec				endm 
# End of macro NEXTW
bdec			 
bdec			 
bdec			.SPACE: 
bdec				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bdec 46				db WORD_SYS_CORE+50             
bded 22 be			dw .SPACES            
bdef 03				db 2 + 1 
bdf0 .. 00			db "BL",0              
bdf3				endm 
# End of macro CWHEAD
bdf3			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bdf3					if DEBUG_FORTH_WORDS_KEY 
bdf3						DMARK "BL." 
bdf3 f5				push af  
bdf4 3a 08 be			ld a, (.dmark)  
bdf7 32 6e ee			ld (debug_mark),a  
bdfa 3a 09 be			ld a, (.dmark+1)  
bdfd 32 6f ee			ld (debug_mark+1),a  
be00 3a 0a be			ld a, (.dmark+2)  
be03 32 70 ee			ld (debug_mark+2),a  
be06 18 03			jr .pastdmark  
be08 ..			.dmark: db "BL."  
be0b f1			.pastdmark: pop af  
be0c			endm  
# End of macro DMARK
be0c						CALLMONITOR 
be0c cd 72 ee			call debug_vector  
be0f				endm  
# End of macro CALLMONITOR
be0f					endif 
be0f 3e 20				ld a, " " 
be11 32 c4 e2				ld (scratch),a 
be14 3e 00				ld a, 0 
be16 32 c5 e2				ld (scratch+1),a 
be19 21 c4 e2				ld hl, scratch 
be1c cd b7 9b				call forth_push_str 
be1f					 
be1f				       NEXTW 
be1f c3 f6 9e			jp macro_next 
be22				endm 
# End of macro NEXTW
be22			 
be22			;.blstr: db " ", 0 
be22			 
be22			.SPACES: 
be22				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be22 47				db WORD_SYS_CORE+51             
be23 bd be			dw .SCROLL            
be25 07				db 6 + 1 
be26 .. 00			db "SPACES",0              
be2d				endm 
# End of macro CWHEAD
be2d			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be2d					if DEBUG_FORTH_WORDS_KEY 
be2d						DMARK "SPS" 
be2d f5				push af  
be2e 3a 42 be			ld a, (.dmark)  
be31 32 6e ee			ld (debug_mark),a  
be34 3a 43 be			ld a, (.dmark+1)  
be37 32 6f ee			ld (debug_mark+1),a  
be3a 3a 44 be			ld a, (.dmark+2)  
be3d 32 70 ee			ld (debug_mark+2),a  
be40 18 03			jr .pastdmark  
be42 ..			.dmark: db "SPS"  
be45 f1			.pastdmark: pop af  
be46			endm  
# End of macro DMARK
be46						CALLMONITOR 
be46 cd 72 ee			call debug_vector  
be49				endm  
# End of macro CALLMONITOR
be49					endif 
be49			 
be49			 
be49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be49 cd 40 9d			call macro_dsp_valuehl 
be4c				endm 
# End of macro FORTH_DSP_VALUEHL
be4c			 
be4c e5					push hl    ; u 
be4d					if DEBUG_FORTH_WORDS 
be4d						DMARK "SPA" 
be4d f5				push af  
be4e 3a 62 be			ld a, (.dmark)  
be51 32 6e ee			ld (debug_mark),a  
be54 3a 63 be			ld a, (.dmark+1)  
be57 32 6f ee			ld (debug_mark+1),a  
be5a 3a 64 be			ld a, (.dmark+2)  
be5d 32 70 ee			ld (debug_mark+2),a  
be60 18 03			jr .pastdmark  
be62 ..			.dmark: db "SPA"  
be65 f1			.pastdmark: pop af  
be66			endm  
# End of macro DMARK
be66						CALLMONITOR 
be66 cd 72 ee			call debug_vector  
be69				endm  
# End of macro CALLMONITOR
be69					endif 
be69			 
be69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be69 cd f8 9d			call macro_forth_dsp_pop 
be6c				endm 
# End of macro FORTH_DSP_POP
be6c e1					pop hl 
be6d 0e 00				ld c, 0 
be6f 45					ld b, l 
be70 21 c4 e2				ld hl, scratch  
be73			 
be73					if DEBUG_FORTH_WORDS 
be73						DMARK "SP2" 
be73 f5				push af  
be74 3a 88 be			ld a, (.dmark)  
be77 32 6e ee			ld (debug_mark),a  
be7a 3a 89 be			ld a, (.dmark+1)  
be7d 32 6f ee			ld (debug_mark+1),a  
be80 3a 8a be			ld a, (.dmark+2)  
be83 32 70 ee			ld (debug_mark+2),a  
be86 18 03			jr .pastdmark  
be88 ..			.dmark: db "SP2"  
be8b f1			.pastdmark: pop af  
be8c			endm  
# End of macro DMARK
be8c						CALLMONITOR 
be8c cd 72 ee			call debug_vector  
be8f				endm  
# End of macro CALLMONITOR
be8f					endif 
be8f 3e 20				ld a, ' ' 
be91			.spaces1:	 
be91 77					ld (hl),a 
be92 23					inc hl 
be93					 
be93 10 fc				djnz .spaces1 
be95 3e 00				ld a,0 
be97 77					ld (hl),a 
be98 21 c4 e2				ld hl, scratch 
be9b					if DEBUG_FORTH_WORDS 
be9b						DMARK "SP3" 
be9b f5				push af  
be9c 3a b0 be			ld a, (.dmark)  
be9f 32 6e ee			ld (debug_mark),a  
bea2 3a b1 be			ld a, (.dmark+1)  
bea5 32 6f ee			ld (debug_mark+1),a  
bea8 3a b2 be			ld a, (.dmark+2)  
beab 32 70 ee			ld (debug_mark+2),a  
beae 18 03			jr .pastdmark  
beb0 ..			.dmark: db "SP3"  
beb3 f1			.pastdmark: pop af  
beb4			endm  
# End of macro DMARK
beb4						CALLMONITOR 
beb4 cd 72 ee			call debug_vector  
beb7				endm  
# End of macro CALLMONITOR
beb7					endif 
beb7 cd b7 9b				call forth_push_str 
beba			 
beba				       NEXTW 
beba c3 f6 9e			jp macro_next 
bebd				endm 
# End of macro NEXTW
bebd			 
bebd			 
bebd			 
bebd			.SCROLL: 
bebd				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bebd 53				db WORD_SYS_CORE+63             
bebe ea be			dw .SCROLLD            
bec0 07				db 6 + 1 
bec1 .. 00			db "SCROLL",0              
bec8				endm 
# End of macro CWHEAD
bec8			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bec8					if DEBUG_FORTH_WORDS_KEY 
bec8						DMARK "SCR" 
bec8 f5				push af  
bec9 3a dd be			ld a, (.dmark)  
becc 32 6e ee			ld (debug_mark),a  
becf 3a de be			ld a, (.dmark+1)  
bed2 32 6f ee			ld (debug_mark+1),a  
bed5 3a df be			ld a, (.dmark+2)  
bed8 32 70 ee			ld (debug_mark+2),a  
bedb 18 03			jr .pastdmark  
bedd ..			.dmark: db "SCR"  
bee0 f1			.pastdmark: pop af  
bee1			endm  
# End of macro DMARK
bee1						CALLMONITOR 
bee1 cd 72 ee			call debug_vector  
bee4				endm  
# End of macro CALLMONITOR
bee4					endif 
bee4			 
bee4 cd 71 8a			call scroll_up 
bee7			;	call update_display 
bee7			 
bee7					NEXTW 
bee7 c3 f6 9e			jp macro_next 
beea				endm 
# End of macro NEXTW
beea			 
beea			 
beea			 
beea			;		; get dir 
beea			; 
beea			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beea			; 
beea			;		push hl 
beea			; 
beea			;		; destroy value TOS 
beea			; 
beea			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
beea			; 
beea			;		; get count 
beea			; 
beea			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beea			; 
beea			;		push hl 
beea			; 
beea			;		; destroy value TOS 
beea			; 
beea			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
beea			; 
beea			;		; one value on hl get other one back 
beea			; 
beea			;		pop bc    ; count 
beea			; 
beea			;		pop de   ; dir 
beea			; 
beea			; 
beea			;		ld b, c 
beea			; 
beea			;.scrolldir:     push bc 
beea			;		push de 
beea			; 
beea			;		ld a, 0 
beea			;		cp e 
beea			;		jr z, .scrollup  
beea			;		call scroll_down 
beea			;		jr .scrollnext 
beea			;.scrollup:	call scroll_up 
beea			; 
beea			;		 
beea			;.scrollnext: 
beea			;		pop de 
beea			;		pop bc 
beea			;		djnz .scrolldir 
beea			; 
beea			; 
beea			; 
beea			; 
beea			; 
beea			;		NEXTW 
beea			 
beea			.SCROLLD: 
beea				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
beea 53				db WORD_SYS_CORE+63             
beeb 18 bf			dw .ATQ            
beed 08				db 7 + 1 
beee .. 00			db "SCROLLD",0              
bef6				endm 
# End of macro CWHEAD
bef6			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bef6					if DEBUG_FORTH_WORDS_KEY 
bef6						DMARK "SCD" 
bef6 f5				push af  
bef7 3a 0b bf			ld a, (.dmark)  
befa 32 6e ee			ld (debug_mark),a  
befd 3a 0c bf			ld a, (.dmark+1)  
bf00 32 6f ee			ld (debug_mark+1),a  
bf03 3a 0d bf			ld a, (.dmark+2)  
bf06 32 70 ee			ld (debug_mark+2),a  
bf09 18 03			jr .pastdmark  
bf0b ..			.dmark: db "SCD"  
bf0e f1			.pastdmark: pop af  
bf0f			endm  
# End of macro DMARK
bf0f						CALLMONITOR 
bf0f cd 72 ee			call debug_vector  
bf12				endm  
# End of macro CALLMONITOR
bf12					endif 
bf12			 
bf12 cd 95 8a			call scroll_down 
bf15			;	call update_display 
bf15			 
bf15					NEXTW 
bf15 c3 f6 9e			jp macro_next 
bf18				endm 
# End of macro NEXTW
bf18			 
bf18			 
bf18			.ATQ: 
bf18				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf18 62				db WORD_SYS_CORE+78             
bf19 76 bf			dw .AUTODSP            
bf1b 04				db 3 + 1 
bf1c .. 00			db "AT@",0              
bf20				endm 
# End of macro CWHEAD
bf20			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf20					if DEBUG_FORTH_WORDS_KEY 
bf20						DMARK "ATA" 
bf20 f5				push af  
bf21 3a 35 bf			ld a, (.dmark)  
bf24 32 6e ee			ld (debug_mark),a  
bf27 3a 36 bf			ld a, (.dmark+1)  
bf2a 32 6f ee			ld (debug_mark+1),a  
bf2d 3a 37 bf			ld a, (.dmark+2)  
bf30 32 70 ee			ld (debug_mark+2),a  
bf33 18 03			jr .pastdmark  
bf35 ..			.dmark: db "ATA"  
bf38 f1			.pastdmark: pop af  
bf39			endm  
# End of macro DMARK
bf39						CALLMONITOR 
bf39 cd 72 ee			call debug_vector  
bf3c				endm  
# End of macro CALLMONITOR
bf3c					endif 
bf3c			 
bf3c			 
bf3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf3c cd 40 9d			call macro_dsp_valuehl 
bf3f				endm 
# End of macro FORTH_DSP_VALUEHL
bf3f			 
bf3f					; TODO save cursor row 
bf3f 7d					ld a,l 
bf40 fe 02				cp 2 
bf42 20 04				jr nz, .crow3aq 
bf44 3e 28				ld a, display_row_2 
bf46 18 12				jr .ccol1aq 
bf48 fe 03		.crow3aq:		cp 3 
bf4a 20 04				jr nz, .crow4aq 
bf4c 3e 50				ld a, display_row_3 
bf4e 18 0a				jr .ccol1aq 
bf50 fe 04		.crow4aq:		cp 4 
bf52 20 04				jr nz, .crow1aq 
bf54 3e 78				ld a, display_row_4 
bf56 18 02				jr .ccol1aq 
bf58 3e 00		.crow1aq:		ld a,display_row_1 
bf5a f5			.ccol1aq:		push af			; got row offset 
bf5b 6f					ld l,a 
bf5c 26 00				ld h,0 
bf5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf5e cd f8 9d			call macro_forth_dsp_pop 
bf61				endm 
# End of macro FORTH_DSP_POP
bf61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf61 cd 40 9d			call macro_dsp_valuehl 
bf64				endm 
# End of macro FORTH_DSP_VALUEHL
bf64					; TODO save cursor col 
bf64 f1					pop af 
bf65 85					add l		; add col offset 
bf66			 
bf66					; add current frame buffer address 
bf66 2a cf eb				ld hl, (display_fb_active) 
bf69 cd dc 8c				call addatohl 
bf6c			 
bf6c			 
bf6c			 
bf6c			 
bf6c					; get char frame buffer location offset in hl 
bf6c			 
bf6c 7e					ld a,(hl) 
bf6d 26 00				ld h, 0 
bf6f 6f					ld l, a 
bf70			 
bf70 cd 49 9b				call forth_push_numhl 
bf73			 
bf73			 
bf73					NEXTW 
bf73 c3 f6 9e			jp macro_next 
bf76				endm 
# End of macro NEXTW
bf76			 
bf76			.AUTODSP: 
bf76				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bf76 63				db WORD_SYS_CORE+79             
bf77 8c bf			dw .MENU            
bf79 05				db 4 + 1 
bf7a .. 00			db "ADSP",0              
bf7f				endm 
# End of macro CWHEAD
bf7f			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bf7f			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bf7f			 
bf7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf7f cd 40 9d			call macro_dsp_valuehl 
bf82				endm 
# End of macro FORTH_DSP_VALUEHL
bf82			 
bf82			;		push hl 
bf82			 
bf82					; destroy value TOS 
bf82			 
bf82					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf82 cd f8 9d			call macro_forth_dsp_pop 
bf85				endm 
# End of macro FORTH_DSP_POP
bf85			 
bf85			;		pop hl 
bf85			 
bf85 7d					ld a,l 
bf86 32 3f ea				ld (cli_autodisplay), a 
bf89				       NEXTW 
bf89 c3 f6 9e			jp macro_next 
bf8c				endm 
# End of macro NEXTW
bf8c			 
bf8c			.MENU: 
bf8c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bf8c 70				db WORD_SYS_CORE+92             
bf8d 35 c0			dw .ENDDISPLAY            
bf8f 05				db 4 + 1 
bf90 .. 00			db "MENU",0              
bf95				endm 
# End of macro CWHEAD
bf95			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bf95			 
bf95			;		; get number of items on the stack 
bf95			; 
bf95				 
bf95					FORTH_DSP_VALUEHL 
bf95 cd 40 9d			call macro_dsp_valuehl 
bf98				endm 
# End of macro FORTH_DSP_VALUEHL
bf98				 
bf98					if DEBUG_FORTH_WORDS_KEY 
bf98						DMARK "MNU" 
bf98 f5				push af  
bf99 3a ad bf			ld a, (.dmark)  
bf9c 32 6e ee			ld (debug_mark),a  
bf9f 3a ae bf			ld a, (.dmark+1)  
bfa2 32 6f ee			ld (debug_mark+1),a  
bfa5 3a af bf			ld a, (.dmark+2)  
bfa8 32 70 ee			ld (debug_mark+2),a  
bfab 18 03			jr .pastdmark  
bfad ..			.dmark: db "MNU"  
bfb0 f1			.pastdmark: pop af  
bfb1			endm  
# End of macro DMARK
bfb1						CALLMONITOR 
bfb1 cd 72 ee			call debug_vector  
bfb4				endm  
# End of macro CALLMONITOR
bfb4					endif 
bfb4			 
bfb4 45					ld b, l	 
bfb5 05					dec b 
bfb6			 
bfb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb6 cd f8 9d			call macro_forth_dsp_pop 
bfb9				endm 
# End of macro FORTH_DSP_POP
bfb9			 
bfb9			 
bfb9					; go directly through the stack to pluck out the string pointers and build an array 
bfb9			 
bfb9			;		FORTH_DSP 
bfb9			 
bfb9					; hl contains top most stack item 
bfb9				 
bfb9 11 c4 e2				ld de, scratch 
bfbc			 
bfbc			.mbuild: 
bfbc			 
bfbc					FORTH_DSP_VALUEHL 
bfbc cd 40 9d			call macro_dsp_valuehl 
bfbf				endm 
# End of macro FORTH_DSP_VALUEHL
bfbf			 
bfbf					if DEBUG_FORTH_WORDS 
bfbf						DMARK "MN3" 
bfbf f5				push af  
bfc0 3a d4 bf			ld a, (.dmark)  
bfc3 32 6e ee			ld (debug_mark),a  
bfc6 3a d5 bf			ld a, (.dmark+1)  
bfc9 32 6f ee			ld (debug_mark+1),a  
bfcc 3a d6 bf			ld a, (.dmark+2)  
bfcf 32 70 ee			ld (debug_mark+2),a  
bfd2 18 03			jr .pastdmark  
bfd4 ..			.dmark: db "MN3"  
bfd7 f1			.pastdmark: pop af  
bfd8			endm  
# End of macro DMARK
bfd8						CALLMONITOR 
bfd8 cd 72 ee			call debug_vector  
bfdb				endm  
# End of macro CALLMONITOR
bfdb					endif 
bfdb eb					ex de, hl 
bfdc 73					ld (hl), e 
bfdd 23					inc hl 
bfde 72					ld (hl), d 
bfdf 23					inc hl 
bfe0 eb					ex de, hl 
bfe1			 
bfe1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfe1 cd f8 9d			call macro_forth_dsp_pop 
bfe4				endm 
# End of macro FORTH_DSP_POP
bfe4			 
bfe4 10 d6				djnz .mbuild 
bfe6			 
bfe6					; done add term 
bfe6			 
bfe6 eb					ex de, hl 
bfe7 36 00				ld (hl), 0 
bfe9 23					inc hl 
bfea 36 00				ld (hl), 0 
bfec			 
bfec				 
bfec					 
bfec 21 c4 e2				ld hl, scratch 
bfef			 
bfef					if DEBUG_FORTH_WORDS 
bfef						DMARK "MNx" 
bfef f5				push af  
bff0 3a 04 c0			ld a, (.dmark)  
bff3 32 6e ee			ld (debug_mark),a  
bff6 3a 05 c0			ld a, (.dmark+1)  
bff9 32 6f ee			ld (debug_mark+1),a  
bffc 3a 06 c0			ld a, (.dmark+2)  
bfff 32 70 ee			ld (debug_mark+2),a  
c002 18 03			jr .pastdmark  
c004 ..			.dmark: db "MNx"  
c007 f1			.pastdmark: pop af  
c008			endm  
# End of macro DMARK
c008						CALLMONITOR 
c008 cd 72 ee			call debug_vector  
c00b				endm  
# End of macro CALLMONITOR
c00b					endif 
c00b			 
c00b			 
c00b			 
c00b 3e 00				ld a, 0 
c00d cd e0 8a				call menu 
c010			 
c010			 
c010 6f					ld l, a 
c011 26 00				ld h, 0 
c013			 
c013					if DEBUG_FORTH_WORDS 
c013						DMARK "MNr" 
c013 f5				push af  
c014 3a 28 c0			ld a, (.dmark)  
c017 32 6e ee			ld (debug_mark),a  
c01a 3a 29 c0			ld a, (.dmark+1)  
c01d 32 6f ee			ld (debug_mark+1),a  
c020 3a 2a c0			ld a, (.dmark+2)  
c023 32 70 ee			ld (debug_mark+2),a  
c026 18 03			jr .pastdmark  
c028 ..			.dmark: db "MNr"  
c02b f1			.pastdmark: pop af  
c02c			endm  
# End of macro DMARK
c02c						CALLMONITOR 
c02c cd 72 ee			call debug_vector  
c02f				endm  
# End of macro CALLMONITOR
c02f					endif 
c02f			 
c02f cd 49 9b				call forth_push_numhl 
c032			 
c032			 
c032			 
c032			 
c032				       NEXTW 
c032 c3 f6 9e			jp macro_next 
c035				endm 
# End of macro NEXTW
c035			 
c035			 
c035			.ENDDISPLAY: 
c035			 
c035			; eof 
# End of file forth_words_display.asm
c035			include "forth_words_str.asm" 
c035			 
c035			; | ## String Words 
c035			 
c035			.PTR:   
c035			 
c035				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c035 48				db WORD_SYS_CORE+52             
c036 62 c0			dw .STYPE            
c038 04				db 3 + 1 
c039 .. 00			db "PTR",0              
c03d				endm 
# End of macro CWHEAD
c03d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c03d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c03d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c03d			 
c03d					if DEBUG_FORTH_WORDS_KEY 
c03d						DMARK "PTR" 
c03d f5				push af  
c03e 3a 52 c0			ld a, (.dmark)  
c041 32 6e ee			ld (debug_mark),a  
c044 3a 53 c0			ld a, (.dmark+1)  
c047 32 6f ee			ld (debug_mark+1),a  
c04a 3a 54 c0			ld a, (.dmark+2)  
c04d 32 70 ee			ld (debug_mark+2),a  
c050 18 03			jr .pastdmark  
c052 ..			.dmark: db "PTR"  
c055 f1			.pastdmark: pop af  
c056			endm  
# End of macro DMARK
c056						CALLMONITOR 
c056 cd 72 ee			call debug_vector  
c059				endm  
# End of macro CALLMONITOR
c059					endif 
c059					FORTH_DSP_VALUEHL 
c059 cd 40 9d			call macro_dsp_valuehl 
c05c				endm 
# End of macro FORTH_DSP_VALUEHL
c05c cd 49 9b				call forth_push_numhl 
c05f			 
c05f			 
c05f					NEXTW 
c05f c3 f6 9e			jp macro_next 
c062				endm 
# End of macro NEXTW
c062			.STYPE: 
c062				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c062 48				db WORD_SYS_CORE+52             
c063 b1 c0			dw .UPPER            
c065 06				db 5 + 1 
c066 .. 00			db "STYPE",0              
c06c				endm 
# End of macro CWHEAD
c06c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c06c					if DEBUG_FORTH_WORDS_KEY 
c06c						DMARK "STY" 
c06c f5				push af  
c06d 3a 81 c0			ld a, (.dmark)  
c070 32 6e ee			ld (debug_mark),a  
c073 3a 82 c0			ld a, (.dmark+1)  
c076 32 6f ee			ld (debug_mark+1),a  
c079 3a 83 c0			ld a, (.dmark+2)  
c07c 32 70 ee			ld (debug_mark+2),a  
c07f 18 03			jr .pastdmark  
c081 ..			.dmark: db "STY"  
c084 f1			.pastdmark: pop af  
c085			endm  
# End of macro DMARK
c085						CALLMONITOR 
c085 cd 72 ee			call debug_vector  
c088				endm  
# End of macro CALLMONITOR
c088					endif 
c088					FORTH_DSP 
c088 cd 06 9d			call macro_forth_dsp 
c08b				endm 
# End of macro FORTH_DSP
c08b					;v5 FORTH_DSP_VALUE 
c08b			 
c08b 7e					ld a, (hl) 
c08c			 
c08c f5					push af 
c08d			 
c08d			; Dont destroy TOS		FORTH_DSP_POP 
c08d			 
c08d f1					pop af 
c08e			 
c08e fe 01				cp DS_TYPE_STR 
c090 28 09				jr z, .typestr 
c092			 
c092 fe 02				cp DS_TYPE_INUM 
c094 28 0a				jr z, .typeinum 
c096			 
c096 21 af c0				ld hl, .tna 
c099 18 0a				jr .tpush 
c09b			 
c09b 21 ab c0		.typestr:	ld hl, .tstr 
c09e 18 05				jr .tpush 
c0a0 21 ad c0		.typeinum:	ld hl, .tinum 
c0a3 18 00				jr .tpush 
c0a5			 
c0a5			.tpush: 
c0a5			 
c0a5 cd b7 9b				call forth_push_str 
c0a8			 
c0a8					NEXTW 
c0a8 c3 f6 9e			jp macro_next 
c0ab				endm 
# End of macro NEXTW
c0ab .. 00		.tstr:	db "s",0 
c0ad .. 00		.tinum:  db "i",0 
c0af .. 00		.tna:   db "?", 0 
c0b1			 
c0b1			 
c0b1			.UPPER: 
c0b1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0b1 48				db WORD_SYS_CORE+52             
c0b2 ec c0			dw .LOWER            
c0b4 06				db 5 + 1 
c0b5 .. 00			db "UPPER",0              
c0bb				endm 
# End of macro CWHEAD
c0bb			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0bb					if DEBUG_FORTH_WORDS_KEY 
c0bb						DMARK "UPR" 
c0bb f5				push af  
c0bc 3a d0 c0			ld a, (.dmark)  
c0bf 32 6e ee			ld (debug_mark),a  
c0c2 3a d1 c0			ld a, (.dmark+1)  
c0c5 32 6f ee			ld (debug_mark+1),a  
c0c8 3a d2 c0			ld a, (.dmark+2)  
c0cb 32 70 ee			ld (debug_mark+2),a  
c0ce 18 03			jr .pastdmark  
c0d0 ..			.dmark: db "UPR"  
c0d3 f1			.pastdmark: pop af  
c0d4			endm  
# End of macro DMARK
c0d4						CALLMONITOR 
c0d4 cd 72 ee			call debug_vector  
c0d7				endm  
# End of macro CALLMONITOR
c0d7					endif 
c0d7			 
c0d7					FORTH_DSP 
c0d7 cd 06 9d			call macro_forth_dsp 
c0da				endm 
# End of macro FORTH_DSP
c0da					 
c0da			; TODO check is string type 
c0da			 
c0da					FORTH_DSP_VALUEHL 
c0da cd 40 9d			call macro_dsp_valuehl 
c0dd				endm 
# End of macro FORTH_DSP_VALUEHL
c0dd			; get pointer to string in hl 
c0dd			 
c0dd 7e			.toup:		ld a, (hl) 
c0de fe 00				cp 0 
c0e0 28 07				jr z, .toupdone 
c0e2			 
c0e2 cd 49 90				call to_upper 
c0e5			 
c0e5 77					ld (hl), a 
c0e6 23					inc hl 
c0e7 18 f4				jr .toup 
c0e9			 
c0e9					 
c0e9			 
c0e9			 
c0e9			; for each char convert to upper 
c0e9					 
c0e9			.toupdone: 
c0e9			 
c0e9			 
c0e9					NEXTW 
c0e9 c3 f6 9e			jp macro_next 
c0ec				endm 
# End of macro NEXTW
c0ec			.LOWER: 
c0ec				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c0ec 48				db WORD_SYS_CORE+52             
c0ed 27 c1			dw .TCASE            
c0ef 06				db 5 + 1 
c0f0 .. 00			db "LOWER",0              
c0f6				endm 
# End of macro CWHEAD
c0f6			; | LOWER ( s -- s ) Lower case string s  | DONE 
c0f6					if DEBUG_FORTH_WORDS_KEY 
c0f6						DMARK "LWR" 
c0f6 f5				push af  
c0f7 3a 0b c1			ld a, (.dmark)  
c0fa 32 6e ee			ld (debug_mark),a  
c0fd 3a 0c c1			ld a, (.dmark+1)  
c100 32 6f ee			ld (debug_mark+1),a  
c103 3a 0d c1			ld a, (.dmark+2)  
c106 32 70 ee			ld (debug_mark+2),a  
c109 18 03			jr .pastdmark  
c10b ..			.dmark: db "LWR"  
c10e f1			.pastdmark: pop af  
c10f			endm  
# End of macro DMARK
c10f						CALLMONITOR 
c10f cd 72 ee			call debug_vector  
c112				endm  
# End of macro CALLMONITOR
c112					endif 
c112			 
c112					FORTH_DSP 
c112 cd 06 9d			call macro_forth_dsp 
c115				endm 
# End of macro FORTH_DSP
c115					 
c115			; TODO check is string type 
c115			 
c115					FORTH_DSP_VALUEHL 
c115 cd 40 9d			call macro_dsp_valuehl 
c118				endm 
# End of macro FORTH_DSP_VALUEHL
c118			; get pointer to string in hl 
c118			 
c118 7e			.tolow:		ld a, (hl) 
c119 fe 00				cp 0 
c11b 28 07				jr z, .tolowdone 
c11d			 
c11d cd 52 90				call to_lower 
c120			 
c120 77					ld (hl), a 
c121 23					inc hl 
c122 18 f4				jr .tolow 
c124			 
c124					 
c124			 
c124			 
c124			; for each char convert to low 
c124					 
c124			.tolowdone: 
c124					NEXTW 
c124 c3 f6 9e			jp macro_next 
c127				endm 
# End of macro NEXTW
c127			.TCASE: 
c127				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c127 48				db WORD_SYS_CORE+52             
c128 5d c2			dw .SUBSTR            
c12a 06				db 5 + 1 
c12b .. 00			db "TCASE",0              
c131				endm 
# End of macro CWHEAD
c131			; | TCASE ( s -- s ) Title case string s  | DONE 
c131					if DEBUG_FORTH_WORDS_KEY 
c131						DMARK "TCS" 
c131 f5				push af  
c132 3a 46 c1			ld a, (.dmark)  
c135 32 6e ee			ld (debug_mark),a  
c138 3a 47 c1			ld a, (.dmark+1)  
c13b 32 6f ee			ld (debug_mark+1),a  
c13e 3a 48 c1			ld a, (.dmark+2)  
c141 32 70 ee			ld (debug_mark+2),a  
c144 18 03			jr .pastdmark  
c146 ..			.dmark: db "TCS"  
c149 f1			.pastdmark: pop af  
c14a			endm  
# End of macro DMARK
c14a						CALLMONITOR 
c14a cd 72 ee			call debug_vector  
c14d				endm  
# End of macro CALLMONITOR
c14d					endif 
c14d			 
c14d					FORTH_DSP 
c14d cd 06 9d			call macro_forth_dsp 
c150				endm 
# End of macro FORTH_DSP
c150					 
c150			; TODO check is string type 
c150			 
c150					FORTH_DSP_VALUEHL 
c150 cd 40 9d			call macro_dsp_valuehl 
c153				endm 
# End of macro FORTH_DSP_VALUEHL
c153			; get pointer to string in hl 
c153			 
c153					if DEBUG_FORTH_WORDS 
c153						DMARK "TC1" 
c153 f5				push af  
c154 3a 68 c1			ld a, (.dmark)  
c157 32 6e ee			ld (debug_mark),a  
c15a 3a 69 c1			ld a, (.dmark+1)  
c15d 32 6f ee			ld (debug_mark+1),a  
c160 3a 6a c1			ld a, (.dmark+2)  
c163 32 70 ee			ld (debug_mark+2),a  
c166 18 03			jr .pastdmark  
c168 ..			.dmark: db "TC1"  
c16b f1			.pastdmark: pop af  
c16c			endm  
# End of macro DMARK
c16c						CALLMONITOR 
c16c cd 72 ee			call debug_vector  
c16f				endm  
# End of macro CALLMONITOR
c16f					endif 
c16f			 
c16f					; first time in turn to upper case first char 
c16f			 
c16f 7e					ld a, (hl) 
c170 c3 fa c1				jp .totsiptou 
c173			 
c173			 
c173 7e			.tot:		ld a, (hl) 
c174 fe 00				cp 0 
c176 ca 3e c2				jp z, .totdone 
c179			 
c179					if DEBUG_FORTH_WORDS 
c179						DMARK "TC2" 
c179 f5				push af  
c17a 3a 8e c1			ld a, (.dmark)  
c17d 32 6e ee			ld (debug_mark),a  
c180 3a 8f c1			ld a, (.dmark+1)  
c183 32 6f ee			ld (debug_mark+1),a  
c186 3a 90 c1			ld a, (.dmark+2)  
c189 32 70 ee			ld (debug_mark+2),a  
c18c 18 03			jr .pastdmark  
c18e ..			.dmark: db "TC2"  
c191 f1			.pastdmark: pop af  
c192			endm  
# End of macro DMARK
c192						CALLMONITOR 
c192 cd 72 ee			call debug_vector  
c195				endm  
# End of macro CALLMONITOR
c195					endif 
c195					; check to see if current char is a space 
c195			 
c195 fe 20				cp ' ' 
c197 28 21				jr z, .totsp 
c199 cd 52 90				call to_lower 
c19c					if DEBUG_FORTH_WORDS 
c19c						DMARK "TC3" 
c19c f5				push af  
c19d 3a b1 c1			ld a, (.dmark)  
c1a0 32 6e ee			ld (debug_mark),a  
c1a3 3a b2 c1			ld a, (.dmark+1)  
c1a6 32 6f ee			ld (debug_mark+1),a  
c1a9 3a b3 c1			ld a, (.dmark+2)  
c1ac 32 70 ee			ld (debug_mark+2),a  
c1af 18 03			jr .pastdmark  
c1b1 ..			.dmark: db "TC3"  
c1b4 f1			.pastdmark: pop af  
c1b5			endm  
# End of macro DMARK
c1b5						CALLMONITOR 
c1b5 cd 72 ee			call debug_vector  
c1b8				endm  
# End of macro CALLMONITOR
c1b8					endif 
c1b8 18 63				jr .totnxt 
c1ba			 
c1ba			.totsp:         ; on a space, find next char which should be upper 
c1ba			 
c1ba					if DEBUG_FORTH_WORDS 
c1ba						DMARK "TC4" 
c1ba f5				push af  
c1bb 3a cf c1			ld a, (.dmark)  
c1be 32 6e ee			ld (debug_mark),a  
c1c1 3a d0 c1			ld a, (.dmark+1)  
c1c4 32 6f ee			ld (debug_mark+1),a  
c1c7 3a d1 c1			ld a, (.dmark+2)  
c1ca 32 70 ee			ld (debug_mark+2),a  
c1cd 18 03			jr .pastdmark  
c1cf ..			.dmark: db "TC4"  
c1d2 f1			.pastdmark: pop af  
c1d3			endm  
# End of macro DMARK
c1d3						CALLMONITOR 
c1d3 cd 72 ee			call debug_vector  
c1d6				endm  
# End of macro CALLMONITOR
c1d6					endif 
c1d6					;; 
c1d6			 
c1d6 fe 20				cp ' ' 
c1d8 20 20				jr nz, .totsiptou 
c1da 23					inc hl 
c1db 7e					ld a, (hl) 
c1dc					if DEBUG_FORTH_WORDS 
c1dc						DMARK "TC5" 
c1dc f5				push af  
c1dd 3a f1 c1			ld a, (.dmark)  
c1e0 32 6e ee			ld (debug_mark),a  
c1e3 3a f2 c1			ld a, (.dmark+1)  
c1e6 32 6f ee			ld (debug_mark+1),a  
c1e9 3a f3 c1			ld a, (.dmark+2)  
c1ec 32 70 ee			ld (debug_mark+2),a  
c1ef 18 03			jr .pastdmark  
c1f1 ..			.dmark: db "TC5"  
c1f4 f1			.pastdmark: pop af  
c1f5			endm  
# End of macro DMARK
c1f5						CALLMONITOR 
c1f5 cd 72 ee			call debug_vector  
c1f8				endm  
# End of macro CALLMONITOR
c1f8					endif 
c1f8 18 c0				jr .totsp 
c1fa fe 00		.totsiptou:    cp 0 
c1fc 28 40				jr z, .totdone 
c1fe					; not space and not zero term so upper case it 
c1fe cd 49 90				call to_upper 
c201			 
c201					if DEBUG_FORTH_WORDS 
c201						DMARK "TC6" 
c201 f5				push af  
c202 3a 16 c2			ld a, (.dmark)  
c205 32 6e ee			ld (debug_mark),a  
c208 3a 17 c2			ld a, (.dmark+1)  
c20b 32 6f ee			ld (debug_mark+1),a  
c20e 3a 18 c2			ld a, (.dmark+2)  
c211 32 70 ee			ld (debug_mark+2),a  
c214 18 03			jr .pastdmark  
c216 ..			.dmark: db "TC6"  
c219 f1			.pastdmark: pop af  
c21a			endm  
# End of macro DMARK
c21a						CALLMONITOR 
c21a cd 72 ee			call debug_vector  
c21d				endm  
# End of macro CALLMONITOR
c21d					endif 
c21d			 
c21d			 
c21d			.totnxt: 
c21d			 
c21d 77					ld (hl), a 
c21e 23					inc hl 
c21f					if DEBUG_FORTH_WORDS 
c21f						DMARK "TC7" 
c21f f5				push af  
c220 3a 34 c2			ld a, (.dmark)  
c223 32 6e ee			ld (debug_mark),a  
c226 3a 35 c2			ld a, (.dmark+1)  
c229 32 6f ee			ld (debug_mark+1),a  
c22c 3a 36 c2			ld a, (.dmark+2)  
c22f 32 70 ee			ld (debug_mark+2),a  
c232 18 03			jr .pastdmark  
c234 ..			.dmark: db "TC7"  
c237 f1			.pastdmark: pop af  
c238			endm  
# End of macro DMARK
c238						CALLMONITOR 
c238 cd 72 ee			call debug_vector  
c23b				endm  
# End of macro CALLMONITOR
c23b					endif 
c23b c3 73 c1				jp .tot 
c23e			 
c23e					 
c23e			 
c23e			 
c23e			; for each char convert to low 
c23e					 
c23e			.totdone: 
c23e					if DEBUG_FORTH_WORDS 
c23e						DMARK "TCd" 
c23e f5				push af  
c23f 3a 53 c2			ld a, (.dmark)  
c242 32 6e ee			ld (debug_mark),a  
c245 3a 54 c2			ld a, (.dmark+1)  
c248 32 6f ee			ld (debug_mark+1),a  
c24b 3a 55 c2			ld a, (.dmark+2)  
c24e 32 70 ee			ld (debug_mark+2),a  
c251 18 03			jr .pastdmark  
c253 ..			.dmark: db "TCd"  
c256 f1			.pastdmark: pop af  
c257			endm  
# End of macro DMARK
c257						CALLMONITOR 
c257 cd 72 ee			call debug_vector  
c25a				endm  
# End of macro CALLMONITOR
c25a					endif 
c25a					NEXTW 
c25a c3 f6 9e			jp macro_next 
c25d				endm 
# End of macro NEXTW
c25d			 
c25d			.SUBSTR: 
c25d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c25d 48				db WORD_SYS_CORE+52             
c25e bb c2			dw .LEFT            
c260 07				db 6 + 1 
c261 .. 00			db "SUBSTR",0              
c268				endm 
# End of macro CWHEAD
c268			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c268			 
c268					if DEBUG_FORTH_WORDS_KEY 
c268						DMARK "SST" 
c268 f5				push af  
c269 3a 7d c2			ld a, (.dmark)  
c26c 32 6e ee			ld (debug_mark),a  
c26f 3a 7e c2			ld a, (.dmark+1)  
c272 32 6f ee			ld (debug_mark+1),a  
c275 3a 7f c2			ld a, (.dmark+2)  
c278 32 70 ee			ld (debug_mark+2),a  
c27b 18 03			jr .pastdmark  
c27d ..			.dmark: db "SST"  
c280 f1			.pastdmark: pop af  
c281			endm  
# End of macro DMARK
c281						CALLMONITOR 
c281 cd 72 ee			call debug_vector  
c284				endm  
# End of macro CALLMONITOR
c284					endif 
c284			; TODO check string type 
c284					FORTH_DSP_VALUEHL 
c284 cd 40 9d			call macro_dsp_valuehl 
c287				endm 
# End of macro FORTH_DSP_VALUEHL
c287			 
c287 e5					push hl      ; string length 
c288			 
c288					FORTH_DSP_POP 
c288 cd f8 9d			call macro_forth_dsp_pop 
c28b				endm 
# End of macro FORTH_DSP_POP
c28b			 
c28b					FORTH_DSP_VALUEHL 
c28b cd 40 9d			call macro_dsp_valuehl 
c28e				endm 
# End of macro FORTH_DSP_VALUEHL
c28e			 
c28e e5					push hl     ; start char 
c28f			 
c28f					FORTH_DSP_POP 
c28f cd f8 9d			call macro_forth_dsp_pop 
c292				endm 
# End of macro FORTH_DSP_POP
c292			 
c292			 
c292					FORTH_DSP_VALUE 
c292 cd 29 9d			call macro_forth_dsp_value 
c295				endm 
# End of macro FORTH_DSP_VALUE
c295			 
c295 d1					pop de    ; get start post offset 
c296			 
c296 19					add hl, de    ; starting offset 
c297			 
c297 c1					pop bc 
c298 c5					push bc      ; grab size of string 
c299			 
c299 e5					push hl    ; save string start  
c29a			 
c29a 26 00				ld h, 0 
c29c 69					ld l, c 
c29d 23					inc hl 
c29e 23					inc hl 
c29f			 
c29f cd a3 91				call malloc 
c2a2				if DEBUG_FORTH_MALLOC_GUARD 
c2a2 cc 03 cc				call z,malloc_error 
c2a5				endif 
c2a5			 
c2a5 eb					ex de, hl      ; save malloc area for string copy 
c2a6 e1					pop hl    ; get back source 
c2a7 c1					pop bc    ; get length of string back 
c2a8			 
c2a8 d5					push de    ; save malloc area for after we push 
c2a9 ed b0				ldir     ; copy substr 
c2ab			 
c2ab			 
c2ab eb					ex de, hl 
c2ac 3e 00				ld a, 0 
c2ae 77					ld (hl), a   ; term substr 
c2af			 
c2af					 
c2af e1					pop hl    ; get malloc so we can push it 
c2b0 e5					push hl   ; save so we can free it afterwards 
c2b1			 
c2b1 cd b7 9b				call forth_push_str 
c2b4			 
c2b4 e1					pop hl 
c2b5 cd 6d 92				call free 
c2b8			 
c2b8					 
c2b8					 
c2b8			 
c2b8			 
c2b8					NEXTW 
c2b8 c3 f6 9e			jp macro_next 
c2bb				endm 
# End of macro NEXTW
c2bb			 
c2bb			.LEFT: 
c2bb				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2bb 48				db WORD_SYS_CORE+52             
c2bc e3 c2			dw .RIGHT            
c2be 05				db 4 + 1 
c2bf .. 00			db "LEFT",0              
c2c4				endm 
# End of macro CWHEAD
c2c4			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2c4					if DEBUG_FORTH_WORDS_KEY 
c2c4						DMARK "LEF" 
c2c4 f5				push af  
c2c5 3a d9 c2			ld a, (.dmark)  
c2c8 32 6e ee			ld (debug_mark),a  
c2cb 3a da c2			ld a, (.dmark+1)  
c2ce 32 6f ee			ld (debug_mark+1),a  
c2d1 3a db c2			ld a, (.dmark+2)  
c2d4 32 70 ee			ld (debug_mark+2),a  
c2d7 18 03			jr .pastdmark  
c2d9 ..			.dmark: db "LEF"  
c2dc f1			.pastdmark: pop af  
c2dd			endm  
# End of macro DMARK
c2dd						CALLMONITOR 
c2dd cd 72 ee			call debug_vector  
c2e0				endm  
# End of macro CALLMONITOR
c2e0					endif 
c2e0			 
c2e0					NEXTW 
c2e0 c3 f6 9e			jp macro_next 
c2e3				endm 
# End of macro NEXTW
c2e3			.RIGHT: 
c2e3				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c2e3 48				db WORD_SYS_CORE+52             
c2e4 0c c3			dw .STR2NUM            
c2e6 06				db 5 + 1 
c2e7 .. 00			db "RIGHT",0              
c2ed				endm 
# End of macro CWHEAD
c2ed			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c2ed					if DEBUG_FORTH_WORDS_KEY 
c2ed						DMARK "RIG" 
c2ed f5				push af  
c2ee 3a 02 c3			ld a, (.dmark)  
c2f1 32 6e ee			ld (debug_mark),a  
c2f4 3a 03 c3			ld a, (.dmark+1)  
c2f7 32 6f ee			ld (debug_mark+1),a  
c2fa 3a 04 c3			ld a, (.dmark+2)  
c2fd 32 70 ee			ld (debug_mark+2),a  
c300 18 03			jr .pastdmark  
c302 ..			.dmark: db "RIG"  
c305 f1			.pastdmark: pop af  
c306			endm  
# End of macro DMARK
c306						CALLMONITOR 
c306 cd 72 ee			call debug_vector  
c309				endm  
# End of macro CALLMONITOR
c309					endif 
c309			 
c309					NEXTW 
c309 c3 f6 9e			jp macro_next 
c30c				endm 
# End of macro NEXTW
c30c			 
c30c			 
c30c			.STR2NUM: 
c30c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c30c 48				db WORD_SYS_CORE+52             
c30d 98 c3			dw .NUM2STR            
c30f 08				db 7 + 1 
c310 .. 00			db "STR2NUM",0              
c318				endm 
# End of macro CWHEAD
c318			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c318			 
c318			 
c318			; TODO STR type check to do 
c318					if DEBUG_FORTH_WORDS_KEY 
c318						DMARK "S2N" 
c318 f5				push af  
c319 3a 2d c3			ld a, (.dmark)  
c31c 32 6e ee			ld (debug_mark),a  
c31f 3a 2e c3			ld a, (.dmark+1)  
c322 32 6f ee			ld (debug_mark+1),a  
c325 3a 2f c3			ld a, (.dmark+2)  
c328 32 70 ee			ld (debug_mark+2),a  
c32b 18 03			jr .pastdmark  
c32d ..			.dmark: db "S2N"  
c330 f1			.pastdmark: pop af  
c331			endm  
# End of macro DMARK
c331						CALLMONITOR 
c331 cd 72 ee			call debug_vector  
c334				endm  
# End of macro CALLMONITOR
c334					endif 
c334			 
c334					;FORTH_DSP 
c334					FORTH_DSP_VALUE 
c334 cd 29 9d			call macro_forth_dsp_value 
c337				endm 
# End of macro FORTH_DSP_VALUE
c337					;inc hl 
c337			 
c337 eb					ex de, hl 
c338					if DEBUG_FORTH_WORDS 
c338						DMARK "S2a" 
c338 f5				push af  
c339 3a 4d c3			ld a, (.dmark)  
c33c 32 6e ee			ld (debug_mark),a  
c33f 3a 4e c3			ld a, (.dmark+1)  
c342 32 6f ee			ld (debug_mark+1),a  
c345 3a 4f c3			ld a, (.dmark+2)  
c348 32 70 ee			ld (debug_mark+2),a  
c34b 18 03			jr .pastdmark  
c34d ..			.dmark: db "S2a"  
c350 f1			.pastdmark: pop af  
c351			endm  
# End of macro DMARK
c351						CALLMONITOR 
c351 cd 72 ee			call debug_vector  
c354				endm  
# End of macro CALLMONITOR
c354					endif 
c354 cd d1 90				call string_to_uint16 
c357			 
c357					if DEBUG_FORTH_WORDS 
c357						DMARK "S2b" 
c357 f5				push af  
c358 3a 6c c3			ld a, (.dmark)  
c35b 32 6e ee			ld (debug_mark),a  
c35e 3a 6d c3			ld a, (.dmark+1)  
c361 32 6f ee			ld (debug_mark+1),a  
c364 3a 6e c3			ld a, (.dmark+2)  
c367 32 70 ee			ld (debug_mark+2),a  
c36a 18 03			jr .pastdmark  
c36c ..			.dmark: db "S2b"  
c36f f1			.pastdmark: pop af  
c370			endm  
# End of macro DMARK
c370						CALLMONITOR 
c370 cd 72 ee			call debug_vector  
c373				endm  
# End of macro CALLMONITOR
c373					endif 
c373			;		push hl 
c373					FORTH_DSP_POP 
c373 cd f8 9d			call macro_forth_dsp_pop 
c376				endm 
# End of macro FORTH_DSP_POP
c376			;		pop hl 
c376					 
c376					if DEBUG_FORTH_WORDS 
c376						DMARK "S2b" 
c376 f5				push af  
c377 3a 8b c3			ld a, (.dmark)  
c37a 32 6e ee			ld (debug_mark),a  
c37d 3a 8c c3			ld a, (.dmark+1)  
c380 32 6f ee			ld (debug_mark+1),a  
c383 3a 8d c3			ld a, (.dmark+2)  
c386 32 70 ee			ld (debug_mark+2),a  
c389 18 03			jr .pastdmark  
c38b ..			.dmark: db "S2b"  
c38e f1			.pastdmark: pop af  
c38f			endm  
# End of macro DMARK
c38f						CALLMONITOR 
c38f cd 72 ee			call debug_vector  
c392				endm  
# End of macro CALLMONITOR
c392					endif 
c392 cd 49 9b				call forth_push_numhl	 
c395			 
c395				 
c395				       NEXTW 
c395 c3 f6 9e			jp macro_next 
c398				endm 
# End of macro NEXTW
c398			.NUM2STR: 
c398				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c398 48				db WORD_SYS_CORE+52             
c399 a7 c3			dw .CONCAT            
c39b 08				db 7 + 1 
c39c .. 00			db "NUM2STR",0              
c3a4				endm 
# End of macro CWHEAD
c3a4			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c3a4			 
c3a4			;		; malloc a string to target 
c3a4			;		ld hl, 10     ; TODO max string size should be fine 
c3a4			;		call malloc 
c3a4			;		push hl    ; save malloc location 
c3a4			; 
c3a4			; 
c3a4			;; TODO check int type 
c3a4			;		FORTH_DSP_VALUEHL 
c3a4			;		ld a, l 
c3a4			;		call DispAToASCII   
c3a4			;;TODO need to chage above call to dump into string 
c3a4			; 
c3a4			; 
c3a4			 
c3a4				       NEXTW 
c3a4 c3 f6 9e			jp macro_next 
c3a7				endm 
# End of macro NEXTW
c3a7			 
c3a7			.CONCAT: 
c3a7				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3a7 48				db WORD_SYS_CORE+52             
c3a8 5a c4			dw .FIND            
c3aa 07				db 6 + 1 
c3ab .. 00			db "CONCAT",0              
c3b2				endm 
# End of macro CWHEAD
c3b2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3b2			 
c3b2			; TODO check string type 
c3b2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3b2			 
c3b2					if DEBUG_FORTH_WORDS_KEY 
c3b2						DMARK "CON" 
c3b2 f5				push af  
c3b3 3a c7 c3			ld a, (.dmark)  
c3b6 32 6e ee			ld (debug_mark),a  
c3b9 3a c8 c3			ld a, (.dmark+1)  
c3bc 32 6f ee			ld (debug_mark+1),a  
c3bf 3a c9 c3			ld a, (.dmark+2)  
c3c2 32 70 ee			ld (debug_mark+2),a  
c3c5 18 03			jr .pastdmark  
c3c7 ..			.dmark: db "CON"  
c3ca f1			.pastdmark: pop af  
c3cb			endm  
# End of macro DMARK
c3cb						CALLMONITOR 
c3cb cd 72 ee			call debug_vector  
c3ce				endm  
# End of macro CALLMONITOR
c3ce					endif 
c3ce			 
c3ce			 
c3ce					FORTH_DSP_VALUE 
c3ce cd 29 9d			call macro_forth_dsp_value 
c3d1				endm 
# End of macro FORTH_DSP_VALUE
c3d1 e5					push hl   ; s2 
c3d2			 
c3d2					FORTH_DSP_POP 
c3d2 cd f8 9d			call macro_forth_dsp_pop 
c3d5				endm 
# End of macro FORTH_DSP_POP
c3d5			 
c3d5					FORTH_DSP_VALUE 
c3d5 cd 29 9d			call macro_forth_dsp_value 
c3d8				endm 
# End of macro FORTH_DSP_VALUE
c3d8			 
c3d8 e5					push hl   ; s1 
c3d9			 
c3d9					FORTH_DSP_POP 
c3d9 cd f8 9d			call macro_forth_dsp_pop 
c3dc				endm 
# End of macro FORTH_DSP_POP
c3dc					 
c3dc			 
c3dc					; copy s1 
c3dc			 
c3dc				 
c3dc					; save ptr 
c3dc e1					pop hl  
c3dd e5					push hl 
c3de 3e 00				ld a, 0 
c3e0 cd 45 91				call strlent 
c3e3					;inc hl    ; zer0 
c3e3 06 00				ld b, 0 
c3e5 4d					ld c, l 
c3e6 e1					pop hl		 
c3e7 11 c4 e2				ld de, scratch	 
c3ea					if DEBUG_FORTH_WORDS 
c3ea						DMARK "CO1" 
c3ea f5				push af  
c3eb 3a ff c3			ld a, (.dmark)  
c3ee 32 6e ee			ld (debug_mark),a  
c3f1 3a 00 c4			ld a, (.dmark+1)  
c3f4 32 6f ee			ld (debug_mark+1),a  
c3f7 3a 01 c4			ld a, (.dmark+2)  
c3fa 32 70 ee			ld (debug_mark+2),a  
c3fd 18 03			jr .pastdmark  
c3ff ..			.dmark: db "CO1"  
c402 f1			.pastdmark: pop af  
c403			endm  
# End of macro DMARK
c403						CALLMONITOR 
c403 cd 72 ee			call debug_vector  
c406				endm  
# End of macro CALLMONITOR
c406					endif 
c406 ed b0				ldir 
c408			 
c408 e1					pop hl 
c409 e5					push hl 
c40a d5					push de 
c40b			 
c40b			 
c40b 3e 00				ld a, 0 
c40d cd 45 91				call strlent 
c410 23					inc hl    ; zer0 
c411 23					inc hl 
c412 06 00				ld b, 0 
c414 4d					ld c, l 
c415 d1					pop de 
c416 e1					pop hl		 
c417					if DEBUG_FORTH_WORDS 
c417						DMARK "CO2" 
c417 f5				push af  
c418 3a 2c c4			ld a, (.dmark)  
c41b 32 6e ee			ld (debug_mark),a  
c41e 3a 2d c4			ld a, (.dmark+1)  
c421 32 6f ee			ld (debug_mark+1),a  
c424 3a 2e c4			ld a, (.dmark+2)  
c427 32 70 ee			ld (debug_mark+2),a  
c42a 18 03			jr .pastdmark  
c42c ..			.dmark: db "CO2"  
c42f f1			.pastdmark: pop af  
c430			endm  
# End of macro DMARK
c430						CALLMONITOR 
c430 cd 72 ee			call debug_vector  
c433				endm  
# End of macro CALLMONITOR
c433					endif 
c433 ed b0				ldir 
c435			 
c435			 
c435			 
c435 21 c4 e2				ld hl, scratch 
c438					if DEBUG_FORTH_WORDS 
c438						DMARK "CO5" 
c438 f5				push af  
c439 3a 4d c4			ld a, (.dmark)  
c43c 32 6e ee			ld (debug_mark),a  
c43f 3a 4e c4			ld a, (.dmark+1)  
c442 32 6f ee			ld (debug_mark+1),a  
c445 3a 4f c4			ld a, (.dmark+2)  
c448 32 70 ee			ld (debug_mark+2),a  
c44b 18 03			jr .pastdmark  
c44d ..			.dmark: db "CO5"  
c450 f1			.pastdmark: pop af  
c451			endm  
# End of macro DMARK
c451						CALLMONITOR 
c451 cd 72 ee			call debug_vector  
c454				endm  
# End of macro CALLMONITOR
c454					endif 
c454			 
c454 cd b7 9b				call forth_push_str 
c457			 
c457			 
c457			 
c457			 
c457				       NEXTW 
c457 c3 f6 9e			jp macro_next 
c45a				endm 
# End of macro NEXTW
c45a			 
c45a			 
c45a			.FIND: 
c45a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c45a 4b				db WORD_SYS_CORE+55             
c45b 18 c5			dw .LEN            
c45d 05				db 4 + 1 
c45e .. 00			db "FIND",0              
c463				endm 
# End of macro CWHEAD
c463			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c463			 
c463					if DEBUG_FORTH_WORDS_KEY 
c463						DMARK "FND" 
c463 f5				push af  
c464 3a 78 c4			ld a, (.dmark)  
c467 32 6e ee			ld (debug_mark),a  
c46a 3a 79 c4			ld a, (.dmark+1)  
c46d 32 6f ee			ld (debug_mark+1),a  
c470 3a 7a c4			ld a, (.dmark+2)  
c473 32 70 ee			ld (debug_mark+2),a  
c476 18 03			jr .pastdmark  
c478 ..			.dmark: db "FND"  
c47b f1			.pastdmark: pop af  
c47c			endm  
# End of macro DMARK
c47c						CALLMONITOR 
c47c cd 72 ee			call debug_vector  
c47f				endm  
# End of macro CALLMONITOR
c47f					endif 
c47f			 
c47f			; TODO check string type 
c47f					FORTH_DSP_VALUE 
c47f cd 29 9d			call macro_forth_dsp_value 
c482				endm 
# End of macro FORTH_DSP_VALUE
c482			 
c482 e5					push hl    
c483 7e					ld a,(hl)    ; char to find   
c484			; TODO change char to substr 
c484			 
c484 f5					push af 
c485					 
c485			 
c485			 
c485					if DEBUG_FORTH_WORDS 
c485						DMARK "FN1" 
c485 f5				push af  
c486 3a 9a c4			ld a, (.dmark)  
c489 32 6e ee			ld (debug_mark),a  
c48c 3a 9b c4			ld a, (.dmark+1)  
c48f 32 6f ee			ld (debug_mark+1),a  
c492 3a 9c c4			ld a, (.dmark+2)  
c495 32 70 ee			ld (debug_mark+2),a  
c498 18 03			jr .pastdmark  
c49a ..			.dmark: db "FN1"  
c49d f1			.pastdmark: pop af  
c49e			endm  
# End of macro DMARK
c49e						CALLMONITOR 
c49e cd 72 ee			call debug_vector  
c4a1				endm  
# End of macro CALLMONITOR
c4a1					endif 
c4a1			 
c4a1					FORTH_DSP_POP 
c4a1 cd f8 9d			call macro_forth_dsp_pop 
c4a4				endm 
# End of macro FORTH_DSP_POP
c4a4			 
c4a4					; string to search 
c4a4			 
c4a4					FORTH_DSP_VALUE 
c4a4 cd 29 9d			call macro_forth_dsp_value 
c4a7				endm 
# End of macro FORTH_DSP_VALUE
c4a7			 
c4a7 d1					pop de  ; d is char to find  
c4a8			 
c4a8					if DEBUG_FORTH_WORDS 
c4a8						DMARK "FN2" 
c4a8 f5				push af  
c4a9 3a bd c4			ld a, (.dmark)  
c4ac 32 6e ee			ld (debug_mark),a  
c4af 3a be c4			ld a, (.dmark+1)  
c4b2 32 6f ee			ld (debug_mark+1),a  
c4b5 3a bf c4			ld a, (.dmark+2)  
c4b8 32 70 ee			ld (debug_mark+2),a  
c4bb 18 03			jr .pastdmark  
c4bd ..			.dmark: db "FN2"  
c4c0 f1			.pastdmark: pop af  
c4c1			endm  
# End of macro DMARK
c4c1						CALLMONITOR 
c4c1 cd 72 ee			call debug_vector  
c4c4				endm  
# End of macro CALLMONITOR
c4c4					endif 
c4c4					 
c4c4 01 00 00				ld bc, 0 
c4c7 7e			.findchar:      ld a,(hl) 
c4c8 fe 00				cp 0   		 
c4ca 28 27				jr z, .finddone     
c4cc ba					cp d 
c4cd 28 20				jr z, .foundchar 
c4cf 03					inc bc 
c4d0 23					inc hl 
c4d1					if DEBUG_FORTH_WORDS 
c4d1						DMARK "FN3" 
c4d1 f5				push af  
c4d2 3a e6 c4			ld a, (.dmark)  
c4d5 32 6e ee			ld (debug_mark),a  
c4d8 3a e7 c4			ld a, (.dmark+1)  
c4db 32 6f ee			ld (debug_mark+1),a  
c4de 3a e8 c4			ld a, (.dmark+2)  
c4e1 32 70 ee			ld (debug_mark+2),a  
c4e4 18 03			jr .pastdmark  
c4e6 ..			.dmark: db "FN3"  
c4e9 f1			.pastdmark: pop af  
c4ea			endm  
# End of macro DMARK
c4ea						CALLMONITOR 
c4ea cd 72 ee			call debug_vector  
c4ed				endm  
# End of macro CALLMONITOR
c4ed					endif 
c4ed 18 d8				jr .findchar 
c4ef			 
c4ef			 
c4ef c5			.foundchar:	push bc 
c4f0 e1					pop hl 
c4f1 18 03				jr .findexit 
c4f3			 
c4f3			 
c4f3							 
c4f3			 
c4f3			.finddone:     ; got to end of string with no find 
c4f3 21 00 00				ld hl, 0 
c4f6			.findexit: 
c4f6			 
c4f6					if DEBUG_FORTH_WORDS 
c4f6						DMARK "FNd" 
c4f6 f5				push af  
c4f7 3a 0b c5			ld a, (.dmark)  
c4fa 32 6e ee			ld (debug_mark),a  
c4fd 3a 0c c5			ld a, (.dmark+1)  
c500 32 6f ee			ld (debug_mark+1),a  
c503 3a 0d c5			ld a, (.dmark+2)  
c506 32 70 ee			ld (debug_mark+2),a  
c509 18 03			jr .pastdmark  
c50b ..			.dmark: db "FNd"  
c50e f1			.pastdmark: pop af  
c50f			endm  
# End of macro DMARK
c50f						CALLMONITOR 
c50f cd 72 ee			call debug_vector  
c512				endm  
# End of macro CALLMONITOR
c512					endif 
c512 cd 49 9b			call forth_push_numhl 
c515			 
c515				       NEXTW 
c515 c3 f6 9e			jp macro_next 
c518				endm 
# End of macro NEXTW
c518			 
c518			.LEN: 
c518				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c518 4c				db WORD_SYS_CORE+56             
c519 82 c5			dw .ASC            
c51b 06				db 5 + 1 
c51c .. 00			db "COUNT",0              
c522				endm 
# End of macro CWHEAD
c522			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c522			 
c522					if DEBUG_FORTH_WORDS_KEY 
c522						DMARK "CNT" 
c522 f5				push af  
c523 3a 37 c5			ld a, (.dmark)  
c526 32 6e ee			ld (debug_mark),a  
c529 3a 38 c5			ld a, (.dmark+1)  
c52c 32 6f ee			ld (debug_mark+1),a  
c52f 3a 39 c5			ld a, (.dmark+2)  
c532 32 70 ee			ld (debug_mark+2),a  
c535 18 03			jr .pastdmark  
c537 ..			.dmark: db "CNT"  
c53a f1			.pastdmark: pop af  
c53b			endm  
# End of macro DMARK
c53b						CALLMONITOR 
c53b cd 72 ee			call debug_vector  
c53e				endm  
# End of macro CALLMONITOR
c53e					endif 
c53e			; TODO check string type 
c53e					FORTH_DSP_VALUE 
c53e cd 29 9d			call macro_forth_dsp_value 
c541				endm 
# End of macro FORTH_DSP_VALUE
c541			 
c541			 
c541					if DEBUG_FORTH_WORDS 
c541						DMARK "CN?" 
c541 f5				push af  
c542 3a 56 c5			ld a, (.dmark)  
c545 32 6e ee			ld (debug_mark),a  
c548 3a 57 c5			ld a, (.dmark+1)  
c54b 32 6f ee			ld (debug_mark+1),a  
c54e 3a 58 c5			ld a, (.dmark+2)  
c551 32 70 ee			ld (debug_mark+2),a  
c554 18 03			jr .pastdmark  
c556 ..			.dmark: db "CN?"  
c559 f1			.pastdmark: pop af  
c55a			endm  
# End of macro DMARK
c55a						CALLMONITOR 
c55a cd 72 ee			call debug_vector  
c55d				endm  
# End of macro CALLMONITOR
c55d					endif 
c55d cd 3a 91				call strlenz 
c560					if DEBUG_FORTH_WORDS 
c560						DMARK "CNl" 
c560 f5				push af  
c561 3a 75 c5			ld a, (.dmark)  
c564 32 6e ee			ld (debug_mark),a  
c567 3a 76 c5			ld a, (.dmark+1)  
c56a 32 6f ee			ld (debug_mark+1),a  
c56d 3a 77 c5			ld a, (.dmark+2)  
c570 32 70 ee			ld (debug_mark+2),a  
c573 18 03			jr .pastdmark  
c575 ..			.dmark: db "CNl"  
c578 f1			.pastdmark: pop af  
c579			endm  
# End of macro DMARK
c579						CALLMONITOR 
c579 cd 72 ee			call debug_vector  
c57c				endm  
# End of macro CALLMONITOR
c57c					endif 
c57c			 
c57c cd 49 9b				call forth_push_numhl 
c57f			 
c57f			 
c57f			 
c57f				       NEXTW 
c57f c3 f6 9e			jp macro_next 
c582				endm 
# End of macro NEXTW
c582			.ASC: 
c582				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c582 4d				db WORD_SYS_CORE+57             
c583 f0 c5			dw .CHR            
c585 04				db 3 + 1 
c586 .. 00			db "ASC",0              
c58a				endm 
# End of macro CWHEAD
c58a			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c58a					if DEBUG_FORTH_WORDS_KEY 
c58a						DMARK "ASC" 
c58a f5				push af  
c58b 3a 9f c5			ld a, (.dmark)  
c58e 32 6e ee			ld (debug_mark),a  
c591 3a a0 c5			ld a, (.dmark+1)  
c594 32 6f ee			ld (debug_mark+1),a  
c597 3a a1 c5			ld a, (.dmark+2)  
c59a 32 70 ee			ld (debug_mark+2),a  
c59d 18 03			jr .pastdmark  
c59f ..			.dmark: db "ASC"  
c5a2 f1			.pastdmark: pop af  
c5a3			endm  
# End of macro DMARK
c5a3						CALLMONITOR 
c5a3 cd 72 ee			call debug_vector  
c5a6				endm  
# End of macro CALLMONITOR
c5a6					endif 
c5a6					FORTH_DSP_VALUE 
c5a6 cd 29 9d			call macro_forth_dsp_value 
c5a9				endm 
# End of macro FORTH_DSP_VALUE
c5a9					;v5 FORTH_DSP_VALUE 
c5a9			;		inc hl      ; now at start of numeric as string 
c5a9			 
c5a9 e5					push hl 
c5aa			 
c5aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5aa cd f8 9d			call macro_forth_dsp_pop 
c5ad				endm 
# End of macro FORTH_DSP_POP
c5ad			 
c5ad e1					pop hl 
c5ae			 
c5ae					if DEBUG_FORTH_WORDS 
c5ae						DMARK "AS1" 
c5ae f5				push af  
c5af 3a c3 c5			ld a, (.dmark)  
c5b2 32 6e ee			ld (debug_mark),a  
c5b5 3a c4 c5			ld a, (.dmark+1)  
c5b8 32 6f ee			ld (debug_mark+1),a  
c5bb 3a c5 c5			ld a, (.dmark+2)  
c5be 32 70 ee			ld (debug_mark+2),a  
c5c1 18 03			jr .pastdmark  
c5c3 ..			.dmark: db "AS1"  
c5c6 f1			.pastdmark: pop af  
c5c7			endm  
# End of macro DMARK
c5c7						CALLMONITOR 
c5c7 cd 72 ee			call debug_vector  
c5ca				endm  
# End of macro CALLMONITOR
c5ca					endif 
c5ca					; push the content of a onto the stack as a value 
c5ca			 
c5ca 7e					ld a,(hl)   ; get char 
c5cb 26 00				ld h,0 
c5cd 6f					ld l,a 
c5ce					if DEBUG_FORTH_WORDS 
c5ce						DMARK "AS2" 
c5ce f5				push af  
c5cf 3a e3 c5			ld a, (.dmark)  
c5d2 32 6e ee			ld (debug_mark),a  
c5d5 3a e4 c5			ld a, (.dmark+1)  
c5d8 32 6f ee			ld (debug_mark+1),a  
c5db 3a e5 c5			ld a, (.dmark+2)  
c5de 32 70 ee			ld (debug_mark+2),a  
c5e1 18 03			jr .pastdmark  
c5e3 ..			.dmark: db "AS2"  
c5e6 f1			.pastdmark: pop af  
c5e7			endm  
# End of macro DMARK
c5e7						CALLMONITOR 
c5e7 cd 72 ee			call debug_vector  
c5ea				endm  
# End of macro CALLMONITOR
c5ea					endif 
c5ea cd 49 9b				call forth_push_numhl 
c5ed			 
c5ed				       NEXTW 
c5ed c3 f6 9e			jp macro_next 
c5f0				endm 
# End of macro NEXTW
c5f0			 
c5f0			.CHR: 
c5f0				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c5f0 4d				db WORD_SYS_CORE+57             
c5f1 2c c6			dw .ENDSTR            
c5f3 04				db 3 + 1 
c5f4 .. 00			db "CHR",0              
c5f8				endm 
# End of macro CWHEAD
c5f8			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c5f8					if DEBUG_FORTH_WORDS_KEY 
c5f8						DMARK "CHR" 
c5f8 f5				push af  
c5f9 3a 0d c6			ld a, (.dmark)  
c5fc 32 6e ee			ld (debug_mark),a  
c5ff 3a 0e c6			ld a, (.dmark+1)  
c602 32 6f ee			ld (debug_mark+1),a  
c605 3a 0f c6			ld a, (.dmark+2)  
c608 32 70 ee			ld (debug_mark+2),a  
c60b 18 03			jr .pastdmark  
c60d ..			.dmark: db "CHR"  
c610 f1			.pastdmark: pop af  
c611			endm  
# End of macro DMARK
c611						CALLMONITOR 
c611 cd 72 ee			call debug_vector  
c614				endm  
# End of macro CALLMONITOR
c614					endif 
c614					FORTH_DSP_VALUEHL 
c614 cd 40 9d			call macro_dsp_valuehl 
c617				endm 
# End of macro FORTH_DSP_VALUEHL
c617			 
c617					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c617 cd f8 9d			call macro_forth_dsp_pop 
c61a				endm 
# End of macro FORTH_DSP_POP
c61a			 
c61a					; save asci byte as a zero term string and push string 
c61a			 
c61a 7d					ld a,l 
c61b 32 c4 e2				ld (scratch), a 
c61e			 
c61e 3e 00				ld a, 0 
c620 32 c5 e2				ld (scratch+1), a 
c623			 
c623 21 c4 e2				ld hl, scratch 
c626 cd b7 9b				call forth_push_str 
c629			 
c629			 
c629				       NEXTW 
c629 c3 f6 9e			jp macro_next 
c62c				endm 
# End of macro NEXTW
c62c			 
c62c			 
c62c			 
c62c			 
c62c			.ENDSTR: 
c62c			; eof 
c62c			 
# End of file forth_words_str.asm
c62c			include "forth_words_key.asm" 
c62c			 
c62c			; | ## Keyboard Words 
c62c			 
c62c			.KEY: 
c62c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c62c 3e				db WORD_SYS_CORE+42             
c62d 5c c6			dw .WAITK            
c62f 04				db 3 + 1 
c630 .. 00			db "KEY",0              
c634				endm 
# End of macro CWHEAD
c634			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c634			 
c634					if DEBUG_FORTH_WORDS_KEY 
c634						DMARK "KEY" 
c634 f5				push af  
c635 3a 49 c6			ld a, (.dmark)  
c638 32 6e ee			ld (debug_mark),a  
c63b 3a 4a c6			ld a, (.dmark+1)  
c63e 32 6f ee			ld (debug_mark+1),a  
c641 3a 4b c6			ld a, (.dmark+2)  
c644 32 70 ee			ld (debug_mark+2),a  
c647 18 03			jr .pastdmark  
c649 ..			.dmark: db "KEY"  
c64c f1			.pastdmark: pop af  
c64d			endm  
# End of macro DMARK
c64d						CALLMONITOR 
c64d cd 72 ee			call debug_vector  
c650				endm  
# End of macro CALLMONITOR
c650					endif 
c650			; TODO currently waits 
c650 cd 3c e3				call cin 
c653					;call cin_wait 
c653 6f					ld l, a 
c654 26 00				ld h, 0 
c656 cd 49 9b				call forth_push_numhl 
c659					NEXTW 
c659 c3 f6 9e			jp macro_next 
c65c				endm 
# End of macro NEXTW
c65c			.WAITK: 
c65c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c65c 3f				db WORD_SYS_CORE+43             
c65d 8e c6			dw .ACCEPT            
c65f 06				db 5 + 1 
c660 .. 00			db "WAITK",0              
c666				endm 
# End of macro CWHEAD
c666			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c666					if DEBUG_FORTH_WORDS_KEY 
c666						DMARK "WAI" 
c666 f5				push af  
c667 3a 7b c6			ld a, (.dmark)  
c66a 32 6e ee			ld (debug_mark),a  
c66d 3a 7c c6			ld a, (.dmark+1)  
c670 32 6f ee			ld (debug_mark+1),a  
c673 3a 7d c6			ld a, (.dmark+2)  
c676 32 70 ee			ld (debug_mark+2),a  
c679 18 03			jr .pastdmark  
c67b ..			.dmark: db "WAI"  
c67e f1			.pastdmark: pop af  
c67f			endm  
# End of macro DMARK
c67f						CALLMONITOR 
c67f cd 72 ee			call debug_vector  
c682				endm  
# End of macro CALLMONITOR
c682					endif 
c682 cd 36 e3				call cin_wait 
c685 6f					ld l, a 
c686 26 00				ld h, 0 
c688 cd 49 9b				call forth_push_numhl 
c68b					NEXTW 
c68b c3 f6 9e			jp macro_next 
c68e				endm 
# End of macro NEXTW
c68e			.ACCEPT: 
c68e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c68e 40				db WORD_SYS_CORE+44             
c68f ec c6			dw .EDIT            
c691 07				db 6 + 1 
c692 .. 00			db "ACCEPT",0              
c699				endm 
# End of macro CWHEAD
c699			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c699					; TODO crashes on push 
c699					if DEBUG_FORTH_WORDS_KEY 
c699						DMARK "ACC" 
c699 f5				push af  
c69a 3a ae c6			ld a, (.dmark)  
c69d 32 6e ee			ld (debug_mark),a  
c6a0 3a af c6			ld a, (.dmark+1)  
c6a3 32 6f ee			ld (debug_mark+1),a  
c6a6 3a b0 c6			ld a, (.dmark+2)  
c6a9 32 70 ee			ld (debug_mark+2),a  
c6ac 18 03			jr .pastdmark  
c6ae ..			.dmark: db "ACC"  
c6b1 f1			.pastdmark: pop af  
c6b2			endm  
# End of macro DMARK
c6b2						CALLMONITOR 
c6b2 cd 72 ee			call debug_vector  
c6b5				endm  
# End of macro CALLMONITOR
c6b5					endif 
c6b5 21 c2 e4				ld hl, os_input 
c6b8 3e 00				ld a, 0 
c6ba 77					ld (hl),a 
c6bb 3a 61 ea				ld a,(f_cursor_ptr) 
c6be 16 64				ld d, 100 
c6c0 0e 00				ld c, 0 
c6c2 1e 28				ld e, 40 
c6c4 cd 09 8d				call input_str 
c6c7					; TODO perhaps do a type check and wrap in quotes if not a number 
c6c7 21 c2 e4				ld hl, os_input 
c6ca					if DEBUG_FORTH_WORDS 
c6ca						DMARK "AC1" 
c6ca f5				push af  
c6cb 3a df c6			ld a, (.dmark)  
c6ce 32 6e ee			ld (debug_mark),a  
c6d1 3a e0 c6			ld a, (.dmark+1)  
c6d4 32 6f ee			ld (debug_mark+1),a  
c6d7 3a e1 c6			ld a, (.dmark+2)  
c6da 32 70 ee			ld (debug_mark+2),a  
c6dd 18 03			jr .pastdmark  
c6df ..			.dmark: db "AC1"  
c6e2 f1			.pastdmark: pop af  
c6e3			endm  
# End of macro DMARK
c6e3						CALLMONITOR 
c6e3 cd 72 ee			call debug_vector  
c6e6				endm  
# End of macro CALLMONITOR
c6e6					endif 
c6e6 cd b7 9b				call forth_push_str 
c6e9					NEXTW 
c6e9 c3 f6 9e			jp macro_next 
c6ec				endm 
# End of macro NEXTW
c6ec			 
c6ec			.EDIT: 
c6ec				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c6ec 40				db WORD_SYS_CORE+44             
c6ed 8e c7			dw .DEDIT            
c6ef 05				db 4 + 1 
c6f0 .. 00			db "EDIT",0              
c6f5				endm 
# End of macro CWHEAD
c6f5			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c6f5			 
c6f5					; TODO does not copy from stack 
c6f5					if DEBUG_FORTH_WORDS_KEY 
c6f5						DMARK "EDT" 
c6f5 f5				push af  
c6f6 3a 0a c7			ld a, (.dmark)  
c6f9 32 6e ee			ld (debug_mark),a  
c6fc 3a 0b c7			ld a, (.dmark+1)  
c6ff 32 6f ee			ld (debug_mark+1),a  
c702 3a 0c c7			ld a, (.dmark+2)  
c705 32 70 ee			ld (debug_mark+2),a  
c708 18 03			jr .pastdmark  
c70a ..			.dmark: db "EDT"  
c70d f1			.pastdmark: pop af  
c70e			endm  
# End of macro DMARK
c70e						CALLMONITOR 
c70e cd 72 ee			call debug_vector  
c711				endm  
# End of macro CALLMONITOR
c711					endif 
c711			 
c711					;FORTH_DSP 
c711					FORTH_DSP_VALUEHL 
c711 cd 40 9d			call macro_dsp_valuehl 
c714				endm 
# End of macro FORTH_DSP_VALUEHL
c714			;		inc hl    ; TODO do type check 
c714			 
c714			;		call get_word_hl 
c714 e5					push hl 
c715					if DEBUG_FORTH_WORDS 
c715						DMARK "EDp" 
c715 f5				push af  
c716 3a 2a c7			ld a, (.dmark)  
c719 32 6e ee			ld (debug_mark),a  
c71c 3a 2b c7			ld a, (.dmark+1)  
c71f 32 6f ee			ld (debug_mark+1),a  
c722 3a 2c c7			ld a, (.dmark+2)  
c725 32 70 ee			ld (debug_mark+2),a  
c728 18 03			jr .pastdmark  
c72a ..			.dmark: db "EDp"  
c72d f1			.pastdmark: pop af  
c72e			endm  
# End of macro DMARK
c72e						CALLMONITOR 
c72e cd 72 ee			call debug_vector  
c731				endm  
# End of macro CALLMONITOR
c731					endif 
c731				;	ld a, 0 
c731 cd 3a 91				call strlenz 
c734 23					inc hl 
c735			 
c735 06 00				ld b, 0 
c737 4d					ld c, l 
c738			 
c738 e1					pop hl 
c739 11 c2 e4				ld de, os_input 
c73c					if DEBUG_FORTH_WORDS_KEY 
c73c						DMARK "EDc" 
c73c f5				push af  
c73d 3a 51 c7			ld a, (.dmark)  
c740 32 6e ee			ld (debug_mark),a  
c743 3a 52 c7			ld a, (.dmark+1)  
c746 32 6f ee			ld (debug_mark+1),a  
c749 3a 53 c7			ld a, (.dmark+2)  
c74c 32 70 ee			ld (debug_mark+2),a  
c74f 18 03			jr .pastdmark  
c751 ..			.dmark: db "EDc"  
c754 f1			.pastdmark: pop af  
c755			endm  
# End of macro DMARK
c755						CALLMONITOR 
c755 cd 72 ee			call debug_vector  
c758				endm  
# End of macro CALLMONITOR
c758					endif 
c758 ed b0				ldir 
c75a			 
c75a			 
c75a 21 c2 e4				ld hl, os_input 
c75d					;ld a, 0 
c75d					;ld (hl),a 
c75d 3a 61 ea				ld a,(f_cursor_ptr) 
c760 16 64				ld d, 100 
c762 0e 00				ld c, 0 
c764 1e 28				ld e, 40 
c766 cd 09 8d				call input_str 
c769					; TODO perhaps do a type check and wrap in quotes if not a number 
c769 21 c2 e4				ld hl, os_input 
c76c					if DEBUG_FORTH_WORDS 
c76c						DMARK "ED1" 
c76c f5				push af  
c76d 3a 81 c7			ld a, (.dmark)  
c770 32 6e ee			ld (debug_mark),a  
c773 3a 82 c7			ld a, (.dmark+1)  
c776 32 6f ee			ld (debug_mark+1),a  
c779 3a 83 c7			ld a, (.dmark+2)  
c77c 32 70 ee			ld (debug_mark+2),a  
c77f 18 03			jr .pastdmark  
c781 ..			.dmark: db "ED1"  
c784 f1			.pastdmark: pop af  
c785			endm  
# End of macro DMARK
c785						CALLMONITOR 
c785 cd 72 ee			call debug_vector  
c788				endm  
# End of macro CALLMONITOR
c788					endif 
c788 cd b7 9b				call forth_push_str 
c78b					NEXTW 
c78b c3 f6 9e			jp macro_next 
c78e				endm 
# End of macro NEXTW
c78e			 
c78e			.DEDIT: 
c78e				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c78e 40				db WORD_SYS_CORE+44             
c78f f0 c7			dw .ENDKEY            
c791 06				db 5 + 1 
c792 .. 00			db "DEDIT",0              
c798				endm 
# End of macro CWHEAD
c798			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c798			 
c798					; TODO does not copy from stack 
c798					if DEBUG_FORTH_WORDS_KEY 
c798						DMARK "DED" 
c798 f5				push af  
c799 3a ad c7			ld a, (.dmark)  
c79c 32 6e ee			ld (debug_mark),a  
c79f 3a ae c7			ld a, (.dmark+1)  
c7a2 32 6f ee			ld (debug_mark+1),a  
c7a5 3a af c7			ld a, (.dmark+2)  
c7a8 32 70 ee			ld (debug_mark+2),a  
c7ab 18 03			jr .pastdmark  
c7ad ..			.dmark: db "DED"  
c7b0 f1			.pastdmark: pop af  
c7b1			endm  
# End of macro DMARK
c7b1						CALLMONITOR 
c7b1 cd 72 ee			call debug_vector  
c7b4				endm  
# End of macro CALLMONITOR
c7b4					endif 
c7b4			 
c7b4					;FORTH_DSP 
c7b4					FORTH_DSP_VALUEHL 
c7b4 cd 40 9d			call macro_dsp_valuehl 
c7b7				endm 
# End of macro FORTH_DSP_VALUEHL
c7b7			;		inc hl    ; TODO do type check 
c7b7			 
c7b7			;		call get_word_hl 
c7b7 e5					push hl 
c7b8 e5					push hl 
c7b9					FORTH_DSP_POP 
c7b9 cd f8 9d			call macro_forth_dsp_pop 
c7bc				endm 
# End of macro FORTH_DSP_POP
c7bc e1					pop hl 
c7bd					if DEBUG_FORTH_WORDS 
c7bd						DMARK "EDp" 
c7bd f5				push af  
c7be 3a d2 c7			ld a, (.dmark)  
c7c1 32 6e ee			ld (debug_mark),a  
c7c4 3a d3 c7			ld a, (.dmark+1)  
c7c7 32 6f ee			ld (debug_mark+1),a  
c7ca 3a d4 c7			ld a, (.dmark+2)  
c7cd 32 70 ee			ld (debug_mark+2),a  
c7d0 18 03			jr .pastdmark  
c7d2 ..			.dmark: db "EDp"  
c7d5 f1			.pastdmark: pop af  
c7d6			endm  
# End of macro DMARK
c7d6						CALLMONITOR 
c7d6 cd 72 ee			call debug_vector  
c7d9				endm  
# End of macro CALLMONITOR
c7d9					endif 
c7d9				;	ld a, 0 
c7d9 cd 3a 91				call strlenz 
c7dc 23					inc hl 
c7dd			 
c7dd 06 00				ld b, 0 
c7df 4d					ld c, l 
c7e0			 
c7e0 e1					pop hl 
c7e1			 
c7e1					;ld a, 0 
c7e1					;ld (hl),a 
c7e1 3a 61 ea				ld a,(f_cursor_ptr) 
c7e4 16 64				ld d, 100 
c7e6 0e 00				ld c, 0 
c7e8 1e 28				ld e, 40 
c7ea cd 09 8d				call input_str 
c7ed					; TODO perhaps do a type check and wrap in quotes if not a number 
c7ed					NEXTW 
c7ed c3 f6 9e			jp macro_next 
c7f0				endm 
# End of macro NEXTW
c7f0			 
c7f0			 
c7f0			.ENDKEY: 
c7f0			; eof 
c7f0			 
# End of file forth_words_key.asm
c7f0			include "forth_words_const.asm" 
c7f0			 
c7f0			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c7f0			 
c7f0			 
c7f0			.SPITIME: 
c7f0				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c7f0 77				db WORD_SYS_CORE+99             
c7f1 05 c8			dw .VA            
c7f3 08				db 7 + 1 
c7f4 .. 00			db "SPITIME",0              
c7fc				endm 
# End of macro CWHEAD
c7fc			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c7fc			; 
c7fc			; | If using BANK devices then leave as is. 
c7fc			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c7fc			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c7fc			 
c7fc 21 67 ea				ld hl, spi_clktime  
c7ff cd 49 9b				call forth_push_numhl 
c802			 
c802					NEXTW 
c802 c3 f6 9e			jp macro_next 
c805				endm 
# End of macro NEXTW
c805			 
c805			 
c805			.VA: 
c805				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c805 77				db WORD_SYS_CORE+99             
c806 15 c8			dw .SYMBOL            
c808 03				db 2 + 1 
c809 .. 00			db "VA",0              
c80c				endm 
# End of macro CWHEAD
c80c			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c80c 21 2b ea				ld hl, cli_var_array 
c80f cd 49 9b				call forth_push_numhl 
c812			 
c812					NEXTW 
c812 c3 f6 9e			jp macro_next 
c815				endm 
# End of macro NEXTW
c815			 
c815			.SYMBOL: 
c815				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c815 77				db WORD_SYS_CORE+99             
c816 4d c9			dw .ENDCONST            
c818 07				db 6 + 1 
c819 .. 00			db "SYMBOL",0              
c820				endm 
# End of macro CWHEAD
c820			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c820			; | 
c820			; | The value is the number reference and the final address is pushed to stack 
c820			 
c820					if DEBUG_FORTH_WORDS_KEY 
c820						DMARK "SYM" 
c820 f5				push af  
c821 3a 35 c8			ld a, (.dmark)  
c824 32 6e ee			ld (debug_mark),a  
c827 3a 36 c8			ld a, (.dmark+1)  
c82a 32 6f ee			ld (debug_mark+1),a  
c82d 3a 37 c8			ld a, (.dmark+2)  
c830 32 70 ee			ld (debug_mark+2),a  
c833 18 03			jr .pastdmark  
c835 ..			.dmark: db "SYM"  
c838 f1			.pastdmark: pop af  
c839			endm  
# End of macro DMARK
c839						CALLMONITOR 
c839 cd 72 ee			call debug_vector  
c83c				endm  
# End of macro CALLMONITOR
c83c					endif 
c83c			 
c83c					FORTH_DSP_VALUEHL 
c83c cd 40 9d			call macro_dsp_valuehl 
c83f				endm 
# End of macro FORTH_DSP_VALUEHL
c83f			 
c83f 7d					ld a, l     
c840			 
c840			 
c840					if DEBUG_FORTH_WORDS 
c840						DMARK "SY1" 
c840 f5				push af  
c841 3a 55 c8			ld a, (.dmark)  
c844 32 6e ee			ld (debug_mark),a  
c847 3a 56 c8			ld a, (.dmark+1)  
c84a 32 6f ee			ld (debug_mark+1),a  
c84d 3a 57 c8			ld a, (.dmark+2)  
c850 32 70 ee			ld (debug_mark+2),a  
c853 18 03			jr .pastdmark  
c855 ..			.dmark: db "SY1"  
c858 f1			.pastdmark: pop af  
c859			endm  
# End of macro DMARK
c859						CALLMONITOR 
c859 cd 72 ee			call debug_vector  
c85c				endm  
# End of macro CALLMONITOR
c85c					endif 
c85c					 
c85c f5					push af	 
c85d					FORTH_DSP_POP 
c85d cd f8 9d			call macro_forth_dsp_pop 
c860				endm 
# End of macro FORTH_DSP_POP
c860 f1					pop af 
c861			 
c861 cb 27				sla a  
c863				 
c863					 
c863					if DEBUG_FORTH_WORDS 
c863						DMARK "SY" 
c863 f5				push af  
c864 3a 78 c8			ld a, (.dmark)  
c867 32 6e ee			ld (debug_mark),a  
c86a 3a 79 c8			ld a, (.dmark+1)  
c86d 32 6f ee			ld (debug_mark+1),a  
c870 3a 7a c8			ld a, (.dmark+2)  
c873 32 70 ee			ld (debug_mark+2),a  
c876 18 02			jr .pastdmark  
c878 ..			.dmark: db "SY"  
c87a f1			.pastdmark: pop af  
c87b			endm  
# End of macro DMARK
c87b						CALLMONITOR 
c87b cd 72 ee			call debug_vector  
c87e				endm  
# End of macro CALLMONITOR
c87e					endif 
c87e			 
c87e 21 8d c8				ld hl, sym_table 
c881 cd dc 8c				call addatohl 
c884 cd 78 9e				call loadwordinhl 
c887 cd 49 9b				call forth_push_numhl 
c88a			 
c88a			 
c88a				       NEXTW 
c88a c3 f6 9e			jp macro_next 
c88d				endm 
# End of macro NEXTW
c88d			 
c88d			sym_table: 
c88d			 
c88d			; 0 
c88d 3f ea		dw cli_autodisplay 
c88f 4d ea		dw cli_buffer 
c891 f1 e9		dw cli_data_sp 
c893 2b e8		dw cli_data_stack 
c895 47 ea		dw cli_execword 
c897 f3 e9		dw cli_loop_sp 
c899 2d e9		dw cli_loop_stack 
c89b 40 ea		dw cli_mvdot 
c89d 45 ea		dw cli_nextword 
c89f 41 ea		dw cli_origptr 
c8a1 4b ea		dw cli_origtoken 
c8a3			; 11 
c8a3 43 ea		dw cli_ptr 
c8a5 f5 e9		dw cli_ret_sp 
c8a7 af e9		dw cli_ret_stack 
c8a9 49 ea		dw cli_token 
c8ab 2b ea		dw cli_var_array 
c8ad c8 eb		dw cursor_col 
c8af c6 eb		dw cursor_ptr 
c8b1 c7 eb		dw cursor_row 
c8b3 c4 eb		dw cursor_shape 
c8b5 6e ee		dw debug_mark 
c8b7			; 21 
c8b7 b4 ed		dw display_fb0 
c8b9 13 ed		dw display_fb1 
c8bb d1 eb		dw display_fb2 
c8bd 72 ec		dw display_fb3 
c8bf cf eb		dw display_fb_active 
c8c1 c3 e3		dw execscratch 
c8c3 61 ea		dw f_cursor_ptr 
c8c5 75 ee		dw hardware_word 
c8c7 65 ee		dw input_at_cursor 
c8c9 67 ee		dw input_at_pos 
c8cb			; 31 
c8cb 63 ee		dw input_cur_flash 
c8cd 62 ee		dw input_cur_onoff 
c8cf 58 ee		dw input_cursor 
c8d1 68 ee		dw input_display_size 
c8d3 5d ee		dw input_len 
c8d5 6c ee		dw input_ptr 
c8d7 69 ee		dw input_size 
c8d9 6a ee		dw input_start 
c8db 09 8d		dw input_str 
c8dd 66 ee		dw input_under_cursor 
c8df			; 41 
c8df 57 ee		dw key_actual_pressed 
c8e1 85 ee		dw key_fa 
c8e3 81 ee		dw key_face_held 
c8e5 84 ee		dw key_fb 
c8e7 83 ee		dw key_fc 
c8e9 82 ee		dw key_fd 
c8eb 8b ee		dw key_held 
c8ed 8a ee		dw key_held_prev 
c8ef 35 e3		dw key_init 
c8f1 86 ee		dw key_repeat_ct 
c8f3			; 51 
c8f3 05 00		dw key_rows 
c8f5 55 ee		dw key_shift 
c8f7 56 ee		dw key_symbol 
c8f9 8c ee		dw keyscan_scancol 
c8fb 96 ee		dw keyscan_table 
c8fd f5 ee		dw keyscan_table_row1 
c8ff ea ee		dw keyscan_table_row2 
c901 df ee		dw keyscan_table_row3 
c903 d4 ee		dw keyscan_table_row4 
c905 c9 ee		dw keyscan_table_row5 
c907			; 61 
c907 eb e5		dw os_cli_cmd 
c909 e7 e5		dw os_cur_ptr 
c90b e9 e5		dw os_current_i 
c90d c2 e4		dw os_input 
c90f ea e6		dw os_last_cmd 
c911 c1 e5		dw os_last_new_uword 
c913			;dw os_view_disable 
c913 72 ee		dw debug_vector 
c915 b2 e2		dw os_view_hl 
c917 c9 e5		dw os_word_scratch 
c919 c3 00		dw portbctl 
c91b			; 71 
c91b c1 00		dw portbdata 
c91d 66 ea		dw spi_cartdev 
c91f 65 ea		dw spi_cartdev2 
c921 67 ea		dw spi_clktime 
c923 63 ea		dw spi_device 
c925 62 ea		dw spi_device_id 
c927 64 ea		dw spi_portbyte 
c929 aa eb		dw stackstore 
c92b			if STORAGE_SE 
c92b			dw storage_actl 
c92b			dw storage_adata 
c92b			else 
c92b 00 00		dw 0 
c92d 00 00		dw 0 
c92f			endif 
c92f			; 81 
c92f 69 88		dw storage_append 
c931			if STORAGE_SE 
c931			dw storage_bctl 
c931			else 
c931 00 00		dw 0 
c933			endif 
c933 96 eb		dw store_bank_active 
c935 6a ea		dw store_filecache 
c937 78 ea		dw store_longread 
c939 6e ea		dw store_openaddr 
c93b 6d ea		dw store_openext 
c93d 6c ea		dw store_openmaxext 
c93f 7d ea		dw store_page 
c941 79 ea		dw store_readbuf 
c943			; 91 
c943 70 ea		dw store_readcont 
c945 7b ea		dw store_readptr 
c947 70 ea		dw store_tmpext 
c949 71 ea		dw store_tmpid 
c94b 68 ea		dw store_tmppageid 
c94d			 
c94d			.ENDCONST: 
c94d			 
c94d			; eof 
c94d			 
c94d			 
# End of file forth_words_const.asm
c94d			 
c94d			if STORAGE_SE 
c94d			   	include "forth_words_storage.asm" 
c94d			endif 
c94d				include "forth_words_device.asm" 
c94d			; Device related words 
c94d			 
c94d			; | ## Device Words 
c94d			 
c94d			;if SOUND_ENABLE 
c94d			;.NOTE: 
c94d			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c94d			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c94d			;		if DEBUG_FORTH_WORDS_KEY 
c94d			;			DMARK "NTE" 
c94d			;			CALLMONITOR 
c94d			;		endif 
c94d			; 
c94d			;	 
c94d			; 
c94d			;		NEXTW 
c94d			;.AFTERSOUND: 
c94d			;endif 
c94d			 
c94d			 
c94d			USE_GPIO: equ 0 
c94d			 
c94d			if USE_GPIO 
c94d			.GP1: 
c94d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c94d			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c94d					NEXTW 
c94d			.GP2: 
c94d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c94d			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c94d			 
c94d					NEXTW 
c94d			 
c94d			.GP3: 
c94d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c94d			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c94d			 
c94d					NEXTW 
c94d			 
c94d			.GP4: 
c94d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c94d			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c94d			 
c94d					NEXTW 
c94d			.SIN: 
c94d			 
c94d			 
c94d			endif 
c94d			 
c94d			 
c94d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c94d 33				db WORD_SYS_CORE+31             
c94e 82 c9			dw .SOUT            
c950 03				db 2 + 1 
c951 .. 00			db "IN",0              
c954				endm 
# End of macro CWHEAD
c954			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c954					if DEBUG_FORTH_WORDS_KEY 
c954						DMARK "IN." 
c954 f5				push af  
c955 3a 69 c9			ld a, (.dmark)  
c958 32 6e ee			ld (debug_mark),a  
c95b 3a 6a c9			ld a, (.dmark+1)  
c95e 32 6f ee			ld (debug_mark+1),a  
c961 3a 6b c9			ld a, (.dmark+2)  
c964 32 70 ee			ld (debug_mark+2),a  
c967 18 03			jr .pastdmark  
c969 ..			.dmark: db "IN."  
c96c f1			.pastdmark: pop af  
c96d			endm  
# End of macro DMARK
c96d						CALLMONITOR 
c96d cd 72 ee			call debug_vector  
c970				endm  
# End of macro CALLMONITOR
c970					endif 
c970					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c970 cd 40 9d			call macro_dsp_valuehl 
c973				endm 
# End of macro FORTH_DSP_VALUEHL
c973			 
c973 e5					push hl 
c974			 
c974					; destroy value TOS 
c974			 
c974					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c974 cd f8 9d			call macro_forth_dsp_pop 
c977				endm 
# End of macro FORTH_DSP_POP
c977			 
c977					; one value on hl get other one back 
c977			 
c977 c1					pop bc 
c978			 
c978					; do the sub 
c978			;		ex de, hl 
c978			 
c978 ed 68				in l,(c) 
c97a			 
c97a					; save it 
c97a			 
c97a 26 00				ld h,0 
c97c			 
c97c					; TODO push value back onto stack for another op etc 
c97c			 
c97c cd 49 9b				call forth_push_numhl 
c97f					NEXTW 
c97f c3 f6 9e			jp macro_next 
c982				endm 
# End of macro NEXTW
c982			.SOUT: 
c982				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c982 34				db WORD_SYS_CORE+32             
c983 d5 c9			dw .SPIO            
c985 04				db 3 + 1 
c986 .. 00			db "OUT",0              
c98a				endm 
# End of macro CWHEAD
c98a			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c98a					if DEBUG_FORTH_WORDS_KEY 
c98a						DMARK "OUT" 
c98a f5				push af  
c98b 3a 9f c9			ld a, (.dmark)  
c98e 32 6e ee			ld (debug_mark),a  
c991 3a a0 c9			ld a, (.dmark+1)  
c994 32 6f ee			ld (debug_mark+1),a  
c997 3a a1 c9			ld a, (.dmark+2)  
c99a 32 70 ee			ld (debug_mark+2),a  
c99d 18 03			jr .pastdmark  
c99f ..			.dmark: db "OUT"  
c9a2 f1			.pastdmark: pop af  
c9a3			endm  
# End of macro DMARK
c9a3						CALLMONITOR 
c9a3 cd 72 ee			call debug_vector  
c9a6				endm  
# End of macro CALLMONITOR
c9a6					endif 
c9a6			 
c9a6					; get port 
c9a6			 
c9a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9a6 cd 40 9d			call macro_dsp_valuehl 
c9a9				endm 
# End of macro FORTH_DSP_VALUEHL
c9a9			 
c9a9 e5					push hl 
c9aa			 
c9aa					; destroy value TOS 
c9aa			 
c9aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9aa cd f8 9d			call macro_forth_dsp_pop 
c9ad				endm 
# End of macro FORTH_DSP_POP
c9ad			 
c9ad					; get byte to send 
c9ad			 
c9ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9ad cd 40 9d			call macro_dsp_valuehl 
c9b0				endm 
# End of macro FORTH_DSP_VALUEHL
c9b0			 
c9b0			;		push hl 
c9b0			 
c9b0					; destroy value TOS 
c9b0			 
c9b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9b0 cd f8 9d			call macro_forth_dsp_pop 
c9b3				endm 
# End of macro FORTH_DSP_POP
c9b3			 
c9b3					; one value on hl get other one back 
c9b3			 
c9b3			;		pop hl 
c9b3			 
c9b3 c1					pop bc 
c9b4			 
c9b4					if DEBUG_FORTH_WORDS 
c9b4						DMARK "OUT" 
c9b4 f5				push af  
c9b5 3a c9 c9			ld a, (.dmark)  
c9b8 32 6e ee			ld (debug_mark),a  
c9bb 3a ca c9			ld a, (.dmark+1)  
c9be 32 6f ee			ld (debug_mark+1),a  
c9c1 3a cb c9			ld a, (.dmark+2)  
c9c4 32 70 ee			ld (debug_mark+2),a  
c9c7 18 03			jr .pastdmark  
c9c9 ..			.dmark: db "OUT"  
c9cc f1			.pastdmark: pop af  
c9cd			endm  
# End of macro DMARK
c9cd						CALLMONITOR 
c9cd cd 72 ee			call debug_vector  
c9d0				endm  
# End of macro CALLMONITOR
c9d0					endif 
c9d0			 
c9d0 ed 69				out (c), l 
c9d2			 
c9d2					NEXTW 
c9d2 c3 f6 9e			jp macro_next 
c9d5				endm 
# End of macro NEXTW
c9d5			 
c9d5			 
c9d5			.SPIO: 
c9d5			 
c9d5			if STORAGE_SE 
c9d5				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9d5			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9d5			 
c9d5					call spi_ce_low 
c9d5			    NEXTW 
c9d5			 
c9d5			.SPICEH: 
c9d5				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9d5			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9d5			 
c9d5					call spi_ce_high 
c9d5			    NEXTW 
c9d5			 
c9d5			 
c9d5			.SPIOb: 
c9d5			 
c9d5				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9d5			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9d5			 
c9d5					if DEBUG_FORTH_WORDS_KEY 
c9d5						DMARK "SPo" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5					; get port 
c9d5			 
c9d5			 
c9d5					; get byte to send 
c9d5			 
c9d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9d5			 
c9d5			;		push hl    ; u1  
c9d5			 
c9d5					; destroy value TOS 
c9d5			 
c9d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9d5			 
c9d5					; one value on hl get other one back 
c9d5			 
c9d5			;		pop hl   ; u2 - addr 
c9d5			 
c9d5					; TODO Send SPI byte 
c9d5			 
c9d5			;		push hl 
c9d5			;		call spi_ce_low 
c9d5			;		pop hl 
c9d5					ld a, l 
c9d5					call spi_send_byte 
c9d5			;		call spi_ce_high 
c9d5			 
c9d5					NEXTW 
c9d5			 
c9d5			.SPII: 
c9d5				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9d5			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9d5					if DEBUG_FORTH_WORDS_KEY 
c9d5						DMARK "SPi" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5			 
c9d5					; TODO Get SPI byte 
c9d5			 
c9d5					call spi_read_byte 
c9d5			 
c9d5					if DEBUG_FORTH_WORDS 
c9d5						DMARK "Si2" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5					ld h, 0 
c9d5					ld l, a 
c9d5					if DEBUG_FORTH_WORDS 
c9d5						DMARK "Si3" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5					call forth_push_numhl 
c9d5			 
c9d5					NEXTW 
c9d5			 
c9d5			 
c9d5			 
c9d5			.SESEL: 
c9d5				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9d5			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9d5					if DEBUG_FORTH_WORDS_KEY 
c9d5						DMARK "BNK" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5			 
c9d5					ld a, 255 
c9d5					ld (spi_cartdev), a 
c9d5			 
c9d5					; get bank 
c9d5			 
c9d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9d5			 
c9d5			;		push hl 
c9d5			 
c9d5					; destroy value TOS 
c9d5			 
c9d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9d5			 
c9d5					; one value on hl get other one back 
c9d5			 
c9d5			;		pop hl 
c9d5			 
c9d5			 
c9d5					ld c, SPI_CE_HIGH 
c9d5					ld b, '0'    ; human readable bank number 
c9d5			 
c9d5					ld a, l 
c9d5			 
c9d5					if DEBUG_FORTH_WORDS 
c9d5						DMARK "BNK" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5			 
c9d5					; active low 
c9d5			 
c9d5					cp 0 
c9d5					jr z, .bset 
c9d5					cp 1 
c9d5					jr nz, .b2 
c9d5					res 0, c 
c9d5					ld b, '1'    ; human readable bank number 
c9d5			.b2:		cp 2 
c9d5					jr nz, .b3 
c9d5					res 1, c 
c9d5					ld b, '2'    ; human readable bank number 
c9d5			.b3:		cp 3 
c9d5					jr nz, .b4 
c9d5					res 2, c 
c9d5					ld b, '3'    ; human readable bank number 
c9d5			.b4:		cp 4 
c9d5					jr nz, .b5 
c9d5					res 3, c 
c9d5					ld b, '4'    ; human readable bank number 
c9d5			.b5:		cp 5 
c9d5					jr nz, .bset 
c9d5					res 4, c 
c9d5					ld b, '5'    ; human readable bank number 
c9d5			 
c9d5			.bset: 
c9d5					ld a, c 
c9d5					ld (spi_device),a 
c9d5					ld a, b 
c9d5					ld (spi_device_id),a 
c9d5					if DEBUG_FORTH_WORDS 
c9d5						DMARK "BN2" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5			 
c9d5					; set default SPI clk pulse time as disabled for BANK use 
c9d5			 
c9d5					ld a, 0 
c9d5					ld (spi_clktime), a 
c9d5			 
c9d5					NEXTW 
c9d5			 
c9d5			.CARTDEV: 
c9d5				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9d5			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9d5					if DEBUG_FORTH_WORDS_KEY 
c9d5						DMARK "CDV" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5			 
c9d5					; disable se storage bank selection 
c9d5			 
c9d5					ld a, SPI_CE_HIGH		; ce high 
c9d5					ld (spi_device), a 
c9d5			 
c9d5					; get bank 
c9d5			 
c9d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9d5			 
c9d5			;		push hl 
c9d5			 
c9d5					; destroy value TOS 
c9d5			 
c9d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9d5			 
c9d5					; one value on hl get other one back 
c9d5			 
c9d5			;		pop hl 
c9d5			 
c9d5					; active low 
c9d5			 
c9d5					ld c, 255 
c9d5			 
c9d5					ld a, l 
c9d5					if DEBUG_FORTH_WORDS 
c9d5						DMARK "CDV" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5					cp 0 
c9d5					jr z, .cset 
c9d5					cp 1 
c9d5					jr nz, .c2 
c9d5					res 0, c 
c9d5			.c2:		cp 2 
c9d5					jr nz, .c3 
c9d5					res 1, c 
c9d5			.c3:		cp 3 
c9d5					jr nz, .c4 
c9d5					res 2, c 
c9d5			.c4:		cp 4 
c9d5					jr nz, .c5 
c9d5					res 3, c 
c9d5			.c5:		cp 5 
c9d5					jr nz, .c6 
c9d5					res 4, c 
c9d5			.c6:		cp 6 
c9d5					jr nz, .c7 
c9d5					res 5, c 
c9d5			.c7:		cp 7 
c9d5					jr nz, .c8 
c9d5					res 6, c 
c9d5			.c8:		cp 8 
c9d5					jr nz, .cset 
c9d5					res 7, c 
c9d5			.cset:		ld a, c 
c9d5					ld (spi_cartdev),a 
c9d5			 
c9d5					if DEBUG_FORTH_WORDS 
c9d5						DMARK "CD2" 
c9d5						CALLMONITOR 
c9d5					endif 
c9d5			 
c9d5					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9d5			 
c9d5					ld a, $0a 
c9d5					ld (spi_clktime), a 
c9d5					NEXTW 
c9d5			endif 
c9d5			 
c9d5			.ENDDEVICE: 
c9d5			; eof 
c9d5			 
# End of file forth_words_device.asm
c9d5			 
c9d5			; var handler 
c9d5			 
c9d5			 
c9d5			.VARS: 
c9d5				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9d5 77				db WORD_SYS_CORE+99             
c9d6 86 ca			dw .V0            
c9d8 04				db 3 + 1 
c9d9 .. 00			db "VAR",0              
c9dd				endm 
# End of macro CWHEAD
c9dd			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9dd			;| 
c9dd			;| The variable name should consist of a single letter. e.g. "a" 
c9dd			;! If a full string is passed then only the first char is looked at 
c9dd			;| Any other char could exceed bounds checks!  
c9dd			 
c9dd					if DEBUG_FORTH_WORDS_KEY 
c9dd						DMARK "VAR" 
c9dd f5				push af  
c9de 3a f2 c9			ld a, (.dmark)  
c9e1 32 6e ee			ld (debug_mark),a  
c9e4 3a f3 c9			ld a, (.dmark+1)  
c9e7 32 6f ee			ld (debug_mark+1),a  
c9ea 3a f4 c9			ld a, (.dmark+2)  
c9ed 32 70 ee			ld (debug_mark+2),a  
c9f0 18 03			jr .pastdmark  
c9f2 ..			.dmark: db "VAR"  
c9f5 f1			.pastdmark: pop af  
c9f6			endm  
# End of macro DMARK
c9f6						CALLMONITOR 
c9f6 cd 72 ee			call debug_vector  
c9f9				endm  
# End of macro CALLMONITOR
c9f9					endif 
c9f9			 
c9f9					FORTH_DSP_VALUEHL 
c9f9 cd 40 9d			call macro_dsp_valuehl 
c9fc				endm 
# End of macro FORTH_DSP_VALUEHL
c9fc			 
c9fc 7e					ld a, (hl)    ; get first char on of the string 
c9fd			 
c9fd			 
c9fd					if DEBUG_FORTH_WORDS 
c9fd						DMARK "VR1" 
c9fd f5				push af  
c9fe 3a 12 ca			ld a, (.dmark)  
ca01 32 6e ee			ld (debug_mark),a  
ca04 3a 13 ca			ld a, (.dmark+1)  
ca07 32 6f ee			ld (debug_mark+1),a  
ca0a 3a 14 ca			ld a, (.dmark+2)  
ca0d 32 70 ee			ld (debug_mark+2),a  
ca10 18 03			jr .pastdmark  
ca12 ..			.dmark: db "VR1"  
ca15 f1			.pastdmark: pop af  
ca16			endm  
# End of macro DMARK
ca16						CALLMONITOR 
ca16 cd 72 ee			call debug_vector  
ca19				endm  
# End of macro CALLMONITOR
ca19					endif 
ca19					 
ca19 f5					push af	 
ca1a					FORTH_DSP_POP 
ca1a cd f8 9d			call macro_forth_dsp_pop 
ca1d				endm 
# End of macro FORTH_DSP_POP
ca1d f1					pop af 
ca1e			 
ca1e					; convert to upper 
ca1e			 
ca1e cd 49 90				call to_upper 
ca21					if DEBUG_FORTH_WORDS 
ca21						DMARK "Vaa" 
ca21 f5				push af  
ca22 3a 36 ca			ld a, (.dmark)  
ca25 32 6e ee			ld (debug_mark),a  
ca28 3a 37 ca			ld a, (.dmark+1)  
ca2b 32 6f ee			ld (debug_mark+1),a  
ca2e 3a 38 ca			ld a, (.dmark+2)  
ca31 32 70 ee			ld (debug_mark+2),a  
ca34 18 03			jr .pastdmark  
ca36 ..			.dmark: db "Vaa"  
ca39 f1			.pastdmark: pop af  
ca3a			endm  
# End of macro DMARK
ca3a						CALLMONITOR 
ca3a cd 72 ee			call debug_vector  
ca3d				endm  
# End of macro CALLMONITOR
ca3d					endif 
ca3d 06 41				ld b, 'A' 
ca3f 90					sub b			; set offset 
ca40					if DEBUG_FORTH_WORDS 
ca40						DMARK "Vbb" 
ca40 f5				push af  
ca41 3a 55 ca			ld a, (.dmark)  
ca44 32 6e ee			ld (debug_mark),a  
ca47 3a 56 ca			ld a, (.dmark+1)  
ca4a 32 6f ee			ld (debug_mark+1),a  
ca4d 3a 57 ca			ld a, (.dmark+2)  
ca50 32 70 ee			ld (debug_mark+2),a  
ca53 18 03			jr .pastdmark  
ca55 ..			.dmark: db "Vbb"  
ca58 f1			.pastdmark: pop af  
ca59			endm  
# End of macro DMARK
ca59						CALLMONITOR 
ca59 cd 72 ee			call debug_vector  
ca5c				endm  
# End of macro CALLMONITOR
ca5c					endif 
ca5c cb 27				sla a  
ca5e				 
ca5e					 
ca5e					if DEBUG_FORTH_WORDS 
ca5e						DMARK "VR2" 
ca5e f5				push af  
ca5f 3a 73 ca			ld a, (.dmark)  
ca62 32 6e ee			ld (debug_mark),a  
ca65 3a 74 ca			ld a, (.dmark+1)  
ca68 32 6f ee			ld (debug_mark+1),a  
ca6b 3a 75 ca			ld a, (.dmark+2)  
ca6e 32 70 ee			ld (debug_mark+2),a  
ca71 18 03			jr .pastdmark  
ca73 ..			.dmark: db "VR2"  
ca76 f1			.pastdmark: pop af  
ca77			endm  
# End of macro DMARK
ca77						CALLMONITOR 
ca77 cd 72 ee			call debug_vector  
ca7a				endm  
# End of macro CALLMONITOR
ca7a					endif 
ca7a			 
ca7a 21 f7 e9				ld hl, cli_var_array2 
ca7d cd dc 8c				call addatohl 
ca80 cd 49 9b				call forth_push_numhl 
ca83			 
ca83			 
ca83				       NEXTW 
ca83 c3 f6 9e			jp macro_next 
ca86				endm 
# End of macro NEXTW
ca86			.V0: 
ca86				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca86 78				db WORD_SYS_CORE+100             
ca87 9e ca			dw .V0Q            
ca89 04				db 3 + 1 
ca8a .. 00			db "V0!",0              
ca8e				endm 
# End of macro CWHEAD
ca8e			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca8e			 
ca8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca8e cd 40 9d			call macro_dsp_valuehl 
ca91				endm 
# End of macro FORTH_DSP_VALUEHL
ca91			 
ca91 11 2b ea				ld de, cli_var_array 
ca94			 
ca94 eb					ex de, hl 
ca95 73					ld (hl), e 
ca96 23					inc hl 
ca97 72					ld (hl), d 
ca98			 
ca98					; destroy value TOS 
ca98			 
ca98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca98 cd f8 9d			call macro_forth_dsp_pop 
ca9b				endm 
# End of macro FORTH_DSP_POP
ca9b			 
ca9b				       NEXTW 
ca9b c3 f6 9e			jp macro_next 
ca9e				endm 
# End of macro NEXTW
ca9e			.V0Q: 
ca9e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ca9e 79				db WORD_SYS_CORE+101             
ca9f af ca			dw .V1S            
caa1 04				db 3 + 1 
caa2 .. 00			db "V0@",0              
caa6				endm 
# End of macro CWHEAD
caa6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
caa6 2a 2b ea				ld hl, (cli_var_array) 
caa9 cd 49 9b				call forth_push_numhl 
caac			 
caac				       NEXTW 
caac c3 f6 9e			jp macro_next 
caaf				endm 
# End of macro NEXTW
caaf			.V1S: 
caaf				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
caaf 7a				db WORD_SYS_CORE+102             
cab0 c7 ca			dw .V1Q            
cab2 04				db 3 + 1 
cab3 .. 00			db "V1!",0              
cab7				endm 
# End of macro CWHEAD
cab7			;| V1! ( u1 -- )  Store value to v1 | DONE 
cab7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cab7 cd 40 9d			call macro_dsp_valuehl 
caba				endm 
# End of macro FORTH_DSP_VALUEHL
caba			 
caba 11 2d ea				ld de, cli_var_array+2 
cabd				 
cabd eb					ex de, hl 
cabe 73					ld (hl), e 
cabf 23					inc hl 
cac0 72					ld (hl), d 
cac1			 
cac1					; destroy value TOS 
cac1			 
cac1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cac1 cd f8 9d			call macro_forth_dsp_pop 
cac4				endm 
# End of macro FORTH_DSP_POP
cac4				       NEXTW 
cac4 c3 f6 9e			jp macro_next 
cac7				endm 
# End of macro NEXTW
cac7			.V1Q: 
cac7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cac7 7b				db WORD_SYS_CORE+103             
cac8 d8 ca			dw .V2S            
caca 04				db 3 + 1 
cacb .. 00			db "V1@",0              
cacf				endm 
# End of macro CWHEAD
cacf			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cacf 2a 2d ea				ld hl, (cli_var_array+2) 
cad2 cd 49 9b				call forth_push_numhl 
cad5				       NEXTW 
cad5 c3 f6 9e			jp macro_next 
cad8				endm 
# End of macro NEXTW
cad8			.V2S: 
cad8				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cad8 7c				db WORD_SYS_CORE+104             
cad9 f0 ca			dw .V2Q            
cadb 04				db 3 + 1 
cadc .. 00			db "V2!",0              
cae0				endm 
# End of macro CWHEAD
cae0			;| V2! ( u1 -- )  Store value to v2 | DONE 
cae0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cae0 cd 40 9d			call macro_dsp_valuehl 
cae3				endm 
# End of macro FORTH_DSP_VALUEHL
cae3			 
cae3 11 2f ea				ld de, cli_var_array+4 
cae6				 
cae6 eb					ex de, hl 
cae7 73					ld (hl), e 
cae8 23					inc hl 
cae9 72					ld (hl), d 
caea			 
caea					; destroy value TOS 
caea			 
caea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caea cd f8 9d			call macro_forth_dsp_pop 
caed				endm 
# End of macro FORTH_DSP_POP
caed				       NEXTW 
caed c3 f6 9e			jp macro_next 
caf0				endm 
# End of macro NEXTW
caf0			.V2Q: 
caf0				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
caf0 7d				db WORD_SYS_CORE+105             
caf1 01 cb			dw .V3S            
caf3 04				db 3 + 1 
caf4 .. 00			db "V2@",0              
caf8				endm 
# End of macro CWHEAD
caf8			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
caf8 2a 2f ea				ld hl, (cli_var_array+4) 
cafb cd 49 9b				call forth_push_numhl 
cafe				       NEXTW 
cafe c3 f6 9e			jp macro_next 
cb01				endm 
# End of macro NEXTW
cb01			.V3S: 
cb01				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb01 7c				db WORD_SYS_CORE+104             
cb02 19 cb			dw .V3Q            
cb04 04				db 3 + 1 
cb05 .. 00			db "V3!",0              
cb09				endm 
# End of macro CWHEAD
cb09			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb09 cd 40 9d			call macro_dsp_valuehl 
cb0c				endm 
# End of macro FORTH_DSP_VALUEHL
cb0c			 
cb0c 11 31 ea				ld de, cli_var_array+6 
cb0f				 
cb0f eb					ex de, hl 
cb10 73					ld (hl), e 
cb11 23					inc hl 
cb12 72					ld (hl), d 
cb13			 
cb13					; destroy value TOS 
cb13			 
cb13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb13 cd f8 9d			call macro_forth_dsp_pop 
cb16				endm 
# End of macro FORTH_DSP_POP
cb16				       NEXTW 
cb16 c3 f6 9e			jp macro_next 
cb19				endm 
# End of macro NEXTW
cb19			.V3Q: 
cb19				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb19 7d				db WORD_SYS_CORE+105             
cb1a 2a cb			dw .END            
cb1c 04				db 3 + 1 
cb1d .. 00			db "V3@",0              
cb21				endm 
# End of macro CWHEAD
cb21			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb21 2a 31 ea				ld hl, (cli_var_array+6) 
cb24 cd 49 9b				call forth_push_numhl 
cb27				       NEXTW 
cb27 c3 f6 9e			jp macro_next 
cb2a				endm 
# End of macro NEXTW
cb2a			 
cb2a			 
cb2a			 
cb2a			 
cb2a			 
cb2a			; end of dict marker 
cb2a			 
cb2a 00			.END:    db WORD_SYS_END 
cb2b 00 00			dw 0 
cb2d 00				db 0 
cb2e			 
cb2e			; use to jp here for user dict words to save on macro expansion  
cb2e			 
cb2e			user_dict_next: 
cb2e				NEXTW 
cb2e c3 f6 9e			jp macro_next 
cb31				endm 
# End of macro NEXTW
cb31			 
cb31			 
cb31			user_exec: 
cb31				;    ld hl, <word code> 
cb31				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb31				;    call forthexec 
cb31				;    jp user_dict_next   (NEXT) 
cb31			        ;    <word code bytes> 
cb31 eb				ex de, hl 
cb32 2a c5 e5			ld hl,(os_tok_ptr) 
cb35				 
cb35				FORTH_RSP_NEXT 
cb35 cd f0 9a			call macro_forth_rsp_next 
cb38				endm 
# End of macro FORTH_RSP_NEXT
cb38			 
cb38			if DEBUG_FORTH_UWORD 
cb38						DMARK "UEX" 
cb38 f5				push af  
cb39 3a 4d cb			ld a, (.dmark)  
cb3c 32 6e ee			ld (debug_mark),a  
cb3f 3a 4e cb			ld a, (.dmark+1)  
cb42 32 6f ee			ld (debug_mark+1),a  
cb45 3a 4f cb			ld a, (.dmark+2)  
cb48 32 70 ee			ld (debug_mark+2),a  
cb4b 18 03			jr .pastdmark  
cb4d ..			.dmark: db "UEX"  
cb50 f1			.pastdmark: pop af  
cb51			endm  
# End of macro DMARK
cb51				CALLMONITOR 
cb51 cd 72 ee			call debug_vector  
cb54				endm  
# End of macro CALLMONITOR
cb54			endif 
cb54			 
cb54			 
cb54			 
cb54 eb				ex de, hl 
cb55 22 c5 e5			ld (os_tok_ptr), hl 
cb58				 
cb58				; Don't use next - Skips the first word in uword. 
cb58			 
cb58 c3 87 9f			jp exec1 
cb5b			;	NEXT 
cb5b			 
cb5b			 
cb5b			; eof 
# End of file forth_wordsv4.asm
cb5b			endif 
cb5b			;;;;;;;;;;;;;; Debug code 
cb5b			 
cb5b			 
cb5b			;if DEBUG_FORTH_PARSE 
cb5b .. 00		.nowordfound: db "No match",0 
cb64 .. 00		.compword:	db "Comparing word ",0 
cb74 .. 00		.nextwordat:	db "Next word at",0 
cb81 .. 00		.charmatch:	db "Char match",0 
cb8c			;endif 
cb8c			if DEBUG_FORTH_JP 
cb8c			.foundword:	db "Word match. Exec..",0 
cb8c			endif 
cb8c			;if DEBUG_FORTH_PUSH 
cb8c .. 00		.enddict:	db "Dict end. Push.",0 
cb9c .. 00		.push_str:	db "Pushing string",0 
cbab .. 00		.push_num:	db "Pushing number",0 
cbba .. 00		.data_sp:	db "SP:",0 
cbbe .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbd0 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cbe2 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbf4			;endif 
cbf4			;if DEBUG_FORTH_MALLOC 
cbf4 .. 00		.push_malloc:	db "Malloc address",0 
cc03			;endif 
cc03			 
cc03			 
cc03			 
cc03			; display malloc address and current data stack pointer  
cc03			 
cc03			malloc_error: 
cc03 d5				push de 
cc04 f5				push af 
cc05 e5				push hl 
cc06 cd af 8a			call clear_display 
cc09 11 29 cc			ld de, .mallocerr 
cc0c 3e 00			ld a,0 
cc0e			;	ld de,os_word_scratch 
cc0e cd c2 8a			call str_at_display 
cc11 3e 11			ld a, display_row_1+17 
cc13 11 6e ee			ld de, debug_mark 
cc16 cd c2 8a			call str_at_display 
cc19 cd d2 8a			call update_display 
cc1c				;call break_point_state 
cc1c cd 36 e3			call cin_wait 
cc1f			 
cc1f			;	ld a, ' ' 
cc1f			;	ld (os_view_disable), a 
cc1f cd d2 94			call bp_on 
cc22 e1				pop hl 
cc23 f1				pop af 
cc24 d1				pop de	 
cc25				CALLMONITOR 
cc25 cd 72 ee			call debug_vector  
cc28				endm  
# End of macro CALLMONITOR
cc28 c9				ret 
cc29			 
cc29 .. 00		.mallocerr: 	db "Malloc Error",0 
cc36			;if DEBUG_FORTH_PUSH 
cc36			display_data_sp: 
cc36 f5				push af 
cc37			 
cc37				; see if disabled 
cc37			 
cc37			 
cc37 3a 72 ee			ld a, (debug_vector) 
cc3a fe c9			cp $C9  ; RET 
cc3c				;ld a, (os_view_disable) 
cc3c				;cp '*' 
cc3c 28 67			jr z, .skipdsp 
cc3e			 
cc3e e5				push hl 
cc3f e5				push hl 
cc40 e5			push hl 
cc41 cd af 8a			call clear_display 
cc44 e1			pop hl 
cc45 7c				ld a,h 
cc46 21 c9 e5			ld hl, os_word_scratch 
cc49 cd dd 8f			call hexout 
cc4c e1				pop hl 
cc4d 7d				ld a,l 
cc4e 21 cb e5			ld hl, os_word_scratch+2 
cc51 cd dd 8f			call hexout 
cc54 21 cd e5			ld hl, os_word_scratch+4 
cc57 3e 00			ld a,0 
cc59 77				ld (hl),a 
cc5a 11 c9 e5			ld de,os_word_scratch 
cc5d 3e 28				ld a, display_row_2 
cc5f cd c2 8a				call str_at_display 
cc62 11 be cb			ld de, .wordinhl 
cc65 3e 00			ld a, display_row_1 
cc67			 
cc67 cd c2 8a				call str_at_display 
cc6a 11 6e ee			ld de, debug_mark 
cc6d 3e 11			ld a, display_row_1+17 
cc6f			 
cc6f cd c2 8a				call str_at_display 
cc72			 
cc72				; display current data stack pointer 
cc72 11 ba cb			ld de,.data_sp 
cc75 3e 30				ld a, display_row_2 + 8 
cc77 cd c2 8a				call str_at_display 
cc7a			 
cc7a 2a f1 e9			ld hl,(cli_data_sp) 
cc7d e5				push hl 
cc7e 7c				ld a,h 
cc7f 21 c9 e5			ld hl, os_word_scratch 
cc82 cd dd 8f			call hexout 
cc85 e1				pop hl 
cc86 7d				ld a,l 
cc87 21 cb e5			ld hl, os_word_scratch+2 
cc8a cd dd 8f			call hexout 
cc8d 21 cd e5			ld hl, os_word_scratch+4 
cc90 3e 00			ld a,0 
cc92 77				ld (hl),a 
cc93 11 c9 e5			ld de,os_word_scratch 
cc96 3e 33				ld a, display_row_2 + 11 
cc98 cd c2 8a				call str_at_display 
cc9b			 
cc9b			 
cc9b cd d2 8a			call update_display 
cc9e cd f2 89			call delay1s 
cca1 cd f2 89			call delay1s 
cca4 e1				pop hl 
cca5			.skipdsp: 
cca5 f1				pop af 
cca6 c9				ret 
cca7			 
cca7			display_data_malloc: 
cca7			 
cca7 f5				push af 
cca8 e5				push hl 
cca9 e5				push hl 
ccaa e5			push hl 
ccab cd af 8a			call clear_display 
ccae e1			pop hl 
ccaf 7c				ld a,h 
ccb0 21 c9 e5			ld hl, os_word_scratch 
ccb3 cd dd 8f			call hexout 
ccb6 e1				pop hl 
ccb7 7d				ld a,l 
ccb8 21 cb e5			ld hl, os_word_scratch+2 
ccbb cd dd 8f			call hexout 
ccbe 21 cd e5			ld hl, os_word_scratch+4 
ccc1 3e 00			ld a,0 
ccc3 77				ld (hl),a 
ccc4 11 c9 e5			ld de,os_word_scratch 
ccc7 3e 28				ld a, display_row_2 
ccc9 cd c2 8a				call str_at_display 
cccc 11 f4 cb			ld de, .push_malloc 
cccf 3e 00			ld a, display_row_1 
ccd1			 
ccd1 cd c2 8a				call str_at_display 
ccd4			 
ccd4				; display current data stack pointer 
ccd4 11 ba cb			ld de,.data_sp 
ccd7 3e 30				ld a, display_row_2 + 8 
ccd9 cd c2 8a				call str_at_display 
ccdc			 
ccdc 2a f1 e9			ld hl,(cli_data_sp) 
ccdf e5				push hl 
cce0 7c				ld a,h 
cce1 21 c9 e5			ld hl, os_word_scratch 
cce4 cd dd 8f			call hexout 
cce7 e1				pop hl 
cce8 7d				ld a,l 
cce9 21 cb e5			ld hl, os_word_scratch+2 
ccec cd dd 8f			call hexout 
ccef 21 cd e5			ld hl, os_word_scratch+4 
ccf2 3e 00			ld a,0 
ccf4 77				ld (hl),a 
ccf5 11 c9 e5			ld de,os_word_scratch 
ccf8 3e 33				ld a, display_row_2 + 11 
ccfa cd c2 8a				call str_at_display 
ccfd			 
ccfd cd d2 8a			call update_display 
cd00 cd f2 89			call delay1s 
cd03 cd f2 89			call delay1s 
cd06 e1				pop hl 
cd07 f1				pop af 
cd08 c9				ret 
cd09			;endif 
cd09			 
cd09			include "forth_autostart.asm" 
cd09			; list of commands to perform at system start up 
cd09			 
cd09			startcmds: 
cd09			;	dw test11 
cd09			;	dw test12 
cd09			;	dw test13 
cd09			;	dw test14 
cd09			;	dw test15 
cd09			;	dw test16 
cd09			;	dw test17 
cd09			;	dw ifthtest1 
cd09			;	dw ifthtest2 
cd09			;	dw ifthtest3 
cd09			;	dw mmtest1 
cd09			;	dw mmtest2 
cd09			;	dw mmtest3 
cd09			;	dw mmtest4 
cd09			;	dw mmtest5 
cd09			;	dw mmtest6 
cd09			;	dw iftest1 
cd09			;	dw iftest2 
cd09			;	dw iftest3 
cd09			;	dw looptest1 
cd09			;	dw looptest2 
cd09			;	dw test1 
cd09			;	dw test2 
cd09			;	dw test3 
cd09			;	dw test4 
cd09			;	dw game2r 
cd09			;	dw game2b1 
cd09			;	dw game2b2 
cd09			 
cd09				; start up words that are actually useful 
cd09			 
cd09 11 ce		    dw spi1 
cd0b 6a ce		    dw spi2 
cd0d f8 ce		    dw spi3 
cd0f a0 ce		    dw spi4 
cd11 cb ce		    dw spi5 
cd13 5e cf		    dw spi6 
cd15 b3 cf		    dw spi7 
cd17			 
cd17 0b d0		    dw spi8 
cd19 2a d0		    dw spi9 
cd1b 82 d0		    dw spi10 
cd1d			 
cd1d			; file editor 
cd1d 83 cd			dw edit1 
cd1f a4 cd			dw edit2 
cd21 d9 cd			dw edit3 
cd23			 
cd23 f5 d0			dw longread 
cd25 3c d1			dw clrstack 
cd27 6f d1			dw type 
cd29 5a d3			dw stest 
cd2b 93 d1			dw strncpy 
cd2d f0 d2			dw list 
cd2f f4 d1			dw start1 
cd31 04 d2			dw start2 
cd33			;	dw start3 
cd33 15 d2			dw start3b 
cd35 90 d2			dw start3c 
cd37			 
cd37				; (unit) testing words 
cd37			 
cd37 d1 d3			dw mtesta 
cd39 86 d4			dw mtestb 
cd3b 29 d5			dw mtestc 
cd3d de d5			dw mtestd 
cd3f 82 d6			dw mteste 
cd41			 
cd41				; demo/game words 
cd41			 
cd41 8e dd		        dw game3w 
cd43 bc dd		        dw game3p 
cd45 da dd		        dw game3sc 
cd47 0b de		        dw game3vsi 
cd49 37 de		        dw game3vs 
cd4b				 
cd4b 81 db			dw game2b 
cd4d ef db			dw game2bf 
cd4f 39 dc			dw game2mba 
cd51 cf dc			dw game2mbas 
cd53 11 dd			dw game2mb 
cd55			 
cd55 42 d8			dw game1 
cd57 53 d8			dw game1a 
cd59 b5 d8			dw game1b 
cd5b ea d8			dw game1c 
cd5d 20 d9			dw game1d 
cd5f 51 d9			dw game1s 
cd61 65 d9			dw game1t 
cd63 7a d9			dw game1f 
cd65 ae d9			dw game1z 
cd67 f2 d9			dw game1zz 
cd69			 
cd69 38 d7			dw test5 
cd6b 70 d7			dw test6 
cd6d a8 d7			dw test7 
cd6f bc d7			dw test8 
cd71 e8 d7			dw test9 
cd73 fe d7			dw test10 
cd75				 
cd75 c9 da		        dw ssv5 
cd77 ad da		        dw ssv4 
cd79 91 da		        dw ssv3 
cd7b 5b da		        dw ssv2 
cd7d e2 da		        dw ssv1 
cd7f 2a db		        dw ssv1cpm 
cd81			;	dw keyup 
cd81			;	dw keydown 
cd81			;	dw keyleft 
cd81			;	dw keyright 
cd81			;	dw 	keyf1 
cd81			;	dw keyf2 
cd81			;	dw keyf3 
cd81			;	dw keyf4 
cd81			;	dw keyf5 
cd81			;	dw keyf6 
cd81			;	dw keyf7 
cd81			;	dw keyf8 
cd81			;	dw keyf9 
cd81			;	dw keyf10 
cd81			;	dw keyf11 
cd81			;	dw keyf12 
cd81			;	dw keytab 
cd81			;	dw keycr 
cd81			;	dw keyhome 
cd81			;	dw keyend 
cd81			;	dw keybs 
cd81 00 00			db 0, 0	 
cd83			 
cd83			 
cd83			; File Editor 
cd83			 
cd83			; ( id - ) use 'e' to edit the displayed line 
cd83 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cda4 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdd9			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdd9 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
ce11			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
ce11			 
ce11			; SPI Net support words 
ce11			 
ce11			; v0! = node to send to 
ce11			; ( str count - ) 
ce11 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce6a			 
ce6a			; spiputchr ( char node - ) 
ce6a .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
cea0			 
cea0			; spigetchr ( - n ) 
cea0 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
cecb			 
cecb			; getnode ( - n ) 
cecb .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cef8			 
cef8			; ( str node - )  
cef8 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf5e			; store string ( str i - ) 
cf5e			 
cf5e			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf5e .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cfb3			 
cfb3			; get string ( addr i -  )    TO FIX 
cfb3			 
cfb3 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d00b			 
d00b			 
d00b			; NETCHAT (TODO) 
d00b			; Program to allow two nodes to chat with eachother 
d00b			; 
d00b			; v0 - target node 
d00b			;  
d00b			; accept input at 0,0 
d00b			; if input is string send spitype to target node 
d00b			; starting at row 2,0 , while spigetchr is not zero ->  
d00b			; 
d00b			; 
d00b			; TODO add paging of get request 
d00b			 
d00b			; ( node - ) 
d00b .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d02a .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d082 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
d0f5			 
d0f5			 
d0f5			; Long read of currently open file 
d0f5 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d13c			 
d13c			; clear stack  
d13c			 
d13c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
d16f			 
d16f			; type ( addr count - ) 
d16f .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
d193			 
d193			; some direct memory words 
d193			; strncpy ( len t f -- t ) 
d193			 
d193 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1f4			 
d1f4 .. 00		start1:     	db ": bpon $00 bp ;",0 
d204 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d215 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d290 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2f0			 
d2f0			 
d2f0			; a handy word to list items on the stack 
d2f0			 
d2f0 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d35a			 
d35a			 
d35a			; test stack  
d35a			; rnd8 stest 
d35a			 
d35a .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d3d1			 
d3d1			; random malloc and free cycles 
d3d1			 
d3d1 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d486			 
d486			; fixed malloc and free cycles 
d486			 
d486 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d529			 
d529			; fixed double string push and drop cycle  
d529			 
d529 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d5de			 
d5de			; consistent fixed string push and drop cycle  
d5de			 
d5de .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d682			 
d682 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d738			 
d738			;test1:		db ": aa 1 2 3 ;", 0 
d738			;test2:     	db "111 aa 888 999",0 
d738			;test3:     	db ": bb 77 ;",0 
d738			;test4:     	db "$02 $01 do i . loop bb",0 
d738			 
d738 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d770 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d7a8 .. 00		test7:     	db ": box hline vline ;",0 
d7bc .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d7e8 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d7fe .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d823 .. 00		test11:     	db "hello create .",0 
d832 .. 00		test12:     	db "hello2 create .",0 
d842			 
d842			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d842			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d842			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d842			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d842			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d842			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d842			 
d842			;iftest1:     	db "$0001 IF cls .",0 
d842			;iftest2:     	db "$0000 IF cls .",0 
d842			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d842			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d842			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d842			 
d842			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d842			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d842			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d842			 
d842			 
d842			 
d842			; a small guess the number game 
d842			 
d842 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d853 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d8b5			 
d8b5 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d8ea .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d920 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d951 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d965 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d97a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d9ae .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d9f2			 
d9f2			; Using 'ga' save a high score across multiple runs using external storage 
d9f2			 
d9f2 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
da5b			 
da5b			 
da5b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
da5b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
da5b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
da5b			 
da5b			; simple screen saver to test code memory reuse to destruction 
da5b			 
da5b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
da91 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
daad .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dac9 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dae2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
db2a .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
db81			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
db81			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
db81			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
db81			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
db81			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
db81			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
db81			 
db81			 
db81			 
db81			; minesweeper/battleship finding game 
db81			; draws a game board of random ship/mine positions 
db81			; user enters coords to see if it hits on 
db81			; game ends when all are hit 
db81			; when hit or miss says how many may be in the area 
db81			 
db81			; setup the game board and then hide it 
db81 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dbef .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dc39			; prompt for where to target 
dc39 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dccf .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dcf4			; TODO see if the entered coords hits or misses pushes char hit of miss 
dcf4 .. 00		game2mbht:      db ": mbckht nop ;",0 
dd03 .. 00		game2mbms:      db ": mbcms nop ;",0 
dd11			; TODO how many might be near by 
dd11 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
dd8e			 
dd8e			; Game 3 
dd8e			 
dd8e			; Vert scroller ski game - avoid the trees! 
dd8e			 
dd8e			; v0 score (ie turns) 
dd8e			; v1 player pos 
dd8e			; v2 left wall 
dd8e			; v3 right wall 
dd8e			 
dd8e			; Draw side walls randomly 
dd8e			 
dd8e .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
ddbc			 
ddbc			; Draw player 
ddbc .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
ddda			 
ddda			; TODO Get Key 
ddda			 
ddda			; TODO Move left right 
ddda			 
ddda			; scroll and move walls a bit 
ddda			 
ddda .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
de0b			 
de0b			; main game loop 
de0b			 
de0b .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
de37 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
de76			 
de76			; key board defs 
de76			 
de76 .. 00		keyup:       db ": keyup $05 ;",0 
de84 .. 00		keydown:       db ": keydown $0a ;",0 
de94 .. 00		keyleft:       db ": keyleft $0b ;",0 
dea4 .. 00		keyright:       db ": keyright $0c ;",0 
deb5 .. 00		keyf1:       db ": keyf1 $10 ;",0 
dec3 .. 00		keyf2:       db ": keyf2 $11 ;",0 
ded1 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dedf .. 00		keyf4:       db ": keyf4 $13 ;",0 
deed .. 00		keyf5:       db ": keyf5 $14 ;",0 
defb .. 00		keyf6:       db ": keyf6 $15 ;",0 
df09 .. 00		keyf7:       db ": keyf7 $16 ;",0 
df17 .. 00		keyf8:       db ": keyf8 $17 ;",0 
df25 .. 00		keyf9:       db ": keyf9 $18 ;",0 
df33 .. 00		keyf10:       db ": keyf10 $19 ;",0 
df42 .. 00		keyf11:       db ": keyf11 $1a ;",0 
df51 .. 00		keyf12:       db ": keyf12 $1b ;",0 
df60			 
df60 .. 00		keytab:       db ": keytab $09 ;",0 
df6f .. 00		keycr:       db ": keycr $0d ;",0 
df7d .. 00		keyhome:       db ": keyhome $0e ;",0 
df8d .. 00		keyend:       db ": keyend $0f ;",0 
df9c .. 00		keybs:       db ": keybs $08 ;",0 
dfaa			 
dfaa			   
dfaa			 
dfaa			 
dfaa			 
dfaa			; eof 
# End of file forth_autostart.asm
dfaa			 
dfaa			 
dfaa			 
dfaa			; stack over and underflow checks 
dfaa			 
dfaa			; init the words to detect the under/overflow 
dfaa			 
dfaa			chk_stk_init: 
dfaa				; a vague random number to check so we dont get any "lucky" hits 
dfaa 3e 2d			ld a, 45 
dfac 6f				ld l, a 
dfad 00				nop 
dfae 3e 17			ld a, 23 
dfb0 67				ld h, a 
dfb1			 
dfb1 22 ac e2			ld (chk_word), hl     ; the word we need to check against 
dfb4			 
dfb4			;	ld (chk_stund), hl	; stack points.... 
dfb4 22 00 ef			ld (chk_stovr), hl 
dfb7 22 ef e9			ld (chk_ret_und), hl 
dfba 22 ad e9			ld (chk_ret_ovr), hl 
dfbd 22 2b e9			ld (chk_loop_ovr), hl 
dfc0 22 29 e8			ld (chk_data_ovr), hl 
dfc3 c9				ret 
dfc4				 
dfc4			check_stacks: 
dfc4				; check all stack words 
dfc4			 
dfc4 e5				push hl 
dfc5 d5				push de 
dfc6			 
dfc6			;	ld de,(chk_word) 
dfc6			;	ld hl, (chk_stund)	; stack points.... 
dfc6			;	if DEBUG_STK_FAULT 
dfc6			;		DMARK "FAa" 
dfc6			;		CALLMONITOR 
dfc6			;	endif 
dfc6			;	call cmp16 
dfc6			;	jp z, .chk_faulta 
dfc6			; 
dfc6			;	ld de, sfaultsu 
dfc6			;	jp .chk_fault 
dfc6			 
dfc6 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
dfc9 ed 5b ac e2		ld de,(chk_word) 
dfcd				if DEBUG_STK_FAULT 
dfcd					DMARK "FAb" 
dfcd					CALLMONITOR 
dfcd				endif 
dfcd cd fa 8c			call cmp16 
dfd0 28 06			jr z, .chk_fault1 
dfd2 11 73 e0			ld de, sfaultso 
dfd5 c3 27 e0			jp .chk_fault 
dfd8			.chk_fault1:  
dfd8 2a ef e9			ld hl, (chk_ret_und) 
dfdb ed 5b ac e2		ld de,(chk_word) 
dfdf				if DEBUG_STK_FAULT 
dfdf					DMARK "FAU" 
dfdf					CALLMONITOR 
dfdf				endif 
dfdf cd fa 8c			call cmp16 
dfe2 ca eb df			jp z, .chk_fault2 
dfe5 11 83 e0			ld de, sfaultru 
dfe8 c3 27 e0			jp .chk_fault 
dfeb			.chk_fault2:  
dfeb 2a ad e9			ld hl, (chk_ret_ovr) 
dfee ed 5b ac e2		ld de,(chk_word) 
dff2				if DEBUG_STK_FAULT 
dff2					DMARK "FA1" 
dff2					CALLMONITOR 
dff2				endif 
dff2 cd fa 8c			call cmp16 
dff5 ca fe df			jp z, .chk_fault3 
dff8 11 91 e0			ld de, sfaultro 
dffb c3 27 e0			jp .chk_fault 
dffe			.chk_fault3:  
dffe 2a 2b e9			ld hl, (chk_loop_ovr) 
e001 ed 5b ac e2		ld de,(chk_word) 
e005				if DEBUG_STK_FAULT 
e005					DMARK "FA2" 
e005					CALLMONITOR 
e005				endif 
e005 cd fa 8c			call cmp16 
e008 ca 11 e0			jp z, .chk_fault4 
e00b 11 ab e0			ld de, sfaultlo 
e00e c3 27 e0			jp .chk_fault 
e011			.chk_fault4:  
e011 2a 29 e8			ld hl, (chk_data_ovr) 
e014 ed 5b ac e2		ld de,(chk_word) 
e018				if DEBUG_STK_FAULT 
e018					DMARK "FA3" 
e018					CALLMONITOR 
e018				endif 
e018 cd fa 8c			call cmp16 
e01b ca 24 e0			jp z, .chk_fault5 
e01e 11 c5 e0			ld de, sfaultdo 
e021 c3 27 e0			jp .chk_fault 
e024			 
e024			 
e024			.chk_fault5:  
e024 d1				pop de 
e025 e1				pop hl 
e026			 
e026 c9				ret 
e027			 
e027 cd af 8a		.chk_fault: 	call clear_display 
e02a 3e 28				ld a, display_row_2 
e02c cd c2 8a				call str_at_display 
e02f 11 55 e0				   ld de, .stackfault 
e032 3e 00				ld a, display_row_1 
e034 cd c2 8a				call str_at_display 
e037 11 6e ee				    ld de, debug_mark 
e03a 3e 11				ld a, display_row_1+17 
e03c cd c2 8a				call str_at_display 
e03f cd d2 8a				call update_display 
e042			 
e042				; prompt before entering montior for investigating issue 
e042			 
e042 3e 78			ld a, display_row_4 
e044 11 3b 98			ld de, endprog 
e047			 
e047 cd d2 8a			call update_display		 
e04a			 
e04a cd c1 9a			call next_page_prompt 
e04d			 
e04d d1				pop de 
e04e e1				pop hl 
e04f cd 8f 98				call monitor 
e052 c3 89 97				jp warmstart 
e055					;jp 0 
e055					;halt 
e055			 
e055			 
e055			 
e055 .. 00		.stackfault: 	db "Stack fault:",0 
e062			 
e062 .. 00		sfaultsu: 	db	"Stack under flow",0 
e073 .. 00		sfaultso: 	db	"Stack over flow",0 
e083 .. 00		sfaultru:	db "RTS underflow",0 
e091 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e0ab .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e0c5 .. 00		sfaultdo:	db "DTS overflow", 0 
e0d2			 
e0d2			 
e0d2			fault_dsp_under: 
e0d2 11 e4 e0			ld de, .dsp_under 
e0d5 c3 94 e1			jp .show_fault 
e0d8			 
e0d8			fault_rsp_under: 
e0d8 11 f2 e0			ld de, .rsp_under 
e0db c3 94 e1			jp .show_fault 
e0de			fault_loop_under: 
e0de 11 00 e1			ld de, .loop_under 
e0e1 c3 94 e1			jp .show_fault 
e0e4			 
e0e4 .. 00		.dsp_under: db "DSP Underflow",0 
e0f2 .. 00		.rsp_under: db "RSP Underflow",0 
e100 .. 00		.loop_under: db "LOOP Underflow",0 
e10f			 
e10f			 
e10f d5			type_faultn: 	push de 
e110 e5					push hl 
e111 cd af 8a				call clear_display 
e114 11 3b e1				   ld de, .typefaultn 
e117 3e 00				ld a, display_row_1 
e119 cd c2 8a				call str_at_display 
e11c 11 6e ee				    ld de, debug_mark 
e11f 3e 11				ld a, display_row_1+17 
e121 cd c2 8a				call str_at_display 
e124 cd d2 8a				call update_display 
e127			 
e127				; prompt before entering montior for investigating issue 
e127			 
e127 3e 78			ld a, display_row_4 
e129 11 3b 98			ld de, endprog 
e12c			 
e12c cd d2 8a			call update_display		 
e12f			 
e12f cd c1 9a			call next_page_prompt 
e132			 
e132 e5					push hl 
e133 d5					push de 
e134 cd 8f 98				call monitor 
e137 c3 89 97				jp warmstart 
e13a 76					halt 
e13b			 
e13b			 
e13b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e152			 
e152 d5			type_faults: 	push de 
e153 e5					push hl 
e154 cd af 8a				call clear_display 
e157 11 7d e1				   ld de, .typefaults 
e15a 3e 00				ld a, display_row_1 
e15c cd c2 8a				call str_at_display 
e15f 11 6e ee				    ld de, debug_mark 
e162 3e 11				ld a, display_row_1+17 
e164 cd c2 8a				call str_at_display 
e167 cd d2 8a				call update_display 
e16a			 
e16a				; prompt before entering montior for investigating issue 
e16a			 
e16a 3e 78			ld a, display_row_4 
e16c 11 3b 98			ld de, endprog 
e16f			 
e16f cd d2 8a			call update_display		 
e172			 
e172 cd c1 9a			call next_page_prompt 
e175			 
e175 e1					pop hl 
e176 d1					pop de 
e177 cd 8f 98				call monitor 
e17a c3 89 97				jp warmstart 
e17d			 
e17d			 
e17d .. 00		.typefaults: db "STR Type Expected TOS!",0 
e194			 
e194			.show_fault: 	 
e194 d5					push de 
e195 cd af 8a				call clear_display 
e198 d1					pop de 
e199 3e 00				ld a, display_row_1 
e19b cd c2 8a				call str_at_display 
e19e 11 6e ee				    ld de, debug_mark 
e1a1 3e 11				ld a, display_row_1+17 
e1a3 cd c2 8a				call str_at_display 
e1a6 cd d2 8a				call update_display 
e1a9			 
e1a9				; prompt before entering montior for investigating issue 
e1a9			 
e1a9 3e 78			ld a, display_row_4 
e1ab 11 3b 98			ld de, endprog 
e1ae			 
e1ae cd d2 8a			call update_display		 
e1b1			 
e1b1 cd c1 9a			call next_page_prompt 
e1b4			 
e1b4 e1					pop hl 
e1b5 d1					pop de 
e1b6 cd 8f 98				call monitor 
e1b9			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e1b9			; TODO Make optional fault restart to cli or warm boot? 
e1b9					;jp warmstart 
e1b9 c3 e1 97				jp cli 
e1bc 76					halt 
e1bd			 
e1bd			; handle the auto run of code from files in storage 
e1bd			 
e1bd			 
e1bd			include "forth_startup.asm" 
e1bd			; Which startup method to use? 
e1bd			; 
e1bd			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e1bd			; followed by loading of a list of scripts in eeprom 
e1bd			 
e1bd			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e1bd			; from eeprom 
e1bd			 
e1bd			; Select with define in main stubs 
e1bd			 
e1bd			if STARTUP_V1 
e1bd				include "forth_startupv1.asm" 
e1bd			; Startup script loading version 1 
e1bd			 
e1bd			; If SE storage is available first stage is to use the selected file 
e1bd			; then go through the eeprom list 
e1bd			 
e1bd .. 00		sprompt1: db "Startup load...",0 
e1cd .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e1e3			 
e1e3			 
e1e3			 
e1e3			 
e1e3			forth_startup: 
e1e3 21 09 cd			ld hl, startcmds 
e1e6 3e 00			ld a, 0 
e1e8 32 ea e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e1eb			 
e1eb e5			.start1:	push hl 
e1ec cd af 8a			call clear_display 
e1ef 11 bd e1			ld de, sprompt1 
e1f2 3e 00		        ld a, display_row_1 
e1f4 cd c2 8a			call str_at_display 
e1f7 11 cd e1			ld de, sprompt2 
e1fa 3e 28		        ld a, display_row_2 
e1fc cd c2 8a			call str_at_display 
e1ff e1				pop hl 
e200 e5				push hl 
e201 5e				ld e,(hl) 
e202 23				inc hl 
e203 56				ld d,(hl) 
e204 3e 50		        ld a, display_row_3 
e206 cd c2 8a			call str_at_display 
e209 cd d2 8a			call update_display 
e20c			 
e20c			 
e20c 3a ea e6			ld a, (os_last_cmd) 
e20f fe 00			cp 0 
e211 28 05			jr z, .startprompt 
e213 cd e6 89			call delay250ms 
e216 18 24			jr .startdo 
e218				 
e218				 
e218			 
e218			.startprompt: 
e218			 
e218 3e 9f			ld a,display_row_4 + display_cols - 1 
e21a 11 bf 9a		        ld de, endprg 
e21d cd c2 8a			call str_at_display 
e220 cd d2 8a			call update_display 
e223 cd f2 89			call delay1s 
e226 cd 36 e3			call cin_wait 
e229						 
e229 fe 2a			cp '*' 
e22b 28 5e			jr z, .startupend1 
e22d fe 23			cp '#' 
e22f 20 07			jr nz, .startno 
e231 3e 01			ld a, 1 
e233 32 ea e6			ld (os_last_cmd),a 
e236 18 04			jr .startdo 
e238 fe 31		.startno:	cp '1' 
e23a 28 3a			jr z,.startnxt  
e23c			 
e23c				; exec startup line 
e23c			.startdo:	 
e23c e1				pop hl 
e23d e5				push hl 
e23e				 
e23e 5e				ld e,(hl) 
e23f 23				inc hl 
e240 56				ld d,(hl) 
e241 eb				ex de,hl 
e242			 
e242 e5				push hl 
e243			 
e243 3e 00			ld a, 0 
e245				;ld a, FORTH_END_BUFFER 
e245 cd 45 91			call strlent 
e248 23				inc hl   ; include zero term to copy 
e249 06 00			ld b,0 
e24b 4d				ld c,l 
e24c e1				pop hl 
e24d 11 c4 e2			ld de, scratch 
e250 ed b0			ldir 
e252			 
e252			 
e252 21 c4 e2			ld hl, scratch 
e255 cd 44 9f			call forthparse 
e258 cd 84 9f			call forthexec 
e25b cd 96 9e			call forthexec_cleanup 
e25e			 
e25e 3e 78			ld a, display_row_4 
e260 11 3b 98			ld de, endprog 
e263			 
e263 cd d2 8a			call update_display		 
e266			 
e266 3a ea e6			ld a, (os_last_cmd) 
e269 fe 00			cp 0 
e26b 20 09			jr nz, .startnxt 
e26d cd c1 9a			call next_page_prompt 
e270 cd af 8a		        call clear_display 
e273 cd d2 8a			call update_display		 
e276			 
e276				; move onto next startup line? 
e276			.startnxt: 
e276			 
e276 cd e6 89			call delay250ms 
e279 e1				pop hl 
e27a			 
e27a 23				inc hl 
e27b 23				inc hl 
e27c			 
e27c e5				push hl 
e27d 5e				ld e, (hl) 
e27e 23				inc hl 
e27f 56				ld d, (hl) 
e280 e1				pop hl 
e281				; TODO replace 0 test 
e281			 
e281 eb				ex de, hl 
e282 cd 05 8d			call ishlzero 
e285			;	ld a,e 
e285			;	add d 
e285			;	cp 0    ; any left to do? 
e285 eb				ex de, hl 
e286 c2 eb e1			jp nz, .start1 
e289 18 01			jr .startupend 
e28b			 
e28b e1			.startupend1: pop hl 
e28c			.startupend: 
e28c			 
e28c cd af 8a			call clear_display 
e28f cd d2 8a			call update_display 
e292 c9				ret 
e293			if STORAGE_SE 
e293			 
e293			sprompt3: db "Loading from start-up file?:",0 
e293			sprompt4: db "(Y=Any key/N=No)",0 
e293			 
e293			 
e293			forth_autoload: 
e293			 
e293				; load block 0 of store 1 
e293				 
e293				ld a, $fe      ; bit 0 clear 
e293				ld (spi_device), a 
e293			 
e293				call storage_get_block_0 
e293			 
e293				ld a, (store_page+STORE_0_AUTOFILE) 
e293			 
e293				cp 0 
e293				ret z     ; auto start not enabled 
e293			 
e293				call clear_display 
e293			 
e293				; set bank 
e293			 
e293					ld a, (store_page+STORE_0_BANKRUN) 
e293					ld (spi_device), a 
e293			 
e293				; get file id to load from and get the file name to display 
e293			 
e293					ld a, (store_page+STORE_0_FILERUN) 
e293			 
e293					ld l, 0 
e293					ld h, a 
e293					ld de, store_page 
e293			 
e293					if DEBUG_FORTH_WORDS 
e293						DMARK "ASp" 
e293						CALLMONITOR 
e293					endif 
e293					call storage_read 
e293			 
e293					if DEBUG_FORTH_WORDS 
e293						DMARK "ASr" 
e293						CALLMONITOR 
e293					endif 
e293			 
e293					call ishlzero 
e293					ret z             ; file not found 
e293			 
e293					ld a, display_row_2 + 10 
e293					ld de, store_page+3 
e293					call str_at_display 
e293				 
e293			; 
e293			 
e293				ld a, display_row_1+5 
e293				ld de, sprompt3 
e293				call str_at_display 
e293				ld a, display_row_3+15 
e293				ld de, sprompt4 
e293				call str_at_display 
e293			 
e293				call update_display 
e293			 
e293				call cin_wait 
e293				cp 'n' 
e293				ret z 
e293				cp 'N' 
e293				ret z 
e293			 
e293				call delay1s 
e293			 
e293				ld a, (store_page+2) 
e293				ld (store_openmaxext), a    ; save count of ext 
e293				ld a, 1  
e293				ld (store_openext), a    ; save count of ext 
e293			 
e293			.autof:  
e293				ld l , a 
e293				 
e293				ld a, (store_page) 
e293				ld h, a	 
e293				ld de, store_page 
e293					if DEBUG_FORTH_WORDS 
e293						DMARK "ASl" 
e293						CALLMONITOR 
e293					endif 
e293					call storage_read 
e293				call ishlzero 
e293				ret z 
e293			;	jr z, .autoend 
e293			 
e293					if DEBUG_FORTH_WORDS 
e293						DMARK "ASc" 
e293						CALLMONITOR 
e293					endif 
e293				ld de, store_page+2 
e293				ld a, display_row_4 
e293				call str_at_display 
e293			 
e293				call update_display 
e293				call delay250ms 
e293			 
e293			 
e293			 
e293				ld hl, store_page+2 
e293				call forthparse 
e293				call forthexec 
e293				call forthexec_cleanup 
e293			 
e293				 
e293				ld a, (store_openext) 
e293				inc a 
e293				ld (store_openext), a    ; save count of ext 
e293			 
e293				jr .autof 
e293			;.autofdone: 
e293			; 
e293			;		if DEBUG_FORTH_WORDS 
e293			;			DMARK "ASx" 
e293			;			CALLMONITOR 
e293			;		endif 
e293			;;	call clear_display 
e293			;	ret 
e293			 
e293			 
e293			 
e293			endif 
# End of file forth_startupv1.asm
e293			endif 
e293			if STARTUP_V2 
e293				include "forth_startupv2.asm" 
e293			endif 
e293			 
# End of file forth_startup.asm
e293			 
e293			; eof 
# End of file forth_kernel.asm
e293			;include "nascombasic.asm" 
e293			 
e293			 
e293			; find out where the code ends if loaded into RAM (for SC114) 
e293			;endofcode:  
e293			;	nop 
e293			 
e293			 
e293			; eof 
e293			 
# End of file main.asm
e293			;include "firmware_lcd_4x40.asm" 
e293			;;include "firmware_lcd_4x20.asm" 
e293			include "firmware_serial_display.asm" 
e293			 
e293			; Serial display interface for SC114 
e293			 
e293			 
e293			display_row_1: equ 0 
e293			display_row_2: equ display_row_1+display_cols 
e293			display_row_3: equ display_row_2 + display_cols 
e293			display_row_4: equ display_row_3 + display_cols 
e293			 
e293			kLCDWidth:  EQU display_cols             ;Width in characters 
e293			kLCD_Line1: EQU 0x00  
e293			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e293			; E1 
e293			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e293			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e293			 
e293			lcd_init: 
e293				; no init as handled by the SCM bios 
e293 c9				ret 
e294			 
e294			 
e294			; low level functions for direct screen writes 
e294			 
e294			; output char at pos? 
e294			fLCD_Str: 
e294			        ;out (SC114_SIO_1_OUT),a 
e294 c5				push bc 
e295 0e 02			ld c, $02 
e297 f7				rst $30 
e298 c1				pop bc 
e299 c9				ret 
e29a			 
e29a			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e29a			fLCD_Pos: 
e29a				; use ASCII escape to position 
e29a			        ;out (SC114_SIO_1_OUT),a 
e29a c5				push bc 
e29b 0e 02			ld c, $02 
e29d f7				rst $30 
e29e c1				pop bc 
e29f			 
e29f c9				ret 
e2a0			 
e2a0			; output char at pos 
e2a0			fLCD_Data: 
e2a0			      ;  out (SC114_SIO_1_OUT),a 
e2a0 c5				push bc 
e2a1 0e 02			ld c, $02 
e2a3 f7				rst $30 
e2a4 c1				pop bc 
e2a5			 
e2a5 c9				ret 
e2a6			 
e2a6			; ascii cls  
e2a6			 
e2a6 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e2aa			 
e2aa			; write the frame buffer given in hl to hardware  
e2aa			write_display: 
e2aa			 
e2aa			API: equ 0 
e2aa			 
e2aa			if API 
e2aa				push bc 
e2aa				ld b, 4 
e2aa			 
e2aa			        ld (display_write_tmp), hl 	  
e2aa			 
e2aa				; clear and home cursor 
e2aa			 
e2aa				ld c, 6 
e2aa				ld de, .cls 
e2aa				rst $30 
e2aa			 
e2aa			 
e2aa			.writeln: 
e2aa			 
e2aa				ld de, (display_write_tmp) 
e2aa				ld c, 6 
e2aa				rst $30 
e2aa				ld c, 7 
e2aa				rst $30 
e2aa			 
e2aa				ld hl, (display_write_tmp) 
e2aa				ld de, display_cols 
e2aa				add hl,de 
e2aa				ld (display_write_tmp),hl 
e2aa			 
e2aa				djnz  .writeln 
e2aa			 
e2aa				pop bc 
e2aa			 
e2aa			 
e2aa				ret 
e2aa			endif 
e2aa e5				push hl 
e2ab c5				push bc 
e2ac d5				push de 
e2ad			 
e2ad			;	ld c, 2 
e2ad			;	;ld de, .cls 
e2ad			;	ld a, 27 
e2ad			;	rst $30 
e2ad			;	ld c, 2 
e2ad			;	;ld de, .cls 
e2ad			;	ld a, '[' 
e2ad			;	rst $30 
e2ad			; 
e2ad			;	ld c, 2 
e2ad			;	;ld de, .cls 
e2ad			;	ld a, 'H' 
e2ad			;	rst $30 
e2ad			; 
e2ad			 
e2ad 0e 02			ld c, 2 
e2af				;ld de, .cls 
e2af 3e 1b			ld a, 27 
e2b1 f7				rst $30 
e2b2			 
e2b2			 
e2b2 0e 02			ld c, 2 
e2b4				;ld de, .cls 
e2b4 3e 5b			ld a, '[' 
e2b6 f7				rst $30 
e2b7 0e 02			ld c, 2 
e2b9				;ld de, .cls 
e2b9 3e 32			ld a, '2' 
e2bb f7				rst $30 
e2bc 0e 02			ld c, 2 
e2be				;ld de, .cls 
e2be 3e 4a			ld a, 'J' 
e2c0 f7				rst $30 
e2c1 d1				pop de 
e2c2 c1				pop bc 
e2c3 e1				pop hl 
e2c4			 
e2c4			 
e2c4 22 cc eb		        ld (display_write_tmp), hl 	  
e2c7 3e 00			ld a, kLCD_Line1 
e2c9			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e2c9 06 28			ld b, display_cols 
e2cb ed 5b cc eb		ld de, (display_write_tmp) 
e2cf cd 2d e3			call write_len_string 
e2d2				 
e2d2			 
e2d2 e5			push hl 
e2d3 d5			push de 
e2d4 c5			push bc 
e2d5 0e 07			ld c, 7 
e2d7 f7				rst $30 
e2d8 c1			pop bc 
e2d9 d1			pop de 
e2da e1			pop hl 
e2db			 
e2db				 
e2db 2a cc eb			ld hl, (display_write_tmp) 
e2de 11 28 00			ld de, display_cols 
e2e1 19				add hl,de 
e2e2 22 cc eb			ld (display_write_tmp),hl 
e2e5			 
e2e5				 
e2e5 3e 28			ld a, kLCD_Line2 
e2e7			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e2e7 06 28			ld b, display_cols 
e2e9 ed 5b cc eb		ld de, (display_write_tmp) 
e2ed cd 2d e3			call write_len_string 
e2f0				 
e2f0 2a cc eb			ld hl, (display_write_tmp) 
e2f3 11 28 00			ld de, display_cols 
e2f6 19				add hl,de 
e2f7 22 cc eb			ld (display_write_tmp),hl 
e2fa			 
e2fa e5			push hl 
e2fb d5			push de 
e2fc c5			push bc 
e2fd 0e 07			ld c, 7 
e2ff f7				rst $30 
e300 c1			pop bc 
e301 d1			pop de 
e302 e1			pop hl 
e303			 
e303				 
e303 3e 50			ld a, kLCD_Line3 
e305			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e305 06 28			ld b, display_cols 
e307 ed 5b cc eb		ld de, (display_write_tmp) 
e30b cd 2d e3			call write_len_string 
e30e				 
e30e 2a cc eb			ld hl, (display_write_tmp) 
e311 11 28 00			ld de, display_cols 
e314 19				add hl,de 
e315 22 cc eb			ld (display_write_tmp),hl 
e318			 
e318 e5			push hl 
e319 d5			push de 
e31a c5			push bc 
e31b 0e 07			ld c, 7 
e31d f7				rst $30 
e31e c1			pop bc 
e31f d1			pop de 
e320 e1			pop hl 
e321			 
e321				 
e321 3e 78			ld a, kLCD_Line4 
e323			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e323 06 28			ld b, display_cols 
e325 ed 5b cc eb		ld de, (display_write_tmp) 
e329 cd 2d e3			call write_len_string 
e32c c9					ret 
e32d			 
e32d			 
e32d				; write out a fixed length string given in b from de 
e32d			 
e32d 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e32e cd a0 e2		            CALL fLCD_Data      ;Write character to display 
e331 13				inc de 
e332 10 f9			djnz write_len_string 
e334 c9				ret 
e335			 
e335			 
e335			; eof 
# End of file firmware_serial_display.asm
e335			;include "firmware_key_5x10.asm" 
e335			;;include "firmware_key_4x10.asm" 
e335			include "firmware_key_serial.asm" 
e335			; Serial keyboard interface for SC114 
e335			 
e335			key_init: 
e335				; no init as handled by the SCM bios 
e335 c9				ret 
e336			 
e336			 
e336			cin_wait: 
e336			;	ld a, 0 
e336			;	ret 
e336			 
e336				;in a,(SC114_SIO_1_IN) 
e336			        ; Use SCM API to get from whatever console device we are using 
e336 c5				push bc 
e337 0e 01			ld c, $01 
e339 f7				rst $30 
e33a c1				pop bc 
e33b c9				ret 
e33c			 
e33c			cin: 
e33c			 
e33c			 
e33c c5				push bc 
e33d			 
e33d				; any key waiting to process? 
e33d 0e 03			ld c, $03 
e33f f7				rst $30 
e340 28 05			jr z, .cin_skip 
e342			 
e342				; yep, get it 
e342			 
e342 0e 01			ld c, $01 
e344 f7				rst $30 
e345 c1				pop bc 
e346 c9				ret 
e347			.cin_skip: 
e347 3e 00			ld a, 0 
e349 c1				pop bc 
e34a c9				ret 
e34b			 
e34b			 
e34b			 
e34b			 
# End of file firmware_key_serial.asm
e34b			endofcode:  
e34b			baseram:  
e34b 00				nop 
e34c			 
e34c			heap_start: equ baseram+15  ; Starting address of heap 
e34c			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e34c			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e34c			;VDU:  EQU     endofcode           ; BASIC Work space 
e34c			; eof 
e34c			 
# End of file os_mega_sc114.asm
e34c
