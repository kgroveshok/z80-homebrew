# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 51 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_write_tmp-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd 80 0b				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd 80 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd 80 0b				call clear_display  
0137			  
0137			  
0137 cd 22 63				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 10 64			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 50 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd a3 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd 85 0b			call fill_display  
014e cd a3 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd 85 0b			call fill_display  
0159 cd a3 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd 85 0b			call fill_display  
0164 cd a3 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 84 17			ld de, prom_bootmsg  
016f cd 93 0b			call str_at_display  
0172 cd a3 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 99 17			ld de, prom_bootmsg1  
0180 cd 93 0b			call str_at_display  
0183 cd a3 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 7d ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd ae 15			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 84 ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd ae 15			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 84 ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd ae 15			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd d6 0d				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 7d ea				ld hl, (store_tmp1) 
0210 11 87 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd ae 15			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 43 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd ae 15			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd ae 15			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd ae 15			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd ae 15			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd d6 0d			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 84 ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd ae 15			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd ae 15			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 84 ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 84 ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd ae 15			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 85 ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd ae 15			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd ae 15			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 84 ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 85 ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 87 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 90 ea			ld hl, store_page+3+9 
03b5 3a 69 ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 84 ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd ae 15			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd ae 15			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd ad 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd ad 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd ae 15			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 87 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd ae 15			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 84 ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd ae 15			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd ae 15			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd d6 0d			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 84 ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd d6 0d			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd ae 15			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 84 ea			ld a, (store_page)	; get file id 
0510 32 78 ea			ld (store_tmpid), a 
0513			 
0513 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
0516 32 77 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 84 ea			ld (store_page), a 
051f 32 85 ea			ld (store_page+1),a 
0522 11 84 ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd ae 15			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 77 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 78 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd ae 15			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd d6 0d			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 84 ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 84 ea			ld (store_page), a 
0582 32 85 ea			ld (store_page+1),a 
0585 11 84 ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd ae 15			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd ae 15			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd cb 0d				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd ad 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd cb 0d				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd ad 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd ae 15			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd ae 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd ad 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd ad 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd ae 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 84 ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 84 ea			ld (store_page),a 
06a3				 
06a3 32 78 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 84 ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd ae 15			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 84 ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd ae 15			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 6f ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd ae 15			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 6f ea			ld (store_tmppageid), hl 
0715				 
0715 3a 78 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 84 ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 85 ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 86 ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd ae 15			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 16 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd ae 15			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd ae 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 6f ea			ld hl,(store_tmppageid) 
078b 11 84 ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd ae 15			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 78 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd ae 15			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 71 ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 72 ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 73 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd ae 15			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 71 ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 72 ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 73 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd ae 15			call break_point_state  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd d6 0d			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 75 ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 71 ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 72 ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 73 ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd ae 15			call break_point_state  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd ad 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 77 ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 71 ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 72 ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 73 ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd ae 15			call break_point_state  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 7f ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd ad 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 71 ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 72 ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 73 ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd ae 15			call break_point_state  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 71 ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 72 ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 73 ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd ae 15			call break_point_state  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 71 ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 72 ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 73 ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd ae 15			call break_point_state  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd d6 0d			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 75 ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 71 ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 72 ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 73 ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd ae 15			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 71 ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 72 ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 73 ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd ae 15			call break_point_state  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 71 ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 72 ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 73 ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd ae 15			call break_point_state  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 71 ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 72 ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 73 ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd ae 15			call break_point_state  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 78 ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 78 ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd d6 0d			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 6f ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 71 ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 72 ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 73 ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd ae 15			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 84 ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 71 ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 72 ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 73 ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd ae 15			call break_point_state  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 86 ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 86 ea			ld (store_page+2), a 
09e3 32 77 ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 71 ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 72 ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 73 ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd ae 15			call break_point_state  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 6f ea			ld hl, (store_tmppageid) 
0a05 11 84 ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd d6 0d			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 6f ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 71 ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 72 ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 73 ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd ae 15			call break_point_state  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 84 ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 78 ea				ld a, (store_tmpid) 
0a4b 32 84 ea				ld (store_page), a   ; file id 
0a4e 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 85 ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 86 ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 71 ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 72 ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 73 ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd ae 15			call break_point_state  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 6f ea			ld hl, (store_tmppageid) 
0a85 11 84 ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 71 ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 72 ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 73 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd ae 15			call break_point_state  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 78 ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 84 ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 85 ea			ld de, store_page+1 
0ac1 01 18 01			ld bc, STORE_BLOCK_LOG 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; information window 
0b11			 
0b11			; pass hl with 1st string to display 
0b11			; pass de with 2nd string to display 
0b11			 
0b11			info_panel: 
0b11 e5				push hl 
0b12			 
0b12 2a d2 eb			ld hl, (display_fb_active) 
0b15 e5				push hl    ; future de destination 
0b16 21 b7 ed				ld hl, display_fb0 
0b19 22 d2 eb				ld (display_fb_active), hl 
0b1c			 
0b1c			;	call clear_display 
0b1c			 
0b1c				if BASE_CPM 
0b1c 3e 2e			ld a, '.' 
0b1e				else 
0b1e				ld a, 165 
0b1e				endif 
0b1e cd 85 0b			call fill_display 
0b21			 
0b21			 
0b21 3e 55			ld a, display_row_3 + 5 
0b23 cd 93 0b			call str_at_display 
0b26			 
0b26 e1				pop hl 
0b27 d1				pop de 
0b28			 
0b28 e5				push hl 
0b29			 
0b29			 
0b29 3e 2d			ld a, display_row_2 + 5 
0b2b cd 93 0b			call str_at_display 
0b2e			 
0b2e			 
0b2e cd a3 0b			call update_display 
0b31 cd 97 1b			call next_page_prompt 
0b34 cd 80 0b			call clear_display 
0b37			 
0b37				 
0b37 21 16 ed				ld hl, display_fb1 
0b3a 22 d2 eb				ld (display_fb_active), hl 
0b3d cd a3 0b			call update_display 
0b40			 
0b40 e1				pop hl 
0b41			 
0b41 c9				ret 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			; TODO windowing? 
0b42			 
0b42			; TODO scroll line up 
0b42			 
0b42			scroll_up: 
0b42			 
0b42 e5				push hl 
0b43 d5				push de 
0b44 c5				push bc 
0b45			 
0b45				; get frame buffer  
0b45			 
0b45 2a d2 eb			ld hl, (display_fb_active) 
0b48 e5				push hl    ; future de destination 
0b49			 
0b49 11 28 00			ld  de, display_cols 
0b4c 19				add hl, de 
0b4d			 
0b4d d1				pop de 
0b4e			 
0b4e				;ex de, hl 
0b4e 01 9f 00			ld bc, display_fb_len -1  
0b51			;if DEBUG_FORTH_WORDS 
0b51			;	DMARK "SCL" 
0b51			;	CALLMONITOR 
0b51			;endif	 
0b51 ed b0			ldir 
0b53			 
0b53				; wipe bottom row 
0b53			 
0b53			 
0b53 2a d2 eb			ld hl, (display_fb_active) 
0b56 11 a0 00			ld de, display_cols*display_rows 
0b59 19				add hl, de 
0b5a 06 28			ld b, display_cols 
0b5c 3e 20			ld a, ' ' 
0b5e			.scwipe: 
0b5e 77				ld (hl), a 
0b5f 2b				dec hl 
0b60 10 fc			djnz .scwipe 
0b62			 
0b62				;pop hl 
0b62			 
0b62 c1				pop bc 
0b63 d1				pop de 
0b64 e1				pop hl 
0b65			 
0b65 c9				ret 
0b66			 
0b66			 
0b66			;scroll_upo: 
0b66			;	ld de, display_row_1 
0b66			 ;	ld hl, display_row_2 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			;	ld de, display_row_2 
0b66			 ;	ld hl, display_row_3 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			;	ld de, display_row_3 
0b66			 ;	ld hl, display_row_4 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			 
0b66			; TODO clear row 4 
0b66			 
0b66			;	ret 
0b66			 
0b66				 
0b66			scroll_down: 
0b66			 
0b66 e5				push hl 
0b67 d5				push de 
0b68 c5				push bc 
0b69			 
0b69				; get frame buffer  
0b69			 
0b69 2a d2 eb			ld hl, (display_fb_active) 
0b6c			 
0b6c 11 9f 00			ld de, display_fb_len - 1 
0b6f 19				add hl, de 
0b70			 
0b70 e5			push hl    ; future de destination 
0b71			 
0b71 11 28 00			ld  de, display_cols 
0b74 ed 52			sbc hl, de 
0b76			 
0b76			 
0b76 d1				pop de 
0b77			 
0b77			;	ex de, hl 
0b77 01 9f 00			ld bc, display_fb_len -1  
0b7a			 
0b7a			 
0b7a				 
0b7a			 
0b7a ed b0			ldir 
0b7c			 
0b7c				; wipe bottom row 
0b7c			 
0b7c			 
0b7c			;	ld hl, (display_fb_active) 
0b7c			;;	ld de, display_cols*display_rows 
0b7c			;;	add hl, de 
0b7c			;	ld b, display_cols 
0b7c			;	ld a, ' ' 
0b7c			;.scwiped: 
0b7c			;	ld (hl), a 
0b7c			;	dec hl 
0b7c			;	djnz .scwiped 
0b7c			 
0b7c				;pop hl 
0b7c			 
0b7c c1				pop bc 
0b7d d1				pop de 
0b7e e1				pop hl 
0b7f			 
0b7f c9				ret 
0b80			;scroll_down: 
0b80			;	ld de, display_row_4 
0b80			;	ld hl, display_row_3 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;	ld de, display_row_3 
0b80			; 	ld hl, display_row_2 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;	ld de, display_row_2 
0b80			;	ld hl, display_row_1 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;;; TODO clear row 1 
0b80			;	ret 
0b80			 
0b80			 
0b80			 
0b80			 
0b80			 
0b80			; clear active frame buffer 
0b80			 
0b80			clear_display: 
0b80 3e 20			ld a, ' ' 
0b82 c3 85 0b			jp fill_display 
0b85			 
0b85			; fill active frame buffer with a char in A 
0b85			 
0b85			fill_display: 
0b85 06 a0			ld b,display_fb_len 
0b87 2a d2 eb			ld hl, (display_fb_active) 
0b8a 77			.fd1:	ld (hl),a 
0b8b 23				inc hl 
0b8c 10 fc			djnz .fd1 
0b8e 23				inc hl 
0b8f 3e 00			ld a,0 
0b91 77				ld (hl),a 
0b92			 
0b92			 
0b92 c9				ret 
0b93			; Write string (DE) at pos (A) to active frame buffer 
0b93			 
0b93 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0b96 06 00					ld b,0 
0b98 4f					ld c,a 
0b99 09					add hl,bc 
0b9a 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b9b b7			            OR   A              ;Null terminator? 
0b9c c8			            RET  Z              ;Yes, so finished 
0b9d 77					ld (hl),a 
0b9e 23				inc hl 
0b9f 13			            INC  DE             ;Point to next character 
0ba0 18 f8		            JR   .sad1     ;Repeat 
0ba2 c9					ret 
0ba3			 
0ba3			; using current frame buffer write to physical display 
0ba3			 
0ba3			update_display: 
0ba3 e5				push hl 
0ba4 2a d2 eb			ld hl, (display_fb_active) 
0ba7 cd 5f 63			call write_display 
0baa e1				pop hl 
0bab c9				ret 
0bac			 
0bac			; TODO scrolling 
0bac			 
0bac			 
0bac			; move cursor right one char 
0bac			cursor_right: 
0bac			 
0bac				; TODO shift right 
0bac				; TODO if beyond max col 
0bac				; TODO       cursor_next_line 
0bac			 
0bac c9				ret 
0bad			 
0bad			 
0bad			cursor_next_line: 
0bad				; TODO first char 
0bad				; TODO line down 
0bad				; TODO if past last row 
0bad				; TODO    scroll up 
0bad			 
0bad c9				ret 
0bae			 
0bae			cursor_left: 
0bae				; TODO shift left 
0bae				; TODO if beyond left  
0bae				; TODO     cursor prev line 
0bae				 
0bae c9				ret 
0baf			 
0baf			cursor_prev_line: 
0baf				; TODO last char 
0baf				; TODO line up 
0baf				; TODO if past first row 
0baf				; TODO   scroll down 
0baf			 
0baf c9				ret 
0bb0			 
0bb0			 
0bb0			cout: 
0bb0				; A - char 
0bb0 c9				ret 
0bb1			 
0bb1			 
0bb1			; Display a menu and allow item selection (optional toggle items) 
0bb1			; 
0bb1			; format: 
0bb1			; hl pointer to word array with zero term for items 
0bb1			; e.g.    db item1 
0bb1			;         db .... 
0bb1			;         db 0 
0bb1			; 
0bb1			; a = starting menu item  
0bb1			; 
0bb1			; de = pointer item toggle array   (todo) 
0bb1			; 
0bb1			; returns item selected in a 1-... 
0bb1			; returns 0 if back button pressed 
0bb1			; 
0bb1			; NOTE: Uses system frame buffer to display 
0bb1			; 
0bb1			; LEFT, Q = go back 
0bb1			; RIGHT, SPACE, CR = select 
0bb1			; UP, A - Up 
0bb1			; DOWN, Z - Down 
0bb1			 
0bb1			 
0bb1			 
0bb1			 
0bb1			 
0bb1			menu: 
0bb1			 
0bb1					; keep array pointer 
0bb1			 
0bb1 22 7d ea				ld (store_tmp1), hl 
0bb4 32 7b ea				ld (store_tmp2), a 
0bb7			 
0bb7					; check for key bounce 
0bb7			 
0bb7			if BASE_KEV 
0bb7			 
0bb7			.mbounce:	call cin 
0bb7					cp 0 
0bb7					jr nz, .mbounce 
0bb7			endif 
0bb7					; for ease use ex 
0bb7			 
0bb7					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bb7 21 b7 ed				ld hl, display_fb0 
0bba 22 d2 eb				ld (display_fb_active), hl 
0bbd			 
0bbd cd 80 0b		.mloop:		call clear_display 
0bc0 cd a3 0b				call update_display 
0bc3			 
0bc3					; draw selection id '>' at 1 
0bc3			 
0bc3					; init start of list display 
0bc3			 
0bc3 3e 05				ld a, 5 
0bc5 32 79 ea				ld (store_tmp3), a   ; display row count 
0bc8 3a 7b ea				ld a,( store_tmp2) 
0bcb 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bce			 
0bce					 
0bce			.mitem:	 
0bce			 
0bce			 
0bce 3a 7c ea				ld a,(store_tmp2+1) 
0bd1 6f					ld l, a 
0bd2 26 00				ld h, 0 
0bd4 29					add hl, hl 
0bd5 ed 5b 7d ea			ld de, (store_tmp1) 
0bd9 19					add hl, de 
0bda 7e					ld a, (hl) 
0bdb 23					inc hl 
0bdc 66					ld h,(hl) 
0bdd 6f					ld l, a 
0bde			 
0bde cd d6 0d				call ishlzero 
0be1 28 1a				jr z, .mdone 
0be3			 
0be3 eb					ex de, hl 
0be4 3a 79 ea				ld a, (store_tmp3) 
0be7 cd 93 0b				call str_at_display 
0bea					 
0bea			 
0bea					; next item 
0bea 3a 7c ea				ld a, (store_tmp2+1) 
0bed 3c					inc a 
0bee 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bf1			 
0bf1			 		; next row 
0bf1			 
0bf1 3a 79 ea				ld a, (store_tmp3) 
0bf4 c6 28				add display_cols 
0bf6 32 79 ea				ld (store_tmp3), a 
0bf9			 
0bf9					; at end of screen? 
0bf9			 
0bf9 fe 10				cp display_rows*4 
0bfb 20 d1				jr nz, .mitem 
0bfd			 
0bfd			 
0bfd			.mdone: 
0bfd cd d6 0d				call ishlzero 
0c00 28 08				jr z, .nodn 
0c02			 
0c02 3e 78				ld a, display_row_4 
0c04 11 83 0c				ld de, .mdown 
0c07 cd 93 0b				call str_at_display 
0c0a			 
0c0a					; draw options to fill the screens with active item on line 1 
0c0a					; if current option is 2 or more then display ^ in top 
0c0a			 
0c0a 3a 7b ea		.nodn:		ld a, (store_tmp2) 
0c0d fe 00				cp 0 
0c0f 28 08				jr z, .noup 
0c11			 
0c11 3e 00				ld a, 0 
0c13 11 81 0c				ld de, .mup 
0c16 cd 93 0b				call str_at_display 
0c19			 
0c19 3e 02		.noup:		ld a, 2 
0c1b 11 7f 0c				ld de, .msel 
0c1e cd 93 0b				call str_at_display 
0c21			 
0c21					; if current option + 1 is not null then display V in bottom 
0c21					; get key 
0c21 cd a3 0b				call update_display 
0c24			 
0c24			 
0c24					; handle key 
0c24			 
0c24 cd 11 64				call cin_wait 
0c27			 
0c27 fe 05				cp KEY_UP 
0c29 28 2b				jr z, .mgoup 
0c2b fe 61				cp 'a' 
0c2d 28 27				jr z, .mgoup 
0c2f fe 0a				cp KEY_DOWN 
0c31 28 32				jr z, .mgod 
0c33 fe 7a				cp 'z' 
0c35 28 2e				jr z, .mgod 
0c37 fe 20				cp ' ' 
0c39 28 34				jr z, .goend 
0c3b fe 0c				cp KEY_RIGHT 
0c3d 28 30				jr z, .goend 
0c3f fe 0d				cp KEY_CR 
0c41 28 2c				jr z, .goend 
0c43 fe 71				cp 'q' 
0c45 28 0b				jr z, .goback 
0c47			 
0c47 fe 0b				cp KEY_LEFT 
0c49 28 07				jr z, .goback 
0c4b fe 08				cp KEY_BS 
0c4d 28 03				jr z, .goback 
0c4f c3 bd 0b				jp .mloop 
0c52			 
0c52			.goback: 
0c52 3e 00			ld a, 0 
0c54 18 1d			jr .goend2 
0c56			 
0c56				; move up one 
0c56			.mgoup: 
0c56 3a 7b ea				ld a, (store_tmp2) 
0c59 fe 00				cp 0 
0c5b ca bd 0b				jp z, .mloop 
0c5e 3d					dec a 
0c5f 32 7b ea				ld (store_tmp2), a 
0c62 c3 bd 0b				jp .mloop 
0c65			 
0c65				; move down one 
0c65			.mgod: 
0c65 3a 7b ea				ld a, (store_tmp2) 
0c68 3c					inc a 
0c69 32 7b ea				ld (store_tmp2), a 
0c6c c3 bd 0b				jp .mloop 
0c6f			 
0c6f			 
0c6f			.goend: 
0c6f					; get selected item number 
0c6f			 
0c6f 3a 7b ea				ld a, (store_tmp2) 
0c72 3c					inc a 
0c73			 
0c73			.goend2: 
0c73 f5					push af 
0c74			 
0c74					; restore active fb 
0c74					; TODO BUG assumes fb1 
0c74			 
0c74 21 16 ed				ld hl, display_fb1 
0c77 22 d2 eb				ld (display_fb_active), hl 
0c7a			 
0c7a					; restore main regs 
0c7a			 
0c7a			 
0c7a cd a3 0b				call update_display 
0c7d			 
0c7d f1					pop af 
0c7e			 
0c7e c9				ret 
0c7f			 
0c7f .. 00		.msel:   db ">",0 
0c81 .. 00		.mup:   db "^",0 
0c83 .. 00		.mdown:   db "v",0 
0c85			 
0c85			 
0c85			; eof 
0c85			 
# End of file firmware_display.asm
0c85			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0c85			; random number generators 
0c85			 
0c85			 
0c85			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0c85			 
0c85			 
0c85			;-----> Generate a random number 
0c85			; output a=answer 0<=a<=255 
0c85			; all registers are preserved except: af 
0c85			random: 
0c85 e5			        push    hl 
0c86 d5			        push    de 
0c87 2a b4 eb		        ld      hl,(randData) 
0c8a ed 5f		        ld      a,r 
0c8c 57			        ld      d,a 
0c8d 5e			        ld      e,(hl) 
0c8e 19			        add     hl,de 
0c8f 85			        add     a,l 
0c90 ac			        xor     h 
0c91 22 b4 eb		        ld      (randData),hl 
0c94 d1			        pop     de 
0c95 e1			        pop     hl 
0c96 c9			        ret 
0c97			 
0c97			 
0c97			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c97			 
0c97			 
0c97			 
0c97			;------LFSR------ 
0c97			;James Montelongo 
0c97			;optimized by Spencer Putt 
0c97			;out: 
0c97			; a = 8 bit random number 
0c97			RandLFSR: 
0c97 21 ba eb		        ld hl,LFSRSeed+4 
0c9a 5e			        ld e,(hl) 
0c9b 23			        inc hl 
0c9c 56			        ld d,(hl) 
0c9d 23			        inc hl 
0c9e 4e			        ld c,(hl) 
0c9f 23			        inc hl 
0ca0 7e			        ld a,(hl) 
0ca1 47			        ld b,a 
0ca2 cb 13		        rl e  
0ca4 cb 12			rl d 
0ca6 cb 11		        rl c  
0ca8 17				rla 
0ca9 cb 13		        rl e  
0cab cb 12			rl d 
0cad cb 11		        rl c  
0caf 17				rla 
0cb0 cb 13		        rl e  
0cb2 cb 12			rl d 
0cb4 cb 11		        rl c  
0cb6 17				rla 
0cb7 67			        ld h,a 
0cb8 cb 13		        rl e  
0cba cb 12			rl d 
0cbc cb 11		        rl c  
0cbe 17				rla 
0cbf a8			        xor b 
0cc0 cb 13		        rl e  
0cc2 cb 12			rl d 
0cc4 ac			        xor h 
0cc5 a9			        xor c 
0cc6 aa			        xor d 
0cc7 21 bc eb		        ld hl,LFSRSeed+6 
0cca 11 bd eb		        ld de,LFSRSeed+7 
0ccd 01 07 00		        ld bc,7 
0cd0 ed b8		        lddr 
0cd2 12			        ld (de),a 
0cd3 c9			        ret 
0cd4			 
0cd4			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0cd4			 
0cd4			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0cd4			 
0cd4			 
0cd4			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0cd4			 
0cd4			prng16: 
0cd4			;Inputs: 
0cd4			;   (seed1) contains a 16-bit seed value 
0cd4			;   (seed2) contains a NON-ZERO 16-bit seed value 
0cd4			;Outputs: 
0cd4			;   HL is the result 
0cd4			;   BC is the result of the LCG, so not that great of quality 
0cd4			;   DE is preserved 
0cd4			;Destroys: 
0cd4			;   AF 
0cd4			;cycle: 4,294,901,760 (almost 4.3 billion) 
0cd4			;160cc 
0cd4			;26 bytes 
0cd4 2a ae eb		    ld hl,(seed1) 
0cd7 44			    ld b,h 
0cd8 4d			    ld c,l 
0cd9 29			    add hl,hl 
0cda 29			    add hl,hl 
0cdb 2c			    inc l 
0cdc 09			    add hl,bc 
0cdd 22 ae eb		    ld (seed1),hl 
0ce0 2a ac eb		    ld hl,(seed2) 
0ce3 29			    add hl,hl 
0ce4 9f			    sbc a,a 
0ce5 e6 2d		    and %00101101 
0ce7 ad			    xor l 
0ce8 6f			    ld l,a 
0ce9 22 ac eb		    ld (seed2),hl 
0cec 09			    add hl,bc 
0ced c9			    ret 
0cee			 
0cee			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0cee			 
0cee			rand32: 
0cee			;Inputs: 
0cee			;   (seed1_0) holds the lower 16 bits of the first seed 
0cee			;   (seed1_1) holds the upper 16 bits of the first seed 
0cee			;   (seed2_0) holds the lower 16 bits of the second seed 
0cee			;   (seed2_1) holds the upper 16 bits of the second seed 
0cee			;   **NOTE: seed2 must be non-zero 
0cee			;Outputs: 
0cee			;   HL is the result 
0cee			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0cee			;Destroys: 
0cee			;   AF 
0cee			;Tested and passes all CAcert tests 
0cee			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0cee			;it has a period of 18,446,744,069,414,584,320 
0cee			;roughly 18.4 quintillion. 
0cee			;LFSR taps: 0,2,6,7  = 11000101 
0cee			;291cc 
0cee			;seed1_0=$+1 
0cee			;    ld hl,12345 
0cee			;seed1_1=$+1 
0cee			;    ld de,6789 
0cee			;    ld b,h 
0cee			;    ld c,l 
0cee			;    add hl,hl \ rl e \ rl d 
0cee			;    add hl,hl \ rl e \ rl d 
0cee			;    inc l 
0cee			;    add hl,bc 
0cee			;    ld (seed1_0),hl 
0cee			;    ld hl,(seed1_1) 
0cee			;    adc hl,de 
0cee			;    ld (seed1_1),hl 
0cee			;    ex de,hl 
0cee			;seed2_0=$+1 
0cee			;    ld hl,9876 
0cee			;seed2_1=$+1 
0cee			;    ld bc,54321 
0cee			;    add hl,hl \ rl c \ rl b 
0cee			;    ld (seed2_1),bc 
0cee			;    sbc a,a 
0cee			;    and %11000101 
0cee			;    xor l 
0cee			;    ld l,a 
0cee			;    ld (seed2_0),hl 
0cee			;    ex de,hl 
0cee			;    add hl,bc 
0cee			;    ret 
0cee			; 
0cee			 
0cee			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0cee			; 20 bytes, 86 cycles (excluding ret) 
0cee			 
0cee			; returns   hl = pseudorandom number 
0cee			; corrupts   a 
0cee			 
0cee			; generates 16-bit pseudorandom numbers with a period of 65535 
0cee			; using the xorshift method: 
0cee			 
0cee			; hl ^= hl << 7 
0cee			; hl ^= hl >> 9 
0cee			; hl ^= hl << 8 
0cee			 
0cee			; some alternative shift triplets which also perform well are: 
0cee			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0cee			 
0cee			;  org 32768 
0cee			 
0cee			xrnd: 
0cee 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0cf1 3e 00		  ld a,0 
0cf3 bd			  cp l 
0cf4 20 02		  jr nz, .xrnd1 
0cf6 2e 01		  ld l, 1 
0cf8			.xrnd1: 
0cf8			 
0cf8 7c			  ld a,h 
0cf9 1f			  rra 
0cfa 7d			  ld a,l 
0cfb 1f			  rra 
0cfc ac			  xor h 
0cfd 67			  ld h,a 
0cfe 7d			  ld a,l 
0cff 1f			  rra 
0d00 7c			  ld a,h 
0d01 1f			  rra 
0d02 ad			  xor l 
0d03 6f			  ld l,a 
0d04 ac			  xor h 
0d05 67			  ld h,a 
0d06			 
0d06 22 b2 eb		  ld (xrandc),hl 
0d09			 
0d09 c9			  ret 
0d0a			;  
0d0a			 
0d0a			 
0d0a			;;;; int maths 
0d0a			 
0d0a			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d0a			; Divide 16-bit values (with 16-bit result) 
0d0a			; In: Divide BC by divider DE 
0d0a			; Out: BC = result, HL = rest 
0d0a			; 
0d0a			Div16: 
0d0a 21 00 00		    ld hl,0 
0d0d 78			    ld a,b 
0d0e 06 08		    ld b,8 
0d10			Div16_Loop1: 
0d10 17			    rla 
0d11 ed 6a		    adc hl,hl 
0d13 ed 52		    sbc hl,de 
0d15 30 01		    jr nc,Div16_NoAdd1 
0d17 19			    add hl,de 
0d18			Div16_NoAdd1: 
0d18 10 f6		    djnz Div16_Loop1 
0d1a 17			    rla 
0d1b 2f			    cpl 
0d1c 47			    ld b,a 
0d1d 79			    ld a,c 
0d1e 48			    ld c,b 
0d1f 06 08		    ld b,8 
0d21			Div16_Loop2: 
0d21 17			    rla 
0d22 ed 6a		    adc hl,hl 
0d24 ed 52		    sbc hl,de 
0d26 30 01		    jr nc,Div16_NoAdd2 
0d28 19			    add hl,de 
0d29			Div16_NoAdd2: 
0d29 10 f6		    djnz Div16_Loop2 
0d2b 17			    rla 
0d2c 2f			    cpl 
0d2d 41			    ld b,c 
0d2e 4f			    ld c,a 
0d2f c9			ret 
0d30			 
0d30			 
0d30			;http://z80-heaven.wikidot.com/math 
0d30			; 
0d30			;Inputs: 
0d30			;     DE and A are factors 
0d30			;Outputs: 
0d30			;     A is not changed 
0d30			;     B is 0 
0d30			;     C is not changed 
0d30			;     DE is not changed 
0d30			;     HL is the product 
0d30			;Time: 
0d30			;     342+6x 
0d30			; 
0d30			Mult16: 
0d30			 
0d30 06 08		     ld b,8          ;7           7 
0d32 21 00 00		     ld hl,0         ;10         10 
0d35 29			       add hl,hl     ;11*8       88 
0d36 07			       rlca          ;4*8        32 
0d37 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d39 19			         add hl,de   ;--         -- 
0d3a 10 f9		       djnz $-5      ;13*7+8     99 
0d3c c9			ret 
0d3d			 
0d3d			; 
0d3d			; Square root of 16-bit value 
0d3d			; In:  HL = value 
0d3d			; Out:  D = result (rounded down) 
0d3d			; 
0d3d			;Sqr16: 
0d3d			;    ld de,#0040 
0d3d			;    ld a,l 
0d3d			;    ld l,h 
0d3d			;    ld h,d 
0d3d			;    or a 
0d3d			;    ld b,8 
0d3d			;Sqr16_Loop: 
0d3d			;    sbc hl,de 
0d3d			;    jr nc,Sqr16_Skip 
0d3d			;    add hl,de 
0d3d			;Sqr16_Skip: 
0d3d			;    ccf 
0d3d			;    rl d 
0d3d			;    add a,a 
0d3d			;    adc hl,hl 
0d3d			;    add a,a 
0d3d			;    adc hl,hl 
0d3d			;    djnz Sqr16_Loop 
0d3d			;    ret 
0d3d			; 
0d3d			; 
0d3d			; Divide 8-bit values 
0d3d			; In: Divide E by divider C 
0d3d			; Out: A = result, B = rest 
0d3d			; 
0d3d			Div8: 
0d3d af			    xor a 
0d3e 06 08		    ld b,8 
0d40			Div8_Loop: 
0d40 cb 13		    rl e 
0d42 17			    rla 
0d43 91			    sub c 
0d44 30 01		    jr nc,Div8_NoAdd 
0d46 81			    add a,c 
0d47			Div8_NoAdd: 
0d47 10 f7		    djnz Div8_Loop 
0d49 47			    ld b,a 
0d4a 7b			    ld a,e 
0d4b 17			    rla 
0d4c 2f			    cpl 
0d4d c9			    ret 
0d4e			 
0d4e			; 
0d4e			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d4e			; In: Multiply A with DE 
0d4e			; Out: HL = result 
0d4e			; 
0d4e			Mult12U: 
0d4e 2e 00		    ld l,0 
0d50 87			    add a,a 
0d51 30 01		    jr nc,Mult12U_NoAdd0 
0d53 19			    add hl,de 
0d54			Mult12U_NoAdd0: 
0d54 29			    add hl,hl 
0d55 87			    add a,a 
0d56 30 01		    jr nc,Mult12U_NoAdd1 
0d58 19			    add hl,de 
0d59			Mult12U_NoAdd1: 
0d59 29			    add hl,hl 
0d5a 87			    add a,a 
0d5b 30 01		    jr nc,Mult12U_NoAdd2 
0d5d 19			    add hl,de 
0d5e			Mult12U_NoAdd2: 
0d5e 29			    add hl,hl 
0d5f 87			    add a,a 
0d60 30 01		    jr nc,Mult12U_NoAdd3 
0d62 19			    add hl,de 
0d63			Mult12U_NoAdd3: 
0d63 29			    add hl,hl 
0d64 87			    add a,a 
0d65 30 01		    jr nc,Mult12U_NoAdd4 
0d67 19			    add hl,de 
0d68			Mult12U_NoAdd4: 
0d68 29			    add hl,hl 
0d69 87			    add a,a 
0d6a 30 01		    jr nc,Mult12U_NoAdd5 
0d6c 19			    add hl,de 
0d6d			Mult12U_NoAdd5: 
0d6d 29			    add hl,hl 
0d6e 87			    add a,a 
0d6f 30 01		    jr nc,Mult12U_NoAdd6 
0d71 19			    add hl,de 
0d72			Mult12U_NoAdd6: 
0d72 29			    add hl,hl 
0d73 87			    add a,a 
0d74 d0			    ret nc 
0d75 19			    add hl,de 
0d76 c9			    ret 
0d77			 
0d77			; 
0d77			; Multiply 8-bit value with a 16-bit value (right rotating) 
0d77			; In: Multiply A with DE 
0d77			;      Put lowest value in A for most efficient calculation 
0d77			; Out: HL = result 
0d77			; 
0d77			Mult12R: 
0d77 21 00 00		    ld hl,0 
0d7a			Mult12R_Loop: 
0d7a cb 3f		    srl a 
0d7c 30 01		    jr nc,Mult12R_NoAdd 
0d7e 19			    add hl,de 
0d7f			Mult12R_NoAdd: 
0d7f cb 23		    sla e 
0d81 cb 12		    rl d 
0d83 b7			    or a 
0d84 c2 7a 0d		    jp nz,Mult12R_Loop 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 16-bit values (with 32-bit result) 
0d88			; In: Multiply BC with DE 
0d88			; Out: BCHL = result 
0d88			; 
0d88			Mult32: 
0d88 79			    ld a,c 
0d89 48			    ld c,b 
0d8a 21 00 00		    ld hl,0 
0d8d 06 10		    ld b,16 
0d8f			Mult32_Loop: 
0d8f 29			    add hl,hl 
0d90 17			    rla 
0d91 cb 11		    rl c 
0d93 30 07		    jr nc,Mult32_NoAdd 
0d95 19			    add hl,de 
0d96 ce 00		    adc a,0 
0d98 d2 9c 0d		    jp nc,Mult32_NoAdd 
0d9b 0c			    inc c 
0d9c			Mult32_NoAdd: 
0d9c 10 f1		    djnz Mult32_Loop 
0d9e 41			    ld b,c 
0d9f 4f			    ld c,a 
0da0 c9			    ret 
0da1			 
0da1			 
0da1			 
0da1			; 
0da1			; Multiply 8-bit values 
0da1			; In:  Multiply H with E 
0da1			; Out: HL = result 
0da1			; 
0da1			Mult8: 
0da1 16 00		    ld d,0 
0da3 6a			    ld l,d 
0da4 06 08		    ld b,8 
0da6			Mult8_Loop: 
0da6 29			    add hl,hl 
0da7 30 01		    jr nc,Mult8_NoAdd 
0da9 19			    add hl,de 
0daa			Mult8_NoAdd: 
0daa 10 fa		    djnz Mult8_Loop 
0dac c9			    ret 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			;;http://z80-heaven.wikidot.com/math 
0dad			;;This divides DE by BC, storing the result in DE, remainder in HL 
0dad			; 
0dad			;DE_Div_BC:          ;1281-2x, x is at most 16 
0dad			;     ld a,16        ;7 
0dad			;     ld hl,0        ;10 
0dad			;     jp $+5         ;10 
0dad			;.DivLoop: 
0dad			;       add hl,bc    ;-- 
0dad			;       dec a        ;64 
0dad			;       jr z,.DivLoopEnd        ;86 
0dad			; 
0dad			;       sla e        ;128 
0dad			;       rl d         ;128 
0dad			;       adc hl,hl    ;240 
0dad			;       sbc hl,bc    ;240 
0dad			;       jr nc,.DivLoop ;23|21 
0dad			;       inc e        ;-- 
0dad			;       jp .DivLoop+1 
0dad			; 
0dad			;.DivLoopEnd: 
0dad			 
0dad			;HL_Div_C: 
0dad			;Inputs: 
0dad			;     HL is the numerator 
0dad			;     C is the denominator 
0dad			;Outputs: 
0dad			;     A is the remainder 
0dad			;     B is 0 
0dad			;     C is not changed 
0dad			;     DE is not changed 
0dad			;     HL is the quotient 
0dad			; 
0dad			;       ld b,16 
0dad			;       xor a 
0dad			;         add hl,hl 
0dad			;         rla 
0dad			;         cp c 
0dad			;         jr c,$+4 
0dad			;           inc l 
0dad			;           sub c 
0dad			;         djnz $-7 
0dad			 
0dad			; https://plutiedev.com/z80-add-8bit-to-16bit 
0dad			 
0dad			addatohl: 
0dad 85			    add   a, l    ; A = A+L 
0dae 6f			    ld    l, a    ; L = A+L 
0daf 8c			    adc   a, h    ; A = A+L+H+carry 
0db0 95			    sub   l       ; A = H+carry 
0db1 67			    ld    h, a    ; H = H+carry 
0db2 c9			ret 
0db3			 
0db3			addatode: 
0db3 83			    add   a, e    ; A = A+L 
0db4 5f			    ld    e, a    ; L = A+L 
0db5 8a			    adc   a, d    ; A = A+L+H+carry 
0db6 93			    sub   e       ; A = H+carry 
0db7 57			    ld    d, a    ; H = H+carry 
0db8 c9			ret 
0db9			 
0db9			 
0db9			addatobc: 
0db9 81			    add   a, c    ; A = A+L 
0dba 4f			    ld    c, a    ; L = A+L 
0dbb 88			    adc   a, b    ; A = A+L+H+carry 
0dbc 91			    sub   c       ; A = H+carry 
0dbd 47			    ld    b, a    ; H = H+carry 
0dbe c9			ret 
0dbf			 
0dbf			subafromhl: 
0dbf			   ; If A=0 do nothing 
0dbf			    ; Otherwise flip A's sign. Since 
0dbf			    ; the upper byte becomes -1, also 
0dbf			    ; substract 1 from H. 
0dbf ed 44		    neg 
0dc1 ca ca 0d		    jp    z, Skip 
0dc4 25			    dec   h 
0dc5			     
0dc5			    ; Now add the low byte as usual 
0dc5			    ; Two's complement takes care of 
0dc5			    ; ensuring the result is correct 
0dc5 85			    add   a, l 
0dc6 6f			    ld    l, a 
0dc7 8c			    adc   a, h 
0dc8 95			    sub   l 
0dc9 67			    ld    h, a 
0dca			Skip: 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			; compare hl and de 
0dcb			; returns:  
0dcb			; if hl = de, z=1, s=0, c0=0 
0dcb			; if hl > de, z=0, s=0, c=0 
0dcb			; if hl < de, z=0, s=1, c=1 
0dcb			cmp16:	 
0dcb b7				or a 
0dcc ed 52			sbc hl,de 
0dce e0				ret po 
0dcf 7c				ld a,h 
0dd0 1f				rra 
0dd1 ee 40			xor 01000000B 
0dd3 37				scf 
0dd4 8f				adc a,a 
0dd5 c9				ret 
0dd6			 
0dd6			 
0dd6			; test if hl contains zero   - A is destroyed 
0dd6			 
0dd6			ishlzero:    
0dd6 b7				or a     ; reset flags 
0dd7 7c				ld a, h 
0dd8 b5				or l        	 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			if FORTH_ENABLE_FLOATMATH 
0dda			;include "float/bbcmath.z80" 
0dda			include "float/lpfpcalc.asm" 
0dda			endif 
0dda			 
0dda			 
0dda			; eof 
0dda			 
# End of file firmware_maths.asm
0dda			include "firmware_strings.asm"   ; string handling  
0dda			 
0dda			 
0dda			; TODO string len 
0dda			; input text string, end on cr with zero term 
0dda			; a offset into frame buffer to start prompt 
0dda			; d is max length 
0dda			; e is display size TODO 
0dda			; c is current cursor position 
0dda			; hl is ptr to where string will be stored 
0dda			 
0dda			 
0dda			; TODO check limit of buffer for new inserts 
0dda			; TODO check insert does not push beyond buffer 
0dda			; TODO scroll in a limited display area 
0dda			; TODO scroll whole screen on page wrap 
0dda			 
0dda			 
0dda			; TODO handle KEY_PREVWORD 
0dda			; TODO handle KEY_NEXTWORD 
0dda			; TODO handle KEY_HOME 
0dda			; TODO handle KEY_END 
0dda			; TODO use LCD cursor? 
0dda			 
0dda 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0ddd 81					add c 
0dde 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0de1 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0de4 79					ld a, c 
0de5 cd ad 0d				call addatohl 
0de8 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0deb 7a					ld a,d 
0dec 32 6c ee			        ld (input_size), a       ; save length of input area 
0def 79					ld a, c 
0df0 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0df3 7b					ld a,e 
0df4 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0df7					 
0df7					 
0df7			 
0df7			;		ld a,(input_ptr) 
0df7			;		ld (input_under_cursor),a 	; save what is under the cursor 
0df7			 
0df7			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0df7					; init cursor shape if not set by the cin routines 
0df7 21 ca eb				ld hl, cursor_shape 
0dfa 3e ff				ld a, 255 
0dfc 77					ld (hl), a 
0dfd 23					inc hl 
0dfe 3e 00				ld a, 0 
0e00 77					ld (hl), a 
0e01			 
0e01 3e 0f				ld a, CUR_BLINK_RATE 
0e03 32 66 ee				ld (input_cur_flash), a 
0e06 3e 01				ld a, 1 
0e08 32 65 ee				ld (input_cur_onoff),a 
0e0b			 
0e0b			;	if DEBUG_INPUT 
0e0b			;		push af 
0e0b			;		ld a, 'I' 
0e0b			;		ld (debug_mark),a 
0e0b			;		pop af 
0e0b			;		CALLMONITOR 
0e0b			;	endif 
0e0b			.is1:		; main entry loop 
0e0b			 
0e0b			 
0e0b			 
0e0b					; pause 1ms 
0e0b			 
0e0b 3e 01				ld a, 1 
0e0d cd d7 0a				call aDelayInMS 
0e10			 
0e10					; dec flash counter 
0e10 3a 66 ee				ld a, (input_cur_flash) 
0e13 3d					dec a 
0e14 32 66 ee				ld (input_cur_flash), a 
0e17 fe 00				cp 0 
0e19 20 0d				jr nz, .nochgstate 
0e1b			 
0e1b			 
0e1b					; change state 
0e1b 3a 65 ee				ld a,(input_cur_onoff) 
0e1e ed 44				neg 
0e20 32 65 ee				ld (input_cur_onoff),a 
0e23			 
0e23			 
0e23					; reset on change of state 
0e23 3e 0f				ld a, CUR_BLINK_RATE 
0e25 32 66 ee				ld (input_cur_flash), a 
0e28			 
0e28			.nochgstate: 
0e28					 
0e28					 
0e28			 
0e28					; display cursor  
0e28			 
0e28			;		ld hl, (input_start) 
0e28			;		ld a, (input_cursor) 
0e28			;		call addatohl 
0e28			 
0e28					; get char under cursor and replace with cursor 
0e28 2a 6f ee		ld hl, (input_ptr) 
0e2b			;		ld a, (hl) 
0e2b			;		ld (input_under_cursor),a 
0e2b			;		ld a, '_' 
0e2b			;		ld (hl), a 
0e2b			 
0e2b					; display string 
0e2b			 
0e2b ed 5b 6d ee			ld de, (input_start) 
0e2f 3a 6a ee				ld a, (input_at_pos) 
0e32 cd 93 0b				call str_at_display 
0e35			;	        call update_display 
0e35			 
0e35					; find place to put the cursor 
0e35			;		add h 
0e35			;		ld l, display_row_1 
0e35			;		sub l 
0e35			; (input_at_pos) 
0e35					;ld c, a 
0e35			;		ld a, (input_cursor) 
0e35			;		ld l, (input_at_pos) 
0e35			;		;ld b, h 
0e35			;		add l 
0e35			;		ld (input_at_cursor),a 
0e35					;ld l,h 
0e35			 
0e35			;		ld h, 0 
0e35			;		ld l,(input_at_pos) 
0e35			;		ld a, (input_cursor) 
0e35			;		call addatohl 
0e35			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e35			;		call subafromhl 
0e35			;		ld a,l 
0e35			;		ld (input_at_cursor), a 
0e35			 
0e35				if DEBUG_INPUT 
0e35					ld a, (hardware_diag) 
0e35					cp 0 
0e35					jr z, .skip_input_diag 
0e35			 
0e35					ld a,(input_at_pos) 
0e35					ld hl, LFSRSeed 
0e35					call hexout 
0e35					ld a, (input_cursor) 
0e35					ld hl, LFSRSeed+2 
0e35					call hexout 
0e35					ld a,(input_at_cursor) 
0e35					ld hl, LFSRSeed+4 
0e35					call hexout 
0e35			 
0e35					ld a,(input_cur_onoff) 
0e35					ld hl, LFSRSeed+6 
0e35					call hexout 
0e35			 
0e35					ld a,(input_cur_flash) 
0e35					ld hl, LFSRSeed+8 
0e35					call hexout 
0e35			 
0e35					ld a,(input_len) 
0e35					ld hl, LFSRSeed+10 
0e35					call hexout 
0e35					ld hl, LFSRSeed+12 
0e35					ld a, 0 
0e35					ld (hl),a 
0e35					ld a, display_row_4 
0e35					ld de, LFSRSeed 
0e35					call str_at_display 
0e35					.skip_input_diag: 
0e35				endif 
0e35			 
0e35					; decide on if we are showing the cursor this time round 
0e35			 
0e35 3a 65 ee				ld a, (input_cur_onoff) 
0e38 fe ff				cp 255 
0e3a 28 13				jr z, .skipcur 
0e3c			 
0e3c			 
0e3c 3a 68 ee				ld a,(input_at_cursor) 
0e3f 11 ca eb				ld de, cursor_shape 
0e42 cd 93 0b				call str_at_display 
0e45			 
0e45					; save length of current input string 
0e45 2a 6d ee				ld hl, (input_start) 
0e48 cd 0b 12				call strlenz 
0e4b 7d					ld a,l 
0e4c 32 60 ee				ld (input_len),a 
0e4f			 
0e4f			.skipcur: 
0e4f			 
0e4f cd a3 0b			        call update_display 
0e52					 
0e52			 
0e52			 
0e52					; wait 
0e52				 
0e52					; TODO loop without wait to flash the cursor and char under cursor	 
0e52 cd 19 64				call cin    ; _wait 
0e55			 
0e55 fe 00				cp 0 
0e57 ca 0b 0e				jp z, .is1 
0e5a			 
0e5a					; get ptr to char to input into 
0e5a			 
0e5a 4f					ld c,a 
0e5b 2a 6d ee				ld hl, (input_start) 
0e5e 3a 5b ee				ld a, (input_cursor) 
0e61 cd ad 0d				call addatohl 
0e64 22 6f ee				ld (input_ptr), hl 
0e67 79					ld a,c 
0e68			 
0e68					; replace char under cursor 
0e68			 
0e68			;		ld hl, (input_ptr) 
0e68			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0e68			;		ld (hl), a 
0e68			 
0e68			;	if DEBUG_INPUT 
0e68			;		push af 
0e68			;		ld a, 'i' 
0e68			;		ld (debug_mark),a 
0e68			;		pop af 
0e68			;		CALLMONITOR 
0e68			;	endif 
0e68 fe 0e				cp KEY_HOME 
0e6a 20 0e				jr nz, .iske 
0e6c			 
0e6c 3a 6a ee				ld a, (input_at_pos) 
0e6f 32 68 ee				ld (input_at_cursor),a 
0e72 3e 00				ld a, 0 
0e74 32 5b ee				ld (input_cursor), a 
0e77 c3 0b 0e				jp .is1 
0e7a					 
0e7a fe 0f		.iske:		cp KEY_END 
0e7c 20 03				jr nz, .isknw 
0e7e c3 0b 0e				jp .is1 
0e81			 
0e81 fe 06		.isknw:		cp KEY_NEXTWORD 
0e83 20 1b				jr nz, .iskpw 
0e85			 
0e85 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0e88 7e					ld a,(hl)	 
0e89 fe 00				cp 0 
0e8b ca 0b 0e				jp z, .is1    ; end of string 
0e8e fe 20				cp ' ' 
0e90 ca 0b 0e				jp z, .is1    ; end of word 
0e93 23					inc hl 
0e94 22 6f ee				ld (input_ptr), hl 
0e97 3a 68 ee				ld a, (input_at_cursor) 
0e9a 3c					inc a 
0e9b 32 68 ee				ld (input_at_cursor), a 
0e9e 18 e5				jr .isknwm 
0ea0			 
0ea0 fe 07		.iskpw:		cp KEY_PREVWORD 
0ea2 20 1b				jr nz, .iskl 
0ea4			.iskpwm:	 
0ea4 2a 6f ee				ld hl, (input_ptr) 
0ea7 7e					ld a,(hl)	 
0ea8 fe 00				cp 0  
0eaa ca 0b 0e				jp z, .is1    ; end of string 
0ead fe 20				cp ' ' 
0eaf ca 0b 0e				jp z, .is1    ; end of word 
0eb2 2b					dec hl 
0eb3 22 6f ee				ld (input_ptr), hl 
0eb6 3a 68 ee				ld a, (input_at_cursor) 
0eb9 3d					dec a 
0eba 32 68 ee				ld (input_at_cursor), a 
0ebd 18 e5				jr .iskpwm 
0ebf			 
0ebf			 
0ebf fe 0b		.iskl:		cp KEY_LEFT 
0ec1 20 27				jr nz, .isk1 
0ec3			 
0ec3 3a 5b ee				ld a, (input_cursor) 
0ec6			 
0ec6 fe 00				cp 0 
0ec8 ca 0b 0e				jp z, .is1 		; at start of line to ignore  
0ecb			 
0ecb 3d					dec  a 		; TODO check underflow 
0ecc 32 5b ee				ld (input_cursor), a 
0ecf			 
0ecf 2a 6f ee				ld hl, (input_ptr) 
0ed2 2b					dec hl 
0ed3 22 6f ee				ld (input_ptr), hl 
0ed6					 
0ed6 3a 68 ee				ld a, (input_at_cursor) 
0ed9 3d					dec a 
0eda 32 68 ee				ld (input_at_cursor), a 
0edd			 
0edd 3e 01				ld a, 1		; show cursor moving 
0edf 32 65 ee				ld (input_cur_onoff),a 
0ee2 3e 0f				ld a, CUR_BLINK_RATE 
0ee4 32 66 ee				ld (input_cur_flash), a 
0ee7			 
0ee7 c3 0b 0e				jp .is1 
0eea			 
0eea fe 0c		.isk1:		cp KEY_RIGHT 
0eec 20 2a				jr nz, .isk2 
0eee			 
0eee 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ef1 5f					ld e,a 
0ef2 3a 5b ee				ld a, (input_cursor) 
0ef5 bb					cp e 
0ef6 ca 0b 0e				jp z, .is1		; at the end of string so dont go right 
0ef9			 
0ef9 3c					inc  a 		; TODO check overflow 
0efa 32 5b ee				ld (input_cursor), a 
0efd			 
0efd 3a 68 ee				ld a, (input_at_cursor) 
0f00 3c					inc a 
0f01 32 68 ee				ld (input_at_cursor), a 
0f04			 
0f04 2a 6f ee				ld hl, (input_ptr) 
0f07 23					inc hl 
0f08 22 6f ee				ld (input_ptr), hl 
0f0b			 
0f0b 3e 01				ld a, 1		; show cursor moving 
0f0d 32 65 ee				ld (input_cur_onoff),a 
0f10 3e 0f				ld a, CUR_BLINK_RATE 
0f12 32 66 ee				ld (input_cur_flash), a 
0f15			 
0f15 c3 0b 0e				jp .is1 
0f18			 
0f18 fe 05		.isk2:		cp KEY_UP 
0f1a			 
0f1a 20 26				jr nz, .isk3 
0f1c			 
0f1c					; swap last command with the current on 
0f1c			 
0f1c					; move cursor to start of string 
0f1c 2a 6d ee				ld hl, (input_start) 
0f1f 22 6f ee				ld (input_ptr), hl 
0f22			 
0f22 3a 6a ee				ld a, (input_at_pos) 
0f25 32 68 ee				ld (input_at_cursor), a 
0f28			 
0f28 3e 00				ld a, 0 
0f2a 32 5b ee				ld (input_cursor), a 
0f2d					 
0f2d					; swap input and last command buffers 
0f2d			 
0f2d 21 f2 e5				ld hl, os_cli_cmd 
0f30 11 f1 e6				ld de, os_last_cmd 
0f33 06 ff				ld b, 255 
0f35 7e			.swap1:		ld a, (hl) 
0f36 4f					ld c,a 
0f37 1a					ld a, (de) 
0f38 77					ld (hl), a 
0f39 79					ld a,c 
0f3a 12					ld (de),a 
0f3b 23					inc hl 
0f3c 13					inc de 
0f3d 10 f6				djnz .swap1 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f c3 0b 0e				jp .is1 
0f42			 
0f42 fe 08		.isk3:		cp KEY_BS 
0f44 20 3c				jr nz, .isk4 
0f46			 
0f46 3a 5b ee				ld a, (input_cursor) 
0f49			 
0f49 fe 00				cp 0 
0f4b ca 0b 0e				jp z, .is1 		; at start of line to ignore  
0f4e			 
0f4e 3d					dec  a 		; TODO check underflow 
0f4f 32 5b ee				ld (input_cursor), a 
0f52			 
0f52					; hl is source 
0f52					; de needs to be source - 1 
0f52			 
0f52			;		ld a, 0 
0f52			;		dec hl 
0f52			;		ld (hl), a 
0f52			 
0f52 2a 6f ee				ld hl, (input_ptr) 
0f55 2b					dec hl 
0f56 22 6f ee				ld (input_ptr), hl 
0f59			 
0f59					; shift all data 
0f59			 
0f59 e5					push hl 
0f5a 23					inc hl 
0f5b d1					pop de 
0f5c 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f5f 4f					ld c,a 
0f60 06 00				ld b,0 
0f62 ed b0				ldir  
0f64			 
0f64			 
0f64			 
0f64			 
0f64 3a 68 ee				ld a, (input_at_cursor) 
0f67 3d					dec a 
0f68 32 68 ee				ld (input_at_cursor), a 
0f6b			 
0f6b			 
0f6b 3e 01				ld a, 1		; show cursor moving 
0f6d 32 65 ee				ld (input_cur_onoff),a 
0f70 3e 0f				ld a, CUR_BLINK_RATE 
0f72 32 66 ee				ld (input_cur_flash), a 
0f75			 
0f75					; remove char 
0f75 3a 68 ee				ld a, (input_at_cursor) 
0f78 3c					inc a 
0f79 11 03 10				ld de,.iblank 
0f7c cd 93 0b				call str_at_display 
0f7f			 
0f7f c3 0b 0e				jp .is1 
0f82			 
0f82 fe 0d		.isk4:		cp KEY_CR 
0f84 28 6c				jr z, .endinput 
0f86			 
0f86					; else add the key press to the end 
0f86			 
0f86 4f					ld c, a			; save key pressed 
0f87			 
0f87 7e					ld a,(hl)		; get what is currently under char 
0f88			 
0f88 fe 00				cp 0			; we are at the end of the string 
0f8a 20 2f				jr nz, .onchar 
0f8c					 
0f8c					; add a char to the end of the string 
0f8c				 
0f8c 71					ld (hl),c 
0f8d 23					inc hl 
0f8e			;		ld a,' ' 
0f8e			;		ld (hl),a 
0f8e			;		inc hl 
0f8e 3e 00				ld a,0 
0f90 77					ld (hl),a 
0f91 2b					dec hl 
0f92			 
0f92 3a 5b ee				ld a, (input_cursor) 
0f95 3c					inc a				; TODO check max string length and scroll  
0f96 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0f99							 
0f99 3a 68 ee				ld a, (input_at_cursor) 
0f9c 3c					inc a 
0f9d 32 68 ee				ld (input_at_cursor), a 
0fa0			 
0fa0 2a 6f ee				ld hl, (input_ptr) 
0fa3 23					inc hl 
0fa4 22 6f ee				ld (input_ptr), hl 
0fa7			 
0fa7 2a 6f ee				ld hl, (input_ptr) 
0faa 23					inc hl 
0fab 22 6f ee				ld (input_ptr), hl 
0fae			;	if DEBUG_INPUT 
0fae			;		push af 
0fae			;		ld a, '+' 
0fae			;		ld (debug_mark),a 
0fae			;		pop af 
0fae			;		CALLMONITOR 
0fae			;	endif 
0fae 3e 01				ld a, 1		; show cursor moving 
0fb0 32 65 ee				ld (input_cur_onoff),a 
0fb3 3e 0f				ld a, CUR_BLINK_RATE 
0fb5 32 66 ee				ld (input_cur_flash), a 
0fb8 c3 0b 0e				jp .is1 
0fbb					 
0fbb			 
0fbb			 
0fbb					; if on a char then insert 
0fbb			.onchar: 
0fbb			 
0fbb					; TODO over flow check: make sure insert does not blow out buffer 
0fbb			 
0fbb					; need to do some maths to use lddr 
0fbb			 
0fbb e5					push hl   ; save char pos 
0fbc c5					push bc 
0fbd			 
0fbd 2a 6d ee				ld hl, (input_start) 
0fc0 3a 60 ee				ld a, (input_len) 
0fc3 cd ad 0d				call addatohl  		; end of string 
0fc6 23					inc hl 
0fc7 23					inc hl		; past zero term 
0fc8 e5					push hl 
0fc9 23					inc hl 
0fca e5					push hl  
0fcb			 
0fcb								; start and end of lddr set, now how much to move? 
0fcb			 
0fcb							 
0fcb 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fce 47					ld b,a 
0fcf 3a 60 ee				ld a,(input_len) 
0fd2 5f					ld e,a 
0fd3 90					sub b 
0fd4 3c					inc a		;?? 
0fd5 3c					inc a		;?? 
0fd6 3c					inc a		;?? 
0fd7			 
0fd7 06 00				ld b,0 
0fd9 4f					ld c,a 
0fda			 
0fda				if DEBUG_INPUT 
0fda					push af 
0fda					ld a, 'i' 
0fda					ld (debug_mark),a 
0fda					pop af 
0fda			;		CALLMONITOR 
0fda				endif 
0fda d1					pop de 
0fdb e1					pop hl 
0fdc				if DEBUG_INPUT 
0fdc					push af 
0fdc					ld a, 'I' 
0fdc					ld (debug_mark),a 
0fdc					pop af 
0fdc			;		CALLMONITOR 
0fdc				endif 
0fdc ed b8				lddr 
0fde				 
0fde			 
0fde			 
0fde					; TODO have a key for insert/overwrite mode???? 
0fde c1					pop bc 
0fdf e1					pop hl 
0fe0 71					ld (hl), c		; otherwise overwrite current char 
0fe1					 
0fe1			 
0fe1			 
0fe1			 
0fe1 3a 5b ee				ld a, (input_cursor) 
0fe4 3c					inc  a 		; TODO check overflow 
0fe5 32 5b ee				ld (input_cursor), a 
0fe8			 
0fe8 3a 68 ee				ld a, (input_at_cursor) 
0feb 3c					inc a 
0fec 32 68 ee				ld (input_at_cursor), a 
0fef			 
0fef c3 0b 0e				jp .is1 
0ff2			 
0ff2			.endinput:	; TODO look for end of string 
0ff2			 
0ff2					; add trailing space for end of token 
0ff2			 
0ff2 2a 6d ee				ld hl, (input_start) 
0ff5 3a 60 ee				ld a,(input_len) 
0ff8 cd ad 0d				call addatohl 
0ffb 3e 20				ld a, ' ' 
0ffd 77					ld (hl),a 
0ffe					; TODO eof of parse marker 
0ffe			 
0ffe 23					inc hl 
0fff 3e 00				ld a, 0 
1001 77					ld (hl),a 
1002			 
1002			 
1002 c9					ret 
1003			 
1003 .. 00		.iblank: db " ",0 
1005			 
1005			 
1005 32 6a ee		input_str_prev:	ld (input_at_pos), a 
1008 22 6d ee				ld (input_start), hl 
100b 3e 01				ld a,1			; add cursor 
100d 77					ld (hl),a 
100e 23					inc hl 
100f 3e 00				ld a,0 
1011 77					ld (hl),a 
1012 22 6f ee				ld (input_ptr), hl 
1015 7a					ld a,d 
1016 32 6c ee				ld (input_size), a 
1019 3e 00				ld a,0 
101b 32 5b ee				ld (input_cursor),a 
101e			.instr1:	 
101e			 
101e					; TODO do block cursor 
101e					; TODO switch cursor depending on the modifer key 
101e			 
101e					; update cursor shape change on key hold 
101e			 
101e 2a 6f ee				ld hl, (input_ptr) 
1021 2b					dec hl 
1022 3a ca eb				ld a,(cursor_shape) 
1025 77					ld (hl), a 
1026			 
1026					; display entered text 
1026 3a 6a ee				ld a,(input_at_pos) 
1029 cd 2e 63		            	CALL fLCD_Pos       ;Position cursor to location in A 
102c ed 5b 6d ee	            	LD   de, (input_start) 
1030 cd 23 63		            	CALL fLCD_Str       ;Display string pointed to by DE 
1033			 
1033 cd 19 64				call cin 
1036 fe 00				cp 0 
1038 28 e4				jr z, .instr1 
103a			 
103a					; proecess keyboard controls first 
103a			 
103a 2a 6f ee				ld hl,(input_ptr) 
103d			 
103d fe 0d				cp KEY_CR	 ; pressing enter ends input 
103f 28 5a				jr z, .instrcr 
1041			 
1041 fe 08				cp KEY_BS 	; back space 
1043 20 0f				jr nz, .instr2 
1045					; process back space 
1045			 
1045					; TODO stop back space if at start of string 
1045 2b					dec hl 
1046 2b					dec hl ; to over write cursor 
1047 3a ca eb				ld a,(cursor_shape) 
104a					;ld a,0 
104a 77					ld (hl),a 
104b 23					inc hl 
104c 3e 20				ld a," " 
104e 77					ld (hl),a 
104f 22 6f ee				ld (input_ptr),hl 
1052					 
1052			 
1052 18 ca				jr .instr1 
1054			 
1054 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1056 20 06				jr nz, .instr3 
1058 2b					dec hl 
1059 22 6f ee				ld (input_ptr),hl 
105c 18 c0				jr .instr1 
105e				 
105e fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1060 20 06				jr nz, .instr4 
1062 23					inc hl 
1063 22 6f ee				ld (input_ptr),hl 
1066 18 b6				jr .instr1 
1068			 
1068 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
106a 20 06				jr nz, .instr5 
106c 2b					dec hl 
106d 22 6f ee				ld (input_ptr),hl 
1070 18 ac				jr .instr1 
1072			 
1072 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1074 20 06				jr nz, .instr6 
1076 2b					dec hl 
1077 22 6f ee				ld (input_ptr),hl 
107a 18 a2				jr .instr1 
107c fe 05		.instr6:        cp KEY_UP      ; recall last command 
107e 20 0b				jr nz, .instrnew 
1080			 
1080 21 cb e2			ld hl, scratch 
1083 11 f1 e6			ld de, os_last_cmd 
1086 cd a4 10			call strcpy 
1089 18 93				jr .instr1 
108b			 
108b			 
108b			.instrnew:	; no special key pressed to see if we have room to store it 
108b			 
108b					; TODO do string size test 
108b			 
108b 2b					dec hl ; to over write cursor 
108c 77					ld (hl),a 
108d 23					inc hl 
108e 3a ca eb				ld a,(cursor_shape) 
1091 77					ld (hl),a 
1092 23					inc hl 
1093 3e 00				ld a,0 
1095 77					ld (hl),a 
1096			 
1096 22 6f ee				ld (input_ptr),hl 
1099					 
1099 18 83				jr .instr1 
109b 2b			.instrcr:	dec hl		; remove cursor 
109c 3e 20				ld a,' '	; TODO add a trailing space for safety 
109e 77					ld (hl),a 
109f 23					inc hl 
10a0 3e 00				ld a,0 
10a2 77					ld (hl),a 
10a3			 
10a3			 
10a3					; if at end of line scroll up    
10a3					; TODO detecting only end of line 4 for scroll up  
10a3			 
10a3					;ld   
10a3			 
10a3 c9					ret 
10a4			 
10a4			 
10a4			; strcpy hl = dest, de source 
10a4			 
10a4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10a5 b7			            OR   A              ;Null terminator? 
10a6 c8			            RET  Z              ;Yes, so finished 
10a7 1a					ld a,(de) 
10a8 77					ld (hl),a 
10a9 13			            INC  DE             ;Point to next character 
10aa 23					inc hl 
10ab 18 f7		            JR   strcpy       ;Repeat 
10ad c9					ret 
10ae			 
10ae			 
10ae			; TODO string_at  
10ae			; pass string which starts with lcd offset address and then null term string 
10ae			 
10ae			; TODO string to dec 
10ae			; TODO string to hex 
10ae			; TODO byte to string hex 
10ae			; TODO byte to string dec 
10ae			 
10ae			 
10ae			 
10ae			; from z80uartmonitor 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10ae			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10ae			; pass hl for where to put the text 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10ae c5			hexout:	PUSH BC 
10af f5					PUSH AF 
10b0 47					LD B, A 
10b1					; Upper nybble 
10b1 cb 3f				SRL A 
10b3 cb 3f				SRL A 
10b5 cb 3f				SRL A 
10b7 cb 3f				SRL A 
10b9 cd c9 10				CALL tohex 
10bc 77					ld (hl),a 
10bd 23					inc hl	 
10be					 
10be					; Lower nybble 
10be 78					LD A, B 
10bf e6 0f				AND 0FH 
10c1 cd c9 10				CALL tohex 
10c4 77					ld (hl),a 
10c5 23					inc hl	 
10c6					 
10c6 f1					POP AF 
10c7 c1					POP BC 
10c8 c9					RET 
10c9					 
10c9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c9			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
10c9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c9			tohex: 
10c9 e5					PUSH HL 
10ca d5					PUSH DE 
10cb 16 00				LD D, 0 
10cd 5f					LD E, A 
10ce 21 d6 10				LD HL, .DATA 
10d1 19					ADD HL, DE 
10d2 7e					LD A, (HL) 
10d3 d1					POP DE 
10d4 e1					POP HL 
10d5 c9					RET 
10d6			 
10d6			.DATA: 
10d6 30					DEFB	30h	; 0 
10d7 31					DEFB	31h	; 1 
10d8 32					DEFB	32h	; 2 
10d9 33					DEFB	33h	; 3 
10da 34					DEFB	34h	; 4 
10db 35					DEFB	35h	; 5 
10dc 36					DEFB	36h	; 6 
10dd 37					DEFB	37h	; 7 
10de 38					DEFB	38h	; 8 
10df 39					DEFB	39h	; 9 
10e0 41					DEFB	41h	; A 
10e1 42					DEFB	42h	; B 
10e2 43					DEFB	43h	; C 
10e3 44					DEFB	44h	; D 
10e4 45					DEFB	45h	; E 
10e5 46					DEFB	46h	; F 
10e6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e6			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
10e6			;;    subtract $30, if result > 9 then subtract $7 more 
10e6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e6			atohex: 
10e6 d6 30				SUB $30 
10e8 fe 0a				CP 10 
10ea f8					RET M		; If result negative it was 0-9 so we're done 
10eb d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
10ed c9					RET		 
10ee			 
10ee			 
10ee			 
10ee			 
10ee			; Get 2 ASCII characters as hex byte from pointer in hl 
10ee			 
10ee			BYTERD: 
10ee 16 00			LD	D,00h		;Set up 
10f0 cd f8 10			CALL	HEXCON		;Get byte and convert to hex 
10f3 87				ADD	A,A		;First nibble so 
10f4 87				ADD	A,A		;multiply by 16 
10f5 87				ADD	A,A		; 
10f6 87				ADD	A,A		; 
10f7 57				LD	D,A		;Save hi nibble in D 
10f8			HEXCON: 
10f8 7e				ld a, (hl)		;Get next chr 
10f9 23				inc hl 
10fa d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
10fc fe 0a			CP	00Ah		;Is it 0-9 ? 
10fe 38 02			JR	C,NALPHA	;If so miss next bit 
1100 d6 07			SUB	007h		;Else convert alpha 
1102			NALPHA: 
1102 b2				OR	D		;Add hi nibble back 
1103 c9				RET			; 
1104			 
1104			 
1104			; 
1104			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1104			; Since the routines get_byte and therefore get_nibble are called, only valid 
1104			; characters (0-9a-f) are accepted. 
1104			; 
1104			;get_word        push    af 
1104			;                call    get_byte        ; Get the upper byte 
1104			;                ld      h, a 
1104			;                call    get_byte        ; Get the lower byte 
1104			;                ld      l, a 
1104			;                pop     af 
1104			;                ret 
1104			; 
1104			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1104			; the routine get_nibble is used only valid characters are accepted - the  
1104			; input routine only accepts characters 0-9a-f. 
1104			; 
1104 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1105 7e					ld a,(hl) 
1106 23					inc hl 
1107 cd 2c 11		                call    nibble2val      ; Get upper nibble 
110a cb 07		                rlc     a 
110c cb 07		                rlc     a 
110e cb 07		                rlc     a 
1110 cb 07		                rlc     a 
1112 47			                ld      b, a            ; Save upper four bits 
1113 7e					ld a,(hl) 
1114 cd 2c 11		                call    nibble2val      ; Get lower nibble 
1117 b0			                or      b               ; Combine both nibbles 
1118 c1			                pop     bc              ; Restore B (and C) 
1119 c9			                ret 
111a			; 
111a			; Get a hexadecimal digit from the serial line. This routine blocks until 
111a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
111a			; to the serial line interface. The lower 4 bits of A contain the value of  
111a			; that particular digit. 
111a			; 
111a			;get_nibble      ld a,(hl)           ; Read a character 
111a			;                call    to_upper        ; Convert to upper case 
111a			;                call    is_hex          ; Was it a hex digit? 
111a			;                jr      nc, get_nibble  ; No, get another character 
111a			 ;               call    nibble2val      ; Convert nibble to value 
111a			 ;               call    print_nibble 
111a			 ;               ret 
111a			; 
111a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
111a			; A valid hexadecimal digit is denoted by a set C flag. 
111a			; 
111a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
111a			;                ret     nc              ; Yes 
111a			;                cp      '0'             ; Less than '0'? 
111a			;                jr      nc, is_hex_1    ; No, continue 
111a			;                ccf                     ; Complement carry (i.e. clear it) 
111a			;                ret 
111a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
111a			;                ret     c               ; Yes 
111a			;                cp      'A'             ; Less than 'A'? 
111a			;                jr      nc, is_hex_2    ; No, continue 
111a			;                ccf                     ; Yes - clear carry and return 
111a			;                ret 
111a			;is_hex_2        scf                     ; Set carry 
111a			;                ret 
111a			; 
111a			; Convert a single character contained in A to upper case: 
111a			; 
111a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
111c d8			                ret     c 
111d fe 7b		                cp      'z' + 1         ; > 'z'? 
111f d0			                ret     nc              ; Nothing to do, either 
1120 e6 5f		                and     $5f             ; Convert to upper case 
1122 c9			                ret 
1123			 
1123			 
1123			to_lower: 
1123			 
1123			   ; if char is in [A-Z] make it lower case 
1123			 
1123			   ; enter : a = char 
1123			   ; exit  : a = lower case char 
1123			   ; uses  : af 
1123			 
1123 fe 41		   cp 'A' 
1125 d8			   ret c 
1126			    
1126 fe 5b		   cp 'Z'+1 
1128 d0			   ret nc 
1129			    
1129 f6 20		   or $20 
112b c9			   ret 
112c			 
112c			; 
112c			; Expects a hexadecimal digit (upper case!) in A and returns the 
112c			; corresponding value in A. 
112c			; 
112c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
112e 38 02		                jr      c, nibble2val_1 ; Yes 
1130 d6 07		                sub     7               ; Adjust for A-F 
1132 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1134 e6 0f		                and     $f              ; Only return lower 4 bits 
1136 c9			                ret 
1137			; 
1137			; Print_nibble prints a single hex nibble which is contained in the lower  
1137			; four bits of A: 
1137			; 
1137			;print_nibble    push    af              ; We won't destroy the contents of A 
1137			;                and     $f              ; Just in case... 
1137			;                add     a, '0'             ; If we have a digit we are done here. 
1137			;                cp      '9' + 1         ; Is the result > 9? 
1137			;                jr      c, print_nibble_1 
1137			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1137			;print_nibble_1  call    putc            ; Print the nibble and 
1137			;                pop     af              ; restore the original value of A 
1137			;                ret 
1137			;; 
1137			;; Send a CR/LF pair: 
1137			; 
1137			;crlf            push    af 
1137			;                ld      a, cr 
1137			;                call    putc 
1137			;                ld      a, lf 
1137			;                call    putc 
1137			;                pop     af 
1137			;                ret 
1137			; 
1137			; Print_word prints the four hex digits of a word to the serial line. The  
1137			; word is expected to be in HL. 
1137			; 
1137			;print_word      push    hl 
1137			;                push    af 
1137			;                ld      a, h 
1137			;                call    print_byte 
1137			;                ld      a, l 
1137			;                call    print_byte 
1137			;                pop     af 
1137			;                pop     hl 
1137			;                ret 
1137			; 
1137			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1137			; The byte to be printed is expected to be in A. 
1137			; 
1137			;print_byte      push    af              ; Save the contents of the registers 
1137			;                push    bc 
1137			;                ld      b, a 
1137			;                rrca 
1137			;                rrca 
1137			;                rrca 
1137			;                rrca 
1137			;                call    print_nibble    ; Print high nibble 
1137			;                ld      a, b 
1137			;                call    print_nibble    ; Print low nibble 
1137			;                pop     bc              ; Restore original register contents 
1137			;                pop     af 
1137			;                ret 
1137			 
1137			 
1137			 
1137			 
1137			 
1137			fourehexhl:  
1137 7e				ld a,(hl) 
1138 cd e6 10			call atohex 
113b cb 3f				SRL A 
113d cb 3f				SRL A 
113f cb 3f				SRL A 
1141 cb 3f				SRL A 
1143 47				ld b, a 
1144 23				inc hl 
1145 7e				ld a,(hl) 
1146 23				inc hl 
1147 cd e6 10			call atohex 
114a 80				add b 
114b 57				ld d,a 
114c 7e				ld a,(hl) 
114d cd e6 10			call atohex 
1150 cb 3f				SRL A 
1152 cb 3f				SRL A 
1154 cb 3f				SRL A 
1156 cb 3f				SRL A 
1158 47				ld b, a 
1159 23				inc hl 
115a 7e				ld a,(hl) 
115b 23				inc hl 
115c cd e6 10			call atohex 
115f 80				add b 
1160 5f				ld e, a 
1161 d5				push de 
1162 e1				pop hl 
1163 c9				ret 
1164			 
1164			; pass hl. returns z set if the byte at hl is a digit 
1164			;isdigithl:  
1164			;	push bc 
1164			;	ld a,(hl) 
1164			;	cp ':' 
1164			;	jr nc, .isdf 		; > 
1164			;	cp '0' 
1164			;	jr c, .isdf		; < 
1164			; 
1164			;	; TODO find a better way to set z 
1164			; 
1164			;	ld b,a 
1164			;	cp b 
1164			;	pop bc 
1164			;	ret 
1164			; 
1164			;.isdf:	; not digit so clear z 
1164			; 
1164			;	; TODO find a better way to unset z 
1164			; 
1164			;	ld b,a 
1164			;	inc b 
1164			;	cp b 
1164			; 
1164			;	pop bc 
1164			;	ret 
1164				 
1164				 
1164			 
1164			 
1164			; pass hl as the four byte address to load 
1164			 
1164			get_word_hl:  
1164 e5				push hl 
1165 cd 04 11			call get_byte 
1168				 
1168 47				ld b, a 
1169			 
1169 e1				pop hl 
116a 23				inc hl 
116b 23				inc hl 
116c			 
116c			; TODO not able to handle a-f  
116c 7e				ld a,(hl) 
116d			;	;cp ':' 
116d			;	cp 'g' 
116d			;	jr nc, .single_byte_hl 		; > 
116d			;	cp 'G' 
116d			;	jr nc, .single_byte_hl 		; > 
116d			;	cp '0' 
116d			;	jr c, .single_byte_hl		; < 
116d			 
116d				;call isdigithl 
116d fe 00			cp 0 
116f 28 06			jr z, .single_byte_hl 
1171			 
1171			.getwhln:   ; hex word so get next byte 
1171			 
1171 cd 04 11			call get_byte 
1174 6f				ld l, a 
1175 60				ld h,b 
1176 c9				ret 
1177 68			.single_byte_hl:   ld l,b 
1178 26 00				ld h,0 
117a c9					ret 
117b			 
117b			 
117b			 
117b			 
117b 21 36 19			ld hl,asc+1 
117e			;	ld a, (hl) 
117e			;	call nibble2val 
117e cd 04 11			call get_byte 
1181			 
1181			;	call fourehexhl 
1181 32 ff e2			ld (scratch+52),a 
1184				 
1184 21 fd e2			ld hl,scratch+50 
1187 22 ee e5			ld (os_cur_ptr),hl 
118a			 
118a c9				ret 
118b			 
118b			 
118b			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
118b			 
118b			; Decimal Unsigned Version 
118b			 
118b			;Number in a to decimal ASCII 
118b			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
118b			;Example: display a=56 as "056" 
118b			;input: a = number 
118b			;Output: a=0,value of a in the screen 
118b			;destroys af,bc (don't know about hl and de) 
118b			DispAToASCII: 
118b 0e 9c			ld	c,-100 
118d cd 97 11			call	.Na1 
1190 0e f6			ld	c,-10 
1192 cd 97 11			call	.Na1 
1195 0e ff			ld	c,-1 
1197 06 2f		.Na1:	ld	b,'0'-1 
1199 04			.Na2:	inc	b 
119a 81				add	a,c 
119b 38 fc			jr	c,.Na2 
119d 91				sub	c		;works as add 100/10/1 
119e f5				push af		;safer than ld c,a 
119f 78				ld	a,b		;char is in b 
11a0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11a0 f1				pop af		;safer than ld a,c 
11a1 c9				ret 
11a2			 
11a2			; Decimal Signed Version 
11a2			 
11a2			; DispA 
11a2			; -------------------------------------------------------------- 
11a2			; Converts a signed integer value to a zero-terminated ASCII 
11a2			; string representative of that value (using radix 10). 
11a2			; -------------------------------------------------------------- 
11a2			; INPUTS: 
11a2			;     HL     Value to convert (two's complement integer). 
11a2			;     DE     Base address of string destination. (pointer). 
11a2			; -------------------------------------------------------------- 
11a2			; OUTPUTS: 
11a2			;     None 
11a2			; -------------------------------------------------------------- 
11a2			; REGISTERS/MEMORY DESTROYED 
11a2			; AF HL 
11a2			; -------------------------------------------------------------- 
11a2			 
11a2			;DispHLToASCII: 
11a2			;   push    de 
11a2			;   push    bc 
11a2			; 
11a2			;; Detect sign of HL. 
11a2			;    bit    7, h 
11a2			;    jr     z, ._DoConvert 
11a2			; 
11a2			;; HL is negative. Output '-' to string and negate HL. 
11a2			;    ld     a, '-' 
11a2			;    ld     (de), a 
11a2			;    inc    de 
11a2			; 
11a2			;; Negate HL (using two's complement) 
11a2			;    xor    a 
11a2			;    sub    l 
11a2			;    ld     l, a 
11a2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11a2			;    sbc    a, h 
11a2			;    ld     h, a 
11a2			; 
11a2			;; Convert HL to digit characters 
11a2			;._DoConvert: 
11a2			;    ld     b, 0     ; B will count character length of number 
11a2			;-   ld     a, 10 
11a2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11a2			;    push   af 
11a2			;    inc    b 
11a2			;    ld     a, h 
11a2			;    or     l 
11a2			;    jr     nz, - 
11a2			; 
11a2			;; Retrieve digits from stack 
11a2			;-   pop    af 
11a2			;    or     $30 
11a2			;    ld     (de), a 
11a2			;    inc    de 
11a2			;    djnz   - 
11a2			; 
11a2			;; Terminate string with NULL 
11a2			;    xor    a 
11a2			;    ld     (de), a 
11a2			; 
11a2			;    pop    bc 
11a2			;    pop    de 
11a2			;    ret 
11a2			 
11a2			;Comments 
11a2			; 
11a2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11a2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11a2			;    Note that the output string will not be fixed-width. 
11a2			; 
11a2			;Example Usage 
11a2			; 
11a2			;    ld    hl, -1004 
11a2			;    ld    de, OP1 
11a2			;    call  DispA 
11a2			;    ld    hl, OP1 
11a2			;    syscall  PutS 
11a2			 
11a2			 
11a2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11a2			 
11a2			 
11a2			;Converts an ASCII string to an unsigned 16-bit integer 
11a2			;Quits when it reaches a non-decimal digit 
11a2			 
11a2			string_to_uint16: 
11a2			atoui_16: 
11a2			;Input: 
11a2			;     DE points to the string 
11a2			;Outputs: 
11a2			;     HL is the result 
11a2			;     A is the 8-bit value of the number 
11a2			;     DE points to the byte after the number 
11a2			;Destroys: 
11a2			;     BC 
11a2			;       if the string is non-empty, BC is HL/10 
11a2			;Size:  24 bytes 
11a2			;Speed: 42+d(104+{0,9}) 
11a2			;       d is the number of digits in the number 
11a2			;       max is 640 cycles for a 5 digit number 
11a2			;Assuming no leading zeros: 
11a2			;1 digit:  146cc 
11a2			;2 digit:  250cc 
11a2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11a2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11a2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11a2			;avg: 544.81158447265625cc (544+13297/16384) 
11a2			;=============================================================== 
11a2 21 00 00		  ld hl,0 
11a5			.u16a: 
11a5 1a			  ld a,(de) 
11a6 d6 30		  sub 30h 
11a8 fe 0a		  cp 10 
11aa d0			  ret nc 
11ab 13			  inc de 
11ac 44			  ld b,h 
11ad 4d			  ld c,l 
11ae 29			  add hl,hl 
11af 29			  add hl,hl 
11b0 09			  add hl,bc 
11b1 29			  add hl,hl 
11b2 85			  add a,l 
11b3 6f			  ld l,a 
11b4 30 ef		  jr nc,.u16a 
11b6 24			  inc h 
11b7 c3 a5 11		  jp .u16a 
11ba			 
11ba			 
11ba			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11ba			 
11ba			;written by Zeda 
11ba			;Converts a 16-bit unsigned integer to an ASCII string. 
11ba			 
11ba			uitoa_16: 
11ba			;Input: 
11ba			;   DE is the number to convert 
11ba			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11ba			;Output: 
11ba			;   HL points to the null-terminated ASCII string 
11ba			;      NOTE: This isn't necessarily the same as the input HL. 
11ba d5			  push de 
11bb c5			  push bc 
11bc f5			  push af 
11bd eb			  ex de,hl 
11be			 
11be 01 f0 d8		  ld bc,-10000 
11c1 3e 2f		  ld a,'0'-1 
11c3 3c			  inc a 
11c4 09			  add hl,bc  
11c5 38 fc		   jr c,$-2 
11c7 12			  ld (de),a 
11c8 13			  inc de 
11c9			 
11c9 01 e8 03		  ld bc,1000 
11cc 3e 3a		  ld a,'9'+1 
11ce 3d			  dec a  
11cf 09			  add hl,bc  
11d0 30 fc		   jr nc,$-2 
11d2 12			  ld (de),a 
11d3 13			  inc de 
11d4			 
11d4 01 9c ff		  ld bc,-100 
11d7 3e 2f		  ld a,'0'-1 
11d9 3c			  inc a  
11da 09			  add hl,bc  
11db 38 fc		   jr c,$-2 
11dd 12			  ld (de),a 
11de 13			  inc de 
11df			 
11df 7d			  ld a,l 
11e0 26 3a		  ld h,'9'+1 
11e2 25			  dec h  
11e3 c6 0a		  add a,10  
11e5 30 fb		   jr nc,$-3 
11e7 c6 30		  add a,'0' 
11e9 eb			  ex de,hl 
11ea 72			  ld (hl),d 
11eb 23			  inc hl 
11ec 77			  ld (hl),a 
11ed 23			  inc hl 
11ee 36 00		  ld (hl),0 
11f0			 
11f0			;Now strip the leading zeros 
11f0 0e fa		  ld c,-6 
11f2 09			  add hl,bc 
11f3 3e 30		  ld a,'0' 
11f5 23			  inc hl  
11f6 be			  cp (hl)  
11f7 28 fc		  jr z,$-2 
11f9			 
11f9			;Make sure that the string is non-empty! 
11f9 7e			  ld a,(hl) 
11fa b7			  or a 
11fb 20 01		  jr nz,.atoub 
11fd 2b			  dec hl 
11fe			.atoub: 
11fe			 
11fe f1			  pop af 
11ff c1			  pop bc 
1200 d1			  pop de 
1201 c9			  ret 
1202			 
1202			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1202			 
1202			toUpper: 
1202			;A is the char. 
1202			;If A is a lowercase letter, this sets it to the matching uppercase 
1202			;18cc or 30cc or 41cc 
1202			;avg: 26.75cc 
1202 fe 61		  cp 'a' 
1204 d8			  ret c 
1205 fe 7b		  cp 'z'+1 
1207 d0			  ret nc 
1208 d6 20		  sub 'a'-'A' 
120a c9			  ret 
120b			 
120b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
120b			 
120b			; String Length 
120b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
120b			 
120b			; Get the length of the null-terminated string starting at $8000 hl 
120b			;    LD     HL, $8000 
120b			 
120b			strlenz: 
120b			 
120b af			    XOR    A               ; Zero is the value we are looking for. 
120c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
120d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
120e			                           ; 65, 536 bytes (the entire addressable memory space). 
120e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1210			 
1210			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1210 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1211 6f			    LD     L, A             ; number of bytes 
1212 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1214 2b			    DEC    HL              ; Compensate for null. 
1215 c9				ret 
1216			 
1216			; Get the length of the A terminated string starting at $8000 hl 
1216			;    LD     HL, $8000 
1216			 
1216			strlent: 
1216			 
1216			                  ; A is the value we are looking for. 
1216 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1218 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
121a			                           ; 65, 536 bytes (the entire addressable memory space). 
121a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
121c			 
121c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
121c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
121e 2e 00		    LD     L, 0             ; number of bytes 
1220 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1222 2b			    DEC    HL              ; Compensate for null. 
1223 c9				ret 
1224			 
1224			 
1224			;Comparing Strings 
1224			 
1224			;IN    HL     Address of string1. 
1224			;      DE     Address of string2. 
1224			 
1224			; doc given but wrong??? 
1224			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1224			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1224			; tested 
1224			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1224			 
1224			strcmp_old: 
1224 e5			    PUSH   HL 
1225 d5			    PUSH   DE 
1226			 
1226 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1227 be			    CP     (HL)            ; (want to minimize work). 
1228 38 01		    JR     C, Str1IsBigger 
122a 7e			    LD     A, (HL) 
122b			 
122b			Str1IsBigger: 
122b 4f			    LD     C, A             ; Put length in BC 
122c 06 00		    LD     B, 0 
122e 13			    INC    DE              ; Increment pointers to meat of string. 
122f 23			    INC    HL 
1230			 
1230			CmpLoop: 
1230 1a			    LD     A, (DE)          ; Compare bytes. 
1231 ed a1		    CPI 
1233 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1235 13			    INC    DE              ; Update pointer. 
1236 ea 30 12		    JP     PE, CmpLoop 
1239			 
1239 d1			    POP    DE 
123a e1			    POP    HL 
123b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
123c be			    CP     (HL) 
123d c9			    RET 
123e			 
123e			NoMatch: 
123e 2b			    DEC    HL 
123f be			    CP     (HL)            ; Compare again to affect carry. 
1240 d1			    POP    DE 
1241 e1			    POP    HL 
1242 c9			    RET 
1243			 
1243			;; test strmp 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str2 
1243			;call strcmp 
1243			;jr z, .z1 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "NZ1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.z1: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "ZZ1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str1 
1243			;call strcmp 
1243			;jr z, .z2 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "NZ2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.z2: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "ZZ2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str2 
1243			;call strcmp 
1243			;jr c, .c1 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "Nc1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.c1: 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "cc1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str1 
1243			;call strcmp 
1243			;jr c, .c2 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "Nc2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.c2: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "cc2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;	NEXTW 
1243			;.str1:   db "string1",0 
1243			;.str2:   db "string2",0 
1243			 
1243			; only care about direct match or not 
1243			; hl and de strings 
1243			; zero set if the same 
1243			 
1243			strcmp: 
1243 1a				ld a, (de) 
1244 be				cp (hl) 
1245 28 02			jr z, .ssame 
1247 b7				or a 
1248 c9				ret 
1249			 
1249			.ssame:  
1249 fe 00			cp 0 
124b c8				ret z 
124c			 
124c 23				inc hl 
124d 13				inc de 
124e 18 f3			jr strcmp 
1250				 
1250				 
1250			 
1250			 
1250			 
1250			 
1250			; eof 
1250			 
1250			 
1250			 
1250			 
1250			 
1250			 
# End of file firmware_strings.asm
1250			include "firmware_memory.asm"   ; malloc and free  
1250			 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			.mallocsize: db "Wants malloc >256",0 
1250			.mallocasize: db "MALLOC gives >256",0 
1250			.malloczero: db "MALLOC gives zero",0 
1250			 
1250			malloc_guard_zerolen: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250				ld de, 0 
1250			        call cmp16 
1250				jr nz, .lowalloz 
1250			 
1250				push hl 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .malloczero 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250			 
1250				pop de 
1250				pop hl 
1250			 
1250				 
1250			 
1250				CALLMONITOR 
1250			.lowalloz: 
1250			 
1250			 
1250				pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			 
1250			malloc_guard_entry: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250			 	or a      ;clear carry flag 
1250				push hl 
1250				ld de, 255 
1250				sbc hl, de 
1250				jr c, .lowalloc 
1250			 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .mallocsize 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250			 
1250				pop de 
1250				pop hl 
1250			 
1250				 
1250			 
1250				CALLMONITOR 
1250				jr .lowdone 
1250			.lowalloc: 
1250			 
1250			 
1250				pop hl 
1250			.lowdone:	pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			 
1250			malloc_guard_exit: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250			 	or a      ;clear carry flag 
1250				push hl 
1250				ld de, 255 
1250				sbc hl, de 
1250				jr c, .lowallocx 
1250			 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .mallocasize 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250				pop de 
1250				pop hl 
1250			 
1250				CALLMONITOR 
1250				jr .lowdonex 
1250			.lowallocx: 
1250			 
1250				pop hl 
1250			.lowdonex:	pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			endif 
1250			 
1250			if MALLOC_2 
1250			; Z80 Malloc and Free Functions 
1250			 
1250			; Malloc Function: 
1250			; Input: 
1250			;   HL: Size of block to allocate 
1250			; Output: 
1250			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1250			 
1250			malloc: 
1250				 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			call malloc_guard_entry 
1250			endif 
1250			 
1250			 
1250			 
1250			 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "mal" 
1250						CALLMONITOR 
1250					endif 
1250			    push af            ; Save AF register 
1250			    ld a, l            ; Load low byte of size into A 
1250			    or h               ; Check if size is zero 
1250			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1250			 
1250			    ; Allocate memory 
1250			    ld hl, (heap_start) ; Load start of heap into HL 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma1" 
1250						CALLMONITOR 
1250					endif 
1250			    call malloc_internal ; Call internal malloc function 
1250			    pop af             ; Restore AF register 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret                ; Return 
1250			 
1250			; Free Function: 
1250			; Input: 
1250			;   HL: Pointer to memory block to free 
1250			; Output: 
1250			;   None 
1250			 
1250			free: 
1250			    push af            ; Save AF register 
1250			    ld a, l            ; Load low byte of pointer into A 
1250			    or h               ; Check if pointer is NULL 
1250			    jp z, free_exit    ; If pointer is NULL, exit 
1250			 
1250			    ; Free memory 
1250			    ld hl, (heap_start) ; Load start of heap into HL 
1250			    call free_internal  ; Call internal free function 
1250			    pop af             ; Restore AF register 
1250			    ret                ; Return 
1250			 
1250			; Internal Malloc Function: 
1250			; Input: 
1250			;   HL: Size of block to allocate 
1250			; Output: 
1250			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1250			 
1250			malloc_internal: 
1250			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1250			    add hl, bc         ; Add management overhead to requested size 
1250			    ex de, hl          ; Save total size in DE, and keep it in HL 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma2" 
1250						CALLMONITOR 
1250					endif 
1250			 
1250			    ; Search for free memory block 
1250			    ld de, (heap_end)  ; Load end of heap into DE 
1250			    ld bc, 0           ; Initialize counter 
1250			 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma2" 
1250						CALLMONITOR 
1250					endif 
1250			malloc_search_loop: 
1250			    ; Check if current block is free 
1250			    ld a, (hl)         ; Load current block's status (free or used) 
1250			    cp 0               ; Compare with zero (free) 
1250			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1250			 
1250			    ; Check if current block is large enough 
1250			    ld a, (hl+1)       ; Load high byte of block size 
1250			    cp l               ; Compare with low byte of requested size 
1250			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1250			 
1250			    ld a, (hl+2)       ; Load low byte of block size 
1250			    cp h               ; Compare with high byte of requested size 
1250			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1250			 
1250			    ; Mark block as used 
1250			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1250			 
1250			    ; Calculate remaining space in block 
1250			    ld bc, 0           ; Clear BC 
1250			    add hl, bc         ; Increment HL to point to start of data block 
1250			    add hl, de         ; HL = HL + DE (total size) 
1250			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1250			    add hl, bc         ; Add management overhead to start of data block 
1250			 
1250			    ; Save pointer to allocated block in HL 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma5" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			 
1250			malloc_skip_block_check: 
1250			    ; Move to the next block 
1250			    ld bc, 3           ; Size of management overhead 
1250			    add hl, bc         ; Move to the next block 
1250			    inc de             ; Increment counter 
1250			 
1250			    ; Check if we have reached the end of heap 
1250			    ld a, e            ; Load low byte of heap end address 
1250			    cp (hl)            ; Compare with low byte of current address 
1250			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1250			    ld a, d            ; Load high byte of heap end address 
1250			    cp 0               ; Check if it's zero (end of memory) 
1250			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1250			 
1250			    ; If we reached here, allocation failed 
1250			    xor a              ; Set result to NULL 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma6" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			malloc_exit: 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma7" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			 
1250			; Internal Free Function: 
1250			; Input: 
1250			;   HL: Pointer to memory block to free 
1250			; Output: 
1250			;   None 
1250			 
1250			free_internal: 
1250			    ld de, (heap_start) ; Load start of heap into DE 
1250			    ld bc, 0            ; Initialize counter 
1250			 
1250			free_search_loop: 
1250			    ; Check if current block contains the pointer 
1250			    ld a, l             ; Load low byte of pointer 
1250			    cp (hl+1)           ; Compare with high byte of current block's address 
1250			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1250			    ld a, h             ; Load high byte of pointer 
1250			    cp (hl+2)           ; Compare with low byte of current block's address 
1250			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1250			 
1250			    ; Mark block as free 
1250			    ld (hl), 0          ; Set status byte to indicate free block 
1250			    ret                 ; Return 
1250			 
1250			free_skip_block_check: 
1250			    ; Move to the next block 
1250			    ld bc, 3            ; Size of management overhead 
1250			    add hl, bc          ; Move to the next block 
1250			    inc de              ; Increment counter 
1250			 
1250			    ; Check if we have reached the end of heap 
1250			    ld a, e             ; Load low byte of heap end address 
1250			    cp (hl)             ; Compare with low byte of current address 
1250			    jr nz, free_search_loop  ; If not equal, continue searching 
1250			    ld a, d             ; Load high byte of heap end address 
1250			    cp 0                ; Check if it's zero (end of memory) 
1250			    jr nz, free_search_loop  ; If not zero, continue searching 
1250			 
1250			    ; If we reached here, pointer is not found in heap 
1250			    ret 
1250			 
1250			free_exit: 
1250			    ret                 ; Return 
1250			 
1250			; Define heap start and end addresses 
1250			;heap_start:    .dw 0xC000   ; Start of heap 
1250			;heap_end:      .dw 0xE000   ; End of heap 
1250			 
1250			endif 
1250			 
1250			 
1250			if MALLOC_1 
1250			 
1250			 
1250			 
1250			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1250			 
1250			;moved to firmware.asm 
1250			;heap_start        .equ  0x9000      ; Starting address of heap 
1250			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1250			 
1250			;      .org 0 
1250			;      jp    main 
1250			 
1250			 
1250			;      .org  0x100 
1250			;main: 
1250			;      ld    HL, 0x8100 
1250			;      ld    SP, HL 
1250			; 
1250			;      call  heap_init 
1250			; 
1250			;      ; Make some allocations 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9004 
1250			; 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9014 
1250			; 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9024 
1250			; 
1250			;      ; Free some allocations 
1250			;      ld    HL, 0x9014 
1250			;      call  free 
1250			; 
1250			;      ld    HL, 0x9004 
1250			;      call  free 
1250			; 
1250			;      ld    HL, 0x9024 
1250			;      call  free 
1250			; 
1250			; 
1250			;      halt 
1250			 
1250			 
1250			;------------------------------------------------------------------------------ 
1250			;     heap_init                                                               : 
1250			;                                                                             : 
1250			; Description                                                                 : 
1250			;     Initialise the heap and make it ready for malloc and free operations.   : 
1250			;                                                                             : 
1250			;     The heap is maintained as a linked list, starting with an initial       : 
1250			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1250			;     the first free block in the heap. Each block then points to the next    : 
1250			;     free block within the heap, and the free list ends at the first block   : 
1250			;     with a null pointer to the next free block.                             : 
1250			;                                                                             : 
1250			; Parameters                                                                  : 
1250			;     Inputs are compile-time only. Two defines which specify the starting    : 
1250			;     address of the heap and its size are required, along with a memory      : 
1250			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1250			;     principally stores a pointer to the first free block in the heap.       : 
1250			;                                                                             : 
1250			; Returns                                                                     : 
1250			;     Nothing                                                                 : 
1250			;------------------------------------------------------------------------------ 
1250			heap_init: 
1250 e5			      push  HL 
1251			 
1251			      ; Initialise free list struct 
1251 21 41 64		      ld    HL, heap_start 
1254 22 3c 64		      ld    (free_list), HL 
1257 21 00 00		      ld    HL, 0 
125a 22 3e 64		      ld    (free_list+2), HL 
125d			 
125d			      ; Insert first free block at bottom of heap, consumes entire heap 
125d 21 ad e2		      ld    HL, heap_start+heap_size-4 
1260 22 41 64		      ld    (heap_start), HL        ; Next block (end of free list) 
1263 21 6c 7e		      ld    HL, heap_size-4 
1266 22 43 64		      ld    (heap_start+2), HL      ; Block size 
1269			 
1269			      ; Insert end of free list block at top of heap - two null words will 
1269			      ; terminate the free list 
1269 21 00 00		      ld    HL, 0 
126c 22 af e2		      ld    (heap_start+heap_size-2), HL 
126f 22 ad e2		      ld    (heap_start+heap_size-4), HL 
1272			 
1272 e1			      pop   HL 
1273			 
1273 c9			      ret 
1274			 
1274			 
1274			;------------------------------------------------------------------------------ 
1274			;     malloc                                                                  : 
1274			;                                                                             : 
1274			; Description                                                                 : 
1274			;     Allocates the wanted space from the heap and returns the address of the : 
1274			;     first useable byte of the allocation.                                   : 
1274			;                                                                             : 
1274			;     Allocations can happen in one of two ways:                              : 
1274			;                                                                             : 
1274			;     1. A free block may be found which is the exact size wanted. In this    : 
1274			;        case the block is removed from the free list and retuedn to the      : 
1274			;        caller.                                                              : 
1274			;     2. A free block may be found which is larger than the size wanted. In   : 
1274			;        this case, the larger block is split into two. The first portion of  : 
1274			;        this block will become the requested space by the malloc call and    : 
1274			;        is returned to the caller. The second portion becomes a new free     : 
1274			;        block, and the free list is adjusted to maintain continuity via this : 
1274			;        newly created block.                                                 : 
1274			;                                                                             : 
1274			;     malloc does not set any initial value in the allocated space, the       : 
1274			;     caller is required to do this as required.                              : 
1274			;                                                                             : 
1274			;     This implementation of malloc uses the stack exclusively, and is        : 
1274			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1274			;     advisable to disable interrupts before calling malloc, and recommended  : 
1274			;     to avoid the use of malloc inside ISRs in general.                      : 
1274			;                                                                             : 
1274			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1274			;                                                                             : 
1274			; Parameters                                                                  : 
1274			;     HL  Number of bytes wanted                                              : 
1274			;                                                                             : 
1274			; Returns                                                                     : 
1274			;     HL  Address of the first useable byte of the allocation                 : 
1274			;                                                                             : 
1274			; Flags                                                                       : 
1274			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1274			;                                                                             : 
1274			; Stack frame                                                                 : 
1274			;       |             |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     BC      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     DE      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     IX      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |  prev_free  |                                                       : 
1274			;   +4  +-------------+                                                       : 
1274			;       |  this_free  |                                                       : 
1274			;   +2  +-------------+                                                       : 
1274			;       |  next_free  |                                                       : 
1274			;   +0  +-------------+                                                       : 
1274			;       |             |                                                       : 
1274			;                                                                             : 
1274			;------------------------------------------------------------------------------ 
1274			 
1274			 
1274			;malloc: 
1274			; 
1274			;	SAVESP ON 1 
1274			; 
1274			;	call malloc_code 
1274			; 
1274			;	CHECKSP ON 1 
1274			;	ret 
1274			 
1274			 
1274			malloc: 
1274 c5			      push  BC 
1275 d5			      push  DE 
1276 dd e5		      push  IX 
1278			if DEBUG_FORTH_MALLOC_HIGH 
1278			call malloc_guard_entry 
1278			endif 
1278			 
1278					if DEBUG_FORTH_MALLOC 
1278						DMARK "mal" 
1278						CALLMONITOR 
1278					endif 
1278 7c			      ld    A, H                    ; Exit if no space requested 
1279 b5			      or    L 
127a ca 39 13		      jp    Z, malloc_early_exit 
127d			 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			; 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			 
127d			 
127d			 
127d			 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "maA" 
127d						CALLMONITOR 
127d					endif 
127d			      ; Set up stack frame 
127d eb			      ex    DE, HL 
127e 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1281 39			      add   HL, SP 
1282 f9			      ld    SP, HL 
1283 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1287 dd 39		      add   IX, SP 
1289			 
1289			      ; Setup initial state 
1289 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
128c 19			      add   HL, DE 
128d			 
128d 44			      ld    B, H                    ; Move want to BC 
128e 4d			      ld    C, L 
128f			 
128f 21 3c 64		      ld    HL, free_list           ; Store prev_free ptr to stack 
1292 dd 75 04		      ld    (IX+4), L 
1295 dd 74 05		      ld    (IX+5), H 
1298			 
1298 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1299 23			      inc   HL 
129a 56			      ld    D, (HL) 
129b dd 73 02		      ld    (IX+2), E 
129e dd 72 03		      ld    (IX+3), D 
12a1 eb			      ex    DE, HL                  ; this_free ptr into HL 
12a2			 
12a2					if DEBUG_FORTH_MALLOC 
12a2						DMARK "maB" 
12a2						CALLMONITOR 
12a2					endif 
12a2			      ; Loop through free block list to find some space 
12a2			malloc_find_space: 
12a2 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12a3 23			      inc   HL 
12a4 56			      ld    D, (HL) 
12a5			 
12a5 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12a6 b3			      or    E 
12a7 ca 33 13		      jp    Z, malloc_no_space 
12aa			 
12aa dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12ad dd 72 01		      ld    (IX+1), D 
12b0			 
12b0			      ; Does this block have enough space to make the allocation? 
12b0 23			      inc   HL                      ; Load free block size into DE 
12b1 5e			      ld    E, (HL) 
12b2 23			      inc   HL 
12b3 56			      ld    D, (HL) 
12b4			 
12b4 eb			      ex    DE, HL                  ; Check size of block against want 
12b5 b7			      or    A                       ; Ensure carry flag clear 
12b6 ed 42		      sbc   HL, BC 
12b8 e5			      push  HL                      ; Store the result for later (new block size) 
12b9			 
12b9 ca 08 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12bc 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12be			 
12be			      ; this_free block is not big enough, setup ptrs to test next free block 
12be e1			      pop   HL                      ; Discard previous result 
12bf			 
12bf dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12c2 dd 66 03		      ld    H, (IX+3) 
12c5 dd 75 04		      ld    (IX+4), L 
12c8 dd 74 05		      ld    (IX+5), H 
12cb			 
12cb dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12ce dd 66 01		      ld    H, (IX+1) 
12d1 dd 75 02		      ld    (IX+2), L 
12d4 dd 74 03		      ld    (IX+3), H 
12d7			 
12d7					if DEBUG_FORTH_MALLOC 
12d7						DMARK "MA>" 
12d7						CALLMONITOR 
12d7					endif 
12d7 18 c9		      jr    malloc_find_space 
12d9			 
12d9			      ; split a bigger block into two - requested size and remaining size 
12d9			malloc_alloc_split: 
12d9					if DEBUG_FORTH_MALLOC 
12d9						DMARK "MAs" 
12d9						CALLMONITOR 
12d9					endif 
12d9 eb			      ex    DE, HL                  ; Calculate address of new free block 
12da 2b			      dec   HL 
12db 2b			      dec   HL 
12dc 2b			      dec   HL 
12dd 09			      add   HL, BC 
12de			 
12de			      ; Create a new block and point it at next_free 
12de dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
12e1 dd 56 01		      ld    D, (IX+1) 
12e4			 
12e4 73			      ld    (HL), E                 ; Store next_free ptr into new block 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7 d1			      pop   DE                      ; Store size of new block into new block 
12e8 23			      inc   HL 
12e9 73			      ld    (HL), E 
12ea 23			      inc   HL 
12eb 72			      ld    (HL), D 
12ec			 
12ec			      ; Update this_free ptr to point to new block 
12ec 2b			      dec   HL 
12ed 2b			      dec   HL 
12ee 2b			      dec   HL 
12ef			 
12ef dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
12f2 dd 56 03		      ld    D, (IX+3) 
12f5			 
12f5 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
12f8 dd 74 03		      ld    (IX+3), H 
12fb			 
12fb			      ; Modify this_free block to be allocation 
12fb eb			      ex    DE, HL 
12fc af			      xor   A                       ; Null the next block ptr of allocated block 
12fd 77			      ld    (HL), A 
12fe 23			      inc   HL 
12ff 77			      ld    (HL), A 
1300			 
1300 23			      inc   HL                      ; Store want size into allocated block 
1301 71			      ld    (HL), C 
1302 23			      inc   HL 
1303 70			      ld    (HL), B 
1304 23			      inc   HL 
1305 e5			      push  HL                      ; Address of allocation to return 
1306			 
1306 18 19		      jr    malloc_update_links 
1308			 
1308			malloc_alloc_fit: 
1308 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1309			 
1309					if DEBUG_FORTH_MALLOC 
1309						DMARK "MAf" 
1309						CALLMONITOR 
1309					endif 
1309			      ; Modify this_free block to be allocation 
1309 eb			      ex    DE, HL 
130a 2b			      dec   HL 
130b 2b			      dec   HL 
130c 2b			      dec   HL 
130d			 
130d af			      xor   A                       ; Null the next block ptr of allocated block 
130e 77			      ld    (HL), A 
130f 23			      inc   HL 
1310 77			      ld    (HL), A 
1311			 
1311 23			      inc   HL                      ; Store address of allocation to return 
1312 23			      inc   HL 
1313 23			      inc   HL 
1314 e5			      push  HL 
1315			 
1315			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1315 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1318 dd 66 01		      ld    H, (IX+1) 
131b			 
131b dd 75 02		      ld    (IX+2), L               ; HL to this_free 
131e dd 74 03		      ld    (IX+3), H 
1321			 
1321			 
1321			malloc_update_links: 
1321			      ; Update prev_free ptr to point to this_free 
1321 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1324 dd 66 05		      ld    H, (IX+5) 
1327			 
1327 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
132a dd 56 03		      ld    D, (IX+3) 
132d			 
132d 73			      ld    (HL), E                 ; this_free ptr into prev_free 
132e 23			      inc   HL 
132f 72			      ld    (HL), D 
1330			 
1330					if DEBUG_FORTH_MALLOC 
1330						DMARK "Mul" 
1330						CALLMONITOR 
1330					endif 
1330			      ; Clear the Z flag to indicate successful allocation 
1330 7a			      ld    A, D 
1331 b3			      or    E 
1332			 
1332 d1			      pop   DE                      ; Address of allocation 
1333					if DEBUG_FORTH_MALLOC 
1333						DMARK "MAu" 
1333						CALLMONITOR 
1333					endif 
1333			 
1333			malloc_no_space: 
1333 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1336 39			      add   HL, SP 
1337 f9			      ld    SP, HL 
1338			 
1338 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1339					if DEBUG_FORTH_MALLOC 
1339						DMARK "MAN" 
1339						CALLMONITOR 
1339					endif 
1339			 
1339			malloc_early_exit: 
1339					if DEBUG_FORTH_MALLOC 
1339						DMARK "MAx" 
1339						CALLMONITOR 
1339					endif 
1339 dd e1		      pop   IX 
133b d1			      pop   DE 
133c c1			      pop   BC 
133d			 
133d			if DEBUG_FORTH_MALLOC_HIGH 
133d			call malloc_guard_exit 
133d			call malloc_guard_zerolen 
133d			endif 
133d c9			      ret 
133e			 
133e			 
133e			;------------------------------------------------------------------------------ 
133e			;     free                                                                    : 
133e			;                                                                             : 
133e			; Description                                                                 : 
133e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
133e			;     returned by malloc, otherwise the behaviour is undefined.               : 
133e			;                                                                             : 
133e			;     Where possible, directly adjacent free blocks will be merged together   : 
133e			;     into larger blocks to help ensure that the heap does not become         : 
133e			;     excessively fragmented.                                                 : 
133e			;                                                                             : 
133e			;     free does not clear or set any other value into the freed space, and    : 
133e			;     therefore its contents may be visible through subsequent malloc's. The  : 
133e			;     caller should clear the freed space as required.                        : 
133e			;                                                                             : 
133e			;     This implementation of free uses the stack exclusively, and is          : 
133e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
133e			;     advisable to disable interrupts before calling free, and recommended    : 
133e			;     to avoid the use of free inside ISRs in general.                        : 
133e			;                                                                             : 
133e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
133e			;                                                                             : 
133e			; Parameters                                                                  : 
133e			;     HL  Pointer to address of first byte of allocation to be freed          : 
133e			;                                                                             : 
133e			; Returns                                                                     : 
133e			;     Nothing                                                                 : 
133e			;                                                                             : 
133e			; Stack frame                                                                 : 
133e			;       |             |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     BC      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     DE      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     IX      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |  prev_free  |                                                       : 
133e			;   +2  +-------------+                                                       : 
133e			;       |  next_free  |                                                       : 
133e			;   +0  +-------------+                                                       : 
133e			;       |             |                                                       : 
133e			;                                                                             : 
133e			;------------------------------------------------------------------------------ 
133e			free: 
133e c5			      push  BC 
133f d5			      push  DE 
1340 dd e5		      push  IX 
1342			 
1342 7c			      ld    A, H                    ; Exit if ptr is null 
1343 b5			      or    L 
1344 ca 08 14		      jp    Z, free_early_exit 
1347			 
1347			      ; Set up stack frame 
1347 eb			      ex    DE, HL 
1348 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
134b 39			      add   HL, SP 
134c f9			      ld    SP, HL 
134d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1351 dd 39		      add   IX, SP 
1353			 
1353			      ; The address in HL points to the start of the useable allocated space, 
1353			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1353			      ; address of the block itself. 
1353 eb			      ex    DE, HL 
1354 11 fc ff		      ld    DE, -4 
1357 19			      add   HL, DE 
1358			 
1358			      ; An allocated block must have a null next block pointer in it 
1358 7e			      ld    A, (HL) 
1359 23			      inc   HL 
135a b6			      or    (HL) 
135b c2 03 14		      jp    NZ, free_done 
135e			 
135e 2b			      dec   HL 
135f			 
135f 44			      ld    B, H                    ; Copy HL to BC 
1360 4d			      ld    C, L 
1361			 
1361			      ; Loop through the free list to find the first block with an address 
1361			      ; higher than the block being freed 
1361 21 3c 64		      ld    HL, free_list 
1364			 
1364			free_find_higher_block: 
1364 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1365 23			      inc   HL 
1366 56			      ld    D, (HL) 
1367 2b			      dec   HL 
1368			 
1368 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
136b dd 72 01		      ld    (IX+1), D 
136e dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1371 dd 74 03		      ld    (IX+3), H 
1374			 
1374 78			      ld    A, B                    ; Check if DE is greater than BC 
1375 ba			      cp    D                       ; Compare MSB first 
1376 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1378 30 04		      jr    NC, free_find_higher_block_skip 
137a 79			      ld    A, C 
137b bb			      cp    E                       ; Then compare LSB 
137c 38 08		      jr    C, free_found_higher_block 
137e			 
137e			free_find_higher_block_skip: 
137e 7a			      ld    A, D                    ; Reached the end of the free list? 
137f b3			      or    E 
1380 ca 03 14		      jp    Z, free_done 
1383			 
1383 eb			      ex    DE, HL 
1384			 
1384 18 de		      jr    free_find_higher_block 
1386			 
1386			free_found_higher_block: 
1386			      ; Insert freed block between prev and next free blocks 
1386 71			      ld    (HL), C                 ; Point prev free block to freed block 
1387 23			      inc   HL 
1388 70			      ld    (HL), B 
1389			 
1389 60			      ld    H, B                    ; Point freed block at next free block 
138a 69			      ld    L, C 
138b 73			      ld    (HL), E 
138c 23			      inc   HL 
138d 72			      ld    (HL), D 
138e			 
138e			      ; Check if the freed block is adjacent to the next free block 
138e 23			      inc   HL                      ; Load size of freed block into HL 
138f 5e			      ld    E, (HL) 
1390 23			      inc   HL 
1391 56			      ld    D, (HL) 
1392 eb			      ex    DE, HL 
1393			 
1393 09			      add   HL, BC                  ; Add addr of freed block and its size 
1394			 
1394 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1397 dd 56 01		      ld    D, (IX+1) 
139a			 
139a b7			      or    A                       ; Clear the carry flag 
139b ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
139d 20 22		      jr    NZ, free_check_adjacent_to_prev 
139f			 
139f			      ; Freed block is adjacent to next, merge into one bigger block 
139f eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13a0 5e			      ld    E, (HL) 
13a1 23			      inc   HL 
13a2 56			      ld    D, (HL) 
13a3 e5			      push  HL                      ; Save ptr to next block for later 
13a4			 
13a4 60			      ld    H, B                    ; Store ptr from next block into freed block 
13a5 69			      ld    L, C 
13a6 73			      ld    (HL), E 
13a7 23			      inc   HL 
13a8 72			      ld    (HL), D 
13a9			 
13a9 e1			      pop   HL                      ; Restore ptr to next block 
13aa 23			      inc   HL                      ; Load size of next block into DE 
13ab 5e			      ld    E, (HL) 
13ac 23			      inc   HL 
13ad 56			      ld    D, (HL) 
13ae d5			      push  DE                      ; Save next block size for later 
13af			 
13af 60			      ld    H, B                    ; Load size of freed block into HL 
13b0 69			      ld    L, C 
13b1 23			      inc   HL 
13b2 23			      inc   HL 
13b3 5e			      ld    E, (HL) 
13b4 23			      inc   HL 
13b5 56			      ld    D, (HL) 
13b6 eb			      ex    DE, HL 
13b7			 
13b7 d1			      pop   DE                      ; Restore size of next block 
13b8 19			      add   HL, DE                  ; Add sizes of both blocks 
13b9 eb			      ex    DE, HL 
13ba			 
13ba 60			      ld    H, B                    ; Store new bigger size into freed block 
13bb 69			      ld    L, C 
13bc 23			      inc   HL 
13bd 23			      inc   HL 
13be 73			      ld    (HL), E 
13bf 23			      inc   HL 
13c0 72			      ld    (HL), D 
13c1			 
13c1			free_check_adjacent_to_prev: 
13c1			      ; Check if the freed block is adjacent to the prev free block 
13c1 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13c4 dd 66 03		      ld    H, (IX+3) 
13c7			 
13c7 23			      inc   HL                      ; Size of prev free block into DE 
13c8 23			      inc   HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc 2b			      dec   HL 
13cd 2b			      dec   HL 
13ce 2b			      dec   HL 
13cf			 
13cf 19			      add   HL, DE                  ; Add prev block addr and size 
13d0			 
13d0 b7			      or    A                       ; Clear the carry flag 
13d1 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
13d3 20 2e		      jr    NZ, free_done 
13d5			 
13d5			      ; Freed block is adjacent to prev, merge into one bigger block 
13d5 60			      ld    H, B                    ; Load next ptr from freed block into DE 
13d6 69			      ld    L, C 
13d7 5e			      ld    E, (HL) 
13d8 23			      inc   HL 
13d9 56			      ld    D, (HL) 
13da e5			      push  HL                      ; Save freed block ptr for later 
13db			 
13db dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
13de dd 66 03		      ld    H, (IX+3) 
13e1 73			      ld    (HL), E 
13e2 23			      inc   HL 
13e3 72			      ld    (HL), D 
13e4			 
13e4 e1			      pop   HL                      ; Restore freed block ptr 
13e5 23			      inc   HL                      ; Load size of freed block into DE 
13e6 5e			      ld    E, (HL) 
13e7 23			      inc   HL 
13e8 56			      ld    D, (HL) 
13e9 d5			      push  DE                      ; Save freed block size for later 
13ea			 
13ea dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
13ed dd 66 03		      ld    H, (IX+3) 
13f0 23			      inc   HL 
13f1 23			      inc   HL 
13f2 5e			      ld    E, (HL) 
13f3 23			      inc   HL 
13f4 56			      ld    D, (HL) 
13f5			 
13f5 e1			      pop   HL                      ; Add sizes of both blocks 
13f6 19			      add   HL, DE 
13f7 eb			      ex    DE, HL 
13f8			 
13f8 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
13fb dd 66 03		      ld    H, (IX+3) 
13fe 23			      inc   HL 
13ff 23			      inc   HL 
1400 73			      ld    (HL), E 
1401 23			      inc   HL 
1402 72			      ld    (HL), D 
1403			 
1403			free_done: 
1403 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1406 39			      add   HL, SP 
1407 f9			      ld    SP, HL 
1408			 
1408			free_early_exit: 
1408 dd e1		      pop   IX 
140a d1			      pop   DE 
140b c1			      pop   BC 
140c			 
140c c9			      ret 
140d			 
140d			; moved to firmware.asm 
140d			; 
140d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
140d			;                  .dw   0 
140d			 
140d			 
140d			endif 
140d			 
140d			 
140d			if MALLOC_3 
140d			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
140d			;heap_start        .equ  0x9000      ; Starting address of heap 
140d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
140d			; 
140d			 ;     .org 0 
140d			  ;    jp    main 
140d			; 
140d			; 
140d			 ;     .org  0x100 
140d			;main: 
140d			 ;     ld    HL, 0x8100 
140d			  ;    ld    SP, HL 
140d			; 
140d			;      call  heap_init 
140d			 
140d			      ; Make some allocations 
140d			;      ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9004 
140d			; 
140d			 ;     ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9014 
140d			 
140d			;      ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9024 
140d			 
140d			      ; Free some allocations 
140d			;      ld    HL, 0x9014 
140d			;      call  free 
140d			 
140d			;      ld    HL, 0x9004 
140d			;      call  free 
140d			; 
140d			;      ld    HL, 0x9024 
140d			;      call  free 
140d			 
140d			 
140d			 ;     halt 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     heap_init                                                               : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Initialise the heap and make it ready for malloc and free operations.   : 
140d			;                                                                             : 
140d			;     The heap is maintained as a linked list, starting with an initial       : 
140d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
140d			;     the first free block in the heap. Each block then points to the next    : 
140d			;     free block within the heap, and the free list ends at the first block   : 
140d			;     with a null pointer to the next free block.                             : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     Inputs are compile-time only. Two defines which specify the starting    : 
140d			;     address of the heap and its size are required, along with a memory      : 
140d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
140d			;     principally stores a pointer to the first free block in the heap.       : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     Nothing                                                                 : 
140d			;------------------------------------------------------------------------------ 
140d			heap_init: 
140d			      push  HL 
140d			 
140d			      ; Initialise free list struct 
140d			      ld    HL, heap_start 
140d			      ld    (free_list), HL 
140d			      ld    HL, 0 
140d			      ld    (free_list+2), HL 
140d			 
140d			      ; Insert first free block at bottom of heap, consumes entire heap 
140d			      ld    HL, heap_start+heap_size-4 
140d			      ld    (heap_start), HL        ; Next block (end of free list) 
140d			      ld    HL, heap_size-4 
140d			      ld    (heap_start+2), HL      ; Block size 
140d			 
140d			      ; Insert end of free list block at top of heap - two null words will 
140d			      ; terminate the free list 
140d			      ld    HL, 0 
140d			      ld    (heap_start+heap_size-2), HL 
140d			      ld    (heap_start+heap_size-4), HL 
140d			 
140d			      pop   HL 
140d			 
140d			      ret 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     malloc                                                                  : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Allocates the wanted space from the heap and returns the address of the : 
140d			;     first useable byte of the allocation.                                   : 
140d			;                                                                             : 
140d			;     Allocations can happen in one of two ways:                              : 
140d			;                                                                             : 
140d			;     1. A free block may be found which is the exact size wanted. In this    : 
140d			;        case the block is removed from the free list and retuedn to the      : 
140d			;        caller.                                                              : 
140d			;     2. A free block may be found which is larger than the size wanted. In   : 
140d			;        this case, the larger block is split into two. The first portion of  : 
140d			;        this block will become the requested space by the malloc call and    : 
140d			;        is returned to the caller. The second portion becomes a new free     : 
140d			;        block, and the free list is adjusted to maintain continuity via this : 
140d			;        newly created block.                                                 : 
140d			;                                                                             : 
140d			;     malloc does not set any initial value in the allocated space, the       : 
140d			;     caller is required to do this as required.                              : 
140d			;                                                                             : 
140d			;     This implementation of malloc uses the stack exclusively, and is        : 
140d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
140d			;     advisable to disable interrupts before calling malloc, and recommended  : 
140d			;     to avoid the use of malloc inside ISRs in general.                      : 
140d			;                                                                             : 
140d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     HL  Number of bytes wanted                                              : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     HL  Address of the first useable byte of the allocation                 : 
140d			;                                                                             : 
140d			; Flags                                                                       : 
140d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
140d			;                                                                             : 
140d			; Stack frame                                                                 : 
140d			;       |             |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     BC      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     DE      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     IX      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |  prev_free  |                                                       : 
140d			;   +4  +-------------+                                                       : 
140d			;       |  this_free  |                                                       : 
140d			;   +2  +-------------+                                                       : 
140d			;       |  next_free  |                                                       : 
140d			;   +0  +-------------+                                                       : 
140d			;       |             |                                                       : 
140d			;                                                                             : 
140d			;------------------------------------------------------------------------------ 
140d			malloc: 
140d			      push  BC 
140d			      push  DE 
140d			      push  IX 
140d			 
140d			      ld    A, H                    ; Exit if no space requested 
140d			      or    L 
140d			      jp    Z, malloc_early_exit 
140d			 
140d			      ; Set up stack frame 
140d			      ex    DE, HL 
140d			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			      ld    IX, 0                   ; Use IX as a frame pointer 
140d			      add   IX, SP 
140d			 
140d			      ; Setup initial state 
140d			      ld    HL, 4                   ; want must also include space used by block struct 
140d			      add   HL, DE 
140d			 
140d			      ld    B, H                    ; Move want to BC 
140d			      ld    C, L 
140d			 
140d			      ld    HL, free_list           ; Store prev_free ptr to stack 
140d			      ld    (IX+4), L 
140d			      ld    (IX+5), H 
140d			 
140d			      ld    E, (HL)                 ; Store this_free ptr to stack 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ld    (IX+2), E 
140d			      ld    (IX+3), D 
140d			      ex    DE, HL                  ; this_free ptr into HL 
140d			 
140d			      ; Loop through free block list to find some space 
140d			malloc_find_space: 
140d			      ld    E, (HL)                 ; Load next_free ptr into DE 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      ld    A, D                    ; Check for null next_free ptr - end of free list 
140d			      or    E 
140d			      jp    Z, malloc_no_space 
140d			 
140d			      ld    (IX+0), E               ; Store next_free ptr to stack 
140d			      ld    (IX+1), D 
140d			 
140d			      ; Does this block have enough space to make the allocation? 
140d			      inc   HL                      ; Load free block size into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      ex    DE, HL                  ; Check size of block against want 
140d			      or    A                       ; Ensure carry flag clear 
140d			      sbc   HL, BC 
140d			      push  HL                      ; Store the result for later (new block size) 
140d			 
140d			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
140d			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
140d			 
140d			      ; this_free block is not big enough, setup ptrs to test next free block 
140d			      pop   HL                      ; Discard previous result 
140d			 
140d			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
140d			      ld    H, (IX+3) 
140d			      ld    (IX+4), L 
140d			      ld    (IX+5), H 
140d			 
140d			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
140d			      ld    H, (IX+1) 
140d			      ld    (IX+2), L 
140d			      ld    (IX+3), H 
140d			 
140d			      jr    malloc_find_space 
140d			 
140d			      ; split a bigger block into two - requested size and remaining size 
140d			malloc_alloc_split: 
140d			      ex    DE, HL                  ; Calculate address of new free block 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			      add   HL, BC 
140d			 
140d			      ; Create a new block and point it at next_free 
140d			      ld    E, (IX+0)               ; Load next_free ptr into DE 
140d			      ld    D, (IX+1) 
140d			 
140d			      ld    (HL), E                 ; Store next_free ptr into new block 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   DE                      ; Store size of new block into new block 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Update this_free ptr to point to new block 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
140d			      ld    D, (IX+3) 
140d			 
140d			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
140d			      ld    (IX+3), H 
140d			 
140d			      ; Modify this_free block to be allocation 
140d			      ex    DE, HL 
140d			      xor   A                       ; Null the next block ptr of allocated block 
140d			      ld    (HL), A 
140d			      inc   HL 
140d			      ld    (HL), A 
140d			 
140d			      inc   HL                      ; Store want size into allocated block 
140d			      ld    (HL), C 
140d			      inc   HL 
140d			      ld    (HL), B 
140d			      inc   HL 
140d			      push  HL                      ; Address of allocation to return 
140d			 
140d			      jr    malloc_update_links 
140d			 
140d			malloc_alloc_fit: 
140d			      pop   HL                      ; Dont need new block size, want is exact fit 
140d			 
140d			      ; Modify this_free block to be allocation 
140d			      ex    DE, HL 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      xor   A                       ; Null the next block ptr of allocated block 
140d			      ld    (HL), A 
140d			      inc   HL 
140d			      ld    (HL), A 
140d			 
140d			      inc   HL                      ; Store address of allocation to return 
140d			      inc   HL 
140d			      inc   HL 
140d			      push  HL 
140d			 
140d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
140d			      ld    L, (IX+0)               ; next_free to HL 
140d			      ld    H, (IX+1) 
140d			 
140d			      ld    (IX+2), L               ; HL to this_free 
140d			      ld    (IX+3), H 
140d			 
140d			 
140d			malloc_update_links: 
140d			      ; Update prev_free ptr to point to this_free 
140d			      ld    L, (IX+4)               ; prev_free ptr to HL 
140d			      ld    H, (IX+5) 
140d			 
140d			      ld    E, (IX+2)               ; this_free ptr to DE 
140d			      ld    D, (IX+3) 
140d			 
140d			      ld    (HL), E                 ; this_free ptr into prev_free 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Clear the Z flag to indicate successful allocation 
140d			      ld    A, D 
140d			      or    E 
140d			 
140d			      pop   DE                      ; Address of allocation 
140d			 
140d			malloc_no_space: 
140d			      ld    HL, 6                   ; Clean up stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			 
140d			      ex    DE, HL                  ; Alloc addr into HL for return 
140d			 
140d			malloc_early_exit: 
140d			      pop   IX 
140d			      pop   DE 
140d			      pop   BC 
140d			 
140d			      ret 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     free                                                                    : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
140d			;     returned by malloc, otherwise the behaviour is undefined.               : 
140d			;                                                                             : 
140d			;     Where possible, directly adjacent free blocks will be merged together   : 
140d			;     into larger blocks to help ensure that the heap does not become         : 
140d			;     excessively fragmented.                                                 : 
140d			;                                                                             : 
140d			;     free does not clear or set any other value into the freed space, and    : 
140d			;     therefore its contents may be visible through subsequent malloc's. The  : 
140d			;     caller should clear the freed space as required.                        : 
140d			;                                                                             : 
140d			;     This implementation of free uses the stack exclusively, and is          : 
140d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
140d			;     advisable to disable interrupts before calling free, and recommended    : 
140d			;     to avoid the use of free inside ISRs in general.                        : 
140d			;                                                                             : 
140d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     HL  Pointer to address of first byte of allocation to be freed          : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     Nothing                                                                 : 
140d			;                                                                             : 
140d			; Stack frame                                                                 : 
140d			;       |             |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     BC      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     DE      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     IX      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |  prev_free  |                                                       : 
140d			;   +2  +-------------+                                                       : 
140d			;       |  next_free  |                                                       : 
140d			;   +0  +-------------+                                                       : 
140d			;       |             |                                                       : 
140d			;                                                                             : 
140d			;------------------------------------------------------------------------------ 
140d			free: 
140d			      push  BC 
140d			      push  DE 
140d			      push  IX 
140d			 
140d			      ld    A, H                    ; Exit if ptr is null 
140d			      or    L 
140d			      jp    Z, free_early_exit 
140d			 
140d			      ; Set up stack frame 
140d			      ex    DE, HL 
140d			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			      ld    IX, 0                   ; Use IX as a frame pointer 
140d			      add   IX, SP 
140d			 
140d			      ; The address in HL points to the start of the useable allocated space, 
140d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
140d			      ; address of the block itself. 
140d			      ex    DE, HL 
140d			      ld    DE, -4 
140d			      add   HL, DE 
140d			 
140d			      ; An allocated block must have a null next block pointer in it 
140d			      ld    A, (HL) 
140d			      inc   HL 
140d			      or    (HL) 
140d			      jp    NZ, free_done 
140d			 
140d			      dec   HL 
140d			 
140d			      ld    B, H                    ; Copy HL to BC 
140d			      ld    C, L 
140d			 
140d			      ; Loop through the free list to find the first block with an address 
140d			      ; higher than the block being freed 
140d			      ld    HL, free_list 
140d			 
140d			free_find_higher_block: 
140d			      ld    E, (HL)                 ; Load next ptr from free block 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      dec   HL 
140d			 
140d			      ld    (IX+0), E               ; Save ptr to next free block 
140d			      ld    (IX+1), D 
140d			      ld    (IX+2), L               ; Save ptr to prev free block 
140d			      ld    (IX+3), H 
140d			 
140d			      ld    A, B                    ; Check if DE is greater than BC 
140d			      cp    D                       ; Compare MSB first 
140d			      jr    Z, $+4                  ; MSB the same, compare LSB 
140d			      jr    NC, free_find_higher_block_skip 
140d			      ld    A, C 
140d			      cp    E                       ; Then compare LSB 
140d			      jr    C, free_found_higher_block 
140d			 
140d			free_find_higher_block_skip: 
140d			      ld    A, D                    ; Reached the end of the free list? 
140d			      or    E 
140d			      jp    Z, free_done 
140d			 
140d			      ex    DE, HL 
140d			 
140d			      jr    free_find_higher_block 
140d			 
140d			free_found_higher_block: 
140d			      ; Insert freed block between prev and next free blocks 
140d			      ld    (HL), C                 ; Point prev free block to freed block 
140d			      inc   HL 
140d			      ld    (HL), B 
140d			 
140d			      ld    H, B                    ; Point freed block at next free block 
140d			      ld    L, C 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Check if the freed block is adjacent to the next free block 
140d			      inc   HL                      ; Load size of freed block into HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ex    DE, HL 
140d			 
140d			      add   HL, BC                  ; Add addr of freed block and its size 
140d			 
140d			      ld    E, (IX+0)               ; Load addr of next free block into DE 
140d			      ld    D, (IX+1) 
140d			 
140d			      or    A                       ; Clear the carry flag 
140d			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
140d			      jr    NZ, free_check_adjacent_to_prev 
140d			 
140d			      ; Freed block is adjacent to next, merge into one bigger block 
140d			      ex    DE, HL                  ; Load next ptr from next block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  HL                      ; Save ptr to next block for later 
140d			 
140d			      ld    H, B                    ; Store ptr from next block into freed block 
140d			      ld    L, C 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   HL                      ; Restore ptr to next block 
140d			      inc   HL                      ; Load size of next block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  DE                      ; Save next block size for later 
140d			 
140d			      ld    H, B                    ; Load size of freed block into HL 
140d			      ld    L, C 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ex    DE, HL 
140d			 
140d			      pop   DE                      ; Restore size of next block 
140d			      add   HL, DE                  ; Add sizes of both blocks 
140d			      ex    DE, HL 
140d			 
140d			      ld    H, B                    ; Store new bigger size into freed block 
140d			      ld    L, C 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			free_check_adjacent_to_prev: 
140d			      ; Check if the freed block is adjacent to the prev free block 
140d			      ld    L, (IX+2)               ; Prev free block ptr into HL 
140d			      ld    H, (IX+3) 
140d			 
140d			      inc   HL                      ; Size of prev free block into DE 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      add   HL, DE                  ; Add prev block addr and size 
140d			 
140d			      or    A                       ; Clear the carry flag 
140d			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d			      jr    NZ, free_done 
140d			 
140d			      ; Freed block is adjacent to prev, merge into one bigger block 
140d			      ld    H, B                    ; Load next ptr from freed block into DE 
140d			      ld    L, C 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  HL                      ; Save freed block ptr for later 
140d			 
140d			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
140d			      ld    H, (IX+3) 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   HL                      ; Restore freed block ptr 
140d			      inc   HL                      ; Load size of freed block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  DE                      ; Save freed block size for later 
140d			 
140d			      ld    L, (IX+2)               ; Load size of prev block into DE 
140d			      ld    H, (IX+3) 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      pop   HL                      ; Add sizes of both blocks 
140d			      add   HL, DE 
140d			      ex    DE, HL 
140d			 
140d			      ld    L, (IX+2)               ; Store new bigger size into prev block 
140d			      ld    H, (IX+3) 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			free_done: 
140d			      ld    HL, 4                   ; Clean up stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			 
140d			free_early_exit: 
140d			      pop   IX 
140d			      pop   DE 
140d			      pop   BC 
140d			 
140d			      ret 
140d			 
140d			 
140d			;      .org 0x8000 
140d			; 
140d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
140d			 ;                 .dw   0 
140d			 
140d			endif 
140d			 
140d			 
140d			if MALLOC_4 
140d			 
140d			; My memory allocation code. Very very simple.... 
140d			; allocate space under 250 chars 
140d			 
140d			heap_init: 
140d				; init start of heap as zero 
140d				;  
140d			 
140d				ld hl, heap_start 
140d				ld a, 0 
140d				ld (hl), a      ; empty block 
140d				inc hl 
140d				ld a, 0 
140d				ld (hl), a      ; length of block 
140d				; write end of list 
140d				inc hl 
140d				ld a,(hl) 
140d				inc hl 
140d				ld a,(hl) 
140d				 
140d			 
140d				; init some malloc vars 
140d			 
140d				ld hl, 0 
140d				ld (free_list), hl       ; store last malloc location 
140d			 
140d				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
140d				ld a, 0 
140d				ld (hl), a 
140d			 
140d			 
140d				ld hl, heap_start 
140d				;  
140d				  
140d				ret 
140d			 
140d			 
140d			;    free block marker 
140d			;    requested size  
140d			;    pointer to next block 
140d			;    .... 
140d			;    next block marker 
140d			 
140d			 
140d			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
140d			; 
140d			 
140d			 
140d			malloc:  
140d				push de 
140d				push bc 
140d				push af 
140d			 
140d				; hl space required 
140d				 
140d				ld c, l    ; hold space   (TODO only a max of 255) 
140d			 
140d			;	inc c     ; TODO BUG need to fix memory leak on push str 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			 
140d			 
140d			 
140d				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
140d			 
140d				ld a, (free_list+3) 
140d				cp 0 
140d				jr z, .contheap 
140d			 
140d				ld hl, (free_list)     ; get last alloc 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mrs" 
140d						CALLMONITOR 
140d					endif 
140d				jr .startalloc 
140d			 
140d			.contheap: 
140d				ld hl, heap_start 
140d			 
140d			.startalloc: 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mym" 
140d						CALLMONITOR 
140d					endif 
140d			.findblock: 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mmf" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d				ld a,(hl)  
140d				; if byte is zero then clear to use 
140d			 
140d				cp 0 
140d				jr z, .foundemptyblock 
140d			 
140d				; if byte is not clear 
140d				;     then byte is offset to next block 
140d			 
140d				inc hl 
140d				ld a, (hl) ; get size 
140d			.nextblock:	inc hl 
140d					ld e, (hl) 
140d					inc hl 
140d					ld d, (hl) 
140d					ex de, hl 
140d			;	inc hl  ; move past the store space 
140d			;	inc hl  ; move past zero index  
140d			 
140d				; TODO detect no more space 
140d			 
140d				push hl 
140d				ld de, heap_end 
140d				call cmp16 
140d				pop hl 
140d				jr nc, .nospace 
140d			 
140d				jr .findblock 
140d			 
140d			.nospace: ld hl, 0 
140d				jp .exit 
140d			 
140d			 
140d			.foundemptyblock:	 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mme" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			; TODO has block enough space if reusing??? 
140d			 
140d				;  
140d			 
140d			; see if this block has been previously used 
140d				inc hl 
140d				ld a, (hl) 
140d				dec hl 
140d				cp 0 
140d				jr z, .newblock 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "meR" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			; no reusing previously allocated block 
140d			 
140d			; is it smaller than previously used? 
140d				 
140d				inc hl    ; move to size 
140d				ld a, c 
140d				sub (hl)        ; we want c < (hl) 
140d				dec hl    ; move back to marker 
140d			        jr z, .findblock 
140d			 
140d				; update with the new size which should be lower 
140d			 
140d			        ;inc  hl   ; negate next move. move back to size  
140d			 
140d			.newblock: 
140d				; need to be at marker here 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "meN" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			 
140d				ld a, c 
140d			 
140d				ld (free_list+3), a	 ; flag resume from last malloc  
140d				ld (free_list), hl    ; save out last location 
140d			 
140d			 
140d				;inc a     ; space for length byte 
140d				ld (hl), a     ; save block in use marker 
140d			 
140d				inc hl   ; move to space marker 
140d				ld (hl), a    ; save new space 
140d			 
140d				inc hl   ; move to start of allocated area 
140d				 
140d			;	push hl     ; save where we are - 1  
140d			 
140d			;	inc hl  ; move past zero index  
140d				; skip space to set down new marker 
140d			 
140d				; provide some extra space for now 
140d			 
140d				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
140d				inc a 
140d				inc a 
140d			 
140d				push hl   ; save where we are in the node block 
140d			 
140d				call addatohl 
140d			 
140d				; write linked list point 
140d			 
140d				pop de     ; get our node position 
140d				ex de, hl 
140d			 
140d				ld (hl), e 
140d				inc hl 
140d				ld (hl), d 
140d			 
140d				inc hl 
140d			 
140d				; now at start of allocated data so save pointer 
140d			 
140d				push hl 
140d			 
140d				; jump to position of next node and setup empty header in DE 
140d			 
140d				ex de, hl 
140d			 
140d			;	inc hl ; move past end of block 
140d			 
140d				ld a, 0 
140d				ld (hl), a   ; empty marker 
140d				inc hl 
140d				ld (hl), a   ; size 
140d				inc hl  
140d				ld (hl), a   ; ptr 
140d				inc hl 
140d				ld (hl), a   ; ptr 
140d			 
140d			 
140d				pop hl 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mmr" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			.exit: 
140d				pop af 
140d				pop bc 
140d				pop de  
140d				ret 
140d			 
140d			 
140d			 
140d			 
140d			free:  
140d				push hl 
140d				push af 
140d				; get address in hl 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "fre" 
140d						CALLMONITOR 
140d					endif 
140d				; data is at hl - move to block count 
140d				dec hl 
140d				dec hl    ; get past pointer 
140d				dec hl 
140d			 
140d				ld a, (hl)    ; need this for a validation check 
140d			 
140d				dec hl    ; move to block marker 
140d			 
140d				; now check that the block count and block marker are the same  
140d			        ; this checks that we are on a malloc node and not random memory 
140d			        ; OK a faint chance this could be a problem but rare - famous last words! 
140d			 
140d				ld c, a 
140d				ld a, (hl)    
140d			 
140d				cp c 
140d				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
140d			 
140d				; yes good chance we are on a malloc node 
140d			 
140d				ld a, 0      
140d				ld (hl), a   ; mark as free 
140d			 
140d				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
140d			 
140d			.freeignore:  
140d			 
140d				pop af 
140d				pop hl 
140d			 
140d				ret 
140d			 
140d			 
140d			 
140d			endif 
140d			 
140d			; eof 
# End of file firmware_memory.asm
140d			  
140d			; device C  
140d			if SOUND_ENABLE  
140d				include "firmware_sound.asm"  
140d			endif  
140d			  
140d			include "firmware_diags.asm"  
140d			; Hardware diags menu 
140d			 
140d			 
140d			config: 
140d			 
140d 3e 00			ld a, 0 
140f 21 3d 14			ld hl, .configmn 
1412 cd b1 0b			call menu 
1415			 
1415 fe 00			cp 0 
1417 c8				ret z 
1418			 
1418 fe 01			cp 1 
141a cc 6b 14			call z, .savetostore 
141d			 
141d fe 02			cp 2 
141f cc 57 14			call z, .selautoload 
1422 fe 03			cp 3 
1424 cc 4d 14			call z, .disautoload 
1427 fe 04			cp 4 
1429 cc 61 14			call z, .selbank 
142c fe 05			cp 5 
142e cc 75 14			call z, .debug_tog 
1431 fe 06			cp 6 
1433 cc b8 15			call z, .bpsgo 
1436 fe 07			cp 7 
1438 cc 9b 14			call z, hardware_diags 
143b			 
143b 18 d0			jr config 
143d			 
143d			.configmn: 
143d a9 17			dw prom_c3 
143f c0 17			dw prom_c2 
1441 d5 17			dw prom_c2a 
1443 eb 17			dw prom_c2b 
1445			;	dw prom_c4 
1445 08 18			dw prom_m4 
1447 23 18			dw prom_m4b 
1449 2b 18			dw prom_c1 
144b 00 00			dw 0 
144d				 
144d			 
144d			 
144d			 
144d			.disautoload: 
144d				if STORAGE_SE 
144d				ld a, $fe      ; bit 0 clear 
144d				ld (spi_device), a 
144d			 
144d				call storage_get_block_0 
144d			 
144d				ld a, 0 
144d				ld (store_page+STORE_0_AUTOFILE), a 
144d			 
144d					ld hl, 0 
144d					ld de, store_page 
144d				call storage_write_block	 ; save update 
144d				else 
144d			 
144d 21 3a 18			ld hl, prom_notav 
1450 11 50 18			ld de, prom_empty 
1453 cd 11 0b			call info_panel 
1456				endif 
1456			 
1456			 
1456 c9				ret 
1457			 
1457			 
1457			 
1457			; Select auto start 
1457			 
1457			.selautoload: 
1457			 
1457				 
1457				if STORAGE_SE 
1457			 
1457					call config_dir 
1457				        ld hl, scratch 
1457					ld a, 0 
1457					call menu 
1457			 
1457					cp 0 
1457					ret z 
1457			 
1457					dec a 
1457			 
1457			 
1457					; locate menu option 
1457			 
1457					ld hl, scratch 
1457					call table_lookup 
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALl" 
1457						CALLMONITOR 
1457					endif 
1457					; with the pointer to the menu it, the byte following the zero term is the file id 
1457			 
1457					ld a, 0 
1457					ld bc, 50   ; max of bytes to look at 
1457					cpir  
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALb" 
1457						CALLMONITOR 
1457					endif 
1457					;inc hl 
1457			 
1457					ld a, (hl)   ; file id 
1457					 
1457				        ; save bank and file ids 
1457			 
1457					push af 
1457			 
1457			; TODO need to save to block 0 on bank 1	 
1457			 
1457					call storage_get_block_0 
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "AL0" 
1457						CALLMONITOR 
1457					endif 
1457					pop af 
1457			 
1457					ld (store_page+STORE_0_FILERUN),a 
1457					 
1457					; save bank id 
1457			 
1457					ld a,(spi_device) 
1457					ld (store_page+STORE_0_BANKRUN),a 
1457			 
1457					; enable auto run of store file 
1457			 
1457					ld a, 1 
1457					ld (store_page+STORE_0_AUTOFILE),a 
1457			 
1457					; save buffer 
1457			 
1457					ld hl, 0 
1457					ld de, store_page 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALw" 
1457						CALLMONITOR 
1457					endif 
1457				call storage_write_block	 ; save update 
1457			  
1457			 
1457			 
1457			 
1457					ld hl, scratch 
1457					call config_fdir 
1457			 
1457				else 
1457			 
1457 21 3a 18			ld hl, prom_notav 
145a 11 50 18			ld de, prom_empty 
145d cd 11 0b			call info_panel 
1460			 
1460				endif 
1460 c9				ret 
1461			 
1461			 
1461			 
1461			; Select storage bank 
1461			 
1461			.selbank: 
1461			 
1461				if STORAGE_SE 
1461				else 
1461			 
1461 21 3a 18			ld hl, prom_notav 
1464 11 50 18			ld de, prom_empty 
1467 cd 11 0b			call info_panel 
146a				endif 
146a				 
146a c9				ret 
146b			 
146b			if STORAGE_SE 
146b			 
146b			.config_ldir:   
146b				; Load storage bank labels into menu array 
146b			 
146b				 
146b			 
146b			 
146b				ret 
146b			 
146b			 
146b			endif 
146b			 
146b			 
146b			; Save user words to storage 
146b			 
146b			.savetostore: 
146b			 
146b				if STORAGE_SE 
146b			 
146b					call config_dir 
146b				        ld hl, scratch 
146b					ld a, 0 
146b					call menu 
146b					 
146b					ld hl, scratch 
146b					call config_fdir 
146b			 
146b				else 
146b			 
146b 21 3a 18			ld hl, prom_notav 
146e 11 50 18			ld de, prom_empty 
1471 cd 11 0b			call info_panel 
1474			 
1474				endif 
1474			 
1474 c9				ret 
1475			 
1475			 
1475			 
1475			if STORAGE_SE 
1475			 
1475			config_fdir: 
1475				; using the scratch dir go through and release the memory allocated for each string 
1475				 
1475				ld hl, scratch 
1475			.cfdir:	ld e,(hl) 
1475				inc hl 
1475				ld d,(hl) 
1475				inc hl 
1475			 
1475				ex de, hl 
1475				call ishlzero 
1475				ret z     ; return on null pointer 
1475				call free 
1475				ex de, hl 
1475				jr .cfdir 
1475			 
1475			 
1475				ret 
1475			 
1475			 
1475			config_dir: 
1475			 
1475				; for the config menus that need to build a directory of storage call this routine 
1475				; it will construct a menu in scratch to pass to menu 
1475			 
1475				; open storage device 
1475			 
1475				; execute DIR to build a list of files and their ids into scratch in menu format 
1475				; once the menu has finished then will need to call config_fdir to release the strings 
1475				 
1475				; c = number items 
1475			 
1475				 
1475				call storage_get_block_0 
1475			 
1475				ld hl, store_page     ; get current id count 
1475				ld b, (hl) 
1475				ld c, 0    ; count of files   
1475			 
1475			 
1475				ld hl, scratch 
1475				ld (store_tmp2), hl    ; location to poke strings 
1475			 
1475				; check for empty drive 
1475			 
1475				ld a, 0 
1475				cp b 
1475				jp z, .dirdone 
1475			 
1475				 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "Cdc" 
1475						CALLMONITOR 
1475					endif 
1475			 
1475			 
1475			.diritem:	 
1475				push bc 
1475				; for each of the current ids do a search for them and if found push to stack 
1475			 
1475					ld hl, STORE_BLOCK_PHY 
1475					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1475					ld e,b 
1475			 
1475					call storage_findnextid 
1475			 
1475			 
1475					; if found hl will be non zero 
1475			 
1475					call ishlzero 
1475					jr z, .dirnotfound 
1475			 
1475					; increase count 
1475			 
1475					pop bc	 
1475					inc c 
1475					push bc 
1475					 
1475			 
1475					; get file header and push the file name 
1475			 
1475					ld de, store_page 
1475					call storage_read_block 
1475			 
1475					; push file id to stack 
1475				 
1475					ld a, (store_page) 
1475					ld h, 0 
1475					ld l, a 
1475			 
1475					;call forth_push_numhl 
1475					; TODO store id 
1475			 
1475					push hl 
1475			 
1475					; push extent count to stack  
1475				 
1475					ld hl, store_page+3 
1475			 
1475					; get file name length 
1475			 
1475					call strlenz   
1475			 
1475					inc hl   ; cover zero term 
1475					inc hl  ; stick the id at the end of the area 
1475			 
1475					push hl 
1475					pop bc    ; move length to bc 
1475			 
1475					call malloc 
1475			 
1475					; TODO save malloc area to scratch 
1475			 
1475					ex de, hl 
1475					ld hl, (store_tmp2) 
1475					ld (hl), e 
1475					inc hl 
1475					ld (hl), d 
1475					inc hl 
1475					ld (store_tmp2), hl 
1475			 
1475					 
1475			 
1475					;pop hl   ; get source 
1475			;		ex de, hl    ; swap aronund	 
1475			 
1475					ld hl, store_page+3 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "CFd" 
1475						CALLMONITOR 
1475					endif 
1475					ldir 
1475			 
1475					; de is past string, move back one and store id 
1475					 
1475					dec de 
1475			 
1475					; store file id 
1475			 
1475					pop hl 
1475					ex de,hl 
1475					ld (hl), e 
1475			 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "Cdi" 
1475						CALLMONITOR 
1475					endif 
1475					 
1475			.dirnotfound: 
1475					pop bc     
1475					djnz .diritem 
1475				 
1475			.dirdone:	 
1475			 
1475					ld a, 0 
1475					ld hl, (store_tmp2) 
1475					ld (hl), a 
1475					inc hl 
1475					ld (hl), a 
1475					inc hl 
1475					; push a count of the dir items found 
1475			 
1475			;		ld h, 0 
1475			;		ld l, c 
1475			 
1475				ret 
1475			 
1475			endif 
1475			 
1475			 
1475			; Settings 
1475			; Run  
1475			 
1475			 
1475			 
1475			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1475			;;hd_menu2:   db "        2: Editor",0   
1475			;hd_menu2:   db "        2: Editor       6: Menu",0   
1475			;hd_menu3:   db "        3: Storage",0 
1475			;hd_menu4:   db "0=quit  4: Debug",0 
1475			;hd_don:     db "ON",0 
1475			;hd_doff:     db "OFF",0 
1475			; 
1475			; 
1475			; 
1475			;hardware_diags_old:       
1475			; 
1475			;.diagmenu: 
1475			;	call clear_display 
1475			;	ld a, display_row_1 
1475			;	ld de, hd_menu1 
1475			;	call str_at_display 
1475			; 
1475			;	ld a, display_row_2 
1475			;	ld de, hd_menu2 
1475			;	call str_at_display 
1475			; 
1475			;	ld a, display_row_3 
1475			;	ld de, hd_menu3 
1475			;	call str_at_display 
1475			; 
1475			;	ld a,  display_row_4 
1475			;	ld de, hd_menu4 
1475			;	call str_at_display 
1475			; 
1475			;	; display debug state 
1475			; 
1475			;	ld de, hd_don 
1475			;	ld a, (os_view_disable) 
1475			;	cp 0 
1475			;	jr z, .distog 
1475			;	ld de, hd_doff 
1475			;.distog: ld a, display_row_4+17 
1475			;	call str_at_display 
1475			; 
1475			;	call update_display 
1475			; 
1475			;	call cin_wait 
1475			; 
1475			; 
1475			; 
1475			;	cp '4' 
1475			;	jr nz, .diagn1 
1475			; 
1475			;	; debug toggle 
1475			; 
1475			;	ld a, (os_view_disable) 
1475			;	ld b, '*' 
1475			;	cp 0 
1475			;	jr z, .debtog 
1475			;	ld b, 0 
1475			;.debtog:	 
1475			;	ld a,b 
1475			;	ld (os_view_disable),a 
1475			; 
1475			;.diagn1: cp '0' 
1475			;	 ret z 
1475			; 
1475			;;	cp '1' 
1475			;;       jp z, matrix	 
1475			;;   TODO keyboard matrix test 
1475			; 
1475			;	cp '2' 
1475			;	jp z, .diagedit 
1475			; 
1475			;;	cp '6' 
1475			;;	jp z, .menutest 
1475			;;if ENABLE_BASIC 
1475			;;	cp '6' 
1475			;;	jp z, basic 
1475			;;endif 
1475			 ; 
1475			;	jp .diagmenu 
1475			; 
1475			; 
1475			;	ret 
1475			 
1475			 
1475			.debug_tog: 
1475 21 bc 14			ld hl, .menudebug 
1478				 
1478 3a bc e2			ld a, (os_view_disable) 
147b fe 2a			cp '*' 
147d 20 04			jr nz,.tdon  
147f 3e 01			ld a, 1 
1481 18 02			jr .tog1 
1483 3e 00		.tdon: ld a, 0 
1485			 
1485			.tog1: 
1485 cd b1 0b			call menu 
1488 fe 00			cp 0 
148a c8				ret z 
148b fe 01			cp 1    ; disable debug 
148d 28 04			jr z, .dtog0 
148f 3e 2a			ld a, '*' 
1491 18 02			jr .dtogset 
1493 3e 00		.dtog0: ld a, 0 
1495 32 bc e2		.dtogset:  ld (os_view_disable), a 
1498 c3 75 14			jp .debug_tog 
149b			 
149b			 
149b			hardware_diags:       
149b			 
149b			.diagm: 
149b 21 ae 14			ld hl, .menuitems 
149e 3e 00			ld a, 0 
14a0 cd b1 0b			call menu 
14a3			 
14a3 fe 00		         cp 0 
14a5 c8				 ret z 
14a6			 
14a6 fe 02			cp 2 
14a8 ca 07 15			jp z, .diagedit 
14ab			 
14ab			;	cp '6' 
14ab			;	jp z, .menutest 
14ab			;if ENABLE_BASIC 
14ab			;	cp '6' 
14ab			;	jp z, basic 
14ab			;endif 
14ab			  
14ab c3 9b 14			jp .diagm 
14ae			 
14ae				 
14ae c2 14		.menuitems:   	dw .m1 
14b0 cd 14				dw .m2 
14b2 d4 14				dw .m3 
14b4 dc 14				dw .m5 
14b6 e2 14				dw .m5a 
14b8 eb 14				dw .m5b 
14ba 00 00				dw 0 
14bc			 
14bc			.menudebug: 
14bc f4 14				dw .m6 
14be fd 14				dw .m7 
14c0 00 00				dw 0 
14c2			 
14c2 .. 00		.m1:   db "Key Matrix",0 
14cd .. 00		.m2:   db "Editor",0 
14d4 .. 00		.m3:   db "Storage",0 
14dc .. 00		.m5:   db "Sound",0 
14e2 .. 00		.m5a:  db "RAM Test",0 
14eb .. 00		.m5b:  db "LCD Test",0 
14f4			 
14f4 .. 00		.m6:   db "Debug ON",0 
14fd .. 00		.m7:   db "Debug OFF",0 
1507			 
1507			; debug editor 
1507			 
1507			.diagedit: 
1507			 
1507 21 cb e2			ld hl, scratch 
150a			;	ld bc, 250 
150a			;	ldir 
150a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
150a 3e 00			ld a, 0 
150c 77				ld (hl), a 
150d 23				inc hl 
150e 77				ld (hl), a 
150f 23				inc hl 
1510 77				ld (hl), a 
1511			 
1511 cd 80 0b		        call clear_display 
1514 cd a3 0b			call update_display 
1517				;ld a, 1 
1517				;ld (hardware_diag), a 
1517			.diloop: 
1517 3e 00			ld a, display_row_1 
1519 0e 00			ld c, 0 
151b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
151d 1e 28			ld e, 40 
151f			 
151f 21 cb e2			ld hl, scratch	 
1522 cd da 0d			call input_str 
1525			 
1525 3e 28			ld a, display_row_2 
1527 11 cb e2			ld de, scratch 
152a cd 93 0b			call str_at_display 
152d cd a3 0b			call update_display 
1530			 
1530 c3 17 15			jp .diloop 
1533			 
1533			 
1533			; pass word in hl 
1533			; a has display location 
1533			display_word_at: 
1533 f5				push af 
1534 e5				push hl 
1535 7c				ld a,h 
1536 21 d0 e5			ld hl, os_word_scratch 
1539 cd ae 10			call hexout 
153c e1				pop hl 
153d 7d				ld a,l 
153e 21 d2 e5			ld hl, os_word_scratch+2 
1541 cd ae 10			call hexout 
1544 21 d4 e5			ld hl, os_word_scratch+4 
1547 3e 00			ld a,0 
1549 77				ld (hl),a 
154a 11 d0 e5			ld de,os_word_scratch 
154d f1				pop af 
154e cd 93 0b				call str_at_display 
1551 c9				ret 
1552			 
1552			display_ptr_state: 
1552			 
1552				; to restore afterwards 
1552			 
1552 d5				push de 
1553 c5				push bc 
1554 e5				push hl 
1555 f5				push af 
1556			 
1556				; for use in here 
1556			 
1556			;	push bc 
1556			;	push de 
1556			;	push hl 
1556			;	push af 
1556			 
1556 cd 80 0b			call clear_display 
1559			 
1559 11 2c 17			ld de, .ptrstate 
155c 3e 00			ld a, display_row_1 
155e cd 93 0b			call str_at_display 
1561			 
1561				; display debug step 
1561			 
1561			 
1561 11 71 ee			ld de, debug_mark 
1564 3e 26			ld a, display_row_1+display_cols-2 
1566 cd 93 0b			call str_at_display 
1569			 
1569				; display a 
1569 11 36 17			ld de, .ptrcliptr 
156c 3e 28			ld a, display_row_2 
156e cd 93 0b			call str_at_display 
1571			 
1571 f1				pop af 
1572 2a 4a ea			ld hl,(cli_ptr) 
1575 3e 30			ld a, display_row_2+8 
1577 cd 33 15			call display_word_at 
157a			 
157a			 
157a				; display hl 
157a			 
157a			 
157a 11 3e 17			ld de, .ptrclioptr 
157d 3e 32			ld a, display_row_2+10 
157f cd 93 0b			call str_at_display 
1582			; 
1582			;	pop hl 
1582 3e 35			ld a, display_row_2+13 
1584 2a 48 ea			ld hl,(cli_origptr) 
1587 cd 33 15			call display_word_at 
158a			; 
158a			;	 
158a			;	; display de 
158a			 
158a			;	ld de, .regstatede 
158a			;	ld a, display_row_3 
158a			;	call str_at_display 
158a			 
158a			;	pop de 
158a			;	ld h,d 
158a			;	ld l, e 
158a			;	ld a, display_row_3+3 
158a			;	call display_word_at 
158a			 
158a			 
158a				; display bc 
158a			 
158a			;	ld de, .regstatebc 
158a			;	ld a, display_row_3+10 
158a			;	call str_at_display 
158a			 
158a			;	pop bc 
158a			;	ld h,b 
158a			;	ld l, c 
158a			;	ld a, display_row_3+13 
158a			;	call display_word_at 
158a			 
158a			 
158a				; display dsp 
158a			 
158a			;	ld de, .regstatedsp 
158a			;	ld a, display_row_4 
158a			;	call str_at_display 
158a			 
158a				 
158a			;	ld hl,(cli_data_sp) 
158a			;	ld a, display_row_4+4 
158a			;	call display_word_at 
158a			 
158a				; display rsp 
158a			 
158a 11 6d 17			ld de, .regstatersp 
158d 3e 82			ld a, display_row_4+10 
158f cd 93 0b			call str_at_display 
1592			 
1592				 
1592 2a fc e9			ld hl,(cli_ret_sp) 
1595 3e 86			ld a, display_row_4+14 
1597 cd 33 15			call display_word_at 
159a			 
159a cd a3 0b			call update_display 
159d			 
159d cd f2 0a			call delay1s 
15a0 cd f2 0a			call delay1s 
15a3 cd f2 0a			call delay1s 
15a6			 
15a6			 
15a6 cd 97 1b			call next_page_prompt 
15a9			 
15a9				; restore  
15a9			 
15a9 f1				pop af 
15aa e1				pop hl 
15ab c1				pop bc 
15ac d1				pop de 
15ad c9				ret 
15ae			 
15ae			break_point_state: 
15ae f5				push af 
15af			 
15af				; see if disabled 
15af			 
15af 3a bc e2			ld a, (os_view_disable) 
15b2 fe 2a			cp '*' 
15b4 20 02			jr nz, .bpsgo 
15b6 f1				pop af 
15b7 c9				ret 
15b8			 
15b8			.bpsgo: 
15b8 f1				pop af 
15b9 f5				push af 
15ba 22 b8 e2			ld (os_view_hl), hl 
15bd ed 53 b6 e2		ld (os_view_de), de 
15c1 ed 43 b4 e2		ld (os_view_bc), bc 
15c5 e5				push hl 
15c6 6f				ld l, a 
15c7 26 00			ld h, 0 
15c9 22 ba e2			ld (os_view_af),hl 
15cc			 
15cc 21 b7 ed				ld hl, display_fb0 
15cf 22 d2 eb				ld (display_fb_active), hl 
15d2 e1				pop hl	 
15d3			 
15d3 3e 31			ld a, '1' 
15d5 fe 2a		.bps1:  cp '*' 
15d7 20 03			jr nz, .bps1b 
15d9 32 bc e2			ld (os_view_disable),a 
15dc fe 31		.bps1b:  cp '1' 
15de 20 14			jr nz, .bps2 
15e0			 
15e0				; display reg 
15e0			 
15e0				 
15e0			 
15e0 3a ba e2			ld a, (os_view_af) 
15e3 2a b8 e2			ld hl, (os_view_hl) 
15e6 ed 5b b6 e2		ld de, (os_view_de) 
15ea ed 4b b4 e2		ld bc, (os_view_bc) 
15ee cd 88 16			call display_reg_state 
15f1 c3 74 16			jp .bpschk 
15f4			 
15f4 fe 32		.bps2:  cp '2' 
15f6 20 08			jr nz, .bps3 
15f8				 
15f8				; display hl 
15f8 2a b8 e2			ld hl, (os_view_hl) 
15fb cd 72 17			call display_dump_at_hl 
15fe			 
15fe 18 74			jr .bpschk 
1600			 
1600 fe 33		.bps3:  cp '3' 
1602 20 08			jr nz, .bps4 
1604			 
1604			        ; display de 
1604 2a b6 e2			ld hl, (os_view_de) 
1607 cd 72 17			call display_dump_at_hl 
160a			 
160a 18 68			jr .bpschk 
160c fe 34		.bps4:  cp '4' 
160e 20 08			jr nz, .bps5 
1610			 
1610			        ; display bc 
1610 2a b4 e2			ld hl, (os_view_bc) 
1613 cd 72 17			call display_dump_at_hl 
1616			 
1616 18 5c			jr .bpschk 
1618 fe 35		.bps5:  cp '5' 
161a 20 08		        jr nz, .bps7 
161c			 
161c				; display cur ptr 
161c 2a 4a ea			ld hl, (cli_ptr) 
161f cd 72 17			call display_dump_at_hl 
1622			 
1622 18 50			jr .bpschk 
1624 fe 36		.bps7:  cp '6' 
1626 20 08			jr nz, .bps8b 
1628				 
1628				; display cur orig ptr 
1628 2a 48 ea			ld hl, (cli_origptr) 
162b cd 72 17			call display_dump_at_hl 
162e 18 44			jr .bpschk 
1630 fe 37		.bps8b:  cp '7' 
1632 20 08			jr nz, .bps9 
1634				 
1634				; display dsp 
1634 2a f8 e9			ld hl, (cli_data_sp) 
1637 cd 72 17			call display_dump_at_hl 
163a			 
163a 18 38			jr .bpschk 
163c fe 39		.bps9:  cp '9' 
163e 20 05			jr nz, .bps8c 
1640				 
1640				; display SP 
1640			;	ld hl, sp 
1640 cd 72 17			call display_dump_at_hl 
1643			 
1643 18 2f			jr .bpschk 
1645 fe 38		.bps8c:  cp '8' 
1647 20 08			jr nz, .bps8d 
1649				 
1649				; display rsp 
1649 2a fc e9			ld hl, (cli_ret_sp) 
164c cd 72 17			call display_dump_at_hl 
164f			 
164f 18 23			jr .bpschk 
1651 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1653 20 05			jr nz, .bps8 
1655 cd 8d 19			call monitor 
1658			 
1658 18 1a			jr .bpschk 
165a fe 30		.bps8:  cp '0' 
165c 20 16			jr nz, .bpschk 
165e			 
165e 21 16 ed				ld hl, display_fb1 
1661 22 d2 eb				ld (display_fb_active), hl 
1664 cd a3 0b				call update_display 
1667			 
1667				;ld a, (os_view_af) 
1667 2a b8 e2			ld hl, (os_view_hl) 
166a ed 5b b6 e2		ld de, (os_view_de) 
166e ed 4b b4 e2		ld bc, (os_view_bc) 
1672 f1				pop af 
1673 c9				ret 
1674			 
1674			.bpschk:   
1674 cd f2 0a			call delay1s 
1677 3e 9f		ld a,display_row_4 + display_cols - 1 
1679 11 95 1b		        ld de, endprg 
167c cd 93 0b			call str_at_display 
167f cd a3 0b			call update_display 
1682 cd 11 64			call cin_wait 
1685			 
1685 c3 d5 15			jp .bps1 
1688			 
1688			 
1688			display_reg_state: 
1688			 
1688				; to restore afterwards 
1688			 
1688 d5				push de 
1689 c5				push bc 
168a e5				push hl 
168b f5				push af 
168c			 
168c				; for use in here 
168c			 
168c c5				push bc 
168d d5				push de 
168e e5				push hl 
168f f5				push af 
1690			 
1690 cd 80 0b			call clear_display 
1693			 
1693 11 48 17			ld de, .regstate 
1696 3e 00			ld a, display_row_1 
1698 cd 93 0b			call str_at_display 
169b			 
169b				; display debug step 
169b			 
169b			 
169b 11 71 ee			ld de, debug_mark 
169e 3e 25			ld a, display_row_1+display_cols-3 
16a0 cd 93 0b			call str_at_display 
16a3			 
16a3				; display a 
16a3 11 64 17			ld de, .regstatea 
16a6 3e 28			ld a, display_row_2 
16a8 cd 93 0b			call str_at_display 
16ab			 
16ab e1				pop hl 
16ac			;	ld h,0 
16ac			;	ld l, a 
16ac 3e 2b			ld a, display_row_2+3 
16ae cd 33 15			call display_word_at 
16b1			 
16b1			 
16b1				; display hl 
16b1			 
16b1			 
16b1 11 58 17			ld de, .regstatehl 
16b4 3e 32			ld a, display_row_2+10 
16b6 cd 93 0b			call str_at_display 
16b9			 
16b9 e1				pop hl 
16ba 3e 35			ld a, display_row_2+13 
16bc cd 33 15			call display_word_at 
16bf			 
16bf				 
16bf				; display de 
16bf			 
16bf 11 5c 17			ld de, .regstatede 
16c2 3e 50			ld a, display_row_3 
16c4 cd 93 0b			call str_at_display 
16c7			 
16c7 e1				pop hl 
16c8			;	ld h,d 
16c8			;	ld l, e 
16c8 3e 53			ld a, display_row_3+3 
16ca cd 33 15			call display_word_at 
16cd			 
16cd			 
16cd				; display bc 
16cd			 
16cd 11 60 17			ld de, .regstatebc 
16d0 3e 5a			ld a, display_row_3+10 
16d2 cd 93 0b			call str_at_display 
16d5			 
16d5 e1				pop hl 
16d6			;	ld h,b 
16d6			;	ld l, c 
16d6 3e 5d			ld a, display_row_3+13 
16d8 cd 33 15			call display_word_at 
16db			 
16db			 
16db				; display dsp 
16db			 
16db 11 68 17			ld de, .regstatedsp 
16de 3e 78			ld a, display_row_4 
16e0 cd 93 0b			call str_at_display 
16e3			 
16e3				 
16e3 2a f8 e9			ld hl,(cli_data_sp) 
16e6 3e 7c			ld a, display_row_4+4 
16e8 cd 33 15			call display_word_at 
16eb			 
16eb				; display rsp 
16eb			 
16eb 11 6d 17			ld de, .regstatersp 
16ee 3e 82			ld a, display_row_4+10 
16f0 cd 93 0b			call str_at_display 
16f3			 
16f3				 
16f3 2a fc e9			ld hl,(cli_ret_sp) 
16f6 3e 86			ld a, display_row_4+14 
16f8 cd 33 15			call display_word_at 
16fb			 
16fb cd a3 0b			call update_display 
16fe			 
16fe			;	call delay1s 
16fe			;	call delay1s 
16fe			;	call delay1s 
16fe			 
16fe			 
16fe			;	call next_page_prompt 
16fe			 
16fe				; restore  
16fe			 
16fe f1				pop af 
16ff e1				pop hl 
1700 c1				pop bc 
1701 d1				pop de 
1702 c9				ret 
1703			 
1703 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1717 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
172c .. 00		.ptrstate:	db "Ptr State",0 
1736 .. 00		.ptrcliptr:     db "cli_ptr",0 
173e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1748 .. 00		.regstate:	db "Reg State (1/0)",0 
1758 .. 00		.regstatehl:	db "HL:",0 
175c .. 00		.regstatede:	db "DE:",0 
1760 .. 00		.regstatebc:	db "BC:",0 
1764 .. 00		.regstatea:	db "A :",0 
1768 .. 00		.regstatedsp:	db "DSP:",0 
176d .. 00		.regstatersp:	db "RSP:",0 
1772			 
1772			display_dump_at_hl: 
1772 e5				push hl 
1773 d5				push de 
1774 c5				push bc 
1775 f5				push af 
1776			 
1776 22 ee e5			ld (os_cur_ptr),hl	 
1779 cd 80 0b			call clear_display 
177c cd 9f 1a			call dumpcont 
177f			;	call delay1s 
177f			;	call next_page_prompt 
177f			 
177f			 
177f f1				pop af 
1780 c1				pop bc 
1781 d1				pop de 
1782 e1				pop hl 
1783 c9				ret 
1784			 
1784			;if ENABLE_BASIC 
1784			;	include "nascombasic.asm" 
1784			;	basic: 
1784			;	include "forth/FORTH.ASM" 
1784			;endif 
1784			 
1784			; eof 
1784			 
1784			 
# End of file firmware_diags.asm
1784			  
1784			include "firmware_prompts.asm"  
1784			; Prompts  
1784			 
1784			; boot messages 
1784			 
1784 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1799 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17a9			 
17a9			 
17a9			; config menus 
17a9			 
17a9 .. 00		prom_c3: db "Add Dictionary To File",0 
17c0 .. 00		prom_c2: db "Select Autoload File",0 
17d5 .. 00		prom_c2a: db "Disable Autoload File", 0 
17eb .. 00		prom_c2b: db "Select Storage Bank",0 
17ff .. 00		prom_c4: db "Settings",0 
1808 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1823 .. 00		prom_m4b:   db "Monitor",0 
182b .. 00		prom_c1: db "Hardware Diags",0 
183a			 
183a			 
183a .. 00		prom_notav:    db "Feature not available",0 
1850 .. 00		prom_empty:    db "",0 
1851			 
1851			; eof 
1851			 
# End of file firmware_prompts.asm
1851			  
1851			  
1851			; eof  
1851			  
# End of file firmware.asm
1851			 
1851			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1851			;if BASE_KEV  
1851			;baseram: equ 08000h 
1851			;endif 
1851			 
1851			;if BASE_SC114 
1851			;baseram:     equ    endofcode 
1851			;endif 
1851			 
1851			 
1851			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1851			 
1851			; start system 
1851			 
1851			coldstart: 
1851				; set sp 
1851				; di/ei 
1851			 
1851 f3				di 
1852 31 00 f0			ld sp, tos 
1855			;	ei 
1855			 
1855			 
1855				; disable breakpoint by default 
1855			 
1855 3e 2a			ld a,'*' 
1857 32 bc e2			ld (os_view_disable),a 
185a			 
185a				; init hardware 
185a			 
185a				; init keyboard and screen hardware 
185a			 
185a cd 1c 01			call hardware_init 
185d			 
185d			 
185d cd f2 0a			call delay1s 
1860 3e 58			ld a, display_row_3+8 
1862 11 03 01			ld de, buildtime 
1865 cd 93 0b			call str_at_display 
1868 cd a3 0b			call update_display 
186b			 
186b cd f2 0a			call delay1s 
186e cd f2 0a			call delay1s 
1871 cd f2 0a			call delay1s 
1874			 
1874				; detect if any keys are held down to enable breakpoints at start up 
1874			 
1874 cd 19 64			call cin  
1877 fe 00			cp 0 
1879 28 03			jr z, .nokeys 
187b			 
187b				;call hardware_diags 
187b cd 0d 14			call config 
187e			 
187e			;	ld de, .bpen 
187e			;	ld a, display_row_4 
187e			;	call str_at_display 
187e			;	call update_display 
187e			; 
187e			;	ld a,0 
187e			;	ld (os_view_disable),a 
187e			; 
187e			;.bpwait: 
187e			;	call cin 
187e			;	cp 0 
187e			;	jr z, .bpwait 
187e			;	jr .nokeys 
187e			; 
187e			; 
187e			;.bpen:  db "Break points enabled!",0 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			.nokeys: 
187e			 
187e			 
187e				 
187e			 
187e			;jp  testkey 
187e			 
187e			;call storage_get_block_0 
187e			; 
187e			;ld hl, 0 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e				 
187e			;ld hl, 10 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			;stop:	nop 
187e			;	jp stop 
187e			 
187e			 
187e			 
187e			main: 
187e cd 80 0b			call clear_display 
1881 cd a3 0b			call update_display 
1884			 
1884			 
1884			 
1884			;	call testlcd 
1884			 
1884			 
1884			 
1884 cd 9c 1f			call forth_init 
1887			 
1887			 
1887			warmstart: 
1887 cd 72 1f			call forth_warmstart 
188a			 
188a				; run startup word load 
188a			        ; TODO prevent this running at warmstart after crash  
188a			 
188a				if STARTUP_ENABLE 
188a					if STORAGE_SE 
188a						call forth_autoload 
188a					endif 
188a cd 5f 60				call forth_startup 
188d			 
188d			 
188d				endif 
188d			 
188d				; show free memory after boot 
188d 11 27 19			ld de, freeram 
1890 3e 00			ld a, display_row_1 
1892 cd 93 0b			call str_at_display 
1895			 
1895			; Or use heap_size word???? 
1895 21 b1 e2			ld hl, heap_end 
1898 11 41 64			ld de, heap_start 
189b ed 52			sbc hl, de 
189d e5				push hl 
189e 7c				ld a,h	         	 
189f 21 d0 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18a2 cd ae 10			call hexout 
18a5 e1			   	pop hl 
18a6			 
18a6 7d				ld a,l 
18a7 21 d2 e5			ld hl, os_word_scratch+2 
18aa cd ae 10			call hexout 
18ad 21 d4 e5			ld hl, os_word_scratch+4 
18b0 3e 00			ld a, 0 
18b2 77				ld (hl),a 
18b3 11 d0 e5			ld de, os_word_scratch 
18b6 3e 0d			ld a, display_row_1 + 13 
18b8 cd 93 0b			call str_at_display 
18bb cd a3 0b			call update_display 
18be			 
18be			 
18be				;call demo 
18be			 
18be			 
18be				; init scratch input area for cli commands 
18be			 
18be 21 f2 e5			ld hl, os_cli_cmd 
18c1 3e 00			ld a,0 
18c3 77				ld (hl),a 
18c4 23				inc hl 
18c5 77				ld (hl),a 
18c6			 
18c6 3e 00			ld a,0 
18c8 32 f1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18cb			 
18cb 32 ee e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18ce 32 ef e5			ld (os_cur_ptr+1),a	 
18d1			 
18d1 32 d0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d4 32 d1 e5			ld (os_word_scratch+1),a	 
18d7				 
18d7			 
18d7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d7 21 f2 e5			ld hl, os_cli_cmd 
18da			 
18da 3e 00			ld a, 0		 ; init cli input 
18dc 77				ld (hl), a 
18dd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18df			cli: 
18df				; show cli prompt 
18df				;push af 
18df				;ld a, 0 
18df				;ld de, prompt 
18df				;call str_at_display 
18df			 
18df				;call update_display 
18df				;pop af 
18df				;inc a 
18df				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18df 0e 00			ld c, 0 
18e1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e3 1e 28			ld e, 40 
18e5			 
18e5 21 f2 e5			ld hl, os_cli_cmd 
18e8			 
18e8				STACKFRAME OFF $fefe $9f9f 
18e8				if DEBUG_STACK_IMB 
18e8					if OFF 
18e8						exx 
18e8						ld de, $fefe 
18e8						ld a, d 
18e8						ld hl, curframe 
18e8						call hexout 
18e8						ld a, e 
18e8						ld hl, curframe+2 
18e8						call hexout 
18e8						ld hl, $fefe 
18e8						push hl 
18e8						ld hl, $9f9f 
18e8						push hl 
18e8						exx 
18e8					endif 
18e8				endif 
18e8			endm 
# End of macro STACKFRAME
18e8			 
18e8 cd da 0d			call input_str 
18eb			 
18eb				STACKFRAMECHK OFF $fefe $9f9f 
18eb				if DEBUG_STACK_IMB 
18eb					if OFF 
18eb						exx 
18eb						ld hl, $9f9f 
18eb						pop de   ; $9f9f 
18eb						call cmp16 
18eb						jr nz, .spnosame 
18eb						ld hl, $fefe 
18eb						pop de   ; $fefe 
18eb						call cmp16 
18eb						jr z, .spfrsame 
18eb						.spnosame: call showsperror 
18eb						.spfrsame: nop 
18eb						exx 
18eb					endif 
18eb				endif 
18eb			endm 
# End of macro STACKFRAMECHK
18eb			 
18eb				; copy input to last command 
18eb			 
18eb 21 f2 e5			ld hl, os_cli_cmd 
18ee 11 f1 e6			ld de, os_last_cmd 
18f1 01 ff 00			ld bc, 255 
18f4 ed b0			ldir 
18f6			 
18f6				; wipe current buffer 
18f6			 
18f6			;	ld a, 0 
18f6			;	ld hl, os_cli_cmd 
18f6			;	ld de, os_cli_cmd+1 
18f6			;	ld bc, 254 
18f6			;	ldir 
18f6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f6			;	call strcpy 
18f6			;	ld a, 0 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			 
18f6				; switch frame buffer to program  
18f6			 
18f6 21 16 ed				ld hl, display_fb1 
18f9 22 d2 eb				ld (display_fb_active), hl 
18fc			 
18fc			;	nop 
18fc				STACKFRAME ON $fbfe $8f9f 
18fc				if DEBUG_STACK_IMB 
18fc					if ON 
18fc						exx 
18fc						ld de, $fbfe 
18fc						ld a, d 
18fc						ld hl, curframe 
18fc						call hexout 
18fc						ld a, e 
18fc						ld hl, curframe+2 
18fc						call hexout 
18fc						ld hl, $fbfe 
18fc						push hl 
18fc						ld hl, $8f9f 
18fc						push hl 
18fc						exx 
18fc					endif 
18fc				endif 
18fc			endm 
# End of macro STACKFRAME
18fc				; first time into the parser so pass over the current scratch pad 
18fc 21 f2 e5			ld hl,os_cli_cmd 
18ff				; tokenise the entered statement(s) in HL 
18ff cd 1a 20			call forthparse 
1902			        ; exec forth statements in top of return stack 
1902 cd 5a 20			call forthexec 
1905				;call forthexec_cleanup 
1905			;	call parsenext 
1905			 
1905				STACKFRAMECHK ON $fbfe $8f9f 
1905				if DEBUG_STACK_IMB 
1905					if ON 
1905						exx 
1905						ld hl, $8f9f 
1905						pop de   ; $8f9f 
1905						call cmp16 
1905						jr nz, .spnosame 
1905						ld hl, $fbfe 
1905						pop de   ; $fbfe 
1905						call cmp16 
1905						jr z, .spfrsame 
1905						.spnosame: call showsperror 
1905						.spfrsame: nop 
1905						exx 
1905					endif 
1905				endif 
1905			endm 
# End of macro STACKFRAMECHK
1905				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1905			 
1905 3e 78			ld a, display_row_4 
1907 11 39 19			ld de, endprog 
190a			 
190a cd a3 0b			call update_display		 
190d			 
190d cd 97 1b			call next_page_prompt 
1910			 
1910				; switch frame buffer to cli 
1910			 
1910 21 b7 ed				ld hl, display_fb0 
1913 22 d2 eb				ld (display_fb_active), hl 
1916			 
1916			 
1916 cd 80 0b		        call clear_display 
1919 cd a3 0b			call update_display		 
191c			 
191c 21 f2 e5			ld hl, os_cli_cmd 
191f			 
191f 3e 00			ld a, 0		 ; init cli input 
1921 77				ld (hl), a 
1922			 
1922				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1922			 
1922				; now on last line 
1922			 
1922				; TODO scroll screen up 
1922			 
1922				; TODO instead just clear screen and place at top of screen 
1922			 
1922			;	ld a, 0 
1922			;	ld (f_cursor_ptr),a 
1922			 
1922				;call clear_display 
1922				;call update_display 
1922			 
1922				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1922 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1924 c3 df 18			jp cli 
1927			 
1927 .. 00		freeram: db "Free bytes: $",0 
1935 ..			asc: db "1A2F" 
1939 .. 00		endprog: db "End prog...",0 
1945			 
1945			testenter2:   
1945 21 fd e2			ld hl,scratch+50 
1948 22 ee e5			ld (os_cur_ptr),hl 
194b c3 df 18			jp cli 
194e			 
194e			testenter:  
194e			 
194e 21 35 19			ld hl,asc 
1951			;	ld a,(hl) 
1951			;	call nibble2val 
1951 cd 04 11			call get_byte 
1954			 
1954			 
1954			;	ld a,(hl) 
1954			;	call atohex 
1954			 
1954			;	call fourehexhl 
1954 32 fd e2			ld (scratch+50),a 
1957			 
1957			 
1957			 
1957 21 37 19			ld hl,asc+2 
195a			;	ld a, (hl) 
195a			;	call nibble2val 
195a cd 04 11			call get_byte 
195d			 
195d			;	call fourehexhl 
195d 32 ff e2			ld (scratch+52),a 
1960				 
1960 21 fd e2			ld hl,scratch+50 
1963 22 ee e5			ld (os_cur_ptr),hl 
1966 c3 df 18			jp cli 
1969			 
1969			enter:	 
1969 3a cf e2			ld a,(scratch+4) 
196c fe 00			cp 0 
196e 28 0c			jr z, .entercont 
1970				; no, not a null term line so has an address to work out.... 
1970			 
1970 21 cd e2			ld hl,scratch+2 
1973 cd 64 11			call get_word_hl 
1976			 
1976 22 ee e5			ld (os_cur_ptr),hl	 
1979 c3 df 18			jp cli 
197c			 
197c			 
197c			.entercont:  
197c			 
197c 21 cd e2			ld hl, scratch+2 
197f cd 04 11			call get_byte 
1982			 
1982 2a ee e5		   	ld hl,(os_cur_ptr) 
1985 77					ld (hl),a 
1986 23					inc hl 
1987 22 ee e5				ld (os_cur_ptr),hl 
198a				 
198a			; get byte  
198a			 
198a			 
198a c3 df 18			jp cli 
198d			 
198d			 
198d			; basic monitor support 
198d			 
198d			monitor: 
198d				;  
198d cd 80 0b			call clear_display 
1990 3e 00			ld a, 0 
1992 11 da 19			ld de, .monprompt 
1995 cd 93 0b			call str_at_display 
1998 cd a3 0b			call update_display 
199b			 
199b				; get a monitor command 
199b			 
199b 0e 00			ld c, 0     ; entry at top left 
199d 16 64			ld d, 100   ; max buffer size 
199f 1e 0f			ld e, 15    ; input scroll area 
19a1 3e 00			ld a, 0     ; init string 
19a3 21 c9 e4			ld hl, os_input 
19a6 77				ld (hl), a 
19a7 23				inc hl 
19a8 77				ld (hl), a 
19a9 21 c9 e4			ld hl, os_input 
19ac 3e 01			ld a, 1     ; init string 
19ae cd da 0d			call input_str 
19b1			 
19b1 cd 80 0b		        call clear_display 
19b4 cd a3 0b			call update_display		 
19b7			 
19b7 3a c9 e4			ld a, (os_input) 
19ba cd 02 12			call toUpper 
19bd fe 48		        cp 'H' 
19bf 28 6f		        jr z, .monhelp 
19c1 fe 44			cp 'D'		; dump 
19c3 ca 51 1a			jp z, .mondump	 
19c6 fe 43			cp 'C'		; dump 
19c8 ca 6b 1a			jp z, .moncdump	 
19cb fe 4d			cp 'M'		; dump 
19cd ca dc 19			jp z, .moneditstart 
19d0 fe 55			cp 'U'		; dump 
19d2 28 14			jr z, .monedit	 
19d4 fe 51			cp 'Q'		; dump 
19d6 c8				ret z	 
19d7			 
19d7			 
19d7				; TODO "S" to access symbol by name and not need the address 
19d7				; TODO "F" to find a string in memory 
19d7			 
19d7 c3 8d 19			jp monitor 
19da			 
19da .. 00		.monprompt: db ">", 0 
19dc			 
19dc			.moneditstart: 
19dc				; get starting address 
19dc			 
19dc 21 cb e4			ld hl,os_input+2 
19df cd 64 11			call get_word_hl 
19e2			 
19e2 22 ee e5			ld (os_cur_ptr),hl	 
19e5			 
19e5 c3 8d 19			jp monitor 
19e8			 
19e8			.monedit: 
19e8				; get byte to load 
19e8			 
19e8 21 cb e4			ld hl,os_input+2 
19eb cd 04 11			call get_byte 
19ee			 
19ee				; get address to update 
19ee 2a ee e5			ld hl, (os_cur_ptr) 
19f1			 
19f1				; update byte 
19f1			 
19f1 77				ld (hl), a 
19f2			 
19f2				; move to next address and save it 
19f2			 
19f2 23				inc hl 
19f3 22 ee e5			ld (os_cur_ptr),hl	 
19f6			 
19f6 c3 8d 19			jp monitor 
19f9			 
19f9			 
19f9 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a0d .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a29 .. 00		.monhelptext3:  db "Q-Quit",0 
1a30			        
1a30			.monhelp: 
1a30 3e 00			ld a, display_row_1 
1a32 11 f9 19		        ld de, .monhelptext1 
1a35			 
1a35 cd 93 0b			call str_at_display 
1a38 3e 28			ld a, display_row_2 
1a3a 11 0d 1a		        ld de, .monhelptext2 
1a3d					 
1a3d cd 93 0b			call str_at_display 
1a40 3e 50			ld a, display_row_3 
1a42 11 29 1a		        ld de, .monhelptext3 
1a45					 
1a45 cd 93 0b			call str_at_display 
1a48 cd a3 0b			call update_display		 
1a4b			 
1a4b cd 97 1b			call next_page_prompt 
1a4e c3 8d 19			jp monitor 
1a51			 
1a51			.mondump:    
1a51 21 cb e4			ld hl,os_input+2 
1a54 cd 64 11			call get_word_hl 
1a57			 
1a57 22 ee e5			ld (os_cur_ptr),hl	 
1a5a cd 9f 1a			call dumpcont 
1a5d 3e 78			ld a, display_row_4 
1a5f 11 39 19			ld de, endprog 
1a62			 
1a62 cd a3 0b			call update_display		 
1a65			 
1a65 cd 97 1b			call next_page_prompt 
1a68 c3 8d 19			jp monitor 
1a6b			.moncdump: 
1a6b cd 9f 1a			call dumpcont 
1a6e 3e 78			ld a, display_row_4 
1a70 11 39 19			ld de, endprog 
1a73			 
1a73 cd a3 0b			call update_display		 
1a76			 
1a76 cd 97 1b			call next_page_prompt 
1a79 c3 8d 19			jp monitor 
1a7c			 
1a7c			 
1a7c			; TODO symbol access  
1a7c			 
1a7c			.symbols:     ;; A list of symbols that can be called up  
1a7c b7 ed			dw display_fb0 
1a7e .. 00			db "fb0",0  
1a82 84 ea		     	dw store_page 
1a84 .. 00			db "store_page",0 
1a8f			 
1a8f			 
1a8f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a8f			 
1a8f 3a cc e2			ld a,(scratch+1) 
1a92 fe 00			cp 0 
1a94 28 09			jr z, dumpcont 
1a96			 
1a96				; no, not a null term line so has an address to work out.... 
1a96			 
1a96 21 cd e2			ld hl,scratch+2 
1a99 cd 64 11			call get_word_hl 
1a9c			 
1a9c 22 ee e5			ld (os_cur_ptr),hl	 
1a9f			 
1a9f			 
1a9f			 
1a9f			dumpcont: 
1a9f			 
1a9f				; dump bytes at ptr 
1a9f			 
1a9f			 
1a9f 3e 00			ld a, display_row_1 
1aa1 2a d2 eb			ld hl, (display_fb_active) 
1aa4 cd ad 0d			call addatohl 
1aa7 cd cf 1a			call .dumpbyterow 
1aaa			 
1aaa 3e 28			ld a, display_row_2 
1aac 2a d2 eb			ld hl, (display_fb_active) 
1aaf cd ad 0d			call addatohl 
1ab2 cd cf 1a			call .dumpbyterow 
1ab5			 
1ab5			 
1ab5 3e 50			ld a, display_row_3 
1ab7 2a d2 eb			ld hl, (display_fb_active) 
1aba cd ad 0d			call addatohl 
1abd cd cf 1a			call .dumpbyterow 
1ac0			 
1ac0 3e 78			ld a, display_row_4 
1ac2 2a d2 eb			ld hl, (display_fb_active) 
1ac5 cd ad 0d			call addatohl 
1ac8 cd cf 1a			call .dumpbyterow 
1acb			 
1acb cd a3 0b			call update_display 
1ace			;		jp cli 
1ace c9				ret 
1acf			 
1acf			.dumpbyterow: 
1acf			 
1acf				;push af 
1acf			 
1acf e5				push hl 
1ad0			 
1ad0				; calc where to poke the ascii 
1ad0			if display_cols == 20 
1ad0				ld a, 16 
1ad0			else 
1ad0 3e 1f			ld a, 31 
1ad2			endif 
1ad2			 
1ad2 cd ad 0d			call addatohl 
1ad5 22 d0 e5			ld (os_word_scratch),hl  		; save pos for later 
1ad8			 
1ad8			 
1ad8			; display decoding address 
1ad8 2a ee e5		   	ld hl,(os_cur_ptr) 
1adb			 
1adb 7c				ld a,h 
1adc e1				pop hl 
1add e5				push hl 
1ade			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ade cd ae 10			call hexout 
1ae1 2a ee e5		   	ld hl,(os_cur_ptr) 
1ae4			 
1ae4 7d				ld a,l 
1ae5 e1				pop hl 
1ae6 23				inc hl 
1ae7 23				inc hl 
1ae8 e5				push hl 
1ae9			;	ld hl, os_word_scratch+2 
1ae9 cd ae 10			call hexout 
1aec e1				pop hl 
1aed 23				inc hl 
1aee 23				inc hl 
1aef				;ld hl, os_word_scratch+4 
1aef 3e 3a			ld a, ':' 
1af1 77				ld (hl),a 
1af2 23				inc hl 
1af3				;ld a, 0 
1af3				;ld (hl),a 
1af3				;ld de, os_word_scratch 
1af3				;pop af 
1af3				;push af 
1af3			;		ld a, display_row_2 
1af3			;		call str_at_display 
1af3			;		call update_display 
1af3			 
1af3			 
1af3			;pop af 
1af3			;	add 5 
1af3			 
1af3			if display_cols == 20 
1af3				ld b, 4 
1af3			else 
1af3 06 08			ld b, 8 
1af5			endif	 
1af5			 
1af5			.dumpbyte: 
1af5 c5				push bc 
1af6 e5				push hl 
1af7			 
1af7			 
1af7 2a ee e5		   	ld hl,(os_cur_ptr) 
1afa 7e					ld a,(hl) 
1afb			 
1afb					; poke the ascii to display 
1afb 2a d0 e5				ld hl,(os_word_scratch) 
1afe 77					ld (hl),a 
1aff 23					inc hl 
1b00 22 d0 e5				ld (os_word_scratch),hl 
1b03			 
1b03					 
1b03			 
1b03			 
1b03 e1					pop hl 
1b04 e5					push hl 
1b05			 
1b05 cd ae 10				call hexout 
1b08			 
1b08					 
1b08 2a ee e5		   	ld hl,(os_cur_ptr) 
1b0b 23				inc hl 
1b0c 22 ee e5		   	ld (os_cur_ptr),hl 
1b0f			 
1b0f e1					pop hl 
1b10 23					inc hl 
1b11 23					inc hl 
1b12 23					inc hl 
1b13			 
1b13			 
1b13			 
1b13					;ld a,0 
1b13					;ld (os_word_scratch+2),a 
1b13					;pop af 
1b13					;push af 
1b13			 
1b13					;ld de, os_word_scratch 
1b13					;call str_at_display 
1b13			;		call update_display 
1b13			;		pop af 
1b13 c1					pop bc 
1b14 c6 03				add 3 
1b16 10 dd			djnz .dumpbyte 
1b18			 
1b18				 
1b18			 
1b18 c9				ret 
1b19			 
1b19			jump:	 
1b19			 
1b19 21 cd e2			ld hl,scratch+2 
1b1c cd 64 11			call get_word_hl 
1b1f				;ld hl,(scratch+2) 
1b1f				;call fourehexhl 
1b1f			 
1b1f 22 ee e5			ld (os_cur_ptr),hl	 
1b22			 
1b22 e9				jp (hl) 
1b23			 
1b23			 
1b23			 
1b23			; TODO implement a basic monitor mode to start with 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			; testing and demo code during development 
1b23			 
1b23			 
1b23 .. 00		str1: db "Enter some text...",0 
1b36 .. 00		clear: db "                    ",0 
1b4b			 
1b4b			demo: 
1b4b			 
1b4b			 
1b4b			 
1b4b			;	call update_display 
1b4b			 
1b4b				; init scratch input area for testing 
1b4b 21 cb e2			ld hl, scratch	 
1b4e 3e 00			ld a,0 
1b50 77				ld (hl),a 
1b51			 
1b51			 
1b51 3e 28		            LD   A, display_row_2 
1b53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b53 11 23 1b		            LD   DE, str1 
1b56 cd 93 0b			call str_at_display 
1b59			 
1b59			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b59			cloop:	 
1b59 3e 50		            LD   A, display_row_3 
1b5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b5b 11 36 1b		            LD   DE, clear 
1b5e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b5e cd 93 0b				call str_at_display 
1b61 3e 78			ld a, display_row_4 
1b63 11 93 1b			ld de, prompt 
1b66			 
1b66 cd 93 0b				call str_at_display 
1b69 cd a3 0b			call update_display 
1b6c			 
1b6c 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b6e 16 0a			ld d, 10 
1b70 21 cb e2			ld hl, scratch	 
1b73 cd da 0d			call input_str 
1b76			 
1b76			;	call clear_display 
1b76			;'	call update_display 
1b76			 
1b76 3e 00		            LD   A, display_row_1 
1b78			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b78 11 36 1b		            LD   DE, clear 
1b7b cd 93 0b				call str_at_display 
1b7e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b7e 3e 00		            LD   A, display_row_1 
1b80			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b80 11 cb e2		            LD   DE, scratch 
1b83			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b83 cd 93 0b				call str_at_display 
1b86 cd a3 0b			call update_display 
1b89			 
1b89 3e 00				ld a,0 
1b8b 21 cb e2			ld hl, scratch 
1b8e 77				ld (hl),a 
1b8f			 
1b8f 00				nop 
1b90 c3 59 1b			jp cloop 
1b93			 
1b93			 
1b93			 
1b93			; OS Prompt 
1b93			 
1b93 .. 00		prompt: db ">",0 
1b95 .. 00		endprg: db "?",0 
1b97			 
1b97			 
1b97			; handy next page prompt 
1b97			next_page_prompt: 
1b97 e5				push hl 
1b98 d5				push de 
1b99 f5				push af 
1b9a c5				push bc 
1b9b			 
1b9b 3e 9f			ld a,display_row_4 + display_cols - 1 
1b9d 11 95 1b		        ld de, endprg 
1ba0 cd 93 0b			call str_at_display 
1ba3 cd a3 0b			call update_display 
1ba6 cd 11 64			call cin_wait 
1ba9 c1				pop bc 
1baa f1				pop af 
1bab d1				pop de 
1bac e1				pop hl 
1bad			 
1bad			 
1bad c9				ret 
1bae			 
1bae			 
1bae			; forth parser 
1bae			 
1bae			; My forth kernel 
1bae			include "forth_kernel.asm" 
1bae			; 
1bae			; kernel to the forth OS 
1bae			 
1bae			DS_TYPE_STR: equ 1     ; string type 
1bae			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bae			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bae			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bae			 
1bae			FORTH_PARSEV1: equ 0 
1bae			FORTH_PARSEV2: equ 0 
1bae			FORTH_PARSEV3: equ 0 
1bae			FORTH_PARSEV4: equ 0 
1bae			FORTH_PARSEV5: equ 1 
1bae			 
1bae			;if FORTH_PARSEV5 
1bae			;	FORTH_END_BUFFER: equ 0 
1bae			;else 
1bae			FORTH_END_BUFFER: equ 127 
1bae			;endif 
1bae			 
1bae			FORTH_TRUE: equ 1 
1bae			FORTH_FALSE: equ 0 
1bae			 
1bae			if FORTH_PARSEV4 
1bae			include "forth_stackops.asm" 
1bae			endif 
1bae			 
1bae			if FORTH_PARSEV5 
1bae			include "forth_stackopsv5.asm" 
1bae			 
1bae			; Stack operations for v5 parser on wards 
1bae			; * DATA stack 
1bae			; * LOOP stack 
1bae			; * RETURN stack 
1bae			 
1bae			 
1bae			 
1bae			FORTH_CHK_DSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_data_sp) 
1bae				ld de, cli_data_stack 
1bae				call cmp16 
1bae				jp c, fault_dsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			 
1bae			FORTH_CHK_RSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_ret_sp) 
1bae				ld de, cli_ret_stack 
1bae				call cmp16 
1bae				jp c, fault_rsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_CHK_LOOP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_loop_sp) 
1bae				ld de, cli_loop_stack 
1bae				call cmp16 
1bae				jp c, fault_loop_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTSTR: macro 
1bae				; TOSO might need more for checks when used 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_STR 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTNUM: macro 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_INUM 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			 
1bae			; increase data stack pointer and save hl to it 
1bae				 
1bae			FORTH_DSP_NEXT: macro 
1bae				call macro_forth_dsp_next 
1bae				endm 
1bae			 
1bae			 
1bae			macro_forth_dsp_next: 
1bae				if DEBUG_FORTH_STACK_GUARD 
1bae cd 29 61				call check_stacks 
1bb1				endif 
1bb1 e5				push hl 
1bb2 d5				push de 
1bb3 eb				ex de,hl 
1bb4 2a f8 e9			ld hl,(cli_data_sp) 
1bb7 23				inc hl 
1bb8 23				inc hl 
1bb9			 
1bb9			; PARSEV5 
1bb9 23				inc hl 
1bba 22 f8 e9			ld (cli_data_sp),hl 
1bbd 73				ld (hl), e 
1bbe 23				inc hl 
1bbf 72				ld (hl), d 
1bc0 d1				pop de 
1bc1 e1				pop hl 
1bc2				if DEBUG_FORTH_STACK_GUARD 
1bc2 cd 29 61				call check_stacks 
1bc5				endif 
1bc5 c9				ret 
1bc6			 
1bc6			 
1bc6			; increase ret stack pointer and save hl to it 
1bc6				 
1bc6			FORTH_RSP_NEXT: macro 
1bc6				call macro_forth_rsp_next 
1bc6				endm 
1bc6			 
1bc6			macro_forth_rsp_next: 
1bc6				if DEBUG_FORTH_STACK_GUARD 
1bc6 cd 29 61				call check_stacks 
1bc9				endif 
1bc9 e5				push hl 
1bca d5				push de 
1bcb eb				ex de,hl 
1bcc 2a fc e9			ld hl,(cli_ret_sp) 
1bcf 23				inc hl 
1bd0 23				inc hl 
1bd1 22 fc e9			ld (cli_ret_sp),hl 
1bd4 73				ld (hl), e 
1bd5 23				inc hl 
1bd6 72				ld (hl), d 
1bd7 d1				pop de 
1bd8 e1				pop hl 
1bd9				if DEBUG_FORTH_STACK_GUARD 
1bd9 cd 29 61				call check_stacks 
1bdc				endif 
1bdc c9				ret 
1bdd			 
1bdd			; get current ret stack pointer and save to hl  
1bdd				 
1bdd			FORTH_RSP_TOS: macro 
1bdd				call macro_forth_rsp_tos 
1bdd				endm 
1bdd			 
1bdd			macro_forth_rsp_tos: 
1bdd				;push de 
1bdd 2a fc e9			ld hl,(cli_ret_sp) 
1be0 cd 18 1c			call loadhlptrtohl 
1be3				;ld e, (hl) 
1be3				;inc hl 
1be3				;ld d, (hl) 
1be3				;ex de, hl 
1be3					if DEBUG_FORTH_WORDS 
1be3			;			DMARK "RST" 
1be3						CALLMONITOR 
1be3 cd ae 15			call break_point_state  
1be6				endm  
# End of macro CALLMONITOR
1be6					endif 
1be6				;pop de 
1be6 c9				ret 
1be7			 
1be7			; pop ret stack pointer 
1be7				 
1be7			FORTH_RSP_POP: macro 
1be7				call macro_forth_rsp_pop 
1be7				endm 
1be7			 
1be7			 
1be7			macro_forth_rsp_pop: 
1be7				if DEBUG_FORTH_STACK_GUARD 
1be7			;		DMARK "RPP" 
1be7 cd 29 61				call check_stacks 
1bea					FORTH_CHK_RSP_UNDER 
1bea e5				push hl 
1beb d5				push de 
1bec 2a fc e9			ld hl,(cli_ret_sp) 
1bef 11 b6 e9			ld de, cli_ret_stack 
1bf2 cd cb 0d			call cmp16 
1bf5 da 3d 62			jp c, fault_rsp_under 
1bf8 d1				pop de 
1bf9 e1				pop hl 
1bfa				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bfa				endif 
1bfa e5				push hl 
1bfb 2a fc e9			ld hl,(cli_ret_sp) 
1bfe			 
1bfe			 
1bfe				if FORTH_ENABLE_FREE 
1bfe			 
1bfe					; get pointer 
1bfe			 
1bfe					push de 
1bfe					push hl 
1bfe			 
1bfe					ld e, (hl) 
1bfe					inc hl 
1bfe					ld d, (hl) 
1bfe			 
1bfe					ex de, hl 
1bfe					call free 
1bfe			 
1bfe					pop hl 
1bfe					pop de 
1bfe			 
1bfe			 
1bfe				endif 
1bfe			 
1bfe			 
1bfe 2b				dec hl 
1bff 2b				dec hl 
1c00 22 fc e9			ld (cli_ret_sp), hl 
1c03				; do stack underflow checks 
1c03 e1				pop hl 
1c04				if DEBUG_FORTH_STACK_GUARD 
1c04 cd 29 61				call check_stacks 
1c07					FORTH_CHK_RSP_UNDER 
1c07 e5				push hl 
1c08 d5				push de 
1c09 2a fc e9			ld hl,(cli_ret_sp) 
1c0c 11 b6 e9			ld de, cli_ret_stack 
1c0f cd cb 0d			call cmp16 
1c12 da 3d 62			jp c, fault_rsp_under 
1c15 d1				pop de 
1c16 e1				pop hl 
1c17				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c17				endif 
1c17 c9				ret 
1c18			 
1c18			 
1c18			 
1c18			; routine to load word pointed to by hl into hl 
1c18			 
1c18			loadhlptrtohl: 
1c18			 
1c18 d5				push de 
1c19 5e				ld e, (hl) 
1c1a 23				inc hl 
1c1b 56				ld d, (hl) 
1c1c eb				ex de, hl 
1c1d d1				pop de 
1c1e			 
1c1e c9				ret 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			; push a number held in HL onto the data stack 
1c1f			; entry point for pushing a value when already in hl used in function above 
1c1f			 
1c1f			forth_push_numhl: 
1c1f			 
1c1f e5				push hl    ; save value to push 
1c20			 
1c20			if DEBUG_FORTH_PUSH 
1c20				; see if disabled 
1c20			 
1c20			 
1c20 f5				push af 
1c21 3a bc e2			ld a, (os_view_disable) 
1c24 fe 2a			cp '*' 
1c26 28 34			jr z, .pskip2 
1c28 e5				push hl 
1c29 e5			push hl 
1c2a cd 80 0b			call clear_display 
1c2d e1			pop hl 
1c2e 7c				ld a,h 
1c2f 21 d0 e5			ld hl, os_word_scratch 
1c32 cd ae 10			call hexout 
1c35 e1				pop hl 
1c36 7d				ld a,l 
1c37 21 d2 e5			ld hl, os_word_scratch+2 
1c3a cd ae 10			call hexout 
1c3d			 
1c3d 21 d4 e5			ld hl, os_word_scratch+4 
1c40 3e 00			ld a,0 
1c42 77				ld (hl),a 
1c43 11 d0 e5			ld de,os_word_scratch 
1c46 3e 28				ld a, display_row_2 
1c48 cd 93 0b				call str_at_display 
1c4b 11 33 4c			ld de, .push_num 
1c4e 3e 00			ld a, display_row_1 
1c50			 
1c50 cd 93 0b				call str_at_display 
1c53			 
1c53			 
1c53 cd a3 0b			call update_display 
1c56 cd f2 0a			call delay1s 
1c59 cd f2 0a			call delay1s 
1c5c			.pskip2:  
1c5c			 
1c5c f1				pop af 
1c5d			endif	 
1c5d			 
1c5d			 
1c5d				FORTH_DSP_NEXT 
1c5d cd ae 1b			call macro_forth_dsp_next 
1c60				endm 
# End of macro FORTH_DSP_NEXT
1c60			 
1c60 2a f8 e9			ld hl, (cli_data_sp) 
1c63			 
1c63				; save item type 
1c63 3e 02			ld a,  DS_TYPE_INUM 
1c65 77				ld (hl), a 
1c66 23				inc hl 
1c67			 
1c67				; get word off stack 
1c67 d1				pop de 
1c68 7b				ld a,e 
1c69 77				ld (hl), a 
1c6a 23				inc hl 
1c6b 7a				ld a,d 
1c6c 77				ld (hl), a 
1c6d			 
1c6d			if DEBUG_FORTH_PUSH 
1c6d 2b				dec hl 
1c6e 2b				dec hl 
1c6f 2b				dec hl 
1c70						DMARK "PH5" 
1c70 f5				push af  
1c71 3a 85 1c			ld a, (.dmark)  
1c74 32 71 ee			ld (debug_mark),a  
1c77 3a 86 1c			ld a, (.dmark+1)  
1c7a 32 72 ee			ld (debug_mark+1),a  
1c7d 3a 87 1c			ld a, (.dmark+2)  
1c80 32 73 ee			ld (debug_mark+2),a  
1c83 18 03			jr .pastdmark  
1c85 ..			.dmark: db "PH5"  
1c88 f1			.pastdmark: pop af  
1c89			endm  
# End of macro DMARK
1c89				CALLMONITOR 
1c89 cd ae 15			call break_point_state  
1c8c				endm  
# End of macro CALLMONITOR
1c8c			endif	 
1c8c			 
1c8c c9				ret 
1c8d			 
1c8d			 
1c8d			; Push a string to stack pointed to by hl 
1c8d			 
1c8d			forth_push_str: 
1c8d			 
1c8d			if DEBUG_FORTH_PUSH 
1c8d						DMARK "PSQ" 
1c8d f5				push af  
1c8e 3a a2 1c			ld a, (.dmark)  
1c91 32 71 ee			ld (debug_mark),a  
1c94 3a a3 1c			ld a, (.dmark+1)  
1c97 32 72 ee			ld (debug_mark+1),a  
1c9a 3a a4 1c			ld a, (.dmark+2)  
1c9d 32 73 ee			ld (debug_mark+2),a  
1ca0 18 03			jr .pastdmark  
1ca2 ..			.dmark: db "PSQ"  
1ca5 f1			.pastdmark: pop af  
1ca6			endm  
# End of macro DMARK
1ca6				CALLMONITOR 
1ca6 cd ae 15			call break_point_state  
1ca9				endm  
# End of macro CALLMONITOR
1ca9			endif	 
1ca9			    
1ca9 e5				push hl 
1caa e5				push hl 
1cab			 
1cab			;	ld a, 0   ; find end of string 
1cab cd 0b 12			call strlenz 
1cae			if DEBUG_FORTH_PUSH 
1cae						DMARK "PQ2" 
1cae f5				push af  
1caf 3a c3 1c			ld a, (.dmark)  
1cb2 32 71 ee			ld (debug_mark),a  
1cb5 3a c4 1c			ld a, (.dmark+1)  
1cb8 32 72 ee			ld (debug_mark+1),a  
1cbb 3a c5 1c			ld a, (.dmark+2)  
1cbe 32 73 ee			ld (debug_mark+2),a  
1cc1 18 03			jr .pastdmark  
1cc3 ..			.dmark: db "PQ2"  
1cc6 f1			.pastdmark: pop af  
1cc7			endm  
# End of macro DMARK
1cc7				CALLMONITOR 
1cc7 cd ae 15			call break_point_state  
1cca				endm  
# End of macro CALLMONITOR
1cca			endif	 
1cca eb				ex de, hl 
1ccb e1				pop hl   ; get ptr to start of string 
1ccc			if DEBUG_FORTH_PUSH 
1ccc						DMARK "PQ3" 
1ccc f5				push af  
1ccd 3a e1 1c			ld a, (.dmark)  
1cd0 32 71 ee			ld (debug_mark),a  
1cd3 3a e2 1c			ld a, (.dmark+1)  
1cd6 32 72 ee			ld (debug_mark+1),a  
1cd9 3a e3 1c			ld a, (.dmark+2)  
1cdc 32 73 ee			ld (debug_mark+2),a  
1cdf 18 03			jr .pastdmark  
1ce1 ..			.dmark: db "PQ3"  
1ce4 f1			.pastdmark: pop af  
1ce5			endm  
# End of macro DMARK
1ce5				CALLMONITOR 
1ce5 cd ae 15			call break_point_state  
1ce8				endm  
# End of macro CALLMONITOR
1ce8			endif	 
1ce8 19				add hl,de 
1ce9			if DEBUG_FORTH_PUSH 
1ce9						DMARK "PQE" 
1ce9 f5				push af  
1cea 3a fe 1c			ld a, (.dmark)  
1ced 32 71 ee			ld (debug_mark),a  
1cf0 3a ff 1c			ld a, (.dmark+1)  
1cf3 32 72 ee			ld (debug_mark+1),a  
1cf6 3a 00 1d			ld a, (.dmark+2)  
1cf9 32 73 ee			ld (debug_mark+2),a  
1cfc 18 03			jr .pastdmark  
1cfe ..			.dmark: db "PQE"  
1d01 f1			.pastdmark: pop af  
1d02			endm  
# End of macro DMARK
1d02				CALLMONITOR 
1d02 cd ae 15			call break_point_state  
1d05				endm  
# End of macro CALLMONITOR
1d05			endif	 
1d05			 
1d05 2b				dec hl    ; see if there is an optional trailing double quote 
1d06 7e				ld a,(hl) 
1d07 fe 22			cp '"' 
1d09 20 03			jr nz, .strnoq 
1d0b 3e 00			ld a, 0      ; get rid of double quote 
1d0d 77				ld (hl), a 
1d0e 23			.strnoq: inc hl 
1d0f			 
1d0f 3e 00			ld a, 0 
1d11 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d12			 
1d12 13				inc de ; add one for the type string 
1d13 13				inc de ; add one for null term??? 
1d14			 
1d14				; tos is get string pointer again 
1d14				; de contains space to allocate 
1d14				 
1d14 d5				push de 
1d15			 
1d15 eb				ex de, hl 
1d16			 
1d16				;push af 
1d16			 
1d16			if DEBUG_FORTH_PUSH 
1d16						DMARK "PHm" 
1d16 f5				push af  
1d17 3a 2b 1d			ld a, (.dmark)  
1d1a 32 71 ee			ld (debug_mark),a  
1d1d 3a 2c 1d			ld a, (.dmark+1)  
1d20 32 72 ee			ld (debug_mark+1),a  
1d23 3a 2d 1d			ld a, (.dmark+2)  
1d26 32 73 ee			ld (debug_mark+2),a  
1d29 18 03			jr .pastdmark  
1d2b ..			.dmark: db "PHm"  
1d2e f1			.pastdmark: pop af  
1d2f			endm  
# End of macro DMARK
1d2f				CALLMONITOR 
1d2f cd ae 15			call break_point_state  
1d32				endm  
# End of macro CALLMONITOR
1d32			endif	 
1d32 cd 74 12			call malloc	; on ret hl now contains allocated memory 
1d35				if DEBUG_FORTH_MALLOC_GUARD 
1d35 cc 8b 4c				call z,malloc_error 
1d38				endif 
1d38			 
1d38				 
1d38 c1				pop bc    ; get length 
1d39 d1				pop de   ;  get string start    
1d3a			 
1d3a				; hl has destination from malloc 
1d3a			 
1d3a eb				ex de, hl    ; prep for ldir 
1d3b			 
1d3b d5				push de   ; save malloc area for DSP later 
1d3c				;push hl   ; save malloc area for DSP later 
1d3c			 
1d3c			if DEBUG_FORTH_PUSH 
1d3c						DMARK "PHc" 
1d3c f5				push af  
1d3d 3a 51 1d			ld a, (.dmark)  
1d40 32 71 ee			ld (debug_mark),a  
1d43 3a 52 1d			ld a, (.dmark+1)  
1d46 32 72 ee			ld (debug_mark+1),a  
1d49 3a 53 1d			ld a, (.dmark+2)  
1d4c 32 73 ee			ld (debug_mark+2),a  
1d4f 18 03			jr .pastdmark  
1d51 ..			.dmark: db "PHc"  
1d54 f1			.pastdmark: pop af  
1d55			endm  
# End of macro DMARK
1d55				CALLMONITOR 
1d55 cd ae 15			call break_point_state  
1d58				endm  
# End of macro CALLMONITOR
1d58			endif	 
1d58			 
1d58			 
1d58 ed b0			ldir 
1d5a			 
1d5a			 
1d5a				; push malloc to data stack     macro?????  
1d5a			 
1d5a				FORTH_DSP_NEXT 
1d5a cd ae 1b			call macro_forth_dsp_next 
1d5d				endm 
# End of macro FORTH_DSP_NEXT
1d5d			 
1d5d				; save value and type 
1d5d			 
1d5d 2a f8 e9			ld hl, (cli_data_sp) 
1d60			 
1d60				; save item type 
1d60 3e 01			ld a,  DS_TYPE_STR 
1d62 77				ld (hl), a 
1d63 23				inc hl 
1d64			 
1d64				; get malloc word off stack 
1d64 d1				pop de 
1d65 73				ld (hl), e 
1d66 23				inc hl 
1d67 72				ld (hl), d 
1d68			 
1d68			 
1d68			 
1d68			if DEBUG_FORTH_PUSH 
1d68 2a f8 e9			ld hl, (cli_data_sp) 
1d6b						DMARK "PHS" 
1d6b f5				push af  
1d6c 3a 80 1d			ld a, (.dmark)  
1d6f 32 71 ee			ld (debug_mark),a  
1d72 3a 81 1d			ld a, (.dmark+1)  
1d75 32 72 ee			ld (debug_mark+1),a  
1d78 3a 82 1d			ld a, (.dmark+2)  
1d7b 32 73 ee			ld (debug_mark+2),a  
1d7e 18 03			jr .pastdmark  
1d80 ..			.dmark: db "PHS"  
1d83 f1			.pastdmark: pop af  
1d84			endm  
# End of macro DMARK
1d84				CALLMONITOR 
1d84 cd ae 15			call break_point_state  
1d87				endm  
# End of macro CALLMONITOR
1d87			;	ex de,hl 
1d87			endif	 
1d87				; in case of spaces, skip the ptr past the copied string 
1d87				;pop af 
1d87				;ld (cli_origptr),hl 
1d87			 
1d87 c9				ret 
1d88			 
1d88			 
1d88			 
1d88			; TODO ascii push input onto stack given hl to start of input 
1d88			 
1d88			; identify type 
1d88			; if starts with a " then a string 
1d88			; otherwise it is a number 
1d88			;  
1d88			; if a string 
1d88			;     scan for ending " to get length of string to malloc for + 1 
1d88			;     malloc 
1d88			;     put pointer to string on stack first byte flags as string 
1d88			; 
1d88			; else a number 
1d88			;    look for number format identifier 
1d88			;    $xx hex 
1d88			;    %xxxxx bin 
1d88			;    xxxxx decimal 
1d88			;    convert number to 16bit word.  
1d88			;    malloc word + 1 with flag to identiy as num 
1d88			;    put pointer to number on stack 
1d88			;   
1d88			;  
1d88			  
1d88			forth_apush: 
1d88				; kernel push 
1d88			 
1d88			if DEBUG_FORTH_PUSH 
1d88						DMARK "PSH" 
1d88 f5				push af  
1d89 3a 9d 1d			ld a, (.dmark)  
1d8c 32 71 ee			ld (debug_mark),a  
1d8f 3a 9e 1d			ld a, (.dmark+1)  
1d92 32 72 ee			ld (debug_mark+1),a  
1d95 3a 9f 1d			ld a, (.dmark+2)  
1d98 32 73 ee			ld (debug_mark+2),a  
1d9b 18 03			jr .pastdmark  
1d9d ..			.dmark: db "PSH"  
1da0 f1			.pastdmark: pop af  
1da1			endm  
# End of macro DMARK
1da1				CALLMONITOR 
1da1 cd ae 15			call break_point_state  
1da4				endm  
# End of macro CALLMONITOR
1da4			endif	 
1da4				; identify input type 
1da4			 
1da4 7e				ld a,(hl) 
1da5 fe 22			cp '"' 
1da7 28 0a			jr z, .fapstr 
1da9 fe 24			cp '$' 
1dab ca d3 1d			jp z, .faphex 
1dae fe 25			cp '%' 
1db0 ca bb 1d			jp z, .fapbin 
1db3			;	cp 'b' 
1db3			;	jp z, .fabin 
1db3				; else decimal 
1db3			 
1db3				; TODO do decimal conversion 
1db3				; decimal is stored as a 16bit word 
1db3			 
1db3				; by default everything is a string if type is not detected 
1db3			.fapstr: ; 
1db3 fe 22			cp '"' 
1db5 20 01			jr nz, .strnoqu 
1db7 23				inc hl 
1db8			.strnoqu: 
1db8 c3 8d 1c			jp forth_push_str 
1dbb			 
1dbb			 
1dbb			 
1dbb			.fapbin:    ; push a binary string.  
1dbb 11 00 00			ld de, 0   ; hold a 16bit value 
1dbe			 
1dbe 23			.fapbinshift:	inc hl  
1dbf 7e				ld a,(hl) 
1dc0 fe 00			cp 0     ; done scanning  
1dc2 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dc4			 
1dc4				; left shift de 
1dc4 eb				ex de, hl	 
1dc5 29				add hl, hl 
1dc6			 
1dc6				; is 1 
1dc6 fe 31			cp '1' 
1dc8 20 02			jr nz, .binzero 
1dca cb 4d			bit 1, l 
1dcc			.binzero: 
1dcc eb				ex de, hl	 ; save current de 
1dcd 18 ef			jr .fapbinshift 
1dcf			 
1dcf			.fapbdone: 
1dcf eb				ex de, hl 
1dd0 c3 1f 1c			jp forth_push_numhl 
1dd3			 
1dd3			 
1dd3			.faphex:   ; hex is always stored as a 16bit word 
1dd3				; skip number prefix 
1dd3 23				inc hl 
1dd4				; turn ascii into number 
1dd4 cd 64 11			call get_word_hl	; ret 16bit word in hl 
1dd7			 
1dd7 c3 1f 1c			jp forth_push_numhl 
1dda			 
1dda 00				 nop 
1ddb			 
1ddb			.fabin:   ; TODO bin conversion 
1ddb			 
1ddb			 
1ddb c9				ret 
1ddc			 
1ddc			 
1ddc			; get either a string ptr or a 16bit word from the data stack 
1ddc			 
1ddc			FORTH_DSP: macro 
1ddc				call macro_forth_dsp 
1ddc				endm 
1ddc			 
1ddc			macro_forth_dsp: 
1ddc				; data stack pointer points to current word on tos 
1ddc			 
1ddc 2a f8 e9			ld hl,(cli_data_sp) 
1ddf			 
1ddf				if DEBUG_FORTH_PUSH 
1ddf						DMARK "DSP" 
1ddf f5				push af  
1de0 3a f4 1d			ld a, (.dmark)  
1de3 32 71 ee			ld (debug_mark),a  
1de6 3a f5 1d			ld a, (.dmark+1)  
1de9 32 72 ee			ld (debug_mark+1),a  
1dec 3a f6 1d			ld a, (.dmark+2)  
1def 32 73 ee			ld (debug_mark+2),a  
1df2 18 03			jr .pastdmark  
1df4 ..			.dmark: db "DSP"  
1df7 f1			.pastdmark: pop af  
1df8			endm  
# End of macro DMARK
1df8			 
1df8 cd c0 4c				call display_data_sp 
1dfb				;call break_point_state 
1dfb				;rst 030h 
1dfb				CALLMONITOR 
1dfb cd ae 15			call break_point_state  
1dfe				endm  
# End of macro CALLMONITOR
1dfe				endif 
1dfe			 
1dfe c9				ret 
1dff			 
1dff			; return hl to start of value on stack 
1dff			 
1dff			FORTH_DSP_VALUE: macro 
1dff				call macro_forth_dsp_value 
1dff				endm 
1dff			 
1dff			macro_forth_dsp_value: 
1dff			 
1dff				FORTH_DSP 
1dff cd dc 1d			call macro_forth_dsp 
1e02				endm 
# End of macro FORTH_DSP
1e02			 
1e02 d5				push de 
1e03			 
1e03 23				inc hl ; skip type 
1e04			 
1e04 5e				ld e, (hl) 
1e05 23				inc hl 
1e06 56				ld d, (hl) 
1e07 eb				ex de,hl  
1e08			 
1e08 d1				pop de 
1e09			 
1e09 c9				ret 
1e0a			 
1e0a			; return hl to start of value to second item on stack 
1e0a			 
1e0a			FORTH_DSP_VALUEM1: macro 
1e0a				call macro_forth_dsp_value_m1 
1e0a				endm 
1e0a			 
1e0a			macro_forth_dsp_value_m1: 
1e0a			 
1e0a				FORTH_DSP 
1e0a cd dc 1d			call macro_forth_dsp 
1e0d				endm 
# End of macro FORTH_DSP
1e0d			 
1e0d 2b				dec hl 
1e0e 2b				dec hl 
1e0f			;	dec hl 
1e0f			 
1e0f d5				push de 
1e10			 
1e10 5e				ld e, (hl) 
1e11 23				inc hl 
1e12 56				ld d, (hl) 
1e13 eb				ex de,hl  
1e14			 
1e14 d1				pop de 
1e15			 
1e15 c9				ret 
1e16			 
1e16				 
1e16			 
1e16			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e16			 
1e16			FORTH_DSP_POP: macro 
1e16				call macro_forth_dsp_pop 
1e16				endm 
1e16			 
1e16			 
1e16			; get the tos data type 
1e16			 
1e16			FORTH_DSP_TYPE:   macro 
1e16			 
1e16				;FORTH_DSP_VALUE 
1e16				FORTH_DSP 
1e16				 
1e16				; hl points to value 
1e16				; check type 
1e16			 
1e16				ld a,(hl) 
1e16			 
1e16				endm 
1e16			 
1e16			; load the tos value into hl 
1e16			 
1e16			 
1e16			FORTH_DSP_VALUEHL:  macro 
1e16				call macro_dsp_valuehl 
1e16				endm 
1e16			 
1e16			 
1e16			 
1e16			macro_dsp_valuehl: 
1e16				FORTH_DSP_VALUE 
1e16 cd ff 1d			call macro_forth_dsp_value 
1e19				endm 
# End of macro FORTH_DSP_VALUE
1e19			 
1e19				;FORTH_ERR_TOS_NOTNUM 
1e19			 
1e19				;inc hl   ; skip type id 
1e19			 
1e19			;	push de 
1e19			; 
1e19			;	ld e, (hl) 
1e19			;	inc hl 
1e19			;	ld d, (hl) 
1e19			;	ex de,hl  
1e19			 
1e19			;	pop de 
1e19			 
1e19				if DEBUG_FORTH_PUSH 
1e19						DMARK "DVL" 
1e19 f5				push af  
1e1a 3a 2e 1e			ld a, (.dmark)  
1e1d 32 71 ee			ld (debug_mark),a  
1e20 3a 2f 1e			ld a, (.dmark+1)  
1e23 32 72 ee			ld (debug_mark+1),a  
1e26 3a 30 1e			ld a, (.dmark+2)  
1e29 32 73 ee			ld (debug_mark+2),a  
1e2c 18 03			jr .pastdmark  
1e2e ..			.dmark: db "DVL"  
1e31 f1			.pastdmark: pop af  
1e32			endm  
# End of macro DMARK
1e32				CALLMONITOR 
1e32 cd ae 15			call break_point_state  
1e35				endm  
# End of macro CALLMONITOR
1e35				endif 
1e35 c9				ret 
1e36			 
1e36			forth_apushstrhl:      
1e36				; push of string requires use of cli_origptr 
1e36				; bodge use 
1e36			 
1e36				; get current cli_origptr, save, update with temp pointer  
1e36 ed 5b 48 ea		ld de, (cli_origptr) 
1e3a 22 48 ea			ld (cli_origptr), hl 
1e3d d5				push de 
1e3e cd 88 1d			call forth_apush 
1e41 d1				pop de 
1e42 ed 53 48 ea		ld (cli_origptr), de 
1e46 c9			        ret	 
1e47			 
1e47			 
1e47			; increase loop stack pointer and save hl to it 
1e47				 
1e47			FORTH_LOOP_NEXT: macro 
1e47				call macro_forth_loop_next 
1e47				;nop 
1e47				endm 
1e47			 
1e47			macro_forth_loop_next: 
1e47				if DEBUG_FORTH_STACK_GUARD 
1e47 cd 29 61				call check_stacks 
1e4a				endif 
1e4a e5				push hl 
1e4b d5				push de 
1e4c eb				ex de,hl 
1e4d 2a fa e9			ld hl,(cli_loop_sp) 
1e50 23				inc hl 
1e51 23				inc hl 
1e52					if DEBUG_FORTH_WORDS 
1e52						DMARK "LNX" 
1e52 f5				push af  
1e53 3a 67 1e			ld a, (.dmark)  
1e56 32 71 ee			ld (debug_mark),a  
1e59 3a 68 1e			ld a, (.dmark+1)  
1e5c 32 72 ee			ld (debug_mark+1),a  
1e5f 3a 69 1e			ld a, (.dmark+2)  
1e62 32 73 ee			ld (debug_mark+2),a  
1e65 18 03			jr .pastdmark  
1e67 ..			.dmark: db "LNX"  
1e6a f1			.pastdmark: pop af  
1e6b			endm  
# End of macro DMARK
1e6b						CALLMONITOR 
1e6b cd ae 15			call break_point_state  
1e6e				endm  
# End of macro CALLMONITOR
1e6e					endif 
1e6e 22 fa e9			ld (cli_loop_sp),hl 
1e71 73				ld (hl), e 
1e72 23				inc hl 
1e73 72				ld (hl), d 
1e74 d1				pop de    ; been reversed so save a swap on restore 
1e75 e1				pop hl 
1e76				if DEBUG_FORTH_STACK_GUARD 
1e76 cd 29 61				call check_stacks 
1e79				endif 
1e79 c9				ret 
1e7a			 
1e7a			; get current ret stack pointer and save to hl  
1e7a				 
1e7a			FORTH_LOOP_TOS: macro 
1e7a				call macro_forth_loop_tos 
1e7a				endm 
1e7a			 
1e7a			macro_forth_loop_tos: 
1e7a d5				push de 
1e7b 2a fa e9			ld hl,(cli_loop_sp) 
1e7e 5e				ld e, (hl) 
1e7f 23				inc hl 
1e80 56				ld d, (hl) 
1e81 eb				ex de, hl 
1e82 d1				pop de 
1e83 c9				ret 
1e84			 
1e84			; pop loop stack pointer 
1e84				 
1e84			FORTH_LOOP_POP: macro 
1e84				call macro_forth_loop_pop 
1e84				endm 
1e84			 
1e84			 
1e84			macro_forth_loop_pop: 
1e84				if DEBUG_FORTH_STACK_GUARD 
1e84					DMARK "LPP" 
1e84 f5				push af  
1e85 3a 99 1e			ld a, (.dmark)  
1e88 32 71 ee			ld (debug_mark),a  
1e8b 3a 9a 1e			ld a, (.dmark+1)  
1e8e 32 72 ee			ld (debug_mark+1),a  
1e91 3a 9b 1e			ld a, (.dmark+2)  
1e94 32 73 ee			ld (debug_mark+2),a  
1e97 18 03			jr .pastdmark  
1e99 ..			.dmark: db "LPP"  
1e9c f1			.pastdmark: pop af  
1e9d			endm  
# End of macro DMARK
1e9d cd 29 61				call check_stacks 
1ea0					FORTH_CHK_LOOP_UNDER 
1ea0 e5				push hl 
1ea1 d5				push de 
1ea2 2a fa e9			ld hl,(cli_loop_sp) 
1ea5 11 34 e9			ld de, cli_loop_stack 
1ea8 cd cb 0d			call cmp16 
1eab da 43 62			jp c, fault_loop_under 
1eae d1				pop de 
1eaf e1				pop hl 
1eb0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1eb0				endif 
1eb0 e5				push hl 
1eb1 2a fa e9			ld hl,(cli_loop_sp) 
1eb4 2b				dec hl 
1eb5 2b				dec hl 
1eb6 22 fa e9			ld (cli_loop_sp), hl 
1eb9				; TODO do stack underflow checks 
1eb9 e1				pop hl 
1eba				if DEBUG_FORTH_STACK_GUARD 
1eba cd 29 61				call check_stacks 
1ebd					FORTH_CHK_LOOP_UNDER 
1ebd e5				push hl 
1ebe d5				push de 
1ebf 2a fa e9			ld hl,(cli_loop_sp) 
1ec2 11 34 e9			ld de, cli_loop_stack 
1ec5 cd cb 0d			call cmp16 
1ec8 da 43 62			jp c, fault_loop_under 
1ecb d1				pop de 
1ecc e1				pop hl 
1ecd				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ecd				endif 
1ecd c9				ret 
1ece			 
1ece			macro_forth_dsp_pop: 
1ece			 
1ece e5				push hl 
1ecf			 
1ecf				; release malloc data 
1ecf			 
1ecf				if DEBUG_FORTH_STACK_GUARD 
1ecf cd 29 61				call check_stacks 
1ed2					FORTH_CHK_DSP_UNDER 
1ed2 e5				push hl 
1ed3 d5				push de 
1ed4 2a f8 e9			ld hl,(cli_data_sp) 
1ed7 11 32 e8			ld de, cli_data_stack 
1eda cd cb 0d			call cmp16 
1edd da 37 62			jp c, fault_dsp_under 
1ee0 d1				pop de 
1ee1 e1				pop hl 
1ee2				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ee2				endif 
1ee2				;ld hl,(cli_data_sp) 
1ee2			if DEBUG_FORTH_DOT 
1ee2				DMARK "DPP" 
1ee2 f5				push af  
1ee3 3a f7 1e			ld a, (.dmark)  
1ee6 32 71 ee			ld (debug_mark),a  
1ee9 3a f8 1e			ld a, (.dmark+1)  
1eec 32 72 ee			ld (debug_mark+1),a  
1eef 3a f9 1e			ld a, (.dmark+2)  
1ef2 32 73 ee			ld (debug_mark+2),a  
1ef5 18 03			jr .pastdmark  
1ef7 ..			.dmark: db "DPP"  
1efa f1			.pastdmark: pop af  
1efb			endm  
# End of macro DMARK
1efb				CALLMONITOR 
1efb cd ae 15			call break_point_state  
1efe				endm  
# End of macro CALLMONITOR
1efe			endif	 
1efe			 
1efe			 
1efe			if FORTH_ENABLE_DSPPOPFREE 
1efe			 
1efe				FORTH_DSP 
1efe cd dc 1d			call macro_forth_dsp 
1f01				endm 
# End of macro FORTH_DSP
1f01			 
1f01 7e				ld a, (hl) 
1f02 fe 01			cp DS_TYPE_STR 
1f04 20 23			jr nz, .skippopfree 
1f06			 
1f06				FORTH_DSP_VALUEHL 
1f06 cd 16 1e			call macro_dsp_valuehl 
1f09				endm 
# End of macro FORTH_DSP_VALUEHL
1f09 00				nop 
1f0a			if DEBUG_FORTH_DOT 
1f0a				DMARK "DPf" 
1f0a f5				push af  
1f0b 3a 1f 1f			ld a, (.dmark)  
1f0e 32 71 ee			ld (debug_mark),a  
1f11 3a 20 1f			ld a, (.dmark+1)  
1f14 32 72 ee			ld (debug_mark+1),a  
1f17 3a 21 1f			ld a, (.dmark+2)  
1f1a 32 73 ee			ld (debug_mark+2),a  
1f1d 18 03			jr .pastdmark  
1f1f ..			.dmark: db "DPf"  
1f22 f1			.pastdmark: pop af  
1f23			endm  
# End of macro DMARK
1f23				CALLMONITOR 
1f23 cd ae 15			call break_point_state  
1f26				endm  
# End of macro CALLMONITOR
1f26			endif	 
1f26 cd 3e 13			call free 
1f29			.skippopfree: 
1f29				 
1f29			 
1f29			endif 
1f29			 
1f29			if DEBUG_FORTH_DOT_KEY 
1f29				DMARK "DP2" 
1f29				CALLMONITOR 
1f29			endif	 
1f29			 
1f29				; move pointer down 
1f29			 
1f29 2a f8 e9			ld hl,(cli_data_sp) 
1f2c 2b				dec hl 
1f2d 2b				dec hl 
1f2e			; PARSEV5 
1f2e 2b				dec hl 
1f2f 22 f8 e9			ld (cli_data_sp), hl 
1f32			 
1f32				if DEBUG_FORTH_STACK_GUARD 
1f32 cd 29 61				call check_stacks 
1f35					FORTH_CHK_DSP_UNDER 
1f35 e5				push hl 
1f36 d5				push de 
1f37 2a f8 e9			ld hl,(cli_data_sp) 
1f3a 11 32 e8			ld de, cli_data_stack 
1f3d cd cb 0d			call cmp16 
1f40 da 37 62			jp c, fault_dsp_under 
1f43 d1				pop de 
1f44 e1				pop hl 
1f45				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f45				endif 
1f45			 
1f45 e1				pop hl 
1f46			 
1f46 c9				ret 
1f47			 
1f47			getwordathl: 
1f47				; hl points to an address 
1f47				; load hl with the word at that address 
1f47			 
1f47 d5				push de 
1f48			 
1f48 5e				ld e, (hl) 
1f49 23				inc hl 
1f4a 56				ld d, (hl) 
1f4b eb				ex de, hl 
1f4c			 
1f4c d1				pop de 
1f4d c9				ret 
1f4e			 
1f4e			 
1f4e			 
1f4e			 
1f4e			 
1f4e			; eof 
1f4e			 
# End of file forth_stackopsv5.asm
1f4e			endif 
1f4e			 
1f4e			loadwordinhl:	 
1f4e			 
1f4e d5				push de 
1f4f			 
1f4f 5e				ld e, (hl) 
1f50 23				inc hl 
1f51 56				ld d, (hl) 
1f52 eb				ex de,hl  
1f53			 
1f53 d1				pop de 
1f54			 
1f54 c9				ret 
1f55			 
1f55			user_word_eol:  
1f55				; hl contains the pointer to where to create a linked list item from the end 
1f55				; of the user dict to continue on at the system word dict 
1f55				 
1f55				; poke the stub of the word list linked list to repoint to rom words 
1f55			 
1f55				; stub format 
1f55				; db   word id 
1f55				; dw    link to next word 
1f55			        ; db char length of token 
1f55				; db string + 0 term 
1f55				; db exec code....  
1f55			 
1f55 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f57 77				ld (hl), a		; word id 
1f58 23				inc hl 
1f59			 
1f59 11 24 21			ld de, sysdict 
1f5c 73				ld (hl), e		; next word link ie system dict 
1f5d 23				inc hl 
1f5e 72				ld (hl), d		; next word link ie system dict 
1f5f 23				inc hl	 
1f60			 
1f60			;	ld (hl), sysdict		; next word link ie system dict 
1f60			;	inc hl 
1f60			;	inc hl 
1f60			 
1f60			;	inc hl 
1f60			;	inc hl 
1f60			 
1f60 3e 02			ld a, 2			; word length is 0 
1f62 77				ld (hl), a	 
1f63 23				inc hl 
1f64			 
1f64 3e 7e			ld a, '~'			; word length is 0 
1f66 77				ld (hl), a	 
1f67 23				inc hl 
1f68 3e 00			ld a, 0			; save empty word 
1f6a 77				ld (hl), a 
1f6b			 
1f6b c9				ret 
1f6c			 
1f6c				 
1f6c			 
1f6c			forthexec_cleanup: 
1f6c				FORTH_RSP_POP 
1f6c cd e7 1b			call macro_forth_rsp_pop 
1f6f				endm 
# End of macro FORTH_RSP_POP
1f6f c9				ret 
1f70			 
1f70			forth_call_hl: 
1f70				; taking hl 
1f70 e5				push hl 
1f71 c9				ret 
1f72			 
1f72			; this is called to reset Forth system but keep existing uwords etc 
1f72			 
1f72			forth_warmstart: 
1f72				; setup stack over/under flow checks 
1f72				if DEBUG_FORTH_STACK_GUARD 
1f72 cd 0f 61				call chk_stk_init 
1f75				endif 
1f75			 
1f75				; init stack pointers  - * these stacks go upwards *  
1f75 21 b6 e9			ld hl, cli_ret_stack 
1f78 22 fc e9			ld (cli_ret_sp), hl	 
1f7b				; set bottom of stack 
1f7b 3e 00			ld a,0 
1f7d 77				ld (hl),a 
1f7e 23				inc hl 
1f7f 77				ld (hl),a 
1f80			 
1f80 21 32 e8			ld hl, cli_data_stack 
1f83 22 f8 e9			ld (cli_data_sp), hl	 
1f86				; set bottom of stack 
1f86 3e 00			ld a,0 
1f88 77				ld (hl),a 
1f89 23				inc hl 
1f8a 77				ld (hl),a 
1f8b			 
1f8b 21 34 e9			ld hl, cli_loop_stack 
1f8e 22 fa e9			ld (cli_loop_sp), hl	 
1f91				; set bottom of stack 
1f91 3e 00			ld a,0 
1f93 77				ld (hl),a 
1f94 23				inc hl 
1f95 77				ld (hl),a 
1f96			 
1f96				; init extent of current open file 
1f96			 
1f96 3e 00			ld a, 0 
1f98 32 74 ea			ld (store_openext), a 
1f9b			 
1f9b c9				ret 
1f9c			 
1f9c			 
1f9c			; Cold Start - this is called to setup the whole Forth system 
1f9c			 
1f9c			forth_init: 
1f9c			 
1f9c				; setup stack over/under flow checks 
1f9c			 
1f9c			;	if DEBUG_FORTH_STACK_GUARD 
1f9c			;		call chk_stk_init 
1f9c			;	endif 
1f9c			 
1f9c				; enable auto display updates (slow.....) 
1f9c			 
1f9c 3e 01			ld a, 1 
1f9e 32 46 ea			ld (cli_autodisplay), a 
1fa1			 
1fa1				; if storage is in use disable long reads for now 
1fa1 3e 00			ld a, 0 
1fa3 32 7f ea			ld (store_longread), a 
1fa6			 
1fa6			 
1fa6				; show start up screen 
1fa6			 
1fa6 cd 80 0b			call clear_display 
1fa9			 
1fa9 3e 00			ld a,0 
1fab 32 68 ea			ld (f_cursor_ptr), a 
1fae			 
1fae				; set start of word list in start of ram - for use when creating user words 
1fae			 
1fae 21 32 64			ld hl, baseram 
1fb1 22 c8 e5			ld (os_last_new_uword), hl 
1fb4 cd 55 1f			call user_word_eol 
1fb7				 
1fb7			;		call display_data_sp 
1fb7			;		call next_page_prompt 
1fb7			 
1fb7			 
1fb7			 
1fb7			 
1fb7 c9				ret 
1fb8			 
1fb8 .. 00		.bootforth: db " Forth Kernel Init ",0 
1fcc			 
1fcc			; TODO push to stack 
1fcc			 
1fcc			;  
1fcc			 
1fcc			if FORTH_PARSEV2 
1fcc			 
1fcc			 
1fcc				include "forth_parserv2.asm" 
1fcc			 
1fcc			endif 
1fcc			 
1fcc			 
1fcc			; parse cli version 1 
1fcc			 
1fcc			if FORTH_PARSEV1 
1fcc			 
1fcc			 
1fcc			 
1fcc			      include "forth_parserv1.asm" 
1fcc			endif 
1fcc				 
1fcc			if FORTH_PARSEV3 
1fcc			 
1fcc			 
1fcc			 
1fcc			      include "forth_parserv3.asm" 
1fcc				include "forth_wordsv3.asm" 
1fcc			endif 
1fcc			 
1fcc			if FORTH_PARSEV4 
1fcc			 
1fcc			 
1fcc			 
1fcc			      include "forth_parserv4.asm" 
1fcc				include "forth_wordsv4.asm" 
1fcc			endif 
1fcc			 
1fcc			if FORTH_PARSEV5 
1fcc			 
1fcc			 
1fcc			 
1fcc			      include "forth_parserv5.asm" 
1fcc			 
1fcc			 
1fcc			; A better parser without using malloc and string copies all over the place.  
1fcc			; Exec in situ should be faster 
1fcc			 
1fcc			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1fcc			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1fcc			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1fcc			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1fcc			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1fcc			WORD_SYS_END: equ 0   ; Opcode for all user words 
1fcc			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1fcc			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1fcc			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1fcc			 
1fcc			; Core word preamble macro 
1fcc			 
1fcc			CWHEAD:   macro nxtword opcode lit len opflags 
1fcc				db WORD_SYS_CORE+opcode             
1fcc				; internal op code number 
1fcc				dw nxtword            
1fcc				; link to next dict word block 
1fcc				db len + 1 
1fcc				; literal length of dict word inc zero term 
1fcc				db lit,0              
1fcc				; literal dict word 
1fcc			        ; TODO db opflags        
1fcc				endm 
1fcc			 
1fcc			 
1fcc			NEXTW: macro  
1fcc				jp macro_next 
1fcc				endm 
1fcc			 
1fcc			macro_next: 
1fcc			if DEBUG_FORTH_PARSE_KEY 
1fcc				DMARK "NXT" 
1fcc				CALLMONITOR 
1fcc			endif	 
1fcc			;	inc hl  ; skip token null term  
1fcc ed 4b 4a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1fd0 ed 5b 48 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1fd4 2a cc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1fd7			if DEBUG_FORTH_PARSE_KEY 
1fd7				DMARK "}AA" 
1fd7				CALLMONITOR 
1fd7			endif	 
1fd7 c3 da 20			jp execnext 
1fda				;jp exec1 
1fda			       
1fda			 
1fda			 
1fda			; Another go at the parser to compile  
1fda			 
1fda			 
1fda			; TODO rework parser to change all of the string words to byte tokens 
1fda			; TODO do a search for  
1fda			 
1fda			; TODO first run normal parser to zero term sections 
1fda			; TODO for each word do a token look up to get the op code 
1fda			; TODO need some means to flag to the exec that this is a byte code form    
1fda			 
1fda			 
1fda			forthcompile: 
1fda			 
1fda			; 
1fda			; line parse: 
1fda			;       parse raw input buffer 
1fda			;       tokenise the words 
1fda			;       malloc new copy (for looping etc) 
1fda			;       copy to malloc + current pc in line to start of string and add line term 
1fda			;       save on new rsp 
1fda			; 
1fda			 
1fda			; hl to point to the line to tokenise 
1fda			 
1fda			;	push hl 
1fda 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1fdd			 
1fdd			;	ld a,0		; string term on input 
1fdd			;	call strlent 
1fdd			 
1fdd			;	ld (os_tok_len), hl	 ; save string length 
1fdd			 
1fdd			;if DEBUG_FORTH_TOK 
1fdd			;	ex de,hl		 
1fdd			;endif 
1fdd			 
1fdd			;	pop hl 		; get back string pointer 
1fdd			 
1fdd			if DEBUG_FORTH_TOK 
1fdd						DMARK "TOc" 
1fdd				CALLMONITOR 
1fdd			endif 
1fdd 7e			.cptoken2:    ld a,(hl) 
1fde 23				inc hl 
1fdf fe 7f			cp FORTH_END_BUFFER 
1fe1 28 29			jr z, .cptokendone2 
1fe3 fe 00			cp 0 
1fe5 28 25			jr z, .cptokendone2 
1fe7 fe 22			cp '"' 
1fe9 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1feb fe 20			cp ' ' 
1fed 20 ee			jr nz,  .cptoken2 
1fef			 
1fef			; TODO consume comments held between ( and ) 
1fef			 
1fef				; we have a space so change to zero term for dict match later 
1fef 2b				dec hl 
1ff0 3e 00			ld a,0 
1ff2 77				ld (hl), a 
1ff3 23				inc hl 
1ff4 18 e7			jr .cptoken2 
1ff6				 
1ff6			 
1ff6			.cptokenstr2: 
1ff6				; skip all white space until either eol (because forgot to term) or end double quote 
1ff6			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ff6				;inc hl ; skip current double quote 
1ff6 7e				ld a,(hl) 
1ff7 23				inc hl 
1ff8 fe 22			cp '"' 
1ffa 28 e1			jr z, .cptoken2 
1ffc fe 7f			cp FORTH_END_BUFFER 
1ffe 28 0c			jr z, .cptokendone2 
2000 fe 00			cp 0 
2002 28 08			jr z, .cptokendone2 
2004 fe 20			cp ' ' 
2006 28 02			jr z, .cptmp2 
2008 18 ec			jr .cptokenstr2 
200a			 
200a			.cptmp2:	; we have a space so change to zero term for dict match later 
200a				;dec hl 
200a				;ld a,"-"	; TODO remove this when working 
200a				;ld (hl), a 
200a				;inc hl 
200a 18 ea			jr .cptokenstr2 
200c			 
200c			.cptokendone2: 
200c				;inc hl 
200c 3e 7f			ld a, FORTH_END_BUFFER 
200e 77				ld (hl),a 
200f 23				inc hl 
2010 3e 21			ld a, '!' 
2012 77				ld (hl),a 
2013			 
2013 2a cc e5			ld hl,(os_tok_ptr) 
2016			         
2016			if DEBUG_FORTH_TOK 
2016						DMARK "Tc1" 
2016				CALLMONITOR 
2016			endif 
2016			 
2016				; push exec string to top of return stack 
2016				FORTH_RSP_NEXT 
2016 cd c6 1b			call macro_forth_rsp_next 
2019				endm 
# End of macro FORTH_RSP_NEXT
2019 c9				ret 
201a			 
201a			; Another go at the parser need to simplify the process 
201a			 
201a			forthparse: 
201a			 
201a			; 
201a			; line parse: 
201a			;       parse raw input buffer 
201a			;       tokenise the words 
201a			;       malloc new copy (for looping etc) 
201a			;       copy to malloc + current pc in line to start of string and add line term 
201a			;       save on new rsp 
201a			; 
201a			 
201a			; hl to point to the line to tokenise 
201a			 
201a			;	push hl 
201a 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
201d			 
201d			;	ld a,0		; string term on input 
201d			;	call strlent 
201d			 
201d			;	ld (os_tok_len), hl	 ; save string length 
201d			 
201d			;if DEBUG_FORTH_TOK 
201d			;	ex de,hl		 
201d			;endif 
201d			 
201d			;	pop hl 		; get back string pointer 
201d			 
201d			if DEBUG_FORTH_TOK 
201d						DMARK "TOK" 
201d				CALLMONITOR 
201d			endif 
201d 7e			.ptoken2:    ld a,(hl) 
201e 23				inc hl 
201f fe 7f			cp FORTH_END_BUFFER 
2021 28 29			jr z, .ptokendone2 
2023 fe 00			cp 0 
2025 28 25			jr z, .ptokendone2 
2027 fe 22			cp '"' 
2029 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
202b fe 20			cp ' ' 
202d 20 ee			jr nz,  .ptoken2 
202f			 
202f			; TODO consume comments held between ( and ) 
202f			 
202f				; we have a space so change to zero term for dict match later 
202f 2b				dec hl 
2030 3e 00			ld a,0 
2032 77				ld (hl), a 
2033 23				inc hl 
2034 18 e7			jr .ptoken2 
2036				 
2036			 
2036			.ptokenstr2: 
2036				; skip all white space until either eol (because forgot to term) or end double quote 
2036			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2036				;inc hl ; skip current double quote 
2036 7e				ld a,(hl) 
2037 23				inc hl 
2038 fe 22			cp '"' 
203a 28 e1			jr z, .ptoken2 
203c fe 7f			cp FORTH_END_BUFFER 
203e 28 0c			jr z, .ptokendone2 
2040 fe 00			cp 0 
2042 28 08			jr z, .ptokendone2 
2044 fe 20			cp ' ' 
2046 28 02			jr z, .ptmp2 
2048 18 ec			jr .ptokenstr2 
204a			 
204a			.ptmp2:	; we have a space so change to zero term for dict match later 
204a				;dec hl 
204a				;ld a,"-"	; TODO remove this when working 
204a				;ld (hl), a 
204a				;inc hl 
204a 18 ea			jr .ptokenstr2 
204c			 
204c			.ptokendone2: 
204c				;inc hl 
204c 3e 7f			ld a, FORTH_END_BUFFER 
204e 77				ld (hl),a 
204f 23				inc hl 
2050 3e 21			ld a, '!' 
2052 77				ld (hl),a 
2053			 
2053 2a cc e5			ld hl,(os_tok_ptr) 
2056			         
2056			if DEBUG_FORTH_TOK 
2056						DMARK "TK1" 
2056				CALLMONITOR 
2056			endif 
2056			 
2056				; push exec string to top of return stack 
2056				FORTH_RSP_NEXT 
2056 cd c6 1b			call macro_forth_rsp_next 
2059				endm 
# End of macro FORTH_RSP_NEXT
2059 c9				ret 
205a			 
205a			; 
205a			;	; malloc size + buffer pointer + if is loop flag 
205a			;	ld hl,(os_tok_len) 		 ; get string length 
205a			; 
205a			;	ld a,l 
205a			; 
205a			;	cp 0			; we dont want to use a null string 
205a			;	ret z 
205a			; 
205a			;;	add 3    ; prefix malloc with buffer for current word ptr 
205a			; 
205a			;	add 5     ; TODO when certain not over writing memory remove 
205a			; 
205a			;		 
205a			; 
205a			;if DEBUG_FORTH_TOK 
205a			;			DMARK "TKE" 
205a			;	CALLMONITOR 
205a			;endif 
205a			; 
205a			;	ld l,a 
205a			;	ld h,0 
205a			;;	push hl   ; save required space for the copy later 
205a			;	call malloc 
205a			;if DEBUG_FORTH_TOK 
205a			;			DMARK "TKM" 
205a			;	CALLMONITOR 
205a			;endif 
205a			;	if DEBUG_FORTH_MALLOC_GUARD 
205a			;		push af 
205a			;		call ishlzero 
205a			;;		ld a, l 
205a			;;		add h 
205a			;;		cp 0 
205a			;		pop af 
205a			;		 
205a			;		call z,malloc_error 
205a			;	endif 
205a			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
205a			; 
205a			; 
205a			;if DEBUG_FORTH_TOK 
205a			;			DMARK "TKR" 
205a			;	CALLMONITOR 
205a			;endif 
205a			; 
205a			;	FORTH_RSP_NEXT 
205a			; 
205a			;	;inc hl	 ; go past current buffer pointer 
205a			;	;inc hl 
205a			;	;inc hl   ; and past if loop flag 
205a			;		; TODO Need to set flag  
205a			; 
205a			;	 
205a			;	 
205a			;	ex de,hl	; malloc is dest 
205a			;	ld hl, (os_tok_len) 
205a			;;	pop bc 
205a			;	ld c, l                
205a			;	ld b,0 
205a			;	ld hl, (os_tok_ptr) 
205a			; 
205a			;if DEBUG_FORTH_TOK 
205a			;			DMARK "TKT" 
205a			;	CALLMONITOR 
205a			;endif 
205a			; 
205a			;	; do str cpy 
205a			; 
205a			;	ldir      ; copy byte in hl to de 
205a			; 
205a			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
205a			; 
205a			;if DEBUG_FORTH_TOK 
205a			; 
205a			;			DMARK "TKY" 
205a			;	CALLMONITOR 
205a			;endif 
205a			;	;ld a,0 
205a			;	;ld a,FORTH_END_BUFFER 
205a			;	ex de, hl 
205a			;	;dec hl			 ; go back over the space delim at the end of word 
205a			;	;ld (hl),a 
205a			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
205a			;	ld a,FORTH_END_BUFFER 
205a			;	ld (hl),a 
205a			;	inc hl 
205a			;	ld a,FORTH_END_BUFFER 
205a			;	ld (hl),a 
205a			; 
205a			;	; init the malloc area data 
205a			;	; set pc for in current area 
205a			;	;ld hl, (os_tok_malloc) 
205a			;	;inc hl 
205a			;	;inc hl 
205a			;	;inc hl 
205a			;	;ex de,hl 
205a			;	;ld hl, (os_tok_malloc) 
205a			;	;ld (hl),e 
205a			;	;inc hl 
205a			;	;ld (hl),d 
205a			; 
205a			; 
205a			;	ld hl,(os_tok_malloc) 
205a			;if DEBUG_FORTH_PARSE_KEY 
205a			;			DMARK "TKU" 
205a			;	CALLMONITOR 
205a			;endif 
205a			; 
205a			;	ret 
205a			 
205a			forthexec: 
205a			 
205a			; line exec: 
205a			; forth parser 
205a			 
205a			; 
205a			;       get current exec line on rsp 
205a			 
205a				FORTH_RSP_TOS 
205a cd dd 1b			call macro_forth_rsp_tos 
205d				endm 
# End of macro FORTH_RSP_TOS
205d			 
205d			;       restore current pc - hl points to malloc of data 
205d			 
205d				;ld e, (hl) 
205d				;inc hl 
205d				;ld d, (hl) 
205d				;ex de,hl 
205d			 
205d			 
205d			exec1: 
205d 22 cc e5			ld (os_tok_ptr), hl 
2060			 
2060				; copy our PC to working vars  
2060 22 4a ea			ld (cli_ptr), hl 
2063 22 48 ea			ld (cli_origptr), hl 
2066			 
2066 7e				ld a,(hl) 
2067 fe 7f			cp FORTH_END_BUFFER 
2069 c8				ret z 
206a			 
206a				; skip any nulls 
206a			 
206a fe 00			cp 0 
206c 20 03			jr nz, .execword 
206e 23				inc hl 
206f 18 ec			jr exec1 
2071			 
2071			 
2071			.execword: 
2071			 
2071			 
2071			 
2071			if DEBUG_FORTH_PARSE_KEY 
2071						DMARK "KYQ" 
2071				CALLMONITOR 
2071			endif 
2071			;       while at start of word: 
2071			; get start of dict (in user area first) 
2071			 
2071 21 32 64		ld hl, baseram 
2074			;ld hl, sysdict 
2074 22 4c ea		ld (cli_nextword),hl 
2077			;           match word at pc 
2077			;           exec word 
2077			;           or push to dsp 
2077			;           forward to next token 
2077			;           if line term pop rsp and exit 
2077			;        
2077			 
2077			if DEBUG_FORTH_PARSE_KEY 
2077						DMARK "KYq" 
2077				CALLMONITOR 
2077			endif 
2077			 
2077			; 
2077			; word comp 
2077			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2077			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2077			;    move to start of word  
2077			;    compare word to cli_token 
2077			 
2077			.execpnword:	; HL at start of a word in the dictionary to check 
2077			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2077			;	ld (cli_ptr), hl 
2077			 
2077 2a 4c ea			ld hl,(cli_nextword) 
207a			 
207a cd 1d 21			call forth_tok_next 
207d			; tok next start here 
207d			;	; TODO skip compiled symbol for now 
207d			;	inc hl 
207d			; 
207d			;	; save pointer to next word 
207d			; 
207d			;	; hl now points to the address of the next word pointer  
207d			;	ld e, (hl) 
207d			;	inc hl 
207d			;	ld d, (hl) 
207d			;	inc l 
207d			; 
207d			;	ex de,hl 
207d			;if DEBUG_FORTH_PARSE_NEXTWORD 
207d			;	push bc 
207d			;	ld bc, (cli_nextword) 
207d			;			DMARK "NXW" 
207d			;	CALLMONITOR 
207d			;	pop bc 
207d			;endif 
207d			; tok next end here 
207d 22 4c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
2080 eb				ex de, hl 
2081			 
2081			 
2081				; save the pointer of the current token - 1 to check against 
2081				 
2081 22 50 ea			ld (cli_token), hl   
2084				; TODO maybe remove below save if no debug 
2084				; save token string ptr for any debug later 
2084 23				inc hl  
2085 22 52 ea			ld (cli_origtoken), hl 
2088 2b				dec hl 
2089				; save pointer to the start of the next dictionay word 
2089 7e				ld a,(hl)   ; get string length 
208a 47				ld b,a 
208b			.execpnwordinc:  
208b 23				inc hl 
208c 10 fd			djnz .execpnwordinc 
208e 22 4e ea			ld (cli_execword), hl      ; save start of this words code 
2091			 
2091				; now check the word token against the string being parsed 
2091			 
2091 2a 50 ea			ld hl,(cli_token) 
2094 23				inc hl     ; skip string length (use zero term instead to end) 
2095 22 50 ea			ld (cli_token), hl 
2098			 
2098			if DEBUG_FORTH_PARSE_KEY 
2098						DMARK "KY2" 
2098			endif 
2098			if DEBUG_FORTH_PARSE_EXEC 
2098				; see if disabled 
2098			 
2098				ld a, (os_view_disable) 
2098				cp '*' 
2098				jr z, .skip 
2098			 
2098				push hl 
2098				push hl 
2098				call clear_display 
2098				ld de, .compword 
2098				ld a, display_row_1 
2098				call str_at_display 
2098				pop de 
2098				ld a, display_row_2 
2098				call str_at_display 
2098				ld hl,(cli_ptr) 
2098				ld a,(hl) 
2098			        ld hl, os_word_scratch 
2098				ld (hl),a 
2098				ld a,0 
2098				inc hl 
2098				ld (hl),a 	 
2098				ld de, os_word_scratch 
2098				ld a, display_row_2+10 
2098				call str_at_display 
2098				call update_display 
2098				ld a, 100 
2098				call aDelayInMS 
2098				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2098				call delay250ms 
2098				endif 
2098				pop hl 
2098			.skip:  
2098			endif	 
2098			.execpnchar:    ; compare char between token and string to parse 
2098			 
2098			if DEBUG_FORTH_PARSE_KEY 
2098						DMARK "Ky3" 
2098			endif 
2098			if DEBUG_FORTH_PARSE_EXEC 
2098				; see if disabled 
2098			 
2098				ld a, (os_view_disable) 
2098				cp '*' 
2098				jr z, .skip2 
2098			 
2098			;	call clear_display 
2098			ld hl,(cli_token) 
2098			ld a,(hl) 
2098			ld (os_word_scratch),a 
2098				ld hl,(cli_ptr) 
2098			ld a,(hl) 
2098				ld (os_word_scratch+1),a 
2098				ld a,0 
2098				ld (os_word_scratch+2),a 
2098				ld de,os_word_scratch 
2098				ld a,display_row_4 
2098				call str_at_display 
2098				call update_display 
2098			.skip2:  
2098			endif 
2098 2a 50 ea			ld hl,(cli_token) 
209b 7e				ld a, (hl)	 ; char in word token 
209c 23				inc hl 		; move to next char 
209d 22 50 ea			ld (cli_token), hl ; and save it 
20a0 47				ld b,a 
20a1			 
20a1 2a 4a ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20a4 7e				ld a,(hl) 
20a5 23				inc hl 
20a6 22 4a ea			ld (cli_ptr), hl		; move to next char 
20a9 cd 02 12			call toUpper 		; make sure the input string matches case 
20ac			 
20ac			if DEBUG_FORTH_PARSE 
20ac			endif 
20ac			 
20ac				; input stream end of token is a space so get rid of it 
20ac			 
20ac			;	cp ' ' 
20ac			;	jr nz, .pnskipspace 
20ac			; 
20ac			;	ld a, 0		; make same term as word token term 
20ac			; 
20ac			;.pnskipspace: 
20ac			 
20ac			if DEBUG_FORTH_PARSE_KEY 
20ac						DMARK "KY7" 
20ac			endif 
20ac b8				cp b 
20ad c2 c3 20			jp nz, .execpnskipword	 ; no match so move to next word 
20b0				 
20b0			;    if same 
20b0			;       scan for string terms 0 for token and 32 for input 
20b0			 
20b0				 
20b0			if DEBUG_FORTH_PARSE_KEY 
20b0						DMARK "KY8" 
20b0			endif 
20b0			 
20b0 80				add b			 
20b1 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20b3							; TODO need to make sure last word in zero term string is accounted for 
20b3 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20b5			 
20b5			 
20b5				; at end of both strings so both are exact match 
20b5			 
20b5			;       skip ptr for next word 
20b5			 
20b5 2a 4a ea			ld hl,(cli_ptr) 	; at input string term 
20b8 23				inc hl			 ; at next char 
20b9 22 4a ea			ld (cli_ptr), hl     ; save for next round of the parser 
20bc 22 48 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20bf				 
20bf				 
20bf			if DEBUG_FORTH_PARSE_KEY 
20bf						DMARK "KY3" 
20bf			endif 
20bf			 
20bf			 
20bf			 
20bf			;       exec code block 
20bf			if DEBUG_FORTH_JP 
20bf				call clear_display 
20bf				call update_display 
20bf				call delay1s 
20bf				ld hl, (cli_execword)     ; save for next check if no match on this word 
20bf				ld a,h 
20bf				ld hl, os_word_scratch 
20bf				call hexout 
20bf				ld hl, (cli_execword)     ; save for next check if no match on this word 
20bf				ld a,l 
20bf				ld hl, os_word_scratch+2 
20bf				call hexout 
20bf				ld hl, os_word_scratch+4 
20bf				ld a,0 
20bf				ld (hl),a 
20bf				ld de,os_word_scratch 
20bf				call str_at_display 
20bf					ld a, display_row_2 
20bf					call str_at_display 
20bf				ld de, (cli_origtoken) 
20bf				ld a, display_row_1+10 
20bf					call str_at_display 
20bf			 
20bf				ld a,display_row_1 
20bf				ld de, .foundword 
20bf				ld a, display_row_3 
20bf				call str_at_display 
20bf				call update_display 
20bf				call delay1s 
20bf				call delay1s 
20bf				call delay1s 
20bf			endif 
20bf			 
20bf			if DEBUG_FORTH_PARSE_KEY 
20bf						DMARK "KYj" 
20bf			endif 
20bf				; TODO save the word pointer in this exec 
20bf			 
20bf 2a 4e ea			ld hl,(cli_execword) 
20c2 e9				jp (hl) 
20c3			 
20c3			 
20c3			;    if not same 
20c3			;	scan for zero term 
20c3			;	get ptr for next word 
20c3			;	goto word comp 
20c3			 
20c3			.execpnskipword:	; get pointer to next word 
20c3 2a 4c ea			ld hl,(cli_nextword) 
20c6			 
20c6 7e				ld a,(hl) 
20c7 fe 00			cp WORD_SYS_END 
20c9			;	cp 0 
20c9 28 09			jr z, .execendofdict			 ; at end of words 
20cb			 
20cb			if DEBUG_FORTH_PARSE_KEY 
20cb						DMARK "KY4" 
20cb			endif 
20cb			if DEBUG_FORTH_PARSE_EXEC 
20cb			 
20cb				; see if disabled 
20cb			 
20cb				ld a, (os_view_disable) 
20cb				cp '*' 
20cb				jr z, .noskip 
20cb			 
20cb			 
20cb				ld de, .nowordfound 
20cb				ld a, display_row_3 
20cb				call str_at_display 
20cb				call update_display 
20cb				ld a, 100 
20cb				call aDelayInMS 
20cb				 
20cb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20cb					call delay250ms 
20cb				endif 
20cb			.noskip:  
20cb			 
20cb			endif	 
20cb			 
20cb 2a 48 ea			ld hl,(cli_origptr) 
20ce 22 4a ea			ld (cli_ptr),hl 
20d1			 
20d1			if DEBUG_FORTH_PARSE_KEY 
20d1						DMARK "KY5" 
20d1			endif 
20d1 c3 77 20			jp .execpnword			; else go to next word 
20d4			 
20d4			.execendofdict:  
20d4			 
20d4			if DEBUG_FORTH_PARSE_KEY 
20d4						DMARK "KYe" 
20d4			endif 
20d4			if DEBUG_FORTH_PARSE_EXEC 
20d4				; see if disabled 
20d4			 
20d4				ld a, (os_view_disable) 
20d4				cp '*' 
20d4				jr z, .ispskip 
20d4			 
20d4				call clear_display 
20d4				call update_display 
20d4				call delay1s 
20d4				ld de, (cli_origptr) 
20d4				ld a, display_row_1 
20d4				call str_at_display 
20d4				 
20d4				ld de, .enddict 
20d4				ld a, display_row_3 
20d4				call str_at_display 
20d4				call update_display 
20d4				ld a, 100 
20d4				call aDelayInMS 
20d4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20d4				call delay1s 
20d4				call delay1s 
20d4				call delay1s 
20d4				endif 
20d4			.ispskip:  
20d4				 
20d4			endif	 
20d4			 
20d4			 
20d4			 
20d4				; if the word is not a keyword then must be a literal so push it to stack 
20d4			 
20d4			; push token to stack to end of word 
20d4			 
20d4				STACKFRAME ON $1efe $2f9f 
20d4				if DEBUG_STACK_IMB 
20d4					if ON 
20d4						exx 
20d4						ld de, $1efe 
20d4						ld a, d 
20d4						ld hl, curframe 
20d4						call hexout 
20d4						ld a, e 
20d4						ld hl, curframe+2 
20d4						call hexout 
20d4						ld hl, $1efe 
20d4						push hl 
20d4						ld hl, $2f9f 
20d4						push hl 
20d4						exx 
20d4					endif 
20d4				endif 
20d4			endm 
# End of macro STACKFRAME
20d4			 
20d4 2a cc e5		ld hl,(os_tok_ptr) 
20d7 cd 88 1d		call forth_apush 
20da			 
20da				STACKFRAMECHK ON $1efe $2f9f 
20da				if DEBUG_STACK_IMB 
20da					if ON 
20da						exx 
20da						ld hl, $2f9f 
20da						pop de   ; $2f9f 
20da						call cmp16 
20da						jr nz, .spnosame 
20da						ld hl, $1efe 
20da						pop de   ; $1efe 
20da						call cmp16 
20da						jr z, .spfrsame 
20da						.spnosame: call showsperror 
20da						.spfrsame: nop 
20da						exx 
20da					endif 
20da				endif 
20da			endm 
# End of macro STACKFRAMECHK
20da			 
20da			execnext: 
20da			 
20da			if DEBUG_FORTH_PARSE_KEY 
20da						DMARK "KY>" 
20da			endif 
20da			; move past token to next word 
20da			 
20da 2a cc e5		ld hl, (os_tok_ptr) 
20dd 3e 00		ld a, 0 
20df 01 ff 00		ld bc, 255     ; input buffer size 
20e2 ed b1		cpir 
20e4			 
20e4			if DEBUG_FORTH_PARSE_KEY 
20e4						DMARK "KY!" 
20e4				CALLMONITOR 
20e4			endif	 
20e4			; TODO this might place hl on the null, so will need to forward on??? 
20e4			;inc hl   ; see if this gets onto the next item 
20e4			 
20e4			 
20e4			; TODO pass a pointer to the buffer to push 
20e4			; TODO call function to push 
20e4			 
20e4			; look for end of input 
20e4			 
20e4			;inc hl 
20e4			;ld a,(hl) 
20e4			;cp FORTH_END_BUFFER 
20e4			;ret z 
20e4			 
20e4			 
20e4 c3 5d 20		jp exec1 
20e7			 
20e7			 
20e7			 
20e7			 
20e7			 
20e7			 
20e7			 
20e7			 
20e7			 
20e7			findnexttok: 
20e7			 
20e7				; hl is pointer to move 
20e7				; de is the token to locate 
20e7			 
20e7					if DEBUG_FORTH 
20e7						DMARK "NTK" 
20e7						CALLMONITOR 
20e7					endif 
20e7 d5				push de 
20e8			 
20e8			.fnt1:	 
20e8				; find first char of token to locate 
20e8			 
20e8 1a				ld a, (de) 
20e9 4f				ld c,a 
20ea 7e				ld a,(hl) 
20eb cd 02 12			call toUpper 
20ee					if DEBUG_FORTH 
20ee						DMARK "NT1" 
20ee						CALLMONITOR 
20ee					endif 
20ee b9				cp c 
20ef			 
20ef 28 03			jr z, .fnt2cmpmorefirst	 
20f1			 
20f1				; first char not found move to next char 
20f1			 
20f1 23				inc hl 
20f2 18 f4			jr .fnt1 
20f4			 
20f4			.fnt2cmpmorefirst:	 
20f4				; first char of token found.  
20f4			 
20f4 e5				push hl     ; save start of token just in case it is the right one 
20f5 d9				exx 
20f6 e1				pop hl        ; save it to hl' 
20f7 d9				exx 
20f8			 
20f8			 
20f8			.fnt2cmpmore:	 
20f8				; compare the rest 
20f8				 
20f8 23				inc hl 
20f9 13				inc de 
20fa				 
20fa 1a				ld a, (de) 
20fb 4f				ld c,a 
20fc 7e				ld a,(hl) 
20fd cd 02 12			call toUpper 
2100			 
2100					if DEBUG_FORTH 
2100						DMARK "NT2" 
2100						CALLMONITOR 
2100					endif 
2100				; c has the token to find char 
2100				; a has the mem to scan char 
2100			 
2100 b9				cp c 
2101 28 04			jr z,.fntmatch1 
2103			 
2103				; they are not the same 
2103			 
2103					if DEBUG_FORTH 
2103						DMARK "NT3" 
2103						CALLMONITOR 
2103					endif 
2103 d1				pop de	; reset de token to look for 
2104 d5				push de 
2105 18 e1			jr .fnt1 
2107				 
2107			.fntmatch1: 
2107			 
2107				; is the same char a null which means we might have a full hit? 
2107					if DEBUG_FORTH 
2107						DMARK "NT4" 
2107						CALLMONITOR 
2107					endif 
2107			 
2107 fe 00			cp 0 
2109 28 0b			jr z, .fntmatchyes 
210b			 
210b				; are we at the end of the token to find? 
210b			 
210b					if DEBUG_FORTH 
210b						DMARK "NT5" 
210b						CALLMONITOR 
210b					endif 
210b 3e 00			ld a, 0 
210d b9				cp c 
210e			 
210e c2 f8 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2111			 
2111					if DEBUG_FORTH 
2111						DMARK "NT6" 
2111						CALLMONITOR 
2111					endif 
2111				; token to find is exhusted but no match to stream 
2111			 
2111				; restore tok pointer and continue on 
2111 d1				pop de 
2112 d5				push de 
2113 c3 e8 20			jp .fnt1 
2116			 
2116			 
2116			.fntmatchyes: 
2116			 
2116				; hl now contains the end of the found token 
2116			 
2116				; get rid of saved token pointer to find 
2116			 
2116 d1				pop de 
2117			 
2117					if DEBUG_FORTH 
2117						DMARK "NT9" 
2117						CALLMONITOR 
2117					endif 
2117			 
2117				; hl will be on the null term so forward on 
2117			 
2117				; get back the saved start of the token 
2117			 
2117 d9				exx 
2118 e5				push hl     ; save start of token just in case it is the right one 
2119 d9				exx 
211a e1				pop hl        ; save it to hl 
211b			 
211b c9				ret 
211c			 
211c			 
211c			; LIST needs to find a specific token   
211c			; FORGET needs to find a spefici token 
211c			 
211c			; SAVE needs to find all tokens by flag 
211c			; WORDS just needs to scan through all  by flag 
211c			; UWORDS needs to scan through all by flag 
211c			 
211c			 
211c			; given hl as pointer to start of dict look up string 
211c			; return hl as pointer to start of word block 
211c			; or 0 if not found 
211c			 
211c			forth_find_tok: 
211c c9				ret 
211d			 
211d			; given hl as pointer to dict structure 
211d			; move to the next dict block structure 
211d			 
211d			forth_tok_next: 
211d				; hl now points to the address of the next word pointer  
211d				; TODO skip compiled symbol for now 
211d			;	push de 
211d 23				inc hl 
211e 5e				ld e, (hl) 
211f 23				inc hl 
2120 56				ld d, (hl) 
2121 23				inc hl 
2122			 
2122 eb				ex de,hl 
2123			if DEBUG_FORTH_PARSE_NEXTWORD 
2123				push bc 
2123				ld bc, (cli_nextword) 
2123						DMARK "NXW" 
2123				CALLMONITOR 
2123				pop bc 
2123			endif 
2123			;	pop de	 
2123 c9				ret 
2124			 
2124			 
2124			 
2124			; eof 
# End of file forth_parserv5.asm
2124				include "forth_wordsv4.asm" 
2124			 
2124			; the core word dictionary v4 
2124			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2124			 
2124			; this is a linked list for each of the system words used 
2124			; user defined words will follow the same format but will be in ram 
2124			 
2124			 
2124			; 
2124			; 
2124			; define linked list: 
2124			; 
2124			; 1. compiled byte op code 
2124			; 2. len of text word 
2124			; 3. text word 
2124			; 4. ptr to next dictionary word 
2124			; 5. asm, calls etc for the word 
2124			; 
2124			;  if 1 == 0 then last word in dict  
2124			;   
2124			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2124			;  
2124			;  
2124			; create basic standard set of words 
2124			; 
2124			;  
2124			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2124			; 2DUP 2DROP 2SWAP  
2124			; @ C@ - get byte  
2124			; ! C! - store byte 
2124			; 0< true if less than zero 
2124			; 0= true if zero 
2124			; < >  
2124			; = true if same 
2124			; variables 
2124			 
2124			 
2124			; Hardware specific words I may need 
2124			; 
2124			; IN OUT  
2124			; calls to key util functions 
2124			; calls to hardward abstraction stuff 
2124			; easy control of frame buffers and lcd i/o 
2124			; keyboard  
2124			 
2124			 
2124			;DICT: macro 
2124			; op_code, len, word, next 
2124			;    word: 
2124			;    db op_code 
2124			;    ds word zero term 
2124			;    dw next 
2124			;    endm 
2124			 
2124			 
2124			 
2124			 
2124			; op code 1 is a flag for user define words which are to be handled differently 
2124			 
2124			 
2124			; 
2124			; 
2124			;    TODO on entry to a word this should be the expected environment 
2124			;    hl - tos value if number then held, if string this is the ptr 
2124			;    de -  
2124			 
2124			 
2124			; opcode ranges 
2124			; 0 - end of word dict 
2124			; 255 - user define words 
2124			 
2124			sysdict: 
2124			include "forth_opcodes.asm" 
2124			; op codes for forth keywords 
2124			; free to use code 0  
2124				OPCODE_HEAP: equ  1 
2124				OPCODE_EXEC: equ 2 
2124				OPCODE_DUP: equ 3 
2124				OPCODE_SWAP: equ 4 
2124				OPCODE_COLN: equ 5 
2124				OPCODE_SCOLN: equ 6 
2124				OPCODE_DROP: equ 7 
2124				OPCODE_DUP2: equ 8 
2124				OPCODE_DROP2: equ 9 
2124				OPCODE_SWAP2: equ 10 
2124				OPCODE_AT: equ 11 
2124				OPCODE_CAT: equ 12 
2124				OPCODE_BANG: equ 13 
2124				OPCODE_CBANG: equ 14 
2124				OPCODE_SCALL: equ 15 
2124				OPCODE_DEPTH: equ 16 
2124				OPCODE_OVER: equ 17 
2124				OPCODE_PAUSE: equ 18 
2124				OPCODE_PAUSES: equ 19 
2124				OPCODE_ROT: equ 20 
2124			;free to reuse	OPCODE_WORDS: equ 21 
2124			        OPCODE_NOT: equ 21 
2124				OPCODE_UWORDS: equ 22 
2124				OPCODE_BP: equ 23 
2124				OPCODE_MONITOR: equ 24  
2124				OPCODE_MALLOC: equ 25 
2124				OPCODE_FREE: equ 26 
2124				OPCODE_LIST: equ 27 
2124				OPCODE_FORGET: equ 28 
2124				OPCODE_NOP: equ 29 
2124				OPCODE_COMO: equ 30 
2124				OPCODE_COMC: equ 31 
2124			;free to reuse	OPCODE_ENDCORE: equ 32 
2124				OPCODE_AFTERSOUND: equ 33 
2124				OPCODE_GP2: equ 34 
2124				OPCODE_GP3: equ 35 
2124				OPCODE_GP4: equ 36 
2124				OPCODE_SIN: equ 37 
2124				OPCODE_SOUT: equ 38 
2124				OPCODE_SPIO: equ 39 
2124				OPCODE_SPICEH: equ 40 
2124				OPCODE_SPIOb: equ 41 
2124				OPCODE_SPII: equ 42 
2124				OPCODE_SESEL: equ 43 
2124				OPCODE_CARTDEV: equ 44 
2124			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2124				OPCODE_FB: equ 46 
2124				OPCODE_EMIT: equ 47 
2124				OPCODE_DOTH: equ 48 
2124				OPCODE_DOTF: equ 49 
2124				OPCODE_DOT: equ 50 
2124				OPCODE_CLS: equ 51 
2124				OPCODE_DRAW: equ 52 
2124				OPCODE_DUMP: equ 53 
2124				OPCODE_CDUMP: equ 54 
2124				OPCODE_DAT: equ 55 
2124				OPCODE_HOME: equ 56 
2124				OPCODE_SPACE: equ 57 
2124				OPCODE_SPACES: equ 58 
2124				OPCODE_SCROLL: equ 59 
2124				OPCODE_ATQ: equ 60 
2124				OPCODE_AUTODSP: equ 61 
2124				OPCODE_MENU: equ 62 
2124			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2124				OPCODE_THEN: equ 64 
2124				OPCODE_ELSE: equ 65 
2124				OPCODE_DO: equ 66 
2124				OPCODE_LOOP: equ 67 
2124				OPCODE_I: equ 68 
2124				OPCODE_DLOOP: equ 69  
2124				OPCODE_REPEAT: equ 70  
2124				OPCODE_UNTIL: equ 71 
2124				OPCODE_ENDFLOW: equ 72 
2124				OPCODE_WAITK: equ 73 
2124				OPCODE_ACCEPT: equ 74 
2124				OPCODE_EDIT: equ 75 
2124			;free to reuse	OPCODE_ENDKEY: equ 76 
2124				OPCODE_LZERO: equ 77 
2124				OPCODE_TZERO: equ 78 
2124				OPCODE_LESS: equ 79 
2124				OPCODE_GT: equ 80 
2124				OPCODE_EQUAL: equ 81  
2124			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2124				OPCODE_NEG: equ 83 
2124				OPCODE_DIV: equ 84 
2124				OPCODE_MUL: equ 85 
2124				OPCODE_MIN: equ 86 
2124				OPCODE_MAX: equ 87 
2124				OPCODE_RND16: equ 88 
2124				OPCODE_RND8: equ 89 
2124				OPCODE_RND: equ 90 
2124			;free to reuse	OPCODE_ENDMATHS: equ 91  
2124				OPCODE_BYNAME: equ 92 
2124				OPCODE_DIR: equ 93 
2124				OPCODE_SAVE: equ 94 
2124				OPCODE_LOAD: equ 95 
2124				OPCODE_BSAVE: equ 96 
2124				OPCODE_BLOAD: equ 97 
2124				OPCODE_SEO: equ 98  
2124				OPCODE_SEI: equ 99 
2124				OPCODE_SFREE: equ 100 
2124				OPCODE_SIZE: equ 101 
2124				OPCODE_CREATE: equ 102 
2124				OPCODE_APPEND: equ 103 
2124				OPCODE_SDEL: equ 104 
2124				OPCODE_OPEN: equ 105 
2124				OPCODE_READ: equ 106 
2124				OPCODE_EOF: equ 106 
2124				OPCODE_FORMAT: equ 107 
2124				OPCODE_LABEL: equ 108 
2124				OPCODE_LABELS: equ 109 
2124			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2124				OPCODE_UPPER: equ 111 
2124				OPCODE_LOWER: equ 112 
2124				OPCODE_SUBSTR: equ 113 
2124				OPCODE_LEFT: equ 114 
2124				OPCODE_RIGHT: equ 115 
2124				OPCODE_STR2NUM: equ 116 
2124				OPCODE_NUM2STR: equ 117 
2124				OPCODE_CONCAT: equ 118 
2124				OPCODE_FIND: equ 119 
2124				OPCODE_LEN: equ 120 
2124				OPCODE_CHAR: equ 121 
2124			; free to reuse	OPCODE_STRLEN: equ 122 
2124			; free to reuse	OPCODE_ENDSTR: equ 123 
2124				OPCODE_V0S: equ 124 
2124				OPCODE_V0Q: equ 125 
2124				OPCODE_V1S: equ 126 
2124				OPCODE_V1Q: equ 127 
2124				OPCODE_V2S: equ 128 
2124				OPCODE_V2Q: equ 129 
2124				OPCODE_V3S: equ 130 
2124				OPCODE_V3Q: equ 131 
2124			;free to reuse	OPCODE_END: equ 132 
2124				OPCODE_ZDUP: equ 133 
2124			 
2124			; eof 
# End of file forth_opcodes.asm
2124			 
2124			include "forth_words_core.asm" 
2124			 
2124			; | ## Core Words 
2124			 
2124			;if MALLOC_4 
2124			 
2124			.HEAP: 
2124				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2124 15				db WORD_SYS_CORE+OPCODE_HEAP             
2125 63 21			dw .EXEC            
2127 05				db 4 + 1 
2128 .. 00			db "HEAP",0              
212d				endm 
# End of macro CWHEAD
212d			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
212d			; | | u1 - Current number of bytes in the heap 
212d			; | | u2 - Remaining bytes left on the heap 
212d			; | |  
212d			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
212d			 
212d			 
212d					if DEBUG_FORTH_WORDS_KEY 
212d						DMARK "HEP" 
212d f5				push af  
212e 3a 42 21			ld a, (.dmark)  
2131 32 71 ee			ld (debug_mark),a  
2134 3a 43 21			ld a, (.dmark+1)  
2137 32 72 ee			ld (debug_mark+1),a  
213a 3a 44 21			ld a, (.dmark+2)  
213d 32 73 ee			ld (debug_mark+2),a  
2140 18 03			jr .pastdmark  
2142 ..			.dmark: db "HEP"  
2145 f1			.pastdmark: pop af  
2146			endm  
# End of macro DMARK
2146						CALLMONITOR 
2146 cd ae 15			call break_point_state  
2149				endm  
# End of macro CALLMONITOR
2149					endif 
2149 2a 3c 64				ld hl, (free_list )      
214c 11 41 64				ld de, heap_start 
214f			 
214f ed 52				sbc hl, de  
2151			 
2151 cd 1f 1c				call forth_push_numhl 
2154			 
2154			 
2154 ed 5b 3c 64			ld de, (free_list )      
2158 21 b1 e2				ld hl, heap_end 
215b			 
215b ed 52				sbc hl, de 
215d			 
215d cd 1f 1c				call forth_push_numhl 
2160					 
2160			 
2160					 
2160			 
2160			 
2160			 
2160					NEXTW 
2160 c3 cc 1f			jp macro_next 
2163				endm 
# End of macro NEXTW
2163			;endif 
2163			 
2163			.EXEC: 
2163			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2163			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2163			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2163			;; > > 
2163			;; > >   
2163			;	STACKFRAME OFF $5efe $5f9f 
2163			; 
2163			;		if DEBUG_FORTH_WORDS_KEY 
2163			;			DMARK "EXE" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			; 
2163			;	FORTH_DSP_VALUEHL 
2163			; 
2163			;	FORTH_DSP_POP 
2163			; 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EX1" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;;	ld e,(hl) 
2163			;;	inc hl 
2163			;;	ld d,(hl) 
2163			;;	ex de,hl 
2163			; 
2163			;;		if DEBUG_FORTH_WORDS 
2163			;;			DMARK "EX2" 
2163			;;			CALLMONITOR 
2163			;;		endif 
2163			;	push hl 
2163			; 
2163			;	;ld a, 0 
2163			;	;ld a, FORTH_END_BUFFER 
2163			;	call strlenz 
2163			;	inc hl   ; include zero term to copy 
2163			;	inc hl   ; include term 
2163			;	inc hl   ; include term 
2163			;	ld b,0 
2163			;	ld c,l 
2163			;	pop hl 
2163			;	ld de, execscratch 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EX3" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;	ldir 
2163			; 
2163			; 
2163			;	ld hl, execscratch 
2163			; 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EXe" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			; 
2163			;	call forthparse 
2163			;	call forthexec 
2163			;;	call forthexec_cleanup 
2163			;;	call forthparse 
2163			;;	call forthexec 
2163			; 
2163			;	STACKFRAMECHK OFF $5efe $5f9f 
2163			; 
2163			;	; an immediate word so no need to process any more words 
2163			;	ret 
2163			;	NEXTW 
2163			 
2163			; dead code - old version  
2163			;	FORTH_RSP_NEXT 
2163			 
2163			;  
2163			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2163			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2163			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2163			;	push hl 
2163			;	push de 
2163			;	push bc 
2163			; 
2163			; 
2163			;		if DEBUG_FORTH_WORDS_KEY 
2163			;			DMARK "EXR" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			; 
2163			; 
2163			; 
2163			;	;v5 FORTH_DSP_VALUE 
2163			;	FORTH_DSP_VALUEHL 
2163			; 
2163			;	; TODO do string type checks 
2163			; 
2163			;;v5	inc hl   ; skip type 
2163			; 
2163			;	push hl  ; source code  
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EX1" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;	ld a, 0 
2163			;	call strlent 
2163			; 
2163			;	inc hl 
2163			;	inc hl 
2163			;	inc hl 
2163			;	inc hl 
2163			; 
2163			;	push hl    ; size 
2163			; 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EX2" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;	call malloc 
2163			; 
2163			;	ex de, hl    ; de now contains malloc area 
2163			;	pop bc   	; get byte count 
2163			;	pop hl      ; get string to copy 
2163			; 
2163			;	push de     ; save malloc for free later 
2163			; 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EX3" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;	ldir       ; duplicate string 
2163			; 
2163			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2163			;	 
2163			;	; TODO fix the parse would be better than this...  
2163			;	ex de, hl 
2163			;	dec hl 
2163			;	ld a, 0 
2163			;	ld (hl), a 
2163			;	dec hl 
2163			;	ld a, ' ' 
2163			;	ld (hl), a 
2163			;	dec hl 
2163			;	ld (hl), a 
2163			; 
2163			;	dec hl 
2163			;	ld (hl), a 
2163			; 
2163			; 
2163			;	FORTH_DSP_POP  
2163			; 
2163			;	pop hl     
2163			;	push hl    ; save malloc area 
2163			; 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EX4" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			; 
2163			;	call forthparse 
2163			;	call forthexec 
2163			;	 
2163			;	pop hl 
2163			;	if DEBUG_FORTH_WORDS 
2163			;		DMARK "EX5" 
2163			;		CALLMONITOR 
2163			;	endif 
2163			; 
2163			;	if FORTH_ENABLE_FREE 
2163			;	call free 
2163			;	endif 
2163			; 
2163			;	if DEBUG_FORTH_WORDS 
2163			;		DMARK "EX6" 
2163			;		CALLMONITOR 
2163			;	endif 
2163			; 
2163			;	pop bc 
2163			;	pop de 
2163			;	pop hl 
2163			;;	FORTH_RSP_POP	  
2163			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2163			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2163			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2163			; 
2163			;	if DEBUG_FORTH_WORDS 
2163			;		DMARK "EX7" 
2163			;		CALLMONITOR 
2163			;	endif 
2163			;	NEXTW 
2163			 
2163			;.STKEXEC: 
2163			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2163			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2163			; 
2163			; 
2163			;		if DEBUG_FORTH_WORDS_KEY 
2163			;			DMARK "STX" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			; 
2163			;	FORTH_DSP_VALUEHL 
2163			; 
2163			;	ld (store_tmp1), hl    ; count 
2163			; 
2163			;	FORTH_DSP_POP 
2163			;.stkexec1: 
2163			;	ld hl, (store_tmp1)   ; count 
2163			;	ld a, 0 
2163			;	cp l 
2163			;	ret z 
2163			; 
2163			;	dec hl 
2163			;	ld (store_tmp1), hl    ; count 
2163			;	 
2163			;	FORTH_DSP_VALUEHL 
2163			;	push hl 
2163			;	 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EXp" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;	FORTH_DSP_POP 
2163			; 
2163			;	call strlenz 
2163			;	inc hl   ; include zero term to copy 
2163			;	inc hl   ; include zero term to copy 
2163			;	inc hl   ; include zero term to copy 
2163			;	ld b,0 
2163			;	ld c,l 
2163			;	pop hl 
2163			;	ld de, execscratch 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EX3" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;	ldir 
2163			; 
2163			; 
2163			;	ld hl, execscratch 
2163			; 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EXP" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			; 
2163			;	call forthparse 
2163			;	ld hl, execscratch 
2163			;		if DEBUG_FORTH_WORDS 
2163			;			DMARK "EXx" 
2163			;			CALLMONITOR 
2163			;		endif 
2163			;	call forthexec 
2163			; 
2163			;	jp .stkexec1 
2163			; 
2163			;	ret 
2163			 
2163			 
2163			.DUP: 
2163				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2163 17				db WORD_SYS_CORE+OPCODE_DUP             
2164 d9 21			dw .ZDUP            
2166 04				db 3 + 1 
2167 .. 00			db "DUP",0              
216b				endm 
# End of macro CWHEAD
216b			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
216b			 
216b					if DEBUG_FORTH_WORDS_KEY 
216b						DMARK "DUP" 
216b f5				push af  
216c 3a 80 21			ld a, (.dmark)  
216f 32 71 ee			ld (debug_mark),a  
2172 3a 81 21			ld a, (.dmark+1)  
2175 32 72 ee			ld (debug_mark+1),a  
2178 3a 82 21			ld a, (.dmark+2)  
217b 32 73 ee			ld (debug_mark+2),a  
217e 18 03			jr .pastdmark  
2180 ..			.dmark: db "DUP"  
2183 f1			.pastdmark: pop af  
2184			endm  
# End of macro DMARK
2184						CALLMONITOR 
2184 cd ae 15			call break_point_state  
2187				endm  
# End of macro CALLMONITOR
2187					endif 
2187			 
2187					FORTH_DSP 
2187 cd dc 1d			call macro_forth_dsp 
218a				endm 
# End of macro FORTH_DSP
218a			 
218a 7e					ld a, (HL) 
218b fe 01				cp DS_TYPE_STR 
218d 20 25				jr nz, .dupinum 
218f			 
218f					; push another string 
218f			 
218f					FORTH_DSP_VALUEHL     		 
218f cd 16 1e			call macro_dsp_valuehl 
2192				endm 
# End of macro FORTH_DSP_VALUEHL
2192			 
2192				if DEBUG_FORTH_WORDS 
2192					DMARK "DUs" 
2192 f5				push af  
2193 3a a7 21			ld a, (.dmark)  
2196 32 71 ee			ld (debug_mark),a  
2199 3a a8 21			ld a, (.dmark+1)  
219c 32 72 ee			ld (debug_mark+1),a  
219f 3a a9 21			ld a, (.dmark+2)  
21a2 32 73 ee			ld (debug_mark+2),a  
21a5 18 03			jr .pastdmark  
21a7 ..			.dmark: db "DUs"  
21aa f1			.pastdmark: pop af  
21ab			endm  
# End of macro DMARK
21ab					CALLMONITOR 
21ab cd ae 15			call break_point_state  
21ae				endm  
# End of macro CALLMONITOR
21ae				endif 
21ae cd 8d 1c				call forth_push_str 
21b1			 
21b1					NEXTW 
21b1 c3 cc 1f			jp macro_next 
21b4				endm 
# End of macro NEXTW
21b4			 
21b4			 
21b4			.dupinum: 
21b4					 
21b4			 
21b4			 
21b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21b4 cd 16 1e			call macro_dsp_valuehl 
21b7				endm 
# End of macro FORTH_DSP_VALUEHL
21b7			 
21b7				; TODO add floating point number detection 
21b7			 
21b7				if DEBUG_FORTH_WORDS 
21b7					DMARK "DUi" 
21b7 f5				push af  
21b8 3a cc 21			ld a, (.dmark)  
21bb 32 71 ee			ld (debug_mark),a  
21be 3a cd 21			ld a, (.dmark+1)  
21c1 32 72 ee			ld (debug_mark+1),a  
21c4 3a ce 21			ld a, (.dmark+2)  
21c7 32 73 ee			ld (debug_mark+2),a  
21ca 18 03			jr .pastdmark  
21cc ..			.dmark: db "DUi"  
21cf f1			.pastdmark: pop af  
21d0			endm  
# End of macro DMARK
21d0					CALLMONITOR 
21d0 cd ae 15			call break_point_state  
21d3				endm  
# End of macro CALLMONITOR
21d3				endif 
21d3			 
21d3 cd 1f 1c				call forth_push_numhl 
21d6					NEXTW 
21d6 c3 cc 1f			jp macro_next 
21d9				endm 
# End of macro NEXTW
21d9			.ZDUP: 
21d9				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
21d9 99				db WORD_SYS_CORE+OPCODE_ZDUP             
21da 11 22			dw .SWAP            
21dc 05				db 4 + 1 
21dd .. 00			db "?DUP",0              
21e2				endm 
# End of macro CWHEAD
21e2			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
21e2			 
21e2					if DEBUG_FORTH_WORDS_KEY 
21e2						DMARK "qDU" 
21e2 f5				push af  
21e3 3a f7 21			ld a, (.dmark)  
21e6 32 71 ee			ld (debug_mark),a  
21e9 3a f8 21			ld a, (.dmark+1)  
21ec 32 72 ee			ld (debug_mark+1),a  
21ef 3a f9 21			ld a, (.dmark+2)  
21f2 32 73 ee			ld (debug_mark+2),a  
21f5 18 03			jr .pastdmark  
21f7 ..			.dmark: db "qDU"  
21fa f1			.pastdmark: pop af  
21fb			endm  
# End of macro DMARK
21fb						CALLMONITOR 
21fb cd ae 15			call break_point_state  
21fe				endm  
# End of macro CALLMONITOR
21fe					endif 
21fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21fe cd 16 1e			call macro_dsp_valuehl 
2201				endm 
# End of macro FORTH_DSP_VALUEHL
2201			 
2201 e5					push hl 
2202			 
2202					; is it a zero? 
2202			 
2202 3e 00				ld a, 0 
2204 84					add h 
2205 85					add l 
2206			 
2206 e1					pop hl 
2207			 
2207 fe 00				cp 0 
2209 28 03				jr z, .dup2orig 
220b			 
220b			 
220b cd 1f 1c				call forth_push_numhl 
220e			 
220e			 
220e				; TODO add floating point number detection 
220e			 
220e			.dup2orig: 
220e			 
220e					NEXTW 
220e c3 cc 1f			jp macro_next 
2211				endm 
# End of macro NEXTW
2211			.SWAP: 
2211				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2211 18				db WORD_SYS_CORE+OPCODE_SWAP             
2212 50 22			dw .COLN            
2214 05				db 4 + 1 
2215 .. 00			db "SWAP",0              
221a				endm 
# End of macro CWHEAD
221a			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
221a					if DEBUG_FORTH_WORDS_KEY 
221a						DMARK "SWP" 
221a f5				push af  
221b 3a 2f 22			ld a, (.dmark)  
221e 32 71 ee			ld (debug_mark),a  
2221 3a 30 22			ld a, (.dmark+1)  
2224 32 72 ee			ld (debug_mark+1),a  
2227 3a 31 22			ld a, (.dmark+2)  
222a 32 73 ee			ld (debug_mark+2),a  
222d 18 03			jr .pastdmark  
222f ..			.dmark: db "SWP"  
2232 f1			.pastdmark: pop af  
2233			endm  
# End of macro DMARK
2233						CALLMONITOR 
2233 cd ae 15			call break_point_state  
2236				endm  
# End of macro CALLMONITOR
2236					endif 
2236			 
2236					FORTH_DSP_VALUEHL 
2236 cd 16 1e			call macro_dsp_valuehl 
2239				endm 
# End of macro FORTH_DSP_VALUEHL
2239 e5					push hl     ; w2 
223a			 
223a					FORTH_DSP_POP 
223a cd ce 1e			call macro_forth_dsp_pop 
223d				endm 
# End of macro FORTH_DSP_POP
223d			 
223d					FORTH_DSP_VALUEHL 
223d cd 16 1e			call macro_dsp_valuehl 
2240				endm 
# End of macro FORTH_DSP_VALUEHL
2240			 
2240					FORTH_DSP_POP 
2240 cd ce 1e			call macro_forth_dsp_pop 
2243				endm 
# End of macro FORTH_DSP_POP
2243			 
2243 d1					pop de     ; w2	, hl = w1 
2244			 
2244 eb					ex de, hl 
2245 d5					push de 
2246			 
2246 cd 1f 1c				call forth_push_numhl 
2249			 
2249 e1					pop hl 
224a			 
224a cd 1f 1c				call forth_push_numhl 
224d					 
224d			 
224d					NEXTW 
224d c3 cc 1f			jp macro_next 
2250				endm 
# End of macro NEXTW
2250			.COLN: 
2250				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2250 19				db WORD_SYS_CORE+OPCODE_COLN             
2251 dc 23			dw .SCOLN            
2253 02				db 1 + 1 
2254 .. 00			db ":",0              
2256				endm 
# End of macro CWHEAD
2256			; | : ( -- )         Create new word | DONE 
2256			 
2256					if DEBUG_FORTH_WORDS_KEY 
2256						DMARK "CLN" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 71 ee			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 72 ee			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 73 ee			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db "CLN"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f						CALLMONITOR 
226f cd ae 15			call break_point_state  
2272				endm  
# End of macro CALLMONITOR
2272					endif 
2272				STACKFRAME OFF $8efe $989f 
2272				if DEBUG_STACK_IMB 
2272					if OFF 
2272						exx 
2272						ld de, $8efe 
2272						ld a, d 
2272						ld hl, curframe 
2272						call hexout 
2272						ld a, e 
2272						ld hl, curframe+2 
2272						call hexout 
2272						ld hl, $8efe 
2272						push hl 
2272						ld hl, $989f 
2272						push hl 
2272						exx 
2272					endif 
2272				endif 
2272			endm 
# End of macro STACKFRAME
2272				; get parser buffer length  of new word 
2272			 
2272				 
2272			 
2272					; move tok past this to start of name defintition 
2272					; TODO get word to define 
2272					; TODO Move past word token 
2272					; TODO get length of string up to the ';' 
2272			 
2272 2a cc e5			ld hl, (os_tok_ptr) 
2275 23				inc hl 
2276 23				inc hl 
2277			 
2277 3e 3b			ld a, ';' 
2279 cd 16 12			call strlent 
227c			 
227c 7d				ld a,l 
227d 32 c7 e2			ld (os_new_parse_len), a 
2280			 
2280			 
2280			if DEBUG_FORTH_UWORD 
2280 ed 5b cc e5		ld de, (os_tok_ptr) 
2284						DMARK ":01" 
2284 f5				push af  
2285 3a 99 22			ld a, (.dmark)  
2288 32 71 ee			ld (debug_mark),a  
228b 3a 9a 22			ld a, (.dmark+1)  
228e 32 72 ee			ld (debug_mark+1),a  
2291 3a 9b 22			ld a, (.dmark+2)  
2294 32 73 ee			ld (debug_mark+2),a  
2297 18 03			jr .pastdmark  
2299 ..			.dmark: db ":01"  
229c f1			.pastdmark: pop af  
229d			endm  
# End of macro DMARK
229d				CALLMONITOR 
229d cd ae 15			call break_point_state  
22a0				endm  
# End of macro CALLMONITOR
22a0			endif 
22a0			 
22a0			; 
22a0			;  new word memory layout: 
22a0			;  
22a0			;    : adg 6666 ;  
22a0			; 
22a0			;    db   1     ; user defined word  
22a0 23				inc hl    
22a1			;    dw   sysdict 
22a1 23				inc hl 
22a2 23				inc hl 
22a3			;    db <word len>+1 (for null) 
22a3 23				inc hl 
22a4			;    db .... <word> 
22a4			; 
22a4			 
22a4 23				inc hl    ; some extras for the word preamble before the above 
22a5 23				inc hl 
22a6 23				inc hl 
22a7 23				inc hl 
22a8 23				inc hl 
22a9 23				inc hl 
22aa 23				inc hl  
22ab 23				inc hl 
22ac 23				inc hl 
22ad 23				inc hl 
22ae 23				inc hl 
22af 23				inc hl 
22b0 23				inc hl 
22b1 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22b2			;       exec word buffer 
22b2			;	<ptr word>   
22b2 23				inc hl 
22b3 23				inc hl 
22b4			;       <word list><null term> 7F final term 
22b4			 
22b4			 
22b4			if DEBUG_FORTH_UWORD 
22b4						DMARK ":02" 
22b4 f5				push af  
22b5 3a c9 22			ld a, (.dmark)  
22b8 32 71 ee			ld (debug_mark),a  
22bb 3a ca 22			ld a, (.dmark+1)  
22be 32 72 ee			ld (debug_mark+1),a  
22c1 3a cb 22			ld a, (.dmark+2)  
22c4 32 73 ee			ld (debug_mark+2),a  
22c7 18 03			jr .pastdmark  
22c9 ..			.dmark: db ":02"  
22cc f1			.pastdmark: pop af  
22cd			endm  
# End of macro DMARK
22cd				CALLMONITOR 
22cd cd ae 15			call break_point_state  
22d0				endm  
# End of macro CALLMONITOR
22d0			endif 
22d0			 
22d0				 
22d0					; malloc the size 
22d0			 
22d0 cd 74 12				call malloc 
22d3 22 c9 e2				ld (os_new_malloc), hl     ; save malloc start 
22d6			 
22d6			;    db   1     ; user defined word  
22d6 3e 01				ld a, WORD_SYS_UWORD  
22d8 77					ld (hl), a 
22d9				 
22d9 23				inc hl    
22da			;    dw   sysdict 
22da 11 24 21			ld de, sysdict       ; continue on with the scan to the system dict 
22dd 73				ld (hl), e 
22de 23				inc hl 
22df 72				ld (hl), d 
22e0 23				inc hl 
22e1			 
22e1			 
22e1			;    Setup dict word 
22e1			 
22e1 23				inc hl 
22e2 22 c3 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
22e5			 
22e5				; 1. get length of dict word 
22e5			 
22e5			 
22e5 2a cc e5			ld hl, (os_tok_ptr) 
22e8 23				inc hl 
22e9 23				inc hl    ; position to start of dict word 
22ea 3e 00			ld a, 0 
22ec cd 16 12			call strlent 
22ef			 
22ef			 
22ef 23				inc hl    ; to include null??? 
22f0			 
22f0				; write length of dict word 
22f0			 
22f0 ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22f4 1b				dec de 
22f5 eb				ex de, hl 
22f6 73				ld (hl), e 
22f7 eb				ex de, hl 
22f8			 
22f8				 
22f8			 
22f8				; copy  
22f8 4d				ld c, l 
22f9 06 00			ld b, 0 
22fb ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22ff 2a cc e5			ld hl, (os_tok_ptr) 
2302 23				inc hl 
2303 23				inc hl    ; position to start of dict word 
2304				 
2304			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2304				 
2304				; TODO need to convert word to upper case 
2304			 
2304			ucasetok:	 
2304 7e				ld a,(hl) 
2305 cd 02 12			call toUpper 
2308 77				ld (hl),a 
2309 ed a0			ldi 
230b f2 04 23		 	jp p, ucasetok 
230e			 
230e			 
230e			 
230e				; de now points to start of where the word body code should be placed 
230e ed 53 c3 e2		ld (os_new_work_ptr), de 
2312				; hl now points to the words to throw at forthexec which needs to be copied 
2312 22 c1 e2			ld (os_new_src_ptr), hl 
2315			 
2315				; TODO add 'call to forthexec' 
2315			 
2315			if DEBUG_FORTH_UWORD 
2315 c5				push bc 
2316 ed 4b c9 e2		ld bc, (os_new_malloc) 
231a						DMARK ":0x" 
231a f5				push af  
231b 3a 2f 23			ld a, (.dmark)  
231e 32 71 ee			ld (debug_mark),a  
2321 3a 30 23			ld a, (.dmark+1)  
2324 32 72 ee			ld (debug_mark+1),a  
2327 3a 31 23			ld a, (.dmark+2)  
232a 32 73 ee			ld (debug_mark+2),a  
232d 18 03			jr .pastdmark  
232f ..			.dmark: db ":0x"  
2332 f1			.pastdmark: pop af  
2333			endm  
# End of macro DMARK
2333				CALLMONITOR 
2333 cd ae 15			call break_point_state  
2336				endm  
# End of macro CALLMONITOR
2336 c1				pop bc 
2337			endif 
2337			 
2337			 
2337				; create word preamble which should be: 
2337			 
2337			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2337			 
2337				;    ld hl, <word code> 
2337				;    jp user_exec 
2337			        ;    <word code bytes> 
2337			 
2337			 
2337			;	inc de     ; TODO ??? or are we already past the word's null 
2337 eb				ex de, hl 
2338			 
2338 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
233a			 
233a 23				inc hl 
233b 22 bd e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
233e 23				inc hl 
233f			 
233f 23				inc hl 
2340 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2342			 
2342 01 b9 4b			ld bc, user_exec 
2345 23				inc hl 
2346 71				ld (hl), c     ; poke address of user_exec 
2347 23				inc hl 
2348 70				ld (hl), b     
2349			 ; 
2349			;	inc hl 
2349			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2349			; 
2349			; 
2349			;	ld bc, macro_forth_rsp_next 
2349			;	inc hl 
2349			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2349			;	inc hl 
2349			;	ld (hl), b     
2349			 ; 
2349			;	inc hl 
2349			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2349			; 
2349			; 
2349			;	inc hl 
2349			;	ld bc, forthexec 
2349			;	ld (hl), c     ; poke address of forthexec 
2349			;	inc hl 
2349			;	ld (hl), b      
2349			; 
2349			;	inc hl 
2349			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2349			; 
2349			;	ld bc, user_dict_next 
2349			;	inc hl 
2349			;	ld (hl), c     ; poke address of forthexec 
2349			;	inc hl 
2349			;	ld (hl), b      
2349			 
2349				; hl is now where we need to copy the word byte data to save this 
2349			 
2349 23				inc hl 
234a 22 bf e2			ld (os_new_exec), hl 
234d				 
234d				; copy definition 
234d			 
234d eb				ex de, hl 
234e			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
234e			;	inc de    ; skip the PC for this parse 
234e 3a c7 e2			ld a, (os_new_parse_len) 
2351 4f				ld c, a 
2352 06 00			ld b, 0 
2354 ed b0			ldir		 ; copy defintion 
2356			 
2356			 
2356				; poke the address of where the new word bytes live for forthexec 
2356			 
2356 2a bd e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2359			 
2359 ed 5b bf e2		ld de, (os_new_exec)      
235d				 
235d 73				ld (hl), e 
235e 23				inc hl 
235f 72				ld (hl), d 
2360			 
2360					; TODO copy last user dict word next link to this word 
2360					; TODO update last user dict word to point to this word 
2360			; 
2360			; hl f923 de 812a ; bc 811a 
2360			 
2360			if DEBUG_FORTH_UWORD 
2360 c5				push bc 
2361 ed 4b c9 e2		ld bc, (os_new_malloc) 
2365						DMARK ":0A" 
2365 f5				push af  
2366 3a 7a 23			ld a, (.dmark)  
2369 32 71 ee			ld (debug_mark),a  
236c 3a 7b 23			ld a, (.dmark+1)  
236f 32 72 ee			ld (debug_mark+1),a  
2372 3a 7c 23			ld a, (.dmark+2)  
2375 32 73 ee			ld (debug_mark+2),a  
2378 18 03			jr .pastdmark  
237a ..			.dmark: db ":0A"  
237d f1			.pastdmark: pop af  
237e			endm  
# End of macro DMARK
237e				CALLMONITOR 
237e cd ae 15			call break_point_state  
2381				endm  
# End of macro CALLMONITOR
2381 c1				pop bc 
2382			endif 
2382			if DEBUG_FORTH_UWORD 
2382 c5				push bc 
2383 ed 4b c9 e2		ld bc, (os_new_malloc) 
2387 03				inc bc 
2388 03				inc bc 
2389 03				inc bc 
238a 03				inc bc 
238b 03				inc bc 
238c 03				inc bc 
238d 03				inc bc 
238e 03				inc bc 
238f			 
238f						DMARK ":0B" 
238f f5				push af  
2390 3a a4 23			ld a, (.dmark)  
2393 32 71 ee			ld (debug_mark),a  
2396 3a a5 23			ld a, (.dmark+1)  
2399 32 72 ee			ld (debug_mark+1),a  
239c 3a a6 23			ld a, (.dmark+2)  
239f 32 73 ee			ld (debug_mark+2),a  
23a2 18 03			jr .pastdmark  
23a4 ..			.dmark: db ":0B"  
23a7 f1			.pastdmark: pop af  
23a8			endm  
# End of macro DMARK
23a8				CALLMONITOR 
23a8 cd ae 15			call break_point_state  
23ab				endm  
# End of macro CALLMONITOR
23ab c1				pop bc 
23ac			endif 
23ac			 
23ac			; update word dict linked list for new word 
23ac			 
23ac			 
23ac 2a c8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23af 23			inc hl     ; move to next work linked list ptr 
23b0			 
23b0 ed 5b c9 e2	ld de, (os_new_malloc)		 ; new next word 
23b4 73			ld (hl), e 
23b5 23			inc hl 
23b6 72			ld (hl), d 
23b7			 
23b7			if DEBUG_FORTH_UWORD 
23b7 ed 4b c8 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23bb			endif 
23bb			 
23bb ed 53 c8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23bf			 
23bf			 
23bf			if DEBUG_FORTH_UWORD 
23bf						DMARK ":0+" 
23bf f5				push af  
23c0 3a d4 23			ld a, (.dmark)  
23c3 32 71 ee			ld (debug_mark),a  
23c6 3a d5 23			ld a, (.dmark+1)  
23c9 32 72 ee			ld (debug_mark+1),a  
23cc 3a d6 23			ld a, (.dmark+2)  
23cf 32 73 ee			ld (debug_mark+2),a  
23d2 18 03			jr .pastdmark  
23d4 ..			.dmark: db ":0+"  
23d7 f1			.pastdmark: pop af  
23d8			endm  
# End of macro DMARK
23d8				CALLMONITOR 
23d8 cd ae 15			call break_point_state  
23db				endm  
# End of macro CALLMONITOR
23db			endif 
23db			 
23db				STACKFRAMECHK OFF $8efe $989f 
23db				if DEBUG_STACK_IMB 
23db					if OFF 
23db						exx 
23db						ld hl, $989f 
23db						pop de   ; $989f 
23db						call cmp16 
23db						jr nz, .spnosame 
23db						ld hl, $8efe 
23db						pop de   ; $8efe 
23db						call cmp16 
23db						jr z, .spfrsame 
23db						.spnosame: call showsperror 
23db						.spfrsame: nop 
23db						exx 
23db					endif 
23db				endif 
23db			endm 
# End of macro STACKFRAMECHK
23db			 
23db c9			ret    ; dont process any remaining parser tokens as they form new word 
23dc			 
23dc			 
23dc			 
23dc			 
23dc			;		NEXT 
23dc			.SCOLN: 
23dc			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
23dc 06				db OPCODE_SCOLN 
23dd 28 24			dw .DROP 
23df 02				db 2 
23e0 .. 00			db ";",0           
23e2			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
23e2					if DEBUG_FORTH_WORDS_KEY 
23e2						DMARK "SCN" 
23e2 f5				push af  
23e3 3a f7 23			ld a, (.dmark)  
23e6 32 71 ee			ld (debug_mark),a  
23e9 3a f8 23			ld a, (.dmark+1)  
23ec 32 72 ee			ld (debug_mark+1),a  
23ef 3a f9 23			ld a, (.dmark+2)  
23f2 32 73 ee			ld (debug_mark+2),a  
23f5 18 03			jr .pastdmark  
23f7 ..			.dmark: db "SCN"  
23fa f1			.pastdmark: pop af  
23fb			endm  
# End of macro DMARK
23fb						CALLMONITOR 
23fb cd ae 15			call break_point_state  
23fe				endm  
# End of macro CALLMONITOR
23fe					endif 
23fe					FORTH_RSP_TOS 
23fe cd dd 1b			call macro_forth_rsp_tos 
2401				endm 
# End of macro FORTH_RSP_TOS
2401 e5					push hl 
2402					FORTH_RSP_POP 
2402 cd e7 1b			call macro_forth_rsp_pop 
2405				endm 
# End of macro FORTH_RSP_POP
2405 e1					pop hl 
2406			;		ex de,hl 
2406 22 cc e5				ld (os_tok_ptr),hl 
2409			 
2409			if DEBUG_FORTH_UWORD 
2409						DMARK "SCL" 
2409 f5				push af  
240a 3a 1e 24			ld a, (.dmark)  
240d 32 71 ee			ld (debug_mark),a  
2410 3a 1f 24			ld a, (.dmark+1)  
2413 32 72 ee			ld (debug_mark+1),a  
2416 3a 20 24			ld a, (.dmark+2)  
2419 32 73 ee			ld (debug_mark+2),a  
241c 18 03			jr .pastdmark  
241e ..			.dmark: db "SCL"  
2421 f1			.pastdmark: pop af  
2422			endm  
# End of macro DMARK
2422				CALLMONITOR 
2422 cd ae 15			call break_point_state  
2425				endm  
# End of macro CALLMONITOR
2425			endif 
2425					NEXTW 
2425 c3 cc 1f			jp macro_next 
2428				endm 
# End of macro NEXTW
2428			 
2428			.DROP: 
2428				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2428 1b				db WORD_SYS_CORE+OPCODE_DROP             
2429 53 24			dw .DUP2            
242b 05				db 4 + 1 
242c .. 00			db "DROP",0              
2431				endm 
# End of macro CWHEAD
2431			; | DROP ( w -- )   drop the TOS item   | DONE 
2431					if DEBUG_FORTH_WORDS_KEY 
2431						DMARK "DRP" 
2431 f5				push af  
2432 3a 46 24			ld a, (.dmark)  
2435 32 71 ee			ld (debug_mark),a  
2438 3a 47 24			ld a, (.dmark+1)  
243b 32 72 ee			ld (debug_mark+1),a  
243e 3a 48 24			ld a, (.dmark+2)  
2441 32 73 ee			ld (debug_mark+2),a  
2444 18 03			jr .pastdmark  
2446 ..			.dmark: db "DRP"  
2449 f1			.pastdmark: pop af  
244a			endm  
# End of macro DMARK
244a						CALLMONITOR 
244a cd ae 15			call break_point_state  
244d				endm  
# End of macro CALLMONITOR
244d					endif 
244d					FORTH_DSP_POP 
244d cd ce 1e			call macro_forth_dsp_pop 
2450				endm 
# End of macro FORTH_DSP_POP
2450					NEXTW 
2450 c3 cc 1f			jp macro_next 
2453				endm 
# End of macro NEXTW
2453			.DUP2: 
2453				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2453 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2454 98 24			dw .DROP2            
2456 05				db 4 + 1 
2457 .. 00			db "2DUP",0              
245c				endm 
# End of macro CWHEAD
245c			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
245c					if DEBUG_FORTH_WORDS_KEY 
245c						DMARK "2DU" 
245c f5				push af  
245d 3a 71 24			ld a, (.dmark)  
2460 32 71 ee			ld (debug_mark),a  
2463 3a 72 24			ld a, (.dmark+1)  
2466 32 72 ee			ld (debug_mark+1),a  
2469 3a 73 24			ld a, (.dmark+2)  
246c 32 73 ee			ld (debug_mark+2),a  
246f 18 03			jr .pastdmark  
2471 ..			.dmark: db "2DU"  
2474 f1			.pastdmark: pop af  
2475			endm  
# End of macro DMARK
2475						CALLMONITOR 
2475 cd ae 15			call break_point_state  
2478				endm  
# End of macro CALLMONITOR
2478					endif 
2478					FORTH_DSP_VALUEHL 
2478 cd 16 1e			call macro_dsp_valuehl 
247b				endm 
# End of macro FORTH_DSP_VALUEHL
247b e5					push hl      ; 2 
247c			 
247c					FORTH_DSP_POP 
247c cd ce 1e			call macro_forth_dsp_pop 
247f				endm 
# End of macro FORTH_DSP_POP
247f					 
247f					FORTH_DSP_VALUEHL 
247f cd 16 1e			call macro_dsp_valuehl 
2482				endm 
# End of macro FORTH_DSP_VALUEHL
2482			;		push hl      ; 1 
2482			 
2482					FORTH_DSP_POP 
2482 cd ce 1e			call macro_forth_dsp_pop 
2485				endm 
# End of macro FORTH_DSP_POP
2485			 
2485			;		pop hl       ; 1 
2485 d1					pop de       ; 2 
2486			 
2486 cd 1f 1c				call forth_push_numhl 
2489 eb					ex de, hl 
248a cd 1f 1c				call forth_push_numhl 
248d			 
248d					 
248d eb					ex de, hl 
248e			 
248e cd 1f 1c				call forth_push_numhl 
2491 eb					ex de, hl 
2492 cd 1f 1c				call forth_push_numhl 
2495			 
2495			 
2495					NEXTW 
2495 c3 cc 1f			jp macro_next 
2498				endm 
# End of macro NEXTW
2498			.DROP2: 
2498				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2498 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2499 c7 24			dw .SWAP2            
249b 06				db 5 + 1 
249c .. 00			db "2DROP",0              
24a2				endm 
# End of macro CWHEAD
24a2			; | 2DROP ( w w -- )    Double drop | DONE 
24a2					if DEBUG_FORTH_WORDS_KEY 
24a2						DMARK "2DR" 
24a2 f5				push af  
24a3 3a b7 24			ld a, (.dmark)  
24a6 32 71 ee			ld (debug_mark),a  
24a9 3a b8 24			ld a, (.dmark+1)  
24ac 32 72 ee			ld (debug_mark+1),a  
24af 3a b9 24			ld a, (.dmark+2)  
24b2 32 73 ee			ld (debug_mark+2),a  
24b5 18 03			jr .pastdmark  
24b7 ..			.dmark: db "2DR"  
24ba f1			.pastdmark: pop af  
24bb			endm  
# End of macro DMARK
24bb						CALLMONITOR 
24bb cd ae 15			call break_point_state  
24be				endm  
# End of macro CALLMONITOR
24be					endif 
24be					FORTH_DSP_POP 
24be cd ce 1e			call macro_forth_dsp_pop 
24c1				endm 
# End of macro FORTH_DSP_POP
24c1					FORTH_DSP_POP 
24c1 cd ce 1e			call macro_forth_dsp_pop 
24c4				endm 
# End of macro FORTH_DSP_POP
24c4					NEXTW 
24c4 c3 cc 1f			jp macro_next 
24c7				endm 
# End of macro NEXTW
24c7			.SWAP2: 
24c7				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24c7 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24c8 f0 24			dw .AT            
24ca 06				db 5 + 1 
24cb .. 00			db "2SWAP",0              
24d1				endm 
# End of macro CWHEAD
24d1			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
24d1					if DEBUG_FORTH_WORDS_KEY 
24d1						DMARK "2SW" 
24d1 f5				push af  
24d2 3a e6 24			ld a, (.dmark)  
24d5 32 71 ee			ld (debug_mark),a  
24d8 3a e7 24			ld a, (.dmark+1)  
24db 32 72 ee			ld (debug_mark+1),a  
24de 3a e8 24			ld a, (.dmark+2)  
24e1 32 73 ee			ld (debug_mark+2),a  
24e4 18 03			jr .pastdmark  
24e6 ..			.dmark: db "2SW"  
24e9 f1			.pastdmark: pop af  
24ea			endm  
# End of macro DMARK
24ea						CALLMONITOR 
24ea cd ae 15			call break_point_state  
24ed				endm  
# End of macro CALLMONITOR
24ed					endif 
24ed					NEXTW 
24ed c3 cc 1f			jp macro_next 
24f0				endm 
# End of macro NEXTW
24f0			.AT: 
24f0				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
24f0 1f				db WORD_SYS_CORE+OPCODE_AT             
24f1 22 25			dw .CAT            
24f3 02				db 1 + 1 
24f4 .. 00			db "@",0              
24f6				endm 
# End of macro CWHEAD
24f6			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
24f6			 
24f6					if DEBUG_FORTH_WORDS_KEY 
24f6						DMARK "AT." 
24f6 f5				push af  
24f7 3a 0b 25			ld a, (.dmark)  
24fa 32 71 ee			ld (debug_mark),a  
24fd 3a 0c 25			ld a, (.dmark+1)  
2500 32 72 ee			ld (debug_mark+1),a  
2503 3a 0d 25			ld a, (.dmark+2)  
2506 32 73 ee			ld (debug_mark+2),a  
2509 18 03			jr .pastdmark  
250b ..			.dmark: db "AT."  
250e f1			.pastdmark: pop af  
250f			endm  
# End of macro DMARK
250f						CALLMONITOR 
250f cd ae 15			call break_point_state  
2512				endm  
# End of macro CALLMONITOR
2512					endif 
2512			.getbyteat:	 
2512					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2512 cd 16 1e			call macro_dsp_valuehl 
2515				endm 
# End of macro FORTH_DSP_VALUEHL
2515					 
2515			;		push hl 
2515				 
2515					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2515 cd ce 1e			call macro_forth_dsp_pop 
2518				endm 
# End of macro FORTH_DSP_POP
2518			 
2518			;		pop hl 
2518			 
2518 7e					ld a, (hl) 
2519			 
2519 6f					ld l, a 
251a 26 00				ld h, 0 
251c cd 1f 1c				call forth_push_numhl 
251f			 
251f					NEXTW 
251f c3 cc 1f			jp macro_next 
2522				endm 
# End of macro NEXTW
2522			.CAT: 
2522				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2522 20				db WORD_SYS_CORE+OPCODE_CAT             
2523 4b 25			dw .BANG            
2525 03				db 2 + 1 
2526 .. 00			db "C@",0              
2529				endm 
# End of macro CWHEAD
2529			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2529					if DEBUG_FORTH_WORDS_KEY 
2529						DMARK "CAA" 
2529 f5				push af  
252a 3a 3e 25			ld a, (.dmark)  
252d 32 71 ee			ld (debug_mark),a  
2530 3a 3f 25			ld a, (.dmark+1)  
2533 32 72 ee			ld (debug_mark+1),a  
2536 3a 40 25			ld a, (.dmark+2)  
2539 32 73 ee			ld (debug_mark+2),a  
253c 18 03			jr .pastdmark  
253e ..			.dmark: db "CAA"  
2541 f1			.pastdmark: pop af  
2542			endm  
# End of macro DMARK
2542						CALLMONITOR 
2542 cd ae 15			call break_point_state  
2545				endm  
# End of macro CALLMONITOR
2545					endif 
2545 c3 12 25				jp .getbyteat 
2548					NEXTW 
2548 c3 cc 1f			jp macro_next 
254b				endm 
# End of macro NEXTW
254b			.BANG: 
254b				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
254b 21				db WORD_SYS_CORE+OPCODE_BANG             
254c 81 25			dw .CBANG            
254e 02				db 1 + 1 
254f .. 00			db "!",0              
2551				endm 
# End of macro CWHEAD
2551			; | ! ( x w -- ) Store x at address w      | DONE 
2551					if DEBUG_FORTH_WORDS_KEY 
2551						DMARK "BNG" 
2551 f5				push af  
2552 3a 66 25			ld a, (.dmark)  
2555 32 71 ee			ld (debug_mark),a  
2558 3a 67 25			ld a, (.dmark+1)  
255b 32 72 ee			ld (debug_mark+1),a  
255e 3a 68 25			ld a, (.dmark+2)  
2561 32 73 ee			ld (debug_mark+2),a  
2564 18 03			jr .pastdmark  
2566 ..			.dmark: db "BNG"  
2569 f1			.pastdmark: pop af  
256a			endm  
# End of macro DMARK
256a						CALLMONITOR 
256a cd ae 15			call break_point_state  
256d				endm  
# End of macro CALLMONITOR
256d					endif 
256d			 
256d			.storebyteat:		 
256d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
256d cd 16 1e			call macro_dsp_valuehl 
2570				endm 
# End of macro FORTH_DSP_VALUEHL
2570					 
2570 e5					push hl 
2571				 
2571					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2571 cd ce 1e			call macro_forth_dsp_pop 
2574				endm 
# End of macro FORTH_DSP_POP
2574			 
2574					; get byte to poke 
2574			 
2574					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2574 cd 16 1e			call macro_dsp_valuehl 
2577				endm 
# End of macro FORTH_DSP_VALUEHL
2577 e5					push hl 
2578			 
2578			 
2578					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2578 cd ce 1e			call macro_forth_dsp_pop 
257b				endm 
# End of macro FORTH_DSP_POP
257b			 
257b			 
257b d1					pop de 
257c e1					pop hl 
257d			 
257d 73					ld (hl),e 
257e			 
257e			 
257e					NEXTW 
257e c3 cc 1f			jp macro_next 
2581				endm 
# End of macro NEXTW
2581			.CBANG: 
2581				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2581 22				db WORD_SYS_CORE+OPCODE_CBANG             
2582 aa 25			dw .SCALL            
2584 03				db 2 + 1 
2585 .. 00			db "C!",0              
2588				endm 
# End of macro CWHEAD
2588			; | C!  ( x w -- ) Store x at address w  | DONE 
2588					if DEBUG_FORTH_WORDS_KEY 
2588						DMARK "CBA" 
2588 f5				push af  
2589 3a 9d 25			ld a, (.dmark)  
258c 32 71 ee			ld (debug_mark),a  
258f 3a 9e 25			ld a, (.dmark+1)  
2592 32 72 ee			ld (debug_mark+1),a  
2595 3a 9f 25			ld a, (.dmark+2)  
2598 32 73 ee			ld (debug_mark+2),a  
259b 18 03			jr .pastdmark  
259d ..			.dmark: db "CBA"  
25a0 f1			.pastdmark: pop af  
25a1			endm  
# End of macro DMARK
25a1						CALLMONITOR 
25a1 cd ae 15			call break_point_state  
25a4				endm  
# End of macro CALLMONITOR
25a4					endif 
25a4 c3 6d 25				jp .storebyteat 
25a7					NEXTW 
25a7 c3 cc 1f			jp macro_next 
25aa				endm 
# End of macro NEXTW
25aa			.SCALL: 
25aa				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25aa 23				db WORD_SYS_CORE+OPCODE_SCALL             
25ab de 25			dw .DEPTH            
25ad 05				db 4 + 1 
25ae .. 00			db "CALL",0              
25b3				endm 
# End of macro CWHEAD
25b3			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25b3					if DEBUG_FORTH_WORDS_KEY 
25b3						DMARK "CLL" 
25b3 f5				push af  
25b4 3a c8 25			ld a, (.dmark)  
25b7 32 71 ee			ld (debug_mark),a  
25ba 3a c9 25			ld a, (.dmark+1)  
25bd 32 72 ee			ld (debug_mark+1),a  
25c0 3a ca 25			ld a, (.dmark+2)  
25c3 32 73 ee			ld (debug_mark+2),a  
25c6 18 03			jr .pastdmark  
25c8 ..			.dmark: db "CLL"  
25cb f1			.pastdmark: pop af  
25cc			endm  
# End of macro DMARK
25cc						CALLMONITOR 
25cc cd ae 15			call break_point_state  
25cf				endm  
# End of macro CALLMONITOR
25cf					endif 
25cf			 
25cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25cf cd 16 1e			call macro_dsp_valuehl 
25d2				endm 
# End of macro FORTH_DSP_VALUEHL
25d2			 
25d2			;		push hl 
25d2			 
25d2					; destroy value TOS 
25d2			 
25d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d2 cd ce 1e			call macro_forth_dsp_pop 
25d5				endm 
# End of macro FORTH_DSP_POP
25d5			 
25d5						 
25d5			;		pop hl 
25d5			 
25d5					; how to do a call with hl???? save SP? 
25d5 cd 70 1f				call forth_call_hl 
25d8			 
25d8			 
25d8					; TODO push value back onto stack for another op etc 
25d8			 
25d8 cd 1f 1c				call forth_push_numhl 
25db					NEXTW 
25db c3 cc 1f			jp macro_next 
25de				endm 
# End of macro NEXTW
25de			.DEPTH: 
25de				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
25de 24				db WORD_SYS_CORE+OPCODE_DEPTH             
25df 1b 26			dw .OVER            
25e1 06				db 5 + 1 
25e2 .. 00			db "DEPTH",0              
25e8				endm 
# End of macro CWHEAD
25e8			; | DEPTH ( -- u ) Push count of stack | DONE 
25e8					; take current TOS and remove from base value div by two to get count 
25e8					if DEBUG_FORTH_WORDS_KEY 
25e8						DMARK "DEP" 
25e8 f5				push af  
25e9 3a fd 25			ld a, (.dmark)  
25ec 32 71 ee			ld (debug_mark),a  
25ef 3a fe 25			ld a, (.dmark+1)  
25f2 32 72 ee			ld (debug_mark+1),a  
25f5 3a ff 25			ld a, (.dmark+2)  
25f8 32 73 ee			ld (debug_mark+2),a  
25fb 18 03			jr .pastdmark  
25fd ..			.dmark: db "DEP"  
2600 f1			.pastdmark: pop af  
2601			endm  
# End of macro DMARK
2601						CALLMONITOR 
2601 cd ae 15			call break_point_state  
2604				endm  
# End of macro CALLMONITOR
2604					endif 
2604			 
2604			 
2604 2a f8 e9			ld hl, (cli_data_sp) 
2607 11 32 e8			ld de, cli_data_stack 
260a ed 52			sbc hl,de 
260c				 
260c				; div by size of stack item 
260c			 
260c 5d				ld e,l 
260d 0e 03			ld c, 3 
260f cd 3d 0d			call Div8 
2612			 
2612 6f				ld l,a 
2613 26 00			ld h,0 
2615			 
2615				;srl h 
2615				;rr l 
2615			 
2615 cd 1f 1c				call forth_push_numhl 
2618					NEXTW 
2618 c3 cc 1f			jp macro_next 
261b				endm 
# End of macro NEXTW
261b			.OVER: 
261b				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
261b 42				db WORD_SYS_CORE+46             
261c 62 26			dw .PAUSE            
261e 05				db 4 + 1 
261f .. 00			db "OVER",0              
2624				endm 
# End of macro CWHEAD
2624			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2624					if DEBUG_FORTH_WORDS_KEY 
2624						DMARK "OVR" 
2624 f5				push af  
2625 3a 39 26			ld a, (.dmark)  
2628 32 71 ee			ld (debug_mark),a  
262b 3a 3a 26			ld a, (.dmark+1)  
262e 32 72 ee			ld (debug_mark+1),a  
2631 3a 3b 26			ld a, (.dmark+2)  
2634 32 73 ee			ld (debug_mark+2),a  
2637 18 03			jr .pastdmark  
2639 ..			.dmark: db "OVR"  
263c f1			.pastdmark: pop af  
263d			endm  
# End of macro DMARK
263d						CALLMONITOR 
263d cd ae 15			call break_point_state  
2640				endm  
# End of macro CALLMONITOR
2640					endif 
2640			 
2640					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2640 cd 16 1e			call macro_dsp_valuehl 
2643				endm 
# End of macro FORTH_DSP_VALUEHL
2643 e5					push hl    ; n2 
2644					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2644 cd ce 1e			call macro_forth_dsp_pop 
2647				endm 
# End of macro FORTH_DSP_POP
2647			 
2647					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2647 cd 16 1e			call macro_dsp_valuehl 
264a				endm 
# End of macro FORTH_DSP_VALUEHL
264a e5					push hl    ; n1 
264b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
264b cd ce 1e			call macro_forth_dsp_pop 
264e				endm 
# End of macro FORTH_DSP_POP
264e			 
264e d1					pop de     ; n1 
264f e1					pop hl     ; n2 
2650			 
2650 d5					push de 
2651 e5					push hl 
2652 d5					push de 
2653			 
2653					; push back  
2653			 
2653 e1					pop hl 
2654 cd 1f 1c				call forth_push_numhl 
2657 e1					pop hl 
2658 cd 1f 1c				call forth_push_numhl 
265b e1					pop hl 
265c cd 1f 1c				call forth_push_numhl 
265f					NEXTW 
265f c3 cc 1f			jp macro_next 
2662				endm 
# End of macro NEXTW
2662			 
2662			.PAUSE: 
2662				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2662 43				db WORD_SYS_CORE+47             
2663 97 26			dw .PAUSES            
2665 08				db 7 + 1 
2666 .. 00			db "PAUSEMS",0              
266e				endm 
# End of macro CWHEAD
266e			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
266e					if DEBUG_FORTH_WORDS_KEY 
266e						DMARK "PMS" 
266e f5				push af  
266f 3a 83 26			ld a, (.dmark)  
2672 32 71 ee			ld (debug_mark),a  
2675 3a 84 26			ld a, (.dmark+1)  
2678 32 72 ee			ld (debug_mark+1),a  
267b 3a 85 26			ld a, (.dmark+2)  
267e 32 73 ee			ld (debug_mark+2),a  
2681 18 03			jr .pastdmark  
2683 ..			.dmark: db "PMS"  
2686 f1			.pastdmark: pop af  
2687			endm  
# End of macro DMARK
2687						CALLMONITOR 
2687 cd ae 15			call break_point_state  
268a				endm  
# End of macro CALLMONITOR
268a					endif 
268a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
268a cd 16 1e			call macro_dsp_valuehl 
268d				endm 
# End of macro FORTH_DSP_VALUEHL
268d			;		push hl    ; n2 
268d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
268d cd ce 1e			call macro_forth_dsp_pop 
2690				endm 
# End of macro FORTH_DSP_POP
2690			;		pop hl 
2690			 
2690 7d					ld a, l 
2691 cd d7 0a				call aDelayInMS 
2694				       NEXTW 
2694 c3 cc 1f			jp macro_next 
2697				endm 
# End of macro NEXTW
2697			.PAUSES:  
2697				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2697 44				db WORD_SYS_CORE+48             
2698 06 27			dw .ROT            
269a 06				db 5 + 1 
269b .. 00			db "PAUSE",0              
26a1				endm 
# End of macro CWHEAD
26a1			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26a1					if DEBUG_FORTH_WORDS_KEY 
26a1						DMARK "PAU" 
26a1 f5				push af  
26a2 3a b6 26			ld a, (.dmark)  
26a5 32 71 ee			ld (debug_mark),a  
26a8 3a b7 26			ld a, (.dmark+1)  
26ab 32 72 ee			ld (debug_mark+1),a  
26ae 3a b8 26			ld a, (.dmark+2)  
26b1 32 73 ee			ld (debug_mark+2),a  
26b4 18 03			jr .pastdmark  
26b6 ..			.dmark: db "PAU"  
26b9 f1			.pastdmark: pop af  
26ba			endm  
# End of macro DMARK
26ba						CALLMONITOR 
26ba cd ae 15			call break_point_state  
26bd				endm  
# End of macro CALLMONITOR
26bd					endif 
26bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bd cd 16 1e			call macro_dsp_valuehl 
26c0				endm 
# End of macro FORTH_DSP_VALUEHL
26c0			;		push hl    ; n2 
26c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c0 cd ce 1e			call macro_forth_dsp_pop 
26c3				endm 
# End of macro FORTH_DSP_POP
26c3			;		pop hl 
26c3 45					ld b, l 
26c4					if DEBUG_FORTH_WORDS 
26c4						DMARK "PAU" 
26c4 f5				push af  
26c5 3a d9 26			ld a, (.dmark)  
26c8 32 71 ee			ld (debug_mark),a  
26cb 3a da 26			ld a, (.dmark+1)  
26ce 32 72 ee			ld (debug_mark+1),a  
26d1 3a db 26			ld a, (.dmark+2)  
26d4 32 73 ee			ld (debug_mark+2),a  
26d7 18 03			jr .pastdmark  
26d9 ..			.dmark: db "PAU"  
26dc f1			.pastdmark: pop af  
26dd			endm  
# End of macro DMARK
26dd						CALLMONITOR 
26dd cd ae 15			call break_point_state  
26e0				endm  
# End of macro CALLMONITOR
26e0					endif 
26e0 c5			.pauses1:	push bc 
26e1 cd f2 0a				call delay1s 
26e4 c1					pop bc 
26e5					if DEBUG_FORTH_WORDS 
26e5						DMARK "PA1" 
26e5 f5				push af  
26e6 3a fa 26			ld a, (.dmark)  
26e9 32 71 ee			ld (debug_mark),a  
26ec 3a fb 26			ld a, (.dmark+1)  
26ef 32 72 ee			ld (debug_mark+1),a  
26f2 3a fc 26			ld a, (.dmark+2)  
26f5 32 73 ee			ld (debug_mark+2),a  
26f8 18 03			jr .pastdmark  
26fa ..			.dmark: db "PA1"  
26fd f1			.pastdmark: pop af  
26fe			endm  
# End of macro DMARK
26fe						CALLMONITOR 
26fe cd ae 15			call break_point_state  
2701				endm  
# End of macro CALLMONITOR
2701					endif 
2701 10 dd				djnz .pauses1 
2703			 
2703				       NEXTW 
2703 c3 cc 1f			jp macro_next 
2706				endm 
# End of macro NEXTW
2706			.ROT: 
2706				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2706 45				db WORD_SYS_CORE+49             
2707 54 27			dw .UWORDS            
2709 04				db 3 + 1 
270a .. 00			db "ROT",0              
270e				endm 
# End of macro CWHEAD
270e			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
270e					if DEBUG_FORTH_WORDS_KEY 
270e						DMARK "ROT" 
270e f5				push af  
270f 3a 23 27			ld a, (.dmark)  
2712 32 71 ee			ld (debug_mark),a  
2715 3a 24 27			ld a, (.dmark+1)  
2718 32 72 ee			ld (debug_mark+1),a  
271b 3a 25 27			ld a, (.dmark+2)  
271e 32 73 ee			ld (debug_mark+2),a  
2721 18 03			jr .pastdmark  
2723 ..			.dmark: db "ROT"  
2726 f1			.pastdmark: pop af  
2727			endm  
# End of macro DMARK
2727						CALLMONITOR 
2727 cd ae 15			call break_point_state  
272a				endm  
# End of macro CALLMONITOR
272a					endif 
272a			 
272a					FORTH_DSP_VALUEHL 
272a cd 16 1e			call macro_dsp_valuehl 
272d				endm 
# End of macro FORTH_DSP_VALUEHL
272d e5					push hl    ; u3  
272e			 
272e					FORTH_DSP_POP 
272e cd ce 1e			call macro_forth_dsp_pop 
2731				endm 
# End of macro FORTH_DSP_POP
2731			   
2731					FORTH_DSP_VALUEHL 
2731 cd 16 1e			call macro_dsp_valuehl 
2734				endm 
# End of macro FORTH_DSP_VALUEHL
2734 e5					push hl     ; u2 
2735			 
2735					FORTH_DSP_POP 
2735 cd ce 1e			call macro_forth_dsp_pop 
2738				endm 
# End of macro FORTH_DSP_POP
2738			 
2738					FORTH_DSP_VALUEHL 
2738 cd 16 1e			call macro_dsp_valuehl 
273b				endm 
# End of macro FORTH_DSP_VALUEHL
273b e5					push hl     ; u1 
273c			 
273c					FORTH_DSP_POP 
273c cd ce 1e			call macro_forth_dsp_pop 
273f				endm 
# End of macro FORTH_DSP_POP
273f			 
273f c1					pop bc      ; u1 
2740 e1					pop hl      ; u2 
2741 d1					pop de      ; u3 
2742			 
2742			 
2742 c5					push bc 
2743 d5					push de 
2744 e5					push hl 
2745			 
2745			 
2745 e1					pop hl 
2746 cd 1f 1c				call forth_push_numhl 
2749			 
2749 e1					pop hl 
274a cd 1f 1c				call forth_push_numhl 
274d			 
274d e1					pop hl 
274e cd 1f 1c				call forth_push_numhl 
2751					 
2751			 
2751			 
2751			 
2751			 
2751			 
2751				       NEXTW 
2751 c3 cc 1f			jp macro_next 
2754				endm 
# End of macro NEXTW
2754			 
2754			.UWORDS: 
2754				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2754 50				db WORD_SYS_CORE+60             
2755 16 28			dw .BP            
2757 07				db 6 + 1 
2758 .. 00			db "UWORDS",0              
275f				endm 
# End of macro CWHEAD
275f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
275f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
275f			; | | Following the count are the individual words. 
275f			; | | 
275f			; | | e.g. UWORDS 
275f			; | | BOX DIRLIST 2 
275f			; | |  
275f			; | | Can be used to save the words to storage via: 
275f			; | | UWORDS $01 DO $01 APPEND LOOP 
275f				if DEBUG_FORTH_WORDS_KEY 
275f					DMARK "UWR" 
275f f5				push af  
2760 3a 74 27			ld a, (.dmark)  
2763 32 71 ee			ld (debug_mark),a  
2766 3a 75 27			ld a, (.dmark+1)  
2769 32 72 ee			ld (debug_mark+1),a  
276c 3a 76 27			ld a, (.dmark+2)  
276f 32 73 ee			ld (debug_mark+2),a  
2772 18 03			jr .pastdmark  
2774 ..			.dmark: db "UWR"  
2777 f1			.pastdmark: pop af  
2778			endm  
# End of macro DMARK
2778					CALLMONITOR 
2778 cd ae 15			call break_point_state  
277b				endm  
# End of macro CALLMONITOR
277b				endif 
277b 21 32 64				ld hl, baseram 
277e					;ld hl, baseusermem 
277e 01 00 00				ld bc, 0    ; start a counter 
2781			 
2781				; skip dict stub 
2781			 
2781 cd 1d 21				call forth_tok_next 
2784			 
2784			 
2784			; while we have words to look for 
2784			 
2784 7e			.douscan:	ld a, (hl)      
2785				if DEBUG_FORTH_WORDS 
2785					DMARK "UWs" 
2785 f5				push af  
2786 3a 9a 27			ld a, (.dmark)  
2789 32 71 ee			ld (debug_mark),a  
278c 3a 9b 27			ld a, (.dmark+1)  
278f 32 72 ee			ld (debug_mark+1),a  
2792 3a 9c 27			ld a, (.dmark+2)  
2795 32 73 ee			ld (debug_mark+2),a  
2798 18 03			jr .pastdmark  
279a ..			.dmark: db "UWs"  
279d f1			.pastdmark: pop af  
279e			endm  
# End of macro DMARK
279e					CALLMONITOR 
279e cd ae 15			call break_point_state  
27a1				endm  
# End of macro CALLMONITOR
27a1				endif 
27a1 fe 00				cp WORD_SYS_END 
27a3 28 4d				jr z, .udone 
27a5 fe 01				cp WORD_SYS_UWORD 
27a7 20 44				jr nz, .nuword 
27a9			 
27a9				if DEBUG_FORTH_WORDS 
27a9					DMARK "UWu" 
27a9 f5				push af  
27aa 3a be 27			ld a, (.dmark)  
27ad 32 71 ee			ld (debug_mark),a  
27b0 3a bf 27			ld a, (.dmark+1)  
27b3 32 72 ee			ld (debug_mark+1),a  
27b6 3a c0 27			ld a, (.dmark+2)  
27b9 32 73 ee			ld (debug_mark+2),a  
27bc 18 03			jr .pastdmark  
27be ..			.dmark: db "UWu"  
27c1 f1			.pastdmark: pop af  
27c2			endm  
# End of macro DMARK
27c2					CALLMONITOR 
27c2 cd ae 15			call break_point_state  
27c5				endm  
# End of macro CALLMONITOR
27c5				endif 
27c5					; we have a uword so push its name to the stack 
27c5			 
27c5 e5				   	push hl  ; save so we can move to next dict block 
27c6			 
27c6					; skip opcode 
27c6 23					inc hl  
27c7					; skip next ptr 
27c7 23					inc hl  
27c8 23					inc hl 
27c9					; skip len 
27c9 23					inc hl 
27ca				if DEBUG_FORTH_WORDS 
27ca					DMARK "UWt" 
27ca f5				push af  
27cb 3a df 27			ld a, (.dmark)  
27ce 32 71 ee			ld (debug_mark),a  
27d1 3a e0 27			ld a, (.dmark+1)  
27d4 32 72 ee			ld (debug_mark+1),a  
27d7 3a e1 27			ld a, (.dmark+2)  
27da 32 73 ee			ld (debug_mark+2),a  
27dd 18 03			jr .pastdmark  
27df ..			.dmark: db "UWt"  
27e2 f1			.pastdmark: pop af  
27e3			endm  
# End of macro DMARK
27e3					CALLMONITOR 
27e3 cd ae 15			call break_point_state  
27e6				endm  
# End of macro CALLMONITOR
27e6				endif 
27e6 03					inc bc 
27e7			 
27e7 c5					push bc 
27e8 cd 8d 1c				call forth_push_str 
27eb c1					pop bc 
27ec			 
27ec e1					pop hl 	 
27ed			 
27ed cd 1d 21		.nuword:	call forth_tok_next 
27f0 18 92				jr .douscan  
27f2			 
27f2			.udone:		 ; push count of uwords found 
27f2 c5					push bc 
27f3 e1					pop hl 
27f4			 
27f4				if DEBUG_FORTH_WORDS 
27f4					DMARK "UWc" 
27f4 f5				push af  
27f5 3a 09 28			ld a, (.dmark)  
27f8 32 71 ee			ld (debug_mark),a  
27fb 3a 0a 28			ld a, (.dmark+1)  
27fe 32 72 ee			ld (debug_mark+1),a  
2801 3a 0b 28			ld a, (.dmark+2)  
2804 32 73 ee			ld (debug_mark+2),a  
2807 18 03			jr .pastdmark  
2809 ..			.dmark: db "UWc"  
280c f1			.pastdmark: pop af  
280d			endm  
# End of macro DMARK
280d					CALLMONITOR 
280d cd ae 15			call break_point_state  
2810				endm  
# End of macro CALLMONITOR
2810				endif 
2810 cd 1f 1c				call forth_push_numhl 
2813			 
2813			 
2813				       NEXTW 
2813 c3 cc 1f			jp macro_next 
2816				endm 
# End of macro NEXTW
2816			 
2816			.BP: 
2816				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2816 54				db WORD_SYS_CORE+64             
2817 4c 28			dw .MONITOR            
2819 03				db 2 + 1 
281a .. 00			db "BP",0              
281d				endm 
# End of macro CWHEAD
281d			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
281d			; | | $00 Will enable the break points within specific code paths 
281d			; | | $01 Will disable break points 
281d			; | |  
281d			; | | By default break points are off. Either the above can be used to enable them 
281d			; | | or if a key is held down during start up the spashscreen will appear to freeze 
281d			; | | and on release of the pressed key a message will be disaplayed to notify 
281d			; | | that break points are enabled. Pressing any key will then continue boot process. 
281d					; get byte count 
281d					if DEBUG_FORTH_WORDS_KEY 
281d						DMARK "BP." 
281d f5				push af  
281e 3a 32 28			ld a, (.dmark)  
2821 32 71 ee			ld (debug_mark),a  
2824 3a 33 28			ld a, (.dmark+1)  
2827 32 72 ee			ld (debug_mark+1),a  
282a 3a 34 28			ld a, (.dmark+2)  
282d 32 73 ee			ld (debug_mark+2),a  
2830 18 03			jr .pastdmark  
2832 ..			.dmark: db "BP."  
2835 f1			.pastdmark: pop af  
2836			endm  
# End of macro DMARK
2836						CALLMONITOR 
2836 cd ae 15			call break_point_state  
2839				endm  
# End of macro CALLMONITOR
2839					endif 
2839			 
2839					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2839 cd 16 1e			call macro_dsp_valuehl 
283c				endm 
# End of macro FORTH_DSP_VALUEHL
283c			 
283c			;		push hl 
283c			 
283c					; destroy value TOS 
283c			 
283c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
283c cd ce 1e			call macro_forth_dsp_pop 
283f				endm 
# End of macro FORTH_DSP_POP
283f			 
283f			;		pop hl 
283f			 
283f 3e 00				ld a,0 
2841 bd					cp l 
2842 28 02				jr z, .bpset 
2844 3e 2a				ld a, '*' 
2846			 
2846 32 bc e2		.bpset:		ld (os_view_disable), a 
2849			 
2849			 
2849					NEXTW 
2849 c3 cc 1f			jp macro_next 
284c				endm 
# End of macro NEXTW
284c			 
284c			 
284c			.MONITOR: 
284c				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
284c 55				db WORD_SYS_CORE+65             
284d 7f 28			dw .MALLOC            
284f 08				db 7 + 1 
2850 .. 00			db "MONITOR",0              
2858				endm 
# End of macro CWHEAD
2858			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2858			; | | At start the current various registers will be displayed with contents. 
2858			; | | Top right corner will show the most recent debug marker seen. 
2858			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2858			; | | and the return stack pointer (RSP). 
2858			; | | Pressing: 
2858			; | |    1 - Initial screen 
2858			; | |    2 - Display a data dump of HL 
2858			; | |    3 - Display a data dump of DE 
2858			; | |    4 - Display a data dump of BC 
2858			; | |    5 - Display a data dump of HL 
2858			; | |    6 - Display a data dump of DSP 
2858			; | |    7 - Display a data dump of RSP 
2858			; | |    8 - Display a data dump of what is at DSP 
2858			; | |    9 - Display a data dump of what is at RSP 
2858			; | |    0 - Exit monitor and continue running. This will also enable break points 
2858			; | |    * - Disable break points 
2858			; | |    # - Enter traditional monitor mode 
2858			; | | 
2858			; | | Monitor Mode 
2858			; | | ------------ 
2858			; | | A prompt of '>' will be shown for various commands: 
2858			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2858			; | |    C - Continue display a data dump from the last set address 
2858			; | |    M xxxx - Set start of memory edit at address xx 
2858			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2858			; | |    Q - Return to previous 
2858					if DEBUG_FORTH_WORDS_KEY 
2858						DMARK "MON" 
2858 f5				push af  
2859 3a 6d 28			ld a, (.dmark)  
285c 32 71 ee			ld (debug_mark),a  
285f 3a 6e 28			ld a, (.dmark+1)  
2862 32 72 ee			ld (debug_mark+1),a  
2865 3a 6f 28			ld a, (.dmark+2)  
2868 32 73 ee			ld (debug_mark+2),a  
286b 18 03			jr .pastdmark  
286d ..			.dmark: db "MON"  
2870 f1			.pastdmark: pop af  
2871			endm  
# End of macro DMARK
2871						CALLMONITOR 
2871 cd ae 15			call break_point_state  
2874				endm  
# End of macro CALLMONITOR
2874					endif 
2874 3e 00				ld a, 0 
2876 32 bc e2				ld (os_view_disable), a 
2879			 
2879					CALLMONITOR 
2879 cd ae 15			call break_point_state  
287c				endm  
# End of macro CALLMONITOR
287c			 
287c			;	call monitor 
287c			 
287c					NEXTW 
287c c3 cc 1f			jp macro_next 
287f				endm 
# End of macro NEXTW
287f			 
287f			 
287f			.MALLOC: 
287f				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
287f 56				db WORD_SYS_CORE+66             
2880 a8 28			dw .MALLOC2            
2882 06				db 5 + 1 
2883 .. 00			db "ALLOT",0              
2889				endm 
# End of macro CWHEAD
2889			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2889					if DEBUG_FORTH_WORDS_KEY 
2889						DMARK "ALL" 
2889 f5				push af  
288a 3a 9e 28			ld a, (.dmark)  
288d 32 71 ee			ld (debug_mark),a  
2890 3a 9f 28			ld a, (.dmark+1)  
2893 32 72 ee			ld (debug_mark+1),a  
2896 3a a0 28			ld a, (.dmark+2)  
2899 32 73 ee			ld (debug_mark+2),a  
289c 18 03			jr .pastdmark  
289e ..			.dmark: db "ALL"  
28a1 f1			.pastdmark: pop af  
28a2			endm  
# End of macro DMARK
28a2						CALLMONITOR 
28a2 cd ae 15			call break_point_state  
28a5				endm  
# End of macro CALLMONITOR
28a5					endif 
28a5 c3 cf 28				jp .mallocc 
28a8			.MALLOC2: 
28a8				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28a8 56				db WORD_SYS_CORE+66             
28a9 e6 28			dw .FREE            
28ab 07				db 6 + 1 
28ac .. 00			db "MALLOC",0              
28b3				endm 
# End of macro CWHEAD
28b3			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28b3					; get byte count 
28b3					if DEBUG_FORTH_WORDS_KEY 
28b3						DMARK "MAL" 
28b3 f5				push af  
28b4 3a c8 28			ld a, (.dmark)  
28b7 32 71 ee			ld (debug_mark),a  
28ba 3a c9 28			ld a, (.dmark+1)  
28bd 32 72 ee			ld (debug_mark+1),a  
28c0 3a ca 28			ld a, (.dmark+2)  
28c3 32 73 ee			ld (debug_mark+2),a  
28c6 18 03			jr .pastdmark  
28c8 ..			.dmark: db "MAL"  
28cb f1			.pastdmark: pop af  
28cc			endm  
# End of macro DMARK
28cc						CALLMONITOR 
28cc cd ae 15			call break_point_state  
28cf				endm  
# End of macro CALLMONITOR
28cf					endif 
28cf			.mallocc: 
28cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28cf cd 16 1e			call macro_dsp_valuehl 
28d2				endm 
# End of macro FORTH_DSP_VALUEHL
28d2			 
28d2			;		push hl 
28d2			 
28d2					; destroy value TOS 
28d2			 
28d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d2 cd ce 1e			call macro_forth_dsp_pop 
28d5				endm 
# End of macro FORTH_DSP_POP
28d5			 
28d5			;		pop hl 
28d5 cd 74 12				call malloc 
28d8				if DEBUG_FORTH_MALLOC_GUARD 
28d8 f5					push af 
28d9 cd d6 0d				call ishlzero 
28dc			;		ld a, l 
28dc			;		add h 
28dc			;		cp 0 
28dc f1					pop af 
28dd					 
28dd cc 8b 4c				call z,malloc_error 
28e0				endif 
28e0			 
28e0 cd 1f 1c				call forth_push_numhl 
28e3					NEXTW 
28e3 c3 cc 1f			jp macro_next 
28e6				endm 
# End of macro NEXTW
28e6			 
28e6			.FREE: 
28e6				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
28e6 57				db WORD_SYS_CORE+67             
28e7 17 29			dw .LIST            
28e9 05				db 4 + 1 
28ea .. 00			db "FREE",0              
28ef				endm 
# End of macro CWHEAD
28ef			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
28ef					if DEBUG_FORTH_WORDS_KEY 
28ef						DMARK "FRE" 
28ef f5				push af  
28f0 3a 04 29			ld a, (.dmark)  
28f3 32 71 ee			ld (debug_mark),a  
28f6 3a 05 29			ld a, (.dmark+1)  
28f9 32 72 ee			ld (debug_mark+1),a  
28fc 3a 06 29			ld a, (.dmark+2)  
28ff 32 73 ee			ld (debug_mark+2),a  
2902 18 03			jr .pastdmark  
2904 ..			.dmark: db "FRE"  
2907 f1			.pastdmark: pop af  
2908			endm  
# End of macro DMARK
2908						CALLMONITOR 
2908 cd ae 15			call break_point_state  
290b				endm  
# End of macro CALLMONITOR
290b					endif 
290b					; get address 
290b			 
290b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
290b cd 16 1e			call macro_dsp_valuehl 
290e				endm 
# End of macro FORTH_DSP_VALUEHL
290e			 
290e			;		push hl 
290e			 
290e					; destroy value TOS 
290e			 
290e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
290e cd ce 1e			call macro_forth_dsp_pop 
2911				endm 
# End of macro FORTH_DSP_POP
2911			 
2911			;		pop hl 
2911			if FORTH_ENABLE_MALLOCFREE 
2911 cd 3e 13				call free 
2914			endif 
2914					NEXTW 
2914 c3 cc 1f			jp macro_next 
2917				endm 
# End of macro NEXTW
2917			.LIST: 
2917				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2917 5c				db WORD_SYS_CORE+72             
2918 05 2b			dw .FORGET            
291a 05				db 4 + 1 
291b .. 00			db "LIST",0              
2920				endm 
# End of macro CWHEAD
2920			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2920			; | | The quoted word must be in upper case. 
2920				if DEBUG_FORTH_WORDS_KEY 
2920					DMARK "LST" 
2920 f5				push af  
2921 3a 35 29			ld a, (.dmark)  
2924 32 71 ee			ld (debug_mark),a  
2927 3a 36 29			ld a, (.dmark+1)  
292a 32 72 ee			ld (debug_mark+1),a  
292d 3a 37 29			ld a, (.dmark+2)  
2930 32 73 ee			ld (debug_mark+2),a  
2933 18 03			jr .pastdmark  
2935 ..			.dmark: db "LST"  
2938 f1			.pastdmark: pop af  
2939			endm  
# End of macro DMARK
2939					CALLMONITOR 
2939 cd ae 15			call break_point_state  
293c				endm  
# End of macro CALLMONITOR
293c				endif 
293c			 
293c					FORTH_DSP_VALUEHL 
293c cd 16 1e			call macro_dsp_valuehl 
293f				endm 
# End of macro FORTH_DSP_VALUEHL
293f			 
293f e5					push hl 
2940					FORTH_DSP_POP 
2940 cd ce 1e			call macro_forth_dsp_pop 
2943				endm 
# End of macro FORTH_DSP_POP
2943 c1					pop bc 
2944			 
2944			; Start format of scratch string 
2944			 
2944 21 cb e2				ld hl, scratch 
2947			 
2947 3e 3a				ld a, ':' 
2949 77					ld (hl),a 
294a 23					inc hl 
294b 3e 20				ld a, ' ' 
294d 77					ld (hl), a 
294e			 
294e					; Get ptr to the word we need to look up 
294e			 
294e			;		FORTH_DSP_VALUEHL 
294e					;v5 FORTH_DSP_VALUE 
294e				; TODO type check 
294e			;		inc hl    ; Skip type check  
294e			;		push hl 
294e			;		ex de, hl    ; put into DE 
294e			 
294e			 
294e 21 32 64				ld hl, baseram 
2951					;ld hl, baseusermem 
2951			 
2951 e5			push hl   ; sacreifical push 
2952			 
2952			.ldouscanm: 
2952 e1				pop hl 
2953			.ldouscan: 
2953				if DEBUG_FORTH_WORDS 
2953					DMARK "LSs" 
2953 f5				push af  
2954 3a 68 29			ld a, (.dmark)  
2957 32 71 ee			ld (debug_mark),a  
295a 3a 69 29			ld a, (.dmark+1)  
295d 32 72 ee			ld (debug_mark+1),a  
2960 3a 6a 29			ld a, (.dmark+2)  
2963 32 73 ee			ld (debug_mark+2),a  
2966 18 03			jr .pastdmark  
2968 ..			.dmark: db "LSs"  
296b f1			.pastdmark: pop af  
296c			endm  
# End of macro DMARK
296c					CALLMONITOR 
296c cd ae 15			call break_point_state  
296f				endm  
# End of macro CALLMONITOR
296f				endif 
296f				; skip dict stub 
296f cd 1d 21				call forth_tok_next 
2972			 
2972			 
2972			; while we have words to look for 
2972			 
2972 7e				ld a, (hl)      
2973				if DEBUG_FORTH_WORDS 
2973					DMARK "LSk" 
2973 f5				push af  
2974 3a 88 29			ld a, (.dmark)  
2977 32 71 ee			ld (debug_mark),a  
297a 3a 89 29			ld a, (.dmark+1)  
297d 32 72 ee			ld (debug_mark+1),a  
2980 3a 8a 29			ld a, (.dmark+2)  
2983 32 73 ee			ld (debug_mark+2),a  
2986 18 03			jr .pastdmark  
2988 ..			.dmark: db "LSk"  
298b f1			.pastdmark: pop af  
298c			endm  
# End of macro DMARK
298c					CALLMONITOR 
298c cd ae 15			call break_point_state  
298f				endm  
# End of macro CALLMONITOR
298f				endif 
298f					;cp WORD_SYS_END 
298f					;jp z, .lunotfound 
298f			 
298f					; if we hit non uwords then gone too far 
298f fe 01				cp WORD_SYS_UWORD 
2991 c2 c1 2a				jp nz, .lunotfound 
2994			 
2994				if DEBUG_FORTH_WORDS 
2994					DMARK "LSu" 
2994 f5				push af  
2995 3a a9 29			ld a, (.dmark)  
2998 32 71 ee			ld (debug_mark),a  
299b 3a aa 29			ld a, (.dmark+1)  
299e 32 72 ee			ld (debug_mark+1),a  
29a1 3a ab 29			ld a, (.dmark+2)  
29a4 32 73 ee			ld (debug_mark+2),a  
29a7 18 03			jr .pastdmark  
29a9 ..			.dmark: db "LSu"  
29ac f1			.pastdmark: pop af  
29ad			endm  
# End of macro DMARK
29ad					CALLMONITOR 
29ad cd ae 15			call break_point_state  
29b0				endm  
# End of macro CALLMONITOR
29b0				endif 
29b0			 
29b0					; found a uword but is it the one we want... 
29b0			 
29b0 c5					push bc     ; uword to find is on bc 
29b1 d1					pop de 
29b2			 
29b2 e5					push hl  ; to save the ptr 
29b3			 
29b3					; skip opcode 
29b3 23					inc hl  
29b4					; skip next ptr 
29b4 23					inc hl  
29b5 23					inc hl 
29b6					; skip len 
29b6 23					inc hl 
29b7			 
29b7				if DEBUG_FORTH_WORDS 
29b7					DMARK "LSc" 
29b7 f5				push af  
29b8 3a cc 29			ld a, (.dmark)  
29bb 32 71 ee			ld (debug_mark),a  
29be 3a cd 29			ld a, (.dmark+1)  
29c1 32 72 ee			ld (debug_mark+1),a  
29c4 3a ce 29			ld a, (.dmark+2)  
29c7 32 73 ee			ld (debug_mark+2),a  
29ca 18 03			jr .pastdmark  
29cc ..			.dmark: db "LSc"  
29cf f1			.pastdmark: pop af  
29d0			endm  
# End of macro DMARK
29d0					CALLMONITOR 
29d0 cd ae 15			call break_point_state  
29d3				endm  
# End of macro CALLMONITOR
29d3				endif 
29d3 cd 43 12				call strcmp 
29d6 c2 52 29				jp nz, .ldouscanm 
29d9				 
29d9			 
29d9			 
29d9					; we have a uword so push its name to the stack 
29d9			 
29d9			;	   	push hl  ; save so we can move to next dict block 
29d9 e1			pop hl 
29da			 
29da				if DEBUG_FORTH_WORDS 
29da					DMARK "LSm" 
29da f5				push af  
29db 3a ef 29			ld a, (.dmark)  
29de 32 71 ee			ld (debug_mark),a  
29e1 3a f0 29			ld a, (.dmark+1)  
29e4 32 72 ee			ld (debug_mark+1),a  
29e7 3a f1 29			ld a, (.dmark+2)  
29ea 32 73 ee			ld (debug_mark+2),a  
29ed 18 03			jr .pastdmark  
29ef ..			.dmark: db "LSm"  
29f2 f1			.pastdmark: pop af  
29f3			endm  
# End of macro DMARK
29f3					CALLMONITOR 
29f3 cd ae 15			call break_point_state  
29f6				endm  
# End of macro CALLMONITOR
29f6				endif 
29f6			 
29f6					; skip opcode 
29f6 23					inc hl  
29f7					; skip next ptr 
29f7 23					inc hl  
29f8 23					inc hl 
29f9					; skip len 
29f9 7e					ld a, (hl)   ; save length to add 
29fa				if DEBUG_FORTH_WORDS 
29fa					DMARK "LS2" 
29fa f5				push af  
29fb 3a 0f 2a			ld a, (.dmark)  
29fe 32 71 ee			ld (debug_mark),a  
2a01 3a 10 2a			ld a, (.dmark+1)  
2a04 32 72 ee			ld (debug_mark+1),a  
2a07 3a 11 2a			ld a, (.dmark+2)  
2a0a 32 73 ee			ld (debug_mark+2),a  
2a0d 18 03			jr .pastdmark  
2a0f ..			.dmark: db "LS2"  
2a12 f1			.pastdmark: pop af  
2a13			endm  
# End of macro DMARK
2a13					CALLMONITOR 
2a13 cd ae 15			call break_point_state  
2a16				endm  
# End of macro CALLMONITOR
2a16				endif 
2a16			 
2a16					; save this location 
2a16				 
2a16 e5					push hl 
2a17			 
2a17 23					inc hl 
2a18 11 cd e2				ld de, scratch+2 
2a1b 4f					ld c, a 
2a1c 06 00				ld b, 0 
2a1e			 
2a1e				if DEBUG_FORTH_WORDS 
2a1e					DMARK "LSn" 
2a1e f5				push af  
2a1f 3a 33 2a			ld a, (.dmark)  
2a22 32 71 ee			ld (debug_mark),a  
2a25 3a 34 2a			ld a, (.dmark+1)  
2a28 32 72 ee			ld (debug_mark+1),a  
2a2b 3a 35 2a			ld a, (.dmark+2)  
2a2e 32 73 ee			ld (debug_mark+2),a  
2a31 18 03			jr .pastdmark  
2a33 ..			.dmark: db "LSn"  
2a36 f1			.pastdmark: pop af  
2a37			endm  
# End of macro DMARK
2a37					CALLMONITOR 
2a37 cd ae 15			call break_point_state  
2a3a				endm  
# End of macro CALLMONITOR
2a3a				endif 
2a3a			 
2a3a					; copy uword name to scratch 
2a3a			 
2a3a ed b0				ldir 
2a3c			 
2a3c 1b					dec de 
2a3d 3e 20				ld a, ' '    ; change null to space 
2a3f 12					ld (de), a 
2a40			 
2a40 13					inc de 
2a41			 
2a41 d5					push de 
2a42 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a43			 
2a43 e1					pop hl 
2a44 7e					ld a, (hl) 
2a45					;inc hl 
2a45					; skip word string 
2a45 cd ad 0d				call addatohl 
2a48			 
2a48 23					inc hl 
2a49			 
2a49				if DEBUG_FORTH_WORDS 
2a49					DMARK "LS3" 
2a49 f5				push af  
2a4a 3a 5e 2a			ld a, (.dmark)  
2a4d 32 71 ee			ld (debug_mark),a  
2a50 3a 5f 2a			ld a, (.dmark+1)  
2a53 32 72 ee			ld (debug_mark+1),a  
2a56 3a 60 2a			ld a, (.dmark+2)  
2a59 32 73 ee			ld (debug_mark+2),a  
2a5c 18 03			jr .pastdmark  
2a5e ..			.dmark: db "LS3"  
2a61 f1			.pastdmark: pop af  
2a62			endm  
# End of macro DMARK
2a62					CALLMONITOR 
2a62 cd ae 15			call break_point_state  
2a65				endm  
# End of macro CALLMONITOR
2a65				endif 
2a65					; should now be at the start of the machine code to setup the eval of the uword 
2a65					; now locate the ptr to the string defintion 
2a65			 
2a65					; skip ld hl, 
2a65					; then load the ptr 
2a65			; TODO use get from hl ptr 
2a65 23					inc hl 
2a66 5e					ld e, (hl) 
2a67 23					inc hl 
2a68 56					ld d, (hl) 
2a69 eb					ex de, hl 
2a6a			 
2a6a			 
2a6a				if DEBUG_FORTH_WORDS 
2a6a					DMARK "LSt" 
2a6a f5				push af  
2a6b 3a 7f 2a			ld a, (.dmark)  
2a6e 32 71 ee			ld (debug_mark),a  
2a71 3a 80 2a			ld a, (.dmark+1)  
2a74 32 72 ee			ld (debug_mark+1),a  
2a77 3a 81 2a			ld a, (.dmark+2)  
2a7a 32 73 ee			ld (debug_mark+2),a  
2a7d 18 03			jr .pastdmark  
2a7f ..			.dmark: db "LSt"  
2a82 f1			.pastdmark: pop af  
2a83			endm  
# End of macro DMARK
2a83					CALLMONITOR 
2a83 cd ae 15			call break_point_state  
2a86				endm  
# End of macro CALLMONITOR
2a86				endif 
2a86			 
2a86			; cant push right now due to tokenised strings  
2a86			 
2a86			; get the destination of where to copy this definition to. 
2a86			 
2a86 c5					push bc 
2a87 d1					pop de 
2a88			 
2a88 7e			.listl:         ld a,(hl) 
2a89 fe 00				cp 0 
2a8b 28 09				jr z, .lreplsp     ; replace zero with space 
2a8d					;cp FORTH_END_BUFFER 
2a8d fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a8f 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a91				 
2a91					; just copy this char as is then 
2a91			 
2a91 12					ld (de), a 
2a92			 
2a92 23			.listnxt:	inc hl 
2a93 13					inc de 
2a94 18 f2				jr .listl 
2a96			 
2a96 3e 20		.lreplsp:	ld a,' ' 
2a98 12					ld (de), a 
2a99 18 f7				jr .listnxt 
2a9b			 
2a9b			; close up uword def 
2a9b			 
2a9b			.listdone: 
2a9b 12					ld (de), a 
2a9c 13					inc de 
2a9d 3e 00				ld a, 0 
2a9f 12					ld (de), a 
2aa0			 
2aa0			; now have def so clean up and push to stack 
2aa0			 
2aa0 21 cb e2				ld hl, scratch 
2aa3				if DEBUG_FORTH_WORDS 
2aa3					DMARK "Ltp" 
2aa3 f5				push af  
2aa4 3a b8 2a			ld a, (.dmark)  
2aa7 32 71 ee			ld (debug_mark),a  
2aaa 3a b9 2a			ld a, (.dmark+1)  
2aad 32 72 ee			ld (debug_mark+1),a  
2ab0 3a ba 2a			ld a, (.dmark+2)  
2ab3 32 73 ee			ld (debug_mark+2),a  
2ab6 18 03			jr .pastdmark  
2ab8 ..			.dmark: db "Ltp"  
2abb f1			.pastdmark: pop af  
2abc			endm  
# End of macro DMARK
2abc					CALLMONITOR 
2abc cd ae 15			call break_point_state  
2abf				endm  
# End of macro CALLMONITOR
2abf				endif 
2abf			 
2abf 18 1f			jr .listpush 
2ac1			 
2ac1			;.lnuword:	pop hl 
2ac1			;		call forth_tok_next 
2ac1			;		jp .ldouscan  
2ac1			 
2ac1			.lunotfound:		  
2ac1			 
2ac1				if DEBUG_FORTH_WORDS 
2ac1					DMARK "LSn" 
2ac1 f5				push af  
2ac2 3a d6 2a			ld a, (.dmark)  
2ac5 32 71 ee			ld (debug_mark),a  
2ac8 3a d7 2a			ld a, (.dmark+1)  
2acb 32 72 ee			ld (debug_mark+1),a  
2ace 3a d8 2a			ld a, (.dmark+2)  
2ad1 32 73 ee			ld (debug_mark+2),a  
2ad4 18 03			jr .pastdmark  
2ad6 ..			.dmark: db "LSn"  
2ad9 f1			.pastdmark: pop af  
2ada			endm  
# End of macro DMARK
2ada					CALLMONITOR 
2ada cd ae 15			call break_point_state  
2add				endm  
# End of macro CALLMONITOR
2add				endif 
2add			 
2add					 
2add			;		FORTH_DSP_POP 
2add			;		ld hl, .luno 
2add			 
2add					NEXTW			 
2add c3 cc 1f			jp macro_next 
2ae0				endm 
# End of macro NEXTW
2ae0			 
2ae0			.listpush: 
2ae0				if DEBUG_FORTH_WORDS 
2ae0					DMARK "LS>" 
2ae0 f5				push af  
2ae1 3a f5 2a			ld a, (.dmark)  
2ae4 32 71 ee			ld (debug_mark),a  
2ae7 3a f6 2a			ld a, (.dmark+1)  
2aea 32 72 ee			ld (debug_mark+1),a  
2aed 3a f7 2a			ld a, (.dmark+2)  
2af0 32 73 ee			ld (debug_mark+2),a  
2af3 18 03			jr .pastdmark  
2af5 ..			.dmark: db "LS>"  
2af8 f1			.pastdmark: pop af  
2af9			endm  
# End of macro DMARK
2af9					CALLMONITOR 
2af9 cd ae 15			call break_point_state  
2afc				endm  
# End of macro CALLMONITOR
2afc				endif 
2afc cd 8d 1c				call forth_push_str 
2aff			 
2aff			 
2aff			 
2aff					NEXTW 
2aff c3 cc 1f			jp macro_next 
2b02				endm 
# End of macro NEXTW
2b02			 
2b02			;.luno:    db "Word not found",0 
2b02			 
2b02			 
2b02			 
2b02			 
2b02			 
2b02			;		push hl   ; save pointer to start of uword def string 
2b02			; 
2b02			;; look for FORTH_EOL_LINE 
2b02			;		ld a, FORTH_END_BUFFER 
2b02			;		call strlent 
2b02			; 
2b02			;		inc hl		 ; space for coln def 
2b02			;		inc hl 
2b02			;		inc hl          ; space for terms 
2b02			;		inc hl 
2b02			; 
2b02			;		ld a, 20   ; TODO get actual length 
2b02			;		call addatohl    ; include a random amount of room for the uword name 
2b02			; 
2b02			;		 
2b02			;	if DEBUG_FORTH_WORDS 
2b02			;		DMARK "Lt1" 
2b02			;		CALLMONITOR 
2b02			;	endif 
2b02			;		 
2b02			; 
2b02			;; malloc space for the string because we cant change it 
2b02			; 
2b02			;		call malloc 
2b02			;	if DEBUG_FORTH_MALLOC_GUARD 
2b02			;		push af 
2b02			;		call ishlzero 
2b02			;		pop af 
2b02			;		 
2b02			;		call z,malloc_error 
2b02			;	endif 
2b02			; 
2b02			;	if DEBUG_FORTH_WORDS 
2b02			;		DMARK "Lt2" 
2b02			;		CALLMONITOR 
2b02			;	endif 
2b02			;		pop de 
2b02			;		push hl    ; push the malloc to release later 
2b02			;		push hl   ;  push back a copy for the later stack push 
2b02			;		 
2b02			;; copy the string swapping out the zero terms for spaces 
2b02			; 
2b02			;		; de has our source 
2b02			;		; hl has our dest 
2b02			; 
2b02			;; add the coln def 
2b02			; 
2b02			;		ld a, ':' 
2b02			;		ld (hl), a 
2b02			;		inc hl 
2b02			;		ld a, ' ' 
2b02			;		ld (hl), a 
2b02			;		inc hl 
2b02			; 
2b02			;; add the uname word 
2b02			;		push de   ; save our string for now 
2b02			;		ex de, hl 
2b02			; 
2b02			;		FORTH_DSP_VALUE 
2b02			;		;v5 FORTH_DSP_VALUE 
2b02			; 
2b02			;		inc hl   ; skip type but we know by now this is OK 
2b02			; 
2b02			;.luword:	ld a,(hl) 
2b02			;		cp 0 
2b02			;		jr z, .luword2 
2b02			;		ld (de), a 
2b02			;		inc de 
2b02			;		inc hl 
2b02			;		jr .luword 
2b02			; 
2b02			;.luword2:	ld a, ' ' 
2b02			;		ld (de), a 
2b02			;;		inc hl 
2b02			;;		inc de 
2b02			;;		ld (de), a 
2b02			;;		inc hl 
2b02			;		inc de 
2b02			; 
2b02			;		ex de, hl 
2b02			;		pop de 
2b02			;		 
2b02			;		 
2b02			; 
2b02			;; detoken that string and copy it 
2b02			; 
2b02			;	if DEBUG_FORTH_WORDS 
2b02			;		DMARK "Lt2" 
2b02			;		CALLMONITOR 
2b02			;	endif 
2b02			;.ldetok:	ld a, (de) 
2b02			;		cp FORTH_END_BUFFER 
2b02			;		jr z, .ldetokend 
2b02			;		; swap out any zero term for space 
2b02			;		cp 0 
2b02			;		jr nz, .ldetoknext 
2b02			;		ld a, ' ' 
2b02			; 
2b02			;	if DEBUG_FORTH_WORDS 
2b02			;		DMARK "LtS" 
2b02			;		CALLMONITOR 
2b02			;	endif 
2b02			;.ldetoknext:	ld (hl), a 
2b02			;		inc de 
2b02			;		inc hl 
2b02			;		jr .ldetok 
2b02			; 
2b02			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b02			;		ld (hl), a  
2b02			; 
2b02			;; free that temp malloc 
2b02			; 
2b02			;		pop hl    
2b02			; 
2b02			;	if DEBUG_FORTH_WORDS 
2b02			;		DMARK "Lt4" 
2b02			;		CALLMONITOR 
2b02			;	endif 
2b02			;		call forth_apushstrhl 
2b02			; 
2b02			;		; get rid of temp malloc area 
2b02			; 
2b02			;		pop hl 
2b02			;		call free 
2b02			; 
2b02			;		jr .ludone 
2b02			; 
2b02			;.lnuword:	pop hl 
2b02			;		call forth_tok_next 
2b02			;		jp .ldouscan  
2b02			; 
2b02			;.ludone:		 pop hl 
2b02			; 
2b02					NEXTW 
2b02 c3 cc 1f			jp macro_next 
2b05				endm 
# End of macro NEXTW
2b05			 
2b05			.FORGET: 
2b05				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b05 5d				db WORD_SYS_CORE+73             
2b06 7e 2b			dw .NOP            
2b08 07				db 6 + 1 
2b09 .. 00			db "FORGET",0              
2b10				endm 
# End of macro CWHEAD
2b10			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b10			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b10			; | |  
2b10			; | | e.g. "MORE" forget 
2b10					if DEBUG_FORTH_WORDS_KEY 
2b10						DMARK "FRG" 
2b10 f5				push af  
2b11 3a 25 2b			ld a, (.dmark)  
2b14 32 71 ee			ld (debug_mark),a  
2b17 3a 26 2b			ld a, (.dmark+1)  
2b1a 32 72 ee			ld (debug_mark+1),a  
2b1d 3a 27 2b			ld a, (.dmark+2)  
2b20 32 73 ee			ld (debug_mark+2),a  
2b23 18 03			jr .pastdmark  
2b25 ..			.dmark: db "FRG"  
2b28 f1			.pastdmark: pop af  
2b29			endm  
# End of macro DMARK
2b29						CALLMONITOR 
2b29 cd ae 15			call break_point_state  
2b2c				endm  
# End of macro CALLMONITOR
2b2c					endif 
2b2c			 
2b2c				; find uword 
2b2c			        ; update start of word with "_" 
2b2c				; replace uword with deleted flag 
2b2c			 
2b2c			 
2b2c			;	if DEBUG_FORTH_WORDS 
2b2c			;		DMARK "FOG" 
2b2c			;		CALLMONITOR 
2b2c			;	endif 
2b2c			 
2b2c			 
2b2c					; Get ptr to the word we need to look up 
2b2c			 
2b2c					FORTH_DSP_VALUEHL 
2b2c cd 16 1e			call macro_dsp_valuehl 
2b2f				endm 
# End of macro FORTH_DSP_VALUEHL
2b2f					;v5 FORTH_DSP_VALUE 
2b2f				; TODO type check 
2b2f			;		inc hl    ; Skip type check  
2b2f e5					push hl 
2b30 c1					pop bc 
2b31			;		ex de, hl    ; put into DE 
2b31			 
2b31			 
2b31 21 32 64				ld hl, baseram 
2b34					;ld hl, baseusermem 
2b34			 
2b34				; skip dict stub 
2b34			;	call forth_tok_next 
2b34 e5			push hl   ; sacreifical push 
2b35			 
2b35			.fldouscanm: 
2b35 e1				pop hl 
2b36			.fldouscan: 
2b36			;	if DEBUG_FORTH_WORDS 
2b36			;		DMARK "LSs" 
2b36			;		CALLMONITOR 
2b36			;	endif 
2b36				; skip dict stub 
2b36 cd 1d 21				call forth_tok_next 
2b39			 
2b39			 
2b39			; while we have words to look for 
2b39			 
2b39 7e				ld a, (hl)      
2b3a			;	if DEBUG_FORTH_WORDS 
2b3a			;		DMARK "LSk" 
2b3a			;		CALLMONITOR 
2b3a			;	endif 
2b3a fe 00				cp WORD_SYS_END 
2b3c ca 78 2b				jp z, .flunotfound 
2b3f fe 01				cp WORD_SYS_UWORD 
2b41 c2 36 2b				jp nz, .fldouscan 
2b44			 
2b44			;	if DEBUG_FORTH_WORDS 
2b44			;		DMARK "LSu" 
2b44			;		CALLMONITOR 
2b44			;	endif 
2b44			 
2b44					; found a uword but is it the one we want... 
2b44			 
2b44 c5					push bc     ; uword to find is on bc 
2b45 d1					pop de 
2b46			 
2b46 e5					push hl  ; to save the ptr 
2b47			 
2b47					; skip opcode 
2b47 23					inc hl  
2b48					; skip next ptr 
2b48 23					inc hl  
2b49 23					inc hl 
2b4a					; skip len 
2b4a 23					inc hl 
2b4b			 
2b4b			;	if DEBUG_FORTH_WORDS 
2b4b			;		DMARK "LSc" 
2b4b			;		CALLMONITOR 
2b4b			;	endif 
2b4b cd 43 12				call strcmp 
2b4e c2 35 2b				jp nz, .fldouscanm 
2b51			; 
2b51			; 
2b51			;; while we have words to look for 
2b51			; 
2b51			;.fdouscan:	ld a, (hl)      
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "LSs" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			;		cp WORD_SYS_END 
2b51			;		jp z, .fudone 
2b51			;		cp WORD_SYS_UWORD 
2b51			;		jp nz, .fnuword 
2b51			; 
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "FGu" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			; 
2b51			;		; found a uword but is it the one we want... 
2b51			; 
2b51			; 
2b51			;	        pop de   ; get back the dsp name 
2b51			;		push de 
2b51			; 
2b51			;		push hl  ; to save the ptr 
2b51			; 
2b51			;		; skip opcode 
2b51			;		inc hl  
2b51			;		; skip next ptr 
2b51			;		inc hl  
2b51			;		inc hl 
2b51			;		; skip len 
2b51			;		inc hl 
2b51			; 
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "FGc" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			;		call strcmp 
2b51			;		jp nz, .fnuword 
2b51			 
2b51			 
2b51 e1			pop hl 
2b52			 
2b52				 
2b52				if DEBUG_FORTH_WORDS 
2b52					DMARK "FGm" 
2b52 f5				push af  
2b53 3a 67 2b			ld a, (.dmark)  
2b56 32 71 ee			ld (debug_mark),a  
2b59 3a 68 2b			ld a, (.dmark+1)  
2b5c 32 72 ee			ld (debug_mark+1),a  
2b5f 3a 69 2b			ld a, (.dmark+2)  
2b62 32 73 ee			ld (debug_mark+2),a  
2b65 18 03			jr .pastdmark  
2b67 ..			.dmark: db "FGm"  
2b6a f1			.pastdmark: pop af  
2b6b			endm  
# End of macro DMARK
2b6b					CALLMONITOR 
2b6b cd ae 15			call break_point_state  
2b6e				endm  
# End of macro CALLMONITOR
2b6e				endif 
2b6e			 
2b6e			 
2b6e			 
2b6e					; we have a uword so push its name to the stack 
2b6e			 
2b6e			;	   	push hl  ; save so we can move to next dict block 
2b6e			;pop hl 
2b6e			 
2b6e					; update opcode to deleted 
2b6e 3e 03				ld a, WORD_SYS_DELETED 
2b70 77					ld (hl), a 
2b71			 
2b71 23					inc hl  
2b72					; skip next ptr 
2b72 23					inc hl  
2b73 23					inc hl 
2b74					; skip len 
2b74 23					inc hl 
2b75			 
2b75					; TODO change parser to skip deleted words but for now mark it out 
2b75 3e 5f				ld a, "_" 
2b77 77					ld  (hl),a 
2b78			 
2b78			;		jr .fudone 
2b78			; 
2b78			;.fnuword:	pop hl 
2b78			;		call forth_tok_next 
2b78			;		jp .fdouscan  
2b78			 
2b78			.flunotfound:		  
2b78			 
2b78			 
2b78					 
2b78					FORTH_DSP_POP 
2b78 cd ce 1e			call macro_forth_dsp_pop 
2b7b				endm 
# End of macro FORTH_DSP_POP
2b7b			;		ld hl, .luno 
2b7b			;.fudone:		 pop hl 
2b7b					NEXTW 
2b7b c3 cc 1f			jp macro_next 
2b7e				endm 
# End of macro NEXTW
2b7e			.NOP: 
2b7e				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b7e 61				db WORD_SYS_CORE+77             
2b7f a5 2b			dw .COMO            
2b81 04				db 3 + 1 
2b82 .. 00			db "NOP",0              
2b86				endm 
# End of macro CWHEAD
2b86			; | NOP (  --  ) Do nothing | DONE 
2b86					if DEBUG_FORTH_WORDS_KEY 
2b86						DMARK "NOP" 
2b86 f5				push af  
2b87 3a 9b 2b			ld a, (.dmark)  
2b8a 32 71 ee			ld (debug_mark),a  
2b8d 3a 9c 2b			ld a, (.dmark+1)  
2b90 32 72 ee			ld (debug_mark+1),a  
2b93 3a 9d 2b			ld a, (.dmark+2)  
2b96 32 73 ee			ld (debug_mark+2),a  
2b99 18 03			jr .pastdmark  
2b9b ..			.dmark: db "NOP"  
2b9e f1			.pastdmark: pop af  
2b9f			endm  
# End of macro DMARK
2b9f						CALLMONITOR 
2b9f cd ae 15			call break_point_state  
2ba2				endm  
# End of macro CALLMONITOR
2ba2					endif 
2ba2				       NEXTW 
2ba2 c3 cc 1f			jp macro_next 
2ba5				endm 
# End of macro NEXTW
2ba5			.COMO: 
2ba5				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2ba5 6e				db WORD_SYS_CORE+90             
2ba6 f7 2b			dw .COMC            
2ba8 02				db 1 + 1 
2ba9 .. 00			db "(",0              
2bab				endm 
# End of macro CWHEAD
2bab			; | ( ( -- )  Start of comment | DONE 
2bab			 
2bab			 
2bab 2a cc e5				ld hl, ( os_tok_ptr) 
2bae 11 f2 2b			ld de, .closepar 
2bb1					 
2bb1					if DEBUG_FORTH_WORDS 
2bb1						DMARK ").." 
2bb1 f5				push af  
2bb2 3a c6 2b			ld a, (.dmark)  
2bb5 32 71 ee			ld (debug_mark),a  
2bb8 3a c7 2b			ld a, (.dmark+1)  
2bbb 32 72 ee			ld (debug_mark+1),a  
2bbe 3a c8 2b			ld a, (.dmark+2)  
2bc1 32 73 ee			ld (debug_mark+2),a  
2bc4 18 03			jr .pastdmark  
2bc6 ..			.dmark: db ").."  
2bc9 f1			.pastdmark: pop af  
2bca			endm  
# End of macro DMARK
2bca						CALLMONITOR 
2bca cd ae 15			call break_point_state  
2bcd				endm  
# End of macro CALLMONITOR
2bcd					endif 
2bcd cd e7 20			call findnexttok  
2bd0			 
2bd0					if DEBUG_FORTH_WORDS 
2bd0						DMARK "IF5" 
2bd0 f5				push af  
2bd1 3a e5 2b			ld a, (.dmark)  
2bd4 32 71 ee			ld (debug_mark),a  
2bd7 3a e6 2b			ld a, (.dmark+1)  
2bda 32 72 ee			ld (debug_mark+1),a  
2bdd 3a e7 2b			ld a, (.dmark+2)  
2be0 32 73 ee			ld (debug_mark+2),a  
2be3 18 03			jr .pastdmark  
2be5 ..			.dmark: db "IF5"  
2be8 f1			.pastdmark: pop af  
2be9			endm  
# End of macro DMARK
2be9						CALLMONITOR 
2be9 cd ae 15			call break_point_state  
2bec				endm  
# End of macro CALLMONITOR
2bec					endif 
2bec				; replace below with ) exec using tok_ptr 
2bec 22 cc e5			ld (os_tok_ptr), hl 
2bef c3 5d 20			jp exec1 
2bf2			 
2bf2 .. 00			.closepar:   db ")",0 
2bf4			 
2bf4				       NEXTW 
2bf4 c3 cc 1f			jp macro_next 
2bf7				endm 
# End of macro NEXTW
2bf7			.COMC: 
2bf7				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2bf7 6f				db WORD_SYS_CORE+91             
2bf8 00 2c			dw .SCRATCH            
2bfa 02				db 1 + 1 
2bfb .. 00			db ")",0              
2bfd				endm 
# End of macro CWHEAD
2bfd			; | ) ( -- )  End of comment |  DONE  
2bfd				       NEXTW 
2bfd c3 cc 1f			jp macro_next 
2c00				endm 
# End of macro NEXTW
2c00			 
2c00			.SCRATCH: 
2c00				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c00 6f				db WORD_SYS_CORE+91             
2c01 3b 2c			dw .INC            
2c03 08				db 7 + 1 
2c04 .. 00			db "SCRATCH",0              
2c0c				endm 
# End of macro CWHEAD
2c0c			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c0c			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c0c			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c0c			; | |  
2c0c			; | | e.g.    : score $00 scratch ; 
2c0c			; | |  
2c0c			; | | $00 score ! 
2c0c			; | | $01 score +! 
2c0c			; | |  
2c0c			; | | e.g.   : varword $0a scratch ;  
2c0c			; | | 
2c0c			; | | $8000 varword ! 
2c0c					if DEBUG_FORTH_WORDS_KEY 
2c0c						DMARK "SCR" 
2c0c f5				push af  
2c0d 3a 21 2c			ld a, (.dmark)  
2c10 32 71 ee			ld (debug_mark),a  
2c13 3a 22 2c			ld a, (.dmark+1)  
2c16 32 72 ee			ld (debug_mark+1),a  
2c19 3a 23 2c			ld a, (.dmark+2)  
2c1c 32 73 ee			ld (debug_mark+2),a  
2c1f 18 03			jr .pastdmark  
2c21 ..			.dmark: db "SCR"  
2c24 f1			.pastdmark: pop af  
2c25			endm  
# End of macro DMARK
2c25						CALLMONITOR 
2c25 cd ae 15			call break_point_state  
2c28				endm  
# End of macro CALLMONITOR
2c28					endif 
2c28			 
2c28					FORTH_DSP_VALUEHL 
2c28 cd 16 1e			call macro_dsp_valuehl 
2c2b				endm 
# End of macro FORTH_DSP_VALUEHL
2c2b				 
2c2b					FORTH_DSP_POP 
2c2b cd ce 1e			call macro_forth_dsp_pop 
2c2e				endm 
# End of macro FORTH_DSP_POP
2c2e			 
2c2e 7d					ld a, l 
2c2f 21 f0 e7				ld hl, os_var_array 
2c32 cd ad 0d				call addatohl 
2c35			 
2c35 cd 1f 1c				call forth_push_numhl 
2c38			 
2c38				       NEXTW 
2c38 c3 cc 1f			jp macro_next 
2c3b				endm 
# End of macro NEXTW
2c3b			 
2c3b			.INC: 
2c3b				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c3b 6f				db WORD_SYS_CORE+91             
2c3c 8f 2c			dw .DEC            
2c3e 03				db 2 + 1 
2c3f .. 00			db "+!",0              
2c42				endm 
# End of macro CWHEAD
2c42			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c42					if DEBUG_FORTH_WORDS_KEY 
2c42						DMARK "+s_" 
2c42 f5				push af  
2c43 3a 57 2c			ld a, (.dmark)  
2c46 32 71 ee			ld (debug_mark),a  
2c49 3a 58 2c			ld a, (.dmark+1)  
2c4c 32 72 ee			ld (debug_mark+1),a  
2c4f 3a 59 2c			ld a, (.dmark+2)  
2c52 32 73 ee			ld (debug_mark+2),a  
2c55 18 03			jr .pastdmark  
2c57 ..			.dmark: db "+s_"  
2c5a f1			.pastdmark: pop af  
2c5b			endm  
# End of macro DMARK
2c5b						CALLMONITOR 
2c5b cd ae 15			call break_point_state  
2c5e				endm  
# End of macro CALLMONITOR
2c5e					endif 
2c5e			 
2c5e					FORTH_DSP_VALUEHL 
2c5e cd 16 1e			call macro_dsp_valuehl 
2c61				endm 
# End of macro FORTH_DSP_VALUEHL
2c61			 
2c61 e5					push hl   ; save address 
2c62			 
2c62					FORTH_DSP_POP 
2c62 cd ce 1e			call macro_forth_dsp_pop 
2c65				endm 
# End of macro FORTH_DSP_POP
2c65			 
2c65					FORTH_DSP_VALUEHL 
2c65 cd 16 1e			call macro_dsp_valuehl 
2c68				endm 
# End of macro FORTH_DSP_VALUEHL
2c68			 
2c68					FORTH_DSP_POP 
2c68 cd ce 1e			call macro_forth_dsp_pop 
2c6b				endm 
# End of macro FORTH_DSP_POP
2c6b			 
2c6b					; hl contains value to add to byte at a 
2c6b				 
2c6b eb					ex de, hl 
2c6c			 
2c6c e1					pop hl 
2c6d			 
2c6d					if DEBUG_FORTH_WORDS 
2c6d						DMARK "INC" 
2c6d f5				push af  
2c6e 3a 82 2c			ld a, (.dmark)  
2c71 32 71 ee			ld (debug_mark),a  
2c74 3a 83 2c			ld a, (.dmark+1)  
2c77 32 72 ee			ld (debug_mark+1),a  
2c7a 3a 84 2c			ld a, (.dmark+2)  
2c7d 32 73 ee			ld (debug_mark+2),a  
2c80 18 03			jr .pastdmark  
2c82 ..			.dmark: db "INC"  
2c85 f1			.pastdmark: pop af  
2c86			endm  
# End of macro DMARK
2c86						CALLMONITOR 
2c86 cd ae 15			call break_point_state  
2c89				endm  
# End of macro CALLMONITOR
2c89					endif 
2c89			 
2c89 7e					ld a,(hl) 
2c8a 83					add e 
2c8b 77					ld (hl),a 
2c8c			 
2c8c			 
2c8c			 
2c8c				       NEXTW 
2c8c c3 cc 1f			jp macro_next 
2c8f				endm 
# End of macro NEXTW
2c8f			 
2c8f			.DEC: 
2c8f				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c8f 6f				db WORD_SYS_CORE+91             
2c90 e0 2c			dw .INC2            
2c92 03				db 2 + 1 
2c93 .. 00			db "-!",0              
2c96				endm 
# End of macro CWHEAD
2c96			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c96					if DEBUG_FORTH_WORDS_KEY 
2c96						DMARK "-s_" 
2c96 f5				push af  
2c97 3a ab 2c			ld a, (.dmark)  
2c9a 32 71 ee			ld (debug_mark),a  
2c9d 3a ac 2c			ld a, (.dmark+1)  
2ca0 32 72 ee			ld (debug_mark+1),a  
2ca3 3a ad 2c			ld a, (.dmark+2)  
2ca6 32 73 ee			ld (debug_mark+2),a  
2ca9 18 03			jr .pastdmark  
2cab ..			.dmark: db "-s_"  
2cae f1			.pastdmark: pop af  
2caf			endm  
# End of macro DMARK
2caf						CALLMONITOR 
2caf cd ae 15			call break_point_state  
2cb2				endm  
# End of macro CALLMONITOR
2cb2					endif 
2cb2			 
2cb2					FORTH_DSP_VALUEHL 
2cb2 cd 16 1e			call macro_dsp_valuehl 
2cb5				endm 
# End of macro FORTH_DSP_VALUEHL
2cb5			 
2cb5 e5					push hl   ; save address 
2cb6			 
2cb6					FORTH_DSP_POP 
2cb6 cd ce 1e			call macro_forth_dsp_pop 
2cb9				endm 
# End of macro FORTH_DSP_POP
2cb9			 
2cb9					FORTH_DSP_VALUEHL 
2cb9 cd 16 1e			call macro_dsp_valuehl 
2cbc				endm 
# End of macro FORTH_DSP_VALUEHL
2cbc			 
2cbc					; hl contains value to add to byte at a 
2cbc				 
2cbc eb					ex de, hl 
2cbd			 
2cbd e1					pop hl 
2cbe			 
2cbe					if DEBUG_FORTH_WORDS 
2cbe						DMARK "DEC" 
2cbe f5				push af  
2cbf 3a d3 2c			ld a, (.dmark)  
2cc2 32 71 ee			ld (debug_mark),a  
2cc5 3a d4 2c			ld a, (.dmark+1)  
2cc8 32 72 ee			ld (debug_mark+1),a  
2ccb 3a d5 2c			ld a, (.dmark+2)  
2cce 32 73 ee			ld (debug_mark+2),a  
2cd1 18 03			jr .pastdmark  
2cd3 ..			.dmark: db "DEC"  
2cd6 f1			.pastdmark: pop af  
2cd7			endm  
# End of macro DMARK
2cd7						CALLMONITOR 
2cd7 cd ae 15			call break_point_state  
2cda				endm  
# End of macro CALLMONITOR
2cda					endif 
2cda			 
2cda 7e					ld a,(hl) 
2cdb 93					sub e 
2cdc 77					ld (hl),a 
2cdd			 
2cdd			 
2cdd			 
2cdd				       NEXTW 
2cdd c3 cc 1f			jp macro_next 
2ce0				endm 
# End of macro NEXTW
2ce0			 
2ce0			.INC2: 
2ce0				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ce0 6f				db WORD_SYS_CORE+91             
2ce1 8a 2d			dw .DEC2            
2ce3 04				db 3 + 1 
2ce4 .. 00			db "+2!",0              
2ce8				endm 
# End of macro CWHEAD
2ce8			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2ce8			 
2ce8					if DEBUG_FORTH_WORDS_KEY 
2ce8						DMARK "+2s" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 71 ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 72 ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 73 ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "+2s"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01						CALLMONITOR 
2d01 cd ae 15			call break_point_state  
2d04				endm  
# End of macro CALLMONITOR
2d04					endif 
2d04			 
2d04					; Address 
2d04			 
2d04					FORTH_DSP_VALUEHL 
2d04 cd 16 1e			call macro_dsp_valuehl 
2d07				endm 
# End of macro FORTH_DSP_VALUEHL
2d07			 
2d07 e5					push hl    ; save address 
2d08			 
2d08					; load content into de 
2d08			 
2d08 5e					ld e,(hl) 
2d09 23					inc hl 
2d0a 56					ld d, (hl) 
2d0b			 
2d0b					if DEBUG_FORTH_WORDS 
2d0b						DMARK "+2a" 
2d0b f5				push af  
2d0c 3a 20 2d			ld a, (.dmark)  
2d0f 32 71 ee			ld (debug_mark),a  
2d12 3a 21 2d			ld a, (.dmark+1)  
2d15 32 72 ee			ld (debug_mark+1),a  
2d18 3a 22 2d			ld a, (.dmark+2)  
2d1b 32 73 ee			ld (debug_mark+2),a  
2d1e 18 03			jr .pastdmark  
2d20 ..			.dmark: db "+2a"  
2d23 f1			.pastdmark: pop af  
2d24			endm  
# End of macro DMARK
2d24						CALLMONITOR 
2d24 cd ae 15			call break_point_state  
2d27				endm  
# End of macro CALLMONITOR
2d27					endif 
2d27			 
2d27					FORTH_DSP_POP 
2d27 cd ce 1e			call macro_forth_dsp_pop 
2d2a				endm 
# End of macro FORTH_DSP_POP
2d2a			 
2d2a					; Get value to add 
2d2a			 
2d2a					FORTH_DSP_VALUE 
2d2a cd ff 1d			call macro_forth_dsp_value 
2d2d				endm 
# End of macro FORTH_DSP_VALUE
2d2d			 
2d2d					if DEBUG_FORTH_WORDS 
2d2d						DMARK "+2v" 
2d2d f5				push af  
2d2e 3a 42 2d			ld a, (.dmark)  
2d31 32 71 ee			ld (debug_mark),a  
2d34 3a 43 2d			ld a, (.dmark+1)  
2d37 32 72 ee			ld (debug_mark+1),a  
2d3a 3a 44 2d			ld a, (.dmark+2)  
2d3d 32 73 ee			ld (debug_mark+2),a  
2d40 18 03			jr .pastdmark  
2d42 ..			.dmark: db "+2v"  
2d45 f1			.pastdmark: pop af  
2d46			endm  
# End of macro DMARK
2d46						CALLMONITOR 
2d46 cd ae 15			call break_point_state  
2d49				endm  
# End of macro CALLMONITOR
2d49					endif 
2d49			 
2d49 19					add hl, de 
2d4a			 
2d4a					if DEBUG_FORTH_WORDS 
2d4a						DMARK "+2+" 
2d4a f5				push af  
2d4b 3a 5f 2d			ld a, (.dmark)  
2d4e 32 71 ee			ld (debug_mark),a  
2d51 3a 60 2d			ld a, (.dmark+1)  
2d54 32 72 ee			ld (debug_mark+1),a  
2d57 3a 61 2d			ld a, (.dmark+2)  
2d5a 32 73 ee			ld (debug_mark+2),a  
2d5d 18 03			jr .pastdmark  
2d5f ..			.dmark: db "+2+"  
2d62 f1			.pastdmark: pop af  
2d63			endm  
# End of macro DMARK
2d63						CALLMONITOR 
2d63 cd ae 15			call break_point_state  
2d66				endm  
# End of macro CALLMONITOR
2d66					endif 
2d66			 
2d66					; move result to de 
2d66			 
2d66 eb					ex de, hl 
2d67			 
2d67					; Address 
2d67			 
2d67 e1					pop hl 
2d68			 
2d68					; save it back 
2d68			 
2d68 73					ld (hl), e 
2d69 23					inc hl 
2d6a 72					ld (hl), d 
2d6b			 
2d6b					if DEBUG_FORTH_WORDS 
2d6b						DMARK "+2e" 
2d6b f5				push af  
2d6c 3a 80 2d			ld a, (.dmark)  
2d6f 32 71 ee			ld (debug_mark),a  
2d72 3a 81 2d			ld a, (.dmark+1)  
2d75 32 72 ee			ld (debug_mark+1),a  
2d78 3a 82 2d			ld a, (.dmark+2)  
2d7b 32 73 ee			ld (debug_mark+2),a  
2d7e 18 03			jr .pastdmark  
2d80 ..			.dmark: db "+2e"  
2d83 f1			.pastdmark: pop af  
2d84			endm  
# End of macro DMARK
2d84						CALLMONITOR 
2d84 cd ae 15			call break_point_state  
2d87				endm  
# End of macro CALLMONITOR
2d87					endif 
2d87			 
2d87			 
2d87			 
2d87			 
2d87			 
2d87				       NEXTW 
2d87 c3 cc 1f			jp macro_next 
2d8a				endm 
# End of macro NEXTW
2d8a			 
2d8a			.DEC2: 
2d8a				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d8a 6f				db WORD_SYS_CORE+91             
2d8b 36 2e			dw .GET2            
2d8d 04				db 3 + 1 
2d8e .. 00			db "-2!",0              
2d92				endm 
# End of macro CWHEAD
2d92			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d92			 
2d92			 
2d92					if DEBUG_FORTH_WORDS_KEY 
2d92						DMARK "-2s" 
2d92 f5				push af  
2d93 3a a7 2d			ld a, (.dmark)  
2d96 32 71 ee			ld (debug_mark),a  
2d99 3a a8 2d			ld a, (.dmark+1)  
2d9c 32 72 ee			ld (debug_mark+1),a  
2d9f 3a a9 2d			ld a, (.dmark+2)  
2da2 32 73 ee			ld (debug_mark+2),a  
2da5 18 03			jr .pastdmark  
2da7 ..			.dmark: db "-2s"  
2daa f1			.pastdmark: pop af  
2dab			endm  
# End of macro DMARK
2dab						CALLMONITOR 
2dab cd ae 15			call break_point_state  
2dae				endm  
# End of macro CALLMONITOR
2dae					endif 
2dae			 
2dae					; Address 
2dae			 
2dae					FORTH_DSP_VALUEHL 
2dae cd 16 1e			call macro_dsp_valuehl 
2db1				endm 
# End of macro FORTH_DSP_VALUEHL
2db1			 
2db1 e5					push hl    ; save address 
2db2			 
2db2					; load content into de 
2db2			 
2db2 5e					ld e,(hl) 
2db3 23					inc hl 
2db4 56					ld d, (hl) 
2db5			 
2db5					if DEBUG_FORTH_WORDS 
2db5						DMARK "-2a" 
2db5 f5				push af  
2db6 3a ca 2d			ld a, (.dmark)  
2db9 32 71 ee			ld (debug_mark),a  
2dbc 3a cb 2d			ld a, (.dmark+1)  
2dbf 32 72 ee			ld (debug_mark+1),a  
2dc2 3a cc 2d			ld a, (.dmark+2)  
2dc5 32 73 ee			ld (debug_mark+2),a  
2dc8 18 03			jr .pastdmark  
2dca ..			.dmark: db "-2a"  
2dcd f1			.pastdmark: pop af  
2dce			endm  
# End of macro DMARK
2dce						CALLMONITOR 
2dce cd ae 15			call break_point_state  
2dd1				endm  
# End of macro CALLMONITOR
2dd1					endif 
2dd1			 
2dd1					FORTH_DSP_POP 
2dd1 cd ce 1e			call macro_forth_dsp_pop 
2dd4				endm 
# End of macro FORTH_DSP_POP
2dd4			 
2dd4					; Get value to remove 
2dd4			 
2dd4					FORTH_DSP_VALUE 
2dd4 cd ff 1d			call macro_forth_dsp_value 
2dd7				endm 
# End of macro FORTH_DSP_VALUE
2dd7			 
2dd7					if DEBUG_FORTH_WORDS 
2dd7						DMARK "-2v" 
2dd7 f5				push af  
2dd8 3a ec 2d			ld a, (.dmark)  
2ddb 32 71 ee			ld (debug_mark),a  
2dde 3a ed 2d			ld a, (.dmark+1)  
2de1 32 72 ee			ld (debug_mark+1),a  
2de4 3a ee 2d			ld a, (.dmark+2)  
2de7 32 73 ee			ld (debug_mark+2),a  
2dea 18 03			jr .pastdmark  
2dec ..			.dmark: db "-2v"  
2def f1			.pastdmark: pop af  
2df0			endm  
# End of macro DMARK
2df0						CALLMONITOR 
2df0 cd ae 15			call break_point_state  
2df3				endm  
# End of macro CALLMONITOR
2df3					endif 
2df3			 
2df3 eb					ex de, hl 
2df4 ed 52				sbc hl, de 
2df6			 
2df6					if DEBUG_FORTH_WORDS 
2df6						DMARK "-2d" 
2df6 f5				push af  
2df7 3a 0b 2e			ld a, (.dmark)  
2dfa 32 71 ee			ld (debug_mark),a  
2dfd 3a 0c 2e			ld a, (.dmark+1)  
2e00 32 72 ee			ld (debug_mark+1),a  
2e03 3a 0d 2e			ld a, (.dmark+2)  
2e06 32 73 ee			ld (debug_mark+2),a  
2e09 18 03			jr .pastdmark  
2e0b ..			.dmark: db "-2d"  
2e0e f1			.pastdmark: pop af  
2e0f			endm  
# End of macro DMARK
2e0f						CALLMONITOR 
2e0f cd ae 15			call break_point_state  
2e12				endm  
# End of macro CALLMONITOR
2e12					endif 
2e12			 
2e12					; move result to de 
2e12			 
2e12 eb					ex de, hl 
2e13			 
2e13					; Address 
2e13			 
2e13 e1					pop hl 
2e14			 
2e14					; save it back 
2e14			 
2e14 73					ld (hl), e 
2e15 23					inc hl 
2e16 72					ld (hl), d 
2e17			 
2e17					if DEBUG_FORTH_WORDS 
2e17						DMARK "-2e" 
2e17 f5				push af  
2e18 3a 2c 2e			ld a, (.dmark)  
2e1b 32 71 ee			ld (debug_mark),a  
2e1e 3a 2d 2e			ld a, (.dmark+1)  
2e21 32 72 ee			ld (debug_mark+1),a  
2e24 3a 2e 2e			ld a, (.dmark+2)  
2e27 32 73 ee			ld (debug_mark+2),a  
2e2a 18 03			jr .pastdmark  
2e2c ..			.dmark: db "-2e"  
2e2f f1			.pastdmark: pop af  
2e30			endm  
# End of macro DMARK
2e30						CALLMONITOR 
2e30 cd ae 15			call break_point_state  
2e33				endm  
# End of macro CALLMONITOR
2e33					endif 
2e33			 
2e33			 
2e33			 
2e33			 
2e33			 
2e33				       NEXTW 
2e33 c3 cc 1f			jp macro_next 
2e36				endm 
# End of macro NEXTW
2e36			.GET2: 
2e36				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e36 6f				db WORD_SYS_CORE+91             
2e37 66 2e			dw .BANG2            
2e39 03				db 2 + 1 
2e3a .. 00			db "2@",0              
2e3d				endm 
# End of macro CWHEAD
2e3d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e3d					if DEBUG_FORTH_WORDS_KEY 
2e3d						DMARK "2A_" 
2e3d f5				push af  
2e3e 3a 52 2e			ld a, (.dmark)  
2e41 32 71 ee			ld (debug_mark),a  
2e44 3a 53 2e			ld a, (.dmark+1)  
2e47 32 72 ee			ld (debug_mark+1),a  
2e4a 3a 54 2e			ld a, (.dmark+2)  
2e4d 32 73 ee			ld (debug_mark+2),a  
2e50 18 03			jr .pastdmark  
2e52 ..			.dmark: db "2A_"  
2e55 f1			.pastdmark: pop af  
2e56			endm  
# End of macro DMARK
2e56						CALLMONITOR 
2e56 cd ae 15			call break_point_state  
2e59				endm  
# End of macro CALLMONITOR
2e59					endif 
2e59			 
2e59					FORTH_DSP_VALUEHL 
2e59 cd 16 1e			call macro_dsp_valuehl 
2e5c				endm 
# End of macro FORTH_DSP_VALUEHL
2e5c			 
2e5c 5e					ld e, (hl) 
2e5d 23					inc hl 
2e5e 56					ld d, (hl) 
2e5f			 
2e5f eb					ex de, hl 
2e60			 
2e60 cd 1f 1c				call forth_push_numhl 
2e63			 
2e63				       NEXTW 
2e63 c3 cc 1f			jp macro_next 
2e66				endm 
# End of macro NEXTW
2e66			.BANG2: 
2e66				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e66 6f				db WORD_SYS_CORE+91             
2e67 9e 2e			dw .CONFIG            
2e69 03				db 2 + 1 
2e6a .. 00			db "2!",0              
2e6d				endm 
# End of macro CWHEAD
2e6d			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e6d					if DEBUG_FORTH_WORDS_KEY 
2e6d						DMARK "2S_" 
2e6d f5				push af  
2e6e 3a 82 2e			ld a, (.dmark)  
2e71 32 71 ee			ld (debug_mark),a  
2e74 3a 83 2e			ld a, (.dmark+1)  
2e77 32 72 ee			ld (debug_mark+1),a  
2e7a 3a 84 2e			ld a, (.dmark+2)  
2e7d 32 73 ee			ld (debug_mark+2),a  
2e80 18 03			jr .pastdmark  
2e82 ..			.dmark: db "2S_"  
2e85 f1			.pastdmark: pop af  
2e86			endm  
# End of macro DMARK
2e86						CALLMONITOR 
2e86 cd ae 15			call break_point_state  
2e89				endm  
# End of macro CALLMONITOR
2e89					endif 
2e89			 
2e89					FORTH_DSP_VALUEHL 
2e89 cd 16 1e			call macro_dsp_valuehl 
2e8c				endm 
# End of macro FORTH_DSP_VALUEHL
2e8c			 
2e8c e5					push hl   ; save address 
2e8d			 
2e8d			 
2e8d					FORTH_DSP_POP 
2e8d cd ce 1e			call macro_forth_dsp_pop 
2e90				endm 
# End of macro FORTH_DSP_POP
2e90			 
2e90					 
2e90					FORTH_DSP_VALUEHL 
2e90 cd 16 1e			call macro_dsp_valuehl 
2e93				endm 
# End of macro FORTH_DSP_VALUEHL
2e93			 
2e93					FORTH_DSP_POP 
2e93 cd ce 1e			call macro_forth_dsp_pop 
2e96				endm 
# End of macro FORTH_DSP_POP
2e96			 
2e96 eb					ex de, hl    ; value now in de 
2e97			 
2e97 e1					pop hl 
2e98			 
2e98 73					ld (hl), e 
2e99			 
2e99 23					inc hl 
2e9a			 
2e9a 72					ld (hl), d 
2e9b			 
2e9b			 
2e9b				       NEXTW 
2e9b c3 cc 1f			jp macro_next 
2e9e				endm 
# End of macro NEXTW
2e9e			.CONFIG: 
2e9e				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2e9e 6f				db WORD_SYS_CORE+91             
2e9f af 2e			dw .ENDCORE            
2ea1 07				db 6 + 1 
2ea2 .. 00			db "CONFIG",0              
2ea9				endm 
# End of macro CWHEAD
2ea9			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ea9			 
2ea9 cd 0d 14				call config 
2eac					NEXTW 
2eac c3 cc 1f			jp macro_next 
2eaf				endm 
# End of macro NEXTW
2eaf			.ENDCORE: 
2eaf			 
2eaf			; eof 
2eaf			 
2eaf			 
# End of file forth_words_core.asm
2eaf			include "forth_words_flow.asm" 
2eaf			 
2eaf			; | ## Program Flow Words 
2eaf			 
2eaf			.IF: 
2eaf				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2eaf 1e				db WORD_SYS_CORE+10             
2eb0 a4 2f			dw .THEN            
2eb2 03				db 2 + 1 
2eb3 .. 00			db "IF",0              
2eb6				endm 
# End of macro CWHEAD
2eb6			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2eb6			; 
2eb6					if DEBUG_FORTH_WORDS_KEY 
2eb6						DMARK "IF." 
2eb6 f5				push af  
2eb7 3a cb 2e			ld a, (.dmark)  
2eba 32 71 ee			ld (debug_mark),a  
2ebd 3a cc 2e			ld a, (.dmark+1)  
2ec0 32 72 ee			ld (debug_mark+1),a  
2ec3 3a cd 2e			ld a, (.dmark+2)  
2ec6 32 73 ee			ld (debug_mark+2),a  
2ec9 18 03			jr .pastdmark  
2ecb ..			.dmark: db "IF."  
2ece f1			.pastdmark: pop af  
2ecf			endm  
# End of macro DMARK
2ecf						CALLMONITOR 
2ecf cd ae 15			call break_point_state  
2ed2				endm  
# End of macro CALLMONITOR
2ed2					endif 
2ed2			; eval TOS 
2ed2			 
2ed2				FORTH_DSP_VALUEHL 
2ed2 cd 16 1e			call macro_dsp_valuehl 
2ed5				endm 
# End of macro FORTH_DSP_VALUEHL
2ed5			 
2ed5			;	push hl 
2ed5				FORTH_DSP_POP 
2ed5 cd ce 1e			call macro_forth_dsp_pop 
2ed8				endm 
# End of macro FORTH_DSP_POP
2ed8			;	pop hl 
2ed8			 
2ed8					if DEBUG_FORTH_WORDS 
2ed8						DMARK "IF1" 
2ed8 f5				push af  
2ed9 3a ed 2e			ld a, (.dmark)  
2edc 32 71 ee			ld (debug_mark),a  
2edf 3a ee 2e			ld a, (.dmark+1)  
2ee2 32 72 ee			ld (debug_mark+1),a  
2ee5 3a ef 2e			ld a, (.dmark+2)  
2ee8 32 73 ee			ld (debug_mark+2),a  
2eeb 18 03			jr .pastdmark  
2eed ..			.dmark: db "IF1"  
2ef0 f1			.pastdmark: pop af  
2ef1			endm  
# End of macro DMARK
2ef1						CALLMONITOR 
2ef1 cd ae 15			call break_point_state  
2ef4				endm  
# End of macro CALLMONITOR
2ef4					endif 
2ef4 b7				or a        ; clear carry flag 
2ef5 11 00 00			ld de, 0 
2ef8 eb				ex de,hl 
2ef9 ed 52			sbc hl, de 
2efb c2 85 2f			jp nz, .iftrue 
2efe			 
2efe					if DEBUG_FORTH_WORDS 
2efe						DMARK "IF2" 
2efe f5				push af  
2eff 3a 13 2f			ld a, (.dmark)  
2f02 32 71 ee			ld (debug_mark),a  
2f05 3a 14 2f			ld a, (.dmark+1)  
2f08 32 72 ee			ld (debug_mark+1),a  
2f0b 3a 15 2f			ld a, (.dmark+2)  
2f0e 32 73 ee			ld (debug_mark+2),a  
2f11 18 03			jr .pastdmark  
2f13 ..			.dmark: db "IF2"  
2f16 f1			.pastdmark: pop af  
2f17			endm  
# End of macro DMARK
2f17						CALLMONITOR 
2f17 cd ae 15			call break_point_state  
2f1a				endm  
# End of macro CALLMONITOR
2f1a					endif 
2f1a			 
2f1a			; if not true then skip to THEN 
2f1a			 
2f1a				; TODO get tok_ptr 
2f1a				; TODO consume toks until we get to THEN 
2f1a			 
2f1a 2a cc e5			ld hl, (os_tok_ptr) 
2f1d					if DEBUG_FORTH_WORDS 
2f1d						DMARK "IF3" 
2f1d f5				push af  
2f1e 3a 32 2f			ld a, (.dmark)  
2f21 32 71 ee			ld (debug_mark),a  
2f24 3a 33 2f			ld a, (.dmark+1)  
2f27 32 72 ee			ld (debug_mark+1),a  
2f2a 3a 34 2f			ld a, (.dmark+2)  
2f2d 32 73 ee			ld (debug_mark+2),a  
2f30 18 03			jr .pastdmark  
2f32 ..			.dmark: db "IF3"  
2f35 f1			.pastdmark: pop af  
2f36			endm  
# End of macro DMARK
2f36						CALLMONITOR 
2f36 cd ae 15			call break_point_state  
2f39				endm  
# End of macro CALLMONITOR
2f39						 
2f39					endif 
2f39 11 80 2f			ld de, .ifthen 
2f3c					if DEBUG_FORTH_WORDS 
2f3c						DMARK "IF4" 
2f3c f5				push af  
2f3d 3a 51 2f			ld a, (.dmark)  
2f40 32 71 ee			ld (debug_mark),a  
2f43 3a 52 2f			ld a, (.dmark+1)  
2f46 32 72 ee			ld (debug_mark+1),a  
2f49 3a 53 2f			ld a, (.dmark+2)  
2f4c 32 73 ee			ld (debug_mark+2),a  
2f4f 18 03			jr .pastdmark  
2f51 ..			.dmark: db "IF4"  
2f54 f1			.pastdmark: pop af  
2f55			endm  
# End of macro DMARK
2f55						CALLMONITOR 
2f55 cd ae 15			call break_point_state  
2f58				endm  
# End of macro CALLMONITOR
2f58					endif 
2f58 cd e7 20			call findnexttok  
2f5b			 
2f5b					if DEBUG_FORTH_WORDS 
2f5b						DMARK "IF5" 
2f5b f5				push af  
2f5c 3a 70 2f			ld a, (.dmark)  
2f5f 32 71 ee			ld (debug_mark),a  
2f62 3a 71 2f			ld a, (.dmark+1)  
2f65 32 72 ee			ld (debug_mark+1),a  
2f68 3a 72 2f			ld a, (.dmark+2)  
2f6b 32 73 ee			ld (debug_mark+2),a  
2f6e 18 03			jr .pastdmark  
2f70 ..			.dmark: db "IF5"  
2f73 f1			.pastdmark: pop af  
2f74			endm  
# End of macro DMARK
2f74						CALLMONITOR 
2f74 cd ae 15			call break_point_state  
2f77				endm  
# End of macro CALLMONITOR
2f77					endif 
2f77				; TODO replace below with ; exec using tok_ptr 
2f77 22 cc e5			ld (os_tok_ptr), hl 
2f7a c3 5d 20			jp exec1 
2f7d				NEXTW 
2f7d c3 cc 1f			jp macro_next 
2f80				endm 
# End of macro NEXTW
2f80			 
2f80 .. 00		.ifthen:  db "THEN",0 
2f85			 
2f85			.iftrue:		 
2f85				; Exec next words normally 
2f85			 
2f85				; if true then exec following IF as normal 
2f85					if DEBUG_FORTH_WORDS 
2f85						DMARK "IFT" 
2f85 f5				push af  
2f86 3a 9a 2f			ld a, (.dmark)  
2f89 32 71 ee			ld (debug_mark),a  
2f8c 3a 9b 2f			ld a, (.dmark+1)  
2f8f 32 72 ee			ld (debug_mark+1),a  
2f92 3a 9c 2f			ld a, (.dmark+2)  
2f95 32 73 ee			ld (debug_mark+2),a  
2f98 18 03			jr .pastdmark  
2f9a ..			.dmark: db "IFT"  
2f9d f1			.pastdmark: pop af  
2f9e			endm  
# End of macro DMARK
2f9e						CALLMONITOR 
2f9e cd ae 15			call break_point_state  
2fa1				endm  
# End of macro CALLMONITOR
2fa1					endif 
2fa1			 
2fa1					NEXTW 
2fa1 c3 cc 1f			jp macro_next 
2fa4				endm 
# End of macro NEXTW
2fa4			.THEN: 
2fa4				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fa4 1f				db WORD_SYS_CORE+11             
2fa5 cc 2f			dw .ELSE            
2fa7 05				db 4 + 1 
2fa8 .. 00			db "THEN",0              
2fad				endm 
# End of macro CWHEAD
2fad			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fad					if DEBUG_FORTH_WORDS_KEY 
2fad						DMARK "THN" 
2fad f5				push af  
2fae 3a c2 2f			ld a, (.dmark)  
2fb1 32 71 ee			ld (debug_mark),a  
2fb4 3a c3 2f			ld a, (.dmark+1)  
2fb7 32 72 ee			ld (debug_mark+1),a  
2fba 3a c4 2f			ld a, (.dmark+2)  
2fbd 32 73 ee			ld (debug_mark+2),a  
2fc0 18 03			jr .pastdmark  
2fc2 ..			.dmark: db "THN"  
2fc5 f1			.pastdmark: pop af  
2fc6			endm  
# End of macro DMARK
2fc6						CALLMONITOR 
2fc6 cd ae 15			call break_point_state  
2fc9				endm  
# End of macro CALLMONITOR
2fc9					endif 
2fc9					NEXTW 
2fc9 c3 cc 1f			jp macro_next 
2fcc				endm 
# End of macro NEXTW
2fcc			.ELSE: 
2fcc				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fcc 20				db WORD_SYS_CORE+12             
2fcd f4 2f			dw .DO            
2fcf 03				db 2 + 1 
2fd0 .. 00			db "ELSE",0              
2fd5				endm 
# End of macro CWHEAD
2fd5			; | ELSE ( -- ) Not supported - does nothing | TODO 
2fd5			 
2fd5					if DEBUG_FORTH_WORDS_KEY 
2fd5						DMARK "ELS" 
2fd5 f5				push af  
2fd6 3a ea 2f			ld a, (.dmark)  
2fd9 32 71 ee			ld (debug_mark),a  
2fdc 3a eb 2f			ld a, (.dmark+1)  
2fdf 32 72 ee			ld (debug_mark+1),a  
2fe2 3a ec 2f			ld a, (.dmark+2)  
2fe5 32 73 ee			ld (debug_mark+2),a  
2fe8 18 03			jr .pastdmark  
2fea ..			.dmark: db "ELS"  
2fed f1			.pastdmark: pop af  
2fee			endm  
# End of macro DMARK
2fee						CALLMONITOR 
2fee cd ae 15			call break_point_state  
2ff1				endm  
# End of macro CALLMONITOR
2ff1					endif 
2ff1			 
2ff1			 
2ff1					NEXTW 
2ff1 c3 cc 1f			jp macro_next 
2ff4				endm 
# End of macro NEXTW
2ff4			.DO: 
2ff4				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2ff4 21				db WORD_SYS_CORE+13             
2ff5 1b 31			dw .LOOP            
2ff7 03				db 2 + 1 
2ff8 .. 00			db "DO",0              
2ffb				endm 
# End of macro CWHEAD
2ffb			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2ffb			 
2ffb					if DEBUG_FORTH_WORDS_KEY 
2ffb						DMARK "DO." 
2ffb f5				push af  
2ffc 3a 10 30			ld a, (.dmark)  
2fff 32 71 ee			ld (debug_mark),a  
3002 3a 11 30			ld a, (.dmark+1)  
3005 32 72 ee			ld (debug_mark+1),a  
3008 3a 12 30			ld a, (.dmark+2)  
300b 32 73 ee			ld (debug_mark+2),a  
300e 18 03			jr .pastdmark  
3010 ..			.dmark: db "DO."  
3013 f1			.pastdmark: pop af  
3014			endm  
# End of macro DMARK
3014						CALLMONITOR 
3014 cd ae 15			call break_point_state  
3017				endm  
# End of macro CALLMONITOR
3017					endif 
3017			;  push pc to rsp stack past the DO 
3017			 
3017 2a cc e5				ld hl, (os_tok_ptr) 
301a 23					inc hl   ; D 
301b 23					inc hl  ; O 
301c 23					inc hl   ; null 
301d					if DEBUG_FORTH_WORDS 
301d						DMARK "DO2" 
301d f5				push af  
301e 3a 32 30			ld a, (.dmark)  
3021 32 71 ee			ld (debug_mark),a  
3024 3a 33 30			ld a, (.dmark+1)  
3027 32 72 ee			ld (debug_mark+1),a  
302a 3a 34 30			ld a, (.dmark+2)  
302d 32 73 ee			ld (debug_mark+2),a  
3030 18 03			jr .pastdmark  
3032 ..			.dmark: db "DO2"  
3035 f1			.pastdmark: pop af  
3036			endm  
# End of macro DMARK
3036						CALLMONITOR 
3036 cd ae 15			call break_point_state  
3039				endm  
# End of macro CALLMONITOR
3039					endif 
3039					FORTH_RSP_NEXT 
3039 cd c6 1b			call macro_forth_rsp_next 
303c				endm 
# End of macro FORTH_RSP_NEXT
303c					if DEBUG_FORTH_WORDS 
303c						DMARK "DO3" 
303c f5				push af  
303d 3a 51 30			ld a, (.dmark)  
3040 32 71 ee			ld (debug_mark),a  
3043 3a 52 30			ld a, (.dmark+1)  
3046 32 72 ee			ld (debug_mark+1),a  
3049 3a 53 30			ld a, (.dmark+2)  
304c 32 73 ee			ld (debug_mark+2),a  
304f 18 03			jr .pastdmark  
3051 ..			.dmark: db "DO3"  
3054 f1			.pastdmark: pop af  
3055			endm  
# End of macro DMARK
3055						CALLMONITOR 
3055 cd ae 15			call break_point_state  
3058				endm  
# End of macro CALLMONITOR
3058					endif 
3058			 
3058					;if DEBUG_FORTH_WORDS 
3058				;		push hl 
3058			;		endif  
3058			 
3058			; get counters from data stack 
3058			 
3058			 
3058					FORTH_DSP_VALUEHL 
3058 cd 16 1e			call macro_dsp_valuehl 
305b				endm 
# End of macro FORTH_DSP_VALUEHL
305b e5					push hl		 ; hl now has starting counter which needs to be tos 
305c			 
305c					if DEBUG_FORTH_WORDS 
305c						DMARK "DO4" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 71 ee			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 72 ee			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 73 ee			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "DO4"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075						CALLMONITOR 
3075 cd ae 15			call break_point_state  
3078				endm  
# End of macro CALLMONITOR
3078					endif 
3078					FORTH_DSP_POP 
3078 cd ce 1e			call macro_forth_dsp_pop 
307b				endm 
# End of macro FORTH_DSP_POP
307b			 
307b					if DEBUG_FORTH_WORDS 
307b						DMARK "DO5" 
307b f5				push af  
307c 3a 90 30			ld a, (.dmark)  
307f 32 71 ee			ld (debug_mark),a  
3082 3a 91 30			ld a, (.dmark+1)  
3085 32 72 ee			ld (debug_mark+1),a  
3088 3a 92 30			ld a, (.dmark+2)  
308b 32 73 ee			ld (debug_mark+2),a  
308e 18 03			jr .pastdmark  
3090 ..			.dmark: db "DO5"  
3093 f1			.pastdmark: pop af  
3094			endm  
# End of macro DMARK
3094						CALLMONITOR 
3094 cd ae 15			call break_point_state  
3097				endm  
# End of macro CALLMONITOR
3097					endif 
3097			 
3097					FORTH_DSP_VALUEHL 
3097 cd 16 1e			call macro_dsp_valuehl 
309a				endm 
# End of macro FORTH_DSP_VALUEHL
309a			;		push hl		 ; hl now has starting limit counter 
309a			 
309a					if DEBUG_FORTH_WORDS 
309a						DMARK "DO6" 
309a f5				push af  
309b 3a af 30			ld a, (.dmark)  
309e 32 71 ee			ld (debug_mark),a  
30a1 3a b0 30			ld a, (.dmark+1)  
30a4 32 72 ee			ld (debug_mark+1),a  
30a7 3a b1 30			ld a, (.dmark+2)  
30aa 32 73 ee			ld (debug_mark+2),a  
30ad 18 03			jr .pastdmark  
30af ..			.dmark: db "DO6"  
30b2 f1			.pastdmark: pop af  
30b3			endm  
# End of macro DMARK
30b3						CALLMONITOR 
30b3 cd ae 15			call break_point_state  
30b6				endm  
# End of macro CALLMONITOR
30b6					endif 
30b6					FORTH_DSP_POP 
30b6 cd ce 1e			call macro_forth_dsp_pop 
30b9				endm 
# End of macro FORTH_DSP_POP
30b9			 
30b9			; put counters on the loop stack 
30b9			 
30b9			;		pop hl			 ; limit counter 
30b9 d1					pop de			; start counter 
30ba			 
30ba					; push limit counter 
30ba			 
30ba					if DEBUG_FORTH_WORDS 
30ba						DMARK "DO7" 
30ba f5				push af  
30bb 3a cf 30			ld a, (.dmark)  
30be 32 71 ee			ld (debug_mark),a  
30c1 3a d0 30			ld a, (.dmark+1)  
30c4 32 72 ee			ld (debug_mark+1),a  
30c7 3a d1 30			ld a, (.dmark+2)  
30ca 32 73 ee			ld (debug_mark+2),a  
30cd 18 03			jr .pastdmark  
30cf ..			.dmark: db "DO7"  
30d2 f1			.pastdmark: pop af  
30d3			endm  
# End of macro DMARK
30d3						CALLMONITOR 
30d3 cd ae 15			call break_point_state  
30d6				endm  
# End of macro CALLMONITOR
30d6					endif 
30d6					FORTH_LOOP_NEXT 
30d6 cd 47 1e			call macro_forth_loop_next 
30d9				endm 
# End of macro FORTH_LOOP_NEXT
30d9			 
30d9					; push start counter 
30d9			 
30d9 eb					ex de, hl 
30da					if DEBUG_FORTH_WORDS 
30da						DMARK "DO7" 
30da f5				push af  
30db 3a ef 30			ld a, (.dmark)  
30de 32 71 ee			ld (debug_mark),a  
30e1 3a f0 30			ld a, (.dmark+1)  
30e4 32 72 ee			ld (debug_mark+1),a  
30e7 3a f1 30			ld a, (.dmark+2)  
30ea 32 73 ee			ld (debug_mark+2),a  
30ed 18 03			jr .pastdmark  
30ef ..			.dmark: db "DO7"  
30f2 f1			.pastdmark: pop af  
30f3			endm  
# End of macro DMARK
30f3						CALLMONITOR 
30f3 cd ae 15			call break_point_state  
30f6				endm  
# End of macro CALLMONITOR
30f6					endif 
30f6					FORTH_LOOP_NEXT 
30f6 cd 47 1e			call macro_forth_loop_next 
30f9				endm 
# End of macro FORTH_LOOP_NEXT
30f9			 
30f9			 
30f9					; init first round of I counter 
30f9			 
30f9 22 f0 e5				ld (os_current_i), hl 
30fc			 
30fc					if DEBUG_FORTH_WORDS 
30fc						DMARK "DO8" 
30fc f5				push af  
30fd 3a 11 31			ld a, (.dmark)  
3100 32 71 ee			ld (debug_mark),a  
3103 3a 12 31			ld a, (.dmark+1)  
3106 32 72 ee			ld (debug_mark+1),a  
3109 3a 13 31			ld a, (.dmark+2)  
310c 32 73 ee			ld (debug_mark+2),a  
310f 18 03			jr .pastdmark  
3111 ..			.dmark: db "DO8"  
3114 f1			.pastdmark: pop af  
3115			endm  
# End of macro DMARK
3115						CALLMONITOR 
3115 cd ae 15			call break_point_state  
3118				endm  
# End of macro CALLMONITOR
3118					endif 
3118			 
3118					NEXTW 
3118 c3 cc 1f			jp macro_next 
311b				endm 
# End of macro NEXTW
311b			.LOOP: 
311b				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
311b 22				db WORD_SYS_CORE+14             
311c 33 32			dw .I            
311e 05				db 4 + 1 
311f .. 00			db "LOOP",0              
3124				endm 
# End of macro CWHEAD
3124			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3124			 
3124				; pop tos as current loop count to hl 
3124			 
3124				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3124			 
3124				FORTH_LOOP_TOS 
3124 cd 7a 1e			call macro_forth_loop_tos 
3127				endm 
# End of macro FORTH_LOOP_TOS
3127 e5				push hl 
3128			 
3128					if DEBUG_FORTH_WORDS_KEY 
3128						DMARK "LOP" 
3128 f5				push af  
3129 3a 3d 31			ld a, (.dmark)  
312c 32 71 ee			ld (debug_mark),a  
312f 3a 3e 31			ld a, (.dmark+1)  
3132 32 72 ee			ld (debug_mark+1),a  
3135 3a 3f 31			ld a, (.dmark+2)  
3138 32 73 ee			ld (debug_mark+2),a  
313b 18 03			jr .pastdmark  
313d ..			.dmark: db "LOP"  
3140 f1			.pastdmark: pop af  
3141			endm  
# End of macro DMARK
3141						CALLMONITOR 
3141 cd ae 15			call break_point_state  
3144				endm  
# End of macro CALLMONITOR
3144					endif 
3144				; next item on the stack is the limit. get it 
3144			 
3144			 
3144				FORTH_LOOP_POP 
3144 cd 84 1e			call macro_forth_loop_pop 
3147				endm 
# End of macro FORTH_LOOP_POP
3147			 
3147				FORTH_LOOP_TOS 
3147 cd 7a 1e			call macro_forth_loop_tos 
314a				endm 
# End of macro FORTH_LOOP_TOS
314a			 
314a d1				pop de		 ; de = i, hl = limit 
314b			 
314b					if DEBUG_FORTH_WORDS 
314b						DMARK "LP1" 
314b f5				push af  
314c 3a 60 31			ld a, (.dmark)  
314f 32 71 ee			ld (debug_mark),a  
3152 3a 61 31			ld a, (.dmark+1)  
3155 32 72 ee			ld (debug_mark+1),a  
3158 3a 62 31			ld a, (.dmark+2)  
315b 32 73 ee			ld (debug_mark+2),a  
315e 18 03			jr .pastdmark  
3160 ..			.dmark: db "LP1"  
3163 f1			.pastdmark: pop af  
3164			endm  
# End of macro DMARK
3164						CALLMONITOR 
3164 cd ae 15			call break_point_state  
3167				endm  
# End of macro CALLMONITOR
3167					endif 
3167			 
3167				; go back to previous word 
3167			 
3167 d5				push de    ; save I for inc later 
3168			 
3168			 
3168				; get limit 
3168				;  is I at limit? 
3168			 
3168			 
3168					if DEBUG_FORTH_WORDS 
3168						DMARK "LP1" 
3168 f5				push af  
3169 3a 7d 31			ld a, (.dmark)  
316c 32 71 ee			ld (debug_mark),a  
316f 3a 7e 31			ld a, (.dmark+1)  
3172 32 72 ee			ld (debug_mark+1),a  
3175 3a 7f 31			ld a, (.dmark+2)  
3178 32 73 ee			ld (debug_mark+2),a  
317b 18 03			jr .pastdmark  
317d ..			.dmark: db "LP1"  
3180 f1			.pastdmark: pop af  
3181			endm  
# End of macro DMARK
3181						CALLMONITOR 
3181 cd ae 15			call break_point_state  
3184				endm  
# End of macro CALLMONITOR
3184					endif 
3184			 
3184 ed 52			sbc hl, de 
3186			 
3186			 
3186				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3186			 
3186 20 26				jr nz, .loopnotdone 
3188			 
3188 e1				pop hl   ; get rid of saved I 
3189				FORTH_LOOP_POP     ; get rid of limit 
3189 cd 84 1e			call macro_forth_loop_pop 
318c				endm 
# End of macro FORTH_LOOP_POP
318c			 
318c				FORTH_RSP_POP     ; get rid of DO ptr 
318c cd e7 1b			call macro_forth_rsp_pop 
318f				endm 
# End of macro FORTH_RSP_POP
318f			 
318f			if DEBUG_FORTH_WORDS 
318f						DMARK "LP>" 
318f f5				push af  
3190 3a a4 31			ld a, (.dmark)  
3193 32 71 ee			ld (debug_mark),a  
3196 3a a5 31			ld a, (.dmark+1)  
3199 32 72 ee			ld (debug_mark+1),a  
319c 3a a6 31			ld a, (.dmark+2)  
319f 32 73 ee			ld (debug_mark+2),a  
31a2 18 03			jr .pastdmark  
31a4 ..			.dmark: db "LP>"  
31a7 f1			.pastdmark: pop af  
31a8			endm  
# End of macro DMARK
31a8				CALLMONITOR 
31a8 cd ae 15			call break_point_state  
31ab				endm  
# End of macro CALLMONITOR
31ab			endif 
31ab			 
31ab					NEXTW 
31ab c3 cc 1f			jp macro_next 
31ae				endm 
# End of macro NEXTW
31ae				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31ae			 
31ae			.loopnotdone: 
31ae			 
31ae e1				pop hl    ; get I 
31af 23				inc hl 
31b0			 
31b0			   	; save new I 
31b0			 
31b0			 
31b0					; set I counter 
31b0			 
31b0 22 f0 e5				ld (os_current_i), hl 
31b3			 
31b3					if DEBUG_FORTH_WORDS 
31b3						DMARK "LPN" 
31b3 f5				push af  
31b4 3a c8 31			ld a, (.dmark)  
31b7 32 71 ee			ld (debug_mark),a  
31ba 3a c9 31			ld a, (.dmark+1)  
31bd 32 72 ee			ld (debug_mark+1),a  
31c0 3a ca 31			ld a, (.dmark+2)  
31c3 32 73 ee			ld (debug_mark+2),a  
31c6 18 03			jr .pastdmark  
31c8 ..			.dmark: db "LPN"  
31cb f1			.pastdmark: pop af  
31cc			endm  
# End of macro DMARK
31cc					CALLMONITOR 
31cc cd ae 15			call break_point_state  
31cf				endm  
# End of macro CALLMONITOR
31cf					endif 
31cf					 
31cf				FORTH_LOOP_NEXT 
31cf cd 47 1e			call macro_forth_loop_next 
31d2				endm 
# End of macro FORTH_LOOP_NEXT
31d2			 
31d2			 
31d2					if DEBUG_FORTH_WORDS 
31d2 eb						ex de,hl 
31d3					endif 
31d3			 
31d3			;	; get DO ptr 
31d3			; 
31d3					if DEBUG_FORTH_WORDS 
31d3						DMARK "LP7" 
31d3 f5				push af  
31d4 3a e8 31			ld a, (.dmark)  
31d7 32 71 ee			ld (debug_mark),a  
31da 3a e9 31			ld a, (.dmark+1)  
31dd 32 72 ee			ld (debug_mark+1),a  
31e0 3a ea 31			ld a, (.dmark+2)  
31e3 32 73 ee			ld (debug_mark+2),a  
31e6 18 03			jr .pastdmark  
31e8 ..			.dmark: db "LP7"  
31eb f1			.pastdmark: pop af  
31ec			endm  
# End of macro DMARK
31ec					CALLMONITOR 
31ec cd ae 15			call break_point_state  
31ef				endm  
# End of macro CALLMONITOR
31ef					endif 
31ef				FORTH_RSP_TOS 
31ef cd dd 1b			call macro_forth_rsp_tos 
31f2				endm 
# End of macro FORTH_RSP_TOS
31f2			 
31f2					if DEBUG_FORTH_WORDS 
31f2						DMARK "LP8" 
31f2 f5				push af  
31f3 3a 07 32			ld a, (.dmark)  
31f6 32 71 ee			ld (debug_mark),a  
31f9 3a 08 32			ld a, (.dmark+1)  
31fc 32 72 ee			ld (debug_mark+1),a  
31ff 3a 09 32			ld a, (.dmark+2)  
3202 32 73 ee			ld (debug_mark+2),a  
3205 18 03			jr .pastdmark  
3207 ..			.dmark: db "LP8"  
320a f1			.pastdmark: pop af  
320b			endm  
# End of macro DMARK
320b					CALLMONITOR 
320b cd ae 15			call break_point_state  
320e				endm  
# End of macro CALLMONITOR
320e					endif 
320e				;push hl 
320e			 
320e				; not going to DO any more 
320e				; get rid of the RSP pointer as DO will add it back in 
320e				;FORTH_RSP_POP 
320e				;pop hl 
320e			 
320e				;ld hl,(cli_ret_sp) 
320e				;ld e, (hl) 
320e				;inc hl 
320e				;ld d, (hl) 
320e				;ex de,hl 
320e 22 cc e5			ld (os_tok_ptr), hl 
3211					if DEBUG_FORTH_WORDS 
3211						DMARK "LP<" 
3211 f5				push af  
3212 3a 26 32			ld a, (.dmark)  
3215 32 71 ee			ld (debug_mark),a  
3218 3a 27 32			ld a, (.dmark+1)  
321b 32 72 ee			ld (debug_mark+1),a  
321e 3a 28 32			ld a, (.dmark+2)  
3221 32 73 ee			ld (debug_mark+2),a  
3224 18 03			jr .pastdmark  
3226 ..			.dmark: db "LP<"  
3229 f1			.pastdmark: pop af  
322a			endm  
# End of macro DMARK
322a					CALLMONITOR 
322a cd ae 15			call break_point_state  
322d				endm  
# End of macro CALLMONITOR
322d				endif 
322d c3 5d 20			jp exec1 
3230			 
3230					 
3230			 
3230			 
3230					NEXTW 
3230 c3 cc 1f			jp macro_next 
3233				endm 
# End of macro NEXTW
3233			.I:  
3233			 
3233				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3233 5e				db WORD_SYS_CORE+74             
3234 5e 32			dw .DLOOP            
3236 02				db 1 + 1 
3237 .. 00			db "I",0              
3239				endm 
# End of macro CWHEAD
3239			; | I ( -- ) Current loop counter | DONE 
3239					if DEBUG_FORTH_WORDS_KEY 
3239						DMARK "I.." 
3239 f5				push af  
323a 3a 4e 32			ld a, (.dmark)  
323d 32 71 ee			ld (debug_mark),a  
3240 3a 4f 32			ld a, (.dmark+1)  
3243 32 72 ee			ld (debug_mark+1),a  
3246 3a 50 32			ld a, (.dmark+2)  
3249 32 73 ee			ld (debug_mark+2),a  
324c 18 03			jr .pastdmark  
324e ..			.dmark: db "I.."  
3251 f1			.pastdmark: pop af  
3252			endm  
# End of macro DMARK
3252						CALLMONITOR 
3252 cd ae 15			call break_point_state  
3255				endm  
# End of macro CALLMONITOR
3255					endif 
3255			 
3255 2a f0 e5				ld hl,(os_current_i) 
3258 cd 1f 1c				call forth_push_numhl 
325b			 
325b					NEXTW 
325b c3 cc 1f			jp macro_next 
325e				endm 
# End of macro NEXTW
325e			.DLOOP: 
325e				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
325e 5f				db WORD_SYS_CORE+75             
325f 3f 33			dw .REPEAT            
3261 06				db 5 + 1 
3262 .. 00			db "-LOOP",0              
3268				endm 
# End of macro CWHEAD
3268			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3268				; pop tos as current loop count to hl 
3268					if DEBUG_FORTH_WORDS_KEY 
3268						DMARK "-LP" 
3268 f5				push af  
3269 3a 7d 32			ld a, (.dmark)  
326c 32 71 ee			ld (debug_mark),a  
326f 3a 7e 32			ld a, (.dmark+1)  
3272 32 72 ee			ld (debug_mark+1),a  
3275 3a 7f 32			ld a, (.dmark+2)  
3278 32 73 ee			ld (debug_mark+2),a  
327b 18 03			jr .pastdmark  
327d ..			.dmark: db "-LP"  
3280 f1			.pastdmark: pop af  
3281			endm  
# End of macro DMARK
3281						CALLMONITOR 
3281 cd ae 15			call break_point_state  
3284				endm  
# End of macro CALLMONITOR
3284					endif 
3284			 
3284				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3284			 
3284				FORTH_LOOP_TOS 
3284 cd 7a 1e			call macro_forth_loop_tos 
3287				endm 
# End of macro FORTH_LOOP_TOS
3287 e5				push hl 
3288			 
3288					if DEBUG_FORTH_WORDS 
3288						DMARK "-LP" 
3288 f5				push af  
3289 3a 9d 32			ld a, (.dmark)  
328c 32 71 ee			ld (debug_mark),a  
328f 3a 9e 32			ld a, (.dmark+1)  
3292 32 72 ee			ld (debug_mark+1),a  
3295 3a 9f 32			ld a, (.dmark+2)  
3298 32 73 ee			ld (debug_mark+2),a  
329b 18 03			jr .pastdmark  
329d ..			.dmark: db "-LP"  
32a0 f1			.pastdmark: pop af  
32a1			endm  
# End of macro DMARK
32a1						CALLMONITOR 
32a1 cd ae 15			call break_point_state  
32a4				endm  
# End of macro CALLMONITOR
32a4					endif 
32a4				; next item on the stack is the limit. get it 
32a4			 
32a4			 
32a4				FORTH_LOOP_POP 
32a4 cd 84 1e			call macro_forth_loop_pop 
32a7				endm 
# End of macro FORTH_LOOP_POP
32a7			 
32a7				FORTH_LOOP_TOS 
32a7 cd 7a 1e			call macro_forth_loop_tos 
32aa				endm 
# End of macro FORTH_LOOP_TOS
32aa			 
32aa d1				pop de		 ; de = i, hl = limit 
32ab			 
32ab					if DEBUG_FORTH_WORDS 
32ab						DMARK "-L1" 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 71 ee			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 72 ee			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 73 ee			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "-L1"  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd ae 15			call break_point_state  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7			 
32c7				; go back to previous word 
32c7			 
32c7 d5				push de    ; save I for inc later 
32c8			 
32c8			 
32c8				; get limit 
32c8				;  is I at limit? 
32c8			 
32c8			 
32c8					if DEBUG_FORTH_WORDS 
32c8						DMARK "-L1" 
32c8 f5				push af  
32c9 3a dd 32			ld a, (.dmark)  
32cc 32 71 ee			ld (debug_mark),a  
32cf 3a de 32			ld a, (.dmark+1)  
32d2 32 72 ee			ld (debug_mark+1),a  
32d5 3a df 32			ld a, (.dmark+2)  
32d8 32 73 ee			ld (debug_mark+2),a  
32db 18 03			jr .pastdmark  
32dd ..			.dmark: db "-L1"  
32e0 f1			.pastdmark: pop af  
32e1			endm  
# End of macro DMARK
32e1						CALLMONITOR 
32e1 cd ae 15			call break_point_state  
32e4				endm  
# End of macro CALLMONITOR
32e4					endif 
32e4			 
32e4 ed 52			sbc hl, de 
32e6			 
32e6			 
32e6				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32e6			 
32e6 20 26				jr nz, .mloopnotdone 
32e8			 
32e8 e1				pop hl   ; get rid of saved I 
32e9				FORTH_LOOP_POP     ; get rid of limit 
32e9 cd 84 1e			call macro_forth_loop_pop 
32ec				endm 
# End of macro FORTH_LOOP_POP
32ec			 
32ec				FORTH_RSP_POP     ; get rid of DO ptr 
32ec cd e7 1b			call macro_forth_rsp_pop 
32ef				endm 
# End of macro FORTH_RSP_POP
32ef			 
32ef			if DEBUG_FORTH_WORDS 
32ef						DMARK "-L>" 
32ef f5				push af  
32f0 3a 04 33			ld a, (.dmark)  
32f3 32 71 ee			ld (debug_mark),a  
32f6 3a 05 33			ld a, (.dmark+1)  
32f9 32 72 ee			ld (debug_mark+1),a  
32fc 3a 06 33			ld a, (.dmark+2)  
32ff 32 73 ee			ld (debug_mark+2),a  
3302 18 03			jr .pastdmark  
3304 ..			.dmark: db "-L>"  
3307 f1			.pastdmark: pop af  
3308			endm  
# End of macro DMARK
3308				CALLMONITOR 
3308 cd ae 15			call break_point_state  
330b				endm  
# End of macro CALLMONITOR
330b			endif 
330b			 
330b					NEXTW 
330b c3 cc 1f			jp macro_next 
330e				endm 
# End of macro NEXTW
330e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
330e			 
330e			.mloopnotdone: 
330e			 
330e e1				pop hl    ; get I 
330f 2b				dec hl 
3310			 
3310			   	; save new I 
3310			 
3310			 
3310					; set I counter 
3310			 
3310 22 f0 e5				ld (os_current_i), hl 
3313			 
3313					 
3313				FORTH_LOOP_NEXT 
3313 cd 47 1e			call macro_forth_loop_next 
3316				endm 
# End of macro FORTH_LOOP_NEXT
3316			 
3316			 
3316					if DEBUG_FORTH_WORDS 
3316 eb						ex de,hl 
3317					endif 
3317			 
3317			;	; get DO ptr 
3317			; 
3317				FORTH_RSP_TOS 
3317 cd dd 1b			call macro_forth_rsp_tos 
331a				endm 
# End of macro FORTH_RSP_TOS
331a			 
331a				;push hl 
331a			 
331a				; not going to DO any more 
331a				; get rid of the RSP pointer as DO will add it back in 
331a				;FORTH_RSP_POP 
331a				;pop hl 
331a			 
331a			 
331a 22 cc e5			ld (os_tok_ptr), hl 
331d					if DEBUG_FORTH_WORDS 
331d						DMARK "-L<" 
331d f5				push af  
331e 3a 32 33			ld a, (.dmark)  
3321 32 71 ee			ld (debug_mark),a  
3324 3a 33 33			ld a, (.dmark+1)  
3327 32 72 ee			ld (debug_mark+1),a  
332a 3a 34 33			ld a, (.dmark+2)  
332d 32 73 ee			ld (debug_mark+2),a  
3330 18 03			jr .pastdmark  
3332 ..			.dmark: db "-L<"  
3335 f1			.pastdmark: pop af  
3336			endm  
# End of macro DMARK
3336					CALLMONITOR 
3336 cd ae 15			call break_point_state  
3339				endm  
# End of macro CALLMONITOR
3339				endif 
3339 c3 5d 20			jp exec1 
333c			 
333c					 
333c			 
333c			 
333c			 
333c				NEXTW 
333c c3 cc 1f			jp macro_next 
333f				endm 
# End of macro NEXTW
333f			 
333f			 
333f			 
333f			 
333f			.REPEAT: 
333f				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
333f 71				db WORD_SYS_CORE+93             
3340 92 33			dw .UNTIL            
3342 06				db 5 + 1 
3343 .. 00			db "REPEAT",0              
334a				endm 
# End of macro CWHEAD
334a			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
334a			;  push pc to rsp stack past the REPEAT 
334a					if DEBUG_FORTH_WORDS_KEY 
334a						DMARK "REP" 
334a f5				push af  
334b 3a 5f 33			ld a, (.dmark)  
334e 32 71 ee			ld (debug_mark),a  
3351 3a 60 33			ld a, (.dmark+1)  
3354 32 72 ee			ld (debug_mark+1),a  
3357 3a 61 33			ld a, (.dmark+2)  
335a 32 73 ee			ld (debug_mark+2),a  
335d 18 03			jr .pastdmark  
335f ..			.dmark: db "REP"  
3362 f1			.pastdmark: pop af  
3363			endm  
# End of macro DMARK
3363						CALLMONITOR 
3363 cd ae 15			call break_point_state  
3366				endm  
# End of macro CALLMONITOR
3366					endif 
3366			 
3366 2a cc e5				ld hl, (os_tok_ptr) 
3369 23					inc hl   ; R 
336a 23					inc hl  ; E 
336b 23					inc hl   ; P 
336c 23					inc hl   ; E 
336d 23					inc hl   ; A 
336e 23					inc hl   ; T 
336f 23					inc hl   ; zero 
3370					FORTH_RSP_NEXT 
3370 cd c6 1b			call macro_forth_rsp_next 
3373				endm 
# End of macro FORTH_RSP_NEXT
3373			 
3373			 
3373					if DEBUG_FORTH_WORDS 
3373						DMARK "REP" 
3373 f5				push af  
3374 3a 88 33			ld a, (.dmark)  
3377 32 71 ee			ld (debug_mark),a  
337a 3a 89 33			ld a, (.dmark+1)  
337d 32 72 ee			ld (debug_mark+1),a  
3380 3a 8a 33			ld a, (.dmark+2)  
3383 32 73 ee			ld (debug_mark+2),a  
3386 18 03			jr .pastdmark  
3388 ..			.dmark: db "REP"  
338b f1			.pastdmark: pop af  
338c			endm  
# End of macro DMARK
338c						;pop bc    ; TODO BUG ?????? what is this for???? 
338c						CALLMONITOR 
338c cd ae 15			call break_point_state  
338f				endm  
# End of macro CALLMONITOR
338f					endif 
338f			 
338f					NEXTW 
338f c3 cc 1f			jp macro_next 
3392				endm 
# End of macro NEXTW
3392			;	       NEXTW 
3392			 
3392			.UNTIL: 
3392				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3392 72				db WORD_SYS_CORE+94             
3393 29 34			dw .ENDFLOW            
3395 06				db 5 + 1 
3396 .. 00			db "UNTIL",0              
339c				endm 
# End of macro CWHEAD
339c			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
339c			 
339c				; pop tos as check 
339c			 
339c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
339c			 
339c				FORTH_DSP_VALUEHL 
339c cd 16 1e			call macro_dsp_valuehl 
339f				endm 
# End of macro FORTH_DSP_VALUEHL
339f			 
339f					if DEBUG_FORTH_WORDS_KEY 
339f						DMARK "UNT" 
339f f5				push af  
33a0 3a b4 33			ld a, (.dmark)  
33a3 32 71 ee			ld (debug_mark),a  
33a6 3a b5 33			ld a, (.dmark+1)  
33a9 32 72 ee			ld (debug_mark+1),a  
33ac 3a b6 33			ld a, (.dmark+2)  
33af 32 73 ee			ld (debug_mark+2),a  
33b2 18 03			jr .pastdmark  
33b4 ..			.dmark: db "UNT"  
33b7 f1			.pastdmark: pop af  
33b8			endm  
# End of macro DMARK
33b8						CALLMONITOR 
33b8 cd ae 15			call break_point_state  
33bb				endm  
# End of macro CALLMONITOR
33bb					endif 
33bb			 
33bb			;	push hl 
33bb				FORTH_DSP_POP 
33bb cd ce 1e			call macro_forth_dsp_pop 
33be				endm 
# End of macro FORTH_DSP_POP
33be			 
33be			;	pop hl 
33be			 
33be				; test if true 
33be			 
33be cd d6 0d			call ishlzero 
33c1			;	ld a,l 
33c1			;	add h 
33c1			; 
33c1			;	cp 0 
33c1			 
33c1 20 3e			jr nz, .untilnotdone 
33c3			 
33c3					if DEBUG_FORTH_WORDS 
33c3						DMARK "UNf" 
33c3 f5				push af  
33c4 3a d8 33			ld a, (.dmark)  
33c7 32 71 ee			ld (debug_mark),a  
33ca 3a d9 33			ld a, (.dmark+1)  
33cd 32 72 ee			ld (debug_mark+1),a  
33d0 3a da 33			ld a, (.dmark+2)  
33d3 32 73 ee			ld (debug_mark+2),a  
33d6 18 03			jr .pastdmark  
33d8 ..			.dmark: db "UNf"  
33db f1			.pastdmark: pop af  
33dc			endm  
# End of macro DMARK
33dc						CALLMONITOR 
33dc cd ae 15			call break_point_state  
33df				endm  
# End of macro CALLMONITOR
33df					endif 
33df			 
33df			 
33df			 
33df				FORTH_RSP_POP     ; get rid of DO ptr 
33df cd e7 1b			call macro_forth_rsp_pop 
33e2				endm 
# End of macro FORTH_RSP_POP
33e2			 
33e2			if DEBUG_FORTH_WORDS 
33e2						DMARK "UN>" 
33e2 f5				push af  
33e3 3a f7 33			ld a, (.dmark)  
33e6 32 71 ee			ld (debug_mark),a  
33e9 3a f8 33			ld a, (.dmark+1)  
33ec 32 72 ee			ld (debug_mark+1),a  
33ef 3a f9 33			ld a, (.dmark+2)  
33f2 32 73 ee			ld (debug_mark+2),a  
33f5 18 03			jr .pastdmark  
33f7 ..			.dmark: db "UN>"  
33fa f1			.pastdmark: pop af  
33fb			endm  
# End of macro DMARK
33fb				CALLMONITOR 
33fb cd ae 15			call break_point_state  
33fe				endm  
# End of macro CALLMONITOR
33fe			endif 
33fe			 
33fe					NEXTW 
33fe c3 cc 1f			jp macro_next 
3401				endm 
# End of macro NEXTW
3401				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3401			 
3401			.untilnotdone: 
3401			 
3401			 
3401			;	; get DO ptr 
3401			; 
3401				FORTH_RSP_TOS 
3401 cd dd 1b			call macro_forth_rsp_tos 
3404				endm 
# End of macro FORTH_RSP_TOS
3404			 
3404				;push hl 
3404			 
3404				; not going to DO any more 
3404				; get rid of the RSP pointer as DO will add it back in 
3404				;FORTH_RSP_POP 
3404				;pop hl 
3404			 
3404			 
3404 22 cc e5			ld (os_tok_ptr), hl 
3407					if DEBUG_FORTH_WORDS 
3407						DMARK "UN<" 
3407 f5				push af  
3408 3a 1c 34			ld a, (.dmark)  
340b 32 71 ee			ld (debug_mark),a  
340e 3a 1d 34			ld a, (.dmark+1)  
3411 32 72 ee			ld (debug_mark+1),a  
3414 3a 1e 34			ld a, (.dmark+2)  
3417 32 73 ee			ld (debug_mark+2),a  
341a 18 03			jr .pastdmark  
341c ..			.dmark: db "UN<"  
341f f1			.pastdmark: pop af  
3420			endm  
# End of macro DMARK
3420					CALLMONITOR 
3420 cd ae 15			call break_point_state  
3423				endm  
# End of macro CALLMONITOR
3423				endif 
3423 c3 5d 20			jp exec1 
3426			 
3426					 
3426			 
3426			 
3426					NEXTW 
3426 c3 cc 1f			jp macro_next 
3429				endm 
# End of macro NEXTW
3429			 
3429			 
3429			.ENDFLOW: 
3429			 
3429			; eof 
3429			 
# End of file forth_words_flow.asm
3429			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3429			include "forth_words_logic.asm" 
3429			 
3429			; | ## Logic Words 
3429			 
3429			.NOT: 
3429				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3429 2d				db WORD_SYS_CORE+25             
342a 71 34			dw .IS            
342c 04				db 3 + 1 
342d .. 00			db "NOT",0              
3431				endm 
# End of macro CWHEAD
3431			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3431					if DEBUG_FORTH_WORDS_KEY 
3431						DMARK "NOT" 
3431 f5				push af  
3432 3a 46 34			ld a, (.dmark)  
3435 32 71 ee			ld (debug_mark),a  
3438 3a 47 34			ld a, (.dmark+1)  
343b 32 72 ee			ld (debug_mark+1),a  
343e 3a 48 34			ld a, (.dmark+2)  
3441 32 73 ee			ld (debug_mark+2),a  
3444 18 03			jr .pastdmark  
3446 ..			.dmark: db "NOT"  
3449 f1			.pastdmark: pop af  
344a			endm  
# End of macro DMARK
344a						CALLMONITOR 
344a cd ae 15			call break_point_state  
344d				endm  
# End of macro CALLMONITOR
344d					endif 
344d					FORTH_DSP 
344d cd dc 1d			call macro_forth_dsp 
3450				endm 
# End of macro FORTH_DSP
3450 7e					ld a,(hl)	; get type of value on TOS 
3451 fe 02				cp DS_TYPE_INUM  
3453 28 03				jr z, .noti 
3455					NEXTW 
3455 c3 cc 1f			jp macro_next 
3458				endm 
# End of macro NEXTW
3458			.noti:          FORTH_DSP_VALUEHL 
3458 cd 16 1e			call macro_dsp_valuehl 
345b				endm 
# End of macro FORTH_DSP_VALUEHL
345b			;		push hl 
345b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
345b cd ce 1e			call macro_forth_dsp_pop 
345e				endm 
# End of macro FORTH_DSP_POP
345e			;		pop hl 
345e 3e 00				ld a,0 
3460 bd					cp l 
3461 28 04				jr z, .not2t 
3463 2e 00				ld l, 0 
3465 18 02				jr .notip 
3467			 
3467 2e ff		.not2t:		ld l, 255 
3469			 
3469 26 00		.notip:		ld h, 0	 
346b			 
346b cd 1f 1c				call forth_push_numhl 
346e					NEXTW 
346e c3 cc 1f			jp macro_next 
3471				endm 
# End of macro NEXTW
3471			 
3471			.IS: 
3471				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3471 2d				db WORD_SYS_CORE+25             
3472 97 34			dw .LZERO            
3474 03				db 2 + 1 
3475 .. 00			db "IS",0              
3478				endm 
# End of macro CWHEAD
3478			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3478					if DEBUG_FORTH_WORDS_KEY 
3478						DMARK "IS." 
3478 f5				push af  
3479 3a 8d 34			ld a, (.dmark)  
347c 32 71 ee			ld (debug_mark),a  
347f 3a 8e 34			ld a, (.dmark+1)  
3482 32 72 ee			ld (debug_mark+1),a  
3485 3a 8f 34			ld a, (.dmark+2)  
3488 32 73 ee			ld (debug_mark+2),a  
348b 18 03			jr .pastdmark  
348d ..			.dmark: db "IS."  
3490 f1			.pastdmark: pop af  
3491			endm  
# End of macro DMARK
3491						CALLMONITOR 
3491 cd ae 15			call break_point_state  
3494				endm  
# End of macro CALLMONITOR
3494					endif 
3494					NEXTW 
3494 c3 cc 1f			jp macro_next 
3497				endm 
# End of macro NEXTW
3497			.LZERO: 
3497				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3497 2d				db WORD_SYS_CORE+25             
3498 a1 34			dw .TZERO            
349a 03				db 2 + 1 
349b .. 00			db "0<",0              
349e				endm 
# End of macro CWHEAD
349e			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
349e					NEXTW 
349e c3 cc 1f			jp macro_next 
34a1				endm 
# End of macro NEXTW
34a1			.TZERO: 
34a1				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34a1 2e				db WORD_SYS_CORE+26             
34a2 e8 34			dw .LESS            
34a4 03				db 2 + 1 
34a5 .. 00			db "0=",0              
34a8				endm 
# End of macro CWHEAD
34a8			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34a8				; TODO add floating point number detection 
34a8					;v5 FORTH_DSP_VALUE 
34a8					if DEBUG_FORTH_WORDS_KEY 
34a8						DMARK "0=." 
34a8 f5				push af  
34a9 3a bd 34			ld a, (.dmark)  
34ac 32 71 ee			ld (debug_mark),a  
34af 3a be 34			ld a, (.dmark+1)  
34b2 32 72 ee			ld (debug_mark+1),a  
34b5 3a bf 34			ld a, (.dmark+2)  
34b8 32 73 ee			ld (debug_mark+2),a  
34bb 18 03			jr .pastdmark  
34bd ..			.dmark: db "0=."  
34c0 f1			.pastdmark: pop af  
34c1			endm  
# End of macro DMARK
34c1						CALLMONITOR 
34c1 cd ae 15			call break_point_state  
34c4				endm  
# End of macro CALLMONITOR
34c4					endif 
34c4					FORTH_DSP 
34c4 cd dc 1d			call macro_forth_dsp 
34c7				endm 
# End of macro FORTH_DSP
34c7 7e					ld a,(hl)	; get type of value on TOS 
34c8 fe 02				cp DS_TYPE_INUM  
34ca 28 00				jr z, .tz_inum 
34cc			 
34cc				if FORTH_ENABLE_FLOATMATH 
34cc					jr .tz_done 
34cc			 
34cc				endif 
34cc					 
34cc			 
34cc			.tz_inum: 
34cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34cc cd 16 1e			call macro_dsp_valuehl 
34cf				endm 
# End of macro FORTH_DSP_VALUEHL
34cf			 
34cf			;		push hl 
34cf			 
34cf					; destroy value TOS 
34cf			 
34cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34cf cd ce 1e			call macro_forth_dsp_pop 
34d2				endm 
# End of macro FORTH_DSP_POP
34d2			 
34d2			;		pop hl 
34d2			 
34d2 3e 00				ld a,0 
34d4			 
34d4 bd					cp l 
34d5 20 08				jr nz, .tz_notzero 
34d7			 
34d7 bc					cp h 
34d8			 
34d8 20 05				jr nz, .tz_notzero 
34da			 
34da			 
34da 21 01 00				ld hl, FORTH_TRUE 
34dd 18 03				jr .tz_done 
34df			 
34df 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34e2			 
34e2					; push value back onto stack for another op etc 
34e2			 
34e2			.tz_done: 
34e2 cd 1f 1c				call forth_push_numhl 
34e5			 
34e5					NEXTW 
34e5 c3 cc 1f			jp macro_next 
34e8				endm 
# End of macro NEXTW
34e8			.LESS: 
34e8				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34e8 2f				db WORD_SYS_CORE+27             
34e9 51 35			dw .GT            
34eb 02				db 1 + 1 
34ec .. 00			db "<",0              
34ee				endm 
# End of macro CWHEAD
34ee			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34ee				; TODO add floating point number detection 
34ee					if DEBUG_FORTH_WORDS_KEY 
34ee						DMARK "LES" 
34ee f5				push af  
34ef 3a 03 35			ld a, (.dmark)  
34f2 32 71 ee			ld (debug_mark),a  
34f5 3a 04 35			ld a, (.dmark+1)  
34f8 32 72 ee			ld (debug_mark+1),a  
34fb 3a 05 35			ld a, (.dmark+2)  
34fe 32 73 ee			ld (debug_mark+2),a  
3501 18 03			jr .pastdmark  
3503 ..			.dmark: db "LES"  
3506 f1			.pastdmark: pop af  
3507			endm  
# End of macro DMARK
3507						CALLMONITOR 
3507 cd ae 15			call break_point_state  
350a				endm  
# End of macro CALLMONITOR
350a					endif 
350a					FORTH_DSP 
350a cd dc 1d			call macro_forth_dsp 
350d				endm 
# End of macro FORTH_DSP
350d					;v5 FORTH_DSP_VALUE 
350d 7e					ld a,(hl)	; get type of value on TOS 
350e fe 02				cp DS_TYPE_INUM  
3510 28 00				jr z, .less_inum 
3512			 
3512				if FORTH_ENABLE_FLOATMATH 
3512					jr .less_done 
3512			 
3512				endif 
3512					 
3512			 
3512			.less_inum: 
3512					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3512 cd 16 1e			call macro_dsp_valuehl 
3515				endm 
# End of macro FORTH_DSP_VALUEHL
3515			 
3515 e5					push hl  ; u2 
3516			 
3516					; destroy value TOS 
3516			 
3516					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3516 cd ce 1e			call macro_forth_dsp_pop 
3519				endm 
# End of macro FORTH_DSP_POP
3519			 
3519			 
3519					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3519 cd 16 1e			call macro_dsp_valuehl 
351c				endm 
# End of macro FORTH_DSP_VALUEHL
351c			 
351c e5					push hl    ; u1 
351d			 
351d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
351d cd ce 1e			call macro_forth_dsp_pop 
3520				endm 
# End of macro FORTH_DSP_POP
3520			 
3520			 
3520 b7			 or a      ;clear carry flag 
3521 01 00 00		 ld bc, FORTH_FALSE 
3524 e1			  pop hl    ; u1 
3525 d1			  pop de    ; u2 
3526 ed 52		  sbc hl,de 
3528 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
352a			 
352a 01 01 00		 ld bc, FORTH_TRUE 
352d			.lscont:  
352d c5					push bc 
352e e1					pop hl 
352f			 
352f					if DEBUG_FORTH_WORDS 
352f						DMARK "LT1" 
352f f5				push af  
3530 3a 44 35			ld a, (.dmark)  
3533 32 71 ee			ld (debug_mark),a  
3536 3a 45 35			ld a, (.dmark+1)  
3539 32 72 ee			ld (debug_mark+1),a  
353c 3a 46 35			ld a, (.dmark+2)  
353f 32 73 ee			ld (debug_mark+2),a  
3542 18 03			jr .pastdmark  
3544 ..			.dmark: db "LT1"  
3547 f1			.pastdmark: pop af  
3548			endm  
# End of macro DMARK
3548						CALLMONITOR 
3548 cd ae 15			call break_point_state  
354b				endm  
# End of macro CALLMONITOR
354b					endif 
354b cd 1f 1c				call forth_push_numhl 
354e			 
354e					NEXTW 
354e c3 cc 1f			jp macro_next 
3551				endm 
# End of macro NEXTW
3551			.GT: 
3551				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3551 30				db WORD_SYS_CORE+28             
3552 ba 35			dw .EQUAL            
3554 02				db 1 + 1 
3555 .. 00			db ">",0              
3557				endm 
# End of macro CWHEAD
3557			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3557				; TODO add floating point number detection 
3557					if DEBUG_FORTH_WORDS_KEY 
3557						DMARK "GRT" 
3557 f5				push af  
3558 3a 6c 35			ld a, (.dmark)  
355b 32 71 ee			ld (debug_mark),a  
355e 3a 6d 35			ld a, (.dmark+1)  
3561 32 72 ee			ld (debug_mark+1),a  
3564 3a 6e 35			ld a, (.dmark+2)  
3567 32 73 ee			ld (debug_mark+2),a  
356a 18 03			jr .pastdmark  
356c ..			.dmark: db "GRT"  
356f f1			.pastdmark: pop af  
3570			endm  
# End of macro DMARK
3570						CALLMONITOR 
3570 cd ae 15			call break_point_state  
3573				endm  
# End of macro CALLMONITOR
3573					endif 
3573					FORTH_DSP 
3573 cd dc 1d			call macro_forth_dsp 
3576				endm 
# End of macro FORTH_DSP
3576					;FORTH_DSP_VALUE 
3576 7e					ld a,(hl)	; get type of value on TOS 
3577 fe 02				cp DS_TYPE_INUM  
3579 28 00				jr z, .gt_inum 
357b			 
357b				if FORTH_ENABLE_FLOATMATH 
357b					jr .gt_done 
357b			 
357b				endif 
357b					 
357b			 
357b			.gt_inum: 
357b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
357b cd 16 1e			call macro_dsp_valuehl 
357e				endm 
# End of macro FORTH_DSP_VALUEHL
357e			 
357e e5					push hl  ; u2 
357f			 
357f					; destroy value TOS 
357f			 
357f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
357f cd ce 1e			call macro_forth_dsp_pop 
3582				endm 
# End of macro FORTH_DSP_POP
3582			 
3582			 
3582					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3582 cd 16 1e			call macro_dsp_valuehl 
3585				endm 
# End of macro FORTH_DSP_VALUEHL
3585			 
3585 e5					push hl    ; u1 
3586			 
3586					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3586 cd ce 1e			call macro_forth_dsp_pop 
3589				endm 
# End of macro FORTH_DSP_POP
3589			 
3589			 
3589 b7			 or a      ;clear carry flag 
358a 01 00 00		 ld bc, FORTH_FALSE 
358d e1			  pop hl    ; u1 
358e d1			  pop de    ; u2 
358f ed 52		  sbc hl,de 
3591 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3593			 
3593 01 01 00		 ld bc, FORTH_TRUE 
3596			.gtcont:  
3596 c5					push bc 
3597 e1					pop hl 
3598			 
3598					if DEBUG_FORTH_WORDS 
3598						DMARK "GT1" 
3598 f5				push af  
3599 3a ad 35			ld a, (.dmark)  
359c 32 71 ee			ld (debug_mark),a  
359f 3a ae 35			ld a, (.dmark+1)  
35a2 32 72 ee			ld (debug_mark+1),a  
35a5 3a af 35			ld a, (.dmark+2)  
35a8 32 73 ee			ld (debug_mark+2),a  
35ab 18 03			jr .pastdmark  
35ad ..			.dmark: db "GT1"  
35b0 f1			.pastdmark: pop af  
35b1			endm  
# End of macro DMARK
35b1						CALLMONITOR 
35b1 cd ae 15			call break_point_state  
35b4				endm  
# End of macro CALLMONITOR
35b4					endif 
35b4 cd 1f 1c				call forth_push_numhl 
35b7			 
35b7					NEXTW 
35b7 c3 cc 1f			jp macro_next 
35ba				endm 
# End of macro NEXTW
35ba			.EQUAL: 
35ba				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35ba 31				db WORD_SYS_CORE+29             
35bb 25 36			dw .ENDLOGIC            
35bd 02				db 1 + 1 
35be .. 00			db "=",0              
35c0				endm 
# End of macro CWHEAD
35c0			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35c0				; TODO add floating point number detection 
35c0					if DEBUG_FORTH_WORDS_KEY 
35c0						DMARK "EQ." 
35c0 f5				push af  
35c1 3a d5 35			ld a, (.dmark)  
35c4 32 71 ee			ld (debug_mark),a  
35c7 3a d6 35			ld a, (.dmark+1)  
35ca 32 72 ee			ld (debug_mark+1),a  
35cd 3a d7 35			ld a, (.dmark+2)  
35d0 32 73 ee			ld (debug_mark+2),a  
35d3 18 03			jr .pastdmark  
35d5 ..			.dmark: db "EQ."  
35d8 f1			.pastdmark: pop af  
35d9			endm  
# End of macro DMARK
35d9						CALLMONITOR 
35d9 cd ae 15			call break_point_state  
35dc				endm  
# End of macro CALLMONITOR
35dc					endif 
35dc					FORTH_DSP 
35dc cd dc 1d			call macro_forth_dsp 
35df				endm 
# End of macro FORTH_DSP
35df					;v5 FORTH_DSP_VALUE 
35df 7e					ld a,(hl)	; get type of value on TOS 
35e0 fe 02				cp DS_TYPE_INUM  
35e2 28 00				jr z, .eq_inum 
35e4			 
35e4				if FORTH_ENABLE_FLOATMATH 
35e4					jr .eq_done 
35e4			 
35e4				endif 
35e4					 
35e4			 
35e4			.eq_inum: 
35e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e4 cd 16 1e			call macro_dsp_valuehl 
35e7				endm 
# End of macro FORTH_DSP_VALUEHL
35e7			 
35e7 e5					push hl 
35e8			 
35e8					; destroy value TOS 
35e8			 
35e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e8 cd ce 1e			call macro_forth_dsp_pop 
35eb				endm 
# End of macro FORTH_DSP_POP
35eb			 
35eb			 
35eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35eb cd 16 1e			call macro_dsp_valuehl 
35ee				endm 
# End of macro FORTH_DSP_VALUEHL
35ee			 
35ee					; one value on hl get other one back 
35ee			 
35ee e5					push hl 
35ef			 
35ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ef cd ce 1e			call macro_forth_dsp_pop 
35f2				endm 
# End of macro FORTH_DSP_POP
35f2			 
35f2 0e 00				ld c, FORTH_FALSE 
35f4			 
35f4 e1					pop hl 
35f5 d1					pop de 
35f6			 
35f6 7b					ld a, e 
35f7 bd					cp l 
35f8			 
35f8 20 06				jr nz, .eq_done 
35fa			 
35fa 7a					ld a, d 
35fb bc					cp h 
35fc			 
35fc 20 02				jr nz, .eq_done 
35fe			 
35fe 0e 01				ld c, FORTH_TRUE 
3600					 
3600			 
3600			 
3600			.eq_done: 
3600			 
3600					; TODO push value back onto stack for another op etc 
3600			 
3600 26 00				ld h, 0 
3602 69					ld l, c 
3603					if DEBUG_FORTH_WORDS 
3603						DMARK "EQ1" 
3603 f5				push af  
3604 3a 18 36			ld a, (.dmark)  
3607 32 71 ee			ld (debug_mark),a  
360a 3a 19 36			ld a, (.dmark+1)  
360d 32 72 ee			ld (debug_mark+1),a  
3610 3a 1a 36			ld a, (.dmark+2)  
3613 32 73 ee			ld (debug_mark+2),a  
3616 18 03			jr .pastdmark  
3618 ..			.dmark: db "EQ1"  
361b f1			.pastdmark: pop af  
361c			endm  
# End of macro DMARK
361c						CALLMONITOR 
361c cd ae 15			call break_point_state  
361f				endm  
# End of macro CALLMONITOR
361f					endif 
361f cd 1f 1c				call forth_push_numhl 
3622			 
3622					NEXTW 
3622 c3 cc 1f			jp macro_next 
3625				endm 
# End of macro NEXTW
3625			 
3625			 
3625			.ENDLOGIC: 
3625			; eof 
3625			 
3625			 
# End of file forth_words_logic.asm
3625			include "forth_words_maths.asm" 
3625			 
3625			; | ## Maths Words 
3625			 
3625			.PLUS:	 
3625				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3625 15				db WORD_SYS_CORE+1             
3626 83 36			dw .NEG            
3628 02				db 1 + 1 
3629 .. 00			db "+",0              
362b				endm 
# End of macro CWHEAD
362b			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
362b					if DEBUG_FORTH_WORDS_KEY 
362b						DMARK "PLU" 
362b f5				push af  
362c 3a 40 36			ld a, (.dmark)  
362f 32 71 ee			ld (debug_mark),a  
3632 3a 41 36			ld a, (.dmark+1)  
3635 32 72 ee			ld (debug_mark+1),a  
3638 3a 42 36			ld a, (.dmark+2)  
363b 32 73 ee			ld (debug_mark+2),a  
363e 18 03			jr .pastdmark  
3640 ..			.dmark: db "PLU"  
3643 f1			.pastdmark: pop af  
3644			endm  
# End of macro DMARK
3644						CALLMONITOR 
3644 cd ae 15			call break_point_state  
3647				endm  
# End of macro CALLMONITOR
3647					endif 
3647					; add top two values and push back result 
3647			 
3647					;for v5 FORTH_DSP_VALUE 
3647					FORTH_DSP 
3647 cd dc 1d			call macro_forth_dsp 
364a				endm 
# End of macro FORTH_DSP
364a 7e					ld a,(hl)	; get type of value on TOS 
364b fe 02				cp DS_TYPE_INUM  
364d 28 03				jr z, .dot_inum 
364f			 
364f					NEXTW 
364f c3 cc 1f			jp macro_next 
3652				endm 
# End of macro NEXTW
3652			 
3652			; float maths 
3652			 
3652				if FORTH_ENABLE_FLOATMATH 
3652						inc hl      ; now at start of numeric as string 
3652			 
3652					if DEBUG_FORTH_MATHS 
3652						DMARK "ADD" 
3652				CALLMONITOR 
3652					endif 
3652			 
3652					;ld ix, hl 
3652					call CON 
3652			 
3652			 
3652					push hl 
3652					 
3652					 
3652			 
3652						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3652			 
3652					; get next number 
3652			 
3652						FORTH_DSP_VALUE 
3652			 
3652						inc hl      ; now at start of numeric as string 
3652			 
3652					;ld ix, hl 
3652					call CON 
3652			 
3652					push hl 
3652			 
3652			 
3652						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3652			 
3652						; TODO do add 
3652			 
3652						call IADD 
3652			 
3652						; TODO get result back as ascii 
3652			 
3652						; TODO push result  
3652			 
3652			 
3652			 
3652						jr .dot_done 
3652				endif 
3652			 
3652			.dot_inum: 
3652			 
3652			 
3652					if DEBUG_FORTH_DOT 
3652						DMARK "+IT" 
3652 f5				push af  
3653 3a 67 36			ld a, (.dmark)  
3656 32 71 ee			ld (debug_mark),a  
3659 3a 68 36			ld a, (.dmark+1)  
365c 32 72 ee			ld (debug_mark+1),a  
365f 3a 69 36			ld a, (.dmark+2)  
3662 32 73 ee			ld (debug_mark+2),a  
3665 18 03			jr .pastdmark  
3667 ..			.dmark: db "+IT"  
366a f1			.pastdmark: pop af  
366b			endm  
# End of macro DMARK
366b				CALLMONITOR 
366b cd ae 15			call break_point_state  
366e				endm  
# End of macro CALLMONITOR
366e					endif 
366e			 
366e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366e cd 16 1e			call macro_dsp_valuehl 
3671				endm 
# End of macro FORTH_DSP_VALUEHL
3671			 
3671				; TODO add floating point number detection 
3671			 
3671 e5					push hl 
3672			 
3672					; destroy value TOS 
3672			 
3672					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3672 cd ce 1e			call macro_forth_dsp_pop 
3675				endm 
# End of macro FORTH_DSP_POP
3675			 
3675			 
3675					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3675 cd 16 1e			call macro_dsp_valuehl 
3678				endm 
# End of macro FORTH_DSP_VALUEHL
3678			 
3678					; one value on hl get other one back 
3678			 
3678 d1					pop de 
3679			 
3679					; do the add 
3679			 
3679 19					add hl,de 
367a			 
367a					; save it 
367a			 
367a			;		push hl	 
367a			 
367a					; 
367a			 
367a					; destroy value TOS 
367a			 
367a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
367a cd ce 1e			call macro_forth_dsp_pop 
367d				endm 
# End of macro FORTH_DSP_POP
367d			 
367d					; TODO push value back onto stack for another op etc 
367d			 
367d			;		pop hl 
367d			 
367d			.dot_done: 
367d cd 1f 1c				call forth_push_numhl 
3680			 
3680					NEXTW 
3680 c3 cc 1f			jp macro_next 
3683				endm 
# End of macro NEXTW
3683			.NEG: 
3683			 
3683				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3683 17				db WORD_SYS_CORE+3             
3684 c6 36			dw .DIV            
3686 02				db 1 + 1 
3687 .. 00			db "-",0              
3689				endm 
# End of macro CWHEAD
3689			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3689					if DEBUG_FORTH_WORDS_KEY 
3689						DMARK "SUB" 
3689 f5				push af  
368a 3a 9e 36			ld a, (.dmark)  
368d 32 71 ee			ld (debug_mark),a  
3690 3a 9f 36			ld a, (.dmark+1)  
3693 32 72 ee			ld (debug_mark+1),a  
3696 3a a0 36			ld a, (.dmark+2)  
3699 32 73 ee			ld (debug_mark+2),a  
369c 18 03			jr .pastdmark  
369e ..			.dmark: db "SUB"  
36a1 f1			.pastdmark: pop af  
36a2			endm  
# End of macro DMARK
36a2						CALLMONITOR 
36a2 cd ae 15			call break_point_state  
36a5				endm  
# End of macro CALLMONITOR
36a5					endif 
36a5			 
36a5			 
36a5				; TODO add floating point number detection 
36a5					; v5 FORTH_DSP_VALUE 
36a5					FORTH_DSP 
36a5 cd dc 1d			call macro_forth_dsp 
36a8				endm 
# End of macro FORTH_DSP
36a8 7e					ld a,(hl)	; get type of value on TOS 
36a9 fe 02				cp DS_TYPE_INUM  
36ab 28 03				jr z, .neg_inum 
36ad			 
36ad					NEXTW 
36ad c3 cc 1f			jp macro_next 
36b0				endm 
# End of macro NEXTW
36b0			 
36b0			; float maths 
36b0			 
36b0				if FORTH_ENABLE_FLOATMATH 
36b0					jr .neg_done 
36b0			 
36b0				endif 
36b0					 
36b0			 
36b0			.neg_inum: 
36b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b0 cd 16 1e			call macro_dsp_valuehl 
36b3				endm 
# End of macro FORTH_DSP_VALUEHL
36b3			 
36b3 e5					push hl 
36b4			 
36b4					; destroy value TOS 
36b4			 
36b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b4 cd ce 1e			call macro_forth_dsp_pop 
36b7				endm 
# End of macro FORTH_DSP_POP
36b7			 
36b7			 
36b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b7 cd 16 1e			call macro_dsp_valuehl 
36ba				endm 
# End of macro FORTH_DSP_VALUEHL
36ba			 
36ba					; one value on hl get other one back 
36ba			 
36ba d1					pop de 
36bb			 
36bb					; do the sub 
36bb			;		ex de, hl 
36bb			 
36bb ed 52				sbc hl,de 
36bd			 
36bd					; save it 
36bd			 
36bd			;		push hl	 
36bd			 
36bd					; 
36bd			 
36bd					; destroy value TOS 
36bd			 
36bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36bd cd ce 1e			call macro_forth_dsp_pop 
36c0				endm 
# End of macro FORTH_DSP_POP
36c0			 
36c0					; TODO push value back onto stack for another op etc 
36c0			 
36c0			;		pop hl 
36c0			 
36c0 cd 1f 1c				call forth_push_numhl 
36c3			.neg_done: 
36c3			 
36c3					NEXTW 
36c3 c3 cc 1f			jp macro_next 
36c6				endm 
# End of macro NEXTW
36c6			.DIV: 
36c6				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36c6 18				db WORD_SYS_CORE+4             
36c7 13 37			dw .MUL            
36c9 02				db 1 + 1 
36ca .. 00			db "/",0              
36cc				endm 
# End of macro CWHEAD
36cc			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36cc					if DEBUG_FORTH_WORDS_KEY 
36cc						DMARK "DIV" 
36cc f5				push af  
36cd 3a e1 36			ld a, (.dmark)  
36d0 32 71 ee			ld (debug_mark),a  
36d3 3a e2 36			ld a, (.dmark+1)  
36d6 32 72 ee			ld (debug_mark+1),a  
36d9 3a e3 36			ld a, (.dmark+2)  
36dc 32 73 ee			ld (debug_mark+2),a  
36df 18 03			jr .pastdmark  
36e1 ..			.dmark: db "DIV"  
36e4 f1			.pastdmark: pop af  
36e5			endm  
# End of macro DMARK
36e5						CALLMONITOR 
36e5 cd ae 15			call break_point_state  
36e8				endm  
# End of macro CALLMONITOR
36e8					endif 
36e8				; TODO add floating point number detection 
36e8					; v5 FORTH_DSP_VALUE 
36e8					FORTH_DSP 
36e8 cd dc 1d			call macro_forth_dsp 
36eb				endm 
# End of macro FORTH_DSP
36eb 7e					ld a,(hl)	; get type of value on TOS 
36ec fe 02				cp DS_TYPE_INUM  
36ee 28 03				jr z, .div_inum 
36f0			 
36f0				if FORTH_ENABLE_FLOATMATH 
36f0					jr .div_done 
36f0			 
36f0				endif 
36f0					NEXTW 
36f0 c3 cc 1f			jp macro_next 
36f3				endm 
# End of macro NEXTW
36f3			.div_inum: 
36f3			 
36f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f3 cd 16 1e			call macro_dsp_valuehl 
36f6				endm 
# End of macro FORTH_DSP_VALUEHL
36f6			 
36f6 e5					push hl    ; to go to bc 
36f7			 
36f7					; destroy value TOS 
36f7			 
36f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f7 cd ce 1e			call macro_forth_dsp_pop 
36fa				endm 
# End of macro FORTH_DSP_POP
36fa			 
36fa			 
36fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fa cd 16 1e			call macro_dsp_valuehl 
36fd				endm 
# End of macro FORTH_DSP_VALUEHL
36fd			 
36fd					; hl to go to de 
36fd			 
36fd e5					push hl 
36fe			 
36fe c1					pop bc 
36ff d1					pop de		 
3700			 
3700			 
3700					if DEBUG_FORTH_MATHS 
3700						DMARK "DIV" 
3700				CALLMONITOR 
3700					endif 
3700					; one value on hl but move to a get other one back 
3700			 
3700			        
3700 cd 0a 0d			call Div16 
3703			 
3703			;	push af	 
3703 e5				push hl 
3704 c5				push bc 
3705			 
3705					if DEBUG_FORTH_MATHS 
3705						DMARK "DI1" 
3705				CALLMONITOR 
3705					endif 
3705			 
3705					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3705 cd ce 1e			call macro_forth_dsp_pop 
3708				endm 
# End of macro FORTH_DSP_POP
3708			 
3708			 
3708			 
3708 e1					pop hl    ; result 
3709			 
3709 cd 1f 1c				call forth_push_numhl 
370c			 
370c e1					pop hl    ; reminder 
370d			;		ld h,0 
370d			;		ld l,d 
370d			 
370d cd 1f 1c				call forth_push_numhl 
3710			.div_done: 
3710					NEXTW 
3710 c3 cc 1f			jp macro_next 
3713				endm 
# End of macro NEXTW
3713			.MUL: 
3713				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3713 19				db WORD_SYS_CORE+5             
3714 58 37			dw .MIN            
3716 02				db 1 + 1 
3717 .. 00			db "*",0              
3719				endm 
# End of macro CWHEAD
3719			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3719				; TODO add floating point number detection 
3719					if DEBUG_FORTH_WORDS_KEY 
3719						DMARK "MUL" 
3719 f5				push af  
371a 3a 2e 37			ld a, (.dmark)  
371d 32 71 ee			ld (debug_mark),a  
3720 3a 2f 37			ld a, (.dmark+1)  
3723 32 72 ee			ld (debug_mark+1),a  
3726 3a 30 37			ld a, (.dmark+2)  
3729 32 73 ee			ld (debug_mark+2),a  
372c 18 03			jr .pastdmark  
372e ..			.dmark: db "MUL"  
3731 f1			.pastdmark: pop af  
3732			endm  
# End of macro DMARK
3732						CALLMONITOR 
3732 cd ae 15			call break_point_state  
3735				endm  
# End of macro CALLMONITOR
3735					endif 
3735					FORTH_DSP 
3735 cd dc 1d			call macro_forth_dsp 
3738				endm 
# End of macro FORTH_DSP
3738					; v5 FORTH_DSP_VALUE 
3738 7e					ld a,(hl)	; get type of value on TOS 
3739 fe 02				cp DS_TYPE_INUM  
373b 28 03				jr z, .mul_inum 
373d			 
373d				if FORTH_ENABLE_FLOATMATH 
373d					jr .mul_done 
373d			 
373d				endif 
373d			 
373d					NEXTW 
373d c3 cc 1f			jp macro_next 
3740				endm 
# End of macro NEXTW
3740			.mul_inum:	 
3740			 
3740					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3740 cd 16 1e			call macro_dsp_valuehl 
3743				endm 
# End of macro FORTH_DSP_VALUEHL
3743			 
3743 e5					push hl 
3744			 
3744					; destroy value TOS 
3744			 
3744					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3744 cd ce 1e			call macro_forth_dsp_pop 
3747				endm 
# End of macro FORTH_DSP_POP
3747			 
3747			 
3747					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3747 cd 16 1e			call macro_dsp_valuehl 
374a				endm 
# End of macro FORTH_DSP_VALUEHL
374a			 
374a					; one value on hl but move to a get other one back 
374a			 
374a 7d					ld a, l 
374b			 
374b d1					pop de 
374c			 
374c					; do the mull 
374c			;		ex de, hl 
374c			 
374c cd 30 0d				call Mult16 
374f					; save it 
374f			 
374f			;		push hl	 
374f			 
374f					; 
374f			 
374f					; destroy value TOS 
374f			 
374f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374f cd ce 1e			call macro_forth_dsp_pop 
3752				endm 
# End of macro FORTH_DSP_POP
3752			 
3752					; TODO push value back onto stack for another op etc 
3752			 
3752			;		pop hl 
3752			 
3752 cd 1f 1c				call forth_push_numhl 
3755			 
3755			.mul_done: 
3755					NEXTW 
3755 c3 cc 1f			jp macro_next 
3758				endm 
# End of macro NEXTW
3758			 
3758			 
3758			 
3758			 
3758			.MIN: 
3758				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3758 49				db WORD_SYS_CORE+53             
3759 d9 37			dw .MAX            
375b 04				db 3 + 1 
375c .. 00			db "MIN",0              
3760				endm 
# End of macro CWHEAD
3760			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3760					if DEBUG_FORTH_WORDS_KEY 
3760						DMARK "MIN" 
3760 f5				push af  
3761 3a 75 37			ld a, (.dmark)  
3764 32 71 ee			ld (debug_mark),a  
3767 3a 76 37			ld a, (.dmark+1)  
376a 32 72 ee			ld (debug_mark+1),a  
376d 3a 77 37			ld a, (.dmark+2)  
3770 32 73 ee			ld (debug_mark+2),a  
3773 18 03			jr .pastdmark  
3775 ..			.dmark: db "MIN"  
3778 f1			.pastdmark: pop af  
3779			endm  
# End of macro DMARK
3779						CALLMONITOR 
3779 cd ae 15			call break_point_state  
377c				endm  
# End of macro CALLMONITOR
377c					endif 
377c					; get u2 
377c			 
377c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377c cd 16 1e			call macro_dsp_valuehl 
377f				endm 
# End of macro FORTH_DSP_VALUEHL
377f			 
377f e5					push hl   ; u2 
3780			 
3780					; destroy value TOS 
3780			 
3780					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3780 cd ce 1e			call macro_forth_dsp_pop 
3783				endm 
# End of macro FORTH_DSP_POP
3783			 
3783					; get u1 
3783			 
3783					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3783 cd 16 1e			call macro_dsp_valuehl 
3786				endm 
# End of macro FORTH_DSP_VALUEHL
3786			 
3786 e5					push hl  ; u1 
3787			 
3787					; destroy value TOS 
3787			 
3787					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3787 cd ce 1e			call macro_forth_dsp_pop 
378a				endm 
# End of macro FORTH_DSP_POP
378a			 
378a b7			 or a      ;clear carry flag 
378b e1			  pop hl    ; u1 
378c d1			  pop de    ; u2 
378d e5				push hl   ; saved in case hl is lowest 
378e ed 52		  sbc hl,de 
3790 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3792			 
3792 e1				pop hl 
3793					if DEBUG_FORTH_WORDS 
3793						DMARK "MIN" 
3793 f5				push af  
3794 3a a8 37			ld a, (.dmark)  
3797 32 71 ee			ld (debug_mark),a  
379a 3a a9 37			ld a, (.dmark+1)  
379d 32 72 ee			ld (debug_mark+1),a  
37a0 3a aa 37			ld a, (.dmark+2)  
37a3 32 73 ee			ld (debug_mark+2),a  
37a6 18 03			jr .pastdmark  
37a8 ..			.dmark: db "MIN"  
37ab f1			.pastdmark: pop af  
37ac			endm  
# End of macro DMARK
37ac						CALLMONITOR 
37ac cd ae 15			call break_point_state  
37af				endm  
# End of macro CALLMONITOR
37af					endif 
37af cd 1f 1c				call forth_push_numhl 
37b2			 
37b2				       NEXTW 
37b2 c3 cc 1f			jp macro_next 
37b5				endm 
# End of macro NEXTW
37b5			 
37b5			.mincont:  
37b5 c1				pop bc   ; tidy up 
37b6 eb				ex de , hl  
37b7					if DEBUG_FORTH_WORDS 
37b7						DMARK "MI1" 
37b7 f5				push af  
37b8 3a cc 37			ld a, (.dmark)  
37bb 32 71 ee			ld (debug_mark),a  
37be 3a cd 37			ld a, (.dmark+1)  
37c1 32 72 ee			ld (debug_mark+1),a  
37c4 3a ce 37			ld a, (.dmark+2)  
37c7 32 73 ee			ld (debug_mark+2),a  
37ca 18 03			jr .pastdmark  
37cc ..			.dmark: db "MI1"  
37cf f1			.pastdmark: pop af  
37d0			endm  
# End of macro DMARK
37d0						CALLMONITOR 
37d0 cd ae 15			call break_point_state  
37d3				endm  
# End of macro CALLMONITOR
37d3					endif 
37d3 cd 1f 1c				call forth_push_numhl 
37d6			 
37d6				       NEXTW 
37d6 c3 cc 1f			jp macro_next 
37d9				endm 
# End of macro NEXTW
37d9			.MAX: 
37d9				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37d9 4a				db WORD_SYS_CORE+54             
37da 5a 38			dw .RND16            
37dc 04				db 3 + 1 
37dd .. 00			db "MAX",0              
37e1				endm 
# End of macro CWHEAD
37e1			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37e1					if DEBUG_FORTH_WORDS_KEY 
37e1						DMARK "MAX" 
37e1 f5				push af  
37e2 3a f6 37			ld a, (.dmark)  
37e5 32 71 ee			ld (debug_mark),a  
37e8 3a f7 37			ld a, (.dmark+1)  
37eb 32 72 ee			ld (debug_mark+1),a  
37ee 3a f8 37			ld a, (.dmark+2)  
37f1 32 73 ee			ld (debug_mark+2),a  
37f4 18 03			jr .pastdmark  
37f6 ..			.dmark: db "MAX"  
37f9 f1			.pastdmark: pop af  
37fa			endm  
# End of macro DMARK
37fa						CALLMONITOR 
37fa cd ae 15			call break_point_state  
37fd				endm  
# End of macro CALLMONITOR
37fd					endif 
37fd					; get u2 
37fd			 
37fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fd cd 16 1e			call macro_dsp_valuehl 
3800				endm 
# End of macro FORTH_DSP_VALUEHL
3800			 
3800 e5					push hl   ; u2 
3801			 
3801					; destroy value TOS 
3801			 
3801					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3801 cd ce 1e			call macro_forth_dsp_pop 
3804				endm 
# End of macro FORTH_DSP_POP
3804			 
3804					; get u1 
3804			 
3804					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3804 cd 16 1e			call macro_dsp_valuehl 
3807				endm 
# End of macro FORTH_DSP_VALUEHL
3807			 
3807 e5					push hl  ; u1 
3808			 
3808					; destroy value TOS 
3808			 
3808					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3808 cd ce 1e			call macro_forth_dsp_pop 
380b				endm 
# End of macro FORTH_DSP_POP
380b			 
380b b7			 or a      ;clear carry flag 
380c e1			  pop hl    ; u1 
380d d1			  pop de    ; u2 
380e e5				push hl   ; saved in case hl is lowest 
380f ed 52		  sbc hl,de 
3811 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3813			 
3813 e1				pop hl 
3814					if DEBUG_FORTH_WORDS 
3814						DMARK "MAX" 
3814 f5				push af  
3815 3a 29 38			ld a, (.dmark)  
3818 32 71 ee			ld (debug_mark),a  
381b 3a 2a 38			ld a, (.dmark+1)  
381e 32 72 ee			ld (debug_mark+1),a  
3821 3a 2b 38			ld a, (.dmark+2)  
3824 32 73 ee			ld (debug_mark+2),a  
3827 18 03			jr .pastdmark  
3829 ..			.dmark: db "MAX"  
382c f1			.pastdmark: pop af  
382d			endm  
# End of macro DMARK
382d						CALLMONITOR 
382d cd ae 15			call break_point_state  
3830				endm  
# End of macro CALLMONITOR
3830					endif 
3830 cd 1f 1c				call forth_push_numhl 
3833			 
3833				       NEXTW 
3833 c3 cc 1f			jp macro_next 
3836				endm 
# End of macro NEXTW
3836			 
3836			.maxcont:  
3836 c1				pop bc   ; tidy up 
3837 eb				ex de , hl  
3838					if DEBUG_FORTH_WORDS 
3838						DMARK "MA1" 
3838 f5				push af  
3839 3a 4d 38			ld a, (.dmark)  
383c 32 71 ee			ld (debug_mark),a  
383f 3a 4e 38			ld a, (.dmark+1)  
3842 32 72 ee			ld (debug_mark+1),a  
3845 3a 4f 38			ld a, (.dmark+2)  
3848 32 73 ee			ld (debug_mark+2),a  
384b 18 03			jr .pastdmark  
384d ..			.dmark: db "MA1"  
3850 f1			.pastdmark: pop af  
3851			endm  
# End of macro DMARK
3851						CALLMONITOR 
3851 cd ae 15			call break_point_state  
3854				endm  
# End of macro CALLMONITOR
3854					endif 
3854 cd 1f 1c				call forth_push_numhl 
3857				       NEXTW 
3857 c3 cc 1f			jp macro_next 
385a				endm 
# End of macro NEXTW
385a			 
385a			.RND16: 
385a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
385a 4e				db WORD_SYS_CORE+58             
385b 89 38			dw .RND8            
385d 06				db 5 + 1 
385e .. 00			db "RND16",0              
3864				endm 
# End of macro CWHEAD
3864			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3864					if DEBUG_FORTH_WORDS_KEY 
3864						DMARK "R16" 
3864 f5				push af  
3865 3a 79 38			ld a, (.dmark)  
3868 32 71 ee			ld (debug_mark),a  
386b 3a 7a 38			ld a, (.dmark+1)  
386e 32 72 ee			ld (debug_mark+1),a  
3871 3a 7b 38			ld a, (.dmark+2)  
3874 32 73 ee			ld (debug_mark+2),a  
3877 18 03			jr .pastdmark  
3879 ..			.dmark: db "R16"  
387c f1			.pastdmark: pop af  
387d			endm  
# End of macro DMARK
387d						CALLMONITOR 
387d cd ae 15			call break_point_state  
3880				endm  
# End of macro CALLMONITOR
3880					endif 
3880 cd d4 0c				call prng16  
3883 cd 1f 1c				call forth_push_numhl 
3886				       NEXTW 
3886 c3 cc 1f			jp macro_next 
3889				endm 
# End of macro NEXTW
3889			.RND8: 
3889				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3889 60				db WORD_SYS_CORE+76             
388a be 38			dw .RND            
388c 05				db 4 + 1 
388d .. 00			db "RND8",0              
3892				endm 
# End of macro CWHEAD
3892			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3892					if DEBUG_FORTH_WORDS_KEY 
3892						DMARK "RN8" 
3892 f5				push af  
3893 3a a7 38			ld a, (.dmark)  
3896 32 71 ee			ld (debug_mark),a  
3899 3a a8 38			ld a, (.dmark+1)  
389c 32 72 ee			ld (debug_mark+1),a  
389f 3a a9 38			ld a, (.dmark+2)  
38a2 32 73 ee			ld (debug_mark+2),a  
38a5 18 03			jr .pastdmark  
38a7 ..			.dmark: db "RN8"  
38aa f1			.pastdmark: pop af  
38ab			endm  
# End of macro DMARK
38ab						CALLMONITOR 
38ab cd ae 15			call break_point_state  
38ae				endm  
# End of macro CALLMONITOR
38ae					endif 
38ae 2a b2 eb				ld hl,(xrandc) 
38b1 23					inc hl 
38b2 cd ee 0c				call xrnd 
38b5 6f					ld l,a	 
38b6 26 00				ld h,0 
38b8 cd 1f 1c				call forth_push_numhl 
38bb				       NEXTW 
38bb c3 cc 1f			jp macro_next 
38be				endm 
# End of macro NEXTW
38be			.RND: 
38be				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38be 60				db WORD_SYS_CORE+76             
38bf c4 39			dw .ENDMATHS            
38c1 04				db 3 + 1 
38c2 .. 00			db "RND",0              
38c6				endm 
# End of macro CWHEAD
38c6			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38c6			 
38c6					if DEBUG_FORTH_WORDS_KEY 
38c6						DMARK "RND" 
38c6 f5				push af  
38c7 3a db 38			ld a, (.dmark)  
38ca 32 71 ee			ld (debug_mark),a  
38cd 3a dc 38			ld a, (.dmark+1)  
38d0 32 72 ee			ld (debug_mark+1),a  
38d3 3a dd 38			ld a, (.dmark+2)  
38d6 32 73 ee			ld (debug_mark+2),a  
38d9 18 03			jr .pastdmark  
38db ..			.dmark: db "RND"  
38de f1			.pastdmark: pop af  
38df			endm  
# End of macro DMARK
38df						CALLMONITOR 
38df cd ae 15			call break_point_state  
38e2				endm  
# End of macro CALLMONITOR
38e2					endif 
38e2					 
38e2					FORTH_DSP_VALUEHL    ; upper range 
38e2 cd 16 1e			call macro_dsp_valuehl 
38e5				endm 
# End of macro FORTH_DSP_VALUEHL
38e5			 
38e5 22 b6 eb				ld (LFSRSeed), hl	 
38e8			 
38e8					if DEBUG_FORTH_WORDS 
38e8						DMARK "RN1" 
38e8 f5				push af  
38e9 3a fd 38			ld a, (.dmark)  
38ec 32 71 ee			ld (debug_mark),a  
38ef 3a fe 38			ld a, (.dmark+1)  
38f2 32 72 ee			ld (debug_mark+1),a  
38f5 3a ff 38			ld a, (.dmark+2)  
38f8 32 73 ee			ld (debug_mark+2),a  
38fb 18 03			jr .pastdmark  
38fd ..			.dmark: db "RN1"  
3900 f1			.pastdmark: pop af  
3901			endm  
# End of macro DMARK
3901						CALLMONITOR 
3901 cd ae 15			call break_point_state  
3904				endm  
# End of macro CALLMONITOR
3904					endif 
3904					FORTH_DSP_POP 
3904 cd ce 1e			call macro_forth_dsp_pop 
3907				endm 
# End of macro FORTH_DSP_POP
3907			 
3907					FORTH_DSP_VALUEHL    ; low range 
3907 cd 16 1e			call macro_dsp_valuehl 
390a				endm 
# End of macro FORTH_DSP_VALUEHL
390a			 
390a					if DEBUG_FORTH_WORDS 
390a						DMARK "RN2" 
390a f5				push af  
390b 3a 1f 39			ld a, (.dmark)  
390e 32 71 ee			ld (debug_mark),a  
3911 3a 20 39			ld a, (.dmark+1)  
3914 32 72 ee			ld (debug_mark+1),a  
3917 3a 21 39			ld a, (.dmark+2)  
391a 32 73 ee			ld (debug_mark+2),a  
391d 18 03			jr .pastdmark  
391f ..			.dmark: db "RN2"  
3922 f1			.pastdmark: pop af  
3923			endm  
# End of macro DMARK
3923						CALLMONITOR 
3923 cd ae 15			call break_point_state  
3926				endm  
# End of macro CALLMONITOR
3926					endif 
3926 22 b8 eb				ld (LFSRSeed+2), hl 
3929			 
3929					FORTH_DSP_POP 
3929 cd ce 1e			call macro_forth_dsp_pop 
392c				endm 
# End of macro FORTH_DSP_POP
392c			 
392c e5					push hl 
392d			 
392d e1			.inrange:	pop hl 
392e cd d4 0c				call prng16  
3931					if DEBUG_FORTH_WORDS 
3931						DMARK "RN3" 
3931 f5				push af  
3932 3a 46 39			ld a, (.dmark)  
3935 32 71 ee			ld (debug_mark),a  
3938 3a 47 39			ld a, (.dmark+1)  
393b 32 72 ee			ld (debug_mark+1),a  
393e 3a 48 39			ld a, (.dmark+2)  
3941 32 73 ee			ld (debug_mark+2),a  
3944 18 03			jr .pastdmark  
3946 ..			.dmark: db "RN3"  
3949 f1			.pastdmark: pop af  
394a			endm  
# End of macro DMARK
394a						CALLMONITOR 
394a cd ae 15			call break_point_state  
394d				endm  
# End of macro CALLMONITOR
394d					endif 
394d					 
394d					; if the range is 8bit knock out the high byte 
394d			 
394d ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
3951			 
3951 3e 00				ld a, 0 
3953 ba					cp d  
3954 20 1e				jr nz, .hirange 
3956 26 00				ld h, 0   ; knock it down to 8bit 
3958			 
3958					if DEBUG_FORTH_WORDS 
3958						DMARK "RNk" 
3958 f5				push af  
3959 3a 6d 39			ld a, (.dmark)  
395c 32 71 ee			ld (debug_mark),a  
395f 3a 6e 39			ld a, (.dmark+1)  
3962 32 72 ee			ld (debug_mark+1),a  
3965 3a 6f 39			ld a, (.dmark+2)  
3968 32 73 ee			ld (debug_mark+2),a  
396b 18 03			jr .pastdmark  
396d ..			.dmark: db "RNk"  
3970 f1			.pastdmark: pop af  
3971			endm  
# End of macro DMARK
3971						CALLMONITOR 
3971 cd ae 15			call break_point_state  
3974				endm  
# End of macro CALLMONITOR
3974					endif 
3974			.hirange:   
3974 e5					push hl  
3975 b7					or a  
3976 ed 52		                sbc hl, de 
3978			 
3978					;call cmp16 
3978			 
3978 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
397a e1					pop hl 
397b e5					push hl 
397c			 
397c					if DEBUG_FORTH_WORDS 
397c						DMARK "RN4" 
397c f5				push af  
397d 3a 91 39			ld a, (.dmark)  
3980 32 71 ee			ld (debug_mark),a  
3983 3a 92 39			ld a, (.dmark+1)  
3986 32 72 ee			ld (debug_mark+1),a  
3989 3a 93 39			ld a, (.dmark+2)  
398c 32 73 ee			ld (debug_mark+2),a  
398f 18 03			jr .pastdmark  
3991 ..			.dmark: db "RN4"  
3994 f1			.pastdmark: pop af  
3995			endm  
# End of macro DMARK
3995						CALLMONITOR 
3995 cd ae 15			call break_point_state  
3998				endm  
# End of macro CALLMONITOR
3998					endif 
3998 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
399c					;call cmp16 
399c				 
399c b7					or a  
399d ed 52		                sbc hl, de 
399f 38 8c				jr c, .inrange 
39a1			 
39a1 e1					pop hl 
39a2					 
39a2					if DEBUG_FORTH_WORDS 
39a2						DMARK "RNd" 
39a2 f5				push af  
39a3 3a b7 39			ld a, (.dmark)  
39a6 32 71 ee			ld (debug_mark),a  
39a9 3a b8 39			ld a, (.dmark+1)  
39ac 32 72 ee			ld (debug_mark+1),a  
39af 3a b9 39			ld a, (.dmark+2)  
39b2 32 73 ee			ld (debug_mark+2),a  
39b5 18 03			jr .pastdmark  
39b7 ..			.dmark: db "RNd"  
39ba f1			.pastdmark: pop af  
39bb			endm  
# End of macro DMARK
39bb						CALLMONITOR 
39bb cd ae 15			call break_point_state  
39be				endm  
# End of macro CALLMONITOR
39be					endif 
39be			 
39be			 
39be cd 1f 1c				call forth_push_numhl 
39c1				       NEXTW 
39c1 c3 cc 1f			jp macro_next 
39c4				endm 
# End of macro NEXTW
39c4			 
39c4			.ENDMATHS: 
39c4			 
39c4			; eof 
39c4			 
# End of file forth_words_maths.asm
39c4			include "forth_words_display.asm" 
39c4			 
39c4			; | ## Display Words 
39c4			 
39c4			.INFO: 
39c4			 
39c4				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
39c4 62				db WORD_SYS_CORE+78             
39c5 e1 39			dw .ATP            
39c7 05				db 4 + 1 
39c8 .. 00			db "INFO",0              
39cd				endm 
# End of macro CWHEAD
39cd			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
39cd					FORTH_DSP_VALUEHL 
39cd cd 16 1e			call macro_dsp_valuehl 
39d0				endm 
# End of macro FORTH_DSP_VALUEHL
39d0			 
39d0					FORTH_DSP_POP 
39d0 cd ce 1e			call macro_forth_dsp_pop 
39d3				endm 
# End of macro FORTH_DSP_POP
39d3			 
39d3 e5					push hl 
39d4			 
39d4					FORTH_DSP_VALUEHL 
39d4 cd 16 1e			call macro_dsp_valuehl 
39d7				endm 
# End of macro FORTH_DSP_VALUEHL
39d7			 
39d7					FORTH_DSP_POP 
39d7 cd ce 1e			call macro_forth_dsp_pop 
39da				endm 
# End of macro FORTH_DSP_POP
39da			 
39da d1					pop de 
39db			 
39db cd 11 0b				call info_panel 
39de			 
39de			 
39de					NEXTW 
39de c3 cc 1f			jp macro_next 
39e1				endm 
# End of macro NEXTW
39e1			.ATP: 
39e1				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
39e1 62				db WORD_SYS_CORE+78             
39e2 58 3a			dw .FB            
39e4 04				db 3 + 1 
39e5 .. 00			db "AT?",0              
39e9				endm 
# End of macro CWHEAD
39e9			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
39e9					if DEBUG_FORTH_WORDS_KEY 
39e9						DMARK "AT?" 
39e9 f5				push af  
39ea 3a fe 39			ld a, (.dmark)  
39ed 32 71 ee			ld (debug_mark),a  
39f0 3a ff 39			ld a, (.dmark+1)  
39f3 32 72 ee			ld (debug_mark+1),a  
39f6 3a 00 3a			ld a, (.dmark+2)  
39f9 32 73 ee			ld (debug_mark+2),a  
39fc 18 03			jr .pastdmark  
39fe ..			.dmark: db "AT?"  
3a01 f1			.pastdmark: pop af  
3a02			endm  
# End of macro DMARK
3a02						CALLMONITOR 
3a02 cd ae 15			call break_point_state  
3a05				endm  
# End of macro CALLMONITOR
3a05					endif 
3a05 3a 68 ea				ld a, (f_cursor_ptr) 
3a08			 
3a08			if DEBUG_FORTH_WORDS 
3a08				DMARK "AT?" 
3a08 f5				push af  
3a09 3a 1d 3a			ld a, (.dmark)  
3a0c 32 71 ee			ld (debug_mark),a  
3a0f 3a 1e 3a			ld a, (.dmark+1)  
3a12 32 72 ee			ld (debug_mark+1),a  
3a15 3a 1f 3a			ld a, (.dmark+2)  
3a18 32 73 ee			ld (debug_mark+2),a  
3a1b 18 03			jr .pastdmark  
3a1d ..			.dmark: db "AT?"  
3a20 f1			.pastdmark: pop af  
3a21			endm  
# End of macro DMARK
3a21				CALLMONITOR 
3a21 cd ae 15			call break_point_state  
3a24				endm  
# End of macro CALLMONITOR
3a24			endif	 
3a24					; count the number of rows 
3a24			 
3a24 06 00				ld b, 0 
3a26 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a27 d6 28				sub display_cols 
3a29 f2 2f 3a				jp p, .atprunder 
3a2c 04					inc b 
3a2d 18 f7				jr .atpr 
3a2f			.atprunder:	 
3a2f			if DEBUG_FORTH_WORDS 
3a2f				DMARK "A?2" 
3a2f f5				push af  
3a30 3a 44 3a			ld a, (.dmark)  
3a33 32 71 ee			ld (debug_mark),a  
3a36 3a 45 3a			ld a, (.dmark+1)  
3a39 32 72 ee			ld (debug_mark+1),a  
3a3c 3a 46 3a			ld a, (.dmark+2)  
3a3f 32 73 ee			ld (debug_mark+2),a  
3a42 18 03			jr .pastdmark  
3a44 ..			.dmark: db "A?2"  
3a47 f1			.pastdmark: pop af  
3a48			endm  
# End of macro DMARK
3a48				CALLMONITOR 
3a48 cd ae 15			call break_point_state  
3a4b				endm  
# End of macro CALLMONITOR
3a4b			endif	 
3a4b 26 00				ld h, 0 
3a4d 69					ld l, c 
3a4e cd 1f 1c				call forth_push_numhl 
3a51 68					ld l, b  
3a52 cd 1f 1c				call forth_push_numhl 
3a55			 
3a55			 
3a55				NEXTW 
3a55 c3 cc 1f			jp macro_next 
3a58				endm 
# End of macro NEXTW
3a58			 
3a58			.FB: 
3a58				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a58 1b				db WORD_SYS_CORE+7             
3a59 a6 3a			dw .EMIT            
3a5b 03				db 2 + 1 
3a5c .. 00			db "FB",0              
3a5f				endm 
# End of macro CWHEAD
3a5f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a5f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a5f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a5f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a5f					if DEBUG_FORTH_WORDS_KEY 
3a5f						DMARK "FB." 
3a5f f5				push af  
3a60 3a 74 3a			ld a, (.dmark)  
3a63 32 71 ee			ld (debug_mark),a  
3a66 3a 75 3a			ld a, (.dmark+1)  
3a69 32 72 ee			ld (debug_mark+1),a  
3a6c 3a 76 3a			ld a, (.dmark+2)  
3a6f 32 73 ee			ld (debug_mark+2),a  
3a72 18 03			jr .pastdmark  
3a74 ..			.dmark: db "FB."  
3a77 f1			.pastdmark: pop af  
3a78			endm  
# End of macro DMARK
3a78						CALLMONITOR 
3a78 cd ae 15			call break_point_state  
3a7b				endm  
# End of macro CALLMONITOR
3a7b					endif 
3a7b			 
3a7b					FORTH_DSP_VALUEHL 
3a7b cd 16 1e			call macro_dsp_valuehl 
3a7e				endm 
# End of macro FORTH_DSP_VALUEHL
3a7e			 
3a7e 7d					ld a, l 
3a7f fe 01				cp 1 
3a81 20 05				jr nz, .fbn1 
3a83 21 16 ed				ld hl, display_fb1 
3a86 18 15				jr .fbset 
3a88 fe 02		.fbn1:		cp 2 
3a8a 20 05				jr nz, .fbn2 
3a8c 21 d4 eb				ld hl, display_fb2 
3a8f 18 0c				jr .fbset 
3a91 fe 03		.fbn2:		cp 3 
3a93 20 05				jr nz, .fbn3 
3a95 21 75 ec				ld hl, display_fb3 
3a98 18 03				jr .fbset 
3a9a			.fbn3:		 ; if invalid number select first 
3a9a 21 16 ed				ld hl, display_fb1 
3a9d 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3aa0			 
3aa0					FORTH_DSP_POP 
3aa0 cd ce 1e			call macro_forth_dsp_pop 
3aa3				endm 
# End of macro FORTH_DSP_POP
3aa3			 
3aa3					NEXTW 
3aa3 c3 cc 1f			jp macro_next 
3aa6				endm 
# End of macro NEXTW
3aa6			 
3aa6			 
3aa6			.EMIT: 
3aa6				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3aa6 1b				db WORD_SYS_CORE+7             
3aa7 f7 3a			dw .DOTH            
3aa9 05				db 4 + 1 
3aaa .. 00			db "EMIT",0              
3aaf				endm 
# End of macro CWHEAD
3aaf			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3aaf					; get value off TOS and display it 
3aaf			 
3aaf					if DEBUG_FORTH_WORDS_KEY 
3aaf						DMARK "EMT" 
3aaf f5				push af  
3ab0 3a c4 3a			ld a, (.dmark)  
3ab3 32 71 ee			ld (debug_mark),a  
3ab6 3a c5 3a			ld a, (.dmark+1)  
3ab9 32 72 ee			ld (debug_mark+1),a  
3abc 3a c6 3a			ld a, (.dmark+2)  
3abf 32 73 ee			ld (debug_mark+2),a  
3ac2 18 03			jr .pastdmark  
3ac4 ..			.dmark: db "EMT"  
3ac7 f1			.pastdmark: pop af  
3ac8			endm  
# End of macro DMARK
3ac8						CALLMONITOR 
3ac8 cd ae 15			call break_point_state  
3acb				endm  
# End of macro CALLMONITOR
3acb					endif 
3acb			 
3acb					FORTH_DSP_VALUEHL 
3acb cd 16 1e			call macro_dsp_valuehl 
3ace				endm 
# End of macro FORTH_DSP_VALUEHL
3ace			 
3ace 7d					ld a,l 
3acf			 
3acf					; TODO write to display 
3acf			 
3acf 32 c9 e4				ld (os_input), a 
3ad2 3e 00				ld a, 0 
3ad4 32 ca e4				ld (os_input+1), a 
3ad7					 
3ad7 3a 68 ea				ld a, (f_cursor_ptr) 
3ada 11 c9 e4				ld de, os_input 
3add cd 93 0b				call str_at_display 
3ae0			 
3ae0			 
3ae0 3a 46 ea				ld a,(cli_autodisplay) 
3ae3 fe 00				cp 0 
3ae5 28 03				jr z, .enoupdate 
3ae7 cd a3 0b						call update_display 
3aea					.enoupdate: 
3aea			 
3aea 3a 68 ea				ld a, (f_cursor_ptr) 
3aed 3c					inc a 
3aee 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
3af1			 
3af1			 
3af1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af1 cd ce 1e			call macro_forth_dsp_pop 
3af4				endm 
# End of macro FORTH_DSP_POP
3af4			  
3af4			 
3af4					NEXTW 
3af4 c3 cc 1f			jp macro_next 
3af7				endm 
# End of macro NEXTW
3af7			.DOTH: 
3af7				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3af7 1c				db WORD_SYS_CORE+8             
3af8 27 3b			dw .DOTF            
3afa 03				db 2 + 1 
3afb .. 00			db ".-",0              
3afe				endm 
# End of macro CWHEAD
3afe			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3afe					; get value off TOS and display it 
3afe					if DEBUG_FORTH_WORDS_KEY 
3afe						DMARK "DTD" 
3afe f5				push af  
3aff 3a 13 3b			ld a, (.dmark)  
3b02 32 71 ee			ld (debug_mark),a  
3b05 3a 14 3b			ld a, (.dmark+1)  
3b08 32 72 ee			ld (debug_mark+1),a  
3b0b 3a 15 3b			ld a, (.dmark+2)  
3b0e 32 73 ee			ld (debug_mark+2),a  
3b11 18 03			jr .pastdmark  
3b13 ..			.dmark: db "DTD"  
3b16 f1			.pastdmark: pop af  
3b17			endm  
# End of macro DMARK
3b17						CALLMONITOR 
3b17 cd ae 15			call break_point_state  
3b1a				endm  
# End of macro CALLMONITOR
3b1a					endif 
3b1a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b1c 3e 00			ld a, 0 
3b1e 32 47 ea			ld (cli_mvdot), a 
3b21 c3 7e 3b			jp .dotgo 
3b24				NEXTW 
3b24 c3 cc 1f			jp macro_next 
3b27				endm 
# End of macro NEXTW
3b27			.DOTF: 
3b27				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b27 1c				db WORD_SYS_CORE+8             
3b28 55 3b			dw .DOT            
3b2a 03				db 2 + 1 
3b2b .. 00			db ".>",0              
3b2e				endm 
# End of macro CWHEAD
3b2e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b2e					; get value off TOS and display it 
3b2e			        ; TODO BUG adds extra spaces 
3b2e			        ; TODO BUG handle numerics? 
3b2e					if DEBUG_FORTH_WORDS_KEY 
3b2e						DMARK "DTC" 
3b2e f5				push af  
3b2f 3a 43 3b			ld a, (.dmark)  
3b32 32 71 ee			ld (debug_mark),a  
3b35 3a 44 3b			ld a, (.dmark+1)  
3b38 32 72 ee			ld (debug_mark+1),a  
3b3b 3a 45 3b			ld a, (.dmark+2)  
3b3e 32 73 ee			ld (debug_mark+2),a  
3b41 18 03			jr .pastdmark  
3b43 ..			.dmark: db "DTC"  
3b46 f1			.pastdmark: pop af  
3b47			endm  
# End of macro DMARK
3b47						CALLMONITOR 
3b47 cd ae 15			call break_point_state  
3b4a				endm  
# End of macro CALLMONITOR
3b4a					endif 
3b4a 3e 01			ld a, 1 
3b4c 32 47 ea			ld (cli_mvdot), a 
3b4f c3 7e 3b			jp .dotgo 
3b52				NEXTW 
3b52 c3 cc 1f			jp macro_next 
3b55				endm 
# End of macro NEXTW
3b55			 
3b55			.DOT: 
3b55				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b55 1c				db WORD_SYS_CORE+8             
3b56 31 3d			dw .CLS            
3b58 02				db 1 + 1 
3b59 .. 00			db ".",0              
3b5b				endm 
# End of macro CWHEAD
3b5b			        ; | . ( u -- ) Display TOS | DONE 
3b5b					; get value off TOS and display it 
3b5b			 
3b5b					if DEBUG_FORTH_WORDS_KEY 
3b5b						DMARK "DOT" 
3b5b f5				push af  
3b5c 3a 70 3b			ld a, (.dmark)  
3b5f 32 71 ee			ld (debug_mark),a  
3b62 3a 71 3b			ld a, (.dmark+1)  
3b65 32 72 ee			ld (debug_mark+1),a  
3b68 3a 72 3b			ld a, (.dmark+2)  
3b6b 32 73 ee			ld (debug_mark+2),a  
3b6e 18 03			jr .pastdmark  
3b70 ..			.dmark: db "DOT"  
3b73 f1			.pastdmark: pop af  
3b74			endm  
# End of macro DMARK
3b74						CALLMONITOR 
3b74 cd ae 15			call break_point_state  
3b77				endm  
# End of macro CALLMONITOR
3b77					endif 
3b77 3e 00			ld a, 0 
3b79 32 47 ea			ld (cli_mvdot), a 
3b7c 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b7e				 
3b7e			 
3b7e			.dotgo: 
3b7e			 
3b7e			; move up type to on stack for parserv5 
3b7e					FORTH_DSP 
3b7e cd dc 1d			call macro_forth_dsp 
3b81				endm 
# End of macro FORTH_DSP
3b81				;FORTH_DSP_VALUE  
3b81			 
3b81			if DEBUG_FORTH_DOT 
3b81				DMARK "DOT" 
3b81 f5				push af  
3b82 3a 96 3b			ld a, (.dmark)  
3b85 32 71 ee			ld (debug_mark),a  
3b88 3a 97 3b			ld a, (.dmark+1)  
3b8b 32 72 ee			ld (debug_mark+1),a  
3b8e 3a 98 3b			ld a, (.dmark+2)  
3b91 32 73 ee			ld (debug_mark+2),a  
3b94 18 03			jr .pastdmark  
3b96 ..			.dmark: db "DOT"  
3b99 f1			.pastdmark: pop af  
3b9a			endm  
# End of macro DMARK
3b9a				CALLMONITOR 
3b9a cd ae 15			call break_point_state  
3b9d				endm  
# End of macro CALLMONITOR
3b9d			endif	 
3b9d			;		.print: 
3b9d			 
3b9d 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b9e 23				inc hl   ; position to the actual value 
3b9f fe 01			cp DS_TYPE_STR 
3ba1 20 06			jr nz, .dotnum1  
3ba3			 
3ba3			; display string 
3ba3				FORTH_DSP_VALUE  
3ba3 cd ff 1d			call macro_forth_dsp_value 
3ba6				endm 
# End of macro FORTH_DSP_VALUE
3ba6 eb				ex de,hl 
3ba7 18 49			jr .dotwrite 
3ba9			 
3ba9			.dotnum1: 
3ba9 fe 02			cp DS_TYPE_INUM 
3bab 20 44			jr nz, .dotflot 
3bad			 
3bad			 
3bad			; display number 
3bad			 
3bad			;	push hl 
3bad			;	call clear_display 
3bad			;	pop hl 
3bad			 
3bad 5e				ld e, (hl) 
3bae 23				inc hl 
3baf 56				ld d, (hl) 
3bb0 21 cb e2			ld hl, scratch 
3bb3			if DEBUG_FORTH_DOT 
3bb3				DMARK "DT1" 
3bb3 f5				push af  
3bb4 3a c8 3b			ld a, (.dmark)  
3bb7 32 71 ee			ld (debug_mark),a  
3bba 3a c9 3b			ld a, (.dmark+1)  
3bbd 32 72 ee			ld (debug_mark+1),a  
3bc0 3a ca 3b			ld a, (.dmark+2)  
3bc3 32 73 ee			ld (debug_mark+2),a  
3bc6 18 03			jr .pastdmark  
3bc8 ..			.dmark: db "DT1"  
3bcb f1			.pastdmark: pop af  
3bcc			endm  
# End of macro DMARK
3bcc				CALLMONITOR 
3bcc cd ae 15			call break_point_state  
3bcf				endm  
# End of macro CALLMONITOR
3bcf			endif	 
3bcf			 
3bcf cd ba 11			call uitoa_16 
3bd2 eb				ex de,hl 
3bd3			 
3bd3			if DEBUG_FORTH_DOT 
3bd3				DMARK "DT2" 
3bd3 f5				push af  
3bd4 3a e8 3b			ld a, (.dmark)  
3bd7 32 71 ee			ld (debug_mark),a  
3bda 3a e9 3b			ld a, (.dmark+1)  
3bdd 32 72 ee			ld (debug_mark+1),a  
3be0 3a ea 3b			ld a, (.dmark+2)  
3be3 32 73 ee			ld (debug_mark+2),a  
3be6 18 03			jr .pastdmark  
3be8 ..			.dmark: db "DT2"  
3beb f1			.pastdmark: pop af  
3bec			endm  
# End of macro DMARK
3bec				CALLMONITOR 
3bec cd ae 15			call break_point_state  
3bef				endm  
# End of macro CALLMONITOR
3bef			endif	 
3bef			 
3bef			;	ld de, os_word_scratch 
3bef 18 01			jr .dotwrite 
3bf1			 
3bf1 00			.dotflot:   nop 
3bf2			; TODO print floating point number 
3bf2			 
3bf2			.dotwrite:		 
3bf2			 
3bf2					; if c is set then set all '-' to spaces 
3bf2					; need to also take into account .>  
3bf2			 
3bf2 3e 01				ld a, 1 
3bf4 b9					cp c 
3bf5 20 67				jr nz, .nodashswap 
3bf7			 
3bf7					; DE has the string to write, working with HL 
3bf7			 
3bf7 06 ff				ld b, 255 
3bf9 d5					push de 
3bfa e1					pop hl 
3bfb			 
3bfb			if DEBUG_FORTH_DOT 
3bfb				DMARK "DT-" 
3bfb f5				push af  
3bfc 3a 10 3c			ld a, (.dmark)  
3bff 32 71 ee			ld (debug_mark),a  
3c02 3a 11 3c			ld a, (.dmark+1)  
3c05 32 72 ee			ld (debug_mark+1),a  
3c08 3a 12 3c			ld a, (.dmark+2)  
3c0b 32 73 ee			ld (debug_mark+2),a  
3c0e 18 03			jr .pastdmark  
3c10 ..			.dmark: db "DT-"  
3c13 f1			.pastdmark: pop af  
3c14			endm  
# End of macro DMARK
3c14				CALLMONITOR 
3c14 cd ae 15			call break_point_state  
3c17				endm  
# End of macro CALLMONITOR
3c17			endif	 
3c17 7e			.dashscan:	ld a, (hl) 
3c18 fe 00				cp 0 
3c1a 28 42				jr z, .nodashswap 
3c1c fe 2d				cp '-' 
3c1e 20 03				jr nz, .dashskip 
3c20 3e 20				ld a, ' ' 
3c22 77					ld (hl), a 
3c23 23			.dashskip:	inc hl 
3c24			if DEBUG_FORTH_DOT 
3c24				DMARK "D-2" 
3c24 f5				push af  
3c25 3a 39 3c			ld a, (.dmark)  
3c28 32 71 ee			ld (debug_mark),a  
3c2b 3a 3a 3c			ld a, (.dmark+1)  
3c2e 32 72 ee			ld (debug_mark+1),a  
3c31 3a 3b 3c			ld a, (.dmark+2)  
3c34 32 73 ee			ld (debug_mark+2),a  
3c37 18 03			jr .pastdmark  
3c39 ..			.dmark: db "D-2"  
3c3c f1			.pastdmark: pop af  
3c3d			endm  
# End of macro DMARK
3c3d				CALLMONITOR 
3c3d cd ae 15			call break_point_state  
3c40				endm  
# End of macro CALLMONITOR
3c40			endif	 
3c40 10 d5				djnz .dashscan 
3c42			 
3c42			if DEBUG_FORTH_DOT 
3c42				DMARK "D-1" 
3c42 f5				push af  
3c43 3a 57 3c			ld a, (.dmark)  
3c46 32 71 ee			ld (debug_mark),a  
3c49 3a 58 3c			ld a, (.dmark+1)  
3c4c 32 72 ee			ld (debug_mark+1),a  
3c4f 3a 59 3c			ld a, (.dmark+2)  
3c52 32 73 ee			ld (debug_mark+2),a  
3c55 18 03			jr .pastdmark  
3c57 ..			.dmark: db "D-1"  
3c5a f1			.pastdmark: pop af  
3c5b			endm  
# End of macro DMARK
3c5b				CALLMONITOR 
3c5b cd ae 15			call break_point_state  
3c5e				endm  
# End of macro CALLMONITOR
3c5e			endif	 
3c5e			 
3c5e			.nodashswap: 
3c5e			 
3c5e			if DEBUG_FORTH_DOT 
3c5e				DMARK "D-o" 
3c5e f5				push af  
3c5f 3a 73 3c			ld a, (.dmark)  
3c62 32 71 ee			ld (debug_mark),a  
3c65 3a 74 3c			ld a, (.dmark+1)  
3c68 32 72 ee			ld (debug_mark+1),a  
3c6b 3a 75 3c			ld a, (.dmark+2)  
3c6e 32 73 ee			ld (debug_mark+2),a  
3c71 18 03			jr .pastdmark  
3c73 ..			.dmark: db "D-o"  
3c76 f1			.pastdmark: pop af  
3c77			endm  
# End of macro DMARK
3c77				CALLMONITOR 
3c77 cd ae 15			call break_point_state  
3c7a				endm  
# End of macro CALLMONITOR
3c7a			endif	 
3c7a			 
3c7a d5					push de   ; save string start in case we need to advance print 
3c7b			 
3c7b 3a 68 ea				ld a, (f_cursor_ptr) 
3c7e cd 93 0b				call str_at_display 
3c81 3a 46 ea				ld a,(cli_autodisplay) 
3c84 fe 00				cp 0 
3c86 28 03				jr z, .noupdate 
3c88 cd a3 0b						call update_display 
3c8b					.noupdate: 
3c8b			 
3c8b			 
3c8b					; see if we need to advance the print position 
3c8b			 
3c8b e1					pop hl   ; get back string 
3c8c			;		ex de,hl 
3c8c			 
3c8c 3a 47 ea				ld a, (cli_mvdot) 
3c8f			if DEBUG_FORTH_DOT 
3c8f			;		ld e,a 
3c8f				DMARK "D>1" 
3c8f f5				push af  
3c90 3a a4 3c			ld a, (.dmark)  
3c93 32 71 ee			ld (debug_mark),a  
3c96 3a a5 3c			ld a, (.dmark+1)  
3c99 32 72 ee			ld (debug_mark+1),a  
3c9c 3a a6 3c			ld a, (.dmark+2)  
3c9f 32 73 ee			ld (debug_mark+2),a  
3ca2 18 03			jr .pastdmark  
3ca4 ..			.dmark: db "D>1"  
3ca7 f1			.pastdmark: pop af  
3ca8			endm  
# End of macro DMARK
3ca8				CALLMONITOR 
3ca8 cd ae 15			call break_point_state  
3cab				endm  
# End of macro CALLMONITOR
3cab			endif	 
3cab fe 00				cp 0 
3cad 28 44				jr z, .noadv 
3caf					; yes, lets advance the print position 
3caf 3e 00				ld a, 0 
3cb1 cd 16 12				call strlent 
3cb4			if DEBUG_FORTH_DOT 
3cb4				DMARK "D-?" 
3cb4 f5				push af  
3cb5 3a c9 3c			ld a, (.dmark)  
3cb8 32 71 ee			ld (debug_mark),a  
3cbb 3a ca 3c			ld a, (.dmark+1)  
3cbe 32 72 ee			ld (debug_mark+1),a  
3cc1 3a cb 3c			ld a, (.dmark+2)  
3cc4 32 73 ee			ld (debug_mark+2),a  
3cc7 18 03			jr .pastdmark  
3cc9 ..			.dmark: db "D-?"  
3ccc f1			.pastdmark: pop af  
3ccd			endm  
# End of macro DMARK
3ccd				CALLMONITOR 
3ccd cd ae 15			call break_point_state  
3cd0				endm  
# End of macro CALLMONITOR
3cd0			endif	 
3cd0 3a 68 ea				ld a, (f_cursor_ptr) 
3cd3 85					add a,l 
3cd4					;call addatohl 
3cd4					;ld a, l 
3cd4 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
3cd7			 
3cd7			if DEBUG_FORTH_DOT 
3cd7				DMARK "D->" 
3cd7 f5				push af  
3cd8 3a ec 3c			ld a, (.dmark)  
3cdb 32 71 ee			ld (debug_mark),a  
3cde 3a ed 3c			ld a, (.dmark+1)  
3ce1 32 72 ee			ld (debug_mark+1),a  
3ce4 3a ee 3c			ld a, (.dmark+2)  
3ce7 32 73 ee			ld (debug_mark+2),a  
3cea 18 03			jr .pastdmark  
3cec ..			.dmark: db "D->"  
3cef f1			.pastdmark: pop af  
3cf0			endm  
# End of macro DMARK
3cf0				CALLMONITOR 
3cf0 cd ae 15			call break_point_state  
3cf3				endm  
# End of macro CALLMONITOR
3cf3			endif	 
3cf3			 
3cf3			.noadv:	 
3cf3			 
3cf3					if DEBUG_FORTH_DOT_WAIT 
3cf3							call next_page_prompt 
3cf3					endif	 
3cf3			; TODO this pop off the stack causes a crash. i dont know why 
3cf3			 
3cf3			 
3cf3			if DEBUG_FORTH_DOT 
3cf3				DMARK "DTh" 
3cf3 f5				push af  
3cf4 3a 08 3d			ld a, (.dmark)  
3cf7 32 71 ee			ld (debug_mark),a  
3cfa 3a 09 3d			ld a, (.dmark+1)  
3cfd 32 72 ee			ld (debug_mark+1),a  
3d00 3a 0a 3d			ld a, (.dmark+2)  
3d03 32 73 ee			ld (debug_mark+2),a  
3d06 18 03			jr .pastdmark  
3d08 ..			.dmark: db "DTh"  
3d0b f1			.pastdmark: pop af  
3d0c			endm  
# End of macro DMARK
3d0c				CALLMONITOR 
3d0c cd ae 15			call break_point_state  
3d0f				endm  
# End of macro CALLMONITOR
3d0f			endif	 
3d0f			 
3d0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d0f cd ce 1e			call macro_forth_dsp_pop 
3d12				endm 
# End of macro FORTH_DSP_POP
3d12			 
3d12			if DEBUG_FORTH_DOT 
3d12				DMARK "DTi" 
3d12 f5				push af  
3d13 3a 27 3d			ld a, (.dmark)  
3d16 32 71 ee			ld (debug_mark),a  
3d19 3a 28 3d			ld a, (.dmark+1)  
3d1c 32 72 ee			ld (debug_mark+1),a  
3d1f 3a 29 3d			ld a, (.dmark+2)  
3d22 32 73 ee			ld (debug_mark+2),a  
3d25 18 03			jr .pastdmark  
3d27 ..			.dmark: db "DTi"  
3d2a f1			.pastdmark: pop af  
3d2b			endm  
# End of macro DMARK
3d2b				CALLMONITOR 
3d2b cd ae 15			call break_point_state  
3d2e				endm  
# End of macro CALLMONITOR
3d2e			endif	 
3d2e			 
3d2e			 
3d2e					NEXTW 
3d2e c3 cc 1f			jp macro_next 
3d31				endm 
# End of macro NEXTW
3d31			 
3d31			.CLS: 
3d31				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d31 35				db WORD_SYS_CORE+33             
3d32 5e 3d			dw .DRAW            
3d34 04				db 3 + 1 
3d35 .. 00			db "CLS",0              
3d39				endm 
# End of macro CWHEAD
3d39			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d39					if DEBUG_FORTH_WORDS_KEY 
3d39						DMARK "CLS" 
3d39 f5				push af  
3d3a 3a 4e 3d			ld a, (.dmark)  
3d3d 32 71 ee			ld (debug_mark),a  
3d40 3a 4f 3d			ld a, (.dmark+1)  
3d43 32 72 ee			ld (debug_mark+1),a  
3d46 3a 50 3d			ld a, (.dmark+2)  
3d49 32 73 ee			ld (debug_mark+2),a  
3d4c 18 03			jr .pastdmark  
3d4e ..			.dmark: db "CLS"  
3d51 f1			.pastdmark: pop af  
3d52			endm  
# End of macro DMARK
3d52						CALLMONITOR 
3d52 cd ae 15			call break_point_state  
3d55				endm  
# End of macro CALLMONITOR
3d55					endif 
3d55 cd 80 0b				call clear_display 
3d58 c3 6c 3e				jp .home		; and home cursor 
3d5b					NEXTW 
3d5b c3 cc 1f			jp macro_next 
3d5e				endm 
# End of macro NEXTW
3d5e			 
3d5e			.DRAW: 
3d5e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d5e 36				db WORD_SYS_CORE+34             
3d5f 89 3d			dw .DUMP            
3d61 05				db 4 + 1 
3d62 .. 00			db "DRAW",0              
3d67				endm 
# End of macro CWHEAD
3d67			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3d67					if DEBUG_FORTH_WORDS_KEY 
3d67						DMARK "DRW" 
3d67 f5				push af  
3d68 3a 7c 3d			ld a, (.dmark)  
3d6b 32 71 ee			ld (debug_mark),a  
3d6e 3a 7d 3d			ld a, (.dmark+1)  
3d71 32 72 ee			ld (debug_mark+1),a  
3d74 3a 7e 3d			ld a, (.dmark+2)  
3d77 32 73 ee			ld (debug_mark+2),a  
3d7a 18 03			jr .pastdmark  
3d7c ..			.dmark: db "DRW"  
3d7f f1			.pastdmark: pop af  
3d80			endm  
# End of macro DMARK
3d80						CALLMONITOR 
3d80 cd ae 15			call break_point_state  
3d83				endm  
# End of macro CALLMONITOR
3d83					endif 
3d83 cd a3 0b				call update_display 
3d86					NEXTW 
3d86 c3 cc 1f			jp macro_next 
3d89				endm 
# End of macro NEXTW
3d89			 
3d89			.DUMP: 
3d89				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d89 37				db WORD_SYS_CORE+35             
3d8a c1 3d			dw .CDUMP            
3d8c 05				db 4 + 1 
3d8d .. 00			db "DUMP",0              
3d92				endm 
# End of macro CWHEAD
3d92			; | DUMP ( x -- ) With address x display dump   | DONE 
3d92			; TODO pop address to use off of the stack 
3d92					if DEBUG_FORTH_WORDS_KEY 
3d92						DMARK "DUM" 
3d92 f5				push af  
3d93 3a a7 3d			ld a, (.dmark)  
3d96 32 71 ee			ld (debug_mark),a  
3d99 3a a8 3d			ld a, (.dmark+1)  
3d9c 32 72 ee			ld (debug_mark+1),a  
3d9f 3a a9 3d			ld a, (.dmark+2)  
3da2 32 73 ee			ld (debug_mark+2),a  
3da5 18 03			jr .pastdmark  
3da7 ..			.dmark: db "DUM"  
3daa f1			.pastdmark: pop af  
3dab			endm  
# End of macro DMARK
3dab						CALLMONITOR 
3dab cd ae 15			call break_point_state  
3dae				endm  
# End of macro CALLMONITOR
3dae					endif 
3dae cd 80 0b				call clear_display 
3db1			 
3db1					; get address 
3db1			 
3db1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3db1 cd 16 1e			call macro_dsp_valuehl 
3db4				endm 
# End of macro FORTH_DSP_VALUEHL
3db4				 
3db4					; save it for cdump 
3db4			 
3db4 22 ee e5				ld (os_cur_ptr),hl 
3db7			 
3db7					; destroy value TOS 
3db7			 
3db7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db7 cd ce 1e			call macro_forth_dsp_pop 
3dba				endm 
# End of macro FORTH_DSP_POP
3dba			 
3dba cd 9f 1a				call dumpcont	; skip old style of param parsing	 
3dbd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3dbe					NEXTW 
3dbe c3 cc 1f			jp macro_next 
3dc1				endm 
# End of macro NEXTW
3dc1			.CDUMP: 
3dc1				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3dc1 38				db WORD_SYS_CORE+36             
3dc2 f1 3d			dw .DAT            
3dc4 06				db 5 + 1 
3dc5 .. 00			db "CDUMP",0              
3dcb				endm 
# End of macro CWHEAD
3dcb			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3dcb					if DEBUG_FORTH_WORDS_KEY 
3dcb						DMARK "CDP" 
3dcb f5				push af  
3dcc 3a e0 3d			ld a, (.dmark)  
3dcf 32 71 ee			ld (debug_mark),a  
3dd2 3a e1 3d			ld a, (.dmark+1)  
3dd5 32 72 ee			ld (debug_mark+1),a  
3dd8 3a e2 3d			ld a, (.dmark+2)  
3ddb 32 73 ee			ld (debug_mark+2),a  
3dde 18 03			jr .pastdmark  
3de0 ..			.dmark: db "CDP"  
3de3 f1			.pastdmark: pop af  
3de4			endm  
# End of macro DMARK
3de4						CALLMONITOR 
3de4 cd ae 15			call break_point_state  
3de7				endm  
# End of macro CALLMONITOR
3de7					endif 
3de7 cd 80 0b				call clear_display 
3dea cd 9f 1a				call dumpcont	 
3ded c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3dee					NEXTW 
3dee c3 cc 1f			jp macro_next 
3df1				endm 
# End of macro NEXTW
3df1			 
3df1			 
3df1			 
3df1			 
3df1			.DAT: 
3df1				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3df1 3d				db WORD_SYS_CORE+41             
3df2 47 3e			dw .HOME            
3df4 03				db 2 + 1 
3df5 .. 00			db "AT",0              
3df8				endm 
# End of macro CWHEAD
3df8			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3df8					if DEBUG_FORTH_WORDS_KEY 
3df8						DMARK "AT." 
3df8 f5				push af  
3df9 3a 0d 3e			ld a, (.dmark)  
3dfc 32 71 ee			ld (debug_mark),a  
3dff 3a 0e 3e			ld a, (.dmark+1)  
3e02 32 72 ee			ld (debug_mark+1),a  
3e05 3a 0f 3e			ld a, (.dmark+2)  
3e08 32 73 ee			ld (debug_mark+2),a  
3e0b 18 03			jr .pastdmark  
3e0d ..			.dmark: db "AT."  
3e10 f1			.pastdmark: pop af  
3e11			endm  
# End of macro DMARK
3e11						CALLMONITOR 
3e11 cd ae 15			call break_point_state  
3e14				endm  
# End of macro CALLMONITOR
3e14					endif 
3e14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e14 cd 16 1e			call macro_dsp_valuehl 
3e17				endm 
# End of macro FORTH_DSP_VALUEHL
3e17			 
3e17			 
3e17					; TODO save cursor row 
3e17 7d					ld a,l 
3e18 fe 02				cp 2 
3e1a 20 04				jr nz, .crow3 
3e1c 3e 28				ld a, display_row_2 
3e1e 18 12				jr .ccol1 
3e20 fe 03		.crow3:		cp 3 
3e22 20 04				jr nz, .crow4 
3e24 3e 50				ld a, display_row_3 
3e26 18 0a				jr .ccol1 
3e28 fe 04		.crow4:		cp 4 
3e2a 20 04				jr nz, .crow1 
3e2c 3e 78				ld a, display_row_4 
3e2e 18 02				jr .ccol1 
3e30 3e 00		.crow1:		ld a,display_row_1 
3e32 f5			.ccol1:		push af			; got row offset 
3e33 6f					ld l,a 
3e34 26 00				ld h,0 
3e36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e36 cd ce 1e			call macro_forth_dsp_pop 
3e39				endm 
# End of macro FORTH_DSP_POP
3e39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e39 cd 16 1e			call macro_dsp_valuehl 
3e3c				endm 
# End of macro FORTH_DSP_VALUEHL
3e3c					; TODO save cursor col 
3e3c f1					pop af 
3e3d 85					add l		; add col offset 
3e3e 32 68 ea				ld (f_cursor_ptr), a 
3e41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e41 cd ce 1e			call macro_forth_dsp_pop 
3e44				endm 
# End of macro FORTH_DSP_POP
3e44			 
3e44					; calculate  
3e44			 
3e44					NEXTW 
3e44 c3 cc 1f			jp macro_next 
3e47				endm 
# End of macro NEXTW
3e47			 
3e47			 
3e47			.HOME: 
3e47				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e47 41				db WORD_SYS_CORE+45             
3e48 74 3e			dw .SPACE            
3e4a 05				db 4 + 1 
3e4b .. 00			db "HOME",0              
3e50				endm 
# End of macro CWHEAD
3e50			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e50					if DEBUG_FORTH_WORDS_KEY 
3e50						DMARK "HOM" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 71 ee			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 72 ee			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 73 ee			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "HOM"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd ae 15			call break_point_state  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c 3e 00		.home:		ld a, 0		; and home cursor 
3e6e 32 68 ea				ld (f_cursor_ptr), a 
3e71					NEXTW 
3e71 c3 cc 1f			jp macro_next 
3e74				endm 
# End of macro NEXTW
3e74			 
3e74			 
3e74			.SPACE: 
3e74				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3e74 46				db WORD_SYS_CORE+50             
3e75 aa 3e			dw .SPACES            
3e77 03				db 2 + 1 
3e78 .. 00			db "BL",0              
3e7b				endm 
# End of macro CWHEAD
3e7b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3e7b					if DEBUG_FORTH_WORDS_KEY 
3e7b						DMARK "BL." 
3e7b f5				push af  
3e7c 3a 90 3e			ld a, (.dmark)  
3e7f 32 71 ee			ld (debug_mark),a  
3e82 3a 91 3e			ld a, (.dmark+1)  
3e85 32 72 ee			ld (debug_mark+1),a  
3e88 3a 92 3e			ld a, (.dmark+2)  
3e8b 32 73 ee			ld (debug_mark+2),a  
3e8e 18 03			jr .pastdmark  
3e90 ..			.dmark: db "BL."  
3e93 f1			.pastdmark: pop af  
3e94			endm  
# End of macro DMARK
3e94						CALLMONITOR 
3e94 cd ae 15			call break_point_state  
3e97				endm  
# End of macro CALLMONITOR
3e97					endif 
3e97 3e 20				ld a, " " 
3e99 32 cb e2				ld (scratch),a 
3e9c 3e 00				ld a, 0 
3e9e 32 cc e2				ld (scratch+1),a 
3ea1 21 cb e2				ld hl, scratch 
3ea4 cd 8d 1c				call forth_push_str 
3ea7					 
3ea7				       NEXTW 
3ea7 c3 cc 1f			jp macro_next 
3eaa				endm 
# End of macro NEXTW
3eaa			 
3eaa			;.blstr: db " ", 0 
3eaa			 
3eaa			.SPACES: 
3eaa				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3eaa 47				db WORD_SYS_CORE+51             
3eab 45 3f			dw .SCROLL            
3ead 07				db 6 + 1 
3eae .. 00			db "SPACES",0              
3eb5				endm 
# End of macro CWHEAD
3eb5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3eb5					if DEBUG_FORTH_WORDS_KEY 
3eb5						DMARK "SPS" 
3eb5 f5				push af  
3eb6 3a ca 3e			ld a, (.dmark)  
3eb9 32 71 ee			ld (debug_mark),a  
3ebc 3a cb 3e			ld a, (.dmark+1)  
3ebf 32 72 ee			ld (debug_mark+1),a  
3ec2 3a cc 3e			ld a, (.dmark+2)  
3ec5 32 73 ee			ld (debug_mark+2),a  
3ec8 18 03			jr .pastdmark  
3eca ..			.dmark: db "SPS"  
3ecd f1			.pastdmark: pop af  
3ece			endm  
# End of macro DMARK
3ece						CALLMONITOR 
3ece cd ae 15			call break_point_state  
3ed1				endm  
# End of macro CALLMONITOR
3ed1					endif 
3ed1			 
3ed1			 
3ed1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ed1 cd 16 1e			call macro_dsp_valuehl 
3ed4				endm 
# End of macro FORTH_DSP_VALUEHL
3ed4			 
3ed4 e5					push hl    ; u 
3ed5					if DEBUG_FORTH_WORDS 
3ed5						DMARK "SPA" 
3ed5 f5				push af  
3ed6 3a ea 3e			ld a, (.dmark)  
3ed9 32 71 ee			ld (debug_mark),a  
3edc 3a eb 3e			ld a, (.dmark+1)  
3edf 32 72 ee			ld (debug_mark+1),a  
3ee2 3a ec 3e			ld a, (.dmark+2)  
3ee5 32 73 ee			ld (debug_mark+2),a  
3ee8 18 03			jr .pastdmark  
3eea ..			.dmark: db "SPA"  
3eed f1			.pastdmark: pop af  
3eee			endm  
# End of macro DMARK
3eee						CALLMONITOR 
3eee cd ae 15			call break_point_state  
3ef1				endm  
# End of macro CALLMONITOR
3ef1					endif 
3ef1			 
3ef1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef1 cd ce 1e			call macro_forth_dsp_pop 
3ef4				endm 
# End of macro FORTH_DSP_POP
3ef4 e1					pop hl 
3ef5 0e 00				ld c, 0 
3ef7 45					ld b, l 
3ef8 21 cb e2				ld hl, scratch  
3efb			 
3efb					if DEBUG_FORTH_WORDS 
3efb						DMARK "SP2" 
3efb f5				push af  
3efc 3a 10 3f			ld a, (.dmark)  
3eff 32 71 ee			ld (debug_mark),a  
3f02 3a 11 3f			ld a, (.dmark+1)  
3f05 32 72 ee			ld (debug_mark+1),a  
3f08 3a 12 3f			ld a, (.dmark+2)  
3f0b 32 73 ee			ld (debug_mark+2),a  
3f0e 18 03			jr .pastdmark  
3f10 ..			.dmark: db "SP2"  
3f13 f1			.pastdmark: pop af  
3f14			endm  
# End of macro DMARK
3f14						CALLMONITOR 
3f14 cd ae 15			call break_point_state  
3f17				endm  
# End of macro CALLMONITOR
3f17					endif 
3f17 3e 20				ld a, ' ' 
3f19			.spaces1:	 
3f19 77					ld (hl),a 
3f1a 23					inc hl 
3f1b					 
3f1b 10 fc				djnz .spaces1 
3f1d 3e 00				ld a,0 
3f1f 77					ld (hl),a 
3f20 21 cb e2				ld hl, scratch 
3f23					if DEBUG_FORTH_WORDS 
3f23						DMARK "SP3" 
3f23 f5				push af  
3f24 3a 38 3f			ld a, (.dmark)  
3f27 32 71 ee			ld (debug_mark),a  
3f2a 3a 39 3f			ld a, (.dmark+1)  
3f2d 32 72 ee			ld (debug_mark+1),a  
3f30 3a 3a 3f			ld a, (.dmark+2)  
3f33 32 73 ee			ld (debug_mark+2),a  
3f36 18 03			jr .pastdmark  
3f38 ..			.dmark: db "SP3"  
3f3b f1			.pastdmark: pop af  
3f3c			endm  
# End of macro DMARK
3f3c						CALLMONITOR 
3f3c cd ae 15			call break_point_state  
3f3f				endm  
# End of macro CALLMONITOR
3f3f					endif 
3f3f cd 8d 1c				call forth_push_str 
3f42			 
3f42				       NEXTW 
3f42 c3 cc 1f			jp macro_next 
3f45				endm 
# End of macro NEXTW
3f45			 
3f45			 
3f45			 
3f45			.SCROLL: 
3f45				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f45 53				db WORD_SYS_CORE+63             
3f46 72 3f			dw .SCROLLD            
3f48 07				db 6 + 1 
3f49 .. 00			db "SCROLL",0              
3f50				endm 
# End of macro CWHEAD
3f50			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f50					if DEBUG_FORTH_WORDS_KEY 
3f50						DMARK "SCR" 
3f50 f5				push af  
3f51 3a 65 3f			ld a, (.dmark)  
3f54 32 71 ee			ld (debug_mark),a  
3f57 3a 66 3f			ld a, (.dmark+1)  
3f5a 32 72 ee			ld (debug_mark+1),a  
3f5d 3a 67 3f			ld a, (.dmark+2)  
3f60 32 73 ee			ld (debug_mark+2),a  
3f63 18 03			jr .pastdmark  
3f65 ..			.dmark: db "SCR"  
3f68 f1			.pastdmark: pop af  
3f69			endm  
# End of macro DMARK
3f69						CALLMONITOR 
3f69 cd ae 15			call break_point_state  
3f6c				endm  
# End of macro CALLMONITOR
3f6c					endif 
3f6c			 
3f6c cd 42 0b			call scroll_up 
3f6f			;	call update_display 
3f6f			 
3f6f					NEXTW 
3f6f c3 cc 1f			jp macro_next 
3f72				endm 
# End of macro NEXTW
3f72			 
3f72			 
3f72			 
3f72			;		; get dir 
3f72			; 
3f72			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f72			; 
3f72			;		push hl 
3f72			; 
3f72			;		; destroy value TOS 
3f72			; 
3f72			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f72			; 
3f72			;		; get count 
3f72			; 
3f72			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f72			; 
3f72			;		push hl 
3f72			; 
3f72			;		; destroy value TOS 
3f72			; 
3f72			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f72			; 
3f72			;		; one value on hl get other one back 
3f72			; 
3f72			;		pop bc    ; count 
3f72			; 
3f72			;		pop de   ; dir 
3f72			; 
3f72			; 
3f72			;		ld b, c 
3f72			; 
3f72			;.scrolldir:     push bc 
3f72			;		push de 
3f72			; 
3f72			;		ld a, 0 
3f72			;		cp e 
3f72			;		jr z, .scrollup  
3f72			;		call scroll_down 
3f72			;		jr .scrollnext 
3f72			;.scrollup:	call scroll_up 
3f72			; 
3f72			;		 
3f72			;.scrollnext: 
3f72			;		pop de 
3f72			;		pop bc 
3f72			;		djnz .scrolldir 
3f72			; 
3f72			; 
3f72			; 
3f72			; 
3f72			; 
3f72			;		NEXTW 
3f72			 
3f72			.SCROLLD: 
3f72				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3f72 53				db WORD_SYS_CORE+63             
3f73 a0 3f			dw .ATQ            
3f75 08				db 7 + 1 
3f76 .. 00			db "SCROLLD",0              
3f7e				endm 
# End of macro CWHEAD
3f7e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3f7e					if DEBUG_FORTH_WORDS_KEY 
3f7e						DMARK "SCD" 
3f7e f5				push af  
3f7f 3a 93 3f			ld a, (.dmark)  
3f82 32 71 ee			ld (debug_mark),a  
3f85 3a 94 3f			ld a, (.dmark+1)  
3f88 32 72 ee			ld (debug_mark+1),a  
3f8b 3a 95 3f			ld a, (.dmark+2)  
3f8e 32 73 ee			ld (debug_mark+2),a  
3f91 18 03			jr .pastdmark  
3f93 ..			.dmark: db "SCD"  
3f96 f1			.pastdmark: pop af  
3f97			endm  
# End of macro DMARK
3f97						CALLMONITOR 
3f97 cd ae 15			call break_point_state  
3f9a				endm  
# End of macro CALLMONITOR
3f9a					endif 
3f9a			 
3f9a cd 66 0b			call scroll_down 
3f9d			;	call update_display 
3f9d			 
3f9d					NEXTW 
3f9d c3 cc 1f			jp macro_next 
3fa0				endm 
# End of macro NEXTW
3fa0			 
3fa0			 
3fa0			.ATQ: 
3fa0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3fa0 62				db WORD_SYS_CORE+78             
3fa1 fe 3f			dw .AUTODSP            
3fa3 04				db 3 + 1 
3fa4 .. 00			db "AT@",0              
3fa8				endm 
# End of macro CWHEAD
3fa8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3fa8					if DEBUG_FORTH_WORDS_KEY 
3fa8						DMARK "ATA" 
3fa8 f5				push af  
3fa9 3a bd 3f			ld a, (.dmark)  
3fac 32 71 ee			ld (debug_mark),a  
3faf 3a be 3f			ld a, (.dmark+1)  
3fb2 32 72 ee			ld (debug_mark+1),a  
3fb5 3a bf 3f			ld a, (.dmark+2)  
3fb8 32 73 ee			ld (debug_mark+2),a  
3fbb 18 03			jr .pastdmark  
3fbd ..			.dmark: db "ATA"  
3fc0 f1			.pastdmark: pop af  
3fc1			endm  
# End of macro DMARK
3fc1						CALLMONITOR 
3fc1 cd ae 15			call break_point_state  
3fc4				endm  
# End of macro CALLMONITOR
3fc4					endif 
3fc4			 
3fc4			 
3fc4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fc4 cd 16 1e			call macro_dsp_valuehl 
3fc7				endm 
# End of macro FORTH_DSP_VALUEHL
3fc7			 
3fc7					; TODO save cursor row 
3fc7 7d					ld a,l 
3fc8 fe 02				cp 2 
3fca 20 04				jr nz, .crow3aq 
3fcc 3e 28				ld a, display_row_2 
3fce 18 12				jr .ccol1aq 
3fd0 fe 03		.crow3aq:		cp 3 
3fd2 20 04				jr nz, .crow4aq 
3fd4 3e 50				ld a, display_row_3 
3fd6 18 0a				jr .ccol1aq 
3fd8 fe 04		.crow4aq:		cp 4 
3fda 20 04				jr nz, .crow1aq 
3fdc 3e 78				ld a, display_row_4 
3fde 18 02				jr .ccol1aq 
3fe0 3e 00		.crow1aq:		ld a,display_row_1 
3fe2 f5			.ccol1aq:		push af			; got row offset 
3fe3 6f					ld l,a 
3fe4 26 00				ld h,0 
3fe6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe6 cd ce 1e			call macro_forth_dsp_pop 
3fe9				endm 
# End of macro FORTH_DSP_POP
3fe9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fe9 cd 16 1e			call macro_dsp_valuehl 
3fec				endm 
# End of macro FORTH_DSP_VALUEHL
3fec					; TODO save cursor col 
3fec f1					pop af 
3fed 85					add l		; add col offset 
3fee			 
3fee					; add current frame buffer address 
3fee 2a d2 eb				ld hl, (display_fb_active) 
3ff1 cd ad 0d				call addatohl 
3ff4			 
3ff4			 
3ff4			 
3ff4			 
3ff4					; get char frame buffer location offset in hl 
3ff4			 
3ff4 7e					ld a,(hl) 
3ff5 26 00				ld h, 0 
3ff7 6f					ld l, a 
3ff8			 
3ff8 cd 1f 1c				call forth_push_numhl 
3ffb			 
3ffb			 
3ffb					NEXTW 
3ffb c3 cc 1f			jp macro_next 
3ffe				endm 
# End of macro NEXTW
3ffe			 
3ffe			.AUTODSP: 
3ffe				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ffe 63				db WORD_SYS_CORE+79             
3fff 14 40			dw .MENU            
4001 05				db 4 + 1 
4002 .. 00			db "ADSP",0              
4007				endm 
# End of macro CWHEAD
4007			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4007			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4007			 
4007					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4007 cd 16 1e			call macro_dsp_valuehl 
400a				endm 
# End of macro FORTH_DSP_VALUEHL
400a			 
400a			;		push hl 
400a			 
400a					; destroy value TOS 
400a			 
400a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
400a cd ce 1e			call macro_forth_dsp_pop 
400d				endm 
# End of macro FORTH_DSP_POP
400d			 
400d			;		pop hl 
400d			 
400d 7d					ld a,l 
400e 32 46 ea				ld (cli_autodisplay), a 
4011				       NEXTW 
4011 c3 cc 1f			jp macro_next 
4014				endm 
# End of macro NEXTW
4014			 
4014			.MENU: 
4014				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4014 70				db WORD_SYS_CORE+92             
4015 bd 40			dw .ENDDISPLAY            
4017 05				db 4 + 1 
4018 .. 00			db "MENU",0              
401d				endm 
# End of macro CWHEAD
401d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
401d			 
401d			;		; get number of items on the stack 
401d			; 
401d				 
401d					FORTH_DSP_VALUEHL 
401d cd 16 1e			call macro_dsp_valuehl 
4020				endm 
# End of macro FORTH_DSP_VALUEHL
4020				 
4020					if DEBUG_FORTH_WORDS_KEY 
4020						DMARK "MNU" 
4020 f5				push af  
4021 3a 35 40			ld a, (.dmark)  
4024 32 71 ee			ld (debug_mark),a  
4027 3a 36 40			ld a, (.dmark+1)  
402a 32 72 ee			ld (debug_mark+1),a  
402d 3a 37 40			ld a, (.dmark+2)  
4030 32 73 ee			ld (debug_mark+2),a  
4033 18 03			jr .pastdmark  
4035 ..			.dmark: db "MNU"  
4038 f1			.pastdmark: pop af  
4039			endm  
# End of macro DMARK
4039						CALLMONITOR 
4039 cd ae 15			call break_point_state  
403c				endm  
# End of macro CALLMONITOR
403c					endif 
403c			 
403c 45					ld b, l	 
403d 05					dec b 
403e			 
403e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
403e cd ce 1e			call macro_forth_dsp_pop 
4041				endm 
# End of macro FORTH_DSP_POP
4041			 
4041			 
4041					; go directly through the stack to pluck out the string pointers and build an array 
4041			 
4041			;		FORTH_DSP 
4041			 
4041					; hl contains top most stack item 
4041				 
4041 11 cb e2				ld de, scratch 
4044			 
4044			.mbuild: 
4044			 
4044					FORTH_DSP_VALUEHL 
4044 cd 16 1e			call macro_dsp_valuehl 
4047				endm 
# End of macro FORTH_DSP_VALUEHL
4047			 
4047					if DEBUG_FORTH_WORDS 
4047						DMARK "MN3" 
4047 f5				push af  
4048 3a 5c 40			ld a, (.dmark)  
404b 32 71 ee			ld (debug_mark),a  
404e 3a 5d 40			ld a, (.dmark+1)  
4051 32 72 ee			ld (debug_mark+1),a  
4054 3a 5e 40			ld a, (.dmark+2)  
4057 32 73 ee			ld (debug_mark+2),a  
405a 18 03			jr .pastdmark  
405c ..			.dmark: db "MN3"  
405f f1			.pastdmark: pop af  
4060			endm  
# End of macro DMARK
4060						CALLMONITOR 
4060 cd ae 15			call break_point_state  
4063				endm  
# End of macro CALLMONITOR
4063					endif 
4063 eb					ex de, hl 
4064 73					ld (hl), e 
4065 23					inc hl 
4066 72					ld (hl), d 
4067 23					inc hl 
4068 eb					ex de, hl 
4069			 
4069					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4069 cd ce 1e			call macro_forth_dsp_pop 
406c				endm 
# End of macro FORTH_DSP_POP
406c			 
406c 10 d6				djnz .mbuild 
406e			 
406e					; done add term 
406e			 
406e eb					ex de, hl 
406f 36 00				ld (hl), 0 
4071 23					inc hl 
4072 36 00				ld (hl), 0 
4074			 
4074				 
4074					 
4074 21 cb e2				ld hl, scratch 
4077			 
4077					if DEBUG_FORTH_WORDS 
4077						DMARK "MNx" 
4077 f5				push af  
4078 3a 8c 40			ld a, (.dmark)  
407b 32 71 ee			ld (debug_mark),a  
407e 3a 8d 40			ld a, (.dmark+1)  
4081 32 72 ee			ld (debug_mark+1),a  
4084 3a 8e 40			ld a, (.dmark+2)  
4087 32 73 ee			ld (debug_mark+2),a  
408a 18 03			jr .pastdmark  
408c ..			.dmark: db "MNx"  
408f f1			.pastdmark: pop af  
4090			endm  
# End of macro DMARK
4090						CALLMONITOR 
4090 cd ae 15			call break_point_state  
4093				endm  
# End of macro CALLMONITOR
4093					endif 
4093			 
4093			 
4093			 
4093 3e 00				ld a, 0 
4095 cd b1 0b				call menu 
4098			 
4098			 
4098 6f					ld l, a 
4099 26 00				ld h, 0 
409b			 
409b					if DEBUG_FORTH_WORDS 
409b						DMARK "MNr" 
409b f5				push af  
409c 3a b0 40			ld a, (.dmark)  
409f 32 71 ee			ld (debug_mark),a  
40a2 3a b1 40			ld a, (.dmark+1)  
40a5 32 72 ee			ld (debug_mark+1),a  
40a8 3a b2 40			ld a, (.dmark+2)  
40ab 32 73 ee			ld (debug_mark+2),a  
40ae 18 03			jr .pastdmark  
40b0 ..			.dmark: db "MNr"  
40b3 f1			.pastdmark: pop af  
40b4			endm  
# End of macro DMARK
40b4						CALLMONITOR 
40b4 cd ae 15			call break_point_state  
40b7				endm  
# End of macro CALLMONITOR
40b7					endif 
40b7			 
40b7 cd 1f 1c				call forth_push_numhl 
40ba			 
40ba			 
40ba			 
40ba			 
40ba				       NEXTW 
40ba c3 cc 1f			jp macro_next 
40bd				endm 
# End of macro NEXTW
40bd			 
40bd			 
40bd			.ENDDISPLAY: 
40bd			 
40bd			; eof 
# End of file forth_words_display.asm
40bd			include "forth_words_str.asm" 
40bd			 
40bd			; | ## String Words 
40bd			 
40bd			.PTR:   
40bd			 
40bd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
40bd 48				db WORD_SYS_CORE+52             
40be ea 40			dw .STYPE            
40c0 04				db 3 + 1 
40c1 .. 00			db "PTR",0              
40c5				endm 
# End of macro CWHEAD
40c5			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
40c5			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
40c5			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
40c5			 
40c5					if DEBUG_FORTH_WORDS_KEY 
40c5						DMARK "PTR" 
40c5 f5				push af  
40c6 3a da 40			ld a, (.dmark)  
40c9 32 71 ee			ld (debug_mark),a  
40cc 3a db 40			ld a, (.dmark+1)  
40cf 32 72 ee			ld (debug_mark+1),a  
40d2 3a dc 40			ld a, (.dmark+2)  
40d5 32 73 ee			ld (debug_mark+2),a  
40d8 18 03			jr .pastdmark  
40da ..			.dmark: db "PTR"  
40dd f1			.pastdmark: pop af  
40de			endm  
# End of macro DMARK
40de						CALLMONITOR 
40de cd ae 15			call break_point_state  
40e1				endm  
# End of macro CALLMONITOR
40e1					endif 
40e1					FORTH_DSP_VALUEHL 
40e1 cd 16 1e			call macro_dsp_valuehl 
40e4				endm 
# End of macro FORTH_DSP_VALUEHL
40e4 cd 1f 1c				call forth_push_numhl 
40e7			 
40e7			 
40e7					NEXTW 
40e7 c3 cc 1f			jp macro_next 
40ea				endm 
# End of macro NEXTW
40ea			.STYPE: 
40ea				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
40ea 48				db WORD_SYS_CORE+52             
40eb 39 41			dw .UPPER            
40ed 06				db 5 + 1 
40ee .. 00			db "STYPE",0              
40f4				endm 
# End of macro CWHEAD
40f4			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
40f4					if DEBUG_FORTH_WORDS_KEY 
40f4						DMARK "STY" 
40f4 f5				push af  
40f5 3a 09 41			ld a, (.dmark)  
40f8 32 71 ee			ld (debug_mark),a  
40fb 3a 0a 41			ld a, (.dmark+1)  
40fe 32 72 ee			ld (debug_mark+1),a  
4101 3a 0b 41			ld a, (.dmark+2)  
4104 32 73 ee			ld (debug_mark+2),a  
4107 18 03			jr .pastdmark  
4109 ..			.dmark: db "STY"  
410c f1			.pastdmark: pop af  
410d			endm  
# End of macro DMARK
410d						CALLMONITOR 
410d cd ae 15			call break_point_state  
4110				endm  
# End of macro CALLMONITOR
4110					endif 
4110					FORTH_DSP 
4110 cd dc 1d			call macro_forth_dsp 
4113				endm 
# End of macro FORTH_DSP
4113					;v5 FORTH_DSP_VALUE 
4113			 
4113 7e					ld a, (hl) 
4114			 
4114 f5					push af 
4115			 
4115			; Dont destroy TOS		FORTH_DSP_POP 
4115			 
4115 f1					pop af 
4116			 
4116 fe 01				cp DS_TYPE_STR 
4118 28 09				jr z, .typestr 
411a			 
411a fe 02				cp DS_TYPE_INUM 
411c 28 0a				jr z, .typeinum 
411e			 
411e 21 37 41				ld hl, .tna 
4121 18 0a				jr .tpush 
4123			 
4123 21 33 41		.typestr:	ld hl, .tstr 
4126 18 05				jr .tpush 
4128 21 35 41		.typeinum:	ld hl, .tinum 
412b 18 00				jr .tpush 
412d			 
412d			.tpush: 
412d			 
412d cd 8d 1c				call forth_push_str 
4130			 
4130					NEXTW 
4130 c3 cc 1f			jp macro_next 
4133				endm 
# End of macro NEXTW
4133 .. 00		.tstr:	db "s",0 
4135 .. 00		.tinum:  db "i",0 
4137 .. 00		.tna:   db "?", 0 
4139			 
4139			 
4139			.UPPER: 
4139				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4139 48				db WORD_SYS_CORE+52             
413a 74 41			dw .LOWER            
413c 06				db 5 + 1 
413d .. 00			db "UPPER",0              
4143				endm 
# End of macro CWHEAD
4143			; | UPPER ( s -- s ) Upper case string s  | DONE 
4143					if DEBUG_FORTH_WORDS_KEY 
4143						DMARK "UPR" 
4143 f5				push af  
4144 3a 58 41			ld a, (.dmark)  
4147 32 71 ee			ld (debug_mark),a  
414a 3a 59 41			ld a, (.dmark+1)  
414d 32 72 ee			ld (debug_mark+1),a  
4150 3a 5a 41			ld a, (.dmark+2)  
4153 32 73 ee			ld (debug_mark+2),a  
4156 18 03			jr .pastdmark  
4158 ..			.dmark: db "UPR"  
415b f1			.pastdmark: pop af  
415c			endm  
# End of macro DMARK
415c						CALLMONITOR 
415c cd ae 15			call break_point_state  
415f				endm  
# End of macro CALLMONITOR
415f					endif 
415f			 
415f					FORTH_DSP 
415f cd dc 1d			call macro_forth_dsp 
4162				endm 
# End of macro FORTH_DSP
4162					 
4162			; TODO check is string type 
4162			 
4162					FORTH_DSP_VALUEHL 
4162 cd 16 1e			call macro_dsp_valuehl 
4165				endm 
# End of macro FORTH_DSP_VALUEHL
4165			; get pointer to string in hl 
4165			 
4165 7e			.toup:		ld a, (hl) 
4166 fe 00				cp 0 
4168 28 07				jr z, .toupdone 
416a			 
416a cd 1a 11				call to_upper 
416d			 
416d 77					ld (hl), a 
416e 23					inc hl 
416f 18 f4				jr .toup 
4171			 
4171					 
4171			 
4171			 
4171			; for each char convert to upper 
4171					 
4171			.toupdone: 
4171			 
4171			 
4171					NEXTW 
4171 c3 cc 1f			jp macro_next 
4174				endm 
# End of macro NEXTW
4174			.LOWER: 
4174				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4174 48				db WORD_SYS_CORE+52             
4175 af 41			dw .TCASE            
4177 06				db 5 + 1 
4178 .. 00			db "LOWER",0              
417e				endm 
# End of macro CWHEAD
417e			; | LOWER ( s -- s ) Lower case string s  | DONE 
417e					if DEBUG_FORTH_WORDS_KEY 
417e						DMARK "LWR" 
417e f5				push af  
417f 3a 93 41			ld a, (.dmark)  
4182 32 71 ee			ld (debug_mark),a  
4185 3a 94 41			ld a, (.dmark+1)  
4188 32 72 ee			ld (debug_mark+1),a  
418b 3a 95 41			ld a, (.dmark+2)  
418e 32 73 ee			ld (debug_mark+2),a  
4191 18 03			jr .pastdmark  
4193 ..			.dmark: db "LWR"  
4196 f1			.pastdmark: pop af  
4197			endm  
# End of macro DMARK
4197						CALLMONITOR 
4197 cd ae 15			call break_point_state  
419a				endm  
# End of macro CALLMONITOR
419a					endif 
419a			 
419a					FORTH_DSP 
419a cd dc 1d			call macro_forth_dsp 
419d				endm 
# End of macro FORTH_DSP
419d					 
419d			; TODO check is string type 
419d			 
419d					FORTH_DSP_VALUEHL 
419d cd 16 1e			call macro_dsp_valuehl 
41a0				endm 
# End of macro FORTH_DSP_VALUEHL
41a0			; get pointer to string in hl 
41a0			 
41a0 7e			.tolow:		ld a, (hl) 
41a1 fe 00				cp 0 
41a3 28 07				jr z, .tolowdone 
41a5			 
41a5 cd 23 11				call to_lower 
41a8			 
41a8 77					ld (hl), a 
41a9 23					inc hl 
41aa 18 f4				jr .tolow 
41ac			 
41ac					 
41ac			 
41ac			 
41ac			; for each char convert to low 
41ac					 
41ac			.tolowdone: 
41ac					NEXTW 
41ac c3 cc 1f			jp macro_next 
41af				endm 
# End of macro NEXTW
41af			.TCASE: 
41af				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
41af 48				db WORD_SYS_CORE+52             
41b0 e5 42			dw .SUBSTR            
41b2 06				db 5 + 1 
41b3 .. 00			db "TCASE",0              
41b9				endm 
# End of macro CWHEAD
41b9			; | TCASE ( s -- s ) Title case string s  | DONE 
41b9					if DEBUG_FORTH_WORDS_KEY 
41b9						DMARK "TCS" 
41b9 f5				push af  
41ba 3a ce 41			ld a, (.dmark)  
41bd 32 71 ee			ld (debug_mark),a  
41c0 3a cf 41			ld a, (.dmark+1)  
41c3 32 72 ee			ld (debug_mark+1),a  
41c6 3a d0 41			ld a, (.dmark+2)  
41c9 32 73 ee			ld (debug_mark+2),a  
41cc 18 03			jr .pastdmark  
41ce ..			.dmark: db "TCS"  
41d1 f1			.pastdmark: pop af  
41d2			endm  
# End of macro DMARK
41d2						CALLMONITOR 
41d2 cd ae 15			call break_point_state  
41d5				endm  
# End of macro CALLMONITOR
41d5					endif 
41d5			 
41d5					FORTH_DSP 
41d5 cd dc 1d			call macro_forth_dsp 
41d8				endm 
# End of macro FORTH_DSP
41d8					 
41d8			; TODO check is string type 
41d8			 
41d8					FORTH_DSP_VALUEHL 
41d8 cd 16 1e			call macro_dsp_valuehl 
41db				endm 
# End of macro FORTH_DSP_VALUEHL
41db			; get pointer to string in hl 
41db			 
41db					if DEBUG_FORTH_WORDS 
41db						DMARK "TC1" 
41db f5				push af  
41dc 3a f0 41			ld a, (.dmark)  
41df 32 71 ee			ld (debug_mark),a  
41e2 3a f1 41			ld a, (.dmark+1)  
41e5 32 72 ee			ld (debug_mark+1),a  
41e8 3a f2 41			ld a, (.dmark+2)  
41eb 32 73 ee			ld (debug_mark+2),a  
41ee 18 03			jr .pastdmark  
41f0 ..			.dmark: db "TC1"  
41f3 f1			.pastdmark: pop af  
41f4			endm  
# End of macro DMARK
41f4						CALLMONITOR 
41f4 cd ae 15			call break_point_state  
41f7				endm  
# End of macro CALLMONITOR
41f7					endif 
41f7			 
41f7					; first time in turn to upper case first char 
41f7			 
41f7 7e					ld a, (hl) 
41f8 c3 82 42				jp .totsiptou 
41fb			 
41fb			 
41fb 7e			.tot:		ld a, (hl) 
41fc fe 00				cp 0 
41fe ca c6 42				jp z, .totdone 
4201			 
4201					if DEBUG_FORTH_WORDS 
4201						DMARK "TC2" 
4201 f5				push af  
4202 3a 16 42			ld a, (.dmark)  
4205 32 71 ee			ld (debug_mark),a  
4208 3a 17 42			ld a, (.dmark+1)  
420b 32 72 ee			ld (debug_mark+1),a  
420e 3a 18 42			ld a, (.dmark+2)  
4211 32 73 ee			ld (debug_mark+2),a  
4214 18 03			jr .pastdmark  
4216 ..			.dmark: db "TC2"  
4219 f1			.pastdmark: pop af  
421a			endm  
# End of macro DMARK
421a						CALLMONITOR 
421a cd ae 15			call break_point_state  
421d				endm  
# End of macro CALLMONITOR
421d					endif 
421d					; check to see if current char is a space 
421d			 
421d fe 20				cp ' ' 
421f 28 21				jr z, .totsp 
4221 cd 23 11				call to_lower 
4224					if DEBUG_FORTH_WORDS 
4224						DMARK "TC3" 
4224 f5				push af  
4225 3a 39 42			ld a, (.dmark)  
4228 32 71 ee			ld (debug_mark),a  
422b 3a 3a 42			ld a, (.dmark+1)  
422e 32 72 ee			ld (debug_mark+1),a  
4231 3a 3b 42			ld a, (.dmark+2)  
4234 32 73 ee			ld (debug_mark+2),a  
4237 18 03			jr .pastdmark  
4239 ..			.dmark: db "TC3"  
423c f1			.pastdmark: pop af  
423d			endm  
# End of macro DMARK
423d						CALLMONITOR 
423d cd ae 15			call break_point_state  
4240				endm  
# End of macro CALLMONITOR
4240					endif 
4240 18 63				jr .totnxt 
4242			 
4242			.totsp:         ; on a space, find next char which should be upper 
4242			 
4242					if DEBUG_FORTH_WORDS 
4242						DMARK "TC4" 
4242 f5				push af  
4243 3a 57 42			ld a, (.dmark)  
4246 32 71 ee			ld (debug_mark),a  
4249 3a 58 42			ld a, (.dmark+1)  
424c 32 72 ee			ld (debug_mark+1),a  
424f 3a 59 42			ld a, (.dmark+2)  
4252 32 73 ee			ld (debug_mark+2),a  
4255 18 03			jr .pastdmark  
4257 ..			.dmark: db "TC4"  
425a f1			.pastdmark: pop af  
425b			endm  
# End of macro DMARK
425b						CALLMONITOR 
425b cd ae 15			call break_point_state  
425e				endm  
# End of macro CALLMONITOR
425e					endif 
425e					;; 
425e			 
425e fe 20				cp ' ' 
4260 20 20				jr nz, .totsiptou 
4262 23					inc hl 
4263 7e					ld a, (hl) 
4264					if DEBUG_FORTH_WORDS 
4264						DMARK "TC5" 
4264 f5				push af  
4265 3a 79 42			ld a, (.dmark)  
4268 32 71 ee			ld (debug_mark),a  
426b 3a 7a 42			ld a, (.dmark+1)  
426e 32 72 ee			ld (debug_mark+1),a  
4271 3a 7b 42			ld a, (.dmark+2)  
4274 32 73 ee			ld (debug_mark+2),a  
4277 18 03			jr .pastdmark  
4279 ..			.dmark: db "TC5"  
427c f1			.pastdmark: pop af  
427d			endm  
# End of macro DMARK
427d						CALLMONITOR 
427d cd ae 15			call break_point_state  
4280				endm  
# End of macro CALLMONITOR
4280					endif 
4280 18 c0				jr .totsp 
4282 fe 00		.totsiptou:    cp 0 
4284 28 40				jr z, .totdone 
4286					; not space and not zero term so upper case it 
4286 cd 1a 11				call to_upper 
4289			 
4289					if DEBUG_FORTH_WORDS 
4289						DMARK "TC6" 
4289 f5				push af  
428a 3a 9e 42			ld a, (.dmark)  
428d 32 71 ee			ld (debug_mark),a  
4290 3a 9f 42			ld a, (.dmark+1)  
4293 32 72 ee			ld (debug_mark+1),a  
4296 3a a0 42			ld a, (.dmark+2)  
4299 32 73 ee			ld (debug_mark+2),a  
429c 18 03			jr .pastdmark  
429e ..			.dmark: db "TC6"  
42a1 f1			.pastdmark: pop af  
42a2			endm  
# End of macro DMARK
42a2						CALLMONITOR 
42a2 cd ae 15			call break_point_state  
42a5				endm  
# End of macro CALLMONITOR
42a5					endif 
42a5			 
42a5			 
42a5			.totnxt: 
42a5			 
42a5 77					ld (hl), a 
42a6 23					inc hl 
42a7					if DEBUG_FORTH_WORDS 
42a7						DMARK "TC7" 
42a7 f5				push af  
42a8 3a bc 42			ld a, (.dmark)  
42ab 32 71 ee			ld (debug_mark),a  
42ae 3a bd 42			ld a, (.dmark+1)  
42b1 32 72 ee			ld (debug_mark+1),a  
42b4 3a be 42			ld a, (.dmark+2)  
42b7 32 73 ee			ld (debug_mark+2),a  
42ba 18 03			jr .pastdmark  
42bc ..			.dmark: db "TC7"  
42bf f1			.pastdmark: pop af  
42c0			endm  
# End of macro DMARK
42c0						CALLMONITOR 
42c0 cd ae 15			call break_point_state  
42c3				endm  
# End of macro CALLMONITOR
42c3					endif 
42c3 c3 fb 41				jp .tot 
42c6			 
42c6					 
42c6			 
42c6			 
42c6			; for each char convert to low 
42c6					 
42c6			.totdone: 
42c6					if DEBUG_FORTH_WORDS 
42c6						DMARK "TCd" 
42c6 f5				push af  
42c7 3a db 42			ld a, (.dmark)  
42ca 32 71 ee			ld (debug_mark),a  
42cd 3a dc 42			ld a, (.dmark+1)  
42d0 32 72 ee			ld (debug_mark+1),a  
42d3 3a dd 42			ld a, (.dmark+2)  
42d6 32 73 ee			ld (debug_mark+2),a  
42d9 18 03			jr .pastdmark  
42db ..			.dmark: db "TCd"  
42de f1			.pastdmark: pop af  
42df			endm  
# End of macro DMARK
42df						CALLMONITOR 
42df cd ae 15			call break_point_state  
42e2				endm  
# End of macro CALLMONITOR
42e2					endif 
42e2					NEXTW 
42e2 c3 cc 1f			jp macro_next 
42e5				endm 
# End of macro NEXTW
42e5			 
42e5			.SUBSTR: 
42e5				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
42e5 48				db WORD_SYS_CORE+52             
42e6 43 43			dw .LEFT            
42e8 07				db 6 + 1 
42e9 .. 00			db "SUBSTR",0              
42f0				endm 
# End of macro CWHEAD
42f0			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
42f0			 
42f0					if DEBUG_FORTH_WORDS_KEY 
42f0						DMARK "SST" 
42f0 f5				push af  
42f1 3a 05 43			ld a, (.dmark)  
42f4 32 71 ee			ld (debug_mark),a  
42f7 3a 06 43			ld a, (.dmark+1)  
42fa 32 72 ee			ld (debug_mark+1),a  
42fd 3a 07 43			ld a, (.dmark+2)  
4300 32 73 ee			ld (debug_mark+2),a  
4303 18 03			jr .pastdmark  
4305 ..			.dmark: db "SST"  
4308 f1			.pastdmark: pop af  
4309			endm  
# End of macro DMARK
4309						CALLMONITOR 
4309 cd ae 15			call break_point_state  
430c				endm  
# End of macro CALLMONITOR
430c					endif 
430c			; TODO check string type 
430c					FORTH_DSP_VALUEHL 
430c cd 16 1e			call macro_dsp_valuehl 
430f				endm 
# End of macro FORTH_DSP_VALUEHL
430f			 
430f e5					push hl      ; string length 
4310			 
4310					FORTH_DSP_POP 
4310 cd ce 1e			call macro_forth_dsp_pop 
4313				endm 
# End of macro FORTH_DSP_POP
4313			 
4313					FORTH_DSP_VALUEHL 
4313 cd 16 1e			call macro_dsp_valuehl 
4316				endm 
# End of macro FORTH_DSP_VALUEHL
4316			 
4316 e5					push hl     ; start char 
4317			 
4317					FORTH_DSP_POP 
4317 cd ce 1e			call macro_forth_dsp_pop 
431a				endm 
# End of macro FORTH_DSP_POP
431a			 
431a			 
431a					FORTH_DSP_VALUE 
431a cd ff 1d			call macro_forth_dsp_value 
431d				endm 
# End of macro FORTH_DSP_VALUE
431d			 
431d d1					pop de    ; get start post offset 
431e			 
431e 19					add hl, de    ; starting offset 
431f			 
431f c1					pop bc 
4320 c5					push bc      ; grab size of string 
4321			 
4321 e5					push hl    ; save string start  
4322			 
4322 26 00				ld h, 0 
4324 69					ld l, c 
4325 23					inc hl 
4326 23					inc hl 
4327			 
4327 cd 74 12				call malloc 
432a				if DEBUG_FORTH_MALLOC_GUARD 
432a cc 8b 4c				call z,malloc_error 
432d				endif 
432d			 
432d eb					ex de, hl      ; save malloc area for string copy 
432e e1					pop hl    ; get back source 
432f c1					pop bc    ; get length of string back 
4330			 
4330 d5					push de    ; save malloc area for after we push 
4331 ed b0				ldir     ; copy substr 
4333			 
4333			 
4333 eb					ex de, hl 
4334 3e 00				ld a, 0 
4336 77					ld (hl), a   ; term substr 
4337			 
4337					 
4337 e1					pop hl    ; get malloc so we can push it 
4338 e5					push hl   ; save so we can free it afterwards 
4339			 
4339 cd 8d 1c				call forth_push_str 
433c			 
433c e1					pop hl 
433d cd 3e 13				call free 
4340			 
4340					 
4340					 
4340			 
4340			 
4340					NEXTW 
4340 c3 cc 1f			jp macro_next 
4343				endm 
# End of macro NEXTW
4343			 
4343			.LEFT: 
4343				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4343 48				db WORD_SYS_CORE+52             
4344 6b 43			dw .RIGHT            
4346 05				db 4 + 1 
4347 .. 00			db "LEFT",0              
434c				endm 
# End of macro CWHEAD
434c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
434c					if DEBUG_FORTH_WORDS_KEY 
434c						DMARK "LEF" 
434c f5				push af  
434d 3a 61 43			ld a, (.dmark)  
4350 32 71 ee			ld (debug_mark),a  
4353 3a 62 43			ld a, (.dmark+1)  
4356 32 72 ee			ld (debug_mark+1),a  
4359 3a 63 43			ld a, (.dmark+2)  
435c 32 73 ee			ld (debug_mark+2),a  
435f 18 03			jr .pastdmark  
4361 ..			.dmark: db "LEF"  
4364 f1			.pastdmark: pop af  
4365			endm  
# End of macro DMARK
4365						CALLMONITOR 
4365 cd ae 15			call break_point_state  
4368				endm  
# End of macro CALLMONITOR
4368					endif 
4368			 
4368					NEXTW 
4368 c3 cc 1f			jp macro_next 
436b				endm 
# End of macro NEXTW
436b			.RIGHT: 
436b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
436b 48				db WORD_SYS_CORE+52             
436c 94 43			dw .STR2NUM            
436e 06				db 5 + 1 
436f .. 00			db "RIGHT",0              
4375				endm 
# End of macro CWHEAD
4375			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4375					if DEBUG_FORTH_WORDS_KEY 
4375						DMARK "RIG" 
4375 f5				push af  
4376 3a 8a 43			ld a, (.dmark)  
4379 32 71 ee			ld (debug_mark),a  
437c 3a 8b 43			ld a, (.dmark+1)  
437f 32 72 ee			ld (debug_mark+1),a  
4382 3a 8c 43			ld a, (.dmark+2)  
4385 32 73 ee			ld (debug_mark+2),a  
4388 18 03			jr .pastdmark  
438a ..			.dmark: db "RIG"  
438d f1			.pastdmark: pop af  
438e			endm  
# End of macro DMARK
438e						CALLMONITOR 
438e cd ae 15			call break_point_state  
4391				endm  
# End of macro CALLMONITOR
4391					endif 
4391			 
4391					NEXTW 
4391 c3 cc 1f			jp macro_next 
4394				endm 
# End of macro NEXTW
4394			 
4394			 
4394			.STR2NUM: 
4394				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4394 48				db WORD_SYS_CORE+52             
4395 20 44			dw .NUM2STR            
4397 08				db 7 + 1 
4398 .. 00			db "STR2NUM",0              
43a0				endm 
# End of macro CWHEAD
43a0			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
43a0			 
43a0			 
43a0			; TODO STR type check to do 
43a0					if DEBUG_FORTH_WORDS_KEY 
43a0						DMARK "S2N" 
43a0 f5				push af  
43a1 3a b5 43			ld a, (.dmark)  
43a4 32 71 ee			ld (debug_mark),a  
43a7 3a b6 43			ld a, (.dmark+1)  
43aa 32 72 ee			ld (debug_mark+1),a  
43ad 3a b7 43			ld a, (.dmark+2)  
43b0 32 73 ee			ld (debug_mark+2),a  
43b3 18 03			jr .pastdmark  
43b5 ..			.dmark: db "S2N"  
43b8 f1			.pastdmark: pop af  
43b9			endm  
# End of macro DMARK
43b9						CALLMONITOR 
43b9 cd ae 15			call break_point_state  
43bc				endm  
# End of macro CALLMONITOR
43bc					endif 
43bc			 
43bc					;FORTH_DSP 
43bc					FORTH_DSP_VALUE 
43bc cd ff 1d			call macro_forth_dsp_value 
43bf				endm 
# End of macro FORTH_DSP_VALUE
43bf					;inc hl 
43bf			 
43bf eb					ex de, hl 
43c0					if DEBUG_FORTH_WORDS 
43c0						DMARK "S2a" 
43c0 f5				push af  
43c1 3a d5 43			ld a, (.dmark)  
43c4 32 71 ee			ld (debug_mark),a  
43c7 3a d6 43			ld a, (.dmark+1)  
43ca 32 72 ee			ld (debug_mark+1),a  
43cd 3a d7 43			ld a, (.dmark+2)  
43d0 32 73 ee			ld (debug_mark+2),a  
43d3 18 03			jr .pastdmark  
43d5 ..			.dmark: db "S2a"  
43d8 f1			.pastdmark: pop af  
43d9			endm  
# End of macro DMARK
43d9						CALLMONITOR 
43d9 cd ae 15			call break_point_state  
43dc				endm  
# End of macro CALLMONITOR
43dc					endif 
43dc cd a2 11				call string_to_uint16 
43df			 
43df					if DEBUG_FORTH_WORDS 
43df						DMARK "S2b" 
43df f5				push af  
43e0 3a f4 43			ld a, (.dmark)  
43e3 32 71 ee			ld (debug_mark),a  
43e6 3a f5 43			ld a, (.dmark+1)  
43e9 32 72 ee			ld (debug_mark+1),a  
43ec 3a f6 43			ld a, (.dmark+2)  
43ef 32 73 ee			ld (debug_mark+2),a  
43f2 18 03			jr .pastdmark  
43f4 ..			.dmark: db "S2b"  
43f7 f1			.pastdmark: pop af  
43f8			endm  
# End of macro DMARK
43f8						CALLMONITOR 
43f8 cd ae 15			call break_point_state  
43fb				endm  
# End of macro CALLMONITOR
43fb					endif 
43fb			;		push hl 
43fb					FORTH_DSP_POP 
43fb cd ce 1e			call macro_forth_dsp_pop 
43fe				endm 
# End of macro FORTH_DSP_POP
43fe			;		pop hl 
43fe					 
43fe					if DEBUG_FORTH_WORDS 
43fe						DMARK "S2b" 
43fe f5				push af  
43ff 3a 13 44			ld a, (.dmark)  
4402 32 71 ee			ld (debug_mark),a  
4405 3a 14 44			ld a, (.dmark+1)  
4408 32 72 ee			ld (debug_mark+1),a  
440b 3a 15 44			ld a, (.dmark+2)  
440e 32 73 ee			ld (debug_mark+2),a  
4411 18 03			jr .pastdmark  
4413 ..			.dmark: db "S2b"  
4416 f1			.pastdmark: pop af  
4417			endm  
# End of macro DMARK
4417						CALLMONITOR 
4417 cd ae 15			call break_point_state  
441a				endm  
# End of macro CALLMONITOR
441a					endif 
441a cd 1f 1c				call forth_push_numhl	 
441d			 
441d				 
441d				       NEXTW 
441d c3 cc 1f			jp macro_next 
4420				endm 
# End of macro NEXTW
4420			.NUM2STR: 
4420				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4420 48				db WORD_SYS_CORE+52             
4421 2f 44			dw .CONCAT            
4423 08				db 7 + 1 
4424 .. 00			db "NUM2STR",0              
442c				endm 
# End of macro CWHEAD
442c			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
442c			 
442c			;		; malloc a string to target 
442c			;		ld hl, 10     ; TODO max string size should be fine 
442c			;		call malloc 
442c			;		push hl    ; save malloc location 
442c			; 
442c			; 
442c			;; TODO check int type 
442c			;		FORTH_DSP_VALUEHL 
442c			;		ld a, l 
442c			;		call DispAToASCII   
442c			;;TODO need to chage above call to dump into string 
442c			; 
442c			; 
442c			 
442c				       NEXTW 
442c c3 cc 1f			jp macro_next 
442f				endm 
# End of macro NEXTW
442f			 
442f			.CONCAT: 
442f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
442f 48				db WORD_SYS_CORE+52             
4430 e2 44			dw .FIND            
4432 07				db 6 + 1 
4433 .. 00			db "CONCAT",0              
443a				endm 
# End of macro CWHEAD
443a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
443a			 
443a			; TODO check string type 
443a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
443a			 
443a					if DEBUG_FORTH_WORDS_KEY 
443a						DMARK "CON" 
443a f5				push af  
443b 3a 4f 44			ld a, (.dmark)  
443e 32 71 ee			ld (debug_mark),a  
4441 3a 50 44			ld a, (.dmark+1)  
4444 32 72 ee			ld (debug_mark+1),a  
4447 3a 51 44			ld a, (.dmark+2)  
444a 32 73 ee			ld (debug_mark+2),a  
444d 18 03			jr .pastdmark  
444f ..			.dmark: db "CON"  
4452 f1			.pastdmark: pop af  
4453			endm  
# End of macro DMARK
4453						CALLMONITOR 
4453 cd ae 15			call break_point_state  
4456				endm  
# End of macro CALLMONITOR
4456					endif 
4456			 
4456			 
4456					FORTH_DSP_VALUE 
4456 cd ff 1d			call macro_forth_dsp_value 
4459				endm 
# End of macro FORTH_DSP_VALUE
4459 e5					push hl   ; s2 
445a			 
445a					FORTH_DSP_POP 
445a cd ce 1e			call macro_forth_dsp_pop 
445d				endm 
# End of macro FORTH_DSP_POP
445d			 
445d					FORTH_DSP_VALUE 
445d cd ff 1d			call macro_forth_dsp_value 
4460				endm 
# End of macro FORTH_DSP_VALUE
4460			 
4460 e5					push hl   ; s1 
4461			 
4461					FORTH_DSP_POP 
4461 cd ce 1e			call macro_forth_dsp_pop 
4464				endm 
# End of macro FORTH_DSP_POP
4464					 
4464			 
4464					; copy s1 
4464			 
4464				 
4464					; save ptr 
4464 e1					pop hl  
4465 e5					push hl 
4466 3e 00				ld a, 0 
4468 cd 16 12				call strlent 
446b					;inc hl    ; zer0 
446b 06 00				ld b, 0 
446d 4d					ld c, l 
446e e1					pop hl		 
446f 11 cb e2				ld de, scratch	 
4472					if DEBUG_FORTH_WORDS 
4472						DMARK "CO1" 
4472 f5				push af  
4473 3a 87 44			ld a, (.dmark)  
4476 32 71 ee			ld (debug_mark),a  
4479 3a 88 44			ld a, (.dmark+1)  
447c 32 72 ee			ld (debug_mark+1),a  
447f 3a 89 44			ld a, (.dmark+2)  
4482 32 73 ee			ld (debug_mark+2),a  
4485 18 03			jr .pastdmark  
4487 ..			.dmark: db "CO1"  
448a f1			.pastdmark: pop af  
448b			endm  
# End of macro DMARK
448b						CALLMONITOR 
448b cd ae 15			call break_point_state  
448e				endm  
# End of macro CALLMONITOR
448e					endif 
448e ed b0				ldir 
4490			 
4490 e1					pop hl 
4491 e5					push hl 
4492 d5					push de 
4493			 
4493			 
4493 3e 00				ld a, 0 
4495 cd 16 12				call strlent 
4498 23					inc hl    ; zer0 
4499 23					inc hl 
449a 06 00				ld b, 0 
449c 4d					ld c, l 
449d d1					pop de 
449e e1					pop hl		 
449f					if DEBUG_FORTH_WORDS 
449f						DMARK "CO2" 
449f f5				push af  
44a0 3a b4 44			ld a, (.dmark)  
44a3 32 71 ee			ld (debug_mark),a  
44a6 3a b5 44			ld a, (.dmark+1)  
44a9 32 72 ee			ld (debug_mark+1),a  
44ac 3a b6 44			ld a, (.dmark+2)  
44af 32 73 ee			ld (debug_mark+2),a  
44b2 18 03			jr .pastdmark  
44b4 ..			.dmark: db "CO2"  
44b7 f1			.pastdmark: pop af  
44b8			endm  
# End of macro DMARK
44b8						CALLMONITOR 
44b8 cd ae 15			call break_point_state  
44bb				endm  
# End of macro CALLMONITOR
44bb					endif 
44bb ed b0				ldir 
44bd			 
44bd			 
44bd			 
44bd 21 cb e2				ld hl, scratch 
44c0					if DEBUG_FORTH_WORDS 
44c0						DMARK "CO5" 
44c0 f5				push af  
44c1 3a d5 44			ld a, (.dmark)  
44c4 32 71 ee			ld (debug_mark),a  
44c7 3a d6 44			ld a, (.dmark+1)  
44ca 32 72 ee			ld (debug_mark+1),a  
44cd 3a d7 44			ld a, (.dmark+2)  
44d0 32 73 ee			ld (debug_mark+2),a  
44d3 18 03			jr .pastdmark  
44d5 ..			.dmark: db "CO5"  
44d8 f1			.pastdmark: pop af  
44d9			endm  
# End of macro DMARK
44d9						CALLMONITOR 
44d9 cd ae 15			call break_point_state  
44dc				endm  
# End of macro CALLMONITOR
44dc					endif 
44dc			 
44dc cd 8d 1c				call forth_push_str 
44df			 
44df			 
44df			 
44df			 
44df				       NEXTW 
44df c3 cc 1f			jp macro_next 
44e2				endm 
# End of macro NEXTW
44e2			 
44e2			 
44e2			.FIND: 
44e2				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
44e2 4b				db WORD_SYS_CORE+55             
44e3 a0 45			dw .LEN            
44e5 05				db 4 + 1 
44e6 .. 00			db "FIND",0              
44eb				endm 
# End of macro CWHEAD
44eb			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
44eb			 
44eb					if DEBUG_FORTH_WORDS_KEY 
44eb						DMARK "FND" 
44eb f5				push af  
44ec 3a 00 45			ld a, (.dmark)  
44ef 32 71 ee			ld (debug_mark),a  
44f2 3a 01 45			ld a, (.dmark+1)  
44f5 32 72 ee			ld (debug_mark+1),a  
44f8 3a 02 45			ld a, (.dmark+2)  
44fb 32 73 ee			ld (debug_mark+2),a  
44fe 18 03			jr .pastdmark  
4500 ..			.dmark: db "FND"  
4503 f1			.pastdmark: pop af  
4504			endm  
# End of macro DMARK
4504						CALLMONITOR 
4504 cd ae 15			call break_point_state  
4507				endm  
# End of macro CALLMONITOR
4507					endif 
4507			 
4507			; TODO check string type 
4507					FORTH_DSP_VALUE 
4507 cd ff 1d			call macro_forth_dsp_value 
450a				endm 
# End of macro FORTH_DSP_VALUE
450a			 
450a e5					push hl    
450b 7e					ld a,(hl)    ; char to find   
450c			; TODO change char to substr 
450c			 
450c f5					push af 
450d					 
450d			 
450d			 
450d					if DEBUG_FORTH_WORDS 
450d						DMARK "FN1" 
450d f5				push af  
450e 3a 22 45			ld a, (.dmark)  
4511 32 71 ee			ld (debug_mark),a  
4514 3a 23 45			ld a, (.dmark+1)  
4517 32 72 ee			ld (debug_mark+1),a  
451a 3a 24 45			ld a, (.dmark+2)  
451d 32 73 ee			ld (debug_mark+2),a  
4520 18 03			jr .pastdmark  
4522 ..			.dmark: db "FN1"  
4525 f1			.pastdmark: pop af  
4526			endm  
# End of macro DMARK
4526						CALLMONITOR 
4526 cd ae 15			call break_point_state  
4529				endm  
# End of macro CALLMONITOR
4529					endif 
4529			 
4529					FORTH_DSP_POP 
4529 cd ce 1e			call macro_forth_dsp_pop 
452c				endm 
# End of macro FORTH_DSP_POP
452c			 
452c					; string to search 
452c			 
452c					FORTH_DSP_VALUE 
452c cd ff 1d			call macro_forth_dsp_value 
452f				endm 
# End of macro FORTH_DSP_VALUE
452f			 
452f d1					pop de  ; d is char to find  
4530			 
4530					if DEBUG_FORTH_WORDS 
4530						DMARK "FN2" 
4530 f5				push af  
4531 3a 45 45			ld a, (.dmark)  
4534 32 71 ee			ld (debug_mark),a  
4537 3a 46 45			ld a, (.dmark+1)  
453a 32 72 ee			ld (debug_mark+1),a  
453d 3a 47 45			ld a, (.dmark+2)  
4540 32 73 ee			ld (debug_mark+2),a  
4543 18 03			jr .pastdmark  
4545 ..			.dmark: db "FN2"  
4548 f1			.pastdmark: pop af  
4549			endm  
# End of macro DMARK
4549						CALLMONITOR 
4549 cd ae 15			call break_point_state  
454c				endm  
# End of macro CALLMONITOR
454c					endif 
454c					 
454c 01 00 00				ld bc, 0 
454f 7e			.findchar:      ld a,(hl) 
4550 fe 00				cp 0   		 
4552 28 27				jr z, .finddone     
4554 ba					cp d 
4555 28 20				jr z, .foundchar 
4557 03					inc bc 
4558 23					inc hl 
4559					if DEBUG_FORTH_WORDS 
4559						DMARK "FN3" 
4559 f5				push af  
455a 3a 6e 45			ld a, (.dmark)  
455d 32 71 ee			ld (debug_mark),a  
4560 3a 6f 45			ld a, (.dmark+1)  
4563 32 72 ee			ld (debug_mark+1),a  
4566 3a 70 45			ld a, (.dmark+2)  
4569 32 73 ee			ld (debug_mark+2),a  
456c 18 03			jr .pastdmark  
456e ..			.dmark: db "FN3"  
4571 f1			.pastdmark: pop af  
4572			endm  
# End of macro DMARK
4572						CALLMONITOR 
4572 cd ae 15			call break_point_state  
4575				endm  
# End of macro CALLMONITOR
4575					endif 
4575 18 d8				jr .findchar 
4577			 
4577			 
4577 c5			.foundchar:	push bc 
4578 e1					pop hl 
4579 18 03				jr .findexit 
457b			 
457b			 
457b							 
457b			 
457b			.finddone:     ; got to end of string with no find 
457b 21 00 00				ld hl, 0 
457e			.findexit: 
457e			 
457e					if DEBUG_FORTH_WORDS 
457e						DMARK "FNd" 
457e f5				push af  
457f 3a 93 45			ld a, (.dmark)  
4582 32 71 ee			ld (debug_mark),a  
4585 3a 94 45			ld a, (.dmark+1)  
4588 32 72 ee			ld (debug_mark+1),a  
458b 3a 95 45			ld a, (.dmark+2)  
458e 32 73 ee			ld (debug_mark+2),a  
4591 18 03			jr .pastdmark  
4593 ..			.dmark: db "FNd"  
4596 f1			.pastdmark: pop af  
4597			endm  
# End of macro DMARK
4597						CALLMONITOR 
4597 cd ae 15			call break_point_state  
459a				endm  
# End of macro CALLMONITOR
459a					endif 
459a cd 1f 1c			call forth_push_numhl 
459d			 
459d				       NEXTW 
459d c3 cc 1f			jp macro_next 
45a0				endm 
# End of macro NEXTW
45a0			 
45a0			.LEN: 
45a0				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
45a0 4c				db WORD_SYS_CORE+56             
45a1 0a 46			dw .ASC            
45a3 06				db 5 + 1 
45a4 .. 00			db "COUNT",0              
45aa				endm 
# End of macro CWHEAD
45aa			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
45aa			 
45aa					if DEBUG_FORTH_WORDS_KEY 
45aa						DMARK "CNT" 
45aa f5				push af  
45ab 3a bf 45			ld a, (.dmark)  
45ae 32 71 ee			ld (debug_mark),a  
45b1 3a c0 45			ld a, (.dmark+1)  
45b4 32 72 ee			ld (debug_mark+1),a  
45b7 3a c1 45			ld a, (.dmark+2)  
45ba 32 73 ee			ld (debug_mark+2),a  
45bd 18 03			jr .pastdmark  
45bf ..			.dmark: db "CNT"  
45c2 f1			.pastdmark: pop af  
45c3			endm  
# End of macro DMARK
45c3						CALLMONITOR 
45c3 cd ae 15			call break_point_state  
45c6				endm  
# End of macro CALLMONITOR
45c6					endif 
45c6			; TODO check string type 
45c6					FORTH_DSP_VALUE 
45c6 cd ff 1d			call macro_forth_dsp_value 
45c9				endm 
# End of macro FORTH_DSP_VALUE
45c9			 
45c9			 
45c9					if DEBUG_FORTH_WORDS 
45c9						DMARK "CN?" 
45c9 f5				push af  
45ca 3a de 45			ld a, (.dmark)  
45cd 32 71 ee			ld (debug_mark),a  
45d0 3a df 45			ld a, (.dmark+1)  
45d3 32 72 ee			ld (debug_mark+1),a  
45d6 3a e0 45			ld a, (.dmark+2)  
45d9 32 73 ee			ld (debug_mark+2),a  
45dc 18 03			jr .pastdmark  
45de ..			.dmark: db "CN?"  
45e1 f1			.pastdmark: pop af  
45e2			endm  
# End of macro DMARK
45e2						CALLMONITOR 
45e2 cd ae 15			call break_point_state  
45e5				endm  
# End of macro CALLMONITOR
45e5					endif 
45e5 cd 0b 12				call strlenz 
45e8					if DEBUG_FORTH_WORDS 
45e8						DMARK "CNl" 
45e8 f5				push af  
45e9 3a fd 45			ld a, (.dmark)  
45ec 32 71 ee			ld (debug_mark),a  
45ef 3a fe 45			ld a, (.dmark+1)  
45f2 32 72 ee			ld (debug_mark+1),a  
45f5 3a ff 45			ld a, (.dmark+2)  
45f8 32 73 ee			ld (debug_mark+2),a  
45fb 18 03			jr .pastdmark  
45fd ..			.dmark: db "CNl"  
4600 f1			.pastdmark: pop af  
4601			endm  
# End of macro DMARK
4601						CALLMONITOR 
4601 cd ae 15			call break_point_state  
4604				endm  
# End of macro CALLMONITOR
4604					endif 
4604			 
4604 cd 1f 1c				call forth_push_numhl 
4607			 
4607			 
4607			 
4607				       NEXTW 
4607 c3 cc 1f			jp macro_next 
460a				endm 
# End of macro NEXTW
460a			.ASC: 
460a				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
460a 4d				db WORD_SYS_CORE+57             
460b 78 46			dw .CHR            
460d 04				db 3 + 1 
460e .. 00			db "ASC",0              
4612				endm 
# End of macro CWHEAD
4612			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4612					if DEBUG_FORTH_WORDS_KEY 
4612						DMARK "ASC" 
4612 f5				push af  
4613 3a 27 46			ld a, (.dmark)  
4616 32 71 ee			ld (debug_mark),a  
4619 3a 28 46			ld a, (.dmark+1)  
461c 32 72 ee			ld (debug_mark+1),a  
461f 3a 29 46			ld a, (.dmark+2)  
4622 32 73 ee			ld (debug_mark+2),a  
4625 18 03			jr .pastdmark  
4627 ..			.dmark: db "ASC"  
462a f1			.pastdmark: pop af  
462b			endm  
# End of macro DMARK
462b						CALLMONITOR 
462b cd ae 15			call break_point_state  
462e				endm  
# End of macro CALLMONITOR
462e					endif 
462e					FORTH_DSP_VALUE 
462e cd ff 1d			call macro_forth_dsp_value 
4631				endm 
# End of macro FORTH_DSP_VALUE
4631					;v5 FORTH_DSP_VALUE 
4631			;		inc hl      ; now at start of numeric as string 
4631			 
4631 e5					push hl 
4632			 
4632					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4632 cd ce 1e			call macro_forth_dsp_pop 
4635				endm 
# End of macro FORTH_DSP_POP
4635			 
4635 e1					pop hl 
4636			 
4636					if DEBUG_FORTH_WORDS 
4636						DMARK "AS1" 
4636 f5				push af  
4637 3a 4b 46			ld a, (.dmark)  
463a 32 71 ee			ld (debug_mark),a  
463d 3a 4c 46			ld a, (.dmark+1)  
4640 32 72 ee			ld (debug_mark+1),a  
4643 3a 4d 46			ld a, (.dmark+2)  
4646 32 73 ee			ld (debug_mark+2),a  
4649 18 03			jr .pastdmark  
464b ..			.dmark: db "AS1"  
464e f1			.pastdmark: pop af  
464f			endm  
# End of macro DMARK
464f						CALLMONITOR 
464f cd ae 15			call break_point_state  
4652				endm  
# End of macro CALLMONITOR
4652					endif 
4652					; push the content of a onto the stack as a value 
4652			 
4652 7e					ld a,(hl)   ; get char 
4653 26 00				ld h,0 
4655 6f					ld l,a 
4656					if DEBUG_FORTH_WORDS 
4656						DMARK "AS2" 
4656 f5				push af  
4657 3a 6b 46			ld a, (.dmark)  
465a 32 71 ee			ld (debug_mark),a  
465d 3a 6c 46			ld a, (.dmark+1)  
4660 32 72 ee			ld (debug_mark+1),a  
4663 3a 6d 46			ld a, (.dmark+2)  
4666 32 73 ee			ld (debug_mark+2),a  
4669 18 03			jr .pastdmark  
466b ..			.dmark: db "AS2"  
466e f1			.pastdmark: pop af  
466f			endm  
# End of macro DMARK
466f						CALLMONITOR 
466f cd ae 15			call break_point_state  
4672				endm  
# End of macro CALLMONITOR
4672					endif 
4672 cd 1f 1c				call forth_push_numhl 
4675			 
4675				       NEXTW 
4675 c3 cc 1f			jp macro_next 
4678				endm 
# End of macro NEXTW
4678			 
4678			.CHR: 
4678				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4678 4d				db WORD_SYS_CORE+57             
4679 b4 46			dw .ENDSTR            
467b 04				db 3 + 1 
467c .. 00			db "CHR",0              
4680				endm 
# End of macro CWHEAD
4680			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4680					if DEBUG_FORTH_WORDS_KEY 
4680						DMARK "CHR" 
4680 f5				push af  
4681 3a 95 46			ld a, (.dmark)  
4684 32 71 ee			ld (debug_mark),a  
4687 3a 96 46			ld a, (.dmark+1)  
468a 32 72 ee			ld (debug_mark+1),a  
468d 3a 97 46			ld a, (.dmark+2)  
4690 32 73 ee			ld (debug_mark+2),a  
4693 18 03			jr .pastdmark  
4695 ..			.dmark: db "CHR"  
4698 f1			.pastdmark: pop af  
4699			endm  
# End of macro DMARK
4699						CALLMONITOR 
4699 cd ae 15			call break_point_state  
469c				endm  
# End of macro CALLMONITOR
469c					endif 
469c					FORTH_DSP_VALUEHL 
469c cd 16 1e			call macro_dsp_valuehl 
469f				endm 
# End of macro FORTH_DSP_VALUEHL
469f			 
469f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
469f cd ce 1e			call macro_forth_dsp_pop 
46a2				endm 
# End of macro FORTH_DSP_POP
46a2			 
46a2					; save asci byte as a zero term string and push string 
46a2			 
46a2 7d					ld a,l 
46a3 32 cb e2				ld (scratch), a 
46a6			 
46a6 3e 00				ld a, 0 
46a8 32 cc e2				ld (scratch+1), a 
46ab			 
46ab 21 cb e2				ld hl, scratch 
46ae cd 8d 1c				call forth_push_str 
46b1			 
46b1			 
46b1				       NEXTW 
46b1 c3 cc 1f			jp macro_next 
46b4				endm 
# End of macro NEXTW
46b4			 
46b4			 
46b4			 
46b4			 
46b4			.ENDSTR: 
46b4			; eof 
46b4			 
# End of file forth_words_str.asm
46b4			include "forth_words_key.asm" 
46b4			 
46b4			; | ## Keyboard Words 
46b4			 
46b4			.KEY: 
46b4				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
46b4 3e				db WORD_SYS_CORE+42             
46b5 e4 46			dw .WAITK            
46b7 04				db 3 + 1 
46b8 .. 00			db "KEY",0              
46bc				endm 
# End of macro CWHEAD
46bc			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
46bc			 
46bc					if DEBUG_FORTH_WORDS_KEY 
46bc						DMARK "KEY" 
46bc f5				push af  
46bd 3a d1 46			ld a, (.dmark)  
46c0 32 71 ee			ld (debug_mark),a  
46c3 3a d2 46			ld a, (.dmark+1)  
46c6 32 72 ee			ld (debug_mark+1),a  
46c9 3a d3 46			ld a, (.dmark+2)  
46cc 32 73 ee			ld (debug_mark+2),a  
46cf 18 03			jr .pastdmark  
46d1 ..			.dmark: db "KEY"  
46d4 f1			.pastdmark: pop af  
46d5			endm  
# End of macro DMARK
46d5						CALLMONITOR 
46d5 cd ae 15			call break_point_state  
46d8				endm  
# End of macro CALLMONITOR
46d8					endif 
46d8			; TODO currently waits 
46d8 cd 19 64				call cin 
46db					;call cin_wait 
46db 6f					ld l, a 
46dc 26 00				ld h, 0 
46de cd 1f 1c				call forth_push_numhl 
46e1					NEXTW 
46e1 c3 cc 1f			jp macro_next 
46e4				endm 
# End of macro NEXTW
46e4			.WAITK: 
46e4				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
46e4 3f				db WORD_SYS_CORE+43             
46e5 16 47			dw .ACCEPT            
46e7 06				db 5 + 1 
46e8 .. 00			db "WAITK",0              
46ee				endm 
# End of macro CWHEAD
46ee			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
46ee					if DEBUG_FORTH_WORDS_KEY 
46ee						DMARK "WAI" 
46ee f5				push af  
46ef 3a 03 47			ld a, (.dmark)  
46f2 32 71 ee			ld (debug_mark),a  
46f5 3a 04 47			ld a, (.dmark+1)  
46f8 32 72 ee			ld (debug_mark+1),a  
46fb 3a 05 47			ld a, (.dmark+2)  
46fe 32 73 ee			ld (debug_mark+2),a  
4701 18 03			jr .pastdmark  
4703 ..			.dmark: db "WAI"  
4706 f1			.pastdmark: pop af  
4707			endm  
# End of macro DMARK
4707						CALLMONITOR 
4707 cd ae 15			call break_point_state  
470a				endm  
# End of macro CALLMONITOR
470a					endif 
470a cd 11 64				call cin_wait 
470d 6f					ld l, a 
470e 26 00				ld h, 0 
4710 cd 1f 1c				call forth_push_numhl 
4713					NEXTW 
4713 c3 cc 1f			jp macro_next 
4716				endm 
# End of macro NEXTW
4716			.ACCEPT: 
4716				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4716 40				db WORD_SYS_CORE+44             
4717 74 47			dw .EDIT            
4719 07				db 6 + 1 
471a .. 00			db "ACCEPT",0              
4721				endm 
# End of macro CWHEAD
4721			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4721					; TODO crashes on push 
4721					if DEBUG_FORTH_WORDS_KEY 
4721						DMARK "ACC" 
4721 f5				push af  
4722 3a 36 47			ld a, (.dmark)  
4725 32 71 ee			ld (debug_mark),a  
4728 3a 37 47			ld a, (.dmark+1)  
472b 32 72 ee			ld (debug_mark+1),a  
472e 3a 38 47			ld a, (.dmark+2)  
4731 32 73 ee			ld (debug_mark+2),a  
4734 18 03			jr .pastdmark  
4736 ..			.dmark: db "ACC"  
4739 f1			.pastdmark: pop af  
473a			endm  
# End of macro DMARK
473a						CALLMONITOR 
473a cd ae 15			call break_point_state  
473d				endm  
# End of macro CALLMONITOR
473d					endif 
473d 21 c9 e4				ld hl, os_input 
4740 3e 00				ld a, 0 
4742 77					ld (hl),a 
4743 3a 68 ea				ld a,(f_cursor_ptr) 
4746 16 64				ld d, 100 
4748 0e 00				ld c, 0 
474a 1e 28				ld e, 40 
474c cd da 0d				call input_str 
474f					; TODO perhaps do a type check and wrap in quotes if not a number 
474f 21 c9 e4				ld hl, os_input 
4752					if DEBUG_FORTH_WORDS 
4752						DMARK "AC1" 
4752 f5				push af  
4753 3a 67 47			ld a, (.dmark)  
4756 32 71 ee			ld (debug_mark),a  
4759 3a 68 47			ld a, (.dmark+1)  
475c 32 72 ee			ld (debug_mark+1),a  
475f 3a 69 47			ld a, (.dmark+2)  
4762 32 73 ee			ld (debug_mark+2),a  
4765 18 03			jr .pastdmark  
4767 ..			.dmark: db "AC1"  
476a f1			.pastdmark: pop af  
476b			endm  
# End of macro DMARK
476b						CALLMONITOR 
476b cd ae 15			call break_point_state  
476e				endm  
# End of macro CALLMONITOR
476e					endif 
476e cd 8d 1c				call forth_push_str 
4771					NEXTW 
4771 c3 cc 1f			jp macro_next 
4774				endm 
# End of macro NEXTW
4774			 
4774			.EDIT: 
4774				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4774 40				db WORD_SYS_CORE+44             
4775 16 48			dw .DEDIT            
4777 05				db 4 + 1 
4778 .. 00			db "EDIT",0              
477d				endm 
# End of macro CWHEAD
477d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
477d			 
477d					; TODO does not copy from stack 
477d					if DEBUG_FORTH_WORDS_KEY 
477d						DMARK "EDT" 
477d f5				push af  
477e 3a 92 47			ld a, (.dmark)  
4781 32 71 ee			ld (debug_mark),a  
4784 3a 93 47			ld a, (.dmark+1)  
4787 32 72 ee			ld (debug_mark+1),a  
478a 3a 94 47			ld a, (.dmark+2)  
478d 32 73 ee			ld (debug_mark+2),a  
4790 18 03			jr .pastdmark  
4792 ..			.dmark: db "EDT"  
4795 f1			.pastdmark: pop af  
4796			endm  
# End of macro DMARK
4796						CALLMONITOR 
4796 cd ae 15			call break_point_state  
4799				endm  
# End of macro CALLMONITOR
4799					endif 
4799			 
4799					;FORTH_DSP 
4799					FORTH_DSP_VALUEHL 
4799 cd 16 1e			call macro_dsp_valuehl 
479c				endm 
# End of macro FORTH_DSP_VALUEHL
479c			;		inc hl    ; TODO do type check 
479c			 
479c			;		call get_word_hl 
479c e5					push hl 
479d					if DEBUG_FORTH_WORDS 
479d						DMARK "EDp" 
479d f5				push af  
479e 3a b2 47			ld a, (.dmark)  
47a1 32 71 ee			ld (debug_mark),a  
47a4 3a b3 47			ld a, (.dmark+1)  
47a7 32 72 ee			ld (debug_mark+1),a  
47aa 3a b4 47			ld a, (.dmark+2)  
47ad 32 73 ee			ld (debug_mark+2),a  
47b0 18 03			jr .pastdmark  
47b2 ..			.dmark: db "EDp"  
47b5 f1			.pastdmark: pop af  
47b6			endm  
# End of macro DMARK
47b6						CALLMONITOR 
47b6 cd ae 15			call break_point_state  
47b9				endm  
# End of macro CALLMONITOR
47b9					endif 
47b9				;	ld a, 0 
47b9 cd 0b 12				call strlenz 
47bc 23					inc hl 
47bd			 
47bd 06 00				ld b, 0 
47bf 4d					ld c, l 
47c0			 
47c0 e1					pop hl 
47c1 11 c9 e4				ld de, os_input 
47c4					if DEBUG_FORTH_WORDS_KEY 
47c4						DMARK "EDc" 
47c4 f5				push af  
47c5 3a d9 47			ld a, (.dmark)  
47c8 32 71 ee			ld (debug_mark),a  
47cb 3a da 47			ld a, (.dmark+1)  
47ce 32 72 ee			ld (debug_mark+1),a  
47d1 3a db 47			ld a, (.dmark+2)  
47d4 32 73 ee			ld (debug_mark+2),a  
47d7 18 03			jr .pastdmark  
47d9 ..			.dmark: db "EDc"  
47dc f1			.pastdmark: pop af  
47dd			endm  
# End of macro DMARK
47dd						CALLMONITOR 
47dd cd ae 15			call break_point_state  
47e0				endm  
# End of macro CALLMONITOR
47e0					endif 
47e0 ed b0				ldir 
47e2			 
47e2			 
47e2 21 c9 e4				ld hl, os_input 
47e5					;ld a, 0 
47e5					;ld (hl),a 
47e5 3a 68 ea				ld a,(f_cursor_ptr) 
47e8 16 64				ld d, 100 
47ea 0e 00				ld c, 0 
47ec 1e 28				ld e, 40 
47ee cd da 0d				call input_str 
47f1					; TODO perhaps do a type check and wrap in quotes if not a number 
47f1 21 c9 e4				ld hl, os_input 
47f4					if DEBUG_FORTH_WORDS 
47f4						DMARK "ED1" 
47f4 f5				push af  
47f5 3a 09 48			ld a, (.dmark)  
47f8 32 71 ee			ld (debug_mark),a  
47fb 3a 0a 48			ld a, (.dmark+1)  
47fe 32 72 ee			ld (debug_mark+1),a  
4801 3a 0b 48			ld a, (.dmark+2)  
4804 32 73 ee			ld (debug_mark+2),a  
4807 18 03			jr .pastdmark  
4809 ..			.dmark: db "ED1"  
480c f1			.pastdmark: pop af  
480d			endm  
# End of macro DMARK
480d						CALLMONITOR 
480d cd ae 15			call break_point_state  
4810				endm  
# End of macro CALLMONITOR
4810					endif 
4810 cd 8d 1c				call forth_push_str 
4813					NEXTW 
4813 c3 cc 1f			jp macro_next 
4816				endm 
# End of macro NEXTW
4816			 
4816			.DEDIT: 
4816				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4816 40				db WORD_SYS_CORE+44             
4817 78 48			dw .ENDKEY            
4819 06				db 5 + 1 
481a .. 00			db "DEDIT",0              
4820				endm 
# End of macro CWHEAD
4820			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4820			 
4820					; TODO does not copy from stack 
4820					if DEBUG_FORTH_WORDS_KEY 
4820						DMARK "DED" 
4820 f5				push af  
4821 3a 35 48			ld a, (.dmark)  
4824 32 71 ee			ld (debug_mark),a  
4827 3a 36 48			ld a, (.dmark+1)  
482a 32 72 ee			ld (debug_mark+1),a  
482d 3a 37 48			ld a, (.dmark+2)  
4830 32 73 ee			ld (debug_mark+2),a  
4833 18 03			jr .pastdmark  
4835 ..			.dmark: db "DED"  
4838 f1			.pastdmark: pop af  
4839			endm  
# End of macro DMARK
4839						CALLMONITOR 
4839 cd ae 15			call break_point_state  
483c				endm  
# End of macro CALLMONITOR
483c					endif 
483c			 
483c					;FORTH_DSP 
483c					FORTH_DSP_VALUEHL 
483c cd 16 1e			call macro_dsp_valuehl 
483f				endm 
# End of macro FORTH_DSP_VALUEHL
483f			;		inc hl    ; TODO do type check 
483f			 
483f			;		call get_word_hl 
483f e5					push hl 
4840 e5					push hl 
4841					FORTH_DSP_POP 
4841 cd ce 1e			call macro_forth_dsp_pop 
4844				endm 
# End of macro FORTH_DSP_POP
4844 e1					pop hl 
4845					if DEBUG_FORTH_WORDS 
4845						DMARK "EDp" 
4845 f5				push af  
4846 3a 5a 48			ld a, (.dmark)  
4849 32 71 ee			ld (debug_mark),a  
484c 3a 5b 48			ld a, (.dmark+1)  
484f 32 72 ee			ld (debug_mark+1),a  
4852 3a 5c 48			ld a, (.dmark+2)  
4855 32 73 ee			ld (debug_mark+2),a  
4858 18 03			jr .pastdmark  
485a ..			.dmark: db "EDp"  
485d f1			.pastdmark: pop af  
485e			endm  
# End of macro DMARK
485e						CALLMONITOR 
485e cd ae 15			call break_point_state  
4861				endm  
# End of macro CALLMONITOR
4861					endif 
4861				;	ld a, 0 
4861 cd 0b 12				call strlenz 
4864 23					inc hl 
4865			 
4865 06 00				ld b, 0 
4867 4d					ld c, l 
4868			 
4868 e1					pop hl 
4869			 
4869					;ld a, 0 
4869					;ld (hl),a 
4869 3a 68 ea				ld a,(f_cursor_ptr) 
486c 16 64				ld d, 100 
486e 0e 00				ld c, 0 
4870 1e 28				ld e, 40 
4872 cd da 0d				call input_str 
4875					; TODO perhaps do a type check and wrap in quotes if not a number 
4875					NEXTW 
4875 c3 cc 1f			jp macro_next 
4878				endm 
# End of macro NEXTW
4878			 
4878			 
4878			.ENDKEY: 
4878			; eof 
4878			 
# End of file forth_words_key.asm
4878			include "forth_words_const.asm" 
4878			 
4878			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4878			 
4878			 
4878			.SPITIME: 
4878				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4878 77				db WORD_SYS_CORE+99             
4879 8d 48			dw .VA            
487b 08				db 7 + 1 
487c .. 00			db "SPITIME",0              
4884				endm 
# End of macro CWHEAD
4884			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4884			; 
4884			; | If using BANK devices then leave as is. 
4884			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4884			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4884			 
4884 21 6e ea				ld hl, spi_clktime  
4887 cd 1f 1c				call forth_push_numhl 
488a			 
488a					NEXTW 
488a c3 cc 1f			jp macro_next 
488d				endm 
# End of macro NEXTW
488d			 
488d			 
488d			.VA: 
488d				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
488d 77				db WORD_SYS_CORE+99             
488e 9d 48			dw .SYMBOL            
4890 03				db 2 + 1 
4891 .. 00			db "VA",0              
4894				endm 
# End of macro CWHEAD
4894			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4894 21 32 ea				ld hl, cli_var_array 
4897 cd 1f 1c				call forth_push_numhl 
489a			 
489a					NEXTW 
489a c3 cc 1f			jp macro_next 
489d				endm 
# End of macro NEXTW
489d			 
489d			.SYMBOL: 
489d				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
489d 77				db WORD_SYS_CORE+99             
489e d5 49			dw .ENDCONST            
48a0 07				db 6 + 1 
48a1 .. 00			db "SYMBOL",0              
48a8				endm 
# End of macro CWHEAD
48a8			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
48a8			; | 
48a8			; | The value is the number reference and the final address is pushed to stack 
48a8			 
48a8					if DEBUG_FORTH_WORDS_KEY 
48a8						DMARK "SYM" 
48a8 f5				push af  
48a9 3a bd 48			ld a, (.dmark)  
48ac 32 71 ee			ld (debug_mark),a  
48af 3a be 48			ld a, (.dmark+1)  
48b2 32 72 ee			ld (debug_mark+1),a  
48b5 3a bf 48			ld a, (.dmark+2)  
48b8 32 73 ee			ld (debug_mark+2),a  
48bb 18 03			jr .pastdmark  
48bd ..			.dmark: db "SYM"  
48c0 f1			.pastdmark: pop af  
48c1			endm  
# End of macro DMARK
48c1						CALLMONITOR 
48c1 cd ae 15			call break_point_state  
48c4				endm  
# End of macro CALLMONITOR
48c4					endif 
48c4			 
48c4					FORTH_DSP_VALUEHL 
48c4 cd 16 1e			call macro_dsp_valuehl 
48c7				endm 
# End of macro FORTH_DSP_VALUEHL
48c7			 
48c7 7d					ld a, l     
48c8			 
48c8			 
48c8					if DEBUG_FORTH_WORDS 
48c8						DMARK "SY1" 
48c8 f5				push af  
48c9 3a dd 48			ld a, (.dmark)  
48cc 32 71 ee			ld (debug_mark),a  
48cf 3a de 48			ld a, (.dmark+1)  
48d2 32 72 ee			ld (debug_mark+1),a  
48d5 3a df 48			ld a, (.dmark+2)  
48d8 32 73 ee			ld (debug_mark+2),a  
48db 18 03			jr .pastdmark  
48dd ..			.dmark: db "SY1"  
48e0 f1			.pastdmark: pop af  
48e1			endm  
# End of macro DMARK
48e1						CALLMONITOR 
48e1 cd ae 15			call break_point_state  
48e4				endm  
# End of macro CALLMONITOR
48e4					endif 
48e4					 
48e4 f5					push af	 
48e5					FORTH_DSP_POP 
48e5 cd ce 1e			call macro_forth_dsp_pop 
48e8				endm 
# End of macro FORTH_DSP_POP
48e8 f1					pop af 
48e9			 
48e9 cb 27				sla a  
48eb				 
48eb					 
48eb					if DEBUG_FORTH_WORDS 
48eb						DMARK "SY" 
48eb f5				push af  
48ec 3a 00 49			ld a, (.dmark)  
48ef 32 71 ee			ld (debug_mark),a  
48f2 3a 01 49			ld a, (.dmark+1)  
48f5 32 72 ee			ld (debug_mark+1),a  
48f8 3a 02 49			ld a, (.dmark+2)  
48fb 32 73 ee			ld (debug_mark+2),a  
48fe 18 02			jr .pastdmark  
4900 ..			.dmark: db "SY"  
4902 f1			.pastdmark: pop af  
4903			endm  
# End of macro DMARK
4903						CALLMONITOR 
4903 cd ae 15			call break_point_state  
4906				endm  
# End of macro CALLMONITOR
4906					endif 
4906			 
4906 21 15 49				ld hl, sym_table 
4909 cd ad 0d				call addatohl 
490c cd 4e 1f				call loadwordinhl 
490f cd 1f 1c				call forth_push_numhl 
4912			 
4912			 
4912				       NEXTW 
4912 c3 cc 1f			jp macro_next 
4915				endm 
# End of macro NEXTW
4915			 
4915			sym_table: 
4915			 
4915			; 0 
4915 46 ea		dw cli_autodisplay 
4917 54 ea		dw cli_buffer 
4919 f8 e9		dw cli_data_sp 
491b 32 e8		dw cli_data_stack 
491d 4e ea		dw cli_execword 
491f fa e9		dw cli_loop_sp 
4921 34 e9		dw cli_loop_stack 
4923 47 ea		dw cli_mvdot 
4925 4c ea		dw cli_nextword 
4927 48 ea		dw cli_origptr 
4929 52 ea		dw cli_origtoken 
492b			; 11 
492b 4a ea		dw cli_ptr 
492d fc e9		dw cli_ret_sp 
492f b6 e9		dw cli_ret_stack 
4931 50 ea		dw cli_token 
4933 32 ea		dw cli_var_array 
4935 ce eb		dw cursor_col 
4937 cc eb		dw cursor_ptr 
4939 cd eb		dw cursor_row 
493b ca eb		dw cursor_shape 
493d 71 ee		dw debug_mark 
493f			; 21 
493f b7 ed		dw display_fb0 
4941 16 ed		dw display_fb1 
4943 d4 eb		dw display_fb2 
4945 75 ec		dw display_fb3 
4947 d2 eb		dw display_fb_active 
4949 ca e3		dw execscratch 
494b 68 ea		dw f_cursor_ptr 
494d 75 ee		dw hardware_word 
494f 68 ee		dw input_at_cursor 
4951 6a ee		dw input_at_pos 
4953			; 31 
4953 66 ee		dw input_cur_flash 
4955 65 ee		dw input_cur_onoff 
4957 5b ee		dw input_cursor 
4959 6b ee		dw input_display_size 
495b 60 ee		dw input_len 
495d 6f ee		dw input_ptr 
495f 6c ee		dw input_size 
4961 6d ee		dw input_start 
4963 da 0d		dw input_str 
4965 69 ee		dw input_under_cursor 
4967			; 41 
4967 5a ee		dw key_actual_pressed 
4969 85 ee		dw key_fa 
496b 81 ee		dw key_face_held 
496d 84 ee		dw key_fb 
496f 83 ee		dw key_fc 
4971 82 ee		dw key_fd 
4973 8b ee		dw key_held 
4975 8a ee		dw key_held_prev 
4977 10 64		dw key_init 
4979 86 ee		dw key_repeat_ct 
497b			; 51 
497b 05 00		dw key_rows 
497d 58 ee		dw key_shift 
497f 59 ee		dw key_symbol 
4981 8c ee		dw keyscan_scancol 
4983 96 ee		dw keyscan_table 
4985 f5 ee		dw keyscan_table_row1 
4987 ea ee		dw keyscan_table_row2 
4989 df ee		dw keyscan_table_row3 
498b d4 ee		dw keyscan_table_row4 
498d c9 ee		dw keyscan_table_row5 
498f			; 61 
498f f2 e5		dw os_cli_cmd 
4991 ee e5		dw os_cur_ptr 
4993 f0 e5		dw os_current_i 
4995 c9 e4		dw os_input 
4997 f1 e6		dw os_last_cmd 
4999 c8 e5		dw os_last_new_uword 
499b bc e2		dw os_view_disable 
499d b8 e2		dw os_view_hl 
499f d0 e5		dw os_word_scratch 
49a1 c3 00		dw portbctl 
49a3			; 71 
49a3 c1 00		dw portbdata 
49a5 6d ea		dw spi_cartdev 
49a7 6c ea		dw spi_cartdev2 
49a9 6e ea		dw spi_clktime 
49ab 6a ea		dw spi_device 
49ad 69 ea		dw spi_device_id 
49af 6b ea		dw spi_portbyte 
49b1 b0 eb		dw stackstore 
49b3			if STORAGE_SE 
49b3			dw storage_actl 
49b3			dw storage_adata 
49b3			else 
49b3 00 00		dw 0 
49b5 00 00		dw 0 
49b7			endif 
49b7			; 81 
49b7 69 09		dw storage_append 
49b9			if STORAGE_SE 
49b9			dw storage_bctl 
49b9			else 
49b9 00 00		dw 0 
49bb			endif 
49bb 9c eb		dw store_bank_active 
49bd 71 ea		dw store_filecache 
49bf 7f ea		dw store_longread 
49c1 75 ea		dw store_openaddr 
49c3 74 ea		dw store_openext 
49c5 73 ea		dw store_openmaxext 
49c7 84 ea		dw store_page 
49c9 80 ea		dw store_readbuf 
49cb			; 91 
49cb 77 ea		dw store_readcont 
49cd 82 ea		dw store_readptr 
49cf 77 ea		dw store_tmpext 
49d1 78 ea		dw store_tmpid 
49d3 6f ea		dw store_tmppageid 
49d5			 
49d5			 
49d5			.ENDCONST: 
49d5			 
49d5			; eof 
49d5			 
49d5			 
# End of file forth_words_const.asm
49d5			 
49d5			if STORAGE_SE 
49d5			   	include "forth_words_storage.asm" 
49d5			endif 
49d5				include "forth_words_device.asm" 
49d5			; Device related words 
49d5			 
49d5			; | ## Device Words 
49d5			 
49d5			;if SOUND_ENABLE 
49d5			;.NOTE: 
49d5			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
49d5			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
49d5			;		if DEBUG_FORTH_WORDS_KEY 
49d5			;			DMARK "NTE" 
49d5			;			CALLMONITOR 
49d5			;		endif 
49d5			; 
49d5			;	 
49d5			; 
49d5			;		NEXTW 
49d5			;.AFTERSOUND: 
49d5			;endif 
49d5			 
49d5			 
49d5			USE_GPIO: equ 0 
49d5			 
49d5			if USE_GPIO 
49d5			.GP1: 
49d5				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
49d5			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
49d5					NEXTW 
49d5			.GP2: 
49d5				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
49d5			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
49d5			 
49d5					NEXTW 
49d5			 
49d5			.GP3: 
49d5				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
49d5			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
49d5			 
49d5					NEXTW 
49d5			 
49d5			.GP4: 
49d5				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
49d5			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
49d5			 
49d5					NEXTW 
49d5			.SIN: 
49d5			 
49d5			 
49d5			endif 
49d5			 
49d5			 
49d5				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
49d5 33				db WORD_SYS_CORE+31             
49d6 0a 4a			dw .SOUT            
49d8 03				db 2 + 1 
49d9 .. 00			db "IN",0              
49dc				endm 
# End of macro CWHEAD
49dc			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
49dc					if DEBUG_FORTH_WORDS_KEY 
49dc						DMARK "IN." 
49dc f5				push af  
49dd 3a f1 49			ld a, (.dmark)  
49e0 32 71 ee			ld (debug_mark),a  
49e3 3a f2 49			ld a, (.dmark+1)  
49e6 32 72 ee			ld (debug_mark+1),a  
49e9 3a f3 49			ld a, (.dmark+2)  
49ec 32 73 ee			ld (debug_mark+2),a  
49ef 18 03			jr .pastdmark  
49f1 ..			.dmark: db "IN."  
49f4 f1			.pastdmark: pop af  
49f5			endm  
# End of macro DMARK
49f5						CALLMONITOR 
49f5 cd ae 15			call break_point_state  
49f8				endm  
# End of macro CALLMONITOR
49f8					endif 
49f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
49f8 cd 16 1e			call macro_dsp_valuehl 
49fb				endm 
# End of macro FORTH_DSP_VALUEHL
49fb			 
49fb e5					push hl 
49fc			 
49fc					; destroy value TOS 
49fc			 
49fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49fc cd ce 1e			call macro_forth_dsp_pop 
49ff				endm 
# End of macro FORTH_DSP_POP
49ff			 
49ff					; one value on hl get other one back 
49ff			 
49ff c1					pop bc 
4a00			 
4a00					; do the sub 
4a00			;		ex de, hl 
4a00			 
4a00 ed 68				in l,(c) 
4a02			 
4a02					; save it 
4a02			 
4a02 26 00				ld h,0 
4a04			 
4a04					; TODO push value back onto stack for another op etc 
4a04			 
4a04 cd 1f 1c				call forth_push_numhl 
4a07					NEXTW 
4a07 c3 cc 1f			jp macro_next 
4a0a				endm 
# End of macro NEXTW
4a0a			.SOUT: 
4a0a				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a0a 34				db WORD_SYS_CORE+32             
4a0b 5d 4a			dw .SPIO            
4a0d 04				db 3 + 1 
4a0e .. 00			db "OUT",0              
4a12				endm 
# End of macro CWHEAD
4a12			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a12					if DEBUG_FORTH_WORDS_KEY 
4a12						DMARK "OUT" 
4a12 f5				push af  
4a13 3a 27 4a			ld a, (.dmark)  
4a16 32 71 ee			ld (debug_mark),a  
4a19 3a 28 4a			ld a, (.dmark+1)  
4a1c 32 72 ee			ld (debug_mark+1),a  
4a1f 3a 29 4a			ld a, (.dmark+2)  
4a22 32 73 ee			ld (debug_mark+2),a  
4a25 18 03			jr .pastdmark  
4a27 ..			.dmark: db "OUT"  
4a2a f1			.pastdmark: pop af  
4a2b			endm  
# End of macro DMARK
4a2b						CALLMONITOR 
4a2b cd ae 15			call break_point_state  
4a2e				endm  
# End of macro CALLMONITOR
4a2e					endif 
4a2e			 
4a2e					; get port 
4a2e			 
4a2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a2e cd 16 1e			call macro_dsp_valuehl 
4a31				endm 
# End of macro FORTH_DSP_VALUEHL
4a31			 
4a31 e5					push hl 
4a32			 
4a32					; destroy value TOS 
4a32			 
4a32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a32 cd ce 1e			call macro_forth_dsp_pop 
4a35				endm 
# End of macro FORTH_DSP_POP
4a35			 
4a35					; get byte to send 
4a35			 
4a35					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a35 cd 16 1e			call macro_dsp_valuehl 
4a38				endm 
# End of macro FORTH_DSP_VALUEHL
4a38			 
4a38			;		push hl 
4a38			 
4a38					; destroy value TOS 
4a38			 
4a38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a38 cd ce 1e			call macro_forth_dsp_pop 
4a3b				endm 
# End of macro FORTH_DSP_POP
4a3b			 
4a3b					; one value on hl get other one back 
4a3b			 
4a3b			;		pop hl 
4a3b			 
4a3b c1					pop bc 
4a3c			 
4a3c					if DEBUG_FORTH_WORDS 
4a3c						DMARK "OUT" 
4a3c f5				push af  
4a3d 3a 51 4a			ld a, (.dmark)  
4a40 32 71 ee			ld (debug_mark),a  
4a43 3a 52 4a			ld a, (.dmark+1)  
4a46 32 72 ee			ld (debug_mark+1),a  
4a49 3a 53 4a			ld a, (.dmark+2)  
4a4c 32 73 ee			ld (debug_mark+2),a  
4a4f 18 03			jr .pastdmark  
4a51 ..			.dmark: db "OUT"  
4a54 f1			.pastdmark: pop af  
4a55			endm  
# End of macro DMARK
4a55						CALLMONITOR 
4a55 cd ae 15			call break_point_state  
4a58				endm  
# End of macro CALLMONITOR
4a58					endif 
4a58			 
4a58 ed 69				out (c), l 
4a5a			 
4a5a					NEXTW 
4a5a c3 cc 1f			jp macro_next 
4a5d				endm 
# End of macro NEXTW
4a5d			 
4a5d			 
4a5d			.SPIO: 
4a5d			 
4a5d			if STORAGE_SE 
4a5d				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4a5d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4a5d			 
4a5d					call spi_ce_low 
4a5d			    NEXTW 
4a5d			 
4a5d			.SPICEH: 
4a5d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4a5d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4a5d			 
4a5d					call spi_ce_high 
4a5d			    NEXTW 
4a5d			 
4a5d			 
4a5d			.SPIOb: 
4a5d			 
4a5d				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4a5d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4a5d			 
4a5d					if DEBUG_FORTH_WORDS_KEY 
4a5d						DMARK "SPo" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d					; get port 
4a5d			 
4a5d			 
4a5d					; get byte to send 
4a5d			 
4a5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a5d			 
4a5d			;		push hl    ; u1  
4a5d			 
4a5d					; destroy value TOS 
4a5d			 
4a5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a5d			 
4a5d					; one value on hl get other one back 
4a5d			 
4a5d			;		pop hl   ; u2 - addr 
4a5d			 
4a5d					; TODO Send SPI byte 
4a5d			 
4a5d			;		push hl 
4a5d			;		call spi_ce_low 
4a5d			;		pop hl 
4a5d					ld a, l 
4a5d					call spi_send_byte 
4a5d			;		call spi_ce_high 
4a5d			 
4a5d					NEXTW 
4a5d			 
4a5d			.SPII: 
4a5d				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4a5d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4a5d					if DEBUG_FORTH_WORDS_KEY 
4a5d						DMARK "SPi" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d			 
4a5d					; TODO Get SPI byte 
4a5d			 
4a5d					call spi_read_byte 
4a5d			 
4a5d					if DEBUG_FORTH_WORDS 
4a5d						DMARK "Si2" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d					ld h, 0 
4a5d					ld l, a 
4a5d					if DEBUG_FORTH_WORDS 
4a5d						DMARK "Si3" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d					call forth_push_numhl 
4a5d			 
4a5d					NEXTW 
4a5d			 
4a5d			 
4a5d			 
4a5d			.SESEL: 
4a5d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4a5d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4a5d					if DEBUG_FORTH_WORDS_KEY 
4a5d						DMARK "BNK" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d			 
4a5d					ld a, 255 
4a5d					ld (spi_cartdev), a 
4a5d			 
4a5d					; get bank 
4a5d			 
4a5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a5d			 
4a5d			;		push hl 
4a5d			 
4a5d					; destroy value TOS 
4a5d			 
4a5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a5d			 
4a5d					; one value on hl get other one back 
4a5d			 
4a5d			;		pop hl 
4a5d			 
4a5d			 
4a5d					ld c, SPI_CE_HIGH 
4a5d					ld b, '0'    ; human readable bank number 
4a5d			 
4a5d					ld a, l 
4a5d			 
4a5d					if DEBUG_FORTH_WORDS 
4a5d						DMARK "BNK" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d			 
4a5d					; active low 
4a5d			 
4a5d					cp 0 
4a5d					jr z, .bset 
4a5d					cp 1 
4a5d					jr nz, .b2 
4a5d					res 0, c 
4a5d					ld b, '1'    ; human readable bank number 
4a5d			.b2:		cp 2 
4a5d					jr nz, .b3 
4a5d					res 1, c 
4a5d					ld b, '2'    ; human readable bank number 
4a5d			.b3:		cp 3 
4a5d					jr nz, .b4 
4a5d					res 2, c 
4a5d					ld b, '3'    ; human readable bank number 
4a5d			.b4:		cp 4 
4a5d					jr nz, .b5 
4a5d					res 3, c 
4a5d					ld b, '4'    ; human readable bank number 
4a5d			.b5:		cp 5 
4a5d					jr nz, .bset 
4a5d					res 4, c 
4a5d					ld b, '5'    ; human readable bank number 
4a5d			 
4a5d			.bset: 
4a5d					ld a, c 
4a5d					ld (spi_device),a 
4a5d					ld a, b 
4a5d					ld (spi_device_id),a 
4a5d					if DEBUG_FORTH_WORDS 
4a5d						DMARK "BN2" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d			 
4a5d					; set default SPI clk pulse time as disabled for BANK use 
4a5d			 
4a5d					ld a, 0 
4a5d					ld (spi_clktime), a 
4a5d			 
4a5d					NEXTW 
4a5d			 
4a5d			.CARTDEV: 
4a5d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4a5d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4a5d					if DEBUG_FORTH_WORDS_KEY 
4a5d						DMARK "CDV" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d			 
4a5d					; disable se storage bank selection 
4a5d			 
4a5d					ld a, SPI_CE_HIGH		; ce high 
4a5d					ld (spi_device), a 
4a5d			 
4a5d					; get bank 
4a5d			 
4a5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a5d			 
4a5d			;		push hl 
4a5d			 
4a5d					; destroy value TOS 
4a5d			 
4a5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a5d			 
4a5d					; one value on hl get other one back 
4a5d			 
4a5d			;		pop hl 
4a5d			 
4a5d					; active low 
4a5d			 
4a5d					ld c, 255 
4a5d			 
4a5d					ld a, l 
4a5d					if DEBUG_FORTH_WORDS 
4a5d						DMARK "CDV" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d					cp 0 
4a5d					jr z, .cset 
4a5d					cp 1 
4a5d					jr nz, .c2 
4a5d					res 0, c 
4a5d			.c2:		cp 2 
4a5d					jr nz, .c3 
4a5d					res 1, c 
4a5d			.c3:		cp 3 
4a5d					jr nz, .c4 
4a5d					res 2, c 
4a5d			.c4:		cp 4 
4a5d					jr nz, .c5 
4a5d					res 3, c 
4a5d			.c5:		cp 5 
4a5d					jr nz, .c6 
4a5d					res 4, c 
4a5d			.c6:		cp 6 
4a5d					jr nz, .c7 
4a5d					res 5, c 
4a5d			.c7:		cp 7 
4a5d					jr nz, .c8 
4a5d					res 6, c 
4a5d			.c8:		cp 8 
4a5d					jr nz, .cset 
4a5d					res 7, c 
4a5d			.cset:		ld a, c 
4a5d					ld (spi_cartdev),a 
4a5d			 
4a5d					if DEBUG_FORTH_WORDS 
4a5d						DMARK "CD2" 
4a5d						CALLMONITOR 
4a5d					endif 
4a5d			 
4a5d					; set default SPI clk pulse time as 10ms for CARTDEV use 
4a5d			 
4a5d					ld a, $0a 
4a5d					ld (spi_clktime), a 
4a5d					NEXTW 
4a5d			endif 
4a5d			 
4a5d			.ENDDEVICE: 
4a5d			; eof 
4a5d			 
# End of file forth_words_device.asm
4a5d			 
4a5d			; var handler 
4a5d			 
4a5d			 
4a5d			.VARS: 
4a5d				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4a5d 77				db WORD_SYS_CORE+99             
4a5e 0e 4b			dw .V0            
4a60 04				db 3 + 1 
4a61 .. 00			db "VAR",0              
4a65				endm 
# End of macro CWHEAD
4a65			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4a65			;| 
4a65			;| The variable name should consist of a single letter. e.g. "a" 
4a65			;! If a full string is passed then only the first char is looked at 
4a65			;| Any other char could exceed bounds checks!  
4a65			 
4a65					if DEBUG_FORTH_WORDS_KEY 
4a65						DMARK "VAR" 
4a65 f5				push af  
4a66 3a 7a 4a			ld a, (.dmark)  
4a69 32 71 ee			ld (debug_mark),a  
4a6c 3a 7b 4a			ld a, (.dmark+1)  
4a6f 32 72 ee			ld (debug_mark+1),a  
4a72 3a 7c 4a			ld a, (.dmark+2)  
4a75 32 73 ee			ld (debug_mark+2),a  
4a78 18 03			jr .pastdmark  
4a7a ..			.dmark: db "VAR"  
4a7d f1			.pastdmark: pop af  
4a7e			endm  
# End of macro DMARK
4a7e						CALLMONITOR 
4a7e cd ae 15			call break_point_state  
4a81				endm  
# End of macro CALLMONITOR
4a81					endif 
4a81			 
4a81					FORTH_DSP_VALUEHL 
4a81 cd 16 1e			call macro_dsp_valuehl 
4a84				endm 
# End of macro FORTH_DSP_VALUEHL
4a84			 
4a84 7e					ld a, (hl)    ; get first char on of the string 
4a85			 
4a85			 
4a85					if DEBUG_FORTH_WORDS 
4a85						DMARK "VR1" 
4a85 f5				push af  
4a86 3a 9a 4a			ld a, (.dmark)  
4a89 32 71 ee			ld (debug_mark),a  
4a8c 3a 9b 4a			ld a, (.dmark+1)  
4a8f 32 72 ee			ld (debug_mark+1),a  
4a92 3a 9c 4a			ld a, (.dmark+2)  
4a95 32 73 ee			ld (debug_mark+2),a  
4a98 18 03			jr .pastdmark  
4a9a ..			.dmark: db "VR1"  
4a9d f1			.pastdmark: pop af  
4a9e			endm  
# End of macro DMARK
4a9e						CALLMONITOR 
4a9e cd ae 15			call break_point_state  
4aa1				endm  
# End of macro CALLMONITOR
4aa1					endif 
4aa1					 
4aa1 f5					push af	 
4aa2					FORTH_DSP_POP 
4aa2 cd ce 1e			call macro_forth_dsp_pop 
4aa5				endm 
# End of macro FORTH_DSP_POP
4aa5 f1					pop af 
4aa6			 
4aa6					; convert to upper 
4aa6			 
4aa6 cd 1a 11				call to_upper 
4aa9					if DEBUG_FORTH_WORDS 
4aa9						DMARK "Vaa" 
4aa9 f5				push af  
4aaa 3a be 4a			ld a, (.dmark)  
4aad 32 71 ee			ld (debug_mark),a  
4ab0 3a bf 4a			ld a, (.dmark+1)  
4ab3 32 72 ee			ld (debug_mark+1),a  
4ab6 3a c0 4a			ld a, (.dmark+2)  
4ab9 32 73 ee			ld (debug_mark+2),a  
4abc 18 03			jr .pastdmark  
4abe ..			.dmark: db "Vaa"  
4ac1 f1			.pastdmark: pop af  
4ac2			endm  
# End of macro DMARK
4ac2						CALLMONITOR 
4ac2 cd ae 15			call break_point_state  
4ac5				endm  
# End of macro CALLMONITOR
4ac5					endif 
4ac5 06 41				ld b, 'A' 
4ac7 90					sub b			; set offset 
4ac8					if DEBUG_FORTH_WORDS 
4ac8						DMARK "Vbb" 
4ac8 f5				push af  
4ac9 3a dd 4a			ld a, (.dmark)  
4acc 32 71 ee			ld (debug_mark),a  
4acf 3a de 4a			ld a, (.dmark+1)  
4ad2 32 72 ee			ld (debug_mark+1),a  
4ad5 3a df 4a			ld a, (.dmark+2)  
4ad8 32 73 ee			ld (debug_mark+2),a  
4adb 18 03			jr .pastdmark  
4add ..			.dmark: db "Vbb"  
4ae0 f1			.pastdmark: pop af  
4ae1			endm  
# End of macro DMARK
4ae1						CALLMONITOR 
4ae1 cd ae 15			call break_point_state  
4ae4				endm  
# End of macro CALLMONITOR
4ae4					endif 
4ae4 cb 27				sla a  
4ae6				 
4ae6					 
4ae6					if DEBUG_FORTH_WORDS 
4ae6						DMARK "VR2" 
4ae6 f5				push af  
4ae7 3a fb 4a			ld a, (.dmark)  
4aea 32 71 ee			ld (debug_mark),a  
4aed 3a fc 4a			ld a, (.dmark+1)  
4af0 32 72 ee			ld (debug_mark+1),a  
4af3 3a fd 4a			ld a, (.dmark+2)  
4af6 32 73 ee			ld (debug_mark+2),a  
4af9 18 03			jr .pastdmark  
4afb ..			.dmark: db "VR2"  
4afe f1			.pastdmark: pop af  
4aff			endm  
# End of macro DMARK
4aff						CALLMONITOR 
4aff cd ae 15			call break_point_state  
4b02				endm  
# End of macro CALLMONITOR
4b02					endif 
4b02			 
4b02 21 fe e9				ld hl, cli_var_array2 
4b05 cd ad 0d				call addatohl 
4b08 cd 1f 1c				call forth_push_numhl 
4b0b			 
4b0b			 
4b0b				       NEXTW 
4b0b c3 cc 1f			jp macro_next 
4b0e				endm 
# End of macro NEXTW
4b0e			.V0: 
4b0e				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b0e 78				db WORD_SYS_CORE+100             
4b0f 26 4b			dw .V0Q            
4b11 04				db 3 + 1 
4b12 .. 00			db "V0!",0              
4b16				endm 
# End of macro CWHEAD
4b16			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b16			 
4b16					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b16 cd 16 1e			call macro_dsp_valuehl 
4b19				endm 
# End of macro FORTH_DSP_VALUEHL
4b19			 
4b19 11 32 ea				ld de, cli_var_array 
4b1c			 
4b1c eb					ex de, hl 
4b1d 73					ld (hl), e 
4b1e 23					inc hl 
4b1f 72					ld (hl), d 
4b20			 
4b20					; destroy value TOS 
4b20			 
4b20					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b20 cd ce 1e			call macro_forth_dsp_pop 
4b23				endm 
# End of macro FORTH_DSP_POP
4b23			 
4b23				       NEXTW 
4b23 c3 cc 1f			jp macro_next 
4b26				endm 
# End of macro NEXTW
4b26			.V0Q: 
4b26				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4b26 79				db WORD_SYS_CORE+101             
4b27 37 4b			dw .V1S            
4b29 04				db 3 + 1 
4b2a .. 00			db "V0@",0              
4b2e				endm 
# End of macro CWHEAD
4b2e			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4b2e 2a 32 ea				ld hl, (cli_var_array) 
4b31 cd 1f 1c				call forth_push_numhl 
4b34			 
4b34				       NEXTW 
4b34 c3 cc 1f			jp macro_next 
4b37				endm 
# End of macro NEXTW
4b37			.V1S: 
4b37				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4b37 7a				db WORD_SYS_CORE+102             
4b38 4f 4b			dw .V1Q            
4b3a 04				db 3 + 1 
4b3b .. 00			db "V1!",0              
4b3f				endm 
# End of macro CWHEAD
4b3f			;| V1! ( u1 -- )  Store value to v1 | DONE 
4b3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b3f cd 16 1e			call macro_dsp_valuehl 
4b42				endm 
# End of macro FORTH_DSP_VALUEHL
4b42			 
4b42 11 34 ea				ld de, cli_var_array+2 
4b45				 
4b45 eb					ex de, hl 
4b46 73					ld (hl), e 
4b47 23					inc hl 
4b48 72					ld (hl), d 
4b49			 
4b49					; destroy value TOS 
4b49			 
4b49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b49 cd ce 1e			call macro_forth_dsp_pop 
4b4c				endm 
# End of macro FORTH_DSP_POP
4b4c				       NEXTW 
4b4c c3 cc 1f			jp macro_next 
4b4f				endm 
# End of macro NEXTW
4b4f			.V1Q: 
4b4f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4b4f 7b				db WORD_SYS_CORE+103             
4b50 60 4b			dw .V2S            
4b52 04				db 3 + 1 
4b53 .. 00			db "V1@",0              
4b57				endm 
# End of macro CWHEAD
4b57			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4b57 2a 34 ea				ld hl, (cli_var_array+2) 
4b5a cd 1f 1c				call forth_push_numhl 
4b5d				       NEXTW 
4b5d c3 cc 1f			jp macro_next 
4b60				endm 
# End of macro NEXTW
4b60			.V2S: 
4b60				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4b60 7c				db WORD_SYS_CORE+104             
4b61 78 4b			dw .V2Q            
4b63 04				db 3 + 1 
4b64 .. 00			db "V2!",0              
4b68				endm 
# End of macro CWHEAD
4b68			;| V2! ( u1 -- )  Store value to v2 | DONE 
4b68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b68 cd 16 1e			call macro_dsp_valuehl 
4b6b				endm 
# End of macro FORTH_DSP_VALUEHL
4b6b			 
4b6b 11 36 ea				ld de, cli_var_array+4 
4b6e				 
4b6e eb					ex de, hl 
4b6f 73					ld (hl), e 
4b70 23					inc hl 
4b71 72					ld (hl), d 
4b72			 
4b72					; destroy value TOS 
4b72			 
4b72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b72 cd ce 1e			call macro_forth_dsp_pop 
4b75				endm 
# End of macro FORTH_DSP_POP
4b75				       NEXTW 
4b75 c3 cc 1f			jp macro_next 
4b78				endm 
# End of macro NEXTW
4b78			.V2Q: 
4b78				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4b78 7d				db WORD_SYS_CORE+105             
4b79 89 4b			dw .V3S            
4b7b 04				db 3 + 1 
4b7c .. 00			db "V2@",0              
4b80				endm 
# End of macro CWHEAD
4b80			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4b80 2a 36 ea				ld hl, (cli_var_array+4) 
4b83 cd 1f 1c				call forth_push_numhl 
4b86				       NEXTW 
4b86 c3 cc 1f			jp macro_next 
4b89				endm 
# End of macro NEXTW
4b89			.V3S: 
4b89				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4b89 7c				db WORD_SYS_CORE+104             
4b8a a1 4b			dw .V3Q            
4b8c 04				db 3 + 1 
4b8d .. 00			db "V3!",0              
4b91				endm 
# End of macro CWHEAD
4b91			;| V3! ( u1 -- )  Store value to v3 | DONE 
4b91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b91 cd 16 1e			call macro_dsp_valuehl 
4b94				endm 
# End of macro FORTH_DSP_VALUEHL
4b94			 
4b94 11 38 ea				ld de, cli_var_array+6 
4b97				 
4b97 eb					ex de, hl 
4b98 73					ld (hl), e 
4b99 23					inc hl 
4b9a 72					ld (hl), d 
4b9b			 
4b9b					; destroy value TOS 
4b9b			 
4b9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b9b cd ce 1e			call macro_forth_dsp_pop 
4b9e				endm 
# End of macro FORTH_DSP_POP
4b9e				       NEXTW 
4b9e c3 cc 1f			jp macro_next 
4ba1				endm 
# End of macro NEXTW
4ba1			.V3Q: 
4ba1				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4ba1 7d				db WORD_SYS_CORE+105             
4ba2 b2 4b			dw .END            
4ba4 04				db 3 + 1 
4ba5 .. 00			db "V3@",0              
4ba9				endm 
# End of macro CWHEAD
4ba9			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4ba9 2a 38 ea				ld hl, (cli_var_array+6) 
4bac cd 1f 1c				call forth_push_numhl 
4baf				       NEXTW 
4baf c3 cc 1f			jp macro_next 
4bb2				endm 
# End of macro NEXTW
4bb2			 
4bb2			 
4bb2			 
4bb2			 
4bb2			 
4bb2			; end of dict marker 
4bb2			 
4bb2 00			.END:    db WORD_SYS_END 
4bb3 00 00			dw 0 
4bb5 00				db 0 
4bb6			 
4bb6			; use to jp here for user dict words to save on macro expansion  
4bb6			 
4bb6			user_dict_next: 
4bb6				NEXTW 
4bb6 c3 cc 1f			jp macro_next 
4bb9				endm 
# End of macro NEXTW
4bb9			 
4bb9			 
4bb9			user_exec: 
4bb9				;    ld hl, <word code> 
4bb9				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4bb9				;    call forthexec 
4bb9				;    jp user_dict_next   (NEXT) 
4bb9			        ;    <word code bytes> 
4bb9 eb				ex de, hl 
4bba 2a cc e5			ld hl,(os_tok_ptr) 
4bbd				 
4bbd				FORTH_RSP_NEXT 
4bbd cd c6 1b			call macro_forth_rsp_next 
4bc0				endm 
# End of macro FORTH_RSP_NEXT
4bc0			 
4bc0			if DEBUG_FORTH_UWORD 
4bc0						DMARK "UEX" 
4bc0 f5				push af  
4bc1 3a d5 4b			ld a, (.dmark)  
4bc4 32 71 ee			ld (debug_mark),a  
4bc7 3a d6 4b			ld a, (.dmark+1)  
4bca 32 72 ee			ld (debug_mark+1),a  
4bcd 3a d7 4b			ld a, (.dmark+2)  
4bd0 32 73 ee			ld (debug_mark+2),a  
4bd3 18 03			jr .pastdmark  
4bd5 ..			.dmark: db "UEX"  
4bd8 f1			.pastdmark: pop af  
4bd9			endm  
# End of macro DMARK
4bd9				CALLMONITOR 
4bd9 cd ae 15			call break_point_state  
4bdc				endm  
# End of macro CALLMONITOR
4bdc			endif 
4bdc			 
4bdc			 
4bdc			 
4bdc eb				ex de, hl 
4bdd 22 cc e5			ld (os_tok_ptr), hl 
4be0				 
4be0				; Don't use next - Skips the first word in uword. 
4be0			 
4be0 c3 5d 20			jp exec1 
4be3			;	NEXT 
4be3			 
4be3			 
4be3			; eof 
# End of file forth_wordsv4.asm
4be3			endif 
4be3			;;;;;;;;;;;;;; Debug code 
4be3			 
4be3			 
4be3			;if DEBUG_FORTH_PARSE 
4be3 .. 00		.nowordfound: db "No match",0 
4bec .. 00		.compword:	db "Comparing word ",0 
4bfc .. 00		.nextwordat:	db "Next word at",0 
4c09 .. 00		.charmatch:	db "Char match",0 
4c14			;endif 
4c14			if DEBUG_FORTH_JP 
4c14			.foundword:	db "Word match. Exec..",0 
4c14			endif 
4c14			;if DEBUG_FORTH_PUSH 
4c14 .. 00		.enddict:	db "Dict end. Push.",0 
4c24 .. 00		.push_str:	db "Pushing string",0 
4c33 .. 00		.push_num:	db "Pushing number",0 
4c42 .. 00		.data_sp:	db "SP:",0 
4c46 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4c58 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4c6a .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4c7c			;endif 
4c7c			;if DEBUG_FORTH_MALLOC 
4c7c .. 00		.push_malloc:	db "Malloc address",0 
4c8b			;endif 
4c8b			 
4c8b			 
4c8b			 
4c8b			; display malloc address and current data stack pointer  
4c8b			 
4c8b			malloc_error: 
4c8b d5				push de 
4c8c f5				push af 
4c8d e5				push hl 
4c8e cd 80 0b			call clear_display 
4c91 11 b3 4c			ld de, .mallocerr 
4c94 3e 00			ld a,0 
4c96			;	ld de,os_word_scratch 
4c96 cd 93 0b			call str_at_display 
4c99 3e 11			ld a, display_row_1+17 
4c9b 11 71 ee			ld de, debug_mark 
4c9e cd 93 0b			call str_at_display 
4ca1 cd a3 0b			call update_display 
4ca4				;call break_point_state 
4ca4 cd 11 64			call cin_wait 
4ca7			 
4ca7 3e 20			ld a, ' ' 
4ca9 32 bc e2			ld (os_view_disable), a 
4cac e1				pop hl 
4cad f1				pop af 
4cae d1				pop de	 
4caf				CALLMONITOR 
4caf cd ae 15			call break_point_state  
4cb2				endm  
# End of macro CALLMONITOR
4cb2 c9				ret 
4cb3			 
4cb3 .. 00		.mallocerr: 	db "Malloc Error",0 
4cc0			;if DEBUG_FORTH_PUSH 
4cc0			display_data_sp: 
4cc0 f5				push af 
4cc1			 
4cc1				; see if disabled 
4cc1			 
4cc1 3a bc e2			ld a, (os_view_disable) 
4cc4 fe 2a			cp '*' 
4cc6 28 67			jr z, .skipdsp 
4cc8			 
4cc8 e5				push hl 
4cc9 e5				push hl 
4cca e5			push hl 
4ccb cd 80 0b			call clear_display 
4cce e1			pop hl 
4ccf 7c				ld a,h 
4cd0 21 d0 e5			ld hl, os_word_scratch 
4cd3 cd ae 10			call hexout 
4cd6 e1				pop hl 
4cd7 7d				ld a,l 
4cd8 21 d2 e5			ld hl, os_word_scratch+2 
4cdb cd ae 10			call hexout 
4cde 21 d4 e5			ld hl, os_word_scratch+4 
4ce1 3e 00			ld a,0 
4ce3 77				ld (hl),a 
4ce4 11 d0 e5			ld de,os_word_scratch 
4ce7 3e 28				ld a, display_row_2 
4ce9 cd 93 0b				call str_at_display 
4cec 11 46 4c			ld de, .wordinhl 
4cef 3e 00			ld a, display_row_1 
4cf1			 
4cf1 cd 93 0b				call str_at_display 
4cf4 11 71 ee			ld de, debug_mark 
4cf7 3e 11			ld a, display_row_1+17 
4cf9			 
4cf9 cd 93 0b				call str_at_display 
4cfc			 
4cfc				; display current data stack pointer 
4cfc 11 42 4c			ld de,.data_sp 
4cff 3e 30				ld a, display_row_2 + 8 
4d01 cd 93 0b				call str_at_display 
4d04			 
4d04 2a f8 e9			ld hl,(cli_data_sp) 
4d07 e5				push hl 
4d08 7c				ld a,h 
4d09 21 d0 e5			ld hl, os_word_scratch 
4d0c cd ae 10			call hexout 
4d0f e1				pop hl 
4d10 7d				ld a,l 
4d11 21 d2 e5			ld hl, os_word_scratch+2 
4d14 cd ae 10			call hexout 
4d17 21 d4 e5			ld hl, os_word_scratch+4 
4d1a 3e 00			ld a,0 
4d1c 77				ld (hl),a 
4d1d 11 d0 e5			ld de,os_word_scratch 
4d20 3e 33				ld a, display_row_2 + 11 
4d22 cd 93 0b				call str_at_display 
4d25			 
4d25			 
4d25 cd a3 0b			call update_display 
4d28 cd f2 0a			call delay1s 
4d2b cd f2 0a			call delay1s 
4d2e e1				pop hl 
4d2f			.skipdsp: 
4d2f f1				pop af 
4d30 c9				ret 
4d31			 
4d31			display_data_malloc: 
4d31			 
4d31 f5				push af 
4d32 e5				push hl 
4d33 e5				push hl 
4d34 e5			push hl 
4d35 cd 80 0b			call clear_display 
4d38 e1			pop hl 
4d39 7c				ld a,h 
4d3a 21 d0 e5			ld hl, os_word_scratch 
4d3d cd ae 10			call hexout 
4d40 e1				pop hl 
4d41 7d				ld a,l 
4d42 21 d2 e5			ld hl, os_word_scratch+2 
4d45 cd ae 10			call hexout 
4d48 21 d4 e5			ld hl, os_word_scratch+4 
4d4b 3e 00			ld a,0 
4d4d 77				ld (hl),a 
4d4e 11 d0 e5			ld de,os_word_scratch 
4d51 3e 28				ld a, display_row_2 
4d53 cd 93 0b				call str_at_display 
4d56 11 7c 4c			ld de, .push_malloc 
4d59 3e 00			ld a, display_row_1 
4d5b			 
4d5b cd 93 0b				call str_at_display 
4d5e			 
4d5e				; display current data stack pointer 
4d5e 11 42 4c			ld de,.data_sp 
4d61 3e 30				ld a, display_row_2 + 8 
4d63 cd 93 0b				call str_at_display 
4d66			 
4d66 2a f8 e9			ld hl,(cli_data_sp) 
4d69 e5				push hl 
4d6a 7c				ld a,h 
4d6b 21 d0 e5			ld hl, os_word_scratch 
4d6e cd ae 10			call hexout 
4d71 e1				pop hl 
4d72 7d				ld a,l 
4d73 21 d2 e5			ld hl, os_word_scratch+2 
4d76 cd ae 10			call hexout 
4d79 21 d4 e5			ld hl, os_word_scratch+4 
4d7c 3e 00			ld a,0 
4d7e 77				ld (hl),a 
4d7f 11 d0 e5			ld de,os_word_scratch 
4d82 3e 33				ld a, display_row_2 + 11 
4d84 cd 93 0b				call str_at_display 
4d87			 
4d87 cd a3 0b			call update_display 
4d8a cd f2 0a			call delay1s 
4d8d cd f2 0a			call delay1s 
4d90 e1				pop hl 
4d91 f1				pop af 
4d92 c9				ret 
4d93			;endif 
4d93			 
4d93			include "forth_autostart.asm" 
4d93			; list of commands to perform at system start up 
4d93			 
4d93			startcmds: 
4d93			;	dw test11 
4d93			;	dw test12 
4d93			;	dw test13 
4d93			;	dw test14 
4d93			;	dw test15 
4d93			;	dw test16 
4d93			;	dw test17 
4d93			;	dw ifthtest1 
4d93			;	dw ifthtest2 
4d93			;	dw ifthtest3 
4d93			;	dw mmtest1 
4d93			;	dw mmtest2 
4d93			;	dw mmtest3 
4d93			;	dw mmtest4 
4d93			;	dw mmtest5 
4d93			;	dw mmtest6 
4d93			;	dw iftest1 
4d93			;	dw iftest2 
4d93			;	dw iftest3 
4d93			;	dw looptest1 
4d93			;	dw looptest2 
4d93			;	dw test1 
4d93			;	dw test2 
4d93			;	dw test3 
4d93			;	dw test4 
4d93			;	dw game2r 
4d93			;	dw game2b1 
4d93			;	dw game2b2 
4d93			 
4d93				; start up words that are actually useful 
4d93			 
4d93 9b 4e		    dw spi1 
4d95 f4 4e		    dw spi2 
4d97 82 4f		    dw spi3 
4d99 2a 4f		    dw spi4 
4d9b 55 4f		    dw spi5 
4d9d e8 4f		    dw spi6 
4d9f 3d 50		    dw spi7 
4da1			 
4da1 95 50		    dw spi8 
4da3 b4 50		    dw spi9 
4da5 0c 51		    dw spi10 
4da7			 
4da7			; file editor 
4da7 0d 4e			dw edit1 
4da9 2e 4e			dw edit2 
4dab 63 4e			dw edit3 
4dad			 
4dad 7f 51			dw longread 
4daf c6 51			dw clrstack 
4db1 f9 51			dw type 
4db3 e9 53			dw stest 
4db5 1d 52			dw strncpy 
4db7 7f 53			dw list 
4db9 7e 52			dw start1 
4dbb 90 52			dw start2 
4dbd			;	dw start3 
4dbd a3 52			dw start3b 
4dbf 1f 53			dw start3c 
4dc1			 
4dc1				; (unit) testing words 
4dc1			 
4dc1 60 54			dw mtesta 
4dc3 15 55			dw mtestb 
4dc5 b8 55			dw mtestc 
4dc7 6d 56			dw mtestd 
4dc9 11 57			dw mteste 
4dcb			 
4dcb				; demo/game words 
4dcb			 
4dcb 1d 5e		        dw game3w 
4dcd 4b 5e		        dw game3p 
4dcf 69 5e		        dw game3sc 
4dd1 9a 5e		        dw game3vsi 
4dd3 c6 5e		        dw game3vs 
4dd5				 
4dd5 10 5c			dw game2b 
4dd7 7e 5c			dw game2bf 
4dd9 c8 5c			dw game2mba 
4ddb 5e 5d			dw game2mbas 
4ddd a0 5d			dw game2mb 
4ddf			 
4ddf d1 58			dw game1 
4de1 e2 58			dw game1a 
4de3 44 59			dw game1b 
4de5 79 59			dw game1c 
4de7 af 59			dw game1d 
4de9 e0 59			dw game1s 
4deb f4 59			dw game1t 
4ded 09 5a			dw game1f 
4def 3d 5a			dw game1z 
4df1 81 5a			dw game1zz 
4df3			 
4df3 c7 57			dw test5 
4df5 ff 57			dw test6 
4df7 37 58			dw test7 
4df9 4b 58			dw test8 
4dfb 77 58			dw test9 
4dfd 8d 58			dw test10 
4dff				 
4dff 58 5b		        dw ssv5 
4e01 3c 5b		        dw ssv4 
4e03 20 5b		        dw ssv3 
4e05 ea 5a		        dw ssv2 
4e07 71 5b		        dw ssv1 
4e09 b9 5b		        dw ssv1cpm 
4e0b			;	dw keyup 
4e0b			;	dw keydown 
4e0b			;	dw keyleft 
4e0b			;	dw keyright 
4e0b			;	dw 	keyf1 
4e0b			;	dw keyf2 
4e0b			;	dw keyf3 
4e0b			;	dw keyf4 
4e0b			;	dw keyf5 
4e0b			;	dw keyf6 
4e0b			;	dw keyf7 
4e0b			;	dw keyf8 
4e0b			;	dw keyf9 
4e0b			;	dw keyf10 
4e0b			;	dw keyf11 
4e0b			;	dw keyf12 
4e0b			;	dw keytab 
4e0b			;	dw keycr 
4e0b			;	dw keyhome 
4e0b			;	dw keyend 
4e0b			;	dw keybs 
4e0b 00 00			db 0, 0	 
4e0d			 
4e0d			 
4e0d			; File Editor 
4e0d			 
4e0d			; ( id - ) use 'e' to edit the displayed line 
4e0d .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e2e .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e63			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e63 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4e9b			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4e9b			 
4e9b			; SPI Net support words 
4e9b			 
4e9b			; v0! = node to send to 
4e9b			; ( str count - ) 
4e9b .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4ef4			 
4ef4			; spiputchr ( char node - ) 
4ef4 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f2a			 
4f2a			; spigetchr ( - n ) 
4f2a .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4f55			 
4f55			; getnode ( - n ) 
4f55 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4f82			 
4f82			; ( str node - )  
4f82 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
4fe8			; store string ( str i - ) 
4fe8			 
4fe8			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
4fe8 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
503d			 
503d			; get string ( addr i -  )    TO FIX 
503d			 
503d .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5095			 
5095			 
5095			; NETCHAT (TODO) 
5095			; Program to allow two nodes to chat with eachother 
5095			; 
5095			; v0 - target node 
5095			;  
5095			; accept input at 0,0 
5095			; if input is string send spitype to target node 
5095			; starting at row 2,0 , while spigetchr is not zero ->  
5095			; 
5095			; 
5095			; TODO add paging of get request 
5095			 
5095			; ( node - ) 
5095 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
50b4 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
510c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
517f			 
517f			 
517f			; Long read of currently open file 
517f .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
51c6			 
51c6			; clear stack  
51c6			 
51c6 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
51f9			 
51f9			; type ( addr count - ) 
51f9 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
521d			 
521d			; some direct memory words 
521d			; strncpy ( len t f -- t ) 
521d			 
521d .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
527e			 
527e .. 00		start1:     	db ": bpon $0000 bp ;",0 
5290 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
52a3 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
531f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
537f			 
537f			 
537f			; a handy word to list items on the stack 
537f			 
537f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
53e9			 
53e9			 
53e9			; test stack  
53e9			; rnd8 stest 
53e9			 
53e9 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5460			 
5460			; random malloc and free cycles 
5460			 
5460 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5515			 
5515			; fixed malloc and free cycles 
5515			 
5515 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55b8			 
55b8			; fixed double string push and drop cycle  
55b8			 
55b8 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
566d			 
566d			; consistent fixed string push and drop cycle  
566d			 
566d .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5711			 
5711 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
57c7			 
57c7			;test1:		db ": aa 1 2 3 ;", 0 
57c7			;test2:     	db "111 aa 888 999",0 
57c7			;test3:     	db ": bb 77 ;",0 
57c7			;test4:     	db "$02 $01 do i . loop bb",0 
57c7			 
57c7 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
57ff .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5837 .. 00		test7:     	db ": box hline vline ;",0 
584b .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5877 .. 00		test9:     	db ": sw $01 adsp world ;",0 
588d .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
58b2 .. 00		test11:     	db "hello create .",0 
58c1 .. 00		test12:     	db "hello2 create .",0 
58d1			 
58d1			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
58d1			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
58d1			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
58d1			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
58d1			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
58d1			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
58d1			 
58d1			;iftest1:     	db "$0001 IF cls .",0 
58d1			;iftest2:     	db "$0000 IF cls .",0 
58d1			;iftest3:     	db "$0002 $0003 - IF cls .",0 
58d1			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
58d1			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
58d1			 
58d1			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
58d1			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
58d1			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
58d1			 
58d1			 
58d1			 
58d1			; a small guess the number game 
58d1			 
58d1 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
58e2 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5944			 
5944 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5979 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
59af .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
59e0 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
59f4 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5a09 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5a3d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5a81			 
5a81			; Using 'ga' save a high score across multiple runs using external storage 
5a81			 
5a81 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5aea			 
5aea			 
5aea			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5aea			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5aea			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5aea			 
5aea			; simple screen saver to test code memory reuse to destruction 
5aea			 
5aea .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5b20 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5b3c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5b58 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5b71 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5bb9 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5c10			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c10			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5c10			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5c10			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5c10			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5c10			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5c10			 
5c10			 
5c10			 
5c10			; minesweeper/battleship finding game 
5c10			; draws a game board of random ship/mine positions 
5c10			; user enters coords to see if it hits on 
5c10			; game ends when all are hit 
5c10			; when hit or miss says how many may be in the area 
5c10			 
5c10			; setup the game board and then hide it 
5c10 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5c7e .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5cc8			; prompt for where to target 
5cc8 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5d5e .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5d83			; TODO see if the entered coords hits or misses pushes char hit of miss 
5d83 .. 00		game2mbht:      db ": mbckht nop ;",0 
5d92 .. 00		game2mbms:      db ": mbcms nop ;",0 
5da0			; TODO how many might be near by 
5da0 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5e1d			 
5e1d			; Game 3 
5e1d			 
5e1d			; Vert scroller ski game - avoid the trees! 
5e1d			 
5e1d			; v0 score (ie turns) 
5e1d			; v1 player pos 
5e1d			; v2 left wall 
5e1d			; v3 right wall 
5e1d			 
5e1d			; Draw side walls randomly 
5e1d			 
5e1d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5e4b			 
5e4b			; Draw player 
5e4b .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5e69			 
5e69			; TODO Get Key 
5e69			 
5e69			; TODO Move left right 
5e69			 
5e69			; scroll and move walls a bit 
5e69			 
5e69 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5e9a			 
5e9a			; main game loop 
5e9a			 
5e9a .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5ec6 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5f05			 
5f05			; key board defs 
5f05			 
5f05 .. 00		keyup:       db ": keyup $05 ;",0 
5f13 .. 00		keydown:       db ": keydown $0a ;",0 
5f23 .. 00		keyleft:       db ": keyleft $0b ;",0 
5f33 .. 00		keyright:       db ": keyright $0c ;",0 
5f44 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5f52 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5f60 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5f6e .. 00		keyf4:       db ": keyf4 $13 ;",0 
5f7c .. 00		keyf5:       db ": keyf5 $14 ;",0 
5f8a .. 00		keyf6:       db ": keyf6 $15 ;",0 
5f98 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5fa6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5fb4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5fc2 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5fd1 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5fe0 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5fef			 
5fef .. 00		keytab:       db ": keytab $09 ;",0 
5ffe .. 00		keycr:       db ": keycr $0d ;",0 
600c .. 00		keyhome:       db ": keyhome $0e ;",0 
601c .. 00		keyend:       db ": keyend $0f ;",0 
602b .. 00		keybs:       db ": keybs $08 ;",0 
6039			 
6039			   
6039			 
6039			 
6039			 
6039			; eof 
# End of file forth_autostart.asm
6039			 
6039 .. 00		sprompt1: db "Startup load...",0 
6049 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
605f			 
605f			 
605f			 
605f			 
605f			forth_startup: 
605f 21 93 4d			ld hl, startcmds 
6062 3e 00			ld a, 0 
6064 32 f1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6067			 
6067 e5			.start1:	push hl 
6068 cd 80 0b			call clear_display 
606b 11 39 60			ld de, sprompt1 
606e 3e 00		        ld a, display_row_1 
6070 cd 93 0b			call str_at_display 
6073 11 49 60			ld de, sprompt2 
6076 3e 28		        ld a, display_row_2 
6078 cd 93 0b			call str_at_display 
607b e1				pop hl 
607c e5				push hl 
607d 5e				ld e,(hl) 
607e 23				inc hl 
607f 56				ld d,(hl) 
6080 3e 50		        ld a, display_row_3 
6082 cd 93 0b			call str_at_display 
6085 cd a3 0b			call update_display 
6088			 
6088			 
6088 3a f1 e6			ld a, (os_last_cmd) 
608b fe 00			cp 0 
608d 28 05			jr z, .startprompt 
608f cd e6 0a			call delay250ms 
6092 18 24			jr .startdo 
6094				 
6094				 
6094			 
6094			.startprompt: 
6094			 
6094 3e 9f			ld a,display_row_4 + display_cols - 1 
6096 11 95 1b		        ld de, endprg 
6099 cd 93 0b			call str_at_display 
609c cd a3 0b			call update_display 
609f cd f2 0a			call delay1s 
60a2 cd 11 64			call cin_wait 
60a5						 
60a5 fe 2a			cp '*' 
60a7 28 5e			jr z, .startupend1 
60a9 fe 23			cp '#' 
60ab 20 07			jr nz, .startno 
60ad 3e 01			ld a, 1 
60af 32 f1 e6			ld (os_last_cmd),a 
60b2 18 04			jr .startdo 
60b4 fe 31		.startno:	cp '1' 
60b6 28 3a			jr z,.startnxt  
60b8			 
60b8				; exec startup line 
60b8			.startdo:	 
60b8 e1				pop hl 
60b9 e5				push hl 
60ba				 
60ba 5e				ld e,(hl) 
60bb 23				inc hl 
60bc 56				ld d,(hl) 
60bd eb				ex de,hl 
60be			 
60be e5				push hl 
60bf			 
60bf 3e 00			ld a, 0 
60c1				;ld a, FORTH_END_BUFFER 
60c1 cd 16 12			call strlent 
60c4 23				inc hl   ; include zero term to copy 
60c5 06 00			ld b,0 
60c7 4d				ld c,l 
60c8 e1				pop hl 
60c9 11 cb e2			ld de, scratch 
60cc ed b0			ldir 
60ce			 
60ce			 
60ce 21 cb e2			ld hl, scratch 
60d1 cd 1a 20			call forthparse 
60d4 cd 5a 20			call forthexec 
60d7 cd 6c 1f			call forthexec_cleanup 
60da			 
60da 3e 78			ld a, display_row_4 
60dc 11 39 19			ld de, endprog 
60df			 
60df cd a3 0b			call update_display		 
60e2			 
60e2 3a f1 e6			ld a, (os_last_cmd) 
60e5 fe 00			cp 0 
60e7 20 09			jr nz, .startnxt 
60e9 cd 97 1b			call next_page_prompt 
60ec cd 80 0b		        call clear_display 
60ef cd a3 0b			call update_display		 
60f2			 
60f2				; move onto next startup line? 
60f2			.startnxt: 
60f2			 
60f2 cd e6 0a			call delay250ms 
60f5 e1				pop hl 
60f6			 
60f6 23				inc hl 
60f7 23				inc hl 
60f8			 
60f8 e5				push hl 
60f9 5e				ld e, (hl) 
60fa 23				inc hl 
60fb 56				ld d, (hl) 
60fc e1				pop hl 
60fd				; TODO replace 0 test 
60fd			 
60fd eb				ex de, hl 
60fe cd d6 0d			call ishlzero 
6101			;	ld a,e 
6101			;	add d 
6101			;	cp 0    ; any left to do? 
6101 eb				ex de, hl 
6102 c2 67 60			jp nz, .start1 
6105 18 01			jr .startupend 
6107			 
6107 e1			.startupend1: pop hl 
6108			.startupend: 
6108			 
6108 cd 80 0b			call clear_display 
610b cd a3 0b			call update_display 
610e c9				ret 
610f			 
610f			 
610f			; stack over and underflow checks 
610f			 
610f			; init the words to detect the under/overflow 
610f			 
610f			chk_stk_init: 
610f				; a vague random number to check so we dont get any "lucky" hits 
610f 3e 2d			ld a, 45 
6111 6f				ld l, a 
6112 00				nop 
6113 3e 17			ld a, 23 
6115 67				ld h, a 
6116			 
6116 22 b2 e2			ld (chk_word), hl     ; the word we need to check against 
6119			 
6119			;	ld (chk_stund), hl	; stack points.... 
6119 22 00 ef			ld (chk_stovr), hl 
611c 22 f6 e9			ld (chk_ret_und), hl 
611f 22 b4 e9			ld (chk_ret_ovr), hl 
6122 22 32 e9			ld (chk_loop_ovr), hl 
6125 22 30 e8			ld (chk_data_ovr), hl 
6128 c9				ret 
6129				 
6129			check_stacks: 
6129				; check all stack words 
6129			 
6129 e5				push hl 
612a d5				push de 
612b			 
612b			;	ld de,(chk_word) 
612b			;	ld hl, (chk_stund)	; stack points.... 
612b			;	if DEBUG_STK_FAULT 
612b			;		DMARK "FAa" 
612b			;		CALLMONITOR 
612b			;	endif 
612b			;	call cmp16 
612b			;	jp z, .chk_faulta 
612b			; 
612b			;	ld de, sfaultsu 
612b			;	jp .chk_fault 
612b			 
612b 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
612e ed 5b b2 e2		ld de,(chk_word) 
6132				if DEBUG_STK_FAULT 
6132					DMARK "FAb" 
6132					CALLMONITOR 
6132				endif 
6132 cd cb 0d			call cmp16 
6135 28 06			jr z, .chk_fault1 
6137 11 d8 61			ld de, sfaultso 
613a c3 8c 61			jp .chk_fault 
613d			.chk_fault1:  
613d 2a f6 e9			ld hl, (chk_ret_und) 
6140 ed 5b b2 e2		ld de,(chk_word) 
6144				if DEBUG_STK_FAULT 
6144					DMARK "FAU" 
6144					CALLMONITOR 
6144				endif 
6144 cd cb 0d			call cmp16 
6147 ca 50 61			jp z, .chk_fault2 
614a 11 e8 61			ld de, sfaultru 
614d c3 8c 61			jp .chk_fault 
6150			.chk_fault2:  
6150 2a b4 e9			ld hl, (chk_ret_ovr) 
6153 ed 5b b2 e2		ld de,(chk_word) 
6157				if DEBUG_STK_FAULT 
6157					DMARK "FA1" 
6157					CALLMONITOR 
6157				endif 
6157 cd cb 0d			call cmp16 
615a ca 63 61			jp z, .chk_fault3 
615d 11 f6 61			ld de, sfaultro 
6160 c3 8c 61			jp .chk_fault 
6163			.chk_fault3:  
6163 2a 32 e9			ld hl, (chk_loop_ovr) 
6166 ed 5b b2 e2		ld de,(chk_word) 
616a				if DEBUG_STK_FAULT 
616a					DMARK "FA2" 
616a					CALLMONITOR 
616a				endif 
616a cd cb 0d			call cmp16 
616d ca 76 61			jp z, .chk_fault4 
6170 11 10 62			ld de, sfaultlo 
6173 c3 8c 61			jp .chk_fault 
6176			.chk_fault4:  
6176 2a 30 e8			ld hl, (chk_data_ovr) 
6179 ed 5b b2 e2		ld de,(chk_word) 
617d				if DEBUG_STK_FAULT 
617d					DMARK "FA3" 
617d					CALLMONITOR 
617d				endif 
617d cd cb 0d			call cmp16 
6180 ca 89 61			jp z, .chk_fault5 
6183 11 2a 62			ld de, sfaultdo 
6186 c3 8c 61			jp .chk_fault 
6189			 
6189			 
6189			.chk_fault5:  
6189 d1				pop de 
618a e1				pop hl 
618b			 
618b c9				ret 
618c			 
618c cd 80 0b		.chk_fault: 	call clear_display 
618f 3e 28				ld a, display_row_2 
6191 cd 93 0b				call str_at_display 
6194 11 ba 61				   ld de, .stackfault 
6197 3e 00				ld a, display_row_1 
6199 cd 93 0b				call str_at_display 
619c 11 71 ee				    ld de, debug_mark 
619f 3e 11				ld a, display_row_1+17 
61a1 cd 93 0b				call str_at_display 
61a4 cd a3 0b				call update_display 
61a7			 
61a7				; prompt before entering montior for investigating issue 
61a7			 
61a7 3e 78			ld a, display_row_4 
61a9 11 39 19			ld de, endprog 
61ac			 
61ac cd a3 0b			call update_display		 
61af			 
61af cd 97 1b			call next_page_prompt 
61b2			 
61b2 d1				pop de 
61b3 e1				pop hl 
61b4 cd 8d 19				call monitor 
61b7 c3 87 18				jp warmstart 
61ba					;jp 0 
61ba					;halt 
61ba			 
61ba			 
61ba			 
61ba .. 00		.stackfault: 	db "Stack fault:",0 
61c7			 
61c7 .. 00		sfaultsu: 	db	"Stack under flow",0 
61d8 .. 00		sfaultso: 	db	"Stack over flow",0 
61e8 .. 00		sfaultru:	db "RTS underflow",0 
61f6 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6210 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
622a .. 00		sfaultdo:	db "DTS overflow", 0 
6237			 
6237			 
6237			fault_dsp_under: 
6237 11 49 62			ld de, .dsp_under 
623a c3 f9 62			jp .show_fault 
623d			 
623d			fault_rsp_under: 
623d 11 57 62			ld de, .rsp_under 
6240 c3 f9 62			jp .show_fault 
6243			fault_loop_under: 
6243 11 65 62			ld de, .loop_under 
6246 c3 f9 62			jp .show_fault 
6249			 
6249 .. 00		.dsp_under: db "DSP Underflow",0 
6257 .. 00		.rsp_under: db "RSP Underflow",0 
6265 .. 00		.loop_under: db "LOOP Underflow",0 
6274			 
6274			 
6274 d5			type_faultn: 	push de 
6275 e5					push hl 
6276 cd 80 0b				call clear_display 
6279 11 a0 62				   ld de, .typefaultn 
627c 3e 00				ld a, display_row_1 
627e cd 93 0b				call str_at_display 
6281 11 71 ee				    ld de, debug_mark 
6284 3e 11				ld a, display_row_1+17 
6286 cd 93 0b				call str_at_display 
6289 cd a3 0b				call update_display 
628c			 
628c				; prompt before entering montior for investigating issue 
628c			 
628c 3e 78			ld a, display_row_4 
628e 11 39 19			ld de, endprog 
6291			 
6291 cd a3 0b			call update_display		 
6294			 
6294 cd 97 1b			call next_page_prompt 
6297			 
6297 e5					push hl 
6298 d5					push de 
6299 cd 8d 19				call monitor 
629c c3 87 18				jp warmstart 
629f 76					halt 
62a0			 
62a0			 
62a0 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
62b7			 
62b7 d5			type_faults: 	push de 
62b8 e5					push hl 
62b9 cd 80 0b				call clear_display 
62bc 11 e2 62				   ld de, .typefaults 
62bf 3e 00				ld a, display_row_1 
62c1 cd 93 0b				call str_at_display 
62c4 11 71 ee				    ld de, debug_mark 
62c7 3e 11				ld a, display_row_1+17 
62c9 cd 93 0b				call str_at_display 
62cc cd a3 0b				call update_display 
62cf			 
62cf				; prompt before entering montior for investigating issue 
62cf			 
62cf 3e 78			ld a, display_row_4 
62d1 11 39 19			ld de, endprog 
62d4			 
62d4 cd a3 0b			call update_display		 
62d7			 
62d7 cd 97 1b			call next_page_prompt 
62da			 
62da e1					pop hl 
62db d1					pop de 
62dc cd 8d 19				call monitor 
62df c3 87 18				jp warmstart 
62e2			 
62e2			 
62e2 .. 00		.typefaults: db "STR Type Expected TOS!",0 
62f9			 
62f9			.show_fault: 	 
62f9 d5					push de 
62fa cd 80 0b				call clear_display 
62fd d1					pop de 
62fe 3e 00				ld a, display_row_1 
6300 cd 93 0b				call str_at_display 
6303 11 71 ee				    ld de, debug_mark 
6306 3e 11				ld a, display_row_1+17 
6308 cd 93 0b				call str_at_display 
630b cd a3 0b				call update_display 
630e			 
630e				; prompt before entering montior for investigating issue 
630e			 
630e 3e 78			ld a, display_row_4 
6310 11 39 19			ld de, endprog 
6313			 
6313 cd a3 0b			call update_display		 
6316			 
6316 cd 97 1b			call next_page_prompt 
6319			 
6319 e1					pop hl 
631a d1					pop de 
631b cd 8d 19				call monitor 
631e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
631e			; TODO Make optional fault restart to cli or warm boot? 
631e					;jp warmstart 
631e c3 df 18				jp cli 
6321 76					halt 
6322			 
6322			; handle the auto run of code from files in storage 
6322			 
6322			 
6322			if STORAGE_SE 
6322			 
6322			sprompt3: db "Loading from start-up file?:",0 
6322			sprompt4: db "(Y=Any key/N=No)",0 
6322			 
6322			 
6322			forth_autoload: 
6322			 
6322				; load block 0 of store 1 
6322				 
6322				ld a, $fe      ; bit 0 clear 
6322				ld (spi_device), a 
6322			 
6322				call storage_get_block_0 
6322			 
6322				ld a, (store_page+STORE_0_AUTOFILE) 
6322			 
6322				cp 0 
6322				ret z     ; auto start not enabled 
6322			 
6322				call clear_display 
6322			 
6322				; set bank 
6322			 
6322					ld a, (store_page+STORE_0_BANKRUN) 
6322					ld (spi_device), a 
6322			 
6322				; get file id to load from and get the file name to display 
6322			 
6322					ld a, (store_page+STORE_0_FILERUN) 
6322			 
6322					ld l, 0 
6322					ld h, a 
6322					ld de, store_page 
6322			 
6322					if DEBUG_FORTH_WORDS 
6322						DMARK "ASp" 
6322						CALLMONITOR 
6322					endif 
6322					call storage_read 
6322			 
6322					if DEBUG_FORTH_WORDS 
6322						DMARK "ASr" 
6322						CALLMONITOR 
6322					endif 
6322			 
6322					call ishlzero 
6322					ret z             ; file not found 
6322			 
6322					ld a, display_row_2 + 10 
6322					ld de, store_page+3 
6322					call str_at_display 
6322				 
6322			; 
6322			 
6322				ld a, display_row_1+5 
6322				ld de, sprompt3 
6322				call str_at_display 
6322				ld a, display_row_3+15 
6322				ld de, sprompt4 
6322				call str_at_display 
6322			 
6322				call update_display 
6322			 
6322				call cin_wait 
6322				cp 'n' 
6322				ret z 
6322				cp 'N' 
6322				ret z 
6322			 
6322				call delay1s 
6322			 
6322				ld a, (store_page+2) 
6322				ld (store_openmaxext), a    ; save count of ext 
6322				ld a, 1  
6322				ld (store_openext), a    ; save count of ext 
6322			 
6322			.autof:  
6322				ld l , a 
6322				 
6322				ld a, (store_page) 
6322				ld h, a	 
6322				ld de, store_page 
6322					if DEBUG_FORTH_WORDS 
6322						DMARK "ASl" 
6322						CALLMONITOR 
6322					endif 
6322					call storage_read 
6322				call ishlzero 
6322				ret z 
6322			;	jr z, .autoend 
6322			 
6322					if DEBUG_FORTH_WORDS 
6322						DMARK "ASc" 
6322						CALLMONITOR 
6322					endif 
6322				ld de, store_page+2 
6322				ld a, display_row_4 
6322				call str_at_display 
6322			 
6322				call update_display 
6322				call delay250ms 
6322			 
6322			 
6322			 
6322				ld hl, store_page+2 
6322				call forthparse 
6322				call forthexec 
6322				call forthexec_cleanup 
6322			 
6322				 
6322				ld a, (store_openext) 
6322				inc a 
6322				ld (store_openext), a    ; save count of ext 
6322			 
6322				jr .autof 
6322			;.autofdone: 
6322			; 
6322			;		if DEBUG_FORTH_WORDS 
6322			;			DMARK "ASx" 
6322			;			CALLMONITOR 
6322			;		endif 
6322			;;	call clear_display 
6322			;	ret 
6322			 
6322			 
6322			 
6322			endif 
6322			 
6322			 
6322			; eof 
# End of file forth_kernel.asm
6322			;include "nascombasic.asm" 
6322			 
6322			 
6322			; find out where the code ends if loaded into RAM (for SC114) 
6322			;endofcode:  
6322			;	nop 
6322			 
6322			 
6322			; eof 
6322			 
# End of file main.asm
6322			;include "firmware_lcd_4x40.asm" 
6322			;;include "firmware_lcd_4x20.asm" 
6322			include "firmware_cpm_display.asm" 
6322			 
6322			; Serial display interface for SC114 
6322			 
6322			 
6322			display_row_1: equ 0 
6322			display_row_2: equ display_row_1+display_cols 
6322			display_row_3: equ display_row_2 + display_cols 
6322			display_row_4: equ display_row_3 + display_cols 
6322			 
6322			kLCDWidth:  EQU display_cols             ;Width in characters 
6322			kLCD_Line1: EQU 0x00  
6322			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6322			; E1 
6322			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6322			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6322			 
6322			lcd_init: 
6322				; no init as handled by the SCM bios 
6322 c9				ret 
6323			 
6323			 
6323			; low level functions for direct screen writes 
6323			 
6323			; output char at pos? 
6323			fLCD_Str: 
6323			        ;out (SC114_SIO_1_OUT),a 
6323 c5				push bc 
6324 d5				push de 
6325 5f				ld e, a 
6326			; TODO Replace with CP/M BIOS call 
6326 0e 02			ld c, $02 
6328 cd 05 00			call 5 
632b d1				pop de 
632c c1				pop bc 
632d c9				ret 
632e			 
632e			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
632e			fLCD_Pos: 
632e				; use ASCII escape to position 
632e			        ;out (SC114_SIO_1_OUT),a 
632e c5				push bc 
632f d5				push de 
6330 5f				ld e, a 
6331 0e 02			ld c, $02 
6333			; TODO Replace with CP/M BIOS call 
6333 cd 05 00			call 5 
6336 d1				pop de 
6337 c1				pop bc 
6338			 
6338 c9				ret 
6339			 
6339			; output char at pos 
6339			fLCD_Data: 
6339			      ;  out (SC114_SIO_1_OUT),a 
6339 c5				push bc 
633a d5				push de 
633b 0e 02			ld c, $02 
633d 5f				ld e, a 
633e			; TODO Replace with CP/M BIOS call 
633e cd 05 00			call 5 
6341 d1				pop de 
6342 c1				pop bc 
6343			 
6343 c9				ret 
6344			 
6344			; ascii cls  
6344			 
6344 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
6348			 
6348 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
635f			;.clscpm: db 3, $3c,"$" 
635f			 
635f			; write the frame buffer given in hl to hardware  
635f			write_display: 
635f			 
635f			API: equ 0 
635f			 
635f			if API 
635f				push bc 
635f				ld b, 4 
635f			 
635f			        ld (display_write_tmp), hl 	  
635f			 
635f				; clear and home cursor 
635f			 
635f				ld c, 9 
635f				ld de, .cls 
635f			; TODO Replace with CP/M BIOS call 
635f				call 5 
635f			 
635f			 
635f			.writeln: 
635f			 
635f				ld de, (display_write_tmp) 
635f				ld c, 6 
635f			; TODO Replace with CP/M BIOS call 
635f				rst $30 
635f				ld c, 7 
635f				rst $30 
635f			 
635f				ld hl, (display_write_tmp) 
635f				ld de, display_cols 
635f				add hl,de 
635f				ld (display_write_tmp),hl 
635f			 
635f				djnz  .writeln 
635f			 
635f				pop bc 
635f			 
635f			 
635f				ret 
635f			endif 
635f e5				push hl 
6360 c5				push bc 
6361 d5				push de 
6362			 
6362			;	ld c, 2 
6362			;	;ld de, .cls 
6362			;	ld a, 27 
6362			;	rst $30 
6362			;	ld c, 2 
6362			;	;ld de, .cls 
6362			;	ld a, '[' 
6362			;	rst $30 
6362			; 
6362			;	ld c, 2 
6362			;	;ld de, .cls 
6362			;	ld a, 'H' 
6362			;	rst $30 
6362			; 
6362			 
6362			 
6362			; lots of CR/LF 
6362			;	ld c, 9 
6362			;	ld de, .clscpm 
6362			;	call 5 
6362			 
6362			; xterm cls 
6362 0e 02			ld c, 2 
6364 1e 1b			ld e, 27 
6366 cd 05 00			call 5 
6369			; cls causes too much flicker 
6369			;	ld c, 2 
6369			;	ld e, 'c' 
6369			;	call 5 
6369			 
6369			; use xterm home instead 
6369 0e 02			ld c, 2 
636b 1e 5b			ld e, '[' 
636d cd 05 00			call 5 
6370 0e 02			ld c, 2 
6372 1e 48			ld e, 'H' 
6374 cd 05 00			call 5 
6377			LLL: equ 0 
6377			 
6377			if LLL 
6377			 
6377				ld c, 2 
6377				;ld de, .cls 
6377				ld e, 27 
6377			; TODO Replace with CP/M BIOS call 
6377				call 5 
6377			 
6377			 
6377				ld c, 2 
6377				;ld de, .cls 
6377				ld e, '[' 
6377			; TODO Replace with CP/M BIOS call 
6377				call 5 
6377				ld c, 2 
6377				;ld de, .cls 
6377				ld e, '2' 
6377			; TODO Replace with CP/M BIOS call 
6377				call 5 
6377				ld c, 2 
6377				;ld de, .cls 
6377				ld e, 'J' 
6377			; TODO Replace with CP/M BIOS call 
6377				call 5 
6377			 
6377			endif 
6377			 
6377 d1				pop de 
6378 c1				pop bc 
6379 e1				pop hl 
637a			 
637a			 
637a 22 cf eb		        ld (display_write_tmp), hl 	  
637d 3e 00			ld a, kLCD_Line1 
637f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
637f 06 28			ld b, display_cols 
6381 ed 5b cf eb		ld de, (display_write_tmp) 
6385 cd 08 64			call write_len_string 
6388				 
6388			 
6388 e5			push hl 
6389 d5			push de 
638a c5			push bc 
638b 0e 02			ld c, 2 
638d 1e 0a			ld e, 10 
638f cd 05 00			call 5 
6392 0e 02			ld c, 2 
6394 1e 0d			ld e, 13 
6396 cd 05 00			call 5 
6399			; TODO Replace with CP/M BIOS call 
6399				;rst $30 
6399 c1			pop bc 
639a d1			pop de 
639b e1			pop hl 
639c			 
639c				 
639c 2a cf eb			ld hl, (display_write_tmp) 
639f 11 28 00			ld de, display_cols 
63a2 19				add hl,de 
63a3 22 cf eb			ld (display_write_tmp),hl 
63a6			 
63a6				 
63a6 3e 28			ld a, kLCD_Line2 
63a8			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
63a8 06 28			ld b, display_cols 
63aa ed 5b cf eb		ld de, (display_write_tmp) 
63ae cd 08 64			call write_len_string 
63b1				 
63b1 2a cf eb			ld hl, (display_write_tmp) 
63b4 11 28 00			ld de, display_cols 
63b7 19				add hl,de 
63b8 22 cf eb			ld (display_write_tmp),hl 
63bb			 
63bb e5			push hl 
63bc d5			push de 
63bd c5			push bc 
63be 0e 07			ld c, 7 
63c0			; TODO Replace with CP/M BIOS call 
63c0				;rst $30 
63c0 0e 02			ld c, 2 
63c2 1e 0a			ld e, 10 
63c4 cd 05 00			call 5 
63c7 0e 02			ld c, 2 
63c9 1e 0d			ld e, 13 
63cb cd 05 00			call 5 
63ce c1			pop bc 
63cf d1			pop de 
63d0 e1			pop hl 
63d1			 
63d1				 
63d1 3e 50			ld a, kLCD_Line3 
63d3			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
63d3 06 28			ld b, display_cols 
63d5 ed 5b cf eb		ld de, (display_write_tmp) 
63d9 cd 08 64			call write_len_string 
63dc				 
63dc 2a cf eb			ld hl, (display_write_tmp) 
63df 11 28 00			ld de, display_cols 
63e2 19				add hl,de 
63e3 22 cf eb			ld (display_write_tmp),hl 
63e6			 
63e6 e5			push hl 
63e7 d5			push de 
63e8 c5			push bc 
63e9 0e 07			ld c, 7 
63eb			; TODO Replace with CP/M BIOS call 
63eb				;rst $30 
63eb 0e 02			ld c, 2 
63ed 1e 0a			ld e, 10 
63ef cd 05 00			call 5 
63f2 0e 02			ld c, 2 
63f4 1e 0d			ld e, 13 
63f6 cd 05 00			call 5 
63f9 c1			pop bc 
63fa d1			pop de 
63fb e1			pop hl 
63fc			 
63fc				 
63fc 3e 78			ld a, kLCD_Line4 
63fe			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
63fe 06 28			ld b, display_cols 
6400 ed 5b cf eb		ld de, (display_write_tmp) 
6404 cd 08 64			call write_len_string 
6407 c9					ret 
6408			 
6408			 
6408				; write out a fixed length string given in b from de 
6408			 
6408 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6409 cd 39 63		            CALL fLCD_Data      ;Write character to display 
640c 13				inc de 
640d 10 f9			djnz write_len_string 
640f c9				ret 
6410			 
6410			 
6410			; eof 
# End of file firmware_cpm_display.asm
6410			;include "firmware_key_5x10.asm" 
6410			;;include "firmware_key_4x10.asm" 
6410			include "firmware_key_cpm.asm" 
6410			; Serial keyboard interface for SC114 
6410			 
6410			 
6410			key_init: 
6410				; no init as handled by the SCM bios 
6410 c9				ret 
6411			 
6411			 
6411			cin_wait: 
6411			;	ld a, 0 
6411			;	ret 
6411			 
6411				;in a,(SC114_SIO_1_IN) 
6411			        ; Use SCM API to get from whatever console device we are using 
6411			 
6411			; TODO Replace with CP/M BIOS call 
6411 c5				push bc 
6412 0e 01			ld c, $01 
6414 cd 05 00			call 5 
6417 c1				pop bc 
6418 c9				ret 
6419			 
6419			cin: 
6419			 
6419			 
6419 c5				push bc 
641a			 
641a				; any key waiting to process? 
641a			; TODO Replace with CP/M BIOS call 
641a 0e 06			ld c, $06 
641c cd 05 00			call 5 
641f 28 0d			jr z, .cin_skip 
6421			 
6421				; yep, get it 
6421			 
6421 0e 01			ld c, $01 
6423			; TODO Replace with CP/M BIOS call 
6423 cd 05 00			call 5 
6426			 
6426 fe 7f			cp $7f     ; back space 
6428 20 02			jr nz, .skipbs 
642a 3e 08			ld a, KEY_BS 
642c			.skipbs: 
642c			 
642c c1				pop bc 
642d c9				ret 
642e			.cin_skip: 
642e 3e 00			ld a, 0 
6430 c1				pop bc 
6431 c9				ret 
6432			 
6432			 
6432			 
6432			 
# End of file firmware_key_cpm.asm
6432			endofcode:  
6432			baseram:  
6432 00				nop 
6433			 
6433			heap_start: equ baseram+15  ; Starting address of heap 
6433			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6433			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6433			;VDU:  EQU     endofcode           ; BASIC Work space 
6433			; eof 
6433			 
# End of file os_mega_cpm.asm
6433
